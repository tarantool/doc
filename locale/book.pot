# SOME DESCRIPTIVE TITLE.
# Copyright (C) 
# This file is distributed under the same license as the Tarantool package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Tarantool 2.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-10-22 14:30+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../doc/book/admin/backups.rst:5
#: ../doc/book/cartridge/cartridge_admin.rst:902
msgid "Backups"
msgstr ""

#: ../doc/book/admin/backups.rst:7
msgid "Tarantool has an append-only storage architecture: it appends data to files but it never overwrites earlier data. The :ref:`Tarantool garbage collector <cfg_checkpoint_daemon-garbage-collector>` removes old files after a checkpoint. You can prevent or delay the garbage collector's action by configuring the :ref:`checkpoint daemon <book_cfg_checkpoint_daemon>`. Backups can be taken at any time, with minimal overhead on database performance."
msgstr ""

#: ../doc/book/admin/backups.rst:20
msgid "backup.start() and backup.stop()"
msgstr ""

#: ../doc/book/admin/backups.rst:22
msgid "Two functions are helpful for backups in certain situations."
msgstr ""

#: ../doc/book/admin/backups.rst:24
msgid "``box.backup.start()`` informs the server that activities related to the removal of outdated backups must be suspended and returns a table with the names of snapshot and vinyl files that should be copied. Example:"
msgstr ""

#: ../doc/book/admin/backups.rst:28
msgid "tarantool> box.backup.start()\n"
"---\n"
"- - ./00000000000000000015.snap\n"
"  - ./00000000000000000000.vylog\n"
"  - ./513/0/00000000000000000002.index\n"
"  - ./513/0/00000000000000000002.run\n"
"..."
msgstr ""

#: ../doc/book/admin/backups.rst:40
msgid "To guarantee an opportunity to copy these files Tarantool will not delete them. But there will be no read-only mode and checkpoints will continue by schedule as usual."
msgstr ""

#: ../doc/book/admin/backups.rst:44
msgid "Later ``box.backup.stop()`` informs the server that normal operations may resume. Starting with Tarantool 1.10.1 there is a new optional argument, ``box.backup.start(n)``, where ``n`` indicates the checkpoint to use relative to the latest checkpoint -- for example ``n = 0`` means \"backup will be based on the latest checkpoint\", ``n = 1`` means \"backup will be based on the first checkpoint before the latest checkpoint (counting backwards)\", and so on, and the default value for ``n`` is zero."
msgstr ""

#: ../doc/book/admin/backups.rst:57
msgid "Hot backup (memtx)"
msgstr ""

#: ../doc/book/admin/backups.rst:59
msgid "This is a special case when there are only in-memory tables."
msgstr ""

#: ../doc/book/admin/backups.rst:61
msgid "The last :ref:`snapshot file <index-box_persistence>` is a backup of the entire database; and the :ref:`WAL <internals-wal>` files that are made after the last snapshot are incremental backups. Therefore taking a backup is a matter of copying the snapshot and WAL files."
msgstr ""

#: ../doc/book/admin/backups.rst:66
msgid "Use ``tar`` to make a (possibly compressed) copy of the latest .snap and .xlog files on the :ref:`memtx_dir <cfg_basic-memtx_dir>` and :ref:`wal_dir <cfg_basic-wal_dir>` directories."
msgstr ""

#: ../doc/book/admin/backups.rst:70
msgid "If there is a security policy, encrypt the .tar file."
msgstr ""

#: ../doc/book/admin/backups.rst:72
msgid "Copy the .tar file to a safe place."
msgstr ""

#: ../doc/book/admin/backups.rst:74
msgid "Later, restoring the database is a matter of taking the .tar file and putting its contents back in the ``memtx_dir`` and ``wal_dir`` directories."
msgstr ""

#: ../doc/book/admin/backups.rst:81
msgid "Hot backup (vinyl/memtx)"
msgstr ""

#: ../doc/book/admin/backups.rst:83
msgid "Vinyl stores its files in :ref:`vinyl_dir <cfg_basic-vinyl_dir>`, and creates a folder for each database space. Dump and compaction processes are append-only and create new files. The Tarantool garbage collector may remove old files after each checkpoint."
msgstr ""

#: ../doc/book/admin/backups.rst:88
msgid "To take a mixed backup:"
msgstr ""

#: ../doc/book/admin/backups.rst:90
msgid "Issue :ref:`box.backup.start() <admin-backups-backup_start>` on the :ref:`administrative console <admin-security>`. This will suspend garbage collection till the next ``box.backup.stop()`` and will return a list of files to back up."
msgstr ""

#: ../doc/book/admin/backups.rst:95
msgid "Copy the files from the list to a safe location. This will include memtx snapshot files, vinyl run and index files, at a state consistent with the last checkpoint."
msgstr ""

#: ../doc/book/admin/backups.rst:99
msgid "Issue ``box.backup.stop()`` so the garbage collector can continue."
msgstr ""

#: ../doc/book/admin/backups.rst:105
msgid "Continuous remote backup (memtx)"
msgstr ""

#: ../doc/book/admin/backups.rst:107
msgid "The :ref:`replication <replication>` feature is useful for backup as well as for load balancing."
msgstr ""

#: ../doc/book/admin/backups.rst:110
msgid "Therefore taking a backup is a matter of ensuring that any given replica is up to date, and doing a cold backup on it. Since all the other replicas continue to operate, this is not a cold backup from the end user’s point of view. This could be done on a regular basis, with a ``cron`` job or with a Tarantool fiber."
msgstr ""

#: ../doc/book/admin/backups.rst:119
msgid "Continuous backup (memtx)"
msgstr ""

#: ../doc/book/admin/backups.rst:121
msgid "The logged changes done since the last cold backup must be secured, while the system is running."
msgstr ""

#: ../doc/book/admin/backups.rst:124
msgid "For this purpose, you need a file copy utility that will do the copying remotely and continuously, copying only the parts of a write ahead log file that are changing. One such utility is `rsync <https://en.wikipedia.org/wiki/Rsync>`_."
msgstr ""

#: ../doc/book/admin/backups.rst:129
msgid "Alternatively, you need an ordinary file copy utility, but there should be frequent production of new snapshot files or new WAL files as changes occur, so that only the new files need to be copied."
msgstr ""

#: ../doc/book/admin/bug_reports.rst:5
msgid "Bug reports"
msgstr ""

#: ../doc/book/admin/bug_reports.rst:7
msgid "If you found a bug in Tarantool, you’re doing us a favor by taking the time to tell us about it."
msgstr ""

#: ../doc/book/admin/bug_reports.rst:10
msgid "Please create an issue at Tarantool repository at GitHub. We encourage you to include the following information:"
msgstr ""

#: ../doc/book/admin/bug_reports.rst:13
msgid "Steps needed to reproduce the bug, and an explanation why this differs from the expected behavior according to our manual. Please provide specific unique information. For example, instead of \"I can’t get certain information\", say \"box.space.x:delete() didn’t report what was deleted\"."
msgstr ""

#: ../doc/book/admin/bug_reports.rst:18
msgid "Your operating system name and version, the Tarantool name and version, and any unusual details about your machine and its configuration."
msgstr ""

#: ../doc/book/admin/bug_reports.rst:21
msgid "Related files like a :ref:`stack trace <admin-stack_traces>` or a Tarantool :ref:`log file <admin-logs>`."
msgstr ""

#: ../doc/book/admin/bug_reports.rst:24
msgid "If this is a feature request or if it affects a special category of users, be sure to mention that."
msgstr ""

#: ../doc/book/admin/bug_reports.rst:27
msgid "Usually within one or two workdays a Tarantool team member will write an acknowledgment, or some questions, or suggestions for a workaround."
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:5
msgid "Daemon supervision"
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:11
msgid "Server signals"
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:13
msgid "Tarantool processes these signals during the event loop in the transaction processor thread:"
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:22
msgid "Signal"
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:22
#: ../doc/book/box/box_schema.rst:131
#: ../doc/book/box/box_space.rst:284
#: ../doc/book/box/data_model.rst:924
msgid "Effect"
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:24
msgid "SIGHUP"
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:24
msgid "May cause log file rotation. See the :ref:`example <cfg_logging-logging_example>` in reference on Tarantool logging parameters."
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:28
msgid "SIGUSR1"
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:28
msgid "May cause a database checkpoint. See :ref:`box.snapshot <box-snapshot>`."
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:31
msgid "SIGTERM"
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:31
msgid "May cause graceful shutdown (information will be saved first)."
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:34
msgid "SIGINT (also known as keyboard interrupt)"
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:34
msgid "May cause graceful shutdown."
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:38
msgid "SIGKILL"
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:38
msgid "Causes an immediate shutdown."
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:41
msgid "Other signals will result in behavior defined by the operating system. Signals other than SIGKILL may be ignored, especially if Tarantool is executing a long-running procedure which prevents return to the event loop in the transaction processor thread."
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:50
msgid "Automatic instance restart"
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:52
msgid "On ``systemd``-enabled platforms, ``systemd`` automatically restarts all Tarantool instances in case of failure. To demonstrate it, let’s try to destroy an instance:"
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:56
msgid "$ systemctl status tarantool@my_app|grep PID\n"
"Main PID: 5885 (tarantool)\n"
"$ tarantoolctl enter my_app\n"
"/bin/tarantoolctl: Found my_app.lua in /etc/tarantool/instances.available\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/my_app.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/my_app.control\n"
"unix/:/var/run/tarantool/my_app.control> os.exit(-1)\n"
"/bin/tarantoolctl: unix/:/var/run/tarantool/my_app.control: Remote host closed connection"
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:67
msgid "Now let’s make sure that ``systemd`` has restarted the instance:"
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:69
msgid "$ systemctl status tarantool@my_app|grep PID\n"
"Main PID: 5914 (tarantool)"
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:74
msgid "Finally, let’s check the boot logs:"
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:76
msgid "$ journalctl -u tarantool@my_app -n 8\n"
"-- Logs begin at Fri 2016-01-08 12:21:53 MSK, end at Thu 2016-01-21 21:09:45 MSK. --\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: tarantool@my_app.service: Unit entered failed state.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: tarantool@my_app.service: Failed with result 'exit-code'.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: tarantool@my_app.service: Service hold-off time over, scheduling restart.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Stopped Tarantool Database Server.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Starting Tarantool Database Server...\n"
"Jan 21 21:09:45 localhost.localdomain tarantoolctl[5910]: /usr/bin/tarantoolctl: Found my_app.lua in /etc/tarantool/instances.available\n"
"Jan 21 21:09:45 localhost.localdomain tarantoolctl[5910]: /usr/bin/tarantoolctl: Starting instance...\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Started Tarantool Database Server."
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:93
msgid "Core dumps"
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:95
msgid "Tarantool makes a core dump if it receives any of the following signals: SIGSEGV, SIGFPE, SIGABRT or SIGQUIT. This is automatic if Tarantool crashes."
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:98
msgid "On ``systemd``-enabled platforms, ``coredumpctl`` automatically saves core dumps and stack traces in case of a crash. Here is a general \"how to\" for how to enable core dumps on a Unix system:"
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:102
msgid "Ensure session limits are configured to enable core dumps, i.e. say ``ulimit -c unlimited``. Check  \"man 5 core\" for other reasons why a core dump may not be produced."
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:106
msgid "Set a directory for writing core dumps to, and make sure that the directory is writable. On Linux, the directory path is set in a kernel parameter configurable via ``/proc/sys/kernel/core_pattern``."
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:110
msgid "Make sure that core dumps include stack trace information. If you use a binary Tarantool distribution, this is automatic. If you build Tarantool from source, you will not get detailed information if you pass ``-DCMAKE_BUILD_TYPE=Release`` to CMake."
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:115
msgid "To simulate a crash, you can execute an illegal command against a Tarantool instance:"
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:118
msgid "$ # !!! please never do this on a production system !!!\n"
"$ tarantoolctl enter my_app\n"
"unix/:/var/run/tarantool/my_app.control> require('ffi').cast('char *', 0)[0] = 48\n"
"/bin/tarantoolctl: unix/:/var/run/tarantool/my_app.control: Remote host closed connection"
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:125
msgid "Alternatively, if you know the process ID of the instance (here we refer to it as $PID), you can abort a Tarantool instance by running ``gdb`` debugger:"
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:128
msgid "$ gdb -batch -ex \"generate-core-file\" -p $PID"
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:132
msgid "or manually sending a SIGABRT signal:"
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:134
msgid "$ kill -SIGABRT $PID"
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:140
msgid "To find out the process id of the instance ($PID), you can:"
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:142
msgid "look it up in the instance's :ref:`box.info.pid <box_introspection-box_info>`,"
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:144
msgid "find it with ``ps -A | grep tarantool``, or"
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:146
msgid "say ``systemctl status tarantool@my_app|grep PID``."
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:148
msgid "On a ``systemd-enabled`` system, to see the latest crashes of the Tarantool daemon, say:"
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:151
msgid "$ coredumpctl list /usr/bin/tarantool\n"
"MTIME                            PID   UID   GID SIG PRESENT EXE\n"
"Sat 2016-01-23 15:21:24 MSK   20681  1000  1000   6   /usr/bin/tarantool\n"
"Sat 2016-01-23 15:51:56 MSK   21035   995   992   6   /usr/bin/tarantool"
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:158
msgid "To save a core dump into a file, say:"
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:160
msgid "$ coredumpctl -o filename.core info <pid>"
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:168
msgid "Stack traces"
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:170
msgid "Since Tarantool stores tuples in memory, core files may be large. For investigation, you normally don't need the whole file, but only a \"stack trace\" or \"backtrace\"."
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:174
msgid "To save a stack trace into a file, say:"
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:176
msgid "$ gdb -se \"tarantool\" -ex \"bt full\" -ex \"thread apply all bt\" --batch -c core> /tmp/tarantool_trace.txt"
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:180
#: ../doc/book/admin/instance_config.rst:120
#: ../doc/book/replication/repl_bootstrap.rst:39
msgid "where:"
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:182
msgid "\"tarantool\" is the path to the Tarantool executable,"
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:183
msgid "\"core\" is the path to the core file, and"
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:184
msgid "\"/tmp/tarantool_trace.txt\" is a sample path to a file for saving the stack trace."
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:188
msgid "Occasionally, you may find that the trace file contains output without debug symbols – the lines will contain ”??” instead of names. If this happens, check the instructions on these Tarantool wiki pages: `How to debug core dump of stripped tarantool <https://github.com/tarantool/tarantool/wiki/How-to-debug-core-dump-of-stripped-tarantool>`_ and `How to debug core from different OS <https://github.com/tarantool/tarantool/wiki/How-to-debug-core-from-different-OS>`_."
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:195
msgid "To see the stack trace and other useful information in console, say:"
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:197
msgid "$ coredumpctl info 21035\n"
"          PID: 21035 (tarantool)\n"
"          UID: 995 (tarantool)\n"
"          GID: 992 (tarantool)\n"
"       Signal: 6 (ABRT)\n"
"    Timestamp: Sat 2016-01-23 15:51:42 MSK (4h 36min ago)\n"
" Command Line: tarantool my_app.lua <running>\n"
"   Executable: /usr/bin/tarantool\n"
"Control Group: /system.slice/system-tarantool.slice/tarantool@my_app.service\n"
"         Unit: tarantool@my_app.service\n"
"        Slice: system-tarantool.slice\n"
"      Boot ID: 7c686e2ef4dc4e3ea59122757e3067e2\n"
"   Machine ID: a4a878729c654c7093dc6693f6a8e5ee\n"
"     Hostname: localhost.localdomain\n"
"      Message: Process 21035 (tarantool) of user 995 dumped core.\n"
"\n"
"               Stack trace of thread 21035:\n"
"               #0  0x00007f84993aa618 raise (libc.so.6)\n"
"               #1  0x00007f84993ac21a abort (libc.so.6)\n"
"               #2  0x0000560d0a9e9233 _ZL12sig_fatal_cbi (tarantool)\n"
"               #3  0x00007f849a211220 __restore_rt (libpthread.so.0)\n"
"               #4  0x0000560d0aaa5d9d lj_cconv_ct_ct (tarantool)\n"
"               #5  0x0000560d0aaa687f lj_cconv_ct_tv (tarantool)\n"
"               #6  0x0000560d0aaabe33 lj_cf_ffi_meta___newindex (tarantool)\n"
"               #7  0x0000560d0aaae2f7 lj_BC_FUNCC (tarantool)\n"
"               #8  0x0000560d0aa9aabd lua_pcall (tarantool)\n"
"               #9  0x0000560d0aa71400 lbox_call (tarantool)\n"
"               #10 0x0000560d0aa6ce36 lua_fiber_run_f (tarantool)\n"
"               #11 0x0000560d0a9e8d0c _ZL16fiber_cxx_invokePFiP13__va_list_tagES0_ (tarantool)\n"
"               #12 0x0000560d0aa7b255 fiber_loop (tarantool)\n"
"               #13 0x0000560d0ab38ed1 coro_init (tarantool)\n"
"               ..."
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:236
msgid "Debugger"
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:238
msgid "To start ``gdb`` debugger on the core dump, say:"
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:240
msgid "$ coredumpctl gdb <pid>"
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:244
msgid "It is highly recommended to install ``tarantool-debuginfo`` package to improve ``gdb`` experience, for example:"
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:247
msgid "$ dnf debuginfo-install tarantool"
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:251
msgid "``gdb`` also provides information about the debuginfo packages you need to install:"
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:254
msgid "$ gdb -p <pid>\n"
"...\n"
"Missing separate debuginfos, use: dnf debuginfo-install\n"
"glibc-2.22.90-26.fc24.x86_64 krb5-libs-1.14-12.fc24.x86_64\n"
"libgcc-5.3.1-3.fc24.x86_64 libgomp-5.3.1-3.fc24.x86_64\n"
"libselinux-2.4-6.fc24.x86_64 libstdc++-5.3.1-3.fc24.x86_64\n"
"libyaml-0.1.6-7.fc23.x86_64 ncurses-libs-6.0-1.20150810.fc24.x86_64\n"
"openssl-libs-1.0.2e-3.fc24.x86_64"
msgstr ""

#: ../doc/book/admin/daemon_supervision.rst:265
msgid "Symbolic names are present in stack traces even if you don’t have ``tarantool-debuginfo`` package installed."
msgstr ""

#: ../doc/book/admin/disaster_recovery.rst:5
#: ../doc/book/cartridge/cartridge_admin.rst:894
msgid "Disaster recovery"
msgstr ""

#: ../doc/book/admin/disaster_recovery.rst:7
msgid "The minimal fault-tolerant Tarantool configuration would be a :ref:`replication cluster<replication-topologies>` that includes a master and a replica, or two masters."
msgstr ""

#: ../doc/book/admin/disaster_recovery.rst:11
msgid "The basic recommendation is to configure all Tarantool instances in a cluster to create :ref:`snapshot files <index-box_persistence>` at a regular basis."
msgstr ""

#: ../doc/book/admin/disaster_recovery.rst:14
msgid "Here follow action plans for typical crash scenarios."
msgstr ""

#: ../doc/book/admin/disaster_recovery.rst:20
msgid "Master-replica"
msgstr ""

#: ../doc/book/admin/disaster_recovery.rst:22
msgid "Configuration: One master and one replica."
msgstr ""

#: ../doc/book/admin/disaster_recovery.rst:24
msgid "Problem: The master has crashed."
msgstr ""

#: ../doc/book/admin/disaster_recovery.rst:26
#: ../doc/book/admin/disaster_recovery.rst:93
msgid "Your actions:"
msgstr ""

#: ../doc/book/admin/disaster_recovery.rst:28
msgid "Ensure the master is stopped for good. For example, log in to the master machine and use ``systemctl stop tarantool@<instance_name>``."
msgstr ""

#: ../doc/book/admin/disaster_recovery.rst:31
msgid "Switch the replica to master mode by setting :ref:`box.cfg.read_only <cfg_basic-read_only>` parameter to *false* and let the load be handled by the replica (effective master)."
msgstr ""

#: ../doc/book/admin/disaster_recovery.rst:35
msgid "Set up a replacement for the crashed master on a spare host, with :ref:`replication <cfg_replication-replication>` parameter set to replica (effective master), so it begins to catch up with the new master’s state. The new instance should have :ref:`box.cfg.read_only <cfg_basic-read_only>` parameter set to *true*."
msgstr ""

#: ../doc/book/admin/disaster_recovery.rst:41
msgid "You lose the few transactions in the master :ref:`write ahead log file <index-box_persistence>`, which it may have not transferred to the replica before crash. If you were able to salvage the master .xlog file, you may be able to recover these. In order to do it:"
msgstr ""

#: ../doc/book/admin/disaster_recovery.rst:46
msgid "Find out the position of the crashed master, as reflected on the new master."
msgstr ""

#: ../doc/book/admin/disaster_recovery.rst:48
msgid "Find out instance UUID from the crashed master :ref:`xlog <internals-wal>`:"
msgstr ""

#: ../doc/book/admin/disaster_recovery.rst:50
msgid "$ head -5 *.xlog | grep Instance\n"
"Instance: ed607cad-8b6d-48d8-ba0b-dae371b79155"
msgstr ""

#: ../doc/book/admin/disaster_recovery.rst:55
msgid "On the new master, use the UUID to find the position:"
msgstr ""

#: ../doc/book/admin/disaster_recovery.rst:57
msgid "tarantool> box.info.vclock[box.space._cluster.index.uuid:select{'ed607cad-8b6d-48d8-ba0b-dae371b79155'}[1][1]]\n"
"---\n"
"- 23425\n"
"<...>"
msgstr ""

#: ../doc/book/admin/disaster_recovery.rst:64
msgid "Play the records from the crashed .xlog to the new master, starting from the new master position:"
msgstr ""

#: ../doc/book/admin/disaster_recovery.rst:67
msgid "Issue this request locally at the new master's machine to find out instance ID of the new master:"
msgstr ""

#: ../doc/book/admin/disaster_recovery.rst:70
#: ../doc/book/replication/repl_architecture.rst:92
msgid "tarantool> box.space._cluster:select{}\n"
"---\n"
"- - [1, '88580b5c-4474-43ab-bd2b-2409a9af80d2']\n"
"..."
msgstr ""

#: ../doc/book/admin/disaster_recovery.rst:77
msgid "Play the records to the new master:"
msgstr ""

#: ../doc/book/admin/disaster_recovery.rst:79
msgid "$ tarantoolctl <new_master_uri> <xlog_file> play --from 23425 --replica 1"
msgstr ""

#: ../doc/book/admin/disaster_recovery.rst:87
msgid "Master-master"
msgstr ""

#: ../doc/book/admin/disaster_recovery.rst:89
msgid "Configuration: Two masters."
msgstr ""

#: ../doc/book/admin/disaster_recovery.rst:91
msgid "Problem: Master#1 has crashed."
msgstr ""

#: ../doc/book/admin/disaster_recovery.rst:95
msgid "Let the load be handled by master#2 (effective master) alone."
msgstr ""

#: ../doc/book/admin/disaster_recovery.rst:97
msgid "2. Follow the same steps as in the :ref:`master-replica <admin-disaster_recovery-master_replica>` recovery scenario to create a new master and salvage lost data."
msgstr ""

#: ../doc/book/admin/disaster_recovery.rst:105
msgid "Data loss"
msgstr ""

#: ../doc/book/admin/disaster_recovery.rst:107
msgid "Configuration: Master-master or master-replica."
msgstr ""

#: ../doc/book/admin/disaster_recovery.rst:109
msgid "Problem: Data was deleted at one master and this data loss was propagated to the other node (master or replica)."
msgstr ""

#: ../doc/book/admin/disaster_recovery.rst:112
msgid "The following steps are applicable only to data in memtx storage engine. Your actions:"
msgstr ""

#: ../doc/book/admin/disaster_recovery.rst:115
msgid "Put all nodes in :ref:`read-only mode <cfg_basic-read_only>` and disable checkpointing with :ref:`box.backup.start() <admin-backups-backup_start>`. Disabling the checkpointing is necessary to prevent the Tarantool garbage collector from removing files made with older checkpoints."
msgstr ""

#: ../doc/book/admin/disaster_recovery.rst:121
msgid "Get the latest valid :ref:`.snap file <internals-snapshot>` and use ``tarantoolctl cat`` command to calculate at which lsn the data loss occurred."
msgstr ""

#: ../doc/book/admin/disaster_recovery.rst:124
msgid "Start a new instance (instance#1) and use ``tarantoolctl play`` command to play to it the contents of .snap/.xlog files up to the calculated lsn."
msgstr ""

#: ../doc/book/admin/disaster_recovery.rst:127
msgid "Bootstrap a new replica from the recovered master (instance#1)."
msgstr ""

#: ../doc/book/admin/index.rst:5
msgid "Server administration"
msgstr ""

#: ../doc/book/admin/index.rst:7
msgid "Tarantool is designed to have multiple running instances on the same host."
msgstr ""

#: ../doc/book/admin/index.rst:9
msgid "Here we show how to administer Tarantool instances using any of the following utilities:"
msgstr ""

#: ../doc/book/admin/index.rst:12
msgid "``systemd`` native utilities, or"
msgstr ""

#: ../doc/book/admin/index.rst:13
msgid ":ref:`tarantoolctl <tarantoolctl>`, a utility shipped and installed as part of Tarantool distribution."
msgstr ""

#: ../doc/book/admin/index.rst:18
msgid "Unlike the rest of this manual, here we use system-wide paths."
msgstr ""

#: ../doc/book/admin/index.rst:19
msgid "Console examples here are for Fedora."
msgstr ""

#: ../doc/book/admin/index.rst:21
#: ../doc/book/replication/index.rst:11
msgid "This chapter includes the following sections:"
msgstr ""

#: ../doc/book/admin/instance_config.rst:5
msgid "Instance configuration"
msgstr ""

#: ../doc/book/admin/instance_config.rst:7
msgid "For each Tarantool instance, you need two files:"
msgstr ""

#: ../doc/book/admin/instance_config.rst:9
msgid "[Optional] An :ref:`application file <app_server-launching_app>` with instance-specific logic. Put this file into the ``/usr/share/tarantool/`` directory."
msgstr ""

#: ../doc/book/admin/instance_config.rst:13
msgid "For example, ``/usr/share/tarantool/my_app.lua`` (here we implement it as a :ref:`Lua module <app_server-modules>` that bootstraps the database and exports ``start()`` function for API calls):"
msgstr ""

#: ../doc/book/admin/instance_config.rst:17
msgid "local function start()\n"
"    box.schema.space.create(\"somedata\")\n"
"    box.space.somedata:create_index(\"primary\")\n"
"    <...>\n"
"end\n"
"\n"
"return {\n"
"  start = start;\n"
"}"
msgstr ""

#: ../doc/book/admin/instance_config.rst:29
msgid "An :ref:`instance file <admin-instance_file>` with instance-specific initialization logic and parameters. Put this file, or a symlink to it, into the **instance directory** (see :ref:`instance_dir <admin-instance_dir>` parameter in ``tarantoolctl`` configuration file)."
msgstr ""

#: ../doc/book/admin/instance_config.rst:35
msgid "For example, ``/etc/tarantool/instances.enabled/my_app.lua`` (here we load ``my_app.lua`` module and make a call to ``start()`` function from that module):"
msgstr ""

#: ../doc/book/admin/instance_config.rst:39
msgid "#!/usr/bin/env tarantool\n"
"\n"
"box.cfg {\n"
"    listen = 3301;\n"
"}\n"
"\n"
"-- load my_app module and call start() function\n"
"-- with some app options controlled by sysadmins\n"
"local m = require('my_app').start({...})"
msgstr ""

#: ../doc/book/admin/instance_config.rst:55
msgid "Instance file"
msgstr ""

#: ../doc/book/admin/instance_config.rst:57
msgid "After this short introduction, you may wonder what an instance file is, what it is for, and how ``tarantoolctl`` uses it. After all, Tarantool is an application server, so why not start the application stored in ``/usr/share/tarantool`` directly?"
msgstr ""

#: ../doc/book/admin/instance_config.rst:62
msgid "A typical Tarantool application is not a script, but a daemon running in background mode and processing requests, usually sent to it over a TCP/IP socket. This daemon needs to be started automatically when the operating system starts, and managed with the operating system standard tools for service management -- such as ``systemd`` or ``init.d``. To serve this very purpose, we created **instance files**."
msgstr ""

#: ../doc/book/admin/instance_config.rst:69
msgid "You can have more than one instance file. For example, a single application in ``/usr/share/tarantool`` can run in multiple instances, each of them having its own instance file. Or you can have multiple applications in ``/usr/share/tarantool`` -- again, each of them having its own instance file."
msgstr ""

#: ../doc/book/admin/instance_config.rst:74
msgid "An instance file is typically created by a system administrator. An application file is often provided by a developer, in a Lua rock or an rpm/deb package."
msgstr ""

#: ../doc/book/admin/instance_config.rst:77
msgid "An instance file is designed to not differ in any way from a Lua application. It must, however, configure the database, i.e. contain a call to :ref:`box.cfg{} <box_introspection-box_cfg>` somewhere in it, because it’s the only way to turn a Tarantool script into a background process, and ``tarantoolctl`` is a tool to manage background processes. Other than that, an instance file may contain arbitrary Lua code, and, in theory, even include the entire application business logic in it. We, however, do not recommend this, since it clutters the instance file and leads to unnecessary copy-paste when you need to run multiple instances of an application."
msgstr ""

#: ../doc/book/admin/instance_config.rst:91
msgid "`tarantoolctl` configuration file"
msgstr ""

#: ../doc/book/admin/instance_config.rst:93
msgid "While instance files contain instance configuration, the ``tarantoolctl`` configuration file contains the configuration that ``tarantoolctl`` uses to override instance configuration. In other words, it contains system-wide configuration defaults. If ``tarantoolctl`` fails to find this file with the method described in section :ref:`Starting/stopping an instance <admin-start_stop_instance>`, it uses default settings."
msgstr ""

#: ../doc/book/admin/instance_config.rst:101
msgid "Most of the parameters are similar to those used by :ref:`box.cfg{} <box_introspection-box_cfg>`. Here are the default settings (possibly installed in ``/etc/default/tarantool`` or ``/etc/sysconfig/tarantool`` as part of Tarantool distribution -- see OS-specific default paths in :ref:`Notes for operating systems <admin-os_notes>`):"
msgstr ""

#: ../doc/book/admin/instance_config.rst:107
msgid "default_cfg = {\n"
"    pid_file  = \"/var/run/tarantool\",\n"
"    wal_dir   = \"/var/lib/tarantool\",\n"
"    memtx_dir = \"/var/lib/tarantool\",\n"
"    vinyl_dir = \"/var/lib/tarantool\",\n"
"    log       = \"/var/log/tarantool\",\n"
"    username  = \"tarantool\",\n"
"    language  = \"Lua\",\n"
"}\n"
"instance_dir = \"/etc/tarantool/instances.enabled\""
msgstr ""

#: ../doc/book/admin/instance_config.rst:0
msgid "``pid_file``"
msgstr ""

#: ../doc/book/admin/instance_config.rst:0
msgid "Directory for the pid file and control-socket file; ``tarantoolctl`` will add “/instance_name” to the directory name."
msgstr ""

#: ../doc/book/admin/instance_config.rst:0
msgid "``wal_dir``"
msgstr ""

#: ../doc/book/admin/instance_config.rst:0
msgid "Directory for write-ahead .xlog files; ``tarantoolctl`` will add \"/instance_name\" to the directory name."
msgstr ""

#: ../doc/book/admin/instance_config.rst:0
msgid "``memtx_dir``"
msgstr ""

#: ../doc/book/admin/instance_config.rst:0
msgid "Directory for snapshot .snap files; ``tarantoolctl`` will add \"/instance_name\" to the directory name."
msgstr ""

#: ../doc/book/admin/instance_config.rst:0
msgid "``vinyl_dir``"
msgstr ""

#: ../doc/book/admin/instance_config.rst:0
msgid "Directory for vinyl files; ``tarantoolctl`` will add \"/instance_name\" to the directory name."
msgstr ""

#: ../doc/book/admin/instance_config.rst:0
msgid "``log``"
msgstr ""

#: ../doc/book/admin/instance_config.rst:0
msgid "The place where the application log will go; ``tarantoolctl`` will add \"/instance_name.log\" to the name."
msgstr ""

#: ../doc/book/admin/instance_config.rst:0
msgid "``username``"
msgstr ""

#: ../doc/book/admin/instance_config.rst:0
msgid "The user that runs the Tarantool instance. This is the operating-system user name rather than the Tarantool-client user name. Tarantool will change its effective user to this user after becoming a daemon."
msgstr ""

#: ../doc/book/admin/instance_config.rst:0
msgid "``language``"
msgstr ""

#: ../doc/book/admin/instance_config.rst:0
msgid "The :ref:`interactive console <interactive_console>` language. Can be either ``Lua`` or ``SQL``."
msgstr ""

#: ../doc/book/admin/instance_config.rst:0
msgid "``instance_dir``"
msgstr ""

#: ../doc/book/admin/instance_config.rst:0
msgid "The directory where all instance files for this host are stored. Put instance files in this directory, or create symbolic links."
msgstr ""

#: ../doc/book/admin/instance_config.rst:156
msgid "The default instance directory depends on Tarantool's ``WITH_SYSVINIT`` build option: when ON, it is ``/etc/tarantool/instances.enabled``, otherwise (OFF or not set) it is ``/etc/tarantool/instances.available``. The latter case is typical for Tarantool builds for Linux distros with ``systemd``."
msgstr ""

#: ../doc/book/admin/instance_config.rst:162
msgid "To check the build options, say ``tarantool --version``."
msgstr ""

#: ../doc/book/admin/instance_config.rst:164
msgid "As a full-featured example, you can take `example.lua <https://github.com/tarantool/tarantool/blob/2.1/extra/dist/example.lua>`_ script that ships with Tarantool and defines all configuration options."
msgstr ""

#: ../doc/book/admin/logs.rst:5
msgid "Logs"
msgstr ""

#: ../doc/book/admin/logs.rst:7
msgid "Tarantool logs important events to a file, e.g. ``/var/log/tarantool/my_app.log``. To build the log file path, ``tarantoolctl`` takes the instance name, prepends the instance directory and appends “.log” extension."
msgstr ""

#: ../doc/book/admin/logs.rst:11
msgid "Let’s write something to the log file:"
msgstr ""

#: ../doc/book/admin/logs.rst:13
msgid "$ tarantoolctl enter my_app\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/my_app.control\n"
"unix/:/var/run/tarantool/my_app.control> require('log').info(\"Hello for the manual readers\")\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/admin/logs.rst:21
msgid "Then check the logs:"
msgstr ""

#: ../doc/book/admin/logs.rst:23
msgid "$ tail /var/log/tarantool/my_app.log\n"
"2017-04-04 15:54:04.977 [29255] main/101/tarantoolctl C> version 1.7.3-382-g68ef3f6a9\n"
"2017-04-04 15:54:04.977 [29255] main/101/tarantoolctl C> log level 5\n"
"2017-04-04 15:54:04.978 [29255] main/101/tarantoolctl I> mapping 134217728 bytes for tuple arena...\n"
"2017-04-04 15:54:04.985 [29255] iproto/101/main I> binary: bound to [::1]:3301\n"
"2017-04-04 15:54:04.986 [29255] main/101/tarantoolctl I> recovery start\n"
"2017-04-04 15:54:04.986 [29255] main/101/tarantoolctl I> recovering from `/var/lib/tarantool/my_app/00000000000000000000.snap'\n"
"2017-04-04 15:54:04.988 [29255] main/101/tarantoolctl I> ready to accept requests\n"
"2017-04-04 15:54:04.988 [29255] main/101/tarantoolctl I> set 'checkpoint_interval' configuration option to 3600\n"
"2017-04-04 15:54:04.988 [29255] main/101/my_app I> Run console at unix/:/var/run/tarantool/my_app.control\n"
"2017-04-04 15:54:04.989 [29255] main/106/console/unix/:/var/ I> started\n"
"2017-04-04 15:54:04.989 [29255] main C> entering the event loop\n"
"2017-04-04 15:54:47.147 [29255] main/107/console/unix/: I> Hello for the manual readers"
msgstr ""

#: ../doc/book/admin/logs.rst:39
msgid "When logging to a file, the system administrator must ensure logs are rotated timely and do not take up all the available disk space. With ``tarantoolctl``, log rotation is pre-configured to use ``logrotate`` program, which you must have installed."
msgstr ""

#: ../doc/book/admin/logs.rst:44
msgid "File ``/etc/logrotate.d/tarantool`` is part of the standard Tarantool distribution, and you can modify it to change the default behavior. This is what this file is usually like:"
msgstr ""

#: ../doc/book/admin/logs.rst:48
msgid "/var/log/tarantool/*.log {\n"
"    daily\n"
"    size 512k\n"
"    missingok\n"
"    rotate 10\n"
"    compress\n"
"    delaycompress\n"
"    create 0640 tarantool adm\n"
"    postrotate\n"
"        /usr/bin/tarantoolctl logrotate `basename ${1%%.*}`\n"
"    endscript\n"
"}"
msgstr ""

#: ../doc/book/admin/logs.rst:63
msgid "If you use a different log rotation program, you can invoke ``tarantoolctl logrotate`` command to request instances to reopen their log files after they were moved by the program of your choice."
msgstr ""

#: ../doc/book/admin/logs.rst:67
msgid "Tarantool can write its logs to a log file, ``syslog`` or a program specified in the configuration file (see :ref:`log <cfg_logging-log>` parameter)."
msgstr ""

#: ../doc/book/admin/logs.rst:70
msgid "By default, logs are written to a file as defined in ``tarantoolctl`` defaults. ``tarantoolctl`` automatically detects if an instance is using ``syslog`` or an external program for logging, and does not override the log destination in this case. In such configurations, log rotation is usually handled by the external program used for logging. So, ``tarantoolctl logrotate`` command works only if logging-into-file is enabled in the instance file."
msgstr ""

#: ../doc/book/admin/os_notes.rst:5
msgid "Notes for operating systems"
msgstr ""

#: ../doc/book/admin/os_notes.rst:11
msgid "Mac OS"
msgstr ""

#: ../doc/book/admin/os_notes.rst:13
msgid "On Mac OS, you can administer Tarantool instances only with ``tarantoolctl``. No native system tools are supported."
msgstr ""

#: ../doc/book/admin/os_notes.rst:20
msgid "FreeBSD"
msgstr ""

#: ../doc/book/admin/os_notes.rst:22
msgid "To make ``tarantoolctl`` work along with ``init.d`` utilities on FreeBSD, use paths other than those suggested in :ref:`Instance configuration <admin-instance_config>`. Instead of ``/usr/share/tarantool/`` directory, use ``/usr/local/etc/tarantool/`` and create the following subdirectories:"
msgstr ""

#: ../doc/book/admin/os_notes.rst:28
msgid "``default`` for ``tarantoolctl`` defaults (see example below),"
msgstr ""

#: ../doc/book/admin/os_notes.rst:29
msgid "``instances.available`` for all available instance files, and"
msgstr ""

#: ../doc/book/admin/os_notes.rst:30
msgid "``instances.enabled`` for instance files to be auto-started by sysvinit."
msgstr ""

#: ../doc/book/admin/os_notes.rst:32
msgid "Here is an example of ``tarantoolctl`` defaults on FreeBSD:"
msgstr ""

#: ../doc/book/admin/os_notes.rst:34
msgid "default_cfg = {\n"
"    pid_file   = \"/var/run/tarantool\", -- /var/run/tarantool/${INSTANCE}.pid\n"
"    wal_dir    = \"/var/db/tarantool\", -- /var/db/tarantool/${INSTANCE}/\n"
"    snap_dir   = \"/var/db/tarantool\", -- /var/db/tarantool/${INSTANCE}\n"
"    vinyl_dir = \"/var/db/tarantool\", -- /var/db/tarantool/${INSTANCE}\n"
"    logger     = \"/var/log/tarantool\", -- /var/log/tarantool/${INSTANCE}.log\n"
"    username   = \"tarantool\",\n"
"}\n"
"\n"
"-- instances.available - all available instances\n"
"-- instances.enabled - instances to autostart by sysvinit\n"
"instance_dir = \"/usr/local/etc/tarantool/instances.available\""
msgstr ""

#: ../doc/book/admin/os_notes.rst:53
msgid "Gentoo Linux"
msgstr ""

#: ../doc/book/admin/os_notes.rst:55
msgid "The section below is about a dev-db/tarantool package installed from the official layman overlay (named ``tarantool``)."
msgstr ""

#: ../doc/book/admin/os_notes.rst:58
msgid "The default instance directory is ``/etc/tarantool/instances.available``, can be redefined in ``/etc/default/tarantool``."
msgstr ""

#: ../doc/book/admin/os_notes.rst:61
msgid "Tarantool instances can be managed (start/stop/reload/status/...) using OpenRC. Consider the example how to create an OpenRC-managed instance:"
msgstr ""

#: ../doc/book/admin/os_notes.rst:64
msgid "$ cd /etc/init.d\n"
"$ ln -s tarantool your_service_name\n"
"$ ln -s /usr/share/tarantool/your_service_name.lua /etc/tarantool/instances.available/your_service_name.lua"
msgstr ""

#: ../doc/book/admin/os_notes.rst:70
msgid "Checking that it works:"
msgstr ""

#: ../doc/book/admin/os_notes.rst:72
msgid "$ /etc/init.d/your_service_name start\n"
"$ tail -f -n 100 /var/log/tarantool/your_service_name.log"
msgstr ""

#: ../doc/book/admin/security.rst:5
msgid "Security"
msgstr ""

#: ../doc/book/admin/security.rst:7
msgid "Tarantool allows for two types of connections:"
msgstr ""

#: ../doc/book/admin/security.rst:9
msgid "With :ref:`console.listen() <console-listen>` function from ``console`` module, you can set up a port which can be used to open an administrative console to the server. This is for administrators to connect to a running instance and make requests. ``tarantoolctl`` invokes ``console.listen()`` to create a control socket for each started instance."
msgstr ""

#: ../doc/book/admin/security.rst:15
msgid "With :ref:`box.cfg{listen=...} <cfg_basic-listen>` parameter from ``box`` module, you can set up a binary port for connections which read and write to the database or invoke stored procedures."
msgstr ""

#: ../doc/book/admin/security.rst:19
msgid "When you connect to an admin console:"
msgstr ""

#: ../doc/book/admin/security.rst:21
msgid "The client-server protocol is plain text."
msgstr ""

#: ../doc/book/admin/security.rst:22
msgid "No password is necessary."
msgstr ""

#: ../doc/book/admin/security.rst:23
msgid "The user is automatically 'admin'."
msgstr ""

#: ../doc/book/admin/security.rst:24
msgid "Each command is fed directly to the built-in Lua interpreter."
msgstr ""

#: ../doc/book/admin/security.rst:26
msgid "Therefore you must set up ports for the admin console very cautiously. If it is a TCP port, it should only be opened for a specific IP. Ideally, it should not be a TCP port at all, it should be a Unix domain socket, so that access to the server machine is required. Thus a typical port setup for admin console is:"
msgstr ""

#: ../doc/book/admin/security.rst:31
msgid "console.listen('/var/lib/tarantool/socket_name.sock')"
msgstr ""

#: ../doc/book/admin/security.rst:35
msgid "and a typical connection :ref:`URI <index-uri>` is:"
msgstr ""

#: ../doc/book/admin/security.rst:37
msgid "/var/lib/tarantool/socket_name.sock"
msgstr ""

#: ../doc/book/admin/security.rst:41
msgid "if the listener has the privilege to write on ``/var/lib/tarantool`` and the connector has the privilege to read on ``/var/lib/tarantool``. Alternatively, to connect to an admin console of an instance started with ``tarantoolctl``, use :ref:`tarantoolctl enter <admin-executing_code_on_an_instance>`."
msgstr ""

#: ../doc/book/admin/security.rst:46
msgid "To find out whether a TCP port is a port for admin console, use ``telnet``. For example:"
msgstr ""

#: ../doc/book/admin/security.rst:49
msgid "$ telnet 0 3303\n"
"Trying 0.0.0.0...\n"
"Connected to 0.\n"
"Escape character is '^]'.\n"
"Tarantool 2.1.0 (Lua console)\n"
"type 'help' for interactive help"
msgstr ""

#: ../doc/book/admin/security.rst:58
msgid "In this example, the response does not include the word \"binary\" and does include the words \"Lua console\". Therefore it is clear that this is a successful connection to a port for admin console, and you can now enter admin requests on this terminal."
msgstr ""

#: ../doc/book/admin/security.rst:63
msgid "When you connect to a binary port:"
msgstr ""

#: ../doc/book/admin/security.rst:65
msgid "The client-server protocol is :ref:`binary <box_protocol-iproto_protocol>`."
msgstr ""

#: ../doc/book/admin/security.rst:66
msgid "The user is automatically ':ref:`guest <authentication-users>`'."
msgstr ""

#: ../doc/book/admin/security.rst:67
msgid "To change the user, it’s necessary to authenticate."
msgstr ""

#: ../doc/book/admin/security.rst:69
msgid "For ease of use, ``tarantoolctl connect`` command automatically detects the type of connection during handshake and uses :ref:`EVAL <box_protocol-eval>` binary protocol command when it’s necessary to execute Lua commands over a binary connection. To execute EVAL, the authenticated user must have global \"EXECUTE\" privilege."
msgstr ""

#: ../doc/book/admin/security.rst:75
msgid "Therefore, when ``ssh`` access to the machine is not available, creating a Tarantool user with global \"EXECUTE\" privilege and non-empty password can be used to provide a system administrator **remote** access to an instance."
msgstr ""

#: ../doc/book/admin/server_introspection.rst:5
msgid "Server introspection"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:11
msgid "Using Tarantool as a client"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:13
msgid "Tarantool enters the interactive mode if:"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:15
msgid "you start Tarantool without an :ref:`instance file <admin-instance_file>`, or"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:18
msgid "the instance file contains :ref:`console.start() <console-start>`."
msgstr ""

#: ../doc/book/admin/server_introspection.rst:20
msgid "Tarantool displays a prompt (e.g. \"tarantool>\") and you can enter requests. When used this way, Tarantool can be a client for a remote server. See basic examples in :ref:`Getting started <getting_started>`."
msgstr ""

#: ../doc/book/admin/server_introspection.rst:24
msgid "The interactive mode is used by ``tarantoolctl`` to implement \"enter\" and \"connect\" commands."
msgstr ""

#: ../doc/book/admin/server_introspection.rst:31
msgid "Executing code on an instance"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:33
msgid "You can attach to an instance's :ref:`admin console <admin-security>` and execute some Lua code using ``tarantoolctl``:"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:36
msgid "$ # for local instances:\n"
"$ tarantoolctl enter my_app\n"
"/bin/tarantoolctl: Found my_app.lua in /etc/tarantool/instances.available\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/my_app.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/my_app.control\n"
"unix/:/var/run/tarantool/my_app.control> 1 + 1\n"
"---\n"
"- 2\n"
"...\n"
"unix/:/var/run/tarantool/my_app.control>\n"
"\n"
"$ # for local and remote instances:\n"
"$ tarantoolctl connect username:password@127.0.0.1:3306"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:52
msgid "You can also use ``tarantoolctl`` to execute Lua code on an instance without attaching to its admin console. For example:"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:55
msgid "$ # executing commands directly from the command line\n"
"$ <command> | tarantoolctl eval my_app\n"
"<...>\n"
"\n"
"$ # - OR -\n"
"\n"
"$ # executing commands from a script file\n"
"$ tarantoolctl eval my_app script.lua\n"
"<...>"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:69
msgid "Alternatively, you can use the :ref:`console <console-module>` module or the :ref:`net.box <net_box-module>` module from a Tarantool server. Also, you can write your client programs with any of the :ref:`connectors <index-box_connectors>`. However, most of the examples in this manual illustrate usage with either ``tarantoolctl connect`` or :ref:`using the Tarantool server as a client <admin-using_tarantool_as_a_client>`."
msgstr ""

#: ../doc/book/admin/server_introspection.rst:80
msgid "Health checks"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:82
msgid "To check the instance status, say:"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:84
msgid "$ tarantoolctl status my_app\n"
"my_app is running (pid: /var/run/tarantool/my_app.pid)\n"
"\n"
"$ # - OR -\n"
"\n"
"$ systemctl status tarantool@my_app\n"
"tarantool@my_app.service - Tarantool Database Server\n"
"Loaded: loaded (/etc/systemd/system/tarantool@.service; disabled; vendor preset: disabled)\n"
"Active: active (running)\n"
"Docs: man:tarantool(1)\n"
"Process: 5346 ExecStart=/usr/bin/tarantoolctl start %I (code=exited, status=0/SUCCESS)\n"
"Main PID: 5350 (tarantool)\n"
"Tasks: 11 (limit: 512)\n"
"CGroup: /system.slice/system-tarantool.slice/tarantool@my_app.service\n"
"+ 5350 tarantool my_app.lua <running>"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:102
msgid "To check the boot log, on systems with ``systemd``, say:"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:104
msgid "$ journalctl -u tarantool@my_app -n 5\n"
"-- Logs begin at Fri 2016-01-08 12:21:53 MSK, end at Thu 2016-01-21 21:17:47 MSK. --\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Stopped Tarantool Database Server.\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Starting Tarantool Database Server...\n"
"Jan 21 21:17:47 localhost.localdomain tarantoolctl[5969]: /usr/bin/tarantoolctl: Found my_app.lua in /etc/tarantool/instances.available\n"
"Jan 21 21:17:47 localhost.localdomain tarantoolctl[5969]: /usr/bin/tarantoolctl: Starting instance...\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Started Tarantool Database Server"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:114
msgid "For more details, use the reports provided by functions in the following submodules:"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:116
msgid ":ref:`box.cfg <box_introspection-box_cfg>` submodule (check and specify all configuration parameters for the Tarantool server)"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:119
msgid ":ref:`box.slab <box_introspection-box_slab>` submodule (monitor the total use and fragmentation of memory allocated for storing data in Tarantool)"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:122
msgid ":ref:`box.info <box_introspection-box_info>` submodule (introspect Tarantool server variables, primarily those related to replication)"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:125
msgid ":ref:`box.stat <box_introspection-box_stat>` submodule (introspect Tarantool request and network statistics)"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:128
msgid "You can also try `tarantool/prometheus <https://github.com/tarantool/prometheus>`_, a Lua module that makes it easy to collect metrics (e.g. memory usage or number of requests) from Tarantool applications and databases and expose them via the Prometheus protocol."
msgstr ""

#: ../doc/book/admin/server_introspection.rst:133
#: ../doc/book/admin/server_introspection.rst:643
#: ../doc/book/box/authentication.rst:300
#: ../doc/book/box/box_schema.rst:186
#: ../doc/book/box/box_session.rst:182
#: ../doc/book/box/box_session.rst:240
#: ../doc/book/box/box_session.rst:270
#: ../doc/book/box/box_session.rst:316
#: ../doc/book/box/box_session.rst:557
#: ../doc/book/box/triggers.rst:89
msgid "**Example**"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:135
msgid "A very popular administrator request is :ref:`box.slab.info() <box_slab_info>`, which displays detailed memory usage statistics for a Tarantool instance."
msgstr ""

#: ../doc/book/admin/server_introspection.rst:138
msgid "tarantool> box.slab.info()\n"
"---\n"
"- items_size: 228128\n"
"  items_used_ratio: 1.8%\n"
"  quota_size: 1073741824\n"
"  quota_used_ratio: 0.8%\n"
"  arena_used_ratio: 43.2%\n"
"  items_used: 4208\n"
"  quota_used: 8388608\n"
"  arena_size: 2325176\n"
"  arena_used: 1003632\n"
"..."
msgstr ""

#: ../doc/book/admin/server_introspection.rst:153
msgid "Tarantool takes memory from the operating system, for example when a user does many insertions. You can see how much it has taken by saying (on Linux):"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:157
msgid "ps -eo args,%mem | grep \"tarantool\""
msgstr ""

#: ../doc/book/admin/server_introspection.rst:161
msgid "Tarantool almost never releases this memory, even if the user deletes everything that was inserted, or reduces fragmentation by calling the Lua garbage collector via the `collectgarbage function <https://www.lua.org/manual/5.1/manual.html#pdf-collectgarbage>`_."
msgstr ""

#: ../doc/book/admin/server_introspection.rst:166
msgid "Ordinarily this does not affect performance. But, to force Tarantool to release memory, you can call :ref:`box.snapshot <box-snapshot>`, stop the server instance, and restart it."
msgstr ""

#: ../doc/book/admin/server_introspection.rst:175
msgid "Profiling performance issues"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:177
msgid "Tarantool can at times work slower than usual. There can be multiple reasons, such as disk issues, CPU-intensive Lua scripts or misconfiguration. Tarantool’s log may lack details in such cases, so the only indications that something goes wrong are log entries like this: ``W> too long DELETE: 8.546 sec``. Here are tools and techniques that can help you collect Tarantool’s performance profile, which is helpful in troubleshooting slowdowns."
msgstr ""

#: ../doc/book/admin/server_introspection.rst:186
msgid "Most of these tools -- except ``fiber.info()`` -- are intended for generic GNU/Linux distributions, but not FreeBSD or Mac OS."
msgstr ""

#: ../doc/book/admin/server_introspection.rst:191
msgid "fiber.info()"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:193
msgid "The simplest profiling method is to take advantage of Tarantool’s built-in functionality. :ref:`fiber.info() <fiber-info>` returns information about all running fibers with their corresponding C stack traces. You can use this data to see how many fibers are running and which C functions are executed more often than others."
msgstr ""

#: ../doc/book/admin/server_introspection.rst:199
msgid "First, enter your instance’s interactive administrator console:"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:201
#: ../doc/book/admin/server_introspection.rst:479
msgid "$ tarantoolctl enter NAME"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:205
msgid "Once there, load the ``fiber`` module:"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:207
msgid "tarantool> fiber = require('fiber')"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:211
msgid "After that you can get the required information with ``fiber.info()``."
msgstr ""

#: ../doc/book/admin/server_introspection.rst:213
msgid "At this point, your console output should look something like this:"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:215
msgid "tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> fiber.info()\n"
"---\n"
"- 360:\n"
"    csw: 2098165\n"
"    backtrace:\n"
"    - '#0 0x4d1b77 in wal_write(journal*, journal_entry*)+487'\n"
"    - '#1 0x4bbf68 in txn_commit(txn*)+152'\n"
"    - '#2 0x4bd5d8 in process_rw(request*, space*, tuple**)+136'\n"
"    - '#3 0x4bed48 in box_process1+104'\n"
"    - '#4 0x4d72f8 in lbox_replace+120'\n"
"    - '#5 0x50f317 in lj_BC_FUNCC+52'\n"
"    fid: 360\n"
"    memory:\n"
"      total: 61744\n"
"      used: 480\n"
"    name: main\n"
"  129:\n"
"    csw: 113\n"
"    backtrace: []\n"
"    fid: 129\n"
"    memory:\n"
"      total: 57648\n"
"      used: 0\n"
"    name: 'console/unix/:'\n"
"..."
msgstr ""

#: ../doc/book/admin/server_introspection.rst:246
msgid "We highly recommend to assign meaningful names to fibers you create so that you can find them in the ``fiber.info()`` list. In the example below, we create a fiber named ``myworker``:"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:250
msgid "tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> f = fiber.create(function() while true do fiber.sleep(0.5) end end)\n"
"---\n"
"...\n"
"tarantool> f:name('myworker') <!-- assigning the name to a fiber\n"
"---\n"
"...\n"
"tarantool> fiber.info()\n"
"---\n"
"- 102:\n"
"    csw: 14\n"
"    backtrace:\n"
"    - '#0 0x501a1a in fiber_yield_timeout+90'\n"
"    - '#1 0x4f2008 in lbox_fiber_sleep+72'\n"
"    - '#2 0x5112a7 in lj_BC_FUNCC+52'\n"
"    fid: 102\n"
"    memory:\n"
"      total: 57656\n"
"      used: 0\n"
"    name: myworker <!-- newly created background fiber\n"
"  101:\n"
"    csw: 284\n"
"    backtrace: []\n"
"    fid: 101\n"
"    memory:\n"
"      total: 57656\n"
"      used: 0\n"
"    name: interactive\n"
"..."
msgstr ""

#: ../doc/book/admin/server_introspection.rst:284
msgid "You can kill any fiber with :ref:`fiber.kill(fid) <fiber-kill>`:"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:286
msgid "tarantool> fiber.kill(102)\n"
"---\n"
"...\n"
"tarantool> fiber.info()\n"
"---\n"
"- 101:\n"
"    csw: 324\n"
"    backtrace: []\n"
"    fid: 101\n"
"    memory:\n"
"      total: 57656\n"
"      used: 0\n"
"    name: interactive\n"
"..."
msgstr ""

#: ../doc/book/admin/server_introspection.rst:303
msgid "If you want to dynamically obtain information with ``fiber.info()``, the shell script below may come in handy. It connects to a Tarantool instance specified by ``NAME`` every 0.5 seconds, grabs the ``fiber.info()`` output and writes it to the ``fiber-info.txt`` file:"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:308
msgid "$ rm -f fiber.info.txt\n"
"$ watch -n 0.5 \"echo 'require(\\\"fiber\\\").info()' | tarantoolctl enter NAME | tee -a fiber-info.txt\""
msgstr ""

#: ../doc/book/admin/server_introspection.rst:313
msgid "If you can't understand which fiber causes performance issues, collect the metrics of the ``fiber.info()`` output for 10-15 seconds using the script above and contact the Tarantool team at support@tarantool.org."
msgstr ""

#: ../doc/book/admin/server_introspection.rst:319
msgid "Poor man’s profilers"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:321
msgid "**pstack <pid>**"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:323
msgid "To use this tool, first install it with a package manager that comes with your Linux distribution. This command prints an execution stack trace of a running process specified by the PID. You might want to run this command several times in a row to pinpoint the bottleneck that causes the slowdown."
msgstr ""

#: ../doc/book/admin/server_introspection.rst:328
msgid "Once installed, say:"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:330
msgid "$ pstack $(pidof tarantool INSTANCENAME.lua)"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:334
#: ../doc/book/admin/server_introspection.rst:381
msgid "Next, say:"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:336
#: ../doc/book/admin/server_introspection.rst:383
msgid "$ echo $(pidof tarantool INSTANCENAME.lua)"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:340
#: ../doc/book/admin/server_introspection.rst:387
msgid "to show the PID of the Tarantool instance that runs the ``INSTANCENAME.lua`` file."
msgstr ""

#: ../doc/book/admin/server_introspection.rst:342
msgid "You should get similar output:"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:344
msgid "Thread 19 (Thread 0x7f09d1bff700 (LWP 24173)):\n"
"#0 0x00007f0a1a5423f2 in ?? () from /lib64/libgomp.so.1\n"
"#1 0x00007f0a1a53fdc0 in ?? () from /lib64/libgomp.so.1\n"
"#2 0x00007f0a1ad5adc5 in start_thread () from /lib64/libpthread.so.0\n"
"#3 0x00007f0a1a050ced in clone () from /lib64/libc.so.6\n"
"Thread 18 (Thread 0x7f09d13fe700 (LWP 24174)):\n"
"#0 0x00007f0a1a5423f2 in ?? () from /lib64/libgomp.so.1\n"
"#1 0x00007f0a1a53fdc0 in ?? () from /lib64/libgomp.so.1\n"
"#2 0x00007f0a1ad5adc5 in start_thread () from /lib64/libpthread.so.0\n"
"#3 0x00007f0a1a050ced in clone () from /lib64/libc.so.6\n"
"<...>\n"
"Thread 2 (Thread 0x7f09c8bfe700 (LWP 24191)):\n"
"#0 0x00007f0a1ad5e6d5 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0\n"
"#1 0x000000000045d901 in wal_writer_pop(wal_writer*) ()\n"
"#2 0x000000000045db01 in wal_writer_f(__va_list_tag*) ()\n"
"#3 0x0000000000429abc in fiber_cxx_invoke(int (*)(__va_list_tag*), __va_list_tag*) ()\n"
"#4 0x00000000004b52a0 in fiber_loop ()\n"
"#5 0x00000000006099cf in coro_init ()\n"
"Thread 1 (Thread 0x7f0a1c47fd80 (LWP 24172)):\n"
"#0 0x00007f0a1a0512c3 in epoll_wait () from /lib64/libc.so.6\n"
"#1 0x00000000006051c8 in epoll_poll ()\n"
"#2 0x0000000000607533 in ev_run ()\n"
"#3 0x0000000000428e13 in main ()"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:370
msgid "**gdb -ex \"bt\" -p <pid>**"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:372
msgid "As with ``pstack``, the GNU debugger (also known as ``gdb``) needs to be installed before you can start using it. Your Linux package manager can help you with that."
msgstr ""

#: ../doc/book/admin/server_introspection.rst:375
msgid "Once the debugger is installed, say:"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:377
msgid "$ gdb -ex \"set pagination 0\" -ex \"thread apply all bt\" --batch -p $(pidof tarantool INSTANCENAME.lua)"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:389
msgid "After using the debugger, your console output should look like this:"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:391
msgid "[Thread debugging using libthread_db enabled]\n"
"Using host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\".\n"
"\n"
"[CUT]\n"
"\n"
"Thread 1 (Thread 0x7f72289ba940 (LWP 20535)):\n"
"#0 _int_malloc (av=av@entry=0x7f7226e0eb20 <main_arena>, bytes=bytes@entry=504) at malloc.c:3697\n"
"#1 0x00007f7226acf21a in __libc_calloc (n=<optimized out>, elem_size=<optimized out>) at malloc.c:3234\n"
"#2 0x00000000004631f8 in vy_merge_iterator_reserve (capacity=3, itr=0x7f72264af9e0) at /usr/src/tarantool/src/box/vinyl.c:7629\n"
"#3 vy_merge_iterator_add (itr=itr@entry=0x7f72264af9e0, is_mutable=is_mutable@entry=true, belong_range=belong_range@entry=false) at /usr/src/tarantool/src/box/vinyl.c:7660\n"
"#4 0x00000000004703df in vy_read_iterator_add_mem (itr=0x7f72264af990) at /usr/src/tarantool/src/box/vinyl.c:8387\n"
"#5 vy_read_iterator_use_range (itr=0x7f72264af990) at /usr/src/tarantool/src/box/vinyl.c:8453\n"
"#6 0x000000000047657d in vy_read_iterator_start (itr=<optimized out>) at /usr/src/tarantool/src/box/vinyl.c:8501\n"
"#7 0x00000000004766b5 in vy_read_iterator_next (itr=itr@entry=0x7f72264af990, result=result@entry=0x7f72264afad8) at /usr/src/tarantool/src/box/vinyl.c:8592\n"
"#8 0x000000000047689d in vy_index_get (tx=tx@entry=0x7f7226468158, index=index@entry=0x2563860, key=<optimized out>, part_count=<optimized out>, result=result@entry=0x7f72264afad8) at /usr/src/tarantool/src/box/vinyl.c:5705\n"
"#9 0x0000000000477601 in vy_replace_impl (request=<optimized out>, request=<optimized out>, stmt=0x7f72265a7150, space=0x2567ea0, tx=0x7f7226468158) at /usr/src/tarantool/src/box/vinyl.c:5920\n"
"#10 vy_replace (tx=0x7f7226468158, stmt=stmt@entry=0x7f72265a7150, space=0x2567ea0, request=<optimized out>) at /usr/src/tarantool/src/box/vinyl.c:6608\n"
"#11 0x00000000004615a9 in VinylSpace::executeReplace (this=<optimized out>, txn=<optimized out>, space=<optimized out>, request=<optimized out>) at /usr/src/tarantool/src/box/vinyl_space.cc:108\n"
"#12 0x00000000004bd723 in process_rw (request=request@entry=0x7f72265a70f8, space=space@entry=0x2567ea0, result=result@entry=0x7f72264afbc8) at /usr/src/tarantool/src/box/box.cc:182\n"
"#13 0x00000000004bed48 in box_process1 (request=0x7f72265a70f8, result=result@entry=0x7f72264afbc8) at /usr/src/tarantool/src/box/box.cc:700\n"
"#14 0x00000000004bf389 in box_replace (space_id=space_id@entry=513, tuple=<optimized out>, tuple_end=<optimized out>, result=result@entry=0x7f72264afbc8) at /usr/src/tarantool/src/box/box.cc:754\n"
"#15 0x00000000004d72f8 in lbox_replace (L=0x413c5780) at /usr/src/tarantool/src/box/lua/index.c:72\n"
"#16 0x000000000050f317 in lj_BC_FUNCC ()\n"
"#17 0x00000000004d37c7 in execute_lua_call (L=0x413c5780) at /usr/src/tarantool/src/box/lua/call.c:282\n"
"#18 0x000000000050f317 in lj_BC_FUNCC ()\n"
"#19 0x0000000000529c7b in lua_cpcall ()\n"
"#20 0x00000000004f6aa3 in luaT_cpcall (L=L@entry=0x413c5780, func=func@entry=0x4d36d0 <execute_lua_call>, ud=ud@entry=0x7f72264afde0) at /usr/src/tarantool/src/lua/utils.c:962\n"
"#21 0x00000000004d3fe7 in box_process_lua (handler=0x4d36d0 <execute_lua_call>, out=out@entry=0x7f7213020600, request=request@entry=0x413c5780) at /usr/src/tarantool/src/box/lua/call.c:382\n"
"#22 box_lua_call (request=request@entry=0x7f72130401d8, out=out@entry=0x7f7213020600) at /usr/src/tarantool/src/box/lua/call.c:405\n"
"#23 0x00000000004c0f27 in box_process_call (request=request@entry=0x7f72130401d8, out=out@entry=0x7f7213020600) at /usr/src/tarantool/src/box/box.cc:1074\n"
"#24 0x000000000041326c in tx_process_misc (m=0x7f7213040170) at /usr/src/tarantool/src/box/iproto.cc:942\n"
"#25 0x0000000000504554 in cmsg_deliver (msg=0x7f7213040170) at /usr/src/tarantool/src/cbus.c:302\n"
"#26 0x0000000000504c2e in fiber_pool_f (ap=<error reading variable: value has been optimized out>) at /usr/src/tarantool/src/fiber_pool.c:64\n"
"#27 0x000000000041122c in fiber_cxx_invoke(fiber_func, typedef __va_list_tag __va_list_tag *) (f=<optimized out>, ap=<optimized out>) at /usr/src/tarantool/src/fiber.h:645\n"
"#28 0x00000000005011a0 in fiber_loop (data=<optimized out>) at /usr/src/tarantool/src/fiber.c:641\n"
"#29 0x0000000000688fbf in coro_init () at /usr/src/tarantool/third_party/coro/coro.c:110"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:430
msgid "Run the debugger in a loop a few times to collect enough samples for making conclusions about why Tarantool demonstrates suboptimal performance. Use the following script:"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:434
msgid "$ rm -f stack-trace.txt\n"
"$ watch -n 0.5 \"gdb -ex 'set pagination 0' -ex 'thread apply all bt' --batch -p $(pidof tarantool INSTANCENAME.lua) | tee -a stack-trace.txt\""
msgstr ""

#: ../doc/book/admin/server_introspection.rst:439
msgid "Structurally and functionally, this script is very similar to the one used with ``fiber.info()`` above."
msgstr ""

#: ../doc/book/admin/server_introspection.rst:442
msgid "If you have any difficulties troubleshooting, let the script run for 10-15 seconds and then send the resulting ``stack-trace.txt`` file to the Tarantool team at support@tarantool.org."
msgstr ""

#: ../doc/book/admin/server_introspection.rst:448
msgid "Use the poor man’s profilers with caution: each time they attach to a running process, this stops the process execution for about a second, which may leave a serious footprint in high-load services."
msgstr ""

#: ../doc/book/admin/server_introspection.rst:454
msgid "gperftools"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:456
msgid "To use the CPU profiler from the Google Performance Tools suite with Tarantool, first take care of the prerequisites:"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:459
msgid "For Debian/Ubuntu, run:"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:461
msgid "$ apt-get install libgoogle-perftools4"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:465
msgid "For RHEL/CentOS/Fedora, run:"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:467
msgid "$ yum install gperftools-libs"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:471
msgid "Once you do this, install Lua bindings:"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:473
msgid "$ tarantoolctl rocks install gperftools"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:477
msgid "Now you're ready to go. Enter your instance’s interactive administrator console:"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:483
msgid "To start profiling, say:"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:485
msgid "tarantool> cpuprof = require('gperftools.cpu')\n"
"tarantool> cpuprof.start('/home/<username>/tarantool-on-production.prof')"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:490
msgid "It takes at least a couple of minutes for the profiler to gather performance metrics. After that, save the results to disk (you can do that as many times as you need):"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:494
msgid "tarantool> cpuprof.flush()"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:498
msgid "To stop profiling, say:"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:500
msgid "tarantool> cpuprof.stop()"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:504
msgid "You can now analyze the output with the ``pprof`` utility that comes with the ``gperftools`` package:"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:507
msgid "$ pprof --text /usr/bin/tarantool /home/<username>/tarantool-on-production.prof"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:513
msgid "On Debian/Ubuntu, the ``pprof`` utility is called ``google-pprof``."
msgstr ""

#: ../doc/book/admin/server_introspection.rst:515
msgid "Your output should look similar to this:"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:517
msgid "Total: 598 samples\n"
"      83 13.9% 13.9% 83 13.9% epoll_wait\n"
"      54 9.0% 22.9% 102 17.1%\n"
"vy_mem_tree_insert.constprop.35\n"
"      32 5.4% 28.3% 34 5.7% __write_nocancel\n"
"      28 4.7% 32.9% 42 7.0% vy_mem_iterator_start_from\n"
"      26 4.3% 37.3% 26 4.3% _IO_str_seekoff\n"
"      21 3.5% 40.8% 21 3.5% tuple_compare_field\n"
"      19 3.2% 44.0% 19 3.2%\n"
"::TupleCompareWithKey::compare\n"
"      19 3.2% 47.2% 38 6.4% tuple_compare_slowpath\n"
"      12 2.0% 49.2% 23 3.8% __libc_calloc\n"
"       9 1.5% 50.7% 9 1.5%\n"
"::TupleCompare::compare@42efc0\n"
"       9 1.5% 52.2% 9 1.5% vy_cache_on_write\n"
"       9 1.5% 53.7% 57 9.5% vy_merge_iterator_next_key\n"
"       8 1.3% 55.0% 8 1.3% __nss_passwd_lookup\n"
"       6 1.0% 56.0% 25 4.2% gc_onestep\n"
"       6 1.0% 57.0% 6 1.0% lj_tab_next\n"
"       5 0.8% 57.9% 5 0.8% lj_alloc_malloc\n"
"       5 0.8% 58.7% 131 21.9% vy_prepare"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:543
msgid "perf"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:545
msgid "This tool for performance monitoring and analysis is installed separately via your package manager. Try running the ``perf`` command in the terminal and follow the prompts to install the necessary package(s)."
msgstr ""

#: ../doc/book/admin/server_introspection.rst:551
msgid "By default, some ``perf`` commands are restricted to **root**, so, to be on the safe side, either run all commands as **root** or prepend them with ``sudo``."
msgstr ""

#: ../doc/book/admin/server_introspection.rst:555
msgid "To start gathering performance statistics, say:"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:557
msgid "$ perf record -g -p $(pidof tarantool INSTANCENAME.lua)"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:561
msgid "This command saves the gathered data to a file named ``perf.data`` inside the current working directory. To stop this process (usually, after 10-15 seconds), press **ctrl+C**. In your console, you’ll see:"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:565
msgid "^C[ perf record: Woken up 1 times to write data ]\n"
"[ perf record: Captured and wrote 0.225 MB perf.data (1573 samples) ]"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:570
msgid "Now run the following command:"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:572
msgid "$ perf report -n -g --stdio | tee perf-report.txt"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:576
msgid "It formats the statistical data in the ``perf.data`` file into a performance report and writes it to the ``perf-report.txt`` file."
msgstr ""

#: ../doc/book/admin/server_introspection.rst:579
msgid "The resulting output should look similar to this:"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:581
msgid "# Samples: 14K of event 'cycles'\n"
"# Event count (approx.): 9927346847\n"
"#\n"
"# Children Self Samples Command Shared Object Symbol\n"
"# ........ ........ ............ ......... .................. .......................................\n"
"#\n"
"    35.50% 0.55% 79 tarantool tarantool [.] lj_gc_step\n"
"            |\n"
"             --34.95%--lj_gc_step\n"
"                       |\n"
"                       |--29.26%--gc_onestep\n"
"                       | |\n"
"                       | |--13.85%--gc_sweep\n"
"                       | | |\n"
"                       | | |--5.59%--lj_alloc_free\n"
"                       | | |\n"
"                       | | |--1.33%--lj_tab_free\n"
"                       | | | |\n"
"                       | | | --1.01%--lj_alloc_free\n"
"                       | | |\n"
"                       | | --1.17%--lj_cdata_free\n"
"                       | |\n"
"                       | |--5.41%--gc_finalize\n"
"                       | | |\n"
"                       | | |--1.06%--lj_obj_equal\n"
"                       | | |\n"
"                       | | --0.95%--lj_tab_set\n"
"                       | |\n"
"                       | |--4.97%--rehashtab\n"
"                       | | |\n"
"                       | | --3.65%--lj_tab_resize\n"
"                       | | |\n"
"                       | | |--0.74%--lj_tab_set\n"
"                       | | |\n"
"                       | | --0.72%--lj_tab_newkey\n"
"                       | |\n"
"                       | |--0.91%--propagatemark\n"
"                       | |\n"
"                       | --0.67%--lj_cdata_free\n"
"                       |\n"
"                        --5.43%--propagatemark\n"
"                                  |\n"
"                                   --0.73%--gc_mark"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:627
msgid "Unlike the poor man’s profilers, ``gperftools`` and ``perf`` have low overhead (almost negligible as compared with ``pstack`` and ``gdb``): they don’t result in long delays when attaching to a process and therefore can be used without serious consequences."
msgstr ""

#: ../doc/book/admin/server_introspection.rst:634
msgid "jit.p"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:637
msgid "The jit.p profiler comes with the Tarantool application server, to load it one only needs to say ``require('jit.p')`` or ``require('jit.profile')``. There are many options for sampling and display, they are described in the documentation for `The LuaJIT Profiler <http://www.luatex.org/svn/trunk/source/libs/luajit/LuaJIT-src/doc/ext_profiler.html>`_."
msgstr ""

#: ../doc/book/admin/server_introspection.rst:645
msgid "Make a function that calls a function named f1 that does 500,000 inserts and deletes in a Tarantool space. Start the profiler, execute the function, stop the profiler, and show what the profiler sampled."
msgstr ""

#: ../doc/book/admin/server_introspection.rst:650
msgid "box.space.t:drop()\n"
"box.schema.space.create('t')\n"
"box.space.t:create_index('i')\n"
"function f1() for i = 1,500000 do\n"
"  box.space.t:insert{i}\n"
"  box.space.t:delete{i}\n"
"  end\n"
"return 1\n"
"end\n"
"function f3() f1() end\n"
"jit_p = require(\"jit.profile\")\n"
"sampletable = {}\n"
"jit_p.start(\"f\", function(thread, samples, vmstate)\n"
"  local dump=jit_p.dumpstack(thread, \"f\", 1)\n"
"  sampletable[dump] = (sampletable[dump] or 0) + samples\n"
"end)\n"
"f3()\n"
"jit_p.stop()\n"
"for d,v in pairs(sampletable) do print(v, d) end"
msgstr ""

#: ../doc/book/admin/server_introspection.rst:672
msgid "Typically the result will show that the sampling happened within f1() many times, but also within internal Tarantool functions, whose names may change with each new version."
msgstr ""

#: ../doc/book/admin/start_stop_instance.rst:5
msgid "Starting/stopping an instance"
msgstr ""

#: ../doc/book/admin/start_stop_instance.rst:7
msgid "While a Lua application is executed by Tarantool, an instance file is executed by ``tarantoolctl`` which is a Tarantool script."
msgstr ""

#: ../doc/book/admin/start_stop_instance.rst:10
msgid "Here is what ``tarantoolctl`` does when you issue the command:"
msgstr ""

#: ../doc/book/admin/start_stop_instance.rst:12
msgid "$ tarantoolctl start <instance_name>"
msgstr ""

#: ../doc/book/admin/start_stop_instance.rst:16
msgid "Read and parse the command line arguments. The last argument, in our case, contains an instance name."
msgstr ""

#: ../doc/book/admin/start_stop_instance.rst:19
msgid "Read and parse its own configuration file. This file contains ``tarantoolctl`` defaults, like the path to the directory where instances should be searched for."
msgstr ""

#: ../doc/book/admin/start_stop_instance.rst:23
msgid "When ``tarantool`` is invoked by root, it looks for a configuration file in ``/etc/default/tarantool``. When ``tarantool`` is invoked by a local (non-root) user, it looks for a configuration file first in the current directory (``$PWD/.tarantoolctl``), and then in the current user's home directory (``$HOME/.config/tarantool/tarantool``). If no configuration file is found there, or in the ``/usr/local/etc/default/tarantool`` file, then ``tarantoolctl`` falls back to :ref:`built-in defaults <admin-tarantoolctl_config_file>`."
msgstr ""

#: ../doc/book/admin/start_stop_instance.rst:32
msgid "Look up the instance file in the instance directory, for example ``/etc/tarantool/instances.enabled``. To build the instance file path, ``tarantoolctl`` takes the instance name, prepends the instance directory and appends \".lua\" extension to the instance file."
msgstr ""

#: ../doc/book/admin/start_stop_instance.rst:37
msgid "Override :ref:`box.cfg{} <box_introspection-box_cfg>` function to pre-process its parameters and ensure that instance paths are pointing to the paths defined in the ``tarantoolctl`` configuration file. For example, if the configuration file specifies that instance work directory must be in ``/var/tarantool``, then the new implementation of ``box.cfg{}`` ensures that :ref:`work_dir <cfg_basic-work_dir>` parameter in ``box.cfg{}`` is set to ``/var/tarantool/<instance_name>``, regardless of what the path is set to in the instance file itself."
msgstr ""

#: ../doc/book/admin/start_stop_instance.rst:46
msgid "Create a so-called \"instance control file\". This is a Unix socket with Lua console attached to it. This file is used later by ``tarantoolctl`` to query the instance state, send commands to the instance and so on."
msgstr ""

#: ../doc/book/admin/start_stop_instance.rst:50
msgid "Set the TARANTOOLCTL environment variable to 'true'. This allows the user to know that the instance was started by ``tarantoolctl``."
msgstr ""

#: ../doc/book/admin/start_stop_instance.rst:53
msgid "Finally, use Lua ``dofile`` command to execute the instance file."
msgstr ""

#: ../doc/book/admin/start_stop_instance.rst:55
msgid "If you start an instance using ``systemd`` tools, like this (the instance name is ``my_app``):"
msgstr ""

#: ../doc/book/admin/start_stop_instance.rst:58
msgid "$ systemctl start tarantool@my_app\n"
"$ ps axuf|grep exampl[e]\n"
"taranto+  5350  1.3  0.3 1448872 7736 ?        Ssl  20:05   0:28 tarantool my_app.lua <running>"
msgstr ""

#: ../doc/book/admin/start_stop_instance.rst:64
msgid "... this actually calls ``tarantoolctl`` like in case of ``tarantoolctl start my_app``."
msgstr ""

#: ../doc/book/admin/start_stop_instance.rst:67
msgid "To check the instance file for syntax errors prior to starting ``my_app`` instance, say:"
msgstr ""

#: ../doc/book/admin/start_stop_instance.rst:70
msgid "$ tarantoolctl check my_app"
msgstr ""

#: ../doc/book/admin/start_stop_instance.rst:74
msgid "To enable ``my_app`` instance for auto-load during system startup, say:"
msgstr ""

#: ../doc/book/admin/start_stop_instance.rst:76
msgid "$ systemctl enable tarantool@my_app"
msgstr ""

#: ../doc/book/admin/start_stop_instance.rst:80
msgid "To stop a running ``my_app`` instance, say:"
msgstr ""

#: ../doc/book/admin/start_stop_instance.rst:82
msgid "$ tarantoolctl stop my_app\n"
"$ # - OR -\n"
"$ systemctl stop tarantool@my_app"
msgstr ""

#: ../doc/book/admin/start_stop_instance.rst:88
msgid "To restart (i.e. stop and start) a running ``my_app`` instance, say:"
msgstr ""

#: ../doc/book/admin/start_stop_instance.rst:90
msgid "$ tarantoolctl restart my_app\n"
"$ # - OR -\n"
"$ systemctl restart tarantool@my_app"
msgstr ""

#: ../doc/book/admin/start_stop_instance.rst:100
msgid "Running Tarantool locally"
msgstr ""

#: ../doc/book/admin/start_stop_instance.rst:102
msgid "Sometimes you may need to run a Tarantool instance locally, e.g. for test purposes. Let's configure a local instance, then start and monitor it with ``tarantoolctl``."
msgstr ""

#: ../doc/book/admin/start_stop_instance.rst:106
msgid "First, we create a sandbox directory on the user's path:"
msgstr ""

#: ../doc/book/admin/start_stop_instance.rst:108
msgid "$ mkdir ~/tarantool_test"
msgstr ""

#: ../doc/book/admin/start_stop_instance.rst:112
msgid "... and set default ``tarantoolctl`` configuration in ``$HOME/.config/tarantool/tarantool``. Let the file contents be:"
msgstr ""

#: ../doc/book/admin/start_stop_instance.rst:115
msgid "default_cfg = {\n"
"    pid_file  = \"/home/user/tarantool_test/my_app.pid\",\n"
"    wal_dir   = \"/home/user/tarantool_test\",\n"
"    snap_dir  = \"/home/user/tarantool_test\",\n"
"    vinyl_dir = \"/home/user/tarantool_test\",\n"
"    log       = \"/home/user/tarantool_test/log\",\n"
"}\n"
"instance_dir = \"/home/user/tarantool_test\""
msgstr ""

#: ../doc/book/admin/start_stop_instance.rst:128
msgid "Specify a full path to the user's home directory instead of \"~/\"."
msgstr ""

#: ../doc/book/admin/start_stop_instance.rst:130
msgid "Omit ``username`` parameter. ``tarantoolctl`` normally doesn't have permissions to switch current user when invoked by a local user. The instance will be running under 'admin'."
msgstr ""

#: ../doc/book/admin/start_stop_instance.rst:134
msgid "Next, we create the instance file ``~/tarantool_test/my_app.lua``. Let the file contents be:"
msgstr ""

#: ../doc/book/admin/start_stop_instance.rst:137
msgid "box.cfg{listen = 3301}\n"
"box.schema.user.passwd('Gx5!')\n"
"box.schema.user.grant('guest','read,write,execute','universe')\n"
"fiber = require('fiber')\n"
"box.schema.space.create('tester')\n"
"box.space.tester:create_index('primary',{})\n"
"i = 0\n"
"while 0 == 0 do\n"
"    fiber.sleep(5)\n"
"    i = i + 1\n"
"    print('insert ' .. i)\n"
"    box.space.tester:insert{i, 'my_app tuple'}\n"
"end"
msgstr ""

#: ../doc/book/admin/start_stop_instance.rst:153
msgid "Let’s verify our instance file by starting it without ``tarantoolctl`` first:"
msgstr ""

#: ../doc/book/admin/start_stop_instance.rst:155
msgid "$ cd ~/tarantool_test\n"
"$ tarantool my_app.lua\n"
"2017-04-06 10:42:15.762 [54085] main/101/my_app.lua C> version 1.7.3-489-gd86e36d5b\n"
"2017-04-06 10:42:15.763 [54085] main/101/my_app.lua C> log level 5\n"
"2017-04-06 10:42:15.764 [54085] main/101/my_app.lua I> mapping 268435456 bytes for tuple arena...\n"
"2017-04-06 10:42:15.774 [54085] iproto/101/main I> binary: bound to [::]:3301\n"
"2017-04-06 10:42:15.774 [54085] main/101/my_app.lua I> initializing an empty data directory\n"
"2017-04-06 10:42:15.789 [54085] snapshot/101/main I> saving snapshot `./00000000000000000000.snap.inprogress'\n"
"2017-04-06 10:42:15.790 [54085] snapshot/101/main I> done\n"
"2017-04-06 10:42:15.791 [54085] main/101/my_app.lua I> vinyl checkpoint done\n"
"2017-04-06 10:42:15.791 [54085] main/101/my_app.lua I> ready to accept requests\n"
"insert 1\n"
"insert 2\n"
"insert 3\n"
"<...>"
msgstr ""

#: ../doc/book/admin/start_stop_instance.rst:173
msgid "Now we tell ``tarantoolctl`` to start the Tarantool instance:"
msgstr ""

#: ../doc/book/admin/start_stop_instance.rst:175
msgid "$ tarantoolctl start my_app"
msgstr ""

#: ../doc/book/admin/start_stop_instance.rst:179
msgid "Expect to see messages indicating that the instance has started. Then:"
msgstr ""

#: ../doc/book/admin/start_stop_instance.rst:181
msgid "$ ls -l ~/tarantool_test/my_app"
msgstr ""

#: ../doc/book/admin/start_stop_instance.rst:185
msgid "Expect to see the .snap file and the .xlog file. Then:"
msgstr ""

#: ../doc/book/admin/start_stop_instance.rst:187
msgid "$ less ~/tarantool_test/log/my_app.log"
msgstr ""

#: ../doc/book/admin/start_stop_instance.rst:191
msgid "Expect to see the contents of ``my_app``‘s log, including error messages, if any. Then:"
msgstr ""

#: ../doc/book/admin/start_stop_instance.rst:194
msgid "$ tarantoolctl enter my_app\n"
"tarantool> box.cfg{}\n"
"tarantool> console = require('console')\n"
"tarantool> console.connect('localhost:3301')\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})"
msgstr ""

#: ../doc/book/admin/start_stop_instance.rst:202
msgid "Expect to see several tuples that ``my_app`` has created."
msgstr ""

#: ../doc/book/admin/start_stop_instance.rst:204
msgid "Stop now. A polite way to stop ``my_app`` is with ``tarantoolctl``, thus we say:"
msgstr ""

#: ../doc/book/admin/start_stop_instance.rst:206
msgid "$ tarantoolctl stop my_app"
msgstr ""

#: ../doc/book/admin/start_stop_instance.rst:210
msgid "Finally, we make a cleanup."
msgstr ""

#: ../doc/book/admin/start_stop_instance.rst:212
msgid "$ rm -R tarantool_test"
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:6
msgid "Troubleshooting guide"
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:8
msgid "For this guide, you need to install Tarantool `stat <https://github.com/tarantool/stat>`_ module:"
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:11
msgid "$ sudo yum install tarantool-stat\n"
"$ # -- OR --\n"
"$ sudo apt-get install tarantool-stat"
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:21
msgid "Problem: INSERT/UPDATE-requests result in ER_MEMORY_ISSUE error"
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:23
#: ../doc/book/admin/troubleshoot.rst:81
#: ../doc/book/admin/troubleshoot.rst:127
#: ../doc/book/admin/troubleshoot.rst:189
#: ../doc/book/admin/troubleshoot.rst:212
#: ../doc/book/admin/troubleshoot.rst:237
#: ../doc/book/admin/troubleshoot.rst:254
#: ../doc/book/admin/troubleshoot.rst:289
msgid "**Possible reasons**"
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:25
msgid "Lack of RAM (parameters ``arena_used_ratio`` and ``quota_used_ratio`` in :ref:`box.slab.info() <box_slab_info>` report are getting close to 100%)."
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:28
msgid "To check these parameters, say:"
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:30
#: ../doc/book/admin/troubleshoot.rst:92
#: ../doc/book/admin/troubleshoot.rst:149
#: ../doc/book/admin/troubleshoot.rst:266
#: ../doc/book/admin/troubleshoot.rst:302
msgid "$ # attaching to a Tarantool instance\n"
"$ tarantoolctl enter <instance_name>\n"
"$ # -- OR --\n"
"$ tarantoolctl connect <URI>"
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:37
msgid "-- requesting arena_used_ratio value\n"
"tarantool> require('stat').stat()['slab.arena_used_ratio']\n"
"\n"
"-- requesting quota_used_ratio value\n"
"tarantool> require('stat').stat()['slab.quota_used_ratio']"
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:45
#: ../doc/book/admin/troubleshoot.rst:86
#: ../doc/book/admin/troubleshoot.rst:137
#: ../doc/book/admin/troubleshoot.rst:170
#: ../doc/book/admin/troubleshoot.rst:194
#: ../doc/book/admin/troubleshoot.rst:217
#: ../doc/book/admin/troubleshoot.rst:241
#: ../doc/book/admin/troubleshoot.rst:262
#: ../doc/book/admin/troubleshoot.rst:293
msgid "**Solution**"
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:47
#: ../doc/book/admin/troubleshoot.rst:139
msgid "Try either of the following measures:"
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:49
msgid "In Tarantool's :ref:`instance file <admin-instance_config>`, increase the value of :ref:`box.cfg{memtx_memory} <cfg_storage-memtx_memory>` (if memory resources are available)."
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:53
msgid "In versions of Tarantool before 1.10, the server needs to be restarted to change this parameter. The Tarantool server will be unavailable while restarting from .xlog files, unless you restart it using :ref:`hot standby <index-hot_standby>` mode. In the latter case, nearly 100% server availability is guaranteed."
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:59
msgid "Clean up the database."
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:61
msgid "Check the indicators of memory fragmentation:"
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:63
msgid "-- requesting quota_used_ratio value\n"
"tarantool> require('stat').stat()['slab.quota_used_ratio']\n"
"\n"
"-- requesting items_used_ratio value\n"
"tarantool> require('stat').stat()['slab.items_used_ratio']"
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:71
msgid "In case of heavy memory fragmentation (``quota_used_ratio`` is getting close to 100%, ``items_used_ratio`` is about 50%), we recommend restarting Tarantool in the :ref:`hot standby <index-hot_standby>` mode."
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:79
msgid "Problem: Tarantool generates too heavy CPU load"
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:83
msgid "The :ref:`transaction processor thread <atomic-threads_fibers_yields>` consumes over 60% CPU."
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:88
msgid "Attach to the Tarantool instance with :ref:`tarantoolctl <tarantoolctl>` utility, analyze the query statistics with :ref:`box.stat() <box_introspection-box_stat>` and spot the CPU consumption leader. The following commands can help:"
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:99
msgid "-- checking the RPS of calling stored procedures\n"
"tarantool> require('stat').stat()['stat.op.call.rps']"
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:104
msgid "The critical RPS value is 75 000, boiling down to 10 000 - 20 000 for a rich Lua application (a Lua module of 200+ lines)."
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:107
msgid "-- checking RPS per query type\n"
"tarantool> require('stat').stat()['stat.op.<query_type>.rps']"
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:112
msgid "The critical RPS value for SELECT/INSERT/UPDATE/DELETE requests is 100 000."
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:114
msgid "If the load is mostly generated by SELECT requests, we recommend adding a :ref:`slave server <replication-bootstrap>` and let it process part of the queries."
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:118
msgid "If the load is mostly generated by INSERT/UPDATE/DELETE requests, we recommend :ref:`sharding the database <shard-module>`."
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:125
msgid "Problem: Query processing times out"
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:131
msgid "All reasons that we discuss here can be identified by messages in Tarantool's log file, all starting with the words ``'Too long...'``."
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:134
msgid "Both fast and slow queries are processed within a single connection, so the readahead buffer is cluttered with slow queries."
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:141
msgid "Increase the readahead buffer size (:ref:`box.cfg{readahead} <cfg_networking-readahead>` parameter)."
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:144
msgid "This parameter can be changed on the fly, so you don't need to restart Tarantool. Attach to the Tarantool instance with :ref:`tarantoolctl <tarantoolctl>` utility and call ``box.cfg{}`` with a new ``readahead`` value:"
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:156
msgid "-- changing the readahead value\n"
"tarantool> box.cfg{readahead = 10 * 1024 * 1024}"
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:161
msgid "**Example:** Given 1000 RPS, 1 Кbyte of query size, and 10 seconds of maximal query processing time, the minimal readahead buffer size must be 10 Mbytes."
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:165
msgid "On the business logic level, split fast and slow queries processing by different connections."
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:168
msgid "Slow disks."
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:172
msgid "Check disk performance (use `iostat <https://linux.die.net/man/1/iostat>`_, `iotop <https://linux.die.net/man/1/iotop>`_ or `strace <https://linux.die.net/man/1/strace>`_ utility to check ``iowait`` parameter) and try to put .xlog files and snapshot files on different physical disks (i.e. use different locations for :ref:`wal_dir <cfg_basic-wal_dir>` and :ref:`memtx_dir <cfg_basic-memtx_dir>`)."
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:183
msgid "Problem: Replication \"lag\" and \"idle\" contain negative values"
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:185
msgid "This is about ``box.info.replication.(upstream.)lag`` and ``box.info.replication.(upstream.)idle`` values in :ref:`box.info.replication <box_info_replication>` section."
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:191
msgid "Operating system clock on the hosts is not synchronized, or the NTP server is faulty."
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:196
msgid "Check NTP server settings."
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:198
msgid "If you found no problems with the NTP server, just do nothing then. Lag calculation uses operating system clock from two different machines. If they get out of sync, the remote master clock can get consistently behind the local instance’s clock."
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:207
msgid "Problem: Replication \"idle\" keeps growing, but no related log messages appear"
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:209
msgid "This is about ``box.info.replication.(upstream.)idle`` value in :ref:`box.info.replication <box_info_replication>` section."
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:214
msgid "Some server was assigned different IP addresses, or some server was specified twice in ``box.cfg{}``, so duplicate connections were established."
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:219
msgid ":ref:`Upgrade Tarantool 1.6 to 1.7 <admin-upgrades_instance>`, where this error is fixed: in case of duplicate connections, replication is stopped and the following message is added to the log: ``'Incorrect value for option ''replication_source'': duplicate connection with the same replica UUID'``."
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:229
msgid "Problem: Replication statistics differ on replicas within a replica set"
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:231
msgid "This is about a replica set that consists of one master and several replicas. In a replica set of this type, values in :ref:`box.info.replication <box_info_replication>` section, like ``box.info.replication.lsn``, come from the master and must be the same on all replicas within the replica set. The problem is that they get different."
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:239
msgid "Replication is broken."
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:243
msgid ":ref:`Restart replication <replication-recover>`."
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:249
msgid "Problem: Master-master replication is stopped"
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:251
msgid "This is about :ref:`box.info.replication(.upstream).status <box_info_replication>` = stopped."
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:256
msgid "In a master-master replica set of two Tarantool instances, one of the masters has tried to perform an action already performed by the other server, for example re-insert a tuple with the same unique key. This would cause an error message like ``'Duplicate key exists in unique index 'primary' in space <space_name>'``."
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:264
msgid "Restart replication with the following commands (at each master instance):"
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:273
msgid "-- restarting replication\n"
"tarantool> original_value = box.cfg.replication\n"
"tarantool> box.cfg{replication={}}\n"
"tarantool> box.cfg{replication=original_value}"
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:280
msgid "We also recommend using text primary keys or setting up :ref:`master-slave replication <replication-master_replica_bootstrap>`."
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:287
msgid "Problem: Tarantool works much slower than before"
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:291
msgid "Inefficient memory usage (RAM is cluttered with a huge amount of unused objects)."
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:295
msgid "Call the Lua garbage collector with the `collectgarbage('count') function <https://www.lua.org/manual/5.1/manual.html#pdf-collectgarbage>`_ and measure its execution time with the Tarantool functions :ref:`clock.bench() <clock-bench>` or :ref:`clock.proc() <clock-proc>`."
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:300
msgid "Example of calculating memory usage statistics:"
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:309
msgid "-- loading Tarantool's \"clock\" module with time-related routines\n"
"tarantool> local clock = require 'clock'\n"
"-- starting the timer\n"
"tarantool> local b = clock.proc()\n"
"-- launching garbage collection\n"
"tarantool> local c = collectgarbage('count')\n"
"-- stopping the timer after garbage collection is completed\n"
"tarantool> return c, clock.proc() - b"
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:320
msgid "If the returned ``clock.proc()`` value is greater than 0.001, this may be an indicator of inefficient memory usage (no active measures are required, but we recommend to optimize your Tarantool application code)."
msgstr ""

#: ../doc/book/admin/troubleshoot.rst:324
msgid "If the value is greater than 0.01, your application definitely needs thorough code analysis aimed at optimizing memory usage."
msgstr ""

#: ../doc/book/admin/upgrades.rst:5
msgid "Upgrades"
msgstr ""

#: ../doc/book/admin/upgrades.rst:11
msgid "Upgrading a Tarantool database"
msgstr ""

#: ../doc/book/admin/upgrades.rst:13
msgid "If you created a database with an older Tarantool version and have now installed a newer version, make the request ``box.schema.upgrade()``. This updates Tarantool system spaces to match the currently installed version of Tarantool."
msgstr ""

#: ../doc/book/admin/upgrades.rst:17
msgid "For example, here is what happens when you run ``box.schema.upgrade()`` with a database created with Tarantool version 1.6.4 to version 1.7.2 (only a small part of the output is shown):"
msgstr ""

#: ../doc/book/admin/upgrades.rst:21
msgid "tarantool> box.schema.upgrade()\n"
"alter index primary on _space set options to {\"unique\":true}, parts to [[0,\"unsigned\"]]\n"
"alter space _schema set options to {}\n"
"create view _vindex...\n"
"grant read access to 'public' role for _vindex view\n"
"set schema version to 1.7.0\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/admin/upgrades.rst:36
msgid "Upgrading a Tarantool instance"
msgstr ""

#: ../doc/book/admin/upgrades.rst:38
msgid "Tarantool is backward compatible between two adjacent versions. For example, you should have no or little trouble when upgrading from Tarantool 1.6 to 1.7, or from Tarantool 1.7 to 2.x. Meanwhile Tarantool 2.x may have incompatible changes when migrating from Tarantool 1.6. to 2.x directly."
msgstr ""

#: ../doc/book/admin/upgrades.rst:47
msgid "How to upgrade from Tarantool 1.7 to 2.x"
msgstr ""

#: ../doc/book/admin/upgrades.rst:49
#: ../doc/book/admin/upgrades.rst:92
msgid "Stop the Tarantool server."
msgstr ""

#: ../doc/book/admin/upgrades.rst:51
#: ../doc/book/admin/upgrades.rst:94
msgid "Make a copy of all data (see an appropriate hot backup procedure in :ref:`Backups <admin-backups>`) and the package from which the current (old) version was installed (for rollback purposes)."
msgstr ""

#: ../doc/book/admin/upgrades.rst:55
#: ../doc/book/admin/upgrades.rst:98
msgid "Update the Tarantool server. See installation instructions at Tarantool `download page <http://tarantool.org/download.html>`_."
msgstr ""

#: ../doc/book/admin/upgrades.rst:58
#: ../doc/book/admin/upgrades.rst:109
msgid "Launch the updated Tarantool server using ``tarantoolctl`` or ``systemctl``."
msgstr ""

#: ../doc/book/admin/upgrades.rst:64
msgid "How to upgrade from Tarantool 1.6 to 2.x"
msgstr ""

#: ../doc/book/admin/upgrades.rst:66
msgid "The procedure is fully analogous to :ref:`upgrading from 1.7 to 2.x <admin-upgrades_instance_17_to_20>`."
msgstr ""

#: ../doc/book/admin/upgrades.rst:73
msgid "How to upgrade from Tarantool 1.6 to 1.7"
msgstr ""

#: ../doc/book/admin/upgrades.rst:75
msgid "This procedure is for upgrading a standalone Tarantool instance in production from 1.6.x to 1.7.x. Notice that this will **always imply a downtime**. To upgrade **without downtime**, you need several Tarantool servers running in a replication cluster (see :ref:`below <admin-upgrades_replication_cluster>`)."
msgstr ""

#: ../doc/book/admin/upgrades.rst:80
msgid "Tarantool 1.7 has an incompatible :ref:`.snap <internals-snapshot>` and :ref:`.xlog <internals-wal>` file format: 1.6 files are supported during upgrade, but you won’t be able to return to 1.6 after running under 1.7 for a while. It also renames a few configuration parameters, but old parameters are supported. The full list of breaking changes is available in `release notes for Tarantool 1.7 <https://github.com/tarantool/tarantool/releases>`_."
msgstr ""

#: ../doc/book/admin/upgrades.rst:87
msgid "Check with application developers whether application files need to be updated due to incompatible changes (see `1.7 release notes <https://github.com/tarantool/tarantool/releases>`_). If yes, back up the old application files."
msgstr ""

#: ../doc/book/admin/upgrades.rst:101
msgid "Update the Tarantool database. Put the request ``box.schema.upgrade()`` inside a :ref:`box.once() <box-once>` function in your Tarantool :ref:`initialization file <index-init_label>`. On startup, this will create new system spaces, update data type names (e.g. num -> unsigned, str -> string) and options in Tarantool system spaces."
msgstr ""

#: ../doc/book/admin/upgrades.rst:107
msgid "Update application files, if needed."
msgstr ""

#: ../doc/book/admin/upgrades.rst:115
msgid "Upgrading Tarantool in a replication cluster"
msgstr ""

#: ../doc/book/admin/upgrades.rst:117
msgid "Tarantool 1.7 can work as a :ref:`replica <replication-architecture>` for Tarantool 1.6 and vice versa. Replicas perform capability negotiation on handshake, and new 1.7 replication features are not used with 1.6 replicas. This allows upgrading clustered configurations."
msgstr ""

#: ../doc/book/admin/upgrades.rst:122
msgid "This procedure allows for a rolling upgrade **without downtime** and works for any cluster configuration: master-master or master-replica."
msgstr ""

#: ../doc/book/admin/upgrades.rst:125
msgid "Upgrade Tarantool at all replicas (or at any master in a master-master cluster). See details in :ref:`Upgrading a Tarantool instance <admin-upgrades_instance>`."
msgstr ""

#: ../doc/book/admin/upgrades.rst:129
msgid "Verify installation on the replicas:"
msgstr ""

#: ../doc/book/admin/upgrades.rst:131
msgid "Start Tarantool."
msgstr ""

#: ../doc/book/admin/upgrades.rst:133
msgid "Attach to the master and start working as before."
msgstr ""

#: ../doc/book/admin/upgrades.rst:135
msgid "The master runs the old Tarantool version, which is always compatible with the next major version."
msgstr ""

#: ../doc/book/admin/upgrades.rst:138
msgid "Upgrade the master. The procedure is similar to upgrading a replica."
msgstr ""

#: ../doc/book/admin/upgrades.rst:140
msgid "Verify master installation:"
msgstr ""

#: ../doc/book/admin/upgrades.rst:142
msgid "Start Tarantool with replica configuration to catch up."
msgstr ""

#: ../doc/book/admin/upgrades.rst:144
msgid "Switch to master mode."
msgstr ""

#: ../doc/book/admin/upgrades.rst:146
msgid "Upgrade the database on any master node in the cluster. Make the request ``box.schema.upgrade()``. This updates Tarantool system spaces to match the currently installed version of Tarantool. Changes are propagated to other nodes via the regular replication mechanism."
msgstr ""

#: ../doc/book/app_server/contributing_module.rst:5
msgid "Contributing a module"
msgstr ""

#: ../doc/book/app_server/contributing_module.rst:7
msgid "We have already discussed :ref:`how to create a simple module in Lua for local usage <app_server-modules>`. Now let's discuss how to create a more advanced Tarantool module and then get it published on `Tarantool rocks page <http://tarantool.org/rocks.html>`_ and included in `official Tarantool images <http://github.com/tarantool/docker>`_ for Docker."
msgstr ""

#: ../doc/book/app_server/contributing_module.rst:14
msgid "To help our contributors, we have created `modulekit <http://github.com/tarantool/modulekit>`_, a set of templates for creating Tarantool modules in Lua and C."
msgstr ""

#: ../doc/book/app_server/contributing_module.rst:20
msgid "As a prerequisite for using ``modulekit``, install ``tarantool-dev`` package first. For example, in Ubuntu say:"
msgstr ""

#: ../doc/book/app_server/contributing_module.rst:23
msgid "$ sudo apt-get install tarantool-dev"
msgstr ""

#: ../doc/book/app_server/contributing_module.rst:31
msgid "Contributing a module in Lua"
msgstr ""

#: ../doc/book/app_server/contributing_module.rst:33
msgid "See `README in \"luakit\" branch of tarantool/modulekit repository <http://github.com/tarantool/modulekit/blob/luakit/README.md>`_ for detailed instructions and examples."
msgstr ""

#: ../doc/book/app_server/contributing_module.rst:41
msgid "Contributing a module in C"
msgstr ""

#: ../doc/book/app_server/contributing_module.rst:43
msgid "In some cases, you may want to create a Tarantool module in C rather than in Lua. For example, to work with specific hardware or low-level system interfaces."
msgstr ""

#: ../doc/book/app_server/contributing_module.rst:46
msgid "See `README in \"ckit\" branch of tarantool/modulekit repository <http://github.com/tarantool/modulekit/blob/ckit/README.md>`_ for detailed instructions and examples."
msgstr ""

#: ../doc/book/app_server/contributing_module.rst:52
msgid "You can also create modules with C++, provided that the code does not throw exceptions."
msgstr ""

#: ../doc/book/app_server/cookbook.rst:5
msgid "Cookbook recipes"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:7
msgid "Here are contributions of Lua programs for some frequent or tricky situations."
msgstr ""

#: ../doc/book/app_server/cookbook.rst:9
msgid "You can execute any of these programs by copying the code into a ``.lua`` file, and then entering :samp:`chmod +x ./{program-name}.lua` and :samp:`./{program-name}.lua` on the terminal."
msgstr ""

#: ../doc/book/app_server/cookbook.rst:13
msgid "The first line is a \"hashbang\":"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:15
msgid "#!/usr/bin/env tarantool"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:19
msgid "This runs  Tarantool Lua application server, which should be on the execution path."
msgstr ""

#: ../doc/book/app_server/cookbook.rst:22
msgid "This section contains the following recipes:"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:27
msgid "Use freely."
msgstr ""

#: ../doc/book/app_server/cookbook.rst:33
msgid "hello_world.lua"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:35
msgid "The standard example of a simple program."
msgstr ""

#: ../doc/book/app_server/cookbook.rst:37
msgid "#!/usr/bin/env tarantool\n"
"\n"
"print('Hello, World!')"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:47
msgid "console_start.lua"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:49
msgid "Use :ref:`box.once() <box-once>` to initialize a database (creating spaces) if this is the first time the server has been run. Then use :ref:`console.start() <console-start>` to start interactive mode."
msgstr ""

#: ../doc/book/app_server/cookbook.rst:53
msgid "#!/usr/bin/env tarantool\n"
"\n"
"-- Configure database\n"
"box.cfg {\n"
"    listen = 3313\n"
"}\n"
"\n"
"box.once(\"bootstrap\", function()\n"
"    box.schema.space.create('tweedledum')\n"
"    box.space.tweedledum:create_index('primary',\n"
"        { type = 'TREE', parts = {1, 'unsigned'}})\n"
"end)\n"
"\n"
"require('console').start()"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:74
msgid "fio_read.lua"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:76
msgid "Use the :ref:`fio module <fio-module>` to open, read, and close a file."
msgstr ""

#: ../doc/book/app_server/cookbook.rst:78
msgid "#!/usr/bin/env tarantool\n"
"\n"
"local fio = require('fio')\n"
"local errno = require('errno')\n"
"local f = fio.open('/tmp/xxxx.txt', {'O_RDONLY' })\n"
"if not f then\n"
"    error(\"Failed to open file: \"..errno.strerror())\n"
"end\n"
"local data = f:read(4096)\n"
"f:close()\n"
"print(data)"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:96
msgid "fio_write.lua"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:98
msgid "Use the :ref:`fio module <fio-module>` to open, write, and close a file."
msgstr ""

#: ../doc/book/app_server/cookbook.rst:100
msgid "#!/usr/bin/env tarantool\n"
"\n"
"local fio = require('fio')\n"
"local errno = require('errno')\n"
"local f = fio.open('/tmp/xxxx.txt', {'O_CREAT', 'O_WRONLY', 'O_APPEND'},\n"
"    tonumber('0666', 8))\n"
"if not f then\n"
"    error(\"Failed to open file: \"..errno.strerror())\n"
"end\n"
"f:write(\"Hello\\n\");\n"
"f:close()"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:118
msgid "ffi_printf.lua"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:120
msgid "Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to call a C built-in function: printf(). (For help understanding ffi, see the `FFI tutorial <http://luajit.org/ext_ffi_tutorial.html>`_.)"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:123
msgid "#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require('ffi')\n"
"ffi.cdef[[\n"
"    int printf(const char *format, ...);\n"
"]]\n"
"\n"
"ffi.C.printf(\"Hello, %s\\n\", os.getenv(\"USER\"));"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:138
msgid "ffi_gettimeofday.lua"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:140
msgid "Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to call a C function: gettimeofday(). This delivers time with millisecond precision, unlike the time function in Tarantool's :ref:`clock module <clock-module>`."
msgstr ""

#: ../doc/book/app_server/cookbook.rst:144
msgid "#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require('ffi')\n"
"ffi.cdef[[\n"
"    typedef long time_t;\n"
"    typedef struct timeval {\n"
"    time_t tv_sec;\n"
"    time_t tv_usec;\n"
"} timeval;\n"
"    int gettimeofday(struct timeval *t, void *tzp);\n"
"]]\n"
"\n"
"local timeval_buf = ffi.new(\"timeval\")\n"
"local now = function()\n"
"    ffi.C.gettimeofday(timeval_buf, nil)\n"
"    return tonumber(timeval_buf.tv_sec * 1000 + (timeval_buf.tv_usec / 1000))\n"
"end"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:168
msgid "ffi_zlib.lua"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:170
msgid "Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to call a C library function. (For help understanding ffi, see the `FFI tutorial <http://luajit.org/ext_ffi_tutorial.html>`_.)"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:173
msgid "#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require(\"ffi\")\n"
"ffi.cdef[[\n"
"    unsigned long compressBound(unsigned long sourceLen);\n"
"    int compress2(uint8_t *dest, unsigned long *destLen,\n"
"    const uint8_t *source, unsigned long sourceLen, int level);\n"
"    int uncompress(uint8_t *dest, unsigned long *destLen,\n"
"    const uint8_t *source, unsigned long sourceLen);\n"
"]]\n"
"local zlib = ffi.load(ffi.os == \"Windows\" and \"zlib1\" or \"z\")\n"
"\n"
"-- Lua wrapper for compress2()\n"
"local function compress(txt)\n"
"    local n = zlib.compressBound(#txt)\n"
"    local buf = ffi.new(\"uint8_t[?]\", n)\n"
"    local buflen = ffi.new(\"unsigned long[1]\", n)\n"
"    local res = zlib.compress2(buf, buflen, txt, #txt, 9)\n"
"    assert(res == 0)\n"
"    return ffi.string(buf, buflen[0])\n"
"end\n"
"\n"
"-- Lua wrapper for uncompress\n"
"local function uncompress(comp, n)\n"
"    local buf = ffi.new(\"uint8_t[?]\", n)\n"
"    local buflen = ffi.new(\"unsigned long[1]\", n)\n"
"    local res = zlib.uncompress(buf, buflen, comp, #comp)\n"
"    assert(res == 0)\n"
"    return ffi.string(buf, buflen[0])\n"
"end\n"
"\n"
"-- Simple test code.\n"
"local txt = string.rep(\"abcd\", 1000)\n"
"print(\"Uncompressed size: \", #txt)\n"
"local c = compress(txt)\n"
"print(\"Compressed size: \", #c)\n"
"local txt2 = uncompress(c, #txt)\n"
"assert(txt2 == txt)"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:218
msgid "ffi_meta.lua"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:220
msgid "Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to access a C object via a metamethod (a method which is defined with a metatable)."
msgstr ""

#: ../doc/book/app_server/cookbook.rst:224
msgid "#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require(\"ffi\")\n"
"ffi.cdef[[\n"
"typedef struct { double x, y; } point_t;\n"
"]]\n"
"\n"
"local point\n"
"local mt = {\n"
"  __add = function(a, b) return point(a.x+b.x, a.y+b.y) end,\n"
"  __len = function(a) return math.sqrt(a.x*a.x + a.y*a.y) end,\n"
"  __index = {\n"
"    area = function(a) return a.x*a.x + a.y*a.y end,\n"
"  },\n"
"}\n"
"point = ffi.metatype(\"point_t\", mt)\n"
"\n"
"local a = point(3, 4)\n"
"print(a.x, a.y)  --> 3  4\n"
"print(#a)        --> 5\n"
"print(a:area())  --> 25\n"
"local b = a + point(0.5, 8)\n"
"print(#b)        --> 12.5"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:254
msgid "ffi_varbinary_insert.lua"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:256
msgid "Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to insert a tuple which has a VARBINARY field. Lua does not have direct support for VARBINARY, so using C is one way to put in data which in MessagePack is stored as bin (MP_BIN). If the tuple is retrieved later, field \"b\" will have type = 'cdata'."
msgstr ""

#: ../doc/book/app_server/cookbook.rst:262
msgid "#!/usr/bin/env tarantool\n"
"\n"
"-- box.cfg{} should be here\n"
"\n"
"s = box.schema.space.create('withdata')\n"
"s:format({{\"b\", \"varbinary\"}})\n"
"s:create_index('pk', {parts = {1, \"varbinary\"}})\n"
"\n"
"buffer = require('buffer')\n"
"ffi = require('ffi')\n"
"\n"
"function varbinary_insert(space, bytes)\n"
"    local tmpbuf = buffer.IBUF_SHARED\n"
"    tmpbuf:reset()\n"
"    local p = tmpbuf:alloc(3 + #bytes)\n"
"    p[0] = 0x91 -- MsgPack code for \"array-1\"\n"
"    p[1] = 0xC4 -- MsgPack code for \"bin-8\" so up to 256 bytes\n"
"    p[2] = #bytes\n"
"    for i, c in pairs(bytes) do p[i + 3 - 1] = c end\n"
"    ffi.cdef[[int box_insert(uint32_t space_id,\n"
"                             const char *tuple,\n"
"                             const char *tuple_end,\n"
"                             box_tuple_t **result);]]\n"
"    ffi.C.box_insert(space.id, tmpbuf.rpos, tmpbuf.wpos, nil)\n"
"end\n"
"\n"
"varbinary_insert(s, {0xDE, 0xAD, 0xBE, 0xAF})\n"
"varbinary_insert(s, {0xFE, 0xED, 0xFA, 0xCE})\n"
"\n"
"-- if successful, Tarantool enters the event loop now"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:300
msgid "print_arrays.lua"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:302
msgid "Create Lua tables, and print them. Notice that for the 'array' table the iterator function is ipairs(), while for the 'map' table the iterator function is pairs(). (`ipairs()` is faster than `pairs()`, but pairs() is recommended for map-like tables or mixed tables.) The display will look like: \"1 Apple | 2 Orange | 3 Grapefruit | 4 Banana | k3 v3 | k1 v1 | k2 v2\"."
msgstr ""

#: ../doc/book/app_server/cookbook.rst:310
msgid "#!/usr/bin/env tarantool\n"
"\n"
"array = { 'Apple', 'Orange', 'Grapefruit', 'Banana'}\n"
"for k, v in ipairs(array) do print(k, v) end\n"
"\n"
"map = { k1 = 'v1', k2 = 'v2', k3 = 'v3' }\n"
"for k, v in pairs(map) do print(k, v) end"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:324
msgid "count_array.lua"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:326
msgid "Use the '#' operator to get the number of items in an array-like Lua table. This operation has O(log(N)) complexity."
msgstr ""

#: ../doc/book/app_server/cookbook.rst:329
msgid "#!/usr/bin/env tarantool\n"
"\n"
"array = { 1, 2, 3}\n"
"print(#array)"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:340
msgid "count_array_with_nils.lua"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:342
msgid "Missing elements in arrays, which Lua treats as \"nil\"s, cause the simple \"#\" operator to deliver improper results. The \"print(#t)\" instruction will print \"4\"; the \"print(counter)\" instruction will print \"3\"; the \"print(max)\" instruction will print \"10\". Other table functions, such as :ref:`table.sort() <table-sort>`, will also misbehave when \"nils\" are present."
msgstr ""

#: ../doc/book/app_server/cookbook.rst:350
msgid "#!/usr/bin/env tarantool\n"
"\n"
"local t = {}\n"
"t[1] = 1\n"
"t[4] = 4\n"
"t[10] = 10\n"
"print(#t)\n"
"local counter = 0\n"
"for k,v in pairs(t) do counter = counter + 1 end\n"
"print(counter)\n"
"local max = 0\n"
"for k,v in pairs(t) do if k > max then max = k end end\n"
"print(max)"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:370
msgid "count_array_with_nulls.lua"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:372
msgid "Use explicit ``NULL`` values to avoid the problems caused by Lua's nil == missing value behavior. Although :code:`json.NULL == nil` is :code:`true`, all the print instructions in this program will print the correct value: 10."
msgstr ""

#: ../doc/book/app_server/cookbook.rst:377
msgid "#!/usr/bin/env tarantool\n"
"\n"
"local json = require('json')\n"
"local t = {}\n"
"t[1] = 1; t[2] = json.NULL; t[3]= json.NULL;\n"
"t[4] = 4; t[5] = json.NULL; t[6]= json.NULL;\n"
"t[6] = 4; t[7] = json.NULL; t[8]= json.NULL;\n"
"t[9] = json.NULL\n"
"t[10] = 10\n"
"print(#t)\n"
"local counter = 0\n"
"for k,v in pairs(t) do counter = counter + 1 end\n"
"print(counter)\n"
"local max = 0\n"
"for k,v in pairs(t) do if k > max then max = k end end\n"
"print(max)"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:400
msgid "count_map.lua"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:402
msgid "Get the number of elements in a map-like table."
msgstr ""

#: ../doc/book/app_server/cookbook.rst:404
msgid "#!/usr/bin/env tarantool\n"
"\n"
"local map = { a = 10, b = 15, c = 20 }\n"
"local size = 0\n"
"for _ in pairs(map) do size = size + 1; end\n"
"print(size)"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:417
msgid "swap.lua"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:419
msgid "Use a Lua peculiarity to swap two variables without needing a third variable."
msgstr ""

#: ../doc/book/app_server/cookbook.rst:421
msgid "#!/usr/bin/env tarantool\n"
"\n"
"local x = 1\n"
"local y = 2\n"
"x, y = y, x\n"
"print(x, y)"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:434
msgid "class.lua"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:436
msgid "Create a class, create a metatable for the class, create an instance of the class. Another illustration is at `http://lua-users.org/wiki/LuaClassesWithMetatable <http://lua-users.org/wiki/LuaClassesWithMetatable>`_."
msgstr ""

#: ../doc/book/app_server/cookbook.rst:440
msgid "#!/usr/bin/env tarantool\n"
"\n"
"-- define class objects\n"
"local myclass_somemethod = function(self)\n"
"    print('test 1', self.data)\n"
"end\n"
"\n"
"local myclass_someothermethod = function(self)\n"
"    print('test 2', self.data)\n"
"end\n"
"\n"
"local myclass_tostring = function(self)\n"
"    return 'MyClass <'..self.data..'>'\n"
"end\n"
"\n"
"local myclass_mt = {\n"
"    __tostring = myclass_tostring;\n"
"    __index = {\n"
"        somemethod = myclass_somemethod;\n"
"        someothermethod = myclass_someothermethod;\n"
"    }\n"
"}\n"
"\n"
"-- create a new object of myclass\n"
"local object = setmetatable({ data = 'data'}, myclass_mt)\n"
"print(object:somemethod())\n"
"print(object.data)"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:474
msgid "garbage.lua"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:476
msgid "Activate the `Lua garbage collector <https://www.lua.org/manual/5.1/manual.html#2.10>`_ with the `collectgarbage function <https://www.lua.org/manual/5.1/manual.html#pdf-collectgarbage>`_."
msgstr ""

#: ../doc/book/app_server/cookbook.rst:479
msgid "#!/usr/bin/env tarantool\n"
"\n"
"collectgarbage('collect')"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:489
msgid "fiber_producer_and_consumer.lua"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:491
msgid "Start one fiber for producer and one fiber for consumer. Use :ref:`fiber.channel() <fiber_ipc-channel>` to exchange data and synchronize. One can tweak the channel size (:code:`ch_size` in the program code) to control the number of simultaneous tasks waiting for processing."
msgstr ""

#: ../doc/book/app_server/cookbook.rst:496
msgid "#!/usr/bin/env tarantool\n"
"\n"
"local fiber = require('fiber')\n"
"local function consumer_loop(ch, i)\n"
"    -- initialize consumer synchronously or raise an error()\n"
"    fiber.sleep(0) -- allow fiber.create() to continue\n"
"    while true do\n"
"        local data = ch:get()\n"
"        if data == nil then\n"
"            break\n"
"        end\n"
"        print('consumed', i, data)\n"
"        fiber.sleep(math.random()) -- simulate some work\n"
"    end\n"
"end\n"
"\n"
"local function producer_loop(ch, i)\n"
"    -- initialize consumer synchronously or raise an error()\n"
"    fiber.sleep(0) -- allow fiber.create() to continue\n"
"    while true do\n"
"        local data = math.random()\n"
"        ch:put(data)\n"
"        print('produced', i, data)\n"
"    end\n"
"end\n"
"\n"
"local function start()\n"
"    local consumer_n = 5\n"
"    local producer_n = 3\n"
"\n"
"    -- Create a channel\n"
"    local ch_size = math.max(consumer_n, producer_n)\n"
"    local ch = fiber.channel(ch_size)\n"
"\n"
"    -- Start consumers\n"
"    for i=1, consumer_n,1 do\n"
"        fiber.create(consumer_loop, ch, i)\n"
"    end\n"
"\n"
"    -- Start producers\n"
"    for i=1, producer_n,1 do\n"
"        fiber.create(producer_loop, ch, i)\n"
"    end\n"
"end\n"
"\n"
"start()\n"
"print('started')"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:550
msgid "socket_tcpconnect.lua"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:552
msgid "Use :ref:`socket.tcp_connect() <socket-tcp_connect>` to connect to a remote host via TCP. Display the connection details and the result of a GET request."
msgstr ""

#: ../doc/book/app_server/cookbook.rst:556
msgid "#!/usr/bin/env tarantool\n"
"\n"
"local s = require('socket').tcp_connect('google.com', 80)\n"
"print(s:peer().host)\n"
"print(s:peer().family)\n"
"print(s:peer().type)\n"
"print(s:peer().protocol)\n"
"print(s:peer().port)\n"
"print(s:write(\"GET / HTTP/1.0\\r\\n\\r\\n\"))\n"
"print(s:read('\\r\\n'))\n"
"print(s:read('\\r\\n'))"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:574
msgid "socket_tcp_echo.lua"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:576
msgid "Use :ref:`socket.tcp_connect() <socket-tcp_connect>` to set up a simple TCP server, by creating a function that handles requests and echos them, and passing the function to :ref:`socket.tcp_server() <socket-tcp_server>`. This program has been used to test with 100,000 clients, with each client getting a separate fiber."
msgstr ""

#: ../doc/book/app_server/cookbook.rst:584
msgid "#!/usr/bin/env tarantool\n"
"\n"
"local function handler(s, peer)\n"
"    s:write(\"Welcome to test server, \" .. peer.host ..\"\\n\")\n"
"    while true do\n"
"        local line = s:read('\\n')\n"
"        if line == nil then\n"
"            break -- error or eof\n"
"        end\n"
"        if not s:write(\"pong: \"..line) then\n"
"            break -- error or eof\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"local server, addr = require('socket').tcp_server('localhost', 3311, handler)"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:607
msgid "getaddrinfo.lua"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:609
msgid "Use :ref:`socket.getaddrinfo() <socket-getaddrinfo>` to perform non-blocking DNS resolution, getting both the AF_INET6 and AF_INET information for 'google.com'. This technique is not always necessary for tcp connections because :ref:`socket.tcp_connect() <socket-tcp_connect>` performs `socket.getaddrinfo` under the hood, before trying to connect to the first available address."
msgstr ""

#: ../doc/book/app_server/cookbook.rst:617
msgid "#!/usr/bin/env tarantool\n"
"\n"
"local s = require('socket').getaddrinfo('google.com', 'http', { type = 'SOCK_STREAM' })\n"
"print('host=',s[1].host)\n"
"print('family=',s[1].family)\n"
"print('type=',s[1].type)\n"
"print('protocol=',s[1].protocol)\n"
"print('port=',s[1].port)\n"
"print('host=',s[2].host)\n"
"print('family=',s[2].family)\n"
"print('type=',s[2].type)\n"
"print('protocol=',s[2].protocol)\n"
"print('port=',s[2].port)"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:637
msgid "socket_udp_echo.lua"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:639
msgid "Tarantool does not currently have a `udp_server` function, therefore socket_udp_echo.lua is more complicated than socket_tcp_echo.lua. It can be implemented with sockets and fibers."
msgstr ""

#: ../doc/book/app_server/cookbook.rst:644
msgid "#!/usr/bin/env tarantool\n"
"\n"
"local socket = require('socket')\n"
"local errno = require('errno')\n"
"local fiber = require('fiber')\n"
"\n"
"local function udp_server_loop(s, handler)\n"
"    fiber.name(\"udp_server\")\n"
"    while true do\n"
"        -- try to read a datagram first\n"
"        local msg, peer = s:recvfrom()\n"
"        if msg == \"\" then\n"
"            -- socket was closed via s:close()\n"
"            break\n"
"        elseif msg ~= nil then\n"
"            -- got a new datagram\n"
"            handler(s, peer, msg)\n"
"        else\n"
"            if s:errno() == errno.EAGAIN or s:errno() == errno.EINTR then\n"
"                -- socket is not ready\n"
"                s:readable() -- yield, epoll will wake us when new data arrives\n"
"            else\n"
"                -- socket error\n"
"                local msg = s:error()\n"
"                s:close() -- save resources and don't wait GC\n"
"                error(\"Socket error: \" .. msg)\n"
"            end\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"local function udp_server(host, port, handler)\n"
"    local s = socket('AF_INET', 'SOCK_DGRAM', 0)\n"
"    if not s then\n"
"        return nil -- check errno:strerror()\n"
"    end\n"
"    if not s:bind(host, port) then\n"
"        local e = s:errno() -- save errno\n"
"        s:close()\n"
"        errno(e) -- restore errno\n"
"        return nil -- check errno:strerror()\n"
"    end\n"
"\n"
"    fiber.create(udp_server_loop, s, handler) -- start a new background fiber\n"
"    return s\n"
"end"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:693
msgid "A function for a client that connects to this server could look something like this ..."
msgstr ""

#: ../doc/book/app_server/cookbook.rst:696
msgid "local function handler(s, peer, msg)\n"
"    -- You don't have to wait until socket is ready to send UDP\n"
"    -- s:writable()\n"
"    s:sendto(peer.host, peer.port, \"Pong: \" .. msg)\n"
"end\n"
"\n"
"local server = udp_server('127.0.0.1', 3548, handler)\n"
"if not server then\n"
"    error('Failed to bind: ' .. errno.strerror())\n"
"end\n"
"\n"
"print('Started')\n"
"\n"
"require('console').start()"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:717
msgid "http_get.lua"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:719
msgid "Use the :ref:`http module <http-module>` to get data via HTTP."
msgstr ""

#: ../doc/book/app_server/cookbook.rst:722
msgid "#!/usr/bin/env tarantool\n"
"\n"
"local http_client = require('http.client')\n"
"local json = require('json')\n"
"local r = http_client.get('http://api.openweathermap.org/data/2.5/weather?q=Oakland,us')\n"
"if r.status ~= 200 then\n"
"    print('Failed to get weather forecast ', r.reason)\n"
"    return\n"
"end\n"
"local data = json.decode(r.body)\n"
"print('Oakland wind speed: ', data.wind.speed)"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:740
msgid "http_send.lua"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:742
msgid "Use the :ref:`http module <http-module>` to send data via HTTP."
msgstr ""

#: ../doc/book/app_server/cookbook.rst:745
msgid "#!/usr/bin/env tarantool\n"
"\n"
"local http_client = require('http.client')\n"
"local json = require('json')\n"
"local data = json.encode({ Key = 'Value'})\n"
"local headers = { Token = 'xxxx', ['X-Secret-Value'] = 42 }\n"
"local r = http_client.post('http://localhost:8081', data, { headers = headers})\n"
"if r.status == 200 then\n"
"    print 'Success'\n"
"end"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:762
msgid "http_server.lua"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:764
msgid "Use the `http`_ `rock`_ (which must first be installed) to turn Tarantool into a web server."
msgstr ""

#: ../doc/book/app_server/cookbook.rst:767
msgid "#!/usr/bin/env tarantool\n"
"\n"
"local function handler(self)\n"
"    return self:render{ json = { ['Your-IP-Is'] = self.peer.host } }\n"
"end\n"
"\n"
"local server = require('http.server').new(nil, 8080) -- listen *:8080\n"
"server:route({ path = '/' }, handler)\n"
"server:start()\n"
"-- connect to localhost:8080 and see json"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:784
msgid "http_generate_html.lua"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:786
msgid "Use the `http`_ `rock` (which must first be installed) to generate HTML pages from templates. The `http`_ `rock`_ has a fairly simple template engine which allows execution of regular Lua code inside text blocks (like PHP). Therefore there is no need to learn new languages in order to write templates."
msgstr ""

#: ../doc/book/app_server/cookbook.rst:792
msgid "#!/usr/bin/env tarantool\n"
"\n"
"local function handler(self)\n"
"local fruits = { 'Apple', 'Orange', 'Grapefruit', 'Banana'}\n"
"    return self:render{ fruits = fruits }\n"
"end\n"
"\n"
"local server = require('http.server').new(nil, 8080) -- nil means '*'\n"
"server:route({ path = '/', file = 'index.html.lua' }, handler)\n"
"server:start()"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:805
msgid "An \"HTML\" file for this server, including Lua, could look like this (it would produce \"1 Apple | 2 Orange | 3 Grapefruit | 4 Banana\")."
msgstr ""

#: ../doc/book/app_server/cookbook.rst:808
msgid "<html>\n"
"<body>\n"
"    <table border=\"1\">\n"
"        % for i,v in pairs(fruits) do\n"
"        <tr>\n"
"            <td><%= i %></td>\n"
"            <td><%= v %></td>\n"
"        </tr>\n"
"        % end\n"
"    </table>\n"
"</body>\n"
"</html>"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:5
msgid "Creating an application"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:7
msgid "Further we walk you through key programming practices that will give you a good start in writing Lua applications for Tarantool. For an adventure, this is a story of implementing... a real microservice based on Tarantool! We implement a backend for a simplified version of `Pokémon Go <https://en.wikipedia.org/wiki/Pokémon_Go>`_, a location-based augmented reality game released in mid-2016. In this game, players use a mobile device's GPS capability to locate, capture, battle and train virtual monsters called \"pokémon\", who appear on the screen as if they were in the same real-world location as the player."
msgstr ""

#: ../doc/book/app_server/creating_app.rst:17
msgid "To stay within the walk-through format, let's narrow the original gameplay as follows. We have a map with pokémon spawn locations. Next, we have multiple players who can send catch-a-pokémon requests to the server (which runs our Tarantool microservice). The server replies whether the pokémon is caught or not, increases the player's pokémon counter if yes, and triggers the respawn-a-pokémon method that spawns a new pokémon at the same location in a while."
msgstr ""

#: ../doc/book/app_server/creating_app.rst:25
msgid "We leave client-side applications outside the scope of this story. Yet we promise a mini-demo in the end to simulate real users and give us some fun. :-)"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:31
msgid "First, what would be the best way to deliver our microservice?"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:37
msgid "Modules, rocks and applications"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:39
msgid "To make our game logic available to other developers and Lua applications, let's put it into a Lua module."
msgstr ""

#: ../doc/book/app_server/creating_app.rst:42
msgid "A **module** (called \"rock\" in Lua) is an optional library which enhances Tarantool functionality. So, we can install our logic as a module in Tarantool and use it from any Tarantool application or module. Like applications, modules in Tarantool can be written in Lua (rocks), C or C++."
msgstr ""

#: ../doc/book/app_server/creating_app.rst:47
msgid "Modules are good for two things:"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:49
msgid "easier **code management** (reuse, packaging, versioning), and"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:50
msgid "hot **code reload** without restarting the Tarantool instance."
msgstr ""

#: ../doc/book/app_server/creating_app.rst:52
msgid "Technically, a module is a file with source code that exports its functions in an API. For example, here is a Lua module named ``mymodule.lua`` that exports one function named ``myfun``:"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:56
msgid "local exports = {}\n"
"exports.myfun = function(input_string)\n"
"   print('Hello', input_string)\n"
"end\n"
"return exports"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:64
msgid "To launch the function ``myfun()`` -- from another module, from a Lua application, or from Tarantool itself, -- we need to save this module as a file, then load this module with the ``require()`` directive and call the exported function."
msgstr ""

#: ../doc/book/app_server/creating_app.rst:68
msgid "For example, here's a Lua application that uses ``myfun()`` function from ``mymodule.lua`` module:"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:71
msgid "-- loading the module\n"
"local mymodule = require('mymodule')\n"
"\n"
"-- calling myfun() from within test() function\n"
"local test = function()\n"
"  mymodule.myfun()\n"
"end"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:81
msgid "A thing to remember here is that the ``require()`` directive takes load paths to Lua modules from the ``package.path`` variable. This is a semicolon-separated string, where a question mark is used to interpolate the module name. By default, this variable contains system-wide Lua paths and the working directory. But if we put our modules inside a specific folder (e.g. ``scripts/``), we need to add this folder to ``package.path`` before any calls to ``require()``:"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:88
msgid "package.path = 'scripts/?.lua;' .. package.path"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:92
msgid "For our microservice, a simple and convenient solution would be to put all methods in a Lua module (say ``pokemon.lua``) and to write a Lua application (say ``game.lua``) that initializes the gaming environment and starts the game loop."
msgstr ""

#: ../doc/book/app_server/creating_app.rst:100
msgid "Now let's get down to implementation details. In our game, we need three entities:"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:102
msgid "**map**, which is an array of pokémons with coordinates of respawn locations; in this version of the game, let a location be a rectangle identified with two points, upper-left and lower-right;"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:105
msgid "**player**, which has an ID, a name, and coordinates of the player's location point;"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:107
msgid "**pokémon**, which has the same fields as the player, plus a status (active/inactive, that is present on the map or not) and a catch probability (well, let's give our pokémons a chance to escape :-) )"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:111
msgid "We'll store these entities as tuples in Tarantool spaces. But to deliver our backend application as a microservice, the good practice would be to send/receive our data in the universal JSON format, thus using Tarantool as a document storage."
msgstr ""

#: ../doc/book/app_server/creating_app.rst:119
msgid "Avro schemas"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:121
msgid "To store JSON data as tuples, we will apply a savvy practice which reduces data footprint and ensures all stored documents are valid. We will use Tarantool module `avro-schema <https://github.com/tarantool/avro-schema>`_ which checks the schema of a JSON document and converts it to a Tarantool tuple. The tuple will contain only field values, and thus take a lot less space than the original document. In avro-schema terms, converting JSON documents to tuples is \"flattening\", and restoring the original documents is \"unflattening\". The usage is quite straightforward:"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:130
msgid "For each entity, we need to define a schema in `Apache Avro schema <https://en.wikipedia.org/wiki/Apache_Avro>`_ syntax, where we list the entity's fields with their names and `Avro data types <http://avro.apache.org/docs/current/spec.html#schema_primitive>`_."
msgstr ""

#: ../doc/book/app_server/creating_app.rst:134
msgid "At initialization, we call ``avro-schema.create()`` that creates objects in memory for all schema entities, and ``compile()`` that generates flatten/unflatten methods for each entity."
msgstr ""

#: ../doc/book/app_server/creating_app.rst:137
msgid "Further on, we just call flatten/unflatten methods for a respective entity on receiving/sending the entity's data."
msgstr ""

#: ../doc/book/app_server/creating_app.rst:140
msgid "Here's what our schema definitions for the player and pokémon entities look like:"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:142
msgid "local schema = {\n"
"    player = {\n"
"        type=\"record\",\n"
"        name=\"player_schema\",\n"
"        fields={\n"
"            {name=\"id\", type=\"long\"},\n"
"            {name=\"name\", type=\"string\"},\n"
"            {\n"
"                name=\"location\",\n"
"                type= {\n"
"                    type=\"record\",\n"
"                    name=\"player_location\",\n"
"                    fields={\n"
"                        {name=\"x\", type=\"double\"},\n"
"                        {name=\"y\", type=\"double\"}\n"
"                    }\n"
"                }\n"
"            }\n"
"        }\n"
"    },\n"
"    pokemon = {\n"
"        type=\"record\",\n"
"        name=\"pokemon_schema\",\n"
"        fields={\n"
"            {name=\"id\", type=\"long\"},\n"
"            {name=\"status\", type=\"string\"},\n"
"            {name=\"name\", type=\"string\"},\n"
"            {name=\"chance\", type=\"double\"},\n"
"            {\n"
"                name=\"location\",\n"
"                type= {\n"
"                    type=\"record\",\n"
"                    name=\"pokemon_location\",\n"
"                    fields={\n"
"                        {name=\"x\", type=\"double\"},\n"
"                        {name=\"y\", type=\"double\"}\n"
"                    }\n"
"                }\n"
"            }\n"
"        }\n"
"    }\n"
"}"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:187
msgid "And here's how we create and compile our entities at initialization:"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:189
msgid "-- load avro-schema module with require()\n"
"local avro = require('avro_schema')\n"
"\n"
"-- create models\n"
"local ok_m, pokemon = avro.create(schema.pokemon)\n"
"local ok_p, player = avro.create(schema.player)\n"
"if ok_m and ok_p then\n"
"    -- compile models\n"
"    local ok_cm, compiled_pokemon = avro.compile(pokemon)\n"
"    local ok_cp, compiled_player = avro.compile(player)\n"
"    if ok_cm and ok_cp then\n"
"        -- start the game\n"
"        <...>\n"
"    else\n"
"        log.error('Schema compilation failed')\n"
"    end\n"
"else\n"
"    log.info('Schema creation failed')\n"
"end\n"
"return false"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:212
msgid "As for the map entity, it would be an overkill to introduce a schema for it, because we have only one map in the game, it has very few fields, and -- which is most important -- we use the map only inside our logic, never exposing it to external users."
msgstr ""

#: ../doc/book/app_server/creating_app.rst:220
msgid "Next, we need methods to implement the game logic. To simulate object-oriented programming in our Lua code, let's store all Lua functions and shared variables in a single local variable (let's name it as ``game``). This will allow us to address functions or variables from within our module as ``self.func_name`` or ``self.var_name``. Like this:"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:226
msgid "local game = {\n"
"    -- a local variable\n"
"    num_players = 0,\n"
"\n"
"    -- a method that prints a local variable\n"
"    hello = function(self)\n"
"      print('Hello! Your player number is ' .. self.num_players .. '.')\n"
"    end,\n"
"\n"
"    -- a method that calls another method and returns a local variable\n"
"    sign_in = function(self)\n"
"      self.num_players = self.num_players + 1\n"
"      self:hello()\n"
"      return self.num_players\n"
"    end\n"
"}"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:245
msgid "In OOP terms, we can now regard local variables inside ``game`` as object fields, and local functions as object methods."
msgstr ""

#: ../doc/book/app_server/creating_app.rst:250
msgid "In this manual, Lua examples use **local** variables. Use **global** variables with caution, since the module’s users may be unaware of them."
msgstr ""

#: ../doc/book/app_server/creating_app.rst:253
msgid "To enable/disable the use of undeclared global variables in your Lua code, use Tarantool's :ref:`strict <strict-module>` module."
msgstr ""

#: ../doc/book/app_server/creating_app.rst:256
msgid "So, our game module will have the following methods:"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:258
msgid "``catch()`` to calculate whether the pokémon was caught (besides the coordinates of both the player and pokémon, this method will apply a probability factor, so not every pokémon within the player's reach will be caught);"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:262
msgid "``respawn()`` to add missing pokémons to the map, say, every 60 seconds (we assume that a frightened pokémon runs away, so we remove a pokémon from the map on any catch attempt and add it back to the map in a while);"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:265
msgid "``notify()`` to log information about caught pokémons (like \"Player 1 caught pokémon A\");"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:267
msgid "``start()`` to initialize the game (it will create database spaces, create and compile avro schemas, and launch ``respawn()``)."
msgstr ""

#: ../doc/book/app_server/creating_app.rst:270
msgid "Besides, it would be convenient to have methods for working with Tarantool storage. For example:"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:273
msgid "``add_pokemon()`` to add a pokémon to the database, and"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:274
msgid "``map()`` to populate the map with all pokémons stored in Tarantool."
msgstr ""

#: ../doc/book/app_server/creating_app.rst:276
msgid "We'll need these two methods primarily when initializing our game, but we can also call them later, for example to test our code."
msgstr ""

#: ../doc/book/app_server/creating_app.rst:283
msgid "Bootstrapping a database"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:285
msgid "Let's discuss game initialization. In ``start()`` method, we need to populate Tarantool spaces with pokémon data. Why not keep all game data in memory? Why use a database? The answer is: :ref:`persistence <index-box_persistence>`. Without a database, we risk losing data on power outage, for example. But if we store our data in an in-memory database, Tarantool takes care to persist it on disk whenever it's changed. This gives us one more benefit: quick startup in case of failure. Tarantool has a :ref:`smart algorithm <internals-recovery_process>` that quickly loads all data from disk into memory on startup, so the warm-up takes little time."
msgstr ""

#: ../doc/book/app_server/creating_app.rst:295
msgid "We'll be using functions from Tarantool built-in :ref:`box <box-module>` module:"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:297
msgid "``box.schema.create_space('pokemons')`` to create a space named ``pokemon`` for storing information about pokémons (we don't create a similar space for players, because we intend to only send/receive player information via API calls, so we needn't store it);"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:301
msgid "``box.space.pokemons:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})`` to create a primary HASH index by pokémon ID;"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:303
msgid "``box.space.pokemons:create_index('status', {type = 'tree', parts = {2, 'str'}})`` to create a secondary TREE index by pokémon status."
msgstr ""

#: ../doc/book/app_server/creating_app.rst:306
msgid "Notice the ``parts =`` argument in the index specification. The pokémon ID is the first field in a Tarantool tuple since it’s the first member of the respective Avro type. So does the pokémon status. The actual JSON document may have ID or status fields at any position of the JSON map."
msgstr ""

#: ../doc/book/app_server/creating_app.rst:311
msgid "The implementation of ``start()`` method looks like this:"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:313
msgid "-- create game object\n"
"start = function(self)\n"
"    -- create spaces and indexes\n"
"    box.once('init', function()\n"
"        box.schema.create_space('pokemons')\n"
"        box.space.pokemons:create_index(\n"
"            \"primary\", {type = 'hash', parts = {1, 'unsigned'}}\n"
"        )\n"
"        box.space.pokemons:create_index(\n"
"            \"status\", {type = \"tree\", parts = {2, 'str'}}\n"
"        )\n"
"    end)\n"
"\n"
"    -- create models\n"
"    local ok_m, pokemon = avro.create(schema.pokemon)\n"
"    local ok_p, player = avro.create(schema.player)\n"
"    if ok_m and ok_p then\n"
"        -- compile models\n"
"        local ok_cm, compiled_pokemon = avro.compile(pokemon)\n"
"        local ok_cp, compiled_player = avro.compile(player)\n"
"        if ok_cm and ok_cp then\n"
"            -- start the game\n"
"            <...>\n"
"        else\n"
"            log.error('Schema compilation failed')\n"
"        end\n"
"    else\n"
"        log.info('Schema creation failed')\n"
"    end\n"
"    return false\n"
"end"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:351
msgid "GIS"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:353
msgid "Now let's discuss ``catch()``, which is the main method in our gaming logic."
msgstr ""

#: ../doc/book/app_server/creating_app.rst:355
msgid "Here we receive the player's coordinates and the target pokémon's ID number, and we need to answer whether the player has actually caught the pokémon or not (remember that each pokémon has a chance to escape)."
msgstr ""

#: ../doc/book/app_server/creating_app.rst:359
msgid "First thing, we validate the received player data against its :ref:`Avro schema <app_server-avro_schemas>`. And we check whether such a pokémon exists in our database and is displayed on the map (the pokémon must have the active status):"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:364
msgid "catch = function(self, pokemon_id, player)\n"
"    -- check player data\n"
"    local ok, tuple = self.player_model.flatten(player)\n"
"    if not ok then\n"
"        return false\n"
"    end\n"
"    -- get pokemon data\n"
"    local p_tuple = box.space.pokemons:get(pokemon_id)\n"
"    if p_tuple == nil then\n"
"        return false\n"
"    end\n"
"    local ok, pokemon = self.pokemon_model.unflatten(p_tuple)\n"
"    if not ok then\n"
"        return false\n"
"    end\n"
"    if pokemon.status ~= self.state.ACTIVE then\n"
"        return false\n"
"    end\n"
"    -- more catch logic to follow\n"
"    <...>\n"
"end"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:388
msgid "Next, we calculate the answer: caught or not."
msgstr ""

#: ../doc/book/app_server/creating_app.rst:390
msgid "To work with geographical coordinates, we use Tarantool `gis <https://github.com/tarantool/gis>`_ module."
msgstr ""

#: ../doc/book/app_server/creating_app.rst:393
msgid "To keep things simple, we don't load any specific map, assuming that we deal with a world map. And we do not validate incoming coordinates, assuming again that all received locations are within the planet Earth."
msgstr ""

#: ../doc/book/app_server/creating_app.rst:397
msgid "We use two geo-specific variables:"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:399
msgid "``wgs84``, which stands for the latest revision of the World Geodetic System standard, `WGS84 <https://en.wikipedia.org/wiki/World_Geodetic_System#WGS84>`_. Basically, it comprises a standard coordinate system for the Earth and represents the Earth as an ellipsoid."
msgstr ""

#: ../doc/book/app_server/creating_app.rst:403
msgid "``nationalmap``, which stands for the `US National Atlas Equal Area <https://epsg.io/2163>`_. This is a projected coordinates system based on WGS84. It gives us a zero base for location projection and allows positioning our players and pokémons in meters."
msgstr ""

#: ../doc/book/app_server/creating_app.rst:408
msgid "Both these systems are listed in the EPSG Geodetic Parameter Registry, where each system has a unique number. In our code, we assign these listing numbers to respective variables:"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:412
msgid "wgs84 = 4326,\n"
"nationalmap = 2163,"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:417
msgid "For our game logic, we need one more variable, ``catch_distance``, which defines how close a player must get to a pokémon before trying to catch it. Let's set the distance to 100 meters."
msgstr ""

#: ../doc/book/app_server/creating_app.rst:421
msgid "catch_distance = 100,"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:425
msgid "Now we're ready to calculate the answer. We need to project the current location of both player (``p_pos``) and pokémon (``m_pos``) on the map, check whether the player is close enough to the pokémon (using ``catch_distance``), and calculate whether the player has caught the pokémon (here we generate some random value and let the pokémon escape if the random value happens to be less than 100 minus pokémon's chance value):"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:432
msgid "-- project locations\n"
"local m_pos = gis.Point(\n"
"    {pokemon.location.x, pokemon.location.y}, self.wgs84\n"
"):transform(self.nationalmap)\n"
"local p_pos = gis.Point(\n"
"    {player.location.x, player.location.y}, self.wgs84\n"
"):transform(self.nationalmap)\n"
"\n"
"-- check catch distance condition\n"
"if p_pos:distance(m_pos) > self.catch_distance then\n"
"    return false\n"
"end\n"
"-- try to catch pokemon\n"
"local caught = math.random(100) >= 100 - pokemon.chance\n"
"if caught then\n"
"    -- update and notify on success\n"
"    box.space.pokemons:update(\n"
"        pokemon_id, {{'=', self.STATUS, self.state.CAUGHT}}\n"
"    )\n"
"    self:notify(player, pokemon)\n"
"end\n"
"return caught"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:461
msgid "Index iterators"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:463
msgid "By our gameplay, all caught pokémons are returned back to the map. We do this for all pokémons on the map every 60 seconds using ``respawn()`` method. We iterate through pokémons by status using Tarantool index iterator function :ref:`index:pairs <box_index-index_pairs>` and reset the statuses of all \"caught\" pokémons back to \"active\" using ``box.space.pokemons:update()``."
msgstr ""

#: ../doc/book/app_server/creating_app.rst:469
msgid "respawn = function(self)\n"
"    fiber.name('Respawn fiber')\n"
"    for _, tuple in box.space.pokemons.index.status:pairs(\n"
"           self.state.CAUGHT) do\n"
"        box.space.pokemons:update(\n"
"            tuple[self.ID],\n"
"            {{'=', self.STATUS, self.state.ACTIVE}}\n"
"        )\n"
"    end\n"
" end"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:482
msgid "For readability, we introduce named fields:"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:484
msgid "ID = 1, STATUS = 2,"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:487
msgid "The complete implementation of ``start()`` now looks like this:"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:489
msgid "-- create game object\n"
"start = function(self)\n"
"    -- create spaces and indexes\n"
"    box.once('init', function()\n"
"       box.schema.create_space('pokemons')\n"
"       box.space.pokemons:create_index(\n"
"           \"primary\", {type = 'hash', parts = {1, 'unsigned'}}\n"
"       )\n"
"       box.space.pokemons:create_index(\n"
"           \"status\", {type = \"tree\", parts = {2, 'str'}}\n"
"       )\n"
"    end)\n"
"\n"
"    -- create models\n"
"    local ok_m, pokemon = avro.create(schema.pokemon)\n"
"    local ok_p, player = avro.create(schema.player)\n"
"    if ok_m and ok_p then\n"
"        -- compile models\n"
"        local ok_cm, compiled_pokemon = avro.compile(pokemon)\n"
"        local ok_cp, compiled_player = avro.compile(player)\n"
"        if ok_cm and ok_cp then\n"
"            -- start the game\n"
"            self.pokemon_model = compiled_pokemon\n"
"            self.player_model = compiled_player\n"
"            self.respawn()\n"
"            log.info('Started')\n"
"            return true\n"
"         else\n"
"            log.error('Schema compilation failed')\n"
"         end\n"
"    else\n"
"        log.info('Schema creation failed')\n"
"    end\n"
"    return false\n"
"end"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:529
msgid "Fibers"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:531
msgid "But wait! If we launch it as shown above -- ``self.respawn()`` -- the function will be executed only once, just like all the other methods. But we need to execute ``respawn()`` every 60 seconds. Creating a :ref:`fiber <fiber-module>` is the Tarantool way of making application logic work in the background at all times."
msgstr ""

#: ../doc/book/app_server/creating_app.rst:537
msgid "A **fiber** exists for executing instruction sequences but it is not a thread. The key difference is that threads use preemptive multitasking, while fibers use cooperative multitasking. This gives fibers the following two advantages over threads:"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:542
msgid "Better controllability. Threads often depend on the kernel's thread scheduler to preempt a busy thread and resume another thread, so preemption may occur unpredictably. Fibers yield themselves to run another fiber while executing, so yields are controlled by application logic."
msgstr ""

#: ../doc/book/app_server/creating_app.rst:546
msgid "Higher performance. Threads require more resources to preempt as they need to address the system kernel. Fibers are lighter and faster as they don't need to address the kernel to yield."
msgstr ""

#: ../doc/book/app_server/creating_app.rst:550
msgid "Yet fibers have some limitations as compared with threads, the main limitation being no multi-core mode. All fibers in an application belong to a single thread, so they all use the same CPU core as the parent thread. Meanwhile, this limitation is not really serious for Tarantool applications, because a typical bottleneck for Tarantool is the HDD, not the CPU."
msgstr ""

#: ../doc/book/app_server/creating_app.rst:556
msgid "A fiber has all the features of a Lua `coroutine <http://www.lua.org/pil/contents.html#9>`_ and all programming concepts that apply for Lua coroutines will apply for fibers as well. However, Tarantool has made some enhancements for fibers and has used fibers internally. So, although use of coroutines is possible and supported, use of fibers is recommended."
msgstr ""

#: ../doc/book/app_server/creating_app.rst:563
msgid "Well, performance or controllability are of little importance in our case. We'll launch ``respawn()`` in a fiber to make it work in the background all the time. To do so, we'll need to amend ``respawn()``:"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:567
msgid "respawn = function(self)\n"
"    -- let's give our fiber a name;\n"
"    -- this will produce neat output in fiber.info()\n"
"    fiber.name('Respawn fiber')\n"
"    while true do\n"
"        for _, tuple in box.space.pokemons.index.status:pairs(\n"
"                self.state.CAUGHT) do\n"
"            box.space.pokemons:update(\n"
"                tuple[self.ID],\n"
"                {{'=', self.STATUS, self.state.ACTIVE}}\n"
"            )\n"
"        end\n"
"        fiber.sleep(self.respawn_time)\n"
"    end\n"
"end"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:585
msgid "and call it as a fiber in ``start()``:"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:587
msgid "start = function(self)\n"
"    -- create spaces and indexes\n"
"        <...>\n"
"    -- create models\n"
"        <...>\n"
"    -- compile models\n"
"        <...>\n"
"    -- start the game\n"
"       self.pokemon_model = compiled_pokemon\n"
"       self.player_model = compiled_player\n"
"       fiber.create(self.respawn, self)\n"
"       log.info('Started')\n"
"    -- errors if schema creation or compilation fails\n"
"       <...>\n"
"end"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:607
msgid "Logging"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:609
msgid "One more helpful function that we used in ``start()`` was ``log.infо()`` from Tarantool :ref:`log <log-module>` module. We also need this function in ``notify()`` to add a record to the log file on every successful catch:"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:613
msgid "-- event notification\n"
"notify = function(self, player, pokemon)\n"
"    log.info(\"Player '%s' caught '%s'\", player.name, pokemon.name)\n"
"end"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:620
msgid "We use default Tarantool :ref:`log settings <cfg_logging>`, so we'll see the log output in console when we launch our application in script mode."
msgstr ""

#: ../doc/book/app_server/creating_app.rst:626
msgid "Great! We've discussed all programming practices used in our Lua module (see `pokemon.lua <https://github.com/tarantool/pokemon/blob/1.9/src/pokemon.lua>`_)."
msgstr ""

#: ../doc/book/app_server/creating_app.rst:629
msgid "Now let's prepare the test environment. As planned, we write a Lua application (see `game.lua <https://github.com/tarantool/pokemon/blob/1.9/game.lua>`_) to initialize Tarantool's database module, initialize our game, call the game loop and simulate a couple of player requests."
msgstr ""

#: ../doc/book/app_server/creating_app.rst:634
msgid "To launch our microservice, we put both ``pokemon.lua`` module and ``game.lua`` application in the current directory, install all external modules, and launch the Tarantool instance running our ``game.lua`` application (this example is for Ubuntu):"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:639
msgid "$ ls\n"
"game.lua  pokemon.lua\n"
"$ sudo apt-get install tarantool-gis\n"
"$ sudo apt-get install tarantool-avro-schema\n"
"$ tarantool game.lua"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:647
msgid "Tarantool starts and initializes the database. Then Tarantool executes the demo logic from ``game.lua``: adds a pokémon named Pikachu (its chance to be caught is very high, 99.1), displays the current map (it contains one active pokémon, Pikachu) and processes catch requests from two players. Player1 is located just near the lonely Pikachu pokémon and Player2 is located far away from it. As expected, the catch results in this output are \"true\" for Player1 and \"false\" for Player2. Finally, Tarantool displays the current map which is empty, because Pikachu is caught and temporarily inactive:"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:656
msgid "$ tarantool game.lua\n"
"2017-01-09 20:19:24.605 [6282] main/101/game.lua C> version 1.7.3-43-gf5fa1e1\n"
"2017-01-09 20:19:24.605 [6282] main/101/game.lua C> log level 5\n"
"2017-01-09 20:19:24.605 [6282] main/101/game.lua I> mapping 1073741824 bytes for tuple arena...\n"
"2017-01-09 20:19:24.609 [6282] main/101/game.lua I> initializing an empty data directory\n"
"2017-01-09 20:19:24.634 [6282] snapshot/101/main I> saving snapshot `./00000000000000000000.snap.inprogress'\n"
"2017-01-09 20:19:24.635 [6282] snapshot/101/main I> done\n"
"2017-01-09 20:19:24.641 [6282] main/101/game.lua I> ready to accept requests\n"
"2017-01-09 20:19:24.786 [6282] main/101/game.lua I> Started\n"
"---\n"
"- {'id': 1, 'status': 'active', 'location': {'y': 2, 'x': 1}, 'name': 'Pikachu', 'chance': 99.1}\n"
"...\n"
"\n"
"2017-01-09 20:19:24.789 [6282] main/101/game.lua I> Player 'Player1' caught 'Pikachu'\n"
"true\n"
"false\n"
"--- []\n"
"...\n"
"\n"
"2017-01-09 20:19:24.789 [6282] main C> entering the event loop"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:681
msgid "nginx"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:683
msgid "In the real life, this microservice would work over HTTP. Let's add `nginx <https://nginx.org/en/>`_ web server to our environment and make a similar demo. But how do we make Tarantool methods callable via REST API? We use nginx with `Tarantool nginx upstream <https://github.com/tarantool/nginx_upstream_module>`_ module and create one more Lua script (`app.lua <https://github.com/tarantool/pokemon/blob/1.9/src/app.lua>`_) that exports three of our game methods -- ``add_pokemon()``, ``map()`` and ``catch()`` -- as REST endpoints of the nginx upstream module:"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:692
msgid "local game = require('pokemon')\n"
"box.cfg{listen=3301}\n"
"game:start()\n"
"\n"
"-- add, map and catch functions exposed to REST API\n"
"function add(request, pokemon)\n"
"    return {\n"
"        result=game:add_pokemon(pokemon)\n"
"    }\n"
"end\n"
"\n"
"function map(request)\n"
"    return {\n"
"        map=game:map()\n"
"    }\n"
"end\n"
"\n"
"function catch(request, pid, player)\n"
"    local id = tonumber(pid)\n"
"    if id == nil then\n"
"        return {result=false}\n"
"    end\n"
"    return {\n"
"        result=game:catch(id, player)\n"
"    }\n"
"end"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:721
msgid "An easy way to configure and launch nginx would be to create a Docker container based on a `Docker image <https://hub.docker.com/r/tarantool/tarantool-nginx/>`_ with nginx and the upstream module already installed (see `http/Dockerfile <https://github.com/tarantool/pokemon/blob/1.9/http/Dockerfile>`_). We take a standard `nginx.conf <https://github.com/tarantool/pokemon/blob/1.9/http/nginx.conf>`_, where we define an upstream with our Tarantool backend running (this is another Docker container, see details below):"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:730
msgid "upstream tnt {\n"
"      server pserver:3301 max_fails=1 fail_timeout=60s;\n"
"      keepalive 250000;\n"
"}"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:737
msgid "and add some Tarantool-specific parameters (see descriptions in the upstream module's `README <https://github.com/tarantool/nginx_upstream_module#directives>`_ file):"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:741
msgid "server {\n"
"  server_name tnt_test;\n"
"\n"
"  listen 80 default deferred reuseport so_keepalive=on backlog=65535;\n"
"\n"
"  location = / {\n"
"      root /usr/local/nginx/html;\n"
"  }\n"
"\n"
"  location /api {\n"
"    # answers check infinity timeout\n"
"    tnt_read_timeout 60m;\n"
"    if ( $request_method = GET ) {\n"
"       tnt_method \"map\";\n"
"    }\n"
"    tnt_http_rest_methods get;\n"
"    tnt_http_methods all;\n"
"    tnt_multireturn_skip_count 2;\n"
"    tnt_pure_result on;\n"
"    tnt_pass_http_request on parse_args;\n"
"    tnt_pass tnt;\n"
"  }\n"
"}"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:767
msgid "Likewise, we put Tarantool server and all our game logic in a second Docker container based on the `official Tarantool 1.9 image <https://github.com/tarantool/docker>`_ (see `src/Dockerfile <https://github.com/tarantool/pokemon/blob/1.9/src/Dockerfile>`_) and set the container's default command to ``tarantool app.lua``. This is the backend."
msgstr ""

#: ../doc/book/app_server/creating_app.rst:776
msgid "Non-blocking IO"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:778
msgid "To test the REST API, we create a new script (`client.lua <https://github.com/tarantool/pokemon/blob/1.9/client/client.lua>`_), which is similar to our ``game.lua`` application, but makes HTTP POST and GET requests rather than calling Lua functions:"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:783
msgid "local http = require('curl').http()\n"
"local json = require('json')\n"
"local URI = os.getenv('SERVER_URI')\n"
"local fiber = require('fiber')\n"
"\n"
"local player1 = {\n"
"    name=\"Player1\",\n"
"    id=1,\n"
"    location = {\n"
"        x=1.0001,\n"
"        y=2.0003\n"
"    }\n"
"}\n"
"local player2 = {\n"
"    name=\"Player2\",\n"
"    id=2,\n"
"    location = {\n"
"        x=30.123,\n"
"        y=40.456\n"
"    }\n"
"}\n"
"\n"
"local pokemon = {\n"
"    name=\"Pikachu\",\n"
"    chance=99.1,\n"
"    id=1,\n"
"    status=\"active\",\n"
"    location = {\n"
"        x=1,\n"
"        y=2\n"
"    }\n"
"}\n"
"\n"
"function request(method, body, id)\n"
"    local resp = http:request(\n"
"        method, URI, body\n"
"    )\n"
"    if id ~= nil then\n"
"        print(string.format('Player %d result: %s',\n"
"            id, resp.body))\n"
"    else\n"
"        print(resp.body)\n"
"    end\n"
"end\n"
"\n"
"local players = {}\n"
"function catch(player)\n"
"    fiber.sleep(math.random(5))\n"
"    print('Catch pokemon by player ' .. tostring(player.id))\n"
"    request(\n"
"        'POST', '{\"method\": \"catch\",\n"
"        \"params\": [1, '..json.encode(player)..']}',\n"
"        tostring(player.id)\n"
"    )\n"
"    table.insert(players, player.id)\n"
"end\n"
"\n"
"print('Create pokemon')\n"
"request('POST', '{\"method\": \"add\",\n"
"    \"params\": ['..json.encode(pokemon)..']}')\n"
"request('GET', '')\n"
"\n"
"fiber.create(catch, player1)\n"
"fiber.create(catch, player2)\n"
"\n"
"-- wait for players\n"
"while #players ~= 2 do\n"
"    fiber.sleep(0.001)\n"
"end\n"
"\n"
"request('GET', '')\n"
"os.exit()"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:858
msgid "When you run this script, you’ll notice that both players have equal chances to make the first attempt at catching the pokémon. In a classical Lua script, a networked call blocks the script until it’s finished, so the first catch attempt can only be done by the player who entered the game first. In Tarantool, both players play concurrently, since all modules are integrated with Tarantool :ref:`cooperative multitasking <atomic-cooperative_multitasking>` and use non-blocking I/O."
msgstr ""

#: ../doc/book/app_server/creating_app.rst:866
msgid "Indeed, when Player1 makes its first REST call, the script doesn’t block. The fiber running ``catch()`` function on behalf of Player1 issues a non-blocking call to the operating system and yields control to the next fiber, which happens to be the fiber of Player2. Player2’s fiber does the same. When the network response is received, Player1's fiber is activated by Tarantool cooperative scheduler, and resumes its work. All Tarantool :ref:`modules <built_in_modules>` use non-blocking I/O and are integrated with Tarantool cooperative scheduler. For module developers, Tarantool provides an :ref:`API <index-c_api_reference>`."
msgstr ""

#: ../doc/book/app_server/creating_app.rst:875
msgid "For our HTTP test, we create a third container based on the `official Tarantool 1.9 image <https://github.com/tarantool/docker>`_ (see `client/Dockerfile <https://github.com/tarantool/pokemon/blob/1.9/client/Dockerfile>`_) and set the container's default command to ``tarantool client.lua``."
msgstr ""

#: ../doc/book/app_server/creating_app.rst:883
msgid "To run this test locally, download our `pokemon <https://github.com/tarantool/pokemon>`_ project from GitHub and say:"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:886
msgid "$ docker-compose build\n"
"$ docker-compose up"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:891
msgid "Docker Compose builds and runs all the three containers: ``pserver`` (Tarantool backend), ``phttp`` (nginx) and ``pclient`` (demo client). You can see log messages from all these containers in the console, pclient saying that it made an HTTP request to create a pokémon, made two catch requests, requested the map (empty since the pokémon is caught and temporarily inactive) and exited:"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:897
msgid "pclient_1  | Create pokemon\n"
"<...>\n"
"pclient_1  | {\"result\":true}\n"
"pclient_1  | {\"map\":[{\"id\":1,\"status\":\"active\",\"location\":{\"y\":2,\"x\":1},\"name\":\"Pikachu\",\"chance\":99.100000}]}\n"
"pclient_1  | Catch pokemon by player 2\n"
"pclient_1  | Catch pokemon by player 1\n"
"pclient_1  | Player 1 result: {\"result\":true}\n"
"pclient_1  | Player 2 result: {\"result\":false}\n"
"pclient_1  | {\"map\":[]}\n"
"pokemon_pclient_1 exited with code 0"
msgstr ""

#: ../doc/book/app_server/creating_app.rst:910
msgid "Congratulations! Here's the end point of our walk-through. As further reading, see more about :ref:`installing <app_server-installing_module>` and :ref:`contributing <app_server-contributing_module>` a module."
msgstr ""

#: ../doc/book/app_server/creating_app.rst:914
msgid "See also reference on :ref:`Tarantool modules <built_in_modules>` and :ref:`C API <index-c_api_reference>`, and don't miss our :ref:`Lua cookbook recipes <cookbook>`."
msgstr ""

#: ../doc/book/app_server/index.rst:5
msgid "Application server"
msgstr ""

#: ../doc/book/app_server/index.rst:7
msgid "In this chapter, we introduce the basics of working with Tarantool as a Lua application server."
msgstr ""

#: ../doc/book/app_server/index.rst:10
#: ../doc/book/box/index.rst:10
#: ../doc/book/cartridge/index.rst:11
#: ../doc/book/getting_started/index.rst:10
msgid "This chapter contains the following sections:"
msgstr ""

#: ../doc/book/app_server/installing_module.rst:5
msgid "Installing a module"
msgstr ""

#: ../doc/book/app_server/installing_module.rst:7
msgid "Modules in Lua and C that come from Tarantool developers and community contributors are available in the following locations:"
msgstr ""

#: ../doc/book/app_server/installing_module.rst:10
msgid "Tarantool modules repository, and"
msgstr ""

#: ../doc/book/app_server/installing_module.rst:11
msgid "Tarantool deb/rpm repositories."
msgstr ""

#: ../doc/book/app_server/installing_module.rst:17
msgid "Installing a module from a repository"
msgstr ""

#: ../doc/book/app_server/installing_module.rst:19
msgid "See `README in tarantool/rocks repository <https://github.com/tarantool/rocks#managing-modules-with-tarantool-174>`_ for detailed instructions."
msgstr ""

#: ../doc/book/app_server/installing_module.rst:27
msgid "Installing a module from deb/rpm"
msgstr ""

#: ../doc/book/app_server/installing_module.rst:29
msgid "Follow these steps:"
msgstr ""

#: ../doc/book/app_server/installing_module.rst:31
msgid "Install Tarantool as recommended on the `download page <http://tarantool.org/download.html>`_."
msgstr ""

#: ../doc/book/app_server/installing_module.rst:34
msgid "Install the module you need. Look up the module's name on `Tarantool rocks page <http://tarantool.org/rocks.html>`_ and put the prefix \"tarantool-\" before the module name to avoid ambiguity:"
msgstr ""

#: ../doc/book/app_server/installing_module.rst:38
msgid "$ # for Ubuntu/Debian:\n"
"$ sudo apt-get install tarantool-<module-name>\n"
"\n"
"$ # for RHEL/CentOS/Amazon:\n"
"$ sudo yum install tarantool-<module-name>"
msgstr ""

#: ../doc/book/app_server/installing_module.rst:46
msgid "For example, to install the module `shard <http://github.com/tarantool/shard>`_ on Ubuntu, say:"
msgstr ""

#: ../doc/book/app_server/installing_module.rst:49
msgid "$ sudo apt-get install tarantool-shard"
msgstr ""

#: ../doc/book/app_server/installing_module.rst:53
msgid "Once these steps are complete, you can:"
msgstr ""

#: ../doc/book/app_server/installing_module.rst:55
msgid "load any module with"
msgstr ""

#: ../doc/book/app_server/installing_module.rst:57
msgid "tarantool> name = require('module-name')"
msgstr ""

#: ../doc/book/app_server/installing_module.rst:61
msgid "for example:"
msgstr ""

#: ../doc/book/app_server/installing_module.rst:63
msgid "tarantool> shard = require('shard')"
msgstr ""

#: ../doc/book/app_server/installing_module.rst:67
msgid "search locally for installed modules using ``package.path`` (Lua) or ``package.cpath`` (C):"
msgstr ""

#: ../doc/book/app_server/installing_module.rst:70
msgid "tarantool> package.path\n"
"---\n"
"- ./?.lua;./?/init.lua; /usr/local/share/tarantool/?.lua;/usr/local/share/\n"
"tarantool/?/init.lua;/usr/share/tarantool/?.lua;/usr/share/tarantool/?/ini\n"
"t.lua;/usr/local/share/lua/5.1/?.lua;/usr/local/share/lua/5.1/?/init.lua;/\n"
"usr/share/lua/5.1/?.lua;/usr/share/lua/5.1/?/init.lua;\n"
"...\n"
"\n"
"tarantool> package.cpath\n"
"---\n"
"- ./?.so;/usr/local/lib/x86_64-linux-gnu/tarantool/?.so;/usr/lib/x86_64-li\n"
"nux-gnu/tarantool/?.so;/usr/local/lib/tarantool/?.so;/usr/local/lib/x86_64\n"
"-linux-gnu/lua/5.1/?.so;/usr/lib/x86_64-linux-gnu/lua/5.1/?.so;/usr/local/\n"
"lib/lua/5.1/?.so;\n"
"..."
msgstr ""

#: ../doc/book/app_server/installing_module.rst:90
msgid "Question-marks stand for the module name that was specified earlier when saying ``require('module-name')``."
msgstr ""

#: ../doc/book/app_server/launching_app.rst:5
msgid "Launching an application"
msgstr ""

#: ../doc/book/app_server/launching_app.rst:7
msgid "Using Tarantool as an application server, you can write your own applications. Tarantool’s native language for writing applications is `Lua <http://www.lua.org/about.html>`_, so a typical application would be a file that contains your Lua script. But you can also write applications in C or C++."
msgstr ""

#: ../doc/book/app_server/launching_app.rst:15
msgid "If you're new to Lua, we recommend going over the interactive Tarantool tutorial before proceeding with this chapter. To launch the tutorial, say ``tutorial()`` in Tarantool console:"
msgstr ""

#: ../doc/book/app_server/launching_app.rst:19
msgid "tarantool> tutorial()\n"
"---\n"
"- |\n"
" Tutorial -- Screen #1 -- Hello, Moon\n"
" ====================================\n"
"\n"
" Welcome to the Tarantool tutorial.\n"
" It will introduce you to Tarantool’s Lua application server\n"
" and database server, which is what’s running what you’re seeing.\n"
" This is INTERACTIVE -- you’re expected to enter requests\n"
" based on the suggestions or examples in the screen’s text.\n"
" <...>"
msgstr ""

#: ../doc/book/app_server/launching_app.rst:34
msgid "Let's create and launch our first Lua application for Tarantool. Here's a simplest Lua application, the good old \"Hello, world!\":"
msgstr ""

#: ../doc/book/app_server/launching_app.rst:37
msgid "#!/usr/bin/env tarantool\n"
"print('Hello, world!')"
msgstr ""

#: ../doc/book/app_server/launching_app.rst:42
msgid "We save it in a file. Let it be ``myapp.lua`` in the current directory."
msgstr ""

#: ../doc/book/app_server/launching_app.rst:44
msgid "Now let's discuss how we can launch our application with Tarantool."
msgstr ""

#: ../doc/book/app_server/launching_app.rst:50
msgid "Launching in Docker"
msgstr ""

#: ../doc/book/app_server/launching_app.rst:52
msgid "If we run Tarantool in a :ref:`Docker container <getting_started-using_docker>`, the following command will start Tarantool 1.9 without any application:"
msgstr ""

#: ../doc/book/app_server/launching_app.rst:55
msgid "$ # create a temporary container and run it in interactive mode\n"
"$ docker run --rm -t -i tarantool/tarantool:1"
msgstr ""

#: ../doc/book/app_server/launching_app.rst:60
msgid "To run Tarantool with our application, we can say:"
msgstr ""

#: ../doc/book/app_server/launching_app.rst:62
msgid "$ # create a temporary container and\n"
"$ # launch Tarantool with our application\n"
"$ docker run --rm -t -i \\\n"
"             -v `pwd`/myapp.lua:/opt/tarantool/myapp.lua \\\n"
"             -v /data/dir/on/host:/var/lib/tarantool \\\n"
"             tarantool/tarantool:1 tarantool /opt/tarantool/myapp.lua"
msgstr ""

#: ../doc/book/app_server/launching_app.rst:71
msgid "Here two resources on the host get mounted in the container:"
msgstr ""

#: ../doc/book/app_server/launching_app.rst:73
msgid "our application file (myapp.lua) and"
msgstr ""

#: ../doc/book/app_server/launching_app.rst:74
msgid "Tarantool data directory (``/data/dir/on/host``)."
msgstr ""

#: ../doc/book/app_server/launching_app.rst:76
msgid "By convention, the directory for Tarantool application code inside a container is ``/opt/tarantool``, and the directory for data is ``/var/lib/tarantool``."
msgstr ""

#: ../doc/book/app_server/launching_app.rst:83
msgid "Launching a binary program"
msgstr ""

#: ../doc/book/app_server/launching_app.rst:85
msgid "If we run Tarantool from a :ref:`binary package <getting_started-using_binary>` or from a :ref:`source build <building_from_source>`, we can launch our application:"
msgstr ""

#: ../doc/book/app_server/launching_app.rst:89
msgid "in the script mode,"
msgstr ""

#: ../doc/book/app_server/launching_app.rst:90
msgid "as a server application, or"
msgstr ""

#: ../doc/book/app_server/launching_app.rst:91
msgid "as a daemon service."
msgstr ""

#: ../doc/book/app_server/launching_app.rst:93
msgid "The simplest way is to pass the filename to Tarantool at start:"
msgstr ""

#: ../doc/book/app_server/launching_app.rst:95
#: ../doc/book/app_server/launching_app.rst:186
msgid "$ tarantool myapp.lua\n"
"Hello, world!\n"
"$"
msgstr ""

#: ../doc/book/app_server/launching_app.rst:101
msgid "Tarantool starts, executes our script in the **script mode** and exits."
msgstr ""

#: ../doc/book/app_server/launching_app.rst:103
msgid "Now let’s turn this script into a **server application**. We use :ref:`box.cfg <box_introspection-box_cfg>` from Tarantool’s built-in Lua module to:"
msgstr ""

#: ../doc/book/app_server/launching_app.rst:107
msgid "launch the database (a database has a persistent on-disk state, which needs to be restored after we start an application) and"
msgstr ""

#: ../doc/book/app_server/launching_app.rst:109
msgid "configure Tarantool as a server that accepts requests over a TCP port."
msgstr ""

#: ../doc/book/app_server/launching_app.rst:111
msgid "We also add some simple database logic, using :ref:`space.create() <box_schema-space_create>` and :ref:`create_index() <box_space-create_index>` to create a space with a primary index. We use the function :ref:`box.once() <box-once>` to make sure that our logic will be executed only once when the database is initialized for the first time, so we don't try to create an existing space or index on each invocation of the script:"
msgstr ""

#: ../doc/book/app_server/launching_app.rst:119
msgid "#!/usr/bin/env tarantool\n"
"-- Configure database\n"
"box.cfg {\n"
"   listen = 3301\n"
"}\n"
"box.once(\"bootstrap\", function()\n"
"   box.schema.space.create('tweedledum')\n"
"   box.space.tweedledum:create_index('primary',\n"
"       { type = 'TREE', parts = {1, 'unsigned'}})\n"
"end)"
msgstr ""

#: ../doc/book/app_server/launching_app.rst:132
msgid "Now we launch our application in the same manner as before:"
msgstr ""

#: ../doc/book/app_server/launching_app.rst:134
msgid "$ tarantool myapp.lua\n"
"Hello, world!\n"
"2017-08-11 16:07:14.250 [41436] main/101/myapp.lua C> version 2.1.0-429-g4e5231702\n"
"2017-08-11 16:07:14.250 [41436] main/101/myapp.lua C> log level 5\n"
"2017-08-11 16:07:14.251 [41436] main/101/myapp.lua I> mapping 1073741824 bytes for tuple arena...\n"
"2017-08-11 16:07:14.255 [41436] main/101/myapp.lua I> recovery start\n"
"2017-08-11 16:07:14.255 [41436] main/101/myapp.lua I> recovering from `./00000000000000000000.snap'\n"
"2017-08-11 16:07:14.271 [41436] main/101/myapp.lua I> recover from `./00000000000000000000.xlog'\n"
"2017-08-11 16:07:14.271 [41436] main/101/myapp.lua I> done `./00000000000000000000.xlog'\n"
"2017-08-11 16:07:14.272 [41436] main/102/hot_standby I> recover from `./00000000000000000000.xlog'\n"
"2017-08-11 16:07:14.274 [41436] iproto/102/iproto I> binary: started\n"
"2017-08-11 16:07:14.275 [41436] iproto/102/iproto I> binary: bound to [::]:3301\n"
"2017-08-11 16:07:14.275 [41436] main/101/myapp.lua I> done `./00000000000000000000.xlog'\n"
"2017-08-11 16:07:14.278 [41436] main/101/myapp.lua I> ready to accept requests"
msgstr ""

#: ../doc/book/app_server/launching_app.rst:151
msgid "This time, Tarantool executes our script and keeps working as a server, accepting TCP requests on port 3301. We can see Tarantool in the current session’s process list:"
msgstr ""

#: ../doc/book/app_server/launching_app.rst:155
msgid "$ ps | grep \"tarantool\"\n"
"  PID TTY           TIME CMD\n"
"41608 ttys001       0:00.47 tarantool myapp.lua <running>"
msgstr ""

#: ../doc/book/app_server/launching_app.rst:161
msgid "But the Tarantool instance will stop if we close the current terminal window. To detach Tarantool and our application from the terminal window, we can launch it in the **daemon mode**. To do so, we add some parameters to ``box.cfg{}``:"
msgstr ""

#: ../doc/book/app_server/launching_app.rst:165
msgid ":ref:`background <cfg_basic-background>` = ``true`` that actually tells Tarantool to work as a daemon service,"
msgstr ""

#: ../doc/book/app_server/launching_app.rst:167
msgid ":ref:`log <cfg_logging-log>` = ``'dir-name'`` that tells the Tarantool daemon where to store its log file (other log settings are available in Tarantool :ref:`log <log-module>` module), and"
msgstr ""

#: ../doc/book/app_server/launching_app.rst:170
msgid ":ref:`pid_file <cfg_basic-pid_file>` = ``'file-name'`` that tells the Tarantool daemon where to store its pid file."
msgstr ""

#: ../doc/book/app_server/launching_app.rst:173
#: ../doc/book/box/engines/vinyl.rst:548
#: ../doc/book/box/engines/vinyl.rst:548
#: ../doc/book/cartridge/cartridge_admin.rst:147
#: ../doc/book/cartridge/cartridge_dev.rst:341
#: ../doc/book/cartridge/cartridge_dev.rst:1227
msgid "For example:"
msgstr ""

#: ../doc/book/app_server/launching_app.rst:175
msgid "box.cfg {\n"
"   listen = 3301,\n"
"   background = true,\n"
"   log = '1.log',\n"
"   pid_file = '1.pid'\n"
"}"
msgstr ""

#: ../doc/book/app_server/launching_app.rst:184
msgid "We launch our application in the same manner as before:"
msgstr ""

#: ../doc/book/app_server/launching_app.rst:192
msgid "Tarantool executes our script, gets detached from the current shell session (you won't see it with ``ps | grep \"tarantool\"``) and continues working in the background as a daemon attached to the global session (with SID = 0):"
msgstr ""

#: ../doc/book/app_server/launching_app.rst:196
msgid "$ ps -ef | grep \"tarantool\"\n"
"  PID SID     TIME  CMD\n"
"42178   0  0:00.72 tarantool myapp.lua <running>"
msgstr ""

#: ../doc/book/app_server/launching_app.rst:202
msgid "Now that we have discussed how to create and launch a Lua application for Tarantool, let's dive deeper into programming practices."
msgstr ""

#: ../doc/book/app_server/reloading_module.rst:5
msgid "Reloading a module"
msgstr ""

#: ../doc/book/app_server/reloading_module.rst:7
msgid "You can reload any Tarantool application or module with zero downtime."
msgstr ""

#: ../doc/book/app_server/reloading_module.rst:13
msgid "Reloading a module in Lua"
msgstr ""

#: ../doc/book/app_server/reloading_module.rst:15
msgid "Here's an example that illustrates the most typical case -- \"update and reload\"."
msgstr ""

#: ../doc/book/app_server/reloading_module.rst:19
msgid "In this example, we use recommended :ref:`administration practices <admin>` based on :ref:`instance files <admin-instance_file>` and :ref:`tarantoolctl <tarantoolctl>` utility."
msgstr ""

#: ../doc/book/app_server/reloading_module.rst:23
msgid "Update the application file."
msgstr ""

#: ../doc/book/app_server/reloading_module.rst:25
msgid "For example, a module in ``/usr/share/tarantool/app.lua``:"
msgstr ""

#: ../doc/book/app_server/reloading_module.rst:27
msgid "local function start()\n"
"  -- initial version\n"
"  box.once(\"myapp:v1.0\", function()\n"
"    box.schema.space.create(\"somedata\")\n"
"    box.space.somedata:create_index(\"primary\")\n"
"    ...\n"
"  end)\n"
"\n"
"  -- migration code from 1.0 to 1.1\n"
"  box.once(\"myapp:v1.1\", function()\n"
"    box.space.somedata.index.primary:alter(...)\n"
"    ...\n"
"  end)\n"
"\n"
"  -- migration code from 1.1 to 1.2\n"
"  box.once(\"myapp:v1.2\", function()\n"
"    box.space.somedata.index.primary:alter(...)\n"
"    box.space.somedata:insert(...)\n"
"    ...\n"
"  end)\n"
"end\n"
"\n"
"-- start some background fibers if you need\n"
"\n"
"local function stop()\n"
"  -- stop all background fibers and clean up resources\n"
"end\n"
"\n"
"local function api_for_call(xxx)\n"
"  -- do some business\n"
"end\n"
"\n"
"return {\n"
"  start = start,\n"
"  stop = stop,\n"
"  api_for_call = api_for_call\n"
"}"
msgstr ""

#: ../doc/book/app_server/reloading_module.rst:67
msgid "Update the :ref:`instance file <admin-instance_file>`."
msgstr ""

#: ../doc/book/app_server/reloading_module.rst:69
msgid "For example, ``/etc/tarantool/instances.enabled/my_app.lua``:"
msgstr ""

#: ../doc/book/app_server/reloading_module.rst:71
msgid "#!/usr/bin/env tarantool\n"
"--\n"
"-- hot code reload example\n"
"--\n"
"\n"
"box.cfg({listen = 3302})\n"
"\n"
"-- ATTENTION: unload it all properly!\n"
"local app = package.loaded['app']\n"
"if app ~= nil then\n"
"  -- stop the old application version\n"
"  app.stop()\n"
"  -- unload the application\n"
"  package.loaded['app'] = nil\n"
"  -- unload all dependencies\n"
"  package.loaded['somedep'] = nil\n"
"end\n"
"\n"
"-- load the application\n"
"log.info('require app')\n"
"app = require('app')\n"
"\n"
"-- start the application\n"
"app.start({some app options controlled by sysadmins})"
msgstr ""

#: ../doc/book/app_server/reloading_module.rst:98
msgid "The important thing here is to properly unload the application and its dependencies."
msgstr ""

#: ../doc/book/app_server/reloading_module.rst:101
msgid "Manually reload the application file."
msgstr ""

#: ../doc/book/app_server/reloading_module.rst:103
msgid "For example, using ``tarantoolctl``:"
msgstr ""

#: ../doc/book/app_server/reloading_module.rst:105
msgid "$ tarantoolctl eval my_app /etc/tarantool/instances.enabled/my_app.lua"
msgstr ""

#: ../doc/book/app_server/reloading_module.rst:113
msgid "Reloading a module in C"
msgstr ""

#: ../doc/book/app_server/reloading_module.rst:115
msgid "After you compiled a new version of a C module (``*.so`` shared library), call :ref:`box.schema.func.reload('module-name') <box_schema-func_reload>` from your Lua script to reload the module."
msgstr ""

#: ../doc/book/app_server/using_ide.rst:5
msgid "Developing with an IDE"
msgstr ""

#: ../doc/book/app_server/using_ide.rst:7
msgid "You can use IntelliJ IDEA as an IDE to develop and debug Lua applications for Tarantool."
msgstr ""

#: ../doc/book/app_server/using_ide.rst:10
msgid "Download and install the IDE from the `official web-site <https://www.jetbrains.com/idea/>`_."
msgstr ""

#: ../doc/book/app_server/using_ide.rst:13
msgid "JetBrains provides specialized editions for particular languages: IntelliJ IDEA (Java), PHPStorm (PHP), PyCharm (Python), RubyMine (Ruby), CLion (C/C++), WebStorm (Web) and others. So, download a version that suits your primary programming language."
msgstr ""

#: ../doc/book/app_server/using_ide.rst:18
msgid "Tarantool integration is supported for all editions."
msgstr ""

#: ../doc/book/app_server/using_ide.rst:20
msgid "Configure the IDE:"
msgstr ""

#: ../doc/book/app_server/using_ide.rst:22
msgid "Start IntelliJ IDEA."
msgstr ""

#: ../doc/book/app_server/using_ide.rst:23
msgid "Click ``Configure`` button and select ``Plugins``."
msgstr ""

#: ../doc/book/app_server/using_ide.rst:30
msgid "Click ``Browse repositories``."
msgstr ""

#: ../doc/book/app_server/using_ide.rst:37
msgid "Install ``EmmyLua`` plugin."
msgstr ""

#: ../doc/book/app_server/using_ide.rst:41
msgid "Please don’t be confused with ``Lua`` plugin, which is less powerful than ``EmmyLua``."
msgstr ""

#: ../doc/book/app_server/using_ide.rst:49
msgid "Restart IntelliJ IDEA."
msgstr ""

#: ../doc/book/app_server/using_ide.rst:50
msgid "Click ``Configure``, select ``Project Defaults`` and then ``Run Configurations``."
msgstr ""

#: ../doc/book/app_server/using_ide.rst:58
msgid "Find ``Lua Application`` in the sidebar at the left."
msgstr ""

#: ../doc/book/app_server/using_ide.rst:60
msgid "In ``Program``, type a path to an installed ``tarantool`` binary."
msgstr ""

#: ../doc/book/app_server/using_ide.rst:62
msgid "By default, this is ``tarantool`` or ``/usr/bin/tarantool`` on most platforms."
msgstr ""

#: ../doc/book/app_server/using_ide.rst:65
msgid "If you installed ``tarantool`` from sources to a custom directory, please specify the proper path here."
msgstr ""

#: ../doc/book/app_server/using_ide.rst:73
msgid "Now IntelliJ IDEA is ready to use with Tarantool."
msgstr ""

#: ../doc/book/app_server/using_ide.rst:75
msgid "Create a new Lua project."
msgstr ""

#: ../doc/book/app_server/using_ide.rst:82
msgid "Add a new Lua file, for example ``init.lua``."
msgstr ""

#: ../doc/book/app_server/using_ide.rst:89
msgid "Write your code, save the file."
msgstr ""

#: ../doc/book/app_server/using_ide.rst:91
msgid "To run you application, click ``Run -> Run`` in the main menu and select your source file in the list."
msgstr ""

#: ../doc/book/app_server/using_ide.rst:99
msgid "Or click ``Run -> Debug`` to start debugging."
msgstr ""

#: ../doc/book/app_server/using_ide.rst:103
msgid "To use Lua debugger, please upgrade Tarantool to version 1.7.5-29-gbb6170e4b or later."
msgstr ""

#: ../doc/book/box/atomic.rst:5
msgid "Transaction control"
msgstr ""

#: ../doc/book/box/atomic.rst:7
msgid "Transactions in Tarantool occur in **fibers** on a single **thread**. That is why Tarantool has a guarantee of execution atomicity. That requires emphasis."
msgstr ""

#: ../doc/book/box/atomic.rst:15
msgid "Threads, fibers and yields"
msgstr ""

#: ../doc/book/box/atomic.rst:17
msgid "How does Tarantool process a basic operation? As an example, let's take this query:"
msgstr ""

#: ../doc/book/box/atomic.rst:20
msgid "tarantool> box.space.tester:update({3}, {{'=', 2, 'size'}, {'=', 3, 0}})"
msgstr ""

#: ../doc/book/box/atomic.rst:24
msgid "This is equivalent to the following SQL statement for a table that stores primary keys in ``field[1]``:"
msgstr ""

#: ../doc/book/box/atomic.rst:27
msgid "UPDATE tester SET \"field[2]\" = 'size', \"field[3]\" = 0 WHERE \"field[1]\" = 3"
msgstr ""

#: ../doc/book/box/atomic.rst:31
msgid "This query will be processed with three operating system **threads**:"
msgstr ""

#: ../doc/book/box/atomic.rst:33
msgid "If we issue the query on a remote client, then the **network thread** on the server side receives the query, parses the statement and changes it to a server executable message which has already been checked, and which the server instance can understand without parsing everything again."
msgstr ""

#: ../doc/book/box/atomic.rst:38
msgid "The network thread ships this message to the instance's **transaction processor thread** using a lock-free message bus. Lua programs execute directly in the transaction processor thread, and do not require parsing and preparation."
msgstr ""

#: ../doc/book/box/atomic.rst:43
msgid "The instance's transaction processor thread uses the primary-key index on field[1] to find the location of the tuple. It determines that the tuple can be updated (not much can go wrong when you're merely changing an unindexed field value to something shorter)."
msgstr ""

#: ../doc/book/box/atomic.rst:48
msgid "The transaction processor thread sends a message to the :ref:`write-ahead logging (WAL) thread <internals-wal>` to commit the transaction. When done, the WAL thread replies with a COMMIT or ROLLBACK result, which is returned to the client."
msgstr ""

#: ../doc/book/box/atomic.rst:53
msgid "Notice that there is only one transaction processor thread in Tarantool. Some people are used to the idea that there can be multiple threads operating on the database, with (say) thread #1 reading row #x, while thread #2 writes row #y. With Tarantool, no such thing ever happens. Only the transaction processor thread can access the database, and there is only one transaction processor thread for each Tarantool instance."
msgstr ""

#: ../doc/book/box/atomic.rst:60
msgid "Like any other Tarantool thread, the transaction processor thread can handle many :ref:`fibers <fiber-fibers>`. A fiber is a set of computer instructions that may contain \"**yield**\" signals. The transaction processor thread will execute all computer instructions until a yield, then switch to execute the instructions of a different fiber. Thus (say) the thread reads row #x for the sake of fiber #1, then writes row #y for the sake of fiber #2."
msgstr ""

#: ../doc/book/box/atomic.rst:67
msgid "Yields must happen, otherwise the transaction processor thread would stick permanently on the same fiber. There are two types of yields:"
msgstr ""

#: ../doc/book/box/atomic.rst:70
msgid ":ref:`implicit yields <atomic-implicit-yields>`: every data-change operation or network-access causes an implicit yield, and every statement that goes through the Tarantool client causes an implicit yield."
msgstr ""

#: ../doc/book/box/atomic.rst:74
msgid "explicit yields: in a Lua function, you can (and should) add :ref:`\"yield\" <fiber-yield>` statements to prevent hogging. This is called **cooperative multitasking**."
msgstr ""

#: ../doc/book/box/atomic.rst:82
msgid "Cooperative multitasking"
msgstr ""

#: ../doc/book/box/atomic.rst:84
msgid "Cooperative multitasking means: unless a running fiber deliberately yields control, it is not preempted by some other fiber. But a running fiber will deliberately yield when it encounters a “yield point”: a transaction commit, an operating system call, or an explicit :ref:`\"yield\" <fiber-yield>` request. Any system call which can block will be performed asynchronously, and any running fiber which must wait for a system call will be preempted, so that another ready-to-run fiber takes its place and becomes the new running fiber."
msgstr ""

#: ../doc/book/box/atomic.rst:92
msgid "This model makes all programmatic locks unnecessary: cooperative multitasking ensures that there will be no concurrency around a resource, no race conditions, and no memory consistency issues."
msgstr ""

#: ../doc/book/box/atomic.rst:96
msgid "When requests are small, for example simple UPDATE or INSERT or DELETE or SELECT, fiber scheduling is fair: it takes only a little time to process the request, schedule a disk write, and yield to a fiber serving the next client."
msgstr ""

#: ../doc/book/box/atomic.rst:100
msgid "However, a function might perform complex computations or might be written in such a way that yields do not occur for a long time. This can lead to unfair scheduling, when a single client throttles the rest of the system, or to apparent stalls in request processing. Avoiding this situation is the responsibility of the function’s author."
msgstr ""

#: ../doc/book/box/atomic.rst:110
msgid "Transactions"
msgstr ""

#: ../doc/book/box/atomic.rst:112
msgid "In the absence of transactions, any function that contains yield points may see changes in the database state caused by fibers that preempt. Multi-statement transactions exist to provide **isolation**: each transaction sees a consistent database state and commits all its changes atomically. At :ref:`commit <box-commit>` time, a yield happens and all transaction changes are written to the :ref:`write ahead log <internals-wal>` in a single batch. Or, if needed, transaction changes can be rolled back -- :ref:`completely <box-rollback>` or to a specific :ref:`savepoint <box-rollback_to_savepoint>`."
msgstr ""

#: ../doc/book/box/atomic.rst:122
msgid "To implement isolation, Tarantool uses a simple optimistic scheduler: the first transaction to commit wins. If a concurrent active transaction has read a value modified by a committed transaction, it is aborted."
msgstr ""

#: ../doc/book/box/atomic.rst:126
msgid "The cooperative scheduler ensures that, in absence of yields, a multi-statement transaction is not preempted and hence is never aborted. Therefore, understanding yields is essential to writing abort-free code."
msgstr ""

#: ../doc/book/box/atomic.rst:132
msgid "You can’t mix storage engines in a transaction today."
msgstr ""

#: ../doc/book/box/atomic.rst:138
msgid "Implicit yields"
msgstr ""

#: ../doc/book/box/atomic.rst:140
msgid "The only explicit yield requests in Tarantool are :ref:`fiber.sleep() <fiber-sleep>` and :ref:`fiber.yield() <fiber-yield>`, but many other requests \"imply\" yields because Tarantool is designed to avoid blocking."
msgstr ""

#: ../doc/book/box/atomic.rst:144
msgid "Database requests imply yields if and only if there is disk I/O. For memtx, since all data is in memory, there is no disk I/O during the request. For vinyl, since some data may not be in memory, there may be disk I/O for a read (to fetch data from disk) or for a write (because a stall may occur while waiting for memory to be free). For both memtx and vinyl, since data-change requests must be recorded in the WAL, there is normally a commit. A commit happens automatically after every request in default \"autocommit\" mode, or a commit happens at the end of a transaction in \"transaction\" mode, when a user deliberately commits by calling :ref:`box.commit() <box-commit>`. Therefore for both memtx and vinyl, because there can be disk I/O, some database operations may imply yields."
msgstr ""

#: ../doc/book/box/atomic.rst:157
msgid "Many functions in modules :ref:`fio <fio-section>`, :ref:`net_box <net_box-module>`, :ref:`console <console-module>` and :ref:`socket <socket-module>` (the \"os\" and \"network\" requests) yield."
msgstr ""

#: ../doc/book/box/atomic.rst:161
#: ../doc/book/box/box_session.rst:352
msgid "**Example #1**"
msgstr ""

#: ../doc/book/box/atomic.rst:163
msgid "*Engine = memtx* |br| ``select() insert()`` has one yield, at the end of insertion, caused by implicit commit; ``select()`` has nothing to write to the WAL and so does not yield."
msgstr ""

#: ../doc/book/box/atomic.rst:168
msgid "*Engine = vinyl* |br| ``select() insert()`` has between one and three yields, since ``select()`` may yield if the data is not in cache, ``insert()`` may yield waiting for available memory, and there is an implicit yield at commit."
msgstr ""

#: ../doc/book/box/atomic.rst:173
msgid "The sequence ``begin() insert() insert() commit()`` yields only at commit if the engine is memtx, and can yield up to 3 times if the engine is vinyl."
msgstr ""

#: ../doc/book/box/atomic.rst:176
#: ../doc/book/box/box_session.rst:361
msgid "**Example #2**"
msgstr ""

#: ../doc/book/box/atomic.rst:178
msgid "Assume that in space ‘tester’ there are tuples in which the third field represents a positive dollar amount. Let's start a transaction, withdraw from tuple#1, deposit in tuple#2, and end the transaction, making its effects permanent."
msgstr ""

#: ../doc/book/box/atomic.rst:183
msgid "tarantool> function txn_example(from, to, amount_of_money)\n"
"         >   box.begin()\n"
"         >   box.space.tester:update(from, {{'-', 3, amount_of_money}})\n"
"         >   box.space.tester:update(to,   {{'+', 3, amount_of_money}})\n"
"         >   box.commit()\n"
"         >   return \"ok\"\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> txn_example({999}, {1000}, 1.00)\n"
"---\n"
"- \"ok\"\n"
"..."
msgstr ""

#: ../doc/book/box/atomic.rst:199
msgid "If :ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>` = ‘none’, then implicit yielding at commit time does not take place, because there are no writes to the WAL."
msgstr ""

#: ../doc/book/box/atomic.rst:203
msgid "If a task is interactive -- sending requests to the server and receiving responses -- then it involves network IO, and therefore there is an implicit yield, even if the request that is sent to the server is not itself an implicit yield request. Therefore, the sequence:"
msgstr ""

#: ../doc/book/box/atomic.rst:245
msgid "select\n"
"select\n"
"select"
msgstr ""

#: ../doc/book/box/atomic.rst:215
msgid "causes blocking (in memtx), if it is inside a function or Lua program being executed on the server instance, but causes yielding (in both memtx and vinyl) if it is done as a series of transmissions from a client, including a client which operates via telnet, via one of the connectors, or via the :ref:`MySQL and PostgreSQL rocks <dbms_modules>`, or via the interactive mode when :ref:`using Tarantool as a client <admin-using_tarantool_as_a_client>`."
msgstr ""

#: ../doc/book/box/atomic.rst:222
msgid "After a fiber has yielded and then has regained control, it immediately issues :ref:`testcancel <fiber-testcancel>`."
msgstr ""

#: ../doc/book/box/authentication.rst:5
msgid "Access control"
msgstr ""

#: ../doc/book/box/authentication.rst:7
msgid "Understanding security details is primarily an issue for administrators. However, ordinary users should at least skim this section to get an idea of how Tarantool makes it possible for administrators to prevent unauthorized access to the database and to certain functions."
msgstr ""

#: ../doc/book/box/authentication.rst:12
msgid "Briefly:"
msgstr ""

#: ../doc/book/box/authentication.rst:14
msgid "There is a method to guarantee with password checks that users really are who they say they are (“authentication”)."
msgstr ""

#: ../doc/book/box/authentication.rst:17
msgid "There is a :ref:`_user <box_space-user>` system space, where usernames and password-hashes are stored."
msgstr ""

#: ../doc/book/box/authentication.rst:20
msgid "There are functions for saying that certain users are allowed to do certain things (“privileges”)."
msgstr ""

#: ../doc/book/box/authentication.rst:23
msgid "There is a :ref:`_priv <box_space-priv>` system space, where privileges are stored. Whenever a user tries to do an operation, there is a check whether the user has the privilege to do the operation (“access control”)."
msgstr ""

#: ../doc/book/box/authentication.rst:27
msgid "Details follow."
msgstr ""

#: ../doc/book/box/authentication.rst:33
msgid "Users"
msgstr ""

#: ../doc/book/box/authentication.rst:35
msgid "There is a **current user** for any program working with Tarantool, local or remote. If a remote connection is using a :ref:`binary port <admin-security>`, the current user, by default, is '**guest**'. If the connection is using an :ref:`admin-console port <admin-security>`, the current user is '**admin**'. When executing a :ref:`Lua initialization script <index-init_label>`, the current user is also ‘**admin**’."
msgstr ""

#: ../doc/book/box/authentication.rst:44
msgid "The current user name can be found with :ref:`box.session.user() <box_session-user>`."
msgstr ""

#: ../doc/book/box/authentication.rst:46
msgid "The current user can be changed:"
msgstr ""

#: ../doc/book/box/authentication.rst:48
msgid "For a binary port connection -- with the :ref:`AUTH protocol command <box_protocol-iproto_protocol>`, supported by most clients;"
msgstr ""

#: ../doc/book/box/authentication.rst:52
msgid "For an admin-console connection and in a Lua initialization script -- with :ref:`box.session.su <box_session-su>`;"
msgstr ""

#: ../doc/book/box/authentication.rst:55
msgid "For a binary-port connection invoking a stored function with the CALL command -- if the :ref:`SETUID <box_schema-func_create>` property is enabled for the function, Tarantool temporarily replaces the current user with the function’s creator, with all the creator's privileges, during function execution."
msgstr ""

#: ../doc/book/box/authentication.rst:64
msgid "Passwords"
msgstr ""

#: ../doc/book/box/authentication.rst:66
msgid "Each user (except 'guest') may have a **password**. The password is any alphanumeric string."
msgstr ""

#: ../doc/book/box/authentication.rst:69
msgid "Tarantool passwords are stored in the :ref:`_user <box_space-user>` system space with a `cryptographic hash function <https://en.wikipedia.org/wiki/Cryptographic_hash_function>`_ so that, if the password is ‘x’, the stored hash-password is a long string like ‘lL3OvhkIPOKh+Vn9Avlkx69M/Ck=‘. When a client connects to a Tarantool instance, the instance sends a random `salt value <https://en.wikipedia.org/wiki/Salt_%28cryptography%29>`_ which the client must mix with the hashed-password before sending to the instance. Thus the original value ‘x’ is never stored anywhere except in the user’s head, and the hashed value is never passed down a network wire except when mixed with a random salt."
msgstr ""

#: ../doc/book/box/authentication.rst:83
msgid "For more details of the password hashing algorithm (e.g. for the purpose of writing a new client application), read the `scramble.h <https://github.com/tarantool/tarantool/blob/2.1/src/scramble.h>`_ header file."
msgstr ""

#: ../doc/book/box/authentication.rst:88
msgid "This system prevents malicious onlookers from finding passwords by snooping in the log files or snooping on the wire. It is the same system that `MySQL introduced several years ago <http://dev.mysql.com/doc/refman/5.7/en/password-hashing.html>`_, which has proved adequate for medium-security installations. Nevertheless, administrators should warn users that no system is foolproof against determined long-term attacks, so passwords should be guarded and changed occasionally. Administrators should also advise users to choose long unobvious passwords, but it is ultimately up to the users to choose or change their own passwords."
msgstr ""

#: ../doc/book/box/authentication.rst:98
msgid "There are two functions for managing passwords in Tarantool: :ref:`box.schema.user.passwd() <box_schema-user_passwd>` for changing a user's password and :ref:`box.schema.user.password() <box_schema-user_password>` for getting a hash of a user's password."
msgstr ""

#: ../doc/book/box/authentication.rst:107
msgid "Owners and privileges"
msgstr ""

#: ../doc/book/box/authentication.rst:109
msgid "Tarantool has one database. It may be called \"box.schema\" or \"universe\". The database contains database objects, including spaces, indexes, users, roles, sequences, and functions."
msgstr ""

#: ../doc/book/box/authentication.rst:113
msgid "The **owner** of a database object is the user who created it. The owner of the database itself, and the owner of objects that are created initially (the system spaces and the default users) is '**admin**'."
msgstr ""

#: ../doc/book/box/authentication.rst:118
msgid "Owners automatically have **privileges** for what they create. They can share these privileges with other users or with roles, using **box.schema.user.grant** requests. The following privileges can be granted:"
msgstr ""

#: ../doc/book/box/authentication.rst:123
msgid "'read', e.g. allow select from a space"
msgstr ""

#: ../doc/book/box/authentication.rst:124
msgid "'write', e.g. allow update on a space"
msgstr ""

#: ../doc/book/box/authentication.rst:125
msgid "'execute', e.g. allow call of a function, or (less commonly) allow use of a role"
msgstr ""

#: ../doc/book/box/authentication.rst:126
msgid "'create', e.g. allow :ref:`box.schema.space.create <box_schema-space_create>` (access to certain system spaces is also necessary)"
msgstr ""

#: ../doc/book/box/authentication.rst:129
msgid "'alter', e.g. allow :ref:`box.space.x.index.y:alter <box_index-alter>` (access to certain system spaces is also necessary)"
msgstr ""

#: ../doc/book/box/authentication.rst:132
msgid "'drop', e.g. allow :ref:`box.sequence.x:drop <box_schema-sequence_drop>` (currently this can be granted but has no effect)"
msgstr ""

#: ../doc/book/box/authentication.rst:135
msgid "'usage', e.g. whether any action is allowable regardless of other privileges (sometimes revoking 'usage' is a convenient way to block a user temporarily without dropping the user)"
msgstr ""

#: ../doc/book/box/authentication.rst:138
msgid "'session', e.g. whether the user can 'connect'."
msgstr ""

#: ../doc/book/box/authentication.rst:140
msgid "To **create** objects, users need the 'create' privilege and at least 'read' and 'write' privileges on the system space with a similar name (for example, on the :ref:`_space <box_space-space>` if the user needs to create spaces)."
msgstr ""

#: ../doc/book/box/authentication.rst:145
msgid "To **access** objects, users need an appropriate privilege on the object (for example, the 'execute' privilege on function F if the users need to execute function F). See below some :ref:`examples for granting specific privileges <authentication-owners_privileges-examples-specific>` that a grantor -- that is, 'admin' or the object creator -- can make."
msgstr ""

#: ../doc/book/box/authentication.rst:151
msgid "To **drop** an object, users must be the object's creator or be 'admin'. As the owner of the entire database, 'admin' can drop any object including other users."
msgstr ""

#: ../doc/book/box/authentication.rst:155
msgid "To grant privileges to a user, the object owner says :ref:`grant() <box_schema-user_grant>`. To revoke privileges from a user, the object owner says :ref:`revoke() <box_schema-user_revoke>`. In either case, there are up to five parameters:"
msgstr ""

#: ../doc/book/box/authentication.rst:159
msgid "(user-name, privilege, object-type [, object-name [, options]])"
msgstr ""

#: ../doc/book/box/authentication.rst:163
msgid "``user-name`` is the user (or role) that will receive or lose the privilege;"
msgstr ""

#: ../doc/book/box/authentication.rst:164
msgid "``privilege`` is any of 'read', 'write', 'execute', 'create', 'alter', 'drop', 'usage', or 'session' (or a comma-separated list);"
msgstr ""

#: ../doc/book/box/authentication.rst:166
msgid "``object-type`` is any of 'space', 'index', 'sequence', 'function', role-name, or 'universe';"
msgstr ""

#: ../doc/book/box/authentication.rst:168
msgid "``object-name`` is what the privilege is for (omitted if ``object-type`` is 'universe');"
msgstr ""

#: ../doc/book/box/authentication.rst:170
msgid "``options`` is a list inside braces for example ``{if_not_exists=true|false}`` (usually omitted because the default is acceptable)."
msgstr ""

#: ../doc/book/box/authentication.rst:173
msgid "**Example for granting many privileges at once**"
msgstr ""

#: ../doc/book/box/authentication.rst:175
msgid "In this example user 'admin' grants many privileges on many objects to user 'U', with a single request."
msgstr ""

#: ../doc/book/box/authentication.rst:178
msgid "box.schema.user.grant('U','read,write,execute,create,drop','universe')"
msgstr ""

#: ../doc/book/box/authentication.rst:184
msgid "**Examples for granting privileges for specific operations**"
msgstr ""

#: ../doc/book/box/authentication.rst:186
msgid "In these examples the object's creator grants precisely the minimal privileges necessary for particular operations, to user 'U'."
msgstr ""

#: ../doc/book/box/authentication.rst:190
msgid "-- So that 'U' can create spaces:\n"
"  box.schema.user.grant('U','create','universe')\n"
"  box.schema.user.grant('U','write', 'space', '_schema')\n"
"  box.schema.user.grant('U','write', 'space', '_space')\n"
"-- So that 'U' can  create indexes (assuming 'U' created the space)\n"
"  box.schema.user.grant('U','read', 'space', '_space')\n"
"  box.schema.user.grant('U','read,write', 'space', '_index')\n"
"-- So that 'U' can  create indexes on space T (assuming 'U' did not create space T)\n"
"  box.schema.user.grant('U','create','space','T')\n"
"  box.schema.user.grant('U','read', 'space', '_space')\n"
"  box.schema.user.grant('U','write', 'space', '_index')\n"
"-- So that 'U' can  alter indexes on space T (assuming 'U' did not create the index)\n"
"  box.schema.user.grant('U','alter','space','T')\n"
"  box.schema.user.grant('U','read','space','_space')\n"
"  box.schema.user.grant('U','read','space','_index')\n"
"  box.schema.user.grant('U','read','space','_space_sequence')\n"
"  box.schema.user.grant('U','write','space','_index')\n"
"-- So that 'U' can create users or roles:\n"
"  box.schema.user.grant('U','create','universe')\n"
"  box.schema.user.grant('U','read,write', 'space', '_user')\n"
"  box.schema.user.grant('U','write','space', '_priv')\n"
"-- So that 'U' can create sequences:\n"
"  box.schema.user.grant('U','create','universe')\n"
"  box.schema.user.grant('U','read,write','space','_sequence')\n"
"-- So that 'U' can create functions:\n"
"  box.schema.user.grant('U','create','universe')\n"
"  box.schema.user.grant('U','read,write','space','_func')\n"
"-- So that 'U' can grant access on objects that 'U' created\n"
"  box.schema.user.grant('U','read','space','_user')\n"
"-- So that 'U' can select or get from a space named 'T'\n"
"  box.schema.user.grant('U','read','space','T')\n"
"-- So that 'U' can update or insert or delete or truncate a space named 'T'\n"
"  box.schema.user.grant('U','write','space','T')\n"
"-- So that 'U' can execute a function named 'F'\n"
"  box.schema.user.grant('U','execute','function','F')\n"
"-- So that 'U' can use the \"S:next()\" function with a sequence named S\n"
"  box.schema.user.grant('U','read,write','sequence','S')\n"
"-- So that 'U' can use the \"S:set()\" or \"S:reset() function with a sequence named S\n"
"  box.schema.user.grant('U','write','sequence','S')"
msgstr ""

#: ../doc/book/box/authentication.rst:232
msgid "**Example for creating users and objects then granting privileges**"
msgstr ""

#: ../doc/book/box/authentication.rst:234
msgid "Here we create a Lua function that will be executed under the user id of its creator, even if called by another user."
msgstr ""

#: ../doc/book/box/authentication.rst:237
msgid "First, we create two spaces ('u' and 'i') and grant a no-password user ('internal') full access to them. Then we define a function ('read_and_modify') and the no-password user becomes this function's creator. Finally, we grant another user ('public_user') access to execute Lua functions created by the no-password user."
msgstr ""

#: ../doc/book/box/authentication.rst:242
msgid "box.schema.space.create('u')\n"
"box.schema.space.create('i')\n"
"box.space.u:create_index('pk')\n"
"box.space.i:create_index('pk')\n"
"\n"
"box.schema.user.create('internal')\n"
"\n"
"box.schema.user.grant('internal', 'read,write', 'space', 'u')\n"
"box.schema.user.grant('internal', 'read,write', 'space', 'i')\n"
"box.schema.user.grant('internal', 'create', 'universe')\n"
"box.schema.user.grant('internal', 'read,write', 'space', '_func')\n"
"\n"
"function read_and_modify(key)\n"
"  local u = box.space.u\n"
"  local i = box.space.i\n"
"  local fiber = require('fiber')\n"
"  local t = u:get{key}\n"
"  if t ~= nil then\n"
"    u:put{key, box.session.uid()}\n"
"    i:put{key, fiber.time()}\n"
"  end\n"
"end\n"
"\n"
"box.session.su('internal')\n"
"box.schema.func.create('read_and_modify', {setuid= true})\n"
"box.session.su('admin')\n"
"box.schema.user.create('public_user', {password = 'secret'})\n"
"box.schema.user.grant('public_user', 'execute', 'function', 'read_and_modify')"
msgstr ""

#: ../doc/book/box/authentication.rst:277
msgid "Roles"
msgstr ""

#: ../doc/book/box/authentication.rst:279
msgid "A **role** is a container for privileges which can be granted to regular users. Instead of granting or revoking individual privileges, you can put all the privileges in a role and then grant or revoke the role."
msgstr ""

#: ../doc/book/box/authentication.rst:283
msgid "Role information is stored in the :ref:`_user <box_space-user>` space, but the third field in the tuple -- the type field -- is ‘role’ rather than ‘user’."
msgstr ""

#: ../doc/book/box/authentication.rst:286
msgid "An important feature in role management is that roles can be **nested**. For example, role R1 can be granted a privilege \"role R2\", so users with the role R1 will subsequently get all privileges from both roles R1 and R2. In other words, a user gets all the privileges that are granted to a user’s roles, directly or indirectly."
msgstr ""

#: ../doc/book/box/authentication.rst:292
msgid "There are actually two ways to grant or revoke a role: :samp:`box.schema.user.grant-or-revoke({user-name-or-role-name},'execute', 'role',{role-name}...)` or :samp:`box.schema.user.grant-or-revoke({user-name-or-role-name},{role-name}...)`. The second way is preferable."
msgstr ""

#: ../doc/book/box/authentication.rst:298
msgid "The 'usage' and 'session' privileges cannot be granted to roles."
msgstr ""

#: ../doc/book/box/authentication.rst:302
msgid "-- This example will work for a user with many privileges, such as 'admin'\n"
"-- or a user with the pre-defined 'super' role\n"
"-- Create space T with a primary index\n"
"box.schema.space.create('T')\n"
"box.space.T:create_index('primary', {})\n"
"-- Create user U1 so that later we can change the current user to U1\n"
"box.schema.user.create('U1')\n"
"-- Create two roles, R1 and R2\n"
"box.schema.role.create('R1')\n"
"box.schema.role.create('R2')\n"
"-- Grant role R2 to role R1 and role R1 to user U1 (order doesn't matter)\n"
"-- There are two ways to grant a role; here we use the shorter way\n"
"box.schema.role.grant('R1', 'R2')\n"
"box.schema.user.grant('U1', 'R1')\n"
"-- Grant read/write privileges for space T to role R2\n"
"-- (but not to role R1 and not to user U1)\n"
"box.schema.role.grant('R2', 'read,write', 'space', 'T')\n"
"-- Change the current user to user U1\n"
"box.session.su('U1')\n"
"-- An insertion to space T will now succeed because, due to nested roles,\n"
"-- user U1 has write privilege on space T\n"
"box.space.T:insert{1}"
msgstr ""

#: ../doc/book/box/authentication.rst:327
msgid "For more detail see :ref:`box.schema.user.grant() <box_schema-user_grant>` and :ref:`box.schema.role.grant() <box_schema-role_grant>` in the built-in modules reference."
msgstr ""

#: ../doc/book/box/authentication.rst:336
msgid "Sessions and security"
msgstr ""

#: ../doc/book/box/authentication.rst:338
msgid "A **session** is the state of a connection to Tarantool. It contains:"
msgstr ""

#: ../doc/book/box/authentication.rst:340
msgid "an integer id identifying the connection,"
msgstr ""

#: ../doc/book/box/authentication.rst:341
msgid "the :ref:`current user <authentication-users>` associated with the connection,"
msgstr ""

#: ../doc/book/box/authentication.rst:342
msgid "text description of the connected peer, and"
msgstr ""

#: ../doc/book/box/authentication.rst:343
msgid "session local state, such as Lua variables and functions."
msgstr ""

#: ../doc/book/box/authentication.rst:345
msgid "In Tarantool, a single session can execute multiple concurrent transactions. Each transaction is identified by a unique integer id, which can be queried at start of the transaction using :ref:`box.session.sync() <box_session-sync>`."
msgstr ""

#: ../doc/book/box/authentication.rst:351
msgid "To track all connects and disconnects, you can use :ref:`connection and authentication triggers <triggers>`."
msgstr ""

#: ../doc/book/box/box_cfg.rst:5
#: ../doc/book/box/box_introspection.rst:5
msgid "Submodule `box.cfg`"
msgstr ""

#: ../doc/book/box/box_cfg.rst:9
msgid "The ``box.cfg`` submodule is for administrators to specify all the :ref:`server configuration parameters <box_cfg_params>`."
msgstr ""

#: ../doc/book/box/box_cfg.rst:12
msgid "Say ``box.cfg`` without braces to view the current configuration, for example:"
msgstr ""

#: ../doc/book/box/box_cfg.rst:14
#: ../doc/book/box/box_introspection.rst:16
msgid "tarantool> box.cfg\n"
"---\n"
"- checkpoint_count: 2\n"
"  too_long_threshold: 0.5\n"
"  slab_alloc_factor: 1.1\n"
"  memtx_max_tuple_size: 1048576\n"
"  background: false\n"
"  <...>\n"
"..."
msgstr ""

#: ../doc/book/box/box_cfg.rst:26
msgid "To set the parameters, say ``box.cfg{...}``, for example:"
msgstr ""

#: ../doc/book/box/box_cfg.rst:28
#: ../doc/book/getting_started/using_binary.rst:91
msgid "tarantool> box.cfg{listen = 3301}"
msgstr ""

#: ../doc/book/box/box_cfg.rst:32
msgid "If you say ``box.cfg{}`` with no parameters, Tarantool applies default settings:"
msgstr ""

#: ../doc/book/box/box_cfg.rst:34
msgid "tarantool> box.cfg{}\n"
"tarantool> box.cfg -- sorted in the alphabetic order\n"
"---\n"
"- background                   = false\n"
"  checkpoint_count             = 2\n"
"  checkpoint_interval          = 3600\n"
"  checkpoint_wal_threshold     = 1000000000000000000\n"
"  coredump                     = false\n"
"  custom_proc_title            = nil\n"
"  feedback_enabled             = true\n"
"  feedback_host                = 'https://feedback.tarantool.io'\n"
"  feedback_interval            = 3600\n"
"  force_recovery               = false\n"
"  hot_standby                  = false\n"
"  io_collect_interval          = nil\n"
"  listen                       = nil\n"
"  log                          = nil\n"
"  log_format                   = plain\n"
"  log_level                    = 5\n"
"  log_nonblock                 = true\n"
"  memtx_dir                    = '.'\n"
"  memtx_max_tuple_size         = 1024 * 1024\n"
"  memtx_memory                 = 256 * 1024 *1024\n"
"  memtx_min_tuple_size         = 16\n"
"  net_msg_max                  = 768\n"
"  pid_file                     = nil\n"
"  readahead                    = 16320\n"
"  read_only                    = false\n"
"  replication                  = nil\n"
"  replication_connect_timeout  = 4\n"
"  replication_skip_conflict    = false\n"
"  replication_sync_lag         = 10\n"
"  replication_sync_timeout     = 300\n"
"  replication_timeout          = 1\n"
"  rows_per_wal                 = 500000\n"
"  slab_alloc_factor            = 1.05\n"
"  snap_io_rate_limit           = nil\n"
"  strip_core                   = true\n"
"  too_long_threshold           = 0.5\n"
"  username                     = nil\n"
"  vinyl_bloom_fpr              = 0.05\n"
"  vinyl_cache                  = 128\n"
"  vinyl_dir                    = '.'\n"
"  vinyl_max_tuple_size         = 1024 * 1024* 1024 * 1024\n"
"  vinyl_memory                 = 128 * 1024 * 1024\n"
"  vinyl_page_size              = 8 * 1024\n"
"  vinyl_range_size             = nil\n"
"  vinyl_read_threads           = 1\n"
"  vinyl_run_count_per_level    = 2\n"
"  vinyl_run_size_ratio         = 3.5\n"
"  vinyl_timeout                = 60\n"
"  vinyl_write_threads          = 2\n"
"  wal_dir                      = '.'\n"
"  wal_dir_rescan_delay         = 2\n"
"  wal_max_size                 = 256 * 1024 * 1024\n"
"  wal_mode                     = 'write'\n"
"  worker_pool_threads          = 4\n"
"  work_dir                     = nil"
msgstr ""

#: ../doc/book/box/box_cfg.rst:95
msgid "The first call to ``box.cfg{...}`` (with or without parameters) initiates Tarantool's database module :ref:`box <box-module>`. Before Tarantool 2.0, you needed to call ``box.cfg{...}`` prior to performing any database operations. Now you can start working with the database outright, without calling ``box.cfg{...}``. In this case, Tarantool initiates the database module and applies default settings, as if you said ``box.cfg{}`` (without parameters)."
msgstr ""

#: ../doc/book/box/box_cfg.rst:103
msgid "``box.cfg{...}`` is also the command that reloads :ref:`persistent data files <index-box_persistence>` into RAM upon restart once we have data."
msgstr ""

#: ../doc/book/box/box_ctl.rst:5
msgid "Submodule `box.ctl`"
msgstr ""

#: ../doc/book/box/box_ctl.rst:9
msgid "The ``box.ctl`` submodule contains two wait functions and two functions related to triggers."
msgstr ""

#: ../doc/book/box/box_ctl.rst:12
msgid "The wait functions ``wait_ro`` (wait until read-only) and ``wait_rw`` (wait until read-write) are useful during initialization of a server."
msgstr ""

#: ../doc/book/box/box_ctl.rst:15
msgid "A particular use is for :ref:`box_once() <box-once>`. For example, when a replica is initializing, it may call a ``box.once()`` function while the server is still in read-only mode, and fail to make changes that are necessary only once before the replica is fully initialized. This could cause conflicts between a master and a replica if the master is in read-write mode and the replica is in read-only mode. Waiting until \"read only mode = false\" solves this problem."
msgstr ""

#: ../doc/book/box/box_ctl.rst:25
msgid "To see whether a function is already in read-only or read-write mode, check :ref:`box.info.ro <box_introspection-box_info>`."
msgstr ""

#: ../doc/book/box/box_ctl.rst:32
msgid "Wait until ``box.info.ro`` is true."
msgstr ""

#: ../doc/book/box/box_ctl.rst:0
#: ../doc/book/box/box_ctl.rst:0
#: ../doc/book/box/box_ctl.rst:0
#: ../doc/book/box/box_index.rst:0
#: ../doc/book/box/box_index.rst:0
#: ../doc/book/box/box_index.rst:0
#: ../doc/book/box/box_index.rst:0
#: ../doc/book/box/box_index.rst:0
#: ../doc/book/box/box_index.rst:0
#: ../doc/book/box/box_index.rst:0
#: ../doc/book/box/box_index.rst:0
#: ../doc/book/box/box_index.rst:0
#: ../doc/book/box/box_index.rst:0
#: ../doc/book/box/box_index.rst:0
#: ../doc/book/box/box_index.rst:0
#: ../doc/book/box/box_index.rst:0
#: ../doc/book/box/box_index.rst:0
#: ../doc/book/box/box_index.rst:0
#: ../doc/book/box/box_schema.rst:0
#: ../doc/book/box/box_schema.rst:0
#: ../doc/book/box/box_schema.rst:0
#: ../doc/book/box/box_schema.rst:0
#: ../doc/book/box/box_schema.rst:0
#: ../doc/book/box/box_schema.rst:0
#: ../doc/book/box/box_schema.rst:0
#: ../doc/book/box/box_schema.rst:0
#: ../doc/book/box/box_schema.rst:0
#: ../doc/book/box/box_schema.rst:0
#: ../doc/book/box/box_schema.rst:0
#: ../doc/book/box/box_schema.rst:0
#: ../doc/book/box/box_schema.rst:0
#: ../doc/book/box/box_schema.rst:0
#: ../doc/book/box/box_schema.rst:0
#: ../doc/book/box/box_schema.rst:0
#: ../doc/book/box/box_schema.rst:0
#: ../doc/book/box/box_schema.rst:0
#: ../doc/book/box/box_schema.rst:0
#: ../doc/book/box/box_schema.rst:0
#: ../doc/book/box/box_session.rst:0
#: ../doc/book/box/box_session.rst:0
#: ../doc/book/box/box_session.rst:0
#: ../doc/book/box/box_session.rst:0
#: ../doc/book/box/box_session.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_sql.rst:0
#: ../doc/book/box/box_tuple.rst:0
#: ../doc/book/box/box_tuple.rst:0
#: ../doc/book/box/box_tuple.rst:0
#: ../doc/book/box/box_tuple.rst:0
#: ../doc/book/box/box_txn_management.rst:0
msgid "Parameters"
msgstr ""

#: ../doc/book/box/box_ctl.rst:34
#: ../doc/book/box/box_ctl.rst:57
msgid "maximum number of seconds to wait"
msgstr ""

#: ../doc/book/box/box_ctl.rst:0
#: ../doc/book/box/box_ctl.rst:0
#: ../doc/book/box/box_ctl.rst:0
#: ../doc/book/box/box_index.rst:0
#: ../doc/book/box/box_index.rst:0
#: ../doc/book/box/box_index.rst:0
#: ../doc/book/box/box_index.rst:0
#: ../doc/book/box/box_index.rst:0
#: ../doc/book/box/box_index.rst:0
#: ../doc/book/box/box_index.rst:0
#: ../doc/book/box/box_index.rst:0
#: ../doc/book/box/box_index.rst:0
#: ../doc/book/box/box_index.rst:0
#: ../doc/book/box/box_index.rst:0
#: ../doc/book/box/box_index.rst:0
#: ../doc/book/box/box_index.rst:0
#: ../doc/book/box/box_index.rst:0
#: ../doc/book/box/box_index.rst:0
#: ../doc/book/box/box_info.rst:0
#: ../doc/book/box/box_introspection.rst:0
#: ../doc/book/box/box_schema.rst:0
#: ../doc/book/box/box_schema.rst:0
#: ../doc/book/box/box_schema.rst:0
#: ../doc/book/box/box_schema.rst:0
#: ../doc/book/box/box_schema.rst:0
#: ../doc/book/box/box_schema.rst:0
#: ../doc/book/box/box_session.rst:0
#: ../doc/book/box/box_session.rst:0
#: ../doc/book/box/box_session.rst:0
#: ../doc/book/box/box_session.rst:0
#: ../doc/book/box/box_session.rst:0
#: ../doc/book/box/box_session.rst:0
#: ../doc/book/box/box_session.rst:0
#: ../doc/book/box/box_session.rst:0
#: ../doc/book/box/box_session.rst:0
#: ../doc/book/box/box_session.rst:0
#: ../doc/book/box/box_session.rst:0
#: ../doc/book/box/box_slab.rst:0
#: ../doc/book/box/box_slab.rst:0
#: ../doc/book/box/box_slab.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_sql.rst:0
#: ../doc/book/box/box_tuple.rst:0
#: ../doc/book/box/box_tuple.rst:0
#: ../doc/book/box/box_tuple.rst:0
#: ../doc/book/box/box_tuple.rst:0
#: ../doc/book/box/box_tuple.rst:0
#: ../doc/book/box/box_tuple.rst:0
#: ../doc/book/box/box_tuple.rst:0
#: ../doc/book/box/box_tuple.rst:0
#: ../doc/book/box/box_tuple.rst:0
#: ../doc/book/box/box_tuple.rst:0
#: ../doc/book/box/box_tuple.rst:0
#: ../doc/book/box/box_txn_management.rst:0
#: ../doc/book/box/box_txn_management.rst:0
#: ../doc/book/box/box_txn_management.rst:0
#: ../doc/book/box/box_txn_management.rst:0
#: ../doc/book/box/box_txn_management.rst:0
msgid "return"
msgstr ""

#: ../doc/book/box/box_ctl.rst:35
#: ../doc/book/box/box_ctl.rst:58
msgid "nil, or error (errors may be due to timeout or fiber cancellation)"
msgstr ""

#: ../doc/book/box/box_ctl.rst:37
#: ../doc/book/box/box_ctl.rst:61
#: ../doc/book/box/box_ctl.rst:104
#: ../doc/book/box/box_index.rst:117
#: ../doc/book/box/box_index.rst:503
#: ../doc/book/box/box_index.rst:643
#: ../doc/book/box/box_index.rst:674
#: ../doc/book/box/box_index.rst:705
#: ../doc/book/box/box_index.rst:734
#: ../doc/book/box/box_index.rst:758
#: ../doc/book/box/box_index.rst:838
#: ../doc/book/box/box_index.rst:868
#: ../doc/book/box/box_index.rst:890
#: ../doc/book/box/box_index.rst:988
#: ../doc/book/box/box_index.rst:1001
#: ../doc/book/box/box_info.rst:199
#: ../doc/book/box/box_introspection.rst:14
#: ../doc/book/box/box_introspection.rst:79
#: ../doc/book/box/box_introspection.rst:141
#: ../doc/book/box/box_schema.rst:280
#: ../doc/book/box/box_schema.rst:318
#: ../doc/book/box/box_schema.rst:352
#: ../doc/book/box/box_schema.rst:391
#: ../doc/book/box/box_schema.rst:413
#: ../doc/book/box/box_schema.rst:458
#: ../doc/book/box/box_schema.rst:477
#: ../doc/book/box/box_schema.rst:492
#: ../doc/book/box/box_schema.rst:523
#: ../doc/book/box/box_schema.rst:554
#: ../doc/book/box/box_schema.rst:571
#: ../doc/book/box/box_schema.rst:617
#: ../doc/book/box/box_schema.rst:721
#: ../doc/book/box/box_schema.rst:756
#: ../doc/book/box/box_schema.rst:772
#: ../doc/book/box/box_schema.rst:797
#: ../doc/book/box/box_schema.rst:945
#: ../doc/book/box/box_slab.rst:55
#: ../doc/book/box/box_slab.rst:114
#: ../doc/book/box/box_slab.rst:156
#: ../doc/book/box/box_space.rst:189
#: ../doc/book/box/box_space.rst:215
#: ../doc/book/box/box_space.rst:241
#: ../doc/book/box/box_space.rst:613
#: ../doc/book/box/box_space.rst:670
#: ../doc/book/box/box_space.rst:719
#: ../doc/book/box/box_space.rst:756
#: ../doc/book/box/box_space.rst:831
#: ../doc/book/box/box_space.rst:962
#: ../doc/book/box/box_space.rst:1011
#: ../doc/book/box/box_space.rst:1055
#: ../doc/book/box/box_space.rst:1082
#: ../doc/book/box/box_space.rst:1258
#: ../doc/book/box/box_space.rst:1306
#: ../doc/book/box/box_space.rst:1349
#: ../doc/book/box/box_space.rst:1385
#: ../doc/book/box/box_space.rst:1406
#: ../doc/book/box/box_space.rst:1456
#: ../doc/book/box/box_space.rst:1544
#: ../doc/book/box/box_space.rst:1621
#: ../doc/book/box/box_space.rst:1730
#: ../doc/book/box/box_space.rst:1766
#: ../doc/book/box/box_space.rst:1818
#: ../doc/book/box/box_space.rst:1866
#: ../doc/book/box/box_space.rst:1884
#: ../doc/book/box/box_space.rst:1905
#: ../doc/book/box/box_space.rst:1975
#: ../doc/book/box/box_space.rst:2099
#: ../doc/book/box/box_space.rst:2360
#: ../doc/book/box/box_space.rst:2394
#: ../doc/book/box/box_tuple.rst:95
#: ../doc/book/box/box_txn_management.rst:155
msgid "**Example:**"
msgstr ""

#: ../doc/book/box/box_ctl.rst:39
msgid "tarantool> box.info().ro\n"
"---\n"
"- false\n"
"...\n"
"\n"
"tarantool> n = box.ctl.wait_ro(0.1)\n"
"---\n"
"- error: timed out\n"
"..."
msgstr ""

#: ../doc/book/box/box_ctl.rst:55
msgid "Wait until box.info.ro is false."
msgstr ""

#: ../doc/book/box/box_ctl.rst:63
msgid "tarantool> box.ctl.wait_rw(0.1)\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/box/box_ctl.rst:71
msgid "The ``box.ctl`` submodule also contains two functions for the two :ref:`server trigger <triggers>` definitions: ``on_schema_init`` and ``on_shutdown``."
msgstr ""

#: ../doc/book/box/box_ctl.rst:76
msgid "Create a \"schema_init :ref:`trigger <triggers>`\". The ``trigger-function`` will be executed when :ref:`box.cfg{} <index-book_cfg>` happens for the first time. That is, the ``schema_init`` trigger is called before the server's configuration and recovery begins, and therefore ``box.ctl.on_schema_init`` must be called before ``box.cfg`` is called."
msgstr ""

#: ../doc/book/box/box_ctl.rst:83
msgid "Parameter: trigger-function (function) – function which will become the trigger function"
msgstr ""

#: ../doc/book/box/box_ctl.rst:85
msgid "Parameter: old-trigger-function (function) – existing trigger function which will be replaced by trigger-function"
msgstr ""

#: ../doc/book/box/box_ctl.rst:87
msgid "Return:     nil or function pointer"
msgstr ""

#: ../doc/book/box/box_ctl.rst:89
#: ../doc/book/box/box_ctl.rst:152
#: ../doc/book/box/box_session.rst:310
#: ../doc/book/box/box_session.rst:346
#: ../doc/book/box/box_session.rst:421
#: ../doc/book/box/box_space.rst:1113
msgid "If the parameters are (nil, old-trigger-function), then the old trigger is deleted."
msgstr ""

#: ../doc/book/box/box_ctl.rst:92
msgid "A common use is: make a ``schema_init`` trigger function which creates a ``before_replace`` trigger function on a system space. Thus, since system spaces are created when the server starts, the ``before_replace`` triggers will be activated for each tuple in each system space. For example, such a trigger could change the storage engine of a given space, or make a given space replica-local while a replica is being bootstrapped. Making such a change after ``box.cfg`` is not reliable because other connections might use the database before the change can be made."
msgstr ""

#: ../doc/book/box/box_ctl.rst:102
#: ../doc/book/box/box_ctl.rst:155
#: ../doc/book/box/box_session.rst:314
#: ../doc/book/box/box_session.rst:350
#: ../doc/book/box/box_session.rst:425
#: ../doc/book/box/box_space.rst:1123
#: ../doc/book/box/box_space.rst:1208
#: ../doc/book/box/box_txn_management.rst:210
msgid "Details about trigger characteristics are in the :ref:`triggers <triggers-box_triggers>` section."
msgstr ""

#: ../doc/book/box/box_ctl.rst:106
msgid "Suppose that, before the server is fully up and ready for connections, you want to make sure that the engine of space ``space_name`` is vinyl. So you want to make a trigger that will be activated when a tuple is inserted in the ``_space`` system space. In this case you could end up with a master that has space-name with ``engine='memtx'`` and a replica that has space_name with ``engine='vinyl'``, with the same contents."
msgstr ""

#: ../doc/book/box/box_ctl.rst:115
msgid "function function_for_before_replace(old, new)\n"
"  if new[3] == 'space_name' and new[4] ~= 'vinyl' then\n"
"    return new:update{{'=', 4, 'vinyl'}}\n"
"  end\n"
"end\n"
"\n"
"box.ctl.on_schema_init(function()\n"
"  box.space._space:before_replace(function_for_before_replace)\n"
"end)\n"
"\n"
"box.cfg{replication='master_uri', ...}"
msgstr ""

#: ../doc/book/box/box_ctl.rst:133
msgid "Create a \"shutdown :ref:`trigger <triggers>`\". The ``trigger-function`` will be executed whenever   :ref:`os.exit() <os-exit>` happens, or when the server is shut down after receiving a SIGTERM or SIGINT or SIGHUP signal (but not after SIGSEGV or SIGABORT or any signal that causes immediate program termination). The trigger function is actually called just before shutdown, so the trigger function can still refer to any methods and members in other Tarantool modules."
msgstr ""

#: ../doc/book/box/box_ctl.rst:142
msgid "Like :ref:`box.ctl.on_schema_init() <box_ctl-on_schema_init>`, ``box.ctl.on_shutdown()`` may be done before ``box.cfg{}`` is invoked."
msgstr ""

#: ../doc/book/box/box_ctl.rst:145
#: ../doc/book/box/box_session.rst:306
#: ../doc/book/box/box_session.rst:342
#: ../doc/book/box/box_session.rst:417
#: ../doc/book/box/box_txn_management.rst:201
msgid "function which will become the trigger function"
msgstr ""

#: ../doc/book/box/box_ctl.rst:147
#: ../doc/book/box/box_session.rst:307
#: ../doc/book/box/box_session.rst:343
#: ../doc/book/box/box_session.rst:418
#: ../doc/book/box/box_txn_management.rst:203
msgid "existing trigger function which will be replaced by trigger-function"
msgstr ""

#: ../doc/book/box/box_ctl.rst:150
#: ../doc/book/box/box_session.rst:308
#: ../doc/book/box/box_session.rst:344
#: ../doc/book/box/box_session.rst:419
#: ../doc/book/box/box_space.rst:1111
#: ../doc/book/box/box_space.rst:1197
#: ../doc/book/box/box_txn_management.rst:205
msgid "nil or function pointer"
msgstr ""

#: ../doc/book/box/box_index.rst:5
msgid "Submodule `box.index`"
msgstr ""

#: ../doc/book/box/box_index.rst:9
#: ../doc/book/box/box_schema.rst:11
#: ../doc/book/box/box_session.rst:9
#: ../doc/book/box/box_slab.rst:11
#: ../doc/book/box/box_space.rst:9
#: ../doc/book/box/box_tuple.rst:11
#: ../doc/book/box/box_txn_management.rst:9
msgid "Overview"
msgstr ""

#: ../doc/book/box/box_index.rst:11
msgid "The ``box.index`` submodule provides read-only access for index definitions and index keys. Indexes are contained in :samp:`box.space.{space-name}.index` array within each space object. They provide an API for ordered iteration over tuples. This API is a direct binding to corresponding methods of index objects of type ``box.index`` in the storage engine."
msgstr ""

#: ../doc/book/box/box_index.rst:19
#: ../doc/book/box/box_schema.rst:18
#: ../doc/book/box/box_session.rst:19
#: ../doc/book/box/box_slab.rst:19
#: ../doc/book/box/box_space.rst:19
#: ../doc/book/box/box_tuple.rst:20
#: ../doc/book/box/box_txn_management.rst:48
#: ../doc/book/box/data_model.rst:66
msgid "Index"
msgstr ""

#: ../doc/book/box/box_index.rst:21
msgid "Below is a list of all ``box.index`` functions and members."
msgstr ""

#: ../doc/book/box/box_index.rst:29
#: ../doc/book/box/box_schema.rst:28
#: ../doc/book/box/box_schema.rst:131
#: ../doc/book/box/box_session.rst:29
#: ../doc/book/box/box_slab.rst:29
#: ../doc/book/box/box_space.rst:29
#: ../doc/book/box/box_space.rst:284
#: ../doc/book/box/box_space.rst:2266
#: ../doc/book/box/box_tuple.rst:30
#: ../doc/book/box/box_txn_management.rst:60
msgid "Name"
msgstr ""

#: ../doc/book/box/box_index.rst:29
#: ../doc/book/box/box_schema.rst:28
#: ../doc/book/box/box_session.rst:29
#: ../doc/book/box/box_slab.rst:29
#: ../doc/book/box/box_space.rst:29
#: ../doc/book/box/box_tuple.rst:30
#: ../doc/book/box/box_txn_management.rst:60
msgid "Use"
msgstr ""

#: ../doc/book/box/box_index.rst:31
msgid ":ref:`index_object.unique <box_index-unique>`"
msgstr ""

#: ../doc/book/box/box_index.rst:31
msgid "Flag, true if an index is unique"
msgstr ""

#: ../doc/book/box/box_index.rst:34
msgid ":ref:`index_object.type <box_index-type>`"
msgstr ""

#: ../doc/book/box/box_index.rst:34
#: ../doc/book/box/data_model.rst:285
#: ../doc/book/box/data_model.rst:935
msgid "Index type"
msgstr ""

#: ../doc/book/box/box_index.rst:37
msgid ":ref:`index_object.parts <box_index-parts>`"
msgstr ""

#: ../doc/book/box/box_index.rst:37
msgid "Array of index key fields"
msgstr ""

#: ../doc/book/box/box_index.rst:40
msgid ":ref:`index_object:pairs() <box_index-index_pairs>`"
msgstr ""

#: ../doc/book/box/box_index.rst:40
#: ../doc/book/box/box_space.rst:72
#: ../doc/book/box/box_tuple.rst:68
msgid "Prepare for iterating"
msgstr ""

#: ../doc/book/box/box_index.rst:43
msgid ":ref:`index_object:select() <box_index-select>`"
msgstr ""

#: ../doc/book/box/box_index.rst:43
msgid "Select one or more tuples via index"
msgstr ""

#: ../doc/book/box/box_index.rst:46
msgid ":ref:`index_object:get() <box_index-get>`"
msgstr ""

#: ../doc/book/box/box_index.rst:46
msgid "Select a tuple via index"
msgstr ""

#: ../doc/book/box/box_index.rst:49
msgid ":ref:`index_object:min() <box_index-min>`"
msgstr ""

#: ../doc/book/box/box_index.rst:49
msgid "Find the minimum value in index"
msgstr ""

#: ../doc/book/box/box_index.rst:52
msgid ":ref:`index_object:max() <box_index-max>`"
msgstr ""

#: ../doc/book/box/box_index.rst:52
msgid "Find the maximum value in index"
msgstr ""

#: ../doc/book/box/box_index.rst:55
msgid ":ref:`index_object:random() <box_index-random>`"
msgstr ""

#: ../doc/book/box/box_index.rst:55
msgid "Find a random value in index"
msgstr ""

#: ../doc/book/box/box_index.rst:58
msgid ":ref:`index_object:count() <box_index-count>`"
msgstr ""

#: ../doc/book/box/box_index.rst:58
msgid "Count tuples matching key value"
msgstr ""

#: ../doc/book/box/box_index.rst:61
msgid ":ref:`index_object:update() <box_index-update>`"
msgstr ""

#: ../doc/book/box/box_index.rst:61
#: ../doc/book/box/box_space.rst:93
#: ../doc/book/box/box_space.rst:96
#: ../doc/book/box/box_tuple.rst:71
msgid "Update a tuple"
msgstr ""

#: ../doc/book/box/box_index.rst:64
msgid ":ref:`index_object:delete() <box_index-delete>`"
msgstr ""

#: ../doc/book/box/box_index.rst:64
msgid "Delete a tuple by key"
msgstr ""

#: ../doc/book/box/box_index.rst:67
msgid ":ref:`index_object:alter() <box_index-alter>`"
msgstr ""

#: ../doc/book/box/box_index.rst:67
msgid "Alter an index"
msgstr ""

#: ../doc/book/box/box_index.rst:70
msgid ":ref:`index_object:drop() <box_index-drop>`"
msgstr ""

#: ../doc/book/box/box_index.rst:70
msgid "Drop an index"
msgstr ""

#: ../doc/book/box/box_index.rst:73
msgid ":ref:`index_object:rename() <box_index-rename>`"
msgstr ""

#: ../doc/book/box/box_index.rst:73
msgid "Rename an index"
msgstr ""

#: ../doc/book/box/box_index.rst:76
msgid ":ref:`index_object:bsize() <box_index-bsize>`"
msgstr ""

#: ../doc/book/box/box_index.rst:76
msgid "Get count of bytes for an index"
msgstr ""

#: ../doc/book/box/box_index.rst:79
msgid ":ref:`index_object:stat() <box_index-stat>`"
msgstr ""

#: ../doc/book/box/box_index.rst:79
msgid "Get statistics for an index"
msgstr ""

#: ../doc/book/box/box_index.rst:82
msgid ":ref:`index_object:compact() <box_index-compact>`"
msgstr ""

#: ../doc/book/box/box_index.rst:82
msgid "Remove unused index space"
msgstr ""

#: ../doc/book/box/box_index.rst:85
msgid ":ref:`index_object:user_defined() <box_index-user_defined>`"
msgstr ""

#: ../doc/book/box/box_index.rst:85
#: ../doc/book/box/box_space.rst:99
msgid "Any function / method that any user wants to add"
msgstr ""

#: ../doc/book/box/box_index.rst:98
msgid "True if the index is unique, false if the index is not unique."
msgstr ""

#: ../doc/book/box/box_index.rst:0
#: ../doc/book/box/box_index.rst:0
#: ../doc/book/box/box_index.rst:0
#: ../doc/book/box/box_index.rst:0
#: ../doc/book/box/box_index.rst:0
#: ../doc/book/box/box_index.rst:0
#: ../doc/book/box/box_index.rst:0
#: ../doc/book/box/box_index.rst:0
#: ../doc/book/box/box_index.rst:0
#: ../doc/book/box/box_index.rst:0
#: ../doc/book/box/box_index.rst:0
#: ../doc/book/box/box_index.rst:0
#: ../doc/book/box/box_info.rst:0
#: ../doc/book/box/box_introspection.rst:0
#: ../doc/book/box/box_schema.rst:0
#: ../doc/book/box/box_schema.rst:0
#: ../doc/book/box/box_schema.rst:0
#: ../doc/book/box/box_schema.rst:0
#: ../doc/book/box/box_schema.rst:0
#: ../doc/book/box/box_session.rst:0
#: ../doc/book/box/box_session.rst:0
#: ../doc/book/box/box_session.rst:0
#: ../doc/book/box/box_session.rst:0
#: ../doc/book/box/box_session.rst:0
#: ../doc/book/box/box_session.rst:0
#: ../doc/book/box/box_session.rst:0
#: ../doc/book/box/box_session.rst:0
#: ../doc/book/box/box_session.rst:0
#: ../doc/book/box/box_slab.rst:0
#: ../doc/book/box/box_slab.rst:0
#: ../doc/book/box/box_slab.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_space.rst:0
#: ../doc/book/box/box_tuple.rst:0
#: ../doc/book/box/box_tuple.rst:0
#: ../doc/book/box/box_tuple.rst:0
#: ../doc/book/box/box_tuple.rst:0
#: ../doc/book/box/box_tuple.rst:0
#: ../doc/book/box/box_tuple.rst:0
#: ../doc/book/box/box_tuple.rst:0
#: ../doc/book/box/box_tuple.rst:0
#: ../doc/book/box/box_tuple.rst:0
#: ../doc/book/box/box_tuple.rst:0
#: ../doc/book/box/box_tuple.rst:0
#: ../doc/book/box/box_tuple.rst:0
#: ../doc/book/box/box_txn_management.rst:0
msgid "rtype"
msgstr ""

#: ../doc/book/box/box_index.rst:100
#: ../doc/book/box/box_schema.rst:152
#: ../doc/book/box/box_schema.rst:158
#: ../doc/book/box/box_schema.rst:165
#: ../doc/book/box/box_space.rst:294
#: ../doc/book/box/box_space.rst:296
#: ../doc/book/box/data_model.rst:155
msgid "boolean"
msgstr ""

#: ../doc/book/box/box_index.rst:106
msgid "Index type, 'TREE' or 'HASH' or 'BITSET' or 'RTREE'."
msgstr ""

#: ../doc/book/box/box_index.rst:112
msgid "An array describing the index fields. To learn more about the index field types, refer to :ref:`this table <box_space-index_field_types>`."
msgstr ""

#: ../doc/book/box/box_index.rst:115
#: ../doc/book/box/box_index.rst:942
#: ../doc/book/box/box_info.rst:197
#: ../doc/book/box/box_introspection.rst:77
#: ../doc/book/box/box_schema.rst:141
#: ../doc/book/box/box_slab.rst:53
#: ../doc/book/box/box_slab.rst:112
#: ../doc/book/box/box_slab.rst:154
#: ../doc/book/box/box_space.rst:1903
msgid "table"
msgstr ""

#: ../doc/book/box/box_index.rst:119
msgid "tarantool> box.space.tester.index.primary\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: unsigned\n"
"    is_nullable: false\n"
"    fieldno: 1\n"
"  id: 0\n"
"  space_id: 513\n"
"  name: primary\n"
"  type: TREE\n"
"..."
msgstr ""

#: ../doc/book/box/box_index.rst:138
msgid "Search for a tuple or a set of tuples via the given index, and allow iterating over one tuple at a time."
msgstr ""

#: ../doc/book/box/box_index.rst:141
msgid "The :samp:`{key}` parameter specifies what must match within the index."
msgstr ""

#: ../doc/book/box/box_index.rst:145
msgid ":samp:`{key}` is only used to find the first match. Do not assume all matched tuples will contain the key."
msgstr ""

#: ../doc/book/box/box_index.rst:148
msgid "The :samp:`{iterator}` parameter specifies the rule for matching and ordering. Different index types support different iterators. For example, a TREE index maintains a strict order of keys and can return all tuples in ascending or descending order, starting from the specified key. Other index types, however, do not support ordering."
msgstr ""

#: ../doc/book/box/box_index.rst:154
msgid "To understand consistency of tuples returned by an iterator, it's essential to know the principles of the Tarantool transaction processing subsystem. An iterator in Tarantool does not own a consistent read view. Instead, each procedure is granted exclusive access to all tuples and spaces until there is a \"context switch\": which may happen due to :ref:`the implicit yield rules <atomic-implicit-yields>`, or by an explicit call to :ref:`fiber.yield <fiber-yield>`. When the execution flow returns to the yielded procedure, the data set could have changed significantly. Iteration, resumed after a yield point, does not preserve the read view, but continues with the new content of the database. The tutorial :ref:`Indexed pattern search <c_lua_tutorial-indexed_pattern_search>` shows one way that iterators and yields can be used together."
msgstr ""

#: ../doc/book/box/box_index.rst:168
#: ../doc/book/box/box_space.rst:1302
msgid "For information about iterators' internal structures see the `\"Lua Functional library\" <https://luafun.github.io/index.html>`_ documentation."
msgstr ""

#: ../doc/book/box/box_index.rst:172
#: ../doc/book/box/box_index.rst:492
#: ../doc/book/box/box_index.rst:627
#: ../doc/book/box/box_index.rst:658
#: ../doc/book/box/box_index.rst:689
#: ../doc/book/box/box_index.rst:723
#: ../doc/book/box/box_index.rst:750
#: ../doc/book/box/box_index.rst:781
#: ../doc/book/box/box_index.rst:801
#: ../doc/book/box/box_index.rst:822
#: ../doc/book/box/box_index.rst:857
#: ../doc/book/box/box_index.rst:882
#: ../doc/book/box/box_index.rst:906
#: ../doc/book/box/box_index.rst:938
#: ../doc/book/box/box_index.rst:984
#: ../doc/book/box/box_space.rst:1762
msgid "an :ref:`object reference <app_server-object_reference>`."
msgstr ""

#: ../doc/book/box/box_index.rst:174
#: ../doc/book/box/box_space.rst:1281
msgid "value to be matched against the index key, which may be multi-part"
msgstr ""

#: ../doc/book/box/box_index.rst:176
msgid "as defined in tables below. The default iterator type is 'EQ'"
msgstr ""

#: ../doc/book/box/box_index.rst:180
#: ../doc/book/box/box_space.rst:1286
msgid "`iterator <https://www.lua.org/pil/7.1.html>`_ which can be used in a for/end loop or with `totable() <https://rtsisyk.github.io/luafun/reducing.html#fun.totable>`_"
msgstr ""

#: ../doc/book/box/box_index.rst:184
#: ../doc/book/box/box_index.rst:634
#: ../doc/book/box/box_index.rst:830
#: ../doc/book/box/box_index.rst:862
#: ../doc/book/box/box_space.rst:184
#: ../doc/book/box/box_space.rst:349
#: ../doc/book/box/box_space.rst:774
#: ../doc/book/box/box_space.rst:1290
#: ../doc/book/box/box_space.rst:1449
#: ../doc/book/box/box_space.rst:1721
msgid "**Possible errors:**"
msgstr ""

#: ../doc/book/box/box_index.rst:186
msgid "no such space; wrong type;"
msgstr ""

#: ../doc/book/box/box_index.rst:187
msgid "selected iteration type is not supported for the index type;"
msgstr ""

#: ../doc/book/box/box_index.rst:188
msgid "key is not supported for the iteration type."
msgstr ""

#: ../doc/book/box/box_index.rst:190
msgid "**Complexity factors:** Index size, Index type; Number of tuples accessed."
msgstr ""

#: ../doc/book/box/box_index.rst:193
msgid "A search-key-value can be a number (for example ``1234``), a string (for example ``'abcd'``), or a table of numbers and strings (for example ``{1234, 'abcd'}``). Each part of a key will be compared to each part of an index key."
msgstr ""

#: ../doc/book/box/box_index.rst:198
msgid "The returned tuples will be in order by index key value, or by the hash of the index key value if index type = 'hash'. If the index is non-unique, then duplicates will be secondarily in order by primary key value. The order will be reversed if the iterator type is 'LT' or 'LE' or 'REQ'."
msgstr ""

#: ../doc/book/box/box_index.rst:205
msgid "**Iterator types for TREE indexes**"
msgstr ""

#: ../doc/book/box/box_index.rst:216
#: ../doc/book/box/box_index.rst:315
#: ../doc/book/box/box_index.rst:351
#: ../doc/book/box/box_index_rtree.csv:1
#: ../doc/book/box/box_schema.rst:131
#: ../doc/book/box/box_space.rst:284
#: ../doc/book/box/box_space.rst:2266
msgid "Type"
msgstr ""

#: ../doc/book/box/box_index.rst:216
#: ../doc/book/box/box_index.rst:315
#: ../doc/book/box/box_index.rst:351
#: ../doc/book/box/box_index_rtree.csv:1
msgid "Arguments"
msgstr ""

#: ../doc/book/box/box_index.rst:216
#: ../doc/book/box/box_index.rst:315
#: ../doc/book/box/box_index.rst:351
#: ../doc/book/box/box_index_rtree.csv:1
#: ../doc/book/box/box_space.rst:2266
msgid "Description"
msgstr ""

#: ../doc/book/box/box_index.rst:218
#: ../doc/book/box/box_index.rst:322
#: ../doc/book/box/box_index.rst:357
#: ../doc/book/box/box_index_rtree.csv:1
msgid "box.index.EQ or 'EQ'"
msgstr ""

#: ../doc/book/box/box_index.rst:218
#: ../doc/book/box/box_index.rst:224
#: ../doc/book/box/box_index.rst:229
#: ../doc/book/box/box_index.rst:236
#: ../doc/book/box/box_index.rst:243
#: ../doc/book/box/box_index.rst:247
#: ../doc/book/box/box_index.rst:253
#: ../doc/book/box/box_index.rst:322
#: ../doc/book/box/box_index.rst:328
#: ../doc/book/box/box_index_rtree.csv:1
#: ../doc/book/box/box_index_rtree.csv:1
#: ../doc/book/box/box_index_rtree.csv:1
#: ../doc/book/box/box_index_rtree.csv:1
#: ../doc/book/box/box_index_rtree.csv:1
#: ../doc/book/box/box_index_rtree.csv:1
#: ../doc/book/box/box_index_rtree.csv:1
msgid "search value"
msgstr ""

#: ../doc/book/box/box_index.rst:218
msgid "The comparison operator is '==' (equal to). If an index key is equal to a search value, it matches. Tuples are returned in ascending order by index key. This is the default."
msgstr ""

#: ../doc/book/box/box_index.rst:224
msgid "box.index.REQ or 'REQ'"
msgstr ""

#: ../doc/book/box/box_index.rst:224
msgid "Matching is the same as for ``box.index.EQ``. Tuples are returned in descending order by index key."
msgstr ""

#: ../doc/book/box/box_index.rst:229
#: ../doc/book/box/box_index.rst:328
#: ../doc/book/box/box_index_rtree.csv:1
msgid "box.index.GT or 'GT'"
msgstr ""

#: ../doc/book/box/box_index.rst:229
msgid "The comparison operator is '>' (greater than). If an index key is greater than a search value, it matches. Tuples are returned in ascending order by index key."
msgstr ""

#: ../doc/book/box/box_index.rst:236
#: ../doc/book/box/box_index_rtree.csv:1
msgid "box.index.GE or 'GE'"
msgstr ""

#: ../doc/book/box/box_index.rst:236
msgid "The comparison operator is '>=' (greater than or equal to). If an index key is greater than or equal to a search value, it matches. Tuples are returned in ascending order by index key."
msgstr ""

#: ../doc/book/box/box_index.rst:243
#: ../doc/book/box/box_index.rst:353
#: ../doc/book/box/box_index_rtree.csv:1
msgid "box.index.ALL or 'ALL'"
msgstr ""

#: ../doc/book/box/box_index.rst:243
msgid "Same as box.index.GE."
msgstr ""

#: ../doc/book/box/box_index.rst:247
#: ../doc/book/box/box_index_rtree.csv:1
msgid "box.index.LT or 'LT'"
msgstr ""

#: ../doc/book/box/box_index.rst:247
msgid "The comparison operator is '<' (less than). If an index key is less than a search value, it matches. Tuples are returned in descending order by index key."
msgstr ""

#: ../doc/book/box/box_index.rst:253
#: ../doc/book/box/box_index_rtree.csv:1
msgid "box.index.LE or 'LE'"
msgstr ""

#: ../doc/book/box/box_index.rst:253
msgid "The comparison operator is '<=' (less than or equal to). If an index key is less than or equal to a search value, it matches. Tuples are returned in descending order by index key."
msgstr ""

#: ../doc/book/box/box_index.rst:261
msgid "Informally, we can state that searches with TREE indexes are generally what users will find is intuitive, provided that there are no nils and no missing parts. Formally, the logic is as follows. A search key has zero or more parts, for example {}, {1,2,3},{1,nil,3}. An index key has one or more parts, for example {1}, {1,2,3},{1,2,3}. A search key may contain nil (but not msgpack.NULL, which is the wrong type). An index key may not contain nil or msgpack.NULL, although a later version of Tarantool will have different rules --  the behavior of searches with nil is subject to change. Possible iterators are LT, LE, EQ, REQ, GE, GT. A search key is said to \"match\" an index key if the following statements, which are pseudocode for the comparison operation, return TRUE."
msgstr ""

#: ../doc/book/box/box_index.rst:311
msgid "If (number-of-search-key-parts > number-of-index-key-parts) return ERROR\n"
"If (number-of-search-key-parts == 0) return TRUE\n"
"for (i = 1; ; ++i)\n"
"{\n"
"  if (i > number-of-search-key-parts) OR (search-key-part[i] is nil)\n"
"  {\n"
"    if (iterator is LT or GT) return FALSE\n"
"    return TRUE\n"
"  }\n"
"  if (type of search-key-part[i] is not compatible with type of index-key-part[i])\n"
"  {\n"
"    return ERROR\n"
"  }\n"
"  if (search-key-part[i] == index-key-part[i])\n"
"  {\n"
"    continue\n"
"  }\n"
"  if (search-key-part[i] > index-key-part[i])\n"
"  {\n"
"    if (iterator is EQ or REQ or LE or LT) return FALSE\n"
"    return TRUE\n"
"  }\n"
"  if (search-key-part[i] < index-key-part[i])\n"
"  {\n"
"    if (iterator is EQ or REQ or GE or GT) return FALSE\n"
"    return TRUE\n"
"  }\n"
"}"
msgstr ""

#: ../doc/book/box/box_index.rst:306
msgid "**Iterator types for HASH indexes**"
msgstr ""

#: ../doc/book/box/box_index.rst:317
msgid "box.index.ALL"
msgstr ""

#: ../doc/book/box/box_index.rst:317
#: ../doc/book/box/box_index.rst:353
#: ../doc/book/box/box_index_rtree.csv:1
msgid "none"
msgstr ""

#: ../doc/book/box/box_index.rst:317
msgid "All index keys match. Tuples are returned in ascending order by hash of index key, which will appear to be random."
msgstr ""

#: ../doc/book/box/box_index.rst:322
msgid "The comparison operator is '==' (equal to). If an index key is equal to a search value, it matches. The number of returned tuples will be 0 or 1. This is the default."
msgstr ""

#: ../doc/book/box/box_index.rst:328
msgid "The comparison operator is '>' (greater than). If a hash of an index key is greater than a hash of a search value, it matches. Tuples are returned in ascending order by hash of index key, which will appear to be random. Provided that the space is not being updated, one can retrieve all the tuples in a space, N tuples at a time, by using {iterator='GT', limit=N} in each search, and using the last returned value from the previous result as the start search value for the next search."
msgstr ""

#: ../doc/book/box/box_index.rst:342
msgid "**Iterator types for BITSET indexes**"
msgstr ""

#: ../doc/book/box/box_index.rst:353
msgid "All index keys match. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/book/box/box_index.rst:357
#: ../doc/book/box/box_index.rst:362
#: ../doc/book/box/box_index.rst:367
#: ../doc/book/box/box_index.rst:372
msgid "bitset value"
msgstr ""

#: ../doc/book/box/box_index.rst:357
msgid "If an index key is equal to a bitset value, it matches. Tuples are returned in their order within the space. This is the default."
msgstr ""

#: ../doc/book/box/box_index.rst:362
msgid "box.index.BITS_ALL_SET"
msgstr ""

#: ../doc/book/box/box_index.rst:362
msgid "If all of the bits which are 1 in the bitset value are 1 in the index key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/book/box/box_index.rst:367
msgid "box.index.BITS_ANY_SET"
msgstr ""

#: ../doc/book/box/box_index.rst:367
msgid "If any of the bits which are 1 in the bitset value are 1 in the index key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/book/box/box_index.rst:372
msgid "box.index.BITS_ALL_NOT_SET"
msgstr ""

#: ../doc/book/box/box_index.rst:372
msgid "If all of the bits which are 1 in the bitset value are 0 in the index key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/book/box/box_index.rst:380
msgid "**Iterator types for RTREE indexes**"
msgstr ""

#: ../doc/book/box/box_index_rtree.csv:1
msgid "All keys match. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/book/box/box_index_rtree.csv:1
msgid "If all points of the rectangle-or-box defined by the search value are the same as the rectangle-or-box defined by the index key, it matches. Tuples are returned in their order within the space. \"Rectangle-or-box\" means \"rectangle-or-box as explained in section about :ref:`RTREE <box_index-rtree>`\". This is the default."
msgstr ""

#: ../doc/book/box/box_index_rtree.csv:1
msgid "If all points of the rectangle-or-box defined by the search value are within the rectangle-or-box defined by the index key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/book/box/box_index_rtree.csv:1
msgid "If all points of the rectangle-or-box defined by the search value are within, or at the side of, the rectangle-or-box defined by the index key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/book/box/box_index_rtree.csv:1
msgid "If all points of the rectangle-or-box defined by the index key are within the rectangle-or-box defined by the search key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/book/box/box_index_rtree.csv:1
msgid "If all points of the rectangle-or-box defined by the index key are within, or at the side of, the rectangle-or-box defined by the search key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/book/box/box_index_rtree.csv:1
msgid "box.index.OVERLAPS or 'OVERLAPS'"
msgstr ""

#: ../doc/book/box/box_index_rtree.csv:1
msgid "If some points of the rectangle-or-box defined by the search value are within the rectangle-or-box defined by the index key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/book/box/box_index_rtree.csv:1
msgid "box.index.NEIGHBOR or 'NEIGHBOR'"
msgstr ""

#: ../doc/book/box/box_index_rtree.csv:1
msgid "If some points of the rectangle-or-box defined by the defined by the key are within, or at the side of, defined by the index key, it matches. Tuples are returned in order: nearest neighbor first."
msgstr ""

#: ../doc/book/box/box_index.rst:394
msgid "**First example of index pairs():**"
msgstr ""

#: ../doc/book/box/box_index.rst:396
msgid "Default 'TREE' Index and ``pairs()`` function:"
msgstr ""

#: ../doc/book/box/box_index.rst:398
msgid "tarantool> s = box.schema.space.create('space17')\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {\n"
"         >   parts = {1, 'string', 2, 'string'}\n"
"         > })\n"
"---\n"
"...\n"
"tarantool> s:insert{'C', 'C'}\n"
"---\n"
"- ['C', 'C']\n"
"...\n"
"tarantool> s:insert{'B', 'A'}\n"
"---\n"
"- ['B', 'A']\n"
"...\n"
"tarantool> s:insert{'C', '!'}\n"
"---\n"
"- ['C', '!']\n"
"...\n"
"tarantool> s:insert{'A', 'C'}\n"
"---\n"
"- ['A', 'C']\n"
"...\n"
"tarantool> function example()\n"
"         >   for _, tuple in\n"
"         >     s.index.primary:pairs(nil, {\n"
"         >         iterator = box.index.ALL}) do\n"
"         >       print(tuple)\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> example()\n"
"['A', 'C']\n"
"['B', 'A']\n"
"['C', '!']\n"
"['C', 'C']\n"
"---\n"
"...\n"
"tarantool> s:drop()\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/box/box_index.rst:444
msgid "**Second example of index pairs():**"
msgstr ""

#: ../doc/book/box/box_index.rst:446
msgid "This Lua code finds all the tuples whose primary key values begin with 'XY'. The assumptions include that there is a one-part primary-key TREE index on the first field, which must be a string. The iterator loop ensures that the search will return tuples where the first value is greater than or equal to 'XY'. The conditional statement within the loop ensures that the looping will stop when the first two letters are not 'XY'."
msgstr ""

#: ../doc/book/box/box_index.rst:454
msgid "for _, tuple in\n"
"box.space.t.index.primary:pairs(\"XY\",{iterator = \"GE\"}) do\n"
"  if (string.sub(tuple[1], 1, 2) ~= \"XY\") then break end\n"
"  print(tuple)\n"
"end"
msgstr ""

#: ../doc/book/box/box_index.rst:462
msgid "**Third example of index pairs():**"
msgstr ""

#: ../doc/book/box/box_index.rst:464
msgid "This Lua code finds all the tuples whose primary key values are greater than or equal to 1000, and less than or equal to 1999 (this type of request is sometimes called a \"range search\" or a \"between search\"). The assumptions include that there is a one-part primary-key TREE index on the first field, which must be a :ref:`number <index-box_number>`. The iterator loop ensures that the search will return tuples where the first value is greater than or equal to 1000. The conditional statement within the loop ensures that the looping will stop when the first value is greater than 1999."
msgstr ""

#: ../doc/book/box/box_index.rst:474
msgid "for _, tuple in\n"
"box.space.t2.index.primary:pairs(1000,{iterator = \"GE\"}) do\n"
"  if (tuple[1] > 1999) then break end\n"
"  print(tuple)\n"
"end"
msgstr ""

#: ../doc/book/box/box_index.rst:486
msgid "This is an alternative to :ref:`box.space...select() <box_space-select>` which goes via a particular index and can make use of additional parameters that specify the iterator type, and the limit (that is, the maximum number of tuples to return) and the offset (that is, which tuple to start with in the list)."
msgstr ""

#: ../doc/book/box/box_index.rst:494
#: ../doc/book/box/box_index.rst:629
#: ../doc/book/box/box_index.rst:660
#: ../doc/book/box/box_index.rst:691
#: ../doc/book/box/box_index.rst:752
#: ../doc/book/box/box_index.rst:783
#: ../doc/book/box/box_index.rst:803
msgid "values to be matched against the index key"
msgstr ""

#: ../doc/book/box/box_index.rst:495
msgid "none, any or all of next parameters"
msgstr ""

#: ../doc/book/box/box_index.rst:496
msgid "type of iterator"
msgstr ""

#: ../doc/book/box/box_index.rst:497
msgid "maximum number of tuples"
msgstr ""

#: ../doc/book/box/box_index.rst:498
msgid "start tuple number"
msgstr ""

#: ../doc/book/box/box_index.rst:500
msgid "the tuple or tuples that match the field values."
msgstr ""

#: ../doc/book/box/box_index.rst:501
#: ../doc/book/box/box_space.rst:1444
msgid "array of tuples"
msgstr ""

#: ../doc/book/box/box_index.rst:505
msgid "-- Create a space named tester.\n"
"tarantool> sp = box.schema.space.create('tester')\n"
"-- Create a unique index 'primary'\n"
"-- which won't be needed for this example.\n"
"tarantool> sp:create_index('primary', {parts = {1, 'unsigned' }})\n"
"-- Create a non-unique index 'secondary'\n"
"-- with an index on the second field.\n"
"tarantool> sp:create_index('secondary', {\n"
"         >   type = 'tree',\n"
"         >   unique = false,\n"
"         >   parts = {2, 'string'}\n"
"         > })\n"
"-- Insert three tuples, values in field[2]\n"
"-- equal to 'X', 'Y', and 'Z'.\n"
"tarantool> sp:insert{1, 'X', 'Row with field[2]=X'}\n"
"tarantool> sp:insert{2, 'Y', 'Row with field[2]=Y'}\n"
"tarantool> sp:insert{3, 'Z', 'Row with field[2]=Z'}\n"
"-- Select all tuples where the secondary index\n"
"-- keys are greater than 'X'.`\n"
"tarantool> sp.index.secondary:select({'X'}, {\n"
"         >   iterator = 'GT',\n"
"         >   limit = 1000\n"
"         > })"
msgstr ""

#: ../doc/book/box/box_index.rst:531
msgid "The result will be a table of tuple and will look like this:"
msgstr ""

#: ../doc/book/box/box_index.rst:533
msgid "---\n"
"- - [2, 'Y', 'Row with field[2]=Y']\n"
"  - [3, 'Z', 'Row with field[2]=Z']\n"
"..."
msgstr ""

#: ../doc/book/box/box_index.rst:542
msgid ":samp:`index.{index-name}` is optional. If it is omitted, then the assumed index is the first (primary-key) index. Therefore, for the example above, ``box.space.tester:select({1}, {iterator = 'GT'})`` would have returned the same two rows, via the 'primary' index."
msgstr ""

#: ../doc/book/box/box_index.rst:549
msgid ":samp:`iterator = {iterator-type}` is optional. If it is omitted, then ``iterator = 'EQ'`` is assumed."
msgstr ""

#: ../doc/book/box/box_index.rst:554
msgid ":samp:`{field-value} [, {field-value ...}]` is optional. If it is omitted, then every key in the index is considered to be a match, regardless of iterator type. Therefore, for the example above, ``box.space.tester:select{}`` will select every tuple in the tester space via the first (primary-key) index."
msgstr ""

#: ../doc/book/box/box_index.rst:564
msgid ":samp:`box.space.{space-name}.index.{index-name}:select(...)[1]``. can be replaced by :samp:`box.space.{space-name}.index.{index-name}:get(...)`. That is, ``get`` can be used as a convenient shorthand to get the first tuple in the tuple set that would be returned by ``select``. However, if there is more than one tuple in the tuple set, then ``get`` throws an error."
msgstr ""

#: ../doc/book/box/box_index.rst:572
msgid "**Example with BITSET index:**"
msgstr ""

#: ../doc/book/box/box_index.rst:574
msgid "The following script shows creation and search with a BITSET index. Notice: BITSET cannot be unique, so first a primary-key index is created. Notice: bit values are entered as hexadecimal literals for easier reading."
msgstr ""

#: ../doc/book/box/box_index.rst:578
msgid "tarantool> s = box.schema.space.create('space_with_bitset')\n"
"tarantool> s:create_index('primary_index', {\n"
"         >   parts = {1, 'string'},\n"
"         >   unique = true,\n"
"         >   type = 'TREE'\n"
"         > })\n"
"tarantool> s:create_index('bitset_index', {\n"
"         >   parts = {2, 'unsigned'},\n"
"         >   unique = false,\n"
"         >   type = 'BITSET'\n"
"         > })\n"
"tarantool> s:insert{'Tuple with bit value = 01', 0x01}\n"
"tarantool> s:insert{'Tuple with bit value = 10', 0x02}\n"
"tarantool> s:insert{'Tuple with bit value = 11', 0x03}\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.EQ\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ANY_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_NOT_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 01', 1]\n"
"..."
msgstr ""

#: ../doc/book/box/box_index.rst:625
msgid "Search for a tuple via the given index, as described :ref:`earlier <box_index-note>`."
msgstr ""

#: ../doc/book/box/box_index.rst:631
msgid "the tuple whose index-key fields are equal to the passed key values."
msgstr ""

#: ../doc/book/box/box_index.rst:632
#: ../doc/book/box/box_index.rst:668
#: ../doc/book/box/box_index.rst:699
#: ../doc/book/box/box_index.rst:728
#: ../doc/book/box/box_index.rst:789
#: ../doc/book/box/box_index.rst:806
#: ../doc/book/box/box_space.rst:179
#: ../doc/book/box/box_space.rst:712
#: ../doc/book/box/box_space.rst:998
#: ../doc/book/box/box_space.rst:1050
#: ../doc/book/box/box_space.rst:1376
#: ../doc/book/box/box_space.rst:1602
#: ../doc/book/box/box_tuple.rst:89
#: ../doc/book/box/box_tuple.rst:364
#: ../doc/book/box/box_tuple.rst:365
#: ../doc/book/box/box_tuple.rst:552
msgid "tuple"
msgstr ""

#: ../doc/book/box/box_index.rst:636
msgid "no such index;"
msgstr ""

#: ../doc/book/box/box_index.rst:637
msgid "wrong type;"
msgstr ""

#: ../doc/book/box/box_index.rst:638
msgid "more than one tuple matches."
msgstr ""

#: ../doc/book/box/box_index.rst:640
msgid "**Complexity factors:** Index size, Index type. See also :ref:`space_object:get() <box_space-get>`."
msgstr ""

#: ../doc/book/box/box_index.rst:645
msgid "tarantool> box.space.tester.index.primary:get(2)\n"
"---\n"
"- [2, 'Music']\n"
"..."
msgstr ""

#: ../doc/book/box/box_index.rst:656
msgid "Find the minimum value in the specified index."
msgstr ""

#: ../doc/book/box/box_index.rst:662
msgid "the tuple for the first key in the index. If optional ``key`` value is supplied, returns the first key which is greater than or equal to ``key`` value. Starting with Tarantool version 2.0, index_object:min(``key`` value) will return nothing if ``key`` value is not equal to a value in the index."
msgstr ""

#: ../doc/book/box/box_index.rst:670
#: ../doc/book/box/box_index.rst:701
msgid "**Possible errors:** index is not of type 'TREE'."
msgstr ""

#: ../doc/book/box/box_index.rst:672
#: ../doc/book/box/box_index.rst:703
#: ../doc/book/box/box_index.rst:730
#: ../doc/book/box/box_space.rst:1295
#: ../doc/book/box/box_space.rst:1454
msgid "**Complexity factors:** Index size, Index type."
msgstr ""

#: ../doc/book/box/box_index.rst:676
msgid "tarantool> box.space.tester.index.primary:min()\n"
"---\n"
"- ['Alpha!', 55, 'This is the first tuple!']\n"
"..."
msgstr ""

#: ../doc/book/box/box_index.rst:687
msgid "Find the maximum value in the specified index."
msgstr ""

#: ../doc/book/box/box_index.rst:693
msgid "the tuple for the last key in the index. If optional ``key`` value is supplied, returns the last key which is less than or equal to ``key`` value. Starting with Tarantool version 2.0, index_object:max(``key`` value) will return nothing if ``key`` value is not equal to a value in the index."
msgstr ""

#: ../doc/book/box/box_index.rst:707
msgid "tarantool> box.space.tester.index.primary:max()\n"
"---\n"
"- ['Gamma!', 55, 'This is the third tuple!']\n"
"..."
msgstr ""

#: ../doc/book/box/box_index.rst:718
msgid "Find a random value in the specified index. This method is useful when it's important to get insight into data distribution in an index without having to iterate over the entire data set."
msgstr ""

#: ../doc/book/box/box_index.rst:725
msgid "an arbitrary non-negative integer"
msgstr ""

#: ../doc/book/box/box_index.rst:727
msgid "the tuple for the random key in the index."
msgstr ""

#: ../doc/book/box/box_index.rst:732
msgid "**Note re storage engine:** vinyl does not support ``random()``."
msgstr ""

#: ../doc/book/box/box_index.rst:736
msgid "tarantool> box.space.tester.index.secondary:random(1)\n"
"---\n"
"- ['Beta!', 66, 'This is the second tuple!']\n"
"..."
msgstr ""

#: ../doc/book/box/box_index.rst:747
msgid "Iterate over an index, counting the number of tuples which match the key-value."
msgstr ""

#: ../doc/book/box/box_index.rst:753
#: ../doc/book/box/box_space.rst:237
msgid "comparison method"
msgstr ""

#: ../doc/book/box/box_index.rst:755
msgid "the number of matching tuples."
msgstr ""

#: ../doc/book/box/box_index.rst:756
#: ../doc/book/box/box_index.rst:910
#: ../doc/book/box/box_schema.rst:135
#: ../doc/book/box/box_schema.rst:148
#: ../doc/book/box/box_session.rst:82
#: ../doc/book/box/box_session.rst:89
#: ../doc/book/box/box_session.rst:118
#: ../doc/book/box/box_session.rst:207
#: ../doc/book/box/box_session.rst:238
#: ../doc/book/box/box_space.rst:292
#: ../doc/book/box/box_space.rst:307
#: ../doc/book/box/box_space.rst:312
#: ../doc/book/box/box_space.rst:314
#: ../doc/book/box/box_space.rst:316
#: ../doc/book/box/box_space.rst:318
#: ../doc/book/box/box_space.rst:320
#: ../doc/book/box/box_tuple.rst:123
#: ../doc/book/box/box_tuple.rst:157
#: ../doc/book/box/box_tuple.rst:320
msgid "number"
msgstr ""

#: ../doc/book/box/box_index.rst:760
msgid "tarantool> box.space.tester.index.primary:count(999)\n"
"---\n"
"- 0\n"
"...\n"
"tarantool> box.space.tester.index.primary:count('Alpha!', { iterator = 'LE' })\n"
"---\n"
"- 1\n"
"..."
msgstr ""

#: ../doc/book/box/box_index.rst:775
#: ../doc/book/box/box_space.rst:1560
#: ../doc/book/box/box_tuple.rst:529
msgid "Update a tuple."
msgstr ""

#: ../doc/book/box/box_index.rst:777
msgid "Same as :ref:`box.space...update() <box_space-update>`, but key is searched in this index instead of primary key. This index should be unique."
msgstr ""

#: ../doc/book/box/box_index.rst:784
#: ../doc/book/box/box_space.rst:1597
#: ../doc/book/box/box_space.rst:1715
msgid "operation type represented in string"
msgstr ""

#: ../doc/book/box/box_index.rst:785
#: ../doc/book/box/box_space.rst:1598
msgid "what field the operation will apply to."
msgstr ""

#: ../doc/book/box/box_index.rst:786
#: ../doc/book/box/box_space.rst:1599
#: ../doc/book/box/box_space.rst:1717
#: ../doc/book/box/box_tuple.rst:549
msgid "what value will be applied"
msgstr ""

#: ../doc/book/box/box_index.rst:788
#: ../doc/book/box/box_space.rst:1601
msgid "the updated tuple."
msgstr ""

#: ../doc/book/box/box_index.rst:795
msgid "Delete a tuple identified by a key."
msgstr ""

#: ../doc/book/box/box_index.rst:797
msgid "Same as :ref:`box.space...delete() <box_space-delete>`, but key is searched in this index instead of in the primary-key index. This index ought to be unique."
msgstr ""

#: ../doc/book/box/box_index.rst:805
msgid "the deleted tuple."
msgstr ""

#: ../doc/book/box/box_index.rst:808
msgid "**Note re storage engine:** vinyl will return `nil`, rather than the deleted tuple."
msgstr ""

#: ../doc/book/box/box_index.rst:815
msgid "Alter an index. It is legal in some circumstances to change one or more of the index characteristics, for example its type, its sequence options, its parts, and whether it is unique, Usually this causes rebuilding of the space,  except for the simple case where a part's ``is_nullable`` flag is changed from ``false`` to ``true``."
msgstr ""

#: ../doc/book/box/box_index.rst:824
msgid "options list, same as the options list for ``create_index``, see the chart named :ref:`Options for space_object:create_index() <box_space-create_index>`."
msgstr ""

#: ../doc/book/box/box_index.rst:828
#: ../doc/book/box/box_index.rst:886
#: ../doc/book/box/box_schema.rst:238
#: ../doc/book/box/box_schema.rst:456
#: ../doc/book/box/box_schema.rst:611
#: ../doc/book/box/box_schema.rst:665
#: ../doc/book/box/box_space.rst:749
#: ../doc/book/box/box_space.rst:1345
#: ../doc/book/box/box_space.rst:1404
#: ../doc/book/box/box_space.rst:1534
#: ../doc/book/box/data_model.rst:153
msgid "nil"
msgstr ""

#: ../doc/book/box/box_index.rst:832
#: ../doc/book/box/box_index.rst:864
msgid "index does not exist,"
msgstr ""

#: ../doc/book/box/box_index.rst:833
msgid "the primary-key index cannot be changed to ``{unique = false}``."
msgstr ""

#: ../doc/book/box/box_index.rst:835
msgid "**Note re storage engine:** vinyl does not support ``alter()`` of a primary-key index unless the space is empty."
msgstr ""

#: ../doc/book/box/box_index.rst:840
msgid "tarantool> box.space.space55.index.primary:alter({type = 'HASH'})\n"
"---\n"
"...\n"
"\n"
"tarantool> box.space.vinyl_space.index.i:alter({page_size=4096})\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/box/box_index.rst:854
msgid "Drop an index. Dropping a primary-key index has a side effect: all tuples are deleted."
msgstr ""

#: ../doc/book/box/box_index.rst:860
msgid "nil."
msgstr ""

#: ../doc/book/box/box_index.rst:865
msgid "a primary-key index cannot be dropped while a secondary-key index exists."
msgstr ""

#: ../doc/book/box/box_index.rst:870
msgid "tarantool> box.space.space55.index.primary:drop()\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/box/box_index.rst:880
msgid "Rename an index."
msgstr ""

#: ../doc/book/box/box_index.rst:884
msgid "new name for index"
msgstr ""

#: ../doc/book/box/box_index.rst:888
msgid "**Possible errors:** index_object does not exist."
msgstr ""

#: ../doc/book/box/box_index.rst:892
msgid "tarantool> box.space.space55.index.primary:rename('secondary')\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/box/box_index.rst:898
#: ../doc/book/box/box_space.rst:1532
msgid "**Complexity factors:** Index size, Index type, Number of tuples accessed."
msgstr ""

#: ../doc/book/box/box_index.rst:904
msgid "Return the total number of bytes taken by the index."
msgstr ""

#: ../doc/book/box/box_index.rst:909
#: ../doc/book/box/box_tuple.rst:156
msgid "number of bytes"
msgstr ""

#: ../doc/book/box/box_index.rst:916
msgid "Return statistics about actions taken that affect the index."
msgstr ""

#: ../doc/book/box/box_index.rst:918
msgid "This is for use with the vinyl engine."
msgstr ""

#: ../doc/book/box/box_index.rst:920
msgid "Some detail items in the output from ``index_object:stat()`` are:"
msgstr ""

#: ../doc/book/box/box_index.rst:922
msgid "``index_object:stat().latency`` -- timings subdivided by percentages;"
msgstr ""

#: ../doc/book/box/box_index.rst:923
msgid "``index_object:stat().bytes`` -- the number of bytes total;"
msgstr ""

#: ../doc/book/box/box_index.rst:924
msgid "``index_object:stat().disk.rows`` -- the approximate number of tuples in each range;"
msgstr ""

#: ../doc/book/box/box_index.rst:925
msgid "``index_object:stat().disk.statement`` -- counts of inserts|updates|upserts|deletes;"
msgstr ""

#: ../doc/book/box/box_index.rst:926
msgid "``index_object:stat().disk.compaction`` -- counts of compactions and their amounts;"
msgstr ""

#: ../doc/book/box/box_index.rst:927
msgid "``index_object:stat().disk.dump`` -- counts of dumps and their amounts;"
msgstr ""

#: ../doc/book/box/box_index.rst:928
msgid "``index_object:stat().disk.iterator.bloom`` -- counts of bloom filter hits|misses;"
msgstr ""

#: ../doc/book/box/box_index.rst:929
msgid "``index_object:stat().disk.pages`` -- the size in pages;"
msgstr ""

#: ../doc/book/box/box_index.rst:930
msgid "``index_object:stat().disk.last_level`` -- size of data in the last LSM tree level;"
msgstr ""

#: ../doc/book/box/box_index.rst:931
msgid "``index_object:stat().cache.evict`` -- number of evictions from the cache;"
msgstr ""

#: ../doc/book/box/box_index.rst:932
msgid "``index_object:stat().range_size`` -- maximum number of bytes in a range;"
msgstr ""

#: ../doc/book/box/box_index.rst:933
msgid "``index_object:stat().dumps_per_compaction`` -- average number of dumps required to trigger major compaction in any range of the LSM tree."
msgstr ""

#: ../doc/book/box/box_index.rst:935
msgid "Summary index statistics are also available via :ref:`box.stat.vinyl() <box_introspection-box_stat_vinyl_details>`."
msgstr ""

#: ../doc/book/box/box_index.rst:941
msgid "statistics"
msgstr ""

#: ../doc/book/box/box_index.rst:948
msgid "Remove unused index space. For the memtx storage engine this method does nothing; ``index_object:compact()`` is only for the vinyl storage engine. For example, with vinyl, if a tuple is deleted, the space is not immediately reclaimed. There is a scheduler for reclaiming space automatically based on factors such as lsm shape and amplification as discussed in the section :ref:`Storing data with vinyl <engines-vinyl>`, so calling ``index_object:compact()`` manually is not always necessary."
msgstr ""

#: ../doc/book/box/box_index.rst:957
msgid "nil (Tarantool returns without waiting for compaction to complete)"
msgstr ""

#: ../doc/book/box/box_index.rst:964
msgid "Users can define any functions they want, and associate them with indexes: in effect they can make their own index methods. They do this by:"
msgstr ""

#: ../doc/book/box/box_index.rst:968
#: ../doc/book/box/box_space.rst:1748
msgid "creating a Lua function,"
msgstr ""

#: ../doc/book/box/box_index.rst:969
#: ../doc/book/box/box_space.rst:1749
msgid "adding the function name to a predefined global variable which has type = table, and"
msgstr ""

#: ../doc/book/box/box_index.rst:971
msgid "invoking the function any time thereafter, as long as the server is up, by saying ``index_object:function-name([parameters])``."
msgstr ""

#: ../doc/book/box/box_index.rst:974
msgid "There are three predefined global variables:"
msgstr ""

#: ../doc/book/box/box_index.rst:976
msgid "Adding to ``box_schema.index_mt`` makes the method available for all indexes."
msgstr ""

#: ../doc/book/box/box_index.rst:977
msgid "Adding to ``box_schema.memtx_index_mt`` makes the method available for all memtx indexes."
msgstr ""

#: ../doc/book/box/box_index.rst:978
msgid "Adding to ``box_schema.vinyl_index_mt`` makes the method available for all vinyl indexes."
msgstr ""

#: ../doc/book/box/box_index.rst:980
msgid "Alternatively, user-defined methods can be made available for only one index, by calling ``getmetatable(index_object)`` and then adding the function name to the meta table."
msgstr ""

#: ../doc/book/box/box_index.rst:986
#: ../doc/book/box/box_space.rst:1764
msgid "whatever the user defines"
msgstr ""

#: ../doc/book/box/box_index.rst:990
msgid "-- Visible to any index of a memtx space, no parameters.\n"
"-- After these requests, the value of global_variable will be 6.\n"
"box.schema.space.create('t', {engine='memtx'})\n"
"box.space.t:create_index('i')\n"
"global_variable = 5\n"
"function f() global_variable = global_variable + 1 end\n"
"box.schema.memtx_index_mt.counter = f\n"
"box.space.t.index.i:counter()"
msgstr ""

#: ../doc/book/box/box_index.rst:1003
msgid "-- Visible to index box.space.t.index.i only, 1 parameter.\n"
"-- After these requests, the value of X will be 1005.\n"
"box.schema.space.create('t', {engine='memtx', id = 1000})\n"
"box.space.t:create_index('i')\n"
"X = 0\n"
"i = box.space.t.index.i\n"
"function f(i_arg, param) X = X + param + i_arg.space_id end\n"
"box.schema.memtx_index_mt.counter = f\n"
"meta = getmetatable(i)\n"
"meta.counter = f\n"
"i:counter(5)"
msgstr ""

#: ../doc/book/box/box_index.rst:1019
msgid "Example showing use of the box functions"
msgstr ""

#: ../doc/book/box/box_index.rst:1021
msgid "This example will work with the sandbox configuration described in the preface. That is, there is a space named tester with a numeric primary key. The example function will:"
msgstr ""

#: ../doc/book/box/box_index.rst:1025
msgid "select a tuple whose key value is 1000;"
msgstr ""

#: ../doc/book/box/box_index.rst:1026
msgid "raise an error if the tuple already exists and already has 3 fields;"
msgstr ""

#: ../doc/book/box/box_index.rst:1029
msgid "Insert or replace the tuple with:"
msgstr ""

#: ../doc/book/box/box_index.rst:1028
msgid "field[1] = 1000"
msgstr ""

#: ../doc/book/box/box_index.rst:1029
msgid "field[2] = a uuid"
msgstr ""

#: ../doc/book/box/box_index.rst:1030
msgid "field[3] = number of seconds since 1970-01-01;"
msgstr ""

#: ../doc/book/box/box_index.rst:1031
msgid "Get field[3] from what was replaced;"
msgstr ""

#: ../doc/book/box/box_index.rst:1032
msgid "Format the value from field[3] as yyyy-mm-dd hh:mm:ss.ffff;"
msgstr ""

#: ../doc/book/box/box_index.rst:1033
msgid "Return the formatted value."
msgstr ""

#: ../doc/book/box/box_index.rst:1035
msgid "The function uses Tarantool box functions :ref:`box.space...select <box_space-select>`, :ref:`box.space...replace <box_space-replace>`, :ref:`fiber.time <fiber-time>`, :ref:`uuid.str <uuid-str>`. The function uses Lua functions `os.date()`_ and `string.sub()`_."
msgstr ""

#: ../doc/book/box/box_index.rst:1044
msgid "function example()\n"
"  local a, b, c, table_of_selected_tuples, d\n"
"  local replaced_tuple, time_field\n"
"  local formatted_time_field\n"
"  local fiber = require('fiber')\n"
"  table_of_selected_tuples = box.space.tester:select{1000}\n"
"  if table_of_selected_tuples ~= nil then\n"
"    if table_of_selected_tuples[1] ~= nil then\n"
"      if #table_of_selected_tuples[1] == 3 then\n"
"        box.error({code=1, reason='This tuple already has 3 fields'})\n"
"      end\n"
"    end\n"
"  end\n"
"  replaced_tuple = box.space.tester:replace\n"
"    {1000,  require('uuid').str(), tostring(fiber.time())}\n"
"  time_field = tonumber(replaced_tuple[3])\n"
"  formatted_time_field = os.date(\"%Y-%m-%d %H:%M:%S\", time_field)\n"
"  c = time_field % 1\n"
"  d = string.sub(c, 3, 6)\n"
"  formatted_time_field = formatted_time_field .. '.' .. d\n"
"  return formatted_time_field\n"
"end"
msgstr ""

#: ../doc/book/box/box_index.rst:1069
#: ../doc/book/box/box_tuple.rst:601
msgid "... And here is what happens when one invokes the function:"
msgstr ""

#: ../doc/book/box/box_index.rst:1071
msgid "tarantool> box.space.tester:delete(1000)\n"
"---\n"
"- [1000, '264ee2da03634f24972be76c43808254', '1391037015.6809']\n"
"...\n"
"tarantool> example(1000)\n"
"---\n"
"- 2014-01-29 16:11:51.1582\n"
"...\n"
"tarantool> example(1000)\n"
"---\n"
"- error: 'This tuple already has 3 fields'\n"
"..."
msgstr ""

#: ../doc/book/box/box_index.rst:1088
msgid "Example showing a user-defined iterator"
msgstr ""

#: ../doc/book/box/box_index.rst:1090
msgid "Here is an example that shows how to build one's own iterator. The ``paged_iter`` function is an \"iterator function\", which will only be understood by programmers who have read the Lua manual section `Iterators and Closures <https://www.lua.org/pil/7.1.html>`_. It does paginated retrievals, that is, it returns 10 tuples at a time from a table named \"t\", whose primary key was defined with ``create_index('primary',{parts={1,'string'}})``."
msgstr ""

#: ../doc/book/box/box_index.rst:1097
msgid "function paged_iter(search_key, tuples_per_page)\n"
"  local iterator_string = \"GE\"\n"
"  return function ()\n"
"  local page = box.space.t.index[0]:select(search_key,\n"
"    {iterator = iterator_string, limit=tuples_per_page})\n"
"  if #page == 0 then return nil end\n"
"  search_key = page[#page][1]\n"
"  iterator_string = \"GT\"\n"
"  return page\n"
"  end\n"
"end"
msgstr ""

#: ../doc/book/box/box_index.rst:1111
msgid "Programmers who use ``paged_iter`` do not need to know why it works, they only need to know that, if they call it within a loop, they will get 10 tuples at a time until there are no more tuples."
msgstr ""

#: ../doc/book/box/box_index.rst:1115
msgid "In this example the tuples are merely printed, a page at a time. But it should be simple to change the functionality, for example by yielding after each retrieval, or by breaking when the tuples fail to match some additional criteria."
msgstr ""

#: ../doc/book/box/box_index.rst:1120
msgid "for page in paged_iter(\"X\", 10) do\n"
"  print(\"New Page. Number Of Tuples = \" .. #page)\n"
"  for i = 1, #page, 1 do\n"
"    print(page[i])\n"
"  end\n"
"end"
msgstr ""

#: ../doc/book/box/box_index.rst:1133
msgid "Submodule `box.index` with index type = RTREE for spatial searches"
msgstr ""

#: ../doc/book/box/box_index.rst:1135
msgid "The :ref:`box.index <box_index>` submodule may be used for spatial searches if the index type is RTREE. There are operations for searching *rectangles* (geometric objects with 4 corners and 4 sides) and *boxes* (geometric objects with more than 4 corners and more than 4 sides, sometimes called hyperrectangles). This manual uses the term *rectangle-or-box* for the whole class of objects that includes both rectangles and boxes. Only rectangles will be illustrated."
msgstr ""

#: ../doc/book/box/box_index.rst:1143
msgid "Rectangles are described according to their X-axis (horizontal axis) and Y-axis (vertical axis) coordinates in a grid of arbitrary size. Here is a picture of four rectangles on a grid with 11 horizontal points and 11 vertical points:"
msgstr ""

#: ../doc/book/box/box_index.rst:1147
msgid "           X AXIS\n"
"           1   2   3   4   5   6   7   8   9   10  11\n"
"        1\n"
"        2  #-------+                                           <-Rectangle#1\n"
"Y AXIS  3  |       |\n"
"        4  +-------#\n"
"        5          #-----------------------+                   <-Rectangle#2\n"
"        6          |                       |\n"
"        7          |   #---+               |                   <-Rectangle#3\n"
"        8          |   |   |               |\n"
"        9          |   +---#               |\n"
"        10         +-----------------------#\n"
"        11                                     #               <-Rectangle#4"
msgstr ""

#: ../doc/book/box/box_index.rst:1163
msgid "The rectangles are defined according to this scheme: {X-axis coordinate of top left, Y-axis coordinate of top left, X-axis coordinate of bottom right, Y-axis coordinate of bottom right} -- or more succinctly: {x1,y1,x2,y2}. So in the picture ... Rectangle#1 starts at position 1 on the X axis and position 2 on the Y axis, and ends at position 3 on the X axis and position 4 on the Y axis, so its coordinates are {1,2,3,4}. Rectangle#2's coordinates are {3,5,9,10}. Rectangle#3's coordinates are {4,7,5,9}. And finally Rectangle#4's coordinates are {10,11,10,11}. Rectangle#4 is actually a \"point\" since it has zero width and zero height, so it could have been described with only two digits: {10,11}."
msgstr ""

#: ../doc/book/box/box_index.rst:1173
msgid "Some relationships between the rectangles are: \"Rectangle#1's nearest neighbor is Rectangle#2\", and \"Rectangle#3 is entirely inside Rectangle#2\"."
msgstr ""

#: ../doc/book/box/box_index.rst:1176
msgid "Now let us create a space and add an RTREE index."
msgstr ""

#: ../doc/book/box/box_index.rst:1178
msgid "tarantool> s = box.schema.space.create('rectangles')\n"
"tarantool> i = s:create_index('primary', {\n"
"         >   type = 'HASH',\n"
"         >   parts = {1, 'unsigned'}\n"
"         > })\n"
"tarantool> r = s:create_index('rtree', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"
msgstr ""

#: ../doc/book/box/box_index.rst:1191
msgid "Field#1 doesn't matter, we just make it because we need a primary-key index. (RTREE indexes cannot be unique and therefore cannot be primary-key indexes.) The second field must be an \"array\", which means its values must represent {x,y} points or {x1,y1,x2,y2} rectangles. Now let us populate the table by inserting two tuples, containing the coordinates of Rectangle#2 and Rectangle#4."
msgstr ""

#: ../doc/book/box/box_index.rst:1197
msgid "tarantool> s:insert{1, {3, 5, 9, 10}}\n"
"tarantool> s:insert{2, {10, 11}}"
msgstr ""

#: ../doc/book/box/box_index.rst:1202
msgid "And now, following the description of `RTREE iterator types`_, we can search the rectangles with these requests:"
msgstr ""

#: ../doc/book/box/box_index.rst:1207
msgid "tarantool> r:select({10, 11, 10, 11}, {iterator = 'EQ'})\n"
"---\n"
"- - [2, [10, 11]]\n"
"...\n"
"tarantool> r:select({4, 7, 5, 9}, {iterator = 'GT'})\n"
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"...\n"
"tarantool> r:select({1, 2, 3, 4}, {iterator = 'NEIGHBOR'})\n"
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"  - [2, [10, 11]]\n"
"..."
msgstr ""

#: ../doc/book/box/box_index.rst:1223
msgid "Request#1 returns 1 tuple because the point {10,11} is the same as the rectangle {10,11,10,11} (\"Rectangle#4\" in the picture). Request#2 returns 1 tuple because the rectangle {4,7,5,9}, which was \"Rectangle#3\" in the picture, is entirely within{3,5,9,10} which was Rectangle#2. Request#3 returns 2 tuples, because the NEIGHBOR iterator always returns all tuples, and the first returned tuple will be {3,5,9,10} (\"Rectangle#2\" in the picture) because it is the closest neighbor of {1,2,3,4} (\"Rectangle#1\" in the picture)."
msgstr ""

#: ../doc/book/box/box_index.rst:1231
msgid "Now let us create a space and index for cuboids, which are rectangle-or-boxes that have 6 corners and 6 sides."
msgstr ""

#: ../doc/book/box/box_index.rst:1234
msgid "tarantool> s = box.schema.space.create('R')\n"
"tarantool> i = s:create_index('primary', {parts = {1, 'unsigned'}})\n"
"tarantool> r = s:create_index('S', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   dimension = 3,\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"
msgstr ""

#: ../doc/book/box/box_index.rst:1245
msgid "The additional option here is ``dimension=3``. The default dimension is 2, which is why it didn't need to be specified for the examples of rectangle. The maximum dimension is 20. Now for insertions and selections there will usually be 6 coordinates. For example:"
msgstr ""

#: ../doc/book/box/box_index.rst:1250
msgid "tarantool> s:insert{1, {0, 3, 0, 3, 0, 3}}\n"
"tarantool> r:select({1, 2, 1, 2, 1, 2}, {iterator = box.index.GT})"
msgstr ""

#: ../doc/book/box/box_index.rst:1255
msgid "Now let us create a space and index for Manhattan-style spatial objects, which are rectangle-or-boxes that have a different way to calculate neighbors."
msgstr ""

#: ../doc/book/box/box_index.rst:1258
msgid "tarantool> s = box.schema.space.create('R')\n"
"tarantool> i = s:create_index('primary', {parts = {1, 'unsigned'}})\n"
"tarantool> r = s:create_index('S', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   distance = 'manhattan',\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"
msgstr ""

#: ../doc/book/box/box_index.rst:1269
msgid "The additional option here is ``distance='manhattan'``. The default distance calculator is 'euclid', which is the straightforward as-the-crow-flies method. The optional distance calculator is 'manhattan', which can be a more appropriate method if one is following the lines of a grid rather than traveling in a straight line."
msgstr ""

#: ../doc/book/box/box_index.rst:1275
msgid "tarantool> s:insert{1, {0, 3, 0, 3}}\n"
"tarantool> r:select({1, 2, 1, 2}, {iterator = box.index.NEIGHBOR})"
msgstr ""

#: ../doc/book/box/box_index.rst:1281
msgid "More examples of spatial searching are online in the file `R tree index quick start and usage`_."
msgstr ""

#: ../doc/book/box/box_info.rst:5
#: ../doc/book/box/box_introspection.rst:32
msgid "Submodule `box.info`"
msgstr ""

#: ../doc/book/box/box_info.rst:9
msgid "The ``box.info`` submodule provides access to information about server instance variables."
msgstr ""

#: ../doc/book/box/box_info.rst:12
msgid "**cluster.uuid** is the UUID of the replica set. Every instance in a replica set will have the same ``cluster.uuid`` value. This value is also stored in :ref:`box.space._schema <box_space-schema>` system space."
msgstr ""

#: ../doc/book/box/box_info.rst:16
msgid "**gc()** returns the state of the :ref:`Tarantool garbage collector <cfg_checkpoint_daemon-garbage-collector>` including the checkpoints and their consumers (users); see details :ref:`below <box_info_gc>`."
msgstr ""

#: ../doc/book/box/box_info.rst:20
msgid "**id** corresponds to **replication.id** (see :ref:`below <box_info_replication>`)."
msgstr ""

#: ../doc/book/box/box_info.rst:22
msgid "**lsn** corresponds to **replication.lsn** (see :ref:`below <box_info_replication>`)."
msgstr ""

#: ../doc/book/box/box_info.rst:24
msgid "**memory()** returns the statistics about memory (see :ref:`below <box_info_memory>`)."
msgstr ""

#: ../doc/book/box/box_info.rst:26
msgid "**pid** is the process ID. This value is also shown by :ref:`tarantool <tarantool-build>` module and by the Linux command ``ps -A``."
msgstr ""

#: ../doc/book/box/box_info.rst:29
msgid "**ro** is ``true`` if the instance is in \"read-only\" mode (same as :ref:`read_only <cfg_basic-read_only>` in ``box.cfg{}``), or if status is 'orphan'."
msgstr ""

#: ../doc/book/box/box_info.rst:32
msgid "**signature** is the sum of all **lsn** values from the vector clocks (**vclock**) of all instances in the replica set."
msgstr ""

#: ../doc/book/box/box_info.rst:34
msgid "**status** corresponds to **replication.upstream.status** (see below)."
msgstr ""

#: ../doc/book/box/box_info.rst:35
msgid "**uptime** is the number of seconds since the instance started. This value can also be retrieved with :ref:`tarantool.uptime() <tarantool-build>`."
msgstr ""

#: ../doc/book/box/box_info.rst:38
msgid "**uuid** corresponds to **replication.uuid** (see :ref:`below <box_info_replication>`)."
msgstr ""

#: ../doc/book/box/box_info.rst:40
msgid "**vclock** corresponds to **replication.downstream.vclock** (see :ref:`below <box_info_replication>`)."
msgstr ""

#: ../doc/book/box/box_info.rst:42
msgid "**version** is the Tarantool version. This value is also shown by :ref:`tarantool -V <index-tarantool_version>`."
msgstr ""

#: ../doc/book/box/box_info.rst:44
msgid "**vinyl()** returns runtime statistics for the vinyl storage engine. This function is deprecated, use :ref:`box.stat.vinyl() <box_introspection-box_stat_vinyl>` instead."
msgstr ""

#: ../doc/book/box/box_info.rst:52
msgid "The **memory** function of ``box.info`` gives the ``admin`` user a picture of the whole Tarantool instance."
msgstr ""

#: ../doc/book/box/box_info.rst:57
msgid "To get a picture of the vinyl subsystem, use :ref:`box.stat.vinyl() <box_introspection-box_stat_vinyl>` instead."
msgstr ""

#: ../doc/book/box/box_info.rst:60
msgid "**memory().cache** -- number of bytes used for caching user data. The memtx storage engine does not require a cache, so in fact this is the number of bytes in the cache for the tuples stored for the vinyl storage engine."
msgstr ""

#: ../doc/book/box/box_info.rst:64
msgid "**memory().data** -- number of bytes used for storing user data (the tuples) with the memtx engine and with level 0 of the vinyl engine, without taking memory fragmentation into account."
msgstr ""

#: ../doc/book/box/box_info.rst:67
msgid "**memory().index** -- number of bytes used for indexing user data, including memtx and vinyl memory tree extents, the vinyl page index, and the vinyl bloom filters."
msgstr ""

#: ../doc/book/box/box_info.rst:70
msgid "**memory().lua** -- number of bytes used for Lua runtime."
msgstr ""

#: ../doc/book/box/box_info.rst:71
msgid "**memory().net** -- number of bytes used for network input/output buffers."
msgstr ""

#: ../doc/book/box/box_info.rst:72
msgid "**memory().tx** -- number of bytes in use by active transactions. For the vinyl storage engine, this is the total size of all allocated objects (struct ``txv``, struct ``vy_tx``, struct ``vy_read_interval``) and tuples pinned for those objects."
msgstr ""

#: ../doc/book/box/box_info.rst:77
msgid "An example with a minimum allocation while only the memtx storage engine is in use:"
msgstr ""

#: ../doc/book/box/box_info.rst:80
msgid "tarantool> box.info.memory()\n"
"---\n"
"- cache: 0\n"
"  data: 6552\n"
"  tx: 0\n"
"  lua: 1315567\n"
"  net: 98304\n"
"  index: 1196032\n"
"..."
msgstr ""

#: ../doc/book/box/box_info.rst:96
msgid "The **gc** function of ``box.info`` gives the ``admin`` user a picture of the factors that affect the :ref:`Tarantool garbage collector <cfg_checkpoint_daemon-garbage-collector>`. The garbage collector compares vclock (:ref:`vector clock <replication-vector>`) values of users and checkpoints, so a look at ``box.info.gc()`` may show why the garbage collector has not removed old WAL files, or show what it may soon remove."
msgstr ""

#: ../doc/book/box/box_info.rst:103
msgid "**gc().consumers** -- a list of users whose requests might affect the garbage collector."
msgstr ""

#: ../doc/book/box/box_info.rst:104
msgid "**gc().checkpoints** -- a list of preserved checkpoints."
msgstr ""

#: ../doc/book/box/box_info.rst:105
msgid "**gc().checkpoints[n].references** -- a list of references to a checkpoint."
msgstr ""

#: ../doc/book/box/box_info.rst:106
msgid "**gc().checkpoints[n].vclock** -- a checkpoint's vclock value."
msgstr ""

#: ../doc/book/box/box_info.rst:107
msgid "**gc().checkpoints[n].signature** -- a sum of a checkpoint's vclock's components."
msgstr ""

#: ../doc/book/box/box_info.rst:108
msgid "**gc().checkpoint_is_in_progress** -- true if a checkpoint is in progress, otherwise false"
msgstr ""

#: ../doc/book/box/box_info.rst:109
msgid "**gc().vclock** -- the garbage collector's vclock."
msgstr ""

#: ../doc/book/box/box_info.rst:110
msgid "**gc().signature** -- the sum of the garbage collector's checkpoint's components."
msgstr ""

#: ../doc/book/box/box_info.rst:116
msgid "The **replication** section of ``box.info()`` contains statistics for all instances in the replica set in regard to the current instance (see also :ref:`\"Monitoring a replica set\" <replication-monitoring>`):"
msgstr ""

#: ../doc/book/box/box_info.rst:120
msgid "**replication.id** is a short numeric identifier of the instance within the replica set."
msgstr ""

#: ../doc/book/box/box_info.rst:122
msgid "**replication.uuid** is a globally unique identifier of the instance. This value is also stored in :ref:`box.space._cluster <box_space-cluster>` system space."
msgstr ""

#: ../doc/book/box/box_info.rst:125
msgid "**replication.lsn** is the :ref:`log sequence number <replication-mechanism>` (LSN) for the latest entry in the instance's :ref:`write ahead log <index-box_persistence>` (WAL)."
msgstr ""

#: ../doc/book/box/box_info.rst:129
msgid "**replication.upstream** contains statistics for the replication data uploaded by the instance."
msgstr ""

#: ../doc/book/box/box_info.rst:131
msgid "**replication.upstream.status** is the replication status of the instance:"
msgstr ""

#: ../doc/book/box/box_info.rst:133
msgid "``auth`` means that the instance is getting :ref:`authenticated <authentication>` to connect to a replication source."
msgstr ""

#: ../doc/book/box/box_info.rst:136
msgid "``connecting`` means that the instance is trying to connect to the replications source(s) listed in its :ref:`replication <cfg_replication-replication>` parameter."
msgstr ""

#: ../doc/book/box/box_info.rst:139
msgid "``disconnected`` means that the instance is not connected to the replica set (due to network problems, not replication errors)."
msgstr ""

#: ../doc/book/box/box_info.rst:141
msgid "``follow`` means that replication is in progress."
msgstr ""

#: ../doc/book/box/box_info.rst:142
msgid "``running`` means the instance's role is \"master\" (non read-only) and replication is in progress."
msgstr ""

#: ../doc/book/box/box_info.rst:144
msgid "``stopped`` means that replication was stopped due to a replication error (e.g. :ref:`duplicate key <error_codes>`)."
msgstr ""

#: ../doc/book/box/box_info.rst:146
msgid "``orphan`` means that the instance has not (yet) succeeded in joining the required number of masters (see :ref:`orphan status <replication-orphan_status>`)."
msgstr ""

#: ../doc/book/box/box_info.rst:148
msgid "``synch`` means that the master and replica are synchronizing to have the same data."
msgstr ""

#: ../doc/book/box/box_info.rst:153
msgid "**replication.upstream.idle** is the time (in seconds) since the instance received the last event from a master. This is the primary indicator of replication health. See more in :ref:`Monitoring a replica set <replication-monitoring>`."
msgstr ""

#: ../doc/book/box/box_info.rst:160
msgid "**replication.upstream.peer** contains the replication user name, host IP adress and port number used for the instance. See more in :ref:`Monitoring a replica set <replication-monitoring>`."
msgstr ""

#: ../doc/book/box/box_info.rst:166
msgid "**replication.upstream.lag** is the time difference between the local time at the instance, recorded when the event was received, and the local time at another master recorded when the event was written to the :ref:`write ahead log <internals-wal>` on that master. See more in :ref:`Monitoring a replica set <replication-monitoring>`."
msgstr ""

#: ../doc/book/box/box_info.rst:172
msgid "**replication.upstream.message** contains an error message in case of a :ref:`degraded state <replication-recover>`, empty otherwise."
msgstr ""

#: ../doc/book/box/box_info.rst:175
msgid "**replication.downstream** contains statistics for the replication data requested and downloaded from the instance."
msgstr ""

#: ../doc/book/box/box_info.rst:178
msgid "**replication.downstream.vclock** contains the :ref:`vector clock <replication-vector>`, which is a table of '**id**, **lsn**' pairs, for example :code:`vclock: {1: 3054773, 4: 8938827, 3: 285902018}`. Even if an instance is :ref:`removed <replication-remove_instances>`, its values will still appear here."
msgstr ""

#: ../doc/book/box/box_info.rst:185
msgid "**replication.downstream.status** ``= disconnected`` is displayed if the downstream instance disconnects from the upstream instance. Otherwise the status is not reported."
msgstr ""

#: ../doc/book/box/box_info.rst:191
#: ../doc/book/box/box_introspection.rst:71
msgid "Since ``box.info`` contents are dynamic, it's not possible to iterate over keys with the Lua ``pairs()`` function. For this purpose, ``box.info()`` builds and returns a Lua table with all keys and values provided in the submodule."
msgstr ""

#: ../doc/book/box/box_info.rst:196
msgid "keys and values in the submodule"
msgstr ""

#: ../doc/book/box/box_info.rst:201
msgid "This example is for a master-replica set that contains one master instance and one replica instance. The request was issued at the replica instance."
msgstr ""

#: ../doc/book/box/box_info.rst:204
msgid "tarantool> box.info()\n"
"---\n"
"- version: 1.7.6-68-g51fcffb77\n"
"  id: 2\n"
"  ro: true\n"
"  vclock: {1: 5}\n"
"  uptime: 917\n"
"  lsn: 0\n"
"  vinyl: []\n"
"  cluster:\n"
"    uuid: 783e2285-55b1-42d4-b93c-68dcbb7a8c18\n"
"  pid: 35341\n"
"  status: running\n"
"  signature: 5\n"
"  replication:\n"
"    1:\n"
"      id: 1\n"
"      uuid: 471cd36e-cb2e-4447-ac66-2d28e9dd3b67\n"
"      lsn: 5\n"
"      upstream:\n"
"        status: follow\n"
"        idle: 124.98795700073\n"
"        peer: replicator@192.168.0.101:3301\n"
"        lag: 0\n"
"      downstream:\n"
"        vclock: {1: 5}\n"
"    2:\n"
"      id: 2\n"
"      uuid: ac45d5d2-8a16-4520-ad5e-1abba6baba0a\n"
"      lsn: 0\n"
"  uuid: ac45d5d2-8a16-4520-ad5e-1abba6baba0a\n"
"..."
msgstr ""

#: ../doc/book/box/box_introspection.rst:9
msgid "The ``box.cfg`` submodule is for administrators to specify all the server configuration parameters (see \"Configuration reference\" for :ref:`a complete description of all configuration parameters <box_cfg_params>`). Use ``box.cfg`` without braces to get read-only access to those parameters."
msgstr ""

#: ../doc/book/box/box_introspection.rst:36
msgid "The ``box.info`` submodule provides access to information about server instance variables. Some of this information is also available from the :ref:`tarantool module <tarantool-module>`."
msgstr ""

#: ../doc/book/box/box_introspection.rst:39
msgid "**server.lsn** Log Sequence Number for the latest entry in the :ref:`WAL <internals-wal>`."
msgstr ""

#: ../doc/book/box/box_introspection.rst:40
msgid "**server.ro**  True if the instance is in \"read_only\" mode (same as :ref:`read_only <cfg_basic-read_only>` in box.cfg)."
msgstr ""

#: ../doc/book/box/box_introspection.rst:42
msgid "**server.uuid** The unique identifier of this instance, as stored in the database. This value is also in the :ref:`box.space._cluster <box_space-cluster>` system space."
msgstr ""

#: ../doc/book/box/box_introspection.rst:45
msgid "**server.id** The number of this server's instance within a replica set."
msgstr ""

#: ../doc/book/box/box_introspection.rst:46
msgid "**version** Tarantool version. This value is also shown by :ref:`tarantool --version <index-tarantool_version>`."
msgstr ""

#: ../doc/book/box/box_introspection.rst:48
msgid "**status** Usually this is 'running', but it can be 'loading', 'orphan', or 'hot_standby'."
msgstr ""

#: ../doc/book/box/box_introspection.rst:49
msgid "**vclock** Same as :ref:`replication.vclock <replication-vector>`."
msgstr ""

#: ../doc/book/box/box_introspection.rst:50
msgid "**pid** Process ID. This value is also shown by the :ref:`tarantool <tarantool-build>` module. This value is also shown by the Linux \"ps -A\" command."
msgstr ""

#: ../doc/book/box/box_introspection.rst:53
msgid "**cluster.uuid** UUID of the :ref:`replica set <replication-mechanism>`. Every instance in a replica set will have the same cluster.uuid value. This value is also in the :ref:`box.space._schema <box_space-schema>` system space."
msgstr ""

#: ../doc/book/box/box_introspection.rst:55
msgid "**vinyl()** Returns runtime statistics for the vinyl storage engine."
msgstr ""

#: ../doc/book/box/box_introspection.rst:56
msgid "**replication.lag** Number of seconds that the replica is behind the master."
msgstr ""

#: ../doc/book/box/box_introspection.rst:57
msgid "**replication.status** Usually this is 'follow', but it can be 'off', 'stopped', 'connecting', 'auth', or 'disconnected'."
msgstr ""

#: ../doc/book/box/box_introspection.rst:59
msgid "**replication.idle** Number of seconds that the instancehas been idle."
msgstr ""

#: ../doc/book/box/box_introspection.rst:60
msgid "**replication.vclock** See the :ref:`discussion of \"vector clock\" <replication-vector>` in the Internals section."
msgstr ""

#: ../doc/book/box/box_introspection.rst:61
msgid "**replication.uuid** The unique identifier of a master to which this instance is connected."
msgstr ""

#: ../doc/book/box/box_introspection.rst:62
msgid "**replication.uptime** Number of seconds since the instance started. This value can also be retrieved with :ref:`tarantool.uptime() <tarantool-build>`."
msgstr ""

#: ../doc/book/box/box_introspection.rst:65
msgid "The replication fields are blank unless the instance is a :ref:`replica <index-box_replication>`. The replication fields are in an array if the instance is a replica for more than one master."
msgstr ""

#: ../doc/book/box/box_introspection.rst:76
msgid "keys and values in the submodule."
msgstr ""

#: ../doc/book/box/box_introspection.rst:81
msgid "tarantool> box.info()\n"
"---\n"
"- server:\n"
"    lsn: 158\n"
"    ro: false\n"
"    uuid: a2684219-b2b1-4334-88ab-50b0722283fd\n"
"    id: 1\n"
"  version: 1.7.2-435-g6ba8500\n"
"  pid: 12932\n"
"  status: running\n"
"  vclock:\n"
"  - 158\n"
"  replication:\n"
"    status: off\n"
"  uptime: 908\n"
"...\n"
"tarantool> box.info.pid\n"
"---\n"
"- 12932\n"
"...\n"
"tarantool> box.info.status\n"
"---\n"
"- running\n"
"...\n"
"tarantool> box.info.uptime\n"
"---\n"
"- 1065\n"
"...\n"
"tarantool> box.info.version\n"
"---\n"
"- 1.7.2-435-g6ba8500\n"
"..."
msgstr ""

#: ../doc/book/box/box_introspection.rst:120
#: ../doc/book/box/box_slab.rst:5
msgid "Submodule `box.slab`"
msgstr ""

#: ../doc/book/box/box_introspection.rst:124
msgid "The ``box.slab`` submodule provides access to slab allocator statistics. The slab allocator is the main allocator used to store tuples. This can be used to monitor the total memory use and memory fragmentation."
msgstr ""

#: ../doc/book/box/box_introspection.rst:128
msgid "The display of slabs is broken down by the slab size -- 64-byte, 136-byte, and so on. The example omits the slabs which are empty. The example display is saying that: * there are 16 items stored in the 64-byte slab (and 16*64=102 so bytes_used = 1024); * there is 1 item stored in the 136-byte slab (and 136*1=136 so bytes_used = 136); * the ``arena_used`` value is the total of all the bytes_used values (1024+136 = 1160); * the ``arena_size`` value is the ``arena_used`` value plus the total of all the"
msgstr ""

#: ../doc/book/box/box_introspection.rst:135
msgid "bytes_free values (1160+4193200+4194088 = 8388448)."
msgstr ""

#: ../doc/book/box/box_introspection.rst:137
msgid "The ``arena_size`` and ``arena_used`` values are the amount of the % of :ref:`memtx_memory <cfg_storage-memtx_memory>` that is already distributed to the slab allocator."
msgstr ""

#: ../doc/book/box/box_introspection.rst:143
msgid "tarantool> box.slab.info().arena_used\n"
"---\n"
"- 4194304\n"
"...\n"
"tarantool> box.slab.info().arena_size\n"
"---\n"
"- 104857600\n"
"...\n"
"tarantool> box.slab.stats()\n"
"---\n"
"- - mem_free: 16248\n"
"    mem_used: 48\n"
"    item_count: 2\n"
"    item_size: 24\n"
"    slab_count: 1\n"
"    slab_size: 16384\n"
"  - mem_free: 15736\n"
"    mem_used: 560\n"
"    item_count: 14\n"
"    item_size: 40\n"
"    slab_count: 1\n"
"    slab_size: 16384\n"
"    <...>\n"
"...\n"
"tarantool> box.slab.stats()[1]\n"
"---\n"
"- mem_free: 15736\n"
"  mem_used: 560\n"
"  item_count: 14\n"
"  item_size: 40\n"
"  slab_count: 1\n"
"  slab_size: 16384\n"
"..."
msgstr ""

#: ../doc/book/box/box_introspection.rst:183
#: ../doc/book/box/box_stat.rst:5
msgid "Submodule `box.stat`"
msgstr ""

#: ../doc/book/box/box_introspection.rst:185
msgid "The ``box.stat`` submodule provides access to request and network statistics. Show the average number of requests per second, and the total number of requests since startup, broken down by request type. Also, show network activity statistics."
msgstr ""

#: ../doc/book/box/box_introspection.rst:190
msgid "tarantool> type(box.stat), type(box.stat.net) -- virtual tables\n"
"---\n"
"- table\n"
"- table\n"
"...\n"
"tarantool> box.stat, box.stat.net\n"
"---\n"
"- net: []\n"
"- []\n"
"...\n"
"tarantool> box.stat()\n"
"---\n"
"- DELETE:\n"
"    total: 1873949\n"
"    rps: 123\n"
"  SELECT:\n"
"    total: 1237723\n"
"    rps: 4099\n"
"  INSERT:\n"
"    total: 0\n"
"    rps: 0\n"
"  EVAL:\n"
"    total: 0\n"
"    rps: 0\n"
"  CALL:\n"
"    total: 0\n"
"    rps: 0\n"
"  REPLACE:\n"
"    total: 1239123\n"
"    rps: 7849\n"
"  UPSERT:\n"
"    total: 0\n"
"    rps: 0\n"
"  AUTH:\n"
"    total: 0\n"
"    rps: 0\n"
"  ERROR:\n"
"    total: 0\n"
"    rps: 0\n"
"  UPDATE:\n"
"    total: 0\n"
"    rps: 0\n"
"...\n"
"tarantool> box.stat().DELETE -- a selected item of the table\n"
"---\n"
"- total: 0\n"
"  rps: 0\n"
"...\n"
"tarantool> box.stat.net()\n"
"---\n"
"- SENT:\n"
"    total: 0\n"
"    rps: 0\n"
"  CONNECTIONS: 0\n"
"  RECEIVED:\n"
"    total: 0\n"
"    rps: 0\n"
"..."
msgstr ""

#: ../doc/book/box/box_schema.rst:5
msgid "Submodule `box.schema`"
msgstr ""

#: ../doc/book/box/box_schema.rst:13
msgid "The ``box.schema`` submodule has data-definition functions for spaces, users, roles, function tuples, and sequences."
msgstr ""

#: ../doc/book/box/box_schema.rst:20
msgid "Below is a list of all ``box.schema`` functions."
msgstr ""

#: ../doc/book/box/box_schema.rst:30
msgid ":ref:`box.schema.space.create() <box_schema-space_create>`"
msgstr ""

#: ../doc/book/box/box_schema.rst:30
msgid "Create a space"
msgstr ""

#: ../doc/book/box/box_schema.rst:33
msgid ":ref:`box.schema.user.create() <box_schema-user_create>`"
msgstr ""

#: ../doc/book/box/box_schema.rst:33
msgid "Create a user"
msgstr ""

#: ../doc/book/box/box_schema.rst:36
msgid ":ref:`box.schema.user.drop() <box_schema-user_drop>`"
msgstr ""

#: ../doc/book/box/box_schema.rst:36
msgid "Drop a user"
msgstr ""

#: ../doc/book/box/box_schema.rst:39
msgid ":ref:`box.schema.user.exists() <box_schema-user_exists>`"
msgstr ""

#: ../doc/book/box/box_schema.rst:39
msgid "Check if a user exists"
msgstr ""

#: ../doc/book/box/box_schema.rst:42
msgid ":ref:`box.schema.user.grant() <box_schema-user_grant>`"
msgstr ""

#: ../doc/book/box/box_schema.rst:42
msgid "Grant privileges to a user or a role"
msgstr ""

#: ../doc/book/box/box_schema.rst:45
msgid ":ref:`box.schema.user.revoke() <box_schema-user_revoke>`"
msgstr ""

#: ../doc/book/box/box_schema.rst:45
msgid "Revoke privileges from a user or a role"
msgstr ""

#: ../doc/book/box/box_schema.rst:48
msgid ":ref:`box.schema.user.password() <box_schema-user_password>`"
msgstr ""

#: ../doc/book/box/box_schema.rst:48
msgid "Get a hash of a user's password"
msgstr ""

#: ../doc/book/box/box_schema.rst:51
msgid ":ref:`box.schema.user.passwd() <box_schema-user_passwd>`"
msgstr ""

#: ../doc/book/box/box_schema.rst:51
msgid "Associate a password with a user"
msgstr ""

#: ../doc/book/box/box_schema.rst:54
msgid ":ref:`box.schema.user.info() <box_schema-user_info>`"
msgstr ""

#: ../doc/book/box/box_schema.rst:54
msgid "Get a description of a user's privileges"
msgstr ""

#: ../doc/book/box/box_schema.rst:57
msgid ":ref:`box.schema.role.create() <box_schema-role_create>`"
msgstr ""

#: ../doc/book/box/box_schema.rst:57
msgid "Create a role"
msgstr ""

#: ../doc/book/box/box_schema.rst:60
msgid ":ref:`box.schema.role.drop() <box_schema-role_drop>`"
msgstr ""

#: ../doc/book/box/box_schema.rst:60
msgid "Drop a role"
msgstr ""

#: ../doc/book/box/box_schema.rst:63
msgid ":ref:`box.schema.role.exists() <box_schema-role_exists>`"
msgstr ""

#: ../doc/book/box/box_schema.rst:63
msgid "Check if a role exists"
msgstr ""

#: ../doc/book/box/box_schema.rst:66
msgid ":ref:`box.schema.role.grant() <box_schema-role_grant>`"
msgstr ""

#: ../doc/book/box/box_schema.rst:66
msgid "Grant privileges to a role"
msgstr ""

#: ../doc/book/box/box_schema.rst:69
msgid ":ref:`box.schema.role.revoke() <box_schema-role_revoke>`"
msgstr ""

#: ../doc/book/box/box_schema.rst:69
msgid "Revoke privileges from a role"
msgstr ""

#: ../doc/book/box/box_schema.rst:72
msgid ":ref:`box.schema.role.info() <box_schema-role_info>`"
msgstr ""

#: ../doc/book/box/box_schema.rst:72
msgid "Get a description of a role's privileges"
msgstr ""

#: ../doc/book/box/box_schema.rst:75
msgid ":ref:`box.schema.func.create() <box_schema-func_create>`"
msgstr ""

#: ../doc/book/box/box_schema.rst:75
msgid "Create a function tuple"
msgstr ""

#: ../doc/book/box/box_schema.rst:78
msgid ":ref:`box.schema.func.drop() <box_schema-func_drop>`"
msgstr ""

#: ../doc/book/box/box_schema.rst:78
msgid "Drop a function tuple"
msgstr ""

#: ../doc/book/box/box_schema.rst:81
msgid ":ref:`box.schema.func.exists() <box_schema-func_exists>`"
msgstr ""

#: ../doc/book/box/box_schema.rst:81
msgid "Check if a function tuple exists"
msgstr ""

#: ../doc/book/box/box_schema.rst:84
msgid ":ref:`box.schema.sequence.create() <box_schema-sequence_create>`"
msgstr ""

#: ../doc/book/box/box_schema.rst:84
msgid "Create a new sequence generator"
msgstr ""

#: ../doc/book/box/box_schema.rst:87
msgid ":ref:`sequence_object:next() <box_schema-sequence_next>`"
msgstr ""

#: ../doc/book/box/box_schema.rst:87
msgid "Generate and return the next value"
msgstr ""

#: ../doc/book/box/box_schema.rst:90
msgid ":ref:`sequence_object:alter() <box_schema-sequence_alter>`"
msgstr ""

#: ../doc/book/box/box_schema.rst:90
msgid "Change sequence options"
msgstr ""

#: ../doc/book/box/box_schema.rst:93
msgid ":ref:`sequence_object:reset() <box_schema-sequence_reset>`"
msgstr ""

#: ../doc/book/box/box_schema.rst:93
msgid "Reset sequence state"
msgstr ""

#: ../doc/book/box/box_schema.rst:96
msgid ":ref:`sequence_object:set() <box_schema-sequence_set>`"
msgstr ""

#: ../doc/book/box/box_schema.rst:96
msgid "Set the new value"
msgstr ""

#: ../doc/book/box/box_schema.rst:99
msgid ":ref:`sequence_object:drop() <box_schema-sequence_drop>`"
msgstr ""

#: ../doc/book/box/box_schema.rst:99
msgid "Drop the sequence"
msgstr ""

#: ../doc/book/box/box_schema.rst:102
msgid ":ref:`space_object:create_index() <box_schema-sequence_create_index>`"
msgstr ""

#: ../doc/book/box/box_schema.rst:102
#: ../doc/book/box/box_space.rst:40
msgid "Create an index"
msgstr ""

#: ../doc/book/box/box_schema.rst:110
msgid "Create a :ref:`space <index-box_space>`."
msgstr ""

#: ../doc/book/box/box_schema.rst:112
msgid "name of space, which should conform to the :ref:`rules for object names <app_server-names>`"
msgstr ""

#: ../doc/book/box/box_schema.rst:114
msgid "see \"Options for box.schema.space.create\" chart, below"
msgstr ""

#: ../doc/book/box/box_schema.rst:116
msgid "space object"
msgstr ""

#: ../doc/book/box/box_schema.rst:117
msgid "userdata"
msgstr ""

#: ../doc/book/box/box_schema.rst:121
msgid "**Options for box.schema.space.create**"
msgstr ""

#: ../doc/book/box/box_schema.rst:131
#: ../doc/book/box/box_space.rst:284
#: ../doc/book/box/data_model.rst:513
msgid "Default"
msgstr ""

#: ../doc/book/box/box_schema.rst:133
msgid "engine"
msgstr ""

#: ../doc/book/box/box_schema.rst:133
msgid "'memtx' or 'vinyl'"
msgstr ""

#: ../doc/book/box/box_schema.rst:133
#: ../doc/book/box/box_schema.rst:173
#: ../doc/book/box/box_schema.rst:389
#: ../doc/book/box/box_session.rst:106
#: ../doc/book/box/box_session.rst:130
#: ../doc/book/box/box_session.rst:138
#: ../doc/book/box/box_space.rst:326
#: ../doc/book/box/data_model.rst:157
msgid "string"
msgstr ""

#: ../doc/book/box/box_schema.rst:133
msgid "'memtx'"
msgstr ""

#: ../doc/book/box/box_schema.rst:135
msgid "field_count"
msgstr ""

#: ../doc/book/box/box_schema.rst:135
msgid "fixed count of :ref:`fields <index-box_tuple>`: for example if field_count=5, it is illegal to insert a tuple with fewer than or more than 5 fields"
msgstr ""

#: ../doc/book/box/box_schema.rst:135
msgid "0 i.e. not fixed"
msgstr ""

#: ../doc/book/box/box_schema.rst:141
msgid "format"
msgstr ""

#: ../doc/book/box/box_schema.rst:141
msgid "field names and types: See the illustrations of format clauses in the :ref:`space_object:format() <box_space-format>` description and in the :ref:`box.space._space <box_space-space>` example. Optional and usually not specified."
msgstr ""

#: ../doc/book/box/box_schema.rst:141
msgid "(blank)"
msgstr ""

#: ../doc/book/box/box_schema.rst:148
#: ../doc/book/box/box_space.rst:292
msgid "id"
msgstr ""

#: ../doc/book/box/box_schema.rst:148
msgid "unique identifier: users can refer to spaces with the id instead of the name"
msgstr ""

#: ../doc/book/box/box_schema.rst:148
msgid "last space's id, +1"
msgstr ""

#: ../doc/book/box/box_schema.rst:152
#: ../doc/book/box/box_space.rst:296
msgid "if_not_exists"
msgstr ""

#: ../doc/book/box/box_schema.rst:152
msgid "create space only if a space with the same name does not exist already, otherwise do nothing but do not cause an error"
msgstr ""

#: ../doc/book/box/box_schema.rst:152
#: ../doc/book/box/box_schema.rst:158
#: ../doc/book/box/box_schema.rst:165
#: ../doc/book/box/data_model.rst:525
#: ../doc/book/box/data_model.rst:535
msgid "false"
msgstr ""

#: ../doc/book/box/box_schema.rst:158
msgid "is_local"
msgstr ""

#: ../doc/book/box/box_schema.rst:158
msgid "space contents are :ref:`replication-local <replication-local>`: changes are stored in the :ref:`write-ahead log <internals-wal>` of the local node but there is no :ref:`replication <replication>`."
msgstr ""

#: ../doc/book/box/box_schema.rst:165
msgid "temporary"
msgstr ""

#: ../doc/book/box/box_schema.rst:165
msgid "space contents are temporary: changes are not stored in the :ref:`write-ahead log <internals-wal>` and there is no :ref:`replication <replication>`. Note re storage engine: vinyl does not support temporary spaces."
msgstr ""

#: ../doc/book/box/box_schema.rst:173
#: ../doc/book/box/box_space.rst:2268
#: ../doc/book/box/box_space.rst:2271
msgid "user"
msgstr ""

#: ../doc/book/box/box_schema.rst:173
msgid "name of the user who is considered to be the space's :ref:`owner <authentication-owners_privileges>` for authorization purposes"
msgstr ""

#: ../doc/book/box/box_schema.rst:173
msgid "current user's name"
msgstr ""

#: ../doc/book/box/box_schema.rst:179
msgid "There are three :ref:`syntax variations <app_server-object_reference>` for object references targeting space objects, for example :samp:`box.schema.space.drop({space-id})` will drop a space. However, the common approach is to use functions attached to the space objects, for example :ref:`space_object:drop() <box_space-drop>`."
msgstr ""

#: ../doc/book/box/box_schema.rst:188
msgid "tarantool> s = box.schema.space.create('space55')\n"
"---\n"
"...\n"
"tarantool> s = box.schema.space.create('space55', {\n"
"         >   id = 555,\n"
"         >   temporary = false\n"
"         > })\n"
"---\n"
"- error: Space 'space55' already exists\n"
"...\n"
"tarantool> s = box.schema.space.create('space55', {\n"
"         >   if_not_exists = true\n"
"         > })\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/box/box_schema.rst:206
msgid "After a space is created, usually the next step is to :ref:`create an index <box_space-create_index>` for it, and then it is available for insert, select, and all the other :ref:`box.space <box_space>` functions."
msgstr ""

#: ../doc/book/box/box_schema.rst:215
msgid "Create a user. For explanation of how Tarantool maintains user data, see section :ref:`Users<authentication-users>` and reference on :ref:`_user <box_space-user>` space."
msgstr ""

#: ../doc/book/box/box_schema.rst:220
#: ../doc/book/box/box_schema.rst:312
#: ../doc/book/box/box_schema.rst:593
#: ../doc/book/box/box_schema.rst:640
msgid "The possible options are:"
msgstr ""

#: ../doc/book/box/box_schema.rst:222
msgid "``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` means there should be no error if the user already exists,"
msgstr ""

#: ../doc/book/box/box_schema.rst:225
msgid "``password`` (default = '') - string; the ``password`` = *password* specification is good because in a :ref:`URI <index-uri>` (Uniform Resource Identifier) it is usually illegal to include a user-name without a password."
msgstr ""

#: ../doc/book/box/box_schema.rst:232
#: ../doc/book/box/box_space.rst:2358
msgid "The maximum number of users is 32."
msgstr ""

#: ../doc/book/box/box_schema.rst:234
msgid "name of user, which should conform to the :ref:`rules for object names <app_server-names>`"
msgstr ""

#: ../doc/book/box/box_schema.rst:236
msgid "``if_not_exists``, ``password``"
msgstr ""

#: ../doc/book/box/box_schema.rst:240
#: ../doc/book/box/box_schema.rst:261
#: ../doc/book/box/data_model.rst:664
msgid "**Examples:**"
msgstr ""

#: ../doc/book/box/box_schema.rst:242
msgid "box.schema.user.create('Lena')\n"
"box.schema.user.create('Lena', {password = 'X'})\n"
"box.schema.user.create('Lena', {if_not_exists = false})"
msgstr ""

#: ../doc/book/box/box_schema.rst:252
msgid "Drop a user. For explanation of how Tarantool maintains user data, see section :ref:`Users <authentication-users>` and reference on :ref:`_user <box_space-user>` space."
msgstr ""

#: ../doc/book/box/box_schema.rst:257
#: ../doc/book/box/box_schema.rst:277
msgid "the name of the user"
msgstr ""

#: ../doc/book/box/box_schema.rst:258
msgid "``if_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` means there should be no error if the user does not exist."
msgstr ""

#: ../doc/book/box/box_schema.rst:263
msgid "box.schema.user.drop('Lena')\n"
"box.schema.user.drop('Lena',{if_exists=false})"
msgstr ""

#: ../doc/book/box/box_schema.rst:272
msgid "Return ``true`` if a user exists; return ``false`` if a user does not exist. For explanation of how Tarantool maintains user data, see section :ref:`Users <authentication-users>` and reference on :ref:`_user <box_space-user>` space."
msgstr ""

#: ../doc/book/box/box_schema.rst:278
#: ../doc/book/box/box_schema.rst:490
#: ../doc/book/box/box_schema.rst:770
msgid "bool"
msgstr ""

#: ../doc/book/box/box_schema.rst:282
msgid "box.schema.user.exists('Lena')"
msgstr ""

#: ../doc/book/box/box_schema.rst:292
msgid "Grant :ref:`privileges <authentication-owners_privileges>` to a user or to another role."
msgstr ""

#: ../doc/book/box/box_schema.rst:295
#: ../doc/book/box/box_schema.rst:337
msgid "the name of the user."
msgstr ""

#: ../doc/book/box/box_schema.rst:296
#: ../doc/book/box/box_schema.rst:338
#: ../doc/book/box/box_schema.rst:507
#: ../doc/book/box/box_schema.rst:540
msgid "'read' or 'write' or 'execute' or 'create' or 'alter' or 'drop' or a combination."
msgstr ""

#: ../doc/book/box/box_schema.rst:298
#: ../doc/book/box/box_schema.rst:509
#: ../doc/book/box/box_schema.rst:542
msgid "'space' or 'function' or 'sequence' or 'role'."
msgstr ""

#: ../doc/book/box/box_schema.rst:299
msgid "name of object to grant permissions for."
msgstr ""

#: ../doc/book/box/box_schema.rst:300
msgid "name of role to grant to user."
msgstr ""

#: ../doc/book/box/box_schema.rst:301
msgid "``grantor``, ``if_not_exists``."
msgstr ""

#: ../doc/book/box/box_schema.rst:303
msgid "If :samp:`'function','{object-name}'` is specified, then a _func tuple with that object-name must exist."
msgstr ""

#: ../doc/book/box/box_schema.rst:306
#: ../doc/book/box/box_schema.rst:517
msgid "**Variation:** instead of ``object-type, object-name`` say 'universe' which means 'all object-types and all objects'. In this case, object name is omitted."
msgstr ""

#: ../doc/book/box/box_schema.rst:309
#: ../doc/book/box/box_schema.rst:349
msgid "**Variation:** instead of ``privilege, object-type, object-name`` say ``role-name`` (see section :ref:`Roles <authentication-roles>`)."
msgstr ""

#: ../doc/book/box/box_schema.rst:314
msgid "``grantor`` = *grantor_name_or_id* -- string or number, for custom grantor,"
msgstr ""

#: ../doc/book/box/box_schema.rst:315
msgid "``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` means there should be no error if the user already has the privilege."
msgstr ""

#: ../doc/book/box/box_schema.rst:320
msgid "box.schema.user.grant('Lena', 'read', 'space', 'tester')\n"
"box.schema.user.grant('Lena', 'execute', 'function', 'f')\n"
"box.schema.user.grant('Lena', 'read,write', 'universe')\n"
"box.schema.user.grant('Lena', 'Accountant')\n"
"box.schema.user.grant('Lena', 'read,write,execute', 'universe')\n"
"box.schema.user.grant('X', 'read', 'universe', nil, {if_not_exists=true}))"
msgstr ""

#: ../doc/book/box/box_schema.rst:334
msgid "Revoke :ref:`privileges <authentication-owners_privileges>` from a user or from another role."
msgstr ""

#: ../doc/book/box/box_schema.rst:340
msgid "'space' or 'function' or 'sequence'."
msgstr ""

#: ../doc/book/box/box_schema.rst:341
msgid "the name of a function or space or sequence."
msgstr ""

#: ../doc/book/box/box_schema.rst:343
msgid "The user must exist, and the object must exist, but it is not an error if the user does not have the privilege."
msgstr ""

#: ../doc/book/box/box_schema.rst:346
#: ../doc/book/box/box_schema.rst:548
msgid "**Variation:** instead of ``object-type, object-name`` say 'universe' which means 'all object-types and all objects'."
msgstr ""

#: ../doc/book/box/box_schema.rst:354
msgid "box.schema.user.revoke('Lena', 'read', 'space', 'tester')\n"
"box.schema.user.revoke('Lena', 'execute', 'function', 'f')\n"
"box.schema.user.revoke('Lena', 'read,write', 'universe')\n"
"box.schema.user.revoke('Lena', 'Accountant')"
msgstr ""

#: ../doc/book/box/box_schema.rst:365
msgid "Return a hash of a user's password. For explanation of how Tarantool maintains passwords, see section :ref:`Passwords <authentication-passwords>` and reference on :ref:`_user <box_space-user>` space."
msgstr ""

#: ../doc/book/box/box_schema.rst:371
msgid "If a non-'guest' user has no password, it’s **impossible** to connect to Tarantool using this user. The user is regarded as “internal” only, not usable from a remote connection. Such users can be useful if they have defined some procedures with the :ref:`SETUID <box_schema-func_create>` option, on which privileges are granted to externally-connectable users. This way, external users cannot create/drop objects, they can only invoke procedures."
msgstr ""

#: ../doc/book/box/box_schema.rst:378
msgid "For the 'guest' user, it’s impossible to set a password: that would be misleading, since 'guest' is the default user on a newly-established connection over a :ref:`binary port <admin-security>`, and Tarantool does not require a password to establish a :ref:`binary connection <box_protocol-iproto_protocol>`. It is, however, possible to change the current user to ‘guest’ by providing the :ref:`AUTH packet <box_protocol-authentication>` with no password at all or an empty password. This feature is useful for connection pools, which want to reuse a connection for a different user without re-establishing it."
msgstr ""

#: ../doc/book/box/box_schema.rst:388
msgid "password to be hashed"
msgstr ""

#: ../doc/book/box/box_schema.rst:393
msgid "box.schema.user.password('ЛЕНА')"
msgstr ""

#: ../doc/book/box/box_schema.rst:401
msgid "Associate a password with the user who is currently logged in, or with the user specified by user-name. The user must exist and must not be 'guest'."
msgstr ""

#: ../doc/book/box/box_schema.rst:404
msgid "Users who wish to change their own passwords should use ``box.schema.user.passwd(password)`` syntax."
msgstr ""

#: ../doc/book/box/box_schema.rst:407
msgid "Administrators who wish to change passwords of other users should use ``box.schema.user.passwd(user-name, password)`` syntax."
msgstr ""

#: ../doc/book/box/box_schema.rst:410
msgid "user-name"
msgstr ""

#: ../doc/book/box/box_schema.rst:411
msgid "password"
msgstr ""

#: ../doc/book/box/box_schema.rst:415
msgid "box.schema.user.passwd('ЛЕНА')\n"
"box.schema.user.passwd('Lena', 'ЛЕНА')"
msgstr ""

#: ../doc/book/box/box_schema.rst:424
msgid "Return a description of a user's :ref:`privileges <authentication-owners_privileges>`."
msgstr ""

#: ../doc/book/box/box_schema.rst:446
msgid "Create a role. For explanation of how Tarantool maintains role data, see section :ref:`Roles <authentication-roles>`."
msgstr ""

#: ../doc/book/box/box_schema.rst:450
msgid "name of role, which should conform to the :ref:`rules for object names <app_server-names>`"
msgstr ""

#: ../doc/book/box/box_schema.rst:452
msgid "``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` means there should be no error if the role already exists"
msgstr ""

#: ../doc/book/box/box_schema.rst:460
msgid "box.schema.role.create('Accountant')\n"
"box.schema.role.create('Accountant', {if_not_exists = false})"
msgstr ""

#: ../doc/book/box/box_schema.rst:469
msgid "Drop a role. For explanation of how Tarantool maintains role data, see section :ref:`Roles <authentication-roles>`."
msgstr ""

#: ../doc/book/box/box_schema.rst:473
#: ../doc/book/box/box_schema.rst:489
msgid "the name of the role"
msgstr ""

#: ../doc/book/box/box_schema.rst:474
msgid "``if_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` means there should be no error if the role does not exist."
msgstr ""

#: ../doc/book/box/box_schema.rst:479
msgid "box.schema.role.drop('Accountant')"
msgstr ""

#: ../doc/book/box/box_schema.rst:487
msgid "Return ``true`` if a role exists; return ``false`` if a role does not exist."
msgstr ""

#: ../doc/book/box/box_schema.rst:494
msgid "box.schema.role.exists('Accountant')"
msgstr ""

#: ../doc/book/box/box_schema.rst:504
msgid "Grant :ref:`privileges <authentication-owners_privileges>` to a role."
msgstr ""

#: ../doc/book/box/box_schema.rst:506
#: ../doc/book/box/box_schema.rst:539
#: ../doc/book/box/box_schema.rst:569
msgid "the name of the role."
msgstr ""

#: ../doc/book/box/box_schema.rst:510
#: ../doc/book/box/box_schema.rst:543
msgid "the name of a function or space or sequence or role."
msgstr ""

#: ../doc/book/box/box_schema.rst:511
msgid "``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` means there should be no error if the role already has the privilege."
msgstr ""

#: ../doc/book/box/box_schema.rst:515
msgid "The role must exist, and the object must exist."
msgstr ""

#: ../doc/book/box/box_schema.rst:520
msgid "**Variation:** instead of ``privilege, object-type, object-name`` say ``role-name`` -- to grant a role to a role."
msgstr ""

#: ../doc/book/box/box_schema.rst:525
msgid "box.schema.role.grant('Accountant', 'read', 'space', 'tester')\n"
"box.schema.role.grant('Accountant', 'execute', 'function', 'f')\n"
"box.schema.role.grant('Accountant', 'read,write', 'universe')\n"
"box.schema.role.grant('public', 'Accountant')\n"
"box.schema.role.grant('role1', 'role2', nil, nil, {if_not_exists=false})"
msgstr ""

#: ../doc/book/box/box_schema.rst:537
msgid "Revoke :ref:`privileges <authentication-owners_privileges>` from a role."
msgstr ""

#: ../doc/book/box/box_schema.rst:545
msgid "The role must exist, and the object must exist, but it is not an error if the role does not have the privilege."
msgstr ""

#: ../doc/book/box/box_schema.rst:551
msgid "**Variation:** instead of ``privilege, object-type, object-name`` say ``role-name``."
msgstr ""

#: ../doc/book/box/box_schema.rst:556
msgid "box.schema.role.revoke('Accountant', 'read', 'space', 'tester')\n"
"box.schema.role.revoke('Accountant', 'execute', 'function', 'f')\n"
"box.schema.role.revoke('Accountant', 'read,write', 'universe')\n"
"box.schema.role.revoke('public', 'Accountant')"
msgstr ""

#: ../doc/book/box/box_schema.rst:567
msgid "Return a description of a role's privileges."
msgstr ""

#: ../doc/book/box/box_schema.rst:573
msgid "box.schema.role.info('Accountant')"
msgstr ""

#: ../doc/book/box/box_schema.rst:581
msgid "Create a function :ref:`tuple <index-box_tuple>`. without including the ``body`` option. (For functions created without the ``body`` option, see :ref:`box.schema.func.create(func-name [, {options-with-body}]) <box_schema-func_create_with-body>`."
msgstr ""

#: ../doc/book/box/box_schema.rst:586
msgid "This is called a \"not persistent\" function because functions without bodies are not persistent. This does not create the function itself -- that is done with Lua -- but if it is necessary to grant privileges for a function, box.schema.func.create must be done first. For explanation of how Tarantool maintains function data, see the reference for the :ref:`box.space._func <box_space-func>` space."
msgstr ""

#: ../doc/book/box/box_schema.rst:595
msgid "``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` means there should be no error if the ``_func`` tuple already exists."
msgstr ""

#: ../doc/book/box/box_schema.rst:598
msgid "``setuid`` = ``true|false`` (default = ``false``) - boolean; ``true`` means that Tarantool should treat the function’s caller as the function’s owner, with owner privileges. ``setuid`` works only over :ref:`binary ports <admin-security>`, ``setuid`` does not work if the function is invoked via an :ref:`admin console <admin-security>` or inside a Lua script."
msgstr ""

#: ../doc/book/box/box_schema.rst:605
msgid "``language`` = 'LUA'|'C' (default = ‘LUA’) - string."
msgstr ""

#: ../doc/book/box/box_schema.rst:607
#: ../doc/book/box/box_schema.rst:661
msgid "name of function, which should conform to the :ref:`rules for object names <app_server-names>`"
msgstr ""

#: ../doc/book/box/box_schema.rst:609
msgid "``if_not_exists``, ``setuid``, ``language``."
msgstr ""

#: ../doc/book/box/box_schema.rst:613
msgid "These functions can be called with :samp:`{function-object}:call({arguments})`; however, unlike the case with ordinary functions, array arguments will not be correctly recognized unless they are enclosed in braces."
msgstr ""

#: ../doc/book/box/box_schema.rst:619
msgid "box.schema.func.create('calculate')\n"
"box.schema.func.create('calculate', {if_not_exists = false})\n"
"box.schema.func.create('calculate', {setuid = false})\n"
"box.schema.func.create('calculate', {language = 'LUA'})"
msgstr ""

#: ../doc/book/box/box_schema.rst:630
msgid "Create a function :ref:`tuple <index-box_tuple>`. including the ``body`` option. (For functions created without the ``body`` option, see :ref:`box.schema.func.create(func-name [, {options-without-body}]) <box_schema-func_create>`."
msgstr ""

#: ../doc/book/box/box_schema.rst:635
msgid "This is called a \"persistent\" function because only functions with bodies are persistent. This does create the function itself, the body is a function definition. For explanation of how Tarantool maintains function data, see the reference for the :ref:`box.space._func <box_space-func>` space."
msgstr ""

#: ../doc/book/box/box_schema.rst:642
msgid "``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; same as for :ref:`box.schema.func.create(func-name [, {options-without-body}]) <box_schema-func_create>`."
msgstr ""

#: ../doc/book/box/box_schema.rst:645
msgid "``setuid`` = ``true|false`` (default = ``false``) - boolean; same as for :ref:`box.schema.func.create(func-name [, {options-without-body}]) <box_schema-func_create>`."
msgstr ""

#: ../doc/book/box/box_schema.rst:648
msgid "``language`` = 'LUA'|'C' (default = ‘LUA’) - string. same as for :ref:`box.schema.func.create(func-name [, {options-without-body}]) <box_schema-func_create>`."
msgstr ""

#: ../doc/book/box/box_schema.rst:651
msgid "``is_sandboxed`` = ``true|false`` (default = ``false``) - boolean; whether the function should be executed in a sandbox."
msgstr ""

#: ../doc/book/box/box_schema.rst:654
msgid "``is_deterministic`` = ``true|false`` (default = ``false``) - boolean; ``true`` means that the function should be deterministic, ``false`` means that the function may or may not be deterministic."
msgstr ""

#: ../doc/book/box/box_schema.rst:658
msgid "``body`` = function definition (default = nil) - string; the function definition."
msgstr ""

#: ../doc/book/box/box_schema.rst:663
msgid "``if_not_exists``, ``setuid``, ``language``, ``is_sandboxed``, ``is_deterministic``, ``body``."
msgstr ""

#: ../doc/book/box/box_schema.rst:667
msgid "C functions are imported from .so files, Lua functions can be defined within ``body``. We will only describe Lua functions in this section."
msgstr ""

#: ../doc/book/box/box_schema.rst:670
msgid "A function tuple with a body is \"persistent\" because the tuple is stored in a snapshot and is recoverable if the server restarts. All of the option values described in this section are visible in the :ref:`box.space._func <box_space-func>` system space."
msgstr ""

#: ../doc/book/box/box_schema.rst:675
msgid "If ``is_sandboxed`` is true, then the function will be executed in an isolated environment: any operation that accesses the world outside the sandbox will be forbidden or will have no effect. Therefore a sandboxed function can only use modules and functions which cannot affect isolation: `assert <https://www.lua.org/manual/5.1/manual.html#pdf-assert>`_ `error <://www.lua.org/manual/5.1/manual.html#pdf-error>`_ `ipairs <https://www.lua.org/manual/5.1/manual.html#pdf-ipairs>`_ `math.* <https://www.lua.org/manual/5.1/manual.html#5.6>`_ `next <https://www.lua.org/manual/5.1/manual.html#pdf-next>`_ `pairs <https://www.lua.org/manual/5.1/manual.html#pdf-pairs>`_ `pcall <https://www.lua.org/manual/5.1/manual.html#pdf-pcall>`_ `print <https://www.lua.org/manual/5.1/manual.html#pdf-print>`_ `select <https://www.lua.org/manual/5.1/manual.html#pdf-select>`_ `string.* <https://www.lua.org/manual/5.1/manual.html#5.4>`_ `table.* <https://www.lua.org/manual/5.1/manual.html#5.5>`_ `tonumber <https://www.lua.org/manual/5.1/manual.html#pdf-tonumber>`_ `tostring <https://www.lua.org/manual/5.1/manual.html#pdf-tostring>`_ `type <https://www.lua.org/manual/5.1/manual.html#pdf-type>`_ `unpack <https://www.lua.org/manual/5.1/manual.html#pdf-unpack>`_ :ref:`utf8.* <utf8-module>` `xpcall <https://www.lua.org/manual/5.1/manual.html#pdf-xpcall>`_. Also a sandboxed function cannot refer to global variables -- they will be treated as local variables because the sandbox is established with `setfenv <https://www.lua.org/manual/5.1/manual.html#pdf-setfenv>`_. So a sandboxed function will happen to be stateless and deterministic."
msgstr ""

#: ../doc/book/box/box_schema.rst:702
msgid "If ``is_deterministic`` is true, there is no immediate effect. Tarantool plans to use the is_deterministic value in a future version. A function is deterministic if it always returns the same outputs given the same inputs. It is the function creator's responsibility to ensure that a function is truly deterministic."
msgstr ""

#: ../doc/book/box/box_schema.rst:708
msgid "**Using a persistent Lua function**"
msgstr ""

#: ../doc/book/box/box_schema.rst:710
msgid "After a persistent Lua function is created, it can be found in the :ref:`box.space._func <box_space-func>` system space, and it can be shown with |br| :samp:`box.func.{func-name}` |br| and it can be invoked by any user with :ref:`authorization <authentication-owners_privileges>` to 'execute' it. The syntax for invoking is: |br| :samp:`box.func.{func-name}:call([parameters])` |br| or, if the connection is remote, the syntax is as in :ref:`net_box:call() <net_box-call>`."
msgstr ""

#: ../doc/book/box/box_schema.rst:723
msgid "tarantool> lua_code = [[function(a, b) return a + b end]]\n"
"tarantool> box.schema.func.create('sum', {body = lua_code})\n"
"\n"
"tarantool> box.func.sum\n"
"---\n"
"- is_sandboxed: false\n"
"  is_deterministic: false\n"
"  id: 2\n"
"  setuid: false\n"
"  body: function(a, b) return a + b end\n"
"  name: sum\n"
"  language: LUA\n"
"...\n"
"\n"
"tarantool> box.func.sum.call({1, 2})\n"
"---\n"
"- 3\n"
"..."
msgstr ""

#: ../doc/book/box/box_schema.rst:748
msgid "Drop a function tuple. For explanation of how Tarantool maintains function data, see reference on :ref:`_func space <box_space-func>`."
msgstr ""

#: ../doc/book/box/box_schema.rst:752
#: ../doc/book/box/box_schema.rst:769
msgid "the name of the function"
msgstr ""

#: ../doc/book/box/box_schema.rst:753
msgid "``if_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` means there should be no error if the _func tuple does not exist."
msgstr ""

#: ../doc/book/box/box_schema.rst:758
msgid "box.schema.func.drop('calculate')"
msgstr ""

#: ../doc/book/box/box_schema.rst:766
msgid "Return true if a function tuple exists; return false if a function tuple does not exist."
msgstr ""

#: ../doc/book/box/box_schema.rst:774
msgid "box.schema.func.exists('calculate')"
msgstr ""

#: ../doc/book/box/box_schema.rst:782
msgid "Reload a C module with all its functions without restarting the server."
msgstr ""

#: ../doc/book/box/box_schema.rst:784
msgid "Under the hood, Tarantool loads a new copy of the module (``*.so`` shared library) and starts routing all new request to the new version. The previous version remains active until all started calls are finished. All shared libraries are loaded with ``RTLD_LOCAL`` (see \"man 3 dlopen\"), therefore multiple copies can co-exist without any problems."
msgstr ""

#: ../doc/book/box/box_schema.rst:792
msgid "Reload will fail if a module was loaded from Lua script with `ffi.load() <http://luajit.org/ext_ffi_api.html#ffi_load>`_."
msgstr ""

#: ../doc/book/box/box_schema.rst:795
msgid "the name of the module to reload"
msgstr ""

#: ../doc/book/box/box_schema.rst:799
msgid "-- reload the entire module contents\n"
"box.schema.func.reload('module')"
msgstr ""

#: ../doc/book/box/box_schema.rst:808
#: ../doc/book/box/data_model.rst:486
msgid "Sequences"
msgstr ""

#: ../doc/book/box/box_schema.rst:810
msgid "An introduction to sequences is in the :ref:`Sequences <index-box_sequence>` section of the \"Data model\" chapter. Here are the details for each function and option."
msgstr ""

#: ../doc/book/box/box_schema.rst:814
msgid "All functions related to sequences require appropriate :ref:`privileges <authentication-owners_privileges>`."
msgstr ""

#: ../doc/book/box/box_schema.rst:821
msgid "Create a new sequence generator."
msgstr ""

#: ../doc/book/box/box_schema.rst:823
msgid "the name of the sequence"
msgstr ""

#: ../doc/book/box/box_schema.rst:825
msgid "see a quick overview in the \"Options for ``box.schema.sequence.create()``\" :ref:`chart <index-box_sequence-options>` (in the :ref:`Sequences <index-box_sequence>` section of the \"Data model\" chapter), and see more details below."
msgstr ""

#: ../doc/book/box/box_schema.rst:832
msgid "a reference to a new sequence object."
msgstr ""

#: ../doc/book/box/box_schema.rst:834
msgid "Options:"
msgstr ""

#: ../doc/book/box/box_schema.rst:836
msgid "``start`` -- the STARTS WITH value. Type = integer, Default = 1."
msgstr ""

#: ../doc/book/box/box_schema.rst:838
msgid "``min`` -- the MINIMUM value. Type = integer, Default = 1."
msgstr ""

#: ../doc/book/box/box_schema.rst:840
msgid "``max`` - the MAXIMUM value. Type = integer, Default = 9223372036854775807."
msgstr ""

#: ../doc/book/box/box_schema.rst:842
msgid "There is a rule: ``min`` <= ``start`` <= ``max``. For example it is illegal to say ``{start=0}`` because then the specified start value (0) would be less than the default min value (1)."
msgstr ""

#: ../doc/book/box/box_schema.rst:846
msgid "There is a rule: ``min`` <= next-value <= ``max``. For example, if the next generated value would be 1000, but the maximum value is 999, then that would be considered \"overflow\"."
msgstr ""

#: ../doc/book/box/box_schema.rst:851
msgid "There is a rule: ``start`` and ``min`` and ``max`` must all be <= 9223372036854775807 which is 2^63 - 1 (not 2^64)."
msgstr ""

#: ../doc/book/box/box_schema.rst:854
msgid "``cycle`` -- the CYCLE value. Type = bool. Default = false."
msgstr ""

#: ../doc/book/box/box_schema.rst:856
msgid "If the sequence generator's next value is an overflow number, it causes an error return -- unless ``cycle == true``."
msgstr ""

#: ../doc/book/box/box_schema.rst:859
msgid "But if ``cycle == true``, the count is started again, at the MINIMUM value or at the MAXIMUM value (not the STARTS WITH value)."
msgstr ""

#: ../doc/book/box/box_schema.rst:862
msgid "``cache`` -- the CACHE value. Type = unsigned integer. Default = 0."
msgstr ""

#: ../doc/book/box/box_schema.rst:864
msgid "Currently Tarantool ignores this value, it is reserved for future use."
msgstr ""

#: ../doc/book/box/box_schema.rst:866
msgid "``step`` -- the INCREMENT BY value. Type = integer. Default = 1."
msgstr ""

#: ../doc/book/box/box_schema.rst:868
msgid "Ordinarily this is what is added to the previous value."
msgstr ""

#: ../doc/book/box/box_schema.rst:874
msgid "Generate the next value and return it."
msgstr ""

#: ../doc/book/box/box_schema.rst:876
msgid "The generation algorithm is simple:"
msgstr ""

#: ../doc/book/box/box_schema.rst:878
msgid "If this is the first time, then return the STARTS WITH value."
msgstr ""

#: ../doc/book/box/box_schema.rst:879
msgid "If the previous value plus the INCREMENT value is less than the MINIMUM value or greater than the MAXIMUM value, that is \"overflow\", so either raise an error (if ``cycle`` = ``false``) or return the MAXIMUM value (if ``cycle`` = ``true`` and ``step`` < 0) or return the MINIMUM value (if ``cycle`` = ``true`` and ``step`` > 0)."
msgstr ""

#: ../doc/book/box/box_schema.rst:885
msgid "If there was no error, then save the returned result, it is now the \"previous value\"."
msgstr ""

#: ../doc/book/box/box_schema.rst:888
msgid "For example, suppose sequence 'S' has:"
msgstr ""

#: ../doc/book/box/box_schema.rst:890
msgid "``min`` == -6,"
msgstr ""

#: ../doc/book/box/box_schema.rst:891
msgid "``max`` == -1,"
msgstr ""

#: ../doc/book/box/box_schema.rst:892
msgid "``step`` == -3,"
msgstr ""

#: ../doc/book/box/box_schema.rst:893
msgid "``start`` = -2,"
msgstr ""

#: ../doc/book/box/box_schema.rst:894
msgid "``cycle`` = true,"
msgstr ""

#: ../doc/book/box/box_schema.rst:895
msgid "previous value = -2."
msgstr ""

#: ../doc/book/box/box_schema.rst:897
msgid "Then ``box.sequence.S:next()`` returns -5 because -2 + (-3) == -5."
msgstr ""

#: ../doc/book/box/box_schema.rst:899
msgid "Then ``box.sequence.S:next()`` again returns -1 because -5 + (-3) < -6, which is overflow, causing cycle, and ``max`` == -1."
msgstr ""

#: ../doc/book/box/box_schema.rst:902
msgid "This function requires a :ref:`'write' privilege <box_schema-user_grant>` on the sequence."
msgstr ""

#: ../doc/book/box/box_schema.rst:907
msgid "This function should not be used in \"cross-engine\" transactions (transactions which use both the memtx and the vinyl storage engines)."
msgstr ""

#: ../doc/book/box/box_schema.rst:910
msgid "To see what the previous value was, without changing it, you can select from the :ref:`_sequence_data <box_space-sequence_data>` system space."
msgstr ""

#: ../doc/book/box/box_schema.rst:918
msgid "The ``alter()`` function can be used to change any of the sequence's options. Requirements and restrictions are the same as for :ref:`box.schema.sequence.create() <box_schema-sequence_create>`."
msgstr ""

#: ../doc/book/box/box_schema.rst:926
msgid "Set the sequence back to its original state. The effect is that a subsequent ``next()`` will return the ``start`` value. This function requires a :ref:`'write' privilege <box_schema-user_grant>` on the sequence."
msgstr ""

#: ../doc/book/box/box_schema.rst:935
msgid "Set the \"previous value\" to ``new-previous-value``. This function requires a :ref:`'write' privilege <box_schema-user_grant>` on the sequence."
msgstr ""

#: ../doc/book/box/box_schema.rst:943
msgid "Drop an existing sequence."
msgstr ""

#: ../doc/book/box/box_schema.rst:947
msgid "Here is an example showing all sequence options and operations:"
msgstr ""

#: ../doc/book/box/box_schema.rst:949
msgid "s = box.schema.sequence.create(\n"
"               'S2',\n"
"               {start=100,\n"
"               min=100,\n"
"               max=tonumber64('9223372036854775807'),\n"
"               cache=100000,\n"
"               cycle=false,\n"
"               step=100\n"
"               })\n"
"s:alter({step=6})\n"
"s:next()\n"
"s:reset()\n"
"s:set(150)\n"
"s:drop()"
msgstr ""

#: ../doc/book/box/box_schema.rst:970
msgid "You can use the ``sequence`` option when :ref:`creating <box_space-create_index>` or :ref:`altering <box_index-alter>` a primary-key index. The sequence becomes associated with the index, so that the next ``insert()`` will put the next generated number into the primary-key field, if the field value would otherwise be nil."
msgstr ""

#: ../doc/book/box/box_schema.rst:977
msgid "The syntax may be any of: |br| :samp:`sequence = {sequence identifier}` |br| or :code:`sequence = {id =` :samp:`{sequence identifier}` :code:`}` |br| or :code:`sequence = {field =` :samp:`{field number}` :code:`}` |br| or :code:`sequence = {id =` :samp:`{sequence identifier}` :code:`, field =` :samp:`{field number}` :code:`}` |br| or :code:`sequence = true` |br| or :code:`sequence = {}`. |br| The sequence identifier may be either a number (the sequence id) or a string (the sequence name). The field number may be the ordinal number of any field in the index; default = 1. Examples of all possibilities: ``sequence = 1`` or ``sequence = 'sequence_name'`` or ``sequence = {id = 1}`` or ``sequence = {id = 'sequence_name'}`` or ``sequence = {id = 1, field = 1}`` or ``sequence = {id = 'sequence_name', field = 1}`` or ``sequence = {field = 1}`` or ``sequence = true`` or ``sequence = {}``. Notice that the sequence identifier can be omitted, if it is omitted then a new sequence is created automatically with default name = :samp:`{space-name}_seq`. Notice that the field number does not have to be 1, that is, the sequence can be associated with any field in the primary-key index."
msgstr ""

#: ../doc/book/box/box_schema.rst:1010
msgid "For example, if 'Q' is a sequence and 'T' is a new space, then this will work:"
msgstr ""

#: ../doc/book/box/box_schema.rst:1013
msgid "tarantool> box.space.T:create_index('Q',{sequence='Q'})\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: unsigned\n"
"    is_nullable: false\n"
"    fieldno: 1\n"
"  sequence_id: 8\n"
"  id: 0\n"
"  space_id: 514\n"
"  name: Q\n"
"  type: TREE\n"
"..."
msgstr ""

#: ../doc/book/box/box_schema.rst:1029
msgid "(Notice that the index now has a ``sequence_id`` field.)"
msgstr ""

#: ../doc/book/box/box_schema.rst:1031
msgid "And this will work:"
msgstr ""

#: ../doc/book/box/box_schema.rst:1033
msgid "tarantool> box.space.T:insert{nil,0}\n"
"---\n"
"- [1, 0]\n"
"..."
msgstr ""

#: ../doc/book/box/box_schema.rst:1042
msgid "The index key type may be either 'integer' or 'unsigned'. If any of the sequence options is a negative number, then the index key type should be 'integer'."
msgstr ""

#: ../doc/book/box/box_schema.rst:1046
msgid "Users should not insert a value greater than 9223372036854775807, which is 2^63 - 1, in the indexed field. The sequence generator will ignore it."
msgstr ""

#: ../doc/book/box/box_schema.rst:1050
msgid "A sequence cannot be dropped if it is associated with an index. However, :ref:`index_object:alter() <box_index-alter>` can be used to say that a sequence is not associated with an index, for example ``box.space.T.index.I:alter({sequence=false})``."
msgstr ""

#: ../doc/book/box/box_schema.rst:1056
msgid "If a sequence was created automatically because the sequence identifier was omitted, then it will be dropped automatically if the index is altered so that ``sequence=false``, or if the index is dropped."
msgstr ""

#: ../doc/book/box/box_schema.rst:1061
msgid "``index_object:alter()`` can also be used to associate a sequence with an existing index, with the same syntax for options."
msgstr ""

#: ../doc/book/box/box_schema.rst:1064
msgid "When a sequence is used with an index based on a JSON path, inserted tuples must have all components of the path preceding the autoincrement field, and the autoincrement field. To achieve that use ``box.NULL`` rather than ``nil``. Example:"
msgstr ""

#: ../doc/book/box/box_schema.rst:1069
msgid "s = box.schema.space.create('test')\n"
"s:create_index('pk', {parts = {{'[1].a.b[1]', 'unsigned'}}, sequence = true})\n"
"s:replace{} -- error\n"
"s:replace{{c = {}}} -- error\n"
"s:replace{{a = {c = {}}}} -- error\n"
"s:replace{{a = {b = {}}}} -- error\n"
"s:replace{{a = {b = {nil}}}} -- error\n"
"s:replace{{a = {b = {box.NULL}}}} -- ok"
msgstr ""

#: ../doc/book/box/box_session.rst:5
msgid "Submodule `box.session`"
msgstr ""

#: ../doc/book/box/box_session.rst:11
msgid "The ``box.session`` submodule allows querying the session state, writing to a session-specific temporary Lua table, or sending out-of-band messages, or setting up triggers which will fire when a session starts or ends."
msgstr ""

#: ../doc/book/box/box_session.rst:15
msgid "A *session* is an object associated with each client connection."
msgstr ""

#: ../doc/book/box/box_session.rst:21
msgid "Below is a list of all ``box.session`` functions and members."
msgstr ""

#: ../doc/book/box/box_session.rst:31
msgid ":ref:`box.session.id() <box_session-id>`"
msgstr ""

#: ../doc/book/box/box_session.rst:31
msgid "Get the current session's ID"
msgstr ""

#: ../doc/book/box/box_session.rst:34
msgid ":ref:`box.session.exists() <box_session-exists>`"
msgstr ""

#: ../doc/book/box/box_session.rst:34
msgid "Check if a session exists"
msgstr ""

#: ../doc/book/box/box_session.rst:37
msgid ":ref:`box.session.peer() <box_session-peer>`"
msgstr ""

#: ../doc/book/box/box_session.rst:37
msgid "Get the session peer's host address and port"
msgstr ""

#: ../doc/book/box/box_session.rst:40
msgid ":ref:`box.session.sync() <box_session-sync>`"
msgstr ""

#: ../doc/book/box/box_session.rst:40
msgid "Get the sync integer constant"
msgstr ""

#: ../doc/book/box/box_session.rst:43
msgid ":ref:`box.session.user() <box_session-user>`"
msgstr ""

#: ../doc/book/box/box_session.rst:43
msgid "Get the current user's name"
msgstr ""

#: ../doc/book/box/box_session.rst:46
msgid ":ref:`box.session.type() <box_session-type>`"
msgstr ""

#: ../doc/book/box/box_session.rst:46
msgid "Get the connection type or cause of action"
msgstr ""

#: ../doc/book/box/box_session.rst:49
msgid ":ref:`box.session.su() <box_session-su>`"
msgstr ""

#: ../doc/book/box/box_session.rst:49
msgid "Change the current user"
msgstr ""

#: ../doc/book/box/box_session.rst:52
msgid ":ref:`box.session.uid() <box_session-uid>`"
msgstr ""

#: ../doc/book/box/box_session.rst:52
msgid "Get the current user's ID"
msgstr ""

#: ../doc/book/box/box_session.rst:55
msgid ":ref:`box.session.euid() <box_session-euid>`"
msgstr ""

#: ../doc/book/box/box_session.rst:55
msgid "Get the current effective user's ID"
msgstr ""

#: ../doc/book/box/box_session.rst:58
msgid ":ref:`box.session.storage <box_session-storage>`"
msgstr ""

#: ../doc/book/box/box_session.rst:58
msgid "Table with session-specific names and values"
msgstr ""

#: ../doc/book/box/box_session.rst:61
msgid ":ref:`box.session.on_connect() <box_session-on_connect>`"
msgstr ""

#: ../doc/book/box/box_session.rst:61
msgid "Define a connect trigger"
msgstr ""

#: ../doc/book/box/box_session.rst:64
msgid ":ref:`box.session.on_disconnect() <box_session-on_disconnect>`"
msgstr ""

#: ../doc/book/box/box_session.rst:64
msgid "Define a disconnect trigger"
msgstr ""

#: ../doc/book/box/box_session.rst:67
msgid ":ref:`box.session.on_auth() <box_session-on_auth>`"
msgstr ""

#: ../doc/book/box/box_session.rst:67
msgid "Define an authentication trigger"
msgstr ""

#: ../doc/book/box/box_session.rst:70
msgid ":ref:`box.session.push() <box_session-push>`"
msgstr ""

#: ../doc/book/box/box_session.rst:70
msgid "Send an out-of-band message"
msgstr ""

#: ../doc/book/box/box_session.rst:80
msgid "the unique identifier (ID) for the current session. The result can be 0 or -1 meaning there is no session."
msgstr ""

#: ../doc/book/box/box_session.rst:88
msgid "1 if the session exists, 0 if the session does not exist."
msgstr ""

#: ../doc/book/box/box_session.rst:95
msgid "This function works only if there is a peer, that is, if a connection has been made to a separate Tarantool instance."
msgstr ""

#: ../doc/book/box/box_session.rst:98
msgid "The host address and port of the session peer, for example \"127.0.0.1:55457\". If the session exists but there is no connection to a separate instance, the return is null. The command is executed on the server instance, so the \"local name\" is the server instance's host and port, and the \"peer name\" is the client's host and port."
msgstr ""

#: ../doc/book/box/box_session.rst:108
msgid "Possible errors: 'session.peer(): session does not exist'"
msgstr ""

#: ../doc/book/box/box_session.rst:114
msgid "the value of the :code:`sync` integer constant used in the `binary protocol <https://github.com/tarantool/tarantool/blob/2.1/src/box/iproto_constants.h>`_. This value becomes invalid when the session is disconnected."
msgstr ""

#: ../doc/book/box/box_session.rst:120
msgid "This function is local for the request, i.e. not global for the session. If the connection behind the session is multiplexed, this function can be safely used inside the request processor."
msgstr ""

#: ../doc/book/box/box_session.rst:128
msgid "the name of the :ref:`current user <authentication-users>`"
msgstr ""

#: ../doc/book/box/box_session.rst:136
msgid "the type of connection or cause of action."
msgstr ""

#: ../doc/book/box/box_session.rst:140
msgid "Possible return values are:"
msgstr ""

#: ../doc/book/box/box_session.rst:142
msgid "'binary' if the connection was done via the binary protocol, for example to a target made with :ref:`box.cfg{listen=...} <cfg_basic-listen>`;"
msgstr ""

#: ../doc/book/box/box_session.rst:145
msgid "'console' if the connection was done via the administrative console, for example to a target made with :ref:`console.listen <console-listen>`;"
msgstr ""

#: ../doc/book/box/box_session.rst:148
msgid "'repl' if the connection was done directly, for example when :ref:`using Tarantool as a client <admin-using_tarantool_as_a_client>`;"
msgstr ""

#: ../doc/book/box/box_session.rst:150
msgid "'applier' if the action is due to :ref:`replication <replication>`, regardless of how the connection was done;"
msgstr ""

#: ../doc/book/box/box_session.rst:153
msgid "'background' if the action is in a :ref:`background fiber <fiber-module>`, regardless of whether the Tarantool server was :ref:`started in the background <cfg_basic-background>`."
msgstr ""

#: ../doc/book/box/box_session.rst:158
msgid "``box.session.type()`` is useful for an :ref:`on_replace() <box_space-on_replace>` trigger on a replica -- the value will be 'applier' if and only if the trigger was activated because of a request that was done on the master."
msgstr ""

#: ../doc/book/box/box_session.rst:168
msgid "Change Tarantool's :ref:`current user <authentication-users>` -- this is analogous to the Unix command ``su``."
msgstr ""

#: ../doc/book/box/box_session.rst:171
msgid "Or, if function-to-execute is specified, change Tarantool's :ref:`current user <authentication-users>` temporarily while executing the function -- this is analogous to the Unix command ``sudo``."
msgstr ""

#: ../doc/book/box/box_session.rst:176
msgid "name of a target user"
msgstr ""

#: ../doc/book/box/box_session.rst:177
msgid "name of a function, or definition of a function. Additional parameters may be passed to ``box.session.su``, they will be interpreted as parameters of function-to-execute."
msgstr ""

#: ../doc/book/box/box_session.rst:184
msgid "tarantool> function f(a) return box.session.user() .. a end\n"
"---\n"
"...\n"
"\n"
"tarantool> box.session.su('guest', f, '-xxx')\n"
"---\n"
"- guest-xxx\n"
"...\n"
"\n"
"tarantool> box.session.su('guest',function(...) return ... end,1,2)\n"
"---\n"
"- 1\n"
"- 2\n"
"..."
msgstr ""

#: ../doc/book/box/box_session.rst:205
msgid "the user ID of the :ref:`current user <authentication-users>`."
msgstr ""

#: ../doc/book/box/box_session.rst:209
msgid "Every user has a unique name (seen with :ref:`box.session.user() <box_session-user>`) and a unique ID (seen with ``box.session.uid()``). The values are stored together in the ``_user`` space."
msgstr ""

#: ../doc/book/box/box_session.rst:217
msgid "the effective user ID of the :ref:`current user <authentication-users>`."
msgstr ""

#: ../doc/book/box/box_session.rst:219
msgid "This is the same as :ref:`box.session.uid() <box_session-uid>`, except in two cases:"
msgstr ""

#: ../doc/book/box/box_session.rst:222
msgid "The first case: if the call to ``box.session.euid()`` is within a function invoked by :ref:`box.session.su(user-name, function-to-execute) <box_session-su>` -- in that case, ``box.session.euid()`` returns the ID of the changed user (the user who is specified by the ``user-name`` parameter of the ``su`` function)  but ``box.session.uid()`` returns the ID of the original user (the user who is calling the ``su`` function)."
msgstr ""

#: ../doc/book/box/box_session.rst:230
msgid "The second case: if the call to ``box.session.euid()`` is within a function specified with :ref:`box.schema.func.create(function-name, {setuid= true}) <box_schema-func_create>` and the binary protocol is in use -- in that case, ``box.session.euid()`` returns the ID of the user who created \"function-name\" but ``box.session.uid()`` returns the ID of the the user who is calling \"function-name\"."
msgstr ""

#: ../doc/book/box/box_session.rst:242
msgid "tarantool> box.session.su('admin')\n"
"---\n"
"...\n"
"tarantool> box.session.uid(), box.session.euid()\n"
"---\n"
"- 1\n"
"- 1\n"
"...\n"
"tarantool> function f() return {box.session.uid(),box.session.euid()} end\n"
"---\n"
"...\n"
"tarantool> box.session.su('guest', f)\n"
"---\n"
"- - 1\n"
"  - 0\n"
"..."
msgstr ""

#: ../doc/book/box/box_session.rst:265
msgid "A Lua table that can hold arbitrary unordered session-specific names and values, which will last until the session ends. For example, this table could be useful to store current tasks when working with a `Tarantool queue manager <https://github.com/tarantool/queue>`_."
msgstr ""

#: ../doc/book/box/box_session.rst:272
msgid "tarantool> box.session.peer(box.session.id())\n"
"---\n"
"- 127.0.0.1:45129\n"
"...\n"
"tarantool> box.session.storage.random_memorandum = \"Don't forget the eggs\"\n"
"---\n"
"...\n"
"tarantool> box.session.storage.radius_of_mars = 3396\n"
"---\n"
"...\n"
"tarantool> m = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in pairs(box.session.storage) do\n"
"         >   m = m .. k .. '='.. v .. ' '\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> m\n"
"---\n"
"- 'radius_of_mars=3396 random_memorandum=Don''t forget the eggs. '\n"
"..."
msgstr ""

#: ../doc/book/box/box_session.rst:301
msgid "Define a trigger for execution when a new session is created due to an event such as :ref:`console.connect <console-connect>`. The trigger function will be the first thing executed after a new session is created. If the trigger execution fails and raises an error, the error is sent to the client and the connection is closed."
msgstr ""

#: ../doc/book/box/box_session.rst:312
#: ../doc/book/box/box_session.rst:348
#: ../doc/book/box/box_session.rst:423
#: ../doc/book/box/box_space.rst:1116
#: ../doc/book/box/box_space.rst:1202
msgid "If both parameters are omitted, then the response is a list of existing trigger functions."
msgstr ""

#: ../doc/book/box/box_session.rst:318
msgid "tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_connect(f)"
msgstr ""

#: ../doc/book/box/box_session.rst:327
msgid "If a trigger always results in an error, it may become impossible to connect to a server to reset it."
msgstr ""

#: ../doc/book/box/box_session.rst:334
msgid "Define a trigger for execution after a client has disconnected. If the trigger function causes an error, the error is logged but otherwise is ignored. The trigger is invoked while the session associated with the client still exists and can access session properties, such as :ref:`box.session.id() <box_session-id>`."
msgstr ""

#: ../doc/book/box/box_session.rst:339
msgid "Since version 1.10, the trigger function is invoked immediately after the disconnect, even if requests that were made during the session have not finished."
msgstr ""

#: ../doc/book/box/box_session.rst:354
msgid "tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_disconnect(f)"
msgstr ""

#: ../doc/book/box/box_session.rst:363
msgid "After the following series of requests, a Tarantool instance will write a message using the :ref:`log <log-module>` module whenever any user connects or disconnects."
msgstr ""

#: ../doc/book/box/box_session.rst:366
msgid "function log_connect ()\n"
"  local log = require('log')\n"
"  local m = 'Connection. user=' .. box.session.user() .. ' id=' .. box.session.id()\n"
"  log.info(m)\n"
"end\n"
"\n"
"function log_disconnect ()\n"
"  local log = require('log')\n"
"  local m = 'Disconnection. user=' .. box.session.user() .. ' id=' .. box.session.id()\n"
"  log.info(m)\n"
"end\n"
"\n"
"box.session.on_connect(log_connect)\n"
"box.session.on_disconnect(log_disconnect)"
msgstr ""

#: ../doc/book/box/box_session.rst:383
msgid "Here is what might appear in the log file in a typical installation:"
msgstr ""

#: ../doc/book/box/box_session.rst:385
msgid "2014-12-15 13:21:34.444 [11360] main/103/iproto I>\n"
"    Connection. user=guest id=3\n"
"2014-12-15 13:22:19.289 [11360] main/103/iproto I>\n"
"    Disconnection. user=guest id=3"
msgstr ""

#: ../doc/book/box/box_session.rst:396
msgid "Define a trigger for execution during :ref:`authentication <authentication-users>`."
msgstr ""

#: ../doc/book/box/box_session.rst:398
msgid "The ``on_auth`` trigger function is invoked in these circumstances:"
msgstr ""

#: ../doc/book/box/box_session.rst:400
msgid "The :ref:`console.connect <console-connect>` function includes an authentication check for all users except 'guest'. For this case, the ``on_auth`` trigger function is invoked after the ``on_connect`` trigger function, if and only if the connection has succeeded so far."
msgstr ""

#: ../doc/book/box/box_session.rst:405
msgid "The :ref:`binary protocol <admin-security>` has a separate :ref:`authentication packet <box_protocol-authentication>`. For this case, connection and authentication are considered to be separate steps."
msgstr ""

#: ../doc/book/box/box_session.rst:409
msgid "Unlike other trigger types, ``on_auth`` trigger functions are invoked **before** the event. Therefore a trigger function like :code:`function auth_function () v = box.session.user(); end` will set :code:`v` to \"guest\", the user name before the authentication is done. To get the user name **after** the authentication is done, use the special syntax: :code:`function auth_function (user_name) v = user_name; end`"
msgstr ""

#: ../doc/book/box/box_session.rst:415
msgid "If the trigger fails by raising an error, the error is sent to the client and the connection is closed."
msgstr ""

#: ../doc/book/box/box_session.rst:427
msgid "**Example 1**"
msgstr ""

#: ../doc/book/box/box_session.rst:429
msgid "tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_auth(f)"
msgstr ""

#: ../doc/book/box/box_session.rst:436
msgid "**Example 2**"
msgstr ""

#: ../doc/book/box/box_session.rst:438
msgid "This is a more complex example, with two server instances."
msgstr ""

#: ../doc/book/box/box_session.rst:440
msgid "The first server instance listens on port 3301; its default user name is 'admin'. There are three ``on_auth`` triggers:"
msgstr ""

#: ../doc/book/box/box_session.rst:444
msgid "The first trigger has a function with no arguments, it can only look at ``box.session.user()``."
msgstr ""

#: ../doc/book/box/box_session.rst:446
msgid "The second trigger has a function with a ``user_name`` argument, it can look at both of: ``box.session.user()`` and ``user_name``."
msgstr ""

#: ../doc/book/box/box_session.rst:448
msgid "The third trigger has a function with a ``user_name`` argument and a ``status`` argument, it can look at all three of: ``box.session.user()`` and ``user_name`` and ``status``."
msgstr ""

#: ../doc/book/box/box_session.rst:453
msgid "The second server instance will connect with :ref:`console.connect <console-connect>`, and then will cause a display of the variables that were set by the trigger functions."
msgstr ""

#: ../doc/book/box/box_session.rst:458
msgid "-- On the first server instance, which listens on port 3301\n"
"box.cfg{listen=3301}\n"
"function function1()\n"
"  print('function 1, box.session.user()='..box.session.user())\n"
"  end\n"
"function function2(user_name)\n"
"  print('function 2, box.session.user()='..box.session.user())\n"
"  print('function 2, user_name='..user_name)\n"
"  end\n"
"function function3(user_name, status)\n"
"  print('function 3, box.session.user()='..box.session.user())\n"
"  print('function 3, user_name='..user_name)\n"
"  if status == true then\n"
"    print('function 3, status = true, authorization succeeded')\n"
"    end\n"
"  end\n"
"box.session.on_auth(function1)\n"
"box.session.on_auth(function2)\n"
"box.session.on_auth(function3)\n"
"box.schema.user.passwd('admin')"
msgstr ""

#: ../doc/book/box/box_session.rst:481
msgid "-- On the second server instance, that connects to port 3301\n"
"console = require('console')\n"
"console.connect('admin:admin@localhost:3301')"
msgstr ""

#: ../doc/book/box/box_session.rst:487
msgid "The result looks like this:"
msgstr ""

#: ../doc/book/box/box_session.rst:489
msgid "function 3, box.session.user()=guest\n"
"function 3, user_name=admin\n"
"function 3, status = true, authorization succeeded\n"
"function 2, box.session.user()=guest\n"
"function 2, user_name=admin\n"
"function 1, box.session.user()=guest"
msgstr ""

#: ../doc/book/box/box_session.rst:502
msgid "Generate an out-of-band message. By \"out-of-band\" we mean an extra message which supplements what is passed in a network via the usual channels. Although ``box.session.push()`` can be called at any time, in practice it is used with networks that are set up with :ref:`module net.box <net_box-module>`, and it is invoked by the server (on the \"remote database system\" to use our terminology for net.box), and the client has options for getting such messages."
msgstr ""

#: ../doc/book/box/box_session.rst:511
msgid "This function returns an error if the session is disconnected."
msgstr ""

#: ../doc/book/box/box_session.rst:513
msgid "what to send"
msgstr ""

#: ../doc/book/box/box_session.rst:514
msgid "an optional argument to indicate what the session is, as taken from an earlier call to :ref:`box_session:sync() <box_session-sync>`. If it is omitted, the default is the current ``box.session.sync()`` value."
msgstr ""

#: ../doc/book/box/box_session.rst:517
msgid "{nil, error} or true:"
msgstr ""

#: ../doc/book/box/box_session.rst:519
msgid "If the result is an error, then the first part of the return is ``nil`` and the second part is the error object."
msgstr ""

#: ../doc/book/box/box_session.rst:521
msgid "If the result is not an error, then the return is the boolean value ``true``."
msgstr ""

#: ../doc/book/box/box_session.rst:522
msgid "When the return is ``true``, the message has gone to the network buffer as a :ref:`packet <box_protocol-iproto_protocol>` with the code IPROTO_CHUNK (0x80)."
msgstr ""

#: ../doc/book/box/box_session.rst:526
msgid "The server's sole job is to call ``box.session.push()``, there is no automatic mechanism for showing that the message was received."
msgstr ""

#: ../doc/book/box/box_session.rst:529
msgid "The client's job is to check for such messages after it sends something to the server. The major client methods -- :ref:`conn:call <net_box-call>`, :ref:`conn:eval <net_box-eval>`, :ref:`conn:select <conn-select>`, :ref:`conn:insert <conn-insert>`, :ref:`conn:replace <conn-replace>`, :ref:`conn:update <conn-update>`, :ref:`conn:upsert <conn-upsert>`, :ref:`delete <conn-delete>` -- may cause the server to send a message."
msgstr ""

#: ../doc/book/box/box_session.rst:537
msgid "Situation 1: when the client calls synchronously with the default ``{async=false}`` option. There are two optional additional options: :samp:`on_push={function-name}`, and :samp:`on_push_ctx={function-argument}`. When the client receives an out-of-band message for the session, it invokes \"function-name(function-argument)\". For example, with options ``{on_push=table.insert, on_push_ctx=messages}``, the client will insert whatever it receives into a table named 'messages'."
msgstr ""

#: ../doc/book/box/box_session.rst:545
msgid "Situation 2: when the client calls asynchronously with the non-default ``{async=true}`` option. Here ``on_push`` and ``on_push_ctx`` are not allowed, but the messages can be seen by calling ``pairs()`` in a loop."
msgstr ""

#: ../doc/book/box/box_session.rst:549
msgid "Situation 2 complication: ``pairs()`` is subject to timeout. So there is an optional argument = timeout per iteration. If timeout occurs before there is a new message or a final response, there is an error return. To check for an error one can use the first loop parameter (if the loop starts with \"for i, message in future:pairs()\" then the first loop parameter is i). If it is ``box.NULL`` then the second parameter (in our example, \"message\") is the error object."
msgstr ""

#: ../doc/book/box/box_session.rst:559
msgid "-- Make two shells. On Shell#1 set up a \"server\", and\n"
"-- in it have a function that includes box.session.push:\n"
"box.cfg{listen=3301}\n"
"box.schema.user.grant('guest','read,write,execute','universe')\n"
"x = 0\n"
"fiber = require('fiber')\n"
"function server_function() x=x+1; fiber.sleep(1); box.session.push(x); end\n"
"\n"
"-- On Shell#2 connect to this server as a \"client\" that\n"
"-- can handle Lua (such as another Tarantool server operating\n"
"-- as a client), and initialize a table where we'll get messages:\n"
"net_box = require('net.box')\n"
"conn = net_box.connect(3301)\n"
"messages_from_server = {}\n"
"\n"
"-- On Shell#2 remotely call the server function and receive\n"
"-- a SYNCHRONOUS out-of-band message:\n"
"conn:call('server_function', {},\n"
"          {is_async = false,\n"
"           on_push = table.insert,\n"
"           on_push_ctx = messages_from_server})\n"
"messages_from_server\n"
"-- After a 1-second pause that is caused by the fiber.sleep()\n"
"-- request inside server_function, the result in the\n"
"--  messages_from_server table will be: 1. Like this:\n"
"-- tarantool> messages_from_server\n"
"-- ---\n"
"-- - - 1\n"
"-- ...\n"
"-- Good. That shows that box.session.push(x) worked,\n"
"-- because we know that x was 1.\n"
"\n"
"-- On Shell#2 remotely call the same server function and\n"
"-- get an ASYNCHRONOUS out-of-band message. For this we cannot\n"
"-- use on_push and on_push_ctx options, but we can use pairs():\n"
"future = conn:call('server_function', {}, {is_async = true})\n"
"messages = {}\n"
"keys = {}\n"
"for i, message in future:pairs() do\n"
"    table.insert(messages, message) table.insert(keys, i) end\n"
"messages\n"
"future:wait_result(1000)\n"
"for i, message in future:pairs() do\n"
"    table.insert(messages, message) table.insert(keys, i) end\n"
"messages\n"
"-- There is no pause because conn:call does not wait for\n"
"-- server_function to finish. The first time that we go through\n"
"-- the pairs() loop, we see the messages table is empty. Like this:\n"
"-- tarantool> messages\n"
"-- ---\n"
"-- - - 2\n"
"--   - []\n"
"-- ...\n"
"-- That is okay because the server hasn't yet called\n"
"-- box.session.push(). The second time that we go through\n"
"-- the pairs() loop, we see the value of x at the time of\n"
"-- the second call to box.session.push(). Like this:\n"
"-- tarantool> messages\n"
"-- ---\n"
"-- - - 2\n"
"--   - &0 []\n"
"--   - 2\n"
"--   - *0\n"
"-- ...\n"
"-- Good. That shows that the message was asynchronous, and\n"
"-- that box.session.push() did its job."
msgstr ""

#: ../doc/book/box/box_slab.rst:13
msgid "The ``box.slab`` submodule provides access to slab allocator statistics. The slab allocator is the main allocator used to store :ref:`tuples <index-box_tuple>`. This can be used to monitor the total memory usage and memory fragmentation."
msgstr ""

#: ../doc/book/box/box_slab.rst:21
msgid "Below is a list of all ``box.slab`` functions."
msgstr ""

#: ../doc/book/box/box_slab.rst:31
msgid ":ref:`box.runtime.info() <box_runtime_info>`"
msgstr ""

#: ../doc/book/box/box_slab.rst:31
msgid "Show a memory usage report for Lua runtime"
msgstr ""

#: ../doc/book/box/box_slab.rst:34
msgid ":ref:`box.slab.info() <box_slab_info>`"
msgstr ""

#: ../doc/book/box/box_slab.rst:34
msgid "Show an aggregated memory usage report for slab allocator"
msgstr ""

#: ../doc/book/box/box_slab.rst:37
msgid ":ref:`box.slab.stats() <box_slab_stats>`"
msgstr ""

#: ../doc/book/box/box_slab.rst:37
msgid "Show a detailed memory usage report for slab allocator"
msgstr ""

#: ../doc/book/box/box_slab.rst:45
msgid "Show a memory usage report (in bytes) for the Lua runtime."
msgstr ""

#: ../doc/book/box/box_slab.rst:49
msgid "``lua`` is the heap size of the Lua garbage collector;"
msgstr ""

#: ../doc/book/box/box_slab.rst:50
msgid "``maxalloc`` is the maximal memory quota that can be allocated for Lua;"
msgstr ""

#: ../doc/book/box/box_slab.rst:51
msgid "``used`` is the current memory size used by Lua."
msgstr ""

#: ../doc/book/box/box_slab.rst:57
msgid "tarantool> box.runtime.info()\n"
"---\n"
"- lua: 913710\n"
"  maxalloc: 4398046510080\n"
"  used: 12582912\n"
"...\n"
"tarantool> box.runtime.info().used\n"
"---\n"
"- used: 12582912\n"
"..."
msgstr ""

#: ../doc/book/box/box_slab.rst:74
msgid "Show an aggregated memory usage report (in bytes) for the slab allocator."
msgstr ""

#: ../doc/book/box/box_slab.rst:76
msgid "This report is useful for assessing out-of-memory risks: the risks are high if both ``arena_used_ratio`` and ``quota_used_ratio`` are high (90-95%)."
msgstr ""

#: ../doc/book/box/box_slab.rst:79
msgid "If ``quota_used_ratio`` is low, then high ``arena_used_ratio`` and/or ``items_used_ratio`` indicate that the memory fragmentation is low (i.e. the memory is used efficiently)."
msgstr ""

#: ../doc/book/box/box_slab.rst:83
msgid "If ``quota_used_ratio`` is high (approaching 100%), then low ``arena_used_ratio`` (50-60%) indicates that the memory is heavily fragmentized. Most probably, there is no immediate out-of-memory risk in this case, but generally this is an issue to consider. For example, probable risks are that the entire memory quota is used for tuples, and there is are no slabs left for a piece of an index. Or that all slabs are allocated for storing tuples, but in fact all the slabs are half-empty."
msgstr ""

#: ../doc/book/box/box_slab.rst:93
msgid "``items_size`` is the *total* amount of memory (including allocated, but currently free slabs) used only for tuples, no indexes;"
msgstr ""

#: ../doc/book/box/box_slab.rst:95
msgid "``items_used_ratio`` = ``items_used`` / ``slab_count`` * ``slab_size`` (these are slabs used only for tuples, no indexes);"
msgstr ""

#: ../doc/book/box/box_slab.rst:97
msgid "``quota_size`` is the maximum amount of memory that the slab allocator can use for both tuples and indexes (as configured in the :ref:`memtx_memory <cfg_storage-memtx_memory>` parameter, the default is 2^28 bytes =  268,435,456 bytes);"
msgstr ""

#: ../doc/book/box/box_slab.rst:101
msgid "``quota_used_ratio`` = ``quota_used`` / ``quota_size``;"
msgstr ""

#: ../doc/book/box/box_slab.rst:102
msgid "``arena_used_ratio`` = ``arena_used`` / ``arena_size``;"
msgstr ""

#: ../doc/book/box/box_slab.rst:103
msgid "``items_used`` is the *efficient* amount of memory (omitting allocated, but currently free slabs) used only for tuples, no indexes;"
msgstr ""

#: ../doc/book/box/box_slab.rst:105
msgid "``quota_used`` is the amount of memory that is already distributed to the slab allocator;"
msgstr ""

#: ../doc/book/box/box_slab.rst:107
msgid "``arena_size`` is the *total* memory used for tuples and indexes together (including allocated, but currently free slabs);"
msgstr ""

#: ../doc/book/box/box_slab.rst:109
msgid "``arena_used`` is the *efficient* memory used for storing tuples and indexes together (omitting allocated, but currently free slabs)."
msgstr ""

#: ../doc/book/box/box_slab.rst:116
msgid "tarantool> box.slab.info()\n"
"---\n"
"- items_size: 228128\n"
"  items_used_ratio: 1.8%\n"
"  quota_size: 1073741824\n"
"  quota_used_ratio: 0.8%\n"
"  arena_used_ratio: 43.2%\n"
"  items_used: 4208\n"
"  quota_used: 8388608\n"
"  arena_size: 2325176\n"
"  arena_used: 1003632\n"
"...\n"
"\n"
"tarantool> box.slab.info().arena_used\n"
"---\n"
"- 1003632\n"
"..."
msgstr ""

#: ../doc/book/box/box_slab.rst:140
msgid "Show a detailed memory usage report (in bytes) for the slab allocator. The report is broken down into groups by *data item size* as well as by *slab size* (64-byte, 136-byte, etc). The report includes the memory allocated for storing both tuples and indexes."
msgstr ""

#: ../doc/book/box/box_slab.rst:147
msgid "``mem_free`` is the allocated, but currently unused memory;"
msgstr ""

#: ../doc/book/box/box_slab.rst:148
msgid "``mem_used`` is the memory used for storing data items (tuples and indexes);"
msgstr ""

#: ../doc/book/box/box_slab.rst:149
msgid "``item_count`` is the number of stored items;"
msgstr ""

#: ../doc/book/box/box_slab.rst:150
msgid "``item_size`` is the size of each data item;"
msgstr ""

#: ../doc/book/box/box_slab.rst:151
msgid "``slab_count`` is the number of slabs allocated;"
msgstr ""

#: ../doc/book/box/box_slab.rst:152
msgid "``slab_size`` is the size of each allocated slab."
msgstr ""

#: ../doc/book/box/box_slab.rst:158
msgid "Here is a sample report for the first group:"
msgstr ""

#: ../doc/book/box/box_slab.rst:160
msgid "tarantool> box.slab.stats()[1]\n"
"---\n"
"- mem_free: 16232\n"
"  mem_used: 48\n"
"  item_count: 2\n"
"  item_size: 24\n"
"  slab_count: 1\n"
"  slab_size: 16384\n"
"..."
msgstr ""

#: ../doc/book/box/box_slab.rst:172
msgid "This report is saying that there are 2 data items (``item_count`` = 2) stored in one (``slab_count`` = 1) 24-byte slab (``item_size`` = 24), so ``mem_used`` = 2 * 24 = 48 bytes. Also, ``slab_size`` is 16384 bytes, of which 16384 - 48 = 16232 bytes are free (``mem_free``)."
msgstr ""

#: ../doc/book/box/box_slab.rst:177
msgid "A complete report would show memory usage statistics for all groups:"
msgstr ""

#: ../doc/book/box/box_slab.rst:179
msgid "tarantool> box.slab.stats()\n"
"---\n"
"- - mem_free: 16232\n"
"    mem_used: 48\n"
"    item_count: 2\n"
"    item_size: 24\n"
"    slab_count: 1\n"
"    slab_size: 16384\n"
"  - mem_free: 15720\n"
"    mem_used: 560\n"
"    item_count: 14\n"
"    item_size: 40\n"
"    slab_count: 1\n"
"    slab_size: 16384\n"
"  <...>\n"
"  - mem_free: 32472\n"
"    mem_used: 192\n"
"    item_count: 1\n"
"    item_size: 192\n"
"    slab_count: 1\n"
"    slab_size: 32768\n"
"  - mem_free: 1097624\n"
"    mem_used: 999424\n"
"    item_count: 61\n"
"    item_size: 16384\n"
"    slab_count: 1\n"
"    slab_size: 2097152\n"
"  ..."
msgstr ""

#: ../doc/book/box/box_slab.rst:210
msgid "The total ``mem_used`` for all groups in this report equals ``arena_used`` in :ref:`box.slab.info() <box_slab_info>` report."
msgstr ""

#: ../doc/book/box/box_slab.rst:217
msgid "Understing memory use statistics with memtx"
msgstr ""

#: ../doc/book/box/box_slab.rst:219
msgid "Inserting a tuple will normally cause increased memory use for the data and for the index. Let us take an example of a tuple with a 5-digit indexed number and a 5-character string: :samp:`{nnnnn}, 'abcde'`."
msgstr ""

#: ../doc/book/box/box_slab.rst:223
msgid "Calculate the tuple size thus: |br| (Size of data + overhead) rounded up to next 8 |br| Size of data is the MsgPack size, because Tarantool stores tuples in MsgPack format, as described in `MsgPack specification <http://github.com/msgpack/msgpack/blob/master/spec.md>`_. and as illustrated in :ref:`Common Types and MsgPack Encodings <msgpack-common_types_and_msgpack_encodings>`, and as easily calculated with :ref:`tuple_object:bsize() <box_tuple-bsize>`. Overhead is always 12. Rounded **up** (emphasis on up) means always use the next integer divisible by 8. In Lua terms, then we can calculate our storage requirement with:"
msgstr ""

#: ../doc/book/box/box_slab.rst:236
msgid "tuple_value = {10000, 'abcde'}\n"
"tuple_size = box.tuple.bsize(box.tuple.new(tuple_value))\n"
"storage_size = math.ceil((tuple_size + 12 + 1) / 8) * 8"
msgstr ""

#: ../doc/book/box/box_slab.rst:242
msgid "In this case tuple_size = 10, storage_size = 24, so we can predict that this tuple requires 24 bytes."
msgstr ""

#: ../doc/book/box/box_slab.rst:245
msgid "Calculate the index size thus: Around 20 to 24 bytes on average. This cannot be an exact number because storage for a TREE index is in blocks. So inserting a single tuple might cause no change to index size, or a large change. But we can expect that when we add 10,000 tuples the average will be 20 to 24."
msgstr ""

#: ../doc/book/box/box_slab.rst:253
msgid "Calculate the initial index overhead thus: 48KB. That is the amount that will be allocated the first time that a tuple is inserted, no matter how big the tuple is. Therefore, when monitoring the growth of memory use, we should ignore the first 48*1024 bytes."
msgstr ""

#: ../doc/book/box/box_slab.rst:259
msgid "Now let us compare our expectations with Tarantool's statistics. Start with a completely empty database, add 10,000 tuples (to ignore), and add 10,000 tuples (to compare the growth)."
msgstr ""

#: ../doc/book/box/box_slab.rst:263
msgid "box.cfg{}\n"
"box.schema.space.create('T')\n"
"box.space.T:create_index('I')\n"
"for i = 0, 9999 do box.space.T:insert{i, 'abcde'} end\n"
"old_memory_data = box.info.memory().data\n"
"old_memory_index = box.info.memory().index\n"
"old_arena_used = box.slab.info().arena_used\n"
"old_1_item_count = box.slab.stats()[1].item_count\n"
"old_24_item_count = box.slab.stats()[24].item_count\n"
"for i = 10000, 19999 do box.space.T:insert{i, 'abcde'} end\n"
"new_memory_data = box.info.memory().data - old_memory_data\n"
"new_memory_index = box.info.memory().index - old_memory_index\n"
"new_arena_used = box.slab.info().arena_used - old_arena_used\n"
"new_1_item_count = box.slab.stats()[1].item_count - old_1_item_count\n"
"new_24_item_count = box.slab.stats()[24].item_count - old_24_item_count\n"
"print('growth in memory().data = ' .. new_memory_data)\n"
"print('growth in memory().index = ' .. new_memory_index)\n"
"print('growth in arena_used = ' .. new_arena_used)\n"
"print('box.slab.stats()[1].item_size = ' .. box.slab.stats()[1].item_size)\n"
"print('growth in box.slab.stats()[1].item_count = ' .. new_1_item_count)\n"
"print('box.slab.stats()[24].item_size = ' .. box.slab.stats()[24].item_size)\n"
"print('growth in box.slab.stats()[24].item_count = ' .. new_24_item_count)"
msgstr ""

#: ../doc/book/box/box_slab.rst:288
msgid "Running that code will result in a display of these values: |br| Growth in memory().data =  240000 bytes, which is 24 * 10000. |br| Growth in memory().index = 229376, which is approximately 23 * 10000. |br| Growth in arena_used = 469376, which is exactly memory().data + memory().index. |br| The first slab stats show there are 10000 new items with size = 24 (the data). |br| The 24th slab stats show that there are 14 new items with size = 16384 (the index blocks)."
msgstr ""

#: ../doc/book/box/box_slab.rst:295
msgid "There are some complications: |br| * The offset of the slab.stats() where item_size = 24 may differ, and the offset of the slab.stats() where item_size = 16384 may differ, depending on Tarantool version and depending on whether there has been any previous activity (for the example we assumed the database is initially empty). |br| * The allocated amount can never be less than :ref:`memtx_min_tuple_size <cfg_storage-memtx_min_tuple_size>`. |br| * If the required size is greater than 128 bytes, then some additional overhead will exist, usually less than 5% of the total size. See the slightly-outdated article: `Memory size calculation <https://github.com/tarantool/tarantool/wiki/Memory-size-calculation>`_."
msgstr ""

#: ../doc/book/box/box_space.rst:5
msgid "Submodule `box.space`"
msgstr ""

#: ../doc/book/box/box_space.rst:11
msgid "The ``box.space`` submodule has the data-manipulation functions ``select``, ``insert``, ``replace``, ``update``, ``upsert``, ``delete``, ``get``, ``put``. It also has members, such as id, and whether or not a space is enabled. Submodule source code is available in file `src/box/lua/schema.lua <https://github.com/tarantool/tarantool/blob/2.1/src/box/lua/schema.lua>`_."
msgstr ""

#: ../doc/book/box/box_space.rst:21
msgid "Below is a list of all ``box.space`` functions and members."
msgstr ""

#: ../doc/book/box/box_space.rst:31
msgid ":ref:`space_object:auto_increment() <box_space-auto_increment>`"
msgstr ""

#: ../doc/book/box/box_space.rst:31
msgid "Generate key + Insert a tuple"
msgstr ""

#: ../doc/book/box/box_space.rst:34
msgid ":ref:`space_object:bsize() <box_space-bsize>`"
msgstr ""

#: ../doc/book/box/box_space.rst:34
msgid "Get count of bytes"
msgstr ""

#: ../doc/book/box/box_space.rst:37
msgid ":ref:`space_object:count() <box_space-count>`"
msgstr ""

#: ../doc/book/box/box_space.rst:37
#: ../doc/book/box/box_space.rst:61
msgid "Get count of tuples"
msgstr ""

#: ../doc/book/box/box_space.rst:40
msgid ":ref:`space_object:create_index() <box_space-create_index>`"
msgstr ""

#: ../doc/book/box/box_space.rst:43
msgid ":ref:`space_object:delete() <box_space-delete>`"
msgstr ""

#: ../doc/book/box/box_space.rst:43
msgid "Delete a tuple"
msgstr ""

#: ../doc/book/box/box_space.rst:46
msgid ":ref:`space_object:drop() <box_space-drop>`"
msgstr ""

#: ../doc/book/box/box_space.rst:46
msgid "Destroy a space"
msgstr ""

#: ../doc/book/box/box_space.rst:49
msgid ":ref:`space_object:format() <box_space-format>`"
msgstr ""

#: ../doc/book/box/box_space.rst:49
msgid "Declare field names and types"
msgstr ""

#: ../doc/book/box/box_space.rst:52
msgid ":ref:`space_object:frommap() <box_space-frommap>`"
msgstr ""

#: ../doc/book/box/box_space.rst:52
msgid "Convert from map to tuple or table"
msgstr ""

#: ../doc/book/box/box_space.rst:55
msgid ":ref:`space_object:get() <box_space-get>`"
msgstr ""

#: ../doc/book/box/box_space.rst:55
msgid "Select a tuple"
msgstr ""

#: ../doc/book/box/box_space.rst:58
msgid ":ref:`space_object:insert() <box_space-insert>`"
msgstr ""

#: ../doc/book/box/box_space.rst:58
msgid "Insert a tuple"
msgstr ""

#: ../doc/book/box/box_space.rst:61
msgid ":ref:`space_object:len() <box_space-len>`"
msgstr ""

#: ../doc/book/box/box_space.rst:64
msgid ":ref:`space_object:on_replace() <box_space-on_replace>`"
msgstr ""

#: ../doc/book/box/box_space.rst:64
msgid "Create a replace trigger with a function that cannot change the tuple"
msgstr ""

#: ../doc/book/box/box_space.rst:68
msgid ":ref:`space_object:before_replace() <box_space-before_replace>`"
msgstr ""

#: ../doc/book/box/box_space.rst:68
msgid "Create a replace trigger with a function that can change the tuple"
msgstr ""

#: ../doc/book/box/box_space.rst:72
msgid ":ref:`space_object:pairs() <box_space-pairs>`"
msgstr ""

#: ../doc/book/box/box_space.rst:75
msgid ":ref:`space_object:put() <box_space-replace>`"
msgstr ""

#: ../doc/book/box/box_space.rst:75
#: ../doc/book/box/box_space.rst:81
msgid "Insert or replace a tuple"
msgstr ""

#: ../doc/book/box/box_space.rst:78
msgid ":ref:`space_object:rename() <box_space-rename>`"
msgstr ""

#: ../doc/book/box/box_space.rst:78
msgid "Rename a space"
msgstr ""

#: ../doc/book/box/box_space.rst:81
msgid ":ref:`space_object:replace() <box_space-replace>`"
msgstr ""

#: ../doc/book/box/box_space.rst:84
msgid ":ref:`space_object:run_triggers() <box_space-run_triggers>`"
msgstr ""

#: ../doc/book/box/box_space.rst:84
msgid "Enable/disable a replace trigger"
msgstr ""

#: ../doc/book/box/box_space.rst:87
msgid ":ref:`space_object:select() <box_space-select>`"
msgstr ""

#: ../doc/book/box/box_space.rst:87
msgid "Select one or more tuples"
msgstr ""

#: ../doc/book/box/box_space.rst:90
msgid ":ref:`space_object:truncate() <box_space-truncate>`"
msgstr ""

#: ../doc/book/box/box_space.rst:90
msgid "Delete all tuples"
msgstr ""

#: ../doc/book/box/box_space.rst:93
msgid ":ref:`space_object:update() <box_space-update>`"
msgstr ""

#: ../doc/book/box/box_space.rst:96
msgid ":ref:`space_object:upsert() <box_space-upsert>`"
msgstr ""

#: ../doc/book/box/box_space.rst:99
msgid ":ref:`space_object:user_defined() <box_space-user_defined>`"
msgstr ""

#: ../doc/book/box/box_space.rst:102
msgid ":ref:`space_object:create_check_constraint() <box_space-create_check_constraint>`"
msgstr ""

#: ../doc/book/box/box_space.rst:102
msgid "Create a check constraint"
msgstr ""

#: ../doc/book/box/box_space.rst:105
msgid ":ref:`space_object.enabled <box_space-enabled>`"
msgstr ""

#: ../doc/book/box/box_space.rst:105
msgid "Flag, true if space is enabled"
msgstr ""

#: ../doc/book/box/box_space.rst:108
msgid ":ref:`space_object.field_count <box_space-field_count>`"
msgstr ""

#: ../doc/book/box/box_space.rst:108
msgid "Required number of fields"
msgstr ""

#: ../doc/book/box/box_space.rst:111
msgid ":ref:`space_object.id <box_space-id>`"
msgstr ""

#: ../doc/book/box/box_space.rst:111
msgid "Numeric identifier of space"
msgstr ""

#: ../doc/book/box/box_space.rst:114
msgid ":ref:`space_object.index <box_space-space_index>`"
msgstr ""

#: ../doc/book/box/box_space.rst:114
msgid "Container of space's indexes"
msgstr ""

#: ../doc/book/box/box_space.rst:117
msgid ":ref:`box.space._cluster <box_space-cluster>`"
msgstr ""

#: ../doc/book/box/box_space.rst:117
msgid "(Metadata) List of replica sets"
msgstr ""

#: ../doc/book/box/box_space.rst:120
msgid ":ref:`box.space._func <box_space-func>`"
msgstr ""

#: ../doc/book/box/box_space.rst:120
msgid "(Metadata) List of function tuples"
msgstr ""

#: ../doc/book/box/box_space.rst:123
msgid ":ref:`box.space._index <box_space-index>`"
msgstr ""

#: ../doc/book/box/box_space.rst:123
msgid "(Metadata) List of indexes"
msgstr ""

#: ../doc/book/box/box_space.rst:126
msgid ":ref:`box.space._priv <box_space-priv>`"
msgstr ""

#: ../doc/book/box/box_space.rst:126
msgid "(Metadata) List of privileges"
msgstr ""

#: ../doc/book/box/box_space.rst:129
msgid ":ref:`box.space._schema <box_space-schema>`"
msgstr ""

#: ../doc/book/box/box_space.rst:129
msgid "(Metadata) List of schemas"
msgstr ""

#: ../doc/book/box/box_space.rst:132
msgid ":ref:`box.space._sequence <box_space-sequence>`"
msgstr ""

#: ../doc/book/box/box_space.rst:132
#: ../doc/book/box/box_space.rst:135
msgid "(Metadata) List of sequences"
msgstr ""

#: ../doc/book/box/box_space.rst:135
msgid ":ref:`box.space._sequence_data <box_space-sequence_data>`"
msgstr ""

#: ../doc/book/box/box_space.rst:138
msgid ":ref:`box.space._space <box_space-space>`"
msgstr ""

#: ../doc/book/box/box_space.rst:138
msgid "(Metadata) List of spaces"
msgstr ""

#: ../doc/book/box/box_space.rst:141
msgid ":ref:`box.space._user <box_space-user>`"
msgstr ""

#: ../doc/book/box/box_space.rst:141
msgid "(Metadata) List of users"
msgstr ""

#: ../doc/book/box/box_space.rst:144
msgid ":ref:`box.space._ck_constraint <box_space-ck_constraint>`"
msgstr ""

#: ../doc/book/box/box_space.rst:144
msgid "(Metadata) List of check constraints"
msgstr ""

#: ../doc/book/box/box_space.rst:147
msgid ":ref:`box.space._collation <box_space-collation>`"
msgstr ""

#: ../doc/book/box/box_space.rst:147
msgid "(Metadata) List of collations"
msgstr ""

#: ../doc/book/box/box_space.rst:150
msgid ":ref:`box.space._vcollation, _vfunc, _vindex <box_space-system_views>` |br| :ref:`_vpriv, _vsequence, _vspace, _vuser <box_space-system_views>`"
msgstr ""

#: ../doc/book/box/box_space.rst:150
msgid "(Metadata) System views"
msgstr ""

#: ../doc/book/box/box_space.rst:164
msgid "Insert a new tuple using an auto-increment primary key. The space specified by space_object must have an :ref:`'unsigned' or 'integer' or 'number' <index-box_indexed-field-types>` primary key index of type ``TREE``. The primary-key field will be incremented before the insert."
msgstr ""

#: ../doc/book/box/box_space.rst:170
msgid "Since version 1.7.5 this method is deprecated – it is better to use a :ref:`sequence <index-box_sequence>`."
msgstr ""

#: ../doc/book/box/box_space.rst:173
#: ../doc/book/box/box_space.rst:206
#: ../doc/book/box/box_space.rst:233
#: ../doc/book/box/box_space.rst:260
#: ../doc/book/box/box_space.rst:706
#: ../doc/book/box/box_space.rst:746
#: ../doc/book/box/box_space.rst:768
#: ../doc/book/box/box_space.rst:949
#: ../doc/book/box/box_space.rst:992
#: ../doc/book/box/box_space.rst:1045
#: ../doc/book/box/box_space.rst:1077
#: ../doc/book/box/box_space.rst:1279
#: ../doc/book/box/box_space.rst:1341
#: ../doc/book/box/box_space.rst:1371
#: ../doc/book/box/box_space.rst:1427
#: ../doc/book/box/box_space.rst:1529
#: ../doc/book/box/box_space.rst:1593
#: ../doc/book/box/box_space.rst:1711
#: ../doc/book/box/box_space.rst:1791
msgid "an :ref:`object reference <app_server-object_reference>`"
msgstr ""

#: ../doc/book/box/box_space.rst:175
msgid "tuple's fields, other than the primary-key field"
msgstr ""

#: ../doc/book/box/box_space.rst:178
#: ../doc/book/box/box_space.rst:1375
msgid "the inserted tuple."
msgstr ""

#: ../doc/book/box/box_space.rst:181
msgid "**Complexity factors:** Index size, Index type, Number of indexes accessed, :ref:`WAL settings <cfg_binary_logging_snapshots-rows_per_wal>`."
msgstr ""

#: ../doc/book/box/box_space.rst:186
msgid "index has wrong type;"
msgstr ""

#: ../doc/book/box/box_space.rst:187
msgid "primary-key indexed field is not a number."
msgstr ""

#: ../doc/book/box/box_space.rst:191
msgid "tarantool> box.space.tester:auto_increment{'Fld#1', 'Fld#2'}\n"
"---\n"
"- [1, 'Fld#1', 'Fld#2']\n"
"...\n"
"tarantool> box.space.tester:auto_increment{'Fld#3'}\n"
"---\n"
"- [2, 'Fld#3']\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:209
msgid "Number of bytes in the space. This number, which is stored in Tarantool's internal memory, represents the total number of bytes in all tuples, not including index keys. For a measure of index size, see :ref:`index_object:bsize() <box_index-bsize>`."
msgstr ""

#: ../doc/book/box/box_space.rst:217
msgid "tarantool> box.space.tester:bsize()\n"
"---\n"
"- 22\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:228
msgid "Return the number of tuples. If compared with :ref:`len() <box_space-len>`, this method works slower because ``count()`` scans the entire space to count the tuples."
msgstr ""

#: ../doc/book/box/box_space.rst:235
#: ../doc/book/box/box_space.rst:708
#: ../doc/book/box/box_space.rst:1595
msgid "primary-key field values, must be passed as a Lua table if key is multi-part"
msgstr ""

#: ../doc/book/box/box_space.rst:239
msgid "Number of tuples."
msgstr ""

#: ../doc/book/box/box_space.rst:243
msgid "tarantool> box.space.tester:count(2, {iterator='GE'})\n"
"---\n"
"- 1\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:254
msgid "Create an :ref:`index <index-box_index>`. It is mandatory to create an index for a space before trying to insert tuples into it, or select tuples from it. The first created index, which will be used as the primary-key index, must be unique."
msgstr ""

#: ../doc/book/box/box_space.rst:262
msgid "name of index, which should conform to the :ref:`rules for object names <app_server-names>`"
msgstr ""

#: ../doc/book/box/box_space.rst:264
msgid "see \"Options for space_object:create_index()\", below"
msgstr ""

#: ../doc/book/box/box_space.rst:267
msgid "index object"
msgstr ""

#: ../doc/book/box/box_space.rst:268
msgid "index_object"
msgstr ""

#: ../doc/book/box/box_space.rst:272
msgid "**Options for space_object:create_index()**"
msgstr ""

#: ../doc/book/box/box_space.rst:286
msgid "type"
msgstr ""

#: ../doc/book/box/box_space.rst:286
msgid "type of index"
msgstr ""

#: ../doc/book/box/box_space.rst:286
msgid "string ('HASH' or 'TREE' or 'BITSET' or 'RTREE') Note re storage engine: vinyl only supports 'TREE'"
msgstr ""

#: ../doc/book/box/box_space.rst:286
msgid "'TREE'"
msgstr ""

#: ../doc/book/box/box_space.rst:292
msgid "unique identifier"
msgstr ""

#: ../doc/book/box/box_space.rst:292
msgid "last index's id, +1"
msgstr ""

#: ../doc/book/box/box_space.rst:294
msgid "unique"
msgstr ""

#: ../doc/book/box/box_space.rst:294
msgid "index is unique"
msgstr ""

#: ../doc/book/box/box_space.rst:294
msgid "``true``"
msgstr ""

#: ../doc/book/box/box_space.rst:296
msgid "no error if duplicate name"
msgstr ""

#: ../doc/book/box/box_space.rst:296
msgid "``false``"
msgstr ""

#: ../doc/book/box/box_space.rst:298
msgid "parts"
msgstr ""

#: ../doc/book/box/box_space.rst:298
msgid "field-numbers  + types"
msgstr ""

#: ../doc/book/box/box_space.rst:298
msgid "{field_no, ``'unsigned'`` or ``'string'`` or ``'integer'`` or ``'number'`` or ``'boolean'`` or ``'decimal'`` or ``'varbinary'`` or ``'array'`` or ``'scalar'``, and optional collation or is_nullable value or path}"
msgstr ""

#: ../doc/book/box/box_space.rst:298
msgid "``{1, 'unsigned'}``"
msgstr ""

#: ../doc/book/box/box_space.rst:307
msgid "dimension"
msgstr ""

#: ../doc/book/box/box_space.rst:307
msgid "affects :ref:`RTREE <box_index-rtree>` only"
msgstr ""

#: ../doc/book/box/box_space.rst:307
#: ../doc/book/box/box_space.rst:2276
#: ../doc/book/cartridge/cartridge_admin.rst:658
#: ../doc/book/cartridge/cartridge_admin.rst:826
msgid "2"
msgstr ""

#: ../doc/book/box/box_space.rst:309
msgid "distance"
msgstr ""

#: ../doc/book/box/box_space.rst:309
msgid "affects RTREE only"
msgstr ""

#: ../doc/book/box/box_space.rst:309
msgid "string ('euclid' or 'manhattan')"
msgstr ""

#: ../doc/book/box/box_space.rst:309
msgid "'euclid'"
msgstr ""

#: ../doc/book/box/box_space.rst:312
msgid "bloom_fpr"
msgstr ""

#: ../doc/book/box/box_space.rst:312
#: ../doc/book/box/box_space.rst:314
#: ../doc/book/box/box_space.rst:316
#: ../doc/book/box/box_space.rst:318
#: ../doc/book/box/box_space.rst:320
msgid "affects vinyl only"
msgstr ""

#: ../doc/book/box/box_space.rst:312
msgid "``vinyl_bloom_fpr``"
msgstr ""

#: ../doc/book/box/box_space.rst:314
msgid "page_size"
msgstr ""

#: ../doc/book/box/box_space.rst:314
msgid "``vinyl_page_size``"
msgstr ""

#: ../doc/book/box/box_space.rst:316
msgid "range_size"
msgstr ""

#: ../doc/book/box/box_space.rst:316
msgid "``vinyl_range_size``"
msgstr ""

#: ../doc/book/box/box_space.rst:318
msgid "run_count_per_level"
msgstr ""

#: ../doc/book/box/box_space.rst:318
msgid "``vinyl_run_count_per_level``"
msgstr ""

#: ../doc/book/box/box_space.rst:320
msgid "run_size_ratio"
msgstr ""

#: ../doc/book/box/box_space.rst:320
msgid "``vinyl_run_size_ratio``"
msgstr ""

#: ../doc/book/box/box_space.rst:322
msgid "sequence"
msgstr ""

#: ../doc/book/box/box_space.rst:322
msgid "see section regarding :ref:`specifying a sequence in create_index() <box_schema-sequence_create_index>`"
msgstr ""

#: ../doc/book/box/box_space.rst:322
msgid "string or number"
msgstr ""

#: ../doc/book/box/box_space.rst:322
#: ../doc/book/box/box_space.rst:326
msgid "not present"
msgstr ""

#: ../doc/book/box/box_space.rst:326
msgid "func"
msgstr ""

#: ../doc/book/box/box_space.rst:326
msgid ":ref:`functional index <box_space-index_func>`"
msgstr ""

#: ../doc/book/box/box_space.rst:329
msgid "The options in the above chart are also applicable for :ref:`index_object:alter() <box_index-alter>`."
msgstr ""

#: ../doc/book/box/box_space.rst:332
msgid "**Note re storage engine:** vinyl has extra options which by default are based on configuration parameters :ref:`vinyl_bloom_fpr <cfg_storage-vinyl_bloom_fpr>`, :ref:`vinyl_page_size <cfg_storage-vinyl_page_size>`, :ref:`vinyl_range_size <cfg_storage-vinyl_range_size>`, :ref:`vinyl_run_count_per_level <cfg_storage-vinyl_run_count_per_level>`, and :ref:`vinyl_run_size_ratio <cfg_storage-vinyl_run_size_ratio>` -- see the description of those parameters. The current values can be seen by selecting from :ref:`box.space._index <box_space-index>`."
msgstr ""

#: ../doc/book/box/box_space.rst:343
msgid "Building or rebuilding a large index will cause occasional :ref:`yields <atomic-cooperative_multitasking>` so that other requests will not be blocked. If the other requests cause an illegal situation such as a duplicate key in a unique index, the index building or rebuilding will fail."
msgstr ""

#: ../doc/book/box/box_space.rst:351
msgid "too many parts;"
msgstr ""

#: ../doc/book/box/box_space.rst:352
msgid "index '...' already exists;"
msgstr ""

#: ../doc/book/box/box_space.rst:353
msgid "primary key must be unique."
msgstr ""

#: ../doc/book/box/box_space.rst:355
msgid "tarantool> s = box.space.tester\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {unique = true, parts = {1, 'unsigned', 2, 'string'}})\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:366
msgid "**Details about index field types:**"
msgstr ""

#: ../doc/book/box/box_space.rst:368
msgid "The nine index field types (unsigned | string | integer | number | boolean | decimal | varbinary | array | scalar) differ depending on what values are allowed, and what index types are allowed."
msgstr ""

#: ../doc/book/box/box_space.rst:372
msgid "**unsigned**: unsigned integers between 0 and 18446744073709551615, about 18 quintillion. May also be called 'uint' or 'num', but 'num' is deprecated. Legal in memtx TREE or HASH indexes, and in vinyl TREE indexes."
msgstr ""

#: ../doc/book/box/box_space.rst:376
msgid "**string**: any set of octets, up to the :ref:`maximum length <limitations_bytes_in_index_key>`. May also be called 'str'. Legal in memtx TREE or HASH or BITSET indexes, and in vinyl TREE indexes. A string may have a :ref:`collation <index-collation>`."
msgstr ""

#: ../doc/book/box/box_space.rst:380
msgid "**integer**: integers between -9223372036854775808 and 18446744073709551615. May also be called 'int'. Legal in memtx TREE or HASH indexes, and in vinyl TREE indexes."
msgstr ""

#: ../doc/book/box/box_space.rst:383
msgid "**number**: integers between -9223372036854775808 and 18446744073709551615, single-precision floating point numbers, or double-precision floating point numbers, or exact numbers. Legal in memtx TREE or HASH indexes, and in vinyl TREE indexes."
msgstr ""

#: ../doc/book/box/box_space.rst:387
msgid "**boolean**: true or false. Legal in memtx TREE or HASH indexes, and in vinyl TREE indexes."
msgstr ""

#: ../doc/book/box/box_space.rst:389
msgid "**decimal**: exact number returned from a function in the :ref:`decimal <decimal>` module. Legal in memtx TREE or HASH indexes, and in vinyl TREE indexes."
msgstr ""

#: ../doc/book/box/box_space.rst:392
msgid "**varbinary**: any set of octets, up to the :ref:`maximum length <limitations_bytes_in_index_key>`. Legal in memtx TREE or HASH indexes, and in vinyl TREE indexes. A varbinary byte sequence does not have a :ref:`collation <index-collation>` because its contents are not UTF-8 characters."
msgstr ""

#: ../doc/book/box/box_space.rst:397
msgid "**array**: array of numbers. Legal in memtx :ref:`RTREE <box_index-rtree>` indexes."
msgstr ""

#: ../doc/book/box/box_space.rst:398
msgid "**scalar**: null (input with ``msgpack.NULL`` or ``yaml.NULL`` or ``json.NULL``), booleans (true or false), or integers between -9223372036854775808 and 18446744073709551615, or single-precision floating point numbers, or double-precison floating-point numbers, or exact numbers, or strings, or (varbinary) byte arrays. When there is a mix of types, the key order is: null, then booleans, then numbers, then strings, then byte arrays. Legal in memtx TREE or HASH indexes, and in vinyl TREE indexes."
msgstr ""

#: ../doc/book/box/box_space.rst:407
msgid "Additionally, `nil` is allowed with any index field type if :ref:`is_nullable=true <box_space-is_nullable>` is specified."
msgstr ""

#: ../doc/book/box/box_space.rst:412
msgid "**Index field types to use in space_object:create_index()**"
msgstr ""

#: ../doc/book/box/box_space.rst:425
msgid "Index field type"
msgstr ""

#: ../doc/book/box/box_space.rst:425
msgid "What can be in it"
msgstr ""

#: ../doc/book/box/box_space.rst:425
msgid "Where is it legal"
msgstr ""

#: ../doc/book/box/box_space.rst:425
#: ../doc/book/box/data_model.rst:285
#: ../doc/book/box/data_model.rst:513
msgid "Examples"
msgstr ""

#: ../doc/book/box/box_space.rst:427
msgid "**unsigned**"
msgstr ""

#: ../doc/book/box/box_space.rst:427
msgid "integers between 0 and 18446744073709551615"
msgstr ""

#: ../doc/book/box/box_space.rst:427
#: ../doc/book/box/box_space.rst:437
#: ../doc/book/box/box_space.rst:441
#: ../doc/book/box/box_space.rst:450
#: ../doc/book/box/box_space.rst:453
#: ../doc/book/box/box_space.rst:462
msgid "memtx TREE or HASH indexes, |br| vinyl TREE indexes"
msgstr ""

#: ../doc/book/box/box_space.rst:427
msgid "123456 |br|"
msgstr ""

#: ../doc/book/box/box_space.rst:431
msgid "**string**"
msgstr ""

#: ../doc/book/box/box_space.rst:431
msgid "strings -- any set of octets"
msgstr ""

#: ../doc/book/box/box_space.rst:431
#: ../doc/book/box/box_space.rst:434
msgid "memtx TREE or HASH indexes |br| vinyl TREE indexes"
msgstr ""

#: ../doc/book/box/box_space.rst:431
msgid "'A B C' |br| '\\\\65 \\\\66 \\\\67'"
msgstr ""

#: ../doc/book/box/box_space.rst:434
#: ../doc/book/box/data_model.rst:312
msgid "**varbinary**"
msgstr ""

#: ../doc/book/box/box_space.rst:434
msgid "byte sequences -- any set of octets"
msgstr ""

#: ../doc/book/box/box_space.rst:434
msgid "'\\\\65 \\\\66 \\\\67' |br|"
msgstr ""

#: ../doc/book/box/box_space.rst:437
msgid "**integer**"
msgstr ""

#: ../doc/book/box/box_space.rst:437
msgid "integers between -9223372036854775808 and 18446744073709551615"
msgstr ""

#: ../doc/book/box/box_space.rst:437
msgid "-2^63 |br|"
msgstr ""

#: ../doc/book/box/box_space.rst:441
#: ../doc/book/box/data_model.rst:298
msgid "**number**"
msgstr ""

#: ../doc/book/box/box_space.rst:441
msgid "integers between -9223372036854775808 and 18446744073709551615, single-precision floating point numbers, double-precision floating point numbers, exact (decimal) numbers"
msgstr ""

#: ../doc/book/box/box_space.rst:441
msgid "1.234 |br| -44 |br| 1.447e+44"
msgstr ""

#: ../doc/book/box/box_space.rst:450
#: ../doc/book/box/data_model.rst:316
msgid "**boolean**"
msgstr ""

#: ../doc/book/box/box_space.rst:450
msgid "true or false"
msgstr ""

#: ../doc/book/box/box_space.rst:450
msgid "false |br| true"
msgstr ""

#: ../doc/book/box/box_space.rst:453
#: ../doc/book/box/data_model.rst:319
msgid "**decimal**"
msgstr ""

#: ../doc/book/box/box_space.rst:453
msgid "exact numbers returned by a function in the :ref:`decimal <decimal>` module"
msgstr ""

#: ../doc/book/box/box_space.rst:453
msgid "decimal.new(1.2) |br|"
msgstr ""

#: ../doc/book/box/box_space.rst:458
#: ../doc/book/box/data_model.rst:322
msgid "**array**"
msgstr ""

#: ../doc/book/box/box_space.rst:458
msgid "array of integers between -9223372036854775808 and 9223372036854775807"
msgstr ""

#: ../doc/book/box/box_space.rst:458
msgid "memtx RTREE indexes"
msgstr ""

#: ../doc/book/box/box_space.rst:458
msgid "{10, 11} |br| {3, 5, 9, 10}"
msgstr ""

#: ../doc/book/box/box_space.rst:462
#: ../doc/book/box/data_model.rst:327
msgid "**scalar**"
msgstr ""

#: ../doc/book/box/box_space.rst:462
msgid "null, booleans (true or false), integers between -9223372036854775808 and 18446744073709551615, single-precision floating point numbers, double-precision floating point numbers, strings"
msgstr ""

#: ../doc/book/box/box_space.rst:462
msgid "null |br| true |br| -1 |br| 1.234 |br| '' |br| 'ру'"
msgstr ""

#: ../doc/book/box/box_space.rst:475
msgid "**Allowing null for an indexed key:** If the index type is TREE, and the index is not the primary index, then the ``parts={...}`` clause may include ``is_nullable=true`` or ``is_nullable=false`` (the default). If ``is_nullable`` is true, then it is legal to insert ``nil`` or an equivalent such as ``msgpack.NULL`` (or it is legal to insert nothing at all for trailing nullable fields). Within indexes, such \"null values\" are always treated as equal to other null values, and are always treated as less than non-null values. Nulls may appear multiple times even in a unique index. Example:"
msgstr ""

#: ../doc/book/box/box_space.rst:484
msgid "box.space.tester:create_index('I',{unique=true,parts={{2,'number',is_nullable=true}}})"
msgstr ""

#: ../doc/book/box/box_space.rst:490
msgid "It is legal to create multiple indexes for the same field with different ``is_nullable`` values, or to call :ref:`space_object:format() <box_space-format>` with a different ``is_nullable`` value from what is used for an index. When there is a contradiction, the rule is: null is illegal unless ``is_nullable=true`` for every index and for the space format."
msgstr ""

#: ../doc/book/box/box_space.rst:498
msgid "**Using field names instead of field numbers:** ``create_index()`` can use field names and/or field types described by the optional :ref:`space_object:format() <box_space-format>` clause. In the following example, we show ``format()`` for a space that has two columns named 'x' and 'y', and then we show five variations of the ``parts={}`` clause of ``create_index()``, first for the 'x' column, second for both the 'x' and 'y' columns. The variations include omitting the type, using numbers, and adding extra braces."
msgstr ""

#: ../doc/book/box/box_space.rst:507
msgid "box.space.tester:format({{name='x', type='scalar'}, {name='y', type='integer'}})\n"
"box.space.tester:create_index('I2',{parts={{'x','scalar'}}})\n"
"box.space.tester:create_index('I3',{parts={{'x','scalar'},{'y','integer'}}})\n"
"box.space.tester:create_index('I4',{parts={1,'scalar'}})\n"
"box.space.tester:create_index('I5',{parts={1,'scalar',2,'integer'}})\n"
"box.space.tester:create_index('I6',{parts={1}})\n"
"box.space.tester:create_index('I7',{parts={1,2}})\n"
"box.space.tester:create_index('I8',{parts={'x'}})\n"
"box.space.tester:create_index('I9',{parts={'x','y'}})\n"
"box.space.tester:create_index('I10',{parts={{'x'}}})\n"
"box.space.tester:create_index('I11',{parts={{'x'},{'y'}}})"
msgstr ""

#: ../doc/book/box/box_space.rst:523
msgid "**Using the path option for map fields:** To create an index for a field that is a map (a path string and a scalar value), specify the path string during index_create, that is, :code:`parts={` :samp:`{field-number},'{data-type}',path = '{path-name}'` :code:`}`. The index type must be ``'tree'`` or ``'hash'`` and the field's contents must always be maps with the same path."
msgstr ""

#: ../doc/book/box/box_space.rst:529
msgid "-- Example 1 -- The simplest use of path:\n"
"-- Result will be - - [{'age': 44}]\n"
"box.schema.space.create('T')\n"
"box.space.T:create_index('I',{parts={{1, 'scalar', path='age'}}})\n"
"box.space.T:insert{{age=44}}\n"
"box.space.T:select(44)\n"
"-- Example 2 -- path plus format() plus JSON syntax to add clarity\n"
"-- Result will be: - [1, {'FIO': {'surname': 'Xi', 'firstname': 'Ahmed'}}]\n"
"s = box.schema.space.create('T')\n"
"format = {{'id', 'unsigned'}, {'data', 'map'}}\n"
"s:format(format)\n"
"parts = {{'data.FIO[\"firstname\"]', 'str'}, {'data.FIO[\"surname\"]', 'str'}}\n"
"i = s:create_index('info', {parts = parts})\n"
"s:insert({1, {FIO={firstname='Ahmed', surname='Xi'}}})"
msgstr ""

#: ../doc/book/box/box_space.rst:546
msgid "**Note re storage engine:** vinyl supports only the TREE index type, and vinyl secondary indexes must be created before tuples are inserted."
msgstr ""

#: ../doc/book/box/box_space.rst:551
msgid "**Using the path option with [*]**  The string in a path option can contain '[*]' which is called an array index placeholder. Indexes defined with this are useful for JSON documents that all have the same structure. For example, when creating an index on field#2 for a string document that will start with ``{'data': [{'name': '...'}, {'name': '...'}]``, the parts section in the create_index request could look like: ``parts = {{2, 'str', path = 'data[*].name'}}``. Then tuples containing names can be retrieved quickly with ``index_object:select({key-value})``. In fact a single field can have multiple keys, as in this example which retrieves the same tuple twice because there are two keys 'A' and 'B' which both match the request:"
msgstr ""

#: ../doc/book/box/box_space.rst:561
msgid "s = box.schema.space.create('json_documents')\n"
"s:create_index('primarykey')\n"
"i = s:create_index('multikey', {parts = {{2, 'str', path = 'data[*].name'}}})\n"
"s:insert({1,\n"
"         {data = {{name='A'},\n"
"                  {name='B'}},\n"
"          extra_field = 1}})\n"
"i:select({''},{iterator='GE'})\n"
"--  The result of the select request looks like this:\n"
"--  tarantool> i:select({''},{iterator='GE'})\n"
"--  ---\n"
"--  - - [1, {'data': [{'name': 'A'}, {'name': 'B'}], 'extra_field': 1}]\n"
"--    - [1, {'data': [{'name': 'A'}, {'name': 'B'}], 'extra_field': 1}]\n"
"--  ..."
msgstr ""

#: ../doc/book/box/box_space.rst:578
msgid "Some restrictions exist: () '[*]' must be alone or must be at the end of a name in the path; () '[*]' must not appear twice in the path; () if an index has a path with x[*] then no other index can have a path with x.component; () '[*]' must not appear in the path of a primary-key ; () if an index has ``unique=true`` and has a path with '[*]' then duplicate keys from different tuples are disallowed but duplicate keys for the same tuple are allowed; () As with :ref:`Using the path option for map fields <box_space-path>`, the field's value must have the structure that the path definition implies, or be nil (nil is not indexed)."
msgstr ""

#: ../doc/book/box/box_space.rst:590
msgid "**Making a functional index with space_object:create_index()**"
msgstr ""

#: ../doc/book/box/box_space.rst:592
msgid "Functional indexes are indexes that call a user-defined function for forming the index key, rather than depending entirely on the Tarantool default formation. Functional indexes are useful for condensing or truncating or reversing or any other way that users want to customize the index."
msgstr ""

#: ../doc/book/box/box_space.rst:597
msgid "The function definition must expect a tuple (which has the contents of fields at the time a data-change request happens) and must return a tuple (which has the contents that will actually be put in the index)."
msgstr ""

#: ../doc/book/box/box_space.rst:601
msgid "The space must have a memtx engine. |br| The function must be :ref:`persistent <box_schema-func_create_with-body>` and deterministic. |br| The key parts must not depend on JSON paths. |br| The ``create_index`` definition must include specification of all key parts, and the function must return a table which has the same number of key parts with the same types. |br| The function must access key-part values by index, not by field name. |br| Functional indexes must not be primary-key indexes. |br| Functional indexes cannot be altered and the function cannot be changed if it is used for an index, so the only way to change them is to drop the index and create it again."
msgstr ""

#: ../doc/book/box/box_space.rst:615
msgid "A function could make a key using only the first letter of a string field."
msgstr ""

#: ../doc/book/box/box_space.rst:617
msgid "-- Step 1: Make the space.\n"
"-- The space needs a primary-key field, which is not the field that we\n"
"-- will use for the functional index.\n"
"box.schema.space.create('x', {engine = 'memtx'})\n"
"box.space.x:create_index('i',{parts={1, 'string'}})\n"
"-- Step 2: Make the function.\n"
"-- The function expects a tuple. In this example it will work on tuple[2]\n"
"-- because the key souce is field number 2 in what we will insert.\n"
"-- Use string.sub() from the string module to get the first character.\n"
"lua_code = [[function(tuple) return {string.sub(tuple[2],1,1)} end]]\n"
"-- Step 3: Make the function persistent.\n"
"-- Use the box.schema.func.create function for this.\n"
"box.schema.func.create('F',\n"
"    {body = lua_code, is_deterministic = true, is_sandboxed = true})\n"
"-- Step 4: Make the functional index.\n"
"-- Specify the fields whose values will be passed to the function.\n"
"-- Specify the function.\n"
"box.space.x:create_index('j',{parts={1, 'string'},func = 'F'})\n"
"-- Step 5: Test.\n"
"-- Insert a few tuples.\n"
"-- Select using only the first letter, it will work because that is the key\n"
"-- Or, select using the same function as was used for insertion\n"
"box.space.x:insert{'a', 'wombat'}\n"
"box.space.x:insert{'b', 'rabbit'}\n"
"-- Select using only the first letter, it will work because that is the key\n"
"-- Or, select using the same function as was used for insertion\n"
"box.space.x:insert{'a', 'wombat'}\n"
"box.space.x:insert{'b', 'rabbit'}\n"
"box.space.x.index.j:select('w')\n"
"box.space.x.index.j:select(box.func.F:call({{'x', 'wombat'}}));"
msgstr ""

#: ../doc/book/box/box_space.rst:650
msgid "The results of the two ``select`` requests will look like this:"
msgstr ""

#: ../doc/book/box/box_space.rst:652
msgid "tarantool>     box.space.x.index.j:select('w')\n"
"---\n"
"- - ['a', 'wombat']\n"
"...\n"
"\n"
"tarantool>     box.space.x.index.j:select(box.func.F:call({{'x','wombat'}}));\n"
"---\n"
"- - ['a', 'wombat']\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:664
msgid "Functions for functional indexes can return multiple keys. |br| Such functions are called \"multikey\" functions. |br| The ``box.func.create`` options must include ``opts = {is_multikey = true}``. |br| The return value must be a table of tuples. |br| If a multikey function returns N tuples, then N keys will be added to the index."
msgstr ""

#: ../doc/book/box/box_space.rst:672
msgid "s = box.schema.space.create('withdata')\n"
"s:format({{name = 'name', type = 'string'},\n"
"          {name = 'address', type = 'string'}})\n"
"pk = s:create_index('name', {parts = {1, 'string'}})\n"
"lua_code = [[function(tuple)\n"
"               local address = string.split(tuple[2])\n"
"               local ret = {}\n"
"               for _, v in pairs(address) do\n"
"                 table.insert(ret, {utf8.upper(v)})\n"
"               end\n"
"               return ret\n"
"             end]]\n"
"box.schema.func.create('address',\n"
"                        {body = lua_code,\n"
"                         is_deterministic = true,\n"
"                         is_sandboxed = true,\n"
"                         opts = {is_multikey = true}})\n"
"idx = s:create_index('addr', {unique = false,\n"
"                              func = 'address',\n"
"                              parts = {{1, 'string',\n"
"                                      collation = 'unicode_ci'}}})\n"
"s:insert({\"James\", \"SIS Building Lambeth London UK\"})\n"
"s:insert({\"Sherlock\", \"221B Baker St Marylebone London NW1 6XE UK\"})\n"
"idx:select('Uk')\n"
"-- Both tuples will be returned."
msgstr ""

#: ../doc/book/box/box_space.rst:704
msgid "Delete a tuple identified by a primary key."
msgstr ""

#: ../doc/book/box/box_space.rst:711
msgid "the deleted tuple"
msgstr ""

#: ../doc/book/box/box_space.rst:714
msgid "**Complexity factors:** Index size, Index type"
msgstr ""

#: ../doc/book/box/box_space.rst:716
msgid "**Note re storage engine:** vinyl will return ``nil``, rather than the deleted tuple."
msgstr ""

#: ../doc/book/box/box_space.rst:721
msgid "tarantool> box.space.tester:delete(1)\n"
"---\n"
"- [1, 'My first tuple']\n"
"...\n"
"tarantool> box.space.tester:delete(1)\n"
"---\n"
"...\n"
"tarantool> box.space.tester:delete('a')\n"
"---\n"
"- error: 'Supplied key type of part 0 does not match index part type:\n"
"  expected unsigned'\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:736
#: ../doc/book/box/box_space.rst:1064
#: ../doc/book/box/box_space.rst:1391
#: ../doc/book/box/box_space.rst:1519
#: ../doc/book/box/box_space.rst:1691
#: ../doc/book/box/box_space.rst:1736
msgid "For more usage scenarios and typical errors see :ref:`Example: using data operations <box_space-operations-detailed-examples>` further in this section."
msgstr ""

#: ../doc/book/box/box_space.rst:744
msgid "Drop a space."
msgstr ""

#: ../doc/book/box/box_space.rst:751
#: ../doc/book/box/box_space.rst:1000
#: ../doc/book/box/box_space.rst:1347
msgid "**Possible errors:** ``space_object`` does not exist."
msgstr ""

#: ../doc/book/box/box_space.rst:753
#: ../doc/book/box/box_space.rst:1002
#: ../doc/book/box/box_space.rst:1382
msgid "**Complexity factors:** Index size, Index type, Number of indexes accessed, WAL settings."
msgstr ""

#: ../doc/book/box/box_space.rst:758
msgid "box.space.space_that_does_not_exist:drop()"
msgstr ""

#: ../doc/book/box/box_space.rst:766
msgid "Declare field names and :ref:`types <index-box_data-types>`."
msgstr ""

#: ../doc/book/box/box_space.rst:770
msgid "a list of field names and types"
msgstr ""

#: ../doc/book/box/box_space.rst:772
msgid "nil, unless format-clause is omitted"
msgstr ""

#: ../doc/book/box/box_space.rst:776
msgid "``space_object`` does not exist;"
msgstr ""

#: ../doc/book/box/box_space.rst:777
msgid "field names are duplicated;"
msgstr ""

#: ../doc/book/box/box_space.rst:778
msgid "type is not legal."
msgstr ""

#: ../doc/book/box/box_space.rst:780
msgid "Ordinarily Tarantool allows unnamed untyped fields. But with ``format`` users can, for example, document that the Nth field is the surname field and must contain strings. It is also possible to specify a format clause in :ref:`box.schema.space.create() <box_schema-space_create>`."
msgstr ""

#: ../doc/book/box/box_space.rst:786
msgid "The format clause contains, for each field, a definition within braces: ``{name='...',type='...'[,is_nullable=...]}``, where:"
msgstr ""

#: ../doc/book/box/box_space.rst:789
msgid "the ``name`` value may be any string, provided that two fields do not have the same name;"
msgstr ""

#: ../doc/book/box/box_space.rst:791
msgid "the ``type`` value may be any of those allowed for :ref:`indexed fields <index-box_indexed-field-types>`: unsigned | string | varbinary | integer | number | boolean | decimal | array | scalar (the same as the requirement in :ref:`\"Options for space_object:create_index\" <box_space-create_index-options>`);"
msgstr ""

#: ../doc/book/box/box_space.rst:796
msgid "the optional ``is_nullable`` value may be either ``true`` or ``false`` (the same as the requirement in :ref:`\"Options for space_object:create_index\" <box_space-create_index-options>`). See also the warning notice in section :ref:`Allowing null for an indexed key <box_space-is_nullable>`."
msgstr ""

#: ../doc/book/box/box_space.rst:802
msgid "It is not legal for tuples to contain values that have the wrong type; for example after ``box.space.tester:format({{' ',type='number'}})`` the request ``box.space.tester:insert{'string-which-is-not-a-number'}`` will cause an error."
msgstr ""

#: ../doc/book/box/box_space.rst:806
msgid "It is not legal for tuples to contain null values if ``is_nullable=false``, which is the default; for example after ``box.space.tester:format({{' ',type='number',is_nullable=false}})`` the request ``box.space.tester:insert{nil,2}`` will cause an error."
msgstr ""

#: ../doc/book/box/box_space.rst:810
msgid "It is legal for tuples to have more fields than are described by a format clause. The way to constrain the number of fields is to specify a space's :ref:`field_count <box_space-field_count>` member."
msgstr ""

#: ../doc/book/box/box_space.rst:814
msgid "It is legal for tuples to have fewer fields than are described by a format clause, if the omitted trailing fields are described with ``is_nullable=true``; for example after ``box.space.tester:format({{'a',type='number'},{'b',type='number',is_nullable=true}})`` the request ``box.space.tester:insert{2}`` will not cause a format-related error."
msgstr ""

#: ../doc/book/box/box_space.rst:819
msgid "It is legal to use ``format`` on a space that already has a format, thus replacing any previous definitions, provided that there is no conflict with existing data or index definitions."
msgstr ""

#: ../doc/book/box/box_space.rst:823
msgid "It is legal to use ``format`` to change the ``is_nullable`` flag; for example after ``box.space.tester:format({{' ',type='scalar',is_nullable=false}})`` the request ``box.space.tester:format({{' ',type='scalar',is_nullable=true}})`` will not cause an error -- and will not cause rebuilding of the space. But going the other way and changing ``is_nullable`` from ``true`` to ``false`` might cause rebuilding and might cause an error if there are existing tuples with nulls."
msgstr ""

#: ../doc/book/box/box_space.rst:833
msgid "box.space.tester:format({{name='surname',type='string'},{name='IDX',type='array'}})\n"
"box.space.tester:format({{name='surname',type='string',is_nullable=true}})"
msgstr ""

#: ../doc/book/box/box_space.rst:839
msgid "There are legal variations of the format clause:"
msgstr ""

#: ../doc/book/box/box_space.rst:841
msgid "omitting both 'name=' and 'type=',"
msgstr ""

#: ../doc/book/box/box_space.rst:842
msgid "omitting 'type=' alone, and"
msgstr ""

#: ../doc/book/box/box_space.rst:843
msgid "adding extra braces."
msgstr ""

#: ../doc/book/box/box_space.rst:845
msgid "The following examples show all the variations, first for one field named 'x', second for two fields named 'x' and 'y'."
msgstr ""

#: ../doc/book/box/box_space.rst:848
msgid "box.space.tester:format({{'x'}})\n"
"box.space.tester:format({{'x'},{'y'}})\n"
"box.space.tester:format({{name='x',type='scalar'}})\n"
"box.space.tester:format({{name='x',type='scalar'},{name='y',type='unsigned'}})\n"
"box.space.tester:format({{name='x'}})\n"
"box.space.tester:format({{name='x'},{name='y'}})\n"
"box.space.tester:format({{'x',type='scalar'}})\n"
"box.space.tester:format({{'x',type='scalar'},{'y',type='unsigned'}})\n"
"box.space.tester:format({{'x','scalar'}})\n"
"box.space.tester:format({{'x','scalar'},{'y','unsigned'}})"
msgstr ""

#: ../doc/book/box/box_space.rst:861
msgid "The following example shows how to create a space, format it with all possible types, and insert into it."
msgstr ""

#: ../doc/book/box/box_space.rst:864
msgid "tarantool> decimal = require('decimal')\n"
"---\n"
"...\n"
"tarantool> box.schema.space.create('t')\n"
"---\n"
"- engine: memtx\n"
"  before_replace: 'function: 0x40650f60'\n"
"  on_replace: 'function: 0x406a3eb8'\n"
"  ck_constraint: []\n"
"  field_count: 0\n"
"  temporary: false\n"
"  index: []\n"
"  is_local: false\n"
"  enabled: false\n"
"  name: t\n"
"  id: 512\n"
"- created\n"
"...\n"
"tarantool> box.space.t:format({{name='1',type='any'},\n"
"         >                      {name='2',type='unsigned'},\n"
"         >                      {name='3',type='string'},\n"
"         >                      {name='4',type='number'},\n"
"         >                      {name='5',type='integer'},\n"
"         >                      {name='6',type='boolean'},\n"
"         >                      {name='7',type='decimal'},\n"
"         >                      {name='8',type='scalar'},\n"
"         >                      {name='9',type='array'},\n"
"         >                      {name='10',type='map'}})\n"
"---\n"
"...\n"
"tarantool> box.space.t:create_index('i',{parts={2,'unsigned'}})\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: unsigned\n"
"    is_nullable: false\n"
"    fieldno: 2\n"
"  id: 0\n"
"  space_id: 512\n"
"  type: TREE\n"
"  name: i\n"
"...\n"
"tarantool> box.space.t:insert{{'a'},             -- any\n"
"         >                     1,                -- unsigned\n"
"         >                     'W?',             -- string\n"
"         >                     5.5,              -- number\n"
"         >                     -0,               -- integer\n"
"         >                     true,             -- boolean\n"
"         >                     decimal.new(1.2), -- decimal\n"
"         >                     true,             -- scalar\n"
"         >                     {{'a'}},          -- array\n"
"         >                     {val=1}}          -- map\n"
"---\n"
"- [['a'], 1, 'W?', 5.5, 0, true, 1.2, true, [['a']], {'val': 1}]\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:922
msgid "Names specified with the format clause can be used in :ref:`space_object:get() <box_space-get>` and in :ref:`space_object:create_index() <box_space-create_index>` and in :ref:`tuple_object[field-name] <box_tuple-field_name>` and in :ref:`tuple_object[field-path] <box_tuple-field_path>`."
msgstr ""

#: ../doc/book/box/box_space.rst:928
msgid "If the format clause is omitted, then the returned value is the table that was used in a previous :samp:`{space_object}:format({format-clause})` invocation. For example, after ``box.space.tester:format({{'x','scalar'}})``, ``box.space.tester:format()`` will return ``[{'name': 'x', 'type': 'scalar'}]``."
msgstr ""

#: ../doc/book/box/box_space.rst:933
msgid "Formatting or reformatting a large space will cause occasional :ref:`yields <atomic-cooperative_multitasking>` so that other requests will not be blocked. If the other requests cause an illegal situation such as a field value of the wrong type, the formatting or reformatting will fail."
msgstr ""

#: ../doc/book/box/box_space.rst:943
msgid "Convert a map to a tuple instance or to a table. The map must consist of \"field name = value\" pairs. The field names and the value types must match names and types stated previously for the space, via :ref:`space_object:format() <box_space-format>`."
msgstr ""

#: ../doc/book/box/box_space.rst:951
msgid "a series of \"field = value\" pairs, in any order."
msgstr ""

#: ../doc/book/box/box_space.rst:952
msgid "the only legal option is ``{table = true|false}``; |br| if the option is omitted or if ``{table = false}``, then return type will be 'cdata' (i.e. tuple); |br| if ``{table = true}``, then return type will be 'table'."
msgstr ""

#: ../doc/book/box/box_space.rst:957
msgid "a tuple instance or table."
msgstr ""

#: ../doc/book/box/box_space.rst:958
msgid "tuple or table"
msgstr ""

#: ../doc/book/box/box_space.rst:960
msgid "**Possible errors:** ``space_object`` does not exist or has no format; \"unknown field\"."
msgstr ""

#: ../doc/book/box/box_space.rst:964
msgid "-- Create a format with two fields named 'a' and 'b'.\n"
"-- Create a space with that format.\n"
"-- Create a tuple based on a map consistent with that space.\n"
"-- Create a table based on a map consistent with that space.\n"
"tarantool> format1 = {{name='a',type='unsigned'},{name='b',type='scalar'}}\n"
"---\n"
"...\n"
"tarantool> s = box.schema.create_space('test', {format = format1})\n"
"---\n"
"...\n"
"tarantool> s:frommap({b = 'x', a = 123456})\n"
"---\n"
"- [123456, 'x']\n"
"...\n"
"tarantool> s:frommap({b = 'x', a = 123456}, {table = true})\n"
"---\n"
"- - 123456\n"
"  - x\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:990
msgid "Search for a tuple in the given space."
msgstr ""

#: ../doc/book/box/box_space.rst:994
#: ../doc/book/box/box_space.rst:1429
msgid "value to be matched against the index key, which may be multi-part."
msgstr ""

#: ../doc/book/box/box_space.rst:997
msgid "the tuple whose index key matches ``key``, or ``nil``."
msgstr ""

#: ../doc/book/box/box_space.rst:1005
msgid "The ``box.space...select`` function returns a set of tuples as a Lua table; the ``box.space...get`` function returns at most a single tuple. And it is possible to get the first tuple in a space by appending ``[1]``. Therefore ``box.space.tester:get{1}`` has the same effect as ``box.space.tester:select{1}[1]``, if exactly one tuple is found."
msgstr ""

#: ../doc/book/box/box_space.rst:1013
msgid "box.space.tester:get{1}"
msgstr ""

#: ../doc/book/box/box_space.rst:1017
msgid "**Using field names instead of field numbers:** `get()` can use field names described by the optional :ref:`space_object:format() <box_space-format>` clause. This is true because the object returned by ``get()`` can be used with most of the features described in the :ref:`Submodule box.tuple <box_tuple>` description, including :ref:`tuple_object[field-name] <box_tuple-field_name>`."
msgstr ""

#: ../doc/book/box/box_space.rst:1023
msgid "For example, we can format the `tester` space with a field named `x` and use the name `x` in the index definition:"
msgstr ""

#: ../doc/book/box/box_space.rst:1026
msgid "box.space.tester:format({{name='x',type='scalar'}})\n"
"box.space.tester:create_index('I',{parts={'x'}})"
msgstr ""

#: ../doc/book/box/box_space.rst:1031
msgid "Then, if ``get`` or ``select`` retrieves a single tuple, we can reference the field 'x' in the tuple by its name:"
msgstr ""

#: ../doc/book/box/box_space.rst:1034
msgid "box.space.tester:get{1}['x']\n"
"box.space.tester:select{1}[1]['x']"
msgstr ""

#: ../doc/book/box/box_space.rst:1043
msgid "Insert a tuple into a space."
msgstr ""

#: ../doc/book/box/box_space.rst:1047
msgid "tuple to be inserted."
msgstr ""

#: ../doc/book/box/box_space.rst:1049
msgid "the inserted tuple"
msgstr ""

#: ../doc/book/box/box_space.rst:1052
msgid "**Possible errors:** :errcode:`ER_TUPLE_FOUND` if a tuple with the same unique-key value already exists."
msgstr ""

#: ../doc/book/box/box_space.rst:1057
msgid "tarantool> box.space.tester:insert{5000,'tuple number five thousand'}\n"
"---\n"
"- [5000, 'tuple number five thousand']\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:1072
msgid "Return the number of tuples in the space. If compared with :ref:`count() <box_space-count>`, this method works faster because ``len()`` does not scan the entire space to count the tuples."
msgstr ""

#: ../doc/book/box/box_space.rst:1080
msgid "Number of tuples in the space."
msgstr ""

#: ../doc/book/box/box_space.rst:1084
msgid "tarantool> box.space.tester:len()\n"
"---\n"
"- 2\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:1091
msgid "**Note re storage engine:** vinyl supports ``len()`` but the result may be approximate. If an exact result is necessary then use :ref:`count() <box_space-count>` or :ref:`pairs():length() <box_space-pairs>`."
msgstr ""

#: ../doc/book/box/box_space.rst:1099
#: ../doc/book/box/box_space.rst:1184
msgid "Create a \"replace :ref:`trigger <triggers>`\". The ``trigger-function`` will be executed whenever a ``replace()`` or ``insert()`` or ``update()`` or ``upsert()`` or ``delete()`` happens to a tuple in ``<space-name>``."
msgstr ""

#: ../doc/book/box/box_space.rst:1104
msgid "function which will become the trigger function; see Example #2 below for details about trigger function parameters"
msgstr ""

#: ../doc/book/box/box_space.rst:1108
#: ../doc/book/box/box_space.rst:1194
msgid "existing trigger function which will be replaced by ``trigger-function``"
msgstr ""

#: ../doc/book/box/box_space.rst:1119
#: ../doc/book/box/box_space.rst:1204
msgid "If it is necessary to know whether the trigger activation happened due to replication or on a specific connection type, the function can refer to :ref:`box.session.type() <box_session-type>`."
msgstr ""

#: ../doc/book/box/box_space.rst:1126
msgid "See also :ref:`space_object:before_replace() <box_space-before_replace>`."
msgstr ""

#: ../doc/book/box/box_space.rst:1128
#: ../doc/book/box/box_space.rst:2159
msgid "**Example #1:**"
msgstr ""

#: ../doc/book/box/box_space.rst:1130
msgid "tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.space.X:on_replace(f)"
msgstr ""

#: ../doc/book/box/box_space.rst:1137
#: ../doc/book/box/box_space.rst:2204
msgid "**Example #2:**"
msgstr ""

#: ../doc/book/box/box_space.rst:1139
msgid "The ``trigger-function`` can have up to four parameters:"
msgstr ""

#: ../doc/book/box/box_space.rst:1141
msgid "(tuple) old value which has the contents before the request started,"
msgstr ""

#: ../doc/book/box/box_space.rst:1142
msgid "(tuple) new value which has the contents after the request ended,"
msgstr ""

#: ../doc/book/box/box_space.rst:1143
msgid "(string) space name,"
msgstr ""

#: ../doc/book/box/box_space.rst:1144
msgid "(string) type of request which is 'INSERT', 'DELETE', 'UPDATE', or 'REPLACE'."
msgstr ""

#: ../doc/book/box/box_space.rst:1146
msgid "For example, the following code causes nil and 'INSERT' to be printed when the insert request is processed, and causes [1, 'Hi'] and 'DELETE' to be printed when the delete request is processed:"
msgstr ""

#: ../doc/book/box/box_space.rst:1150
msgid "box.schema.space.create('space_1')\n"
"box.space.space_1:create_index('space_1_index',{})\n"
"function on_replace_function (old, new, s, op) print(old) print(op) end\n"
"box.space.space_1:on_replace(on_replace_function)\n"
"box.space.space_1:insert{1,'Hi'}\n"
"box.space.space_1:delete{1}"
msgstr ""

#: ../doc/book/box/box_space.rst:1159
msgid "**Example #3:**"
msgstr ""

#: ../doc/book/box/box_space.rst:1161
msgid "The following series of requests will create a space, create an index, create a function which increments a counter, create a trigger, do two inserts, drop the space, and display the counter value - which is 2, because the function is executed once after each insert."
msgstr ""

#: ../doc/book/box/box_space.rst:1166
msgid "tarantool> s = box.schema.space.create('space53')\n"
"tarantool> s:create_index('primary', {parts = {1, 'unsigned'}})\n"
"tarantool> function replace_trigger()\n"
"         >   replace_counter = replace_counter + 1\n"
"         > end\n"
"tarantool> s:on_replace(replace_trigger)\n"
"tarantool> replace_counter = 0\n"
"tarantool> t = s:insert{1, 'First replace'}\n"
"tarantool> t = s:insert{2, 'Second replace'}\n"
"tarantool> s:drop()\n"
"tarantool> replace_counter"
msgstr ""

#: ../doc/book/box/box_space.rst:1189
msgid "function which will become the trigger function; for the trigger function's optional parameters see the description of :ref:`on_replace <box_space-on_replace>`."
msgstr ""

#: ../doc/book/box/box_space.rst:1199
#: ../doc/book/box/box_txn_management.rst:207
msgid "If the parameters are ``(nil, old-trigger-function)``, then the old trigger is deleted."
msgstr ""

#: ../doc/book/box/box_space.rst:1211
msgid "See also :ref:`space_object:on_replace() <box_space-on_replace>`."
msgstr ""

#: ../doc/book/box/box_space.rst:1213
msgid "Administrators can make replace triggers with ``on_replace()``, or make triggers with ``before_replace()``. If they make both types, then all ``before_replace`` triggers are executed before all ``on_replace`` triggers. The functions for both ``on_replace`` and ``before_replace`` triggers can make changes to the database, but only the functions for ``before_replace`` triggers can change the tuple that is being replaced."
msgstr ""

#: ../doc/book/box/box_space.rst:1222
msgid "Since a ``before_replace`` trigger function has the extra capability of making a change to the old tuple, it also can have extra overhead, to fetch the old tuple before making the change. Therefore an ``on_replace`` trigger is better if there is no need to change the old tuple. However, this only applies for the memtx engine -- for the vinyl engine, the fetch will happen for either kind of trigger. (With memtx the tuple data is stored along with the index key so no extra search is necessary; with vinyl that is not the case so the extra search is necessary.)"
msgstr ""

#: ../doc/book/box/box_space.rst:1234
msgid "Where the extra capability is not needed, ``on_replace`` should be used instead of ``before_replace``. Usually ``before_replace`` is used only for certain replication scenarios -- it is useful for conflict resolution."
msgstr ""

#: ../doc/book/box/box_space.rst:1239
msgid "The value that a ``before_replace`` trigger function can return affects what will happen after the return. Specifically:"
msgstr ""

#: ../doc/book/box/box_space.rst:1242
msgid "if there is no return value, then execution proceeds, inserting|replacing the new value;"
msgstr ""

#: ../doc/book/box/box_space.rst:1244
msgid "if the value is nil, then the tuple will be deleted;"
msgstr ""

#: ../doc/book/box/box_space.rst:1245
msgid "if the value is the same as the old parameter, then no `on_replace`` function will be called and the data change will be skipped"
msgstr ""

#: ../doc/book/box/box_space.rst:1248
msgid "if the value is the same as the new parameter, then it's as if the ``before_replace`` function wasn't called;"
msgstr ""

#: ../doc/book/box/box_space.rst:1250
msgid "if the value is something else, then execution proceeds, inserting|replacing the new value."
msgstr ""

#: ../doc/book/box/box_space.rst:1253
msgid "However, if a trigger function returns an old tuple, or if a trigger function calls :ref:`run_triggers(false) <box_space-run_triggers>`, that will not affect other triggers that are activated for the same insert|update|replace request."
msgstr ""

#: ../doc/book/box/box_space.rst:1260
msgid "The following are ``before_replace`` functions that have no return value, or that return nil, or the same as the old parameter, or the same as the new parameter, or something else."
msgstr ""

#: ../doc/book/box/box_space.rst:1264
msgid "function f1 (old, new) return end\n"
"function f2 (old, new) return nil end\n"
"function f3 (old, new) return old end\n"
"function f4 (old, new) return new end\n"
"function f5 (old, new) return box.tuple.new({new[1],'b'}) end"
msgstr ""

#: ../doc/book/box/box_space.rst:1276
msgid "Search for a tuple or a set of tuples in the given space, and allow iterating over one tuple at a time."
msgstr ""

#: ../doc/book/box/box_space.rst:1283
msgid "see :ref:`index_object:pairs <box_index-index_pairs>`"
msgstr ""

#: ../doc/book/box/box_space.rst:1292
#: ../doc/book/box/box_space.rst:1451
msgid "no such space;"
msgstr ""

#: ../doc/book/box/box_space.rst:1293
#: ../doc/book/box/box_space.rst:1452
msgid "wrong type."
msgstr ""

#: ../doc/book/box/box_space.rst:1297
msgid "For examples of complex ``pairs`` requests, where one can specify which index to search and what condition to use (for example \"greater than\" instead of \"equal to\"), see the later section :ref:`index_object:pairs <box_index-index_pairs>`."
msgstr ""

#: ../doc/book/box/box_space.rst:1308
msgid "tarantool> s = box.schema.space.create('space33')\n"
"---\n"
"...\n"
"tarantool> -- index 'X' has default parts {1, 'unsigned'}\n"
"tarantool> s:create_index('X', {})\n"
"---\n"
"...\n"
"tarantool> s:insert{0, 'Hello my '}, s:insert{1, 'Lua world'}\n"
"---\n"
"- [0, 'Hello my ']\n"
"- [1, 'Lua world']\n"
"...\n"
"tarantool> tmp = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in s:pairs() do\n"
"         >   tmp = tmp .. v[2]\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> tmp\n"
"---\n"
"- Hello my Lua world\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:1339
msgid "Rename a space."
msgstr ""

#: ../doc/book/box/box_space.rst:1343
msgid "new name for space"
msgstr ""

#: ../doc/book/box/box_space.rst:1351
msgid "tarantool> box.space.space55:rename('space56')\n"
"---\n"
"...\n"
"tarantool> box.space.space56:rename('space55')\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:1365
msgid "Insert a tuple into a space. If a tuple with the same primary key already exists, ``box.space...:replace()`` replaces the existing tuple with a new one. The syntax variants ``box.space...:replace()`` and ``box.space...:put()`` have the same effect; the latter is sometimes used to show that the effect is the converse of ``box.space...:get()``."
msgstr ""

#: ../doc/book/box/box_space.rst:1373
msgid "tuple to be inserted"
msgstr ""

#: ../doc/book/box/box_space.rst:1378
msgid "**Possible errors:** :errcode:`ER_TUPLE_FOUND` if a different tuple with the same unique-key value already exists. (This will only happen if there is a unique secondary index.)"
msgstr ""

#: ../doc/book/box/box_space.rst:1387
msgid "box.space.tester:replace{5000, 'tuple number five thousand'}"
msgstr ""

#: ../doc/book/box/box_space.rst:1399
msgid "At the time that a :ref:`trigger <triggers>` is defined, it is automatically enabled - that is, it will be executed. :ref:`Replace <box_space-on_replace>` triggers can be disabled with :samp:`box.space.{space-name}:run_triggers(false)` and re-enabled with :samp:`box.space.{space-name}:run_triggers(true)`."
msgstr ""

#: ../doc/book/box/box_space.rst:1408
msgid "The following series of requests will associate an existing function named `F` with an existing space named `T`, associate the function a second time with the same space (so it will be called twice), disable all triggers of `T`, and delete each trigger by replacing with ``nil``."
msgstr ""

#: ../doc/book/box/box_space.rst:1413
msgid "tarantool> box.space.T:on_replace(F)\n"
"tarantool> box.space.T:on_replace(F)\n"
"tarantool> box.space.T:run_triggers(false)\n"
"tarantool> box.space.T:on_replace(nil, F)\n"
"tarantool> box.space.T:on_replace(nil, F)"
msgstr ""

#: ../doc/book/box/box_space.rst:1425
msgid "Search for a tuple or a set of tuples in the given space."
msgstr ""

#: ../doc/book/box/box_space.rst:1431
msgid "none, any or all of the same options that :ref:`index_object:select <box_index-select>` allows:  * ``options.iterator`` (:ref:`type of iterator <box_index-iterator-types>`) * ``options.limit`` (maximum number of tuples) * ``options.offset`` (number of tuples to skip)"
msgstr ""

#: ../doc/book/box/box_space.rst:1431
msgid "none, any or all of the same options that :ref:`index_object:select <box_index-select>` allows:"
msgstr ""

#: ../doc/book/box/box_space.rst:1435
msgid "``options.iterator`` (:ref:`type of iterator <box_index-iterator-types>`)"
msgstr ""

#: ../doc/book/box/box_space.rst:1436
msgid "``options.limit`` (maximum number of tuples)"
msgstr ""

#: ../doc/book/box/box_space.rst:1437
msgid "``options.offset`` (number of tuples to skip)"
msgstr ""

#: ../doc/book/box/box_space.rst:1439
msgid "the tuples whose primary-key fields are equal to the fields of the passed key. If the number of passed fields is less than the number of fields in the primary key, then only the passed fields are compared, so ``select{1,2}`` will match a tuple whose primary key is ``{1,2,3}``."
msgstr ""

#: ../doc/book/box/box_space.rst:1446
msgid "A ``select`` request can also be done with a specific index and index options, which are the subject of :ref:`index_object:select <box_index-select>`."
msgstr ""

#: ../doc/book/box/box_space.rst:1458
msgid "tarantool> s = box.schema.space.create('tmp', {temporary=true})\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary',{parts = {1,'unsigned', 2, 'string'}})\n"
"---\n"
"...\n"
"tarantool> s:insert{1,'A'}\n"
"---\n"
"- [1, 'A']\n"
"...\n"
"tarantool> s:insert{1,'B'}\n"
"---\n"
"- [1, 'B']\n"
"...\n"
"tarantool> s:insert{1,'C'}\n"
"---\n"
"- [1, 'C']\n"
"...\n"
"tarantool> s:insert{2,'D'}\n"
"---\n"
"- [2, 'D']\n"
"...\n"
"tarantool> -- must equal both primary-key fields\n"
"tarantool> s:select{1,'B'}\n"
"---\n"
"- - [1, 'B']\n"
"...\n"
"tarantool> -- must equal only one primary-key field\n"
"tarantool> s:select{1}\n"
"---\n"
"- - [1, 'A']\n"
"  - [1, 'B']\n"
"  - [1, 'C']\n"
"...\n"
"tarantool> -- must equal 0 fields, so returns all tuples\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 'A']\n"
"  - [1, 'B']\n"
"  - [1, 'C']\n"
"  - [2, 'D']\n"
"...\n"
"tarantool> -- the first field must be greater than 0, and\n"
"tarantool> -- skip the first tuple, and return up to\n"
"tarantool> -- 2 tuples. This example's options all\n"
"tarantool> -- depend on index characteristics so see\n"
"tarantool> -- more explanation in index_object:select().\n"
"tarantool> s:select({0},{iterator='GT',offset=1,limit=2})\n"
"---\n"
"- - [1, 'B']\n"
"  - [1, 'C']\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:1513
msgid "As the last request in the above example shows: to make complex ``select`` requests, where you can specify which index to search and what condition to use (for example \"greater than\" instead of \"equal to\") and how many tuples to return, it will be necessary to become familiar with :ref:`index_object:select <box_index-select>`."
msgstr ""

#: ../doc/book/box/box_space.rst:1527
msgid "Deletes all tuples."
msgstr ""

#: ../doc/book/box/box_space.rst:1536
msgid "The ``truncate`` method can only be called by the user who created the space, or from within a ``setuid`` function created by the user who created the space. Read more about `setuid` functions in the reference for :ref:`box.schema.func.create() <box_schema-func_create>`."
msgstr ""

#: ../doc/book/box/box_space.rst:1542
msgid "The ``truncate`` method cannot be called from within a transaction."
msgstr ""

#: ../doc/book/box/box_space.rst:1546
msgid "tarantool> box.space.tester:truncate()\n"
"---\n"
"...\n"
"tarantool> box.space.tester:len()\n"
"---\n"
"- 0\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:1562
msgid "The ``update`` function supports operations on fields — assignment, arithmetic (if the field is numeric), cutting and pasting fragments of a field, deleting or inserting a field. Multiple operations can be combined in a single update request, and in this case they are performed atomically and sequentially. Each operation requires specification of a field identifier, which is usually a number. When multiple operations are present, the field number for each operation is assumed to be relative to the most recent state of the tuple, that is, as if all previous operations in a multi-operation update have already been applied. In other words, it is always safe to merge multiple ``update`` invocations into a single invocation, with no change in semantics."
msgstr ""

#: ../doc/book/box/box_space.rst:1574
msgid "Possible operators are:"
msgstr ""

#: ../doc/book/box/box_space.rst:1576
msgid "``+`` for addition. values must be numeric, e.g. unsigned or decimal"
msgstr ""

#: ../doc/book/box/box_space.rst:1577
msgid "``-`` for subtraction. values must be numeric"
msgstr ""

#: ../doc/book/box/box_space.rst:1578
msgid "``&`` for bitwise AND. values must be unsigned numeric"
msgstr ""

#: ../doc/book/box/box_space.rst:1579
msgid "``|`` for bitwise OR. values must be unsigned numeric"
msgstr ""

#: ../doc/book/box/box_space.rst:1580
msgid "``^`` for bitwise :abbr:`XOR(exclusive OR)`. values must be unsigned numeric"
msgstr ""

#: ../doc/book/box/box_space.rst:1582
msgid "``:`` for string splice."
msgstr ""

#: ../doc/book/box/box_space.rst:1583
msgid "``!`` for insertion of a new field."
msgstr ""

#: ../doc/book/box/box_space.rst:1584
msgid "``#`` for deletion."
msgstr ""

#: ../doc/book/box/box_space.rst:1585
msgid "``=`` for assignment."
msgstr ""

#: ../doc/book/box/box_space.rst:1587
msgid "Possible field_identifiers are:"
msgstr ""

#: ../doc/book/box/box_space.rst:1589
msgid "Positive field number. The first field is 1, the second field is 2, and so on."
msgstr ""

#: ../doc/book/box/box_space.rst:1590
msgid "Negative field number. The last field is -1, the second-last field is -2, and so on. In other words: (#tuple + negative field number + 1)."
msgstr ""

#: ../doc/book/box/box_space.rst:1591
msgid "Name. If the space was formatted with :ref:`space_object:format() <box_space-format>`, then this can be a string for the field 'name'."
msgstr ""

#: ../doc/book/box/box_space.rst:1604
msgid "**Possible errors:** it is illegal to modify a primary-key field."
msgstr ""

#: ../doc/book/box/box_space.rst:1606
#: ../doc/book/box/box_space.rst:1727
msgid "**Complexity factors:** Index size, Index type, number of indexes accessed, WAL settings."
msgstr ""

#: ../doc/book/box/box_space.rst:1609
msgid "Thus, in the instruction:"
msgstr ""

#: ../doc/book/box/box_space.rst:1611
msgid "s:update(44, {{'+', 1, 55 }, {'=', 3, 'x'}})"
msgstr ""

#: ../doc/book/box/box_space.rst:1615
msgid "the primary-key value is ``44``, the operators are ``'+'`` and ``'='`` meaning *add a value to a field and then assign a value to a field*, the first affected field is field ``1`` and the value which will be added to it is ``55``, the second affected field is field ``3`` and the value which will be assigned to it is ``'x'``."
msgstr ""

#: ../doc/book/box/box_space.rst:1623
msgid "Assume that initially there is a space named ``tester`` with a primary-key index whose type is ``unsigned``. There is one tuple, with ``field[1]`` = ``999`` and ``field[2]`` = ``'A'``."
msgstr ""

#: ../doc/book/box/box_space.rst:1627
msgid "In the update: |br| ``box.space.tester:update(999, {{'=', 2, 'B'}})`` |br| The first argument is ``tester``, that is, the affected space is ``tester``. The second argument is ``999``, that is, the affected tuple is identified by primary key value = 999. The third argument is ``=``, that is, there is one operation — *assignment to a field*. The fourth argument is ``2``, that is, the affected field is ``field[2]``. The fifth argument is ``'B'``, that is, ``field[2]`` contents change to ``'B'``. Therefore, after this update, ``field[1]`` = ``999`` and ``field[2]`` = ``'B'``."
msgstr ""

#: ../doc/book/box/box_space.rst:1638
msgid "In the update: |br| ``box.space.tester:update({999}, {{'=', 2, 'B'}})`` |br| the arguments are the same, except that the key is passed as a Lua table (inside braces). This is unnecessary when the primary key has only one field, but would be necessary if the primary key had more than one field. Therefore, after this update, ``field[1]`` = ``999`` and ``field[2]`` = ``'B'`` (no change)."
msgstr ""

#: ../doc/book/box/box_space.rst:1645
msgid "In the update: |br| ``box.space.tester:update({999}, {{'=', 3, 1}})`` |br| the arguments are the same, except that the fourth argument is ``3``, that is, the affected field is ``field[3]``. It is okay that, until now, ``field[3]`` has not existed. It gets added. Therefore, after this update, ``field[1]`` = ``999``, ``field[2]`` = ``'B'``, ``field[3]`` = ``1``."
msgstr ""

#: ../doc/book/box/box_space.rst:1652
msgid "In the update: |br| ``box.space.tester:update({999}, {{'+', 3, 1}})`` |br| the arguments are the same, except that the third argument is ``'+'``, that is, the operation is addition rather than assignment. Since ``field[3]`` previously contained ``1``, this means we're adding ``1`` to ``1``. Therefore, after this update, ``field[1]`` = ``999``, ``field[2]`` = ``'B'``, ``field[3]`` = ``2``."
msgstr ""

#: ../doc/book/box/box_space.rst:1660
msgid "In the update: |br| ``box.space.tester:update({999}, {{'|', 3, 1}, {'=', 2, 'C'}})`` |br| the idea is to modify two fields at once. The formats are ``'|'`` and ``=``, that is, there are two operations, OR and assignment. The fourth and fifth arguments mean that ``field[3]`` gets OR'ed with ``1``. The seventh and eighth arguments mean that ``field[2]`` gets assigned ``'C'``. Therefore, after this update, ``field[1]`` = ``999``, ``field[2]`` = ``'C'``, ``field[3]`` = ``3``."
msgstr ""

#: ../doc/book/box/box_space.rst:1669
msgid "In the update: |br| ``box.space.tester:update({999}, {{'#', 2, 1}, {'-', 2, 3}})`` |br| The idea is to delete ``field[2]``, then subtract ``3`` from ``field[3]``. But after the delete, there is a renumbering, so ``field[3]`` becomes ``field[2]`` before we subtract ``3`` from it, and that's why the seventh argument is ``2``, not ``3``. Therefore, after this update, ``field[1]`` = ``999``, ``field[2]`` = ``0``."
msgstr ""

#: ../doc/book/box/box_space.rst:1677
msgid "In the update: |br| ``box.space.tester:update({999}, {{'=', 2, 'XYZ'}})`` |br| we're making a long string so that splice will work in the next example. Therefore, after this update, ``field[1]`` = ``999``, ``field[2]`` = ``'XYZ'``."
msgstr ""

#: ../doc/book/box/box_space.rst:1682
msgid "In the update: |br| ``box.space.tester:update({999}, {{':', 2, 2, 1, '!!'}})`` |br| The third argument is ``':'``, that is, this is the example of splice. The fourth argument is ``2`` because the change will occur in ``field[2]``. The fifth argument is 2 because deletion will begin with the second byte. The sixth argument is 1 because the number of bytes to delete is 1. The seventh argument is ``'!!'``, because ``'!!'`` is to be added at this position. Therefore, after this update, ``field[1]`` = ``999``, ``field[2]`` = ``'X!!Z'``."
msgstr ""

#: ../doc/book/box/box_space.rst:1699
msgid "Update or insert a tuple."
msgstr ""

#: ../doc/book/box/box_space.rst:1701
msgid "If there is an existing tuple which matches the key fields of ``tuple``, then the request has the same effect as :ref:`space_object:update() <box_space-update>` and the ``{{operator, field_identifier, value}, ...}`` parameter is used. If there is no existing tuple which matches the key fields of ``tuple``, then the request has the same effect as :ref:`space_object:insert() <box_space-insert>` and the ``{tuple}`` parameter is used. However, unlike ``insert`` or ``update``, ``upsert`` will not read a tuple and perform error checks before returning -- this is a design feature which enhances throughput but requires more caution on the part of the user."
msgstr ""

#: ../doc/book/box/box_space.rst:1713
msgid "default tuple to be inserted, if analogue isn't found"
msgstr ""

#: ../doc/book/box/box_space.rst:1716
msgid "what field the operation will apply to"
msgstr ""

#: ../doc/book/box/box_space.rst:1719
msgid "null"
msgstr ""

#: ../doc/book/box/box_space.rst:1723
msgid "It is illegal to modify a primary-key field."
msgstr ""

#: ../doc/book/box/box_space.rst:1724
msgid "It is illegal to use upsert with a space that has a unique secondary index."
msgstr ""

#: ../doc/book/box/box_space.rst:1732
msgid "box.space.tester:upsert({12,'c'}, {{'=', 3, 'a'}, {'=', 4, 'b'}})"
msgstr ""

#: ../doc/book/box/box_space.rst:1744
msgid "Users can define any functions they want, and associate them with spaces: in effect they can make their own space methods. They do this by:"
msgstr ""

#: ../doc/book/box/box_space.rst:1751
msgid "invoking the function any time thereafter, as long as the server is up, by saying ``space_object:function-name([parameters])``."
msgstr ""

#: ../doc/book/box/box_space.rst:1754
msgid "The predefined global variable is ``box.schema.space_mt``. Adding to ``box.schema.space_mt`` makes the method available for all spaces."
msgstr ""

#: ../doc/book/box/box_space.rst:1757
msgid "Alternatively, user-defined methods can be made available for only one space, by calling ``getmetatable(space_object)`` and then adding the function name to the meta table. See also the example for :ref:`index_object:user_defined() <box_index-user_defined>`."
msgstr ""

#: ../doc/book/box/box_space.rst:1768
msgid "-- Visible to any space, no parameters.\n"
"-- After these requests, the value of global_variable will be 6.\n"
"box.schema.space.create('t')\n"
"box.space.t:create_index('i')\n"
"global_variable = 5\n"
"function f(space_arg) global_variable = global_variable + 1 end\n"
"box.schema.space_mt.counter = f\n"
"box.space.t:counter()"
msgstr ""

#: ../doc/book/box/box_space.rst:1784
msgid "Create a check constraint. A check constraint is a requirement that must be met when a tuple is inserted or updated in a space. Check constraints created with ``space_object:create_check_constraint`` have the same effect as check constraints created with an SQL CHECK() clause in a :ref:`CREATE TABLE statement <sql_create_table>`."
msgstr ""

#: ../doc/book/box/box_space.rst:1793
msgid "name of check constraint, which should conform to the :ref:`rules for object names <app_server-names>`"
msgstr ""

#: ../doc/book/box/box_space.rst:1795
msgid "SQL code of an expression which must return a boolean result"
msgstr ""

#: ../doc/book/box/box_space.rst:1797
msgid "check constraint object"
msgstr ""

#: ../doc/book/box/box_space.rst:1798
msgid "check_constraint_object"
msgstr ""

#: ../doc/book/box/box_space.rst:1800
msgid "The space must be formatted with :ref:`space_object:format() <box_space-format>` so that the expression can contain field names. The space must be empty. The space must not be a system space."
msgstr ""

#: ../doc/book/box/box_space.rst:1804
msgid "The expression must return true or false and should be deterministic. The expresion may be any SQL (not Lua) expression containing field names, built-in function names, literals, and operators. Not subqueries. If a field name contains lower case characters, it must be enclosed in \"double quotes\"."
msgstr ""

#: ../doc/book/box/box_space.rst:1809
msgid "Check constraints are checked before the request is performed, at the same time as Lua :ref:`before_replace triggers <box_space-before_replace>`. If there is more than one check constraint or before_replace trigger, then they are ordered according to time of creation. (This is a change from the earlier behavior of check constraints, which caused checking before the tuple was formed.)"
msgstr ""

#: ../doc/book/box/box_space.rst:1816
msgid "Check constraints can be dropped with :samp:`space_object:{check_constraint_name}:drop()`."
msgstr ""

#: ../doc/book/box/box_space.rst:1820
msgid "box.schema.space.create('t')\n"
"box.space.t:format({{name = 'f1', type = 'unsigned'},\n"
"                    {name = 'f2', type = 'string'},\n"
"                    {name = 'f3', type = 'string'}})\n"
"box.space.t:create_index('i')\n"
"box.space.t:create_check_constraint('c1', [[\"f2\" > 'A']])\n"
"box.space.t:create_check_constraint('c2',\n"
"                        [[\"f2\"=UPPER(\"f3\") AND NOT \"f2\" LIKE '__']])\n"
"-- This insert will fail, constraint c1 expression returns false\n"
"box.space.t:insert{1, 'A', 'A'}\n"
"-- This insert will fail, constraint c2 expression returns false\n"
"box.space.t:insert{1, 'B', 'c'}\n"
"-- This insert will succeed, both constraint expressions return true\n"
"box.space.t:insert{1, 'B', 'b'}\n"
"-- This update will fail, constraint c2 expression returns false\n"
"box.space.t:update(1, {{'=', 2, 'xx'}, {'=', 3, 'xx'}})"
msgstr ""

#: ../doc/book/box/box_space.rst:1839
msgid "A list of check constraints is in :ref:`space_object._ck_constraint <box_space-ck_constraint>`."
msgstr ""

#: ../doc/book/box/box_space.rst:1845
msgid "Whether or not this space is enabled. The value is ``false`` if the space has no index."
msgstr ""

#: ../doc/book/box/box_space.rst:1852
msgid "The required field count for all tuples in this space. The field_count can be set initially with:"
msgstr ""

#: ../doc/book/box/box_space.rst:1892
msgid "box.schema.space.create(..., {\n"
"    ... ,\n"
"    field_count = *field_count_value* ,\n"
"    ...\n"
"})"
msgstr ""

#: ../doc/book/box/box_space.rst:1864
msgid "The default value is ``0``, which means there is no required field count."
msgstr ""

#: ../doc/book/box/box_space.rst:1868
msgid "tarantool> box.space.tester.field_count\n"
"---\n"
"- 0\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:1879
msgid "Ordinal space number. Spaces can be referenced by either name or number. Thus, if space ``tester`` has ``id = 800``, then ``box.space.tester:insert{0}`` and ``box.space[800]:insert{0}`` are equivalent requests."
msgstr ""

#: ../doc/book/box/box_space.rst:1886
msgid "tarantool> box.space.tester.id\n"
"---\n"
"- 512\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:1897
msgid "A container for all defined indexes. There is a Lua object of type :ref:`box.index <box_index>` with methods to search tuples and iterate over them in predefined order."
msgstr ""

#: ../doc/book/box/box_space.rst:1901
msgid "To reset, use :ref:`box.stat.reset() <box_introspection-box_stat_reset>`."
msgstr ""

#: ../doc/book/box/box_space.rst:1907
msgid "# checking the number of indexes for space 'tester'\n"
"tarantool> local counter=0; for i=0,#box.space.tester.index do\n"
"  if box.space.tester.index[i]~=nil then counter=counter+1 end\n"
"  end; print(counter)\n"
"1\n"
"---\n"
"...\n"
"# checking the type of index 'primary'\n"
"tarantool> box.space.tester.index.primary.type\n"
"---\n"
"- TREE\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:1926
msgid "``_cluster`` is a system space for support of the :ref:`replication feature <replication>`."
msgstr ""

#: ../doc/book/box/box_space.rst:1933
msgid "``_func`` is a system space with function tuples made by :ref:`box.schema.func.create() <box_schema-func_create>` or :ref:`box.schema.func.create(func-name [, {options-with-body}]) <box_schema-func_create_with-body>`."
msgstr ""

#: ../doc/book/box/box_space.rst:1938
#: ../doc/book/box/box_space.rst:2006
#: ../doc/book/box/box_space.rst:2046
#: ../doc/book/box/box_space.rst:2148
#: ../doc/book/box/box_space.rst:2245
#: ../doc/book/box/box_space.rst:2386
msgid "Tuples in this space contain the following fields:"
msgstr ""

#: ../doc/book/box/box_space.rst:1940
msgid "id (integer identifier),"
msgstr ""

#: ../doc/book/box/box_space.rst:1941
msgid "owner (integer identifier),"
msgstr ""

#: ../doc/book/box/box_space.rst:1942
msgid "the function name,"
msgstr ""

#: ../doc/book/box/box_space.rst:1943
msgid "the setuid flag,"
msgstr ""

#: ../doc/book/box/box_space.rst:1944
msgid "a language name (optional): 'LUA' (default) or 'C'."
msgstr ""

#: ../doc/book/box/box_space.rst:1945
msgid "the body"
msgstr ""

#: ../doc/book/box/box_space.rst:1946
msgid "the is_deterministic flag"
msgstr ""

#: ../doc/book/box/box_space.rst:1947
msgid "the is_sandboxed flag"
msgstr ""

#: ../doc/book/box/box_space.rst:1948
msgid "options"
msgstr ""

#: ../doc/book/box/box_space.rst:1950
msgid "If the function tuple was made in the older way without specification of ``body``, then the ``_func`` space will contain default values for the body and the is_deterministic flag and the is_sandboxed flag. Such function tuples are called \"not persistent\". You continue to create Lua functions in the usual way, by saying ``function function_name () ... end``, without adding anything in the ``_func`` space. The ``_func`` space only exists for storing function tuples so that their names can be used within :ref:`grant/revoke <authentication-owners_privileges>` functions."
msgstr ""

#: ../doc/book/box/box_space.rst:1961
msgid "If the function tuple was made the newer way with specification of ``body``, then all the fields may contain non-default values. Such functions are called \"persistent\". They should be invoked with :samp:`box.func.{func-name}:call([parameters])`."
msgstr ""

#: ../doc/book/box/box_space.rst:1966
#: ../doc/book/box/box_space.rst:2056
#: ../doc/book/cartridge/cartridge_dev.rst:501
msgid "You can:"
msgstr ""

#: ../doc/book/box/box_space.rst:1968
msgid "Create a ``_func`` tuple with :ref:`box.schema.func.create() <box_schema-func_create>`,"
msgstr ""

#: ../doc/book/box/box_space.rst:1970
msgid "Drop a ``_func`` tuple with :ref:`box.schema.func.drop() <box_schema-func_drop>`,"
msgstr ""

#: ../doc/book/box/box_space.rst:1972
msgid "Check whether a ``_func`` tuple exists with :ref:`box.schema.func.exists() <box_schema-func_exists>`."
msgstr ""

#: ../doc/book/box/box_space.rst:1977
msgid "In the following example, we create a function named ‘f7’, put it into Tarantool's ``_func`` space and grant 'execute' privilege for this function to 'guest' user."
msgstr ""

#: ../doc/book/box/box_space.rst:1981
msgid "tarantool> function f7()\n"
"         >  box.session.uid()\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> box.schema.func.create('f7')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('guest', 'execute', 'function', 'f7')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.revoke('guest', 'execute', 'function', 'f7')\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:1998
msgid "The :ref:`system view <box_space-system_views>` for ``_func`` is ``_vfunc``."
msgstr ""

#: ../doc/book/box/box_space.rst:2004
msgid "``_index`` is a system space."
msgstr ""

#: ../doc/book/box/box_space.rst:2008
msgid "``id`` (= id of space),"
msgstr ""

#: ../doc/book/box/box_space.rst:2009
msgid "``iid`` (= index number within space),"
msgstr ""

#: ../doc/book/box/box_space.rst:2010
msgid "``name``,"
msgstr ""

#: ../doc/book/box/box_space.rst:2011
msgid "``type``,"
msgstr ""

#: ../doc/book/box/box_space.rst:2012
msgid "``opts`` (e.g. unique option), [``tuple-field-no``, ``tuple-field-type`` ...]."
msgstr ""

#: ../doc/book/box/box_space.rst:2014
msgid "Here is what ``_index`` contains in a typical installation:"
msgstr ""

#: ../doc/book/box/box_space.rst:2016
msgid "tarantool> box.space._index:select{}\n"
"---\n"
"- - [272, 0, 'primary', 'tree', {'unique': true}, [[0, 'string']]]\n"
"  - [280, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned']]]\n"
"  - [280, 1, 'owner', 'tree', {'unique': false}, [[1, 'unsigned']]]\n"
"  - [280, 2, 'name', 'tree', {'unique': true}, [[2, 'string']]]\n"
"  - [281, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned']]]\n"
"  - [281, 1, 'owner', 'tree', {'unique': false}, [[1, 'unsigned']]]\n"
"  - [281, 2, 'name', 'tree', {'unique': true}, [[2, 'string']]]\n"
"  - [288, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned'], [1, 'unsigned']]]\n"
"  - [288, 2, 'name', 'tree', {'unique': true}, [[0, 'unsigned'], [2, 'string']]]\n"
"  - [289, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned'], [1, 'unsigned']]]\n"
"  - [289, 2, 'name', 'tree', {'unique': true}, [[0, 'unsigned'], [2, 'string']]]\n"
"  - [296, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned']]]\n"
"  - [296, 1, 'owner', 'tree', {'unique': false}, [[1, 'unsigned']]]\n"
"  - [296, 2, 'name', 'tree', {'unique': true}, [[2, 'string']]]\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:2037
msgid "The :ref:`system view <box_space-system_views>` for ``_index`` is ``_vindex``."
msgstr ""

#: ../doc/book/box/box_space.rst:2043
msgid "``_priv`` is a system space where :ref:`privileges <authentication-owners_privileges>` are stored."
msgstr ""

#: ../doc/book/box/box_space.rst:2048
msgid "the numeric id of the user who gave the privilege (\"grantor_id\"),"
msgstr ""

#: ../doc/book/box/box_space.rst:2049
msgid "the numeric id of the user who received the privilege (\"grantee_id\"),"
msgstr ""

#: ../doc/book/box/box_space.rst:2050
msgid "the type of object: 'space', 'function', 'sequence' or 'universe',"
msgstr ""

#: ../doc/book/box/box_space.rst:2051
msgid "the numeric id of the object,"
msgstr ""

#: ../doc/book/box/box_space.rst:2052
msgid "the type of operation: \"read\" = 1, \"write\" = 2, \"execute\" = 4, \"create\" = 32, \"drop\" = 64, \"alter\" = 128, or a combination such as \"read,write,execute\"."
msgstr ""

#: ../doc/book/box/box_space.rst:2058
msgid "Grant a privilege with :ref:`box.schema.user.grant() <box_schema-user_grant>`."
msgstr ""

#: ../doc/book/box/box_space.rst:2059
msgid "Revoke a privilege with :ref:`box.schema.user.revoke() <box_schema-user_revoke>`."
msgstr ""

#: ../doc/book/box/box_space.rst:2063
msgid "Generally, privileges are granted or revoked by the owner of the object (the user who created it), or by the 'admin' user."
msgstr ""

#: ../doc/book/box/box_space.rst:2066
msgid "Before dropping any objects or users, make sure that all their associated privileges have been revoked."
msgstr ""

#: ../doc/book/box/box_space.rst:2069
msgid "Only the :ref:`'admin' user <authentication-owners_privileges>` can grant privileges for the 'universe'."
msgstr ""

#: ../doc/book/box/box_space.rst:2072
msgid "Only the 'admin' user or the creator of a space can drop, alter, or truncate the space."
msgstr ""

#: ../doc/book/box/box_space.rst:2075
msgid "Only the 'admin' user or the creator of a user can change a different user’s password."
msgstr ""

#: ../doc/book/box/box_space.rst:2078
msgid "The :ref:`system view <box_space-system_views>` for ``_priv`` is ``__vpriv``."
msgstr ""

#: ../doc/book/box/box_space.rst:2084
msgid "``_schema`` is a system space."
msgstr ""

#: ../doc/book/box/box_space.rst:2086
msgid "This space contains the following tuples:"
msgstr ""

#: ../doc/book/box/box_space.rst:2088
msgid "``version`` tuple with version information for this Tarantool instance,"
msgstr ""

#: ../doc/book/box/box_space.rst:2089
msgid "``cluster`` tuple with the instance's replica set ID,"
msgstr ""

#: ../doc/book/box/box_space.rst:2090
msgid "``max_id`` tuple with the maximal space ID,"
msgstr ""

#: ../doc/book/box/box_space.rst:2091
msgid "``once...`` tuples that correspond to specific :ref:`box.once() <box-once>` blocks from the instance's :ref:`initialization file <index-init_label>`. The first field in these tuples contains the ``key`` value from the corresponding ``box.once()`` block prefixed with 'once' (e.g. `oncehello`), so you can easily find a tuple that corresponds to a specific ``box.once()`` block."
msgstr ""

#: ../doc/book/box/box_space.rst:2101
msgid "Here is what ``_schema`` contains in a typical installation (notice the tuples for two ``box.once()`` blocks, ``'oncebye'`` and ``'oncehello'``):"
msgstr ""

#: ../doc/book/box/box_space.rst:2104
msgid "tarantool> box.space._schema:select{}\n"
"---\n"
"- - ['cluster', 'b4e15788-d962-4442-892e-d6c1dd5d13f2']\n"
"  - ['max_id', 512]\n"
"  - ['oncebye']\n"
"  - ['oncehello']\n"
"  - ['version', 1, 7, 2]"
msgstr ""

#: ../doc/book/box/box_space.rst:2118
msgid "``_sequence`` is a system space for support of the :ref:`sequence feature <index-box_sequence>`. It contains persistent information that was established by :ref:`box.schema.sequence.create() <box_schema-sequence_create>` or :ref:`box.schema.sequence.alter() <box_schema-sequence_alter>`."
msgstr ""

#: ../doc/book/box/box_space.rst:2124
msgid "The :ref:`system view <box_space-system_views>` for ``_sequence`` is ``_vsequence``."
msgstr ""

#: ../doc/book/box/box_space.rst:2130
msgid "``_sequence_data`` is a system space for support of the :ref:`sequence feature <index-box_sequence>`."
msgstr ""

#: ../doc/book/box/box_space.rst:2133
msgid "Each tuple in ``_sequence_data`` contains two fields:"
msgstr ""

#: ../doc/book/box/box_space.rst:2135
msgid "the id of the sequence, and"
msgstr ""

#: ../doc/book/box/box_space.rst:2136
msgid "the last value that the sequence generator returned (non-persistent information)."
msgstr ""

#: ../doc/book/box/box_space.rst:2139
msgid "There is no guarantee that this space will be updated immediately after every data-change request."
msgstr ""

#: ../doc/book/box/box_space.rst:2146
msgid "``_space`` is a system space."
msgstr ""

#: ../doc/book/box/box_space.rst:2150
msgid "``id``,"
msgstr ""

#: ../doc/book/box/box_space.rst:2151
msgid "``owner`` (= id of user who owns the space),"
msgstr ""

#: ../doc/book/box/box_space.rst:2152
msgid "``name``, ``engine``, ``field_count``,"
msgstr ""

#: ../doc/book/box/box_space.rst:2153
msgid "``flags`` (e.g. temporary),"
msgstr ""

#: ../doc/book/box/box_space.rst:2154
msgid "``format`` (as made by a :ref:`format clause <box_space-format>`)."
msgstr ""

#: ../doc/book/box/box_space.rst:2156
msgid "These fields are established by :ref:`space.create() <box_schema-space_create>`."
msgstr ""

#: ../doc/book/box/box_space.rst:2161
msgid "The following function will display all simple fields in all tuples of ``_space``."
msgstr ""

#: ../doc/book/box/box_space.rst:2164
msgid "function example()\n"
"  local ta = {}\n"
"  local i, line\n"
"  for k, v in box.space._space:pairs() do\n"
"    i = 1\n"
"    line = ''\n"
"    while i <= #v do\n"
"      if type(v[i]) ~= 'table' then\n"
"        line = line .. v[i] .. ' '\n"
"      end\n"
"    i = i + 1\n"
"    end\n"
"    table.insert(ta, line)\n"
"  end\n"
"  return ta\n"
"end"
msgstr ""

#: ../doc/book/box/box_space.rst:2183
msgid "Here is what ``example()`` returns in a typical installation:"
msgstr ""

#: ../doc/book/box/box_space.rst:2185
msgid "tarantool> example()\n"
"---\n"
"- - '272 1 _schema memtx 0  '\n"
"  - '280 1 _space memtx 0  '\n"
"  - '281 1 _vspace sysview 0  '\n"
"  - '288 1 _index memtx 0  '\n"
"  - '296 1 _func memtx 0  '\n"
"  - '304 1 _user memtx 0  '\n"
"  - '305 1 _vuser sysview 0  '\n"
"  - '312 1 _priv memtx 0  '\n"
"  - '313 1 _vpriv sysview 0  '\n"
"  - '320 1 _cluster memtx 0  '\n"
"  - '512 1 tester memtx 0  '\n"
"  - '513 1 origin vinyl 0  '\n"
"  - '514 1 archive memtx 0  '\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:2206
msgid "The following requests will create a space using ``box.schema.space.create()`` with a :ref:`format clause <box_space-format>`, then retrieve the ``_space`` tuple for the new space. This illustrates the typical use of the ``format`` clause, it shows the recommended names and data types for the fields."
msgstr ""

#: ../doc/book/box/box_space.rst:2212
msgid "tarantool> box.schema.space.create('TM', {\n"
"         >   id = 12345,\n"
"         >   format = {\n"
"         >     [1] = {[\"name\"] = \"field_1\"},\n"
"         >     [2] = {[\"type\"] = \"unsigned\"}\n"
"         >   }\n"
"         > })\n"
"---\n"
"- index: []\n"
"  on_replace: 'function: 0x41c67338'\n"
"  temporary: false\n"
"  id: 12345\n"
"  engine: memtx\n"
"  enabled: false\n"
"  name: TM\n"
"  field_count: 0\n"
"- created\n"
"...\n"
"tarantool> box.space._space:select(12345)\n"
"---\n"
"- - [12345, 1, 'TM', 'memtx', 0, {}, [{'name': 'field_1'}, {'type': 'unsigned'}]]\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:2237
msgid "The :ref:`system view <box_space-system_views>` for ``_space`` is ``_vspace``."
msgstr ""

#: ../doc/book/box/box_space.rst:2243
msgid "``_user`` is a system space where user-names and password hashes are stored."
msgstr ""

#: ../doc/book/box/box_space.rst:2247
msgid "the numeric id of the tuple (\"id\"),"
msgstr ""

#: ../doc/book/box/box_space.rst:2248
msgid "the numeric id of the tuple’s creator,"
msgstr ""

#: ../doc/book/box/box_space.rst:2249
#: ../doc/book/box/box_space.rst:2389
msgid "the name,"
msgstr ""

#: ../doc/book/box/box_space.rst:2250
msgid "the type: 'user' or 'role',"
msgstr ""

#: ../doc/book/box/box_space.rst:2251
msgid "optional password."
msgstr ""

#: ../doc/book/box/box_space.rst:2253
msgid "There are five special tuples in the ``_user`` space: 'guest', 'admin', 'public', 'replication', and 'super'."
msgstr ""

#: ../doc/book/box/box_space.rst:2266
msgid "ID"
msgstr ""

#: ../doc/book/box/box_space.rst:2268
msgid "guest"
msgstr ""

#: ../doc/book/box/box_space.rst:2268
#: ../doc/book/box/data_model.rst:528
#: ../doc/book/cartridge/cartridge_admin.rst:651
#: ../doc/book/cartridge/cartridge_admin.rst:821
msgid "0"
msgstr ""

#: ../doc/book/box/box_space.rst:2268
msgid "Default user when connecting remotely. Usually an untrusted user with few privileges."
msgstr ""

#: ../doc/book/box/box_space.rst:2271
msgid "admin"
msgstr ""

#: ../doc/book/box/box_space.rst:2271
#: ../doc/book/box/data_model.rst:515
#: ../doc/book/box/data_model.rst:519
#: ../doc/book/box/data_model.rst:531
#: ../doc/book/cartridge/cartridge_admin.rst:653
#: ../doc/book/cartridge/cartridge_admin.rst:823
msgid "1"
msgstr ""

#: ../doc/book/box/box_space.rst:2271
msgid "Default user when using Tarantool as a console. Usually an :ref:`administrative user <authentication-owners_privileges>` with all privileges."
msgstr ""

#: ../doc/book/box/box_space.rst:2276
msgid "public"
msgstr ""

#: ../doc/book/box/box_space.rst:2276
#: ../doc/book/box/box_space.rst:2284
#: ../doc/book/box/box_space.rst:2288
msgid "role"
msgstr ""

#: ../doc/book/box/box_space.rst:2276
msgid "Pre-defined :ref:`role <authentication-roles>`, automatically granted to new users when they are created with ``box.schema.user.create(user-name)``. Therefore a convenient way to grant 'read' on space 't' to every user that will ever exist is with ``box.schema.role.grant('public','read','space','t')``."
msgstr ""

#: ../doc/book/box/box_space.rst:2284
msgid "replication"
msgstr ""

#: ../doc/book/box/box_space.rst:2284
#: ../doc/book/cartridge/cartridge_admin.rst:660
#: ../doc/book/cartridge/cartridge_admin.rst:828
msgid "3"
msgstr ""

#: ../doc/book/box/box_space.rst:2284
msgid "Pre-defined :ref:`role <authentication-roles>`, which the 'admin' user can grant to users who need to use :ref:`replication <replication>` features."
msgstr ""

#: ../doc/book/box/box_space.rst:2288
msgid "super"
msgstr ""

#: ../doc/book/box/box_space.rst:2288
msgid "31"
msgstr ""

#: ../doc/book/box/box_space.rst:2288
msgid "Pre-defined :ref:`role <authentication-roles>`, which the 'admin' user can grant to users who need all privileges on all objects. The 'super' role has these privileges on 'universe': read, write, execute, create, drop, alter."
msgstr ""

#: ../doc/book/box/box_space.rst:2296
msgid "To select a tuple from the ``_user`` space, use ``box.space._user:select()``. For example, here is what happens with a select for user id = 0, which is the 'guest' user, which by default has no password:"
msgstr ""

#: ../doc/book/box/box_space.rst:2300
msgid "tarantool> box.space._user:select{0}\n"
"---\n"
"- - [0, 1, 'guest', 'user']\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:2309
msgid "To change tuples in the ``_user`` space, do not use ordinary ``box.space`` functions for insert or update or delete. The ``_user`` space is special, so there are special functions which have appropriate error checking."
msgstr ""

#: ../doc/book/box/box_space.rst:2313
msgid "To create a new user, use :ref:`box.schema.user.create() <box_schema-user_create>`:"
msgstr ""

#: ../doc/book/box/box_space.rst:2352
msgid "box.schema.user.create(*user-name*)\n"
"box.schema.user.create(*user-name*, {if_not_exists = true})\n"
"box.schema.user.create(*user-name*, {password = *password*})"
msgstr ""

#: ../doc/book/box/box_space.rst:2322
msgid "To change the user's password, use :ref:`box.schema.user.password() <box_schema-user_password>`:"
msgstr ""

#: ../doc/book/box/box_space.rst:2361
msgid "-- To change the current user's password\n"
"box.schema.user.passwd(*password*)\n"
"\n"
"-- To change a different user's password\n"
"-- (usually only 'admin' can do it)\n"
"box.schema.user.passwd(*user-name*, *password*)"
msgstr ""

#: ../doc/book/box/box_space.rst:2334
msgid "To drop a user, use :ref:`box.schema.user.drop() <box_schema-user_drop>`:"
msgstr ""

#: ../doc/book/box/box_space.rst:2373
msgid "box.schema.user.drop(*user-name*)"
msgstr ""

#: ../doc/book/box/box_space.rst:2341
msgid "To check whether a user exists, use :ref:`box.schema.user.exists() <box_schema-user_exists>`, which returns ``true`` or ``false``:"
msgstr ""

#: ../doc/book/box/box_space.rst:2381
msgid "box.schema.user.exists(*user-name*)"
msgstr ""

#: ../doc/book/box/box_space.rst:2349
msgid "To find what privileges a user has, use :ref:`box.schema.user.info() <box_schema-user_info>`:"
msgstr ""

#: ../doc/book/box/box_space.rst:2388
msgid "box.schema.user.info(*user-name*)"
msgstr ""

#: ../doc/book/box/box_space.rst:2362
msgid "Here is a session which creates a new user with a strong password, selects a tuple in the ``_user`` space, and then drops the user."
msgstr ""

#: ../doc/book/box/box_space.rst:2365
msgid "tarantool> box.schema.user.create('JeanMartin', {password = 'Iwtso_6_os$$'})\n"
"---\n"
"...\n"
"tarantool> box.space._user.index.name:select{'JeanMartin'}\n"
"---\n"
"- - [17, 1, 'JeanMartin', 'user', {'chap-sha1': 't3xjUpQdrt857O+YRvGbMY5py8Q='}]\n"
"...\n"
"tarantool> box.schema.user.drop('JeanMartin')\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:2378
msgid "The :ref:`system view <box_space-system_views>` for ``_user`` is ``_vuser``."
msgstr ""

#: ../doc/book/box/box_space.rst:2384
msgid "``_ck_constraint`` is a system space where check constraints are stored."
msgstr ""

#: ../doc/book/box/box_space.rst:2388
msgid "the numeric id of the space (\"space_id\"),"
msgstr ""

#: ../doc/book/box/box_space.rst:2390
msgid "whether the check is deferred (\"is_deferred\"),"
msgstr ""

#: ../doc/book/box/box_space.rst:2391
msgid "the language of the expression, such as 'SQL',"
msgstr ""

#: ../doc/book/box/box_space.rst:2392
msgid "the expression (\"code\")"
msgstr ""

#: ../doc/book/box/box_space.rst:2396
msgid "tarantool> box.space._ck_constraint:select()\n"
"---\n"
"- - [527, 'c1', false, 'SQL', '\"f2\" > ''A''']\n"
"  - [527, 'c2', false, 'SQL', '\"f2\" == UPPER(\"f3\") AND NOT \"f2\" LIKE ''__''']\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:2406
msgid "Example: using box.space functions to read _space tuples"
msgstr ""

#: ../doc/book/box/box_space.rst:2408
msgid "This function will illustrate how to look at all the spaces, and for each display: approximately how many tuples it contains, and the first field of its first tuple. The function uses Tarantool ``box.space`` functions ``len()`` and ``pairs()``. The iteration through the spaces is coded as a scan of the ``_space`` system space, which contains metadata. The third field in ``_space`` contains the space name, so the key instruction ``space_name = v[3]`` means ``space_name`` is the ``space_name`` field in the tuple of ``_space`` that we've just fetched with ``pairs()``. The function returns a table:"
msgstr ""

#: ../doc/book/box/box_space.rst:2418
msgid "function example()\n"
"  local tuple_count, space_name, line\n"
"  local ta = {}\n"
"  for k, v in box.space._space:pairs() do\n"
"    space_name = v[3]\n"
"    if box.space[space_name].index[0] ~= nil then\n"
"      tuple_count = '1 or more'\n"
"    else\n"
"      tuple_count = '0'\n"
"    end\n"
"    line = space_name .. ' tuple_count =' .. tuple_count\n"
"    if tuple_count == '1 or more' then\n"
"      for k1, v1 in box.space[space_name]:pairs() do\n"
"        line = line .. '. first field in first tuple = ' .. v1[1]\n"
"        break\n"
"      end\n"
"    end\n"
"    table.insert(ta, line)\n"
"  end\n"
"  return ta\n"
"end"
msgstr ""

#: ../doc/book/box/box_space.rst:2442
msgid "And here is what happens when one invokes the function:"
msgstr ""

#: ../doc/book/box/box_space.rst:2444
msgid "tarantool> example()\n"
"---\n"
"- - _schema tuple_count =1 or more. first field in first tuple = cluster\n"
"  - _space tuple_count =1 or more. first field in first tuple = 272\n"
"  - _vspace tuple_count =1 or more. first field in first tuple = 272\n"
"  - _index tuple_count =1 or more. first field in first tuple = 272\n"
"  - _vindex tuple_count =1 or more. first field in first tuple = 272\n"
"  - _func tuple_count =1 or more. first field in first tuple = 1\n"
"  - _vfunc tuple_count =1 or more. first field in first tuple = 1\n"
"  - _user tuple_count =1 or more. first field in first tuple = 0\n"
"  - _vuser tuple_count =1 or more. first field in first tuple = 0\n"
"  - _priv tuple_count =1 or more. first field in first tuple = 1\n"
"  - _vpriv tuple_count =1 or more. first field in first tuple = 1\n"
"  - _cluster tuple_count =1 or more. first field in first tuple = 1\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:2464
msgid "Example: using box.space functions to organize a _space tuple"
msgstr ""

#: ../doc/book/box/box_space.rst:2466
msgid "The objective is to display field names and field types of a system space -- using metadata to find metadata."
msgstr ""

#: ../doc/book/box/box_space.rst:2469
msgid "To begin: how can one select the ``_space`` tuple that describes ``_space``?"
msgstr ""

#: ../doc/book/box/box_space.rst:2471
msgid "A simple way is to look at the constants in ``box.schema``, which tell us that there is an item named SPACE_ID == 288, so these statements will retrieve the correct tuple:"
msgstr ""

#: ../doc/book/box/box_space.rst:2475
msgid "box.space._space:select{ 288 }\n"
"-- or --\n"
"box.space._space:select{ box.schema.SPACE_ID }"
msgstr ""

#: ../doc/book/box/box_space.rst:2481
msgid "Another way is to look at the tuples in ``box.space._index``, which tell us that there is a secondary index named 'name' for space number 288, so this statement also will retrieve the correct tuple:"
msgstr ""

#: ../doc/book/box/box_space.rst:2485
msgid "box.space._space.index.name:select{ '_space' }"
msgstr ""

#: ../doc/book/box/box_space.rst:2489
msgid "However, the retrieved tuple is not easy to read:"
msgstr ""

#: ../doc/book/box/box_space.rst:2491
msgid "tarantool> box.space._space.index.name:select{'_space'}\n"
"---\n"
"- - [280, 1, '_space', 'memtx', 0, {}, [{'name': 'id', 'type': 'num'}, {'name': 'owner',\n"
"        'type': 'num'}, {'name': 'name', 'type': 'str'}, {'name': 'engine', 'type': 'str'},\n"
"      {'name': 'field_count', 'type': 'num'}, {'name': 'flags', 'type': 'str'}, {\n"
"        'name': 'format', 'type': '*'}]]\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:2501
msgid "It looks disorganized because field number 7 has been formatted with recommended names and data types. How can one get those specific sub-fields? Since it's visible that field number 7 is an array of maps, this `for` loop will do the organizing:"
msgstr ""

#: ../doc/book/box/box_space.rst:2506
msgid "tarantool> do\n"
"         >   local tuple_of_space = box.space._space.index.name:get{'_space'}\n"
"         >   for _, field in ipairs(tuple_of_space[7]) do\n"
"         >     print(field.name .. ', ' .. field.type)\n"
"         >   end\n"
"         > end\n"
"id, num\n"
"owner, num\n"
"name, str\n"
"engine, str\n"
"field_count, num\n"
"flags, str\n"
"format, *\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:2528
msgid "``_collation`` is a system space with a list of :ref:`collations <index-collation>`. There are over 270 built-in collations and users may add more. Here is one example:"
msgstr ""

#: ../doc/book/box/box_space.rst:2531
msgid "localhost:3301> box.space._collation:select(239)\n"
"---\n"
"- - [239, 'unicode_uk_s2', 1, 'ICU', 'uk', {'strength': 'secondary'}]\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:2538
msgid "Explanation of the fields in the example: id = 239 i.e. Tarantool's primary key is 239, name = 'unicode_uk_s2' i.e. according to Tarantool's naming convention this is a Unicode collation + it is for the uk locale + it has secondary strength, owner = 1 i.e. :ref:`the admin user <authentication-owners_privileges>`, type = 'ICU' i.e. the rules are according to `International Components for Unicode <http://site.icu-project.org/home>`_, locale = 'uk' i.e. `Ukrainian <http://www.unicode.org/cldr/charts/29/collation/uk.html>`_, opts = 'strength:secondary' i.e. with this collation comparisons use both primary and secondary `weights <https://unicode.org/reports/tr10/#Weight_Level_Defn>`_."
msgstr ""

#: ../doc/book/box/box_space.rst:2547
msgid "The :ref:`system view <box_space-system_views>` for ``_collation`` is ``_vcollation``."
msgstr ""

#: ../doc/book/box/box_space.rst:2553
msgid "System views"
msgstr ""

#: ../doc/book/box/box_space.rst:2555
msgid "A system view, also called a 'sysview', is a restricted copy of a system space."
msgstr ""

#: ../doc/book/box/box_space.rst:2557
msgid "The system views and the spaces that they are associated with are: |br| ``_vcollation``, a view of :ref:`_collation <box_space-collation>`, |br| ``_vfunc``, a view of :ref:`_func <box_space-func>`, |br| ``_vindex``, a view of :ref:`_index <box_space-index>`, |br| ``_vpriv``, a view of :ref:`_priv <box_space-priv>`, |br| ``_vsequence``, a view of :ref:`_sequence <box_space-sequence>`, |br| ``_vspace``, a view of :ref:`_space <box_space-space>`, |br| ``_vuser``, a view of :ref:`_user <box_space-user>`."
msgstr ""

#: ../doc/book/box/box_space.rst:2566
msgid "The structure of a system view's tuples is identical to the structure of the associated space's tuples. However, the privileges for a system view are usually different. By default, ordinary users do not have any privileges for most system spaces, but have a 'read' privilege for system views."
msgstr ""

#: ../doc/book/box/box_space.rst:2571
msgid "Typically this is the default situation: |br| * :ref:`The 'public' role <box_space-user>` has 'read' privilege on all system views because that is the situation when the database is first created. |br| * All users have the 'public' role, because it is granted to them automatically during :ref:`box.schema.user.create() <box_schema-user_create>`. |br| * The system view will contain the tuples in the associated system space, if and only if the user has a privilege for the object named in the tuple. |br| Unless administrators change the privileges, the effect is that non-administrator users cannot access the system space, but they can access the system view, which shows only the the objects that they can access."
msgstr ""

#: ../doc/book/box/box_space.rst:2582
msgid "For example, typically, the 'admin' user can do anything with ``_space`` and ``_vspace`` looks the same as ``_space``. But the 'guest' user can only read ``_vspace``, and ``_vspace`` contains fewer tuples than ``_space``. Therefore in most installations the 'guest' user should select from ``_vspace`` to get a list of spaces."
msgstr ""

#: ../doc/book/box/box_space.rst:2587
msgid "See :ref:`Access control <authentication>` for details about user privileges."
msgstr ""

#: ../doc/book/box/box_space.rst:2589
msgid "Here is an example showing the difference between ``_vuser`` and ``_user``. We have explained that: If the user has the full set of privileges (like 'admin'), the contents of ``_vuser`` match the contents of ``_user``. If the user has limited access, ``_vuser`` contains only tuples accessible to this user."
msgstr ""

#: ../doc/book/box/box_space.rst:2595
msgid "To see how ``_vuser`` works, :ref:`connect to a Tarantool database remotely <connecting-remotely>` via ``tarantoolctl`` and select all tuples from the ``_user`` space, both when the 'guest' user *is* and *is not* allowed to read from the database."
msgstr ""

#: ../doc/book/box/box_space.rst:2601
msgid "First, start Tarantool and grant read, write and execute privileges to the 'guest' user:"
msgstr ""

#: ../doc/book/box/box_space.rst:2604
msgid "tarantool> box.cfg{listen = 3301}\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('guest', 'read,write,execute', 'universe')\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:2613
msgid "Switch to the other terminal, connect to the Tarantool instance and select all tuples from the ``_user`` space:"
msgstr ""

#: ../doc/book/box/box_space.rst:2616
msgid "$ tarantoolctl connect 3301\n"
"localhost:3301> box.space._user:select{}\n"
"---\n"
"- - [0, 1, 'guest', 'user', {}]\n"
"  - [1, 1, 'admin', 'user', {}]\n"
"  - [2, 1, 'public', 'role', {}]\n"
"  - [3, 1, 'replication', 'role', {}]\n"
"  - [31, 1, 'super', 'role', {}]\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:2628
msgid "This result contains the same set of users as if you made the request from your Tarantool instance as 'admin'."
msgstr ""

#: ../doc/book/box/box_space.rst:2631
msgid "Switch to the first terminal and revoke the read privileges from the 'guest' user:"
msgstr ""

#: ../doc/book/box/box_space.rst:2633
msgid "tarantool> box.schema.user.revoke('guest', 'read', 'universe')\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:2639
msgid "Switch to the other terminal, stop the session (to stop ``tarantoolctl``, type Ctrl+C or Ctrl+D) and repeat the ``box.space._user:select{}`` request. The access is denied:"
msgstr ""

#: ../doc/book/box/box_space.rst:2643
msgid "$ tarantoolctl connect 3301\n"
"localhost:3301> box.space._user:select{}\n"
"---\n"
"- error: Read access to space '_user' is denied for user 'guest'\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:2651
msgid "However, if you select from ``_vuser`` instead, the users' data available for the 'guest' user is displayed:"
msgstr ""

#: ../doc/book/box/box_space.rst:2654
msgid "localhost:3301> box.space._vuser:select{}\n"
"---\n"
"- - [0, 1, 'guest', 'user', {}]\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:2665
msgid "Example: using data operations"
msgstr ""

#: ../doc/book/box/box_space.rst:2667
msgid "This example demonstrates all legal scenarios -- as well as typical errors -- for each :ref:`data operation <index-box_data-operations>` in Tarantool: :ref:`INSERT <box_space-operations-insert>`, :ref:`DELETE <box_space-operations-delete>`, :ref:`UPDATE <box_space-operations-update>`, :ref:`UPSERT <box_space-operations-upsert>`, :ref:`REPLACE <box_space-operations-replace>`, and :ref:`SELECT <box_space-operations-select>`."
msgstr ""

#: ../doc/book/box/box_space.rst:2676
msgid "-- Bootstrap the database --\n"
"box.cfg{}\n"
"format = {}\n"
"format[1] = {'field1', 'unsigned'}\n"
"format[2] = {'field2', 'unsigned'}\n"
"format[3] = {'field3', 'unsigned'}\n"
"s = box.schema.create_space('test', {format = format})\n"
"-- Create a primary index --\n"
"pk = s:create_index('pk', {parts = {{'field1'}}})\n"
"-- Create a unique secondary index --\n"
"sk_uniq = s:create_index('sk_uniq', {parts = {{'field2'}}})\n"
"-- Create a non-unique secondary index --\n"
"sk_non_uniq = s:create_index('sk_non_uniq', {parts = {{'field3'}}, unique = false})"
msgstr ""

#: ../doc/book/box/box_space.rst:2696
msgid "INSERT"
msgstr ""

#: ../doc/book/box/box_space.rst:2698
msgid "``insert`` accepts a well-formatted tuple and checks all keys for duplicates."
msgstr ""

#: ../doc/book/box/box_space.rst:2700
msgid "tarantool> -- Unique indexes: ok --\n"
"tarantool> s:insert({1, 1, 1})\n"
"---\n"
"- [1, 1, 1]\n"
"...\n"
"tarantool> -- Conflicting primary key: error --\n"
"tarantool> s:insert({1, 1, 1})\n"
"---\n"
"- error: Duplicate key exists in unique index 'pk' in space 'test'\n"
"...\n"
"tarantool> -- Conflicting unique secondary key: error --\n"
"tarantool> s:insert({2, 1, 1})\n"
"---\n"
"- error: Duplicate key exists in unique index 'sk_uniq' in space 'test'\n"
"...\n"
"tarantool> -- Key {1} exists in sk_non_uniq index, but it is not unique: ok --\n"
"tarantool> s:insert({2, 2, 1})\n"
"---\n"
"- [2, 2, 1]\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:2730
#: ../doc/book/box/engines/vinyl.rst:139
#: ../doc/book/box/engines/vinyl.rst:139
msgid "DELETE"
msgstr ""

#: ../doc/book/box/box_space.rst:2732
msgid "``delete`` accepts a full key of any unique index."
msgstr ""

#: ../doc/book/box/box_space.rst:2734
msgid "``space:delete`` is an alias for \"delete by primary key\"."
msgstr ""

#: ../doc/book/box/box_space.rst:2736
msgid "tarantool> -- Insert some test data --\n"
"tarantool> s:insert{3, 4, 5}\n"
"---\n"
"- [3, 4, 5]\n"
"...\n"
"tarantool> s:insert{6, 7, 8}\n"
"---\n"
"- [6, 7, 8]\n"
"...\n"
"tarantool> s:insert{9, 10, 11}\n"
"---\n"
"- [9, 10, 11]\n"
"...\n"
"tarantool> s:insert{12, 13, 14}\n"
"---\n"
"- [12, 13, 14]\n"
"...\n"
"tarantool> -- Nothing done here: no {4} key in pk index --\n"
"tarantool> s:delete{4}\n"
"---\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 4, 5]\n"
"  - [6, 7, 8]\n"
"  - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Delete by a primary key: ok --\n"
"tarantool> s:delete{3}\n"
"---\n"
"- [3, 4, 5]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [6, 7, 8]\n"
"  - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Explicitly delete by a primary key: ok --\n"
"tarantool> s.index.pk:delete{6}\n"
"---\n"
"- [6, 7, 8]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Delete by a unique secondary key: ok --\n"
"s.index.sk_uniq:delete{10}\n"
"---\n"
"- [9, 10, 11]\n"
"...\n"
"s:select{}\n"
"---\n"
"- - [12, 13, 14]\n"
"...\n"
"tarantool> -- Delete by a non-unique secondary index: error --\n"
"tarantool> s.index.sk_non_uniq:delete{14}\n"
"---\n"
"- error: Get() doesn't support partial keys and non-unique indexes\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [12, 13, 14]\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:2809
msgid "The key must be full: ``delete`` cannot work with partial keys."
msgstr ""

#: ../doc/book/box/box_space.rst:2811
msgid "tarantool> s2 = box.schema.create_space('test2')\n"
"---\n"
"...\n"
"tarantool> pk2 = s2:create_index('pk2', {parts = {{1, 'unsigned'}, {2, 'unsigned'}}})\n"
"---\n"
"...\n"
"tarantool> s2:insert{1, 1}\n"
"---\n"
"- [1, 1]\n"
"...\n"
"tarantool> -- Delete by a partial key: error --\n"
"tarantool> s2:delete{1}\n"
"---\n"
"- error: Invalid key part count in an exact match (expected 2, got 1)\n"
"...\n"
"tarantool> -- Delete by a full key: ok --\n"
"tarantool> s2:delete{1, 1}\n"
"---\n"
"- [1, 1]\n"
"...\n"
"tarantool> s2:select{}\n"
"---\n"
"- []\n"
"...\n"
"tarantool> s2:drop()\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:2845
msgid "UPDATE"
msgstr ""

#: ../doc/book/box/box_space.rst:2847
msgid "Similarly to ``delete``, ``update`` accepts a full key of any unique index, and also the operations to execute."
msgstr ""

#: ../doc/book/box/box_space.rst:2850
msgid "``space:update`` is an alias for \"update by primary key\"."
msgstr ""

#: ../doc/book/box/box_space.rst:2852
msgid "tarantool> -- Insert some test data --\n"
"tarantool> s:insert{3, 4, 5}\n"
"---\n"
"- [3, 4, 5]\n"
"...\n"
"tarantool> s:insert{6, 7, 8}\n"
"---\n"
"- [6, 7, 8]\n"
"...\n"
"tarantool> s:insert{9, 10, 11}\n"
"---\n"
"- [9, 10, 11]\n"
"...\n"
"tarantool> s:insert{12, 13, 14}\n"
"---\n"
"- [12, 13, 14]\n"
"...\n"
"tarantool> -- Nothing done here: no {4} key in pk index --\n"
"s:update({4}, {{'=', 2, 400}})\n"
"---\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 4, 5]\n"
"  - [6, 7, 8]\n"
"  - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Update by a primary key: ok --\n"
"tarantool> s:update({3}, {{'=', 2, 400}})\n"
"---\n"
"- [3, 400, 5]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 400, 5]\n"
"  - [6, 7, 8]\n"
"  - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Explicitly update by a primary key: ok --\n"
"tarantool> s.index.pk:update({6}, {{'=', 2, 700}})\n"
"---\n"
"- [6, 700, 8]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 400, 5]\n"
"  - [6, 700, 8]\n"
"  - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Update by a unique secondary key: ok --\n"
"tarantool> s.index.sk_uniq:update({10}, {{'=', 2, 1000}})\n"
"---\n"
"- [9, 1000, 11]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 400, 5]\n"
"  - [6, 700, 8]\n"
"  - [9, 1000, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Update by a non-unique secondary key: error --\n"
"tarantool> s.index.sk_non_uniq:update({14}, {{'=', 2, 1300}})\n"
"---\n"
"- error: Get() doesn't support partial keys and non-unique indexes\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 400, 5]\n"
"  - [6, 700, 8]\n"
"  - [9, 1000, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:2938
#: ../doc/book/box/engines/vinyl.rst:140
#: ../doc/book/box/engines/vinyl.rst:140
msgid "UPSERT"
msgstr ""

#: ../doc/book/box/box_space.rst:2940
msgid "``upsert`` accepts a well-formatted tuple and update operations."
msgstr ""

#: ../doc/book/box/box_space.rst:2942
msgid "If an old tuple is found by the primary key of the specified tuple, then the update operations are applied to the old tuple, and the new tuple is ignored."
msgstr ""

#: ../doc/book/box/box_space.rst:2946
msgid "If no old tuple is found, then the new tuple is inserted, and the update operations are **ignored**."
msgstr ""

#: ../doc/book/box/box_space.rst:2949
msgid "Indexes have no ``upsert`` method - this is a method of a space."
msgstr ""

#: ../doc/book/box/box_space.rst:2951
msgid "tarantool> s.index.pk.upsert == nil\n"
"---\n"
"- true\n"
"...\n"
"tarantool> s.index.sk_uniq.upsert == nil\n"
"---\n"
"- true\n"
"...\n"
"tarantool> s.upsert ~= nil\n"
"---\n"
"- true\n"
"...\n"
"tarantool> -- As the first argument, upsert accepts --\n"
"tarantool> -- a well-formatted tuple, NOT a key! --\n"
"tarantool> s:insert{1, 2, 3}\n"
"---\n"
"- [1, 2, 3]\n"
"...\n"
"tarantool> s:upsert({1}, {{'=', 2, 200}})\n"
"---\n"
"- error: Tuple field count 1 is less than required by space format or defined indexes\n"
"    (expected at least 3)\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 2, 3]\n"
"...\n"
"tarantool> s:delete{1}\n"
"---\n"
"- [1, 2, 3]\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:2985
msgid "``upsert`` turns into ``insert`` when no old tuple is found by the primary key."
msgstr ""

#: ../doc/book/box/box_space.rst:2987
msgid "tarantool> s:upsert({1, 2, 3}, {{'=', 2, 200}})\n"
"---\n"
"...\n"
"tarantool> -- As you can see, {1, 2, 3} were inserted, --\n"
"tarantool> -- and the update operations were not applied. --\n"
"s:select{}\n"
"---\n"
"- - [1, 2, 3]\n"
"...\n"
"tarantool> -- Performing another upsert with the same primary key, --\n"
"tarantool> -- but different values in the other fields. --\n"
"s:upsert({1, 20, 30}, {{'=', 2, 200}})\n"
"---\n"
"...\n"
"tarantool> -- The old tuple was found by the primary key {1} --\n"
"tarantool> -- and update operations were applied. --\n"
"tarantool> -- The new tuple was ignored. --\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 200, 3]\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:3011
msgid "``upsert`` searches for an old tuple by the primary index, NOT by a secondary index. This can lead to a duplication error if the new tuple ruins the uniqueness of a secondary index."
msgstr ""

#: ../doc/book/box/box_space.rst:3015
msgid "tarantool> s:upsert({2, 200, 3}, {{'=', 3, 300}})\n"
"---\n"
"- error: Duplicate key exists in unique index 'sk_uniq' in space 'test'\n"
"...\n"
"s:select{}\n"
"---\n"
"- - [1, 200, 3]\n"
"...\n"
"tarantool> -- But this works, when uniqueness is preserved. --\n"
"tarantool> s:upsert({2, 0, 0}, {{'=', 3, 300}})\n"
"---\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 200, 3]\n"
"  - [2, 0, 0]\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:3042
#: ../doc/book/box/engines/vinyl.rst:138
#: ../doc/book/box/engines/vinyl.rst:138
msgid "REPLACE"
msgstr ""

#: ../doc/book/box/box_space.rst:3044
msgid "``replace`` accepts a well-formatted tuple and searches for an old tuple by the primary key of the new tuple."
msgstr ""

#: ../doc/book/box/box_space.rst:3047
msgid "If the old tuple is found, then it is deleted, and the new tuple is inserted."
msgstr ""

#: ../doc/book/box/box_space.rst:3049
msgid "If the old tuple was not found, then just the new tuple is inserted."
msgstr ""

#: ../doc/book/box/box_space.rst:3051
msgid "tarantool> s:replace{1, 2, 3}\n"
"---\n"
"- [1, 2, 3]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 2, 3]\n"
"...\n"
"tarantool> s:replace{1, 3, 4}\n"
"---\n"
"- [1, 3, 4]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 3, 4]\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:3073
msgid "``replace`` can ruin unique constraints, like ``upsert`` does."
msgstr ""

#: ../doc/book/box/box_space.rst:3075
msgid "tarantool> s:insert{1, 1, 1}\n"
"---\n"
"- [1, 1, 1]\n"
"...\n"
"tarantool> s:insert{2, 2, 2}\n"
"---\n"
"- [2, 2, 2]\n"
"...\n"
"tarantool> -- This replace fails, because if the new tuple {1, 2, 0} replaces --\n"
"tarantool> -- the old tuple by the primary key from 'pk' index {1, 1, 1}, --\n"
"tarantool> -- this results in a duplicate unique secondary key in 'sk_uniq' index: --\n"
"tarantool> -- key {2} is used both in the new tuple and in {2, 2, 2}. --\n"
"tarantool> s:replace{1, 2, 0}\n"
"---\n"
"- error: Duplicate key exists in unique index 'sk_uniq' in space 'test'\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:3101
msgid "SELECT"
msgstr ""

#: ../doc/book/box/box_space.rst:3103
msgid "``select`` works with any indexes (primary/secondary) and with any keys (unique/non-unique, full/partial)."
msgstr ""

#: ../doc/book/box/box_space.rst:3106
msgid "If a key is partial, then ``select`` searches by all keys, where the prefix matches the specified key part."
msgstr ""

#: ../doc/book/box/box_space.rst:3109
msgid "tarantool> s:insert{1, 2, 3}\n"
"---\n"
"- [1, 2, 3]\n"
"...\n"
"tarantool> s:insert{4, 5, 6}\n"
"---\n"
"- [4, 5, 6]\n"
"...\n"
"tarantool> s:insert{7, 8, 9}\n"
"---\n"
"- [7, 8, 9]\n"
"...\n"
"tarantool> s:insert{10, 11, 9}\n"
"---\n"
"- [10, 11, 9]\n"
"...\n"
"tarantool> s:select{1}\n"
"---\n"
"- - [1, 2, 3]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 2, 3]\n"
"  - [4, 5, 6]\n"
"  - [7, 8, 9]\n"
"  - [10, 11, 9]\n"
"...\n"
"tarantool> s.index.pk:select{4}\n"
"---\n"
"- - [4, 5, 6]\n"
"...\n"
"tarantool> s.index.sk_uniq:select{8}\n"
"---\n"
"- - [7, 8, 9]\n"
"...\n"
"tarantool> s.index.sk_non_uniq:select{9}\n"
"---\n"
"- - [7, 8, 9]\n"
"  - [10, 11, 9]\n"
"..."
msgstr ""

#: ../doc/book/box/box_sql.rst:5
msgid "Functions for SQL"
msgstr ""

#: ../doc/book/box/box_sql.rst:7
msgid "The ``box`` module contains two functions related to SQL:"
msgstr ""

#: ../doc/book/box/box_sql.rst:9
msgid "``box.schema.func.create`` -- for making Lua functions callable from SQL statements. This will be part of the documentation regarding SQL Plus Lua."
msgstr ""

#: ../doc/book/box/box_sql.rst:13
msgid "``box.execute`` -- for making SQL statements callable from Lua functions."
msgstr ""

#: ../doc/book/box/box_sql.rst:15
msgid "Some SQL statements are illustrated in the :ref:`SQL tutorial <sql_tutorial>`."
msgstr ""

#: ../doc/book/box/box_sql.rst:21
msgid "Execute the SQL statement contained in the sql-statement parameter."
msgstr ""

#: ../doc/book/box/box_sql.rst:23
msgid "statement, which should conform to the rules for SQL grammar"
msgstr ""

#: ../doc/book/box/box_sql.rst:24
msgid "optional list for placeholders in the statement"
msgstr ""

#: ../doc/book/box/box_sql.rst:26
msgid "depends on statement"
msgstr ""

#: ../doc/book/box/box_sql.rst:28
msgid "There are two ways to pass extra parameters for ``box.execute()``:"
msgstr ""

#: ../doc/book/box/box_sql.rst:30
msgid "The first way is to concatenate strings. For example, this Lua script will insert 10 rows with different primary-key values into table t:"
msgstr ""

#: ../doc/book/box/box_sql.rst:34
msgid "for i=1,10,1 do\n"
"  box.execute(\"insert into t values (\" .. i .. \")\")\n"
"end"
msgstr ""

#: ../doc/book/box/box_sql.rst:40
msgid "The second way is to put one or more placeholder \"?\" tokens inside the string, and pass a second argument, which must be a table containing values for each placeholder. For example these two requests are equivalent:"
msgstr ""

#: ../doc/book/box/box_sql.rst:44
msgid "box.execute([[INSERT INTO tt VALUES (1,'x');]]);\n"
"x = {1,'x'}; box.execute([[INSERT INTO tt VALUES (?,?);]], x);"
msgstr ""

#: ../doc/book/box/box_sql.rst:49
msgid "Since ``box.execute()`` is an invocation of a Lua function, it either causes an error message or returns a value."
msgstr ""

#: ../doc/book/box/box_sql.rst:52
msgid "For some statements the returned value will contain a field named rowcount. For example;"
msgstr ""

#: ../doc/book/box/box_sql.rst:55
msgid "tarantool> box.execute([[INSERT INTO tt VALUES (8,8),(9,9);]])\n"
"tarantool> box.execute([[CREATE TABLE table1 (column1 INT PRIMARY key, column2 VARCHAR(10));]])\n"
"---\n"
"- rowcount: 1\n"
"...\n"
"tarantool> box.execute([[INSERT INTO table1 VALUES (55,'Hello SQL world!');]])\n"
"---\n"
"- rowcount: 1\n"
"..."
msgstr ""

#: ../doc/book/box/box_sql.rst:67
msgid "For statements that cause generation of values for PRIMARY KEY AUTOINCREMENT columns, there will also be a field named \"autoincrement_ids\"."
msgstr ""

#: ../doc/book/box/box_sql.rst:70
msgid "For SELECT statements the returned value will contain a field named metadata (a table with column names and data types) and a field named \"rows\" (a table with the result set). For example:"
msgstr ""

#: ../doc/book/box/box_sql.rst:74
msgid "tarantool> box.execute([[SELECT * FROM table1 WHERE column1 > 0;]])\n"
"---\n"
"- metadata:\n"
"  - name: COLUMN1\n"
"    type: integer\n"
"  - name: COLUMN2\n"
"    type: string\n"
"  rows:\n"
"  - [55, 'Hello SQL world!']\n"
"..."
msgstr ""

#: ../doc/book/box/box_sql.rst:87
msgid "The result structure contains Tarantool/NoSQL data type names in MsgPack format. For example, for a statement SELECT \"x\" FROM t WHERE \"x\"=5; where \"x\" is an integer column and there is one row, the raw data for the result set will look like this:"
msgstr ""

#: ../doc/book/box/box_sql.rst:92
msgid "dd 00 00 00 01                  1-element array\n"
"82                              2-element map (for metadata + rows)\n"
"a8 6d 65 74 61 64 61 74 61      string = \"metadata\"\n"
"91                              1-element array (for column count)\n"
"82                              2-element map (for name + type)\n"
"a4 6e 61 6d 65                  string = \"name\"\n"
"a1 78                           string = \"x\"\n"
"a4 74 79 70 6                   string = \"type\"\n"
"a7 69 6e 74 65 67 65 72         string = \"integer\"\n"
"a4 72 6f 77 73                  string = \"rows\"\n"
"91                              1-element array (for row count)\n"
"91                              1-element array (for field count)\n"
"05                              contents"
msgstr ""

#: ../doc/book/box/box_sql.rst:108
msgid "The order of components within a map is not guaranteed."
msgstr ""

#: ../doc/book/box/box_sql.rst:110
msgid "Alternative: if you are using the Tarantool server as a client, you can switch languages thus:"
msgstr ""

#: ../doc/book/box/box_sql.rst:113
msgid "\\set language sql\n"
"\\set delimiter ;"
msgstr ""

#: ../doc/book/box/box_sql.rst:118
msgid "Afterwards, you can enter any SQL statement directly without needing ``box.execute()``."
msgstr ""

#: ../doc/book/box/box_sql.rst:120
msgid "There is also an ``execute()`` function available via :ref:`module net.box <net_box-module>`, for example after ``conn = net_box.connect(url-string)`` one can say ``conn:execute(sql-statement])``."
msgstr ""

#: ../doc/book/box/box_stat.rst:7
msgid "The ``box.stat`` submodule provides access to request and network statistics."
msgstr ""

#: ../doc/book/box/box_stat.rst:9
msgid "Use ``box.stat()`` to show the average number of requests per second, and the total number of requests since startup, broken down by request type."
msgstr ""

#: ../doc/book/box/box_stat.rst:12
msgid "Use ``box.stat.net()``  to see network activity: the number of packets sent and received, the count of active iproto connections, and the average number of requests per second."
msgstr ""

#: ../doc/book/box/box_stat.rst:17
msgid "Use ``box.stat.vinyl()`` to see vinyl-storage-engine activity, for example ``box.stat.vinyl().tx`` has the number of commits and rollbacks. See details at :ref:`the end of this section <box_introspection-box_stat_vinyl_details>`."
msgstr ""

#: ../doc/book/box/box_stat.rst:23
msgid "Use ``box.stat.reset()`` to reset the statistics of ``box.stat()``, ``box.stat.net()``, ``box.stat.vinyl()`` and :ref:`box.space.index <box_space-space_index>`."
msgstr ""

#: ../doc/book/box/box_stat.rst:27
msgid "In the tables that ``box.stat()`` and ``box.stat.net()`` return: ``rps`` stands for \"[average number of] requests per second [in the last 5 seconds]\", ``total`` stands for \"total [number processed since the server began]\", ``current`` stands for \"[number of] current [requests in progress, which can be limited by :ref:`box.cfg.net_msg_max <cfg_networking-net_msg_max>`]\". \"ERROR\" is the count of requests that resulted in an error."
msgstr ""

#: ../doc/book/box/box_stat.rst:34
msgid "tarantool> box.stat() -- return 10 tables\n"
"---\n"
"- DELETE:\n"
"    total: 1873949\n"
"    rps: 123\n"
"  SELECT:\n"
"    total: 1237723\n"
"    rps: 4099\n"
"  INSERT:\n"
"    total: 0\n"
"    rps: 0\n"
"  EVAL:\n"
"    total: 0\n"
"    rps: 0\n"
"  CALL:\n"
"    total: 0\n"
"    rps: 0\n"
"  REPLACE:\n"
"    total: 1239123\n"
"    rps: 7849\n"
"  UPSERT:\n"
"    total: 0\n"
"    rps: 0\n"
"  AUTH:\n"
"    total: 0\n"
"    rps: 0\n"
"  ERROR:\n"
"    total: 0\n"
"    rps: 0\n"
"  UPDATE:\n"
"    total: 0\n"
"    rps: 0\n"
"...\n"
"tarantool> box.stat().DELETE -- total + requests per second from one table\n"
"---\n"
"- total: 0\n"
"  rps: 0\n"
"...\n"
"tarantool> box.stat.net() -- 4 tables\n"
"---\n"
"- SENT:\n"
"    total: 0\n"
"    rps: 0\n"
"  CONNECTIONS:\n"
"    current: 0\n"
"    rps: 0\n"
"    total: 0\n"
"  REQUESTS:\n"
"    current: 0\n"
"    rps: 0\n"
"    total: 0\n"
"  RECEIVED:\n"
"    total: 0\n"
"    rps: 0\n"
"...\n"
"tarantool> box.stat.vinyl().tx.commit -- one item of the vinyl table\n"
"---\n"
"- 1047632\n"
"..."
msgstr ""

#: ../doc/book/box/box_stat.rst:98
msgid "Here are details about the ``box.stat.vinyl()`` items."
msgstr ""

#: ../doc/book/box/box_stat.rst:102
msgid "**Details about box.stat.vinyl().regulator:** The vinyl regulator decides when to take or delay actions for disk IO, grouping activity in batches so that it is consistent and efficient. The regulator is invoked by the vinyl scheduler, once per second, and updates related variables whenever it is invoked."
msgstr ""

#: ../doc/book/box/box_stat.rst:109
msgid "``box.stat.vinyl().regulator.dump_bandwidth`` is the estimated average rate at which dumps are done. Initially this will appear as 10485760 (10 megabytes per second). Only significant dumps (larger than one megabyte) are used for estimating."
msgstr ""

#: ../doc/book/box/box_stat.rst:114
msgid "``box.stat.vinyl().regulator.dump_watermark`` is the point when dumping must occur. The value is slightly smaller than the amount of memory that is allocated for vinyl trees, which is the :ref:`vinyl_memory <cfg_storage-vinyl_memory>` parameter."
msgstr ""

#: ../doc/book/box/box_stat.rst:120
msgid "``box.stat.vinyl().regulator.write_rate`` is the actual average rate at which recent writes to disk are done. Averaging is done over a 5-second time window, so if there has been no activity for 5 seconds then ``regulator.write_rate = 0``. The ``write_rate`` may be slowed when a dump is in progress or when the user has set :ref:`snap_io_rate_limit <cfg_binary_logging_snapshots-snap_io_rate_limit>`."
msgstr ""

#: ../doc/book/box/box_stat.rst:128
msgid "``box.stat.vinyl().regulator.rate_limit`` is the write rate limit, in bytes per second, imposed on transactions by the regulator based on the observed dump/compaction performance."
msgstr ""

#: ../doc/book/box/box_stat.rst:134
msgid "**Details about box.stat.vinyl().disk:** Since vinyl is an on-disk storage engine (unlike memtx which is an in-memory storage engine), it can handle large databases -- but if a database is larger than the amount of memory that is allocated for vinyl, then there will be more disk activity."
msgstr ""

#: ../doc/book/box/box_stat.rst:141
msgid "``box.stat.vinyl().disk.data`` and ``box.stat.vinyl().disk.index`` are the amount of data that has gone into files in a subdirectory of :ref:`vinyl_dir <cfg_basic-vinyl_dir>`, with names like ``{lsn}.run`` and ``{lsn}.index``. The size of the run will be related to the output of ``scheduler.dump_*``."
msgstr ""

#: ../doc/book/box/box_stat.rst:148
msgid "``box.stat.vinyl().disk.data_compacted`` Sum size of data stored at the last LSM tree level, in bytes, without taking disk compression into account. It can be thought of as the size of disk space that the user data would occupy if there were no compression, indexing, or space increase caused by the LSM tree design."
msgstr ""

#: ../doc/book/box/box_stat.rst:156
msgid "**Details about box.stat.vinyl().memory:** Although the vinyl storage engine is not \"in-memory\", Tarantool does need to have memory for write buffers and for caches:"
msgstr ""

#: ../doc/book/box/box_stat.rst:160
msgid "``box.stat.vinyl().memory.tuple_cache`` is the number of bytes that are being used for tuples (data)."
msgstr ""

#: ../doc/book/box/box_stat.rst:162
msgid "``box.stat.vinyl().memory.tx`` is transactional memory. This will usually be 0."
msgstr ""

#: ../doc/book/box/box_stat.rst:164
msgid "``box.stat.vinyl().memory.level0`` is the \"level0\" memory area, sometimes abbreviated \"L0\", which is the area that vinyl can use for in-memory storage of an LSM tree."
msgstr ""

#: ../doc/book/box/box_stat.rst:168
msgid "Therefore we can say that \"L0 is becoming full\" when the amount in ``memory.level0`` is close to the maximum, which is :ref:`regulator.dump_watermark <box_introspection-box_stat_vinyl_regulator>`. We can expect that \"L0 = 0\" immediately after a dump. ``box.stat.vinyl().memory.page_index`` and  ``box.stat.vinyl().memory.bloom_filter`` have the current amount being used for index-related structures. The size is a function of the number and size of keys, plus :ref:`page_size <cfg_storage-vinyl_page_size>`, plus :ref:`bloom_fpr <cfg_storage-vinyl_bloom_fpr>`. This is not a count of bloom filter \"hits\" (the number of reads that could be avoided because the bloom filter predicts their presence in a run file) -- that statistic can be found with :ref:`index_object:stat() <box_index-stat>`."
msgstr ""

#: ../doc/book/box/box_stat.rst:185
msgid "**Details about box.stat.vinyl().tx:** This is about requests that affect transactional activity (\"tx\" is used here as an abbreviation for \"transaction\"):"
msgstr ""

#: ../doc/book/box/box_stat.rst:189
msgid "``box.stat.vinyl().tx.conflict`` counts conflicts that caused a transaction to roll back."
msgstr ""

#: ../doc/book/box/box_stat.rst:191
msgid "``box.stat.vinyl().tx.commit`` is the count of commits (successful transaction ends). It includes implicit commits, for example any insert causes a commit unless it is within a begin-end block."
msgstr ""

#: ../doc/book/box/box_stat.rst:195
msgid "``box.stat.vinyl().tx.rollback`` is the count of rollbacks (unsuccessful transaction ends). This is not merely a count of explicit :ref:`box.rollback <box-rollback>` requests -- it includes requests that ended in errors. For example, after an attempted insert request that causes a \"Duplicate key exists in unique index\" error, ``tx.rollback`` is incremented."
msgstr ""

#: ../doc/book/box/box_stat.rst:203
msgid "``box.stat.vinyl().tx.statements`` will usually be 0."
msgstr ""

#: ../doc/book/box/box_stat.rst:205
msgid "``box.stat.vinyl().tx.transactions`` is the number of transactions that are currently running."
msgstr ""

#: ../doc/book/box/box_stat.rst:207
msgid "``box.stat.vinyl().tx.gap_locks`` is the number of gap locks that are outstanding during execution of a request. For a low-level description of Tarantool's implementation of gap locking, see `Gap locks in Vinyl transaction manager <https://github.com/tarantool/tarantool/issues/2671>`_."
msgstr ""

#: ../doc/book/box/box_stat.rst:211
msgid "``box.stat.vinyl().tx.read_views`` shows whether a transaction has entered a read-only state to avoid conflict temporarily. This will usually be 0."
msgstr ""

#: ../doc/book/box/box_stat.rst:215
msgid "**Details about box.stat.vinyl().scheduler:** This primarily has counters related to tasks that the scheduler has arranged for dumping or compaction: (most of these items are reset to 0 when the server restarts or when :ref:`box.stat.reset() <box_introspection-box_stat_reset>` occurs):"
msgstr ""

#: ../doc/book/box/box_stat.rst:221
msgid "``box.stat.vinyl().scheduler.compaction_*`` is the amount of data from recent changes that has been :ref:`compacted <box_index-compact>`. This is divided into ``scheduler.compaction_input`` (the amount that is being compacted), ``scheduler.compaction_queue`` (the amount that is waiting to be compacted), ``scheduler.compaction_time`` (total time spent by all worker threads performing compaction, in seconds), and ``scheduler.compaction_output`` (the amount that has been compacted, which is presumably smaller than ``scheduler.compaction_input``)."
msgstr ""

#: ../doc/book/box/box_stat.rst:231
msgid "``box.stat.vinyl().scheduler.tasks_*`` is about dump/compaction tasks, in three categories, ``scheduler.tasks_inprogress`` (currently running), ``scheduler.tasks_completed`` (successfully completed) ``scheduler.tasks_failed`` (aborted due to errors)."
msgstr ""

#: ../doc/book/box/box_stat.rst:237
msgid "``box.stat.vinyl().scheduler_dump_*`` has the amount of data from recent changes that has been dumped, including ``dump_time`` (total time spent by all worker threads performing dumps, in seconds), and ``dump_count`` (the count of completed dumps), ``dump_input`` and ``dump_output``."
msgstr ""

#: ../doc/book/box/box_stat.rst:243
msgid "A \"dump\" is explained in section :ref:`Storing data with vinyl <engines-algorithm_filling_lsm>`:"
msgstr ""

#: ../doc/book/box/box_stat.rst:245
msgid "Sooner or later the number of elements in an LSM tree exceeds the L0 size and that is when L0 gets written to a file on disk (called a 'run') and then cleared for storing new elements. This operation is called a 'dump'."
msgstr ""

#: ../doc/book/box/box_stat.rst:249
msgid "Thus it can be predicted that a dump will occur if the size of L0 (which is :ref:`memory.level0 <box_introspection-box_stat_vinyl_memory>`) is approaching the maximum (which is :ref:`regulator.dump_watermark <box_introspection-box_stat_vinyl_regulator>`) and a dump is not already in progress. In fact Tarantool will try to arrange a dump before this hard limit is reached."
msgstr ""

#: ../doc/book/box/box_stat.rst:259
msgid "A dump will also occur during a  :ref:`snapshot <box-snapshot>` operation."
msgstr ""

#: ../doc/book/box/box_tuple.rst:5
msgid "Submodule `box.tuple`"
msgstr ""

#: ../doc/book/box/box_tuple.rst:13
msgid "The ``box.tuple`` submodule provides read-only access for the ``tuple`` userdata type. It allows, for a single :ref:`tuple <index-box_tuple>`: selective retrieval of the field contents, retrieval of information about size, iteration over all the fields, and conversion to a `Lua table <https://www.lua.org/pil/2.5.html>`_."
msgstr ""

#: ../doc/book/box/box_tuple.rst:22
msgid "Below is a list of all ``box.tuple`` functions."
msgstr ""

#: ../doc/book/box/box_tuple.rst:32
msgid ":ref:`box.tuple.new() <box_tuple-new>`"
msgstr ""

#: ../doc/book/box/box_tuple.rst:32
msgid "Create a tuple"
msgstr ""

#: ../doc/book/box/box_tuple.rst:35
msgid ":ref:`#tuple_object <box_tuple-count_fields>`"
msgstr ""

#: ../doc/book/box/box_tuple.rst:35
msgid "Count tuple fields"
msgstr ""

#: ../doc/book/box/box_tuple.rst:38
msgid ":ref:`tuple_object:bsize() <box_tuple-bsize>`"
msgstr ""

#: ../doc/book/box/box_tuple.rst:38
msgid "Get count of bytes in a tuple"
msgstr ""

#: ../doc/book/box/box_tuple.rst:41
msgid ":ref:`tuple_object[field-number] <box_tuple-field_number>`"
msgstr ""

#: ../doc/book/box/box_tuple.rst:41
msgid "Get a tuple's field by specifying a number"
msgstr ""

#: ../doc/book/box/box_tuple.rst:44
msgid ":ref:`tuple_object[field-name] <box_tuple-field_name>`"
msgstr ""

#: ../doc/book/box/box_tuple.rst:44
msgid "Get a tuple's field by specifying a name"
msgstr ""

#: ../doc/book/box/box_tuple.rst:47
msgid ":ref:`tuple_object[field-path] <box_tuple-field_path>`"
msgstr ""

#: ../doc/book/box/box_tuple.rst:47
msgid "Get a tuple's fields or parts by specifying a path"
msgstr ""

#: ../doc/book/box/box_tuple.rst:50
msgid ":ref:`tuple_object:find() <box_tuple-find>`"
msgstr ""

#: ../doc/book/box/box_tuple.rst:50
msgid "Get the number of the first field matching the search value"
msgstr ""

#: ../doc/book/box/box_tuple.rst:53
msgid ":ref:`tuple_object:findall() <box_tuple-find>`"
msgstr ""

#: ../doc/book/box/box_tuple.rst:53
msgid "Get the number of all fields matching the search value"
msgstr ""

#: ../doc/book/box/box_tuple.rst:56
msgid ":ref:`tuple_object:transform() <box_tuple-transform>`"
msgstr ""

#: ../doc/book/box/box_tuple.rst:56
msgid "Remove (and replace) a tuple's fields"
msgstr ""

#: ../doc/book/box/box_tuple.rst:59
msgid ":ref:`tuple_object:unpack() <box_tuple-unpack>`"
msgstr ""

#: ../doc/book/box/box_tuple.rst:59
msgid "Get a tuple's fields"
msgstr ""

#: ../doc/book/box/box_tuple.rst:62
msgid ":ref:`tuple_object:totable() <box_tuple-totable>`"
msgstr ""

#: ../doc/book/box/box_tuple.rst:62
msgid "Get a tuple's fields as a table"
msgstr ""

#: ../doc/book/box/box_tuple.rst:65
msgid ":ref:`tuple_object:tomap() <box_tuple-tomap>`"
msgstr ""

#: ../doc/book/box/box_tuple.rst:65
msgid "Get a tuple's fields as a table along with key:value pairs"
msgstr ""

#: ../doc/book/box/box_tuple.rst:68
msgid ":ref:`tuple_object:pairs() <box_tuple-pairs>`"
msgstr ""

#: ../doc/book/box/box_tuple.rst:71
msgid ":ref:`tuple_object:update() <box_tuple-update>`"
msgstr ""

#: ../doc/book/box/box_tuple.rst:79
msgid "Construct a new tuple from either a scalar or a Lua table. Alternatively, one can get new tuples from tarantool's :ref:`select <box_space-select>` or :ref:`insert <box_space-insert>` or :ref:`replace <box_space-replace>` or :ref:`update <box_space-update>` requests, which can be regarded as statements that do ``new()`` implicitly."
msgstr ""

#: ../doc/book/box/box_tuple.rst:86
msgid "the value that will become the tuple contents."
msgstr ""

#: ../doc/book/box/box_tuple.rst:88
msgid "a new tuple"
msgstr ""

#: ../doc/book/box/box_tuple.rst:91
msgid "In the following example, ``x`` will be a new table object containing one tuple and ``t`` will be a new tuple object. Saying ``t`` returns the entire tuple ``t``."
msgstr ""

#: ../doc/book/box/box_tuple.rst:97
msgid "tarantool> x = box.space.tester:insert{\n"
"         >   33,\n"
"         >   tonumber('1'),\n"
"         >   tonumber64('2')\n"
"         > }:totable()\n"
"---\n"
"...\n"
"tarantool> t = box.tuple.new{'abc', 'def', 'ghi', 'abc'}\n"
"---\n"
"...\n"
"tarantool> t\n"
"---\n"
"- ['abc', 'def', 'ghi', 'abc']\n"
"..."
msgstr ""

#: ../doc/book/box/box_tuple.rst:120
msgid "The ``#`` operator in Lua means \"return count of components\". So, if ``t`` is a tuple instance, ``#t`` will return the number of fields."
msgstr ""

#: ../doc/book/box/box_tuple.rst:125
msgid "In the following example, a tuple named ``t`` is created and then the number of fields in ``t`` is returned."
msgstr ""

#: ../doc/book/box/box_tuple.rst:128
msgid "tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4'}\n"
"---\n"
"...\n"
"tarantool> #t\n"
"---\n"
"- 4\n"
"..."
msgstr ""

#: ../doc/book/box/box_tuple.rst:142
msgid "If ``t`` is a tuple instance, ``t:bsize()`` will return the number of bytes in the tuple. With both the memtx storage engine and the vinyl storage engine the default maximum is one megabyte (:ref:`memtx_max_tuple_size <cfg_storage-memtx_max_tuple_size>` or :ref:`vinyl_max_tuple_size <cfg_storage-vinyl_max_tuple_size>`). Every field has one or more \"length\" bytes preceding the actual contents, so ``bsize()`` returns a value which is slightly greater than the sum of the lengths of the contents."
msgstr ""

#: ../doc/book/box/box_tuple.rst:151
msgid "The value does not include the size of \"struct tuple\" (for the current size of this structure look in the `tuple.h <https://github.com/tarantool/tarantool/blob/2.1/src/box/tuple.h>`_ file in Tarantool's source code)."
msgstr ""

#: ../doc/book/box/box_tuple.rst:159
msgid "In the following example, a tuple named ``t`` is created which has three fields, and for each field it takes one byte to store the length and three bytes to store the contents, and then there is one more byte to store a count of the number of fields, so ``bsize()`` returns ``3*(1+3)+1``. This is the same as the size of the string that :ref:`msgpack.encode({'aaa','bbb','ccc'}) <msgpack-encode>` would return."
msgstr ""

#: ../doc/book/box/box_tuple.rst:166
msgid "tarantool> t = box.tuple.new{'aaa', 'bbb', 'ccc'}\n"
"---\n"
"...\n"
"tarantool> t:bsize()\n"
"---\n"
"- 13\n"
"..."
msgstr ""

#: ../doc/book/box/box_tuple.rst:180
msgid "If ``t`` is a tuple instance, ``t[field-number]`` will return the field numbered field-number in the tuple. The first field is ``t[1]``."
msgstr ""

#: ../doc/book/box/box_tuple.rst:183
#: ../doc/book/box/box_tuple.rst:214
msgid "field value."
msgstr ""

#: ../doc/book/box/box_tuple.rst:184
#: ../doc/book/box/box_tuple.rst:215
msgid "lua-value"
msgstr ""

#: ../doc/book/box/box_tuple.rst:186
msgid "In the following example, a tuple named ``t`` is created and then the second field in ``t`` is returned."
msgstr ""

#: ../doc/book/box/box_tuple.rst:189
msgid "tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4'}\n"
"---\n"
"...\n"
"tarantool> t[2]\n"
"---\n"
"- Fld#2\n"
"..."
msgstr ""

#: ../doc/book/box/box_tuple.rst:203
msgid "If ``t`` is a tuple instance, ``t['field-name']`` will return the field named 'field-name' in the tuple. Fields have names if the tuple has been retrieved from a space that has an associated :ref:`format <box_space-format>`. :samp:`t[{lua-variable-name}]` will do the same thing if ``lua-variable-name`` contains ``'field-name'``."
msgstr ""

#: ../doc/book/box/box_tuple.rst:209
msgid "There is a variation which the `Lua manual <https://www.lua.org/pil/2.5.html>`_ calls \"syntactic sugar\": use ``t.field-name`` as an equivalent of ``t['field-name']``."
msgstr ""

#: ../doc/book/box/box_tuple.rst:217
msgid "In the following example, a tuple named ``t`` is returned from ``replace`` and then the second field in ``t`` named 'field2' is returned."
msgstr ""

#: ../doc/book/box/box_tuple.rst:220
msgid "tarantool> format = {}\n"
"---\n"
"...\n"
"tarantool> format[1] = {name = 'field1', type = 'unsigned'}\n"
"---\n"
"...\n"
"tarantool> format[2] = {name = 'field2', type = 'string'}\n"
"---\n"
"...\n"
"tarantool> s = box.schema.space.create('test', {format = format})\n"
"---\n"
"...\n"
"tarantool> pk = s:create_index('pk')\n"
"---\n"
"...\n"
"tarantool> t = s:replace{1, 'Я'}\n"
"---\n"
"...\n"
"tarantool> t['field2']\n"
"---\n"
"- Я\n"
"..."
msgstr ""

#: ../doc/book/box/box_tuple.rst:249
msgid "If ``t`` is a tuple instance, ``t['path']`` will return the field or subset of fields that are in ``path``. ``path`` must be a well formed JSON specification. ``path`` may contain field names if the tuple has been retrieved from a space that has an associated :ref:`format <box_space-format>`."
msgstr ""

#: ../doc/book/box/box_tuple.rst:254
msgid "To prevent ambiguity, Tarantool first tries to interpret the request as :ref:`tuple_object[field-number] <box_tuple-field_number>` or :ref:`tuple_object[field-name] <box_tuple-field_name>`. If and only if that fails, Tarantool tries to interpret the request as ``tuple_object[field-path]``."
msgstr ""

#: ../doc/book/box/box_tuple.rst:260
msgid "The path must be a well formed JSON specification, but it may be preceded by '.'. The '.' is a signal that the path acts as a suffix for the tuple."
msgstr ""

#: ../doc/book/box/box_tuple.rst:264
msgid "The advantage of specifying a path is that Tarantool will use it to search through a tuple body and get only the tuple part, or parts, that are actually necessary."
msgstr ""

#: ../doc/book/box/box_tuple.rst:268
msgid "In the following example, a tuple named ``t`` is returned from ``replace`` and then only the relevant part (in this case, matching a name) of a relevant field is returned. Namely: the second field, the sixth part, the value following 'value='."
msgstr ""

#: ../doc/book/box/box_tuple.rst:273
msgid "tarantool> format = {}\n"
"---\n"
"...\n"
"tarantool> format[1] = {name = 'field1', type = 'unsigned'}\n"
"---\n"
"...\n"
"tarantool> format[2] = {name = 'field2', type = 'array'}\n"
"---\n"
"...\n"
"tarantool> format[3] = {name = 'field4', type = 'string' }\n"
"---\n"
"...\n"
"tarantool> format[4] = {name = \"[2][6]['пw']['Я']\", type = 'string'}\n"
"---\n"
"...\n"
"tarantool> s = box.schema.space.create('test', {format = format})\n"
"---\n"
"...\n"
"tarantool> pk = s:create_index('pk')\n"
"---\n"
"...\n"
"tarantool> field2 = {1, 2, 3, \"4\", {5,6,7}, {пw={Я=\"п\"}, key=\"V!\", value=\"K!\"}}\n"
"---\n"
"...\n"
"tarantool> t = s:replace{1, field2, \"123456\", \"Not K!\"}\n"
"---\n"
"...\n"
"tarantool> t[\"[2][6]['value']\"]\n"
"---\n"
"- K!\n"
"..."
msgstr ""

#: ../doc/book/box/box_tuple.rst:312
msgid "If ``t`` is a tuple instance, ``t:find(search-value)`` will return the number of the first field in ``t`` that matches the search value, and ``t:findall(search-value [, search-value ...])`` will return numbers of all fields in ``t`` that match the search value. Optionally one can put a numeric argument ``field-number`` before the search-value to indicate “start searching at field number ``field-number``.”"
msgstr ""

#: ../doc/book/box/box_tuple.rst:319
msgid "the number of the field in the tuple."
msgstr ""

#: ../doc/book/box/box_tuple.rst:322
msgid "In the following example, a tuple named ``t`` is created and then: the number of the first field in ``t`` which matches 'a' is returned, then the numbers of all the fields in ``t`` which match 'a' are returned, then the numbers of all the fields in t which match 'a' and are at or after the second field are returned."
msgstr ""

#: ../doc/book/box/box_tuple.rst:328
msgid "tarantool> t = box.tuple.new{'a', 'b', 'c', 'a'}\n"
"---\n"
"...\n"
"tarantool> t:find('a')\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> t:findall('a')\n"
"---\n"
"- 1\n"
"- 4\n"
"...\n"
"tarantool> t:findall(2, 'a')\n"
"---\n"
"- 4\n"
"..."
msgstr ""

#: ../doc/book/box/box_tuple.rst:351
msgid "If ``t`` is a tuple instance, :samp:`t:transform({start-field-number},{fields-to-remove})` will return a tuple where, starting from field ``start-field-number``, a number of fields (``fields-to-remove``) are removed. Optionally one can add more arguments after ``fields-to-remove`` to indicate new values that will replace what was removed."
msgstr ""

#: ../doc/book/box/box_tuple.rst:357
msgid "If the original tuple comes from a space that has been formatted with a :ref:`format clause <box_space-format>`, the formatting will not be preserved for the result tuple."
msgstr ""

#: ../doc/book/box/box_tuple.rst:361
msgid "base 1, may be negative"
msgstr ""

#: ../doc/book/box/box_tuple.rst:367
msgid "In the following example, a tuple named ``t`` is created and then, starting from the second field, two fields are removed but one new one is added, then the result is returned."
msgstr ""

#: ../doc/book/box/box_tuple.rst:371
msgid "tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}\n"
"---\n"
"...\n"
"tarantool> t:transform(2, 2, 'x')\n"
"---\n"
"- ['Fld#1', 'x', 'Fld#4', 'Fld#5']\n"
"..."
msgstr ""

#: ../doc/book/box/box_tuple.rst:385
msgid "If ``t`` is a tuple instance, ``t:unpack()`` will return all fields, ``t:unpack(1)`` will return all fields starting with field number 1, ``t:unpack(1,5)`` will return all fields between field number 1 and field number 5."
msgstr ""

#: ../doc/book/box/box_tuple.rst:389
msgid "field(s) from the tuple."
msgstr ""

#: ../doc/book/box/box_tuple.rst:390
msgid "lua-value(s)"
msgstr ""

#: ../doc/book/box/box_tuple.rst:392
msgid "In the following example, a tuple named ``t`` is created and then all its fields are selected, then the result is returned."
msgstr ""

#: ../doc/book/box/box_tuple.rst:395
msgid "tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}\n"
"---\n"
"...\n"
"tarantool> t:unpack()\n"
"---\n"
"- Fld#1\n"
"- Fld#2\n"
"- Fld#3\n"
"- Fld#4\n"
"- Fld#5\n"
"..."
msgstr ""

#: ../doc/book/box/box_tuple.rst:413
msgid "If ``t`` is a tuple instance, ``t:totable()`` will return all fields, ``t:totable(1)`` will return all fields starting with field number 1, ``t:totable(1,5)`` will return all fields between field number 1 and field number 5."
msgstr ""

#: ../doc/book/box/box_tuple.rst:417
msgid "It is preferable to use ``t:totable()`` rather than ``t:unpack()``."
msgstr ""

#: ../doc/book/box/box_tuple.rst:419
msgid "field(s) from the tuple"
msgstr ""

#: ../doc/book/box/box_tuple.rst:420
#: ../doc/book/box/box_tuple.rst:469
msgid "lua-table"
msgstr ""

#: ../doc/book/box/box_tuple.rst:422
msgid "In the following example, a tuple named ``t`` is created, then all its fields are selected, then the result is returned."
msgstr ""

#: ../doc/book/box/box_tuple.rst:425
msgid "tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}\n"
"---\n"
"...\n"
"tarantool> t:totable()\n"
"---\n"
"- ['Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5']\n"
"..."
msgstr ""

#: ../doc/book/box/box_tuple.rst:439
msgid "A `Lua table <https://www.lua.org/pil/2.5.html>`_ can have indexed values, also called key:value pairs. For example, here:"
msgstr ""

#: ../doc/book/box/box_tuple.rst:443
msgid "a = {}; a['field1'] = 10; a['field2'] = 20"
msgstr ""

#: ../doc/book/box/box_tuple.rst:447
msgid "``a`` is a table with \"field1: 10\" and \"field2: 20\"."
msgstr ""

#: ../doc/book/box/box_tuple.rst:449
msgid "The :ref:`tuple_object:totable() <box_tuple-totable>` function only returns a table containing the values. But the ``tuple_object:tomap()`` function returns a table containing not only the values, but also the key:value pairs."
msgstr ""

#: ../doc/book/box/box_tuple.rst:454
msgid "This only works if the tuple comes from a space that has been formatted with a :ref:`format clause <box_space-format>`."
msgstr ""

#: ../doc/book/box/box_tuple.rst:457
msgid "the only possible option is ``names_only``.  If ``names_only`` is false or omitted (default), then all the fields will appear twice, first with numeric headings and second with name headings.  If ``names_only`` is true, then all the fields will appear only once, with name headings."
msgstr ""

#: ../doc/book/box/box_tuple.rst:457
msgid "the only possible option is ``names_only``."
msgstr ""

#: ../doc/book/box/box_tuple.rst:459
msgid "If ``names_only`` is false or omitted (default), then all the fields will appear twice, first with numeric headings and second with name headings."
msgstr ""

#: ../doc/book/box/box_tuple.rst:464
msgid "If ``names_only`` is true, then all the fields will appear only once, with name headings."
msgstr ""

#: ../doc/book/box/box_tuple.rst:468
msgid "field-number:value pair(s) and key:value pair(s) from the tuple"
msgstr ""

#: ../doc/book/box/box_tuple.rst:471
msgid "In the following example, a tuple named ``t1`` is returned from a space that has been formatted, then tables named ``t1map1`` and ``t1map2`` are produced from ``t1``."
msgstr ""

#: ../doc/book/box/box_tuple.rst:475
msgid "format = {{'field1', 'unsigned'}, {'field2', 'unsigned'}}\n"
"s = box.schema.space.create('test', {format = format})\n"
"s:create_index('pk',{parts={1,'unsigned',2,'unsigned'}})\n"
"t1 = s:insert{10, 20}\n"
"t1map = t1:tomap()\n"
"t1map_names_only = t1:tomap({names_only=true})"
msgstr ""

#: ../doc/book/box/box_tuple.rst:484
msgid "``t1map`` will contain \"1: 10\", \"2: 20\", \"field1: 10\", \"field2: 20\"."
msgstr ""

#: ../doc/book/box/box_tuple.rst:486
msgid "``t1map_names_only`` will contain \"field1: 10\", \"field2: 20\"."
msgstr ""

#: ../doc/book/box/box_tuple.rst:492
msgid "In Lua, `lua-table-value:pairs() <https://www.lua.org/pil/7.3.html>`_ is a method which returns: ``function``, ``lua-table-value``, ``nil``."
msgstr ""

#: ../doc/book/box/box_tuple.rst:496
msgid "Tarantool has extended this so that ``tuple-value:pairs()`` returns: ``function``, ``tuple-value``, ``nil``. It is useful for Lua iterators, because Lua iterators traverse a value's components until an end marker is reached."
msgstr ""

#: ../doc/book/box/box_tuple.rst:501
msgid "function, tuple-value, nil"
msgstr ""

#: ../doc/book/box/box_tuple.rst:502
msgid "function, lua-value, nil"
msgstr ""

#: ../doc/book/box/box_tuple.rst:504
msgid "In the following example, a tuple named ``t`` is created and then all its fields are selected using a Lua for-end loop."
msgstr ""

#: ../doc/book/box/box_tuple.rst:507
msgid "tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}\n"
"---\n"
"...\n"
"tarantool> tmp = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in t:pairs() do\n"
"         >   tmp = tmp .. v\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> tmp\n"
"---\n"
"- Fld#1Fld#2Fld#3Fld#4Fld#5\n"
"..."
msgstr ""

#: ../doc/book/box/box_tuple.rst:531
msgid "This function updates a tuple which is not in a space. Compare the function :extsamp:`box.space.{*{space-name}*}:update({*{key}*}, {{{*{format}*}, {*{field_identifier}*}, {*{value}*}}, ...})` which updates a tuple in a space."
msgstr ""

#: ../doc/book/box/box_tuple.rst:535
msgid "For details: see the description for ``operator``, ``field_identifier``, and ``value`` in the section :ref:`box.space.space-name:update{key, format, {field_identifier, value}...) <box_space-update>`."
msgstr ""

#: ../doc/book/box/box_tuple.rst:539
msgid "If the original tuple comes from a space that has been formatted with a :ref:`format clause <box_space-format>`, the formatting will be preserved for the result tuple."
msgstr ""

#: ../doc/book/box/box_tuple.rst:543
msgid "operation type represented in string (e.g. '``=``' for 'assign new value')"
msgstr ""

#: ../doc/book/box/box_tuple.rst:545
msgid "what field the operation will apply to. The field number can be negative, meaning the position from the end of tuple. (#tuple + negative field number + 1)"
msgstr ""

#: ../doc/book/box/box_tuple.rst:551
msgid "new tuple"
msgstr ""

#: ../doc/book/box/box_tuple.rst:554
msgid "In the following example, a tuple named ``t`` is created and then its second field is updated to equal 'B'."
msgstr ""

#: ../doc/book/box/box_tuple.rst:557
msgid "tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}\n"
"---\n"
"...\n"
"tarantool> t:update({{'=', 2, 'B'}})\n"
"---\n"
"- ['Fld#1', 'B', 'Fld#3', 'Fld#4', 'Fld#5']\n"
"..."
msgstr ""

#: ../doc/book/box/box_tuple.rst:569
#: ../doc/book/sql.rst:23
msgid "Example"
msgstr ""

#: ../doc/book/box/box_tuple.rst:571
msgid "This function will illustrate how to convert tuples to/from Lua tables and lists of scalars:"
msgstr ""

#: ../doc/book/box/box_tuple.rst:574
msgid "tuple = box.tuple.new({scalar1, scalar2, ... scalar_n}) -- scalars to tuple\n"
"lua_table = {tuple:unpack()}                            -- tuple to Lua table\n"
"lua_table = tuple:totable()                             -- tuple to Lua table\n"
"scalar1, scalar2, ... scalar_n = tuple:unpack()         -- tuple to scalars\n"
"tuple = box.tuple.new(lua_table)                        -- Lua table to tuple"
msgstr ""

#: ../doc/book/box/box_tuple.rst:582
msgid "Then it will find the field that contains 'b', remove that field from the tuple, and display how many bytes remain in the tuple. The function uses Tarantool ``box.tuple`` functions ``new()``, ``unpack()``, ``find()``, ``transform()``, ``bsize()``."
msgstr ""

#: ../doc/book/box/box_tuple.rst:587
msgid "function example()\n"
"  local tuple1, tuple2, lua_table_1, scalar1, scalar2, scalar3, field_number\n"
"  local luatable1 = {}\n"
"  tuple1 = box.tuple.new({'a', 'b', 'c'})\n"
"  luatable1 = tuple1:totable()\n"
"  scalar1, scalar2, scalar3 = tuple1:unpack()\n"
"  tuple2 = box.tuple.new(luatable1[1],luatable1[2],luatable1[3])\n"
"  field_number = tuple2:find('b')\n"
"  tuple2 = tuple2:transform(field_number, 1)\n"
"  return 'tuple2 = ' , tuple2 , ' # of bytes = ' , tuple2:bsize()\n"
"end"
msgstr ""

#: ../doc/book/box/box_tuple.rst:603
msgid "tarantool> example()\n"
"---\n"
"- tuple2 =\n"
"- ['a', 'c']\n"
"- ' # of bytes = '\n"
"- 5\n"
"..."
msgstr ""

#: ../doc/book/box/box_txn_management.rst:5
msgid "Functions for transaction management"
msgstr ""

#: ../doc/book/box/box_txn_management.rst:11
msgid "For general information and examples, see section :ref:`Transaction control <atomic-atomic_execution>`."
msgstr ""

#: ../doc/book/box/box_txn_management.rst:14
msgid "Observe the following rules when working with transactions:"
msgstr ""

#: ../doc/book/box/box_txn_management.rst:16
msgid "Rule #1"
msgstr ""

#: ../doc/book/box/box_txn_management.rst:19
msgid "The requests in a transaction must be sent to a server as a single block. It is not enough to enclose them between begin and commit or rollback. To ensure they are sent as a single block: put them in a function, or put them all on one line, or use a delimiter so that multi-line requests are handled together."
msgstr ""

#: ../doc/book/box/box_txn_management.rst:25
msgid "Rule #2"
msgstr ""

#: ../doc/book/box/box_txn_management.rst:28
msgid "All database operations in a transaction should use the same storage engine. It is not safe to access tuple sets that are defined with ``{engine='vinyl'}`` and also access tuple sets that are defined with ``{engine='memtx'}``, in the same transaction."
msgstr ""

#: ../doc/book/box/box_txn_management.rst:33
msgid "Rule #3"
msgstr ""

#: ../doc/book/box/box_txn_management.rst:36
msgid "Requests which cause changes to the data definition -- create, alter, drop, truncate -- are only allowed with Tarantool version 2.1 or later. Data-definition requests which change an index or change a format, such as :ref:`space_object:create_index() <box_schema-sequence_create_index>` and :ref:`space_object:format() <box_space-format>`, are not allowed inside transactions except as the first request after ``box.begin()``."
msgstr ""

#: ../doc/book/box/box_txn_management.rst:50
msgid "Below is a list of all functions for transaction management."
msgstr ""

#: ../doc/book/box/box_txn_management.rst:62
msgid ":ref:`box.begin() <box-begin>`"
msgstr ""

#: ../doc/book/box/box_txn_management.rst:62
msgid "Begin the transaction"
msgstr ""

#: ../doc/book/box/box_txn_management.rst:65
msgid ":ref:`box.commit() <box-commit>`"
msgstr ""

#: ../doc/book/box/box_txn_management.rst:65
msgid "End the transaction and save all changes"
msgstr ""

#: ../doc/book/box/box_txn_management.rst:68
msgid ":ref:`box.rollback() <box-rollback>`"
msgstr ""

#: ../doc/book/box/box_txn_management.rst:68
msgid "End the transaction and discard all changes"
msgstr ""

#: ../doc/book/box/box_txn_management.rst:71
msgid ":ref:`box.savepoint() <box-savepoint>`"
msgstr ""

#: ../doc/book/box/box_txn_management.rst:71
msgid "Get a savepoint descriptor"
msgstr ""

#: ../doc/book/box/box_txn_management.rst:74
msgid ":ref:`box.rollback_to_savepoint() <box-rollback_to_savepoint>`"
msgstr ""

#: ../doc/book/box/box_txn_management.rst:74
msgid "Do not end the transaction and discard all changes made after a savepoint"
msgstr ""

#: ../doc/book/box/box_txn_management.rst:78
msgid ":ref:`box.atomic() <box-atomic>`"
msgstr ""

#: ../doc/book/box/box_txn_management.rst:78
msgid "Execute a function, treating it as a transaction"
msgstr ""

#: ../doc/book/box/box_txn_management.rst:81
msgid ":ref:`box.on_commit() <box-on_commit>`"
msgstr ""

#: ../doc/book/box/box_txn_management.rst:81
msgid "Define a trigger that will be activated by box.commit"
msgstr ""

#: ../doc/book/box/box_txn_management.rst:84
msgid ":ref:`box.on_rollback() <box-on_rollback>`"
msgstr ""

#: ../doc/book/box/box_txn_management.rst:84
msgid "Define a trigger that will be activated by box.rollback"
msgstr ""

#: ../doc/book/box/box_txn_management.rst:87
msgid ":ref:`box.is_in_txn() <box-is_in_txn>`"
msgstr ""

#: ../doc/book/box/box_txn_management.rst:87
msgid "State whether a transaction is in progress"
msgstr ""

#: ../doc/book/box/box_txn_management.rst:95
msgid "Begin the transaction. Disable :ref:`implicit yields <atomic-implicit-yields>` until the transaction ends. Signal that writes to the :ref:`write-ahead log <internals-wal>` will be deferred until the transaction ends. In effect the fiber which executes ``box.begin()`` is starting an \"active multi-request transaction\", blocking all other fibers."
msgstr ""

#: ../doc/book/box/box_txn_management.rst:103
msgid "**Possible errors:** error if this operation is not permitted because there"
msgstr ""

#: ../doc/book/box/box_txn_management.rst:103
msgid "is already an active transaction. error if for some reason memory cannot be allocated."
msgstr ""

#: ../doc/book/box/box_txn_management.rst:110
msgid "End the transaction, and make all its data-change operations permanent."
msgstr ""

#: ../doc/book/box/box_txn_management.rst:113
msgid "**Possible errors:**  error and abort the transaction in case of a conflict."
msgstr ""

#: ../doc/book/box/box_txn_management.rst:113
msgid "error if the operation fails to write to disk. error if for some reason memory cannot be allocated."
msgstr ""

#: ../doc/book/box/box_txn_management.rst:120
msgid "End the transaction, but cancel all its data-change operations. An explicit call to functions outside ``box.space`` that always yield, such as :ref:`fiber.sleep() <fiber-sleep>` or :ref:`fiber.yield() <fiber-yield>`, will have the same effect."
msgstr ""

#: ../doc/book/box/box_txn_management.rst:129
msgid "Return a descriptor of a savepoint (type = table), which can be used later by :ref:`box.rollback_to_savepoint(savepoint) <box-rollback_to_savepoint>`. Savepoints can only be created while a transaction is active, and they are destroyed when a transaction ends."
msgstr ""

#: ../doc/book/box/box_txn_management.rst:134
msgid "savepoint table"
msgstr ""

#: ../doc/book/box/box_txn_management.rst:135
msgid "Lua object"
msgstr ""

#: ../doc/book/box/box_txn_management.rst:137
#: ../doc/book/box/box_txn_management.rst:150
msgid "error if the savepoint cannot be set in absence of active transaction."
msgstr ""

#: ../doc/book/box/box_txn_management.rst:140
msgid "**Possible errors:** error if for some reason memory cannot be allocated."
msgstr ""

#: ../doc/book/box/box_txn_management.rst:146
msgid "Do not end the transaction, but cancel all its data-change and :ref:`box.savepoint() <box-savepoint>` operations that were done after the specified savepoint."
msgstr ""

#: ../doc/book/box/box_txn_management.rst:153
msgid "**Possible errors:** error if the savepoint does not exist."
msgstr ""

#: ../doc/book/box/box_txn_management.rst:157
msgid "function f()\n"
"  box.begin()           -- start transaction\n"
"  box.space.t:insert{1} -- this will not be rolled back\n"
"  local s = box.savepoint()\n"
"  box.space.t:insert{2} -- this will be rolled back\n"
"  box.rollback_to_savepoint(s)\n"
"  box.commit()          -- end transaction\n"
"end"
msgstr ""

#: ../doc/book/box/box_txn_management.rst:172
msgid "Execute a function, acting as if the function starts with an implicit :ref:`box.begin() <box-begin>` and ends with an implicit :ref:`box.commit() <box-commit>` if successful, or ends with an implicit :ref:`box.rollback() <box-rollback>` if there is an error."
msgstr ""

#: ../doc/book/box/box_txn_management.rst:177
msgid "the result of the function passed to ``atomic()`` as an argument."
msgstr ""

#: ../doc/book/box/box_txn_management.rst:179
msgid "**Possible errors:** any error that :ref:`box.begin() <box-begin>` and"
msgstr ""

#: ../doc/book/box/box_txn_management.rst:180
msgid ":ref:`box.commit() <box-commit>` can return."
msgstr ""

#: ../doc/book/box/box_txn_management.rst:186
msgid "Define a trigger for execution when a transaction ends due to an event such as :ref:`box.commit <box-commit>`."
msgstr ""

#: ../doc/book/box/box_txn_management.rst:189
msgid "The trigger function may take an iterator parameter, as described in an example for this section."
msgstr ""

#: ../doc/book/box/box_txn_management.rst:192
msgid "The trigger function should not access any database spaces."
msgstr ""

#: ../doc/book/box/box_txn_management.rst:194
msgid "If the trigger execution fails and raises an error, the effect is severe and should be avoided -- use Lua's ``pcall()`` mechanism around code that might fail."
msgstr ""

#: ../doc/book/box/box_txn_management.rst:198
msgid "``box.on_commit()`` must be invoked within a transaction, and the trigger ceases to exist when the transaction ends."
msgstr ""

#: ../doc/book/box/box_txn_management.rst:213
msgid "**Simple and useless example:** this will display 'commit happened':"
msgstr ""

#: ../doc/book/box/box_txn_management.rst:215
msgid "function f()\n"
"function f() print('commit happened') end\n"
"box.begin() box.on_commit(f) box.commit()"
msgstr ""

#: ../doc/book/box/box_txn_management.rst:221
msgid "But of course there is more to it: the function parameter can be an ITERATOR."
msgstr ""

#: ../doc/book/box/box_txn_management.rst:223
msgid "The iterator goes through the effects of every request that changed a space during the transaction."
msgstr ""

#: ../doc/book/box/box_txn_management.rst:226
msgid "The iterator will have:"
msgstr ""

#: ../doc/book/box/box_txn_management.rst:228
msgid "an ordinal request number,"
msgstr ""

#: ../doc/book/box/box_txn_management.rst:229
msgid "the old value of the tuple before the request (this will be nil for an insert request),"
msgstr ""

#: ../doc/book/box/box_txn_management.rst:231
msgid "the new value of the tuple after the request (this will be nil for a delete request),"
msgstr ""

#: ../doc/book/box/box_txn_management.rst:233
msgid "and the id of the space."
msgstr ""

#: ../doc/book/box/box_txn_management.rst:235
msgid "**Less simple more useful example:** this will display the effects of two replace requests:"
msgstr ""

#: ../doc/book/box/box_txn_management.rst:238
msgid "box.space.test:drop()\n"
"s = box.schema.space.create('test')\n"
"i = box.space.test:create_index('i')\n"
"function f(iterator)\n"
"  for request_number, old_tuple, new_tuple, space_id in iterator() do\n"
"    print('request_number ' .. tostring(request_number))\n"
"    print('  old_tuple ' .. tostring(old_tuple[1]) .. ' ' .. old_tuple[2])\n"
"    print('  new_tuple ' .. tostring(new_tuple[1]) .. ' ' .. new_tuple[2])\n"
"    print('  space_id ' .. tostring(space_id))\n"
"  end\n"
"end\n"
"s:insert{1,'-'}\n"
"box.begin() s:replace{1,'x'} s:replace{1,'y'} box.on_commit(f) box.commit()"
msgstr ""

#: ../doc/book/box/box_txn_management.rst:254
msgid "The result will look like this:"
msgstr ""

#: ../doc/book/box/box_txn_management.rst:256
msgid "tarantool> box.begin() s:replace{1,'x'} s:replace{1,'y'} box.on_commit(f) box.commit()\n"
"request_number 1\n"
"  old_tuple 1 -\n"
"  new_tuple 1 x\n"
"  space_id 517\n"
"request_number 2\n"
"  old_tuple 1 x\n"
"  new_tuple 1 y\n"
"  space_id 517"
msgstr ""

#: ../doc/book/box/box_txn_management.rst:272
msgid "Define a trigger for execution when a transaction ends due to an event such as :ref:`box.rollback <box-rollback>`."
msgstr ""

#: ../doc/book/box/box_txn_management.rst:275
msgid "The parameters and warnings are exactly the same as for :ref:`box.on-commit <box-on_commit>`."
msgstr ""

#: ../doc/book/box/box_txn_management.rst:282
msgid "If a transaction is in progress (for example the user has called :ref:`box.begin <box-begin>` and has not yet called either :ref:`box.commit <box-commit>` or :ref:`box.rollback <box-rollback>`, return ``true``. Otherwise return ``false``."
msgstr ""

#: ../doc/book/box/data_model.rst:5
msgid "Data model"
msgstr ""

#: ../doc/book/box/data_model.rst:7
msgid "This section describes how Tarantool stores values and what operations with data it supports."
msgstr ""

#: ../doc/book/box/data_model.rst:10
msgid "If you tried to create a database as suggested in our :ref:`\"Getting started\" exercises <getting_started>`, then your test database now looks like this:"
msgstr ""

#: ../doc/book/box/data_model.rst:20
msgid "Space"
msgstr ""

#: ../doc/book/box/data_model.rst:22
msgid "A **space** -- 'tester' in our example -- is a container."
msgstr ""

#: ../doc/book/box/data_model.rst:24
msgid "When Tarantool is being used to store data, there is always at least one space. Each space has a unique **name** specified by the user. Besides, each space has a unique **numeric identifier** which can be specified by the user, but usually is assigned automatically by Tarantool. Finally, a space always has an **engine**: *memtx* (default) -- in-memory engine, fast but limited in size, or *vinyl* -- on-disk engine for huge data sets."
msgstr ""

#: ../doc/book/box/data_model.rst:31
msgid "A space is a container for :ref:`tuples <index-box_tuple>`. To be functional, it needs to have a :ref:`primary index <index-box_index>`. It can also have secondary indexes."
msgstr ""

#: ../doc/book/box/data_model.rst:39
msgid "Tuple"
msgstr ""

#: ../doc/book/box/data_model.rst:41
msgid "A **tuple** plays the same role as a “row” or a “record”, and the components of a tuple (which we call “fields”) play the same role as a “row column” or “record field”, except that:"
msgstr ""

#: ../doc/book/box/data_model.rst:45
msgid "fields can be composite structures, such as arrays or maps, and"
msgstr ""

#: ../doc/book/box/data_model.rst:46
msgid "fields don't need to have names."
msgstr ""

#: ../doc/book/box/data_model.rst:48
msgid "Any given tuple may have any number of fields, and the fields may be of different :ref:`types <index-box_data-types>`. The identifier of a field is the field's number, base 1 (in Lua and other 1-based languages) or base 0 (in PHP or C/C++). For example, ``1`` or ``0`` can be used in some contexts to refer to the first field of a tuple."
msgstr ""

#: ../doc/book/box/data_model.rst:55
msgid "Tuples in Tarantool are stored as `MsgPack <https://en.wikipedia.org/wiki/MessagePack>`_ arrays."
msgstr ""

#: ../doc/book/box/data_model.rst:58
msgid "When Tarantool returns a tuple value in the console, by default it uses :ref:`YAML <interactive_console>` format, for example: ``[3, 'Ace of Base', 1993]``."
msgstr ""

#: ../doc/book/box/data_model.rst:68
msgid "An **index** is a group of key values and pointers."
msgstr ""

#: ../doc/book/box/data_model.rst:70
msgid "As with spaces, you should specify the index **name**, and let Tarantool come up with a unique **numeric identifier** (\"index id\")."
msgstr ""

#: ../doc/book/box/data_model.rst:73
msgid "An index always has a **type**. The default index type is 'TREE'. TREE indexes are provided by all Tarantool engines, can index unique and non-unique values, support partial key searches, comparisons and ordered results. Additionally, memtx engine supports HASH, RTREE and BITSET indexes."
msgstr ""

#: ../doc/book/box/data_model.rst:78
msgid "An index may be **multi-part**, that is, you can declare that an index key value is composed of two or more fields in the tuple, in any order. For example, for an ordinary TREE index, the maximum number of parts is 255."
msgstr ""

#: ../doc/book/box/data_model.rst:82
msgid "An index may be **unique**, that is, you can declare that it would be illegal to have the same key value twice."
msgstr ""

#: ../doc/book/box/data_model.rst:85
msgid "The first index defined on a space is called the **primary key index**, and it must be unique. All other indexes are called **secondary indexes**, and they may be non-unique."
msgstr ""

#: ../doc/book/box/data_model.rst:89
msgid "An index definition may include identifiers of tuple fields and their expected **types** (see allowed :ref:`indexed field types <index-box_indexed-field-types>` below)."
msgstr ""

#: ../doc/book/box/data_model.rst:93
msgid "In our example, we first defined the primary index (named 'primary') based on field #1 of each tuple:"
msgstr ""

#: ../doc/book/box/data_model.rst:96
msgid "tarantool> i = s:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})"
msgstr ""

#: ../doc/book/box/data_model.rst:100
msgid "The effect is that, for all tuples in space 'tester', field #1 must exist and must contain an unsigned integer. The index type is 'hash', so values in field #1 must be unique, because keys in HASH indexes are unique."
msgstr ""

#: ../doc/book/box/data_model.rst:105
msgid "After that, we defined a secondary index (named 'secondary') based on field #2 of each tuple:"
msgstr ""

#: ../doc/book/box/data_model.rst:108
msgid "tarantool> i = s:create_index('secondary', {type = 'tree', parts = {2, 'string'}})"
msgstr ""

#: ../doc/book/box/data_model.rst:112
msgid "The effect is that, for all tuples in space 'tester', field #2 must exist and must contain a string. The index type is 'tree', so values in field #2 must not be unique, because keys in TREE indexes may be non-unique."
msgstr ""

#: ../doc/book/box/data_model.rst:119
msgid "Space definitions and index definitions are stored permanently in Tarantool's system spaces :ref:`_space <box_space-space>` and :ref:`_index <box_space-index>` (for details, see reference on :ref:`box.space <box_space>` submodule)."
msgstr ""

#: ../doc/book/box/data_model.rst:123
msgid "You can add, drop, or alter the definitions at runtime, with some restrictions. See syntax details in reference on :ref:`box <box-module>` module."
msgstr ""

#: ../doc/book/box/data_model.rst:130
msgid "Data types"
msgstr ""

#: ../doc/book/box/data_model.rst:132
msgid "Tarantool is both a database and an application server. Hence a developer often deals with two type sets: the programming language types (e.g. Lua) and the types of the Tarantool storage format (MsgPack)."
msgstr ""

#: ../doc/book/box/data_model.rst:141
msgid "Lua vs MsgPack"
msgstr ""

#: ../doc/book/box/data_model.rst:151
msgid "Scalar / compound"
msgstr ""

#: ../doc/book/box/data_model.rst:151
msgid "MsgPack |nbsp| type"
msgstr ""

#: ../doc/book/box/data_model.rst:151
msgid "Lua type"
msgstr ""

#: ../doc/book/box/data_model.rst:151
msgid "Example value"
msgstr ""

#: ../doc/book/box/data_model.rst:153
#: ../doc/book/box/data_model.rst:155
#: ../doc/book/box/data_model.rst:157
#: ../doc/book/box/data_model.rst:159
#: ../doc/book/box/data_model.rst:161
#: ../doc/book/box/data_model.rst:163
#: ../doc/book/box/data_model.rst:165
msgid "scalar"
msgstr ""

#: ../doc/book/box/data_model.rst:153
msgid "\"`nil`_\""
msgstr ""

#: ../doc/book/box/data_model.rst:153
#: ../doc/book/box/data_model.rst:327
msgid "msgpack.NULL"
msgstr ""

#: ../doc/book/box/data_model.rst:155
msgid "\"`boolean`_\""
msgstr ""

#: ../doc/book/box/data_model.rst:155
#: ../doc/book/box/data_model.rst:316
#: ../doc/book/box/data_model.rst:329
msgid "true"
msgstr ""

#: ../doc/book/box/data_model.rst:157
msgid "\"`string`_\""
msgstr ""

#: ../doc/book/box/data_model.rst:157
msgid "'A B C'"
msgstr ""

#: ../doc/book/box/data_model.rst:159
msgid "integer"
msgstr ""

#: ../doc/book/box/data_model.rst:159
#: ../doc/book/box/data_model.rst:161
msgid "\"`number`_\""
msgstr ""

#: ../doc/book/box/data_model.rst:159
msgid "12345"
msgstr ""

#: ../doc/book/box/data_model.rst:161
msgid "double"
msgstr ""

#: ../doc/book/box/data_model.rst:161
msgid "1.2345"
msgstr ""

#: ../doc/book/box/data_model.rst:163
msgid "bin"
msgstr ""

#: ../doc/book/box/data_model.rst:163
msgid "\"`cdata`_\""
msgstr ""

#: ../doc/book/box/data_model.rst:163
msgid "[!!binary 3t7e]"
msgstr ""

#: ../doc/book/box/data_model.rst:165
msgid "ext"
msgstr ""

#: ../doc/book/box/data_model.rst:165
msgid "(converted to exact number)"
msgstr ""

#: ../doc/book/box/data_model.rst:165
#: ../doc/book/box/data_model.rst:319
msgid "1.2"
msgstr ""

#: ../doc/book/box/data_model.rst:167
#: ../doc/book/box/data_model.rst:169
#: ../doc/book/box/data_model.rst:171
msgid "compound"
msgstr ""

#: ../doc/book/box/data_model.rst:167
msgid "map"
msgstr ""

#: ../doc/book/box/data_model.rst:167
msgid "\"`table`_\" (with string keys)"
msgstr ""

#: ../doc/book/box/data_model.rst:167
msgid "{'a': 5, 'b': 6}"
msgstr ""

#: ../doc/book/box/data_model.rst:169
#: ../doc/book/box/data_model.rst:171
msgid "array"
msgstr ""

#: ../doc/book/box/data_model.rst:169
msgid "\"`table`_\" (with integer keys)"
msgstr ""

#: ../doc/book/box/data_model.rst:169
msgid "[1, 2, 3, 4, 5]"
msgstr ""

#: ../doc/book/box/data_model.rst:171
msgid "tuple (\"`cdata`_\")"
msgstr ""

#: ../doc/book/box/data_model.rst:171
msgid "[12345, 'A B C']"
msgstr ""

#: ../doc/book/box/data_model.rst:181
msgid "In Lua, a **nil** type has only one possible value, also called *nil* (displayed as **null** on Tarantool's command line, since the output is in the YAML format). Nils may be compared to values of any types with == (is-equal) or ~= (is-not-equal), but other operations will not work. Nils may not be used in Lua tables; the workaround is to use :ref:`msgpack.NULL <msgpack-null>`"
msgstr ""

#: ../doc/book/box/data_model.rst:189
msgid "A **boolean** is either ``true`` or ``false``."
msgstr ""

#: ../doc/book/box/data_model.rst:193
msgid "A **string** is a variable-length sequence of bytes, usually represented with alphanumeric characters inside single quotes. In both Lua and MsgPack, strings are treated as binary data, with no attempts to determine a string's character set or to perform any string conversion -- unless there is an optional :ref:`collation <index-collation>`. So, usually, string sorting and comparison are done byte-by-byte, without any special collation rules applied. (Example: numbers are ordered by their point on the number line, so 2345 is greater than 500; meanwhile, strings are ordered by the encoding of the first byte, then the encoding of the second byte, and so on, so '2345' is less than '500'.)"
msgstr ""

#: ../doc/book/box/data_model.rst:206
msgid "In Lua, a **number** is double-precision floating-point, but Tarantool allows both integer and floating-point values. Tarantool will try to store a Lua number as floating-point if the value contains a decimal point or is very large (greater than 100 trillion = 1e14), otherwise Tarantool will store it as an integer. To ensure that even very large numbers are stored as integers, use the :ref:`tonumber64 <other-tonumber64>` function, or the LL (Long Long) suffix, or the ULL (Unsigned Long Long) suffix. Here are examples of numbers using regular notation, exponential notation, the ULL suffix and the ``tonumber64`` function: ``-55``, ``-2.7e+20``, ``100000000000000ULL``, ``tonumber64('18446744073709551615')``."
msgstr ""

#: ../doc/book/box/data_model.rst:217
msgid "An **ext** (extension) value is an addition by Tarantool, not part of the formal MsgPack definition, for storage of decimal values. Values with the decimal type are not floating-point values although they may contain decimal points. They are exact."
msgstr ""

#: ../doc/book/box/data_model.rst:222
msgid "A **bin** (binary) value is not directly supported by Lua but there is a Tarantool type ``VARBINARY`` which is encoded as MessagePack binary. For an (advanced) example showing how to insert VARBINARY into a database, see the Cookbook Recipe for :ref:`ffi_varbinary_insert <cookbook-ffi_varbinary_insert>`."
msgstr ""

#: ../doc/book/box/data_model.rst:227
msgid "Lua **tables** with string keys are stored as MsgPack maps; Lua tables with integer keys starting with 1 -- as MsgPack arrays. Nils may not be used in Lua tables; the workaround is to use :ref:`msgpack.NULL <msgpack-null>`"
msgstr ""

#: ../doc/book/box/data_model.rst:232
msgid "A **tuple** is a light reference to a MsgPack array stored in the database. It is a special type (cdata) to avoid conversion to a Lua table on retrieval. A few functions may return tables with multiple tuples. For more tuple examples, see :ref:`box.tuple <box_tuple>`."
msgstr ""

#: ../doc/book/box/data_model.rst:239
msgid "Tarantool uses the MsgPack format for database storage, which is variable-length. So, for example, the smallest number requires only one byte, but the largest number requires nine bytes."
msgstr ""

#: ../doc/book/box/data_model.rst:243
msgid "Examples of insert requests with different data types:"
msgstr ""

#: ../doc/book/box/data_model.rst:245
msgid "tarantool> box.space.K:insert{1,nil,true,'A B C',12345,1.2345}\n"
"---\n"
"- [1, null, true, 'A B C', 12345, 1.2345]\n"
"...\n"
"tarantool> box.space.K:insert{2,{['a']=5,['b']=6}}\n"
"---\n"
"- [2, {'a': 5, 'b': 6}]\n"
"...\n"
"tarantool> box.space.K:insert{3,{1,2,3,4,5}}\n"
"---\n"
"- [3, [1, 2, 3, 4, 5]]\n"
"..."
msgstr ""

#: ../doc/book/box/data_model.rst:264
msgid "Indexed field types"
msgstr ""

#: ../doc/book/box/data_model.rst:266
msgid "Indexes restrict values which Tarantool's MsgPack may contain. This is why, for example, 'unsigned' is a separate **indexed field type**, compared to ‘integer’ data type in MsgPack: they both store ‘integer’ values, but an 'unsigned' index contains only *non-negative* integer values and an ‘integer’ index contains *all* integer values."
msgstr ""

#: ../doc/book/box/data_model.rst:272
msgid "Here's how Tarantool indexed field types correspond to MsgPack data types."
msgstr ""

#: ../doc/book/box/data_model.rst:285
msgid "Indexed field type"
msgstr ""

#: ../doc/book/box/data_model.rst:285
msgid "MsgPack data type |br| (and possible values)"
msgstr ""

#: ../doc/book/box/data_model.rst:288
msgid "**unsigned** (may also be called ‘uint’ or ‘num’, but ‘num’ is deprecated)"
msgstr ""

#: ../doc/book/box/data_model.rst:288
msgid "**integer** (integer between 0 and 18446744073709551615, i.e. about 18 quintillion)"
msgstr ""

#: ../doc/book/box/data_model.rst:288
#: ../doc/book/box/data_model.rst:308
msgid "TREE, BITSET or HASH"
msgstr ""

#: ../doc/book/box/data_model.rst:288
msgid "123456"
msgstr ""

#: ../doc/book/box/data_model.rst:293
msgid "**integer** (may also be called ‘int’)"
msgstr ""

#: ../doc/book/box/data_model.rst:293
#: ../doc/book/box/data_model.rst:298
#: ../doc/book/box/data_model.rst:332
msgid "**integer** (integer between -9223372036854775808 and 18446744073709551615)"
msgstr ""

#: ../doc/book/box/data_model.rst:293
#: ../doc/book/box/data_model.rst:298
#: ../doc/book/box/data_model.rst:312
#: ../doc/book/box/data_model.rst:316
#: ../doc/book/box/data_model.rst:319
#: ../doc/book/box/data_model.rst:327
msgid "TREE or HASH"
msgstr ""

#: ../doc/book/box/data_model.rst:293
msgid "-2^63"
msgstr ""

#: ../doc/book/box/data_model.rst:303
#: ../doc/book/box/data_model.rst:337
msgid "**double** (single-precision floating point number or double-precision floating point number)"
msgstr ""

#: ../doc/book/box/data_model.rst:298
#: ../doc/book/box/data_model.rst:333
msgid "1.234"
msgstr ""

#: ../doc/book/box/data_model.rst:300
msgid "-44"
msgstr ""

#: ../doc/book/box/data_model.rst:302
msgid "1.447e+44"
msgstr ""

#: ../doc/book/box/data_model.rst:308
msgid "**string** (may also be called ‘str’)"
msgstr ""

#: ../doc/book/box/data_model.rst:308
msgid "**string** (any set of octets, up to the maximum length)"
msgstr ""

#: ../doc/book/box/data_model.rst:308
msgid "‘A B C’"
msgstr ""

#: ../doc/book/box/data_model.rst:310
#: ../doc/book/box/data_model.rst:312
msgid "‘\\\\65 \\\\66 \\\\67’"
msgstr ""

#: ../doc/book/box/data_model.rst:312
msgid "**bin** (any set of octets, up to the maximum length)"
msgstr ""

#: ../doc/book/box/data_model.rst:316
#: ../doc/book/box/data_model.rst:329
msgid "**bool** (true or false)"
msgstr ""

#: ../doc/book/box/data_model.rst:319
msgid "**ext** (extension)"
msgstr ""

#: ../doc/book/box/data_model.rst:322
msgid "**array** (list of numbers representing points in a geometric figure)"
msgstr ""

#: ../doc/book/box/data_model.rst:322
msgid "RTREE"
msgstr ""

#: ../doc/book/box/data_model.rst:322
msgid "{10, 11}"
msgstr ""

#: ../doc/book/box/data_model.rst:324
msgid "{3, 5, 9, 10}"
msgstr ""

#: ../doc/book/box/data_model.rst:327
msgid "**null**"
msgstr ""

#: ../doc/book/box/data_model.rst:342
msgid "**decimal** (value returned by a function in the :ref:`decimal <decimal>` module"
msgstr ""

#: ../doc/book/box/data_model.rst:347
msgid "**string** (any set of octets)"
msgstr ""

#: ../doc/book/box/data_model.rst:349
msgid "**varbinary** (any set of octets)"
msgstr ""

#: ../doc/book/box/data_model.rst:351
msgid "Note: When there is a mix of types, the key order is: null, then booleans, then numbers, then strings, then varbinary."
msgstr ""

#: ../doc/book/box/data_model.rst:331
msgid "-1"
msgstr ""

#: ../doc/book/box/data_model.rst:335
msgid "‘’"
msgstr ""

#: ../doc/book/box/data_model.rst:337
msgid "‘ру’"
msgstr ""

#: ../doc/book/box/data_model.rst:361
msgid "Collations"
msgstr ""

#: ../doc/book/box/data_model.rst:363
msgid "By default, when Tarantool compares strings, it uses what we call a **\"binary\" collation**. The only consideration here is the numeric value of each byte in the string. Therefore, if the string is encoded with ASCII or UTF-8, then ``'A' < 'B' < 'a'``, because the encoding of 'A' (what used to be called the \"ASCII value\") is 65, the encoding of 'B' is 66, and the encoding of 'a' is 98. Binary collation is best if you prefer fast deterministic simple maintenance and searching with Tarantool indexes."
msgstr ""

#: ../doc/book/box/data_model.rst:372
msgid "But if you want the ordering that you see in phone books and dictionaries, then you need Tarantool's optional collations, such as ``unicode`` and ``unicode_ci``, which allow for ``'a' < 'A' < 'B'`` and ``'a' = 'A' < 'B'`` respectively."
msgstr ""

#: ../doc/book/box/data_model.rst:377
msgid "**The unicode and unicode_ci optional collations** use the ordering according to the `Default Unicode Collation Element Table (DUCET) <http://unicode.org/reports/tr10/#Default_Unicode_Collation_Element_Table>`_ and the rules described in `Unicode® Technical Standard #10 Unicode Collation Algorithm (UTS #10 UCA) <http://unicode.org/reports/tr10>`_. The only difference between the two collations is about `weights <https://unicode.org/reports/tr10/#Weight_Level_Defn>`_:"
msgstr ""

#: ../doc/book/box/data_model.rst:384
msgid "``unicode`` collation observes L1 and L2 and L3 weights (strength = 'tertiary'),"
msgstr ""

#: ../doc/book/box/data_model.rst:385
msgid "``unicode_ci`` collation observes only L1 weights (strength = 'primary'), so for example 'a' = 'A' = 'á' = 'Á'."
msgstr ""

#: ../doc/book/box/data_model.rst:387
msgid "As an example, take some Russian words:"
msgstr ""

#: ../doc/book/box/data_model.rst:389
msgid "'ЕЛЕ'\n"
"'елейный'\n"
"'ёлка'\n"
"'еловый'\n"
"'елозить'\n"
"'Ёлочка'\n"
"'ёлочный'\n"
"'ЕЛь'\n"
"'ель'"
msgstr ""

#: ../doc/book/box/data_model.rst:401
msgid "...and show the difference in ordering and selecting by index:"
msgstr ""

#: ../doc/book/box/data_model.rst:403
msgid "with ``unicode`` collation:"
msgstr ""

#: ../doc/book/box/data_model.rst:405
msgid "tarantool> box.space.T:create_index('I', {parts = {{1,'str', collation='unicode'}}})\n"
"...\n"
"tarantool> box.space.T.index.I:select()\n"
"---\n"
"- - ['ЕЛЕ']\n"
"  - ['елейный']\n"
"  - ['ёлка']\n"
"  - ['еловый']\n"
"  - ['елозить']\n"
"  - ['Ёлочка']\n"
"  - ['ёлочный']\n"
"  - ['ель']\n"
"  - ['ЕЛь']\n"
"...\n"
"tarantool> box.space.T.index.I:select{'ЁлКа'}\n"
"---\n"
"- []\n"
"..."
msgstr ""

#: ../doc/book/box/data_model.rst:426
msgid "with ``unicode_ci`` collation:"
msgstr ""

#: ../doc/book/box/data_model.rst:428
msgid "tarantool> box.space.T:create_index('I', {parts = {{1,'str', collation='unicode_ci'}}})\n"
"...\n"
"tarantool> box.space.S.index.I:select()\n"
"---\n"
"- - ['ЕЛЕ']\n"
"  - ['елейный']\n"
"  - ['ёлка']\n"
"  - ['еловый']\n"
"  - ['елозить']\n"
"  - ['Ёлочка']\n"
"  - ['ёлочный']\n"
"  - ['ЕЛь']\n"
"...\n"
"tarantool> box.space.S.index.I:select{'ЁлКа'}\n"
"---\n"
"- - ['ёлка']\n"
"..."
msgstr ""

#: ../doc/book/box/data_model.rst:449
msgid "In all, collation involves much more than these simple examples of upper case / lower case and accented / unaccented equivalence in alphabets. We also consider variations of the same character, non-alphabetic writing systems, and special rules that apply for combinations of characters."
msgstr ""

#: ../doc/book/box/data_model.rst:454
msgid "For English: use \"unicode\" and \"unicode_ci\". For Russian: use \"unicode\" and \"unicode_ci\" (although a few Russians might prefer the Kyrgyz collation which says Cyrillic letters 'Е' and 'Ё' are the same with level-1 weights). For Dutch, German (dictionary), French, Indonesian, Irish, Italian, Lingala, Malay, Portuguese, Southern Soho, Xhosa, or Zulu: \"unicode\" and \"unicode_ci\" will do."
msgstr ""

#: ../doc/book/box/data_model.rst:462
msgid "**The tailored optional collations**: For other languages, Tarantool supplies tailored collations for every modern language that has more than a million native speakers, and for specialized situations such as the difference between dictionary order and telephone book order. To see a complete list say ``box.space._collation:select()``. The tailored collation names have the form unicode_[language code]_[strength] where language code is a standard 2-character or 3-character language abbreviation, and strength is s1 for \"primary strength\" (level-1 weights), s2 for \"secondary\", s3 for \"tertiary\". Tarantool uses the same language codes as the ones in the \"list of tailorable locales\" on man pages of `Ubuntu <http://manpages.ubuntu.com/manpages/bionic/man3/Unicode::Collate::Locale.3perl.html>`_ and `Fedora <http://www.polarhome.com/service/man/?qf=Unicode%3A%3ACollate%3A%3ALocale&af=0&tf=2&of=Fedora>`_. Charts explaining the precise differences from DUCET order are in the `Common Language Data Repository <https://unicode.org/cldr/charts/30/collation>`_."
msgstr ""

#: ../doc/book/box/data_model.rst:488
msgid "A **sequence** is a generator of ordered integer values."
msgstr ""

#: ../doc/book/box/data_model.rst:490
msgid "As with spaces and indexes, you should specify the sequence **name**, and let Tarantool come up with a unique **numeric identifier** (\"sequence id\")."
msgstr ""

#: ../doc/book/box/data_model.rst:493
msgid "As well, you can specify several options when creating a new sequence. The options determine what value will be generated whenever the sequence is used."
msgstr ""

#: ../doc/book/box/data_model.rst:500
msgid "Options for ``box.schema.sequence.create()``"
msgstr ""

#: ../doc/book/box/data_model.rst:513
msgid "Option name"
msgstr ""

#: ../doc/book/box/data_model.rst:513
msgid "Type and meaning"
msgstr ""

#: ../doc/book/box/data_model.rst:515
msgid "**start**"
msgstr ""

#: ../doc/book/box/data_model.rst:515
msgid "Integer. The value to generate the first time a sequence is used"
msgstr ""

#: ../doc/book/box/data_model.rst:515
msgid "start=0"
msgstr ""

#: ../doc/book/box/data_model.rst:519
msgid "**min**"
msgstr ""

#: ../doc/book/box/data_model.rst:519
msgid "Integer. Values smaller than this cannot be generated"
msgstr ""

#: ../doc/book/box/data_model.rst:519
msgid "min=-1000"
msgstr ""

#: ../doc/book/box/data_model.rst:522
msgid "**max**"
msgstr ""

#: ../doc/book/box/data_model.rst:522
msgid "Integer. Values larger than this cannot be generated"
msgstr ""

#: ../doc/book/box/data_model.rst:522
msgid "9223372036854775807"
msgstr ""

#: ../doc/book/box/data_model.rst:522
msgid "max=0"
msgstr ""

#: ../doc/book/box/data_model.rst:525
msgid "**cycle**"
msgstr ""

#: ../doc/book/box/data_model.rst:525
msgid "Boolean. Whether to start again when values cannot be generated"
msgstr ""

#: ../doc/book/box/data_model.rst:525
msgid "cycle=true"
msgstr ""

#: ../doc/book/box/data_model.rst:528
msgid "**cache**"
msgstr ""

#: ../doc/book/box/data_model.rst:528
msgid "Integer. The number of values to store in a cache"
msgstr ""

#: ../doc/book/box/data_model.rst:528
msgid "cache=0"
msgstr ""

#: ../doc/book/box/data_model.rst:531
msgid "**step**"
msgstr ""

#: ../doc/book/box/data_model.rst:531
msgid "Integer. What to add to the previous generated value, when generating a new value"
msgstr ""

#: ../doc/book/box/data_model.rst:531
msgid "step=-1"
msgstr ""

#: ../doc/book/box/data_model.rst:535
msgid "**if_not_exists**"
msgstr ""

#: ../doc/book/box/data_model.rst:535
msgid "Boolean. If this is true and a sequence with this name exists already, ignore other options and use the existing values"
msgstr ""

#: ../doc/book/box/data_model.rst:535
msgid "if_not_exists=true"
msgstr ""

#: ../doc/book/box/data_model.rst:541
msgid "Once a sequence exists, it can be altered, dropped, reset, forced to generate the next value, or associated with an index."
msgstr ""

#: ../doc/book/box/data_model.rst:544
msgid "For an initial example, we generate a sequence named 'S'."
msgstr ""

#: ../doc/book/box/data_model.rst:546
msgid "tarantool> box.schema.sequence.create('S',{min=5, start=5})\n"
"---\n"
"- step: 1\n"
"  id: 5\n"
"  min: 5\n"
"  cache: 0\n"
"  uid: 1\n"
"  max: 9223372036854775807\n"
"  cycle: false\n"
"  name: S\n"
"  start: 5\n"
"..."
msgstr ""

#: ../doc/book/box/data_model.rst:561
msgid "The result shows that the new sequence has all default values, except for the two that were specified, ``min`` and ``start``."
msgstr ""

#: ../doc/book/box/data_model.rst:564
msgid "Then we get the next value, with the ``next()`` function."
msgstr ""

#: ../doc/book/box/data_model.rst:566
msgid "tarantool> box.sequence.S:next()\n"
"---\n"
"- 5\n"
"..."
msgstr ""

#: ../doc/book/box/data_model.rst:573
msgid "The result is the same as the start value. If we called ``next()`` again, we would get 6 (because the previous value plus the step value is 6), and so on."
msgstr ""

#: ../doc/book/box/data_model.rst:577
msgid "Then we create a new table, and say that its primary key may be generated from the sequence."
msgstr ""

#: ../doc/book/box/data_model.rst:580
msgid "tarantool> s=box.schema.space.create('T');s:create_index('I',{sequence='S'})\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/box/data_model.rst:586
msgid "Then we insert a tuple, without specifying a value for the primary key."
msgstr ""

#: ../doc/book/box/data_model.rst:588
msgid "tarantool> box.space.T:insert{nil,'other stuff'}\n"
"---\n"
"- [6, 'other stuff']\n"
"..."
msgstr ""

#: ../doc/book/box/data_model.rst:595
msgid "The result is a new tuple where the first field has a value of 6. This arrangement, where the system automatically generates the values for a primary key, is sometimes called \"auto-incrementing\" or \"identity\"."
msgstr ""

#: ../doc/book/box/data_model.rst:600
msgid "For syntax and implementation details, see the reference for :ref:`box.schema.sequence <box_schema-sequence>`."
msgstr ""

#: ../doc/book/box/data_model.rst:607
msgid "Persistence"
msgstr ""

#: ../doc/book/box/data_model.rst:609
msgid "In Tarantool, updates to the database are recorded in the so-called :ref:`write ahead log (WAL) <internals-wal>` files. This ensures data persistence. When a power outage occurs or the Tarantool instance is killed incidentally, the in-memory database is lost. In this situation, WAL files are used to restore the data. Namely, Tarantool reads the WAL files and redoes the requests (this is called the \"recovery process\"). You can change the timing of the WAL writer, or turn it off, by setting :ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>`."
msgstr ""

#: ../doc/book/box/data_model.rst:618
msgid "Tarantool also maintains a set of :ref:`snapshot files <internals-snapshot>`. These files contain an on-disk copy of the entire data set for a given moment. Instead of reading every WAL file since the databases were created, the recovery process can load the latest snapshot file and then read only those WAL files that were produced after the snapshot file was made. After checkpointing, old WAL files can be removed to free up space."
msgstr ""

#: ../doc/book/box/data_model.rst:625
msgid "To force immediate creation of a snapshot file, you can use Tarantool's :ref:`box.snapshot() <box-snapshot>` request. To enable automatic creation of snapshot files, you can use Tarantool's :ref:`checkpoint daemon <book_cfg_checkpoint_daemon>`. The checkpoint daemon sets intervals for forced checkpoints. It makes sure that the states of both memtx and vinyl storage engines are synchronized and saved to disk, and automatically removes old WAL files."
msgstr ""

#: ../doc/book/box/data_model.rst:633
msgid "Snapshot files can be created even if there is no WAL file."
msgstr ""

#: ../doc/book/box/data_model.rst:637
msgid "The memtx engine makes only regular checkpoints with the interval set in :ref:`checkpoint daemon <book_cfg_checkpoint_daemon>` configuration."
msgstr ""

#: ../doc/book/box/data_model.rst:640
msgid "The vinyl engine runs checkpointing in the background at all times."
msgstr ""

#: ../doc/book/box/data_model.rst:642
msgid "See the :ref:`Internals <internals-data_persistence>` section for more details about the WAL writer and the recovery process."
msgstr ""

#: ../doc/book/box/data_model.rst:649
msgid "Operations"
msgstr ""

#: ../doc/book/box/data_model.rst:655
msgid "Data operations"
msgstr ""

#: ../doc/book/box/data_model.rst:657
msgid "The basic data operations supported in Tarantool are:"
msgstr ""

#: ../doc/book/box/data_model.rst:659
msgid "five data-manipulation operations (INSERT, UPDATE, UPSERT, DELETE, REPLACE), and"
msgstr ""

#: ../doc/book/box/data_model.rst:660
msgid "one data-retrieval operation (SELECT)."
msgstr ""

#: ../doc/book/box/data_model.rst:662
msgid "All of them are implemented as functions in :ref:`box.space <box_space>` submodule."
msgstr ""

#: ../doc/book/box/data_model.rst:666
msgid ":ref:`INSERT <box_space-insert>`: Add a new tuple to space 'tester'."
msgstr ""

#: ../doc/book/box/data_model.rst:668
msgid "The first field, field[1], will be 999 (MsgPack type is `integer`)."
msgstr ""

#: ../doc/book/box/data_model.rst:670
msgid "The second field, field[2], will be 'Taranto' (MsgPack type is `string`)."
msgstr ""

#: ../doc/book/box/data_model.rst:672
msgid "tarantool> box.space.tester:insert{999, 'Taranto'}"
msgstr ""

#: ../doc/book/box/data_model.rst:676
msgid ":ref:`UPDATE <box_space-update>`: Update the tuple, changing field field[2]."
msgstr ""

#: ../doc/book/box/data_model.rst:678
msgid "The clause \"{999}\", which has the value to look up in the index of the tuple's primary-key field, is mandatory, because ``update()`` requests must always have a clause that specifies a unique key, which in this case is field[1]."
msgstr ""

#: ../doc/book/box/data_model.rst:682
msgid "The clause \"{{'=', 2, 'Tarantino'}}\" specifies that assignment will happen to field[2] with the new value."
msgstr ""

#: ../doc/book/box/data_model.rst:685
msgid "tarantool> box.space.tester:update({999}, {{'=', 2, 'Tarantino'}})"
msgstr ""

#: ../doc/book/box/data_model.rst:689
msgid ":ref:`UPSERT <box_space-upsert>`: Upsert the tuple, changing field field[2] again."
msgstr ""

#: ../doc/book/box/data_model.rst:692
msgid "The syntax of ``upsert()`` is similar to the syntax of ``update()``. However, the execution logic of these two requests is different. UPSERT is either UPDATE or INSERT, depending on the database's state. Also, UPSERT execution is postponed until after transaction commit, so, unlike ``update()``, ``upsert()`` doesn't return data back."
msgstr ""

#: ../doc/book/box/data_model.rst:698
msgid "tarantool> box.space.tester:upsert({999, 'Taranted'}, {{'=', 2, 'Tarantism'}})"
msgstr ""

#: ../doc/book/box/data_model.rst:702
msgid ":ref:`REPLACE <box_space-replace>`: Replace the tuple, adding a new field."
msgstr ""

#: ../doc/book/box/data_model.rst:704
msgid "This is also possible with the ``update()`` request, but the ``update()`` request is usually more complicated."
msgstr ""

#: ../doc/book/box/data_model.rst:707
msgid "tarantool> box.space.tester:replace{999, 'Tarantella', 'Tarantula'}"
msgstr ""

#: ../doc/book/box/data_model.rst:711
msgid ":ref:`SELECT <box_space-select>`: Retrieve the tuple."
msgstr ""

#: ../doc/book/box/data_model.rst:713
msgid "The clause \"{999}\" is still mandatory, although it does not have to mention the primary key."
msgstr ""

#: ../doc/book/box/data_model.rst:716
msgid "tarantool> box.space.tester:select{999}"
msgstr ""

#: ../doc/book/box/data_model.rst:720
msgid ":ref:`DELETE <box_space-delete>`: Delete the tuple."
msgstr ""

#: ../doc/book/box/data_model.rst:722
msgid "In this example, we identify the primary-key field."
msgstr ""

#: ../doc/book/box/data_model.rst:724
msgid "tarantool> box.space.tester:delete{999}"
msgstr ""

#: ../doc/book/box/data_model.rst:728
msgid "Summarizing the examples:"
msgstr ""

#: ../doc/book/box/data_model.rst:730
msgid "Functions ``insert`` and ``replace`` accept a tuple (where a primary key comes as part of the tuple)."
msgstr ""

#: ../doc/book/box/data_model.rst:732
msgid "Function ``upsert`` accepts a tuple (where a primary key comes as part of the tuple), and also the update operations to execute."
msgstr ""

#: ../doc/book/box/data_model.rst:735
msgid "Function ``delete`` accepts a full key of any unique index (primary or secondary)."
msgstr ""

#: ../doc/book/box/data_model.rst:737
msgid "Function ``update`` accepts a full key of any unique index (primary or secondary), and also the operations to execute."
msgstr ""

#: ../doc/book/box/data_model.rst:740
msgid "Function ``select`` accepts any key: primary/secondary, unique/non-unique, full/partial."
msgstr ""

#: ../doc/book/box/data_model.rst:743
msgid "See reference on ``box.space`` for more :ref:`details on using data operations <box_space-operations-detailed-examples>`."
msgstr ""

#: ../doc/book/box/data_model.rst:748
msgid "Besides Lua, you can use :ref:`Perl, PHP, Python or other programming language connectors <index-box_connectors>`. The client server protocol is open and documented. See this :ref:`annotated BNF <box_protocol-iproto_protocol>`."
msgstr ""

#: ../doc/book/box/data_model.rst:757
msgid "Index operations"
msgstr ""

#: ../doc/book/box/data_model.rst:759
msgid "Index operations are automatic: if a data-manipulation request changes a tuple, then it also changes the index keys defined for the tuple."
msgstr ""

#: ../doc/book/box/data_model.rst:762
msgid "The simple index-creation operation that we've illustrated before is:"
msgstr ""

#: ../doc/book/box/data_model.rst:801
msgid ":samp:`box.space.{space-name}:create_index('{index-name}')`"
msgstr ""

#: ../doc/book/box/data_model.rst:769
msgid "This creates a unique TREE index on the first field of all tuples (often called \"Field#1\"), which is assumed to be numeric."
msgstr ""

#: ../doc/book/box/data_model.rst:772
msgid "The simple SELECT request that we've illustrated before is:"
msgstr ""

#: ../doc/book/box/data_model.rst:811
msgid ":extsamp:`box.space.{*{space-name}*}:select({*{value}*})`"
msgstr ""

#: ../doc/book/box/data_model.rst:779
msgid "This looks for a single tuple via the first index. Since the first index is always unique, the maximum number of returned tuples will be: one."
msgstr ""

#: ../doc/book/box/data_model.rst:782
msgid "The following SELECT variations exist:"
msgstr ""

#: ../doc/book/box/data_model.rst:784
msgid "The search can use comparisons other than equality."
msgstr ""

#: ../doc/book/box/data_model.rst:823
msgid ":extsamp:`box.space.{*{space-name}*}:select(value, {iterator = 'GT'})`"
msgstr ""

#: ../doc/book/box/data_model.rst:791
msgid "The :ref:`comparison operators <box_index-iterator-types>` are LT, LE, EQ, REQ, GE, GT (for \"less than\", \"less than or equal\", \"equal\", \"reversed equal\", \"greater than or equal\", \"greater than\" respectively). Comparisons make sense if and only if the index type is ‘TREE'."
msgstr ""

#: ../doc/book/box/data_model.rst:796
msgid "This type of search may return more than one tuple; if so, the tuples will be in descending order by key when the comparison operator is LT or LE or REQ, otherwise in ascending order."
msgstr ""

#: ../doc/book/box/data_model.rst:800
msgid "The search can use a secondary index."
msgstr ""

#: ../doc/book/box/data_model.rst:839
msgid ":extsamp:`box.space.{*{space-name}*}.index.{*{index-name}*}:select(value)`"
msgstr ""

#: ../doc/book/box/data_model.rst:807
msgid "For a primary-key search, it is optional to specify an index name. For a secondary-key search, it is mandatory."
msgstr ""

#: ../doc/book/box/data_model.rst:810
msgid "The search may be for some or all key parts."
msgstr ""

#: ../doc/book/box/data_model.rst:849
msgid "-- Suppose an index has two parts\n"
":samp:`tarantool> box.space.{space-name}.index.{index-name}.parts`\n"
"---\n"
"- - type: unsigned\n"
"    fieldno: 1\n"
"  - type: string\n"
"    fieldno: 2\n"
"...\n"
"-- Suppose the space has three tuples\n"
":samp:`box.space.{space-name}:select()`\n"
"---\n"
"- - [1, 'A']\n"
"  - [1, 'B']\n"
"  - [2, '']\n"
"..."
msgstr ""

#: ../doc/book/box/data_model.rst:831
msgid "The search may be for all fields, using a table for the value:"
msgstr ""

#: ../doc/book/box/data_model.rst:870
msgid ":extsamp:`box.space.{*{space-name}*}:select({1, 'A'})`"
msgstr ""

#: ../doc/book/box/data_model.rst:838
msgid "or the search can be for one field, using a table or a scalar:"
msgstr ""

#: ../doc/book/box/data_model.rst:877
msgid ":samp:`box.space.{space-name}:select(1)`"
msgstr ""

#: ../doc/book/box/data_model.rst:845
msgid "In the second case, the result will be two tuples: ``{1, 'A'}`` and ``{1, 'B'}``."
msgstr ""

#: ../doc/book/box/data_model.rst:848
msgid "You can specify even zero fields, causing all three tuples to be returned. (Notice that partial key searches are available only in TREE indexes.)"
msgstr ""

#: ../doc/book/box/data_model.rst:851
msgid "**Examples**"
msgstr ""

#: ../doc/book/box/data_model.rst:853
msgid "BITSET example:"
msgstr ""

#: ../doc/book/box/data_model.rst:855
msgid "tarantool> box.schema.space.create('bitset_example')\n"
"tarantool> box.space.bitset_example:create_index('primary')\n"
"tarantool> box.space.bitset_example:create_index('bitset',{unique=false,type='BITSET', parts={2,'unsigned'}})\n"
"tarantool> box.space.bitset_example:insert{1,1}\n"
"tarantool> box.space.bitset_example:insert{2,4}\n"
"tarantool> box.space.bitset_example:insert{3,7}\n"
"tarantool> box.space.bitset_example:insert{4,3}\n"
"tarantool> box.space.bitset_example.index.bitset:select(2, {iterator='BITS_ANY_SET'})"
msgstr ""

#: ../doc/book/box/data_model.rst:866
#: ../doc/book/box/data_model.rst:888
msgid "The result will be:"
msgstr ""

#: ../doc/book/box/data_model.rst:868
msgid "---\n"
"- - [3, 7]\n"
"  - [4, 3]\n"
"..."
msgstr ""

#: ../doc/book/box/data_model.rst:875
msgid "because (7 AND 2) is not equal to 0, and (3 AND 2) is not equal to 0."
msgstr ""

#: ../doc/book/box/data_model.rst:877
msgid "RTREE example:"
msgstr ""

#: ../doc/book/box/data_model.rst:879
msgid "tarantool> box.schema.space.create('rtree_example')\n"
"tarantool> box.space.rtree_example:create_index('primary')\n"
"tarantool> box.space.rtree_example:create_index('rtree',{unique=false,type='RTREE', parts={2,'ARRAY'}})\n"
"tarantool> box.space.rtree_example:insert{1, {3, 5, 9, 10}}\n"
"tarantool> box.space.rtree_example:insert{2, {10, 11}}\n"
"tarantool> box.space.rtree_example.index.rtree:select({4, 7, 5, 9}, {iterator = 'GT'})"
msgstr ""

#: ../doc/book/box/data_model.rst:890
msgid "---\n"
"- - [1, [3, 5, 9, 10]]\n"
"..."
msgstr ""

#: ../doc/book/box/data_model.rst:896
msgid "because a rectangle whose corners are at coordinates ``4,7,5,9`` is entirely within a rectangle whose corners are at coordinates ``3,5,9,10``."
msgstr ""

#: ../doc/book/box/data_model.rst:899
msgid "Additionally, there exist :ref:`index iterator operations <box_index-index_pairs>`. They can only be used with code in Lua and C/C++. Index iterators are for traversing indexes one key at a time, taking advantage of features that are specific to an index type, for example evaluating Boolean expressions when traversing BITSET indexes, or going in descending order when traversing TREE indexes."
msgstr ""

#: ../doc/book/box/data_model.rst:905
msgid "See also other index operations like :ref:`alter() <box_index-alter>` and :ref:`drop() <box_index-drop>` in reference for :ref:`box.index <box_index>` submodule."
msgstr ""

#: ../doc/book/box/data_model.rst:910
msgid "Complexity factors"
msgstr ""

#: ../doc/book/box/data_model.rst:912
msgid "In reference for :ref:`box.space <box_space>` and :ref:`box.index <box_index>` submodules, there are notes about which complexity factors might affect the resource usage of each function."
msgstr ""

#: ../doc/book/box/data_model.rst:924
msgid "Complexity factor"
msgstr ""

#: ../doc/book/box/data_model.rst:927
msgid "Index size"
msgstr ""

#: ../doc/book/box/data_model.rst:927
msgid "The number of index keys is the same as the number of tuples in the data set. For a TREE index, if there are more keys, then the lookup time will be greater, although of course the effect is not linear. For a HASH index, if there are more keys, then there is more RAM used, but the number of low-level steps tends to remain constant."
msgstr ""

#: ../doc/book/box/data_model.rst:935
msgid "Typically, a HASH index is faster than a TREE index if the number of tuples in the space is greater than one."
msgstr ""

#: ../doc/book/box/data_model.rst:939
msgid "Number of indexes accessed"
msgstr ""

#: ../doc/book/box/data_model.rst:939
msgid "Ordinarily, only one index is accessed to retrieve one tuple. But to update the tuple, there must be N accesses if the space has N different indexes."
msgstr ""

#: ../doc/book/box/data_model.rst:943
msgid "Note re storage engine: Vinyl optimizes away such accesses if secondary index fields are unchanged by the update. So, this complexity factor applies only to memtx, since it always makes a full-tuple copy on every update."
msgstr ""

#: ../doc/book/box/data_model.rst:949
msgid "Number of tuples accessed"
msgstr ""

#: ../doc/book/box/data_model.rst:949
msgid "A few requests, for example SELECT, can retrieve multiple tuples. This factor is usually less important than the others."
msgstr ""

#: ../doc/book/box/data_model.rst:953
msgid "WAL settings"
msgstr ""

#: ../doc/book/box/data_model.rst:953
msgid "The important setting for the write-ahead log is :ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>`. If the setting causes no writing or delayed writing, this factor is unimportant. If the setting causes every data-change request to wait for writing to finish on a slow device, this factor is more important than all the others."
msgstr ""

#: ../doc/book/box/engines/index.rst:5
msgid "Storage engines"
msgstr ""

#: ../doc/book/box/engines/index.rst:7
msgid "A storage engine is a set of very-low-level routines which actually store and retrieve tuple values. Tarantool offers a choice of two storage engines:"
msgstr ""

#: ../doc/book/box/engines/index.rst:10
msgid "memtx (the in-memory storage engine) is the default and was the first to arrive."
msgstr ""

#: ../doc/book/box/engines/index.rst:13
msgid "vinyl (the on-disk storage engine) is a working key-value engine and will especially appeal to users who like to see data go directly to disk, so that recovery time might be shorter and database size might be larger."
msgstr ""

#: ../doc/book/box/engines/index.rst:17
msgid "On the other hand, vinyl lacks some functions and options that are available with memtx. Where that is the case, the relevant description in this manual contains a note beginning with the words \"Note re storage engine\"."
msgstr ""

#: ../doc/book/box/engines/index.rst:21
msgid "Further in this section we discuss the details of storing data using the vinyl storage engine."
msgstr ""

#: ../doc/book/box/engines/index.rst:24
msgid "To specify that the engine should be vinyl, add the clause ``engine = 'vinyl'`` when creating a space, for example:"
msgstr ""

#: ../doc/book/box/engines/index.rst:27
msgid "space = box.schema.space.create('name', {engine='vinyl'})"
msgstr ""

#: ../doc/book/box/engines/index.rst:35
msgid "Differences between memtx and vinyl storage engines"
msgstr ""

#: ../doc/book/box/engines/index.rst:37
msgid "The primary difference between memtx and vinyl is that memtx is an \"in-memory\" engine while vinyl is an \"on-disk\" engine. An in-memory storage engine is generally faster (each query is usually run under 1 ms), and the memtx engine is justifiably the default for Tarantool, but on-disk engine such as vinyl is preferable when the database is larger than the available memory and adding more memory is not a realistic option."
msgstr ""

#: ../doc/book/box/engines/index.rst:50
msgid "Option"
msgstr ""

#: ../doc/book/box/engines/index.rst:50
msgid "memtx"
msgstr ""

#: ../doc/book/box/engines/index.rst:50
msgid "vinyl"
msgstr ""

#: ../doc/book/box/engines/index.rst:52
msgid "Supported index type"
msgstr ""

#: ../doc/book/box/engines/index.rst:52
msgid "TREE, HASH, :ref:`RTREE <box_index-rtree>` or BITSET"
msgstr ""

#: ../doc/book/box/engines/index.rst:52
msgid "TREE"
msgstr ""

#: ../doc/book/box/engines/index.rst:54
msgid "Temporary spaces"
msgstr ""

#: ../doc/book/box/engines/index.rst:54
#: ../doc/book/box/engines/index.rst:56
#: ../doc/book/box/engines/index.rst:58
msgid "Supported"
msgstr ""

#: ../doc/book/box/engines/index.rst:54
#: ../doc/book/box/engines/index.rst:56
msgid "Not supported"
msgstr ""

#: ../doc/book/box/engines/index.rst:56
msgid ":ref:`random() <box_index-random>` function"
msgstr ""

#: ../doc/book/box/engines/index.rst:58
msgid ":ref:`alter() <box_index-alter>` function"
msgstr ""

#: ../doc/book/box/engines/index.rst:58
msgid "Supported starting from the 1.10.2 release (the primary index cannot be modified)"
msgstr ""

#: ../doc/book/box/engines/index.rst:61
msgid ":ref:`len() <box_space-len>` function"
msgstr ""

#: ../doc/book/box/engines/index.rst:61
msgid "Returns the number of tuples in the space"
msgstr ""

#: ../doc/book/box/engines/index.rst:61
msgid "Returns the maximum approximate number of tuples in the space"
msgstr ""

#: ../doc/book/box/engines/index.rst:64
msgid ":ref:`count() <box_index-count>` function"
msgstr ""

#: ../doc/book/box/engines/index.rst:64
msgid "Takes a constant amount of time"
msgstr ""

#: ../doc/book/box/engines/index.rst:64
msgid "Takes a variable amount of time depending on a state of a DB"
msgstr ""

#: ../doc/book/box/engines/index.rst:67
msgid ":ref:`delete() <box_space-delete>` function"
msgstr ""

#: ../doc/book/box/engines/index.rst:67
msgid "Returns the deleted tuple, if any"
msgstr ""

#: ../doc/book/box/engines/index.rst:67
msgid "Always returns nil"
msgstr ""

#: ../doc/book/box/engines/index.rst:69
msgid "yield"
msgstr ""

#: ../doc/book/box/engines/index.rst:69
msgid "Does not yield on the select requests unless the transaction is commited to WAL"
msgstr ""

#: ../doc/book/box/engines/index.rst:69
msgid "Yields on the select requests or on its equivalents: get() or pairs()"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:5
#: ../doc/book/box/engines/vinyl.rst:5
msgid "Storing data with vinyl"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:7
#: ../doc/book/box/engines/vinyl.rst:7
msgid "Tarantool is a transactional and persistent DBMS that maintains 100% of its data in RAM. The greatest advantages of in-memory databases are their speed and ease of use: they demonstrate consistently high performance, but you never need to tune them."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:12
#: ../doc/book/box/engines/vinyl.rst:12
msgid "A few years ago we decided to extend the product by implementing a classical storage engine similar to those used by regular DBMSes: it uses RAM for caching, while the bulk of its data is stored on disk. We decided to make it possible to set a storage engine independently for each table in the database, which is the same way that MySQL approaches it, but we also wanted to support transactions from the very beginning."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:19
#: ../doc/book/box/engines/vinyl.rst:19
msgid "The first question we needed to answer was whether to create our own storage engine or use an existing library. The open-source community offered a few viable solutions. The RocksDB library was the fastest growing open-source library and is currently one of the most prominent out there. There were also several lesser-known libraries to consider, such as WiredTiger, ForestDB, NestDB, and LMDB."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:26
#: ../doc/book/box/engines/vinyl.rst:26
msgid "Nevertheless, after studying the source code of existing libraries and considering the pros and cons, we opted for our own storage engine. One reason is that the existing third-party libraries expected requests to come from multiple operating system threads and thus contained complex synchronization primitives for controlling parallel data access. If we had decided to embed one of these in Tarantool, we would have made our users bear the overhead of a multithreaded application without getting anything in return. The thing is, Tarantool has an actor-based architecture. The way it processes transactions in a dedicated thread allows it to do away with the unnecessary locks, interprocess communication, and other overhead that accounts for up to 80% of processor time in multithreaded DBMSes."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:41
#: ../doc/book/box/engines/vinyl.rst:41
msgid "*The Tarantool process consists of a fixed number of \"actor\" threads*"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:43
#: ../doc/book/box/engines/vinyl.rst:43
msgid "If you design a database engine with cooperative multitasking in mind right from the start, it not only significantly speeds up the development process, but also allows the implementation of certain optimization tricks that would be too complex for multithreaded engines. In short, using a third-party solution wouldn’t have yielded the best result."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:53
#: ../doc/book/box/engines/vinyl.rst:53
msgid "Algorithm"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:55
#: ../doc/book/box/engines/vinyl.rst:55
msgid "Once the idea of using an existing library was off the table, we needed to pick an architecture to build upon. There are two competing approaches to on-disk data storage: the older one relies on B-trees and their variations; the newer one advocates the use of log-structured merge-trees, or \"LSM\" trees. MySQL, PostgreSQL, and Oracle use B-trees, while Cassandra, MongoDB, and CockroachDB have adopted LSM trees."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:62
#: ../doc/book/box/engines/vinyl.rst:62
msgid "B-trees are considered better suited for reads and LSM trees—for writes. However, with SSDs becoming more widespread and the fact that SSDs have read throughput that’s several times greater than write throughput, the advantages of LSM trees in most scenarios was more obvious to us."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:67
#: ../doc/book/box/engines/vinyl.rst:67
msgid "Before dissecting LSM trees in Tarantool, let’s take a look at how they work. To do that, we’ll begin by analyzing a regular B-tree and the issues it faces. A B-tree is a balanced tree made up of blocks, which contain sorted lists of key- value pairs. (Topics such as filling and balancing a B-tree or splitting and merging blocks are outside of the scope of this article and can easily be found on Wikipedia). As a result, we get a container sorted by key, where the smallest element is stored in the leftmost node and the largest one in the rightmost node. Let’s have a look at how insertions and searches in a B-tree happen."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:78
#: ../doc/book/box/engines/vinyl.rst:78
msgid "*Classical B-tree*"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:80
#: ../doc/book/box/engines/vinyl.rst:80
msgid "If you need to find an element or check its membership, the search starts at the root, as usual. If the key is found in the root block, the search stops; otherwise, the search visits the rightmost block holding the largest element that’s not larger than the key being searched (recall that elements at each level are sorted). If the first level yields no results, the search proceeds to the next level. Finally, the search ends up in one of the leaves and probably locates the needed key. Blocks are stored and read into RAM one by one, meaning the algorithm reads :math:`logB(N)` blocks in a single search, where N is the number of elements in the B-tree. In the simplest case, writes are done similarly: the algorithm finds the block that holds the necessary element and updates (inserts) its value."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:92
#: ../doc/book/box/engines/vinyl.rst:92
msgid "To better understand the data structure, let’s consider a practical example: say we have a B-tree with 100,000,000 nodes, a block size of 4096 bytes, and an element size of 100 bytes. Thus each block will hold up to 40 elements (all overhead considered), and the B-tree will consist of around 2,570,000 blocks and 5 levels: the first four will have a size of 256 Mb, while the last one will grow up to 10 Gb. Obviously, any modern computer will be able to store all of the levels except the last one in filesystem cache, so read requests will require just a single I/O operation."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:101
#: ../doc/book/box/engines/vinyl.rst:101
msgid "But if we change our perspective —B-trees don’t look so good anymore. Suppose we need to update a single element. Since working with B-trees involves reading and writing whole blocks, we would have to read in one whole block, change our 100 bytes out of 4096, and then write the whole updated block to disk. In other words,we were forced to write 40 times more data than we actually modified!"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:108
#: ../doc/book/box/engines/vinyl.rst:108
msgid "If you take into account the fact that an SSD block has a size of 64 Kb+ and not every modification changes a whole element, the extra disk workload can be greater still."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:113
#: ../doc/book/box/engines/vinyl.rst:113
msgid "Authors of specialized literature and blogs dedicated to on-disk data storage have coined two terms for these phenomena: extra reads are referred to as \"read amplification\" and writes as \"write amplification\"."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:117
#: ../doc/book/box/engines/vinyl.rst:117
msgid "The amplification factor (multiplication coefficient) is calculated as the ratio of the size of actual read (or written) data to the size of data needed (or actually changed). In our B-tree example, the amplification factor would be around 40 for both reads and writes."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:123
#: ../doc/book/box/engines/vinyl.rst:123
msgid "The huge number of extra I/O operations associated with updating data is one of the main issues addressed by LSM trees. Let’s see how they work."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:127
#: ../doc/book/box/engines/vinyl.rst:127
msgid "The key difference between LSM trees and regular B-trees is that LSM trees don’t just store data (keys and values), but also data operations: insertions and deletions."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:133
#: ../doc/book/box/engines/vinyl.rst:189
#: ../doc/book/box/engines/vinyl.rst:204
#: ../doc/book/box/engines/vinyl.rst:226
#: ../doc/book/box/engines/vinyl.rst:278
#: ../doc/book/box/engines/vinyl.rst:303
#: ../doc/book/box/engines/vinyl.rst:640
#: ../doc/book/box/engines/vinyl.rst:792
#: ../doc/book/box/engines/vinyl.rst:133
#: ../doc/book/box/engines/vinyl.rst:189
#: ../doc/book/box/engines/vinyl.rst:204
#: ../doc/book/box/engines/vinyl.rst:226
#: ../doc/book/box/engines/vinyl.rst:278
#: ../doc/book/box/engines/vinyl.rst:303
#: ../doc/book/box/engines/vinyl.rst:640
#: ../doc/book/box/engines/vinyl.rst:792
msgid "|br|"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:135
#: ../doc/book/box/engines/vinyl.rst:135
msgid "LSM tree:"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:140
#: ../doc/book/box/engines/vinyl.rst:140
msgid "Stores statements, not values:"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:142
#: ../doc/book/box/engines/vinyl.rst:142
msgid "Every statement is marked by LSN Append-only files, garbage is collected after a checkpoint"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:144
#: ../doc/book/box/engines/vinyl.rst:144
msgid "Transactional log of all filesystem changes: vylog"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:146
#: ../doc/book/box/engines/vinyl.rst:146
msgid "For example, an element corresponding to an insertion operation has, apart from a key and a value, an extra byte with an operation code (\"REPLACE\" in the image above). An element representing the deletion operation contains a key (since storing a value is unnecessary) and the corresponding operation code—\"DELETE\". Also, each LSM tree element has a log sequence number (LSN), which is the value of a monotonically increasing sequence that uniquely identifies each operation. The whole tree is first ordered by key in ascending order, and then, within a single key scope, by LSN in descending order."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:157
#: ../doc/book/box/engines/vinyl.rst:157
msgid "*A single level of an LSM tree*"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:163
#: ../doc/book/box/engines/vinyl.rst:163
msgid "Filling an LSM tree"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:165
#: ../doc/book/box/engines/vinyl.rst:165
msgid "Unlike a B-tree, which is stored completely on disk and can be partly cached in RAM, when using an LSM tree, memory is explicitly separated from disk right from the start. The issue of volatile memory and data persistence is beyond the scope of the storage algorithm and can be solved in various ways—for example, by logging changes."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:171
#: ../doc/book/box/engines/vinyl.rst:171
msgid "The part of an LSM tree that’s stored in RAM is called L0 (level zero). The size of RAM is limited, so L0 is allocated a fixed amount of memory. For example, in Tarantool, the L0 size is controlled by the ``vinyl_memory`` parameter. Initially, when an LSM tree is empty, operations are written to L0. Recall that all elements are ordered by key in ascending order, and then within a single key scope, by LSN in descending order, so when a new value associated with a given key gets inserted, it’s easy to locate the older value and delete it. L0 can be structured as any container capable of storing a sorted sequence of elements. For example, in Tarantool, L0 is implemented as a B+*-tree. Lookups and insertions are standard operations for the data structure underlying L0, so I won’t dwell on those."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:183
#: ../doc/book/box/engines/vinyl.rst:183
msgid "Sooner or later the number of elements in an LSM tree exceeds the L0 size and that’s when L0 gets written to a file on disk (called a \"run\") and then cleared for storing new elements. This operation is called a \"dump\"."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:191
#: ../doc/book/box/engines/vinyl.rst:191
msgid "Dumps on disk form a sequence ordered by LSN: LSN ranges in different runs don’t overlap, and the leftmost runs (at the head of the sequence) hold newer operations. Think of these runs as a pyramid, with the newest ones closer to the top. As runs keep getting dumped, the pyramid grows higher. Note that newer runs may contain deletions or replacements for existing keys. To remove older data, it’s necessary to perform garbage collection (this process is sometimes called \"merge\" or \"compaction\") by combining several older runs into a new one. If two versions of the same key are encountered during a compaction, only the newer one is retained; however, if a key insertion is followed by a deletion, then both operations can be discarded."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:206
#: ../doc/book/box/engines/vinyl.rst:206
msgid "The key choices determining an LSM tree’s efficiency are which runs to compact and when to compact them. Suppose an LSM tree stores a monotonically increasing sequence of keys (1, 2, 3, ...,) with no deletions. In this case, compacting runs would be useless: all of the elements are sorted, the tree doesn’t have any garbage, and the location of any key can unequivocally be determined. On the other hand, if an LSM tree contains many deletions, doing a compaction would free up some disk space. However, even if there are no deletions, but key ranges in different runs overlap a lot, compacting such runs could speed up lookups as there would be fewer runs to scan. In this case, it might make sense to compact runs after each dump. But keep in mind that a compaction causes all data stored on disk to be overwritten, so with few reads it’s recommended to perform it less often."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:219
#: ../doc/book/box/engines/vinyl.rst:219
msgid "To ensure it’s optimally configurable for any of the scenarios above, an LSM tree organizes all runs into a pyramid: the newer the data operations, the higher up the pyramid they are located. During a compaction, the algorithm picks two or more neighboring runs of approximately equal size, if possible."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:228
#: ../doc/book/box/engines/vinyl.rst:228
msgid "Multi-level compaction can span any number of levels"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:229
#: ../doc/book/box/engines/vinyl.rst:229
msgid "A level can contain multiple runs"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:231
#: ../doc/book/box/engines/vinyl.rst:231
msgid "All of the neighboring runs of approximately equal size constitute an LSM tree level on disk. The ratio of run sizes at different levels determines the pyramid’s proportions, which allows optimizing the tree for write-intensive or read-intensive scenarios."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:236
#: ../doc/book/box/engines/vinyl.rst:236
msgid "Suppose the L0 size is 100 Mb, the ratio of run sizes at each level (the ``vinyl_run_size_ratio`` parameter) is 5, and there can be no more than 2 runs per level (the ``vinyl_run_count_per_level`` parameter). After the first 3 dumps, the disk will contain 3 runs of 100 Mb each—which constitute L1 (level one). Since 3 > 2, the runs will be compacted into a single 300 Mb run, with the older ones being deleted. After 2 more dumps, there will be another compaction, this time of 2 runs of 100 Mb each and the 300 Mb run, which will produce one 500 Mb run. It will be moved to L2 (recall that the run size ratio is 5), leaving L1 empty. The next 10 dumps will result in L2 having 3 runs of 500 Mb each, which will be compacted into a single 1500 Mb run. Over the course of 10 more dumps, the following will happen: 3 runs of 100 Mb each will be compacted twice, as will two 100 Mb runs and one 300 Mb run, which will yield 2 new 500 Mb runs in L2. Since L2 now has 3 runs, they will also be compacted: two 500 Mb runs and one 1500 Mb run will produce a 2500 Mb run that will be moved to L3, given its size."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:251
#: ../doc/book/box/engines/vinyl.rst:251
msgid "This can go on infinitely, but if an LSM tree contains lots of deletions, the resulting compacted run can be moved not only down, but also up the pyramid due to its size being smaller than the sizes of the original runs that were compacted. In other words, it’s enough to logically track which level a certain run belongs to, based on the run size and the smallest and greatest LSN among all of its operations."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:262
#: ../doc/book/box/engines/vinyl.rst:262
msgid "Controlling the form of an LSM tree"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:264
#: ../doc/book/box/engines/vinyl.rst:264
msgid "If it’s necessary to reduce the number of runs for lookups, then the run size ratio can be increased, thus bringing the number of levels down. If, on the other hand, you need to minimize the compaction-related overhead, then the run size ratio can be decreased: the pyramid will grow higher, and even though runs will be compacted more often, they will be smaller, which will reduce the total amount of work done. In general, write amplification in an LSM tree is described by this formula: :math:`log_{x}(\\frac {N} {L0}) × x` or, alternatively, :math:`x × \\frac {ln (\\frac {N} {C0})} {ln(x)}`, where N is the total size of all tree elements, L0 is the level zero size, and x is the level size ratio (the ``level_size_ratio`` parameter). At :math:`\\frac {N} {C0}` = 40 (the disk-to- memory ratio), the plot would look something like this:"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:280
#: ../doc/book/box/engines/vinyl.rst:280
msgid "As for read amplification, it’s proportional to the number of levels. The lookup cost at each level is no greater than that for a B-tree. Getting back to the example of a tree with 100,000,000 elements: given 256 Mb of RAM and the default values of ``vinyl_level_size_ratio`` and ``run_count_per_level``, write amplification would come out to about 13, while read amplification could be as high as 150. Let’s try to figure out why this happens."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:291
#: ../doc/book/box/engines/vinyl.rst:291
msgid "Search"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:293
#: ../doc/book/box/engines/vinyl.rst:293
msgid "When doing a lookup in an LSM tree, what we need to find is not the element itself, but the most recent operation associated with it. If it’s a deletion, then the tree doesn’t contain this element. If it’s an insertion, we need to grab the topmost value in the pyramid, and the search can be stopped after finding the first matching key. In the worst-case scenario, that is if the tree doesn’t hold the needed element, the algorithm will have to sequentially visit all of the levels, starting from L0."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:305
#: ../doc/book/box/engines/vinyl.rst:305
msgid "Unfortunately, this scenario is quite common in real life. For example, when inserting a value into a tree, it’s necessary to make sure there are no duplicates among primary/unique keys. So to speed up membership checks, LSM trees use a probabilistic data structure called a \"Bloom filter\", which will be covered a bit later, in a section on how vinyl works under the hood."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:315
#: ../doc/book/box/engines/vinyl.rst:315
msgid "Range searching"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:317
#: ../doc/book/box/engines/vinyl.rst:317
msgid "In the case of a single-key search, the algorithm stops after encountering the first match. However, when searching within a certain key range (for example, looking for all the users with the last name \"Ivanov\"), it’s necessary to scan all tree levels."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:324
#: ../doc/book/box/engines/vinyl.rst:324
msgid "*Searching within a range of [24,30)*"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:326
#: ../doc/book/box/engines/vinyl.rst:326
msgid "The required range is formed the same way as when compacting several runs: the algorithm picks the key with the largest LSN out of all the sources, ignoring the other associated operations, then moves on to the next key and repeats the procedure."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:335
#: ../doc/book/box/engines/vinyl.rst:335
msgid "Deletion"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:337
#: ../doc/book/box/engines/vinyl.rst:337
msgid "Why would one store deletions? And why doesn’t it lead to a tree overflow in the case of for i=1,10000000 put(i) delete(i) end?"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:340
#: ../doc/book/box/engines/vinyl.rst:340
msgid "With regards to lookups, deletions signal the absence of a value being searched; with compactions, they clear the tree of \"garbage\" records with older LSNs."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:343
#: ../doc/book/box/engines/vinyl.rst:343
msgid "While the data is in RAM only, there’s no need to store deletions. Similarly, you don’t need to keep them following a compaction if they affect, among other things, the lowest tree level, which contains the oldest dump. Indeed, if a value can’t be found at the lowest level, then it doesn’t exist in the tree."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:348
#: ../doc/book/box/engines/vinyl.rst:348
msgid "We can't delete from append-only files"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:349
#: ../doc/book/box/engines/vinyl.rst:349
msgid "Tombstones (delete markers) are inserted into L0 instead"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:353
#: ../doc/book/box/engines/vinyl.rst:353
msgid "*Deletion, step 1: a tombstone is inserted into L0*"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:357
#: ../doc/book/box/engines/vinyl.rst:357
msgid "*Deletion, step 2: the tombstone passes through intermediate levels*"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:361
#: ../doc/book/box/engines/vinyl.rst:361
msgid "*Deletion, step 3: in the case of a major compaction, the tombstone is removed from the tree*"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:363
#: ../doc/book/box/engines/vinyl.rst:363
msgid "If a deletion is known to come right after the insertion of a unique value, which is often the case when modifying a value in a secondary index, then the deletion can safely be filtered out while compacting intermediate tree levels. This optimization is implemented in vinyl."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:372
#: ../doc/book/box/engines/vinyl.rst:372
msgid "Advantages of an LSM tree"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:374
#: ../doc/book/box/engines/vinyl.rst:374
msgid "Apart from decreasing write amplification, the approach that involves periodically dumping level L0 and compacting levels L1-Lk has a few advantages over the approach to writes adopted by B-trees:"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:378
#: ../doc/book/box/engines/vinyl.rst:378
msgid "Dumps and compactions write relatively large files: typically, the L0 size is 50-100 Mb, which is thousands of times larger than the size of a B-tree block."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:381
#: ../doc/book/box/engines/vinyl.rst:381
msgid "This large size allows efficiently compressing data before writing it. Tarantool compresses data automatically, which further decreases write amplification."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:384
#: ../doc/book/box/engines/vinyl.rst:384
msgid "There is no fragmentation overhead, since there’s no padding/empty space between the elements inside a run."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:386
#: ../doc/book/box/engines/vinyl.rst:386
msgid "All operations create new runs instead of modifying older data in place. This allows avoiding those nasty locks that everyone hates so much. Several operations can run in parallel without causing any conflicts. This also simplifies making backups and moving data to replicas."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:391
#: ../doc/book/box/engines/vinyl.rst:391
msgid "Storing older versions of data allows for the efficient implementation of transaction support by using multiversion concurrency control."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:399
#: ../doc/book/box/engines/vinyl.rst:399
msgid "Disadvantages of an LSM tree and how to deal with them"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:401
#: ../doc/book/box/engines/vinyl.rst:401
msgid "One of the key advantages of the B-tree as a search data structure is its predictability: all operations take no longer than :math:`log_{B}(N)` to run. Conversely, in a classical LSM tree, both read and write speeds can differ by a factor of hundreds (best case scenario) or even thousands (worst case scenario). For example, adding just one element to L0 can cause it to overflow, which can trigger a chain reaction in levels L1, L2, and so on. Lookups may find the needed element in L0 or may need to scan all of the tree levels. It’s also necessary to optimize reads within a single level to achieve speeds comparable to those of a B-tree. Fortunately, most disadvantages can be mitigated or even eliminated with additional algorithms and data structures. Let’s take a closer look at these disadvantages and how they’re dealt with in Tarantool."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:417
#: ../doc/book/box/engines/vinyl.rst:417
msgid "Unpredictable write speed"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:419
#: ../doc/book/box/engines/vinyl.rst:419
msgid "In an LSM tree, insertions almost always affect L0 only. How do you avoid idle time when the memory area allocated for L0 is full?"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:422
#: ../doc/book/box/engines/vinyl.rst:422
msgid "Clearing L0 involves two lengthy operations: writing to disk and memory deallocation. To avoid idle time while L0 is being dumped, Tarantool uses writeaheads. Suppose the L0 size is 256 Mb. The disk write speed is 10 Mbps. Then it would take 26 seconds to dump L0. The insertion speed is 10,000 RPS, with each key having a size of 100 bytes. While L0 is being dumped, it’s necessary to reserve 26 Mb of RAM, effectively slicing the L0 size down to 230 Mb."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:430
#: ../doc/book/box/engines/vinyl.rst:430
msgid "Tarantool does all of these calculations automatically, constantly updating the rolling average of the DBMS workload and the histogram of the disk speed. This allows using L0 as efficiently as possible and it prevents write requests from timing out. But in the case of workload surges, some wait time is still possible. That’s why we also introduced an insertion timeout (the ``vinyl_timeout`` parameter), which is set to 60 seconds by default. The write operation itself is executed in dedicated threads. The number of these threads (2 by default) is controlled by the ``vinyl_write_threads`` parameter. The default value of 2 allows doing dumps and compactions in parallel, which is also necessary for ensuring system predictability."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:441
#: ../doc/book/box/engines/vinyl.rst:441
msgid "In Tarantool, compactions are always performed independently of dumps, in a separate execution thread. This is made possible by the append-only nature of an LSM tree: after dumps runs are never changed, and compactions simply create new runs."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:446
#: ../doc/book/box/engines/vinyl.rst:446
msgid "Delays can also be caused by L0 rotation and the deallocation of memory dumped to disk: during a dump, L0 memory is owned by two operating system threads, a transaction processing thread and a write thread. Even though no elements are being added to the rotated L0, it can still be used for lookups. To avoid read locks when doing lookups, the write thread doesn’t deallocate the dumped memory, instead delegating this task to the transaction processor thread. Following a dump, memory deallocation itself happens instantaneously: to achieve this, L0 uses a special allocator that deallocates all of the memory with a single operation."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:458
#: ../doc/book/box/engines/vinyl.rst:458
msgid "anticipatory dump"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:459
#: ../doc/book/box/engines/vinyl.rst:459
msgid "throttling"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:461
#: ../doc/book/box/engines/vinyl.rst:461
msgid "The dump is performed from the so-called \"shadow\" L0 without blocking new insertions and lookups"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:468
#: ../doc/book/box/engines/vinyl.rst:468
msgid "Unpredictable read speed"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:470
#: ../doc/book/box/engines/vinyl.rst:470
msgid "Optimizing reads is the most difficult optimization task with regards to LSM trees. The main complexity factor here is the number of levels: any optimization causes not only much slower lookups, but also tends to require significantly larger RAM resources. Fortunately, the append-only nature of LSM trees allows us to address these problems in ways that would be nontrivial for traditional data structures."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:479
#: ../doc/book/box/engines/vinyl.rst:479
msgid "page index"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:480
#: ../doc/book/box/engines/vinyl.rst:480
msgid "bloom filters"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:481
#: ../doc/book/box/engines/vinyl.rst:481
msgid "tuple range cache"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:482
#: ../doc/book/box/engines/vinyl.rst:482
msgid "multi-level compaction"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:488
#: ../doc/book/box/engines/vinyl.rst:488
msgid "Compression and page index"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:490
#: ../doc/book/box/engines/vinyl.rst:490
msgid "In B-trees, data compression is either the hardest problem to crack or a great marketing tool—rather than something really useful. In LSM trees, compression works as follows:"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:494
#: ../doc/book/box/engines/vinyl.rst:494
msgid "During a dump or compaction all of the data within a single run is split into pages. The page size (in bytes) is controlled by the ``vinyl_page_size`` parameter and can be set separately for each index. A page doesn’t have to be exactly of ``vinyl_page_size`` size—depending on the data it holds, it can be a little bit smaller or larger. Because of this, pages never have any empty space inside."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:501
#: ../doc/book/box/engines/vinyl.rst:501
msgid "Data is compressed by `Facebook’s streaming algorithm <https://github.com/facebook/zstd>`_ called \"zstd\". The first key of each page, along with the page offset, is added to a \"page index\", which is a separate file that allows the quick retrieval of any page. After a dump or compaction, the page index of the created run is also written to disk."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:508
#: ../doc/book/box/engines/vinyl.rst:508
msgid "All `.index` files are cached in RAM, which allows finding the necessary page with a single lookup in a `.run` file (in vinyl, this is the extension of files resulting from a dump or compaction). Since data within a page is sorted, after it’s read and decompressed, the needed key can be found using a regular binary search. Decompression and reads are handled by separate threads, and are controlled by the ``vinyl_read_threads`` parameter."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:515
#: ../doc/book/box/engines/vinyl.rst:515
msgid "Tarantool uses a universal file format: for example, the format of a `.run` file is no different from that of an `.xlog` file (log file). This simplifies backup and recovery as well as the usage of external tools."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:523
#: ../doc/book/box/engines/vinyl.rst:523
msgid "Bloom filters"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:525
#: ../doc/book/box/engines/vinyl.rst:525
msgid "Even though using a page index enables scanning fewer pages per run when doing a lookup, it’s still necessary to traverse all of the tree levels. There’s a special case, which involves checking if particular data is absent when scanning all of the tree levels and it’s unavoidable: I’m talking about insertions into a unique index. If the data being inserted already exists, then inserting the same data into a unique index should lead to an error. The only way to throw an error in an LSM tree before a transaction is committed is to do a search before inserting the data. Such reads form a class of their own in the DBMS world and are called \"hidden\" or \"parasitic\" reads."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:535
#: ../doc/book/box/engines/vinyl.rst:535
msgid "Another operation leading to hidden reads is updating a value in a field on which a secondary index is defined. Secondary keys are regular LSM trees that store differently ordered data. In most cases, in order not to have to store all of the data in all of the indexes, a value associated with a given key is kept in whole only in the primary index (any index that stores both a key and a value is called \"covering\" or \"clustered\"), whereas the secondary index only stores the fields on which a secondary index is defined, and the values of the fields that are part of the primary index. Thus, each time a change is made to a value in a field on which a secondary index is defined, it’s necessary to first remove the old key from the secondary index—and only then can the new key be inserted. At update time, the old value is unknown, and it is this value that needs to be read in from the primary key \"under the hood\"."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:550
#: ../doc/book/box/engines/vinyl.rst:550
msgid "update t1 set city=’Moscow’ where id=1"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:554
#: ../doc/book/box/engines/vinyl.rst:554
msgid "To minimize the number of disk reads, especially for nonexistent data, nearly all LSM trees use probabilistic data structures, and Tarantool is no exception. A classical Bloom filter is made up of several (usually 3-to-5) bit arrays. When data is written, several hash functions are calculated for each key in order to get corresponding array positions. The bits at these positions are then set to 1. Due to possible hash collisions, some bits might be set to 1 twice. We’re most interested in the bits that remain 0 after all keys have been added. When looking for an element within a run, the same hash functions are applied to produce bit positions in the arrays. If any of the bits at these positions is 0, then the element is definitely not in the run. The probability of a false positive in a Bloom filter is calculated using Bayes’ theorem: each hash function is an independent random variable, so the probability of a collision simultaneously occurring in all of the bit arrays is infinitesimal."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:568
#: ../doc/book/box/engines/vinyl.rst:568
msgid "The key advantage of Bloom filters in Tarantool is that they’re easily configurable. The only parameter that can be specified separately for each index is called ``bloom_fpr`` (FPR stands for \"false positive ratio\") and it has the default value of 0.05, which translates to a 5% FPR. Based on this parameter, Tarantool automatically creates Bloom filters of the optimal size for partial- key and full-key searches. The Bloom filters are stored in the `.index` file, along with the page index, and are cached in RAM."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:580
#: ../doc/book/box/engines/vinyl.rst:580
msgid "Caching"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:582
#: ../doc/book/box/engines/vinyl.rst:582
msgid "A lot of people think that caching is a silver bullet that can help with any performance issue. \"When in doubt, add more cache\". In vinyl, caching is viewed rather as a means of reducing the overall workload and consequently, of getting a more stable response time for those requests that don’t hit the cache. vinyl boasts a unique type of cache among transactional systems called a \"range tuple cache\". Unlike, say, RocksDB or MySQL, this cache doesn’t store pages, but rather ranges of index values obtained  from disk, after having performed a compaction spanning all tree levels. This allows the use of caching for both single-key and key-range searches. Since this method of caching stores only hot data and not, say, pages (you may need only some data from a page), RAM is used in the most efficient way possible. The cache size is controlled by the ``vinyl_cache`` parameter."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:599
#: ../doc/book/box/engines/vinyl.rst:599
msgid "Garbage collection control"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:601
#: ../doc/book/box/engines/vinyl.rst:601
msgid "Chances are that by now you’ve started losing focus and need a well-deserved dopamine reward. Feel free to take a break, since working through the rest of the article is going to take some serious mental effort."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:605
#: ../doc/book/box/engines/vinyl.rst:605
msgid "An LSM tree in vinyl is just a small piece of the puzzle. Even with a single table (or so-called \"space\"), vinyl creates and maintains several LSM trees, one for each index. But even a single index can be comprised of dozens of LSM trees. Let’s try to understand why this might be necessary."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:610
#: ../doc/book/box/engines/vinyl.rst:610
msgid "Recall our example with a tree containing 100,000,000 records, 100 bytes each. As time passes, the lowest LSM level may end up holding a 10 Gb run. During compaction, a temporary run of approximately the same size will be created. Data at intermediate levels takes up some space as well, since the tree may store several operations associated with a single key. In total, storing 10 Gb of actual data may require up to 30 Gb of free space: 10 Gb for the last tree level, 10 Gb for a temporary run, and 10 Gb for the remaining data. But what if the data size is not 10 Gb, but 1 Tb? Requiring that the available disk space always be several times greater than the actual data size is financially unpractical, not to mention that it may take dozens of hours to create a 1 Tb run. And in the case of an emergency shutdown or system restart, the process would have to be started from scratch."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:623
#: ../doc/book/box/engines/vinyl.rst:623
msgid "Here’s another scenario. Suppose the primary key is a monotonically increasing sequence—for example, a time series. In this case, most insertions will fall into the right part of the key range, so it wouldn’t make much sense to do a compaction just to append a few million more records to an already huge run."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:628
#: ../doc/book/box/engines/vinyl.rst:628
msgid "But what if writes predominantly occur in a particular region of the key range, whereas most reads take place in a different region? How do you optimize the form of the LSM tree in this case? If it’s too high, read performance is impacted; if it’s too low—write speed is reduced."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:633
#: ../doc/book/box/engines/vinyl.rst:633
msgid "Tarantool \"factorizes\" this problem by creating multiple LSM trees for each index. The approximate size of each subtree may be controlled by the :ref:`vinyl_range_size <cfg_storage-vinyl_range_size>` configuration parameter. We call such subtrees \"ranges\"."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:642
#: ../doc/book/box/engines/vinyl.rst:642
msgid "Factorizing large LSM trees via ranging"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:644
#: ../doc/book/box/engines/vinyl.rst:644
msgid "Ranges reflect a static layout of sorted runs"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:645
#: ../doc/book/box/engines/vinyl.rst:645
msgid "Slices connect a sorted run into a range"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:649
#: ../doc/book/box/engines/vinyl.rst:649
msgid "Initially, when the index has few elements, it consists of a single range. As more elements are added, its total size may exceed :ref:`the maximum range size <cfg_storage-vinyl_range_size>`. In that case a special operation called \"split\" divides the tree into two equal parts. The tree is split at the middle element in the range of keys stored in the tree. For example, if  the tree initially stores the full range of -inf…+inf, then after splitting it at the middle key X, we get two subtrees: one that stores the range of -inf...X, and the other storing the range of X…+inf. With this approach, we always know which subtree to use for writes and which one for reads. If the tree contained deletions and each of the neighboring ranges grew smaller as a result, the opposite operation called \"coalesce\" combines two neighboring trees into one."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:662
#: ../doc/book/box/engines/vinyl.rst:662
msgid "Split and coalesce don’t entail a compaction, the creation of new runs, or other resource-intensive operations. An LSM tree is just a collection of runs. vinyl has a special metadata log that helps keep track of which run belongs to which subtree(s). This has the `.vylog` extension and its format is compatible with an .xlog file. Similarly to an `.xlog` file, the metadata log gets rotated at each checkpoint. To avoid the creation of extra runs with split and coalesce, we have also introduced an auxiliary entity called \"slice\". It’s a reference to a run containing a key range and it’s stored only in the metadata log. Once the reference counter drops to zero, the corresponding file gets removed. When it’s necessary to perform a split or to coalesce, Tarantool creates slice objects for each new tree, removes older slices, and writes these operations to the metadata log, which literally stores records that look like this: ``<tree id, slice id>`` or ``<slice id, run id, min, max>``."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:676
#: ../doc/book/box/engines/vinyl.rst:676
msgid "This way all of the heavy lifting associated with splitting a tree into two subtrees is postponed until a compaction and then is performed automatically. A huge advantage of dividing all of the keys into ranges is the ability to independently control the L0 size as well as the dump and compaction processes for each subtree, which makes these processes manageable and predictable. Having a separate metadata log also simplifies the implementation of both \"truncate\" and \"drop\". In vinyl, they’re processed instantly, since they only work with the metadata log, while garbage collection is done in the background."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:689
#: ../doc/book/box/engines/vinyl.rst:689
msgid "Advanced features of vinyl"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:695
#: ../doc/book/box/engines/vinyl.rst:695
msgid "Upsert"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:697
#: ../doc/book/box/engines/vinyl.rst:697
msgid "In the previous sections, we mentioned only two operations stored by an LSM tree: deletion and replacement. Let’s take a look at how all of the other operations can be represented. An insertion can be represented via a replacement—you just need to make sure there are no other elements with the specified key. To perform an update, it’s necessary to read the older value from the tree, so it’s easier to represent this operation as a replacement as well—this speeds up future read requests by the key. Besides, an update must return the new value, so there’s no avoiding hidden reads."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:706
#: ../doc/book/box/engines/vinyl.rst:706
msgid "In B-trees, the cost of hidden reads is negligible: to update a block, it first needs to be read from disk anyway. Creating a special update operation for an LSM tree that doesn’t cause any hidden reads is really tempting."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:711
#: ../doc/book/box/engines/vinyl.rst:711
msgid "Such an operation must contain not only a default value to be inserted if a key has no value yet, but also a list of update operations to perform if a value does exist."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:715
#: ../doc/book/box/engines/vinyl.rst:715
msgid "At transaction execution time, Tarantool just saves the operation in an LSM tree, then \"executes\" it later, during a compaction."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:719
#: ../doc/book/box/engines/vinyl.rst:719
msgid "The upsert operation:"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:721
#: ../doc/book/box/engines/vinyl.rst:721
msgid "space:upsert(tuple, {{operator, field, value}, ... })"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:725
#: ../doc/book/box/engines/vinyl.rst:725
msgid "Non-reading update or insert"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:726
#: ../doc/book/box/engines/vinyl.rst:726
msgid "Delayed execution"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:727
#: ../doc/book/box/engines/vinyl.rst:727
msgid "Background upsert squashing prevents upserts from piling up"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:729
#: ../doc/book/box/engines/vinyl.rst:729
msgid "Unfortunately, postponing the operation execution until a compaction doesn’t leave much leeway in terms of error handling. That’s why Tarantool tries to validate upserts as fully as possible before writing them to an LSM tree. However, some checks are only possible with older data on hand, for example when the update operation is trying to add a number to a string or to remove a field that doesn’t exist."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:736
#: ../doc/book/box/engines/vinyl.rst:736
msgid "A semantically similar operation exists in many products including PostgreSQL and MongoDB. But anywhere you look, it’s just syntactic sugar that combines the update and replace operations without avoiding hidden reads. Most probably, the reason is that LSM trees as data storage structures are relatively new."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:742
#: ../doc/book/box/engines/vinyl.rst:742
msgid "Even though an upsert is a very important optimization and implementing it cost us a lot of blood, sweat, and tears, we must admit that it has limited applicability. If a table contains secondary keys or triggers, hidden reads can’t be avoided. But if you have a scenario where secondary keys are not required and the update following the transaction completion will certainly not cause any errors, then the operation is for you."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:749
#: ../doc/book/box/engines/vinyl.rst:749
msgid "I’d like to tell you a short story about an upsert. It takes place back when vinyl was only beginning to \"mature\" and we were using an upsert in production for the first time. We had what seemed like an ideal environment for it: we had tons of keys, the current time was being used as values; update operations were inserting keys or modifying the current time; and we had few reads. Load tests yielded great results."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:757
#: ../doc/book/box/engines/vinyl.rst:757
msgid "Nevertheless, after a couple of days, the Tarantool process started eating up 100% of our CPU, and the system performance dropped close to zero."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:760
#: ../doc/book/box/engines/vinyl.rst:760
msgid "We started digging into the issue and found out that the distribution of requests across keys was significantly different from what we had seen in the test environment. It was...well, quite nonuniform. Most keys were updated once or twice a day, so the database was idle for the most part, but there were much hotter keys with tens of thousands of updates per day. Tarantool handled those just fine. But in the case of lookups by key with tens of thousands of upserts, things quickly went downhill. To return the most recent value, Tarantool had to read and \"replay\" the whole history consisting of all of the upserts. When designing upserts, we had hoped this would happen automatically during a compaction, but the process never even got to that stage: the L0 size was more than enough, so there were no dumps."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:773
#: ../doc/book/box/engines/vinyl.rst:773
msgid "We solved the problem by adding a background process that performed readaheads on any keys that had more than a few dozen upserts piled up, so all those upserts were squashed and substituted with the read value."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:782
#: ../doc/book/box/engines/vinyl.rst:782
msgid "Secondary keys"
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:784
#: ../doc/book/box/engines/vinyl.rst:784
msgid "Update is not the only operation where optimizing hidden reads is critical. Even the replace operation, given secondary keys, has to read the older value: it needs to be independently deleted from the secondary indexes, and inserting a new element might not do this, leaving some garbage behind."
msgstr ""

#: ../doc/book/box/engines/vinyl.rst:794
#: ../doc/book/box/engines/vinyl.rst:794
msgid "If secondary indexes are not unique, then collecting \"garbage\" from them can be put off until a compaction, which is what we do in Tarantool. The append-only nature of LSM trees allowed us to implement full-blown serializable transactions in vinyl. Read-only requests use older versions of data without blocking any writes. The transaction manager itself is fairly simple for now: in classical terms, it implements the MVTO (multiversion timestamp ordering) class, whereby the winning transaction is the one that finished earlier. There are no locks and associated deadlocks. Strange as it may seem, this is a drawback rather than an advantage: with parallel execution, you can increase the number of successful transactions by simply holding some of them on lock when necessary. We’re planning to improve the transaction manager soon. In the current release, we focused on making the algorithm behave 100% correctly and predictably. For example, our transaction manager is one of the few on the NoSQL market that supports so-called \"gap locks\"."
msgstr ""

#: ../doc/book/box/index.rst:5
msgid "Database"
msgstr ""

#: ../doc/book/box/index.rst:7
msgid "In this chapter, we introduce the basic concepts of working with Tarantool as a database manager."
msgstr ""

#: ../doc/book/box/limitations.rst:5
msgid "Limitations"
msgstr ""

#: ../doc/book/box/limitations.rst:7
msgid "**Number of parts in an index**"
msgstr ""

#: ../doc/book/box/limitations.rst:9
msgid "For TREE or HASH indexes, the maximum is 255 (``box.schema.INDEX_PART_MAX``). For :ref:`RTREE <box_index-rtree>` indexes, the maximum is 1 but the field is an ARRAY of up to 20 dimensions. For BITSET indexes, the maximum is 1."
msgstr ""

#: ../doc/book/box/limitations.rst:16
msgid "**Number of indexes in a space**"
msgstr ""

#: ../doc/book/box/limitations.rst:18
msgid "128 (``box.schema.INDEX_MAX``)."
msgstr ""

#: ../doc/book/box/limitations.rst:22
msgid "**Number of fields in a tuple**"
msgstr ""

#: ../doc/book/box/limitations.rst:24
msgid "The theoretical maximum is 2,147,483,647 (``box.schema.FIELD_MAX``). The practical maximum is whatever is specified by the space's :ref:`field_count <box_space-field_count>` member, or the maximal tuple length."
msgstr ""

#: ../doc/book/box/limitations.rst:31
msgid "**Number of bytes in a tuple**"
msgstr ""

#: ../doc/book/box/limitations.rst:33
msgid "The maximal number of bytes in a tuple is roughly equal to :ref:`memtx_max_tuple_size <cfg_storage-memtx_max_tuple_size>` or :ref:`vinyl_max_tuple_size <cfg_storage-vinyl_max_tuple_size>` (with a metadata overhead of about 20 bytes per tuple, which is added on top of useful bytes). By default, the value of either ``memtx_max_tuple_size`` or ``vinyl_max_tuple_size`` is 1,048,576. To increase it, specify a larger value when starting the Tarantool instance. For example, ``box.cfg{memtx_max_tuple_size=2*1048576}``."
msgstr ""

#: ../doc/book/box/limitations.rst:45
msgid "**Number of bytes in an index key**"
msgstr ""

#: ../doc/book/box/limitations.rst:47
msgid "If a field in a tuple can contain a million bytes, then the index key can contain a million bytes, so the maximum is determined by factors such as :ref:`Number of bytes in a tuple <limitations_bytes_in_tuple>`, not by the index support."
msgstr ""

#: ../doc/book/box/limitations.rst:54
msgid "**Number of spaces**"
msgstr ""

#: ../doc/book/box/limitations.rst:56
msgid "The theoretical maximum is 2147483647 (``box.schema.SPACE_MAX``) but the practical maximum is around 65,000."
msgstr ""

#: ../doc/book/box/limitations.rst:61
msgid "**Number of connections**"
msgstr ""

#: ../doc/book/box/limitations.rst:63
msgid "The practical limit is the number of file descriptors that one can set with the operating system."
msgstr ""

#: ../doc/book/box/limitations.rst:68
msgid "**Space size**"
msgstr ""

#: ../doc/book/box/limitations.rst:70
msgid "The total maximum size for all spaces is in effect set by :ref:`memtx_memory <cfg_storage-memtx_memory>`, which in turn is limited by the total available memory."
msgstr ""

#: ../doc/book/box/limitations.rst:76
msgid "**Update operations count**"
msgstr ""

#: ../doc/book/box/limitations.rst:78
msgid "The maximum number of operations that can be in a single update is 4000 (``BOX_UPDATE_OP_CNT_MAX``)."
msgstr ""

#: ../doc/book/box/limitations.rst:83
msgid "**Number of users and roles**"
msgstr ""

#: ../doc/book/box/limitations.rst:85
msgid "32 (``BOX_USER_MAX``)."
msgstr ""

#: ../doc/book/box/limitations.rst:89
msgid "**Length of an index name or space name or user name**"
msgstr ""

#: ../doc/book/box/limitations.rst:91
msgid "65000 (``box.schema.NAME_MAX``)."
msgstr ""

#: ../doc/book/box/limitations.rst:95
msgid "**Number of replicas in a replica set**"
msgstr ""

#: ../doc/book/box/limitations.rst:97
msgid "32 (``vclock.VCLOCK_MAX``)."
msgstr ""

#: ../doc/book/box/triggers.rst:6
msgid "Triggers"
msgstr ""

#: ../doc/book/box/triggers.rst:8
msgid "**Triggers**, also known as **callbacks**, are functions which the server executes when certain events happen."
msgstr ""

#: ../doc/book/box/triggers.rst:11
msgid "There are six types of triggers in Tarantool:"
msgstr ""

#: ../doc/book/box/triggers.rst:13
msgid ":ref:`connection triggers <box_session-on_connect>`, which are executed when a session begins or ends,"
msgstr ""

#: ../doc/book/box/triggers.rst:16
msgid ":ref:`authentication triggers <box_session-on_auth>`, which are executed during authentication,"
msgstr ""

#: ../doc/book/box/triggers.rst:19
msgid ":ref:`replace triggers <box_space-on_replace>`, which are for database events,"
msgstr ""

#: ../doc/book/box/triggers.rst:22
msgid ":ref:`transaction triggers <box-on_commit>`, which are executed during commit or rollback,"
msgstr ""

#: ../doc/book/box/triggers.rst:25
msgid ":ref:`server triggers <box_ctl-on_schema_init>`, which are executed when the server starts or stops."
msgstr ""

#: ../doc/book/box/triggers.rst:28
msgid ":ref:`member triggers <swim-on_member_event>`, which are executed when a SWIM member is updated."
msgstr ""

#: ../doc/book/box/triggers.rst:31
msgid "All triggers have the following characteristics:"
msgstr ""

#: ../doc/book/box/triggers.rst:33
msgid "Triggers associate a function with an event. The request to \"define a trigger\" implies passing the trigger's function to one of the \"on_event()\" functions:"
msgstr ""

#: ../doc/book/box/triggers.rst:37
msgid ":ref:`box.session.on_connect() <box_session-on_connect>` and :ref:`box.session.on_disconnect() <box_session-on_disconnect>`, or"
msgstr ""

#: ../doc/book/box/triggers.rst:38
msgid ":ref:`box.session.on_auth() <box_session-on_auth>`, or"
msgstr ""

#: ../doc/book/box/triggers.rst:39
msgid ":ref:`space_object:on_replace() <box_space-on_replace>` and :ref:`space_object:before_replace() <box_space-before_replace>`, or"
msgstr ""

#: ../doc/book/box/triggers.rst:40
msgid ":ref:`box.on_commit() <box-on_commit>` and :ref:`box.on_rollback() <box-on_rollback>`, or"
msgstr ""

#: ../doc/book/box/triggers.rst:41
msgid ":ref:`box.ctl.on_schema_init() <box_ctl-on_schema_init>` and :ref:`box.ctl.on_shutdown() <box_ctl-on_shutdown>`, or"
msgstr ""

#: ../doc/book/box/triggers.rst:42
msgid ":ref:`swim_object:on_member_event() <swim-on_member_event>`."
msgstr ""

#: ../doc/book/box/triggers.rst:44
msgid "Triggers are defined only by the :ref:`'admin' user <authentication-owners_privileges>`."
msgstr ""

#: ../doc/book/box/triggers.rst:46
msgid "Triggers are stored in the Tarantool instance's memory, not in the database. Therefore triggers disappear when the instance is shut down. To make them permanent, put function definitions and trigger settings into Tarantool's :ref:`initialization script <index-init_label>`."
msgstr ""

#: ../doc/book/box/triggers.rst:51
msgid "Triggers have low overhead. If a trigger is not defined, then the overhead is minimal: merely a pointer dereference and check. If a trigger is defined, then its overhead is equivalent to the overhead of calling a function."
msgstr ""

#: ../doc/book/box/triggers.rst:55
msgid "There can be multiple triggers for one event. In this case, triggers are executed in the reverse order that they were defined in. (Exception: member triggers are executed in the order that they appear in the member list.)"
msgstr ""

#: ../doc/book/box/triggers.rst:59
msgid "Triggers must work within the event context. However, effects are undefined if a function contains requests which normally could not occur immediately after the event, but only before the return from the event. For example, putting `os.exit() <http://www.lua.org/manual/5.1/manual.html#pdf-os.exit>`_ or :ref:`box.rollback() <box-rollback>` in a trigger function would be bringing in requests outside the event context."
msgstr ""

#: ../doc/book/box/triggers.rst:66
msgid "Triggers are replaceable. The request to \"redefine a trigger\" implies passing a new trigger function and an old trigger function to one of the \"on_event()\" functions."
msgstr ""

#: ../doc/book/box/triggers.rst:70
msgid "The \"on_event()\" functions all have parameters which are function pointers, and they all return function pointers. Remember that a Lua function definition such as \"function f() x = x + 1 end\" is the same as \"f = function () x = x + 1 end\" -- in both cases ``f`` gets a function pointer. And \"trigger = box.session.on_connect(f)\" is the same as \"trigger = box.session.on_connect(function () x = x + 1 end)\" -- in both cases ``trigger`` gets the function pointer which was passed."
msgstr ""

#: ../doc/book/box/triggers.rst:78
msgid "To get a list of triggers, you can use:"
msgstr ""

#: ../doc/book/box/triggers.rst:80
msgid "box.session.on_connect() – with no arguments – to return a table of all connect-trigger functions;"
msgstr ""

#: ../doc/book/box/triggers.rst:81
msgid "box.session.on_auth() to return all authentication-trigger functions;"
msgstr ""

#: ../doc/book/box/triggers.rst:82
msgid "box.session.on_disconnect() to return all disconnect-trigger functions;"
msgstr ""

#: ../doc/book/box/triggers.rst:83
msgid "space_object:on_replace() to return all replace-trigger functions made for on_replace()."
msgstr ""

#: ../doc/book/box/triggers.rst:84
msgid "space_object:before_replace() to return all replace-trigger functions made for before_replace()."
msgstr ""

#: ../doc/book/box/triggers.rst:85
msgid "box.ctl.on_shutdown() to return all shutdown-trigger functions made for on_shutdown()."
msgstr ""

#: ../doc/book/box/triggers.rst:86
msgid "box.ctl.on_schema_init() to return all initialization-trigger functions made for on_schema_init()."
msgstr ""

#: ../doc/book/box/triggers.rst:87
msgid "swim_object:on_member_event() to return all member triggers made for on_member_event()."
msgstr ""

#: ../doc/book/box/triggers.rst:91
msgid "Here we log connect and disconnect events into Tarantool server log."
msgstr ""

#: ../doc/book/box/triggers.rst:93
msgid "log = require('log')\n"
"\n"
"function on_connect_impl()\n"
"  log.info(\"connected \"..box.session.peer()..\", sid \"..box.session.id())\n"
"end\n"
"\n"
"function on_disconnect_impl()\n"
"  log.info(\"disconnected, sid \"..box.session.id())\n"
"end\n"
"\n"
"function on_auth_impl(user)\n"
"  log.info(\"authenticated sid \"..box.session.id()..\" as \"..user)\n"
"end\"\n"
"\n"
"function on_connect() pcall(on_connect_impl) end\n"
"function on_disconnect() pcall(on_disconnect_impl) end\n"
"function on_auth(user) pcall(on_auth_impl, user) end\n"
"\n"
"box.session.on_connect(on_connect)\n"
"box.session.on_disconnect(on_disconnect)\n"
"box.session.on_auth(on_auth)"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:5
msgid "Tarantool Cartridge administrator's guide"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:7
msgid "This guide explains how to deploy and manage a Tarantool cluster with Tarantool Cartridge."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:12
msgid "For more information on managing Tarantool instances, see the :ref:`Server administration <admin>` section."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:15
msgid "Before deploying the cluster, familiarize yourself with the notion of :ref:`cluster roles <cartridge-roles>` and :ref:`deploy Tarantool instances <cartridge-deploy>` according to the desired cluster topology."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:24
msgid "Deploying the cluster"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:26
msgid "To deploy the cluster, first, :ref:`configure <cartridge-config>` your Tarantool instances according to the desired cluster topology, for example:"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:29
msgid "my_app.router: {\"advertise_uri\": \"localhost:3301\", \"http_port\": 3301, \"workdir\": \"./tmp/router\"}\n"
"my_app.storage_A_master: {\"advertise_uri\": \"localhost:3302\", \"http_enabled\": False, \"workdir\": \"./tmp/storage-a-master\"}\n"
"my_app.storage_A_replica: {\"advertise_uri\": \"localhost:3303\", \"http_enabled\": False, \"workdir\": \"./tmp/storage-a-replica\"}\n"
"my_app.storage_B_master: {\"advertise_uri\": \"localhost:3304\", \"http_enabled\": False, \"workdir\": \"./tmp/storage-b-master\"}\n"
"my_app.storage_B_replica: {\"advertise_uri\": \"localhost:3305\", \"http_enabled\": False, \"workdir\": \"./tmp/storage-b-replica\"}"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:37
msgid "Then :ref:`start the instances <cartridge-run>`, for example using ``cartridge`` CLI:"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:40
#: ../doc/book/cartridge/cartridge_dev.rst:1229
msgid "cartridge start my_app --cfg demo.yml --run_dir ./tmp/run --foreground"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:44
msgid "And bootstrap the cluster. You can do this via the Web interface which is available at ``http://<instance_hostname>:<instance_http_port>`` (in this example, ``http://localhost:3301``)."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:49
msgid "In the web interface, do the following:"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:51
msgid "Depending on the authentication state:"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:53
msgid "If enabled (in production), enter your credentials and click **Login**:"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:60
msgid "If disabled (for easier testing), simply proceed to configuring the cluster."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:63
msgid "Click **Сonfigure** next to the first unconfigured server to create the first replica set -- solely for the router (intended for *compute-intensive* workloads)."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:70
#: ../doc/book/cartridge/cartridge_admin.rst:82
#: ../doc/book/cartridge/cartridge_admin.rst:97
#: ../doc/book/cartridge/cartridge_admin.rst:170
#: ../doc/book/cartridge/cartridge_admin.rst:470
#: ../doc/book/cartridge/cartridge_admin.rst:513
msgid "|nbsp|"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:72
msgid "In the pop-up window, check the ``vshard-router`` role -- or any custom role that has ``vshard-router`` as a dependent role (in this example, this is a custom role named ``app.roles.api``)."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:76
msgid "(Optional) Specify a display name for the replica set, for example ``router``."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:86
msgid "As described in the :ref:`built-in roles section <cartridge-built-in-roles>`, it is a good practice to enable workload-specific cluster roles on instances running on physical servers with workload-specific hardware."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:90
msgid "Click **Create replica set** and see the newly-created replica set in the web interface:"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:101
msgid "Be careful: after an instance joins a replica set, you **CAN NOT** revert this or make the instance join any other replica set."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:104
msgid "Create another replica set -- for a master storage node (intended for *transaction-intensive* workloads)."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:107
msgid "Check the ``vshard-storage`` role -- or any custom role that has ``vshard-storage`` as a dependent role (in this example, this is a custom role named ``app.roles.storage``)."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:111
msgid "(Optional) Check a specific group, for example ``hot``. Replica sets with ``vshard-storage`` roles can belong to different groups. In our example, these are ``hot`` or ``cold`` groups meant to process hot and cold data independently. These groups are specified in the cluster's :ref:`configuration file <cartridge-vshard-groups>`; by default, a cluster has no groups."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:118
msgid "(Optional) Specify a display name for the replica set, for example ``hot-storage``."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:120
msgid "Click **Create replica set**."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:126
msgid "(Optional) If required by topology, populate the second replica set with more storage nodes:"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:129
msgid "Click **Configure** next to another unconfigured server dedicated for *transaction-intensive* workloads."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:132
msgid "Click **Join Replica Set** tab."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:134
msgid "Select the second replica set, and click **Join replica set** to add the server to it."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:141
msgid "Depending on cluster topology:"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:143
msgid "add more instances to the first or second replica sets, or"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:144
msgid "create more replica sets and populate them with instances meant to handle a specific type of workload (compute or transactions)."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:153
msgid "(Optional) By default, all new ``vshard-storage`` replica sets get a weight of ``1`` before the ``vshard`` bootstrap in the next step."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:158
msgid "In case you add a new replica set after ``vshard`` bootstrap, as described in the :ref:`topology change section <cartridge-change-cluster-topology>`, it will get a weight of 0 by default."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:162
msgid "To make different replica sets store different numbers of buckets, click **Edit** next to a replica set, change its default weight, and click **Save**:"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:172
msgid "For more information on buckets and replica set's weights, see the :ref:`vshard module documentation <vshard>`."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:175
msgid "Bootstrap ``vshard`` by clicking the corresponding button, or by saying ``cartridge.admin.boostrap_vshard()`` over the administrative console."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:178
msgid "This command creates virtual buckets and distributes them among storages."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:180
msgid "From now on, all cluster configuration can be done via the web interface."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:186
msgid "Updating the configuration"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:188
msgid "Cluster configuration is specified in a YAML configuration file. This file includes cluster topology and role descriptions."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:191
msgid "All instances in Tarantool cluster have the same configuration. To this end, every instance stores a copy of the configuration file, and the cluster keeps these copies in sync: as you submit updated configuration in the Web interface, the cluster validates it (and rejects inappropriate changes) and distributes **automatically** across the cluster."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:197
msgid "To update the configuration:"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:199
msgid "Click **Configuration files** tab."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:201
msgid "(Optional) Click **Downloaded** to get hold of the current configuration file."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:203
msgid "Update the configuration file."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:205
msgid "You can add/change/remove any sections except system ones: ``topology``, ``vshard``, and ``vshard_groups``."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:208
msgid "To remove a section, simply remove it from the configuration file."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:210
msgid "Compress the configuration file as a ``.zip`` archive and click **Upload configuration** button to upload it."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:213
msgid "You will see a message in the lower part of the screen saying whether configuration was uploaded successfully, and an error description if the new configuration was not applied."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:221
msgid "Managing the cluster"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:223
msgid "This chapter explains how to:"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:225
msgid "change the cluster topology,"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:226
msgid "enable automatic failover,"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:227
msgid "switch the replica set's master manually,"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:228
msgid "deactivate replica sets, and"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:229
msgid "expel instances."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:235
msgid "Changing the cluster topology"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:237
msgid "Upon adding a newly deployed instance to a new or existing replica set:"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:239
msgid "The cluster validates the configuration update by checking if the new instance is available using the `membership module <https://www.tarantool.io/en/doc/2.2/reference/reference_rock/membership/>`_."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:244
msgid "The ``membership`` module works over the UDP protocol and can operate before the ``box.cfg`` function is called."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:247
msgid "All the nodes in the cluster must be healthy for validation success."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:249
msgid "The new instance waits until another instance in the cluster receives the configuration update and discovers it, again, using the ``membership`` module. On this step, the new instance does not have a UUID yet."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:253
msgid "Once the instance realizes its presence is known to the cluster, it calls the ``box.cfg`` function and starts living its life."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:256
msgid "For more information, see the :ref:`box.cfg submodule reference <box_introspection-box_cfg>`_."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:259
msgid "An optimal strategy for connecting new nodes to the cluster is to deploy a new zero-weight replica set instance by instance, and then increase the weight. Once the weight is updated and all cluster nodes are notified of the configuration change, buckets start migrating to new nodes."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:264
msgid "To populate the cluster with more nodes, do the following:"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:266
msgid "Deploy new Tarantool instances as described in the :ref:`deployment section <cartridge-deploy>`."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:269
msgid "If new nodes do not appear in the Web interface, click **Probe server** and specify their URIs manually."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:276
msgid "If a node is accessible, it will appear in the list."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:278
msgid "In the Web interface:"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:280
msgid "Create a new replica set with one of the new instances: click **Configure** next to an unconfigured server, check the necessary roles, and click **Create replica set**:"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:286
msgid "In case you are adding a new ``vshard-storage`` instance, remember that all such instances get a ``0`` weight by default after the ``vshard`` bootstrap which happened during the initial cluster deployment."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:294
msgid "Or add the instances to existing replica sets: click **Configure** next to an unconfigured server, click **Join replica set** tab, select a replica set, and click **Join replica set**."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:298
msgid "If necessary, repeat this for more instances to reach the desired redundancy level."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:301
msgid "In case you are deploying a new ``vshard-storage`` replica set, populate it with data when you are ready: click **Edit** next to the replica set in question, increase its weight, and click **Save** to start :ref:`data rebalancing <cartridge-rebalance-data>`."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:306
msgid "As an alternative to the web interface, you can view and change cluster topology via GraphQL. The cluster's endpoint for serving GraphQL queries is ``/admin/api``. You can use any third-party GraphQL client like `GraphiQL <https://github.com/graphql/graphiql>`_ or `Altair <https://altair.sirmuel.design>`_."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:312
msgid "Examples:"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:314
msgid "listing all servers in the cluster:"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:316
msgid "query {\n"
"    servers { alias uri uuid }\n"
"}"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:322
msgid "listing all replica sets with their servers:"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:324
msgid "query {\n"
"    replicasets {\n"
"        uuid\n"
"        roles\n"
"        servers { uri uuid }\n"
"    }\n"
"}"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:334
msgid "joining a server to a new replica set with a storage role enabled:"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:336
msgid "mutation {\n"
"    join_server(\n"
"        uri: \"localhost:33003\"\n"
"        roles: [\"vshard-storage\"]\n"
"    )\n"
"}"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:349
msgid "Data rebalancing"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:351
msgid "Rebalancing (resharding) is initiated periodically and upon adding a new replica set with a non-zero weight to the cluster. For more information, see the :ref:`rebalancing process section <vshard-rebalancing>` of the ``vshard`` module documentation."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:356
msgid "The most convenient way to trace through the process of rebalancing is to monitor the number of active buckets on storage nodes. Initially, a newly added replica set has 0 active buckets. After a few minutes, the background rebalancing process begins to transfer buckets from other replica sets to the new one. Rebalancing continues until the data is distributed evenly among all replica sets."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:362
msgid "To monitor the current number of buckets, connect to any Tarantool instance over the :ref:`administrative console <cartridge-manage-sharding-cli>`, and say:"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:365
msgid "tarantool> vshard.storage.info().bucket\n"
"---\n"
"- receiving: 0\n"
"  active: 1000\n"
"  total: 1000\n"
"  garbage: 0\n"
"  sending: 0\n"
"..."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:376
msgid "The number of buckets may be increasing or decreasing depending on whether the rebalancer is migrating buckets to or from the storage node."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:379
msgid "For more information on the monitoring parameters, see the :ref:`monitoring storages section <cartridge-monitor-storage>`."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:386
msgid "Deactivating replica sets"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:388
msgid "To deactivate an entire replica set (e.g., to perform maintenance on it) means to move all of its buckets to other sets."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:391
msgid "To deactivate a set, do the following:"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:393
msgid "Click **Edit** next to the set in question."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:395
msgid "Set its weight to ``0`` and click **Save**:"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:401
msgid "Wait for the rebalancing process to finish migrating all the set's buckets away. You can monitor the current bucket number as described in the :ref:`data rebalancing section <cartridge-rebalance-data>`."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:409
msgid "Expelling instances"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:414
msgid "Once an instance is *expelled*, it can never participate in the cluster again as every instance will reject it."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:417
msgid "To expel an instance, click **...** next to it, then click **Expel server** and **Expel**:"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:428
msgid "Enabling automatic failover"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:430
msgid "In a master-replica cluster configuration with automatic failover enabled, if the user-specified master of any replica set fails, the cluster automatically chooses the next replica from the priority list and grants it the active master role (read/write). When the failed master comes back online, its role is restored and the active master, again, becomes a replica (read-only). This works for any roles."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:437
msgid "To set the priority in a replica set:"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:439
msgid "Click **Edit** next to the replica set in question."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:441
msgid "Scroll to the bottom of the **Edit replica set** box to see the list of servers."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:444
msgid "Drag replicas to their place in the priority list, and click **Save**:"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:450
msgid "The failover is disabled by default. To enable it:"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:452
msgid "Click **Failover**:"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:458
msgid "In the **Failover control** box, click **Enable**:"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:464
msgid "The failover status will change to enabled:"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:472
msgid "For more information, see the :ref:`replication section <replication>`."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:478
msgid "Switching the replica set's master"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:480
msgid "To manually switch the master in a replica set:"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:482
msgid "Click the **Edit** button next to the replica set in question:"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:488
msgid "Scroll to the bottom of the **Edit replica set** box to see the list of servers. The server on the top is the master."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:495
msgid "Drag a required server to the top position and click **Save**."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:497
msgid "The new master will automatically enter the read/write mode, while the ex-master will become read-only. This works for any roles."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:504
msgid "Managing users"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:506
msgid "On the **Users** tab, you can enable/disable authentication as well as add, remove, edit, and view existing users who can access the web interface."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:515
msgid "Notice that the **Users** tab is available only if authorization in the web interface is :ref:`implemented <cartridge-auth-enable>`."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:518
msgid "Also, some features (like deleting users) can be disabled in the cluster configuration; this is regulated by the `auth_backend_name <https://www.tarantool.io/en/rocks/cluster/1.0/modules/cluster/#cfg-opts-box-opts>`_ option passed to ``cartridge.cfg()``."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:527
msgid "Resolving conflicts"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:529
msgid "Tarantool has an embedded mechanism for asynchronous replication. As a consequence, records are distributed among the replicas with a delay, so conflicts can arise."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:532
msgid "To prevent conflicts, the special trigger ``space.before_replace`` is used. It is executed every time before making changes to the table for which it was configured. The trigger function is implemented in the Lua programming language. This function takes the original and new values of the tuple to be modified as its arguments. The returned value of the function is used to change the result of the operation: this will be the new value of the modified tuple."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:539
msgid "For insert operations, the old value is absent, so ``nil`` is passed as the first argument."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:542
msgid "For delete operations, the new value is absent, so ``nil`` is passed as the second argument. The trigger function can also return ``nil``, thus turning this operation into delete."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:546
msgid "This example shows how to use the ``space.before_replace`` trigger to prevent replication conflicts. Suppose we have a ``box.space.test`` table that is modified in multiple replicas at the same time. We store one payload field in this table. To ensure consistency, we also store the last modification time in each tuple of this table and set the ``space.before_replace`` trigger, which gives preference to newer tuples. Below is the code in Lua:"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:553
msgid "fiber = require('fiber')\n"
"-- define a function that will modify the function test_replace(tuple)\n"
"        -- add a timestamp to each tuple in the space\n"
"        tuple = box.tuple.new(tuple):update{{'!', 2, fiber.time()}}\n"
"        box.space.test:replace(tuple)\n"
"end\n"
"box.cfg{ } -- restore from the local directory\n"
"-- set the trigger to avoid conflicts\n"
"box.space.test:before_replace(function(old, new)\n"
"        if old ~= nil and new ~= nil and new[2] < old[2] then\n"
"                return old -- ignore the request\n"
"        end\n"
"        -- otherwise apply as is\n"
"end)\n"
"box.cfg{ replication = {...} } -- subscribe"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:575
msgid "Monitoring cluster via CLI"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:577
msgid "This section describes parameters you can monitor over the administrative console."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:584
msgid "Connecting to nodes via CLI"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:586
msgid "Each Tarantool node (``router``/``storage``) provides an administrative console (Command Line Interface) for debugging, monitoring, and troubleshooting. The console acts as a Lua interpreter and displays the result in the human-readable YAML format. To connect to a Tarantool instance via the console, say:"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:591
msgid "$ tarantoolctl connect <instance_hostname>:<port>"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:595
msgid "where the ``<instance_hostname>:<port>`` is the instance's URI."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:601
msgid "Monitoring storages"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:603
msgid "Use ``vshard.storage.info()`` to obtain information on storage nodes."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:609
#: ../doc/book/cartridge/cartridge_admin.rst:782
msgid "Output example"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:611
msgid "tarantool> vshard.storage.info()\n"
"---\n"
"- replicasets:\n"
"    <replicaset_2>:\n"
"    uuid: <replicaset_2>\n"
"    master:\n"
"        uri: storage:storage@127.0.0.1:3303\n"
"    <replicaset_1>:\n"
"    uuid: <replicaset_1>\n"
"    master:\n"
"        uri: storage:storage@127.0.0.1:3301\n"
"  bucket: <!-- buckets status\n"
"    receiving: 0 <!-- buckets in the RECEIVING state\n"
"    active: 2 <!-- buckets in the ACTIVE state\n"
"    garbage: 0 <!-- buckets in the GARBAGE state (are to be deleted)\n"
"    total: 2 <!-- total number of buckets\n"
"    sending: 0 <!-- buckets in the SENDING state\n"
"  status: 1 <!-- the status of the replica set\n"
"  replication:\n"
"    status: disconnected <!-- the status of the replication\n"
"    idle: <idle>\n"
"  alerts:\n"
"  - ['MASTER_IS_UNREACHABLE', 'Master is unreachable: disconnected']"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:641
#: ../doc/book/cartridge/cartridge_admin.rst:811
msgid "Status list"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:649
#: ../doc/book/cartridge/cartridge_admin.rst:819
msgid "**Code**"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:649
#: ../doc/book/cartridge/cartridge_admin.rst:819
msgid "**Critical level**"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:649
#: ../doc/book/cartridge/cartridge_admin.rst:819
msgid "**Description**"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:651
#: ../doc/book/cartridge/cartridge_admin.rst:821
msgid "Green"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:651
msgid "A replica set works in a regular way."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:653
#: ../doc/book/cartridge/cartridge_admin.rst:823
msgid "Yellow"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:653
msgid "There are some issues, but they don’t affect a replica set efficiency (worth noticing, but don't require immediate intervention)."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:658
#: ../doc/book/cartridge/cartridge_admin.rst:826
msgid "Orange"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:658
msgid "A replica set is in a degraded state."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:660
#: ../doc/book/cartridge/cartridge_admin.rst:828
msgid "Red"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:660
msgid "A replica set is disabled."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:667
#: ../doc/book/cartridge/cartridge_admin.rst:835
msgid "Potential issues"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:669
msgid "``MISSING_MASTER`` — No master node in the replica set configuration."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:671
#: ../doc/book/cartridge/cartridge_admin.rst:845
#: ../doc/book/cartridge/cartridge_admin.rst:854
msgid "**Critical level:** Orange."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:673
msgid "**Cluster condition:** Service is degraded for data-change requests to the replica set."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:676
msgid "**Solution:** Set the master node for the replica set in the configuration using API."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:678
msgid "``UNREACHABLE_MASTER`` — No connection between the master and the replica."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:680
#: ../doc/book/cartridge/cartridge_admin.rst:725
msgid "**Critical level:**"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:682
msgid "If idle value doesn’t exceed T1 threshold (1 s.) — Yellow,"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:683
msgid "If idle value doesn’t exceed T2 threshold (5 s.) — Orange,"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:684
msgid "If idle value exceeds T3 threshold (10 s.) — Red."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:686
msgid "**Cluster condition:** For read requests to replica, the data may be obsolete compared with the data on master."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:689
msgid "**Solution:** Reconnect to the master: fix the network issues, reset the current master, switch to another master."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:692
msgid "``LOW_REDUNDANCY`` — Master has access to a single replica only."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:694
#: ../doc/book/cartridge/cartridge_admin.rst:712
#: ../doc/book/cartridge/cartridge_admin.rst:750
#: ../doc/book/cartridge/cartridge_admin.rst:865
msgid "**Critical level:** Yellow."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:696
msgid "**Cluster condition:** The data storage redundancy factor is equal to 2. It is lower than the minimal recommended value for production usage."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:699
msgid "**Solution:** Check cluster configuration:"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:701
msgid "If only one master and one replica are specified in the configuration, it is recommended to add at least one more replica to reach the redundancy factor of 3."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:704
msgid "If three or more replicas are specified in the configuration, consider checking the replicas' states and network connection among the replicas."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:707
msgid "``INVALID_REBALANCING`` — Rebalancing invariant was violated. During migration, a storage node can either send or receive buckets. So it shouldn’t be the case that a replica set sends buckets to one replica set and receives buckets from another replica set at the same time."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:714
msgid "**Cluster condition:** Rebalancing is on hold."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:716
msgid "**Solution:** There are two possible reasons for invariant violation:"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:718
msgid "The ``rebalancer`` has crashed."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:719
msgid "Bucket states were changed manually."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:721
msgid "Either way, please contact Tarantool support."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:723
msgid "``HIGH_REPLICATION_LAG`` — Replica’s lag exceeds T1 threshold (1 sec.)."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:727
msgid "If the lag doesn’t exceed T1 threshold (1 sec.) — Yellow;"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:728
msgid "If the lag exceeds T2 threshold (5 sec.) — Orange."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:730
#: ../doc/book/cartridge/cartridge_admin.rst:740
msgid "**Cluster condition:** For read-only requests to the replica, the data may be obsolete compared with the data on the master."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:733
#: ../doc/book/cartridge/cartridge_admin.rst:743
msgid "**Solution:** Check the replication status of the replica. Further instructions are given in the :ref:`Tarantool troubleshooting guide <admin-troubleshooting-guide>`."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:736
msgid "``OUT_OF_SYNC`` — Mal-synchronization occured. The lag exceeds T3 threshold (10 sec.)."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:738
msgid "**Critical level:** Red."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:748
msgid "``UNREACHABLE_REPLICA`` — One or multiple replicas are unreachable."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:752
msgid "**Cluster condition:** Data storage redundancy factor for the given replica set is less than the configured factor. If the replica is next in the queue for rebalancing (in accordance with the weight configuration), the requests are forwarded to the replica that is still next in the queue."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:757
msgid "**Solution:** Check the error message and find out which replica is unreachable. If a replica is disabled, enable it. If this doesn’t help, consider checking the network."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:761
msgid "``UNREACHABLE_REPLICASET`` — All replicas except for the current one are unreachable. **Critical level:** Red."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:764
msgid "**Cluster condition:** The replica stores obsolete data."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:766
msgid "**Solution:** Check if the other replicas are enabled. If all replicas are enabled, consider checking network issues on the master. If the replicas are disabled, check them first: the master might be working properly."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:774
msgid "Monitoring routers"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:776
msgid "Use ``vshard.router.info()`` to obtain information on the router."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:784
msgid "tarantool> vshard.router.info()\n"
"---\n"
"- replicasets:\n"
"    <replica set UUID>:\n"
"      master:\n"
"        status: <available / unreachable / missing>\n"
"        uri: <!-- URI of master\n"
"        uuid: <!-- UUID of instance\n"
"      replica:\n"
"        status: <available / unreachable / missing>\n"
"        uri: <!-- URI of replica used for slave requests\n"
"        uuid: <!-- UUID of instance\n"
"      uuid: <!-- UUID of replica set\n"
"    <replica set UUID>: ...\n"
"    ...\n"
"  status: <!-- status of router\n"
"  bucket:\n"
"    known: <!-- number of buckets with the known destination\n"
"    unknown: <!-- number of other buckets\n"
"  alerts: [<alert code>, <alert description>], ..."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:821
msgid "The ``router`` works in a regular way."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:823
msgid "Some replicas sre unreachable (affects the speed of executing read requests)."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:826
msgid "Service is degraded for changing data."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:828
msgid "Service is degraded for reading data."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:839
msgid "Depending on the nature of the issue, use either the UUID of a replica, or the UUID of a replica set."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:842
msgid "``MISSING_MASTER`` — The master in one or multiple replica sets is not specified in the configuration."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:847
#: ../doc/book/cartridge/cartridge_admin.rst:856
msgid "**Cluster condition:** Partial degrade for data-change requests."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:849
msgid "**Solution:** Specify the master in the configuration."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:851
msgid "``UNREACHABLE_MASTER`` — The ``router`` lost connection with the master of one or multiple replica sets."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:858
msgid "**Solution:** Restore connection with the master. First, check if the master is enabled. If it is, consider checking the network."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:861
msgid "``SUBOPTIMAL_REPLICA`` — There is a replica for read-only requests, but this replica is not optimal according to the configured weights. This means that the optimal replica is unreachable."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:867
msgid "**Cluster condition:** Read-only requests are forwarded to a backup replica."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:869
msgid "**Solution:** Check the status of the optimal replica and its network connection."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:871
msgid "``UNREACHABLE_REPLICASET`` — A replica set is unreachable for both read-only and data-change requests."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:874
msgid "**Critical Level:** Red."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:876
msgid "**Cluster condition:** Partial degrade for read-only and data-change requests."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:878
msgid "**Solution:** The replica set has an unreachable master and replica. Check the error message to detect this replica set. Then fix the issue in the same way as for :ref:`UNREACHABLE_REPLICA <unreachable_replica>`."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:886
msgid "Troubleshooting"
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:888
msgid "Please see the :ref:`Troubleshooting guide <admin-troubleshooting-guide>`."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:896
msgid "Please see the section :ref:`Disaster recovery <admin-disaster_recovery>`."
msgstr ""

#: ../doc/book/cartridge/cartridge_admin.rst:904
msgid "Please see the section :ref:`Backups <admin-backups>`."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:5
msgid "Tarantool Cartridge developer's guide"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:7
msgid "For a quick start, skip the details below and jump right away to this detailed `guide <https://github.com/tarantool/cartridge-cli/blob/master/examples/getting-started-app/README.md>`_ to creating a cluster-aware Tarantool application."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:11
msgid "For a deep dive into what you can do with Tarantool Cartridge, go on with this section."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:13
msgid "To develop and start an application, in short, you need to go through the following steps:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:16
msgid ":ref:`Install <cartridge-install>` Tarantool Cartridge and other components of the development environment."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:18
msgid "Choose a :ref:`template <cartridge-templates>` for the application and create a project."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:20
msgid "Develop the application. In case it is a cluster-aware application, implement its logic in a custom (user-defined) :ref:`cluster role <cartridge-roles>` to initialize the database in a cluster environment."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:24
msgid ":ref:`Deploy <cartridge-deploy>` the application to target server(s). This includes :ref:`configuring <cartridge-config>` and :ref:`starting <cartridge-run>` the instance(s)."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:27
msgid "In case it is a cluster-aware application, :ref:`deploy the cluster <cartridge-deployment>`."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:30
msgid "The following sections provide details for each of these steps."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:36
msgid "Installing Tarantool Cartridge"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:38
msgid "Install ``catridge-cli``, a command-line tool for developing, deploying, and managing Tarantool applications:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:41
msgid "$ tarantoolctl rocks install cartridge-cli"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:45
msgid "The Cartridge framework will come as a dependency when you create your project."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:47
msgid "Everything will be installed to ``.rocks/bin``, so for convenient usage add ``.rocks/bin`` to the executable path:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:50
msgid "$ export PATH=$PWD/.rocks/bin/:$PATH"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:54
msgid "Install ``git``, a version control system."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:56
msgid "Install ``npm``, a package manager for ``node.js``."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:58
msgid "Install the ``unzip`` utility."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:64
msgid "Application templates"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:66
msgid "Tarantool Cartridge provides you with two templates that help instantly set up the application development environment:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:69
msgid "``plain``, for developing an application that runs on a single or multiple independent Tarantool instances (e.g. acting as a proxy to third-party databases) -- that's what you could do before, :ref:`without Tarantool Cartridge <app_server-creating_app>`, but now it's more convenient."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:74
msgid "``cartridge``, for developing a cluster-aware application -- this is an exclusive feature of Tarantool Cartridge."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:77
msgid "To create a project based on either template, in any directory say:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:79
msgid "# plain application\n"
"$ plain create --name <app_name> /path/to/\n"
"\n"
"# - OR -\n"
"\n"
"# cluster application\n"
"$ cartridge create --name <app_name> /path/to/"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:89
msgid "This will automatically set up a Git repository in a new ``/path/to/<app_name>/`` directory, tag it with :ref:`version <cartridge-versioning>` ``0.1.0``, and put the necessary files into it (read about default files for each template below)."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:94
msgid "In this Git repository, you can develop the application (by simply editing the default files provided by the template), plug the necessary modules, and then easily pack everything to deploy on your server(s)."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:102
msgid "Plain template"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:104
msgid "The plain template creates the ``<app_name>/`` directory with the following contents:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:107
msgid "``<app_name>-scm-1.rockspec`` file where you can specify the application dependencies."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:109
msgid "``deps.sh`` script that resolves dependencies from the ``.rockspec`` file."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:110
msgid "``init.lua`` file which is the entry point for your application."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:111
msgid "``.git`` file necessary for a Git repository."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:112
msgid "``.gitignore`` file to ignore the unnecessary files."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:118
msgid "Cluster template"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:120
msgid "In addition to the files listed in the plain template section, the cluster template contains the following:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:123
msgid "``env.lua`` file that sets common rock paths so that the application can be started from any directory."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:125
msgid "``custom-role.lua`` file that is a placeholder for a custom (user-defined) :ref:`cluster role <cartridge-roles>`."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:128
msgid "The entry point file (``init.lua``) of the cluster template differs from the plain one. Among other things, it loads the ``cartridge`` module and calls its initialization function:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:132
msgid "...\n"
"local cartridge = require('cartridge')\n"
"...\n"
"cartridge.cfg({\n"
"  workdir = ...,\n"
"  advertise_uri = ...,\n"
"  cluster_cookie = ...,\n"
"  ...\n"
"})\n"
"..."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:145
msgid "The ``cartridge.cfg()`` call renders the instance operable via the administrative console but does not call ``box.cfg()`` to configure instances."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:150
msgid "Calling the ``box.cfg()`` function is forbidden."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:152
msgid "The cluster itself will do it for you when it is time to:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:154
msgid "bootstrap the current instance once you:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:156
msgid "run ``cartridge.bootstrap()`` via the administrative console, or"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:157
msgid "click **Create** in the web interface;"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:159
msgid "join the instance to an existing cluster once you:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:161
msgid "run ``cartridge.join_server({uri = 'other_instance_uri'})`` via the console, or"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:162
msgid "click **Join** (an existing replica set) or **Create** (a new replica set) in the web interface."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:165
msgid "Notice that you can specify a cookie for the cluster (``cluster_cookie`` parameter) if you need to run several clusters in the same network. The cookie can be any string value."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:169
msgid "Before developing a cluster-aware application, familiarize yourself with the notion of :ref:`cluster roles <cartridge-roles>` and make sure to define a custom role to initialize the database for the cluster application."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:178
msgid "Cluster roles"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:180
msgid "A Tarantool Cartridge cluster segregates instance functionality in a role-based way. **Cluster roles** are Lua modules that implement some instance-specific functions and/or logic."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:184
msgid "Since all instances running cluster applications use the same source code and are aware of all the defined roles (and plugged modules), multiple different roles can be dynamically enabled and disabled on any number of instances without restarts even during cluster operation."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:193
msgid "Built-in roles"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:195
msgid "The ``cartridge`` module comes with two *built-in* roles that implement automatic sharding:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:198
msgid "``vshard-router`` that handles the ``vshard``'s *compute-intensive* workload: routes requests to storage nodes."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:200
msgid "``vshard-storage`` that handles the ``vshard``'s *transaction-intensive* workload: stores and manages a subset of a dataset."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:205
msgid "For more information on sharding, see the :ref:`vshard module documentation <vshard>`."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:208
msgid "With the built-in and custom roles, Tarantool Cartridge allows you to develop applications with separated compute and transaction handling. Later, the relevant workload-specific roles can be enabled on different instances running on physical servers with workload-dedicated hardware."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:213
msgid "Neither ``vshard-router`` nor ``vshard-storage`` manage spaces, indexes, or formats. To start developing an application, edit the ``custom-role.lua`` placeholder file: add a ``box.schema.space.create()`` call to your first cluster role."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:218
msgid "Additionally, you can implement several such roles to:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:220
msgid "define stored procedures;"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:221
msgid "implement functionality on top of ``vshard``;"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:222
msgid "go without ``vshard`` at all;"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:223
msgid "implement one or multiple supplementary services such as e-mail notifier, replicator, etc."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:230
msgid "Custom roles"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:232
msgid "To implement a *custom* cluster role, do the following:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:234
msgid "Register the new role in the cluster by modifying the ``cartridge.cfg()`` call in the ``init.lua`` entry point file:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:237
msgid "...\n"
"local cartridge = require('cartridge')\n"
"...\n"
"cartridge.cfg({\n"
"  workdir = ...,\n"
"  advertise_uri = ...,\n"
"  roles = {'custom-role'},\n"
"})\n"
"..."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:250
msgid "where ``custom-role`` is the name of the Lua module to be loaded."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:252
msgid "Implement the role in a file with the appropriate name (``custom-role.lua``). For example:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:255
msgid "#!/usr/bin/env tarantool\n"
"-- Custom role implementation\n"
"local role_name = 'custom-role'\n"
"\n"
"local function init()\n"
"...\n"
"end\n"
"\n"
"local function stop()\n"
"...\n"
"end\n"
"\n"
"return {\n"
"    role_name = role_name,\n"
"    init = init,\n"
"    stop = stop,\n"
"}"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:275
msgid "Where the ``role_name`` may differ from the module name passed to the ``cartridge.cfg()`` function. If the ``role_name`` variable is not specified, the module name is the default value."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:281
msgid "Role names must be unique as it is impossible to register multiple roles with the same name."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:284
msgid "The role module does not have required functions but the cluster may execute the following ones during the role's life cycle:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:287
msgid "``init()`` is the role's *initialization* function."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:289
msgid "Inside the function's body you can call any ``box`` functions: create spaces, indexes, grant permissions, etc. Here is what the initialization function may look like:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:293
msgid "local function init(opts)\n"
"    -- The cluster passes an 'opts' Lua table containing an 'is_master' flag.\n"
"    if opts.is_master then\n"
"        local customer = box.schema.space.create('customer',\n"
"            { if_not_exists = true }\n"
"        )\n"
"        customer:format({\n"
"            {'customer_id', 'unsigned'},\n"
"            {'bucket_id', 'unsigned'},\n"
"            {'name', 'string'},\n"
"        })\n"
"        customer:create_index('customer_id', {\n"
"            parts = {'customer_id'},\n"
"            if_not_exists = true,\n"
"        })\n"
"    end\n"
"end"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:316
msgid "The function's body is wrapped in a conditional statement that lets you call ``box`` functions on masters only. This protects against replication collisions as data propagates to replicas automatically."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:321
msgid "``stop()`` is the role's *termination* function. Implement it if initialization starts a fiber that has to be stopped or does any job that has to be undone on termination."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:325
msgid "``validate_config()`` and ``apply_config()`` are *validation* and *application* functions that make custom roles configurable. Implement them if some configuration data has to be stored cluster-wide."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:329
msgid "Next, get a grip on the :ref:`role's life cycle <cartridge-role-lifecycle>` to implement the necessary functions."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:336
msgid "Defining role dependencies"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:338
msgid "You can instruct the cluster to apply some other roles if your custom role is enabled."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:343
msgid "-- Role dependencies defined in custom-role.lua\n"
"local role_name = 'custom-role'\n"
"...\n"
"return {\n"
"    role_name = role_name,\n"
"    dependencies = {'cartridge.roles.vshard-router'},\n"
"    ...\n"
"}"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:354
msgid "Here ``vshard-router`` role will be initialized automatically for every instance with ``custom-role`` enabled."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:361
msgid "Using multiple vshard storage groups"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:363
msgid "Replica sets with ``vshard-storage`` roles can belong to different *groups*. For example, ``hot`` or ``cold`` groups meant to independently process hot and cold data."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:367
msgid "Groups are specified in the cluster's configuration:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:369
msgid "cartridge.cfg({\n"
"    vshard_groups = {'hot', 'cold'},\n"
"    ...\n"
"})"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:376
msgid "If no groups are specified, the cluster assumes that all replica sets belong to the ``default`` group."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:379
msgid "With multiple groups enabled, every replica set with a ``vshard-storage`` role enabled must be assigned to a particular group. The assignment can never be changed."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:383
msgid "Another limitation is that you cannot add groups dynamically (this will become available in future)."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:386
msgid "Finally, mind the new syntax for router access. Every instance with a ``vshard-router`` role enabled initializes multiple routers. All of them are accessible through the role:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:390
msgid "local router_role = cartridge.service_get('vshard-router')\n"
"router_role.get('hot'):call(...)"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:395
msgid "If you have no roles specified, you can access a static router as before:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:397
msgid "local vhsard = require('vshard')\n"
"vshard.router.call(...)"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:402
msgid "However, when using the new API, you must call a static router with a colon:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:404
msgid "local router_role = cartridge.service_get('vshard-router')\n"
"local default_router = router_role.get() -- or router_role.get('default')\n"
"default_router:call(...)"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:414
msgid "Role's life cycle and the order of function execution"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:416
msgid "The cluster displays all custom role names along with the built-in ``vshard`` ones in the web interface. Cluster administrators can enable and disable them for particular instances either via the web interface or cluster public API. For example:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:421
msgid "cartridge.admin.edit_replicaset('replicaset-uuid', {roles = {'vshard-router', 'custom-role'}})"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:425
msgid "If multiple roles are enabled on an instance at the same time, the cluster first initializes the built-in roles (if any) and then the custom ones (if any) in the order the latter were listed in ``cartridge.cfg()``."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:429
msgid "If a custom role has dependent roles, the dependencies are registered and validated first, prior to the role itself."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:432
msgid "The cluster calls the role's functions in the following circumstances:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:434
msgid "The ``init()`` function, typically, once: either when the role is enabled by the administrator or at the instance restart. Enabling a role once is normally enough."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:438
msgid "The ``stop()`` function -- only when the administrator disables the role, not on instance termination."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:441
msgid "The ``validate_config()`` function, first, before the automatic ``box.cfg()`` call (database initialization), then -- upon every configuration update."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:444
msgid "The ``apply_config()`` function upon every configuration update."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:446
msgid "Hence, if the cluster is tasked with performing the following actions, it will execute the functions listed in the following order:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:449
msgid "Join an instance or create a replica set, both with an enabled role:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:451
#: ../doc/book/cartridge/cartridge_dev.rst:457
#: ../doc/book/cartridge/cartridge_dev.rst:465
#: ../doc/book/cartridge/cartridge_dev.rst:470
msgid "``validate_config()``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:452
#: ../doc/book/cartridge/cartridge_dev.rst:458
msgid "``init()``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:453
#: ../doc/book/cartridge/cartridge_dev.rst:459
#: ../doc/book/cartridge/cartridge_dev.rst:466
#: ../doc/book/cartridge/cartridge_dev.rst:471
msgid "``apply_config()``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:455
msgid "Restart an instance with an enabled role:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:461
msgid "Disable role: ``stop()``."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:463
msgid "Upon the ``cartridge.confapplier.patch_clusterwide()`` call:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:468
msgid "Upon a triggered failover:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:473
msgid "Considering the described behavior:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:475
msgid "The ``init()`` function may:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:477
msgid "Call ``box`` functions."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:478
msgid "Start a fiber and, in this case, the ``stop()`` function should take care of the fiber's termination."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:480
msgid "Configure the built-in :ref:`HTTP server <cartridge-httpd-instance>`."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:481
msgid "Execute any code related to the role's initialization."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:483
msgid "The ``stop()`` functions must undo any job that has to be undone on role's termination."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:486
msgid "The ``validate_config()`` function must validate any configuration change."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:488
msgid "The ``apply_config()`` function may execute any code related to a configuration change, e.g., take care of an ``expirationd`` fiber."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:491
msgid "The validation and application functions together allow you to customize the cluster-wide configuration as described in the :ref:`next section <cartridge-role-config>`."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:499
msgid "Configuring custom roles"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:503
msgid "Store your custom roles as sections in cluster-wide configuration, for example:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:506
msgid "my_role:\n"
"  notify_url: \"https://localhost:8080\""
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:511
msgid "local notify_url = 'http://localhost'\n"
"function my_role.apply_config(conf, opts)\n"
"  local conf = conf['my_role'] or {}\n"
"  notify_url = conf.notify_url or 'default'\n"
"end"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:519
msgid "Download and upload cluster-wide configuration using :ref:`cluster UI <cartridge-ui-configuration>` or API (via GET/PUT queries to ``admin/config`` endpoint like ``curl localhost:8081/admin/config`` and ``curl -X PUT -d \"{'my_parameter': 'value'}\" localhost:8081/admin/config``)."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:525
msgid "Utilize it in your role ``apply_config()`` function."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:527
msgid "Every instance in the cluster stores a copy of the configuration file in its working directory (configured by ``cartridge.cfg({workdir = ...})``):"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:530
msgid "``/var/lib/tarantool/<instance_name>/config.yml`` for instances deployed from RPM packages and managed by ``systemd``."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:532
msgid "``/home/<username>/tarantool_state/var/lib/tarantool/config.yml`` for instances deployed from archives."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:535
msgid "The cluster's configuration is a Lua table, downloaded and uploaded as YAML. If some application-specific configuration data, e.g., a database schema as defined by DDL (data definition language), has to be stored on every instance in the cluster, you can implement your own API by adding a custom section to the table. The cluster will help you spread it safely across all instances."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:541
msgid "Such section goes in parallel (in the same file) with the topology-specific and ``vshard``-specific ones the cluster automatically generates. Unlike the generated, the custom section's modification, validation, and application logic has to be defined."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:546
msgid "The common way is to define two functions:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:548
msgid "``validate_config(conf_new, conf_old)`` to validate changes made in the new configuration (``conf_new``) versus the old configuration (``conf_old``)."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:550
msgid "``apply_config(conf, opts)`` to execute any code related to a configuration change. As input, this function takes the configuration to apply (``conf``, which is actually the new configuration that you validated earlier with ``validate_config()``) and options (the ``opts`` argument that includes ``is_master``, a Boolean flag described later)."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:558
msgid "The ``validate_config()`` function must detect all configuration problems that may lead to ``apply_config()`` errors. For more information, see the :ref:`next section <cartridge-role-config-apply>`."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:562
msgid "When implementing validation and application functions that call ``box`` ones for some reason, the following precautions apply:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:565
msgid "Due to the :ref:`role's life cycle <cartridge-role-lifecycle>`, the cluster does not guarantee an automatic ``box.cfg()`` call prior to calling ``validate_config()``."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:569
msgid "If the validation function is to call any ``box`` functions (e.g., to check a format), make sure the calls are wrapped in a protective conditional statement that checks if ``box.cfg()`` has already happened:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:573
msgid "-- Inside the validation function:\n"
"\n"
"if type(box.cfg) == 'function' then\n"
"\n"
"    -- Here you can call box functions\n"
"\n"
"end"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:584
msgid "Unlike the validation and similar to initialization function, ``apply_config()`` can call ``box`` functions freely as the cluster applies custom configuration after the automatic ``box.cfg()`` call."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:588
msgid "However, creating spaces, users, etc., can cause replication collisions when performed on both master and replica instances simultaneously. The appropriate way is to call such ``box`` functions on masters only and let the changes propagate to replicas automatically."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:593
msgid "Upon the ``apply_config(conf, opts)`` execution, the cluster passes an ``is_master`` flag in the ``opts`` table which you can use to wrap collision-inducing ``box`` functions in a protective conditional statement:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:597
msgid "-- Inside the configuration application function:\n"
"\n"
"if opts.is_master then\n"
"\n"
"    -- Here you can call box functions\n"
"\n"
"end"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:612
msgid "Custom configuration example"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:614
msgid "Consider the following code as part of the role's module (``custom-role.lua``) implementation:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:617
msgid "#!/usr/bin/env tarantool\n"
"-- Custom role implementation\n"
"\n"
"local cartridge = require('cartridge')\n"
"\n"
"local role_name = 'custom-role'\n"
"\n"
"-- Modify the config by implementing some setter (an alternative to HTTP PUT)\n"
"local function set_secret(secret)\n"
"    local custom_role_cfg = cartridge.confapplier.get_deepcopy(role_name) or {}\n"
"    custom_role_cfg.secret = secret\n"
"    cartridge.confapplier.patch_clusterwide({\n"
"        [role_name] = custom_role_cfg,\n"
"    })\n"
"end\n"
"-- Validate\n"
"local function validate_config(cfg)\n"
"    local custom_role_cfg = cfg[role_name] or {}\n"
"    if custom_role_cfg.secret ~= nil then\n"
"        assert(type(custom_role_cfg.secret) == 'string', 'custom-role.secret must be a string')\n"
"    end\n"
"    return true\n"
"end\n"
"-- Apply\n"
"local function apply_config(cfg)\n"
"    local custom_role_cfg = cfg[role_name] or {}\n"
"    local secret = custom_role_cfg.secret or 'default-secret'\n"
"    -- Make use of it\n"
"end\n"
"\n"
"return {\n"
"    role_name = role_name,\n"
"    set_secret = set_secret,\n"
"    validate_config = validate_config,\n"
"    apply_config = apply_config,\n"
"}"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:656
msgid "Once the configuration is customized, do one of the following:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:658
msgid "continue developing your application and pay attention to its :ref:`versioning <cartridge-versioning>`;"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:660
msgid "(optional) :ref:`enable authorization <cartridge-auth-enable>` in the web interface."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:661
msgid "in case the cluster is already deployed, :ref:`apply the configuration <cartridge-role-config-apply>` cluster-wide."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:668
msgid "Applying custom role's configuration"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:670
msgid "With the implementation showed by the :ref:`example <cartridge-role-config-example>`, you can call the ``set_secret()`` function to apply the new configuration via the administrative console or an HTTP endpoint if the role exports one."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:674
msgid "The ``set_secret()`` function calls ``cartridge.confapplier.patch_clusterwide()`` which performs a two-phase commit:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:677
msgid "It patches the active configuration in memory: copies the table and replaces the ``\"custom-role\"`` section in the copy with the one given by the ``set_secret()`` function."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:681
msgid "The cluster checks if the new configuration can be applied on all instances except disabled and expelled. All instances subject to update must be healthy and ``alive`` according to the `membership module <https://www.tarantool.io/en/doc/2.2/reference/reference_rock/membership/>`_."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:686
msgid "(**Preparation phase**) The cluster propagates the patched configuration. Every instance validates it with the ``validate_config()`` function of every registered role. Depending on the validation's result:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:690
msgid "If successful (i.e., returns ``true``), the instance saves the new configuration to a temporary file named ``config.prepare.yml`` within the working directory."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:693
msgid "(**Abort phase**) Otherwise, the instance reports an error and all other instances roll back the update: remove the file they may have already prepared."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:697
msgid "(**Commit phase**) Upon successful preparation of all instances, the cluster commits the changes. Every instance:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:700
msgid "Creates the active configuration's hard-link."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:701
msgid "Atomically replaces the active one with the prepared. The atomic replacement is indivisible -- it can either succeed or fail entirely, never partially."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:704
msgid "Calls the ``apply_config()`` function of every registered role."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:706
msgid "If any of these steps fail, an error pops up in the web interface next to the corresponding instance. The cluster does not handle such errors automatically, they require manual repair."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:710
msgid "You will avoid the repair if the ``validate_config()`` function can detect all configuration problems that may lead to ``apply_config()`` errors."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:717
msgid "Using the built-in HTTP server"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:719
msgid "The cluster launches an ``httpd`` server instance during initialization (``cartridge.cfg()``). You can bind a port to the instance via an environmental variable:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:723
msgid "-- Get the port from an environmental variable or the default one:\n"
"local http_port = os.getenv('HTTP_PORT') or '8080'\n"
"\n"
"local ok, err = cartridge.cfg({\n"
"   ...\n"
"   -- Pass the port to the cluster:\n"
"   http_port = http_port,\n"
"   ...\n"
"})"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:735
msgid "To make use of the ``httpd`` instance, access it and configure routes inside the ``init()`` function of some role, e.g. a role that exposes API over HTTP:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:738
msgid "local function init(opts)\n"
"\n"
"...\n"
"\n"
"   -- Get the httpd instance:\n"
"   local httpd = cartridge.service_get('httpd')\n"
"   if httpd ~= nil then\n"
"       -- Configure a route to, for example, metrics:\n"
"       httpd:route({\n"
"               method = 'GET',\n"
"               path = '/metrics',\n"
"               public = true,\n"
"           },\n"
"           function(req)\n"
"               return req:render({json = stat.stat()})\n"
"           end\n"
"       )\n"
"   end\n"
"end"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:760
msgid "For more information on the usage of Tarantool's HTTP server, see `its documentation <https://github.com/tarantool/http>`_."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:767
msgid "Implementing authorization in the web interface"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:769
msgid "To implement authorization in the web interface of every instance in Tarantool cluster:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:772
msgid "Implement a new, say, ``auth`` module with a ``check_password`` function. It should check the credentials of any user trying to log in to the web interface."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:775
msgid "The ``check_password`` function accepts a username and password and returns an authentication success or failure."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:778
msgid "-- auth.lua\n"
"\n"
"-- Add a function to check the credentials\n"
"local function check_password(username, password)\n"
"\n"
"    -- Check the credentials any way you like\n"
"\n"
"    -- Return an authentication success or failure\n"
"    if not ok then\n"
"        return false\n"
"    end\n"
"    return true\n"
"end\n"
"..."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:795
msgid "Pass the implemented ``auth`` module name as a parameter to ``cartridge.cfg()``, so the cluster can use it:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:798
msgid "-- init.lua\n"
"\n"
"local ok, err = cartridge.cfg({\n"
"    auth_backend_name = 'auth',\n"
"    -- The cluster will automatically call 'require()' on the 'auth' module.\n"
"    ...\n"
"})"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:808
msgid "This adds a **Log in** button to the upper right corner of the web interface but still lets the unsigned users interact with the interface. This is convenient for testing."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:814
msgid "Also, to authorize requests to cluster API, you can use the HTTP basic authorization header."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:817
msgid "To require the authorization of every user in the web interface even before the cluster bootstrap, add the following line:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:820
msgid "-- init.lua\n"
"\n"
"local ok, err = cartridge.cfg({\n"
"    auth_backend_name = 'auth',\n"
"    auth_enabled = true,\n"
"    ...\n"
"})"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:831
msgid "With the authentication enabled and the ``auth`` module implemented, the user will not be able to even bootstrap the cluster without logging in. After the successful login and bootstrap, the authentication can be enabled and disabled cluster-wide in the web interface and the ``auth_enabled`` parameter is ignored."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:841
msgid "Application versioning"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:843
msgid "Tarantool Cartridge understands semantic versioning as described at `semver.org <https://semver.org>`_. When developing an application, create new Git branches and tag them appropriately. These tags are used to calculate version increments for subsequent packaging."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:848
msgid "For example, if your application has version 1.2.1, tag your current branch with ``1.2.1`` (annotated or not)."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:851
msgid "To retrieve the current version from Git, say:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:853
msgid "$ git describe --long --tags\n"
"1.2.1-12-g74864f2"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:858
msgid "This output shows that we are 12 commits after the version 1.2.1. If we are to package the application at this point, it will have a full version of ``1.2.1-12`` and its package will be named ``<app_name>-1.2.1-12.rpm``."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:862
msgid "Non-semantic tags are prohibited. You will not be able to create a package from a branch with the latest tag being non-semantic."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:865
msgid "Once you :ref:`package <cartridge-deploy>` your application, the version is saved in a ``VERSION`` file in the package root."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:872
msgid "Using .cartridge-cli.ignore files"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:874
msgid "You can add a ``.cartridge-cli.ignore`` file to your application repository to exclude particular files and/or directories from package builds."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:877
msgid "For the most part, the logic is similar to that of ``.gitignore`` files. The major difference is that in ``.cartridge-cli.ignore`` files the order of exceptions relative to the rest of the templates does not matter, while in ``.gitignore`` files the order does matter."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:888
msgid "**.cartridge-cli.ignore** entry"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:888
msgid "ignores every..."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:890
msgid "``target/``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:890
msgid "**folder** (due to the trailing ``/``) named ``target``, recursively"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:893
msgid "``target``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:893
msgid "**file or folder** named ``target``, recursively"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:896
msgid "``/target``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:896
msgid "**file or folder** named ``target`` in the top-most directory (due to the leading ``/``)"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:899
msgid "``/target/``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:899
msgid "**folder** named ``target`` in the top-most directory (leading and trailing ``/``)"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:902
msgid "``*.class``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:902
msgid "every **file or folder** ending with ``.class``, recursively"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:905
msgid "``#comment``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:905
msgid "nothing, this is a comment (the first character is a ``#``)"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:908
msgid "``\\#comment``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:908
msgid "every **file or folder** with name ``#comment`` (``\\`` for escaping)"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:911
msgid "``target/logs/``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:911
msgid "every **folder** named ``logs`` which is a subdirectory of a folder named ``target``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:914
msgid "``target/*/logs/``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:914
msgid "every **folder** named ``logs`` two levels under a folder named ``target`` (``*`` doesn’t include ``/``)"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:918
msgid "``target/**/logs/``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:918
msgid "every **folder** named ``logs`` somewhere under a folder named ``target`` (``**`` includes ``/``)"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:922
msgid "``*.py[co]``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:922
msgid "every **file or folder** ending in ``.pyc`` or ``.pyo``; however, it doesn’t match ``.py!``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:925
msgid "``*.py[!co]``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:925
msgid "every **file or folder** ending in anything other than ``c`` or ``o``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:928
msgid "``*.file[0-9]``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:928
msgid "every **file or folder** ending in digit"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:930
msgid "``*.file[!0-9]``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:930
msgid "every **file or folder** ending in anything other than digit"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:933
msgid "``*``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:933
msgid "**every**"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:935
msgid "``/*``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:935
msgid "**everything** in the top-most directory (due to the leading ``/``)"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:938
msgid "``**/*.tar.gz``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:938
msgid "every ``*.tar.gz`` file or folder which is **one or more** levels under the starting folder"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:942
msgid "``!file``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:942
msgid "every **file or folder** will be ignored even if it matches other patterns"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:950
msgid "Deploying an application"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:952
msgid "You have four options to deploy a Tarantool Cartridge application:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:954
msgid "as an :ref:`rpm <cartridge-deploy-rpm>` package (for production);"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:955
msgid "as a :ref:`deb <cartridge-deploy-deb>` package (for production);"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:956
msgid "as a :ref:`tar+gz <cartridge-deploy-tgz>` archive (for testing, or as a workaround for production if root access is unavailable)."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:958
msgid ":ref:`from sources <cartridge-deploy-rock>` (for local testing only)."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:965
msgid "Deploying as an rpm or deb package"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:967
#: ../doc/book/cartridge/cartridge_dev.rst:1012
msgid "Pack the application into a distributable:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:969
msgid "$ cartridge pack rpm APP_NAME\n"
"# -- OR --\n"
"$ cartridge pack deb APP_NAME"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:975
msgid "This will create an RPM package (e.g. ``./my_app-0.1.0-1.rpm``) or a DEB package (e.g. ``./my_app-0.1.0-1.deb``)."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:978
msgid "Upload the package to target servers, with ``systemctl`` supported."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:980
msgid "Install:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:982
msgid "$ yum install APP_NAME-VERSION.rpm\n"
"# -- OR --\n"
"$ dpkg -i APP_NAME-VERSION.deb"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:988
#: ../doc/book/cartridge/cartridge_dev.rst:1029
#: ../doc/book/cartridge/cartridge_dev.rst:1066
msgid ":ref:`Configure the instance(s) <cartridge-config>`."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:990
msgid "Start Tarantool instances with the corresponding services. You can do it using :ref:`systemctl <cartridge-run-systemctl>`, for example:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:993
msgid "# starts a single instance\n"
"$ systemctl start my_app\n"
"\n"
"# starts multiple instances\n"
"$ systemctl start my_app@router\n"
"$ systemctl start my_app@storage_A\n"
"$ systemctl start my_app@storage_B"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1003
#: ../doc/book/cartridge/cartridge_dev.rst:1051
#: ../doc/book/cartridge/cartridge_dev.rst:1088
msgid "In case it is a cluster-aware application, proceed to :ref:`deploying the cluster <cartridge-deployment>`."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1010
msgid "Deploying as a tar+gz archive"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1014
msgid "$ cartridge pack tgz APP_NAME"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1018
msgid "This will create a tar+gz archive (e.g. ``./my_app-0.1.0-1.tgz``)."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1020
msgid "Upload the archive to target servers, with ``tarantool`` and (optionally) :ref:`cartridge-cli <cartridge-install>` installed."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1023
msgid "Extract the archive:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1025
msgid "$ tar -xzvf APP_NAME-VERSION.tgz"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1031
#: ../doc/book/cartridge/cartridge_dev.rst:1068
msgid "Start Tarantool instance(s). You can do it using:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1033
#: ../doc/book/cartridge/cartridge_dev.rst:1070
msgid ":ref:`tarantool <cartridge-run-tarantool>`, for example:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1035
#: ../doc/book/cartridge/cartridge_dev.rst:1072
msgid "$ tarantool init.lua # starts a single instance"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1039
#: ../doc/book/cartridge/cartridge_dev.rst:1076
msgid "or :ref:`cartridge <cartridge-run-cartridge>`, for example:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1041
msgid "# in application directory\n"
"$ cartridge start # starts all instances\n"
"$ cartridge start .router_1 # starts a single instance\n"
"\n"
"# in multi-application environment\n"
"$ cartridge start my_app # starts all instances of my_app\n"
"$ cartridge start my_app.router # starts a single instance"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1058
msgid "Deploying from sources"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1060
msgid "This deployment method is intended for local testing only."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1062
msgid "Pull all dependencies to the ``.rocks`` directory:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1064
msgid "$ tarantoolctl rocks make"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1078
msgid "# in application directory\n"
"cartridge start # starts all instances\n"
"cartridge start .router_1 # starts a single instance\n"
"\n"
"# in multi-application environment\n"
"cartridge start my_app # starts all instances of my_app\n"
"cartridge start my_app.router # starts a single instance"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1095
msgid "Configuring instances"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1097
msgid "Instance configuration includes two sets of parameters:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1099
msgid "`cartridge.cfg() parameters <https://www.tarantool.io/en/rocks/cartridge/1.0/modules/cartridge.argparse/#cluster-opts>`_;"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1100
msgid "`box.cfg() parameters <https://www.tarantool.io/en/rocks/cartridge/1.0/modules/cartridge.argparse/#box-opts>`_."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1102
msgid "You can set any of these parameters in:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1104
msgid "Command line arguments."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1105
msgid "Environment variables."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1106
msgid "YAML configuration file."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1107
msgid "``init.lua`` file."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1109
msgid "The order here indicates the priority: command-line arguments override environment variables, and so forth."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1112
msgid "No matter how you :ref:`start the instances <cartridge-run>`, you need to set the following ``cartridge.cfg()`` parameters for each instance:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1115
msgid "``advertise_uri`` -- either ``<HOST>:<PORT>``, or ``<HOST>:``, or ``<PORT>``. Used by other instances to connect to the current one. **DO NOT** specify ``0.0.0.0`` -- this must be an external IP address, not a socket bind."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1119
msgid "``http_port`` -- port to open administrative web interface and API on. Defaults to ``8081``. To disable it, specify ``\"http_enabled\": False``."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1122
msgid "``workdir`` -- a directory where all data will be stored: snapshots, wal logs, and ``cartridge`` configuration file. Defaults to ``.``."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1129
msgid "If you start instances using ``cartridge`` CLI or ``systemctl``, save the configuration as a YAML file, for example:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1132
msgid "my_app.router: {\"advertise_uri\": \"localhost:3301\", \"http_port\": 8080}\n"
"my_app.storage_A: {\"advertise_uri\": \"localhost:3302\", \"http_enabled\": False}\n"
"my_app.storage_B: {\"advertise_uri\": \"localhost:3303\", \"http_enabled\": False}"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1138
msgid "With ``cartridge`` CLI, you can pass the path to this file as the ``--cfg`` command-line argument to the ``cartridge start`` command -- or specify the path in ``cartridge`` CLI configuration (in ``./.cartridge.yml`` or ``~/.cartridge.yml``):"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1142
msgid "cfg: cartridge.yml\n"
"run_dir: tmp/run\n"
"apps_path: /usr/local/share/tarantool"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1148
msgid "With ``systemctl``, save the YAML file to ``/etc/tarantool/conf.d/`` (the default ``systemd`` path) or to a location set in the ``TARANTOOL_CFG`` environment variable."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1154
msgid "If you start instances with ``tarantool init.lua``, you need to pass other configuration options as command-line parameters and environment variables, for example:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1158
msgid "$ tarantool init.lua --alias router --memtx-memory 100 --workdir \"~/db/3301\" --advertise_uri \"localhost:3301\" --http_port \"8080\""
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1166
msgid "Starting/stopping instances"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1168
msgid "Depending on your :ref:`deployment method <cartridge-deploy>`, you can start/stop the instances using :ref:`tarantool <cartridge-run-tarantool>`, :ref:`cartridge CLI <cartridge-run-cartridge>`, or :ref:`systemctl <cartridge-run-systemctl>`."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1177
msgid "Start/stop using ``tarantool``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1179
msgid "With ``tarantool``, you can start only a single instance:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1181
msgid "$ tarantool init.lua # the simplest command"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1185
msgid "You can also :ref:`specify more options <cartridge-config-tarantool>` on the command line or in environment variables."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1188
msgid "To stop the instance, use Ctrl+C."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1194
msgid "Start/stop using ``cartridge`` CLI"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1196
msgid "With ``cartridge`` CLI, you can start one or multiple instances:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1198
msgid "$ cartridge start [APP_NAME[.INSTANCE_NAME]] [options]"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1202
msgid "The options are:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1210
msgid "``--script FILE``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1205
msgid "Application's entry point. Defaults to:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1208
msgid "``TARANTOOL_SCRIPT``, or"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1209
msgid "``./init.lua`` when running from the app's directory, or"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1210
msgid "``:apps_path/:app_name/init.lua`` in a multi-app environment."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1214
msgid "``--apps_path PATH``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1213
msgid "Path to apps directory when running in a multi-app environment. Defaults to ``/usr/share/tarantool``."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1218
#: ../doc/book/cartridge/cartridge_dev.rst:1260
msgid "``--run_dir DIR``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1217
msgid "Directory with pid and sock files. Defaults to ``TARANTOOL_RUN_DIR`` or ``/var/run/tarantool``."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1222
#: ../doc/book/cartridge/cartridge_dev.rst:1261
msgid "``--cfg FILE``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1221
msgid "Cartridge instances YAML configuration file. Defaults to ``TARANTOOL_CFG`` or ``./instances.yml``."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1225
msgid "``--foreground``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1225
msgid "Do not daemonize."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1233
msgid "It starts all ``tarantool`` instances specified in ``cfg`` file, in foreground, with enforced :ref:`environment variables <cartridge-config>`."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1236
msgid "When ``APP_NAME`` is not provided, ``cartridge`` parses it from ``./*.rockspec`` filename."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1239
msgid "When ``INSTANCE_NAME`` is not provided, ``cartridge`` reads ``cfg`` file and starts all defined instances:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1242
msgid "# in application directory\n"
"cartridge start # starts all instances\n"
"cartridge start .router_1 # start single instance\n"
"\n"
"# in multi-application environment\n"
"cartridge start my_app # starts all instances of my_app\n"
"cartridge start my_app.router # start a single instance"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1252
msgid "To stop the instances, say:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1254
msgid "$ cartridge stop [APP_NAME[.INSTANCE_NAME]] [options]"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1258
msgid "These options from the ``cartridge start`` command are supported:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1267
msgid "Start/stop using ``systemctl``"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1269
msgid "To run a single instance:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1271
msgid "$ systemctl start APP_NAME"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1275
msgid "This will start a  ``systemd`` service that will listen to the port specified in :ref:`instance configuration <cartridge-config>` (``http_port`` parameter)."
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1279
msgid "To run multiple instances on one or multiple servers:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1281
msgid "$ systemctl start APP_NAME@INSTANCE_1\n"
"$ systemctl start APP_NAME@INSTANCE_2\n"
"...\n"
"$ systemctl start APP_NAME@INSTANCE_N"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1288
msgid "where ``APP_NAME@INSTANCE_N`` is the instantiated service name for ``systemd`` with an incremental ``N`` -- a number, unique for every instance, added to the port the instance will listen to (e.g., ``3301``, ``3302``, etc.)"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1293
msgid "To stop all services on a server, use the ``systemctl stop`` command and specify instance names one by one. For example:"
msgstr ""

#: ../doc/book/cartridge/cartridge_dev.rst:1296
msgid "$ systemctl stop APP_NAME@INSTANCE_1 APP_NAME@INSTANCE_2 ... APP_NAME@INSTANCE_<N>"
msgstr ""

#: ../doc/book/cartridge/cartridge_overview.rst:5
msgid "About Tarantool Cartridge"
msgstr ""

#: ../doc/book/cartridge/cartridge_overview.rst:7
msgid "Tarantool Cartridge is the recommended alternative to the :ref:`old-school practices <app_server-creating_app>` of application development for Tarantool."
msgstr ""

#: ../doc/book/cartridge/cartridge_overview.rst:13
msgid "As a software development kit (SDK), Tarantool Cartridge provides you with utilities and :ref:`templates <cartridge-templates>` to help:"
msgstr ""

#: ../doc/book/cartridge/cartridge_overview.rst:16
msgid "easily set up a development environment for your applications;"
msgstr ""

#: ../doc/book/cartridge/cartridge_overview.rst:17
msgid "plug the necessary Lua modules."
msgstr ""

#: ../doc/book/cartridge/cartridge_overview.rst:19
msgid "The resulting package can be installed and started on one or multiple servers as one or multiple instantiated services -- independent or organized into a **cluster**."
msgstr ""

#: ../doc/book/cartridge/cartridge_overview.rst:25
msgid "A Tarantool cluster is a collection of Tarantool instances acting in concert. While a single Tarantool instance can leverage the performance of a single server and is vulnerable to failure, the cluster spans multiple servers, utilizes their cumulative CPU power, and is fault-tolerant."
msgstr ""

#: ../doc/book/cartridge/cartridge_overview.rst:30
msgid "To fully utilize the capabilities of a Tarantool cluster, you need to develop applications keeping in mind they are to run in a cluster environment."
msgstr ""

#: ../doc/book/cartridge/cartridge_overview.rst:33
msgid "Further on, Tarantool Cartridge provides your cluster-aware applications with the following benefits:"
msgstr ""

#: ../doc/book/cartridge/cartridge_overview.rst:36
msgid "horizontal scalability and load balancing via built-in automatic sharding;"
msgstr ""

#: ../doc/book/cartridge/cartridge_overview.rst:37
msgid "asynchronous replication;"
msgstr ""

#: ../doc/book/cartridge/cartridge_overview.rst:38
msgid "automatic failover;"
msgstr ""

#: ../doc/book/cartridge/cartridge_overview.rst:39
msgid "centralized cluster control via GUI or API;"
msgstr ""

#: ../doc/book/cartridge/cartridge_overview.rst:40
msgid "automatic configuration synchronization;"
msgstr ""

#: ../doc/book/cartridge/cartridge_overview.rst:41
msgid "instance functionality segregation."
msgstr ""

#: ../doc/book/cartridge/cartridge_overview.rst:43
msgid "A Tarantool Cartridge cluster can segregate functionality between instances via built-in and custom (user-defined) :ref:`cluster roles <cartridge-roles>`. You can toggle instances on and off on the fly during cluster operation. This allows you to put different types of workloads (e.g., compute- and transaction-intensive ones) on different physical servers with dedicated hardware."
msgstr ""

#: ../doc/book/cartridge/index.rst:5
msgid "Tarantool Cartridge"
msgstr ""

#: ../doc/book/cartridge/index.rst:7
msgid "In this chapter, we explain how you can benefit with Tarantool Cartridge, a framework for developing, deploying, and managing applications based on Tarantool."
msgstr ""

#: ../doc/book/connectors/__c.rst:3
#: ../doc/book/connectors/__c.rst:3
msgid "C"
msgstr ""

#: ../doc/book/connectors/__c.rst:5
#: ../doc/book/connectors/__c.rst:5
msgid "Here follow two examples of using Tarantool's high-level C API."
msgstr ""

#: ../doc/book/connectors/__c.rst:9
#: ../doc/book/connectors/__c.rst:9
msgid "Example 1"
msgstr ""

#: ../doc/book/connectors/__c.rst:11
#: ../doc/book/connectors/__c.rst:11
msgid "Here is a complete C program that inserts :code:`[99999,'B']` into space :code:`examples` via the high-level C API."
msgstr ""

#: ../doc/book/connectors/__c.rst:14
#: ../doc/book/connectors/__c.rst:14
msgid "#include <stdio.h>\n"
"#include <stdlib.h>\n"
"\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"\n"
"void main() {\n"
"   struct tnt_stream *tnt = tnt_net(NULL);          /* See note = SETUP */\n"
"   tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"   if (tnt_connect(tnt) < 0) {                      /* See note = CONNECT */\n"
"       printf(\"Connection refused\\n\");\n"
"       exit(-1);\n"
"   }\n"
"   struct tnt_stream *tuple = tnt_object(NULL);     /* See note = MAKE REQUEST */\n"
"   tnt_object_format(tuple, \"[%d%s]\", 99999, \"B\");\n"
"   tnt_insert(tnt, 999, tuple);                     /* See note = SEND REQUEST */\n"
"   tnt_flush(tnt);\n"
"   struct tnt_reply reply;  tnt_reply_init(&reply); /* See note = GET REPLY */\n"
"   tnt->read_reply(tnt, &reply);\n"
"   if (reply.code != 0) {\n"
"       printf(\"Insert failed %lu.\\n\", reply.code);\n"
"   }\n"
"   tnt_close(tnt);                                  /* See below = TEARDOWN */\n"
"   tnt_stream_free(tuple);\n"
"   tnt_stream_free(tnt);\n"
"}"
msgstr ""

#: ../doc/book/connectors/__c.rst:44
#: ../doc/book/connectors/__c.rst:44
msgid "Paste the code into a file named :file:`example.c` and install ``tarantool-c``. One way to install ``tarantool-c`` (using Ubuntu) is:"
msgstr ""

#: ../doc/book/connectors/__c.rst:47
#: ../doc/book/connectors/__c.rst:47
msgid "$ git clone git://github.com/tarantool/tarantool-c.git ~/tarantool-c\n"
"$ cd ~/tarantool-c\n"
"$ git submodule init\n"
"$ git submodule update\n"
"$ cmake .\n"
"$ make\n"
"$ make install"
msgstr ""

#: ../doc/book/connectors/__c.rst:57
#: ../doc/book/connectors/__c.rst:282
#: ../doc/book/connectors/__c.rst:57
#: ../doc/book/connectors/__c.rst:282
msgid "To compile and link the program, say:"
msgstr ""

#: ../doc/book/connectors/__c.rst:59
#: ../doc/book/connectors/__c.rst:59
msgid "$ # sometimes this is necessary:\n"
"$ export LD_LIBRARY_PATH=/usr/local/lib\n"
"$ gcc -o example example.c -ltarantool"
msgstr ""

#: ../doc/book/connectors/__c.rst:65
#: ../doc/book/connectors/__c.rst:65
msgid "Before trying to run, check that a server instance is listening at ``localhost:3301`` and that the space ``examples`` exists, as :ref:`described earlier <index-connector_setting>`. To run the program, say :samp:`./example`. The program will connect to the Tarantool instance, and will send the request. If Tarantool is not running on localhost with listen address = 3301, the program will print “Connection refused”. If the insert fails, the program will print \"Insert failed\" and an error number (see all error codes in the source file `/src/box/errcode.h <https://github.com/tarantool/tarantool/blob/2.1/src/box/errcode.h>`_)."
msgstr ""

#: ../doc/book/connectors/__c.rst:77
#: ../doc/book/connectors/__c.rst:77
msgid "Here are notes corresponding to comments in the example program."
msgstr ""

#: ../doc/book/connectors/__c.rst:79
#: ../doc/book/connectors/__c.rst:79
msgid "**SETUP:** The setup begins by creating a stream."
msgstr ""

#: ../doc/book/connectors/__c.rst:81
#: ../doc/book/connectors/__c.rst:81
msgid "struct tnt_stream *tnt = tnt_net(NULL);\n"
"tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");"
msgstr ""

#: ../doc/book/connectors/__c.rst:86
#: ../doc/book/connectors/__c.rst:86
msgid "In this program, the stream will be named ``tnt``. Before connecting on the ``tnt`` stream, some options may have to be set. The most important option is TNT_OPT_URI. In this program, the :ref:`URI <index-uri>` is ``localhost:3301``, since that is where the Tarantool instance is supposed to be listening."
msgstr ""

#: ../doc/book/connectors/__c.rst:92
#: ../doc/book/connectors/__c.rst:107
#: ../doc/book/connectors/__c.rst:134
#: ../doc/book/connectors/__c.rst:153
#: ../doc/book/connectors/__c.rst:177
#: ../doc/book/connectors/__c.rst:195
#: ../doc/book/connectors/__c.rst:92
#: ../doc/book/connectors/__c.rst:107
#: ../doc/book/connectors/__c.rst:134
#: ../doc/book/connectors/__c.rst:153
#: ../doc/book/connectors/__c.rst:177
#: ../doc/book/connectors/__c.rst:195
msgid "Function description:"
msgstr ""

#: ../doc/book/connectors/__c.rst:94
#: ../doc/book/connectors/__c.rst:94
msgid "struct tnt_stream *tnt_net(struct tnt_stream *s)\n"
"int tnt_set(struct tnt_stream *s, int option, variant option-value)"
msgstr ""

#: ../doc/book/connectors/__c.rst:99
#: ../doc/book/connectors/__c.rst:99
msgid "**CONNECT:** Now that the stream named ``tnt`` exists and is associated with a URI, this example program can connect to a server instance."
msgstr ""

#: ../doc/book/connectors/__c.rst:102
#: ../doc/book/connectors/__c.rst:102
msgid "if (tnt_connect(tnt) < 0)\n"
"   { printf(\"Connection refused\\n\"); exit(-1); }"
msgstr ""

#: ../doc/book/connectors/__c.rst:109
#: ../doc/book/connectors/__c.rst:109
msgid "int tnt_connect(struct tnt_stream *s)"
msgstr ""

#: ../doc/book/connectors/__c.rst:113
#: ../doc/book/connectors/__c.rst:113
msgid "The connection might fail for a variety of reasons, such as: the server is not running, or the URI contains an invalid :ref:`password<authentication-passwords>`. If the connection fails, the return value will be -1."
msgstr ""

#: ../doc/book/connectors/__c.rst:117
#: ../doc/book/connectors/__c.rst:117
msgid "**MAKE REQUEST:** Most requests require passing a structured value, such as the contents of a tuple."
msgstr ""

#: ../doc/book/connectors/__c.rst:120
#: ../doc/book/connectors/__c.rst:120
msgid "struct tnt_stream *tuple = tnt_object(NULL);\n"
"tnt_object_format(tuple, \"[%d%s]\", 99999, \"B\");"
msgstr ""

#: ../doc/book/connectors/__c.rst:125
#: ../doc/book/connectors/__c.rst:125
msgid "In this program, the request will be an :ref:`INSERT<box_space-insert>`, and the tuple contents will be an integer and a string. This is a simple serial set of values, that is, there are no sub-structures or arrays. Therefore it is easy in this case to format what will be passed using the same sort of arguments that one would use with a C ``printf()`` function: ``%d`` for the integer, ``%s`` for the string, then the integer value, then a pointer to the string value."
msgstr ""

#: ../doc/book/connectors/__c.rst:136
#: ../doc/book/connectors/__c.rst:136
msgid "ssize_t tnt_object_format(struct tnt_stream *s, const char *fmt, ...)"
msgstr ""

#: ../doc/book/connectors/__c.rst:140
#: ../doc/book/connectors/__c.rst:140
msgid "**SEND REQUEST:** The database-manipulation requests are analogous to the requests in the box library."
msgstr ""

#: ../doc/book/connectors/__c.rst:143
#: ../doc/book/connectors/__c.rst:143
msgid "tnt_insert(tnt, 999, tuple);\n"
"tnt_flush(tnt);"
msgstr ""

#: ../doc/book/connectors/__c.rst:148
#: ../doc/book/connectors/__c.rst:148
msgid "In this program, the choice is to do an INSERT request, so the program passes the ``tnt_stream`` that was used for connection (``tnt``) and the ``tnt_stream`` that was set up with :c:func:`tarantoolc:tnt_object_format` (``tuple``)."
msgstr ""

#: ../doc/book/connectors/__c.rst:155
#: ../doc/book/connectors/__c.rst:155
msgid "ssize_t tnt_insert(struct tnt_stream *s, uint32_t space, struct tnt_stream *tuple)\n"
"ssize_t tnt_replace(struct tnt_stream *s, uint32_t space, struct tnt_stream *tuple)\n"
"ssize_t tnt_select(struct tnt_stream *s, uint32_t space, uint32_t index,\n"
"                   uint32_t limit, uint32_t offset, uint8_t iterator,\n"
"                   struct tnt_stream *key)\n"
"ssize_t tnt_update(struct tnt_stream *s, uint32_t space, uint32_t index,\n"
"                   struct tnt_stream *key, struct tnt_stream *ops)"
msgstr ""

#: ../doc/book/connectors/__c.rst:165
#: ../doc/book/connectors/__c.rst:165
msgid "**GET REPLY:** For most requests, the client will receive a reply containing some indication whether the result was successful, and a set of tuples."
msgstr ""

#: ../doc/book/connectors/__c.rst:168
#: ../doc/book/connectors/__c.rst:168
msgid "struct tnt_reply reply;  tnt_reply_init(&reply);\n"
"tnt->read_reply(tnt, &reply);\n"
"if (reply.code != 0)\n"
"   { printf(\"Insert failed %lu.\\n\", reply.code); }"
msgstr ""

#: ../doc/book/connectors/__c.rst:175
#: ../doc/book/connectors/__c.rst:175
msgid "This program checks for success but does not decode the rest of the reply."
msgstr ""

#: ../doc/book/connectors/__c.rst:179
#: ../doc/book/connectors/__c.rst:179
msgid "struct tnt_reply *tnt_reply_init(struct tnt_reply *r)\n"
"tnt->read_reply(struct tnt_stream *s, struct tnt_reply *r)\n"
"void tnt_reply_free(struct tnt_reply *r)"
msgstr ""

#: ../doc/book/connectors/__c.rst:185
#: ../doc/book/connectors/__c.rst:185
msgid "**TEARDOWN:** When a session ends, the connection that was made with :c:func:`tarantoolc:tnt_connect()` should be closed, and the objects that were made in the setup should be destroyed."
msgstr ""

#: ../doc/book/connectors/__c.rst:189
#: ../doc/book/connectors/__c.rst:189
msgid "tnt_close(tnt);\n"
"tnt_stream_free(tuple);\n"
"tnt_stream_free(tnt);"
msgstr ""

#: ../doc/book/connectors/__c.rst:197
#: ../doc/book/connectors/__c.rst:197
msgid "void tnt_close(struct tnt_stream *s)\n"
"void tnt_stream_free(struct tnt_stream *s)"
msgstr ""

#: ../doc/book/connectors/__c.rst:204
#: ../doc/book/connectors/__c.rst:204
msgid "Example 2"
msgstr ""

#: ../doc/book/connectors/__c.rst:206
#: ../doc/book/connectors/__c.rst:206
msgid "Here is a complete C program that selects, using index key ``[99999]``, from space ``examples`` via the high-level C API. To display the results, the program uses functions in the `MsgPuck <http://rtsisyk.github.io/msgpuck/>`_ library which allow decoding of `MessagePack <https://en.wikipedia.org/wiki/MessagePack>`_  arrays."
msgstr ""

#: ../doc/book/connectors/__c.rst:212
#: ../doc/book/connectors/__c.rst:212
msgid "#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"\n"
"#define MP_SOURCE 1\n"
"#include <msgpuck.h>\n"
"\n"
"void main() {\n"
"    struct tnt_stream *tnt = tnt_net(NULL);\n"
"    tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"    if (tnt_connect(tnt) < 0) {\n"
"        printf(\"Connection refused\\n\");\n"
"        exit(1);\n"
"    }\n"
"    struct tnt_stream *tuple = tnt_object(NULL);\n"
"    tnt_object_format(tuple, \"[%d]\", 99999); /* tuple = search key */\n"
"    tnt_select(tnt, 999, 0, (2^32) - 1, 0, 0, tuple);\n"
"    tnt_flush(tnt);\n"
"    struct tnt_reply reply; tnt_reply_init(&reply);\n"
"    tnt->read_reply(tnt, &reply);\n"
"    if (reply.code != 0) {\n"
"        printf(\"Select failed.\\n\");\n"
"        exit(1);\n"
"    }\n"
"    char field_type;\n"
"    field_type = mp_typeof(*reply.data);\n"
"    if (field_type != MP_ARRAY) {\n"
"        printf(\"no tuple array\\n\");\n"
"        exit(1);\n"
"    }\n"
"    long unsigned int row_count;\n"
"    uint32_t tuple_count = mp_decode_array(&reply.data);\n"
"    printf(\"tuple count=%u\\n\", tuple_count);\n"
"    unsigned int i, j;\n"
"    for (i = 0; i < tuple_count; ++i) {\n"
"        field_type = mp_typeof(*reply.data);\n"
"        if (field_type != MP_ARRAY) {\n"
"            printf(\"no field array\\n\");\n"
"            exit(1);\n"
"        }\n"
"        uint32_t field_count = mp_decode_array(&reply.data);\n"
"        printf(\"  field count=%u\\n\", field_count);\n"
"        for (j = 0; j < field_count; ++j) {\n"
"            field_type = mp_typeof(*reply.data);\n"
"            if (field_type == MP_UINT) {\n"
"                uint64_t num_value = mp_decode_uint(&reply.data);\n"
"                printf(\"    value=%lu.\\n\", num_value);\n"
"            } else if (field_type == MP_STR) {\n"
"                const char *str_value;\n"
"                uint32_t str_value_length;\n"
"                str_value = mp_decode_str(&reply.data, &str_value_length);\n"
"                printf(\"    value=%.*s.\\n\", str_value_length, str_value);\n"
"            } else {\n"
"                printf(\"wrong field type\\n\");\n"
"                exit(1);\n"
"            }\n"
"        }\n"
"    }\n"
"    tnt_close(tnt);\n"
"    tnt_stream_free(tuple);\n"
"    tnt_stream_free(tnt);\n"
"}"
msgstr ""

#: ../doc/book/connectors/__c.rst:279
#: ../doc/book/connectors/__c.rst:279
msgid "Similarly to the first example, paste the code into a file named :file:`example2.c`."
msgstr ""

#: ../doc/book/connectors/__c.rst:284
#: ../doc/book/connectors/__c.rst:284
msgid "$ gcc -o example2 example2.c -ltarantool"
msgstr ""

#: ../doc/book/connectors/__c.rst:288
#: ../doc/book/connectors/__c.rst:288
msgid "To run the program, say :samp:`./example2`."
msgstr ""

#: ../doc/book/connectors/__c.rst:290
#: ../doc/book/connectors/__c.rst:290
msgid "The two example programs only show a few requests and do not show all that's necessary for good practice. See more in the `tarantool-c documentation at GitHub <http://github.com/tarantool/tarantool-c>`_."
msgstr ""

#: ../doc/book/connectors/__csharp.rst:3
#: ../doc/book/connectors/__csharp.rst:3
msgid "C#"
msgstr ""

#: ../doc/book/connectors/__csharp.rst:5
#: ../doc/book/connectors/__csharp.rst:5
msgid "The most commonly used C# driver is `progaudi.tarantool <https://github.com/progaudi/progaudi.tarantool>`_, previously named ``tarantool-csharp``. It is not supplied as part of the Tarantool repository; it must be installed separately. The makers recommend `cross-platform installation using Nuget <https://www.nuget.org/packages/progaudi.tarantool>`_."
msgstr ""

#: ../doc/book/connectors/__csharp.rst:11
#: ../doc/book/connectors/__csharp.rst:11
msgid "To be consistent with the other instructions in this chapter, here is a way to install the driver directly on Ubuntu 16.04."
msgstr ""

#: ../doc/book/connectors/__csharp.rst:14
#: ../doc/book/connectors/__csharp.rst:14
msgid "Install .net core from Microsoft. Follow `.net core installation instructions <https://www.microsoft.com/net/core#ubuntu>`_."
msgstr ""

#: ../doc/book/connectors/__csharp.rst:19
#: ../doc/book/connectors/__csharp.rst:19
msgid "Mono will not work, nor will .Net from xbuild. Only .net core supported on Linux and Mac."
msgstr ""

#: ../doc/book/connectors/__csharp.rst:21
#: ../doc/book/connectors/__csharp.rst:21
msgid "Read the Microsoft End User License Agreement first, because it is not an ordinary open-source agreement and there will be a message during installation saying \"This software may collect information about you and your use of the software, and send that to Microsoft.\" Still you can `set environment variables <https://docs.microsoft.com/en-us/dotnet/core/tools/telemetry#behavior>`_ to opt out from telemetry."
msgstr ""

#: ../doc/book/connectors/__csharp.rst:29
#: ../doc/book/connectors/__csharp.rst:29
msgid "Create a new console project."
msgstr ""

#: ../doc/book/connectors/__csharp.rst:31
#: ../doc/book/connectors/__csharp.rst:31
msgid "$ cd ~\n"
"$ mkdir progaudi.tarantool.test\n"
"$ cd progaudi.tarantool.test\n"
"$ dotnet new console"
msgstr ""

#: ../doc/book/connectors/__csharp.rst:38
#: ../doc/book/connectors/__csharp.rst:38
msgid "Add ``progaudi.tarantool`` reference."
msgstr ""

#: ../doc/book/connectors/__csharp.rst:40
#: ../doc/book/connectors/__csharp.rst:40
msgid "$ dotnet add package progaudi.tarantool"
msgstr ""

#: ../doc/book/connectors/__csharp.rst:44
#: ../doc/book/connectors/__csharp.rst:44
msgid "Change code in ``Program.cs``."
msgstr ""

#: ../doc/book/connectors/__csharp.rst:46
#: ../doc/book/connectors/__csharp.rst:46
msgid "$ cat <<EOT > Program.cs\n"
"using System;\n"
"using System.Threading.Tasks;\n"
"using ProGaudi.Tarantool.Client;\n"
"\n"
"public class HelloWorld\n"
"{\n"
"  static public void Main ()\n"
"  {\n"
"    Test().GetAwaiter().GetResult();\n"
"  }\n"
"  static async Task Test()\n"
"  {\n"
"    var box = await Box.Connect(\"127.0.0.1:3301\");\n"
"    var schema = box.GetSchema();\n"
"    var space = await schema.GetSpace(\"examples\");\n"
"    await space.Insert((99999, \"BB\"));\n"
"  }\n"
"}\n"
"EOT"
msgstr ""

#: ../doc/book/connectors/__csharp.rst:69
#: ../doc/book/connectors/__csharp.rst:69
msgid "Build and run your application."
msgstr ""

#: ../doc/book/connectors/__csharp.rst:71
#: ../doc/book/connectors/__csharp.rst:71
msgid "Before trying to run, check that the server is listening at ``localhost:3301`` and that the space ``examples`` exists, as :ref:`described earlier <index-connector_setting>`."
msgstr ""

#: ../doc/book/connectors/__csharp.rst:75
#: ../doc/book/connectors/__csharp.rst:75
msgid "$ dotnet restore\n"
"$ dotnet run"
msgstr ""

#: ../doc/book/connectors/__csharp.rst:80
#: ../doc/book/connectors/__csharp.rst:80
msgid "The program will:"
msgstr ""

#: ../doc/book/connectors/__csharp.rst:82
#: ../doc/book/connectors/__csharp.rst:82
msgid "connect using an application-specific definition of the space,"
msgstr ""

#: ../doc/book/connectors/__csharp.rst:83
#: ../doc/book/connectors/__csharp.rst:83
msgid "open a socket connection with the Tarantool server at `localhost:3301`,"
msgstr ""

#: ../doc/book/connectors/__csharp.rst:84
#: ../doc/book/connectors/__csharp.rst:84
msgid "send an INSERT request, and — if all is well — end without saying anything."
msgstr ""

#: ../doc/book/connectors/__csharp.rst:86
#: ../doc/book/connectors/__csharp.rst:86
msgid "If Tarantool is not running on localhost with listen port = 3301, or if user 'guest' does not have authorization to connect, or if the INSERT request fails for any reason, the program will print an error message, among other things (stacktrace, etc)."
msgstr ""

#: ../doc/book/connectors/__csharp.rst:91
#: ../doc/book/connectors/__csharp.rst:91
msgid "The example program only shows one request and does not show all that’s necessary for good practice. For that, please see the `progaudi.tarantool driver repository <https://github.com/progaudi/progaudi.tarantool>`_."
msgstr ""

#: ../doc/book/connectors/__erlang.rst:3
#: ../doc/book/connectors/__erlang.rst:3
msgid "Erlang"
msgstr ""

#: ../doc/book/connectors/__erlang.rst:5
#: ../doc/book/connectors/__erlang.rst:5
msgid "See `Erlang tarantool driver <https://github.com/stofel/taran>`_."
msgstr ""

#: ../doc/book/connectors/__go.rst:3
#: ../doc/book/connectors/__go.rst:3
msgid "Go"
msgstr ""

#: ../doc/book/connectors/__go.rst:5
#: ../doc/book/connectors/__go.rst:5
msgid "Please see https://github.com/mialinx/go-tarantool."
msgstr ""

#: ../doc/book/connectors/__java.rst:3
#: ../doc/book/connectors/__java.rst:3
msgid "Java"
msgstr ""

#: ../doc/book/connectors/__java.rst:5
#: ../doc/book/connectors/__java.rst:5
msgid "See http://github.com/tarantool/tarantool-java/."
msgstr ""

#: ../doc/book/connectors/__nodejs.rst:3
#: ../doc/book/connectors/__nodejs.rst:3
msgid "Node.js"
msgstr ""

#: ../doc/book/connectors/__nodejs.rst:5
#: ../doc/book/connectors/__nodejs.rst:5
msgid "The most commonly used node.js driver is the `Node Tarantool driver <https://github.com/KlonD90/node-tarantool-driver>`_. It is not supplied as part of the Tarantool repository; it must be installed separately. The most common way to install it is with `npm <https://www.sitepoint.com/beginners-guide-node-package-manager/>`_. For example, on Ubuntu, the installation could look like this after npm has been installed:"
msgstr ""

#: ../doc/book/connectors/__nodejs.rst:13
#: ../doc/book/connectors/__nodejs.rst:13
msgid "$ npm install tarantool-driver --global"
msgstr ""

#: ../doc/book/connectors/__nodejs.rst:17
#: ../doc/book/connectors/__nodejs.rst:17
msgid "Here is a complete node.js program that inserts ``[99999,'BB']`` into ``space[999]`` via the node.js API. Before trying to run, check that the server instance is :ref:`listening <cfg_basic-listen>` at ``localhost:3301`` and that the space ``examples`` exists, as :ref:`described earlier <index-connector_setting>`. To run, paste the code into a file named :file:`example.rs` and say ``node example.rs``. The program will connect using an application-specific definition of the space. The program will open a socket connection with the Tarantool instance at ``localhost:3301``, then send an :ref:`INSERT <box_space-insert>` request, then — if all is well — end after saying \"Insert succeeded\". If Tarantool is not running on ``localhost`` with listen port = 3301, the program will print “Connect failed”. If :ref:`the 'guest' user <box_space-user>` does not have authorization to connect, the program will print \"Auth failed\". If the insert request fails for any reason, for example because the tuple already exists, the program will print \"Insert failed\"."
msgstr ""

#: ../doc/book/connectors/__nodejs.rst:31
#: ../doc/book/connectors/__nodejs.rst:31
msgid "var TarantoolConnection = require('tarantool-driver');\n"
"var conn = new TarantoolConnection({port: 3301});\n"
"var insertTuple = [99999, \"BB\"];\n"
"conn.connect().then(function() {\n"
"    conn.auth(\"guest\", \"\").then(function() {\n"
"        conn.insert(999, insertTuple).then(function() {\n"
"            console.log(\"Insert succeeded\");\n"
"            process.exit(0);\n"
"    }, function(e) { console.log(\"Insert failed\");  process.exit(1); });\n"
"    }, function(e) { console.log(\"Auth failed\");    process.exit(1); });\n"
"    }, function(e) { console.log(\"Connect failed\"); process.exit(1); });"
msgstr ""

#: ../doc/book/connectors/__nodejs.rst:45
#: ../doc/book/connectors/__nodejs.rst:45
msgid "The example program only shows one request and does not show all that's necessary for good practice. For that, please see  `The node.js driver repository <https://github.com/KlonD90/node-tarantool-driver>`_."
msgstr ""

#: ../doc/book/connectors/__perl.rst:3
#: ../doc/book/connectors/__perl.rst:3
msgid "Perl"
msgstr ""

#: ../doc/book/connectors/__perl.rst:5
#: ../doc/book/connectors/__perl.rst:5
msgid "The most commonly used Perl driver is `tarantool-perl <https://github.com/tarantool/tarantool-perl>`_. It is not supplied as part of the Tarantool repository; it must be installed separately. The most common way to install it is by cloning from GitHub."
msgstr ""

#: ../doc/book/connectors/__perl.rst:10
#: ../doc/book/connectors/__perl.rst:10
msgid "To avoid minor warnings that may appear the first time ``tarantool-perl`` is installed, start with installing some other modules that ``tarantool-perl`` uses, with `CPAN, the Comprehensive Perl Archive Network <https://en.wikipedia.org/wiki/Cpan>`_:"
msgstr ""

#: ../doc/book/connectors/__perl.rst:14
#: ../doc/book/connectors/__perl.rst:14
msgid "$ sudo cpan install AnyEvent\n"
"$ sudo cpan install Devel::GlobalDestruction"
msgstr ""

#: ../doc/book/connectors/__perl.rst:19
#: ../doc/book/connectors/__perl.rst:19
msgid "Then, to install ``tarantool-perl`` itself, say:"
msgstr ""

#: ../doc/book/connectors/__perl.rst:21
#: ../doc/book/connectors/__perl.rst:21
msgid "$ git clone https://github.com/tarantool/tarantool-perl.git tarantool-perl\n"
"$ cd tarantool-perl\n"
"$ git submodule init\n"
"$ git submodule update --recursive\n"
"$ perl Makefile.PL\n"
"$ make\n"
"$ sudo make install"
msgstr ""

#: ../doc/book/connectors/__perl.rst:31
#: ../doc/book/connectors/__perl.rst:31
msgid "Here is a complete Perl program that inserts ``[99999,'BB']`` into ``space[999]`` via the Perl API. Before trying to run, check that the server instance is listening at ``localhost:3301`` and that the space ``examples`` exists, as :ref:`described earlier <index-connector_setting>`. To run, paste the code into a file named :file:`example.pl` and say :samp:`perl example.pl`. The program will connect using an application-specific definition of the space. The program will open a socket connection with the Tarantool instance at ``localhost:3301``, then send an :ref:`space_object:INSERT<box_space-insert>` request, then — if all is well — end without displaying any messages. If Tarantool is not running on ``localhost`` with :ref:`listen<cfg_basic-listen>` port = 3301, the program will print “Connection refused”."
msgstr ""

#: ../doc/book/connectors/__perl.rst:43
#: ../doc/book/connectors/__perl.rst:43
msgid "#!/usr/bin/perl\n"
"use DR::Tarantool ':constant', 'tarantool';\n"
"use DR::Tarantool ':all';\n"
"use DR::Tarantool::MsgPack::SyncClient;\n"
"\n"
"my $tnt = DR::Tarantool::MsgPack::SyncClient->connect(\n"
"  host    => '127.0.0.1',                      # look for tarantool on localhost\n"
"  port    => 3301,                             # on port 3301\n"
"  user    => 'guest',                          # username. for 'guest' we do not also say 'password=>...'\n"
"\n"
"  spaces  => {\n"
"    999 => {                                   # definition of space[999] ...\n"
"      name => 'examples',                      #   space[999] name = 'examples'\n"
"      default_type => 'STR',                   #   space[999] field type is 'STR' if undefined\n"
"      fields => [ {                            #   definition of space[999].fields ...\n"
"          name => 'field1', type => 'NUM' } ], #     space[999].field[1] name='field1',type='NUM'\n"
"      indexes => {                             #   definition of space[999] indexes ...\n"
"        0 => {\n"
"          name => 'primary', fields => [ 'field1' ] } } } } );\n"
"\n"
"$tnt->insert('examples' => [ 99999, 'BB' ]);"
msgstr ""

#: ../doc/book/connectors/__perl.rst:67
#: ../doc/book/connectors/__perl.rst:67
msgid "The example program uses field type names 'STR' and 'NUM' instead of :ref:`'string' and 'unsigned'<box_space-create_index>`, due to a temporary Perl limitation."
msgstr ""

#: ../doc/book/connectors/__perl.rst:70
#: ../doc/book/connectors/__perl.rst:70
msgid "The example program only shows one request and does not show all that's necessary for good practice. For that, please see the `tarantool-perl repository <https://github.com/tarantool/tarantool-perl>`_."
msgstr ""

#: ../doc/book/connectors/__php.rst:3
#: ../doc/book/connectors/__php.rst:3
msgid "PHP"
msgstr ""

#: ../doc/book/connectors/__php.rst:5
#: ../doc/book/connectors/__php.rst:5
msgid "`tarantool-php <https://github.com/tarantool/tarantool-php>`_ is the official PHP connector for Tarantool. It is not supplied as part of the Tarantool repository and must be installed separately (see `installation instructions <https://github.com/tarantool/tarantool-php/#installing-and-building>`_ in the connector's ``README`` file)."
msgstr ""

#: ../doc/book/connectors/__php.rst:12
#: ../doc/book/connectors/__php.rst:12
msgid "Here is a complete PHP program that inserts ``[99999,'BB']`` into a space named ``examples`` via the PHP API."
msgstr ""

#: ../doc/book/connectors/__php.rst:15
#: ../doc/book/connectors/__php.rst:15
msgid "Before trying to run, check that the server instance is :ref:`listening <cfg_basic-listen>` at ``localhost:3301`` and that the space ``examples`` exists, as :ref:`described earlier <index-connector_setting>`."
msgstr ""

#: ../doc/book/connectors/__php.rst:19
#: ../doc/book/connectors/__php.rst:19
msgid "To run, paste the code into a file named :file:`example.php` and say:"
msgstr ""

#: ../doc/book/connectors/__php.rst:21
#: ../doc/book/connectors/__php.rst:21
msgid "$ php -d extension=~/tarantool-php/modules/tarantool.so example.php"
msgstr ""

#: ../doc/book/connectors/__php.rst:25
#: ../doc/book/connectors/__php.rst:25
msgid "The program will open a socket connection with the Tarantool instance at ``localhost:3301``, then send an :ref:`INSERT <box_space-insert>` request, then -- if all is well -- print \"Insert succeeded\"."
msgstr ""

#: ../doc/book/connectors/__php.rst:29
#: ../doc/book/connectors/__php.rst:29
msgid "If the tuple already exists, the program will print \"Duplicate key exists in unique index 'primary' in space 'examples'\"."
msgstr ""

#: ../doc/book/connectors/__php.rst:32
#: ../doc/book/connectors/__php.rst:32
msgid "<?php\n"
"$tarantool = new Tarantool('localhost', 3301);\n"
"\n"
"try {\n"
"    $tarantool->insert('examples', [99999, 'BB']);\n"
"    echo \"Insert succeeded\\n\";\n"
"} catch (Exception $e) {\n"
"    echo $e->getMessage(), \"\\n\";\n"
"}"
msgstr ""

#: ../doc/book/connectors/__php.rst:44
#: ../doc/book/connectors/__php.rst:44
msgid "The example program only shows one request and does not show all that's necessary for good practice. For that, please see `tarantool/tarantool-php <https://github.com/tarantool/tarantool-php>`_ project at GitHub."
msgstr ""

#: ../doc/book/connectors/__php.rst:49
#: ../doc/book/connectors/__php.rst:49
msgid "Besides, there is another community-driven `GitHub project <https://github.com/tarantool-php>`_ which includes an `alternative connector <https://github.com/tarantool-php/client>`_ written in pure PHP, an `object mapper <https://github.com/tarantool-php/mapper>`_, a `queue <https://github.com/tarantool-php/queue>`_ and other packages."
msgstr ""

#: ../doc/book/connectors/__python.rst:3
#: ../doc/book/connectors/__python.rst:3
msgid "Python"
msgstr ""

#: ../doc/book/connectors/__python.rst:5
#: ../doc/book/connectors/__python.rst:5
msgid "`tarantool-python <http://github.com/tarantool/tarantool-python>`_ is the official Python connector for Tarantool. It is not supplied as part of the Tarantool repository and must be installed separately (see below for details)."
msgstr ""

#: ../doc/book/connectors/__python.rst:9
#: ../doc/book/connectors/__python.rst:9
msgid "Here is a complete Python program that inserts ``[99999,'Value','Value']`` into space ``examples`` via the high-level Python API."
msgstr ""

#: ../doc/book/connectors/__python.rst:12
#: ../doc/book/connectors/__python.rst:12
msgid "#!/usr/bin/python\n"
"from tarantool import Connection\n"
"\n"
"c = Connection(\"127.0.0.1\", 3301)\n"
"result = c.insert(\"examples\",(99999,'Value', 'Value'))\n"
"print result"
msgstr ""

#: ../doc/book/connectors/__python.rst:21
#: ../doc/book/connectors/__python.rst:21
msgid "To prepare, paste the code into a file named :file:`example.py` and install the ``tarantool-python`` connector with either :samp:`pip install tarantool\\>0.4` to install in :file:`/usr` (requires **root** privilege) or :samp:`pip install tarantool\\>0.4 --user` to install in :file:`~` i.e. user's default directory."
msgstr ""

#: ../doc/book/connectors/__python.rst:27
#: ../doc/book/connectors/__python.rst:27
msgid "Before trying to run, check that the server instance is :ref:`listening <cfg_basic-listen>` at ``localhost:3301`` and that the space ``examples`` exists, as :ref:`described earlier <index-connector_setting>`. To run the program, say :samp:`python example.py`. The program will connect to the Tarantool server, will send the :ref:`INSERT<box_space-insert>` request, and will not throw any exception if all went well. If the tuple already exists, the program will throw ``tarantool.error.DatabaseError: (3, \"Duplicate key exists in unique index 'primary' in space 'examples'\")``."
msgstr ""

#: ../doc/book/connectors/__python.rst:35
#: ../doc/book/connectors/__python.rst:35
msgid "The example program only shows one request and does not show all that's necessary for good practice. For that, please see `tarantool-python <http://github.com/tarantool/tarantool-python>`_ project at GitHub. For an example of using Python API with `queue managers for Tarantool <https://github.com/tarantool/queue>`_, see `queue-python <https://github.com/tarantool/queue-python>`_ project at GitHub."
msgstr ""

#: ../doc/book/connectors/__python.rst:42
#: ../doc/book/connectors/__python.rst:42
msgid "Also there are several community-driven Python connectors:"
msgstr ""

#: ../doc/book/connectors/__python.rst:44
#: ../doc/book/connectors/__python.rst:44
msgid "`asynctnt <https://github.com/igorcoding/asynctnt>`_ with asyncio support"
msgstr ""

#: ../doc/book/connectors/__python.rst:45
#: ../doc/book/connectors/__python.rst:45
msgid "`aiotarantool <https://github.com/shveenkov/aiotarantool>`_ also with asyncio support"
msgstr ""

#: ../doc/book/connectors/__python.rst:46
#: ../doc/book/connectors/__python.rst:46
msgid "`gtarantool <https://github.com/shveenkov/gtarantool>`_ with gevent support **no active maintenance**"
msgstr ""

#: ../doc/book/connectors/__r.rst:3
#: ../doc/book/connectors/__r.rst:3
msgid "R"
msgstr ""

#: ../doc/book/connectors/__r.rst:5
#: ../doc/book/connectors/__r.rst:5
msgid "See https://github.com/thekvs/tarantoolr."
msgstr ""

#: ../doc/book/connectors/__results.rst:4
#: ../doc/book/connectors/__results.rst:4
msgid "Interpreting function return values"
msgstr ""

#: ../doc/book/connectors/__results.rst:6
#: ../doc/book/connectors/__results.rst:6
msgid "For all connectors, calling a function via Tarantool causes a return in the MsgPack format. If the function is called using the connector's API, some conversions may occur. All scalar values are returned as tuples (with a MsgPack type-identifier followed by a value); all non-scalar values are returned as a group of tuples (with a MsgPack array-identifier followed by the scalar values). If the function is called via the binary protocol command layer -- \"eval\" -- rather than via the connector's API, no conversions occur."
msgstr ""

#: ../doc/book/connectors/__results.rst:14
#: ../doc/book/connectors/__results.rst:14
msgid "In the following example, a Lua function will be created. Since it will be accessed externally by a :ref:`'guest' user<box_space-user>`, a :ref:`grant <box_schema-user_grant>` of an execute privilege will be necessary. The function returns an empty array, a scalar string, two booleans, and a short integer. The values are the ones described in the table :ref:`Common Types and MsgPack Encodings <msgpack-common_types_and_msgpack_encodings>`."
msgstr ""

#: ../doc/book/connectors/__results.rst:21
#: ../doc/book/connectors/__results.rst:21
msgid "tarantool> box.cfg{listen=3301}\n"
"2016-03-03 18:45:52.802 [27381] main/101/interactive I> ready to accept requests\n"
"---\n"
"...\n"
"tarantool> function f() return {},'a',false,true,127; end\n"
"---\n"
"...\n"
"tarantool> box.schema.func.create('f')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('guest','execute','function','f')\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/connectors/__results.rst:37
#: ../doc/book/connectors/__results.rst:37
msgid "Here is a C program which calls the function. Although C is being used for the example, the result would be precisely the same if the calling program was written in Perl, PHP, Python, Go, or Java."
msgstr ""

#: ../doc/book/connectors/__results.rst:41
#: ../doc/book/connectors/__results.rst:41
msgid "#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"void main() {\n"
"  struct tnt_stream *tnt = tnt_net(NULL);              /* SETUP */\n"
"  tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"   if (tnt_connect(tnt) < 0) {                         /* CONNECT */\n"
"       printf(\"Connection refused\\n\");\n"
"       exit(-1);\n"
"   }\n"
"   struct tnt_stream *arg; arg = tnt_object(NULL);     /* MAKE REQUEST */\n"
"   tnt_object_add_array(arg, 0);\n"
"   struct tnt_request *req1 = tnt_request_call(NULL);  /* CALL function f() */\n"
"   tnt_request_set_funcz(req1, \"f\");\n"
"   uint64_t sync1 = tnt_request_compile(tnt, req1);\n"
"   tnt_flush(tnt);                                     /* SEND REQUEST */\n"
"   struct tnt_reply reply;  tnt_reply_init(&reply);    /* GET REPLY */\n"
"   tnt->read_reply(tnt, &reply);\n"
"   if (reply.code != 0) {\n"
"     printf(\"Call failed %lu.\\n\", reply.code);\n"
"     exit(-1);\n"
"   }\n"
"   const unsigned char *p= (unsigned char*)reply.data; /* PRINT REPLY */\n"
"   while (p < (unsigned char *) reply.data_end)\n"
"   {\n"
"     printf(\"%x \", *p);\n"
"     ++p;\n"
"   }\n"
"   printf(\"\\n\");\n"
"   tnt_close(tnt);                                     /* TEARDOWN */\n"
"   tnt_stream_free(arg);\n"
"   tnt_stream_free(tnt);\n"
"}"
msgstr ""

#: ../doc/book/connectors/__results.rst:79
#: ../doc/book/connectors/__results.rst:79
msgid "When this program is executed, it will print:"
msgstr ""

#: ../doc/book/connectors/__results.rst:81
#: ../doc/book/connectors/__results.rst:81
msgid "dd 0 0 0 5 90 91 a1 61 91 c2 91 c3 91 7f"
msgstr ""

#: ../doc/book/connectors/__results.rst:85
#: ../doc/book/connectors/__results.rst:85
msgid "The first five bytes -- ``dd 0 0 0 5`` -- are the MsgPack encoding for \"32-bit array header with value 5\" (see `MsgPack specification <http://github.com/msgpack/msgpack/blob/master/spec.md>`_). The rest are as described in the table :ref:`Common Types and MsgPack Encodings <msgpack-common_types_and_msgpack_encodings>`."
msgstr ""

#: ../doc/book/connectors/index.rst:5
msgid "Connectors"
msgstr ""

#: ../doc/book/connectors/index.rst:7
msgid "This chapter documents APIs for various programming languages."
msgstr ""

#: ../doc/book/connectors/index.rst:11
msgid "Protocol"
msgstr ""

#: ../doc/book/connectors/index.rst:13
msgid "Tarantool's binary protocol was designed with a focus on asynchronous I/O and easy integration with proxies. Each client request starts with a variable-length binary header, containing request id, request type, instance id, log sequence number, and so on."
msgstr ""

#: ../doc/book/connectors/index.rst:18
msgid "The mandatory length, present in request header simplifies client or proxy I/O. A response to a request is sent to the client as soon as it is ready. It always carries in its header the same type and id as in the request. The id makes it possible to match a request to a response, even if the latter arrived out of order."
msgstr ""

#: ../doc/book/connectors/index.rst:24
msgid "Unless implementing a client driver, you needn't concern yourself with the complications of the binary protocol. Language-specific drivers provide a friendly way to store domain language data structures in Tarantool. A complete description of the binary protocol is maintained in annotated Backus-Naur form in the source tree: please see the page about :ref:`Tarantool's binary protocol <box_protocol-iproto_protocol>`."
msgstr ""

#: ../doc/book/connectors/index.rst:33
msgid "Packet example"
msgstr ""

#: ../doc/book/connectors/index.rst:35
msgid "The Tarantool API exists so that a client program can send a request packet to a server instance, and receive a response. Here is an example of a what the client would send for ``box.space[513]:insert{'A', 'BB'}``. The BNF description of the components is on the page about :ref:`Tarantool's binary protocol <box_protocol-iproto_protocol>`."
msgstr ""

#: ../doc/book/connectors/index.rst:51
msgid "Component"
msgstr ""

#: ../doc/book/connectors/index.rst:51
msgid "Byte #0"
msgstr ""

#: ../doc/book/connectors/index.rst:51
msgid "Byte #1"
msgstr ""

#: ../doc/book/connectors/index.rst:51
msgid "Byte #2"
msgstr ""

#: ../doc/book/connectors/index.rst:51
msgid "Byte #3"
msgstr ""

#: ../doc/book/connectors/index.rst:53
msgid "code for insert"
msgstr ""

#: ../doc/book/connectors/index.rst:53
#: ../doc/book/connectors/index.rst:57
msgid "02"
msgstr ""

#: ../doc/book/connectors/index.rst:55
msgid "rest of header"
msgstr ""

#: ../doc/book/connectors/index.rst:55
#: ../doc/book/connectors/index.rst:55
#: ../doc/book/connectors/index.rst:55
#: ../doc/book/connectors/index.rst:55
msgid "..."
msgstr ""

#: ../doc/book/connectors/index.rst:57
msgid "2-digit number: space id"
msgstr ""

#: ../doc/book/connectors/index.rst:57
msgid "cd"
msgstr ""

#: ../doc/book/connectors/index.rst:57
msgid "01"
msgstr ""

#: ../doc/book/connectors/index.rst:59
msgid "code for tuple"
msgstr ""

#: ../doc/book/connectors/index.rst:59
msgid "21"
msgstr ""

#: ../doc/book/connectors/index.rst:61
msgid "1-digit number: field count = 2"
msgstr ""

#: ../doc/book/connectors/index.rst:61
msgid "92"
msgstr ""

#: ../doc/book/connectors/index.rst:63
msgid "1-character string: field[1]"
msgstr ""

#: ../doc/book/connectors/index.rst:63
msgid "a1"
msgstr ""

#: ../doc/book/connectors/index.rst:63
msgid "41"
msgstr ""

#: ../doc/book/connectors/index.rst:65
msgid "2-character string: field[2]"
msgstr ""

#: ../doc/book/connectors/index.rst:65
msgid "a2"
msgstr ""

#: ../doc/book/connectors/index.rst:65
#: ../doc/book/connectors/index.rst:65
msgid "42"
msgstr ""

#: ../doc/book/connectors/index.rst:68
msgid "Now, you could send that packet to the Tarantool instance, and interpret the response (the page about :ref:`Tarantool's binary protocol <box_protocol-iproto_protocol>` has a description of the packet format for responses as well as requests). But it would be easier, and less error-prone, if you could invoke a routine that formats the packet according to typed parameters. Something like ``response = tarantool_routine(\"insert\", 513, \"A\", \"B\");``. And that is why APIs exist for drivers for Perl, Python, PHP, and so on."
msgstr ""

#: ../doc/book/connectors/index.rst:81
msgid "Setting up the server for connector examples"
msgstr ""

#: ../doc/book/connectors/index.rst:83
msgid "This chapter has examples that show how to connect to a Tarantool instance via the Perl, PHP, Python, node.js, and C connectors. The examples contain hard code that will work if and only if the following conditions are met:"
msgstr ""

#: ../doc/book/connectors/index.rst:87
msgid "the Tarantool instance (tarantool) is running on localhost (127.0.0.1) and is listening on port 3301 (``box.cfg.listen = '3301'``),"
msgstr ""

#: ../doc/book/connectors/index.rst:90
msgid "space ``examples`` has id = 999 (``box.space.examples.id = 999``) and has a primary-key index for a numeric field (``box.space[999].index[0].parts[1].type = \"unsigned\"``),"
msgstr ""

#: ../doc/book/connectors/index.rst:94
msgid "user 'guest' has privileges for reading and writing."
msgstr ""

#: ../doc/book/connectors/index.rst:96
msgid "It is easy to meet all the conditions by starting the instance and executing this script:"
msgstr ""

#: ../doc/book/connectors/index.rst:99
msgid "box.cfg{listen=3301}\n"
"box.schema.space.create('examples',{id=999})\n"
"box.space.examples:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
"box.schema.user.grant('guest','read,write','space','examples')\n"
"box.schema.user.grant('guest','read','space','_space')"
msgstr ""

#: ../doc/book/faq.rst:5
msgid "FAQ"
msgstr ""

#: ../doc/book/faq.rst:0
#: ../doc/book/faq.rst:0
#: ../doc/book/faq.rst:0
#: ../doc/book/faq.rst:0
#: ../doc/book/faq.rst:0
#: ../doc/book/faq.rst:0
#: ../doc/book/faq.rst:0
msgid "Q"
msgstr ""

#: ../doc/book/faq.rst:9
msgid "Why Tarantool?"
msgstr ""

#: ../doc/book/faq.rst:0
#: ../doc/book/faq.rst:0
#: ../doc/book/faq.rst:0
#: ../doc/book/faq.rst:0
#: ../doc/book/faq.rst:0
#: ../doc/book/faq.rst:0
#: ../doc/book/faq.rst:0
msgid "A"
msgstr ""

#: ../doc/book/faq.rst:10
msgid "Tarantool is the latest generation of a family of in-memory data servers developed for web applications. It is the result of practical experience and trials within Mail.Ru since development began in 2008."
msgstr ""

#: ../doc/book/faq.rst:14
msgid "Why Lua?"
msgstr ""

#: ../doc/book/faq.rst:15
msgid "Lua is a lightweight, fast, extensible multi-paradigm language. Lua also happens to be very easy to embed. Lua coroutines relate very closely to Tarantool fibers, and Lua architecture works well with Tarantool internals. Lua acts well as a stored program language for Tarantool, although connecting with other languages is also easy."
msgstr ""

#: ../doc/book/faq.rst:21
msgid "What's the key advantage of Tarantool?"
msgstr ""

#: ../doc/book/faq.rst:0
msgid "Tarantool provides a rich database feature set (HASH, TREE, RTREE, BITSET indexes, secondary indexes, composite indexes, transactions, triggers, asynchronous replication) in a flexible environment of a Lua interpreter."
msgstr ""

#: ../doc/book/faq.rst:0
msgid "These two properties make it possible to be a fast, atomic and reliable in-memory data server which handles non-trivial application-specific logic. The advantage over traditional SQL servers is in performance: low-overhead, lock-free architecture means Tarantool can serve an order of magnitude more requests per second, on comparable hardware. The advantage over NoSQL alternatives is in flexibility: Lua allows flexible processing of data stored in a compact, denormalized format."
msgstr ""

#: ../doc/book/faq.rst:35
msgid "Who is developing Tarantool?"
msgstr ""

#: ../doc/book/faq.rst:36
msgid "There is an engineering team employed by Mail.Ru -- check out our commit logs on `github.com/tarantool <http://github.com/tarantool/>`_. The development is fully open. Most of the connectors' authors, and the maintainers for different distributions, come from the wider community."
msgstr ""

#: ../doc/book/faq.rst:41
msgid "Are there problems associated with being an in-memory server?"
msgstr ""

#: ../doc/book/faq.rst:42
msgid "The principal storage engine (memtx) is designed for RAM plus persistent storage. It is immune to data loss because there is a write-ahead log. Its memory-allocation and compression techniques ensure there is no waste. And if Tarantool runs out of memory, then it will stop accepting updates until more memory is available, but will continue to handle read and delete requests without difficulty. However, for databases which are much larger than the available RAM space, Tarantool has a second storage engine (vinyl) which is only limited by the available disk space."
msgstr ""

#: ../doc/book/faq.rst:51
msgid "Can I store (large) BLOBs in Tarantool?"
msgstr ""

#: ../doc/book/faq.rst:52
msgid "Starting with Tarantool 1.7, there is no \"hard\" limit for the maximal tuple size. Tarantool, however, is designed for high-velocity workload with a lot of small chunks. For example, when you change an existing tuple, Tarantool creates a new version of the tuple in memory. Thus, an optimal tuple size is within kilobytes."
msgstr ""

#: ../doc/book/faq.rst:59
msgid "I delete data from vinyl, but disk usage stays the same. What gives?"
msgstr ""

#: ../doc/book/faq.rst:60
msgid "Data you write to vinyl is persisted in append-only run files. These files are immutable, and to perform a delete, a deletion marker (tombstone) is written to a newer run file instead. On compaction, new and old run files are merged, and a new run file is produced. Independently, the checkpoint manager keeps track of all run files involved in a checkpoint, and deletes obsolete files once they are no longer needed."
msgstr ""

#: ../doc/book/getting_started/index.rst:5
msgid "Getting started"
msgstr ""

#: ../doc/book/getting_started/index.rst:7
msgid "In this chapter, we explain how to install Tarantool, how to start it, and how to create a simple database."
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:5
msgid "Using a binary package"
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:7
msgid "For production purposes, we recommend `official binary packages <http://tarantool.org/download.html>`_. You can choose from two Tarantool versions: ``1.10`` (stable) or ``2.2`` (beta). An automatic build system creates, tests and publishes packages for every push into a corresponding branch (``1.10`` or ``2.2``) at `Tarantool's GitHub repository <https://github.com/tarantool/tarantool>`_."
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:14
msgid "To download and install the package that’s appropriate for your OS, start a shell (terminal) and enter the command-line instructions provided for your OS at Tarantool's `download page <http://tarantool.org/download.html>`_."
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:20
msgid "Starting Tarantool"
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:22
msgid "To start a Tarantool instance, say this:"
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:24
msgid "$ # if you downloaded a binary with apt-get or yum, say this:\n"
"$ /usr/bin/tarantool\n"
"$ # if you downloaded and untarred a binary tarball to ~/tarantool, say this:\n"
"$ ~/tarantool/bin/tarantool"
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:31
msgid "Tarantool starts in the interactive mode and displays a prompt:"
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:33
msgid "tarantool>"
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:37
#: ../doc/book/getting_started/using_docker.rst:84
msgid "Now you can enter requests on the command line."
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:41
#: ../doc/book/getting_started/using_docker.rst:88
msgid "On production machines, Tarantool's interactive mode is for system administration only. But we use it for most examples in this manual, because the interactive mode is convenient for learning."
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:47
#: ../doc/book/getting_started/using_docker.rst:94
msgid "Creating a database"
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:49
msgid "Here is how to create a simple test database after installation."
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:51
msgid "To let Tarantool store data in a separate place, create a new directory dedicated for tests:"
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:54
msgid "$ mkdir ~/tarantool_sandbox\n"
"$ cd ~/tarantool_sandbox"
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:59
msgid "You can delete the directory when the tests are over."
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:61
msgid "Check if the default port the database instance will listen to is vacant."
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:63
msgid "Depending on the release, during installation Tarantool may start a demonstrative global ``example.lua`` instance that listens to the ``3301`` port by default. The ``example.lua`` file showcases basic configuration and can be found in the ``/etc/tarantool/instances.enabled`` or ``/etc/tarantool/instances.available`` directories."
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:69
msgid "However, we encourage you to perform the instance startup manually, so you can learn."
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:72
msgid "Make sure the default port is vacant:"
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:74
msgid "To check if the demonstrative instance is running, say:"
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:76
msgid "$ lsof -i :3301\n"
"COMMAND    PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME\n"
"tarantool 6851 root   12u  IPv4  40827      0t0  TCP *:3301 (LISTEN)"
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:82
msgid "If it does, kill the corresponding process. In this example:"
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:84
msgid "$ kill 6851"
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:88
msgid "To start Tarantool's database module and make the instance accept TCP requests on port ``3301``, say:"
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:95
msgid "Create the first :ref:`space <index-box_space>` (named ``tester``):"
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:97
msgid "tarantool> s = box.schema.space.create('tester')"
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:101
#: ../doc/book/getting_started/using_docker.rst:104
msgid "Format the created space by specifying field names and types:"
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:103
msgid "tarantool> s:format({\n"
"         > {name = 'id', type = 'unsigned'},\n"
"         > {name = 'band_name', type = 'string'},\n"
"         > {name = 'year', type = 'unsigned'}\n"
"         > })"
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:111
#: ../doc/book/getting_started/using_docker.rst:114
msgid "Create the first :ref:`index <index-box_index>` (named ``primary``):"
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:113
msgid "tarantool> s:create_index('primary', {\n"
"         > type = 'hash',\n"
"         > parts = {'id'}\n"
"         > })"
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:120
#: ../doc/book/getting_started/using_docker.rst:123
msgid "This is a primary index based on the ``id`` field of each tuple."
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:122
#: ../doc/book/getting_started/using_docker.rst:125
msgid "Insert three :ref:`tuples <index-box_tuple>` (our name for records) into the space:"
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:125
msgid "tarantool> s:insert{1, 'Roxette', 1986}\n"
"tarantool> s:insert{2, 'Scorpions', 2015}\n"
"tarantool> s:insert{3, 'Ace of Base', 1993}"
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:131
#: ../doc/book/getting_started/using_docker.rst:134
msgid "To select a tuple using the ``primary`` index, say:"
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:133
msgid "tarantool> s:select{3}"
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:137
#: ../doc/book/getting_started/using_docker.rst:140
msgid "The terminal screen now looks like this:"
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:139
msgid "tarantool> s = box.schema.space.create('tester')\n"
"---\n"
"...\n"
"tarantool> s:format({\n"
"         > {name = 'id', type = 'unsigned'},\n"
"         > {name = 'band_name', type = 'string'},\n"
"         > {name = 'year', type = 'unsigned'}\n"
"         > })\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {\n"
"         > type = 'hash',\n"
"         > parts = {'id'}\n"
"         > })\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: unsigned\n"
"    is_nullable: false\n"
"    fieldno: 1\n"
"  id: 0\n"
"  space_id: 512\n"
"  name: primary\n"
"  type: HASH\n"
"...\n"
"tarantool> s:insert{1, 'Roxette', 1986}\n"
"---\n"
"- [1, 'Roxette', 1986]\n"
"...\n"
"tarantool> s:insert{2, 'Scorpions', 2015}\n"
"---\n"
"- [2, 'Scorpions', 2015]\n"
"...\n"
"tarantool> s:insert{3, 'Ace of Base', 1993}\n"
"---\n"
"- [3, 'Ace of Base', 1993]\n"
"...\n"
"tarantool> s:select{3}\n"
"---\n"
"- - [3, 'Ace of Base', 1993]\n"
"..."
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:183
#: ../doc/book/getting_started/using_docker.rst:186
msgid "To add a secondary index based on the ``band_name`` field, say:"
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:185
msgid "tarantool> s:create_index('secondary', {\n"
"         > type = 'hash',\n"
"         > parts = {'band_name'}\n"
"         > })"
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:192
#: ../doc/book/getting_started/using_docker.rst:195
msgid "To select tuples using the ``secondary`` index, say:"
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:194
msgid "tarantool> s.index.secondary:select{'Scorpions'}\n"
"---\n"
"- - [2, 'Scorpions', 2015]\n"
"..."
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:201
msgid "Now, to prepare for the example in the next section, try this:"
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:203
msgid "tarantool> box.schema.user.grant('guest', 'read,write,execute', 'universe')"
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:212
msgid "Connecting remotely"
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:214
msgid "In the request ``box.cfg{listen = 3301}`` that we made earlier, the ``listen`` value can be any form of a :ref:`URI <index-uri>` (uniform resource identifier). In this case, it’s just a local port: port ``3301``. You can send requests to the listen URI via:"
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:219
msgid "``telnet``,"
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:220
msgid "a :ref:`connector <index-box_connectors>`,"
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:221
msgid "another instance of Tarantool (using the :ref:`console <console-module>` module), or"
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:222
msgid ":ref:`tarantoolctl <tarantoolctl>` utility."
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:224
msgid "Let’s try (4)."
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:226
msgid "Switch to another terminal. On Linux, for example, this means starting another instance of a Bash shell. You can switch to any working directory in the new terminal, not necessarily to ``~/tarantool_sandbox``."
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:230
msgid "Start the ``tarantoolctl`` utility:"
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:232
msgid "$ tarantoolctl connect '3301'"
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:236
msgid "This means \"use ``tarantoolctl connect`` to connect to the Tarantool instance that’s listening on ``localhost:3301``\"."
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:239
msgid "Try this request:"
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:241
msgid "localhost:3301> box.space.tester:select{2}"
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:245
msgid "This means \"send a request to that Tarantool instance, and display the result\". The result in this case is one of the tuples that was inserted earlier. Your terminal screen should now look like this:"
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:249
msgid "$ tarantoolctl connect 3301\n"
"/usr/local/bin/tarantoolctl: connected to localhost:3301\n"
"localhost:3301> box.space.tester:select{2}\n"
"---\n"
"- - [2, 'Scorpions', 2015]\n"
"..."
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:258
msgid "You can repeat ``box.space...:insert{}`` and ``box.space...:select{}`` indefinitely, on either Tarantool instance."
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:261
msgid "When the testing is over:"
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:263
msgid "To drop the space: ``s:drop()``"
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:264
msgid "To stop ``tarantoolctl``: Ctrl+C or Ctrl+D"
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:265
msgid "To stop Tarantool (an alternative): the standard Lua function `os.exit() <http://www.lua.org/manual/5.1/manual.html#pdf-os.exit>`_"
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:267
msgid "To stop Tarantool (from another terminal): ``sudo pkill -f tarantool``"
msgstr ""

#: ../doc/book/getting_started/using_binary.rst:268
msgid "To destroy the test: ``rm -r ~/tarantool_sandbox``"
msgstr ""

#: ../doc/book/getting_started/using_docker.rst:5
msgid "Using a Docker image"
msgstr ""

#: ../doc/book/getting_started/using_docker.rst:7
msgid "For trial and test purposes, we recommend using `official Tarantool images for Docker <https://github.com/tarantool/docker>`_. An official image contains a particular Tarantool version and all popular external modules for Tarantool. Everything is already installed and configured in Linux. These images are the easiest way to install and use Tarantool."
msgstr ""

#: ../doc/book/getting_started/using_docker.rst:16
msgid "If you're new to Docker, we recommend going over `this tutorial <https://docs.docker.com/engine/getstarted/step_one/>`_ before proceeding with this chapter."
msgstr ""

#: ../doc/book/getting_started/using_docker.rst:24
msgid "Launching a container"
msgstr ""

#: ../doc/book/getting_started/using_docker.rst:26
msgid "If you don't have Docker installed, please follow the official `installation guide <https://docs.docker.com/engine/getstarted/step_one/#/step-1-get-docker>`_ for your OS."
msgstr ""

#: ../doc/book/getting_started/using_docker.rst:30
msgid "To start a fully functional Tarantool instance, run a container with minimal options:"
msgstr ""

#: ../doc/book/getting_started/using_docker.rst:33
msgid "$ docker run \\\n"
"  --name mytarantool \\\n"
"  -d -p 3301:3301 \\\n"
"  -v /data/dir/on/host:/var/lib/tarantool \\\n"
"  tarantool/tarantool:2"
msgstr ""

#: ../doc/book/getting_started/using_docker.rst:41
msgid "This command runs a new container named ``mytarantool``. Docker starts it from an official image named ``tarantool/tarantool:2``, with Tarantool version ``2.2`` and all external modules already installed."
msgstr ""

#: ../doc/book/getting_started/using_docker.rst:45
msgid "Tarantool will be accepting incoming connections on ``localhost:3301``. You may start using it as a key-value storage right away."
msgstr ""

#: ../doc/book/getting_started/using_docker.rst:48
msgid "Tarantool :ref:`persists data <index-box_persistence>` inside the container. To make your test data available after you stop the container, this command also mounts the host's directory ``/data/dir/on/host`` (you need to specify here an absolute path to an existing local directory) in the container's directory ``/var/lib/tarantool`` (by convention, Tarantool in a container uses this directory to persist data). So, all changes made in the mounted directory on the container's side are applied to the host's disk."
msgstr ""

#: ../doc/book/getting_started/using_docker.rst:57
msgid "Tarantool's database module in the container is already :ref:`configured <box_introspection-box_cfg>` and started. You needn't do it manually, unless you use Tarantool as an :ref:`application server <app_server>` and run it with an application."
msgstr ""

#: ../doc/book/getting_started/using_docker.rst:64
msgid "Attaching to Tarantool"
msgstr ""

#: ../doc/book/getting_started/using_docker.rst:66
msgid "To attach to Tarantool that runs inside the container, say:"
msgstr ""

#: ../doc/book/getting_started/using_docker.rst:68
msgid "$ docker exec -i -t mytarantool console"
msgstr ""

#: ../doc/book/getting_started/using_docker.rst:72
msgid "This command:"
msgstr ""

#: ../doc/book/getting_started/using_docker.rst:74
msgid "Instructs Tarantool to open an interactive console port for incoming connections."
msgstr ""

#: ../doc/book/getting_started/using_docker.rst:75
msgid "Attaches to the Tarantool server inside the container under ``admin`` user via a standard Unix socket."
msgstr ""

#: ../doc/book/getting_started/using_docker.rst:78
msgid "Tarantool displays a prompt:"
msgstr ""

#: ../doc/book/getting_started/using_docker.rst:80
msgid "tarantool.sock>"
msgstr ""

#: ../doc/book/getting_started/using_docker.rst:96
msgid "While you're attached to the console, let's create a simple test database."
msgstr ""

#: ../doc/book/getting_started/using_docker.rst:98
msgid "First, create the first :ref:`space <index-box_space>` (named ``tester``):"
msgstr ""

#: ../doc/book/getting_started/using_docker.rst:100
msgid "tarantool.sock> s = box.schema.space.create('tester')"
msgstr ""

#: ../doc/book/getting_started/using_docker.rst:106
msgid "tarantool.sock> s:format({\n"
"              > {name = 'id', type = 'unsigned'},\n"
"              > {name = 'band_name', type = 'string'},\n"
"              > {name = 'year', type = 'unsigned'}\n"
"              > })"
msgstr ""

#: ../doc/book/getting_started/using_docker.rst:116
msgid "tarantool.sock> s:create_index('primary', {\n"
"              > type = 'hash',\n"
"              > parts = {'id'}\n"
"              > })"
msgstr ""

#: ../doc/book/getting_started/using_docker.rst:128
msgid "tarantool.sock> s:insert{1, 'Roxette', 1986}\n"
"tarantool.sock> s:insert{2, 'Scorpions', 2015}\n"
"tarantool.sock> s:insert{3, 'Ace of Base', 1993}"
msgstr ""

#: ../doc/book/getting_started/using_docker.rst:136
msgid "tarantool.sock> s:select{3}"
msgstr ""

#: ../doc/book/getting_started/using_docker.rst:142
msgid "tarantool.sock> s = box.schema.space.create('tester')\n"
"---\n"
"...\n"
"tarantool.sock> s:format({\n"
"              > {name = 'id', type = 'unsigned'},\n"
"              > {name = 'band_name', type = 'string'},\n"
"              > {name = 'year', type = 'unsigned'}\n"
"              > })\n"
"---\n"
"...\n"
"tarantool.sock> s:create_index('primary', {\n"
"              > type = 'hash',\n"
"              > parts = {'id'}\n"
"              > })\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: unsigned\n"
"    is_nullable: false\n"
"    fieldno: 1\n"
"  id: 0\n"
"  space_id: 512\n"
"  name: primary\n"
"  type: HASH\n"
"...\n"
"tarantool.sock> s:insert{1, 'Roxette', 1986}\n"
"---\n"
"- [1, 'Roxette', 1986]\n"
"...\n"
"tarantool.sock> s:insert{2, 'Scorpions', 2015}\n"
"---\n"
"- [2, 'Scorpions', 2015]\n"
"...\n"
"tarantool.sock> s:insert{3, 'Ace of Base', 1993}\n"
"---\n"
"- [3, 'Ace of Base', 1993]\n"
"...\n"
"tarantool.sock> s:select{3}\n"
"---\n"
"- - [3, 'Ace of Base', 1993]\n"
"..."
msgstr ""

#: ../doc/book/getting_started/using_docker.rst:188
msgid "tarantool.sock> s:create_index('secondary', {\n"
"              > type = 'hash',\n"
"              > parts = {'band_name'}\n"
"              > })"
msgstr ""

#: ../doc/book/getting_started/using_docker.rst:197
msgid "tarantool.sock> s.index.secondary:select{'Scorpions'}\n"
"---\n"
"- - [2, 'Scorpions', 2015]\n"
"..."
msgstr ""

#: ../doc/book/getting_started/using_docker.rst:206
msgid "Stopping a container"
msgstr ""

#: ../doc/book/getting_started/using_docker.rst:208
msgid "When the testing is over, stop the container politely:"
msgstr ""

#: ../doc/book/getting_started/using_docker.rst:210
msgid "$ docker stop mytarantool"
msgstr ""

#: ../doc/book/getting_started/using_docker.rst:214
msgid "This was a temporary container, and its disk/memory data were flushed when you stopped it. But since you mounted a data directory from the host in the container, Tarantool's data files were persisted to the host's disk. Now if you start a new container and mount that data directory in it, Tarantool will recover all data from disk and continue working with the persisted data."
msgstr ""

#: ../doc/book/index.rst:5
msgid "User's Guide"
msgstr ""

#: ../doc/book/intro.rst:3
msgid "Preface"
msgstr ""

#: ../doc/book/intro.rst:5
msgid "Welcome to Tarantool! This is the User's Guide. We recommend reading it first, and consulting :ref:`Reference <reference>` materials for more detail afterwards, if needed."
msgstr ""

#: ../doc/book/intro.rst:11
msgid "How to read the documentation"
msgstr ""

#: ../doc/book/intro.rst:13
msgid "To get started, you can install and launch Tarantool using :ref:`a Docker container <getting_started-using_docker>`, :ref:`a binary package <getting_started-using_binary>`, or the online Tarantool server at http://try.tarantool.org. Either way, as the first tryout, you can follow the introductory exercises from :ref:`Chapter 2 \"Getting started\" <getting_started>`. If you want more hands-on experience, proceed to :ref:`Tutorials <tutorials>` after you are through with Chapter 2."
msgstr ""

#: ../doc/book/intro.rst:22
msgid ":ref:`Chapter 3 \"Database\" <database-chapter>` is about using Tarantool as a NoSQL DBMS, whereas :ref:`Chapter 4 \"Application server\" <app_server>` is about using Tarantool as an application server."
msgstr ""

#: ../doc/book/intro.rst:26
msgid ":ref:`Chapter 5 \"Server administration\" <admin>` and :ref:`Chapter 6 \"Replication\" <replication>` are primarily for administrators."
msgstr ""

#: ../doc/book/intro.rst:29
msgid ":ref:`Chapter 7 \"Connectors\" <index-box_connectors>` is strictly for users who are connecting from a different language such as C or Perl or Python — other users will find no immediate need for this chapter."
msgstr ""

#: ../doc/book/intro.rst:33
msgid ":ref:`Chapter 8 \"FAQ\" <faq>` gives answers to some frequently asked questions about Tarantool."
msgstr ""

#: ../doc/book/intro.rst:36
msgid "For experienced users, there are also :ref:`Reference <reference>` materials, a :ref:`Contributor's Guide <contrib_guide>` and an extensive set of comments in the source code."
msgstr ""

#: ../doc/book/intro.rst:42
msgid "Getting in touch with the Tarantool community"
msgstr ""

#: ../doc/book/intro.rst:44
msgid "Please report bugs or make feature requests at http://github.com/tarantool/tarantool/issues."
msgstr ""

#: ../doc/book/intro.rst:46
msgid "You can contact developers directly in `telegram <http://telegram.me/tarantool>`_ or in a Tarantool discussion group (`English <https://groups.google.com/forum/#!forum/tarantool>`_ or `Russian <https://googlegroups.com/group/tarantool-ru>`_)."
msgstr ""

#: ../doc/book/intro.rst:53
msgid "Conventions used in this manual"
msgstr ""

#: ../doc/book/intro.rst:55
msgid "Square brackets [ and ] enclose optional syntax."
msgstr ""

#: ../doc/book/intro.rst:57
msgid "Two dots in a row .. mean the preceding tokens may be repeated."
msgstr ""

#: ../doc/book/intro.rst:59
msgid "A vertical bar | means the preceding and following tokens are mutually exclusive alternatives."
msgstr ""

#: ../doc/book/replication/1_1.rst:1
msgid "$ # Terminal 1\n"
"$ mkdir -p ~/tarantool_test_node_1\n"
"$ cd ~/tarantool_test_node_1\n"
"$ rm -R ./*\n"
"$ ~/tarantool/src/tarantool\n"
"$ ~/tarantool/src/tarantool: version 1.7.0-1724-g033ed69\n"
"type 'help' for interactive help\n"
"tarantool> box.cfg{listen = 3301}\n"
"<... ...>\n"
"tarantool> box.schema.user.create('replicator', {password = 'password'})\n"
"<...> I> creating ./00000000000000000000.xlog.inprogress'\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('replicator','execute','role','replication')\n"
"---\n"
"...\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"..."
msgstr ""

#: ../doc/book/replication/1_2.rst:1
msgid "$"
msgstr ""

#: ../doc/book/replication/2_1.rst:1
msgid "$ # Terminal 1\n"
"$ mkdir -p ~/tarantool_test_node_1\n"
"<... ...>\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"...\n"
"tarantool>\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovery start\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovering from `./00000000000000000000.snap'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> snapshot sent\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recover from `./00000000000000000000.xlog'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main recovery.cc:211 W> file\n"
"      `./00000000000000000000.xlog` wasn't correctly closed\n"
"<...> [11031] relay/127.0.0.1:58734/102/main I> recover from `./00000000000000000000.xlog'"
msgstr ""

#: ../doc/book/replication/2_2.rst:1
#: ../doc/book/replication/3_2.rst:1
msgid "$ # Terminal 2\n"
"$ mkdir -p ~/tarantool_test_node_2\n"
"$ cd ~/tarantool_test_node_2\n"
"$ rm -R ./*\n"
"$ ~/tarantool/src/tarantool\n"
"/home/username/tarantool/src/tarantool: version 1.7.0-1724-g033ed69\n"
"type 'help' for interactive help\n"
"tarantool> box.cfg{\n"
"         >   listen = 3302,\n"
"         >   replication = 'replicator:password@localhost:3301'\n"
"         > }\n"
"<...>\n"
"<...> [11243] main/101/interactive I> mapping 1073741824 bytes for tuple arena...\n"
"<...> [11243] main/101/interactive C> starting replication from localhost:3301\n"
"<...> [11243] main/102/applier/localhost:3301 I> connected to 1.7.0 at 127.0.0.1:3301\n"
"<...> [11243] main/102/applier/localhost:3301 I> authenticated\n"
"<...> [11243] main/102/applier/localhost:3301 I> downloading a snapshot from 127.0.0.1:3301\n"
"<...> [11243] main/102/applier/localhost:3301 I> done\n"
"<...> [11243] snapshot/101/main I> creating `./00000000000000000000.snap.inprogress'\n"
"<...> [11243] snapshot/101/main I> saving snapshot `./00000000000000000000.snap.inprogress'\n"
"<...> [11243] snapshot/101/main I> done\n"
"<...> [11243] iproto I> binary: started\n"
"<...> [11243] iproto I> binary: bound to 0.0.0.0:3302\n"
"<...> [11243] wal/101/main I> creating `./00000000000000000000.xlog.inprogress'\n"
"<...> [11243] main/101/interactive I> ready to accept requests\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"  - [2, '236230b8-af3e-406b-b709-15a60b44c20c']\n"
"..."
msgstr ""

#: ../doc/book/replication/3_1.rst:1
#: ../doc/book/replication/4_1.rst:1
msgid "<... ...>\n"
"tarantool>\n"
"tarantool>\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovery start\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovering from `./00000000000000000000.snap'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> snapshot sent\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recover from `./00000000000000000000.xlog'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main recovery.cc:211 W> file\n"
"      `./00000000000000000000.xlog` wasn't correctly closed\n"
"<...> [11031] relay/127.0.0.1:58734/102/main I> recover from `./00000000000000000000.xlog'\n"
"tarantool> s = box.schema.space.create('tester')\n"
"---\n"
"...\n"
"tarantool> i = s:create_index('primary', {})\n"
"---\n"
"...\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}\n"
"---\n"
"- [1, 'Tuple inserted on Terminal #1']\n"
"..."
msgstr ""

#: ../doc/book/replication/4_2.rst:1
msgid "<... ...>\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"  - [2, '236230b8-af3e-406b-b709-15a60b44c20c']\n"
"...\n"
"tarantool> s = box.space.tester\n"
"---\n"
"...\n"
"tarantool> s:select({1}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"..."
msgstr ""

#: ../doc/book/replication/5_1.rst:1
#: ../doc/book/replication/6_1.rst:1
msgid "<... ...>\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}\n"
"---\n"
"- [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> os.exit()\n"
"$ ls -l ~/tarantool_test_node_1\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:12 00000000000000000000.snap\n"
"-rw-rw-r-- 1   634 May  5 11:45 00000000000000000000.xlog\n"
"$ ls -l ~/tarantool_test_node_2/\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:20 00000000000000000000.snap\n"
"-rw-rw-r-- 1   704 May  5 11:38 00000000000000000000.xlog\n"
"$"
msgstr ""

#: ../doc/book/replication/5_2.rst:1
msgid "<... ...>\n"
"tarantool> s:select({1}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
"<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken pipe\n"
"<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 second"
msgstr ""

#: ../doc/book/replication/6_2.rst:1
msgid "<... ...>\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [11243] main/105/applier/localhost:3301 I> can't read row\n"
"<...> [11243] main/105/applier/localhost:3301 coio.cc:352 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 6, aka 127.0.0.1:58734, peer of 127.0.0.1:3301: Broken pipe\n"
"<...> [11243] main/105/applier/localhost:3301 I> will retry every 1 second\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool> box.space.tester:insert{3, 'Another'}\n"
"---\n"
"- [3, 'Another']\n"
"..."
msgstr ""

#: ../doc/book/replication/7_1.rst:1
msgid "<... ...>\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}\n"
"---\n"
"- [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> os.exit()\n"
"$ ls -l ~/tarantool_test_node_1\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:12 00000000000000000000.snap\n"
"-rw-rw-r-- 1   634 May  5 11:45 00000000000000000000.xlog\n"
"$ ls -l ~/tarantool_test_node_2/\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:20 00000000000000000000.snap\n"
"-rw-rw-r-- 1   704 May  5 11:38 00000000000000000000.xlog\n"
"$ ~/tarantool/src/tarantool\n"
"<...>\n"
"tarantool> box.cfg{listen = 3301}\n"
"<...> [22612] main/101/interactive I> ready to accept requests\n"
"<... ...>\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"..."
msgstr ""

#: ../doc/book/replication/7_2.rst:1
msgid "<... ...>\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
"<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken pipe\n"
"<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 second\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool> box.space.tester:insert{3, 'Another'}\n"
"---\n"
"- [3, 'Another']\n"
"...\n"
"<...> [11243] main/105/applier/localhost:3301 I> connected to 1.7.0 at 127.0.0.1:3301\n"
"<...> [11243] main/105/applier/localhost:3301 I> authenticated"
msgstr ""

#: ../doc/book/replication/8_1.rst:1
msgid "<... ...>\n"
"$ ~/tarantool/src/tarantool\n"
"<...>\n"
"tarantool> box.cfg{listen = 3301}\n"
"<...> [22612] main/101/interactive I> ready to accept requests\n"
"<... ...>\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> box.cfg{\n"
"         >   replication = 'replicator:password@localhost:3302'\n"
"         > }\n"
"[28987] main/101/interactive C> starting replication from localhost:3302\n"
"---\n"
"...\n"
"[22612] main/101/interactive C> starting replication from localhost:3302\n"
"[22612] main/101/interactive I> set 'replication' configuration\n"
"        option to \"replicator:password@localhost:3302\"\n"
"[22612] main/104/applier/localhost:3302 I> connected to 1.7.0 at 127.0.0.1:3302\n"
"[22612] main/104/applier/localhost:3302 I> authenticated\n"
"[22612] wal/101/main I> creating `./00000000000000000008.xlog.inprogress'\n"
"[22612] relay/127.0.0.1:33510/102/main I> done `./00000000000000000000.xlog'\n"
"[22612] relay/127.0.0.1:33510/102/main I> recover from `./00000000000000000008.xlog'\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"  - [3, 'Another']\n"
"..."
msgstr ""

#: ../doc/book/replication/8_2.rst:1
msgid "<... ...>\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
"<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken pipe\n"
"<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 second\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool> box.space.tester:insert{3, 'Another'}\n"
"---\n"
"- [3, 'Another']\n"
"...\n"
"<...> [11243] main/105/applier/localhost:3301 I> connected to 1.7.0 at 127.0.0.1:3301\n"
"<...> [11243] main/105/applier/localhost:3301 I> authenticated\n"
"tarantool>\n"
"<...> [11243] relay/127.0.0.1:36150/101/main I> recover from `./00000000000000000000.xlog'\n"
"<...> [11243] relay/127.0.0.1:36150/101/main recovery.cc:211 W> file\n"
"     `./00000000000000000000.xlog` wasn't correctly closed\n"
"<...> [11243] relay/127.0.0.1:36150/102/main I> recover from `./00000000000000000000.xlog'"
msgstr ""

#: ../doc/book/replication/index.rst:5
msgid "Replication"
msgstr ""

#: ../doc/book/replication/index.rst:7
msgid "Replication allows multiple Tarantool instances to work on copies of the same databases. The databases are kept in sync because each instance can communicate its changes to all the other instances."
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:5
msgid "Adding instances"
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:11
msgid "Adding a replica"
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:16
msgid "To add a second **replica** instance to the **master-replica** set from our :ref:`bootstrapping example <replication-master_replica_bootstrap>`, we need an analog of the instance file that we created for the first replica in that set:"
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:20
msgid "-- instance file for replica #2\n"
"box.cfg{\n"
"  listen = 3301,\n"
"  replication = {'replicator:password@192.168.0.101:3301',  -- master URI\n"
"                 'replicator:password@192.168.0.102:3301',  -- replica #1 URI\n"
"                 'replicator:password@192.168.0.103:3301'}, -- replica #2 URI\n"
"  read_only = true\n"
"}\n"
"box.once(\"schema\", function()\n"
"   box.schema.user.create('replicator', {password = 'password'})\n"
"   box.schema.user.grant('replicator', 'replication') -- grant replication role\n"
"   box.schema.space.create(\"test\")\n"
"   box.space.test:create_index(\"primary\")\n"
"   print('box.once executed on replica #2')\n"
"end)"
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:38
msgid "Here we add the URI of replica #2 to the :ref:`replication <cfg_replication-replication>` parameter, so now it contains three URIs."
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:41
msgid "After we launch the new replica instance, it gets connected to the master instance and retrieves the master's write-ahead-log and snapshot files:"
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:44
msgid "$ # launching replica #2\n"
"$ tarantool replica2.lua\n"
"2017-06-14 14:54:33.927 [46945] main/101/replica2.lua C> version 1.7.4-52-g980d30092\n"
"2017-06-14 14:54:33.927 [46945] main/101/replica2.lua C> log level 5\n"
"2017-06-14 14:54:33.928 [46945] main/101/replica2.lua I> mapping 268435456 bytes for tuple arena...\n"
"2017-06-14 14:54:33.930 [46945] main/104/applier/replicator@192.168.0.10 I> remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 14:54:33.930 [46945] main/104/applier/replicator@192.168.0.10 I> authenticated\n"
"2017-06-14 14:54:33.930 [46945] main/101/replica2.lua I> bootstrapping replica from 192.168.0.101:3301\n"
"2017-06-14 14:54:33.933 [46945] main/104/applier/replicator@192.168.0.10 I> initial data received\n"
"2017-06-14 14:54:33.933 [46945] main/104/applier/replicator@192.168.0.10 I> final data received\n"
"2017-06-14 14:54:33.934 [46945] snapshot/101/main I> saving snapshot `/var/lib/tarantool/replica2/00000000000000000010.snap.inprogress'\n"
"2017-06-14 14:54:33.934 [46945] snapshot/101/main I> done\n"
"2017-06-14 14:54:33.935 [46945] main/101/replica2.lua I> vinyl checkpoint done\n"
"2017-06-14 14:54:33.935 [46945] main/101/replica2.lua I> ready to accept requests\n"
"2017-06-14 14:54:33.935 [46945] main/101/replica2.lua I> set 'read_only' configuration option to true\n"
"2017-06-14 14:54:33.936 [46945] main C> entering the event loop"
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:63
msgid "Since we are adding a read-only instance, there is no need to dynamically update the ``replication`` parameter on the other running instances. This update would be required if we :ref:`added a master instance <replication-add_master>`."
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:67
msgid "However, we recommend specifying the URI of replica #3 in all instance files of the replica set. This will keep all the files consistent with each other and with the current replication topology, and so will help to avoid configuration errors in case of further configuration updates and replica set restart."
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:76
msgid "Adding a master"
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:81
msgid "To add a third master instance to the **master-master** set from our :ref:`bootstrapping example <replication-master_master_bootstrap>`, we need an analog of the instance files that we created to bootstrap the other master instances in that set:"
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:86
msgid "-- instance file for master #3\n"
"box.cfg{\n"
"  listen      = 3301,\n"
"  replication = {'replicator:password@192.168.0.101:3301',  -- master#1 URI\n"
"                 'replicator:password@192.168.0.102:3301',  -- master#2 URI\n"
"                 'replicator:password@192.168.0.103:3301'}, -- master#3 URI\n"
"  read_only   = true, -- temporarily read-only\n"
"}\n"
"box.once(\"schema\", function()\n"
"   box.schema.user.create('replicator', {password = 'password'})\n"
"   box.schema.user.grant('replicator', 'replication') -- grant replication role\n"
"   box.schema.space.create(\"test\")\n"
"   box.space.test:create_index(\"primary\")\n"
"end)"
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:103
msgid "Here we make the following changes:"
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:105
msgid "Add the URI of master #3 to the :ref:`replication <cfg_replication-replication>` parameter."
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:107
msgid "Temporarily specify :ref:`read_only=true <cfg_basic-read_only>` to disable data-change operations on the instance. After launch, master #3 will act as a replica until it retrieves all data from the other masters in the replica set."
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:111
msgid "After we launch master #3, it gets connected to the other master instances and retrieves their write-ahead-log and snapshot files:"
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:114
msgid "$ # launching master #3\n"
"$ tarantool master3.lua\n"
"2017-06-14 17:10:00.556 [47121] main/101/master3.lua C> version 1.7.4-52-g980d30092\n"
"2017-06-14 17:10:00.557 [47121] main/101/master3.lua C> log level 5\n"
"2017-06-14 17:10:00.557 [47121] main/101/master3.lua I> mapping 268435456 bytes for tuple arena...\n"
"2017-06-14 17:10:00.559 [47121] iproto/101/main I> binary: bound to [::]:3301\n"
"2017-06-14 17:10:00.559 [47121] main/104/applier/replicator@192.168.0.10 I> remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 17:10:00.559 [47121] main/105/applier/replicator@192.168.0.10 I> remote master is 1.7.4 at 192.168.0.102:3301\n"
"2017-06-14 17:10:00.559 [47121] main/106/applier/replicator@192.168.0.10 I> remote master is 1.7.4 at 192.168.0.103:3301\n"
"2017-06-14 17:10:00.559 [47121] main/105/applier/replicator@192.168.0.10 I> authenticated\n"
"2017-06-14 17:10:00.559 [47121] main/101/master3.lua I> bootstrapping replica from 192.168.0.102:3301\n"
"2017-06-14 17:10:00.562 [47121] main/105/applier/replicator@192.168.0.10 I> initial data received\n"
"2017-06-14 17:10:00.562 [47121] main/105/applier/replicator@192.168.0.10 I> final data received\n"
"2017-06-14 17:10:00.562 [47121] snapshot/101/main I> saving snapshot `/Users/e.shebunyaeva/work/tarantool-test-repl/master3_dir/00000000000000000009.snap.inprogress'\n"
"2017-06-14 17:10:00.562 [47121] snapshot/101/main I> done\n"
"2017-06-14 17:10:00.564 [47121] main/101/master3.lua I> vinyl checkpoint done\n"
"2017-06-14 17:10:00.564 [47121] main/101/master3.lua I> ready to accept requests\n"
"2017-06-14 17:10:00.565 [47121] main/101/master3.lua I> set 'read_only' configuration option to true\n"
"2017-06-14 17:10:00.565 [47121] main C> entering the event loop\n"
"2017-06-14 17:10:00.565 [47121] main/104/applier/replicator@192.168.0.10 I> authenticated"
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:137
msgid "Next, we add the URI of master #3 to the ``replication`` parameter on the existing two masters. Replication-related parameters are dynamic, so we only need to make a ``box.cfg{}`` request on each of the running instances:"
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:141
msgid "# adding master #3 URI to replication sources\n"
"tarantool> box.cfg{replication =\n"
"         > {'replicator:password@192.168.0.101:3301',\n"
"         > 'replicator:password@192.168.0.102:3301',\n"
"         > 'replicator:password@192.168.0.103:3301'}}\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:151
msgid "When master #3 catches up with the other masters' state, we can disable read-only mode for this instance:"
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:154
msgid "# making master #3 a real master\n"
"tarantool> box.cfg{read_only=false}\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:161
msgid "We also recommend to specify master #3 URI in all instance files in order to keep all the files consistent with each other and with the current replication topology."
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:169
msgid "Orphan status"
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:171
msgid "Starting with Tarantool version 1.9, there is a change to the procedure when an instance joins a replica set. During ``box.cfg()`` the instance will try to join all masters listed in :ref:`box.cfg.replication <cfg_replication-replication>`. If the instance does not succeed with at least the number of masters specified in :ref:`replication_connect_quorum <cfg_replication-replication_connect_quorum>`, then it will switch to **orphan status**. While an instance is in orphan status, it is read-only."
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:181
msgid "To \"join\" a master, a replica instance must \"connect\" to the master node and then \"sync\"."
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:184
msgid "\"Connect\" means contact the master over the physical network and receive acknowledgment. If there is no acknowledgment after :ref:`box.replication_connect_timeout <cfg_replication-replication_connect_timeout>` seconds (usually 4 seconds), and retries fail, then the connect step fails."
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:189
msgid "\"Sync\" means receive updates from the master in order to make a local database copy. Syncing is complete when the replica has received all the updates, or at least has received enough updates that the replica's lag (see :ref:`replication.upstream.lag <box_info_replication_upstream_lag>` in ``box.info()``) is less than or equal to the number of seconds specified in :ref:`box.cfg.replication_sync_lag <cfg_replication-replication_sync_lag>`. If ``replication_sync_lag`` is unset (nil) or set to TIMEOUT_INFINITY, then the replica skips the \"sync\" state and switches to \"follow\" immediately."
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:201
msgid "The following situations are possible."
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:205
msgid "**Situation 1: bootstrap**"
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:207
msgid "Here ``box.cfg{}`` is being called for the first time. A replica is joining but no replica set exists yet."
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:210
msgid "Set status to 'orphan'."
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:211
msgid "Try to connect to all nodes from ``box.cfg.replication``, or to the number of nodes required by :ref:`replication_connect_quorum <cfg_replication-replication_connect_quorum>`. Retrying up to 3 times in 30 seconds is possible because this is bootstrap, :ref:`replication_connect_timeout <cfg_replication-replication_connect_timeout>` is overridden."
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:218
msgid "Abort if not connected to all nodes in ``box.cfg.replication`` or :ref:`replication_connect_quorum <cfg_replication-replication_connect_quorum>`."
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:221
msgid "This instance might be elected as the replica set 'leader'. Criteria for electing a leader include vclock value (largest is best), and whether it is read-only or read-write (read-write is best unless there is no other choice). The leader is the master that other instances must join. The leader is the master that executes :ref:`box_once() <box-once>` functions."
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:227
msgid "If this instance is elected as the replica set leader, then perform an \"automatic bootstrap\":"
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:231
msgid "Set status to 'running'."
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:232
msgid "Return from ``box.cfg{}``."
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:234
msgid "Otherwise this instance will be a replica joining an existing replica set, so:"
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:237
msgid "Bootstrap from the leader. See examples in section :ref:`Bootstrapping a replica set <replication-bootstrap>`."
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:239
msgid "In background, sync with all the other nodes in the replication set."
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:241
msgid "**Situation 2: recovery**"
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:243
msgid "Here ``box.cfg{}`` is not being called for the first time. It is being called again in order to perform recovery."
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:246
msgid "Perform :ref:`recovery <internals-recovery_process>` from the last local snapshot and the WAL files."
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:249
msgid "Connect to at least :ref:`replication_connect_quorum <cfg_replication-replication_connect_quorum>` nodes."
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:253
msgid "Sync with all connected nodes, until the difference is not more than :ref:`replication_sync_lag <cfg_replication-replication_sync_lag>` seconds."
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:258
msgid "**Situation 3: configuration update**"
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:260
msgid "Here ``box.cfg{}`` is not being called for the first time. It is being called again because some replication parameter or something in the replica set has changed."
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:264
msgid "Try to connect to all nodes from ``box.cfg.replication``, or to the number of nodes required by :ref:`replication_connect_quorum <cfg_replication-replication_connect_quorum>`, within the time period specified in :ref:`replication_connect_timeout <cfg_replication-replication_connect_timeout>`."
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:270
msgid "Try to sync with the connected nodes, within the time period specified in :ref:`replication_sync_timeout <cfg_replication-replication_sync_timeout>`."
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:274
msgid "If earlier steps fail, change status to 'orphan'. (Attempts to sync will continue in the background and when/if they succeed then 'orphan' status will end.)"
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:278
msgid "If earlier steps succeed, set status to 'running' (master) or 'follow' (replica)."
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:282
msgid "**Situation 4: rebootstrap**"
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:284
msgid "Here ``box.cfg{}`` is not being called. The replica connected successfully at some point in the past, and is now ready for an update from the master. But the master cannot provide an update. This can happen by accident, or more likely can happen because the replica is slow (its :ref:`lag <cfg_replication-replication_sync_lag>` is large), and the WAL (.xlog) files containing the updates have been deleted. This is not crippling. The replica can discard what it received earlier, and then ask for the master's latest snapshot (.snap) file contents. Since it is effectively going through the bootstrap process a second time, this is called \"rebootstrapping\". However, there has to be one difference from an ordinary bootstrap -- the replica's :ref:`replica id <replication-replica-id>` will remain the same. If it changed, then the master would think that the replica is a new addition to the cluster, and would maintain a record of an instance ID of a replica that has ceased to exist. Rebootstrapping was introduced in Tarantool version 1.10.2 and is completely automatic."
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:305
msgid "Server startup with replication"
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:307
msgid "In addition to the recovery process described in the section :ref:`Recovery process <internals-recovery_process>`, the server must take additional steps and precautions if :ref:`replication <replication>` is enabled."
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:311
msgid "Once again the startup procedure is initiated by the ``box.cfg{}`` request. One of the ``box.cfg`` parameters may be :ref:`replication <cfg_replication-replication>` which specifies replication source(-s). We will refer to this replica, which is starting up due to ``box.cfg``, as the \"local\" replica to distinguish it from the other replicas in a replica set, which we will refer to as \"distant\" replicas."
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:318
msgid "*If there is no snapshot .snap file and the 'replication' parameter is empty and cfg.read_only=false*: |br| then the local replica assumes it is an unreplicated \"standalone\" instance, or is the first replica of a new replica set. It will generate new UUIDs for itself and for the replica set. The replica UUID is stored in the ``_cluster`` space; the replica set UUID is stored in the ``_schema`` space. Since a snapshot contains all the data in all the spaces, that means the local replica's snapshot will contain the replica UUID and the replica set UUID. Therefore, when the local replica restarts on later occasions, it will be able to recover these UUIDs when it reads the .snap file."
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:328
msgid "*If there is no snapshot .snap file and the 'replication' parameter is empty and cfg.read_only=true*: |br| When an instance is starting with ``box.cfg({... read_only = true})``, it cannot be the first replica of a new replica set because the first replica must be a master. Therefore an error message will occur: ER_BOOTSTRAP_READONLY. To avoid this, change the setting for this (local) instance to ``read_only = false``, or ensure that another (distant) instance starts first and has the local instance's UUID in its _cluster space. In the latter case, if ER_BOOTSTRAP_READONLY still occurs, set the local instance's :ref:`box.replication_connect_timeout <cfg_replication-replication_connect_timeout>` to a larger value."
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:339
msgid "*If there is no snapshot .snap file and the 'replication' parameter is not empty and the '_cluster' space contains no other replica UUIDs*: |br| then the local replica assumes it is not a standalone instance, but is not yet part of a replica set. It must now join the replica set. It will send its replica UUID to the first distant replica which is listed in ``replication`` and which will act as a master. This is called the \"join request\". When a distant replica receives a join request, it will send back:"
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:347
msgid "the distant replica's replica set UUID,"
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:348
msgid "the contents of the distant replica's .snap file. |br| When the local replica receives this information, it puts the replica set UUID in its ``_schema`` space, puts the distant replica's UUID and connection information in its ``_cluster`` space, and makes a snapshot containing all the data sent by the distant replica. Then, if the local replica has data in its WAL .xlog files, it sends that data to the distant replica. The distant replica will receive this and update its own copy of the data, and add the local replica's UUID to its ``_cluster`` space."
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:357
msgid "*If there is no snapshot .snap file and the 'replication' parameter is not empty and the ``_cluster`` space contains other replica UUIDs*: |br| then the local replica assumes it is not a standalone instance, and is already part of a replica set. It will send its replica UUID and replica set UUID to all the distant replicas which are listed in ``replication``. This is called the \"on-connect handshake\". When a distant replica receives an on-connect handshake: |br|"
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:364
msgid "the distant replica compares its own copy of the replica set UUID to the one in the on-connect handshake. If there is no match, then the handshake fails and the local replica will display an error."
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:367
msgid "the distant replica looks for a record of the connecting instance in its ``_cluster`` space. If there is none, then the handshake fails. |br| Otherwise the handshake is successful. The distant replica will read any new information from its own .snap and .xlog files, and send the new requests to the local replica."
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:373
msgid "In the end, the local replica knows what replica set it belongs to, the distant replica knows that the local replica is a member of the replica set, and both replicas have the same database contents."
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:379
msgid "*If there is a snapshot file and replication source is not empty*: |br| first the local replica goes through the recovery process described in the previous section, using its own .snap and .xlog files. Then it sends a \"subscribe\" request to all the other replicas of the replica set. The subscribe request contains the server vector clock. The vector clock has a collection of pairs 'server id, lsn' for every replica in the ``_cluster`` system space. Each distant replica, upon receiving a subscribe request, will read its .xlog files' requests and send them to the local replica if (lsn of .xlog file request) is greater than (lsn of the vector clock in the subscribe request). After all the other replicas of the replica set have responded to the local replica's subscribe request, the replica startup is complete."
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:391
msgid "The following temporary limitations applied for Tarantool versions earlier than 1.7.7:"
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:394
msgid "The URIs in the ``replication`` parameter should all be in the same order on all replicas. This is not mandatory but is an aid to consistency."
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:396
msgid "The replicas of a replica set should be started up at slightly different times. This is not mandatory but prevents a situation where each replica is waiting for the other replica to be ready."
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:400
msgid "The following limitation still applies for the current Tarantool version:"
msgstr ""

#: ../doc/book/replication/repl_add_instances.rst:402
msgid "The maximum number of entries in the ``_cluster`` space is :ref:`32 <limitations_replicas>`. Tuples for out-of-date replicas are not automatically re-used, so if this 32-replica limit is reached, users may have to reorganize the ``_cluster`` space manually."
msgstr ""

#: ../doc/book/replication/repl_architecture.rst:5
msgid "Replication architecture"
msgstr ""

#: ../doc/book/replication/repl_architecture.rst:11
msgid "Replication mechanism"
msgstr ""

#: ../doc/book/replication/repl_architecture.rst:13
msgid "A pack of instances which operate on copies of the same databases make up a **replica set**. Each instance in a replica set has a role, **master** or **replica**."
msgstr ""

#: ../doc/book/replication/repl_architecture.rst:17
msgid "A replica gets all updates from the master by continuously fetching and applying its :ref:`write ahead log (WAL)<internals-wal>`. Each record in the WAL represents a single Tarantool data-change request such as :ref:`INSERT<box_space-insert>`, :ref:`UPDATE<box_space-update>` or :ref:`DELETE<box_space-delete>`, and is assigned a monotonically growing log sequence number (**LSN**). In essence, Tarantool replication is **row-based**: each data-change request is fully deterministic and operates on a single :ref:`tuple<index-box_tuple>`. However, unlike a classical row-based log, which contains entire copies of the changed rows, Tarantool's WAL contains copies of the requests. For example, for UPDATE requests, Tarantool only stores the primary key of the row and the update operations, to save space."
msgstr ""

#: ../doc/book/replication/repl_architecture.rst:28
msgid "Invocations of **stored programs** are not written to the WAL. Instead, records of the actual **data-change requests, performed by the Lua code**, are written to the WAL. This ensures that possible non-determinism of Lua does not cause replication to go out of sync."
msgstr ""

#: ../doc/book/replication/repl_architecture.rst:33
msgid "Data definition operations on **temporary spaces**, such as creating/dropping, adding indexes, truncating, etc., are written to the WAL, since information about temporary spaces is stored in non-temporary system spaces, such as :ref:`box.space._space <box_space-space>`. Data change operations on temporary spaces are not written to the WAL and are not replicated."
msgstr ""

#: ../doc/book/replication/repl_architecture.rst:41
msgid "Data change operations on **replication-local** spaces (spaces :ref:`created <box_schema-space_create>` with ``is_local`` = true) are written to the WAL but are not replicated."
msgstr ""

#: ../doc/book/replication/repl_architecture.rst:45
msgid "To create a valid initial state, to which WAL changes can be applied, every instance of a replica set requires a start set of :ref:`checkpoint files <index-box_persistence>`, such as .snap files for memtx and .run files for vinyl. A replica joining an existing replica set, chooses an existing master and automatically downloads the initial state from it. This is called an **initial join**."
msgstr ""

#: ../doc/book/replication/repl_architecture.rst:52
msgid "When an entire replica set is bootstrapped for the first time, there is no master which could provide the initial checkpoint. In such a case, replicas connect to each other and elect a master, which then creates the starting set of checkpoint files, and distributes it to all the other replicas. This is called an **automatic bootstrap** of a replica set."
msgstr ""

#: ../doc/book/replication/repl_architecture.rst:58
msgid "When a replica contacts a master (there can be many masters) for the first time, it becomes part of a replica set. On subsequent occasions, it should always contact a master in the same replica set. Once connected to the master, the replica requests all changes that happened after the latest local LSN (there can be many LSNs -- each master has its own LSN)."
msgstr ""

#: ../doc/book/replication/repl_architecture.rst:64
msgid "Each replica set is identified by a globally unique identifier, called the **replica set UUID**. The identifier is created by the master which creates the very first checkpoint, and is part of the checkpoint file. It is stored in system space :ref:`box.space._schema <box_space-schema>`. For example:"
msgstr ""

#: ../doc/book/replication/repl_architecture.rst:69
msgid "tarantool> box.space._schema:select{'cluster'}\n"
"---\n"
"- - ['cluster', '6308acb9-9788-42fa-8101-2e0cb9d3c9a0']\n"
"..."
msgstr ""

#: ../doc/book/replication/repl_architecture.rst:78
msgid "Additionally, each instance in a replica set is assigned its own UUID, when it joins the replica set. It is called an **instance UUID** and is a globally unique identifier. The instance UUID is checked to ensure that instances do not join a different replica set, e.g. because of a configuration error. A unique instance identifier is also necessary to apply rows originating from different masters only once, that is, to implement multi-master replication. This is why each row in the write ahead log, in addition to its log sequence number, stores the instance identifier of the instance on which it was created. But using a UUID as such an identifier would take too much space in the write ahead log, thus a shorter integer number is assigned to the instance when it joins a replica set. This number is then used to refer to the instance in the write ahead log. It is called **instance id**. All identifiers are stored in system space :ref:`box.space._cluster <box_space-cluster>`. For example:"
msgstr ""

#: ../doc/book/replication/repl_architecture.rst:99
msgid "Here the instance ID is ``1`` (unique within the replica set), and the instance UUID is ``88580b5c-4474-43ab-bd2b-2409a9af80d2`` (globally unique)."
msgstr ""

#: ../doc/book/replication/repl_architecture.rst:102
msgid "Using instance IDs is also handy for tracking the state of the entire replica set. For example, :ref:`box.info.vclock <box_introspection-box_info>` describes the state of replication in regard to each connected peer."
msgstr ""

#: ../doc/book/replication/repl_architecture.rst:106
msgid "tarantool> box.info.vclock\n"
"---\n"
"- {1: 827, 2: 584}\n"
"..."
msgstr ""

#: ../doc/book/replication/repl_architecture.rst:113
msgid "Here ``vclock`` contains log sequence numbers (827 and 584) for instances with instance IDs 1 and 2."
msgstr ""

#: ../doc/book/replication/repl_architecture.rst:116
msgid "Starting in Tarantool 1.7.7, it is possible for administrators to assign the instance UUID and the replica set UUID values, rather than let the system generate them -- see the description of the :ref:`replicaset_uuid <cfg_replication-replicaset_uuid>` configuration parameter."
msgstr ""

#: ../doc/book/replication/repl_architecture.rst:125
msgid "Replication setup"
msgstr ""

#: ../doc/book/replication/repl_architecture.rst:127
msgid "To enable replication, you need to specify two parameters in a ``box.cfg{}`` request:"
msgstr ""

#: ../doc/book/replication/repl_architecture.rst:130
msgid ":ref:`replication <cfg_replication-replication>` which defines the replication source(s), and"
msgstr ""

#: ../doc/book/replication/repl_architecture.rst:132
msgid ":ref:`read_only <cfg_basic-read_only>` which is ``true`` for a replica and ``false`` for a master."
msgstr ""

#: ../doc/book/replication/repl_architecture.rst:135
msgid "Both these parameters are \"dynamic\". This allows a replica to become a master and vice versa on the fly with the help of a ``box.cfg{}`` request."
msgstr ""

#: ../doc/book/replication/repl_architecture.rst:138
msgid "Later we will give a detailed example of :ref:`bootstrapping a replica set <replication-bootstrap>`."
msgstr ""

#: ../doc/book/replication/repl_architecture.rst:145
msgid "Replication roles: master and replica"
msgstr ""

#: ../doc/book/replication/repl_architecture.rst:147
msgid "The replication role (master or replica) is set by the :ref:`read_only <cfg_basic-read_only>` configuration parameter. The recommended role is \"read_only\" (replica) for all but one instance in the replica set."
msgstr ""

#: ../doc/book/replication/repl_architecture.rst:151
msgid "In a master-replica configuration, every change that happens on the master will be visible on the replicas, but not vice versa."
msgstr ""

#: ../doc/book/replication/repl_architecture.rst:157
msgid "A simple two-instance replica set with the master on one machine and the replica on a different machine provides two benefits:"
msgstr ""

#: ../doc/book/replication/repl_architecture.rst:160
msgid "**failover**, because if the master goes down then the replica can take over, and"
msgstr ""

#: ../doc/book/replication/repl_architecture.rst:162
msgid "**load balancing**, because clients can connect to either the master or the replica for read requests."
msgstr ""

#: ../doc/book/replication/repl_architecture.rst:165
msgid "In a **master-master** configuration (also called \"multi-master\"), every change that happens on either instance will be visible on the other one."
msgstr ""

#: ../doc/book/replication/repl_architecture.rst:171
msgid "The failover benefit in this case is still present, and the load-balancing benefit is enhanced, because any instance can handle both read and write requests. Meanwhile, for multi-master configurations, it is necessary to understand the **replication guarantees** provided by the asynchronous protocol that Tarantool implements."
msgstr ""

#: ../doc/book/replication/repl_architecture.rst:177
msgid "Tarantool multi-master replication guarantees that each change on each master is propagated to all instances and is applied only once. Changes from the same instance are applied in the same order as on the originating instance. Changes from different instances, however, can be mixed and applied in a different order on different instances. This may lead to replication going out of sync in certain cases."
msgstr ""

#: ../doc/book/replication/repl_architecture.rst:184
msgid "For example, assuming the database is only appended to (i.e. it contains only insertions), a multi-master configuration is safe. If there are also deletions, but it is not mission critical that deletion happens in the same order on all replicas (e.g. the DELETE is used to prune expired data), a master-master configuration is also safe."
msgstr ""

#: ../doc/book/replication/repl_architecture.rst:190
msgid "UPDATE operations, however, can easily go out of sync. For example, assignment and increment are not commutative, and may yield different results if applied in different order on different instances."
msgstr ""

#: ../doc/book/replication/repl_architecture.rst:194
msgid "More generally, it is only safe to use Tarantool master-master replication if all database changes are **commutative**: the end result does not depend on the order in which the changes are applied. You can start learning more about conflict-free replicated data types `here <https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type>`_."
msgstr ""

#: ../doc/book/replication/repl_architecture.rst:204
msgid "Replication topologies: cascade, ring and full mesh"
msgstr ""

#: ../doc/book/replication/repl_architecture.rst:206
msgid "Replication topology is set by the :ref:`replication <cfg_replication-replication>` configuration parameter. The recommended topology is a **full mesh**, because it makes potential failover easy."
msgstr ""

#: ../doc/book/replication/repl_architecture.rst:210
msgid "Some database products offer **cascading replication** topologies: creating a replica on a replica. Tarantool does not recommend such setup."
msgstr ""

#: ../doc/book/replication/repl_architecture.rst:216
msgid "The problem with a cascading replica set is that some instances have no connection to other instances and may not receive changes from them. One essential change that must be propagated across all instances in a replica set is an entry in ``box.space._cluster`` system space with the replica set UUID. Without knowing the replica set UUID, a master refuses to accept connections from such instances when replication topology changes. Here is how this can happen:"
msgstr ""

#: ../doc/book/replication/repl_architecture.rst:226
msgid "We have a chain of three instances. Instance #1 contains entries for instances #1 and #2 in its ``_cluster`` space. Instances #2 and #3 contain entries for instances #1, #2 and #3 in their ``_cluster`` spaces."
msgstr ""

#: ../doc/book/replication/repl_architecture.rst:233
msgid "Now instance #2 is faulty. Instance #3 tries connecting to instance #1 as its new master, but the master refuses the connection since it has no entry for instance #3."
msgstr ""

#: ../doc/book/replication/repl_architecture.rst:237
msgid "**Ring replication** topology is, however, supported:"
msgstr ""

#: ../doc/book/replication/repl_architecture.rst:242
msgid "So, if you need a cascading topology, you may first create a ring to ensure all instances know each other’s UUID, and then disconnect the chain in the place you desire."
msgstr ""

#: ../doc/book/replication/repl_architecture.rst:246
msgid "A stock recommendation for a master-master replication topology, however, is a **full mesh**:"
msgstr ""

#: ../doc/book/replication/repl_architecture.rst:252
msgid "You then can decide where to locate instances of the mesh -- within the same data center, or spread across a few data centers. Tarantool will automatically ensure that each row is applied only once on each instance. To remove a degraded instance from a mesh, simply change the ``replication`` configuration parameter."
msgstr ""

#: ../doc/book/replication/repl_architecture.rst:257
msgid "This ensures full cluster availability in case of a local failure, e.g. one of the instances failing in one of the data centers, as well as in case of an entire data center failure."
msgstr ""

#: ../doc/book/replication/repl_architecture.rst:261
msgid "The maximal number of replicas in a mesh is 32."
msgstr ""

#: ../doc/book/replication/repl_bootstrap.rst:5
msgid "Bootstrapping a replica set"
msgstr ""

#: ../doc/book/replication/repl_bootstrap.rst:11
msgid "Master-replica bootstrap"
msgstr ""

#: ../doc/book/replication/repl_bootstrap.rst:13
msgid "Let us first bootstrap a simple **master-replica** set containing two instances, each located on its own machine. For easier administration, we make the :ref:`instance files <admin-instance_file>` almost identical."
msgstr ""

#: ../doc/book/replication/repl_bootstrap.rst:20
msgid "Here is an example of the master's instance file:"
msgstr ""

#: ../doc/book/replication/repl_bootstrap.rst:22
msgid "-- instance file for the master\n"
"box.cfg{\n"
"  listen = 3301,\n"
"  replication = {'replicator:password@192.168.0.101:3301',  -- master URI\n"
"                 'replicator:password@192.168.0.102:3301'}, -- replica URI\n"
"  read_only = false\n"
"}\n"
"box.once(\"schema\", function()\n"
"   box.schema.user.create('replicator', {password = 'password'})\n"
"   box.schema.user.grant('replicator', 'replication') -- grant replication role\n"
"   box.schema.space.create(\"test\")\n"
"   box.space.test:create_index(\"primary\")\n"
"   print('box.once executed on master')\n"
"end)"
msgstr ""

#: ../doc/book/replication/repl_bootstrap.rst:41
msgid "the ``box.cfg()`` :ref:`listen <cfg_basic-listen>` parameter defines a URI (port 3301 in our example), on which the master can accept connections from replicas."
msgstr ""

#: ../doc/book/replication/repl_bootstrap.rst:44
msgid "the ``box.cfg()`` :ref:`replication <cfg_replication-replication>` parameter defines the URIs at which all instances in the replica set can accept connections. It includes the replica's URI as well, although the replica is not a replication source right now."
msgstr ""

#: ../doc/book/replication/repl_bootstrap.rst:51
msgid "For security reasons, we recommend that administrators prevent unauthorized replication sources by associating a password with every user that has a replication :ref:`role <authentication-roles>`. That way, the :ref:`URI <index-uri>` for ``replication`` parameter must have the long form ``username:password@host:port``."
msgstr ""

#: ../doc/book/replication/repl_bootstrap.rst:57
msgid "the :ref:`read_only = false <cfg_basic-read_only>` parameter setting enables data-change operations on the instance and makes the instance act as a master, not as a replica. *That is the only parameter setting in our instance files that will differ.*"
msgstr ""

#: ../doc/book/replication/repl_bootstrap.rst:61
msgid "the :ref:`box.once() <box-once>` function contains database initialization logic that should be executed only once during the replica set lifetime."
msgstr ""

#: ../doc/book/replication/repl_bootstrap.rst:64
msgid "In this example, we create a space with a primary index, and a user for replication purposes. We also say ``print('box.once executed on master')`` so that it will later be visible on a console whether ``box.once()`` was executed."
msgstr ""

#: ../doc/book/replication/repl_bootstrap.rst:70
msgid "Replication requires privileges. We can grant privileges for accessing spaces directly to the user who will start the instance. However, it is more usual to grant privileges for accessing spaces to a :ref:`role <authentication-roles>`, and then grant the role to the user who will start the replica."
msgstr ""

#: ../doc/book/replication/repl_bootstrap.rst:76
msgid "Here we use Tarantool's predefined role named \"replication\" which by default grants \"read\" privileges for all database objects (\"universe\"), and we can change privileges for this role as required."
msgstr ""

#: ../doc/book/replication/repl_bootstrap.rst:80
msgid "In the replica's instance file, we set the ``read_only`` parameter to \"true\", and say ``print('box.once executed on replica')`` so that later it will be visible that ``box.once()`` was not executed more than once. Otherwise the replica's instance file is identical to the master's instance file."
msgstr ""

#: ../doc/book/replication/repl_bootstrap.rst:85
msgid "-- instance file for the replica\n"
"box.cfg{\n"
"  listen = 3301,\n"
"  replication = {'replicator:password@192.168.0.101:3301',  -- master URI\n"
"                 'replicator:password@192.168.0.102:3301'}, -- replica URI\n"
"  read_only = true\n"
"}\n"
"box.once(\"schema\", function()\n"
"   box.schema.user.create('replicator', {password = 'password'})\n"
"   box.schema.user.grant('replicator', 'replication') -- grant replication role\n"
"   box.schema.space.create(\"test\")\n"
"   box.space.test:create_index(\"primary\")\n"
"   print('box.once executed on replica')\n"
"end)"
msgstr ""

#: ../doc/book/replication/repl_bootstrap.rst:104
msgid "The replica does not inherit the master’s configuration parameters, such as those making the :ref:`checkpoint daemon <book_cfg_checkpoint_daemon>` run on the master. To get the same behavior, set the relevant parameters explicitly so that they are the same on both master and replica."
msgstr ""

#: ../doc/book/replication/repl_bootstrap.rst:109
msgid "Now we can launch the two instances. The master..."
msgstr ""

#: ../doc/book/replication/repl_bootstrap.rst:111
msgid "$ # launching the master\n"
"$ tarantool master.lua\n"
"2017-06-14 14:12:03.847 [18933] main/101/master.lua C> version 1.7.4-52-g980d30092\n"
"2017-06-14 14:12:03.848 [18933] main/101/master.lua C> log level 5\n"
"2017-06-14 14:12:03.849 [18933] main/101/master.lua I> mapping 268435456 bytes for tuple arena...\n"
"2017-06-14 14:12:03.859 [18933] iproto/101/main I> binary: bound to [::]:3301\n"
"2017-06-14 14:12:03.861 [18933] main/105/applier/replicator@192.168.0. I> can't connect to master\n"
"2017-06-14 14:12:03.861 [18933] main/105/applier/replicator@192.168.0. coio.cc:105 !> SystemError connect, called on fd 14, aka 192.168.0.102:56736: Connection refused\n"
"2017-06-14 14:12:03.861 [18933] main/105/applier/replicator@192.168.0. I> will retry every 1 second\n"
"2017-06-14 14:12:03.861 [18933] main/104/applier/replicator@192.168.0. I> remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 14:12:19.878 [18933] main/105/applier/replicator@192.168.0. I> remote master is 1.7.4 at 192.168.0.102:3301\n"
"2017-06-14 14:12:19.879 [18933] main/101/master.lua I> initializing an empty data directory\n"
"2017-06-14 14:12:19.908 [18933] snapshot/101/main I> saving snapshot `/var/lib/tarantool/master/00000000000000000000.snap.inprogress'\n"
"2017-06-14 14:12:19.914 [18933] snapshot/101/main I> done\n"
"2017-06-14 14:12:19.914 [18933] main/101/master.lua I> vinyl checkpoint done\n"
"2017-06-14 14:12:19.917 [18933] main/101/master.lua I> ready to accept requests\n"
"2017-06-14 14:12:19.918 [18933] main/105/applier/replicator@192.168.0. I> failed to authenticate\n"
"2017-06-14 14:12:19.918 [18933] main/105/applier/replicator@192.168.0. xrow.cc:431 E> ER_LOADING: Instance bootstrap hasn't finished yet\n"
"box.once executed on master\n"
"2017-06-14 14:12:19.920 [18933] main C> entering the event loop"
msgstr ""

#: ../doc/book/replication/repl_bootstrap.rst:134
msgid "... (the display confirms that ``box.once()`` was executed on the master) -- and the replica:"
msgstr ""

#: ../doc/book/replication/repl_bootstrap.rst:136
msgid "$ # launching the replica\n"
"$ tarantool replica.lua\n"
"2017-06-14 14:12:19.486 [18934] main/101/replica.lua C> version 1.7.4-52-g980d30092\n"
"2017-06-14 14:12:19.486 [18934] main/101/replica.lua C> log level 5\n"
"2017-06-14 14:12:19.487 [18934] main/101/replica.lua I> mapping 268435456 bytes for tuple arena...\n"
"2017-06-14 14:12:19.494 [18934] iproto/101/main I> binary: bound to [::]:3311\n"
"2017-06-14 14:12:19.495 [18934] main/104/applier/replicator@192.168.0. I> remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 14:12:19.495 [18934] main/105/applier/replicator@192.168.0. I> remote master is 1.7.4 at 192.168.0.102:3302\n"
"2017-06-14 14:12:19.496 [18934] main/104/applier/replicator@192.168.0. I> failed to authenticate\n"
"2017-06-14 14:12:19.496 [18934] main/104/applier/replicator@192.168.0. xrow.cc:431 E> ER_LOADING: Instance bootstrap hasn't finished yet"
msgstr ""

#: ../doc/book/replication/repl_bootstrap.rst:149
msgid "In both logs, there are messages saying that the replica was bootstrapped from the master:"
msgstr ""

#: ../doc/book/replication/repl_bootstrap.rst:151
msgid "$ # bootstrapping the replica (from the master's log)\n"
"<...>\n"
"2017-06-14 14:12:20.503 [18933] main/106/main I> initial data sent.\n"
"2017-06-14 14:12:20.505 [18933] relay/[::ffff:192.168.0.101]:/101/main I> recover from `/var/lib/tarantool/master/00000000000000000000.xlog'\n"
"2017-06-14 14:12:20.505 [18933] main/106/main I> final data sent.\n"
"2017-06-14 14:12:20.522 [18933] relay/[::ffff:192.168.0.101]:/101/main I> recover from `/Users/e.shebunyaeva/work/tarantool-test-repl/master_dir/00000000000000000000.xlog'\n"
"2017-06-14 14:12:20.922 [18933] main/105/applier/replicator@192.168.0. I> authenticated"
msgstr ""

#: ../doc/book/replication/repl_bootstrap.rst:161
msgid "$ # bootstrapping the replica (from the replica's log)\n"
"<...>\n"
"2017-06-14 14:12:20.498 [18934] main/104/applier/replicator@192.168.0. I> authenticated\n"
"2017-06-14 14:12:20.498 [18934] main/101/replica.lua I> bootstrapping replica from 192.168.0.101:3301\n"
"2017-06-14 14:12:20.512 [18934] main/104/applier/replicator@192.168.0. I> initial data received\n"
"2017-06-14 14:12:20.512 [18934] main/104/applier/replicator@192.168.0. I> final data received\n"
"2017-06-14 14:12:20.517 [18934] snapshot/101/main I> saving snapshot `/var/lib/tarantool/replica/00000000000000000005.snap.inprogress'\n"
"2017-06-14 14:12:20.518 [18934] snapshot/101/main I> done\n"
"2017-06-14 14:12:20.519 [18934] main/101/replica.lua I> vinyl checkpoint done\n"
"2017-06-14 14:12:20.520 [18934] main/101/replica.lua I> ready to accept requests\n"
"2017-06-14 14:12:20.520 [18934] main/101/replica.lua I> set 'read_only' configuration option to true\n"
"2017-06-14 14:12:20.520 [18934] main C> entering the event loop"
msgstr ""

#: ../doc/book/replication/repl_bootstrap.rst:176
msgid "Notice that ``box.once()`` was executed only at the master, although we added ``box.once()`` to both instance files."
msgstr ""

#: ../doc/book/replication/repl_bootstrap.rst:179
msgid "We could as well launch the replica first:"
msgstr ""

#: ../doc/book/replication/repl_bootstrap.rst:181
msgid "$ # launching the replica\n"
"$ tarantool replica.lua\n"
"2017-06-14 14:35:36.763 [18952] main/101/replica.lua C> version 1.7.4-52-g980d30092\n"
"2017-06-14 14:35:36.765 [18952] main/101/replica.lua C> log level 5\n"
"2017-06-14 14:35:36.765 [18952] main/101/replica.lua I> mapping 268435456 bytes for tuple arena...\n"
"2017-06-14 14:35:36.772 [18952] iproto/101/main I> binary: bound to [::]:3301\n"
"2017-06-14 14:35:36.772 [18952] main/104/applier/replicator@192.168.0. I> can't connect to master\n"
"2017-06-14 14:35:36.772 [18952] main/104/applier/replicator@192.168.0. coio.cc:105 !> SystemError connect, called on fd 13, aka 192.168.0.101:56820: Connection refused\n"
"2017-06-14 14:35:36.772 [18952] main/104/applier/replicator@192.168.0. I> will retry every 1 second\n"
"2017-06-14 14:35:36.772 [18952] main/105/applier/replicator@192.168.0. I> remote master is 1.7.4 at 192.168.0.102:3301"
msgstr ""

#: ../doc/book/replication/repl_bootstrap.rst:194
msgid "... and the master later:"
msgstr ""

#: ../doc/book/replication/repl_bootstrap.rst:196
msgid "$ # launching the master\n"
"$ tarantool master.lua\n"
"2017-06-14 14:35:43.701 [18953] main/101/master.lua C> version 1.7.4-52-g980d30092\n"
"2017-06-14 14:35:43.702 [18953] main/101/master.lua C> log level 5\n"
"2017-06-14 14:35:43.702 [18953] main/101/master.lua I> mapping 268435456 bytes for tuple arena...\n"
"2017-06-14 14:35:43.709 [18953] iproto/101/main I> binary: bound to [::]:3301\n"
"2017-06-14 14:35:43.709 [18953] main/105/applier/replicator@192.168.0. I> remote master is 1.7.4 at 192.168.0.102:3301\n"
"2017-06-14 14:35:43.709 [18953] main/104/applier/replicator@192.168.0. I> remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 14:35:43.709 [18953] main/101/master.lua I> initializing an empty data directory\n"
"2017-06-14 14:35:43.721 [18953] snapshot/101/main I> saving snapshot `/var/lib/tarantool/master/00000000000000000000.snap.inprogress'\n"
"2017-06-14 14:35:43.722 [18953] snapshot/101/main I> done\n"
"2017-06-14 14:35:43.723 [18953] main/101/master.lua I> vinyl checkpoint done\n"
"2017-06-14 14:35:43.723 [18953] main/101/master.lua I> ready to accept requests\n"
"2017-06-14 14:35:43.724 [18953] main/105/applier/replicator@192.168.0. I> failed to authenticate\n"
"2017-06-14 14:35:43.724 [18953] main/105/applier/replicator@192.168.0. xrow.cc:431 E> ER_LOADING: Instance bootstrap hasn't finished yet\n"
"box.once executed on master\n"
"2017-06-14 14:35:43.726 [18953] main C> entering the event loop\n"
"2017-06-14 14:35:43.779 [18953] main/103/main I> initial data sent.\n"
"2017-06-14 14:35:43.780 [18953] relay/[::ffff:192.168.0.101]:/101/main I> recover from `/var/lib/tarantool/master/00000000000000000000.xlog'\n"
"2017-06-14 14:35:43.780 [18953] main/103/main I> final data sent.\n"
"2017-06-14 14:35:43.796 [18953] relay/[::ffff:192.168.0.102]:/101/main I> recover from `/var/lib/tarantool/master/00000000000000000000.xlog'\n"
"2017-06-14 14:35:44.726 [18953] main/105/applier/replicator@192.168.0. I> authenticated"
msgstr ""

#: ../doc/book/replication/repl_bootstrap.rst:221
msgid "In this case, the replica would wait for the master to become available, so the launch order doesn't matter. Our ``box.once()`` logic would also be executed only once, at the master."
msgstr ""

#: ../doc/book/replication/repl_bootstrap.rst:225
msgid "$ # the replica has eventually connected to the master\n"
"$ # and got bootstrapped (from the replica's log)\n"
"2017-06-14 14:35:43.777 [18952] main/104/applier/replicator@192.168.0. I> remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 14:35:43.777 [18952] main/104/applier/replicator@192.168.0. I> authenticated\n"
"2017-06-14 14:35:43.777 [18952] main/101/replica.lua I> bootstrapping replica from 192.168.0.199:3310\n"
"2017-06-14 14:35:43.788 [18952] main/104/applier/replicator@192.168.0. I> initial data received\n"
"2017-06-14 14:35:43.789 [18952] main/104/applier/replicator@192.168.0. I> final data received\n"
"2017-06-14 14:35:43.793 [18952] snapshot/101/main I> saving snapshot `/var/lib/tarantool/replica/00000000000000000005.snap.inprogress'\n"
"2017-06-14 14:35:43.793 [18952] snapshot/101/main I> done\n"
"2017-06-14 14:35:43.795 [18952] main/101/replica.lua I> vinyl checkpoint done\n"
"2017-06-14 14:35:43.795 [18952] main/101/replica.lua I> ready to accept requests\n"
"2017-06-14 14:35:43.795 [18952] main/101/replica.lua I> set 'read_only' configuration option to true\n"
"2017-06-14 14:35:43.795 [18952] main C> entering the event loop"
msgstr ""

#: ../doc/book/replication/repl_bootstrap.rst:245
msgid "Controlled failover"
msgstr ""

#: ../doc/book/replication/repl_bootstrap.rst:247
msgid "To perform a **controlled failover**, that is, swap the roles of the master and replica, all we need to do is to set ``read_only=true`` at the master, and ``read_only=false`` at the replica. The order of actions is important here. If a system is running in production, we do not want concurrent writes happening both at the replica and the master. Nor do we want the new replica to accept any writes until it has finished fetching all replication data from the old master. To compare replica and master state, we can use :ref:`box.info.signature <box_introspection-box_info>`."
msgstr ""

#: ../doc/book/replication/repl_bootstrap.rst:256
msgid "Set ``read_only=true`` at the master."
msgstr ""

#: ../doc/book/replication/repl_bootstrap.rst:258
msgid "# at the master\n"
"tarantool> box.cfg{read_only=true}"
msgstr ""

#: ../doc/book/replication/repl_bootstrap.rst:263
msgid "Record the master’s current position with ``box.info.signature``, containing the sum of all LSNs in the master’s vector clock."
msgstr ""

#: ../doc/book/replication/repl_bootstrap.rst:266
msgid "# at the master\n"
"tarantool> box.info.signature"
msgstr ""

#: ../doc/book/replication/repl_bootstrap.rst:271
msgid "Wait until the replica’s signature is the same as the master’s."
msgstr ""

#: ../doc/book/replication/repl_bootstrap.rst:273
msgid "# at the replica\n"
"tarantool> box.info.signature"
msgstr ""

#: ../doc/book/replication/repl_bootstrap.rst:278
msgid "Set ``read_only=false`` at the replica to enable write operations."
msgstr ""

#: ../doc/book/replication/repl_bootstrap.rst:280
msgid "# at the replica\n"
"tarantool> box.cfg{read_only=false}"
msgstr ""

#: ../doc/book/replication/repl_bootstrap.rst:285
msgid "These four steps ensure that the replica doesn’t accept new writes until it’s done fetching writes from the master."
msgstr ""

#: ../doc/book/replication/repl_bootstrap.rst:292
msgid "Master-master bootstrap"
msgstr ""

#: ../doc/book/replication/repl_bootstrap.rst:294
msgid "Now let us bootstrap a two-instance **master-master** set. For easier administration, we make master#1 and master#2 instance files fully identical."
msgstr ""

#: ../doc/book/replication/repl_bootstrap.rst:300
msgid "We re-use the master's instance file from the :ref:`master-replica example <replication-master_replica_bootstrap>` above."
msgstr ""

#: ../doc/book/replication/repl_bootstrap.rst:303
msgid "-- instance file for any of the two masters\n"
"box.cfg{\n"
"  listen      = 3301,\n"
"  replication = {'replicator:password@192.168.0.101:3301',  -- master1 URI\n"
"                 'replicator:password@192.168.0.102:3301'}, -- master2 URI\n"
"  read_only   = false\n"
"}\n"
"box.once(\"schema\", function()\n"
"   box.schema.user.create('replicator', {password = 'password'})\n"
"   box.schema.user.grant('replicator', 'replication') -- grant replication role\n"
"   box.schema.space.create(\"test\")\n"
"   box.space.test:create_index(\"primary\")\n"
"   print('box.once executed on master #1')\n"
"end)"
msgstr ""

#: ../doc/book/replication/repl_bootstrap.rst:320
msgid "In the :ref:`replication <cfg_replication-replication>` parameter, we define the URIs of both masters in the replica set and say ``print('box.once executed on master #1')`` so it will be clear when and where the ``box.once()`` logic is executed."
msgstr ""

#: ../doc/book/replication/repl_bootstrap.rst:325
msgid "Now we can launch the two masters. Again, the launch order doesn't matter. The ``box.once()`` logic will also be executed only once, at the master which is elected as the replica set :ref:`leader <replication-leader>` at bootstrap."
msgstr ""

#: ../doc/book/replication/repl_bootstrap.rst:329
msgid "$ # launching master #1\n"
"$ tarantool master1.lua\n"
"2017-06-14 15:39:03.062 [47021] main/101/master1.lua C> version 1.7.4-52-g980d30092\n"
"2017-06-14 15:39:03.062 [47021] main/101/master1.lua C> log level 5\n"
"2017-06-14 15:39:03.063 [47021] main/101/master1.lua I> mapping 268435456 bytes for tuple arena...\n"
"2017-06-14 15:39:03.065 [47021] iproto/101/main I> binary: bound to [::]:3301\n"
"2017-06-14 15:39:03.065 [47021] main/105/applier/replicator@192.168.0.10 I> can't connect to master\n"
"2017-06-14 15:39:03.065 [47021] main/105/applier/replicator@192.168.0.10 coio.cc:107 !> SystemError connect, called on fd 14, aka 192.168.0.102:57110: Connection refused\n"
"2017-06-14 15:39:03.065 [47021] main/105/applier/replicator@192.168.0.10 I> will retry every 1 second\n"
"2017-06-14 15:39:03.065 [47021] main/104/applier/replicator@192.168.0.10 I> remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 15:39:08.070 [47021] main/105/applier/replicator@192.168.0.10 I> remote master is 1.7.4 at 192.168.0.102:3301\n"
"2017-06-14 15:39:08.071 [47021] main/105/applier/replicator@192.168.0.10 I> authenticated\n"
"2017-06-14 15:39:08.071 [47021] main/101/master1.lua I> bootstrapping replica from 192.168.0.102:3301\n"
"2017-06-14 15:39:08.073 [47021] main/105/applier/replicator@192.168.0.10 I> initial data received\n"
"2017-06-14 15:39:08.074 [47021] main/105/applier/replicator@192.168.0.10 I> final data received\n"
"2017-06-14 15:39:08.074 [47021] snapshot/101/main I> saving snapshot `/Users/e.shebunyaeva/work/tarantool-test-repl/master1_dir/00000000000000000008.snap.inprogress'\n"
"2017-06-14 15:39:08.074 [47021] snapshot/101/main I> done\n"
"2017-06-14 15:39:08.076 [47021] main/101/master1.lua I> vinyl checkpoint done\n"
"2017-06-14 15:39:08.076 [47021] main/101/master1.lua I> ready to accept requests\n"
"box.once executed on master #1\n"
"2017-06-14 15:39:08.077 [47021] main C> entering the event loop"
msgstr ""

#: ../doc/book/replication/repl_bootstrap.rst:353
msgid "$ # launching master #2\n"
"$ tarantool master2.lua\n"
"2017-06-14 15:39:07.452 [47022] main/101/master2.lua C> version 1.7.4-52-g980d30092\n"
"2017-06-14 15:39:07.453 [47022] main/101/master2.lua C> log level 5\n"
"2017-06-14 15:39:07.453 [47022] main/101/master2.lua I> mapping 268435456 bytes for tuple arena...\n"
"2017-06-14 15:39:07.455 [47022] iproto/101/main I> binary: bound to [::]:3301\n"
"2017-06-14 15:39:07.455 [47022] main/104/applier/replicator@192.168.0.19 I> remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 15:39:07.455 [47022] main/105/applier/replicator@192.168.0.10 I> remote master is 1.7.4 at 192.168.0.102:3301\n"
"2017-06-14 15:39:07.455 [47022] main/101/master2.lua I> initializing an empty data directory\n"
"2017-06-14 15:39:07.457 [47022] snapshot/101/main I> saving snapshot `/Users/e.shebunyaeva/work/tarantool-test-repl/master2_dir/00000000000000000000.snap.inprogress'\n"
"2017-06-14 15:39:07.457 [47022] snapshot/101/main I> done\n"
"2017-06-14 15:39:07.458 [47022] main/101/master2.lua I> vinyl checkpoint done\n"
"2017-06-14 15:39:07.459 [47022] main/101/master2.lua I> ready to accept requests\n"
"2017-06-14 15:39:07.460 [47022] main C> entering the event loop\n"
"2017-06-14 15:39:08.072 [47022] main/103/main I> initial data sent.\n"
"2017-06-14 15:39:08.073 [47022] relay/[::ffff:192.168.0.102]:/101/main I> recover from `/Users/e.shebunyaeva/work/tarantool-test-repl/master2_dir/00000000000000000000.xlog'\n"
"2017-06-14 15:39:08.073 [47022] main/103/main I> final data sent.\n"
"2017-06-14 15:39:08.077 [47022] relay/[::ffff:192.168.0.102]:/101/main I> recover from `/Users/e.shebunyaeva/work/tarantool-test-repl/master2_dir/00000000000000000000.xlog'\n"
"2017-06-14 15:39:08.461 [47022] main/104/applier/replicator@192.168.0.10 I> authenticated"
msgstr ""

#: ../doc/book/replication/repl_duplicates.rst:5
msgid "Preventing duplicate actions"
msgstr ""

#: ../doc/book/replication/repl_duplicates.rst:7
msgid "Tarantool guarantees that every update is applied only once on every replica. However, due to the asynchronous nature of replication, the order of updates is not guaranteed. We now analyze this problem with more details, provide examples of replication going out of sync, and suggest solutions."
msgstr ""

#: ../doc/book/replication/repl_duplicates.rst:16
msgid "Replication stops"
msgstr ""

#: ../doc/book/replication/repl_duplicates.rst:18
msgid "In a replica set of two masters, suppose master #1 tries to do something that master #2 has already done. For example, try to insert a tuple with the same unique key:"
msgstr ""

#: ../doc/book/replication/repl_duplicates.rst:22
msgid "tarantool> box.space.tester:insert{1, 'data'}"
msgstr ""

#: ../doc/book/replication/repl_duplicates.rst:26
msgid "This would cause an error saying ``Duplicate key exists in unique index 'primary' in space 'tester'`` and the replication would be stopped. (This is the behavior when the :ref:`replication_skip_conflict <cfg_replication-replication_skip_conflict>` configuration parameter has its default recommended value, ``false``.)"
msgstr ""

#: ../doc/book/replication/repl_duplicates.rst:32
msgid "$ # error messages from master #1\n"
"2017-06-26 21:17:03.233 [30444] main/104/applier/rep_user@100.96.166.1 I> can't read row\n"
"2017-06-26 21:17:03.233 [30444] main/104/applier/rep_user@100.96.166.1 memtx_hash.cc:226 E> ER_TUPLE_FOUND:\n"
"Duplicate key exists in unique index 'primary' in space 'tester'\n"
"2017-06-26 21:17:03.233 [30444] relay/[::ffff:100.96.166.178]/101/main I> the replica has closed its socket, exiting\n"
"2017-06-26 21:17:03.233 [30444] relay/[::ffff:100.96.166.178]/101/main C> exiting the relay loop\n"
"\n"
"$ # error messages from master #2\n"
"2017-06-26 21:17:03.233 [30445] main/104/applier/rep_user@100.96.166.1 I> can't read row\n"
"2017-06-26 21:17:03.233 [30445] main/104/applier/rep_user@100.96.166.1 memtx_hash.cc:226 E> ER_TUPLE_FOUND:\n"
"Duplicate key exists in unique index 'primary' in space 'tester'\n"
"2017-06-26 21:17:03.234 [30445] relay/[::ffff:100.96.166.178]/101/main I> the replica has closed its socket, exiting\n"
"2017-06-26 21:17:03.234 [30445] relay/[::ffff:100.96.166.178]/101/main C> exiting the relay loop"
msgstr ""

#: ../doc/book/replication/repl_duplicates.rst:48
msgid "If we check replication statuses with ``box.info``, we will see that replication at master #1 is stopped (``1.upstream.status = stopped``). Additionally, no data is replicated from that master (section ``1.downstream`` is missing in the report), because the downstream has encountered the same error:"
msgstr ""

#: ../doc/book/replication/repl_duplicates.rst:53
msgid "# replication statuses (report from master #3)\n"
"tarantool> box.info\n"
"---\n"
"- version: 1.7.4-52-g980d30092\n"
"  id: 3\n"
"  ro: false\n"
"  vclock: {1: 9, 2: 1000000, 3: 3}\n"
"  uptime: 557\n"
"  lsn: 3\n"
"  vinyl: []\n"
"  cluster:\n"
"    uuid: 34d13b1a-f851-45bb-8f57-57489d3b3c8b\n"
"  pid: 30445\n"
"  status: running\n"
"  signature: 1000012\n"
"  replication:\n"
"    1:\n"
"      id: 1\n"
"      uuid: 7ab6dee7-dc0f-4477-af2b-0e63452573cf\n"
"      lsn: 9\n"
"      upstream:\n"
"        peer: replicator@192.168.0.101:3301\n"
"        lag: 0.00050592422485352\n"
"        status: stopped\n"
"        idle: 445.8626639843\n"
"        message: Duplicate key exists in unique index 'primary' in space 'tester'\n"
"    2:\n"
"      id: 2\n"
"      uuid: 9afbe2d9-db84-4d05-9a7b-e0cbbf861e28\n"
"      lsn: 1000000\n"
"      upstream:\n"
"        status: follow\n"
"        idle: 201.99915885925\n"
"        peer: replicator@192.168.0.102:3301\n"
"        lag: 0.0015020370483398\n"
"      downstream:\n"
"        vclock: {1: 8, 2: 1000000, 3: 3}\n"
"    3:\n"
"      id: 3\n"
"      uuid: e826a667-eed7-48d5-a290-64299b159571\n"
"      lsn: 3\n"
"  uuid: e826a667-eed7-48d5-a290-64299b159571\n"
"..."
msgstr ""

#: ../doc/book/replication/repl_duplicates.rst:99
msgid "When replication is later manually resumed:"
msgstr ""

#: ../doc/book/replication/repl_duplicates.rst:101
msgid "# resuming stopped replication (at all masters)\n"
"tarantool> original_value = box.cfg.replication\n"
"tarantool> box.cfg{replication={}}\n"
"tarantool> box.cfg{replication=original_value}"
msgstr ""

#: ../doc/book/replication/repl_duplicates.rst:108
msgid "... the faulty row in the write-ahead-log files is skipped."
msgstr ""

#: ../doc/book/replication/repl_duplicates.rst:114
msgid "Replication runs out of sync"
msgstr ""

#: ../doc/book/replication/repl_duplicates.rst:116
msgid "In a master-master cluster of two instances, suppose we make the following operation:"
msgstr ""

#: ../doc/book/replication/repl_duplicates.rst:119
msgid "tarantool> box.space.tester:upsert({1}, {{'=', 2, box.info.uuid}})"
msgstr ""

#: ../doc/book/replication/repl_duplicates.rst:123
msgid "When this operation is applied on both instances in the replica set:"
msgstr ""

#: ../doc/book/replication/repl_duplicates.rst:125
msgid "# at master #1\n"
"tarantool> box.space.tester:upsert({1}, {{'=', 2, box.info.uuid}})\n"
"# at master #2\n"
"tarantool> box.space.tester:upsert({1}, {{'=', 2, box.info.uuid}})"
msgstr ""

#: ../doc/book/replication/repl_duplicates.rst:132
msgid "... we can have the following results, depending on the order of execution:"
msgstr ""

#: ../doc/book/replication/repl_duplicates.rst:134
msgid "each master’s row contains the UUID from master #1,"
msgstr ""

#: ../doc/book/replication/repl_duplicates.rst:135
msgid "each master’s row contains the UUID from master #2,"
msgstr ""

#: ../doc/book/replication/repl_duplicates.rst:136
msgid "master #1 has the UUID of master #2, and vice versa."
msgstr ""

#: ../doc/book/replication/repl_duplicates.rst:142
msgid "Commutative changes"
msgstr ""

#: ../doc/book/replication/repl_duplicates.rst:144
msgid "The cases described in the previous paragraphs represent examples of **non-commutative** operations, i.e. operations whose result depends on the execution order. On the contrary, for **commutative operations**, the execution order does not matter."
msgstr ""

#: ../doc/book/replication/repl_duplicates.rst:149
msgid "Consider for example the following command:"
msgstr ""

#: ../doc/book/replication/repl_duplicates.rst:151
msgid "tarantool> box.space.tester:upsert{{1, 0}, {{'+', 2, 1)}"
msgstr ""

#: ../doc/book/replication/repl_duplicates.rst:155
msgid "This operation is commutative: we get the same result no matter in which order the update is applied on the other masters."
msgstr ""

#: ../doc/book/replication/repl_monitoring.rst:5
msgid "Monitoring a replica set"
msgstr ""

#: ../doc/book/replication/repl_monitoring.rst:7
msgid "To learn what instances belong in the replica set, and obtain statistics for all these instances, issue a :ref:`box.info.replication <box_info_replication>` request:"
msgstr ""

#: ../doc/book/replication/repl_monitoring.rst:10
msgid "tarantool> box.info.replication\n"
"---\n"
"  replication:\n"
"    1:\n"
"      id: 1\n"
"      uuid: b8a7db60-745f-41b3-bf68-5fcce7a1e019\n"
"      lsn: 88\n"
"    2:\n"
"      id: 2\n"
"      uuid: cd3c7da2-a638-4c5d-ae63-e7767c3a6896\n"
"      lsn: 31\n"
"      upstream:\n"
"        status: follow\n"
"        idle: 43.187747001648\n"
"        peer: replicator@192.168.0.102:3301\n"
"        lag: 0\n"
"      downstream:\n"
"        vclock: {1: 31}\n"
"    3:\n"
"      id: 3\n"
"      uuid: e38ef895-5804-43b9-81ac-9f2cd872b9c4\n"
"      lsn: 54\n"
"      upstream:\n"
"        status: follow\n"
"        idle: 43.187621831894\n"
"        peer: replicator@192.168.0.103:3301\n"
"        lag: 2\n"
"      downstream:\n"
"        vclock: {1: 54}\n"
"..."
msgstr ""

#: ../doc/book/replication/repl_monitoring.rst:43
msgid "This report is for a master-master replica set of three instances, each having its own instance id, UUID and log sequence number."
msgstr ""

#: ../doc/book/replication/repl_monitoring.rst:49
msgid "The request was issued at master #1, and the reply includes statistics for the other two masters, given in regard to master #1."
msgstr ""

#: ../doc/book/replication/repl_monitoring.rst:52
msgid "The primary indicators of replication health are:"
msgstr ""

#: ../doc/book/replication/repl_monitoring.rst:56
msgid ":ref:`idle <box_info_replication_upstream_idle>`, the time (in seconds) since the instance received the last event from a master."
msgstr ""

#: ../doc/book/replication/repl_monitoring.rst:59
msgid "A replica sends heartbeat messages to the master every second, and the master is programmed to reconnect automatically if it does not see heartbeat messages within :ref:`replication_timeout <cfg_replication-replication_timeout>` seconds."
msgstr ""

#: ../doc/book/replication/repl_monitoring.rst:64
msgid "Therefore, in a healthy replication setup, ``idle`` should never exceed ``replication_timeout``: if it does, either the replication is lagging seriously behind, because the master is running ahead of the replica, or the network link between the instances is down."
msgstr ""

#: ../doc/book/replication/repl_monitoring.rst:69
msgid ":ref:`lag <box_info_replication_upstream_lag>`, the time difference between the local time at the instance, recorded when the event was received, and the local time at another master recorded when the event was written to the :ref:`write ahead log <internals-wal>` on that master."
msgstr ""

#: ../doc/book/replication/repl_monitoring.rst:74
msgid "Since the ``lag`` calculation uses the operating system clocks from two different machines, do not be surprised if it’s negative: a time drift may lead to the remote master clock being consistently behind the local instance's clock."
msgstr ""

#: ../doc/book/replication/repl_monitoring.rst:78
msgid "For multi-master configurations, ``lag`` is the maximal lag."
msgstr ""

#: ../doc/book/replication/repl_recover.rst:5
msgid "Recovering from a degraded state"
msgstr ""

#: ../doc/book/replication/repl_recover.rst:7
msgid "\"Degraded state\" is a situation when the master becomes unavailable -- due to hardware or network failure, or due to a programming bug."
msgstr ""

#: ../doc/book/replication/repl_recover.rst:13
msgid "In a master-replica set, if a master disappears, error messages appear on the replicas stating that the connection is lost:"
msgstr ""

#: ../doc/book/replication/repl_recover.rst:16
msgid "$ # messages from a replica's log\n"
"2017-06-14 16:23:10.993 [19153] main/105/applier/replicator@192.168.0. I> can't read row\n"
"2017-06-14 16:23:10.993 [19153] main/105/applier/replicator@192.168.0. coio.cc:349 !> SystemError\n"
"unexpected EOF when reading from socket, called on fd 17, aka 192.168.0.101:57815,\n"
"peer of 192.168.0.101:3301: Broken pipe\n"
"2017-06-14 16:23:10.993 [19153] main/105/applier/replicator@192.168.0. I> will retry every 1 second\n"
"2017-06-14 16:23:10.993 [19153] relay/[::ffff:192.168.0.101]:/101/main I> the replica has closed its socket, exiting\n"
"2017-06-14 16:23:10.993 [19153] relay/[::ffff:192.168.0.101]:/101/main C> exiting the relay loop"
msgstr ""

#: ../doc/book/replication/repl_recover.rst:27
msgid "... and the master's status is reported as \"disconnected\":"
msgstr ""

#: ../doc/book/replication/repl_recover.rst:29
msgid "# report from replica #1\n"
"tarantool> box.info.replication\n"
"---\n"
"- 1:\n"
"    id: 1\n"
"    uuid: 70e8e9dc-e38d-4046-99e5-d25419267229\n"
"    lsn: 542\n"
"    upstream:\n"
"      peer: replicator@192.168.0.101:3301\n"
"      lag: 0.00026607513427734\n"
"      status: disconnected\n"
"      idle: 182.36929893494\n"
"      message: connect, called on fd 13, aka 192.168.0.101:58244\n"
"  2:\n"
"    id: 2\n"
"    uuid: fb252ac7-5c34-4459-84d0-54d248b8c87e\n"
"    lsn: 0\n"
"  3:\n"
"    id: 3\n"
"    uuid: fd7681d8-255f-4237-b8bb-c4fb9d99024d\n"
"    lsn: 0\n"
"    downstream:\n"
"      vclock: {1: 542}\n"
"..."
msgstr ""

#: ../doc/book/replication/repl_recover.rst:56
msgid "# report from replica #2\n"
"tarantool> box.info.replication\n"
"---\n"
"- 1:\n"
"    id: 1\n"
"    uuid: 70e8e9dc-e38d-4046-99e5-d25419267229\n"
"    lsn: 542\n"
"    upstream:\n"
"      peer: replicator@192.168.0.101:3301\n"
"      lag: 0.00027203559875488\n"
"      status: disconnected\n"
"      idle: 186.76988101006\n"
"      message: connect, called on fd 13, aka 192.168.0.101:58253\n"
"  2:\n"
"    id: 2\n"
"    uuid: fb252ac7-5c34-4459-84d0-54d248b8c87e\n"
"    lsn: 0\n"
"    upstream:\n"
"      status: follow\n"
"      idle: 186.76960110664\n"
"      peer: replicator@192.168.0.102:3301\n"
"      lag: 0.00020599365234375\n"
"  3:\n"
"    id: 3\n"
"    uuid: fd7681d8-255f-4237-b8bb-c4fb9d99024d\n"
"    lsn: 0\n"
"..."
msgstr ""

#: ../doc/book/replication/repl_recover.rst:86
msgid "To declare that one of the replicas must now take over as a new master:"
msgstr ""

#: ../doc/book/replication/repl_recover.rst:88
msgid "Make sure that the old master is gone for good:"
msgstr ""

#: ../doc/book/replication/repl_recover.rst:90
msgid "change network routing rules to avoid any more packets being delivered to the master, or"
msgstr ""

#: ../doc/book/replication/repl_recover.rst:92
msgid "shut down the master instance, if you have access to the machine, or"
msgstr ""

#: ../doc/book/replication/repl_recover.rst:93
msgid "power off the container or the machine."
msgstr ""

#: ../doc/book/replication/repl_recover.rst:95
msgid "Say ``box.cfg{read_only=false, listen=URI}`` on the replica, and ``box.cfg{replication=URI}`` on the other replicas in the set."
msgstr ""

#: ../doc/book/replication/repl_recover.rst:100
msgid "If there are updates on the old master that were not propagated before the old master went down, :ref:`re-apply them manually <admin-disaster_recovery-master_replica>` to the new master using ``tarantoolctl cat`` and ``tarantoolctl play`` commands."
msgstr ""

#: ../doc/book/replication/repl_recover.rst:105
msgid "There is no automatic way for a replica to detect that the master is gone forever, since sources of failure and replication environments vary significantly. So the detection of degraded state requires an external observer."
msgstr ""

#: ../doc/book/replication/repl_remove_instances.rst:5
msgid "Removing instances"
msgstr ""

#: ../doc/book/replication/repl_remove_instances.rst:7
msgid "To remove an instance from a replica set politely, follow these steps:"
msgstr ""

#: ../doc/book/replication/repl_remove_instances.rst:9
msgid "On the instance, run ``box.cfg{}`` with a blank replication source:"
msgstr ""

#: ../doc/book/replication/repl_remove_instances.rst:11
msgid "tarantool> box.cfg{replication=''}\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/replication/repl_remove_instances.rst:17
msgid "The other instances in the replica set will carry on. If later the removed instance rejoins, it will receive all the updates that the other instances made while it was away."
msgstr ""

#: ../doc/book/replication/repl_remove_instances.rst:21
msgid "If the instance is decommissioned forever, delete the instance's record from the following locations:"
msgstr ""

#: ../doc/book/replication/repl_remove_instances.rst:24
msgid "the :ref:`replication <cfg_replication-replication>` parameter at all running instances in the replica set:"
msgstr ""

#: ../doc/book/replication/repl_remove_instances.rst:27
msgid "tarantool> box.cfg{replication=...}"
msgstr ""

#: ../doc/book/replication/repl_remove_instances.rst:31
msgid "the :ref:`box.space._cluster <box_space-cluster>` tuple on any master instance in the replica set. For example, for a record with instance id = 3:"
msgstr ""

#: ../doc/book/replication/repl_remove_instances.rst:34
msgid "tarantool> box.space._cluster:select{}\n"
"---\n"
"- - [1, '913f99c8-aee3-47f2-b414-53ed0ec5bf27']\n"
"  - [2, 'eac1aee7-cfeb-46cc-8503-3f8eb4c7de1e']\n"
"  - [3, '97f2d65f-2e03-4dc8-8df3-2469bd9ce61e']\n"
"...\n"
"tarantool> box.space._cluster:delete(3)\n"
"---\n"
"- [3, '97f2d65f-2e03-4dc8-8df3-2469bd9ce61e']\n"
"..."
msgstr ""

#: ../doc/book/replication/repl_reseed.rst:5
msgid "Reseeding a replica"
msgstr ""

#: ../doc/book/replication/repl_reseed.rst:7
msgid "If any of a replica's .xlog/.snap/.run files are corrupted or deleted, you can \"re-seed\" the replica:"
msgstr ""

#: ../doc/book/replication/repl_reseed.rst:10
msgid "Stop the replica and destroy all local database files (the ones with extensions .xlog/.snap/.run/.inprogress)."
msgstr ""

#: ../doc/book/replication/repl_reseed.rst:13
msgid "Delete the replica's record from the following locations:"
msgstr ""

#: ../doc/book/replication/repl_reseed.rst:15
msgid "the ``replication`` parameter at all running instances in the replica set."
msgstr ""

#: ../doc/book/replication/repl_reseed.rst:16
msgid "the ``box.space._cluster`` tuple on the master instance."
msgstr ""

#: ../doc/book/replication/repl_reseed.rst:18
msgid "See section :ref:`Removing instances <replication-remove_instances>` for details."
msgstr ""

#: ../doc/book/replication/repl_reseed.rst:21
msgid "Restart the replica with the same instance file to contact the master again. The replica will then catch up with the master by retrieving all the master’s tuples."
msgstr ""

#: ../doc/book/replication/repl_reseed.rst:27
msgid "Remember that this procedure works only if the master’s WAL files are present."
msgstr ""

#: ../doc/book/sql.rst:5
msgid "SQL"
msgstr ""

#: ../doc/book/sql.rst:7
msgid "In this section we will go through SQL:2016's \"Feature taxonomy and definition for mandatory features\"."
msgstr ""

#: ../doc/book/sql.rst:10
msgid "For each feature in that list, we will come up with a simple example SQL statement. If Tarantool appears to handle the example, we will mark it \"Okay\", else we will mark it \"Fail\". Since this is rough and arbitrary, we believe that tests which are unfairly marked \"Okay\" will probably be balanced by tests which are unfairly marked \"Fail\"."
msgstr ""

#: ../doc/book/sql.rst:23
msgid "Feature ID"
msgstr ""

#: ../doc/book/sql.rst:23
msgid "Feature"
msgstr ""

#: ../doc/book/sql.rst:23
msgid "Test"
msgstr ""

#: ../doc/book/sql.rst:25
msgid "E011"
msgstr ""

#: ../doc/book/sql.rst:25
msgid "Numeric data types"
msgstr ""

#: ../doc/book/sql.rst:27
msgid "E011-01"
msgstr ""

#: ../doc/book/sql.rst:27
msgid "INTEGER and SMALLINT"
msgstr ""

#: ../doc/book/sql.rst:27
msgid "``CREATE TABLE t (s1 INTEGER PRIMARY KEY);``"
msgstr ""

#: ../doc/book/sql.rst:27
#: ../doc/book/sql.rst:45
#: ../doc/book/sql.rst:47
#: ../doc/book/sql.rst:72
#: ../doc/book/sql.rst:74
#: ../doc/book/sql.rst:76
#: ../doc/book/sql.rst:94
#: ../doc/book/sql.rst:96
#: ../doc/book/sql.rst:100
#: ../doc/book/sql.rst:102
#: ../doc/book/sql.rst:104
#: ../doc/book/sql.rst:107
#: ../doc/book/sql.rst:111
#: ../doc/book/sql.rst:113
#: ../doc/book/sql.rst:119
#: ../doc/book/sql.rst:121
#: ../doc/book/sql.rst:123
#: ../doc/book/sql.rst:125
#: ../doc/book/sql.rst:127
#: ../doc/book/sql.rst:129
#: ../doc/book/sql.rst:133
#: ../doc/book/sql.rst:135
#: ../doc/book/sql.rst:137
#: ../doc/book/sql.rst:141
#: ../doc/book/sql.rst:144
#: ../doc/book/sql.rst:152
#: ../doc/book/sql.rst:160
#: ../doc/book/sql.rst:190
#: ../doc/book/sql.rst:192
#: ../doc/book/sql.rst:194
#: ../doc/book/sql.rst:196
#: ../doc/book/sql.rst:198
#: ../doc/book/sql.rst:200
#: ../doc/book/sql.rst:204
#: ../doc/book/sql.rst:207
#: ../doc/book/sql.rst:210
#: ../doc/book/sql.rst:212
#: ../doc/book/sql.rst:218
#: ../doc/book/sql.rst:220
#: ../doc/book/sql.rst:234
#: ../doc/book/sql.rst:238
#: ../doc/book/sql.rst:241
#: ../doc/book/sql.rst:247
#: ../doc/book/sql.rst:251
#: ../doc/book/sql.rst:254
#: ../doc/book/sql.rst:260
#: ../doc/book/sql.rst:269
#: ../doc/book/sql.rst:281
#: ../doc/book/sql.rst:294
#: ../doc/book/sql.rst:310
#: ../doc/book/sql.rst:313
#: ../doc/book/sql.rst:315
#: ../doc/book/sql.rst:321
#: ../doc/book/sql.rst:327
#: ../doc/book/sql.rst:355
#: ../doc/book/sql.rst:360
#: ../doc/book/sql.rst:363
#: ../doc/book/sql.rst:366
#: ../doc/book/sql.rst:369
#: ../doc/book/sql.rst:374
#: ../doc/book/sql.rst:380
#: ../doc/book/sql.rst:382
#: ../doc/book/sql.rst:384
#: ../doc/book/sql.rst:386
#: ../doc/book/sql.rst:404
#: ../doc/book/sql.rst:429
msgid "Okay."
msgstr ""

#: ../doc/book/sql.rst:29
msgid "E011-02"
msgstr ""

#: ../doc/book/sql.rst:29
msgid "REAL, DOUBLE PRECISION, and FLOAT data types"
msgstr ""

#: ../doc/book/sql.rst:29
msgid "``CREATE TABLE tr (s1 FLOAT PRIMARY KEY);``"
msgstr ""

#: ../doc/book/sql.rst:29
msgid "Fail, approximate-numeric type names are different."
msgstr ""

#: ../doc/book/sql.rst:31
msgid "**Note:** Floating point SQL types are not planned to be compatible between 2.1 and 2.2 releases. The reason is that in 2.1 we set 'number' format for columns of these types, but will restrict it to 'float32' and 'float64' in 2.2. The format change requires data migration and cannot be done automatically, because in 2.1 we have no information to distinguish 'number' columns (created from Lua) from FLOAT/DOUBLE/REAL ones (created from SQL)."
msgstr ""

#: ../doc/book/sql.rst:41
msgid "E011-03"
msgstr ""

#: ../doc/book/sql.rst:41
msgid "DECIMAL and NUMERIC data types"
msgstr ""

#: ../doc/book/sql.rst:41
msgid "``CREATE TABLE td (s1 DECIMAL PRIMARY KEY);``"
msgstr ""

#: ../doc/book/sql.rst:41
msgid "Fail, DECIMAL and NUMERIC data types are not supported and a number containing post-decimal digits will be treated as approximate numeric."
msgstr ""

#: ../doc/book/sql.rst:45
msgid "E011-04"
msgstr ""

#: ../doc/book/sql.rst:45
msgid "Arithmetic operators"
msgstr ""

#: ../doc/book/sql.rst:45
msgid "``SELECT 10 + 1, 9 - 2, 8 * 3, 7 / 2 FROM t;``"
msgstr ""

#: ../doc/book/sql.rst:47
msgid "E011-05"
msgstr ""

#: ../doc/book/sql.rst:47
msgid "Numeric comparisons"
msgstr ""

#: ../doc/book/sql.rst:47
msgid "``SELECT * FROM t WHERE 1 < 2;``"
msgstr ""

#: ../doc/book/sql.rst:49
msgid "E011-06"
msgstr ""

#: ../doc/book/sql.rst:49
msgid "Implicit casting among the numeric data types"
msgstr ""

#: ../doc/book/sql.rst:49
msgid "``SELECT * FROM t WHERE s1 = 1.00;``"
msgstr ""

#: ../doc/book/sql.rst:49
msgid "Okay, but only because Tarantool doesn't distinguish between numeric data types."
msgstr ""

#: ../doc/book/sql.rst:52
msgid "E021"
msgstr ""

#: ../doc/book/sql.rst:52
msgid "Character string types"
msgstr ""

#: ../doc/book/sql.rst:54
msgid "E021-01"
msgstr ""

#: ../doc/book/sql.rst:54
msgid "Character data type (including all its spellings)"
msgstr ""

#: ../doc/book/sql.rst:54
msgid "``CREATE TABLE t44 (s1 CHAR PRIMARY KEY);``"
msgstr ""

#: ../doc/book/sql.rst:54
msgid "Fail, CHAR is not supported. This type of Fail will only be counted once."
msgstr ""

#: ../doc/book/sql.rst:57
msgid "E021-02"
msgstr ""

#: ../doc/book/sql.rst:57
msgid "CHARACTER VARYING data type (including all its spellings)"
msgstr ""

#: ../doc/book/sql.rst:57
msgid "``CREATE TABLE t45 (s1 VARCHAR(1) PRIMARY KEY);``"
msgstr ""

#: ../doc/book/sql.rst:57
msgid "Fail, only the spelling VARCHAR is allowed."
msgstr ""

#: ../doc/book/sql.rst:59
msgid "**Note:** VARCHAR(N) does not check the string length."
msgstr ""

#: ../doc/book/sql.rst:61
msgid "E021-03"
msgstr ""

#: ../doc/book/sql.rst:61
msgid "Character literals"
msgstr ""

#: ../doc/book/sql.rst:61
msgid "``INSERT INTO t45 VALUES ('');``"
msgstr ""

#: ../doc/book/sql.rst:61
msgid "Okay, and the bad practice of accepting \"\"'s for character literals is avoided."
msgstr ""

#: ../doc/book/sql.rst:64
msgid "E021-04"
msgstr ""

#: ../doc/book/sql.rst:64
msgid "CHARACTER_LENGTH function"
msgstr ""

#: ../doc/book/sql.rst:64
msgid "``SELECT character_length(s1) FROM t;``"
msgstr ""

#: ../doc/book/sql.rst:64
msgid "Fail. There is no such function. There is a function LENGTH(), which is okay."
msgstr ""

#: ../doc/book/sql.rst:67
msgid "E021-05"
msgstr ""

#: ../doc/book/sql.rst:67
msgid "OCTET_LENGTH"
msgstr ""

#: ../doc/book/sql.rst:67
msgid "``SELECT octet_length(s1) FROM t;``"
msgstr ""

#: ../doc/book/sql.rst:67
msgid "Fail. There is no such function."
msgstr ""

#: ../doc/book/sql.rst:69
msgid "E021-06"
msgstr ""

#: ../doc/book/sql.rst:69
msgid "SUBSTRING function."
msgstr ""

#: ../doc/book/sql.rst:69
msgid "``SELECT substring(s1 FROM 1 FOR 1) FROM t;``"
msgstr ""

#: ../doc/book/sql.rst:69
msgid "Fail. There is no such function. There is a function SUBSTR(x,n,n) which is okay."
msgstr ""

#: ../doc/book/sql.rst:72
msgid "E021-07"
msgstr ""

#: ../doc/book/sql.rst:72
msgid "Character concatenation"
msgstr ""

#: ../doc/book/sql.rst:72
msgid "``SELECT 'a' || 'b' FROM t;``"
msgstr ""

#: ../doc/book/sql.rst:74
msgid "E021-08"
msgstr ""

#: ../doc/book/sql.rst:74
msgid "UPPER and LOWER functions"
msgstr ""

#: ../doc/book/sql.rst:74
msgid "``SELECT upper('a'), lower('B') FROM t;``"
msgstr ""

#: ../doc/book/sql.rst:76
msgid "E021-09"
msgstr ""

#: ../doc/book/sql.rst:76
msgid "TRIM function"
msgstr ""

#: ../doc/book/sql.rst:76
msgid "``SELECT trim('a ') FROM t;``"
msgstr ""

#: ../doc/book/sql.rst:78
msgid "E021-10"
msgstr ""

#: ../doc/book/sql.rst:78
msgid "Implicit casting among the fixed-length and variable-length character string types"
msgstr ""

#: ../doc/book/sql.rst:78
msgid "``SELECT * FROM tm WHERE char_column > varchar_column;``"
msgstr ""

#: ../doc/book/sql.rst:78
msgid "Fail, there is no fixed-length character string type."
msgstr ""

#: ../doc/book/sql.rst:81
msgid "E021-11"
msgstr ""

#: ../doc/book/sql.rst:81
msgid "POSITION function"
msgstr ""

#: ../doc/book/sql.rst:81
msgid "``SELECT position(x in y) FROM z;``"
msgstr ""

#: ../doc/book/sql.rst:81
msgid "Fail. Tarantool's function uses ',' rather than 'in'"
msgstr ""

#: ../doc/book/sql.rst:83
msgid "E021-12"
msgstr ""

#: ../doc/book/sql.rst:83
msgid "Character comparison"
msgstr ""

#: ../doc/book/sql.rst:83
msgid "``SELECT * FROM t WHERE s1 > 'a';``"
msgstr ""

#: ../doc/book/sql.rst:83
msgid "Okay. We should note here that comparisons use a binary collation by default, but it is easy to specify unicode or unicode_ci collations, or create new collations."
msgstr ""

#: ../doc/book/sql.rst:87
msgid "E031"
msgstr ""

#: ../doc/book/sql.rst:87
msgid "Identifiers"
msgstr ""

#: ../doc/book/sql.rst:87
msgid "``CREATE TABLE rank (ceil INTEGER PRIMARY KEY);``"
msgstr ""

#: ../doc/book/sql.rst:87
msgid "Fail. Tarantool's list of reserved words differs from the standard's list of reserved words."
msgstr ""

#: ../doc/book/sql.rst:90
msgid "E031-01"
msgstr ""

#: ../doc/book/sql.rst:90
msgid "Delimited Identifiers"
msgstr ""

#: ../doc/book/sql.rst:90
msgid "``CREATE TABLE \"t47\" (s1 INTEGER PRIMARY KEY);``"
msgstr ""

#: ../doc/book/sql.rst:90
msgid "Okay. And enclosing identifiers inside double quotes means they won't be converted to upper case or lower case, this is behavior that some other DBMSs sadly lack."
msgstr ""

#: ../doc/book/sql.rst:94
msgid "E031-02"
msgstr ""

#: ../doc/book/sql.rst:94
msgid "Lower case identifiers"
msgstr ""

#: ../doc/book/sql.rst:94
msgid "``CREATE TABLE t48 (s1 INTEGER PRIMARY KEY);``"
msgstr ""

#: ../doc/book/sql.rst:96
msgid "E031-03"
msgstr ""

#: ../doc/book/sql.rst:96
msgid "Trailing underscore"
msgstr ""

#: ../doc/book/sql.rst:96
msgid "``CREATE TABLE t49_ (s1 INTEGER PRIMARY KEY);``"
msgstr ""

#: ../doc/book/sql.rst:98
msgid "E051"
msgstr ""

#: ../doc/book/sql.rst:98
msgid "Basic query specification"
msgstr ""

#: ../doc/book/sql.rst:100
msgid "E051-01"
msgstr ""

#: ../doc/book/sql.rst:100
msgid "SELECT DISTINCT"
msgstr ""

#: ../doc/book/sql.rst:100
msgid "``SELECT DISTINCT s1 FROM t;``"
msgstr ""

#: ../doc/book/sql.rst:102
msgid "E051-02"
msgstr ""

#: ../doc/book/sql.rst:102
msgid "GROUP BY clause"
msgstr ""

#: ../doc/book/sql.rst:102
msgid "``SELECT DISTINCT s1 FROM t GROUP BY s1;``"
msgstr ""

#: ../doc/book/sql.rst:104
msgid "E051-04"
msgstr ""

#: ../doc/book/sql.rst:104
msgid "GROUP BY can contain columns not in select list"
msgstr ""

#: ../doc/book/sql.rst:104
msgid "``SELECT s1 FROM t GROUP BY lower(s1);``"
msgstr ""

#: ../doc/book/sql.rst:107
msgid "E051-05"
msgstr ""

#: ../doc/book/sql.rst:107
msgid "Select list items can be renamed"
msgstr ""

#: ../doc/book/sql.rst:107
msgid "``SELECT s1 AS k FROM t ORDER BY k;``"
msgstr ""

#: ../doc/book/sql.rst:109
msgid "E051-06"
msgstr ""

#: ../doc/book/sql.rst:109
msgid "HAVING clause"
msgstr ""

#: ../doc/book/sql.rst:109
msgid "``SELECT COUNT(*) FROM t HAVING COUNT(*) > 0;``"
msgstr ""

#: ../doc/book/sql.rst:109
msgid "Okay. GROUP BY is not mandatory before HAVING."
msgstr ""

#: ../doc/book/sql.rst:111
msgid "E051-07"
msgstr ""

#: ../doc/book/sql.rst:111
msgid "Qualified * in select list"
msgstr ""

#: ../doc/book/sql.rst:111
msgid "``SELECT t.* FROM t;``"
msgstr ""

#: ../doc/book/sql.rst:113
msgid "E051-08"
msgstr ""

#: ../doc/book/sql.rst:113
msgid "Correlation names in the FROM clause"
msgstr ""

#: ../doc/book/sql.rst:113
msgid "``SELECT * FROM t AS k;``"
msgstr ""

#: ../doc/book/sql.rst:115
msgid "E051-09"
msgstr ""

#: ../doc/book/sql.rst:115
msgid "Rename columns in the FROM clause"
msgstr ""

#: ../doc/book/sql.rst:115
msgid "``SELECT * FROM t AS x(q,c);``"
msgstr ""

#: ../doc/book/sql.rst:115
msgid "Fail."
msgstr ""

#: ../doc/book/sql.rst:117
msgid "E061"
msgstr ""

#: ../doc/book/sql.rst:117
msgid "Basic predicates and search conditions"
msgstr ""

#: ../doc/book/sql.rst:119
msgid "E061-01"
msgstr ""

#: ../doc/book/sql.rst:119
msgid "Comparison predicate"
msgstr ""

#: ../doc/book/sql.rst:119
msgid "``SELECT * FROM t WHERE 0 = 0;``"
msgstr ""

#: ../doc/book/sql.rst:121
msgid "E061-02"
msgstr ""

#: ../doc/book/sql.rst:121
msgid "BETWEEN predicate"
msgstr ""

#: ../doc/book/sql.rst:121
msgid "``SELECT * FROM t WHERE ' ' BETWEEN '' and ' ';``"
msgstr ""

#: ../doc/book/sql.rst:123
msgid "E061-03"
msgstr ""

#: ../doc/book/sql.rst:123
msgid "IN predicate with list of values"
msgstr ""

#: ../doc/book/sql.rst:123
msgid "``SELECT * FROM t WHERE s1 IN ('a', upper('a'));``"
msgstr ""

#: ../doc/book/sql.rst:125
msgid "E061-04"
msgstr ""

#: ../doc/book/sql.rst:125
msgid "LIKE predicate"
msgstr ""

#: ../doc/book/sql.rst:125
msgid "``SELECT * FROM t WHERE s1 LIKE '_';``"
msgstr ""

#: ../doc/book/sql.rst:127
msgid "E061-05"
msgstr ""

#: ../doc/book/sql.rst:127
msgid "LIKE predicate: ESCAPE clause"
msgstr ""

#: ../doc/book/sql.rst:127
msgid "``VALUES ('abc_' LIKE 'abcX_' ESCAPE 'X');``"
msgstr ""

#: ../doc/book/sql.rst:129
msgid "E061-06"
msgstr ""

#: ../doc/book/sql.rst:129
msgid "NULL predicate"
msgstr ""

#: ../doc/book/sql.rst:129
msgid "``SELECT * FROM t WHERE s1 IS NOT NULL;``"
msgstr ""

#: ../doc/book/sql.rst:131
msgid "E061-07"
msgstr ""

#: ../doc/book/sql.rst:131
msgid "Quantified comparison predicate"
msgstr ""

#: ../doc/book/sql.rst:131
msgid "``SELECT * FROM t WHERE s1 = ANY (SELECT s1 FROM t);``"
msgstr ""

#: ../doc/book/sql.rst:131
#: ../doc/book/sql.rst:139
#: ../doc/book/sql.rst:273
#: ../doc/book/sql.rst:276
#: ../doc/book/sql.rst:318
#: ../doc/book/sql.rst:335
#: ../doc/book/sql.rst:338
#: ../doc/book/sql.rst:347
#: ../doc/book/sql.rst:349
#: ../doc/book/sql.rst:351
#: ../doc/book/sql.rst:353
#: ../doc/book/sql.rst:376
#: ../doc/book/sql.rst:407
msgid "Fail. Syntax error."
msgstr ""

#: ../doc/book/sql.rst:133
msgid "E061-08"
msgstr ""

#: ../doc/book/sql.rst:133
msgid "EXISTS predicate"
msgstr ""

#: ../doc/book/sql.rst:133
msgid "``SELECT * FROM t WHERE NOT EXISTS (SELECT * FROM t);``"
msgstr ""

#: ../doc/book/sql.rst:135
msgid "E061-09"
msgstr ""

#: ../doc/book/sql.rst:135
msgid "Subqueries in comparison predicate"
msgstr ""

#: ../doc/book/sql.rst:135
msgid "``SELECT * FROM t WHERE s1 > (SELECT s1 FROM t);``"
msgstr ""

#: ../doc/book/sql.rst:137
msgid "E061-11"
msgstr ""

#: ../doc/book/sql.rst:137
msgid "Subqueries in IN predicate"
msgstr ""

#: ../doc/book/sql.rst:137
msgid "``SELECT * FROM t WHERE s1 IN (SELECT s1 FROM t);``"
msgstr ""

#: ../doc/book/sql.rst:139
msgid "E061-12"
msgstr ""

#: ../doc/book/sql.rst:139
msgid "Subqueries in quantified comparison predicate"
msgstr ""

#: ../doc/book/sql.rst:139
msgid "``SELECT * FROM t WHERE s1 >= ALL (SELECT s1 FROM t);``"
msgstr ""

#: ../doc/book/sql.rst:141
msgid "E061-13"
msgstr ""

#: ../doc/book/sql.rst:141
msgid "Correlated subqueries"
msgstr ""

#: ../doc/book/sql.rst:141
msgid "``SELECT * FROM t WHERE s1 = (SELECT s1 FROM t2 WHERE t2.s2 = t.s1);``"
msgstr ""

#: ../doc/book/sql.rst:144
msgid "E061-14"
msgstr ""

#: ../doc/book/sql.rst:144
msgid "Search condition"
msgstr ""

#: ../doc/book/sql.rst:144
msgid "``SELECT * FROM t WHERE 0 <> 0 OR 'a' < 'b' AND s1 IS NULL;``"
msgstr ""

#: ../doc/book/sql.rst:147
msgid "E071"
msgstr ""

#: ../doc/book/sql.rst:147
msgid "Basic query expressions"
msgstr ""

#: ../doc/book/sql.rst:149
msgid "E071-01"
msgstr ""

#: ../doc/book/sql.rst:149
msgid "UNION DISTINCT table operator"
msgstr ""

#: ../doc/book/sql.rst:149
msgid "``SELECT * FROM t UNION DISTINCT SELECT * FROM t;``"
msgstr ""

#: ../doc/book/sql.rst:149
msgid "Fail. However, \"SELECT * FROM t UNION SELECT * FROM t;\" is okay."
msgstr ""

#: ../doc/book/sql.rst:152
msgid "E071-02"
msgstr ""

#: ../doc/book/sql.rst:152
msgid "UNION ALL table operator"
msgstr ""

#: ../doc/book/sql.rst:152
msgid "``SELECT * FROM t UNION ALL SELECT * FROM t;``"
msgstr ""

#: ../doc/book/sql.rst:154
msgid "E071-03"
msgstr ""

#: ../doc/book/sql.rst:154
msgid "EXCEPT DISTINCT table operator"
msgstr ""

#: ../doc/book/sql.rst:154
msgid "``SELECT * FROM t EXCEPT DISTINCT SELECT * FROM t;``"
msgstr ""

#: ../doc/book/sql.rst:154
msgid "Fail. However, \"SELECT * FROM t EXCEPT SELECT * FROM t;\" is okay."
msgstr ""

#: ../doc/book/sql.rst:157
msgid "E071-05"
msgstr ""

#: ../doc/book/sql.rst:157
msgid "Columns combined via table operators need not have exactly the same data type."
msgstr ""

#: ../doc/book/sql.rst:157
msgid "``SELECT s1 FROM t UNION SELECT 5 FROM t;``"
msgstr ""

#: ../doc/book/sql.rst:157
msgid "Okay, but only because Tarantool doesn't distinguish data types very well."
msgstr ""

#: ../doc/book/sql.rst:160
msgid "E071-06"
msgstr ""

#: ../doc/book/sql.rst:160
msgid "Table operators in subqueries"
msgstr ""

#: ../doc/book/sql.rst:160
msgid "``SELECT * FROM t WHERE 'a' IN (SELECT * FROM t UNION SELECT * FROM t);``"
msgstr ""

#: ../doc/book/sql.rst:163
msgid "E081"
msgstr ""

#: ../doc/book/sql.rst:163
msgid "Basic privileges"
msgstr ""

#: ../doc/book/sql.rst:165
msgid "E081-01"
msgstr ""

#: ../doc/book/sql.rst:165
msgid "Select privilege at the table level"
msgstr ""

#: ../doc/book/sql.rst:165
msgid "Fail. Syntax error. (Tarantool doesn't support privileges.)"
msgstr ""

#: ../doc/book/sql.rst:168
msgid "E081-02"
msgstr ""

#: ../doc/book/sql.rst:168
msgid "DELETE privilege"
msgstr ""

#: ../doc/book/sql.rst:168
#: ../doc/book/sql.rst:170
#: ../doc/book/sql.rst:172
#: ../doc/book/sql.rst:174
#: ../doc/book/sql.rst:176
#: ../doc/book/sql.rst:178
#: ../doc/book/sql.rst:180
#: ../doc/book/sql.rst:182
#: ../doc/book/sql.rst:184
msgid "Fail. (Tarantool doesn't support privileges.)"
msgstr ""

#: ../doc/book/sql.rst:170
msgid "E081-03"
msgstr ""

#: ../doc/book/sql.rst:170
msgid "INSERT privilege at the table level"
msgstr ""

#: ../doc/book/sql.rst:172
msgid "E081-04"
msgstr ""

#: ../doc/book/sql.rst:172
msgid "UPDATE privilege at the table level"
msgstr ""

#: ../doc/book/sql.rst:174
msgid "E081-05"
msgstr ""

#: ../doc/book/sql.rst:174
msgid "UPDATE privilege at column level"
msgstr ""

#: ../doc/book/sql.rst:176
msgid "E081-06"
msgstr ""

#: ../doc/book/sql.rst:176
msgid "REFERENCES privilege at the table level"
msgstr ""

#: ../doc/book/sql.rst:178
msgid "E081-07"
msgstr ""

#: ../doc/book/sql.rst:178
msgid "REFERENCES privilege at column level"
msgstr ""

#: ../doc/book/sql.rst:180
msgid "E081-08"
msgstr ""

#: ../doc/book/sql.rst:180
msgid "WITH GRANT OPTION"
msgstr ""

#: ../doc/book/sql.rst:182
msgid "E081-09"
msgstr ""

#: ../doc/book/sql.rst:182
msgid "USAGE privilege"
msgstr ""

#: ../doc/book/sql.rst:184
msgid "E081-10"
msgstr ""

#: ../doc/book/sql.rst:184
msgid "EXECUTE privilege"
msgstr ""

#: ../doc/book/sql.rst:186
msgid "E091"
msgstr ""

#: ../doc/book/sql.rst:186
msgid "Set functions"
msgstr ""

#: ../doc/book/sql.rst:188
msgid "E091-01"
msgstr ""

#: ../doc/book/sql.rst:188
msgid "AVG"
msgstr ""

#: ../doc/book/sql.rst:188
msgid "``SELECT AVG(s1) FROM t7;``"
msgstr ""

#: ../doc/book/sql.rst:188
msgid "Fail. No warning that nulls were eliminated."
msgstr ""

#: ../doc/book/sql.rst:190
msgid "E091-02"
msgstr ""

#: ../doc/book/sql.rst:190
msgid "COUNT"
msgstr ""

#: ../doc/book/sql.rst:190
msgid "``SELECT COUNT(*) FROM t7 WHERE s1 > 0;``"
msgstr ""

#: ../doc/book/sql.rst:192
msgid "E091-03"
msgstr ""

#: ../doc/book/sql.rst:192
msgid "MAX"
msgstr ""

#: ../doc/book/sql.rst:192
msgid "``SELECT MAX(s1) FROM t7 WHERE s1 > 0;``"
msgstr ""

#: ../doc/book/sql.rst:194
msgid "E091-04"
msgstr ""

#: ../doc/book/sql.rst:194
msgid "MIN"
msgstr ""

#: ../doc/book/sql.rst:194
msgid "``SELECT MIN(s1) FROM t7 WHERE s1 > 0;``"
msgstr ""

#: ../doc/book/sql.rst:196
msgid "E091-05"
msgstr ""

#: ../doc/book/sql.rst:196
msgid "SUM"
msgstr ""

#: ../doc/book/sql.rst:196
msgid "``SELECT SUM(1) FROM t7 WHERE s1 > 0;``"
msgstr ""

#: ../doc/book/sql.rst:198
msgid "E091-06"
msgstr ""

#: ../doc/book/sql.rst:198
msgid "ALL quantifier"
msgstr ""

#: ../doc/book/sql.rst:198
msgid "``SELECT SUM(ALL s1) FROM t7 WHERE s1 > 0;``"
msgstr ""

#: ../doc/book/sql.rst:200
msgid "E091-07"
msgstr ""

#: ../doc/book/sql.rst:200
msgid "DISTINCT quantifier"
msgstr ""

#: ../doc/book/sql.rst:200
msgid "``SELECT SUM(DISTINCT s1) FROM t7 WHERE s1 > 0;``"
msgstr ""

#: ../doc/book/sql.rst:202
msgid "E101"
msgstr ""

#: ../doc/book/sql.rst:202
msgid "Basic data manipulation"
msgstr ""

#: ../doc/book/sql.rst:204
msgid "E101-01"
msgstr ""

#: ../doc/book/sql.rst:204
msgid "INSERT statement"
msgstr ""

#: ../doc/book/sql.rst:204
msgid "``INSERT INTO t (s1, s2) VALUES (1, ''), (2, NULL), (3, 55);``"
msgstr ""

#: ../doc/book/sql.rst:207
msgid "E101-03"
msgstr ""

#: ../doc/book/sql.rst:207
msgid "Searched UPDATE statement"
msgstr ""

#: ../doc/book/sql.rst:207
msgid "``UPDATE t SET s1 = NULL WHERE s2 IN (SELECT s1 FROM t2);``"
msgstr ""

#: ../doc/book/sql.rst:210
msgid "E101-04"
msgstr ""

#: ../doc/book/sql.rst:210
msgid "Searched DELETE statement"
msgstr ""

#: ../doc/book/sql.rst:210
msgid "``DELETE FROM t WHERE s1 IN (SELECT s1 FROM t);``"
msgstr ""

#: ../doc/book/sql.rst:212
msgid "E111"
msgstr ""

#: ../doc/book/sql.rst:212
msgid "Single row SELECT statement"
msgstr ""

#: ../doc/book/sql.rst:212
msgid "``SELECT COUNT(*) FROM t;``"
msgstr ""

#: ../doc/book/sql.rst:214
msgid "E121"
msgstr ""

#: ../doc/book/sql.rst:214
msgid "Basic cursor support"
msgstr ""

#: ../doc/book/sql.rst:216
msgid "E121-01"
msgstr ""

#: ../doc/book/sql.rst:216
msgid "DECLARE CURSOR"
msgstr ""

#: ../doc/book/sql.rst:216
#: ../doc/book/sql.rst:222
#: ../doc/book/sql.rst:224
#: ../doc/book/sql.rst:226
#: ../doc/book/sql.rst:228
#: ../doc/book/sql.rst:230
#: ../doc/book/sql.rst:232
msgid "Fail. Tarantool doesn't support cursors."
msgstr ""

#: ../doc/book/sql.rst:218
msgid "E121-02"
msgstr ""

#: ../doc/book/sql.rst:218
msgid "ORDER BY columns need not be in select list"
msgstr ""

#: ../doc/book/sql.rst:218
msgid "``SELECT s1 FROM t ORDER BY s2;``"
msgstr ""

#: ../doc/book/sql.rst:220
msgid "E121-03"
msgstr ""

#: ../doc/book/sql.rst:220
msgid "Value expressions in select list"
msgstr ""

#: ../doc/book/sql.rst:220
msgid "``SELECT s1 FROM t7 ORDER BY -s1;``"
msgstr ""

#: ../doc/book/sql.rst:222
msgid "E121-04"
msgstr ""

#: ../doc/book/sql.rst:222
msgid "OPEN statement"
msgstr ""

#: ../doc/book/sql.rst:224
msgid "E121-06"
msgstr ""

#: ../doc/book/sql.rst:224
msgid "Positioned UPDATE statement"
msgstr ""

#: ../doc/book/sql.rst:226
msgid "E121-07"
msgstr ""

#: ../doc/book/sql.rst:226
msgid "Positioned DELETE statement"
msgstr ""

#: ../doc/book/sql.rst:228
msgid "E121-08"
msgstr ""

#: ../doc/book/sql.rst:228
msgid "CLOSE statement"
msgstr ""

#: ../doc/book/sql.rst:230
msgid "E121-10"
msgstr ""

#: ../doc/book/sql.rst:230
msgid "FETCH statement implicit next"
msgstr ""

#: ../doc/book/sql.rst:232
msgid "E121-17"
msgstr ""

#: ../doc/book/sql.rst:232
msgid "WITH HOLD cursors"
msgstr ""

#: ../doc/book/sql.rst:234
msgid "E131"
msgstr ""

#: ../doc/book/sql.rst:234
msgid "Null value support (nulls in lieu of values)"
msgstr ""

#: ../doc/book/sql.rst:234
msgid "``SELECT s1 FROM t7 WHERE s1 IS NULL;``"
msgstr ""

#: ../doc/book/sql.rst:236
msgid "E141"
msgstr ""

#: ../doc/book/sql.rst:236
msgid "Basic integrity constraints"
msgstr ""

#: ../doc/book/sql.rst:238
msgid "E141-01"
msgstr ""

#: ../doc/book/sql.rst:238
msgid "NOT NULL constraints"
msgstr ""

#: ../doc/book/sql.rst:238
msgid "``CREATE TABLE t8 (s1 INTEGER PRIMARY KEY, s2 INTEGER NOT NULL);``"
msgstr ""

#: ../doc/book/sql.rst:241
msgid "E141-02"
msgstr ""

#: ../doc/book/sql.rst:241
msgid "UNIQUE constraints of NOT NULL columns"
msgstr ""

#: ../doc/book/sql.rst:241
msgid "``CREATE TABLE t9 (s1 INTEGER PRIMARY KEY, s2 INTEGER NOT NULL UNIQUE);``"
msgstr ""

#: ../doc/book/sql.rst:244
msgid "E141-03"
msgstr ""

#: ../doc/book/sql.rst:244
msgid "PRIMARY KEY constraints"
msgstr ""

#: ../doc/book/sql.rst:244
msgid "``CREATE TABLE t10 (s1 INTEGER PRIMARY KEY);``"
msgstr ""

#: ../doc/book/sql.rst:244
msgid "Okay, although Tarantool shouldn't always insist on having a primary key."
msgstr ""

#: ../doc/book/sql.rst:247
msgid "E141-04"
msgstr ""

#: ../doc/book/sql.rst:247
msgid "Basic FOREIGN KEY constraint with the NO ACTION default for both referential delete action and referential update action."
msgstr ""

#: ../doc/book/sql.rst:247
msgid "``CREATE TABLE t11 (s0 INTEGER PRIMARY KEY, s1 INTEGER REFERENCES t10);``"
msgstr ""

#: ../doc/book/sql.rst:251
msgid "E141-06"
msgstr ""

#: ../doc/book/sql.rst:251
msgid "CHECK constraints"
msgstr ""

#: ../doc/book/sql.rst:251
msgid "``CREATE TABLE t12 (s1 INTEGER PRIMARY KEY, s2 INTEGER, CHECK (s1 = s2));``"
msgstr ""

#: ../doc/book/sql.rst:254
msgid "E141-07"
msgstr ""

#: ../doc/book/sql.rst:254
msgid "Column defaults"
msgstr ""

#: ../doc/book/sql.rst:254
msgid "``CREATE TABLE t13 (s1 INTEGER PRIMARY KEY, s2 INTEGER DEFAULT -1);``"
msgstr ""

#: ../doc/book/sql.rst:257
msgid "E141-08"
msgstr ""

#: ../doc/book/sql.rst:257
msgid "NOT NULL inferred on primary key"
msgstr ""

#: ../doc/book/sql.rst:257
msgid "``CREATE TABLE t14 (s1 INTEGER PRIMARY KEY);``"
msgstr ""

#: ../doc/book/sql.rst:257
msgid "Okay. We are unable to insert NULL although we don't explicitly say the column is NOT NULL."
msgstr ""

#: ../doc/book/sql.rst:260
msgid "E141-10"
msgstr ""

#: ../doc/book/sql.rst:260
msgid "Names in a foreign key can be specified in any order"
msgstr ""

#: ../doc/book/sql.rst:260
msgid "``CREATE TABLE t15 (s1 INTEGER, s2 INTEGER, PRIMARY KEY (s1,s2));`` ``CREATE TABLE t16 (s1 INTEGER PRIMARY KEY, s2 INTEGER, FOREIGN KEY (s2, s1) REFERENCES t15 (s1, s2));``"
msgstr ""

#: ../doc/book/sql.rst:265
msgid "E151"
msgstr ""

#: ../doc/book/sql.rst:265
msgid "Transaction support"
msgstr ""

#: ../doc/book/sql.rst:267
msgid "E151-01"
msgstr ""

#: ../doc/book/sql.rst:267
msgid "COMMIT statement"
msgstr ""

#: ../doc/book/sql.rst:267
msgid "``COMMIT;``"
msgstr ""

#: ../doc/book/sql.rst:267
msgid "Fail. We have to say START TRANSACTION first."
msgstr ""

#: ../doc/book/sql.rst:269
msgid "E151-02"
msgstr ""

#: ../doc/book/sql.rst:269
msgid "ROLLBACK statement"
msgstr ""

#: ../doc/book/sql.rst:269
msgid "``ROLLBACK;``"
msgstr ""

#: ../doc/book/sql.rst:271
msgid "E152"
msgstr ""

#: ../doc/book/sql.rst:271
msgid "Basic SET TRANSACTION statement"
msgstr ""

#: ../doc/book/sql.rst:273
msgid "E152-01"
msgstr ""

#: ../doc/book/sql.rst:273
msgid "SET TRANSACTION statement ISOLATION SERIALIZABLE clause"
msgstr ""

#: ../doc/book/sql.rst:273
msgid "``SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;``"
msgstr ""

#: ../doc/book/sql.rst:276
msgid "E152-02"
msgstr ""

#: ../doc/book/sql.rst:276
msgid "SET TRANSACTION statement READ ONLY and READ WRITE clauses"
msgstr ""

#: ../doc/book/sql.rst:276
msgid "``SET TRANSACTION READ ONLY;``"
msgstr ""

#: ../doc/book/sql.rst:279
msgid "E153"
msgstr ""

#: ../doc/book/sql.rst:279
msgid "Updatable queries with subqueries"
msgstr ""

#: ../doc/book/sql.rst:281
msgid "E161"
msgstr ""

#: ../doc/book/sql.rst:281
msgid "SQL comments using leading double minus"
msgstr ""

#: ../doc/book/sql.rst:281
msgid "``--comment;``"
msgstr ""

#: ../doc/book/sql.rst:283
msgid "E171"
msgstr ""

#: ../doc/book/sql.rst:283
msgid "SQLSTATE support"
msgstr ""

#: ../doc/book/sql.rst:283
msgid "``DROP TABLE no_such_table;``"
msgstr ""

#: ../doc/book/sql.rst:283
msgid "Fail. At least, the error message doesn't hint that SQLSTATE exists."
msgstr ""

#: ../doc/book/sql.rst:286
msgid "E182"
msgstr ""

#: ../doc/book/sql.rst:286
msgid "Host language binding"
msgstr ""

#: ../doc/book/sql.rst:286
msgid "Okay. Any of the Tarantool connectors should be able to call ``box.execute()``."
msgstr ""

#: ../doc/book/sql.rst:289
msgid "F031"
msgstr ""

#: ../doc/book/sql.rst:289
msgid "Basic schema manipulation"
msgstr ""

#: ../doc/book/sql.rst:291
msgid "F031-01"
msgstr ""

#: ../doc/book/sql.rst:291
msgid "CREATE TABLE statement to create persistent base tables"
msgstr ""

#: ../doc/book/sql.rst:291
msgid "``CREATE TABLE t20 (t20_1 INTEGER NOT NULL);``"
msgstr ""

#: ../doc/book/sql.rst:291
msgid "Fail. We always have to say PRIMARY KEY (we only count this flaw once)."
msgstr ""

#: ../doc/book/sql.rst:294
msgid "F031-02"
msgstr ""

#: ../doc/book/sql.rst:294
msgid "CREATE VIEW statement"
msgstr ""

#: ../doc/book/sql.rst:294
msgid "``CREATE VIEW t21 AS SELECT * FROM t20;``"
msgstr ""

#: ../doc/book/sql.rst:296
msgid "F031-03"
msgstr ""

#: ../doc/book/sql.rst:296
#: ../doc/book/sql.rst:401
msgid "GRANT statement"
msgstr ""

#: ../doc/book/sql.rst:296
msgid "Fail. Tarantool doesn't support privileges except via NoSQL."
msgstr ""

#: ../doc/book/sql.rst:299
msgid "F031-04"
msgstr ""

#: ../doc/book/sql.rst:299
msgid "ALTER TABLE statement: add column"
msgstr ""

#: ../doc/book/sql.rst:299
msgid "``ALTER TABLE t7 ADD COLUMN t7_2 VARCHAR DEFAULT 'q';``"
msgstr ""

#: ../doc/book/sql.rst:299
msgid "Fail. Table alterations work but not this clause."
msgstr ""

#: ../doc/book/sql.rst:301
msgid "F031-13"
msgstr ""

#: ../doc/book/sql.rst:301
msgid "DROP TABLE statement: RESTRICT clause"
msgstr ""

#: ../doc/book/sql.rst:301
msgid "``DROP TABLE t20 RESTRICT;``"
msgstr ""

#: ../doc/book/sql.rst:301
#: ../doc/book/sql.rst:303
msgid "Fail. Syntax error, and RESTRICT is not assumed."
msgstr ""

#: ../doc/book/sql.rst:303
msgid "F031-16"
msgstr ""

#: ../doc/book/sql.rst:303
msgid "DROP VIEW statement: RESTRICT clause"
msgstr ""

#: ../doc/book/sql.rst:303
msgid "``DROP VIEW v2 RESTRICT;``"
msgstr ""

#: ../doc/book/sql.rst:305
msgid "F031-19"
msgstr ""

#: ../doc/book/sql.rst:305
msgid "REVOKE statement: RESTRICT clause"
msgstr ""

#: ../doc/book/sql.rst:305
msgid "Fail. Tarantool does not support privileges except via NoSQL."
msgstr ""

#: ../doc/book/sql.rst:308
msgid "F041"
msgstr ""

#: ../doc/book/sql.rst:308
msgid "Basic joined table"
msgstr ""

#: ../doc/book/sql.rst:310
msgid "F041-01"
msgstr ""

#: ../doc/book/sql.rst:310
msgid "Inner join but not necessarily the INNER keyword"
msgstr ""

#: ../doc/book/sql.rst:310
msgid "``SELECT a.s1 FROM t7 a JOIN t7 b;``"
msgstr ""

#: ../doc/book/sql.rst:313
msgid "F041-02"
msgstr ""

#: ../doc/book/sql.rst:313
msgid "INNER keyword"
msgstr ""

#: ../doc/book/sql.rst:313
msgid "``SELECT a.s1 FROM t7 a INNER JOIN t7 b;``"
msgstr ""

#: ../doc/book/sql.rst:315
msgid "F041-03"
msgstr ""

#: ../doc/book/sql.rst:315
msgid "LEFT OUTER JOIN"
msgstr ""

#: ../doc/book/sql.rst:315
msgid "``SELECT t7.*, t22.* FROM t22 LEFT OUTER JOIN t7 ON (t22_1 = s1);``"
msgstr ""

#: ../doc/book/sql.rst:318
msgid "F041-04"
msgstr ""

#: ../doc/book/sql.rst:318
msgid "RIGHT OUTER JOIN"
msgstr ""

#: ../doc/book/sql.rst:318
msgid "``SELECT t7.*, t22.* FROM t22 RIGHT OUTER JOIN t7 ON (t22_1 = s1);``"
msgstr ""

#: ../doc/book/sql.rst:321
msgid "F041-05"
msgstr ""

#: ../doc/book/sql.rst:321
msgid "Outer joins can be nested"
msgstr ""

#: ../doc/book/sql.rst:321
msgid "``SELECT t7.*, t22.* FROM t22 LEFT OUTER JOIN t7 ON (t22_1 = s1) LEFT OUTER JOIN t23;``"
msgstr ""

#: ../doc/book/sql.rst:324
msgid "F041-07"
msgstr ""

#: ../doc/book/sql.rst:324
msgid "The inner table in a left or right outer join can also be used in an inner join"
msgstr ""

#: ../doc/book/sql.rst:324
msgid "``SELECT t7.* FROM t22 LEFT OUTER JOIN t7 ON (t22_1 = s1) INNER JOIN t22 ON (t22_4 = t22_5);``"
msgstr ""

#: ../doc/book/sql.rst:324
msgid "Okay. The query fails due to a syntax error but that's expectable."
msgstr ""

#: ../doc/book/sql.rst:327
msgid "F041-08"
msgstr ""

#: ../doc/book/sql.rst:327
msgid "All comparison operators are supported"
msgstr ""

#: ../doc/book/sql.rst:327
msgid "``SELECT * FROM t WHERE 0 = 1 OR 0 > 1 OR 0 < 1 OR 0 <> 1;``"
msgstr ""

#: ../doc/book/sql.rst:330
msgid "F051 Basic date and time"
msgstr ""

#: ../doc/book/sql.rst:332
msgid "F051-01"
msgstr ""

#: ../doc/book/sql.rst:332
msgid "DATE data type (including support of DATE literal)"
msgstr ""

#: ../doc/book/sql.rst:332
msgid "``CREATE TABLE dates (s1 DATE);``"
msgstr ""

#: ../doc/book/sql.rst:332
msgid "Fail. Tarantool does not support DATE data type."
msgstr ""

#: ../doc/book/sql.rst:335
msgid "F051-02"
msgstr ""

#: ../doc/book/sql.rst:335
msgid "TIME data type (including support of TIME literal)"
msgstr ""

#: ../doc/book/sql.rst:335
msgid "``CREATE TABLE times (s1 TIME DEFAULT TIME '1:2:3');``"
msgstr ""

#: ../doc/book/sql.rst:338
msgid "F051-03"
msgstr ""

#: ../doc/book/sql.rst:338
msgid "TIMESTAMP data type (including support of TIMESTAMP literal)"
msgstr ""

#: ../doc/book/sql.rst:338
msgid "``CREATE TABLE timestamps (s1 TIMESTAMP);``"
msgstr ""

#: ../doc/book/sql.rst:341
msgid "F051-04"
msgstr ""

#: ../doc/book/sql.rst:341
msgid "Comparison predicate on DATE, TIME and TIMESTAMP data types"
msgstr ""

#: ../doc/book/sql.rst:341
msgid "``SELECT * FROM dates WHERE s1 = s1;``"
msgstr ""

#: ../doc/book/sql.rst:341
#: ../doc/book/sql.rst:344
msgid "Fail. The data types are not supported."
msgstr ""

#: ../doc/book/sql.rst:344
msgid "F051-05"
msgstr ""

#: ../doc/book/sql.rst:344
msgid "Explicit CAST between date-time types and character string types"
msgstr ""

#: ../doc/book/sql.rst:344
msgid "``SELECT cast(s1 AS VARCHAR(10)) FROM dates;``"
msgstr ""

#: ../doc/book/sql.rst:347
msgid "F051-06"
msgstr ""

#: ../doc/book/sql.rst:347
msgid "CURRENT_DATE"
msgstr ""

#: ../doc/book/sql.rst:347
msgid "``SELECT CURRENT_DATE FROM t;``"
msgstr ""

#: ../doc/book/sql.rst:349
msgid "F051-07"
msgstr ""

#: ../doc/book/sql.rst:349
msgid "CURRENT_TIME"
msgstr ""

#: ../doc/book/sql.rst:349
msgid "``SELECT * FROM t WHERE CURRENT_TIME < '23:23:23';``"
msgstr ""

#: ../doc/book/sql.rst:351
msgid "F051-08"
msgstr ""

#: ../doc/book/sql.rst:351
msgid "LOCALTIME"
msgstr ""

#: ../doc/book/sql.rst:351
msgid "``SELECT LOCALTIME FROM t;``"
msgstr ""

#: ../doc/book/sql.rst:353
msgid "F051-09"
msgstr ""

#: ../doc/book/sql.rst:353
msgid "LOCALTIMESTAMP"
msgstr ""

#: ../doc/book/sql.rst:353
msgid "``SELECT LOCALTIMESTAMP FROM t;``"
msgstr ""

#: ../doc/book/sql.rst:355
msgid "F081"
msgstr ""

#: ../doc/book/sql.rst:355
msgid "UNION and EXCEPT in views"
msgstr ""

#: ../doc/book/sql.rst:355
msgid "``CREATE VIEW vv AS SELECT * FROM t7 EXCEPT SELECT * FROM t15;``"
msgstr ""

#: ../doc/book/sql.rst:358
msgid "F131"
msgstr ""

#: ../doc/book/sql.rst:358
msgid "Grouped operations"
msgstr ""

#: ../doc/book/sql.rst:360
msgid "F131-01"
msgstr ""

#: ../doc/book/sql.rst:360
msgid "WHERE, GROUP BY, and HAVING clauses supported in queries with grouped views"
msgstr ""

#: ../doc/book/sql.rst:360
msgid "``CREATE VIEW vv2 AS SELECT * FROM vv GROUP BY s1;``"
msgstr ""

#: ../doc/book/sql.rst:363
msgid "F131-02"
msgstr ""

#: ../doc/book/sql.rst:363
msgid "Multiple tables supported in queries with grouped views"
msgstr ""

#: ../doc/book/sql.rst:363
msgid "``CREATE VIEW vv3 AS SELECT * FROM vv2, t30;``"
msgstr ""

#: ../doc/book/sql.rst:366
msgid "F131-03"
msgstr ""

#: ../doc/book/sql.rst:366
msgid "Set functions supported in queries with grouped views"
msgstr ""

#: ../doc/book/sql.rst:366
msgid "``CREATE VIEW vv4 AS SELECT COUNT(*) FROM vv2;``"
msgstr ""

#: ../doc/book/sql.rst:369
msgid "F131-04"
msgstr ""

#: ../doc/book/sql.rst:369
msgid "Subqueries with GROUP BY and HAVING clauses and grouped views"
msgstr ""

#: ../doc/book/sql.rst:369
msgid "``CREATE VIEW vv5 AS SELECT COUNT(*) FROM vv2 GROUP BY s1 HAVING COUNT(*) > 0;``"
msgstr ""

#: ../doc/book/sql.rst:372
msgid "F181"
msgstr ""

#: ../doc/book/sql.rst:372
msgid "Multiple module support"
msgstr ""

#: ../doc/book/sql.rst:372
msgid "Fail. Tarantool doesn't have modules."
msgstr ""

#: ../doc/book/sql.rst:374
msgid "F201"
msgstr ""

#: ../doc/book/sql.rst:374
msgid "CAST function"
msgstr ""

#: ../doc/book/sql.rst:374
msgid "``SELECT CAST(s1 AS INTEGER) FROM t;``"
msgstr ""

#: ../doc/book/sql.rst:376
msgid "F221"
msgstr ""

#: ../doc/book/sql.rst:376
msgid "Explicit defaults"
msgstr ""

#: ../doc/book/sql.rst:376
msgid "``UPDATE t SET s1 = DEFAULT;``"
msgstr ""

#: ../doc/book/sql.rst:378
msgid "F261"
msgstr ""

#: ../doc/book/sql.rst:378
msgid "CASE expression"
msgstr ""

#: ../doc/book/sql.rst:380
msgid "F261-01"
msgstr ""

#: ../doc/book/sql.rst:380
msgid "Simple CASE"
msgstr ""

#: ../doc/book/sql.rst:380
msgid "``SELECT CASE WHEN 1 = 0 THEN 5 ELSE 7 END FROM t;``"
msgstr ""

#: ../doc/book/sql.rst:382
msgid "F261-02"
msgstr ""

#: ../doc/book/sql.rst:382
msgid "Searched CASE"
msgstr ""

#: ../doc/book/sql.rst:382
msgid "``SELECT CASE 1 WHEN 0 THEN 5 ELSE 7 END FROM t;``"
msgstr ""

#: ../doc/book/sql.rst:384
msgid "F261-03"
msgstr ""

#: ../doc/book/sql.rst:384
msgid "NULLIF"
msgstr ""

#: ../doc/book/sql.rst:384
msgid "``SELECT nullif(s1, 7) FROM t;``"
msgstr ""

#: ../doc/book/sql.rst:386
msgid "F261-04"
msgstr ""

#: ../doc/book/sql.rst:386
msgid "COALESCE"
msgstr ""

#: ../doc/book/sql.rst:386
msgid "``SELECT coalesce(s1, 7) FROM t;``"
msgstr ""

#: ../doc/book/sql.rst:388
msgid "F311"
msgstr ""

#: ../doc/book/sql.rst:388
msgid "Schema definition statement"
msgstr ""

#: ../doc/book/sql.rst:390
msgid "F311-01"
msgstr ""

#: ../doc/book/sql.rst:390
msgid "CREATE SCHEMA"
msgstr ""

#: ../doc/book/sql.rst:390
msgid "Fail. Tarantool doesn't have schemas or databases."
msgstr ""

#: ../doc/book/sql.rst:392
msgid "F311-02"
msgstr ""

#: ../doc/book/sql.rst:392
msgid "CREATE TABLE for persistent base tables"
msgstr ""

#: ../doc/book/sql.rst:392
msgid "Fail. Tarantool doesn't have CREATE TABLE inside CREATE SCHEMA."
msgstr ""

#: ../doc/book/sql.rst:395
msgid "F311-03"
msgstr ""

#: ../doc/book/sql.rst:395
msgid "CREATE VIEW"
msgstr ""

#: ../doc/book/sql.rst:395
#: ../doc/book/sql.rst:398
msgid "Fail. Tarantool doesn't have CREATE VIEW inside CREATE SCHEMA."
msgstr ""

#: ../doc/book/sql.rst:398
msgid "F311-04"
msgstr ""

#: ../doc/book/sql.rst:398
msgid "CREATE VIEW: WITH CHECK OPTION"
msgstr ""

#: ../doc/book/sql.rst:401
msgid "F311-05"
msgstr ""

#: ../doc/book/sql.rst:401
msgid "Fail. Tarantool doesn't have GRANT inside CREATE SCHEMA."
msgstr ""

#: ../doc/book/sql.rst:404
msgid "F471"
msgstr ""

#: ../doc/book/sql.rst:404
msgid "Scalar subquery values"
msgstr ""

#: ../doc/book/sql.rst:404
msgid "``SELECT s1 FROM t WHERE s1 = (SELECT COUNT(*) FROM t);``"
msgstr ""

#: ../doc/book/sql.rst:407
msgid "F481"
msgstr ""

#: ../doc/book/sql.rst:407
msgid "Expanded NULL Predicate"
msgstr ""

#: ../doc/book/sql.rst:407
msgid "``SELECT * FROM t WHERE row (s1, s1) IS NOT NULL;``"
msgstr ""

#: ../doc/book/sql.rst:409
msgid "F812"
msgstr ""

#: ../doc/book/sql.rst:409
msgid "Basic flagging"
msgstr ""

#: ../doc/book/sql.rst:409
msgid "Fail. Tarantool doesn't support any flagging."
msgstr ""

#: ../doc/book/sql.rst:411
msgid "S011"
msgstr ""

#: ../doc/book/sql.rst:411
msgid "Distinct types"
msgstr ""

#: ../doc/book/sql.rst:411
msgid "``CREATE TYPE x AS INTEGER;``"
msgstr ""

#: ../doc/book/sql.rst:411
msgid "Fail. Tarantool doesn't support distinct types."
msgstr ""

#: ../doc/book/sql.rst:413
msgid "T321"
msgstr ""

#: ../doc/book/sql.rst:413
msgid "Basic SQL-invoked routines"
msgstr ""

#: ../doc/book/sql.rst:415
msgid "T321-01"
msgstr ""

#: ../doc/book/sql.rst:415
msgid "User-defined functions with no overloading"
msgstr ""

#: ../doc/book/sql.rst:415
msgid "``CREATE FUNCTION f () RETURNS INTEGER RETURN 5;``"
msgstr ""

#: ../doc/book/sql.rst:415
msgid "Fail. Tarantool doesn't support user-defined SQL functions."
msgstr ""

#: ../doc/book/sql.rst:418
msgid "T321-02"
msgstr ""

#: ../doc/book/sql.rst:418
msgid "User-defined procedures with no overloading"
msgstr ""

#: ../doc/book/sql.rst:418
msgid "``CREATE PROCEDURE p () BEGIN END;``"
msgstr ""

#: ../doc/book/sql.rst:418
#: ../doc/book/sql.rst:423
msgid "Fail. Tarantool doesn't support user-defined procedures."
msgstr ""

#: ../doc/book/sql.rst:421
msgid "T321-03"
msgstr ""

#: ../doc/book/sql.rst:421
msgid "Function invocation"
msgstr ""

#: ../doc/book/sql.rst:421
msgid "``SELECT f(1) FROM t;``"
msgstr ""

#: ../doc/book/sql.rst:421
msgid "Okay. Tarantool can invoke Lua user-defined functions."
msgstr ""

#: ../doc/book/sql.rst:423
msgid "T321-04"
msgstr ""

#: ../doc/book/sql.rst:423
msgid "CALL statement."
msgstr ""

#: ../doc/book/sql.rst:423
msgid "``CALL p();``"
msgstr ""

#: ../doc/book/sql.rst:426
msgid "T321-05"
msgstr ""

#: ../doc/book/sql.rst:426
msgid "RETURN statement."
msgstr ""

#: ../doc/book/sql.rst:426
msgid "``CREATE FUNCTION f() RETURNS INTEGER RETURN 5;``"
msgstr ""

#: ../doc/book/sql.rst:426
msgid "Fail. Tarantool doesn't support user-defined functions."
msgstr ""

#: ../doc/book/sql.rst:429
msgid "T631"
msgstr ""

#: ../doc/book/sql.rst:429
msgid "IN predicate with one list element"
msgstr ""

#: ../doc/book/sql.rst:429
msgid "``SELECT * FROM t WHERE 1 IN (1);``"
msgstr ""

#: ../doc/book/sql.rst:431
msgid "F021"
msgstr ""

#: ../doc/book/sql.rst:431
msgid "Basic information schema"
msgstr ""

#: ../doc/book/sql.rst:431
msgid "``SELECT * FROM information_schema.tables;``"
msgstr ""

#: ../doc/book/sql.rst:431
msgid "Fail. There is no schema with that name (not counted in the final score)."
msgstr ""

#: ../doc/book/sql.rst:435
msgid "Total number of items marked \"Fail\": 70"
msgstr ""

#: ../doc/book/sql.rst:437
msgid "Total number of items marked \"Okay\": 76"
msgstr ""

