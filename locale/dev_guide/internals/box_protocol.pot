
msgid "Binary protocol"
msgstr ""

msgid "The binary protocol is called a \"request/response\" protocol because it is for sending requests to a Tarantool server and receiving responses. There is complete access to Tarantool functionality, including:"
msgstr ""

msgid "request multiplexing, for example ability to issue multiple requests asynchronously via the same connection"
msgstr ""

msgid "response format that supports zero-copy writes"
msgstr ""

msgid "The protocol can be called \"binary\" because the most-frequently-used database accesses are done with binary codes instead of Lua request text. Tarantool experts use it to write their own connectors, to understand network messages, to support new features that their favorite connector doesn't support yet, or to avoid repetitive parsing by the server."
msgstr ""

msgid "Index"
msgstr ""

msgid "Section"
msgstr ""

msgid "Description"
msgstr ""

msgid ":ref:`Symbols and terms <box_protocol-notation>`"
msgstr ""

msgid "Notation of binary protocol"
msgstr ""

msgid ":ref:`Illustration <box_protocol-illustration>`"
msgstr ""

msgid "Illustration of use"
msgstr ""

msgid ":ref:`Header and body <box_protocol-header>`"
msgstr ""

msgid "Header of a request"
msgstr ""

msgid "Requests: |br|:ref:`IPROTO_SELECT <box_protocol-select>` |br|:ref:`IPROTO_INSERT <box_protocol-insert>` |br|:ref:`IPROTO_REPLACE <box_protocol-replace>` |br|:ref:`IPROTO_UPDATE <box_protocol-update>` |br|:ref:`IPROTO_DELETE <box_protocol-delete>` |br|:ref:`IPROTO_CALL_16 <box_protocol-call16>` |br|:ref:`IPROTO_AUTH <box_protocol-auth>` |br|:ref:`IPROTO_EVAL <box_protocol-eval>` |br|:ref:`IPROTO_UPSERT <box_protocol-upsert>` |br|:ref:`IPROTO_CALL <box_protocol-call>` |br|:ref:`IPROTO_EXECUTE <box_protocol-execute>` |br|:ref:`IPROTO_NOP <box_protocol-nop>` |br|:ref:`IPROTO_PREPARE <box_protocol-prepare>` |br|:ref:`IPROTO_PING <box_protocol-ping>` |br|:ref:`IPROTO_JOIN <box_protocol-join>` |br|:ref:`IPROTO_SUBSCRIBE <box_protocol-join>` |br|:ref:`IPROTO_VOTE_DEPRECATED <box_protocol-join>` |br|:ref:`IPROTO_VOTE <box_protocol-join>` |br|:ref:`IPROTO_FETCH_SNAPSHOT <box_protocol-join>` |br|:ref:`IPROTO_REGISTER <box_protocol-join>`"
msgstr ""

msgid "Body of a request"
msgstr ""

msgid ":ref:`Responses if no error and no SQL <box_protocol-responses>`"
msgstr ""

msgid "Responses for no SQL"
msgstr ""

msgid ":ref:`Responses for errors <box_protocol-responses_error>`"
msgstr ""

msgid "Responses for errors"
msgstr ""

msgid ":ref:`Responses for SQL <box_protocol-sql_protocol>`"
msgstr ""

msgid "Responses for SQL"
msgstr ""

msgid ":ref:`Authentication <box_protocol-authentication>`"
msgstr ""

msgid "Authentication after connection"
msgstr ""

msgid ":ref:`Replication <box_protocol-replication>`"
msgstr ""

msgid "Replication request"
msgstr ""

msgid ":ref:`XLOG/SNAP <box_protocol-xlog>`"
msgstr ""

msgid "Format of .xlog and .snap files"
msgstr ""

msgid "Binary protocol -- symbols and terms"
msgstr ""

msgid "For diagrams in this section, the box borders have special meanings:"
msgstr ""

msgid "0    X\n"
"+----+\n"
"|    | - X + 1 bytes\n"
"+----+\n"
" TYPE - type of MessagePack value (if it is a MessagePack object)\n"
"\n"
"+====+\n"
"|    | - Variable size MessagePack object\n"
"+====+\n"
" TYPE - type of MessagePack value\n"
"\n"
"+~~~~+\n"
"|    | - Variable size MessagePack Array/Map\n"
"+~~~~+\n"
" TYPE - type of MessagePack value"
msgstr ""

msgid "And words that start with **MP_** mean: a `MessagePack <http://MessagePack.org>`_ type or a range of MessagePack types, including the signal and possibly including a value, with slight modification:"
msgstr ""

msgid "**MP_NIL**    nil"
msgstr ""

msgid "**MP_UINT**   unsigned integer"
msgstr ""

msgid "**MP_INT**    either integer or unsigned integer"
msgstr ""

msgid "**MP_STR**    string"
msgstr ""

msgid "**MP_BIN**    binary string"
msgstr ""

msgid "**MP_ARRAY**  array"
msgstr ""

msgid "**MP_MAP**    map"
msgstr ""

msgid "**MP_BOOL**   boolean"
msgstr ""

msgid "**MP_FLOAT**  float"
msgstr ""

msgid "**MP_DOUBLE** double"
msgstr ""

msgid "**MP_EXT**    extension (including the :ref:`DECIMAL type <msgpack_ext-decimal>`)"
msgstr ""

msgid "**MP_OBJECT** any MessagePack object"
msgstr ""

msgid "Short descriptions are in MessagePack's `\"spec\" page <https://github.com/msgpack/msgpack/blob/master/spec.md>`_."
msgstr ""

msgid "And words that start with **IPROTO_** mean: a Tarantool constant which is either defined or mentioned in the `iproto_constants.h file <https://github.com/tarantool/tarantool/blob/master/src/box/iproto_constants.h>`_. These constants are used as keys within MP_MAP maps."
msgstr ""

msgid "Binary protocol -- illustration"
msgstr ""

msgid "To follow the examples in this section, get a single Linux computer and start three command-line shells (\"terminals\")."
msgstr ""

msgid "-- On terminal #1, Start monitoring port 3302 with `tcpdump <https://www.tcpdump.org/manpages/tcpdump.1.html>`_: |br| ``sudo tcpdump -i lo 'port 3302' -X``"
msgstr ""

msgid "On terminal #2, start a server with: |br| ``box.cfg{listen=3302}`` |br| ``box.schema.user.grant('guest','read,write,execute,create,drop','universe')`` |br|"
msgstr ""

msgid "On terminal #3, start another server, which will act as a client, with: |br| ``box.cfg{}`` |br| ``net_box = require('net.box')`` |br| ``conn = net_box.connect('localhost:3302')`` |br| ``conn.space._space:select(280)`` |br|"
msgstr ""

msgid "Now look at what tcpdump shows for the job connecting to 3302. -- the \"request\". After the words \"length 32\" is a packet that ends with with these 32 bytes: (we have added indented comments):"
msgstr ""

msgid "ce 00 00 00 1b   MP_UINT = decimal 27 = number of bytes after this\n"
"82               MP_MAP, size 2 (we'll call this \"Main-Map\")\n"
"01                 IPROTO_SYNC (Main-Map Item#1)\n"
"04                 MP_INT = 4 = number that gets incremented with each request\n"
"00                 IPROTO_REQUEST_TYPE (Main-Map Item#2)\n"
"01                 IPROTO_SELECT\n"
"86                 MP_MAP, size 6 (we'll call this \"Select-Map\")\n"
"10                   IPROTO_SPACE_ID (Select-Map Item#1)\n"
"cd 01 18             MP_UINT = decimal 280 = id of _space\n"
"11                   IPROTO_INDEX_ID (Select-Map Item#2)\n"
"00                   MP_INT = 0 = id of index within _space\n"
"14                   IPROTO_ITERATOR (Select-Map Item#3)\n"
"00                   MP_INT = 0 = Tarantool iterator_type.h constant ITER_EQ\n"
"13                   IPROTO_OFFSET (Select-Map Item#4)\n"
"00                   MP_INT = 0 = amount to offset\n"
"12                   IPROTO_LIMIT (Select-Map Item#5)\n"
"ce ff ff ff ff       MP_UINT = 4294967295 = biggest possible limit\n"
"20                   IPROTO_KEY (Select-Map Item#6)\n"
"91                   MP_ARRAY, size 1 (we'll call this \"Key-Array\")\n"
"cd 01 18               MP_UINT = 280 (Select-Map Item#6, Key-Array Item#1)\n"
"                       -- 280 is the key value that we are searching for"
msgstr ""

msgid "Now read the source code file `net_box.c <https://github.com/tarantool/tarantool/blob/master/src/box/lua/net_box.c>`_ and skip to the line ``netbox_encode_select(lua_State *L)``. From the comments and from simple function calls like ``mpstream_encode_uint(&stream, IPROTO_SPACE_ID);`` you will be able to see how net_box put together the packet contents that you have just observed with tcpdump."
msgstr ""

msgid "There are libraries for reading and writing MessagePack objects. C programmers sometimes include `msgpuck.h <https://github.com/rtsisyk/msgpuck>`_."
msgstr ""

msgid "Now you know how Tarantool itself makes requests with the binary protocol. When in doubt about a detail, consult ``net_box.c`` -- it has routines for each request. Some :ref:`connectors <index-box_connectors>` have similar code."
msgstr ""

msgid "Binary protocol -- header and body"
msgstr ""

msgid "Except during connection (which involves a greeting from the server and optional :ref:`authentication <box_protocol-authentication>` that we will discuss later in this section), the protocol is pure request/response (the client requests and the server responds). It is legal to put more than one request in a packet."
msgstr ""

msgid "Almost all requests and responses contain both a header and a body."
msgstr ""

msgid "Normal Request/Response header and body:\n"
"\n"
"0        5\n"
"+--------+ +============+ +===================================+\n"
"| HEADER | |            | |                                   |\n"
"| + BODY | |   HEADER   | |               BODY                |\n"
"|  SIZE  | |            | |                                   |\n"
"+--------+ +============+ +===================================+\n"
"  MP_INT       MP_MAP                     MP_MAP"
msgstr ""

msgid "HEADER + BODY SIZE is the size of the header plus the size of the body. It may be useful to compare it with the number of bytes remaining in the packet."
msgstr ""

msgid "HEADER may contain, in any order:"
msgstr ""

msgid "HEADER:\n"
"\n"
"+====================================+=====================+===============================+\n"
"|                                    |                     |                               |\n"
"|   0x00: IPROTO_REQUEST_TYPE        |   0x01: IPROTO_SYNC |   0x05: IPROTO_SCHEMA_VERSION |\n"
"|         or Response-Code-Indicator | MP_INT: MP_INT      | MP_INT: MP_INT                |\n"
"| MP_INT: MP_INT                     |                     |                               |\n"
"|                                    |                     |                               |\n"
"+====================================+=====================+===============================+\n"
"                          MP_MAP"
msgstr ""

msgid "**IPROTO_SYNC** = 0x01. An unsigned integer that should be incremented so that it is unique in every request. This integer is also returned from :ref:`box.session.sync() <box_session-sync>`. The IPROTO_SYNC value of a response should be the same as the IPROTO_SYNC value of a request."
msgstr ""

msgid "**IPROTO_SCHEMA_VERSION** = 0x05. An unsigned number, sometimes called SCHEMA_ID, that goes up when there is a major change. In a request header IPROTO_SCHEMA_VERSION is optional, so the version will not be checked if it is absent. In a response header IPROTO_SCHEMA_VERSION is always present, and it is up to the client to check if it has changed."
msgstr ""

msgid "**IPROTO_REQUEST_TYPE** or Response-Code-Indicator = 0x00. An unsigned number that indicates what will be in the BODY. In requests IPROTO_REQUEST_TYPE will be followed by IPROTO_SELECT etc. In responses Response-Code-Indicator will be followed by IPROTO_OK etc."
msgstr ""

msgid "The BODY has the details of the request or response. In a request, it can also be absent or be an empty map. Both these states will be interpreted equally. Responses will contain the BODY anyway even if it is a :ref:`IPROTO_PING <box_protocol-ping>` request."
msgstr ""

msgid "Have a look at file `xrow.c <https://github.com/tarantool/tarantool/blob/master/src/box/xrow.c>`_ function xrow_header_encode, to see how Tarantool encodes the header. Have a look at file net_box.c, function netbox_decode_data, to see how Tarantool decodes the header. For example, in a successful response to ``box.space:select()``, the Response-Code-Indicator value will be 0 = IPROTO_OK and the array will have all the tuples of the result."
msgstr ""

msgid "Binary protocol -- requests"
msgstr ""

msgid "After the :ref:`HEADER <box_protocol-header>`, for a request, there will be a body that begins with these request-type IPROTO codes."
msgstr ""

msgid "**IPROTO_SELECT** = 0x01."
msgstr ""

msgid "See :ref:`space_object:select()  <box_space-select>`. The body is a 6-item map:"
msgstr ""

msgid "+=========================+=========================+=========================+\n"
"|                         |                         |                         |\n"
"|   0x10: IPROTO_SPACE_ID |   0x11: IPROTO_INDEX_ID |   0x12: IPROTO_LIMIT    |\n"
"| MP_INT: MP_INT          | MP_INT: MP_INT          | MP_INT: MP_INT          |\n"
"|                         |                         |                         |\n"
"+=========================+=========================+=========================+\n"
"|                         |                         |                         |\n"
"|   0x13: IPROTO_OFFSET   |   0x14: IPROTO_ITERATOR |   0x20: IPROTO_KEY      |\n"
"| MP_INT: MP_INT          | MP_INT: MP_INT          | MP_INT: MP_ARRAY        |\n"
"|                         |                         |                         |\n"
"+=========================+=========================+=========================+\n"
"             MP_MAP"
msgstr ""

msgid "IPROTO_SPACE_ID (0x10) + MP_INT, IPROTO_INDEX_ID (0x11) + MP_INT, IPROTO_ITERATOR (0x14) + MP_INT, IPROTO_OFFSET (0x13) + MP_INT, IPROTO_LIMIT (0x12) + MP_INT, IPROTO_KEY (0x20) + MP_ARRAY (array of key values). See the illustration of IPROTO_SELECT in the earlier section, :ref:`Binary protocol -- illustration <box_protocol-illustration>`."
msgstr ""

msgid "**IPROTO_INSERT** == 0x02."
msgstr ""

msgid "See :ref:`space_object:insert()  <box_space-insert>`. The body is a 2-item map:"
msgstr ""

msgid "+=========================+======================+\n"
"|                         |                      |\n"
"|   0x10: IPROTO_SPACE_ID |   0x21: IPROTO_TUPLE |\n"
"| MP_INT: MP_INT          | MP_INT: MP_ARRAY     |\n"
"|                         |                      |\n"
"+=========================+======================+\n"
"                 MP_MAP"
msgstr ""

msgid "IPROTO_SPACE_ID (0x10) + MP_INT, IPROTO_TUPLE + MP_ARRAY (array of field values)."
msgstr ""

msgid "**IPROTO_REPLACE** = 0x03, See :ref:`space_object:replace()  <box_space-replace>`. The body is a 2-item map, the same as for IPROTO_INSERT:"
msgstr ""

msgid "+=========================+======================+\n"
"|                         |                      |\n"
"|   0x10: IPROTO_SPACE_ID |   0x21: IPROTO_TUPLE |\n"
"| MP_INT: MP_INT          | MP_INT: MP_ARRAY     |\n"
"|                         |                      |\n"
"+=========================+======================+\n"
"               MP_MAP"
msgstr ""

msgid "IPROTO_SPACE_ID (0x10) + MP_INT, IPROTO_TUPLE (0x21) + MP_ARRAY (array of field values)."
msgstr ""

msgid "**IPROTO_UPDATE** = 0x04."
msgstr ""

msgid "See :ref:`space_object:update()  <box_space-update>`. The body is usually a 4-item map,"
msgstr ""

msgid "+=========================+===============================+\n"
"|                         |                               |\n"
"|   0x10: IPROTO_SPACE_ID |   0x11: IPROTO_INDEX_ID       |\n"
"| MP_INT: MP_INT          | MP_INT: MP_INT                |\n"
"|                         |                               |\n"
"+=========================+===============================+\n"
"|                         |                 +~~~~~~~~~~~+ |\n"
"|                         |                 | usually   | |\n"
"|                         |                 | OPERATOR, | |\n"
"|                         | (IPROTO_TUPLE)  | FIELD_NO, | |\n"
"|   0x20: IPROTO_KEY      |    0x21:        | VALUE     | |\n"
"| MP_INT: MP_ARRAY        |  MP_INT:        +~~~~~~~~~~~+ |\n"
"|                         |                   MP_ARRAY    |\n"
"+=========================+===============================+\n"
"                MP_MAP"
msgstr ""

msgid "IPROTO_SPACE_ID (0x10) + MP_INT, IPROTO_INDEX_ID (0x11) + MP_INT with index number starting with 0, IPROTO_KEY (0x20) + MP_ARRAY (array of index keys), IPROTO_TUPLE (0x21) + MP_ARRAY (array of update operations). |br| If the operation specifies no values, it is a 2-item array: OPERATOR MP_STR = ``\"#\"``, FIELD_NO MP_INT = field number starting with 1. |br| If the operation specifies one value, it is a 3-item array: |br|"
msgstr ""

msgid "0           2\n"
"+-------------+==========+===========+\n"
"|             |          |           |\n"
"| OPERATOR    | FIELD_NO | VALUE     |\n"
"| MP_STR      | MP_INT   | MP_OBJECT |\n"
"|             |          |           |\n"
"+-------------+==========+===========+\n"
"          MP_ARRAY"
msgstr ""

msgid "OPERATOR MP_STR = ``\"+\"`` or ``\"-\"`` or ``\"&\"`` or ``\"^\"`` or ``\"|\"`` or ``\"!\"`` or ``\"=\"``), FIELD_NO MP_INT = field number starting with 1, VALUE MP_OBJECT, that is, any type, MP_INT, MP_STR, etc.. |br| Otherwise the operation is a 5-item array: |br|"
msgstr ""

msgid "0           2\n"
"+-----------+==========+==========+========+==========+\n"
"|           |          |          |        |          |\n"
"| ':'       | FIELD_NO | POSITION | OFFSET | VALUE    |\n"
"| MP_STR    | MP_INT   | MP_INT   | MP_INT | MP_STR   |\n"
"|           |          |          |        |          |\n"
"+-----------+==========+==========+========+==========+\n"
"                      MP_ARRAY"
msgstr ""

msgid "OPERATOR MP_STR = ``\":\"``, FIELD_NO MP_INT = field number starting with 1, POSITION MP_INT, OFFSET MP_INT, VALUE MP_STR."
msgstr ""

msgid "For example, suppose a user changes field #2 in tuple #2 in space #256 to 'BBBB'. The body will look like this: (notice that in this case there is an extra map item IPROTO_INDEX_BASE, to emphasize that field numbers start with 1, which is optional and can be omitted):"
msgstr ""

msgid "04               IPROTO_UPDATE\n"
"85               IPROTO_MAP, size 5\n"
"10                 IPROTO_SPACE_ID, Map Item#1\n"
"cd 02 00           MP_UINT 256\n"
"11                 IPROTO_INDEX_ID, Map Item#2\n"
"00                 MP_INT 0 = primary-key index number\n"
"15                 IPROTO_INDEX_BASE, Map Item#3\n"
"01                 MP_INT = 1 i.e. field numbers start at 1\n"
"21                 IPROTO_TUPLE, Map Item#4\n"
"91                 MP_ARRAY, size 1, for array of operations\n"
"93                   MP_ARRAY, size 3\n"
"a1 3d                   MP_STR = OPERATOR = '='\n"
"02                      MP_INT = FIELD_NO = 2\n"
"a5 42 42 42 42 42       MP_STR = VALUE = 'BBBB'\n"
"20                 IPROTO_KEY, Map Item#5\n"
"91                 MP_ARRAY, size 1, for array of key values\n"
"02                   MP_UINT = primary-key value = 2"
msgstr ""

msgid "**IPROTO_DELETE** = 0x05."
msgstr ""

msgid "See :ref:`space_object:delete()  <box_space-delete>`. The body is a 3-item map:"
msgstr ""

msgid "+=========================+=========================+====================+\n"
"|                         |                         |                    |\n"
"|   0x10: IPROTO_SPACE_ID |   0x11: IPROTO_INDEX_ID |   0x20: IPROTO_KEY |\n"
"| MP_INT: MP_INT          | MP_INT: MP_INT          | MP_INT: MP_ARRAY   |\n"
"|                         |                         |                    |\n"
"+=========================+=========================+====================+\n"
"                          MP_MAP"
msgstr ""

msgid "IPROTO_SPACE_ID (0x10) + MP_INT, IPROTO_INDEX_ID (0x11) + MP_INT, IPROTO_KEY (0x20) + MP_ARRAY (array of key values)."
msgstr ""

msgid "**IPROTO_CALL_16** = 0x06."
msgstr ""

msgid "See :ref:`conn:call() <net_box-call>`. The suffix ``_16`` is a hint that this is for the ``call()`` until Tarantool 1.6. It is deprecated. Use :ref:`IPROTO_CALL <box_protocol-call>` instead. The body is a 2-item map:"
msgstr ""

msgid "+==============================+=======================+\n"
"|                              |                       |\n"
"|   0x22: IPROTO_FUNCTION_NAME |   0x21: IPROTO_TUPLE  |\n"
"| MP_INT: MP_STRING            | MP_INT: MP_ARRAY      |\n"
"|                              |                       |\n"
"+==============================+=======================+\n"
"                    MP_MAP"
msgstr ""

msgid "IPROTO_FUNCTION_NAME (0x22) +  function name (MP_STRING), IPROTO_TUPLE (0x22) + array of arguments (MP_ARRAY). The return value is an array of tuples."
msgstr ""

msgid "**IPROTO_AUTH** = 0x07."
msgstr ""

msgid "See :ref:`authentication <authentication-users>`. See the later section :ref:`Binary protocol -- authentication <box_protocol-authentication>`."
msgstr ""

msgid "**IPROTO_EVAL** = 0x08."
msgstr ""

msgid "See :ref:`conn:eval() <net_box-eval>`. Since the argument is a Lua expression, this is Tarantool's way to handle non-binary with the binary protocol. Any request that does not have its own code, for example :samp:`box.space.{space-name}:drop()`, will be handled either with :ref:`IPROTO_CALL <box_protocol-call>` or IPROTO_EVAL. The :ref:`tarantoolctl <tarantoolctl>` administrative utility makes extensive use of ``eval``. The body is a 2-item map:"
msgstr ""

msgid "+=======================+======================+\n"
"|                       |                      |\n"
"|   0x27: IPROTO_EXPR   |   0x21: IPROTO_TUPLE |\n"
"| MP_INT: MP_STRING     | MP_INT: MP_ARRAY     |\n"
"|                       |                      |\n"
"+=======================+======================+\n"
"                MP_MAP"
msgstr ""

msgid "IPROTO_EXPR (0x27) + expression (MP_STRING), IPROTO_TUPLE (0x21) + array of arguments to match placeholders."
msgstr ""

msgid "**IPROTO_UPSERT** = 0x09."
msgstr ""

msgid "See :ref:`space_object:upsert()  <box_space-upsert>`."
msgstr ""

msgid "+===============================+===============================+\n"
"|                               |                               |\n"
"|   0x10: IPROTO_SPACE_ID       |   0x15: IPROTO_INDEX_BASE     |\n"
"| MP_INT: MP_INT                | MP_INT: MP_INT                |\n"
"|                               |                               |\n"
"+===============================+===============================+\n"
"|                 +~~~~~~~~~~~+ |                               |\n"
"|                 | usually   | |   0x21: IPROTO_TUPLE          |\n"
"|                 | OPERATOR, | | MP_INT: MP_ARRAY              |\n"
"| (IPROTO_OPS)    | FIELD_NO, | |                               |\n"
"|    0x28:        | VALUE     | |                               |\n"
"|  MP_INT:        +~~~~~~~~~~~+ |                               |\n"
"|                   MP_ARRAY    |                               |\n"
"+===============================+===============================+\n"
"            MP_MAP"
msgstr ""

msgid "IPROTO_SPACE_ID (0x10) + MP_INT, IPROTO_INDEX_BASE (0x15) + MP_INT with index number starting with 1, IPROTO_OPS (0x28) + MP_ARRAY (array of upsert operations), IPROTO_TUPLE (0x21) + MP_ARRAY (array of primary-key-field values). |br|"
msgstr ""

msgid "The IPROTO_OPS is the same as the IPROTO_OPS of :ref:`IPROTO_UPDATE <box_protocol-update>`."
msgstr ""

msgid "**IPROTO_CALL** = 0x0a."
msgstr ""

msgid "See :ref:`conn:call() <net_box-call>`. The body is a 2-item map:"
msgstr ""

msgid "+==============================+======================+\n"
"|                              |                      |\n"
"|   0x22: IPROTO_FUNCTION_NAME |   0x21: IPROTO_TUPLE |\n"
"| MP_INT: MP_STRING            | MP_INT: MP_ARRAY     |\n"
"|                              |                      |\n"
"+==============================+======================+\n"
"                        MP_MAP"
msgstr ""

msgid "IPROTO_FUNCTION_NAME (0x22) +  function name (MP_STRING), IPROTO_TUPLE (0x22) + array of arguments (MP_ARRAY). The response will be a list of values, similar to the :ref:`IPROTO_EVAL <box_protocol-eval>` response."
msgstr ""

msgid "**IPROTO_EXECUTE** = 0x0b."
msgstr ""

msgid "See :ref:`box.execute() <box-sql_box_execute>`, this is only for SQL. The body is a 3-item map:"
msgstr ""

msgid "+=========================+=========================+========================+\n"
"|                         |                         |                        |\n"
"|   0x43: IPROTO_STMT_ID  |   0x11: IPROTO_SQL_BIND |   0x20: IPROTO_OPTIONS |\n"
"| MP_INT: MP_INT          | MP_INT: MP_INT          | MP_INT: MP_ARRAY       |\n"
"|   or                    |                         |                        |\n"
"|   0x40: IPROTO_SQL_TEXT |                         |                        |\n"
"| MP_INT: MP_STR          |                         |                        |\n"
"|                         |                         |                        |\n"
"+=========================+=========================+========================+\n"
"                          MP_MAP"
msgstr ""

msgid "IPROTO_STMT_ID (0x43) + statement-id (MP_INT) if executing a prepared statement or IPROTO_SQL_TEXT (0x40) + statement-text (MP_STR) if executing an SQL string, IPROTO_SQL_BIND (0x41) + array of parameter values to match ? placeholders or :name placeholders, IPROTO_OPTIONS (0x2b) + array of options (usually empty)."
msgstr ""

msgid "For example, suppose we prepare a statement with two ? placeholders, and execute with two parameters, thus: |br| :code:`n = conn:prepare([[VALUES (?, ?);]])` |br| :code:`conn:execute(n.stmt_id, {1,'a'})` |br| Then the body will look like this:"
msgstr ""

msgid "0b               IPROTO_EXECUTE\n"
"83               MP_MAP, size 3\n"
"43                 IPROTO_STMT_ID Map Item#1\n"
"ce d7 aa 74 1b     MP_UINT value of n.stmt_id\n"
"41                 IPROTO_SQL_BIND Map Item#2\n"
"92                 MP_ARRAY, size 2\n"
"01                   MP_INT = 1 = value for first parameter\n"
"a1 61                MP_STR = 'a' = value for second parameter\n"
"2b                 IPROTO_OPTIONS Map Item#3\n"
"90                 MP_ARRAY, size 0 (there are no options)"
msgstr ""

msgid "To call a prepared statement with named parameters from a connector pass the parameters within an array of maps. A client should wrap each element into a map, where the key holds a name of the parameter (with a colon) and the value holds an actual value. So, to bind foo and bar to 42 and 43, a client should send ``IPROTO_SQL_TEXT: <...>, IPROTO_SQL_BIND: [{\"foo\": 42}, {\"bar\": 43}]``."
msgstr ""

msgid "If a statement has both named and non-named parameters, wrap only named ones into a map. The rest of parameters are positional and substituted in order."
msgstr ""

msgid "**IPROTO_NOP** = 0x0c."
msgstr ""

msgid "There is no Lua request exactly equivalent to IPROTO_NOP. It causes the LSN to be incremented. It could be sometimes used for updates where the old and new values are the same, but the LSN must be increased because a data-change must be recorded. The body is: nothing."
msgstr ""

msgid "**IPROTO_PREPARE** = 0x0d."
msgstr ""

msgid "See :ref:`box.prepare <box-sql_box_prepare>`, this is only for SQL. The body is a 1-item map:"
msgstr ""

msgid "+=========================+\n"
"|                         |\n"
"|   0x10: IPROTO_STMT_ID  |\n"
"| MP_INT: MP_INT          |\n"
"|   or                    |\n"
"|   0x10: IPROTO_SQL_TEXT |\n"
"| MP_INT: MP_STR          |\n"
"|                         |\n"
"+=========================+\n"
"     MP_MAP"
msgstr ""

msgid "IPROTO_STMT_ID (0x43) + statement-id (MP_INT) if executing a prepared statement or IPROTO_SQL_TEXT (0x40) + statement-text (string) if executing an SQL string. Thus the IPROTO_PREPARE map item is the same as the first item of the :ref:`IPROTO_EXECUTE <box_protocol-execute>` map."
msgstr ""

msgid "**IPROTO_PING** = 0x40."
msgstr ""

msgid "See :ref:`conn:ping() <conn-ping>`. The BODY will be an empty map because IPROTO_PING in the HEADER contains all the information that the server instance needs."
msgstr ""

msgid "**IPROTO_JOIN** = 0x41, for replication  |br| **IPROTO_SUBSCRIBE** = 0x42, for replication SUBSCRIBE |br| **IPROTO_VOTE_DEPRECATED** = 0x43, for old style vote, superseded by IPROTO_VOTE |br| **IPROTO_VOTE** = 0x44, for master election |br| **IPROTO_FETCH_SNAPSHOT** = 0x45, for starting anonymous replication |br| **IPROTO_REGISTER** =0x46, for leaving anonymous replication."
msgstr ""

msgid "Tarantool constants 0x41 to 0x46 (decimal 65 to 70) are for replication. Connectors and clients do not need to send replication packets. See :ref:`Binary protocol -- replication <box_protocol-replication>`."
msgstr ""

msgid "The next two IProto messages are used in replication connections between Tarantool nodes in :ref:`synchronous replication <repl_sync>`. The messages are not supposed to be used by any client applications in their regular connections."
msgstr ""

msgid "**IPROTO_CONFIRM** = 0x28"
msgstr ""

msgid "This message confirms that the transactions originated from the instance with id = IPROTO_REPLICA_ID have achieved quorum and can be committed, up to LSN = IPROTO_LSN and including it."
msgstr ""

msgid "The body is a 2-item map:"
msgstr ""

msgid "+===========================+====================+\n"
"|                           |                    |\n"
"|   0x02: IPROTO_REPLICA_ID |   0x03: IPROTO_LSN |\n"
"| MP_UINT: MP_UINT          | MP_UINT: MP_UINT   |\n"
"|                           |                    |\n"
"+===========================+====================+\n"
"                    MP_MAP"
msgstr ""

msgid "**IPROTO_ROLLBACK** = 0x29"
msgstr ""

msgid "This message says that the transactions originated from the instance with id = IPROTO_REPLICA_ID couldn't achieve quorum for some reason and should be rolled back, down to LSN = IPROTO_LSN and including it."
msgstr ""

msgid "Binary protocol -- responses if no error and no SQL"
msgstr ""

msgid "After the :ref:`HEADER <box_protocol-header>`, for a response, there will be a body. It will contain IPROTO_OK (0x00) (there was no error), or an error code other than IPROTO_OK (there was an error). Responses to SQL statements are slightly different and will be described in the later section, :ref:`Binary protocol -- responses for SQL <box_protocol-sql_protocol>`."
msgstr ""

msgid "For IPROTO_OK, the header Response-Code-Indicator will be 0 and the body will be:"
msgstr ""

msgid "++=====================+\n"
"||                     |\n"
"||   0x30: IPROTO_DATA |\n"
"|| MP_INT: MP_OBJECT   |\n"
"||                     |\n"
"++=====================+\n"
"    MP_MAP"
msgstr ""

msgid "For :ref:`IPROTO_PING <box_protocol-ping>` the body will be an empty map. For most data-access requests (IPROTO_SELECT IPROTO_INSERT IPROTO_DELETE etc.) it will be an array of tuples that contain an array of fields. For :ref:`IPROTO_EVAL <box_protocol-eval>` and :ref:`IPROTO_CALL <box_protocol-call>` it will usually be an array but, since Lua requests can result in a wide variety of structures, bodies can have a wide variety of structures."
msgstr ""

msgid "For example, after :codenormal:`box.space.`:codeitalic:`space-name`:codenormal:`:insert{6}` a successful response will look like this:"
msgstr ""

msgid "ce 00 00 00 20                MP_UINT = HEADER + BODY SIZE\n"
"83                            MP_MAP, size 3\n"
"00                              Response-Code-Indicator\n"
"ce 00 00 00 00                  MP_UINT = IPROTO_OK\n"
"01                              IPROTO_SYNC\n"
"cf 00 00 00 00 00 00 00 53      MP_UINT = sync value\n"
"05                              IPROTO_SCHEMA_VERSION\n"
"ce 00 00 00 68                  MP_UINT = schema version\n"
"81                            MP_MAP, size 1\n"
"30                              IPROTO_DATA\n"
"dd 00 00 00 01                  MP_ARRAY, size 1 (row count)\n"
"91                              MP_ARRAY, size 1 (field count)\n"
"06                              MP_INT = 6 = the value that was inserted"
msgstr ""

msgid "IPROTO_DATA is what we get with net_box and :ref:`Module buffer <buffer-module>` so if we were using net_box we could decode with :ref:`msgpack.decode_unchecked() <msgpack-decode_unchecked_string>`, or we could convert to a string with :samp:`ffi.string({pointer},{length})`. The :ref:`pickle.unpack() <pickle-unpack>` function might also be helpful."
msgstr ""

msgid "Binary protocol -- responses for errors"
msgstr ""

msgid "For a response other than IPROTO_OK, the header Response-Code-Indicator will be 0x8XXX and the body will be:"
msgstr ""

msgid "++=========================+\n"
"||                         |\n"
"||   0x31: IPROTO_ERROR_24 |\n"
"|| MP_INT: MP_STRING       |\n"
"||                         |\n"
"++=========================+\n"
"      MP_MAP"
msgstr ""

msgid "where 0x8XXX is the indicator for an error and XXX is a value in `src/box/errcode.h <https://github.com/tarantool/tarantool/blob/master/src/box/errcode.h>`_. ``src/box/errcode.h`` also has some convenience macros which define hexadecimal constants for return codes."
msgstr ""

msgid "For example, in version 2.4.0 or earlier, if we try to create a duplicate space with |br| ``conn:eval([[box.schema.space.create('_space');]])`` |br| the server response will look like this:"
msgstr ""

msgid "ce 00 00 00 3b                  MP_UINT = HEADER + BODY SIZE\n"
"83                              MP_MAP, size 3 (i.e. 3 items in header)\n"
"  00                              Response-Code-Indicator\n"
"  ce 00 00 80 0a                  MP_UINT = hexadecimal 800a\n"
"  01                              IPROTO_SYNC\n"
"  cf 00 00 00 00 00 00 00 26      MP_UINT = sync value\n"
"  05                              IPROTO_SCHEMA_VERSION\n"
"  ce 00 00 00 78                  MP_UINT = schema version value\n"
"  81                              MP_MAP, size 1\n"
"    31                              IPROTO_ERROR_24\n"
"    db 00 00 00 1d 53 70 61 63 etc. MP_STR = \"Space '_space' already exists\""
msgstr ""

msgid "Looking in errcode.h we find that error code 0x0a (decimal 10) is ER_SPACE_EXISTS, and the string associated with ER_SPACE_EXISTS is \"Space '%s' already exists\"."
msgstr ""

msgid "Beginning in version 2.4.1, responses for errors have extra information following what was described above. This extra information is given via MP_ERROR extension type. See details in :ref:`MessagePack extensions <msgpack_ext-error>` section."
msgstr ""

msgid "Binary protocol -- responses for SQL"
msgstr ""

msgid "After the :ref:`HEADER <box_protocol-header>`, for a response to an SQL statement, there will be a body that is slightly different from the body for :ref:`Binary protocol -- responses if no error and no SQL <box_protocol-responses>`."
msgstr ""

msgid "If the SQL request is not SELECT or VALUES or PRAGMA, then the response body contains only IPROTO_SQL_INFO (0x42). Usually IPROTO_SQL_INFO is a map with only one item -- SQL_INFO_ROW_COUNT (0x00) -- which is the number of changed rows."
msgstr ""

msgid "+=========================================================+\n"
"|                                                         |\n"
"|   0x42: IPROTO_SQL_INFO                                 |\n"
"| MP_MAP: usually 1 item  +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+ |\n"
"|                         |                             | |\n"
"|                         |    0x00: SQL_INFO_ROW_COUNT | |\n"
"|                         | MP_UINT: changed row count  | |\n"
"|                         |                             | |\n"
"|                         +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+ |\n"
"|                                                         |\n"
"+=========================================================+"
msgstr ""

msgid "For example, if the request is :samp:`INSERT INTO {table-name} VALUES (1), (2), (3)`, then the response body contains an IPROTO_SQL_INFO map with SQL_INFO_ROW_COUNT = 3. SQL_INFO_ROW_COUNT can be 0 for statements that do not change rows, but can be 1 for statements that create new objects."
msgstr ""

msgid "The IPROTO_SQL_INFO map may contain a second item -- SQL_INFO_AUTO_INCREMENT_IDS (0x01) -- which is the new primary-key value (or values) for an INSERT in a table defined with PRIMARY KEY AUTOINCREMENT. In this case the MP_MAP will have two keys, and  one of the two keys will be 0x01: SQL_INFO_AUTO_INCREMENT_IDS, which is an array of unsigned integers."
msgstr ""

msgid "For example, if we use the same net.box connection that we used for :ref:`Binary protocol -- illustration <box_protocol-illustration>` and we say |br| ``conn:execute([[CREATE TABLE t1 (dd INT PRIMARY KEY AUTOINCREMENT, дд STRING COLLATE \"unicode\");]])`` |br| ``conn:execute([[INSERT INTO t1 VALUES (NULL, 'a'), (NULL, 'b');]])`` |br| and we watch what tcpdump displays, we will see two noticeable things: (1) the CREATE statement caused a schema change so the response has a new IPROTO_SCHEMA_VERSION value and the body includes the new contents of some system tables (caused by requests from net.box which users will not see); (2) the final bytes of the response to the INSERT will be:"
msgstr ""

msgid "81   MP_MAP, size 1\n"
"42     IPROTO_SQL_INFO\n"
"82     MP_MAP, size 2\n"
"00       Tarantool constant (not in iproto_constants.h) = SQL_INFO_ROW_COUNT\n"
"02       1 = row count\n"
"01       Tarantool constant (not in iproto_constants.h) = SQL_INFO_AUTOINCREMENT_ID\n"
"92       MP_ARRAY, size 2\n"
"01         first autoincrement number\n"
"02         second autoincrement number"
msgstr ""

msgid "If the SQL statement is SELECT or VALUES or PRAGMA, the response contains:"
msgstr ""

msgid "IPROTO_METADATA + array of column maps, with each column map containing at least IPROTO_FIELD_NAME (0x00) + MP_STR, and IPROTO_FIELD_TYPE (0x01) + MP_STR. Additionally, if ``sql_full_metadata`` in the :ref:`_session_settings <box_space-session_settings>` system space is TRUE, then the array will have these additional column maps which correspond to components described in the :ref:`box.execute() <box-sql_if_full_metadata>` section: IPROTO_FIELD_COLL (0x02) + MP_STR, IPROTO_FIELD_IS_NULLABLE (0x03) + MP_BOOL, IPROTO_FIELD_IS_AUTOINCREMENT (0x04) + MP_BOOL, IPROTO_FIELD_SPAN (0x05) + MP_STR or MP_NIL."
msgstr ""

msgid "IPROTO_DATA + array of tuples = the result set \"rows\""
msgstr ""

msgid "EXECUTE SELECT RESPONSE BODY:\n"
"                              MAP\n"
"+=============================================+===========================+\n"
"|                                             |                           |\n"
"|     0x32: IPROTO_METADATA                   |                           |\n"
"| MP_ARRAY: array of maps:                    |                           |\n"
"|           +~~~~~~~~~~~~~~~~~~~~~~-------~~+ |                           |\n"
"|           | +~~~~~~~~~~~~~-------~~~~~~~+ | |     0x30: IPROTO_DATA     |\n"
"|           | |   0x00: IPROTO_FIELD_NAME | | | MP_ARRAY: array of tuples |\n"
"|           | | MP_STR: field name        | | |                           |\n"
"|           | |   0x01: IPROTO_FIELD_TYPE | | |                           |\n"
"|           | | MP_STR: field type        | | |                           |\n"
"|           | | + more if full metadata   | | |                           |\n"
"|           | +~~~~~~~~~~~~~~~~~~~~~~~~~~~+ | |                           |\n"
"|           |        MP_MAP                 | |                           |\n"
"|           +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+ |                           |\n"
"|                   MP_ARRAY                  |                           |\n"
"|                                             |                           |\n"
"+=============================================+===========================+"
msgstr ""

msgid "For example, if we use the same net_box connection that we used for :ref:`Binary protocol -- illustration <box_protocol-illustration>` and we ask for full metadata by saying |br| :code:`conn.space._session_settings:update('sql_full_metadata', {{'=', 'value', true}})` |br| and we select the two rows from the table that we just created |br| :code:`conn:execute([[SELECT dd, дд AS д FROM t1;]])` |br| then tcpdump will show this response, after the header:"
msgstr ""

msgid "82                       MP_MAP, size 2 (i.e. metadata and rows)\n"
"32                         IPROTO_METADATA\n"
"92                         MP_ARRAY, size 2 (i.e. 2 columns)\n"
"85                           MP_MAP, size 5 (i.e. 5 items for column#1)\n"
"00 a2 44 44                    IPROTO_FIELD_NAME + 'DD'\n"
"01 a7 69 6e 74 65 67 65 72     IPROTO_FIELD_TYPE + 'integer'\n"
"03 c2                          IPROTO_FIELD_IS_NULLABLE + false\n"
"04 c3                          IPROTO_FIELD_IS_AUTOINCREMENT + true\n"
"05 c0                          PROTO_FIELD_SPAN + nil\n"
"85                           MP_MAP, size 5 (i.e. 5 items for column#2)\n"
"00 a2 d0 94                    IPROTO_FIELD_NAME + 'Д' upper case\n"
"01 a6 73 74 72 69 6e 67        IPROTO_FIELD_TYPE + 'string'\n"
"02 a7 75 6e 69 63 6f 64 65     IPROTO_FIELD_COLL + 'unicode'\n"
"03 c3                          IPROTO_FIELD_IS_NULLABLE + true\n"
"05 a4 d0 b4 d0 b4              IPROTO_FIELD_SPAN + 'дд' lower case\n"
"30                         IPROTO_DATA\n"
"92                         MP_ARRAY, size 2\n"
"92                           MP_ARRAY, size 2\n"
"01                             MP_INT = 1 i.e. contents of row#1 column#1\n"
"a1 61                          MP_STR = 'a' i.e. contents of row#1 column#2\n"
"92                           MP_ARRAY, size 2\n"
"02                             MP_INT = 2 i.e. contents of row#2 column#1\n"
"a1 62                          MP_STR = 'b' i.e. contents of row#2 column#2"
msgstr ""

msgid "If instead we said |br| :code:`conn:prepare([[SELECT dd, дд AS д FROM t1;]])` |br| then tcpdump would should show almost the same response, but there would be no IPROTO_DATA and there would be two additional items: |br| 34 00 = IPROTO_BIND_COUNT + MP_UINT = 0 (there are no parameters to bind), |br| 33 90 = IPROTO_BIND_METADATA + MP_ARRAY, size 0 (there are no parameters to bind)."
msgstr ""

msgid "84                       MP_MAP, size 4\n"
"43                         IPROTO_STMT_ID\n"
"ce c2 3c 2c 1e             MP_UINT = statement id\n"
"34                         IPROTO_BIND_COUNT\n"
"00                         MP_INT = 0 = number of parameters to bind\n"
"33                         IPROTO_BIND_METADATA\n"
"90                         MP_ARRAY, size 0 = there are no parameters to bind\n"
"32                         IPROTO_METADATA\n"
"92                         MP_ARRAY, size 2 (i.e. 2 columns)\n"
"85                           MP_MAP, size 5 (i.e. 5 items for column#1)\n"
"00 a2 44 44                    IPROTO_FIELD_NAME + 'DD'\n"
"01 a7 69 6e 74 65 67 65 72     IPROTO_FIELD_TYPE + 'integer'\n"
"03 c2                          IPROTO_FIELD_IS_NULLABLE + false\n"
"04 c3                          IPROTO_FIELD_IS_AUTOINCREMENT + true\n"
"05 c0                          PROTO_FIELD_SPAN + nil\n"
"85                           MP_MAP, size 5 (i.e. 5 items for column#2)\n"
"00 a2 d0 94                    IPROTO_FIELD_NAME + 'Д' upper case\n"
"01 a6 73 74 72 69 6e 67        IPROTO_FIELD_TYPE + 'string'\n"
"02 a7 75 6e 69 63 6f 64 65     IPROTO_FIELD_COLL + 'unicode'\n"
"03 c3                          IPROTO_FIELD_IS_NULLABLE + true\n"
"05 a4 d0 b4 d0 b4              IPROTO_FIELD_SPAN + 'дд' lower case"
msgstr ""

msgid "Now read the source code file `net_box.c <https://github.com/tarantool/tarantool/blob/master/src/box/lua/net_box.c>`_ where the function \"decode_metadata_optional\" is an example of how Tarantool itself decodes extra items."
msgstr ""

msgid "Binary protocol -- authentication"
msgstr ""

msgid "When a client connects to the server instance, the instance responds with a 128-byte text greeting message, like this:"
msgstr ""

msgid "Greeting packet sent by server after connect:\n"
"\n"
"0                                     63\n"
"+--------------------------------------+\n"
"|                                      |\n"
"| Tarantool Greeting (server version)  |\n"
"|               64 bytes               |\n"
"+---------------------+----------------+\n"
"|                     |                |\n"
"| BASE64 encoded SALT |      NULL      |\n"
"|      44 bytes       |                |\n"
"+---------------------+----------------+\n"
"64                  107              127"
msgstr ""

msgid "The greeting contains two 64-byte lines of ASCII text. Each line ends with a newline character (:code:`\\n`). The first line contains the instance version and protocol type. The second line contains up to 44 bytes of base64-encoded random string, to use in the authentication packet, and ends with up to 23 spaces."
msgstr ""

msgid "Part of the greeting is a base-64-encoded session salt - a random string which can be used for authentication. The maximum length of an encoded salt (44 bytes) is more than the amount necessary to create the authentication message. An excess is reserved for future authentication schemas."
msgstr ""

msgid "Authentication is optional -- if it is skipped, then the session user is ``'guest'`` (the ``'guest'`` user does not need a password)."
msgstr ""

msgid "If authentication is not skipped, then at any time an authentication packet can be prepared using the greeting, the user's name and password, and `sha-1 <https://en.wikipedia.org/wiki/SHA-1>`_ functions, as follows."
msgstr ""

msgid "PREPARE SCRAMBLE:\n"
"\n"
"    size_of_encoded_salt_in_greeting = 44;\n"
"    size_of_salt_after_base64_decode = 32;\n"
"    /* sha1() will only use the first 20 bytes */\n"
"    size_of_any_sha1_digest = 20;\n"
"    size_of_scramble = 20;\n"
"\n"
"prepare 'chap-sha1' scramble:\n"
"\n"
"    salt = base64_decode(encoded_salt);\n"
"    step_1 = sha1(password);\n"
"    step_2 = sha1(step_1);\n"
"    step_3 = sha1(first_20_bytes_of_salt, step_2);\n"
"    scramble = xor(step_1, step_3);\n"
"    return scramble;\n"
"\n"
"AUTHORIZATION BODY: CODE = IPROTO_AUTH (0x07)\n"
"\n"
"+==========================+=====================================+\n"
"|                          |        +-------------+------------+ |\n"
"|  (KEY)                   | (TUPLE)| size == 9   | size == 20 | |\n"
"|   0x23: IPROTO_USER_NAME |   0x21:| \"chap-sha1\" |  SCRAMBLE  | |\n"
"| MP_INT: MP_STRING        | MP_INT:|  MP_STRING  |  MP_STRING | |\n"
"|                          |        +-------------+------------+ |\n"
"|                          |                   MP_ARRAY          |\n"
"+==========================+=====================================+\n"
"                        MP_MAP"
msgstr ""

msgid ":code:`<key>` holds the user name. :code:`<tuple>` must be an array of 2 fields: authentication mechanism (\"chap-sha1\" is the only supported mechanism right now) and scramble, encrypted according to the specified mechanism."
msgstr ""

msgid "The server instance responds to an authentication packet with a standard response with 0 tuples."
msgstr ""

msgid "To see how Tarantool handles this, look at `net_box.c <https://github.com/tarantool/tarantool/blob/master/src/box/lua/net_box.c>`_ function netbox_encode_auth."
msgstr ""

msgid "Binary protocol -- replication"
msgstr ""

msgid "-- replication keys\n"
"<server_id>    ::= 0x02\n"
"<lsn>          ::= 0x03\n"
"<timestamp>    ::= 0x04\n"
"<server_uuid>  ::= 0x24\n"
"<cluster_uuid> ::= 0x25\n"
"<vclock>       ::= 0x26"
msgstr ""

msgid "-- replication codes\n"
"<join>         ::= 0x41\n"
"<subscribe>    ::= 0x42"
msgstr ""

msgid "JOIN:\n"
"\n"
"In the beginning you must send an initial IPROTO_JOIN request (0x41)\n"
"               HEADER                      BODY\n"
"+================+=======================++========================+\n"
"|                |                       ||   IPROTO_INSTANCE_UUID |\n"
"|   0x00: 0x41   |   0x01: IPROTO_SYNC   ||   0x24: UUID           |\n"
"| MP_INT: MP_INT | MP_INT: MP_INT        || MP_INT: MP_STRING      |\n"
"|                |                       ||                        |\n"
"+================+=======================++========================+\n"
"               MP_MAP                     MP_MAP\n"
"\n"
"Then the instance which you want to connect to will send its last SNAP file,\n"
"by simply creating a number of INSERTs (with additional LSN and ServerID)\n"
"(do not reply to this). Then that instance will send a vclock's MP_MAP and\n"
"close a socket.\n"
"\n"
"+================+=======================++============================+\n"
"|                |                       ||        +~~~~~~~~~~~~~~~~~+ |\n"
"|                |                       ||        |                 | |\n"
"|   0x00: 0x00   |   0x01: IPROTO_SYNC   ||   0x26:| SRV_ID: SRV_LSN | |\n"
"| MP_INT: MP_INT | MP_INT: MP_INT        || MP_INT:| MP_INT: MP_INT  | |\n"
"|                |                       ||        +~~~~~~~~~~~~~~~~~+ |\n"
"|                |                       ||               MP_MAP       |\n"
"+================+=======================++============================+\n"
"               MP_MAP                      MP_MAP\n"
"\n"
"SUBSCRIBE:\n"
"\n"
"Then you must send an IPROTO_SUBSCRIBE request (0x42)\n"
"\n"
"                              HEADER\n"
"+=========================+========================+\n"
"|                         |                        |\n"
"|     0x00: 0x42          |    0x01: IPROTO_SYNC   |\n"
"|   MP_INT: MP_INT        |  MP_INT: MP_INT        |\n"
"|                         |                        |\n"
"+=========================+========================+\n"
"|    IPROTO_INSTANCE_UUID |    IPROTO_CLUSTER_UUID |\n"
"|   0x24: UUID            |   0x25: UUID           |\n"
"| MP_INT: MP_STRING       | MP_INT: MP_STRING      |\n"
"|                         |                        |\n"
"+=========================+========================+\n"
"                 MP_MAP\n"
"\n"
"      BODY\n"
"+=======================+\n"
"|                       |\n"
"|   0x26: IPROTO_VCLOCK |\n"
"| MP_INT: MP_INT        |\n"
"|                       |\n"
"+=======================+\n"
"      MP_MAP\n"
"\n"
"Then you must process every request that could come through other masters.\n"
"Every request between masters will have Additional LSN and SERVER_ID."
msgstr ""

msgid "Frequently a master sends a :ref:`heartbeat <heartbeat>` message to a replica. For example, if there is a replica with id = 2, and a timestamp with a moment in 2020, a master might send this:"
msgstr ""

msgid "83                      MP_MAP, size 3\n"
"00                        Main-Map Item #1 IPROTO_REQUEST_TYPE\n"
"00                          MP_UINT = 0\n"
"02                        Main-Map Item #2 IPROTO_REPLICA_ID\n"
"02                          MP_UINT = 2 = id\n"
"04                        Main-Map Item #3 IPROTO_TIMESTAMP\n"
"cb                          MP_DOUBLE (MessagePack \"Float 64\")\n"
"41 d7 ba 06 7b 3a 03 21     8-byte timestamp"
msgstr ""

msgid "and the replica might send back this:"
msgstr ""

msgid "81                       MP_MAP, size 1\n"
"00                         Main-Map Item #1 Response-code-indicator\n"
"00                         MP_UINT = 0 = IPROTO_OK\n"
"81                         Main-Map Item #2, MP_MAP, size 1\n"
"26                           Sub-Map Item #1 IPROTO_VCLOCK\n"
"81                           Sub-Map Item #2, MP_MAP, size 1\n"
"01                             MP_UINT = 1 = id (part 1 of vclock)\n"
"06                             MP_UINT = 6 = lsn (part 2 of vclock)"
msgstr ""

msgid "XLOG / SNAP"
msgstr ""

msgid ".xlog and .snap files have nearly the same format. The header looks like:"
msgstr ""

msgid "<type>\\n                  SNAP\\n or XLOG\\n\n"
"<version>\\n               currently 0.13\\n\n"
"Server: <server_uuid>\\n   where UUID is a 36-byte string\n"
"VClock: <vclock_map>\\n    e.g. {1: 0}\\n\n"
"\\n"
msgstr ""

msgid "After the file header come the data tuples. Tuples begin with a row marker ``0xd5ba0bab`` and the last tuple may be followed by an EOF marker ``0xd510aded``. Thus, between the file header and the EOF marker, there may be data tuples that have this form:"
msgstr ""

msgid "0            3 4                                         17\n"
"+-------------+========+============+===========+=========+\n"
"|             |        |            |           |         |\n"
"| 0xd5ba0bab  | LENGTH | CRC32 PREV | CRC32 CUR | PADDING |\n"
"|             |        |            |           |         |\n"
"+-------------+========+============+===========+=========+\n"
"  MP_FIXEXT2    MP_INT     MP_INT       MP_INT      ---\n"
"\n"
"+============+ +===================================+\n"
"|            | |                                   |\n"
"|   HEADER   | |                BODY               |\n"
"|            | |                                   |\n"
"+============+ +===================================+\n"
"    MP_MAP                     MP_MAP"
msgstr ""

msgid "See the example in the :ref:`File formats <internals-data_persistence>` section."
msgstr ""

