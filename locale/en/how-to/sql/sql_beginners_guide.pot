# SOME DESCRIPTIVE TITLE.
# Copyright (C) 
# This file is distributed under the same license as the Tarantool package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Tarantool 3.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-11-17 14:22+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../doc/how-to/sql/sql_beginners_guide.rst:4
msgid "SQL beginners' guide"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:6
msgid "The Beginners' Guide describes how users can start up with SQL with Tarantool, and necessary concepts."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:8
msgid "The SQL Beginners' Guide is about databases in general, and about the relationship between Tarantool's NoSQL and SQL products. Most of the matters in the Beginners' Guide will already be familiar to people who have used relational databases before."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:15
msgid "Sample table"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:17
msgid "In football training camp it is traditional for the trainer to begin by showing a football and saying \"this is a football\". In that spirit, this is a table:"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:20
msgid "TABLE\n"
"          [1]              [2]              [3]\n"
"       +-----------------+----------------+----------------+\n"
" Row#1 | Row#1,Column#1  | Row#1,Column#2 | Row#1,Column#3 |\n"
"       +-----------------+----------------+----------------+\n"
" Row#2 | Row#2,Column#1  | Row#2,Column#2 | Row#2,Column#3 |\n"
"       +-----------------+----------------+----------------+\n"
" Row#3 | Row#3,Column#1  | Row#3,Column#2 | Row#3,Column#3 |\n"
"       +-----------------+----------------+----------------+"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:32
msgid "But the labels are misleading -- one usually doesn't identify rows and columns by their ordinal positions, one prefers to pick out specific items by their contents. In that spirit, this is a table:"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:35
#: ../../doc/how-to/sql/sql_beginners_guide.rst:698
msgid "MODULES\n"
"\n"
"+-----------------+------+---------------------+\n"
"| NAME            | SIZE | PURPOSE             |\n"
"+-----------------+------+---------------------+\n"
"| box             | 1432 | Database Management |\n"
"| clock           |  188 | Seconds             |\n"
"| crypto          |    4 | Cryptography        |\n"
"+-----------------+------+---------------------+"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:47
msgid "So one does not use longitude/latitude navigation by talking about \"Row#2 Column #2\", one uses the contents of the Name column and the name of the Size column by talking about \"the size, where the name is 'clock'\". To be more exact, this is what one says:"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:52
#: ../../doc/how-to/sql/sql_beginners_guide.rst:331
#: ../../doc/how-to/sql/sql_beginners_guide.rst:386
msgid "SELECT size FROM modules WHERE name = 'clock';"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:56
msgid "If you're familiar with Tarantool's architecture -- and ideally you read about that before coming to this chapter -- then you know that there is a NoSQL way to get the same thing:"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:60
msgid "box.space.MODULES:select()[2][2]"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:64
msgid "Well, you can do that. One of the advantages of Tarantool is that if you can get data via an SQL statement, then you can get the same data via a NoSQL request. But the reverse is not true, because not all NoSQL tuple sets are definable as SQL tables. These restrictions apply for SQL that do not apply for NoSQL: |br| 1. Every column must have a name. |br| 2. Every column should have a scalar type (Tarantool is relaxed about which particular scalar type you can have, but there is no way to index and search arrays, tables within tables, or what MessagePack calls \"maps\".)"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:73
msgid "Tarantool/NoSQL's \"format\" clause causes the same restrictions."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:75
msgid "So an SQL \"table\" is a NoSQL \"tuple set with format restrictions\", an SQL \"row\" is a NoSQL \"tuple\", an SQL \"column\" is a NoSQL \"list of fields within a tuple set\"."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:81
msgid "Creating a table"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:83
msgid "This is how to create the modules table:"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:85
msgid "CREATE TABLE modules (name STRING, size INTEGER, purpose STRING, PRIMARY KEY (name));"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:89
msgid "The words that are IN CAPITAL LETTERS are \"keywords\" (although it is only a convention in this manual that keywords are in capital letters, in practice many programmers prefer to avoid shouting). A keyword has meaning for the SQL parser so many keywords are reserved, they cannot be used as names unless they are enclosed inside quotation marks."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:94
msgid "The word \"modules\" is a \"table name\", and the words \"name\" and \"size\" and \"purpose\" are \"column names\". All tables and all columns must have names."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:97
msgid "The words \"STRING\" and \"INTEGER\" are \"data types\". STRING means \"the contents should be characters, the length is indefinite, the equivalent NoSQL type is 'string''\". INTEGER means \"the contents should be numbers without decimal points, the equivalent NoSQL type is 'integer'\". Tarantool supports other data types but this section's example table has data types from the two main groups, namely, data types for numbers and data types for strings."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:103
msgid "The final clause, PRIMARY KEY (name), means that the name column is the main column used to identify the row."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:108
msgid "Nulls"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:110
msgid "Frequently it is necessary, at least temporarily, that a column value should be NULL. Typical situations are: the value is unknown, or the value is not applicable. For example, you might make a module as a placeholder but you don't want to say its size or purpose. If such things are possible, the column is \"nullable\". The example table's name column cannot contain nulls, and it could be defined explicitly as \"name STRING NOT NULL\", but in this case that's unnecessary -- a column defined as PRIMARY KEY is automatically NOT NULL."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:117
msgid "Is a NULL in SQL the same thing as a nil in Lua? No, but it is close enough that there will be confusion. When nil means \"unknown\" or \"inapplicable\", yes. But when nil means \"nonexistent\" or \"type is nil\", no. NULL is a value, it has a data type because it is inside a column which is defined with that data type."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:126
msgid "Creating an index"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:128
msgid "This is how to create indexes for the modules table:"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:130
msgid "CREATE INDEX size ON modules (size);\n"
"CREATE UNIQUE INDEX purpose ON modules (purpose);"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:135
msgid "There is no need to create an index on the name column, because Tarantool creates an index automatically when it sees a PRIMARY KEY clause in the CREATE TABLE statement. In fact there is no need to create indexes on the size or purpose columns either -- if indexes don't exist, then it is still possible to use the columns for searches. Typically people create non-primary indexes, also called secondary indexes, when it becomes clear that the table will grow large and searches will be frequent, because searching with an index is generally much faster than searching without an index."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:143
msgid "Another use for indexes is to enforce uniqueness. When an index is created with CREATE UNIQUE INDEX for the purpose column, it is not possible to have duplicate values in that column."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:150
msgid "Data change"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:152
msgid "Putting data into a table is called \"inserting\". Changing data is called \"updating\". Removing data is called \"deleting\". Together, the three SQL statements INSERT plus UPDATE plus DELETE are the three main \"data-change\" statements."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:157
msgid "This is how to insert, update, and delete a row in the modules table:"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:159
msgid "INSERT INTO modules VALUES ('json', 14, 'format functions for JSON');\n"
"UPDATE modules SET size = 15 WHERE name = 'json';\n"
"DELETE FROM modules WHERE name = 'json';"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:165
msgid "The corresponding non-SQL Tarantool requests would be:"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:167
msgid "box.space.MODULES:insert{'json', 14, 'format functions for JSON'}\n"
"box.space.MODULES:update('json', {{'=', 2, 15}})\n"
"box.space.MODULES:delete{'json'}"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:173
msgid "This is how one would populate the table with the values that was shown earlier:"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:175
msgid "INSERT INTO modules VALUES ('box', 1432, 'Database Management');\n"
"INSERT INTO modules VALUES ('clock', 188, 'Seconds');\n"
"INSERT INTO modules VALUES ('crypto', 4, 'Cryptography');"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:184
msgid "Constraints"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:186
msgid "Some data-change statements are illegal due to something in the table's definition. This is called \"constraining what can be done\". Some types of constraints have already been shown ..."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:189
msgid "NOT NULL -- if a column is defined with a NOT NULL clause, it is illegal to put NULL into it. A primary-key column is automatically NOT NULL."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:192
msgid "UNIQUE -- if a column has a UNIQUE index, it is illegal to put a duplicate into it. A primary-key column automatically has a UNIQUE index."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:195
msgid "data domain -- if a column is defined as having data type INTEGER, it is illegal to put a non-number into it. More generally, if a value doesn't correspond to the data type of the definition, it is illegal. Some database management systems (DBMSs) are very forgiving and will try to make allowances for bad values rather than reject them; Tarantool is a bit more strict than those DBMSs."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:200
msgid "Now, here are other types of constraints ..."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:202
msgid "CHECK -- a table description can have a clause \"CHECK (conditional expression)\". For example, if the CREATE TABLE modules statement looked like this:"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:205
msgid "CREATE TABLE modules (name STRING,\n"
"                      size INTEGER,\n"
"                      purpose STRING,\n"
"                      PRIMARY KEY (name),\n"
"                      CHECK (size > 0));"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:213
msgid "then this INSERT statement would be illegal: |br| ``INSERT INTO modules VALUES ('box', 0, 'The Database Kernel');`` |br| because there is a CHECK constraint saying that the second column, the size column, cannot contain a value which is less than or equal to zero. Try this instead: |br| ``INSERT INTO modules VALUES ('box', 1, 'The Database Kernel');``"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:219
msgid "FOREIGN KEY -- a table description can have a clause \"FOREIGN KEY (column-list) REFERENCES table (column-list)\". For example, if there is a new table \"submodules\" which in a way depends on the modules table, it can be defined like this:"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:224
msgid "CREATE TABLE submodules (name STRING,\n"
"                         module_name STRING,\n"
"                         size INTEGER,\n"
"                         purpose STRING,\n"
"                         PRIMARY KEY (name),\n"
"                         FOREIGN KEY (module_name) REFERENCES\n"
"                         modules (name));"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:234
msgid "Now try to insert a new row into this submodules table:"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:236
msgid "INSERT INTO submodules VALUES\n"
"  ('space', 'Box', 10000, 'insert etc.');"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:241
msgid "The insert will fail because the second column (module_name) refers to the name column in the modules table, and the name column in the modules table does not contain 'Box'. However, it does contain 'box'. By default searches in Tarantool's SQL use a binary collation. This will work:"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:247
msgid "INSERT INTO submodules\n"
"  VALUES ('space', 'box', 10000, 'insert etc.');"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:252
msgid "Now try to delete the corresponding row from the modules table:"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:254
msgid "DELETE FROM modules WHERE name = 'box';"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:258
msgid "The delete will fail because the second column (module_name) in the submodules table refers to the name column in the modules table, and the name column in the modules table would not contain 'box' if the delete succeeded. So the FOREIGN KEY constraint affects both the table which contains the FOREIGN KEY clause and the table that the FOREIGN KEY clause refers to."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:264
msgid "The constraints in a table's definition -- NOT NULL, UNIQUE, data domain, CHECK, and FOREIGN KEY -- are guarantors of the database's integrity. It is important that they are fixed and well-defined parts of the definition, and hard to bypass with SQL. This is often seen as a difference between SQL and NoSQL -- SQL emphasizes law and order, NoSQL emphasizes freedom and making your own rules."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:274
msgid "Table relationships"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:276
msgid "Think about the two tables that have been discussed so far:"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:278
msgid "CREATE TABLE modules (name STRING,\n"
"                      size INTEGER,\n"
"                       purpose STRING,\n"
"                       PRIMARY KEY (name),\n"
"                       CHECK (size > 0));\n"
"\n"
"CREATE TABLE submodules (name STRING,\n"
"                         module_name STRING,\n"
"                         size INTEGER,\n"
"                         purpose STRING,\n"
"                         PRIMARY KEY (name),\n"
"                         FOREIGN KEY (module_name) REFERENCES\n"
"                         modules (name));"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:300
msgid "Because of the FOREIGN KEYS clause in the submodules table, there is clearly a many-to-one relationship: |br| submodules -->> modules |br| that is, every submodules row must refer to one (and only one) modules row, while every modules row can be referred to in zero or more submodules rows."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:305
msgid "Table relationships are important, but beware: do not trust anyone who tells you that databases made with SQL are relational \"because there are relationships between tables\". That is wrong, as will be clear in the discussion about what makes a database relational, later."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:313
msgid "Selecting with WHERE"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:317
msgid "By default, Tarantool prohibits ``SELECT`` queries that scan table rows instead of using indexes to avoid unwanted heavy load. For the purposes of this tutorial, allow SQL scan queries in Tarantool by running the command:"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:321
msgid "SET SESSION \"sql_seq_scan\" = true;"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:325
msgid "Alternatively, you can allow a specific query to perform a table scan by adding the ``SEQSCAN`` keyword before the table name. Learn more about using ``SEQSCAN`` in SQL scan queries in the :ref:`SQL FROM clause description <sql_from>`."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:329
msgid "We gave a simple example of a SELECT statement earlier:"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:335
msgid "The clause \"WHERE name = 'clock'\" is legal in other statements -- it is in examples with UPDATE and DELETE -- but here the only examples will be with SELECT."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:338
msgid "The first variation is that the WHERE clause does not have to be specified at all, it is optional. So this statement would return all rows:"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:341
msgid "SELECT size FROM modules;"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:345
msgid "The second variation is that the comparison operator does not have to be '=', it can be anything that makes sense: '>' or '>=' or '<' or '<=', or 'LIKE' which is an operator that works with strings that may contain wildcard characters '_' meaning 'match any one character' or '%' meaning 'match any zero or one or many characters'. These are legal statements which return all rows:"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:352
msgid "SELECT size FROM modules WHERE name >= '';\n"
"SELECT size FROM modules WHERE name LIKE '%';"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:357
msgid "The third variation is that IS [NOT] NULL is a special condition. Remembering that the NULL value can mean \"it is unknown what the value should be\", and supposing that in some row the size is NULL, then the condition \"size > 10\" is not certainly true and it is not certainly false, so it is evaluated as \"unknown\". Ordinarily the application of a WHERE clause filters out both false and unknown results. So when searching for NULL, say IS NULL; when searching anything that is not NULL, say IS NOT NULL. This statement will return all rows because (due to the definition) there are no NULLs in the name column:"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:367
msgid "SELECT size FROM modules WHERE name IS NOT NULL;"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:371
msgid "The fourth variation is that conditions can be combined with AND / OR, and negated with NOT."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:373
msgid "So this statement would return all rows (the first condition is false but the second condition is true, and OR means \"return true if either condition is true\"):"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:376
msgid "SELECT size\n"
"FROM modules\n"
"WHERE name = 'wombat' OR size IS NOT NULL;"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:382
msgid "**Selecting with a select list**"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:384
msgid "Yet again, here is a simple example of a SELECT statement:"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:390
msgid "The words between SELECT and FROM are the select list. In this case, the select list is just one word: size. Formally it means that the desire is to return the size values, and technically the name for picking a particular column is called \"projection\"."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:395
msgid "The first variation is that one can specify any column in any order:"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:397
msgid "SELECT name, purpose, size FROM modules;"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:401
msgid "The second variation is that one can specify an expression, it does not have to be a column name, it does not even have to include a column name. The common expression operators for numbers are the arithmetic operators ``+ - / *``; the common expression operator for strings is the concatenation operator ||. For example this statement will return 8, 'XY':"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:407
msgid "SELECT size * 2, 'X' || 'Y' FROM modules WHERE size = 4;"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:411
msgid "The third variation is that one can add a clause [AS name] after every expression, so that in the return the column titles will make sense. This is especially important when a title might otherwise be ambiguous or meaningless. For example this statement will return 8, 'XY' as before"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:416
msgid "SELECT size * 2 AS double_size, 'X' || 'Y' AS concatenated_literals  FROM modules\n"
"  WHERE size = 4;"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:421
msgid "but displayed as a table the result will look like"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:423
msgid "+----------------+------------------------+\n"
"| DOUBLE_SIZE    | CONCATENATED_LITERALS  |\n"
"+----------------+------------------------+\n"
"|              8 | XY                     |\n"
"+----------------+------------------------+"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:431
msgid "**Selecting with a select list with asterisk**"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:433
msgid "Instead of listing columns in a select list, one can just say ``'*'``. For example"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:435
msgid "SELECT * FROM modules;"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:439
msgid "This is the same thing as"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:441
msgid "SELECT name, size, purpose FROM modules;"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:445
msgid "Selecting with ``\"*\"``  saves time for the writer, but it is unclear to a reader who has not memorized what the column names are. Also it is unstable, because there is a way to change a table's definition (the ALTER statement, which is an advanced topic). Nevertheless, although it might be bad to use it for production, it is handy to use it for introduction, so ``\"*\"`` will appear in some following examples."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:455
msgid "Select with subqueries"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:457
msgid "Remember that there is a modules table and there is a submodules table. Suppose that there is a desire to list the submodules that refer to modules for which the purpose is X. That is, this involves a search of one table using a value in another table. This can be done by enclosing \"(SELECT ...)\" within the WHERE clause. For example:"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:462
msgid "SELECT name FROM submodules\n"
"WHERE module_name =\n"
"    (SELECT name FROM modules WHERE purpose LIKE '%Database%');"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:468
msgid "Subqueries are also useful in the select list, when one wishes to combine information from more than one table. For example this statement will display submodules rows but will include values that come from the modules table:"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:472
msgid "SELECT name AS submodules_name,\n"
"    (SELECT purpose FROM modules\n"
"     WHERE modules.name = submodules.module_name)\n"
"     AS modules_purpose,\n"
"    purpose AS submodules_purpose\n"
"FROM submodules;"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:481
msgid "Whoa. What are \"modules.name\" and \"submodules.name\"? Whenever you see \"x . y\" you are looking at a \"qualified column name\", and the first part is a table identifier, the second part is a column identifier. It is always legal to use qualified column names, but until now it has not been necessary. Now it is necessary, or at least it is a good idea, because both tables have a column named \"name\"."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:487
#: ../../doc/how-to/sql/sql_beginners_guide.rst:720
#: ../../doc/how-to/sql/sql_beginners_guide.rst:741
msgid "The result will look like this:"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:489
msgid "+-------------------+------------------------+--------------------+\n"
"| SUBMODULES_NAME   | MODULES_PURPOSE        | SUBMODULES_PURPOSE |\n"
"+-------------------+------------------------+--------------------+\n"
"| space             | Database Management    | insert etc.        |\n"
"+-------------------+------------------------+--------------------+"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:497
msgid "Perhaps you have read somewhere that SQL stands for \"Structured Query Language\". That is not true any more. But it is true that the query syntax allows for a structural component, namely the subquery, and that was the original idea. However, there is a different way to combine tables -- with joins instead of subqueries."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:506
msgid "Select with Cartesian join"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:508
msgid "Until now only \"FROM modules\" or \"FROM submodules\" was used in SELECT statements. What if there was more than one table in the FROM clause? For example"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:511
msgid "SELECT * FROM modules, submodules;"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:515
msgid "or"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:517
msgid "SELECT * FROM modules JOIN submodules;"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:521
msgid "That is legal. Usually it is not what you want, but it is a learning aid. The result will be:"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:523
msgid "{ columns from modules table }         { columns from submodules table }\n"
"+--------+------+---------------------+-------+-------------+-------+-------------+\n"
"| NAME   | SIZE | PURPOSE             | NAME  | MODULE_NAME | SIZE  | PURPOSE     |\n"
"+--------+------+---------------------+-------+-------------+-------+-------------+\n"
"| box    | 1432 | Database Management | space | box         | 10000 | insert etc. |\n"
"| clock  |  188 | Seconds             | space | box         | 10000 | insert etc. |\n"
"| crypto |    4 | Cryptography        | space | box         | 10000 | insert etc. |\n"
"+--------+------+---------------------+-------+-------------+-------+-------------+"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:534
msgid "It is not an error. The meaning of this type of join is \"combine every row in table-1 with every row in table-2\". It did not specify what the relationship should be, so the result has everything, even when the submodule has nothing to do with the module."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:538
msgid "It is handy to look at the above result, called a \"Cartesian join\" result, to see what would really be desirable. Probably for this case the row that actually makes sense is the one where the modules.name = submodules.module_name, and it's better to make that clear in both the select list and the WHERE clause, thus:"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:542
msgid "SELECT modules.name AS modules_name,\n"
"       modules.size AS modules_size,\n"
"       modules.purpose AS modules_purpose,\n"
"       submodules.name,\n"
"       module_name,\n"
"       submodules.size,\n"
"       submodules.purpose\n"
"FROM modules, submodules\n"
"WHERE modules.name = submodules.module_name;"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:554
msgid "The result will be:"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:556
msgid "+----------+-----------+------------+--------+---------+-------+-------------+\n"
"| MODULES_ |  MODULES_ | MODULES_   | NAME   | MODULE_ | SIZE  | PURPOSE     |\n"
"| NAME     |  SIZE     | PURPOSE    |        | NAME    |       |             |\n"
"+----------+-----------+--------- --+--------+---------+-------+-------------+\n"
"| box      |      1432 | Database   | space  | box     | 10000 | insert etc. |\n"
"|          |           | Management |        |         |       |             |\n"
"+----------+-----------+------------+--------+---------+-------+-------------+"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:566
msgid "In other words, you can specify a Cartesian join in the FROM clause, then you can filter out the irrelevant rows in the WHERE clause, and then you can rename columns in the select list. This is fine, and every SQL DBMS supports this. But it is worrisome that the number of rows in a Cartesian join is always (number of rows in first table multiplied by number of rows in second table), which means that conceptually you are often filtering in a large set of rows."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:574
msgid "It is good to start by looking at Cartesian joins because they show the concept. Many people, though, prefer to use different syntaxes for joins because they look better or clearer. So now those alternatives will be shown."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:581
msgid "Select with join with ON clause"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:583
msgid "The ON clause would have the same comparisons as the WHERE clause that was illustrated for the previous section, but the use of different syntax would be making it clear \"this is for the sake of the join\". Readers can see at a glance that it is, in concept at least, an initial step before the result rows are filtered. For example this"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:589
msgid "SELECT * FROM modules JOIN submodules\n"
"  ON (modules.name = submodules.module_name);"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:594
msgid "is the same as"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:596
msgid "SELECT * FROM modules, submodules\n"
"  WHERE modules.name = submodules.module_name;"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:604
msgid "Select with join with USING clause"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:606
msgid "The USING clause would take advantage of names that are held in common between the two tables, with the assumption that the intent is to match those columns with '=' comparisons. For example,"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:609
msgid "SELECT * FROM modules JOIN submodules USING (name);"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:613
msgid "has the same effect as"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:615
msgid "SELECT * FROM modules JOIN submodules WHERE modules.name = submodules.name;"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:619
msgid "If the table had been created with a plan in advance to use USING clauses, that would save time. But that did not happen. So, although the above example \"works\", the results will not be sensible."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:626
msgid "Select with natural join"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:628
msgid "A natural join would take advantage of names that are held in common between the two tables, and would do the filtering automatically based on that knowledge, and throw away duplicate columns."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:631
msgid "If the table had been created with a plan in advance to use natural joins, that would be very handy. But that did not happen. So, although the following example \"works\", the results won't be sensible."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:634
msgid "SELECT * FROM modules NATURAL JOIN submodules;"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:638
msgid "Result: nothing, because modules.name does not match submodules.name, and so on And even if there had been a result, it would only have included four columns: name, module_name, size, purpose."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:645
msgid "Select with left join"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:647
msgid "Now what if there is a desire to join modules to submodules, but it's necessary to be sure that all the modules are found? In other words, suppose the requirement is to get modules even if the condition submodules.module_name = modules.name is not true, because the module has no submodules."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:652
msgid "When that is the requirement, the type of join is an \"outer join\" (as opposed to the type that has been used so far which is an \"inner join\"). Specifically the format will be LEFT [OUTER] JOIN because the main table, modules, is on the left. For example:"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:656
msgid "SELECT *\n"
"FROM modules LEFT JOIN submodules\n"
"ON modules.name = submodules.module_name;"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:662
msgid "which returns:"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:664
msgid "{ columns from modules table }         { columns from submodules table }\n"
"+--------+------+---------------------+-------+-------------+-------+-------------+\n"
"| NAME   | SIZE | PURPOSE             | NAME  | MODULE_NAME | SIZE  | PURPOSE     |\n"
"+--------+------+---------------------+-------+-------------+-------+-------------+\n"
"| box    | 1432 | Database Management | space | box         | 10000 | insert etc. |\n"
"| clock  |  188 | Seconds             | NULL  | NULL        | NULL  | NULL        |\n"
"| crypto |    4 | Cryptography        | NULL  | NULL        | NULL  | NULL        |\n"
"+--------+------+---------------------+-------+-------------+-------+-------------+"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:675
msgid "Thus, for the submodules of the clock module and the submodules of the crypto module -- which do not exist -- there are NULLs in every column."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:681
msgid "Select with functions"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:683
msgid "A function can take any expression, including an expression that contains another function, and return a scalar value. There are many such functions. Here will be a description of only one, SUBSTR, which returns a substring of a string."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:687
msgid "Format: :samp:`SUBSTR({input-string}, {start-with} [, {length}])`"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:689
msgid "Description: SUBSTR takes input-string, eliminates any characters before start-with, eliminates any characters after (start-with plus length), and returns the result."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:692
msgid "Example: ``SUBSTR('abcdef', 2, 3)`` returns 'bcd'."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:694
msgid "Select with aggregation, GROUP BY, and HAVING"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:696
msgid "Remember that the modules table looks like this:"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:711
msgid "Suppose that there is no need to know all the individual size values, all that is important is their aggregation, that is, take the attributes of the collection. SQL allows aggregation functions including: AVG (average), SUM, MIN (minimum), MAX (maximum), and COUNT. For example"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:716
msgid "SELECT AVG(size), SUM(size), MIN(size), MAX(size), COUNT(size) FROM modules;"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:722
msgid "+-----------+-----------+-----------+-----------+-----------+\n"
"| COLUMN_1  | COLUMN_2  | COLUMN_3  | COLUMN_4  | COLUMN_5  |\n"
"+-----------+-----------+-----------+-----------+-----------|\n"
"|       541 |      1624 |         4 |      1432 |         3 |\n"
"+-----------+-----------+-----------+-----------+-----------+"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:730
msgid "Suppose that the requirement is aggregations, but aggregations of rows that have some common characteristic. Supposing further, the rows should be divided into two groups, the ones whose names begin with 'b' and the ones whose names begin with 'c'. This can be done by adding a clause [GROUP BY expression]. For example,"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:735
msgid "SELECT SUBSTR(name, 1, 1), AVG(size), SUM(size), MIN(size), MAX(size), COUNT(size)\n"
"FROM modules\n"
"GROUP BY SUBSTR(name, 1, 1);"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:743
msgid "+------------+--------------+-----------+-----------+-----------+-------------+\n"
"| COLUMN_1   | COLUMN_2     | COLUMN_3  | COLUMN_4  | COLUMN_5  | COLUMN_6    |\n"
"+------------+--------------+-----------+-----------+-----------+-------------+\n"
"| b          |         1432 |      1432 |      1432 |      1432 |           1 |\n"
"| c          |           96 |       192 |         4 |       188 |           2 |\n"
"+------------+--------------+-----------+-----------+-----------+-------------+"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:756
msgid "Select with common table expression"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:758
msgid "It is possible to define a temporary (viewed) table within a statement, usually within a SELECT statement, using a WITH clause. For example:"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:761
msgid "WITH tmp_table AS (SELECT x1 FROM t1) SELECT * FROM tmp_table;"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:768
msgid "Select with order, limit, and offset clauses"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:770
msgid "So far, tor every search in the modules table, the rows have come out in alphabetical order by name: 'box', then 'clock', then 'crypto'. However, to really be sure about the order, or to ask for a different order, it is necessary to be explicit and add a clause: ``ORDER BY column-name [ASC|DESC]``. (ASC stands for ASCending, DESC stands for DESCending.) For example:"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:778
msgid "SELECT * FROM modules ORDER BY name DESC;"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:782
msgid "The result will be the usual rows, in descending alphabetical order: 'crypto' then 'clock' then 'box'."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:784
msgid "After the ORDER BY clause there can be a clause LIMIT n, where n is the maximum number of rows to retrieve. For example:"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:786
msgid "SELECT * FROM modules ORDER BY name DESC LIMIT 2;"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:790
msgid "The result will be the first two rows, 'crypto' and 'clock'."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:792
msgid "After the ORDER BY clause and the LIMIT clause there can be a clause OFFSET n, where n is the row to start with. The first offset is 0. For example:"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:795
msgid "SELECT * FROM modules ORDER BY name DESC LIMIT 2 OFFSET 2;"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:799
msgid "The result will be the third row, 'box'."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:804
msgid "Views"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:806
msgid "A view is a canned SELECT. If you have a complex SELECT that you want to run frequently, create a view and then do a simple SELECT on the view. For example:"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:808
msgid "CREATE VIEW v AS SELECT size, (size *5) AS size_times_5\n"
"FROM modules\n"
"GROUP BY size, name\n"
"ORDER BY size_times_5;\n"
"SELECT * FROM v;"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:819
msgid "Transactions"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:821
msgid "Tarantool has a \"Write Ahead Log\" (WAL). Effects of data-change statements are logged before they are permanently stored on disk. This is a reason that, although entire databases can be stored in temporary memory, they are not vulnerable in case of power failure."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:826
msgid "Tarantool supports commits and rollbacks. In effect, asking for a commit means asking for all the recent data-change statements, since a transaction began, to become permanent. In effect, asking for a rollback means asking for all the recent data-change statements, since a transaction began, to be cancelled."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:832
msgid "For example, consider these statements:"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:834
msgid "CREATE TABLE things (remark STRING, PRIMARY KEY (remark));\n"
"START TRANSACTION;\n"
"INSERT INTO things VALUES ('A');\n"
"COMMIT;\n"
"START TRANSACTION;\n"
"INSERT INTO things VALUES ('B');\n"
"ROLLBACK;\n"
"SELECT * FROM things;"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:845
msgid "The result will be: one row, containing 'A'. The ROLLBACK cancelled the second INSERT statement, but did not cancel the first one, because it had already been committed."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:848
msgid "Ordinarily every statement is automatically committed."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:850
msgid "After START TRANSACTION, statements are not automatically committed -- Tarantool considers that a transaction is now \"active\", until the transaction ends with a COMMIT statement or a ROLLBACK statement. While a transaction is active, all statements are legal except another START TRANSACTION."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:857
msgid "Implementing Tarantool's SQL On Top of NoSQL"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:859
msgid "Tarantool's SQL data is the same as Tarantool's NoSQL data. When you create a table or an index with SQL, you are creating a space or an index in NoSQL. For example:"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:862
msgid "CREATE TABLE things (remark STRING, PRIMARY KEY (remark));\n"
"INSERT INTO things VALUES ('X');"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:867
msgid "is somewhat similar to"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:869
msgid "box.schema.space.create('THINGS',\n"
"{\n"
"    format = {\n"
"              [1] = {[\"name\"] = \"REMARK\", [\"type\"] = \"string\"}\n"
"              }\n"
"})\n"
"box.space.THINGS:create_index('pk_unnamed_THINGS_1',{unique=true,parts={1,'string'}})\n"
"box.space.THINGS:insert{'X'}"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:880
msgid "Therefore you can take advantage of Tarantool's NoSQL features even though your primary language is SQL. Here are some possibilities."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:883
msgid "(1) NoSQL applications written in one of the connector languages may be slightly faster than SQL applications because SQL statements may require more parsing and may be translated to NoSQL requests."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:886
msgid "(2) You can write stored procedures in Lua, combining Lua loop-control and Lua library-access statements with SQL statements. These routines are executed on the server, which is the principal advantage of pure-SQL stored procedures."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:889
msgid "(3) There are some options that are implemented in NoSQL that are not (yet) implemented in SQL. For example you can use NoSQL to change an index option, and to deny access to users named 'guest'."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:892
msgid "(4) System spaces such as _space and _index can be accessed with SQL SELECT statements. This is not quite the same as an information_schema, but it does mean that you can use SQL to access the database's metadata catalog."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:896
msgid "Fields in NoSQL spaces can be accessed with SQL if and only if they are scalar and are defined in format clauses. Indexes of NoSQL spaces will be used with SQL if and only if they are TREE indexes."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:902
msgid "Relational databases"
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:904
msgid "Edgar F. Codd, the person most responsible for researching and explaining relational database concepts, listed the main criteria as (`Codd's 12 rules <https://en.wikipedia.org/wiki/Codd's_12_rules>`_)."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:908
msgid "Although Tarantool is not advertised as \"relational\", Tarantool comes with a claim that it complies with these rules, with the following caveats and exceptions ..."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:911
msgid "The rules state that all data must be viewable as relations. A Tarantool SQL table is a relation. However, it is possible to have duplicate values in SQL tables and it is possible to have an implicit ordering. Those characteristics are not allowed for true relations."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:916
msgid "The rules state that there must be a dynamic online catalog. Tarantool has one but some metadata is missing from it."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:918
msgid "The rules state that the data language must support authorization. Tarantool's SQL does not. Authorization occurs via NoSQL requests."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:921
msgid "The rules require that data must be physically independent (from underlying storage changes) and logically independent (from application program changes). So far there is not enough experience to make this guarantee."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:925
msgid "The rules require certain types of updatable views. Tarantool's views are not updatable."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:927
msgid "The rules state that it should be impossible to use a low-level language to bypass integrity as defined in the relational-level language. In Tarantool's case, this is not true, for example one can execute a request with Tarantool's NoSQL to violate a foreign-key constraint that was defined with Tarantool's SQL."
msgstr ""

#: ../../doc/how-to/sql/sql_beginners_guide.rst:932
msgid "To learn more about SQL in Tarantool, check the :ref:`reference <reference_sql>`."
msgstr ""
