# SOME DESCRIPTIVE TITLE.
# Copyright (C) 
# This file is distributed under the same license as the Tarantool package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Tarantool 3.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-11-17 14:22+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../doc/reference/reference_lua/net_box.rst:5
msgid "Module net.box"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:9
msgid "Overview"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:11
msgid "The ``net.box`` module contains connectors to remote database systems. One variant, to be discussed later, is for connecting to MySQL or MariaDB or PostgreSQL (see :ref:`SQL DBMS modules <dbms_modules>` reference). The other variant, which is discussed in this section, is for connecting to Tarantool server instances via a network. For a quick start with ``net.box``, refer to the :ref:`tutorial <getting_started_net_box>`."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:18
msgid "You can call the following methods:"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:20
msgid "``require('net.box')`` -- to get a ``net.box`` object (named ``net_box`` for examples in this section)"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:22
msgid "``net_box.connect()`` -- to connect and get a connection object (named ``conn`` for examples in this section)"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:24
msgid "other ``net.box()`` routines, passing ``conn:``, to execute requests on the remote database system"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:26
msgid "``conn:close`` -- to disconnect"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:28
msgid "All ``net.box`` methods are fiber-safe, that is, it is safe to share and use the same connection object across multiple concurrent fibers. In fact that is perhaps the best programming practice with Tarantool. When multiple fibers use the same connection, all requests are pipelined through the same network socket, but each fiber gets back a correct response. Reducing the number of active sockets lowers the overhead of system calls and increases the overall server performance. However for some cases a single connection is not enough -- for example, when it is necessary to prioritize requests or to use different authentication IDs."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:39
msgid "Most ``net.box`` methods accept the last ``{options}`` argument, which can be:"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:41
msgid "``{timeout=...}``. For example, a method whose last argument is ``{timeout=1.5}`` will stop after 1.5 seconds on the local node, although this does not guarantee that execution will stop on the remote server node."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:45
msgid "``{buffer=...}``. For an example, see the :ref:`buffer module <buffer-module>`."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:47
msgid "``{is_async=...}``. For example, a method whose last argument is ``{is_async=true}`` will not wait for the result of a request. See the :ref:`is_async <net_box-is_async>` description."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:51
msgid "``{on_push=... on_push_ctx=...}``. For receiving out-of-band messages. See the :doc:`/reference/reference_lua/box_session/push` description."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:54
msgid "``{return_raw=...}`` (since version 2.10.0). If set to ``true``, net.box returns response data wrapped in a :ref:`MsgPack object <msgpack-object-info>` instead of decoding it to Lua. The default value is ``false``. For an example, see option description :ref:`below <net_box-return_raw>`."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:62
msgid "The diagram below shows possible connection states and transitions:"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:None
msgid "net_states.png"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:70
msgid "On this diagram:"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:72
msgid "``net_box.connect()`` method spawns a worker fiber, which will establish the connection and start the state machine."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:74
msgid "The state machine goes to the ``initial`` state."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:76
msgid "Authentication and schema upload. It is possible later on to re-enter the ``fetch_schema`` state from ``active`` to trigger schema reload."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:79
msgid "The state changes to the ``graceful_shutdown`` state when the state machine receives a :ref:`box.shutdown <system-events_box-shutdown>` event from the remote host (see :ref:`conn:on_shutdown() <net_box-on_shutdown>`). Once all pending requests are completed, the state machine switches to the ``error`` (``error_reconnect``) state."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:84
msgid "The transport goes to the ``error`` state in case of an error. It can happen, for example, if the server closed the connection. If the ``reconnect_after`` option is set, instead of the ‘error’ state, the transport goes to the ``error_reconnect`` state."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:89
msgid "``conn.close()`` method sets the state to ``closed`` and kills the worker. If the transport is already in the ``error`` state, ``close()`` does nothing."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:94
msgid "Index"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:96
msgid "Below is a list of all ``net.box`` functions."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:104
msgid "Name"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:105
#: ../../doc/reference/reference_lua/net_box.rst:231
msgid "Use"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:106
msgid ":ref:`net_box.connect() <net_box-connect>` |br| :ref:`net_box.new() <net_box-new>` |br| :ref:`net_box.self <net_box-self>`"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:107
msgid "Create a connection"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:108
msgid ":ref:`conn:ping() <conn-ping>`"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:109
msgid "Execute a PING command"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:110
msgid ":ref:`conn:wait_connected() <conn-wait_connected>`"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:111
msgid "Wait for a connection to be active or closed"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:112
msgid ":ref:`conn:is_connected() <conn-is_connected>`"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:113
msgid "Check if a connection is active or closed"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:114
msgid ":ref:`conn:wait_state() <conn-wait_state>`"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:115
msgid "Wait for a target state"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:116
msgid ":ref:`conn:close() <conn-close>`"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:117
msgid "Close a connection"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:118
msgid ":ref:`conn.space.space-name:select{field-value} <conn-select>`"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:119
msgid "Select one or more tuples"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:120
msgid ":ref:`conn.space.space-name:get{field-value} <conn-get>`"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:121
msgid "Select a tuple"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:122
msgid ":ref:`conn.space.space-name:insert{field-value} <conn-insert>`"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:123
msgid "Insert a tuple"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:124
msgid ":ref:`conn.space.space-name:replace{field-value} <conn-replace>`"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:125
msgid "Insert or replace a tuple"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:126
msgid ":ref:`conn.space.space-name:update{field-value} <conn-update>`"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:127
#: ../../doc/reference/reference_lua/net_box.rst:129
msgid "Update a tuple"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:128
msgid ":ref:`conn.space.space-name:upsert{field-value} <conn-upsert>`"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:130
msgid ":ref:`conn.space.space-name:delete{field-value} <conn-delete>`"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:131
msgid "Delete a tuple"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:132
msgid ":ref:`conn:eval() <net_box-eval>`"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:133
msgid "Evaluate the expression in a string and execute it"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:134
msgid ":ref:`conn:call() <net_box-call>`"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:135
msgid "Call a stored procedure"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:136
msgid ":ref:`conn:watch() <conn-watch>`"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:137
msgid "Subscribe to events broadcast by a remote host"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:138
msgid ":ref:`conn:on_connect() <net_box-on_connect>`"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:139
msgid "Define a connect trigger"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:140
msgid ":ref:`conn:on_disconnect() <net_box-on_disconnect>`"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:141
msgid "Define a disconnect trigger"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:142
msgid ":ref:`conn:on_shutdown() <net_box-on_shutdown>`"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:143
msgid "Define a shutdown trigger"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:144
msgid ":ref:`conn:on_schema_reload() <net_box-on_schema_reload>`"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:145
msgid "Define a trigger when schema is modified"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:146
msgid ":ref:`conn:new_stream() <conn-new_stream>`"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:147
msgid "Create a stream"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:148
msgid ":ref:`stream:begin() <net_box-stream_begin>`"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:149
msgid "Begin a stream transaction"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:150
msgid ":ref:`stream:commit() <net_box-stream_commit>`"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:151
msgid "Commit a stream transaction"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:152
msgid ":ref:`stream:rollback() <net_box-stream_rollback>`"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:153
msgid "Rollback a stream transaction"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:161
msgid "Create a new connection. The connection is established on demand, at the time of the first request. It can be re-established automatically after a disconnect (see ``reconnect_after`` option below). The returned ``conn`` object supports methods for making remote requests, such as select, update or delete."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:0
#: ../../doc/reference/reference_lua/net_box.rst:0
#: ../../doc/reference/reference_lua/net_box.rst:0
#: ../../doc/reference/reference_lua/net_box.rst:0
#: ../../doc/reference/reference_lua/net_box.rst:0
#: ../../doc/reference/reference_lua/net_box.rst:0
#: ../../doc/reference/reference_lua/net_box.rst:0
#: ../../doc/reference/reference_lua/net_box.rst:0
#: ../../doc/reference/reference_lua/net_box.rst:0
#: ../../doc/reference/reference_lua/net_box.rst:0
msgid "Parameters"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:167
msgid "the :ref:`URI <index-uri>` of the target for the connection"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:168
msgid "the supported options are shown below:  *   ``user/password``: two options to connect to a remote host other than through     :ref:`URI <index-uri>`. For example, instead of ``connect('username:userpassword@localhost:3301')``     you can write ``connect('localhost:3301', {user = 'username', password='userpassword'})``.  *   ``wait_connected``: a connection timeout. By default, the connection is blocked until the connection     is established, but if you specify ``wait_connected=false``, the connection returns immediately.     If you specify this timeout, it will wait before returning (``wait_connected=1.5`` makes it wait at most 1.5 seconds).      .. NOTE::           If ``reconnect_after`` is greater than zero, then ``wait_connected`` ignores transient failures.          The wait completes once the connection is established or is closed explicitly.   *   ``reconnect_after``: a number of seconds to wait before reconnecting.     The default value, as with the other ``connect`` options, is ``nil``. If ``reconnect_after``     is greater than zero, then a ``net.box`` instance will attempt to reconnect if a connection     is lost or a connection attempt fails. This makes transient network failures transparent to the application.     Reconnection happens automatically in the background, so requests that initially fail due to connection drops     fail, are transparently retried. The number of retries is unlimited, connection retries are made after     any specified interval (for example, ``reconnect_after=5`` means that reconnect attempts are made every 5 seconds).     When a connection is explicitly closed or when the Lua garbage collector removes it, then reconnect attempts stop.   *   ``call_16``: [since 1.7.2] a new binary protocol command for CALL in ``net.box`` connections by default.     The new CALL is not backward compatible with previous versions. It no longer restricts a function to     returning an array of tuples and allows returning an arbitrary MsgPack/JSON result,     including scalars, nil and void (nothing). The old CALL is left intact for backward compatibility.     It will not be present in the next major release. All programming language drivers will gradually be switched     to the new CALL. To connect to a Tarantool instance that uses the old CALL, specify ``call_16=true``.  *   ``connect_timeout``: a number of seconds to wait before returning \"error: Connection timed out\".  *   ``fetch_schema``: a boolean option that controls fetching schema changes from the server. Default: ``true``.     If you don't operate with remote spaces, for example, run only ``call`` or ``eval``, set ``fetch_schema`` to     ``false`` to avoid fetching schema changes which is not needed in this case.      .. important::          In connections with ``fetch_schema == false``, remote spaces are unavailable         and the :ref:`on_schema_reload <net_box-on_schema_reload>` triggers don't work.  *   ``required_protocol_version``: a minimum version of the :ref:`IPROTO protocol <box_protocol-id>`     supported by the server. If the version of the :ref:`IPROTO protocol <box_protocol-id>` supported     by the server is lower than specified, the connection will fail with an error message.     With ``required_protocol_version = 1``, all connections fail where the :ref:`IPROTO protocol <box_protocol-id>`     version is lower than ``1``.  *   ``required_protocol_features``: specified :ref:`IPROTO protocol features <box_protocol-id>` supported by the server.     You can specify one or more ``net.box`` features from the table below. If the server does not     support the specified features, the connection will fail with an error message.     With ``required_protocol_features = {'transactions'}``, all connections fail where the     server has ``transactions: false``."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:168
msgid "the supported options are shown below:"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:170
msgid "``user/password``: two options to connect to a remote host other than through :ref:`URI <index-uri>`. For example, instead of ``connect('username:userpassword@localhost:3301')`` you can write ``connect('localhost:3301', {user = 'username', password='userpassword'})``."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:174
msgid "``wait_connected``: a connection timeout. By default, the connection is blocked until the connection is established, but if you specify ``wait_connected=false``, the connection returns immediately. If you specify this timeout, it will wait before returning (``wait_connected=1.5`` makes it wait at most 1.5 seconds)."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:180
msgid "If ``reconnect_after`` is greater than zero, then ``wait_connected`` ignores transient failures. The wait completes once the connection is established or is closed explicitly."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:184
msgid "``reconnect_after``: a number of seconds to wait before reconnecting. The default value, as with the other ``connect`` options, is ``nil``. If ``reconnect_after`` is greater than zero, then a ``net.box`` instance will attempt to reconnect if a connection is lost or a connection attempt fails. This makes transient network failures transparent to the application. Reconnection happens automatically in the background, so requests that initially fail due to connection drops fail, are transparently retried. The number of retries is unlimited, connection retries are made after any specified interval (for example, ``reconnect_after=5`` means that reconnect attempts are made every 5 seconds). When a connection is explicitly closed or when the Lua garbage collector removes it, then reconnect attempts stop."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:194
msgid "``call_16``: [since 1.7.2] a new binary protocol command for CALL in ``net.box`` connections by default. The new CALL is not backward compatible with previous versions. It no longer restricts a function to returning an array of tuples and allows returning an arbitrary MsgPack/JSON result, including scalars, nil and void (nothing). The old CALL is left intact for backward compatibility. It will not be present in the next major release. All programming language drivers will gradually be switched to the new CALL. To connect to a Tarantool instance that uses the old CALL, specify ``call_16=true``."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:201
msgid "``connect_timeout``: a number of seconds to wait before returning \"error: Connection timed out\"."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:203
msgid "``fetch_schema``: a boolean option that controls fetching schema changes from the server. Default: ``true``. If you don't operate with remote spaces, for example, run only ``call`` or ``eval``, set ``fetch_schema`` to ``false`` to avoid fetching schema changes which is not needed in this case."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:209
msgid "In connections with ``fetch_schema == false``, remote spaces are unavailable and the :ref:`on_schema_reload <net_box-on_schema_reload>` triggers don't work."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:212
msgid "``required_protocol_version``: a minimum version of the :ref:`IPROTO protocol <box_protocol-id>` supported by the server. If the version of the :ref:`IPROTO protocol <box_protocol-id>` supported by the server is lower than specified, the connection will fail with an error message. With ``required_protocol_version = 1``, all connections fail where the :ref:`IPROTO protocol <box_protocol-id>` version is lower than ``1``."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:218
msgid "``required_protocol_features``: specified :ref:`IPROTO protocol features <box_protocol-id>` supported by the server. You can specify one or more ``net.box`` features from the table below. If the server does not support the specified features, the connection will fail with an error message. With ``required_protocol_features = {'transactions'}``, all connections fail where the server has ``transactions: false``."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:230
msgid "net.box feature"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:232
msgid "IPROTO feature ID"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:233
msgid "IPROTO versions supporting the feature"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:234
msgid "``streams``"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:235
msgid "Requires streams support on the server"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:236
msgid "IPROTO_FEATURE_STREAMS"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:237
#: ../../doc/reference/reference_lua/net_box.rst:241
msgid "1 and newer"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:238
msgid "``transactions``"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:239
msgid "Requires transactions support on the server"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:240
msgid "IPROTO_FEATURE_TRANSACTIONS"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:242
msgid "``error_extension``"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:243
msgid "Requires support for :ref:`MP_ERROR <msgpack_ext-error>` MsgPack extension on the server"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:244
msgid "IPROTO_FEATURE_ERROR_EXTENSION"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:245
msgid "2 and newer"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:246
msgid "``watchers``"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:247
msgid "Requires remote :ref:`watchers <conn-watch>` support on the server"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:248
msgid "IPROTO_FEATURE_WATCHERS"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:249
msgid "3 and newer"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:251
msgid "To learn more about IPROTO features, see :ref:`IPROTO_ID <box_protocol-id>` and the :ref:`IPROTO_FEATURES <internals-iproto-keys-features>` key."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:0
#: ../../doc/reference/reference_lua/net_box.rst:0
#: ../../doc/reference/reference_lua/net_box.rst:0
#: ../../doc/reference/reference_lua/net_box.rst:0
#: ../../doc/reference/reference_lua/net_box.rst:0
#: ../../doc/reference/reference_lua/net_box.rst:0
#: ../../doc/reference/reference_lua/net_box.rst:0
#: ../../doc/reference/reference_lua/net_box.rst:0
#: ../../doc/reference/reference_lua/net_box.rst:0
#: ../../doc/reference/reference_lua/net_box.rst:0
msgid "return"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:254
msgid "conn object"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:0
#: ../../doc/reference/reference_lua/net_box.rst:0
#: ../../doc/reference/reference_lua/net_box.rst:0
#: ../../doc/reference/reference_lua/net_box.rst:0
#: ../../doc/reference/reference_lua/net_box.rst:0
msgid "rtype"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:255
msgid "userdata"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:257
#: ../../doc/reference/reference_lua/net_box.rst:357
#: ../../doc/reference/reference_lua/net_box.rst:495
#: ../../doc/reference/reference_lua/net_box.rst:529
#: ../../doc/reference/reference_lua/net_box.rst:647
#: ../../doc/reference/reference_lua/net_box.rst:751
msgid "**Examples:**"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:259
msgid "net_box = require('net.box')\n"
"\n"
"conn = net_box.connect('localhost:3301')\n"
"conn = net_box.connect('127.0.0.1:3302', {wait_connected = false})\n"
"conn = net_box.connect('127.0.0.1:3303', {reconnect_after = 5, call_16 = true})\n"
"conn = net_box.connect('127.0.0.1:3304', {required_protocol_version = 4, required_protocol_features = {'transactions', 'streams'}, })"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:272
msgid "``new()`` is a synonym for ``connect()``. It is retained for backward compatibility. For more information, see the description of :ref:`net_box.connect() <net_box-connect>`."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:279
msgid "For a local Tarantool server, there is a pre-created always-established connection object named :samp:`{net_box}.self`. Its purpose is to make polymorphic use of the ``net_box`` API easier. Therefore :samp:`conn = {net_box}.connect('localhost:3301')` can be replaced by :samp:`conn = {net_box}.self`."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:285
msgid "However, there is an important difference between the embedded connection and a remote one:"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:288
msgid "With the embedded connection, requests which do not modify data do not yield. When using a remote connection, due to :ref:`the implicit rules <app-implicit-yields>` any request can yield, and the database state may have changed by the time it regains control."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:294
msgid "All the options passed to a request (as ``is_async``, ``on_push``, ``timeout``) will be ignored."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:303
msgid "Execute a PING command."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:305
msgid "the supported option is :samp:`timeout={seconds}`"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:306
msgid "true on success, false on error"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:307
#: ../../doc/reference/reference_lua/net_box.rst:323
#: ../../doc/reference/reference_lua/net_box.rst:338
#: ../../doc/reference/reference_lua/net_box.rst:355
msgid "boolean"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:309
#: ../../doc/reference/reference_lua/net_box.rst:325
#: ../../doc/reference/reference_lua/net_box.rst:340
#: ../../doc/reference/reference_lua/net_box.rst:381
#: ../../doc/reference/reference_lua/net_box.rst:395
#: ../../doc/reference/reference_lua/net_box.rst:418
#: ../../doc/reference/reference_lua/net_box.rst:432
#: ../../doc/reference/reference_lua/net_box.rst:446
#: ../../doc/reference/reference_lua/net_box.rst:460
#: ../../doc/reference/reference_lua/net_box.rst:577
#: ../../doc/reference/reference_lua/net_box.rst:708
#: ../../doc/reference/reference_lua/net_box.rst:725
#: ../../doc/reference/reference_lua/net_box.rst:768
msgid "**Example:**"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:311
msgid "net_box.self:ping({timeout = 0.5})"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:319
msgid "Wait for connection to be active or closed."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:321
#: ../../doc/reference/reference_lua/net_box.rst:353
msgid "in seconds"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:322
msgid "true when connected, false on failure."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:327
msgid "net_box.self:wait_connected()"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:335
msgid "Show whether connection is active or closed."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:337
msgid "true if connected, false on failure."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:342
msgid "net_box.self:is_connected()"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:350
msgid "[since 1.7.2] Wait for a target state."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:352
msgid "target states"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:354
msgid "true when a target state is reached, false on timeout or connection closure"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:359
msgid "-- wait infinitely for 'active' state:\n"
"conn:wait_state('active')\n"
"\n"
"-- wait for 1.5 secs at most:\n"
"conn:wait_state('active', 1.5)\n"
"\n"
"-- wait infinitely for either `active` or `fetch_schema` state:\n"
"conn:wait_state({active=true, fetch_schema=true})"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:374
msgid "Close a connection."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:376
msgid "Connection objects are destroyed by the Lua garbage collector, just like any other objects in Lua, so an explicit destruction is not mandatory. However, since close() is a system call, it is good programming practice to close a connection explicitly when it is no longer needed, to avoid lengthy stalls of the garbage collector."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:383
msgid "conn:close()"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:391
msgid ":samp:`conn.space.{space-name}:select`:code:`({...})` is the remote-call equivalent of the local call :samp:`box.space.{space-name}:select`:code:`{...}` (:ref:`see details <box_space-select>`). For an additional option see :ref:`Module buffer and skip-header <buffer-module_and_skip_header>`."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:397
msgid "conn.space.testspace:select({1,'B'}, {timeout=1})"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:403
msgid "Due to :ref:`the implicit yield rules <app-implicit-yields>` a local :samp:`box.space.{space-name}:select`:code:`{...}` does not yield, but a remote :samp:`conn.space.{space-name}:select`:code:`{...}` call does yield, so global variables or database tuples data may change when a remote :samp:`conn.space.{space-name}:select`:code:`{...}` occurs."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:414
msgid ":samp:`conn.space.{space-name}:get(...)` is the remote-call equivalent of the local call :samp:`box.space.{space-name}:get(...)` (:ref:`see details <box_space-get>`)."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:420
msgid "conn.space.testspace:get({1})"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:428
msgid ":samp:`conn.space.{space-name}:insert(...)` is the remote-call equivalent of the local call :samp:`box.space.{space-name}:insert(...)` (:ref:`see details <box_space-insert>`). For an additional option see :ref:`Module buffer and skip-header <buffer-module_and_skip_header>`."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:434
msgid "conn.space.testspace:insert({2,3,4,5}, {timeout=1.1})"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:442
msgid ":samp:`conn.space.{space-name}:replace(...)` is the remote-call equivalent of the local call :samp:`box.space.{space-name}:replace(...)` (:ref:`see details <box_space-replace>`). For an additional option see :ref:`Module buffer and skip-header <buffer-module_and_skip_header>`."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:448
msgid "conn.space.testspace:replace({5,6,7,8})"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:456
msgid ":samp:`conn.space.{space-name}:update(...)` is the remote-call equivalent of the local call :samp:`box.space.{space-name}:update(...)` (:ref:`see details <box_space-update>`). For an additional option see :ref:`Module buffer and skip-header <buffer-module_and_skip_header>`."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:462
msgid "conn.space.Q:update({1},{{'=',2,5}}, {timeout=0})"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:470
msgid ":samp:`conn.space.{space-name}:upsert(...)` is the remote-call equivalent of the local call :samp:`box.space.{space-name}:upsert(...)`. (:ref:`see details <box_space-upsert>`). For an additional option see :ref:`Module buffer and skip-header <buffer-module_and_skip_header>`."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:478
msgid ":samp:`conn.space.{space-name}:delete(...)` is the remote-call equivalent of the local call :samp:`box.space.{space-name}:delete(...)` (:ref:`see details <box_space-delete>`). For an additional option see :ref:`Module buffer and skip-header <buffer-module_and_skip_header>`."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:486
msgid ":samp:`conn:eval({Lua-string})` evaluates and executes the expression in Lua-string, which may be any statement or series of statements. An :ref:`execute privilege <authentication-owners_privileges>` is required; if the user does not have it, an administrator may grant it with :samp:`box.schema.user.grant({username}, 'execute', 'universe')`."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:492
msgid "To ensure that the return from ``conn:eval`` is whatever the Lua expression returns, begin the Lua-string with the word \"return\"."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:497
msgid "tarantool> --Lua-string\n"
"tarantool> conn:eval('function f5() return 5+5 end; return f5();')\n"
"---\n"
"- 10\n"
"...\n"
"tarantool> --Lua-string, {arguments}\n"
"tarantool> conn:eval('return ...', {1,2,{3,'x'}})\n"
"---\n"
"- 1\n"
"- 2\n"
"- [3, 'x']\n"
"...\n"
"tarantool> --Lua-string, {arguments}, {options}\n"
"tarantool> conn:eval('return {nil,5}', {}, {timeout=0.1})\n"
"---\n"
"- [null, 5]\n"
"..."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:521
msgid "``conn:call('func', {'1', '2', '3'})`` is the remote-call equivalent of ``func('1', '2', '3')``. That is, ``conn:call`` is a remote stored-procedure call. The return from ``conn:call`` is whatever the function returns."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:525
msgid "Limitation: the called function cannot return a function, for example if ``func2`` is defined as ``function func2 () return func end`` then ``conn:call(func2)`` will return \"error: unsupported Lua type 'function'\"."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:531
msgid "tarantool> -- create 2 functions with conn:eval()\n"
"tarantool> conn:eval('function f1() return 5+5 end;')\n"
"tarantool> conn:eval('function f2(x,y) return x,y end;')\n"
"tarantool> -- call first function with no parameters and no options\n"
"tarantool> conn:call('f1')\n"
"---\n"
"- 10\n"
"...\n"
"tarantool> -- call second function with two parameters and one option\n"
"tarantool> conn:call('f2',{1,'B'},{timeout=99})\n"
"---\n"
"- 1\n"
"- B\n"
"..."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:552
msgid "Subscribe to events broadcast by a remote host."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:554
msgid "a key name of an event to subscribe to"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:555
msgid "a callback to invoke when the key value is updated"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:556
msgid "a watcher handle. The handle consists of one method -- ``unregister()``, which unregisters the watcher."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:558
msgid "To read more about watchers, see the :ref:`Functions for watchers <box-watchers>` section."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:560
msgid "The method has the same syntax as the :doc:`box.watch() </reference/reference_lua/box_events/broadcast>` function, which is used for subscribing to events locally."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:563
msgid "Watchers survive reconnection (see the ``reconnect_after`` connection :ref:`option <net_box-connect>`). All registered watchers are automatically resubscribed when the connection is reestablished."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:567
msgid "If a remote host supports watchers, the ``watchers`` key will be set in the connection ``peer_protocol_features``. For details, check the :ref:`net.box features table <net_box-connect>`."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:573
msgid "Keep in mind that garbage collection of a watcher handle doesn't lead to the watcher's destruction. In this case, the watcher remains registered. It is okay to discard the result of ``watch`` function if the watcher will never be unregistered."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:579
msgid "Server:"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:581
msgid "-- Broadcast value 42 for the 'foo' key.\n"
"box.broadcast('foo', 42)"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:586
msgid "Client:"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:588
msgid "conn = net.box.connect(URI)\n"
"local log = require('log')\n"
"-- Subscribe to updates of the 'foo' key.\n"
"w = conn:watch('foo', function(key, value)\n"
"    assert(key == 'foo')\n"
"    log.info(\"The box.id value is '%d'\", value)\n"
"end)"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:598
msgid "If you don't need the watcher anymore, you can unregister it using the command below:"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:600
msgid "w:unregister()"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:608
msgid "``{is_async=true|false}`` is an option which is applicable for all ``net_box`` requests including ``conn:call``, ``conn:eval``, and the ``conn.space.space-name`` requests."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:612
msgid "The default is ``is_async=false``, meaning requests are synchronous for the fiber. The fiber is blocked, waiting until there is a reply to the request or until timeout expires. Before Tarantool version 1.10, the only way to make asynchronous requests was to put them in separate fibers."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:618
msgid "The non-default is ``is_async=true``, meaning requests are asynchronous for the fiber. The request causes a yield but there is no waiting. The immediate return is not the result of the request, instead it is an object that the calling program can use later to get the result of the request."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:624
msgid "This immediately-returned object, which we'll call \"future\", has its own methods:"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:627
msgid "``future:is_ready()`` which will return true when the result of the request is available,"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:629
msgid "``future:result()`` to get the result of the request (returns the response or **nil** in case it's not ready yet or there has been an error),"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:631
msgid "``future:wait_result(timeout)`` to wait until the result of the request is available and then get it, or throw an error if there is no result after the timeout exceeded,"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:634
msgid "``future:discard()`` to abandon the object."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:636
msgid "Typically a user would say ``future=request-name(...{is_async=true})``, then either loop checking ``future:is_ready()`` until it is true and then say ``request_result=future:result()``, or say ``request_result=future:wait_result(...)``. Alternatively the client could check for \"out-of-band\" messages from the server by calling ``pairs()`` in a loop -- see :doc:`/reference/reference_lua/box_session/push`."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:643
msgid "A user would say ``future:discard()`` to make a connection forget about the response -- if a response for a discarded object is received then it will be ignored, so that the size of the requests table will be reduced and other requests will be faster."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:649
msgid "-- Insert a tuple asynchronously --\n"
"tarantool> future = conn.space.bands:insert({10, 'Queen', 1970}, {is_async=true})\n"
"---\n"
"...\n"
"tarantool> future:is_ready()\n"
"---\n"
"- true\n"
"...\n"
"tarantool> future:result()\n"
"---\n"
"- [10, 'Queen', 1970]\n"
"...\n"
"\n"
"-- Iterate through a space with 10 records to get data in chunks of 3 records --\n"
"tarantool> while true do\n"
"               future = conn.space.bands:select({}, {limit=3, after=position, fetch_pos=true, is_async=true})\n"
"               result = future:wait_result()\n"
"               tuples = result[1]\n"
"               position = result[2]\n"
"               if position == nil then\n"
"                   break\n"
"               end\n"
"               print('Chunk size: '..#tuples)\n"
"           end\n"
"Chunk size: 3\n"
"Chunk size: 3\n"
"Chunk size: 3\n"
"Chunk size: 1\n"
"---\n"
"..."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:683
msgid "Typically ``{is_async=true}`` is used only if the load is large (more than 100,000 requests per second) and latency is large (more than 1 second), or when it is necessary to send multiple requests in parallel then collect responses (sometimes called a \"map-reduce\" scenario)."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:691
msgid "Although the final result of an async request is the same as the result of a sync request, it is structured differently: as a table, instead of as the unpacked values."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:699
msgid "``{return_raw=true}`` is ignored for:"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:701
msgid "Methods that return ``nil``: ``begin``, ``commit``, ``rollback``, ``upsert``, ``prepare``."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:704
msgid "``index.count`` (returns number)."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:706
msgid "For ``execute``, the option is applied only to data (`rows`). Metadata is decoded even if ``{return_raw=true}``."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:710
msgid "local c = require('net.box').connect(uri)\n"
"local mp = c.eval('eval ...', {1, 2, 3}, {return_raw = true})\n"
"mp:decode() -- {1, 2, 3}"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:716
msgid "The option can be useful if you want to pass a response through without decoding or with partial decoding. The usage of :ref:`MsgPack object <msgpack-object-info>` can reduce pressure on the Lua garbage collector."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:723
msgid "Create a stream."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:727
msgid "-- Start a server to create a new stream\n"
"local conn = net_box.connect('localhost:3301')\n"
"local conn_space = conn.space.test\n"
"local stream = conn:new_stream()\n"
"local stream_space = stream.space.test"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:741
msgid "Begin a stream transaction. Instead of the direct method, you can also use the ``call``, ``eval`` or execute methods with SQL transaction."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:743
msgid ":ref:`transaction isolation level <txn_mode_mvcc-options>`"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:749
msgid "Commit a stream transaction. Instead of the direct method, you can also use the ``call``, ``eval`` or execute methods with SQL transaction."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:753
msgid "-- Begin stream transaction\n"
"stream:begin()\n"
"-- In the previously created ``accounts`` space with the primary key ``test``, modify the fields 2 and 3\n"
"stream.space.accounts:update(test_1, {{'-', 2, 370}, {'+', 3, 100}})\n"
"-- Commit stream transaction\n"
"stream:commit()"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:766
msgid "Rollback a stream transaction. Instead of the direct method, you can also use the ``call``, ``eval`` or execute methods with SQL transaction."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:770
msgid "-- Test rollback for memtx space\n"
"space:replace({1})\n"
"-- Select return tuple that was previously inserted, because this select belongs to stream transaction\n"
"space:select({})\n"
"stream:rollback()\n"
"-- Select is empty, stream transaction rollback\n"
"space:select({})"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:784
msgid "Triggers"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:786
msgid "With the ``net.box`` module, you can use the following :ref:`triggers <triggers-box_triggers>`:"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:793
msgid "Define a trigger for execution when a new connection is established, and authentication and schema fetch are completed due to an event such as ``net_box.connect``."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:796
#: ../../doc/reference/reference_lua/net_box.rst:864
msgid "If a trigger function issues ``net_box`` requests, they must be :ref:`asynchronous <net_box-is_async>` (``{is_async = true}``). An attempt to wait for request completion with ``future:pairs()`` or ``future:wait_result()`` in the trigger function will result in an error."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:800
msgid "If the trigger execution fails and an exception happens, the connection's state changes to 'error'. In this case, the connection is terminated, regardless of the ``reconnect_after`` option's value. Can be called as many times as reconnection happens, if ``reconnect_after`` is greater than zero."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:805
msgid "the trigger function. Takes the ``conn`` object as the first argument."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:807
#: ../../doc/reference/reference_lua/net_box.rst:823
#: ../../doc/reference/reference_lua/net_box.rst:852
#: ../../doc/reference/reference_lua/net_box.rst:870
msgid "an existing trigger function to replace with ``trigger-function``"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:809
#: ../../doc/reference/reference_lua/net_box.rst:825
#: ../../doc/reference/reference_lua/net_box.rst:854
#: ../../doc/reference/reference_lua/net_box.rst:872
msgid "nil or function pointer"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:815
msgid "Define a trigger for execution after a connection is closed. If the trigger function causes an error, the error is logged but otherwise is ignored. Execution stops after a connection is explicitly closed, or once the Lua garbage collector removes it."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:820
#: ../../doc/reference/reference_lua/net_box.rst:850
#: ../../doc/reference/reference_lua/net_box.rst:868
msgid "the trigger function. Takes the ``conn`` object as the first argument"
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:831
msgid "Define a trigger for shutdown when a :ref:`box.shutdown <system-events_box-shutdown>` event is received."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:833
msgid "The trigger starts in a new fiber. While the ``on_shutdown()`` trigger is running, the connection stays active. It means that the trigger callback is allowed to send new requests."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:837
msgid "After the trigger return, the ``net.box`` connection goes to the ``graceful_shutdown`` state (check :ref:`the state diagram <net_box-state_diagram>` for details). In this state, no new requests are allowed. The connection waits for all pending requests to be completed."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:842
msgid "Once all in-progress requests have been processed, the connection is closed. The state changes to ``error`` or ``error_reconnect`` (if the ``reconnect_after`` option is defined)."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:846
msgid "Servers that do not support the ``box.shutdown`` event or :ref:`IPROTO_WATCH <box_protocol-watch>` just close the connection abruptly. In this case, the ``on_shutdown()`` trigger is not executed."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:860
msgid "Define a trigger executed when some operation has been performed on the remote server after schema has been updated. So, if a server request fails due to a schema version mismatch error, schema reload is triggered."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:876
msgid "If the parameters are ``(nil, old-trigger-function)``, then the old trigger is deleted."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:879
msgid "If both parameters are omitted, then the response is a list of existing trigger functions."
msgstr ""

#: ../../doc/reference/reference_lua/net_box.rst:882
msgid "Find the detailed information about triggers in the :ref:`triggers <triggers-box_triggers>` section."
msgstr ""
