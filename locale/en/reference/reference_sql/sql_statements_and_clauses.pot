# SOME DESCRIPTIVE TITLE.
# Copyright (C) 
# This file is distributed under the same license as the Tarantool package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Tarantool 3.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-11-17 14:22+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:6
msgid "SQL statements and clauses"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:8
msgid "The Statements and Clauses guide shows all Tarantool/SQL statements' syntax and use."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:15
msgid "Heading"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:16
msgid "Summary"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:17
msgid ":ref:`Statements that change data definition <sql_statements_change_definition>`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:18
msgid ":ref:`ALTER TABLE <sql_alter_table>`, :ref:`CREATE TABLE <sql_create_table>`, :ref:`DROP TABLE <sql_drop_table>`, :ref:`CREATE VIEW <sql_create_view>`, :ref:`DROP VIEW <sql_drop_view>`, :ref:`CREATE INDEX <sql_create_index>`, :ref:`DROP INDEX <sql_drop_index>`, :ref:`CREATE TRIGGER <sql_create_trigger>`, :ref:`DROP TRIGGER <sql_drop_trigger>`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:21
msgid ":ref:`Statements that change data <sql_statements_change_data>`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:22
msgid ":ref:`INSERT <sql_insert>`, :ref:`UPDATE <sql_update>`,  :ref:`DELETE <sql_delete>`, :ref:`REPLACE <sql_replace>`, :ref:`TRUNCATE <sql_truncate>`, :ref:`SET <sql_set>`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:24
msgid ":ref:`Statements that retrieve data <sql_statements_retrieve_data>`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:25
msgid ":ref:`SELECT <sql_select>`, :ref:`VALUES <sql_values>`, :ref:`PRAGMA <sql_pragma>`, :ref:`EXPLAIN <sql_explain>`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:26
msgid ":ref:`Statements for transactions <sql_transactions>`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:27
msgid ":ref:`START TRANSACTION <sql_start_transaction>`, :ref:`COMMIT <sql_commit>`, :ref:`SAVEPOINT <sql_savepoint>`, :ref:`RELEASE SAVEPOINT <sql_release_savepoint>`, :ref:`ROLLBACK <sql_rollback>`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:29
msgid ":ref:`Functions <sql_functions>`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:30
msgid "For example :ref:`CAST(...) <sql_function_cast>`, :ref:`LENGTH(...) <sql_function_length>`, :ref:`VERSION() <sql_function_version>`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:37
msgid "Statements that change data definition"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:43
msgid "ALTER TABLE"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:45
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:152
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:240
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:833
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:882
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:939
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:981
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1057
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1096
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1429
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1474
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1546
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1625
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1674
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1719
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1770
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1831
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1857
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1925
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1997
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2037
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2122
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2198
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2251
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2351
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2402
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2463
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2608
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2693
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2759
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2795
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2917
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3000
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3070
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3099
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3129
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3158
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3216
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3244
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3258
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3275
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3308
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3324
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3391
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3409
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3438
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3456
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3474
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3500
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3514
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3528
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3543
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3579
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3604
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3638
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3660
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3682
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3706
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3723
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3740
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3811
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3831
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3862
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3885
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3910
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3926
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3941
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3956
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3974
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3988
msgid "Syntax:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:47
msgid ":samp:`ALTER TABLE {table-name} RENAME TO {new-table-name};`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:48
msgid ":samp:`ALTER TABLE {table-name} ADD COLUMN {column-name} {column-definition};`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:49
msgid ":samp:`ALTER TABLE {table-name} ADD CONSTRAINT {constraint-name} {constraint-definition};`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:50
msgid ":samp:`ALTER TABLE {table-name} DROP CONSTRAINT {constraint-name};`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:51
msgid ":samp:`ALTER TABLE {table-name} ENABLE|DISABLE CHECK CONSTRAINT {constraint-name};`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:54
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:59
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:157
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:162
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:260
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:837
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:842
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:886
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:891
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:943
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:948
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:985
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:990
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1061
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1066
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1108
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1113
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1433
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1438
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1480
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1485
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1552
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1557
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1629
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1634
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1680
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1685
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1723
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1728
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1840
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1845
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1866
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1929
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1934
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2001
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2006
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2041
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2046
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2202
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2207
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2255
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2260
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2361
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2366
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2469
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2474
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2539
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2544
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2614
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2619
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2624
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2629
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2697
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2702
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2763
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2768
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3004
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3009
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3074
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3079
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3103
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3108
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3133
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3138
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3162
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3167
msgid "|br|"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:61
msgid "ALTER is used to change a table's name or a table's elements."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:63
msgid "**Examples:**"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:65
msgid "For renaming a table with ``ALTER ... RENAME``, the *old-table* must exist, the *new-table* must not exist. Example: |br| ``-- renaming a table:`` ``ALTER TABLE t1 RENAME TO t2;``"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:70
msgid "For adding a :ref:`column <sql_column_def>` with ``ADD COLUMN``, the table must exist, the table must be empty, the column name must be unique within the table. Example with a STRING column that must start with X:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:75
msgid "ALTER TABLE t1 ADD COLUMN s4 STRING CHECK (s4 LIKE 'X%');"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:79
msgid "``ALTER TABLE ... ADD COLUMN`` support was added in version :doc:`2.7.1 </release/2.7.1>`."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:81
msgid "For adding a :ref:`table constraint <sql_table_constraint_def>` with ``ADD CONSTRAINT``, the table must exist, the table must be empty, the constraint name must be unique within the table. Example with a :ref:`foreign-key constraint definition <sql_foreign_key>`: |br| ``ALTER TABLE t1 ADD CONSTRAINT fk_s1_t1_1 FOREIGN KEY (s1) REFERENCES t1;`` |br|"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:87
msgid "It is not possible to say ``CREATE TABLE table_a ... REFERENCES table_b ...`` if table ``b`` does not exist yet. This is a situation where ``ALTER TABLE`` is handy -- users can ``CREATE TABLE table_a`` without the foreign key, then ``CREATE TABLE table_b``, then ``ALTER TABLE table_a ... REFERENCES table_b ...``."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:92
msgid "-- adding a primary-key constraint definition:\n"
"-- This is unusual because primary keys are created automatically\n"
"-- and it is illegal to have two primary keys for the same table.\n"
"-- However, it is possible to drop a primary-key index, and this\n"
"-- is a way to restore the primary key if that happens.\n"
"ALTER TABLE t1 ADD CONSTRAINT \"pk_unnamed_T1_1\" PRIMARY KEY (s1);\n"
"\n"
"-- adding a unique-constraint definition:\n"
"-- Alternatively, you can say CREATE UNIQUE INDEX unique_key ON t1 (s1);\n"
"ALTER TABLE t1 ADD CONSTRAINT \"unique_unnamed_T1_2\" UNIQUE (s1);\n"
"\n"
"-- Adding a check-constraint definition:\n"
"ALTER TABLE t1 ADD CONSTRAINT \"ck_unnamed_T1_1\" CHECK (s1 > 0);"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:110
msgid "For ``ALTER ... DROP CONSTRAINT``, it is only legal to drop a named constraint. (Tarantool generates the constraint names automatically if the user does not provide them.) Since version :doc:`2.4.1 </release/2.4.1>`, it is possible to drop any of the named table constraints, namely, PRIMARY KEY, UNIQUE, FOREIGN KEY, and CHECK."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:117
msgid "To remove a unique constraint, use either ``ALTER ... DROP CONSTRAINT`` or :ref:`DROP INDEX <sql_drop_index>`, which will drop the constraint as well."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:121
msgid "-- dropping a constraint:\n"
"ALTER TABLE t1 DROP CONSTRAINT \"fk_unnamed_JJ2_1\";"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:126
msgid "For ``ALTER ... ENABLE|DISABLE CHECK CONSTRAINT``, it is only legal to enable or disable a named constraint, and Tarantool only looks for names of check constraints. By default a constraint is enabled. If a constraint is disabled, then the check will not be performed."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:131
msgid "-- disabling and re-enabling a constraint:\n"
"ALTER TABLE t1 DISABLE CHECK CONSTRAINT c;\n"
"ALTER TABLE t1 ENABLE CHECK CONSTRAINT c;"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:137
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:226
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:927
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1409
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2108
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2241
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2339
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2389
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2668
msgid "Limitations:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:139
msgid "It is not possible to drop a column."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:140
msgid "It is not possible to modify NOT NULL constraints or column properties DEFAULT and :ref:`data type <sql_column_def_data_type>`. However, it is possible to modify them with Tarantool/NOSQL, for example by calling :ref:`space_object:format() <box_space-format>` with a different ``is_nullable`` value."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:150
msgid "CREATE TABLE"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:154
msgid ":samp:`CREATE TABLE [IF NOT EXISTS] {table-name} (column-definition or table-constraint list)` :samp:`[WITH ENGINE = {string}];`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:164
msgid "Create a new base table, usually called a \"table\"."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:168
msgid "A table is a *base table* if it is created with CREATE TABLE and contains data in persistent storage."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:171
msgid "A table is a *viewed table*, or just \"view\", if it is created with :ref:`CREATE VIEW <sql_create_view>` and gets its data from other views or from base tables."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:174
msgid "The *table-name* must be an identifier which is valid according to the rules for identifiers, and must not be the name of an already existing base table or view."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:177
msgid "The *column-definition* or *table-constraint* list is a comma-separated list of :ref:`column definitions <sql_column_def>` or :ref:`table constraint definitions <sql_table_constraint_def>`. Column definitions and table constraint definitions are sometimes called *table elements*."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:182
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:849
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:904
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1001
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1123
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1497
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1569
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1644
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1736
msgid "Rules:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:184
msgid "A primary key is necessary; it can be specified with a table constraint PRIMARY KEY."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:186
msgid "There must be at least one column."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:187
msgid "When IF NOT EXISTS is specified, and there is already a table with the same name, the statement is ignored."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:189
msgid "When :samp:`WITH ENGINE = {string}` is specified, where :samp:`{string}` must be either 'memtx' or 'vinyl', the table is created with that :ref:`storage engine <engines-chapter>`. When this clause is not specified, the table is created with the default engine, which is ordinarily 'memtx' but may be changed by updating the :ref:`box.space._session_settings <box_space-session_settings>` system table.."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:197
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:857
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:911
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:957
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1009
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1076
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1141
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1447
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1513
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1579
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1650
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1743
msgid "Actions:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:199
msgid "Tarantool evaluates each column definition and table-constraint, and returns an error if any of the rules is violated."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:201
msgid "Tarantool makes a new definition in the schema."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:202
msgid "Tarantool makes new indexes for PRIMARY KEY or UNIQUE constraints. A unique index name is created automatically."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:204
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:863
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:916
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:962
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1015
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1081
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1145
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1451
msgid "Usually Tarantool effectively executes a :ref:`COMMIT <sql_commit>` statement."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:206
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:865
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:918
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:964
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1037
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1147
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1453
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1524
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1589
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1659
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1695
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1904
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1978
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2022
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2099
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2228
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2314
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2378
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2505
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2777
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3181
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3354
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3426
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3487
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3556
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3586
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3872
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3893
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:4010
msgid "Examples:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:208
msgid "-- the simplest form, with one column and one constraint:\n"
"CREATE TABLE t1 (s1 INTEGER, PRIMARY KEY (s1));\n"
"\n"
"-- you can see the effect of the statement by querying\n"
"-- Tarantool system spaces:\n"
"SELECT * FROM \"_space\" WHERE \"name\" = 'T1';\n"
"SELECT * FROM \"_index\" JOIN \"_space\" ON \"_index\".\"id\" = \"_space\".\"id\"\n"
"         WHERE \"_space\".\"name\" = 'T1';\n"
"\n"
"-- variation of the simplest form, with delimited identifiers\n"
"-- and a bracketed comment:\n"
"CREATE TABLE \"T1\" (\"S1\" INT /* synonym of INTEGER */, PRIMARY KEY (\"S1\"));\n"
"\n"
"-- two columns, one named constraint\n"
"CREATE TABLE t1 (s1 INTEGER, s2 STRING, CONSTRAINT pk_s1s2_t1_1 PRIMARY KEY (s1, s2));"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:228
msgid "The maximum number of columns is 2000."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:229
msgid "The maximum length of a row depends on the :ref:`memtx_max_tuple_size <cfg_storage-memtx_max_tuple_size>` or :ref:`vinyl_max_tuple_size  <cfg_storage-memtx_max_tuple_size>` configuration option."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:238
msgid "Column definition"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:242
msgid ":samp:`column-name data-type [, column-constraint]`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:244
msgid "Define a column, which is a table element used in a :ref:`CREATE TABLE <sql_create_table>` statement."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:246
msgid "The ``column-name`` must be an identifier which is valid according to the rules for identifiers."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:249
msgid "Each ``column-name`` must be unique within a table."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:255
msgid "Column definition -- data type"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:262
msgid "Every column has a data type: ANY or ARRAY or BOOLEAN or DECIMAL or DOUBLE or INTEGER or MAP or NUMBER or SCALAR or STRING or UNSIGNED or UUID or VARBINARY. The detailed description of data types is in the section :ref:`Operands <sql_operands>`."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:272
msgid "Column definition -- the rules for the SCALAR data type"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:274
msgid "The rules for the SCALAR data type were significantly changed in Tarantool version :tarantool-release:`2.10.0`."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:277
msgid "SCALAR is a \"complex\" data type, unlike all the other data types which are \"primitive\". Two column values in a SCALAR column can have two different primitive data types."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:280
msgid "Any item defined as SCALAR has an underlying primitive type. For example, here:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:282
msgid "CREATE TABLE t (s1 SCALAR PRIMARY KEY);\n"
"INSERT INTO t VALUES (55), ('41');"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:287
msgid "the underlying primitive type of the item in the first row is INTEGER because literal 55 has data type INTEGER, and the underlying primitive type in the second row is STRING (the data type of a literal is always clear from its format)."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:292
msgid "An item's primitive type is far less important than its defined type. Incidentally Tarantool might find the primitive type by looking at the way MsgPack stores it, but that is an implementation detail."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:296
msgid "A SCALAR definition may not include a maximum length, as there is no suggested restriction."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:298
msgid "A SCALAR definition may include a :ref:`COLLATE clause <sql_collate_clause>`, which affects any items whose primitive data type is STRING. The default collation is \"binary\"."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:300
msgid "Some assignments are illegal when data types differ, but legal when the target is a SCALAR item. For example ``UPDATE ... SET column1 = 'a'`` is illegal if ``column1`` is defined as INTEGER, but is legal if ``column1`` is defined as SCALAR -- values which happen to be INTEGER will be changed so their data type is SCALAR."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:305
msgid "There is no literal syntax which implies data type SCALAR."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:306
msgid "TYPEOF(x) is always 'scalar' or 'NULL', it is never the underlying data type. In fact there is no function that is guaranteed to return the underlying data type. For example, ``TYPEOF(CAST(1 AS SCALAR));`` returns 'scalar', not 'integer'."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:309
msgid "For any operation that requires implicit casting from an item defined as SCALAR, the operation will fail at runtime. For example, if a definition is:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:313
msgid "CREATE TABLE t (s1 SCALAR PRIMARY KEY, s2 INTEGER);"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:317
msgid "and the only row in table T has s1 = 1, that is, its underlying primitive type is INTEGER, then ``UPDATE t SET s2 = s1;`` is illegal."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:319
msgid "For any dyadic operation that requires implicit casting for comparison, the syntax is legal and the operation will not fail at runtime. Take this situation: comparison with a primitive type VARBINARY and a primitive type STRING."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:324
msgid "CREATE TABLE t (s1 SCALAR PRIMARY KEY);\n"
"INSERT INTO t VALUES (X'41');\n"
"SELECT * FROM t WHERE s1 > 'a';"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:330
msgid "The comparison is valid, because Tarantool knows the ordering of X'41' and 'a' in Tarantool/NoSQL 'scalar' -- this is a case where the primitive type matters."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:332
msgid "The result data type of :ref:`min/max <sql_aggregate>` operation on a column defined as SCALAR is SCALAR. Users will need to know the underlying primitive type of the result in advance. For example:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:336
msgid "CREATE TABLE t (s1 INTEGER, s2 SCALAR PRIMARY KEY);\n"
"INSERT INTO t VALUES (1, X'44'), (2, 11), (3, 1E4), (4, 'a');\n"
"SELECT cast(min(s2) AS INTEGER), hex(cast(max(s2) as VARBINARY)) FROM t;"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:342
msgid "The result is: ``- - [11, '44',]``"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:344
msgid "That is only possible with Tarantool/NoSQL scalar rules, but ``SELECT SUM(s2)`` would not be legal because addition would in this case require implicit casting from VARBINARY to a numeric, which is not sensible."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:347
msgid "The result data type of a primitive combination is sometimes SCALAR although Tarantool in effect uses the primitive data type not the defined data type. (Here the word \"combination\" is used in the way that the standard document uses it for section \"Result of data type combinations\".) Therefore for ``greatest(1E308, 'a', 0, X'00')`` the result is X'00' but ``typeof(greatest(1E308, 'a', 0, X'00')`` is 'scalar'."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:353
msgid "The union of two SCALARs is sometimes the primitive type. For example, ``SELECT TYPEOF((SELECT CAST('a' AS SCALAR) UNION SELECT CAST('a' AS SCALAR)));`` returns 'string'."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:359
msgid "Column definition -- relation to NoSQL"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:361
msgid "All of the SQL data types except SCALAR correspond to :ref:`Tarantool/NoSQL types with the same name <index-box_indexed-field-types>`. For example an SQL STRING is stored in a NoSQL space as type = 'string'."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:365
msgid "Therefore specifying an SQL data type X determines that the storage will be in a space with a format column saying that the NoSQL type is 'x'."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:368
msgid "The rules for that NoSQL type are applicable to the SQL data type."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:370
msgid "If two items have SQL data types that have the same underlying type, then they are compatible for all assignment or comparison purposes."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:373
msgid "If two items have SQL data types that have different underlying types, then the rules for explicit casts, or implicit (assignment) casts, or implicit (comparison) casts, apply."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:377
msgid "There is one floating-point value which is not handled by SQL: -nan is seen as NULL although its data type is 'double'."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:380
msgid "Before Tarantool :tarantool-release:`2.10.0`, there were also some Tarantool/NoSQL data types which had no corresponding SQL data types. For example, ``SELECT \"flags\" FROM \"_vspace\";`` would return a column whose SQL data type is VARBINARY rather than MAP. Such columns can only be manipulated in SQL by :ref:`invoking Lua functions <sql_calling_lua>`."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:389
msgid "Column definition -- column-constraint or default clause"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:394
msgid "The column-constraint or default clause may be as follows:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:402
msgid "Type"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:403
msgid "Comment"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:404
msgid "NOT NULL"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:405
msgid "means \"it is illegal to assign a NULL to this column\""
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:406
msgid "PRIMARY KEY"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:407
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:410
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:413
msgid "explained in the :ref:`Table constraint definition <sql_table_constraint_def>` section"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:409
msgid "UNIQUE"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:412
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:681
msgid "CHECK (expression)"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:415
msgid "foreign-key-clause"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:416
msgid "explained in the :ref:`Table constraint definition for foreign keys <sql_foreign_key>` section"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:419
msgid "DEFAULT expression"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:420
msgid "means \"if INSERT does not assign to this column then assign expression result to this column\" -- if there is no DEFAULT clause then DEFAULT NULL is assumed"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:426
msgid "If column-constraint is PRIMARY KEY, this is a shorthand for a separate :ref:`table-constraint definition <sql_table_constraint_def>`: \"PRIMARY KEY (column-name)\"."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:429
msgid "If column-constraint is UNIQUE, this is a shorthand for a separate :ref:`table-constraint definition <sql_table_constraint_def>`: \"UNIQUE (column-name)\"."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:432
msgid "If column-constraint is CHECK, this is a shorthand for a separate :ref:`table-constraint definition <sql_table_constraint_def>`: \"CHECK (expression)\"."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:435
msgid "Columns defined with PRIMARY KEY are automatically NOT NULL."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:437
msgid "To enforce some restrictions that Tarantool does not enforce automatically, add CHECK clauses, like these:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:440
msgid "CREATE TABLE t (\"smallint\" INTEGER PRIMARY KEY CHECK (\"smallint\" <= 32767 AND \"smallint\" >= -32768));\n"
"CREATE TABLE t (\"shorttext\" STRING PRIMARY KEY CHECK (length(\"shorttext\") <= 10));"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:445
msgid "but this may cause inserts or updates to be slow."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:449
msgid "Column definition -- examples"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:451
msgid "These are shown within :ref:`CREATE TABLE <sql_create_table>` statements. Data types may also appear in :ref:`CAST <sql_function_cast>` functions."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:454
msgid "-- the simple form with column-name and data-type\n"
"CREATE TABLE t (column1 INTEGER ...);\n"
"-- with column-name and data-type and column-constraint\n"
"CREATE TABLE t (column1 STRING PRIMARY KEY ...);\n"
"-- with column-name and data-type and collate-clause\n"
"CREATE TABLE t (column1 SCALAR COLLATE \"unicode\" ...);"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:463
msgid "-- with all possible data types and aliases\n"
"CREATE TABLE t\n"
"(column1 BOOLEAN, column2 BOOL,\n"
" column3 INT PRIMARY KEY, column4 INTEGER,\n"
" column5 DOUBLE,\n"
" column6 NUMBER,\n"
" column7 STRING, column8 STRING COLLATE \"unicode\",\n"
" column9 TEXT, columna TEXT COLLATE \"unicode_sv_s1\",\n"
" columnb VARCHAR(0), columnc VARCHAR(100000) COLLATE \"binary\",\n"
" columnd UUID,\n"
" columne VARBINARY,\n"
" columnf SCALAR, columng SCALAR COLLATE \"unicode_uk_s2\",\n"
" columnh DECIMAL,\n"
" columni ARRAY,\n"
" columnj MAP,\n"
" columnk ANY);"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:482
msgid "-- with all possible column constraints and a default clause\n"
"CREATE TABLE t\n"
"(column1 INTEGER NOT NULL,\n"
" column2 INTEGER PRIMARY KEY,\n"
" column3 INTEGER UNIQUE,\n"
" column4 INTEGER CHECK (column3 > column2),\n"
" column5 INTEGER REFERENCES t,\n"
" column6 INTEGER DEFAULT NULL);"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:497
msgid "Table constraint definition"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:499
msgid "A table :ref:`constraint <index-constraints>` restricts the data you can add to the table. If you try to insert invalid data on a column, Tarantool throws an error."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:502
msgid "A table constraint has the following syntax:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:504
msgid "[CONSTRAINT [name]] constraint_expression\n"
"\n"
"constraint_expression:\n"
"  | PRIMARY KEY (column_name, ...)\n"
"  | UNIQUE (column_name, ...)\n"
"  | CHECK (expression)\n"
"  | FOREIGN KEY (column_name, ...) foreign_key_clause"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:515
msgid "Define a constraint, which is a table element used in a CREATE TABLE statement."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:517
msgid "A constraint name must be an identifier that is valid according to the rules for identifiers. A constraint name must be unique within the table for a specific constraint type. For example, the CHECK and FOREIGN KEY constraints can have the same name."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:521
msgid "**PRIMARY KEY constraints**"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:523
msgid "PRIMARY KEY constraints look like this:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:525
msgid "PRIMARY KEY (column_name, ...)"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:529
msgid "There is a shorthand: specifying PRIMARY KEY in a :ref:`column definition <sql_column_def_constraint>`."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:531
msgid "Every table must have one and only one primary key."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:532
msgid "Primary-key columns are automatically ``NOT NULL``."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:533
msgid "Primary-key columns are automatically indexed."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:534
msgid "Primary-key columns are unique. That means it is illegal to have two rows with the same values for the columns specified in the constraint."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:536
msgid "**Example 1: one-column primary key**"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:538
msgid "Create an ``author`` table with the ``id`` primary key column:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:540
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:769
msgid "CREATE TABLE author (\n"
"    id INTEGER PRIMARY KEY,\n"
"    name STRING NOT NULL\n"
");\n"
""
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:546
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:573
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:632
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:659
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:705
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:775
msgid "Insert data into this table:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:548
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:634
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:707
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:777
msgid "INSERT INTO author VALUES (1, 'Leo Tolstoy'),\n"
"                          (2, 'Fyodor Dostoevsky');\n"
""
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:554
msgid "On an attempt to add an author with the existing id, the following error is raised:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:556
msgid "INSERT INTO author VALUES (2, 'Alexander Pushkin');\n"
"/*\n"
"- Duplicate key exists in unique index \"pk_unnamed_AUTHOR_1\" in space \"AUTHOR\" with\n"
"  old tuple - [2, \"Fyodor Dostoevsky\"] and new tuple - [2, \"Alexander Pushkin\"]\n"
"*/\n"
""
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:563
msgid "**Example 2: two-column primary key**"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:565
msgid "Create a ``book`` table with the primary key defined on two columns:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:567
msgid "CREATE TABLE book (\n"
"    id INTEGER,\n"
"    title STRING NOT NULL,\n"
"    PRIMARY KEY (id, title)\n"
");\n"
""
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:575
msgid "INSERT INTO book VALUES (1, 'War and Peace'),\n"
"                        (2, 'Crime and Punishment');\n"
""
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:581
msgid "On an attempt to add the existing book, the following error is raised:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:583
msgid "INSERT INTO book VALUES (2, 'Crime and Punishment');\n"
"/*\n"
"- Duplicate key exists in unique index \"pk_unnamed_BOOK_1\" in space \"BOOK\" with old\n"
"  tuple - [2, \"Crime and Punishment\"] and new tuple - [2, \"Crime and Punishment\"]\n"
"*/\n"
""
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:589
msgid "PRIMARY KEY with the AUTOINCREMENT modifier may be specified in one of two ways:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:591
msgid "In a column definition after the words PRIMARY KEY, as in ``CREATE TABLE t (c INTEGER PRIMARY KEY AUTOINCREMENT);``"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:593
msgid "In a PRIMARY KEY (column-list) after a column name, as in ``CREATE TABLE t (c INTEGER, PRIMARY KEY (c AUTOINCREMENT));``"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:595
msgid "When AUTOINCREMENT is specified, the column must be a primary-key column and it must be INTEGER or UNSIGNED."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:597
msgid "Only one column in the table may be autoincrement. However, it is legal to say ``PRIMARY KEY (a, b, c AUTOINCREMENT)`` -- in that case, there are three columns in the primary key but only the third column (``c``) is AUTOINCREMENT."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:601
msgid "As the name suggests, values in an autoincrement column are automatically incremented. That is: if a user inserts NULL in the column, then the stored value will be the smallest non-negative integer that has not already been used. This occurs because autoincrement columns are associated with :doc:`sequences </reference/reference_lua/box_schema_sequence/create_index>`."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:606
msgid "**UNIQUE constraints**"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:608
msgid "UNIQUE constraints look like this:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:610
msgid "UNIQUE (column_name, ...)"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:614
msgid "There is a shorthand: specifying UNIQUE in a :ref:`column definition <sql_column_def_constraint>`."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:616
msgid "Unique constraints are similar to primary-key constraints, except that:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:618
msgid "A table may have any number of unique keys, and unique keys are not automatically NOT NULL."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:619
msgid "Unique columns are automatically indexed."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:620
msgid "Unique columns are unique. That means it is illegal to have two rows with the same values in the unique-key columns."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:622
msgid "**Example 1: one-column unique constraint**"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:624
msgid "Create an ``author`` table with the unique ``name`` column:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:626
msgid "CREATE TABLE author (\n"
"    id INTEGER PRIMARY KEY,\n"
"    name STRING UNIQUE\n"
");\n"
""
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:640
msgid "On an attempt to add an author with the same name, the following error is raised:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:642
msgid "INSERT INTO author VALUES (3, 'Leo Tolstoy');\n"
"/*\n"
"- Duplicate key exists in unique index \"unique_unnamed_AUTHOR_2\" in space \"AUTHOR\"\n"
"  with old tuple - [1, \"Leo Tolstoy\"] and new tuple - [3, \"Leo Tolstoy\"]\n"
"*/\n"
""
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:649
msgid "**Example 2: two-column unique constraint**"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:651
msgid "Create a ``book`` table with the unique constraint defined on two columns:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:653
msgid "CREATE TABLE book (\n"
"    id INTEGER PRIMARY KEY,\n"
"    title STRING NOT NULL,\n"
"    author_id INTEGER UNIQUE,\n"
"    UNIQUE (title, author_id)\n"
");\n"
""
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:661
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:803
msgid "INSERT INTO book VALUES (1, 'War and Peace', 1),\n"
"                        (2, 'Crime and Punishment', 2);\n"
""
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:667
msgid "On an attempt to add a book with duplicated values, the following error is raised:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:669
msgid "INSERT INTO book VALUES (3, 'War and Peace', 1);\n"
"/*\n"
"- Duplicate key exists in unique index \"unique_unnamed_BOOK_2\" in space \"BOOK\" with\n"
"  old tuple - [1, \"War and Peace\", 1] and new tuple - [3, \"War and Peace\", 1]\n"
"*/\n"
""
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:676
msgid "**CHECK constraints**"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:678
msgid "The CHECK constraint is used to limit the value range that a column can store. CHECK constraints look like this:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:685
msgid "There is a shorthand: specifying CHECK in a :ref:`column definition <sql_column_def_constraint>`."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:687
msgid "The expression may be anything that returns a BOOLEAN result = TRUE or FALSE or UNKNOWN. |br| The expression may not contain a :ref:`subquery <sql_subquery>`. |br| If the expression contains a column name, the column must exist in the table. |br| If a CHECK constraint is specified, the table must not contain rows where the expression is FALSE. (The table may contain rows where the expression is either TRUE or UNKNOWN.) |br| Constraint checking may be stopped with :ref:`ALTER TABLE ... DISABLE CHECK CONSTRAINT <sql_alter_table>` and restarted with ALTER TABLE ... ENABLE CHECK CONSTRAINT."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:695
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:763
msgid "**Example**"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:697
msgid "Create an ``author`` table with the ``name`` column that should contain values longer than 4 characters:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:699
msgid "CREATE TABLE author (\n"
"    id INTEGER PRIMARY KEY,\n"
"    name STRING,\n"
"    CONSTRAINT check_name_length CHECK (CHAR_LENGTH(name) > 4)\n"
");\n"
""
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:713
msgid "On an attempt to add an author with a name shorter than 5 characters, the following error is raised:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:715
msgid "INSERT INTO author VALUES (3, 'Alex');\n"
"/*\n"
"- Check constraint 'CHECK_NAME_LENGTH' failed for tuple\n"
"*/\n"
""
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:726
msgid "Table constraint definition for foreign keys"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:728
msgid "A :ref:`foreign key <index-box_foreign_keys>` is a :ref:`constraint <index-constraints>` that can be used to enforce data integrity across related tables. A foreign key constraint is defined on the child table that references the parent table's column values."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:731
msgid "Foreign key constraints look like this:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:733
msgid "FOREIGN KEY (referencing_column_name, ...)\n"
"    REFERENCES referenced_table_name (referenced_column_name, ...)"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:738
msgid "You can also add a reference in a :ref:`column definition <sql_column_def_constraint>`:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:740
msgid "referencing_column_name column_definition\n"
"    REFERENCES referenced_table_name(referenced_column_name)"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:747
msgid "Since :doc:`2.11.0 </release/2.11.0>`, the following referencing options aren't supported anymore:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:749
msgid "The ``ON UPDATE`` and ``ON DELETE`` triggers. The ``RESTRICT`` trigger action is used implicitly."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:750
msgid "The ``MATCH`` subclause. ``MATCH FULL`` is used implicitly."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:751
msgid "``DEFERRABLE`` constraints. The ``INITIALLY IMMEDIATE`` constraint check time rule is used implicitly."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:753
msgid "Note that a referenced column should meet one of the following requirements:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:755
msgid "A referenced column is a PRIMARY KEY column."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:756
msgid "A referenced column has a UNIQUE constraint."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:757
msgid "A referenced column has a UNIQUE index."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:759
msgid "Note that before the :doc:`2.11.0 </release/2.11.0>` version, an index existence for the referenced columns is checked when creating a constraint (for example, using ``CREATE TABLE`` or ``ALTER TABLE``). Starting with 2.11.0, this check is weakened and the existence of an index is checked during data insertion."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:765
msgid "This example shows how to create a relation between the parent and child tables through a single-column foreign key:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:767
msgid "First, create a parent ``author`` table:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:783
msgid "Create a child ``book`` table whose ``author_id`` column references the ``id`` column from the ``author`` table:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:785
msgid "CREATE TABLE book (\n"
"    id INTEGER PRIMARY KEY,\n"
"    title STRING NOT NULL,\n"
"    author_id INTEGER NOT NULL UNIQUE,\n"
"    FOREIGN KEY (author_id)\n"
"        REFERENCES author (id)\n"
");\n"
""
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:791
msgid "Alternatively, you can add a reference in a column definition:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:793
msgid "CREATE TABLE book (\n"
"    id INTEGER PRIMARY KEY,\n"
"    title STRING NOT NULL,\n"
"    author_id INTEGER NOT NULL UNIQUE REFERENCES author(id)\n"
");"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:801
msgid "Insert data to the ``book`` table:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:809
msgid "Check how the created foreign key constraint enforces data integrity. The following error is raised on an attempt to insert a new book with the ``author_id`` value that doesn't exist in the parent ``author`` table:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:812
msgid "INSERT INTO book VALUES (3, 'Eugene Onegin', 3);\n"
"/*\n"
"- 'Foreign key constraint ''fk_unnamed_BOOK_1'' failed: foreign tuple was not found'\n"
"*/\n"
""
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:818
msgid "On an attempt to delete an author that already has books in the ``book`` table, the following error is raised:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:820
msgid "DELETE FROM author WHERE id = 2;\n"
"/*\n"
"- 'Foreign key ''fk_unnamed_BOOK_1'' integrity check failed: tuple is referenced'\n"
"*/\n"
""
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:831
msgid "DROP TABLE"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:835
msgid ":samp:`DROP TABLE [IF EXISTS] {table-name};`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:844
msgid "Drop a table."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:846
msgid "The *table-name* must identify a table that was created earlier with the :ref:`CREATE TABLE statement <sql_create_table>`."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:851
msgid "If there is a view that references the table, the drop will fail. Please drop the referencing view with :ref:`DROP VIEW <sql_drop_view>` first."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:853
msgid "If there is a foreign key that references the table, the drop will fail. Please drop the referencing constraint with :ref:`ALTER TABLE ... DROP <sql_alter_table_drop_constraint>` first."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:859
msgid "Tarantool returns an error if the table does not exist and there is no ``IF EXISTS`` clause."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:860
msgid "The table and all its data are dropped."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:861
msgid "All indexes for the table are dropped."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:862
msgid "All triggers for the table are dropped."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:867
msgid "-- the simple case:\n"
"DROP TABLE t31;\n"
"-- with an IF EXISTS clause:\n"
"DROP TABLE IF EXISTS t31;"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:874
msgid "See also: :ref:`DROP VIEW <sql_drop_view>`."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:880
msgid "CREATE VIEW"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:884
msgid ":samp:`CREATE VIEW [IF NOT EXISTS] {view-name} [(column-list)] AS subquery;`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:893
msgid "Create a new viewed table, usually called a \"view\"."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:895
msgid "The *view-name* must be valid according to the rules for identifiers."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:897
msgid "The optional *column-list* must be a comma-separated list of names of columns in the view."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:900
msgid "The syntax of the subquery must be the same as the syntax of a :ref:`SELECT statement <sql_select>`, or of a VALUES clause."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:906
msgid "There must not already be a base table or view with the same name as *view-name*."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:908
msgid "If *column-list* is specified, the number of columns in *column-list* must be the same as the number of columns in the :ref:`select list <sql_select_list>` of the subquery."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:913
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1011
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1143
msgid "Tarantool will throw an error if a rule is violated."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:914
msgid "Tarantool will create a new persistent object with *column-names* equal to the names in the *column-list* or the names in the subquery's *select list*."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:920
msgid "-- the simple case:\n"
"CREATE VIEW v AS SELECT column1, column2 FROM t;\n"
"-- with a column-list:\n"
"CREATE VIEW v (a,b) AS SELECT column1, column2 FROM t;"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:929
msgid "It is not possible to insert or update or delete from a view, although sometimes a possible substitution is to :ref:`create an INSTEAD OF trigger <sql_create_trigger>`."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:937
msgid "DROP VIEW"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:941
msgid ":samp:`DROP VIEW [IF EXISTS] {view-name};`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:950
msgid "Drop a view."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:952
msgid "The *view-name* must identify a view that was created earlier with the :ref:`CREATE VIEW statement <sql_create_view>`."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:955
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1074
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1445
msgid "Rules: none"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:959
msgid "Tarantool returns an error if the view does not exist and there is no ``IF EXISTS`` clause."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:960
msgid "The view is dropped."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:961
msgid "All triggers for the view are dropped."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:966
msgid "-- the simple case:\n"
"DROP VIEW v31;\n"
"-- with an IF EXISTS clause:\n"
"DROP VIEW IF EXISTS v31;"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:973
msgid "See also: :ref:`DROP TABLE <sql_drop_table>`."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:979
msgid "CREATE INDEX"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:983
msgid ":samp:`CREATE [UNIQUE] INDEX [IF NOT EXISTS] {index-name} ON {table-name} (column-list);`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:992
msgid "Create an index."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:994
msgid "The *index-name* must be valid according to the rules for identifiers."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:996
msgid "The *table-name* must refer to an existing table."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:998
msgid "The *column-list* must be a comma-separated list of names of columns in the table."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1003
msgid "There must not already be, for the same table, an index with the same name as *index-name*. But there may already be, for a different table, an index with the same name as *index-name*."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1007
msgid "The maximum number of indexes per table is 128."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1012
msgid "If the new index is UNIQUE, Tarantool will throw an error if any row exists with columns that have duplicate values."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1014
msgid "Tarantool will create a new index."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1017
msgid "Automatic indexes:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1019
msgid "Indexes may be created automatically for columns mentioned in the PRIMARY KEY or UNIQUE clauses of a CREATE TABLE statement. If an index was created automatically, then the *index-name* has four parts:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1023
msgid "``pk`` if this is for a PRIMARY KEY clause, ``unique`` if this is for a UNIQUE clause;"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1025
msgid "``_unnamed_``;"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1026
msgid "the name of the table;"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1027
msgid "``_`` and an ordinal number; the first index is 1, the second index is 2, and so on."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1030
msgid "For example, after ``CREATE TABLE t (s1 INTEGER PRIMARY KEY, s2 INTEGER, UNIQUE (s2));`` there are two indexes named ``pk_unnamed_T_1`` and ``unique_unnamed_T_2``. You can confirm this by saying ``SELECT * FROM \"_index\";`` which will list all indexes on all tables. There is no need to say ``CREATE INDEX`` for columns that already have automatic indexes."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1039
msgid "-- the simple case\n"
"CREATE INDEX idx_column1_t_1 ON t (column1);\n"
"-- with IF NOT EXISTS clause\n"
"CREATE INDEX IF NOT EXISTS idx_column1_t_1 ON t (column1);\n"
"-- with UNIQUE specifier and more than one column\n"
"CREATE UNIQUE INDEX idx_unnamed_t_1 ON t (column1, column2);"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1048
msgid "Dropping an automatic index created for a unique constraint will drop the unique constraint as well."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1055
msgid "DROP INDEX"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1059
msgid ":samp:`DROP INDEX [IF EXISTS] index-name ON {table-name};`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1068
msgid "The *index-name* must be the name of an existing index, which was created with :ref:`CREATE INDEX <sql_create_index>`. Or, the *index-name* must be the name of an index that was created automatically due to a PRIMARY KEY or UNIQUE clause in the :ref:`CREATE TABLE <sql_create_table>` statement. To see what a table's indexes are, use :ref:`PRAGMA index_list(table-name); <sql_pragma>`."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1078
msgid "Tarantool throws an error if the index does not exist, or is an automatically created index."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1080
msgid "Tarantool will drop the index."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1083
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1414
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1758
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2648
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2673
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2728
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3046
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3087
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3117
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3146
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3316
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3448
msgid "Example:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1085
msgid "-- the simplest form:\n"
"DROP INDEX idx_unnamed_t_1 ON t;"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1094
msgid "CREATE TRIGGER"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1098
msgid ":samp:`CREATE TRIGGER [IF NOT EXISTS] {trigger-name}` |br| :samp:`BEFORE|AFTER|INSTEAD OF` |br| :samp:`DELETE|INSERT|UPDATE ON {table-name}` |br| :samp:`FOR EACH ROW` |br| :samp:`[WHEN search-condition]` |br| :samp:`BEGIN` |br| :samp:`delete-statement | insert-statement | replace-statement | select-statement | update-statement;` |br| :samp:`[delete-statement | insert-statement | replace-statement | select-statement | update-statement; ...]` |br| :samp:`END;`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1115
msgid "The *trigger-name* must be valid according to the rules for identifiers."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1117
msgid "If the trigger action time is BEFORE or AFTER, then the *table-name* must refer to an existing base table."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1120
msgid "If the trigger action time is INSTEAD OF, then the *table-name* must refer to an existing view."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1125
msgid "There must not already be a trigger with the same name as *trigger-name*."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1126
msgid "Triggers on different tables or views share the same namespace."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1127
msgid "The statements between BEGIN and END should not refer to the *table-name* mentioned in the ON clause."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1129
msgid "The statements between BEGIN and END should not contain an :ref:`INDEXED BY <sql_indexed_by>` clause."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1132
msgid "SQL triggers are not activated by Tarantool/NoSQL requests. This will change in a future version."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1135
msgid "On a :ref:`replica <Replication>`, effects of trigger execution are applied, and the SQL triggers themselves are not activated upon replication events."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1138
msgid "NoSQL triggers are activated both on replica and master, thus if you have a :ref:`NoSQL trigger <triggers>` on a replica, it is activated when applying effects of an SQL trigger."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1144
msgid "Tarantool will create a new trigger."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1149
msgid "-- the simple case:\n"
"CREATE TRIGGER stores_before_insert BEFORE INSERT ON stores FOR EACH ROW\n"
"  BEGIN DELETE FROM warehouses; END;\n"
"-- with IF NOT EXISTS clause:\n"
"CREATE TRIGGER IF NOT EXISTS stores_before_insert BEFORE INSERT ON stores FOR EACH ROW\n"
"  BEGIN DELETE FROM warehouses; END;\n"
"-- with FOR EACH ROW and WHEN clauses:\n"
"CREATE TRIGGER stores_before_insert BEFORE INSERT ON stores FOR EACH ROW WHEN a=5\n"
"  BEGIN DELETE FROM warehouses; END;\n"
"-- with multiple statements between BEGIN and END:\n"
"CREATE TRIGGER stores_before_insert BEFORE INSERT ON stores FOR EACH ROW\n"
"  BEGIN DELETE FROM warehouses; INSERT INTO inventories VALUES (1); END;"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1168
msgid "Trigger extra clauses"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1170
msgid ":samp:`UPDATE OF column-list`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1172
msgid "After BEFORE|AFTER UPDATE it is optional to add ``OF column-list``. If any of the columns in *column-list* is affected at the time the row is processed, then the trigger will be activated for that row. For example:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1176
msgid "CREATE TRIGGER table1_before_update\n"
" BEFORE UPDATE  OF column1, column2 ON table1\n"
" FOR EACH ROW\n"
" BEGIN UPDATE table2 SET column1 = column1 + 1; END;\n"
"UPDATE table1 SET column3 = column3 + 1; -- Trigger will not be activated\n"
"UPDATE table1 SET column2 = column2 + 0; -- Trigger will be activated"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1185
msgid ":samp:`WHEN`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1187
msgid "After *table-name* FOR EACH ROW it is optional to add [``WHEN expression``]. If the expression is true at the time the row is processed, only then will the trigger will be activated for that row. For example:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1191
msgid "CREATE TRIGGER table1_before_update BEFORE UPDATE ON table1 FOR EACH ROW\n"
" WHEN (SELECT COUNT(*) FROM table1) > 1\n"
" BEGIN UPDATE table2 SET column1 = column1 + 1; END;"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1197
msgid "This trigger will not be activated unless there is more than one row in ``table1``."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1200
msgid ":samp:`OLD and NEW`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1202
msgid "The keywords OLD and NEW have special meaning in the context of trigger action:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1204
msgid "OLD.column-name refers to the value of *column-name* before the change."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1205
msgid "NEW.column-name refers to the value of *column-name* after the change."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1207
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2551
msgid "For example:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1209
msgid "CREATE TABLE table1 (column1 STRING, column2 INTEGER PRIMARY KEY);\n"
"CREATE TABLE table2 (column1 STRING, column2 STRING, column3 INTEGER PRIMARY KEY);\n"
"INSERT INTO table1 VALUES ('old value', 1);\n"
"INSERT INTO table2 VALUES ('', '', 1);\n"
"CREATE TRIGGER table1_before_update BEFORE UPDATE ON table1 FOR EACH ROW\n"
" BEGIN UPDATE table2 SET column1 = old.column1, column2 = new.column1; END;\n"
"UPDATE table1 SET column1 = 'new value';\n"
"SELECT * FROM table2;"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1220
msgid "At the beginning of the UPDATE for the single row of ``table1``, the value in ``column1`` is 'old value' -- so that is what is seen as ``old.column1``."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1223
msgid "At the end of the UPDATE for the single row of ``table1``, the value in ``column1`` is 'new value' -- so that is what is seen as ``new.column1``. (OLD and NEW are qualifiers for ``table1``, not ``table2.``)"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1227
msgid "Therefore, ``SELECT * FROM table2;`` returns ``['old value', 'new value']``."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1229
msgid "``OLD.column-name`` does not exist for an INSERT trigger."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1231
msgid "``NEW.column-name`` does not exist for a DELETE trigger."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1233
msgid "OLD and NEW are read-only; you cannot change their values."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1235
msgid "Deprecated or illegal statements:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1237
msgid "It is illegal for the trigger action to include a qualified column reference other than ``OLD.column-name`` or ``NEW.column-name``. For example, ``CREATE TRIGGER ... BEGIN UPDATE table1 SET table1.column1 = 5; END;`` is illegal."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1242
msgid "It is illegal for the trigger action to include statements that include a :ref:`WITH clause <sql_with>`, a DEFAULT VALUES clause, or an :ref:`INDEXED BY <sql_indexed_by>` clause."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1246
msgid "It is usually not a good idea to have a trigger on ``table1`` which causes a change on ``table2``, and at the same time have a trigger on ``table2`` which causes a change on ``table1``. For example:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1250
msgid "CREATE TRIGGER table1_before_update\n"
" BEFORE UPDATE ON table1\n"
" FOR EACH ROW\n"
" BEGIN UPDATE table2 SET column1 = column1 + 1; END;\n"
"CREATE TRIGGER table2_before_update\n"
" BEFORE UPDATE ON table2\n"
" FOR EACH ROW\n"
" BEGIN UPDATE table1 SET column1 = column1 + 1; END;"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1261
msgid "Luckily ``UPDATE table1 ...`` will not cause an infinite loop, because Tarantool recognizes when it has already updated so it will stop. However, not every DBMS acts this way."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1269
msgid "Trigger activation"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1271
msgid "These are remarks concerning trigger activation."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1273
msgid "Standard terminology:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1275
msgid "\"trigger action time\" = BEFORE or AFTER or INSTEAD OF"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1276
msgid "\"trigger event\" = INSERT or DELETE or UPDATE"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1277
msgid "\"triggered statement\" = BEGIN ... DELETE|INSERT|REPLACE|SELECT|UPDATE ... END"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1278
msgid "\"triggered when clause\" = WHEN search-condition"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1279
msgid "\"activate\" = execute a triggered statement"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1280
msgid "some vendors use the word \"fire\" instead of \"activate\""
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1282
msgid "If there is more than one trigger for the same trigger event, Tarantool may execute the triggers in any order."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1285
msgid "It is possible for a triggered statement to cause activation of another triggered statement. For example, this is legal:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1288
msgid "CREATE TRIGGER t1_before_delete BEFORE DELETE ON t1 FOR EACH ROW BEGIN DELETE FROM t2; END;\n"
"CREATE TRIGGER t2_before_delete BEFORE DELETE ON t2 FOR EACH ROW BEGIN DELETE FROM t3; END;"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1293
msgid "Activation occurs FOR EACH ROW, not FOR EACH STATEMENT. Therefore, if no rows are candidates for insert or update or delete, then no triggers are activated."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1296
msgid "The BEFORE trigger is activated even if the trigger event fails."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1298
msgid "If an UPDATE trigger event does not make a change, the trigger is activated anyway. For example, if row 1 ``column1`` contains ``'a'``, and the trigger event is ``UPDATE ... SET column1 = 'a';``, the trigger is activated."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1302
msgid "The triggered statement may refer to a function: ``RAISE(FAIL, error-message)``. If a triggered statement invokes a ``RAISE(FAIL, error-message)`` function, or if a triggered statement causes an error, then statement execution stops immediately."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1308
msgid "The triggered statement may refer to column values within the rows being changed. in this case:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1311
msgid "The row \"as of before\" the change is called the \"old\" row (which makes sense only for UPDATE and DELETE statements)."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1313
msgid "The row \"as of after\" the change is called the \"new\" row (which makes sense only for UPDATE and INSERT statements)."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1316
msgid "This example shows how an INSERT can be done to a view by referring to the \"new\" row:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1319
msgid "CREATE TABLE t (s1 INTEGER PRIMARY KEY, s2 INTEGER);\n"
"CREATE VIEW v AS SELECT s1, s2 FROM t;\n"
"CREATE TRIGGER v_instead_of INSTEAD OF INSERT ON v\n"
"  FOR EACH ROW\n"
"  BEGIN INSERT INTO t VALUES (new.s1, new.s2); END;\n"
"INSERT INTO v VALUES (1, 2);"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1328
msgid "Ordinarily saying ``INSERT INTO view_name ...`` is illegal in Tarantool, so this is a workaround."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1331
msgid "It is possible to generalize this so that all data-change statements on views will change the base tables, provided that the view contains all the columns of the base table, and provided that the triggers refer to those columns when necessary, as in this example:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1336
msgid "CREATE TABLE base_table (primary_key_column INTEGER PRIMARY KEY, value_column INTEGER);\n"
"CREATE VIEW viewed_table AS SELECT primary_key_column, value_column FROM base_table;\n"
"CREATE TRIGGER viewed_table_instead_of_insert INSTEAD OF INSERT ON viewed_table FOR EACH ROW\n"
"  BEGIN\n"
"    INSERT INTO base_table VALUES (new.primary_key_column, new.value_column); END;\n"
"CREATE TRIGGER viewed_table_instead_of_update INSTEAD OF UPDATE ON viewed_table FOR EACH ROW\n"
"  BEGIN\n"
"    UPDATE base_table\n"
"    SET primary_key_column = new.primary_key_column, value_column = new.value_column\n"
"    WHERE primary_key_column = old.primary_key_column; END;\n"
"CREATE TRIGGER viewed_table_instead_of_delete INSTEAD OF DELETE ON viewed_table FOR EACH ROW\n"
"  BEGIN\n"
"    DELETE FROM base_table WHERE primary_key_column = old.primary_key_column; END;"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1352
msgid "When INSERT or UPDATE or DELETE occurs for table ``X``, Tarantool usually operates in this order (a basic scheme):"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1355
msgid "For each row\n"
"  Perform constraint checks\n"
"  For each BEFORE trigger that refers to table X\n"
"    Check that the trigger's WHEN condition is true.\n"
"    Execute what is in the triggered statement.\n"
"  Insert or update or delete the row in table X.\n"
"  Perform more constraint checks\n"
"  For each AFTER trigger that refers to table X\n"
"    Check that the trigger's WHEN condition is true.\n"
"    Execute what is in the triggered statement."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1370
msgid "However, Tarantool does not guarantee execution order when there are multiple constraints, or multiple triggers for the same event (including NoSQL :ref:`on_replace triggers <box_space-on_replace>` or SQL :ref:`INSTEAD OF triggers <sql_instead_of_triggers>` that affect a view of table ``X``)."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1377
msgid "The maximum number of trigger activations per statement is 32."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1383
msgid "INSTEAD OF triggers"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1385
msgid "A trigger which is created with the clause |br| :samp:`INSTEAD OF {INSERT|UPDATE|DELETE} ON {view-name}` |br| is an INSTEAD OF trigger. For each affected row, the trigger action is performed \"instead of\" the INSERT or UPDATE or DELETE statement that causes trigger activation."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1391
msgid "For example, ordinarily it is illegal to INSERT rows in a view, but it is legal to create a trigger which intercepts attempts to INSERT, and puts rows in the underlying base table:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1395
msgid "CREATE TABLE t1 (column1 INTEGER PRIMARY KEY, column2 INTEGER);\n"
"CREATE VIEW v1 AS SELECT column1, column2 FROM t1;\n"
"CREATE TRIGGER v1_instead_of INSTEAD OF INSERT ON v1 FOR EACH ROW BEGIN\n"
" INSERT INTO t1 VALUES (NEW.column1, NEW.column2); END;\n"
"INSERT INTO v1 VALUES (1, 1);\n"
"-- ... The result will be: table t1 will contain a new row."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1404
msgid "INSTEAD OF triggers are only legal for views, while BEFORE or AFTER triggers are only legal for base tables."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1407
msgid "It is legal to create INSTEAD OF triggers with triggered WHEN clauses."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1411
msgid "It is legal to create INSTEAD OF triggers with UPDATE OF *column-list* clauses, but they are not standard SQL."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1416
msgid "CREATE TRIGGER ev1_instead_of_update\n"
"  INSTEAD OF UPDATE OF column2,column1 ON ev1\n"
"  FOR EACH ROW BEGIN\n"
"  INSERT INTO et2 VALUES (NEW.column1, NEW.column2); END;"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1427
msgid "DROP TRIGGER"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1431
msgid ":samp:`DROP TRIGGER [IF EXISTS] {trigger-name};`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1440
msgid "Drop a trigger."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1442
msgid "The *trigger-name* must identify a trigger that was created earlier with the :ref:`CREATE TRIGGER <sql_create_trigger>` statement."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1449
msgid "Tarantool returns an error if the trigger does not exist and there is no ``IF EXISTS`` clause."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1450
msgid "The trigger is dropped."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1455
msgid "-- the simple case:\n"
"DROP TRIGGER table1_before_insert;\n"
"-- with an IF EXISTS clause:\n"
"DROP TRIGGER IF EXISTS table1_before_insert;"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1466
msgid "Statements that change data"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1472
msgid "INSERT"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1476
msgid ":samp:`INSERT INTO {table-name} [(column-list)] VALUES (expression-list) [, (expression-list)];`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1477
msgid ":samp:`INSERT INTO {table-name} [(column-list)]  select-statement;`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1478
msgid ":samp:`INSERT INTO {table-name} DEFAULT VALUES;`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1487
msgid "Insert one or more new rows into a table."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1489
msgid "The *table-name* must be a name of a table defined earlier with :ref:`CREATE TABLE <sql_create_table>`."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1491
msgid "The optional *column-list* must be a comma-separated list of names of columns in the table."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1494
msgid "The *expression-list* must be a comma-separated list of expressions; each expression may contain literals and operators and subqueries and function invocations."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1499
msgid "The values in the *expression-list* are evaluated from left to right."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1500
msgid "The order of the values in the *expression-list* must correspond to the order of the columns in the table, or (if a *column-list* is specified) to the order of the columns in the *column-list*."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1503
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1572
msgid "The data type of the value should correspond to the :ref:`data type of the column <sql_column_def_data_type>`, that is, the data type that was specified with CREATE TABLE."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1506
msgid "If a *column-list* is not specified, then the number of expressions must be the same as the number of columns in the table."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1508
msgid "If a *column-list* is specified, then some columns may be omitted; omitted columns will get default values."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1510
msgid "The parenthesized *expression-list* may be repeated -- ``(expression-list),(expression-list),...`` -- for multiple rows."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1515
msgid "Tarantool evaluates each expression in *expression-list*, and returns an error if any of the rules is violated."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1517
msgid "Tarantool creates zero or more new rows containing values based on the values in the VALUES list or based on the results of the *select-expression* or based on the default values."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1520
msgid "Tarantool executes constraint checks and trigger actions and the actual insertion."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1526
msgid "-- the simplest form:\n"
"INSERT INTO table1 VALUES (1, 'A');\n"
"-- with a column list:\n"
"INSERT INTO table1 (column1, column2) VALUES (2, 'B');\n"
"-- with an arithmetic operator in the first expression:\n"
"INSERT INTO table1 VALUES (2 + 1, 'C');\n"
"-- put two rows in the table:\n"
"INSERT INTO table1 VALUES (4, 'D'), (5, 'E');"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1538
msgid "See also: :ref:`REPLACE statement <sql_replace>`."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1544
msgid "UPDATE"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1548
msgid ":samp:`UPDATE {table-name} SET column-name = expression [, column-name = expression ...] [WHERE search-condition];`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1559
msgid "Update zero or more existing rows in a table."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1561
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1638
msgid "The *table-name* must be a name of a table defined earlier with :ref:`CREATE TABLE <sql_create_table>` or :ref:`CREATE VIEW <sql_create_view>`."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1564
msgid "The *column-name* must be an updatable column in the table."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1566
msgid "The *expression* may contain literals and operators and subqueries and function invocations and column names."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1571
msgid "The values in the SET clause are evaluated from left to right."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1575
msgid "If a *search-condition* is not specified, then all rows in the table will be updated; otherwise only those rows which match the *search-condition* will be updated."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1581
msgid "Tarantool evaluates each expression in the SET clause, and returns an error if any of the rules is violated. For each row that is found by the WHERE clause, a temporary new row is formed based on the original contents and the modifications caused by the SET clause."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1585
msgid "Tarantool executes constraint checks and trigger actions and the actual update."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1591
msgid "-- the simplest form:\n"
"UPDATE t SET column1 = 1;\n"
"-- with more than one assignment in the SET clause:\n"
"UPDATE t SET column1 = 1, column2 = 2;\n"
"-- with a WHERE clause:\n"
"UPDATE t SET column1 = 5 WHERE column2 = 6;"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1600
msgid "Special cases:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1602
msgid "It is legal to say SET (list of columns) = (list of values). For example:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1604
msgid "UPDATE t SET (column1, column2, column3) = (1, 2, 3);"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1608
msgid "It is not legal to assign to a column more than once. For example:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1610
msgid "INSERT INTO t (column1) VALUES (0);\n"
"UPDATE t SET column1 = column1 + 1, column1 = column1 + 1;"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1615
msgid "The result is an error: \"duplicate column name\"."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1617
msgid "It is not legal to assign to a primary-key column."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1623
msgid "DELETE"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1627
msgid ":samp:`DELETE FROM {table-name} [WHERE search-condition];`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1636
msgid "Delete zero or more existing rows in a table."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1641
msgid "The *search-condition* may contain literals and operators and subqueries and function invocations and column names."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1646
msgid "If a search-condition is not specified, then all rows in the table will be deleted; otherwise only those rows which match the *search-condition* will be deleted."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1652
msgid "Tarantool evaluates each expression in the *search-condition*, and returns an error if any of the rules is violated."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1654
msgid "Tarantool finds the set of rows that are to be deleted."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1655
msgid "Tarantool executes constraint checks and trigger actions and the actual deletion."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1661
msgid "-- the simplest form:\n"
"DELETE FROM t;\n"
"-- with a WHERE clause:\n"
"DELETE FROM t WHERE column2 = 6;"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1672
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3721
msgid "REPLACE"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1676
msgid ":samp:`REPLACE INTO {table-name} [(column-list)] VALUES (expression-list) [, (expression-list)];`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1677
msgid ":samp:`REPLACE INTO {table-name} [(column-list)] select-statement;`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1678
msgid ":samp:`REPLACE INTO {table-name} DEFAULT VALUES;`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1687
msgid "Insert one or more new rows into a table, or update existing rows."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1689
msgid "If a row already exists (as determined by the primary key or any unique key), then the action is delete + insert, and the rules are the same as for a :ref:`DELETE statement <sql_delete>` followed by an :ref:`INSERT statement <sql_insert>`. Otherwise the action is insert, and the rules are the same as for the INSERT statement."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1697
msgid "-- the simplest form:\n"
"REPLACE INTO table1 VALUES (1, 'A');\n"
"-- with a column list:\n"
"REPLACE INTO table1 (column1, column2) VALUES (2, 'B');\n"
"-- with an arithmetic operator in the first expression:\n"
"REPLACE INTO table1 VALUES (2 + 1, 'C');\n"
"-- put two rows in the table:\n"
"REPLACE INTO table1 VALUES (4, 'D'), (5, 'E');"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1708
msgid "See also: :ref:`INSERT Statement <sql_insert>`, :ref:`UPDATE Statement <sql_update>`."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1717
msgid "TRUNCATE"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1721
msgid ":samp:`TRUNCATE TABLE {table-name};`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1730
msgid "Remove all rows in the table."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1732
msgid "TRUNCATE is considered to be a schema-change rather than a data-change statement, so it does not work within transactions (it cannot be :ref:`rolled back <sql_rollback>`)."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1738
msgid "It is illegal to truncate a table which is referenced by a foreign key."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1739
msgid "It is illegal to truncate a table which is also a system space, such as ``_space``."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1741
msgid "The table must be a base table rather than a view."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1745
msgid "All rows in the table are removed. Usually this is faster than :samp:`DELETE FROM {table-name};`."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1747
msgid "If the table has an autoincrement primary key, its :doc:`sequence </reference/reference_lua/box_schema_sequence/create_index>` is not reset to zero, but that may occur in a future Tarantool version."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1751
msgid "There is no effect for any triggers associated with the table."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1752
msgid "There is no effect on the counts for the ``ROW_COUNT()`` function."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1753
msgid "Only one action is written to the :ref:`write-ahead log <internals-wal>` (with :samp:`DELETE FROM {table-name};` there would be one action for each deleted row)."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1760
msgid "TRUNCATE TABLE t;"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1768
msgid "SET"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1772
msgid ":samp:`SET SESSION {setting-name} = {setting-value};`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1777
msgid "``SET SESSION`` is a shorthand way to update the :ref:`box.space._session_settings <box_space-session_settings>` temporary system space."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1782
msgid "``setting-name`` can have the following values:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1784
msgid "``\"sql_default_engine\"``"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1785
msgid "``\"sql_full_column_names\"``"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1786
msgid "``\"sql_full_metadata\"``"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1787
msgid "``\"sql_parser_debug\"``"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1788
msgid "``\"sql_recursive_triggers\"``"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1789
msgid "``\"sql_reverse_unordered_selects\"``"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1790
msgid "``\"sql_select_debug\"``"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1791
msgid "``\"sql_vdbe_debug\"``"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1792
msgid "``\"sql_defer_foreign_keys\"`` (removed in :doc:`2.11.0 </release/2.11.0>`)"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1793
msgid "``\"error_marshaling_enabled\"`` (removed in :doc:`2.10.0 </release/2.10.0>`)"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1795
msgid "The quote marks are necessary."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1797
msgid "If ``setting-name`` is ``\"sql_default_engine\"``, then ``setting-value`` can be either 'vinyl' or 'memtx'. Otherwise, ``setting-value`` can be either TRUE or FALSE."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1801
msgid "Example: ``SET SESSION \"sql_default_engine\" = 'vinyl';`` changes the default engine to 'vinyl' instead of 'memtx', and returns:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1805
msgid "---\n"
"- row_count: 1\n"
"..."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1811
msgid "It is functionally the same thing as an :ref:`UPDATE Statement <sql_update>`:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1813
msgid "UPDATE \"_session_settings\"\n"
"SET \"value\" = 'vinyl'\n"
"WHERE \"name\" = 'sql_default_engine';"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1823
msgid "Statements that retrieve data"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1829
msgid "SELECT"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1833
msgid ":samp:`SELECT [ALL|DISTINCT] select list [from clause] [where clause] [group-by clause] [having clause] [order-by clause];`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1847
msgid "Select zero or more rows."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1849
msgid "The clauses of the SELECT statement are discussed in the following five sections."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1855
msgid "Select list"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1859
msgid ":samp:`select-list-column [, select-list-column ...]`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1861
msgid "select-list-column:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1868
msgid "Define what will be in a result set; this is a clause in a :ref:`SELECT statement <sql_select>`."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1870
msgid "The *select list* is a comma-delimited list of expressions, or ``*`` (asterisk). An expression can have an alias provided with an ``[[AS] column-name]`` clause."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1873
msgid "The ``*`` \"asterisk\" shorthand is valid if and only if the SELECT statement also contains a :ref:`FROM clause <sql_from>` which specifies the table or tables (details about the FROM clause are in the next section). The simple form is ``*`` which means \"all columns\" -- for example, if the select is done for a table which contains three columns ``s1`` ``s2`` ``s3``, then ``SELECT * ...`` is equivalent to ``SELECT s1, s2, s3 ...``. The qualified form is ``table-name.*`` which means \"all columns in the specified table\", which again must be a result of the FROM clause -- for example, if the table is named ``table1``, then ``table1.*`` is equivalent to a list of the columns of ``table1``."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1885
msgid "The ``[[AS] column-name]`` clause determines the column name. The column name is useful for two reasons:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1888
msgid "in a tabular display, the column names are the headings"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1889
msgid "if the results of the SELECT are used when creating a new table (such as a view), then the column names in the new table will be the column names in the *select list*."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1893
msgid "If ``[[AS] column-name]`` is missing, and the expression is not simply the name of a column in the table, then Tarantool makes a name :samp:`COLUMN_{n}` where :samp:`{n}` is the number of the non-simple expression within the select list, for example ``SELECT 5.88, table1.x, 'b' COLLATE \"unicode_ci\" FROM table1;`` will cause the column names to be COLUMN_1, X, COLUMN_2. This is a behavior change since version :doc:`2.5.1 </release/2.5.1>`. In earlier versions, the name would be equal to the expression; see `Issue#3962 <https://github.com/tarantool/tarantool/issues/3962>`_. It is still legal to define tables with column names like ``COLUMN_1`` but not recommended."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1906
msgid "-- the simple form:\n"
"SELECT 5;\n"
"-- with multiple expressions including operators:\n"
"SELECT 1, 2 * 2, 'Three' || 'Four';\n"
"-- with [[AS] column-name] clause:\n"
"SELECT 5 AS column1;\n"
"-- * which must be eventually followed by a FROM clause:\n"
"SELECT * FROM table1;\n"
"-- as a list:\n"
"SELECT 1 AS a, 2 AS b, table1.* FROM table1;"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1923
msgid "FROM clause"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1927
msgid ":samp:`FROM [SEQSCAN] table-reference [, table-reference ...]`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1936
msgid "Specify the table or tables for the source of a :ref:`SELECT statement <sql_select>`."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1938
msgid "The *table-reference* must be a name of an existing table, or a subquery, or a joined table."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1941
msgid "A joined table looks like this:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1943
msgid ":samp:`table-reference-or-joined-table join-operator table-reference-or-joined-table [join-specification]`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1945
msgid "A *join-operator* must be any of `the standard types <https://en.wikipedia.org/wiki/Join_(SQL)>`_:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1948
msgid "[NATURAL] LEFT [OUTER] JOIN,"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1949
msgid "[NATURAL] INNER JOIN, or"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1950
msgid "CROSS JOIN"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1952
msgid "A *join-specification* must be any of:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1954
msgid "ON expression, or"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1955
msgid "USING (column-name [, column-name ...])"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1957
msgid "Parentheses are allowed, and ``[[AS] correlation-name]`` is allowed."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1959
msgid "The maximum number of joins in a FROM clause is 64."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1961
msgid "The ``SEQSCAN`` keyword (since :doc:`2.11 </release/2.11.0>`) marks the queries that perform sequential scans during the execution. It happens if the query can't use indexes, and goes through all the table rows one by one, sometimes causing a heavy load. Such queries are called *scan queries*. If a scan query doesn't have the ``SEQSCAN`` keyword, Tarantool raises an error. ``SEQSCAN`` must precede all names of the tables that the query scans."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1968
msgid "To find out if a query performs a sequential scan, use ``EXPLAIN QUERY PLAN``. For scan queries, the result contains ``SCAN TABLE table_name``."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1973
msgid "For backward compatibility, the scan queries without the ``SEQSCAN`` keyword are allowed in Tarantool 2.11. The errors on scan queries are the default behavior starting from 3.0. You can change the default behavior of scan queries using the :ref:`compat option sql_seq_scan <compat-option-sql-scan>`."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1980
msgid "-- the simplest form:\n"
"SELECT * FROM SEQSCAN t;\n"
"-- with two tables, making a Cartesian join:\n"
"SELECT * FROM SEQSCAN t1, SEQSCAN t2;\n"
"-- with one table joined to itself, requiring correlation names:\n"
"SELECT a.*, b.* FROM SEQSCAN t1 AS a, SEQSCAN t1 AS b;\n"
"-- with a left outer join:\n"
"SELECT * FROM SEQSCAN t1 LEFT JOIN SEQSCAN t2;"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1995
msgid "WHERE clause"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:1999
msgid ":samp:`WHERE condition;`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2008
msgid "Specify the condition for filtering rows from a table; this is a clause in a :ref:`SELECT <sql_select>` or :ref:`UPDATE <sql_update>` or :ref:`DELETE <sql_delete>` statement."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2011
msgid "The condition may contain any expression that returns a BOOLEAN (TRUE or FALSE or UNKNOWN) value."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2014
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2220
msgid "For each row in the table:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2016
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2222
msgid "if the condition is true, then the row is kept;"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2017
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2223
msgid "if the condition is false or unknown, then the row is ignored."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2019
msgid "In effect, WHERE condition takes a table with n rows and returns a table with n or fewer rows."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2024
msgid "-- with a simple condition:\n"
"SELECT 1 FROM t WHERE column1 = 5;\n"
"-- with a condition that contains AND and OR and parentheses:\n"
"SELECT 1 FROM t WHERE column1 = 5 AND (x > 1 OR y < 1);"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2035
msgid "GROUP BY clause"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2039
msgid ":samp:`GROUP BY expression [, expression ...]`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2048
msgid "Make a grouped table; this is a clause in a :ref:`SELECT statement <sql_select>`."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2050
msgid "The expressions should be column names in the table, and each column should be specified only once."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2053
msgid "In effect, the GROUP BY clause takes a table with rows that may have matching values, combines rows that have matching values into single rows, and returns a table which, because it is the result of GROUP BY, is called a grouped table."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2058
msgid "Thus, if the input is a table:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2060
msgid "a    b      c\n"
"-    -      -\n"
"1    'a'   'b\n"
"1    'b'   'b'\n"
"2    'a'   'b'\n"
"3    'a'   'b'\n"
"1    'b'   'b'"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2070
msgid "then ``GROUP BY a, b`` will produce a grouped table:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2072
msgid "a    b      c\n"
"-    -      -\n"
"1    'a'   'b'\n"
"1    'b'   'b'\n"
"2    'a'   'b'\n"
"3    'a'   'b'"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2081
msgid "The rows where column ``a`` and column ``b`` have the same value have been merged; column ``c`` has been preserved but its value should not be depended on -- if the rows were not all 'b', Tarantool could pick any value."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2085
msgid "It is useful to envisage a grouped table as having hidden extra columns for the aggregation of the values, for example:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2088
msgid "a    b      c    COUNT(a) SUM(a) MIN(c)\n"
"-    -      -    -------- ------ ------\n"
"1    'a'    'b'         2      2    'b'\n"
"1    'b'    'b'         1      1    'b'\n"
"2    'a'    'b'         1      2    'b'\n"
"     'a'    'b'         1      3    'b'"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2097
msgid "These extra columns are what :ref:`aggregate functions <sql_aggregate>` are for."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2101
msgid "-- with a single column:\n"
"SELECT 1 FROM t GROUP BY column1;\n"
"-- with two columns:\n"
"SELECT 1 FROM t GROUP BY column1, column2;"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2110
msgid "``SELECT s1, s2 FROM t GROUP BY s1;`` is legal."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2111
msgid "``SELECT s1 AS q FROM t GROUP BY q;`` is legal."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2112
msgid "``SELECT s1 FROM t GROUP by 1;`` is legal."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2120
msgid "Aggregate functions"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2124
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3218
msgid ":samp:`function-name (one or more expressions)`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2126
msgid "Apply a built-in aggregate function to one or more expressions and return a scalar value."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2129
msgid "Aggregate functions are only legal in certain clauses of a :ref:`SELECT statement <sql_select>` for grouped tables. (A table is a grouped table if a GROUP BY clause is present.) Also, if an aggregate function is used in a :ref:`select list <sql_select_list>` and the GROUP BY clause is omitted, then Tarantool assumes ``SELECT ... GROUP BY [all columns];``."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2136
msgid "NULLs are ignored for all aggregate functions except COUNT(*)."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2143
msgid "``AVG([DISTINCT] expression)``"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2141
msgid "Return the average value of expression."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2143
msgid "Example: :samp:`AVG({column1})`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2150
msgid "``COUNT([DISTINCT] expression)``"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2148
msgid "Return the number of occurrences of expression."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2150
msgid "Example: :samp:`COUNT({column1})`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2155
msgid "``COUNT(*)``"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2153
msgid "Return the number of occurrences of a row."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2155
msgid "Example: :samp:`COUNT(*)`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2162
msgid "``GROUP_CONCAT(expression-1 [, expression-2])`` or ``GROUP_CONCAT(DISTINCT expression-1)``"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2158
msgid "Return a list of *expression-1* values, separated by commas if *expression-2* is omitted, or separated by the *expression-2* value if *expression-2* is not omitted."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2162
msgid "Example: :samp:`GROUP_CONCAT({column1})`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2169
msgid "``MAX([DISTINCT] expression)``"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2167
msgid "Return the maximum value of expression."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2169
msgid "Example: :samp:`MAX({column1})`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2176
msgid "``MIN([DISTINCT] expression)``"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2174
msgid "Return the minimum value of expression."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2176
msgid "Example: :samp:`MIN({column1})`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2183
msgid "``SUM([DISTINCT] expression)``"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2181
msgid "Return the sum of values of expression, or NULL if there are no rows."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2183
msgid "Example: :samp:`SUM({column1})`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2188
msgid "``TOTAL([DISTINCT] expression)``"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2186
msgid "Return the sum of values of expression, or zero if there are no rows."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2188
msgid "Example: :samp:`TOTAL({column1})`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2196
msgid "HAVING clause"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2200
msgid ":samp:`HAVING condition;`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2209
msgid "Specify the condition for filtering rows from a grouped table; this is a clause in a :ref:`SELECT statement <sql_select>`."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2212
msgid "The clause preceding the HAVING clause may be a GROUP BY clause. HAVING operates on the table that the GROUP BY produces, which may contain grouped columns and aggregates."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2216
msgid "If the preceding clause is not a GROUP BY clause, then there is only one group and the HAVING clause may only contain aggregate functions or literals."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2225
msgid "In effect, HAVING condition takes a table with n rows and returns a table with n or fewer rows."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2230
msgid "-- with a simple condition:\n"
"SELECT 1 FROM t GROUP BY column1 HAVING column2 > 5;\n"
"-- with a more complicated condition:\n"
"SELECT 1 FROM t GROUP BY column1 HAVING column2 > 5 OR column2 < 5;\n"
"-- with an aggregate:\n"
"SELECT x, SUM(y) FROM t GROUP BY x HAVING SUM(y) > 0;\n"
"-- with no GROUP BY and an aggregate:\n"
"SELECT SUM(y) FROM t GROUP BY x HAVING MIN(y) < MAX(y);"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2243
msgid "HAVING without GROUP BY is not supported for multiple tables."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2249
msgid "ORDER BY clause"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2253
msgid ":samp:`ORDER BY expression [ASC|DESC] [, expression [ASC|DESC] ...]`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2262
msgid "Put rows in order; this is a clause in a :ref:`SELECT statement <sql_select>`."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2264
msgid "An ORDER BY expression has one of three types which are checked in order:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2266
msgid "Expression is a positive integer, representing the ordinal position of the column in the :ref:`select list <sql_select_list>`. For example, in the statement |br| ``SELECT x, y, z FROM t ORDER BY 2;`` |br| ``ORDER BY 2`` means \"order by the second column in the select list\", which is ``y``."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2271
msgid "Expression is a name of a column in the select list, which is determined by an AS clause. For example, in the statement |br| ``SELECT x, y AS x, z FROM t ORDER BY x;`` |br| ``ORDER BY x`` means \"order by the column explicitly named ``x`` in the select list\", which is the second column."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2276
msgid "Expression contains a name of a column in a table of the FROM clause. For example, in the statement |br| ``SELECT x, y FROM t1 JOIN t2 ORDER BY z;`` |br| ``ORDER BY z`` means \"order by a column named ``z`` which is expected to be in table ``t1`` or table ``t2``\"."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2282
msgid "If both tables contain a column named ``z``, then Tarantool will choose the first column that it finds."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2285
msgid "The expression may also contain operators and function names and literals. For example, in the statement |br| ``SELECT x, y FROM t ORDER BY UPPER(z);`` |br| ``ORDER BY UPPER(z)`` means \"order by the uppercase form of column ``t.z``\", which may be similar to doing ordering with one of Tarantool's case-insensitive collations."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2291
msgid "Type 3 is illegal if the SELECT statement contains :ref:`UNION or EXCEPT or INTERSECT <sql_union>`."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2294
msgid "If an ORDER BY clause contains multiple expressions, then expressions on the left are processed first and expressions on the right are processed only if necessary for tie-breaking. For example, in the statement |br| ``SELECT x, y FROM t ORDER BY x, y;`` if there are two rows which both have the same values for column ``x``, then an additional check is made to see which row has a greater value for column ``y``."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2303
msgid "In effect, ORDER BY clause takes a table with rows that may be out of order, and returns a table with rows in order."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2306
msgid "Sorting order:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2308
msgid "The default order is ASC (ascending), the optional order is DESC (descending)."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2309
msgid "NULLs come first, then BOOLEANs, then numerics, then STRINGs, then VARBINARYs, then UUIDs."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2310
msgid "Ordering does not matter for ARRAYs or MAPs or ANYs because they are not legal for comparisons."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2311
msgid "Within STRINGs, ordering is according to collation."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2312
msgid "Collation may be specified with a :ref:`COLLATE clause <sql_collate_clause>` within the ORDER BY column-list, or may be default."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2316
msgid "-- with a single column:\n"
"SELECT 1 FROM t ORDER BY column1;\n"
"-- with two columns:\n"
"SELECT 1 FROM t ORDER BY column1, column2;\n"
"-- with a variety of data:\n"
"CREATE TABLE h (s1 NUMBER PRIMARY KEY, s2 SCALAR);\n"
"INSERT INTO h VALUES (7, 'A'), (4, 'a'), (-4, 'AZ'), (17, 17), (23, NULL);\n"
"INSERT INTO h VALUES (17.5, 'Д'), (1e+300, 'A'), (0, ''), (-1, '');\n"
"SELECT * FROM h ORDER BY s2 COLLATE \"unicode_ci\", s1;\n"
"-- The result of the above SELECT will be:\n"
"- - [23, null]\n"
"  - [17, 17]\n"
"  - [-1, '']\n"
"  - [0, '']\n"
"  - [4, 'a']\n"
"  - [7, 'A']\n"
"  - [1e+300, 'A']\n"
"  - [-4, 'AZ']\n"
"  - [17.5, 'Д']\n"
"..."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2341
msgid "ORDER BY 1 is legal. This is common but is not standard SQL nowadays."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2349
msgid "LIMIT clause"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2353
msgid ":samp:`LIMIT limit-expression [OFFSET offset-expression]`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2354
msgid ":samp:`LIMIT offset-expression, limit-expression`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2358
msgid "The above is not a typo: *offset-expression* and *limit-expression* are in reverse order if a comma is used."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2368
msgid "Specify a maximum number of rows and a start row; this is a clause in a :ref:`SELECT statement <sql_select>`."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2371
msgid "Expressions may contain integers and arithmetic operators or functions, for example ``ABS(-3 / 1)``. However, the result must be an integer value greater than or equal to zero."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2375
msgid "Usually the LIMIT clause follows an :ref:`ORDER BY clause <sql_order_by>`, because otherwise Tarantool does not guarantee that rows are in order."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2380
msgid "-- simple case:\n"
"SELECT * FROM t LIMIT 3;\n"
"-- both limit and order:\n"
"SELECT * FROM t LIMIT 3 OFFSET 1;\n"
"-- applied to a UNIONed result (LIMIT clause must be the final clause):\n"
"SELECT column1 FROM table1 UNION SELECT column1 FROM table2 ORDER BY 1 LIMIT 1;"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2391
msgid "If ORDER BY ... LIMIT is used, then all order-by columns must be ASC or all must be DESC."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2400
msgid "Subquery"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2404
msgid ":ref:`SELECT-statement <sql_select>` syntax"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2405
msgid ":ref:`VALUES-statement <sql_values>` syntax"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2407
msgid "A subquery has the same syntax as a :ref:`SELECT statement <sql_select>` or :ref:`VALUES statement <sql_values>` embedded inside a main statement."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2413
msgid "The SELECT and VALUES statements are called \"queries\" because they return answers, in the form of result sets."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2416
msgid "Subqueries may be the second part of :ref:`INSERT statements <sql_insert>`. For example:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2418
msgid "INSERT INTO t2 SELECT a, b, c FROM t1;"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2422
msgid "Subqueries may be in the :ref:`FROM clause <sql_from>` of SELECT statements."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2424
msgid "Subqueries may be expressions, or be inside expressions. In this case they must be parenthesized, and usually the number of rows must be 1. For example:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2428
msgid "SELECT 1, (SELECT 5), 3 FROM t WHERE c1 * (SELECT COUNT(*) FROM t2) > 5;"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2432
msgid "Subqueries may be expressions on the right side of certain comparison operators, and in this unusual case the number of rows may be greater than 1. The comparison operators are: [NOT] EXISTS and [NOT] IN. For example:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2436
msgid "DELETE FROM t WHERE s1 NOT IN (SELECT s2 FROM t);"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2440
msgid "Subqueries may refer to values in the outer query. In this case, the subquery is called a \"correlated subquery\"."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2443
msgid "Subqueries may refer to rows which are being updated or deleted by the main query. In that case, the subquery finds the matching rows first, before starting to update or delete. For example, after:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2447
msgid "CREATE TABLE t (s1 INTEGER PRIMARY KEY, s2 INTEGER);\n"
"INSERT INTO t VALUES (1, 3), (2, 1);\n"
"DELETE FROM t WHERE s2 NOT IN (SELECT s1 FROM t);"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2453
msgid "only one of the rows is deleted, not both rows."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2459
msgid "WITH clause"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2461
msgid "**WITH clause (common table expression)**"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2465
msgid ":samp:`WITH {temporary-table-name} AS (subquery)` |br| :samp:`[, {temporary-table-name} AS (subquery)]` |br| :samp:`SELECT statement | INSERT statement | DELETE statement | UPDATE statement | REPLACE statement;`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2476
msgid "WITH v AS (SELECT * FROM t) SELECT * FROM v;"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2480
msgid "is equivalent to :ref:`creating a view <sql_create_view>` and selecting from it:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2482
msgid "CREATE VIEW v AS SELECT * FROM t;\n"
"SELECT * FROM v;"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2487
msgid "The difference is that a WITH-clause \"view\" is temporary and only useful within the same statement. No CREATE privilege is required."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2490
msgid "The WITH-clause can also be thought of as a :ref:`subquery <sql_subquery>` that has a name. This is useful when the same subquery is being repeated. For example:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2493
msgid "SELECT * FROM t WHERE a < (SELECT s1 FROM x) AND b < (SELECT s1 FROM x);"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2497
msgid "can be replaced with:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2499
msgid "WITH s AS (SELECT s1 FROM x) SELECT * FROM t,s WHERE a < s.s1 AND b < s.s1;"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2503
msgid "This \"factoring out\" of a repeated expression is regarded as good practice."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2507
msgid "WITH cte AS (VALUES (7, '') INSERT INTO j SELECT * FROM cte;\n"
"WITH cte AS (SELECT s1 AS x FROM k) SELECT * FROM cte;\n"
"WITH cte AS (SELECT COUNT(*) FROM k WHERE s2 < 'x' GROUP BY s3)\n"
"  UPDATE j SET s2 = 5\n"
"  WHERE s1 = (SELECT s1 FROM cte) OR s3 = (SELECT s1 FROM cte);"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2515
msgid "WITH can only be used at the beginning of a statement, therefore it cannot be used at the beginning of a subquery or after a :ref:`set operator <sql_union>` or inside a CREATE statement."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2519
msgid "A WITH-clause \"view\" is read-only because Tarantool does not support updatable views."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2526
msgid "WITH RECURSIVE"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2528
msgid "**WITH RECURSIVE clause (iterative common table expression)**"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2530
msgid "The real power of WITH lies in the WITH RECURSIVE clause, which is useful when it is combined with :ref:`UNION or UNION ALL <sql_union>`:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2533
msgid ":samp:`WITH RECURSIVE recursive-table-name AS` |br| :samp:`(SELECT ... FROM non-recursive-table-name ...` |br| :samp:`UNION [ALL]` |br| :samp:`SELECT ... FROM recursive-table-name ...)` |br| :samp:`statement-that-uses-recursive-table-name;` |br|"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2546
msgid "In non-SQL this can be read as: starting with a seed value from a non-recursive table, produce a recursive viewed table, UNION that with itself, UNION that with itself, UNION that with itself ... forever, or until a condition in the WHERE clause says \"stop\"."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2553
msgid "CREATE TABLE ts (s1 INTEGER PRIMARY KEY);\n"
"INSERT INTO ts VALUES (1);\n"
"WITH RECURSIVE w AS (\n"
"  SELECT s1 FROM ts\n"
"  UNION ALL\n"
"  SELECT s1 + 1 FROM w WHERE s1 < 4)\n"
"SELECT * FROM w;"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2563
msgid "First, table ``w`` is seeded from ``t1``, so it has one row: [1]."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2565
msgid "Then, ``UNION ALL (SELECT s1 + 1 FROM w)`` takes the row from ``w`` -- which contains [1] -- adds 1 because the select list says \"s1+1\", and so it has one row: [2]."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2569
msgid "Then, ``UNION ALL (SELECT s1 + 1 FROM w)`` takes the row from ``w`` -- which contains [2] -- adds 1 because the select list says \"s1+1\", and so it has one row: [3]."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2573
msgid "Then, ``UNION ALL (SELECT s1 + 1 FROM w)`` takes the row from ``w`` -- which contains [3] -- adds 1 because the select list says \"s1+1\", and so it has one row: [4]."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2577
msgid "Then, ``UNION ALL (SELECT s1 + 1 FROM w)`` takes the row from ``w`` -- which contains [4] -- and now the importance of the WHERE clause becomes evident, because \"s1 < 4\" is false for this row, and therefore the \"stop\" condition has been reached."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2582
msgid "So, before the \"stop\", table ``w`` got 4 rows -- [1], [2], [3], [4] -- and the result of the statement looks like:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2585
msgid "tarantool> WITH RECURSIVE w AS (\n"
"         >   SELECT s1 FROM ts\n"
"         >   UNION ALL\n"
"         >   SELECT s1 + 1 FROM w WHERE s1 < 4)\n"
"         > SELECT * FROM w;\n"
"---\n"
"- - [1]\n"
"  - [2]\n"
"  - [3]\n"
"  - [4]\n"
"..."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2599
msgid "In other words, this ``WITH RECURSIVE ... SELECT`` produces a table of auto-incrementing values."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2606
msgid "UNION, EXCEPT, and INTERSECT clauses"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2610
msgid ":samp:`select-statement UNION [ALL] select-statement [ORDER BY clause] [LIMIT clause];`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2611
msgid ":samp:`select-statement EXCEPT select-statement [ORDER BY clause] [LIMIT clause];`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2612
msgid ":samp:`select-statement INTERSECT select-statement [ORDER BY clause] [LIMIT clause];`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2631
msgid "UNION, EXCEPT, and INTERSECT are collectively called \"set operators\" or \"table operators\". In particular:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2634
msgid "``a UNION b`` means \"take rows which occur in a OR b\"."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2635
msgid "``a EXCEPT b`` means \"take rows which occur in a AND NOT b\"."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2636
msgid "``a INTERSECT b`` means \"take rows which occur in a AND b\"."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2638
msgid "Duplicate rows are eliminated unless ALL is specified."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2640
msgid "The *select-statements* may be chained: ``SELECT ... SELECT ... SELECT ...;``"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2642
msgid "Each *select-statement* must result in the same number of columns."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2644
msgid "The *select-statements* may be replaced with :ref:`VALUES statements <sql_values>`."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2646
msgid "The maximum number of set operations is 50."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2650
msgid "CREATE TABLE t1 (s1 INTEGER PRIMARY KEY, s2 STRING);\n"
"CREATE TABLE t2 (s1 INTEGER PRIMARY KEY, s2 STRING);\n"
"INSERT INTO t1 VALUES (1, 'A'), (2, 'B'), (3, NULL);\n"
"INSERT INTO t2 VALUES (1, 'A'), (2, 'C'), (3,NULL);\n"
"SELECT s2 FROM t1 UNION SELECT s2 FROM t2;\n"
"SELECT s2 FROM t1 UNION ALL SELECT s2 FROM t2 ORDER BY s2;\n"
"SELECT s2 FROM t1 EXCEPT SELECT s2 FROM t2;\n"
"SELECT s2 FROM t1 INTERSECT SELECT s2 FROM t2;"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2661
msgid "In this example:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2663
msgid "The UNION query returns 4 rows: NULL, 'A', 'B', 'C'."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2664
msgid "The UNION ALL query returns 6 rows: NULL, NULL, 'A', 'A', 'B', 'C'."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2665
msgid "The EXCEPT query returns 1 row: 'B'."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2666
msgid "The INTERSECT query returns 2 rows: NULL, 'A'."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2670
msgid "Parentheses are not allowed."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2671
msgid "Evaluation is left to right, INTERSECT does not have precedence."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2675
msgid "CREATE TABLE t01 (s1 INTEGER PRIMARY KEY, s2 STRING);\n"
"CREATE TABLE t02 (s1 INTEGER PRIMARY KEY, s2 STRING);\n"
"CREATE TABLE t03 (s1 INTEGER PRIMARY KEY, s2 STRING);\n"
"INSERT INTO t01 VALUES (1, 'A');\n"
"INSERT INTO t02 VALUES (1, 'B');\n"
"INSERT INTO t03 VALUES (1, 'A');\n"
"SELECT s2 FROM t01 INTERSECT SELECT s2 FROM t03 UNION SELECT s2 FROM t02;\n"
"SELECT s2 FROM t03 UNION SELECT s2 FROM t02 INTERSECT SELECT s2 FROM t03;\n"
"-- ... results are different."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2691
msgid "INDEXED BY clause"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2695
msgid ":samp:`INDEXED BY {index-name}`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2704
msgid "The INDEXED BY clause may be used in a :ref:`SELECT <sql_select>`, :ref:`DELETE <sql_delete>`, or :ref:`UPDATE <sql_update>` statement, immediately after the *table-name*. For example:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2708
msgid "DELETE FROM table7 INDEXED BY index7 WHERE column1 = 'a';"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2712
msgid "In this case the search for 'a' will take place within ``index7``. For example:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2714
msgid "SELECT * FROM table7 NOT INDEXED WHERE column1 = 'a';"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2718
msgid "In this case the search for 'a' will be done via a search of the whole table, what is sometimes called a \"full table scan\", even if there is an index for ``column1``."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2722
msgid "Ordinarily Tarantool chooses the appropriate index or lookup method depending on a complex set of \"optimizer\" rules; the INDEXED BY clause overrides the optimizer choice. If the index was defined with the :ref:`exclude_null <key_part_exclude_null>` parts option, it will only be used if the user specifies it."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2730
msgid "Suppose a table has two columns:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2732
msgid "The first column is the primary key and therefore it has an automatic index named ``pk_unnamed_T_1``."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2734
msgid "The second column has an index created by the user."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2736
msgid "The user selects with ``INDEXED BY the-index-on-column1``, then selects with ``INDEXED BY the-index-on-column-2``."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2739
msgid "CREATE TABLE t (column1 INTEGER PRIMARY KEY, column2 INTEGER);\n"
"CREATE INDEX idx_column2_t_1 ON t (column2);\n"
"INSERT INTO t VALUES (1, 2), (2, 1);\n"
"SELECT * FROM t INDEXED BY \"pk_unnamed_T_1\";\n"
"SELECT * FROM t INDEXED BY idx_column2_t_1;\n"
"-- Result for the first select: (1, 2), (2, 1)\n"
"-- Result for the second select: (2, 1), (1, 2)."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2749
msgid "Limitations: |br| Often INDEXED BY has no effect. |br| Often INDEXED BY affects a choice of covering index, but not a WHERE clause."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2757
msgid "VALUES"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2761
msgid ":samp:`VALUES (expression [, expression ...]) [, (expression [, expression ...])`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2770
msgid "Select one or more rows."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2772
msgid "VALUES has the same effect as :ref:`SELECT <sql_select>`, that is, it returns a result set, but VALUES statements may not have FROM or GROUP or ORDER BY or LIMIT clauses."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2775
msgid "VALUES may be used wherever SELECT may be used, for example in :ref:`subqueries <sql_subquery>`."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2779
msgid "-- simple case:\n"
"VALUES (1);\n"
"-- equivalent to SELECT 1, 2, 3:\n"
"VALUES (1, 2, 3);\n"
"-- two rows:\n"
"VALUES (1, 2, 3), (4, 5, 6);"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2793
msgid "PRAGMA"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2797
msgid ":samp:`PRAGMA {pragma-name} (pragma-value);`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2798
msgid "or :samp:`PRAGMA {pragma-name};`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2803
msgid "PRAGMA statements will give rudimentary information about database 'metadata' or server performance, although it is better to get metadata via :ref:`system tables <sql_system_tables>`."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2807
msgid "For PRAGMA statements that include (``pragma-value``), pragma values are strings and can be specified inside ``\"\"`` double quotes, or without quotes. When a string is used for searching, results must match according to a binary collation. If the object being searched has a lower-case name, use double quotes."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2814
msgid "In an earlier version, there were some PRAGMA statements that determined behavior. Now that does not happen. Behavior change is done by updating the :ref:`box.space._session_settings <box_space-session_settings>` system table."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2824
msgid "Pragma"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2825
msgid "Parameter"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2826
msgid "Effect"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2827
msgid "foreign_key_list"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2828
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2866
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2885
msgid "string |br| table-name"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2829
msgid "Return a :ref:`result set <box-sql_result_sets>` with one row for each foreign key of \"table-name\". Each row contains: |br| (INTEGER) id -- identification number |br| (INTEGER) seq -- sequential number |br| (STRING) table -- name of table |br| (STRING) from  -- referencing key |br| (STRING) to -- referenced key |br| (STRING) on_update -- ON UPDATE clause |br| (STRING) on_delete -- ON DELETE clause |br| (STRING) match -- MATCH clause |br| The system table is ``\"_fk_constraint\"``."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2842
msgid "collation_list"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2844
msgid "Return a result set with one row for each supported collation. The first four collations are ``'none'`` and ``'unicode'`` and ``'unicode_ci'`` and ``'binary'``, then come about 270 predefined collations, the exact count may vary because users can add their own collations. |br| The system table is ``\"_collation\"``."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2852
msgid "index_info"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2853
msgid "string |br| table-name . index-name"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2854
msgid "Return a result set with one row for each column in \"table-name.index-name\". Each row contains: |br| (INTEGER) seqno -- the column's ordinal position in the index (first column is 0) |br| (INTEGER) cid -- the column's ordinal position in the table (first column is 0) |br| (STRING) name -- name of the column |br| (INTEGER) desc -- 0 is ASC, 1 is DESC |br| (STRING) collation name |br| (STRING) type -- data type"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2865
msgid "index_list"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2867
msgid "Return a result set with one row for each index of \"table-name\". Each row contains: |br| (INTEGER) seq -- sequential number |br| (STRING) name -- index name |br| (INTEGER) unique -- whether the index is unique, 0 is false, 1 is true |br| The system table is ``\"_index\"``."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2875
msgid "stats"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2877
msgid "Return a result set with one row for each index of each table. Each row contains: |br| (STRING) table -- name of the table |br| (STRING) index -- name of the index |br| (INTEGER) width -- arbitrary information |br| (INTEGER) height -- arbitrary information"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2884
msgid "table_info"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2886
msgid "Return a result set with one row for each column in \"table-name\". Each row contains: |br| (INTEGER) cid -- ordinal position in the table |br| (first column number is 0) |br| (STRING) name -- column name |br| (STRING) type |br| (INTEGER) notnull -- whether the column is NOT NULL, 0 is false, 1 is true. |br| (STRING) dflt_value -- default value |br| (INTEGER) pk -- whether the column is a PRIMARY KEY column, 0 is false, 1 is true."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2900
msgid "Example: (not showing result set metadata)"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2902
msgid "PRAGMA table_info(T);\n"
"---\n"
"- - [0, 's1', 'integer', 1, null, 1]\n"
"  - [1, 's2', 'integer', 0, null, 0]\n"
"..."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2915
msgid "EXPLAIN"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2919
msgid ":samp:`EXPLAIN explainable-statement;`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2924
msgid "EXPLAIN will show what steps Tarantool would take if it executed explainable-statement. This is primarily a debugging and optimization aid for the Tarantool team."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2927
msgid "Example: ``EXPLAIN DELETE FROM m;`` returns:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2929
msgid "- - [0, 'Init', 0, 3, 0, '', '00', 'Start at 3']\n"
"  - [1, 'Clear', 16416, 0, 0, '', '00', '']\n"
"  - [2, 'Halt', 0, 0, 0, '', '00', '']\n"
"  - [3, 'Transaction', 0, 1, 1, '0', '01', 'usesStmtJournal=0']\n"
"  - [4, 'Goto', 0, 1, 0, '', '00', '']"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2937
msgid "Variation: ``EXPLAIN QUERY PLAN statement;`` shows the steps of a search."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2992
msgid "Statements for transactions"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:2998
msgid "START TRANSACTION"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3002
msgid ":samp:`START TRANSACTION;`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3011
msgid "Start a transaction. After ``START TRANSACTION;``, a transaction is \"active\". If a transaction is already active, then ``START TRANSACTION;`` is illegal."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3014
msgid "Transactions should be active for fairly short periods of time, to avoid concurrency issues. To end a transaction, say :ref:`COMMIT; <sql_commit>` or :ref:`ROLLBACK; <sql_rollback>`."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3017
msgid "Just as in NoSQL, transaction control statements are subject to limitations set by the :ref:`storage engine <engines-chapter>` involved: |br| * For the memtx storage engine, if a yield happens within an active transaction, the transaction is rolled back. |br| * For the vinyl engine, yields are allowed. |br| Also, although CREATE AND DROP and ALTER statements are legal in transactions, there are a few exceptions. For example, :samp:`CREATE INDEX ON {table_name} ...` will fail within a multi-statement transaction if the table is not empty."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3025
msgid "However, transaction control statements still may not work as you expect when run over a network connection: a transaction is associated with a fiber, not a network connection, and different transaction control statements sent via the same network connection may be executed by different fibers from the fiber pool."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3031
msgid "In order to ensure that all statements are part of the intended transaction, put all of them between ``START TRANSACTION;`` and ``COMMIT;`` or ``ROLLBACK;`` then send as a single batch. For example:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3035
msgid "Enclose each separate SQL statement in a :ref:`box.execute() <box-sql_box_execute>` function."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3037
msgid "Pass all the ``box.execute()`` functions to the server in a single message."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3039
msgid "If you are using a console, you can do this by writing everything on a single line."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3042
msgid "If you are using :ref:`net.box <net_box-module>`, you can do this by putting all the function calls in a single string and calling :ref:`eval(string) <net_box-eval>`."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3048
msgid "START TRANSACTION;"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3052
msgid "Example of a whole transaction sent to a server on ``localhost:3301`` with ``eval(string)``:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3055
msgid "net_box = require('net.box')\n"
"conn = net_box.new('localhost', 3301)\n"
"s = 'box.execute([[START TRANSACTION;]]) '\n"
"s = s .. 'box.execute([[INSERT INTO t VALUES (1);]]) '\n"
"s = s .. 'box.execute([[ROLLBACK;]]) '\n"
"conn:eval(s)"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3068
msgid "COMMIT"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3072
msgid ":samp:`COMMIT;`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3081
msgid "Commit an active transaction, so all changes are made permanent and the transaction ends."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3084
msgid "COMMIT is illegal unless a transaction is active. If a transaction is not active then SQL statements are committed automatically."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3089
msgid "COMMIT;"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3097
msgid "SAVEPOINT"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3101
msgid ":samp:`SAVEPOINT {savepoint-name};`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3110
msgid "Set a savepoint, so that :ref:`ROLLBACK TO savepoint-name <sql_rollback>` is possible."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3112
msgid "SAVEPOINT is illegal unless a transaction is active."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3114
msgid "If a savepoint with the same name already exists, it is released before the new savepoint is set."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3119
msgid "SAVEPOINT x;"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3127
msgid "RELEASE SAVEPOINT"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3131
msgid ":samp:`RELEASE SAVEPOINT {savepoint-name};`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3140
msgid "Release (destroy) a savepoint created by a :ref:`SAVEPOINT statement <sql_savepoint>`."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3142
msgid "RELEASE is illegal unless a transaction is active."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3144
msgid "Savepoints are released automatically when a transaction ends."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3148
msgid "RELEASE SAVEPOINT x;"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3156
msgid "ROLLBACK"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3160
msgid ":samp:`ROLLBACK [TO [SAVEPOINT] {savepoint-name}];`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3169
msgid "If ROLLBACK does not specify a *savepoint-name*, rollback an active transaction, so all changes since :ref:`START TRANSACTION <sql_start_transaction>` are cancelled, and the transaction ends."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3174
msgid "If ROLLBACK does specify a *savepoint-name*, rollback an active transaction, so all changes since :ref:`SAVEPOINT savepoint-name <sql_savepoint>` are cancelled, and the transaction does not end."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3179
msgid "ROLLBACK is illegal unless a transaction is active."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3183
msgid "-- the simple form:\n"
"ROLLBACK;\n"
"-- the form so changes before a savepoint are not cancelled:\n"
"ROLLBACK TO SAVEPOINT x;"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3190
msgid "-- An example of a Lua function that will do a transaction\n"
"-- containing savepoint and rollback to savepoint.\n"
"function f()\n"
"box.execute([[DROP TABLE IF EXISTS t;]]) -- commits automatically\n"
"box.execute([[CREATE TABLE t (s1 STRING PRIMARY KEY);]]) -- commits automatically\n"
"box.execute([[START TRANSACTION;]]) -- after this succeeds, a transaction is active\n"
"box.execute([[INSERT INTO t VALUES ('Data change #1');]])\n"
"box.execute([[SAVEPOINT \"1\";]])\n"
"box.execute([[INSERT INTO t VALUES ('Data change #2');]])\n"
"box.execute([[ROLLBACK TO SAVEPOINT \"1\";]]) -- rollback Data change #2\n"
"box.execute([[ROLLBACK TO SAVEPOINT \"1\";]]) -- this is legal but does nothing\n"
"box.execute([[COMMIT;]]) -- make Data change #1 permanent, end the transaction\n"
"end"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3210
msgid "Functions"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3214
msgid "Explanation of functions"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3220
msgid "Apply a built-in function to one or more expressions and return a scalar value."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3222
msgid "Tarantool supports 33 built-in functions."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3224
msgid "The maximum number of operands for any function is 127."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3226
msgid "The required privileges for built-in functions will likely change in a future version."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3232
msgid "List of functions"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3234
msgid "These are Tarantool/SQL's built-in functions. Starting with Tarantool 2.10, for functions that require numeric arguments, function arguments with NUMBER data type are illegal."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3242
msgid "ABS"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3246
msgid ":samp:`ABS({numeric-expression})`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3248
msgid "Return the absolute value of numeric-expression, which can be any numeric type."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3250
msgid "Example: ``ABS(-1)`` is 1."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3256
msgid "CAST"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3260
msgid ":samp:`CAST({expression} AS {data-type})`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3262
msgid "Return the expression value after casting to the specified :ref:`data type <sql_column_def_data_type>`."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3265
msgid "CAST to/from UUID may change some components to/from little-endian."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3267
msgid "Examples: ``CAST('AB' AS VARBINARY)``, ``CAST(X'4142' AS STRING)``"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3273
msgid "CHAR"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3277
msgid ":samp:`CHAR([numeric-expression [,numeric-expression...])`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3279
msgid "Return the characters whose Unicode code point values are equal to the numeric expressions."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3282
msgid "Short example:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3284
msgid "The first 128 Unicode characters are the \"ASCII\" characters, so CHAR(65, 66, 67) is 'ABC'."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3287
msgid "Long example:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3289
msgid "For the current list of Unicode characters, in order by code point, see `www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt <http://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt>`_. In that list, there is a line for a Linear B ideogram"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3295
msgid "``100CC;LINEAR B IDEOGRAM B240 WHEELED CHARIOT ...``"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3297
msgid "Therefore, for a string with a chariot in the middle, use the concatenation operator ``||`` and the CHAR function"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3300
msgid "``'start of string ' || CHAR(0X100CC) || ' end of string'``."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3306
msgid "COALESCE"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3310
msgid ":samp:`COALESCE(expression, expression [, expression ...])`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3312
msgid "Return the value of the first non-NULL expression, or, if all expression values are NULL, return NULL."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3316
msgid "``COALESCE(NULL, 17, 32)`` is 17."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3322
msgid "DATE_PART"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3326
msgid ":samp:`DATE_PART(value_requested , datetime)`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3328
#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3547
msgid "Since :doc:`2.10.0 </release/2.10.0>`."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3330
msgid "The ``DATE_PART()`` function returns the requested information from a DATETIME value. It takes two arguments: the first one tells us what information is requested, the second is a DATETIME value."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3333
msgid "Below is a list of supported values of the first argument and what information is returned:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3335
msgid "``millennium`` -- millennium"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3336
msgid "``century`` -- century"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3337
msgid "``decade`` -- decade"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3338
msgid "``year`` -- year"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3339
msgid "``quarter`` -- quarter of year"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3340
msgid "``month`` -- month of year"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3341
msgid "``week`` -- week of year"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3342
msgid "``day`` -- day of month"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3343
msgid "``dow`` -- day of week"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3344
msgid "``doy`` -- day of year"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3345
msgid "``hour`` -- hour of day"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3346
msgid "``minute`` -- minute of hour"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3347
msgid "``second`` -- second of minute"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3348
msgid "``millisecond`` -- millisecond of second"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3349
msgid "``microsecond`` -- microsecond of second"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3350
msgid "``nanosecond`` -- nanosecond of second"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3351
msgid "``epoch`` -- epoch"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3352
msgid "``timezone_offset`` -- time zone offset from the UTC, in minutes."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3356
msgid "tarantool> select date_part('millennium', cast({'year': 2000, 'month': 4, 'day': 5, 'hour': 6, 'min': 33, 'sec': 22, 'nsec': 523999111} as datetime));\n"
"---\n"
"- metadata:\n"
"  - name: COLUMN_1\n"
"    type: integer\n"
"  rows:\n"
"  - [2]\n"
"...\n"
"\n"
"tarantool> select date_part('day', cast({'year': 2000, 'month': 4, 'day': 5, 'hour': 6, 'min': 33, 'sec': 22, 'nsec': 523999111} as datetime));\n"
"---\n"
"- metadata:\n"
"  - name: COLUMN_1\n"
"    type: integer\n"
"  rows:\n"
"  - [5]\n"
"...\n"
"\n"
"tarantool> select date_part('nanosecond', cast({'year': 2000, 'month': 4, 'day': 5, 'hour': 6, 'min': 33, 'sec': 22, 'nsec': 523999111} as datetime));\n"
"---\n"
"- metadata:\n"
"  - name: COLUMN_1\n"
"    type: integer\n"
"  rows:\n"
"  - [523999111]\n"
"..."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3389
msgid "GREATEST"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3393
msgid ":samp:`GREATEST({expression-1}, {expression-2}, [{expression-3} ...])`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3395
msgid "Return the greatest value of the supplied expressions, or, if any expression is NULL, return NULL. The reverse of ``GREATEST`` is :ref:`LEAST <sql_function_least>`."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3399
msgid "Examples: ``GREATEST(7, 44, -1)`` is 44; ``GREATEST(1E308, 'a', 0, X'00')`` is '\\0' = the nul character; ``GREATEST(3, NULL, 2)`` is NULL"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3407
msgid "HEX"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3411
msgid ":samp:`HEX(expression)`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3413
msgid "Return the hexadecimal code for each byte in **expression**."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3415
msgid "Starting with Tarantool version 2.10.0, the expression must be a byte sequence (data type VARBINARY)."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3418
msgid "In earlier versions of Tarantool, the expression could be either a string or a byte sequence. For ASCII characters, this was straightforward because the encoding is the same as the code point value. For non-ASCII characters, since character strings are usually encoded in UTF-8, each character will require two or more bytes."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3428
msgid "``HEX(X'41')`` will return ``41``."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3429
msgid "``HEX(CAST('Д' AS VARBINARY))`` will return ``D094``."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3435
msgid "IFNULL"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3440
msgid ":samp:`IFNULL(expression, expression)`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3442
msgid "Return the value of the first non-NULL expression, or, if both expression values are NULL, return NULL. Thus ``IFNULL(expression, expression)`` is the same as :ref:`COALESCE(expression, expression) <sql_function_coalesce>`."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3448
msgid "``IFNULL(NULL, 17)`` is 17"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3454
msgid "LEAST"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3458
msgid ":samp:`LEAST({expression-1}, {expression-2}, [{expression-3} ...])`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3460
msgid "Return the least value of the supplied expressions, or, if any expression is NULL, return NULL. The reverse of ``LEAST`` is :ref:`GREATEST <sql_function_greatest>`."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3464
msgid "Examples: ``LEAST(7, 44, -1)`` is -1; ``LEAST(1E308, 'a', 0, X'00')`` is 0; ``LEAST(3, NULL, 2)`` is NULL."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3472
msgid "LENGTH"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3476
msgid ":samp:`LENGTH(expression)`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3478
msgid "Return the number of characters in the **expression**, or the number of bytes in the **expression**. It depends on the data type: strings with data type STRING are counted in characters, byte sequences with data type VARBINARY are counted in bytes and are not ended by the nul character. There are two aliases for ``LENGTH(expression)`` -- ``CHAR_LENGTH(expression)`` and ``CHARACTER_LENGTH(expression)`` do the same thing."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3489
msgid "``LENGTH('ДД')`` is 2, the string has 2 characters."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3490
msgid "``LENGTH(CAST('ДД' AS VARBINARY))`` is 4, the string has 4 bytes."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3491
msgid "``LENGTH(CHAR(0, 65))`` is 2, '\\0' does not mean 'end of string'."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3492
msgid "``LENGTH(X'410041')`` is 3, X'...' byte sequences have type VARBINARY."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3498
msgid "LIKELIHOOD"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3502
msgid ":samp:`LIKELIHOOD({expression}, {DOUBLE literal})`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3504
msgid "Return the expression without change, provided that the numeric literal is between 0.0 and 1.0."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3506
msgid "Example: ``LIKELIHOOD('a' = 'b', .0)`` is FALSE"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3512
msgid "LIKELY"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3516
msgid ":samp:`LIKELY({expression})`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3518
msgid "Return TRUE if the expression is probably true."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3520
msgid "Example: ``LIKELY('a' <= 'b')`` is TRUE"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3526
msgid "LOWER"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3530
msgid ":samp:`LOWER({string-expression})`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3532
msgid "Return the expression, with upper-case characters converted to lower case. The reverse of ``LOWER`` is :ref:`UPPER <sql_function_upper>`."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3535
msgid "Example: ``LOWER('ДA')`` is 'дa'"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3541
msgid "NOW"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3545
msgid ":samp:`NOW()`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3549
msgid "The NOW() function returns the current date and time as a DATETIME value."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3552
msgid "If the function is called more than once in a query, it returns the same result until the query completes, unless a yield has occurred. On yield, the value returned by NOW() is changing."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3558
msgid "tarantool> select now(), now(), now()\n"
"---\n"
"- metadata:\n"
"  - name: COLUMN_1\n"
"    type: datetime\n"
"  - name: COLUMN_2\n"
"    type: datetime\n"
"  - name: COLUMN_3\n"
"    type: datetime\n"
"  rows:\n"
"  - ['2022-07-20T19:02:02.010812282+0300', '2022-07-20T19:02:02.010812282+0300', '2022-07-20T19:02:02.010812282+0300']\n"
"..."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3577
msgid "NULLIF"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3581
msgid ":samp:`NULLIF(expression-1, expression-2)`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3583
msgid "Return *expression-1* if *expression-1* <> *expression-2*, otherwise return NULL."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3588
msgid "``NULLIF('a', 'A')`` is 'a'."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3589
msgid "``NULLIF(1.00, 1)`` is NULL."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3593
msgid "Before :doc:`/release/2.10.4`, the type of the result was always ``SCALAR``. Since :doc:`/release/2.10.4`, the result of ``NULLIF`` matches the type of the first argument. If the first argument is the ``NULL`` literal, then the result has the ``SCALAR`` type."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3602
msgid "POSITION"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3606
msgid ":samp:`POSITION({expression-1}, {expression-2})`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3608
msgid "Return the position of expression-1 within expression-2, or return 0 if expression-1 does not appear within expression-2. The data types of the expressions must be either STRING or VARBINARY. If the expressions have data type STRING, then the result is the character position. If the expressions have data type VARBINARY, then the result is the byte position."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3616
msgid "Short example: ``POSITION('C', 'ABC')`` is 3"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3619
msgid "Long example: The UTF-8 encoding for the Latin letter A is hexadecimal 41; the UTF-8 encoding for the Cyrillic letter Д is hexadecimal D094 -- you can confirm this by saying SELECT HEX('ДA'); and seeing that the result is 'D09441'. If you now execute ``SELECT POSITION('A', 'ДA');`` the result will be 2, because 'A' is the second character in the string. However, if you now execute ``SELECT POSITION(X'41', X'D09441');`` the result will be 3, because X'41' is the third byte in the byte sequence."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3636
msgid "PRINTF"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3640
msgid ":samp:`PRINTF(string-expression [, expression ...])`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3642
msgid "Return a string formatted according to the rules of the C ``sprintf()`` function, where ``%d%s`` means the next two arguments are a numeric and a string, and so on."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3646
msgid "If an argument is missing or is NULL, it becomes:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3648
msgid "'0' if the format requires an integer,"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3649
msgid "'0.0' if the format requires a numeric with a decimal point,"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3650
msgid "'' if the format requires a string."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3652
msgid "Example: ``PRINTF('%da', 5)`` is '5a'."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3658
msgid "QUOTE"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3662
msgid ":samp:`QUOTE(string-argument)`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3664
msgid "Return a string with enclosing quotes if necessary, and with quotes inside the enclosing quotes if necessary. This function is useful for creating strings which are part of SQL statements, because of SQL's rules that string literals are enclosed by single quotes, and single quotes inside such strings are shown as two single quotes in a row."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3671
msgid "Starting with Tarantool version 2.10, arguments with numeric data types are returned without change."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3674
msgid "Example: ``QUOTE('a')`` is ``'a'``. ``QUOTE(5)`` is ``5``."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3680
msgid "RAISE"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3684
msgid ":samp:`RAISE(FAIL, {error-message})`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3686
msgid "This may only be used within a triggered statement. See also :ref:`Trigger Activation <sql_trigger_activation>`."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3692
msgid "RANDOM"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3694
msgid "Syntax: :samp:`RANDOM()`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3696
msgid "Return a 19-digit integer which is generated by a pseudo-random number generator,"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3698
msgid "Example: ``RANDOM()`` is 6832175749978026034, or it is any other integer"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3704
msgid "RANDOMBLOB"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3708
msgid ":samp:`RANDOMBLOB({n})`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3710
msgid "Return a byte sequence, n bytes long, data type = VARBINARY, containing bytes generated by a pseudo-random byte generator. The result can be translated to hexadecimal. If n is less than 1 or is NULL or is infinity, then NULL is returned."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3714
msgid "Example: ``HEX(RANDOMBLOB(3))`` is '9EAAA8', or it is the hex value for any other three-byte string"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3725
msgid ":samp:`REPLACE({expression-1}, {expression-2}, {expression-3})`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3727
msgid "Return expression-1, except that wherever expression-1 contains expression-2, replace expression-2 with expression-3. The expressions should all have data type STRING or VARBINARY."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3732
msgid "Example: ``REPLACE('AAABCCCBD', 'B', '!')`` is 'AAA!CCC!D'"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3738
msgid "ROUND"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3742
msgid ":samp:`ROUND({numeric-expression-1} [, {numeric-expression-2}])`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3744
msgid "Return the rounded value of numeric-expression-1, always rounding .5 upward for positive numerics or downward for negative numerics. If numeric-expression-2 is supplied then rounding is to the nearest numeric-expression-2 digits after the decimal point; if numeric-expression-2 is not supplied then rounding is to the nearest integer."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3750
msgid "Example: ``ROUND(-1.5)`` is -2, ``ROUND(1.7766E1,2)`` is 17.77."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3756
msgid "ROW_COUNT"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3758
msgid ":samp:`ROW_COUNT()`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3760
msgid "Return the number of rows that were inserted / updated / deleted by the last :ref:`INSERT <sql_insert>` or :ref:`UPDATE <sql_update>` or :ref:`DELETE <sql_delete>` or :ref:`REPLACE <sql_replace>` statement. Rows which were updated by an UPDATE statement are counted even if there was no change. Rows which were inserted / updated / deleted due to foreign-key action are not counted. Rows which were inserted / updated / deleted due to a view's :ref:`INSTEAD OF triggers <sql_instead_of_triggers>` are  not counted. After a CREATE or DROP statement, ROW_COUNT() is 1. After other statements,  ROW_COUNT() is 0."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3772
msgid "Example: ``ROW_COUNT()`` is 1 after a successful INSERT of a single row."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3774
msgid "Special rule if there are BEFORE or AFTER triggers: In effect the ROW_COUNT() counter is pushed at the beginning of a series of triggered statements, and popped at the end. Therefore, after the following statements:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3778
msgid "CREATE TABLE t1 (s1 INTEGER PRIMARY KEY);\n"
"CREATE TABLE t2 (s1 INTEGER, s2 STRING, s3 INTEGER, PRIMARY KEY (s1, s2, s3));\n"
"CREATE TRIGGER tt1 BEFORE DELETE ON t1 FOR EACH ROW BEGIN\n"
"  INSERT INTO t2 VALUES (old.s1, '#2 Triggered', ROW_COUNT());\n"
"  INSERT INTO t2 VALUES (old.s1, '#3 Triggered', ROW_COUNT());\n"
"  END;\n"
"INSERT INTO t1 VALUES (1),(2),(3);\n"
"DELETE FROM t1;\n"
"INSERT INTO t2 VALUES (4, '#4 Untriggered', ROW_COUNT());\n"
"SELECT * FROM t2;"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3791
msgid "The result is:"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3793
msgid "---\n"
"- - [1, '#2 Triggered', 3]\n"
"  - [1, '#3 Triggered', 1]\n"
"  - [2, '#2 Triggered', 3]\n"
"  - [2, '#3 Triggered', 1]\n"
"  - [3, '#2 Triggered', 3]\n"
"  - [3, '#3 Triggered', 1]\n"
"  - [4, '#4 Untriggered', 3]\n"
"..."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3809
msgid "SOUNDEX"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3813
msgid ":samp:`SOUNDEX(string-expression)`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3815
msgid "Return a four-character string which represents the sound of ``string-expression``. Often words and names which have different spellings will have the same Soundex representation if they are pronounced similarly, so it is possible to search by what they sound like. The algorithm works with characters in the Latin alphabet and works best with English words."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3823
msgid "Example: ``SOUNDEX('Crater')`` and ``SOUNDEX('Creature')`` both return ``C636``."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3829
msgid "SUBSTR"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3833
msgid ":samp:`SUBSTR({string-or-varbinary-value}, {numeric-start-position} [, {numeric-length}])`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3835
msgid "If string-or-varbinary-value has data type STRING, then return the substring which begins at character position numeric-start-position and continues for numeric-length characters (if numeric-length is supplied), or continues till the end of string-or-varbinary-value (if numeric-length is not supplied)."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3842
msgid "If numeric-start-position is less than 1, or if numeric-start-position + numeric-length is greater than the length of string-or-varbinary-value, then the result is not an error, anything which would be before the start or after the end is ignored. There are no symbols with index <= 0 or with index greater than the length of the first argument."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3848
msgid "If numeric-length is less than 0, then the result is an error."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3850
msgid "If string-or-varbinary-value has data type VARBINARY rather than data type STRING, then positioning and counting is by bytes rather than by characters."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3854
msgid "Examples: ``SUBSTR('ABCDEF', 3, 2)`` is 'CD', ``SUBSTR('абвгде', -1, 4)`` is 'аб'"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3860
msgid "TRIM"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3864
msgid ":samp:`TRIM([[LEADING|TRAILING|BOTH] [{expression-1}] FROM] {expression-2})`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3866
msgid "Return expression-2 after removing all leading and/or trailing characters or bytes. The expressions should have data type STRING or VARBINARY. If LEADING|TRAILING|BOTH is omitted, the default is BOTH. If expression-1 is omitted, the default is ' ' (space) for data type STRING or X'00' (nul) for data type VARBINARY."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3874
msgid "``TRIM('a' FROM 'abaaaaa')`` is 'b' -- all repetitions of 'a' are removed on both sides; ``TRIM(TRAILING 'ב' FROM 'אב')`` is 'א' -- if all characters are Hebrew, TRAILING means \"left\"; ``TRIM(X'004400')`` is X'44' -- the default byte sequence to trim is X'00' when data type is VARBINARY; ``TRIM(LEADING 'abc' FROM 'abcd')`` is 'd' -- expression-1 can have more than 1 character."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3883
msgid "TYPEOF"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3887
msgid ":samp:`TYPEOF({expression})`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3889
msgid "Return 'NULL' if the expression is NULL, or return 'scalar' if the expression is the name of a column defined as SCALAR, or return the :ref:`data type <sql_column_def_data_type>` of the expression."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3895
msgid "``TYPEOF('A')`` returns 'string'; ``TYPEOF(RANDOMBLOB(1))`` returns 'varbinary'; ``TYPEOF(1e44)`` returns 'double' or 'number'; ``TYPEOF(-44)`` returns 'integer'; ``TYPEOF(NULL)`` returns 'NULL'"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3901
msgid "Prior to Tarantool version 2.10, ``TYPEOF(expression)`` simply returned the data type of the expression for all cases."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3908
msgid "UNICODE"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3912
msgid ":samp:`UNICODE(string-expression)`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3914
msgid "Return the Unicode code point value of the first character of **string-expression**. If *string-expression* is empty, the return is NULL. This is the reverse of :ref:`CHAR(integer) <sql_function_char>`."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3918
msgid "Example: ``UNICODE('Щ')`` is 1065 (hexadecimal 0429)."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3924
msgid "UNLIKELY"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3928
msgid ":samp:`UNLIKELY({expression})`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3930
msgid "Return TRUE if the expression is probably false. Limitation: in fact ``UNLIKELY`` may return the same thing as :ref:`LIKELY <sql_function_likely>`."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3933
msgid "Example: ``UNLIKELY('a' <= 'b')`` is TRUE."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3939
msgid "UPPER"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3943
msgid ":samp:`UPPER(string-expression)`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3945
msgid "Return the expression, with lower-case characters converted to upper case. The reverse of ``UPPER`` is :ref:`LOWER <sql_function_lower>`."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3948
msgid "Example: ``UPPER('-4щl')`` is '-4ЩL'."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3954
msgid "UUID"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3958
msgid ":samp:`UUID([integer])`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3960
msgid "Return a Universal Unique Identifier, data type UUID. Optionally one can specify a version number; however, at this time the only allowed version is 4, which is the default. UUID support in SQL was added in Tarantool version 2.9.1."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3965
msgid "Example: ``UUID()`` or ``UUID(4)``"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3972
msgid "VERSION"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3976
msgid ":samp:`VERSION()`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3978
msgid "Return the Tarantool version."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3980
msgid "Example: for a February 2020 build VERSION() is ``'2.4.0-35-g57f6fc932'``."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3986
msgid "ZEROBLOB"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3990
msgid ":samp:`ZEROBLOB({n})`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3992
msgid "Return a byte sequence, data type = VARBINARY, n bytes long."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:3998
msgid "COLLATE clause"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:4000
msgid ":samp:`COLLATE collation-name`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:4002
msgid "The collation-name must identify an existing collation."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:4004
msgid "The COLLATE clause is allowed for STRING or SCALAR items: |br| () in :ref:`CREATE INDEX <sql_create_index>` |br| () in :ref:`CREATE TABLE <sql_create_table>` as part of :ref:`column definition <sql_column_def>` |br| () in CREATE TABLE as part of :ref:`UNIQUE definition <sql_table_constraint_def>` |br| () in string expressions |br|"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:4012
msgid "-- In CREATE INDEX\n"
"CREATE INDEX idx_unicode_mb_1 ON mb (s1 COLLATE \"unicode\");\n"
"-- In CREATE TABLE\n"
"CREATE TABLE t1 (s1 INTEGER PRIMARY KEY, s2 STRING COLLATE \"unicode_ci\");\n"
"-- In CREATE TABLE ... UNIQUE\n"
"CREATE TABLE mb (a STRING, b STRING, PRIMARY KEY(a), UNIQUE(b COLLATE \"unicode_ci\" DESC));\n"
"-- In string expressions\n"
"SELECT 'a' = 'b' COLLATE \"unicode\"\n"
"    FROM t\n"
"    WHERE s1 = 'b' COLLATE \"unicode\"\n"
"    ORDER BY s1 COLLATE \"unicode\";"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:4026
msgid "The list of collations can be seen with: :ref:`PRAGMA collation_list; <sql_pragma>`"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:4028
msgid "The collation rules comply completely with the Unicode Technical Standard #10 (`\"Unicode Collation Algorithm\" <http://unicode.org/reports/tr10/>`_) and the default character order is as in the `Default Unicode Collation Element Table (DUCET) <https://www.unicode.org/Public/UCA/8.0.0/allkeys.txt>`_. There are many permanent collations; the commonly used ones include: |br| |nbsp| |nbsp| ``\"none\"`` (not applicable) |br| |nbsp| |nbsp| ``\"unicode\"`` (characters are in DUCET order with strength = 'tertiary') |br| |nbsp| |nbsp| ``\"unicode_ci\"`` (characters are in DUCET order with strength = 'primary') |br| |nbsp| |nbsp| ``\"binary\"`` (characters are in code point order) |br| These identifiers must be quoted and in lower case because they are in lower case in :ref:`Tarantool/NoSQL collations <index-collation>`."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:4040
msgid "If one says ``COLLATE \"binary\"``, this is equivalent to asking for what is sometimes called \"code point order\" because, if the contents are in the UTF-8 character set, characters with larger code points will appear after characters with lower code points."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:4044
msgid "In an expression, ``COLLATE`` is an operator with higher precedence than anything except ``~``. This is fine because there are no other useful operators except ``||`` and comparison. After ``||``, collation is preserved."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:4048
msgid "In an expression with more than one ``COLLATE`` clause, if the collation names differ, there is an error: \"Illegal mix of collations\". In an expression with no ``COLLATE`` clauses, literals have collation ``\"binary\"``, columns have the collation specified by ``CREATE TABLE``."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:4053
msgid "In other words, to pick a collation, Tarantool uses: |br| the first ``COLLATE`` clause in an expression if it was specified, |br| else the column's ``COLLATE`` clause if it was specified, |br| else ``\"binary\"``."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:4058
msgid "However, for searches and sometimes for sorting, the collation may be an index's collation, so all non-index ``COLLATE`` clauses are ignored."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:4061
msgid ":ref:`EXPLAIN <sql_explain>` will not show the name of what collation was used, but will show the collation's characteristics."
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:4063
msgid "Example with Swedish collation: |br| Knowing that \"sv\" is the two-letter code for Swedish, |br| and knowing that \"s1\" means strength = 1, |br| and seeing with ``PRAGMA collation_list;`` that there is a collation named unicode_sv_s1, |br| check whether two strings are equal according to Swedish rules (yes they are): |br| ``SELECT 'ÄÄ' = 'ĘĘ' COLLATE \"unicode_sv_s1\";``"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:4070
msgid "Example with Russian and Ukrainian and Kyrgyz collations: |br| Knowing that Russian collation is practically the same as Unicode default, |br| and knowing that the two-letter codes for Ukrainian and Kyrgyz are 'uk' and 'ky', |br| and knowing that in Russian (but not Ukrainian) 'Г' = 'Ґ' with strength=primary, |br| and knowing that in Russian (but not Kyrgyz) 'Е' = 'Ё' with strength=primary, |br| the three SELECT statements here will return results in three different orders: |br| ``CREATE TABLE things (remark STRING PRIMARY KEY);`` |br| ``INSERT INTO things VALUES ('Е2'), ('Ё1');`` |br| ``INSERT INTO things VALUES ('Г2'), ('Ґ1');`` |br| ``SELECT remark FROM things ORDER BY remark COLLATE \"unicode\";`` |br| ``SELECT remark FROM things ORDER BY remark COLLATE \"unicode_uk_s1\";`` |br| ``SELECT remark FROM things ORDER BY remark COLLATE \"unicode_ky_s1\";``"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:4085
msgid "Default function parameters"
msgstr ""

#: ../../doc/reference/reference_sql/sql_statements_and_clauses.rst:4087
msgid "Starting in Tarantool 2.10, if a parameter for an :ref:`aggregate function <sql_aggregate>` or a :ref:`built-in scalar SQL function <sql_functions>` is one of the ``extra-parameters`` that can appear in :ref:`box.execute(...[,extra-parameters]) <box-sql_box_execute>` requests, default data type is calculated thus: |br| * When there is only one possible data type, it is default. |br| Example: ``box.execute([[SELECT TYPEOF(LOWER(?));]],{x})`` is 'string'. |br| * When possible data types are INTEGER or DOUBLE or DECIMAL, DECIMAL is default. |br| Example: ``box.execute([[SELECT TYPEOF(AVG(?));]],{x})`` is 'decimal'. |br| * When possible data types are STRING or VARBINARY, STRING is default. |br| Example: ``box.execute([[SELECT TYPEOF(LENGTH(?));]],{x})`` is 'string'. |br| * When possible data types are any other scalar data type, SCALAR is default. |br| Example: ``box.execute([[SELECT TYPEOF(GREATEST(?,5));]],{x})`` is 'scalar'. |br| * When possible data type is a non-scalar data type, such as ARRAY, result is undefined. |br| * Otherwise, there is no default. |br| Example: ``box.execute([[SELECT TYPEOF(LIKELY(?));]],{x})`` is the name of one of the primitive data types."
msgstr ""
