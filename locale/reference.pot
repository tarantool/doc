# SOME DESCRIPTIVE TITLE.
# Copyright (C) 
# This file is distributed under the same license as the Tarantool package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Tarantool 1.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-11-13 14:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../doc/reference/configuration/cfg_basic.rst:1
#: ../doc/reference/configuration/cfg_basic.rst:1
msgid ":ref:`background <cfg_basic-background>`"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:2
#: ../doc/reference/configuration/cfg_basic.rst:2
msgid ":ref:`custom_proc_title <cfg_basic-custom_proc_title>`"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:3
#: ../doc/reference/configuration/cfg_basic.rst:3
msgid ":ref:`listen <cfg_basic-listen>`"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:4
#: ../doc/reference/configuration/cfg_basic.rst:4
msgid ":ref:`memtx_dir <cfg_basic-memtx_dir>`"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:5
#: ../doc/reference/configuration/cfg_basic.rst:5
msgid ":ref:`pid_file <cfg_basic-pid_file>`"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:6
#: ../doc/reference/configuration/cfg_basic.rst:6
msgid ":ref:`read_only <cfg_basic-read_only>`"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:7
#: ../doc/reference/configuration/cfg_basic.rst:7
msgid ":ref:`vinyl_dir <cfg_basic-vinyl_dir>`"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:8
#: ../doc/reference/configuration/cfg_basic.rst:8
msgid ":ref:`vinyl_timeout <cfg_basic-vinyl_timeout>`"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:9
#: ../doc/reference/configuration/cfg_basic.rst:9
msgid ":ref:`username <cfg_basic-username>`"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:10
#: ../doc/reference/configuration/cfg_basic.rst:10
msgid ":ref:`wal_dir <cfg_basic-wal_dir>`"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:11
#: ../doc/reference/configuration/cfg_basic.rst:11
msgid ":ref:`work_dir <cfg_basic-work_dir>`"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:12
#: ../doc/reference/configuration/cfg_basic.rst:12
msgid ":ref:`worker_pool_threads <cfg_basic-worker_pool_threads>`"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:18
#: ../doc/reference/configuration/cfg_basic.rst:18
msgid "Run the server as a background task. The :ref:`log <cfg_logging-log>` and :ref:`pid_file <cfg_basic-pid_file>` parameters must be non-null for this to work."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:22
#: ../doc/reference/configuration/cfg_basic.rst:111
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:22
#: ../doc/reference/configuration/cfg_deprecated.rst:25
#: ../doc/reference/configuration/cfg_deprecated.rst:55
#: ../doc/reference/configuration/cfg_deprecated.rst:66
#: ../doc/reference/configuration/cfg_hot_standby.rst:48
#: ../doc/reference/configuration/cfg_logging.rst:127
#: ../doc/reference/configuration/cfg_logging.rst:282
#: ../doc/reference/configuration/cfg_replication.rst:124
#: ../doc/reference/configuration/cfg_basic.rst:22
#: ../doc/reference/configuration/cfg_basic.rst:111
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:22
#: ../doc/reference/configuration/cfg_hot_standby.rst:48
#: ../doc/reference/configuration/cfg_replication.rst:124
#: ../doc/reference/configuration/cfg_logging.rst:127
#: ../doc/reference/configuration/cfg_logging.rst:282
#: ../doc/reference/configuration/cfg_deprecated.rst:25
#: ../doc/reference/configuration/cfg_deprecated.rst:55
#: ../doc/reference/configuration/cfg_deprecated.rst:66
#: ../doc/reference/reference_rock/vshard/index.rst:1088
msgid "Type: boolean"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:23
#: ../doc/reference/configuration/cfg_basic.rst:112
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:23
#: ../doc/reference/configuration/cfg_deprecated.rst:26
#: ../doc/reference/configuration/cfg_hot_standby.rst:49
#: ../doc/reference/configuration/cfg_replication.rst:125
#: ../doc/reference/configuration/cfg_basic.rst:23
#: ../doc/reference/configuration/cfg_basic.rst:112
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:23
#: ../doc/reference/configuration/cfg_hot_standby.rst:49
#: ../doc/reference/configuration/cfg_replication.rst:125
#: ../doc/reference/configuration/cfg_deprecated.rst:26
#: ../doc/reference/reference_rock/vshard/index.rst:1024
#: ../doc/reference/reference_rock/vshard/index.rst:1035
msgid "Default: false"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:24
#: ../doc/reference/configuration/cfg_basic.rst:86
#: ../doc/reference/configuration/cfg_basic.rst:97
#: ../doc/reference/configuration/cfg_basic.rst:141
#: ../doc/reference/configuration/cfg_basic.rst:168
#: ../doc/reference/configuration/cfg_basic.rst:182
#: ../doc/reference/configuration/cfg_basic.rst:207
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:24
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:37
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:52
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:86
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:98
#: ../doc/reference/configuration/cfg_deprecated.rst:27
#: ../doc/reference/configuration/cfg_deprecated.rst:57
#: ../doc/reference/configuration/cfg_deprecated.rst:95
#: ../doc/reference/configuration/cfg_deprecated.rst:110
#: ../doc/reference/configuration/cfg_hot_standby.rst:50
#: ../doc/reference/configuration/cfg_logging.rst:112
#: ../doc/reference/configuration/cfg_logging.rst:129
#: ../doc/reference/configuration/cfg_replication.rst:216
#: ../doc/reference/configuration/cfg_replication.rst:238
#: ../doc/reference/configuration/cfg_storage.rst:43
#: ../doc/reference/configuration/cfg_storage.rst:55
#: ../doc/reference/configuration/cfg_storage.rst:69
#: ../doc/reference/configuration/cfg_storage.rst:93
#: ../doc/reference/configuration/cfg_storage.rst:115
#: ../doc/reference/configuration/cfg_storage.rst:139
#: ../doc/reference/configuration/cfg_storage.rst:152
#: ../doc/reference/configuration/cfg_storage.rst:164
#: ../doc/reference/configuration/cfg_storage.rst:175
#: ../doc/reference/configuration/cfg_storage.rst:186
#: ../doc/reference/configuration/cfg_basic.rst:24
#: ../doc/reference/configuration/cfg_basic.rst:86
#: ../doc/reference/configuration/cfg_basic.rst:97
#: ../doc/reference/configuration/cfg_basic.rst:141
#: ../doc/reference/configuration/cfg_basic.rst:168
#: ../doc/reference/configuration/cfg_basic.rst:182
#: ../doc/reference/configuration/cfg_basic.rst:207
#: ../doc/reference/configuration/cfg_storage.rst:43
#: ../doc/reference/configuration/cfg_storage.rst:55
#: ../doc/reference/configuration/cfg_storage.rst:69
#: ../doc/reference/configuration/cfg_storage.rst:93
#: ../doc/reference/configuration/cfg_storage.rst:115
#: ../doc/reference/configuration/cfg_storage.rst:139
#: ../doc/reference/configuration/cfg_storage.rst:152
#: ../doc/reference/configuration/cfg_storage.rst:164
#: ../doc/reference/configuration/cfg_storage.rst:175
#: ../doc/reference/configuration/cfg_storage.rst:186
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:24
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:37
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:52
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:86
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:98
#: ../doc/reference/configuration/cfg_hot_standby.rst:50
#: ../doc/reference/configuration/cfg_replication.rst:216
#: ../doc/reference/configuration/cfg_replication.rst:238
#: ../doc/reference/configuration/cfg_logging.rst:112
#: ../doc/reference/configuration/cfg_logging.rst:129
#: ../doc/reference/configuration/cfg_deprecated.rst:27
#: ../doc/reference/configuration/cfg_deprecated.rst:57
#: ../doc/reference/configuration/cfg_deprecated.rst:95
#: ../doc/reference/configuration/cfg_deprecated.rst:110
#: ../doc/reference/reference_rock/vshard/index.rst:1046
#: ../doc/reference/reference_rock/vshard/index.rst:1070
msgid "Dynamic: no"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:30
#: ../doc/reference/configuration/cfg_basic.rst:30
msgid "Add the given string to the server's process title (what’s shown in the COMMAND column for ``ps -ef`` and ``top -c`` commands)."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:34
#: ../doc/reference/configuration/cfg_basic.rst:34
msgid "For example, ordinarily :samp:`ps -ef` shows the Tarantool server process thus:"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:37
#: ../doc/reference/configuration/cfg_basic.rst:37
msgid "$ ps -ef | grep tarantool\n"
"1000     14939 14188  1 10:53 pts/2    00:00:13 tarantool <running>"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:42
#: ../doc/reference/configuration/cfg_basic.rst:42
msgid "But if the configuration parameters include ``custom_proc_title='sessions'`` then the output looks like:"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:45
#: ../doc/reference/configuration/cfg_basic.rst:45
msgid "$ ps -ef | grep tarantool\n"
"1000     14939 14188  1 10:53 pts/2    00:00:16 tarantool <running>: sessions"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:50
#: ../doc/reference/configuration/cfg_basic.rst:84
#: ../doc/reference/configuration/cfg_basic.rst:95
#: ../doc/reference/configuration/cfg_basic.rst:139
#: ../doc/reference/configuration/cfg_basic.rst:166
#: ../doc/reference/configuration/cfg_basic.rst:180
#: ../doc/reference/configuration/cfg_basic.rst:205
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:84
#: ../doc/reference/configuration/cfg_logging.rst:110
#: ../doc/reference/configuration/cfg_logging.rst:180
#: ../doc/reference/configuration/cfg_logging.rst:293
#: ../doc/reference/configuration/cfg_replication.rst:44
#: ../doc/reference/configuration/cfg_replication.rst:214
#: ../doc/reference/configuration/cfg_replication.rst:236
#: ../doc/reference/configuration/cfg_basic.rst:50
#: ../doc/reference/configuration/cfg_basic.rst:84
#: ../doc/reference/configuration/cfg_basic.rst:95
#: ../doc/reference/configuration/cfg_basic.rst:139
#: ../doc/reference/configuration/cfg_basic.rst:166
#: ../doc/reference/configuration/cfg_basic.rst:180
#: ../doc/reference/configuration/cfg_basic.rst:205
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:84
#: ../doc/reference/configuration/cfg_replication.rst:44
#: ../doc/reference/configuration/cfg_replication.rst:214
#: ../doc/reference/configuration/cfg_replication.rst:236
#: ../doc/reference/configuration/cfg_logging.rst:110
#: ../doc/reference/configuration/cfg_logging.rst:180
#: ../doc/reference/configuration/cfg_logging.rst:293
msgid "Type: string"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:51
#: ../doc/reference/configuration/cfg_basic.rst:73
#: ../doc/reference/configuration/cfg_basic.rst:96
#: ../doc/reference/configuration/cfg_basic.rst:167
#: ../doc/reference/configuration/cfg_basic.rst:206
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:69
#: ../doc/reference/configuration/cfg_logging.rst:111
#: ../doc/reference/configuration/cfg_networking.rst:15
#: ../doc/reference/configuration/cfg_replication.rst:45
#: ../doc/reference/configuration/cfg_replication.rst:104
#: ../doc/reference/configuration/cfg_replication.rst:215
#: ../doc/reference/configuration/cfg_replication.rst:237
#: ../doc/reference/configuration/cfg_basic.rst:51
#: ../doc/reference/configuration/cfg_basic.rst:73
#: ../doc/reference/configuration/cfg_basic.rst:96
#: ../doc/reference/configuration/cfg_basic.rst:167
#: ../doc/reference/configuration/cfg_basic.rst:206
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:69
#: ../doc/reference/configuration/cfg_replication.rst:45
#: ../doc/reference/configuration/cfg_replication.rst:104
#: ../doc/reference/configuration/cfg_replication.rst:215
#: ../doc/reference/configuration/cfg_replication.rst:237
#: ../doc/reference/configuration/cfg_networking.rst:15
#: ../doc/reference/configuration/cfg_logging.rst:111
msgid "Default: null"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:52
#: ../doc/reference/configuration/cfg_basic.rst:74
#: ../doc/reference/configuration/cfg_basic.rst:113
#: ../doc/reference/configuration/cfg_basic.rst:158
#: ../doc/reference/configuration/cfg_basic.rst:221
#: ../doc/reference/configuration/cfg_deprecated.rst:68
#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:70
#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:99
#: ../doc/reference/configuration/cfg_basic.rst:52
#: ../doc/reference/configuration/cfg_basic.rst:74
#: ../doc/reference/configuration/cfg_basic.rst:113
#: ../doc/reference/configuration/cfg_basic.rst:158
#: ../doc/reference/configuration/cfg_basic.rst:221
#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:70
#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:99
#: ../doc/reference/configuration/cfg_deprecated.rst:68
#: ../doc/reference/reference_rock/vshard/index.rst:1025
#: ../doc/reference/reference_rock/vshard/index.rst:1036
#: ../doc/reference/reference_rock/vshard/index.rst:1080
#: ../doc/reference/reference_rock/vshard/index.rst:1090
#: ../doc/reference/reference_rock/vshard/index.rst:1102
#: ../doc/reference/reference_rock/vshard/index.rst:1117
#: ../doc/reference/reference_rock/vshard/index.rst:1138
msgid "Dynamic: yes"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:58
#: ../doc/reference/configuration/cfg_basic.rst:58
msgid "The read/write data port number or :ref:`URI <index-uri>` (Universal Resource Identifier) string. Has no default value, so **must be specified** if connections will occur from remote clients that do not use the :ref:`“admin port” <admin-security>`. Connections made with :samp:`listen = {URI}` are called \"binary port\" or \"binary protocol\" connections."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:65
#: ../doc/reference/configuration/cfg_basic.rst:65
msgid "A typical value is 3301."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:69
#: ../doc/reference/configuration/cfg_basic.rst:69
msgid "A replica also binds to this port, and accepts connections, but these connections can only serve reads until the replica becomes a master."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:72
#: ../doc/reference/configuration/cfg_basic.rst:72
msgid "Type: integer or string"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:80
#: ../doc/reference/configuration/cfg_basic.rst:80
msgid "A directory where memtx stores snapshot (.snap) files. Can be relative to :ref:`work_dir <cfg_basic-work_dir>`. If not specified, defaults to ``work_dir``. See also :ref:`wal_dir <cfg_basic-wal_dir>`."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:85
#: ../doc/reference/configuration/cfg_basic.rst:140
#: ../doc/reference/configuration/cfg_basic.rst:181
#: ../doc/reference/configuration/cfg_basic.rst:85
#: ../doc/reference/configuration/cfg_basic.rst:140
#: ../doc/reference/configuration/cfg_basic.rst:181
msgid "Default: \".\""
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:92
#: ../doc/reference/configuration/cfg_basic.rst:92
msgid "Store the process id in this file. Can be relative to :ref:`work_dir <cfg_basic-work_dir>`. A typical value is “:file:`tarantool.pid`”."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:103
#: ../doc/reference/configuration/cfg_basic.rst:103
msgid "Say ``box.cfg{read_only=true...}`` to put the server instance in read-only mode. After this, any requests that try to change persistent data will fail with error :errcode:`ER_READONLY`. Read-only mode should be used for master-replica :ref:`replication <replication>`. Read-only mode does not affect data-change requests for spaces defined as :ref:`temporary <box_schema-space_create>`. Although read-only mode prevents the server from writing to the :ref:`WAL <internals-wal>`, it does not prevent writing diagnostics with the :ref:`log module <log-module>`."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:115
#: ../doc/reference/configuration/cfg_basic.rst:115
msgid "Setting ``read_only == true`` affects spaces differently depending on the options that were used during :ref:`box.schema.space.create <box_schema-space_create>`, as summarized by this chart:"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:122
#: ../doc/reference/configuration/cfg_basic.rst:122
msgid "Option"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:122
#: ../doc/reference/configuration/cfg_basic.rst:122
msgid "Can be created?"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:122
#: ../doc/reference/configuration/cfg_basic.rst:122
msgid "Can be written to?"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:122
#: ../doc/reference/configuration/cfg_basic.rst:122
msgid "Is replicated?"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:122
#: ../doc/reference/configuration/cfg_basic.rst:122
msgid "Is persistent?"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:124
#: ../doc/reference/configuration/cfg_basic.rst:124
msgid "(default)"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:124
#: ../doc/reference/configuration/cfg_basic.rst:124
#: ../doc/reference/configuration/cfg_basic.rst:126
#: ../doc/reference/configuration/cfg_basic.rst:126
#: ../doc/reference/configuration/cfg_basic.rst:126
#: ../doc/reference/configuration/cfg_basic.rst:128
#: ../doc/reference/configuration/cfg_basic.rst:128
#: ../doc/reference/configuration/cfg_basic.rst:124
#: ../doc/reference/configuration/cfg_basic.rst:124
#: ../doc/reference/configuration/cfg_basic.rst:126
#: ../doc/reference/configuration/cfg_basic.rst:126
#: ../doc/reference/configuration/cfg_basic.rst:126
#: ../doc/reference/configuration/cfg_basic.rst:128
#: ../doc/reference/configuration/cfg_basic.rst:128
msgid "no"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:124
#: ../doc/reference/configuration/cfg_basic.rst:124
#: ../doc/reference/configuration/cfg_basic.rst:126
#: ../doc/reference/configuration/cfg_basic.rst:128
#: ../doc/reference/configuration/cfg_basic.rst:128
#: ../doc/reference/configuration/cfg_basic.rst:124
#: ../doc/reference/configuration/cfg_basic.rst:124
#: ../doc/reference/configuration/cfg_basic.rst:126
#: ../doc/reference/configuration/cfg_basic.rst:128
#: ../doc/reference/configuration/cfg_basic.rst:128
msgid "yes"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:126
#: ../doc/reference/configuration/cfg_basic.rst:126
msgid "temporary"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:128
#: ../doc/reference/configuration/cfg_basic.rst:128
msgid "is_local"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:135
#: ../doc/reference/configuration/cfg_basic.rst:135
msgid "A directory where vinyl files or subdirectories will be stored. Can be relative to :ref:`work_dir <cfg_basic-work_dir>`. If not specified, defaults to ``work_dir``."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:147
#: ../doc/reference/configuration/cfg_basic.rst:147
msgid "The vinyl storage engine has a scheduler which does compaction. When vinyl is low on available memory, the compaction scheduler may be unable to keep up with incoming update requests. In that situation, queries may time out after ``vinyl_timeout`` seconds. This should rarely occur, since normally vinyl would throttle inserts when it is running low on compaction bandwidth. Compaction can also be ordered manually with :ref:`index_object:compact() <box_index-compact>`."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:156
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:68
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:96
#: ../doc/reference/configuration/cfg_deprecated.rst:93
#: ../doc/reference/configuration/cfg_deprecated.rst:108
#: ../doc/reference/configuration/cfg_logging.rst:139
#: ../doc/reference/configuration/cfg_logging.rst:303
#: ../doc/reference/configuration/cfg_networking.rst:14
#: ../doc/reference/configuration/cfg_replication.rst:75
#: ../doc/reference/configuration/cfg_replication.rst:148
#: ../doc/reference/configuration/cfg_replication.rst:165
#: ../doc/reference/configuration/cfg_storage.rst:28
#: ../doc/reference/configuration/cfg_storage.rst:67
#: ../doc/reference/configuration/cfg_storage.rst:162
#: ../doc/reference/configuration/cfg_basic.rst:156
#: ../doc/reference/configuration/cfg_storage.rst:28
#: ../doc/reference/configuration/cfg_storage.rst:67
#: ../doc/reference/configuration/cfg_storage.rst:162
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:68
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:96
#: ../doc/reference/configuration/cfg_replication.rst:75
#: ../doc/reference/configuration/cfg_replication.rst:148
#: ../doc/reference/configuration/cfg_replication.rst:165
#: ../doc/reference/configuration/cfg_networking.rst:14
#: ../doc/reference/configuration/cfg_logging.rst:139
#: ../doc/reference/configuration/cfg_logging.rst:303
#: ../doc/reference/configuration/cfg_deprecated.rst:93
#: ../doc/reference/configuration/cfg_deprecated.rst:108
msgid "Type: float"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:157
#: ../doc/reference/configuration/cfg_basic.rst:157
msgid "Default: 60"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:164
#: ../doc/reference/configuration/cfg_basic.rst:164
msgid "UNIX user name to switch to after start."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:174
#: ../doc/reference/configuration/cfg_basic.rst:174
msgid "A directory where write-ahead log (.xlog) files are stored. Can be relative to :ref:`work_dir <cfg_basic-work_dir>`. Sometimes ``wal_dir`` and :ref:`memtx_dir <cfg_basic-memtx_dir>` are specified with different values, so that write-ahead log files and snapshot files can be stored on different disks. If not specified, defaults to ``work_dir``."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:188
#: ../doc/reference/configuration/cfg_basic.rst:188
msgid "A directory where database working files will be stored. The server instance switches to ``work_dir`` with :manpage:`chdir(2)` after start. Can be relative to the current directory. If not specified, defaults to the current directory. Other directory parameters may be relative to ``work_dir``, for example:"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:194
#: ../doc/reference/configuration/cfg_basic.rst:194
msgid "box.cfg{\n"
"    work_dir = '/home/user/A',\n"
"    wal_dir = 'B',\n"
"    memtx_dir = 'C'\n"
"}"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:202
#: ../doc/reference/configuration/cfg_basic.rst:202
msgid "will put xlog files in ``/home/user/A/B``, snapshot files in ``/home/user/A/C``, and all other files or subdirectories in ``/home/user/A``."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:214
#: ../doc/reference/configuration/cfg_basic.rst:214
msgid "The maximum number of threads to use during execution of certain internal processes (currently :ref:`socket.getaddrinfo() <socket-getaddrinfo>` and :ref:`coio_call() <c_api-coio-coio_call>`)."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:219
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:35
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:50
#: ../doc/reference/configuration/cfg_logging.rst:28
#: ../doc/reference/configuration/cfg_networking.rst:50
#: ../doc/reference/configuration/cfg_networking.rst:67
#: ../doc/reference/configuration/cfg_replication.rst:58
#: ../doc/reference/configuration/cfg_replication.rst:103
#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:68
#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:97
#: ../doc/reference/configuration/cfg_storage.rst:41
#: ../doc/reference/configuration/cfg_storage.rst:53
#: ../doc/reference/configuration/cfg_storage.rst:78
#: ../doc/reference/configuration/cfg_storage.rst:91
#: ../doc/reference/configuration/cfg_storage.rst:101
#: ../doc/reference/configuration/cfg_storage.rst:113
#: ../doc/reference/configuration/cfg_storage.rst:137
#: ../doc/reference/configuration/cfg_storage.rst:150
#: ../doc/reference/configuration/cfg_storage.rst:173
#: ../doc/reference/configuration/cfg_storage.rst:184
#: ../doc/reference/configuration/cfg_basic.rst:219
#: ../doc/reference/configuration/cfg_storage.rst:41
#: ../doc/reference/configuration/cfg_storage.rst:53
#: ../doc/reference/configuration/cfg_storage.rst:78
#: ../doc/reference/configuration/cfg_storage.rst:91
#: ../doc/reference/configuration/cfg_storage.rst:101
#: ../doc/reference/configuration/cfg_storage.rst:113
#: ../doc/reference/configuration/cfg_storage.rst:137
#: ../doc/reference/configuration/cfg_storage.rst:150
#: ../doc/reference/configuration/cfg_storage.rst:173
#: ../doc/reference/configuration/cfg_storage.rst:184
#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:68
#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:97
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:35
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:50
#: ../doc/reference/configuration/cfg_replication.rst:58
#: ../doc/reference/configuration/cfg_replication.rst:103
#: ../doc/reference/configuration/cfg_networking.rst:50
#: ../doc/reference/configuration/cfg_networking.rst:67
#: ../doc/reference/configuration/cfg_logging.rst:28
msgid "Type: integer"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:220
#: ../doc/reference/configuration/cfg_replication.rst:76
#: ../doc/reference/configuration/cfg_basic.rst:220
#: ../doc/reference/configuration/cfg_replication.rst:76
msgid "Default: 4"
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:1
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:1
msgid ":ref:`force_recovery <cfg_binary_logging_snapshots-force_recovery>`,"
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:2
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:2
msgid ":ref:`rows_per_wal <cfg_binary_logging_snapshots-rows_per_wal>`,"
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:3
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:3
msgid ":ref:`wal_max_size <cfg_binary_logging_snapshots-wal_max_size>`,"
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:4
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:4
msgid ":ref:`snap_io_rate_limit <cfg_binary_logging_snapshots-snap_io_rate_limit>`,"
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:5
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:5
msgid ":ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>`,"
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:6
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:6
msgid ":ref:`wal_dir_rescan_delay <cfg_binary_logging_snapshots-wal_dir_rescan_delay>`"
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:12
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:12
msgid "If ``force_recovery`` equals true, Tarantool tries to continue if there is an error while reading a :ref:`snapshot file<index-box_persistence>` (at server instance start) or a :ref:`write-ahead log file<internals-wal>` (at server instance start or when applying an update at a replica): skips invalid records, reads as much data as possible and lets the process finish with a warning. Users can prevent the error from recurring by writing to the database and executing :ref:`box.snapshot() <box-snapshot>`."
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:20
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:20
msgid "Otherwise, Tarantool aborts recovery if there is an error while reading."
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:30
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:30
msgid "How many log records to store in a single write-ahead log file. When this limit is reached, Tarantool creates another WAL file named :samp:`{<first-lsn-in-wal>}.xlog`. This can be useful for simple rsync-based backups."
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:36
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:36
msgid "Default: 500000"
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:43
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:43
msgid "The maximum number of bytes in a single write-ahead log file. When a request would cause an .xlog file to become larger than ``wal_max_size``, Tarantool creates another WAL file -- the same effect that happens when the :ref:`rows_per_wal <cfg_binary_logging_snapshots-rows_per_wal>` limit is reached."
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:51
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:51
msgid "Default: 268435456 (256 * 1024 * 1024)"
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:58
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:58
msgid "Reduce the throttling effect of :ref:`box.snapshot <box-snapshot>` on INSERT/UPDATE/DELETE performance by setting a limit on how many megabytes per second it can write to disk. The same can be achieved by splitting :ref:`wal_dir <cfg_basic-wal_dir>` and :ref:`memtx_dir <cfg_basic-memtx_dir>` locations and moving snapshots to a separate disk. The limit also affects what :ref:`box.stat.vinyl().regulator <box_introspection-box_stat_vinyl_regulator>` may show for the write rate of dumps to .run and .index files."
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:70
#: ../doc/reference/configuration/cfg_logging.rst:30
#: ../doc/reference/configuration/cfg_logging.rst:141
#: ../doc/reference/configuration/cfg_logging.rst:182
#: ../doc/reference/configuration/cfg_logging.rst:284
#: ../doc/reference/configuration/cfg_logging.rst:295
#: ../doc/reference/configuration/cfg_logging.rst:305
#: ../doc/reference/configuration/cfg_networking.rst:16
#: ../doc/reference/configuration/cfg_networking.rst:52
#: ../doc/reference/configuration/cfg_networking.rst:69
#: ../doc/reference/configuration/cfg_replication.rst:46
#: ../doc/reference/configuration/cfg_replication.rst:60
#: ../doc/reference/configuration/cfg_replication.rst:77
#: ../doc/reference/configuration/cfg_replication.rst:105
#: ../doc/reference/configuration/cfg_replication.rst:126
#: ../doc/reference/configuration/cfg_replication.rst:150
#: ../doc/reference/configuration/cfg_replication.rst:167
#: ../doc/reference/configuration/cfg_storage.rst:80
#: ../doc/reference/configuration/cfg_storage.rst:80
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:70
#: ../doc/reference/configuration/cfg_replication.rst:46
#: ../doc/reference/configuration/cfg_replication.rst:60
#: ../doc/reference/configuration/cfg_replication.rst:77
#: ../doc/reference/configuration/cfg_replication.rst:105
#: ../doc/reference/configuration/cfg_replication.rst:126
#: ../doc/reference/configuration/cfg_replication.rst:150
#: ../doc/reference/configuration/cfg_replication.rst:167
#: ../doc/reference/configuration/cfg_networking.rst:16
#: ../doc/reference/configuration/cfg_networking.rst:52
#: ../doc/reference/configuration/cfg_networking.rst:69
#: ../doc/reference/configuration/cfg_logging.rst:30
#: ../doc/reference/configuration/cfg_logging.rst:141
#: ../doc/reference/configuration/cfg_logging.rst:182
#: ../doc/reference/configuration/cfg_logging.rst:284
#: ../doc/reference/configuration/cfg_logging.rst:295
#: ../doc/reference/configuration/cfg_logging.rst:305
msgid "Dynamic: **yes**"
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:76
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:76
msgid "Specify fiber-WAL-disk synchronization mode as:"
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:78
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:78
msgid "``none``: write-ahead log is not maintained;"
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:79
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:79
msgid "``write``: :ref:`fibers <fiber-fibers>` wait for their data to be written to the write-ahead log (no :manpage:`fsync(2)`);"
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:81
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:81
msgid "``fsync``: fibers wait for their data, :manpage:`fsync(2)` follows each :manpage:`write(2)`;"
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:85
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:85
msgid "Default: \"write\""
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:92
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:92
msgid "Number of seconds between periodic scans of the write-ahead-log file directory, when checking for changes to write-ahead-log files for the sake of :ref:`replication <replication>` or :ref:`hot standby <index-hot_standby>`."
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:97
#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:98
#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:98
#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:97
msgid "Default: 2"
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:3
#: ../doc/reference/configuration/cfg_deprecated.rst:3
msgid "These parameters are deprecated since Tarantool version 1.7.4:"
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:5
#: ../doc/reference/configuration/cfg_deprecated.rst:5
msgid ":ref:`coredump <cfg_basic-coredump_deprecated>`"
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:6
#: ../doc/reference/configuration/cfg_deprecated.rst:6
msgid ":ref:`logger <cfg_logging-logger_deprecated>`"
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:7
#: ../doc/reference/configuration/cfg_deprecated.rst:7
msgid ":ref:`logger_nonblock <cfg_logging-logger_nonblock_deprecated>`"
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:8
#: ../doc/reference/configuration/cfg_deprecated.rst:8
msgid ":ref:`panic_on_snap_error <cfg_binary_logging_snapshots-panic_on_snap_error_deprecated>`,"
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:9
#: ../doc/reference/configuration/cfg_deprecated.rst:9
msgid ":ref:`panic_on_wal_error <cfg_binary_logging_snapshots-panic_on_wal_error_deprecated>`"
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:10
#: ../doc/reference/configuration/cfg_deprecated.rst:10
msgid ":ref:`replication_source <cfg_replication-replication_source_deprecated>`"
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:11
#: ../doc/reference/configuration/cfg_deprecated.rst:11
msgid ":ref:`slab_alloc_arena <cfg_storage-slab_alloc_arena_deprecated>`"
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:12
#: ../doc/reference/configuration/cfg_deprecated.rst:12
msgid ":ref:`slab_alloc_factor <cfg_storage-slab_alloc_factor_deprecated>`"
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:13
#: ../doc/reference/configuration/cfg_deprecated.rst:13
msgid ":ref:`slab_alloc_maximal <cfg_storage-slab_alloc_maximal_deprecated>`"
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:14
#: ../doc/reference/configuration/cfg_deprecated.rst:14
msgid ":ref:`slab_alloc_minimal <cfg_storage-slab_alloc_minimal_deprecated>`"
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:15
#: ../doc/reference/configuration/cfg_deprecated.rst:15
msgid ":ref:`snap_dir <cfg_basic-snap_dir_deprecated>`"
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:16
#: ../doc/reference/configuration/cfg_deprecated.rst:16
msgid ":ref:`snapshot_count <cfg_checkpoint_daemon-snapshot_count_deprecated>`"
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:17
#: ../doc/reference/configuration/cfg_deprecated.rst:17
msgid ":ref:`snapshot_period <cfg_checkpoint_daemon-snapshot_period_deprecated>`"
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:23
#: ../doc/reference/configuration/cfg_deprecated.rst:101
#: ../doc/reference/configuration/cfg_deprecated.rst:23
#: ../doc/reference/configuration/cfg_deprecated.rst:101
msgid "**Deprecated**, do not use."
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:33
#: ../doc/reference/configuration/cfg_deprecated.rst:33
msgid "**Deprecated** in favor of :ref:`log <cfg_logging-log>`. The parameter was only renamed, while the type, values and semantics remained intact."
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:41
#: ../doc/reference/configuration/cfg_deprecated.rst:41
msgid "**Deprecated** in favor of :ref:`log_nonblock <cfg_logging-log_nonblock>`. The parameter was only renamed, while the type, values and semantics remained intact."
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:49
#: ../doc/reference/configuration/cfg_deprecated.rst:63
#: ../doc/reference/configuration/cfg_deprecated.rst:49
#: ../doc/reference/configuration/cfg_deprecated.rst:63
msgid "**Deprecated** in favor of :ref:`force_recovery <cfg_binary_logging_snapshots-force_recovery>`."
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:52
#: ../doc/reference/configuration/cfg_deprecated.rst:52
msgid "If there is an error while reading a snapshot file (at server instance start), abort."
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:56
#: ../doc/reference/configuration/cfg_deprecated.rst:67
#: ../doc/reference/configuration/cfg_logging.rst:128
#: ../doc/reference/configuration/cfg_logging.rst:283
#: ../doc/reference/configuration/cfg_logging.rst:128
#: ../doc/reference/configuration/cfg_logging.rst:283
#: ../doc/reference/configuration/cfg_deprecated.rst:56
#: ../doc/reference/configuration/cfg_deprecated.rst:67
msgid "Default: true"
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:74
#: ../doc/reference/configuration/cfg_deprecated.rst:74
msgid "**Deprecated** in favor of :ref:`replication <cfg_replication-replication>`. The parameter was only renamed, while the type, values and semantics remained intact."
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:83
#: ../doc/reference/configuration/cfg_deprecated.rst:83
msgid "**Deprecated** in favor of :ref:`memtx_memory <cfg_storage-memtx_memory>`."
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:86
#: ../doc/reference/configuration/cfg_deprecated.rst:86
msgid "How much memory Tarantool allocates to actually store tuples, **in gigabytes**. When the limit is reached, INSERT or UPDATE requests begin failing with error :errcode:`ER_MEMORY_ISSUE`. While the server does not go beyond the defined limit to allocate tuples, there is additional memory used to store indexes and connection information. Depending on actual configuration and workload, Tarantool can consume up to 20% more than the limit set here."
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:94
#: ../doc/reference/configuration/cfg_deprecated.rst:94
msgid "Default: 1.0"
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:103
#: ../doc/reference/configuration/cfg_deprecated.rst:103
msgid "The multiplier for computing the sizes of memory chunks that tuples are stored in. A lower value may result in less wasted memory depending on the total amount of memory available and the distribution of item sizes."
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:109
#: ../doc/reference/configuration/cfg_deprecated.rst:109
msgid "Default: 1.1"
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:116
#: ../doc/reference/configuration/cfg_deprecated.rst:116
msgid "**Deprecated** in favor of :ref:`memtx_max_tuple_size <cfg_storage-memtx_max_tuple_size>`. The parameter was only renamed, while the type, values and semantics remained intact."
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:125
#: ../doc/reference/configuration/cfg_deprecated.rst:125
msgid "**Deprecated** in favor of :ref:`memtx_min_tuple_size <cfg_storage-memtx_min_tuple_size>`. The parameter was only renamed, while the type, values and semantics remained intact."
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:134
#: ../doc/reference/configuration/cfg_deprecated.rst:134
msgid "**Deprecated** in favor of :ref:`memtx_dir <cfg_basic-memtx_dir>`. The parameter was only renamed, while the type, values and semantics remained intact."
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:142
#: ../doc/reference/configuration/cfg_deprecated.rst:142
msgid "**Deprecated** in favor of :ref:`checkpoint_interval <cfg_checkpoint_daemon-checkpoint_interval>`. The parameter was only renamed, while the type, values and semantics remained intact."
msgstr ""

#: ../doc/reference/configuration/cfg_deprecated.rst:151
#: ../doc/reference/configuration/cfg_deprecated.rst:151
msgid "**Deprecated** in favor of :ref:`checkpoint_count <cfg_checkpoint_daemon-checkpoint_count>`. The parameter was only renamed, while the type, values and semantics remained intact."
msgstr ""

#: ../doc/reference/configuration/cfg_hot_standby.rst:3
#: ../doc/reference/configuration/cfg_hot_standby.rst:3
msgid "Whether to start the server in **hot standby** mode."
msgstr ""

#: ../doc/reference/configuration/cfg_hot_standby.rst:5
#: ../doc/reference/configuration/cfg_hot_standby.rst:5
msgid "Hot standby is a feature which provides a simple form of failover without :ref:`replication <replication>`."
msgstr ""

#: ../doc/reference/configuration/cfg_hot_standby.rst:8
#: ../doc/reference/configuration/cfg_hot_standby.rst:8
msgid "The expectation is that there will be two instances of the server using the same configuration. The first one to start will be the \"primary\" instance. The second one to start will be the \"standby\" instance."
msgstr ""

#: ../doc/reference/configuration/cfg_hot_standby.rst:12
#: ../doc/reference/configuration/cfg_hot_standby.rst:12
msgid "To initiate the standby instance, start a second instance of the Tarantool server on the same computer with the same :ref:`box.cfg <box_introspection-box_cfg>` configuration settings -- including the same directories and same non-null URIs -- and with the additional configuration setting ``hot_standby = true``. Expect to see a notification ending with the words ``I> Entering hot standby mode``. This is fine. It means that the standby instance is ready to take over if the primary instance goes down."
msgstr ""

#: ../doc/reference/configuration/cfg_hot_standby.rst:22
#: ../doc/reference/configuration/cfg_hot_standby.rst:22
msgid "The standby instance will initialize and will try to take a lock on :ref:`wal_dir <cfg_basic-wal_dir>`, but will fail because the primary instance has made a lock on ``wal_dir``. So the standby instance goes into a loop, reading the write ahead log which the primary instance is writing (so the two instances are always in sync), and trying to take the lock. If the primary instance goes down for any reason, the lock will be released. In this case, the standby instance will succeed in taking the lock, will connect on the :ref:`listen <cfg_basic-listen>` address and will become the primary instance. Expect to see a notification ending with the words ``I> ready to accept requests``."
msgstr ""

#: ../doc/reference/configuration/cfg_hot_standby.rst:35
#: ../doc/reference/configuration/cfg_hot_standby.rst:35
msgid "Thus there is no noticeable downtime if the primary instance goes down."
msgstr ""

#: ../doc/reference/configuration/cfg_hot_standby.rst:37
#: ../doc/reference/configuration/cfg_hot_standby.rst:37
msgid "Hot standby feature has no effect:"
msgstr ""

#: ../doc/reference/configuration/cfg_hot_standby.rst:39
#: ../doc/reference/configuration/cfg_hot_standby.rst:39
msgid "if :ref:`wal_dir_rescan_delay = a large number <cfg_binary_logging_snapshots-wal_dir_rescan_delay>` (on Mac OS and FreeBSD); on these platforms, it is designed so that the loop repeats every ``wal_dir_rescan_delay`` seconds."
msgstr ""

#: ../doc/reference/configuration/cfg_hot_standby.rst:43
#: ../doc/reference/configuration/cfg_hot_standby.rst:43
msgid "if :ref:`wal_mode = 'none' <cfg_binary_logging_snapshots-wal_mode>`; it is designed to work with ``wal_mode = 'write'`` or ``wal_mode = 'fsync'``."
msgstr ""

#: ../doc/reference/configuration/cfg_hot_standby.rst:45
#: ../doc/reference/configuration/cfg_hot_standby.rst:45
msgid "for spaces created with :ref:`engine = 'vinyl' <box_schema-space_create>`; it is designed to work for spaces created with ``engine = 'memtx'``."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:3
#: ../doc/reference/configuration/cfg_logging.rst:3
msgid ":ref:`log_level <cfg_logging-log_level>`"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:4
#: ../doc/reference/configuration/cfg_logging.rst:4
msgid ":ref:`log <cfg_logging-log>`"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:5
#: ../doc/reference/configuration/cfg_logging.rst:5
msgid ":ref:`log_nonblock <cfg_logging-log_nonblock>`"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:6
#: ../doc/reference/configuration/cfg_logging.rst:6
msgid ":ref:`too_long_threshold <cfg_logging-too_long_threshold>`"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:7
#: ../doc/reference/configuration/cfg_logging.rst:7
msgid ":ref:`log_format <cfg_logging-log_format>`"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:13
#: ../doc/reference/configuration/cfg_logging.rst:13
msgid "What level of detail the :ref:`log <admin-logs>` will have. There are seven levels:"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:15
#: ../doc/reference/configuration/cfg_logging.rst:15
#: ../doc/reference/reference_lua/log.rst:91
msgid "1 – ``SYSERROR``"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:16
#: ../doc/reference/configuration/cfg_logging.rst:16
msgid "2 – ``ERROR``"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:17
#: ../doc/reference/configuration/cfg_logging.rst:17
#: ../doc/reference/reference_lua/log.rst:93
msgid "3 – ``CRITICAL``"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:18
#: ../doc/reference/configuration/cfg_logging.rst:18
msgid "4 – ``WARNING``"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:19
#: ../doc/reference/configuration/cfg_logging.rst:19
msgid "5 – ``INFO``"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:20
#: ../doc/reference/configuration/cfg_logging.rst:20
msgid "6 – ``VERBOSE``"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:21
#: ../doc/reference/configuration/cfg_logging.rst:21
msgid "7 – ``DEBUG``"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:23
#: ../doc/reference/configuration/cfg_logging.rst:23
msgid "By setting log_level, one can enable logging of all classes below or equal to the given level. Tarantool prints its logs to the standard error stream by default, but this can be changed with the :ref:`log <cfg_logging-log>` configuration parameter."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:29
#: ../doc/reference/configuration/cfg_logging.rst:29
msgid "Default: 5"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:32
#: ../doc/reference/configuration/cfg_logging.rst:32
msgid "Warning: prior to Tarantool 1.7.5 there were only six levels and ``DEBUG`` was level 6. Starting with Tarantool 1.7.5 ``VERBOSE`` is level 6 and ``DEBUG`` is level 7. ``VERBOSE`` is a new level for monitoring repetitive events which would cause too much log writing if ``INFO`` were used instead."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:41
#: ../doc/reference/configuration/cfg_logging.rst:41
msgid "By default, Tarantool sends the log to the standard error stream (``stderr``). If ``log`` is specified, Tarantool sends the log to a file, or to a pipe, or to the system logger."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:45
#: ../doc/reference/configuration/cfg_logging.rst:45
msgid "Example setting for sending the log to a file:"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:47
#: ../doc/reference/configuration/cfg_logging.rst:47
msgid "box.cfg{log = 'tarantool.log'}\n"
"-- or\n"
"box.cfg{log = 'file:tarantool.log'}"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:53
#: ../doc/reference/configuration/cfg_logging.rst:53
msgid "This will open the file ``tarantool.log`` for output on the server’s default directory. If the ``log`` string has no prefix or has the prefix \"file:\", then the string is interpreted as a file path."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:57
#: ../doc/reference/configuration/cfg_logging.rst:57
msgid "Example setting for sending the log to a pipe:"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:59
#: ../doc/reference/configuration/cfg_logging.rst:59
msgid "box.cfg{log = '| cronolog tarantool.log'}\n"
"-- or\n"
"box.cfg{log = 'pipe: cronolog tarantool.log'}'"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:65
#: ../doc/reference/configuration/cfg_logging.rst:65
msgid "This will start the program `cronolog <https://linux.die.net/man/1/cronolog>`_ when the server starts, and will send all log messages to the standard input (``stdin``) of cronolog. If the ``log`` string begins with '|' or has the prefix \"pipe:\", then the string is interpreted as a Unix `pipeline <https://en.wikipedia.org/wiki/Pipeline_%28Unix%29>`_."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:71
#: ../doc/reference/configuration/cfg_logging.rst:71
msgid "Example setting for sending the log to syslog:"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:73
#: ../doc/reference/configuration/cfg_logging.rst:73
msgid "box.cfg{log = 'syslog:identity=tarantool'}\n"
"-- or\n"
"box.cfg{log = 'syslog:facility=user'}\n"
"-- or\n"
"box.cfg{log = 'syslog:identity=tarantool,facility=user'}\n"
"-- or\n"
"box.cfg{log = 'syslog:server=unix:/dev/log'}"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:83
#: ../doc/reference/configuration/cfg_logging.rst:83
msgid "If the ``log`` string begins with \"syslog:\", then it is interpreted as a message for the `syslogd <http://www.rfc-base.org/txt/rfc-5424.txt>`_ program which normally is running in the background of any Unix-like platform. The setting can be 'syslog:', 'syslog:facility=...', 'syslog:identity=...', 'syslog:server=...', or a combination."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:90
#: ../doc/reference/configuration/cfg_logging.rst:90
msgid "The ``syslog:identity`` setting is an arbitrary string which will be placed at the beginning of all messages. The default value is: tarantool."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:93
#: ../doc/reference/configuration/cfg_logging.rst:93
msgid "The ``syslog:facility`` setting is currently ignored but will be used in the future. The value must be one of the `syslog <https://en.wikipedia.org/wiki/Syslog>`_ keywords, which tell syslogd where the message should go. The possible values are: auth, authpriv, cron, daemon, ftp, kern, lpr, mail, news, security, syslog, user, uucp, local0, local1, local2, local3, local4, local5, local6, local7. The default value is: user."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:100
#: ../doc/reference/configuration/cfg_logging.rst:100
msgid "The ``syslog:server`` setting is the locator for the syslog server. It can be a Unix socket path beginning with \"unix:\", or an ipv4 port number. The default socket value is: dev/log (on Linux) or /var/run/syslog (on Mac OS). The default port value is: 514, the UDP port."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:105
#: ../doc/reference/configuration/cfg_logging.rst:105
msgid "When logging to a file, Tarantool reopens the log on `SIGHUP <https://en.wikipedia.org/wiki/SIGHUP>`_. When log is a program, its pid is saved in the :ref:`log.logger_pid <log-logger_pid>` variable. You need to send it a signal to rotate logs."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:118
#: ../doc/reference/configuration/cfg_logging.rst:118
msgid "If ``log_nonblock`` equals true, Tarantool does not block on the log file descriptor when it’s not ready for write, and drops the message instead. If :ref:`log_level <cfg_logging-log_level>` is high, and many messages go to the log file, setting ``log_nonblock`` to true may improve logging performance at the cost of some log messages getting lost."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:124
#: ../doc/reference/configuration/cfg_logging.rst:124
msgid "This parameter has effect only if the output is going to ``syslog`` or to a pipe."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:135
#: ../doc/reference/configuration/cfg_logging.rst:135
msgid "If processing a request takes longer than the given value (in seconds), warn about it in the log. Has effect only if :ref:`log_level <cfg_logging-log_level>` is more than or equal to 4 (WARNING)."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:140
#: ../doc/reference/configuration/cfg_logging.rst:140
#: ../doc/reference/reference_rock/vshard/index.rst:1079
msgid "Default: 0.5"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:147
#: ../doc/reference/configuration/cfg_logging.rst:147
msgid "Log entries have two possible formats:"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:149
#: ../doc/reference/configuration/cfg_logging.rst:149
#: ../doc/reference/reference_lua/log.rst:21
msgid "'plain' (the default), or"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:150
#: ../doc/reference/configuration/cfg_logging.rst:150
#: ../doc/reference/reference_lua/log.rst:22
msgid "'json' (with more detail and with JSON labels)."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:152
#: ../doc/reference/configuration/cfg_logging.rst:152
#: ../doc/reference/reference_lua/log.rst:24
msgid "Here is what a log entry looks like after ``box.cfg{log_format='plain'}``:"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:154
#: ../doc/reference/configuration/cfg_logging.rst:154
#: ../doc/reference/reference_lua/log.rst:26
msgid "2017-10-16 11:36:01.508 [18081] main/101/interactive I> set 'log_format' configuration option to \"plain\""
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:158
#: ../doc/reference/configuration/cfg_logging.rst:158
#: ../doc/reference/reference_lua/log.rst:30
msgid "Here is what a log entry looks like after ``box.cfg{log_format='json'}``:"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:160
#: ../doc/reference/configuration/cfg_logging.rst:160
#: ../doc/reference/reference_lua/log.rst:32
msgid "{\"time\": \"2017-10-16T11:36:17.996-0600\",\n"
"\"level\": \"INFO\",\n"
"\"message\": \"set 'log_format' configuration option to \\\"json\\\"\",\n"
"\"pid\": 18081,|\n"
"\"cord_name\": \"main\",\n"
"\"fiber_id\": 101,\n"
"\"fiber_name\": \"interactive\",\n"
"\"file\": \"builtin\\/box\\/load_cfg.lua\",\n"
"\"line\": 317}"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:172
#: ../doc/reference/configuration/cfg_logging.rst:172
msgid "The ``log_format='plain'`` entry has time, process id, cord name, :ref:`fiber_id <fiber_object-id>`, :ref:`fiber_name <fiber_object-name_get>`, :ref:`log level <cfg_logging-log_level>`, and message."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:177
#: ../doc/reference/configuration/cfg_logging.rst:177
msgid "The ``log_format='json'`` entry has the same things along with their labels, and in addition has the file name and line number of the Tarantool source."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:181
#: ../doc/reference/configuration/cfg_logging.rst:181
msgid "Default: 'plain'"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:188
#: ../doc/reference/configuration/cfg_logging.rst:188
msgid "Logging example"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:190
#: ../doc/reference/configuration/cfg_logging.rst:190
msgid "This will illustrate how \"rotation\" works, that is, what happens when the server instance is writing to a log and signals are used when archiving it."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:193
#: ../doc/reference/configuration/cfg_logging.rst:193
msgid "Start with two terminal shells, Terminal #1 and Terminal #2."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:195
#: ../doc/reference/configuration/cfg_logging.rst:195
msgid "On Terminal #1: start an interactive Tarantool session, then say the logging will go to `Log_file`, then put a message \"Log Line #1\" in the log file:"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:198
#: ../doc/reference/configuration/cfg_logging.rst:198
msgid "box.cfg{log='Log_file'}\n"
"log = require('log')\n"
"log.info('Log Line #1')"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:204
#: ../doc/reference/configuration/cfg_logging.rst:204
msgid "On Terminal #2: use ``mv`` so the log file is now named `Log_file.bak`. The result of this is: the next log message will go to `Log_file.bak`."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:244
#: ../doc/reference/configuration/cfg_logging.rst:1462
msgid "mv Log_file Log_file.bak"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:212
#: ../doc/reference/configuration/cfg_logging.rst:212
msgid "On Terminal #1: put a message \"Log Line #2\" in the log file."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:214
#: ../doc/reference/configuration/cfg_logging.rst:214
msgid "log.info('Log Line #2')"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:218
#: ../doc/reference/configuration/cfg_logging.rst:218
msgid "On Terminal #2: use ``ps`` to find the process ID of the Tarantool instance."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:257
#: ../doc/reference/configuration/cfg_logging.rst:1475
msgid "ps -A | grep tarantool"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:225
#: ../doc/reference/configuration/cfg_logging.rst:225
msgid "On Terminal #2: use ``kill -HUP`` to send a SIGHUP signal to the Tarantool instance. The result of this is: Tarantool will open `Log_file` again, and the next log message will go to `Log_file`. (The same effect could be accomplished by executing log.rotate() on the instance.)"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:267
#: ../doc/reference/configuration/cfg_logging.rst:1485
msgid "kill -HUP *process_id*"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:235
#: ../doc/reference/configuration/cfg_logging.rst:235
msgid "On Terminal #1: put a message \"Log Line #3\" in the log file."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:237
#: ../doc/reference/configuration/cfg_logging.rst:237
msgid "log.info('Log Line #3')"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:241
#: ../doc/reference/configuration/cfg_logging.rst:241
msgid "On Terminal #2: use ``less`` to examine files. `Log_file.bak` will have these lines, except that the date and time will depend on when the example is done:"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:281
#: ../doc/reference/configuration/cfg_logging.rst:1499
msgid "2015-11-30 15:13:06.373 [27469] main/101/interactive I> Log Line #1`\n"
"2015-11-30 15:14:25.973 [27469] main/101/interactive I> Log Line #2`"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:250
#: ../doc/reference/configuration/cfg_logging.rst:250
msgid "and `Log_file` will have"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:289
#: ../doc/reference/configuration/cfg_logging.rst:1507
msgid "log file has been reopened\n"
"2015-11-30 15:15:32.629 [27469] main/101/interactive I> Log Line #3"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:260
#: ../doc/reference/configuration/cfg_logging.rst:260
msgid "Feedback"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:262
#: ../doc/reference/configuration/cfg_logging.rst:262
msgid ":ref:`feedback_enabled <cfg_logging-feedback_enabled>`"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:263
#: ../doc/reference/configuration/cfg_logging.rst:263
msgid ":ref:`feedback_host <cfg_logging-feedback_host>`"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:264
#: ../doc/reference/configuration/cfg_logging.rst:264
msgid ":ref:`feedback_interval <cfg_logging-feedback_interval>`"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:266
#: ../doc/reference/configuration/cfg_logging.rst:266
msgid "By default a Tarantool daemon sends a small packet once per hour, to https://feedback.tarantool.io. The packet contains three values from :ref:`box.info <box_introspection-box_info>`: ``box.info.version``, ``box.info.uuid``, and ``box.info.cluster_uuid``. By changing the feedback configuration parameters, users can adjust or turn off this feature."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:277
#: ../doc/reference/configuration/cfg_logging.rst:277
msgid "Whether to send feedback."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:279
#: ../doc/reference/configuration/cfg_logging.rst:279
msgid "If this is set to ``true``, feedback will be sent as described above. If this is set to ``false``, no feedback will be sent."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:290
#: ../doc/reference/configuration/cfg_logging.rst:290
msgid "The address to which the packet is sent. Usually the recipient is Tarantool, but it can be any URL."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:294
#: ../doc/reference/configuration/cfg_logging.rst:294
msgid "Default: 'https://feedback.tarantool.io'"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:301
#: ../doc/reference/configuration/cfg_logging.rst:301
msgid "The number of seconds between sendings, usually 3600 (1 hour)."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:304
#: ../doc/reference/configuration/cfg_logging.rst:304
msgid "Default: 3600"
msgstr ""

#: ../doc/reference/configuration/cfg_networking.rst:1
#: ../doc/reference/configuration/cfg_networking.rst:1
msgid ":ref:`io_collect_interval <cfg_networking-io_collect_interval>`,"
msgstr ""

#: ../doc/reference/configuration/cfg_networking.rst:2
#: ../doc/reference/configuration/cfg_networking.rst:2
msgid ":ref:`net_msg_max <cfg_networking-net_msg_max>`"
msgstr ""

#: ../doc/reference/configuration/cfg_networking.rst:3
#: ../doc/reference/configuration/cfg_networking.rst:3
msgid ":ref:`readahead <cfg_networking-readahead>`,"
msgstr ""

#: ../doc/reference/configuration/cfg_networking.rst:9
#: ../doc/reference/configuration/cfg_networking.rst:9
msgid "The instance will sleep for io_collect_interval seconds between iterations of the event loop. Can be used to reduce CPU load in deployments in which the number of client connections is large, but requests are not so frequent (for example, each connection issues just a handful of requests per second)."
msgstr ""

#: ../doc/reference/configuration/cfg_networking.rst:22
#: ../doc/reference/configuration/cfg_networking.rst:22
msgid "To handle messages, Tarantool allocates fibers. To prevent fiber overhead from affecting the whole system, Tarantool restricts how many messages the fibers handle, so that some pending requests are blocked."
msgstr ""

#: ../doc/reference/configuration/cfg_networking.rst:27
#: ../doc/reference/configuration/cfg_networking.rst:27
msgid "On powerful systems, increase ``net_msg_max`` and the scheduler will immediately start processing pending requests."
msgstr ""

#: ../doc/reference/configuration/cfg_networking.rst:30
#: ../doc/reference/configuration/cfg_networking.rst:30
msgid "On weaker systems, decrease ``net_msg_max`` and the overhead may decrease although this may take some time because the scheduler must wait until already-running requests finish."
msgstr ""

#: ../doc/reference/configuration/cfg_networking.rst:34
#: ../doc/reference/configuration/cfg_networking.rst:34
msgid "When ``net_msg_max`` is reached, Tarantool suspends processing of incoming packages until it has processed earlier messages. This is not a direct restriction of the number of fibers that handle network messages, rather it is a system-wide restriction of channel bandwidth. This in turn causes restriction of the number of incoming network messages that the :ref:`transaction processor thread <atomic-threads_fibers_yields>` handles, and therefore indirectly affects the fibers that handle network messages. (The number of fibers is smaller than the number of messages because messages can be released as soon as they are delivered, while incoming requests might not be processed until some time after delivery.)"
msgstr ""

#: ../doc/reference/configuration/cfg_networking.rst:48
#: ../doc/reference/configuration/cfg_networking.rst:48
msgid "On typical systems, the default value (768) is correct."
msgstr ""

#: ../doc/reference/configuration/cfg_networking.rst:51
#: ../doc/reference/configuration/cfg_networking.rst:51
msgid "Default: 768"
msgstr ""

#: ../doc/reference/configuration/cfg_networking.rst:58
#: ../doc/reference/configuration/cfg_networking.rst:58
msgid "The size of the read-ahead buffer associated with a client connection. The larger the buffer, the more memory an active connection consumes and the more requests can be read from the operating system buffer in a single system call. The rule of thumb is to make sure the buffer can contain at least a few dozen requests. Therefore, if a typical tuple in a request is large, e.g. a few kilobytes or even megabytes, the read-ahead buffer size should be increased. If batched request processing is not used, it’s prudent to leave this setting at its default."
msgstr ""

#: ../doc/reference/configuration/cfg_networking.rst:68
#: ../doc/reference/configuration/cfg_networking.rst:68
msgid "Default: 16320"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:1
#: ../doc/reference/configuration/cfg_replication.rst:1
msgid ":ref:`replication <cfg_replication-replication>`"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:2
#: ../doc/reference/configuration/cfg_replication.rst:2
msgid ":ref:`replication_timeout <cfg_replication-replication_timeout>`"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:3
#: ../doc/reference/configuration/cfg_replication.rst:3
msgid ":ref:`replication_connect_timeout <cfg_replication-replication_connect_timeout>`"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:4
#: ../doc/reference/configuration/cfg_replication.rst:4
msgid ":ref:`replication_connect_quorum <cfg_replication-replication_connect_quorum>`"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:5
#: ../doc/reference/configuration/cfg_replication.rst:5
msgid ":ref:`replication_skip_conflict <cfg_replication-replication_skip_conflict>`"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:6
#: ../doc/reference/configuration/cfg_replication.rst:6
msgid ":ref:`replication_sync_lag <cfg_replication-replication_sync_lag>`"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:7
#: ../doc/reference/configuration/cfg_replication.rst:7
msgid ":ref:`replication_sync_timeout <cfg_replication-replication_sync_timeout>`"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:8
#: ../doc/reference/configuration/cfg_replication.rst:8
msgid ":ref:`replicaset_uuid <cfg_replication-replicaset_uuid>`"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:9
#: ../doc/reference/configuration/cfg_replication.rst:9
msgid ":ref:`instance_uuid <cfg_replication-instance_uuid>`"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:15
#: ../doc/reference/configuration/cfg_replication.rst:15
msgid "If ``replication`` is not an empty string, the instance is considered to be a Tarantool :ref:`replica <replication>`. The replica will try to connect to the master specified in ``replication`` with a :ref:`URI <index-uri>` (Universal Resource Identifier), for example:"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:20
#: ../doc/reference/configuration/cfg_replication.rst:20
msgid ":samp:`{konstantin}:{secret_password}@{tarantool.org}:{3301}`"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:22
#: ../doc/reference/configuration/cfg_replication.rst:22
msgid "If there is more than one replication source in a replica set, specify an array of URIs, for example (replace 'uri' and 'uri2' in this example with valid URIs):"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:26
#: ../doc/reference/configuration/cfg_replication.rst:26
msgid ":extsamp:`box.cfg{ replication = { {*{'uri1'}*}, {*{'uri2'}*} } }`"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:28
#: ../doc/reference/configuration/cfg_replication.rst:28
msgid "If one of the URIs is \"self\" -- that is, if one of the URIs is for the instance where ``box.cfg{}`` is being executed on -- then it is ignored. Thus it is possible to use the same ``replication`` specification on multiple server instances, as shown in :ref:`these examples <replication-bootstrap>`."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:34
#: ../doc/reference/configuration/cfg_replication.rst:34
msgid "The default user name is 'guest'."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:36
#: ../doc/reference/configuration/cfg_replication.rst:36
msgid "A read-only replica does not accept data-change requests on the :ref:`listen <cfg_basic-listen>` port."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:39
#: ../doc/reference/configuration/cfg_replication.rst:39
msgid "The ``replication`` parameter is dynamic, that is, to enter master mode, simply set ``replication`` to an empty string and issue:"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:42
#: ../doc/reference/configuration/cfg_replication.rst:42
msgid ":extsamp:`box.cfg{ replication = {*{new-value}*} }`"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:52
#: ../doc/reference/configuration/cfg_replication.rst:52
msgid "A replica sends heartbeat messages to the master every second, and the master is programmed to reconnect automatically if it doesn’t see heartbeat messages more often than ``replication_timeout`` seconds."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:56
#: ../doc/reference/configuration/cfg_replication.rst:56
msgid "See more in :ref:`Monitoring a replica set <replication-monitoring>`."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:59
#: ../doc/reference/configuration/cfg_replication.rst:59
#: ../doc/reference/reference_rock/vshard/index.rst:1101
#: ../doc/reference/reference_rock/vshard/index.rst:1116
#: ../doc/reference/reference_rock/vshard/index.rst:1167
msgid "Default: 1"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:66
#: ../doc/reference/configuration/cfg_replication.rst:66
msgid "The number of seconds that a replica will wait when trying to connect to a master in a cluster. See :ref:`orphan status <replication-orphan_status>` for details."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:70
#: ../doc/reference/configuration/cfg_replication.rst:70
msgid "This parameter is different from :ref:`replication_timeout <cfg_replication-replication_timeout>`, which is only used to automatically reconnect replication when it gets no heartbeats."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:83
#: ../doc/reference/configuration/cfg_replication.rst:83
msgid "By default a replica will try to connect to all the masters, or it will not start. (The default is recommended so that all replicas will receive the same replica set UUID.)"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:87
#: ../doc/reference/configuration/cfg_replication.rst:87
msgid "However, by specifying ``replication_connect_quorum = N``, where N is a number greater than or equal to zero, users can state that the replica only needs to connect to N masters."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:91
#: ../doc/reference/configuration/cfg_replication.rst:91
msgid "This parameter has effect during bootstrap and during :ref:`configuration update <replication-configuration_update>`. Setting ``replication_connect_quorum = 0`` makes Tarantool require no immediate reconnect only in case of recovery. See :ref:`orphan status <replication-orphan_status>` for details."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:97
#: ../doc/reference/configuration/cfg_replication.rst:118
#: ../doc/reference/configuration/cfg_replication.rst:208
#: ../doc/reference/configuration/cfg_replication.rst:230
#: ../doc/reference/configuration/cfg_replication.rst:97
#: ../doc/reference/configuration/cfg_replication.rst:118
#: ../doc/reference/configuration/cfg_replication.rst:208
#: ../doc/reference/configuration/cfg_replication.rst:230
msgid "Example:"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:99
#: ../doc/reference/configuration/cfg_replication.rst:99
msgid "box.cfg{replication_connect_quorum=2}"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:111
#: ../doc/reference/configuration/cfg_replication.rst:111
msgid "By default, if a replica adds a unique key that another replica has added, replication :ref:`stops <replication-replication_stops>` with error = ER_TUPLE_FOUND."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:115
#: ../doc/reference/configuration/cfg_replication.rst:115
msgid "However, by specifying ``replication_skip_conflict = true``, users can state that such errors may be ignored."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:120
#: ../doc/reference/configuration/cfg_replication.rst:120
msgid "box.cfg{replication_skip_conflict=true}"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:133
#: ../doc/reference/configuration/cfg_replication.rst:133
msgid "The maximum :ref:`lag <box_info_replication_upstream_lag>` allowed for a replica. When a replica :ref:`syncs <replication-orphan_status>` (gets updates from a master), it may not catch up completely. The number of seconds that the replica is behind the master is called the \"lag\". Syncing is considered to be complete when the replica's lag is less than or equal to ``replication_sync_lag``."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:140
#: ../doc/reference/configuration/cfg_replication.rst:140
msgid "If a user sets ``replication_sync_lag`` to nil or to 365 * 100 * 86400 (TIMEOUT_INFINITY), then lag does not matter -- the replica is always considered to be \"synced\". Also, the lag is ignored (assumed to be infinite) in case the master is running Tarantool older than 1.7.7, which does not send :ref:`heartbeat messages <heartbeat>`."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:145
#: ../doc/reference/configuration/cfg_replication.rst:145
msgid "This parameter is ignored during bootstrap. See :ref:`orphan status <replication-orphan_status>` for details."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:149
#: ../doc/reference/configuration/cfg_replication.rst:149
msgid "Default: 10"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:156
#: ../doc/reference/configuration/cfg_replication.rst:156
msgid "The number of seconds that a replica will wait when trying to sync with a master in a cluster, or a :ref:`quorum <cfg_replication-replication_connect_quorum>` of masters, after connecting or during :ref:`configuration update <replication-configuration_update>`. This could fail indefinitely if ``replication_sync_lag`` is smaller than network latency, or if the replica cannot keep pace with master updates. If ``replication_sync_timeout`` expires, the replica enters :ref:`orphan status <replication-orphan_status>`."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:166
#: ../doc/reference/configuration/cfg_replication.rst:166
msgid "Default: 300"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:173
#: ../doc/reference/configuration/cfg_replication.rst:173
msgid "As described in section :ref:`\"Replication architecture\" <replication-architecture>`, each replica set is identified by a `universally unique identifier <https://en.wikipedia.org/wiki/Universally_unique_identifier>`_ called **replica set UUID**, and each instance is identified by an **instance UUID**."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:180
#: ../doc/reference/configuration/cfg_replication.rst:180
msgid "Ordinarily it is sufficient to let the system generate and format the UUID strings which will be permanently stored."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:183
#: ../doc/reference/configuration/cfg_replication.rst:183
msgid "However, some administrators may prefer to store Tarantool configuration information in a central repository, for example `Apache ZooKeeper <https://zookeeper.apache.org>`_. Such administrators can assign their own UUID values for either -- or both -- instances (:ref:`instance_uuid <cfg_replication-instance_uuid>`) and replica set (``replicaset_uuid``), when starting up for the first time."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:190
#: ../doc/reference/configuration/cfg_replication.rst:190
msgid "General rules:"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:192
#: ../doc/reference/configuration/cfg_replication.rst:192
msgid "The values must be true unique identifiers, not shared by other instances or replica sets within the common infrastructure."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:195
#: ../doc/reference/configuration/cfg_replication.rst:195
msgid "The values must be used consistently, not changed after initial setup (the initial values are stored in :ref:`snapshot files <index-box_persistence>` and are checked whenever the system is restarted)."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:199
#: ../doc/reference/configuration/cfg_replication.rst:199
msgid "The values must comply with `RFC 4122 <https://tools.ietf.org/html/rfc4122>`_. The `nil UUID <https://tools.ietf.org/html/rfc4122#section-4.1.7>`_ is not allowed."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:203
#: ../doc/reference/configuration/cfg_replication.rst:203
msgid "The UUID format includes sixteen octets represented as 32 hexadecimal (base 16) digits, displayed in five groups separated by hyphens, in the form ``8-4-4-4-12`` for a total of 36 characters (32 alphanumeric characters and four hyphens)."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:210
#: ../doc/reference/configuration/cfg_replication.rst:210
msgid "box.cfg{replicaset_uuid='7b853d13-508b-4b8e-82e6-806f088ea6e9'}"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:222
#: ../doc/reference/configuration/cfg_replication.rst:222
msgid "For replication administration purposes, it is possible to set the `universally unique identifiers <https://en.wikipedia.org/wiki/Universally_unique_identifier>`_ of the instance (``instance_uuid``) and the replica set (``replicaset_uuid``), instead of having the system generate the values."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:227
#: ../doc/reference/configuration/cfg_replication.rst:227
msgid "See the description of :ref:`replicaset_uuid <cfg_replication-replicaset_uuid>` parameter for details."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:232
#: ../doc/reference/configuration/cfg_replication.rst:232
msgid "box.cfg{instance_uuid='037fec43-18a9-4e12-a684-a42b716fcd02'}"
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:1
#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:1
msgid ":ref:`checkpoint_count <cfg_checkpoint_daemon-checkpoint_count>`"
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:2
#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:2
msgid ":ref:`checkpoint_interval <cfg_checkpoint_daemon-checkpoint_interval>`"
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:4
#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:4
msgid "The checkpoint daemon is a fiber which is constantly running. At intervals, it may make new :ref:`snapshot (.snap) files <index-box_persistence>` and then may delete old snapshot files."
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:8
#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:8
msgid "The :ref:`checkpoint_interval <cfg_checkpoint_daemon-checkpoint_interval>` and :ref:`checkpoint_count <cfg_checkpoint_daemon-checkpoint_count>` configuration settings determine how long the intervals are, and how many snapshots should exist before deletions occur."
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:15
#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:15
msgid "**Tarantool garbage collector**"
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:17
#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:17
msgid "The checkpoint daemon may activate the Tarantool garbage collector which deletes old files. This garbage collector is distinct from the `Lua garbage collector <https://www.lua.org/manual/5.1/manual.html#2.10>`_ which is for Lua objects, and distinct from a Tarantool garbage collector which specializes in :ref:`handling shard buckets <vshard-gc>`."
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:24
#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:24
msgid "If the checkpoint daemon deletes an old snapshot file, then the Tarantool garbage collector will also delete any :ref:`write-ahead log (.xlog) <internals-wal>` files which are older than the snapshot file and which contain information that is present in the snapshot file. It will also delete obsolete vinyl ``.run`` files."
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:30
#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:30
msgid "The checkpoint daemon and the Tarantool garbage collector will not delete a file if:"
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:32
#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:32
msgid "a **backup** is ongoing and the file has not been backed up (see :ref:`\"Hot backup\" <admin-backups-hot_backup_vinyl_memtx>`), or"
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:35
#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:35
msgid "**replication** is ongoing and the file has not been relayed to a replica (see :ref:`\"Replication architecture\" <replication-architecture>`),"
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:38
#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:38
msgid "a replica is connecting, or"
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:40
#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:40
msgid "a replica has fallen behind. The progress of each replica is tracked; if a replica's position is far from being up to date, then the server stops to give it a chance to catch up. If an administrator concludes that a replica is permanently down, then the correct procedure is to restart the server, or (preferably) :ref:`remove the replica from the cluster <replication-remove_instances>`."
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:52
#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:52
msgid "The interval between actions by the checkpoint daemon, in seconds. If ``checkpoint_interval`` is set to a value greater than zero, and there is activity which causes change to a database, then the checkpoint daemon will call :ref:`box.snapshot <box-snapshot>` every ``checkpoint_interval`` seconds, creating a new snapshot file each time. If ``checkpoint_interval`` is set to zero, then the checkpoint daemon is disabled."
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:59
#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:59
#: ../doc/reference/reference_lua/box_error.rst:70
#: ../doc/reference/reference_lua/digest.rst:227
#: ../doc/reference/reference_rock/dbms.rst:82
#: ../doc/reference/reference_rock/dbms.rst:435
#: ../doc/reference/reference_rock/vshard/index.rst:844
msgid "For example:"
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:61
#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:61
msgid "box.cfg{checkpoint_interval=60}"
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:65
#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:65
msgid "will cause the checkpoint daemon to create a new database snapshot once per minute, if there is activity."
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:69
#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:69
msgid "Default: 3600 (one hour)"
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:76
#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:76
msgid "The maximum number of snapshots that may exist on the :ref:`memtx_dir <cfg_basic-memtx_dir>` directory before the checkpoint daemon will delete old snapshots. If ``checkpoint_count`` equals zero, then the checkpoint daemon does not delete old snapshots. For example:"
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:82
#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:82
msgid "box.cfg{\n"
"    checkpoint_interval = 3600,\n"
"    checkpoint_count  = 10\n"
"}"
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:89
#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:89
msgid "will cause the checkpoint daemon to create a new snapshot each hour until it has created ten snapshots. After that, it will delete the oldest snapshot (and any associated write-ahead-log files) after creating a new one."
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:93
#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:93
msgid "Remember that, as noted earlier, snapshots will not be deleted if replication is ongoing and the file has not been relayed to a replica. Therefore ``checkpoint_count`` has no effect unless all replicas are alive."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:1
#: ../doc/reference/configuration/cfg_storage.rst:1
msgid ":ref:`memtx_memory <cfg_storage-memtx_memory>`"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:2
#: ../doc/reference/configuration/cfg_storage.rst:2
msgid ":ref:`memtx_max_tuple_size <cfg_storage-memtx_max_tuple_size>`"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:3
#: ../doc/reference/configuration/cfg_storage.rst:3
msgid ":ref:`memtx_min_tuple_size <cfg_storage-memtx_min_tuple_size>`"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:4
#: ../doc/reference/configuration/cfg_storage.rst:4
msgid ":ref:`vinyl_bloom_fpr <cfg_storage-vinyl_bloom_fpr>`"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:5
#: ../doc/reference/configuration/cfg_storage.rst:5
msgid ":ref:`vinyl_cache <cfg_storage-vinyl_cache>`"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:6
#: ../doc/reference/configuration/cfg_storage.rst:6
msgid ":ref:`vinyl_max_tuple_size <cfg_storage-vinyl_max_tuple_size>`"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:7
#: ../doc/reference/configuration/cfg_storage.rst:7
msgid ":ref:`vinyl_memory <cfg_storage-vinyl_memory>`"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:8
#: ../doc/reference/configuration/cfg_storage.rst:8
msgid ":ref:`vinyl_page_size <cfg_storage-vinyl_page_size>`"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:9
#: ../doc/reference/configuration/cfg_storage.rst:9
msgid ":ref:`vinyl_range_size <cfg_storage-vinyl_range_size>`"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:10
#: ../doc/reference/configuration/cfg_storage.rst:10
msgid ":ref:`vinyl_run_count_per_level <cfg_storage-vinyl_run_count_per_level>`"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:11
#: ../doc/reference/configuration/cfg_storage.rst:11
msgid ":ref:`vinyl_run_size_ratio <cfg_storage-vinyl_run_size_ratio>`"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:12
#: ../doc/reference/configuration/cfg_storage.rst:12
msgid ":ref:`vinyl_read_threads <cfg_storage-vinyl_read_threads>`"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:13
#: ../doc/reference/configuration/cfg_storage.rst:13
msgid ":ref:`vinyl_write_threads <cfg_storage-vinyl_write_threads>`"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:19
#: ../doc/reference/configuration/cfg_storage.rst:19
msgid "How much memory Tarantool allocates to actually store tuples, in bytes. When the limit is reached, :ref:`INSERT <box_space-insert>` or :ref:`UPDATE <box_space-insert>` requests begin failing with error :errcode:`ER_MEMORY_ISSUE`. The server does not go beyond the ``memtx_memory`` limit to allocate tuples, but there is additional memory used to store indexes and connection information. Depending on actual configuration and workload, Tarantool can consume up to 20% more than the ``memtx_memory`` limit."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:29
#: ../doc/reference/configuration/cfg_storage.rst:29
msgid "Default: 256 * 1024 * 1024 = 268435456"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:30
#: ../doc/reference/configuration/cfg_storage.rst:103
#: ../doc/reference/configuration/cfg_storage.rst:30
#: ../doc/reference/configuration/cfg_storage.rst:103
msgid "Dynamic: **yes** but it cannot be decreased"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:36
#: ../doc/reference/configuration/cfg_storage.rst:36
msgid "Size of the largest allocation unit, in bytes, for the memtx storage engine. It can be increased if it is necessary to store large tuples. See also: :ref:`vinyl_max_tuple_size <cfg_storage-vinyl_max_tuple_size>`."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:42
#: ../doc/reference/configuration/cfg_storage.rst:92
#: ../doc/reference/configuration/cfg_storage.rst:42
#: ../doc/reference/configuration/cfg_storage.rst:92
msgid "Default: 1024 * 1024 = 1048576"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:49
#: ../doc/reference/configuration/cfg_storage.rst:49
msgid "Size of the smallest allocation unit, in bytes. It can be decreased if most of the tuples are very small. The value must be between 8 and 1048280 inclusive."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:54
#: ../doc/reference/configuration/cfg_storage.rst:54
msgid "Default: 16"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:61
#: ../doc/reference/configuration/cfg_storage.rst:61
msgid "Bloom filter false positive rate -- the suitable probability of the `bloom filter <https://en.wikipedia.org/wiki/Bloom_filter>`_ to give a wrong result. The ``vinyl_bloom_fpr`` setting is a default value for one of the options in the :ref:`Options for space_object:create_index() <box_space-create_index>` chart."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:68
#: ../doc/reference/configuration/cfg_storage.rst:68
msgid "Default = 0.05"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:75
#: ../doc/reference/configuration/cfg_storage.rst:75
msgid "The cache size for the vinyl storage engine, in bytes. The cache can be resized dynamically."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:79
#: ../doc/reference/configuration/cfg_storage.rst:102
#: ../doc/reference/configuration/cfg_storage.rst:79
#: ../doc/reference/configuration/cfg_storage.rst:102
msgid "Default = 128 * 1024 * 1024 = 134217728"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:86
#: ../doc/reference/configuration/cfg_storage.rst:86
msgid "Size of the largest allocation unit, in bytes, for the vinyl storage engine. It can be increased if it is necessary to store large tuples. See also: :ref:`memtx_max_tuple_size <cfg_storage-memtx_max_tuple_size>`."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:99
#: ../doc/reference/configuration/cfg_storage.rst:99
msgid "The maximum number of in-memory bytes that vinyl uses."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:109
#: ../doc/reference/configuration/cfg_storage.rst:109
msgid "Page size, in bytes. Page is a read/write unit for vinyl disk operations. The ``vinyl_page_size`` setting is a default value for one of the options in the :ref:`Options for space_object:create_index() <box_space-create_index>` chart."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:114
#: ../doc/reference/configuration/cfg_storage.rst:114
msgid "Default = 8 * 1024 = 8192"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:121
#: ../doc/reference/configuration/cfg_storage.rst:121
msgid "The default maximum range size for a vinyl index, in bytes. The maximum range size affects the decision whether to :ref:`split <engines-vinyl_split>` a range."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:125
#: ../doc/reference/configuration/cfg_storage.rst:125
msgid "If ``vinyl_range_size`` is not nil and not 0, then it is used as the default value for the ``range_size`` option in the :ref:`Options for space_object:create_index() <box_space-create_index>` chart."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:130
#: ../doc/reference/configuration/cfg_storage.rst:130
msgid "If ``vinyl_range_size`` is nil or 0, and ``range_size`` is not specified when the index is created, then Tarantool sets a value later depending on performance considerations. To see the actual value, use :ref:`index_object:stat().range_size <box_index-stat>`."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:135
#: ../doc/reference/configuration/cfg_storage.rst:135
msgid "In Tarantool versions prior to 1.10.2, ``vinyl_range_size`` default value was 1073741824."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:138
#: ../doc/reference/configuration/cfg_storage.rst:138
msgid "Default = nil"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:145
#: ../doc/reference/configuration/cfg_storage.rst:145
msgid "The maximal number of runs per level in vinyl LSM tree. If this number is exceeded, a new level is created. The ``vinyl_run_count_per_level`` setting is a default value for one of the options in the :ref:`Options for space_object:create_index() <box_space-create_index>` chart."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:151
#: ../doc/reference/configuration/cfg_storage.rst:185
#: ../doc/reference/configuration/cfg_storage.rst:151
#: ../doc/reference/configuration/cfg_storage.rst:185
msgid "Default = 2"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:158
#: ../doc/reference/configuration/cfg_storage.rst:158
msgid "Ratio between the sizes of different levels in the LSM tree. The ``vinyl_run_size_ratio`` setting is a default value for one of the options in the :ref:`Options for space_object:create_index() <box_space-create_index>` chart."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:163
#: ../doc/reference/configuration/cfg_storage.rst:163
msgid "Default = 3.5"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:170
#: ../doc/reference/configuration/cfg_storage.rst:170
msgid "The maximum number of read threads that vinyl can use for some concurrent operations, such as I/O and compression."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:174
#: ../doc/reference/configuration/cfg_storage.rst:174
msgid "Default = 1"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:181
#: ../doc/reference/configuration/cfg_storage.rst:181
msgid "The maximum number of write threads that vinyl can use for some concurrent operations, such as I/O and compression."
msgstr ""

#: ../doc/reference/configuration/index.rst:5
#: ../doc/reference/reference_rock/vshard/index.rst:999
msgid "Configuration reference"
msgstr ""

#: ../doc/reference/configuration/index.rst:7
msgid "This reference covers all options and parameters which can be set for Tarantool on the command line or in an :ref:`initialization file <index-init_label>`."
msgstr ""

#: ../doc/reference/configuration/index.rst:10
msgid "Tarantool is started by entering either of the following command:"
msgstr ""

#: ../doc/reference/configuration/index.rst:49
msgid "$ **tarantool**\n"
"\n"
"$ **tarantool** *options*\n"
"\n"
"$ **tarantool** *lua-initialization-file* **[** *arguments* **]**"
msgstr ""

#: ../doc/reference/configuration/index.rst:23
msgid "Command options"
msgstr ""

#: ../doc/reference/configuration/index.rst:27
msgid "Print an annotated list of all available options and exit."
msgstr ""

#: ../doc/reference/configuration/index.rst:33
msgid "Print product name and version, for example:"
msgstr ""

#: ../doc/reference/configuration/index.rst:35
msgid "$ ./tarantool --version\n"
"Tarantool 1.7.0-1216-g73f7154\n"
"Target: Linux-x86_64-Debug\n"
"..."
msgstr ""

#: ../doc/reference/configuration/index.rst:42
msgid "In this example:"
msgstr ""

#: ../doc/reference/configuration/index.rst:44
msgid "“Tarantool” is the name of the reusable asynchronous networking programming framework."
msgstr ""

#: ../doc/reference/configuration/index.rst:47
msgid "The 3-number version follows the standard ``<major>-<minor>-<patch>`` scheme, in which ``<major>`` number is changed only rarely, ``<minor>`` is incremented for each new milestone and indicates possible incompatible changes, and ``<patch>`` stands for the number of bug fix releases made after the start of the milestone. For non-released versions only, there may be a commit number and commit SHA1 to indicate how much this particular build has diverged from the last release."
msgstr ""

#: ../doc/reference/configuration/index.rst:55
msgid "“Target” is the platform tarantool was built on. Some platform-specific details may follow this line."
msgstr ""

#: ../doc/reference/configuration/index.rst:60
msgid "Tarantool uses `git describe <http://www.kernel.org/pub/software/scm/git/docs/git-describe.html>`_ to produce its version id, and this id can be used at any time to check out the corresponding source from our `git repository <http://github.com/tarantool/tarantool.git>`_."
msgstr ""

#: ../doc/reference/configuration/index.rst:70
msgid "URI"
msgstr ""

#: ../doc/reference/configuration/index.rst:72
msgid "Some configuration parameters and some functions depend on a URI, or \"Universal Resource Identifier\". The URI string format is similar to the `generic syntax for a URI schema <http://en.wikipedia.org/wiki/URI_scheme#Generic_syntax>`_. So it may contain (in order) a user name for login, a password, a host name or host IP address, and a port number. Only the port number is always mandatory. The password is mandatory if the user name is specified, unless the user name is 'guest'. So, formally, the URI syntax is ``[host:]port`` or ``[username:password@]host:port``. If host is omitted, then '0.0.0.0' or '[::]' is assumed, meaning respectively any IPv4 address or any IPv6 address, on the local machine. If username:password is omitted, then 'guest' is assumed. Some examples:"
msgstr ""

#: ../doc/reference/configuration/index.rst:91
msgid "URI fragment"
msgstr ""

#: ../doc/reference/configuration/index.rst:91
#: ../doc/reference/reference_lua/digest.rst:353
#: ../doc/reference/reference_lua/fiber.rst:736
#: ../doc/reference/reference_lua/fiber.rst:933
#: ../doc/reference/reference_lua/fiber.rst:1062
#: ../doc/reference/reference_lua/log.rst:144
#: ../doc/reference/reference_lua/msgpack.rst:111
#: ../doc/reference/reference_lua/net_box.rst:564
#: ../doc/reference/reference_lua/tap.rst:333
#: ../doc/reference/reference_lua/uuid.rst:132
#: ../doc/reference/reference_lua/yaml.rst:68
#: ../doc/reference/reference_rock/dbms.rst:249
#: ../doc/reference/reference_rock/dbms.rst:590
msgid "Example"
msgstr ""

#: ../doc/reference/configuration/index.rst:93
msgid "port"
msgstr ""

#: ../doc/reference/configuration/index.rst:93
msgid "3301"
msgstr ""

#: ../doc/reference/configuration/index.rst:95
msgid "host:port"
msgstr ""

#: ../doc/reference/configuration/index.rst:95
msgid "127.0.0.1:3301"
msgstr ""

#: ../doc/reference/configuration/index.rst:97
msgid "username:password@host:port"
msgstr ""

#: ../doc/reference/configuration/index.rst:97
msgid "notguest:sesame@mail.ru:3301"
msgstr ""

#: ../doc/reference/configuration/index.rst:100
msgid "In certain circumstances a Unix domain socket may be used where a URI is expected, for example \"unix/:/tmp/unix_domain_socket.sock\" or simply \"/tmp/unix_domain_socket.sock\"."
msgstr ""

#: ../doc/reference/configuration/index.rst:104
msgid "A method for parsing URIs is illustrated in :ref:`Module uri <uri-parse>`."
msgstr ""

#: ../doc/reference/configuration/index.rst:110
msgid "Initialization file"
msgstr ""

#: ../doc/reference/configuration/index.rst:112
msgid "If the command to start Tarantool includes :codeitalic:`lua-initialization-file`, then Tarantool begins by invoking the Lua program in the file, which by convention may have the name \"``script.lua``\". The Lua program may get further arguments from the command line or may use operating-system functions, such as ``getenv()``. The Lua program almost always begins by invoking ``box.cfg()``, if the database server will be used or if ports need to be opened. For example, suppose ``script.lua`` contains the lines"
msgstr ""

#: ../doc/reference/configuration/index.rst:120
msgid "#!/usr/bin/env tarantool\n"
"box.cfg{\n"
"    listen              = os.getenv(\"LISTEN_URI\"),\n"
"    memtx_memory        = 100000,\n"
"    pid_file            = \"tarantool.pid\",\n"
"    rows_per_wal        = 50\n"
"}\n"
"print('Starting ', arg[1])"
msgstr ""

#: ../doc/reference/configuration/index.rst:131
msgid "and suppose the environment variable LISTEN_URI contains 3301, and suppose the command line is ``~/tarantool/src/tarantool script.lua ARG``. Then the screen might look like this:"
msgstr ""

#: ../doc/reference/configuration/index.rst:135
msgid "$ export LISTEN_URI=3301\n"
"$ ~/tarantool/src/tarantool script.lua ARG\n"
"... main/101/script.lua C> version 1.7.0-1216-g73f7154\n"
"... main/101/script.lua C> log level 5\n"
"... main/101/script.lua I> mapping 107374184 bytes for a shared arena...\n"
"... main/101/script.lua I> recovery start\n"
"... main/101/script.lua I> recovering from './00000000000000000000.snap'\n"
"... main/101/script.lua I> primary: bound to 0.0.0.0:3301\n"
"... main/102/leave_local_hot_standby I> ready to accept requests\n"
"Starting  ARG\n"
"... main C> entering the event loop"
msgstr ""

#: ../doc/reference/configuration/index.rst:149
msgid "If you wish to start an interactive session on the same terminal after initialization is complete, you can use :ref:`console.start() <console-start>`."
msgstr ""

#: ../doc/reference/configuration/index.rst:165
msgid "Configuration parameters"
msgstr ""

#: ../doc/reference/configuration/index.rst:167
msgid "Configuration parameters have the form:"
msgstr ""

#: ../doc/reference/configuration/index.rst:169
msgid ":extsamp:`{**{box.cfg}**}{[{*{key = value}*} [, {*{key = value ...}*}]]}`"
msgstr ""

#: ../doc/reference/configuration/index.rst:171
msgid "Since ``box.cfg`` may contain many configuration parameters and since some of the parameters (such as directory addresses) are semi-permanent, it's best to keep ``box.cfg`` in a Lua file. Typically this Lua file is the initialization file which is specified on the tarantool command line."
msgstr ""

#: ../doc/reference/configuration/index.rst:176
msgid "Most configuration parameters are for allocating resources, opening ports, and specifying database behavior. All parameters are optional. A few parameters are dynamic, that is, they can be changed at runtime by calling ``box.cfg{}`` a second time."
msgstr ""

#: ../doc/reference/configuration/index.rst:181
msgid "To see all the non-null parameters, say ``box.cfg`` (no parentheses). To see a particular parameter, for example the listen address, say ``box.cfg.listen``."
msgstr ""

#: ../doc/reference/configuration/index.rst:184
msgid "The following sections describe all parameters for basic operation, for storage, for binary logging and snapshots, for replication, for networking, for logging, and for feedback."
msgstr ""

#: ../doc/reference/configuration/index.rst:190
#: ../doc/reference/reference_rock/vshard/index.rst:1005
msgid "Basic parameters"
msgstr ""

#: ../doc/reference/configuration/index.rst:196
msgid "Configuring the storage"
msgstr ""

#: ../doc/reference/configuration/index.rst:204
msgid "Checkpoint daemon"
msgstr ""

#: ../doc/reference/configuration/index.rst:210
msgid "Binary logging and snapshots"
msgstr ""

#: ../doc/reference/configuration/index.rst:218
msgid "Hot standby"
msgstr ""

#: ../doc/reference/configuration/index.rst:224
msgid "Replication"
msgstr ""

#: ../doc/reference/configuration/index.rst:230
msgid "Networking"
msgstr ""

#: ../doc/reference/configuration/index.rst:236
msgid "Logging"
msgstr ""

#: ../doc/reference/configuration/index.rst:242
msgid "Deprecated parameters"
msgstr ""

#: ../doc/reference/index.rst:5
msgid "Reference"
msgstr ""

#: ../doc/reference/lua_tips.rst:5
msgid "Tips on Lua syntax"
msgstr ""

#: ../doc/reference/lua_tips.rst:7
msgid "The Lua syntax for :ref:`data-manipulation functions <index-box_data-operations>` can vary. Here are examples of the variations with ``select()`` requests. The same rules exist for the other data-manipulation functions."
msgstr ""

#: ../doc/reference/lua_tips.rst:11
msgid "Every one of the examples does the same thing: select a tuple set from a space named 'tester' where the primary-key field value equals 1. For these examples, we assume that the numeric id of 'tester' is 512, which happens to be the case in our sandbox example only."
msgstr ""

#: ../doc/reference/lua_tips.rst:20
msgid "Object reference variations"
msgstr ""

#: ../doc/reference/lua_tips.rst:22
msgid "First, there are three **object reference variations**:"
msgstr ""

#: ../doc/reference/lua_tips.rst:24
msgid "-- #1 module . submodule . name\n"
"tarantool> box.space.tester:select{1}\n"
"-- #2 replace name with a literal in square brackets\n"
"tarantool> box.space['tester']:select{1}\n"
"-- #3 use a variable for the entire object reference\n"
"tarantool> s = box.space.tester\n"
"tarantool> s:select{1}"
msgstr ""

#: ../doc/reference/lua_tips.rst:34
msgid "Examples in this manual usually have the \":samp:`box.space.{tester}:`\" form (#1). However, this is a matter of user preference and all the variations exist in the wild."
msgstr ""

#: ../doc/reference/lua_tips.rst:38
msgid "Also, descriptions in this manual use the syntax \"``space_object:``\" for references to objects which are spaces, and \"``index_object:``\" for references to objects which are indexes (for example :samp:`box.space.{tester}.index.{primary}:`)."
msgstr ""

#: ../doc/reference/lua_tips.rst:47
msgid "Parameter variations"
msgstr ""

#: ../doc/reference/lua_tips.rst:49
msgid "Then, there are seven **parameter variations**:"
msgstr ""

#: ../doc/reference/lua_tips.rst:51
msgid "-- #1\n"
"tarantool> box.space.tester:select{1}\n"
"-- #2\n"
"tarantool> box.space.tester:select({1})\n"
"-- #3\n"
"tarantool> box.space.tester:select(1)\n"
"-- #4\n"
"tarantool> box.space.tester.select(box.space.tester,1)\n"
"-- #5\n"
"tarantool> box.space.tester:select({1},{iterator='EQ'})\n"
"-- #6\n"
"tarantool> variable = 1\n"
"tarantool> box.space.tester:select{variable}\n"
"-- #7\n"
"tarantool> variable = {1}\n"
"tarantool> box.space.tester:select(variable)"
msgstr ""

#: ../doc/reference/lua_tips.rst:70
msgid "Lua allows to omit parentheses ``()`` when invoking a function if its only argument is a Lua table, and we use it sometimes in our examples. This is why ``select{1}`` is equivalent to ``select({1})``. Literal values such as ``1`` (a scalar value) or ``{1}`` (a Lua table value) may be replaced by variable names, as in examples #6 and #7."
msgstr ""

#: ../doc/reference/lua_tips.rst:76
msgid "Although there are special cases where braces can be omitted, they are preferable because they signal \"Lua table\". Examples and descriptions in this manual have the ``{1}`` form. However, this too is a matter of user preference and all the variations exist in the wild."
msgstr ""

#: ../doc/reference/lua_tips.rst:85
msgid "Rules for object names"
msgstr ""

#: ../doc/reference/lua_tips.rst:87
msgid "Database objects have loose **rules for names**: the maximum length is 65000 bytes (not characters), and almost any legal Unicode character is allowed, including spaces, ideograms and punctuation."
msgstr ""

#: ../doc/reference/lua_tips.rst:92
msgid "In those cases, to prevent confusion with Lua operators and separators, object references should have the literal-in-square-brackets form (#2), or the variable form (#3). For example:"
msgstr ""

#: ../doc/reference/lua_tips.rst:96
msgid "tarantool> box.space['1*A']:select{1}\n"
"tarantool> s = box.space['1*A !@$%^&*()_+12345678901234567890']\n"
"tarantool> s:select{1}"
msgstr ""

#: ../doc/reference/lua_tips.rst:102
msgid "Disallowed:"
msgstr ""

#: ../doc/reference/lua_tips.rst:104
msgid "characters which are unassigned code points,"
msgstr ""

#: ../doc/reference/lua_tips.rst:105
msgid "line and paragraph separators,"
msgstr ""

#: ../doc/reference/lua_tips.rst:106
msgid "control characters,"
msgstr ""

#: ../doc/reference/lua_tips.rst:107
msgid "the replacement character (U+FFFD)."
msgstr ""

#: ../doc/reference/lua_tips.rst:109
msgid "Not recommended: characters which cannot be displayed."
msgstr ""

#: ../doc/reference/lua_tips.rst:111
msgid "Names are \"case sensitive\", so 'A' and 'a' are not the same."
msgstr ""

#: ../doc/reference/reference_lua/box.rst:5
msgid "Module `box`"
msgstr ""

#: ../doc/reference/reference_lua/box.rst:7
msgid "As well as executing Lua chunks or defining your own functions, you can exploit Tarantool's storage functionality with the ``box`` module and its submodules."
msgstr ""

#: ../doc/reference/reference_lua/box.rst:10
msgid "Every submodule contains one or more Lua functions. A few submodules contain members as well as functions. The functions allow data definition (create alter drop), data manipulation (insert delete update upsert select replace), and introspection (inspecting contents of spaces, accessing server configuration)."
msgstr ""

#: ../doc/reference/reference_lua/box.rst:15
msgid "To catch errors that functions in ``box`` submodules may throw, use :ref:`pcall <error_handling>`."
msgstr ""

#: ../doc/reference/reference_lua/box.rst:17
msgid "The contents of the ``box`` module can be inspected at runtime with ``box``, with no arguments. The ``box`` module contains:"
msgstr ""

#: ../doc/reference/reference_lua/box_backup.rst:3
msgid "Submodule box.backup"
msgstr ""

#: ../doc/reference/reference_lua/box_backup.rst:5
msgid "The box.backup submodule contains two functions that are helpful for :ref:`backup <admin-backups>` in certain situations."
msgstr ""

#: ../doc/reference/reference_lua/box_backup.rst:12
msgid "Informs the server that activities related to the removal of outdated backups must be suspended."
msgstr ""

#: ../doc/reference/reference_lua/box_backup.rst:15
msgid "To guarantee an opportunity to copy these files, Tarantool will not delete them. But there will be no read-only mode and checkpoints will continue by schedule as usual."
msgstr ""

#: ../doc/reference/reference_lua/box_backup.rst:0
#: ../doc/reference/reference_lua/box_error.rst:0
#: ../doc/reference/reference_lua/box_error.rst:0
#: ../doc/reference/reference_lua/box_error.rst:0
#: ../doc/reference/reference_lua/box_once.rst:0
#: ../doc/reference/reference_lua/clock.rst:0
#: ../doc/reference/reference_lua/console.rst:0
#: ../doc/reference/reference_lua/console.rst:0
#: ../doc/reference/reference_lua/console.rst:0
#: ../doc/reference/reference_lua/csv.rst:0
#: ../doc/reference/reference_lua/csv.rst:0
#: ../doc/reference/reference_lua/csv.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/errno.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/http.rst:0
#: ../doc/reference/reference_lua/http.rst:0
#: ../doc/reference/reference_lua/iconv.rst:0
#: ../doc/reference/reference_lua/json.rst:0
#: ../doc/reference/reference_lua/json.rst:0
#: ../doc/reference/reference_lua/log.rst:0
#: ../doc/reference/reference_lua/msgpack.rst:0
#: ../doc/reference/reference_lua/msgpack.rst:0
#: ../doc/reference/reference_lua/msgpack.rst:0
#: ../doc/reference/reference_lua/net_box.rst:0
#: ../doc/reference/reference_lua/net_box.rst:0
#: ../doc/reference/reference_lua/net_box.rst:0
#: ../doc/reference/reference_lua/net_box.rst:0
#: ../doc/reference/reference_lua/osmodule.rst:0
#: ../doc/reference/reference_lua/osmodule.rst:0
#: ../doc/reference/reference_lua/other.rst:0
#: ../doc/reference/reference_lua/pickle.rst:0
#: ../doc/reference/reference_lua/pickle.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/table.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/uri.rst:0
#: ../doc/reference/reference_lua/uri.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/yaml.rst:0
#: ../doc/reference/reference_lua/yaml.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
msgid "Parameters"
msgstr ""

#: ../doc/reference/reference_lua/box_backup.rst:19
msgid "optional argument starting with Tarantool 1.10.1 that indicates the checkpoint to use relative to the latest checkpoint. For example ``n = 0`` means “backup will be based on the latest checkpoint”, ``n = 1`` means \"backup will be based on the first checkpoint before the latest checkpoint (counting backwards)\", and so on. The default value for n is zero."
msgstr ""

#: ../doc/reference/reference_lua/box_backup.rst:26
msgid "**Return:**  a table with the names of snapshot and vinyl files that should be copied"
msgstr ""

#: ../doc/reference/reference_lua/box_backup.rst:29
#: ../doc/reference/reference_lua/box_error.rst:80
#: ../doc/reference/reference_lua/box_error.rst:120
#: ../doc/reference/reference_lua/box_error.rst:160
#: ../doc/reference/reference_lua/box_snapshot.rst:49
#: ../doc/reference/reference_lua/buffer.rst:23
#: ../doc/reference/reference_lua/clock.rst:78
#: ../doc/reference/reference_lua/clock.rst:103
#: ../doc/reference/reference_lua/clock.rst:124
#: ../doc/reference/reference_lua/clock.rst:145
#: ../doc/reference/reference_lua/clock.rst:167
#: ../doc/reference/reference_lua/console.rst:79
#: ../doc/reference/reference_lua/console.rst:110
#: ../doc/reference/reference_lua/console.rst:135
#: ../doc/reference/reference_lua/console.rst:174
#: ../doc/reference/reference_lua/crypto.rst:71
#: ../doc/reference/reference_lua/crypto.rst:103
#: ../doc/reference/reference_lua/crypto.rst:132
#: ../doc/reference/reference_lua/csv.rst:77
#: ../doc/reference/reference_lua/csv.rst:159
#: ../doc/reference/reference_lua/csv.rst:204
#: ../doc/reference/reference_lua/errno.rst:60
#: ../doc/reference/reference_lua/fiber.rst:201
#: ../doc/reference/reference_lua/fiber.rst:240
#: ../doc/reference/reference_lua/fiber.rst:263
#: ../doc/reference/reference_lua/fiber.rst:283
#: ../doc/reference/reference_lua/fiber.rst:303
#: ../doc/reference/reference_lua/fiber.rst:318
#: ../doc/reference/reference_lua/fiber.rst:337
#: ../doc/reference/reference_lua/fiber.rst:356
#: ../doc/reference/reference_lua/fiber.rst:383
#: ../doc/reference/reference_lua/fiber.rst:409
#: ../doc/reference/reference_lua/fiber.rst:433
#: ../doc/reference/reference_lua/fiber.rst:458
#: ../doc/reference/reference_lua/fiber.rst:485
#: ../doc/reference/reference_lua/fiber.rst:508
#: ../doc/reference/reference_lua/fiber.rst:534
#: ../doc/reference/reference_lua/fiber.rst:554
#: ../doc/reference/reference_lua/fiber.rst:622
#: ../doc/reference/reference_lua/fiber.rst:672
#: ../doc/reference/reference_lua/fiber.rst:705
#: ../doc/reference/reference_lua/fiber.rst:724
#: ../doc/reference/reference_lua/fio.rst:181
#: ../doc/reference/reference_lua/fio.rst:203
#: ../doc/reference/reference_lua/fio.rst:223
#: ../doc/reference/reference_lua/fio.rst:242
#: ../doc/reference/reference_lua/fio.rst:318
#: ../doc/reference/reference_lua/fio.rst:354
#: ../doc/reference/reference_lua/fio.rst:393
#: ../doc/reference/reference_lua/fio.rst:413
#: ../doc/reference/reference_lua/fio.rst:434
#: ../doc/reference/reference_lua/fio.rst:457
#: ../doc/reference/reference_lua/fio.rst:474
#: ../doc/reference/reference_lua/fio.rst:489
#: ../doc/reference/reference_lua/fio.rst:513
#: ../doc/reference/reference_lua/fio.rst:535
#: ../doc/reference/reference_lua/fio.rst:558
#: ../doc/reference/reference_lua/fio.rst:584
#: ../doc/reference/reference_lua/fio.rst:610
#: ../doc/reference/reference_lua/fio.rst:633
#: ../doc/reference/reference_lua/fio.rst:655
#: ../doc/reference/reference_lua/fio.rst:681
#: ../doc/reference/reference_lua/fio.rst:699
#: ../doc/reference/reference_lua/fio.rst:800
#: ../doc/reference/reference_lua/fio.rst:831
#: ../doc/reference/reference_lua/fio.rst:951
#: ../doc/reference/reference_lua/fio.rst:971
#: ../doc/reference/reference_lua/fio.rst:996
#: ../doc/reference/reference_lua/fio.rst:1017
#: ../doc/reference/reference_lua/fio.rst:1050
#: ../doc/reference/reference_lua/fio.rst:1072
#: ../doc/reference/reference_lua/http.rst:83
#: ../doc/reference/reference_lua/iconv.rst:57
#: ../doc/reference/reference_lua/iconv.rst:78
#: ../doc/reference/reference_lua/jit.rst:58
#: ../doc/reference/reference_lua/jit.rst:76
#: ../doc/reference/reference_lua/jit.rst:92
#: ../doc/reference/reference_lua/jit.rst:110
#: ../doc/reference/reference_lua/jit.rst:134
#: ../doc/reference/reference_lua/json.rst:56
#: ../doc/reference/reference_lua/json.rst:95
#: ../doc/reference/reference_lua/json.rst:126
#: ../doc/reference/reference_lua/net_box.rst:232
#: ../doc/reference/reference_lua/net_box.rst:248
#: ../doc/reference/reference_lua/net_box.rst:263
#: ../doc/reference/reference_lua/net_box.rst:304
#: ../doc/reference/reference_lua/net_box.rst:317
#: ../doc/reference/reference_lua/net_box.rst:339
#: ../doc/reference/reference_lua/net_box.rst:352
#: ../doc/reference/reference_lua/net_box.rst:365
#: ../doc/reference/reference_lua/net_box.rst:378
#: ../doc/reference/reference_lua/net_box.rst:474
#: ../doc/reference/reference_lua/net_box.rst:526
#: ../doc/reference/reference_lua/osmodule.rst:88
#: ../doc/reference/reference_lua/osmodule.rst:111
#: ../doc/reference/reference_lua/osmodule.rst:130
#: ../doc/reference/reference_lua/osmodule.rst:147
#: ../doc/reference/reference_lua/osmodule.rst:165
#: ../doc/reference/reference_lua/osmodule.rst:180
#: ../doc/reference/reference_lua/osmodule.rst:193
#: ../doc/reference/reference_lua/osmodule.rst:208
#: ../doc/reference/reference_lua/osmodule.rst:223
#: ../doc/reference/reference_lua/osmodule.rst:238
#: ../doc/reference/reference_lua/osmodule.rst:253
#: ../doc/reference/reference_lua/osmodule.rst:269
#: ../doc/reference/reference_lua/osmodule.rst:284
#: ../doc/reference/reference_lua/other.rst:38
#: ../doc/reference/reference_lua/other.rst:78
#: ../doc/reference/reference_lua/pickle.rst:91
#: ../doc/reference/reference_lua/pickle.rst:138
#: ../doc/reference/reference_lua/socket.rst:138
#: ../doc/reference/reference_lua/socket.rst:156
#: ../doc/reference/reference_lua/socket.rst:175
#: ../doc/reference/reference_lua/socket.rst:257
#: ../doc/reference/reference_lua/socket.rst:416
#: ../doc/reference/reference_lua/strict.rst:18
#: ../doc/reference/reference_lua/string.rst:72
#: ../doc/reference/reference_lua/string.rst:97
#: ../doc/reference/reference_lua/string.rst:120
#: ../doc/reference/reference_lua/string.rst:150
#: ../doc/reference/reference_lua/string.rst:180
#: ../doc/reference/reference_lua/string.rst:204
#: ../doc/reference/reference_lua/string.rst:227
#: ../doc/reference/reference_lua/string.rst:257
#: ../doc/reference/reference_lua/string.rst:282
#: ../doc/reference/reference_lua/table.rst:44
#: ../doc/reference/reference_lua/tap.rst:179
#: ../doc/reference/reference_lua/tap.rst:225
#: ../doc/reference/reference_lua/tarantool.rst:20
#: ../doc/reference/reference_lua/uri.rst:65
#: ../doc/reference/reference_lua/uri.rst:92
#: ../doc/reference/reference_lua/utf8.rst:72
#: ../doc/reference/reference_lua/utf8.rst:101
#: ../doc/reference/reference_lua/utf8.rst:130
#: ../doc/reference/reference_lua/utf8.rst:154
#: ../doc/reference/reference_lua/utf8.rst:176
#: ../doc/reference/reference_lua/utf8.rst:198
#: ../doc/reference/reference_lua/utf8.rst:220
#: ../doc/reference/reference_lua/utf8.rst:252
#: ../doc/reference/reference_lua/utf8.rst:276
#: ../doc/reference/reference_lua/utf8.rst:297
#: ../doc/reference/reference_lua/utf8.rst:335
#: ../doc/reference/reference_lua/utf8.rst:357
#: ../doc/reference/reference_lua/xlog.rst:27
#: ../doc/reference/reference_rock/dbms.rst:188
#: ../doc/reference/reference_rock/dbms.rst:212
#: ../doc/reference/reference_rock/dbms.rst:236
#: ../doc/reference/reference_rock/dbms.rst:530
#: ../doc/reference/reference_rock/dbms.rst:554
#: ../doc/reference/reference_rock/dbms.rst:577
#: ../doc/reference/reference_rock/vshard/index.rst:1057
#: ../doc/reference/reference_rock/vshard/index.rst:1128
#: ../doc/reference/reference_rock/vshard/index.rst:1426
#: ../doc/reference/reference_rock/vshard/index.rst:1441
#: ../doc/reference/reference_rock/vshard/index.rst:1458
#: ../doc/reference/reference_rock/vshard/index.rst:1519
msgid "**Example:**"
msgstr ""

#: ../doc/reference/reference_lua/box_backup.rst:31
msgid "tarantool> box.backup.start()\n"
"---\n"
"- - ./00000000000000000015.snap\n"
"  - ./00000000000000000000.vylog\n"
"  - ./513/0/00000000000000000002.index\n"
"  - ./513/0/00000000000000000002.run\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/box_backup.rst:45
msgid "informs the server that normal operations may resume."
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:3
msgid "Submodule `box.error`"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:9
#: ../doc/reference/reference_lua/clock.rst:9
#: ../doc/reference/reference_lua/console.rst:9
#: ../doc/reference/reference_lua/crypto.rst:11
#: ../doc/reference/reference_lua/csv.rst:9
#: ../doc/reference/reference_lua/debug_facilities.rst:9
#: ../doc/reference/reference_lua/digest.rst:11
#: ../doc/reference/reference_lua/errno.rst:11
#: ../doc/reference/reference_lua/fiber.rst:9
#: ../doc/reference/reference_lua/fio.rst:11
#: ../doc/reference/reference_lua/http.rst:11
#: ../doc/reference/reference_lua/iconv.rst:11
#: ../doc/reference/reference_lua/jit.rst:11
#: ../doc/reference/reference_lua/json.rst:9
#: ../doc/reference/reference_lua/log.rst:11
#: ../doc/reference/reference_lua/msgpack.rst:9
#: ../doc/reference/reference_lua/net_box.rst:9
#: ../doc/reference/reference_lua/osmodule.rst:11
#: ../doc/reference/reference_lua/socket.rst:9
#: ../doc/reference/reference_lua/string.rst:9
#: ../doc/reference/reference_lua/tap.rst:7
#: ../doc/reference/reference_lua/uri.rst:7
#: ../doc/reference/reference_lua/utf8.rst:9
#: ../doc/reference/reference_lua/uuid.rst:7
#: ../doc/reference/reference_lua/yaml.rst:9
msgid "Overview"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:11
msgid "The ``box.error`` function is for raising an error. The difference between this function and Lua's built-in `error <https://www.lua.org/pil/8.3.html>`_ function is that when the error reaches the client, its error code is preserved. In contrast, a Lua error would always be presented to the client as :errcode:`ER_PROC_LUA`."
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:19
#: ../doc/reference/reference_lua/clock.rst:18
#: ../doc/reference/reference_lua/console.rst:17
#: ../doc/reference/reference_lua/crypto.rst:22
#: ../doc/reference/reference_lua/csv.rst:41
#: ../doc/reference/reference_lua/debug_facilities.rst:33
#: ../doc/reference/reference_lua/digest.rst:22
#: ../doc/reference/reference_lua/errno.rst:19
#: ../doc/reference/reference_lua/fiber.rst:22
#: ../doc/reference/reference_lua/fio.rst:27
#: ../doc/reference/reference_lua/http.rst:19
#: ../doc/reference/reference_lua/iconv.rst:24
#: ../doc/reference/reference_lua/jit.rst:20
#: ../doc/reference/reference_lua/json.rst:18
#: ../doc/reference/reference_lua/log.rst:46
#: ../doc/reference/reference_lua/msgpack.rst:18
#: ../doc/reference/reference_lua/net_box.rst:71
#: ../doc/reference/reference_lua/osmodule.rst:28
#: ../doc/reference/reference_lua/other.rst:7
#: ../doc/reference/reference_lua/pickle.rst:7
#: ../doc/reference/reference_lua/socket.rst:28
#: ../doc/reference/reference_lua/tap.rst:17
#: ../doc/reference/reference_lua/uri.rst:35
#: ../doc/reference/reference_lua/uuid.rst:17
#: ../doc/reference/reference_lua/yaml.rst:16
msgid "Index"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:21
msgid "Below is a list of all ``box.error`` functions."
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:29
#: ../doc/reference/reference_lua/clock.rst:28
#: ../doc/reference/reference_lua/console.rst:27
#: ../doc/reference/reference_lua/crypto.rst:32
#: ../doc/reference/reference_lua/csv.rst:51
#: ../doc/reference/reference_lua/debug_facilities.rst:43
#: ../doc/reference/reference_lua/digest.rst:32
#: ../doc/reference/reference_lua/errno.rst:29
#: ../doc/reference/reference_lua/fiber.rst:32
#: ../doc/reference/reference_lua/fio.rst:39
#: ../doc/reference/reference_lua/http.rst:29
#: ../doc/reference/reference_lua/iconv.rst:34
#: ../doc/reference/reference_lua/jit.rst:30
#: ../doc/reference/reference_lua/json.rst:28
#: ../doc/reference/reference_lua/log.rst:56
#: ../doc/reference/reference_lua/msgpack.rst:28
#: ../doc/reference/reference_lua/net_box.rst:81
#: ../doc/reference/reference_lua/osmodule.rst:38
#: ../doc/reference/reference_lua/other.rst:17
#: ../doc/reference/reference_lua/pickle.rst:17
#: ../doc/reference/reference_lua/socket.rst:38
#: ../doc/reference/reference_lua/string.rst:28
#: ../doc/reference/reference_lua/tap.rst:27
#: ../doc/reference/reference_lua/uri.rst:45
#: ../doc/reference/reference_lua/utf8.rst:27
#: ../doc/reference/reference_lua/uuid.rst:27
#: ../doc/reference/reference_lua/yaml.rst:26
#: ../doc/reference/reference_rock/membership.rst:78
msgid "Name"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:29
#: ../doc/reference/reference_lua/clock.rst:28
#: ../doc/reference/reference_lua/console.rst:27
#: ../doc/reference/reference_lua/crypto.rst:32
#: ../doc/reference/reference_lua/csv.rst:51
#: ../doc/reference/reference_lua/debug_facilities.rst:43
#: ../doc/reference/reference_lua/digest.rst:32
#: ../doc/reference/reference_lua/errno.rst:29
#: ../doc/reference/reference_lua/fiber.rst:32
#: ../doc/reference/reference_lua/fio.rst:39
#: ../doc/reference/reference_lua/http.rst:29
#: ../doc/reference/reference_lua/iconv.rst:34
#: ../doc/reference/reference_lua/jit.rst:30
#: ../doc/reference/reference_lua/json.rst:28
#: ../doc/reference/reference_lua/log.rst:56
#: ../doc/reference/reference_lua/msgpack.rst:28
#: ../doc/reference/reference_lua/net_box.rst:81
#: ../doc/reference/reference_lua/osmodule.rst:38
#: ../doc/reference/reference_lua/other.rst:17
#: ../doc/reference/reference_lua/pickle.rst:17
#: ../doc/reference/reference_lua/socket.rst:38
#: ../doc/reference/reference_lua/string.rst:28
#: ../doc/reference/reference_lua/tap.rst:27
#: ../doc/reference/reference_lua/uri.rst:45
#: ../doc/reference/reference_lua/utf8.rst:27
#: ../doc/reference/reference_lua/uuid.rst:27
#: ../doc/reference/reference_lua/yaml.rst:26
#: ../doc/reference/reference_rock/membership.rst:78
msgid "Use"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:31
msgid ":ref:`box.error() <box_error-error>`"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:31
msgid "Throw an error"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:34
msgid ":ref:`box.error.last() <box_error-last>`"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:34
msgid "Get a description of the last error"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:37
msgid ":ref:`box.error.clear() <box_error-clear>`"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:37
msgid "Clear the record of errors"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:40
msgid ":ref:`box.error.new() <box_error-new>`"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:40
msgid "Create an error but do not throw"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:46
msgid "When called with a Lua-table argument, the code and reason have any user-desired values. The result will be those values."
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:49
msgid "description of an error, defined by user"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:50
msgid "numeric code for this error, defined by user"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:54
msgid "When called without arguments, ``box.error()`` re-throws whatever the last error was."
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:61
msgid "Emulate a request error, with text based on one of the pre-defined Tarantool errors defined in the file `errcode.h <https://github.com/tarantool/tarantool/blob/1.10/src/box/errcode.h>`_ in the source tree. Lua constants which correspond to those Tarantool errors are defined as members of ``box.error``, for example ``box.error.NO_SUCH_USER == 45``."
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:67
#: ../doc/reference/reference_lua/box_error.rst:157
msgid "number of a pre-defined error"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:68
#: ../doc/reference/reference_lua/box_error.rst:158
msgid "part of the message which will accompany the error"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:72
msgid "the ``NO_SUCH_USER`` message is \"``User '%s' is not found``\" -- it includes one \"``%s``\" component which will be replaced with errtext. Thus a call to ``box.error(box.error.NO_SUCH_USER, 'joe')`` or ``box.error(45, 'joe')`` will result in an error with the accompanying message \"``User 'joe' is not found``\"."
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:0
msgid "except"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:78
msgid "whatever is specified in errcode-number."
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:82
msgid "tarantool> box.error{code = 555, reason = 'Arbitrary message'}\n"
"---\n"
"- error: Arbitrary message\n"
"...\n"
"tarantool> box.error()\n"
"---\n"
"- error: Arbitrary message\n"
"...\n"
"tarantool> box.error(box.error.FUNCTION_ACCESS_DENIED, 'A', 'B', 'C')\n"
"---\n"
"- error: A access denied for user 'B' to function 'C'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:101
msgid "Returns a description of the last error, as a Lua table with five members: \"line\" (number) Tarantool source file line number, \"code\" (number) error's number, \"type\", (string) error's C++ class, \"message\" (string) error's message, \"file\" (string) Tarantool source file. Additionally, if the error is a system error (for example due to a failure in socket or file io), there may be a sixth member: \"errno\" (number) C standard error number."
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:111
msgid "rtype: table"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:117
msgid "Clears the record of errors, so functions like `box.error()` or `box.error.last()` will have no effect."
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:122
msgid "tarantool> box.error{code = 555, reason = 'Arbitrary message'}\n"
"---\n"
"- error: Arbitrary message\n"
"...\n"
"tarantool> box.schema.space.create('#')\n"
"---\n"
"- error: Invalid identifier '#' (expected letters, digits or an underscore)\n"
"...\n"
"tarantool> box.error.last()\n"
"---\n"
"- line: 278\n"
"  code: 70\n"
"  type: ClientError\n"
"  message: Invalid identifier '#' (expected letters, digits or an underscore)\n"
"  file: /tmp/buildd/tarantool-1.7.0.252.g1654e31~precise/src/box/key_def.cc\n"
"...\n"
"tarantool> box.error.clear()\n"
"---\n"
"...\n"
"tarantool> box.error.last()\n"
"---\n"
"- null\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:152
msgid "Create an error object, but do not throw. This is useful when error information should be saved for later retrieval. The parameters are the same as for :ref:`box.error() <box_error-error>`, see the description there."
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:162
msgid "tarantool> e = box.error.new{code = 555, reason = 'Arbitrary message'}\n"
"---\n"
"...\n"
"tarantool> e:unpack()\n"
"---\n"
"- type: ClientError\n"
"  code: 555\n"
"  message: Arbitrary message\n"
"  trace:\n"
"  - file: '[string \"e = box.error.new{code = 555, reason = ''Arbit...\"]'\n"
"    line: 1\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/box_once.rst:5
msgid "Function `box.once`"
msgstr ""

#: ../doc/reference/reference_lua/box_once.rst:9
msgid "Execute a function, provided it has not been executed before. A passed value is checked to see whether the function has already been executed. If it has been executed before, nothing happens. If it has not been executed before, the function is invoked."
msgstr ""

#: ../doc/reference/reference_lua/box_once.rst:14
msgid "See an example of using ``box.once()`` while :ref:`bootstrapping a replica set <replication-bootstrap>`."
msgstr ""

#: ../doc/reference/reference_lua/box_once.rst:17
msgid "If an error occurs inside ``box.once()`` when initializing a database, you can re-execute the failed ``box.once()`` block without stopping the database. The solution is to delete the ``once`` object from the system space :ref:`_schema <box_space-schema>`. Say ``box.space._schema:select{}``, find your ``once`` object there and delete it. For example, re-executing a block with ``key='hello'`` :"
msgstr ""

#: ../doc/reference/reference_lua/box_once.rst:24
msgid "When ``box.once()`` is used for initialization, it may be useful to wait until the database is in an appropriate state (read-only or read-write). In that case, see the functions in the :ref:`box.ctl submodule <box_ctl>`."
msgstr ""

#: ../doc/reference/reference_lua/box_once.rst:28
msgid "tarantool> box.space._schema:select{}\n"
"---\n"
"- - ['cluster', 'b4e15788-d962-4442-892e-d6c1dd5d13f2']\n"
"  - ['max_id', 512]\n"
"  - ['oncebye']\n"
"  - ['oncehello']\n"
"  - ['version', 1, 7, 2]\n"
"...\n"
"\n"
"tarantool> box.space._schema:delete('oncehello')\n"
"---\n"
"- ['oncehello']\n"
"...\n"
"\n"
"tarantool> box.once('hello', function() end)\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/box_once.rst:48
msgid "a value that will be checked"
msgstr ""

#: ../doc/reference/reference_lua/box_once.rst:49
msgid "a function"
msgstr ""

#: ../doc/reference/reference_lua/box_once.rst:50
msgid "arguments that must be passed to function"
msgstr ""

#: ../doc/reference/reference_lua/box_snapshot.rst:5
msgid "Function `box.snapshot`"
msgstr ""

#: ../doc/reference/reference_lua/box_snapshot.rst:9
msgid "Take a snapshot of all data and store it in :ref:`memtx_dir <cfg_basic-memtx_dir>`:samp:`/{<latest-lsn>}.snap`. To take a snapshot, Tarantool first enters the delayed garbage collection mode for all data. In this mode, the :ref:`Tarantool garbage collector <cfg_checkpoint_daemon-garbage-collector>` will not remove files which were created before the snapshot started, it will not remove them until the snapshot has finished. To preserve consistency of the primary key, used to iterate over tuples, a copy-on-write technique is employed. If the master process changes part of a primary key, the corresponding process page is split, and the snapshot process obtains an old copy of the page. In effect, the snapshot process uses multi-version concurrency control in order to avoid copying changes which are superseded while it is running."
msgstr ""

#: ../doc/reference/reference_lua/box_snapshot.rst:23
msgid "Since a snapshot is written sequentially, one can expect a very high write performance (averaging to 80MB/second on modern disks), which means an average database instance gets saved in a matter of minutes. Users may restrict the speed by changing :ref:`snap_io_rate_limit <cfg_binary_logging_snapshots-snap_io_rate_limit>`."
msgstr ""

#: ../doc/reference/reference_lua/box_snapshot.rst:31
msgid "As long as there are any changes to the parent index memory through concurrent updates, there are going to be page splits, and therefore you need to have some extra free memory to run this command. 10% of :ref:`memtx_memory <cfg_storage-memtx_memory>` is, on average, sufficient. This statement waits until a snapshot is taken and returns operation result."
msgstr ""

#: ../doc/reference/reference_lua/box_snapshot.rst:39
msgid "**Change notice:** Prior to Tarantool version 1.6.6, the snapshot process caused a fork, which could cause occasional latency spikes. Starting with Tarantool version 1.6.6, the snapshot process creates a consistent read view and this view is written to the snapshot file by a separate thread (the \"Write Ahead Log\" thread)."
msgstr ""

#: ../doc/reference/reference_lua/box_snapshot.rst:45
msgid "Although ``box.snapshot()`` does not cause a fork, there is a separate fiber which may produce snapshots at regular intervals -- see the discussion of the :ref:`checkpoint daemon <book_cfg_checkpoint_daemon>`."
msgstr ""

#: ../doc/reference/reference_lua/box_snapshot.rst:51
msgid "tarantool> box.info.version\n"
"---\n"
"- 1.7.0-1216-g73f7154\n"
"...\n"
"tarantool> box.snapshot()\n"
"---\n"
"- ok\n"
"...\n"
"tarantool> box.snapshot()\n"
"---\n"
"- error: can't save snapshot, errno 17 (File exists)\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/box_snapshot.rst:66
msgid "Taking a snapshot does not cause the server to start a new write-ahead log. Once a snapshot is taken, old WALs can be deleted as long as all replicated data is up to date. But the WAL which was current at the time ``box.snapshot()`` started must be kept for recovery, since it still contains log records written after the start of ``box.snapshot()``."
msgstr ""

#: ../doc/reference/reference_lua/box_snapshot.rst:72
msgid "An alternative way to save a snapshot is to send a SIGUSR1 signal to the instance. While this approach could be handy, it is not recommended for use in automation: a signal provides no way to find out whether the snapshot was taken successfully or not."
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:5
msgid "Module `buffer`"
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:7
msgid "The ``buffer`` module returns a dynamically resizable buffer which is solely for use as an option for methods of the :ref:`net.box module <net_box-module>`."
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:10
msgid "Ordinarily the ``net.box`` methods return a Lua table. If a ``buffer`` option is used, then the ``net.box`` methods return a raw MsgPack_ string. This saves time on the server, if the client application has its own routine for decoding MsgPack strings."
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:0
#: ../doc/reference/reference_lua/clock.rst:0
#: ../doc/reference/reference_lua/clock.rst:0
#: ../doc/reference/reference_lua/clock.rst:0
#: ../doc/reference/reference_lua/clock.rst:0
#: ../doc/reference/reference_lua/clock.rst:0
#: ../doc/reference/reference_lua/console.rst:0
#: ../doc/reference/reference_lua/csv.rst:0
#: ../doc/reference/reference_lua/csv.rst:0
#: ../doc/reference/reference_lua/csv.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/debug_facilities.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/http.rst:0
#: ../doc/reference/reference_lua/http.rst:0
#: ../doc/reference/reference_lua/iconv.rst:0
#: ../doc/reference/reference_lua/iconv.rst:0
#: ../doc/reference/reference_lua/json.rst:0
#: ../doc/reference/reference_lua/json.rst:0
#: ../doc/reference/reference_lua/log.rst:0
#: ../doc/reference/reference_lua/log.rst:0
#: ../doc/reference/reference_lua/log.rst:0
#: ../doc/reference/reference_lua/msgpack.rst:0
#: ../doc/reference/reference_lua/msgpack.rst:0
#: ../doc/reference/reference_lua/msgpack.rst:0
#: ../doc/reference/reference_lua/net_box.rst:0
#: ../doc/reference/reference_lua/net_box.rst:0
#: ../doc/reference/reference_lua/net_box.rst:0
#: ../doc/reference/reference_lua/net_box.rst:0
#: ../doc/reference/reference_lua/net_box.rst:0
#: ../doc/reference/reference_lua/other.rst:0
#: ../doc/reference/reference_lua/pickle.rst:0
#: ../doc/reference/reference_lua/pickle.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/uri.rst:0
#: ../doc/reference/reference_lua/uri.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/yaml.rst:0
#: ../doc/reference/reference_lua/yaml.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
msgid "return"
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:20
msgid "a descriptor of a buffer."
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:0
#: ../doc/reference/reference_lua/clock.rst:0
#: ../doc/reference/reference_lua/clock.rst:0
#: ../doc/reference/reference_lua/clock.rst:0
#: ../doc/reference/reference_lua/clock.rst:0
#: ../doc/reference/reference_lua/csv.rst:0
#: ../doc/reference/reference_lua/csv.rst:0
#: ../doc/reference/reference_lua/csv.rst:0
#: ../doc/reference/reference_lua/errno.rst:0
#: ../doc/reference/reference_lua/errno.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/fio.rst:0
#: ../doc/reference/reference_lua/http.rst:0
#: ../doc/reference/reference_lua/http.rst:0
#: ../doc/reference/reference_lua/iconv.rst:0
#: ../doc/reference/reference_lua/json.rst:0
#: ../doc/reference/reference_lua/json.rst:0
#: ../doc/reference/reference_lua/msgpack.rst:0
#: ../doc/reference/reference_lua/msgpack.rst:0
#: ../doc/reference/reference_lua/msgpack.rst:0
#: ../doc/reference/reference_lua/net_box.rst:0
#: ../doc/reference/reference_lua/net_box.rst:0
#: ../doc/reference/reference_lua/net_box.rst:0
#: ../doc/reference/reference_lua/net_box.rst:0
#: ../doc/reference/reference_lua/net_box.rst:0
#: ../doc/reference/reference_lua/pickle.rst:0
#: ../doc/reference/reference_lua/pickle.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/socket.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/tap.rst:0
#: ../doc/reference/reference_lua/uri.rst:0
#: ../doc/reference/reference_lua/uri.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/utf8.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/uuid.rst:0
#: ../doc/reference/reference_lua/xlog.rst:0
#: ../doc/reference/reference_lua/yaml.rst:0
#: ../doc/reference/reference_lua/yaml.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
msgid "rtype"
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:21
#: ../doc/reference/reference_lua/uuid.rst:61
#: ../doc/reference/reference_lua/uuid.rst:83
#: ../doc/reference/reference_lua/uuid.rst:91
msgid "cdata"
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:25
msgid "Assume a Tarantool server is listening on farhost:3301. Assume it has a space ``T`` with one tuple: ``'ABCDE', 12345``. In this example we start up a server on localhost:3302 and then use ``net.box`` routines to connect to farhost. Then we create a buffer, and use it as an option for a ``conn.space...select()`` call. The result will be in MsgPack_ format. To show this, we will use :ref:`msgpack.decode_unchecked() <msgpack-decode_unchecked>` on ``ibuf.rpos`` (the \"read position\" of the buffer). Thus we do not decode on the remote server, but we do decode on the local server."
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:38
msgid "box.cfg{listen=3302}\n"
"buffer = require('buffer')\n"
"ibuf = buffer.ibuf()\n"
"net_box = require('net.box')\n"
"conn = net_box.connect('farhost:3301')\n"
"buffer = require('buffer')\n"
"conn.space.T:select({},{buffer=ibuf})\n"
"msgpack = require('msgpack')\n"
"msgpack.decode_unchecked(ibuf.rpos)"
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:50
msgid "The result of the final request looks like this:"
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:52
msgid "tarantool> msgpack.decode_unchecked(ibuf.rpos)\n"
"---\n"
"- {48: [['ABCDE', 12345]]}\n"
"- 'cdata<char *>: 0x7f97ba10c041'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/buffer.rst:62
msgid "Before Tarantool version 1.7.7, the function to use for this case is ``msgpack.ibuf_decode(ibuf.rpos)``. Starting with Tarantool version 1.7.7, ``ibuf_decode`` is deprecated."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:5
msgid "Module `clock`"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:11
msgid "The ``clock`` module returns time values derived from the Posix / C CLOCK_GETTIME_ function or equivalent. Most functions in the module return a number of seconds; functions whose names end in \"64\" return a 64-bit number of nanoseconds."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:20
msgid "Below is a list of all ``clock`` functions."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:30
msgid ":ref:`clock.time() <clock-time>` |br| :ref:`clock.realtime() <clock-time>`"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:31
msgid "Get the wall clock time in seconds"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:35
msgid ":ref:`clock.time64() <clock-time>` |br| :ref:`clock.realtime64() <clock-time>`"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:36
msgid "Get the wall clock time in nanoseconds"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:40
msgid ":ref:`clock.monotonic() <clock-monotonic>`"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:40
msgid "Get the monotonic time in seconds"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:43
msgid ":ref:`clock.monotonic64() <clock-monotonic>`"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:43
msgid "Get the monotonic time in nanoseconds"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:46
msgid ":ref:`clock.proc() <clock-proc>`"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:46
msgid "Get the processor time in seconds"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:49
msgid ":ref:`clock.proc64() <clock-proc>`"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:49
msgid "Get the processor time in nanoseconds"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:52
msgid ":ref:`clock.thread() <clock-thread>`"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:52
msgid "Get the thread time in seconds"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:55
msgid ":ref:`clock.thread64() <clock-thread>`"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:55
msgid "Get the thread time in nanoseconds"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:58
msgid ":ref:`clock.bench() <clock-bench>`"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:58
msgid "Measure the time a function takes within a processor"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:71
msgid "The wall clock time. Derived from C function clock_gettime(CLOCK_REALTIME). This is the best function for knowing what the official time is, as determined by the system administrator."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:75
msgid "seconds or nanoseconds since epoch (1970-01-01 00:00:00), adjusted."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:76
#: ../doc/reference/reference_lua/clock.rst:101
#: ../doc/reference/reference_lua/clock.rst:122
#: ../doc/reference/reference_lua/clock.rst:143
msgid "number or number64"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:80
msgid "-- This will print an approximate number of years since 1970.\n"
"clock = require('clock')\n"
"print(clock.time() / (365*24*60*60))"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:86
msgid "See also :ref:`fiber.time64 <fiber-time64>` and the standard Lua function `os.clock <http://www.lua.org/manual/5.1/manual.html#pdf-os.clock>`_."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:94
msgid "The monotonic time. Derived from C function clock_gettime(CLOCK_MONOTONIC). Monotonic time is similar to wall clock time but is not affected by changes to or from daylight saving time, or by changes done by a user. This is the best function to use with benchmarks that need to calculate elapsed time."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:100
msgid "seconds or nanoseconds since the last time that the computer was booted."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:105
msgid "-- This will print nanoseconds since the start.\n"
"clock = require('clock')\n"
"print(clock.monotonic64())"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:116
msgid "The processor time. Derived from C function ``clock_gettime(CLOCK_PROCESS_CPUTIME_ID)``. This is the best function to use with benchmarks that need to calculate how much time has been spent within a CPU."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:121
msgid "seconds or nanoseconds since processor start."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:126
msgid "-- This will print nanoseconds in the CPU since the start.\n"
"clock = require('clock')\n"
"print(clock.proc64())"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:137
msgid "The thread time. Derived from C function ``clock_gettime(CLOCK_THREAD_CPUTIME_ID)``. This is the best function to use with benchmarks that need to calculate how much time has been spent within a thread within a CPU."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:142
msgid "seconds or nanoseconds since the transaction processor thread started."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:147
msgid "-- This will print seconds in the thread since the start.\n"
"clock = require('clock')\n"
"print(clock.thread64())"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:157
msgid "The time that a function takes within a processor. This function uses ``clock.proc()``, therefore it calculates elapsed CPU time. Therefore it is not useful for showing actual elapsed time."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:161
msgid "function or function reference"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:162
msgid "whatever values are required by the function."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:164
msgid "**table**. first element - seconds of CPU time, second element - whatever the function returns."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:169
msgid "-- Benchmark a function which sleeps 10 seconds.\n"
"-- NB: bench() will not calculate sleep time.\n"
"-- So the returned value will be {a number less than 10, 88}.\n"
"clock = require('clock')\n"
"fiber = require('fiber')\n"
"function f(param)\n"
"  fiber.sleep(param)\n"
"  return 88\n"
"end\n"
"clock.bench(f, 10)"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:5
msgid "Module `console`"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:11
msgid "The console module allows one Tarantool instance to access another Tarantool instance, and allows one Tarantool instance to start listening on an :ref:`admin port <admin-security>`."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:19
msgid "Below is a list of all ``console`` functions."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:29
msgid ":ref:`console.connect() <console-connect>`"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:29
msgid "Connect to an instance"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:32
msgid ":ref:`console.listen() <console-listen>`"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:32
msgid "Listen for incoming requests"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:35
msgid ":ref:`console.start() <console-start>`"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:35
msgid "Start the console"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:38
msgid ":ref:`console.ac() <console-ac>`"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:38
msgid "Set the auto-completion flag"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:41
msgid ":ref:`console.delimiter() <console-delimiter>`"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:41
msgid "Set a delimiter"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:51
msgid "Connect to the instance at :ref:`URI <index-uri>`, change the prompt from '``tarantool>``' to ':samp:`{uri}>`', and act henceforth as a client until the user ends the session or types ``control-D``."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:55
msgid "The console.connect function allows one Tarantool instance, in interactive mode, to access another Tarantool instance. Subsequent requests will appear to be handled locally, but in reality the requests are being sent to the remote instance and the local instance is acting as a client. Once connection is successful, the prompt will change and subsequent requests are sent to, and executed on, the remote instance. Results are displayed on the local instance. To return to local mode, enter ``control-D``."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:63
msgid "If the Tarantool instance at :samp:`uri` requires authentication, the connection might look something like: ``console.connect('admin:secretpassword@distanthost.com:3301')``."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:67
msgid "There are no restrictions on the types of requests that can be entered, except those which are due to privilege restrictions -- by default the login to the remote instance is done with user name = 'guest'. The remote instance could allow for this by granting at least one privilege: ``box.schema.user.grant('guest','execute','universe')``."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:73
msgid "the URI of the remote instance"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:74
#: ../doc/reference/reference_lua/fiber.rst:483
#: ../doc/reference/reference_lua/fiber.rst:530
#: ../doc/reference/reference_lua/fiber.rst:620
#: ../doc/reference/reference_lua/fiber.rst:1050
#: ../doc/reference/reference_lua/fiber.rst:1058
#: ../doc/reference/reference_lua/log.rst:115
#: ../doc/reference/reference_lua/log.rst:140
#: ../doc/reference/reference_lua/msgpack.rst:220
#: ../doc/reference/reference_lua/tap.rst:129
#: ../doc/reference/reference_lua/tap.rst:163
#: ../doc/reference/reference_lua/tap.rst:223
msgid "nil"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:76
msgid "Possible errors: the connection will fail if the target Tarantool instance was not initiated with ``box.cfg{listen=...}``."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:81
msgid "tarantool> console = require('console')\n"
"---\n"
"...\n"
"tarantool> console.connect('198.18.44.44:3301')\n"
"---\n"
"...\n"
"198.18.44.44:3301> -- prompt is telling us that instance is remote"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:95
msgid "Listen on :ref:`URI <index-uri>`. The primary way of listening for incoming requests is via the connection-information string, or URI, specified in ``box.cfg{listen=...}``. The alternative way of listening is via the URI specified in ``console.listen(...)``. This alternative way is called \"administrative\" or simply :ref:`\"admin port\" <admin-security>`. The listening is usually over a local host with a Unix domain socket."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:102
msgid "the URI of the local instance"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:104
msgid "The \"admin\" address is the URI to listen on. It has no default value, so it must be specified if connections will occur via an admin port. The parameter is expressed with URI = Universal Resource Identifier format, for example \"/tmpdir/unix_domain_socket.sock\", or a numeric TCP port. Connections are often made with telnet. A typical port value is 3313."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:112
msgid "tarantool> console = require('console')\n"
"---\n"
"...\n"
"tarantool> console.listen('unix/:/tmp/X.sock')\n"
"... main/103/console/unix/:/tmp/X I> started\n"
"---\n"
"- fd: 6\n"
"  name:\n"
"    host: unix/\n"
"    family: AF_UNIX\n"
"    type: SOCK_STREAM\n"
"    protocol: 0\n"
"    port: /tmp/X.sock\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:133
msgid "Start the console on the current interactive terminal."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:137
msgid "A special use of ``console.start()`` is with :ref:`initialization files <index-init_label>`. Normally, if one starts the Tarantool instance with :samp:`tarantool {initialization file}` there is no console. This can be remedied by adding these lines at the end of the initialization file:"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:142
msgid "local console = require('console')\n"
"console.start()"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:151
msgid "Set the auto-completion flag. If auto-completion is `true`, and the user is using Tarantool as a client or the user is using Tarantool via ``console.connect()``, then hitting the TAB key may cause tarantool to complete a word automatically. The default auto-completion value is `true`."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:160
msgid "Set a custom end-of-request marker for Tarantool console."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:162
msgid "The default end-of-request marker is a newline (line feed). Custom markers are not necessary because Tarantool can tell when a multi-line request has not ended (for example, if it sees that a function declaration does not have an end keyword). Nonetheless for special needs, or for entering multi-line requests in older Tarantool versions, you can change the end-of-request marker. As a result, newline alone is not treated as end of request."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:170
msgid "To go back to normal mode, say: ``console.delimiter('')<marker>``"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:172
msgid "a custom end-of-request marker for Tarantool console"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:176
msgid "tarantool> console = require('console'); console.delimiter('!')\n"
"---\n"
"...\n"
"tarantool> function f ()\n"
"         > statement_1 = 'a'\n"
"         > statement_2 = 'b'\n"
"         > end!\n"
"---\n"
"...\n"
"tarantool> console.delimiter('')!\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:5
msgid "Module `crypto`"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:13
msgid "\"Crypto\" is short for \"Cryptography\", which generally refers to the production of a digest value from a function (usually a `Cryptographic hash function`_), applied against a string. Tarantool's ``crypto`` module supports ten types of cryptographic hash functions (AES_, DES_, DSS_, MD4_, MD5_, MDC2_, RIPEMD_, SHA-1_, SHA-2_). Some of the crypto functionality is also present in the :ref:`digest` module."
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:24
msgid "Below is a list of all ``crypto`` functions."
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:34
msgid ":ref:`crypto.cipher.{algorithm}.{cipher_mode}.encrypt() <crypto-cipher>`"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:34
msgid "Encrypt a string"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:37
msgid ":ref:`crypto.cipher.{algorithm}.{cipher_mode}.decrypt() <crypto-cipher>`"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:37
msgid "Decrypt a string"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:40
msgid ":ref:`crypto.digest.{algorithm}() <crypto-digest>`"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:40
msgid "Get a digest"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:43
msgid ":ref:`crypto.hmac.{algorithm}() <crypto-hmac>`"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:43
msgid "Get a hash key"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:53
msgid "Pass or return a cipher derived from the string, key, and (optionally, sometimes) initialization vector. The four choices of algorithms:"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:56
msgid "aes128 - aes-128 (with 192-bit binary strings using AES)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:57
msgid "aes192 - aes-192 (with 192-bit binary strings using AES)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:58
msgid "aes256 - aes-256 (with 256-bit binary strings using AES)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:59
msgid "des    - des (with 56-bit binary strings using DES, though DES is not recommended)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:62
msgid "Four choices of block cipher modes are also available:"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:64
msgid "cbc - Cipher Block Chaining"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:65
msgid "cfb - Cipher Feedback"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:66
msgid "ecb - Electronic Codebook"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:67
msgid "ofb - Output Feedback"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:69
msgid "For more information, read the article about `Encryption Modes`_"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:73
msgid "_16byte_iv='1234567890123456'\n"
"_16byte_pass='1234567890123456'\n"
"e=crypto.cipher.aes128.cbc.encrypt('string', _16byte_pass, _16byte_iv)\n"
"crypto.cipher.aes128.cbc.decrypt(e,  _16byte_pass, _16byte_iv)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:88
msgid "Pass or return a digest derived from the string. The eleven algorithm choices:"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:91
msgid "dss - dss (using DSS)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:92
msgid "dss1 - dss (using DSS-1)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:93
msgid "md4 - md4 (with 128-bit binary strings using MD4)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:94
msgid "md5 - md5 (with 128-bit binary strings using MD5)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:95
msgid "mdc2 - mdc2 (using MDC2)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:96
msgid "ripemd160 - ripemd (with 160-bit binary strings using RIPEMD-160)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:97
msgid "sha1 - sha-1 (with 160-bit binary strings using SHA-1)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:98
msgid "sha224 - sha-224 (with 224-bit binary strings using SHA-2)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:99
msgid "sha256 - sha-256 (with 256-bit binary strings using SHA-2)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:100
msgid "sha384 - sha-384 (with 384-bit binary strings using SHA-2)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:101
msgid "sha512 - sha-512(with 512-bit binary strings using SHA-2)."
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:105
msgid "crypto.digest.md4('string')\n"
"crypto.digest.sha512('string')"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:118
msgid "Pass a key and a string. The result is an `HMAC <https://en.wikipedia.org/wiki/HMAC>`_ message authentication code. The eight algorithm choices:"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:123
msgid "md4 or md4_hex - md4 (with 128-bit binary strings using MD4)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:124
msgid "md5 or md5_hex - md5 (with 128-bit binary strings using MD5)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:125
msgid "ripemd160 or ripemd160_hex - ripemd (with 160-bit binary strings using RIPEMD-160)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:126
msgid "sha1 or sha1_hex - sha-1 (with 160-bit binary strings using SHA-1)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:127
msgid "sha224 or sha224_hex - sha-224 (with 224-bit binary strings using SHA-2)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:128
msgid "sha256 or sha256_hex - sha-256 (with 256-bit binary strings using SHA-2)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:129
msgid "sha384 or sha384_hex - sha-384 (with 384-bit binary strings using SHA-2)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:130
msgid "sha512 or sha512_hex - sha-512(with 512-bit binary strings using SHA-2)."
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:134
msgid "crypto.hmac.md4('key', 'string')\n"
"crypto.hmac.md4_hex('key', 'string')"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:141
msgid "Incremental methods in the crypto module"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:143
msgid "Suppose that a digest is done for a string 'A', then a new part 'B' is appended to the string, then a new digest is required. The new digest could be recomputed for the whole string 'AB', but it is faster to take what was computed before for 'A' and apply changes based on the new part 'B'. This is called multi-step or \"incremental\" digesting, which Tarantool supports for all crypto functions."
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:149
msgid "crypto = require('crypto')\n"
"\n"
"-- print aes-192 digest of 'AB', with one step, then incrementally\n"
"key = 'key/key/key/key/key/key/'\n"
"iv =  'iviviviviviviviv'\n"
"print(crypto.cipher.aes192.cbc.encrypt('AB', key, iv))\n"
"c = crypto.cipher.aes192.cbc.encrypt.new(key)\n"
"c:init(nil, iv)\n"
"c:update('A')\n"
"c:update('B')\n"
"print(c:result())\n"
"c:free()\n"
"\n"
"-- print sha-256 digest of 'AB', with one step, then incrementally\n"
"print(crypto.digest.sha256('AB'))\n"
"c = crypto.digest.sha256.new()\n"
"c:init()\n"
"c:update('A')\n"
"c:update('B')\n"
"print(c:result())\n"
"c:free()"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:175
msgid "Getting the same results from digest and crypto modules"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:177
msgid "The following functions are equivalent. For example, the ``digest`` function and the ``crypto`` function will both produce the same result."
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:180
msgid "crypto.cipher.aes256.cbc.encrypt('x',b32,b16)==digest.aes256cbc.encrypt('x',b32,b16)\n"
"crypto.digest.md4('string') == digest.md4('string')\n"
"crypto.digest.md5('string') == digest.md5('string')\n"
"crypto.digest.sha1('string') == digest.sha1('string')\n"
"crypto.digest.sha224('string') == digest.sha224('string')\n"
"crypto.digest.sha256('string') == digest.sha256('string')\n"
"crypto.digest.sha384('string') == digest.sha384('string')\n"
"crypto.digest.sha512('string') == digest.sha512('string')"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:3
msgid "Module `csv`"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:11
msgid "The ``csv`` module handles records formatted according to Comma-Separated-Values (CSV) rules."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:14
msgid "The default formatting rules are:"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:16
msgid "Lua `escape sequences`_ such as \\\\n or \\\\10 are legal within strings but not within files,"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:18
msgid "Commas designate end-of-field,"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:19
msgid "Line feeds, or line feeds plus carriage returns, designate end-of-record,"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:20
msgid "Leading or trailing spaces are ignored,"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:21
msgid "Quote marks may enclose fields or parts of fields,"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:22
msgid "When enclosed by quote marks, commas and line feeds and spaces are treated as ordinary characters, and a pair of quote marks \"\" is treated as a single quote mark."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:28
msgid "The possible options which can be passed to csv functions are:"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:30
msgid ":samp:`delimiter = {string}` (default: comma) -- single-byte character to designate end-of-field"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:32
msgid ":samp:`quote_char = {string}` (default: quote mark) -- single-byte character to designate encloser of string"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:34
msgid ":samp:`chunk_size = {number}` (default: 4096) -- number of characters to read at once (usually for file-IO efficiency)"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:36
msgid ":samp:`skip_head_lines = {number}` (default: 0) -- number of lines to skip at the start (usually for a header)"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:43
msgid "Below is a list of all ``csv`` functions."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:53
msgid ":ref:`csv.load() <csv-load>`"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:53
msgid "Load a CSV file"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:56
msgid ":ref:`csv.dump() <csv-dump>`"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:56
msgid "Transform input into a CSV-formatted string"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:59
msgid ":ref:`csv.iterate() <csv-iterate>`"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:59
msgid "Iterate over CSV records"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:67
msgid "Get CSV-formatted input from ``readable`` and return a table as output. Usually ``readable`` is either a string or a file opened for reading. Usually :samp:`{options}` is not specified."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:71
msgid "a string, or any object which has a read() method, formatted according to the CSV rules"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:73
#: ../doc/reference/reference_lua/csv.rst:199
msgid "see :ref:`above <csv-options>`"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:74
msgid "loaded_value"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:75
#: ../doc/reference/reference_lua/fiber.rst:354
#: ../doc/reference/reference_lua/fio.rst:432
#: ../doc/reference/reference_lua/fio.rst:453
#: ../doc/reference/reference_lua/fio.rst:1015
#: ../doc/reference/reference_lua/http.rst:162
#: ../doc/reference/reference_lua/json.rst:93
#: ../doc/reference/reference_lua/pickle.rst:136
#: ../doc/reference/reference_lua/socket.rst:173
#: ../doc/reference/reference_lua/socket.rst:561
#: ../doc/reference/reference_lua/socket.rst:573
#: ../doc/reference/reference_lua/string.rst:255
#: ../doc/reference/reference_lua/table.rst:42
#: ../doc/reference/reference_lua/utf8.rst:292
#: ../doc/reference/reference_lua/yaml.rst:58
#: ../doc/reference/reference_rock/membership.rst:181
#: ../doc/reference/reference_rock/membership.rst:190
#: ../doc/reference/reference_rock/membership.rst:203
msgid "table"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:79
msgid "Readable string has 3 fields, field#2 has comma and space so use quote marks:"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:82
msgid "tarantool> csv = require('csv')\n"
"---\n"
"...\n"
"tarantool> csv.load('a,\"b,c \",d')\n"
"---\n"
"- - - a\n"
"    - 'b,c '\n"
"    - d\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:94
msgid "Readable string contains 2-byte character = Cyrillic Letter Palochka: (This displays a palochka if and only if character set = UTF-8.)"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:97
msgid "tarantool> csv.load('a\\\\211\\\\128b')\n"
"---\n"
"- - - a\\211\\128b\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:104
msgid "Semicolon instead of comma for the delimiter:"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:106
msgid "tarantool> csv.load('a,b;c,d', {delimiter = ';'})\n"
"---\n"
"- - - a,b\n"
"    - c,d\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:114
msgid "Readable file :file:`./file.csv` contains two CSV records. Explanation of ``fio`` is in section :ref:`fio <fio-section>`. Source CSV file and example respectively:"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:118
msgid "tarantool> -- input in file.csv is:\n"
"tarantool> -- a,\"b,c \",d\n"
"tarantool> -- a\\\\211\\\\128b\n"
"tarantool> fio = require('fio')\n"
"---\n"
"...\n"
"tarantool> f = fio.open('./file.csv', {'O_RDONLY'})\n"
"---\n"
"...\n"
"tarantool> csv.load(f, {chunk_size = 4096})\n"
"---\n"
"- - - a\n"
"    - 'b,c '\n"
"    - d\n"
"  - - a\\\\211\\\\128b\n"
"...\n"
"tarantool> f:close()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:145
msgid "Get table input from ``csv-table`` and return a CSV-formatted string as output. Or, get table input from ``csv-table`` and put the output in ``writable``. Usually :samp:`{options}` is not specified. Usually ``writable``, if specified, is a file opened for writing. :ref:`csv.dump() <csv-dump>` is the reverse of :ref:`csv.load() <csv-load>`."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:151
#: ../doc/reference/reference_lua/csv.rst:197
msgid "a table which can be formatted according to the CSV rules."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:153
msgid "optional. see :ref:`above <csv-options>`"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:154
msgid "any object which has a ``write()`` method"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:156
msgid "dumped_value"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:157
msgid "string, which is written to ``writable`` if specified"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:161
msgid "CSV-table has 3 fields, field#2 has \",\" so result has quote marks"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:163
msgid "tarantool> csv = require('csv')\n"
"---\n"
"...\n"
"tarantool> csv.dump({'a','b,c ','d'})\n"
"---\n"
"- 'a,\"b,c \",d\n"
"\n"
"'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:175
msgid "Round Trip: from string to table and back to string"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:177
msgid "tarantool> csv_table = csv.load('a,b,c')\n"
"---\n"
"...\n"
"tarantool> csv.dump(csv_table)\n"
"---\n"
"- 'a,b,c\n"
"\n"
"'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:193
msgid "Form a Lua iterator function for going through CSV records one field at a time. Use of an iterator is strongly recommended if the amount of data is large (ten or more megabytes)."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:201
msgid "Lua iterator function"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:202
msgid "iterator function"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:206
msgid ":ref:`csv.iterate() <csv-iterate>` is the low level of :ref:`csv.load() <csv-load>` and :ref:`csv.dump() <csv-dump>`. To illustrate that, here is a function which is the same as the :ref:`csv.load() <csv-load>` function, as seen in `the Tarantool source code`_."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:211
msgid "tarantool> load = function(readable, opts)\n"
"         >   opts = opts or {}\n"
"         >   local result = {}\n"
"         >   for i, tup in csv.iterate(readable, opts) do\n"
"         >     result[i] = tup\n"
"         >   end\n"
"         >   return result\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> load('a,b,c')\n"
"---\n"
"- - - a\n"
"    - b\n"
"    - c\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:5
msgid "Debug facilities"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:11
msgid "Tarantool users can benefit from built-in debug facilities that are part of:"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:13
msgid "Lua (`debug <https://www.lua.org/manual/5.1/manual.html#5.9>`_ library, see details below) and"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:15
msgid "LuaJit (`debug.* <http://luajit.org/extensions.html>`_ functions)."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:19
msgid "The ``debug`` library provides an interface for debugging Lua programs. All functions in this library reside in the ``debug`` table. Those functions that operate on a thread have an optional first parameter that specifies the thread to operate on. The default is always the current thread."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:26
msgid "This library should be used only for debugging and profiling and not as a regular programming tool, as the functions provided here can take too long to run. Besides, several of these functions can compromise otherwise secure code."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:35
msgid "Below is a list of all ``debug`` functions."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:45
msgid ":ref:`debug.debug() <debug-debug>`"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:45
msgid "Enter an interactive mode"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:48
msgid ":ref:`debug.getfenv() <debug-getfenv>`"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:48
msgid "Get an object's environment"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:51
msgid ":ref:`debug.gethook() <debug-gethook>`"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:51
msgid "Get a thread's current hook settings"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:54
msgid ":ref:`debug.getinfo() <debug-getinfo>`"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:54
msgid "Get information about a function"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:57
msgid ":ref:`debug.getlocal() <debug-getlocal>`"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:57
msgid "Get a local variable's name and value"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:60
msgid ":ref:`debug.getmetatable() <debug-getmetatable>`"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:60
msgid "Get an object's metatable"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:63
msgid ":ref:`debug.getregistry() <debug-getregistry>`"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:63
msgid "Get the registry table"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:66
msgid ":ref:`debug.getupvalue() <debug-getupvalue>`"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:66
msgid "Get an upvalue's name and value"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:69
msgid ":ref:`debug.setfenv() <debug-setfenv>`"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:69
msgid "Set an object's environment"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:72
msgid ":ref:`debug.sethook() <debug-sethook>`"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:72
msgid "Set a given function as a hook"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:75
msgid ":ref:`debug.setlocal() <debug-setlocal>`"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:75
msgid "Assign a value to a local variable"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:78
msgid ":ref:`debug.setmetatable() <debug-setmetatable>`"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:78
msgid "Set an object's metatable"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:81
msgid ":ref:`debug.setupvalue() <debug-setupvalue>`"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:81
msgid "Assign a value to an upvalue"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:84
msgid ":ref:`debug.traceback() <debug-traceback>`"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:84
msgid "Get a traceback of the call stack"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:92
msgid "Enters an interactive mode and runs each string that the user types in. The user can, among other things, inspect global and local variables, change their values and evaluate expressions."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:96
msgid "Enter ``cont`` to exit this function, so that the caller can continue its execution."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:101
msgid "Commands for ``debug.debug()`` are not lexically nested within any function and so have no direct access to local variables."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:108
msgid "object to get the environment of"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:111
msgid "the environment of the ``object``"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:117
msgid "the current hook settings of the ``thread`` as three values:"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:119
msgid "the current hook function"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:120
msgid "the current hook mask"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:121
msgid "the current hook count as set by the ``debug.sethook()`` function"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:127
msgid "function to get information on"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:129
msgid "what information on the ``function`` to return"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:131
msgid "a table with information about the ``function``"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:133
msgid "You can pass in a ``function`` directly, or you can give a number that specifies a function running at level ``function`` of the call stack of the given ``thread``: level 0 is the current function (``getinfo()`` itself), level 1 is the function that called ``getinfo()``, and so on. If ``function`` is a number larger than the number of active functions, ``getinfo()`` returns ``nil``."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:140
msgid "The default for ``what`` is to get all information available, except the table of valid lines. If present, the option ``f`` adds a field named ``func`` with the function itself. If present, the option ``L`` adds a field named ``activelines`` with the table of valid lines."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:149
#: ../doc/reference/reference_lua/debug_facilities.rst:226
msgid "level of the stack"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:150
#: ../doc/reference/reference_lua/debug_facilities.rst:227
msgid "index of the local variable"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:152
msgid "the name and the value of the local variable with the index ``local`` of the function at level ``level`` of the stack or ``nil`` if there is no local variable with the given index; raises an error if ``level`` is out of range"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:159
#: ../doc/reference/reference_lua/debug_facilities.rst:237
msgid "You can call ``debug.getinfo()`` to check whether the level is valid."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:165
msgid "object to get the metatable of"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:168
msgid "a metatable of the ``object`` or ``nil`` if it does not have a metatable"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:175
msgid "the registry table"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:181
msgid "function to get the upvalue of"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:182
#: ../doc/reference/reference_lua/debug_facilities.rst:257
msgid "index of the function upvalue"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:184
msgid "the name and the value of the upvalue with the index ``up`` of the function ``func`` or ``nil`` if there is no upvalue with the given index"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:192
msgid "Sets the environment of the ``object`` to the ``table``."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:194
msgid "object to change the environment of"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:196
msgid "table to set the object environment to"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:198
msgid "the ``object``"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:204
msgid "Sets the given function as a hook.  When called without arguments, turns the hook off."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:207
msgid "function to set as a hook"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:208
msgid "describes when the ``hook`` will be called; may have the following values:  * ``c`` - the ``hook`` is called every time Lua calls a function * ``r`` - the ``hook`` is called every time Lua returns from a function * ``l`` - the ``hook`` is called every time Lua enters a new line of code"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:208
msgid "describes when the ``hook`` will be called; may have the following values:"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:211
msgid "``c`` - the ``hook`` is called every time Lua calls a function"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:212
msgid "``r`` - the ``hook`` is called every time Lua returns from a function"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:213
msgid "``l`` - the ``hook`` is called every time Lua enters a new line of code"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:215
msgid "describes when the ``hook`` will be called; when different from zero, the ``hook`` is called after every ``count`` instructions."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:223
msgid "Assigns the value ``value`` to the local variable with the index ``local`` of the function at level ``level`` of the stack."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:228
msgid "value to assign to the local variable"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:231
msgid "the name of the local variable or ``nil`` if there is no local variable with the given index; raises an error if ``level`` is out of range"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:243
msgid "Sets the metatable of the ``object`` to the ``table``."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:245
msgid "object to change the metatable of"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:247
msgid "table to set the object metatable to"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:253
msgid "Assigns the value ``value`` to the upvalue with the index ``up`` of the function ``func``."
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:256
msgid "function to set the upvalue of"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:258
msgid "value to assign to the function upvalue"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:261
msgid "the name of the upvalue or ``nil`` if there is no upvalue with the given index"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:268
msgid "an optional message prepended to the traceback"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:269
msgid "specifies at which level to start the traceback (default is 1)"
msgstr ""

#: ../doc/reference/reference_lua/debug_facilities.rst:272
msgid "a string with a traceback of the call stack"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:5
msgid "Module `digest`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:13
msgid "A \"digest\" is a value which is returned by a function (usually a `Cryptographic hash function`_), applied against a string. Tarantool's ``digest`` module supports several types of cryptographic hash functions (AES_, MD4_, MD5_, SHA-1_, SHA-2_, PBKDF2_) as well as a checksum function (CRC32_), two functions for base64_, and two non-cryptographic hash functions (guava_, murmur_). Some of the digest functionality is also present in the :ref:`crypto <crypto>`."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:24
msgid "Below is a list of all ``digest`` functions."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:34
msgid ":ref:`digest.aes256cbc.encrypt() <digest-aes>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:34
msgid "Encrypt a string using AES"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:37
msgid ":ref:`digest.aes256cbc.decrypt() <digest-aes>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:37
msgid "Decrypt a string using AES"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:40
msgid ":ref:`digest.md4() <digest-md4>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:40
msgid "Get a digest made with MD4"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:43
msgid ":ref:`digest.md4_hex() <digest-md4_hex>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:43
msgid "Get a hexadecimal digest made with MD4"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:46
msgid ":ref:`digest.md5() <digest-md5>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:46
msgid "Get a digest made with MD5"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:49
msgid ":ref:`digest.md5_hex() <digest-md5_hex>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:49
msgid "Get a hexadecimal digest made with MD5"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:52
msgid ":ref:`digest.pbkdf2() <digest-pbkdf2>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:52
msgid "Get a digest made with PBKDF2"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:55
msgid ":ref:`digest.sha1() <digest-sha1>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:55
msgid "Get a digest made with SHA-1"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:58
msgid ":ref:`digest.sha1_hex() <digest-sha1_hex>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:58
msgid "Get a hexadecimal digest made with SHA-1"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:61
msgid ":ref:`digest.sha224() <digest-sha224>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:61
msgid "Get a 224-bit digest made with SHA-2"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:64
msgid ":ref:`digest.sha224_hex() <digest-sha224_hex>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:64
msgid "Get a 56-byte hexadecimal digest made with SHA-2"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:67
msgid ":ref:`digest.sha256() <digest-sha256>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:67
msgid "Get a 256-bit digest made with SHA-2"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:70
msgid ":ref:`digest.sha256_hex() <digest-sha256_hex>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:70
msgid "Get a 64-byte hexadecimal digest made with SHA-2"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:73
msgid ":ref:`digest.sha384() <digest-sha384>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:73
msgid "Get a 384-bit digest made with SHA-2"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:76
msgid ":ref:`digest.sha384_hex() <digest-sha384_hex>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:76
msgid "Get a 96-byte hexadecimal digest made with SHA-2"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:79
msgid ":ref:`digest.sha512() <digest-sha512>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:79
msgid "Get a 512-bit digest made with SHA-2"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:82
msgid ":ref:`digest.sha512_hex() <digest-sha512_hex>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:82
msgid "Get a 128-byte hexadecimal digest made with SHA-2"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:85
msgid ":ref:`digest.base64_encode() <digest-base64_encode>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:85
msgid "Encode a string to Base64"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:88
msgid ":ref:`digest.base64_decode() <digest-base64_decode>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:88
msgid "Decode a Base64-encoded string"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:91
msgid ":ref:`digest.urandom() <digest-urandom>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:91
msgid "Get an array of random bytes"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:94
msgid ":ref:`digest.crc32() <digest-crc32>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:94
msgid "Get a 32-bit checksum made with CRC32"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:97
msgid ":ref:`digest.crc32.new() <digest-crc32_new>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:97
msgid "Initiate incremental CRC32"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:100
msgid ":ref:`digest.guava() <digest-guava>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:100
msgid "Get a number made with a consistent hash"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:103
msgid ":ref:`digest.murmur() <digest-murmur>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:103
msgid "Get a digest made with MurmurHash"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:106
msgid ":ref:`digest.murmur.new() <digest-murmur_new>`"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:106
msgid "Initiate incremental MurmurHash"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:115
msgid "Returns 256-bit binary string = digest made with AES."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:121
msgid "Returns 128-bit binary string = digest made with MD4."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:127
msgid "Returns 32-byte string = hexadecimal of a digest calculated with md4."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:133
msgid "Returns 128-bit binary string = digest made with MD5."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:139
msgid "Returns 32-byte string = hexadecimal of a digest calculated with md5."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:145
msgid "Returns binary string = digest made with PBKDF2. |br| For effective encryption the ``iterations`` value should be at least several thousand. The ``digest-length`` value determines the length of the resulting binary string."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:154
msgid "Returns 160-bit binary string = digest made with SHA-1."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:160
msgid "Returns 40-byte string = hexadecimal of a digest calculated with sha1."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:166
msgid "Returns 224-bit binary string = digest made with SHA-2."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:172
msgid "Returns 56-byte string = hexadecimal of a digest calculated with sha224."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:178
msgid "Returns 256-bit binary string =  digest made with SHA-2."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:184
msgid "Returns 64-byte string = hexadecimal of a digest calculated with sha256."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:190
msgid "Returns 384-bit binary string =  digest made with SHA-2."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:196
msgid "Returns 96-byte string = hexadecimal of a digest calculated with sha384."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:202
msgid "Returns 512-bit binary tring = digest made with SHA-2."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:208
msgid "Returns 128-byte string = hexadecimal of a digest calculated with sha512."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:214
msgid "Returns base64 encoding from a regular string."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:216
msgid "The possible options are:"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:218
msgid "``nopad`` -- result must not include '=' for padding at the end,"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:219
msgid "``nowrap`` -- result must not include line feed for splitting lines after 72 characters,"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:221
msgid "``urlsafe`` -- result must not include '=' or line feed, and may contain '-' or '_' instead of '+' or '/' for positions 62 and 63 in the index table."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:225
msgid "Options may be ``true`` or ``false``, the default value is ``false``."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:229
msgid "digest.base64_encode(string_variable,{nopad=true})"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:237
msgid "Returns a regular string from a base64 encoding."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:243
msgid "Returns array of random bytes with length = integer."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:249
msgid "Returns 32-bit checksum made with CRC32."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:251
msgid "The ``crc32`` and ``crc32_update`` functions use the `Cyclic Redundancy Check`_ polynomial value: ``0x1EDC6F41`` / ``4812730177``. (Other settings are: input = reflected, output = reflected, initial value = 0xFFFFFFFF, final xor value = 0x0.) If it is necessary to be compatible with other checksum functions in other programming languages, ensure that the other functions use the same polynomial value."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:258
msgid "For example, in Python, install the ``crcmod`` package and say:"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:260
msgid ">>> import crcmod\n"
">>> fun = crcmod.mkCrcFun('4812730177')\n"
">>> fun('string')\n"
"3304160206L"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:267
msgid "In Perl, install the ``Digest::CRC`` module and run the following code:"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:269
msgid "use Digest::CRC;\n"
"$d = Digest::CRC->new(width => 32, poly => 0x1EDC6F41, init => 0xFFFFFFFF, refin => 1, refout => 1);\n"
"$d->add('string');\n"
"print $d->digest;"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:276
msgid "(the expected output is 3304160206)."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:282
msgid "Initiates incremental crc32. See :ref:`incremental methods <digest-incremental_digests>` notes."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:289
msgid "Returns a number made with consistent hash."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:291
msgid "The guava function uses the `Consistent Hashing`_ algorithm of the Google guava library. The first parameter should be a hash code; the second parameter should be the number of buckets; the returned value will be an integer between 0 and the number of buckets. For example,"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:296
msgid "tarantool> digest.guava(10863919174838991, 11)\n"
"---\n"
"- 8\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:307
msgid "Returns 32-bit binary string = digest made with MurmurHash."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:313
msgid "Initiates incremental MurmurHash. See :ref:`incremental methods <digest-incremental_digests>` notes. For example:"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:317
msgid "murmur.new({seed=0})"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:325
msgid "Incremental methods in the ``digest`` module"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:327
msgid "Suppose that a digest is done for a string 'A', then a new part 'B' is appended to the string, then a new digest is required. The new digest could be recomputed for the whole string 'AB', but it is faster to take what was computed before for 'A' and apply changes based on the new part 'B'. This is called multi-step or \"incremental\" digesting, which Tarantool supports with crc32 and with murmur..."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:333
msgid "digest = require('digest')\n"
"\n"
"-- print crc32 of 'AB', with one step, then incrementally\n"
"print(digest.crc32('AB'))\n"
"c = digest.crc32.new()\n"
"c:update('A')\n"
"c:update('B')\n"
"print(c:result())\n"
"\n"
"-- print murmur hash of 'AB', with one step, then incrementally\n"
"print(digest.murmur('AB'))\n"
"m = digest.murmur.new()\n"
"m:update('A')\n"
"m:update('B')\n"
"print(m:result())"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:355
msgid "In the following example, the user creates two functions, ``password_insert()`` which inserts a SHA-1_ digest of the word \"**^S^e^c^ret Wordpass**\" into a tuple set, and ``password_check()`` which requires input of a password."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:359
msgid "tarantool> digest = require('digest')\n"
"---\n"
"...\n"
"tarantool> function password_insert()\n"
"         >   box.space.tester:insert{1234, digest.sha1('^S^e^c^ret Wordpass')}\n"
"         >   return 'OK'\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> function password_check(password)\n"
"         >   local t = box.space.tester:select{12345}\n"
"         >   if digest.sha1(password) == t[2] then\n"
"         >     return 'Password is valid'\n"
"         >   else\n"
"         >     return 'Password is not valid'\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> password_insert()\n"
"---\n"
"- 'OK'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:385
msgid "If a later user calls the ``password_check()`` function and enters the wrong password, the result is an error."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:388
msgid "tarantool> password_check('Secret Password')\n"
"---\n"
"- 'Password is not valid'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:5
msgid "Database error codes"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:7
msgid "In the current version of the binary protocol, error messages, which are normally more descriptive than error codes, are not present in server responses. The actual message may contain a file name, a detailed reason or operating system error code. All such messages, however, are logged in the error log. Below are general descriptions of some popular codes. A complete list of errors can be found in file `errcode.h`_ in the source tree."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:18
msgid "**List of error codes**"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:26
msgid "ER_NONMASTER"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:26
msgid "(In replication) A server instance cannot modify data unless it is a master."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:29
msgid "ER_ILLEGAL_PARAMS"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:29
msgid "Illegal parameters. Malformed protocol message."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:32
msgid "ER_MEMORY_ISSUE"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:32
msgid "Out of memory: :ref:`memtx_memory <cfg_storage-memtx_memory>` limit has been reached."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:36
msgid "ER_WAL_IO"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:36
msgid "Failed to write to disk. May mean: failed to record a change in the write-ahead log. Some sort of disk error."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:40
msgid "ER_KEY_PART_COUNT"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:40
msgid "Key part count is not the same as index part count"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:43
msgid "ER_NO_SUCH_SPACE"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:43
msgid "The specified space does not exist."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:46
msgid "ER_NO_SUCH_INDEX"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:46
msgid "The specified index in the specified space does not exist."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:49
msgid "ER_PROC_LUA"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:49
msgid "An error occurred inside a Lua procedure."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:52
msgid "ER_FIBER_STACK"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:52
msgid "The recursion limit was reached when creating a new fiber. This usually indicates that a stored procedure is recursively invoking itself too often."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:57
msgid "ER_UPDATE_FIELD"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:57
msgid "An error occurred during update of a field."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:60
msgid "ER_TUPLE_FOUND"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:60
msgid "A duplicate key exists in a unique index."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:68
msgid "Handling errors"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:70
msgid "Here are some procedures that can make Lua functions more robust when there are errors, particularly database errors."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:73
msgid "Invoke with pcall."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:0
msgid "Take advantage of Lua's mechanisms for `\"Error handling and exceptions\" <http://www.lua.org/pil/8.4.html>`_, particularly ``pcall``. That is, instead of simply invoking with"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:0
msgid ":samp:`box.space.{space-name}:{function-name}()`"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:0
msgid "say"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:0
msgid ":samp:`if pcall(box.space.{space-name}.{function-name}, box.space.{space-name}) ...`"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:0
msgid "For some Tarantool box functions, pcall also returns error details including a file-name and line-number within Tarantool's source code. This can be seen by unpacking. For example:"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:0
msgid "``x, y = pcall(function() box.schema.space.create('') end)``"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:0
msgid "``y:unpack()``"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:88
msgid "See the tutorial :ref:`Sum a JSON field for all tuples <c_lua_tutorial-sum_a_json_field>` to see how pcall can fit in an application."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:91
msgid "Examine and raise with box.error."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:93
msgid "To make a new error and pass it on, the box.error module provides :ref:`box.error(code, errtext [, errtext ...]) <box_error-error>`."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:96
msgid "To find the last error, the box.error module provides :ref:`box.error.last() <box_error-last>`. (There is also a way to find the text of the last operating-system error for certain functions -- :ref:`errno.strerror([code]) <errno-strerror>`.)"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:101
msgid "Log."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:103
msgid "Put messages in a log using the :ref:`log module <log-module>`."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:105
msgid "And filter messages that are automatically generated, with the :ref:`log <cfg_logging-log>` configuration parameter."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:109
msgid "Generally, for Tarantool built-in functions which are designed to return objects: the result will be an object, or nil, or `a Lua error <https://www.lua.org/pil/8.3.html>`_. For example consider the :ref:`fio_read.lua <cookbook-fio_read>` program in our cookbook:"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:113
msgid "#!/usr/bin/env tarantool\n"
"\n"
"local fio = require('fio')\n"
"local errno = require('errno')\n"
"local f = fio.open('/tmp/xxxx.txt', {'O_RDONLY' })\n"
"if not f then\n"
"    error(\"Failed to open file: \"..errno.strerror())\n"
"end\n"
"local data = f:read(4096)\n"
"f:close()\n"
"print(data)"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:127
msgid "After a function call that might fail, like fio.open() above, it is common to see syntax like ``if not f then ...`` or ``if f == nil then ...``, which check for common failures. But if there had been a syntax error, for example fio.opex instead of fio.open, then there would have been a Lua error and f would not have been changed. If checking for such an obvious error had been a concern, the programmer would probably have used pcall()."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:137
msgid "All functions in Tarantool modules should work this way, unless the manual explicitly says otherwise."
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:5
msgid "Module `errno`"
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:13
msgid "The ``errno`` module is typically used within a function or within a Lua program, in association with a module whose functions can return operating-system errors, such as :ref:`fio <fio-module>`."
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:21
msgid "Below is a list of all ``errno`` functions."
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:31
msgid ":ref:`errno() <errno-errno>`"
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:31
msgid "Get an error number for the last OS-related function"
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:34
msgid ":ref:`errno.strerror() <errno-strerror>`"
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:34
msgid "Get an error message for the corresponding error number"
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:42
msgid "Return an error number for the last operating-system-related function, or 0. To invoke it, simply say ``errno()``, without the module name."
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:45
msgid "integer"
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:51
msgid "Return a string, given an error number. The string will contain the text of the conventional error message for the current operating system. If ``code`` is not supplied, the error message will be for the last operating-system-related function, or 0."
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:56
msgid "number of an operating-system error"
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:58
#: ../doc/reference/reference_lua/fiber.rst:335
#: ../doc/reference/reference_lua/fiber.rst:454
#: ../doc/reference/reference_lua/fiber.rst:504
#: ../doc/reference/reference_lua/fio.rst:179
#: ../doc/reference/reference_lua/fio.rst:201
#: ../doc/reference/reference_lua/fio.rst:221
#: ../doc/reference/reference_lua/fio.rst:240
#: ../doc/reference/reference_lua/json.rst:54
#: ../doc/reference/reference_lua/msgpack.rst:57
#: ../doc/reference/reference_lua/pickle.rst:83
#: ../doc/reference/reference_lua/socket.rst:294
#: ../doc/reference/reference_lua/socket.rst:328
#: ../doc/reference/reference_lua/socket.rst:344
#: ../doc/reference/reference_lua/string.rst:70
#: ../doc/reference/reference_lua/string.rst:95
#: ../doc/reference/reference_lua/string.rst:118
#: ../doc/reference/reference_lua/string.rst:202
#: ../doc/reference/reference_lua/string.rst:225
#: ../doc/reference/reference_lua/string.rst:280
#: ../doc/reference/reference_lua/uri.rst:90
#: ../doc/reference/reference_lua/utf8.rst:88
#: ../doc/reference/reference_lua/utf8.rst:274
#: ../doc/reference/reference_lua/utf8.rst:326
#: ../doc/reference/reference_lua/utf8.rst:350
#: ../doc/reference/reference_lua/yaml.rst:48
#: ../doc/reference/reference_rock/membership.rst:314
msgid "string"
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:62
msgid "This function displays the result of a call to :ref:`fio.open() <fio-open>` which causes error 2 (``errno.ENOENT``). The display includes the error number, the associated error string, and the error name."
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:66
msgid "tarantool> function f()\n"
"         >   local fio = require('fio')\n"
"         >   local errno = require('errno')\n"
"         >   fio.open('no_such_file')\n"
"         >   print('errno() = ' .. errno())\n"
"         >   print('errno.strerror() = ' .. errno.strerror())\n"
"         >   local t = getmetatable(errno).__index\n"
"         >   for k, v in pairs(t) do\n"
"         >     if v == errno() then\n"
"         >       print('errno() constant = ' .. k)\n"
"         >     end\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"\n"
"tarantool> f()\n"
"errno() = 2\n"
"errno.strerror() = No such file or directory\n"
"errno() constant = ENOENT\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:91
msgid "To see all possible error names stored in the ``errno`` metatable, say ``getmetatable(errno)`` (output abridged):"
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:94
msgid "tarantool> getmetatable(errno)\n"
"---\n"
"- __newindex: 'function: 0x41666a38'\n"
"  __call: 'function: 0x41666890'\n"
"  __index:\n"
"  ENOLINK: 67\n"
"  EMSGSIZE: 90\n"
"  EOVERFLOW: 75\n"
"  ENOTCONN: 107\n"
"  EFAULT: 14\n"
"  EOPNOTSUPP: 95\n"
"  EEXIST: 17\n"
"  ENOSR: 63\n"
"  ENOTSOCK: 88\n"
"  EDESTADDRREQ: 89\n"
"  <...>\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:5
msgid "Module `fiber`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:11
msgid "With the ``fiber`` module, you can:"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:13
msgid "create, run and manage :ref:`fibers <fiber-fibers>`,"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:14
msgid "send and receive messages between different processes (i.e. different connections, sessions, or fibers) via :ref:`channels <fiber_ipc-channel>`, and"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:16
msgid "use a :ref:`synchronization mechanism <fiber_ipc-cond_var>` for fibers, similar to \"condition variables\" and similar to operating-system functions such as ``pthread_cond_wait()`` plus ``pthread_cond_signal()``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:24
msgid "Below is a list of all ``fiber`` functions and members."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:34
msgid ":ref:`fiber.create() <fiber-create>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:34
msgid "Create and start a fiber"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:37
msgid ":ref:`fiber.new() <fiber-new>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:37
msgid "Create but do not start a fiber"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:40
msgid ":ref:`fiber.self() <fiber-self>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:40
msgid "Get a fiber object"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:43
msgid ":ref:`fiber.find() <fiber-find>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:43
msgid "Get a fiber object by ID"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:46
msgid ":ref:`fiber.sleep() <fiber-sleep>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:46
msgid "Make a fiber go to sleep"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:49
msgid ":ref:`fiber.yield() <fiber-yield>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:49
msgid "Yield control"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:52
msgid ":ref:`fiber.status() <fiber-status>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:52
msgid "Get the current fiber's status"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:55
msgid ":ref:`fiber.info() <fiber-info>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:55
msgid "Get information about all fibers"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:58
msgid ":ref:`fiber.kill() <fiber-kill>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:58
#: ../doc/reference/reference_lua/fiber.rst:76
msgid "Cancel a fiber"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:61
msgid ":ref:`fiber.testcancel() <fiber-testcancel>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:61
msgid "Check if the current fiber has been cancelled"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:64
msgid ":ref:`fiber_object:id() <fiber_object-id>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:64
msgid "Get a fiber's ID"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:67
msgid ":ref:`fiber_object:name() <fiber_object-name_get>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:67
msgid "Get a fiber's name"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:70
msgid ":ref:`fiber_object:name(name) <fiber_object-name_set>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:70
msgid "Set a fiber's name"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:73
msgid ":ref:`fiber_object:status() <fiber_object-status>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:73
msgid "Get a fiber's status"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:76
msgid ":ref:`fiber_object:cancel() <fiber_object-cancel>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:79
msgid ":ref:`fiber_object.storage <fiber_object-storage>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:79
msgid "Local storage within the fiber"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:82
msgid ":ref:`fiber_object:set_joinable() <fiber_object-set_joinable>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:82
msgid "Make it possible for a new fiber to join"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:85
msgid ":ref:`fiber_object:join() <fiber_object-join>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:85
msgid "Wait for a fiber's state to become 'dead'"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:88
msgid ":ref:`fiber.time() <fiber-time>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:88
msgid "Get the system time in seconds"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:91
msgid ":ref:`fiber.time64() <fiber-time64>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:91
msgid "Get the system time in microseconds"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:94
msgid ":ref:`fiber.channel() <fiber-channel>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:94
msgid "Create a communication channel"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:97
msgid ":ref:`channel_object:put() <channel_object-put>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:97
msgid "Send a message via a channel"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:100
msgid ":ref:`channel_object:close() <channel_object-close>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:100
msgid "Close a channel"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:103
msgid ":ref:`channel_object:get() <channel_object-get>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:103
msgid "Fetch a message from a channel"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:106
msgid ":ref:`channel_object:is_empty() <channel_object-is_empty>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:106
msgid "Check if a channel is empty"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:109
msgid ":ref:`channel_object:count() <channel_object-count>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:109
msgid "Count messages in a channel"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:112
msgid ":ref:`channel_object:is_full() <channel_object-is_full>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:112
msgid "Check if a channel is full"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:115
msgid ":ref:`channel_object:has_readers() <channel_object-has_readers>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:115
msgid "Check if an empty channel has any readers waiting"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:118
msgid ":ref:`channel_object:has_writers() <channel_object-has_writers>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:118
msgid "Check if a full channel has any writers waiting"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:121
msgid ":ref:`channel_object:is_closed() <channel_object-is_closed>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:121
msgid "Check if a channel is closed"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:124
msgid ":ref:`fiber.cond() <fiber-cond>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:124
msgid "Create a condition variable"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:127
msgid ":ref:`cond_object:wait() <cond_object-wait>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:127
msgid "Make a fiber go to sleep until woken by another fiber"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:130
msgid ":ref:`cond_object:signal() <cond_object-signal>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:130
msgid "Wake up a single fiber"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:133
msgid ":ref:`cond_object:broadcast() <cond_object-broadcast>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:133
msgid "Wake up all fibers"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:142
#: ../doc/reference/reference_rock/vshard/index.rst:936
msgid "Fibers"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:144
msgid "A **fiber** is a set of instructions which are executed with cooperative multitasking. Fibers managed by the fiber module are associated with a user-supplied function called the *fiber function*."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:148
msgid "A fiber has three possible states: **running**, **suspended** or **dead**. When a fiber is created with :ref:`fiber.create() <fiber-create>`, it is running. When a fiber is created with :ref:`fiber.new() <fiber-new>` or yields control with :ref:`fiber.sleep() <fiber-sleep>`, it is suspended. When a fiber ends (because the fiber function ends), it is dead."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:154
msgid "All fibers are part of the fiber registry. This registry can be searched with :ref:`fiber.find() <fiber-find>` - via fiber id (fid), which is a numeric identifier."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:158
msgid "A runaway fiber can be stopped with :ref:`fiber_object.cancel <fiber_object-cancel>`. However, :ref:`fiber_object.cancel <fiber_object-cancel>` is advisory — it works only if the runaway fiber calls :ref:`fiber.testcancel() <fiber-testcancel>` occasionally. Most ``box.*`` functions, such as :ref:`box.space...delete() <box_space-delete>` or :ref:`box.space...update() <box_space-update>`, do call :ref:`fiber.testcancel() <fiber-testcancel>` but :ref:`box.space...select{} <box_space-select>` does not. In practice, a runaway fiber can only become unresponsive if it does many computations and does not check whether it has been cancelled."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:169
msgid "The other potential problem comes from fibers which never get scheduled, because they are not subscribed to any events, or because no relevant events occur. Such morphing fibers can be killed with :ref:`fiber.kill() <fiber-kill>` at any time, since :ref:`fiber.kill() <fiber-kill>` sends an asynchronous wakeup event to the fiber, and :ref:`fiber.testcancel() <fiber-testcancel>` is checked whenever such a wakeup event occurs."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:176
msgid "Like all Lua objects, dead fibers are garbage collected. The Lua garbage collector frees pool allocator memory owned by the fiber, resets all fiber data, and returns the fiber (now called a fiber carcass) to the fiber pool. The carcass can be reused when another fiber is created."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:181
msgid "A fiber has all the features of a Lua coroutine_ and all the programming concepts that apply for Lua coroutines will apply for fibers as well. However, Tarantool has made some enhancements for fibers and has used fibers internally. So, although use of coroutines is possible and supported, use of fibers is recommended."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:193
msgid "Create and start a fiber. The fiber is created and begins to run immediately."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:195
#: ../doc/reference/reference_lua/fiber.rst:234
msgid "the function to be associated with the fiber"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:196
#: ../doc/reference/reference_lua/fiber.rst:235
msgid "what will be passed to function"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/table.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
msgid "Return"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:198
#: ../doc/reference/reference_lua/fiber.rst:237
msgid "created fiber object"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/fiber.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/string.rst:0
#: ../doc/reference/reference_lua/table.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
#: ../doc/reference/reference_rock/vshard/index.rst:0
msgid "Rtype"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:199
#: ../doc/reference/reference_lua/fiber.rst:238
#: ../doc/reference/reference_lua/fiber.rst:261
#: ../doc/reference/reference_lua/fiber.rst:281
#: ../doc/reference/reference_lua/fio.rst:759
#: ../doc/reference/reference_lua/http.rst:81
#: ../doc/reference/reference_lua/iconv.rst:53
#: ../doc/reference/reference_lua/net_box.rst:210
#: ../doc/reference/reference_lua/socket.rst:136
#: ../doc/reference/reference_lua/socket.rst:154
#: ../doc/reference/reference_lua/socket.rst:385
#: ../doc/reference/reference_lua/tap.rst:98
msgid "userdata"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:203
msgid "tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function function_name()\n"
"         >   fiber.sleep(1000)\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> fiber_object = fiber.create(function_name)\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:221
msgid "Create but do not start a fiber: the fiber is created but does not begin to run immediately -- it starts after the fiber creator (that is, the job that is calling ``fiber.new()``) yields, under :ref:`transaction control <atomic-atomic_execution>`. The initial fiber state is 'suspended'. Thus ``fiber.new()`` differs slightly from :ref:`fiber.create() <fiber-create>`."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:229
msgid "Ordinarily ``fiber.new()`` is used in conjunction with :ref:`fiber_object:set_joinable() <fiber_object-set_joinable>` and :ref:`fiber_object:join() <fiber_object-join>`."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:242
msgid "tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function function_name()\n"
"         >   fiber.sleep(1000)\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> fiber_object = fiber.new(function_name)\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:260
msgid "fiber object for the currently scheduled fiber."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:265
msgid "tarantool> fiber.self()\n"
"---\n"
"- status: running\n"
"  name: interactive\n"
"  id: 101\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:278
msgid "numeric identifier of the fiber."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:280
msgid "fiber object for the specified fiber."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:285
msgid "tarantool> fiber.find(101)\n"
"---\n"
"- status: running\n"
"  name: interactive\n"
"  id: 101\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:298
msgid "Yield control to the scheduler and sleep for the specified number of seconds. Only the current fiber can be made to sleep."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:301
msgid "number of seconds to sleep."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:305
msgid "tarantool> fiber.sleep(1.5)\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:315
msgid "Yield control to the scheduler. Equivalent to :ref:`fiber.sleep(0) <fiber-sleep>`, except that `fiber.sleep(0)` depends on a timer, `fiber.yield()` does not."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:320
msgid "tarantool> fiber.yield()\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:330
msgid "Return the status of the current fiber. Or, if optional fiber_object is passed, return the status of the specified fiber."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:334
msgid "the status of ``fiber``. One of: “dead”, “suspended”, or “running”."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:339
msgid "tarantool> fiber.status()\n"
"---\n"
"- running\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:350
msgid "Return information about all fibers."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:352
msgid "number of context switches, backtrace, id, total memory, used memory, name for each fiber."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:358
msgid "tarantool> fiber.info()\n"
"---\n"
"- 101:\n"
"    csw: 7\n"
"    backtrace: []\n"
"    fid: 101\n"
"    memory:\n"
"      total: 65776\n"
"      used: 0\n"
"    name: interactive\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:376
msgid "Locate a fiber by its numeric id and cancel it. In other words, :ref:`fiber.kill() <fiber-kill>` combines :ref:`fiber.find() <fiber-find>` and :ref:`fiber_object:cancel() <fiber_object-cancel>`."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:380
msgid "the id of the fiber to be cancelled."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:0
msgid "Exception"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:381
msgid "the specified fiber does not exist or cancel is not permitted."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:385
msgid "tarantool> fiber.kill(fiber.id()) -- kill self, may make program end\n"
"---\n"
"- error: fiber is cancelled\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:397
msgid "Check if the current fiber has been cancelled and throw an exception if this is the case."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:402
msgid "Even if you catch the exception, the fiber will remain cancelled. Most types of calls will check ``fiber.testcancel()``. However, some functions (``id``, ``status``, ``join`` etc.) will return no error. We recommend application developers to implement occasional checks with :ref:`fiber.testcancel() <fiber-testcancel>` and to end fiber's execution as soon as possible in case it has been cancelled."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:411
msgid "tarantool> fiber.testcancel()\n"
"---\n"
"- error: fiber is cancelled\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:424
#: ../doc/reference/reference_lua/fiber.rst:449
#: ../doc/reference/reference_lua/fiber.rst:477
#: ../doc/reference/reference_lua/fiber.rst:499
#: ../doc/reference/reference_lua/fiber.rst:526
msgid "generally this is an object referenced in the return from :ref:`fiber.create <fiber-create>` or :ref:`fiber.self <fiber-self>` or :ref:`fiber.find <fiber-find>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:428
msgid "id of the fiber."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:429
#: ../doc/reference/reference_lua/fiber.rst:890
#: ../doc/reference/reference_lua/fio.rst:316
#: ../doc/reference/reference_lua/fio.rst:992
#: ../doc/reference/reference_lua/socket.rst:274
#: ../doc/reference/reference_lua/socket.rst:400
#: ../doc/reference/reference_lua/utf8.rst:55
#: ../doc/reference/reference_lua/utf8.rst:116
#: ../doc/reference/reference_lua/utf8.rst:239
#: ../doc/reference/reference_rock/vshard/index.rst:1456
#: ../doc/reference/reference_rock/vshard/index.rst:1471
msgid "number"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:431
msgid "``fiber.self():id()`` can also be expressed as ``fiber.id()``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:435
msgid "tarantool> fiber_object = fiber.self()\n"
"---\n"
"...\n"
"tarantool> fiber_object:id()\n"
"---\n"
"- 101\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:453
msgid "name of the fiber."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:456
msgid "``fiber.self():name()`` can also be expressed as ``fiber.name()``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:460
msgid "tarantool> fiber.self():name()\n"
"---\n"
"- interactive\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:471
msgid "Change the fiber name. By default a Tarantool server's interactive-mode fiber is named 'interactive' and new fibers created due to :ref:`fiber.create <fiber-create>` are named 'lua'. Giving fibers distinct names makes it easier to distinguish them when using :ref:`fiber.info <fiber-info>`."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:481
msgid "the new name of the fiber."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:487
msgid "tarantool> fiber.self():name('non-interactive')\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:497
msgid "Return the status of the specified fiber."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:503
msgid "the status of fiber. One of: “dead”, “suspended”, or “running”."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:506
msgid "``fiber.self():status(`` can also be expressed as ``fiber.status()``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:510
msgid "tarantool> fiber.self():status()\n"
"---\n"
"- running\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:521
msgid "Cancel a fiber. Running and suspended fibers can be cancelled. After a fiber has been cancelled, attempts to operate on it will cause errors, for example :ref:`fiber_object:name() <fiber_object-name_get>` will cause ``error: the fiber is dead``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:532
msgid "Possible errors: cancel is not permitted for the specified fiber object."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:536
msgid "tarantool> fiber.self():cancel() -- kill self, may make program end\n"
"---\n"
"- error: fiber is cancelled\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:547
msgid "Local storage within the fiber. The storage can contain any number of named values, subject to memory limitations. Naming may be done with :samp:`{fiber_object}.storage.{name}` or :samp:`{fiber_object}.storage['{name}'].` or with a number :samp:`{fiber_object}.storage[{number}]`. Values may be either numbers or strings. The Lua garbage collector will mark or free the local storage when :samp:`{fiber_object}:cancel()` happens."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:556
msgid "tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function f () fiber.sleep(1000); end\n"
"---\n"
"...\n"
"tarantool> fiber_function = fiber.create(f)\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage.str1 = 'string'\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage['str1']\n"
"---\n"
"- string\n"
"...\n"
"tarantool> fiber_function:cancel()\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage['str1']\n"
"---\n"
"- error: '[string \"return fiber_function.storage[''str1'']\"]:1: the fiber is dead'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:582
msgid "See also :ref:`box.session.storage <box_session-storage>`."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:588
msgid "``fiber_object:set_joinable(true)`` makes a fiber joinable; ``fiber_object:set_joinable(false)`` makes a fiber not joinable; the default is false."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:592
msgid "A joinable fiber can be waited for, with :ref:`fiber_object:join() <fiber_object-join>`."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:595
msgid "Best practice is to call ``fiber_object:set_joinable()`` before the fiber function begins to execute, because otherwise the fiber could become 'dead' before ``fiber_object:set_joinable()`` takes effect. The usual sequence could be:"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:600
msgid "Call ``fiber.new()`` instead of ``fiber.create()`` to create a new fiber_object."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:603
msgid "Do not yield at this point, because that will cause the fiber function to begin."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:606
msgid "Call ``fiber_object:set_joinable(true)`` to make the new fiber_object joinable."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:609
msgid "Now it is safe to yield."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:611
msgid "Call ``fiber_object:join()``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:613
msgid "Usually ``fiber_object:join()`` should be called, otherwise the fiber's status may become 'suspended' when the fiber function ends, instead of 'dead'."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:617
msgid "the boolean value that changes the ``set_joinable`` flag"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:624
#: ../doc/reference/reference_lua/fiber.rst:674
msgid "The result of the following sequence of requests is:"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:626
msgid "the global variable ``d`` will be 6 (which proves that the function was not executed until after ``d`` was set to 1, when ``fiber.sleep(1)`` caused a yield);"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:629
msgid "``fiber.status(fi2)`` will be 'suspended' (which proves that after the function was executed the fiber status did not change to 'dead')."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:632
msgid "fiber=require('fiber')\n"
"d=0\n"
"function fu2() d=d+5 end\n"
"fi2=fiber.new(fu2) fi2:set_joinable(true) d=1 fiber.sleep(1)\n"
"print(d)\n"
"fiber.status(fi2)"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:645
msgid "\"Join\" a joinable fiber. That is, let the fiber's function run and wait until the fiber's status is 'dead' (normally a status becomes 'dead' when the function execution finishes). Joining will cause a yield, therefore, if the fiber is currently in a suspended state, execution of its fiber function will resume."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:653
msgid "This kind of waiting is more convenient than going into a loop and periodically checking the status; however, it works only if the fiber was created with :ref:`fiber.new() <fiber-new>` and was made joinable with :ref:`fiber_object:set_joinable() <fiber_object-set_joinable>`."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:660
msgid "two values. The first value is boolean. If the first value is true, then the join succeeded because the fiber's function ended normally and the second result has the return value from the fiber's function. If the first value is false, then the join succeeded because the fiber's function ended abnormally and the second result has the details about the error, which one can unpack in the same way that one unpacks :ref:`a pcall result <error_handling>`."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:670
msgid "boolean +result type, or boolean + struct error"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:676
msgid "the first ``fiber.status()`` call returns 'suspended',"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:677
msgid "the ``join()`` call returns true,"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:678
msgid "the elapsed time is usually 5 seconds, and"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:679
msgid "the second ``fiber.status()`` call returns 'dead'."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:681
msgid "This proves that the ``join()`` does not return until the function -- which sleeps 5 seconds -- is 'dead'."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:684
msgid "fiber=require('fiber')\n"
"function fu2() fiber.sleep(5) end\n"
"fi2=fiber.new(fu2) fi2:set_joinable(true)\n"
"start_time = os.time()\n"
"fiber.status(fi2)\n"
"fi2:join()\n"
"print('elapsed = ' .. os.time() - start_time)\n"
"fiber.status(fi2)"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:699
msgid "current system time (in seconds since the epoch) as a Lua number. The time is taken from the event loop clock, which makes this call very cheap, but still useful for constructing artificial tuple keys."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:703
#: ../doc/reference/reference_lua/fiber.rst:722
msgid "num"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:707
msgid "tarantool> fiber.time(), fiber.time()\n"
"---\n"
"- 1448466279.2415\n"
"- 1448466279.2415\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:719
msgid "current system time (in microseconds since the epoch) as a 64-bit integer. The time is taken from the event loop clock."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:726
msgid "tarantool> fiber.time(), fiber.time64()\n"
"---\n"
"- 1448466351.2708\n"
"- 1448466351270762\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:738
msgid "Make the function which will be associated with the fiber. This function contains an infinite loop. Each iteration of the loop adds 1 to a global variable named gvar, then goes to sleep for 2 seconds. The sleep causes an implicit :ref:`fiber.yield() <fiber-yield>`."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:743
msgid "tarantool> fiber = require('fiber')\n"
"tarantool> function function_x()\n"
"         >   gvar = 0\n"
"         >   while true do\n"
"         >     gvar = gvar + 1\n"
"         >     fiber.sleep(2)\n"
"         >   end\n"
"         > end\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:756
msgid "Make a fiber, associate function_x with the fiber, and start function_x. It will immediately \"detach\" so it will be running independently of the caller."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:759
msgid "tarantool> gvar = 0\n"
"\n"
"tarantool> fiber_of_x = fiber.create(function_x)\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:767
msgid "Get the id of the fiber (fid), to be used in later displays."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:769
msgid "tarantool> fid = fiber_of_x:id()\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:775
msgid "Pause for a while, while the detached function runs. Then ... Display the fiber id, the fiber status, and gvar (gvar will have gone up a bit depending how long the pause lasted). The status is suspended because the fiber spends almost all its time sleeping or yielding."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:780
msgid "tarantool> print('#', fid, '. ', fiber_of_x:status(), '. gvar=', gvar)\n"
"# 102 .  suspended . gvar= 399\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:787
msgid "Pause for a while, while the detached function runs. Then ... Cancel the fiber. Then, once again ... Display the fiber id, the fiber status, and gvar (gvar will have gone up a bit more depending how long the pause lasted). This time the status is dead because the cancel worked."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:792
msgid "tarantool> fiber_of_x:cancel()\n"
"---\n"
"...\n"
"tarantool> print('#', fid, '. ', fiber_of_x:status(), '. gvar=', gvar)\n"
"# 102 .  dead . gvar= 421\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:808
msgid "Channels"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:810
msgid "Call ``fiber.channel()`` to allocate space and get a channel object, which will be called channel for examples in this section."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:813
msgid "Call the other routines, via channel, to send messages, receive messages, or check channel status."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:816
msgid "Message exchange is synchronous. The Lua garbage collector will mark or free the channel when no one is using it, as with any other Lua object. Use object-oriented syntax, for example ``channel:put(message)`` rather than ``fiber.channel.put(message)``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:825
msgid "Create a new communication channel."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:827
msgid "the maximum number of slots (spaces for ``channel:put`` messages) that can be in use at once. The default is 0."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:831
msgid "new channel."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:832
msgid "userdata, possibly including the string \"channel ...\"."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:840
msgid "Send a message using a channel. If the channel is full, ``channel:put()`` waits until there is a free slot in the channel."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:843
msgid "what will be sent, usually a string or number or table"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:844
msgid "maximum number of seconds to wait for a slot to become free"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:845
msgid "If timeout is specified, and there is no free slot in the channel for the duration of the timeout, then the return value is ``false``. If the channel is closed, then the return value is ``false``. Otherwise, the return value is ``true``, indicating success."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:849
#: ../doc/reference/reference_lua/fiber.rst:881
#: ../doc/reference/reference_lua/fiber.rst:901
#: ../doc/reference/reference_lua/fiber.rst:911
#: ../doc/reference/reference_lua/fiber.rst:921
#: ../doc/reference/reference_lua/fiber.rst:929
#: ../doc/reference/reference_lua/fiber.rst:1041
#: ../doc/reference/reference_lua/fio.rst:267
#: ../doc/reference/reference_lua/fio.rst:275
#: ../doc/reference/reference_lua/fio.rst:283
#: ../doc/reference/reference_lua/fio.rst:291
#: ../doc/reference/reference_lua/fio.rst:299
#: ../doc/reference/reference_lua/fio.rst:391
#: ../doc/reference/reference_lua/fio.rst:411
#: ../doc/reference/reference_lua/fio.rst:511
#: ../doc/reference/reference_lua/fio.rst:533
#: ../doc/reference/reference_lua/fio.rst:556
#: ../doc/reference/reference_lua/fio.rst:608
#: ../doc/reference/reference_lua/fio.rst:631
#: ../doc/reference/reference_lua/fio.rst:679
#: ../doc/reference/reference_lua/fio.rst:697
#: ../doc/reference/reference_lua/fio.rst:798
#: ../doc/reference/reference_lua/fio.rst:857
#: ../doc/reference/reference_lua/fio.rst:942
#: ../doc/reference/reference_lua/fio.rst:969
#: ../doc/reference/reference_lua/net_box.rst:230
#: ../doc/reference/reference_lua/net_box.rst:246
#: ../doc/reference/reference_lua/net_box.rst:261
#: ../doc/reference/reference_lua/net_box.rst:278
#: ../doc/reference/reference_lua/socket.rst:255
#: ../doc/reference/reference_lua/socket.rst:361
#: ../doc/reference/reference_lua/socket.rst:437
#: ../doc/reference/reference_lua/socket.rst:449
#: ../doc/reference/reference_lua/string.rst:145
#: ../doc/reference/reference_lua/string.rst:175
#: ../doc/reference/reference_lua/tap.rst:154
#: ../doc/reference/reference_lua/tap.rst:177
#: ../doc/reference/reference_lua/tap.rst:211
#: ../doc/reference/reference_lua/tap.rst:246
#: ../doc/reference/reference_lua/tap.rst:259
#: ../doc/reference/reference_lua/tap.rst:269
#: ../doc/reference/reference_lua/tap.rst:284
#: ../doc/reference/reference_lua/tap.rst:305
#: ../doc/reference/reference_lua/tap.rst:324
#: ../doc/reference/reference_lua/utf8.rst:147
#: ../doc/reference/reference_lua/utf8.rst:172
#: ../doc/reference/reference_lua/utf8.rst:194
#: ../doc/reference/reference_lua/utf8.rst:216
#: ../doc/reference/reference_rock/membership.rst:172
#: ../doc/reference/reference_rock/membership.rst:232
#: ../doc/reference/reference_rock/membership.rst:244
#: ../doc/reference/reference_rock/membership.rst:255
#: ../doc/reference/reference_rock/membership.rst:268
#: ../doc/reference/reference_rock/membership.rst:278
#: ../doc/reference/reference_rock/membership.rst:285
msgid "boolean"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:855
msgid "Close the channel. All waiters in the channel will stop waiting. All following ``channel:get()`` operations will return ``nil``, and all following ``channel:put()`` operations will return ``false``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:863
msgid "Fetch and remove a message from a channel. If the channel is empty, ``channel:get()`` waits for a message."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:866
msgid "maximum number of seconds to wait for a message"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:867
msgid "If timeout is specified, and there is no message in the channel for the duration of the timeout, then the return value is ``nil``. If the channel is closed, then the return value is ``nil``. Otherwise, the return value is the message placed on the channel by ``channel:put()``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:872
msgid "usually string or number or table, as determined by ``channel:put``"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:878
msgid "Check whether the channel is empty (has no messages)."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:880
msgid "``true`` if the channel is empty. Otherwise ``false``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:887
msgid "Find out how many messages are in the channel."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:889
msgid "the number of messages."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:896
msgid "Check whether the channel is full."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:898
msgid "``true`` if the channel is full (the number of messages in the channel equals the number of slots so there is no room for a new message). Otherwise ``false``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:907
msgid "Check whether readers are waiting for a message because they have issued ``channel:get()`` and the channel is empty."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:910
msgid "``true`` if readers are waiting. Otherwise ``false``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:917
msgid "Check whether writers are waiting because they have issued ``channel:put()`` and the channel is full."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:920
msgid "``true`` if writers are waiting. Otherwise ``false``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:927
msgid "``true`` if the channel is already closed. Otherwise ``false``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:935
msgid "This example should give a rough idea of what some functions for fibers should look like. It's assumed that the functions would be referenced in :ref:`fiber.create() <fiber-create>`."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:939
msgid "fiber = require('fiber')\n"
"channel = fiber.channel(10)\n"
"function consumer_fiber()\n"
"    while true do\n"
"        local task = channel:get()\n"
"        ...\n"
"    end\n"
"end\n"
"\n"
"function consumer2_fiber()\n"
"    while true do\n"
"        -- 10 seconds\n"
"        local task = channel:get(10)\n"
"        if task ~= nil then\n"
"            ...\n"
"        else\n"
"            -- timeout\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"function producer_fiber()\n"
"    while true do\n"
"        task = box.space...:select{...}\n"
"        ...\n"
"        if channel:is_empty() then\n"
"            -- channel is empty\n"
"        end\n"
"\n"
"        if channel:is_full() then\n"
"            -- channel is full\n"
"        end\n"
"\n"
"        ...\n"
"        if channel:has_readers() then\n"
"            -- there are some fibers\n"
"            -- that are waiting for data\n"
"        end\n"
"        ...\n"
"\n"
"        if channel:has_writers() then\n"
"            -- there are some fibers\n"
"            -- that are waiting for readers\n"
"        end\n"
"        channel:put(task)\n"
"    end\n"
"end\n"
"\n"
"function producer2_fiber()\n"
"    while true do\n"
"        task = box.space...select{...}\n"
"        -- 10 seconds\n"
"        if channel:put(task, 10) then\n"
"            ...\n"
"        else\n"
"            -- timeout\n"
"        end\n"
"    end\n"
"end"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1005
msgid "Condition variables"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1007
msgid "Call ``fiber.cond()`` to create a named condition variable, which will be called 'cond' for examples in this section."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1010
msgid "Call ``cond:wait()`` to make a fiber wait for a signal via a condition variable."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1012
msgid "Call ``cond:signal()`` to send a signal to wake up a single fiber that has executed ``cond:wait()``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1015
msgid "Call ``cond:broadcast()`` to send a signal to all fibers that have executed ``cond:wait()``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1022
msgid "Create a new condition variable."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1024
msgid "new condition variable."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1025
msgid "Lua object"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1033
msgid "Make the current fiber go to sleep, waiting until another fiber invokes the ``signal()`` or ``broadcast()`` method on the cond object. The sleep causes an implicit :ref:`fiber.yield() <fiber-yield>`."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1037
msgid "number of seconds to wait, default = forever."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1038
msgid "If timeout is provided, and a signal doesn't happen for the duration of the timeout, ``wait()`` returns false. If a signal or broadcast happens, ``wait()`` returns true."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1047
msgid "Wake up a single fiber that has executed ``wait()`` for the same variable."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1056
msgid "Wake up all fibers that have executed ``wait()`` for the same variable."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1064
msgid "Assume that a tarantool instance is running and listening for connections on localhost port 3301. Assume that guest users have privileges to connect. We will use the tarantoolctl utility to start two clients."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1068
msgid "On terminal #1, say"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1070
msgid "$ tarantoolctl connect '3301'\n"
"tarantool> fiber = require('fiber')\n"
"tarantool> cond = fiber.cond()\n"
"tarantool> cond:wait()"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1077
msgid "The job will hang because ``cond:wait()`` -- without an optional timeout argument -- will go to sleep until the condition variable changes."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1080
msgid "On terminal #2, say"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1082
msgid "$ tarantoolctl connect '3301'\n"
"tarantool> cond:signal()"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1087
msgid "Now look again at terminal #1. It will show that the waiting stopped, and the ``cond:wait()`` function returned ``true``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:1090
msgid "This example depended on the use of a global conditional variable with the arbitrary name ``cond``. In real life, programmers would make sure to use different conditional variable names for different applications."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:5
msgid "Module `fio`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:13
msgid "Tarantool supports file input/output with an API that is similar to POSIX syscalls. All operations are performed asynchronously. Multiple fibers can access the same file simultaneously."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:17
msgid "The ``fio`` module contains:"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:19
msgid "functions for :ref:`common pathname manipulations <fio-pathname>`,"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:20
msgid "functions for :ref:`directory or file existence and type checks<fio-checks>`,"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:21
msgid "functions for :ref:`common file manipulations <fio-file>`, and"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:22
msgid ":ref:`constants <fio-c>` which are the same as POSIX flag values (for example ``fio.c.flag.O_RDONLY`` = POSIX O_RDONLY)."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:29
msgid "Below is a list of all ``fio`` functions and members."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:41
msgid ":ref:`fio.pathjoin() <fio-pathjoin>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:41
msgid "Form a path name from one or more partial strings"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:44
msgid ":ref:`fio.basename() <fio-basename>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:44
msgid "Get a file name"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:47
msgid ":ref:`fio.dirname() <fio-dirname>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:47
msgid "Get a directory name"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:50
msgid ":ref:`fio.abspath() <fio-abspath>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:50
msgid "Get a directory and file name"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:53
msgid ":ref:`fio.path.exists() <fio-path_exists>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:53
#: ../doc/reference/reference_lua/fio.rst:65
msgid "Check if file or directory exists"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:56
msgid ":ref:`fio.path.is_dir() <fio-path_is_dir>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:56
msgid "Check if file or directory is a directory"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:59
msgid ":ref:`fio.path.is_file() <fio-path_is_file>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:59
msgid "Check if file or directory is a file"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:62
msgid ":ref:`fio.path.is_link() <fio-path_is_link>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:62
msgid "Check if file or directory is a link"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:65
msgid ":ref:`fio.path.lexists() <fio-path_lexists>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:68
msgid ":ref:`fio.umask() <fio-umask>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:68
msgid "Set mask bits"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:71
msgid ":ref:`fio.lstat() <fio-stat>` |br| :ref:`fio.stat() <fio-stat>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:72
msgid "Get information about a file object"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:76
msgid ":ref:`fio.mkdir() <fio-mkdir>` |br| :ref:`fio.rmdir() <fio-mkdir>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:77
msgid "Create or delete a directory"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:81
msgid ":ref:`fio.chdir() <fio-chdir>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:81
msgid "Change working directory"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:84
msgid ":ref:`fio.listdir() <fio-listdir>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:84
msgid "List files in a directory"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:87
msgid ":ref:`fio.glob() <fio-glob>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:87
msgid "Get files whose names match a given string"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:90
msgid ":ref:`fio.tempdir() <fio-tempdir>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:90
msgid "Get the name of a directory for storing temporary files"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:93
msgid ":ref:`fio.cwd() <fio-cwd>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:93
msgid "Get the name of the current working directory"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:96
msgid ":ref:`fio.copytree() <fio-copytree>` |br| :ref:`fio.mktree() <fio-mktree>` |br| :ref:`fio.rmtree() <fio-rmtree>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:99
msgid "Create and delete directories"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:103
msgid ":ref:`fio.link() <fio-link>` |br| :ref:`fio.symlink() <fio-link>` |br| :ref:`fio.readlink() <fio-link>` |br| :ref:`fio.unlink() <fio-link>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:106
msgid "Create and delete links"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:112
msgid ":ref:`fio.rename() <fio-rename>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:112
#: ../doc/reference/reference_lua/osmodule.rst:43
msgid "Rename a file or directory"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:115
msgid ":ref:`fio.copyfile() <fio-copyfile>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:115
msgid "Copy a file"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:118
msgid ":ref:`fio.chown() <fio-chown>` |br| :ref:`fio.chmod() <fio-chown>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:119
msgid "Manage rights to and ownership of file objects"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:123
msgid ":ref:`fio.truncate() <fio-truncate>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:123
msgid "Reduce the file size"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:126
msgid ":ref:`fio.sync() <fio-sync>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:126
msgid "Ensure that changes are written to disk"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:129
msgid ":ref:`fio.open() <fio-open>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:129
msgid "Open a file"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:132
msgid ":ref:`file-handle:close() <file_handle-close>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:132
msgid "Close a file"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:135
msgid ":ref:`file-handle:pread() <file_handle-pread>` |br| :ref:`file-handle:pwrite() <file_handle-pwrite>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:136
msgid "Perform random-access read or write on a file"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:140
msgid ":ref:`file-handle:read() <file_handle-read>` |br| :ref:`file-handle:write() <file_handle-write>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:141
msgid "Perform non-random-access read or write on a file"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:145
msgid ":ref:`file-handle:truncate() <file_handle-truncate>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:145
msgid "Change the size of an open file"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:148
msgid ":ref:`file-handle:seek() <file_handle-seek>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:148
msgid "Change position in a file"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:151
msgid ":ref:`file-handle:stat() <file_handle-stat>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:151
msgid "Get statistics about an open file"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:154
msgid ":ref:`file-handle:fsync() <file_handle-fsync>` |br| :ref:`file-handle:fdatasync() <file_handle-fsync>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:155
msgid "Ensure that changes made to an open file are written to disk"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:159
msgid ":ref:`fio.c <fio-c_table>`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:159
msgid "Table of constants similar to POSIX flag values"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:169
msgid "Common pathname manipulations"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:175
msgid "Concatenate partial string, separated by '/' to form a path name."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:177
msgid "one or more strings to be concatenated."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:178
#: ../doc/reference/reference_lua/fio.rst:197
#: ../doc/reference/reference_lua/fio.rst:218
msgid "path name"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:183
msgid "tarantool> fio.pathjoin('/etc', 'default', 'myfile')\n"
"---\n"
"- /etc/default/myfile\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:194
msgid "Given a full path name, remove all but the final part (the file name). Also remove the suffix, if it is passed."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:198
msgid "suffix"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:200
#: ../doc/reference/reference_lua/fio.rst:237
msgid "file name"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:205
msgid "tarantool> fio.basename('/path/to/my.lua', '.lua')\n"
"---\n"
"- my\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:216
msgid "Given a full path name, remove the final part (the file name)."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:220
msgid "directory name, that is, path name except for file name."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:225
msgid "tarantool> fio.dirname('path/to/my.lua')\n"
"---\n"
"- 'path/to/'"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:235
msgid "Given a final part (the file name), return the full path name."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:239
msgid "directory name, that is, path name including file name."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:244
msgid "tarantool> fio.abspath('my.lua')\n"
"---\n"
"- 'path/to/my.lua'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:255
msgid "Directory or file existence and type checks"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:257
msgid "Functions in this section are similar to some `Python os.path <https://docs.python.org/2/library/os.path.htmll>`_ functions."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:265
#: ../doc/reference/reference_lua/fio.rst:273
#: ../doc/reference/reference_lua/fio.rst:281
#: ../doc/reference/reference_lua/fio.rst:289
#: ../doc/reference/reference_lua/fio.rst:297
msgid "path to directory or file."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:266
msgid "true if path-name refers to a directory or file that exists and is not a broken symbolic link; otherwise false"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:274
msgid "true if path-name refers to a directory; otherwise false"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:282
msgid "true if path-name refers to a file; otherwise false"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:290
msgid "true if path-name refers to a symbolic link; otherwise false"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:298
msgid "true if path-name refers to a directory or file that exists or is a broken symbolic link; otherwise false"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:305
msgid "Common file manipulations"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:311
msgid "Set the mask bits used when creating files or directories. For a detailed description type ``man 2 umask``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:314
msgid "mask bits."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:315
msgid "previous mask bits."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:320
msgid "tarantool> fio.umask(tonumber('755', 8))\n"
"---\n"
"- 493\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:332
msgid "Returns information about a file object. For details type ``man 2 lstat`` or ``man 2 stat``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:335
msgid "path name of file."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:336
msgid "(If no error) table of fields which describe the file's block size, creation time, size, and other attributes. |br| (If error) two return values: null, error message."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:339
msgid "table."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:341
msgid "Additionally, the result of ``fio.stat('file-name')`` will include methods equivalent to POSIX macros:"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:344
msgid "``is_blk()`` = POSIX macro S_ISBLK,"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:345
msgid "``is_chr()`` = POSIX macro S_ISCHR,"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:346
msgid "``is_dir()`` = POSIX macro S_ISDIR,"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:347
msgid "``is_fifo()`` = POSIX macro S_ISFIFO,"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:348
msgid "``is_link()`` = POSIX macro S_ISLINK,"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:349
msgid "``is_reg()`` = POSIX macro S_ISREG,"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:350
msgid "``is_sock()`` = POSIX macro S_ISSOCK."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:352
msgid "For example, ``fio.stat('/'):is_dir()`` will return true."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:356
msgid "tarantool> fio.lstat('/etc')\n"
"---\n"
"- inode: 1048577\n"
"  rdev: 0\n"
"  size: 12288\n"
"  atime: 1421340698\n"
"  mode: 16877\n"
"  mtime: 1424615337\n"
"  nlink: 160\n"
"  uid: 0\n"
"  blksize: 4096\n"
"  gid: 0\n"
"  ctime: 1424615337\n"
"  dev: 2049\n"
"  blocks: 24\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:382
msgid "Create or delete a directory. For details type ``man 2 mkdir`` or ``man 2 rmdir``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:385
#: ../doc/reference/reference_lua/fio.rst:409
#: ../doc/reference/reference_lua/fio.rst:429
msgid "path of directory."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:386
msgid "Mode bits can be passed as a number or as string constants, for example ``S_IWUSR``. Mode bits can be combined by enclosing them in braces."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:389
#: ../doc/reference/reference_lua/fio.rst:509
#: ../doc/reference/reference_lua/fio.rst:531
#: ../doc/reference/reference_lua/fio.rst:606
#: ../doc/reference/reference_lua/fio.rst:629
#: ../doc/reference/reference_lua/fio.rst:677
msgid "(If no error) true. |br| (If error) two return values: false, error message."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:395
msgid "tarantool> fio.mkdir('/etc')\n"
"---\n"
"- false\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:406
msgid "Change working directory. For details type ``man 2 chdir``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:410
msgid "(If success) true. (If failure) false."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:415
msgid "tarantool> fio.chdir('/etc')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:426
msgid "List files in directory. The result is similar to the result from the ``ls`` command."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:430
msgid "(If no error) a list of files. |br| (If error) two return values: null, error message."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:436
msgid "tarantool> fio.listdir('/usr/lib/tarantool')\n"
"---\n"
"- - mysql\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:447
msgid "Return a list of files that match an input string. The list is constructed with a single flag that controls the behavior of the function: ``GLOB_NOESCAPE``. For details type ``man 3 glob``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:451
msgid "path-name, which may contain wildcard characters."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:452
msgid "list of files whose names match the input string"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:455
#: ../doc/reference/reference_lua/fio.rst:761
#: ../doc/reference/reference_lua/fio.rst:994
msgid "**Possible errors:** nil."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:459
msgid "tarantool> fio.glob('/etc/x*')\n"
"---\n"
"- - /etc/xdg\n"
"  - /etc/xml\n"
"  - /etc/xul-ext\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:472
msgid "Return the name of a directory that can be used to store temporary files."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:476
msgid "tarantool> fio.tempdir()\n"
"---\n"
"- /tmp/lG31e7\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:487
msgid "Return the name of the current working directory."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:491
msgid "tarantool> fio.cwd()\n"
"---\n"
"- /home/username/tarantool_sandbox\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:502
msgid "Copy everything in the from-path, including subdirectory contents, to the to-path. The result is similar to the result that one gets from the ``cp -r`` command. The to-path should be empty."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:507
#: ../doc/reference/reference_lua/fio.rst:508
#: ../doc/reference/reference_lua/fio.rst:530
#: ../doc/reference/reference_lua/fio.rst:553
msgid "path-name."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:515
msgid "tarantool> fio.copytree('/home/original','/home/archives')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:526
msgid "Create the path, including subdirectories, but without file contents. The result is similar to the result that one gets from the ``mkdir`` command."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:537
msgid "tarantool> fio.mktree('/home/archives')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:548
msgid "Remove the directory indicated by path-name, including subdirectories. The result is similar to the result that one gets from the ``rmdir`` command, recursively. The directory must be empty."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:554
msgid "(If no error) true. |br| (If error) two return values: null, error message."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:560
msgid "tarantool> fio.rmtree('/home/archives')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:574
msgid "Functions to create and delete links. For details type ``man readlink``, ``man 2 link``, ``man 2 symlink``, ``man 2 unlink``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:577
msgid "existing file name."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:578
msgid "linked name."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:580
msgid "(If no error) ``fio.link`` and ``fio.symlink`` and ``fio.unlink`` return true, ``fio.readlink`` returns the link value. |br| (If error) two return values: false|null, error message."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:586
msgid "tarantool> fio.link('/home/username/tmp.txt', '/home/username/tmp.txt2')\n"
"---\n"
"- true\n"
"...\n"
"tarantool> fio.unlink('/home/username/tmp.txt2')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:601
msgid "Rename a file or directory. For details type ``man 2 rename``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:603
msgid "original name."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:604
msgid "new name."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:612
msgid "tarantool> fio.rename('/home/username/tmp.txt', '/home/username/tmp.txt2')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:623
msgid "Copy a file. The effect is similar to the effect that one gets with the ``cp`` command."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:626
msgid "path to original file."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:627
msgid "path to new file."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:635
msgid "tarantool> fio.copyfile('/home/user/tmp.txt', '/home/usern/tmp.txt2')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:647
msgid "Manage the rights to file objects, or ownership of file objects. For details type ``man 2 chown`` or ``man 2 chmod``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:650
msgid "new user uid."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:651
msgid "new group uid."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:652
msgid "new permissions"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:653
msgid "null"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:657
msgid "tarantool> fio.chmod('/home/username/tmp.txt', tonumber('0755', 8))\n"
"---\n"
"- true\n"
"...\n"
"tarantool> fio.chown('/home/username/tmp.txt', 'username', 'username')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:672
msgid "Reduce file size to a specified value. For details type ``man 2 truncate``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:683
msgid "tarantool> fio.truncate('/home/username/tmp.txt', 99999)\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:694
msgid "Ensure that changes are written to disk. For details type ``man 2 sync``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:696
#: ../doc/reference/reference_lua/fio.rst:797
#: ../doc/reference/reference_lua/fio.rst:856
#: ../doc/reference/reference_lua/fio.rst:941
#: ../doc/reference/reference_lua/fio.rst:968
#: ../doc/reference/reference_lua/fio.rst:1048
msgid "true if success, false if failure."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:701
msgid "tarantool> fio.sync()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:716
msgid "Open a file in preparation for reading or writing or seeking."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:718
msgid "Full path to the file to open."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:719
msgid "Flags can be passed as a number or as string constants, for example '``O_RDONLY``', '``O_WRONLY``', '``O_RDWR``'. Flags can be combined by enclosing them in braces. On Linux the full set of flags as described on the `Linux man page <http://man7.org/linux/man-pages/man2/open.2.html>`_ is:  * O_APPEND (start at end of file), * O_ASYNC (signal when IO is possible), * O_CLOEXEC (enable a flag related to closing), * O_CREAT (create file if it doesn't exist), * O_DIRECT (do less caching or no caching), * O_DIRECTORY (fail if it's not a directory), * O_EXCL (fail if file cannot be created), * O_LARGEFILE (allow 64-bit file offsets), * O_NOATIME (no access-time updating), * O_NOCTTY (no console tty), * O_NOFOLLOW (no following symbolic links), * O_NONBLOCK (no blocking), * O_PATH (get a path for low-level use), * O_SYNC (force writing if it's possible), * O_TMPFILE (the file will be temporary and nameless), * O_TRUNC (truncate)  ... and, always, one of:  * O_RDONLY (read only), * O_WRONLY (write only), or * O_RDWR (either read or write)."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:719
msgid "Flags can be passed as a number or as string constants, for example '``O_RDONLY``', '``O_WRONLY``', '``O_RDWR``'. Flags can be combined by enclosing them in braces. On Linux the full set of flags as described on the `Linux man page <http://man7.org/linux/man-pages/man2/open.2.html>`_ is:"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:728
msgid "O_APPEND (start at end of file),"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:729
msgid "O_ASYNC (signal when IO is possible),"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:730
msgid "O_CLOEXEC (enable a flag related to closing),"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:731
msgid "O_CREAT (create file if it doesn't exist),"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:732
msgid "O_DIRECT (do less caching or no caching),"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:733
msgid "O_DIRECTORY (fail if it's not a directory),"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:734
msgid "O_EXCL (fail if file cannot be created),"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:735
msgid "O_LARGEFILE (allow 64-bit file offsets),"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:736
msgid "O_NOATIME (no access-time updating),"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:737
msgid "O_NOCTTY (no console tty),"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:738
msgid "O_NOFOLLOW (no following symbolic links),"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:739
msgid "O_NONBLOCK (no blocking),"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:740
msgid "O_PATH (get a path for low-level use),"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:741
msgid "O_SYNC (force writing if it's possible),"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:742
msgid "O_TMPFILE (the file will be temporary and nameless),"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:743
msgid "O_TRUNC (truncate)"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:745
msgid "... and, always, one of:"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:747
msgid "O_RDONLY (read only),"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:748
msgid "O_WRONLY (write only), or"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:749
msgid "O_RDWR (either read or write)."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:751
msgid "Mode bits can be passed as a number or as string constants, for example ``S_IWUSR``. Mode bits are significant if flags include ``O_CREAT`` or ``O_TMPFILE``. Mode bits can be combined by enclosing them in braces."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:756
msgid "(If no error) file handle (abbreviated as 'fh' in later description). |br| (If error) two return values: null, error message."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:763
#: ../doc/reference/reference_lua/http.rst:210
msgid "**Example 1:**"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:765
msgid "tarantool> fh = fio.open('/home/username/tmp.txt', {'O_RDWR', 'O_APPEND'})\n"
"---\n"
"...\n"
"tarantool> fh -- display file handle returned by fio.open\n"
"---\n"
"- fh: 11\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:775
#: ../doc/reference/reference_lua/http.rst:239
msgid "**Example 2:**"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:777
msgid "Using ``fio.open()`` with ``tonumber('N', 8)`` to set permissions as an octal number:"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:780
msgid "tarantool> fio.open('x.txt', {'O_WRONLY', 'O_CREAT'}, tonumber('644',8))\n"
"---\n"
"- fh: 12\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:793
msgid "Close a file that was opened with ``fio.open``. For details type ``man 2 close``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:796
#: ../doc/reference/reference_lua/fio.rst:818
#: ../doc/reference/reference_lua/fio.rst:851
#: ../doc/reference/reference_lua/fio.rst:892
#: ../doc/reference/reference_lua/fio.rst:937
#: ../doc/reference/reference_lua/fio.rst:967
#: ../doc/reference/reference_lua/fio.rst:987
#: ../doc/reference/reference_lua/fio.rst:1013
#: ../doc/reference/reference_lua/fio.rst:1047
msgid "file-handle as returned by ``fio.open()``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:802
msgid "tarantool> fh:close() -- where fh = file-handle\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:814
msgid "Perform random-access read operation on a file, without affecting the current seek position of the file. For details type ``man 2 pread``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:819
msgid "where to read into (if the format is ``pread(buffer, count, offset)``)"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:821
#: ../doc/reference/reference_lua/fio.rst:895
msgid "number of bytes to read"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:822
msgid "offset within file where reading begins"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:824
msgid "If the format is ``pread(count, offset)`` then return a string containing the data that was read from the file, or nil if failure."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:827
msgid "If the format is ``pread(buffer, count, offset)`` then return the data to the buffer. (Buffers can be acquired with :ref:`buffer.ibuf <buffer-module>`.)"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:833
msgid "tarantool> fh:pread(25, 25)\n"
"---\n"
"- |\n"
"  elete from t8//\n"
"  insert in\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:847
msgid "Perform random-access write operation on a file, without affecting the current seek position of the file. For details type ``man 2 pwrite``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:852
#: ../doc/reference/reference_lua/fio.rst:938
msgid "value to write"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:853
msgid "number of bytes to write (if the format is ``pwrite(buffer, count, offset)``)"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:855
msgid "offset within file where writing begins"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:859
msgid "If the format is ``pwrite(new-string, offset)`` then the returned string is written to the file, as far as the end of the string."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:862
msgid "If the format is ``pwrite(buffer, count, offset)`` then the buffer contents are written to the file, for ``count`` bytes. (Buffers can be acquired with :ref:`buffer.ibuf <buffer-module>`.)"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:866
msgid "ibuf = require('buffer').ibuf()\n"
"---\n"
"...\n"
"\n"
"tarantool> fh:pwrite(ibuf, 1, 0)\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:882
msgid "Perform non-random-access read on a file. For details type ``man 2 read`` or ``man 2 write``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:887
#: ../doc/reference/reference_lua/fio.rst:932
msgid "``fh:read`` and ``fh:write`` affect the seek position within the file, and this must be taken into account when working on the same file from multiple fibers. It is possible to limit or prevent file access from other fibers with ``fiber.ipc``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:893
msgid "where to read into (if the format is ``read(buffer, count)``)"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:897
msgid "If the format is ``read()`` -- omitting ``count`` -- then read all bytes in the file."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:900
msgid "If the format is ``read()``  or ``read([count])`` then return a string containing the data that was read from the file, or nil if failure."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:903
msgid "If the format is ``read(buffer, count)`` then return the data to the buffer. (Buffers can be acquired with :ref:`buffer.ibuf <buffer-module>`.)"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:907
msgid "ibuf = require('buffer').ibuf()\n"
"---\n"
"...\n"
"\n"
"tarantool> fh:read(ibuf:reserve(5), 5)\n"
"---\n"
"- 5\n"
"...\n"
"\n"
"tarantool> require('ffi').string(ibuf:alloc(5),5)\n"
"---\n"
"- abcde"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:927
msgid "Perform non-random-access write on a file. For details type ``man 2 write``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:939
msgid "number of bytes to write (if the format is ``write(buffer, count)``)"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:944
msgid "If the format is ``write(new-string)`` then the returned string is written to the file, as far as the end of the string."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:947
msgid "If the format is ``write(buffer, count)`` then the buffer contents are written to the file, for ``count`` bytes. (Buffers can be acquired with :ref:`buffer.ibuf <buffer-module>`.)"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:953
msgid "tarantool> fh:write(\"new data\")\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:964
msgid "Change the size of an open file. Differs from ``fio.truncate``, which changes the size of a closed file."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:973
msgid "tarantool> fh:truncate(0)\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:984
msgid "Shift position in the file to the specified position. For details type ``man 2 seek``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:988
msgid "position to seek to"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:989
msgid "'``SEEK_END``' = end of file, '``SEEK_CUR``' = current position, '``SEEK_SET``' = start of file."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:991
msgid "the new position if success"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:998
msgid "tarantool> fh:seek(20, 'SEEK_SET')\n"
"---\n"
"- 20\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:1009
msgid "Return statistics about an open file. This differs from ``fio.stat`` which return statistics about a closed file. For details type ``man 2 stat``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:1014
msgid "details about the file."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:1019
msgid "tarantool> fh:stat()\n"
"---\n"
"- inode: 729866\n"
"  rdev: 0\n"
"  size: 100\n"
"  atime: 140942855\n"
"  mode: 33261\n"
"  mtime: 1409430660\n"
"  nlink: 1\n"
"  uid: 1000\n"
"  blksize: 4096\n"
"  gid: 1000\n"
"  ctime: 1409430660\n"
"  dev: 2049\n"
"  blocks: 8\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:1043
msgid "Ensure that file changes are written to disk, for an open file. Compare ``fio.sync``, which is for all files. For details type ``man 2 fsync`` or ``man 2 fdatasync``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:1052
msgid "tarantool> fh:fsync()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:1063
msgid "FIO constants"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:1069
msgid "Table with constants which are the same as POSIX flag values on the target platform (see ``man 2 stat``)."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:1074
msgid "tarantool> fio.c\n"
"---\n"
"- seek:\n"
"    SEEK_SET: 0\n"
"    SEEK_END: 2\n"
"    SEEK_CUR: 1\n"
"  mode:\n"
"    S_IWGRP: 16\n"
"    S_IXGRP: 8\n"
"    S_IROTH: 4\n"
"    S_IXOTH: 1\n"
"    S_IRUSR: 256\n"
"    S_IXUSR: 64\n"
"    S_IRWXU: 448\n"
"    S_IRWXG: 56\n"
"    S_IWOTH: 2\n"
"    S_IRWXO: 7\n"
"    S_IWUSR: 128\n"
"    S_IRGRP: 32\n"
"  flag:\n"
"    O_EXCL: 2048\n"
"    O_NONBLOCK: 4\n"
"    O_RDONLY: 0\n"
"    <...>\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fun.rst:5
msgid "Module `fun`"
msgstr ""

#: ../doc/reference/reference_lua/fun.rst:7
msgid "Luafun, also known as the Lua Functional Library, takes advantage of the features of LuaJIT to help users create complex functions. Inside the module are \"sequence processors\" such as ``map``, ``filter``, ``reduce``, ``zip`` -- they take a user-written function as an argument and run it against every element in a sequence, which can be faster or more convenient than a user-written loop. Inside the module are \"generators\" such as ``range``, ``tabulate``, and ``rands`` -- they return a bounded or boundless series of values. Within the module are \"reducers\", \"filters\", \"composers\" ... or, in short, all the important features found in languages like Standard ML, Haskell, or Erlang."
msgstr ""

#: ../doc/reference/reference_lua/fun.rst:17
msgid "The full documentation is `On the luafun section of github`_. However, the first chapter can be skipped because installation is already done, it's inside Tarantool. All that is needed is the usual ``require`` request. After that, all the operations described in the Lua fun manual will work, provided they are preceded by the name returned by the ``require`` request. For example:"
msgstr ""

#: ../doc/reference/reference_lua/fun.rst:23
msgid "tarantool> fun = require('fun')\n"
"---\n"
"...\n"
"tarantool> for _k, a in fun.range(3) do\n"
"         >   print(a)\n"
"         > end\n"
"1\n"
"2\n"
"3\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:5
msgid "Module `http`"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:13
msgid "The ``http`` module, specifically the ``http.client`` submodule, provides the functionality of an HTTP client with support for HTTPS and keepalive. It uses routines in the `libcurl <https://curl.haxx.se/libcurl/>`_ library."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:21
msgid "Below is a list of all ``http`` functions."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:31
msgid ":ref:`http.client.new() <http-new>`"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:31
msgid "Create an HTTP client instance"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:34
msgid ":ref:`client_object:request() <client_object-request>`"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:34
msgid "Perform an HTTP request"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:37
msgid ":ref:`client_object:stat() <client_object-stat>`"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:37
msgid "Get a table with statistics"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:45
msgid "Construct a new HTTP client instance."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:47
msgid "integer settings which are passed to libcurl."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:49
msgid "The two possible options are ``max_connections`` and ``max_total_connections``."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:51
msgid "``max_connections`` is the maximum number of entries in the cache. It affects libcurl `CURLMOPT_MAXCONNECTS <https://curl.haxx.se/libcurl/c/CURLMOPT_MAXCONNECTS.html>`_. The default is -1."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:55
msgid "``max_total_connections`` is the maximum number of active connections. It affects libcurl  `CURLMOPT_MAX_TOTAL_CONNECTIONS <https://curl.haxx.se/libcurl/c/CURLMOPT_MAX_TOTAL_CONNECTIONS.html>`_. It is ignored if the curl version is less than 7.30. The default is 0, which allows libcurl to scale according to easy handles count."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:60
msgid "The default option values are usually good enough but in rare cases it might be good to set them. In that case here are two tips."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:63
msgid "1. You may want to control the maximum number of sockets that a particular http client uses simultaneously. If a system passes many requests to distinct hosts, then libcurl cannot reuse sockets. In this case setting ``max_total_connections`` may be useful, since it causes curl to avoid creating too many sockets which would not be used anyway."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:68
msgid "2. Do not set ``max_connections`` less than ``max_total_connections`` unless you are confident about your actions. When ``max_connections`` is less then ``max_total_connections``, in some cases libcurl will not reuse sockets for requests that are going to the same host. If the limit is reached and a new request occurs, then libcurl will first create a new socket, send the request, wait for the first connection to be free, and close it, in order to avoid exceeding the ``max_connections`` cache size. In the worst case, libcurl will create a new socket for every request, even if all requests are going to the same host. See `this Tarantool issue on github <https://github.com/tarantool/tarantool/issues/3945>`_ for details."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:80
msgid "a new HTTP client instance"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:85
msgid "tarantool> http_client = require('http.client').new({max_connections = 5})\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:97
msgid "If ``http_client`` is an HTTP client instance, ``http_client:request()`` will perform an HTTP request and, if there is a successful connection, will return a table with connection information."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:101
msgid "HTTP method, for example 'GET' or 'POST' or 'PUT'"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:102
msgid "location, for example 'https://tarantool.org/doc'"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:103
msgid "optional initial message, for example 'My text string!'"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:104
msgid "table of connection options, with any of these components:   * ``timeout`` - number of seconds to wait for a curl API read request    before timing out  * ``ca_path`` - path to a directory holding one or more certificates to    verify the peer with  * ``ca_file`` - path to an SSL certificate file to verify the peer with  * ``verify_host`` - set on/off verification of the certificate's name    (CN) against host. See also    `CURLOPT_SSL_VERIFYHOST <https://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYHOST.html>`_  * ``verify_peer`` - set on/off verification of the peer's SSL    certificate. See also    `CURLOPT_SSL_VERIFYPEER <https://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYPEER.html>`_  * ``ssl_key`` - path to a private key file for a TLS and SSL client    certificate. See also    `CURLOPT_SSLKEY <https://curl.haxx.se/libcurl/c/CURLOPT_SSLKEY.html>`_  * ``ssl_cert`` - path to a SSL client certificate file. See also    `CURLOPT_SSLCERT <https://curl.haxx.se/libcurl/c/CURLOPT_SSLCERT.html>`_  * ``headers`` - table of HTTP headers  * ``keepalive_idle`` - delay, in seconds, that the operating system    will wait while the connection is idle before sending keepalive    probes. See also    `CURLOPT_TCP_KEEPIDLE <https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPIDLE.html>`_    and the note below about keepalive_interval.  * ``keepalive_interval`` - the interval, in seconds, that the operating    system will wait between sending keepalive probes. See also    `CURLOPT_TCP_KEEPINTVL <https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPINTVL.html>`_.    If both keepalive_idle and keepalive_interval are set, then    Tarantool will also set HTTP keepalive headers: Connection:Keep-Alive    and Keep-Alive:timeout=<keepalive_idle>.    Otherwise Tarantool will send Connection:close  * ``low_speed_time`` - set the \"low speed time\" -- the time that the    transfer speed should be below the \"low speed limit\" for the library    to consider it too slow and abort. See also    `CURLOPT_LOW_SPEED_TIME <https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_TIME.html>`_  * ``low_speed_limit`` - set the \"low speed limit\" -- the average    transfer speed in bytes per second that the transfer should be below    during \"low speed time\" seconds for the library to consider it to be    too slow and abort. See also    `CURLOPT_LOW_SPEED_LIMIT <https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_LIMIT.html>`_  * ``verbose`` - set on/off verbose mode  * ``unix_socket`` - a socket name to use instead of an Internet address,    for a local connection. The Tarantool server must be built with    ``libcurl`` 7.40 or later. See the :ref:`second example <http-example2>`    later in this section.  * ``max_header_name_len`` - the maximal length of a header name. If a header    name is bigger than this value, it is truncated to this length.    The default value is '32'."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:104
msgid "table of connection options, with any of these components:"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:107
msgid "``timeout`` - number of seconds to wait for a curl API read request before timing out"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:109
msgid "``ca_path`` - path to a directory holding one or more certificates to verify the peer with"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:111
msgid "``ca_file`` - path to an SSL certificate file to verify the peer with"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:112
msgid "``verify_host`` - set on/off verification of the certificate's name (CN) against host. See also `CURLOPT_SSL_VERIFYHOST <https://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYHOST.html>`_"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:115
msgid "``verify_peer`` - set on/off verification of the peer's SSL certificate. See also `CURLOPT_SSL_VERIFYPEER <https://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYPEER.html>`_"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:118
msgid "``ssl_key`` - path to a private key file for a TLS and SSL client certificate. See also `CURLOPT_SSLKEY <https://curl.haxx.se/libcurl/c/CURLOPT_SSLKEY.html>`_"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:121
msgid "``ssl_cert`` - path to a SSL client certificate file. See also `CURLOPT_SSLCERT <https://curl.haxx.se/libcurl/c/CURLOPT_SSLCERT.html>`_"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:123
msgid "``headers`` - table of HTTP headers"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:124
msgid "``keepalive_idle`` - delay, in seconds, that the operating system will wait while the connection is idle before sending keepalive probes. See also `CURLOPT_TCP_KEEPIDLE <https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPIDLE.html>`_ and the note below about keepalive_interval."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:129
msgid "``keepalive_interval`` - the interval, in seconds, that the operating system will wait between sending keepalive probes. See also `CURLOPT_TCP_KEEPINTVL <https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPINTVL.html>`_. If both keepalive_idle and keepalive_interval are set, then Tarantool will also set HTTP keepalive headers: Connection:Keep-Alive and Keep-Alive:timeout=<keepalive_idle>. Otherwise Tarantool will send Connection:close"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:136
msgid "``low_speed_time`` - set the \"low speed time\" -- the time that the transfer speed should be below the \"low speed limit\" for the library to consider it too slow and abort. See also `CURLOPT_LOW_SPEED_TIME <https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_TIME.html>`_"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:140
msgid "``low_speed_limit`` - set the \"low speed limit\" -- the average transfer speed in bytes per second that the transfer should be below during \"low speed time\" seconds for the library to consider it to be too slow and abort. See also `CURLOPT_LOW_SPEED_LIMIT <https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_LIMIT.html>`_"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:145
msgid "``verbose`` - set on/off verbose mode"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:146
msgid "``unix_socket`` - a socket name to use instead of an Internet address, for a local connection. The Tarantool server must be built with ``libcurl`` 7.40 or later. See the :ref:`second example <http-example2>` later in this section."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:150
msgid "``max_header_name_len`` - the maximal length of a header name. If a header name is bigger than this value, it is truncated to this length. The default value is '32'."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:154
msgid "connection information, with all of these components:"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:156
msgid "``status`` - HTTP response status"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:157
msgid "``reason`` - HTTP response status text"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:158
msgid "``headers`` - a Lua table with normalized HTTP headers"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:159
msgid "``body`` - response body"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:160
msgid "``proto`` - protocol version"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:164
msgid "The following \"shortcuts\" exist for requests:"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:166
msgid "``http_client:get(url, options)`` - shortcut for ``http_client:request(\"GET\", url, nil, opts)``"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:168
msgid "``http_client:post (url, body, options)`` - shortcut for ``http_client:request(\"POST\", url, body, opts)``"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:170
msgid "``http_client:put(url, body, options)`` - shortcut for ``http_client:request(\"PUT\", url, body, opts)``"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:172
msgid "``http_client:patch(url, body, options)`` - shortcut for ``http_client:request(\"PATCH\", url, body, opts)``"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:174
msgid "``http_client:options(url, options)`` - shortcut for ``http_client:request(\"OPTIONS\", url, nil, opts)``"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:176
msgid "``http_client:head(url, options)`` - shortcut for ``http_client:request(\"HEAD\", url, nil, opts)``"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:178
msgid "``http_client:delete(url, options)`` - shortcut for ``http_client:request(\"DELETE\", url, nil, opts)``"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:180
msgid "``http_client:trace(url, options)`` - shortcut for ``http_client:request(\"TRACE\", url, nil, opts)``"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:182
msgid "``http_client:connect:(url, options)`` - shortcut for ``http_client:request(\"CONNECT\", url, nil, opts)``"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:185
msgid "Requests may be influenced by environment variables, for example users can set up an http proxy by setting :samp:`HTTP_PROXY={proxy}` before initiating any requests. See the web page document `Environment variables libcurl understands <https://curl.haxx.se/libcurl/c/libcurl-env.html>`_."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:195
msgid "The ``http_client:stat()`` function returns a table with statistics:"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:197
msgid "``active_requests`` - number of currently executing requests"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:198
msgid "``sockets_added`` - total number of sockets added into an event loop"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:199
msgid "``sockets_deleted`` - total number of sockets sockets from an event loop"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:200
msgid "``total_requests`` - total number of requests"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:201
msgid "``http_200_responses`` - total number of requests which have returned code HTTP 200"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:203
msgid "``http_other_responses`` - total number of requests which have not returned code HTTP 200"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:205
msgid "``failed_requests`` - total number of requests which have failed including system errors, curl errors, and HTTP errors"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:212
msgid "Connect to an HTTP server, look at the size of the response for a 'GET' request, and look at the statistics for the session."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:215
msgid "tarantool> http_client = require('http.client').new()\n"
"---\n"
"...\n"
"tarantool> r = http_client:request('GET','http://tarantool.org')\n"
"---\n"
"...\n"
"tarantool> string.len(r.body)\n"
"---\n"
"- 21725\n"
"...\n"
"tarantool> http_client:stat()\n"
"---\n"
"- total_requests: 1\n"
"  sockets_deleted: 2\n"
"  failed_requests: 0\n"
"  active_requests: 0\n"
"  http_other_responses: 0\n"
"  http_200_responses: 1\n"
"  sockets_added: 2"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:241
msgid "Start two Tarantool instances on the same computer."
msgstr ""

#: ../doc/reference/reference_lua/http.rst:243
msgid "On the first Tarantool instance, listen on a Unix socket:"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:245
msgid "box.cfg{listen='/tmp/unix_domain_socket.sock'}"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:249
msgid "On the second Tarantool instance, send via ``http_client``:"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:251
msgid "box.cfg{}\n"
"http_client = require('http.client').new({5})\n"
"http_client:put('http://localhost/','body',{unix_socket = '/tmp/unix_domain_socket.sock'})"
msgstr ""

#: ../doc/reference/reference_lua/http.rst:257
msgid "Terminal #1 will show an error message: \"Invalid MsgPack\". This is not useful but demonstrates the syntax and demonstrates that was sent was received."
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:5
msgid "Module `iconv`"
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:13
msgid "The ``iconv`` module provides a way to convert a string with one encoding to a string with another encoding, for example from ASCII to UTF-8. It is based on the POSIX iconv routines."
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:17
msgid "An exact list of the available encodings may depend on environment. Typically the list includes ASCII, BIG5, KOI8R, LATIN8, MS-GREEK, SJIS, and about 100 others. For a complete list, type ``iconv --list`` on a terminal."
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:26
msgid "Below is a list of all ``iconv`` functions."
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:36
msgid ":ref:`iconv.new() <iconv-new>`"
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:36
msgid "Create an iconv instance"
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:39
msgid ":ref:`iconv.converter() <iconv-converter>`"
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:39
msgid "Perform conversion on a string"
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:47
msgid "Construct a new iconv instance."
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:49
msgid "the name of the encoding that we will convert to."
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:50
msgid "the name of the encoding that we will convert from."
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:52
msgid "a new iconv instance -- in effect, a callable function"
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:55
msgid "If either parameter is not a valid name, there will be an error message."
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:59
msgid "tarantool> converter = require('iconv').new('UTF8', 'ASCII')\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:69
msgid "Convert."
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:0
msgid "param string input-string"
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:71
msgid "the string to be converted (the \"from\" string)"
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:73
msgid "the string that results from the conversion (the \"to\" string)"
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:75
msgid "If anything in input-string cannot be converted, there will be an error message and the result string will be unchanged."
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:80
msgid "We know that the Unicode code point for \"Д\" (CYRILLIC CAPITAL LETTER DE) is hexadecimal 0414 according to the character database of Unicode_. Therefore that is what it will look like in UTF-16. We know that Tarantool typically uses the UTF-8 character set. So make a from-UTF-8-to-UTF-16 converter, use string.hex('Д') to show what Д's encoding looks like in the UTF-8 source, and use string.hex('Д'-after-conversion) to show what it looks like in the UTF-16 target. Since the result is 0414, we see that iconv conversion works. (Different iconv implementations might use different names, for example UTF-16BE instead of UTF16BE.)"
msgstr ""

#: ../doc/reference/reference_lua/iconv.rst:90
msgid "tarantool> string.hex('Д')\n"
"---\n"
"- d094\n"
"...\n"
"\n"
"tarantool> converter = require('iconv').new('UTF16BE', 'UTF8')\n"
"---\n"
"...\n"
"\n"
"tarantool> utf16_string = converter('Д')\n"
"---\n"
"...\n"
"\n"
"tarantool> string.hex(utf16_string)\n"
"---\n"
"- '0414'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/index.rst:5
msgid "Built-in modules reference"
msgstr ""

#: ../doc/reference/reference_lua/index.rst:7
msgid "This reference covers Tarantool's built-in Lua modules."
msgstr ""

#: ../doc/reference/reference_lua/index.rst:11
msgid "Some functions in these modules are analogs to functions from `standard Lua libraries <http://www.lua.org/manual/>`_. For better results, we recommend using functions from Tarantool's built-in modules."
msgstr ""

#: ../doc/reference/reference_lua/index.rst:15
msgid "List of Lua modules"
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:5
msgid "Module `jit`"
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:13
msgid "The ``jit`` module has functions for tracing the `LuaJIT <http://luajit.org>`_ Just-In-Time compiler's progress, showing the byte-code or assembler output that the compiler produces, and in general providing information about what LuaJIT does with Lua code."
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:22
msgid "Below is a list of all ``jit`` functions."
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:32
msgid ":ref:`jit.bc.dump() <jit-bc-dump>`"
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:32
msgid "Print the byte code of a function"
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:35
msgid ":ref:`jit.dis_x86.disass() <jit-dis-x86-disass>`"
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:35
msgid "Print the i386 assembler code of a string of bytes"
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:38
msgid ":ref:`jit.dis_x64.disass() <jit-dis-x64-disass>`"
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:38
msgid "Print the x86-64 assembler code of a string of bytes"
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:41
msgid ":ref:`jit.dump.on() <jit-dump-on>`, :ref:`jit.dump.off() <jit-dump-off>`"
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:41
msgid "Print the intermediate or machine code of the following Lua code"
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:46
msgid ":ref:`jit.v.on() <jit-v-on>`, :ref:`jit.v.off() <jit-v-off>`"
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:46
msgid "Print a trace of LuaJIT's progress compiling and interpreting code"
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:56
msgid "Prints the byte code of a function."
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:60
msgid "function f()\n"
"  print(\"D\")\n"
"end\n"
"jit.bc.dump(f)"
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:67
msgid "For a list of available options, read `the source code of bc.lua <https://github.com/tarantool/luajit/tree/tarantool-1.6/src/jit/bc.lua>`_."
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:74
msgid "Prints the i386 assembler code of a string of bytes."
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:78
msgid "-- Disassemble hexadecimal 97 which is the x86 code for xchg eax, edi\n"
"jit.dis_x86.disass('\\x97')"
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:83
msgid "For a list of available options, read `the source code of dis_x86.lua <https://github.com/tarantool/luajit/tree/tarantool-1.6/src/jit/dis_x86.lua>`_."
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:90
msgid "Prints the x86-64 assembler code of a string of bytes."
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:94
msgid "-- Disassemble hexadecimal 97 which is the x86-64 code for xchg eax, edi\n"
"jit.dis_x64.disass('\\x97')"
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:99
msgid "For a list of available options, read `the source code of dis_x64.lua <https://github.com/tarantool/luajit/tree/tarantool-1.6/src/jit/dis_x64.lua>`_."
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:108
msgid "Prints the intermediate or machine code of the following Lua code."
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:112
msgid "-- Show the machine code of a Lua \"for\" loop\n"
"jit.dump.on('m')\n"
"local x = 0;\n"
"for i = 1, 1e6 do\n"
"  x = x + i\n"
"end\n"
"print(x)\n"
"jit.dump.off()"
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:123
msgid "For a list of available options, read `the source code of dump.lua <https://github.com/tarantool/luajit/tree/tarantool-1.6/src/jit/dump.lua>`_."
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:132
msgid "Prints a trace of LuaJIT's progress compiling and interpreting code."
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:136
msgid "-- Show what LuaJIT is doing for a Lua \"for\" loop\n"
"jit.v.on()\n"
"local x = 0\n"
"for i = 1, 1e6 do\n"
"    x = x + i\n"
"end\n"
"print(x)\n"
"jit.v.off()"
msgstr ""

#: ../doc/reference/reference_lua/jit.rst:147
msgid "For a list of available options, read `the source code of v.lua <https://github.com/tarantool/luajit/tree/tarantool-1.6/src/jit/v.lua>`_."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:5
msgid "Module `json`"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:11
msgid "The ``json`` module provides JSON manipulation routines. It is based on the `Lua-CJSON module by Mark Pulford <http://www.kyne.com.au/~mark/software/lua-cjson.php>`_. For a complete manual on Lua-CJSON please read `the official documentation <http://www.kyne.com.au/~mark/software/lua-cjson-manual.html>`_."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:20
msgid "Below is a list of all ``json`` functions and members."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:30
msgid ":ref:`json.encode() <json-encode>`"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:30
msgid "Convert a Lua object to a JSON string"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:33
msgid ":ref:`json.decode() <json-decode>`"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:33
msgid "Convert a JSON string to a Lua object"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:36
msgid ":ref:`json.NULL <json-null>`"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:36
#: ../doc/reference/reference_lua/msgpack.rst:39
#: ../doc/reference/reference_lua/yaml.rst:34
msgid "Analog of Lua's \"nil\""
msgstr ""

#: ../doc/reference/reference_lua/json.rst:39
msgid ":ref:`json.cfg() <json-module_cfg>`"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:39
msgid "Set global flags"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:49
msgid "Convert a Lua object to a JSON string."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:51
#: ../doc/reference/reference_lua/msgpack.rst:55
#: ../doc/reference/reference_lua/yaml.rst:46
msgid "either a scalar value or a Lua table value."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:52
#: ../doc/reference/reference_lua/json.rst:91
msgid "see :ref:`json.cfg <json-module_cfg>`"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:53
msgid "the original value reformatted as a JSON string."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:58
msgid "tarantool> json=require('json')\n"
"---\n"
"...\n"
"tarantool> json.encode(123)\n"
"---\n"
"- '123'\n"
"...\n"
"tarantool> json.encode({123})\n"
"---\n"
"- '[123]'\n"
"...\n"
"tarantool> json.encode({123, 234, 345})\n"
"---\n"
"- '[123,234,345]'\n"
"...\n"
"tarantool> json.encode({abc = 234, cde = 345})\n"
"---\n"
"- '{\"cde\":345,\"abc\":234}'\n"
"...\n"
"tarantool> json.encode({hello = {'world'}})\n"
"---\n"
"- '{\"hello\":[\"world\"]}'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:88
msgid "Convert a JSON string to a Lua object."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:90
msgid "a string formatted as JSON."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:92
#: ../doc/reference/reference_lua/yaml.rst:57
msgid "the original contents formatted as a Lua table."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:97
msgid "tarantool> json = require('json')\n"
"---\n"
"...\n"
"tarantool> json.decode('123')\n"
"---\n"
"- 123\n"
"...\n"
"tarantool> json.decode('[123, \"hello\"]')\n"
"---\n"
"- [123, 'hello']\n"
"...\n"
"tarantool> json.decode('{\"hello\": \"world\"}').hello\n"
"---\n"
"- world\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:115
msgid "See the tutorial :ref:`Sum a JSON field for all tuples <c_lua_tutorial-sum_a_json_field>` to see how ``json.decode()`` can fit in an application."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:123
#: ../doc/reference/reference_lua/msgpack.rst:106
#: ../doc/reference/reference_lua/yaml.rst:64
msgid "A value comparable to Lua \"nil\" which may be useful as a placeholder in a tuple."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:128
msgid "-- When nil is assigned to a Lua-table field, the field is null\n"
"tarantool> {nil, 'a', 'b'}\n"
"---\n"
"- - null\n"
"  - a\n"
"  - b\n"
"...\n"
"-- When json.NULL is assigned to a Lua-table field, the field is json.NULL\n"
"tarantool> {json.NULL, 'a', 'b'}\n"
"---\n"
"- - null\n"
"  - a\n"
"  - b\n"
"...\n"
"-- When json.NULL is assigned to a JSON field, the field is null\n"
"tarantool> json.encode({field2 = json.NULL, field1 = 'a', field3 = 'c'})\n"
"---\n"
"- '{\"field2\":null,\"field1\":\"a\",\"field3\":\"c\"}'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:150
msgid "The JSON output structure can be specified with ``__serialize``:"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:152
msgid "``__serialize=\"seq\"`` for an array"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:153
msgid "``__serialize=\"map\"`` for a map"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:155
#: ../doc/reference/reference_lua/yaml.rst:101
msgid "Serializing 'A' and 'B' with different ``__serialize`` values causes different results:"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:158
msgid "tarantool> json.encode(setmetatable({'A', 'B'}, { __serialize=\"seq\"}))\n"
"---\n"
"- '[\"A\",\"B\"]'\n"
"...\n"
"tarantool> json.encode(setmetatable({'A', 'B'}, { __serialize=\"map\"}))\n"
"---\n"
"- '{\"1\":\"A\",\"2\":\"B\"}'\n"
"...\n"
"tarantool> json.encode({setmetatable({f1 = 'A', f2 = 'B'}, { __serialize=\"map\"})})\n"
"---\n"
"- '[{\"f2\":\"B\",\"f1\":\"A\"}]'\n"
"...\n"
"tarantool> json.encode({setmetatable({f1 = 'A', f2 = 'B'}, { __serialize=\"seq\"})})\n"
"---\n"
"- '[[]]'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:181
msgid "Set values affecting behavior of :ref:`json.encode <json-encode>` and :ref:`json.decode <json-decode>`."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:184
msgid "The values are all either integers or boolean ``true``/``false`` values."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:186
msgid "``cfg.encode_deep_as_nil`` (default is false) -- see :ref:`below <json-module.cfg_encode_deep_as_nil>`"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:187
msgid "``cfg.encode_invalid_as_nil`` (default is false) -- use ``null`` for all unrecognizable types"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:189
msgid "``cfg.encode_invalid_numbers`` (default is true) -- allow nan and inf"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:190
msgid "``cfg.encode_load_metatables`` (default is false) -- load metatables"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:191
msgid "``cfg.encode_max_depth`` (default is 32) -- maximum nesting depth in a structure"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:192
msgid "``cfg.encode_number_precision`` (default is 14) -- maximum post-decimal digits"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:193
msgid "``cfg.encode_sparse_convert`` (default is true) -- handle excessively sparse arrays as maps"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:194
msgid "``cfg.encode_sparse_ratio`` (default is 2) -- how sparse an array can be"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:195
msgid "``cfg.encode_sparse_safe`` (default is 10) -- how much can safely be sparse"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:196
msgid "``cfg.encode_use_tostring`` (default is false) -- use ``tostring`` for unrecognizable types"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:198
msgid "``cfg.decode_invalid_numbers`` (default is true) -- allow nan and inf"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:199
msgid "``cfg.decode_max_depth`` (default is 32) -- maximum nesting depth in a structure"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:200
msgid "``cfg.decode_save_metatables`` (default is true) -- like ``encode_load_metatables``"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:202
msgid "For example, the following code will encode 0/0 as nan (\"not a number\") and 1/0 as inf (\"infinity\"), rather than returning nil or an error message:"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:205
msgid "json = require('json')\n"
"json.cfg{encode_invalid_numbers = true}\n"
"x = 0/0\n"
"y = 1/0\n"
"json.encode({1, x, y, 2})"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:213
msgid "The result of the ``json.encode()`` request will look like this:"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:215
msgid "tarantool> json.encode({1, x, y, 2})\n"
"---\n"
"- '[1,nan,inf,2]\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:222
msgid "To achieve the same effect for only one call to ``json.encode()`` without changing the configuration persistently, one could say ``json.encode({1, x, y, 2}, {encode_invalid_numbers = true})``."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:226
msgid "The same configuration settings exist for json, for :ref:`MsgPack <msgpack-module>`, and for :ref:`YAML <yaml-module>`."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:233
msgid "**Behavior change:** Before Tarantool version 1.10.4, if a nested structure was deeper than ``cfg.encode_max_depth``, the deeper levels were cropped (encoded as nil)."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:237
msgid "Now, the result is an error suggesting that ``cfg.encode_max_depth`` is not deep enough. To return to the old behavior, say ``cfg.encode_deep_as_nil = true``."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:241
msgid "This option is ignored for ``YAML``."
msgstr ""

#: ../doc/reference/reference_lua/log.rst:5
msgid "Module `log`"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:13
msgid "The Tarantool server puts all diagnostic messages in a log file specified by the :ref:`log <cfg_logging-log>` configuration parameter. Diagnostic messages may be either system-generated by the server's internal code, or user-generated with the :samp:`log.{log_level_function_name}` function."
msgstr ""

#: ../doc/reference/reference_lua/log.rst:18
msgid "As explained in the description of :ref:`log_format <cfg_logging-log_format>` configuration setting, there are two possible formats for log entries:"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:48
msgid "Below is a list of all ``log`` functions."
msgstr ""

#: ../doc/reference/reference_lua/log.rst:58
msgid ":ref:`log.error() <log-ug_message>` |br| :ref:`log.warn() <log-ug_message>` |br| :ref:`log.info() <log-ug_message>` |br| :ref:`log.verbose() <log-ug_message>` |br| :ref:`log.debug() <log-ug_message>`"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:62
msgid "Write a user-generated message to a log file"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:69
msgid ":ref:`log.logger_pid() <log-logger_pid>`"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:69
msgid "Get the PID of a logger"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:72
msgid ":ref:`log.rotate() <log-rotate>`"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:72
msgid "Rotate a log file"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:84
msgid "Output a user-generated message to the :ref:`log file <cfg_logging-log>`, given log_level_function_name = ``error`` or ``warn`` or ``info`` or ``verbose`` or ``debug``."
msgstr ""

#: ../doc/reference/reference_lua/log.rst:88
msgid "As explained in the description of the configuration setting for :ref:`log_level <cfg_logging-log_level>`, there are seven levels of detail:"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:92
msgid "2 – ``ERROR`` -- this corresponds to ``log.error(...)``"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:94
msgid "4 – ``WARNING``  -- this corresponds to ``log.warn(...)``"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:95
msgid "5 – ``INFO`` -- this corresponds to ``log.info(...)``"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:96
msgid "6 – ``VERBOSE``  -- this corresponds to ``log.verbose(...)``"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:97
msgid "7 – ``DEBUG`` -- this corresponds to ``log.debug(...)``"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:99
msgid "For example, if ``box.cfg.log_level`` is currently 5 (the default value), then ``log.error(...)``, ``log.warn(...)`` and ``log.info(...)`` messages will go to the log file. However, ``log.verbose(...)`` and ``log.debug(...)`` messages will not go to the log file, because they correspond to higher levels of detail."
msgstr ""

#: ../doc/reference/reference_lua/log.rst:105
msgid "Usually a string.  Messages may contain C-style format specifiers %d or %s, so :samp:`log.error('...%d...%s', {x}, {y})` will work if ``x`` is a number and ``y`` is a string.  Less commonly, messages may be other scalar data types, or even tables. So :code:`log.error({'x',18.7,true})` will work."
msgstr ""

#: ../doc/reference/reference_lua/log.rst:105
msgid "Usually a string."
msgstr ""

#: ../doc/reference/reference_lua/log.rst:107
msgid "Messages may contain C-style format specifiers %d or %s, so :samp:`log.error('...%d...%s', {x}, {y})` will work if ``x`` is a number and ``y`` is a string."
msgstr ""

#: ../doc/reference/reference_lua/log.rst:111
msgid "Less commonly, messages may be other scalar data types, or even tables. So :code:`log.error({'x',18.7,true})` will work."
msgstr ""

#: ../doc/reference/reference_lua/log.rst:117
msgid "The actual output will be a line in the log, containing:"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:119
msgid "the current timestamp,"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:120
msgid "a module name,"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:121
msgid "'E', 'W', 'I', 'V' or 'D' depending on ``log_level_function_name``, and"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:122
msgid "``message``."
msgstr ""

#: ../doc/reference/reference_lua/log.rst:124
msgid "Output will not occur if ``log_level_function_name`` is for a type greater than :ref:`log_level <cfg_logging-log_level>`."
msgstr ""

#: ../doc/reference/reference_lua/log.rst:132
msgid "PID of a logger"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:138
msgid "Rotate the log."
msgstr ""

#: ../doc/reference/reference_lua/log.rst:146
msgid "$ tarantool\n"
"tarantool> box.cfg{log_level=3, log='tarantool.txt'}\n"
"tarantool> log = require('log')\n"
"tarantool> log.error('Error')\n"
"tarantool> log.info('Info %s', box.info.version)\n"
"tarantool> os.exit()"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:155
msgid "$ less tarantool.txt\n"
"2017-09-20 ... [68617] main/101/interactive C> version 1.7.5-31-ge939c6ea6\n"
"2017-09-20 ... [68617] main/101/interactive C> log level 3\n"
"2017-09-20 ... [68617] main/101/interactive [C]:-1 E> Error"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:162
msgid "The 'Error' line is visible in ``tarantool.txt`` preceded by the letter E."
msgstr ""

#: ../doc/reference/reference_lua/log.rst:164
msgid "The 'Info' line is not present because the ``log_level`` is 3."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:5
msgid "Module `msgpack`"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:11
msgid "The ``msgpack`` module takes strings in MsgPack_ format and decodes them, or takes a series of non-MsgPack values and encodes them. Tarantool makes heavy internal use of MsgPack because tuples in Tarantool are :ref:`stored <index-box_lua-vs-msgpack>` as MsgPack arrays."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:20
msgid "Below is a list of all ``msgpack`` functions and members."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:30
msgid ":ref:`msgpack.encode() <msgpack-encode>`"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:30
msgid "Convert a Lua object to an MsgPack string"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:33
msgid ":ref:`msgpack.decode() <msgpack-decode>`"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:33
#: ../doc/reference/reference_lua/msgpack.rst:36
msgid "Convert a MsgPack string to a Lua object"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:36
msgid ":ref:`msgpack.decode_unchecked() <msgpack-decode_unchecked>`"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:39
msgid ":ref:`msgpack.NULL <msgpack-null>`"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:42
msgid ":ref:`msgpack.cfg <msgpack-cfg>`"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:42
msgid "Change configuration"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:53
msgid "Convert a Lua object to a MsgPack string."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:56
msgid "the original value reformatted as a MsgPack string."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:63
msgid "Convert a MsgPack string to a Lua object."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:65
#: ../doc/reference/reference_lua/msgpack.rst:93
msgid "a string formatted as MsgPack."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:66
msgid "where to start, minimum = 1, maximum = string length, default = 1."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:71
msgid "(if ``msgpack_string`` is in valid MsgPack format) the original contents of ``msgpack_string``, formatted as a Lua table, (otherwise) a scalar value, such as a string or a number;"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:74
msgid "\"next_start_position\". If ``decode`` stops after parsing as far as byte N in ``msgpack_string``, then \"next_start_position\" will equal N + 1, and ``decode(msgpack_string, next_start_position)`` will continue parsing from where the previous ``decode`` stopped, plus 1. Normally ``decode`` parses all of ``msgpack_string``, so \"next_start_position\" will equal ``string.len(msgpack_string)`` + 1."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:81
msgid "table and number"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:87
msgid "Convert a MsgPack string to a Lua object. Because checking is skipped, ``decode_unchecked()`` can operate with string pointers to buffers which ``decode()`` cannot handle. For an example see the :ref:`buffer <buffer-module>` module."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:97
msgid "the original contents formatted as a Lua table;"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:98
msgid "the number of bytes that were decoded."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:100
msgid "lua object"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:113
msgid "tarantool> msgpack = require('msgpack')\n"
"---\n"
"...\n"
"tarantool> y = msgpack.encode({'a',1,'b',2})\n"
"---\n"
"...\n"
"tarantool> z = msgpack.decode(y)\n"
"---\n"
"...\n"
"tarantool> z[1], z[2], z[3], z[4]\n"
"---\n"
"- a\n"
"- 1\n"
"- b\n"
"- 2\n"
"...\n"
"tarantool> box.space.tester:insert{20, msgpack.NULL, 20}\n"
"---\n"
"- [20, null, 20]\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:138
msgid "The MsgPack output structure can be specified with ``__serialize``:"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:140
msgid "``__serialize = \"seq\" or \"sequence\"`` for an array"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:141
msgid "``__serialize = \"map\" or \"mapping\"`` for a map"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:143
msgid "Serializing 'A' and 'B' with different ``__serialize`` values causes different results. To show this, here is a routine which encodes `{'A','B'}` both as an array and as a map, then displays each result in hexadecimal."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:147
msgid "function hexdump(bytes)\n"
"    local result = ''\n"
"    for i = 1, #bytes do\n"
"        result = result .. string.format(\"%x\", string.byte(bytes, i)) .. ' '\n"
"    end\n"
"    return result\n"
"end\n"
"\n"
"msgpack = require('msgpack')\n"
"m1 = msgpack.encode(setmetatable({'A', 'B'}, {\n"
"                             __serialize = \"seq\"\n"
"                          }))\n"
"m2 = msgpack.encode(setmetatable({'A', 'B'}, {\n"
"                             __serialize = \"map\"\n"
"                          }))\n"
"print('array encoding: ', hexdump(m1))\n"
"print('map encoding: ', hexdump(m2))"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:167
msgid "**Result:**"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:206
msgid "**array** encoding: 92 a1 41 a1 42\n"
"**map** encoding:   82 01 a1 41 02 a1 42"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:175
msgid "The MsgPack Specification_ page explains that the first encoding means:"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:214
msgid "fixarray(2), fixstr(1), \"A\", fixstr(1), \"B\""
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:182
msgid "and the second encoding means:"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:221
msgid "fixmap(2), key(1), fixstr(1), \"A\", key(2), fixstr(2), \"B\""
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:189
msgid "Here are examples for all the common types, with the Lua-table representation on the left, with the MsgPack format name and encoding on the right."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:197
msgid "**Common Types and MsgPack Encodings**"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:205
msgid "{}"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:205
msgid "'fixmap' if metatable is 'map' = 80 otherwise 'fixarray' = 90"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:208
msgid "'a'"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:208
msgid "'fixstr' = a1 61"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:210
msgid "false"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:210
msgid "'false' = c2"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:212
msgid "true"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:212
msgid "'true' = c3"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:214
msgid "127"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:214
msgid "'positive fixint' = 7f"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:216
msgid "65535"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:216
msgid "'uint 16' = cd ff ff"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:218
msgid "4294967295"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:218
msgid "'uint 32' = ce ff ff ff ff"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:220
msgid "'nil' = c0"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:222
msgid "msgpack.NULL"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:222
msgid "same as nil"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:224
msgid "[0] = 5"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:224
msgid "'fixmap(1)' + 'positive fixint' (for the key) + 'positive fixint' (for the value) = 81 00 05"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:227
msgid "[0] = nil"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:227
msgid "'fixmap(0)' = 80 -- nil is not stored when it is a missing map value"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:230
msgid "1.5"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:230
msgid "'float 64' = cb 3f f8 00 00 00 00 00 00"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:237
msgid "Some MsgPack configuration settings can be changed, in the same way that they can be changed for json. See :ref:`Module JSON <json-module_cfg>` for a list of some configuration settings. (The same configuration settings exist for json, for MsgPack, and for  :ref:`YAML <yaml-module>`.)"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:242
msgid "For example, if ``msgpack.cfg.encode_invalid_numbers = true`` (the default), then nan and inf are legal values. If that is not desirable, then ensure that ``msgpack.encode()`` will not accept them, by saying ``msgpack.cfg{encode_invalid_numbers = false}``, thus:"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:247
msgid " tarantool> msgpack = require('msgpack'); msgpack.cfg{encode_invalid_numbers = true}\n"
" ---\n"
" ...\n"
" tarantool> msgpack.decode(msgpack.encode{1, 0 / 0, 1 / 0, false})\n"
" ---\n"
" - [1, -nan, inf, false]\n"
" - 22\n"
" ...\n"
" tarantool> msgpack.cfg{encode_invalid_numbers = false}\n"
"---\n"
"...\n"
" tarantool> msgpack.decode(msgpack.encode{1, 0 / 0, 1 / 0, false})\n"
" ---\n"
" - error: ... number must not be NaN or Inf'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:5
msgid "Module `net.box`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:11
msgid "The ``net.box`` module contains connectors to remote database systems. One variant, to be discussed later, is for connecting to MySQL or MariaDB or PostgreSQL (see :ref:`SQL DBMS modules <dbms_modules>` reference). The other variant, which is discussed in this section, is for connecting to Tarantool server instances via a network."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:17
msgid "You can call the following methods:"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:19
msgid "``require('net.box')`` to get a ``net.box`` object (named ``net_box`` for examples in this section),"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:21
msgid "``net_box.connect()`` to connect and get a connection object (named ``conn`` for examples in this section),"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:23
msgid "other ``net.box()`` routines, passing ``conn:``, to execute requests on the remote database system,"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:25
msgid "``conn:close`` to disconnect."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:27
msgid "All ``net.box`` methods are fiber-safe, that is, it is safe to share and use the same connection object across multiple concurrent fibers. In fact that is perhaps the best programming practice with Tarantool. When multiple fibers use the same connection, all requests are pipelined through the same network socket, but each fiber gets back a correct response. Reducing the number of active sockets lowers the overhead of system calls and increases the overall server performance. However for some cases a single connection is not enough —- for example, when it is necessary to prioritize requests or to use different authentication IDs."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:36
msgid "Most ``net.box`` methods allow a final ``{options}`` argument, which can be:"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:38
msgid "``{timeout=...}``. For example, a method whose final argument is ``{timeout=1.5}`` will stop after 1.5 seconds on the local node, although this does not guarantee that execution will stop on the remote server node."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:41
msgid "``{buffer=...}``. For an example see :ref:`buffer module <buffer-module>`."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:42
msgid "``{is_async=...}``. For example, a method whose final argument is ``{is_async=true}`` will not wait for the result of a request. See the :ref:`is_async <net_box-is_async>` description."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:45
msgid "``{on_push=... on_push_ctx=...}``. For receiving out-of-band messages. See the :ref:`box.session.push <box_session-push>` description."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:48
msgid "The diagram below shows possible connection states and transitions:"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:56
msgid "On this diagram:"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:58
msgid "The state machine starts in the 'initial' state."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:60
msgid "``net_box.connect()`` method changes the state to 'connecting' and spawns a worker fiber."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:62
msgid "If authentication and schema upload are required, it's possible later on to re-enter the 'fetch_schema' state from 'active' if a request fails due to a schema version mismatch error, so schema reload is triggered."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:66
msgid "``conn.close()`` method sets the state to 'closed' and kills the worker. If the transport is already in the 'error' state, ``close()`` does nothing."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:73
msgid "Below is a list of all ``net.box`` functions."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:83
msgid ":ref:`net_box.connect() <net_box-connect>` |br| :ref:`net_box.new() <net_box-new>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:84
msgid "Create a connection"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:88
msgid ":ref:`conn:ping() <conn-ping>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:88
msgid "Execute a PING command"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:91
msgid ":ref:`conn:wait_connected() <conn-wait_connected>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:91
msgid "Wait for a connection to be active or closed"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:94
msgid ":ref:`conn:is_connected() <conn-is_connected>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:94
msgid "Check if a connection is active or closed"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:97
msgid ":ref:`conn:wait_state() <conn-wait_state>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:97
msgid "Wait for a target state"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:100
msgid ":ref:`conn:close() <conn-close>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:100
msgid "Close a connection"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:103
msgid ":ref:`conn.space.space-name:select{field-value} <conn-select>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:103
msgid "Select one or more tuples"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:106
msgid ":ref:`conn.space.space-name:get{field-value} <conn-get>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:106
msgid "Select a tuple"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:109
msgid ":ref:`conn.space.space-name:insert{field-value} <conn-insert>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:109
msgid "Insert a tuple"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:112
msgid ":ref:`conn.space.space-name:replace{field-value} <conn-replace>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:112
msgid "Insert or replace a tuple"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:115
msgid ":ref:`conn.space.space-name:update{field-value} <conn-update>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:115
#: ../doc/reference/reference_lua/net_box.rst:118
msgid "Update a tuple"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:118
msgid ":ref:`conn.space.space-name:upsert{field-value} <conn-upsert>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:121
msgid ":ref:`conn.space.space-name:delete{field-value} <conn-delete>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:121
msgid "Delete a tuple"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:124
msgid ":ref:`conn:eval() <net_box-eval>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:124
msgid "Evaluate and execute the expression in a string"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:127
msgid ":ref:`conn:call() <net_box-call>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:127
msgid "Call a stored procedure"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:130
msgid ":ref:`conn:timeout() <conn-timeout>`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:130
msgid "Set a timeout"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:146
msgid "The names ``connect()`` and ``new()`` are synonyms: ``connect()`` is preferred; ``new()`` is retained for backward compatibility."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:149
msgid "Create a new connection. The connection is established on demand, at the time of the first request. It can be re-established automatically after a disconnect (see ``reconnect_after`` option below). The returned ``conn`` object supports methods for making remote requests, such as select, update or delete."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:155
msgid "For a local Tarantool server, there is a pre-created always-established connection object named :samp:`{net_box}.self`. Its purpose is to make polymorphic use of the ``net_box`` API easier. Therefore :samp:`conn = {net_box}.connect('localhost:3301')` can be replaced by :samp:`conn = {net_box}.self`. However, there is an important difference between the embedded connection and a remote one. With the embedded connection, requests which do not modify data do not yield. When using a remote connection, due to :ref:`the implicit rules <atomic-implicit-yields>` any request can yield, and database state may have changed by the time it regains control."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:167
msgid "Possible options:"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:169
msgid "`wait_connected`: by default, connection creation is blocked until the connection is established, but passing ``wait_connected=false`` makes it return immediately. Also, passing a timeout makes it wait before returning (e.g. ``wait_connected=1.5`` makes it wait at most 1.5 seconds)."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:175
msgid "In the presence of ``reconnect_after``, ``wait_connected`` ignores transient failures. The wait completes once the connection is established or is closed explicitly."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:178
msgid "`reconnect_after`: a ``net.box`` instance automatically reconnects any time the connection is broken or if a connection attempt fails. This makes transient network failures become transparent to the application. Reconnect happens automatically in the background, so queries/requests that suffered due to connectivity loss are transparently retried. The number of retries is unlimited, connection attempts are done over the specified timeout (e.g. ``reconnect_after=5`` for 5 secs). Once a connection is explicitly closed, or once the Lua garbage collector removes it, reconnects stop."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:188
msgid "`call_16`: [since 1.7.2] by default, ``net.box`` connections comply with a new binary protocol command for CALL, which is not backward compatible with previous versions. The new CALL no longer restricts a function to returning an array of tuples and allows returning an arbitrary MsgPack/JSON result, including scalars, nil and void (nothing). The old CALL is left intact for backward compatibility. It will be removed in the next major release. All programming language drivers will be gradually changed to use the new CALL. To connect to a Tarantool instance that uses the old CALL, specify ``call_16=true``."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:197
msgid "`console`: depending on the option's value, the connection supports different methods (as if instances of different classes were returned). With ``console = true``, you can use ``conn`` methods ``close()``, ``is_connected()``, ``wait_state()``, ``eval()`` (in this case, both binary and Lua console network protocols are supported). With ``console = false`` (default), you can also use ``conn`` database methods (in this case, only the binary protocol is supported). Deprecation notice: ``console = true`` is deprecated, users should use :ref:`console.connect() <console-connect>` instead."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:205
msgid "`connect_timeout`: number of seconds to wait before returning \"error: Connection timed out\"."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:207
msgid "the :ref:`URI <index-uri>` of the target for the connection"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:208
msgid "possible options are `wait_connected`, `reconnect_after`, `call_16` and `console`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:209
msgid "conn object"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:212
#: ../doc/reference/reference_lua/net_box.rst:280
#: ../doc/reference/reference_lua/net_box.rst:411
#: ../doc/reference/reference_lua/net_box.rst:445
#: ../doc/reference/reference_rock/vshard/index.rst:1294
msgid "**Examples:**"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:214
msgid "conn = net_box.connect('localhost:3301')\n"
"conn = net_box.connect('127.0.0.1:3302', {wait_connected = false})\n"
"conn = net_box.connect('127.0.0.1:3303', {reconnect_after = 5, call_16 = true})"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:226
msgid "Execute a PING command."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:228
msgid "the supported option is :samp:`timeout={seconds}`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:229
msgid "true on success, false on error"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:234
msgid "net_box.self:ping({timeout = 0.5})"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:242
msgid "Wait for connection to be active or closed."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:244
#: ../doc/reference/reference_lua/net_box.rst:276
msgid "in seconds"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:245
msgid "true when connected, false on failure."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:250
msgid "net_box.self:wait_connected()"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:258
msgid "Show whether connection is active or closed."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:260
msgid "true if connected, false on failure."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:265
msgid "net_box.self:is_connected()"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:273
msgid "[since 1.7.2] Wait for a target state."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:275
msgid "target states"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:277
msgid "true when a target state is reached, false on timeout or connection closure"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:282
msgid "-- wait infinitely for 'active' state:\n"
"conn:wait_state('active')\n"
"\n"
"-- wait for 1.5 secs at most:\n"
"conn:wait_state('active', 1.5)\n"
"\n"
"-- wait infinitely for either `active` or `fetch_schema` state:\n"
"conn:wait_state({active=true, fetch_schema=true})"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:297
msgid "Close a connection."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:299
msgid "Connection objects are destroyed by the Lua garbage collector, just like any other objects in Lua, so an explicit destruction is not mandatory. However, since close() is a system call, it is good programming practice to close a connection explicitly when it is no longer needed, to avoid lengthy stalls of the garbage collector."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:306
msgid "conn:close()"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:314
msgid ":samp:`conn.space.{space-name}:select`:code:`({...})` is the remote-call equivalent of the local call :samp:`box.space.{space-name}:select`:code:`{...}`."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:319
msgid "conn.space.testspace:select({1,'B'}, {timeout=1})"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:325
msgid "Due to :ref:`the implicit yield rules <atomic-implicit-yields>` a local :samp:`box.space.{space-name}:select`:code:`{...}` does not yield, but a remote :samp:`conn.space.{space-name}:select`:code:`{...}` call does yield, so global variables or database tuples data may change when a remote :samp:`conn.space.{space-name}:select`:code:`{...}` occurs."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:336
msgid ":samp:`conn.space.{space-name}:get(...)` is the remote-call equivalent of the local call :samp:`box.space.{space-name}:get(...)`."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:341
msgid "conn.space.testspace:get({1})"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:349
msgid ":samp:`conn.space.{space-name}:insert(...)` is the remote-call equivalent of the local call :samp:`box.space.{space-name}:insert(...)`."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:354
msgid "conn.space.testspace:insert({2,3,4,5}, {timeout=1.1})"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:362
msgid ":samp:`conn.space.{space-name}:replace(...)` is the remote-call equivalent of the local call :samp:`box.space.{space-name}:replace(...)`."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:367
msgid "conn.space.testspace:replace({5,6,7,8})"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:375
msgid ":samp:`conn.space.{space-name}:update(...)` is the remote-call equivalent of the local call :samp:`box.space.{space-name}:update(...)`."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:380
msgid "conn.space.Q:update({1},{{'=',2,5}}, {timeout=0})"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:388
msgid ":samp:`conn.space.{space-name}:upsert(...)` is the remote-call equivalent of the local call :samp:`box.space.{space-name}:upsert(...)`."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:395
msgid ":samp:`conn.space.{space-name}:delete(...)` is the remote-call equivalent of the local call :samp:`box.space.{space-name}:delete(...)`."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:402
msgid ":samp:`conn:eval({Lua-string})` evaluates and executes the expression in Lua-string, which may be any statement or series of statements. An :ref:`execute privilege <authentication-owners_privileges>` is required; if the user does not have it, an administrator may grant it with :samp:`box.schema.user.grant({username}, 'execute', 'universe')`."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:408
msgid "To ensure that the return from ``conn:eval`` is whatever the Lua expression returns, begin the Lua-string with the word \"return\"."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:413
msgid "tarantool> --Lua-string\n"
"tarantool> conn:eval('function f5() return 5+5 end; return f5();')\n"
"---\n"
"- 10\n"
"...\n"
"tarantool> --Lua-string, {arguments}\n"
"tarantool> conn:eval('return ...', {1,2,{3,'x'}})\n"
"---\n"
"- 1\n"
"- 2\n"
"- [3, 'x']\n"
"...\n"
"tarantool> --Lua-string, {arguments}, {options}\n"
"tarantool> conn:eval('return {nil,5}', {}, {timeout=0.1})\n"
"---\n"
"- [null, 5]\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:437
msgid "``conn:call('func', {'1', '2', '3'})`` is the remote-call equivalent of ``func('1', '2', '3')``. That is, ``conn:call`` is a remote stored-procedure call. The return from ``conn:call`` is whatever the function returns."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:441
msgid "Limitation: the called function cannot return a function, for example if ``func2`` is defined as ``function func2 () return func end`` then ``conn:call(func2)`` will return \"error: unsupported Lua type 'function'\"."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:447
msgid "tarantool> -- create 2 functions with conn:eval()\n"
"tarantool> conn:eval('function f1() return 5+5 end;')\n"
"tarantool> conn:eval('function f2(x,y) return x,y end;')\n"
"tarantool> -- call first function with no parameters and no options\n"
"tarantool> conn:call('f1')\n"
"---\n"
"- 10\n"
"...\n"
"tarantool> -- call second function with two parameters and one option\n"
"tarantool> conn:call('f2',{1,'B'},{timeout=99})\n"
"---\n"
"- 1\n"
"- B\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:470
msgid "``timeout(...)`` is a wrapper which sets a timeout for the request that follows it. Since version 1.7.4 this method is deprecated -- it is better to pass a timeout value for a method's ``{options}`` parameter."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:476
msgid "conn:timeout(0.5).space.tester:update({1}, {{'=', 2, 15}})"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:480
msgid "Although ``timeout(...)`` is deprecated, all remote calls support its use. Using a wrapper object makes the remote connection API compatible with the local one, removing the need for a separate ``timeout`` argument, which the local version would ignore. Once a request is sent, it cannot be revoked from the remote server even if a timeout expires: the timeout expiration only aborts the wait for the remote server response, not the request itself."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:492
msgid "``{is_async=true|false}`` is an option which is applicable for all ``net_box`` requests including ``conn:call``, ``conn:eval``, and the ``conn.space.space-name`` requests."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:496
msgid "The default is ``is_async=false``, meaning requests are synchronous for the fiber. The fiber is blocked, waiting until there is a reply to the request or until timeout expires. Before Tarantool version 1.10, the only way to make asynchronous requests was to put them in separate fibers."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:502
msgid "The non-default is ``is_async=true``, meaning requests are asynchronous for the fiber. The request causes a yield but there is no waiting. The immediate return is not the result of the request, instead it is an object that the calling program can use later to get the result of the request."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:508
msgid "This immediately-returned object, which we'll call \"future\", has its own methods:"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:511
msgid "``future:is_ready()`` which will return true when the result of the request is available,"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:513
msgid "``future:result()`` to get the result of the request (returns the response or **nil** in case it's not ready yet or there has been an error),"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:515
msgid "``future:wait_result(timeout)`` to wait until the result of the request is available and then get it,"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:517
msgid "``future:discard()`` to abandon the object."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:519
msgid "Typically a user would say ``future=request-name(...{is_async=true})``, then either loop checking ``future:is_ready()`` until it is true and then say ``request_result=future:result()``, or say ``request_result=future:wait_result(...)``. Alternatively the client could check for \"out-of-band\" messages from the server by calling ``pairs()`` in a loop -- see :ref:`box.session.push() <box_session-push>`."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:528
msgid "tarantool> future = conn.space.tester:insert({900},{is_async=true})\n"
"---\n"
"...\n"
"tarantool> future\n"
"---\n"
"- method: insert\n"
"  response: [900]\n"
"  cond: cond\n"
"  on_push_ctx: []\n"
"  on_push: 'function: builtin#91'\n"
"...\n"
"tarantool> future:is_ready()\n"
"---\n"
"- true\n"
"...\n"
"tarantool> future:result()\n"
"---\n"
"- [900]\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:550
msgid "Typically ``{is_async=true}`` is used only if the load is large (more than 100,000 requests per second) and latency is large (more than 1 second), or when it is necessary to send multiple requests in parallel then collect responses (sometimes called a \"map-reduce\" scenario)."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:558
msgid "Although the final result of an async request is the same as the result of a sync request, it is structured differently: as a table, instead of as the unpacked values."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:566
msgid "This example shows the use of most of the ``net.box`` methods."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:568
msgid "The sandbox configuration for this example assumes that:"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:570
msgid "the Tarantool instance is running on ``localhost 127.0.0.1:3301``,"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:571
msgid "there is a space named ``tester`` with a numeric primary key and with a tuple that contains a key value = 800,"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:573
msgid "the current user has read, write and execute privileges."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:575
msgid "Here are commands for a quick sandbox setup:"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:577
msgid "box.cfg{listen = 3301}\n"
"s = box.schema.space.create('tester')\n"
"s:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
"t = s:insert({800, 'TEST'})\n"
"box.schema.user.grant('guest', 'read,write,execute', 'universe')"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:585
msgid "And here starts the example:"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:587
msgid "tarantool> net_box = require('net.box')\n"
"---\n"
"...\n"
"tarantool> function example()\n"
"         >   local conn, wtuple\n"
"         >   if net_box.self:ping() then\n"
"         >     table.insert(ta, 'self:ping() succeeded')\n"
"         >     table.insert(ta, '  (no surprise -- self connection is pre-established)')\n"
"         >   end\n"
"         >   if box.cfg.listen == '3301' then\n"
"         >     table.insert(ta,'The local server listen address = 3301')\n"
"         >   else\n"
"         >     table.insert(ta, 'The local server listen address is not 3301')\n"
"         >     table.insert(ta, '(  (maybe box.cfg{...listen=\"3301\"...} was not stated)')\n"
"         >     table.insert(ta, '(  (so connect will fail)')\n"
"         >   end\n"
"         >   conn = net_box.connect('127.0.0.1:3301')\n"
"         >   conn.space.tester:delete({800})\n"
"         >   table.insert(ta, 'conn delete done on tester.')\n"
"         >   conn.space.tester:insert({800, 'data'})\n"
"         >   table.insert(ta, 'conn insert done on tester, index 0')\n"
"         >   table.insert(ta, '  primary key value = 800.')\n"
"         >   wtuple = conn.space.tester:select({800})\n"
"         >   table.insert(ta, 'conn select done on tester, index 0')\n"
"         >   table.insert(ta, '  number of fields = ' .. #wtuple)\n"
"         >   conn.space.tester:delete({800})\n"
"         >   table.insert(ta, 'conn delete done on tester')\n"
"         >   conn.space.tester:replace({800, 'New data', 'Extra data'})\n"
"         >   table.insert(ta, 'conn:replace done on tester')\n"
"         >   conn.space.tester:update({800}, {{'=', 2, 'Fld#1'}})\n"
"         >   table.insert(ta, 'conn update done on tester')\n"
"         >   conn:close()\n"
"         >   table.insert(ta, 'conn close done')\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> ta = {}\n"
"---\n"
"...\n"
"tarantool> example()\n"
"---\n"
"...\n"
"tarantool> ta\n"
"---\n"
"- - self:ping() succeeded\n"
"  - '  (no surprise -- self connection is pre-established)'\n"
"  - The local server listen address = 3301\n"
"  - conn delete done on tester.\n"
"  - conn insert done on tester, index 0\n"
"  - '  primary key value = 800.'\n"
"  - conn select done on tester, index 0\n"
"  - '  number of fields = 1'\n"
"  - conn delete done on tester\n"
"  - conn:replace done on tester\n"
"  - conn update done on tester\n"
"  - conn close done\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:5
msgid "Module `os`"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:13
msgid "The ``os`` module contains the functions :ref:`execute() <os-execute>`, :ref:`rename() <os-rename>`, :ref:`getenv() <os-getenv>`, :ref:`remove() <os-remove>`, :ref:`date() <os-date>`, :ref:`exit() <os-exit>`, :ref:`time() <os-time>`, :ref:`clock() <os-clock>`, :ref:`tmpname() <os-tmpname>`, :ref:`environ() <os-environ>`, :ref:`setenv() <os-setenv>`, :ref:`setlocale() <os-setlocale>`, :ref:`difftime() <os-difftime>`. Most of these functions are described in the Lua manual Chapter 22 `The Operating System Library <https://www.lua.org/pil/contents.html#22>`_."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:30
msgid "Below is a list of all ``os`` functions."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:40
msgid ":ref:`os.execute() <os-execute>`"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:40
msgid "Execute by passing to the shell"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:43
msgid ":ref:`os.rename() <os-rename>`"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:46
msgid ":ref:`os.getenv() <os-getenv>`"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:46
msgid "Get an environment variable"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:49
msgid ":ref:`os.remove() <os-remove>`"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:49
msgid "Remove a file or directory"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:52
msgid ":ref:`os.date() <os-date>`"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:52
msgid "Get a formatted date"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:55
msgid ":ref:`os.exit() <os-exit>`"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:55
msgid "Exit the program"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:58
msgid ":ref:`os.time() <os-time>`"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:58
msgid "Get the number of seconds since the epoch"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:61
msgid ":ref:`os.clock() <os-clock>`"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:61
msgid "Get the number of CPU seconds since the program start"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:64
msgid ":ref:`os.tmpname() <os-tmpname>`"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:64
msgid "Get the name of a temporary file"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:67
msgid ":ref:`os.environ() <os-environ>`"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:67
msgid "Get a table with all environment variables"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:70
msgid ":ref:`os.setenv() <os-setenv>`"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:70
msgid "Set an environment variable"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:73
msgid ":ref:`os.setlocale() <os-setlocale>`"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:73
msgid "Change the locale"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:76
msgid ":ref:`os.difftime() <os-difftime>`"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:76
msgid "Get the number of seconds between two times"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:84
msgid "Execute by passing to the shell."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:86
msgid "what to execute."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:90
msgid "tarantool> os.execute('ls -l /usr')\n"
"total 200\n"
"drwxr-xr-x   2 root root 65536 Apr 22 15:49 bin\n"
"drwxr-xr-x  59 root root 20480 Apr 18 07:58 include\n"
"drwxr-xr-x 210 root root 65536 Apr 18 07:59 lib\n"
"drwxr-xr-x  12 root root  4096 Apr 22 15:49 local\n"
"drwxr-xr-x   2 root root 12288 Jan 31 09:50 sbin\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:106
msgid "Rename a file or directory."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:108
msgid "name of existing file or directory,"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:109
msgid "changed name of file or directory."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:113
msgid "tarantool> os.rename('local','foreign')\n"
"---\n"
"- null\n"
"- 'local: No such file or directory'\n"
"- 2\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:126
msgid "Get environment variable."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:128
msgid "Parameters: (string) variable-name = environment variable name."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:132
msgid "tarantool> os.getenv('PATH')\n"
"---\n"
"- /usr/local/sbin:/usr/local/bin:/usr/sbin\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:143
msgid "Remove file or directory."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:145
msgid "Parameters: (string) name = name of file or directory which will be removed."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:149
msgid "tarantool> os.remove('file')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:160
msgid "Return a formatted date."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:162
msgid "Parameters: (string) format-string = instructions; (string) time-since-epoch = number of seconds since 1970-01-01. If time-since-epoch is omitted, it is assumed to be the current time."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:167
msgid "tarantool> os.date(\"%A %B %d\")\n"
"---\n"
"- Sunday April 24\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:178
msgid "Exit the program. If this is done on a server instance, then the instance stops."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:182
msgid "tarantool> os.exit()\n"
"user@user-shell:~/tarantool_sandbox$"
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:191
msgid "Return the number of seconds since the epoch."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:195
msgid "tarantool> os.time()\n"
"---\n"
"- 1461516945\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:206
msgid "Return the number of CPU seconds since the program start."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:210
msgid "tarantool> os.clock()\n"
"---\n"
"- 0.05\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:221
msgid "Return a name for a temporary file."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:225
msgid "tarantool> os.tmpname()\n"
"---\n"
"- /tmp/lua_7SW1m2\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:236
msgid "Return a table containing all environment variables."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:240
msgid "tarantool> os.environ()['TERM']..os.environ()['SHELL']\n"
"---\n"
"- xterm/bin/bash\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:251
msgid "Set an environment variable."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:255
msgid "tarantool> os.setenv('VERSION','99')\n"
"---\n"
"-\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:266
msgid "Change the locale. If new-locale-string is not specified, return the current locale."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:271
msgid "tarantool> require('string').sub(os.setlocale(),1,20)\n"
"---\n"
"- LC_CTYPE=en_US.UTF-8\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:282
msgid "Return the number of seconds between two times."
msgstr ""

#: ../doc/reference/reference_lua/osmodule.rst:286
msgid "tarantool> os.difftime(os.time() - 0)\n"
"---\n"
"- 1486594859\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/other.rst:3
msgid "Miscellaneous"
msgstr ""

#: ../doc/reference/reference_lua/other.rst:9
msgid "Below is a list of miscellaneous functions."
msgstr ""

#: ../doc/reference/reference_lua/other.rst:19
msgid ":ref:`tonumber64() <other-tonumber64>`"
msgstr ""

#: ../doc/reference/reference_lua/other.rst:19
msgid "Convert a string or a Lua number to a 64-bit integer"
msgstr ""

#: ../doc/reference/reference_lua/other.rst:22
msgid ":ref:`dostring() <other-dostring>`"
msgstr ""

#: ../doc/reference/reference_lua/other.rst:22
msgid "Parse and execute an arbitrary chunk of Lua code"
msgstr ""

#: ../doc/reference/reference_lua/other.rst:30
msgid "Convert a string or a Lua number to a 64-bit integer. The input value can be expressed in decimal, binary (for example 0b1010), or hexadecimal (for example -0xffff). The result can be used in arithmetic, and the arithmetic will be 64-bit integer arithmetic rather than floating-point arithmetic. (Operations on an unconverted Lua number use floating-point arithmetic.) The ``tonumber64()`` function is added by Tarantool; the name is global."
msgstr ""

#: ../doc/reference/reference_lua/other.rst:40
msgid "tarantool> type(123456789012345), type(tonumber64(123456789012345))\n"
"---\n"
"- number\n"
"- number\n"
"...\n"
"tarantool> i = tonumber64('1000000000')\n"
"---\n"
"...\n"
"tarantool> type(i), i / 2, i - 2, i * 2, i + 2, i % 2, i ^ 2\n"
"---\n"
"- number\n"
"- 500000000\n"
"- 999999998\n"
"- 2000000000\n"
"- 1000000002\n"
"- 0\n"
"- 1000000000000000000\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/other.rst:65
msgid "Parse and execute an arbitrary chunk of Lua code. This function is mainly useful to define and run Lua code without having to introduce changes to the global Lua environment."
msgstr ""

#: ../doc/reference/reference_lua/other.rst:69
msgid "Lua code"
msgstr ""

#: ../doc/reference/reference_lua/other.rst:70
msgid "zero or more scalar values which will be appended to, or substitute for, items in the Lua chunk."
msgstr ""

#: ../doc/reference/reference_lua/other.rst:73
msgid "whatever is returned by the Lua code chunk."
msgstr ""

#: ../doc/reference/reference_lua/other.rst:75
msgid "Possible errors: If there is a compilation error, it is raised as a Lua error."
msgstr ""

#: ../doc/reference/reference_lua/other.rst:80
msgid "tarantool> dostring('abc')\n"
"---\n"
"error: '[string \"abc\"]:1: ''='' expected near ''<eof>'''\n"
"...\n"
"tarantool> dostring('return 1')\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> dostring('return ...', 'hello', 'world')\n"
"---\n"
"- hello\n"
"- world\n"
"...\n"
"tarantool> dostring([[\n"
"         >   local f = function(key)\n"
"         >     local t = box.space.tester:select{key}\n"
"         >     if t ~= nil then\n"
"         >       return t[1]\n"
"         >     else\n"
"         >       return nil\n"
"         >     end\n"
"         >   end\n"
"         >   return f(...)]], 1)\n"
"---\n"
"- null\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:3
msgid "Module `pickle`"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:9
msgid "Below is a list of all ``pickle`` functions."
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:19
msgid ":ref:`pickle.pack() <pickle-pack>`"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:19
msgid "Convert Lua variables to binary format"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:22
msgid ":ref:`pickle.unpack() <pickle-unpack>`"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:22
msgid "Convert Lua variables back from binary format"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:32
msgid "To use Tarantool binary protocol primitives from Lua, it's necessary to convert Lua variables to binary format. The ``pickle.pack()`` helper function is prototyped after Perl 'pack_'."
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:38
msgid "**Format specifiers**"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:43
msgid "b, B"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:43
msgid "converts Lua scalar value to a 1-byte integer, and stores the integer in the resulting string"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:46
msgid "s, S"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:46
msgid "converts Lua scalar value to a 2-byte integer, and stores the integer in the resulting string, low byte first"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:50
msgid "i, I"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:50
msgid "converts Lua scalar value to a 4-byte integer, and stores the integer in the resulting string, low byte first"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:54
msgid "l, L"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:54
msgid "converts Lua scalar value to an 8-byte integer, and stores the integer in the resulting string, low byte first"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:58
msgid "n"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:58
msgid "converts Lua scalar value to a 2-byte integer, and stores the integer in the resulting string, big endian,"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:62
msgid "N"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:62
msgid "converts Lua scalar value to a 4-byte integer, and stores the integer in the resulting string, big"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:65
msgid "q, Q"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:65
msgid "converts Lua scalar value to an 8-byte integer, and stores the integer in the resulting string, big endian,"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:69
msgid "f"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:69
msgid "converts Lua scalar value to a 4-byte float, and stores the float in the resulting string"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:72
msgid "d"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:72
msgid "converts Lua scalar value to a 8-byte double, and stores the double in the resulting string"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:75
msgid "a, A"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:75
msgid "converts Lua scalar value to a sequence of bytes, and stores the sequence in the resulting string"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:79
msgid "string containing format specifiers"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:80
msgid "scalar values to be formatted"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:81
msgid "a binary string containing all arguments, packed according to the format specifiers."
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:85
msgid "A scalar value can be either a variable or a literal. Remember that large integers should be entered with :ref:`tonumber64() or LL or ULL suffixes <index-box_number>`."
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:89
msgid "Possible errors: unknown format specifier."
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:93
msgid "tarantool> pickle = require('pickle')\n"
"---\n"
"...\n"
"tarantool> box.space.tester:insert{0, 'hello world'}\n"
"---\n"
"- [0, 'hello world']\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'=', 2, 'bye world'}})\n"
"---\n"
"- [0, 'bye world']\n"
"...\n"
"tarantool> box.space.tester:update({0}, {\n"
"         >   {'=', 2, pickle.pack('iiA', 0, 3, 'hello')}\n"
"         > })\n"
"---\n"
"- [0, \"\\0\\0\\0\\0\\x03\\0\\0\\0hello\"]\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'=', 2, 4}})\n"
"---\n"
"- [0, 4]\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'+', 2, 4}})\n"
"---\n"
"- [0, 8]\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'^', 2, 4}})\n"
"---\n"
"- [0, 12]\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:129
msgid "Counterpart to ``pickle.pack()``. Warning: if format specifier 'A' is used, it must be the last item."
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:135
msgid "A list of strings or numbers."
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:140
msgid "tarantool> pickle = require('pickle')\n"
"---\n"
"...\n"
"tarantool> tuple = box.space.tester:replace{0}\n"
"---\n"
"...\n"
"tarantool> string.len(tuple[1])\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> pickle.unpack('b', tuple[1])\n"
"---\n"
"- 48\n"
"...\n"
"tarantool> pickle.unpack('bsi', pickle.pack('bsi', 255, 65535, 4294967295))\n"
"---\n"
"- 255\n"
"- 65535\n"
"- 4294967295\n"
"...\n"
"tarantool> pickle.unpack('ls', pickle.pack('ls', tonumber64('18446744073709551615'), 65535))\n"
"---\n"
"...\n"
"tarantool> num, num64, str = pickle.unpack('slA', pickle.pack('slA', 666,\n"
"         > tonumber64('666666666666666'), 'string'))\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:5
msgid "Module `socket`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:11
msgid "The ``socket`` module allows exchanging data via BSD sockets with a local or remote host in connection-oriented (TCP) or datagram-oriented (UDP) mode. Semantics of the calls in the ``socket`` API closely follow semantics of the corresponding POSIX calls. Function names and signatures are mostly compatible with `luasocket`_."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:17
msgid "The functions for setting up and connecting are ``socket``, ``sysconnect``, ``tcp_connect``. The functions for sending data are ``send``, ``sendto``, ``write``, ``syswrite``. The functions for receiving data are ``recv``, ``recvfrom``, ``read``. The functions for waiting before sending/receiving data are ``wait``, ``readable``, ``writable``. The functions for setting flags are ``nonblock``, ``setsockopt``. The functions for stopping and disconnecting are ``shutdown``, ``close``. The functions for error checking are ``errno``, ``error``."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:30
msgid "Below is a list of all ``socket`` functions."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:40
msgid ":ref:`socket() <socket-socket>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:40
msgid "Create a socket"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:42
msgid ":ref:`socket.tcp_connect() <socket-tcp_connect>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:42
#: ../doc/reference/reference_lua/socket.rst:51
msgid "Connect a socket to a remote host"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:45
msgid ":ref:`socket.getaddrinfo() <socket-getaddrinfo>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:45
msgid "Get information about a remote site"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:48
msgid ":ref:`socket.tcp_server() <socket-tcp_server>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:48
msgid "Make Tarantool act as a TCP server"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:51
msgid ":ref:`socket_object:sysconnect() <socket-sysconnect>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:54
msgid ":ref:`socket_object:send() <socket-send>` |br| :ref:`socket_object:write() <socket-send>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:54
msgid "Send data over a connected socket"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:57
msgid ":ref:`socket_object:syswrite() <socket-syswrite>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:57
msgid "Write data to the socket buffer if non-blocking"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:60
msgid ":ref:`socket_object:recv() <socket-recv>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:60
msgid "Read from a connected socket"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:62
msgid ":ref:`socket_object:sysread() <socket-sysread>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:62
msgid "Read data from the socket buffer if non-blocking"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:65
msgid ":ref:`socket_object:bind() <socket-bind>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:65
msgid "Bind a socket to the given host/port"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:68
msgid ":ref:`socket_object:listen() <socket-listen>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:68
msgid "Start listening for incoming connections"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:71
msgid ":ref:`socket_object:accept() <socket-accept>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:71
msgid "Accept a client connection + create a connected socket"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:74
msgid ":ref:`socket_object:sendto() <socket-sendto>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:74
msgid "Send a message on a UDP socket to a specified host"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:77
msgid ":ref:`socket_object:recvfrom() <socket-recvfrom>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:77
msgid "Receive a message on a UDP socket"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:80
msgid ":ref:`socket_object:shutdown() <socket-shutdown>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:80
msgid "Shut down a reading end, a writing end, or both"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:83
msgid ":ref:`socket_object:close() <socket-close>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:83
msgid "Close a socket"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:85
msgid ":ref:`socket_object:error() <socket-error>` |br| :ref:`socket_object:errno() <socket-error>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:85
msgid "Get information about the last error on a socket"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:88
msgid ":ref:`socket_object:setsockopt() <socket-setsockopt>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:88
msgid "Set socket flags"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:90
msgid ":ref:`socket_object:getsockopt() <socket-getsockopt>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:90
msgid "Get socket flags"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:92
msgid ":ref:`socket_object:linger() <socket-linger>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:92
msgid "Set/clear the SO_LINGER flag"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:94
msgid ":ref:`socket_object:nonblock() <socket-nonblock>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:94
msgid "Set/get the flag value"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:96
msgid ":ref:`socket_object:readable() <socket-readable>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:96
msgid "Wait until something is readable"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:99
msgid ":ref:`socket_object:writable() <socket-writable>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:99
msgid "Wait until something is writable"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:102
msgid ":ref:`socket_object:wait() <socket-wait>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:102
msgid "Wait until something is either readable or writable"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:105
msgid ":ref:`socket_object:name() <socket-name>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:105
msgid "Get information about the connection's near side"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:108
msgid ":ref:`socket_object:peer() <socket-peer>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:108
msgid "Get information about the connection's far side"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:111
msgid ":ref:`socket.iowait() <socket-iowait>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:111
msgid "Wait for read/write activity"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:114
msgid "Typically a socket session will begin with the setup functions, will set one or more flags, will have a loop with sending and receiving functions, will end with the teardown functions -- as an example at the end of this section will show. Throughout, there may be error-checking and waiting functions for synchronization. To prevent a fiber containing socket functions from \"blocking\" other fibers, the :ref:`implicit yield rules <atomic-implicit-yields>` will cause a yield so that other processes may take over, as is the norm for :ref:`cooperative multitasking <atomic-cooperative_multitasking>`."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:123
msgid "For all examples in this section the socket name will be sock and the function invocations will look like ``sock:function_name(...)``."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:132
msgid "Create a new TCP or UDP socket. The argument values are the same as in the `Linux socket(2) man page <http://man7.org/linux/man-pages/man2/socket.2.html>`_."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:135
msgid "an unconnected socket, or nil."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:140
msgid "socket('AF_INET', 'SOCK_STREAM', 'tcp')"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:148
msgid "Connect a socket to a remote host."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:150
#: ../doc/reference/reference_lua/socket.rst:355
#: ../doc/reference/reference_lua/socket.rst:395
msgid "URL or IP address"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:151
#: ../doc/reference/reference_lua/socket.rst:356
#: ../doc/reference/reference_lua/socket.rst:396
msgid "port number"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:152
msgid "timeout"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:153
msgid "a connected socket, if no error."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:158
msgid "socket.tcp_connect('127.0.0.1', 3301)"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:166
msgid "The ``socket.getaddrinfo()`` function is useful for finding information about a remote site so that the correct arguments for ``sock:sysconnect()`` can be passed. This function may use the :ref:`worker_pool_threads <cfg_basic-worker_pool_threads>` configuration parameter."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:172
#: ../doc/reference/reference_lua/socket.rst:560
#: ../doc/reference/reference_lua/socket.rst:572
msgid "A table containing these fields: \"host\", \"family\", \"type\", \"protocol\", \"port\"."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:177
msgid "tarantool> socket.getaddrinfo('tarantool.org', 'http')\n"
"---\n"
"- - host: 188.93.56.70\n"
"    family: AF_INET\n"
"    type: SOCK_STREAM\n"
"    protocol: tcp\n"
"    port: 80\n"
"  - host: 188.93.56.70\n"
"    family: AF_INET\n"
"    type: SOCK_DGRAM\n"
"    protocol: udp\n"
"    port: 80\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:197
msgid "The ``socket.tcp_server()`` function makes Tarantool act as a server that can accept connections. Usually the same objective is accomplished with :ref:`box.cfg{listen=...} <cfg_basic-listen>`."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:201
msgid "host name or IP"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:202
msgid "host port, may be 0"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:203
msgid "what to execute when a connection occurs"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:205
msgid "number of seconds to wait before timing out"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:208
msgid "The handler-function-or-table parameter may be simply a function name / function declaration: :code:`handler_function`. Or it may be a table: :code:`{handler =` :samp:`{handler_function} [, prepare = {prepare_function}] [, name = {name}]` :code:`}`. ``handler_function`` is mandatory; it may have a single parameter = the socket; it is for continuous operation after the connection is made. ``prepare_function`` is optional; it is executed once before any connection is made. Examples:"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:220
msgid "socket.tcp_server('localhost', 3302, function (s) loop_loop() end)\n"
"socket.tcp_server('localhost', 3302, {handler=hfunc, name='name'})\n"
"socket.tcp_server('localhost', 3302, {handler=hfunc, prepare=pfunc})"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:226
msgid "For a fuller example see :ref:`Use tcp_server to accept file contents sent with socat <socket_socat>`."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:235
msgid "Connect an existing socket to a remote host. The argument values are the same as in :ref:`tcp_connect() <socket-tcp_connect>`. The host must be an IP address."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:252
msgid "Parameters:"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:242
msgid "Either:"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:241
msgid "host - a string representation of an IPv4 address or an IPv6 address;"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:243
msgid "port - a number."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:245
#: ../doc/reference/reference_lua/socket.rst:252
msgid "Or:"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:245
msgid "host - a string containing \"unix/\";"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:246
msgid "port - a string containing a path to a unix socket."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:248
msgid "host - a number, 0 (zero), meaning \"all local interfaces\";"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:250
msgid "port - a number. If a port number is 0 (zero), the socket will be bound to a random local port."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:254
msgid "the socket object value may change if sysconnect() succeeds."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:259
msgid "socket = require('socket')\n"
"sock = socket('AF_INET', 'SOCK_STREAM', 'tcp')\n"
"sock:sysconnect(0, 3301)"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:270
msgid "Send data over a connected socket."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:272
#: ../doc/reference/reference_lua/socket.rst:397
msgid "what is to be sent"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:273
#: ../doc/reference/reference_lua/socket.rst:399
msgid "the number of bytes sent."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:276
msgid "Possible errors: nil on error."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:282
msgid "Write as much data as possible to the socket buffer if non-blocking. Rarely used. For details see `this description`_."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:289
msgid "Read ``size`` bytes from a connected socket. An internal read-ahead buffer is used to reduce the cost of this call."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:292
#: ../doc/reference/reference_lua/socket.rst:410
msgid "maximum number of bytes to receive. See :ref:`Recommended size <socket-recommended>`."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:293
msgid "a string of the requested length on success."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:296
msgid "Possible errors: On error, returns an empty string, followed by status, errno, errstr. In case the writing side has closed its end, returns the remainder read from the socket (possibly an empty string), followed by \"eof\" status."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:307
msgid "Read from a connected socket until some condition is true, and return the bytes that were read. Reading goes on until ``limit`` bytes have been read, or a delimiter has been read, or a timeout has expired. Unlike ``socket_object:recv`` (which uses an internal read-ahead buffer), ``socket_object:read`` depends on the socket's buffer."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:314
#: ../doc/reference/reference_lua/socket.rst:339
msgid "maximum number of bytes to read, for example 50 means \"stop after 50 bytes\""
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:316
msgid "separator for example '?' means \"stop after a question mark\""
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:318
msgid "maximum number of seconds to wait, for example 50 means \"stop after 50 seconds\"."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:320
msgid ":samp:`chunk={limit}` and/or :samp:`delimiter={delimiter}`, for example :code:`{chunk=5,delimiter='x'}`."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:324
msgid "an empty string if there is nothing more to read, or a nil value if error, or a string up to ``limit`` bytes long, which may include the bytes that matched the ``delimiter`` expression."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:334
msgid "Return data from the socket buffer if non-blocking. In case the socket is blocking, ``sysread()`` can block the calling process. Rarely used. For details, see also `this description <https://github.com/tarantool/tarantool/wiki/sockets%201.6>`_."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:342
msgid "an empty string if there is nothing more to read, or a nil value if error, or a string up to ``size`` bytes long."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:350
msgid "Bind a socket to the given host/port. A UDP socket after binding can be used to receive data (see :ref:`socket_object.recvfrom <socket-recvfrom>`). A TCP socket can be used to accept new connections, after it has been put in listen mode."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:358
msgid "true for success, false for error. If return is false, use :ref:`socket_object:errno() <socket-error>` or :ref:`socket_object:error() <socket-error>` to see details."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:367
msgid "Start listening for incoming connections."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:369
msgid "on Linux the listen ``backlog`` backlog may be from ``/proc/sys/net/core/somaxconn``, on BSD the backlog may be ``SOMAXCONN``."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:373
msgid "true for success, false for error."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:374
msgid "boolean."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:380
msgid "Accept a new client connection and create a new connected socket. It is good practice to set the socket's blocking mode explicitly after accepting."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:384
msgid "new socket if success."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:387
msgid "Possible errors: nil."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:393
msgid "Send a message on a UDP socket to a specified host."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:402
msgid "Possible errors: on error, returns nil and may return status, errno, errstr."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:408
msgid "Receive a message on a UDP socket."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:411
msgid "message, a table containing \"host\", \"family\" and \"port\" fields."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:412
msgid "string, table"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:414
msgid "Possible errors: on error, returns status, errno, errstr."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:418
msgid "After ``message_content, message_sender = recvfrom(1)`` the value of ``message_content`` might be a string containing 'X' and the value of ``message_sender`` might be a table containing"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:422
msgid "message_sender.host = '18.44.0.1'\n"
"message_sender.family = 'AF_INET'\n"
"message_sender.port = 43065"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:432
msgid "Shutdown a reading end, a writing end, or both ends of a socket."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:434
msgid "socket.SHUT_RD, socket.SHUT_WR, or socket.SHUT_RDWR."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:436
#: ../doc/reference/reference_lua/tap.rst:153
#: ../doc/reference/reference_lua/tap.rst:176
#: ../doc/reference/reference_lua/tap.rst:210
#: ../doc/reference/reference_lua/tap.rst:245
#: ../doc/reference/reference_lua/tap.rst:258
#: ../doc/reference/reference_lua/tap.rst:268
#: ../doc/reference/reference_lua/tap.rst:283
#: ../doc/reference/reference_lua/tap.rst:304
#: ../doc/reference/reference_lua/tap.rst:323
msgid "true or false."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:443
msgid "Close (destroy) a socket. A closed socket should not be used any more. A socket is closed automatically when the Lua garbage collector removes its user data."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:447
msgid "true on success, false on error. For example, if sock is already closed, sock:close() returns false."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:456
msgid "Retrieve information about the last error that occurred on a socket, if any. Errors do not cause throwing of exceptions so these functions are usually necessary."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:459
msgid "result for ``sock:errno()``, result for ``sock:error()``. If there is no error, then ``sock:errno()`` will return 0 and ``sock:error()``."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:461
msgid "number, string"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:467
msgid "Set socket flags. The argument values are the same as in the `Linux getsockopt(2) man page <http://man7.org/linux/man-pages/man2/setsockopt.2.html>`_. The ones that Tarantool accepts are:"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:471
msgid "SO_ACCEPTCONN"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:472
msgid "SO_BINDTODEVICE"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:473
msgid "SO_BROADCAST"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:474
msgid "SO_DEBUG"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:475
msgid "SO_DOMAIN"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:476
msgid "SO_ERROR"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:477
msgid "SO_DONTROUTE"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:478
msgid "SO_KEEPALIVE"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:479
msgid "SO_MARK"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:480
msgid "SO_OOBINLINE"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:481
msgid "SO_PASSCRED"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:482
msgid "SO_PEERCRED"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:483
msgid "SO_PRIORITY"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:484
msgid "SO_PROTOCOL"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:485
msgid "SO_RCVBUF"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:486
msgid "SO_RCVBUFFORCE"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:487
msgid "SO_RCVLOWAT"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:488
msgid "SO_SNDLOWAT"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:489
msgid "SO_RCVTIMEO"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:490
msgid "SO_SNDTIMEO"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:491
msgid "SO_REUSEADDR"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:492
msgid "SO_SNDBUF"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:493
msgid "SO_SNDBUFFORCE"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:494
msgid "SO_TIMESTAMP"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:495
msgid "SO_TYPE"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:497
msgid "Setting SO_LINGER is done with ``sock:linger(active)``."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:503
msgid "Get socket flags. For a list of possible flags see ``sock:setsockopt()``."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:509
msgid "Set or clear the SO_LINGER flag. For a description of the flag, see the `Linux man page <http://man7.org/linux/man-pages/man1/loginctl.1.html>`_."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:514
msgid "new active and timeout values."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:520
msgid "``sock:nonblock()`` returns the current flag value."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:521
msgid "``sock:nonblock(false)`` sets the flag to false and returns false."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:522
msgid "``sock:nonblock(true)`` sets the flag to true and returns true."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:524
msgid "This function may be useful before invoking a function which might otherwise block indefinitely."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:531
msgid "Wait until something is readable, or until a timeout value expires."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:533
msgid "true if the socket is now readable, false if timeout expired;"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:539
msgid "Wait until something is writable, or until a timeout value expires."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:541
msgid "true if the socket is now writable, false if timeout expired;"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:547
msgid "Wait until something is either readable or writable, or until a timeout value expires."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:549
msgid "'R' if the socket is now readable, 'W' if the socket is now writable, 'RW' if the socket is now both readable and writable, '' (empty string) if timeout expired;"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:555
msgid "The ``sock:name()`` function is used to get information about the near side of the connection. If a socket was bound to ``xyz.com:45``, then ``sock:name`` will return information about ``[host:xyz.com, port:45]``. The equivalent POSIX function is ``getsockname()``."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:567
msgid "The ``sock:peer()`` function is used to get information about the far side of a connection. If a TCP connection has been made to a distant host ``tarantool.org:80``, ``sock:peer()`` will return information about ``[host:tarantool.org, port:80]``. The equivalent POSIX function is ``getpeername()``."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:579
msgid "The ``socket.iowait()`` function is used to wait until read-or-write activity occurs for a file descriptor."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:582
msgid "file descriptor"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:583
msgid "'R' or 1 = read, 'W' or 2 = write, 'RW' or 3 = read|write."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:584
msgid "number of seconds to wait"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:586
msgid "If the fd parameter is nil, then there will be a sleep until the timeout. If the timeout parameter is nil or unspecified, then timeout is infinite."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:589
msgid "Ordinarily the return value is the activity that occurred ('R' or 'W' or 'RW' or 1 or 2 or 3). If the timeout period goes by without any reading or writing, the return is an error = ETIMEDOUT."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:593
msgid "Example: ``socket.iowait(sock:fd(), 'r', 1.11)``"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:599
msgid "Recommended size"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:601
msgid "For ``recv`` and ``recvfrom``: use the optional ``size`` parameter to limit the number of bytes to receive. A fixed size such as 512 is often reasonable; a pre-calculated size that depends on context -- such as the message format or the state of the network -- is often better. For ``recvfrom``, be aware that a size greater than the `Maximum Transmission Unit <https://en.wikipedia.org/wiki/Maximum_transmission_unit>`_ can cause inefficient transport. For Mac OS X, be aware that the size can be tuned by changing ``sysctl net.inet.udp.maxdgram``."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:612
msgid "If ``size`` is not stated: Tarantool will make an extra call to calculate how many bytes are necessary. This extra call takes time, therefore not stating ``size`` may be inefficient."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:616
msgid "If ``size`` is stated: on a UDP socket, excess bytes are discarded. On a TCP socket, excess bytes are not discarded and can be received by the next call."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:622
msgid "Examples"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:626
msgid "Use of a TCP socket over the Internet"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:628
msgid "In this example a connection is made over the internet between a Tarantool instance and tarantool.org, then an HTTP \"head\" message is sent, and a response is received: \"``HTTP/1.1 200 OK``\" or something else if the site has moved. This is not a useful way to communicate with this particular site, but shows that the system works."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:634
msgid "tarantool> socket = require('socket')\n"
"---\n"
"...\n"
"tarantool> sock = socket.tcp_connect('tarantool.org', 80)\n"
"---\n"
"...\n"
"tarantool> type(sock)\n"
"---\n"
"- table\n"
"...\n"
"tarantool> sock:error()\n"
"---\n"
"- null\n"
"...\n"
"tarantool> sock:send(\"HEAD / HTTP/1.0\\r\\nHost: tarantool.org\\r\\n\\r\\n\")\n"
"---\n"
"- 40\n"
"...\n"
"tarantool> sock:read(17)\n"
"---\n"
"- HTTP/1.1 302 Move\n"
"...\n"
"tarantool> sock:close()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:665
msgid "Use of a UDP socket on localhost"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:667
msgid "Here is an example with datagrams. Set up two connections on 127.0.0.1 (localhost): ``sock_1`` and ``sock_2``. Using ``sock_2``, send a message to ``sock_1``. Using ``sock_1``, receive a message. Display the received message. Close both connections. |br| This is not a useful way for a computer to communicate with itself, but shows that the system works."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:673
msgid "tarantool> socket = require('socket')\n"
"---\n"
"...\n"
"tarantool> sock_1 = socket('AF_INET', 'SOCK_DGRAM', 'udp')\n"
"---\n"
"...\n"
"tarantool> sock_1:bind('127.0.0.1')\n"
"---\n"
"- true\n"
"...\n"
"tarantool> sock_2 = socket('AF_INET', 'SOCK_DGRAM', 'udp')\n"
"---\n"
"...\n"
"tarantool> sock_2:sendto('127.0.0.1', sock_1:name().port,'X')\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> message = sock_1:recvfrom(512)\n"
"---\n"
"...\n"
"tarantool> message\n"
"---\n"
"- X\n"
"...\n"
"tarantool> sock_1:close()\n"
"---\n"
"- true\n"
"...\n"
"tarantool> sock_2:close()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:712
msgid "Use tcp_server to accept file contents sent with socat"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:714
msgid "Here is an example of the tcp_server function, reading strings from the client and printing them. On the client side, the Linux socat utility will be used to ship a whole file for the tcp_server function to read."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:719
msgid "Start two shells. The first shell will be a server instance. The second shell will be the client."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:722
msgid "On the first shell, start Tarantool and say:"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:724
msgid "box.cfg{}\n"
"socket = require('socket')\n"
"socket.tcp_server('0.0.0.0', 3302,\n"
"{\n"
"  handler = function(s)\n"
"    while true do\n"
"      local request\n"
"      request = s:read(\"\\n\");\n"
"      if request == \"\" or request == nil then\n"
"        break\n"
"      end\n"
"      print(request)\n"
"    end\n"
"  end,\n"
"  prepare = function()\n"
"    print('Initialized')\n"
"  end\n"
"}\n"
")"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:746
msgid "The above code means: use `tcp_server()` to wait for a connection from any host on port 3302. When it happens, enter a loop that reads on the socket and prints what it reads. The \"delimiter\" for the read function is \"\\\\n\" so each `read()` will read a string as far as the next line feed, including the line feed."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:753
msgid "On the second shell, create a file that contains a few lines. The contents don't matter. Suppose the first line contains A, the second line contains B, the third line contains C. Call this file \"tmp.txt\"."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:758
msgid "On the second shell, use the socat utility to ship the tmp.txt file to the server instance's host and port:"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:761
msgid "$ socat TCP:localhost:3302 ./tmp.txt"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:765
msgid "Now watch what happens on the first shell. The strings \"A\", \"B\", \"C\" are printed."
msgstr ""

#: ../doc/reference/reference_lua/strict.rst:5
msgid "Module `strict`"
msgstr ""

#: ../doc/reference/reference_lua/strict.rst:9
msgid "The :code:`strict` module has functions for turning \"strict mode\" on or off. When strict mode is on, an attempt to use an undeclared global variable will cause an error. A global variable is considered \"undeclared\" if it has never had a value assigned to it. Often this is an indication of a programming error."
msgstr ""

#: ../doc/reference/reference_lua/strict.rst:14
msgid "By default strict mode is off, unless tarantool was built with the ``-DCMAKE_BUILD_TYPE=Debug`` option -- see the description of build options in section :ref:`building-from-source <building_from_source>`."
msgstr ""

#: ../doc/reference/reference_lua/strict.rst:20
msgid "tarantool> strict = require('strict')\n"
"---\n"
"...\n"
"tarantool> strict.on()\n"
"---\n"
"...\n"
"tarantool> a = b -- strict mode is on so this will cause an error\n"
"---\n"
"- error: ... variable ''b'' is not declared'\n"
"...\n"
"tarantool> strict.off()\n"
"---\n"
"...\n"
"tarantool> a = b -- strict mode is off so this will not cause an error\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:5
msgid "Module `string`"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:13
msgid "The :code:`string` module has everything in the `standard Lua string library <https://www.lua.org/pil/20.html>`_, and some Tarantool extensions."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:17
msgid "In this section we only discuss the additional functions that the Tarantool developers have added."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:20
msgid "Below is a list of all additional ``string`` functions."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:30
msgid ":ref:`string.ljust() <string-ljust>`"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:30
msgid "Left-justify a string"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:33
msgid ":ref:`string.rjust() <string-rjust>`"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:33
msgid "Right-justify a string"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:36
msgid ":ref:`string.hex() <string-hex>`"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:36
msgid "Get the hexadecimal value of a string"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:39
msgid ":ref:`string.startswith() <string-startswith>`"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:39
msgid "Check if a string starts with a given substring"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:42
msgid ":ref:`string.endswith() <string-endswith>`"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:42
msgid "Check if a string ends with a given substring"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:45
msgid ":ref:`string.lstrip() <string-lstrip>`"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:45
msgid "Remove spaces on the left of a string"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:48
msgid ":ref:`string.rstrip() <string-rstrip>`"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:48
msgid "Remove spaces on the right of a string"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:51
msgid ":ref:`string.split() <string-split>`"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:51
msgid "Split a string into a table of strings"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:54
msgid ":ref:`string.strip() <string-strip>`"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:54
msgid "Remove spaces on the left and right of a string"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:63
msgid "Return the string left-justified in a string of length ``width``."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:65
msgid "the string to left-justify"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:66
msgid "the width of the string after left-justifying"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:67
#: ../doc/reference/reference_lua/string.rst:92
msgid "a single character, default = 1 space"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:69
msgid "left-justified string (unchanged if width <= string length)"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:74
msgid "tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.ljust(' A', 5)\n"
"---\n"
"- ' A   '\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:88
msgid "Return the string right-justified in a string of length ``width``."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:90
msgid "the string to right-justify"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:91
msgid "the width of the string after right-justifying"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:94
msgid "right-justified string (unchanged if width <= string length)"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:99
msgid "tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.rjust('', 5, 'X')\n"
"---\n"
"- 'XXXXX'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:113
msgid "Return the hexadecimal value of the input string."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:115
#: ../doc/reference/reference_lua/string.rst:199
#: ../doc/reference/reference_lua/string.rst:222
#: ../doc/reference/reference_lua/string.rst:277
msgid "the string to process"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:117
msgid "hexadecimal, 2 hex-digit characters for each input character"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:122
msgid "tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.hex('ABC ')\n"
"---\n"
"- '41424320'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:136
msgid "Return True if ``input-string`` starts with ``start-string``, otherwise return False."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:139
msgid "the string where ``start-string`` should be looked for"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:140
#: ../doc/reference/reference_lua/string.rst:170
msgid "the string to look for"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:141
#: ../doc/reference/reference_lua/string.rst:171
msgid "position: where to start looking within ``input-string``"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:142
#: ../doc/reference/reference_lua/string.rst:172
msgid "position: where to end looking within ``input-string``"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:144
#: ../doc/reference/reference_lua/string.rst:174
#: ../doc/reference/reference_lua/utf8.rst:146
#: ../doc/reference/reference_lua/utf8.rst:171
#: ../doc/reference/reference_lua/utf8.rst:193
#: ../doc/reference/reference_lua/utf8.rst:215
msgid "true or false"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:147
#: ../doc/reference/reference_lua/string.rst:177
msgid "``start-pos`` and ``end-pos`` may be negative, meaning the position should be calculated from the end of the string."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:152
msgid "tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.startswith(' A', 'A', 2, 5)\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:166
msgid "Return True if ``input-string`` ends with ``end-string``, otherwise return False."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:169
msgid "the string where ``end-string`` should be looked for"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:182
msgid "tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.endswith('Baa', 'aa')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:197
msgid "Return the value of the input string, but without spaces on the left."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:201
#: ../doc/reference/reference_lua/string.rst:224
#: ../doc/reference/reference_lua/string.rst:279
msgid "result after stripping spaces from input string"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:206
msgid "tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.lstrip(' ABC ')\n"
"---\n"
"- 'ABC '\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:220
msgid "Return the value of the input string, but without spaces on the right."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:229
msgid "tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.rstrip(' ABC ')\n"
"---\n"
"- ' ABC'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:243
msgid "Split ``input-string`` into one or more output strings in a table. The places to split are the places where ``split-string`` occurs."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:247
msgid "the string to split"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:248
msgid "the string to find within ``input-string``. Default = space."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:250
msgid "maximum number of delimiters to process counting from the beginning of the input string. Result will contain max + 1 parts maximum."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:254
msgid "table of strings that were split from ``input-string``"
msgstr ""

#: ../doc/reference/reference_lua/string.rst:259
msgid "tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.split(\"A:B C:D\", \":\", 2)\n"
"---\n"
"- - A\n"
"  - B\n"
"  - ' C:D'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:275
msgid "Return the value of the input string, but without spaces on the left or the right."
msgstr ""

#: ../doc/reference/reference_lua/string.rst:284
msgid "tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.strip(' ABC ')\n"
"---\n"
"- ABC\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/table.rst:5
msgid "Module `table`"
msgstr ""

#: ../doc/reference/reference_lua/table.rst:9
msgid "The :code:`table` module has everything in the `standard Lua table library <https://www.lua.org/pil/19.html>`_, and some Tarantool extensions."
msgstr ""

#: ../doc/reference/reference_lua/table.rst:13
msgid "You can see this by saying \"table\": you will see this list of functions: ``clear`` (LuaJIT extension = erase all elements), `concat <https://www.lua.org/manual/5.1/manual.html#pdf-table.concat>`_ (concatenate), ``copy`` (make a copy of an array), ``deepcopy`` (see description below), ``foreach``, ``foreach1``, `getn <https://www.lua.org/pil/19.1.html>`_ (get the number of elements in an array), `insert <https://www.lua.org/manual/5.1/manual.html#pdf-table.insert>`_ (insert an element into an array), `maxn <https://www.lua.org/manual/5.1/manual.html#pdf-table.maxn>`_ (get largest index) `move <https://www.lua.org/manual/5.3/manual.html#pdf-table.move>`_ (move elements between tables), ``new`` (LuaJIT extension = return a new table with pre-allocated elements), `remove <https://www.lua.org/manual/5.1/manual.html#pdf-table.remove>`_ (remove an element from an array), `sort <https://www.lua.org/manual/5.1/manual.html#pdf-table.sort>`_ (sort the elements of an array)."
msgstr ""

#: ../doc/reference/reference_lua/table.rst:28
msgid "In this section we only discuss the additional function that the Tarantool developers have added: ``deepcopy``."
msgstr ""

#: ../doc/reference/reference_lua/table.rst:35
msgid "Return a \"deep\" copy of the table -- a copy which follows nested structures to any depth and does not depend on pointers, it copies the contents."
msgstr ""

#: ../doc/reference/reference_lua/table.rst:39
msgid "(table) the table to copy"
msgstr ""

#: ../doc/reference/reference_lua/table.rst:41
msgid "the copy of the table"
msgstr ""

#: ../doc/reference/reference_lua/table.rst:46
msgid "tarantool> input_table = {1,{'a','b'}}\n"
"---\n"
"...\n"
"\n"
"tarantool> output_table = table.deepcopy(input_table)\n"
"---\n"
"...\n"
"\n"
"tarantool> output_table\n"
"---\n"
"- - 1\n"
"  - - a\n"
"    - b\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/table.rst:67
msgid "Put the input-table contents in sorted order."
msgstr ""

#: ../doc/reference/reference_lua/table.rst:69
msgid "The `basic Lua table.sort <https://www.lua.org/manual/5.1/manual.html#pdf-table.sort>`_ has a default comparison-function: :code:`function (a, b) return a < b end`."
msgstr ""

#: ../doc/reference/reference_lua/table.rst:72
msgid "That is efficient and standard. However, sometimes Tarantool users will want an equivalent to ``table.sort`` which has any of these features:"
msgstr ""

#: ../doc/reference/reference_lua/table.rst:75
msgid "(1) If the table contains nils, except nils at the end, the results must still be correct. That is not the case with the default tarantool_sort, and it cannot be fixed by making a comparison that checks whether a and b are nil. (Before trying certain Internet suggestions, test with {1, nil, 2, -1, 44, 1e308, nil, 2, nil, nil, 0}."
msgstr ""

#: ../doc/reference/reference_lua/table.rst:81
msgid "(2) If strings are to be sorted in a language-aware way, there must be a parameter for collation."
msgstr ""

#: ../doc/reference/reference_lua/table.rst:84
msgid "(3) If the table has a mix of types, then they must be sorted as booleans, then numbers, then strings, then byte arrays."
msgstr ""

#: ../doc/reference/reference_lua/table.rst:87
msgid "Since all those features are available in Tarantool spaces, the solution for Tarantool is simple: make a temporary Tarantool space, put the table contents into it, retrieve the tuples from it in order, and overwrite the table."
msgstr ""

#: ../doc/reference/reference_lua/table.rst:92
msgid "Here then is ``tarantool_sort()`` which does the same thing as ``table.sort`` but has those extra features. It is not fast and it requires a database privilege, so it should only be used if the extra features are necessary."
msgstr ""

#: ../doc/reference/reference_lua/table.rst:97
msgid "  function tarantool_sort(input_table, collation)\n"
"      local c = collation or 'binary'\n"
"      local tmp_name = 'Temporary_for_tarantool_sort'\n"
"      pcall(function() box.space[tmp_name]:drop() end)\n"
"      box.schema.space.create(tmp_name, {temporary = true})\n"
"      box.space[tmp_name]:create_index('I')\n"
"      box.space[tmp_name]:create_index('I2',\n"
"                                       {unique = false,\n"
"                                        type='tree',\n"
"                                        parts={{2, 'scalar',\n"
"                                                collation = c,\n"
"                                                is_nullable = true}}})\n"
"      for i = 1, table.maxn(input_table) do\n"
"          box.space[tmp_name]:insert{i, input_table[i]}\n"
"      end\n"
"      local t = box.space[tmp_name].index.I2:select()\n"
"      for i = 1, table.maxn(input_table) do\n"
"          input_table[i] = t[i][2]\n"
"      end\n"
"      box.space[tmp_name]:drop()\n"
"    end\n"
"\n"
"For example, suppose table t = {1, 'A', -88.3, nil, true, 'b', 'B', nil, 'À'}.\n"
"After tarantool_sort(t, 'unicode_ci') t contains {nil, nil, true, -88.3, 1, 'A', 'À', 'b', 'B'}."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:3
msgid "Module `tap`"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:9
msgid "The ``tap`` module streamlines the testing of other modules. It allows writing of tests in the `TAP protocol`_. The results from the tests can be parsed by standard TAP-analyzers so they can be passed to utilities such as `prove`_. Thus one can run tests and then use the results for statistics, decision-making, and so on."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:19
msgid "Below is a list of all ``tap`` functions."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:29
msgid ":ref:`tap.test() <tap-test>`"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:29
msgid "Initialize"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:32
msgid ":ref:`taptest:test() <taptest-test>`"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:32
msgid "Create a subtest and print the results"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:35
msgid ":ref:`taptest:plan() <taptest-plan>`"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:35
msgid "Indicate how many tests to perform"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:38
msgid ":ref:`taptest:check() <taptest-check>`"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:38
msgid "Check the number of tests performed"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:41
msgid ":ref:`taptest:diag() <taptest-diag>`"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:41
msgid "Display a diagnostic message"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:44
msgid ":ref:`taptest:ok() <taptest-ok>`"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:44
#: ../doc/reference/reference_lua/tap.rst:47
#: ../doc/reference/reference_lua/tap.rst:50
msgid "Evaluate the condition and display the message"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:47
msgid ":ref:`taptest:fail() <taptest-fail>`"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:50
msgid ":ref:`taptest:skip() <taptest-skip>`"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:53
msgid ":ref:`taptest:is() <taptest-is>`"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:53
msgid "Check if the two arguments are equal"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:56
msgid ":ref:`taptest:isnt() <taptest-isnt>`"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:56
msgid "Check if the two arguments are different"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:59
msgid ":ref:`taptest:is_deeply() <taptest-is_deeply>`"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:59
msgid "Recursively check if the two arguments are equal"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:62
msgid ":ref:`taptest:like() <taptest-like>`"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:62
msgid "Check if the argument matches a pattern"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:65
msgid ":ref:`taptest:unlike() <taptest-unlike>`"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:65
msgid "Check if the argument does not match a pattern"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:68
msgid ":ref:`taptest:isnil() <taptest-istype>` |br| :ref:`taptest:isstring() <taptest-istype>` |br| :ref:`taptest:isnumber() <taptest-istype>` |br| :ref:`taptest:istable() <taptest-istype>` |br| :ref:`taptest:isboolean() <taptest-istype>` |br| :ref:`taptest:isudata() <taptest-istype>` |br| :ref:`taptest:iscdata() <taptest-istype>`"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:74
msgid "Check if a value has a particular type"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:90
msgid "Initialize."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:92
msgid "The result of ``tap.test`` is an object, which will be called taptest in the rest of this discussion, which is necessary for ``taptest:plan()`` and all the other methods."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:96
#: ../doc/reference/reference_lua/tap.rst:117
msgid "an arbitrary name to give for the test outputs."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:97
#: ../doc/reference/reference_lua/tap.rst:119
msgid "taptest"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:100
msgid "tap = require('tap')\n"
"taptest = tap.test('test-name')"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:111
msgid "Create a subtest (if no ``func`` argument specified), or (if all arguments are specified) create a subtest, run the test function and print the result."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:115
msgid "See the :ref:`example <tap-example>`."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:118
msgid "the test logic to run."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:120
msgid "userdata or string"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:126
msgid "Indicate how many tests will be performed."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:135
msgid "Checks the number of tests performed."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:137
msgid "The result will be a display saying ``# bad plan: ...`` if the number of completed tests is not equal to the number of tests specified by ``taptest:plan(...)``. (This is a purely Tarantool feature: \"bad plan\" messages are out of the TAP13 standard.)"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:142
msgid "This check should only be done after all planned tests are complete, so ordinarily ``taptest:check()`` will only appear at the end of a script. However, as a Tarantool extension, ``taptest:check()`` may appear at the end of any subtest. Therefore there are three ways to cause the check:"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:147
msgid "by calling ``taptest:check()`` at the end of a script,"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:148
msgid "by calling a function which ends with a call to ``taptest:check()``,"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:149
msgid "or by calling taptest:test('...', subtest-function-name) where subtest-function-name does not need to end with ``taptest:check()`` because it can be called after the subtest is complete."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:160
msgid "Display a diagnostic message."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:162
msgid "the message to be displayed."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:169
msgid "This is a basic function which is used by other functions. Depending on the value of ``condition``, print 'ok' or 'not ok' along with debugging information. Displays the message."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:173
msgid "an expression which is true or false"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:174
#: ../doc/reference/reference_lua/tap.rst:208
#: ../doc/reference/reference_lua/tap.rst:221
#: ../doc/reference/reference_lua/tap.rst:244
#: ../doc/reference/reference_lua/tap.rst:256
#: ../doc/reference/reference_lua/tap.rst:273
#: ../doc/reference/reference_lua/tap.rst:288
#: ../doc/reference/reference_lua/tap.rst:302
#: ../doc/reference/reference_lua/tap.rst:321
msgid "name of the test"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:181
msgid "tarantool> taptest:ok(true, 'x')\n"
"ok - x\n"
"---\n"
"- true\n"
"...\n"
"tarantool> tap = require('tap')\n"
"---\n"
"...\n"
"tarantool> taptest = tap.test('test-name')\n"
"TAP version 13\n"
"---\n"
"...\n"
"tarantool> taptest:ok(1 + 1 == 2, 'X')\n"
"ok - X\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:205
msgid "``taptest:fail('x')`` is equivalent to ``taptest:ok(false, 'x')``. Displays the message."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:217
msgid "``taptest:skip('x')`` is equivalent to ``taptest:ok(true, 'x' .. '# skip')``. Displays the message."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:227
msgid "tarantool> taptest:skip('message')\n"
"ok - message # skip\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:239
msgid "Check whether the first argument equals the second argument. Displays extensive message if the result is false."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:242
#: ../doc/reference/reference_lua/tap.rst:254
#: ../doc/reference/reference_lua/tap.rst:271
#: ../doc/reference/reference_lua/tap.rst:286
#: ../doc/reference/reference_lua/tap.rst:300
msgid "actual result"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:243
#: ../doc/reference/reference_lua/tap.rst:255
#: ../doc/reference/reference_lua/tap.rst:272
msgid "expected result"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:252
msgid "This is the negation of :ref:`taptest:is() <taptest-is>`."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:265
msgid "Recursive version of ``taptest:is(...)``, which can be be used to compare tables as well as scalar values."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:279
msgid "Verify a string against a `pattern <http://lua-users.org/wiki/PatternsTutorial>`_. Ok if match is found."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:287
#: ../doc/reference/reference_lua/tap.rst:301
msgid "pattern"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:290
msgid "test:like(tarantool.version, '^[1-9]', \"version\")"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:298
msgid "This is the negation of :ref:`taptest:like() <taptest-like>`."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:317
msgid "Test whether a value has a particular type. Displays a long message if the value is not of the specified type."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:335
msgid "To run this example: put the script in a file named ./tap.lua, then make tap.lua executable by saying ``chmod a+x ./tap.lua``, then execute using Tarantool as a script processor by saying ./tap.lua."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:339
msgid "#!/usr/bin/tarantool\n"
"local tap = require('tap')\n"
"test = tap.test(\"my test name\")\n"
"test:plan(2)\n"
"test:ok(2 * 2 == 4, \"2 * 2 is 4\")\n"
"test:test(\"some subtests for test2\", function(test)\n"
"    test:plan(2)\n"
"    test:is(2 + 2, 4, \"2 + 2 is 4\")\n"
"    test:isnt(2 + 3, 4, \"2 + 3 is not 4\")\n"
"end)\n"
"test:check()"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:353
msgid "The output from the above script will look approximately like this:"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:355
msgid "TAP version 13\n"
"1..2\n"
"ok - 2 * 2 is 4\n"
"    # Some subtests for test2\n"
"    1..2\n"
"    ok - 2 + 2 is 4,\n"
"    ok - 2 + 3 is not 4\n"
"    # Some subtests for test2: end\n"
"ok - some subtests for test2"
msgstr ""

#: ../doc/reference/reference_lua/tarantool.rst:5
msgid "Module `tarantool`"
msgstr ""

#: ../doc/reference/reference_lua/tarantool.rst:9
msgid "By saying ``require('tarantool')``, one can answer some questions about how the tarantool server was built, such as \"what flags were used\", or \"what was the version of the compiler\"."
msgstr ""

#: ../doc/reference/reference_lua/tarantool.rst:15
msgid "Additionally one can see the uptime and the server version and the process id. Those information items can also be accessed with :ref:`box.info() <box_introspection-box_info>` but use of the tarantool module is recommended."
msgstr ""

#: ../doc/reference/reference_lua/tarantool.rst:22
msgid "tarantool> tarantool = require('tarantool')\n"
"---\n"
"...\n"
"tarantool> tarantool\n"
"---\n"
"- build:\n"
"    target: Linux-x86_64-RelWithDebInfo\n"
"    options: cmake . -DCMAKE_INSTALL_PREFIX=/usr -DENABLE_BACKTRACE=ON\n"
"    mod_format: so\n"
"    flags: ' -fno-common -fno-omit-frame-pointer -fno-stack-protector -fexceptions\n"
"      -funwind-tables -fopenmp -msse2 -std=c11 -Wall -Wextra -Wno-sign-compare -Wno-strict-aliasing\n"
"      -fno-gnu89-inline'\n"
"    compiler: /usr/bin/x86_64-linux-gnu-gcc /usr/bin/x86_64-linux-gnu-g++\n"
"  uptime: 'function: 0x408668e0'\n"
"  version: 1.7.0-66-g9093daa\n"
"  pid: 'function: 0x40866900'\n"
"...\n"
"tarantool> tarantool.pid()\n"
"---\n"
"- 30155\n"
"...\n"
"tarantool> tarantool.uptime()\n"
"---\n"
"- 108.64641499519\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:3
msgid "Module `uri`"
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:9
msgid "A \"URI\" is a \"Uniform Resource Identifier\". The `IETF standard <https://www.ietf.org/rfc/rfc2396.txt>`_ says a URI string looks like this:"
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:13
msgid "[scheme:]scheme-specific-part[#fragment]"
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:17
msgid "A common type, a hierarchical URI, looks like this:"
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:19
msgid "[scheme:][//authority][path][?query][#fragment]"
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:23
msgid "For example the string ``'https://tarantool.org/x.html#y'`` has three components:"
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:26
msgid "``https`` is the scheme,"
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:27
msgid "``tarantool.org/x.html`` is the path,"
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:28
msgid "``y`` is the fragment."
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:30
msgid "Tarantool's URI module provides routines which convert URI strings into their components, or turn components into URI strings."
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:37
msgid "Below is a list of all ``uri`` functions."
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:47
msgid ":ref:`uri.parse() <uri-parse>`"
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:47
msgid "Get a table of URI components"
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:50
msgid ":ref:`uri.format() <uri-format>`"
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:50
msgid "Construct a URI from components"
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:60
msgid "a Uniform Resource Identifier"
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:61
msgid "URI-components-table. Possible components are fragment, host, login, password, path, query, scheme, service."
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:63
msgid "Table"
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:67
msgid "tarantool> uri = require('uri')\n"
"---\n"
"...\n"
"\n"
"tarantool> uri.parse('http://x.html#y')\n"
"---\n"
"- host: x.html\n"
"  scheme: http\n"
"  fragment: y\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:84
msgid "a series of name:value pairs, one for each component"
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:86
msgid "boolean. If this is supplied and is ``true``, then the password component is rendered in clear text, otherwise it is omitted."
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:89
msgid "URI-string. Thus uri.format() is the reverse of uri.parse()."
msgstr ""

#: ../doc/reference/reference_lua/uri.rst:94
msgid "tarantool> uri.format({host = 'x.html', scheme = 'http', fragment = 'y'})\n"
"---\n"
"- http://x.html#y\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:5
msgid "Module `utf8`"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:11
msgid "``utf8`` is Tarantool's module for handling UTF-8 strings. It includes some functions which are compatible with ones in `Lua 5.3 <https://www.lua.org/manual/5.3/manual.html#6.5>`_ but Tarantool has much more. For example, because internally Tarantool contains a complete copy of the \"International Components For Unicode\" library, there are comparison functions which understand the default ordering for Cyrillic (Capital Letter Zhe Ж = Small Letter Zhe ж) and Japanese (Hiragana A = Katakana A)."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:29
msgid ":ref:`casecmp <utf8-casecmp>` and |br| :ref:`cmp <utf8-cmp>`"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:29
msgid "Comparisons"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:32
msgid ":ref:`lower <utf8-islower>` and |br| :ref:`upper <utf8-isupper>`"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:32
msgid "Case conversions"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:35
msgid ":ref:`isalpha <utf8-isalpha>`, |br| :ref:`isdigit <utf8-isdigit>`, |br| :ref:`islower <utf8-islower>` and |br| :ref:`isupper <utf8-isupper>`"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:35
msgid "Determine character types"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:40
msgid ":ref:`sub <utf8-sub>`"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:40
msgid "Substrings"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:42
msgid ":ref:`length <utf8-length>`"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:42
msgid "Length in characters"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:44
msgid ":ref:`next <utf8-next>`"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:44
msgid "Character-at-a-time iterations"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:53
#: ../doc/reference/reference_lua/utf8.rst:114
#: ../doc/reference/reference_lua/utf8.rst:235
#: ../doc/reference/reference_lua/utf8.rst:272
#: ../doc/reference/reference_lua/utf8.rst:289
#: ../doc/reference/reference_lua/utf8.rst:348
msgid "a string encoded with UTF-8"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:54
#: ../doc/reference/reference_lua/utf8.rst:115
msgid "-1 meaning \"less\", 0 meaning \"equal\", +1 meaning \"greater\""
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:57
msgid "Compare two strings with the Default Unicode Collation Element Table (DUCET) for the `Unicode Collation Algorithm <http://www.unicode.org/Public/UCA/10.0.0/allkeys.txt>`_. Thus 'å' is less than 'B', even though the code-point value of å (229) is greater than the code-point value of B (66), because the algorithm depends on the values in the Collation Element Table, not the code-point values."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:64
msgid "The comparison is done with primary weights. Therefore the elements which affect secondary or later weights (such as \"case\" in Latin or Cyrillic alphabets, or \"kana differentiation\" in Japanese) are ignored. If asked \"is this like a Microsoft case-insensitive accent-insensitive collation\" we tend to answer \"yes\", though the Unicode Collation Algorithm is far more sophisticated than those terms imply."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:74
msgid "tarantool> utf8.casecmp('é','e'),utf8.casecmp('E','e')\n"
"---\n"
"- 0\n"
"- 0\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:86
msgid "a Unicode code point value, repeatable"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:87
msgid "a UTF-8 string"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:90
msgid "The code-point number is the value that corresponds to a character in the `Unicode Character Database <http://www.unicode.org/Public/5.2.0/ucd/UnicodeData.txt>`_ This is not the same as the byte values of the encoded character, because the UTF-8 encoding scheme is more complex than a simple copy of the code-point number."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:97
msgid "Another way to construct a string with Unicode characters is with the \\\\u{hex-digits} escape mechanism, for example '\\\\u{41}\\\\u{42}' and ``utf8.char(65,66)`` both produce the string 'AB'."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:103
msgid "tarantool> utf8.char(229)\n"
"---\n"
"- å\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:118
msgid "Compare two strings with the Default Unicode Collation Element Table (DUCET) for the `Unicode Collation Algorithm <http://www.unicode.org/Public/UCA/10.0.0/allkeys.txt>`_. Thus 'å' is less than 'B', even though the code-point value of å (229) is greater than the code-point value of B (66), because the algorithm depends on the values in the Collation Element Table, not the code values."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:125
msgid "The comparison is done with at least three weights. Therefore the elements which affect secondary or later weights (such as \"case\" in Latin or Cyrillic alphabets, or \"kana differentiation\" in Japanese) are not ignored. and upper case comes after lower case."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:132
msgid "tarantool> utf8.cmp('é','e'),utf8.cmp('E','e')\n"
"---\n"
"- 1\n"
"- 1\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:144
#: ../doc/reference/reference_lua/utf8.rst:169
#: ../doc/reference/reference_lua/utf8.rst:191
#: ../doc/reference/reference_lua/utf8.rst:213
msgid "a single UTF8 character, expressed as a one-byte string or a code point value"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:149
msgid "Return true if the input character is an \"alphabetic-like\" character, otherwise return false. Generally speaking a character will be considered alphabetic-like provided it is typically used within a word, as opposed to a digit or punctuation. It does not have to be a character in an alphabet."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:156
msgid "tarantool> utf8.isalpha('Ж'),utf8.isalpha('å'),utf8.isalpha('9')\n"
"---\n"
"- true\n"
"- true\n"
"- false\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:174
msgid "Return true if the input character is a digit, otherwise return false."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:178
msgid "tarantool> utf8.isdigit('Ж'),utf8.isdigit('å'),utf8.isdigit('9')\n"
"---\n"
"- false\n"
"- false\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:196
msgid "Return true if the input character is lower case, otherwise return false."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:200
msgid "tarantool> utf8.islower('Ж'),utf8.islower('å'),utf8.islower('9')\n"
"---\n"
"- false\n"
"- true\n"
"- false\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:218
msgid "Return true if the input character is upper case, otherwise return false."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:222
msgid "tarantool> utf8.isupper('Ж'),utf8.isupper('å'),utf8.isupper('9')\n"
"---\n"
"- true\n"
"- false\n"
"- false\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:236
msgid "byte position of the first character"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:237
msgid "byte position where to stop"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:238
msgid "the number of characters in the string, or between start and end"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:241
msgid "Byte positions for start and end can be negative, which indicates \"calculate from end of string\" rather than \"calculate from start of string\"."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:244
msgid "If the string contains a byte sequence which is not valid in UTF-8, each byte in the invalid byte sequence will be counted as one character."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:247
msgid "UTF-8 is a variable-size encoding scheme. Typically a simple Latin letter takes one byte, a Cyrillic letter takes two bytes, a Chinese/Japanese character takes three bytes, and the maximum is four bytes."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:254
msgid "tarantool> utf8.len('G'),utf8.len('ж')\n"
"---\n"
"- 1\n"
"- 1\n"
"...\n"
"\n"
"tarantool> string.len('G'),string.len('ж')\n"
"---\n"
"- 1\n"
"- 2\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:273
msgid "the same string, lower case"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:278
msgid "tarantool> utf8.lower('ÅΓÞЖABCDEFG')\n"
"---\n"
"- åγþжabcdefg\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:290
msgid "byte position where to start within the string, default is 1"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:291
msgid "byte position of the next character and the code point value of the next character"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:294
msgid "The ``next`` function is often used in a loop to get one character at a time from a UTF-8 string."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:299
msgid "In the string 'åa' the first character is 'å', it starts at position 1, it takes two bytes to store so the character after it will be at position 3, its Unicode code point value is (decimal) 229."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:304
msgid "tarantool> -- show next-character position + first-character codepoint\n"
"tarantool> utf8.next('åa', 1)\n"
"---\n"
"- 3\n"
"- 229\n"
"...\n"
"tarantool> -- (loop) show codepoint of every character\n"
"tarantool> for position,codepoint in utf8.next,'åa' do print(codepoint) end\n"
"229\n"
"97\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:322
msgid "a string encoded as UTF-8"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:323
msgid "the position of the first character"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:324
msgid "the position of the last character"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:325
msgid "a UTF-8 string, the \"substring\" of the input value"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:328
msgid "Character positions for start and end can be negative, which indicates \"calculate from end of string\" rather than \"calculate from start of string\"."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:331
msgid "The default value for end-character is the length of the input string. Therefore, saying ``utf8.sub(1, 'abc')`` will return 'abc', the same as the input string."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:337
msgid "tarantool> utf8.sub('åγþжabcdefg', 5, 8)\n"
"---\n"
"- abcd\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:349
msgid "the same string, upper case"
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:354
msgid "In rare cases the upper-case result may be longer than the lower-case input, for example ``utf8.upper('ß')`` is 'SS'."
msgstr ""

#: ../doc/reference/reference_lua/utf8.rst:359
msgid "tarantool> utf8.upper('åγþжabcdefg')\n"
"---\n"
"- ÅΓÞЖABCDEFG\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:3
msgid "Module `uuid`"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:9
msgid "A \"UUID\" is a `Universally unique identifier`_. If an application requires that a value be unique only within a single computer or on a single database, then a simple counter is better than a UUID, because getting a UUID is time-consuming (it requires a syscall_). For clusters of computers, or widely distributed applications, UUIDs are better."
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:19
msgid "Below is list of all ``uuid`` functions and members."
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:29
msgid ":ref:`uuid.nil <uuid-nil>`"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:29
#: ../doc/reference/reference_lua/uuid.rst:54
msgid "A nil object"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:31
msgid ":ref:`uuid() <uuid-__call>` |br| :ref:`uuid.bin() <uuid-bin>` |br| :ref:`uuid.str() <uuid-str>`"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:32
msgid "Get a UUID"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:35
msgid ":ref:`uuid.fromstr() <uuid-fromstr>` |br| :ref:`uuid.frombin() <uuid-frombin>` |br| :ref:`uuid_object:bin() <uuid-object_bin>` |br| :ref:`uuid_object:str() <uuid-object_str>`"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:38
msgid "Get a converted UUID"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:44
msgid ":ref:`uuid_object:isnil() <uuid-isnil>`"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:44
msgid "Check if a UUID is an all-zero value"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:60
#: ../doc/reference/reference_lua/uuid.rst:67
#: ../doc/reference/reference_lua/uuid.rst:74
msgid "a UUID"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:68
msgid "16-byte string"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:75
msgid "36-byte binary string"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:81
msgid "UUID in 36-byte hexadecimal string"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:82
#: ../doc/reference/reference_lua/uuid.rst:90
msgid "converted UUID"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:89
msgid "UUID in 16-byte binary string"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:99
msgid "``byte-order`` can be one of next flags:"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:101
msgid "'l' - little-endian,"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:102
msgid "'b' - big-endian,"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:103
msgid "'h' - endianness depends on host (default),"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:104
msgid "'n' - endianness depends on network"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:106
msgid "one of ``'l'``, ``'b'``, ``'h'`` or ``'n'``."
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:108
#: ../doc/reference/reference_lua/uuid.rst:115
msgid "UUID converted from cdata input value."
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:109
msgid "16-byte binary string"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:116
msgid "36-byte hexadecimal string"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:122
msgid "The all-zero UUID value can be expressed as uuid.NULL, or as ``uuid.fromstr('00000000-0000-0000-0000-000000000000')``. The comparison with an all-zero value can also be expressed as ``uuid_with_type_cdata == uuid.NULL``."
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:127
msgid "true if the value is all zero, otherwise false."
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:128
msgid "bool"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:134
msgid "tarantool> uuid = require('uuid')\n"
"---\n"
"...\n"
"tarantool> uuid(), uuid.bin(), uuid.str()\n"
"---\n"
"- 16ffedc8-cbae-4f93-a05e-349f3ab70baa\n"
"- !!binary FvG+Vy1MfUC6kIyeM81DYw==\n"
"- 67c999d2-5dce-4e58-be16-ac1bcb93160f\n"
"...\n"
"tarantool> uu = uuid()\n"
"---\n"
"...\n"
"tarantool> #uu:bin(), #uu:str(), type(uu), uu:isnil()\n"
"---\n"
"- 16\n"
"- 36\n"
"- cdata\n"
"- false\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/xlog.rst:5
msgid "Module `xlog`"
msgstr ""

#: ../doc/reference/reference_lua/xlog.rst:7
msgid "The xlog module contains one function: ``pairs()``. It can be used to read Tarantool's :ref:`snapshot files<index-box_persistence>` or :ref:`write-ahead-log (WAL) <internals-wal>` files. A description of the file format is in section :ref:`Data persistence and the WAL file format <internals-data_persistence>`."
msgstr ""

#: ../doc/reference/reference_lua/xlog.rst:19
msgid "Open a file, and allow iterating over one file entry at a time."
msgstr ""

#: ../doc/reference/reference_lua/xlog.rst:0
msgid "returns"
msgstr ""

#: ../doc/reference/reference_lua/xlog.rst:21
msgid "iterator  which can be used in a for/end loop."
msgstr ""

#: ../doc/reference/reference_lua/xlog.rst:22
msgid "`iterator <https://www.lua.org/pil/7.1.html>`_"
msgstr ""

#: ../doc/reference/reference_lua/xlog.rst:24
msgid "Possible errors: File does not contain properly formatted snapshot or write-ahead-log information."
msgstr ""

#: ../doc/reference/reference_lua/xlog.rst:29
msgid "This will read the first write-ahead-log (WAL) file that was created in the :ref:`wal_dir <cfg_basic-wal_dir>` directory in our :ref:`\"Getting started\" exercises <getting_started>`."
msgstr ""

#: ../doc/reference/reference_lua/xlog.rst:33
msgid "Each result from ``pairs()`` is formatted with MsgPack so its structure can be specified with :ref:`__serialize <msgpack-serialize>`."
msgstr ""

#: ../doc/reference/reference_lua/xlog.rst:36
msgid "xlog = require('xlog')\n"
"t = {}\n"
"for k, v in xlog.pairs('00000000000000000000.xlog') do\n"
"  table.insert(t, setmetatable(v, { __serialize = \"map\"}))\n"
"end\n"
"return t"
msgstr ""

#: ../doc/reference/reference_lua/xlog.rst:45
msgid "The first lines of the result will look like:"
msgstr ""

#: ../doc/reference/reference_lua/xlog.rst:47
msgid "(...)\n"
"---\n"
"- - {'BODY':   {'space_id': 272, 'index_base': 1, 'key': ['max_id'],\n"
"                'tuple': [['+', 2, 1]]},\n"
"     'HEADER': {'type': 'UPDATE', 'timestamp': 1477846870.8541,\n"
"                'lsn': 1, 'server_id': 1}}\n"
"  - {'BODY':   {'space_id': 280,\n"
"                 'tuple': [512, 1, 'tester', 'memtx', 0, {}, []]},\n"
"     'HEADER': {'type': 'INSERT', 'timestamp': 1477846870.8597,\n"
"                'lsn': 2, 'server_id': 1}}"
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:5
msgid "Module `yaml`"
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:11
msgid "The ``yaml`` module takes strings in YAML_ format and decodes them, or takes a series of non-YAML values and encodes them."
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:18
msgid "Below is a list of all ``yaml`` functions and members."
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:28
msgid ":ref:`yaml.encode() <yaml-encode>`"
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:28
msgid "Convert a Lua object to a YAML string"
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:31
msgid ":ref:`yaml.decode() <yaml-decode>`"
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:31
msgid "Convert a YAML string to a Lua object"
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:34
msgid ":ref:`yaml.NULL <yaml-null>`"
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:44
msgid "Convert a Lua object to a YAML string."
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:47
msgid "the original value reformatted as a YAML string."
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:54
msgid "Convert a YAML string to a Lua object."
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:56
msgid "a string formatted as YAML."
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:70
msgid "tarantool> yaml = require('yaml')\n"
"---\n"
"...\n"
"tarantool> y = yaml.encode({'a', 1, 'b', 2})\n"
"---\n"
"...\n"
"tarantool> z = yaml.decode(y)\n"
"---\n"
"...\n"
"tarantool> z[1], z[2], z[3], z[4]\n"
"---\n"
"- a\n"
"- 1\n"
"- b\n"
"- 2\n"
"...\n"
"tarantool> if yaml.NULL == nil then print('hi') end\n"
"hi\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:93
msgid "The `YAML collection style <http://yaml.org/spec/1.1/#id930798>`_ can be specified with ``__serialize``:"
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:96
msgid "``__serialize=\"sequence\"`` for a Block Sequence array,"
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:97
msgid "``__serialize=\"seq\"`` for a Flow Sequence array,"
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:98
msgid "``__serialize=\"mapping\"`` for a Block Mapping map,"
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:99
msgid "``__serialize=\"map\"`` for a Flow Mapping map."
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:104
msgid "tarantool> yaml = require('yaml')\n"
"---\n"
"...\n"
"tarantool> yaml.encode(setmetatable({'A', 'B'}, { __serialize=\"sequence\"}))\n"
"---\n"
"- |\n"
"  ---\n"
"  - A\n"
"  - B\n"
"  ...\n"
"...\n"
"tarantool> yaml.encode(setmetatable({'A', 'B'}, { __serialize=\"seq\"}))\n"
"---\n"
"- |\n"
"  ---\n"
"  ['A', 'B']\n"
"  ...\n"
"...\n"
"tarantool> yaml.encode({setmetatable({f1 = 'A', f2 = 'B'}, { __serialize=\"map\"})})\n"
"---\n"
"- |\n"
"  ---\n"
"  - {'f2': 'B', 'f1': 'A'}\n"
"  ...\n"
"...\n"
"tarantool> yaml.encode({setmetatable({f1 = 'A', f2 = 'B'}, { __serialize=\"mapping\"})})\n"
"---\n"
"- |\n"
"  ---\n"
"  - f2: B\n"
"    f1: A\n"
"  ...\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:140
msgid "Also, some YAML configuration settings for encoding can be changed, in the same way that they can be changed for :ref:`JSON <json-module_cfg>`."
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:2
msgid "Cartridge Command Line Interface"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:5
#: ../doc/reference/reference_rock/dbms.rst:53
#: ../doc/reference/reference_rock/dbms.rst:406
#: ../doc/reference/reference_rock/vshard/index.rst:57
msgid "Installation"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:10
msgid "tarantoolctl rocks install cartridge-cli"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:11
msgid "Optionally you may add ``.rocks/bin`` to executable path:"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:16
msgid "export PATH=$PWD/.rocks/bin/:$PATH"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:18
msgid "Usage"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:20
msgid "For more details, run"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:25
msgid "cartridge --help"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:27
msgid "Applications lifecycle"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:29
msgid "Create an application from template:"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:34
msgid "cartridge create --name myapp"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:35
msgid "Pack an application into distributable:"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:40
msgid "cartridge pack rpm myapp"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:42
msgid "Managing instances"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:80
msgid "cartridge start [APP_NAME[.INSTANCE_NAME]] [options]\n"
"\n"
"Options\n"
"    --script FILE       Application's entry point.\n"
"                        Default to TARANTOOL_SCRIPT,\n"
"                        or ./init.lua when running from app's directory,\n"
"                        or :apps_path/:app_name/init.lua in multi-app env.\n"
"\n"
"    --apps_path PATH    Path to apps direcrory when running in multi-app env.\n"
"                        Default to /usr/share/tarantool\n"
"\n"
"    --run_dir DIR       Directory with pid and sock files\n"
"                        Default to TARANTOOL_RUN_DIR or /var/run/tarantool\n"
"\n"
"    --cfg FILE          Cartridge instances config file.\n"
"                        Default to TARANTOOL_CFG or ./instances.yml\n"
"\n"
"    --foreground        Do not daemonize"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:65
msgid "It starts tarantool instance in background with enforced env-vars and waits until app’s main script is finished."
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:104
msgid "TARANTOOL_INSTANCE_NAME\n"
"TARANTOOL_CFG\n"
"TARANTOOL_PID_FILE - %run_dir%/%instance_name%.pid\n"
"TARANTOOL_CONSOLE_SOCK - %run_dir%/%instance_name%.pid"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:75
msgid "``cartridge.cfg()`` uses ``TARANTOOL_INSTANCE_NAME`` to read instance’s config from file provided in ``TARANTOOL_CFG``."
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:78
msgid "Default options for ``cartridge`` command can be overriden in ``./.cartridge.yml`` or ``~/.cartridge.yml``:"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:86
msgid "run_dir: tmp/run\n"
"cfg: cartrifge.yml\n"
"apps_path: /usr/local/share/tarantool"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:87
msgid "When APP_NAME is not provided it is parsed from ``./*.rockspec`` filename. When ``INSTANCE_NAME`` is not provided cartridge reads ``cfg`` file and starts all defined instances:"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:127
msgid "# in application directory\n"
"cartridge start # starts all instances\n"
"cartridge start .router_1 # start single instance\n"
"\n"
"# in multi-application environment\n"
"cartridge start app_1 # starts all instances of app_1\n"
"cartridge start app_1.router_1 # start single instance"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:101
msgid "To stop one or more running instances use:"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:139
msgid "cartridge stop [APP_NAME[.INSTANCE_NAME]] [options]\n"
"\n"
"These options from `start` command are supported\n"
"    --run_dir DIR\n"
"    --cfg FILE"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:112
msgid "Misc"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:115
msgid "Running end-to-end tests"
msgstr ""

#: ../doc/reference/reference_rock/cartridge-cli.rst:121
msgid "vagrant up\n"
"vagrant ssh 1_10 < test/end-to-end.sh\n"
"vagrant halt"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:5
msgid "SQL DBMS Modules"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:7
msgid "The discussion here in the reference is about incorporating and using two modules that have already been created: the \"SQL DBMS rocks\" for MySQL and PostgreSQL."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:11
msgid "To call another DBMS from Tarantool, the essential requirements are: another DBMS, and Tarantool. The module which connects Tarantool to another DBMS may be called a \"connector\". Within the module there is a shared library which may be called a \"driver\"."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:16
msgid "Tarantool supplies DBMS connector modules with the module manager for Lua, LuaRocks. So the connector modules may be called \"rocks\"."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:19
msgid "The Tarantool rocks allow for connecting to SQL servers and executing SQL statements the same way that a MySQL or PostgreSQL client does. The SQL statements are visible as Lua methods. Thus Tarantool can serve as a \"MySQL Lua Connector\" or \"PostgreSQL Lua Connector\", which would be useful even if that was all Tarantool could do. But of course Tarantool is also a DBMS, so the module also is useful for any operations, such as database copying and accelerating, which work best when the application can work on both SQL and Tarantool inside the same Lua routine. The methods for connect/select/insert/etc. are similar to the ones in the :ref:`net.box <net_box-module>` module."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:30
msgid "From a user's point of view the MySQL and PostgreSQL rocks are very similar, so the following sections -- \"MySQL Example\" and \"PostgreSQL Example\" -- contain some redundancy."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:38
msgid "MySQL Example"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:40
msgid "This example assumes that MySQL 5.5 or MySQL 5.6 or MySQL 5.7 has been installed. Recent MariaDB versions will also work, the MariaDB C connector is used. The package that matters most is the MySQL client developer package, typically named something like libmysqlclient-dev. The file that matters most from this package is libmysqlclient.so or a similar name. One can use ``find`` or ``whereis`` to see what directories these files are installed in."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:47
msgid "It will be necessary to install Tarantool's MySQL driver shared library, load it, and use it to connect to a MySQL server instance. After that, one can pass any MySQL statement to the server instance and receive results, including multiple result sets."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:55
#: ../doc/reference/reference_rock/dbms.rst:408
msgid "Check the instructions for `downloading and installing a binary package <http://tarantool.org/download.html>`_ that apply for the environment where Tarantool was installed. In addition to installing ``tarantool``, install ``tarantool-dev``. For example, on Ubuntu, add the line:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:61
#: ../doc/reference/reference_rock/dbms.rst:414
msgid "$ sudo apt-get install tarantool-dev"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:65
msgid "Now, for the MySQL driver shared library, there are two ways to install:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:69
#: ../doc/reference/reference_rock/dbms.rst:422
msgid "With LuaRocks"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:71
#: ../doc/reference/reference_rock/dbms.rst:424
msgid "Begin by installing luarocks and making sure that tarantool is among the upstream servers, as in the instructions on `rocks.tarantool.org`_, the Tarantool luarocks page. Now execute this:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:112
msgid "luarocks install mysql [MYSQL_LIBDIR = *path*]\n"
"                       [MYSQL_INCDIR = *path*]\n"
"                       [--local]"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:84
msgid "$ luarocks install mysql MYSQL_LIBDIR=/usr/local/mysql/lib"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:90
#: ../doc/reference/reference_rock/dbms.rst:443
msgid "With GitHub"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:92
msgid "Go the site `github.com/tarantool/mysql`_. Follow the instructions there, saying:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:94
msgid "$ git clone https://github.com/tarantool/mysql.git\n"
"$ cd mysql && cmake . -DCMAKE_BUILD_TYPE=RelWithDebInfo\n"
"$ make\n"
"$ make install"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:101
#: ../doc/reference/reference_rock/dbms.rst:454
msgid "At this point it is a good idea to check that the installation produced a file named ``driver.so``, and to check that this file is on a directory that is searched by the ``require`` request."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:107
#: ../doc/reference/reference_rock/dbms.rst:460
msgid "Connecting"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:109
msgid "Begin by making a ``require`` request for the mysql driver. We will assume that the name is ``mysql`` in further examples."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:112
msgid "mysql = require('mysql')"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:116
#: ../doc/reference/reference_rock/dbms.rst:469
msgid "Now, say:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:155
msgid "*connection_name* = mysql.connect(*connection options*)"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:123
#: ../doc/reference/reference_rock/dbms.rst:476
msgid "The connection-options parameter is a table. Possible options are:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:125
#: ../doc/reference/reference_rock/dbms.rst:478
msgid ":samp:`host = {host-name}` - string, default value = 'localhost'"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:126
msgid ":samp:`port = {port-number}` - number, default value = 3306"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:127
#: ../doc/reference/reference_rock/dbms.rst:480
msgid ":samp:`user = {user-name}` - string, default value is operating-system user name"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:128
msgid ":samp:`password = {password}` - string, default value is blank"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:129
#: ../doc/reference/reference_rock/dbms.rst:482
msgid ":samp:`db = {database-name}` - string, default value is blank"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:130
msgid ":samp:`raise = {true|false}` - boolean, default value is false"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:132
msgid "The option names, except for `raise`, are similar to the names that MySQL's mysql client uses, for details see the MySQL manual at `dev.mysql.com/doc/refman/5.6/en/connecting.html`_. The `raise` option should be set to :codenormal:`true` if errors should be raised when encountered. To connect with a Unix socket rather than with TCP, specify ``host = 'unix/'`` and :samp:`port = {socket-name}`."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:139
#: ../doc/reference/reference_rock/dbms.rst:486
msgid "Example, using a table literal enclosed in {braces}:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:141
msgid "conn = mysql.connect({\n"
"    host = '127.0.0.1',\n"
"    port = 3306,\n"
"    user = 'p',\n"
"    password = 'p',\n"
"    db = 'test',\n"
"    raise = true\n"
"})\n"
"-- OR\n"
"conn = mysql.connect({\n"
"    host = 'unix/',\n"
"    port = '/var/run/mysqld/mysqld.sock'\n"
"})"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:157
#: ../doc/reference/reference_rock/dbms.rst:498
msgid "Example, creating a function which sets each option in a separate line:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:159
msgid "tarantool> -- Connection function. Usage: conn = mysql_connect()\n"
"tarantool> function mysql_connection()\n"
"         >   local p = {}\n"
"         >   p.host = 'widgets.com'\n"
"         >   p.db = 'test'\n"
"         >   conn = mysql.connect(p)\n"
"         >   return conn\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> conn = mysql_connect()\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:175
#: ../doc/reference/reference_rock/dbms.rst:517
msgid "We will assume that the name is 'conn' in further examples."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:179
#: ../doc/reference/reference_rock/dbms.rst:521
msgid "How to ping"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:181
#: ../doc/reference/reference_rock/dbms.rst:523
msgid "To ensure that a connection is working, the request is:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:220
#: ../doc/reference/reference_rock/dbms.rst:562
msgid "*connection-name*:ping()"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:190
#: ../doc/reference/reference_rock/dbms.rst:532
msgid "tarantool> conn:ping()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:199
#: ../doc/reference/reference_rock/dbms.rst:541
msgid "Executing a statement"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:201
msgid "For all MySQL statements, the request is:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:240
#: ../doc/reference/reference_rock/dbms.rst:582
msgid "*connection-name*:execute(*sql-statement* [, *parameters*])"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:208
msgid "where ``sql-statement`` is a string, and the optional ``parameters`` are extra values that can be plugged in to replace any question marks (\"?\"s) in the SQL statement."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:214
msgid "tarantool> conn:execute('select table_name from information_schema.tables')\n"
"---\n"
"- - table_name: ALL_PLUGINS\n"
"  - table_name: APPLICABLE_ROLES\n"
"  - table_name: CHARACTER_SETS\n"
"  <...>\n"
"- 78\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:227
#: ../doc/reference/reference_rock/dbms.rst:568
msgid "Closing connection"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:229
msgid "To end a session that began with ``mysql.connect``, the request is:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:268
#: ../doc/reference/reference_rock/dbms.rst:609
msgid "*connection-name*:close()"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:238
#: ../doc/reference/reference_rock/dbms.rst:579
msgid "tarantool> conn:close()\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:244
msgid "For further information, including examples of rarely-used requests, see the README.md file at `github.com/tarantool/mysql`_."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:251
msgid "The example was run on an Ubuntu 12.04 (\"precise\") machine where tarantool had been installed in a /usr subdirectory, and a copy of MySQL had been installed on ~/mysql-5.5. The mysqld server instance is already running on the local host 127.0.0.1."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:255
msgid "$ export TMDIR=~/mysql-5.5\n"
"$ # Check that the include subdirectory exists by looking\n"
"$ # for .../include/mysql.h. (If this fails, there's a chance\n"
"$ # that it's in .../include/mysql/mysql.h instead.)\n"
"$ [ -f $TMDIR/include/mysql.h ] && echo \"OK\" || echo \"Error\"\n"
"OK\n"
"\n"
"$ # Check that the library subdirectory exists and has the\n"
"$ # necessary .so file.\n"
"$ [ -f $TMDIR/lib/libmysqlclient.so ] && echo \"OK\" || echo \"Error\"\n"
"OK\n"
"\n"
"$ # Check that the mysql client can connect using some factory\n"
"$ # defaults: port = 3306, user = 'root', user password = '',\n"
"$ # database = 'test'. These can be changed, provided one uses\n"
"$ # the changed values in all places.\n"
"$ $TMDIR/bin/mysql --port=3306 -h 127.0.0.1 --user=root \\\n"
"    --password= --database=test\n"
"Welcome to the MySQL monitor.  Commands end with ; or \\g.\n"
"Your MySQL connection id is 25\n"
"Server version: 5.5.35 MySQL Community Server (GPL)\n"
"...\n"
"Type 'help;' or '\\h' for help. Type '\\c' to clear ...\n"
"\n"
"$ # Insert a row in database test, and quit.\n"
"mysql> CREATE TABLE IF NOT EXISTS test (s1 INT, s2 VARCHAR(50));\n"
"Query OK, 0 rows affected (0.13 sec)\n"
"mysql> INSERT INTO test.test VALUES (1,'MySQL row');\n"
"Query OK, 1 row affected (0.02 sec)\n"
"mysql> QUIT\n"
"Bye\n"
"\n"
"$ # Install luarocks\n"
"$ sudo apt-get -y install luarocks | grep -E \"Setting up|already\"\n"
"Setting up luarocks (2.0.8-2) ...\n"
"\n"
"$ # Set up the Tarantool rock list in ~/.luarocks,\n"
"$ # following instructions at rocks.tarantool.org\n"
"$ mkdir ~/.luarocks\n"
"$ echo \"rocks_servers = {[[http://rocks.tarantool.org/]]}\" >> \\\n"
"    ~/.luarocks/config.lua\n"
"\n"
"$ # Ensure that the next \"install\" will get files from Tarantool\n"
"$ # master repository. The resultant display is normal for Ubuntu\n"
"$ # 12.04 precise\n"
"$ cat /etc/apt/sources.list.d/tarantool.list\n"
"deb http://tarantool.org/dist/1.7/ubuntu/ precise main\n"
"deb-src http://tarantool.org/dist/1.7/ubuntu/ precise main\n"
"\n"
"$ # Install tarantool-dev. The displayed line should show version = 1.6\n"
"$ sudo apt-get -y install tarantool-dev | grep -E \"Setting up|already\"\n"
"Setting up tarantool-dev (1.6.6.222.g48b98bb~precise-1) ...\n"
"$\n"
"\n"
"$ # Use luarocks to install locally, that is, relative to $HOME\n"
"$ luarocks install mysql MYSQL_LIBDIR=/usr/local/mysql/lib --local\n"
"Installing http://rocks.tarantool.org/mysql-scm-1.rockspec...\n"
"... (more info about building the Tarantool/MySQL driver appears here)\n"
"mysql scm-1 is now built and installed in ~/.luarocks/\n"
"\n"
"$ # Ensure driver.so now has been created in a place\n"
"$ # tarantool will look at\n"
"$ find ~/.luarocks -name \"driver.so\"\n"
"~/.luarocks/lib/lua/5.1/mysql/driver.so\n"
"\n"
"$ # Change directory to a directory which can be used for\n"
"$ # temporary tests. For this example we assume that the name\n"
"$ # of this directory is /home/pgulutzan/tarantool_sandbox.\n"
"$ # (Change \"/home/pgulutzan\" to whatever is the user's actual\n"
"$ # home directory for the machine that's used for this test.)\n"
"$ cd /home/pgulutzan/tarantool_sandbox\n"
"\n"
"$ # Start the Tarantool server instance. Do not use a Lua initialization file.\n"
"\n"
"$ tarantool\n"
"tarantool: version 1.7.0-222-g48b98bb\n"
"type 'help' for interactive help\n"
"tarantool>"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:336
msgid "Configure tarantool and load mysql module. Make sure that tarantool doesn't reply \"error\" for the call to \"require()\"."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:339
msgid "tarantool> box.cfg{}\n"
"...\n"
"tarantool> mysql = require('mysql')\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:347
msgid "Create a Lua function that will connect to the MySQL server instance, (using some factory default values for the port and user and password), retrieve one row, and display the row. For explanations of the statement types used here, read the Lua tutorial earlier in the Tarantool user manual."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:352
msgid "tarantool> function mysql_select ()\n"
"         >   local conn = mysql.connect({\n"
"         >     host = '127.0.0.1',\n"
"         >     port = 3306,\n"
"         >     user = 'root',\n"
"         >     db = 'test'\n"
"         >   })\n"
"         >   local test = conn:execute('SELECT * FROM test WHERE s1 = 1')\n"
"         >   local row = ''\n"
"         >   for i, card in pairs(test) do\n"
"         >       row = row .. card.s2 .. ' '\n"
"         >       end\n"
"         >   conn:close()\n"
"         >   return row\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> mysql_select()\n"
"---\n"
"- 'MySQL row '\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:376
msgid "Observe the result. It contains \"MySQL row\". So this is the row that was inserted into the MySQL database. And now it's been selected with the Tarantool client."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:383
msgid "PostgreSQL Example"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:385
msgid "This example assumes that PostgreSQL 8 or PostgreSQL 9 has been installed. More recent versions should also work. The package that matters most is the PostgreSQL developer package, typically named something like libpq-dev. On Ubuntu this can be installed with:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:390
msgid "$ sudo apt-get install libpq-dev"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:394
msgid "However, because not all platforms are alike, for this example the assumption is that the user must check that the appropriate PostgreSQL files are present and must explicitly state where they are when building the Tarantool/PostgreSQL driver. One can use ``find`` or ``whereis`` to see what directories PostgreSQL files are installed in."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:400
msgid "It will be necessary to install Tarantool's PostgreSQL driver shared library, load it, and use it to connect to a PostgreSQL server instance. After that, one can pass any PostgreSQL statement to the server instance and receive results."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:418
msgid "Now, for the PostgreSQL driver shared library, there are two ways to install:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:465
msgid "luarocks install pg [POSTGRESQL_LIBDIR = *path*]\n"
"                    [POSTGRESQL_INCDIR = *path*]\n"
"                    [--local]"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:437
msgid "$ luarocks install pg POSTGRESQL_LIBDIR=/usr/local/postgresql/lib"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:445
msgid "Go the site `github.com/tarantool/pg`_. Follow the instructions there, saying:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:447
msgid "$ git clone https://github.com/tarantool/pg.git\n"
"$ cd pg && cmake . -DCMAKE_BUILD_TYPE=RelWithDebInfo\n"
"$ make\n"
"$ make install"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:462
msgid "Begin by making a ``require`` request for the pg driver. We will assume that the name is ``pg`` in further examples."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:465
msgid "pg = require('pg')"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:508
msgid "*connection_name* = pg.connect(*connection options*)"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:479
msgid ":samp:`port = {port-number}` - number, default value = 5432"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:481
msgid ":samp:`pass = {password}` or :samp:`password = {password}` - string, default value is blank"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:484
msgid "The names are similar to the names that PostgreSQL itself uses."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:488
msgid "conn = pg.connect({\n"
"    host = '127.0.0.1',\n"
"    port = 5432,\n"
"    user = 'p',\n"
"    password = 'p',\n"
"    db = 'test'\n"
"})"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:500
msgid "tarantool> function pg_connect()\n"
"         >   local p = {}\n"
"         >   p.host = 'widgets.com'\n"
"         >   p.db = 'test'\n"
"         >   p.user = 'postgres'\n"
"         >   p.password = 'postgres'\n"
"         >   local conn = pg.connect(p)\n"
"         >   return conn\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> conn = pg_connect()\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:543
msgid "For all PostgreSQL statements, the request is:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:550
msgid "where ``sql-statement`` is a string, and the optional ``parameters`` are extra values that can be plugged in to replace any placeholders ($1 $2 $3 etc.) in the SQL statement."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:556
msgid "tarantool> conn:execute('select tablename from pg_tables')\n"
"---\n"
"- - tablename: pg_statistic\n"
"  - tablename: pg_type\n"
"  - tablename: pg_authid\n"
"  <...>\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:570
msgid "To end a session that began with ``pg.connect``, the request is:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:585
msgid "For further information, including examples of rarely-used requests, see the README.md file at `github.com/tarantool/pg`_."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:592
msgid "The example was run on an Ubuntu 12.04 (\"precise\") machine where tarantool had been installed in a /usr subdirectory, and a copy of PostgreSQL had been installed on /usr. The PostgreSQL server instance is already running on the local host 127.0.0.1."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:596
msgid "$ # Check that the include subdirectory exists\n"
"$ # by looking for /usr/include/postgresql/libpq-fe-h.\n"
"$ [ -f /usr/include/postgresql/libpq-fe.h ] && echo \"OK\" || echo \"Error\"\n"
"OK\n"
"\n"
"$ # Check that the library subdirectory exists and has the necessary .so file.\n"
"$ [ -f /usr/lib/x86_64-linux-gnu/libpq.so ] && echo \"OK\" || echo \"Error\"\n"
"OK\n"
"\n"
"$ # Check that the psql client can connect using some factory defaults:\n"
"$ # port = 5432, user = 'postgres', user password = 'postgres',\n"
"$ # database = 'postgres'. These can be changed, provided one changes\n"
"$ # them in all places. Insert a row in database postgres, and quit.\n"
"$ psql -h 127.0.0.1 -p 5432 -U postgres -d postgres\n"
"Password for user postgres:\n"
"psql (9.3.10)\n"
"SSL connection (cipher: DHE-RSA-AES256-SHA, bits: 256)\n"
"Type \"help\" for help.\n"
"\n"
"postgres=# CREATE TABLE test (s1 INT, s2 VARCHAR(50));\n"
"CREATE TABLE\n"
"postgres=# INSERT INTO test VALUES (1,'PostgreSQL row');\n"
"INSERT 0 1\n"
"postgres=# \\q\n"
"$\n"
"\n"
"$ # Install luarocks\n"
"$ sudo apt-get -y install luarocks | grep -E \"Setting up|already\"\n"
"Setting up luarocks (2.0.8-2) ...\n"
"\n"
"$ # Set up the Tarantool rock list in ~/.luarocks,\n"
"$ # following instructions at rocks.tarantool.org\n"
"$ mkdir ~/.luarocks\n"
"$ echo \"rocks_servers = {[[http://rocks.tarantool.org/]]}\" >> \\\n"
"        ~/.luarocks/config.lua\n"
"\n"
"$ # Ensure that the next \"install\" will get files from Tarantool master\n"
"$ # repository. The resultant display is normal for Ubuntu 12.04 precise\n"
"$ cat /etc/apt/sources.list.d/tarantool.list\n"
"deb http://tarantool.org/dist/1.7/ubuntu/ precise main\n"
"deb-src http://tarantool.org/dist/1.7/ubuntu/ precise main\n"
"\n"
"$ # Install tarantool-dev. The displayed line should show version = 1.7\n"
"$ sudo apt-get -y install tarantool-dev | grep -E \"Setting up|already\"\n"
"Setting up tarantool-dev (1.7.0.222.g48b98bb~precise-1) ...\n"
"$\n"
"\n"
"$ # Use luarocks to install locally, that is, relative to $HOME\n"
"$ luarocks install pg POSTGRESQL_LIBDIR=/usr/lib/x86_64-linux-gnu --local\n"
"Installing http://rocks.tarantool.org/pg-scm-1.rockspec...\n"
"... (more info about building the Tarantool/PostgreSQL driver appears here)\n"
"pg scm-1 is now built and installed in ~/.luarocks/\n"
"\n"
"$ # Ensure driver.so now has been created in a place\n"
"$ # tarantool will look at\n"
"$ find ~/.luarocks -name \"driver.so\"\n"
"~/.luarocks/lib/lua/5.1/pg/driver.so\n"
"\n"
"$ # Change directory to a directory which can be used for\n"
"$ # temporary tests. For this example we assume that the\n"
"$ # name of this directory is $HOME/tarantool_sandbox.\n"
"$ # (Change \"$HOME\" to whatever is the user's actual\n"
"$ # home directory for the machine that's used for this test.)\n"
"cd $HOME/tarantool_sandbox\n"
"\n"
"$ # Start the Tarantool server instance. Do not use a Lua initialization file.\n"
"\n"
"$ tarantool\n"
"tarantool: version 1.7.0-412-g803b15c\n"
"type 'help' for interactive help\n"
"tarantool>"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:670
msgid "Configure tarantool and load pg module. Make sure that tarantool doesn't reply \"error\" for the call to \"require()\"."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:673
msgid "tarantool> box.cfg{}\n"
"...\n"
"tarantool> pg = require('pg')\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:681
msgid "Create a Lua function that will connect to a PostgreSQL server, (using some factory default values for the port and user and password), retrieve one row, and display the row. For explanations of the statement types used here, read the Lua tutorial earlier in the Tarantool user manual."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:686
msgid "tarantool> function pg_select ()\n"
"         >   local conn = pg.connect({\n"
"         >     host = '127.0.0.1',\n"
"         >     port = 5432,\n"
"         >     user = 'postgres',\n"
"         >     password = 'postgres',\n"
"         >     db = 'postgres'\n"
"         >   })\n"
"         >   local test = conn:execute('SELECT * FROM test WHERE s1 = 1')\n"
"         >   local row = ''\n"
"         >   for i, card in pairs(test) do\n"
"         >       row = row .. card.s2 .. ' '\n"
"         >       end\n"
"         >   conn:close()\n"
"         >   return row\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> pg_select()\n"
"---\n"
"- 'PostgreSQL row '\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:711
msgid "Observe the result. It contains \"PostgreSQL row\". So this is the row that was inserted into the PostgreSQL database. And now it's been selected with the Tarantool client."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:5
msgid "Module `expirationd`"
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:7
msgid "For a commercial-grade example of a Lua rock that works with Tarantool, let us look at the source code of ``expirationd``, which Tarantool supplies on GitHub_ with an Artistic license. The ``expirationd.lua`` program is lengthy (about 500 lines), so here we will only highlight the matters that will be enhanced by studying the full source later."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:13
msgid "task.worker_fiber = fiber.create(worker_loop, task)\n"
"log.info(\"expiration: task %q restarted\", task.name)\n"
"...\n"
"fiber.sleep(expirationd.constants.check_interval)\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:21
msgid "Whenever one hears \"daemon\" in Tarantool, one should suspect it's being done with a :doc:`fiber<../reference_lua/fiber>`. The program is making a fiber and turning control over to it so it runs occasionally, goes to sleep, then comes back for more."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:26
msgid "for _, tuple in scan_space.index[0]:pairs(nil, {iterator = box.index.ALL}) do\n"
"...\n"
"    expiration_process(task, tuple)\n"
"...\n"
"    /* expiration_process() contains:\n"
"    if task.is_tuple_expired(task.args, tuple) then\n"
"    task.expired_tuples_count = task.expired_tuples_count + 1\n"
"    task.process_expired_tuple(task.space_id, task.args, tuple) */"
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:37
msgid "The \"for\" instruction can be translated as \"iterate through the index of the space that is being scanned\", and within it, if the tuple is \"expired\" (for example, if the tuple has a timestamp field which is less than the current time), process the tuple as an expired tuple."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:42
msgid "-- default process_expired_tuple function\n"
"local function default_tuple_drop(space_id, args, tuple)\n"
"    box.space[space_id]:delete(construct_key(space_id, tuple))\n"
"end\n"
"    /* construct_key() contains:\n"
"    local function construct_key(space_id, tuple)\n"
"        return fun.map(\n"
"            function(x) return tuple[x.fieldno] end,\n"
"           box.space[space_id].index[0].parts\n"
"        ):totable()\n"
"    end */"
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:56
msgid "Ultimately the tuple-expiry process leads to ``default_tuple_drop()`` which does a \"delete\" of a tuple from its original space. First the fun :ref:`fun <fun-module>` module is used, specifically fun.map_. Remembering that :codenormal:`index[0]` is always the space's primary key, and :codenormal:`index[0].parts[`:codeitalic:`N`:codenormal:`].fieldno` is always the field number for key part :codeitalic:`N`, fun.map() is creating a table from the primary-key values of the tuple. The result of fun.map() is passed to :ref:`space_object:delete() <box_space-delete>`."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:66
msgid "local function expirationd_run_task(name, space_id, is_tuple_expired, options)\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:71
msgid "At this point, if the above explanation is worthwhile, it is clear that ``expirationd.lua`` starts a background routine (fiber) which iterates through all the tuples in a space, sleeps cooperatively so that other fibers can operate at the same time, and -- whenever it finds a tuple that has expired -- deletes it from this space. Now the \"``expirationd_run_task()``\" function can be used in a test which creates sample data, lets the daemon run for a while, and prints results."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:80
msgid "For those who like to see things run, here are the exact steps to get ``expirationd`` through the test."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:83
msgid "Get ``expirationd.lua``. There are standard ways -- it is after all part of a `standard rock <https://luarocks.org/modules/rtsisyk/expirationd>`_ -- but for this purpose just copy the contents of ``expirationd.lua`` to a directory on the Lua path (type ``print(package.path)`` to see the Lua path)."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:88
msgid "Start the Tarantool server as described before."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:89
msgid "Execute these requests:"
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:91
msgid "fiber = require('fiber')\n"
"expd = require('expirationd')\n"
"box.cfg{}\n"
"e = box.schema.space.create('expirationd_test')\n"
"e:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
"e:replace{1, fiber.time() + 3}\n"
"e:replace{2, fiber.time() + 30}\n"
"function is_tuple_expired(args, tuple)\n"
"  if (tuple[2] < fiber.time()) then return true end\n"
"  return false\n"
"  end\n"
"expd.run_task('expirationd_test', e.id, is_tuple_expired)\n"
"retval = {}\n"
"fiber.sleep(2)\n"
"expd.task_stats()\n"
"fiber.sleep(2)\n"
"expd.task_stats()\n"
"expd.kill_task('expirationd_test')\n"
"e:drop()\n"
"os.exit()"
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:114
msgid "The database-specific requests (``cfg``, :ref:`space.create <box_schema-space_create>`, :ref:`create_index <box_space-create_index>`) should already be familiar."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:119
msgid "The function which will be supplied to ``expirationd`` is :codenormal:`is_tuple_expired`, which is saying \"if the second field of the tuple is less than the :ref:`current time <fiber-time>`  , then return true, otherwise return false\"."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:124
msgid "The key for getting the rock rolling is ``expd = require('expirationd')``. The require_ function is what reads in the program; it will appear in many later examples in this manual, when it's necessary to get a module that's not part of the Tarantool kernel, but is on the Lua path (``package.path``) or the C path (``package.cpath``). After the Lua variable expd has been assigned the value of the ``expirationd`` module, it's possible to invoke the module's ``run_task()`` function."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:133
msgid "After :ref:`sleeping <fiber-sleep>` for two seconds, when the task has had time to do its iterations through the spaces, ``expd.task_stats()`` will print out a report showing how many tuples have expired -- \"expired_count: 0\"."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:138
msgid "After sleeping for two more seconds, ``expd.task_stats()`` will print out a report showing how many tuples have expired -- \"expired_count: 1\". This shows that the ``is_tuple_expired()`` function eventually returned \"true\" for one of the tuples, because its timestamp field was more than three seconds old."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:145
msgid "Of course, ``expirationd`` can be customized to do different things by passing different parameters, which will be evident after looking in more detail at the source code. Particularly important are ``{options}`` which can be added as a final parameter in ``expirationd.run_task``:"
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:150
msgid "``force`` (boolean) -- run task even on replica. Default: ``force=false`` so ordinarily ``expirationd`` ignores replicas."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:152
msgid "``tuples_per_iteration`` (integer) -- number of tuples that will be checked by one iteration Default: ``tuples_per_iteration=1024``."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:155
msgid "``full_scan_time`` (number) -- number of seconds required for full index scan Default: ``full_scan_time=3600``."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:157
msgid "``vinyl_assumed_space_len`` (integer) -- assumed size of vinyl space, for the first iteration only. Default: ``vinyl_assumed_space_len=10000000``."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:160
msgid "``vinyl_assumed_space_len_factor`` (integer) -- factor for recalculation of size of vinyl space. Default: ``vinyl_assumed_space_len_factor=2``. (The size of a vinyl space cannot be easily calculated, so on the first iteration it will be the \"assumed\" size, on the second iteration it will be \"assumed\" times \"factor\", on the third iteration it will be \"assumed\" times \"factor\" times factor\", and so on.)"
msgstr ""

#: ../doc/reference/reference_rock/index.rst:3
msgid "Rocks reference"
msgstr ""

#: ../doc/reference/reference_rock/index.rst:5
msgid "This reference covers third-party Lua modules for Tarantool."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:5
msgid "Module `membership`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:7
msgid "This module is a ``membership`` library for Tarantool based on a gossip protocol."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:9
msgid "This library builds a mesh from multiple Tarantool instances. The mesh monitors itself, helps members discover everyone else in the group and get notified about their status changes with low latency. It is built upon the ideas from Consul or, more precisely, the SWIM algorithm."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:14
msgid "The ``membership`` module works over UDP protocol and can operate even before the ``box.cfg`` initialization."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:21
msgid "Member data structure"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:23
msgid "A member is represented by the table with the following fields:"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:25
msgid "``uri`` (string) is a Uniform Resource Identifier."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:26
msgid "``status`` (string) is a string that takes one of the values below."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:28
msgid "``alive``: a member that replies to ping-messages is ``alive`` and well."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:29
msgid "``suspect``: if any member in the group cannot get a reply from any other member, the first member asks three other ``alive`` members to send a ping-message to the member in question. If there is no response, the latter becomes a ``suspect``."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:33
msgid "``dead``: a ``suspect`` becomes ``dead`` after a timeout."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:34
msgid "``left``: a member gets the ``left`` status after executing the :ref:`leave() <membership-leave>` function."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:37
msgid "The gossip protocol guarantees that every member in the group becomes aware of any status change in two communication cycles."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:40
msgid "``incarnation`` (number) is a value incremented every time the instance is becomes a ``suspect``, ``dead``, or updates its payload."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:42
msgid "``payload`` (table) is auxiliary data that can be used by various modules."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:43
msgid "``timestamp`` (number) is a value of ``fiber.time64()`` which:"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:45
msgid "corresponds to the last update of ``status`` or ``incarnation``;"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:46
msgid "is always local;"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:47
msgid "does not depend on other members' clock setting."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:49
msgid "Below is an example of the table:"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:51
msgid "tarantool> membership.myself()\n"
"---\n"
"uri: localhost:33001\n"
"status: alive\n"
"incarnation: 1\n"
"payload:\n"
"    uuid: 2d00c500-2570-4019-bfcc-ab25e5096b73\n"
"timestamp: 1522427330993752\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:67
#: ../doc/reference/reference_rock/vshard/index.rst:1174
msgid "API reference"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:69
msgid "Below is a list of ``membership``'s common, encryption, subscription functions, and options."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:80
msgid "Common functions"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:82
msgid ":ref:`init(advertise_host, port) <membership-init>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:82
msgid "Initialize the ``membership`` module."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:85
msgid ":ref:`myself() <membership-myself>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:85
msgid "Get the member data structure of the current instance."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:88
msgid ":ref:`get_member(uri) <membership-get-member>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:88
msgid "Get the member data structure for a given URI."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:91
msgid ":ref:`members() <membership-members>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:91
msgid "Obtain a table with all members known to the current instance."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:94
msgid ":ref:`pairs() <membership-pairs>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:94
msgid "Shorthand for ``pairs(membership.members())``."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:97
msgid ":ref:`add_member(uri) <membership-add-member>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:97
msgid "Add a member to the group."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:100
msgid ":ref:`probe_uri(uri) <membership-probe-uri>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:100
msgid "Check if the member is in the group."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:103
msgid ":ref:`broadcast() <membership-broadcast>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:103
msgid "Discover members in LAN by sending a UDP broadcast message."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:106
msgid ":ref:`set_payload(key, value) <membership-set-payload>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:106
msgid "Update ``myself().payload`` and disseminate it."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:109
msgid ":ref:`leave() <membership-leave>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:109
msgid "Gracefully leave the group."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:112
msgid ":ref:`is_encrypted() <membership-is-encrypted>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:112
msgid "Check if encryption is enabled."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:115
msgid "Encryption functions"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:117
msgid ":ref:`set_encryption_key(key) <membership-set-enc-key>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:117
msgid "Set the key for low-level message encryption."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:120
msgid ":ref:`get_encryption_key() <membership-get-enc-key>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:120
msgid "Retrieve the encryption key in use."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:123
msgid "Subscription functions"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:125
msgid ":ref:`subscribe() <membership-subscribe>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:125
msgid "Subscribe for the members table updates."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:128
msgid ":ref:`unsubscribe() <membership-unsubscribe>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:128
msgid "Remove the subscription."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:131
msgid "Options"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:133
msgid ":ref:`PROTOCOL_PERIOD_SECONDS <membership-protocol_period_seconds>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:133
msgid "Direct ping period."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:136
msgid ":ref:`ACK_TIMEOUT_SECONDS <membership-ack_timeout_seconds>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:136
msgid "ACK message wait time."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:139
msgid ":ref:`ANTI_ENTROPY_PERIOD_SECONDS <member-anti_entropy_period_seconds>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:139
msgid "Anti-entropy synchronization period."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:142
msgid ":ref:`SUSPECT_TIMEOUT_SECONDS <membership-suspect_timeout_seconds>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:142
msgid "Timeout to mark a ``suspect`` ``dead``."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:145
msgid ":ref:`NUM_FAILURE_DETECTION_SUBGROUPS <membership-num_fail_detect_subgr>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:145
msgid "Number of members to ping a ``suspect`` indirectly."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:152
msgid "Common functions:"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:158
msgid "Initialize the ``membership`` module. This binds a UDP socket to ``0.0.0.0:<port>``, sets the ``advertise_uri`` parameter to ``<advertise_host>:<port>``, and ``incarnation`` to ``1``."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:162
msgid "The ``init()`` function can be called several times, the old socket will be closed and a new one opened."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:165
msgid "If the ``advertise_uri`` changes during the next ``init()``, the old URI is considered ``DEAD``. In order to leave the group gracefully, use the :ref:`leave() <membership-leave>` function."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:169
msgid "a hostname or IP address to advertise to other members"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:170
msgid "a UDP port to bind"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:171
#: ../doc/reference/reference_rock/membership.rst:267
#: ../doc/reference/reference_rock/membership.rst:277
msgid "``true``"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
#: ../doc/reference/reference_rock/membership.rst:0
msgid "raises"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:173
msgid "socket bind error"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:179
msgid "the :ref:`member data structure <membership-datastruct>` of the current instance."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:187
msgid "the given member's ``advertise_uri``"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:188
msgid "the :ref:`member data structure <membership-datastruct>` of the instance with the given URI."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:196
msgid "Obtain all members known to the current instance."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:198
msgid "Editing this table has no effect."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:200
msgid "a table with URIs as keys and corresponding :ref:`member data structures <membership-datastruct>` as values."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:209
msgid "A shorthand for ``pairs(membership.members())``."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:211
msgid "Lua iterator"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:213
msgid "It can be used in the following way:"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:215
msgid "for uri, member in memberhip.pairs()\n"
"  -- do something\n"
"end"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:225
msgid "Add a member with the given URI to the group and propagate this event to other members. Adding a member to a single instance is enough as everybody else in the group will receive the update with time. It does not matter who adds whom."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:230
msgid "the ``advertise_uri`` of the member to add"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:231
msgid "``true`` or ``nil`` in case of an error"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:233
msgid "parse error if the URI cannot be parsed"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:239
msgid "Send a message to a member to make sure it is in the group. If the member is ``alive`` but not in the group, it is added. If it already is in the group, nothing happens."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:242
msgid "the ``advertise_uri`` of the member to ping"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:243
msgid "``true`` if the member responds within 0.2 seconds, otherwise ``no response``"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:245
msgid "``ping was not sent`` if the hostname could not be resolved"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:251
msgid "Discover members in local network by sending a UDP broadcast message to all networks discovered by a ``getifaddrs()`` C call."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:254
msgid "``true`` if broadcast was sent, ``false`` if ``getaddrinfo()`` fails."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:261
msgid "Update ``myself().payload`` and disseminate it along with the member status."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:263
msgid "Increments ``incarnation``."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:265
msgid "a key to set in payload table"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:266
msgid "auxiliary data"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:274
msgid "Gracefully leave the ``membership`` group. The node will be marked with the ``left`` status and no other members will ever try to reconnect it."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:284
msgid "``true`` if encryption is enabled, ``false`` otherwise."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:287
msgid "Encryption functions:"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:293
msgid "Set the key used for low-level message encryption. The key is either trimmed or padded automatically to be exactly 32 bytes. If the ``key`` value is ``nil``, the encryption is disabled."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:297
msgid "The encryption is handled by the ``crypto.cipher.aes256.cbc`` Tarantool module."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:300
msgid "For proper communication, all members must be configured to use the same encryption key. Otherwise, members report either ``dead`` or ``non-decryptable`` in their status."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:304
msgid "encryption key"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:305
#: ../doc/reference/reference_rock/membership.rst:336
msgid "``nil``."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:311
msgid "Retrieve the encryption key that is currently in use."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:313
msgid "encryption key or ``nil`` if the encryption is disabled."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:316
msgid "Subscription functions:"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:322
msgid "Subscribe for updates in the members table."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:324
msgid "a ``fiber.cond`` object broadcasted whenever the members table changes."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:325
msgid "object"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:331
msgid "Remove subscription on ``cond`` obtained by the :ref:`subscribe() function <membership-subscribe>`."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:333
msgid "The ``cond``'s validity is not checked."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:335
msgid "the ``fiber.cond`` object obtained from :ref:`subscribe() <membership-subscribe>`"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:338
msgid "Below is a list of ``membership`` options. They can be set as follows:"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:340
msgid "options = require('membership.options')\n"
"options.<option> = <value>"
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:349
msgid "Period of sending direct pings. Denoted as ``T'`` in the SWIM protocol."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:355
msgid "Time to wait for ACK message after a ping. If a member is late to reply, the indirect ping algorithm is invoked."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:362
msgid "Period to perform the anti-entropy synchronization algorithm of the SWIM protocol."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:369
msgid "Timeout to mark ``suspect`` members as ``dead``."
msgstr ""

#: ../doc/reference/reference_rock/membership.rst:375
msgid "Number of members to try pinging a ``suspect`` indirectly. Denoted as ``k`` in the SWIM protocol."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:5
msgid "Module `shard`"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:9
msgid "With sharding, the tuples of a tuple set are distributed to multiple nodes, with a Tarantool database server instance on each node. With this arrangement, each instance is handling only a subset of the total data, so larger loads can be handled by simply adding more computers to a network."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:14
msgid "The Tarantool `shard` module has facilities for creating shards, as well as analogues for the data-manipulation functions of the box library (select, insert, replace, update, delete)."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:18
msgid "First some terminology:"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:21
msgid "**Consistent hash**"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:23
msgid "The `shard` module distributes according to a hash algorithm, that is, it applies a hash function to a tuple's primary-key value in order to decide which shard the tuple belongs to. The hash function is `consistent <https://en.wikipedia.org/wiki/Consistent_hashing>`_ so that changing the number of servers will not affect results for many keys. The specific hash function that the `shard` module uses is :ref:`digest.guava <digest-guava>` in the :codeitalic:`digest` module."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:30
msgid "**Instance**"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:32
msgid "A currently-running in-memory copy of the Tarantool server, sometimes called a \"server instance\". Usually each shard is associated with one instance, or, if both sharding and replicating are going on, each shard is associated with one replica set."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:36
msgid "**Queue**"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:38
msgid "A temporary list of recent update requests. Sometimes called \"batching\". Since updates to a sharded database can be slow, it may speed up throughput to send requests to a queue rather than wait for the update to finish on every node. The `shard` module has functions for adding requests to the queue, which it will process without further intervention. Queuing is optional."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:44
msgid "**Redundancy**"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:46
msgid "The number of replicated data copies in each shard."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:47
#: ../doc/reference/reference_rock/vshard/index.rst:2089
msgid "**Replica**"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:49
msgid "An instance which is part of a replica set."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:50
#: ../doc/reference/reference_rock/vshard/index.rst:2078
msgid "**Replica set**"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:52
msgid "Often a single shard is associated with a single instance; however, often the shard is replicated. When a shard is replicated, the multiple instances (\"replicas\"), which handle the shard's replicated data, are a \"replica set\"."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:56
msgid "**Replicated data**"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:58
msgid "A complete copy of the data. The `shard` module handles both sharding and replication. One shard can contain one or more replicated data copies. When a write occurs, the write is attempted on every replicated data copy in turn. The `shard` module does not use the built-in replication feature."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:62
msgid "**Shard**"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:64
msgid "A subset of the tuples in the database partitioned according to the value returned by the consistent hash function. Usually each shard is on a separate node, or a separate set of nodes (for example if redundancy = 3 then the shard will be on three nodes)."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:68
msgid "**Zone**"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:70
msgid "A physical location where the nodes are closely connected, with the same security and backup and access points. The simplest example of a zone is a single computer with a single Tarantool-server instance. A shard's replicated data copies should be in different zones."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:75
msgid "The `shard` package is distributed separately from the main `tarantool` package. To acquire it, do a separate installation:"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:78
msgid "with Tarantool 1.7.4+, say:"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:80
msgid "$ tarantoolctl rocks install shard"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:84
msgid "install with `yum` or `apt`, for example on Ubuntu say:"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:86
msgid "$ sudo apt-get install tarantool-shard"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:90
msgid "or download from GitHub `tarantool/shard` and use the Lua files as described in the `README <https://github.com/tarantool/shard>`_."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:93
msgid "Then, before using the module, say ``shard = require('shard')``."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:95
msgid "The most important function is:"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:134
msgid "shard.init(*shard-configuration*)"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:102
msgid "This must be called for every shard."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:104
msgid "The shard configuration is a table with these fields:"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:106
msgid "`servers` (a list of URIs of nodes and the zones the nodes are in)"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:107
msgid "`login` (the user name which applies for accessing via the `shard` module)"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:108
msgid "`password` (the password for the login)"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:109
msgid "`redundancy` (a number, minimum 1)"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:110
msgid "`binary` (a port number that this host is listening on, on the current host, (distinguishable from the 'listen' port specified by `box.cfg`)"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:113
msgid "Possible errors:"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:115
msgid "redundancy should not be greater than the number of servers;"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:116
msgid "the servers must be alive;"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:117
msgid "two replicated data copies of the same shard should not be in the same zone."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:121
msgid "Example: `shard.init` syntax for one shard"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:123
msgid "The number of replicated data copies per shard (redundancy) is 3."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:124
msgid "The number of instances is 3."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:125
msgid "The `shard` module will conclude that there is only one shard."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:127
msgid "tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'localhost:33131', zone = '1' },\n"
"         >     { uri = 'localhost:33132', zone = '2' },\n"
"         >     { uri = 'localhost:33133', zone = '3' }\n"
"         >   },\n"
"         >   login = 'test_user',\n"
"         >   password = 'pass',\n"
"         >   redundancy = '3',\n"
"         >   binary = 33131,\n"
"         > }\n"
"---\n"
"...\n"
"tarantool> shard.init(cfg)\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:148
msgid "Example: `shard.init` syntax for three shards"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:150
msgid "This describes three shards. Each shard has two replicated data copies. Since the number of servers is 7, and the number of replicated data copies per shard is 2, and dividing 7 / 2 leaves a remainder of 1, one of the servers will not be used. This is not necessarily an error, because perhaps one of the servers in the list is not alive."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:155
msgid "tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'host1:33131', zone = '1' },\n"
"         >     { uri = 'host2:33131', zone = '2' },\n"
"         >     { uri = 'host3:33131', zone = '3' },\n"
"         >     { uri = 'host4:33131', zone = '4' },\n"
"         >     { uri = 'host5:33131', zone = '5' },\n"
"         >     { uri = 'host6:33131', zone = '6' },\n"
"         >     { uri = 'host7:33131', zone = '7' }\n"
"         >   },\n"
"         >   login = 'test_user',\n"
"         >   password = 'pass',\n"
"         >   redundancy = '2',\n"
"         >   binary = 33131,\n"
"         > }\n"
"---\n"
"...\n"
"tarantool> shard.init(cfg)\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:178
msgid "Every data-access function in the `box` module has an analogue in the `shard` module:"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:218
msgid "shard[*space-name*].insert{...}\n"
"shard[*space-name*].replace{...}\n"
"shard[*space-name*].delete{...}\n"
"shard[*space-name*].select{...}\n"
"shard[*space-name*].update{...}\n"
"shard[*space-name*].auto_increment{...}"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:191
msgid "For example, to insert in table T in a sharded database you simply say ``shard.T:insert{...}`` instead of ``box.space.T:insert{...}``."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:194
msgid "A ``shard.T:select{}`` request without a primary key will cause an error."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:196
msgid "Every queued data-access function has an analogue in the `shard` module:"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:235
msgid "shard[*space-name*].q_insert{...}\n"
"shard[*space-name*].q_replace{...}\n"
"shard[*space-name*].q_delete{...}\n"
"shard[*space-name*].q_select{...}\n"
"shard[*space-name*].q_update{...}\n"
"shard[*space-name*].q_auto_increment{...}"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:208
msgid "The user must add an `operation_id`. For details of queued data-access functions, and of maintenance-related functions, see the `README <https://github.com/tarantool/shard>`_."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:214
msgid "Example: shard, minimal configuration"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:216
msgid "There is only one shard, and that shard contains only one replicated data copy. So this isn't illustrating the features of either replication or sharding, it's only illustrating what the syntax is, and what the messages look like, that anyone could duplicate in a minute or two with the magic of cut-and-paste."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:222
msgid "$ mkdir ~/tarantool_sandbox_1\n"
"$ cd ~/tarantool_sandbox_1\n"
"$ rm -r *.snap\n"
"$ rm -r *.xlog\n"
"$ ~/tarantool-1.7/src/tarantool\n"
"\n"
"tarantool> box.cfg{listen = 3301}\n"
"tarantool> box.schema.space.create('tester')\n"
"tarantool> box.space.tester:create_index('primary', {})\n"
"tarantool> box.schema.user.create('test_user', {password = 'pass'})\n"
"tarantool> box.schema.user.grant('test_user', 'read,write,execute', 'universe')\n"
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >       { uri = 'localhost:3301', zone = '1' },\n"
"         >   },\n"
"         >   login = 'test_user';\n"
"         >   password = 'pass';\n"
"         >   redundancy = 1;\n"
"         >   binary = 3301;\n"
"         > }\n"
"tarantool> shard = require('shard')\n"
"tarantool> shard.init(cfg)\n"
"tarantool> -- Now put something in ...\n"
"tarantool> shard.tester:insert{1,'Tuple #1'}"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:249
msgid "If you cut and paste the above, then the result, showing only the requests and responses for `shard.init` and `shard.tester`, should look approximately like this:"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:253
msgid "<...>\n"
"tarantool> shard.init(cfg)\n"
"2017-09-06 ... I> Sharding initialization started...\n"
"2017-09-06 ... I> establishing connection to cluster servers...\n"
"2017-09-06 ... I> connected to all servers\n"
"2017-09-06 ... I> started\n"
"2017-09-06 ... I> redundancy = 1\n"
"2017-09-06 ... I> Adding localhost:3301 to shard 1\n"
"2017-09-06 ... I> shards = 1\n"
"2017-09-06 ... I> Done\n"
"---\n"
"- true\n"
"...\n"
"tarantool> -- Now put something in ...\n"
"---\n"
"...\n"
"tarantool> shard.tester:insert{1,'Tuple #1'}\n"
"---\n"
"- - [1, 'Tuple #1']\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:278
msgid "Example: shard, scaling out"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:280
msgid "There are two shards, and each shard contains one replicated data copy. This requires two nodes. In real life the two nodes would be two computers, but for this illustration the requirement is merely: start two shells, which we'll call Terminal#1 and Terminal #2."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:285
msgid "On Terminal #1, say:"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:287
msgid "$ mkdir ~/tarantool_sandbox_1\n"
"$ cd ~/tarantool_sandbox_1\n"
"$ rm -r *.snap\n"
"$ rm -r *.xlog\n"
"$ ~/tarantool-1.7/src/tarantool\n"
"\n"
"tarantool> box.cfg{listen = 3301}\n"
"tarantool> box.schema.space.create('tester')\n"
"tarantool> box.space.tester:create_index('primary', {})\n"
"tarantool> box.schema.user.create('test_user', {password = 'pass'})\n"
"tarantool> box.schema.user.grant('test_user', 'read,write,execute', 'universe')\n"
"tarantool> console = require('console')\n"
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'localhost:3301', zone = '1' },\n"
"         >     { uri = 'localhost:3302', zone = '2' },\n"
"         >   },\n"
"         >   login = 'test_user',\n"
"         >   password = 'pass',\n"
"         >   redundancy = 1,\n"
"         >   binary = 3301,\n"
"         > }\n"
"tarantool> shard = require('shard')\n"
"tarantool> shard.init(cfg)\n"
"tarantool> -- Now put something in ...\n"
"tarantool> shard.tester:insert{1,'Tuple #1'}"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:316
msgid "On Terminal #2, say:"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:318
msgid "$ mkdir ~/tarantool_sandbox_2\n"
"$ cd ~/tarantool_sandbox_2\n"
"$ rm -r *.snap\n"
"$ rm -r *.xlog\n"
"$ ~/tarantool-1.7/src/tarantool\n"
"\n"
"tarantool> box.cfg{listen = 3302}\n"
"tarantool> box.schema.space.create('tester')\n"
"tarantool> box.space.tester:create_index('primary', {})\n"
"tarantool> box.schema.user.create('test_user', {password = 'pass'})\n"
"tarantool> box.schema.user.grant('test_user', 'read,write,execute', 'universe')\n"
"tarantool> console = require('console')\n"
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'localhost:3301', zone = '1' };\n"
"         >     { uri = 'localhost:3302', zone = '2' };\n"
"         >   };\n"
"         >   login = 'test_user';\n"
"         >   password = 'pass';\n"
"         >   redundancy = 1;\n"
"         >   binary = 3302;\n"
"         > }\n"
"tarantool> shard = require('shard')\n"
"tarantool> shard.init(cfg)\n"
"tarantool> -- Now get something out ...\n"
"tarantool> shard.tester:select{1}"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:347
msgid "What will appear on Terminal #1 is: a loop of error messages saying \"Connection refused\" and \"server check failure\". This is normal. It will go on until Terminal #2 process starts."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:351
msgid "What will appear on Terminal #2, at the end, should look like this:"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:353
msgid "tarantool> shard.tester:select{1}\n"
"---\n"
"- - - [1, 'Tuple #1']\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:360
msgid "This shows that what was inserted by Terminal #1 can be selected by Terminal #2, via the `shard` module."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:363
msgid "For details, see the `README <https://github.com/tarantool/shard>`_."
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:3
msgid "Module `tdb`"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:5
msgid "The Tarantool Debugger (abbreviation = ``tdb``) can be used with any Lua program. The operational features include: setting breakpoints, examining variables, going forward one line at a time, backtracing, and showing information about fibers. The display features include: using different colors for different situations, including line numbers, and adding hints."
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:11
msgid "It is not supplied as part of the Tarantool repository; it must be installed separately. Here is the usual way:"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:14
msgid "$ git clone --recursive https://github.com/Sulverus/tdb\n"
"$ cd tdb\n"
"$ make\n"
"$ sudo make install prefix=/usr/share/tarantool/"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:21
msgid "To initiate ``tdb`` within a Lua program and set a breakpoint, edit the program to include these lines:"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:24
msgid "tdb = require('tdb')\n"
"tdb.start()"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:29
msgid "To start the debugging session, execute the Lua program. Execution will stop at the breakpoint, and it will be possible to enter debugging commands."
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:34
msgid "Debugger Commands"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:38
msgid ":codebold:`bt`"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:37
msgid "Backtrace -- show the stack (in red), with program/function names and line numbers of whatever has been invoked to reach the current line."
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:41
msgid ":codebold:`c`"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:41
msgid "Continue till next breakpoint or till program ends."
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:48
msgid ":codebold:`e`"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:44
msgid "Enter evaluation mode. When the program is in evaluation mode, one can execute certain Lua statements that would be valid in the context. This is particularly useful for displaying the values of the program's variables. Other debugger commands will not work until one exits evaluation mode by typing :codebold:`-e`."
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:51
msgid ":codebold:`-e`"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:51
msgid "Exit evaluation mode."
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:55
msgid ":codebold:`f`"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:54
msgid "Display the fiber id, the program name, and the percentage of memory used, as a table."
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:58
msgid ":codebold:`n`"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:58
msgid "Go to the next line, skipping over any function calls."
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:61
msgid ":codebold:`globals`"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:61
msgid "Display names of variables or functions which are defined as global."
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:64
msgid ":codebold:`h`"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:64
msgid "Display a list of debugger commands."
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:68
msgid ":codebold:`locals`"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:67
msgid "Display names and values of variables, for example the control variables of a Lua \"for\" statement."
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:71
msgid ":codebold:`q`"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:71
msgid "Quit immediately."
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:75
msgid "Example Session"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:77
msgid "Put the following program in a default directory and call it \"example.lua\":"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:79
msgid "tdb = require('tdb')\n"
"tdb.start()\n"
"i = 1\n"
"j = 'a' .. i\n"
"print('end of program')"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:87
msgid "Now start Tarantool, using example.lua as the initialization file"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:89
msgid "$ tarantool example.lua"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:93
#: ../doc/reference/reference_rock/tdb.rst:118
msgid "The screen should now look like this:"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:132
msgid "$ :codebold:`tarantool example.lua`\n"
":codeblue:`(TDB)`  :codegreen:`Tarantool debugger v.0.0.3. Type h for help`\n"
"example.lua\n"
":codeblue:`(TDB)`  :codegreen:`[example.lua]`\n"
":codeblue:`(TDB)`  :codenormal:`3: i = 1`\n"
":codeblue:`(TDB)>`"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:105
msgid "Debugger prompts are blue, debugger hints and information are green, and the current line -- line 3 of example.lua -- is the default color. Now enter six debugger commands:"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:109
msgid "n  -- go to next line\n"
"n  -- go to next line\n"
"e  -- enter evaluation mode\n"
"j  -- display j\n"
"-e -- exit evaluation mode\n"
"q  -- quit"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:157
msgid "$ :codebold:`tarantool example.lua`\n"
":codeblue:`(TDB)`  :codegreen:`Tarantool debugger v.0.0.3. Type h for help`\n"
"example.lua\n"
":codeblue:`(TDB)`  :codegreen:`[example.lua]`\n"
":codeblue:`(TDB)`  :codenormal:`3: i = 1`\n"
":codeblue:`(TDB)>` n\n"
":codeblue:`(TDB)`  :codenormal:`4: j = 'a' .. i`\n"
":codeblue:`(TDB)>` n\n"
":codeblue:`(TDB)`  :codenormal:`5: print('end of program')`\n"
":codeblue:`(TDB)>` e\n"
":codeblue:`(TDB)`  :codegreen:`Eval mode ON`\n"
":codeblue:`(TDB)>` j\n"
"j       a1\n"
":codeblue:`(TDB)>` -e\n"
":codeblue:`(TDB)`  :codegreen:`Eval mode OFF`\n"
":codeblue:`(TDB)>` q"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:140
msgid "Another debugger example can be found `here <https://github.com/sulverus/tdb>`_."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:5
msgid "Module `vshard`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:11
msgid "Summary"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:13
msgid "The ``vshard`` module introduces the sharding feature, which enables horizontal scaling in Tarantool."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:16
msgid "While a project is growing, scaling the databases may become the most challenging issue. Once a single server cannot withstand the load, scaling methods should be applied."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:20
msgid "There are two different approaches for scaling data, `vertical and horizontal scaling <https://en.wikipedia.org/wiki/Scalability#Horizontal_and_vertical_scaling>`_:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:23
msgid "*Vertical scaling* implies that the hardware capacities of a single server would be increased."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:26
msgid "*Horizontal scaling* implies that a dataset is partitioned and distributed over multiple servers. In case new servers are added, the dataset is re-distributed evenly across all servers, both the original and new ones."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:30
msgid "Sharding is a database architecture that allows for horizontal scaling."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:32
msgid "With ``vshard``, the tuples of a dataset are distributed across multiple nodes, with a Tarantool database server instance on each node. Each instance handles only a subset of the total data, so larger loads can be handled by simply adding more servers. The initial dataset is partitioned into multiple parts, so each part is stored on a separate server. The dataset is partitioned using sharding keys."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:38
msgid "The ``vshard`` module is based on the concept of virtual buckets, where a tuple set is partitioned into a large number of abstract virtual nodes (virtual buckets, or buckets) rather than into a smaller number of physical nodes."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:42
msgid "Hashing a sharding key into a large number of virtual buckets allows seamlessly changing the number of servers in the cluster. The rebalancing mechanism distributes buckets evenly among all shards in case some servers were added or removed."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:46
msgid "The buckets have states, so it is easy to monitor the server states. For example, a server instance is active and available for all types of requests, or a failover occurred and the instance accepts only read requests."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:50
msgid "The ``vshard`` module provides analogs for the data-manipulation functions of the Tarantool ``box`` library (select, insert, replace, update, delete)."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:59
msgid "The ``vshard`` module is distributed separately from the main Tarantool package. To acquire it, do a separate installation:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:62
msgid "$ tarantoolctl rocks install vshard"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:68
msgid "The ``vshard`` module requires Tarantool version 1.9+."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:74
msgid "Quick start"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:76
msgid "The ``example/`` directory of `the vshard git-repository <https://github.com/tarantool/vshard>`_ includes a pre-configured development cluster of 1 ``router`` and 2 replica sets of 2 nodes (2 ``storages``) each, making 5 Tarantool instances in total:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:81
msgid "``router_1`` – a ``router`` instance"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:82
msgid "``storage_1_a`` – a ``storage`` instance, the master of the first replica set"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:83
msgid "``storage_1_b`` – a ``storage`` instance, the replica of the first replica set"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:84
msgid "``storage_2_a`` – a ``storage`` instance, the master of the second replica set"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:85
msgid "``storage_2_b`` – a ``storage`` instance, the replica of the second replica set"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:87
msgid "All instances are managed using the ``tarantoolctl`` utility which comes with Tarantool."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:89
msgid "Change the directory to ``example/`` and use ``make`` to run the development cluster:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:91
msgid "$ cd example/\n"
"$ make\n"
"tarantoolctl stop storage_1_a  # stop the first storage instance\n"
"Stopping instance storage_1_a...\n"
"tarantoolctl stop storage_1_b\n"
"<...>\n"
"rm -rf data/\n"
"tarantoolctl start storage_1_a # start the first storage instance\n"
"Starting instance storage_1_a...\n"
"Starting configuration of replica 8a274925-a26d-47fc-9e1b-af88ce939412\n"
"I am master\n"
"Taking on replicaset master role...\n"
"Run console at unix/:./data/storage_1_a.control\n"
"started\n"
"mkdir ./data/storage_1_a\n"
"<...>\n"
"tarantoolctl start router_1 # start the router\n"
"Starting instance router_1...\n"
"Starting router configuration\n"
"Calling box.cfg()...\n"
"<...>\n"
"Run console at unix/:./data/router_1.control\n"
"started\n"
"mkdir ./data/router_1\n"
"Waiting cluster to start\n"
"echo \"vshard.router.bootstrap()\" | tarantoolctl enter router_1\n"
"connected to unix/:./data/router_1.control\n"
"unix/:./data/router_1.control> vshard.router.bootstrap()\n"
"---\n"
"- true\n"
"...\n"
"unix/:./data/router_1.control>\n"
"tarantoolctl enter router_1 # enter the admin console\n"
"connected to unix/:./data/router_1.control\n"
"unix/:./data/router_1.control>"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:129
msgid "Some ``tarantoolctl`` commands:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:131
msgid "``tarantoolctl start router_1`` – start the router instance"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:132
msgid "``tarantoolctl enter router_1``  – enter the admin console"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:134
msgid "The full list of ``tarantoolctl`` commands for managing Tarantool instances is available in the :ref:`tarantoolctl reference <tarantoolctl>`."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:137
msgid "Essential make commands you need to know:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:139
msgid "``make start`` – start all Tarantool instances"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:140
msgid "``make stop`` – stop all Tarantool instances"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:141
msgid "``make logcat`` – show logs from all instances"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:142
msgid "``make enter`` – enter the admin console on router_1"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:143
msgid "``make clean`` – clean up all persistent data"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:144
msgid "``make test`` – run the test suite (you can also run test-run.py in the test directory)"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:145
msgid "``make`` – execute ``make stop``, ``make clean``, ``make start`` and ``make enter``"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:147
msgid "For example, to start all instances, use ``make start``:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:149
msgid "$ make start\n"
"$ ps x|grep tarantool\n"
"46564   ??  Ss     0:00.34 tarantool storage_1_a.lua <running>\n"
"46566   ??  Ss     0:00.19 tarantool storage_1_b.lua <running>\n"
"46568   ??  Ss     0:00.35 tarantool storage_2_a.lua <running>\n"
"46570   ??  Ss     0:00.20 tarantool storage_2_b.lua <running>\n"
"46572   ??  Ss     0:00.25 tarantool router_1.lua <running>"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:159
msgid "To perform commands in the admin console, use the ``router`` API:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:161
msgid "unix/:./data/router_1.control> vshard.router.info()\n"
"---\n"
"- replicasets:\n"
"    ac522f65-aa94-4134-9f64-51ee384f1a54:\n"
"      replica: &0\n"
"        network_timeout: 0.5\n"
"        status: available\n"
"        uri: storage@127.0.0.1:3303\n"
"        uuid: 1e02ae8a-afc0-4e91-ba34-843a356b8ed7\n"
"      uuid: ac522f65-aa94-4134-9f64-51ee384f1a54\n"
"      master: *0\n"
"    cbf06940-0790-498b-948d-042b62cf3d29:\n"
"      replica: &1\n"
"        network_timeout: 0.5\n"
"        status: available\n"
"        uri: storage@127.0.0.1:3301\n"
"        uuid: 8a274925-a26d-47fc-9e1b-af88ce939412\n"
"      uuid: cbf06940-0790-498b-948d-042b62cf3d29\n"
"      master: *1\n"
"  bucket:\n"
"    unreachable: 0\n"
"    available_ro: 0\n"
"    unknown: 0\n"
"    available_rw: 3000\n"
"  status: 0\n"
"  alerts: []\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:195
msgid "Architecture"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:197
msgid "A sharded cluster in Tarantool consists of storages, routers, and a rebalancer."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:199
msgid "A **storage** is a node storing a subset of a dataset. Multiple replicated storages are deployed as replica sets to provide redundancy (a replica set can also be called a shard)."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:203
msgid "A **router** is a standalone software component that routes read and write requests from the client application to shards."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:206
msgid "A **rebalancer** is an internal component that distributes the dataset among all shards evenly in case some servers are added or removed. It also balances the load considering the capacities of existing replica sets."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:217
msgid "Storage"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:219
msgid "**Storage** is a node storing a subset of a dataset. Multiple replicated storages comprise a replica set. Each storage in a replica set has a role, **master** or **replica**. A master processes read and write requests. A replica processes read requests but cannot process write requests."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:231
msgid "Virtual buckets"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:233
msgid "The sharded dataset is partitioned into a large number of abstract nodes called **virtual buckets** (further referred to as **buckets**)."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:236
msgid "The dataset is partitioned using the sharding key (or **bucket id**, in Tarantool terminology). Bucket id is a number from 1 to N, where N is the total number of buckets."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:243
msgid "Each replica set stores a unique subset of buckets. One bucket cannot belong to multiple replica sets at a time."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:249
msgid "The total number of buckets is determined by the administrator who sets up the initial cluster configuration."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:252
msgid "Every Tarantool space you plan to shard must have a bucket id field indexed by the bucket id ``index``. Spaces without the bucket id indexes don’t participate in sharding but can be used as regular spaces. By default, the name of the index coincides with the bucket id."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:261
msgid "Migration of buckets"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:263
msgid "A **rebalancer** is a background rebalancing process that ensures an even distribution of buckets across the shards. During rebalancing, buckets are being migrated among replica sets."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:267
msgid "A replica set from which the bucket is being migrated is called a **source** ; a target replica set to which the bucket is being migrated is called a **destination**."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:270
msgid "A **replica set lock** makes a replica set invisible to the rebalancer. A locked replica set can neither receive new buckets nor migrate its own buckets."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:273
msgid "While a bucket is being migrated, it can have different states:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:275
msgid "ACTIVE – the bucket is available for read and write requests."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:276
msgid "PINNED – the bucket is locked for migrating to another replica set. Otherwise pinned buckets are similar to buckets in the ACTIVE state."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:278
msgid "SENDING – the bucket is currently being copied to the destination replica set; read requests to the source replica set are still processed."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:280
msgid "RECEIVING – the bucket is currently being filled; all requests to it are rejected."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:281
msgid "SENT – the bucket was migrated to the destination replica set. The `router` uses the SENT state to calculate the new location of the bucket. A bucket in the SENT state goes to the GARBAGE state automatically after BUCKET_SENT_GARBAGE_DELAY seconds, which by default is :ref:`0.5 seconds <cfg_basic-collect_bucket_garbage_interval>`."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:285
msgid "GARBAGE – the bucket was already migrated to the destination replica set during rebalancing; or the bucket was initially in the RECEIVING state, but some error occurred during the migration."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:289
msgid "Buckets in the GARBAGE state are deleted by the garbage collector."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:294
msgid "Migration is performed as follows:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:296
msgid "At the destination replica set, a new bucket is created and assigned the RECEIVING state, the data copying starts, and the bucket rejects all requests."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:298
msgid "The source bucket in the source replica set is assigned the SENDING state, and the bucket continues to process read requests."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:300
msgid "Once the data is copied, the bucket on the source replica set is assigned the SENT and it starts rejecting all requests."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:302
msgid "The bucket on the destination replica set is assigned the ACTIVE state and starts accepting all requests."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:309
msgid "The `_bucket` system space"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:311
msgid "The ``_bucket`` system space of each replica set stores the ids of buckets present in the replica set. The space contains the following fields:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:314
msgid "``bucket`` – bucket id"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:315
msgid "``status`` – state of the bucket"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:316
msgid "``destination`` – UUID of the destination replica set"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:318
msgid "An example of ``_bucket.select{}``:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:320
msgid "---\n"
"- - [1, ACTIVE, abfe2ef6-9d11-4756-b668-7f5bc5108e2a]\n"
"  - [2, SENT, 19f83dcb-9a01-45bc-a0cf-b0c5060ff82c]\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:327
msgid "Once the bucket is migrated, the destination replica set identified by UUID is filled in the table. While the bucket is still located on the source replica set, the value of the destination replica set UUID is equal to ``NULL``."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:335
msgid "Router"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:337
msgid "All requests from the application come to the sharded cluster through a ``router``. The ``router`` keeps the topology of a sharded cluster transparent for the application, thus keeping the application unaware of:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:341
msgid "the number and location of shards,"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:342
msgid "data rebalancing process,"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:343
msgid "the fact and the process of a failover that occurred after a replica's failure."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:345
msgid "The ``router`` does not have a persistent state, nor does it store the cluster topology or balance the data. The ``router`` is a standalone software component that can run in the storage layer or application layer depending on the application features."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:353
msgid "The routing table"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:355
msgid "А routing table on the ``router`` stores the map of all bucket ids to replica sets. It ensures the consistency of sharding in case of failover."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:358
msgid "The ``router`` keeps a persistent pool of connections to all the storages that are created at startup. This helps prevent configuration errors. Once the connection pool is created, the ``router`` caches the current state of the routing table in order to speed up routing. If a bucket migrated to another ``storage`` after rebalancing, or a failover occurred and caused one of the shards switching to another replica, the ``discovery fiber`` on the ``router`` updates the routing table automatically."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:365
msgid "As the bucket id is explicitly indicated both in the data and in the mapping table on the ``router``, the data is consistent regardless of the application logic. It also makes rebalancing transparent for the application."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:373
msgid "Processing requests"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:375
msgid "Requests to the database can be performed by the application or using stored procedures. Either way, the bucket id should be explicitly specified in the request."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:378
msgid "All requests are forwarded to the ``router`` first. The only operation supported by the ``router`` is ``call``. The operation is performed via the ``vshard.router.call()`` function:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:382
msgid "result = vshard.router.call(<bucket_id>, <mode>, <function_name>, {<argument_list>}, {<opts>})"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:386
msgid "Requests are processed as follows:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:388
msgid "The ``router`` uses the bucket id to search for a replica set with the corresponding bucket in the routing table."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:391
msgid "If the map of the bucket id to the replica set is not known to the ``router`` (the discovery fiber hasn’t filled the table yet), the ``router`` makes requests to all ``storages`` to find out where the bucket is located."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:394
msgid "Once the bucket is located, the shard checks:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:396
msgid "whether the bucket is stored in the ``_bucket`` system space of the replica set;"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:397
msgid "whether the bucket is ACTIVE or PINNED (for a read request, it can also be SENDING)."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:398
msgid "If all the checks succeed, the request is executed. Otherwise, it is terminated with the error: ``“wrong bucket”``."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:405
msgid "Administration"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:411
msgid "Configuring a sharded cluster"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:413
msgid "A minimal viable sharded cluster should consist of:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:415
msgid "one or more replica sets, each containing two or more ``storage`` instances"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:416
msgid "one or more ``router`` instances"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:418
msgid "The number of ``storage`` instances in a replica set defines the redundancy factor of the data. The recommended value is 3 or more. The number of ``router`` instances is not limited, because routers are completely stateless. We recommend increasing the number of routers when an existing ``router`` instance becomes CPU or I/O bound."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:423
msgid "``vshard`` supports multiple ``router`` instances on a single Tarantool instance. Each ``router`` can be connected to any ``vshard`` cluster. Multiple ``router`` instances can be connected to the same cluster."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:427
msgid "As the ``router`` and ``storage`` applications perform completely different sets of functions, they should be deployed to different Tarantool instances. Although it is technically possible to place the router application on every ``storage`` node, this approach is highly discouraged and should be avoided on production deployments."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:432
msgid "All ``storage`` instances can be deployed using identical instance (configuration) files."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:435
msgid "Self-identification is currently performed using ``tarantoolctl``:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:437
msgid "$ tarantoolctl instance_name"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:441
msgid "All ``router`` instances can also be deployed using identical instance (configuration) files."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:444
msgid "All cluster nodes must share a common topology. An administrator must ensure that the configurations are identical. We suggest using a configuration management tool like Ansible or Puppet to deploy the cluster."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:448
msgid "Sharding is not integrated into any system for centralized configuration management. It is expected that the application itself is responsible for interacting with such a system and passing the sharding parameters."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:456
msgid "Sample configuration"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:458
msgid "The configuration of a simple sharded cluster can look like this:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:460
msgid "local cfg = {\n"
"    memtx_memory = 100 * 1024 * 1024,\n"
"    replication_connect_quorum = 0,\n"
"    bucket_count = 10000,\n"
"    rebalancer_disbalance_threshold = 10,\n"
"    rebalancer_max_receiving = 100,\n"
"    sharding = {\n"
"        ['cbf06940-0790-498b-948d-042b62cf3d29'] = {\n"
"            replicas = {\n"
"                ['8a274925-a26d-47fc-9e1b-af88ce939412'] = {\n"
"                    uri = 'storage:storage@127.0.0.1:3301',\n"
"                    name = 'storage_1_a',\n"
"                    master = true\n"
"                },\n"
"                ['3de2e3e1-9ebe-4d0d-abb1-26d301b84633'] = {\n"
"                    uri = 'storage:storage@127.0.0.1:3302',\n"
"                    name = 'storage_1_b'\n"
"                }\n"
"            },\n"
"        },\n"
"        ['ac522f65-aa94-4134-9f64-51ee384f1a54'] = {\n"
"            replicas = {\n"
"                ['1e02ae8a-afc0-4e91-ba34-843a356b8ed7'] = {\n"
"                    uri = 'storage:storage@127.0.0.1:3303',\n"
"                    name = 'storage_2_a',\n"
"                    master = true\n"
"                },\n"
"                ['001688c3-66f8-4a31-8e19-036c17d489c2'] = {\n"
"                    uri = 'storage:storage@127.0.0.1:3304',\n"
"                    name = 'storage_2_b'\n"
"                }\n"
"            },\n"
"        },\n"
"    },\n"
"}"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:498
msgid "This cluster includes one ``router`` instance and two ``storage`` instances. Each ``storage`` instance includes one master and one replica."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:501
msgid "The sharding field defines the logical topology of a sharded Tarantool cluster. All the other fields are passed to ``box.cfg()`` as they are, without modifications. See the :ref:`Configuration reference <vshard-config-reference>` section for details."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:505
msgid "On routers call ``vshard.router.cfg(cfg)``:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:507
msgid "cfg.listen = 3300\n"
"\n"
"-- Start the database with sharding\n"
"vshard = require('vshard')\n"
"vshard.router.cfg(cfg)"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:515
msgid "On storages call ``vshard.storage.cfg(cfg, instance_uuid)``:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:517
msgid "-- Get instance name\n"
"local MY_UUID = \"de0ea826-e71d-4a82-bbf3-b04a6413e417\"\n"
"\n"
"-- Call a configuration provider\n"
"local cfg = require('localcfg')\n"
"\n"
"-- Start the database with sharding\n"
"vshard = require('vshard')\n"
"vshard.storage.cfg(cfg, MY_UUID)"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:529
msgid "``vshard.storage.cfg()`` automatically calls ``box.cfg()`` and configures the listen port and replication parameters."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:532
msgid "See ``router.lua`` and ``storage.lua`` in the ``vshard/example`` directory for a sample configuration."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:539
msgid "Replica weights"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:541
msgid "The ``router`` sends all requests to the master instance only. Setting replica weights allows sending read requests not only to the master instance, but to any available replica that is the 'nearest' to the ``router``. Weights are used to define distances between replicas within a replica set."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:546
msgid "Weights can be used, for example, to define the physical distance between the ``router`` and each replica in each replica set. In such a case read requests are sent to the nearest replica."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:550
msgid "Setting weights can also help to define the most powerful replicas: the ones that can process the largest number of requests per second."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:553
msgid "The idea is to specify the zone for every ``router`` and every replica, therefore filling a matrix of relative zone weights. This approach allows setting different weights in different zones for the same replica set."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:557
msgid "To set weights, use the zone attribute for each replica during configuration:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:559
msgid "local cfg = {\n"
"   sharding = {\n"
"      ['...replicaset_uuid...'] = {\n"
"         replicas = {\n"
"            ['...replica_uuid...'] = {\n"
"                 ...,\n"
"                 zone = <number or string>\n"
"            }\n"
"         }\n"
"      }\n"
"   }\n"
"}"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:574
msgid "Then, specify relative weights for each zone pair in the weights parameter of ``vshard.router.cfg``. For example:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:577
msgid "weights = {\n"
"    [1] = {\n"
"        [2] = 1, -- routers of the 1st zone see the weight of the 2nd zone as 1\n"
"        [3] = 2, -- routers of the 1st zone see the weight of the 3rd zone as 2\n"
"\n"
"\n"
"   [4] = 3, -- ...\n"
"    },\n"
"    [2] = {\n"
"        [1] = 10,\n"
"        [2] = 0,\n"
"        [3] = 10,\n"
"        [4] = 20,\n"
"    },\n"
"    [3] = {\n"
"        [1] = 100,\n"
"        [2] = 200, -- routers of the 3rd zone see the weight of the 2nd zone as 200. Mind that it is not equal to the weight of the 2nd zone = 2 visible from the 1st zone\n"
"        [4] = 1000,\n"
"    }\n"
"}\n"
"\n"
"local cfg = vshard.router.cfg({weights = weights, sharding = ...})"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:606
msgid "Replica set weights"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:608
msgid "A replica set weight is not the same as the replica weight. The weight of a replica set defines the capacity of the replica set: the larger the weight, the more buckets the replica set can store. The total size of all sharded spaces in the replica set is also its capacity metric."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:613
msgid "You can consider replica set weights as the relative amount of data within a replica set. For example, if ``replicaset_1 = 100``, and ``replicaset_2 = 200``, the second replica set stores twice as many buckets as the first one. By default, all weights of all replica sets are equal."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:618
msgid "You can use weights, for example, to store the prevailing amount of data on a replica set with more memory space."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:625
msgid "Rebalancing process"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:627
msgid "There is an **etalon number** of buckets for a replica set. (Etalon in this context means \"ideal\".) If there is no deviation from this number in the whole replica set, then the buckets are distributed evenly."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:632
msgid "The etalon number is calculated automatically considering the number of buckets in the cluster and weights of the replica sets."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:635
msgid "For example: The user specified the number of buckets is 3000, and weights of 3 replica sets are 1, 0.5, and 1.5. The resulting etalon numbers of buckets for the replica sets are: 1st replica set – 1000, 2nd replica set – 500, 3rd replica set – 1500."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:640
msgid "This approach allows assigning a zero weight to a replica set, which initiates migration of its buckets to the remaining cluster nodes. It also allows adding a new zero-load replica set, which initiates migration of the buckets from the loaded replica sets to the zero-load replica set."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:647
msgid "A new zero-load replica set should be assigned a weight for rebalancing to start."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:649
msgid "The ``rebalancer`` wakes up periodically and redistributes data from the most loaded nodes to less loaded nodes. Rebalancing starts if the disbalance threshold of a replica set exceeds a disbalance threshold specified in the configuration."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:653
msgid "The disbalance threshold is calculated as follows:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:655
msgid "|etalon_bucket_number - real_bucket_number| / etalon_bucket_number * 100"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:659
msgid "When a new shard is added, the configuration can be updated dynamically:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:661
msgid "The configuration should be updated on all the ``routers`` first, and then on all the ``storages``."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:663
msgid "The new shard becomes available for rebalancing in the ``storage`` layer."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:664
msgid "As a result of rebalancing, buckets are migrated to the new shard."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:665
msgid "If a migrated bucket is requested, ``router`` receives an error code containing information about the new location of the bucket."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:668
msgid "At this time, the new shard is already present in the ``router``'s pool of connections, so redirection is transparent for the application."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:675
msgid "Replica set lock and bucket pin"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:677
msgid "A replica set lock makes a replica set invisible to the ``rebalancer``: a locked replica set can neither receive new buckets nor migrate its own buckets."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:680
msgid "A bucket pin blocks a specific bucket from migrating: a pinned bucket stays on the replica set to which it is pinned, until it is unpinned."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:683
msgid "Pinning all replica set buckets is not equivalent to locking a replica set. Even if you pin all buckets, a non-locked replica set can still receive new buckets."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:686
msgid "Replica set lock is helpful, for example, to separate a replica set from production replica sets for testing, or to preserve some application metadata that must not be sharded for a while. A bucket pin is used for similar cases but in a smaller scope."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:691
msgid "By both locking a replica set and pinning all buckets, one can isolate an entire replica set."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:694
msgid "Locked replica sets and pinned buckets affect the rebalancing algorithm as the ``rebalancer`` must ignore locked replica sets and consider pinned buckets when attempting to reach the best possible balance."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:698
msgid "The issue is not trivial as a user can pin too many buckets to a replica set, so a perfect balance becomes unreachable. For example, consider the following cluster (assume all replica set weights are equal to 1)."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:702
msgid "The initial configuration:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:704
msgid "rs1: bucket_count = 150\n"
"rs2: bucket_count = 150, pinned_count = 120"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:709
msgid "Adding a new replica set:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:711
msgid "rs1: bucket_count = 150\n"
"rs2: bucket_count = 150, pinned_count = 120\n"
"rs3: bucket_count = 0"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:717
msgid "The perfect balance would be ``100 - 100 - 100``, which is impossible since the ``rs2`` replica set has 120 pinned buckets. The best possible balance here is the following:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:721
msgid "rs1: bucket_count = 90\n"
"rs2: bucket_count = 120, pinned_count 120\n"
"rs3: bucket_count = 90"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:727
msgid "The ``rebalancer`` moved as many buckets as possible from ``rs2`` to decrease the disbalance. At the same time it respected equal weights of ``rs1`` and ``rs3``."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:730
msgid "The algorithms for implementing locks and pins are completely different, although they look similar in terms of functionality."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:737
msgid "Replica set lock and rebalancing"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:739
msgid "Locked replica sets simply do not participate in rebalancing. This means that even if the actual total number of buckets is not equal to the etalon number, the disbalance cannot be fixed due to the lock. When the rebalancer detects that one of the replica sets is locked, it recalculates the etalon number of buckets of the non-locked replica sets as if the locked replica set and its buckets did not exist at all."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:750
msgid "Bucket pin and rebalancing"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:752
msgid "Rebalancing replica sets with pinned buckets requires a more complex algorithm. Here pinned_count[o] is the number of pinned buckets, and ``etalon_count`` is the etalon number of buckets for a replica set:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:756
msgid "The ``rebalancer`` calculates the etalon number of buckets as if all buckets were not pinned. Then the rebalancer checks each replica set and compares the etalon number of buckets with the number of pinned buckets in a replica set. If ``pinned_count < etalon_count``, non-locked replica sets (at this point all locked replica sets already are filtered out) with pinned buckets can receive new buckets."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:762
msgid "If ``pinned_count > etalon_count``, the disbalance cannot be fixed, as the ``rebalancer`` cannot move pinned buckets out of this replica set. In such a case the etalon number is updated and set equal to the number of pinned buckets. The replica sets with ``pinned_count > etalon_count`` are not processed by the ``rebalancer``, and the number of pinned buckets is subtracted from the total number of buckets. The rebalancer tries to move out as many buckets as possible from such replica sets."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:769
msgid "This procedure is restarted from step 1 for replica sets with ``pinned_count >= etalon_count`` until ``pinned_count <= etalon_count`` on all replica sets. The procedure is also restarted when the total number of buckets is changed."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:774
msgid "Here is the pseudocode for the algorithm:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:776
msgid "function cluster_calculate_perfect_balance(replicasets, bucket_count)\n"
"        -- rebalance the buckets using weights of the still viable replica sets --\n"
"end;\n"
"\n"
"cluster = <all of the non-locked replica sets>;\n"
"bucket_count = <the total number of buckets in the cluster>;\n"
"can_reach_balance = false\n"
"while not can_reach_balance do\n"
"        can_reach_balance = true\n"
"        cluster_calculate_perfect_balance(cluster, bucket_count);\n"
"        foreach replicaset in cluster do\n"
"                if replicaset.perfect_bucket_count <\n"
"                   replicaset.pinned_bucket_count then\n"
"                        can_reach_balance = false\n"
"                        bucket_count -= replicaset.pinned_bucket_count;\n"
"                        replicaset.perfect_bucket_count =\n"
"                                replicaset.pinned_bucket_count;\n"
"                end;\n"
"        end;\n"
"end;\n"
"cluster_calculate_perfect_balance(cluster, bucket_count);"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:800
msgid "The complexity of the algorithm is ``O(N^2)``, where N is the number of replica sets. On each step, the algorithm either finishes the calculation, or ignores at least one new replica set overloaded with the pinned buckets, and updates the etalon number of buckets on other replica sets."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:809
msgid "Bucket ref"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:811
msgid "Bucket ref is an in-memory counter that is similar to the :ref:`bucket pin <vshard-lock-pin>`, but has the following differences:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:814
msgid "Bucket ref is not persistent. Refs are intended for forbidding bucket transfer during request execution, but on restart all requests are dropped."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:817
msgid "There are two types of bucket refs: read-only (RO) and read-write (RW)."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:819
msgid "If a bucket has RW refs, it can not be moved. However, when the rebalancer needs it to be sent, it locks the bucket for new write requests, waits until all current requests are finished, and then sends the bucket."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:824
msgid "If a bucket has RO refs, it can be sent, but cannot be dropped. Such a bucket can even enter GARBAGE or SENT state, but its data is kept until the last reader is gone."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:828
msgid "A single bucket can have both RO and RW refs."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:830
msgid "Bucket ref is countable."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:832
msgid "The :ref:`vshard.storage.bucket_ref/unref()<storage_api-bucket_ref>` methods are called automatically when :ref:`vshard.router.call() <router_api-call>` or :ref:`vshard.storage.call() <storage_api-call>` is used. For raw API like ``r = vshard.router.route() r:callro/callrw`` you should explicitly call the ``bucket_ref()`` method inside the function. Also, make sure that you call ``bucket_unref()`` after ``bucket_ref()``, otherwise the bucket cannot be moved from the storage until the instance restart."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:840
msgid "To see how many refs there are for a bucket, use :ref:`vshard.storage.buckets_info([bucket_id]) <storage_api-buckets_info>` (the ``bucket_id`` parameter is optional)."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:846
#: ../doc/reference/reference_rock/vshard/index.rst:1858
msgid "vshard.storage.buckets_info(1)\n"
"---\n"
"- 1:\n"
"    status: active\n"
"    ref_rw: 1\n"
"    ref_ro: 1\n"
"    ro_lock: true\n"
"    rw_lock: true\n"
"    id: 1"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:862
msgid "Defining spaces"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:864
msgid "Spaces should be defined within a storage application using ``box.once()``. For example:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:867
msgid "box.once(\"testapp:schema:1\", function()\n"
"    local customer = box.schema.space.create('customer')\n"
"    customer:format({\n"
"        {'customer_id', 'unsigned'},\n"
"        {'bucket_id', 'unsigned'},\n"
"        {'name', 'string'},\n"
"    })\n"
"    customer:create_index('customer_id', {parts = {'customer_id'}})\n"
"    customer:create_index('bucket_id', {parts = {'bucket_id'}, unique = false})\n"
"\n"
"    local account = box.schema.space.create('account')\n"
"    account:format({\n"
"        {'account_id', 'unsigned'},\n"
"        {'customer_id', 'unsigned'},\n"
"        {'bucket_id', 'unsigned'},\n"
"        {'balance', 'unsigned'},\n"
"        {'name', 'string'},\n"
"    })\n"
"    account:create_index('account_id', {parts = {'account_id'}})\n"
"    account:create_index('customer_id', {parts = {'customer_id'}, unique = false})\n"
"    account:create_index('bucket_id', {parts = {'bucket_id'}, unique = false})\n"
"    box.snapshot()\n"
"\n"
"    box.schema.func.create('customer_lookup')\n"
"    box.schema.role.grant('public', 'execute', 'function', 'customer_lookup')\n"
"    box.schema.func.create('customer_add')\n"
"end)"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:901
msgid "Bootstrapping and restarting a storage"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:903
msgid "If a replica set master fails, it is recommended to:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:905
msgid "Switch one of the replicas into the master mode. This allows the new master to process all the incoming requests."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:907
msgid "Update the configuration of all the cluster members. This forwards all the requests to the new master."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:910
msgid "Monitoring the master and switching the instance modes can be handled by any external utility."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:913
msgid "To perform a scheduled downtime of a replica set master, it is recommended to:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:915
msgid "Update the configuration of the master and wait for the replicas to get into sync. All the requests then are forwarded to a new master."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:917
msgid "Switch another instance into the master mode."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:918
#: ../doc/reference/reference_rock/vshard/index.rst:924
msgid "Update the configuration of all the nodes."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:919
msgid "Shut down the old master."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:921
msgid "To perform a scheduled downtime of a replica set, it is recommended to:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:923
msgid "Migrate all the buckets to the other cluster storages."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:925
msgid "Shut down the replica set."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:927
msgid "In case a whole replica set fails, some part of the dataset becomes inaccessible. Meanwhile, the ``router`` tries to reconnect to the master of the failed replica set. This way, once the replica set is up and running again, the cluster is automatically restored."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:938
msgid "Searches for buckets, buckets recovery, and buckets rebalancing are performed automatically and do not require human intervention."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:941
msgid "Technically, there are multiple fibers responsible for different types of operations:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:944
msgid "a **discovery** fiber on the ``router`` searches for buckets in the background"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:945
msgid "a **failover** fiber on the ``router`` maintains replica connections"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:946
msgid "a **garbage collector** fiber on each master ``storage`` removes the contents of buckets that were moved"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:948
msgid "a **bucket recovery** fiber on each master ``storage`` recovers buckets in the SENDING and RECEIVING states in case of reboot"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:950
msgid "a **rebalancer** on a single master ``storage`` among all replica sets executes the rebalancing process."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:953
msgid "See the :ref:`Rebalancing process <vshard-rebalancing>` section for details."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:959
msgid "Garbage collector"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:961
msgid "A **garbage collector** fiber runs in the background on the master storages of each replica set. It starts deleting the contents of the bucket in the GARBAGE state part by part. Once the bucket is empty, its record is deleted from the ``_bucket`` system space."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:970
msgid "Bucket recovery"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:972
msgid "A **bucket recovery** fiber runs on the master storages. It helps to recover buckets in the SENDING and RECEIVING states in case of reboot."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:975
msgid "Buckets in the SENDING state are recovered as follows:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:977
msgid "The system first searches for buckets in the SENDING state."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:978
msgid "If such a bucket is found, the system sends a request to the destination replica set."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:980
msgid "If the bucket on the destination replica set is ACTIVE, the original bucket is deleted from the source node."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:983
msgid "Buckets in the RECEIVING state are deleted without extra checks."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:989
msgid "Failover"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:991
msgid "A **failover** fiber runs on every ``router``. If a master of a replica set becomes unavailable, the failover fiber redirects read requests to the replicas. Write requests are rejected with an error until the master becomes available."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1007
msgid ":ref:`sharding <cfg_basic-sharding>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1008
msgid ":ref:`weights <cfg_basic-weights>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1009
msgid ":ref:`shard_index <cfg_basic-shard_index>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1010
msgid ":ref:`bucket_count <cfg_basic-bucket_count>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1011
msgid ":ref:`collect_bucket_garbage_interval <cfg_basic-collect_bucket_garbage_interval>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1012
msgid ":ref:`collect_lua_garbage <cfg_basic-collect_lua_garbage>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1013
msgid ":ref:`sync_timeout <cfg_basic-sync_timeout>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1014
msgid ":ref:`rebalancer_disbalance_threshold <cfg_basic-rebalancer_disbalance_threshold>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1015
msgid ":ref:`rebalancer_max_receiving <cfg_basic-rebalancer_max_receiving>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1021
msgid "A field defining the logical topology of the sharded Tarantool cluster."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1023
#: ../doc/reference/reference_rock/vshard/index.rst:1034
msgid "Type: table"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1031
msgid "A field defining the configuration of relative weights for each zone pair in a replica set. See the :ref:`Replica weights <vshard-replica-weights>` section."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1042
msgid "An index over the bucket id."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1044
msgid "Type: non-empty string or non-negative integer"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1045
msgid "Default: coincides with the bucket id number"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1052
msgid "The total number of buckets in a cluster."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1054
msgid "This number should be several orders of magnitude larger than the potential number of cluster nodes, considering potential scaling out in the foreseeable future."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1059
msgid "If the estimated number of nodes is M, then the data set should be divided into 100M or even 1000M buckets, depending on the planned scaling out. This number is certainly greater than the potential number of cluster nodes in the system being designed."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1064
msgid "Keep in mind that too many buckets can cause a need to allocate more memory to store routing information. On the other hand, an insufficient number of buckets can lead to decreased granularity when rebalancing."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1068
#: ../doc/reference/reference_rock/vshard/index.rst:1078
#: ../doc/reference/reference_rock/vshard/index.rst:1100
#: ../doc/reference/reference_rock/vshard/index.rst:1115
#: ../doc/reference/reference_rock/vshard/index.rst:1136
msgid "Type: number"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1069
msgid "Default: 3000"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1076
msgid "The interval between garbage collector actions, in seconds."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1086
msgid "If set to true, the Lua collectgarbage() function is called periodically."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1089
msgid "Default: no"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1096
msgid "Timeout to wait for synchronization of the old master with replicas before demotion. Used when switching a master or when manually calling the ``sync()`` function."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1108
msgid "A maximum bucket disbalance threshold, in percent. The threshold is calculated for each replica set using the following formula:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1111
msgid "|etalon_bucket_count - real_bucket_count| / etalon_bucket_count * 100"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1123
msgid "The maximum number of buckets that can be received in parallel by a single replica set. This number must be limited, because when a new replica set is added to a cluster, the rebalancer sends a very large amount of buckets from the existing replica sets to the new replica set. This produces a heavy load on a new replica set."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1130
msgid "Suppose ``rebalancer_max_receiving`` is equal to 100, ``bucket_count`` is equal to 1000. There are 3 replica sets with 333, 333 and 334 buckets on each respectively. When a new replica set is added, each replica set’s ``etalon_bucket_count`` becomes equal to 250. Rather than receiving all 250 buckets at once, the new replica set receives 100, 100 and 50 buckets sequentially."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1137
msgid "Default: 100"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1144
msgid "Replica set functions"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1146
msgid ":ref:`uuid <cfg_replica_set-uuid>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1147
msgid ":ref:`weight <cfg_replica_set-weight>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1153
msgid "A unique identifier of a replica set."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1155
#: ../doc/reference/reference_rock/vshard/index.rst:1166
msgid "Type:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1156
msgid "Default:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1157
#: ../doc/reference/reference_rock/vshard/index.rst:1168
msgid "Dynamic:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1163
msgid "A weight of a replica set. See the :ref:`Replica set weights <vshard-replica-set-weights>` section for details."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1180
msgid "Router public API"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1182
msgid ":ref:`vshard.router.bootstrap() <router_api-bootstrap>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1183
msgid ":ref:`vshard.router.cfg(cfg) <router_api-cfg>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1184
msgid ":ref:`vshard.router.new(name, cfg) <router_api-new>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1185
msgid ":ref:`vshard.router.call(bucket_id, mode, function_name, {argument_list}, {options}) <router_api-call>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1186
msgid ":ref:`vshard.router.callro(bucket_id, function_name, {argument_list}, {options}) <router_api-callro>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1187
msgid ":ref:`vshard.router.callrw(bucket_id, function_name, {argument_list}, {options}) <router_api-callrw>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1188
msgid ":ref:`vshard.router.callre(bucket_id, function_name, {argument_list}, {options}) <router_api-callre>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1189
msgid ":ref:`vshard.router.callbro(bucket_id, function_name, {argument_list}, {options}) <router_api-callbro>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1190
msgid ":ref:`vshard.router.callbre(bucket_id, function_name, {argument_list}, {options}) <router_api-callbre>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1191
msgid ":ref:`vshard.router.route(bucket_id) <router_api-route>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1192
msgid ":ref:`vshard.router.routeall() <router_api-routeall>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1193
msgid ":ref:`vshard.router.bucket_id(key) <router_api-bucket_id>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1194
msgid ":ref:`vshard.router.bucket_count() <router_api-bucket_count>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1195
msgid ":ref:`vshard.router.sync(timeout) <router_api-sync>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1196
msgid ":ref:`vshard.router.discovery_wakeup() <router_api-discovery_wakeup>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1197
msgid ":ref:`vshard.router.info() <router_api-info>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1198
msgid ":ref:`vshard.router.buckets_info() <router_api-buckets_info>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1199
msgid ":ref:`replicaset.call() <router_api-replicaset_call>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1200
msgid ":ref:`replicaset.callro() <router_api-replicaset_callro>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1201
msgid ":ref:`replicaset.callrw() <router_api-replicaset_callrw>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1202
msgid ":ref:`replicaset.callre() <router_api-replicaset_callre>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1208
msgid "Perform the initial cluster bootstrap and distribute all buckets across the replica sets."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1215
msgid "Configure the database and start sharding for the specified ``router`` instance. See the :ref:`sample configuration <vshard-config-cluster-example>` above."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1219
msgid "a configuration table"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1225
msgid "Create a new router instance. ``vshard`` supports multiple routers in a single Tarantool instance. Each router can be connected to any ``vshard`` cluster, and multiple routers can be connected to the same cluster."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1229
msgid "A router created via ``vshard.router.new()`` works in the same way as a static router, but the method name is preceded by a colon (``vshard.router:method_name(...)``), while for a static router the method name is preceded by a period (``vshard.router.method_name(...)``)."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1234
msgid "A static router can be obtained via the ``vshard.router.static()`` method and then used like a router created via the ``vshard.router.new()`` method."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1240
msgid "``box.cfg`` is shared among all the routers of a single instance."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1242
msgid "a router instance name. This name is used as a prefix in logs of the router and must be unique within the instance"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1244
msgid "a configuration table. The :ref:`sample configuration <vshard-config-cluster-example>` is described above."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1248
msgid "a router instance, if created successfully; otherwise, nil and an error object"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1255
msgid "Call the function identified by function-name on the shard storing the bucket identified by bucket_id. See the :ref:`Processing requests <vshard-process-requests>` section for details on function operation."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1259
#: ../doc/reference/reference_rock/vshard/index.rst:1314
#: ../doc/reference/reference_rock/vshard/index.rst:1345
#: ../doc/reference/reference_rock/vshard/index.rst:1378
#: ../doc/reference/reference_rock/vshard/index.rst:1422
#: ../doc/reference/reference_rock/vshard/index.rst:1455
#: ../doc/reference/reference_rock/vshard/index.rst:1662
#: ../doc/reference/reference_rock/vshard/index.rst:1742
#: ../doc/reference/reference_rock/vshard/index.rst:1770
#: ../doc/reference/reference_rock/vshard/index.rst:1781
#: ../doc/reference/reference_rock/vshard/index.rst:1792
#: ../doc/reference/reference_rock/vshard/index.rst:1818
#: ../doc/reference/reference_rock/vshard/index.rst:1937
#: ../doc/reference/reference_rock/vshard/index.rst:1957
#: ../doc/reference/reference_rock/vshard/index.rst:1966
#: ../doc/reference/reference_rock/vshard/index.rst:1991
#: ../doc/reference/reference_rock/vshard/index.rst:2009
msgid "a bucket identifier"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1260
msgid "either a string = 'read'|'write', or a map with mode='read'|'write' and/or prefer_replica=true|false and/or balance=true|false."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1261
#: ../doc/reference/reference_rock/vshard/index.rst:1315
#: ../doc/reference/reference_rock/vshard/index.rst:1346
#: ../doc/reference/reference_rock/vshard/index.rst:1379
msgid "a function to execute"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1262
#: ../doc/reference/reference_rock/vshard/index.rst:1316
#: ../doc/reference/reference_rock/vshard/index.rst:1347
#: ../doc/reference/reference_rock/vshard/index.rst:1380
msgid "an array of the function's arguments"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1263
msgid "* ``timeout`` – a request timeout, in seconds. If the router cannot identify a   shard with the specified bucket_id, the operation will be repeated until the   timeout is reached."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1265
msgid "``timeout`` – a request timeout, in seconds. If the router cannot identify a shard with the specified bucket_id, the operation will be repeated until the timeout is reached."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1269
msgid "The mode parameter has two possible forms: a string or a map. Examples of the string form are: 'read', 'write'. Examples of the map form are: {mode='read'}, {mode='write'}, {mode='read', prefer_replica=true}, {mode='read', balance=true}, {mode='read', prefer_replica=true, balance=true}. If 'write' is specified then the target is the master. If prefer_replica=true is specified then the preferred target is one of the replicas, but the target is the master if there is no conveniently available replica. It may be good to specify prefer_replica=true for functions which are expensive in terms of resource use, to avoid slowing down the master. If balance=true then there is load balancing -- reads are distributed over all the nodes in the replica set in round-robin fashion, with a preference for replicas if prefer_replica=true is also set."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1283
#: ../doc/reference/reference_rock/vshard/index.rst:1325
#: ../doc/reference/reference_rock/vshard/index.rst:1356
#: ../doc/reference/reference_rock/vshard/index.rst:1389
msgid "The original return value of the executed function, or ``nil`` and error object. The error object has a type attribute equal to ``ShardingError`` or one of the regular Tarantool errors (``ClientError``, ``OutOfMemory``, ``SocketError``, etc.)."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1288
msgid "``ShardingError`` is returned on errors specific for sharding: the replica set is not available, the master is missing, wrong bucket id, etc. It has an attribute code containing one of the values from the ``vshard.error.code.*`` LUA table, an optional attribute containing a message with the human-readable error description, and other attributes specific for the error code."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1296
msgid "To call ``customer_add`` function from ``vshard/example``, say:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1298
msgid "vshard.router.call(100, 'write', 'customer_add', {{customer_id = 2, bucket_id = 100, name = 'name2', accounts = {}}}, {timeout = 100})\n"
"-- or, the same thing but with a map for the second argument\n"
"vshard.router.call(100, {mode='write'}, 'customer_add', {{customer_id = 2, bucket_id = 100, name = 'name2', accounts = {}}}, {timeout = 100})"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1308
msgid "Call the function identified by function-name on the shard storing the bucket identified by bucket_id, in read-only mode (similar to calling vshard.router.call with mode='read'). See the :ref:`Processing requests <vshard-process-requests>` section for details on function operation."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1317
#: ../doc/reference/reference_rock/vshard/index.rst:1348
#: ../doc/reference/reference_rock/vshard/index.rst:1381
#: ../doc/reference/reference_rock/vshard/index.rst:1578
#: ../doc/reference/reference_rock/vshard/index.rst:1599
#: ../doc/reference/reference_rock/vshard/index.rst:1618
#: ../doc/reference/reference_rock/vshard/index.rst:1640
msgid "* ``timeout`` – a request timeout, in seconds. In case the ``router`` cannot identify a   shard with the bucket id, the operation will be repeated until the   timeout is reached."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1319
#: ../doc/reference/reference_rock/vshard/index.rst:1350
#: ../doc/reference/reference_rock/vshard/index.rst:1383
#: ../doc/reference/reference_rock/vshard/index.rst:1580
#: ../doc/reference/reference_rock/vshard/index.rst:1601
#: ../doc/reference/reference_rock/vshard/index.rst:1620
#: ../doc/reference/reference_rock/vshard/index.rst:1642
msgid "``timeout`` – a request timeout, in seconds. In case the ``router`` cannot identify a shard with the bucket id, the operation will be repeated until the timeout is reached."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1330
#: ../doc/reference/reference_rock/vshard/index.rst:1361
#: ../doc/reference/reference_rock/vshard/index.rst:1394
msgid "``ShardingError`` is returned on errors specific for sharding: the replica set is not available, the master is missing, wrong bucket id, etc. It has an attribute code containing one of the values from the ``vshard.error.code.*`` LUA table, an optional attribute containing a message with the human-readable error description, and other attributes specific for this error code."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1340
msgid "Call the function identified by function-name on the shard storing the bucket identified by bucket_id, in read-write mode (similar to calling vshard.router.call with mode='write'). See the :ref:`Processing requests <vshard-process-requests>` section for details on function operation."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1371
msgid "Call the function identified by function-name on the shard storing the bucket identified by bucket_id, in read-only mode (similar to calling vshard.router.call with mode='read'), with preference for a replica rather than a master (similar to calling vshard.router.call with prefer_replica = true). See the :ref:`Processing requests <vshard-process-requests>` section for details on function operation."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1404
msgid "This has the same effect as :ref:`vshard.router.call() <router_api-call>` with mode parameter = {mode='read', balance=true}."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1412
msgid "This has the same effect as :ref:`vshard.router.call() <router_api-call>` with mode parameter = {mode='read', balance=true, prefer_replica=true}."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1420
msgid "Return the replica set object for the bucket with the specified bucket id value."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1424
#: ../doc/reference/reference_rock/vshard/index.rst:1439
msgid "a replica set object"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1428
msgid "replicaset = vshard.router.route(123)"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1436
msgid "Return all available replica set objects."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1438
msgid "a map of the following type: ``{UUID = replicaset}``"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1443
msgid "replicaset = vshard.router.routeall()"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1451
msgid "Calculate the bucket id using a simple built-in hash function."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1453
msgid "a hash key. This can be any Lua object (number, table, string)."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1460
msgid "bucket_id = vshard.router.bucket_id(18374927634039)"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1468
msgid "Return the total number of buckets specified in ``vshard.router.cfg()``."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1470
msgid "the total number of buckets"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1477
#: ../doc/reference/reference_rock/vshard/index.rst:1756
msgid "Wait until the dataset is synchronized on replicas."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1479
#: ../doc/reference/reference_rock/vshard/index.rst:1758
msgid "a timeout, in seconds"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1481
#: ../doc/reference/reference_rock/vshard/index.rst:1760
msgid "``true`` if the dataset was synchronized successfully; or ``nil`` and ``err`` explaining why the dataset cannot be synchronized."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1488
msgid "Force wakeup of the bucket discovery fiber."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1494
msgid "Return information about each instance."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1498
msgid "Replica set parameters:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1500
msgid "replica set uuid"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1501
msgid "master instance parameters"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1502
msgid "replica instance parameters"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1504
msgid "Instance parameters:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1506
msgid "``uri`` — URI of the instance"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1507
msgid "``uuid`` — UUID of the instance"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1508
msgid "``status`` – status of the instance (``available``, ``unreachable``, ``missing``)"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1509
msgid "``network_timeout`` – a timeout for the request. The value is updated automatically on each 10th successful request and each 2nd failed request."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1512
msgid "Bucket parameters:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1514
msgid "``available_ro`` – the number of buckets known to the ``router`` and available for read requests"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1515
msgid "``available_rw`` – the number of buckets known to the router and available for read and write requests"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1516
msgid "``unavailable`` – the number of buckets known to the ``router`` but unavailable for any requests"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1517
msgid "``unreachable`` – the number of buckets whose replica sets are not known to the ``router``"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1521
msgid "tarantool> vshard.router.info()\n"
"---\n"
"- replicasets:\n"
"    ac522f65-aa94-4134-9f64-51ee384f1a54:\n"
"      replica: &0\n"
"        network_timeout: 0.5\n"
"        status: available\n"
"        uri: storage@127.0.0.1:3303\n"
"        uuid: 1e02ae8a-afc0-4e91-ba34-843a356b8ed7\n"
"      uuid: ac522f65-aa94-4134-9f64-51ee384f1a54\n"
"      master: *0\n"
"    cbf06940-0790-498b-948d-042b62cf3d29:\n"
"      replica: &1\n"
"        network_timeout: 0.5\n"
"        status: available\n"
"        uri: storage@127.0.0.1:3301\n"
"        uuid: 8a274925-a26d-47fc-9e1b-af88ce939412\n"
"      uuid: cbf06940-0790-498b-948d-042b62cf3d29\n"
"      master: *1\n"
"  bucket:\n"
"    unreachable: 0\n"
"    available_ro: 0\n"
"    unknown: 0\n"
"    available_rw: 3000\n"
"  status: 0\n"
"  alerts: []\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1555
msgid "Return information about each bucket. Since a bucket map can be huge, only the required range of buckets can be specified."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1558
msgid "the offset in a bucket map of the first bucket to show"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1559
msgid "the maximum number of buckets to show"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1561
msgid "a map of the following type: ``{bucket_id = 'unknown'/replicaset_uuid}``"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1567
msgid "Call a function on a nearest available master (distances are defined using ``replica.zone`` and ``cfg.weights`` matrix) with specified arguments."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1573
msgid "The ``replicaset.call`` method is similar to ``replicaset.callrw``."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1575
#: ../doc/reference/reference_rock/vshard/index.rst:1596
#: ../doc/reference/reference_rock/vshard/index.rst:1615
#: ../doc/reference/reference_rock/vshard/index.rst:1637
msgid "UUID of a replica set"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1576
#: ../doc/reference/reference_rock/vshard/index.rst:1597
#: ../doc/reference/reference_rock/vshard/index.rst:1616
#: ../doc/reference/reference_rock/vshard/index.rst:1638
#: ../doc/reference/reference_rock/vshard/index.rst:1744
msgid "function to execute"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1577
#: ../doc/reference/reference_rock/vshard/index.rst:1598
#: ../doc/reference/reference_rock/vshard/index.rst:1617
#: ../doc/reference/reference_rock/vshard/index.rst:1639
#: ../doc/reference/reference_rock/vshard/index.rst:1745
msgid "array of the function's arguments"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1588
msgid "Call a function on a nearest available master (distances are defined using ``replica.zone`` and ``cfg.weights`` matrix) with a specified arguments."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1594
msgid "The ``replicaset.callrw`` method is similar to ``replicaset.call``."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1609
msgid "Call a function on the nearest available replica (distances are defined using ``replica.zone`` and ``cfg.weights`` matrix) with specified arguments. It is recommended to call only read-only functions using ``replicaset.callro()``, as the function can be executed not only on a master, but also on replicas."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1628
msgid "Call a function on the nearest available replica (distances are defined using ``replica.zone`` and ``cfg.weights`` matrix) with specified arguments, with preference for a replica rather than a master (similar to calling vshard.router.call with prefer_replica = true). It is recommended to call only read-only functions using ``replicaset.callre()``, as the function can be executed not only on a master, but also on replicas."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1650
msgid "Router internal API"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1652
msgid ":ref:`vshard.router.bucket_discovery(bucket_id) <router_api-bucket_discovery>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1658
msgid "Search for the bucket in the whole cluster. If the bucket is not found, it is likely that it does not exist. The bucket might also be moved during rebalancing and currently is in the RECEIVING state."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1668
msgid "Storage public API"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1670
msgid ":ref:`vshard.storage.cfg(cfg, name) <storage_api-cfg>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1671
msgid ":ref:`vshard.storage.info() <storage_api-info>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1672
msgid ":ref:`vshard.storage.call(bucket_id, mode, function_name, {argument_list}) <storage_api-call>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1673
msgid ":ref:`vshard.storage.sync(timeout) <storage_api-sync>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1674
msgid ":ref:`vshard.storage.bucket_pin(bucket_id) <storage_api-bucket_pin>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1675
msgid ":ref:`vshard.storage.bucket_unpin(bucket_id) <storage_api-bucket_unpin>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1676
msgid ":ref:`vshard.storage.bucket_ref(bucket_id, mode) <storage_api-bucket_ref>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1677
msgid ":ref:`vshard.storage.bucket_refro() <storage_api-bucket_refro>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1678
msgid ":ref:`vshard.storage.bucket_refrw() <storage_api-bucket_refrw>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1679
msgid ":ref:`vshard.storage.bucket_unref(bucket_id, mode) <storage_api-bucket_unref>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1680
msgid ":ref:`vshard.storage.bucket_unrefro() <storage_api-bucket_unrefro>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1681
msgid ":ref:`vshard.storage.bucket_unrefrw() <storage_api-bucket_unrefrw>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1682
msgid ":ref:`vshard.storage.find_garbage_bucket(bucket_index, control) <storage_api-find_garbage_bucket>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1683
msgid ":ref:`vshard.storage.rebalancer_disable() <storage_api-rebalancer_disable>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1684
msgid ":ref:`vshard.storage.rebalancer_enable() <storage_api-rebalancer_enable>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1685
msgid ":ref:`vshard.storage.is_locked() <storage_api-is_locked>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1686
msgid ":ref:`vshard.storage.rebalancing_is_in_progress() <storage_api-rebalancing_is_in_progress>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1687
msgid ":ref:`vshard.storage.buckets_info() <storage_api-buckets_info>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1688
msgid ":ref:`vshard.storage.buckets_count() <storage_api-buckets_count>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1689
msgid ":ref:`vshard.storage.sharded_spaces() <storage_api-sharded_spaces>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1695
msgid "Configure the database and start sharding for the specified ``storage`` instance."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1698
msgid "a ``storage`` configuration"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1699
msgid "UUID of the instance"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1705
msgid "Return information about the storage instance in the following format:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1707
msgid "tarantool> vshard.storage.info()\n"
"---\n"
"- buckets:\n"
"    2995:\n"
"      status: active\n"
"      id: 2995\n"
"    2997:\n"
"      status: active\n"
"      id: 2997\n"
"    2999:\n"
"      status: active\n"
"      id: 2999\n"
"  replicasets:\n"
"    2dd0a343-624e-4d3a-861d-f45efc571cd3:\n"
"      uuid: 2dd0a343-624e-4d3a-861d-f45efc571cd3\n"
"      master:\n"
"        state: active\n"
"        uri: storage:storage@127.0.0.1:3301\n"
"        uuid: 2ec29309-17b6-43df-ab07-b528e1243a79\n"
"    c7ad642f-2cd8-4a8c-bb4e-4999ac70bba1:\n"
"      uuid: c7ad642f-2cd8-4a8c-bb4e-4999ac70bba1\n"
"      master:\n"
"        state: active\n"
"        uri: storage:storage@127.0.0.1:3303\n"
"        uuid: 810d85ef-4ce4-4066-9896-3c352fec9e64\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1740
msgid "Call the specified function on the current ``storage`` instance."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1743
msgid "a type of the function: 'read' or 'write'"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1749
msgid "The original return value of the executed function, or ``nil`` and error object."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1767
msgid "Pin a bucket to a replica set. A pinned bucket cannot be moved even if it breaks the cluster balance."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1772
msgid "``true`` if the bucket is pinned successfully; or ``nil`` and ``err`` explaining why the bucket cannot be pinned"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1779
msgid "Return a pinned bucket back into the active state."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1783
msgid "``true`` if the bucket is unpinned successfully; or ``nil`` and ``err`` explaining why the bucket cannot be unpinned"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1790
msgid "Create an RO or RW :ref:`ref <vshard-ref>`."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1793
#: ../doc/reference/reference_rock/vshard/index.rst:1819
msgid "'read' or 'write'"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1795
msgid "``true`` if the bucket ref is created successfully; or ``nil`` and ``err`` explaining why the ref cannot be created"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1802
msgid "An alias for :ref:`vshard.storage.bucket_ref <storage_api-bucket_ref>` in the RO mode."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1809
msgid "An alias for :ref:`vshard.storage.bucket_ref <storage_api-bucket_ref>` in the RW mode."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1816
msgid "Remove a RO/RW :ref:`ref <vshard-ref>`."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1821
msgid "``true`` if the bucket ref is removed successfully; or ``nil`` and ``err`` explaining why the ref cannot be removed"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1828
msgid "An alias for :ref:`vshard.storage.bucket_unref <storage_api-bucket_unref>` in the RO mode."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1835
msgid "An alias for :ref:`vshard.storage.bucket_unref <storage_api-bucket_unref>` in the RW mode."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1842
msgid "Find a bucket which has data in a space but is not stored in a ``_bucket`` space; or is in a GARBAGE state."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1845
msgid "index of a space with the part of a bucket id"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1846
msgid "a garbage collector controller. If there is an increased buckets generation, then the search should be interrupted."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1849
msgid "an identifier of the bucket in the garbage state, if found; otherwise, nil"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1856
msgid "Return information about each bucket located in storage. For example:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1874
msgid "Return the number of buckets located in storage."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1880
msgid "Immediately wake up a recovery fiber, if it exists."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1886
msgid "Return a flag indicating whether rebalancing is in progress. The result is true if the node is currently applying routes received from a rebalancer node in the special fiber."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1894
msgid "Return a flag indicating whether storage is invisible to the rebalancer."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1900
msgid "Disable rebalancing. A disabled rebalancer sleeps until it is enabled again with vshard.storage.rebalancer_enable()."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1907
msgid "Enable rebalancing."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1913
msgid "Show the spaces that are visible to rebalancer and garbage collector fibers."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1919
msgid "Storage internal API"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1921
msgid ":ref:`vshard.storage.bucket_stat(bucket_id) <storage_api-bucket_stat>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1922
msgid ":ref:`vshard.storage.bucket_recv(bucket_id, from, data) <storage_api-bucket_recv>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1923
msgid ":ref:`vshard.storage.bucket_delete_garbage(bucket_id) <storage_api-bucket_delete_garbage>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1924
msgid ":ref:`vshard.storage.bucket_collect(bucket_id) <storage_api-bucket_collect>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1925
msgid ":ref:`vshard.storage.bucket_force_create(first_bucket_id, count) <storage_api-bucket_force_create>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1926
msgid ":ref:`vshard.storage.bucket_force_drop(bucket_id, to) <storage_api-bucket_force_drop>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1927
msgid ":ref:`vshard.storage.bucket_send(bucket_id, to) <storage_api-bucket_send>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1928
msgid ":ref:`vshard.storage.buckets_discovery() <storage_api-buckets_discovery>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1929
msgid ":ref:`vshard.storage.rebalancer_request_state() <storage_api-rebalancer_request_state>`"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1935
msgid "Receive a bucket identified by bucket id from a remote replica set."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1938
msgid "UUID of source replica set"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1939
msgid "data logically stored in a bucket identified by bucket_id, in the same format as the return value from ``bucket_collect() <storage_api-bucket_collect>``"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1946
msgid "Return information about the bucket id:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1948
msgid "tarantool> vshard.storage.bucket_stat(1)\n"
"---\n"
"- 0\n"
"- status: active\n"
"  id: 1\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1963
msgid "Force garbage collection for the bucket identified by bucket_id in case the bucket was transferred to a different replica set."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1972
msgid "Collect all the data that is logically stored in the bucket identified by bucket_id:"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1974
msgid "tarantool> vshard.storage.bucket_collect(1)\n"
"---\n"
"- 0\n"
"- - - 514\n"
"    - - [10, 1, 1, 100, 'Account 10']\n"
"      - [11, 1, 1, 100, 'Account 11']\n"
"      - [12, 1, 1, 100, 'Account 12']\n"
"      - [50, 5, 1, 100, 'Account 50']\n"
"      - [51, 5, 1, 100, 'Account 51']\n"
"      - [52, 5, 1, 100, 'Account 52']\n"
"  - - 513\n"
"    - - [1, 1, 'Customer 1']\n"
"      - [5, 1, 'Customer 5']\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:1997
msgid "Force creation of the buckets (single or multiple) on the current replica set. Use only for manual emergency recovery or for initial bootstrap."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2000
msgid "an identifier of the first bucket in a range"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2001
msgid "the number of buckets to insert (default = 1)"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2007
msgid "Drop a bucket manually for tests or emergency cases."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2015
msgid "Send a specified bucket from the current replica set to a remote replica set."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2017
msgid "bucket identifier"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2018
msgid "UUID of a remote replica set"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2024
msgid "Check all buckets of the host storage that have the SENT or ACTIVE state, return the number of active buckets."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2027
msgid "the number of buckets in the active state, if found; otherwise, nil"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2033
msgid "Collect an array of active bucket identifiers for discovery."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2039
msgid "Glossary"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2044
msgid "**Vertical scaling**"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2046
msgid "Adding more power to a single server: using a more powerful CPU, adding more capacity to RAM, adding more storage space, etc."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2050
msgid "**Horizontal scaling**"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2052
msgid "Adding more servers to the pool of resources, then partitioning and distributing a dataset across the servers."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2056
msgid "**Sharding**"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2058
msgid "A database architecture that allows partitioning a dataset using a sharding key and distributing a dataset across multiple servers. Sharding is a special case of horizontal scaling."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2063
msgid "**Node**"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2065
msgid "A virtual or physical server instance."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2068
msgid "**Cluster**"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2070
msgid "A set of nodes that make up a single group."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2073
msgid "**Storage**"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2075
msgid "A node storing a subset of a dataset."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2080
msgid "A set of storage nodes storing copies of a dataset. Each storage in a replica set has a role, master or replica."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2084
msgid "**Master**"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2086
msgid "A storage in a replica set processing read and write requests."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2091
msgid "A storage in a replica set processing only read requests."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2094
msgid "**Read requests**"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2096
msgid "Read-only requests, that is, select requests."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2099
msgid "**Write requests**"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2101
msgid "Data-change operations, that is create, replace, update, delete requests."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2104
msgid "**Buckets (virtual buckets)**"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2106
msgid "The abstract virtual nodes into which the dataset is partitioned by the sharding key (bucket id)."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2110
msgid "**Bucket id**"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2112
msgid "A sharding key defining which bucket belongs to which replica set. A bucket id may be calculated from a :ref:`hash key <router_api-bucket_id>`."
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2116
msgid "**Router**"
msgstr ""

#: ../doc/reference/reference_rock/vshard/index.rst:2118
msgid "A proxy server responsible for routing requests from an application to nodes in a cluster."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:5
msgid "Utility `tarantoolctl`"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:7
msgid "``tarantoolctl`` is a utility for administering Tarantool :ref:`instances <tarantoolctl-instance_management>`, :ref:`checkpoint files <tarantoolctl-checkpoint_management>` and :ref:`modules <tarantoolctl-module_management>`. It is shipped and installed as part of Tarantool distribution."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:13
msgid "See also ``tarantoolctl`` usage examples in :ref:`Server administration <admin>` section."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:20
msgid "Command format"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:22
msgid "``tarantoolctl COMMAND NAME [URI] [FILE] [OPTIONS..]``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:24
msgid "where:"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:26
msgid "``COMMAND`` is one of the following: ``start``, ``stop``, ``status``, ``restart``, ``logrotate``, ``check``, ``enter``, ``eval``, ``connect``, ``cat``, ``play``, ``rocks``."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:30
msgid "``NAME`` is the name of an :ref:`instance file <admin-instance_file>` or a :ref:`module <app_server-modules>`."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:33
msgid "``FILE`` is the path to some file (.lua, .xlog or .snap)."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:35
msgid "``URI`` is the URI of some Tarantool instance."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:37
msgid "``OPTIONS`` are options taken by some ``tarantoolctl`` commands."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:43
msgid "Commands for managing Tarantool instances"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:61
msgid "``tarantoolctl start NAME``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:46
msgid "Start a Tarantool instance."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:48
msgid "Additionally, this command sets the TARANTOOLCTL environment variable to 'true', to mark that the instance was started by ``tarantoolctl``."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:53
msgid "``tarantoolctl`` works for instances without ``box.cfg{}`` called or with delayed ``box.cfg{}`` call."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:56
msgid "For example, this can be used to manage instances which receive configuration from an external server. For such instances, ``tarantoolctl start`` goes to background when ``box.cfg{}`` is called, so it will wait until options for ``box.cfg`` are received. However this is not the case for daemon management systems like ``systemd``, as they handle backgrounding on their side."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:64
msgid "``tarantoolctl stop NAME``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:64
msgid "Stop a Tarantool instance."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:72
msgid "``tarantoolctl status NAME``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:67
msgid "Show an instance's status (started/stopped). If pid file exists and an alive control socket exists, the return code is ``0``. Otherwise, the return code is not ``0``."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:71
msgid "Reports typical problems to stderr (e.g. pid file exists and control socket doesn't)."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:79
msgid "``tarantoolctl restart NAME``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:75
msgid "Stop and start a Tarantool instance."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:77
msgid "Additionally, this command sets the TARANTOOL_RESTARTED environment variable to 'true', to mark that the instance was restarted by ``tarantoolctl``."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:84
msgid "``tarantoolctl logrotate NAME``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:82
msgid "Rotate logs of a started Tarantool instance. Works only if logging-into-file is enabled in the instance file. Pipe/syslog make no effect."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:87
msgid "``tarantoolctl check NAME``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:87
msgid "Check an instance file for syntax errors."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:90
msgid "``tarantoolctl enter NAME``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:90
msgid "Enter an instance's interactive Lua console."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:93
msgid "``tarantoolctl eval NAME FILE``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:93
msgid "Evaluate a local Lua file on a running Tarantool instance."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:97
msgid "``tarantoolctl connect URI``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:96
msgid "Connect to a Tarantool instance on an admin-console port. Supports both TCP/Unix sockets."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:103
msgid "Commands for managing checkpoint files"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:106
msgid "``tarantoolctl cat FILE.. [--space=space_no ..] [--show-system] [--from=from_lsn] [--to=to_lsn] [--replica=replica_id ..]``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:106
msgid "Print into stdout the contents of .snap/.xlog files."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:109
msgid "``tarantoolctl play URI FILE.. [--space=space_no ..] [--show-system] [--from=from_lsn] [--to=to_lsn] [--replica=replica_id ..]``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:109
msgid "Play the contents of .snap/.xlog files to another Tarantool instance."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:111
#: ../doc/reference/tarantoolctl.rst:162
msgid "Supported options:"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:113
msgid "``--space=space_no`` to filter the output by space number. May be passed more than once."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:115
msgid "``--show-system`` to show the contents of system spaces."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:116
msgid "``--from=from_lsn`` to show operations starting from the given lsn."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:117
msgid "``--to=to_lsn`` to show operations ending with the given lsn."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:118
msgid "``--replica=replica_id`` to filter the output by replica id. May be passed more than once."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:125
msgid "Commands for managing Tarantool modules"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:128
msgid "``tarantoolctl rocks install NAME``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:128
msgid "Install a module in the current directory."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:131
msgid "``tarantoolctl rocks remove NAME``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:131
msgid "Remove a module."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:134
msgid "``tarantoolctl rocks show NAME``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:134
msgid "Show information about an installed module."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:137
msgid "``tarantoolctl rocks search NAME``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:137
msgid "Search the repository for modules."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:140
msgid "``tarantoolctl rocks list``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:140
msgid "List all installed modules."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:150
msgid "``tarantoolctl rocks pack {<rockspec> | <name> [<version>]}``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:143
msgid "Create a rock by packing sources or binaries."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:145
#: ../doc/reference/tarantoolctl.rst:155
msgid "As an argument, you can specify:"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:147
msgid "a ``.rockspec`` file to create a source rock containing the module's sources, or"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:149
msgid "the name of an installed module (and its version if there are more than one) to create a binary rock containing the compiled module."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:160
msgid "``tarantoolctl rocks unpack {<rock_file> | <rockspec> | <name> [version]}``"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:153
msgid "Unpack the contents of a rock into a new directory under the current one."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:157
msgid "source or binary rock files,"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:158
msgid "``.rockspec`` files, or"
msgstr ""

#: ../doc/reference/tarantoolctl.rst:159
msgid "names of rocks or ``.rockspec`` files in remote repositories (and the rock version if there are more than one)."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:164
msgid "``--server=server_name`` check this server first, then the usual list."
msgstr ""

#: ../doc/reference/tarantoolctl.rst:165
msgid "``--only-server=server_name`` check this server only, ignore the usual list."
msgstr ""

