
msgid "Submodule `box.schema`"
msgstr ""

msgid "Overview"
msgstr ""

msgid "The ``box.schema`` submodule has data-definition functions for spaces, users, roles, function tuples, and sequences."
msgstr ""

msgid "Index"
msgstr ""

msgid "Below is a list of all ``box.schema`` functions."
msgstr ""

msgid "Name"
msgstr ""

msgid "Use"
msgstr ""

msgid ":ref:`box.schema.space.create() <box_schema-space_create>` or :ref:`box.schema.create_space() <box_schema-space_create>`"
msgstr ""

msgid "Create a space"
msgstr ""

msgid ":ref:`box.schema.upgrade <admin-upgrades>`"
msgstr ""

msgid "Upgrade a database"
msgstr ""

msgid ":ref:`box.schema.user.create() <box_schema-user_create>`"
msgstr ""

msgid "Create a user"
msgstr ""

msgid ":ref:`box.schema.user.drop() <box_schema-user_drop>`"
msgstr ""

msgid "Drop a user"
msgstr ""

msgid ":ref:`box.schema.user.exists() <box_schema-user_exists>`"
msgstr ""

msgid "Check if a user exists"
msgstr ""

msgid ":ref:`box.schema.user.grant() <box_schema-user_grant>`"
msgstr ""

msgid "Grant privileges to a user or a role"
msgstr ""

msgid ":ref:`box.schema.user.revoke() <box_schema-user_revoke>`"
msgstr ""

msgid "Revoke privileges from a user or a role"
msgstr ""

msgid ":ref:`box.schema.user.password() <box_schema-user_password>`"
msgstr ""

msgid "Get a hash of a user's password"
msgstr ""

msgid ":ref:`box.schema.user.passwd() <box_schema-user_passwd>`"
msgstr ""

msgid "Associate a password with a user"
msgstr ""

msgid ":ref:`box.schema.user.info() <box_schema-user_info>`"
msgstr ""

msgid "Get a description of a user's privileges"
msgstr ""

msgid ":ref:`box.schema.role.create() <box_schema-role_create>`"
msgstr ""

msgid "Create a role"
msgstr ""

msgid ":ref:`box.schema.role.drop() <box_schema-role_drop>`"
msgstr ""

msgid "Drop a role"
msgstr ""

msgid ":ref:`box.schema.role.exists() <box_schema-role_exists>`"
msgstr ""

msgid "Check if a role exists"
msgstr ""

msgid ":ref:`box.schema.role.grant() <box_schema-role_grant>`"
msgstr ""

msgid "Grant privileges to a role"
msgstr ""

msgid ":ref:`box.schema.role.revoke() <box_schema-role_revoke>`"
msgstr ""

msgid "Revoke privileges from a role"
msgstr ""

msgid ":ref:`box.schema.role.info() <box_schema-role_info>`"
msgstr ""

msgid "Get a description of a role's privileges"
msgstr ""

msgid ":ref:`box.schema.func.create() <box_schema-func_create>`"
msgstr ""

msgid "Create a function tuple"
msgstr ""

msgid ":ref:`box.schema.func.drop() <box_schema-func_drop>`"
msgstr ""

msgid "Drop a function tuple"
msgstr ""

msgid ":ref:`box.schema.func.exists() <box_schema-func_exists>`"
msgstr ""

msgid "Check if a function tuple exists"
msgstr ""

msgid ":ref:`box.schema.sequence.create() <box_schema-sequence_create>`"
msgstr ""

msgid "Create a new sequence generator"
msgstr ""

msgid ":ref:`sequence_object:next() <box_schema-sequence_next>`"
msgstr ""

msgid "Generate and return the next value"
msgstr ""

msgid ":ref:`sequence_object:alter() <box_schema-sequence_alter>`"
msgstr ""

msgid "Change sequence options"
msgstr ""

msgid ":ref:`sequence_object:reset() <box_schema-sequence_reset>`"
msgstr ""

msgid "Reset sequence state"
msgstr ""

msgid ":ref:`sequence_object:set() <box_schema-sequence_set>`"
msgstr ""

msgid "Set the new value"
msgstr ""

msgid ":ref:`sequence_object:current() <box_schema-sequence_current>`"
msgstr ""

msgid "Return the last retrieved value"
msgstr ""

msgid ":ref:`sequence_object:drop() <box_schema-sequence_drop>`"
msgstr ""

msgid "Drop the sequence"
msgstr ""

msgid ":ref:`space_object:create_index() <box_schema-sequence_create_index>`"
msgstr ""

msgid "Create an index"
msgstr ""

msgid "Create a :ref:`space <index-box_space>`."
msgstr ""

msgid "Parameters"
msgstr ""

msgid "name of space, which should conform to the :ref:`rules for object names <app_server-names>`"
msgstr ""

msgid "see \"Options for box.schema.space.create\" chart, below"
msgstr ""

msgid "return"
msgstr ""

msgid "space object"
msgstr ""

msgid "rtype"
msgstr ""

msgid "userdata"
msgstr ""

msgid "You can use either syntax. For example, ``s = box.schema.space.create('tester')`` has the same effect as ``s = box.schema.create_space('tester')``."
msgstr ""

msgid "**Options for box.schema.space.create**"
msgstr ""

msgid "Effect"
msgstr ""

msgid "Type"
msgstr ""

msgid "Default"
msgstr ""

msgid "engine"
msgstr ""

msgid "'memtx' or 'vinyl'"
msgstr ""

msgid "string"
msgstr ""

msgid "'memtx'"
msgstr ""

msgid "field_count"
msgstr ""

msgid "fixed count of :ref:`fields <index-box_tuple>`: for example if field_count=5, it is illegal to insert a tuple with fewer than or more than 5 fields"
msgstr ""

msgid "number"
msgstr ""

msgid "0 i.e. not fixed"
msgstr ""

msgid "format"
msgstr ""

msgid "field names and types: See the illustrations of format clauses in the :ref:`space_object:format() <box_space-format>` description and in the :ref:`box.space._space <box_space-space>` example. Optional and usually not specified."
msgstr ""

msgid "table"
msgstr ""

msgid "(blank)"
msgstr ""

msgid "id"
msgstr ""

msgid "unique identifier: users can refer to spaces with the id instead of the name"
msgstr ""

msgid "last space's id, +1"
msgstr ""

msgid "if_not_exists"
msgstr ""

msgid "create space only if a space with the same name does not exist already, otherwise do nothing but do not cause an error"
msgstr ""

msgid "boolean"
msgstr ""

msgid "false"
msgstr ""

msgid "is_local"
msgstr ""

msgid "space contents are :ref:`replication-local <replication-local>`: changes are stored in the :ref:`write-ahead log <internals-wal>` of the local node but there is no :ref:`replication <replication>`."
msgstr ""

msgid "temporary"
msgstr ""

msgid "space contents are temporary: changes are not stored in the :ref:`write-ahead log <internals-wal>` and there is no :ref:`replication <replication>`. Note re storage engine: vinyl does not support temporary spaces."
msgstr ""

msgid "user"
msgstr ""

msgid "name of the user who is considered to be the space's :ref:`owner <authentication-owners_privileges>` for authorization purposes"
msgstr ""

msgid "current user's name"
msgstr ""

msgid "There are three :ref:`syntax variations <app_server-object_reference>` for object references targeting space objects, for example :samp:`box.schema.space.drop({space-id})` will drop a space. However, the common approach is to use functions attached to the space objects, for example :ref:`space_object:drop() <box_space-drop>`."
msgstr ""

msgid "**Example**"
msgstr ""

msgid "tarantool> s = box.schema.space.create('space55')\n"
"---\n"
"...\n"
"tarantool> s = box.schema.space.create('space55', {\n"
"         >   id = 555,\n"
"         >   temporary = false\n"
"         > })\n"
"---\n"
"- error: Space 'space55' already exists\n"
"...\n"
"tarantool> s = box.schema.space.create('space55', {\n"
"         >   if_not_exists = true\n"
"         > })\n"
"---\n"
"..."
msgstr ""

msgid "After a space is created, usually the next step is to :ref:`create an index <box_space-create_index>` for it, and then it is available for insert, select, and all the other :ref:`box.space <box_space>` functions."
msgstr ""

msgid "Create a user. For explanation of how Tarantool maintains user data, see section :ref:`Users<authentication-users>` and reference on :ref:`_user <box_space-user>` space."
msgstr ""

msgid "The possible options are:"
msgstr ""

msgid "``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` means there should be no error if the user already exists,"
msgstr ""

msgid "``password`` (default = '') - string; the ``password`` = *password* specification is good because in a :ref:`URI <index-uri>` (Uniform Resource Identifier) it is usually illegal to include a user-name without a password."
msgstr ""

msgid "The maximum number of users is 32."
msgstr ""

msgid "name of user, which should conform to the :ref:`rules for object names <app_server-names>`"
msgstr ""

msgid "``if_not_exists``, ``password``"
msgstr ""

msgid "nil"
msgstr ""

msgid "**Examples:**"
msgstr ""

msgid "box.schema.user.create('Lena')\n"
"box.schema.user.create('Lena', {password = 'X'})\n"
"box.schema.user.create('Lena', {if_not_exists = false})"
msgstr ""

msgid "Drop a user. For explanation of how Tarantool maintains user data, see section :ref:`Users <authentication-users>` and reference on :ref:`_user <box_space-user>` space."
msgstr ""

msgid "the name of the user"
msgstr ""

msgid "``if_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` means there should be no error if the user does not exist."
msgstr ""

msgid "box.schema.user.drop('Lena')\n"
"box.schema.user.drop('Lena',{if_exists=false})"
msgstr ""

msgid "Return ``true`` if a user exists; return ``false`` if a user does not exist. For explanation of how Tarantool maintains user data, see section :ref:`Users <authentication-users>` and reference on :ref:`_user <box_space-user>` space."
msgstr ""

msgid "bool"
msgstr ""

msgid "**Example:**"
msgstr ""

msgid "box.schema.user.exists('Lena')"
msgstr ""

msgid "Grant :ref:`privileges <authentication-owners_privileges>` to a user or to another role."
msgstr ""

msgid "the name of the user."
msgstr ""

msgid "'read' or 'write' or 'execute' or 'create' or 'alter' or 'drop' or a combination."
msgstr ""

msgid "'space' or 'function' or 'sequence' or 'role'."
msgstr ""

msgid "name of object to grant permissions for."
msgstr ""

msgid "name of role to grant to user."
msgstr ""

msgid "``grantor``, ``if_not_exists``."
msgstr ""

msgid "If :samp:`'function','{object-name}'` is specified, then a _func tuple with that object-name must exist."
msgstr ""

msgid "**Variation:** instead of ``object-type, object-name`` say 'universe' which means 'all object-types and all objects'. In this case, object name is omitted."
msgstr ""

msgid "**Variation:** instead of ``privilege, object-type, object-name`` say ``role-name`` (see section :ref:`Roles <authentication-roles>`)."
msgstr ""

msgid "**Variation:** instead of :samp:`box.schema.user.grant('{user-name}','usage,session','universe',nil,` :code:`{if_not_exists=true})` say :samp:`box.schema.user.enable('{user-name}')`."
msgstr ""

msgid "``grantor`` = *grantor_name_or_id* -- string or number, for custom grantor,"
msgstr ""

msgid "``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` means there should be no error if the user already has the privilege."
msgstr ""

msgid "box.schema.user.grant('Lena', 'read', 'space', 'tester')\n"
"box.schema.user.grant('Lena', 'execute', 'function', 'f')\n"
"box.schema.user.grant('Lena', 'read,write', 'universe')\n"
"box.schema.user.grant('Lena', 'Accountant')\n"
"box.schema.user.grant('Lena', 'read,write,execute', 'universe')\n"
"box.schema.user.grant('X', 'read', 'universe', nil, {if_not_exists=true}))"
msgstr ""

msgid "Revoke :ref:`privileges <authentication-owners_privileges>` from a user or from another role."
msgstr ""

msgid "'space' or 'function' or 'sequence'."
msgstr ""

msgid "the name of a function or space or sequence."
msgstr ""

msgid "``if_exists``."
msgstr ""

msgid "The user must exist, and the object must exist, but if the option setting is ``{if_exists=true}`` then it is not an error if the user does not have the privilege."
msgstr ""

msgid "**Variation:** instead of ``object-type, object-name`` say 'universe' which means 'all object-types and all objects'."
msgstr ""

msgid "**Variation:** instead of :samp:`box.schema.user.revoke('{user-name}','usage,session','universe',nil,` :code:`{if_exists=true})` say :samp:`box.schema.user.disable('{user-name}')`."
msgstr ""

msgid "box.schema.user.revoke('Lena', 'read', 'space', 'tester')\n"
"box.schema.user.revoke('Lena', 'execute', 'function', 'f')\n"
"box.schema.user.revoke('Lena', 'read,write', 'universe')\n"
"box.schema.user.revoke('Lena', 'Accountant')"
msgstr ""

msgid "Return a hash of a user's password. For explanation of how Tarantool maintains passwords, see section :ref:`Passwords <authentication-passwords>` and reference on :ref:`_user <box_space-user>` space."
msgstr ""

msgid "If a non-'guest' user has no password, it’s **impossible** to connect to Tarantool using this user. The user is regarded as “internal” only, not usable from a remote connection. Such users can be useful if they have defined some procedures with the :ref:`SETUID <box_schema-func_create>` option, on which privileges are granted to externally-connectable users. This way, external users cannot create/drop objects, they can only invoke procedures."
msgstr ""

msgid "For the 'guest' user, it’s impossible to set a password: that would be misleading, since 'guest' is the default user on a newly-established connection over a :ref:`binary port <admin-security>`, and Tarantool does not require a password to establish a :ref:`binary connection <box_protocol-iproto_protocol>`. It is, however, possible to change the current user to ‘guest’ by providing the :ref:`AUTH packet <box_protocol-authentication>` with no password at all or an empty password. This feature is useful for connection pools, which want to reuse a connection for a different user without re-establishing it."
msgstr ""

msgid "password to be hashed"
msgstr ""

msgid "box.schema.user.password('ЛЕНА')"
msgstr ""

msgid "Associate a password with the user who is currently logged in, or with the user specified by user-name. The user must exist and must not be 'guest'."
msgstr ""

msgid "Users who wish to change their own passwords should use ``box.schema.user.passwd(password)`` syntax."
msgstr ""

msgid "Administrators who wish to change passwords of other users should use ``box.schema.user.passwd(user-name, password)`` syntax."
msgstr ""

msgid "user-name"
msgstr ""

msgid "password"
msgstr ""

msgid "box.schema.user.passwd('ЛЕНА')\n"
"box.schema.user.passwd('Lena', 'ЛЕНА')"
msgstr ""

msgid "Return a description of a user's :ref:`privileges <authentication-owners_privileges>`."
msgstr ""

msgid "Create a role. For explanation of how Tarantool maintains role data, see section :ref:`Roles <authentication-roles>`."
msgstr ""

msgid "name of role, which should conform to the :ref:`rules for object names <app_server-names>`"
msgstr ""

msgid "``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` means there should be no error if the role already exists"
msgstr ""

msgid "box.schema.role.create('Accountant')\n"
"box.schema.role.create('Accountant', {if_not_exists = false})"
msgstr ""

msgid "Drop a role. For explanation of how Tarantool maintains role data, see section :ref:`Roles <authentication-roles>`."
msgstr ""

msgid "the name of the role"
msgstr ""

msgid "``if_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` means there should be no error if the role does not exist."
msgstr ""

msgid "box.schema.role.drop('Accountant')"
msgstr ""

msgid "Return ``true`` if a role exists; return ``false`` if a role does not exist."
msgstr ""

msgid "box.schema.role.exists('Accountant')"
msgstr ""

msgid "Grant :ref:`privileges <authentication-owners_privileges>` to a role."
msgstr ""

msgid "the name of the role."
msgstr ""

msgid "the name of a function or space or sequence or role."
msgstr ""

msgid "``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` means there should be no error if the role already has the privilege."
msgstr ""

msgid "The role must exist, and the object must exist."
msgstr ""

msgid "**Variation:** instead of ``privilege, object-type, object-name`` say ``role-name`` -- to grant a role to a role."
msgstr ""

msgid "box.schema.role.grant('Accountant', 'read', 'space', 'tester')\n"
"box.schema.role.grant('Accountant', 'execute', 'function', 'f')\n"
"box.schema.role.grant('Accountant', 'read,write', 'universe')\n"
"box.schema.role.grant('public', 'Accountant')\n"
"box.schema.role.grant('role1', 'role2', nil, nil, {if_not_exists=false})"
msgstr ""

msgid "Revoke :ref:`privileges <authentication-owners_privileges>` from a role."
msgstr ""

msgid "The role must exist, and the object must exist, but it is not an error if the role does not have the privilege."
msgstr ""

msgid "**Variation:** instead of ``privilege, object-type, object-name`` say ``role-name``."
msgstr ""

msgid "box.schema.role.revoke('Accountant', 'read', 'space', 'tester')\n"
"box.schema.role.revoke('Accountant', 'execute', 'function', 'f')\n"
"box.schema.role.revoke('Accountant', 'read,write', 'universe')\n"
"box.schema.role.revoke('public', 'Accountant')"
msgstr ""

msgid "Return a description of a role's privileges."
msgstr ""

msgid "box.schema.role.info('Accountant')"
msgstr ""

msgid "Create a function :ref:`tuple <index-box_tuple>`. without including the ``body`` option. (For functions created with the ``body`` option, see :ref:`box.schema.func.create(func-name [, {options-with-body}]) <box_schema-func_create_with-body>`."
msgstr ""

msgid "This is called a \"not persistent\" function because functions without bodies are not persistent. This does not create the function itself -- that is done with Lua -- but if it is necessary to grant privileges for a function, box.schema.func.create must be done first. For explanation of how Tarantool maintains function data, see the reference for the :ref:`box.space._func <box_space-func>` space."
msgstr ""

msgid "``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` means there should be no error if the ``_func`` tuple already exists."
msgstr ""

msgid "``setuid`` = ``true|false`` (default = ``false``) - boolean; ``true`` means that Tarantool should treat the function’s caller as the function’s owner, with owner privileges. ``setuid`` works only over :ref:`binary ports <admin-security>`, ``setuid`` does not work if the function is invoked via an :ref:`admin console <admin-security>` or inside a Lua script."
msgstr ""

msgid "``language`` = 'LUA'|'C' (default = ‘LUA’) - string."
msgstr ""

msgid "name of function, which should conform to the :ref:`rules for object names <app_server-names>`"
msgstr ""

msgid "``if_not_exists``, ``setuid``, ``language``."
msgstr ""

msgid "These functions can be called with :samp:`{function-object}:call({arguments})`; however, unlike the case with ordinary functions, array arguments will not be correctly recognized unless they are enclosed in braces."
msgstr ""

msgid "box.schema.func.create('calculate')\n"
"box.schema.func.create('calculate', {if_not_exists = false})\n"
"box.schema.func.create('calculate', {setuid = false})\n"
"box.schema.func.create('calculate', {language = 'LUA'})"
msgstr ""

msgid "Create a function :ref:`tuple <index-box_tuple>`. including the ``body`` option. (For functions created without the ``body`` option, see :ref:`box.schema.func.create(func-name [, {options-without-body}]) <box_schema-func_create>`."
msgstr ""

msgid "This is called a \"persistent\" function because only functions with bodies are persistent. This does create the function itself, the body is a function definition. For explanation of how Tarantool maintains function data, see the reference for the :ref:`box.space._func <box_space-func>` space."
msgstr ""

msgid "``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; same as for :ref:`box.schema.func.create(func-name [, {options-without-body}]) <box_schema-func_create>`."
msgstr ""

msgid "``setuid`` = ``true|false`` (default = ``false``) - boolean; same as for :ref:`box.schema.func.create(func-name [, {options-without-body}]) <box_schema-func_create>`."
msgstr ""

msgid "``language`` = 'LUA'|'C' (default = ‘LUA’) - string. same as for :ref:`box.schema.func.create(func-name [, {options-without-body}]) <box_schema-func_create>`."
msgstr ""

msgid "``is_sandboxed`` = ``true|false`` (default = ``false``) - boolean; whether the function should be executed in a sandbox."
msgstr ""

msgid "``is_deterministic`` = ``true|false`` (default = ``false``) - boolean; ``true`` means that the function should be deterministic, ``false`` means that the function may or may not be deterministic."
msgstr ""

msgid "``body`` = function definition (default = nil) - string; the function definition."
msgstr ""

msgid "Additional options for SQL = See :ref:`Calling Lua routines from SQL <sql_calling_lua>`."
msgstr ""

msgid "``if_not_exists``, ``setuid``, ``language``, ``is_sandboxed``, ``is_deterministic``, ``body``."
msgstr ""

msgid "C functions are imported from .so files, Lua functions can be defined within ``body``. We will only describe Lua functions in this section."
msgstr ""

msgid "A function tuple with a body is \"persistent\" because the tuple is stored in a snapshot and is recoverable if the server restarts. All of the option values described in this section are visible in the :ref:`box.space._func <box_space-func>` system space."
msgstr ""

msgid "If ``is_sandboxed`` is true, then the function will be executed in an isolated environment: any operation that accesses the world outside the sandbox will be forbidden or will have no effect. Therefore a sandboxed function can only use modules and functions which cannot affect isolation: `assert <https://www.lua.org/manual/5.1/manual.html#pdf-assert>`_, `error <https://www.lua.org/manual/5.1/manual.html#pdf-error>`_, `ipairs <https://www.lua.org/manual/5.1/manual.html#pdf-ipairs>`_, `math.* <https://www.lua.org/manual/5.1/manual.html#5.6>`_, `next <https://www.lua.org/manual/5.1/manual.html#pdf-next>`_, `pairs <https://www.lua.org/manual/5.1/manual.html#pdf-pairs>`_, `pcall <https://www.lua.org/manual/5.1/manual.html#pdf-pcall>`_, `print <https://www.lua.org/manual/5.1/manual.html#pdf-print>`_, `select <https://www.lua.org/manual/5.1/manual.html#pdf-select>`_, `string.* <https://www.lua.org/manual/5.1/manual.html#5.4>`_, `table.* <https://www.lua.org/manual/5.1/manual.html#5.5>`_, `tonumber <https://www.lua.org/manual/5.1/manual.html#pdf-tonumber>`_, `tostring <https://www.lua.org/manual/5.1/manual.html#pdf-tostring>`_, `type <https://www.lua.org/manual/5.1/manual.html#pdf-type>`_, `unpack <https://www.lua.org/manual/5.1/manual.html#pdf-unpack>`_, :ref:`utf8.* <utf8-module>`, `xpcall <https://www.lua.org/manual/5.1/manual.html#pdf-xpcall>`_. Also a sandboxed function cannot refer to global variables -- they will be treated as local variables because the sandbox is established with `setfenv <https://www.lua.org/manual/5.1/manual.html#pdf-setfenv>`_. So a sandboxed function will happen to be stateless and deterministic."
msgstr ""

msgid "If ``is_deterministic`` is true, there is no immediate effect. Tarantool plans to use the is_deterministic value in a future version. A function is deterministic if it always returns the same outputs given the same inputs. It is the function creator's responsibility to ensure that a function is truly deterministic."
msgstr ""

msgid "**Using a persistent Lua function**"
msgstr ""

msgid "After a persistent Lua function is created, it can be found in the :ref:`box.space._func <box_space-func>` system space, and it can be shown with |br| :samp:`box.func.{func-name}` |br| and it can be invoked by any user with :ref:`authorization <authentication-owners_privileges>` to 'execute' it. The syntax for invoking is: |br| :samp:`box.func.{func-name}:call([parameters])` |br| or, if the connection is remote, the syntax is as in :ref:`net_box:call() <net_box-call>`."
msgstr ""

msgid "tarantool> lua_code = [[function(a, b) return a + b end]]\n"
"tarantool> box.schema.func.create('sum', {body = lua_code})\n"
"\n"
"tarantool> box.func.sum\n"
"---\n"
"- is_sandboxed: false\n"
"  is_deterministic: false\n"
"  id: 2\n"
"  setuid: false\n"
"  body: function(a, b) return a + b end\n"
"  name: sum\n"
"  language: LUA\n"
"...\n"
"\n"
"tarantool> box.func.sum:call({1, 2})\n"
"---\n"
"- 3\n"
"..."
msgstr ""

msgid "Drop a function tuple. For explanation of how Tarantool maintains function data, see reference on :ref:`_func space <box_space-func>`."
msgstr ""

msgid "the name of the function"
msgstr ""

msgid "``if_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` means there should be no error if the _func tuple does not exist."
msgstr ""

msgid "box.schema.func.drop('calculate')"
msgstr ""

msgid "Return true if a function tuple exists; return false if a function tuple does not exist."
msgstr ""

msgid "box.schema.func.exists('calculate')"
msgstr ""

msgid "Reload a C module with all its functions without restarting the server."
msgstr ""

msgid "Under the hood, Tarantool loads a new copy of the module (``*.so`` shared library) and starts routing all new request to the new version. The previous version remains active until all started calls are finished. All shared libraries are loaded with ``RTLD_LOCAL`` (see \"man 3 dlopen\"), therefore multiple copies can co-exist without any problems."
msgstr ""

msgid "Reload will fail if a module was loaded from Lua script with `ffi.load() <http://luajit.org/ext_ffi_api.html#ffi_load>`_."
msgstr ""

msgid "the name of the module to reload"
msgstr ""

msgid "-- reload the entire module contents\n"
"box.schema.func.reload('module')"
msgstr ""

msgid "Sequences"
msgstr ""

msgid "An introduction to sequences is in the :ref:`Sequences <index-box_sequence>` section of the \"Data model\" chapter. Here are the details for each function and option."
msgstr ""

msgid "All functions related to sequences require appropriate :ref:`privileges <authentication-owners_privileges>`."
msgstr ""

msgid "Create a new sequence generator."
msgstr ""

msgid "the name of the sequence"
msgstr ""

msgid "see a quick overview in the \"Options for ``box.schema.sequence.create()``\" :ref:`chart <index-box_sequence-options>` (in the :ref:`Sequences <index-box_sequence>` section of the \"Data model\" chapter), and see more details below."
msgstr ""

msgid "a reference to a new sequence object."
msgstr ""

msgid "Options:"
msgstr ""

msgid "``start`` -- the STARTS WITH value. Type = integer, Default = 1."
msgstr ""

msgid "``min`` -- the MINIMUM value. Type = integer, Default = 1."
msgstr ""

msgid "``max`` - the MAXIMUM value. Type = integer, Default = 9223372036854775807."
msgstr ""

msgid "There is a rule: ``min`` <= ``start`` <= ``max``. For example it is illegal to say ``{start=0}`` because then the specified start value (0) would be less than the default min value (1)."
msgstr ""

msgid "There is a rule: ``min`` <= next-value <= ``max``. For example, if the next generated value would be 1000, but the maximum value is 999, then that would be considered \"overflow\"."
msgstr ""

msgid "There is a rule: ``start`` and ``min`` and ``max`` must all be <= 9223372036854775807 which is 2^63 - 1 (not 2^64)."
msgstr ""

msgid "``cycle`` -- the CYCLE value. Type = bool. Default = false."
msgstr ""

msgid "If the sequence generator's next value is an overflow number, it causes an error return -- unless ``cycle == true``."
msgstr ""

msgid "But if ``cycle == true``, the count is started again, at the MINIMUM value or at the MAXIMUM value (not the STARTS WITH value)."
msgstr ""

msgid "``cache`` -- the CACHE value. Type = unsigned integer. Default = 0."
msgstr ""

msgid "Currently Tarantool ignores this value, it is reserved for future use."
msgstr ""

msgid "``step`` -- the INCREMENT BY value. Type = integer. Default = 1."
msgstr ""

msgid "Ordinarily this is what is added to the previous value."
msgstr ""

msgid "Generate the next value and return it."
msgstr ""

msgid "The generation algorithm is simple:"
msgstr ""

msgid "If this is the first time, then return the STARTS WITH value."
msgstr ""

msgid "If the previous value plus the INCREMENT value is less than the MINIMUM value or greater than the MAXIMUM value, that is \"overflow\", so either raise an error (if ``cycle`` = ``false``) or return the MAXIMUM value (if ``cycle`` = ``true`` and ``step`` < 0) or return the MINIMUM value (if ``cycle`` = ``true`` and ``step`` > 0)."
msgstr ""

msgid "If there was no error, then save the returned result, it is now the \"previous value\"."
msgstr ""

msgid "For example, suppose sequence 'S' has:"
msgstr ""

msgid "``min`` == -6,"
msgstr ""

msgid "``max`` == -1,"
msgstr ""

msgid "``step`` == -3,"
msgstr ""

msgid "``start`` = -2,"
msgstr ""

msgid "``cycle`` = true,"
msgstr ""

msgid "previous value = -2."
msgstr ""

msgid "Then ``box.sequence.S:next()`` returns -5 because -2 + (-3) == -5."
msgstr ""

msgid "Then ``box.sequence.S:next()`` again returns -1 because -5 + (-3) < -6, which is overflow, causing cycle, and ``max`` == -1."
msgstr ""

msgid "This function requires a :ref:`'write' privilege <box_schema-user_grant>` on the sequence."
msgstr ""

msgid "This function should not be used in \"cross-engine\" transactions (transactions which use both the memtx and the vinyl storage engines)."
msgstr ""

msgid "To see what the previous value was, without changing it, you can select from the :ref:`_sequence_data <box_space-sequence_data>` system space."
msgstr ""

msgid "The ``alter()`` function can be used to change any of the sequence's options. Requirements and restrictions are the same as for :ref:`box.schema.sequence.create() <box_schema-sequence_create>`."
msgstr ""

msgid "Set the sequence back to its original state. The effect is that a subsequent ``next()`` will return the ``start`` value. This function requires a :ref:`'write' privilege <box_schema-user_grant>` on the sequence."
msgstr ""

msgid "Set the \"previous value\" to ``new-previous-value``. This function requires a :ref:`'write' privilege <box_schema-user_grant>` on the sequence."
msgstr ""

msgid "Return the last retrieved value of the specified sequence or throw an error if no value has been generated yet (``next()`` has not been called yet, or ``current()`` is called right after ``reset()`` is called)."
msgstr ""

msgid "tarantool> sq = box.schema.sequence.create('test')\n"
"---\n"
"...\n"
"tarantool> sq:current()\n"
"---\n"
"- error: Sequence 'test' is not started\n"
"...\n"
"tarantool> sq:next()\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> sq:current()\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> sq:set(42)\n"
"---\n"
"...\n"
"tarantool> sq:current()\n"
"---\n"
"- 42\n"
"...\n"
"tarantool> sq:reset()\n"
"---\n"
"...\n"
"tarantool> sq:current()  -- error\n"
"---\n"
"- error: Sequence 'test' is not started\n"
"..."
msgstr ""

msgid "Drop an existing sequence."
msgstr ""

msgid "Here is an example showing all sequence options and operations:"
msgstr ""

msgid "s = box.schema.sequence.create(\n"
"               'S2',\n"
"               {start=100,\n"
"               min=100,\n"
"               max=tonumber64('9223372036854775807'),\n"
"               cache=100000,\n"
"               cycle=false,\n"
"               step=100\n"
"               })\n"
"s:alter({step=6})\n"
"s:next()\n"
"s:reset()\n"
"s:set(150)\n"
"s:drop()"
msgstr ""

msgid "You can use the ``sequence`` option when :ref:`creating <box_space-create_index>` or :ref:`altering <box_index-alter>` a primary-key index. The sequence becomes associated with the index, so that the next ``insert()`` will put the next generated number into the primary-key field, if the field value would otherwise be nil."
msgstr ""

msgid "The syntax may be any of: |br| :samp:`sequence = {sequence identifier}` |br| or :code:`sequence = {id =` :samp:`{sequence identifier}` :code:`}` |br| or :code:`sequence = {field =` :samp:`{field number}` :code:`}` |br| or :code:`sequence = {id =` :samp:`{sequence identifier}` :code:`, field =` :samp:`{field number}` :code:`}` |br| or :code:`sequence = true` |br| or :code:`sequence = {}`. |br| The sequence identifier may be either a number (the sequence id) or a string (the sequence name). The field number may be the ordinal number of any field in the index; default = 1. Examples of all possibilities: ``sequence = 1`` or ``sequence = 'sequence_name'`` or ``sequence = {id = 1}`` or ``sequence = {id = 'sequence_name'}`` or ``sequence = {id = 1, field = 1}`` or ``sequence = {id = 'sequence_name', field = 1}`` or ``sequence = {field = 1}`` or ``sequence = true`` or ``sequence = {}``. Notice that the sequence identifier can be omitted, if it is omitted then a new sequence is created automatically with default name = :samp:`{space-name}_seq`. Notice that the field number does not have to be 1, that is, the sequence can be associated with any field in the primary-key index."
msgstr ""

msgid "For example, if 'Q' is a sequence and 'T' is a new space, then this will work:"
msgstr ""

msgid "tarantool> box.space.T:create_index('Q',{sequence='Q'})\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: unsigned\n"
"    is_nullable: false\n"
"    fieldno: 1\n"
"  sequence_id: 8\n"
"  id: 0\n"
"  space_id: 514\n"
"  name: Q\n"
"  type: TREE\n"
"..."
msgstr ""

msgid "(Notice that the index now has a ``sequence_id`` field.)"
msgstr ""

msgid "And this will work:"
msgstr ""

msgid "tarantool> box.space.T:insert{box.NULL,0}\n"
"---\n"
"- [1, 0]\n"
"..."
msgstr ""

msgid "The index key type may be either 'integer' or 'unsigned'. If any of the sequence options is a negative number, then the index key type should be 'integer'."
msgstr ""

msgid "Users should not insert a value greater than 9223372036854775807, which is 2^63 - 1, in the indexed field. The sequence generator will ignore it."
msgstr ""

msgid "A sequence cannot be dropped if it is associated with an index. However, :ref:`index_object:alter() <box_index-alter>` can be used to say that a sequence is not associated with an index, for example ``box.space.T.index.I:alter({sequence=false})``."
msgstr ""

msgid "If a sequence was created automatically because the sequence identifier was omitted, then it will be dropped automatically if the index is altered so that ``sequence=false``, or if the index is dropped."
msgstr ""

msgid "``index_object:alter()`` can also be used to associate a sequence with an existing index, with the same syntax for options."
msgstr ""

msgid "When a sequence is used with an index based on a JSON path, inserted tuples must have all components of the path preceding the autoincrement field, and the autoincrement field. To achieve that use ``box.NULL`` rather than ``nil``. Example:"
msgstr ""

msgid "s = box.schema.space.create('test')\n"
"s:create_index('pk', {parts = {{'[1].a.b[1]', 'unsigned'}}, sequence = true})\n"
"s:replace{} -- error\n"
"s:replace{{c = {}}} -- error\n"
"s:replace{{a = {c = {}}}} -- error\n"
"s:replace{{a = {b = {}}}} -- error\n"
"s:replace{{a = {b = {nil}}}} -- error\n"
"s:replace{{a = {b = {box.NULL}}}} -- ok"
msgstr ""

