# SOME DESCRIPTIVE TITLE.
# Copyright (C) 
# This file is distributed under the same license as the Tarantool package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Tarantool 2.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-02-06 15:34+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "SQL beginners' guide"
msgstr ""

msgid "**What Tarantool's SQL product delivers**"
msgstr ""

msgid "Tarantool's SQL is a major new feature that was first introduced with Tarantool version 2.1. |br| The primary advantages are: |br| - a high level of SQL compatibility |br| - an easy way to switch from NoSQL to SQL and back |br| - the Tarantool brand."
msgstr ""

msgid "The \"high level of SQL compatibility\" includes support for joins, subqueries, triggers, indexes, groupings, transactions in a multi-user environment, and conformance with the majority of the mandatory requirements of the SQL:2016 standard."
msgstr ""

msgid "The \"easy way to switch\" consists of the fact that the same tables can be operated on with SQL and with the  long-established Tarantool-NoSQL product, meaning that when you want standard Relational-DBMS jobs you can do them, and when you want NoSQL capability you can have it (Tarantool-NoSQL outperforms other NoSQL products in public benchmarks)."
msgstr ""

msgid "The \"Tarantool brand\" comes from the support of a multi-billion-dollar internet / mail / social-network provider, a dozens-of-professionals staff of programmers and support people, a community who believes in open-source BSD licensing, and hundreds of corporations / government bodies using Tarantool products in production already."
msgstr ""

msgid "The status of Tarantool's SQL feature is \"release\". So, it is working now and you can verify that by downloading it and trying all the features, which we will explain in the rest of this document. There is also a :ref:`tutorial <sql_tutorial>`."
msgstr ""

msgid "This document has four parts. The SQL BEGINNERS' GUIDE explains the basics of relational database management and SQL in particular. The USER GUIDE explains \"How to get Started\" and explains the terms and the syntax elements that apply for all SQL statements. The SQL STATEMENTS AND CLAUSES guide explains, for each SQL statement, the format and the rules and the exceptions and the examples and the limitations. The SQL PLUS LUA guide has the details about calling Lua from SQL, calling SQL from Lua, and using the same database objects in both SQL and Lua."
msgstr ""

msgid "Users are expected to know what databases are, and experience with other SQL DBMSs would be an advantage."
msgstr ""

msgid "**SQL beginners' guide begins**"
msgstr ""

msgid "The Beginners' Guide describes how users can start up with SQL with Tarantool, and necessary concepts."
msgstr ""

msgid "The SQL Beginners' Guide is about databases in general, and about the relationship between Tarantool's NoSQL and SQL products. Most of the matters in the Beginners' Guide will already be familiar to people who have used relational databases before."
msgstr ""

msgid "**Sample Simple Table**"
msgstr ""

msgid "In football training camp it is traditional for the trainer to begin by showing a football and saying \"this is a football\". In that spirit, this is a table:"
msgstr ""

msgid "TABLE\n"
"          [1]              [2]              [3]\n"
"       +-----------------+----------------+----------------+\n"
" Row#1 | Row#1,Column#1  | Row#1,Column#2 | Row#1,Column#3 |\n"
"       +-----------------+----------------+----------------+\n"
" Row#2 | Row#2,Column#1  | Row#2,Column#2 | Row#2,Column#3 |\n"
"       +-----------------+----------------+----------------+\n"
" Row#3 | Row#3,Column#1  | Row#3,Column#2 | Row#3,Column#3 |\n"
"       +-----------------+----------------+----------------+"
msgstr ""

msgid "but the labels are misleading -- we usually don't identify rows and columns by their ordinal positions, we prefer to pick out specific items by their contents. In that spirit, this is a table:"
msgstr ""

msgid "modules\n"
"\n"
"+-----------------+------+---------------------+\n"
"| name            | size | purpose             |\n"
"+-----------------|------|---------------------|\n"
"| box             | 1432 | Database Management |\n"
"| clock           |  188 | Seconds             |\n"
"| crypto          |    4 | Cryptography        |\n"
"+-----------------+------+---------------------+"
msgstr ""

msgid "so we do not use longitude/latitude navigation by talking about \"Row#2 Column #2\", we use the contents of the Name column and the name of the Size column by talking about \"the size, where the name is 'clock'\". To be more exact, this is what we say:"
msgstr ""

msgid "``SELECT size FROM modules WHERE name = 'clock';``"
msgstr ""

msgid "If you're familiar with Tarantool's architecture -- and we hope that you read about that before coming to this chapter -- then you know that there is a NoSQL way to get the same thing:"
msgstr ""

msgid "``box.space.MODULES:select()[2][2]``"
msgstr ""

msgid "Well, you can do that. One of the advantages of Tarantool is that if you can get data via an SQL statement, then you can get the same data via a NoSQL request. But the reverse is not true, because not all NoSQL tuple sets are definable as SQL tables. These restrictions apply for SQL that do not apply for NoSQL: |br| 1. Every column must have a name. |br| 2. Every column must have a scalar type (Tarantool is relaxed about which particular scalar type you can have, but there is no way to index and search arrays, tables within tables, or what MessagePack calls \"maps\".)"
msgstr ""

msgid "Tarantool/NoSQL's \"format\" clause causes the same restrictions."
msgstr ""

msgid "So an SQL \"table\" is a NoSQL \"tuple set with format restrictions\", an SQL \"row\" is a NoSQL \"tuple\", an SQL \"column\" is a NoSQL \"list of fields within a tuple set\"."
msgstr ""

msgid "**Creating a table**"
msgstr ""

msgid "This is how to create the modules table:"
msgstr ""

msgid "``CREATE TABLE modules (name STRING, size INTEGER, purpose STRING, PRIMARY KEY (name));``"
msgstr ""

msgid "The words that are IN CAPITAL LETTERS are \"keywords\" (although it is only a convention in this manual that keywords are in capital letters, in practice many programmers prefer to avoid shouting). A keyword has meaning for the SQL parser so many keywords are reserved, they cannot be used as names unless they are enclosed inside quotation marks."
msgstr ""

msgid "The word \"modules\" is a \"table name\", and the words \"name\" and \"size\" and \"purpose\" are \"column names\". All tables and all columns must have names."
msgstr ""

msgid "The words \"STRING\" and \"INTEGER\" are \"data types\". STRING means \"the contents should be characters, the length is indefinite, the equivalent NoSQL type is 'string''\". INTEGER means \"the contents should be numbers without decimal points, the equivalent NoSQL type is 'integer'\". Tarantool supports other data types but our example table has data types from the two main groups, namely, data types for numbers and data types for strings."
msgstr ""

msgid "The final clause, PRIMARY KEY (name), means that the name column is the main column used to identify the row."
msgstr ""

msgid "**Nulls**"
msgstr ""

msgid "Frequently it is necessary, at least temporarily, that a column value should be NULL. Typical situations are: the value is unknown, or the value is not applicable. For example, you might make a module as a placeholder but you don't want to say its size or purpose. If such things are possible, the column is \"nullable\". Our name column cannot contain nulls, and it could be defined explicitly as \"name STRING NOT NULL\", but in this case that's unnecessary -- a column defined as PRIMARY KEY is automatically NOT NULL."
msgstr ""

msgid "Is a NULL in SQL the same thing as a nil in Lua? No, but it is close enough that there will be confusion. When nil means \"unknown\" or \"inapplicable\", yes. But when nil means \"nonexistent\" or \"type is nil\", no. NULL is a value, it has a data type because it is inside a column which is defined with that data type."
msgstr ""

msgid "**Creating an index**"
msgstr ""

msgid "This is how to create indexes for the modules table:"
msgstr ""

msgid "``CREATE INDEX size ON modules (size);`` |br| ``CREATE UNIQUE INDEX purpose ON modules (purpose);``"
msgstr ""

msgid "There is no need to create an index on the name column, because Tarantool creates an index automatically when it sees a PRIMARY KEY clause in the CREATE TABLE statement. In fact there is no need to create indexes on the size or purpose columns either -- if indexes don't exist, then it is still possible to use the columns for searches. Typically people create non-primary indexes, also called secondary indexes, when it becomes clear that the table will grow large and searches will be frequent, because searching with an index is generally much faster than searching without an index."
msgstr ""

msgid "Another use for indexes is to enforce uniqueness. When an index is created with CREATE UNIQUE INDEX for the purpose column, it is not possible to have duplicate values in that column."
msgstr ""

msgid "**Data change**"
msgstr ""

msgid "Putting data into a table is called \"inserting\". Changing data is called \"updating\". Removing data is called \"deleting\". Together, the three SQL statements INSERT plus UPDATE plus DELETE are the three main \"data-change\" statements."
msgstr ""

msgid "This is how to insert, update, and delete a row in the modules table:"
msgstr ""

msgid "``INSERT INTO modules VALUES ('json', 14, 'format functions for JSON');`` |br| ``UPDATE modules SET size = 15 WHERE name = 'json';`` |br| ``DELETE FROM modules WHERE name = 'json';``"
msgstr ""

msgid "The corresponding non-SQL Tarantool requests would be:"
msgstr ""

msgid "``box.space.MODULES:insert{'json', 14, 'format functions for JSON'}`` |br| ``box.space.MODULES:update('json', {{'=', 2, 15}})`` |br| ``box.space.MODULES:delete{'json'}`` |br|"
msgstr ""

msgid "This is how we would populate the table with the values that we showed earlier:"
msgstr ""

msgid "``INSERT INTO modules VALUES ('box', 1432, 'Database Management');`` |br| ``INSERT INTO modules VALUES ('clock', 188, 'Seconds');`` |br| ``INSERT INTO modules VALUES ('crypto', 4, 'Cryptography');`` |br|"
msgstr ""

msgid "**Constraints**"
msgstr ""

msgid "Some data-change statements are illegal due to something in the table's definition. This is called \"constraining what can be done\". We have already seen some types of constraints ..."
msgstr ""

msgid "NOT NULL -- if a column is defined with a NOT NULL clause, it is illegal to put NULL into it. A primary-key column is automatically NOT NULL."
msgstr ""

msgid "UNIQUE -- if a column has a UNIQUE index, it is illegal to put a duplicate into it. A primary-key column automatically has a UNIQUE index."
msgstr ""

msgid "data domain -- if a column is defined as having data type INTEGER, it is illegal to put a non-number into it. More generally, if a value doesn't correspond to the data type of the definition, it is illegal. However, some database management systems (DBMSs) are very forgiving and will try to make allowances for bad values rather than reject them; Tarantool is one of those DBMSs."
msgstr ""

msgid "Now, here are other types of constraints ..."
msgstr ""

msgid "CHECK -- a table description can have a clause \"CHECK (conditional expression)\". For example, if the CREATE TABLE modules statement looked like this:"
msgstr ""

msgid "CREATE TABLE modules (name STRING,\n"
"                      size INTEGER,\n"
"                      purpose STRING,\n"
"                      PRIMARY KEY (name),\n"
"                      CHECK (size > 0));"
msgstr ""

msgid "then this INSERT statement would be illegal: |br| ``INSERT INTO modules VALUES ('box', 0, 'The Database Kernel');`` |br| because there is a CHECK constraint saying that the second column, the size column, cannot contain a value which is less than or equal to zero. Try this instead: |br| ``INSERT INTO modules VALUES ('box', 1, 'The Database Kernel');``"
msgstr ""

msgid "FOREIGN KEY -- a table description can have a clause \"FOREIGN KEY (column-list) REFERENCES table (column-list)\". For example, if there is a new table \"submodules\" which in a way depends on the modules table, it can be defined like this:"
msgstr ""

msgid "CREATE TABLE submodules (name STRING,\n"
"                         module_name STRING,\n"
"                         size INTEGER,\n"
"                         purpose STRING,\n"
"                         PRIMARY KEY (name),\n"
"                         FOREIGN KEY (module_name) REFERENCES\n"
"                         modules (name));"
msgstr ""

msgid "Now try to insert a new row into this submodules table:"
msgstr ""

msgid "``INSERT INTO submodules VALUES`` |br| |nbsp| |nbsp| ``('space', 'Box', 10000, 'insert etc.');``"
msgstr ""

msgid "The insert will fail because the second column (module_name) refers to the name column in the modules table, and the name column in the modules table does not contain 'Box'. However, it does contain 'box'. By default searches in Tarantool's SQL use a binary collation. This will work:"
msgstr ""

msgid "``INSERT INTO submodules`` |br| |nbsp| |nbsp| ``VALUES ('space', 'box', 10000, 'insert etc.');``"
msgstr ""

msgid "Now try to delete the new row from the modules table:"
msgstr ""

msgid "``DELETE FROM modules WHERE name = 'box';``"
msgstr ""

msgid "The delete will fail because the second column (module_name) in the submodules table refers to the name column in the modules table, and the name column in the modules table would not contain 'box' if the delete succeeded. So the FOREIGN KEY constraint affects both the table which contains the FOREIGN KEY clause and the table that the FOREIGN KEY clause refers to."
msgstr ""

msgid "The constraints in a table's definition -- NOT NULL, UNIQUE, data domain, CHECK, and FOREIGN KEY -- are guarantors of the database's integrity. It is important that they are fixed and well-defined parts of the definition, and hard to bypass with SQL. This is often seen as a difference between SQL and NoSQL -- SQL emphasizes law and order, NoSQL emphasizes freedom and making your own rules."
msgstr ""

msgid "**Table Relationships**"
msgstr ""

msgid "Think about the two tables that we have discussed so far:"
msgstr ""

msgid "CREATE TABLE modules (name STRING,\n"
"                      size INTEGER,\n"
"                       purpose STRING,\n"
"                       PRIMARY KEY (name),\n"
"                       CHECK (size > 0));\n"
"\n"
"CREATE TABLE submodules (name STRING,\n"
"                         module_name STRING,\n"
"                         size INTEGER,\n"
"                         purpose STRING,\n"
"                         PRIMARY KEY (name),\n"
"                         FOREIGN KEY (module_name) REFERENCES\n"
"                         modules (name));"
msgstr ""

msgid "Because of the FOREIGN KEYS clause in the submodules table, there is clearly a many-to-one relationship: |br| submodules -->> modules |br| that is, every submodules row must refer to one (and only one) modules row, while every modules row can be referred to in zero or more submodules rows."
msgstr ""

msgid "Table relationships are important, but beware: do not trust anyone who tells you that databases made with SQL are relational \"because there are relationships between tables\". That is wrong. We will see why when we talk about what makes a database relational, later."
msgstr ""

msgid "**Selecting with WHERE**"
msgstr ""

msgid "We gave a simple example of a SELECT statement earlier:"
msgstr ""

msgid "The clause \"WHERE name = 'clock'\" is legal in other statements -- we have seen it in UPDATE and DELETE -- but here we will only give examples with SELECT."
msgstr ""

msgid "The first variation is that the WHERE clause does not have to be specified at all, it is optional. So this statement would return all rows:"
msgstr ""

msgid "``SELECT size FROM modules;``"
msgstr ""

msgid "The second variation is that the comparison operator does not have to be '=', it can be anything that makes sense: '>' or '>=' or '<' or '<=', or 'LIKE' which is an operator that works with strings that may contain wildcard characters '_' meaning 'match any one character' or '%' meaning 'match any zero or one or many characters'. These are legal statements which return all rows:"
msgstr ""

msgid "``SELECT size FROM modules WHERE name >= '';`` |br| ``SELECT size FROM modules WHERE name LIKE '%';``"
msgstr ""

msgid "The third variation is that IS [NOT] NULL is a special condition. Remembering that the NULL value can mean \"it is unknown what the value should be\", and supposing that in some row the size is NULL, then the condition \"size > 10\" is not certainly true and it is not certainly false, so it is evaluated as \"unknown\". Ordinarily the application of a WHERE clause filters out both false and unknown results. So when searching for NULL, say IS NULL; when searching anything that is not NULL, say IS NOT NULL. This statement will return all rows because (due to the definition) there are no NULLs in the name column:"
msgstr ""

msgid "``SELECT size FROM modules WHERE name IS NOT NULL;``"
msgstr ""

msgid "The fourth variation is that conditions can be combined with AND / OR, and negated with NOT."
msgstr ""

msgid "So this statement would return all rows (the first condition is false but the second condition is true, and OR means \"return true if either condition is true\"):"
msgstr ""

msgid "SELECT size\n"
"FROM modules\n"
"WHERE name = 'wombat' OR size IS NOT NULL;"
msgstr ""

msgid "**Selecting with a select list**"
msgstr ""

msgid "Yet again, here is a simple example of a SELECT statement:"
msgstr ""

msgid "The words between SELECT and FROM are the select list. In this case, the select list is just one word: size. Formally it means that the desire is to return the size values, and technically the name for picking a particular column is called \"projection\"."
msgstr ""

msgid "The first variation is that one can specify any column in any order:"
msgstr ""

msgid "``SELECT name, purpose, size FROM modules;``"
msgstr ""

msgid "The second variation is that one can specify an expression, it does not have to be a column name, it does not even have to include a column name. The common expression operators for numbers are the arithmetic operators ``+ - / *``; the common expression operator for strings is the concatenation operator ||. For example this statement will return 8, 'XY':"
msgstr ""

msgid "``SELECT size * 2, 'X' || 'Y' FROM modules WHERE size = 4;``"
msgstr ""

msgid "The third variation is that one can add a clause [AS name] after every expression, so that in the return the column titles will make sense. This is especially important when a title might otherwise be ambiguous or meaningless. For example this statement will return 8, 'XY' as before"
msgstr ""

msgid "``SELECT size * 2 AS double_size, 'X' || 'Y' AS concatenated_literals  FROM modules`` |br| |nbsp| |nbsp| ``WHERE size = 4;``"
msgstr ""

msgid "but displayed as a table the result will look like"
msgstr ""

msgid "+----------------+------------------------+\n"
"| double_size    | concatenated_literals  |\n"
"+----------------+------------------------+\n"
"|               8| XY                     |\n"
"+----------------+------------------------+"
msgstr ""

msgid "**Selecting with a select list with asterisk**"
msgstr ""

msgid "Instead of listing columns in a select list, one can just say ``'*'``. For example"
msgstr ""

msgid "``SELECT * FROM modules;``"
msgstr ""

msgid "This is the same thing as"
msgstr ""

msgid "``SELECT name, size, purpose FROM modules;``"
msgstr ""

msgid "Selecting with ``\"*\"``  saves time for the writer, but it is unclear to a reader who has not memorized what the column names are. Also it is unstable, because there is a way to change a table's definition (the ALTER statement, which is an advanced topic). Nevertheless, although it might be bad to use it for production, it is handy to use it for introduction, so we will use ``\"*\"`` in several examples."
msgstr ""

msgid "**Select with subqueries**"
msgstr ""

msgid "Remember that we have a modules table and we have a submodules table. Suppose that we want to list the submodules that refer to modules for which the purpose is X. That is, this involves a search of one table using a value in another table. This can be done by enclosing \"(SELECT ...)\" within the WHERE clause. For example:"
msgstr ""

msgid "SELECT name FROM submodules\n"
"WHERE module_name =\n"
"    (SELECT name FROM modules WHERE purpose LIKE '%Database%');"
msgstr ""

msgid "Subqueries are also useful in the select list, when one wishes to combine information from more than one table. For example this statement will display submodules rows but will include values that come from the modules table:"
msgstr ""

msgid "SELECT name AS submodules_name,\n"
"    (SELECT purpose FROM modules\n"
"     WHERE modules.name = submodules.module_name)\n"
"     AS modules_purpose,\n"
"    purpose AS submodules_purpose\n"
"FROM submodules;"
msgstr ""

msgid "Whoa. What are \"modules.name\" and \"submodules.name\"? Whenever you see \"x . y\" you are looking at a \"qualified column name\", and the first part is a table identifier, the second part is a column identifier. It is always legal to use qualified column names, but until now it has not been necessary. Now it is necessary, or at least it is a good idea, because both tables have a column named \"name\"."
msgstr ""

msgid "The result will look like this:"
msgstr ""

msgid "+-------------------+------------------------+--------------------+\n"
"| submodules_name   | modules_purpose        | submodules_purpose |\n"
"+-------------------+------------------------+--------------------+\n"
"| space             | Database Management    | insert etc.        |\n"
"+-------------------+------------------------+--------------------+"
msgstr ""

msgid "Perhaps you have read somewhere that SQL stands for \"Structured Query Language\". That is not true any more. But it is true that the query syntax allows for a structural component, namely the subquery, and that was the original idea. However, there is a different way to combine tables -- with joins instead of subqueries."
msgstr ""

msgid "**Select with Cartesian join**"
msgstr ""

msgid "Until now we have only used \"FROM modules\" or \"FROM submodules\" in our SELECT statements. What if we used more than one table in the FROM clause? For example"
msgstr ""

msgid "``SELECT * FROM modules, submodules;`` |br| or ``SELECT * FROM modules JOIN submodules;``"
msgstr ""

msgid "That is legal. Usually it is not what you want, but it is a learning aid. The result will be:"
msgstr ""

msgid "{ columns from modules table }         { columns from submodules table }\n"
"+--------+------+---------------------+-------+-------------+-------+-------------+\n"
"| name   | size | purpose             | name  | module_name | size  | purpose     |\n"
"+--------+------+---------------------+-------+-------------+-------+-------------+\n"
"| box    | 1432 | Database Management | space | box         | 10000 | insert etc. |\n"
"| clock  | 188  | Seconds             | space | box         | 10000 | insert etc. |\n"
"| crypto |   4  | Cryptography        | space | box         | 10000 | insert etc. |\n"
"+--------+------+---------------------+-------+-------------+-------+-------------+"
msgstr ""

msgid "It is not an error. The meaning of this type of join is \"combine every row in table-1 with every row in table-2\". It did not specify what the relationship should be, so the result has everything, even when the submodule has nothing to do with the module."
msgstr ""

msgid "It is handy to look at the above result, called a \"Cartesian join\" result, to see what we really want. Probably for this case the row that actually makes sense is the one where the modules.name = submodules.module_name, and we should make that clear in both the select list and the WHERE clause, thus:"
msgstr ""

msgid "SELECT modules.name AS modules_name,\n"
"       modules.size AS modules_size,\n"
"       modules.purpose AS modules_purpose,\n"
"       submodules.name,\n"
"       module_name,\n"
"       submodules.size,\n"
"       submodules.purpose\n"
"FROM modules, submodules\n"
"WHERE modules.name = submodules.module_name;"
msgstr ""

msgid "The result will be:"
msgstr ""

msgid "+----------+-----------+------------+--------+---------+-------+-------------+\n"
"| modules_ |  modules_ | modules_   | name   | module_ | size  | purpose     |\n"
"| name     |  size     | purpose    |        | name    |       |             |\n"
"+----------+-----------+--------- --+--------+---------+-------+-------------|\n"
"| box      | 1432      | Database   | space  | box     | 10000 | insert etc. |\n"
"|          |           | Management |        |         |       |             |\n"
"+----------+-----------+------------+--------+---------+-------+-------------|"
msgstr ""

msgid "In other words, you can specify a Cartesian join in the FROM clause, then you can filter out the irrelevant rows in the WHERE clause, and then you can rename columns in the select list. This is fine, and every SQL DBMS supports this. But it is worrisome that the number of rows in a Cartesian join is always (number of rows in first table multiplied by number of rows in second table), which means that conceptually you are often filtering in a large set of rows."
msgstr ""

msgid "It is good to start by looking at Cartesian joins because they show the concept. Many people, though, prefer to use different syntaxes for joins because they look better or clearer. We will look at those alternatives now."
msgstr ""

msgid "**Select with join with ON clause**"
msgstr ""

msgid "The ON clause would have the same comparisons as the WHERE clause that we illustrated for the previous section, but by using different syntax we would be making it clear \"this is for the sake of the join\". Readers can see at a glance that it is, in concept at least, an initial step before the result rows are filtered. For example this"
msgstr ""

msgid "``SELECT * FROM modules JOIN submodules`` |br| |nbsp| |nbsp| ``ON (modules.name = submodules.module_name);``"
msgstr ""

msgid "is the same as"
msgstr ""

msgid "``SELECT * FROM modules, submodules`` |br| |nbsp| |nbsp| ``WHERE modules.name = submodules.module_name;``"
msgstr ""

msgid "**Select with join with USING clause**"
msgstr ""

msgid "The USING clause would take advantage of names that are held in common between the two tables, with the assumption that the intent is to match those columns with '=' comparisons. For example,"
msgstr ""

msgid "``SELECT * FROM modules JOIN submodules USING (name);``"
msgstr ""

msgid "has the same effect as"
msgstr ""

msgid "``SELECT * FROM modules JOIN submodules WHERE modules.name = submodules.name;``"
msgstr ""

msgid "If we had created our table with a plan in advance to use USING clauses, that would save time. But we did not. So, although the above example \"works\", the results will not be sensible."
msgstr ""

msgid "**Select with natural join**"
msgstr ""

msgid "A natural join would take advantage of names that are held in common between the two tables, and would do the filtering automatically based on that knowledge, and throw away duplicate columns."
msgstr ""

msgid "If we had created our table with a plan in advance to use natural joins, that would be very handy. But we did not. So, although the following example \"works\", the results won't be sensible."
msgstr ""

msgid "``SELECT * FROM modules NATURAL JOIN submodules;``"
msgstr ""

msgid "Result: nothing, because modules.name does not match submodules.name, and so on And even if there had been a result, it would only have included four columns: name, module_name, size, purpose."
msgstr ""

msgid "**Select with left join**"
msgstr ""

msgid "Now what if we want to join modules to submodules, but we want to be sure that we get all the modules? In other words, we want to get modules even if the condition submodules.module_name = modules.name is not true, because the module has no submodules."
msgstr ""

msgid "When that is what we want, the type of join is an \"outer join\" (as opposed to the type we have used so far which is an \"inner join\"). Specifically we will use LEFT [OUTER] JOIN because our main table, modules, is on the left. For example:"
msgstr ""

msgid "SELECT *\n"
"FROM modules LEFT JOIN submodules\n"
"ON modules.name = submodules.module_name;"
msgstr ""

msgid "which returns:"
msgstr ""

msgid "{ columns from modules table }         { columns from submodules table }\n"
"+--------+------+---------------------+-------+-------------+-------+-------------+\n"
"| name   | size | purpose             | name  | module_name | size  | purpose     |\n"
"+--------+------+---------------------+-------+-------------+-------+-------------+\n"
"| box    | 1432 | Database Management | space | box         | 10000 | insert etc. |\n"
"| clock  | 188  | Seconds             | NULL  | NULL        | NULL  | NULL        |\n"
"| crypto |   4  | Cryptography        | NULL  | NULL        | NULL  | NULL        |\n"
"+--------+------+---------------------+-------+-------------+-------+-------------+"
msgstr ""

msgid "Thus, for the submodules of the clock module and the submodules of the crypto module -- which do not exist -- there are NULLs in every column."
msgstr ""

msgid "**Select with functions**"
msgstr ""

msgid "A function can take any expression, including an expression that contains another function, and return a scalar value. There are many such functions. We will just describe one, SUBSTR, which returns a substring of a string."
msgstr ""

msgid "Format: :samp:`SUBSTR({input-string}, {start-with} [, {length}])`"
msgstr ""

msgid "Description: SUBSTR takes input-string, eliminates any characters before start-with, eliminates any characters after (start-with plus length), and returns the result."
msgstr ""

msgid "Example: ``SUBSTR('abcdef', 2, 3)`` returns 'bcd'."
msgstr ""

msgid "Select with aggregation, GROUP BY, and HAVING"
msgstr ""

msgid "Remember that our modules table looks like this:"
msgstr ""

msgid "Suppose that we do not want to know all the individual size values, we just want to know about their aggregation, that is, take the attributes of the collection. SQL allows five aggregation functions: AVG (average), SUM, MIN (minimum), MAX (maximum), and COUNT. For example"
msgstr ""

msgid "``SELECT AVG(size), SUM(size), MIN(size), MAX(size), COUNT(size) FROM modules;``"
msgstr ""

msgid "+--------------+-----------+-----------+-----------+-------------+\n"
"| AVG(size)    | SUM(size) | MIN(size) | MAX(size) | COUNT(size) |\n"
"+--------------+-----------+-----------+-----------+-------------|\n"
"| 5.413333E+02 | 1624      |         4 |      1432 |           3 |\n"
"+--------------+-----------+-----------+-----------+-------------+"
msgstr ""

msgid "Suppose that we want aggregations, but aggregations of rows that have some common characteristic. Supposing further, we want to divide the rows into two groups, the ones whose names begin with 'b' and the ones whose names begin with 'c'. This can be done by adding a clause [GROUP BY expression]. For example,"
msgstr ""

msgid "SELECT SUBSTR(name, 1, 1), AVG(size), SUM(size), MIN(size), MAX(size), COUNT(size)\n"
"FROM modules\n"
"GROUP BY SUBSTR(name, 1, 1);"
msgstr ""

msgid "+--------------------+--------------+-----------+-----------+-----------+-------------+\n"
"| SUBSTR(name, 1, 1) | AVG(size)    | SUM(size) | MIN(size) | MAX(size) | CoUNT(size) |\n"
"+--------------------+--------------+-----------+-----------+-----------|-------------|\n"
"| b                  |         1432 |      1432 |      1432 |      1432 |           1 |\n"
"| c                  |           96 |       192 |         4 |       188 |           2 |\n"
"+--------------------+--------------+-----------+-----------+-----------|-------------+"
msgstr ""

msgid "**Select with common table expression**"
msgstr ""

msgid "It is possible to define a temporary (viewed) table within a statement, usually within a SELECT statement, using a WITH clause. For example:"
msgstr ""

msgid "``WITH tmp_table AS (SELECT x1 FROM t1) SELECT * FROM tmp_table;``"
msgstr ""

msgid "**Select with order, limit, and offset clauses**"
msgstr ""

msgid "Every time we have searched in the modules table, the rows have come out in alphabetical order by name: 'box', then 'clock', then 'crypto'. However, if we want to be sure about the order, or if we want a different order, we will have to be explicit and add a clause: ``ORDER BY column-name [ASC|DESC]``. (ASC stands for ASCending, DESC stands for DESCending.) For example:"
msgstr ""

msgid "``SELECT * FROM modules ORDER BY name DESC;``"
msgstr ""

msgid "The result will be the usual rows, in descending alphabetical order: 'crypto' then 'clock' then 'box'."
msgstr ""

msgid "After the ORDER BY clause we can add a clause LIMIT n, where n is the maximum number of rows that we want. For example:"
msgstr ""

msgid "``SELECT * FROM modules ORDER BY name DESC LIMIT 2;``"
msgstr ""

msgid "The result will be the first two rows, 'crypto' and 'clock'."
msgstr ""

msgid "After the ORDER BY clause and the LIMIT clause we can add a clause OFFSET n, where n is the row to start with. The first offset is 0. For example:"
msgstr ""

msgid "``SELECT * FROM modules ORDER BY name DESC LIMIT 2 OFFSET 2;``"
msgstr ""

msgid "The result will be the third row, 'box'."
msgstr ""

msgid "**Views**"
msgstr ""

msgid "A view is a canned SELECT. If you have a complex SELECT that you want to run frequently, create a view and then do a simple SELECT on the view. For example:"
msgstr ""

msgid "CREATE VIEW v AS SELECT size, (size *5) AS size_times_5\n"
"FROM modules\n"
"GROUP BY size, name\n"
"ORDER BY size_times_5;\n"
"SELECT * FROM v;"
msgstr ""

msgid "**Transactions**"
msgstr ""

msgid "Tarantool has a \"Write Ahead Log\" (WAL). Effects of data-change statements are logged before they are permanently stored on disk. This is a reason that, although entire databases can be stored in temporary memory, they are not vulnerable in case of power failure."
msgstr ""

msgid "Tarantool supports commits and rollbacks. In effect, asking for a commit means asking for all the recent data-change statements, since a transaction began, to become permanent. In effect, asking for a rollback means asking for all the recent data-change statements, since a transaction began, to be cancelled."
msgstr ""

msgid "For example, consider these statements:"
msgstr ""

msgid "CREATE TABLE things (remark STRING, PRIMARY KEY (remark));\n"
"START TRANSACTION;\n"
"INSERT INTO things VALUES ('A');\n"
"COMMIT;\n"
"START TRANSACTION;\n"
"INSERT INTO things VALUES ('B');\n"
"ROLLBACK;\n"
"SELECT * FROM things;"
msgstr ""

msgid "The result will be: one row, containing 'A'. The ROLLBACK cancelled the second INSERT statement, but did not cancel the first one, because it had already been committed."
msgstr ""

msgid "Ordinarily every statement is automatically committed."
msgstr ""

msgid "After START TRANSACTION, statements are not automatically committed -- Tarantool considers that a transaction is now \"active\", until the transaction ends with a COMMIT statement or a ROLLBACK statement. While a transaction is active, all statements are legal except another START TRANSACTION."
msgstr ""

msgid "**Implementing Tarantool's SQL On Top of NoSQL**"
msgstr ""

msgid "Tarantool's SQL data is the same as Tarantool's NoSQL data. When you create a table or an index with SQL, you are creating a space or an index in NoSQL. For example:"
msgstr ""

msgid "CREATE TABLE things (remark STRING, PRIMARY KEY (remark));\n"
"INSERT INTO things VALUES ('X');"
msgstr ""

msgid "is somewhat similar to"
msgstr ""

msgid "box.schema.space.create('THINGS',\n"
"{\n"
"    format = {\n"
"              [1] = {[\"name\"] = \"REMARK\", [\"type\"] = \"string\"}\n"
"              }\n"
"})\n"
"box.space.THINGS:create_index('pk_unnamed_THINGS_1',{unique=true,parts={1,'string'}})\n"
"box.space.THINGS:insert{'X'}"
msgstr ""

msgid "Therefore you can take advantage of Tarantool's NoSQL features even though your primary language is SQL. Here are some possibilities."
msgstr ""

msgid "(1) NoSQL applications written in one of the connector languages may be slightly faster than SQL applications because SQL statements may require more parsing and may be translated to NoSQL requests."
msgstr ""

msgid "(2) You can write stored procedures in Lua, combining Lua loop-control and Lua library-access statements with SQL statements. These routines are executed on the server, which is the principal advantage of pure-SQL stored procedures."
msgstr ""

msgid "(3) There are some options that are implemented in NoSQL that are not (yet) implemented in SQL. For example you can use NoSQL to change an index type to 'hash', and to deny access to users named 'guest'."
msgstr ""

msgid "(4) System spaces such as _space and _index can be accessed with SQL SELECT statements. This is not quite the same as an information_schema, but it does mean that you can use SQL to access the database's metadata catalog."
msgstr ""

msgid "Fields in NoSQL spaces can be accessed with SQL if and only if they are scalar and are defined in format clauses. Indexes of NoSQL spaces will be used with SQL if and only if they are TREE or HASH indexes."
msgstr ""

msgid "**Relational Databases**"
msgstr ""

msgid "Edgar F. Codd, the person most responsible for researching and explaining relational database concepts, listed the main criteria as (`Codd's 12 rules <https://en.wikipedia.org/wiki/Codd's_12_rules>`_)."
msgstr ""

msgid "Although we do not advertise Tarantool as \"relational\", we claim that Tarantool complies with these rules, with the following caveats and exceptions ..."
msgstr ""

msgid "The rules state that all data must be viewable as relations. A Tarantool SQL table is a relation. However, it is possible to have duplicate values in SQL tables and it is possible to have an implicit ordering. Those characteristics are not allowed for true relations."
msgstr ""

msgid "The rules state that there must be a dynamic online catalog. Tarantool has one but some metadata is missing from it."
msgstr ""

msgid "The rules state that the data language must support authorization. Tarantool's SQL does not. Authorization occurs via NoSQL requests."
msgstr ""

msgid "The rules require that data must be physically independent (from underlying storage changes) and logically independent (from application program changes). So far we do not have enough experience to make this guarantee."
msgstr ""

msgid "The rules require certain types of updatable views. Tarantool's views are not updatable."
msgstr ""

msgid "The rules state that it should be impossible to use a low-level language to bypass integrity as defined in the relational-level language. In our case, this is not true, for example one can execute a request with Tarantool's NoSQL to violate a foreign-key constraint that was defined with Tarantool's SQL."
msgstr ""

msgid "SQL user guide"
msgstr ""

msgid "The User Guide describes how users can start up with SQL with Tarantool, and necessary concepts."
msgstr ""

msgid "Getting Started"
msgstr ""

msgid "The explanations for installing and starting the Tarantool server are in earlier chapters of the Tarantool manual.."
msgstr ""

msgid "To get started specifically with the SQL features, using Tarantool as a client, execute these requests:"
msgstr ""

msgid "box.cfg{}\n"
"box.execute([[VALUES ('hello');]])"
msgstr ""

msgid "The bottom of the screen should now look like this:"
msgstr ""

msgid "tarantool> box.execute([[VALUES ('hello');]])\n"
"---\n"
"- metadata:\n"
"  - name: column1\n"
"    type: string\n"
"  rows:\n"
"  - ['hello']\n"
"..."
msgstr ""

msgid "That's an SQL statement done with Tarantool."
msgstr ""

msgid "Now you are ready to execute any SQL statements via the connection. For example"
msgstr ""

msgid "box.execute([[CREATE TABLE things (id INTEGER PRIMARY key,\n"
"                                   remark STRING);]])\n"
"box.execute([[INSERT INTO things VALUES (55, 'Hello SQL world!');]])\n"
"box.execute([[SELECT * FROM things WHERE id > 0;]])"
msgstr ""

msgid "And you will see the results of the SQL query."
msgstr ""

msgid "For the rest of this chapter, the :ref:`box.execute([[...]]) <box-sql>` enclosure will not be shown. Examples will simply say what a piece of syntax looks like, such as ``SELECT 'hello';`` |br| and users should know that must be entered as |br| ``box.execute([[SELECT 'hello';]])`` |br| It is also legal to enclose SQL statements inside single or double quote marks instead of [[ ... ]]."
msgstr ""

msgid "Supported syntax"
msgstr ""

msgid "Keywords, for example CREATE or INSERT or VALUES, may be entered in either upper case or lower case."
msgstr ""

msgid "Literal values, for example ``55`` or ``'Hello SQL world!'``, should be entered without single quote marks if they are numeric, and should be entered with single quote marks if they are strings."
msgstr ""

msgid "Object names, for example table1 or column1, should usually be entered without double quote marks and are subject to some restrictions. They may be enclosed in double quote marks and in that case they are subject to fewer restrictions."
msgstr ""

msgid "Almost all keywords are :ref:`reserved <sql_reserved_words>`, which means that they cannot be used as object names unless they are enclosed in double quote marks."
msgstr ""

msgid "Comments may be between ``/*`` and ``*/`` (bracketed) or between ``--`` and the end of a line (simple)."
msgstr ""

msgid "INSERT /* This is a bracketed comment */ INTO t VALUES (5);\n"
"INSERT INTO t VALUES (5); -- this is a simple comment"
msgstr ""

msgid "Expressions, for example ``a + b`` OR ``a > b AND NOT a <= b``, may have arithmetic operators ``+ - / *``, may have comparison operators ``= > < <= >= LIKE``, and may be combined with ``AND OR NOT``, with optional parentheses."
msgstr ""

msgid "SQL statements should end with ; (semicolon); this is not mandatory but it is recommended."
msgstr ""

msgid "In alphabetical order, the following statements are legal."
msgstr ""

msgid "|nbsp| :ref:`ALTER TABLE table-name [RENAME or ADD CONSTRAINT clauses]; <sql_alter_table>` |br| |nbsp| ANALYZE [table-name]; -- temporarily disabled in current version |br| |nbsp| :ref:`COMMIT; <sql_commit>` |br| |nbsp| :ref:`CREATE [UNIQUE] INDEX [IF NOT EXISTS] index-name <sql_create_index>` |br| |nbsp| |nbsp| |nbsp| |nbsp| :ref:`ON table-name (column-name [, column-name ...]); <sql_create_index>` |br| |nbsp| :ref:`CREATE TABLE [IF NOT EXISTS] table-name <sql_create_table>` |br| |nbsp| |nbsp| |nbsp| |nbsp| :ref:`(column-or-constraint-definition <sql_create_table>` |br| |nbsp| |nbsp| |nbsp| |nbsp| :ref:`[, column-or-constraint-definition ...]) <sql_create_table>` |br| |nbsp| |nbsp| |nbsp| |nbsp| :ref:`[WITH ENGINE = engine-name]; <sql_create_table>` |br| |nbsp| :ref:`CREATE TRIGGER [IF NOT EXISTS] trigger-name <sql_create_trigger>` |br| |nbsp| |nbsp| |nbsp| |nbsp| :ref:`BEFORE|AFTER INSERT|UPDATE|DELETE ON table-name <sql_create_trigger>` |br| |nbsp| |nbsp| |nbsp| |nbsp| :ref:`FOR EACH ROW <sql_create_trigger>` |br| |nbsp| |nbsp| |nbsp| |nbsp| :ref:`BEGIN dml-statement [, dml-statement ...] END; <sql_create_trigger>` |br| |nbsp| :ref:`CREATE VIEW [IF NOT EXISTS] view-name <sql_create_view>`  |br| |nbsp| |nbsp| |nbsp| |nbsp| :ref:`[(column-name [, column-name ...])] <sql_create_view>`  |br| |nbsp| |nbsp| |nbsp| |nbsp| :ref:`AS select-statement | values-statement; <sql_create_view>`  |br| |nbsp| :ref:`DROP INDEX [IF EXISTS] index-name ON table-name; <sql_drop_index>`  |br| |nbsp| :ref:`DROP TABLE [IF EXISTS] table-name; <sql_drop_table>`  |br| |nbsp| :ref:`DROP TRIGGER [IF EXISTS] trigger-name; <sql_drop_trigger>` |br| |nbsp| :ref:`DROP VIEW [IF EXISTS] view-name; <sql_drop_view>` |br| |nbsp| :ref:`EXPLAIN explainable-statement; <sql_explain>` |br| |nbsp| :ref:`INSERT INTO table-name <sql_insert>` |br| |nbsp| |nbsp| |nbsp| |nbsp| :ref:`[(column-name [, column-name ...])] <sql_insert>` |br| |nbsp| |nbsp| |nbsp| |nbsp| :ref:`values-statement | select-statement; <sql_insert>` |br| |nbsp| :ref:`PRAGMA pragma-name[(value)]; <sql_pragma>` |br| |nbsp| :ref:`RELEASE SAVEPOINT savepoint-name; <sql_release_savepoint>` |br| |nbsp| :ref:`REPLACE INTO table-name VALUES (expression [, expression ...]); <sql_replace>` |br| |nbsp| :ref:`ROLLBACK [TO [SAVEPOINT] savepoint-name]; <sql_rollback>` |br| |nbsp| :ref:`SAVEPOINT savepoint-name; <sql_savepoint>` |br| |nbsp| :ref:`SELECT [DISTINCT|ALL] expression [, expression ...] <sql_select>` |br| |nbsp| |nbsp| |nbsp| |nbsp| :ref:`FROM table-name | joined-table-names [AS alias]  <sql_select>` |br| |nbsp| |nbsp| |nbsp| |nbsp| :ref:`[WHERE expression] <sql_select>` |br| |nbsp| |nbsp| |nbsp| |nbsp| :ref:`[GROUP BY expression [, expression ...]] <sql_group_by>` |br| |nbsp| |nbsp| |nbsp| |nbsp| :ref:`[HAVING expression] <sql_having>` |br| |nbsp| |nbsp| |nbsp| |nbsp| :ref:`[ORDER BY expression] <sql_order_by>` |br| |nbsp| |nbsp| |nbsp| |nbsp| :ref:`LIMIT expression [OFFSET expression]]; <sql_limit>` |br| |nbsp| :ref:`START TRANSACTION; <sql_start_transaction>` |br| |nbsp| :ref:`TRUNCATE TABLE table-name; <sql_truncate>` |br| |nbsp| :ref:`UPDATE table-name <sql_update>` |br| |nbsp| |nbsp| |nbsp| |nbsp| :ref:`SET column-name=expression [,column-name=expression...] <sql_update>` |br| |nbsp| |nbsp| |nbsp| |nbsp| :ref:`[WHERE expression]; <sql_update>` |br| |nbsp| :ref:`VALUES (expression [, expression ...]; <sql_values>` |br| |nbsp| :ref:`WITH [RECURSIVE] common-table-expression; <sql_with>`"
msgstr ""

msgid "Differences from other products"
msgstr ""

msgid "Differences from other SQL products: We believe that Tarantool's SQL conforms to the majority of the listed mandatory requirements of the core SQL:2016 standard, and we enumerate the specific conformance statements in the feature list in a section about :ref:`\"compliance with the official SQL standard\" <sql>`. We believe that the deviations which most people will find notable are: type checking is less strict, and some data definition options must be done with NoSQL syntax."
msgstr ""

msgid "Differences from other NoSQL products: We have examined attempts by others to paste relatively smaller subsets of SQL onto NoSQL products, and concluded that Tarantool's SQL has demonstrably more features and capabilities. The reason is that we started with a complete code base of a working SQL DBMS and made it work with Tarantool-NoSQL underneath, rather than starting with a NoSQL DBMS and adding syntax to it."
msgstr ""

msgid "Concepts"
msgstr ""

msgid "In an earlier section of this documentation, we discussed: |br| What are: relational databases, tables, views, rows, and columns? |br| What are: transactions, write-ahead logs, commits and rollbacks? |br| What are: security considerations? |br| How do we: add, delete, or update rows in tables? |br| How do we: work inside transactions with commits and/or rollbacks? |br| How do we: select, join, filter, group, and sort rows?"
msgstr ""

msgid "Tarantool has a \"schema\". A schema is a container for all database objects. A schema may be called a \"database\" in other DBMS implementations"
msgstr ""

msgid "Tarantool allows four types of \"database objects\" to be created within the schema: tables, triggers, indexes, and constraints. Within tables, there are \"columns\"."
msgstr ""

msgid "Almost all Tarantool SQL statements begin with a reserved-word \"verb\" such as INSERT, and end optionally with a semicolon. For example: ``INSERT INTO t VALUES (1);``"
msgstr ""

msgid "A Tarantool SQL database and a Tarantool NoSQL database are the same thing. However, some operations are only possible with SQL, and others are only possible with NoSQL. Mixing SQL statements with NoSQL requests is allowed."
msgstr ""

msgid "Tokens"
msgstr ""

msgid "The token is the minimum SQL-syntax unit that Tarantool understands. These are the types of tokens:"
msgstr ""

msgid "Keywords -- official words in the language, for example ``SELECT`` |br| Literals -- constants for numbers or strings, for example ``15.7`` or ``'Taranto'`` |br| Identifiers -- for example column55 or table_of_accounts |br| Operators (strictly speaking \"non-alphabetic operators\") -- for example ``* / + - ( ) , ; < = >=``"
msgstr ""

msgid "Tokens can be separated from each other by one or more separators: |br| * White space characters: tab (U+0009), line feed (U+000A), vertical tab (U+000B), form feed (U+000C), carriage return (U+000D), space (U+0020), next line (U+0085), and all the rare characters in Unicode classes Zl and Zp and Zs. For a full list see https://github.com/tarantool/tarantool/issues/2371. |br| * Bracketed comments (beginning with ``/*`` and ending with ``*/``) |br| * Simple comments (beginning with ``--`` and ending with line feed) |br| Separators are not necessary before or after operators. |br| Separators are necessary after keywords or numbers or ordinary identifiers, unless the following token is an operator. |br| Thus Tarantool can understand this series of six tokens: |br| ``SELECT'a'FROM/**/t;`` |br| but for readability one would usually use spaces to separate tokens: |br| ``SELECT 'a' FROM /**/ t;``"
msgstr ""

msgid "Literals"
msgstr ""

msgid "There are five kinds of literals: BOOLEAN INTEGER DOUBLE STRING VARBINARY."
msgstr ""

msgid "BOOLEAN literals:  |br| TRUE | FALSE | UNKNOWN |br| A literal has :ref:`data type = BOOLEAN <sql_data_type_boolean>` if it is the keyword TRUE or FALSE. UNKNOWN is a synonym for NULL. A literal may have type = BOOLEAN if it is the keyword NULL and there is no context to indicate a different data type."
msgstr ""

msgid "INTEGER literals: |br| [plus-sign | minus-sign] digit [digit ...] |br| or, for a hexadecimal integer literal, |br| [plus-sign | minus-sign] 0X | 0x hexadecimal-digit [hexadecimal-digit ...] |br| Examples: 5, -5, +5, 55555, 0X55, 0x55 |br| Hexadecimal 0X55 is equal to decimal 85. A literal has :ref:`data type = INTEGER <sql_data_type_integer>` if it contains only digits and is in the range  -9223372036854775808 to +18446744073709551615, integers outside that range are illegal."
msgstr ""

msgid "DOUBLE literals: |br| [plus-sign | minus-sign] [digit [digit ...]] period [digit [digit ...]] |br| [E|e [plus-sign | minus-sign] digit ...] |br| Examples: .0, 1.0, 1E5, 1.1E5. |br| A literal has :ref:`data type = DOUBLE <sql_data_type_double>` if it contains a period, or contains \"E\". DOUBLE literals are also known as floating-point literals or approximate-numeric literals. To represent \"Inf\" (infinity), write a real number outside the double-precision number range, for example 1E309. To represent \"nan\" (not a number), write an expression that does not result in a real number, for example 0/0, using Tarantool/NoSQL. This will appear as NULL in Tarantool/SQL. In an earlier version literals containing periods were considered to be :ref:`NUMBER <sql_data_type_number>` literals. In a future version \"nan\" may not appear as NULL."
msgstr ""

msgid "STRING literals: |br| [quote] [character ...] [quote] |br| Examples: ``'ABC'``, ``'AB''C'`` |br| A literal has :ref:`data type type = STRING <sql_data_type_string>` if it is a sequence of zero or more characters enclosed in single quotes. The sequence ``''``  (two single quotes in a row) is treated as ``'`` (a single quote) when enclosed in quotes, that is, ``'A''B'`` is interpreted as ``A'B``."
msgstr ""

msgid "VARBINARY literals: |br| X|x [quote] [hexadecimal-digit-pair ...] [quote] |br| Example: ``X'414243'``, which will be displayed as ``'ABC'``. |br| A literal has :ref:`data type = VARBINARY <sql_data_type_varbinary>` (\"variable-length binary\") if it is the letter X followed by quotes containing pairs of hexadecimal digits, representing byte values."
msgstr ""

msgid "Here are four ways to put non-ASCII characters,such as the Greek letter  alpha,  in string literals: |br| First make sure that your shell program is set to accept characters as UTF-8. A simple way to check is |br| ``SELECT hex('');`` If the result is CEB1 -- which is the hexadecimal value for the UTF-8 representation of  -- it is good. |br| (1) Simply enclose the character inside ``'...'``, |br| ``''`` |br| or |br| (2) Find out what is the hexadecimal code for the UTF-8 representation of , and enclose that inside ``X'...'``, then cast to STRING because ``X'...'`` literals are data type VARBINARY not STRING, |br| ``CAST(X'CEB1' AS STRING)`` |br| or |br| (3) Find out what is the Unicode code point for , and pass that to the :ref:`CHAR function <sql_function_char>`. |br| ``CHAR(945)  /* remember that this is  as data type STRING not VARBINARY */`` |br| (4) Enclose statements inside double quotes and include Lua escapes, for example ``box.execute(\"SELECT '\\206\\177';\")`` |br| One can use the concatenation operator ``||`` to combine characters made with any of these methods."
msgstr ""

msgid "Limitations: (`Issue#2344 <https://github.com/tarantool/tarantool/issues/2344>`_) |br| * Numeric literals may be quoted, one cannot depend on the presence or absence of quote marks to determine whether a literal is numeric. |br| * ``LENGTH('A''B') = 3`` which is correct, but the display from ``SELECT A''B;`` is ``A''B``, which is misleading. |br| * It is unfortunate that ``X'41'`` is a byte sequence which looks the same as ``'A'``, but it is not the same. ``box.execute(\"select 'A' < X'41';\")`` is not legal at the moment. This happens because ``TYPEOF(X'41')`` yields ``'varbinary'``. Also it is illegal to say ``UPDATE ... SET string_column = X'41'``, one must say ``UPDATE ... SET string_column = CAST(X'41' AS STRING);``. |br| * It is non-standard to say that any number which contains a period has data type = DOUBLE."
msgstr ""

msgid "Identifiers"
msgstr ""

msgid "All database objects -- tables, triggers, indexes, columns, constraints, functions, collations -- have identifiers. An identifier should begin with a letter or underscore (``'_'``) and should contain only letters, digits, dollar signs (``'$'``), or underscores. The maximum number of bytes in an identifier is between 64982 and 65000. For compatibility reasons, Tarantool recommends that an identifier should not have more than 30 characters."
msgstr ""

msgid "Letters in identifiers do not have to come from the Latin alphabet, for example the Japanese syllabic  and the Cyrillic letter  are legal. But be aware that a Latin letter needs only one byte but a Cyrillic letter needs two bytes, so Cyrillic identifiers consume a tiny amount more space."
msgstr ""

msgid "Certain words are reserved and should not be used for identifiers. The simple rule is: if a word means something in Tarantool SQL syntax, do not try to use it for an identifier. The current list of reserved words is:"
msgstr ""

msgid "ALL ALTER ANALYZE AND ANY AS ASC ASENSITIVE AUTOINCREMENT BEGIN BETWEEN BINARY BLOB BOOL BOOLEAN BOTH BY CALL CASE CAST CHAR CHARACTER CHECK COLLATE COLUMN COMMIT CONDITION CONNECT CONSTRAINT CREATE CROSS CURRENT CURRENT_DATE CURRENT_TIME CURRENT_TIMESTAMP CURRENT_USER CURSOR DATE DATETIME dec DECIMAL DECLARE DEFAULT DEFERRABLE DELETE DENSE_RANK DESC DESCRIBE DETERMINISTIC DISTINCT DOUBLE DROP EACH ELSE ELSEIF END ESCAPE EXCEPT EXISTS EXPLAIN FALSE FETCH FLOAT FOR FOREIGN FROM FULL FUNCTION GET GRANT GROUP HAVING IF IMMEDIATE IN INDEX INNER INOUT INSENSITIVE INSERT INT INTEGER INTERSECT INTO IS ITERATE JOIN LEADING LEAVE LEFT LIKE LIMIT LOCALTIME LOCALTIMESTAMP LOOP MATCH NATURAL NOT NULL NUM NUMBER NUMERIC OF ON OR ORDER OUT OUTER OVER PARTIAL PARTITION PRAGMA PRECISION PRIMARY PROCEDURE RANGE RANK READS REAL RECURSIVE REFERENCES REGEXP RELEASE RENAME REPEAT REPLACE RESIGNAL RETURN REVOKE RIGHT ROLLBACK ROW ROWS ROW_NUMBER SAVEPOINT SCALAR SELECT SENSITIVE SET SIGNAL SIMPLE SMALLINT SPECIFIC SQL START STRING SYSTEM TABLE TEXT THEN TO TRAILING TRANSACTION TRIGGER TRIM TRUE TRUNCATE UNION UNIQUE UNKNOWN UNSIGNED UPDATE USER USING VALUES VARBINARY VARCHAR VIEW WHEN WHENEVER WHERE WHILE WITH"
msgstr ""

msgid "Identifiers may be enclosed in double quotes. These are called quoted identifiers or \"delimited identifiers\" (unquoted identifiers may be called \"regular identifiers\"). The double quotes are not part of the identifier. A delimited identifier may be a reserved word and may contain any printable character. Tarantool converts letters in regular identifiers to upper case before it accesses the database, so for statements like ``CREATE TABLE a (a INTEGER PRIMARY KEY);`` or ``SELECT a FROM a;`` the table name is A and the column name is A. However, Tarantool does not convert delimited identifiers to upper case, so for statements like ``CREATE TABLE \"a\" (\"a\" INTEGER PRIMARY KEY);`` or ``SELECT \"a\" FROM \"a\";`` the table name is a and the column name is a. The sequence ``\"\"`` is treated as ``\"`` when enclosed in double quotes, that is, ``\"A\"\"B\"`` is interpreted as ``\"A\"B\"``."
msgstr ""

msgid "Examples: things, t45, journal_entries_for_2017, , ``\"into\"``"
msgstr ""

msgid "Inside certain statements, identifiers may have \"qualifiers\" to prevent ambiguity. A qualifier is an identifier of a higher-level object, followed by a period. For example column1 within table1 may be referred to as table1.column1. The \"name\" of an object is the same as its identifier, or its qualified identifier. For example, inside ``SELECT t1.column1, t2.column1 FROM t1, t2;`` the qualifiers make it clear that the first column is column1 from table1 and the second column is column2 from table2."
msgstr ""

msgid "The rules are sometimes relaxed for compatibility reasons, for example some non-letter characters such as $ and  are legal in regular identifiers. However, it is better to assume that rules are never relaxed."
msgstr ""

msgid "The following are examples of legal and illegal identifiers."
msgstr ""

msgid "_A1   -- legal, begins with underscore and contains underscore | letter | digit\n"
"1_A   -- illegal, begins with digit\n"
"A$ -- legal, but not recommended, try to stick with digits and letters and underscores\n"
"+ -- illegal, operator token\n"
"grant -- illegal, GRANT is a reserved word\n"
"\"grant\" -- legal, delimited identifiers may be reserved words\n"
"\"_space\" -- legal, but Tarantool already uses this name for a system space\n"
"\"A\".\"X\" -- legal, for columns only, inside statements where qualifiers may be necessary\n"
"'a' -- illegal, single quotes are for literals not identifiers\n"
"A123456789012345678901234567890 -- legal, identifiers can be long\n"
" -- legal, and will be converted to upper case in identifiers"
msgstr ""

msgid "The following example shows that conversion to upper case affects regular identifiers but not delimited identifiers."
msgstr ""

msgid "CREATE TABLE \"q\" (\"q\" INTEGER PRIMARY KEY);\n"
"SELECT * FROM q;\n"
"-- Result = \"error: 'no such table: Q'."
msgstr ""

msgid "Operands"
msgstr ""

msgid "An operand is something that can be operated on. Literals and column identifiers are operands. So are NULL and DEFAULT."
msgstr ""

msgid "NULL and DEFAULT are keywords which represent values whose data types are not known until they are assigned or compared, so they are known by the technical term \"contextually typed value specifications\". (Exception: for the non-standard statement \"SELECT NULL FROM table-name;\"  NULL has data type BOOLEAN.)"
msgstr ""

msgid "Every operand has a data type."
msgstr ""

msgid "For literals, :ref:`as we saw earlier <sql_literals>`, the data type is usually determined by the format."
msgstr ""

msgid "For identifiers, the data type is usually determined by the definition."
msgstr ""

msgid "The usual determination may change because of context or because of :ref:`explicit casting <sql_function_cast>`."
msgstr ""

msgid "For some SQL data type names there are *aliases*. An alias may be used for data definition. For example VARCHAR(5) and TEXT are aliases of STRING and may appear in :samp:`CREATE TABLE {table_name} ({column_name} VARCHAR(5) PRIMARY KEY);` but Tarantool, if asked, will report that the data type of :samp:`{column_name}` is STRING."
msgstr ""

msgid "For every SQL data type there is a corresponding NoSQL type, for example an SQL STRING is stored in a NoSQL space as :ref:`type = 'string' <index-box_string>`."
msgstr ""

msgid "To avoid confusion in this manual, all references to SQL data type names are in upper case and all similar words which refer to NoSQL types or to other kinds of object are in lower case, for example:"
msgstr ""

msgid "STRING is a data type name, but string is a general term;"
msgstr ""

msgid "NUMBER is a data type name, but number is a general term."
msgstr ""

msgid "Although it is common to say that a VARBINARY value is a \"binary string\", this manual will not use that term and will instead say \"byte sequence\"."
msgstr ""

msgid "Here are all the SQL data types, their corresponding NoSQL types, their aliases, and minimum / maximum literal examples."
msgstr ""

msgid "**Data types**"
msgstr ""

msgid "SQL type"
msgstr ""

msgid "NoSQL type"
msgstr ""

msgid "Aliases"
msgstr ""

msgid "Minimum"
msgstr ""

msgid "Maximum"
msgstr ""

msgid "BOOLEAN"
msgstr ""

msgid "boolean"
msgstr ""

msgid "BOOL"
msgstr ""

msgid "FALSE"
msgstr ""

msgid "TRUE"
msgstr ""

msgid "INTEGER"
msgstr ""

msgid "integer"
msgstr ""

msgid "INT"
msgstr ""

msgid "-9223372036854775808"
msgstr ""

msgid "18446744073709551615"
msgstr ""

msgid "UNSIGNED"
msgstr ""

msgid "unsigned"
msgstr ""

msgid "(none)"
msgstr ""

msgid "0"
msgstr ""

msgid "DOUBLE"
msgstr ""

msgid "double"
msgstr ""

msgid "-1.79769e308"
msgstr ""

msgid "1.79769e308"
msgstr ""

msgid "NUMBER"
msgstr ""

msgid "number"
msgstr ""

msgid "STRING"
msgstr ""

msgid "string"
msgstr ""

msgid "TEXT, VARCHAR(n)"
msgstr ""

msgid "``''``"
msgstr ""

msgid "``'many-characters'``"
msgstr ""

msgid "VARBINARY"
msgstr ""

msgid "varbinary"
msgstr ""

msgid "``X''``"
msgstr ""

msgid "``X'many-hex-digits'``"
msgstr ""

msgid "SCALAR"
msgstr ""

msgid "scalar"
msgstr ""

msgid "BOOLEAN values are FALSE, TRUE, and UNKNOWN (which is the same as NULL). FALSE is less than TRUE."
msgstr ""

msgid "INTEGER values are numbers that do not contain decimal points and are not expressed with exponential notation. The range of possible values is between -2^63 and +2^64, or NULL."
msgstr ""

msgid "UNSIGNED values are numbers that do not contain decimal points and are not expressed with exponential notation. The range of possible values is between 0 and +2^64, or NULL."
msgstr ""

msgid "DOUBLE values are numbers that do contain decimal points (for example 0.5) or are expressed with exponential notation (for example 5E-1). The range of possible values is the same as for the IEEE 754 floating-point standard, or NULL. Numbers outside the range of DOUBLE literals may be displayed as -inf or inf."
msgstr ""

msgid "NUMBER values have the same range as DOUBLE values. But NUMBER values may also also be integers, and, if so, arithmetic operation results will be exact rather than approximate. There is no literal format for NUMBER (literals like ``1.5`` or ``1E555`` are considered to be DOUBLEs), so use :ref:`CAST <sql_function_cast>` to insist that a number has data type NUMBER, but that is rarely necessary. See the description of NoSQL type :ref:`'number' <index-box_number>`."
msgstr ""

msgid "STRING values are any sequence of zero or more characters encoded with UTF-8, or NULL. The possible character values are the same as for the Unicode standard. Byte sequences which are not valid UTF-8 characters are allowed but not recommended. STRING literal values are enclosed within single quotes, for example ``'literal'``. If the VARCHAR alias is used for column definition, it must include a maximum length, for example column_1 VARCHAR(40). However, the maximum length is ignored. The data-type may be followed by :ref:`[COLLATE collation-name] <sql_collate_clause>`."
msgstr ""

msgid "VARBINARY values are any sequence of zero or more octets (bytes), or NULL. VARBINARY literal values are expressed as X followed by pairs of hexadecimal digits enclosed within single quotes, for example ``X'0044'``. VARBINARY's NoSQL equivalent is ``'varbinary'`` but not character string -- the MessagePack storage is MP_BIN (MsgPack binary)."
msgstr ""

msgid "SCALAR can be used for :ref:`column definitions <sql_column_def_data_type>` but the individual column values have one of the preceding types -- BOOLEAN, INTEGER, DOUBLE, STRING, or VARBINARY. See more about SCALAR in the section :ref:`Column definition -- the rules for the SCALAR data type <sql_column_def_scalar>`. The data-type may be followed by :ref:`[COLLATE collation-name] <sql_collate_clause>`."
msgstr ""

msgid "Any value of any data type may be NULL. Ordinarily NULL will be cast to the data type of any operand it is being compared to or to the data type of the column it is in. If the data type of NULL cannot be determined from context, it is BOOLEAN."
msgstr ""

msgid "All the SQL data types correspond to :ref:`Tarantool/NoSQL types <details_about_index_field_types>` with the same name. There are also some Tarantool/NoSQL data types which have no corresponding SQL data types. If Tarantool/SQL reads a Tarantool/NoSQL value which has a type which has no SQL equivalent, Tarantool/SQL may treat it as NULL or INTEGER or VARBINARY. For example, ``SELECT \"flags\" FROM \"_space\";`` will return a column whose data type is ``'map'``. Such columns can only be manipulated in SQL by :ref:`invoking Lua functions <sql_calling_lua>`."
msgstr ""

msgid "Operators"
msgstr ""

msgid "An operator signifies what operation can be performed on operands."
msgstr ""

msgid "Almost all operators are easy to recognize because they consist of one-character or two-character non-alphabetic tokens, except for six keyword operators (AND IN IS LIKE NOT OR)."
msgstr ""

msgid "Almost all operators are \"dyadic\", that is, they are performed on a pair of operands -- the only operators that are performed on a single operand are NOT and ~ and (sometimes) -."
msgstr ""

msgid "The result of an operation is a new operand. If the operator is a comparison operator then the result has data type BOOLEAN (TRUE or FALSE or UNKNOWN). Otherwise the result has the same data type as the original operands, except that: promotion to a broader type may occur to avoid overflow. Arithmetic with NULL operands will result in a NULL operand."
msgstr ""

msgid "In the following list of operators, the tag \"(arithmetic)\" indicates that all operands are expected to be numbers and should result in a number; the tag \"(comparison)\" indicates that operands are expected to have similar data types and should result in a BOOLEAN; the tag \"(logic)\" indicates that operands are expected to be BOOLEAN and should result in a BOOLEAN. Exceptions may occur where operations are not possible, but see the \"special situations\" which are described after this list. Although all examples show literals, they could just as easily show column identifiers."
msgstr ""

msgid "``+`` addition (arithmetic) Add two numbers according to standard arithmetic rules. Example: ``1 + 5``, result = 6."
msgstr ""

msgid "``-`` subtraction (arithmetic) Subtract second number from first number according to standard arithmetic rules. Example: ``1 - 5``, result = -4."
msgstr ""

msgid "``*`` multiplication (arithmetic) Multiply two numbers according to standard arithmetic rules. Example: ``2 * 5``, result = 10."
msgstr ""

msgid "``/`` division (arithmetic) Divide second number into first number according to standard arithmetic rules. Division by zero is not legal. Division of integers always results in rounding down, use :ref:`CAST <sql_function_cast>` to NUMBER to get non-integer results. Example: ``5 / 2``, result = 2."
msgstr ""

msgid "``%`` modulus (arithmetic) Divide second number into first number according to standard arithmetic rules. The result is the remainder. Example: ``17 % 5``, result = 2."
msgstr ""

msgid "``<<`` shift left (arithmetic) Shift the first number to the left N times, where N = the second number. For positive numbers, each 1-bit shift to the left is equivalent to multiplying times 2. Example: ``5 << 1``, result = 10."
msgstr ""

msgid "``>>`` shift right (arithmetic) Shift the first number to the right N times, where N = the second number. For positive numbers, each 1-bit shift to the right is equivalent to dividing by 2. Example: ``5 >> 1``, result = 2."
msgstr ""

msgid "``&`` and (arithmetic) Combine the two numbers, with 1 bits in the result if and only if both original numbers have 1 bits. Example: ``5 & 4``, result = 4."
msgstr ""

msgid "``|`` or (arithmetic) Combine the two numbers, with 1 bits in the result if either original number has a 1 bit. Example: ``5 | 2``, result = 7."
msgstr ""

msgid "``~`` negate (arithmetic), sometimes called bit inversion Change 0 bits to 1 bits, change 1 bits to 0 bits. Example: ``~5``, result = -6."
msgstr ""

msgid "``<`` less than (comparison) Return TRUE if the first operand is less than the second by arithmetic or collation rules. Example for numbers: ``5 < 2``, result = FALSE. Example for strings: ``'C' < ' '``, result = FALSE."
msgstr ""

msgid "``<=`` less than or equal (comparison) Return TRUE if the first operand is less than or equal to the second by arithmetic or collation rules. Example for numbers: ``5 <= 5``, result = TRUE. Example for strings: ``'C' <= 'B'``, result = FALSE."
msgstr ""

msgid "``>`` greater than (comparison) Return TRUE if the first operand is greater than the second by arithmetic or collation rules. Example for numbers: ``5 > -5``, result = TRUE. Example for strings: ``'C' > '!'``, result = TRUE."
msgstr ""

msgid "``>=`` greater than or equal (comparison) Return TRUE if the first operand is greater than or equal to the second by arithmetic or collation rules. Example for numbers: ``0 >= 0``, result = TRUE. Example for strings: ``'Z' >= ''``, result = FALSE."
msgstr ""

msgid "``=`` equal (assignment or comparison) After the word SET, \"=\" means the first operand gets the value from the second operand. In other contexts, \"=\" returns TRUE if operands are equal. Example for assignment: ``... SET column1 = 'a';`` Example for numbers: ``0 = 0``, result = TRUE. Example for strings:  ``'1' = '2 '``, result = FALSE."
msgstr ""

msgid "``==`` equal (assignment), or equal (comparison) This is a non-standard equivalent of :ref:`\"= equal (assignment or comparison)\" <sql_equal>`."
msgstr ""

msgid "``<>`` not equal (comparison) Return TRUE if the first operand is not equal to the second by arithmetic or collation rules. Example for strings: ``'A' <> 'A     '`` is TRUE."
msgstr ""

msgid "``!=`` not equal (comparison) This is a non-standard equivalent of :ref:`\"<> not equal (comparison)\" <sql_not_equal>`."
msgstr ""

msgid "``IS NULL`` and ``IS NOT NULL`` (comparison) For IS NULL: Return TRUE if the first operand is NULL, otherwise return FALSE. Example: column1 IS NULL, result = TRUE if column1 contains NULL. For IS NOT NULL: Return FALSE if the first operand is NULL, otherwise return TRUE. Example: ``column1 IS NOT NULL``, result = FALSE if column1 contains NULL."
msgstr ""

msgid "``LIKE`` (comparison) Perform a comparison of two string operands. If the second operand contains ``'_'``, the ``'_'`` matches any single character in the first operand. If the second operand contains ``'%'``, the ``'%'`` matches 0 or more characters in the first operand. If it is necessary to search for either ``'_'`` or ``'%'`` within a string without treating it specially, an optional clause can be added, ESCAPE single-character-operand, for example ``'abc_' LIKE 'abcX_' ESCAPE 'X'`` is TRUE because ``X'`` means \"following character is not special\". Matching is also affected by the string's collation."
msgstr ""

msgid "``NOT`` negation (logic) Return TRUE if operand is FALSE return FALSE if operand is TRUE, else return UNKNOWN. Example: ``NOT (1 > 1)``, result = TRUE."
msgstr ""

msgid "``IN`` is equal to one of a list of operands (comparison) Return TRUE if first operand equals any of the operands in a parenthesized list. Example: ``1 IN (2,3,4,1,7)``, result = TRUE."
msgstr ""

msgid "``AND`` and (logic) Return TRUE if both operands are TRUE. Return UNKNOWN if both operands are UNKNOWN. Return UNKNOWN if one operand is TRUE and the other operand is UNKNOWN. Return FALSE if one operand is FALSE and the other operand is (UNKNOWN or TRUE or FALSE)."
msgstr ""

msgid "``OR`` or (logic) Return TRUE if either operand is TRUE. Return FALSE if both operands are FALSE. Return UNKNOWN if one operand is UNKNOWN and the other operand is (UNKNOWN or FALSE)."
msgstr ""

msgid "``||`` concatenate (string manipulation) Return the value of the first operand concatenated with the value of the second operand. Example: ``'A' || 'B'``, result = ``'AB'``."
msgstr ""

msgid "The precedence of dyadic operators is:"
msgstr ""

msgid "||\n"
"* / %\n"
"+ -\n"
"<< >> & |\n"
"<  <= > >=\n"
"=  == != <> IS IS NOT IN LIKE\n"
"AND\n"
"OR"
msgstr ""

msgid "To ensure a desired precedence, use () parentheses."
msgstr ""

msgid "Special Situations"
msgstr ""

msgid "If one of the operands has data type DOUBLE, Tarantool uses floating-point arithmetic. This means that exact results are not guaranteed and rounding may occur without warning. For example, 4.7777777777777778 = 4.7777777777777777 is TRUE."
msgstr ""

msgid "The floating-point values inf and -inf are possible. For example, ``SELECT 1e318, -1e318;`` will return \"inf, -inf\". Arithmetic on infinite values may cause NULL results, for example ``SELECT 1e318 - 1e318;`` is NULL and ``SELECT 1e318 * 0;`` is NULL."
msgstr ""

msgid "SQL operations never return the floating-point value -nan, although it may exist in data created by Tarantool's NoSQL. In SQL, -nan is treated as NULL."
msgstr ""

msgid "A string will be converted to a number if it is used with an arithmetic operator and conversion is possible, for example ``'7' + '7'`` = 14. And for comparison or assignment, ``'7'`` = 7. This is called implicit casting. It is applicable for STRINGs and all numeric data types."
msgstr ""

msgid "Limitations: (`Issue#2346 <https://github.com/tarantool/tarantool/issues/2346>`_) |br| * Some words, for example MATCH and REGEXP, are reserved but are not necessary for current or planned Tarantool versions |br| * 999999999999999 << 210 yields 0. (1 << 63) >> 63 yields -1."
msgstr ""

msgid "Expressions"
msgstr ""

msgid "An expression is a chunk of syntax that causes return of a value. Expressions may contain literals, column-names, operators, and parentheses."
msgstr ""

msgid "Therefore these are examples of expressions: ``1``, ``1 + 1 << 1``, ``(1 = 2) OR 4 > 3``, ``'x' || 'y' || 'z'``."
msgstr ""

msgid "Also there are two expressions that involve keywords:"
msgstr ""

msgid "value IS [NOT] NULL |br|"
msgstr ""

msgid "... for determining whether value is (not) NULL"
msgstr ""

msgid "CASE ... WHEN ... THEN ... ELSE ... END |br|"
msgstr ""

msgid "... for setting a series of conditions"
msgstr ""

msgid "See also: :ref:`subquery <sql_subquery>`."
msgstr ""

msgid "Limitations: IS TRUE and IS FALSE return an error."
msgstr ""

msgid "Comparing and Ordering"
msgstr ""

msgid "There are rules for determining whether value-1 is \"less than\", \"equal to\", or \"greater than\" value-2. These rules are applied for searches, for sorting results in order by column values, and for determining whether a column is unique. The result of a comparison of two values can be TRUE, FALSE, or UNKNOWN (the three BOOLEAN values). Sometimes for retrieval TRUE is converted to 1, FALSE is converted to 0, UNKNOWN is converted to NULL. For any comparisons where neither operand is NULL, the operands are \"distinct\" if the comparison result is FALSE. For any set of operands where all operands are distinct from each other, the set is considered to be \"unique\"."
msgstr ""

msgid "When comparing a number to a number: |br| * infinity = infinity is true |br| * regular numbers are compared according to usual arithmetic rules"
msgstr ""

msgid "When comparing any value to NULL: |br| (for examples in this paragraph assume that column1 in table T contains {NULL, NULL, 1, 2}) |br| * value comparison-operator NULL is UNKNOWN (not TRUE and not FALSE), which affects \"WHERE condition\" because the condition must be TRUE, and does not affect  \"CHECK (condition)\" because the condition must be either TRUE or UNKNOWN. Therefore SELECT * FROM T WHERE column1 > 0 OR column1 < 0 OR column1 = 0; returns only  {1,2}, and the table can have been created with CREATE TABLE T (... column1 INTEGER, CHECK (column1 >= 0)); |br| * for any operations that contain the keyword DISTINCT, NULLs are not distinct. Therefore SELECT DISTINCT column1 FROM T; will return {NULL,1,2}. |br| * for grouping, NULL values sort together. Therefore SELECT column1, COUNT(*) FROM T GROUP BY column1; will include a row {NULL, 2}. |br| * for ordering, NULL values sort together and are less than non-NULL values. Therefore SELECT column1 FROM T ORDER BY column1; returns {NULL, NULL, 1,2}. |br| * for evaluating a UNIQUE constraint or UNIQUE index, any number of NULLs is okay. Therefore CREATE UNIQUE INDEX i ON T (column1); will succeed."
msgstr ""

msgid "When comparing a number to a STRING: |br| * If implicit casting is possible, the STRING operand is converted to a number before comparison. If implicit casting is not possible, and one of the operands is the name of a column which was defined as SCALAR, and the column is being compared with a number, then number is less than STRING. Otherwise, the comparison is not legal."
msgstr ""

msgid "When comparing a BOOLEAN to a BOOLEAN: |br| TRUE is greater than FALSE."
msgstr ""

msgid "When comparing a VARBINARY to a VARBINARY: |br| * The numeric value of each pair of bytes is compared until the end of the byte sequences or until inequality. If two byte sequences are otherwise equal but one is longer, then the longer one is greater."
msgstr ""

msgid "When comparing for the sake of eliminating duplicates: |br| * This is usually signalled by the word DISTINCT, so it applies to SELECT DISTINCT, to set operators such as UNION (where DISTINCT is implied), and to aggregate functions such as  AVG(DISTINCT). |br| * Two operators are \"not distinct\" if they are equal to each other, or are both NULL |br| * If two values are equal but not identical, for example 1.0 and 1.00, they are non-distinct and there is no way to specify which one will be eliminated |br| * Values in primary-key or unique columns are distinct due to definition."
msgstr ""

msgid "When comparing a STRING to a STRING: |br| * Ordinarily collation is \"binary\", that is, comparison is done according to the numeric values of the bytes. This can be cancelled by adding a :ref:`COLLATE clause <sql_collate_clause>` at the end of either expression. So ``'A' < 'a'`` and ``'a' < ''``, but ``'A' COLLATE \"unicode_ci\" = 'a'`` and ``'a' COLLATE \"unicode_ci\" = ''``. |br| * When comparing a column with a string literal, the column's defined collation is used. |br| * Ordinarily trailing spaces matter. So ``'a' = 'a  '`` is not TRUE. This can be cancelled by using the :ref:`TRIM(TRAILING ...) <sql_function_trim>` function. |br|"
msgstr ""

msgid "Limitations: |br| * LIKE comparisons return integer results according to meta-information. |br| * LIKE is not expected to work with VARBINARY."
msgstr ""

msgid "Data Type Conversion"
msgstr ""

msgid "Data type conversion, also called casting, is necessary for any operation involving two operands X and Y, when X and Y have different data types. |br| Or, casting is necessary for assignment operations (when INSERT or UPDATE is putting a value of type X into a column defined as type Y). |br| Casting can be \"explicit\" when a user uses the :ref:`CAST <sql_function_cast>` function, or \"implicit\" when Tarantool does a conversion automatically."
msgstr ""

msgid "The general rules are fairly simple: |br| Assignments and operations involving NULL cause NULL or UNKNOWN results. |br| For arithmetic, convert to the data type which can contain both operands and the result. |br| For explicit casts, if a meaningful result is possible, the operation is allowed. |br| For implicit casts, if a meaningful result is possible and the data types on both sides are either STRINGs or numbers (that is, are STRING or INTEGER or UNSIGNED or DOUBLE or NUMBER), the operation is sometimes allowed."
msgstr ""

msgid "The specific situations in this chart follow the general rules:"
msgstr ""

msgid "~                To BOOLEAN | To INTEGER | To DOUBLE | To STRING | To VARBINARY\n"
"---------------  ----------   ----------   ---------   ---------   ------------\n"
"From BOOLEAN   | AAA        | A--        | ---       | A--       | ---\n"
"From INTEGER   | A--        | AAA        | AAA       | AAA       | ---\n"
"From DOUBLE    | A--        | SSA        | AAA       | AAA       | ---\n"
"From STRING    | S--        | SSS        | SSS       | AAA       | A--\n"
"From VARBINARY | ---        | ---        | ---       | A--       | AAA"
msgstr ""

msgid "Where each entry in the chart has 3 characters: |br| Where A = Always allowed, S = Sometimes allowed, - = Never allowed. |br| The first character of an entry is for explicit casts, |br| the second character is for implicit casts for assignment, |br| the third character is for implicit cast for comparison. |br| So AAA = Always for explicit, Always for Implicit (assignment), Always for Implicit (comparison)."
msgstr ""

msgid "The S \"Sometimes allowed\" character applies for these special situations: |br| From STRING To BOOLEAN is allowed if UPPER(string-value) = ``'TRUE'`` or ``'FALSE'``. |br| From DOUBLE to INTEGER is allowed for cast and assignment only if the result is not out of range. |br| From STRING to INTEGER or DOUBLE is allowed only if the string has a representation of a number."
msgstr ""

msgid "The chart does not show To|From SCALAR because the conversions depend on the type of the value, not the type of the column definition. Explicit cast to SCALAR is allowed but has no effect, the result data type is always the same as the original data type. But comparisons of values of different types are allowed if the definition is SCALAR."
msgstr ""

msgid "Examples of casts, illustrating the situations in the chart:"
msgstr ""

msgid "``CAST(TRUE AS INTEGER)`` is legal because the intersection of the  \"From BOOLEAN\" row with the \"To INTEGER\" column is ``A--`` and the first letter of ``A--`` is for explicit cast and A means Always Allowed. The result is 1."
msgstr ""

msgid "``UPDATE ... SET varbinary_column = 'A'`` is illegal because the intersection of the \"From STRING\" row with the \"To VARBINARY\" column is ``A--`` and the second letter of ``A--`` is for implicit cast (assignment) and - means not allowed. The result is an error message."
msgstr ""

msgid "``1.7E-1 > 0`` is legal because the intersection of the \"From DOUBLE\" row with the \"To INTEGER\" column is AAA, and the third letter of AAA is for implicit cast (comparison) and A means Always Allowed. The result is TRUE."
msgstr ""

msgid "``11 > '2'`` is legal because the intersection of the \"From INTEGER\" row with the \"To STRING\" column is AAA and the third letter of AAA is for implicit cast (comparison) and A means Always Allowed. The result is TRUE.  For detailed explanation see the following section."
msgstr ""

msgid "Implicit string/numeric cast"
msgstr ""

msgid "Special considerations may apply for casting STRINGs to/from INTEGERs/DOUBLEs (numbers) for comparison or assignment."
msgstr ""

msgid "``1 = '1' /* compare a STRING with a number */`` |br| ``UPDATE ... SET string_column = 1 /* assign a number to a STRING */``"
msgstr ""

msgid "For comparisons, the cast is always from STRING to number. |br| Therefore ``1e2 = '100'`` is TRUE, and ``11 > '2'`` is TRUE. |br| If the cast fails, then the number is less than the STRING. |br| Therefore ``1e400 < ''`` is TRUE. |br| Exception: for BETWEEN the cast is to the data type of the first and last operands. |br| Therefore ``'66' BETWEEN 5 AND '7'`` is TRUE."
msgstr ""

msgid "For assignments, the cast is always from source to target. Therefore ``INSERT INTO t (integer_column) VALUES ('5');`` inserts 5. |br| |br| If the cast fails, then the result is an error."
msgstr ""

msgid "Implicit cast also happens if STRINGS are used in arithmetic. |br| Therefore ``'5' / '5' = 1``. If the cast fails, then the result is an error. |br| Therefore ``'5' / ''`` is an error."
msgstr ""

msgid "Implicit cast does NOT happen if numbers are used in concatenation, or in LIKE. |br| Therefore ``5 || 5`` is illegal."
msgstr ""

msgid "In the following examples, implicit cast does not happen for SCALAR column values: |br| ``DROP TABLE scalars;`` |br| ``CREATE TABLE scalars (scalar_column SCALAR PRIMARY KEY);`` |br| ``INSERT INTO scalars VALUES (11), ('2');`` |br| ``SELECT * FROM scalars WHERE scalar_column > 11;   /* 0 rows. So 11 > '2'. */`` |br| ``SELECT * FROM scalars WHERE scalar_column < '2';  /* 1 row. So 11 < '2'. */`` |br| ``SELECT max(scalar_column) FROM scalars; /* 1 row: '2'. So 11 < '2'. */`` |br| ``SELECT sum(scalar_column) FROM scalars; /* 1 row: 13. So cast happened. */`` |br| These results are not affected by indexing, or by reversing the operands."
msgstr ""

msgid "Implicit cast does NOT happen for :ref:`GREATEST() <sql_function_greatest>` or :ref:`LEAST() <sql_function_least>`. Therefore ``LEAST('5',6)`` is 6."
msgstr ""

msgid "For function arguments: |br| If the function description says that a parameter has a specific data type, and implicit assignment casts are allowed, then arguments which are not passed with that data type will be converted before the function is applied. |br| For example, the :ref:`LENGTH() <sql_function_length>` function expects a STRING or VARBINARY, and INTEGER  can be converted to STRING, therefore LENGTH(15) will return the length of ``'15'``, that is, 2. |br| But implicit cast sometimes does NOT happen for parameters. Therefore ``ABS('5')`` will cause an error message after `Issue#4159 <https://github.com/tarantool/tarantool/issues/4159>`_ is fixed. However, :ref:`TRIM(5) <sql_function_trim>` will still be legal."
msgstr ""

msgid "Although it is not a requirement of the SQL standard, implicit cast is supposed to help compatibility with other DBMSs. However, other DBMSs have different rules about what can be converted (for example they may allow assignment of ``'inf'`` but disallow comparison with ``'1e5'``). And, of course, it is not possible to be compatible with other DBMSs and at the same time support SCALAR, which other DBMSs do not have."
msgstr ""

msgid "Limitations (`Issue#3809 <https://github.com/tarantool/tarantool/issues/3809>`_): |br| Result of concatenation, or out-of-bound result, may have wrong type. |br| Parameter conversion behavior will change (`Issue#4159 <https://github.com/tarantool/tarantool/issues/4159>`_). After issue#4159 is done, LENGTH(15) will be illegal."
msgstr ""

msgid "Statements"
msgstr ""

msgid "A statement consists of SQL-language keywords and expressions that direct Tarantool to do something with a database. Statements begin with one of the words ALTER ANALYZE COMMIT CREATE DELETE DROP EXPLAIN INSERT PRAGMA RELEASE REPLACE ROLLBACK SAVEPOINT SELECT START TRUNCATE UPDATE VALUES WITH. Statements should end with \";\" semicolon although this is not mandatory."
msgstr ""

msgid "A client sends a statement to the Tarantool server. The Tarantool server parses the statement and executes it. If there is an error, Tarantool returns an error message."
msgstr ""

msgid "SQL statements and clauses"
msgstr ""

msgid "ALTER TABLE"
msgstr ""

msgid "Syntax:"
msgstr ""

msgid ":samp:`ALTER TABLE {table-name} RENAME TO {new-table-name};`"
msgstr ""

msgid ":samp:`ALTER TABLE {table-name} ADD CONSTRAINT {constraint-name} {constraint-definition};`"
msgstr ""

msgid ":samp:`ALTER TABLE {table-name} DROP CONSTRAINT {constraint-name};`"
msgstr ""

msgid ":samp:`ALTER TABLE {table-name} ENABLE|DISABLE CHECK CONSTRAINT {constraint-name};`"
msgstr ""

msgid "|br|"
msgstr ""

msgid "ALTER is used to change a table's name or a table's constraints."
msgstr ""

msgid "Examples:"
msgstr ""

msgid "For renaming a table with ``ALTER ... RENAME``, the *old-table* must exist, the *new-table* must not exist. Example: |br| ``-- renaming a table:`` ``ALTER TABLE t1 RENAME TO t2;``"
msgstr ""

msgid "For adding a :ref:`table constraint <sql_table_constraint_def>` with ``ADD CONSTRAINT``, the table must exist, the table must be empty, the constraint name must be unique within the table. Example with a :ref:`foreign-key constraint definition <sql_foreign_key>`: |br| ``ALTER TABLE t1 ADD CONSTRAINT fk_s1_t1_1 FOREIGN KEY (s1) REFERENCES t1;`` |br|"
msgstr ""

msgid "It is not possible to say ``CREATE TABLE table_a ... REFERENCES table_b ...`` if table ``b`` does not exist yet. This is a situation where ``ALTER TABLE`` is handy -- users can ``CREATE TABLE table_a`` without the foreign key, then ``CREATE TABLE table_b``, then ``ALTER TABLE table_a ... REFERENCES table_b ...``."
msgstr ""

msgid "-- adding a primary-key constraint definition:\n"
"-- This is unusual because primary keys are created automatically\n"
"-- and it is illegal to have two primary keys for the same table.\n"
"-- However, it is possible to drop a primary-key index, and this\n"
"-- is a way to restore the primary key if that happens.\n"
"ALTER TABLE t1 ADD CONSTRAINT pk_s1_t1_1 PRIMARY KEY (s1);\n"
"\n"
"-- adding a unique-constraint definition:\n"
"-- Alternatively, you can say CREATE UNIQUE INDEX unique_key ON t1 (s1);\n"
"ALTER TABLE t1 ADD CONSTRAINT uk_s1_t1_1 UNIQUE (s1);\n"
"\n"
"-- Adding a check-constraint definition:\n"
"ALTER TABLE t1 ADD CONSTRAINT ck_s1_t1_1 CHECK (s1 > 0);"
msgstr ""

msgid "For ``ALTER ... DROP CONSTRAINT``, it is only legal to drop a named constraint, and Tarantool only looks for names of foreign-key constraints. (Tarantool generates the constraint names automatically if the user does not provide them.)"
msgstr ""

msgid "To remove a unique constraint, use :ref:`DROP INDEX <sql_drop_index>`, which will drop the constraint as well."
msgstr ""

msgid "-- dropping a constraint:\n"
"ALTER TABLE t1 DROP CONSTRAINT ck_s1_t1_1;"
msgstr ""

msgid "For ``ALTER ... ENABLE|DISABLE CHECK CONSTRAINT``, it is only legal to enable or disable a named constraint, and Tarantool only looks for names of check constraints. By default a constraint is enabled. If a constraint is disabled, then the check will not be performed."
msgstr ""

msgid "-- disabling and re-enabling a constraint:\n"
"ALTER TABLE t1 DISABLE CHECK CONSTRAINT c;\n"
"ALTER TABLE t1 ENABLE CHECK CONSTRAINT c;"
msgstr ""

msgid "Limitations:"
msgstr ""

msgid "It is not possible to add or drop a column."
msgstr ""

msgid "It is not possible to modify NOT NULL constraints or column properties DEFAULT and :ref:`data type <sql_column_def_data_type>`. However, it is possible to modify them with Tarantool/NOSQL, for example by calling :ref:`space_object:format() <box_space-format>` with a different ``is_nullable`` value."
msgstr ""

msgid "CREATE TABLE"
msgstr ""

msgid ":samp:`CREATE TABLE [IF NOT EXISTS] {table-name} ((column-definition or table-constraint list)` :samp:`[WITH ENGINE = {string}];`"
msgstr ""

msgid "Create a new base table, usually called a \"table\"."
msgstr ""

msgid "A table is a *base table* if it is created with CREATE TABLE and contains data in persistent storage."
msgstr ""

msgid "A table is a *viewed table*, or just \"view\", if it is created with :ref:`CREATE VIEW <sql_create_view>` and gets its data from other views or from base tables."
msgstr ""

msgid "The *table-name* must be an identifier which is valid according to the rules for identifiers, and must not be the name of an already existing base table or view."
msgstr ""

msgid "The *column-definition* or *table-constraint* list is a comma-separated list of :ref:`column definitions <sql_column_def>` or table constraints."
msgstr ""

msgid "A *table-element-list* must be a comma-separated list of table elements; each table element may be either a column definition or a :ref:`table constraint definition <sql_table_constraint_def>`."
msgstr ""

msgid "Rules:"
msgstr ""

msgid "A primary key is necessary; it can be specified with a table constraint PRIMARY KEY."
msgstr ""

msgid "There must be at least one column."
msgstr ""

msgid "When IF NOT EXISTS is specified, and there is already a table with the same name, the statement is ignored."
msgstr ""

msgid "When :samp:`WITH ENGINE = {string}` is specified, where :samp:`string}` must be either 'memtx' or 'vinyl', the table is created with that :ref:`storage engine <engines-chapter>`. When this clause is not specified, the table is created with the default engine, which is ordinarily 'memtx' but may be changed by updating a table that has a list of session settings."
msgstr ""

msgid "Actions:"
msgstr ""

msgid "Tarantool evaluates each column definition and *table-constraint*, and returns an error if any of the rules is violated."
msgstr ""

msgid "Tarantool makes a new definition in the schema."
msgstr ""

msgid "Tarantool makes new indexes for PRIMARY KEY or UNIQUE constraints. A unique index name is created automatically."
msgstr ""

msgid "Tarantool effectively executes a :ref:`COMMIT <sql_commit>` statement."
msgstr ""

msgid "-- the simplest form, with one column and one constraint:\n"
"CREATE TABLE t1 (s1 INTEGER, PRIMARY KEY (s1));\n"
"\n"
"-- you can see the effect of the statement by querying\n"
"-- Tarantool system spaces:\n"
"SELECT * FROM \"_space\" WHERE \"name\" = 'T1';\n"
"SELECT * FROM \"_index\" JOIN \"_space\" ON \"_index\".\"id\" = \"_space\".\"id\"\n"
"         WHERE \"_space\".\"name\" = 'T1';\n"
"\n"
"-- variation of the simplest form, with delimited identifiers\n"
"-- and an inline comment:\n"
"CREATE TABLE \"T1\" (\"S1\" INT /* synonym of INTEGER */, PRIMARY KEY (\"S1\"));\n"
"\n"
"-- two columns, one named constraint\n"
"CREATE TABLE t1 (s1 INTEGER, s2 STRING, CONSTRAINT pk_s1s2_t1_1 PRIMARY KEY (s1, s2));"
msgstr ""

msgid "The maximum number of columns is 2000."
msgstr ""

msgid "The maximum length of a row depends on the :ref:`memtx_max_tuple_size <cfg_storage-memtx_max_tuple_size>` or :ref:`vinyl_max_tuple_size  <cfg_storage-memtx_max_tuple_size>` configuration option."
msgstr ""

msgid "Column definition"
msgstr ""

msgid ":samp:`column-name data-type [, column-constraint]`"
msgstr ""

msgid "Define a column, which is a table-element used in a :ref:`CREATE TABLE <sql_create_table>` statement."
msgstr ""

msgid "The ``column-name`` must be an identifier which is valid according to the rules for identifiers."
msgstr ""

msgid "Each ``column-name`` must be unique within a table."
msgstr ""

msgid "Column definition -- data type"
msgstr ""

msgid "Every column has a data type: BOOLEAN or INTEGER or UNSIGNED or DOUBLE or NUMBER or STRING or VARBINARY or SCALAR. The detailed description of data types is in the section :ref:`Operands <sql_operands>`."
msgstr ""

msgid "Column definition -- the rules for the SCALAR data type"
msgstr ""

msgid "SCALAR is a \"complex\" data type, unlike all the other data types which are \"primitive\". Two column values in a SCALAR column can have two different primitive data types."
msgstr ""

msgid "Any item defined as SCALAR has an underlying primitive type. For example, here:"
msgstr ""

msgid "CREATE TABLE t (s1 SCALAR PRIMARY KEY);\n"
"INSERT INTO t VALUES (55), ('41');"
msgstr ""

msgid "the underlying primitive type of the item in the first row is INTEGER because literal 55 has data type INTEGER, and the underlying primitive type in the second row is STRING (the data type of a literal is always clear from its format)."
msgstr ""

msgid "An item's primitive type is far more important than its defined type. Incidentally Tarantool might find the primitive type by looking at the way MsgPack stores it, but that is an implementation detail."
msgstr ""

msgid "A SCALAR definition may not include a maximum length, as there is no suggested restriction."
msgstr ""

msgid "A SCALAR definition may include a :ref:`COLLATE clause <sql_collate_clause>`, which affects any items whose primitive data type is STRING. The default collation is \"binary\"."
msgstr ""

msgid "Some assignments are illegal when data types differ, but legal when the target is a SCALAR item. For example ``UPDATE ... SET column1 = 'a'`` is illegal if ``column1`` is defined as INTEGER, but is legal if ``column1`` is defined as SCALAR -- values which happen to be INTEGER will be changed so their data type is STRING."
msgstr ""

msgid "There is no literal syntax which implies data type SCALAR."
msgstr ""

msgid "TYPEOF(x) is never SCALAR, it is always the underlying data type. This is true even if ``x`` is NULL (in that case the data type is BOOLEAN). In fact there is no function that is guaranteed to return the defined data type. For example, ``TYPEOF(CAST(1 AS SCALAR));`` returns INTEGER, not SCALAR."
msgstr ""

msgid "For any operation that requires implicit casting from an item defined as SCALAR, the syntax is legal but the operation may fail at runtime. At runtime, Tarantool detects the underlying primitive data type and applies the rules for that. For example, if a definition is:"
msgstr ""

msgid "CREATE TABLE t (s1 SCALAR PRIMARY KEY, s2 INTEGER);"
msgstr ""

msgid "and within any row ``s1 = 'a'``, that is, its underlying primitive type is STRING to indicate character strings, then ``UPDATE t SET s2 = s1;`` is illegal. Tarantool usually does not know that in advance."
msgstr ""

msgid "For any dyadic operation that requires implicit casting for comparison, the syntax is legal and the operation will not fail at runtime. Take this situation: comparison with a primitive type VARBINARY and a primitive type STRING."
msgstr ""

msgid "CREATE TABLE t (s1 SCALAR PRIMARY KEY);\n"
"INSERT INTO t VALUES (X'41');\n"
"SELECT * FROM t WHERE s1 > 'a';"
msgstr ""

msgid "The comparison is valid, because Tarantool knows the ordering of X'41' and 'a' in Tarantool/NoSQL 'scalar'. This would be true even if ``s1`` was not defined as SCALAR."
msgstr ""

msgid "The result data type of :ref:`min/max <sql_aggregate>` operation on a column defined as SCALAR is the data type of the minimum/maximum operand, unless the result value is NULL. For example:"
msgstr ""

msgid "CREATE TABLE t (s1 INTEGER, s2 SCALAR PRIMARY KEY);\n"
"INSERT INTO t VALUES (1, X'44'), (2, 11), (3, 1E4), (4, 'a');\n"
"SELECT min(s2), hex(max(s2)) FROM t;"
msgstr ""

msgid "The result is: ``- - [11, '44',]``"
msgstr ""

msgid "That is only possible with Tarantool/NoSQL scalar rules, but ``SELECT SUM(s2)`` would not be legal because addition would in this case require implicit casting from VARBINARY to integer, which is not sensible."
msgstr ""

msgid "The result data type of a primitive combination is never SCALAR because we in effect use TYPEOF(item) not the defined data type. (Here we use the word \"combination\" in the way that the standard document uses it for section \"Result of data type combinations\".) Therefore for ``max(1E308, 'a', 0, X'00')`` the result is X'00'."
msgstr ""

msgid "Column definition -- relation to NoSQL"
msgstr ""

msgid "All the SQL data types correspond to :ref:`Tarantool/NoSQL types with the same name <box_space-index_field_types>`. For example an SQL STRING is stored in a NoSQL space as type = 'string'."
msgstr ""

msgid "Therefore specifying an SQL data type X determines that the storage will be in a space with a format column saying that the NoSQL type is 'x'."
msgstr ""

msgid "The rules for that NoSQL type are applicable to the SQL data type."
msgstr ""

msgid "If two items have SQL data types that have the same underlying type, then they are compatible for all assignment or comparison purposes."
msgstr ""

msgid "If two items have SQL data types that have different underlying types, then the rules for explicit casts, or implicit (assignment) casts, or implicit (comparison) casts, apply."
msgstr ""

msgid "There is one floating-point value which is not handled by SQL: -nan is seen as NULL."
msgstr ""

msgid "There are also some Tarantool/NoSQL data types which have no corresponding SQL data types. For example, ``SELECT \"flags\" FROM \"_space\";`` will return a column whose data type is 'map'. Such columns can only be manipulated in SQL by :ref:`invoking Lua functions <sql_calling_lua>`."
msgstr ""

msgid "Column definition -- column-constraint or default clause"
msgstr ""

msgid "The column-constraint or default clause may be as follows:"
msgstr ""

msgid "Type"
msgstr ""

msgid "Comment"
msgstr ""

msgid "NOT NULL"
msgstr ""

msgid "means \"it is illegal to assign a NULL to this column\""
msgstr ""

msgid "PRIMARY KEY"
msgstr ""

msgid "explained in the later section :ref:`\"Table Constraint Definition\" <sql_table_constraint_def>`"
msgstr ""

msgid "UNIQUE"
msgstr ""

msgid "explained in the later section \"Table Constraint Definition\""
msgstr ""

msgid "CHECK (expression)"
msgstr ""

msgid "DEFAULT expression"
msgstr ""

msgid "means \"if INSERT does not assign to this column then assign expression result to this column\" -- if there is no DEFAULT clause then DEFAULT NULL is assumed."
msgstr ""

msgid "If column-constraint is PRIMARY KEY, this is a shorthand for a separate :ref:`table-constraint definition <sql_table_constraint_def>`: \"PRIMARY KEY (column-name)\"."
msgstr ""

msgid "If column-constraint is UNIQUE, this is a shorthand for a separate :ref:`table-constraint definition <sql_table_constraint_def>`: \"UNIQUE (column-name)\"."
msgstr ""

msgid "If column-constraint is CHECK, this is a shorthand for a separate :ref:`table-constraint definition <sql_table_constraint_def>`: \"CHECK (expression)\"."
msgstr ""

msgid "Columns defined with PRIMARY KEY are automatically NOT NULL."
msgstr ""

msgid "To enforce some restrictions that Tarantool does not enforce automatically, add CHECK clauses, like these:"
msgstr ""

msgid "CREATE TABLE t (\"smallint\" INTEGER PRIMARY KEY, CHECK (\"smallint\" <= 32767 AND \"smallint\" >= -32768));\n"
"CREATE TABLE t (\"shorttext\" STRING PRIMARY KEY, CHECK (length(\"shorttext\") <= 10));"
msgstr ""

msgid "but this may cause inserts or updates to be slow."
msgstr ""

msgid "Column definition -- examples"
msgstr ""

msgid "These are shown within :ref:`CREATE TABLE <sql_create_table>` statements. Data types may also appear in :ref:`CAST <sql_function_cast>` functions."
msgstr ""

msgid "-- the simple form with column-name and data-type\n"
"CREATE TABLE t (column1 INTEGER ...);\n"
"-- with column-name and data-type and column-constraint\n"
"CREATE TABLE t (column1 STRING PRIMARY KEY ...);\n"
"-- with column-name and data-type and collate-clause and two column-constraints\n"
"CREATE TABLE t (column1 SCALAR COLLATE \"unicode\" ...);"
msgstr ""

msgid "-- with all possible data types and aliases\n"
"CREATE TABLE t\n"
"(column1 BOOLEAN, column2 BOOL,\n"
" column3 INT PRIMARY KEY, column4 INTEGER,\n"
" column5 DOUBLE,\n"
" column6 NUMBER,\n"
" column7 STRING, column8 STRING COLLATE \"unicode\",\n"
" column9 TEXT, columna TEXT COLLATE \"unicode_sv_s1\",\n"
" columnb VARCHAR(0), columnc VARCHAR(100000) COLLATE \"binary\",\n"
" columnd VARBINARY,\n"
" columne SCALAR, columnf SCALAR COLLATE \"unicode_uk_s2\");"
msgstr ""

msgid "-- with all possible column constraints and a default clause\n"
"CREATE TABLE t\n"
"(column1 INTEGER PRIMARY KEY,\n"
" column2 INTEGER UNIQUE,\n"
" column3 INTEGER CHECK (column3 > column2),\n"
" column4 INTEGER REFERENCES t,\n"
" column6 INTEGER DEFAULT NULL);"
msgstr ""

msgid "Table Constraint Definition"
msgstr ""

msgid ":samp:`CONSTRAINT {constraint-name}] primary-key-constraint | unique-constraint | check-constraint | foreign-key-constraint`"
msgstr ""

msgid "Define a constraint, which is a table-element used in a CREATE TABLE statement."
msgstr ""

msgid "The constraint-name must be an identifier which is valid according to the rules for identifiers. The constraint-name must be unique within the table."
msgstr ""

msgid "PRIMARY KEY constraints look like this: |br| :samp:`PRIMARY KEY ({column-name} [, {column-name}...])`"
msgstr ""

msgid "There is a shorthand: specifying PRIMARY KEY in a :ref:`column definition <sql_column_def_constraint>`."
msgstr ""

msgid "Every table must have one and only one primary key. |br| Primary-key columns are automatically NOT NULL. |br| Primary-key columns are automatically indexed. |br| Primary-key columns are unique, that is, it is illegal to have two rows which have the same values for the columns specified in the constraint."
msgstr ""

msgid "-- this is a table with a one-column primary-key constraint\n"
"CREATE TABLE t1 (s1 INTEGER, PRIMARY KEY (s1));\n"
"-- this is the column-definition shorthand for the same thing:\n"
"CREATE TABLE t1 (s1 INTEGER PRIMARY KEY);\n"
"-- this is a table with a two-column primary-key constraint\n"
"CREATE TABLE t2 (s1 INTEGER, s2 INTEGER, PRIMARY KEY (s1, s2));\n"
"-- this is an example of an attempted primary-key violation\n"
"-- (the third INSERT will fail because 55, 'a' is a duplicate)\n"
"CREATE TABLE t3 (s1 INTEGER, s2 STRING, PRIMARY KEY (s1, s2));\n"
"INSERT INTO t3 VALUES (55, 'a');\n"
"INSERT INTO t3 VALUES (55, 'b');\n"
"INSERT INTO t3 VALUES (55, 'a');"
msgstr ""

msgid "PRIMARY KEY plus AUTOINCREMENT modifier may be specified in one of two ways: |br| - In a column definition after the words PRIMARY KEY, as in ``CREATE TABLE t (c INTEGER PRIMARY KEY AUTOINCREMENT);`` |br| - In a PRIMARY KEY (column-list) after a column name, as in ``CREATE TABLE t (c INTEGER, PRIMARY KEY (c AUTOINCREMENT));`` |br| When AUTOINCREMENT is specified, the column must be a primary-key column and it must be INTEGER or UNSIGNED. |br| Only one column in the table may be autoincrement. However, it is legal to say ``PRIMARY KEY (a, b, c AUTOINCREMENT)`` -- in that case, there are three columns in the primary key but only the first column (``a``) is AUTOINCREMENT."
msgstr ""

msgid "As the name suggests, values in an autoincrement column are automatically incremented. That is: if a user inserts NULL in the column, then the stored value will be the smallest non-negative integer that has not already been used. This occurs because autoincrement columns are associated with :ref:`sequences <box_schema-sequence_create_index>`."
msgstr ""

msgid "UNIQUE constraints look like this: |br| :samp:`UNIQUE ({column-name} [, {column-name}...])`"
msgstr ""

msgid "There is a shorthand: specifying UNIQUE in a :ref:`column definition <sql_column_def_constraint>`."
msgstr ""

msgid "Unique constraints are similar to primary-key constraints, except that: a table may have any number of unique keys, and unique keys are not automatically NOT NULL. |br| Unique columns are automatically indexed. |br| Unique columns are unique, that is, it is illegal to have two rows with the same values in the unique-key columns."
msgstr ""

msgid "-- this is a table with a one-column primary-key constraint\n"
"-- and a one-column unique constraint\n"
"CREATE TABLE t1 (s1 INTEGER, s2 INTEGER, PRIMARY KEY (s1), UNIQUE (s2));\n"
"-- this is the column-definition shorthand for the same thing:\n"
"CREATE TABLE t1 (s1 INTEGER PRIMARY KEY, s2 INTEGER UNIQUE);\n"
"-- this is a table with a two-column unique constraint\n"
"CREATE TABLE t2 (s1 INTEGER PRIMARY KEY, s2 INTEGER, UNIQUE (s2, s1));\n"
"-- this is an example of an attempted unique-key violation\n"
"-- (the third INSERT will not fail because NULL is not a duplicate)\n"
"-- (the fourth INSERT will fail because 'a' is a duplicate)\n"
"CREATE TABLE t3 (s1 INTEGER PRIMARY KEY, s2 STRING, UNIQUE (s2));\n"
"INSERT INTO t3 VALUES (1, 'a');\n"
"INSERT INTO t3 VALUES (2, NULL);\n"
"INSERT INTO t3 VALUES (3, NULL);\n"
"INSERT INTO t3 VALUES (4, 'a');"
msgstr ""

msgid "CHECK constraints look like this: |br| :samp:`CHECK ({expression})`"
msgstr ""

msgid "There is a shorthand: specifying CHECK in a :ref:`column definition <sql_column_def_constraint>`."
msgstr ""

msgid "The expression may be anything that returns a BOOLEAN result = TRUE or FALSE or UNKNOWN. |br| The expression may not contain a :ref:`subquery <sql_subquery>`. |br| If the expression contains a column name, the column must exist in the table. |br| If a CHECK constraint is specified, the table must not contain rows where the expression is FALSE. (The table may contain rows where the expression is either TRUE or UNKNOWN.) |br| Constraint checking may be stopped with :ref:`ALTER TABLE ... DISABLE CHECK CONSTRAINT <sql_alter_table>` and restarted with ALTER TABLE ... ENABLE CHECK CONSTRAINT."
msgstr ""

msgid "-- this is a table with a one-column primary-key constraint\n"
"-- and a check constraint\n"
"CREATE TABLE t1 (s1 INTEGER PRIMARY KEY, s2 INTEGER, CHECK (s2 <> s1));\n"
"-- this is an attempt to violate the constraint, it will fail\n"
"INSERT INTO t1 VALUES (1, 1);\n"
"-- this is okay because comparison with NULL will not return FALSE\n"
"INSERT INTO t1 VALUES (1, NULL);\n"
"-- a constraint that makes it difficult to insert lower case\n"
"CHECK (s1 = UPPER(s1))"
msgstr ""

msgid "Limitations: (`Issue#3503 <https://github.com/tarantool/tarantool/issues/3503>`_): |br| * ``CREATE TABLE t99 (s1 INTEGER, UNIQUE(s1, s1),PRIMARY KEY(s1));`` causes no error message, although (s1, s1) is probably a user error."
msgstr ""

msgid "Table Constraint Definition for foreign keys"
msgstr ""

msgid "FOREIGN KEY constraints look like this: |br| :samp:`FOREIGN KEY ({referencing-column-name} [, {referencing-column-name}...]) REFERENCES {referenced-table-name} [({referenced-column-name} [, {referenced-column-name}...]]) [MATCH FULL] [update-or-delete-rules]`"
msgstr ""

msgid "There is a shorthand: specifying REFERENCES in a :ref:`column definition <sql_column_def_constraint>`."
msgstr ""

msgid "The referencing column names must be defined in the table that is being created. The referenced table name must refer to a table that already exists, or to the table that is being created. The referenced column names must be defined in the referenced table, and have similar data types. There must be a PRIMARY KEY or UNIQUE constraint or UNIQUE index on the referenced column names."
msgstr ""

msgid "The words MATCH FULL are optional and have no effect."
msgstr ""

msgid "If a foreign-key constraint exists, then the values in the referencing columns must equal values in the referenced columns of the referenced table, or at least one of the referencing columns must contain NULL."
msgstr ""

msgid "-- A foreign key referencing a primary key in the same table\n"
"CREATE TABLE t1 (s1 INTEGER PRIMARY KEY, s2 INTEGER, FOREIGN KEY (s2) REFERENCES t1 (s1));\n"
"-- The same thing with column shorthand\n"
"CREATE TABLE t1 (s1 INTEGER PRIMARY KEY, s2 INTEGER REFERENCES t1(s1));\n"
"-- An attempt to violate the constraint -- this will fail\n"
"INSERT INTO t1 VALUES (1, 2);\n"
"-- A NULL in the referencing column -- this will succeed\n"
"INSERT INTO t1 VALUES (1, NULL);\n"
"-- A reference to a primary key that now exists -- this will succeed\n"
"INSERT INTO t1 VALUES (2, 1);"
msgstr ""

msgid "The optional update-or-delete rules look like this: |br| ``ON {UPDATE|DELETE} { CASCADE | SET DEFAULT | SET NULL | RESTRICT | NO ACTION}`` |br| and the idea is: if something changes the referenced key, then one of three possible \"referential actions\" takes place: |br| ``CASCADE``: the change that is applied for the referenced key is applied for the referencing key. |br| ``SET DEFAULT``: the referencing key is set to its default value. |br| ``SET NULL``: the referencing key is set to NULL. |br| ``RESTRICT``: the UPDATE or DELETE fails if a referencing key exists; checked immediately. |br| ``NO ACTION``: the UPDATE or DELETE fails if a referencing key exists; checked at statement end. |br| The default is ``NO ACTION``."
msgstr ""

msgid "For example:"
msgstr ""

msgid "CREATE TABLE f1 (ordinal INTEGER PRIMARY KEY,\n"
"             referenced_planet STRING UNIQUE NOT NULL);\n"
"CREATE TABLE f2 (\n"
"    ordinal INTEGER PRIMARY KEY,\n"
"    referring_planet STRING DEFAULT 'Earth',\n"
"    FOREIGN KEY (referring_planet) REFERENCES f1 (referenced_planet)\n"
"        ON UPDATE SET DEFAULT\n"
"        ON DELETE CASCADE);\n"
"INSERT INTO f1 VALUES (1, 'Mercury'), (2,' Venus'), (3, 'Earth');\n"
"INSERT INTO f2 VALUES (1, 'Mercury'), (2, 'Mercury');\n"
"UPDATE f1 SET referenced_planet = 'Mars'\n"
"    WHERE referenced_planet = 'Mercury';\n"
"SELECT * FROM f2;\n"
"DELETE FROM f1 WHERE referenced_planet = 'Earth';\n"
"SELECT * FROM f2;\n"
"... In this example, the UPDATE statement changes the referenced key,\n"
"    and the clause is ON UPDATE SET DEFAULT, therefore both of the\n"
"    rows in f2 have referring_planet set to their default value,\n"
"    which is 'Earth'. The DELETE statement deletes the row that\n"
"    has 'Earth', and the clause is ON DELETE CASCADE,\n"
"    therefore both of the rows in f2 are deleted."
msgstr ""

msgid "Limitations: |br| * Foreign keys can have a MATCH clause (`Issue#3455 <https://github.com/tarantool/tarantool/issues/3455>`_)."
msgstr ""

msgid "DROP TABLE"
msgstr ""

msgid ":samp:`DROP TABLE [IF EXISTS] {table-name};`"
msgstr ""

msgid "Drop a table."
msgstr ""

msgid "The *table-name* must identify a table that was created earlier with the :ref:`CREATE TABLE statement <sql_create_table>`."
msgstr ""

msgid "If there is a view that references the table, the drop will fail. Please drop the referencing view with :ref:`DROP VIEW <sql_drop_view>` first."
msgstr ""

msgid "If there is a foreign key that references the table, the drop will fail. Please drop the referencing constraint with :ref:`ALTER TABLE ... DROP <sql_alter_table_drop_constraint>` first."
msgstr ""

msgid "Tarantool returns an error if the table does not exist."
msgstr ""

msgid "The table and all its data are dropped."
msgstr ""

msgid "All indexes for the table are dropped."
msgstr ""

msgid "All triggers for the table are dropped."
msgstr ""

msgid "-- the simple case:\n"
"DROP TABLE t31;\n"
"-- with an IF EXISTS clause:\n"
"DROP TABLE IF EXISTS t31;"
msgstr ""

msgid "See also: :ref:`DROP VIEW <sql_drop_view>`."
msgstr ""

msgid "CREATE VIEW"
msgstr ""

msgid ":samp:`CREATE VIEW [IF NOT EXISTS] {view-name} [(column-list)] AS subquery;`"
msgstr ""

msgid "Create a new viewed table, usually called a \"view\"."
msgstr ""

msgid "The *view-name* must be valid according to the rules for identifiers."
msgstr ""

msgid "The optional *column-list* must be a comma-separated list of names of columns in the view."
msgstr ""

msgid "The syntax of the subquery must be the same as the syntax of a :ref:`SELECT statement <sql_select>`, or of a VALUES clause."
msgstr ""

msgid "There must not already be a base table or view with the same name as *view-name*."
msgstr ""

msgid "If *column-list* is specified, the number of columns in *column-list* must be the same as the number of columns in the *select-list* of the subquery."
msgstr ""

msgid "Tarantool will throw an error if a rule is violated."
msgstr ""

msgid "Tarantool will create a new persistent object with *column-names* equal to the names in the *column-list* or the names in the subquery's *select-list*."
msgstr ""

msgid "-- the simple case:\n"
"CREATE VIEW v AS SELECT column1, column2 FROM t;\n"
"-- with a column-list:\n"
"CREATE VIEW v (a,b) AS SELECT column1, column2 FROM t;"
msgstr ""

msgid "It is not possible to insert or update or delete from a view, although sometimes a possible substitution is to :ref:`create an INSTEAD OF trigger <sql_create_trigger>`."
msgstr ""

msgid "DROP VIEW"
msgstr ""

msgid ":samp:`DROP VIEW [IF EXISTS] {view-name};`"
msgstr ""

msgid "Drop a view."
msgstr ""

msgid "The *view-name* must identify a view that was created earlier with the :ref:`CREATE VIEW statement <sql_create_view>`."
msgstr ""

msgid "Rules: none"
msgstr ""

msgid "Tarantool returns an error if the view does not exist."
msgstr ""

msgid "The view is dropped."
msgstr ""

msgid "All triggers for the view are dropped."
msgstr ""

msgid "-- the simple case:\n"
"DROP VIEW v31;\n"
"-- with an IF EXISTS clause:\n"
"DROP VIEW IF EXISTS v31;"
msgstr ""

msgid "See also: :ref:`DROP TABLE <sql_drop_table>`."
msgstr ""

msgid "CREATE INDEX"
msgstr ""

msgid ":samp:`CREATE [UNIQUE] INDEX [IF NOT EXISTS] {index-name} ON {table-name} (column-list);`"
msgstr ""

msgid "Create an index."
msgstr ""

msgid "The *index-name* must be valid according to the rules for identifiers."
msgstr ""

msgid "The *table-name* must refer to an existing table."
msgstr ""

msgid "The *column-list* must be a comma-separated list of names of columns in the table."
msgstr ""

msgid "There must not already be, for the same table, an index with the same name as *index-name*. But there may already be, for a different table, an index with the same name as *index-name*."
msgstr ""

msgid "The maximum number of indexes per table is 128."
msgstr ""

msgid "If the new index is UNIQUE, Tarantool will throw an error if any row exists with columns that have duplicate values."
msgstr ""

msgid "Tarantool will create a new index."
msgstr ""

msgid "Automatic indexes:"
msgstr ""

msgid "Indexes may be created automatically for columns mentioned in the PRIMARY KEY or UNIQUE clauses of a CREATE TABLE statement. If an index was created automatically, then the *index-name* has four parts:"
msgstr ""

msgid "``pk`` if this is for a PRIMARY KEY clause, ``unique`` if this is for a UNIQUE clause;"
msgstr ""

msgid "``_unnamed_``;"
msgstr ""

msgid "the name of the table;"
msgstr ""

msgid "``_`` and an ordinal number; the first index is 1, the second index is 2, and so on."
msgstr ""

msgid "For example, after ``CREATE TABLE t (s1 INTEGER PRIMARY KEY, s2 INTEGER, UNIQUE (s2));`` there are two indexes named ``pk_unnamed_T_1`` and ``unique_unnamed_T_2``. You can confirm this by saying ``SELECT * FROM \"_index\";`` which will list all indexes on all tables. There is no need to say ``CREATE INDEX`` for columns that already have automatic indexes."
msgstr ""

msgid "-- the simple case\n"
"CREATE INDEX idx_column1_t_1 ON t (column1);\n"
"-- with IF NOT EXISTS clause\n"
"CREATE INDEX IF NOT EXISTS idx_column1_t_1 ON t (column1);\n"
"-- with UNIQUE specifier and more than one column\n"
"CREATE UNIQUE INDEX idx_unnamed_t_1 ON t (column1, column2);"
msgstr ""

msgid "Dropping an automatic index created for a unique constraint will drop the unique constraint as well."
msgstr ""

msgid "DROP INDEX"
msgstr ""

msgid ":samp:`DROP INDEX [IF EXISTS] index-name ON {table-name};`"
msgstr ""

msgid "The *index-name* must be the name of an existing index, which was created with :ref:`CREATE INDEX <sql_create_index>`. Or, the *index-name* must be the name of an index that was created automatically due to a PRIMARY KEY or UNIQUE clause in the :ref:`CREATE TABLE <sql_create_table>` statement. To see what a table's indexes are, use :ref:`PRAGMA index_list(table-name); <sql_pragma>`."
msgstr ""

msgid "Tarantool throws an error if the index does not exist, or is an automatically created index."
msgstr ""

msgid "Tarantool will drop the index."
msgstr ""

msgid "Example:"
msgstr ""

msgid "-- the simplest form:\n"
"DROP INDEX idx_unnamed_t_1 ON t;"
msgstr ""

msgid "INSERT"
msgstr ""

msgid ":samp:`INSERT INTO {table-name} [(column-list)] VALUES (expression-list) [, (expression-list)];`"
msgstr ""

msgid ":samp:`INSERT INTO {table-name} [(column-list)]  select-statement;`"
msgstr ""

msgid ":samp:`INSERT INTO {table-name} DEFAULT VALUES;`"
msgstr ""

msgid "Insert one or more new rows into a table."
msgstr ""

msgid "The *table-name* must be a name of a table defined earlier with :ref:`CREATE TABLE <sql_create_table>`."
msgstr ""

msgid "The optional *column-list* must be a comma-separated list of names of columns in the table."
msgstr ""

msgid "The *expression-list* must be a comma-separated list of expressions; each expression may contain literals and operators and subqueries and function invocations."
msgstr ""

msgid "The values in the *expression-list* are evaluated from left to right."
msgstr ""

msgid "The order of the values in the *expression-list* must correspond to the order of the columns in the table, or (if a *column-list* is specified) to the order of the columns in the *column-list*."
msgstr ""

msgid "The data type of the value should correspond to the :ref:`data type of the column <sql_column_def_data_type>`, that is, the data type that was specified with CREATE TABLE."
msgstr ""

msgid "If a *column-list* is not specified, then the number of expressions must be the same as the number of columns in the table."
msgstr ""

msgid "If a *column-list* is specified, then some columns may be omitted; omitted columns will get default values."
msgstr ""

msgid "The parenthesized *expression-list* may be repeated -- ``(expression-list),(expression-list),...`` -- for multiple rows."
msgstr ""

msgid "Tarantool evaluates each expression in *expression-list*, and returns an error if any of the rules is violated."
msgstr ""

msgid "Tarantool creates zero or more new rows containing values based on the values in the VALUES list or based on the results of the *select-expression* or based on the default values."
msgstr ""

msgid "Tarantool executes constraint checks and trigger actions and the actual insertion."
msgstr ""

msgid "Tarantool inserts values into the table."
msgstr ""

msgid "-- the simplest form:\n"
"INSERT INTO table1 VALUES (1, 'A');\n"
"-- with a column list:\n"
"INSERT INTO table1 (column1, column2) VALUES (2, 'B');\n"
"-- with an arithmetic operator in the first expression:\n"
"INSERT INTO table1 VALUES (2 + 1, 'C');\n"
"-- put two rows in the table:\n"
"INSERT INTO table1 VALUES (4, 'D'), (5, 'E');"
msgstr ""

msgid "See also: :ref:`REPLACE statement <sql_replace>`."
msgstr ""

msgid "UPDATE"
msgstr ""

msgid ":samp:`UPDATE {table-name} SET column-name = expression [, column-name = expression ...] [WHERE search-condition];`"
msgstr ""

msgid "Update zero or more existing rows in a table."
msgstr ""

msgid "The *table-name* must be a name of a table defined earlier with :ref:`CREATE TABLE <sql_create_table>` or :ref:`CREATE VIEW <sql_create_view>`."
msgstr ""

msgid "The *column-name* must be an updatable column in the table."
msgstr ""

msgid "The *expression* may contain literals and operators and subqueries and function invocations and column names."
msgstr ""

msgid "The values in the SET clause are evaluated from left to right."
msgstr ""

msgid "If a *search-condition* is not specified, then all rows in the table will be updated; otherwise only those rows which match the *search-condition* will be updated."
msgstr ""

msgid "Tarantool evaluates each expression in the SET clause, and returns an error if any of the rules is violated. For each row that is found by the WHERE clause, a temporary new row is formed based on the original contents and the modifications caused by the SET clause."
msgstr ""

msgid "Tarantool executes constraint checks and trigger actions and the actual update."
msgstr ""

msgid "-- the simplest form:\n"
"UPDATE t SET column1 = 1;\n"
"-- with more than one assignment in the SET clause:\n"
"UPDATE t SET column1 = 1, column2 = 2;\n"
"-- with a WHERE clause:\n"
"UPDATE t SET column1 = 5 WHERE column2 = 6;"
msgstr ""

msgid "Special cases:"
msgstr ""

msgid "It is legal to say SET (list of columns) = (list of values). For example:"
msgstr ""

msgid "UPDATE t SET (column1, column2, column3) = (1, 2, 3);"
msgstr ""

msgid "It is not legal to assign to a column more than once. For example:"
msgstr ""

msgid "INSERT INTO t (column1) VALUES (0);\n"
"UPDATE t SET column1 = column1 + 1, column1 = column1 + 1;"
msgstr ""

msgid "The result is an error: \"duplicate column name\"."
msgstr ""

msgid "It is not legal to assign to a primary-key column."
msgstr ""

msgid "DELETE"
msgstr ""

msgid ":samp:`DELETE FROM {table-name} [WHERE search-condition];`"
msgstr ""

msgid "Delete zero or more existing rows in a table."
msgstr ""

msgid "The *search-condition* may contain literals and operators and subqueries and function invocations and column names."
msgstr ""

msgid "If a search-condition is not specified, then all rows in the table will be deleted; otherwise only those rows which match the *search-condition* will be deleted."
msgstr ""

msgid "Tarantool evaluates each expression in the *search-condition*, and returns an error if any of the rules is violated."
msgstr ""

msgid "Tarantool finds the set of rows that are to be deleted."
msgstr ""

msgid "Tarantool executes constraint checks and trigger actions and the actual deletion."
msgstr ""

msgid "Tarantool deletes the set of matching rows from the table."
msgstr ""

msgid "-- the simplest form:\n"
"DELETE FROM t;\n"
"-- with a WHERE clause:\n"
"DELETE FROM t WHERE column2 = 6;"
msgstr ""

msgid "REPLACE"
msgstr ""

msgid ":samp:`REPLACE INTO {table-name} [(column-list)] VALUES (expression-list) [, (expression-list)];`"
msgstr ""

msgid ":samp:`REPLACE INTO {table-name} [(column-list)] select-statement;`"
msgstr ""

msgid ":samp:`REPLACE INTO {table-name} DEFAULT VALUES;`"
msgstr ""

msgid "Insert one or more new rows into a table, or update existing rows."
msgstr ""

msgid "If a row already exists (as determined by the primary key or any unique key), then the action is delete + insert, and the rules are the same as for a :ref:`DELETE statement <sql_delete>` followed by an :ref:`INSERT statement <sql_insert>`. Otherwise the action is insert, and the rules are the same as for the INSERT statement."
msgstr ""

msgid "-- the simplest form:\n"
"REPLACE INTO table1 VALUES (1, 'A');\n"
"-- with a column list:\n"
"REPLACE INTO table1 (column1, column2) VALUES (2, 'B');\n"
"-- with an arithmetic operator in the first expression:\n"
"REPLACE INTO table1 VALUES (2 + 1, 'C');\n"
"-- put two rows in the table:\n"
"REPLACE INTO table1 VALUES (4, 'D'), (5, 'E');"
msgstr ""

msgid "See also: :ref:`INSERT Statement <sql_insert>`, :ref:`UPDATE Statement <sql_update>`."
msgstr ""

msgid "CREATE TRIGGER"
msgstr ""

msgid ":samp:`CREATE TRIGGER [IF NOT EXISTS] {trigger-name}` |br| :samp:`BEFORE|AFTER|INSTEAD OF` |br| :samp:`INSERT|UPDATE|DELETE ON {table-name}` |br| :samp:`FOR EACH ROW` |br| :samp:`[WHEN (search-condition)]` |br| :samp:`BEGIN` |br| :samp:`update-statement | insert-statement | delete-statement | select-statement;` |br| :samp:`[update-statement | insert-statement | delete-statement | select-statement; ...]` |br| :samp:`END;`"
msgstr ""

msgid "The *trigger-name* must be valid according to the rules for identifiers."
msgstr ""

msgid "If the trigger action time is BEFORE or AFTER, then the *table-name* must refer to an existing base table."
msgstr ""

msgid "If the trigger action time is INSTEAD OF, then the *table-name* must refer to an existing view."
msgstr ""

msgid "There must not already be a trigger with the same name as *trigger-name*."
msgstr ""

msgid "Triggers on different tables or views share the same namespace."
msgstr ""

msgid "The statements between BEGIN and END should not refer to the *table-name* mentioned in the ON clause."
msgstr ""

msgid "The statements between BEGIN and END should not contain an :ref:`INDEXED BY <sql_indexed_by>` clause."
msgstr ""

msgid "SQL triggers are not activated by Tarantool/NoSQL requests. This will change in a future version."
msgstr ""

msgid "On a :ref:`replica <Replication>`, effects of trigger execution are applied, and the SQL triggers themselves are not activated upon replication events."
msgstr ""

msgid "NoSQL triggers are activated both on replica and master, thus if you have a :ref:`NoSQL trigger <triggers>` on a replica, it is activated when applying effects of an SQL trigger."
msgstr ""

msgid "Tarantool will create a new trigger."
msgstr ""

msgid "-- the simple case:\n"
"CREATE TRIGGER stores_before_insert BEFORE INSERT ON stores FOR EACH ROW\n"
"  BEGIN DELETE FROM warehouses; END;\n"
"-- with IF NOT EXISTS clause:\n"
"CREATE TRIGGER IF NOT EXISTS stores_before_insert BEFORE INSERT ON stores FOR EACH ROW\n"
"  BEGIN DELETE FROM warehouses; END;\n"
"-- with FOR EACH ROW and WHEN clauses:\n"
"CREATE TRIGGER stores_before_insert BEFORE INSERT ON stores FOR EACH ROW WHEN a=5\n"
"  BEGIN DELETE FROM warehouses; END;\n"
"-- with multiple statements between BEGIN and END:\n"
"CREATE TRIGGER stores_before_insert BEFORE INSERT ON stores FOR EACH ROW\n"
"  BEGIN DELETE FROM warehouses; INSERT INTO inventories VALUES (1); END;"
msgstr ""

msgid "Trigger extra clauses"
msgstr ""

msgid ":samp:`UPDATE OF column-list`"
msgstr ""

msgid "After BEFORE|AFTER UPDATE it is optional to add ``OF column-list``. If any of the columns in *column-list* is affected at the time the row is processed, then the trigger will be activated for that row. For example:"
msgstr ""

msgid "CREATE TRIGGER table1_before_update\n"
" BEFORE UPDATE  OF column1, column2 ON table1\n"
" FOR EACH ROW\n"
" BEGIN UPDATE table2 SET column1 = column1 + 1; END;\n"
"UPDATE table1 SET column3 = column3 + 1; -- Trigger will not be activated\n"
"UPDATE table1 SET column2 = column2 + 0; -- Trigger will be activated"
msgstr ""

msgid ":samp:`WHEN`"
msgstr ""

msgid "After *table-name* FOR EACH ROW it is optional to add [``WHEN expression``]. If the expression is true at the time the row is processed, only then will the trigger will be activated for that row. For example:"
msgstr ""

msgid "CREATE TRIGGER table1_before_update BEFORE UPDATE ON table1 FOR EACH ROW\n"
" WHEN (SELECT COUNT(*) FROM table1) > 1\n"
" BEGIN UPDATE table2 SET column1 = column1 + 1; END;"
msgstr ""

msgid "This trigger will not be activated unless there is more than one row in ``table1``."
msgstr ""

msgid ":samp:`OLD and NEW`"
msgstr ""

msgid "The keywords OLD and NEW have special meaning in the context of trigger action:"
msgstr ""

msgid "OLD.column-name refers to the value of *column-name* before the change."
msgstr ""

msgid "NEW.column-name refers to the value of *column-name* after the change."
msgstr ""

msgid "CREATE TABLE table1 (column1 STRING, column2 INTEGER PRIMARY KEY);\n"
"CREATE TABLE table2 (column1 STRING, column2 STRING, column3 INTEGER PRIMARY KEY);\n"
"INSERT INTO table1 VALUES ('old value', 1);\n"
"INSERT INTO table2 VALUES ('', '', 1);\n"
"CREATE TRIGGER table1_before_update BEFORE UPDATE ON table1 FOR EACH ROW\n"
" BEGIN UPDATE table2 SET column1 = old.column1, column2 = new.column1; END;\n"
"UPDATE table1 SET column1 = 'new value';\n"
"SELECT * FROM table2;"
msgstr ""

msgid "At the beginning of the UPDATE for the single row of ``table1``, the value in ``column1`` is 'old value' -- so that is what is seen as ``old.column1``."
msgstr ""

msgid "At the end of the UPDATE for the single row of ``table1``, the value in ``column1`` is 'new value' -- so that is what is seen as ``new.column1``. (OLD and NEW are qualifiers for ``table1``, not ``table2.``)"
msgstr ""

msgid "Therefore, ``SELECT * FROM table2;`` returns ``['old value', 'new value']``."
msgstr ""

msgid "``OLD.column-name`` does not exist for an INSERT trigger."
msgstr ""

msgid "``NEW.column-name`` does not exist for a DELETE trigger."
msgstr ""

msgid "OLD and NEW are read-only; you cannot change their values."
msgstr ""

msgid "Deprecated or illegal statements:"
msgstr ""

msgid "It is legal for the trigger action to include a :ref:`SELECT statement <sql_select>` or a :ref:`REPLACE statement <sql_replace>`, but not recommended."
msgstr ""

msgid "It is illegal for the trigger action to include a qualified column reference other than ``OLD.column-name`` or ``NEW.column-name``. For example, ``CREATE TRIGGER ... BEGIN UPDATE table1 SET table1.column1 = 5; END;`` is illegal."
msgstr ""

msgid "It is illegal for the trigger action to include statements that include a :ref:`WITH clause <sql_with>`, a DEFAULT VALUES clause, or an :ref:`INDEXED BY <sql_indexed_by>` clause."
msgstr ""

msgid "It is usually not a good idea to have a trigger on ``table1`` which causes a change on ``table2``, and at the same time have a trigger on ``table2`` which causes a change on ``table1``. For example:"
msgstr ""

msgid "CREATE TRIGGER table1_before_update\n"
" BEFORE UPDATE ON table1\n"
" FOR EACH ROW\n"
" BEGIN UPDATE table2 SET column1 = column1 + 1; END;\n"
"CREATE TRIGGER table2_before_update\n"
" BEFORE UPDATE ON table2\n"
" FOR EACH ROW\n"
" BEGIN UPDATE table1 SET column1 = column1 + 1; END;"
msgstr ""

msgid "Luckily ``UPDATE table1 ...`` will not cause an infinite loop, because Tarantool recognizes when it has already updated so it will stop. However, not every DBMS acts this way."
msgstr ""

msgid "Trigger activation"
msgstr ""

msgid "These are remarks concerning trigger activation."
msgstr ""

msgid "Standard terminology:"
msgstr ""

msgid "\"trigger action time\" = BEFORE or AFTER or INSTEAD OF"
msgstr ""

msgid "\"trigger event\" = INSERT or DELETE or UPDATE"
msgstr ""

msgid "\"triggered statement\" = BEGIN ... INSERT|DELETE|UPDATE ... END"
msgstr ""

msgid "\"triggered when clause\" = WHEN (search condition)"
msgstr ""

msgid "\"activate\" = execute a triggered statement"
msgstr ""

msgid "some vendors use the word \"fire\" instead of \"activate\""
msgstr ""

msgid "If there is more than one trigger for the same trigger event, Tarantool may execute the triggers in any order."
msgstr ""

msgid "It is possible for a triggered statement to cause activation of another triggered statement. For example, this is legal:"
msgstr ""

msgid "CREATE TRIGGER t1_before_delete BEFORE DELETE ON t1 BEGIN DELETE FROM t2; END;\n"
"CREATE TRIGGER t2_before_delete BEFORE DELETE ON t2 BEGIN DELETE FROM t3; END;"
msgstr ""

msgid "Activation occurs FOR EACH ROW, not FOR EACH STATEMENT. Therefore, if no rows are candidates for insert or update or delete, then no triggers are activated."
msgstr ""

msgid "The BEFORE trigger is activated even if the trigger event fails."
msgstr ""

msgid "If an UPDATE trigger event does not make a change, the trigger is activated anyway. For example, if row 1 ``column1`` contains 'a', and the trigger event is ``UPDATE ... SET column1 = 'a';``, the trigger is activated."
msgstr ""

msgid "The triggered statement may refer to a function: ``RAISE(FAIL, error-message)``. If a triggered statement invokes a ``RAISE(FAIL, error-message)`` function, or if a triggered statement causes an error, then statement execution stops immediately."
msgstr ""

msgid "The triggered statement may refer to column values within the rows being changed. in this case:"
msgstr ""

msgid "The row \"as of before\" the change is called the \"old\" row (which makes sense only for UPDATE and DELETE statements)."
msgstr ""

msgid "The row \"as of after\" the change is called the \"new\" row (which makes sense only for UPDATE and INSERT statements)."
msgstr ""

msgid "This example shows how an INSERT can be done to a view by referring to the \"new\" row:"
msgstr ""

msgid "CREATE TABLE t (s1 INTEGER PRIMARY KEY, s2 INTEGER);\n"
"CREATE VIEW v AS SELECT s1, s2 FROM t;\n"
"CREATE TRIGGER v_instead_of INSTEAD OF INSERT ON v\n"
"  FOR EACH ROW\n"
"  BEGIN INSERT INTO t VALUES (new.s1, new.s2); END;\n"
"INSERT INTO v VALUES (1, 2);"
msgstr ""

msgid "Ordinarily saying ``INSERT INTO view_name ...`` is illegal in Tarantool, so this is a workaround."
msgstr ""

msgid "It is possible to generalize this so that all data-change statements on views will change the base tables, provided that the view contains all the columns of the base table, and provided that the triggers refer to those columns when necessary, as in this example:"
msgstr ""

msgid "CREATE TABLE base_table (primary_key_column INTEGER PRIMARY KEY, value_column INTEGER);\n"
"CREATE VIEW viewed_table AS SELECT primary_key_column, value_column FROM base_table;\n"
"CREATE TRIGGER viewed_table_instead_of_insert INSTEAD OF INSERT ON viewed_table FOR EACH ROW\n"
"  BEGIN\n"
"    INSERT INTO base_table VALUES (new.primary_key_column, new.value_column);\n"
"  END;\n"
"CREATE TRIGGER viewed_table_instead_of_update INSTEAD OF UPDATE ON viewed_table FOR EACH ROW\n"
"  BEGIN\n"
"    UPDATE base_table\n"
"    SET primary_key_column = new.primary_key_column, value_column = new.value_column\n"
"    WHERE primary_key_column = old.primary_key_column;\n"
"  END;\n"
"CREATE TRIGGER viewed_table_instead_of_delete INSTEAD OF DELETE ON viewed_table FOR EACH ROW\n"
"  BEGIN\n"
"    DELETE FROM base_table WHERE primary_key_column = old.primary_key_column;\n"
"  END;"
msgstr ""

msgid "When INSERT or UPDATE or DELETE occurs for table ``X``, Tarantool usually operates in this order (a basic scheme):"
msgstr ""

msgid "For each row\n"
"  Perform constraint checks\n"
"  For each BEFORE trigger that refers to table X\n"
"    Check that the trigger's WHEN condition is true.\n"
"    Execute what is in the trigger's BEGIN|END block.\n"
"  Insert or update or delete the row in table X.\n"
"  Perform more constraint checks\n"
"  For each AFTER trigger that refers to table X\n"
"    Check that the trigger's WHEN condition is true.\n"
"    Execute what is in the trigger's BEGIN|END block."
msgstr ""

msgid "However, Tarantool does not guarantee execution order when there are multiple constraints, or multiple triggers for the same event (including NoSQL :ref:`on_replace triggers <box_space-on_replace>` or SQL :ref:`INSTEAD OF triggers <sql_instead_of_triggers>` that affect a view of table ``X``)."
msgstr ""

msgid "The maximum number of trigger activations per statement is 32."
msgstr ""

msgid "INSTEAD OF triggers"
msgstr ""

msgid "A trigger which is created with the clause |br| :samp:`INSTEAD OF {INSERT|UPDATE|DELETE} ON {view-name}` |br| is an INSTEAD OF trigger. For each affected row, the trigger action is performed \"instead of\" the INSERT or UPDATE or DELETE statement that causes trigger activation."
msgstr ""

msgid "For example, ordinarily it is illegal to INSERT rows in a view, but it is legal to create a trigger which intercepts attempts to INSERT, and puts rows in the underlying base table:"
msgstr ""

msgid "CREATE TABLE t1 (column1 INTEGER PRIMARY KEY, column2 INTEGER);\n"
"CREATE VIEW v1 AS SELECT column1, column2 FROM t1;\n"
"CREATE TRIGGER v1_instead_of INSTEAD OF INSERT ON v1 FOR EACH ROW BEGIN\n"
" INSERT INTO t1 VALUES (NEW.column1, NEW.column2); END;\n"
"INSERT INTO v1 VALUES (1, 1);\n"
"-- ... The result will be: table t1 will contain a new row."
msgstr ""

msgid "INSTEAD OF triggers are only legal for views, while BEFORE or AFTER triggers are only legal for base tables."
msgstr ""

msgid "It is legal to create INSTEAD OF triggers with triggered WHEN clauses."
msgstr ""

msgid "It is legal to create INSTEAD OF triggers with UPDATE OF *column-list* clauses, but they are not standard SQL."
msgstr ""

msgid "CREATE TRIGGER ev1_instead_of_update\n"
"  INSTEAD OF UPDATE OF column2,column1 ON ev1\n"
"  FOR EACH ROW BEGIN\n"
"  INSERT INTO et2 VALUES (NEW.column1, NEW.column2); END;"
msgstr ""

msgid "DROP TRIGGER"
msgstr ""

msgid ":samp:`DROP TRIGGER [IF EXISTS] {trigger-name};`"
msgstr ""

msgid "Drop a trigger."
msgstr ""

msgid "The *trigger-name* must identify a trigger that was created earlier with the :ref:`CREATE TRIGGER <sql_create_trigger>` statement."
msgstr ""

msgid "Tarantool returns an error if the trigger does not exist."
msgstr ""

msgid "The trigger is dropped."
msgstr ""

msgid "-- the simple case:\n"
"DROP TRIGGER table1_before_insert;\n"
"-- with an IF EXISTS clause:\n"
"DROP TRIGGER IF EXISTS table1_before_insert;"
msgstr ""

msgid "TRUNCATE"
msgstr ""

msgid ":samp:`TRUNCATE TABLE {table-name};`"
msgstr ""

msgid "Remove all rows in the table."
msgstr ""

msgid "TRUNCATE is considered to be a schema-change rather than a data-change statement, so it does not work within transactions (it cannot be :ref:`rolled back <sql_rollback>`)."
msgstr ""

msgid "It is illegal to truncate a table which is referenced by a foreign key."
msgstr ""

msgid "It is illegal to truncate a table which is also a system space, such as ``_space``."
msgstr ""

msgid "The table must be a base table rather than a view."
msgstr ""

msgid "All rows in the table are removed. Usually this is faster than :samp:`DELETE FROM {table-name};`."
msgstr ""

msgid "If the table has an autoincrement primary key, its :ref:`sequence <box_schema-sequence_create_index>` is reset to zero."
msgstr ""

msgid "There is no effect for any triggers associated with the table."
msgstr ""

msgid "There is no effect on the counts for the ``ROW_COUNT()`` function."
msgstr ""

msgid "Only one action is written to the :ref:`write-ahead log <internals-wal>` (with :samp:`DELETE FROM {table-name};` there would be one action for each deleted row)."
msgstr ""

msgid "TRUNCATE TABLE t;"
msgstr ""

msgid "SELECT"
msgstr ""

msgid ":samp:`SELECT [ALL|DISTINCT] select-list [from clause] [where clause] [group-by clause] [having clause] [order-by clause];`"
msgstr ""

msgid "Select zero or more rows."
msgstr ""

msgid "The clauses of the SELECT statement are discussed in the following five sections."
msgstr ""

msgid "Select-list"
msgstr ""

msgid ":samp:`select-list-column [, select-list-column ...] select-list-column:`"
msgstr ""

msgid "Define what will be in a result set; this is a clause in a :ref:`SELECT statement <sql_select>`."
msgstr ""

msgid "The *select-list* is a comma-delimited list of expressions, or ``*`` (asterisk). An expression can have an alias provided with an ``[AS [column-name]]`` clause."
msgstr ""

msgid "The ``*`` \"asterisk\" shorthand is valid if and only if the SELECT statement also contains a :ref:`FROM clause <sql_from>` which specifies the table or tables (details about the FROM clause are in the next section). The simple form is ``*`` which means \"all columns\" -- for example, if the select is done for a table which contains three columns ``s1`` ``s2`` ``s3``, then ``SELECT * ...`` is equivalent to ``SELECT s1, s2, s3 ...``. The qualified form is ``table-name.*`` which means \"all columns in the specified table\", which again must be a result of the FROM clause -- for example, if the table is named ``table1``, then ``table1.*`` is equivalent to a list of the columns of ``table1``."
msgstr ""

msgid "The ``[AS [column-name]]`` clause determines the column name. The column name is useful for two reasons:"
msgstr ""

msgid "in a tabular display, the column names are the headings"
msgstr ""

msgid "if the results of the SELECT are used in ``CREATE TABLE new-table-name ... AS SELECT select-list ...``, then the column names in the new table will be the column names in the *select-list*."
msgstr ""

msgid "If ``[AS [column-name]]`` is missing, Tarantool makes a name equal to the expression, for example ``SELECT 5 * 88`` will cause the column name to be ``5 * 88``, but such names may be ambiguous or illegal in other contexts, so it is better to say, for example, ``SELECT 5 * 88 AS column1``."
msgstr ""

msgid "-- the simple form:\n"
"SELECT 5;\n"
"-- with multiple expressions including operators:\n"
"SELECT 1, 2 * 2, 'Three' || 'Four';\n"
"-- with [[AS] column-name] clause:\n"
"SELECT 5 AS column1;\n"
"-- * which must be eventually followed by a FROM clause:\n"
"SELECT * FROM table1;\n"
"-- as a list:\n"
"SELECT 1 AS a, 2 AS b, table1.* FROM table1;"
msgstr ""

msgid "FROM clause"
msgstr ""

msgid ":samp:`FROM table-reference [, table-reference ...]`"
msgstr ""

msgid "Specify the table or tables for the source of a :ref:`SELECT statement <sql_select>`."
msgstr ""

msgid "The *table-reference* must be a name of an existing table, or a subquery, or a joined table."
msgstr ""

msgid "A joined table looks like this:"
msgstr ""

msgid ":samp:`table-reference-or-joined-table join-operator table-reference-or-joined-table [join-specification]`"
msgstr ""

msgid "A *join-operator* must be any of `the standard types <https://en.wikipedia.org/wiki/Join_(SQL)>`_:"
msgstr ""

msgid "[NATURAL] LEFT [OUTER] JOIN,"
msgstr ""

msgid "[NATURAL] INNER JOIN, or"
msgstr ""

msgid "CROSS JOIN"
msgstr ""

msgid "A *join-specification* must be any of:"
msgstr ""

msgid "ON expression, or"
msgstr ""

msgid "USING (column-name [, column-name ...])"
msgstr ""

msgid "Parentheses are allowed, and ``[[AS] correlation-name]`` is allowed."
msgstr ""

msgid "The maximum number of joins in a FROM clause is 64."
msgstr ""

msgid "-- the simplest form:\n"
"SELECT * FROM t;\n"
"-- with two tables, making a Cartesian join:\n"
"SELECT * FROM t1, t2;\n"
"-- with one table joined to itself, requiring correlation names:\n"
"SELECT a.*, b.* FROM t1 AS a, t1 AS b;\n"
"-- with a left outer join:\n"
"SELECT * FROM t1 LEFT JOIN t2;"
msgstr ""

msgid "WHERE clause"
msgstr ""

msgid ":samp:`WHERE condition;`"
msgstr ""

msgid "Specify the condition for filtering rows from a table; this is a clause in a :ref:`SELECT <sql_select>` or :ref:`UPDATE <sql_update>` or :ref:`DELETE <sql_delete>` statement."
msgstr ""

msgid "The condition may contain any expression that returns a BOOLEAN (TRUE or FALSE or UNKNOWN) value."
msgstr ""

msgid "For each row in the table:"
msgstr ""

msgid "if the condition is true, then the row is kept;"
msgstr ""

msgid "if the condition is false or unknown, then the row is ignored."
msgstr ""

msgid "In effect, WHERE condition takes a table with n rows and returns a table with n or fewer rows."
msgstr ""

msgid "-- with a simple condition:\n"
"SELECT 1 FROM t WHERE column1 = 5;\n"
"-- with a condition that contains AND and OR and parentheses:\n"
"SELECT 1 FROM t WHERE column1 = 5 AND (x > 1 OR y < 1);"
msgstr ""

msgid "GROUP BY clause"
msgstr ""

msgid ":samp:`GROUP BY expression [, expression ...]`"
msgstr ""

msgid "Make a grouped table; this is a clause in a :ref:`SELECT statement <sql_select>`."
msgstr ""

msgid "The expressions should be column names in the table, and each column should be specified only once."
msgstr ""

msgid "In effect, the GROUP BY clause takes a table with rows that may have matching values, combines rows that have matching values into single rows, and returns a table which, because it is the result of GROUP BY, is called a grouped table."
msgstr ""

msgid "Thus, if the input is a table:"
msgstr ""

msgid "a    b      c\n"
"-    -      -\n"
"1    'a'   'b\n"
"1    'b'   'b'\n"
"2    'a'   'b'\n"
"3    'a'   'b'\n"
"1    'b'   'b'"
msgstr ""

msgid "then ``GROUP BY a, b`` will produce a grouped table:"
msgstr ""

msgid "a    b      c\n"
"-    -      -\n"
"1    'a'   'b'\n"
"1    'b'   'b'\n"
"2    'a'   'b'\n"
"3    'a'   'b'"
msgstr ""

msgid "The rows where column ``a`` and column ``b`` have the same value have been merged; column ``c`` has been preserved but its value should not be depended on -- if the rows were not all 'b', Tarantool could pick any value."
msgstr ""

msgid "It is useful to envisage a grouped table as having hidden extra columns for the aggregation of the values, for example:"
msgstr ""

msgid "a    b      c    COUNT(a) SUM(a) MIN(c)\n"
"-    -      -    -------- ------ ------\n"
"1    'a'  'b'         2      2    'b'\n"
"1    'b'  'b'         1      1    'b'\n"
"2    'a'  'b'         1      2    'b'\n"
"     'a'  'b'         1      3    'b'"
msgstr ""

msgid "These extra columns are what :ref:`aggregate functions <sql_aggregate>` are for."
msgstr ""

msgid "-- with a single column:\n"
"SELECT 1 FROM t GROUP BY column1;\n"
"-- with two columns:\n"
"SELECT 1 FROM t GROUP BY column1, column2;"
msgstr ""

msgid "``SELECT s1, s2 FROM t GROUP BY s1;`` is legal."
msgstr ""

msgid "``SELECT s1 AS q FROM t GROUP BY q;`` is legal."
msgstr ""

msgid "``SELECT s1 FROM t GROUP by 1;`` is legal."
msgstr ""

msgid "Aggregate functions"
msgstr ""

msgid ":samp:`function-name (one or more expressions)`"
msgstr ""

msgid "Apply a built-in aggregate function to one or more expressions and return a scalar value."
msgstr ""

msgid "Aggregate functions are only legal in certain clauses of a :ref:`SELECT statement <sql_select>` for grouped tables. (A table is a grouped table if a GROUP BY clause is present.) Also, if an aggregate function is used in a select-list and the GROUP BY clause is omitted, then Tarantool assumes ``SELECT ... GROUP BY [all columns];``."
msgstr ""

msgid "NULLs are ignored for all aggregate functions except COUNT(*)."
msgstr ""

msgid "``AVG([DISTINCT] expression)``"
msgstr ""

msgid "Return the average value of expression."
msgstr ""

msgid "Example: :samp:`AVG({column1})`"
msgstr ""

msgid "``COUNT([DISTINCT] expression)``"
msgstr ""

msgid "Return the number of occurrences of expression."
msgstr ""

msgid "Example: :samp:`COUNT({column1})`"
msgstr ""

msgid "``COUNT(*)``"
msgstr ""

msgid "Return the number of occurrences of a row."
msgstr ""

msgid "Example: :samp:`COUNT(*)`"
msgstr ""

msgid "``GROUP_CONCAT(expression-1 [, expression-2])``"
msgstr ""

msgid "Return a list of *expression-1* values, separated by commas if *expression-2* is omitted, or separated by the *expression-2* value if *expression-2* is not omitted."
msgstr ""

msgid "Example: :samp:`GROUP_CONCAT{column1})`"
msgstr ""

msgid "``MAX([DISTINCT] expression)``"
msgstr ""

msgid "Return the maximum value of expression."
msgstr ""

msgid "Example: :samp:`MAX({column1})`"
msgstr ""

msgid "``MIN([DISTINCT] expression)``"
msgstr ""

msgid "Return the minimum value of expression."
msgstr ""

msgid "Example: :samp:`MIN({column1})`"
msgstr ""

msgid "``SUM([DISTINCT] expression)``"
msgstr ""

msgid "Return the sum of values of expression."
msgstr ""

msgid "Example: :samp:`SUM({column1})`"
msgstr ""

msgid "``TOTAL([DISTINCT] expression)``"
msgstr ""

msgid "Example: :samp:`TOTAL({column1})`"
msgstr ""

msgid "HAVING clause"
msgstr ""

msgid ":samp:`HAVING condition;`"
msgstr ""

msgid "Specify the condition for filtering rows from a grouped table; this is a clause in a :ref:`SELECT statement <sql_select>`."
msgstr ""

msgid "The clause preceding the HAVING clause may be a GROUP BY clause. HAVING operates on the table that the GROUP BY produces, which may contain grouped columns and aggregates."
msgstr ""

msgid "If the preceding clause is not a GROUP BY clause, then there is only one group and the HAVING clause may only contain aggregate functions or literals."
msgstr ""

msgid "In effect, HAVING condition takes a table with n rows and returns a table with n or fewer rows."
msgstr ""

msgid "-- with a simple condition:\n"
"SELECT 1 FROM t GROUP BY column1 HAVING column2 > 5;\n"
"-- with a more complicated condition:\n"
"SELECT 1 FROM t GROUP BY column1 HAVING column2 > 5 OR column2 < 5;\n"
"-- with an aggregate:\n"
"SELECT x, SUM(y) FROM t GROUP BY x HAVING SUM(y) > 0;\n"
"-- with no GROUP BY and an aggregate:\n"
"SELECT SUM(y) FROM t GROUP BY x HAVING MIN(y) < MAX(y);"
msgstr ""

msgid "HAVING without GROUP BY is not supported for multiple tables."
msgstr ""

msgid "ORDER BY clause"
msgstr ""

msgid ":samp:`ORDER BY expression [ASC|DESC] [, expression [ASC|DESC] ...]`"
msgstr ""

msgid "Put rows in order; this is a clause in a :ref:`SELECT statement <sql_select>`."
msgstr ""

msgid "An ORDER BY expression has one of three types which are checked in order:"
msgstr ""

msgid "Expression is a positive integer, representing the ordinal position of the column in the select list. For example, in the statement |br| ``SELECT x, y, z FROM t ORDER BY 2;`` |br| ``ORDER BY 2`` means \"order by the second column in the select list\", which is ``y``."
msgstr ""

msgid "Expression is a name of a column in the select list, which is determined by an AS clause. For example, in the statement |br| ``SELECT x, y AS x, z FROM t ORDER BY x;`` |br| ``ORDER BY x`` means \"order by the column explicitly named ``x`` in the select list\", which is the second column."
msgstr ""

msgid "Expression contains a name of a column in a table of the FROM clause. For example, in the statement |br| ``SELECT x, y FROM t1 JOIN t2 ORDER BY z;`` |br| ``ORDER BY z`` means \"order by a column named ``z`` which is expected to be in table ``t1`` or table ``t2``\"."
msgstr ""

msgid "If both tables contain a column named ``z``, then Tarantool will choose the first column that it finds."
msgstr ""

msgid "The expression may also contain operators and function names and literals. For example, in the statement |br| ``SELECT x, y FROM t ORDER BY UPPER(z);`` |br| ``ORDER BY UPPER(z)`` means \"order by the uppercase form of column ``t.z``\", which may be similar to doing ordering in a case-insensitive manner."
msgstr ""

msgid "Type 3 is illegal if the SELECT statement contains :ref:`UNION or EXCEPT or INTERSECT <sql_union>`."
msgstr ""

msgid "If an ORDER BY clause contains multiple expressions, then expressions on the left are processed first and expressions on the right are processed only if necessary for tie-breaking. For example, in the statement |br| ``SELECT x, y FROM t ORDER BY x, y;`` if there are two rows which both have the same values for column ``x``, then an additional check is made to see which row has a greater value for column ``y``."
msgstr ""

msgid "In effect, ORDER BY clause takes a table with rows that may be out of order, and returns a table with rows in order."
msgstr ""

msgid "Sorting order:"
msgstr ""

msgid "The default order is ASC (ascending), the optional order is DESC (descending)."
msgstr ""

msgid "NULLs come first, then BOOLEANs, then numbers (INTEGER or DOUBLE), then STRINGs, then VARBINARYs."
msgstr ""

msgid "Within STRINGs, ordering is according to collation."
msgstr ""

msgid "Collation may be specified with a :ref:`COLLATE clause <sql_collate_clause>` within the ORDER BY column-list, or may be default."
msgstr ""

msgid "-- with a single column:\n"
"SELECT 1 FROM t ORDER BY column1;\n"
"-- with two columns:\n"
"SELECT 1 FROM t ORDER BY column1, column2;\n"
"-- with a variety of data:\n"
"CREATE TABLE h (s1 INTEGER PRIMARY KEY, s2 INTEGER);\n"
"INSERT INTO h VALUES (7, 'A'), (4, 'A '), (-4, 'AZ'), (17, 17), (23, NULL);\n"
"INSERT INTO h VALUES (17.5, ''), (1e+300, 'a'), (0, ''), (-1, '');\n"
"SELECT * FROM h ORDER BY s2, s1;\n"
"-- The result of the above SELECT will be:\n"
"- - [23, null]\n"
"  - [17, 17]\n"
"  - [-1, '']\n"
"  - [0, '']\n"
"  - [7, 'A']\n"
"  - [4, 'A ']\n"
"  - [-4, 'AZ']\n"
"  - [1e+300, 'a']\n"
"  - [17.5, '']\n"
"..."
msgstr ""

msgid "ORDER BY 1 is legal. This is common but is not standard SQL nowadays."
msgstr ""

msgid "LIMIT clause"
msgstr ""

msgid ":samp:`LIMIT limit-expression [OFFSET offset-expression]`"
msgstr ""

msgid ":samp:`LIMIT offset-expression, limit-expression`"
msgstr ""

msgid "The above is not a typo: *offset-expression* and *limit-expression* are in reverse order if a comma is used."
msgstr ""

msgid "Specify a maximum number of rows and a start row; this is a clause in a :ref:`SELECT statement <sql_select>`."
msgstr ""

msgid "Expressions may contain integers and arithmetic operators or functions, for example ``ABS(-3 / 1)``. However, the result must be an integer value greater than or equal to zero."
msgstr ""

msgid "Usually the LIMIT clause follows an :ref:`ORDER BY clause <sql_order_by>`, because otherwise Tarantool does not guarantee that rows are in order."
msgstr ""

msgid "-- simple case:\n"
"SELECT * FROM t LIMIT 3;\n"
"-- both limit and order:\n"
"SELECT * FROM t LIMIT 3 OFFSET 1;\n"
"-- applied to a UNIONed result (LIMIT clause must be the final clause):\n"
"SELECT column1 FROM table1 UNION SELECT column1 FROM table2 ORDER BY 1 LIMIT 1;"
msgstr ""

msgid "If ORDER BY ... LIMIT is used, then all order-by columns must be ASC or all must be DESC."
msgstr ""

msgid "VALUES"
msgstr ""

msgid ":samp:`VALUES (expression [, expression ...]) [, (expression [, expression ...])`"
msgstr ""

msgid "Select one or more rows."
msgstr ""

msgid "VALUES has the same effect as :ref:`SELECT <sql_select>`, that is, it returns a result set, but VALUES statements may not have FROM or GROUP or ORDER BY or LIMIT clauses."
msgstr ""

msgid "VALUES may be used wherever SELECT may be used, for example in :ref:`subqueries <sql_subquery>`."
msgstr ""

msgid "-- simple case:\n"
"VALUES (1);\n"
"-- equivalent to SELECT 1, 2, 3:\n"
"VALUES (1, 2, 3);\n"
"-- two rows:\n"
"VALUES (1, 2, 3), (4, 5, 6);"
msgstr ""

msgid "Subquery"
msgstr ""

msgid ":ref:`SELECT-statement <sql_select>` syntax"
msgstr ""

msgid ":ref:`VALUES-statement <sql_values>` syntax"
msgstr ""

msgid "A subquery has the same syntax as a :ref:`SELECT statement <sql_select>` or :ref:`VALUES statement <sql_values>` embedded inside a main statement."
msgstr ""

msgid "The SELECT and VALUES statements are called \"queries\" because they return answers, in the form of result sets."
msgstr ""

msgid "Subqueries may be the second part of :ref:`INSERT statements <sql_insert>`. For example:"
msgstr ""

msgid "INSERT INTO t2 SELECT a, b, c FROM t1;"
msgstr ""

msgid "Subqueries may be in the :ref:`FROM clause <sql_from>` of SELECT statements."
msgstr ""

msgid "Subqueries may be expressions, or be inside expressions. In this case they must be parenthesized, and usually the number of rows must be 1. For example:"
msgstr ""

msgid "SELECT 1, (SELECT 5), 3 FROM t WHERE c1 * (SELECT COUNT(*) FROM t2) > 5;"
msgstr ""

msgid "Subqueries may be expressions on the right side of certain comparison operators, and in this unusual case the number of rows may be greater than 1. The comparison operators are: [NOT] EXISTS and [NOT] IN. For example:"
msgstr ""

msgid "DELETE FROM t WHERE s1 NOT IN (SELECT s2 FROM t);"
msgstr ""

msgid "Subqueries may refer to values in the outer query. In this case, the subquery is called a \"correlated subquery\"."
msgstr ""

msgid "Subqueries may refer to rows which are being updated or deleted by the main query. In that case, the subquery finds the matching rows first, before starting to update or delete. For example, after:"
msgstr ""

msgid "CREATE TABLE t (s1 INTEGER PRIMARY KEY, s2 INTEGER);\n"
"INSERT INTO t VALUES (1, 3), (2, 1);\n"
"DELETE FROM t WHERE s2 NOT IN (SELECT s1 FROM t);"
msgstr ""

msgid "only one of the rows is deleted, not both rows."
msgstr ""

msgid "WITH clause"
msgstr ""

msgid "**WITH clause (common table expression)**"
msgstr ""

msgid ":samp:`WITH {temporary-table-name} AS (subquery)` |br| :samp:`[, {temporary-table-name} AS (subquery)]` |br| :samp:`SELECT statement | INSERT statement | DELETE statement | UPDATE statement | REPLACE statement;`"
msgstr ""

msgid "WITH v AS (SELECT * FROM t) SELECT * FROM v;"
msgstr ""

msgid "is equivalent to :ref:`creating a view <sql_create_view>` and selecting from it:"
msgstr ""

msgid "CREATE VIEW v AS SELECT * FROM t;\n"
"SELECT * FROM v;"
msgstr ""

msgid "The difference is that a WITH-clause \"view\" is temporary and only useful within the same statement. No CREATE privilege is required."
msgstr ""

msgid "The WITH-clause can also be thought of as a :ref:`subquery <sql_subquery>` that has a name. This is useful when the same subquery is being repeated. For example:"
msgstr ""

msgid "SELECT * FROM t WHERE a < (SELECT s1 FROM x) AND b < (SELECT s1 FROM x);"
msgstr ""

msgid "can be replaced with:"
msgstr ""

msgid "WITH s AS (SELECT s1 FROM x) SELECT * FROM t,s WHERE a < s.s1 AND b < s.s1;"
msgstr ""

msgid "This \"factoring out\" of a repeated expression is regarded as good practice."
msgstr ""

msgid "WITH cte AS (VALUES (7, '') INSERT INTO j SELECT * FROM cte;\n"
"WITH cte AS (SELECT s1 AS x FROM k) SELECT * FROM cte;\n"
"WITH cte AS (SELECT COUNT(*) FROM k WHERE s2 < 'x' GROUP BY s3)\n"
"  UPDATE j SET s2 = 5\n"
"  WHERE s1 = (SELECT s1 FROM cte) OR s3 = (SELECT s1 FROM cte);"
msgstr ""

msgid "WITH can only be used at the beginning of a statement, therefore it cannot be used at the beginning of a subquery or after a :ref:`set operator <sql_union>` or inside a CREATE statement."
msgstr ""

msgid "A WITH-clause \"view\" is read-only because Tarantool does not support updatable views."
msgstr ""

msgid "WITH RECURSIVE"
msgstr ""

msgid "**WITH RECURSIVE clause (iterative common table expression)**"
msgstr ""

msgid "The real power of WITH lies in the WITH RECURSIVE clause, which is useful when it is combined with :ref:`UNION or UNION ALL <sql_union>`:"
msgstr ""

msgid ":samp:`WITH RECURSIVE recursive-table-name AS` |br| :samp:`(SELECT ... FROM non-recursive-table-name ...` |br| :samp:`UNION [ALL]` |br| :samp:`SELECT ... FROM recursive-table-name ...)` |br| :samp:`statement-that-uses-recursive-table-name;` |br|"
msgstr ""

msgid "In non-SQL this can be read as: starting with a seed value from a non-recursive table, produce a recursive viewed table, UNION that with itself, UNION that with itself, UNION that with itself ... forever, or until a condition in the WHERE clause says \"stop\"."
msgstr ""

msgid "CREATE TABLE ts (s1 INTEGER PRIMARY KEY);\n"
"INSERT INTO ts VALUES (1);\n"
"WITH RECURSIVE w AS (\n"
"  SELECT s1 FROM ts\n"
"  UNION ALL\n"
"  SELECT s1 + 1 FROM w WHERE s1 < 4)\n"
"SELECT * FROM w;"
msgstr ""

msgid "First, table ``w`` is seeded from ``t1``, so it has one row: [1]."
msgstr ""

msgid "Then, ``UNION ALL (SELECT s1 + 1 FROM w)`` takes the row from ``w`` -- which contains [1] -- adds 1 because the select list says \"s1+1\", and so it has one row: [2]."
msgstr ""

msgid "Then, ``UNION ALL (SELECT s1 + 1 FROM w)`` takes the row from ``w`` -- which contains [2] -- adds 1 because the select list says \"s1+1\", and so it has one row: [3]."
msgstr ""

msgid "Then, ``UNION ALL (SELECT s1 + 1 FROM w)`` takes the row from ``w`` -- which contains [3] -- adds 1 because the select list says \"s1+1\", and so it has one row: [4]."
msgstr ""

msgid "Then, ``UNION ALL (SELECT s1 + 1 FROM w)`` takes the row from ``w`` -- which contains [4] -- and now the importance of the WHERE clause becomes evident, because \"s1 < 4\" is false for this row, and therefore we have reached the \"stop\" condition."
msgstr ""

msgid "So, before the \"stop\", table ``w`` got 4 rows -- [1], [2], [3], [4] -- and the result of the statement looks like:"
msgstr ""

msgid "tarantool> WITH RECURSIVE w AS (\n"
"         >   SELECT s1 FROM ts\n"
"         >   UNION ALL\n"
"         >   SELECT s1 + 1 FROM w WHERE s1 < 4)\n"
"         > SELECT * FROM w;\n"
"---\n"
"- - [1]\n"
"  - [2]\n"
"  - [3]\n"
"  - [4]\n"
"..."
msgstr ""

msgid "In other words, this ``WITH RECURSIVE ... SELECT`` produces a table of auto-incrementing values."
msgstr ""

msgid "UNION, EXCEPT, and INTERSECT clauses"
msgstr ""

msgid ":samp:`select-statement UNION [ALL] select-statement [ORDER BY clause] [LIMIT clause];`"
msgstr ""

msgid ":samp:`select-statement EXCEPT select-statement [ORDER BY clause] [LIMIT clause];`"
msgstr ""

msgid ":samp:`select-statement INTERSECT select-statement [ORDER BY clause] [LIMIT clause];`"
msgstr ""

msgid "UNION, EXCEPT, and INTERSECT are collectively called \"set operators\" or \"table operators\". In particular:"
msgstr ""

msgid "``a UNION b`` means \"take rows which occur in a OR b\"."
msgstr ""

msgid "``a EXCEPT b`` means \"take rows which occur in a AND NOT b\"."
msgstr ""

msgid "``a INTERSECT b`` means \"take rows which occur in a AND b\"."
msgstr ""

msgid "Duplicate rows are eliminated unless ALL is specified."
msgstr ""

msgid "The *select-statements* may be chained: ``SELECT ... SELECT ... SELECT ...;``"
msgstr ""

msgid "Each *select-statement* must result in the same number of columns."
msgstr ""

msgid "The *select-statements* may be replaced with :ref:`VALUES statements <sql_values>`."
msgstr ""

msgid "The maximum number of set operations is 50."
msgstr ""

msgid "CREATE TABLE t1 (s1 INTEGER PRIMARY KEY, s2 STRING);\n"
"CREATE TABLE t2 (s1 INTEGER PRIMARY KEY, s2 STRING);\n"
"INSERT INTO t1 VALUES (1, 'A'), (2, 'B'), (3, NULL);\n"
"INSERT INTO t2 VALUES (1, 'A'), (2, 'C'), (3,NULL);\n"
"SELECT s2 FROM t1 UNION SELECT s2 FROM t2;\n"
"SELECT s2 FROM t1 UNION ALL SELECT s2 FROM t2 ORDER BY s2;\n"
"SELECT s2 FROM t1 EXCEPT SELECT s2 FROM t2;\n"
"SELECT s2 FROM t1 INTERSECT SELECT s2 FROM t2;"
msgstr ""

msgid "In this example:"
msgstr ""

msgid "The UNION query returns 4 rows: NULL, 'A', 'B', 'C'."
msgstr ""

msgid "The UNION ALL query returns 6 rows: NULL, NULL, 'A', 'A', 'B', 'C'."
msgstr ""

msgid "The EXCEPT query returns 1 row: 'B'."
msgstr ""

msgid "The INTERSECT query returns 2 rows: NULL, 'A'."
msgstr ""

msgid "Parentheses are not allowed."
msgstr ""

msgid "Evaluation is left to right, INTERSECT does not have precedence."
msgstr ""

msgid "CREATE TABLE t01 (s1 INTEGER PRIMARY KEY, s2 STRING);\n"
"CREATE TABLE t02 (s1 INTEGER PRIMARY KEY, s2 STRING);\n"
"CREATE TABLE t03 (s1 INTEGER PRIMARY KEY, s2 STRING);\n"
"INSERT INTO t01 VALUES (1, 'A');\n"
"INSERT INTO t02 VALUES (1, 'B');\n"
"INSERT INTO t03 VALUES (1, 'A');\n"
"SELECT s2 FROM t01 INTERSECT SELECT s2 FROM t03 UNION SELECT s2 FROM t02;\n"
"SELECT s2 FROM t03 UNION SELECT s2 FROM t02 INTERSECT SELECT s2 FROM t03;\n"
"-- ... results are different."
msgstr ""

msgid "INDEXED BY clause"
msgstr ""

msgid ":samp:`INDEXED BY {index-name}`"
msgstr ""

msgid "The INDEXED BY clause may be used in a :ref:`SELECT <sql_select>`, :ref:`DELETE <sql_delete>`, or :ref:`UPDATE <sql_update>` statement, immediately after the *table-name*. For example:"
msgstr ""

msgid "DELETE FROM table7 INDEXED BY index7 WHERE column1 = 'a';"
msgstr ""

msgid "In this case the search for 'a' will take place within ``index7``. For example:"
msgstr ""

msgid "SELECT * FROM table7 NOT INDEXED WHERE column1 = 'a';"
msgstr ""

msgid "In this case the search for 'a' will be done via a search of the whole table, what is sometimes called a \"full table scan\", even if there is an index for ``column1``."
msgstr ""

msgid "Ordinarily Tarantool chooses the appropriate index or lookup method depending on a complex set of \"optimizer\" rules; the INDEXED BY clause overrides the optimizer choice."
msgstr ""

msgid "Suppose a table has two columns:"
msgstr ""

msgid "The first column is the primary key and therefore it has an automatic index named ``pk_unnamed_T_1``."
msgstr ""

msgid "The second column has an index created by the user."
msgstr ""

msgid "The user selects with ``INDEXED BY the-index-on-column1``, then selects with ``INDEXED BY the-index-on-column-2``."
msgstr ""

msgid "CREATE TABLE t (column1 INTEGER PRIMARY KEY, column2 INTEGER);\n"
"CREATE INDEX idx_column2_t_1 ON t (column2);\n"
"INSERT INTO t VALUES (1, 2), (2, 1);\n"
"SELECT * FROM t INDEXED BY \"pk_unnamed_T_1\";\n"
"SELECT * FROM t INDEXED BY i;\n"
"-- Result for the first select: (1, 2), (2, 1)\n"
"-- Result for the second select: (2, 1), (1, 2)."
msgstr ""

msgid "Limitations: |br| Often INDEXED BY has no effect. |br| Often INDEXED BY affects a choice of covering index, but not a WHERE clause."
msgstr ""

msgid "Transactions"
msgstr ""

msgid "START TRANSACTION"
msgstr ""

msgid ":samp:`START TRANSACTION;`"
msgstr ""

msgid "Start a transaction. After ``START TRANSACTION;``, a transaction is \"active\". If a transaction is already active, then ``START TRANSACTION;`` is illegal."
msgstr ""

msgid "Transactions should be active for fairly short periods of time, to avoid concurrency issues. To end a transaction, say :ref:`COMMIT; <sql_commit>` or :ref:`ROLLBACK; <sql_rollback>`."
msgstr ""

msgid "Just as in NoSQL, transaction control statements are subject to limitations set by the :ref:`storage engine <engines-chapter>` involved: |br| * For the memtx storage engine, if a yield happens within an active transaction, the transaction is rolled back. |br| * For the vinyl engine, yields are allowed. |br| Also, although CREATE AND DROP and ALTER statements are legal in transactions, there are a few exceptions. For example, :samp:`CREATE INDEX ON {table_name} ...` will fail within a multi-statement transaction if the table is not empty."
msgstr ""

msgid "However,transaction control statements still may not work as you expect when run over a network connection: a transaction is associated with a fiber, not a network connection, and different transaction control statements sent via the same network connection may be executed by different fibers from the fiber pool."
msgstr ""

msgid "In order to ensure that all statements are part of the intended transaction, put all of them between ``START TRANSACTION;`` and ``COMMIT;`` or ``ROLLBACK;`` then send as a single batch. For example:"
msgstr ""

msgid "Enclose each separate SQL statement in a :ref:`box.execute() <box-sql_box_execute>` function."
msgstr ""

msgid "Pass all the ``box.execute()`` functions to the server in a single message."
msgstr ""

msgid "If you are using a console, you can do this by writing everything on a single line."
msgstr ""

msgid "If you are using :ref:`net.box <net_box-module>`, you can do this by putting all the function calls in a single string and calling :ref:`eval(string) <net_box-eval>`."
msgstr ""

msgid "START TRANSACTION;"
msgstr ""

msgid "Example of a whole transaction sent to a server on ``localhost:3301`` with ``eval(string)``:"
msgstr ""

msgid "net_box = require('net.box')\n"
"conn = net_box.new('localhost', 3301)\n"
"s = 'box.execute([[START TRANSACTION;]]) '\n"
"s = s .. 'box.execute([[INSERT INTO t VALUES (1);]]) '\n"
"s = s .. 'box.execute([[ROLLBACK;]]) '\n"
"conn:eval(s)"
msgstr ""

msgid "COMMIT"
msgstr ""

msgid ":samp:`COMMIT;`"
msgstr ""

msgid "Commit an active transaction, so all changes are made permanent and the transaction ends."
msgstr ""

msgid "COMMIT is illegal unless a transaction is active. If a transaction is not active then SQL statements are committed automatically."
msgstr ""

msgid "COMMIT;"
msgstr ""

msgid "SAVEPOINT"
msgstr ""

msgid ":samp:`SAVEPOINT {savepoint-name};`"
msgstr ""

msgid "Set a savepoint, so that :ref:`ROLLBACK TO savepoint-name <sql_rollback>` is possible."
msgstr ""

msgid "SAVEPOINT is illegal unless a transaction is active."
msgstr ""

msgid "If a savepoint with the same name already exists, it is released before the new savepoint is set."
msgstr ""

msgid "SAVEPOINT x;"
msgstr ""

msgid "RELEASE SAVEPOINT"
msgstr ""

msgid ":samp:`RELEASE SAVEPOINT {savepoint-name};`"
msgstr ""

msgid "Release (destroy) a savepoint created by a :ref:`SAVEPOINT statement <sql_savepoint>`."
msgstr ""

msgid "RELEASE is illegal unless a transaction is active."
msgstr ""

msgid "Savepoints are released automatically when a transaction ends."
msgstr ""

msgid "RELEASE SAVEPOINT x;"
msgstr ""

msgid "ROLLBACK"
msgstr ""

msgid ":samp:`ROLLBACK [TO [SAVEPOINT] {savepoint-name}];`"
msgstr ""

msgid "If ROLLBACK does not specify a *savepoint-name*, rollback an active transaction, so all changes since :ref:`START TRANSACTION <sql_start_transaction>` are cancelled, and the transaction ends."
msgstr ""

msgid "If ROLLBACK does specify a *savepoint-name*, rollback an active transaction, so all changes since :ref:`SAVEPOINT savepoint-name <sql_savepoint>` are cancelled, and the transaction does not end."
msgstr ""

msgid "ROLLBACK is illegal unless a transaction is active."
msgstr ""

msgid "-- the simple form:\n"
"ROLLBACK;\n"
"-- the form so changes before a savepoint are not cancelled:\n"
"ROLLBACK TO SAVEPOINT x;"
msgstr ""

msgid "-- An example of a Lua function that will do a transaction\n"
"-- containing savepoint and rollback to savepoint.\n"
"function f()\n"
"box.execute([[DROP TABLE IF EXISTS t;]]) -- commits automatically\n"
"box.execute([[CREATE TABLE t (s1 STRING PRIMARY KEY);]]) -- commits automatically\n"
"box.execute([[START TRANSACTION;]]) -- after this succeeds, a transaction is active\n"
"box.execute([[INSERT INTO t VALUES ('Data change #1');]])\n"
"box.execute([[SAVEPOINT \"1\";]])\n"
"box.execute([[INSERT INTO t VALUES ('Data change #2');]])\n"
"box.execute([[ROLLBACK TO SAVEPOINT \"1\";]]) -- rollback Data change #2\n"
"box.execute([[ROLLBACK TO SAVEPOINt \"1\";]]) -- this is legal but does nothing\n"
"box.execute([[COMMIT;]]) -- make Data change #1 permanent, end the transaction\n"
"end"
msgstr ""

msgid "PRAGMA"
msgstr ""

msgid ":samp:`PRAGMA {pragma-name} (pragma-value);`"
msgstr ""

msgid "or :samp:`PRAGMA {pragma-name};`"
msgstr ""

msgid "PRAGMA statements will give rudimentary information about database 'metadata' or server performance, although it is better to get metadata via :ref:`system tables <sql_system_tables>`."
msgstr ""

msgid "For PRAGMA statements that include (``pragma-value``), pragma values are strings and can be specified inside ``\"\"`` double quotes, or without quotes. When a string is used for searching, results must match according to a binary collation. If the object being searched has a lower-case name, use double quotes."
msgstr ""

msgid "In an earlier version, there were some PRAGMA statements that determined behavior. Now that does not happen. Behavior change is done by updating the :ref:`box.space._session_settings <box_space-session_settings>` system table."
msgstr ""

msgid "Pragma"
msgstr ""

msgid "Parameter"
msgstr ""

msgid "Effect"
msgstr ""

msgid "foreign_key_list"
msgstr ""

msgid "string |br| table-name"
msgstr ""

msgid "Return a result set with one row for each foreign key of \"table-name\". Each row contains: |br| (INTEGER) id -- identification number |br| (INTEGER) seq -- sequential number |br| (STRING) table -- name of table |br| (STRING) from  -- referencing key |br| (STRING) to -- referenced key |br| (STRING) on_update -- ON UPDATE clause |br| (STRING) on_delete -- ON DELETE clause |br| (STRING) match -- MATCH clause |br| The system table is ``\"_fk_constraint\"``."
msgstr ""

msgid "collation_list"
msgstr ""

msgid "Return a result set with one row for each supported collation. The first four collations are ``'none'`` and ``'unicode'`` and ``'unicode_ci'`` and ``'binary'``, then come about 270 predefined collations, the exact count may vary because users can add their own collations. |br| The system table is ``\"_collation\"``."
msgstr ""

msgid "index_info"
msgstr ""

msgid "string |br| table-name . index-name"
msgstr ""

msgid "Return a result set with one row for each column in \"table-name.index-name\". Each row contains: |br| (INTEGER) seqno -- the column's ordinal position in the index (first column is 0) |br| (INTEGER) cid -- the column's ordinal position in the table (first column is 0) |br| (STRING) name -- name of the column |br| (INTEGER) desc -- 0 if ASC, 1 if DESC |br| (STRING) collation name |br| (STRING) type -- data type |br|"
msgstr ""

msgid "index_list"
msgstr ""

msgid "Return a result set with one row for each index of \"table-name\". Each row contains: |br| (INTEGER) seq -- sequential number |br| (STRING) name -- index name |br| (INTEGER) unique -- whether the index is unique, 0 = false, 1 = true |br| The system table is ``\"_index\"``."
msgstr ""

msgid "stats"
msgstr ""

msgid "Return a result set with one row for each index of each table. Each row contains: |br| (STRING) table -- name of the table |br| (STRING) index -- name of the index |br| (INTEGER) width -- arbitrary information |br| (INTEGER) height -- arbitrary information"
msgstr ""

msgid "table_info"
msgstr ""

msgid "Return a result set with one row for each column in \"table-name\". Each row contains: |br| (INTEGER) cid -- ordinal position in the table |br| (first column number is 0) |br| (STRING) name -- column name |br| (INTEGER) notnull -- whether the column is NOT NULL. 0 is false, 1 is true. |br| (STRING) dflt_value -- default value |br| (INTEGER) pk -- whether the column is a PRIMARY KEY column. 0 is false, 1 is true."
msgstr ""

msgid "Example: (not showing metadata)"
msgstr ""

msgid "PRAGMA table_info('T');\n"
"---\n"
"- - [0, 's1', 'integer', 1, null, 1]\n"
"  - [1, 's2', 'integer', 0, null, 0]\n"
"..."
msgstr ""

msgid "EXPLAIN"
msgstr ""

msgid ":samp:`EXPLAIN explainable-statement;`"
msgstr ""

msgid "EXPLAIN will show what steps Tarantool would take if it executed explainable-statement. This is primarily a debugging and optimization aid for the Tarantool team."
msgstr ""

msgid "Example: ``EXPLAIN DELETE FROM m;`` returns:"
msgstr ""

msgid "- - [0, 'Init', 0, 3, 0, '', '00', 'Start at 3']\n"
"  - [1, 'Clear', 16416, 0, 0, '', '00', '']\n"
"  - [2, 'Halt', 0, 0, 0, '', '00', '']\n"
"  - [3, 'Transaction', 0, 1, 1, '0', '01', 'usesStmtJournal=0']\n"
"  - [4, 'Goto', 0, 1, 0, '', '00', '']"
msgstr ""

msgid "Variation: ``EXPLAIN QUERY PLAN statement;`` shows the steps of a search."
msgstr ""

msgid "Functions"
msgstr ""

msgid "Apply a built-in function to one or more expressions and return a scalar value."
msgstr ""

msgid "Tarantool supports 32 built-in functions."
msgstr ""

msgid "The maximum number of operands for any function is 127."
msgstr ""

msgid "The required privileges for built-in functions will likely change in a future version."
msgstr ""

msgid "ABS"
msgstr ""

msgid ":samp:`ABS({numeric-expression})`"
msgstr ""

msgid "Return the absolute value of numeric-expression, which can be any numeric type."
msgstr ""

msgid "Example: ``ABS(-1)`` is 1."
msgstr ""

msgid "CAST"
msgstr ""

msgid ":samp:`CAST({expression} AS {data-type})`"
msgstr ""

msgid "Return the expression value after casting to the specified :ref:`data type <sql_column_def_data_type>`."
msgstr ""

msgid "Examples: ``CAST('AB' AS VARBINARY)``, ``CAST(X'4142' AS STRING)``"
msgstr ""

msgid "CHAR"
msgstr ""

msgid ":samp:`CHAR([numeric-expression [,numeric-expression...])`"
msgstr ""

msgid "Return the characters whose Unicode code point values are equal to the numeric expressions."
msgstr ""

msgid "Short example:"
msgstr ""

msgid "The first 128 Unicode characters are the \"ASCII\" characters, so CHAR(65, 66, 67) is 'ABC'."
msgstr ""

msgid "Long example:"
msgstr ""

msgid "For the current list of Unicode characters, in order by code point, see `www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt <http://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt>`_. In that list, there is a line for a Linear B ideogram"
msgstr ""

msgid "``100CC;LINEAR B IDEOGRAM B240 WHEELED CHARIOT ...``"
msgstr ""

msgid "Therefore, for a string with a chariot in the middle, use the concatenation operator ``||`` and the CHAR function"
msgstr ""

msgid "``'start of string ' || CHAR(0X100CC) || ' end of string'``."
msgstr ""

msgid "COALESCE"
msgstr ""

msgid ":samp:`COALESCE(expression, expression [, expression ...])`"
msgstr ""

msgid "Return the value of the first non-NULL expression, or, if all expression values are NULL, return NULL."
msgstr ""

msgid "``COALESCE(NULL, 17, 32)`` is 17."
msgstr ""

msgid "GREATEST"
msgstr ""

msgid ":samp:`GREATEST({expression-1}, {expression-2}, [{expression-3} ...])`"
msgstr ""

msgid "Return the greatest value of the supplied expressions, or, if any expression is NULL, return NULL. The reverse of ``GREATEST`` is :ref:`LEAST <sql_function_least>`."
msgstr ""

msgid "Examples: ``GREATEST(7, 44, -1)`` is 44; ``GREATEST(1E308, 'a', 0, X'00')`` is '\\0' = the nul character; ``GREATEST(3, NULL, 2)`` is NULL"
msgstr ""

msgid "HEX"
msgstr ""

msgid ":samp:`HEX(expression)`"
msgstr ""

msgid "Return the hexadecimal code for each byte in **expression**, which may be either a string or a byte sequence. For ASCII characters, this is straightforward because the encoding is the same as the code point value. For non-ASCII characters, since character strings are usually encoded in UTF-8, each character will require two or more bytes."
msgstr ""

msgid "``HEX('A')`` will return ``41``."
msgstr ""

msgid "``HEX('')`` will return ``D094``."
msgstr ""

msgid "IFNULL"
msgstr ""

msgid ":samp:`IFNULL(expression, expression)`"
msgstr ""

msgid "Return the value of the first non-NULL expression, or, if both expression values are NULL, return NULL. Thus ``IFNULL(expression, expression)`` is the same as ``COALESCE(expression, expression)``."
msgstr ""

msgid "``IFNULL(NULL, 17)`` is 17"
msgstr ""

msgid "LEAST"
msgstr ""

msgid ":samp:`LEAST({expression-1}, {expression-2}, [{expression-3} ...])`"
msgstr ""

msgid "Return the least value of the supplied expressions, or, if any expression is NULL, return . The reverse of ``LEAST`` is :ref:`GREATEST <sql_function_greatest>`."
msgstr ""

msgid "Examples: ``LEAST(7, 44, -1)`` is -1; ``LEAST(1E308, 'a', 0, X'00')`` is 0; ``LEAST(3, NULL, 2)`` is NULL."
msgstr ""

msgid "LENGTH"
msgstr ""

msgid ":samp:`LENGTH(expression)`"
msgstr ""

msgid "Return the number of characters in the **expression**, or the number of bytes in the **expression**. It depends on the data type: strings with data type STRING are counted in characters, byte sequences with data type VARBINARY are counted in bytes and are not ended by the nul character. There are two aliases for ``LENGTH(expression)`` -- ``CHAR_LENGTH(expression)`` and ``CHARACTER_LENGTH(expression)`` do the same thing."
msgstr ""

msgid "``LENGTH('')`` is 2, the string has 2 characters."
msgstr ""

msgid "``LENGTH(CAST('' AS VARBINARY))`` is 4, the string has 4 bytes."
msgstr ""

msgid "``LENGTH(CHAR(0, 65))`` is 2, '\\0' does not mean 'end of string'."
msgstr ""

msgid "``LENGTH(X'410041')`` is 3, X'...' byte sequences have type VARBINARY."
msgstr ""

msgid "LIKELIHOOD"
msgstr ""

msgid ":samp:`LIKELIHOOD({expression}, {number literal})`"
msgstr ""

msgid "Return the result of the expression, provided that the number literal is between 0.0 and 1.0."
msgstr ""

msgid "Example: ``LIKELIHOOD('a' = 'b', .0)`` is FALSE"
msgstr ""

msgid "LIKELY"
msgstr ""

msgid ":samp:`LIKELY({expression})`"
msgstr ""

msgid "Return TRUE if the expression is probably true."
msgstr ""

msgid "Example: ``LIKELY('a' <= 'b')`` is TRUE"
msgstr ""

msgid "LOWER"
msgstr ""

msgid ":samp:`LOWER({string-expression})`"
msgstr ""

msgid "Return the expression, with upper-case characters converted to lower case. The reverse of ``LOWER`` is :ref:`UPPER <sql_function_upper>`."
msgstr ""

msgid "Example: ``LOWER('A')`` is 'a'"
msgstr ""

msgid "NULLIF"
msgstr ""

msgid ":samp:`NULLIF(expression-1, expression-2)`"
msgstr ""

msgid "Return *expression-1* if *expression-1* <> *expression-2*, otherwise return NULL."
msgstr ""

msgid "``NULLIF('a', 'A')`` is 'a'."
msgstr ""

msgid "``NULLIF(1.00, 1)`` is NULL."
msgstr ""

msgid "POSITION"
msgstr ""

msgid ":samp:`POSITION({expression-1}, {expression-2})`"
msgstr ""

msgid "Return the position of expression-1 within expression-2, or return 0 if expression-1 does not appear within expression-2. The data types of the expressions must be either STRING or VARBINARY. If the expressions have data type STRING, then the result is the character position. If the expressions have data type VARBINARY, then the result is the byte position."
msgstr ""

msgid "Short example: ``POSITION('C', 'ABC')`` is 3"
msgstr ""

msgid "Long example: The UTF-8 encoding for the Latin letter A is hexadecimal 41; the UTF-8 encoding for the Cyrillic letter  is hexadecimal D094 -- you can confirm this by saying SELECT HEX('A'); and seeing that the result is 'D09441'. If you now execute ``SELECT POSITION('A', 'A');`` the result will be 2, because 'A' is the second character in the string. However, if you now execute ``SELECT POSITION(X'41', X'D09441');`` the result will be 3, because X'41' is the third byte in the byte sequence."
msgstr ""

msgid "PRINTF"
msgstr ""

msgid ":samp:`PRINTF(string-expression [, expression ...])`"
msgstr ""

msgid "Return a string formatted according to the rules of the C ``sprintf()`` function, where ``%d%s`` means the next two arguments are a number and a string, and so on."
msgstr ""

msgid "If an argument is missing or is NULL, it becomes:"
msgstr ""

msgid "'0' if the format requires an integer,"
msgstr ""

msgid "'0.0' if the format requires a number with a decimal point,"
msgstr ""

msgid "'' if the format requires a string."
msgstr ""

msgid "Example: ``PRINTF('%da', 5)`` is '5a'."
msgstr ""

msgid "QUOTE"
msgstr ""

msgid ":samp:`QUOTE(string-literal)`"
msgstr ""

msgid "Return a string with enclosing quotes if necessary, and with quotes inside the enclosing quotes if necessary. This function is useful for creating strings which are part of SQL statements, because of SQL's rules that string literals are enclosed by single quotes, and single quotes inside such strings are shown as two single quotes in a row."
msgstr ""

msgid "Example: ``QUOTE('a')`` is ``'a'``."
msgstr ""

msgid "RAISE"
msgstr ""

msgid ":samp:`RAISE(FAIL, {error-message})`"
msgstr ""

msgid "This may only be used within a triggered statement. See also :ref:`Trigger Activation <sql_trigger_activation>`."
msgstr ""

msgid "RANDOM"
msgstr ""

msgid "Syntax: :samp:`RANDOM()`"
msgstr ""

msgid "Return a 19-digit integer which is generated by a pseudo-random number generator,"
msgstr ""

msgid "Example: ``RANDOM()`` is 6832175749978026034, or it is any other integer"
msgstr ""

msgid "RANDOMBLOB"
msgstr ""

msgid ":samp:`RANDOMBLOB({n})`"
msgstr ""

msgid "Return a byte sequence, n bytes long, data type = VARBINARY, containing bytes generated by a pseudo-random byte generator. The result can be translated to hexadecimal. If n is less than 1 or is NULL or is infinity, then NULL is returned."
msgstr ""

msgid "Example: ``HEX(RANDOMBLOB(3))`` is '9EAAA8', or it is the hex value for any other three-byte string"
msgstr ""

msgid ":samp:`REPLACE({expression-1}, {xpression-2}, {expression-3})`"
msgstr ""

msgid "Return expression-1, except that wherever expression-1 contains expression-2, replace expression-2 with expression-3. The expressions should all have data type STRING or VARBINARY."
msgstr ""

msgid "Example: ``REPLACE('AAABCCCBD', 'B', '!')`` is 'AAA!CCC!D'"
msgstr ""

msgid "ROUND"
msgstr ""

msgid ":samp:`ROUND({numeric-expression-1} [, {numeric-expression-2}])`"
msgstr ""

msgid "Return the rounded value of numeric-expression-1, always rounding .5 upward for floating-point positive numbers or downward for negative numbers. If numeric-expression-2 is supplied then rounding is to the nearest numeric-expression-2 digits after the decimal point; if numeric-expression-2 is not supplied then rounding is to the nearest integer."
msgstr ""

msgid "Example: ``ROUND(-1.5)`` is -2, ``ROUND(1.7766E1,2)`` is 17.77."
msgstr ""

msgid "ROW_COUNT"
msgstr ""

msgid ":samp:`ROW_COUNT()`"
msgstr ""

msgid "Return the number of rows that were inserted / updated / deleted by the last :ref:`INSERT <sql_insert>` or :ref:`UPDATE <sql_update>` or :ref:`DELETE <sql_delete>` or :ref:`REPLACE <sql_replace>` statement. Rows which were updated by an UPDATE statement are counted even if there was no change. Rows which were inserted / updated / deleted due to foreign-key action are not counted. Rows which were inserted / updated / deleted due to a view's :ref:`INSTEAD OF triggers <sql_instead_of_triggers>` are  not counted. After a CREATE or DROP statement, ROW_COUNT() is 1. After other statements,  ROW_COUNT() is 0."
msgstr ""

msgid "Example: ``ROW_COUNT()`` is 1 after a successful INSERT of a single row."
msgstr ""

msgid "Special rule if there are BEFORE or AFTER triggers: In effect the ROW_COUNT() counter is pushed at the beginning of a series of triggered statements, and popped at the end. Therefore, after the following statements:"
msgstr ""

msgid "CREATE TABLE t1 (s1 INTEGER PRIMARY KEY);\n"
"CREATE TABLE t2 (s1 INTEGER, s2 STRING, s3 INTEGER, PRIMARY KEY (s1, s2, s3));\n"
"CREATE TRIGGER tt1 BEFORE DELETE ON t1 FOR EACH ROW BEGIN\n"
"  INSERT INTO t2 VALUES (old.s1, '#2 Triggered', ROW_COUNT());\n"
"  INSERT INTO t2 VALUES (old.s1, '#3 Triggered', ROW_COUNT());\n"
"  END;\n"
"INSERT INTO t1 VALUES (1),(2),(3);\n"
"DELETE FROM t1;\n"
"INSERT INTO t2 VALUES (4, '#4 Untriggered', ROW_COUNT());\n"
"SELECT * FROM t2;"
msgstr ""

msgid "The result is:"
msgstr ""

msgid "---\n"
"- - [1, '#2 Triggered', 3]\n"
"  - [1, '#3 Triggered', 1]\n"
"  - [2, '#2 Triggered', 3]\n"
"  - [2, '#3 Triggered', 1]\n"
"  - [3, '#2 Triggered', 3]\n"
"  - [3, '#3 Triggered', 1]\n"
"  - [4, '#4 Untriggered', 3]\n"
"..."
msgstr ""

msgid "SOUNDEX"
msgstr ""

msgid ":samp:`SOUNDEX(string-expression)`"
msgstr ""

msgid "Return a four-character string which represents the sound of ``string-expression``. Often words and names which have different spellings will have the same Soundex representation if they are pronounced similarly, so it is possible to search by what they sound like. The algorithm works with characters in the Latin alphabet and works best with English words."
msgstr ""

msgid "Example: ``SOUNDEX('Crater')`` and ``SOUNDEX('Creature')`` both return ``C636``."
msgstr ""

msgid "SUBSTR"
msgstr ""

msgid ":samp:`SUBSTR({expression-1}, {numeric-expression-1} [, {numeric-expression-2}])`"
msgstr ""

msgid "If expression-1 has data type STRING, then return the substring which begins at character position numeric-expression-1 and continues for numeric-expression-2 characters (if numeric-expression-2 is supplied), or continues till the end of string-expression-1 (if numeric-expression-2 is not supplied)."
msgstr ""

msgid "If expression-1 has data type VARBINARY rather than data type STRING, then positioning and counting is by bytes rather than by characters."
msgstr ""

msgid "Example: ``SUBSTR('ABCDEFG', 3, 2)`` is 'CD'"
msgstr ""

msgid "TRIM"
msgstr ""

msgid ":samp:`TRIM([[LEADING|TRAILING|BOTH] [{expression-1}] FROM] {expression-2})`"
msgstr ""

msgid "Return expression-2 after removing all leading and/or trailing characters or bytes. The expressions should have data type STRING or VARBINARY. If LEADING|TRAILING|BOTH is omitted, the default is BOTH. If expression-1 is omitted, the default is ' ' (space) for data type STRING or X'00' (nul) for data type VARBINARY."
msgstr ""

msgid "Examples: ``TRIM('a' FROM 'abaaaaa')`` is 'b' -- all repetitions of 'a' are removed on both sides; ``TRIM(TRAILING '' FROM '')`` is '' -- if all characters are Hebrew, TRAILING means \"left\"; ``TRIM(X'004400')`` is X'44' -- the default byte sequence to trim is X'00' when data type is VARBINARY' ``TRIM(LEADING 'abc' FROM 'abcd')`` is 'd' -- expression-1 can have more than 1 character"
msgstr ""

msgid "TYPEOF"
msgstr ""

msgid ":samp:`TYPEOF({expression})`"
msgstr ""

msgid "Return the :ref:`data type <sql_column_def_data_type>` of the expression."
msgstr ""

msgid "Examples: ``TYPEOF('A')`` returns 'string'; ``TYPEOF(RANDOMBLOB(1))`` returns 'varbinary'; ``TYPEOF(1e44)`` returns 'double' or 'number'; ``TYPEOF(-44)`` returns 'integer'; ``TYPEOF(NULL)`` returns 'boolean'"
msgstr ""

msgid "UNICODE"
msgstr ""

msgid ":samp:`UNICODE(string-expression)`"
msgstr ""

msgid "Return the Unicode code point value of the first character of **string-expression**. If *string-expression* is empty, the return is NULL. This is the reverse of :ref:`CHAR(integer) <sql_function_char>`."
msgstr ""

msgid "Example: ``UNICODE('')`` is 1065 (hexadecimal 0429)."
msgstr ""

msgid "UNLIKELY"
msgstr ""

msgid ":samp:`UNLIKELY({expression})`"
msgstr ""

msgid "Return TRUE if the expression is probably false. Limitation: in fact ``UNLIKELY`` may return the same thing as :ref:`LIKELY <sql_function_likely>`."
msgstr ""

msgid "Example: ``UNLIKELY('a' <= 'b')`` is TRUE."
msgstr ""

msgid "UPPER"
msgstr ""

msgid ":samp:`UPPER(string-expression)`"
msgstr ""

msgid "Return the expression, with lower-case characters converted to upper case. The reverse of ``UPPER`` is :ref:`LOWER <sql_function_lower>`."
msgstr ""

msgid "Example: ``UPPER('-4l')`` is '-4L'."
msgstr ""

msgid "VERSION"
msgstr ""

msgid ":samp:`VERSION()`"
msgstr ""

msgid "Return the Tarantool version."
msgstr ""

msgid "Example: for a December 2019 build VERSION() is ``2.3.0-258-g960e9c0c7``."
msgstr ""

msgid "ZEROBLOB"
msgstr ""

msgid ":samp:`ZEROBLOB({n})`"
msgstr ""

msgid "Return a byte sequence, data type = VARBINARY, n bytes long."
msgstr ""

msgid "COLLATE clause"
msgstr ""

msgid ":samp:`COLLATE collation-name`"
msgstr ""

msgid "The collation-name must identify an existing collation."
msgstr ""

msgid "The COLLATE clause is allowed for STRING or SCALAR items: |br| () in :ref:`CREATE INDEX <sql_create_index>` |br| () in :ref:`CREATE TABLE <sql_create_table>` as part of :ref:`column definition <sql_column_def>` |br| () in CREATE TABLE as part of :ref:`UNIQUE definition <sql_table_constraint_def>` |br| () in string expressions |br|"
msgstr ""

msgid "-- In CREATE INDEX\n"
"CREATE INDEX idx_unicode_mb_1 ON mb (s1 COLLATE \"unicode\");\n"
"-- In CREATE TABLE\n"
"CREATE TABLE t1 (s1 INTEGER PRIMARY KEY, s2 STRING COLLATE \"unicode_ci\");\n"
"-- In CREATE TABLE ... UNIQUE\n"
"CREATE TABLE mb (a STRING, b STRING, PRIMARY KEY(a), UNIQUE(b COLLATE \"unicode_ci\" DESC));\n"
"-- In string expressions\n"
"SELECT 'a' = 'b' COLLATE \"unicode\"\n"
"    FROM t\n"
"    WHERE s1 = 'b' COLLATE \"unicode\"\n"
"    ORDER BY s1 COLLATE \"unicode\";"
msgstr ""

msgid "The list of collations can be seen with: :ref:`PRAGMA collation_list; <sql_pragma>`"
msgstr ""

msgid "The collation rules comply completely with the Unicode Technical Standard #10 (`\"Unicode Collation Algorithm\" <http://unicode.org/reports/tr10/>`_) and the default character order is as in the `Default Unicode Collation Element Table (DUCET) <https://www.unicode.org/Public/UCA/8.0.0/allkeys.txt>`_. There are many permanent collations; the commonly used ones include: |br| |nbsp| |nbsp| ``\"none\"`` (not applicable) |br| |nbsp| |nbsp| ``\"unicode\"`` (characters are in DUCET order with strength = 'tertiary') |br| |nbsp| |nbsp| ``\"unicode_ci\"`` (characters are in DUCET order with strength = 'primary') |br| |nbsp| |nbsp| ``\"binary\"`` (characters are in code point order) |br| These identifiers must be quoted and in lower case because they are in lower case in :ref:`Tarantool/NoSQL collations <index-collation>`."
msgstr ""

msgid "If one says ``COLLATE \"binary\"``, this is equivalent to asking for what is sometimes called \"code point order\" because, if the contents are in the UTF-8 character set, characters with larger code points will appear after characters with lower code points."
msgstr ""

msgid "In an expression, ``COLLATE`` is an operator with higher precedence than anything except ``~``. This is fine because there are no other useful operators except ``||`` and comparison. After ``||``, collation is preserved."
msgstr ""

msgid "In an expression with more than one ``COLLATE`` clause, if the collation names differ, there is an error: \"Illegal mix of collations\". In an expression with no ``COLLATE`` clauses, literals have collation ``\"binary\"``, columns have the collation specified by ``CREATE TABLE``."
msgstr ""

msgid "In other words, to pick a collation, we use: |br| the first ``COLLATE`` clause in an expression if it was specified, |br| else the the column's ``COLLATE`` clause if it was specified, |br| else ``\"binary\"``."
msgstr ""

msgid "However, for searches and sometimes for sorting, the collation may be an index's collation, so all non-index ``COLLATE`` clauses are ignored."
msgstr ""

msgid ":ref:`EXPLAIN <sql_explain>` will not show the name of what collation was used, but will show the collation's characteristics."
msgstr ""

msgid "Example with Swedish collation: |br| Knowing that \"sv\" is the two-letter code for Swedish, |br| and knowing that \"s1\" means strength = 1, |br| and seeing with ``PRAGMA collation_list;`` that there is a collation named unicode_sv_s1, |br| check whether two strings are equal according to Swedish rules (yes they are): |br| ``SELECT '' = '' COLLATE \"unicode_sv_s1\";``"
msgstr ""

msgid "Example with Russian and Ukrainian and Kyrgyz collations: |br| Knowing that Russian collation is practically the same as Unicode default, |br| and knowing that the two-letter codes for Ukrainian and Kyrgyz are 'uk' and 'ky', |br| and knowing that in Russian (but not Ukrainian) '' = '' with strength=primary, |br| and knowing that in Russian (but not Kyrgyz) '' = '' with strength=primary, |br| the three SELECT statements here will return results in three different orders: |br| ``CREATE TABLE things (remark STRING PRIMARY KEY);`` |br| ``INSERT INTO things VALUES ('2'), ('1');`` |br| ``INSERT INTO things VALUES ('2'), ('1');`` |br| ``SELECT remark FROM things ORDER BY remark COLLATE \"unicode\";`` |br| ``SELECT remark FROM things ORDER BY remark COLLATE \"unicode_uk_s1\";`` |br| ``SELECT remark FROM things ORDER BY remark COLLATE \"unicode_ky_s1\";``"
msgstr ""

msgid "SQL PLUS LUA -- Adding Tarantool/NoSQL to Tarantool/SQL"
msgstr ""

msgid "The Adding Tarantool/NoSQL To Tarantool/SQL Guide contains descriptions of NoSQL database objects that can be accessed from SQL, of SQL database objects that can be accessed from NoSQL, of the way to call SQL from Lua, and of the way to call Lua from SQL."
msgstr ""

msgid "Lua Requests"
msgstr ""

msgid "A great deal of functionality is not specifically part of Tarantool's SQL feature, but is part of the Tarantool Lua application server and DBMS. Here we will give examples so it is clear where to look in other sections of the Tarantool manual."
msgstr ""

msgid "NoSQL :ref:`\"spaces\" <index-box_space>` can be accessed as SQL ``\"tables\"``, and vice versa. For example, suppose a table has been created with |br| ``CREATE TABLE things (id INTEGER PRIMARY KEY, remark SCALAR);``"
msgstr ""

msgid "This is viewable from Tarantool's NoSQL feature as a memtx space named THINGS with a primary-key :ref:`TREE index <index-box_index>` ..."
msgstr ""

msgid "tarantool> box.space.THINGS\n"
"---\n"
"- engine: memtx\n"
"  before_replace: 'function: 0x40bb4608'\n"
"  on_replace: 'function: 0x40bb45e0'\n"
"  ck_constraint: []\n"
"  field_count: 2\n"
"  temporary: false\n"
"  index:\n"
"    0: &0\n"
"      unique: true\n"
"      parts:\n"
"     - type: integer\n"
"        is_nullable: false\n"
"        fieldno: 1\n"
"      id: 0\n"
"      space_id: 520\n"
"      type: TREE\n"
"      name: pk_unnamed_THINGS_1\n"
"    pk_unnamed_THINGS_1: *0\n"
"  is_local: false\n"
"  enabled: true\n"
"  name: THINGS\n"
"  id: 520"
msgstr ""

msgid "The NoSQL :ref:`basic data operation requests <index-box_data-operations>` select, insert, replace, upsert, update, delete will all work. Particularly interesting are the requests that come only via NoSQL."
msgstr ""

msgid "To create a HASH index on things (remark), say: |br| ``box.space.THINGS:create_index('hash', {type='hash', parts={2, 'scalar'}})``"
msgstr ""

msgid "(If the SQL data type name is SCALAR, then the NoSQL type is 'scalar', as described earlier. See the chart in section :ref:`Operands <sql_operands>`.)"
msgstr ""

msgid "To :ref:`grant <box_schema-user_grant>` database-access privileges to user 'guest', say |br| ``box.schema.user.grant('guest', 'execute', 'universe')`` |br| To grant SELECT privileges on table things to user 'guest', say |br| ``box.schema.user.grant('guest',  'read', 'space', 'THINGS')`` |br| To grant UPDATE privileges on table things to user 'guest', say: |br| ``box.schema.user.grant('guest', 'read,write', 'space', 'THINGS')`` |br| To grant DELETE or INSERT privileges on table things if no reading is involved, say: |br| ``box.schema.user.grant('guest', 'write', 'space', 'THINGS')`` |br| To grant DELETE or INSERT privileges on table things if reading is involved, say: |br| ``box.schema.user.grant('guest',  'read,write',  'space',  'THINGS')`` |br| To grant CREATE TABLE privilege to user 'guest', say |br| ``box.schema.user.grant('guest', 'read,write', 'space', '_schema')`` |br| ``box.schema.user.grant('guest', 'read,write', 'space', '_space')`` |br| ``box.schema.user.grant('guest', 'read,write', 'space', '_index')`` |br| ``box.schema.user.grant('guest', 'create', 'space')`` |br| To grant CREATE TRIGGER privilege to user 'guest', say |br| ``box.schema.user.grant('guest', 'read', 'space', '_space')`` |br| ``box.schema.user.grant('guest', 'read,write', 'space', '_trigger')`` |br| To grant CREATE INDEX privilege to user 'guest', say |br| ``box.schema.user.grant('guest', 'read,write', 'space', '_index')`` |br| ``box.schema.user.grant('guest', 'create', 'space')`` |br| To grant CREATE TABLE ... INTEGER PRIMARY KEY AUTOINCREMENT to user 'guest', say |br| ``box.schema.user.grant('guest', 'read,write', 'space', '_schema')`` |br| ``box.schema.user.grant('guest', 'read,write', 'space', '_space')`` |br| ``box.schema.user.grant('guest', 'read,write', 'space', '_index')`` |br| ``box.schema.user.grant('guest', 'create', 'space')`` |br| ``box.schema.user.grant('guest', 'read,write', 'space', '_space_sequence')`` |br| ``box.schema.user.grant('guest', 'read,write', 'space', '_sequence')`` |br| ``box.schema.user.grant('guest', 'create', 'sequence')`` |br|"
msgstr ""

msgid "To write a stored procedure that inserts 5 rows in things, say |br| ``function f() for i = 3, 7 do box.space.THINGS:insert{i, i} end end`` |br| For client-side API functions, see section :ref:`\"Connectors\" <index-box_connectors>`."
msgstr ""

msgid "To make spaces with field names that SQL can understand, use :ref:`space_object:format() <box_space-format>`. (Exception: in Tarantool/NoSQL it is legal for tuples to have more fields than are described by a format clause, but in Tarantool/SQL such fields will be ignored.)"
msgstr ""

msgid "To handle replication and sharding of SQL data, see section :ref:`Sharding <shard-module>`."
msgstr ""

msgid "To enhance performance of SQL statements by preparing them in advance, see section :ref:`box.prepare() <box-sql_box_prepare>`."
msgstr ""

msgid "To call SQL from Lua, see section :ref:`box.execute([[...]]) <box-sql>`."
msgstr ""

msgid "Limitations: (`Issue#2368 <https://github.com/tarantool/tarantool/issues/2368>`_) |br| * after ``box.schema.user.grant('guest','read,write,execute','universe')``, user ``'guest'`` can create tables. But this is a powerful set of privileges."
msgstr ""

msgid "System Tables"
msgstr ""

msgid "There is a way to get some information about the database objects, for example the names of all the tables and their indexes, using :ref:`SELECT statements <sql_select>`. This is done by looking at special read-only tables which Tarantool updates automatically whenever objects are created or dropped. See the :ref:`submodule box.space <box_space>` overview section. Names of system tables are in lower case so always enclose them in ``\"quotes\"``."
msgstr ""

msgid "For example, the :ref:`_space <box_space-space>` system table has these fields which are seen in SQL as columns: |br| |nbsp|  id = numeric identifier |br| |nbsp|  owner = for example, 1 if the object was made by the ``'admin'`` user |br| |nbsp|  name = the name that was used with CREATE TABLE |br| |nbsp|  engine = usually ``'memtx'`` (the ``'vinyl'`` engine can be used but is not default) |br| |nbsp|  field_count = sometimes 0, but usually a count of the table's columns |br| |nbsp|  flags = usually empty |br| |nbsp|  format = what a Lua format() function or an SQL CREATE statement produced |br| Example selection: |br| |nbsp|  ``SELECT \"id\", \"name\" FROM \"_space\";``"
msgstr ""

msgid "See also: :ref:`Lua functions to make views of metadata <sql_lua_functions>`."
msgstr ""

msgid "Calling Lua routines from SQL"
msgstr ""

msgid "SQL statements can invoke functions that are written in Lua. This is Tarantool's equivalent for the \"stored procedure\" feature found in other SQL DBMSs. Tarantool server-side stored procedures are written in Lua rather than SQL/PSM dialect."
msgstr ""

msgid "Functions can be invoked anywhere that the SQL syntax allows a literal or a column name for reading. Function parameters can include any number of SQL values. If a SELECT statement's result list has a million rows, and the select list invokes a non-deterministic function, then the function is called a million times."
msgstr ""

msgid "To create a Lua function that you can call from SQL, use :ref:`box.schema.func.create(func-name, {options-with-body}) <box_schema-func_create_with-body>` with these additional options:"
msgstr ""

msgid "``exports = {'LUA', 'SQL'}`` -- This indicates what languages can call the function. The default is ``'LUA'``. Specify both: ``'LUA', 'SQL'``."
msgstr ""

msgid "``param_list = {list}`` -- This is the list of parameters. Specify the Lua type names for each parameter of the function. Remember that a Lua type name is :ref:`the same as <sql_operands>` an SQL data type name, in lower case. The Lua type should not be an array."
msgstr ""

msgid "Also it is good to specify ``{deterministic = true}`` if possible, because that may allow Tarantool to generate more efficient SQL byte code."
msgstr ""

msgid "For a useful example, here is a general function for decoding a single Lua ``'map'`` field:"
msgstr ""

msgid "box.schema.func.create('_DECODE',\n"
"   {language = 'LUA',\n"
"    returns = 'string',\n"
"    body = [[function (field, part)\n"
"             __GLOBAL= field\n"
"             return dostring(\"return require('msgpack').decode(__GLOBAL,1).\" .. part)\n"
"             end]],\n"
"    is_sandboxed = false,\n"
"    param_list = {'string', \"string\"},\n"
"    exports = {'LUA', 'SQL'},\n"
"    is_deterministic = true})"
msgstr ""

msgid "See it work with, say, the _trigger space. That space has a ``'map'`` field named opts which has a part named sql. By selecting from the space and passing the field and the part name to _DECODE, you can get a list of all the trigger bodies."
msgstr ""

msgid "__GLOBAL = \"\"\n"
"box.execute([[SELECT _decode(\"opts\", 'sql') FROM \"_trigger\";]])"
msgstr ""

msgid "Remember that SQL converts :ref:`regular identifiers <sql_identifiers>` to upper case, so this example works with a function named _DECODE. If the function had been named _decode, then the SELECT statement would have to be: |br| ``box.execute([[SELECT \"_decode\"(\"opts\", 'sql') FROM \"_trigger\";]])``"
msgstr ""

msgid "Here is another example, which illustrates the way that Tarantool creates a view which includes the table_name and table_type columns in the same way that the standard-SQL information_schema.tables view contains them. The difficulty is that, in order to discover whether table_type should be ``'BASE TABLE'`` or should be ``'VIEW'``, we need to know the value of the ``\"flags\"`` field in the Tarantool/NoSQL :ref:`\"_space\" <box_space-space>` or ``\"_vspace\"`` space. The ``\"flags\"`` field type is ``\"map\"``, which SQL does not understand well. If there were no Lua functions, we would have to treat it as a VARBINARY and look for ``POSITION(X'A476696577C3',\"flags\")  > 0`` (A4 is a MsgPack signal that a 4-byte string follows, 76696577 is UTF8 encoding for 'view', C3 is a MsgPack code meaning true). But we have a more sophisticated way, we can create a function that returns true if ``\"flags\".view`` is true. So our way of making the function looks like this:"
msgstr ""

msgid "box.schema.func.create('TABLES_IS_VIEW',\n"
"     {language = 'LUA',\n"
"      returns = 'boolean',\n"
"      body = [[function (flags)\n"
"          local view\n"
"          view = require('msgpack').decode(flags).view\n"
"          if view == nil then return false end\n"
"          return view\n"
"          end]],\n"
"     is_sandboxed = false,\n"
"     param_list = {'string'},\n"
"     exports = {'LUA', 'SQL'},\n"
"     is_deterministic = true})"
msgstr ""

msgid "And this creates the view:"
msgstr ""

msgid "box.execute([[\n"
"CREATE VIEW vtables AS SELECT\n"
"\"name\" AS table_name,\n"
"CASE WHEN tables_is_view(\"flags\") == TRUE THEN 'VIEW'\n"
"     ELSE 'BASE TABLE' END AS table_type,\n"
"\"id\" AS id,\n"
"\"engine\" AS engine,\n"
"(SELECT \"name\" FROM \"_vuser\" x\n"
" WHERE x.\"id\" = y.\"owner\") AS owner,\n"
"\"field_count\" AS field_count\n"
"FROM \"_vspace\" y;\n"
"]])"
msgstr ""

msgid "Remember that these Lua functions are persistent, so if the server has to be restarted then they do not have to be re-declared."
msgstr ""

msgid "Executing Lua chunks"
msgstr ""

msgid "To execute Lua code without creating a function, use: |br| :samp:`LUA({Lua-code-string})` |br| where Lua-code-string is any amount of Lua code. The string should begin with ``'return '``."
msgstr ""

msgid "For example this will show the number of seconds since the epoch: |br| ``box.execute([[SELECT lua('return os.time()');]])`` |br| For example this will show a database configuration member: |br| ``box.execute([[SELECT lua('return box.cfg.memtx_memory');]])`` For example this will return FALSE because Lua nil and box.NULL are the same as SQL NULL: |br| ``box.execute([[SELECT lua('return box.NULL') IS NOT NULL;]])``"
msgstr ""

msgid "Warning: the SQL statement must not invoke a Lua function, or execute a Lua chunk, that accesses a space that underlies any SQL table that the SQL statement accesses. For example, if function ``f()`` contains a request ``\"box.space.TEST:insert{0}\"``, then the SQL statement ``\"SELECT f() FROM test;\"`` will try to access the same space in two ways. The results of such conflict may include a hang or an infinite loop."
msgstr ""

msgid "Example Session -- Create, Insert, Select"
msgstr ""

msgid "Assume that the task is to create two tables, put some rows in each table, create a :ref:`view <sql_create_view>` that is based on a join of the tables, then select from the view all rows where the second column values are not null, ordered by the first column."
msgstr ""

msgid "That is, what we want is |br| ``CREATE TABLE t1 (c1 INTEGER PRIMARY KEY, c2 STRING);`` |br| ``CREATE TABLE t2 (c1 INTEGER PRIMARY KEY, x2 STRING);`` |br| ``INSERT INTO t1 VALUES (1, 'A'), (2, 'B'), (3, 'C');`` |br| ``INSERT INTO t1 VALUES (4, 'D'), (5, 'E'), (6, 'F');`` |br| ``INSERT INTO t2 VALUES (1, 'C'), (4, 'A'), (6, NULL);`` |br| ``CREATE VIEW v AS SELECT * FROM t1 NATURAL JOIN t2;`` |br| ``SELECT * FROM v WHERE c2 IS NOT NULL ORDER BY c1;``"
msgstr ""

msgid "So the session looks like this: |br| ``box.cfg{}`` |br| ``box.execute([[CREATE TABLE t1 (c1 INTEGER PRIMARY KEY, c2 STRING);]])`` |br| ``box.execute([[CREATE TABLE t2 (c1 INTEGER PRIMARY KEY, x2 STRING);]])`` |br| ``box.execute([[INSERT INTO t1 VALUES (1, 'A'), (2, 'B'), (3, 'C');]])`` |br| ``box.execute([[INSERT INTO t1 VALUES (4, 'D'), (5, 'E'), (6, 'F');]])`` |br| ``box.execute([[INSERT INTO t2 VALUES (1, 'C'), (4, 'A'), (6, NULL);]])`` |br| ``box.execute([[CREATE VIEW v AS SELECT * FROM t1 NATURAL JOIN t2;]])`` |br| ``box.execute([[SELECT * FROM v WHERE c2 IS NOT NULL ORDER BY c1;)]])``"
msgstr ""

msgid "If one executes the above requests with Tarantool as a client, provided the database objects do not already exist, the execution will be successful and the final display will be |br| tarantool> box.execute([[SELECT * FROM v WHERE c2 IS NOT NULL ORDER BY c1;]]) ``---`` |br| ``- - [1, 'A', 'C']`` |br| ``  - [4, 'D', 'A']`` |br| ``  - [6, 'F', null]`` |br|"
msgstr ""

msgid "Example Session -- Get a List of Columns"
msgstr ""

msgid "Here  is a function which will create a table that contains a list of all the columns and their Lua types, for all tables. It is not a necessary function because one can create a :ref:`_COLUMNS view <sql__columns_view>` instead. It merely shows, with simpler Lua code, how to make a base table instead of a view."
msgstr ""

msgid "function create_information_schema_columns()\n"
"  box.execute([[DROP TABLE IF EXISTS information_schema_columns;]])\n"
"  box.execute([[CREATE TABLE information_schema_columns (\n"
"                    table_name STRING,\n"
"                    column_name STRING,\n"
"                    ordinal_position INTEGER,\n"
"                    data_type STRING,\n"
"                    PRIMARY KEY (table_name, column_name));]]);\n"
"  local space = box.space._vspace:select()\n"
"  local sqlstring = ''\n"
"  for i = 1, #space do\n"
"      for j = 1, #space[i][7] do\n"
"          sqlstring = \"INSERT INTO information_schema_columns VALUES (\"\n"
"                  .. \"'\" .. space[i][3] .. \"'\"\n"
"                  .. \",\"\n"
"                  .. \"'\" .. space[i][7][j].name .. \"'\"\n"
"                  .. \",\"\n"
"                  .. j\n"
"                  .. \",\"\n"
"                  .. \"'\" .. space[i][7][j].type .. \"'\"\n"
"                  .. \");\"\n"
"          box.execute(sqlstring)\n"
"      end\n"
"  end\n"
"  return\n"
"end"
msgstr ""

msgid "If you now execute the function by saying |br| ``create_information_schema_columns()`` |br| you will see that there is a table named information_schema_columns containing table_name and column_name and ordinal_position and data_type for everything that was accessible."
msgstr ""

msgid "Example Session -- Million-Row Insert"
msgstr ""

msgid "Here is a variation of the Lua tutorial :ref:`\"Insert one million tuples with a Lua stored procedure\" <c_lua_tutorial-insert_one_million_tuples>`. The differences are: the creation is done with an SQL :ref:`CREATE TABLE statement <sql_create_table>`, and the inserting is done with an SQL :ref:`INSERT statement <sql_insert>`. Otherwise, it is the same. It is the same because Lua and SQL are compatible, just as Lua and NoSQL are compatible."
msgstr ""

msgid "box.execute([[CREATE TABLE tester (s1 INTEGER PRIMARY KEY, s2 STRING);]])\n"
"\n"
"function string_function()\n"
"  local random_number\n"
"  local random_string\n"
"  random_string = \"\"\n"
"  for x = 1,10,1 do\n"
"    random_number = math.random(65, 90)\n"
"    random_string = random_string .. string.char(random_number)\n"
"  end\n"
"  return random_string\n"
"end\n"
"\n"
"function main_function()\n"
"    local string_value, t, sql_statement\n"
"    for i = 1,1000000, 1 do\n"
"    string_value = string_function()\n"
"    sql_statement = \"INSERT INTO tester VALUES (\" .. i .. \",'\" .. string_value .. \"')\"\n"
"    box.execute(sql_statement)\n"
"    end\n"
"end\n"
"start_time = os.clock()\n"
"main_function()\n"
"end_time = os.clock()\n"
"'insert done in ' .. end_time - start_time .. ' seconds'"
msgstr ""

msgid "Limitations: The function takes more time than the original (Tarantool/NoSQL)."
msgstr ""

msgid "Lua functions to make views of metadata"
msgstr ""

msgid "Tarantool does not include all the standard-SQL `information_schema <https://en.wikipedia.org/wiki/information_schema>`_ views, which are for looking at metadata, that is, \"data about the data\". But here is the Lua code and SQL code for creating equivalents: |br| :ref:`_TABLES <sql__tables_view>` nearly equivalent to INFORMATION_SCHEMA.TABLES |br| :ref:`_COLUMNS <sql__columns_view>` nearly equivalent to INFORMATION_SCHEMA.COLUMNS |br| :ref:`_VIEWS <sql__views_view>` nearly equivalent to INFORMATION_SCHEMA.VIEWS |br| :ref:`_TRIGGERS <sql__triggers_view>` nearly equivalent to INFORMATION_SCHEMA.TRIGGERS |br| :ref:`_REFERENTIAL_CONSTRAINTS <sql__referential_constraints_view>` nearly equivalent to INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS |br| :ref:`_CHECK_CONSTRAINTS <sql__check_constraints_view>` nearly equivalent to INFORMATION_SCHEMA.CHECK_CONSTRAINTS |br| :ref:`_TABLE_CONSTRAINTS <sql__table_constraints_view>` nearly equivalent to INFORMATION_SCHEMA.TABLE_CONSTRAINTS. |br| For each view we show an example of a SELECT from the view, and the code. Users who want metadata can simply copy the code. Use this code only with Tarantool version 2.3.0 or later. With an earlier Tarantool version, a :ref:`PRAGMA statement <sql_pragma>` may be useful."
msgstr ""

msgid "_TABLES view"
msgstr ""

msgid "tarantool>SELECT * FROM _tables WHERE id > 340 LIMIT 5;\n"
"OK 5 rows selected (0.0 seconds)\n"
"+---------------+--------------+----------------+------------+-----+--------+-------+-------------+\n"
"| TABLE_CATALOG | TABLE_SCHEMA | TABLE_NAME     | TABLE_TYPE | ID  | ENGINE | OWNER | FIELD_COUNT |\n"
"+---------------+--------------+----------------+------------+-----+--------+-------+-------------+\n"
"| NULL          | NULL         | _fk_constraint | BASE TABLE | 356 | memtx  | admin |        0    |\n"
"| NULL          | NULL         | _ck_constraint | BASE TABLE | 364 | memtx  | admin |        0    |\n"
"| NULL          | NULL         | _func_index    | BASE TABLE | 372 | memtx  | admin |        0    |\n"
"| NULL          | NULL         | _COLUMNS       | VIEW       | 513 | memtx  | admin |        8    |\n"
"| NULL          | NULL         | _VIEWS         | VIEW       | 514 | memtx  | admin |        7    |\n"
"+---------------+--------------+----------------+------------+-----+--------+-------+-------------+"
msgstr ""

msgid "Definition of the function and the CREATE VIEW statement:"
msgstr ""

msgid "box.schema.func.drop('_TABLES_IS_VIEW',{if_exists = true})\n"
"box.schema.func.create('_TABLES_IS_VIEW',\n"
"     {language = 'LUA',\n"
"      returns = 'boolean',\n"
"      body = [[function (flags)\n"
"          local view\n"
"          view = require('msgpack').decode(flags).view\n"
"          if view == nil then return false end\n"
"          return view\n"
"          end]],\n"
"     is_sandboxed = false,\n"
"     param_list = {'string'},\n"
"     exports = {'LUA', 'SQL'},\n"
"     setuid = false,\n"
"     is_deterministic = true})\n"
"box.schema.role.grant('public', 'execute', 'function', '_TABLES_IS_VIEW')\n"
"pcall(function ()\n"
"    box.schema.role.revoke('public', 'read', 'space', '_TABLES', {if_exists = true})\n"
"    end)\n"
"box.execute([[DROP VIEW IF EXISTS _tables;]])\n"
"box.execute([[\n"
"CREATE VIEW _tables AS SELECT\n"
"    CAST(NULL AS STRING) AS table_catalog,\n"
"    CAST(NULL AS STRING) AS table_schema,\n"
"    \"name\" AS table_name,\n"
"    CASE\n"
"        WHEN _tables_is_view(\"flags\") = TRUE THEN 'VIEW'\n"
"        ELSE 'BASE TABLE' END\n"
"        AS table_type,\n"
"    \"id\" AS id,\n"
"    \"engine\" AS engine,\n"
"    (SELECT \"name\" FROM \"_vuser\" x WHERE x.\"id\" = y.\"owner\") AS owner,\n"
"    \"field_count\" AS field_count\n"
"FROM \"_vspace\" y;\n"
"]])\n"
"box.schema.role.grant('public', 'read', 'space', '_TABLES')"
msgstr ""

msgid "_COLUMNS view"
msgstr ""

msgid "This is also an example of how one can use :ref:`recursive views <sql_with>` to make temporary tables with multiple rows for each tuple in the original ``\"_vtable\"`` space. It requires a global variable, _G.box.FORMATS, as a temporary static variable."
msgstr ""

msgid "Warning: Use this code only with Tarantool version 2.3.2 or later. Use with earlier versions will cause an assertion. See `Issue#4504 <https://github.com/tarantool/tarantool/issues/4504>`_."
msgstr ""

msgid "tarantool>SELECT * FROM _columns WHERE ordinal_position = 9;\n"
"OK 6 rows selected (0.0 seconds)\n"
"+--------------+-------------+--------------------------+--------------+------------------+-------------+-----------+-----+\n"
"| CATALOG_NAME | SCHEMA_NAME | TABLE_NAME               | COLUMN_NAME  | ORDINAL_POSITION | IS_NULLABLE | DATA_TYPE | ID  |\n"
"+--------------+-------------+--------------------------+--------------+------------------+-------------+-----------+-----+\n"
"| NULL         | NULL        | _sequence                | cycle        |                9 | YES         | boolean   | 284 |\n"
"| NULL         | NULL        | _vsequence               | cycle        |                9 | YES         | boolean   | 286 |\n"
"| NULL         | NULL        | _func                    | returns      |                9   YES           string    | 296 |\n"
"| NULL         | NULL        | _fk_constraint           | parent_cols  |                9 | YES         | array     | 356 |\n"
"| NULL         | NULL        | _REFERENTIAL_CONSTRAINTS | MATCH_OPTION |                9 | YES         | string    | 518 |\n"
"+--------------+-------------+--------------------------+--------------+------------------+-------------+-----------+-----+"
msgstr ""

msgid "box.schema.func.drop('_COLUMNS_FORMATS', {if_exists = true})\n"
"box.schema.func.create('_COLUMNS_FORMATS',\n"
"    {language = 'LUA',\n"
"     returns = 'string',\n"
"     body = [[\n"
"     function (row_number_, ordinal_position)\n"
"         if row_number_ == 0 then\n"
"             _G.box.FORMATS = {}\n"
"             local vspace = box.space._vspace:select()\n"
"             for i = 1, #vspace do\n"
"                 local format = vspace[i][\"format\"]\n"
"                 for j = 1, #format do\n"
"                     local is_nullable = 'YES'\n"
"                     if format[j].is_nullable == false then\n"
"                         is_nullable = 'NO'\n"
"                     end\n"
"                     table.insert(_G.box.FORMATS,\n"
"                                  {vspace[i].name, format[j].name, j,\n"
"                                   is_nullable, format[j].type, vspace[i].id})\n"
"                 end\n"
"             end\n"
"             return ''\n"
"         end\n"
"         if row_number_ > #_G.box.FORMATS then\n"
"             _G.box.FORMATS = {}\n"
"             return ''\n"
"         end\n"
"         return _G.box.FORMATS[row_number_][ordinal_position]\n"
"     end\n"
"     ]],\n"
"    param_list = {'integer', 'integer'},\n"
"    exports = {'LUA', 'SQL'},\n"
"    is_sandboxed = false,\n"
"    setuid = false,\n"
"    is_deterministic = false})\n"
"box.schema.role.grant('public', 'execute', 'function', '_COLUMNS_FORMATS')\n"
"\n"
"pcall(function ()\n"
"    box.schema.role.revoke('public', 'read', 'space', '_COLUMNS', {if_exists = true})\n"
"    end)\n"
"box.execute([[DROP VIEW IF EXISTS _columns;]])\n"
"box.execute([[\n"
"CREATE VIEW _columns AS\n"
"WITH RECURSIVE r_columns AS\n"
"(\n"
"SELECT 0 AS row_number_,\n"
"      '' AS table_name,\n"
"      '' AS column_name,\n"
"      0 AS ordinal_position,\n"
"      '' AS is_nullable,\n"
"      '' AS data_type,\n"
"      0 AS id\n"
"UNION ALL\n"
"SELECT row_number_ + 1 AS row_number_,\n"
"       _columns_formats(row_number_, 1) AS table_name,\n"
"       _columns_formats(row_number_, 2) AS column_name,\n"
"       _columns_formats(row_number_, 3) AS ordinal_position,\n"
"       _columns_formats(row_number_, 4) AS is_nullable,\n"
"       _columns_formats(row_number_, 5) AS data_type,\n"
"       _columns_formats(row_number_, 6) AS id\n"
"    FROM r_columns\n"
"    WHERE row_number_ == 0 OR row_number_ <= lua('return #_G.box.FORMATS + 1')\n"
")\n"
"SELECT CAST(NULL AS STRING) AS catalog_name,\n"
"       CAST(NULL AS STRING) AS schema_name,\n"
"       table_name,\n"
"       column_name,\n"
"       ordinal_position,\n"
"       is_nullable,\n"
"       data_type,\n"
"       id\n"
"    FROM r_columns\n"
"    WHERE data_type <> '';\n"
"]])\n"
"box.schema.role.grant('public', 'read', 'space', '_COLUMNS')"
msgstr ""

msgid "_VIEWS view"
msgstr ""

msgid "tarantool>SELECT table_name, substr(view_definition,1,20), id, owner, field_count FROM _views LIMIT 5;\n"
"OK 5 rows selected (0.0 seconds)\n"
"+--------------------------+------------------------------+-----+-------+-------------+\n"
"| TABLE_NAME               | SUBSTR(VIEW_DEFINITION,1,20) | ID  | OWNER | FIELD_COUNT |\n"
"+--------------------------+------------------------------+-----+-------+-------------+\n"
"| _COLUMNS                 | CREATE VIEW _columns         | 513 | admin |           8 |\n"
"| _TRIGGERS                | CREATE VIEW _trigger         | 515 | admin |           4 |\n"
"| _CHECK_CONSTRAINTS       | CREATE VIEW _check_c         | 517 | admin |           8 |\n"
"| _REFERENTIAL_CONSTRAINTS | CREATE VIEW _referen         | 518 | admin |          12 |\n"
"| _TABLE_CONSTRAINTS       | CREATE VIEW _table_c         | 519 | admin |          11 |\n"
"+--------------------------+------------------------------+-----+-------+-------------+"
msgstr ""

msgid "box.schema.func.drop('_VIEWS_DEFINITION',{if_exists = true})\n"
"box.schema.func.create('_VIEWS_DEFINITION',\n"
"    {language = 'LUA',\n"
"     returns = 'string',\n"
"     body = [[function (flags)\n"
"                  return require('msgpack').decode(flags).sql end]],\n"
"     param_list = {'string'},\n"
"     exports = {'LUA', 'SQL'},\n"
"     is_sandboxed = false,\n"
"     setuid = false,\n"
"     is_deterministic = false})\n"
"box.schema.role.grant('public', 'execute', 'function', '_VIEWS_DEFINITION')\n"
"pcall(function ()\n"
"    box.schema.role.revoke('public', 'read', 'space', '_VIEWS', {if_exists = true})\n"
"    end)\n"
"box.execute([[DROP VIEW IF EXISTS _views;]])\n"
"box.execute([[\n"
"CREATE VIEW _views AS SELECT\n"
"    CAST(NULL AS STRING) AS table_catalog,\n"
"    CAST(NULL AS STRING) AS table_schema,\n"
"    \"name\" AS table_name,\n"
"    CAST(_views_definition(\"flags\") AS STRING) AS VIEW_DEFINITION,\n"
"    \"id\" AS id,\n"
"    (SELECT \"name\" FROM \"_vuser\" x WHERE x.\"id\" = y.\"owner\") AS owner,\n"
"    \"field_count\" AS field_count\n"
"    FROM \"_vspace\" y\n"
"    WHERE _tables_is_view(\"flags\") = TRUE;\n"
"]])\n"
"box.schema.role.grant('public', 'read', 'space', '_VIEWS')"
msgstr ""

msgid "_TABLES_IS_VIEW() was described earlier, see :ref:`_TABLES view <sql__tables_view>`."
msgstr ""

msgid "_TRIGGERS view"
msgstr ""

msgid "tarantool>SELECT trigger_name, opts_sql FROM _triggers;\n"
"OK 2 rows selected (0.0 seconds)\n"
"+--------------+-------------------------------------------------------------------------------------------------+\n"
"| TRIGGER_NAME | OPTS_SQL                                                                                        |\n"
"+--------------+-------------------------------------------------------------------------------------------------+\n"
"| THINGS1_AD   | CREATE TRIGGER things1_ad AFTER DELETE ON things1 FOR EACH ROW BEGIN DELETE FROM things2; END;  |\n"
"| THINGS1_BI   | CREATE TRIGGER things1_bi BEFORE INSERT ON things1 FOR EACH ROW BEGIN DELETE FROM things2; END; |\n"
"+--------------+-------------------------------------------------------------------------------------------------+"
msgstr ""

msgid "box.schema.func.drop('_TRIGGERS_OPTS_SQL',{if_exists = true})\n"
"box.schema.func.create('_TRIGGERS_OPTS_SQL',\n"
"    {language = 'LUA',\n"
"     returns = 'string',\n"
"     body = [[function (opts)\n"
"                  return require('msgpack').decode(opts).sql end]],\n"
"     param_list = {'string'},\n"
"     exports = {'LUA', 'SQL'},\n"
"     is_sandboxed = false,\n"
"     setuid = false,\n"
"     is_deterministic = false})\n"
"box.schema.role.grant('public', 'execute', 'function', '_TRIGGERS_OPTS_SQL')\n"
"pcall(function ()\n"
"    box.schema.role.revoke('public', 'read', 'space', '_TRIGGERS', {if_exists = true})\n"
"    end)\n"
"box.execute([[DROP VIEW IF EXISTS _triggers;]])\n"
"box.execute([[\n"
"CREATE VIEW _triggers AS SELECT\n"
"    CAST(NULL AS STRING) AS trigger_catalog,\n"
"    CAST(NULL AS STRING) AS trigger_schema,\n"
"    \"name\" AS trigger_name,\n"
"    CAST(_triggers_opts_sql(\"opts\") AS STRING) AS opts_sql,\n"
"    \"space_id\" AS space_id\n"
"    FROM \"_trigger\";\n"
"]])\n"
"box.schema.role.grant('public', 'read', 'space', '_TRIGGERS')"
msgstr ""

msgid "Users who select from this view will need 'read' privilege on the _trigger space."
msgstr ""

msgid "_REFERENTIAL_CONSTRAINTS view"
msgstr ""

msgid "tarantool>SELECT constraint_name, update_rule, delete_rule, match_option,\n"
"> referencing, referenced\n"
"> FROM _referential_constraints;\n"
"OK 2 rows selected (0.0 seconds)\n"
"+----------------------+-------------+-------------+--------------+-------------+------------+\n"
"| CONSTRAINT_NAME      | UPDATE_RULE | DELETE_RULE | MATCH_OPTION | REFERENCING | REFERENCED |\n"
"+----------------------+-------------+-------------+--------------+-------------+------------+\n"
"| fk_unnamed_THINGS2_1 | no_action   | no_action   | simple       | THINGS2     | THINGS1    |\n"
"| fk_unnamed_THINGS3_1 | no_action   | no_action   | simple       | THINGS3     | THINGS1    |\n"
"+----------------------+-------------+-------------+--------------+-------------+------------+"
msgstr ""

msgid "Definition of the CREATE VIEW statement:"
msgstr ""

msgid "pcall(function ()\n"
"    box.schema.role.revoke('public', 'read', 'space', '_REFERENTIAL_CONSTRAINTS', {if_exists = true})\n"
"    end)\n"
"box.execute([[DROP VIEW IF EXISTS _referential_constraints;]])\n"
"box.execute([[\n"
"CREATE VIEW _referential_constraints AS SELECT\n"
"    CAST(NULL AS STRING) AS constraint_catalog,\n"
"    CAST(NULL AS STRING) AS constraint_schema,\n"
"    \"name\" AS constraint_name,\n"
"    CAST(NULL AS STRING) AS unique_constraint_catalog,\n"
"    CAST(NULL AS STRING) AS unique_constraint_schema,\n"
"    '' AS unique_constraint_name,\n"
"    \"on_update\" AS update_rule,\n"
"    \"on_delete\" AS delete_rule,\n"
"    \"match\" AS match_option,\n"
"    (SELECT \"name\" FROM \"_vspace\" x WHERE x.\"id\" = y.\"child_id\") AS referencing,\n"
"    (SELECT \"name\" FROM \"_vspace\" x WHERE x.\"id\" = y.\"parent_id\") AS referenced,\n"
"    \"is_deferred\" AS is_deferred,\n"
"    \"child_id\" AS child_id,\n"
"    \"parent_id\" AS parent_id\n"
"    FROM \"_fk_constraint\" y;\n"
"]])\n"
"box.schema.role.grant('public', 'read', 'space', '_REFERENTIAL_CONSTRAINTS')"
msgstr ""

msgid "We are not taking child_cols or parent_cols from the _fk_constraint space because in standard SQL those are in a separate table."
msgstr ""

msgid "Users who select from this view will need 'read' privilege on the _fk_constraint space."
msgstr ""

msgid "_CHECK_CONSTRAINTS view"
msgstr ""

msgid "tarantool>SELECT constraint_name, check_clause, space_name, language\n"
"> FROM _check_constraints;\n"
"OK 3 rows selected (0.0 seconds)\n"
"+------------------------+-------------------------+------------+----------+\n"
"| CONSTRAINT_NAME        | CHECK_CLAUSE            | SPACE_NAME | LANGUAGE |\n"
"+------------------------+-------------------------+------------+----------+\n"
"| ck_unnamed_Employees_1 | first_name LIKE '%' | Employees  | SQL      |\n"
"| ck_unnamed_Critics_1   | first_name LIKE 'Vlad%' | Critics    | SQL      |\n"
"| ck_unnamed_ACTORS_1    | salary > 0              | ACTORS     | SQL      |\n"
"+------------------------+-------------------------+------------+----------+"
msgstr ""

msgid "pcall(function ()\n"
"    box.schema.role.revoke('public', 'read', 'space', '_CHECK_CONSTRAINTS', {if_exists = true})\n"
"    end)\n"
"box.execute([[DROP VIEW IF EXISTS _check_constraints;]])\n"
"box.execute([[\n"
"CREATE VIEW _check_constraints AS SELECT\n"
"    CAST(NULL AS STRING) AS constraint_catalog,\n"
"    CAST(NULL AS STRING) AS constraint_schema,\n"
"    \"name\" AS constraint_name,\n"
"    \"code\" AS check_clause,\n"
"    (SELECT \"name\" FROM \"_vspace\" x WHERE x.\"id\" = y.\"space_id\") AS space_name,\n"
"    \"language\" AS language,\n"
"    \"is_deferred\" AS is_deferred,\n"
"    \"space_id\" AS space_id\n"
"    FROM \"_ck_constraint\" y;\n"
"]])\n"
"box.schema.role.grant('public', 'read', 'space', '_CHECK_CONSTRAINTS')"
msgstr ""

msgid "Users who select from this view will need 'read' privilege on the _ck_constraint space."
msgstr ""

msgid "_TABLE_CONSTRAINTS view"
msgstr ""

msgid "This has only the constraints (primary-key and unique-key) that can be found by looking at the :ref:`_index <box_space-index>` space. It is not a list of indexes, that is, it is not equivalent to INFORMATION_SCHEMA.STATISTICS. We do not take the columns of the index because in standard SQL they would be in a different table."
msgstr ""

msgid "tarantool>SELECT constraint_name, constraint_type, table_name, id, iid, index_type\n"
"> FROM _table_constraints\n"
"> LIMIT 5;\n"
"OK 5 rows selected (0.0 seconds)\n"
"+-----------------+-----------------+-------------+-----+-----+------------+\n"
"| CONSTRAINT_NAME | CONSTRAINT_TYPE | TABLE_NAME  | ID  | IID | INDEX_TYPE |\n"
"+-----------------+-----------------+-------------+-----+-----+------------+\n"
"| primary         | PRIMARY         | _schema     | 272 |   0 | tree       |\n"
"| primary         | PRIMARY         | _collation  | 276 |   0 | tree       |\n"
"| name            | UNIQUE          | _collation  | 276 |   1 | tree       |\n"
"| primary         | PRIMARY         | _vcollation | 277 |   0 | tree       |\n"
"| name            | UNIQUE          | _vcollation | 277 |   1 | tree       |\n"
"+-----------------+-----------------+-------------+-----+-----+------------+"
msgstr ""

msgid "box.schema.func.drop('_TABLE_CONSTRAINTS_OPTS_UNIQUE',{if_exists = true})\n"
"function _TABLE_CONSTRAINTS_OPTS_UNIQUE (opts) return require('msgpack').decode(opts).unique end\n"
"box.schema.func.create('_TABLE_CONSTRAINTS_OPTS_UNIQUE',\n"
"    {language = 'LUA',\n"
"     returns = 'boolean',\n"
"     body = [[function (opts) return require('msgpack').decode(opts).unique end]],\n"
"     param_list = {'string'},\n"
"     exports = {'LUA', 'SQL'},\n"
"     is_sandboxed = false,\n"
"     setuid = false,\n"
"     is_deterministic = false})\n"
"box.schema.role.grant('public', 'execute', 'function', '_TABLE_CONSTRAINTS_OPTS_UNIQUE')\n"
"pcall(function ()\n"
"box.schema.role.revoke('public', 'read', 'space', '_TABLE_CONSTRAINTS', {if_exists = true})\n"
"end)\n"
"box.execute([[DROP VIEW IF EXISTS _table_constraints;]])\n"
"box.execute([[\n"
"CREATE VIEW _table_constraints AS SELECT\n"
"CAST(NULL AS STRING) AS constraint_catalog,\n"
"CAST(NULL AS STRING) AS constraint_schema,\n"
"\"name\" AS constraint_name,\n"
"(SELECT \"name\" FROM \"_vspace\" x WHERE x.\"id\" = y.\"id\") AS table_name,\n"
"CASE WHEN \"iid\" = 0 THEN 'PRIMARY' ELSE 'UNIQUE' END AS constraint_type,\n"
"CAST(NULL AS STRING) AS initially_deferrable,\n"
"CAST(NULL AS STRING) AS deferred,\n"
"CAST(NULL AS STRING) AS enforced,\n"
"\"id\" AS id,\n"
"\"iid\" AS iid,\n"
"\"type\" AS index_type\n"
"FROM \"_vindex\" y\n"
"WHERE _table_constraints_opts_unique(\"opts\") = TRUE;\n"
"]])\n"
"box.schema.role.grant('public', 'read', 'space', '_TABLE_CONSTRAINTS')"
msgstr ""

