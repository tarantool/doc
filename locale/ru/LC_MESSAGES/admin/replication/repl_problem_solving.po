
msgid "Resolving replication conflicts"
msgstr "Решение конфликтов репликации"

msgid "Solving problems with master-master replication"
msgstr "Устранение конфликтов репликации мастер-мастер"

msgid ""
"Tarantool guarantees that every update is applied only once on every "
"replica. However, due to the asynchronous nature of replication, the order "
"of updates is not guaranteed. We now analyze this problem with more details,"
" provide examples of replication going out of sync, and suggest solutions."
msgstr ""
"Tarantool гарантирует, что все обновления применяются однократно на каждой "
"реплике. Однако, поскольку репликация носит асинхронный характер, порядок "
"обновлений не гарантируется. Сейчас мы проанализируем данную проблему более "
"подробно с примерами рассинхронизации репликации и предложим соответствующие"
" решения."

msgid "Replacing the same primary key"
msgstr "Замена по одному и тому же первичному ключу"

msgid ""
"**Case 1:** You have two instances of Tarantool. For example, you try to "
"make a ``replace`` operation with the same primary key on both instances in "
"the same time. This will cause a conflict over which tuple to save and which"
" one to discard."
msgstr ""
"**Кейс 1:** у вас есть два экземпляра Тарантула. Например, вы пытаетесь "
"сделать операцию замены одного и того же первичного ключа на обоих "
"экземплярах одновременно. Случится конфликт из-за того, какой кортеж "
"сохранить, а какой отбросить."

msgid ""
"Tarantool :ref:`trigger functions <triggers>` can help here to implement the"
" rules of conflict resolution on some condition. For example, if you have a "
"timestamp, you can declare saving the tuple with the bigger one."
msgstr ""
":ref:`Триггер-функции <triggers>` Тарантула могут помочь в реализации правил"
" разрешения конфликтов при определенных условиях. Например, если у вас есть "
"метка времени, то можно указать, что сохранять нужно кортеж с большей "
"меткой."

msgid ""
"First, you need a :ref:`before_replace() <box_space-before_replace>` trigger"
" on the space which may have conflicts. In this trigger you can compare the "
"old and new replica records and choose which one to use (or skip the update "
"entirely, or merge two records together)."
msgstr ""
"Во-первых, вам нужно повесить триггер :ref:`before_replace() <box_space-"
"before_replace>` на спейс, в котором могут быть конфликты. В этом триггере "
"вы можете сравнить старую и новую записи реплики и выбрать, какую из них "
"использовать (или полностью пропустить обновление, или объединить две записи"
" вместе)."

msgid ""
"Then you need to set the trigger at the right time, before the space starts "
"to receive any updates. The way you usually set the ``before_replace`` "
"trigger is right when the space is created, so you need a trigger to set "
"another trigger on the system space ``_space``, to capture the moment when "
"your space is created and set the trigger there. This can be an "
":ref:`on_replace() <box_space-on_replace>` trigger."
msgstr ""
"Затем вам нужно установить триггер в нужное время, прежде чем спейс начнет "
"получать обновления. Триггер ``before_replace`` нужно устанавливать в тот "
"момент, когда спейс создается, поэтому еще нужен триггер, чтобы установить "
"другой триггер на системном спейсе ``_space``, чтобы поймать момент, когда "
"ваш спейс создается, и установить триггер там. Для этого подходит триггер "
":ref:`on_replace() <box_space-on_replace>`."

msgid ""
"The difference between ``before_replace`` and ``on_replace`` is that "
"``on_replace`` is called after a row is inserted into the space, and "
"``before_replace`` is called before that."
msgstr ""
"Разница между ``before_replace`` и ``on_replace`` заключается в том, что "
"``on_replace`` вызывается после вставки строки в спейс, а ``before_replace``"
" вызывается перед ней."

msgid ""
"To set a ``_space:on_replace()`` trigger correctly, you also need the right "
"timing. The best timing to use it is when ``_space`` is just created, which "
"is the :ref:`box.ctl.on_schema_init() <box_ctl-on_schema_init>` trigger."
msgstr ""
"Устанавливать триггер ``_space:on_replace()`` также нужно в определенный "
"момент. Лучшее время для его использования -- это когда только что создан "
"``_space``, что является триггером на :ref:`box.ctl.on_schema_init() "
"<box_ctl-on_schema_init>`."

msgid ""
"You will also need to utilize ``box.on_commit`` to get access to the space "
"being created. The resulting snippet would be the following:"
msgstr ""
"Вам также нужно использовать ``box.on_commit``, чтобы получить доступ к "
"создаваемому спейсу. В результате код будет выглядеть следующим образом:"

msgid ""
"local my_space_name = 'my_space'\n"
"local my_trigger = function(old, new) ... end -- your function resolving a conflict\n"
"box.ctl.on_schema_init(function()\n"
"    box.space._space:on_replace(function(old_space, new_space)\n"
"        if not old_space and new_space and new_space.name == my_space_name then\n"
"            box.on_commit(function()\n"
"                box.space[my_space_name]:before_replace(my_trigger)\n"
"            end\n"
"        end\n"
"    end)\n"
"end)"
msgstr ""
"local my_space_name = 'my_space'\n"
"local my_trigger = function(old, new) ... end -- ваша функция, устраняющая конфликт\n"
"box.ctl.on_schema_init(function()\n"
"    box.space._space:on_replace(function(old_space, new_space)\n"
"        if not old_space and new_space and new_space.name == my_space_name then\n"
"            box.on_commit(function()\n"
"                box.space[my_space_name]:before_replace(my_trigger)\n"
"            end\n"
"        end\n"
"    end)\n"
"end)"

msgid "Preventing duplicate insert"
msgstr "Предотвращение дублирующей вставки"

msgid ""
"**Case 2:** In a replica set of two masters, suppose master #1 tries to "
"``insert`` a tuple with the same unique key:"
msgstr ""
"**Кейс 2:** Предположим, что в наборе реплик с двумя мастерами мастер №1 "
"пытается вставить кортеж с одинаковым уникальным ключом:"

msgid "tarantool> box.space.tester:insert{1, 'data'}"
msgstr "tarantool> box.space.tester:insert{1, 'data'}"

msgid ""
"This would cause an error saying ``Duplicate key exists in unique index "
"'primary' in space 'tester'`` and the replication would be stopped. (This is"
" the behavior when the :ref:`replication_skip_conflict <cfg_replication-"
"replication_skip_conflict>` configuration parameter has its default "
"recommended value, ``false``.)"
msgstr ""
"Это вызовет сообщение об ошибке дубликата ключа (``Duplicate key exists in "
"unique index 'primary' in space 'tester'``), и репликация остановится. Такое"
" поведение системы обеспечивается использованием рекомендуемого значения "
"``false`` (по умолчанию) для конфигурационного параметра "
":ref:`replication_skip_conflict <cfg_replication-"
"replication_skip_conflict>`."

msgid ""
"$ # error messages from master #1\n"
"2017-06-26 21:17:03.233 [30444] main/104/applier/rep_user@100.96.166.1 I> can't read row\n"
"2017-06-26 21:17:03.233 [30444] main/104/applier/rep_user@100.96.166.1 memtx_hash.cc:226 E> ER_TUPLE_FOUND:\n"
"Duplicate key exists in unique index 'primary' in space 'tester'\n"
"2017-06-26 21:17:03.233 [30444] relay/[::ffff:100.96.166.178]/101/main I> the replica has closed its socket, exiting\n"
"2017-06-26 21:17:03.233 [30444] relay/[::ffff:100.96.166.178]/101/main C> exiting the relay loop\n"
"\n"
"$ # error messages from master #2\n"
"2017-06-26 21:17:03.233 [30445] main/104/applier/rep_user@100.96.166.1 I> can't read row\n"
"2017-06-26 21:17:03.233 [30445] main/104/applier/rep_user@100.96.166.1 memtx_hash.cc:226 E> ER_TUPLE_FOUND:\n"
"Duplicate key exists in unique index 'primary' in space 'tester'\n"
"2017-06-26 21:17:03.234 [30445] relay/[::ffff:100.96.166.178]/101/main I> the replica has closed its socket, exiting\n"
"2017-06-26 21:17:03.234 [30445] relay/[::ffff:100.96.166.178]/101/main C> exiting the relay loop"
msgstr ""
"$ # сообщения об ошибках от мастера №1\n"
"2017-06-26 21:17:03.233 [30444] main/104/applier/rep_user@100.96.166.1 I> can't read row\n"
"2017-06-26 21:17:03.233 [30444] main/104/applier/rep_user@100.96.166.1 memtx_hash.cc:226 E> ER_TUPLE_FOUND:\n"
"Duplicate key exists in unique index 'primary' in space 'tester'\n"
"2017-06-26 21:17:03.233 [30444] relay/[::ffff:100.96.166.178]/101/main I> the replica has closed its socket, exiting\n"
"2017-06-26 21:17:03.233 [30444] relay/[::ffff:100.96.166.178]/101/main C> exiting the relay loop\n"
"\n"
"$ # сообщения об ошибках от мастера №2\n"
"2017-06-26 21:17:03.233 [30445] main/104/applier/rep_user@100.96.166.1 I> can't read row\n"
"2017-06-26 21:17:03.233 [30445] main/104/applier/rep_user@100.96.166.1 memtx_hash.cc:226 E> ER_TUPLE_FOUND:\n"
"Duplicate key exists in unique index 'primary' in space 'tester'\n"
"2017-06-26 21:17:03.234 [30445] relay/[::ffff:100.96.166.178]/101/main I> the replica has closed its socket, exiting\n"
"2017-06-26 21:17:03.234 [30445] relay/[::ffff:100.96.166.178]/101/main C> exiting the relay loop"

msgid ""
"If we check replication statuses with ``box.info``, we will see that "
"replication at master #1 is stopped (``1.upstream.status = stopped``). "
"Additionally, no data is replicated from that master (section "
"``1.downstream`` is missing in the report), because the downstream has "
"encountered the same error:"
msgstr ""
"Если мы проверим статус репликации с помощью ``box.info``, то увидим, что "
"репликация на мастере №1 остановлена (``1.upstream.status = stopped``). "
"Кроме того, данные с этого мастера не реплицируются (группа ``1.downstream``"
" отсутствует в отчете), поскольку встречается та же ошибка:"

msgid ""
"# replication statuses (report from master #3)\n"
"tarantool> box.info\n"
"---\n"
"- version: 1.7.4-52-g980d30092\n"
"  id: 3\n"
"  ro: false\n"
"  vclock: {1: 9, 2: 1000000, 3: 3}\n"
"  uptime: 557\n"
"  lsn: 3\n"
"  vinyl: []\n"
"  cluster:\n"
"    uuid: 34d13b1a-f851-45bb-8f57-57489d3b3c8b\n"
"  pid: 30445\n"
"  status: running\n"
"  signature: 1000012\n"
"  replication:\n"
"    1:\n"
"      id: 1\n"
"      uuid: 7ab6dee7-dc0f-4477-af2b-0e63452573cf\n"
"      lsn: 9\n"
"      upstream:\n"
"        peer: replicator@192.168.0.101:3301\n"
"        lag: 0.00050592422485352\n"
"        status: stopped\n"
"        idle: 445.8626639843\n"
"        message: Duplicate key exists in unique index 'primary' in space 'tester'\n"
"    2:\n"
"      id: 2\n"
"      uuid: 9afbe2d9-db84-4d05-9a7b-e0cbbf861e28\n"
"      lsn: 1000000\n"
"      upstream:\n"
"        status: follow\n"
"        idle: 201.99915885925\n"
"        peer: replicator@192.168.0.102:3301\n"
"        lag: 0.0015020370483398\n"
"      downstream:\n"
"        vclock: {1: 8, 2: 1000000, 3: 3}\n"
"    3:\n"
"      id: 3\n"
"      uuid: e826a667-eed7-48d5-a290-64299b159571\n"
"      lsn: 3\n"
"  uuid: e826a667-eed7-48d5-a290-64299b159571\n"
"..."
msgstr ""
"# статусы репликации (отчет от мастера №3)\n"
"tarantool> box.info\n"
"---\n"
"- version: 1.7.4-52-g980d30092\n"
"  id: 3\n"
"  ro: false\n"
"  vclock: {1: 9, 2: 1000000, 3: 3}\n"
"  uptime: 557\n"
"  lsn: 3\n"
"  vinyl: []\n"
"  cluster:\n"
"    uuid: 34d13b1a-f851-45bb-8f57-57489d3b3c8b\n"
"  pid: 30445\n"
"  status: running\n"
"  signature: 1000012\n"
"  replication:\n"
"    1:\n"
"      id: 1\n"
"      uuid: 7ab6dee7-dc0f-4477-af2b-0e63452573cf\n"
"      lsn: 9\n"
"      upstream:\n"
"        peer: replicator@192.168.0.101:3301\n"
"        lag: 0.00050592422485352\n"
"        status: stopped\n"
"        idle: 445.8626639843\n"
"        message: Duplicate key exists in unique index 'primary' in space 'tester'\n"
"    2:\n"
"      id: 2\n"
"      uuid: 9afbe2d9-db84-4d05-9a7b-e0cbbf861e28\n"
"      lsn: 1000000\n"
"      upstream:\n"
"        status: follow\n"
"        idle: 201.99915885925\n"
"        peer: replicator@192.168.0.102:3301\n"
"        lag: 0.0015020370483398\n"
"      downstream:\n"
"        vclock: {1: 8, 2: 1000000, 3: 3}\n"
"    3:\n"
"      id: 3\n"
"      uuid: e826a667-eed7-48d5-a290-64299b159571\n"
"      lsn: 3\n"
"  uuid: e826a667-eed7-48d5-a290-64299b159571\n"
"..."

msgid "When replication is later manually resumed:"
msgstr "Когда позднее репликация возобновлена вручную:"

msgid ""
"# resuming stopped replication (at all masters)\n"
"tarantool> original_value = box.cfg.replication\n"
"tarantool> box.cfg{replication={}}\n"
"tarantool> box.cfg{replication=original_value}"
msgstr ""
"# возобновление остановленной репликации (на всех мастерах)\n"
"tarantool> original_value = box.cfg.replication\n"
"tarantool> box.cfg{replication={}}\n"
"tarantool> box.cfg{replication=original_value}"

msgid "... the faulty row in the write-ahead-log files is skipped."
msgstr "... запись с ошибкой в журнале упреждающей записи пропущена."

msgid "**Solution #1: replication runs out of sync**"
msgstr "**Решение #1: рассинхронизация репликации**"

msgid ""
"In a master-master cluster of two instances, suppose we make the following "
"operation:"
msgstr ""
"Предположим, что мы выполняем следующую операцию в кластере из двух "
"экземпляров с конфигурацией мастер-мастер:"

msgid "tarantool> box.space.tester:upsert({1}, {{'=', 2, box.info.uuid}})"
msgstr "tarantool> box.space.tester:upsert({1}, {{'=', 2, box.info.uuid}})"

msgid "When this operation is applied on both instances in the replica set:"
msgstr "Когда эта операция применяется на обоих экземплярах в наборе реплик:"

msgid ""
"# at master #1\n"
"tarantool> box.space.tester:upsert({1}, {{'=', 2, box.info.uuid}})\n"
"# at master #2\n"
"tarantool> box.space.tester:upsert({1}, {{'=', 2, box.info.uuid}})"
msgstr ""
"# на мастере #1\n"
"tarantool> box.space.tester:upsert({1}, {{'=', 2, box.info.uuid}})\n"
"# на мастере #2\n"
"tarantool> box.space.tester:upsert({1}, {{'=', 2, box.info.uuid}})"

msgid ""
"... we can have the following results, depending on the order of execution:"
msgstr ""
"... можно получить следующие результаты в зависимости от порядка выполнения:"

msgid "each master’s row contains the UUID from master #1,"
msgstr "каждая строка мастера содержит UUID из мастера №1,"

msgid "each master’s row contains the UUID from master #2,"
msgstr "каждая строка мастера содержит UUID из мастера №2,"

msgid "master #1 has the UUID of master #2, and vice versa."
msgstr "у мастера №1 UUID мастера №2, и наоборот."

msgid "**Solution #2: commutative changes**"
msgstr "**Решение #2: коммутативные изменения**"

msgid ""
"The cases described in the previous paragraphs represent examples of **non-"
"commutative** operations, i.e. operations whose result depends on the "
"execution order. On the contrary, for **commutative operations**, the "
"execution order does not matter."
msgstr ""
"Случаи, описанные в предыдущих абзацах, представляют собой примеры "
"**некоммутативных** операций, т.е. операций, результат которых зависит от "
"порядка их выполнения. Для **коммутативных операций** порядок выполнения "
"значения не имеет."

msgid "Consider for example the following command:"
msgstr "Рассмотрим, например, следующую команду:"

msgid "tarantool> box.space.tester:upsert{{1, 0}, {{'+', 2, 1)}"
msgstr "tarantool> box.space.tester:upsert{{1, 0}, {{'+', 2, 1)}"

msgid ""
"This operation is commutative: we get the same result no matter in which "
"order the update is applied on the other masters."
msgstr ""
"Эта операция коммутативна: получаем одинаковый результат, независимо от "
"порядка, в котором обновление применяется на других мастерах."

msgid "**Solution #3: trigger usage**"
msgstr "**Решение #3: использование триггера**"

msgid ""
"The logic and the snippet setting a trigger will be the same here as in case"
" 1. But the trigger function will differ:"
msgstr ""
"Логика и установка триггера будет такой же, как в кейсе 1. Но сама триггер-"
"функция будет отличаться:"

msgid ""
"local my_space_name = 'test'\n"
"local my_trigger = function(old, new, sp, op)\n"
"    -- op:  ‘INSERT’, ‘DELETE’, ‘UPDATE’, or ‘REPLACE’\n"
"    if new == nil then\n"
"        print(\"No new during \"..op, old)\n"
"        return -- deletes are ok\n"
"    end\n"
"    if old == nil then\n"
"        print(\"Insert new, no old\", new)\n"
"        return new  -- insert without old value: ok\n"
"    end\n"
"    print(op..\" duplicate\", old, new)\n"
"    if op == 'INSERT' then\n"
"        if new[2] > old[2] then\n"
"            -- Creating new tuple will change op to ‘REPLACE’\n"
"            return box.tuple.new(new)\n"
"        end\n"
"        return old\n"
"    end\n"
"    if new[2] > old[2] then\n"
"        return new\n"
"    else\n"
"        return old\n"
"    end\n"
"    return\n"
"end\n"
"\n"
"box.ctl.on_schema_init(function()\n"
"    box.space._space:on_replace(function(old_space, new_space)\n"
"        if not old_space and new_space and new_space.name == my_space_name then\n"
"            box.on_commit(function()\n"
"                box.space[my_space_name]:before_replace(my_trigger)\n"
"            end)\n"
"        end\n"
"    end)\n"
"end)"
msgstr ""
"local my_space_name = 'test'\n"
"local my_trigger = function(old, new, sp, op)\n"
"    -- op:  ‘INSERT’, ‘DELETE’, ‘UPDATE’, or ‘REPLACE’\n"
"    if new == nil then\n"
"        print(\"No new during \"..op, old)\n"
"        return -- удаление допустимо\n"
"    end\n"
"    if old == nil then\n"
"        print(\"Insert new, no old\", new)\n"
"        return new  -- вставка без старого значения допустима\n"
"    end\n"
"    print(op..\" duplicate\", old, new)\n"
"    if op == 'INSERT' then\n"
"        if new[2] > old[2] then\n"
"            -- Создание нового кортежа сменит оператор на REPLACE\n"
"            return box.tuple.new(new)\n"
"        end\n"
"        return old\n"
"    end\n"
"    if new[2] > old[2] then\n"
"        return new\n"
"    else\n"
"        return old\n"
"    end\n"
"    return\n"
"end\n"
"\n"
"box.ctl.on_schema_init(function()\n"
"    box.space._space:on_replace(function(old_space, new_space)\n"
"        if not old_space and new_space and new_space.name == my_space_name then\n"
"            box.on_commit(function()\n"
"                box.space[my_space_name]:before_replace(my_trigger)\n"
"            end)\n"
"        end\n"
"    end)\n"
"end)"
