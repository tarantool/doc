# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the Tarantool package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
msgid ""
msgstr ""
"Project-Id-Version: Tarantool 1.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-11-15 13:18+0000\n"
"PO-Revision-Date: 2019-11-15 12:58+0300\n"
"Last-Translator: \n"
"Language: ru\n"
"Language-Team: \n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: ../doc/book/admin/backups.rst:5
#: ../doc/book/cartridge/cartridge_admin.rst:902
msgid "Backups"
msgstr "Резервное копирование"

#: ../doc/book/admin/backups.rst:7
msgid ""
"Tarantool has an append-only storage architecture: it appends data to "
"files but it never overwrites earlier data. The :ref:`Tarantool garbage "
"collector <cfg_checkpoint_daemon-garbage-collector>` removes old files "
"after a checkpoint. You can prevent or delay the garbage collector's "
"action by configuring the :ref:`checkpoint daemon "
"<book_cfg_checkpoint_daemon>`. Backups can be taken at any time, with "
"minimal overhead on database performance."
msgstr ""
"Архитектура Tarantool-хранилища позволяет производить обновление только "
"путем присоединения новых записей: сами файлы никогда не "
"перезаписываются. :ref:`Сборщик мусора Tarantool'а "
"<cfg_checkpoint_daemon-garbage-collector>` удаляет старые файлы после "
"определенной контрольной точки. В настройках :ref:`демона создания "
"контрольных точек <book_cfg_checkpoint_daemon>` можно отложить или "
"запретить работу сборщика мусора. Резервное копирование может проводиться"
" в любое время с минимальной затратой ресурсов."

#: ../doc/book/admin/backups.rst:16
msgid "Two functions are helpful for backups in certain situations:"
msgstr ""
"Данные функции используются для резервного копирования в определенных "
"ситуациях:"

#: ../doc/book/admin/backups.rst:18
msgid ""
":ref:`box.backup.start() <reference_lua-box_backup-backup_start>` informs"
" the server that activities related to the removal of outdated backups "
"must be suspended and returns a table with the names of snapshot and "
"vinyl files that should be copied."
msgstr ""
":ref:`box.backup.start() <reference_lua-box_backup-backup_start>` "
"сообщает серверу, что следует отложить некоторые действия, связанные с "
"удалением устаревших резервных копий, и возвращает таблицу с именами "
"файлов снимков и файлов vinyl'а, которые необходимо будет скопировать."

#: ../doc/book/admin/backups.rst:23
msgid ""
":ref:`box.backup.stop() <reference_lua-box_backup-backup_stop>` later "
"informs the server that normal operations may resume."
msgstr ""
":ref:`box.backup.stop() <reference_lua-box_backup-backup_stop>` затем "
"уведомляет сервер, что работа может быть продолжена в обычном режиме."

#: ../doc/book/admin/backups.rst:30
msgid "Hot backup (memtx)"
msgstr "Горячее резервирование (memtx)"

#: ../doc/book/admin/backups.rst:32
msgid "This is a special case when there are only in-memory tables."
msgstr "Это особый случай, когда все таблицы хранятся в памяти."

#: ../doc/book/admin/backups.rst:34
msgid ""
"The last :ref:`snapshot file <index-box_persistence>` is a backup of the "
"entire database; and the :ref:`WAL <internals-wal>` files that are made "
"after the last snapshot are incremental backups. Therefore taking a "
"backup is a matter of copying the snapshot and WAL files."
msgstr ""
"Последний созданный Tarantool'ом :ref:`файл-снимок <index-"
"box_persistence>` является резервной копией всей базы данных; а "
":ref:`WAL-файлы <internals-wal>`, созданные следом за последним "
"файлом-снимком, являются инкрементными копиями. Поэтому процедура "
"резервирования сводится к копированию последнего файла-снимка и следующих"
" за ним WAL-файлов."

#: ../doc/book/admin/backups.rst:39
msgid ""
"Use ``tar`` to make a (possibly compressed) copy of the latest .snap and "
".xlog files on the :ref:`memtx_dir <cfg_basic-memtx_dir>` and "
":ref:`wal_dir <cfg_basic-wal_dir>` directories."
msgstr ""
"С помощью ``tar`` создайте (зачастую сжатую) копию последнего .snap-файла"
" и следующих за ним .xlog-файлов из директорий :ref:`memtx_dir "
"<cfg_basic-memtx_dir>` и :ref:`wal_dir <cfg_basic-wal_dir>`."

#: ../doc/book/admin/backups.rst:43
msgid "If there is a security policy, encrypt the .tar file."
msgstr "Если того требуют правила безопасности, зашифруйте получившийся .tar-файл."

#: ../doc/book/admin/backups.rst:45
msgid "Copy the .tar file to a safe place."
msgstr "Скопируйте .tar-файл в надежное место."

#: ../doc/book/admin/backups.rst:47
msgid ""
"Later, restoring the database is a matter of taking the .tar file and "
"putting its contents back in the ``memtx_dir`` and ``wal_dir`` "
"directories."
msgstr ""
"В дальнейшем базу данных можно восстановить, разархивировав содержимое "
".tar-файла в директории ``memtx_dir`` и ``wal_dir``."

#: ../doc/book/admin/backups.rst:54
msgid "Hot backup (vinyl/memtx)"
msgstr "Горячее резервирование (vinyl/memtx)"

#: ../doc/book/admin/backups.rst:56
msgid ""
"Vinyl stores its files in :ref:`vinyl_dir <cfg_basic-vinyl_dir>`, and "
"creates a folder for each database space. Dump and compaction processes "
"are append-only and create new files. The Tarantool garbage collector may"
" remove old files after each checkpoint."
msgstr ""
"Vinyl хранит свои файлы в :ref:`vinyl_dir <cfg_basic-vinyl_dir>` и "
"создает для каждого спейса в базе данных отдельную поддиректорию. "
"Создание дампов и слияние -- это процессы, которые могут лишь добавлять "
"записи, поэтому в результате создаются новые файлы. Сборщик мусора "
"Tarantool'а может удалять старые файлы после каждой контрольной точки."

#: ../doc/book/admin/backups.rst:61
msgid "To take a mixed backup:"
msgstr "Для создания смешанной резервной копии:"

#: ../doc/book/admin/backups.rst:63
msgid ""
"Issue :ref:`box.backup.start() <admin-backups-backup_start>` on the "
":ref:`administrative console <admin-security>`. This will return a list "
"of files to back up and suspend garbage collection for them till the next"
" ``box.backup.stop()``."
msgstr ""
"Выполните команду :ref:`box.backup.start() <admin-backups-backup_start>` "
"в :ref:`административной консоли <admin-security>`. Эта команда покажет "
"список файлов для резервирования и приостановит сборку мусора до "
"следующего вызова ``box.backup.stop()``."

#: ../doc/book/admin/backups.rst:67
msgid ""
"Copy the files from the list to a safe location. This will include memtx "
"snapshot files, vinyl run and index files, at a state consistent with the"
" last checkpoint."
msgstr ""
"Скопируйте файлы из списка в надежное место. Это касается файлов-снимков "
"memtx, выполняемых vinyl-файлов и индексных файлов, соответствующих "
"последней контрольной точке."

#: ../doc/book/admin/backups.rst:71
msgid ""
"Issue ``box.backup.stop()`` so the garbage collector can continue as "
"usual."
msgstr ""
"Выполните команду ``box.backup.stop()``, чтобы сборщик мусора мог "
"продолжить работу."

#: ../doc/book/admin/backups.rst:77
msgid "Continuous remote backup (memtx)"
msgstr "Непрерывное удаленное резервирование"

#: ../doc/book/admin/backups.rst:79
msgid ""
"The :ref:`replication <replication>` feature is useful for backup as well"
" as for load balancing."
msgstr ""
":ref:`Репликация <replication>` используется не только для "
"резервирования, но и для выравнивания нагрузки."

#: ../doc/book/admin/backups.rst:82
msgid ""
"Therefore taking a backup is a matter of ensuring that any given replica "
"is up to date, and doing a cold backup on it. Since all the other "
"replicas continue to operate, this is not a cold backup from the end "
"user’s point of view. This could be done on a regular basis, with a "
"``cron`` job or with a Tarantool fiber."
msgstr ""
"Поэтому процесс создания резервной копии сводится к обновлению (при "
"необходимости) одной из реплик с последующим холодным резервированием. "
"Так как все остальные реплики продолжают функционировать, с точки зрения "
"конечного пользователя, этот процесс не является холодным "
"резервированием. Такое резервирование можно выполнять регулярно с помощью"
"  планировщика ``cron`` или файбера Tarantool'а."

#: ../doc/book/admin/backups.rst:91
msgid "Continuous backup (memtx)"
msgstr "Непрерывное резервирование"

#: ../doc/book/admin/backups.rst:93
msgid ""
"The logged changes done since the last cold backup must be secured, while"
" the system is running."
msgstr ""
"По ходу работы системы необходимо сохранять записи об изменениях, "
"внесенных со времени последнего холодного резервирования."

#: ../doc/book/admin/backups.rst:96
msgid ""
"For this purpose, you need a file copy utility that will do the copying "
"remotely and continuously, copying only the parts of a write ahead log "
"file that are changing. One such utility is `rsync "
"<https://en.wikipedia.org/wiki/Rsync>`_."
msgstr ""
"Для этого нужна специальная утилита для копирования файлов (например, "
"`rsync <https://en.wikipedia.org/wiki/rsync>`_), которая позволит "
"удаленно и на постоянной основе копировать только изменившиеся части "
"WAL-файла, а не весь файл целиком."

#: ../doc/book/admin/backups.rst:101
msgid ""
"Alternatively, you need an ordinary file copy utility, but there should "
"be frequent production of new snapshot files or new WAL files as changes "
"occur, so that only the new files need to be copied."
msgstr ""
"Можно взять и обычную утилиту для копирования целых файлов, но тогда "
"придется создавать файлы-снимки и WAL-файлы на каждое изменение, чтобы "
"нужно было копировать только новые файлы."

#: ../doc/book/admin/bug_reports.rst:5
msgid "Bug reports"
msgstr "Сообщения об ошибках"

#: ../doc/book/admin/bug_reports.rst:7
msgid ""
"If you found a bug in Tarantool, you’re doing us a favor by taking the "
"time to tell us about it."
msgstr "Если вы нашли ошибку в Tarantool, вы окажете нам услугу, сообщив о ней."

#: ../doc/book/admin/bug_reports.rst:10
msgid ""
"Please create an issue at Tarantool repository at GitHub. We encourage "
"you to include the following information:"
msgstr ""
"Пожалуйста, откройте тикет в репозитории Tarantool на GitHub. Рекомендуем"
"  включить следующую информацию:"

#: ../doc/book/admin/bug_reports.rst:13
msgid ""
"Steps needed to reproduce the bug, and an explanation why this differs "
"from the expected behavior according to our manual. Please provide "
"specific unique information. For example, instead of \"I can’t get "
"certain information\", say \"box.space.x:delete() didn’t report what was "
"deleted\"."
msgstr ""
"Шаги для воспроизведения ошибки с объяснением того, как ошибочное "
"поведение отличается от описанного в документации ожидаемого поведения. "
"Пожалуйста, указывайте как можно более конкретную информацию. Например, "
"вместо \"Я не могу получить определенную информацию\" лучше написать "
"\"box.space.x:delete() не указывает, что именно было удалено\"."

#: ../doc/book/admin/bug_reports.rst:18
msgid ""
"Your operating system name and version, the Tarantool name and version, "
"and any unusual details about your machine and its configuration."
msgstr ""
"Название и версию вашей операционной системы, название и версию Tarantool"
"  и любую информацию об особенностях вашей машины и ее конфигурации."

#: ../doc/book/admin/bug_reports.rst:21
msgid ""
"Related files like a :ref:`stack trace <admin-stack_traces>` or a "
"Tarantool :ref:`log file <admin-logs>`."
msgstr ""
"Сопутствующие файлы -- такие как :ref:`трассировка стека <admin-"
"stack_traces>` или :ref:`файл журнала <admin-logs>` Tarantool'а."

#: ../doc/book/admin/bug_reports.rst:24
msgid ""
"If this is a feature request or if it affects a special category of "
"users, be sure to mention that."
msgstr ""
"Если это запрос новой функции или это затрагивает определенную группу "
"пользователей, не забудьте это указать."

#: ../doc/book/admin/bug_reports.rst:27
msgid ""
"Usually within one or two workdays a Tarantool team member will write an "
"acknowledgment, or some questions, or suggestions for a workaround."
msgstr ""
"Обычно член команды Tarantool отвечает в течение одного-двух рабочих "
"дней, чтобы подтвердить, что тикет взят в работу, задать уточняющие "
"вопросы или предложить альтернативное решение описанной проблемы."

#: ../doc/book/admin/daemon_supervision.rst:5
msgid "Daemon supervision"
msgstr "Контроль за фоновыми программами"

#: ../doc/book/admin/daemon_supervision.rst:11
msgid "Server signals"
msgstr "Сигналы от сервера"

#: ../doc/book/admin/daemon_supervision.rst:13
msgid ""
"Tarantool processes these signals during the event loop in the "
"transaction processor thread:"
msgstr ""
"Во время событийного цикла в потоке обработки транзакций Tarantool "
"обрабатывает следующие сигналы:"

#: ../doc/book/admin/daemon_supervision.rst:22
msgid "Signal"
msgstr "Сигнал"

#: ../doc/book/admin/daemon_supervision.rst:22
#: ../doc/book/box/box_schema.rst:131 ../doc/book/box/box_space.rst:295
#: ../doc/book/box/data_model.rst:909
msgid "Effect"
msgstr "Эффект"

#: ../doc/book/admin/daemon_supervision.rst:24
msgid "SIGHUP"
msgstr "SIGHUP"

#: ../doc/book/admin/daemon_supervision.rst:24
msgid ""
"May cause log file rotation. See the :ref:`example <cfg_logging-"
"logging_example>` in reference on Tarantool logging parameters."
msgstr ""
"Может привести к ротации журналов, см. :ref:`пример <cfg_logging-"
"logging_example>` в справочнике по параметрам журналирования Tarantool'а."

#: ../doc/book/admin/daemon_supervision.rst:28
msgid "SIGUSR1"
msgstr "SIGUSR1"

#: ../doc/book/admin/daemon_supervision.rst:28
msgid "May cause a database checkpoint. See :ref:`box.snapshot <box-snapshot>`."
msgstr ""
"Может привести к созданию снимка состояния базы данных, см. описание "
"функции :ref:`box.snapshot <box-snapshot>`."

#: ../doc/book/admin/daemon_supervision.rst:31
msgid "SIGTERM"
msgstr "SIGTERM"

#: ../doc/book/admin/daemon_supervision.rst:31
msgid "May cause graceful shutdown (information will be saved first)."
msgstr ""
"Может привести к корректному завершению работы (с предварительным "
"сохранением всех данных)."

#: ../doc/book/admin/daemon_supervision.rst:34
msgid "SIGINT (also known as keyboard interrupt)"
msgstr "SIGINT (или \"прерывание от клавиатуры\")"

#: ../doc/book/admin/daemon_supervision.rst:34
msgid "May cause graceful shutdown."
msgstr "Может привести к корректному завершению работы."

#: ../doc/book/admin/daemon_supervision.rst:38
msgid "SIGKILL"
msgstr "SIGKILL"

#: ../doc/book/admin/daemon_supervision.rst:38
msgid "Causes an immediate shutdown."
msgstr "Приводит к аварийному завершению работы."

#: ../doc/book/admin/daemon_supervision.rst:41
msgid ""
"Other signals will result in behavior defined by the operating system. "
"Signals other than SIGKILL may be ignored, especially if Tarantool is "
"executing a long-running procedure which prevents return to the event "
"loop in the transaction processor thread."
msgstr ""
"Остальные сигналы приводят к заданному операционной системой поведению. "
"Все сигналы, за исключением SIGKILL, можно игнорировать, особенно если "
"Tarantool выполняет длительную процедуру и не может вернуться в "
"событийный цикл в потоке обработки транзакций."

#: ../doc/book/admin/daemon_supervision.rst:50
msgid "Automatic instance restart"
msgstr "Автоматическая перезагрузка экземпляра"

#: ../doc/book/admin/daemon_supervision.rst:52
msgid ""
"On ``systemd``-enabled platforms, ``systemd`` automatically restarts all "
"Tarantool instances in case of failure. To demonstrate it, let’s try to "
"destroy an instance:"
msgstr ""
"На платформах, где доступна утилита ``systemd``, ``systemd`` "
"автоматически перезагружает все экземпляры Tarantool'а при сбое. Чтобы "
"продемонстрировать это, отключим один из экземпляров:"

#: ../doc/book/admin/daemon_supervision.rst:56
msgid ""
"$ systemctl status tarantool@my_app|grep PID\n"
"Main PID: 5885 (tarantool)\n"
"$ tarantoolctl enter my_app\n"
"/bin/tarantoolctl: Found my_app.lua in /etc/tarantool/instances.available"
"\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/my_app.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/my_app.control\n"
"unix/:/var/run/tarantool/my_app.control> os.exit(-1)\n"
"/bin/tarantoolctl: unix/:/var/run/tarantool/my_app.control: Remote host "
"closed connection"
msgstr ""
"$ systemctl status tarantool@my_app|grep PID\n"
"Main PID: 5885 (tarantool)\n"
"$ tarantoolctl enter my_app\n"
"/bin/tarantoolctl: Found my_app.lua in /etc/tarantool/instances.available"
"\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/my_app.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/my_app.control\n"
"unix/:/var/run/tarantool/my_app.control> os.exit(-1)\n"
"/bin/tarantoolctl: unix/:/var/run/tarantool/my_app.control: Remote host "
"closed connection"

#: ../doc/book/admin/daemon_supervision.rst:67
msgid "Now let’s make sure that ``systemd`` has restarted the instance:"
msgstr "А теперь убедимся, что ``systemd`` перезапустила его:"

#: ../doc/book/admin/daemon_supervision.rst:69
msgid ""
"$ systemctl status tarantool@my_app|grep PID\n"
"Main PID: 5914 (tarantool)"
msgstr ""
"$ systemctl status tarantool@my_app|grep PID\n"
"Main PID: 5914 (tarantool)"

#: ../doc/book/admin/daemon_supervision.rst:74
msgid "Finally, let’s check the boot logs:"
msgstr "И под конец проверим содержимое журнала загрузки:"

#: ../doc/book/admin/daemon_supervision.rst:76
msgid ""
"$ journalctl -u tarantool@my_app -n 8\n"
"-- Logs begin at Fri 2016-01-08 12:21:53 MSK, end at Thu 2016-01-21 "
"21:09:45 MSK. --\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: "
"tarantool@my_app.service: Unit entered failed state.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: "
"tarantool@my_app.service: Failed with result 'exit-code'.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: "
"tarantool@my_app.service: Service hold-off time over, scheduling restart."
"\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Stopped Tarantool "
"Database Server.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Starting Tarantool "
"Database Server...\n"
"Jan 21 21:09:45 localhost.localdomain tarantoolctl[5910]: "
"/usr/bin/tarantoolctl: Found my_app.lua in "
"/etc/tarantool/instances.available\n"
"Jan 21 21:09:45 localhost.localdomain tarantoolctl[5910]: "
"/usr/bin/tarantoolctl: Starting instance...\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Started Tarantool "
"Database Server."
msgstr ""
"$ journalctl -u tarantool@my_app -n 8\n"
"-- Записи начинаются в пятницу 08.01.2016 12:21:53 MSK, заканчиваются в "
"четверг 21.01.2016 2016-01-21 21:09:45 MSK. --\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: "
"tarantool@my_app.service: Unit entered failed state.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: "
"tarantool@my_app.service: Failed with result 'exit-code'.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: "
"tarantool@my_app.service: Service hold-off time over, scheduling restart."
"\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Stopped Tarantool "
"Database Server.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Starting Tarantool "
"Database Server...\n"
"Jan 21 21:09:45 localhost.localdomain tarantoolctl[5910]: "
"/usr/bin/tarantoolctl: Found my_app.lua in "
"/etc/tarantool/instances.available\n"
"Jan 21 21:09:45 localhost.localdomain tarantoolctl[5910]: "
"/usr/bin/tarantoolctl: Starting instance...\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Started Tarantool "
"Database Server."

#: ../doc/book/admin/daemon_supervision.rst:93
msgid "Core dumps"
msgstr "Создание дампов памяти"

#: ../doc/book/admin/daemon_supervision.rst:95
msgid ""
"Tarantool makes a core dump if it receives any of the following signals: "
"SIGSEGV, SIGFPE, SIGABRT or SIGQUIT. This is automatic if Tarantool "
"crashes."
msgstr ""
"Tarantool создает дамп памяти при получении одного из следующих сигналов:"
" SIGSEGV, SIGFPE, SIGABRT или SIGQUIT. При сбое Tarantool'а дамп "
"создается автоматически."

#: ../doc/book/admin/daemon_supervision.rst:98
msgid ""
"On ``systemd``-enabled platforms, ``coredumpctl`` automatically saves "
"core dumps and stack traces in case of a crash. Here is a general \"how "
"to\" for how to enable core dumps on a Unix system:"
msgstr ""
"На платформах, где доступна утилита ``systemd``, ``coredumpctl`` "
"автоматически сохраняет дампы памяти и трассировку стека при аварийном "
"завершении Tarantool-сервера. Вот как включить создание дампов памяти в "
"Unix-системе:"

#: ../doc/book/admin/daemon_supervision.rst:102
msgid ""
"Ensure session limits are configured to enable core dumps, i.e. say "
"``ulimit -c unlimited``. Check  \"man 5 core\" for other reasons why a "
"core dump may not be produced."
msgstr ""
"Убедитесь, что лимиты для сессии установлены таким образом, чтобы можно "
"было создавать дампы памяти, -- выполните команду ``ulimit -c "
"unlimited``.  Также проверьте \"man 5 core\" на другие причины, по "
"которым дамп памяти  может не создаваться."

#: ../doc/book/admin/daemon_supervision.rst:106
msgid ""
"Set a directory for writing core dumps to, and make sure that the "
"directory is writable. On Linux, the directory path is set in a kernel "
"parameter configurable via ``/proc/sys/kernel/core_pattern``."
msgstr ""
"Создайте директорию для записи дампов памяти и убедитесь, что в эту "
"директорию действительно можно производить запись. На Linux путь до "
"директории задается в параметре ядра, который настраивается через "
"``/proc/sys/kernel/core_pattern``."

#: ../doc/book/admin/daemon_supervision.rst:110
msgid ""
"Make sure that core dumps include stack trace information. If you use a "
"binary Tarantool distribution, this is automatic. If you build Tarantool "
"from source, you will not get detailed information if you pass "
"``-DCMAKE_BUILD_TYPE=Release`` to CMake."
msgstr ""
"Убедитесь, что дампы памяти включают трассировку стека. При использовании"
"  бинарного дистрибутива Tarantool'а эта информация включается "
"автоматически. При сборке Tarantool'а из исходников, если передать CMake "
"флаг ``-DCMAKE_BUILD_TYPE=Release``, вы не получите подробной информации."

#: ../doc/book/admin/daemon_supervision.rst:115
msgid ""
"To simulate a crash, you can execute an illegal command against a "
"Tarantool instance:"
msgstr ""
"Для симуляции сбоя можно попытаться выполнить нелегальную команду на "
"работающем экземпляре Tarantool'а:"

#: ../doc/book/admin/daemon_supervision.rst:118
msgid ""
"$ # !!! please never do this on a production system !!!\n"
"$ tarantoolctl enter my_app\n"
"unix/:/var/run/tarantool/my_app.control> require('ffi').cast('char *', "
"0)[0] = 48\n"
"/bin/tarantoolctl: unix/:/var/run/tarantool/my_app.control: Remote host "
"closed connection"
msgstr ""
"$ # !!! пожалуйста, никогда не делайте этого на боевом сервере !!!\n"
"$ tarantoolctl enter my_app\n"
"unix/:/var/run/tarantool/my_app.control> require('ffi').cast('char *', "
"0)[0] = 48\n"
"/bin/tarantoolctl: unix/:/var/run/tarantool/my_app.control: Remote host "
"closed connection"

#: ../doc/book/admin/daemon_supervision.rst:125
msgid ""
"Alternatively, if you know the process ID of the instance (here we refer "
"to it as $PID), you can abort a Tarantool instance by running ``gdb`` "
"debugger:"
msgstr ""
"Есть другой способ: если вы знаете PID экземпляра ($PID в нашем примере),"
"  можно остановить этот экземпляр, запустив отладчик ``gdb``:"

#: ../doc/book/admin/daemon_supervision.rst:128
msgid "$ gdb -batch -ex \"generate-core-file\" -p $PID"
msgstr "$ gdb -batch -ex \"generate-core-file\" -p $PID"

#: ../doc/book/admin/daemon_supervision.rst:132
msgid "or manually sending a SIGABRT signal:"
msgstr "или послав вручную сигнал SIGABRT:"

#: ../doc/book/admin/daemon_supervision.rst:134
msgid "$ kill -SIGABRT $PID"
msgstr "$ kill -SIGABRT $PID"

#: ../doc/book/admin/daemon_supervision.rst:140
msgid "To find out the process id of the instance ($PID), you can:"
msgstr "Чтобы узнать PID экземпляра, можно:"

#: ../doc/book/admin/daemon_supervision.rst:142
msgid ""
"look it up in the instance's :ref:`box.info.pid <box_introspection-"
"box_info>`,"
msgstr "посмотреть его с помощью :ref:`box.info.pid <box_introspection-box_info>`,"

#: ../doc/book/admin/daemon_supervision.rst:144
msgid "find it with ``ps -A | grep tarantool``, or"
msgstr "использовать команду ``ps -A | grep tarantool``, или"

#: ../doc/book/admin/daemon_supervision.rst:146
msgid "say ``systemctl status tarantool@my_app|grep PID``."
msgstr "выполнить ``systemctl status tarantool@my_app|grep PID``."

#: ../doc/book/admin/daemon_supervision.rst:148
msgid ""
"On a ``systemd-enabled`` system, to see the latest crashes of the "
"Tarantool daemon, say:"
msgstr ""
"Чтобы посмотреть на последние сбои Tarantool-демона на платформах, где "
"доступна утилита ``systemd``, выполните команду:"

#: ../doc/book/admin/daemon_supervision.rst:151
msgid ""
"$ coredumpctl list /usr/bin/tarantool\n"
"MTIME                            PID   UID   GID SIG PRESENT EXE\n"
"Sat 2016-01-23 15:21:24 MSK   20681  1000  1000   6   /usr/bin/tarantool\n"
"Sat 2016-01-23 15:51:56 MSK   21035   995   992   6   /usr/bin/tarantool"
msgstr ""
"$ coredumpctl list /usr/bin/tarantool\n"
"MTIME                            PID   UID   GID SIG PRESENT EXE\n"
"Sat 2016-01-23 15:21:24 MSK   20681  1000  1000   6   /usr/bin/tarantool\n"
"Sat 2016-01-23 15:51:56 MSK   21035   995   992   6   /usr/bin/tarantool"

#: ../doc/book/admin/daemon_supervision.rst:158
msgid "To save a core dump into a file, say:"
msgstr "Чтобы сохранить дамп памяти в файл, выполните команду:"

#: ../doc/book/admin/daemon_supervision.rst:160
msgid "$ coredumpctl -o filename.core info <pid>"
msgstr "$ coredumpctl -o filename.core info <pid>"

#: ../doc/book/admin/daemon_supervision.rst:168
msgid "Stack traces"
msgstr "Трассировка стека"

#: ../doc/book/admin/daemon_supervision.rst:170
msgid ""
"Since Tarantool stores tuples in memory, core files may be large. For "
"investigation, you normally don't need the whole file, but only a \"stack"
" trace\" or \"backtrace\"."
msgstr ""
"Так как Tarantool хранит кортежи в памяти, файлы с дампами памяти могут "
"быть довольно большими. Чтобы найти проблему, обычно целый файл не нужен "
"-- достаточно только \"трассировки стека\" или \"обратной трассировки\"."

#: ../doc/book/admin/daemon_supervision.rst:174
msgid "To save a stack trace into a file, say:"
msgstr "Чтобы сохранить трассировку стека в файл, выполните команду:"

#: ../doc/book/admin/daemon_supervision.rst:176
msgid ""
"$ gdb -se \"tarantool\" -ex \"bt full\" -ex \"thread apply all bt\" "
"--batch -c core> /tmp/tarantool_trace.txt"
msgstr ""
"$ gdb -se \"tarantool\" -ex \"bt full\" -ex \"thread apply all bt\" "
"--batch -c core> /tmp/tarantool_trace.txt"

#: ../doc/book/admin/daemon_supervision.rst:180
#: ../doc/book/admin/instance_config.rst:120
#: ../doc/book/replication/repl_bootstrap.rst:39
msgid "where:"
msgstr "где:"

#: ../doc/book/admin/daemon_supervision.rst:182
msgid "\"tarantool\" is the path to the Tarantool executable,"
msgstr "\"tarantool\" -- это путь до исполняемого файла Tarantool'а,"

#: ../doc/book/admin/daemon_supervision.rst:183
msgid "\"core\" is the path to the core file, and"
msgstr "\"core\" -- это путь до файла с дампом памяти, и"

#: ../doc/book/admin/daemon_supervision.rst:184
msgid ""
"\"/tmp/tarantool_trace.txt\" is a sample path to a file for saving the "
"stack trace."
msgstr ""
"\"/tmp/tarantool_trace.txt\" -- это пример пути до файла, в который "
"сохраняется трассировка стека."

#: ../doc/book/admin/daemon_supervision.rst:188
msgid ""
"Occasionally, you may find that the trace file contains output without "
"debug symbols – the lines will contain ”??” instead of names. If this "
"happens, check the instructions on these Tarantool wiki pages: `How to "
"debug core dump of stripped tarantool "
"<https://github.com/tarantool/tarantool/wiki/How-to-debug-core-dump-of-"
"stripped-tarantool>`_ and `How to debug core from different OS "
"<https://github.com/tarantool/tarantool/wiki/How-to-debug-core-from-"
"different-OS>`_."
msgstr ""
"Иногда может оказаться, что файл с трассировкой стека не содержит "
"отладочных символов -- в таких строках вместо имени будет стоять ”??”. "
"Если это произошло, ознакомьтесь с инструкциями на этих двух "
"wiki-страницах Tarantool'а: `How to debug core dump of stripped tarantool"
"  <https://github.com/tarantool/tarantool/wiki/How-to-debug-core-dump-of-"
" stripped-tarantool>`_ и `How to debug core from different OS "
"<https://github.com/tarantool/tarantool/wiki/How-to-debug-core-from- "
"different-OS>`_."

#: ../doc/book/admin/daemon_supervision.rst:195
msgid "To see the stack trace and other useful information in console, say:"
msgstr ""
"Чтобы получить трассировку стека и прочую полезную информацию в консоли, "
"выполните команду:"

#: ../doc/book/admin/daemon_supervision.rst:197
msgid ""
"$ coredumpctl info 21035\n"
"          PID: 21035 (tarantool)\n"
"          UID: 995 (tarantool)\n"
"          GID: 992 (tarantool)\n"
"       Signal: 6 (ABRT)\n"
"    Timestamp: Sat 2016-01-23 15:51:42 MSK (4h 36min ago)\n"
" Command Line: tarantool my_app.lua <running>\n"
"   Executable: /usr/bin/tarantool\n"
"Control Group: /system.slice/system-"
"tarantool.slice/tarantool@my_app.service\n"
"         Unit: tarantool@my_app.service\n"
"        Slice: system-tarantool.slice\n"
"      Boot ID: 7c686e2ef4dc4e3ea59122757e3067e2\n"
"   Machine ID: a4a878729c654c7093dc6693f6a8e5ee\n"
"     Hostname: localhost.localdomain\n"
"      Message: Process 21035 (tarantool) of user 995 dumped core.\n"
"\n"
"               Stack trace of thread 21035:\n"
"               #0  0x00007f84993aa618 raise (libc.so.6)\n"
"               #1  0x00007f84993ac21a abort (libc.so.6)\n"
"               #2  0x0000560d0a9e9233 _ZL12sig_fatal_cbi (tarantool)\n"
"               #3  0x00007f849a211220 __restore_rt (libpthread.so.0)\n"
"               #4  0x0000560d0aaa5d9d lj_cconv_ct_ct (tarantool)\n"
"               #5  0x0000560d0aaa687f lj_cconv_ct_tv (tarantool)\n"
"               #6  0x0000560d0aaabe33 lj_cf_ffi_meta___newindex "
"(tarantool)\n"
"               #7  0x0000560d0aaae2f7 lj_BC_FUNCC (tarantool)\n"
"               #8  0x0000560d0aa9aabd lua_pcall (tarantool)\n"
"               #9  0x0000560d0aa71400 lbox_call (tarantool)\n"
"               #10 0x0000560d0aa6ce36 lua_fiber_run_f (tarantool)\n"
"               #11 0x0000560d0a9e8d0c "
"_ZL16fiber_cxx_invokePFiP13__va_list_tagES0_ (tarantool)\n"
"               #12 0x0000560d0aa7b255 fiber_loop (tarantool)\n"
"               #13 0x0000560d0ab38ed1 coro_init (tarantool)\n"
"               ..."
msgstr ""
"$ coredumpctl info 21035\n"
"          PID: 21035 (tarantool)\n"
"          UID: 995 (tarantool)\n"
"          GID: 992 (tarantool)\n"
"       Signal: 6 (ABRT)\n"
"    Timestamp: Sat 2016-01-23 15:51:42 MSK (4h 36min ago)\n"
" Command Line: tarantool my_app.lua <running>\n"
"   Executable: /usr/bin/tarantool\n"
"Control Group: /system.slice/system-"
"tarantool.slice/tarantool@my_app.service\n"
"         Unit: tarantool@my_app.service\n"
"        Slice: system-tarantool.slice\n"
"      Boot ID: 7c686e2ef4dc4e3ea59122757e3067e2\n"
"   Machine ID: a4a878729c654c7093dc6693f6a8e5ee\n"
"     Hostname: localhost.localdomain\n"
"      Message: Process 21035 (tarantool) of user 995 dumped core.\n"
"\n"
"               Stack trace of thread 21035:\n"
"               #0  0x00007f84993aa618 raise (libc.so.6)\n"
"               #1  0x00007f84993ac21a abort (libc.so.6)\n"
"               #2  0x0000560d0a9e9233 _ZL12sig_fatal_cbi (tarantool)\n"
"               #3  0x00007f849a211220 __restore_rt (libpthread.so.0)\n"
"               #4  0x0000560d0aaa5d9d lj_cconv_ct_ct (tarantool)\n"
"               #5  0x0000560d0aaa687f lj_cconv_ct_tv (tarantool)\n"
"               #6  0x0000560d0aaabe33 lj_cf_ffi_meta___newindex "
"(tarantool)\n"
"               #7  0x0000560d0aaae2f7 lj_BC_FUNCC (tarantool)\n"
"               #8  0x0000560d0aa9aabd lua_pcall (tarantool)\n"
"               #9  0x0000560d0aa71400 lbox_call (tarantool)\n"
"               #10 0x0000560d0aa6ce36 lua_fiber_run_f (tarantool)\n"
"               #11 0x0000560d0a9e8d0c "
"_ZL16fiber_cxx_invokePFiP13__va_list_tagES0_ (tarantool)\n"
"               #12 0x0000560d0aa7b255 fiber_loop (tarantool)\n"
"               #13 0x0000560d0ab38ed1 coro_init (tarantool)\n"
"               ..."

#: ../doc/book/admin/daemon_supervision.rst:236
msgid "Debugger"
msgstr "Отладчик"

#: ../doc/book/admin/daemon_supervision.rst:238
msgid "To start ``gdb`` debugger on the core dump, say:"
msgstr "Для запуска отладчика ``gdb``, выполните команду:"

#: ../doc/book/admin/daemon_supervision.rst:240
msgid "$ coredumpctl gdb <pid>"
msgstr "$ coredumpctl gdb <pid>"

#: ../doc/book/admin/daemon_supervision.rst:244
msgid ""
"It is highly recommended to install ``tarantool-debuginfo`` package to "
"improve ``gdb`` experience, for example:"
msgstr ""
"Мы очень рекомендуем установить пакет ``tarantool-debuginfo``, чтобы "
"сделать отладку средствами ``gdb`` более эффективной. Например:"

#: ../doc/book/admin/daemon_supervision.rst:247
msgid "$ dnf debuginfo-install tarantool"
msgstr "$ dnf debuginfo-install tarantool"

#: ../doc/book/admin/daemon_supervision.rst:251
msgid ""
"``gdb`` also provides information about the debuginfo packages you need "
"to install:"
msgstr ""
"С помощью ``gdb`` можно узнать, какие еще ``debuginfo``-пакеты нужно "
"установить:"

#: ../doc/book/admin/daemon_supervision.rst:254
msgid ""
"$ gdb -p <pid>\n"
"...\n"
"Missing separate debuginfos, use: dnf debuginfo-install\n"
"glibc-2.22.90-26.fc24.x86_64 krb5-libs-1.14-12.fc24.x86_64\n"
"libgcc-5.3.1-3.fc24.x86_64 libgomp-5.3.1-3.fc24.x86_64\n"
"libselinux-2.4-6.fc24.x86_64 libstdc++-5.3.1-3.fc24.x86_64\n"
"libyaml-0.1.6-7.fc23.x86_64 ncurses-libs-6.0-1.20150810.fc24.x86_64\n"
"openssl-libs-1.0.2e-3.fc24.x86_64"
msgstr ""
"$ gdb -p <pid>\n"
"...\n"
"Missing separate debuginfos, use: dnf debuginfo-install\n"
"glibc-2.22.90-26.fc24.x86_64 krb5-libs-1.14-12.fc24.x86_64\n"
"libgcc-5.3.1-3.fc24.x86_64 libgomp-5.3.1-3.fc24.x86_64\n"
"libselinux-2.4-6.fc24.x86_64 libstdc++-5.3.1-3.fc24.x86_64\n"
"libyaml-0.1.6-7.fc23.x86_64 ncurses-libs-6.0-1.20150810.fc24.x86_64\n"
"openssl-libs-1.0.2e-3.fc24.x86_64"

#: ../doc/book/admin/daemon_supervision.rst:265
msgid ""
"Symbolic names are present in stack traces even if you don’t have "
"``tarantool-debuginfo`` package installed."
msgstr ""
"В трассировке стека присутствуют символические имена, даже если у вас не "
"установлен пакет ``tarantool-debuginfo``."

#: ../doc/book/admin/disaster_recovery.rst:5
#: ../doc/book/cartridge/cartridge_admin.rst:894
msgid "Disaster recovery"
msgstr "Аварийное восстановление"

#: ../doc/book/admin/disaster_recovery.rst:7
msgid ""
"The minimal fault-tolerant Tarantool configuration would be a "
":ref:`replication cluster<replication-topologies>` that includes a master"
" and a replica, or two masters."
msgstr ""
"Минимальная отказоустойчивая конфигурация Tarantool'а -- это "
":ref:`репликационный кластер <replication-topologies>`, содержащий мастер"
" и реплику или два мастера."

#: ../doc/book/admin/disaster_recovery.rst:11
msgid ""
"The basic recommendation is to configure all Tarantool instances in a "
"cluster to create :ref:`snapshot files <index-box_persistence>` at a "
"regular basis."
msgstr ""
"Основная рекомендация -- настраивать все экземпляры Tarantool'а в "
"кластере  таким образом, чтобы они регулярно создавали :ref:`файлы-снимки"
" <index-box_persistence>`."

#: ../doc/book/admin/disaster_recovery.rst:14
msgid "Here follow action plans for typical crash scenarios."
msgstr "Ниже дано несколько инструкций для типовых аварийных сценариев."

#: ../doc/book/admin/disaster_recovery.rst:20
msgid "Master-replica"
msgstr "Мастер-реплика"

#: ../doc/book/admin/disaster_recovery.rst:22
msgid "Configuration: One master and one replica."
msgstr "Конфигурация: один мастер и одна реплика."

#: ../doc/book/admin/disaster_recovery.rst:24
msgid "Problem: The master has crashed."
msgstr "Проблема: мастер вышел из строя."

#: ../doc/book/admin/disaster_recovery.rst:26
#: ../doc/book/admin/disaster_recovery.rst:93
msgid "Your actions:"
msgstr "План действий:"

#: ../doc/book/admin/disaster_recovery.rst:28
msgid ""
"Ensure the master is stopped for good. For example, log in to the master "
"machine and use ``systemctl stop tarantool@<instance_name>``."
msgstr ""
"Убедитесь, что мастер полностью остановлен. Например, подключитесь к "
"мастеру и используйте команду ``systemctl stop "
"tarantool@<имя_экземпляра>``."

#: ../doc/book/admin/disaster_recovery.rst:31
msgid ""
"Switch the replica to master mode by setting :ref:`box.cfg.read_only "
"<cfg_basic-read_only>` parameter to *false* and let the load be handled "
"by the replica (effective master)."
msgstr ""
"Переключите реплику в режим мастера, установив параметру "
":ref:`box.cfg.read_only <cfg_basic-read_only>` значение *false*. Теперь "
"вся нагрузка пойдет только на реплику (по сути ставшую мастером)."

#: ../doc/book/admin/disaster_recovery.rst:35
msgid ""
"Set up a replacement for the crashed master on a spare host, with "
":ref:`replication <cfg_replication-replication>` parameter set to replica"
" (effective master), so it begins to catch up with the new master’s "
"state. The new instance should have :ref:`box.cfg.read_only <cfg_basic-"
"read_only>` parameter set to *true*."
msgstr ""
"Настройте на свободной машине замену вышедшему из строя мастеру, "
"установив параметру :ref:`replication <cfg_replication-replication>` в "
"качестве значения URI реплики (которая в данный момент выполняет роль "
"мастера), чтобы новая реплика начала синхронизироваться с текущим "
"мастером. Значение параметра :ref:`box.cfg.read_only <cfg_basic-"
"read_only>` в новом экземпляре должно быть установлено на *true*."

#: ../doc/book/admin/disaster_recovery.rst:41
msgid ""
"You lose the few transactions in the master :ref:`write ahead log file "
"<index-box_persistence>`, which it may have not transferred to the "
"replica before crash. If you were able to salvage the master .xlog file, "
"you may be able to recover these. In order to do it:"
msgstr ""
"Все немногочисленные транзакции в :ref:`WAL-файле <index-"
"box_persistence>` мастера, которые он не успел передать реплике до выхода"
"  из строя, будут потеряны. Однако если удастся получить .xlog-файл "
"мастера, их можно будет восстановить. Для этого:"

#: ../doc/book/admin/disaster_recovery.rst:46
msgid ""
"Find out the position of the crashed master, as reflected on the new "
"master."
msgstr ""
"Узнайте позицию вышедшего из строя мастера -- эта информация доступна из "
"нового мастера."

#: ../doc/book/admin/disaster_recovery.rst:48
msgid ""
"Find out instance UUID from the crashed master :ref:`xlog <internals-"
"wal>`:"
msgstr ""
"Посмотрите UUID экземпляра в :ref:`xlog-файле <internals-wal>` вышедшего "
"из строя мастера:"

#: ../doc/book/admin/disaster_recovery.rst:50
msgid ""
"$ head -5 *.xlog | grep Instance\n"
"Instance: ed607cad-8b6d-48d8-ba0b-dae371b79155"
msgstr ""
"$ head -5 *.xlog | grep Instance\n"
"Instance: ed607cad-8b6d-48d8-ba0b-dae371b79155"

#: ../doc/book/admin/disaster_recovery.rst:55
msgid "On the new master, use the UUID to find the position:"
msgstr "Используйте этот UUID на новом мастере для поиска позиции:"

#: ../doc/book/admin/disaster_recovery.rst:57
msgid ""
"tarantool> box.info.vclock[box.space._cluster.index.uuid:select"
"{'ed607cad-8b6d-48d8-ba0b-dae371b79155'}[1][1]]\n"
"---\n"
"- 23425\n"
"<...>"
msgstr ""
"tarantool> box.info.vclock[box.space._cluster.index.uuid:select"
"{'ed607cad-8b6d-48d8-ba0b-dae371b79155'}[1][1]]\n"
"---\n"
"- 23425\n"
"<...>"

#: ../doc/book/admin/disaster_recovery.rst:64
msgid ""
"Play the records from the crashed .xlog to the new master, starting from "
"the new master position:"
msgstr ""
"Запишите транзакции из .xlog-файла вышедшего из строя мастера в новый "
"мастер, начиная с позиции нового мастера:"

#: ../doc/book/admin/disaster_recovery.rst:67
msgid ""
"Issue this request locally at the new master's machine to find out "
"instance ID of the new master:"
msgstr ""
"Локально выполните эту команду на новом мастере, чтобы узнать его ID "
"экземпляра:"

#: ../doc/book/admin/disaster_recovery.rst:70
#: ../doc/book/replication/repl_architecture.rst:92
msgid ""
"tarantool> box.space._cluster:select{}\n"
"---\n"
"- - [1, '88580b5c-4474-43ab-bd2b-2409a9af80d2']\n"
"..."
msgstr ""
"tarantool> box.space._cluster:select{}\n"
"---\n"
"- - [1, '88580b5c-4474-43ab-bd2b-2409a9af80d2']\n"
"..."

#: ../doc/book/admin/disaster_recovery.rst:77
msgid "Play the records to the new master:"
msgstr "Запишите транзакции в новый мастер:"

#: ../doc/book/admin/disaster_recovery.rst:79
msgid "$ tarantoolctl <new_master_uri> <xlog_file> play --from 23425 --replica 1"
msgstr ""
"$ tarantoolctl <uri_нового_мастера> <xlog_файл> play --from 23425 "
"--replica 1"

#: ../doc/book/admin/disaster_recovery.rst:87
msgid "Master-master"
msgstr "Мастер-мастер"

#: ../doc/book/admin/disaster_recovery.rst:89
msgid "Configuration: Two masters."
msgstr "Конфигурация: два мастера."

#: ../doc/book/admin/disaster_recovery.rst:91
msgid "Problem: Master#1 has crashed."
msgstr "Проблема: мастер #1 вышел из строя."

#: ../doc/book/admin/disaster_recovery.rst:95
msgid "Let the load be handled by master#2 (effective master) alone."
msgstr "Пусть вся нагрузка идет только на мастер #2 (действующий мастер)."

#: ../doc/book/admin/disaster_recovery.rst:97
msgid ""
"2. Follow the same steps as in the :ref:`master-replica <admin-"
"disaster_recovery-master_replica>` recovery scenario to create a new "
"master and salvage lost data."
msgstr ""
"2. Создайте новый мастер и восстановите данные, проделав те же шаги, что "
"и в сценарии для конфигурации :ref:`мастер-реплика <admin-"
"disaster_recovery-master_replica>`."

#: ../doc/book/admin/disaster_recovery.rst:105
msgid "Data loss"
msgstr "Потеря данных"

#: ../doc/book/admin/disaster_recovery.rst:107
msgid "Configuration: Master-master or master-replica."
msgstr "Конфигурация: мастер-мастер или мастер-реплика."

#: ../doc/book/admin/disaster_recovery.rst:109
msgid ""
"Problem: Data was deleted at one master and this data loss was propagated"
" to the other node (master or replica)."
msgstr ""
"Проблема: данные были удалены на одном мастере, а затем эти изменения "
"реплицировались на другом узле (мастере или реплике)."

#: ../doc/book/admin/disaster_recovery.rst:112
msgid ""
"The following steps are applicable only to data in memtx storage engine. "
"Your actions:"
msgstr ""
"Эта инструкция применима только для данных, хранящихся на движке memtx. "
"План действий:"

#: ../doc/book/admin/disaster_recovery.rst:115
msgid ""
"Put all nodes in :ref:`read-only mode <cfg_basic-read_only>` and disable "
"deletion of expired checkpoints with :ref:`box.backup.start() <admin-"
"backups-backup_start>`. This will prevent the Tarantool garbage collector"
" from removing files made with older checkpoints until "
":ref:`box.backup.stop() <admin-backups-backup_start>` is called."
msgstr ""
"Перевести все узлы в режим :ref:`read-only <cfg_basic-read_only>` и не "
"разрешать функции :ref:`box.backup.start() <admin-backups-backup_start>` "
"удалять старые контрольные точки. Это не даст сборщику мусора в Tarantool"
" удалять файлы, созданные во время предыдущих контрольных точек, до тех "
"пор пока не будет вызвана функция :ref:`box.backup.stop() <admin-backups-"
"backup_start>`."

#: ../doc/book/admin/disaster_recovery.rst:120
msgid ""
"Get the latest valid :ref:`.snap file <internals-snapshot>` and use "
"``tarantoolctl cat`` command to calculate at which lsn the data loss "
"occurred."
msgstr ""
"Возьмите последний корректный :ref:`.snap-файл <internals-snapshot>` и, "
"используя команду ``tarantoolctl cat``, выясните, на каком именно lsn "
"произошла потеря данных."

#: ../doc/book/admin/disaster_recovery.rst:123
msgid ""
"Start a new instance (instance#1) and use ``tarantoolctl play`` command "
"to play to it the contents of .snap/.xlog files up to the calculated lsn."
msgstr ""
"Запустите новый экземпляр (экземпляр #1) и с помощью команды "
"``tarantoolctl play`` скопируйте в него содержимое .snap/.xlog-файлов "
"вплоть до вычисленного lsn."

#: ../doc/book/admin/disaster_recovery.rst:126
msgid "Bootstrap a new replica from the recovered master (instance#1)."
msgstr ""
"Настройте новую реплику с помощью восстановленного мастера (экземпляра "
"#1)."

#: ../doc/book/admin/index.rst:5
msgid "Server administration"
msgstr "Администрирование серверной части"

#: ../doc/book/admin/index.rst:7
msgid "Tarantool is designed to have multiple running instances on the same host."
msgstr ""
"Tarantool устроен таким образом, что возможно запустить несколько "
"экземпляров программы на одном компьютере."

#: ../doc/book/admin/index.rst:9
msgid ""
"Here we show how to administer Tarantool instances using any of the "
"following utilities:"
msgstr ""
"Здесь мы показываем, как администрировать экземпляры Tarantool’а с "
"помощью любой из следующих утилит:"

#: ../doc/book/admin/index.rst:12
msgid "``systemd`` native utilities, or"
msgstr "встроенные утилиты ``systemd`` или"

#: ../doc/book/admin/index.rst:13
msgid ""
":ref:`tarantoolctl <tarantoolctl>`, a utility shipped and installed as "
"part of Tarantool distribution."
msgstr ""
":ref:`tarantoolctl <tarantoolctl>`, утилита, поставляемая и "
"устанавливаемая вместе с дистрибутивом Tarantool’а."

#: ../doc/book/admin/index.rst:18
msgid "Unlike the rest of this manual, here we use system-wide paths."
msgstr ""
"В отличие от остальной части руководства, в этой главе мы используем "
"общесистемные пути."

#: ../doc/book/admin/index.rst:19
msgid "Console examples here are for Fedora."
msgstr "Здесь мы приводим примеры консольного вывода для Fedora."

#: ../doc/book/admin/index.rst:21 ../doc/book/replication/index.rst:11
msgid "This chapter includes the following sections:"
msgstr "Эта глава включает в себя следующие разделы:"

#: ../doc/book/admin/instance_config.rst:5
msgid "Instance configuration"
msgstr "Настройка экземпляров Tarantool’а"

#: ../doc/book/admin/instance_config.rst:7
msgid "For each Tarantool instance, you need two files:"
msgstr "Для каждого экземпляра Tarantool’а понадобится два файла:"

#: ../doc/book/admin/instance_config.rst:9
msgid ""
"[Optional] An :ref:`application file <app_server-launching_app>` with "
"instance-specific logic. Put this file into the ``/usr/share/tarantool/``"
" directory."
msgstr ""
"[Необязательный] :ref:`Файл приложения <app_server-launching_app>`, "
"содержащий логику данного экземпляра. Поместите его в папку "
"``/usr/share/tarantool/``."

#: ../doc/book/admin/instance_config.rst:13
msgid ""
"For example, ``/usr/share/tarantool/my_app.lua`` (here we implement it as"
" a :ref:`Lua module <app_server-modules>` that bootstraps the database "
"and exports ``start()`` function for API calls):"
msgstr ""
"Например, ``/usr/share/tarantool/my_app.lua`` (здесь мы реализуем его как"
"  :ref:`Lua-модуль <app_server-modules>`, который запускает базу данных и"
" экспортирует функцию ``start()`` для API -вызовов):"

#: ../doc/book/admin/instance_config.rst:17
msgid ""
"local function start()\n"
"    box.schema.space.create(\"somedata\")\n"
"    box.space.somedata:create_index(\"primary\")\n"
"    <...>\n"
"end\n"
"\n"
"return {\n"
"  start = start;\n"
"}"
msgstr ""
"local function start()\n"
"    box.schema.space.create(\"somedata\")\n"
"    box.space.somedata:create_index(\"primary\")\n"
"    <...>\n"
"end\n"
"\n"
"return {\n"
"  start = start;\n"
"}"

#: ../doc/book/admin/instance_config.rst:29
msgid ""
"An :ref:`instance file <admin-instance_file>` with instance-specific "
"initialization logic and parameters. Put this file, or a symlink to it, "
"into the **instance directory** (see :ref:`instance_dir <admin-"
"instance_dir>` parameter in ``tarantoolctl`` configuration file)."
msgstr ""
":ref:`Файл экземпляра <admin-instance_file>`, содержащий логику и "
"параметры инициализации данного экземпляра. Поместите этот файл или "
"символьную ссылку на него в **директорию экземпляра** (см. параметр "
":ref:`instance_dir <admin-instance_dir>` в конфигурационном файле "
"``tarantoolctl``)."

#: ../doc/book/admin/instance_config.rst:35
msgid ""
"For example, ``/etc/tarantool/instances.enabled/my_app.lua`` (here we "
"load ``my_app.lua`` module and make a call to ``start()`` function from "
"that module):"
msgstr ""
"Например, ``/etc/tarantool/instances.enabled/my_app.lua`` (здесь мы "
"загружаем модуль ``my_app.lua`` и вызываем из него функцию ``start()``):"

#: ../doc/book/admin/instance_config.rst:39
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"box.cfg {\n"
"    listen = 3301;\n"
"}\n"
"\n"
"-- load my_app module and call start() function\n"
"-- with some app options controlled by sysadmins\n"
"local m = require('my_app').start({...})"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"box.cfg {\n"
"    listen = 3301;\n"
"}\n"
"\n"
"-- загрузить модуль my_app и вызвать функцию start()\n"
"-- некоторые опции приложения под контролем сисадминов\n"
"local m = require('my_app').start({...})"

#: ../doc/book/admin/instance_config.rst:55
msgid "Instance file"
msgstr "Файл экземпляра"

#: ../doc/book/admin/instance_config.rst:57
msgid ""
"After this short introduction, you may wonder what an instance file is, "
"what it is for, and how ``tarantoolctl`` uses it. After all, Tarantool is"
" an application server, so why not start the application stored in "
"``/usr/share/tarantool`` directly?"
msgstr ""
"После столь краткого предисловия может возникнуть вопрос: что из себя "
"представляет файл экземпляра, для чего он нужен и как ``tarantoolctl`` "
"использует его? Если Tarantool -- это сервер приложений, так почему бы не"
" запускать хранящееся в ``/usr/share/tarantool`` приложение напрямую?"

#: ../doc/book/admin/instance_config.rst:62
msgid ""
"A typical Tarantool application is not a script, but a daemon running in "
"background mode and processing requests, usually sent to it over a TCP/IP"
" socket. This daemon needs to be started automatically when the operating"
" system starts, and managed with the operating system standard tools for "
"service management -- such as ``systemd`` or ``init.d``. To serve this "
"very purpose, we created **instance files**."
msgstr ""
"Типичное приложение для Tarantool -- это не скрипт, а демон, запущенный в"
" фоновом режиме и обрабатывающий запросы, которые, как правило, "
"посылаются  через TCP/IP-сокет. Необходимо запускать этот демон со "
"стартом операционной системы и управлять им с помощью стандартных средств"
" операционной системы для управления сервисами -- таких как ``systemd`` "
"или ``init.d``. С этой целью и были созданы **файлы экземпляра**."

#: ../doc/book/admin/instance_config.rst:69
msgid ""
"You can have more than one instance file. For example, a single "
"application in ``/usr/share/tarantool`` can run in multiple instances, "
"each of them having its own instance file. Or you can have multiple "
"applications in ``/usr/share/tarantool`` -- again, each of them having "
"its own instance file."
msgstr ""
"Файлов экземпляра может быть больше одного. Например, одно и то же "
"приложение в ``/usr/share/tarantool`` может быть запущено на нескольких "
"экземплярах Tarantool'а, у каждого из которых есть свой файл экземпляра. "
"Или в ``/usr/share/tarantool`` может быть несколько приложений, и на "
"каждое из них будет опять же приходиться свой файл экземпляра."

#: ../doc/book/admin/instance_config.rst:74
msgid ""
"An instance file is typically created by a system administrator. An "
"application file is often provided by a developer, in a Lua rock or an "
"rpm/deb package."
msgstr ""
"Обычно файл экземпляра создает системный администратор, а файл приложения"
"  предоставляет разработчик в Lua-модуле или rpm/deb-пакете."

#: ../doc/book/admin/instance_config.rst:77
msgid ""
"An instance file is designed to not differ in any way from a Lua "
"application. It must, however, configure the database, i.e. contain a "
"call to :ref:`box.cfg{} <box_introspection-box_cfg>` somewhere in it, "
"because it’s the only way to turn a Tarantool script into a background "
"process, and ``tarantoolctl`` is a tool to manage background processes. "
"Other than that, an instance file may contain arbitrary Lua code, and, in"
" theory, even include the entire application business logic in it. We, "
"however, do not recommend this, since it clutters the instance file and "
"leads to unnecessary copy-paste when you need to run multiple instances "
"of an application."
msgstr ""
"По своему устройству файл экземпляра ничем не отличается от "
"Lua-приложения. Однако с его помощью должна настраиваться база данных, "
"поэтому в нем должен содержаться вызов :ref:`box.cfg{} "
"<box_introspection-box_cfg>`, потому что это единственный способ "
"превратить Tarantool-скрипт в фоновый процесс, а ``tarantoolctl`` -- это "
"инструмент для управления фоновыми процессами. За исключением этого "
"вызова, файл экземпляра может содержать произвольный код на Lua и, "
"теоретически, даже всю бизнес-логику приложения. Однако мы не рекомендуем"
"  хранить весь код в файле экземпляра, потому что это приводит как к "
"замусориванию самого файла, так и к ненужному копированию кода при "
"необходимости запустить несколько экземпляров приложения."

#: ../doc/book/admin/instance_config.rst:91
msgid "`tarantoolctl` configuration file"
msgstr "Конфигурационный файл `tarantoolctl`"

#: ../doc/book/admin/instance_config.rst:93
msgid ""
"While instance files contain instance configuration, the ``tarantoolctl``"
" configuration file contains the configuration that ``tarantoolctl`` uses"
" to override instance configuration. In other words, it contains system-"
"wide configuration defaults. If ``tarantoolctl`` fails to find this file "
"with the method described in section :ref:`Starting/stopping an instance "
"<admin-start_stop_instance>`, it uses default settings."
msgstr ""
"Файлы экземпляра содержат конфигурацию экземпляра, тогда как "
"конфигурационный файл ``tarantoolctl`` содержит конфигурацию, которую "
"``tarantoolctl`` использует, чтобы переопределять конфигурацию "
"экземпляров. Другими словами, он содержит общесистемную конфигурацию по "
"умолчанию. Если ``tarantoolctl`` не сможет обнаружить этот файл, "
"используя метод, описанный в разделе :ref:`Запуск/остановка экземпляра "
"<admin-start_stop_instance>`, будут использованы настройки по умолчанию."

#: ../doc/book/admin/instance_config.rst:101
msgid ""
"Most of the parameters are similar to those used by :ref:`box.cfg{} "
"<box_introspection-box_cfg>`. Here are the default settings (possibly "
"installed in ``/etc/default/tarantool`` or ``/etc/sysconfig/tarantool`` "
"as part of Tarantool distribution -- see OS-specific default paths in "
":ref:`Notes for operating systems <admin-os_notes>`):"
msgstr ""
"Большинство параметров схожи с теми, которые используются в "
":ref:`box.cfg{} <box_introspection-box_cfg>`. Ниже даны настройки по "
"умолчанию (могут быть установлены в ``/etc/default/tarantool`` или "
"``/etc/sysconfig/tarantool`` как часть дистрибутива Tarantool'а -- см. "
"пути по умолчанию для разных ОС в :ref:`Замечаниях по поводу некоторых "
"операционных систем <admin-os_notes>`):"

#: ../doc/book/admin/instance_config.rst:107
#, fuzzy
msgid ""
"default_cfg = {\n"
"    pid_file  = \"/var/run/tarantool\",\n"
"    wal_dir   = \"/var/lib/tarantool\",\n"
"    memtx_dir = \"/var/lib/tarantool\",\n"
"    vinyl_dir = \"/var/lib/tarantool\",\n"
"    log       = \"/var/log/tarantool\",\n"
"    username  = \"tarantool\",\n"
"    language  = \"Lua\",\n"
"}\n"
"instance_dir = \"/etc/tarantool/instances.enabled\""
msgstr ""
"default_cfg = {\n"
"    pid_file  = \"/var/run/tarantool\",\n"
"    wal_dir   = \"/var/lib/tarantool\",\n"
"    memtx_dir = \"/var/lib/tarantool\",\n"
"    vinyl_dir = \"/var/lib/tarantool\",\n"
"    log       = \"/var/log/tarantool\",\n"
"    username  = \"tarantool\",\n"
"}\n"
"instance_dir = \"/etc/tarantool/instances.enabled\""

#: ../doc/book/admin/instance_config.rst
msgid "``pid_file``"
msgstr "``pid_file``"

#: ../doc/book/admin/instance_config.rst
msgid ""
"Directory for the pid file and control-socket file; ``tarantoolctl`` will"
" add “/instance_name” to the directory name."
msgstr ""
"Директория, где хранятся pid-файл и socket-файл; ``tarantoolctl`` "
"добавляет “/имя_экземпляра” к имени директории."

#: ../doc/book/admin/instance_config.rst
msgid "``wal_dir``"
msgstr "``wal_dir``"

#: ../doc/book/admin/instance_config.rst
msgid ""
"Directory for write-ahead .xlog files; ``tarantoolctl`` will add "
"\"/instance_name\" to the directory name."
msgstr ""
"Директория, где хранятся .xlog-файлы; ``tarantoolctl`` добавляет "
"“/имя_экземпляра” к имени директории."

#: ../doc/book/admin/instance_config.rst
msgid "``memtx_dir``"
msgstr "``memtx_dir``"

#: ../doc/book/admin/instance_config.rst
msgid ""
"Directory for snapshot .snap files; ``tarantoolctl`` will add "
"\"/instance_name\" to the directory name."
msgstr ""
"Директория, где хранятся .snap-файлы; ``tarantoolctl`` добавляет "
"“/имя_экземпляра” к имени директории."

#: ../doc/book/admin/instance_config.rst
msgid "``vinyl_dir``"
msgstr "``vinyl_dir``"

#: ../doc/book/admin/instance_config.rst
msgid ""
"Directory for vinyl files; ``tarantoolctl`` will add \"/instance_name\" "
"to the directory name."
msgstr ""
"Директория, где хранятся vinyl-файлы; ``tarantoolctl`` добавляет "
"“/имя_экземпляра” к имени директории."

#: ../doc/book/admin/instance_config.rst
msgid "``log``"
msgstr "``log``"

#: ../doc/book/admin/instance_config.rst
msgid ""
"The place where the application log will go; ``tarantoolctl`` will add "
"\"/instance_name.log\" to the name."
msgstr ""
"Директория, где хранятся файлы журнала с сообщениями от "
"Tarantool-приложения; ``tarantoolctl`` добавляет “/имя_экземпляра” к "
"имени директории."

#: ../doc/book/admin/instance_config.rst
msgid "``username``"
msgstr "``username``"

#: ../doc/book/admin/instance_config.rst
msgid ""
"The user that runs the Tarantool instance. This is the operating-system "
"user name rather than the Tarantool-client user name. Tarantool will "
"change its effective user to this user after becoming a daemon."
msgstr ""
"Пользователь, запускающий экземпляр Tarantool'а. Это пользователь "
"операционной системы, а не Tarantool-клиента. Став демоном, Tarantool "
"сменит своего пользователя на указанного."

#: ../doc/book/admin/instance_config.rst
#, fuzzy
msgid "``language``"
msgstr "``name``,"

#: ../doc/book/admin/instance_config.rst
msgid ""
"The :ref:`interactive console <interactive_console>` language. Can be "
"either ``Lua`` or ``SQL``."
msgstr ""

#: ../doc/book/admin/instance_config.rst
msgid "``instance_dir``"
msgstr "``instance_dir``"

#: ../doc/book/admin/instance_config.rst
msgid ""
"The directory where all instance files for this host are stored. Put "
"instance files in this directory, or create symbolic links."
msgstr ""
"Директория, где хранятся все файлы экземпляра для данного компьютера. "
"Поместите сюда файлы экземпляра или создайте символьные ссылки на них."

#: ../doc/book/admin/instance_config.rst:156
msgid ""
"The default instance directory depends on Tarantool's ``WITH_SYSVINIT`` "
"build option: when ON, it is ``/etc/tarantool/instances.enabled``, "
"otherwise (OFF or not set) it is ``/etc/tarantool/instances.available``. "
"The latter case is typical for Tarantool builds for Linux distros with "
"``systemd``."
msgstr ""
"Директория с экземплярами, которая используется по умолчанию, зависит от "
"параметра ``WITH_SYSVINIT`` сборки Tarantool'а: когда его значение "
"\"ON\", то ``/etc/tarantool/instances.enabled``, в противном случае "
"(\"OFF\" или значение не установлено), то "
"``/etc/tarantool/instances.available``. Последний случай характерен для "
"сборок Tarantool'а для дистрибутивов Linux с ``systemd``."

#: ../doc/book/admin/instance_config.rst:162
msgid "To check the build options, say ``tarantool --version``."
msgstr "Для проверки параметров сборки выполните команду ``tarantool --version``."

#: ../doc/book/admin/instance_config.rst:164
#, fuzzy
msgid ""
"As a full-featured example, you can take `example.lua "
"<https://github.com/tarantool/tarantool/blob/2.1/extra/dist/example.lua>`_"
" script that ships with Tarantool and defines all configuration options."
msgstr ""
"В качестве полноценного примера можно использовать скрипт `example.lua "
"<https://github.com/tarantool/tarantool/blob/1.10/extra/dist/example.lua>`_,"
"  который поставляется вместе с Tarantool и задает все конфигурационные "
"параметры."

#: ../doc/book/admin/logs.rst:5
msgid "Logs"
msgstr "Журналирование"

#: ../doc/book/admin/logs.rst:7
msgid ""
"Tarantool logs important events to a file, e.g. "
"``/var/log/tarantool/my_app.log``. To build the log file path, "
"``tarantoolctl`` takes the instance name, prepends the instance directory"
" and appends “.log” extension."
msgstr ""
"Все важные события Tarantool записывает в файл журнала -- например, в "
"``/var/log/tarantool/my_app.log``.  ``tarantoolctl`` строит путь до файла"
"  журнала следующим образом: \"путь до директории с экземплярами\" + "
"\"имя  экземпляра\" + \".lua\"."

#: ../doc/book/admin/logs.rst:11
msgid "Let’s write something to the log file:"
msgstr "Запишем что-нибудь в файл журнала:"

#: ../doc/book/admin/logs.rst:13
msgid ""
"$ tarantoolctl enter my_app\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/my_app.control\n"
"unix/:/var/run/tarantool/my_app.control> require('log').info(\"Hello for "
"the manual readers\")\n"
"---\n"
"..."
msgstr ""
"$ tarantoolctl enter my_app\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/my_app.control\n"
"unix/:/var/run/tarantool/my_app.control> require('log').info(\"Hello for "
"the manual readers\")\n"
"---\n"
"..."

#: ../doc/book/admin/logs.rst:21
msgid "Then check the logs:"
msgstr "Затем проверим содержимое журнала:"

#: ../doc/book/admin/logs.rst:23
msgid ""
"$ tail /var/log/tarantool/my_app.log\n"
"2017-04-04 15:54:04.977 [29255] main/101/tarantoolctl C> version "
"1.7.3-382-g68ef3f6a9\n"
"2017-04-04 15:54:04.977 [29255] main/101/tarantoolctl C> log level 5\n"
"2017-04-04 15:54:04.978 [29255] main/101/tarantoolctl I> mapping "
"134217728 bytes for tuple arena...\n"
"2017-04-04 15:54:04.985 [29255] iproto/101/main I> binary: bound to "
"[::1]:3301\n"
"2017-04-04 15:54:04.986 [29255] main/101/tarantoolctl I> recovery start\n"
"2017-04-04 15:54:04.986 [29255] main/101/tarantoolctl I> recovering from "
"`/var/lib/tarantool/my_app/00000000000000000000.snap'\n"
"2017-04-04 15:54:04.988 [29255] main/101/tarantoolctl I> ready to accept "
"requests\n"
"2017-04-04 15:54:04.988 [29255] main/101/tarantoolctl I> set "
"'checkpoint_interval' configuration option to 3600\n"
"2017-04-04 15:54:04.988 [29255] main/101/my_app I> Run console at "
"unix/:/var/run/tarantool/my_app.control\n"
"2017-04-04 15:54:04.989 [29255] main/106/console/unix/:/var/ I> started\n"
"2017-04-04 15:54:04.989 [29255] main C> entering the event loop\n"
"2017-04-04 15:54:47.147 [29255] main/107/console/unix/: I> Hello for the "
"manual readers"
msgstr ""
"$ tail /var/log/tarantool/my_app.log\n"
"2017-04-04 15:54:04.977 [29255] main/101/tarantoolctl C> version "
"1.7.3-382-g68ef3f6a9\n"
"2017-04-04 15:54:04.977 [29255] main/101/tarantoolctl C> log level 5\n"
"2017-04-04 15:54:04.978 [29255] main/101/tarantoolctl I> mapping "
"134217728 bytes for tuple arena...\n"
"2017-04-04 15:54:04.985 [29255] iproto/101/main I> binary: bound to "
"[::1]:3301\n"
"2017-04-04 15:54:04.986 [29255] main/101/tarantoolctl I> recovery start\n"
"2017-04-04 15:54:04.986 [29255] main/101/tarantoolctl I> recovering from "
"`/var/lib/tarantool/my_app/00000000000000000000.snap'\n"
"2017-04-04 15:54:04.988 [29255] main/101/tarantoolctl I> ready to accept "
"requests\n"
"2017-04-04 15:54:04.988 [29255] main/101/tarantoolctl I> set "
"'checkpoint_interval' configuration option to 3600\n"
"2017-04-04 15:54:04.988 [29255] main/101/my_app I> Run console at "
"unix/:/var/run/tarantool/my_app.control\n"
"2017-04-04 15:54:04.989 [29255] main/106/console/unix/:/var/ I> started\n"
"2017-04-04 15:54:04.989 [29255] main C> entering the event loop\n"
"2017-04-04 15:54:47.147 [29255] main/107/console/unix/: I> Hello for the "
"manual readers"

#: ../doc/book/admin/logs.rst:39
msgid ""
"When logging to a file, the system administrator must ensure logs are "
"rotated timely and do not take up all the available disk space. With "
"``tarantoolctl``, log rotation is pre-configured to use ``logrotate`` "
"program, which you must have installed."
msgstr ""
"При включенном журналировании системный администратор должен обеспечивать"
"  своевременную ротацию журналов, чтобы избежать переполнения дискового "
"пространства. Ротация журналов в ``tarantoolctl`` производится с помощью "
"программы ``logrotate``, которую необходимо установить заранее."

#: ../doc/book/admin/logs.rst:44
msgid ""
"File ``/etc/logrotate.d/tarantool`` is part of the standard Tarantool "
"distribution, and you can modify it to change the default behavior. This "
"is what this file is usually like:"
msgstr ""
"Файл ``/etc/logrotate.d/tarantool`` поставляется со стандартным "
"дистрибутивом Tarantool. Его можно редактировать для изменения поведения "
"по умолчанию. Содержимое файла обычно выглядит так:"

#: ../doc/book/admin/logs.rst:48
#, python-format
msgid ""
"/var/log/tarantool/*.log {\n"
"    daily\n"
"    size 512k\n"
"    missingok\n"
"    rotate 10\n"
"    compress\n"
"    delaycompress\n"
"    create 0640 tarantool adm\n"
"    postrotate\n"
"        /usr/bin/tarantoolctl logrotate `basename ${1%%.*}`\n"
"    endscript\n"
"}"
msgstr ""
"/var/log/tarantool/*.log {\n"
"    daily\n"
"    size 512k\n"
"    missingok\n"
"    rotate 10\n"
"    compress\n"
"    delaycompress\n"
"    create 0640 tarantool adm\n"
"    postrotate\n"
"        /usr/bin/tarantoolctl logrotate `basename ${1%%.*}`\n"
"    endscript\n"
"}"

#: ../doc/book/admin/logs.rst:63
msgid ""
"If you use a different log rotation program, you can invoke "
"``tarantoolctl logrotate`` command to request instances to reopen their "
"log files after they were moved by the program of your choice."
msgstr ""
"Если вы используете другую программу для ротации журналов, можно вызвать "
"команду ``tarantoolctl logrotate``, чтобы экземпляры переоткрыли свои "
"файлы журнала после того, как выбранная вами программа переместила их."

#: ../doc/book/admin/logs.rst:67
msgid ""
"Tarantool can write its logs to a log file, ``syslog`` or a program "
"specified in the configuration file (see :ref:`log <cfg_logging-log>` "
"parameter)."
msgstr ""
"Tarantool может писать события в файл журнала, ``syslog`` или программу, "
"указанную в конфигурационном файле (см. параметр :ref:`log <cfg_logging-"
"log>`)."

#: ../doc/book/admin/logs.rst:70
msgid ""
"By default, logs are written to a file as defined in ``tarantoolctl`` "
"defaults. ``tarantoolctl`` automatically detects if an instance is using "
"``syslog`` or an external program for logging, and does not override the "
"log destination in this case. In such configurations, log rotation is "
"usually handled by the external program used for logging. So, "
"``tarantoolctl logrotate`` command works only if logging-into-file is "
"enabled in the instance file."
msgstr ""
"По умолчанию запись производится в файл журнала, как указано в исходных "
"настройках ``tarantoolctl``. Скрипт ``tarantoolctl`` автоматически "
"определяет, когда экземпляр использует для журналирования ``syslog`` или "
"внешнюю программу, и не изменяет то, куда ведется запись. В таких случаях"
"  ротацию журналов обычно выполняет та же программа, которая используется"
" для журналирования. Именно поэтому команда ``tarantoolctl logrotate`` "
"сработает только в том случае, если в файле экземпляра включена "
"возможность вести запись в файл."

#: ../doc/book/admin/os_notes.rst:5
msgid "Notes for operating systems"
msgstr "Замечания по поводу некоторых операционных систем"

#: ../doc/book/admin/os_notes.rst:11
msgid "Mac OS"
msgstr "Mac OS"

#: ../doc/book/admin/os_notes.rst:13
msgid ""
"On Mac OS, you can administer Tarantool instances only with "
"``tarantoolctl``. No native system tools are supported."
msgstr ""
"Администрирование экземпляров Tarantool'а на Mac OS возможно только с "
"помощью ``tarantoolctl``. Встроенные системные инструменты не "
"поддерживаются."

#: ../doc/book/admin/os_notes.rst:20
msgid "FreeBSD"
msgstr "FreeBSD"

#: ../doc/book/admin/os_notes.rst:22
msgid ""
"To make ``tarantoolctl`` work along with ``init.d`` utilities on FreeBSD,"
" use paths other than those suggested in :ref:`Instance configuration "
"<admin-instance_config>`. Instead of ``/usr/share/tarantool/`` directory,"
" use ``/usr/local/etc/tarantool/`` and create the following "
"subdirectories:"
msgstr ""
"Чтобы ``tarantoolctl`` и утилиты ``init.d`` работали на FreeBSD, "
"используйте пути, отличные от предложенных в разделе :ref:`Настройка "
"экземпляров Tarantool’а <admin-instance_config>`. Используйте "
"``/usr/local/etc/tarantool/`` вместо ``/usr/share/tarantool/`` и создайте"
"  следующие поддиректории:"

#: ../doc/book/admin/os_notes.rst:28
msgid "``default`` for ``tarantoolctl`` defaults (see example below),"
msgstr ""
"``default`` для хранения настроек ``tarantoolctl`` по умолчанию (см. "
"пример ниже),"

#: ../doc/book/admin/os_notes.rst:29
msgid "``instances.available`` for all available instance files, and"
msgstr "``instances.available`` для хранения всех доступных файлов экземпляра, и"

#: ../doc/book/admin/os_notes.rst:30
msgid "``instances.enabled`` for instance files to be auto-started by sysvinit."
msgstr ""
"``instances.enabled`` для хранения файлов экземпляра, которые необходимо "
"запускать автоматически с помощью sysvinit."

#: ../doc/book/admin/os_notes.rst:32
msgid "Here is an example of ``tarantoolctl`` defaults on FreeBSD:"
msgstr "Так выглядят настройки ``tarantoolctl`` по умолчанию на FreeBSD:"

#: ../doc/book/admin/os_notes.rst:34
msgid ""
"default_cfg = {\n"
"    pid_file   = \"/var/run/tarantool\", -- "
"/var/run/tarantool/${INSTANCE}.pid\n"
"    wal_dir    = \"/var/db/tarantool\", -- /var/db/tarantool/${INSTANCE}/"
"\n"
"    snap_dir   = \"/var/db/tarantool\", -- /var/db/tarantool/${INSTANCE}\n"
"    vinyl_dir = \"/var/db/tarantool\", -- /var/db/tarantool/${INSTANCE}\n"
"    logger     = \"/var/log/tarantool\", -- "
"/var/log/tarantool/${INSTANCE}.log\n"
"    username   = \"tarantool\",\n"
"}\n"
"\n"
"-- instances.available - all available instances\n"
"-- instances.enabled - instances to autostart by sysvinit\n"
"instance_dir = \"/usr/local/etc/tarantool/instances.available\""
msgstr ""
"default_cfg = {\n"
"    pid_file   = \"/var/run/tarantool\", -- "
"/var/run/tarantool/${INSTANCE}.pid\n"
"    wal_dir    = \"/var/db/tarantool\", -- /var/db/tarantool/${INSTANCE}/"
"\n"
"    snap_dir   = \"/var/db/tarantool\", -- /var/db/tarantool/${INSTANCE}\n"
"    vinyl_dir = \"/var/db/tarantool\", -- /var/db/tarantool/${INSTANCE}\n"
"    logger     = \"/var/log/tarantool\", -- "
"/var/log/tarantool/${INSTANCE}.log\n"
"    username   = \"tarantool\",\n"
"}\n"
"\n"
"-- instances.available - все доступные экземпляры\n"
"-- instances.enabled - экземпляры для автоматического запуска через "
"sysvinit\n"
"instance_dir = \"/usr/local/etc/tarantool/instances.available\""

#: ../doc/book/admin/os_notes.rst:53
msgid "Gentoo Linux"
msgstr "Gentoo Linux"

#: ../doc/book/admin/os_notes.rst:55
msgid ""
"The section below is about a dev-db/tarantool package installed from the "
"official layman overlay (named ``tarantool``)."
msgstr ""
"В разделе ниже описывается пакет \"dev-db/tarantool\", установленный из "
"официального оверлея layman (под названием ``tarantool``)."

#: ../doc/book/admin/os_notes.rst:58
msgid ""
"The default instance directory is ``/etc/tarantool/instances.available``,"
" can be redefined in ``/etc/default/tarantool``."
msgstr ""
"По умолчанию с экземплярами используется директория "
"``/etc/tarantool/instances.available``,  ее можно переопределить в "
"``/etc/default/tarantool``."

#: ../doc/book/admin/os_notes.rst:61
msgid ""
"Tarantool instances can be managed (start/stop/reload/status/...) using "
"OpenRC. Consider the example how to create an OpenRC-managed instance:"
msgstr ""
"Управление экземплярами Tarantool'а "
"(запуск/остановка/перезагрузка/проверка статуса и т.д.) можно "
"осуществлять с помощью OpenRC. Рассмотрим пример, как создать экземпляр с"
" управлением OpenRC:"

#: ../doc/book/admin/os_notes.rst:64
msgid ""
"$ cd /etc/init.d\n"
"$ ln -s tarantool your_service_name\n"
"$ ln -s /usr/share/tarantool/your_service_name.lua "
"/etc/tarantool/instances.available/your_service_name.lua"
msgstr ""
"$ cd /etc/init.d\n"
"$ ln -s tarantool your_service_name\n"
"$ ln -s /usr/share/tarantool/your_service_name.lua "
"/etc/tarantool/instances.available/your_service_name.lua"

#: ../doc/book/admin/os_notes.rst:70
msgid "Checking that it works:"
msgstr "Проверяем, что работает:"

#: ../doc/book/admin/os_notes.rst:72
msgid ""
"$ /etc/init.d/your_service_name start\n"
"$ tail -f -n 100 /var/log/tarantool/your_service_name.log"
msgstr ""
"$ /etc/init.d/your_service_name start\n"
"$ tail -f -n 100 /var/log/tarantool/your_service_name.log"

#: ../doc/book/admin/security.rst:5
msgid "Security"
msgstr "Безопасность"

#: ../doc/book/admin/security.rst:7
msgid "Tarantool allows for two types of connections:"
msgstr "Tarantool разрешает два типа подключений:"

#: ../doc/book/admin/security.rst:9
msgid ""
"With :ref:`console.listen() <console-listen>` function from ``console`` "
"module, you can set up a port which can be used to open an administrative"
" console to the server. This is for administrators to connect to a "
"running instance and make requests. ``tarantoolctl`` invokes "
"``console.listen()`` to create a control socket for each started "
"instance."
msgstr ""
"Используя функцию :ref:`console.listen() <console-listen>` из модуля "
"``console``, можно настроить порт для подключения к серверной "
"административной консоли. Этот вариант для администраторов, которым "
"необходимо подключиться к работающему экземпляру и послать некоторые "
"запросы. ``tarantoolctl`` вызывает ``console.listen()``, чтобы создать "
"управляющий сокет для каждого запущенного экземпляра."

#: ../doc/book/admin/security.rst:15
msgid ""
"With :ref:`box.cfg{listen=...} <cfg_basic-listen>` parameter from ``box``"
" module, you can set up a binary port for connections which read and "
"write to the database or invoke stored procedures."
msgstr ""
"Используя параметр :ref:`box.cfg{listen=...} <cfg_basic-listen>` из "
"модуля ``box``, можно настроить бинарный порт для соединений, которые "
"читают и пишут в базу данных или вызывают хранимые процедуры."

#: ../doc/book/admin/security.rst:19
msgid "When you connect to an admin console:"
msgstr "Если вы подключены к административной консоли:"

#: ../doc/book/admin/security.rst:21
msgid "The client-server protocol is plain text."
msgstr "Клиент-серверный протокол -- это простой текст."

#: ../doc/book/admin/security.rst:22
msgid "No password is necessary."
msgstr "Пароль не требуется."

#: ../doc/book/admin/security.rst:23
msgid "The user is automatically 'admin'."
msgstr "Пользователь автоматически получает права администратора."

#: ../doc/book/admin/security.rst:24
msgid "Each command is fed directly to the built-in Lua interpreter."
msgstr "Каждая команда напрямую обрабатывается встроенным интерпретатором Lua."

#: ../doc/book/admin/security.rst:26
msgid ""
"Therefore you must set up ports for the admin console very cautiously. If"
" it is a TCP port, it should only be opened for a specific IP. Ideally, "
"it should not be a TCP port at all, it should be a Unix domain socket, so"
" that access to the server machine is required. Thus a typical port setup"
" for admin console is:"
msgstr ""
"Поэтому порты для административной консоли следует настраивать очень "
"осторожно. Если это TCP-порт, он должен быть открыть только для "
"определенного IP-адреса. В идеале вместо TCP-порта лучше настроить "
"доменный Unix-сокет, который требует наличие прав доступа к серверной "
"машине. Тогда типичная настройка порта для административной консоли будет"
"  выглядеть следующим образом:"

#: ../doc/book/admin/security.rst:31
msgid "console.listen('/var/lib/tarantool/socket_name.sock')"
msgstr "console.listen('/var/lib/tarantool/socket_name.sock')"

#: ../doc/book/admin/security.rst:35
msgid "and a typical connection :ref:`URI <index-uri>` is:"
msgstr "а типичный :ref:`URI <index-uri>` для соединения будет таким:"

#: ../doc/book/admin/security.rst:37
msgid "/var/lib/tarantool/socket_name.sock"
msgstr "/var/lib/tarantool/socket_name.sock"

#: ../doc/book/admin/security.rst:41
msgid ""
"if the listener has the privilege to write on ``/var/lib/tarantool`` and "
"the connector has the privilege to read on ``/var/lib/tarantool``. "
"Alternatively, to connect to an admin console of an instance started with"
" ``tarantoolctl``, use :ref:`tarantoolctl enter <admin-"
"executing_code_on_an_instance>`."
msgstr ""
"если у приемника событий есть права на запись в ``/var/lib/tarantool`` и "
"у коннектора есть права на чтение из ``/var/lib/tarantool``. Еще один "
"способ подключиться к административной консоли экземпляра, запущенного с "
"помощью ``tarantoolctl``, -- использовать  :ref:`tarantoolctl enter "
"<admin-executing_code_on_an_instance>`."

#: ../doc/book/admin/security.rst:46
msgid ""
"To find out whether a TCP port is a port for admin console, use "
"``telnet``. For example:"
msgstr ""
"Выяснить, является ли некоторый TCP-порт портом для административной "
"консоли, можно с помощью ``telnet``. Например:"

#: ../doc/book/admin/security.rst:49
#, fuzzy
msgid ""
"$ telnet 0 3303\n"
"Trying 0.0.0.0...\n"
"Connected to 0.\n"
"Escape character is '^]'.\n"
"Tarantool 2.1.0 (Lua console)\n"
"type 'help' for interactive help"
msgstr ""
"$ telnet 0 3303\n"
"Trying 0.0.0.0...\n"
"Connected to 0.\n"
"Escape character is '^]'.\n"
"Tarantool 1.10.0 (Lua console)\n"
"type 'help' for interactive help"

#: ../doc/book/admin/security.rst:58
msgid ""
"In this example, the response does not include the word \"binary\" and "
"does include the words \"Lua console\". Therefore it is clear that this "
"is a successful connection to a port for admin console, and you can now "
"enter admin requests on this terminal."
msgstr ""
"В этом примере в ответе от сервера нет слова \"binary\" и есть слова "
"\"Lua console\". Это значит, что мы успешно подключились к порту для "
"административной консоли и можем вводить администраторские запросы на "
"этом терминале."

#: ../doc/book/admin/security.rst:63
msgid "When you connect to a binary port:"
msgstr "Если вы подключены к бинарному порту:"

#: ../doc/book/admin/security.rst:65
msgid ""
"The client-server protocol is :ref:`binary <box_protocol-"
"iproto_protocol>`."
msgstr ""
"Клиент-серверный протокол -- :ref:`бинарный <box_protocol-"
"iproto_protocol>`."

#: ../doc/book/admin/security.rst:66
msgid "The user is automatically ':ref:`guest <authentication-users>`'."
msgstr ""
"Автоматически выбирается пользователь ':ref:`guest <authentication-"
"users>`'."

#: ../doc/book/admin/security.rst:67
msgid "To change the user, it’s necessary to authenticate."
msgstr "Для смены пользователя необходимо пройти аутентификацию."

#: ../doc/book/admin/security.rst:69
msgid ""
"For ease of use, ``tarantoolctl connect`` command automatically detects "
"the type of connection during handshake and uses :ref:`EVAL "
"<box_protocol-eval>` binary protocol command when it’s necessary to "
"execute Lua commands over a binary connection. To execute EVAL, the "
"authenticated user must have global \"EXECUTE\" privilege."
msgstr ""
"Для удобства использования команда ``tarantoolctl connect`` автоматически"
"  определяет тип подключения при установке соединения и использует "
"команду  бинарного протокола :ref:`EVAL <box_protocol-eval>` для "
"выполнения Lua-команд по бинарному подключению. Чтобы выполнить команду "
"EVAL, аутентифицированный пользователь должен иметь глобальные "
"\"EXECUTE\"-права."

#: ../doc/book/admin/security.rst:75
msgid ""
"Therefore, when ``ssh`` access to the machine is not available, creating "
"a Tarantool user with global \"EXECUTE\" privilege and non-empty password"
" can be used to provide a system administrator **remote** access to an "
"instance."
msgstr ""
"Поэтому при невозможности подключиться к машине по ``ssh`` системный "
"администратор может получить **удаленный** доступ к экземпляру, создав "
"пользователя Tarantool с глобальными \"EXECUTE\"-правами и непустым "
"паролем."

#: ../doc/book/admin/server_introspection.rst:5
msgid "Server introspection"
msgstr "Просмотр состояния сервера"

#: ../doc/book/admin/server_introspection.rst:11
msgid "Using Tarantool as a client"
msgstr "Использование Tarantool'а в качестве клиента"

#: ../doc/book/admin/server_introspection.rst:13
msgid "Tarantool enters the interactive mode if:"
msgstr "Tarantool входит в интерактивный режим, если:"

#: ../doc/book/admin/server_introspection.rst:15
msgid ""
"you start Tarantool without an :ref:`instance file <admin-"
"instance_file>`, or"
msgstr "вы запускаете его без :ref:`файла экземпляра <admin-instance_file>`, либо"

#: ../doc/book/admin/server_introspection.rst:18
msgid "the instance file contains :ref:`console.start() <console-start>`."
msgstr ""
"в файле экземпляра содержится команда :ref:`console.start() <console-"
"start>`."

#: ../doc/book/admin/server_introspection.rst:20
msgid ""
"Tarantool displays a prompt (e.g. \"tarantool>\") and you can enter "
"requests. When used this way, Tarantool can be a client for a remote "
"server. See basic examples in :ref:`Getting started <getting_started>`."
msgstr ""
"Tarantool выводит приглашение командной строки (например, \"tarantool>\")"
" -- и вы можете посылать запросы. Если использовать Tarantool таким "
"образом, он может выступать клиентом для удаленного сервера, см. простые "
"примеры в :ref:`Руководстве для начинающих <getting_started>`."

#: ../doc/book/admin/server_introspection.rst:24
msgid ""
"The interactive mode is used by ``tarantoolctl`` to implement \"enter\" "
"and \"connect\" commands."
msgstr ""
"Скрипт ``tarantoolctl`` использует интерактивный режим для реализации "
"команд  \"enter\" и \"connect\"."

#: ../doc/book/admin/server_introspection.rst:31
msgid "Executing code on an instance"
msgstr "Выполнение кода на экземпляре Tarantool'а"

#: ../doc/book/admin/server_introspection.rst:33
msgid ""
"You can attach to an instance's :ref:`admin console <admin-security>` and"
" execute some Lua code using ``tarantoolctl``:"
msgstr ""
"Можно подключиться к :ref:`административной консоли <admin-security>` "
"экземпляра и выполнить некий Lua-код с помощью утилиты ``tarantoolctl``:"

#: ../doc/book/admin/server_introspection.rst:36
msgid ""
"$ # for local instances:\n"
"$ tarantoolctl enter my_app\n"
"/bin/tarantoolctl: Found my_app.lua in /etc/tarantool/instances.available"
"\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/my_app.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/my_app.control\n"
"unix/:/var/run/tarantool/my_app.control> 1 + 1\n"
"---\n"
"- 2\n"
"...\n"
"unix/:/var/run/tarantool/my_app.control>\n"
"\n"
"$ # for local and remote instances:\n"
"$ tarantoolctl connect username:password@127.0.0.1:3306"
msgstr ""
"$ # для локальных экземпляров:\n"
"$ tarantoolctl enter my_app\n"
"/bin/tarantoolctl: Found my_app.lua in /etc/tarantool/instances.available"
"\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/my_app.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/my_app.control\n"
"unix/:/var/run/tarantool/my_app.control> 1 + 1\n"
"---\n"
"- 2\n"
"...\n"
"unix/:/var/run/tarantool/my_app.control>\n"
"\n"
"$ # для локальных и удаленных экземпляров:\n"
"$ tarantoolctl connect username:password@127.0.0.1:3306"

#: ../doc/book/admin/server_introspection.rst:52
msgid ""
"You can also use ``tarantoolctl`` to execute Lua code on an instance "
"without attaching to its admin console. For example:"
msgstr ""
"Можно также использовать ``tarantoolctl`` для выполнения Lua-кода на "
"запущенном экземпляре Tarantool-сервера, не подключаясь к его "
"административной консоли. Например:"

#: ../doc/book/admin/server_introspection.rst:55
msgid ""
"$ # executing commands directly from the command line\n"
"$ <command> | tarantoolctl eval my_app\n"
"<...>\n"
"\n"
"$ # - OR -\n"
"\n"
"$ # executing commands from a script file\n"
"$ tarantoolctl eval my_app script.lua\n"
"<...>"
msgstr ""
"$ # выполнение команд напрямую из командной строки\n"
"$ <command> | tarantoolctl eval my_app\n"
"<...>\n"
"\n"
"$ # - ИЛИ -\n"
"\n"
"$ # выполнение команд из скрипта\n"
"$ tarantoolctl eval my_app script.lua\n"
"<...>"

#: ../doc/book/admin/server_introspection.rst:69
msgid ""
"Alternatively, you can use the :ref:`console <console-module>` module or "
"the :ref:`net.box <net_box-module>` module from a Tarantool server. Also,"
" you can write your client programs with any of the :ref:`connectors "
"<index-box_connectors>`. However, most of the examples in this manual "
"illustrate usage with either ``tarantoolctl connect`` or :ref:`using the "
"Tarantool server as a client <admin-using_tarantool_as_a_client>`."
msgstr ""
"Еще можно использовать модули :ref:`console <console-module>` и "
":ref:`net.box <net_box-module>` из Tarantool-сервера. Также вы можете "
"писать свои клиентские программы с использованием любого из доступных "
":ref:`коннекторов <index-box_connectors>`. Однако большинство примеров в "
"данном документе использует или ``tarantoolctl connect``, или "
":ref:`Tarantool-сервер как клиент <admin-using_tarantool_as_a_client>`."

#: ../doc/book/admin/server_introspection.rst:80
msgid "Health checks"
msgstr "Проверка состояния экземпляра"

#: ../doc/book/admin/server_introspection.rst:82
msgid "To check the instance status, say:"
msgstr "Чтобы проверить статус экземпляра Tarantool-сервера, выполните команду:"

#: ../doc/book/admin/server_introspection.rst:84
msgid ""
"$ tarantoolctl status my_app\n"
"my_app is running (pid: /var/run/tarantool/my_app.pid)\n"
"\n"
"$ # - OR -\n"
"\n"
"$ systemctl status tarantool@my_app\n"
"tarantool@my_app.service - Tarantool Database Server\n"
"Loaded: loaded (/etc/systemd/system/tarantool@.service; disabled; vendor "
"preset: disabled)\n"
"Active: active (running)\n"
"Docs: man:tarantool(1)\n"
"Process: 5346 ExecStart=/usr/bin/tarantoolctl start %I (code=exited, "
"status=0/SUCCESS)\n"
"Main PID: 5350 (tarantool)\n"
"Tasks: 11 (limit: 512)\n"
"CGroup: /system.slice/system-tarantool.slice/tarantool@my_app.service\n"
"+ 5350 tarantool my_app.lua <running>"
msgstr ""
"$ tarantoolctl status my_app\n"
"my_app is running (pid: /var/run/tarantool/my_app.pid)\n"
"\n"
"$ # - ИЛИ -\n"
"\n"
"$ systemctl status tarantool@my_app\n"
"tarantool@my_app.service - Tarantool Database Server\n"
"Loaded: loaded (/etc/systemd/system/tarantool@.service; disabled; vendor "
"preset: disabled)\n"
"Active: active (running)\n"
"Docs: man:tarantool(1)\n"
"Process: 5346 ExecStart=/usr/bin/tarantoolctl start %I (code=exited, "
"status=0/SUCCESS)\n"
"Main PID: 5350 (tarantool)\n"
"Tasks: 11 (limit: 512)\n"
"CGroup: /system.slice/system-tarantool.slice/tarantool@my_app.service\n"
"+ 5350 tarantool my_app.lua <running>"

#: ../doc/book/admin/server_introspection.rst:102
msgid "To check the boot log, on systems with ``systemd``, say:"
msgstr ""
"Если вы используете систему, на которой доступна утилита ``systemd``, "
"выполните следующую команду для проверки содержимого журнала загрузки:"

#: ../doc/book/admin/server_introspection.rst:104
msgid ""
"$ journalctl -u tarantool@my_app -n 5\n"
"-- Logs begin at Fri 2016-01-08 12:21:53 MSK, end at Thu 2016-01-21 "
"21:17:47 MSK. --\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Stopped Tarantool "
"Database Server.\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Starting Tarantool "
"Database Server...\n"
"Jan 21 21:17:47 localhost.localdomain tarantoolctl[5969]: "
"/usr/bin/tarantoolctl: Found my_app.lua in "
"/etc/tarantool/instances.available\n"
"Jan 21 21:17:47 localhost.localdomain tarantoolctl[5969]: "
"/usr/bin/tarantoolctl: Starting instance...\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Started Tarantool "
"Database Server"
msgstr ""
"$ journalctl -u tarantool@my_app -n 5\n"
"-- Logs begin at Fri 2016-01-08 12:21:53 MSK, end at Thu 2016-01-21 "
"21:17:47 MSK. --\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Stopped Tarantool "
"Database Server.\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Starting Tarantool "
"Database Server...\n"
"Jan 21 21:17:47 localhost.localdomain tarantoolctl[5969]: "
"/usr/bin/tarantoolctl: Found my_app.lua in "
"/etc/tarantool/instances.available\n"
"Jan 21 21:17:47 localhost.localdomain tarantoolctl[5969]: "
"/usr/bin/tarantoolctl: Starting instance...\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Started Tarantool "
"Database Server"

#: ../doc/book/admin/server_introspection.rst:114
msgid ""
"For more details, use the reports provided by functions in the following "
"submodules:"
msgstr ""
"Более подробная информация содержится в отчетах, которые можно получить с"
" помощью функций из следующих подмодулей:"

#: ../doc/book/admin/server_introspection.rst:116
msgid ""
":ref:`box.cfg <box_introspection-box_cfg>` submodule (check and specify "
"all configuration parameters for the Tarantool server)"
msgstr ""
":ref:`box.cfg <box_introspection-box_cfg>` -- проверка и указание всех "
"конфигурационных параметров Tarantool-сервера,"

#: ../doc/book/admin/server_introspection.rst:119
msgid ""
":ref:`box.slab <box_introspection-box_slab>` submodule (monitor the total"
" use and fragmentation of memory allocated for storing data in Tarantool)"
msgstr ""
":ref:`box.slab <box_introspection-box_slab>` -- мониторинг использования "
"и фрагментированности памяти, выделенной для хранения данных в "
"Tarantool'е,"

#: ../doc/book/admin/server_introspection.rst:122
msgid ""
":ref:`box.info <box_introspection-box_info>` submodule (introspect "
"Tarantool server variables, primarily those related to replication)"
msgstr ""
":ref:`box.info <box_introspection-box_info>` -- просмотр переменных "
"Tarantool-сервера -- в первую очередь тех, что относятся к репликации,"

#: ../doc/book/admin/server_introspection.rst:125
msgid ""
":ref:`box.stat <box_introspection-box_stat>` submodule (introspect "
"Tarantool request and network statistics)"
msgstr ""
":ref:`box.stat <box_introspection-box_stat>` -- просмотр статистики "
"Tarantool'а по запросам и использованию сети,"

#: ../doc/book/admin/server_introspection.rst:128
msgid ""
"You can also try `tarantool/prometheus "
"<https://github.com/tarantool/prometheus>`_, a Lua module that makes it "
"easy to collect metrics (e.g. memory usage or number of requests) from "
"Tarantool applications and databases and expose them via the Prometheus "
"protocol."
msgstr ""
"Можно также попробовать воспользоваться Lua-модулем `tarantool/prometheus"
" <https://github.com/tarantool/prometheus>`_, который облегчает сбор "
"метрик (например, использование памяти или количество запросов) с "
"Tarantool-приложений и баз данных и их публикацию через протокол "
"Prometheus."

#: ../doc/book/admin/server_introspection.rst:133
#: ../doc/book/admin/server_introspection.rst:643
#: ../doc/book/box/authentication.rst:300 ../doc/book/box/box_schema.rst:186
#: ../doc/book/box/box_session.rst:182 ../doc/book/box/box_session.rst:240
#: ../doc/book/box/box_session.rst:270 ../doc/book/box/box_session.rst:316
#: ../doc/book/box/box_session.rst:557 ../doc/book/box/triggers.rst:89
msgid "**Example**"
msgstr "**Пример**"

#: ../doc/book/admin/server_introspection.rst:135
msgid ""
"A very popular administrator request is :ref:`box.slab.info() "
"<box_slab_info>`, which displays detailed memory usage statistics for a "
"Tarantool instance."
msgstr ""
"Очень часто администраторам приходится вызывать функцию "
":ref:`box.slab.info() <box_slab_info>`, которая показывает подробную "
"статистику по использованию памяти для конкретного экземпляра "
"Tarantool'а."

#: ../doc/book/admin/server_introspection.rst:138
msgid ""
"tarantool> box.slab.info()\n"
"---\n"
"- items_size: 228128\n"
"  items_used_ratio: 1.8%\n"
"  quota_size: 1073741824\n"
"  quota_used_ratio: 0.8%\n"
"  arena_used_ratio: 43.2%\n"
"  items_used: 4208\n"
"  quota_used: 8388608\n"
"  arena_size: 2325176\n"
"  arena_used: 1003632\n"
"..."
msgstr ""
"tarantool> box.slab.info()\n"
"---\n"
"- items_size: 228128\n"
"  items_used_ratio: 1.8%\n"
"  quota_size: 1073741824\n"
"  quota_used_ratio: 0.8%\n"
"  arena_used_ratio: 43.2%\n"
"  items_used: 4208\n"
"  quota_used: 8388608\n"
"  arena_size: 2325176\n"
"  arena_used: 1003632\n"
"..."

#: ../doc/book/admin/server_introspection.rst:153
msgid ""
"Tarantool takes memory from the operating system, for example when a user"
" does many insertions. You can see how much it has taken by saying (on "
"Linux):"
msgstr ""
"Tarantool занимает память операционной системы, например, когда "
"пользователь вставляет много данных. Можно проверить, сколько памяти "
"занято, выполнив команду (в Linux):"

#: ../doc/book/admin/server_introspection.rst:157
msgid "ps -eo args,%mem | grep \"tarantool\""
msgstr "ps -eo args,%mem | grep \"tarantool\""

#: ../doc/book/admin/server_introspection.rst:161
msgid ""
"Tarantool almost never releases this memory, even if the user deletes "
"everything that was inserted, or reduces fragmentation by calling the Lua"
" garbage collector via the `collectgarbage function "
"<https://www.lua.org/manual/5.1/manual.html#pdf-collectgarbage>`_."
msgstr ""
"Tarantool почти никогда не освобождает эту память, даже если пользователь"
" удалит все, что было вставлено, или уменьшит фрагментацию, вызвав "
"сборщик мусора в Lua с помощью `функции collectgarbage "
"<https://www.lua.org/manual/5.1/manual.html #pdf-collectgarbage>`_."

#: ../doc/book/admin/server_introspection.rst:166
msgid ""
"Ordinarily this does not affect performance. But, to force Tarantool to "
"release memory, you can call :ref:`box.snapshot <box-snapshot>`, stop the"
" server instance, and restart it."
msgstr ""
"Как правило, это не влияет на производительность. Однако, чтобы заставить"
" Tarantool высвободить память, можно вызвать :ref:`box.snapshot <box-"
"snapshot>`, остановить экземпляр и перезапустить его."

#: ../doc/book/admin/server_introspection.rst:175
msgid "Profiling performance issues"
msgstr "Профилирование производительности"

#: ../doc/book/admin/server_introspection.rst:177
msgid ""
"Tarantool can at times work slower than usual. There can be multiple "
"reasons, such as disk issues, CPU-intensive Lua scripts or "
"misconfiguration. Tarantool’s log may lack details in such cases, so the "
"only indications that something goes wrong are log entries like this: "
"``W> too long DELETE: 8.546 sec``. Here are tools and techniques that can"
" help you collect Tarantool’s performance profile, which is helpful in "
"troubleshooting slowdowns."
msgstr ""
"Иногда Tarantool может работать медленнее, чем обычно. Причин такого "
"поведения может быть несколько: проблемы с диском, Lua-скрипты, активно "
"использующие процессор, или неправильная настройка. В таких случаях в "
"журнале Tarantool’а могут отсутствовать необходимые подробности, поэтому "
"единственным признаком неправильного поведения является наличие в журнале"
"  записей вида ``W> too long DELETE: 8.546 sec``. Ниже приведены "
"инструменты и приемы, которые облегчают снятие профиля производительности"
"  Tarantool’а. Эта процедура может помочь при решении проблем с "
"замедлением."

#: ../doc/book/admin/server_introspection.rst:186
msgid ""
"Most of these tools -- except ``fiber.info()`` -- are intended for "
"generic GNU/Linux distributions, but not FreeBSD or Mac OS."
msgstr ""
"Большинство инструментов, за исключением ``fiber.info()``, предназначено "
"для дистрибутивов GNU/Linux, но не для FreeBSD или Mac OS."

#: ../doc/book/admin/server_introspection.rst:191
msgid "fiber.info()"
msgstr "fiber.info()"

#: ../doc/book/admin/server_introspection.rst:193
msgid ""
"The simplest profiling method is to take advantage of Tarantool’s built-"
"in functionality. :ref:`fiber.info() <fiber-info>` returns information "
"about all running fibers with their corresponding C stack traces. You can"
" use this data to see how many fibers are running and which C functions "
"are executed more often than others."
msgstr ""
"Самый простой способ профилирования -- это использование встроенных "
"функций Tarantool’а. :ref:`fiber.info() <fiber-info>` возвращает "
"информацию обо всех работающих файберах с соответствующей трассировкой "
"стека для языка C. Эти данные показывают, сколько файберов запущенно на "
"данный момент и какие функции, написанные на C, вызываются чаще "
"остальных."

#: ../doc/book/admin/server_introspection.rst:199
msgid "First, enter your instance’s interactive administrator console:"
msgstr ""
"Сначала войдите в интерактивную административную консоль вашего "
"экземпляра Tarantool’а:"

#: ../doc/book/admin/server_introspection.rst:201
#: ../doc/book/admin/server_introspection.rst:479
msgid "$ tarantoolctl enter NAME"
msgstr "$ tarantoolctl enter NAME"

#: ../doc/book/admin/server_introspection.rst:205
msgid "Once there, load the ``fiber`` module:"
msgstr "После этого загрузите модуль ``fiber``:"

#: ../doc/book/admin/server_introspection.rst:207
msgid "tarantool> fiber = require('fiber')"
msgstr "tarantool> fiber = require('fiber')"

#: ../doc/book/admin/server_introspection.rst:211
msgid "After that you can get the required information with ``fiber.info()``."
msgstr "Теперь можно получить необходимую информацию с помощью `fiber.info()`."

#: ../doc/book/admin/server_introspection.rst:213
#, fuzzy
msgid "At this point, your console output should look something like this:"
msgstr "На этом шаге в вашей консоли должно выводиться следующее:"

#: ../doc/book/admin/server_introspection.rst:215
msgid ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> fiber.info()\n"
"---\n"
"- 360:\n"
"    csw: 2098165\n"
"    backtrace:\n"
"    - '#0 0x4d1b77 in wal_write(journal*, journal_entry*)+487'\n"
"    - '#1 0x4bbf68 in txn_commit(txn*)+152'\n"
"    - '#2 0x4bd5d8 in process_rw(request*, space*, tuple**)+136'\n"
"    - '#3 0x4bed48 in box_process1+104'\n"
"    - '#4 0x4d72f8 in lbox_replace+120'\n"
"    - '#5 0x50f317 in lj_BC_FUNCC+52'\n"
"    fid: 360\n"
"    memory:\n"
"      total: 61744\n"
"      used: 480\n"
"    name: main\n"
"  129:\n"
"    csw: 113\n"
"    backtrace: []\n"
"    fid: 129\n"
"    memory:\n"
"      total: 57648\n"
"      used: 0\n"
"    name: 'console/unix/:'\n"
"..."
msgstr ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> fiber.info()\n"
"---\n"
"- 360:\n"
"    csw: 2098165\n"
"    backtrace:\n"
"    - '#0 0x4d1b77 in wal_write(journal*, journal_entry*)+487'\n"
"    - '#1 0x4bbf68 in txn_commit(txn*)+152'\n"
"    - '#2 0x4bd5d8 in process_rw(request*, space*, tuple**)+136'\n"
"    - '#3 0x4bed48 in box_process1+104'\n"
"    - '#4 0x4d72f8 in lbox_replace+120'\n"
"    - '#5 0x50f317 in lj_BC_FUNCC+52'\n"
"    fid: 360\n"
"    memory:\n"
"      total: 61744\n"
"      used: 480\n"
"    name: main\n"
"  129:\n"
"    csw: 113\n"
"    backtrace: []\n"
"    fid: 129\n"
"    memory:\n"
"      total: 57648\n"
"      used: 0\n"
"    name: 'console/unix/:'\n"
"..."

#: ../doc/book/admin/server_introspection.rst:246
msgid ""
"We highly recommend to assign meaningful names to fibers you create so "
"that you can find them in the ``fiber.info()`` list. In the example "
"below, we create a fiber named ``myworker``:"
msgstr ""
"Мы рекомендуем присваивать создаваемым файберам понятные имена, чтобы их "
"можно было легко найти в списке, выводимом ``fiber.info()``. В примере "
"ниже создается файбер с именем ``myworker``:"

#: ../doc/book/admin/server_introspection.rst:250
msgid ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> f = fiber.create(function() while true do fiber.sleep(0.5) end"
" end)\n"
"---\n"
"...\n"
"tarantool> f:name('myworker') <!-- assigning the name to a fiber\n"
"---\n"
"...\n"
"tarantool> fiber.info()\n"
"---\n"
"- 102:\n"
"    csw: 14\n"
"    backtrace:\n"
"    - '#0 0x501a1a in fiber_yield_timeout+90'\n"
"    - '#1 0x4f2008 in lbox_fiber_sleep+72'\n"
"    - '#2 0x5112a7 in lj_BC_FUNCC+52'\n"
"    fid: 102\n"
"    memory:\n"
"      total: 57656\n"
"      used: 0\n"
"    name: myworker <!-- newly created background fiber\n"
"  101:\n"
"    csw: 284\n"
"    backtrace: []\n"
"    fid: 101\n"
"    memory:\n"
"      total: 57656\n"
"      used: 0\n"
"    name: interactive\n"
"..."
msgstr ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> f = fiber.create(function() while true do fiber.sleep(0.5) end"
" end)\n"
"---\n"
"...\n"
"tarantool> f:name('myworker') <!-- присваивание имени файберу\n"
"---\n"
"...\n"
"tarantool> fiber.info()\n"
"---\n"
"- 102:\n"
"    csw: 14\n"
"    backtrace:\n"
"    - '#0 0x501a1a in fiber_yield_timeout+90'\n"
"    - '#1 0x4f2008 in lbox_fiber_sleep+72'\n"
"    - '#2 0x5112a7 in lj_BC_FUNCC+52'\n"
"    fid: 102\n"
"    memory:\n"
"      total: 57656\n"
"      used: 0\n"
"    name: myworker <!-- новый созданный фоновый файбер\n"
"  101:\n"
"    csw: 284\n"
"    backtrace: []\n"
"    fid: 101\n"
"    memory:\n"
"      total: 57656\n"
"      used: 0\n"
"    name: interactive\n"
"..."

#: ../doc/book/admin/server_introspection.rst:284
msgid "You can kill any fiber with :ref:`fiber.kill(fid) <fiber-kill>`:"
msgstr ""
"Для принудительного завершения файбера используется команда "
":ref:`fiber.kill(fid) <fiber-kill>`:"

#: ../doc/book/admin/server_introspection.rst:286
msgid ""
"tarantool> fiber.kill(102)\n"
"---\n"
"...\n"
"tarantool> fiber.info()\n"
"---\n"
"- 101:\n"
"    csw: 324\n"
"    backtrace: []\n"
"    fid: 101\n"
"    memory:\n"
"      total: 57656\n"
"      used: 0\n"
"    name: interactive\n"
"..."
msgstr ""
"tarantool> fiber.kill(102)\n"
"---\n"
"...\n"
"tarantool> fiber.info()\n"
"---\n"
"- 101:\n"
"    csw: 324\n"
"    backtrace: []\n"
"    fid: 101\n"
"    memory:\n"
"      total: 57656\n"
"      used: 0\n"
"    name: interactive\n"
"..."

#: ../doc/book/admin/server_introspection.rst:303
msgid ""
"If you want to dynamically obtain information with ``fiber.info()``, the "
"shell script below may come in handy. It connects to a Tarantool instance"
" specified by ``NAME`` every 0.5 seconds, grabs the ``fiber.info()`` "
"output and writes it to the ``fiber-info.txt`` file:"
msgstr ""
"Если вам необходимо динамически получать информацию с помощью "
"``fiber.info()``, вам может пригодиться приведенный ниже скрипт. Он "
"каждые полсекунды подключается к экземпляру Tarantool’а, указанному в "
"переменной ``NAME``, выполняет команду ``fiber.info()`` и записывает ее "
"выход в файл ``fiber-info.txt``:"

#: ../doc/book/admin/server_introspection.rst:308
msgid ""
"$ rm -f fiber.info.txt\n"
"$ watch -n 0.5 \"echo 'require(\\\"fiber\\\").info()' | tarantoolctl "
"enter NAME | tee -a fiber-info.txt\""
msgstr ""
"$ rm -f fiber.info.txt\n"
"$ watch -n 0.5 \"echo 'require(\\\"fiber\\\").info()' | tarantoolctl "
"enter NAME | tee -a fiber-info.txt\""

#: ../doc/book/admin/server_introspection.rst:313
msgid ""
"If you can't understand which fiber causes performance issues, collect "
"the metrics of the ``fiber.info()`` output for 10-15 seconds using the "
"script above and contact the Tarantool team at support@tarantool.org."
msgstr ""
"Если вы не можете самостоятельно разобраться, какой именно файбер "
"вызывает проблемы с производительностью, запустите данный скрипт на 10-15"
" секунд и пришлите получившийся файл команде Tarantool’а на адрес "
"support@tarantool.org."

#: ../doc/book/admin/server_introspection.rst:319
msgid "Poor man’s profilers"
msgstr "Простейшие профилировщики"

#: ../doc/book/admin/server_introspection.rst:321
msgid "**pstack <pid>**"
msgstr "**pstack <pid>**"

#: ../doc/book/admin/server_introspection.rst:323
msgid ""
"To use this tool, first install it with a package manager that comes with"
" your Linux distribution. This command prints an execution stack trace of"
" a running process specified by the PID. You might want to run this "
"command several times in a row to pinpoint the bottleneck that causes the"
" slowdown."
msgstr ""
"Чтобы использовать этот инструмент, его необходимо установить с помощью "
"пакетного менеджера, поставляемого с вашим дистрибутивом Linux. Данная "
"команда выводит трассировку стека выполнения для работающего процесса с "
"соответствующим PID. При необходимости команду можно запустить несколько "
"раз, чтобы выявить узкое место, которое вызывает падение "
"производительности."

#: ../doc/book/admin/server_introspection.rst:328
msgid "Once installed, say:"
msgstr "После установки воспользуйтесь следующей командой:"

#: ../doc/book/admin/server_introspection.rst:330
msgid "$ pstack $(pidof tarantool INSTANCENAME.lua)"
msgstr "$ pstack $(pidof tarantool INSTANCENAME.lua)"

#: ../doc/book/admin/server_introspection.rst:334
#: ../doc/book/admin/server_introspection.rst:381
msgid "Next, say:"
msgstr "Затем выполните:"

#: ../doc/book/admin/server_introspection.rst:336
#: ../doc/book/admin/server_introspection.rst:383
msgid "$ echo $(pidof tarantool INSTANCENAME.lua)"
msgstr "$ echo $(pidof tarantool INSTANCENAME.lua)"

#: ../doc/book/admin/server_introspection.rst:340
#: ../doc/book/admin/server_introspection.rst:387
msgid ""
"to show the PID of the Tarantool instance that runs the "
"``INSTANCENAME.lua`` file."
msgstr ""
"чтобы вывести на экран PID экземпляра Tarantool’а, использующего файл "
"``INSTANCENAME.lua``."

#: ../doc/book/admin/server_introspection.rst:342
msgid "You should get similar output:"
msgstr "В вашей консоли должно отображаться приблизительно следующее:"

#: ../doc/book/admin/server_introspection.rst:344
msgid ""
"Thread 19 (Thread 0x7f09d1bff700 (LWP 24173)):\n"
"#0 0x00007f0a1a5423f2 in ?? () from /lib64/libgomp.so.1\n"
"#1 0x00007f0a1a53fdc0 in ?? () from /lib64/libgomp.so.1\n"
"#2 0x00007f0a1ad5adc5 in start_thread () from /lib64/libpthread.so.0\n"
"#3 0x00007f0a1a050ced in clone () from /lib64/libc.so.6\n"
"Thread 18 (Thread 0x7f09d13fe700 (LWP 24174)):\n"
"#0 0x00007f0a1a5423f2 in ?? () from /lib64/libgomp.so.1\n"
"#1 0x00007f0a1a53fdc0 in ?? () from /lib64/libgomp.so.1\n"
"#2 0x00007f0a1ad5adc5 in start_thread () from /lib64/libpthread.so.0\n"
"#3 0x00007f0a1a050ced in clone () from /lib64/libc.so.6\n"
"<...>\n"
"Thread 2 (Thread 0x7f09c8bfe700 (LWP 24191)):\n"
"#0 0x00007f0a1ad5e6d5 in pthread_cond_wait@@GLIBC_2.3.2 () from "
"/lib64/libpthread.so.0\n"
"#1 0x000000000045d901 in wal_writer_pop(wal_writer*) ()\n"
"#2 0x000000000045db01 in wal_writer_f(__va_list_tag*) ()\n"
"#3 0x0000000000429abc in fiber_cxx_invoke(int (*)(__va_list_tag*), "
"__va_list_tag*) ()\n"
"#4 0x00000000004b52a0 in fiber_loop ()\n"
"#5 0x00000000006099cf in coro_init ()\n"
"Thread 1 (Thread 0x7f0a1c47fd80 (LWP 24172)):\n"
"#0 0x00007f0a1a0512c3 in epoll_wait () from /lib64/libc.so.6\n"
"#1 0x00000000006051c8 in epoll_poll ()\n"
"#2 0x0000000000607533 in ev_run ()\n"
"#3 0x0000000000428e13 in main ()"
msgstr ""
"Thread 19 (Thread 0x7f09d1bff700 (LWP 24173)):\n"
"#0 0x00007f0a1a5423f2 in ?? () from /lib64/libgomp.so.1\n"
"#1 0x00007f0a1a53fdc0 in ?? () from /lib64/libgomp.so.1\n"
"#2 0x00007f0a1ad5adc5 in start_thread () from /lib64/libpthread.so.0\n"
"#3 0x00007f0a1a050ced in clone () from /lib64/libc.so.6\n"
"Thread 18 (Thread 0x7f09d13fe700 (LWP 24174)):\n"
"#0 0x00007f0a1a5423f2 in ?? () from /lib64/libgomp.so.1\n"
"#1 0x00007f0a1a53fdc0 in ?? () from /lib64/libgomp.so.1\n"
"#2 0x00007f0a1ad5adc5 in start_thread () from /lib64/libpthread.so.0\n"
"#3 0x00007f0a1a050ced in clone () from /lib64/libc.so.6\n"
"<...>\n"
"Thread 2 (Thread 0x7f09c8bfe700 (LWP 24191)):\n"
"#0 0x00007f0a1ad5e6d5 in pthread_cond_wait@@GLIBC_2.3.2 () from "
"/lib64/libpthread.so.0\n"
"#1 0x000000000045d901 in wal_writer_pop(wal_writer*) ()\n"
"#2 0x000000000045db01 in wal_writer_f(__va_list_tag*) ()\n"
"#3 0x0000000000429abc in fiber_cxx_invoke(int (*)(__va_list_tag*), "
"__va_list_tag*) ()\n"
"#4 0x00000000004b52a0 in fiber_loop ()\n"
"#5 0x00000000006099cf in coro_init ()\n"
"Thread 1 (Thread 0x7f0a1c47fd80 (LWP 24172)):\n"
"#0 0x00007f0a1a0512c3 in epoll_wait () from /lib64/libc.so.6\n"
"#1 0x00000000006051c8 in epoll_poll ()\n"
"#2 0x0000000000607533 in ev_run ()\n"
"#3 0x0000000000428e13 in main ()"

#: ../doc/book/admin/server_introspection.rst:370
msgid "**gdb -ex \"bt\" -p <pid>**"
msgstr "**gdb -ex \"bt\" -p <pid>**"

#: ../doc/book/admin/server_introspection.rst:372
msgid ""
"As with ``pstack``, the GNU debugger (also known as ``gdb``) needs to be "
"installed before you can start using it. Your Linux package manager can "
"help you with that."
msgstr ""
"Как и в случае с ``pstack``,  перед использованием GNU-отладчик (также "
"известный как ``gdb``) необходимо сначала установить через пакетный "
"менеджер, встроенный в ваш дистрибутив Linux."

#: ../doc/book/admin/server_introspection.rst:375
msgid "Once the debugger is installed, say:"
msgstr "После установки воспользуйтесь следующей командой:"

#: ../doc/book/admin/server_introspection.rst:377
msgid ""
"$ gdb -ex \"set pagination 0\" -ex \"thread apply all bt\" --batch -p "
"$(pidof tarantool INSTANCENAME.lua)"
msgstr ""
"$ gdb -ex \"set pagination 0\" -ex \"thread apply all bt\" --batch -p "
"$(pidof tarantool INSTANCENAME.lua)"

#: ../doc/book/admin/server_introspection.rst:389
msgid "After using the debugger, your console output should look like this:"
msgstr ""
"После использования отладчика в консоль должна выводиться следующая "
"информация:"

#: ../doc/book/admin/server_introspection.rst:391
msgid ""
"[Thread debugging using libthread_db enabled]\n"
"Using host libthread_db library \"/lib/x86_64-linux-"
"gnu/libthread_db.so.1\".\n"
"\n"
"[CUT]\n"
"\n"
"Thread 1 (Thread 0x7f72289ba940 (LWP 20535)):\n"
"#0 _int_malloc (av=av@entry=0x7f7226e0eb20 <main_arena>, "
"bytes=bytes@entry=504) at malloc.c:3697\n"
"#1 0x00007f7226acf21a in __libc_calloc (n=<optimized out>, "
"elem_size=<optimized out>) at malloc.c:3234\n"
"#2 0x00000000004631f8 in vy_merge_iterator_reserve (capacity=3, "
"itr=0x7f72264af9e0) at /usr/src/tarantool/src/box/vinyl.c:7629\n"
"#3 vy_merge_iterator_add (itr=itr@entry=0x7f72264af9e0, "
"is_mutable=is_mutable@entry=true, belong_range=belong_range@entry=false) "
"at /usr/src/tarantool/src/box/vinyl.c:7660\n"
"#4 0x00000000004703df in vy_read_iterator_add_mem (itr=0x7f72264af990) at"
" /usr/src/tarantool/src/box/vinyl.c:8387\n"
"#5 vy_read_iterator_use_range (itr=0x7f72264af990) at "
"/usr/src/tarantool/src/box/vinyl.c:8453\n"
"#6 0x000000000047657d in vy_read_iterator_start (itr=<optimized out>) at "
"/usr/src/tarantool/src/box/vinyl.c:8501\n"
"#7 0x00000000004766b5 in vy_read_iterator_next "
"(itr=itr@entry=0x7f72264af990, result=result@entry=0x7f72264afad8) at "
"/usr/src/tarantool/src/box/vinyl.c:8592\n"
"#8 0x000000000047689d in vy_index_get (tx=tx@entry=0x7f7226468158, "
"index=index@entry=0x2563860, key=<optimized out>, part_count=<optimized "
"out>, result=result@entry=0x7f72264afad8) at "
"/usr/src/tarantool/src/box/vinyl.c:5705\n"
"#9 0x0000000000477601 in vy_replace_impl (request=<optimized out>, "
"request=<optimized out>, stmt=0x7f72265a7150, space=0x2567ea0, "
"tx=0x7f7226468158) at /usr/src/tarantool/src/box/vinyl.c:5920\n"
"#10 vy_replace (tx=0x7f7226468158, stmt=stmt@entry=0x7f72265a7150, "
"space=0x2567ea0, request=<optimized out>) at "
"/usr/src/tarantool/src/box/vinyl.c:6608\n"
"#11 0x00000000004615a9 in VinylSpace::executeReplace (this=<optimized "
"out>, txn=<optimized out>, space=<optimized out>, request=<optimized "
"out>) at /usr/src/tarantool/src/box/vinyl_space.cc:108\n"
"#12 0x00000000004bd723 in process_rw "
"(request=request@entry=0x7f72265a70f8, space=space@entry=0x2567ea0, "
"result=result@entry=0x7f72264afbc8) at "
"/usr/src/tarantool/src/box/box.cc:182\n"
"#13 0x00000000004bed48 in box_process1 (request=0x7f72265a70f8, "
"result=result@entry=0x7f72264afbc8) at "
"/usr/src/tarantool/src/box/box.cc:700\n"
"#14 0x00000000004bf389 in box_replace (space_id=space_id@entry=513, "
"tuple=<optimized out>, tuple_end=<optimized out>, "
"result=result@entry=0x7f72264afbc8) at "
"/usr/src/tarantool/src/box/box.cc:754\n"
"#15 0x00000000004d72f8 in lbox_replace (L=0x413c5780) at "
"/usr/src/tarantool/src/box/lua/index.c:72\n"
"#16 0x000000000050f317 in lj_BC_FUNCC ()\n"
"#17 0x00000000004d37c7 in execute_lua_call (L=0x413c5780) at "
"/usr/src/tarantool/src/box/lua/call.c:282\n"
"#18 0x000000000050f317 in lj_BC_FUNCC ()\n"
"#19 0x0000000000529c7b in lua_cpcall ()\n"
"#20 0x00000000004f6aa3 in luaT_cpcall (L=L@entry=0x413c5780, "
"func=func@entry=0x4d36d0 <execute_lua_call>, ud=ud@entry=0x7f72264afde0) "
"at /usr/src/tarantool/src/lua/utils.c:962\n"
"#21 0x00000000004d3fe7 in box_process_lua (handler=0x4d36d0 "
"<execute_lua_call>, out=out@entry=0x7f7213020600, "
"request=request@entry=0x413c5780) at "
"/usr/src/tarantool/src/box/lua/call.c:382\n"
"#22 box_lua_call (request=request@entry=0x7f72130401d8, "
"out=out@entry=0x7f7213020600) at "
"/usr/src/tarantool/src/box/lua/call.c:405\n"
"#23 0x00000000004c0f27 in box_process_call "
"(request=request@entry=0x7f72130401d8, out=out@entry=0x7f7213020600) at "
"/usr/src/tarantool/src/box/box.cc:1074\n"
"#24 0x000000000041326c in tx_process_misc (m=0x7f7213040170) at "
"/usr/src/tarantool/src/box/iproto.cc:942\n"
"#25 0x0000000000504554 in cmsg_deliver (msg=0x7f7213040170) at "
"/usr/src/tarantool/src/cbus.c:302\n"
"#26 0x0000000000504c2e in fiber_pool_f (ap=<error reading variable: value"
" has been optimized out>) at /usr/src/tarantool/src/fiber_pool.c:64\n"
"#27 0x000000000041122c in fiber_cxx_invoke(fiber_func, typedef "
"__va_list_tag __va_list_tag *) (f=<optimized out>, ap=<optimized out>) at"
" /usr/src/tarantool/src/fiber.h:645\n"
"#28 0x00000000005011a0 in fiber_loop (data=<optimized out>) at "
"/usr/src/tarantool/src/fiber.c:641\n"
"#29 0x0000000000688fbf in coro_init () at "
"/usr/src/tarantool/third_party/coro/coro.c:110"
msgstr ""
"[Thread debugging using libthread_db enabled]\n"
"Using host libthread_db library \"/lib/x86_64-linux-"
"gnu/libthread_db.so.1\".\n"
"\n"
"[CUT]\n"
"\n"
"Thread 1 (Thread 0x7f72289ba940 (LWP 20535)):\n"
"#0 _int_malloc (av=av@entry=0x7f7226e0eb20 <main_arena>, "
"bytes=bytes@entry=504) at malloc.c:3697\n"
"#1 0x00007f7226acf21a in __libc_calloc (n=<optimized out>, "
"elem_size=<optimized out>) at malloc.c:3234\n"
"#2 0x00000000004631f8 in vy_merge_iterator_reserve (capacity=3, "
"itr=0x7f72264af9e0) at /usr/src/tarantool/src/box/vinyl.c:7629\n"
"#3 vy_merge_iterator_add (itr=itr@entry=0x7f72264af9e0, "
"is_mutable=is_mutable@entry=true, belong_range=belong_range@entry=false) "
"at /usr/src/tarantool/src/box/vinyl.c:7660\n"
"#4 0x00000000004703df in vy_read_iterator_add_mem (itr=0x7f72264af990) at"
" /usr/src/tarantool/src/box/vinyl.c:8387\n"
"#5 vy_read_iterator_use_range (itr=0x7f72264af990) at "
"/usr/src/tarantool/src/box/vinyl.c:8453\n"
"#6 0x000000000047657d in vy_read_iterator_start (itr=<optimized out>) at "
"/usr/src/tarantool/src/box/vinyl.c:8501\n"
"#7 0x00000000004766b5 in vy_read_iterator_next "
"(itr=itr@entry=0x7f72264af990, result=result@entry=0x7f72264afad8) at "
"/usr/src/tarantool/src/box/vinyl.c:8592\n"
"#8 0x000000000047689d in vy_index_get (tx=tx@entry=0x7f7226468158, "
"index=index@entry=0x2563860, key=<optimized out>, part_count=<optimized "
"out>, result=result@entry=0x7f72264afad8) at "
"/usr/src/tarantool/src/box/vinyl.c:5705\n"
"#9 0x0000000000477601 in vy_replace_impl (request=<optimized out>, "
"request=<optimized out>, stmt=0x7f72265a7150, space=0x2567ea0, "
"tx=0x7f7226468158) at /usr/src/tarantool/src/box/vinyl.c:5920\n"
"#10 vy_replace (tx=0x7f7226468158, stmt=stmt@entry=0x7f72265a7150, "
"space=0x2567ea0, request=<optimized out>) at "
"/usr/src/tarantool/src/box/vinyl.c:6608\n"
"#11 0x00000000004615a9 in VinylSpace::executeReplace (this=<optimized "
"out>, txn=<optimized out>, space=<optimized out>, request=<optimized "
"out>) at /usr/src/tarantool/src/box/vinyl_space.cc:108\n"
"#12 0x00000000004bd723 in process_rw "
"(request=request@entry=0x7f72265a70f8, space=space@entry=0x2567ea0, "
"result=result@entry=0x7f72264afbc8) at "
"/usr/src/tarantool/src/box/box.cc:182\n"
"#13 0x00000000004bed48 in box_process1 (request=0x7f72265a70f8, "
"result=result@entry=0x7f72264afbc8) at "
"/usr/src/tarantool/src/box/box.cc:700\n"
"#14 0x00000000004bf389 in box_replace (space_id=space_id@entry=513, "
"tuple=<optimized out>, tuple_end=<optimized out>, "
"result=result@entry=0x7f72264afbc8) at "
"/usr/src/tarantool/src/box/box.cc:754\n"
"#15 0x00000000004d72f8 in lbox_replace (L=0x413c5780) at "
"/usr/src/tarantool/src/box/lua/index.c:72\n"
"#16 0x000000000050f317 in lj_BC_FUNCC ()\n"
"#17 0x00000000004d37c7 in execute_lua_call (L=0x413c5780) at "
"/usr/src/tarantool/src/box/lua/call.c:282\n"
"#18 0x000000000050f317 in lj_BC_FUNCC ()\n"
"#19 0x0000000000529c7b in lua_cpcall ()\n"
"#20 0x00000000004f6aa3 in luaT_cpcall (L=L@entry=0x413c5780, "
"func=func@entry=0x4d36d0 <execute_lua_call>, ud=ud@entry=0x7f72264afde0) "
"at /usr/src/tarantool/src/lua/utils.c:962\n"
"#21 0x00000000004d3fe7 in box_process_lua (handler=0x4d36d0 "
"<execute_lua_call>, out=out@entry=0x7f7213020600, "
"request=request@entry=0x413c5780) at "
"/usr/src/tarantool/src/box/lua/call.c:382\n"
"#22 box_lua_call (request=request@entry=0x7f72130401d8, "
"out=out@entry=0x7f7213020600) at "
"/usr/src/tarantool/src/box/lua/call.c:405\n"
"#23 0x00000000004c0f27 in box_process_call "
"(request=request@entry=0x7f72130401d8, out=out@entry=0x7f7213020600) at "
"/usr/src/tarantool/src/box/box.cc:1074\n"
"#24 0x000000000041326c in tx_process_misc (m=0x7f7213040170) at "
"/usr/src/tarantool/src/box/iproto.cc:942\n"
"#25 0x0000000000504554 in cmsg_deliver (msg=0x7f7213040170) at "
"/usr/src/tarantool/src/cbus.c:302\n"
"#26 0x0000000000504c2e in fiber_pool_f (ap=<error reading variable: value"
" has been optimized out>) at /usr/src/tarantool/src/fiber_pool.c:64\n"
"#27 0x000000000041122c in fiber_cxx_invoke(fiber_func, typedef "
"__va_list_tag __va_list_tag *) (f=<optimized out>, ap=<optimized out>) at"
" /usr/src/tarantool/src/fiber.h:645\n"
"#28 0x00000000005011a0 in fiber_loop (data=<optimized out>) at "
"/usr/src/tarantool/src/fiber.c:641\n"
"#29 0x0000000000688fbf in coro_init () at "
"/usr/src/tarantool/third_party/coro/coro.c:110"

#: ../doc/book/admin/server_introspection.rst:430
msgid ""
"Run the debugger in a loop a few times to collect enough samples for "
"making conclusions about why Tarantool demonstrates suboptimal "
"performance. Use the following script:"
msgstr ""
"Запустите отладчик в цикле, чтобы собрать достаточно информации, которая "
"поможет установить причину спада производительности Tarantool’а. Можно "
"воспользоваться следующим скриптом:"

#: ../doc/book/admin/server_introspection.rst:434
msgid ""
"$ rm -f stack-trace.txt\n"
"$ watch -n 0.5 \"gdb -ex 'set pagination 0' -ex 'thread apply all bt' "
"--batch -p $(pidof tarantool INSTANCENAME.lua) | tee -a stack-trace.txt\""
msgstr ""
"$ rm -f stack-trace.txt\n"
"$ watch -n 0.5 \"gdb -ex 'set pagination 0' -ex 'thread apply all bt' "
"--batch -p $(pidof tarantool INSTANCENAME.lua) | tee -a stack-trace.txt\""

#: ../doc/book/admin/server_introspection.rst:439
msgid ""
"Structurally and functionally, this script is very similar to the one "
"used with ``fiber.info()`` above."
msgstr ""
"С точки зрения структуры и функциональности, этот скрипт идентичен тому, "
"что используется выше с ``fiber.info()``."

#: ../doc/book/admin/server_introspection.rst:442
msgid ""
"If you have any difficulties troubleshooting, let the script run for "
"10-15 seconds and then send the resulting ``stack-trace.txt`` file to the"
" Tarantool team at support@tarantool.org."
msgstr ""
"Если вам не удается отыскать причину пониженной производительности, "
"запустите данный скрипт на 10-15 секунд и пришлите получившийся файл "
"``stack-trace.txt`` команде Tarantool’а на адрес support@tarantool.org."

#: ../doc/book/admin/server_introspection.rst:448
msgid ""
"Use the poor man’s profilers with caution: each time they attach to a "
"running process, this stops the process execution for about a second, "
"which may leave a serious footprint in high-load services."
msgstr ""
"Следует использовать ``pstack`` и ``gdb`` с осторожностью: каждый раз, "
"подключаясь с работающему процессу, они приостанавливают выполнение этого"
"  процесса приблизительно на одну секунду, что может иметь серьезные "
"последствия для высоконагруженных сервисов."

#: ../doc/book/admin/server_introspection.rst:454
msgid "gperftools"
msgstr "gperftools"

#: ../doc/book/admin/server_introspection.rst:456
msgid ""
"To use the CPU profiler from the Google Performance Tools suite with "
"Tarantool, first take care of the prerequisites:"
msgstr ""
"Чтобы использовать профилировщик процессора из набора Google Performance "
"Tools с Tarantool’ом, необходимо сначала установить зависимости:"

#: ../doc/book/admin/server_introspection.rst:459
msgid "For Debian/Ubuntu, run:"
msgstr "Если вы используете Debian/Ubuntu, запустите эту команду:"

#: ../doc/book/admin/server_introspection.rst:461
msgid "$ apt-get install libgoogle-perftools4"
msgstr "$ apt-get install libgoogle-perftools4"

#: ../doc/book/admin/server_introspection.rst:465
msgid "For RHEL/CentOS/Fedora, run:"
msgstr "Если вы используете RHEL/CentOS/Fedora, запустите эту команду:"

#: ../doc/book/admin/server_introspection.rst:467
msgid "$ yum install gperftools-libs"
msgstr "$ yum install gperftools-libs"

#: ../doc/book/admin/server_introspection.rst:471
msgid "Once you do this, install Lua bindings:"
msgstr "После этого установите привязки для Lua:"

#: ../doc/book/admin/server_introspection.rst:473
msgid "$ tarantoolctl rocks install gperftools"
msgstr "$ tarantoolctl rocks install gperftools"

#: ../doc/book/admin/server_introspection.rst:477
msgid ""
"Now you're ready to go. Enter your instance’s interactive administrator "
"console:"
msgstr ""
"После окончания установки войдите в интерактивную административную "
"консоль вашего экземпляра Tarantool’а:"

#: ../doc/book/admin/server_introspection.rst:483
msgid "To start profiling, say:"
msgstr "Для запуска профилировщика выполните следующий код:"

#: ../doc/book/admin/server_introspection.rst:485
msgid ""
"tarantool> cpuprof = require('gperftools.cpu')\n"
"tarantool> cpuprof.start('/home/<username>/tarantool-on-production.prof')"
msgstr ""
"tarantool> cpuprof = require('gperftools.cpu')\n"
"tarantool> cpuprof.start('/home/<имя_пользователя>/tarantool-on-"
"production.prof')"

#: ../doc/book/admin/server_introspection.rst:490
msgid ""
"It takes at least a couple of minutes for the profiler to gather "
"performance metrics. After that, save the results to disk (you can do "
"that as many times as you need):"
msgstr ""
"На сбор метрик производительности у профилировщика уходит по крайней мере"
"  пара минут. По истечении этого времени можно сохранять информацию на "
"диск (неограниченное количество раз):"

#: ../doc/book/admin/server_introspection.rst:494
msgid "tarantool> cpuprof.flush()"
msgstr "tarantool> cpuprof.flush()"

#: ../doc/book/admin/server_introspection.rst:498
msgid "To stop profiling, say:"
msgstr "Для остановки профилировщика выполните следующую команду:"

#: ../doc/book/admin/server_introspection.rst:500
msgid "tarantool> cpuprof.stop()"
msgstr "tarantool> cpuprof.stop()"

#: ../doc/book/admin/server_introspection.rst:504
msgid ""
"You can now analyze the output with the ``pprof`` utility that comes with"
" the ``gperftools`` package:"
msgstr ""
"Теперь можно проанализировать собранные данные с помощью утилиты "
"``pprof``, которая входит в пакет ``gperftools``:"

#: ../doc/book/admin/server_introspection.rst:507
msgid ""
"$ pprof --text /usr/bin/tarantool /home/<username>/tarantool-on-"
"production.prof"
msgstr ""
"$ pprof --text /usr/bin/tarantool /home/<имя_пользователя>/tarantool-on-"
"production.prof"

#: ../doc/book/admin/server_introspection.rst:513
msgid "On Debian/Ubuntu, the ``pprof`` utility is called ``google-pprof``."
msgstr ""
"В дистрибутивах Debian/Ubuntu утилита ``pprof`` называется ``google-"
"pprof``."

#: ../doc/book/admin/server_introspection.rst:515
msgid "Your output should look similar to this:"
msgstr "В консоль должно выводиться приблизительно следующее:"

#: ../doc/book/admin/server_introspection.rst:517
#, python-format
msgid ""
"Total: 598 samples\n"
"      83 13.9% 13.9% 83 13.9% epoll_wait\n"
"      54 9.0% 22.9% 102 17.1%\n"
"vy_mem_tree_insert.constprop.35\n"
"      32 5.4% 28.3% 34 5.7% __write_nocancel\n"
"      28 4.7% 32.9% 42 7.0% vy_mem_iterator_start_from\n"
"      26 4.3% 37.3% 26 4.3% _IO_str_seekoff\n"
"      21 3.5% 40.8% 21 3.5% tuple_compare_field\n"
"      19 3.2% 44.0% 19 3.2%\n"
"::TupleCompareWithKey::compare\n"
"      19 3.2% 47.2% 38 6.4% tuple_compare_slowpath\n"
"      12 2.0% 49.2% 23 3.8% __libc_calloc\n"
"       9 1.5% 50.7% 9 1.5%\n"
"::TupleCompare::compare@42efc0\n"
"       9 1.5% 52.2% 9 1.5% vy_cache_on_write\n"
"       9 1.5% 53.7% 57 9.5% vy_merge_iterator_next_key\n"
"       8 1.3% 55.0% 8 1.3% __nss_passwd_lookup\n"
"       6 1.0% 56.0% 25 4.2% gc_onestep\n"
"       6 1.0% 57.0% 6 1.0% lj_tab_next\n"
"       5 0.8% 57.9% 5 0.8% lj_alloc_malloc\n"
"       5 0.8% 58.7% 131 21.9% vy_prepare"
msgstr ""
"Total: 598 samples\n"
"      83 13.9% 13.9% 83 13.9% epoll_wait\n"
"      54 9.0% 22.9% 102 17.1%\n"
"vy_mem_tree_insert.constprop.35\n"
"      32 5.4% 28.3% 34 5.7% __write_nocancel\n"
"      28 4.7% 32.9% 42 7.0% vy_mem_iterator_start_from\n"
"      26 4.3% 37.3% 26 4.3% _IO_str_seekoff\n"
"      21 3.5% 40.8% 21 3.5% tuple_compare_field\n"
"      19 3.2% 44.0% 19 3.2%\n"
"::TupleCompareWithKey::compare\n"
"      19 3.2% 47.2% 38 6.4% tuple_compare_slowpath\n"
"      12 2.0% 49.2% 23 3.8% __libc_calloc\n"
"       9 1.5% 50.7% 9 1.5%\n"
"::TupleCompare::compare@42efc0\n"
"       9 1.5% 52.2% 9 1.5% vy_cache_on_write\n"
"       9 1.5% 53.7% 57 9.5% vy_merge_iterator_next_key\n"
"       8 1.3% 55.0% 8 1.3% __nss_passwd_lookup\n"
"       6 1.0% 56.0% 25 4.2% gc_onestep\n"
"       6 1.0% 57.0% 6 1.0% lj_tab_next\n"
"       5 0.8% 57.9% 5 0.8% lj_alloc_malloc\n"
"       5 0.8% 58.7% 131 21.9% vy_prepare"

#: ../doc/book/admin/server_introspection.rst:543
msgid "perf"
msgstr "perf"

#: ../doc/book/admin/server_introspection.rst:545
msgid ""
"This tool for performance monitoring and analysis is installed separately"
" via your package manager. Try running the ``perf`` command in the "
"terminal and follow the prompts to install the necessary package(s)."
msgstr ""
"Этот инструмент для мониторинга и анализа производительности "
"устанавливается отдельно с помощью пакетного менеджера. Попробуйте ввести"
" в окне консоли команду ``perf`` и следуйте подсказкам, чтобы установить "
"необходимые пакеты."

#: ../doc/book/admin/server_introspection.rst:551
msgid ""
"By default, some ``perf`` commands are restricted to **root**, so, to be "
"on the safe side, either run all commands as **root** or prepend them "
"with ``sudo``."
msgstr ""
"По умолчанию некоторые команды из пакета ``perf`` можно выполнять только "
"с **root**-правами, поэтому необходимо либо зайти в систему из-под "
"пользователя **root**, либо добавлять перед каждой командой ``sudo``."

#: ../doc/book/admin/server_introspection.rst:555
msgid "To start gathering performance statistics, say:"
msgstr ""
"Чтобы начать сбор показателей производительности, выполните следующую "
"команду:"

#: ../doc/book/admin/server_introspection.rst:557
msgid "$ perf record -g -p $(pidof tarantool INSTANCENAME.lua)"
msgstr "$ perf record -g -p $(pidof tarantool INSTANCENAME.lua)"

#: ../doc/book/admin/server_introspection.rst:561
msgid ""
"This command saves the gathered data to a file named ``perf.data`` inside"
" the current working directory. To stop this process (usually, after "
"10-15 seconds), press **ctrl+C**. In your console, you’ll see:"
msgstr ""
"Эта команда сохраняет собранные данные в файл ``perf.data``, который "
"находится в текущей рабочей папке. Для остановки процесса (обычно через "
"10-15 секунд) нажмите **ctrl+C**. В консоли должно появиться следующее:"

#: ../doc/book/admin/server_introspection.rst:565
msgid ""
"^C[ perf record: Woken up 1 times to write data ]\n"
"[ perf record: Captured and wrote 0.225 MB perf.data (1573 samples) ]"
msgstr ""
"^C[ perf record: Woken up 1 times to write data ]\n"
"[ perf record: Captured and wrote 0.225 MB perf.data (1573 samples) ]"

#: ../doc/book/admin/server_introspection.rst:570
msgid "Now run the following command:"
msgstr "Затем выполните эту команду:"

#: ../doc/book/admin/server_introspection.rst:572
msgid "$ perf report -n -g --stdio | tee perf-report.txt"
msgstr "$ perf report -n -g --stdio | tee perf-report.txt"

#: ../doc/book/admin/server_introspection.rst:576
msgid ""
"It formats the statistical data in the ``perf.data`` file into a "
"performance report and writes it to the ``perf-report.txt`` file."
msgstr ""
"Она превращает содержащиеся в ``perf.data`` статистические данные в отчет"
"  о производительности, который сохраняется в файл ``perf-report.txt``."

#: ../doc/book/admin/server_introspection.rst:579
msgid "The resulting output should look similar to this:"
msgstr "Получившийся отчет выглядит следующим образом:"

#: ../doc/book/admin/server_introspection.rst:581
#, python-format
msgid ""
"# Samples: 14K of event 'cycles'\n"
"# Event count (approx.): 9927346847\n"
"#\n"
"# Children Self Samples Command Shared Object Symbol\n"
"# ........ ........ ............ ......... .................. "
".......................................\n"
"#\n"
"    35.50% 0.55% 79 tarantool tarantool [.] lj_gc_step\n"
"            |\n"
"             --34.95%--lj_gc_step\n"
"                       |\n"
"                       |--29.26%--gc_onestep\n"
"                       | |\n"
"                       | |--13.85%--gc_sweep\n"
"                       | | |\n"
"                       | | |--5.59%--lj_alloc_free\n"
"                       | | |\n"
"                       | | |--1.33%--lj_tab_free\n"
"                       | | | |\n"
"                       | | | --1.01%--lj_alloc_free\n"
"                       | | |\n"
"                       | | --1.17%--lj_cdata_free\n"
"                       | |\n"
"                       | |--5.41%--gc_finalize\n"
"                       | | |\n"
"                       | | |--1.06%--lj_obj_equal\n"
"                       | | |\n"
"                       | | --0.95%--lj_tab_set\n"
"                       | |\n"
"                       | |--4.97%--rehashtab\n"
"                       | | |\n"
"                       | | --3.65%--lj_tab_resize\n"
"                       | | |\n"
"                       | | |--0.74%--lj_tab_set\n"
"                       | | |\n"
"                       | | --0.72%--lj_tab_newkey\n"
"                       | |\n"
"                       | |--0.91%--propagatemark\n"
"                       | |\n"
"                       | --0.67%--lj_cdata_free\n"
"                       |\n"
"                        --5.43%--propagatemark\n"
"                                  |\n"
"                                   --0.73%--gc_mark"
msgstr ""
"# Samples: 14K of event 'cycles'\n"
"# Event count (approx.): 9927346847\n"
"#\n"
"# Children Self Samples Command Shared Object Symbol\n"
"# ........ ........ ............ ......... .................. "
".......................................\n"
"#\n"
"    35.50% 0.55% 79 tarantool tarantool [.] lj_gc_step\n"
"            |\n"
"             --34.95%--lj_gc_step\n"
"                       |\n"
"                       |--29.26%--gc_onestep\n"
"                       | |\n"
"                       | |--13.85%--gc_sweep\n"
"                       | | |\n"
"                       | | |--5.59%--lj_alloc_free\n"
"                       | | |\n"
"                       | | |--1.33%--lj_tab_free\n"
"                       | | | |\n"
"                       | | | --1.01%--lj_alloc_free\n"
"                       | | |\n"
"                       | | --1.17%--lj_cdata_free\n"
"                       | |\n"
"                       | |--5.41%--gc_finalize\n"
"                       | | |\n"
"                       | | |--1.06%--lj_obj_equal\n"
"                       | | |\n"
"                       | | --0.95%--lj_tab_set\n"
"                       | |\n"
"                       | |--4.97%--rehashtab\n"
"                       | | |\n"
"                       | | --3.65%--lj_tab_resize\n"
"                       | | |\n"
"                       | | |--0.74%--lj_tab_set\n"
"                       | | |\n"
"                       | | --0.72%--lj_tab_newkey\n"
"                       | |\n"
"                       | |--0.91%--propagatemark\n"
"                       | |\n"
"                       | --0.67%--lj_cdata_free\n"
"                       |\n"
"                        --5.43%--propagatemark\n"
"                                  |\n"
"                                   --0.73%--gc_mark"

#: ../doc/book/admin/server_introspection.rst:627
msgid ""
"Unlike the poor man’s profilers, ``gperftools`` and ``perf`` have low "
"overhead (almost negligible as compared with ``pstack`` and ``gdb``): "
"they don’t result in long delays when attaching to a process and "
"therefore can be used without serious consequences."
msgstr ""
"Инструменты ``gperftools`` и ``perf`` отличаются от ``pstack`` и ``gdb`` "
"низкой затратой ресурсов (пренебрежимо малой по сравнению с ``pstack`` и "
"``gdb``): они подключаются к работающим процессам без больших задержек, а"
" потому могут использоваться без серьезных последствий."

#: ../doc/book/admin/server_introspection.rst:634
msgid "jit.p"
msgstr "jit.p"

#: ../doc/book/admin/server_introspection.rst:637
msgid ""
"The jit.p profiler comes with the Tarantool application server, to load "
"it one only needs to say ``require('jit.p')`` or "
"``require('jit.profile')``. There are many options for sampling and "
"display, they are described in the documentation for `The LuaJIT Profiler"
" <http://www.luatex.org/svn/trunk/source/libs/luajit/LuaJIT-"
"src/doc/ext_profiler.html>`_."
msgstr ""
"Профилировщик \"jit.p\" входит в комплект сервера приложений Tarantool'а."
" Чтобы загрузить его, выполните команду ``require('jit.p')`` или "
"``require('jit.profile')``. Есть много параметров для настройки выборки и"
" вывода, они описаны в документации по `Профилировщику LuaJIT "
"<http://www.luatex.org/svn/trunk/source/libs/luajit/LuaJIT-"
"src/doc/ext_profiler.html>`_."

#: ../doc/book/admin/server_introspection.rst:645
msgid ""
"Make a function that calls a function named f1 that does 500,000 inserts "
"and deletes in a Tarantool space. Start the profiler, execute the "
"function, stop the profiler, and show what the profiler sampled."
msgstr ""
"Создайте функцию для вызова функции под названием f1, которая "
"осуществляет 500 000 вставок и удалений в спейсе Tarantool'а. Запустите "
"профилировщик, выполните функцию, завершите работу профилировщика. "
"Получите результат выборки профилировщика."

#: ../doc/book/admin/server_introspection.rst:650
msgid ""
"box.space.t:drop()\n"
"box.schema.space.create('t')\n"
"box.space.t:create_index('i')\n"
"function f1() for i = 1,500000 do\n"
"  box.space.t:insert{i}\n"
"  box.space.t:delete{i}\n"
"  end\n"
"return 1\n"
"end\n"
"function f3() f1() end\n"
"jit_p = require(\"jit.profile\")\n"
"sampletable = {}\n"
"jit_p.start(\"f\", function(thread, samples, vmstate)\n"
"  local dump=jit_p.dumpstack(thread, \"f\", 1)\n"
"  sampletable[dump] = (sampletable[dump] or 0) + samples\n"
"end)\n"
"f3()\n"
"jit_p.stop()\n"
"for d,v in pairs(sampletable) do print(v, d) end"
msgstr ""
"box.space.t:drop()\n"
"box.schema.space.create('t')\n"
"box.space.t:create_index('i')\n"
"function f1() for i = 1,500000 do\n"
"  box.space.t:insert{i}\n"
"  box.space.t:delete{i}\n"
"  end\n"
"return 1\n"
"end\n"
"function f3() f1() end\n"
"jit_p = require(\"jit.profile\")\n"
"sampletable = {}\n"
"jit_p.start(\"f\", function(thread, samples, vmstate)\n"
"  local dump=jit_p.dumpstack(thread, \"f\", 1)\n"
"  sampletable[dump] = (sampletable[dump] or 0) + samples\n"
"end)\n"
"f3()\n"
"jit_p.stop()\n"
"for d,v in pairs(sampletable) do print(v, d) end"

#: ../doc/book/admin/server_introspection.rst:672
msgid ""
"Typically the result will show that the sampling happened within f1() "
"many times, but also within internal Tarantool functions, whose names may"
" change with each new version."
msgstr ""
"Как правило, результат покажет, что выборка многократно осуществлялась в "
"рамках f1(), а также в рамках внутренних функций Tarantool'а, имена "
"которых могут изменяться с каждой новой версией."

#: ../doc/book/admin/start_stop_instance.rst:5
msgid "Starting/stopping an instance"
msgstr "Запуск/остановка экземпляра"

#: ../doc/book/admin/start_stop_instance.rst:7
msgid ""
"While a Lua application is executed by Tarantool, an instance file is "
"executed by ``tarantoolctl`` which is a Tarantool script."
msgstr ""
"Lua-приложение выполняется Tarantool'ом, тогда как файл экземпляра "
"выполняется Tarantool-скриптом ``tarantoolctl``."

#: ../doc/book/admin/start_stop_instance.rst:10
msgid "Here is what ``tarantoolctl`` does when you issue the command:"
msgstr "Вот что делает ``tarantoolctl`` при вводе следующей команды:"

#: ../doc/book/admin/start_stop_instance.rst:12
msgid "$ tarantoolctl start <instance_name>"
msgstr "$ tarantoolctl start <имя_экземпляра>"

#: ../doc/book/admin/start_stop_instance.rst:16
msgid ""
"Read and parse the command line arguments. The last argument, in our "
"case, contains an instance name."
msgstr ""
"Считывает и разбирает аргументы командной строки. В нашем случае "
"последний аргумент содержит имя экземпляра."

#: ../doc/book/admin/start_stop_instance.rst:19
msgid ""
"Read and parse its own configuration file. This file contains "
"``tarantoolctl`` defaults, like the path to the directory where instances"
" should be searched for."
msgstr ""
"Считывает и разбирает собственный конфигурационный файл. Этот файл "
"содержит параметры ``tarantoolctl`` по умолчанию -- такие как путь до "
"директории, в которой располагаются экземпляры."

#: ../doc/book/admin/start_stop_instance.rst:23
msgid ""
"When ``tarantool`` is invoked by root, it looks for a configuration file "
"in ``/etc/default/tarantool``. When ``tarantool`` is invoked by a local "
"(non-root) user, it looks for a configuration file first in the current "
"directory (``$PWD/.tarantoolctl``), and then in the current user's home "
"directory (``$HOME/.config/tarantool/tarantool``). If no configuration "
"file is found there, or in the ``/usr/local/etc/default/tarantool`` file,"
" then ``tarantoolctl`` falls back to :ref:`built-in defaults <admin-"
"tarantoolctl_config_file>`."
msgstr ""
"Когда ``tarantoolctl`` вызывается с root-правами, он ищет "
"конфигурационный файл в ``/etc/default/tarantool``. Если вызов "
"``tarantool`` производит локальный пользователь, сначала он ищет "
"конфигурационный файл в текущей директории (``$PWD/.tarantoolctl``), а "
"затем в домашней директории текущего пользователя "
"(``$HOME/.config/tarantool/tarantool``). Если конфигурационный файл не "
"найден, ``tarantoolctl`` принимает :ref:`встроенные параметры по "
"умолчанию <admin-tarantoolctl_config_file>`."

#: ../doc/book/admin/start_stop_instance.rst:32
msgid ""
"Look up the instance file in the instance directory, for example "
"``/etc/tarantool/instances.enabled``. To build the instance file path, "
"``tarantoolctl`` takes the instance name, prepends the instance directory"
" and appends \".lua\" extension to the instance file."
msgstr ""
"Ищет файл экземпляра в директории, где располагаются экземпляры, "
"например, в ``/etc/tarantool/instances.enabled``. ``tarantoolctl`` строит"
" путь до файла экземпляра следующим образом: \"путь до директории с "
"экземплярами\" + \"имя экземпляра\" + \".lua\"."

#: ../doc/book/admin/start_stop_instance.rst:37
msgid ""
"Override :ref:`box.cfg{} <box_introspection-box_cfg>` function to pre-"
"process its parameters and ensure that instance paths are pointing to the"
" paths defined in the ``tarantoolctl`` configuration file. For example, "
"if the configuration file specifies that instance work directory must be "
"in ``/var/tarantool``, then the new implementation of ``box.cfg{}`` "
"ensures that :ref:`work_dir <cfg_basic-work_dir>` parameter in "
"``box.cfg{}`` is set to ``/var/tarantool/<instance_name>``, regardless of"
" what the path is set to in the instance file itself."
msgstr ""
"Переопределяет функцию :ref:`box.cfg{} <box_introspection-box_cfg>`, "
"чтобы предобработать ее параметры и сделать так, чтобы пути к экземплярам"
"  указывали на пути, прописанные в конфигурационном файле "
"``tarantoolctl``. Например, если в конфигурационном файле указано, что "
"рабочей директорией экземпляра является ``/var/tarantool``, то новая "
"реализация ``box.cfg{}`` сделает так, чтобы параметр :ref:`work_dir "
"<cfg_basic-work_dir>` в ``box.cfg{}`` имел значение "
"``/var/tarantool/<имя_экземпляра>``, независимо от того, какой путь "
"указан в самом файле экземпляра."

#: ../doc/book/admin/start_stop_instance.rst:46
msgid ""
"Create a so-called \"instance control file\". This is a Unix socket with "
"Lua console attached to it. This file is used later by ``tarantoolctl`` "
"to query the instance state, send commands to the instance and so on."
msgstr ""
"Создает так называемый \"файл для управления экземпляром\". Это "
"Unix-сокет с прикрепленной к нему Lua-консолью. В дальнейшем "
"``tarantoolctl`` использует этот файл для получения состояния экземпляра,"
"  отправки команд и т.д."

#: ../doc/book/admin/start_stop_instance.rst:50
msgid ""
"Set the TARANTOOLCTL environment variable to 'true'. This allows the user"
" to know that the instance was started by ``tarantoolctl``."
msgstr ""
"Задает значение переменной окружения TARANTOOLCTL = 'true'. Это позволит "
"пользователю понять, что экземпляр был запущен ``tarantoolctl``."

#: ../doc/book/admin/start_stop_instance.rst:53
msgid "Finally, use Lua ``dofile`` command to execute the instance file."
msgstr ""
"Наконец, использует Lua-команду ``dofile`` для выполнения файла "
"экземпляра."

#: ../doc/book/admin/start_stop_instance.rst:55
msgid ""
"If you start an instance using ``systemd`` tools, like this (the instance"
" name is ``my_app``):"
msgstr ""
"При запуске экземпляра с помощью инструментария ``systemd`` указанным "
"ниже способом (имя экземпляра -- ``my_app``):"

#: ../doc/book/admin/start_stop_instance.rst:58
msgid ""
"$ systemctl start tarantool@my_app\n"
"$ ps axuf|grep exampl[e]\n"
"taranto+  5350  1.3  0.3 1448872 7736 ?        Ssl  20:05   0:28 "
"tarantool my_app.lua <running>"
msgstr ""
"$ systemctl start tarantool@my_app\n"
"$ ps axuf|grep exampl[e]\n"
"taranto+  5350  1.3  0.3 1448872 7736 ?        Ssl  20:05   0:28 "
"tarantool my_app.lua <running>"

#: ../doc/book/admin/start_stop_instance.rst:64
msgid ""
"... this actually calls ``tarantoolctl`` like in case of ``tarantoolctl "
"start my_app``."
msgstr ""
"...на самом деле вызывается ``tarantoolctl`` -- так же, как и в случае "
"``tarantoolctl start my_app``."

#: ../doc/book/admin/start_stop_instance.rst:67
msgid ""
"To check the instance file for syntax errors prior to starting ``my_app``"
" instance, say:"
msgstr ""
"Для проверки файла экземпляра на наличие синтаксических ошибок перед "
"запуском экземпляра ``my_app`` используйте команду:"

#: ../doc/book/admin/start_stop_instance.rst:70
msgid "$ tarantoolctl check my_app"
msgstr "$ tarantoolctl check my_app"

#: ../doc/book/admin/start_stop_instance.rst:74
msgid "To enable ``my_app`` instance for auto-load during system startup, say:"
msgstr ""
"Для включения автоматической загрузки экземпляра ``my_app`` при запуске "
"всей системы используйте команду:"

#: ../doc/book/admin/start_stop_instance.rst:76
msgid "$ systemctl enable tarantool@my_app"
msgstr "$ systemctl enable tarantool@my_app"

#: ../doc/book/admin/start_stop_instance.rst:80
msgid "To stop a running ``my_app`` instance, say:"
msgstr "Для остановки работающего экземпляра ``my_app`` используйте команду:"

#: ../doc/book/admin/start_stop_instance.rst:82
msgid ""
"$ tarantoolctl stop my_app\n"
"$ # - OR -\n"
"$ systemctl stop tarantool@my_app"
msgstr ""
"$ tarantoolctl stop my_app\n"
"$ # - ИЛИ -\n"
"$ systemctl stop tarantool@my_app"

#: ../doc/book/admin/start_stop_instance.rst:88
msgid "To restart (i.e. stop and start) a running ``my_app`` instance, say:"
msgstr ""
"Для перезапуска (т.е. остановки и запуска) работающего экземпляра "
"``my_app`` используйте команду:"

#: ../doc/book/admin/start_stop_instance.rst:90
msgid ""
"$ tarantoolctl restart my_app\n"
"$ # - OR -\n"
"$ systemctl restart tarantool@my_app"
msgstr ""
"$ tarantoolctl restart my_app\n"
"$ # - ИЛИ -\n"
"$ systemctl restart tarantool@my_app"

#: ../doc/book/admin/start_stop_instance.rst:100
msgid "Running Tarantool locally"
msgstr "Локальный запуск Tarantool'а"

#: ../doc/book/admin/start_stop_instance.rst:102
msgid ""
"Sometimes you may need to run a Tarantool instance locally, e.g. for test"
" purposes. Let's configure a local instance, then start and monitor it "
"with ``tarantoolctl``."
msgstr ""
"Иногда бывает необходимо запустить Tarantool локально -- например, для "
"тестирования. Давайте настроим локальный экземпляр, запустим его и будем "
"мониторить с помощью ``tarantoolctl``."

#: ../doc/book/admin/start_stop_instance.rst:106
msgid "First, we create a sandbox directory on the user's path:"
msgstr "Сперва создадим директорию-песочницу по следующему пути:"

#: ../doc/book/admin/start_stop_instance.rst:108
msgid "$ mkdir ~/tarantool_test"
msgstr "$ mkdir ~/tarantool_test"

#: ../doc/book/admin/start_stop_instance.rst:112
msgid ""
"... and set default ``tarantoolctl`` configuration in "
"``$HOME/.config/tarantool/tarantool``. Let the file contents be:"
msgstr ""
"...и поместим конфигурационный файл с параметрами ``tarantoolctl`` по "
"умолчанию в ``$HOME/.config/tarantool/tarantool``. Содержимое файла будет"
" таким:"

#: ../doc/book/admin/start_stop_instance.rst:115
msgid ""
"default_cfg = {\n"
"    pid_file  = \"/home/user/tarantool_test/my_app.pid\",\n"
"    wal_dir   = \"/home/user/tarantool_test\",\n"
"    snap_dir  = \"/home/user/tarantool_test\",\n"
"    vinyl_dir = \"/home/user/tarantool_test\",\n"
"    log       = \"/home/user/tarantool_test/log\",\n"
"}\n"
"instance_dir = \"/home/user/tarantool_test\""
msgstr ""
"default_cfg = {\n"
"    pid_file  = \"/home/user/tarantool_test/my_app.pid\",\n"
"    wal_dir   = \"/home/user/tarantool_test\",\n"
"    snap_dir  = \"/home/user/tarantool_test\",\n"
"    vinyl_dir = \"/home/user/tarantool_test\",\n"
"    log       = \"/home/user/tarantool_test/log\",\n"
"}\n"
"instance_dir = \"/home/user/tarantool_test\""

#: ../doc/book/admin/start_stop_instance.rst:128
msgid "Specify a full path to the user's home directory instead of \"~/\"."
msgstr "Указывайте полный путь к домашней директории пользователя вместо \"~/\"."

#: ../doc/book/admin/start_stop_instance.rst:130
msgid ""
"Omit ``username`` parameter. ``tarantoolctl`` normally doesn't have "
"permissions to switch current user when invoked by a local user. The "
"instance will be running under 'admin'."
msgstr ""
"Опустите параметр ``username``. Обычно, когда запуск производит локальный"
"  пользователь, у ``tarantoolctl`` нет разрешения на смену текущего "
"пользователя. Экземпляр будет работать с пользователем 'admin'."

#: ../doc/book/admin/start_stop_instance.rst:134
msgid ""
"Next, we create the instance file ``~/tarantool_test/my_app.lua``. Let "
"the file contents be:"
msgstr ""
"Далее создадим файл экземпляра ``~/tarantool_test/my_app.lua``. "
"Содержимое файла будет таким:"

#: ../doc/book/admin/start_stop_instance.rst:137
msgid ""
"box.cfg{listen = 3301}\n"
"box.schema.user.passwd('Gx5!')\n"
"box.schema.user.grant('guest','read,write,execute','universe')\n"
"fiber = require('fiber')\n"
"box.schema.space.create('tester')\n"
"box.space.tester:create_index('primary',{})\n"
"i = 0\n"
"while 0 == 0 do\n"
"    fiber.sleep(5)\n"
"    i = i + 1\n"
"    print('insert ' .. i)\n"
"    box.space.tester:insert{i, 'my_app tuple'}\n"
"end"
msgstr ""
"box.cfg{listen = 3301}\n"
"box.schema.user.passwd('Gx5!')\n"
"box.schema.user.grant('guest','read,write,execute','universe')\n"
"fiber = require('fiber')\n"
"box.schema.space.create('tester')\n"
"box.space.tester:create_index('primary',{})\n"
"i = 0\n"
"while 0 == 0 do\n"
"    fiber.sleep(5)\n"
"    i = i + 1\n"
"    print('insert ' .. i)\n"
"    box.space.tester:insert{i, 'my_app tuple'}\n"
"end"

#: ../doc/book/admin/start_stop_instance.rst:153
msgid ""
"Let’s verify our instance file by starting it without ``tarantoolctl`` "
"first:"
msgstr "Проверим наш файл экземпляра, сперва запустив его без ``tarantoolctl``:"

#: ../doc/book/admin/start_stop_instance.rst:155
msgid ""
"$ cd ~/tarantool_test\n"
"$ tarantool my_app.lua\n"
"2017-04-06 10:42:15.762 [54085] main/101/my_app.lua C> version "
"1.7.3-489-gd86e36d5b\n"
"2017-04-06 10:42:15.763 [54085] main/101/my_app.lua C> log level 5\n"
"2017-04-06 10:42:15.764 [54085] main/101/my_app.lua I> mapping 268435456 "
"bytes for tuple arena...\n"
"2017-04-06 10:42:15.774 [54085] iproto/101/main I> binary: bound to "
"[::]:3301\n"
"2017-04-06 10:42:15.774 [54085] main/101/my_app.lua I> initializing an "
"empty data directory\n"
"2017-04-06 10:42:15.789 [54085] snapshot/101/main I> saving snapshot "
"`./00000000000000000000.snap.inprogress'\n"
"2017-04-06 10:42:15.790 [54085] snapshot/101/main I> done\n"
"2017-04-06 10:42:15.791 [54085] main/101/my_app.lua I> vinyl checkpoint "
"done\n"
"2017-04-06 10:42:15.791 [54085] main/101/my_app.lua I> ready to accept "
"requests\n"
"insert 1\n"
"insert 2\n"
"insert 3\n"
"<...>"
msgstr ""
"$ cd ~/tarantool_test\n"
"$ tarantool my_app.lua\n"
"2017-04-06 10:42:15.762 [54085] main/101/my_app.lua C> version "
"1.7.3-489-gd86e36d5b\n"
"2017-04-06 10:42:15.763 [54085] main/101/my_app.lua C> log level 5\n"
"2017-04-06 10:42:15.764 [54085] main/101/my_app.lua I> mapping 268435456 "
"bytes for tuple arena...\n"
"2017-04-06 10:42:15.774 [54085] iproto/101/main I> binary: bound to "
"[::]:3301\n"
"2017-04-06 10:42:15.774 [54085] main/101/my_app.lua I> initializing an "
"empty data directory\n"
"2017-04-06 10:42:15.789 [54085] snapshot/101/main I> saving snapshot "
"`./00000000000000000000.snap.inprogress'\n"
"2017-04-06 10:42:15.790 [54085] snapshot/101/main I> done\n"
"2017-04-06 10:42:15.791 [54085] main/101/my_app.lua I> vinyl checkpoint "
"done\n"
"2017-04-06 10:42:15.791 [54085] main/101/my_app.lua I> ready to accept "
"requests\n"
"insert 1\n"
"insert 2\n"
"insert 3\n"
"<...>"

#: ../doc/book/admin/start_stop_instance.rst:173
msgid "Now we tell ``tarantoolctl`` to start the Tarantool instance:"
msgstr "Запустим экземпляр Tarantool'а с помощью ``tarantoolctl``:"

#: ../doc/book/admin/start_stop_instance.rst:175
msgid "$ tarantoolctl start my_app"
msgstr "$ tarantoolctl start my_app"

#: ../doc/book/admin/start_stop_instance.rst:179
msgid "Expect to see messages indicating that the instance has started. Then:"
msgstr ""
"В консоли должны появиться сообщения о том, что экземпляр запущен. Затем "
"выполним следующую команду:"

#: ../doc/book/admin/start_stop_instance.rst:181
msgid "$ ls -l ~/tarantool_test/my_app"
msgstr "$ ls -l ~/tarantool_test/my_app"

#: ../doc/book/admin/start_stop_instance.rst:185
msgid "Expect to see the .snap file and the .xlog file. Then:"
msgstr ""
"В консоли должны появиться .snap-файл и .xlog-файл. Затем выполним "
"следующую команду:"

#: ../doc/book/admin/start_stop_instance.rst:187
msgid "$ less ~/tarantool_test/log/my_app.log"
msgstr "$ less ~/tarantool_test/log/my_app.log"

#: ../doc/book/admin/start_stop_instance.rst:191
msgid ""
"Expect to see the contents of ``my_app``‘s log, including error messages,"
" if any. Then:"
msgstr ""
"В консоли должно отобразиться содержимое файла журнала для приложения "
"``my_app``, в том числе сообщения об ошибках, если они были. Затем "
"выполним серию команд:"

#: ../doc/book/admin/start_stop_instance.rst:194
msgid ""
"$ tarantoolctl enter my_app\n"
"tarantool> box.cfg{}\n"
"tarantool> console = require('console')\n"
"tarantool> console.connect('localhost:3301')\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})"
msgstr ""
"$ tarantoolctl enter my_app\n"
"tarantool> box.cfg{}\n"
"tarantool> console = require('console')\n"
"tarantool> console.connect('localhost:3301')\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})"

#: ../doc/book/admin/start_stop_instance.rst:202
msgid "Expect to see several tuples that ``my_app`` has created."
msgstr ""
"В консоли должны появиться несколько кортежей, которые создало приложение"
" ``my_app``."

#: ../doc/book/admin/start_stop_instance.rst:204
msgid ""
"Stop now. A polite way to stop ``my_app`` is with ``tarantoolctl``, thus "
"we say:"
msgstr ""
"Теперь остановим приложение ``my_app``. Корректный способ остановки -- "
"это использовать``tarantoolctl``:"

#: ../doc/book/admin/start_stop_instance.rst:206
msgid "$ tarantoolctl stop my_app"
msgstr "$ tarantoolctl stop my_app"

#: ../doc/book/admin/start_stop_instance.rst:210
msgid "Finally, we make a cleanup."
msgstr "Последний шаг -- удаление тестовых данных."

#: ../doc/book/admin/start_stop_instance.rst:212
msgid "$ rm -R tarantool_test"
msgstr "$ rm -R tarantool_test"

#: ../doc/book/admin/troubleshoot.rst:6
msgid "Troubleshooting guide"
msgstr "Руководство по разрешению проблем"

#: ../doc/book/admin/troubleshoot.rst:8
msgid ""
"For this guide, you need to install Tarantool `stat "
"<https://github.com/tarantool/stat>`_ module:"
msgstr ""
"В данном руководстве используется сторонний модуль `stat "
"<https://github.com/tarantool/stat>`_. Для его установки выполните "
"команду:"

#: ../doc/book/admin/troubleshoot.rst:11
msgid ""
"$ sudo yum install tarantool-stat\n"
"$ # -- OR --\n"
"$ sudo apt-get install tarantool-stat"
msgstr ""
"$ sudo yum install tarantool-stat\n"
"$ # -- ИЛИ --\n"
"$ sudo apt-get install tarantool-stat"

#: ../doc/book/admin/troubleshoot.rst:21
msgid "Problem: INSERT/UPDATE-requests result in ER_MEMORY_ISSUE error"
msgstr ""
"Проблема: при выполнении INSERT/UPDATE-запросов возникает ошибка "
"ER_MEMORY_ISSUE"

#: ../doc/book/admin/troubleshoot.rst:23 ../doc/book/admin/troubleshoot.rst:81
#: ../doc/book/admin/troubleshoot.rst:127
#: ../doc/book/admin/troubleshoot.rst:189
#: ../doc/book/admin/troubleshoot.rst:212
#: ../doc/book/admin/troubleshoot.rst:237
#: ../doc/book/admin/troubleshoot.rst:254
#: ../doc/book/admin/troubleshoot.rst:289
msgid "**Possible reasons**"
msgstr "**Возможные причины**"

#: ../doc/book/admin/troubleshoot.rst:25
msgid ""
"Lack of RAM (parameters ``arena_used_ratio`` and ``quota_used_ratio`` in "
":ref:`box.slab.info() <box_slab_info>` report are getting close to 100%)."
msgstr ""
"Нехватка памяти (значения параметров ``arena_used_ratio`` и "
"``quota_used_ratio`` из  :ref:`box.slab.info() <box_slab_info>` "
"приближаются к 100%)."

#: ../doc/book/admin/troubleshoot.rst:28
msgid "To check these parameters, say:"
msgstr ""
"Чтобы проверить значения данных параметров, выполните соответствующие "
"команды:"

#: ../doc/book/admin/troubleshoot.rst:30 ../doc/book/admin/troubleshoot.rst:92
#: ../doc/book/admin/troubleshoot.rst:149
#: ../doc/book/admin/troubleshoot.rst:266
#: ../doc/book/admin/troubleshoot.rst:302
msgid ""
"$ # attaching to a Tarantool instance\n"
"$ tarantoolctl enter <instance_name>\n"
"$ # -- OR --\n"
"$ tarantoolctl connect <URI>"
msgstr ""
"$ # подключаемся к админ-консоли нужного экземпляра\n"
"$ tarantoolctl enter <instance_name>\n"
"$ # -- ИЛИ --\n"
"$ tarantoolctl connect <URI>"

#: ../doc/book/admin/troubleshoot.rst:37
msgid ""
"-- requesting arena_used_ratio value\n"
"tarantool> require('stat').stat()['slab.arena_used_ratio']\n"
"\n"
"-- requesting quota_used_ratio value\n"
"tarantool> require('stat').stat()['slab.quota_used_ratio']"
msgstr ""
"-- запрашиваем значение arena_used_ratio\n"
"tarantool> require('stat').stat()['slab.arena_used_ratio']\n"
"\n"
"-- запрашиваем значение quota_used_ratio\n"
"tarantool> require('stat').stat()['slab.quota_used_ratio']"

#: ../doc/book/admin/troubleshoot.rst:45 ../doc/book/admin/troubleshoot.rst:86
#: ../doc/book/admin/troubleshoot.rst:137
#: ../doc/book/admin/troubleshoot.rst:170
#: ../doc/book/admin/troubleshoot.rst:194
#: ../doc/book/admin/troubleshoot.rst:217
#: ../doc/book/admin/troubleshoot.rst:241
#: ../doc/book/admin/troubleshoot.rst:262
#: ../doc/book/admin/troubleshoot.rst:293
msgid "**Solution**"
msgstr "**Решение**"

#: ../doc/book/admin/troubleshoot.rst:47 ../doc/book/admin/troubleshoot.rst:139
msgid "Try either of the following measures:"
msgstr "У вас есть несколько вариантов действий:"

#: ../doc/book/admin/troubleshoot.rst:49
msgid ""
"In Tarantool's :ref:`instance file <admin-instance_config>`, increase the"
" value of :ref:`box.cfg{memtx_memory} <cfg_storage-memtx_memory>` (if "
"memory resources are available)."
msgstr ""
"Зайти в :ref:`конфигурационный файл <admin-instance_config>` Tarantool и "
"увеличить значение параметра :ref:`box.cfg{memtx_memory} <cfg_storage-"
"memtx_memory>` (при наличии свободных ресурсов)."

#: ../doc/book/admin/troubleshoot.rst:53
#, python-format
msgid ""
"In versions of Tarantool before 1.10, the server needs to be restarted to"
" change this parameter. The Tarantool server will be unavailable while "
"restarting from .xlog files, unless you restart it using :ref:`hot "
"standby <index-hot_standby>` mode. In the latter case, nearly 100% server"
" availability is guaranteed."
msgstr ""
"В версиях Tarantool'а до 1.10 для изменения данного параметра требуется "
"перезагрузить сервер. При обычной перезагрузке сервер будет недоступен на"
" время старта Tarantool из .xlog-файлов. При перезагрузке в режиме "
"горячего резервирования :ref:`hot standby <index-hot_standby>` "
"гарантирована практически 100%-ная доступность."

#: ../doc/book/admin/troubleshoot.rst:59
msgid "Clean up the database."
msgstr "Провести очистку базы данных."

#: ../doc/book/admin/troubleshoot.rst:61
msgid "Check the indicators of memory fragmentation:"
msgstr "Проверьте, нет ли проблем с фрагментацией памяти:"

#: ../doc/book/admin/troubleshoot.rst:63
msgid ""
"-- requesting quota_used_ratio value\n"
"tarantool> require('stat').stat()['slab.quota_used_ratio']\n"
"\n"
"-- requesting items_used_ratio value\n"
"tarantool> require('stat').stat()['slab.items_used_ratio']"
msgstr ""
"-- запрашиваем значение quota_used_ratio\n"
"tarantool> require('stat').stat()['slab.quota_used_ratio']\n"
"\n"
"-- запрашиваем значение items_used_ratio\n"
"tarantool> require('stat').stat()['slab.items_used_ratio']"

#: ../doc/book/admin/troubleshoot.rst:71
msgid ""
"In case of heavy memory fragmentation (``quota_used_ratio`` is getting "
"close to 100%, ``items_used_ratio`` is about 50%), we recommend "
"restarting Tarantool in the :ref:`hot standby <index-hot_standby>` mode."
msgstr ""
"При высокой степени фрагментации памяти (значение параметра "
"``quota_used_ratio`` приближается к 100%, ``items_used_ratio`` около 50%)"
"  рекомендуется перезапустить Tarantool в режиме горячего резервирования "
":ref:`hot standby <index-hot_standby>`."

#: ../doc/book/admin/troubleshoot.rst:79
msgid "Problem: Tarantool generates too heavy CPU load"
msgstr "Проблема: Tarantool создает большую нагрузку на CPU"

#: ../doc/book/admin/troubleshoot.rst:83
msgid ""
"The :ref:`transaction processor thread <atomic-threads_fibers_yields>` "
"consumes over 60% CPU."
msgstr ""
":ref:`Поток обработки транзакций <atomic-threads_fibers_yields>` "
"нагружает ЦП более чем на 60%."

#: ../doc/book/admin/troubleshoot.rst:88
msgid ""
"Attach to the Tarantool instance with :ref:`tarantoolctl <tarantoolctl>` "
"utility, analyze the query statistics with :ref:`box.stat() "
"<box_introspection-box_stat>` and spot the CPU consumption leader. The "
"following commands can help:"
msgstr ""
"Подключиться к Tarantool с помощью утилиты :ref:`tarantoolctl "
"<tarantoolctl>`, внимательно изучить статистику запросов с помощью "
":ref:`box.stat() <box_introspection-box_stat>` и выявить источник "
"потребления. Для этой цели могут оказаться полезными следующие команды:"

#: ../doc/book/admin/troubleshoot.rst:99
msgid ""
"-- checking the RPS of calling stored procedures\n"
"tarantool> require('stat').stat()['stat.op.call.rps']"
msgstr ""
"-- запрашиваем RPS для вызовов хранимых процедур\n"
"tarantool> require('stat').stat()['stat.op.call.rps']"

#: ../doc/book/admin/troubleshoot.rst:104
msgid ""
"The critical RPS value is 75 000, boiling down to 10 000 - 20 000 for a "
"rich Lua application (a Lua module of 200+ lines)."
msgstr ""
"Критическое значение RPS -- 75 000, в случае большого Lua-приложения "
"(модульного приложения, содержащего более 200 строк кода) -- 10 000 - 20 "
"000."

#: ../doc/book/admin/troubleshoot.rst:107
msgid ""
"-- checking RPS per query type\n"
"tarantool> require('stat').stat()['stat.op.<query_type>.rps']"
msgstr ""
"-- запрашиваем RPS для запросов указанного типа\n"
"tarantool> require('stat').stat()['stat.op.<query_type>.rps']"

#: ../doc/book/admin/troubleshoot.rst:112
msgid ""
"The critical RPS value for SELECT/INSERT/UPDATE/DELETE requests is 100 "
"000."
msgstr ""
"Критическое значение RPS для запросов типа SELECT/INSERT/UPDATE/DELETE --"
" 100 000."

#: ../doc/book/admin/troubleshoot.rst:114
msgid ""
"If the load is mostly generated by SELECT requests, we recommend adding a"
" :ref:`slave server <replication-bootstrap>` and let it process part of "
"the queries."
msgstr ""
"Если основная нагрузка генерируется SELECT-запросами, следует добавить "
":ref:`slave-сервер <replication-bootstrap>` и часть запросов обрабатывать"
"  на нем."

#: ../doc/book/admin/troubleshoot.rst:118
msgid ""
"If the load is mostly generated by INSERT/UPDATE/DELETE requests, we "
"recommend :ref:`sharding the database <shard-module>`."
msgstr ""
"Если же нагрузка по большей части приходится на "
"INSERT/UPDATE/DELETE-запросы, рекомендуется провести :ref:`шардинг базы "
"данных <shard-module>`."

#: ../doc/book/admin/troubleshoot.rst:125
msgid "Problem: Query processing times out"
msgstr "Проблема: обработка запросов прекращается по таймауту"

#: ../doc/book/admin/troubleshoot.rst:131
msgid ""
"All reasons that we discuss here can be identified by messages in "
"Tarantool's log file, all starting with the words ``'Too long...'``."
msgstr ""
"Все описанные ниже ситуации можно распознать по записям в журнале "
"Tarantool, начинающимся со слов ``'Too long...'``."

#: ../doc/book/admin/troubleshoot.rst:134
msgid ""
"Both fast and slow queries are processed within a single connection, so "
"the readahead buffer is cluttered with slow queries."
msgstr ""
"Быстрые и медленные запросы обрабатываются в одном подключении, что "
"приводит к забиванию readahead-буфера медленными запросами."

#: ../doc/book/admin/troubleshoot.rst:141
msgid ""
"Increase the readahead buffer size (:ref:`box.cfg{readahead} "
"<cfg_networking-readahead>` parameter)."
msgstr ""
"Увеличить размер readahead-буфера (:ref:`box.cfg{readahead} "
"<cfg_networking-readahead>`)."

#: ../doc/book/admin/troubleshoot.rst:144
msgid ""
"This parameter can be changed on the fly, so you don't need to restart "
"Tarantool. Attach to the Tarantool instance with :ref:`tarantoolctl "
"<tarantoolctl>` utility and call ``box.cfg{}`` with a new ``readahead`` "
"value:"
msgstr ""
"Перезапускать Tarantool при этом не требуется. Для обновления "
"конфигурации необходимо подключиться к Tarantool с помощью утилиты "
":ref:`tarantoolctl <tarantoolctl>` и передать в ``box.cfg{}`` новое "
"значение параметра ``readahead``:"

#: ../doc/book/admin/troubleshoot.rst:156
msgid ""
"-- changing the readahead value\n"
"tarantool> box.cfg{readahead = 10 * 1024 * 1024}"
msgstr ""
"-- задаем новое значение readahead\n"
"tarantool> box.cfg{readahead = 10 * 1024 * 1024}"

#: ../doc/book/admin/troubleshoot.rst:161
msgid ""
"**Example:** Given 1000 RPS, 1 Кbyte of query size, and 10 seconds of "
"maximal query processing time, the minimal readahead buffer size must be "
"10 Mbytes."
msgstr ""
"**Пример расчета:** при 1000 RPS, размере одного запроса в 1 Кбайт и "
"максимальном времени обработки одного запроса в 10 секунд минимальный "
"размер readahead-буфера должен равняться 10 Мбайт."

#: ../doc/book/admin/troubleshoot.rst:165
msgid ""
"On the business logic level, split fast and slow queries processing by "
"different connections."
msgstr ""
"Обрабатывать быстрые и медленные запросы в отдельных подключениях "
"(решается на уровне бизнес-логики)."

#: ../doc/book/admin/troubleshoot.rst:168
msgid "Slow disks."
msgstr "Медленная работа дисков."

#: ../doc/book/admin/troubleshoot.rst:172
msgid ""
"Check disk performance (use `iostat "
"<https://linux.die.net/man/1/iostat>`_, `iotop "
"<https://linux.die.net/man/1/iotop>`_ or `strace "
"<https://linux.die.net/man/1/strace>`_ utility to check ``iowait`` "
"parameter) and try to put .xlog files and snapshot files on different "
"physical disks (i.e. use different locations for :ref:`wal_dir "
"<cfg_basic-wal_dir>` and :ref:`memtx_dir <cfg_basic-memtx_dir>`)."
msgstr ""
"Проверить занятость дисков (с помощью утилиты `iostat "
"<https://linux.die.net/man/1/iostat>`_, `iotop "
"<https://linux.die.net/man/1/iotop>`_ или `strace "
"<https://linux.die.net/man/1/strace>`_ посмотреть на параметр ``iowait``)"
"  и попробовать разнести .xlog-файлы и снимки состояния базы данных по "
"разным дискам (т.е. указать разные значения для параметров  :ref:`wal_dir"
"  <cfg_basic-wal_dir>` и :ref:`memtx_dir <cfg_basic-memtx_dir>`)."

#: ../doc/book/admin/troubleshoot.rst:183
msgid "Problem: Replication \"lag\" and \"idle\" contain negative values"
msgstr "Проблема: параметры репликации lag и idle принимают отрицательные значения"

#: ../doc/book/admin/troubleshoot.rst:185
msgid ""
"This is about ``box.info.replication.(upstream.)lag`` and "
"``box.info.replication.(upstream.)idle`` values in "
":ref:`box.info.replication <box_info_replication>` section."
msgstr ""
"Речь идет о параметрах ``box.info.replication.(upstream.)lag`` и "
"``box.info.replication.(upstream.)idle`` из сводной таблицы "
":ref:`box.info.replication <box_info_replication>`."

#: ../doc/book/admin/troubleshoot.rst:191
msgid ""
"Operating system clock on the hosts is not synchronized, or the NTP "
"server is faulty."
msgstr "Не синхронизированы часы на машинах или  неправильно работает NTP-сервер."

#: ../doc/book/admin/troubleshoot.rst:196
msgid "Check NTP server settings."
msgstr "Проверить настройки NTP-сервера."

#: ../doc/book/admin/troubleshoot.rst:198
msgid ""
"If you found no problems with the NTP server, just do nothing then. Lag "
"calculation uses operating system clock from two different machines. If "
"they get out of sync, the remote master clock can get consistently behind"
" the local instance’s clock."
msgstr ""
"Если проблем с NTP-сервером не обнаружено, то не следует ничего "
"предпринимать, потому что при вычислении лага репликации используются "
"показания системных часов на двух разных машинах, и в случае "
"рассинхронизации может случиться так, что часы удаленного мастер-сервера "
"всегда будут отставать от часов локального экземпляра Tarantool."

#: ../doc/book/admin/troubleshoot.rst:207
msgid ""
"Problem: Replication \"idle\" keeps growing, but no related log messages "
"appear"
msgstr ""
"Проблема: значение параметра idle растет, но журнал не содержит связанных"
"  с этим сообщений"

#: ../doc/book/admin/troubleshoot.rst:209
msgid ""
"This is about ``box.info.replication.(upstream.)idle`` value in "
":ref:`box.info.replication <box_info_replication>` section."
msgstr ""
"Речь идет о параметре ``box.info.replication.(upstream.)idle`` из сводной"
"  таблицы :ref:`box.info.replication <box_info_replication>`."

#: ../doc/book/admin/troubleshoot.rst:214
msgid ""
"Some server was assigned different IP addresses, or some server was "
"specified twice in ``box.cfg{}``, so duplicate connections were "
"established."
msgstr ""
"Одному серверу были назначены различные IP-адреса или один и тот же "
"сервер был указан в ``box.cfg{}`` дважды, что привело к установлению "
"дублирующего подключения."

#: ../doc/book/admin/troubleshoot.rst:219
#, fuzzy
msgid ""
":ref:`Upgrade Tarantool 1.6 to 1.7 <admin-upgrades_instance>`, where this"
" error is fixed: in case of duplicate connections, replication is stopped"
" and the following message is added to the log: ``'Incorrect value for "
"option ''replication_source'': duplicate connection with the same replica"
" UUID'``."
msgstr ""
":ref:`Обновить Tarantool 1.6 до 1.9+ <admin-upgrades_instance>`, где эта "
"ошибка была исправлена: в описанной ситуации репликация будет "
"остановлена, а в журнал будет записана следующая ошибка: ``'Incorrect "
"value for option ''replication_source'': duplicate connection with the "
"same replica UUID'``."

#: ../doc/book/admin/troubleshoot.rst:229
msgid "Problem: Replication statistics differ on replicas within a replica set"
msgstr ""
"Проблема: общие параметры репликации не совпадают на репликах в рамках "
"одного кластера"

#: ../doc/book/admin/troubleshoot.rst:231
msgid ""
"This is about a replica set that consists of one master and several "
"replicas. In a replica set of this type, values in "
":ref:`box.info.replication <box_info_replication>` section, like "
"``box.info.replication.lsn``, come from the master and must be the same "
"on all replicas within the replica set. The problem is that they get "
"different."
msgstr ""
"Речь идет о кластере, состоящем из одного мастера и нескольких реплик. В "
"таком случае значения общих параметров из сводной таблицы "
":ref:`box.info.replication <box_info_replication>`, например "
"``box.info.replication.lsn``, должны приходить с мастера и должны быть "
"одинаковыми на всех репликах. Если такие параметры не совпадают, это "
"свидетельствует о наличии проблем."

#: ../doc/book/admin/troubleshoot.rst:239
msgid "Replication is broken."
msgstr "Сбой репликации."

#: ../doc/book/admin/troubleshoot.rst:243
msgid ":ref:`Restart replication <replication-recover>`."
msgstr ":ref:`Перезапустить репликацию <replication-recover>`."

#: ../doc/book/admin/troubleshoot.rst:249
msgid "Problem: Master-master replication is stopped"
msgstr "Проблема: репликация мастер-мастер остановлена"

#: ../doc/book/admin/troubleshoot.rst:251
msgid ""
"This is about :ref:`box.info.replication(.upstream).status "
"<box_info_replication>` = stopped."
msgstr ""
"Речь идет о том, что параметр "
":ref:`box.info.replication(.upstream).status <box_info_replication>` "
"имеет значение stopped."

#: ../doc/book/admin/troubleshoot.rst:256
msgid ""
"In a master-master replica set of two Tarantool instances, one of the "
"masters has tried to perform an action already performed by the other "
"server, for example re-insert a tuple with the same unique key. This "
"would cause an error message like ``'Duplicate key exists in unique index"
" 'primary' in space <space_name>'``."
msgstr ""
"В репликационном кластере, состоящем из двух мастер-серверов, один из "
"серверов попытался выполнить действие, уже выполненное другим сервером, "
"-- например, повторно вставить кортеж с таким же уникальным ключом "
"(распознается по ошибке вида ``'Duplicate key exists in unique index "
"'primary' in space <space_name>'``)."

#: ../doc/book/admin/troubleshoot.rst:264
msgid "Restart replication with the following commands (at each master instance):"
msgstr ""
"Возобновить репликацию с помощью следующих команд (должны быть выполнены "
"на всех мастер-серверах):"

#: ../doc/book/admin/troubleshoot.rst:273
msgid ""
"-- restarting replication\n"
"tarantool> original_value = box.cfg.replication\n"
"tarantool> box.cfg{replication={}}\n"
"tarantool> box.cfg{replication=original_value}"
msgstr ""
"-- перезапускаем репликацию\n"
"tarantool> original_value = box.cfg.replication\n"
"tarantool> box.cfg{replication={}}\n"
"tarantool> box.cfg{replication=original_value}"

#: ../doc/book/admin/troubleshoot.rst:280
msgid ""
"We also recommend using text primary keys or setting up :ref:`master-"
"slave replication <replication-master_replica_bootstrap>`."
msgstr ""
"Также рекомендуется перейти на текстовые первичные ключи или настроить "
":ref:`репликацию мастер-реплика <replication-master_replica_bootstrap>`."

#: ../doc/book/admin/troubleshoot.rst:287
msgid "Problem: Tarantool works much slower than before"
msgstr "Проблема: Tarantool работает заметно медленнее, чем раньше"

#: ../doc/book/admin/troubleshoot.rst:291
msgid ""
"Inefficient memory usage (RAM is cluttered with a huge amount of unused "
"objects)."
msgstr ""
"Неэффективное использование памяти (память занята большим количеством "
"неиспользуемых объектов)."

#: ../doc/book/admin/troubleshoot.rst:295
msgid ""
"Call the Lua garbage collector with the `collectgarbage('count') function"
" <https://www.lua.org/manual/5.1/manual.html#pdf-collectgarbage>`_ and "
"measure its execution time with the Tarantool functions "
":ref:`clock.bench() <clock-bench>` or :ref:`clock.proc() <clock-proc>`."
msgstr ""
"Запустить сборщик мусора в Lua с помощью `функции collectgarbage(count) "
"<https://www.lua.org/manual/5.1/manual.html#pdf-collectgarbage>`_ и "
"измерить время ее выполнения с помощью :ref:`clock.bench() <clock-bench>`"
"  или :ref:`clock.proc() <clock-proc>`."

#: ../doc/book/admin/troubleshoot.rst:300
msgid "Example of calculating memory usage statistics:"
msgstr "Пример кода для подсчета потребляемой памяти:"

#: ../doc/book/admin/troubleshoot.rst:309
msgid ""
"-- loading Tarantool's \"clock\" module with time-related routines\n"
"tarantool> local clock = require 'clock'\n"
"-- starting the timer\n"
"tarantool> local b = clock.proc()\n"
"-- launching garbage collection\n"
"tarantool> local c = collectgarbage('count')\n"
"-- stopping the timer after garbage collection is completed\n"
"tarantool> return c, clock.proc() - b"
msgstr ""
"-- загрузка модуля clock для работы со временем\n"
"tarantool> local clock = require 'clock'\n"
"-- запускаем таймер\n"
"tarantool> local b = clock.proc()\n"
"-- запускаем сборку мусора\n"
"tarantool> local c = collectgarbage('count')\n"
"-- останавливаем таймер по завершении сборки мусора\n"
"tarantool> return c, clock.proc() - b"

#: ../doc/book/admin/troubleshoot.rst:320
msgid ""
"If the returned ``clock.proc()`` value is greater than 0.001, this may be"
" an indicator of inefficient memory usage (no active measures are "
"required, but we recommend to optimize your Tarantool application code)."
msgstr ""
"Если возвращаемое ``clock.proc()`` значение больше 0.001, это может "
"являться признаком неэффективного использования памяти (активного "
"вмешательства не требуется, но рекомендуется оптимизация кода). Если "
"значение превышает 0.01, необходимо провести подробный анализ кода и "
"оптимизировать потребление памяти."

#: ../doc/book/admin/troubleshoot.rst:324
msgid ""
"If the value is greater than 0.01, your application definitely needs "
"thorough code analysis aimed at optimizing memory usage."
msgstr ""
"Если значение больше 0,01, код приложения однозначно необходимо "
"проанализировать на предмет оптимизации использования памяти."

#: ../doc/book/admin/upgrades.rst:5
msgid "Upgrades"
msgstr "Обновление"

#: ../doc/book/admin/upgrades.rst:11
msgid "Upgrading a Tarantool database"
msgstr "Обновление базы данных Tarantool"

#: ../doc/book/admin/upgrades.rst:13
msgid ""
"If you created a database with an older Tarantool version and have now "
"installed a newer version, make the request ``box.schema.upgrade()``. "
"This updates Tarantool system spaces to match the currently installed "
"version of Tarantool."
msgstr ""
"Если вы создали базу данных в старой версии Tarantool'а, а потом обновили"
"  Tarantool до более свежей версии, вызовите команду "
"``box.schema.upgrade()``. Она обновляет системные спейсы Tarantool'а так,"
"  чтобы они совпадали с текущей установленной версией Tarantool'а."

#: ../doc/book/admin/upgrades.rst:17
msgid ""
"For example, here is what happens when you run ``box.schema.upgrade()`` "
"with a database created with Tarantool version 1.6.4 to version 1.7.2 "
"(only a small part of the output is shown):"
msgstr ""
"Например, вот что происходит, если выполнить команду "
"``box.schema.upgrade()`` для базы данных, созданной в Tarantool версии "
"1.6.4 (показана лишь малая часть выводимых сообщений):"

#: ../doc/book/admin/upgrades.rst:21
msgid ""
"tarantool> box.schema.upgrade()\n"
"alter index primary on _space set options to {\"unique\":true}, parts to "
"[[0,\"unsigned\"]]\n"
"alter space _schema set options to {}\n"
"create view _vindex...\n"
"grant read access to 'public' role for _vindex view\n"
"set schema version to 1.7.0\n"
"---\n"
"..."
msgstr ""
"tarantool> box.schema.upgrade()\n"
"alter index primary on _space set options to {\"unique\":true}, parts to "
"[[0,\"unsigned\"]]\n"
"alter space _schema set options to {}\n"
"create view _vindex...\n"
"grant read access to 'public' role for _vindex view\n"
"set schema version to 1.7.0\n"
"---\n"
"..."

#: ../doc/book/admin/upgrades.rst:36
msgid "Upgrading a Tarantool instance"
msgstr "Обновление экземпляра Tarantool'а"

#: ../doc/book/admin/upgrades.rst:38
#, fuzzy
msgid ""
"Tarantool is backward compatible between two adjacent versions. For "
"example, you should have no or little trouble when upgrading from "
"Tarantool 1.6 to 1.7, or from Tarantool 1.7 to 2.x. Meanwhile Tarantool "
"2.x may have incompatible changes when migrating from Tarantool 1.6. to "
"2.x directly."
msgstr ""
"Tarantool поддерживает обратную совместимость между двумя "
"последовательными версиями. Например, обновление Tarantool 1.6 до 1.7 или"
"  Tarantool 1.7 до 1.8 не должно вызвать затруднений, тогда как миграции "
"с  Tarantool 1.6 прямиком на 1.8 могут препятствовать несовместимые "
"изменения."

#: ../doc/book/admin/upgrades.rst:47
#, fuzzy
msgid "How to upgrade from Tarantool 1.7 to 2.x"
msgstr "Как обновить Tarantool 1.6 до 1.7 / 1.10"

#: ../doc/book/admin/upgrades.rst:49 ../doc/book/admin/upgrades.rst:92
msgid "Stop the Tarantool server."
msgstr "Остановите Tarantool-сервер."

#: ../doc/book/admin/upgrades.rst:51 ../doc/book/admin/upgrades.rst:94
msgid ""
"Make a copy of all data (see an appropriate hot backup procedure in "
":ref:`Backups <admin-backups>`) and the package from which the current "
"(old) version was installed (for rollback purposes)."
msgstr ""
"Создайте копию всех данных (см. подразделы про горячее резервное "
"копирование в разделе :ref:`Резервное копирование <admin-backups>`) и "
"пакета, из которого была установлена текущая (старая) версия (на случай "
"отката)."

#: ../doc/book/admin/upgrades.rst:55 ../doc/book/admin/upgrades.rst:98
msgid ""
"Update the Tarantool server. See installation instructions at Tarantool "
"`download page <http://tarantool.org/download.html>`_."
msgstr ""
"Обновите Tarantool-сервер. Инструкции по установке доступны на `странице "
"загрузок Tarantool'а <http://tarantool.org/download.html>`_."

#: ../doc/book/admin/upgrades.rst:58 ../doc/book/admin/upgrades.rst:109
msgid ""
"Launch the updated Tarantool server using ``tarantoolctl`` or "
"``systemctl``."
msgstr ""
"Запустите обновленный Tarantool-сервер с помощью ``tarantoolctl`` или "
"``systemctl``."

#: ../doc/book/admin/upgrades.rst:64
#, fuzzy
msgid "How to upgrade from Tarantool 1.6 to 2.x"
msgstr "Как обновить Tarantool 1.6 до 1.7 / 1.10"

#: ../doc/book/admin/upgrades.rst:66
msgid ""
"The procedure is fully analogous to :ref:`upgrading from 1.7 to 2.x "
"<admin-upgrades_instance_17_to_20>`."
msgstr ""

#: ../doc/book/admin/upgrades.rst:73
#, fuzzy
msgid "How to upgrade from Tarantool 1.6 to 1.7"
msgstr "Как обновить Tarantool 1.6 до 1.7 / 1.10"

#: ../doc/book/admin/upgrades.rst:75
#, fuzzy
msgid ""
"This procedure is for upgrading a standalone Tarantool instance in "
"production from 1.6.x to 1.7.x. Notice that this will **always imply a "
"downtime**. To upgrade **without downtime**, you need several Tarantool "
"servers running in a replication cluster (see :ref:`below <admin-"
"upgrades_replication_cluster>`)."
msgstr ""
"Этот процесс предназначен для обновления индивидуальных экземпляров "
"Tarantool'а с 1.6.х до 1.7.х (или до 1.10.x) на боевом сервере. Обратите "
"внимание, что это **всегда приводит к некоторому простою**. Для "
"обновления **без простоев** необходимо, чтобы несколько работающих "
"Tarantool-серверов были объединены в репликационный кластер (см. "
":ref:`ниже <admin-upgrades_replication_cluster>`)."

#: ../doc/book/admin/upgrades.rst:80
#, fuzzy
msgid ""
"Tarantool 1.7 has an incompatible :ref:`.snap <internals-snapshot>` and "
":ref:`.xlog <internals-wal>` file format: 1.6 files are supported during "
"upgrade, but you won’t be able to return to 1.6 after running under 1.7 "
"for a while. It also renames a few configuration parameters, but old "
"parameters are supported. The full list of breaking changes is available "
"in `release notes for Tarantool 1.7 "
"<https://github.com/tarantool/tarantool/releases>`_."
msgstr ""
"Tarantool 1.7 работает с несовместимыми форматами файлов -- :ref:`.snap "
"<internals-snapshot>` и :ref:`.xlog <internals-wal>`. Файлы Tarantool'а "
"1.6 поддерживаются при обновлении, но после непродолжительного "
"использования Tarantool'а 1.7 вернуться к 1.6 уже нельзя. Также были "
"переименованы некоторые конфигурационные параметры, но старые параметры "
"еще поддерживаются. Список критических изменений доступен в `Примечаниях "
"к версиям Tarantool'а 1.7 / 1.9 / 1.10 "
"<https://github.com/tarantool/tarantool/releases>`_."

#: ../doc/book/admin/upgrades.rst:87
#, fuzzy
msgid ""
"Check with application developers whether application files need to be "
"updated due to incompatible changes (see `1.7 release notes "
"<https://github.com/tarantool/tarantool/releases>`_). If yes, back up the"
" old application files."
msgstr ""
"Уточните у разработчиков, необходимо ли обновлять файлы приложения из-за "
"наличия несовместимых изменений (см. `Примечания к версиям Tarantool'а "
"1.7 / 1.9 / 1.10 <https://github.com/tarantool/tarantool/releases>`_). "
"Если да, то создайте резервные копии старых файлов приложения."

#: ../doc/book/admin/upgrades.rst:101
msgid ""
"Update the Tarantool database. Put the request ``box.schema.upgrade()`` "
"inside a :ref:`box.once() <box-once>` function in your Tarantool "
":ref:`initialization file <index-init_label>`. On startup, this will "
"create new system spaces, update data type names (e.g. num -> unsigned, "
"str -> string) and options in Tarantool system spaces."
msgstr ""
"Обновите базу данных Tarantool. Выполните команду "
"``box.schema.upgrade()``, поместив ее внутрь функции :ref:`box.once() "
"<box-once>` в :ref:`файле инициализации <index-init_label>` Tarantool'а. "
"В результате на этапе запуска Tarantool создаст новые системные спейсы, "
"обновит названия типов данных (например, num -> unsigned, str -> string) "
"и список доступных типов данных в системных спейсах."

#: ../doc/book/admin/upgrades.rst:107
msgid "Update application files, if needed."
msgstr "При необходимости обновите файлы приложения."

#: ../doc/book/admin/upgrades.rst:115
msgid "Upgrading Tarantool in a replication cluster"
msgstr "Обновление Tarantool'а в репликационном кластере"

#: ../doc/book/admin/upgrades.rst:117
#, fuzzy
msgid ""
"Tarantool 1.7 can work as a :ref:`replica <replication-architecture>` for"
" Tarantool 1.6 and vice versa. Replicas perform capability negotiation on"
" handshake, and new 1.7 replication features are not used with 1.6 "
"replicas. This allows upgrading clustered configurations."
msgstr ""
"Tarantool 1.7 (а также Tarantool 1.9 и 1.10) может служить :ref:`репликой"
" <replication-architecture>` для Tarantool'а 1.6 -- и наоборот. При "
"установке соединения происходит обсуждение возможностей, и новые для 1.7 "
"репликационные функции не используются при работе с репликами версии 1.6."
" Такой подход позволяет обновлять кластерные конфигурации."

#: ../doc/book/admin/upgrades.rst:122
msgid ""
"This procedure allows for a rolling upgrade **without downtime** and "
"works for any cluster configuration: master-master or master-replica."
msgstr ""
"Этот процесс позволяет осуществить последовательное обновление **без "
"простоев** и подходит для любой конфигурации кластера: master-master или "
"мастер-реплика."

#: ../doc/book/admin/upgrades.rst:125
msgid ""
"Upgrade Tarantool at all replicas (or at any master in a master-master "
"cluster). See details in :ref:`Upgrading a Tarantool instance <admin-"
"upgrades_instance>`."
msgstr ""
"Обновите Tarantool на всех репликах (или на любом мастере в кластере "
"мастер-мастер). Подробные инструкции доступны в подразделе "
":ref:`Обновление экземпляра Tarantool'а <admin-upgrades_instance>`."

#: ../doc/book/admin/upgrades.rst:129
msgid "Verify installation on the replicas:"
msgstr "Проверьте работу реплик:"

#: ../doc/book/admin/upgrades.rst:131
msgid "Start Tarantool."
msgstr "Запустите Tarantool."

#: ../doc/book/admin/upgrades.rst:133
msgid "Attach to the master and start working as before."
msgstr "Присоединитесь к мастеру и начните работать, как раньше."

#: ../doc/book/admin/upgrades.rst:135
msgid ""
"The master runs the old Tarantool version, which is always compatible "
"with the next major version."
msgstr ""
"На мастере установлена старая версия Tarantool'а, которая всегда "
"совместима со следующей мажорной версией."

#: ../doc/book/admin/upgrades.rst:138
msgid "Upgrade the master. The procedure is similar to upgrading a replica."
msgstr "Обновите мастер. Процесс такой же, как и при обновлении реплики."

#: ../doc/book/admin/upgrades.rst:140
msgid "Verify master installation:"
msgstr "Проверьте работу мастера:"

#: ../doc/book/admin/upgrades.rst:142
msgid "Start Tarantool with replica configuration to catch up."
msgstr ""
"Запустите Tarantool в режиме реплики для получения последней версии "
"данных."

#: ../doc/book/admin/upgrades.rst:144
msgid "Switch to master mode."
msgstr "Переключитесь в режим мастера."

#: ../doc/book/admin/upgrades.rst:146
msgid ""
"Upgrade the database on any master node in the cluster. Make the request "
"``box.schema.upgrade()``. This updates Tarantool system spaces to match "
"the currently installed version of Tarantool. Changes are propagated to "
"other nodes via the regular replication mechanism."
msgstr ""
"Обновите базу данных на любом мастере в кластере. Выполните команду "
"``box.schema.upgrade()``. Это обновит системные спейсы Tarantool'а так, "
"чтобы они совпадали с текущей установленной версией Tarantool'а. "
"Изменения распространятся на другие узлы кластера через обычный механизм "
"репликации."

#: ../doc/book/app_server/contributing_module.rst:5
msgid "Contributing a module"
msgstr "Добавление собственного модуля"

#: ../doc/book/app_server/contributing_module.rst:7
msgid ""
"We have already discussed :ref:`how to create a simple module in Lua for "
"local usage <app_server-modules>`. Now let's discuss how to create a more"
" advanced Tarantool module and then get it published on `Tarantool rocks "
"page <http://tarantool.org/rocks.html>`_ and included in `official "
"Tarantool images <http://github.com/tarantool/docker>`_ for Docker."
msgstr ""
"Мы уже обсуждали, :ref:`как создать простой модуль на языке Lua для "
"локального использования <app_server-modules>`.Теперь давайте обсудим, "
"как создать модуль более продвинутого уровня для Tarantool'а, а затем "
"разместить его на странице модулей Tarantool'а "
"<http://tarantool.org/rocks.html>`_ и включить его в `официальные образы "
"Tarantool'а <http://github.com/tarantool/docker>`_ для Docker."

#: ../doc/book/app_server/contributing_module.rst:14
msgid ""
"To help our contributors, we have created `modulekit "
"<http://github.com/tarantool/modulekit>`_, a set of templates for "
"creating Tarantool modules in Lua and C."
msgstr ""
"Чтобы помочь разработчикам, мы создали `modulekit "
"<http://github.com/tarantool/modulekit>`_, набор шаблонов для создания "
"Tarantool-модулей на Lua и C."

#: ../doc/book/app_server/contributing_module.rst:20
msgid ""
"As a prerequisite for using ``modulekit``, install ``tarantool-dev`` "
"package first. For example, in Ubuntu say:"
msgstr ""
"Чтобы использовать ``modulekit``, необходимо предварительно установить "
"пакет ``tarantool-dev``. Например, в Ubuntu выполните команду:"

#: ../doc/book/app_server/contributing_module.rst:23
msgid "$ sudo apt-get install tarantool-dev"
msgstr "$ sudo apt-get install tarantool-dev"

#: ../doc/book/app_server/contributing_module.rst:31
msgid "Contributing a module in Lua"
msgstr "Добавление собственного модуля на Lua"

#: ../doc/book/app_server/contributing_module.rst:33
msgid ""
"See `README in \"luakit\" branch of tarantool/modulekit repository "
"<http://github.com/tarantool/modulekit/blob/luakit/README.md>`_ for "
"detailed instructions and examples."
msgstr ""
"Подробную информацию и примеры см. в `README в ветке \"luakit\" "
"репозитория tarantool/modulekit "
"<http://github.com/tarantool/modulekit/blob/luakit/README.md>`_."

#: ../doc/book/app_server/contributing_module.rst:41
msgid "Contributing a module in C"
msgstr "Добавление собственного модуля на C"

#: ../doc/book/app_server/contributing_module.rst:43
msgid ""
"In some cases, you may want to create a Tarantool module in C rather than"
" in Lua. For example, to work with specific hardware or low-level system "
"interfaces."
msgstr ""
"В некоторых случаях может потребоваться создание Tarantool-модуля на C, а"
" не на Lua, например, для работы со специальным оборудованием или "
"низкоуровневыми системными интерфейсами."

#: ../doc/book/app_server/contributing_module.rst:46
msgid ""
"See `README in \"ckit\" branch of tarantool/modulekit repository "
"<http://github.com/tarantool/modulekit/blob/ckit/README.md>`_ for "
"detailed instructions and examples."
msgstr ""
"Подробную информацию и примеры см. в `README в ветке \"ckit\" репозитория"
" tarantool/modulekit "
"<http://github.com/tarantool/modulekit/blob/ckit/README.md>`_."

#: ../doc/book/app_server/contributing_module.rst:52
msgid ""
"You can also create modules with C++, provided that the code does not "
"throw exceptions."
msgstr ""
"Вы можете аналогичным образом создавать модули на C++ при условии, что в "
"их коде не будут выбрасываться исключения."

#: ../doc/book/app_server/cookbook.rst:5
msgid "Cookbook recipes"
msgstr "Примеры и рекомендации по разработке"

#: ../doc/book/app_server/cookbook.rst:7
msgid ""
"Here are contributions of Lua programs for some frequent or tricky "
"situations."
msgstr ""
"Ниже представлены дополнения в виде Lua-программ для часто встречающихся "
"или сложных случаев."

#: ../doc/book/app_server/cookbook.rst:9
msgid ""
"You can execute any of these programs by copying the code into a ``.lua``"
" file, and then entering :samp:`chmod +x ./{program-name}.lua` and :samp"
":`./{program-name}.lua` on the terminal."
msgstr ""
"Любую из этих программ можно выполнить, скопировав код в ``.lua-файл``, а"
" затем выполнив в командной строке :samp:`chmod +x ./{имя-программы}.lua`"
" и :samp :`./{имя-программы}.lua`."

#: ../doc/book/app_server/cookbook.rst:13
msgid "The first line is a \"hashbang\":"
msgstr "Первая строка -- это шебанг:"

#: ../doc/book/app_server/cookbook.rst:15
msgid "#!/usr/bin/env tarantool"
msgstr "#!/usr/bin/env tarantool"

#: ../doc/book/app_server/cookbook.rst:19
msgid ""
"This runs  Tarantool Lua application server, which should be on the "
"execution path."
msgstr ""
"Он запускает сервер приложений Tarantool'а на языке Lua, который должен "
"быть в пути выполнения."

#: ../doc/book/app_server/cookbook.rst:22
msgid "This section contains the following recipes:"
msgstr "В этом разделе собраны следующие рецепты:"

#: ../doc/book/app_server/cookbook.rst:27
msgid "Use freely."
msgstr "Можно использовать свободно."

#: ../doc/book/app_server/cookbook.rst:33
msgid "hello_world.lua"
msgstr "hello_world.lua"

#: ../doc/book/app_server/cookbook.rst:35
msgid "The standard example of a simple program."
msgstr "Стандартный пример простой программы."

#: ../doc/book/app_server/cookbook.rst:37
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"print('Hello, World!')"
msgstr ""
"#!/usr/bin/env tarantool\n"
" \n"
" print('Hello, World!')"

#: ../doc/book/app_server/cookbook.rst:47
msgid "console_start.lua"
msgstr "console_start.lua"

#: ../doc/book/app_server/cookbook.rst:49
msgid ""
"Use :ref:`box.once() <box-once>` to initialize a database (creating "
"spaces) if this is the first time the server has been run. Then use "
":ref:`console.start() <console-start>` to start interactive mode."
msgstr ""
"Для инициализации базы данных (создания спейсов) используйте "
":ref:`box.once() <box-once>`, если сервер запускается впервые. Затем "
"используйте :ref:`console.start() <console-start>`, чтобы запустить "
"интерактивный режим."

#: ../doc/book/app_server/cookbook.rst:53
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"-- Configure database\n"
"box.cfg {\n"
"    listen = 3313\n"
"}\n"
"\n"
"box.once(\"bootstrap\", function()\n"
"    box.schema.space.create('tweedledum')\n"
"    box.space.tweedledum:create_index('primary',\n"
"        { type = 'TREE', parts = {1, 'unsigned'}})\n"
"end)\n"
"\n"
"require('console').start()"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"-- Настроить базу данных\n"
"box.cfg {\n"
"    listen = 3313\n"
"}\n"
"\n"
"box.once(\"bootstrap\", function()\n"
"    box.schema.space.create('tweedledum')\n"
"    box.space.tweedledum:create_index('primary',\n"
"        { type = 'TREE', parts = {1, 'unsigned'}})\n"
"end)\n"
"\n"
"require('console').start()"

#: ../doc/book/app_server/cookbook.rst:74
msgid "fio_read.lua"
msgstr "fio_read.lua"

#: ../doc/book/app_server/cookbook.rst:76
msgid "Use the :ref:`fio module <fio-module>` to open, read, and close a file."
msgstr ""
"Используйте :ref:`Модуль fio <fio-module>`, чтобы открыть, прочитать и "
"закрыть файл."

#: ../doc/book/app_server/cookbook.rst:78
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local fio = require('fio')\n"
"local errno = require('errno')\n"
"local f = fio.open('/tmp/xxxx.txt', {'O_RDONLY' })\n"
"if not f then\n"
"    error(\"Failed to open file: \"..errno.strerror())\n"
"end\n"
"local data = f:read(4096)\n"
"f:close()\n"
"print(data)"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local fio = require('fio')\n"
"local errno = require('errno')\n"
"local f = fio.open('/tmp/xxxx.txt', {'O_RDONLY' })\n"
"if not f then\n"
"    error(\"Failed to open file: \"..errno.strerror())\n"
"end\n"
"local data = f:read(4096)\n"
"f:close()\n"
"print(data)"

#: ../doc/book/app_server/cookbook.rst:96
msgid "fio_write.lua"
msgstr "fio_write.lua"

#: ../doc/book/app_server/cookbook.rst:98
msgid "Use the :ref:`fio module <fio-module>` to open, write, and close a file."
msgstr ""
"Используйте :ref:`Модуль fio <fio-module>`, чтобы открыть, записать "
"данные и закрыть файл."

#: ../doc/book/app_server/cookbook.rst:100
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local fio = require('fio')\n"
"local errno = require('errno')\n"
"local f = fio.open('/tmp/xxxx.txt', {'O_CREAT', 'O_WRONLY', 'O_APPEND'},\n"
"    tonumber('0666', 8))\n"
"if not f then\n"
"    error(\"Failed to open file: \"..errno.strerror())\n"
"end\n"
"f:write(\"Hello\\n\");\n"
"f:close()"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local fio = require('fio')\n"
"local errno = require('errno')\n"
"local f = fio.open('/tmp/xxxx.txt', {'O_CREAT', 'O_WRONLY', 'O_APPEND'},\n"
"    tonumber('0666', 8))\n"
"if not f then\n"
"    error(\"Failed to open file: \"..errno.strerror())\n"
"end\n"
"f:write(\"Hello\\n\");\n"
"f:close()"

#: ../doc/book/app_server/cookbook.rst:118
msgid "ffi_printf.lua"
msgstr "ffi_printf.lua"

#: ../doc/book/app_server/cookbook.rst:120
msgid ""
"Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to call a "
"C built-in function: printf(). (For help understanding ffi, see the `FFI "
"tutorial <http://luajit.org/ext_ffi_tutorial.html>`_.)"
msgstr ""
"Используйте `Библиотеку LuaJIT FFI <http://luajit.org/ext_ffi.html>`_, "
"чтобы вызвать встроенную в C функцию: printf(). (Чтобы лучше понимать "
"FFI, см. `Учебное пособие по FFI "
"<http://luajit.org/ext_ffi_tutorial.html>`_.)"

#: ../doc/book/app_server/cookbook.rst:123
#, python-format
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require('ffi')\n"
"ffi.cdef[[\n"
"    int printf(const char *format, ...);\n"
"]]\n"
"\n"
"ffi.C.printf(\"Hello, %s\\n\", os.getenv(\"USER\"));"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require('ffi')\n"
"ffi.cdef[[\n"
"    int printf(const char *format, ...);\n"
"]]\n"
"\n"
"ffi.C.printf(\"Hello, %s\\n\", os.getenv(\"USER\"));"

#: ../doc/book/app_server/cookbook.rst:138
msgid "ffi_gettimeofday.lua"
msgstr "ffi_gettimeofday.lua"

#: ../doc/book/app_server/cookbook.rst:140
msgid ""
"Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to call a "
"C function: gettimeofday(). This delivers time with millisecond "
"precision, unlike the time function in Tarantool's :ref:`clock module "
"<clock-module>`."
msgstr ""
"Используйте `Библиотеку LuaJIT FFI <http://luajit.org/ext_ffi.html>`_, "
"чтобы вызвать встроенную в C функцию: gettimeofday(). Она позволяет "
"получить значение времени с точностью в миллисекундах, в отличие от "
"функции времени в Tarantool'е :ref:`Модуль clock <clock-module>`."

#: ../doc/book/app_server/cookbook.rst:144
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require('ffi')\n"
"ffi.cdef[[\n"
"    typedef long time_t;\n"
"    typedef struct timeval {\n"
"    time_t tv_sec;\n"
"    time_t tv_usec;\n"
"} timeval;\n"
"    int gettimeofday(struct timeval *t, void *tzp);\n"
"]]\n"
"\n"
"local timeval_buf = ffi.new(\"timeval\")\n"
"local now = function()\n"
"    ffi.C.gettimeofday(timeval_buf, nil)\n"
"    return tonumber(timeval_buf.tv_sec * 1000 + (timeval_buf.tv_usec / "
"1000))\n"
"end"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require('ffi')\n"
"ffi.cdef[[\n"
"    typedef long time_t;\n"
"    typedef struct timeval {\n"
"    time_t tv_sec;\n"
"    time_t tv_usec;\n"
"} timeval;\n"
"    int gettimeofday(struct timeval *t, void *tzp);\n"
"]]\n"
"\n"
"local timeval_buf = ffi.new(\"timeval\")\n"
"local now = function()\n"
"    ffi.C.gettimeofday(timeval_buf, nil)\n"
"    return tonumber(timeval_buf.tv_sec * 1000 + (timeval_buf.tv_usec / "
"1000))\n"
"end"

#: ../doc/book/app_server/cookbook.rst:168
msgid "ffi_zlib.lua"
msgstr "ffi_zlib.lua"

#: ../doc/book/app_server/cookbook.rst:170
msgid ""
"Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to call a "
"C library function. (For help understanding ffi, see the `FFI tutorial "
"<http://luajit.org/ext_ffi_tutorial.html>`_.)"
msgstr ""
"Используйте `Библиотеку LuaJIT FFI  <http://luajit.org/ext_ffi.html>`_, "
"чтобы вызвать библиотечную функцию в C. (Чтобы лучше понимать FFI, см. "
"`Учебное пособие по FFI <http://luajit.org/ext_ffi_tutorial.html>`_.)"

#: ../doc/book/app_server/cookbook.rst:173
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require(\"ffi\")\n"
"ffi.cdef[[\n"
"    unsigned long compressBound(unsigned long sourceLen);\n"
"    int compress2(uint8_t *dest, unsigned long *destLen,\n"
"    const uint8_t *source, unsigned long sourceLen, int level);\n"
"    int uncompress(uint8_t *dest, unsigned long *destLen,\n"
"    const uint8_t *source, unsigned long sourceLen);\n"
"]]\n"
"local zlib = ffi.load(ffi.os == \"Windows\" and \"zlib1\" or \"z\")\n"
"\n"
"-- Lua wrapper for compress2()\n"
"local function compress(txt)\n"
"    local n = zlib.compressBound(#txt)\n"
"    local buf = ffi.new(\"uint8_t[?]\", n)\n"
"    local buflen = ffi.new(\"unsigned long[1]\", n)\n"
"    local res = zlib.compress2(buf, buflen, txt, #txt, 9)\n"
"    assert(res == 0)\n"
"    return ffi.string(buf, buflen[0])\n"
"end\n"
"\n"
"-- Lua wrapper for uncompress\n"
"local function uncompress(comp, n)\n"
"    local buf = ffi.new(\"uint8_t[?]\", n)\n"
"    local buflen = ffi.new(\"unsigned long[1]\", n)\n"
"    local res = zlib.uncompress(buf, buflen, comp, #comp)\n"
"    assert(res == 0)\n"
"    return ffi.string(buf, buflen[0])\n"
"end\n"
"\n"
"-- Simple test code.\n"
"local txt = string.rep(\"abcd\", 1000)\n"
"print(\"Uncompressed size: \", #txt)\n"
"local c = compress(txt)\n"
"print(\"Compressed size: \", #c)\n"
"local txt2 = uncompress(c, #txt)\n"
"assert(txt2 == txt)"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require(\"ffi\")\n"
"ffi.cdef[[\n"
"    unsigned long compressBound(unsigned long sourceLen);\n"
"    int compress2(uint8_t *dest, unsigned long *destLen,\n"
"    const uint8_t *source, unsigned long sourceLen, int level);\n"
"    int uncompress(uint8_t *dest, unsigned long *destLen,\n"
"    const uint8_t *source, unsigned long sourceLen);\n"
"]]\n"
"local zlib = ffi.load(ffi.os == \"Windows\" and \"zlib1\" or \"z\")\n"
"\n"
"-- Надстройка Lua для функции compress2()\n"
"local function compress(txt)\n"
"    local n = zlib.compressBound(#txt)\n"
"    local buf = ffi.new(\"uint8_t[?]\", n)\n"
"    local buflen = ffi.new(\"unsigned long[1]\", n)\n"
"    local res = zlib.compress2(buf, buflen, txt, #txt, 9)\n"
"    assert(res == 0)\n"
"    return ffi.string(buf, buflen[0])\n"
"end\n"
"\n"
"-- Надстройка Lua для функции uncompress\n"
"local function uncompress(comp, n)\n"
"    local buf = ffi.new(\"uint8_t[?]\", n)\n"
"    local buflen = ffi.new(\"unsigned long[1]\", n)\n"
"    local res = zlib.uncompress(buf, buflen, comp, #comp)\n"
"    assert(res == 0)\n"
"    return ffi.string(buf, buflen[0])\n"
"end\n"
"\n"
"-- Простой код теста\n"
"local txt = string.rep(\"abcd\", 1000)\n"
"print(\"Uncompressed size: \", #txt)\n"
"local c = compress(txt)\n"
"print(\"Compressed size: \", #c)\n"
"local txt2 = uncompress(c, #txt)\n"
"assert(txt2 == txt)"

#: ../doc/book/app_server/cookbook.rst:218
msgid "ffi_meta.lua"
msgstr "ffi_meta.lua"

#: ../doc/book/app_server/cookbook.rst:220
msgid ""
"Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to access "
"a C object via a metamethod (a method which is defined with a metatable)."
msgstr ""
"Используйте `Библиотеку LuaJIT FFI <http://luajit.org/ext_ffi.html>`_, "
"чтобы получить доступ к объекту в C с помощью метаметода (метод, который "
"определен метатаблицей)."

#: ../doc/book/app_server/cookbook.rst:224
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require(\"ffi\")\n"
"ffi.cdef[[\n"
"typedef struct { double x, y; } point_t;\n"
"]]\n"
"\n"
"local point\n"
"local mt = {\n"
"  __add = function(a, b) return point(a.x+b.x, a.y+b.y) end,\n"
"  __len = function(a) return math.sqrt(a.x*a.x + a.y*a.y) end,\n"
"  __index = {\n"
"    area = function(a) return a.x*a.x + a.y*a.y end,\n"
"  },\n"
"}\n"
"point = ffi.metatype(\"point_t\", mt)\n"
"\n"
"local a = point(3, 4)\n"
"print(a.x, a.y)  --> 3  4\n"
"print(#a)        --> 5\n"
"print(a:area())  --> 25\n"
"local b = a + point(0.5, 8)\n"
"print(#b)        --> 12.5"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require(\"ffi\")\n"
"ffi.cdef[[\n"
"typedef struct { double x, y; } point_t;\n"
"]]\n"
"\n"
"local point\n"
"local mt = {\n"
"  __add = function(a, b) return point(a.x+b.x, a.y+b.y) end,\n"
"  __len = function(a) return math.sqrt(a.x*a.x + a.y*a.y) end,\n"
"  __index = {\n"
"    area = function(a) return a.x*a.x + a.y*a.y end,\n"
"  },\n"
"}\n"
"point = ffi.metatype(\"point_t\", mt)\n"
"\n"
"local a = point(3, 4)\n"
"print(a.x, a.y)  --> 3  4\n"
"print(#a)        --> 5\n"
"print(a:area())  --> 25\n"
"local b = a + point(0.5, 8)\n"
"print(#b)        --> 12.5"

#: ../doc/book/app_server/cookbook.rst:254
#, fuzzy
msgid "ffi_varbinary_insert.lua"
msgstr "ffi_printf.lua"

#: ../doc/book/app_server/cookbook.rst:256
msgid ""
"Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to insert "
"a tuple which has a VARBINARY field. Lua does not have direct support for"
" VARBINARY, so using C is one way to put in data which in MessagePack is "
"stored as bin (MP_BIN). If the tuple is retrieved later, field \"b\" will"
" have type = 'cdata'."
msgstr ""

#: ../doc/book/app_server/cookbook.rst:262
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"-- box.cfg{} should be here\n"
"\n"
"s = box.schema.space.create('withdata')\n"
"s:format({{\"b\", \"varbinary\"}})\n"
"s:create_index('pk', {parts = {1, \"varbinary\"}})\n"
"\n"
"buffer = require('buffer')\n"
"ffi = require('ffi')\n"
"\n"
"function varbinary_insert(space, bytes)\n"
"    local tmpbuf = buffer.IBUF_SHARED\n"
"    tmpbuf:reset()\n"
"    local p = tmpbuf:alloc(3 + #bytes)\n"
"    p[0] = 0x91 -- MsgPack code for \"array-1\"\n"
"    p[1] = 0xC4 -- MsgPack code for \"bin-8\" so up to 256 bytes\n"
"    p[2] = #bytes\n"
"    for i, c in pairs(bytes) do p[i + 3 - 1] = c end\n"
"    ffi.cdef[[int box_insert(uint32_t space_id,\n"
"                             const char *tuple,\n"
"                             const char *tuple_end,\n"
"                             box_tuple_t **result);]]\n"
"    ffi.C.box_insert(space.id, tmpbuf.rpos, tmpbuf.wpos, nil)\n"
"end\n"
"\n"
"varbinary_insert(s, {0xDE, 0xAD, 0xBE, 0xAF})\n"
"varbinary_insert(s, {0xFE, 0xED, 0xFA, 0xCE})\n"
"\n"
"-- if successful, Tarantool enters the event loop now"
msgstr ""

#: ../doc/book/app_server/cookbook.rst:300
msgid "print_arrays.lua"
msgstr "print_arrays.lua"

#: ../doc/book/app_server/cookbook.rst:302
msgid ""
"Create Lua tables, and print them. Notice that for the 'array' table the "
"iterator function is ipairs(), while for the 'map' table the iterator "
"function is pairs(). (`ipairs()` is faster than `pairs()`, but pairs() is"
" recommended for map-like tables or mixed tables.) The display will look "
"like: \"1 Apple | 2 Orange | 3 Grapefruit | 4 Banana | k3 v3 | k1 v1 | k2"
" v2\"."
msgstr ""
"Используйте, чтобы создать Lua-таблицы и вывести их. Следует отметить, "
"что для таблицы типа массива (array) функция-итератор будет ipairs(), а "
"для таблицы типа ассоциативного массива (map) функция-итератор -- "
"pairs(). (`ipairs()` быстрее, чем `pairs()`, но pairs() рекомендуется для"
" ассоциативных массивов или смешанных таблиц.) Результат будет выглядеть "
"следующим образом: \"1 Apple | 2 Orange | 3 Grapefruit | 4 Banana | k3 v3"
" | k1 v1 | k2  v2\"."

#: ../doc/book/app_server/cookbook.rst:310
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"array = { 'Apple', 'Orange', 'Grapefruit', 'Banana'}\n"
"for k, v in ipairs(array) do print(k, v) end\n"
"\n"
"map = { k1 = 'v1', k2 = 'v2', k3 = 'v3' }\n"
"for k, v in pairs(map) do print(k, v) end"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"array = { 'Apple', 'Orange', 'Grapefruit', 'Banana'}\n"
"for k, v in ipairs(array) do print(k, v) end\n"
"\n"
"map = { k1 = 'v1', k2 = 'v2', k3 = 'v3' }\n"
"for k, v in pairs(map) do print(k, v) end"

#: ../doc/book/app_server/cookbook.rst:324
msgid "count_array.lua"
msgstr "count_array.lua"

#: ../doc/book/app_server/cookbook.rst:326
msgid ""
"Use the '#' operator to get the number of items in an array-like Lua "
"table. This operation has O(log(N)) complexity."
msgstr ""
"Используйте оператор '#', чтобы получить количество элементов в "
"Lua-таблице типа массива. У этой операции сложность O(log(N))."

#: ../doc/book/app_server/cookbook.rst:329
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"array = { 1, 2, 3}\n"
"print(#array)"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"array = { 1, 2, 3}\n"
"print(#array)"

#: ../doc/book/app_server/cookbook.rst:340
msgid "count_array_with_nils.lua"
msgstr "count_array_with_nils.lua"

#: ../doc/book/app_server/cookbook.rst:342
msgid ""
"Missing elements in arrays, which Lua treats as \"nil\"s, cause the "
"simple \"#\" operator to deliver improper results. The \"print(#t)\" "
"instruction will print \"4\"; the \"print(counter)\" instruction will "
"print \"3\"; the \"print(max)\" instruction will print \"10\". Other "
"table functions, such as :ref:`table.sort() <table-sort>`, will also "
"misbehave when \"nils\" are present."
msgstr ""
"Отсутствующие элементы в массивах, которые Lua рассматривает как nil, "
"заставляют простой оператор '#' выдавать неправильные результаты. Команда"
" \"print(#t)\" выведет \"4\", команда \"print(counter)\" выведет \"3\", а"
" команда \"print(max)\" -- \"10\". Другие табличные функции, такие как "
":ref:`table.sort() <table-sort>`, также сработают неправильно при наличии"
" нулевых значений nil."

#: ../doc/book/app_server/cookbook.rst:350
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local t = {}\n"
"t[1] = 1\n"
"t[4] = 4\n"
"t[10] = 10\n"
"print(#t)\n"
"local counter = 0\n"
"for k,v in pairs(t) do counter = counter + 1 end\n"
"print(counter)\n"
"local max = 0\n"
"for k,v in pairs(t) do if k > max then max = k end end\n"
"print(max)"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local t = {}\n"
"t[1] = 1\n"
"t[4] = 4\n"
"t[10] = 10\n"
"print(#t)\n"
"local counter = 0\n"
"for k,v in pairs(t) do counter = counter + 1 end\n"
"print(counter)\n"
"local max = 0\n"
"for k,v in pairs(t) do if k > max then max = k end end\n"
"print(max)"

#: ../doc/book/app_server/cookbook.rst:370
msgid "count_array_with_nulls.lua"
msgstr "count_array_with_nulls.lua"

#: ../doc/book/app_server/cookbook.rst:372
msgid ""
"Use explicit ``NULL`` values to avoid the problems caused by Lua's nil =="
" missing value behavior. Although :code:`json.NULL == nil` is "
":code:`true`, all the print instructions in this program will print the "
"correct value: 10."
msgstr ""
"Используйте явные значения``NULL``, чтобы избежать проблем, вызванных  "
"nil в Lua == поведение с пропущенными значениями. Хотя :code:`json.NULL "
"== nil` является :code:`true`, все команды вывода в данной программе "
"выведут правильное значение: 10."

#: ../doc/book/app_server/cookbook.rst:377
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local json = require('json')\n"
"local t = {}\n"
"t[1] = 1; t[2] = json.NULL; t[3]= json.NULL;\n"
"t[4] = 4; t[5] = json.NULL; t[6]= json.NULL;\n"
"t[6] = 4; t[7] = json.NULL; t[8]= json.NULL;\n"
"t[9] = json.NULL\n"
"t[10] = 10\n"
"print(#t)\n"
"local counter = 0\n"
"for k,v in pairs(t) do counter = counter + 1 end\n"
"print(counter)\n"
"local max = 0\n"
"for k,v in pairs(t) do if k > max then max = k end end\n"
"print(max)"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local json = require('json')\n"
"local t = {}\n"
"t[1] = 1; t[2] = json.NULL; t[3]= json.NULL;\n"
"t[4] = 4; t[5] = json.NULL; t[6]= json.NULL;\n"
"t[6] = 4; t[7] = json.NULL; t[8]= json.NULL;\n"
"t[9] = json.NULL\n"
"t[10] = 10\n"
"print(#t)\n"
"local counter = 0\n"
"for k,v in pairs(t) do counter = counter + 1 end\n"
"print(counter)\n"
"local max = 0\n"
"for k,v in pairs(t) do if k > max then max = k end end\n"
"print(max)"

#: ../doc/book/app_server/cookbook.rst:400
msgid "count_map.lua"
msgstr "count_map.lua"

#: ../doc/book/app_server/cookbook.rst:402
msgid "Get the number of elements in a map-like table."
msgstr ""
"Программа используется для получения количества элементов в таблице типа "
"ассоциативного массива."

#: ../doc/book/app_server/cookbook.rst:404
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local map = { a = 10, b = 15, c = 20 }\n"
"local size = 0\n"
"for _ in pairs(map) do size = size + 1; end\n"
"print(size)"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local map = { a = 10, b = 15, c = 20 }\n"
"local size = 0\n"
"for _ in pairs(map) do size = size + 1; end\n"
"print(size)"

#: ../doc/book/app_server/cookbook.rst:417
msgid "swap.lua"
msgstr "swap.lua"

#: ../doc/book/app_server/cookbook.rst:419
msgid ""
"Use a Lua peculiarity to swap two variables without needing a third "
"variable."
msgstr ""
"Программа использует особенность Lua менять местами две переменные без "
"необходимости использования третьей переменной."

#: ../doc/book/app_server/cookbook.rst:421
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local x = 1\n"
"local y = 2\n"
"x, y = y, x\n"
"print(x, y)"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local x = 1\n"
"local y = 2\n"
"x, y = y, x\n"
"print(x, y)"

#: ../doc/book/app_server/cookbook.rst:434
msgid "class.lua"
msgstr "class.lua"

#: ../doc/book/app_server/cookbook.rst:436
msgid ""
"Create a class, create a metatable for the class, create an instance of "
"the class. Another illustration is at `http://lua-"
"users.org/wiki/LuaClassesWithMetatable <http://lua-"
"users.org/wiki/LuaClassesWithMetatable>`_."
msgstr ""
"Используется для создания класса, метатаблицы для класса, экземпляра "
"класса. Другой пример можно найти в `http://lua-"
"users.org/wiki/LuaClassesWithMetatable <http://lua-"
"users.org/wiki/LuaClassesWithMetatable>`_."

#: ../doc/book/app_server/cookbook.rst:440
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"-- define class objects\n"
"local myclass_somemethod = function(self)\n"
"    print('test 1', self.data)\n"
"end\n"
"\n"
"local myclass_someothermethod = function(self)\n"
"    print('test 2', self.data)\n"
"end\n"
"\n"
"local myclass_tostring = function(self)\n"
"    return 'MyClass <'..self.data..'>'\n"
"end\n"
"\n"
"local myclass_mt = {\n"
"    __tostring = myclass_tostring;\n"
"    __index = {\n"
"        somemethod = myclass_somemethod;\n"
"        someothermethod = myclass_someothermethod;\n"
"    }\n"
"}\n"
"\n"
"-- create a new object of myclass\n"
"local object = setmetatable({ data = 'data'}, myclass_mt)\n"
"print(object:somemethod())\n"
"print(object.data)"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"-- определить объекты класса\n"
"local myclass_somemethod = function(self)\n"
"    print('test 1', self.data)\n"
"end\n"
"\n"
"local myclass_someothermethod = function(self)\n"
"    print('test 2', self.data)\n"
"end\n"
"\n"
"local myclass_tostring = function(self)\n"
"    return 'MyClass <'..self.data..'>'\n"
"end\n"
"\n"
"local myclass_mt = {\n"
"    __tostring = myclass_tostring;\n"
"    __index = {\n"
"        somemethod = myclass_somemethod;\n"
"        someothermethod = myclass_someothermethod;\n"
"    }\n"
"}\n"
"\n"
"-- создать новый объект своего класса myclass\n"
"local object = setmetatable({ data = 'data'}, myclass_mt)\n"
"print(object:somemethod())\n"
"print(object.data)"

#: ../doc/book/app_server/cookbook.rst:474
msgid "garbage.lua"
msgstr "garbage.lua"

#: ../doc/book/app_server/cookbook.rst:476
msgid ""
"Activate the `Lua garbage collector "
"<https://www.lua.org/manual/5.1/manual.html#2.10>`_ with the "
"`collectgarbage function <https://www.lua.org/manual/5.1/manual.html#pdf-"
"collectgarbage>`_."
msgstr ""
"Запустите `сборщик мусора в Lua "
"<https://www.lua.org/manual/5.1/manual.html#2.10>`_ с помощью `функции "
"collectgarbage <https://www.lua.org/manual/5.1/manual.html#pdf- "
"collectgarbage>`_."

#: ../doc/book/app_server/cookbook.rst:479
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"collectgarbage('collect')"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"collectgarbage('collect')"

#: ../doc/book/app_server/cookbook.rst:489
msgid "fiber_producer_and_consumer.lua"
msgstr "fiber_producer_and_consumer.lua"

#: ../doc/book/app_server/cookbook.rst:491
msgid ""
"Start one fiber for producer and one fiber for consumer. Use "
":ref:`fiber.channel() <fiber_ipc-channel>` to exchange data and "
"synchronize. One can tweak the channel size (:code:`ch_size` in the "
"program code) to control the number of simultaneous tasks waiting for "
"processing."
msgstr ""
"Запустите один файбер для производителя и один файбер для потребителя. "
"Используйте :ref:`fiber.channel() <fiber_ipc-channel>` для обмена данных "
"и синхронизации. Можно настроить ширину канала (:code:`ch_size` в "
"программном коде) для управления количеством одновременных задач к "
"обработке."

#: ../doc/book/app_server/cookbook.rst:496
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local fiber = require('fiber')\n"
"local function consumer_loop(ch, i)\n"
"    -- initialize consumer synchronously or raise an error()\n"
"    fiber.sleep(0) -- allow fiber.create() to continue\n"
"    while true do\n"
"        local data = ch:get()\n"
"        if data == nil then\n"
"            break\n"
"        end\n"
"        print('consumed', i, data)\n"
"        fiber.sleep(math.random()) -- simulate some work\n"
"    end\n"
"end\n"
"\n"
"local function producer_loop(ch, i)\n"
"    -- initialize consumer synchronously or raise an error()\n"
"    fiber.sleep(0) -- allow fiber.create() to continue\n"
"    while true do\n"
"        local data = math.random()\n"
"        ch:put(data)\n"
"        print('produced', i, data)\n"
"    end\n"
"end\n"
"\n"
"local function start()\n"
"    local consumer_n = 5\n"
"    local producer_n = 3\n"
"\n"
"    -- Create a channel\n"
"    local ch_size = math.max(consumer_n, producer_n)\n"
"    local ch = fiber.channel(ch_size)\n"
"\n"
"    -- Start consumers\n"
"    for i=1, consumer_n,1 do\n"
"        fiber.create(consumer_loop, ch, i)\n"
"    end\n"
"\n"
"    -- Start producers\n"
"    for i=1, producer_n,1 do\n"
"        fiber.create(producer_loop, ch, i)\n"
"    end\n"
"end\n"
"\n"
"start()\n"
"print('started')"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local fiber = require('fiber')\n"
"local function consumer_loop(ch, i)\n"
"    -- инициализировать потребитель синхронно или выдать ошибку()\n"
"    fiber.sleep(0) -- позволить fiber.create() продолжать\n"
"    while true do\n"
"        local data = ch:get()\n"
"        if data == nil then\n"
"            break\n"
"        end\n"
"        print('consumed', i, data)\n"
"        fiber.sleep(math.random()) -- моделировать работу\n"
"    end\n"
"end\n"
"\n"
"local function producer_loop(ch, i)\n"
"    -- инициализировать потребитель синхронно или выдать ошибку()\n"
"    fiber.sleep(0) -- allow fiber.create() to continue\n"
"    while true do\n"
"        local data = math.random()\n"
"        ch:put(data)\n"
"        print('produced', i, data)\n"
"    end\n"
"end\n"
"\n"
"local function start()\n"
"    local consumer_n = 5\n"
"    local producer_n = 3\n"
"\n"
"    -- создать канал\n"
"    local ch_size = math.max(consumer_n, producer_n)\n"
"    local ch = fiber.channel(ch_size)\n"
"\n"
"    -- запустить потребители\n"
"    for i=1, consumer_n,1 do\n"
"        fiber.create(consumer_loop, ch, i)\n"
"    end\n"
"\n"
"    -- запустить производители\n"
"    for i=1, producer_n,1 do\n"
"        fiber.create(producer_loop, ch, i)\n"
"    end\n"
"end\n"
"\n"
"start()\n"
"print('started')"

#: ../doc/book/app_server/cookbook.rst:550
msgid "socket_tcpconnect.lua"
msgstr "socket_tcpconnect.lua"

#: ../doc/book/app_server/cookbook.rst:552
msgid ""
"Use :ref:`socket.tcp_connect() <socket-tcp_connect>` to connect to a "
"remote host via TCP. Display the connection details and the result of a "
"GET request."
msgstr ""
"Используйте :ref:`socket.tcp_connect() <socket-tcp_connect>` для "
"подключения к удаленному серверу по TCP. Можно отобразить информацию о "
"подключении и результат запроса GET."

#: ../doc/book/app_server/cookbook.rst:556
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local s = require('socket').tcp_connect('google.com', 80)\n"
"print(s:peer().host)\n"
"print(s:peer().family)\n"
"print(s:peer().type)\n"
"print(s:peer().protocol)\n"
"print(s:peer().port)\n"
"print(s:write(\"GET / HTTP/1.0\\r\\n\\r\\n\"))\n"
"print(s:read('\\r\\n'))\n"
"print(s:read('\\r\\n'))"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local s = require('socket').tcp_connect('google.com', 80)\n"
"print(s:peer().host)\n"
"print(s:peer().family)\n"
"print(s:peer().type)\n"
"print(s:peer().protocol)\n"
"print(s:peer().port)\n"
"print(s:write(\"GET / HTTP/1.0\\r\\n\\r\\n\"))\n"
"print(s:read('\\r\\n'))\n"
"print(s:read('\\r\\n'))"

#: ../doc/book/app_server/cookbook.rst:574
msgid "socket_tcp_echo.lua"
msgstr "socket_tcp_echo.lua"

#: ../doc/book/app_server/cookbook.rst:576
msgid ""
"Use :ref:`socket.tcp_connect() <socket-tcp_connect>` to set up a simple "
"TCP server, by creating a function that handles requests and echos them, "
"and passing the function to :ref:`socket.tcp_server() <socket-"
"tcp_server>`. This program has been used to test with 100,000 clients, "
"with each client getting a separate fiber."
msgstr ""
"Используйте :ref:`socket.tcp_connect() <socket-tcp_connect>` для "
"настройки простого TCP-сервера путем создания функции, которая "
"обрабатывает запросы и отражает их, а затем передачи функции на "
":ref:`socket.tcp_server() <socket-tcp_server>`. Данная программа была "
"протестирована на 100 000 клиентов, каждый из которых получил отдельный "
"файбер."

#: ../doc/book/app_server/cookbook.rst:584
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local function handler(s, peer)\n"
"    s:write(\"Welcome to test server, \" .. peer.host ..\"\\n\")\n"
"    while true do\n"
"        local line = s:read('\\n')\n"
"        if line == nil then\n"
"            break -- error or eof\n"
"        end\n"
"        if not s:write(\"pong: \"..line) then\n"
"            break -- error or eof\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"local server, addr = require('socket').tcp_server('localhost', 3311, "
"handler)"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local function handler(s, peer)\n"
"    s:write(\"Welcome to test server, \" .. peer.host ..\"\\n\")\n"
"    while true do\n"
"        local line = s:read('\\n')\n"
"        if line == nil then\n"
"            break -- ошибка или конец файла\n"
"        end\n"
"        if not s:write(\"pong: \"..line) then\n"
"            break -- ошибка или конец файла\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"local server, addr = require('socket').tcp_server('localhost', 3311, "
"handler)"

#: ../doc/book/app_server/cookbook.rst:607
msgid "getaddrinfo.lua"
msgstr "getaddrinfo.lua"

#: ../doc/book/app_server/cookbook.rst:609
msgid ""
"Use :ref:`socket.getaddrinfo() <socket-getaddrinfo>` to perform non-"
"blocking DNS resolution, getting both the AF_INET6 and AF_INET "
"information for 'google.com'. This technique is not always necessary for "
"tcp connections because :ref:`socket.tcp_connect() <socket-tcp_connect>` "
"performs `socket.getaddrinfo` under the hood, before trying to connect to"
" the first available address."
msgstr ""
"Используйте :ref:`socket.getaddrinfo() <socket-getaddrinfo>`, чтобы "
"провести неблокирующее разрешение имен DNS, получая как AF_INET6, так и "
"AF_INET информацию для 'google.com'. Данная техника не всегда необходима "
"для TCP-соединений, поскольку :ref:`socket.tcp_connect() <socket-"
"tcp_connect>` выполняет `socket.getaddrinfo` с точки зрения внутреннего "
"устройства до попытки соединения с первым доступным адресом."

#: ../doc/book/app_server/cookbook.rst:617
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local s = require('socket').getaddrinfo('google.com', 'http', { type = "
"'SOCK_STREAM' })\n"
"print('host=',s[1].host)\n"
"print('family=',s[1].family)\n"
"print('type=',s[1].type)\n"
"print('protocol=',s[1].protocol)\n"
"print('port=',s[1].port)\n"
"print('host=',s[2].host)\n"
"print('family=',s[2].family)\n"
"print('type=',s[2].type)\n"
"print('protocol=',s[2].protocol)\n"
"print('port=',s[2].port)"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local s = require('socket').getaddrinfo('google.com', 'http', { type = "
"'SOCK_STREAM' })\n"
"print('host=',s[1].host)\n"
"print('family=',s[1].family)\n"
"print('type=',s[1].type)\n"
"print('protocol=',s[1].protocol)\n"
"print('port=',s[1].port)\n"
"print('host=',s[2].host)\n"
"print('family=',s[2].family)\n"
"print('type=',s[2].type)\n"
"print('protocol=',s[2].protocol)\n"
"print('port=',s[2].port)"

#: ../doc/book/app_server/cookbook.rst:637
msgid "socket_udp_echo.lua"
msgstr "socket_udp_echo.lua"

#: ../doc/book/app_server/cookbook.rst:639
msgid ""
"Tarantool does not currently have a `udp_server` function, therefore "
"socket_udp_echo.lua is more complicated than socket_tcp_echo.lua. It can "
"be implemented with sockets and fibers."
msgstr ""
"В данный момент в Tarantool нет функции `udp_server`, поэтому "
"socket_udp_echo.lua -- более сложная программа, чем socket_tcp_echo.lua. "
"Ее можно реализовать с помощью сокетов и файберов."

#: ../doc/book/app_server/cookbook.rst:644
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local socket = require('socket')\n"
"local errno = require('errno')\n"
"local fiber = require('fiber')\n"
"\n"
"local function udp_server_loop(s, handler)\n"
"    fiber.name(\"udp_server\")\n"
"    while true do\n"
"        -- try to read a datagram first\n"
"        local msg, peer = s:recvfrom()\n"
"        if msg == \"\" then\n"
"            -- socket was closed via s:close()\n"
"            break\n"
"        elseif msg ~= nil then\n"
"            -- got a new datagram\n"
"            handler(s, peer, msg)\n"
"        else\n"
"            if s:errno() == errno.EAGAIN or s:errno() == errno.EINTR then"
"\n"
"                -- socket is not ready\n"
"                s:readable() -- yield, epoll will wake us when new data "
"arrives\n"
"            else\n"
"                -- socket error\n"
"                local msg = s:error()\n"
"                s:close() -- save resources and don't wait GC\n"
"                error(\"Socket error: \" .. msg)\n"
"            end\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"local function udp_server(host, port, handler)\n"
"    local s = socket('AF_INET', 'SOCK_DGRAM', 0)\n"
"    if not s then\n"
"        return nil -- check errno:strerror()\n"
"    end\n"
"    if not s:bind(host, port) then\n"
"        local e = s:errno() -- save errno\n"
"        s:close()\n"
"        errno(e) -- restore errno\n"
"        return nil -- check errno:strerror()\n"
"    end\n"
"\n"
"    fiber.create(udp_server_loop, s, handler) -- start a new background "
"fiber\n"
"    return s\n"
"end"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local socket = require('socket')\n"
"local errno = require('errno')\n"
"local fiber = require('fiber')\n"
"\n"
"local function udp_server_loop(s, handler)\n"
"    fiber.name(\"udp_server\")\n"
"    while true do\n"
"        -- попытка прочитать сначала датаграмму\n"
"        local msg, peer = s:recvfrom()\n"
"        if msg == \"\" then\n"
"            -- сокет был закрыт с помощью s:close()\n"
"            break\n"
"        elseif msg ~= nil then\n"
"            -- получена новая датаграмма\n"
"            handler(s, peer, msg)\n"
"        else\n"
"            if s:errno() == errno.EAGAIN or s:errno() == errno.EINTR then"
"\n"
"                -- сокет не готов\n"
"                s:readable() -- передача управления, epoll сообщит, когда"
" будут новые данные\n"
"            else\n"
"                -- ошибка сокета\n"
"                local msg = s:error()\n"
"                s:close() -- сохранить ресурсы и не ждать сборку мусора\n"
"                error(\"Socket error: \" .. msg)\n"
"            end\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"local function udp_server(host, port, handler)\n"
"    local s = socket('AF_INET', 'SOCK_DGRAM', 0)\n"
"    if not s then\n"
"        return nil -- проверить номер ошибки errno:strerror()\n"
"   end\n"
"    if not s:bind(host, port) then\n"
"        local e = s:errno() -- сохранить номер ошибки errno\n"
"        s:close()\n"
"        errno(e) -- восстановить номер ошибки errno\n"
"        return nil -- проверить номер ошибки errno:strerror()\n"
"    end\n"
"\n"
"    fiber.create(udp_server_loop, s, handler) -- запустить новый файбер в"
" фоновом режиме\n"
"    return s\n"
"end"

#: ../doc/book/app_server/cookbook.rst:693
msgid ""
"A function for a client that connects to this server could look something"
" like this ..."
msgstr ""
"Функция для клиента, который подключается к этому серверу, может "
"выглядеть следующим образом:"

#: ../doc/book/app_server/cookbook.rst:696
msgid ""
"local function handler(s, peer, msg)\n"
"    -- You don't have to wait until socket is ready to send UDP\n"
"    -- s:writable()\n"
"    s:sendto(peer.host, peer.port, \"Pong: \" .. msg)\n"
"end\n"
"\n"
"local server = udp_server('127.0.0.1', 3548, handler)\n"
"if not server then\n"
"    error('Failed to bind: ' .. errno.strerror())\n"
"end\n"
"\n"
"print('Started')\n"
"\n"
"require('console').start()"
msgstr ""
"local function handler(s, peer, msg)\n"
"    -- Необязательно ждать, пока сокет будет готов отправлять UDP\n"
"    -- s:writable()\n"
"    s:sendto(peer.host, peer.port, \"Pong: \" .. msg)\n"
"end\n"
"\n"
"local server = udp_server('127.0.0.1', 3548, handler)\n"
"if not server then\n"
"    error('Failed to bind: ' .. errno.strerror())\n"
"end\n"
"\n"
"print('Started')\n"
"\n"
"require('console').start()"

#: ../doc/book/app_server/cookbook.rst:717
msgid "http_get.lua"
msgstr "http_get.lua"

#: ../doc/book/app_server/cookbook.rst:719
msgid "Use the :ref:`http module <http-module>` to get data via HTTP."
msgstr "Используйте :ref:`Модуль HTTP <http-module>` для получения данных по HTTP."

#: ../doc/book/app_server/cookbook.rst:722
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local http_client = require('http.client')\n"
"local json = require('json')\n"
"local r = "
"http_client.get('http://api.openweathermap.org/data/2.5/weather?q=Oakland,us')"
"\n"
"if r.status ~= 200 then\n"
"    print('Failed to get weather forecast ', r.reason)\n"
"    return\n"
"end\n"
"local data = json.decode(r.body)\n"
"print('Oakland wind speed: ', data.wind.speed)"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local http_client = require('http.client')\n"
"local json = require('json')\n"
"local r = "
"http_client.get('http://api.openweathermap.org/data/2.5/weather?q=Oakland,us')"
"\n"
"if r.status ~= 200 then\n"
"    print('Failed to get weather forecast ', r.reason)\n"
"    return\n"
"end\n"
"local data = json.decode(r.body)\n"
"print('Oakland wind speed: ', data.wind.speed)"

#: ../doc/book/app_server/cookbook.rst:740
msgid "http_send.lua"
msgstr "http_send.lua"

#: ../doc/book/app_server/cookbook.rst:742
msgid "Use the :ref:`http module <http-module>` to send data via HTTP."
msgstr "Используйте :ref:`Модуль HTTP <http-module>` для отправки данных по HTTP."

#: ../doc/book/app_server/cookbook.rst:745
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local http_client = require('http.client')\n"
"local json = require('json')\n"
"local data = json.encode({ Key = 'Value'})\n"
"local headers = { Token = 'xxxx', ['X-Secret-Value'] = 42 }\n"
"local r = http_client.post('http://localhost:8081', data, { headers = "
"headers})\n"
"if r.status == 200 then\n"
"    print 'Success'\n"
"end"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local http_client = require('http.client')\n"
"local json = require('json')\n"
"local data = json.encode({ Key = 'Value'})\n"
"local headers = { Token = 'xxxx', ['X-Secret-Value'] = 42 }\n"
"local r = http_client.post('http://localhost:8081', data, { headers = "
"headers})\n"
"if r.status == 200 then\n"
"    print 'Success'\n"
"end"

#: ../doc/book/app_server/cookbook.rst:762
msgid "http_server.lua"
msgstr "http_server.lua"

#: ../doc/book/app_server/cookbook.rst:764
msgid ""
"Use the `http`_ `rock`_ (which must first be installed) to turn Tarantool"
" into a web server."
msgstr ""
"Используйте `сторонний модуль`_ `http`_  (который необходимо "
"предварительно установить), чтобы превратить Tarantool в веб-сервер."

#: ../doc/book/app_server/cookbook.rst:767
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local function handler(self)\n"
"    return self:render{ json = { ['Your-IP-Is'] = self.peer.host } }\n"
"end\n"
"\n"
"local server = require('http.server').new(nil, 8080) -- listen *:8080\n"
"server:route({ path = '/' }, handler)\n"
"server:start()\n"
"-- connect to localhost:8080 and see json"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local function handler(self)\n"
"    return self:render{ json = { ['Your-IP-Is'] = self.peer.host } }\n"
"end\n"
"\n"
"local server = require('http.server').new(nil, 8080) -- анализировать "
"связь с *:8080\n"
"server:route({ path = '/' }, handler)\n"
"server:start()\n"
"-- подключиться к localhost:8080 и читать JSON"

#: ../doc/book/app_server/cookbook.rst:784
msgid "http_generate_html.lua"
msgstr "http_generate_html.lua"

#: ../doc/book/app_server/cookbook.rst:786
msgid ""
"Use the `http`_ `rock` (which must first be installed) to generate HTML "
"pages from templates. The `http`_ `rock`_ has a fairly simple template "
"engine which allows execution of regular Lua code inside text blocks "
"(like PHP). Therefore there is no need to learn new languages in order to"
" write templates."
msgstr ""
"Используйте сторонний модуль `http`_ (который необходимо предварительно "
"установить) для создания HTML-страниц из шаблонов. В `модуле "
"<https://tarantool.io/ru/download/rocks>`_ `http`_ достаточно простой "
"движок шаблонов, который позволяет выполнять регулярный код на Lua в "
"текстовых блоках (как в PHP). Таким образом, нет необходимости в изучении"
" новых языков, чтобы написать шаблоны."

#: ../doc/book/app_server/cookbook.rst:792
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local function handler(self)\n"
"local fruits = { 'Apple', 'Orange', 'Grapefruit', 'Banana'}\n"
"    return self:render{ fruits = fruits }\n"
"end\n"
"\n"
"local server = require('http.server').new(nil, 8080) -- nil means '*'\n"
"server:route({ path = '/', file = 'index.html.lua' }, handler)\n"
"server:start()"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local function handler(self)\n"
"local fruits = { 'Apple', 'Orange', 'Grapefruit', 'Banana'}\n"
"    return self:render{ fruits = fruits }\n"
"end\n"
"\n"
"local server = require('http.server').new(nil, 8080) -- nil означает '*'\n"
"server:route({ path = '/', file = 'index.html.lua' }, handler)\n"
"server:start()"

#: ../doc/book/app_server/cookbook.rst:805
msgid ""
"An \"HTML\" file for this server, including Lua, could look like this (it"
" would produce \"1 Apple | 2 Orange | 3 Grapefruit | 4 Banana\")."
msgstr ""
"HTML-файл для этого сервера, включая Lua, может выглядеть следующим "
"образом (он выведет \"1 Apple | 2 Orange | 3 Grapefruit | 4 Banana\")."

#: ../doc/book/app_server/cookbook.rst:808
#, python-format
msgid ""
"<html>\n"
"<body>\n"
"    <table border=\"1\">\n"
"        % for i,v in pairs(fruits) do\n"
"        <tr>\n"
"            <td><%= i %></td>\n"
"            <td><%= v %></td>\n"
"        </tr>\n"
"        % end\n"
"    </table>\n"
"</body>\n"
"</html>"
msgstr ""
"<html>\n"
"<body>\n"
"    <table border=\"1\">\n"
"        % for i,v in pairs(fruits) do\n"
"        <tr>\n"
"            <td><%= i %></td>\n"
"            <td><%= v %></td>\n"
"        </tr>\n"
"        % end\n"
"    </table>\n"
"</body>\n"
"</html>"

#: ../doc/book/app_server/creating_app.rst:5
msgid "Creating an application"
msgstr "Создание приложения"

#: ../doc/book/app_server/creating_app.rst:7
msgid ""
"Further we walk you through key programming practices that will give you "
"a good start in writing Lua applications for Tarantool. For an adventure,"
" this is a story of implementing... a real microservice based on "
"Tarantool! We implement a backend for a simplified version of `Pokémon Go"
" <https://en.wikipedia.org/wiki/Pokémon_Go>`_, a location-based augmented"
" reality game released in mid-2016. In this game, players use a mobile "
"device's GPS capability to locate, capture, battle and train virtual "
"monsters called \"pokémon\", who appear on the screen as if they were in "
"the same real-world location as the player."
msgstr ""
"Далее мы пошагово разберем ключевые методики программирования, что "
"послужит хорошим началом для написания Lua-приложений для Tarantool'а. "
"Для интереса возьмем историю реализации... настоящего микросервиса на "
"основе Tarantool'а! Мы реализуем бэкенд для упрощенной версии `Pokémon Go"
"  <https://ru.wikipedia.org/wiki/Pok%C3%A9mon_Go>`_, игры на основе "
"определения местоположения дополненной реальности, выпущенной в середине "
"2016 года. В этой игре игроки используют GPS-возможности мобильных "
"устройств, чтобы находить, захватывать, сражаться и тренировать "
"виртуальных существ, или покемонов, которые появляются на экране, как "
"если бы они находились в том же реальном месте, как и игрок."

#: ../doc/book/app_server/creating_app.rst:17
msgid ""
"To stay within the walk-through format, let's narrow the original "
"gameplay as follows. We have a map with pokémon spawn locations. Next, we"
" have multiple players who can send catch-a-pokémon requests to the "
"server (which runs our Tarantool microservice). The server replies "
"whether the pokémon is caught or not, increases the player's pokémon "
"counter if yes, and triggers the respawn-a-pokémon method that spawns a "
"new pokémon at the same location in a while."
msgstr ""
"Чтобы не выходить за рамки пошагового примера, ограничим оригинальный "
"сюжет игры. У нас есть карта с местами появления покемонов. Далее у нас "
"есть несколько игроков, которые могут отправлять запросы на поимку "
"покемона на сервер (где работает микросервис Tarantool'а). Сервер "
"отвечает, пойман ли покемон, увеличивает счетчик покемонов, если пойман, "
"и вызывает метод респауна покемона, который через некоторое время создает"
" нового покемона на том же самом месте."

#: ../doc/book/app_server/creating_app.rst:25
msgid ""
"We leave client-side applications outside the scope of this story. Yet we"
" promise a mini-demo in the end to simulate real users and give us some "
"fun. :-)"
msgstr ""
"Мы вынесем клиентские приложения за рамки рассказа. Но в конце обещаем "
"небольшую демонстрацию с моделированием настоящих пользователей, чтобы "
"немного поразвлечься. :-)"

#: ../doc/book/app_server/creating_app.rst:31
msgid "First, what would be the best way to deliver our microservice?"
msgstr "Для начала как лучше всего предоставить микросервис?"

#: ../doc/book/app_server/creating_app.rst:37
msgid "Modules, rocks and applications"
msgstr "Модули и приложения"

#: ../doc/book/app_server/creating_app.rst:39
msgid ""
"To make our game logic available to other developers and Lua "
"applications, let's put it into a Lua module."
msgstr ""
"Чтобы наша логическая схема игры была доступна другим разработчикам и "
"Lua-приложениям, поместим ее в Lua-модуль."

#: ../doc/book/app_server/creating_app.rst:42
msgid ""
"A **module** (called \"rock\" in Lua) is an optional library which "
"enhances Tarantool functionality. So, we can install our logic as a "
"module in Tarantool and use it from any Tarantool application or module. "
"Like applications, modules in Tarantool can be written in Lua (rocks), C "
"or C++."
msgstr ""
"**Модуль** (который называется \"rock\" в Lua) -- это дополнительная "
"библиотека, которая расширяет функции Tarantool'а. Поэтому можно "
"установить нашу логическую схему в виде модуля в Tarantool и использовать"
" ее из любого Tarantool-приложения или модуля. Как и приложения, модули в"
" Tarantool'е могут быть написаны на Lua (rocks), C или C++."

#: ../doc/book/app_server/creating_app.rst:47
msgid "Modules are good for two things:"
msgstr "Модули хороши для двух целей:"

#: ../doc/book/app_server/creating_app.rst:49
msgid "easier **code management** (reuse, packaging, versioning), and"
msgstr ""
"облегченное **управление кодом** (переиспользование, подготовка к "
"развертыванию, версионирование) и"

#: ../doc/book/app_server/creating_app.rst:50
msgid "hot **code reload** without restarting the Tarantool instance."
msgstr "горячая **перезагрузка кода** без перезапуска экземпляра Tarantool'а."

#: ../doc/book/app_server/creating_app.rst:52
msgid ""
"Technically, a module is a file with source code that exports its "
"functions in an API. For example, here is a Lua module named "
"``mymodule.lua`` that exports one function named ``myfun``:"
msgstr ""
"В техническом смысле, модуль - это файл с исходным кодом, который "
"экспортирует свои функции в API. Например, вот Lua-модуль под названием "
"``mymodule.lua``, который экспортирует одну функцию под названием "
"``myfun``:"

#: ../doc/book/app_server/creating_app.rst:56
msgid ""
"local exports = {}\n"
"exports.myfun = function(input_string)\n"
"   print('Hello', input_string)\n"
"end\n"
"return exports"
msgstr ""
"local exports = {}\n"
"exports.myfun = function(input_string)\n"
"   print('Hello', input_string)\n"
"end\n"
"return exports"

#: ../doc/book/app_server/creating_app.rst:64
msgid ""
"To launch the function ``myfun()`` -- from another module, from a Lua "
"application, or from Tarantool itself, -- we need to save this module as "
"a file, then load this module with the ``require()`` directive and call "
"the exported function."
msgstr ""
"Чтобы запустить функцию ``myfun()`` -- из другого модуля, из "
"Lua-приложения или из самого Tarantool'а -- необходимо сохранить этот "
"модуль в виде файла, а затем загрузить этот модуль с директивой "
"``require()`` и вызвать экспортированную функцию."

#: ../doc/book/app_server/creating_app.rst:68
msgid ""
"For example, here's a Lua application that uses ``myfun()`` function from"
" ``mymodule.lua`` module:"
msgstr ""
"Например, вот Lua-приложение, которое использует функцию ``myfun()`` из "
"модуля ``mymodule.lua``:"

#: ../doc/book/app_server/creating_app.rst:71
msgid ""
"-- loading the module\n"
"local mymodule = require('mymodule')\n"
"\n"
"-- calling myfun() from within test() function\n"
"local test = function()\n"
"  mymodule.myfun()\n"
"end"
msgstr ""
"-- загрузка модуля\n"
"local mymodule = require('mymodule')\n"
"\n"
"-- вызов myfun() из функции test\n"
"local test = function()\n"
"  mymodule.myfun()\n"
"end"

#: ../doc/book/app_server/creating_app.rst:81
msgid ""
"A thing to remember here is that the ``require()`` directive takes load "
"paths to Lua modules from the ``package.path`` variable. This is a "
"semicolon-separated string, where a question mark is used to interpolate "
"the module name. By default, this variable contains system-wide Lua paths"
" and the working directory. But if we put our modules inside a specific "
"folder (e.g. ``scripts/``), we need to add this folder to "
"``package.path`` before any calls to ``require()``:"
msgstr ""
"Здесь важно запомнить, что директива ``require()`` берет пути загрузки к "
"Lua-модулям из переменной ``package.path``. Она представляет собой строку"
" с разделителями в виде точки с запятой, где знак вопроса используется "
"для вставки имени модуля. По умолчанию, эта переменная содержит пути в "
"системе и рабочую директорию. Но если мы поместим наши модули в особую "
"папку (например, ``scripts/``), необходимо будет добавить эту папку в "
"``package.path`` до вызова ``require()``:"

#: ../doc/book/app_server/creating_app.rst:88
msgid "package.path = 'scripts/?.lua;' .. package.path"
msgstr "package.path = 'scripts/?.lua;' .. package.path"

#: ../doc/book/app_server/creating_app.rst:92
msgid ""
"For our microservice, a simple and convenient solution would be to put "
"all methods in a Lua module (say ``pokemon.lua``) and to write a Lua "
"application (say ``game.lua``) that initializes the gaming environment "
"and starts the game loop."
msgstr ""
"Для нашего микросервиса простым и удобным решением будет разместить все "
"методы в Lua-модуле (скажем, ``pokemon.lua``) и написать Lua-приложение "
"(скажем, ``game.lua``), которое запустит игровое окружение и цикл игры."

#: ../doc/book/app_server/creating_app.rst:100
msgid ""
"Now let's get down to implementation details. In our game, we need three "
"entities:"
msgstr "Теперь приступим к деталям реализации. В игре нам необходимы три сущности:"

#: ../doc/book/app_server/creating_app.rst:102
msgid ""
"**map**, which is an array of pokémons with coordinates of respawn "
"locations; in this version of the game, let a location be a rectangle "
"identified with two points, upper-left and lower-right;"
msgstr ""
"**карта**, которая представляет собой массив покемонов с координатами "
"мест респауна; в данной версии игры пусть местом будет прямоугольник, "
"установленный по двум точкам, верхней левой и нижней правой;"

#: ../doc/book/app_server/creating_app.rst:105
msgid ""
"**player**, which has an ID, a name, and coordinates of the player's "
"location point;"
msgstr "**игрок**, у которого есть ID, имя и координаты местонахождения игрока;"

#: ../doc/book/app_server/creating_app.rst:107
msgid ""
"**pokémon**, which has the same fields as the player, plus a status "
"(active/inactive, that is present on the map or not) and a catch "
"probability (well, let's give our pokémons a chance to escape :-) )"
msgstr ""
"**покемон**, у которого такие же поля, как и у игрока, плюс статус "
"(активный/неактивный, то есть находится ли на карте) и возможность поимки"
" (давайте уж дадим нашим покемонам шанс сбежать :-) )"

#: ../doc/book/app_server/creating_app.rst:111
msgid ""
"We'll store these entities as tuples in Tarantool spaces. But to deliver "
"our backend application as a microservice, the good practice would be to "
"send/receive our data in the universal JSON format, thus using Tarantool "
"as a document storage."
msgstr ""
"Эти данные будем хранить как кортежи в спейсах Tarantool'а. Но чтобы "
"бэкенд-приложение работало как микросервис, правильно будет "
"отправлять/получать данные в универсальном формате JSON, используя "
"Tarantool в качестве системы хранения документов."

#: ../doc/book/app_server/creating_app.rst:119
msgid "Avro schemas"
msgstr "Avro-схемы"

#: ../doc/book/app_server/creating_app.rst:121
msgid ""
"To store JSON data as tuples, we will apply a savvy practice which "
"reduces data footprint and ensures all stored documents are valid. We "
"will use Tarantool module `avro-schema <https://github.com/tarantool"
"/avro-schema>`_ which checks the schema of a JSON document and converts "
"it to a Tarantool tuple. The tuple will contain only field values, and "
"thus take a lot less space than the original document. In avro-schema "
"terms, converting JSON documents to tuples is \"flattening\", and "
"restoring the original documents is \"unflattening\". The usage is quite "
"straightforward:"
msgstr ""
"Чтобы хранить JSON-данные в виде кортежей, используем продвинутую "
"методику, которая уменьшит отпечаток данных и обеспечит пригодность всех "
"сохраняемых документов. Будем использовать Tarantool-модуль `avro-schema "
"<https://github.com/tarantool/avro-schema>`_, который проверяет схему "
"JSON-документа и конвертирует его в кортеж Tarantool'а. Кортеж будет "
"содержать только значения полей, таким образом, занимая меньше места, чем"
" оригинальный документ. С точки зрения avro-схемы, конвертация "
"JSON-документов в кортежи -- \"flattening\" (конвертация в плоские "
"файлы), а восстановление оригинальных документов -- \"unflattening\" "
"(конвертация из плоских файлов). Использовать модуль достаточно просто:"

#: ../doc/book/app_server/creating_app.rst:130
msgid ""
"For each entity, we need to define a schema in `Apache Avro schema "
"<https://en.wikipedia.org/wiki/Apache_Avro>`_ syntax, where we list the "
"entity's fields with their names and `Avro data types "
"<http://avro.apache.org/docs/current/spec.html#schema_primitive>`_."
msgstr ""
"Для каждой сущности необходимо определить схему в синтаксисе `схемы "
"Apache Avro <https://en.wikipedia.org/wiki/Apache_Avro>`_, где мы "
"перечисляем поля сущности с их наименованиями и `типами данных по Avro "
"<http://avro.apache.org/docs/current/spec.html#schema_primitive>`_."

#: ../doc/book/app_server/creating_app.rst:134
msgid ""
"At initialization, we call ``avro-schema.create()`` that creates objects "
"in memory for all schema entities, and ``compile()`` that generates "
"flatten/unflatten methods for each entity."
msgstr ""
"При инициализации мы вызываем функцию ``avro-schema.create()``, которая "
"создает объекты в памяти для всех сущностей схемы, а также функцию "
"``compile()``, которая создает методы flatten/unflatten (конвертация в "
"плоские файлы и обратно) для каждой сущности."

#: ../doc/book/app_server/creating_app.rst:137
msgid ""
"Further on, we just call flatten/unflatten methods for a respective "
"entity on receiving/sending the entity's data."
msgstr ""
"Далее мы просто вызываем методы flatten/unflatten для соответствующей "
"сущности при получении/отправке данных об этой сущности."

#: ../doc/book/app_server/creating_app.rst:140
msgid ""
"Here's what our schema definitions for the player and pokémon entities "
"look like:"
msgstr "Вот как будут выглядеть определения схемы для сущностей игрока и покемона:"

#: ../doc/book/app_server/creating_app.rst:142
msgid ""
"local schema = {\n"
"    player = {\n"
"        type=\"record\",\n"
"        name=\"player_schema\",\n"
"        fields={\n"
"            {name=\"id\", type=\"long\"},\n"
"            {name=\"name\", type=\"string\"},\n"
"            {\n"
"                name=\"location\",\n"
"                type= {\n"
"                    type=\"record\",\n"
"                    name=\"player_location\",\n"
"                    fields={\n"
"                        {name=\"x\", type=\"double\"},\n"
"                        {name=\"y\", type=\"double\"}\n"
"                    }\n"
"                }\n"
"            }\n"
"        }\n"
"    },\n"
"    pokemon = {\n"
"        type=\"record\",\n"
"        name=\"pokemon_schema\",\n"
"        fields={\n"
"            {name=\"id\", type=\"long\"},\n"
"            {name=\"status\", type=\"string\"},\n"
"            {name=\"name\", type=\"string\"},\n"
"            {name=\"chance\", type=\"double\"},\n"
"            {\n"
"                name=\"location\",\n"
"                type= {\n"
"                    type=\"record\",\n"
"                    name=\"pokemon_location\",\n"
"                    fields={\n"
"                        {name=\"x\", type=\"double\"},\n"
"                        {name=\"y\", type=\"double\"}\n"
"                    }\n"
"                }\n"
"            }\n"
"        }\n"
"    }\n"
"}"
msgstr ""
"local schema = {\n"
"    player = {\n"
"        type=\"record\",\n"
"        name=\"player_schema\",\n"
"        fields={\n"
"            {name=\"id\", type=\"long\"},\n"
"            {name=\"name\", type=\"string\"},\n"
"            {\n"
"                name=\"location\",\n"
"                type= {\n"
"                    type=\"record\",\n"
"                    name=\"player_location\",\n"
"                    fields={\n"
"                        {name=\"x\", type=\"double\"},\n"
"                        {name=\"y\", type=\"double\"}\n"
"                    }\n"
"                }\n"
"            }\n"
"        }\n"
"    },\n"
"    pokemon = {\n"
"        type=\"record\",\n"
"        name=\"pokemon_schema\",\n"
"        fields={\n"
"            {name=\"id\", type=\"long\"},\n"
"            {name=\"status\", type=\"string\"},\n"
"            {name=\"name\", type=\"string\"},\n"
"            {name=\"chance\", type=\"double\"},\n"
"            {\n"
"                name=\"location\",\n"
"                type= {\n"
"                    type=\"record\",\n"
"                    name=\"pokemon_location\",\n"
"                    fields={\n"
"                        {name=\"x\", type=\"double\"},\n"
"                        {name=\"y\", type=\"double\"}\n"
"                    }\n"
"                }\n"
"            }\n"
"        }\n"
"    }\n"
"}"

#: ../doc/book/app_server/creating_app.rst:187
msgid "And here's how we create and compile our entities at initialization:"
msgstr "А вот как мы создадим и скомпилируем наши сущности при инициализации:"

#: ../doc/book/app_server/creating_app.rst:189
msgid ""
"-- load avro-schema module with require()\n"
"local avro = require('avro_schema')\n"
"\n"
"-- create models\n"
"local ok_m, pokemon = avro.create(schema.pokemon)\n"
"local ok_p, player = avro.create(schema.player)\n"
"if ok_m and ok_p then\n"
"    -- compile models\n"
"    local ok_cm, compiled_pokemon = avro.compile(pokemon)\n"
"    local ok_cp, compiled_player = avro.compile(player)\n"
"    if ok_cm and ok_cp then\n"
"        -- start the game\n"
"        <...>\n"
"    else\n"
"        log.error('Schema compilation failed')\n"
"    end\n"
"else\n"
"    log.info('Schema creation failed')\n"
"end\n"
"return false"
msgstr ""
"-- загрузить модуль avro-schema с директивой require()\n"
"local avro = require('avro_schema')\n"
"\n"
"-- создать модели\n"
"local ok_m, pokemon = avro.create(schema.pokemon)\n"
"local ok_p, player = avro.create(schema.player)\n"
"if ok_m and ok_p then\n"
"    -- скомпилировать модели\n"
"    local ok_cm, compiled_pokemon = avro.compile(pokemon)\n"
"    local ok_cp, compiled_player = avro.compile(player)\n"
"    if ok_cm and ok_cp then\n"
"        -- начать игру\n"
"        <...>\n"
"    else\n"
"        log.error('Schema compilation failed')\n"
"    end\n"
"else\n"
"    log.info('Schema creation failed')\n"
"end\n"
"return false"

#: ../doc/book/app_server/creating_app.rst:212
msgid ""
"As for the map entity, it would be an overkill to introduce a schema for "
"it, because we have only one map in the game, it has very few fields, and"
" -- which is most important -- we use the map only inside our logic, "
"never exposing it to external users."
msgstr ""
"Что касается сущности карты, вводить для нее схему будет перебор, потому "
"что в игре всего одна карта, у нее мало полей, и -- что самое главное -- "
"мы используем карту только внутри нашей логики, не показывая ее внешним "
"пользователям."

#: ../doc/book/app_server/creating_app.rst:220
msgid ""
"Next, we need methods to implement the game logic. To simulate object-"
"oriented programming in our Lua code, let's store all Lua functions and "
"shared variables in a single local variable (let's name it as ``game``). "
"This will allow us to address functions or variables from within our "
"module as ``self.func_name`` or ``self.var_name``. Like this:"
msgstr ""
"Далее нам нужны методы для реализации игровой логики. Чтобы смоделировать"
" объектно-ориентированное программирование в нашем Lua-коде, будем "
"хранить все Lua-функции и общие переменные в одной внутренней переменной "
"(назовем ее ``game``). Это позволит нам обращаться к функциям или "
"переменным из нашего модуля с помощью ``self.func_name`` или "
"``self.var_name`` следующим образом:"

#: ../doc/book/app_server/creating_app.rst:226
msgid ""
"local game = {\n"
"    -- a local variable\n"
"    num_players = 0,\n"
"\n"
"    -- a method that prints a local variable\n"
"    hello = function(self)\n"
"      print('Hello! Your player number is ' .. self.num_players .. '.')\n"
"    end,\n"
"\n"
"    -- a method that calls another method and returns a local variable\n"
"    sign_in = function(self)\n"
"      self.num_players = self.num_players + 1\n"
"      self:hello()\n"
"      return self.num_players\n"
"    end\n"
"}"
msgstr ""
"local game = {\n"
"    -- локальная переменная\n"
"    num_players = 0,\n"
"\n"
"    -- метод, который выводит локальную переменную\n"
"    hello = function(self)\n"
"      print('Hello! Your player number is ' .. self.num_players .. '.')\n"
"    end,\n"
"\n"
"    -- метод, который вызывает другой метод и возвращает локальную "
"переменную\n"
"    sign_in = function(self)\n"
"      self.num_players = self.num_players + 1\n"
"      self:hello()\n"
"      return self.num_players\n"
"    end\n"
"}"

#: ../doc/book/app_server/creating_app.rst:245
msgid ""
"In OOP terms, we can now regard local variables inside ``game`` as object"
" fields, and local functions as object methods."
msgstr ""
"В терминах ООП сейчас мы можем рассматривать внутренние переменные внутри"
" переменной ``game`` как поля объекта, а внутренние функции -- как методы"
" объекта."

#: ../doc/book/app_server/creating_app.rst:250
msgid ""
"In this manual, Lua examples use **local** variables. Use **global** "
"variables with caution, since the module’s users may be unaware of them."
msgstr ""
"Обратите внимание, что в текущей документации в примерах Lua-кода "
"используются *локальные* переменные. Используйте *глобальные* переменные "
"аккуратно, поскольку пользователи ваших модулей могут не знать об этих "
"переменных."

#: ../doc/book/app_server/creating_app.rst:253
msgid ""
"To enable/disable the use of undeclared global variables in your Lua "
"code, use Tarantool's :ref:`strict <strict-module>` module."
msgstr ""
"Чтобы включить/отключить использование необъявленных глобальных "
"переменных в вашем коде на языке Lua, используйте модуль Tarantool'а "
":ref:`strict <strict-module>`."

#: ../doc/book/app_server/creating_app.rst:256
msgid "So, our game module will have the following methods:"
msgstr "Таким образом, в модуле игры будут следующие методы:"

#: ../doc/book/app_server/creating_app.rst:258
msgid ""
"``catch()`` to calculate whether the pokémon was caught (besides the "
"coordinates of both the player and pokémon, this method will apply a "
"probability factor, so not every pokémon within the player's reach will "
"be caught);"
msgstr ""
"``catch()`` (поймать) для расчета, когда был пойман покемон (помимо "
"координат как игрока, так и покемона, этот метод будет использовать "
"коэффициент вероятности, чтобы в пределах досягаемости игрока можно было "
"поймать не каждого покемона);"

#: ../doc/book/app_server/creating_app.rst:262
msgid ""
"``respawn()`` to add missing pokémons to the map, say, every 60 seconds "
"(we assume that a frightened pokémon runs away, so we remove a pokémon "
"from the map on any catch attempt and add it back to the map in a while);"
msgstr ""
"``respawn()`` (респаун) для добавления отсутствующих покемонов на карту, "
"скажем, каждые 60 секунд (предположим, что испуганный покемон убегает, "
"поэтому мы убираем покемона с карты при любой попытке поймать его и через"
" некоторое время добавляем обратно на карту);"

#: ../doc/book/app_server/creating_app.rst:265
msgid ""
"``notify()`` to log information about caught pokémons (like \"Player 1 "
"caught pokémon A\");"
msgstr ""
"``notify()`` (уведомить) для записи информации о пойманных покемонах "
"(например, \"Игрок 1 поймал покемона A\");"

#: ../doc/book/app_server/creating_app.rst:267
msgid ""
"``start()`` to initialize the game (it will create database spaces, "
"create and compile avro schemas, and launch ``respawn()``)."
msgstr ""
"``start()`` (начать) для инициализации игры (метод создаст спейсы в базе "
"данных, создаст и скомпилирует avro-схемы, а также запустит метод "
"``respawn()``)."

#: ../doc/book/app_server/creating_app.rst:270
msgid ""
"Besides, it would be convenient to have methods for working with "
"Tarantool storage. For example:"
msgstr ""
"Кроме того, было бы удобно завести методы для работы с хранилищем "
"Tarantool'а. Например:"

#: ../doc/book/app_server/creating_app.rst:273
msgid "``add_pokemon()`` to add a pokémon to the database, and"
msgstr ""
"``add_pokemon()`` (добавить покемона) для добавления покемона в базу "
"данных и"

#: ../doc/book/app_server/creating_app.rst:274
msgid "``map()`` to populate the map with all pokémons stored in Tarantool."
msgstr ""
"``map()`` (карта) для заполнения карты всеми покемонами, которые хранятся"
" в Tarantool'е."

#: ../doc/book/app_server/creating_app.rst:276
msgid ""
"We'll need these two methods primarily when initializing our game, but we"
" can also call them later, for example to test our code."
msgstr ""
"Эти два метода будут главным образом использоваться во время "
"инициализации нашей игры, но их также можно вызывать позднее, например "
"для тестирования кода."

#: ../doc/book/app_server/creating_app.rst:283
msgid "Bootstrapping a database"
msgstr "Настройка базы данных"

#: ../doc/book/app_server/creating_app.rst:285
msgid ""
"Let's discuss game initialization. In ``start()`` method, we need to "
"populate Tarantool spaces with pokémon data. Why not keep all game data "
"in memory? Why use a database? The answer is: :ref:`persistence <index-"
"box_persistence>`. Without a database, we risk losing data on power "
"outage, for example. But if we store our data in an in-memory database, "
"Tarantool takes care to persist it on disk whenever it's changed. This "
"gives us one more benefit: quick startup in case of failure. Tarantool "
"has a :ref:`smart algorithm <internals-recovery_process>` that quickly "
"loads all data from disk into memory on startup, so the warm-up takes "
"little time."
msgstr ""
"Обсудим инициализацию игры. В методе ``start()`` нам нужно заполнить "
"спейсы Tarantool'а данными о покемонах. Почему бы не хранить все игровые "
"данные в памяти? Зачем нужна база данных? Ответ на это: "
":ref:`персистентность <index-box_persistence>`. Без базы данных мы "
"рискуем потерять данные при отключении электроэнергии, например. Но если "
"мы храним данные в in-memory базе данных, Tarantool позаботится о том, "
"чтобы обеспечить постоянное хранение данных при их изменении. Это дает "
"дополнительное преимущество: быстрая загрузка в случае отказа. "
":ref:`Умный алгоритм <internals-recovery_process>` Tarantool'а быстро "
"загружает все данные с диска в память при начале работы, так что "
"подготовка к работе не займет много времени."

#: ../doc/book/app_server/creating_app.rst:295
msgid ""
"We'll be using functions from Tarantool built-in :ref:`box <box-module>` "
"module:"
msgstr ""
"Мы будем использовать функции из встроенного модуля Tarantool'а :ref:`box"
" <box-module>`:"

#: ../doc/book/app_server/creating_app.rst:297
msgid ""
"``box.schema.create_space('pokemons')`` to create a space named "
"``pokemon`` for storing information about pokémons (we don't create a "
"similar space for players, because we intend to only send/receive player "
"information via API calls, so we needn't store it);"
msgstr ""
"``box.schema.create_space('pokemons')`` для создания спейса под названием"
" ``pokemon`` (покемон), чтобы хранить информацию о покемонах (мы не "
"создаем аналогичный спейс по игрокам, потому что планируем только "
"отправлять и получать информацию об игроках с помощью вызовов API, так "
"что нет необходимости хранить ее);"

#: ../doc/book/app_server/creating_app.rst:301
msgid ""
"``box.space.pokemons:create_index('primary', {type = 'hash', parts = {1, "
"'unsigned'}})`` to create a primary HASH index by pokémon ID;"
msgstr ""
"``box.space.pokemons:create_index('primary', {type = 'hash', parts = {1, "
"'unsigned'}})`` для создания первичного HASH-индекса по ID покемона;"

#: ../doc/book/app_server/creating_app.rst:303
msgid ""
"``box.space.pokemons:create_index('status', {type = 'tree', parts = {2, "
"'str'}})`` to create a secondary TREE index by pokémon status."
msgstr ""
"``box.space.pokemons:create_index('status', {type = 'tree', parts = {2, "
"'str'}})`` для создания вторичного TREE-индекса по статусу покемона."

#: ../doc/book/app_server/creating_app.rst:306
msgid ""
"Notice the ``parts =`` argument in the index specification. The pokémon "
"ID is the first field in a Tarantool tuple since it’s the first member of"
" the respective Avro type. So does the pokémon status. The actual JSON "
"document may have ID or status fields at any position of the JSON map."
msgstr ""
"Обратите внимание на аргумент ``parts =`` в спецификации индекса. ID "
"покемона -- это первое поле в кортеже Tarantool'а, потому что это первый "
"элемент соответствующего типа Avro. То же относится к статусу покемона. В"
" самом JSON-файле поля ID или статуса могут быть в любом положении на "
"JSON-карте."

#: ../doc/book/app_server/creating_app.rst:311
msgid "The implementation of ``start()`` method looks like this:"
msgstr "Реализация метода ``start()`` выглядит следующим образом:"

#: ../doc/book/app_server/creating_app.rst:313
msgid ""
"-- create game object\n"
"start = function(self)\n"
"    -- create spaces and indexes\n"
"    box.once('init', function()\n"
"        box.schema.create_space('pokemons')\n"
"        box.space.pokemons:create_index(\n"
"            \"primary\", {type = 'hash', parts = {1, 'unsigned'}}\n"
"        )\n"
"        box.space.pokemons:create_index(\n"
"            \"status\", {type = \"tree\", parts = {2, 'str'}}\n"
"        )\n"
"    end)\n"
"\n"
"    -- create models\n"
"    local ok_m, pokemon = avro.create(schema.pokemon)\n"
"    local ok_p, player = avro.create(schema.player)\n"
"    if ok_m and ok_p then\n"
"        -- compile models\n"
"        local ok_cm, compiled_pokemon = avro.compile(pokemon)\n"
"        local ok_cp, compiled_player = avro.compile(player)\n"
"        if ok_cm and ok_cp then\n"
"            -- start the game\n"
"            <...>\n"
"        else\n"
"            log.error('Schema compilation failed')\n"
"        end\n"
"    else\n"
"        log.info('Schema creation failed')\n"
"    end\n"
"    return false\n"
"end"
msgstr ""
"-- создать игровой объект\n"
"start = function(self)\n"
"    -- создать спейсы и индексы\n"
"    box.once('init', function()\n"
"        box.schema.create_space('pokemons')\n"
"        box.space.pokemons:create_index(\n"
"            \"primary\", {type = 'hash', parts = {1, 'unsigned'}}\n"
"        )\n"
"        box.space.pokemons:create_index(\n"
"            \"status\", {type = \"tree\", parts = {2, 'str'}}\n"
"        )\n"
"    end)\n"
"\n"
"    -- создать модели\n"
"    local ok_m, pokemon = avro.create(schema.pokemon)\n"
"    local ok_p, player = avro.create(schema.player)\n"
"    if ok_m and ok_p then\n"
"        -- скомпилировать модели\n"
"        local ok_cm, compiled_pokemon = avro.compile(pokemon)\n"
"        local ok_cp, compiled_player = avro.compile(player)\n"
"        if ok_cm and ok_cp then\n"
"            -- начать игру\n"
"            <...>\n"
"        else\n"
"            log.error('Schema compilation failed')\n"
"        end\n"
"    else\n"
"        log.info('Schema creation failed')\n"
"    end\n"
"    return false\n"
"end"

#: ../doc/book/app_server/creating_app.rst:351
msgid "GIS"
msgstr "ГИС"

#: ../doc/book/app_server/creating_app.rst:353
msgid ""
"Now let's discuss ``catch()``, which is the main method in our gaming "
"logic."
msgstr ""
"Теперь обсудим метод ``catch()``, который является основным в логике "
"нашей игры."

#: ../doc/book/app_server/creating_app.rst:355
msgid ""
"Here we receive the player's coordinates and the target pokémon's ID "
"number, and we need to answer whether the player has actually caught the "
"pokémon or not (remember that each pokémon has a chance to escape)."
msgstr ""
"Здесь мы получаем координаты игрока и номер ID искомого покемона, а нужен"
" нам ответ на вопрос, поймали ли игрок покемона (помните, что у каждого "
"покемона есть шанс убежать)."

#: ../doc/book/app_server/creating_app.rst:359
msgid ""
"First thing, we validate the received player data against its :ref:`Avro "
"schema <app_server-avro_schemas>`. And we check whether such a pokémon "
"exists in our database and is displayed on the map (the pokémon must have"
" the active status):"
msgstr ""
"Для начала проверим полученные данные об игроке по :ref:`Avro-схеме "
"<app_server-avro_schemas>`. Также проверим, есть ли такой покемон в базе "
"данных, и отображается ли он на карте (у покемона должен быть активный "
"статус):"

#: ../doc/book/app_server/creating_app.rst:364
msgid ""
"catch = function(self, pokemon_id, player)\n"
"    -- check player data\n"
"    local ok, tuple = self.player_model.flatten(player)\n"
"    if not ok then\n"
"        return false\n"
"    end\n"
"    -- get pokemon data\n"
"    local p_tuple = box.space.pokemons:get(pokemon_id)\n"
"    if p_tuple == nil then\n"
"        return false\n"
"    end\n"
"    local ok, pokemon = self.pokemon_model.unflatten(p_tuple)\n"
"    if not ok then\n"
"        return false\n"
"    end\n"
"    if pokemon.status ~= self.state.ACTIVE then\n"
"        return false\n"
"    end\n"
"    -- more catch logic to follow\n"
"    <...>\n"
"end"
msgstr ""
"catch = function(self, pokemon_id, player)\n"
"    -- проверить данные игрока\n"
"    local ok, tuple = self.player_model.flatten(player)\n"
"    if not ok then\n"
"        return false\n"
"    end\n"
"    -- получить данные покемона\n"
"    local p_tuple = box.space.pokemons:get(pokemon_id)\n"
"    if p_tuple == nil then\n"
"        return false\n"
"    end\n"
"    local ok, pokemon = self.pokemon_model.unflatten(p_tuple)\n"
"    if not ok then\n"
"        return false\n"
"    end\n"
"    if pokemon.status ~= self.state.ACTIVE then\n"
"        return false\n"
"    end\n"
"    -- логика поимки будет дополняться\n"
"    <...>\n"
"end"

#: ../doc/book/app_server/creating_app.rst:388
msgid "Next, we calculate the answer: caught or not."
msgstr "Далее вычисляем ответ: пойман или нет."

#: ../doc/book/app_server/creating_app.rst:390
msgid ""
"To work with geographical coordinates, we use Tarantool `gis "
"<https://github.com/tarantool/gis>`_ module."
msgstr ""
"Чтобы работать с географическими координатами, используем модуль "
"Tarantool'а `gis <https://github.com/tarantool/gis>`_."

#: ../doc/book/app_server/creating_app.rst:393
msgid ""
"To keep things simple, we don't load any specific map, assuming that we "
"deal with a world map. And we do not validate incoming coordinates, "
"assuming again that all received locations are within the planet Earth."
msgstr ""
"Чтобы не усложнять, не будем загружать какую-то особую карту, допуская, "
"что рассматриваем карту мира. Также не будет проверять поступающие "
"координаты, снова допуская, что все места находятся на планете Земля."

#: ../doc/book/app_server/creating_app.rst:397
msgid "We use two geo-specific variables:"
msgstr "Используем две географические переменные:"

#: ../doc/book/app_server/creating_app.rst:399
msgid ""
"``wgs84``, which stands for the latest revision of the World Geodetic "
"System standard, `WGS84 "
"<https://en.wikipedia.org/wiki/World_Geodetic_System#WGS84>`_. Basically,"
" it comprises a standard coordinate system for the Earth and represents "
"the Earth as an ellipsoid."
msgstr ""
"``wgs84``, что означает последнюю редакцию стандарта Мировой "
"геодезической системы координат, `WGS84 "
"<https://en.wikipedia.org/wiki/World_Geodetic_System#WGS84>`_. В целом, "
"она представляет собой стандартную систему координат Земли и изображает "
"Землю как эллипсоид."

#: ../doc/book/app_server/creating_app.rst:403
msgid ""
"``nationalmap``, which stands for the `US National Atlas Equal Area "
"<https://epsg.io/2163>`_. This is a projected coordinates system based on"
" WGS84. It gives us a zero base for location projection and allows "
"positioning our players and pokémons in meters."
msgstr ""
"``nationalmap``, что означает `Государственный атлас США в равновеликой "
"проекции (US National Atlas Equal Area) <https://epsg.io/2163>`_. Это "
"система спроецированных координат на основании WGS84. Она дает основу для"
" проецирования мест и позволяет определить местоположение наших игроков и"
" покемонов в метрах."

#: ../doc/book/app_server/creating_app.rst:408
msgid ""
"Both these systems are listed in the EPSG Geodetic Parameter Registry, "
"where each system has a unique number. In our code, we assign these "
"listing numbers to respective variables:"
msgstr ""
"Обе системы указаны в Реестре геодезических параметров EPSG, где каждой "
"системе присвоен уникальный номер. Мы назначим эти числа соответствующим "
"переменным в нашем коде:"

#: ../doc/book/app_server/creating_app.rst:412
msgid ""
"wgs84 = 4326,\n"
"nationalmap = 2163,"
msgstr ""
"wgs84 = 4326,\n"
"nationalmap = 2163,"

#: ../doc/book/app_server/creating_app.rst:417
msgid ""
"For our game logic, we need one more variable, ``catch_distance``, which "
"defines how close a player must get to a pokémon before trying to catch "
"it. Let's set the distance to 100 meters."
msgstr ""
"Для игровой логики необходима еще одна переменная ``catch_distance``, "
"которая определяет, насколько близко игрок должен подойти к покемону, "
"чтобы попытаться поймать его. Определим это расстояние в 100 метров."

#: ../doc/book/app_server/creating_app.rst:421
msgid "catch_distance = 100,"
msgstr "catch_distance = 100,"

#: ../doc/book/app_server/creating_app.rst:425
msgid ""
"Now we're ready to calculate the answer. We need to project the current "
"location of both player (``p_pos``) and pokémon (``m_pos``) on the map, "
"check whether the player is close enough to the pokémon (using "
"``catch_distance``), and calculate whether the player has caught the "
"pokémon (here we generate some random value and let the pokémon escape if"
" the random value happens to be less than 100 minus pokémon's chance "
"value):"
msgstr ""
"Теперь можно рассчитать ответ. Необходимо спроецировать текущее "
"местоположение как игрока (``p_pos``), так и покемона (``m_pos``) на "
"карте, проверить, достаточно ли близко к покемону находится игрок (с "
"помощью ``catch_distance``), и рассчитать, поймал ли игрок покемона "
"(здесь мы генерируем случайное значение, и покемон убегает, если "
"случайное значение оказывается меньше, чем 100 минус случайная величина "
"покемона):"

#: ../doc/book/app_server/creating_app.rst:432
msgid ""
"-- project locations\n"
"local m_pos = gis.Point(\n"
"    {pokemon.location.x, pokemon.location.y}, self.wgs84\n"
"):transform(self.nationalmap)\n"
"local p_pos = gis.Point(\n"
"    {player.location.x, player.location.y}, self.wgs84\n"
"):transform(self.nationalmap)\n"
"\n"
"-- check catch distance condition\n"
"if p_pos:distance(m_pos) > self.catch_distance then\n"
"    return false\n"
"end\n"
"-- try to catch pokemon\n"
"local caught = math.random(100) >= 100 - pokemon.chance\n"
"if caught then\n"
"    -- update and notify on success\n"
"    box.space.pokemons:update(\n"
"        pokemon_id, {{'=', self.STATUS, self.state.CAUGHT}}\n"
"    )\n"
"    self:notify(player, pokemon)\n"
"end\n"
"return caught"
msgstr ""
"-- спроецировать местоположение\n"
" local m_pos = gis.Point(\n"
"     {pokemon.location.x, pokemon.location.y}, self.wgs84\n"
" ):transform(self.nationalmap)\n"
" local p_pos = gis.Point(\n"
"     {player.location.x, player.location.y}, self.wgs84\n"
" ):transform(self.nationalmap)\n"
" \n"
" -- проверить условие близости игрока\n"
" if p_pos:distance(m_pos) > self.catch_distance then\n"
"     return false\n"
" end\n"
" -- попытаться поймать покемона\n"
" local caught = math.random(100) >= 100 - pokemon.chance\n"
" if caught then\n"
"     -- обновить и сообщить об успехе\n"
"     box.space.pokemons:update(\n"
"         pokemon_id, {{'=', self.STATUS, self.state.CAUGHT}}\n"
"     )\n"
"     self:notify(player, pokemon)\n"
" end\n"
" return caught"

#: ../doc/book/app_server/creating_app.rst:461
msgid "Index iterators"
msgstr "Итератор с индексом"

#: ../doc/book/app_server/creating_app.rst:463
msgid ""
"By our gameplay, all caught pokémons are returned back to the map. We do "
"this for all pokémons on the map every 60 seconds using ``respawn()`` "
"method. We iterate through pokémons by status using Tarantool index "
"iterator function :ref:`index:pairs <box_index-index_pairs>` and reset "
"the statuses of all \"caught\" pokémons back to \"active\" using "
"``box.space.pokemons:update()``."
msgstr ""
"По сюжету игры все пойманные покемоны возвращаются на карту. Метод "
"``respawn()`` обеспечивает это для всех покемонов на карте каждые 60 "
"секунд. Мы выполняем перебор покемонов по статусу с помощью функции "
"Tarantool'а итератора с индексом :ref:`index:pairs <box_index-"
"index_pairs>` и сбрасываем статусы всех \"пойманных\" покемонов обратно "
"на \"активный\" с помощью ``box.space.pokemons:update()``."

#: ../doc/book/app_server/creating_app.rst:469
msgid ""
"respawn = function(self)\n"
"    fiber.name('Respawn fiber')\n"
"    for _, tuple in box.space.pokemons.index.status:pairs(\n"
"           self.state.CAUGHT) do\n"
"        box.space.pokemons:update(\n"
"            tuple[self.ID],\n"
"            {{'=', self.STATUS, self.state.ACTIVE}}\n"
"        )\n"
"    end\n"
" end"
msgstr ""
"respawn = function(self)\n"
"    fiber.name('Respawn fiber')\n"
"    for _, tuple in box.space.pokemons.index.status:pairs(\n"
"           self.state.CAUGHT) do\n"
"        box.space.pokemons:update(\n"
"            tuple[self.ID],\n"
"            {{'=', self.STATUS, self.state.ACTIVE}}\n"
"        )\n"
"    end\n"
" end"

#: ../doc/book/app_server/creating_app.rst:482
msgid "For readability, we introduce named fields:"
msgstr "Для удобства введем именованные поля:"

#: ../doc/book/app_server/creating_app.rst:484
msgid "ID = 1, STATUS = 2,"
msgstr "ID = 1, STATUS = 2,"

#: ../doc/book/app_server/creating_app.rst:487
msgid "The complete implementation of ``start()`` now looks like this:"
msgstr "Реализация метода ``start()`` полностью теперь выглядит так:"

#: ../doc/book/app_server/creating_app.rst:489
msgid ""
"-- create game object\n"
"start = function(self)\n"
"    -- create spaces and indexes\n"
"    box.once('init', function()\n"
"       box.schema.create_space('pokemons')\n"
"       box.space.pokemons:create_index(\n"
"           \"primary\", {type = 'hash', parts = {1, 'unsigned'}}\n"
"       )\n"
"       box.space.pokemons:create_index(\n"
"           \"status\", {type = \"tree\", parts = {2, 'str'}}\n"
"       )\n"
"    end)\n"
"\n"
"    -- create models\n"
"    local ok_m, pokemon = avro.create(schema.pokemon)\n"
"    local ok_p, player = avro.create(schema.player)\n"
"    if ok_m and ok_p then\n"
"        -- compile models\n"
"        local ok_cm, compiled_pokemon = avro.compile(pokemon)\n"
"        local ok_cp, compiled_player = avro.compile(player)\n"
"        if ok_cm and ok_cp then\n"
"            -- start the game\n"
"            self.pokemon_model = compiled_pokemon\n"
"            self.player_model = compiled_player\n"
"            self.respawn()\n"
"            log.info('Started')\n"
"            return true\n"
"         else\n"
"            log.error('Schema compilation failed')\n"
"         end\n"
"    else\n"
"        log.info('Schema creation failed')\n"
"    end\n"
"    return false\n"
"end"
msgstr ""
"-- создать игровой объект\n"
"start = function(self)\n"
"    -- создать спейсы и индексы\n"
"    box.once('init', function()\n"
"       box.schema.create_space('pokemons')\n"
"       box.space.pokemons:create_index(\n"
"           \"primary\", {type = 'hash', parts = {1, 'unsigned'}}\n"
"       )\n"
"       box.space.pokemons:create_index(\n"
"           \"status\", {type = \"tree\", parts = {2, 'str'}}\n"
"       )\n"
"    end)\n"
"\n"
"    -- создать модели\n"
"    local ok_m, pokemon = avro.create(schema.pokemon)\n"
"    local ok_p, player = avro.create(schema.player)\n"
"    if ok_m and ok_p then\n"
"        -- скомпилировать модели\n"
"        local ok_cm, compiled_pokemon = avro.compile(pokemon)\n"
"        local ok_cp, compiled_player = avro.compile(player)\n"
"        if ok_cm and ok_cp then\n"
"            -- начать игру\n"
"            self.pokemon_model = compiled_pokemon\n"
"            self.player_model = compiled_player\n"
"            self.respawn()\n"
"            log.info('Started')\n"
"            return true\n"
"         else\n"
"            log.error('Schema compilation failed')\n"
"         end\n"
"    else\n"
"        log.info('Schema creation failed')\n"
"    end\n"
"    return false\n"
"end"

#: ../doc/book/app_server/creating_app.rst:529
msgid "Fibers"
msgstr "Файберы"

#: ../doc/book/app_server/creating_app.rst:531
msgid ""
"But wait! If we launch it as shown above -- ``self.respawn()`` -- the "
"function will be executed only once, just like all the other methods. But"
" we need to execute ``respawn()`` every 60 seconds. Creating a "
":ref:`fiber <fiber-module>` is the Tarantool way of making application "
"logic work in the background at all times."
msgstr ""
"Но подождите! Если мы запустим функцию ``self.respawn()``, как показано "
"выше, то она запустится только один раз, как и остальные методы. А нам "
"необходимо запускать ``respawn()`` каждые 60 секунд. Tarantool заставляет"
" логику приложения непрерывно работать в фоновом режиме с помощью "
":ref:`файбера <fiber-module>`."

#: ../doc/book/app_server/creating_app.rst:537
msgid ""
"A **fiber** exists for executing instruction sequences but it is not a "
"thread. The key difference is that threads use preemptive multitasking, "
"while fibers use cooperative multitasking. This gives fibers the "
"following two advantages over threads:"
msgstr ""
"**Файбер** предназначен для выполнения последовательностей команд, но это"
" не поток. Ключевое отличие в том, что потоки используют многозадачность "
"с реализацией приоритетов, тогда как файберы используют кооперативную "
"многозадачность. Это дает файберам два преимущества над потоками:"

#: ../doc/book/app_server/creating_app.rst:542
msgid ""
"Better controllability. Threads often depend on the kernel's thread "
"scheduler to preempt a busy thread and resume another thread, so "
"preemption may occur unpredictably. Fibers yield themselves to run "
"another fiber while executing, so yields are controlled by application "
"logic."
msgstr ""
"Улучшенная управляемость. Потоки часто зависят от планировщика потока "
"ядра в вопросе вытеснения занятого потока и возобновления другого потока,"
" поэтому вытеснение может быть непредвиденным. Файберы передают "
"управление самостоятельно другому файберу во время работы, поэтому "
"управление файберами осуществляется логикой приложения."

#: ../doc/book/app_server/creating_app.rst:546
msgid ""
"Higher performance. Threads require more resources to preempt as they "
"need to address the system kernel. Fibers are lighter and faster as they "
"don't need to address the kernel to yield."
msgstr ""
"Повышенная производительность. Потокам необходимо больше ресурсов для "
"вытеснения, поскольку они обращаются к ядру системы. Файберы легче и "
"быстрее, поскольку для передачи управления им не нужно обращаться к ядру."

#: ../doc/book/app_server/creating_app.rst:550
msgid ""
"Yet fibers have some limitations as compared with threads, the main "
"limitation being no multi-core mode. All fibers in an application belong "
"to a single thread, so they all use the same CPU core as the parent "
"thread. Meanwhile, this limitation is not really serious for Tarantool "
"applications, because a typical bottleneck for Tarantool is the HDD, not "
"the CPU."
msgstr ""
"Однако у файберов есть определенные ограничения, по сравнению с потоками,"
" основное из которых -- отсутствие режима работы с многоядерной системой."
" Все файберы в приложении относятся к одному потоку, поэтому они "
"используют то же ядро процессора, что и родительский поток. В то же "
"время, это ограничение незначительно для приложений Tarantool'а, "
"поскольку узкое место Tarantool'а -- жесткий диск, а не ЦП."

#: ../doc/book/app_server/creating_app.rst:556
msgid ""
"A fiber has all the features of a Lua `coroutine "
"<http://www.lua.org/pil/contents.html#9>`_ and all programming concepts "
"that apply for Lua coroutines will apply for fibers as well. However, "
"Tarantool has made some enhancements for fibers and has used fibers "
"internally. So, although use of coroutines is possible and supported, use"
" of fibers is recommended."
msgstr ""
"У файбера есть все возможности `сопрограммы "
"<http://www.lua.org/pil/contents.html#9>`_ на языке Lua, и все принципы "
"программирования, которые применяются к сопрограммам на Lua, применимы и "
"к файберам. Однако Tarantool расширил возможности файберов для "
"внутреннего использования. Поэтому, несмотря на возможность и поддержку "
"использования сопрограмм, рекомендуется использовать файберы."

#: ../doc/book/app_server/creating_app.rst:563
msgid ""
"Well, performance or controllability are of little importance in our "
"case. We'll launch ``respawn()`` in a fiber to make it work in the "
"background all the time. To do so, we'll need to amend ``respawn()``:"
msgstr ""
"Производительность или управляемость не слишком важны в нашем случае. "
"Запустим ``respawn()`` в файбере для непрерывной работы в фоновом режиме."
" Для этого необходимо изменить ``respawn()``:"

#: ../doc/book/app_server/creating_app.rst:567
msgid ""
"respawn = function(self)\n"
"    -- let's give our fiber a name;\n"
"    -- this will produce neat output in fiber.info()\n"
"    fiber.name('Respawn fiber')\n"
"    while true do\n"
"        for _, tuple in box.space.pokemons.index.status:pairs(\n"
"                self.state.CAUGHT) do\n"
"            box.space.pokemons:update(\n"
"                tuple[self.ID],\n"
"                {{'=', self.STATUS, self.state.ACTIVE}}\n"
"            )\n"
"        end\n"
"        fiber.sleep(self.respawn_time)\n"
"    end\n"
"end"
msgstr ""
"respawn = function(self)\n"
"    -- назовем наш файбер;\n"
"    -- это выполнит чистый вывод в fiber.info()\n"
"    fiber.name('Respawn fiber')\n"
"    while true do\n"
"        for _, tuple in box.space.pokemons.index.status:pairs(\n"
"                self.state.CAUGHT) do\n"
"            box.space.pokemons:update(\n"
"                tuple[self.ID],\n"
"                {{'=', self.STATUS, self.state.ACTIVE}}\n"
"            )\n"
"        end\n"
"        fiber.sleep(self.respawn_time)\n"
"    end\n"
"end"

#: ../doc/book/app_server/creating_app.rst:585
msgid "and call it as a fiber in ``start()``:"
msgstr "и назвать его файбером в ``start()``:"

#: ../doc/book/app_server/creating_app.rst:587
msgid ""
"start = function(self)\n"
"    -- create spaces and indexes\n"
"        <...>\n"
"    -- create models\n"
"        <...>\n"
"    -- compile models\n"
"        <...>\n"
"    -- start the game\n"
"       self.pokemon_model = compiled_pokemon\n"
"       self.player_model = compiled_player\n"
"       fiber.create(self.respawn, self)\n"
"       log.info('Started')\n"
"    -- errors if schema creation or compilation fails\n"
"       <...>\n"
"end"
msgstr ""
"start = function(self)\n"
"    -- создать спейсы и индексы\n"
"        <...>\n"
"    -- создать модели\n"
"        <...>\n"
"    -- скомпилировать модели\n"
"        <...>\n"
"    -- начать игру\n"
"       self.pokemon_model = compiled_pokemon\n"
"       self.player_model = compiled_player\n"
"       fiber.create(self.respawn, self)\n"
"       log.info('Started')\n"
"    -- ошибки, если создание схемы или компиляция не работает\n"
"       <...>\n"
"end"

#: ../doc/book/app_server/creating_app.rst:607
msgid "Logging"
msgstr "Запись в журнал"

#: ../doc/book/app_server/creating_app.rst:609
msgid ""
"One more helpful function that we used in ``start()`` was ``log.infо()`` "
"from Tarantool :ref:`log <log-module>` module. We also need this function"
" in ``notify()`` to add a record to the log file on every successful "
"catch:"
msgstr ""
"В  ``start()`` мы использовали еще одну полезную функцию -- "
"``log.infо()`` из :ref:`модуля log <log-module>` Tarantool'а . Эта "
"функция также понадобится в ``notify()`` для добавления записи в файл "
"журнала при каждой успешной поимке:"

#: ../doc/book/app_server/creating_app.rst:613
#, python-format
msgid ""
"-- event notification\n"
"notify = function(self, player, pokemon)\n"
"    log.info(\"Player '%s' caught '%s'\", player.name, pokemon.name)\n"
"end"
msgstr ""
"-- уведомление о событии\n"
"notify = function(self, player, pokemon)\n"
"    log.info(\"Player '%s' caught '%s'\", player.name, pokemon.name)\n"
"end"

#: ../doc/book/app_server/creating_app.rst:620
msgid ""
"We use default Tarantool :ref:`log settings <cfg_logging>`, so we'll see "
"the log output in console when we launch our application in script mode."
msgstr ""
"Мы используем стандартные :ref:`настройки журнала <cfg_logging>` "
"Tarantool'а, поэтому увидим вывод записей журнала в консоли, когда "
"запустим приложение в режиме скрипта."

#: ../doc/book/app_server/creating_app.rst:626
msgid ""
"Great! We've discussed all programming practices used in our Lua module "
"(see `pokemon.lua "
"<https://github.com/tarantool/pokemon/blob/1.9/src/pokemon.lua>`_)."
msgstr ""
"Отлично! Мы обсудили все методики программирования, используемые в нашем"
"  Lua-модуле (см. `pokemon.lua "
"<https://github.com/tarantool/pokemon/blob/1.9/src/pokemon.lua>`_)."

#: ../doc/book/app_server/creating_app.rst:629
msgid ""
"Now let's prepare the test environment. As planned, we write a Lua "
"application (see `game.lua "
"<https://github.com/tarantool/pokemon/blob/1.9/game.lua>`_) to initialize"
" Tarantool's database module, initialize our game, call the game loop and"
" simulate a couple of player requests."
msgstr ""
"Теперь подготовим среду тестирования. Как и планировалось, напишем "
"приложение на языке Lua (см. `game.lua "
"<https://github.com/tarantool/pokemon/blob/1.9/game.lua>`_), чтобы "
"инициализировать модуль базы данных Tarantool'а, инициализировать нашу "
"игру, вызвать цикл игры и смоделировать пару запросов от игроков."

#: ../doc/book/app_server/creating_app.rst:634
msgid ""
"To launch our microservice, we put both ``pokemon.lua`` module and "
"``game.lua`` application in the current directory, install all external "
"modules, and launch the Tarantool instance running our ``game.lua`` "
"application (this example is for Ubuntu):"
msgstr ""
"Чтобы запустить микросервис, поместим модуль ``pokemon.lua`` и приложение"
"  ``game.lua`` в текущую директорию, установим все внешние модули и "
"запустим экземпляр Tarantool'а с работают приложением ``game.lua`` (это "
"пример для Ubuntu):"

#: ../doc/book/app_server/creating_app.rst:639
msgid ""
"$ ls\n"
"game.lua  pokemon.lua\n"
"$ sudo apt-get install tarantool-gis\n"
"$ sudo apt-get install tarantool-avro-schema\n"
"$ tarantool game.lua"
msgstr ""
"$ ls\n"
"game.lua  pokemon.lua\n"
"$ sudo apt-get install tarantool-gis\n"
"$ sudo apt-get install tarantool-avro-schema\n"
"$ tarantool game.lua"

#: ../doc/book/app_server/creating_app.rst:647
msgid ""
"Tarantool starts and initializes the database. Then Tarantool executes "
"the demo logic from ``game.lua``: adds a pokémon named Pikachu (its "
"chance to be caught is very high, 99.1), displays the current map (it "
"contains one active pokémon, Pikachu) and processes catch requests from "
"two players. Player1 is located just near the lonely Pikachu pokémon and "
"Player2 is located far away from it. As expected, the catch results in "
"this output are \"true\" for Player1 and \"false\" for Player2. Finally, "
"Tarantool displays the current map which is empty, because Pikachu is "
"caught and temporarily inactive:"
msgstr ""
"Tarantool запускает и инициализирует базу данных. Затем Tarantool "
"выполняет демо-логику из ``game.lua``: добавляет покемона под названием "
"Пикачу (Pikachu) (шанс его поимки очень высок -- 99,1), отображает "
"текущую карту (на ней расположен один активный покемон, Пикачу) и "
"обрабатывает запросы поимки от двух игроков. Player1 (Игрок 1) находится "
"очень близко к одинокому покемону Пикачу, а Player2 (Игрок 2) находится "
"очень далеко от него. Как предполагается, результаты поимки в таком "
"выводе будут \"true\" для Player1 и \"false\" для Player2. Наконец, "
"Tarantool отображает текущую карту, которая пуста, потому что Пикачу "
"пойман и временно неактивен:"

#: ../doc/book/app_server/creating_app.rst:656
msgid ""
"$ tarantool game.lua\n"
"2017-01-09 20:19:24.605 [6282] main/101/game.lua C> version "
"1.7.3-43-gf5fa1e1\n"
"2017-01-09 20:19:24.605 [6282] main/101/game.lua C> log level 5\n"
"2017-01-09 20:19:24.605 [6282] main/101/game.lua I> mapping 1073741824 "
"bytes for tuple arena...\n"
"2017-01-09 20:19:24.609 [6282] main/101/game.lua I> initializing an empty"
" data directory\n"
"2017-01-09 20:19:24.634 [6282] snapshot/101/main I> saving snapshot "
"`./00000000000000000000.snap.inprogress'\n"
"2017-01-09 20:19:24.635 [6282] snapshot/101/main I> done\n"
"2017-01-09 20:19:24.641 [6282] main/101/game.lua I> ready to accept "
"requests\n"
"2017-01-09 20:19:24.786 [6282] main/101/game.lua I> Started\n"
"---\n"
"- {'id': 1, 'status': 'active', 'location': {'y': 2, 'x': 1}, 'name': "
"'Pikachu', 'chance': 99.1}\n"
"...\n"
"\n"
"2017-01-09 20:19:24.789 [6282] main/101/game.lua I> Player 'Player1' "
"caught 'Pikachu'\n"
"true\n"
"false\n"
"--- []\n"
"...\n"
"\n"
"2017-01-09 20:19:24.789 [6282] main C> entering the event loop"
msgstr ""
"$ tarantool game.lua\n"
"2017-01-09 20:19:24.605 [6282] main/101/game.lua C> version "
"1.7.3-43-gf5fa1e1\n"
"2017-01-09 20:19:24.605 [6282] main/101/game.lua C> log level 5\n"
"2017-01-09 20:19:24.605 [6282] main/101/game.lua I> mapping 1073741824 "
"bytes for tuple arena...\n"
"2017-01-09 20:19:24.609 [6282] main/101/game.lua I> initializing an empty"
" data directory\n"
"2017-01-09 20:19:24.634 [6282] snapshot/101/main I> saving snapshot "
"`./00000000000000000000.snap.inprogress'\n"
"2017-01-09 20:19:24.635 [6282] snapshot/101/main I> done\n"
"2017-01-09 20:19:24.641 [6282] main/101/game.lua I> ready to accept "
"requests\n"
"2017-01-09 20:19:24.786 [6282] main/101/game.lua I> Started\n"
"---\n"
"- {'id': 1, 'status': 'active', 'location': {'y': 2, 'x': 1}, 'name': "
"'Pikachu', 'chance': 99.1}\n"
"...\n"
"\n"
"2017-01-09 20:19:24.789 [6282] main/101/game.lua I> Player 'Player1' "
"caught 'Pikachu'\n"
"true\n"
"false\n"
"--- []\n"
"...\n"
"\n"
"2017-01-09 20:19:24.789 [6282] main C> entering the event loop"

#: ../doc/book/app_server/creating_app.rst:681
msgid "nginx"
msgstr "nginx"

#: ../doc/book/app_server/creating_app.rst:683
msgid ""
"In the real life, this microservice would work over HTTP. Let's add "
"`nginx <https://nginx.org/en/>`_ web server to our environment and make a"
" similar demo. But how do we make Tarantool methods callable via REST "
"API? We use nginx with `Tarantool nginx upstream "
"<https://github.com/tarantool/nginx_upstream_module>`_ module and create "
"one more Lua script (`app.lua "
"<https://github.com/tarantool/pokemon/blob/1.9/src/app.lua>`_) that "
"exports three of our game methods -- ``add_pokemon()``, ``map()`` and "
"``catch()`` -- as REST endpoints of the nginx upstream module:"
msgstr ""
"В реальной жизни такой микросервис работал бы по HTTP. Добавим веб-сервер"
" `nginx <https://nginx.org/en/>`_ в нашу среду и сделаем аналогичный "
"пример. Но как вызывать методы Tarantool'а с помощью REST API? Мы "
"используем nginx с модулем `Tarantool nginx upstream "
"<https://github.com/tarantool/nginx_upstream_module>`_ и создадим еще "
"один скрипт на Lua (`app.lua "
"<https://github.com/tarantool/pokemon/blob/1.9/src/app.lua>`_), который "
"экспортирует три наших игровых метода -- ``add_pokemon()``, ``map()`` и "
"``catch()`` -- в качестве конечных точек обработки запросов REST модуля "
"nginx upstream:"

#: ../doc/book/app_server/creating_app.rst:692
msgid ""
"local game = require('pokemon')\n"
"box.cfg{listen=3301}\n"
"game:start()\n"
"\n"
"-- add, map and catch functions exposed to REST API\n"
"function add(request, pokemon)\n"
"    return {\n"
"        result=game:add_pokemon(pokemon)\n"
"    }\n"
"end\n"
"\n"
"function map(request)\n"
"    return {\n"
"        map=game:map()\n"
"    }\n"
"end\n"
"\n"
"function catch(request, pid, player)\n"
"    local id = tonumber(pid)\n"
"    if id == nil then\n"
"        return {result=false}\n"
"    end\n"
"    return {\n"
"        result=game:catch(id, player)\n"
"    }\n"
"end"
msgstr ""
"local game = require('pokemon')\n"
"box.cfg{listen=3301}\n"
"game:start()\n"
"\n"
"-- функции add, map и catch по REST API\n"
"function add(request, pokemon)\n"
"    return {\n"
"        result=game:add_pokemon(pokemon)\n"
"    }\n"
"end\n"
"\n"
"function map(request)\n"
"    return {\n"
"        map=game:map()\n"
"    }\n"
"end\n"
"\n"
"function catch(request, pid, player)\n"
"    local id = tonumber(pid)\n"
"    if id == nil then\n"
"        return {result=false}\n"
"    end\n"
"    return {\n"
"        result=game:catch(id, player)\n"
"    }\n"
"end"

#: ../doc/book/app_server/creating_app.rst:721
msgid ""
"An easy way to configure and launch nginx would be to create a Docker "
"container based on a `Docker image <https://hub.docker.com/r/tarantool"
"/tarantool-nginx/>`_ with nginx and the upstream module already installed"
" (see `http/Dockerfile "
"<https://github.com/tarantool/pokemon/blob/1.9/http/Dockerfile>`_). We "
"take a standard `nginx.conf "
"<https://github.com/tarantool/pokemon/blob/1.9/http/nginx.conf>`_, where "
"we define an upstream with our Tarantool backend running (this is another"
" Docker container, see details below):"
msgstr ""
"Чтобы с легкостью настроить и запустить nginx, необходимо создать "
"Docker-контейнер на основе `Docker-образа "
"<https://hub.docker.com/r/tarantool /tarantool-nginx/>`_ с уже "
"установленными nginx и модулем upstream (см. `http/Dockerfile "
"<https://github.com/tarantool/pokemon/blob/1.9/http/Dockerfile>`_). Берем"
" стандартный `nginx.conf "
"<https://github.com/tarantool/pokemon/blob/1.9/http/nginx.conf>`_, где "
"определяем upstream с работающим бэкендом Tarantool'а (это еще один "
"Docker-контейнер, см. нижеприведенную информацию):"

#: ../doc/book/app_server/creating_app.rst:730
msgid ""
"upstream tnt {\n"
"      server pserver:3301 max_fails=1 fail_timeout=60s;\n"
"      keepalive 250000;\n"
"}"
msgstr ""
"upstream tnt {\n"
"      server pserver:3301 max_fails=1 fail_timeout=60s;\n"
"      keepalive 250000;\n"
"}"

#: ../doc/book/app_server/creating_app.rst:737
msgid ""
"and add some Tarantool-specific parameters (see descriptions in the "
"upstream module's `README "
"<https://github.com/tarantool/nginx_upstream_module#directives>`_ file):"
msgstr ""
"и добавляем специальные параметры для Tarantool'а (см. описание в файле "
"`README <https://github.com/tarantool/nginx_upstream_module#directives>`_"
" модуля upstream):"

#: ../doc/book/app_server/creating_app.rst:741
msgid ""
"server {\n"
"  server_name tnt_test;\n"
"\n"
"  listen 80 default deferred reuseport so_keepalive=on backlog=65535;\n"
"\n"
"  location = / {\n"
"      root /usr/local/nginx/html;\n"
"  }\n"
"\n"
"  location /api {\n"
"    # answers check infinity timeout\n"
"    tnt_read_timeout 60m;\n"
"    if ( $request_method = GET ) {\n"
"       tnt_method \"map\";\n"
"    }\n"
"    tnt_http_rest_methods get;\n"
"    tnt_http_methods all;\n"
"    tnt_multireturn_skip_count 2;\n"
"    tnt_pure_result on;\n"
"    tnt_pass_http_request on parse_args;\n"
"    tnt_pass tnt;\n"
"  }\n"
"}"
msgstr ""
"server {\n"
"  server_name tnt_test;\n"
"\n"
"  listen 80 default deferred reuseport so_keepalive=on backlog=65535;\n"
"\n"
"  location = / {\n"
"      root /usr/local/nginx/html;\n"
"  }\n"
"\n"
"  location /api {\n"
"    # ответы проверяют бесконечное время ожидания\n"
"    tnt_read_timeout 60m;\n"
"    if ( $request_method = GET ) {\n"
"       tnt_method \"map\";\n"
"    }\n"
"    tnt_http_rest_methods get;\n"
"    tnt_http_methods all;\n"
"    tnt_multireturn_skip_count 2;\n"
"    tnt_pure_result on;\n"
"    tnt_pass_http_request on parse_args;\n"
"    tnt_pass tnt;\n"
"  }\n"
"}"

#: ../doc/book/app_server/creating_app.rst:767
msgid ""
"Likewise, we put Tarantool server and all our game logic in a second "
"Docker container based on the `official Tarantool 1.9 image "
"<https://github.com/tarantool/docker>`_ (see `src/Dockerfile "
"<https://github.com/tarantool/pokemon/blob/1.9/src/Dockerfile>`_) and set"
" the container's default command to ``tarantool app.lua``. This is the "
"backend."
msgstr ""
"Аналогичным образом, поместим Tarantool-сервер и всю игровую логику в "
"другой Docker-контейнер на основе `официального образа Tarantool'а 1.9 "
"<https://github.com/tarantool/docker>`_ (см. `src/Dockerfile "
"<https://github.com/tarantool/pokemon/blob/1.9/src/Dockerfile>`_) и "
"установим ``tarantool app.lua`` в качестве стандартной команды для "
"контейнера. Это бэкенд."

#: ../doc/book/app_server/creating_app.rst:776
msgid "Non-blocking IO"
msgstr "Неблокирующий ввод-вывод"

#: ../doc/book/app_server/creating_app.rst:778
msgid ""
"To test the REST API, we create a new script (`client.lua "
"<https://github.com/tarantool/pokemon/blob/1.9/client/client.lua>`_), "
"which is similar to our ``game.lua`` application, but makes HTTP POST and"
" GET requests rather than calling Lua functions:"
msgstr ""
"Чтобы протестировать REST API, создадим новый скрипт (`client.lua "
"<https://github.com/tarantool/pokemon/blob/1.9/client/client.lua>`_), "
"который похож на наше приложение ``game.lua``, но отправляет запросы HTTP"
" POST и GET, а не вызывает Lua-функции:"

#: ../doc/book/app_server/creating_app.rst:783
#, python-format
msgid ""
"local http = require('curl').http()\n"
"local json = require('json')\n"
"local URI = os.getenv('SERVER_URI')\n"
"local fiber = require('fiber')\n"
"\n"
"local player1 = {\n"
"    name=\"Player1\",\n"
"    id=1,\n"
"    location = {\n"
"        x=1.0001,\n"
"        y=2.0003\n"
"    }\n"
"}\n"
"local player2 = {\n"
"    name=\"Player2\",\n"
"    id=2,\n"
"    location = {\n"
"        x=30.123,\n"
"        y=40.456\n"
"    }\n"
"}\n"
"\n"
"local pokemon = {\n"
"    name=\"Pikachu\",\n"
"    chance=99.1,\n"
"    id=1,\n"
"    status=\"active\",\n"
"    location = {\n"
"        x=1,\n"
"        y=2\n"
"    }\n"
"}\n"
"\n"
"function request(method, body, id)\n"
"    local resp = http:request(\n"
"        method, URI, body\n"
"    )\n"
"    if id ~= nil then\n"
"        print(string.format('Player %d result: %s',\n"
"            id, resp.body))\n"
"    else\n"
"        print(resp.body)\n"
"    end\n"
"end\n"
"\n"
"local players = {}\n"
"function catch(player)\n"
"    fiber.sleep(math.random(5))\n"
"    print('Catch pokemon by player ' .. tostring(player.id))\n"
"    request(\n"
"        'POST', '{\"method\": \"catch\",\n"
"        \"params\": [1, '..json.encode(player)..']}',\n"
"        tostring(player.id)\n"
"    )\n"
"    table.insert(players, player.id)\n"
"end\n"
"\n"
"print('Create pokemon')\n"
"request('POST', '{\"method\": \"add\",\n"
"    \"params\": ['..json.encode(pokemon)..']}')\n"
"request('GET', '')\n"
"\n"
"fiber.create(catch, player1)\n"
"fiber.create(catch, player2)\n"
"\n"
"-- wait for players\n"
"while #players ~= 2 do\n"
"    fiber.sleep(0.001)\n"
"end\n"
"\n"
"request('GET', '')\n"
"os.exit()"
msgstr ""
"local http = require('curl').http()\n"
"local json = require('json')\n"
"local URI = os.getenv('SERVER_URI')\n"
"local fiber = require('fiber')\n"
"\n"
"local player1 = {\n"
"    name=\"Player1\",\n"
"    id=1,\n"
"    location = {\n"
"        x=1.0001,\n"
"        y=2.0003\n"
"    }\n"
"}\n"
"local player2 = {\n"
"    name=\"Player2\",\n"
"    id=2,\n"
"    location = {\n"
"        x=30.123,\n"
"        y=40.456\n"
"    }\n"
"}\n"
"\n"
"local pokemon = {\n"
"    name=\"Pikachu\",\n"
"    chance=99.1,\n"
"    id=1,\n"
"    status=\"active\",\n"
"    location = {\n"
"        x=1,\n"
"        y=2\n"
"    }\n"
"}\n"
"\n"
"function request(method, body, id)\n"
"    local resp = http:request(\n"
"        method, URI, body\n"
"    )\n"
"    if id ~= nil then\n"
"        print(string.format('Player %d result: %s',\n"
"            id, resp.body))\n"
"    else\n"
"        print(resp.body)\n"
"    end\n"
"end\n"
"\n"
"local players = {}\n"
"function catch(player)\n"
"    fiber.sleep(math.random(5))\n"
"    print('Catch pokemon by player ' .. tostring(player.id))\n"
"    request(\n"
"        'POST', '{\"method\": \"catch\",\n"
"        \"params\": [1, '..json.encode(player)..']}',\n"
"        tostring(player.id)\n"
"    )\n"
"    table.insert(players, player.id)\n"
"end\n"
"\n"
"print('Create pokemon')\n"
"request('POST', '{\"method\": \"add\",\n"
"    \"params\": ['..json.encode(pokemon)..']}')\n"
"request('GET', '')\n"
"\n"
"fiber.create(catch, player1)\n"
"fiber.create(catch, player2)\n"
"\n"
"-- подождать игроков\n"
"while #players ~= 2 do\n"
"    fiber.sleep(0.001)\n"
"end\n"
"\n"
"request('GET', '')\n"
"os.exit()"

#: ../doc/book/app_server/creating_app.rst:858
msgid ""
"When you run this script, you’ll notice that both players have equal "
"chances to make the first attempt at catching the pokémon. In a classical"
" Lua script, a networked call blocks the script until it’s finished, so "
"the first catch attempt can only be done by the player who entered the "
"game first. In Tarantool, both players play concurrently, since all "
"modules are integrated with Tarantool :ref:`cooperative multitasking "
"<atomic-cooperative_multitasking>` and use non-blocking I/O."
msgstr ""
"При запуске этого скрипта вы заметите, что у обоих игроков одинаковые "
"шансы сделать первую попытку поимки покемона. В классическом Lua-скрипте "
"сетевой вызов блокирует скрипт, пока он не будет выполнен, поэтому первым"
" попытаться поймать может тот игрок, который раньше зашел в игру. В "
"Tarantool'е оба игрока играют одновременно, поскольку все модули "
"объединены в :ref:`кооперативной многозадачности <atomic-"
"cooperative_multitasking>` и используют неблокирующий ввод-вывод."

#: ../doc/book/app_server/creating_app.rst:866
msgid ""
"Indeed, when Player1 makes its first REST call, the script doesn’t block."
" The fiber running ``catch()`` function on behalf of Player1 issues a "
"non-blocking call to the operating system and yields control to the next "
"fiber, which happens to be the fiber of Player2. Player2’s fiber does the"
" same. When the network response is received, Player1's fiber is "
"activated by Tarantool cooperative scheduler, and resumes its work. All "
"Tarantool :ref:`modules <built_in_modules>` use non-blocking I/O and are "
"integrated with Tarantool cooperative scheduler. For module developers, "
"Tarantool provides an :ref:`API <index-c_api_reference>`."
msgstr ""
"Действительно, когда Player1 посылает первый REST-вызов, скрипт не "
"блокируется. Файбер, выполняющий функцию ``catch()`` от Player1, посылает"
" неблокирующий вызов в операционную систему и передает управление на "
"следующий файбер, которым оказывается файбер от Player2. Файбер от "
"Player2 делает то же самое. Когда получен сетевой ответ, файбер от "
"Player1 активируется  с помощью кооперативного планировщика Tarantool'а и"
" возобновляет работу. Все :ref:`модули <built_in_modules>` Tarantool'а "
"используют неблокирующий ввод-вывод и интегрированы с кооперативным "
"планировщиком Tarantool'а. Разработчикам модулей Tarantool предоставляет "
":ref:`API <index-c_api_reference>`."

#: ../doc/book/app_server/creating_app.rst:875
msgid ""
"For our HTTP test, we create a third container based on the `official "
"Tarantool 1.9 image <https://github.com/tarantool/docker>`_ (see "
"`client/Dockerfile "
"<https://github.com/tarantool/pokemon/blob/1.9/client/Dockerfile>`_) and "
"set the container's default command to ``tarantool client.lua``."
msgstr ""
"Для HTTP-теста создадим третий контейнер на основе `официального образа "
"Tarantool'а 1.9 <https://github.com/tarantool/docker>`_ (см. "
"`client/Dockerfile "
"<https://github.com/tarantool/pokemon/blob/1.9/client/Dockerfile>`_)  "
"установим ``tarantool client.lua`` в качестве стандартной команды для "
"контейнера."

#: ../doc/book/app_server/creating_app.rst:883
msgid ""
"To run this test locally, download our `pokemon "
"<https://github.com/tarantool/pokemon>`_ project from GitHub and say:"
msgstr ""
"Чтобы запустить тест локально, скачайте наш проект `покемон "
"<https://github.com/tarantool/pokemon>`_ из GitHub и вызовите:"

#: ../doc/book/app_server/creating_app.rst:886
msgid ""
"$ docker-compose build\n"
"$ docker-compose up"
msgstr ""
"$ docker-compose build\n"
"$ docker-compose up"

#: ../doc/book/app_server/creating_app.rst:891
msgid ""
"Docker Compose builds and runs all the three containers: ``pserver`` "
"(Tarantool backend), ``phttp`` (nginx) and ``pclient`` (demo client). You"
" can see log messages from all these containers in the console, pclient "
"saying that it made an HTTP request to create a pokémon, made two catch "
"requests, requested the map (empty since the pokémon is caught and "
"temporarily inactive) and exited:"
msgstr ""
"Docker Compose собирает и запускает все три контейнера: ``pserver`` "
"(бэкенд Tarantool'а), ``phttp`` (nginx) и``pclient`` (демо-клиент). ВЫ "
"можете увидеть все сообщения журнала из всех этих контейнеров в консоли. "
"pclient выведет, что сделал HTTP-запрос на создание покемона, два запроса"
" на поимку покемона, запросил карту (пустая, поскольку покемон пойман и "
"временно неактивен) и завершил работу:"

#: ../doc/book/app_server/creating_app.rst:897
msgid ""
"pclient_1  | Create pokemon\n"
"<...>\n"
"pclient_1  | {\"result\":true}\n"
"pclient_1  | "
"{\"map\":[{\"id\":1,\"status\":\"active\",\"location\":{\"y\":2,\"x\":1},\"name\":\"Pikachu\",\"chance\":99.100000}]}"
"\n"
"pclient_1  | Catch pokemon by player 2\n"
"pclient_1  | Catch pokemon by player 1\n"
"pclient_1  | Player 1 result: {\"result\":true}\n"
"pclient_1  | Player 2 result: {\"result\":false}\n"
"pclient_1  | {\"map\":[]}\n"
"pokemon_pclient_1 exited with code 0"
msgstr ""
"pclient_1  | Create pokemon\n"
"<...>\n"
"pclient_1  | {\"result\":true}\n"
"pclient_1  | "
"{\"map\":[{\"id\":1,\"status\":\"active\",\"location\":{\"y\":2,\"x\":1},\"name\":\"Pikachu\",\"chance\":99.100000}]}"
"\n"
"pclient_1  | Catch pokemon by player 2\n"
"pclient_1  | Catch pokemon by player 1\n"
"pclient_1  | Player 1 result: {\"result\":true}\n"
"pclient_1  | Player 2 result: {\"result\":false}\n"
"pclient_1  | {\"map\":[]}\n"
"pokemon_pclient_1 exited with code 0"

#: ../doc/book/app_server/creating_app.rst:910
msgid ""
"Congratulations! Here's the end point of our walk-through. As further "
"reading, see more about :ref:`installing <app_server-installing_module>` "
"and :ref:`contributing <app_server-contributing_module>` a module."
msgstr ""
"Поздравляем! Вот мы и закончили наш пошаговый пример. Для дальнейшего "
"изучения рекомендуем :ref:`установку <app_server-installing_module>` и "
":ref:`добавление <app_server-contributing_module>` модуля."

#: ../doc/book/app_server/creating_app.rst:914
msgid ""
"See also reference on :ref:`Tarantool modules <built_in_modules>` and "
":ref:`C API <index-c_api_reference>`, and don't miss our :ref:`Lua "
"cookbook recipes <cookbook>`."
msgstr ""
"См. также справочник по :ref:`модулям Tarantool'а <built_in_modules>` и "
":ref:`C API <index-c_api_reference>` и не пропустите наши "
":ref:`рекомендации по разработке на Lua <cookbook>`."

#: ../doc/book/app_server/index.rst:5
msgid "Application server"
msgstr "Сервер приложений"

#: ../doc/book/app_server/index.rst:7
msgid ""
"In this chapter, we introduce the basics of working with Tarantool as a "
"Lua application server."
msgstr ""
"В данной главе мы рассмотрим основы работы с Tarantool'ом в качестве "
"сервера приложений на языке Lua."

#: ../doc/book/app_server/index.rst:10 ../doc/book/box/index.rst:10
#: ../doc/book/cartridge/index.rst:11 ../doc/book/getting_started/index.rst:10
msgid "This chapter contains the following sections:"
msgstr "Эта глава состоит из следующих разделов:"

#: ../doc/book/app_server/installing_module.rst:5
msgid "Installing a module"
msgstr "Установка модуля"

#: ../doc/book/app_server/installing_module.rst:7
msgid ""
"Modules in Lua and C that come from Tarantool developers and community "
"contributors are available in the following locations:"
msgstr ""
"Модули на Lua и C от разработчиков Tarantool'а и сторонних разработчиков "
"доступны здесь:"

#: ../doc/book/app_server/installing_module.rst:10
msgid "Tarantool modules repository, and"
msgstr "Репозиторий модулей Tarantool'а и"

#: ../doc/book/app_server/installing_module.rst:11
msgid "Tarantool deb/rpm repositories."
msgstr "Репозитории deb/rpm Tarantool'а."

#: ../doc/book/app_server/installing_module.rst:17
msgid "Installing a module from a repository"
msgstr "Установка модуля из репозитория"

#: ../doc/book/app_server/installing_module.rst:19
msgid ""
"See `README in tarantool/rocks repository "
"<https://github.com/tarantool/rocks#managing-modules-with-"
"tarantool-174>`_ for detailed instructions."
msgstr ""
"Для получения подробной информации см. `README в репозитории "
"tarantool/rocks <https://github.com/tarantool/rocks#managing-modules-"
"with-tarantool-174>`_."

#: ../doc/book/app_server/installing_module.rst:27
msgid "Installing a module from deb/rpm"
msgstr "Установка модуля из deb/rpm"

#: ../doc/book/app_server/installing_module.rst:29
msgid "Follow these steps:"
msgstr "Выполните следующие действия:"

#: ../doc/book/app_server/installing_module.rst:31
msgid ""
"Install Tarantool as recommended on the `download page "
"<http://tarantool.org/download.html>`_."
msgstr ""
"Установите Tarantool в соответствии с рекомендациями на `странице "
"загрузки <http://tarantool.org/download.html>`_."

#: ../doc/book/app_server/installing_module.rst:34
msgid ""
"Install the module you need. Look up the module's name on `Tarantool "
"rocks page <http://tarantool.org/rocks.html>`_ and put the prefix "
"\"tarantool-\" before the module name to avoid ambiguity:"
msgstr ""
"Установите необходимый модуль. Найдите имя модуля на `странице со "
"сторонними библиотеками Tarantool'а <http://tarantool.org/rocks.html>`_  "
"и введите префикс \"tarantool-\" перед названием модуля во избежание "
"неоднозначности:"

#: ../doc/book/app_server/installing_module.rst:38
msgid ""
"$ # for Ubuntu/Debian:\n"
"$ sudo apt-get install tarantool-<module-name>\n"
"\n"
"$ # for RHEL/CentOS/Amazon:\n"
"$ sudo yum install tarantool-<module-name>"
msgstr ""
"$ # для Ubuntu/Debian:\n"
"$ sudo apt-get install tarantool-<module-name>\n"
"\n"
"$ # для RHEL/CentOS/Amazon:\n"
"$ sudo yum install tarantool-<module-name>"

#: ../doc/book/app_server/installing_module.rst:46
msgid ""
"For example, to install the module `shard "
"<http://github.com/tarantool/shard>`_ on Ubuntu, say:"
msgstr ""
"Например, чтобы установить модуль `shard "
"<http://github.com/tarantool/shard>`_ на Ubuntu, введите:"

#: ../doc/book/app_server/installing_module.rst:49
msgid "$ sudo apt-get install tarantool-shard"
msgstr "$ sudo apt-get install tarantool-shard"

#: ../doc/book/app_server/installing_module.rst:53
msgid "Once these steps are complete, you can:"
msgstr "Теперь можно:"

#: ../doc/book/app_server/installing_module.rst:55
msgid "load any module with"
msgstr "загружать любой модуль с помощью"

#: ../doc/book/app_server/installing_module.rst:57
msgid "tarantool> name = require('module-name')"
msgstr "tarantool> name = require('module-name')"

#: ../doc/book/app_server/installing_module.rst:61
msgid "for example:"
msgstr "например:"

#: ../doc/book/app_server/installing_module.rst:63
msgid "tarantool> shard = require('shard')"
msgstr "tarantool> shard = require('shard')"

#: ../doc/book/app_server/installing_module.rst:67
msgid ""
"search locally for installed modules using ``package.path`` (Lua) or "
"``package.cpath`` (C):"
msgstr ""
"локально находить установленные модули с помощью ``package.path`` (Lua) "
"или ``package.cpath`` (C):"

#: ../doc/book/app_server/installing_module.rst:70
msgid ""
"tarantool> package.path\n"
"---\n"
"- ./?.lua;./?/init.lua; "
"/usr/local/share/tarantool/?.lua;/usr/local/share/\n"
"tarantool/?/init.lua;/usr/share/tarantool/?.lua;/usr/share/tarantool/?/ini"
"\n"
"t.lua;/usr/local/share/lua/5.1/?.lua;/usr/local/share/lua/5.1/?/init.lua;/"
"\n"
"usr/share/lua/5.1/?.lua;/usr/share/lua/5.1/?/init.lua;\n"
"...\n"
"\n"
"tarantool> package.cpath\n"
"---\n"
"- ./?.so;/usr/local/lib/x86_64-linux-"
"gnu/tarantool/?.so;/usr/lib/x86_64-li\n"
"nux-"
"gnu/tarantool/?.so;/usr/local/lib/tarantool/?.so;/usr/local/lib/x86_64\n"
"-linux-gnu/lua/5.1/?.so;/usr/lib/x86_64-linux-"
"gnu/lua/5.1/?.so;/usr/local/\n"
"lib/lua/5.1/?.so;\n"
"..."
msgstr ""
"tarantool> package.path\n"
"---\n"
"- ./?.lua;./?/init.lua; "
"/usr/local/share/tarantool/?.lua;/usr/local/share/\n"
"tarantool/?/init.lua;/usr/share/tarantool/?.lua;/usr/share/tarantool/?/ini"
"\n"
"t.lua;/usr/local/share/lua/5.1/?.lua;/usr/local/share/lua/5.1/?/init.lua;/"
"\n"
"usr/share/lua/5.1/?.lua;/usr/share/lua/5.1/?/init.lua;\n"
"...\n"
"\n"
"tarantool> package.cpath\n"
"---\n"
"- ./?.so;/usr/local/lib/x86_64-linux-"
"gnu/tarantool/?.so;/usr/lib/x86_64-li\n"
"nux-"
"gnu/tarantool/?.so;/usr/local/lib/tarantool/?.so;/usr/local/lib/x86_64\n"
"-linux-gnu/lua/5.1/?.so;/usr/lib/x86_64-linux-"
"gnu/lua/5.1/?.so;/usr/local/\n"
"lib/lua/5.1/?.so;\n"
"..."

#: ../doc/book/app_server/installing_module.rst:90
msgid ""
"Question-marks stand for the module name that was specified earlier when "
"saying ``require('module-name')``."
msgstr ""
"Знаки вопроса стоят вместо имени модуля, которое было указано ранее при "
"вызове ``require('module-name')``."

#: ../doc/book/app_server/launching_app.rst:5
msgid "Launching an application"
msgstr "Запуск приложения"

#: ../doc/book/app_server/launching_app.rst:7
msgid ""
"Using Tarantool as an application server, you can write your own "
"applications. Tarantool’s native language for writing applications is "
"`Lua <http://www.lua.org/about.html>`_, so a typical application would be"
" a file that contains your Lua script. But you can also write "
"applications in C or C++."
msgstr ""
"Используя Tarantool в качестве сервера приложений, вы можете написать "
"собственные приложения. Собственный язык Tarantool’а для приложений -- "
"`Lua <http://www.lua.org/about.html>`_, поэтому типовое приложение "
"представляет собой файл, который содержит Lua-скрипт. Однако вы также "
"можете писать приложения на C или C++."

#: ../doc/book/app_server/launching_app.rst:15
msgid ""
"If you're new to Lua, we recommend going over the interactive Tarantool "
"tutorial before proceeding with this chapter. To launch the tutorial, say"
" ``tutorial()`` in Tarantool console:"
msgstr ""
"Если вы только осваиваете Lua, рекомендуем выполнить практическое задание"
" по Tarantool'у до работы с данной главой. Для запуска практического "
"задания, выполните команду ``tutorial()`` в консоли Tarantool'а:"

#: ../doc/book/app_server/launching_app.rst:19
msgid ""
"tarantool> tutorial()\n"
"---\n"
"- |\n"
" Tutorial -- Screen #1 -- Hello, Moon\n"
" ====================================\n"
"\n"
" Welcome to the Tarantool tutorial.\n"
" It will introduce you to Tarantool’s Lua application server\n"
" and database server, which is what’s running what you’re seeing.\n"
" This is INTERACTIVE -- you’re expected to enter requests\n"
" based on the suggestions or examples in the screen’s text.\n"
" <...>"
msgstr ""
"tarantool> tutorial()\n"
"---\n"
"- |\n"
" Tutorial -- Screen #1 -- Hello, Moon\n"
" ====================================\n"
"\n"
" Welcome to the Tarantool tutorial.\n"
" It will introduce you to Tarantool’s Lua application server\n"
" and database server, which is what’s running what you’re seeing.\n"
" This is INTERACTIVE -- you’re expected to enter requests\n"
" based on the suggestions or examples in the screen’s text.\n"
" <...>"

#: ../doc/book/app_server/launching_app.rst:34
msgid ""
"Let's create and launch our first Lua application for Tarantool. Here's a"
" simplest Lua application, the good old \"Hello, world!\":"
msgstr ""
"Создадим и запустим первое приложение на языке Lua для Tarantool'а -- "
"самое простое приложение, старую добрую программу \"Hello, world!\":"

#: ../doc/book/app_server/launching_app.rst:37
msgid ""
"#!/usr/bin/env tarantool\n"
"print('Hello, world!')"
msgstr ""
"#!/usr/bin/env tarantool\n"
"print('Hello, world!')"

#: ../doc/book/app_server/launching_app.rst:42
msgid "We save it in a file. Let it be ``myapp.lua`` in the current directory."
msgstr ""
"Сохраним приложение в файле. Пусть это будет ``myapp.lua`` в текущей "
"директории."

#: ../doc/book/app_server/launching_app.rst:44
msgid "Now let's discuss how we can launch our application with Tarantool."
msgstr "Теперь рассмотрим, как можно запустить наше приложение с Tarantool'ом."

#: ../doc/book/app_server/launching_app.rst:50
msgid "Launching in Docker"
msgstr "Запуск в Docker"

#: ../doc/book/app_server/launching_app.rst:52
msgid ""
"If we run Tarantool in a :ref:`Docker container <getting_started-"
"using_docker>`, the following command will start Tarantool 1.9 without "
"any application:"
msgstr ""
"Если мы запустим Tarantool в :ref:`Docker-контейнере <getting_started-"
"using_docker>`, Tarantool 1.9 начнет работу без какого-либо приложения "
"после следующей команды:"

#: ../doc/book/app_server/launching_app.rst:55
msgid ""
"$ # create a temporary container and run it in interactive mode\n"
"$ docker run --rm -t -i tarantool/tarantool:1"
msgstr ""
"$ # создать временный контейнер и запустить его в интерактивном режиме\n"
"$ docker run --rm -t -i tarantool/tarantool:1"

#: ../doc/book/app_server/launching_app.rst:60
msgid "To run Tarantool with our application, we can say:"
msgstr "Чтобы запустить Tarantool с нашим приложением, можно выполнить команду:"

#: ../doc/book/app_server/launching_app.rst:62
msgid ""
"$ # create a temporary container and\n"
"$ # launch Tarantool with our application\n"
"$ docker run --rm -t -i \\\n"
"             -v `pwd`/myapp.lua:/opt/tarantool/myapp.lua \\\n"
"             -v /data/dir/on/host:/var/lib/tarantool \\\n"
"             tarantool/tarantool:1 tarantool /opt/tarantool/myapp.lua"
msgstr ""
"$ # создать временный контейнер и\n"
"$ # запустить Tarantool с нашим приложением\n"
"$ docker run --rm -t -i \\\n"
"             -v `pwd`/myapp.lua:/opt/tarantool/myapp.lua \\\n"
"             -v /data/dir/on/host:/var/lib/tarantool \\\n"
"             tarantool/tarantool:1 tarantool /opt/tarantool/myapp.lua"

#: ../doc/book/app_server/launching_app.rst:71
msgid "Here two resources on the host get mounted in the container:"
msgstr "Здесь два ресурса подключаются к серверу в контейнере:"

#: ../doc/book/app_server/launching_app.rst:73
msgid "our application file (myapp.lua) and"
msgstr "наш файл с приложением (myapp.lua) и"

#: ../doc/book/app_server/launching_app.rst:74
msgid "Tarantool data directory (``/data/dir/on/host``)."
msgstr "каталог данных Tarantool'а (``/data/dir/on/host``)."

#: ../doc/book/app_server/launching_app.rst:76
msgid ""
"By convention, the directory for Tarantool application code inside a "
"container is ``/opt/tarantool``, and the directory for data is "
"``/var/lib/tarantool``."
msgstr ""
"Традиционно в контейнере директория ``/opt/tarantool`` используется для "
"кода приложения  Tarantool'а, а директория ``/var/lib/tarantool`` "
"используется для данных."

#: ../doc/book/app_server/launching_app.rst:83
msgid "Launching a binary program"
msgstr "Запуск бинарной программы"

#: ../doc/book/app_server/launching_app.rst:85
msgid ""
"If we run Tarantool from a :ref:`binary package <getting_started-"
"using_binary>` or from a :ref:`source build <building_from_source>`, we "
"can launch our application:"
msgstr ""
"При запуске Tarantool'а из :ref:`бинарного пакета <getting_started-"
"using_binary>` или :ref:`сборке из исходников <building_from_source>`, "
"можно запустить наше приложение:"

#: ../doc/book/app_server/launching_app.rst:89
msgid "in the script mode,"
msgstr "в режиме скрипта,"

#: ../doc/book/app_server/launching_app.rst:90
msgid "as a server application, or"
msgstr "как серверное приложение или"

#: ../doc/book/app_server/launching_app.rst:91
msgid "as a daemon service."
msgstr "как демон службы."

#: ../doc/book/app_server/launching_app.rst:93
msgid "The simplest way is to pass the filename to Tarantool at start:"
msgstr "Самый простой способ -- передать имя файла в Tarantool при запуске:"

#: ../doc/book/app_server/launching_app.rst:95
#: ../doc/book/app_server/launching_app.rst:186
msgid ""
"$ tarantool myapp.lua\n"
"Hello, world!\n"
"$"
msgstr ""
"$ tarantool myapp.lua\n"
"Hello, world!\n"
"$"

#: ../doc/book/app_server/launching_app.rst:101
msgid "Tarantool starts, executes our script in the **script mode** and exits."
msgstr ""
"Tarantool запускается, выполняет наш скрипт в **режиме скрипта** и "
"завершает работу."

#: ../doc/book/app_server/launching_app.rst:103
msgid ""
"Now let’s turn this script into a **server application**. We use "
":ref:`box.cfg <box_introspection-box_cfg>` from Tarantool’s built-in Lua "
"module to:"
msgstr ""
"Теперь превратим этот скрипт в **серверное приложение**. Используем "
":ref:`box.cfg <box_introspection-box_cfg>` из встроенного в Tarantool "
"Lua-модуля, чтобы:"

#: ../doc/book/app_server/launching_app.rst:107
msgid ""
"launch the database (a database has a persistent on-disk state, which "
"needs to be restored after we start an application) and"
msgstr ""
"запустить базу данных (данные в базе находятся в персистентном состоянии "
"на диске, которое следует восстановить после запуска приложения) и"

#: ../doc/book/app_server/launching_app.rst:109
msgid "configure Tarantool as a server that accepts requests over a TCP port."
msgstr "настроить Tarantool как сервер, который принимает запросы по TCP-порту."

#: ../doc/book/app_server/launching_app.rst:111
msgid ""
"We also add some simple database logic, using :ref:`space.create() "
"<box_schema-space_create>` and :ref:`create_index() <box_space-"
"create_index>` to create a space with a primary index. We use the "
"function :ref:`box.once() <box-once>` to make sure that our logic will be"
" executed only once when the database is initialized for the first time, "
"so we don't try to create an existing space or index on each invocation "
"of the script:"
msgstr ""
"Также добавим простую логику для базы данных, используя "
":ref:`space.create() <box_schema-space_create>` и :ref:`create_index() "
"<box_space-create_index>` для создания спейса с первичным индексом. "
"Используем функцию :ref:`box.once() <box-once>`, чтобы обеспечить "
"единовременное выполнение логики после первоначальной инициализации базы "
"данных, поскольку мы не хотим создавать уже существующий спейс или индекс"
" при каждом обращении к скрипту:"

#: ../doc/book/app_server/launching_app.rst:119
msgid ""
"#!/usr/bin/env tarantool\n"
"-- Configure database\n"
"box.cfg {\n"
"   listen = 3301\n"
"}\n"
"box.once(\"bootstrap\", function()\n"
"   box.schema.space.create('tweedledum')\n"
"   box.space.tweedledum:create_index('primary',\n"
"       { type = 'TREE', parts = {1, 'unsigned'}})\n"
"end)"
msgstr ""
"#!/usr/bin/env tarantool\n"
"-- настроить базу данных\n"
"box.cfg {\n"
"   listen = 3301\n"
"}\n"
"box.once(\"bootstrap\", function()\n"
"   box.schema.space.create('tweedledum')\n"
"   box.space.tweedledum:create_index('primary',\n"
"       { type = 'TREE', parts = {1, 'unsigned'}})\n"
"end)"

#: ../doc/book/app_server/launching_app.rst:132
msgid "Now we launch our application in the same manner as before:"
msgstr "Далее запустим наше приложение, как делали ранее:"

#: ../doc/book/app_server/launching_app.rst:134
msgid ""
"$ tarantool myapp.lua\n"
"Hello, world!\n"
"2017-08-11 16:07:14.250 [41436] main/101/myapp.lua C> version "
"2.1.0-429-g4e5231702\n"
"2017-08-11 16:07:14.250 [41436] main/101/myapp.lua C> log level 5\n"
"2017-08-11 16:07:14.251 [41436] main/101/myapp.lua I> mapping 1073741824 "
"bytes for tuple arena...\n"
"2017-08-11 16:07:14.255 [41436] main/101/myapp.lua I> recovery start\n"
"2017-08-11 16:07:14.255 [41436] main/101/myapp.lua I> recovering from "
"`./00000000000000000000.snap'\n"
"2017-08-11 16:07:14.271 [41436] main/101/myapp.lua I> recover from "
"`./00000000000000000000.xlog'\n"
"2017-08-11 16:07:14.271 [41436] main/101/myapp.lua I> done "
"`./00000000000000000000.xlog'\n"
"2017-08-11 16:07:14.272 [41436] main/102/hot_standby I> recover from "
"`./00000000000000000000.xlog'\n"
"2017-08-11 16:07:14.274 [41436] iproto/102/iproto I> binary: started\n"
"2017-08-11 16:07:14.275 [41436] iproto/102/iproto I> binary: bound to "
"[::]:3301\n"
"2017-08-11 16:07:14.275 [41436] main/101/myapp.lua I> done "
"`./00000000000000000000.xlog'\n"
"2017-08-11 16:07:14.278 [41436] main/101/myapp.lua I> ready to accept "
"requests"
msgstr ""

#: ../doc/book/app_server/launching_app.rst:151
msgid ""
"This time, Tarantool executes our script and keeps working as a server, "
"accepting TCP requests on port 3301. We can see Tarantool in the current "
"session’s process list:"
msgstr ""
"На этот раз Tarantool выполняет скрипт и продолжает работать в качестве "
"сервера, принимая TCP-запросы на порт 3301. Можно увидеть Tarantool в "
"списке процессов текущей сессии:"

#: ../doc/book/app_server/launching_app.rst:155
msgid ""
"$ ps | grep \"tarantool\"\n"
"  PID TTY           TIME CMD\n"
"41608 ttys001       0:00.47 tarantool myapp.lua <running>"
msgstr ""
"$ ps | grep \"tarantool\"\n"
"  PID TTY           TIME CMD\n"
"41608 ttys001       0:00.47 tarantool myapp.lua <running>"

#: ../doc/book/app_server/launching_app.rst:161
msgid ""
"But the Tarantool instance will stop if we close the current terminal "
"window. To detach Tarantool and our application from the terminal window,"
" we can launch it in the **daemon mode**. To do so, we add some "
"parameters to ``box.cfg{}``:"
msgstr ""
"Однако экземпляр Tarantool'а завершит работу, если мы закроем окно "
"командной строки. Чтобы отделить Tarantool и приложение от окна командной"
" строки, можно запустить **режим демона**. Для этого добавим некоторые "
"параметры в ``box.cfg{}``:"

#: ../doc/book/app_server/launching_app.rst:165
msgid ""
":ref:`background <cfg_basic-background>` = ``true`` that actually tells "
"Tarantool to work as a daemon service,"
msgstr ""
":ref:`background <cfg_basic-background>` = ``true``, который собственно "
"заставит Tarantool работать в качестве демона,"

#: ../doc/book/app_server/launching_app.rst:167
msgid ""
":ref:`log <cfg_logging-log>` = ``'dir-name'`` that tells the Tarantool "
"daemon where to store its log file (other log settings are available in "
"Tarantool :ref:`log <log-module>` module), and"
msgstr ""
":ref:`log <cfg_logging-log>` = ``'dir-name'``, который укажет, где демон "
"Tarantool'а будет сохранять файл журнала (другие настройки журнала "
"находятся в модуле Tarantool'а :ref:`log <log-module>` module), а также"

#: ../doc/book/app_server/launching_app.rst:170
msgid ""
":ref:`pid_file <cfg_basic-pid_file>` = ``'file-name'`` that tells the "
"Tarantool daemon where to store its pid file."
msgstr ""
":ref:`pid_file <cfg_basic-pid_file>` = ``'file-name'``, который укажет, "
"где демон Tarantool'а будет сохранять файл журнала pid-файл."

#: ../doc/book/app_server/launching_app.rst:173
#: ../doc/book/box/engines/vinyl.rst:548
#: ../doc/book/cartridge/cartridge_admin.rst:147
#: ../doc/book/cartridge/cartridge_dev.rst:341
#: ../doc/book/cartridge/cartridge_dev.rst:1229
msgid "For example:"
msgstr "Например:"

#: ../doc/book/app_server/launching_app.rst:175
msgid ""
"box.cfg {\n"
"   listen = 3301,\n"
"   background = true,\n"
"   log = '1.log',\n"
"   pid_file = '1.pid'\n"
"}"
msgstr ""
"box.cfg {\n"
"   listen = 3301,\n"
"   background = true,\n"
"   log = '1.log',\n"
"   pid_file = '1.pid'\n"
"}"

#: ../doc/book/app_server/launching_app.rst:184
msgid "We launch our application in the same manner as before:"
msgstr "Запустим наше приложение, как делали ранее:"

#: ../doc/book/app_server/launching_app.rst:192
msgid ""
"Tarantool executes our script, gets detached from the current shell "
"session (you won't see it with ``ps | grep \"tarantool\"``) and continues"
" working in the background as a daemon attached to the global session "
"(with SID = 0):"
msgstr ""
"Tarantool выполняет наш скрипт, отделяется от текущей сессии (он не "
"отображается при вводе ``ps | grep \"tarantool\"``) и продолжает работать"
" в фоновом режиме в качестве демона, прикрепленного к общей сессии (с SID"
" = 0):"

#: ../doc/book/app_server/launching_app.rst:196
msgid ""
"$ ps -ef | grep \"tarantool\"\n"
"  PID SID     TIME  CMD\n"
"42178   0  0:00.72 tarantool myapp.lua <running>"
msgstr ""
"$ ps -ef | grep \"tarantool\"\n"
"  PID SID     TIME  CMD\n"
"42178   0  0:00.72 tarantool myapp.lua <running>"

#: ../doc/book/app_server/launching_app.rst:202
msgid ""
"Now that we have discussed how to create and launch a Lua application for"
" Tarantool, let's dive deeper into programming practices."
msgstr ""
"Рассмотрев создание и запуск Lua-приложения для Tarantool'а, перейдем к "
"углубленному изложению методик программирования."

#: ../doc/book/app_server/reloading_module.rst:5
msgid "Reloading a module"
msgstr "Перезагрузка модуля"

#: ../doc/book/app_server/reloading_module.rst:7
msgid "You can reload any Tarantool application or module with zero downtime."
msgstr ""
"Любое приложение или модуль Tarantool'а можно перезагрузить с нулевым "
"временем простоя."

#: ../doc/book/app_server/reloading_module.rst:13
msgid "Reloading a module in Lua"
msgstr "Перезагрузка модуля на Lua"

#: ../doc/book/app_server/reloading_module.rst:15
msgid ""
"Here's an example that illustrates the most typical case -- \"update and "
"reload\"."
msgstr ""
"Ниже представлен пример, который иллюстрирует наиболее типичный случай --"
" \"обновление и перезагрузка\"."

#: ../doc/book/app_server/reloading_module.rst:19
msgid ""
"In this example, we use recommended :ref:`administration practices "
"<admin>` based on :ref:`instance files <admin-instance_file>` and "
":ref:`tarantoolctl <tarantoolctl>` utility."
msgstr ""
"В этом примере используются рекомендованные :ref:`методики "
"администрирования <admin>` на основании :ref:`файлов экземпляров <admin-"
"instance_file>` и утилиты :ref:`tarantoolctl <tarantoolctl>`."

#: ../doc/book/app_server/reloading_module.rst:23
msgid "Update the application file."
msgstr "Обновите файлы приложения."

#: ../doc/book/app_server/reloading_module.rst:25
msgid "For example, a module in ``/usr/share/tarantool/app.lua``:"
msgstr "Например, модуль в ``/usr/share/tarantool/app.lua``:"

#: ../doc/book/app_server/reloading_module.rst:27
msgid ""
"local function start()\n"
"  -- initial version\n"
"  box.once(\"myapp:v1.0\", function()\n"
"    box.schema.space.create(\"somedata\")\n"
"    box.space.somedata:create_index(\"primary\")\n"
"    ...\n"
"  end)\n"
"\n"
"  -- migration code from 1.0 to 1.1\n"
"  box.once(\"myapp:v1.1\", function()\n"
"    box.space.somedata.index.primary:alter(...)\n"
"    ...\n"
"  end)\n"
"\n"
"  -- migration code from 1.1 to 1.2\n"
"  box.once(\"myapp:v1.2\", function()\n"
"    box.space.somedata.index.primary:alter(...)\n"
"    box.space.somedata:insert(...)\n"
"    ...\n"
"  end)\n"
"end\n"
"\n"
"-- start some background fibers if you need\n"
"\n"
"local function stop()\n"
"  -- stop all background fibers and clean up resources\n"
"end\n"
"\n"
"local function api_for_call(xxx)\n"
"  -- do some business\n"
"end\n"
"\n"
"return {\n"
"  start = start,\n"
"  stop = stop,\n"
"  api_for_call = api_for_call\n"
"}"
msgstr ""
"local function start()\n"
"  -- начальная версия\n"
"  box.once(\"myapp:v1.0\", function()\n"
"    box.schema.space.create(\"somedata\")\n"
"    box.space.somedata:create_index(\"primary\")\n"
"    ...\n"
"  end)\n"
"\n"
"  -- код миграции с 1.0 на 1.1\n"
"  box.once(\"myapp:v1.1\", function()\n"
"    box.space.somedata.index.primary:alter(...)\n"
"    ...\n"
"  end)\n"
"\n"
"  -- код миграции с 1.1 на 1.2\n"
"  box.once(\"myapp:v1.2\", function()\n"
"    box.space.somedata.index.primary:alter(...)\n"
"    box.space.somedata:insert(...)\n"
"    ...\n"
"  end)\n"
"end\n"
"\n"
"-- запустить файберы в фоновом режиме, если необходимо\n"
"\n"
"local function stop()\n"
"  -- остановить все файберы, работающие в фоновом режиме, и очистить "
"ресурсы\n"
"end\n"
"\n"
"local function api_for_call(xxx)\n"
"  -- сделать что-то\n"
"end\n"
"\n"
"return {\n"
"  start = start,\n"
"  stop = stop,\n"
"  api_for_call = api_for_call\n"
"}"

#: ../doc/book/app_server/reloading_module.rst:67
msgid "Update the :ref:`instance file <admin-instance_file>`."
msgstr "Обновить :ref:`файл экземпляра <admin-instance_file>`."

#: ../doc/book/app_server/reloading_module.rst:69
msgid "For example, ``/etc/tarantool/instances.enabled/my_app.lua``:"
msgstr "Например, ``/etc/tarantool/instances.enabled/my_app.lua``:"

#: ../doc/book/app_server/reloading_module.rst:71
msgid ""
"#!/usr/bin/env tarantool\n"
"--\n"
"-- hot code reload example\n"
"--\n"
"\n"
"box.cfg({listen = 3302})\n"
"\n"
"-- ATTENTION: unload it all properly!\n"
"local app = package.loaded['app']\n"
"if app ~= nil then\n"
"  -- stop the old application version\n"
"  app.stop()\n"
"  -- unload the application\n"
"  package.loaded['app'] = nil\n"
"  -- unload all dependencies\n"
"  package.loaded['somedep'] = nil\n"
"end\n"
"\n"
"-- load the application\n"
"log.info('require app')\n"
"app = require('app')\n"
"\n"
"-- start the application\n"
"app.start({some app options controlled by sysadmins})"
msgstr ""
"#!/usr/bin/env tarantool\n"
"--\n"
"-- пример горячей перезагрузки кода\n"
"--\n"
"\n"
"box.cfg({listen = 3302})\n"
"\n"
"-- ВНИМАНИЕ: правильно выполните разгрузку!\n"
"local app = package.loaded['app']\n"
"if app ~= nil then\n"
"  -- остановите старую версию приложения\n"
"  app.stop()\n"
"  -- разгрузите приложение\n"
"  package.loaded['app'] = nil\n"
"  -- разгрузите все зависимости\n"
"  package.loaded['somedep'] = nil\n"
"end\n"
"\n"
"-- загрузите приложение\n"
"log.info('require app')\n"
"app = require('app')\n"
"\n"
"-- запустите приложение\n"
"app.start({some app options controlled by sysadmins})"

#: ../doc/book/app_server/reloading_module.rst:98
msgid ""
"The important thing here is to properly unload the application and its "
"dependencies."
msgstr "Самое главное -- правильно разгрузить приложение и его зависимости."

#: ../doc/book/app_server/reloading_module.rst:101
msgid "Manually reload the application file."
msgstr "Вручную перезагрузите файл приложения."

#: ../doc/book/app_server/reloading_module.rst:103
msgid "For example, using ``tarantoolctl``:"
msgstr "Например, используя ``tarantoolctl``:"

#: ../doc/book/app_server/reloading_module.rst:105
msgid "$ tarantoolctl eval my_app /etc/tarantool/instances.enabled/my_app.lua"
msgstr "$ tarantoolctl eval my_app /etc/tarantool/instances.enabled/my_app.lua"

#: ../doc/book/app_server/reloading_module.rst:113
msgid "Reloading a module in C"
msgstr "Перезагрузка модуля на С"

#: ../doc/book/app_server/reloading_module.rst:115
msgid ""
"After you compiled a new version of a C module (``*.so`` shared library),"
" call :ref:`box.schema.func.reload('module-name') <box_schema-"
"func_reload>` from your Lua script to reload the module."
msgstr ""
"После компиляции новой версии модуля на C (библиотека общего пользования "
"``*.so``),  вызовите функцию :ref:`box.schema.func.reload('module-name') "
"<box_schema-func_reload>` из Lua-скрипта для перезагрузки модуля."

#: ../doc/book/app_server/using_ide.rst:5
msgid "Developing with an IDE"
msgstr "Разработка с IDE"

#: ../doc/book/app_server/using_ide.rst:7
msgid ""
"You can use IntelliJ IDEA as an IDE to develop and debug Lua applications"
" for Tarantool."
msgstr ""
"Для разработки и отладки Lua-приложений для Tarantool'а можно "
"использовать IntelliJ IDEA в качестве интегрированной среды разработки "
"(IDE)."

#: ../doc/book/app_server/using_ide.rst:10
msgid ""
"Download and install the IDE from the `official web-site "
"<https://www.jetbrains.com/idea/>`_."
msgstr ""
"Загрузите и установите IDE с `официального сайта "
"<https://www.jetbrains.com/idea/>`_."

#: ../doc/book/app_server/using_ide.rst:13
msgid ""
"JetBrains provides specialized editions for particular languages: "
"IntelliJ IDEA (Java), PHPStorm (PHP), PyCharm (Python), RubyMine (Ruby), "
"CLion (C/C++), WebStorm (Web) and others. So, download a version that "
"suits your primary programming language."
msgstr ""
"JetBrains предоставляет специализированные версии для разных языков "
"программирования: IntelliJ IDEA (Java), PHPStorm (PHP), PyCharm (Python),"
" RubyMine (Ruby), CLion (C/C++), WebStorm (Web) и другие. Поэтому "
"загрузите версию, которая подходит предпочитаемому языку."

#: ../doc/book/app_server/using_ide.rst:18
msgid "Tarantool integration is supported for all editions."
msgstr "Для всех версий поддерживается интеграция с Tarantool'ом."

#: ../doc/book/app_server/using_ide.rst:20
msgid "Configure the IDE:"
msgstr "Настройте IDE:"

#: ../doc/book/app_server/using_ide.rst:22
msgid "Start IntelliJ IDEA."
msgstr "Запустите IntelliJ IDEA."

#: ../doc/book/app_server/using_ide.rst:23
msgid "Click ``Configure`` button and select ``Plugins``."
msgstr "Нажмите кнопку ``Configure`` и выберите ``Plugins``."

#: ../doc/book/app_server/using_ide.rst:30
msgid "Click ``Browse repositories``."
msgstr "Нажмите ``Browse repositories``."

#: ../doc/book/app_server/using_ide.rst:37
msgid "Install ``EmmyLua`` plugin."
msgstr "Установите плагин ``EmmyLua``."

#: ../doc/book/app_server/using_ide.rst:41
msgid ""
"Please don’t be confused with ``Lua`` plugin, which is less powerful than"
" ``EmmyLua``."
msgstr ""
"Не путайте с плагином ``Lua``, у которого меньше возможностей, чем у "
"``EmmyLua``."

#: ../doc/book/app_server/using_ide.rst:49
msgid "Restart IntelliJ IDEA."
msgstr "Перезапустите IntelliJ IDEA."

#: ../doc/book/app_server/using_ide.rst:50
msgid ""
"Click ``Configure``, select ``Project Defaults`` and then ``Run "
"Configurations``."
msgstr ""
"Нажмите ``Configure``, выберите ``Project Defaults``, а затем ``Run "
"Configurations``."

#: ../doc/book/app_server/using_ide.rst:58
msgid "Find ``Lua Application`` in the sidebar at the left."
msgstr "Найдите ``Lua Application`` в боковой панели слева."

#: ../doc/book/app_server/using_ide.rst:60
msgid "In ``Program``, type a path to an installed ``tarantool`` binary."
msgstr "В ``Program`` введите путь к установленному бинарному файлу ``tarantool``."

#: ../doc/book/app_server/using_ide.rst:62
msgid ""
"By default, this is ``tarantool`` or ``/usr/bin/tarantool`` on most "
"platforms."
msgstr ""
"По умолчанию, это ``tarantool`` или ``/usr/bin/tarantool`` на большинстве"
" платформ."

#: ../doc/book/app_server/using_ide.rst:65
msgid ""
"If you installed ``tarantool`` from sources to a custom directory, please"
" specify the proper path here."
msgstr ""
"Если вы установили ``tarantool`` из источников в другую директорию, "
"укажите здесь правильный путь."

#: ../doc/book/app_server/using_ide.rst:73
msgid "Now IntelliJ IDEA is ready to use with Tarantool."
msgstr "Теперь IntelliJ IDEA можно использовать с Tarantool'ом."

#: ../doc/book/app_server/using_ide.rst:75
msgid "Create a new Lua project."
msgstr "Создайте новый проект на Lua."

#: ../doc/book/app_server/using_ide.rst:82
msgid "Add a new Lua file, for example ``init.lua``."
msgstr "Добавьте новый Lua-файл, например, ``init.lua``."

#: ../doc/book/app_server/using_ide.rst:89
msgid "Write your code, save the file."
msgstr "Разработайте код, сохраните файл."

#: ../doc/book/app_server/using_ide.rst:91
msgid ""
"To run you application, click ``Run -> Run`` in the main menu and select "
"your source file in the list."
msgstr ""
"Чтобы запустить приложение, нажмите ``Run -> Run`` в основном меню и "
"выберите исходный файл из списка."

#: ../doc/book/app_server/using_ide.rst:99
msgid "Or click ``Run -> Debug`` to start debugging."
msgstr "Или нажмите ``Run -> Debug`` для начала отладки."

#: ../doc/book/app_server/using_ide.rst:103
msgid ""
"To use Lua debugger, please upgrade Tarantool to version "
"1.7.5-29-gbb6170e4b or later."
msgstr ""
"Чтобы использовать Lua-отладчик, обновите Tarantool до версии "
"1.7.5-29-gbb6170e4b или более поздней версии."

#: ../doc/book/box/atomic.rst:5
msgid "Transaction control"
msgstr "Контроль транзакций"

#: ../doc/book/box/atomic.rst:7
msgid ""
"Transactions in Tarantool occur in **fibers** on a single **thread**. "
"That is why Tarantool has a guarantee of execution atomicity. That "
"requires emphasis."
msgstr ""
"Транзакции в Tarantool'е происходят в **файберах** в одном **потоке**. "
"Вот почему Tarantool дает гарантию атомарности выполнения. На этом "
"следует сделать акцент."

#: ../doc/book/box/atomic.rst:15
msgid "Threads, fibers and yields"
msgstr "Потоки, файберы и передача управления"

#: ../doc/book/box/atomic.rst:17
msgid ""
"How does Tarantool process a basic operation? As an example, let's take "
"this query:"
msgstr ""
"Как Tarantool выполняет основные операции? Для примера возьмем такой "
"запрос:"

#: ../doc/book/box/atomic.rst:20
msgid "tarantool> box.space.tester:update({3}, {{'=', 2, 'size'}, {'=', 3, 0}})"
msgstr "tarantool> box.space.tester:update({3}, {{'=', 2, 'size'}, {'=', 3, 0}})"

#: ../doc/book/box/atomic.rst:24
msgid ""
"This is equivalent to the following SQL statement for a table that stores"
" primary keys in ``field[1]``:"
msgstr ""
"Это эквивалентно следующему SQL-выражению (оно работает с таблицей, где "
"первичные ключи в ``field[1]``):"

#: ../doc/book/box/atomic.rst:27
msgid ""
"UPDATE tester SET \"field[2]\" = 'size', \"field[3]\" = 0 WHERE "
"\"field[1]\" = 3"
msgstr ""
"UPDATE tester SET \"field[2]\" = 'size', \"field[3]\" = 0 WHERE "
"\"field[1]\" = 3"

#: ../doc/book/box/atomic.rst:31
msgid "This query will be processed with three operating system **threads**:"
msgstr "Этот запрос будет обработан тремя **потоками** операционной системы:"

#: ../doc/book/box/atomic.rst:33
msgid ""
"If we issue the query on a remote client, then the **network thread** on "
"the server side receives the query, parses the statement and changes it "
"to a server executable message which has already been checked, and which "
"the server instance can understand without parsing everything again."
msgstr ""
"Если мы передадим запрос на удаленный клиент, **сетевой поток** на "
"стороне сервера получит запрос, разберет выражение и преобразует его в "
"выполняемое сообщение сервера, которое уже проверено. Такое сообщение "
"экземпляр сервера может понимать без повторного разбора."

#: ../doc/book/box/atomic.rst:38
msgid ""
"The network thread ships this message to the instance's **transaction "
"processor thread** using a lock-free message bus. Lua programs execute "
"directly in the transaction processor thread, and do not require parsing "
"and preparation."
msgstr ""
"Сетевой поток отправляет это сообщение в **поток обработки транзакций** с"
" помощью шины передачи сообщений без блокировок. Lua-программы "
"выполняются непосредственно в потоке обработки транзакций и не требуют "
"разбора и подготовки."

#: ../doc/book/box/atomic.rst:43
msgid ""
"The instance's transaction processor thread uses the primary-key index on"
" field[1] to find the location of the tuple. It determines that the tuple"
" can be updated (not much can go wrong when you're merely changing an "
"unindexed field value to something shorter)."
msgstr ""
"Поток обработки транзакций экземпляра использует индекс на поле "
"первичного ключа field[1], чтобы найти нужный кортеж. Он проверяет, что "
"данный кортеж можно обновить (мы хотим лишь изменить значение не "
"индексированного поля на более короткое, и вряд ли что-то пойдет не так)."

#: ../doc/book/box/atomic.rst:48
msgid ""
"The transaction processor thread sends a message to the :ref:`write-ahead"
" logging (WAL) thread <internals-wal>` to commit the transaction. When "
"done, the WAL thread replies with a COMMIT or ROLLBACK result, which is "
"returned to the client."
msgstr ""
"Поток обработки транзакций отправляет сообщение в :ref:`поток упреждающей"
" записи в журнал (WAL) <internals-wal>` для коммита транзакции. По "
"завершении поток WAL отправляет ответ с результатом COMMIT (коммит) или "
"ROLLBACK (откат) на клиент."

#: ../doc/book/box/atomic.rst:53
msgid ""
"Notice that there is only one transaction processor thread in Tarantool. "
"Some people are used to the idea that there can be multiple threads "
"operating on the database, with (say) thread #1 reading row #x, while "
"thread #2 writes row #y. With Tarantool, no such thing ever happens. Only"
" the transaction processor thread can access the database, and there is "
"only one transaction processor thread for each Tarantool instance."
msgstr ""
"Обратите внимание, что в Tarantool'е есть только один поток обработки "
"транзакций. Некоторые уже привыкли к мысли, что потоков для обработки "
"данных в базе данных может быть много (например, поток №1 читает данные "
"из строки №x, в то время как поток №2 записывает данные в столбец №y). В "
"случае с Tarantool'ом такого не происходит. Доступ к базе есть только у "
"потока обработки транзакций, и на  каждый экземпляр Tarantool'а есть "
"только один такой поток."

#: ../doc/book/box/atomic.rst:60
msgid ""
"Like any other Tarantool thread, the transaction processor thread can "
"handle many :ref:`fibers <fiber-fibers>`. A fiber is a set of computer "
"instructions that may contain \"**yield**\" signals. The transaction "
"processor thread will execute all computer instructions until a yield, "
"then switch to execute the instructions of a different fiber. Thus (say) "
"the thread reads row #x for the sake of fiber #1, then writes row #y for "
"the sake of fiber #2."
msgstr ""
"Как и любой другой поток Tarantool'а, поток обработки транзакций может "
"управлять множеством :ref:`файберов <fiber-fibers>`. Файбер -- это набор "
"команд, среди которых могут быть и сигналы \"**передачи управления**\". "
"Поток обработки транзакций выполняет все команды, пока не увидит такой "
"сигнал, и тогда он переключается на выполнение команд из другого файбера."
" Например, таким образом поток обработки транзакций сначала выполняет "
"чтение данных из строки №x для файбера №1, а затем выполняет запись в "
"строку №y для файбера №2."

#: ../doc/book/box/atomic.rst:67
msgid ""
"Yields must happen, otherwise the transaction processor thread would "
"stick permanently on the same fiber. There are two types of yields:"
msgstr ""
"Передача управления необходима, в противном случае, поток обработки "
"транзакции заклинит на одном файбере. Есть два типа передачи управления:"

#: ../doc/book/box/atomic.rst:70
msgid ""
":ref:`implicit yields <atomic-implicit-yields>`: every data-change "
"operation or network-access causes an implicit yield, and every statement"
" that goes through the Tarantool client causes an implicit yield."
msgstr ""
":ref:`неявная передача управления <atomic-implicit-yields>`: каждая "
"операция по изменению данных или доступ к сети вызывают неявную передачу "
"управления, а также каждое выражение, которое проходит через клиент "
"Tarantool'а, вызывает неявную передачу управления."

#: ../doc/book/box/atomic.rst:74
msgid ""
"explicit yields: in a Lua function, you can (and should) add "
":ref:`\"yield\" <fiber-yield>` statements to prevent hogging. This is "
"called **cooperative multitasking**."
msgstr ""
"явная передача управления: в Lua-функции можно (и нужно) добавить "
"выражения :ref:`\"передачи управления\" <fiber-yield>` для предотвращения"
" захвата ЦП. Это называется **кооперативной многозадачностью**."

#: ../doc/book/box/atomic.rst:82
msgid "Cooperative multitasking"
msgstr "Кооперативная многозадачность"

#: ../doc/book/box/atomic.rst:84
msgid ""
"Cooperative multitasking means: unless a running fiber deliberately "
"yields control, it is not preempted by some other fiber. But a running "
"fiber will deliberately yield when it encounters a “yield point”: a "
"transaction commit, an operating system call, or an explicit "
":ref:`\"yield\" <fiber-yield>` request. Any system call which can block "
"will be performed asynchronously, and any running fiber which must wait "
"for a system call will be preempted, so that another ready-to-run fiber "
"takes its place and becomes the new running fiber."
msgstr ""
"Кооперативная многозадачность означает, что если запущенный файбер "
"намеренно не передаст управление, он не вытесняется каким-либо другим "
"файбером. Но запущенный файбер намеренно передает управление, когда "
"обнаруживает “точку передачи управления”: коммит транзакции, вызов "
"операционной системы или запрос явной :ref:`\"передачи управления\" "
"<fiber-yield>`. Любой вызов системы, который может блокировать файбер, "
"будет производиться асинхронно, а запущенный файбер, который должен "
"ожидать системного вызова, будет вытеснен так, что другой готовый к "
"работе файбер занимает его место и становится запущенным файбером."

#: ../doc/book/box/atomic.rst:92
msgid ""
"This model makes all programmatic locks unnecessary: cooperative "
"multitasking ensures that there will be no concurrency around a resource,"
" no race conditions, and no memory consistency issues."
msgstr ""
"Эта модель исключает необходимость любых программных блокировок -- "
"кооперативная многозадачность обеспечивает отсутствие многопоточности "
"вокруг ресурса, состояния гонки и проблем с согласованностью данных."

#: ../doc/book/box/atomic.rst:96
msgid ""
"When requests are small, for example simple UPDATE or INSERT or DELETE or"
" SELECT, fiber scheduling is fair: it takes only a little time to process"
" the request, schedule a disk write, and yield to a fiber serving the "
"next client."
msgstr ""
"При небольших запросах, таких как простые UPDATE, INSERT, DELETE или "
"SELECT, происходит справедливое планирование файберов: немного времени "
"требуется на обработку запроса, планирование записи на диск и передачу "
"управления на файбер, обслуживающий следующего клиента."

#: ../doc/book/box/atomic.rst:100
msgid ""
"However, a function might perform complex computations or might be "
"written in such a way that yields do not occur for a long time. This can "
"lead to unfair scheduling, when a single client throttles the rest of the"
" system, or to apparent stalls in request processing. Avoiding this "
"situation is the responsibility of the function’s author."
msgstr ""
"Однако функция может выполнять сложные расчеты  или может быть написана "
"так, что управление не передается в течение длительного времени. Это "
"может привести к несправедливому планированию, когда отдельный клиент "
"перекрывает работу остальной системы, или к явным задержкам в обработке "
"запросов. Автору функции следует не допускать таких ситуаций."

#: ../doc/book/box/atomic.rst:110
msgid "Transactions"
msgstr "Транзакции"

#: ../doc/book/box/atomic.rst:112
msgid ""
"In the absence of transactions, any function that contains yield points "
"may see changes in the database state caused by fibers that preempt. "
"Multi-statement transactions exist to provide **isolation**: each "
"transaction sees a consistent database state and commits all its changes "
"atomically. At :ref:`commit <box-commit>` time, a yield happens and all "
"transaction changes are written to the :ref:`write ahead log <internals-"
"wal>` in a single batch. Or, if needed, transaction changes can be rolled"
" back -- :ref:`completely <box-rollback>` or to a specific "
":ref:`savepoint <box-rollback_to_savepoint>`."
msgstr ""
"В отсутствие транзакций любая функция, в которой есть точки передачи "
"управления, может видеть изменения в состоянии базы данных, вызванные "
"вытесняющими файберами. Составные транзакции предназначены для "
"**изоляции**: каждая транзакция видит постоянное состояние базы данных и "
"делает атомарные коммиты изменений. Во время :ref:`коммита <box-commit>` "
"происходит передача управления, а все транзакционные изменения "
"записываются в :ref:`журнал упреждающей записи <internals-wal>` в "
"отдельный пакет. Или, при необходимости, можно откатить изменения -- "
":ref:`полностью <box-rollback>` или на определенную :ref:`точку "
"сохранения <box-rollback_to_savepoint>`."

#: ../doc/book/box/atomic.rst:122
msgid ""
"To implement isolation, Tarantool uses a simple optimistic scheduler: the"
" first transaction to commit wins. If a concurrent active transaction has"
" read a value modified by a committed transaction, it is aborted."
msgstr ""
"Чтобы осуществить изоляцию, Tarantool использует простой планировщик с "
"оптимистичным управлением: транзакция подтверждена первой -- выигрывает. "
"Если параллельная активная транзакция читает значение, измененное "
"подтвержденной транзакцией, она прерывается."

#: ../doc/book/box/atomic.rst:126
msgid ""
"The cooperative scheduler ensures that, in absence of yields, a multi-"
"statement transaction is not preempted and hence is never aborted. "
"Therefore, understanding yields is essential to writing abort-free code."
msgstr ""
"Кооперативный планировщик обеспечивает, что в отсутствие передачи "
"управления составная транзакция не вытесняется, поэтому никогда не "
"прерывается. Таким образом, понимание передачи управления необходимо для "
"написания кода без прерываний."

#: ../doc/book/box/atomic.rst:132
msgid "You can’t mix storage engines in a transaction today."
msgstr "На сегодняшний день нельзя смешивать движки базы данных в транзакции."

#: ../doc/book/box/atomic.rst:138
msgid "Implicit yields"
msgstr "Правила неявной передачи управления"

#: ../doc/book/box/atomic.rst:140
msgid ""
"The only explicit yield requests in Tarantool are :ref:`fiber.sleep() "
"<fiber-sleep>` and :ref:`fiber.yield() <fiber-yield>`, but many other "
"requests \"imply\" yields because Tarantool is designed to avoid "
"blocking."
msgstr ""
"Единственные запросы явной передачи данных в Tarantool'е отправляют "
":ref:`fiber.sleep() <fiber-sleep>` и :ref:`fiber.yield() <fiber-yield>`, "
"но многие другие запросы \"неявно\" подразумевают передачу управления, "
"поскольку цель Tarantool'а -- избежать блокировок."

#: ../doc/book/box/atomic.rst:144
msgid ""
"Database requests imply yields if and only if there is disk I/O. For "
"memtx, since all data is in memory, there is no disk I/O during the "
"request. For vinyl, since some data may not be in memory, there may be "
"disk I/O for a read (to fetch data from disk) or for a write (because a "
"stall may occur while waiting for memory to be free). For both memtx and "
"vinyl, since data-change requests must be recorded in the WAL, there is "
"normally a commit. A commit happens automatically after every request in "
"default \"autocommit\" mode, or a commit happens at the end of a "
"transaction in \"transaction\" mode, when a user deliberately commits by "
"calling :ref:`box.commit() <box-commit>`. Therefore for both memtx and "
"vinyl, because there can be disk I/O, some database operations may imply "
"yields."
msgstr ""
"Запросы к базе данных подразумевают передачу управления исключительно при"
" вводе-выводе с диска. В memtx'е нет дискового ввода-вывода во время "
"запроса, поскольку все данные находятся в памяти. Что же касается "
"vinyl'а, то некоторых данных может не быть в памяти, поэтому для чтения "
"дисковый ввод-вывод может использоваться для чтения (для извлечения "
"данных с диска) или для записи (потому что в ожидании освобождения памяти"
" может произойти задержка). Как для memtx'а, так и для vinyl'а обычно "
"используются коммиты, поскольку запросы на изменение данных должны быть "
"записаны в WAL. В режиме автокоммита по умолчанию коммиты производятся "
"автоматически после каждого запроса. В режиме транзакций коммит "
"производится в конце транзакции, когда пользователь специально совершает "
"коммит, вызывая :ref:`box.commit() <box-commit>`. Поэтому как для "
"memtx'а, так и для vinyl'а некоторые операции с базой данных могут "
"вызывать передачу управления, поскольку может производиться дисковый "
"ввод-вывод."

#: ../doc/book/box/atomic.rst:157
msgid ""
"Many functions in modules :ref:`fio <fio-section>`, :ref:`net_box "
"<net_box-module>`, :ref:`console <console-module>` and :ref:`socket "
"<socket-module>` (the \"os\" and \"network\" requests) yield."
msgstr ""
"Многие функции в модулях :ref:`fio <fio-section>`, :ref:`net_box "
"<net_box-module>`, :ref:`console <console-module>` и :ref:`socket "
"<socket-module>` (запросы \"ОС\" и \"сети\") передают управление."

#: ../doc/book/box/atomic.rst:161 ../doc/book/box/box_session.rst:352
msgid "**Example #1**"
msgstr "**Пример №1**"

#: ../doc/book/box/atomic.rst:163
msgid ""
"*Engine = memtx* |br| ``select() insert()`` has one yield, at the end of "
"insertion, caused by implicit commit; ``select()`` has nothing to write "
"to the WAL and so does not yield."
msgstr ""
"*Движок = memtx* |br| В ``select() insert()`` управление передается один "
"раз в конце вставки, что вызвано неявным коммитом; ``select()`` ничего не"
" записывает в WAL-файл, поэтому не передает управление."

#: ../doc/book/box/atomic.rst:168
msgid ""
"*Engine = vinyl* |br| ``select() insert()`` has between one and three "
"yields, since ``select()`` may yield if the data is not in cache, "
"``insert()`` may yield waiting for available memory, and there is an "
"implicit yield at commit."
msgstr ""
"*Движок = vinyl* |br| В ``select() insert()`` управление передается от "
"одного до трех раз, поскольку ``select()`` может передавать управление, "
"если данные не находятся в кэше, ``insert()`` может передавать управление"
" в ожидании свободной памяти, а при коммите управление передается неявно."

#: ../doc/book/box/atomic.rst:173
msgid ""
"The sequence ``begin() insert() insert() commit()`` yields only at commit"
" if the engine is memtx, and can yield up to 3 times if the engine is "
"vinyl."
msgstr ""
"Последовательность ``begin() insert() insert() commit()`` передает "
"управление только при коммите, если движок -- memtx, и может передавать "
"управление до 3 раз, если движок -- vinyl."

#: ../doc/book/box/atomic.rst:176 ../doc/book/box/box_session.rst:361
msgid "**Example #2**"
msgstr "**Пример №2**"

#: ../doc/book/box/atomic.rst:178
msgid ""
"Assume that in space ‘tester’ there are tuples in which the third field "
"represents a positive dollar amount. Let's start a transaction, withdraw "
"from tuple#1, deposit in tuple#2, and end the transaction, making its "
"effects permanent."
msgstr ""
"Предположим, что в спейсе ‘tester’ существуют кортежи, третье поле "
"которых представляет собой положительную сумму в долларах. Начнем "
"транзакцию, снимем сумму из кортежа №1, внесем ее в кортеж №2 и завершим "
"транзакцию, подтверждая изменения."

#: ../doc/book/box/atomic.rst:183
msgid ""
"tarantool> function txn_example(from, to, amount_of_money)\n"
"         >   box.begin()\n"
"         >   box.space.tester:update(from, {{'-', 3, amount_of_money}})\n"
"         >   box.space.tester:update(to,   {{'+', 3, amount_of_money}})\n"
"         >   box.commit()\n"
"         >   return \"ok\"\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> txn_example({999}, {1000}, 1.00)\n"
"---\n"
"- \"ok\"\n"
"..."
msgstr ""
"tarantool> function txn_example(from, to, amount_of_money)\n"
"         >   box.begin()\n"
"         >   box.space.tester:update(from, {{'-', 3, amount_of_money}})\n"
"         >   box.space.tester:update(to,   {{'+', 3, amount_of_money}})\n"
"         >   box.commit()\n"
"         >   return \"ok\"\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> txn_example({999}, {1000}, 1.00)\n"
"---\n"
"- \"ok\"\n"
"..."

#: ../doc/book/box/atomic.rst:199
msgid ""
"If :ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>` = ‘none’, then"
" implicit yielding at commit time does not take place, because there are "
"no writes to the WAL."
msgstr ""
"Если :ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>` = ‘none’, то"
" при коммите управление не передается неявно, потому что не идет запись в"
" WAL-файл."

#: ../doc/book/box/atomic.rst:203
msgid ""
"If a task is interactive -- sending requests to the server and receiving "
"responses -- then it involves network IO, and therefore there is an "
"implicit yield, even if the request that is sent to the server is not "
"itself an implicit yield request. Therefore, the sequence:"
msgstr ""
"Если задача интерактивная -- отправка запроса на сервер и получение "
"ответа -- то она включает в себя сетевой ввод-вывод, поэтому наблюдается "
"неявная передача управления, даже если отправляемый на сервер запрос не "
"представляет собой запрос с неявной передачей управления. Таким образом, "
"последовательность:"

#: ../doc/book/box/atomic.rst:245
msgid ""
"select\n"
"select\n"
"select"
msgstr ""
"select\n"
"select\n"
"select"

#: ../doc/book/box/atomic.rst:215
msgid ""
"causes blocking (in memtx), if it is inside a function or Lua program "
"being executed on the server instance, but causes yielding (in both memtx"
" and vinyl) if it is done as a series of transmissions from a client, "
"including a client which operates via telnet, via one of the connectors, "
"or via the :ref:`MySQL and PostgreSQL rocks <dbms_modules>`, or via the "
"interactive mode when :ref:`using Tarantool as a client <admin-"
"using_tarantool_as_a_client>`."
msgstr ""
"приводит к блокировке (в memtx'е), если находится внутри функции или "
"Lua-программы, которая выполняется на экземпляре сервера. Однако она "
"вызывает передачу управления (и в memtx'е, и в vinyl'е), если выполняется"
" как серия передач от клиента, включая клиентов, работающих по telnet, по"
" одному из коннекторов или :ref:`модулей MySQL и PostgreSQL "
"<dbms_modules>` или в интерактивном режиме при :ref:`использовании "
"Tarantool'а как клиента <admin-using_tarantool_as_a_client>`."

#: ../doc/book/box/atomic.rst:222
msgid ""
"After a fiber has yielded and then has regained control, it immediately "
"issues :ref:`testcancel <fiber-testcancel>`."
msgstr ""
"После того, как файбер передал управление, а затем вернул его, он "
"незамедлительно вызывает :ref:`testcancel <fiber-testcancel>`."

#: ../doc/book/box/authentication.rst:5
msgid "Access control"
msgstr "Управление доступом"

#: ../doc/book/box/authentication.rst:7
msgid ""
"Understanding security details is primarily an issue for administrators. "
"However, ordinary users should at least skim this section to get an idea "
"of how Tarantool makes it possible for administrators to prevent "
"unauthorized access to the database and to certain functions."
msgstr ""
"В основном администраторы занимаются вопросами настроек безопасности. "
"Однако обычные пользователи должны хотя бы бегло прочитать этот раздел, "
"чтобы понять, как Tarantool позволяет администраторам не допустить "
"неавторизованный доступ к базе данных и некоторым функциям."

#: ../doc/book/box/authentication.rst:12
msgid "Briefly:"
msgstr "Вкратце:"

#: ../doc/book/box/authentication.rst:14
msgid ""
"There is a method to guarantee with password checks that users really are"
" who they say they are (“authentication”)."
msgstr ""
"Существует метод, который с помощью паролей проверяет, что пользователи "
"являются теми, за кого себя выдают (“аутентификация”)."

#: ../doc/book/box/authentication.rst:17
msgid ""
"There is a :ref:`_user <box_space-user>` system space, where usernames "
"and password-hashes are stored."
msgstr ""
"Существует системный спейс :ref:`_user <box_space-user>`, где хранятся "
"имена пользователей и хеши паролей."

#: ../doc/book/box/authentication.rst:20
msgid ""
"There are functions for saying that certain users are allowed to do "
"certain things (“privileges”)."
msgstr ""
"Существуют функции, чтобы дать определенным пользователям право совершать"
" определенные действия (“права”)."

#: ../doc/book/box/authentication.rst:23
msgid ""
"There is a :ref:`_priv <box_space-priv>` system space, where privileges "
"are stored. Whenever a user tries to do an operation, there is a check "
"whether the user has the privilege to do the operation (“access "
"control”)."
msgstr ""
"Существует системный спейс :ref:`_priv <box_space-priv>`, где хранятся "
"права. Когда пользователь пытается выполнить операцию, проводится "
"проверка на наличие у него прав на выполнение такой операции (“управление"
" доступом”)."

#: ../doc/book/box/authentication.rst:27
msgid "Details follow."
msgstr "Подробная информация приводится ниже."

#: ../doc/book/box/authentication.rst:33
msgid "Users"
msgstr "Пользователи"

#: ../doc/book/box/authentication.rst:35
msgid ""
"There is a **current user** for any program working with Tarantool, local"
" or remote. If a remote connection is using a :ref:`binary port <admin-"
"security>`, the current user, by default, is '**guest**'. If the "
"connection is using an :ref:`admin-console port <admin-security>`, the "
"current user is '**admin**'. When executing a :ref:`Lua initialization "
"script <index-init_label>`, the current user is also ‘**admin**’."
msgstr ""
"Для любой локальной или удаленной программы, работающей с Tarantool'ом, "
"есть **текущий пользователь**. Если удаленное соединение использует "
":ref:`бинарный порт <admin-security>`, то текущим пользователем, по "
"умолчанию, будет '**guest**' (гость). Если соединение использует "
":ref:`порт для административной консоли <admin-security>`, текущим "
"пользователем будет '**admin**' (администратор). При выполнении "
":ref:`скрипта инициализации на Lua <index-init_label>`, текущим "
"пользователем также будет ‘**admin**’."

#: ../doc/book/box/authentication.rst:44
msgid ""
"The current user name can be found with :ref:`box.session.user() "
"<box_session-user>`."
msgstr ""
"Имя текущего пользователя можно узнать с помощью :ref:`box.session.user()"
" <box_session-user>`."

#: ../doc/book/box/authentication.rst:46
msgid "The current user can be changed:"
msgstr "Текущего пользователя можно изменить:"

#: ../doc/book/box/authentication.rst:48
msgid ""
"For a binary port connection -- with the :ref:`AUTH protocol command "
"<box_protocol-iproto_protocol>`, supported by most clients;"
msgstr ""
"Для соединения по бинарному порту -- с помощью :ref:`команды протокола "
"AUTH <box_protocol-iproto_protocol>`, которая поддерживается большинством"
" клиентов;"

#: ../doc/book/box/authentication.rst:52
msgid ""
"For an admin-console connection and in a Lua initialization script -- "
"with :ref:`box.session.su <box_session-su>`;"
msgstr ""
"Для соединения по порту для административной консоли и при выполнении "
"скрипта инициализации на Lua -- с помощью :ref:`box.session.su "
"<box_session-su>`;"

#: ../doc/book/box/authentication.rst:55
msgid ""
"For a binary-port connection invoking a stored function with the CALL "
"command -- if the :ref:`SETUID <box_schema-func_create>` property is "
"enabled for the function, Tarantool temporarily replaces the current user"
" with the function’s creator, with all the creator's privileges, during "
"function execution."
msgstr ""
"Для соединения по бинарному порту, которое вызывает хранимую функцию с "
"помощью команды CALL -- если для функции включена настройка :ref:`SETUID "
"<box_schema-func_create>`, Tarantool временно заменит текущего "
"пользователя на создателя функции со всеми правами создателя во время "
"выполнения функции."

#: ../doc/book/box/authentication.rst:64
msgid "Passwords"
msgstr "Пароли"

#: ../doc/book/box/authentication.rst:66
msgid ""
"Each user (except 'guest') may have a **password**. The password is any "
"alphanumeric string."
msgstr ""
"У каждого пользователя (за исключением гостя 'guest') может быть "
"**пароль**. Паролем является любая буквенно-цифровая строка."

#: ../doc/book/box/authentication.rst:69
#, python-format
msgid ""
"Tarantool passwords are stored in the :ref:`_user <box_space-user>` "
"system space with a `cryptographic hash function "
"<https://en.wikipedia.org/wiki/Cryptographic_hash_function>`_ so that, if"
" the password is ‘x’, the stored hash-password is a long string like "
"‘lL3OvhkIPOKh+Vn9Avlkx69M/Ck=‘. When a client connects to a Tarantool "
"instance, the instance sends a random `salt value "
"<https://en.wikipedia.org/wiki/Salt_%28cryptography%29>`_ which the "
"client must mix with the hashed-password before sending to the instance. "
"Thus the original value ‘x’ is never stored anywhere except in the user’s"
" head, and the hashed value is never passed down a network wire except "
"when mixed with a random salt."
msgstr ""
"Пароли Tarantool'а хранятся в системном спейсе :ref:`_user <box_space-"
"user>` с `криптографической хеш-функцией "
"<https://ru.wikipedia.org/wiki/%D0%9A%D1%80%D0%B8%D0%BF%D1%82%D0%BE%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D1%85%D0%B5%D1%88-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F>`_,"
" так что если паролем является ‘x’, хранится хеш-пароль в виде длинной "
"строки, например ‘lL3OvhkIPOKh+Vn9Avlkx69M/Ck=‘. Когда клиент "
"подключается к экземпляру Tarantool'а, экземпляр отправляет случайное "
"`значение соль "
"<https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D0%BB%D1%8C_(%D0%BA%D1%80%D0%B8%D0%BF%D1%82%D0%BE%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D1%8F)>`_,"
" которое клиент должен сложить вместе с хеш-паролем перед отправкой на "
"экземпляр. Таким образом, изначальное значение ‘x’ никогда не хранится "
"нигде, кроме как в голове самого пользователя, а хешированное значение "
"никогда не передается по сети, кроме как в смешанном с солью виде."

#: ../doc/book/box/authentication.rst:83
#, fuzzy
msgid ""
"For more details of the password hashing algorithm (e.g. for the purpose "
"of writing a new client application), read the `scramble.h "
"<https://github.com/tarantool/tarantool/blob/2.1/src/scramble.h>`_ header"
" file."
msgstr ""
"Для получения дополнительной информации об алгоритме хеширования паролей "
"(например, для написания нового клиентского приложения), прочтите файл "
"заголовка `scramble.h <https://github.com/tarantool/tarantool/blob/1.9/ "
"src/scramble.h>`_."

#: ../doc/book/box/authentication.rst:88
msgid ""
"This system prevents malicious onlookers from finding passwords by "
"snooping in the log files or snooping on the wire. It is the same system "
"that `MySQL introduced several years ago "
"<http://dev.mysql.com/doc/refman/5.7/en/password-hashing.html>`_, which "
"has proved adequate for medium-security installations. Nevertheless, "
"administrators should warn users that no system is foolproof against "
"determined long-term attacks, so passwords should be guarded and changed "
"occasionally. Administrators should also advise users to choose long "
"unobvious passwords, but it is ultimately up to the users to choose or "
"change their own passwords."
msgstr ""
"Система не дает злоумышленнику определить пароли путем просмотра файлов "
"журнала или слежения за активностью. Это та же система, `несколько лет "
"назад внедренная в MySQL <http://dev.mysql.com/doc/refman/5.7/en"
"/password-hashing.html>`_, которой оказалось достаточно для объектов со "
"средней степенью безопасности. Тем не менее, администраторы должны "
"предупреждать пользователей, что никакая система не защищена полностью от"
" постоянных длительных атак, поэтому пароли следует охранять и "
"периодически изменять. Администраторы также должны рекомендовать "
"пользователям выбирать длинные неочевидные пароли, но сами пользователи "
"выбирают свои пароли и изменяют их."

#: ../doc/book/box/authentication.rst:98
msgid ""
"There are two functions for managing passwords in Tarantool: "
":ref:`box.schema.user.passwd() <box_schema-user_passwd>` for changing a "
"user's password and :ref:`box.schema.user.password() <box_schema-"
"user_password>` for getting a hash of a user's password."
msgstr ""
"Для управления паролями в Tarantool'е есть две функции: "
":ref:`box.schema.user.passwd() <box_schema-user_passwd>` для изменения "
"пароля пользователя и :ref:`box.schema.user.password() <box_schema-"
"user_password>` для получения хеша пароля пользователя."

#: ../doc/book/box/authentication.rst:107
msgid "Owners and privileges"
msgstr "Владельцы и права"

#: ../doc/book/box/authentication.rst:109
msgid ""
"Tarantool has one database. It may be called \"box.schema\" or "
"\"universe\". The database contains database objects, including spaces, "
"indexes, users, roles, sequences, and functions."
msgstr ""
"В Tarantool'е одна база данных. Она может называться \"box.schema\" или "
"\"universe\". База данных содержит объекты базы данных, включая спейсы, "
"индексы, пользователей, роли, последовательности и функции."

#: ../doc/book/box/authentication.rst:113
msgid ""
"The **owner** of a database object is the user who created it. The owner "
"of the database itself, and the owner of objects that are created "
"initially (the system spaces and the default users) is '**admin**'."
msgstr ""
"**Владелец** объекта базы данных -- это пользователь, который создал его."
" Владельцем самой базы данных и объектов, которые изначально были созданы"
" (системные спейсы и пользователи по умолчанию) является '**admin**'."

#: ../doc/book/box/authentication.rst:118
msgid ""
"Owners automatically have **privileges** for what they create. They can "
"share these privileges with other users or with roles, using "
"**box.schema.user.grant** requests. The following privileges can be "
"granted:"
msgstr ""
"У владельцев автоматически есть **права** на то, что они создают. "
"Владельцы могут поделиться этими правами с другими пользователями или "
"ролями с помощью запросов **box.schema.user.grant**. Можно предоставить "
"следующие права:"

#: ../doc/book/box/authentication.rst:123
msgid "'read', e.g. allow select from a space"
msgstr "'read' (чтение), например, разрешить выборку из спейса"

#: ../doc/book/box/authentication.rst:124
msgid "'write', e.g. allow update on a space"
msgstr "'write' (запись), например, разрешить обновление спейса"

#: ../doc/book/box/authentication.rst:125
msgid ""
"'execute', e.g. allow call of a function, or (less commonly) allow use of"
" a role"
msgstr ""
"'execute' (выполнение), например, разрешить вызов функции, или (реже) "
"разрешить использование роли"

#: ../doc/book/box/authentication.rst:126
msgid ""
"'create', e.g. allow :ref:`box.schema.space.create <box_schema-"
"space_create>` (access to certain system spaces is also necessary)"
msgstr ""
"'create' (создание), например, разрешить выполнение "
":ref:`box.schema.space.create <box_schema-space_create>` (также необходим"
" доступ к определенным системным спейсам)"

#: ../doc/book/box/authentication.rst:129
msgid ""
"'alter', e.g. allow :ref:`box.space.x.index.y:alter <box_index-alter>` "
"(access to certain system spaces is also necessary)"
msgstr ""
"'alter' (изменение), например, разрешить выполнение "
":ref:`box.space.x.index.y:alter <box_index-alter>` (также необходим "
"доступ к определенным системным спейсам"

#: ../doc/book/box/authentication.rst:132
msgid ""
"'drop', e.g. allow :ref:`box.sequence.x:drop <box_schema-sequence_drop>` "
"(currently this can be granted but has no effect)"
msgstr ""
"'drop' (удаление), например, разрешить выполнение "
":ref:`box.sequence.x:drop <box_schema-sequence_drop>` (сейчас можно "
"настроить такие права, но они не действуют)"

#: ../doc/book/box/authentication.rst:135
msgid ""
"'usage', e.g. whether any action is allowable regardless of other "
"privileges (sometimes revoking 'usage' is a convenient way to block a "
"user temporarily without dropping the user)"
msgstr ""
"'usage' (использование), например, допустимо ли любое действие, несмотря "
"на другие права (иногда удобно отменить право на использование, чтобы "
"временно заблокировать пользователя, не удаляя ег"

#: ../doc/book/box/authentication.rst:138
msgid "'session', e.g. whether the user can 'connect'."
msgstr ""
"'session' (сессия), например, может ли пользователь выполнить подключение"
" 'connect'."

#: ../doc/book/box/authentication.rst:140
msgid ""
"To **create** objects, users need the 'create' privilege and at least "
"'read' and 'write' privileges on the system space with a similar name "
"(for example, on the :ref:`_space <box_space-space>` if the user needs to"
" create spaces)."
msgstr ""
"Чтобы **создавать** объекты, у пользователей должны быть права на "
"создание 'create' и хотя бы права на чтение 'read' и запись 'write' в "
"системный спейс с похожим именем (например, на спейс :ref:`_space "
"<box_space-space>`, если пользователю необходимо создавать спейсы."

#: ../doc/book/box/authentication.rst:145
msgid ""
"To **access** objects, users need an appropriate privilege on the object "
"(for example, the 'execute' privilege on function F if the users need to "
"execute function F). See below some :ref:`examples for granting specific "
"privileges <authentication-owners_privileges-examples-specific>` that a "
"grantor -- that is, 'admin' or the object creator -- can make."
msgstr ""
"Чтобы **получать доступ** к объектам, у пользователей должны быть "
"соответствующие права на объект (например, права на выполнение 'execute' "
"на функцию F, если пользователям необходимо выполнить функцию F). См. "
"ниже некоторые :ref:`примеры предоставления определенных прав "
"<authentication-owners_privileges-examples-specific>`, которые может "
"выдать 'admin' или создатель объекта."

#: ../doc/book/box/authentication.rst:151
msgid ""
"To **drop** an object, users must be the object's creator or be 'admin'. "
"As the owner of the entire database, 'admin' can drop any object "
"including other users."
msgstr ""
"Чтобы **удалить** объект, пользователь должен быть создателем объекта или"
" 'admin'. Как владелец всей базы данных, 'admin' может удалить любой "
"объект, в том числе других пользователей."

#: ../doc/book/box/authentication.rst:155
msgid ""
"To grant privileges to a user, the object owner says :ref:`grant() "
"<box_schema-user_grant>`. To revoke privileges from a user, the object "
"owner says :ref:`revoke() <box_schema-user_revoke>`. In either case, "
"there are up to five parameters:"
msgstr ""
"Чтобы предоставить права пользователю, владелец объекта выполняет команду"
" :ref:`grant() <box_schema-user_grant>`. Чтобы отменить права "
"пользователя, владелец объекта выполняет команду :ref:`revoke() "
"<box_schema-user_revoke>`. В любом случае можно использовать до пяти "
"параметров:"

#: ../doc/book/box/authentication.rst:159
msgid "(user-name, privilege, object-type [, object-name [, options]])"
msgstr "(user-name, privilege, object-type [, object-name [, options]])"

#: ../doc/book/box/authentication.rst:163
msgid ""
"``user-name`` is the user (or role) that will receive or lose the "
"privilege;"
msgstr ""
"``user-name`` -- это пользователь (или роль), который получит или "
"потеряет права;"

#: ../doc/book/box/authentication.rst:164
msgid ""
"``privilege`` is any of 'read', 'write', 'execute', 'create', 'alter', "
"'drop', 'usage', or 'session' (or a comma-separated list);"
msgstr ""
"``privilege`` -- это тип прав: 'read', 'write', 'execute', 'create', "
"'alter', 'drop', 'usage' или 'session' (или список прав, разделенных "
"запятыми);"

#: ../doc/book/box/authentication.rst:166
msgid ""
"``object-type`` is any of 'space', 'index', 'sequence', 'function', role-"
"name, or 'universe';"
msgstr ""
"``object-type`` -- это любой тип объекта: 'space' (спейс), 'index' "
"(индекс), 'sequence' (последовательность), 'function' (функция), имя роли"
" или 'universe';"

#: ../doc/book/box/authentication.rst:168
msgid ""
"``object-name`` is what the privilege is for (omitted if ``object-type`` "
"is 'universe');"
msgstr ""
"``object-name`` -- это то, на что распространяются права (не указывается,"
" если ``object-type`` = 'universe');"

#: ../doc/book/box/authentication.rst:170
msgid ""
"``options`` is a list inside braces for example "
"``{if_not_exists=true|false}`` (usually omitted because the default is "
"acceptable)."
msgstr ""
"``options`` -- это список параметров, приведенный в скобках, например, "
"``{if_not_exists=true|false}`` (как правило, не указывается, поскольку "
"допускаются значения по умолчанию)."

#: ../doc/book/box/authentication.rst:173
msgid "**Example for granting many privileges at once**"
msgstr "**Пример предоставления нескольких типов прав одновременно**"

#: ../doc/book/box/authentication.rst:175
msgid ""
"In this example user 'admin' grants many privileges on many objects to "
"user 'U', with a single request."
msgstr ""
"В данном примере пользователь 'admin' выдает много типов прав на "
"множество объектов пользователю 'U' в едином запросе."

#: ../doc/book/box/authentication.rst:178
msgid "box.schema.user.grant('U','read,write,execute,create,drop','universe')"
msgstr "box.schema.user.grant('U','read,write,execute,create,drop','universe')"

#: ../doc/book/box/authentication.rst:184
msgid "**Examples for granting privileges for specific operations**"
msgstr "**Примеры предоставления прав на определенные действия**"

#: ../doc/book/box/authentication.rst:186
msgid ""
"In these examples the object's creator grants precisely the minimal "
"privileges necessary for particular operations, to user 'U'."
msgstr ""
"В данных примерах создатель объекта выдает пользователю 'U' минимально "
"необходимые права на определенные действия."

#: ../doc/book/box/authentication.rst:190
msgid ""
"-- So that 'U' can create spaces:\n"
"  box.schema.user.grant('U','create','universe')\n"
"  box.schema.user.grant('U','write', 'space', '_schema')\n"
"  box.schema.user.grant('U','write', 'space', '_space')\n"
"-- So that 'U' can  create indexes (assuming 'U' created the space)\n"
"  box.schema.user.grant('U','read', 'space', '_space')\n"
"  box.schema.user.grant('U','read,write', 'space', '_index')\n"
"-- So that 'U' can  create indexes on space T (assuming 'U' did not "
"create space T)\n"
"  box.schema.user.grant('U','create','space','T')\n"
"  box.schema.user.grant('U','read', 'space', '_space')\n"
"  box.schema.user.grant('U','write', 'space', '_index')\n"
"-- So that 'U' can  alter indexes on space T (assuming 'U' did not create"
" the index)\n"
"  box.schema.user.grant('U','alter','space','T')\n"
"  box.schema.user.grant('U','read','space','_space')\n"
"  box.schema.user.grant('U','read','space','_index')\n"
"  box.schema.user.grant('U','read','space','_space_sequence')\n"
"  box.schema.user.grant('U','write','space','_index')\n"
"-- So that 'U' can create users or roles:\n"
"  box.schema.user.grant('U','create','universe')\n"
"  box.schema.user.grant('U','read,write', 'space', '_user')\n"
"  box.schema.user.grant('U','write','space', '_priv')\n"
"-- So that 'U' can create sequences:\n"
"  box.schema.user.grant('U','create','universe')\n"
"  box.schema.user.grant('U','read,write','space','_sequence')\n"
"-- So that 'U' can create functions:\n"
"  box.schema.user.grant('U','create','universe')\n"
"  box.schema.user.grant('U','read,write','space','_func')\n"
"-- So that 'U' can grant access on objects that 'U' created\n"
"  box.schema.user.grant('U','read','space','_user')\n"
"-- So that 'U' can select or get from a space named 'T'\n"
"  box.schema.user.grant('U','read','space','T')\n"
"-- So that 'U' can update or insert or delete or truncate a space named "
"'T'\n"
"  box.schema.user.grant('U','write','space','T')\n"
"-- So that 'U' can execute a function named 'F'\n"
"  box.schema.user.grant('U','execute','function','F')\n"
"-- So that 'U' can use the \"S:next()\" function with a sequence named S\n"
"  box.schema.user.grant('U','read,write','sequence','S')\n"
"-- So that 'U' can use the \"S:set()\" or \"S:reset() function with a "
"sequence named S\n"
"  box.schema.user.grant('U','write','sequence','S')"
msgstr ""
"-- Чтобы 'U' мог создавать спейсы:\n"
"   box.schema.user.grant('U','create','universe')\n"
"   box.schema.user.grant('U','write', 'space', '_schema')\n"
"   box.schema.user.grant('U','write', 'space', '_space')\n"
"-- Чтобы 'U' мог создавать индексы (подразумевая, что 'U' создал спейс)\n"
"   box.schema.user.grant('U','read', 'space', '_space')\n"
"   box.schema.user.grant('U','read,write', 'space', '_index')\n"
"-- Чтобы 'U' мог создавать индексы в спейсы T (подразумевая, что 'U' не "
"создал спейс T)\n"
"   box.schema.user.grant('U','create','space','T')\n"
"   box.schema.user.grant('U','read', 'space', '_space')\n"
"   box.schema.user.grant('U','write', 'space', '_index')\n"
"-- Чтобы 'U' мог изменять индексы в спейсе T (подразумевая, что 'U' не "
"создал индекс)\n"
"   box.schema.user.grant('U','alter','space','T')\n"
"   box.schema.user.grant('U','read','space','_space')\n"
"   box.schema.user.grant('U','read','space','_index')\n"
"   box.schema.user.grant('U','read','space','_space_sequence')\n"
"   box.schema.user.grant('U','write','space','_index')\n"
"-- Чтобы 'U' мог создавать пользователей или роли:\n"
"   box.schema.user.grant('U','create','universe')\n"
"   box.schema.user.grant('U','read,write', 'space', '_user')\n"
"   box.schema.user.grant('U','write','space', '_priv')\n"
"-- Чтобы 'U' мог создавать последовательности:\n"
"   box.schema.user.grant('U','create','universe')\n"
"   box.schema.user.grant('U','read,write','space','_sequence')\n"
"-- Чтобы 'U' мог создавать функции:\n"
"   box.schema.user.grant('U','create','universe')\n"
"   box.schema.user.grant('U','read,write','space','_func')\n"
"-- Чтобы 'U' мог выдавать права на созданные им объекты:\n"
"   box.schema.user.grant('U','read','space','_user')\n"
"-- Чтобы 'U' мог производить выборку или получать данные из спейса под "
"названием 'T'\n"
"   box.schema.user.grant('U','read','space','T')\n"
"-- Чтобы 'U' мог производить обновление, вставку, удаление или очистку "
"спейса под названием 'T'\n"
"   box.schema.user.grant('U','write','space','T')\n"
"-- Чтобы 'U' мог выполнять функцию под названием 'F'\n"
"   box.schema.user.grant('U','execute','function','F')\n"
"-- Чтобы 'U' мог использовать функцию \"S:next()\" для последовательности"
" под названием S\n"
"   box.schema.user.grant('U','read,write','sequence','S')\n"
"-- Чтобы 'U' мог использовать функцию \"S:set()\" или \"S:reset()\" для "
"последовательности под названием S\n"
"  box.schema.user.grant('U','write','sequence','S')"

#: ../doc/book/box/authentication.rst:232
msgid "**Example for creating users and objects then granting privileges**"
msgstr "**Пример создания пользователей и объектов и последующей выдачи прав**"

#: ../doc/book/box/authentication.rst:234
msgid ""
"Here we create a Lua function that will be executed under the user id of "
"its creator, even if called by another user."
msgstr ""
"Здесь создадим Lua-функциб, которая будет выполняться от ID пользователя,"
" который является ее создателем, даже если она вызывается другим "
"пользователем."

#: ../doc/book/box/authentication.rst:237
msgid ""
"First, we create two spaces ('u' and 'i') and grant a no-password user "
"('internal') full access to them. Then we define a function "
"('read_and_modify') and the no-password user becomes this function's "
"creator. Finally, we grant another user ('public_user') access to execute"
" Lua functions created by the no-password user."
msgstr ""
"Для начала создадим два спейса ('u' и 'i') и дадим полный доступ к ним "
"пользователю без пароля ('internal'). Затем определим функцию "
"('read_and_modify'), и пользователь без пароля становится создателем "
"функции. Наконец, дадим другому пользователю ('public_user') доступ на "
"выполнение Lua-функций, созданных пользователем без пароля."

#: ../doc/book/box/authentication.rst:242
msgid ""
"box.schema.space.create('u')\n"
"box.schema.space.create('i')\n"
"box.space.u:create_index('pk')\n"
"box.space.i:create_index('pk')\n"
"\n"
"box.schema.user.create('internal')\n"
"\n"
"box.schema.user.grant('internal', 'read,write', 'space', 'u')\n"
"box.schema.user.grant('internal', 'read,write', 'space', 'i')\n"
"box.schema.user.grant('internal', 'create', 'universe')\n"
"box.schema.user.grant('internal', 'read,write', 'space', '_func')\n"
"\n"
"function read_and_modify(key)\n"
"  local u = box.space.u\n"
"  local i = box.space.i\n"
"  local fiber = require('fiber')\n"
"  local t = u:get{key}\n"
"  if t ~= nil then\n"
"    u:put{key, box.session.uid()}\n"
"    i:put{key, fiber.time()}\n"
"  end\n"
"end\n"
"\n"
"box.session.su('internal')\n"
"box.schema.func.create('read_and_modify', {setuid= true})\n"
"box.session.su('admin')\n"
"box.schema.user.create('public_user', {password = 'secret'})\n"
"box.schema.user.grant('public_user', 'execute', 'function', "
"'read_and_modify')"
msgstr ""
"box.schema.space.create('u')\n"
"box.schema.space.create('i')\n"
"box.space.u:create_index('pk')\n"
"box.space.i:create_index('pk')\n"
"\n"
"box.schema.user.create('internal')\n"
"\n"
"box.schema.user.grant('internal', 'read,write', 'space', 'u')\n"
"box.schema.user.grant('internal', 'read,write', 'space', 'i')\n"
"box.schema.user.grant('internal', 'create', 'universe')\n"
"box.schema.user.grant('internal', 'read,write', 'space', '_func')\n"
"\n"
"function read_and_modify(key)\n"
"  local u = box.space.u\n"
"  local i = box.space.i\n"
"  local fiber = require('fiber')\n"
"  local t = u:get{key}\n"
"  if t ~= nil then\n"
"    u:put{key, box.session.uid()}\n"
"    i:put{key, fiber.time()}\n"
"  end\n"
"end\n"
"\n"
"box.session.su('internal')\n"
"box.schema.func.create('read_and_modify', {setuid= true})\n"
"box.session.su('admin')\n"
"box.schema.user.create('public_user', {password = 'secret'})\n"
"box.schema.user.grant('public_user', 'execute', 'function', "
"'read_and_modify')"

#: ../doc/book/box/authentication.rst:277
msgid "Roles"
msgstr "Роли"

#: ../doc/book/box/authentication.rst:279
msgid ""
"A **role** is a container for privileges which can be granted to regular "
"users. Instead of granting or revoking individual privileges, you can put"
" all the privileges in a role and then grant or revoke the role."
msgstr ""
"**Роль** представляет собой контейнер для прав, которые можно "
"предоставить обычным пользователям. Вместо того, чтобы предоставлять или "
"отменять индивидуальные права, можно поместить все права в роль, а затем "
"назначить или отменить роль."

#: ../doc/book/box/authentication.rst:283
msgid ""
"Role information is stored in the :ref:`_user <box_space-user>` space, "
"but the third field in the tuple -- the type field -- is ‘role’ rather "
"than ‘user’."
msgstr ""
"Информация о роли хранится в спейсе :ref:`_user <box_space-user>`, но "
"третье поле кортежа -- поле типа -- это ‘роль’, а не ‘пользователь’."

#: ../doc/book/box/authentication.rst:286
msgid ""
"An important feature in role management is that roles can be **nested**. "
"For example, role R1 can be granted a privilege \"role R2\", so users "
"with the role R1 will subsequently get all privileges from both roles R1 "
"and R2. In other words, a user gets all the privileges that are granted "
"to a user’s roles, directly or indirectly."
msgstr ""
"В управлении доступом на основе ролей один из главных моментов -- это то,"
" что роли могут быть **вложенными**. Например, роли R1 можно предоставить"
" право типа \"роль R2\", то есть пользователи с ролью R1 тогда получат "
"все права роли R1 и роли R2. Другими словами, пользователь получает все "
"права, которые предоставляются ролям пользователя напрямую и "
"опосредованно."

#: ../doc/book/box/authentication.rst:292
msgid ""
"There are actually two ways to grant or revoke a role: "
":samp:`box.schema.user.grant-or-revoke({user-name-or-role-"
"name},'execute', 'role',{role-name}...)` or :samp:`box.schema.user.grant-"
"or-revoke({user-name-or-role-name},{role-name}...)`. The second way is "
"preferable."
msgstr ""
"Фактически есть два способа предоставить или отменить роль: "
":samp:`box.schema.user.grant-or-"
"revoke({имя-пользователя-или-имя-роли},'execute', 'role',{имя-роли}...)` "
"или :samp:`box.schema.user.grant-or-"
"revoke({имя-пользователя-или-имя-роли},{имя-роли}...)`. Рекомендуется "
"использовать второй способ."

#: ../doc/book/box/authentication.rst:298
msgid "The 'usage' and 'session' privileges cannot be granted to roles."
msgstr "Права типов 'usage' и 'session' нельзя предоставить для роли."

#: ../doc/book/box/authentication.rst:302
msgid ""
"-- This example will work for a user with many privileges, such as "
"'admin'\n"
"-- or a user with the pre-defined 'super' role\n"
"-- Create space T with a primary index\n"
"box.schema.space.create('T')\n"
"box.space.T:create_index('primary', {})\n"
"-- Create user U1 so that later we can change the current user to U1\n"
"box.schema.user.create('U1')\n"
"-- Create two roles, R1 and R2\n"
"box.schema.role.create('R1')\n"
"box.schema.role.create('R2')\n"
"-- Grant role R2 to role R1 and role R1 to user U1 (order doesn't matter)"
"\n"
"-- There are two ways to grant a role; here we use the shorter way\n"
"box.schema.role.grant('R1', 'R2')\n"
"box.schema.user.grant('U1', 'R1')\n"
"-- Grant read/write privileges for space T to role R2\n"
"-- (but not to role R1 and not to user U1)\n"
"box.schema.role.grant('R2', 'read,write', 'space', 'T')\n"
"-- Change the current user to user U1\n"
"box.session.su('U1')\n"
"-- An insertion to space T will now succeed because, due to nested roles,"
"\n"
"-- user U1 has write privilege on space T\n"
"box.space.T:insert{1}"
msgstr ""
"-- Этот пример сработает для пользователя со множеством прав, например, "
"'admin'\n"
"-- или для пользователя с заданной ролью 'super'\n"
"-- Создать спейс T с первичным индексом\n"
"box.schema.space.create('T')\n"
"box.space.T:create_index('primary', {})\n"
"-- Создать пользователя U1, чтобы затем можно было заменить текущего "
"пользователя на U1\n"
"box.schema.user.create('U1')\n"
"-- Создать две роли, R1 и R2\n"
"box.schema.role.create('R1')\n"
"box.schema.role.create('R2')\n"
"-- Предоставить роль R2 для роли R1, а роль R1 пользователю U1 (порядок "
"не имеет значения)\n"
"-- Есть два способа предоставить роль, здесь используется более короткий "
"способ\n"
"box.schema.role.grant('R1', 'R2')\n"
"box.schema.user.grant('U1', 'R1')\n"
"-- Предоставить права на чтение/запись на спейс T для роли R2\n"
"-- (но не для роли R1 и не пользователю U1)\n"
"box.schema.role.grant('R2', 'read,write', 'space', 'T')\n"
"-- Изменить текущего пользователя на пользователя U1\n"
"box.session.su('U1')\n"
"-- Теперь вставка в спейс T сработает, потому что благодаря вложенным "
"ролям,\n"
"-- у пользователя U1 есть права на запись в спейс T\n"
"box.space.T:insert{1}"

#: ../doc/book/box/authentication.rst:327
msgid ""
"For more detail see :ref:`box.schema.user.grant() <box_schema-"
"user_grant>` and :ref:`box.schema.role.grant() <box_schema-role_grant>` "
"in the built-in modules reference."
msgstr ""
"Более подробную информацию см. в справочнике по встроенным модулям: "
":ref:`box.schema.user.grant() <box_schema-user_grant>` и "
":ref:`box.schema.role.grant() <box_schema-role_grant>`."

#: ../doc/book/box/authentication.rst:336
msgid "Sessions and security"
msgstr "Сессии и безопасность"

#: ../doc/book/box/authentication.rst:338
msgid "A **session** is the state of a connection to Tarantool. It contains:"
msgstr "**Сессия** -- это состояние подключения к Tarantool'у. Она содержит:"

#: ../doc/book/box/authentication.rst:340
msgid "an integer id identifying the connection,"
msgstr "идентификатор в виде целого числа, определяющий соединение,"

#: ../doc/book/box/authentication.rst:341
msgid ""
"the :ref:`current user <authentication-users>` associated with the "
"connection,"
msgstr ""
":ref:`текущий пользователь <authentication-users>`, использующий "
"соединение,"

#: ../doc/book/box/authentication.rst:342
msgid "text description of the connected peer, and"
msgstr "текстовое описание подключенного узла и"

#: ../doc/book/box/authentication.rst:343
msgid "session local state, such as Lua variables and functions."
msgstr "локальное состояние сессии, например, переменные и функции на Lua."

#: ../doc/book/box/authentication.rst:345
msgid ""
"In Tarantool, a single session can execute multiple concurrent "
"transactions. Each transaction is identified by a unique integer id, "
"which can be queried at start of the transaction using "
":ref:`box.session.sync() <box_session-sync>`."
msgstr ""
"В Tarantool'е отдельная сессия может выполнять несколько транзакций "
"одновременно. Каждая транзакция определяется по уникальному "
"идентификатору в виде целого числа, который можно запросить в начале "
"транзакции с помощью :ref:`box.session.sync() <box_session-sync>`."

#: ../doc/book/box/authentication.rst:351
msgid ""
"To track all connects and disconnects, you can use :ref:`connection and "
"authentication triggers <triggers>`."
msgstr ""
"Чтобы отследить все подключения и отключения, можно использовать "
":ref:`триггеры соединений и аутентификации <triggers>`."

#: ../doc/book/box/box_cfg.rst:5 ../doc/book/box/box_introspection.rst:5
msgid "Submodule `box.cfg`"
msgstr "Вложенный модуль `box.cfg`"

#: ../doc/book/box/box_cfg.rst:9
msgid ""
"The ``box.cfg`` submodule is for administrators to specify all the "
":ref:`server configuration parameters <box_cfg_params>`."
msgstr ""
"Вложенный модуль ``box.cfg`` предназначен для системных администраторов, "
"чтобы указать все :ref:`параметры конфигурации сервера <box_cfg_params>`."

#: ../doc/book/box/box_cfg.rst:12
msgid ""
"Say ``box.cfg`` without braces to view the current configuration, for "
"example:"
msgstr ""
"Введите команду ``box.cfg`` без фигурных скобок для просмотра текущей "
"конфигурации, например:"

#: ../doc/book/box/box_cfg.rst:14 ../doc/book/box/box_introspection.rst:16
msgid ""
"tarantool> box.cfg\n"
"---\n"
"- checkpoint_count: 2\n"
"  too_long_threshold: 0.5\n"
"  slab_alloc_factor: 1.1\n"
"  memtx_max_tuple_size: 1048576\n"
"  background: false\n"
"  <...>\n"
"..."
msgstr ""
"tarantool> box.cfg\n"
" ---\n"
" - checkpoint_count: 2\n"
"   too_long_threshold: 0.5\n"
"   slab_alloc_factor: 1.1\n"
"   memtx_max_tuple_size: 1048576\n"
"   background: false\n"
"   <...>\n"
" ..."

#: ../doc/book/box/box_cfg.rst:26
msgid "To set the parameters, say ``box.cfg{...}``, for example:"
msgstr "Чтобы установить параметры, введите команду ``box.cfg{...}``, например:"

#: ../doc/book/box/box_cfg.rst:28
#: ../doc/book/getting_started/using_binary.rst:91
msgid "tarantool> box.cfg{listen = 3301}"
msgstr "tarantool> box.cfg{listen = 3301}"

#: ../doc/book/box/box_cfg.rst:32
msgid ""
"If you say ``box.cfg{}`` with no parameters, Tarantool applies default "
"settings:"
msgstr ""
"Если ввести ``box.cfg{}`` без параметров, Tarantool применит настройки по"
" умолчанию:"

#: ../doc/book/box/box_cfg.rst:34
#, fuzzy
msgid ""
"tarantool> box.cfg{}\n"
"tarantool> box.cfg -- sorted in the alphabetic order\n"
"---\n"
"- background                   = false\n"
"  checkpoint_count             = 2\n"
"  checkpoint_interval          = 3600\n"
"  checkpoint_wal_threshold     = 1000000000000000000\n"
"  coredump                     = false\n"
"  custom_proc_title            = nil\n"
"  feedback_enabled             = true\n"
"  feedback_host                = 'https://feedback.tarantool.io'\n"
"  feedback_interval            = 3600\n"
"  force_recovery               = false\n"
"  hot_standby                  = false\n"
"  io_collect_interval          = nil\n"
"  listen                       = nil\n"
"  log                          = nil\n"
"  log_format                   = plain\n"
"  log_level                    = 5\n"
"  log_nonblock                 = true\n"
"  memtx_dir                    = '.'\n"
"  memtx_max_tuple_size         = 1024 * 1024\n"
"  memtx_memory                 = 256 * 1024 *1024\n"
"  memtx_min_tuple_size         = 16\n"
"  net_msg_max                  = 768\n"
"  pid_file                     = nil\n"
"  readahead                    = 16320\n"
"  read_only                    = false\n"
"  replication                  = nil\n"
"  replication_connect_timeout  = 4\n"
"  replication_skip_conflict    = false\n"
"  replication_sync_lag         = 10\n"
"  replication_sync_timeout     = 300\n"
"  replication_timeout          = 1\n"
"  rows_per_wal                 = 500000\n"
"  slab_alloc_factor            = 1.05\n"
"  snap_io_rate_limit           = nil\n"
"  strip_core                   = true\n"
"  too_long_threshold           = 0.5\n"
"  username                     = nil\n"
"  vinyl_bloom_fpr              = 0.05\n"
"  vinyl_cache                  = 128\n"
"  vinyl_dir                    = '.'\n"
"  vinyl_max_tuple_size         = 1024 * 1024* 1024 * 1024\n"
"  vinyl_memory                 = 128 * 1024 * 1024\n"
"  vinyl_page_size              = 8 * 1024\n"
"  vinyl_range_size             = nil\n"
"  vinyl_read_threads           = 1\n"
"  vinyl_run_count_per_level    = 2\n"
"  vinyl_run_size_ratio         = 3.5\n"
"  vinyl_timeout                = 60\n"
"  vinyl_write_threads          = 2\n"
"  wal_dir                      = '.'\n"
"  wal_dir_rescan_delay         = 2\n"
"  wal_max_size                 = 256 * 1024 * 1024\n"
"  wal_mode                     = 'write'\n"
"  worker_pool_threads          = 4\n"
"  work_dir                     = nil"
msgstr ""
"tarantool> box.cfg{}\n"
"tarantool> box.cfg -- сортировка в алфавитном порядке\n"
"---\n"
"- background                   = false\n"
"  checkpoint_count             = 2\n"
"  checkpoint_interval          = 3600\n"
"  coredump                     = false\n"
"  custom_proc_title            = nil\n"
"  feedback_enabled             = true\n"
"  feedback_host                = 'https://feedback.tarantool.io'\n"
"  feedback_interval            = 3600\n"
"  force_recovery               = false\n"
"  hot_standby                  = false\n"
"  io_collect_interval          = nil\n"
"  listen                       = nil\n"
"  log                          = nil\n"
"  log_format                   = plain\n"
"  log_level                    = 5\n"
"  log_nonblock                 = true\n"
"  memtx_dir                    = '.'\n"
"  memtx_max_tuple_size         = 1024 * 1024\n"
"  memtx_memory                 = 256 * 1024 *1024\n"
"  memtx_min_tuple_size         = 16\n"
"  net_msg_max                  = 768\n"
"  pid_file                     = nil\n"
"  readahead                    = 16320\n"
"  read_only                    = false\n"
"  replication                  = nil\n"
"  replication_connect_timeout  = 4\n"
"  replication_skip_conflict    = false\n"
"  replication_sync_lag         = 10\n"
"  replication_sync_timeout     = 300\n"
"  replication_timeout          = 1\n"
"  rows_per_wal                 = 500000\n"
"  slab_alloc_factor            = 1.05\n"
"  snap_io_rate_limit           = nil\n"
"  too_long_threshold           = 0.5\n"
"  username                     = nil\n"
"  vinyl_bloom_fpr              = 0.05\n"
"  vinyl_cache                  = 128\n"
"  vinyl_dir                    = '.'\n"
"  vinyl_max_tuple_size         = 1024 * 1024* 1024 * 1024\n"
"  vinyl_memory                 = 128 * 1024 * 1024\n"
"  vinyl_page_size              = 8 * 1024\n"
"  vinyl_range_size             = nil\n"
"  vinyl_read_threads           = 1\n"
"  vinyl_run_count_per_level    = 2\n"
"  vinyl_run_size_ratio         = 3.5\n"
"  vinyl_timeout                = 60\n"
"  vinyl_write_threads          = 2\n"
"  wal_dir                      = '.'\n"
"  wal_dir_rescan_delay         = 2\n"
"  wal_max_size                 = 256 * 1024 * 1024\n"
"  wal_mode                     = 'write'\n"
"  worker_pool_threads          = 4\n"
"  work_dir                     = nil"

#: ../doc/book/box/box_cfg.rst:95
msgid ""
"The first call to ``box.cfg{...}`` (with or without parameters) initiates"
" Tarantool's database module :ref:`box <box-module>`. Before Tarantool "
"2.0, you needed to call ``box.cfg{...}`` prior to performing any database"
" operations. Now you can start working with the database outright, "
"without calling ``box.cfg{...}``. In this case, Tarantool initiates the "
"database module and applies default settings, as if you said "
"``box.cfg{}`` (without parameters)."
msgstr ""

#: ../doc/book/box/box_cfg.rst:103
msgid ""
"``box.cfg{...}`` is also the command that reloads :ref:`persistent data "
"files <index-box_persistence>` into RAM upon restart once we have data."
msgstr ""
"Команда ``box.cfg{...}`` также перезагружает :ref:`файлы с данными "
"длительного хранения <index-box_persistence>` в оперативную память при "
"перезапуске после получения данных."

#: ../doc/book/box/box_ctl.rst:5
msgid "Submodule `box.ctl`"
msgstr "Вложенный модуль `box.ctl`"

#: ../doc/book/box/box_ctl.rst:9
msgid ""
"The ``box.ctl`` submodule contains two functions: ``wait_ro`` (wait until"
" read-only) and ``wait_rw`` (wait until read-write). The functions are "
"useful during initialization of a server."
msgstr ""
"Вложенный модуль ``box.ctl`` включает в себя две функции: ``wait_ro`` "
"(дождаться режима только для чтения) и ``wait_rw`` (дождаться режима "
"чтения и записи). Эти функции используются во время инициализации "
"сервера."

#: ../doc/book/box/box_ctl.rst:14
msgid ""
"A particular use is for :ref:`box_once() <box-once>`. For example, when a"
" replica is initializing, it may call a ``box.once()`` function while the"
" server is still in read-only mode, and fail to make changes that are "
"necessary only once before the replica is fully initialized. This could "
"cause conflicts between a master and a replica if the master is in read-"
"write mode and the replica is in read-only mode. Waiting until \"read "
"only mode = false\" solves this problem."
msgstr ""
"Для :ref:`box_once() <box-once>` есть особое предназначение. Например, "
"при инициализации реплика может вызвать функцию ``box.once()``, пока "
"сервер все еще находится в режиме только для чтения, и не сможет "
"применить изменения однократно до окончательной инициализации реплики. "
"Это может привести к конфликту между мастером и репликой, если мастер "
"находится в режиме чтения и записи, а реплика доступна только для чтения."
" Ожидание условия \"read only mode = false\" (режим только для чтения "
"отключен) решает эту проблему."

#: ../doc/book/box/box_ctl.rst:24
msgid ""
"To see whether a function is already in read-only or read-write mode, "
"check :ref:`box.info.ro <box_introspection-box_info>`."
msgstr ""
"Чтобы проверить режим функции -- только для чтения или чтение и запись, "
"используйте :ref:`box.info.ro <box_introspection-box_info>`."

#: ../doc/book/box/box_ctl.rst:31
msgid "Wait until ``box.info.ro`` is true."
msgstr "Дождаться, пока не будет выполнено ``box.info.ro``."

#: ../doc/book/box/box_ctl.rst ../doc/book/box/box_index.rst
#: ../doc/book/box/box_schema.rst ../doc/book/box/box_session.rst
#: ../doc/book/box/box_space.rst ../doc/book/box/box_sql.rst
#: ../doc/book/box/box_tuple.rst ../doc/book/box/box_txn_management.rst
msgid "Parameters"
msgstr "Параметры"

#: ../doc/book/box/box_ctl.rst:33 ../doc/book/box/box_ctl.rst:56
msgid "maximum number of seconds to wait"
msgstr "максимальное количество секунд ожидания"

#: ../doc/book/box/box_ctl.rst ../doc/book/box/box_index.rst
#: ../doc/book/box/box_info.rst ../doc/book/box/box_introspection.rst
#: ../doc/book/box/box_schema.rst ../doc/book/box/box_session.rst
#: ../doc/book/box/box_slab.rst ../doc/book/box/box_space.rst
#: ../doc/book/box/box_sql.rst ../doc/book/box/box_tuple.rst
#: ../doc/book/box/box_txn_management.rst
msgid "return"
msgstr "возвращается"

#: ../doc/book/box/box_ctl.rst:34 ../doc/book/box/box_ctl.rst:57
msgid "nil, or error may be thrown due to timeout or fiber cancellation"
msgstr ""
"нулевое значение nil или ошибка, которая может возникнуть из-за "
"превышения времени ожидания или прерывания работы файбера"

#: ../doc/book/box/box_ctl.rst:36 ../doc/book/box/box_ctl.rst:60
#: ../doc/book/box/box_index.rst:117 ../doc/book/box/box_index.rst:503
#: ../doc/book/box/box_index.rst:643 ../doc/book/box/box_index.rst:674
#: ../doc/book/box/box_index.rst:705 ../doc/book/box/box_index.rst:734
#: ../doc/book/box/box_index.rst:758 ../doc/book/box/box_index.rst:841
#: ../doc/book/box/box_index.rst:871 ../doc/book/box/box_index.rst:893
#: ../doc/book/box/box_index.rst:991 ../doc/book/box/box_index.rst:1004
#: ../doc/book/box/box_info.rst:204 ../doc/book/box/box_introspection.rst:14
#: ../doc/book/box/box_introspection.rst:78
#: ../doc/book/box/box_introspection.rst:141 ../doc/book/box/box_schema.rst:280
#: ../doc/book/box/box_schema.rst:318 ../doc/book/box/box_schema.rst:352
#: ../doc/book/box/box_schema.rst:391 ../doc/book/box/box_schema.rst:413
#: ../doc/book/box/box_schema.rst:458 ../doc/book/box/box_schema.rst:477
#: ../doc/book/box/box_schema.rst:492 ../doc/book/box/box_schema.rst:523
#: ../doc/book/box/box_schema.rst:554 ../doc/book/box/box_schema.rst:571
#: ../doc/book/box/box_schema.rst:613 ../doc/book/box/box_schema.rst:717
#: ../doc/book/box/box_schema.rst:752 ../doc/book/box/box_schema.rst:768
#: ../doc/book/box/box_schema.rst:793 ../doc/book/box/box_schema.rst:941
#: ../doc/book/box/box_slab.rst:55 ../doc/book/box/box_slab.rst:114
#: ../doc/book/box/box_slab.rst:156 ../doc/book/box/box_space.rst:200
#: ../doc/book/box/box_space.rst:226 ../doc/book/box/box_space.rst:252
#: ../doc/book/box/box_space.rst:613 ../doc/book/box/box_space.rst:670
#: ../doc/book/box/box_space.rst:719 ../doc/book/box/box_space.rst:756
#: ../doc/book/box/box_space.rst:831 ../doc/book/box/box_space.rst:933
#: ../doc/book/box/box_space.rst:982 ../doc/book/box/box_space.rst:1026
#: ../doc/book/box/box_space.rst:1053 ../doc/book/box/box_space.rst:1229
#: ../doc/book/box/box_space.rst:1277 ../doc/book/box/box_space.rst:1320
#: ../doc/book/box/box_space.rst:1356 ../doc/book/box/box_space.rst:1377
#: ../doc/book/box/box_space.rst:1427 ../doc/book/box/box_space.rst:1515
#: ../doc/book/box/box_space.rst:1592 ../doc/book/box/box_space.rst:1704
#: ../doc/book/box/box_space.rst:1740 ../doc/book/box/box_space.rst:1792
#: ../doc/book/box/box_space.rst:1840 ../doc/book/box/box_space.rst:1858
#: ../doc/book/box/box_space.rst:1879 ../doc/book/box/box_space.rst:1949
#: ../doc/book/box/box_space.rst:2109 ../doc/book/box/box_space.rst:2388
#: ../doc/book/box/box_space.rst:2420 ../doc/book/box/box_tuple.rst:95
#: ../doc/book/box/box_txn_management.rst:155
msgid "**Example:**"
msgstr "**Пример:**"

#: ../doc/book/box/box_ctl.rst:38
msgid ""
"tarantool> box.info().ro\n"
"---\n"
"- false\n"
"...\n"
"\n"
"tarantool> n = box.ctl.wait_ro(0.1)\n"
"---\n"
"- error: timed out\n"
"..."
msgstr ""
"tarantool> box.info().ro\n"
"---\n"
"- false\n"
"...\n"
"\n"
"tarantool> n = box.ctl.wait_ro(0.1)\n"
"---\n"
"- error: timed out\n"
"..."

#: ../doc/book/box/box_ctl.rst:54
msgid "Wait until box.info.ro is false."
msgstr "Дождаться, пока не перестанет соблюдаться box.info.ro."

#: ../doc/book/box/box_ctl.rst:62
msgid ""
"tarantool> box.ctl.wait_rw(0.1)\n"
"---\n"
"..."
msgstr ""
"tarantool> box.ctl.wait_rw(0.1)\n"
"---\n"
"..."

#: ../doc/book/box/box_index.rst:5
msgid "Submodule `box.index`"
msgstr "Вложенный модуль `box.index`"

#: ../doc/book/box/box_index.rst:9 ../doc/book/box/box_schema.rst:11
#: ../doc/book/box/box_session.rst:9 ../doc/book/box/box_slab.rst:11
#: ../doc/book/box/box_space.rst:9 ../doc/book/box/box_tuple.rst:11
#: ../doc/book/box/box_txn_management.rst:9
msgid "Overview"
msgstr "Общие сведения"

#: ../doc/book/box/box_index.rst:11
msgid ""
"The ``box.index`` submodule provides read-only access for index "
"definitions and index keys. Indexes are contained in :samp:`box.space"
".{space-name}.index` array within each space object. They provide an API "
"for ordered iteration over tuples. This API is a direct binding to "
"corresponding methods of index objects of type ``box.index`` in the "
"storage engine."
msgstr ""
"Вложенный модуль ``box.index`` обеспечивает доступ к схемам индекса и "
"ключам индекса в режиме только для чтения. Индексы хранятся в массиве "
":samp:`box.space.{имя-спейса}.index` в каждом спейсе. Они предоставляют "
"API для упорядоченной итерации по кортежам. Этот API представляет собой "
"прямую привязку к соответствующим методам объектов типа``box.index`` в "
"движке базы данных."

#: ../doc/book/box/box_index.rst:19 ../doc/book/box/box_schema.rst:18
#: ../doc/book/box/box_session.rst:19 ../doc/book/box/box_slab.rst:19
#: ../doc/book/box/box_space.rst:19 ../doc/book/box/box_tuple.rst:20
#: ../doc/book/box/box_txn_management.rst:48 ../doc/book/box/data_model.rst:66
msgid "Index"
msgstr "Индекс"

#: ../doc/book/box/box_index.rst:21
msgid "Below is a list of all ``box.index`` functions and members."
msgstr "Ниже приведен перечень всех функций и элементов модуля ``box.index``."

#: ../doc/book/box/box_index.rst:29 ../doc/book/box/box_schema.rst:28
#: ../doc/book/box/box_schema.rst:131 ../doc/book/box/box_session.rst:29
#: ../doc/book/box/box_slab.rst:29 ../doc/book/box/box_space.rst:29
#: ../doc/book/box/box_space.rst:295 ../doc/book/box/box_space.rst:2294
#: ../doc/book/box/box_tuple.rst:30 ../doc/book/box/box_txn_management.rst:60
msgid "Name"
msgstr "Имя"

#: ../doc/book/box/box_index.rst:29 ../doc/book/box/box_schema.rst:28
#: ../doc/book/box/box_session.rst:29 ../doc/book/box/box_slab.rst:29
#: ../doc/book/box/box_space.rst:29 ../doc/book/box/box_tuple.rst:30
#: ../doc/book/box/box_txn_management.rst:60
msgid "Use"
msgstr "Использование"

#: ../doc/book/box/box_index.rst:31
msgid ":ref:`index_object.unique <box_index-unique>`"
msgstr ":ref:`index_object.unique <box_index-unique>`"

#: ../doc/book/box/box_index.rst:31
msgid "Flag, true if an index is unique"
msgstr "Флаг, если индекс уникальный -- true"

#: ../doc/book/box/box_index.rst:34
msgid ":ref:`index_object.type <box_index-type>`"
msgstr ":ref:`index_object.type <box_index-type>`"

#: ../doc/book/box/box_index.rst:34 ../doc/book/box/data_model.rst:278
#: ../doc/book/box/data_model.rst:920
msgid "Index type"
msgstr "Тип индекса"

#: ../doc/book/box/box_index.rst:37
msgid ":ref:`index_object.parts <box_index-parts>`"
msgstr ":ref:`index_object.parts <box_index-parts>`"

#: ../doc/book/box/box_index.rst:37
msgid "Array of index key fields"
msgstr "Массив полей с ключами индекса"

#: ../doc/book/box/box_index.rst:40
msgid ":ref:`index_object:pairs() <box_index-index_pairs>`"
msgstr ":ref:`index_object:pairs() <box_index-index_pairs>`"

#: ../doc/book/box/box_index.rst:40 ../doc/book/box/box_space.rst:72
#: ../doc/book/box/box_tuple.rst:68
msgid "Prepare for iterating"
msgstr "Подготовка к итерации"

#: ../doc/book/box/box_index.rst:43
msgid ":ref:`index_object:select() <box_index-select>`"
msgstr ":ref:`index_object:select() <box_index-select>`"

#: ../doc/book/box/box_index.rst:43
msgid "Select one or more tuples via index"
msgstr "Выбор одного или более кортежей по индексу"

#: ../doc/book/box/box_index.rst:46
msgid ":ref:`index_object:get() <box_index-get>`"
msgstr ":ref:`index_object:get() <box_index-get>`"

#: ../doc/book/box/box_index.rst:46
msgid "Select a tuple via index"
msgstr "Выбор кортежа по индексу"

#: ../doc/book/box/box_index.rst:49
msgid ":ref:`index_object:min() <box_index-min>`"
msgstr ":ref:`index_object:min() <box_index-min>`"

#: ../doc/book/box/box_index.rst:49
msgid "Find the minimum value in index"
msgstr "Поиск минимального значения в индексе"

#: ../doc/book/box/box_index.rst:52
msgid ":ref:`index_object:max() <box_index-max>`"
msgstr ":ref:`index_object:max() <box_index-max>`"

#: ../doc/book/box/box_index.rst:52
msgid "Find the maximum value in index"
msgstr "Поиск максимального значения в индексе"

#: ../doc/book/box/box_index.rst:55
msgid ":ref:`index_object:random() <box_index-random>`"
msgstr ":ref:`index_object:random() <box_index-random>`"

#: ../doc/book/box/box_index.rst:55
msgid "Find a random value in index"
msgstr "Поиск случайного значения в индексе"

#: ../doc/book/box/box_index.rst:58
msgid ":ref:`index_object:count() <box_index-count>`"
msgstr ":ref:`index_object:count() <box_index-count>`"

#: ../doc/book/box/box_index.rst:58
msgid "Count tuples matching key value"
msgstr "Подсчет кортежей с совпадающим значением ключа"

#: ../doc/book/box/box_index.rst:61
msgid ":ref:`index_object:update() <box_index-update>`"
msgstr ":ref:`index_object:update() <box_index-update>`"

#: ../doc/book/box/box_index.rst:61 ../doc/book/box/box_space.rst:93
#: ../doc/book/box/box_space.rst:96 ../doc/book/box/box_tuple.rst:71
msgid "Update a tuple"
msgstr "Обновление кортежа"

#: ../doc/book/box/box_index.rst:64
msgid ":ref:`index_object:delete() <box_index-delete>`"
msgstr ":ref:`index_object:delete() <box_index-delete>`"

#: ../doc/book/box/box_index.rst:64
msgid "Delete a tuple by key"
msgstr "Удаление кортежа по ключу"

#: ../doc/book/box/box_index.rst:67
msgid ":ref:`index_object:alter() <box_index-alter>`"
msgstr ":ref:`index_object:alter() <box_index-alter>`"

#: ../doc/book/box/box_index.rst:67
msgid "Alter an index"
msgstr "Изменение индекса"

#: ../doc/book/box/box_index.rst:70
msgid ":ref:`index_object:drop() <box_index-drop>`"
msgstr ":ref:`index_object:drop() <box_index-drop>`"

#: ../doc/book/box/box_index.rst:70
msgid "Drop an index"
msgstr "Удаление индекса"

#: ../doc/book/box/box_index.rst:73
msgid ":ref:`index_object:rename() <box_index-rename>`"
msgstr ":ref:`index_object:rename() <box_index-rename>`"

#: ../doc/book/box/box_index.rst:73
msgid "Rename an index"
msgstr "Переименование индекса"

#: ../doc/book/box/box_index.rst:76
msgid ":ref:`index_object:bsize() <box_index-bsize>`"
msgstr ":ref:`index_object:bsize() <box_index-bsize>`"

#: ../doc/book/box/box_index.rst:76
msgid "Get count of bytes for an index"
msgstr "Подсчет байтов для индекса"

#: ../doc/book/box/box_index.rst:79
msgid ":ref:`index_object:stat() <box_index-stat>`"
msgstr ":ref:`index_object:stat() <box_index-stat>`"

#: ../doc/book/box/box_index.rst:79
msgid "Get statistics for an index"
msgstr "Получение статистических данных по индексу"

#: ../doc/book/box/box_index.rst:82
msgid ":ref:`index_object:compact() <box_index-compact>`"
msgstr ":ref:`index_object:compact() <box_index-compact>`"

#: ../doc/book/box/box_index.rst:82
msgid "Remove unused index space"
msgstr "Удаление неиспользуемого пространства индекса"

#: ../doc/book/box/box_index.rst:85
msgid ":ref:`index_object:user_defined() <box_index-user_defined>`"
msgstr ":ref:`index_object:user_defined() <box_index-user_defined>`"

#: ../doc/book/box/box_index.rst:85 ../doc/book/box/box_space.rst:99
msgid "Any function / method that any user wants to add"
msgstr "Любая функция / метод, которые хочет добавить любой пользователь"

#: ../doc/book/box/box_index.rst:98
msgid "True if the index is unique, false if the index is not unique."
msgstr "Если индекс уникальный -- true, если индекс не уникален -- false."

#: ../doc/book/box/box_index.rst ../doc/book/box/box_info.rst
#: ../doc/book/box/box_introspection.rst ../doc/book/box/box_schema.rst
#: ../doc/book/box/box_session.rst ../doc/book/box/box_slab.rst
#: ../doc/book/box/box_space.rst ../doc/book/box/box_tuple.rst
#: ../doc/book/box/box_txn_management.rst
msgid "rtype"
msgstr "тип возвращаемого значения"

#: ../doc/book/box/box_index.rst:100 ../doc/book/box/box_schema.rst:152
#: ../doc/book/box/box_schema.rst:158 ../doc/book/box/box_schema.rst:165
#: ../doc/book/box/box_space.rst:305 ../doc/book/box/box_space.rst:307
#: ../doc/book/box/data_model.rst:155
msgid "boolean"
msgstr "boolean (логический)"

#: ../doc/book/box/box_index.rst:106
msgid "Index type, 'TREE' or 'HASH' or 'BITSET' or 'RTREE'."
msgstr "Тип индекса: 'TREE' или 'HASH' или 'BITSET' или 'RTREE'."

#: ../doc/book/box/box_index.rst:112
msgid ""
"An array describing the index fields. To learn more about the index field"
" types, refer to :ref:`this table <box_space-index_field_types>`."
msgstr ""
"Массив, описывающий поля индекса. Чтобы узнать больше о типах полей "
"индекса, обращайтесь к :ref:`этой таблице <box_space-index_field_types>`."

#: ../doc/book/box/box_index.rst:115 ../doc/book/box/box_index.rst:945
#: ../doc/book/box/box_info.rst:202 ../doc/book/box/box_introspection.rst:76
#: ../doc/book/box/box_schema.rst:141 ../doc/book/box/box_slab.rst:53
#: ../doc/book/box/box_slab.rst:112 ../doc/book/box/box_slab.rst:154
#: ../doc/book/box/box_space.rst:1877
msgid "table"
msgstr "таблица"

#: ../doc/book/box/box_index.rst:119
msgid ""
"tarantool> box.space.tester.index.primary\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: unsigned\n"
"    is_nullable: false\n"
"    fieldno: 1\n"
"  id: 0\n"
"  space_id: 513\n"
"  name: primary\n"
"  type: TREE\n"
"..."
msgstr ""
"tarantool> box.space.tester.index.primary\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: unsigned\n"
"    is_nullable: false\n"
"    fieldno: 1\n"
"  id: 0\n"
"  space_id: 513\n"
"  name: primary\n"
"  type: TREE\n"
"..."

#: ../doc/book/box/box_index.rst:138
msgid ""
"Search for a tuple or a set of tuples via the given index, and allow "
"iterating over one tuple at a time."
msgstr ""
"Поиск кортежа или набора кортежей по заданному индексу и итерация по "
"одному кортежу за раз."

#: ../doc/book/box/box_index.rst:141
msgid "The :samp:`{key}` parameter specifies what must match within the index."
msgstr ""
"Параметр :samp:`{key}` (ключ) задает, что именно должно совпадать в "
"индексе."

#: ../doc/book/box/box_index.rst:145
msgid ""
":samp:`{key}` is only used to find the first match. Do not assume all "
"matched tuples will contain the key."
msgstr ""
":samp:`{key}` используется в поиске только первого совпадения. Не стоит "
"ожидать, что все подобранные кортежи будут содержать этот ключ."

#: ../doc/book/box/box_index.rst:148
msgid ""
"The :samp:`{iterator}` parameter specifies the rule for matching and "
"ordering. Different index types support different iterators. For example,"
" a TREE index maintains a strict order of keys and can return all tuples "
"in ascending or descending order, starting from the specified key. Other "
"index types, however, do not support ordering."
msgstr ""
"Параметр :samp:`{iterator}` (итератор) задает правило для совпадений и "
"упорядочивания. Различные типы индексов поддерживают различные итераторы."
" Например, TREE-индекс поддерживает строгий порядок ключей и может "
"вернуть все кортежи в порядке по возрастанию или по убыванию, начиная с "
"указанного ключа. Однако другие типы индексов не поддерживают "
"упорядочивание."

#: ../doc/book/box/box_index.rst:154
msgid ""
"To understand consistency of tuples returned by an iterator, it's "
"essential to know the principles of the Tarantool transaction processing "
"subsystem. An iterator in Tarantool does not own a consistent read view. "
"Instead, each procedure is granted exclusive access to all tuples and "
"spaces until there is a \"context switch\": which may happen due to "
":ref:`the implicit yield rules <atomic-implicit-yields>`, or by an "
"explicit call to :ref:`fiber.yield <fiber-yield>`. When the execution "
"flow returns to the yielded procedure, the data set could have changed "
"significantly. Iteration, resumed after a yield point, does not preserve "
"the read view, but continues with the new content of the database. The "
"tutorial :ref:`Indexed pattern search <c_lua_tutorial-"
"indexed_pattern_search>` shows one way that iterators and yields can be "
"used together."
msgstr ""
"Чтобы понять логику возврата кортежей с помощью итератора, важно знать "
"принципы работы подсистемы обработки транзакций в Tarantool'е. В "
"итераторе Tarantool'а нет собственного постоянного вида просмотра. "
"Наоборот, каждая процедура получает эксклюзивный доступ ко всем кортежам "
"и спейсам до тех пор, пока не \"переключится контекст\", что может "
"произойти по причине :ref:`неявной передачи управления <atomic-implicit-"
"yields>` или в результате явного вызова функции :ref:`fiber.yield <fiber-"
"yield>`. Когда поток выполнения возвращается к процедуре, передавшей "
"управление, набор данных может уже значительно измениться. Итерация "
"возобновляется после стадии передачи управления и не сохраняет вид "
"просмотра, а продолжает работу с новым содержимым базы данных. В "
"практическом задании :ref:`\"Индексированный поиск по шаблонам\" "
"<c_lua_tutorial-indexed_pattern_search>` демонстрируется один из способов"
" одновременного использования итераторов и передачи управления."

#: ../doc/book/box/box_index.rst:168 ../doc/book/box/box_space.rst:1273
msgid ""
"For information about iterators' internal structures see the `\"Lua "
"Functional library\" <https://luafun.github.io/index.html>`_ "
"documentation."
msgstr ""
"Для получения информации о внутренней структуре итераторов см. "
"документацию по библиотеке для функционального программирования в Lua "
"`\"Lua Functional library\" <https://luafun.github.io/index.html>`_."

#: ../doc/book/box/box_index.rst:172 ../doc/book/box/box_index.rst:492
#: ../doc/book/box/box_index.rst:627 ../doc/book/box/box_index.rst:658
#: ../doc/book/box/box_index.rst:689 ../doc/book/box/box_index.rst:723
#: ../doc/book/box/box_index.rst:750 ../doc/book/box/box_index.rst:781
#: ../doc/book/box/box_index.rst:804 ../doc/book/box/box_index.rst:825
#: ../doc/book/box/box_index.rst:860 ../doc/book/box/box_index.rst:885
#: ../doc/book/box/box_index.rst:909 ../doc/book/box/box_index.rst:941
#: ../doc/book/box/box_index.rst:987 ../doc/book/box/box_space.rst:1736
msgid "an :ref:`object reference <app_server-object_reference>`."
msgstr ":ref:`ссылка на объект <app_server-object_reference>`."

#: ../doc/book/box/box_index.rst:174 ../doc/book/box/box_space.rst:1252
msgid "value to be matched against the index key, which may be multi-part"
msgstr "значение должно совпасть с индексным ключом, который может быть составным"

#: ../doc/book/box/box_index.rst:176
msgid "as defined in tables below. The default iterator type is 'EQ'"
msgstr "как определено в таблицах ниже. По умолчанию используется итератор 'EQ'"

#: ../doc/book/box/box_index.rst:180 ../doc/book/box/box_space.rst:1257
msgid ""
"`iterator <https://www.lua.org/pil/7.1.html>`_ which can be used in a "
"for/end loop or with `totable() "
"<https://rtsisyk.github.io/luafun/reducing.html#fun.totable>`_"
msgstr ""
"`итератор <https://www.lua.org/pil/7.1.html>`_, который может "
"использовать в цикле for/end или с функцией `totable() "
"<https://rtsisyk.github.io/luafun/reducing.html#fun.totable>`_"

#: ../doc/book/box/box_index.rst:184 ../doc/book/box/box_index.rst:634
#: ../doc/book/box/box_index.rst:833 ../doc/book/box/box_index.rst:865
#: ../doc/book/box/box_space.rst:195 ../doc/book/box/box_space.rst:359
#: ../doc/book/box/box_space.rst:774 ../doc/book/box/box_space.rst:1261
#: ../doc/book/box/box_space.rst:1420 ../doc/book/box/box_space.rst:1695
msgid "**Possible errors:**"
msgstr "**Возможные ошибки:**"

#: ../doc/book/box/box_index.rst:186
msgid "no such space; wrong type;"
msgstr "спейс отсутствует; неправильный тип;"

#: ../doc/book/box/box_index.rst:187
msgid "selected iteration type is not supported for the index type;"
msgstr "выбранный тип итерации не поддерживается для данного типа индекса;"

#: ../doc/book/box/box_index.rst:188
msgid "key is not supported for the iteration type."
msgstr "ключ не поддерживается для данного типа итерации."

#: ../doc/book/box/box_index.rst:190
msgid "**Complexity factors:** Index size, Index type; Number of tuples accessed."
msgstr ""
"**Факторы сложности** Размер индекса, тип индекса; количество кортежей, к"
" которым получен доступ."

#: ../doc/book/box/box_index.rst:193
msgid ""
"A search-key-value can be a number (for example ``1234``), a string (for "
"example ``'abcd'``), or a table of numbers and strings (for example "
"``{1234, 'abcd'}``). Each part of a key will be compared to each part of "
"an index key."
msgstr ""
"Значение искомого ключа может представлять собой число (например, "
"``1234``), строку (например, ``'abcd'``) или таблицу из чисел и строк "
"(например, ``{1234, 'abcd'}``). Каждая часть ключа будет сопоставляться с"
" каждой частью ключа в индексе."

#: ../doc/book/box/box_index.rst:198
msgid ""
"The returned tuples will be in order by index key value, or by the hash "
"of the index key value if index type = 'hash'. If the index is non-"
"unique, then duplicates will be secondarily in order by primary key "
"value. The order will be reversed if the iterator type is 'LT' or 'LE' or"
" 'REQ'."
msgstr ""
"Найденные кортежи будут упорядочены по значению ключа в индексе или по "
"хешу значения ключа, если тип индекса -- 'hash'. Если индекс не уникален,"
" то дубликаты будут упорядочены во вторую очередь по первичному значению "
"ключа. Порядок будет обратным, если тип итератора -- 'LT', 'LE' или "
"'REQ'."

#: ../doc/book/box/box_index.rst:205
msgid "**Iterator types for TREE indexes**"
msgstr "**Типы итераторов для TREE-индексов**"

#: ../doc/book/box/box_index.rst:216 ../doc/book/box/box_index.rst:315
#: ../doc/book/box/box_index.rst:351 ../doc/book/box/box_index_rtree.csv:1
#: ../doc/book/box/box_schema.rst:131 ../doc/book/box/box_space.rst:295
#: ../doc/book/box/box_space.rst:2294
msgid "Type"
msgstr "Type"

#: ../doc/book/box/box_index.rst:216 ../doc/book/box/box_index.rst:315
#: ../doc/book/box/box_index.rst:351 ../doc/book/box/box_index_rtree.csv:1
msgid "Arguments"
msgstr "Аргументы"

#: ../doc/book/box/box_index.rst:216 ../doc/book/box/box_index.rst:315
#: ../doc/book/box/box_index.rst:351 ../doc/book/box/box_index_rtree.csv:1
#: ../doc/book/box/box_space.rst:2294
msgid "Description"
msgstr "Описание"

#: ../doc/book/box/box_index.rst:218 ../doc/book/box/box_index.rst:322
#: ../doc/book/box/box_index.rst:357 ../doc/book/box/box_index_rtree.csv:1
msgid "box.index.EQ or 'EQ'"
msgstr "box.index.EQ или 'EQ'"

#: ../doc/book/box/box_index.rst:218 ../doc/book/box/box_index.rst:224
#: ../doc/book/box/box_index.rst:229 ../doc/book/box/box_index.rst:236
#: ../doc/book/box/box_index.rst:243 ../doc/book/box/box_index.rst:247
#: ../doc/book/box/box_index.rst:253 ../doc/book/box/box_index.rst:322
#: ../doc/book/box/box_index.rst:328 ../doc/book/box/box_index_rtree.csv:1
msgid "search value"
msgstr "искомое значение"

#: ../doc/book/box/box_index.rst:218
msgid ""
"The comparison operator is '==' (equal to). If an index key is equal to a"
" search value, it matches. Tuples are returned in ascending order by "
"index key. This is the default."
msgstr ""
"Оператором сравнения будет '==' (равно). Если ключ индекса равен искомому"
" значению, получим совпадение. Найденные кортежи упорядочены по "
"возрастанию по ключу индекса. Этот тип используется по умолчанию."

#: ../doc/book/box/box_index.rst:224
msgid "box.index.REQ or 'REQ'"
msgstr "box.index.REQ или 'REQ'"

#: ../doc/book/box/box_index.rst:224
msgid ""
"Matching is the same as for ``box.index.EQ``. Tuples are returned in "
"descending order by index key."
msgstr ""
"Совпадения находятся таким же образом, что и для ``box.index.EQ``. "
"Разница только в том, что найденные кортежи упорядочены по ключу индекса "
"по убыванию, а не по возрастанию."

#: ../doc/book/box/box_index.rst:229 ../doc/book/box/box_index.rst:328
#: ../doc/book/box/box_index_rtree.csv:1
msgid "box.index.GT or 'GT'"
msgstr "box.index.GT или 'GT'"

#: ../doc/book/box/box_index.rst:229
msgid ""
"The comparison operator is '>' (greater than). If an index key is greater"
" than a search value, it matches. Tuples are returned in ascending order "
"by index key."
msgstr ""
"Оператором сравнения будет '>' (больше чем). Если ключ индекса больше, "
"чем искомое значение, получим совпадение. Найденные кортежи упорядочены "
"по возрастанию по ключу индекса."

#: ../doc/book/box/box_index.rst:236 ../doc/book/box/box_index_rtree.csv:1
msgid "box.index.GE or 'GE'"
msgstr "box.index.GE или 'GE'"

#: ../doc/book/box/box_index.rst:236
msgid ""
"The comparison operator is '>=' (greater than or equal to). If an index "
"key is greater than or equal to a search value, it matches. Tuples are "
"returned in ascending order by index key."
msgstr ""
"Оператором сравнения будет '>=' (больше или равен). Если ключ индекса "
"больше искомого значения или равен ему, получим совпадение. Найденные "
"кортежи упорядочены по возрастанию по ключу индекса."

#: ../doc/book/box/box_index.rst:243 ../doc/book/box/box_index.rst:353
#: ../doc/book/box/box_index_rtree.csv:1
msgid "box.index.ALL or 'ALL'"
msgstr "box.index.ALL или 'ALL'"

#: ../doc/book/box/box_index.rst:243
msgid "Same as box.index.GE."
msgstr "Как для box.index.GE."

#: ../doc/book/box/box_index.rst:247 ../doc/book/box/box_index_rtree.csv:1
msgid "box.index.LT or 'LT'"
msgstr "box.index.LT или 'LT'"

#: ../doc/book/box/box_index.rst:247
msgid ""
"The comparison operator is '<' (less than). If an index key is less than "
"a search value, it matches. Tuples are returned in descending order by "
"index key."
msgstr ""
"Оператором сравнения будет  '<' (меньше чем). Если ключ индекса меньше "
"искомого значения, получим совпадение. Найденные кортежи упорядочены по "
"убыванию по ключу индекса."

#: ../doc/book/box/box_index.rst:253 ../doc/book/box/box_index_rtree.csv:1
msgid "box.index.LE or 'LE'"
msgstr "box.index.LE или 'LE'"

#: ../doc/book/box/box_index.rst:253
msgid ""
"The comparison operator is '<=' (less than or equal to). If an index key "
"is less than or equal to a search value, it matches. Tuples are returned "
"in descending order by index key."
msgstr ""
"Оператором сравнения будет '<=' (меньше или равен). Если ключ индекса "
"меньше искомого значения или равен ему, получим совпадение. Найденные "
"кортежи упорядочены по убыванию по ключу индекса."

#: ../doc/book/box/box_index.rst:261
msgid ""
"Informally, we can state that searches with TREE indexes are generally "
"what users will find is intuitive, provided that there are no nils and no"
" missing parts. Formally, the logic is as follows. A search key has zero "
"or more parts, for example {}, {1,2,3},{1,nil,3}. An index key has one or"
" more parts, for example {1}, {1,2,3},{1,2,3}. A search key may contain "
"nil (but not msgpack.NULL, which is the wrong type). An index key may not"
" contain nil or msgpack.NULL, although a later version of Tarantool will "
"have different rules --  the behavior of searches with nil is subject to "
"change. Possible iterators are LT, LE, EQ, REQ, GE, GT. A search key is "
"said to \"match\" an index key if the following statements, which are "
"pseudocode for the comparison operation, return TRUE."
msgstr ""
"Неофициально можно сказать, что поиск с помощью TREE-индексов "
"пользователи обычно считают интуитивно понятным при условии, что нет "
"нулевых значений и отсутствующих частей. Формально же логика заключается "
"в следующем. Ключ поиска состоит из нуля или более частей, например, {}, "
"{1,2,3},{1,nil,3}. Ключ индекса состоит из одной или более частей, "
"например, {1}, {1,2,3},{1,2,3}. Ключ поиска может содержать нулевое "
"значение nil (но не msgpack.NULL, этот тип не будет правильным). Ключ "
"индекса не может содержать nil или msgpack.NULL, хотя в последующих "
"версиях правила работы Tarantool'а будут другие -- поведение поиска с nil"
" может измениться. Возможные итераторы: LT, LE, EQ, REQ, GE, GT. "
"Считается, что ключ поиска соответствует ключу индекса, если следующие "
"операторы, которые представляют собой псевдокод для операции "
"сопоставления, возвращают TRUE."

#: ../doc/book/box/box_index.rst:311
msgid ""
"If (number-of-search-key-parts > number-of-index-key-parts) return ERROR\n"
"If (number-of-search-key-parts == 0) return TRUE\n"
"for (i = 1; ; ++i)\n"
"{\n"
"  if (i > number-of-search-key-parts) OR (search-key-part[i] is nil)\n"
"  {\n"
"    if (iterator is LT or GT) return FALSE\n"
"    return TRUE\n"
"  }\n"
"  if (type of search-key-part[i] is not compatible with type of index-"
"key-part[i])\n"
"  {\n"
"    return ERROR\n"
"  }\n"
"  if (search-key-part[i] == index-key-part[i])\n"
"  {\n"
"    continue\n"
"  }\n"
"  if (search-key-part[i] > index-key-part[i])\n"
"  {\n"
"    if (iterator is EQ or REQ or LE or LT) return FALSE\n"
"    return TRUE\n"
"  }\n"
"  if (search-key-part[i] < index-key-part[i])\n"
"  {\n"
"    if (iterator is EQ or REQ or GE or GT) return FALSE\n"
"    return TRUE\n"
"  }\n"
"}"
msgstr ""
"If (number-of-search-key-parts > number-of-index-key-parts) return ERROR\n"
"If (number-of-search-key-parts == 0) return TRUE\n"
"for (i = 1; ; ++i)\n"
"{\n"
"  if (i > number-of-search-key-parts) OR (search-key-part[i] is nil)\n"
"  {\n"
"    if (iterator is LT or GT) return FALSE\n"
"    return TRUE\n"
"  }\n"
"  if (type of search-key-part[i] is not compatible with type of index-"
"key-part[i])\n"
"  {\n"
"    return ERROR\n"
"  }\n"
"  if (search-key-part[i] == index-key-part[i])\n"
"  {\n"
"    continue\n"
"  }\n"
"  if (search-key-part[i] > index-key-part[i])\n"
"  {\n"
"    if (iterator is EQ or REQ or LE or LT) return FALSE\n"
"    return TRUE\n"
"  }\n"
"  if (search-key-part[i] < index-key-part[i])\n"
"  {\n"
"    if (iterator is EQ or REQ or GE or GT) return FALSE\n"
"    return TRUE\n"
"  }\n"
"}"

#: ../doc/book/box/box_index.rst:306
msgid "**Iterator types for HASH indexes**"
msgstr "**Типы итераторов для HASH-индексов**"

#: ../doc/book/box/box_index.rst:317
msgid "box.index.ALL"
msgstr "box.index.ALL"

#: ../doc/book/box/box_index.rst:317 ../doc/book/box/box_index.rst:353
#: ../doc/book/box/box_index_rtree.csv:1
msgid "none"
msgstr "нет"

#: ../doc/book/box/box_index.rst:317
msgid ""
"All index keys match. Tuples are returned in ascending order by hash of "
"index key, which will appear to be random."
msgstr ""
"Все ключи индекса являются совпадениями. Найденные кортежи упорядочены по"
" возрастанию по хешу ключа индекса, который будет выглядеть случайным."

#: ../doc/book/box/box_index.rst:322
msgid ""
"The comparison operator is '==' (equal to). If an index key is equal to a"
" search value, it matches. The number of returned tuples will be 0 or 1. "
"This is the default."
msgstr ""
"Оператором сравнения будет '==' (равный). Если ключ индекса равен "
"искомому значению, получим совпадение. Количество найденных кортежей "
"будет 0 или 1. Этот тип используется по умолчанию."

#: ../doc/book/box/box_index.rst:328
msgid ""
"The comparison operator is '>' (greater than). If a hash of an index key "
"is greater than a hash of a search value, it matches. Tuples are returned"
" in ascending order by hash of index key, which will appear to be random."
" Provided that the space is not being updated, one can retrieve all the "
"tuples in a space, N tuples at a time, by using {iterator='GT', limit=N} "
"in each search, and using the last returned value from the previous "
"result as the start search value for the next search."
msgstr ""
"Оператором сравнения будет '>' (больше чем). Если хеш ключа индекса "
"больше, чем хеш искомого значения, получим совпадение. Найденные кортежи "
"упорядочены по возрастанию по хешу ключа индекса, который будет выглядеть"
" случайным. При условии, что спейс не обновляется, можно получить все "
"кортежи в спейсе, N кортежей за раз, используя  {iterator='GT', limit=N} "
"в каждом поиске и последнее найденное значение из предыдущего результата "
"поиска в качестве начального значения для следующего поиска."

#: ../doc/book/box/box_index.rst:342
msgid "**Iterator types for BITSET indexes**"
msgstr "**Типы итераторов для BITSET-индексов**"

#: ../doc/book/box/box_index.rst:353
msgid "All index keys match. Tuples are returned in their order within the space."
msgstr ""
"Все ключи индекса являются совпадениями. Найденные кортежи упорядочены по"
" положению в спейсе."

#: ../doc/book/box/box_index.rst:357 ../doc/book/box/box_index.rst:362
#: ../doc/book/box/box_index.rst:367 ../doc/book/box/box_index.rst:372
msgid "bitset value"
msgstr "значение bitset (битовое множество)"

#: ../doc/book/box/box_index.rst:357
msgid ""
"If an index key is equal to a bitset value, it matches. Tuples are "
"returned in their order within the space. This is the default."
msgstr ""
"Если ключ индекса равен искомому значению, получим совпадение. Найденные "
"кортежи упорядочены по положению в спейсе. Этот тип используется по "
"умолчанию."

#: ../doc/book/box/box_index.rst:362
msgid "box.index.BITS_ALL_SET"
msgstr "box.index.BITS_ALL_SET"

#: ../doc/book/box/box_index.rst:362
msgid ""
"If all of the bits which are 1 in the bitset value are 1 in the index "
"key, it matches. Tuples are returned in their order within the space."
msgstr ""
"Если все биты, которые равны 1 в битовом множестве, также равны 1 в ключе"
" индекса, получим совпадение. Найденные кортежи упорядочены по положению "
"в спейсе."

#: ../doc/book/box/box_index.rst:367
msgid "box.index.BITS_ANY_SET"
msgstr "box.index.BITS_ANY_SET"

#: ../doc/book/box/box_index.rst:367
msgid ""
"If any of the bits which are 1 in the bitset value are 1 in the index "
"key, it matches. Tuples are returned in their order within the space."
msgstr ""
"Если один из битов, которые равны 1 в битовом множестве, также равен 1 в "
"ключе индекса, получим совпадение. Найденные кортежи упорядочены по "
"положению в спейсе."

#: ../doc/book/box/box_index.rst:372
msgid "box.index.BITS_ALL_NOT_SET"
msgstr "box.index.BITS_ALL_NOT_SET"

#: ../doc/book/box/box_index.rst:372
msgid ""
"If all of the bits which are 1 in the bitset value are 0 in the index "
"key, it matches. Tuples are returned in their order within the space."
msgstr ""
"Если все биты, которые равны 1 в битовом множестве, равны 0 в ключе "
"индекса, получим совпадение. Найденные кортежи упорядочены по положению в"
" спейсе."

#: ../doc/book/box/box_index.rst:380
msgid "**Iterator types for RTREE indexes**"
msgstr "**Типы итераторов для RTREE-индексов**"

#: ../doc/book/box/box_index_rtree.csv:1
msgid "All keys match. Tuples are returned in their order within the space."
msgstr ""
"Все ключи являются совпадениями. Найденные кортежи упорядочены по "
"положению в спейсе."

#: ../doc/book/box/box_index_rtree.csv:1
msgid ""
"If all points of the rectangle-or-box defined by the search value are the"
" same as the rectangle-or-box defined by the index key, it matches. "
"Tuples are returned in their order within the space. \"Rectangle-or-box\""
" means \"rectangle-or-box as explained in section about :ref:`RTREE "
"<box_index-rtree>`\". This is the default."
msgstr ""
"Если все точки прямоугольника-или-параллелепипеда, определенные искомым "
"значением, совпадают с точками прямоугольника-или-параллелепипеда, "
"определенного ключом индекса, получим совпадение. Найденные кортежи "
"упорядочены по положению в спейсе. \"Прямоугольник-или-параллелепипед\" "
"означает \"прямоугольник-или-параллелепипед, как описано в разделе о "
":ref:`RTREE <box_index-rtree>`\". Этот тип используется по умолчанию."

#: ../doc/book/box/box_index_rtree.csv:1
msgid ""
"If all points of the rectangle-or-box defined by the search value are "
"within the rectangle-or-box defined by the index key, it matches. Tuples "
"are returned in their order within the space."
msgstr ""
"Если все точки прямоугольника-или-параллелепипеда, определенные искомым "
"значением, находятся в пределах прямоугольника-или-параллелепипеда, "
"определенного ключом индекса, получим совпадение. Найденные кортежи "
"упорядочены по положению в спейсе."

#: ../doc/book/box/box_index_rtree.csv:1
msgid ""
"If all points of the rectangle-or-box defined by the search value are "
"within, or at the side of, the rectangle-or-box defined by the index key,"
" it matches. Tuples are returned in their order within the space."
msgstr ""
"Если все точки прямоугольника-или-параллелепипеда, определенные искомым "
"значением, находятся в пределах прямоугольника-или-параллелепипеда, "
"определенного ключом индекса, или рядом с ним, получим совпадение. "
"Найденные кортежи упорядочены по положению в спейсе."

#: ../doc/book/box/box_index_rtree.csv:1
msgid ""
"If all points of the rectangle-or-box defined by the index key are within"
" the rectangle-or-box defined by the search key, it matches. Tuples are "
"returned in their order within the space."
msgstr ""
"Если все точки прямоугольника-или-параллелепипеда, определенные ключом "
"индекса, находятся в пределах прямоугольника-или-параллелепипеда, "
"определенного искомым значением, получим совпадение. Найденные кортежи "
"упорядочены по положению в спейсе."

#: ../doc/book/box/box_index_rtree.csv:1
msgid ""
"If all points of the rectangle-or-box defined by the index key are "
"within, or at the side of, the rectangle-or-box defined by the search "
"key, it matches. Tuples are returned in their order within the space."
msgstr ""
"Если все точки прямоугольника-или-параллелепипеда, определенные ключом "
"индекса, находятся в пределах прямоугольника-или-параллелепипеда, "
"определенного искомым значением, или рядом с ним, получим совпадение. "
"Найденные кортежи упорядочены по положению в спейсе."

#: ../doc/book/box/box_index_rtree.csv:1
msgid "box.index.OVERLAPS or 'OVERLAPS'"
msgstr "box.index.OVERLAPS или 'OVERLAPS'"

#: ../doc/book/box/box_index_rtree.csv:1
msgid ""
"If some points of the rectangle-or-box defined by the search value are "
"within the rectangle-or-box defined by the index key, it matches. Tuples "
"are returned in their order within the space."
msgstr ""
"Если некоторые точки прямоугольника-или-параллелепипеда, определенные "
"искомым значением, находятся в пределах "
"прямоугольника-или-параллелепипеда, определенного ключом индекса, получим"
" совпадение. Найденные кортежи упорядочены по положению в спейсе."

#: ../doc/book/box/box_index_rtree.csv:1
msgid "box.index.NEIGHBOR or 'NEIGHBOR'"
msgstr "box.index.NEIGHBOR или 'NEIGHBOR'"

#: ../doc/book/box/box_index_rtree.csv:1
msgid ""
"If some points of the rectangle-or-box defined by the defined by the key "
"are within, or at the side of, defined by the index key, it matches. "
"Tuples are returned in order: nearest neighbor first."
msgstr ""
"Если некоторые точки прямоугольника-или-параллелепипеда, определенные "
"ключом, находятся в пределах, определенных ключом индекса, или рядом с "
"ним, получим совпадение. Найденные кортежи упорядочены следующим образом:"
" сначала ближайший сосед."

#: ../doc/book/box/box_index.rst:394
msgid "**First example of index pairs():**"
msgstr "**Первый пример pairs():**"

#: ../doc/book/box/box_index.rst:396
msgid "Default 'TREE' Index and ``pairs()`` function:"
msgstr "'TREE'-индекс, используемый по умолчанию, и функция ``pairs()``:"

#: ../doc/book/box/box_index.rst:398
msgid ""
"tarantool> s = box.schema.space.create('space17')\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {\n"
"         >   parts = {1, 'string', 2, 'string'}\n"
"         > })\n"
"---\n"
"...\n"
"tarantool> s:insert{'C', 'C'}\n"
"---\n"
"- ['C', 'C']\n"
"...\n"
"tarantool> s:insert{'B', 'A'}\n"
"---\n"
"- ['B', 'A']\n"
"...\n"
"tarantool> s:insert{'C', '!'}\n"
"---\n"
"- ['C', '!']\n"
"...\n"
"tarantool> s:insert{'A', 'C'}\n"
"---\n"
"- ['A', 'C']\n"
"...\n"
"tarantool> function example()\n"
"         >   for _, tuple in\n"
"         >     s.index.primary:pairs(nil, {\n"
"         >         iterator = box.index.ALL}) do\n"
"         >       print(tuple)\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> example()\n"
"['A', 'C']\n"
"['B', 'A']\n"
"['C', '!']\n"
"['C', 'C']\n"
"---\n"
"...\n"
"tarantool> s:drop()\n"
"---\n"
"..."
msgstr ""
"tarantool> s = box.schema.space.create('space17')\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {\n"
"         >   parts = {1, 'string', 2, 'string'}\n"
"         > })\n"
"---\n"
"...\n"
"tarantool> s:insert{'C', 'C'}\n"
"---\n"
"- ['C', 'C']\n"
"...\n"
"tarantool> s:insert{'B', 'A'}\n"
"---\n"
"- ['B', 'A']\n"
"...\n"
"tarantool> s:insert{'C', '!'}\n"
"---\n"
"- ['C', '!']\n"
"...\n"
"tarantool> s:insert{'A', 'C'}\n"
"---\n"
"- ['A', 'C']\n"
"...\n"
"tarantool> function example()\n"
"         >   for _, tuple in\n"
"         >     s.index.primary:pairs(nil, {\n"
"         >         iterator = box.index.ALL}) do\n"
"         >       print(tuple)\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> example()\n"
"['A', 'C']\n"
"['B', 'A']\n"
"['C', '!']\n"
"['C', 'C']\n"
"---\n"
"...\n"
"tarantool> s:drop()\n"
"---\n"
"..."

#: ../doc/book/box/box_index.rst:444
msgid "**Second example of index pairs():**"
msgstr "**Второй пример pairs():**"

#: ../doc/book/box/box_index.rst:446
msgid ""
"This Lua code finds all the tuples whose primary key values begin with "
"'XY'. The assumptions include that there is a one-part primary-key TREE "
"index on the first field, which must be a string. The iterator loop "
"ensures that the search will return tuples where the first value is "
"greater than or equal to 'XY'. The conditional statement within the loop "
"ensures that the looping will stop when the first two letters are not "
"'XY'."
msgstr ""
"Данный код на Lua найдет все кортежи, значения первичного ключа в которых"
" начинаются с 'XY'. Рабочие предположения заключаются в следующем: есть "
"однокомпонентный первичный TREE-индекс по первому полю, которое должно "
"представлять собой строку. Цикл с итератором обеспечивает поиск кортежей,"
" в которых первое значение больше или равно 'XY'. Условный оператор в "
"цикле служит для того, чтобы цикл останавливался, если первые две буквы "
"не 'XY'."

#: ../doc/book/box/box_index.rst:454
msgid ""
"for _, tuple in\n"
"box.space.t.index.primary:pairs(\"XY\",{iterator = \"GE\"}) do\n"
"  if (string.sub(tuple[1], 1, 2) ~= \"XY\") then break end\n"
"  print(tuple)\n"
"end"
msgstr ""
"for _, tuple in\n"
"box.space.t.index.primary:pairs(\"XY\",{iterator = \"GE\"}) do\n"
"  if (string.sub(tuple[1], 1, 2) ~= \"XY\") then break end\n"
"  print(tuple)\n"
"end"

#: ../doc/book/box/box_index.rst:462
msgid "**Third example of index pairs():**"
msgstr "**Третий пример pairs():**"

#: ../doc/book/box/box_index.rst:464
msgid ""
"This Lua code finds all the tuples whose primary key values are greater "
"than or equal to 1000, and less than or equal to 1999 (this type of "
"request is sometimes called a \"range search\" or a \"between search\"). "
"The assumptions include that there is a one-part primary-key TREE index "
"on the first field, which must be a :ref:`number <index-box_number>`. The"
" iterator loop ensures that the search will return tuples where the first"
" value is greater than or equal to 1000. The conditional statement within"
" the loop ensures that the looping will stop when the first value is "
"greater than 1999."
msgstr ""
"Данный код на Lua найдет все кортежи, значения первичного ключа которых "
"равны или больше 1000 и меньше или равны 1999 (такой тип запроса иногда "
"называют поиском по диапазону или поиском в заданных пределах). Рабочие "
"предположения заключаются в следующем: есть однокомпонентный первичный "
"TREE-индекс по первому полю, которое должно представлять собой "
":ref:`число <index-box_number>`. Цикл с итератором обеспечивает поиск "
"кортежей, в которых первое значение больше или равно 1000. Условный "
"оператор в цикле служит для того, чтобы цикл останавливался, если первое "
"значение больше 1999."

#: ../doc/book/box/box_index.rst:474
msgid ""
"for _, tuple in\n"
"box.space.t2.index.primary:pairs(1000,{iterator = \"GE\"}) do\n"
"  if (tuple[1] > 1999) then break end\n"
"  print(tuple)\n"
"end"
msgstr ""
"for _, tuple in\n"
"box.space.t2.index.primary:pairs(1000,{iterator = \"GE\"}) do\n"
"  if (tuple[1] > 1999) then break end\n"
"  print(tuple)\n"
"end"

#: ../doc/book/box/box_index.rst:486
msgid ""
"This is an alternative to :ref:`box.space...select() <box_space-select>` "
"which goes via a particular index and can make use of additional "
"parameters that specify the iterator type, and the limit (that is, the "
"maximum number of tuples to return) and the offset (that is, which tuple "
"to start with in the list)."
msgstr ""
"Это может быть альтернативой для функции :ref:`box.space...select() "
"<box_space-select>`, которая проходит по определенному индексу и может "
"использовать дополнительные параметры, которые определяют тип итератора и"
" пределы (то есть максимальное количество возвращаемых кортежей) и "
"смещение (то есть с какого кортежа в списке начинать)."

#: ../doc/book/box/box_index.rst:494 ../doc/book/box/box_index.rst:629
#: ../doc/book/box/box_index.rst:660 ../doc/book/box/box_index.rst:691
#: ../doc/book/box/box_index.rst:752 ../doc/book/box/box_index.rst:783
#: ../doc/book/box/box_index.rst:806
msgid "values to be matched against the index key"
msgstr "значения для сопоставления с ключом индекса"

#: ../doc/book/box/box_index.rst:495
msgid "none, any or all of next parameters"
msgstr "ни один, любой или все следующие параметры"

#: ../doc/book/box/box_index.rst:496
msgid "type of iterator"
msgstr "тип итератора"

#: ../doc/book/box/box_index.rst:497
msgid "maximum number of tuples"
msgstr "максимальное количество кортежей"

#: ../doc/book/box/box_index.rst:498
msgid "start tuple number"
msgstr "номер начального кортежа"

#: ../doc/book/box/box_index.rst:500
msgid "the tuple or tuples that match the field values."
msgstr "кортеж или кортежи, которые совпадают со значениями поля."

#: ../doc/book/box/box_index.rst:501 ../doc/book/box/box_space.rst:1415
msgid "array of tuples"
msgstr "массив кортежей"

#: ../doc/book/box/box_index.rst:505
msgid ""
"-- Create a space named tester.\n"
"tarantool> sp = box.schema.space.create('tester')\n"
"-- Create a unique index 'primary'\n"
"-- which won't be needed for this example.\n"
"tarantool> sp:create_index('primary', {parts = {1, 'unsigned' }})\n"
"-- Create a non-unique index 'secondary'\n"
"-- with an index on the second field.\n"
"tarantool> sp:create_index('secondary', {\n"
"         >   type = 'tree',\n"
"         >   unique = false,\n"
"         >   parts = {2, 'string'}\n"
"         > })\n"
"-- Insert three tuples, values in field[2]\n"
"-- equal to 'X', 'Y', and 'Z'.\n"
"tarantool> sp:insert{1, 'X', 'Row with field[2]=X'}\n"
"tarantool> sp:insert{2, 'Y', 'Row with field[2]=Y'}\n"
"tarantool> sp:insert{3, 'Z', 'Row with field[2]=Z'}\n"
"-- Select all tuples where the secondary index\n"
"-- keys are greater than 'X'.`\n"
"tarantool> sp.index.secondary:select({'X'}, {\n"
"         >   iterator = 'GT',\n"
"         >   limit = 1000\n"
"         > })"
msgstr ""
"-- Создать спейс под названием tester.\n"
"tarantool> sp = box.schema.space.create('tester')\n"
"-- Создать уникальный индекс 'primary'\n"
"-- который не будет нужен для данного примера..\n"
"tarantool> sp:create_index('primary', {parts = {1, 'unsigned' }})\n"
"-- Создать неуникальный индекс 'secondary'\n"
"-- по второму полю.\n"
"tarantool> sp:create_index('secondary', {\n"
"         >   type = 'tree',\n"
"         >   unique = false,\n"
"         >   parts = {2, 'string'}\n"
"         > })\n"
"-- Вставить три кортежа, значения в поле2 field[2]\n"
"-- равны 'X', 'Y' и 'Z'.\n"
"tarantool> sp:insert{1, 'X', 'Row with field[2]=X'}\n"
"tarantool> sp:insert{2, 'Y', 'Row with field[2]=Y'}\n"
"tarantool> sp:insert{3, 'Z', 'Row with field[2]=Z'}\n"
"-- Выбрать все кортежи, где вторичные ключи\n"
"-- больше, чем 'X'.`\n"
"tarantool> sp.index.secondary:select({'X'}, {\n"
"         >   iterator = 'GT',\n"
"         >   limit = 1000\n"
"         > })"

#: ../doc/book/box/box_index.rst:531
msgid "The result will be a table of tuple and will look like this:"
msgstr "Результатом будет следующая таблица кортежа:"

#: ../doc/book/box/box_index.rst:533
msgid ""
"---\n"
"- - [2, 'Y', 'Row with field[2]=Y']\n"
"  - [3, 'Z', 'Row with field[2]=Z']\n"
"..."
msgstr ""
"---\n"
"- - [2, 'Y', 'Row with field[2]=Y']\n"
"  - [3, 'Z', 'Row with field[2]=Z']\n"
"..."

#: ../doc/book/box/box_index.rst:542
msgid ""
":samp:`index.{index-name}` is optional. If it is omitted, then the "
"assumed index is the first (primary-key) index. Therefore, for the "
"example above, ``box.space.tester:select({1}, {iterator = 'GT'})`` would "
"have returned the same two rows, via the 'primary' index."
msgstr ""
"Параметр :samp:`index.{имя-индекса}` необязателен. Если он пропущен, то "
"подразумевается первый индекс (первичный ключ). Таким образом, для "
"примера выше, ``box.space.tester:select({1}, {iterator = 'GT'})`` вернет "
"две одинаковых строки по первичному индексу 'primary'."

#: ../doc/book/box/box_index.rst:549
msgid ""
":samp:`iterator = {iterator-type}` is optional. If it is omitted, then "
"``iterator = 'EQ'`` is assumed."
msgstr ""
"Параметр типа итератора :samp:`iterator = {тип-итератора}` необязателен. "
"Если он пропущен, то подразумевается, что ``iterator = 'EQ'``."

#: ../doc/book/box/box_index.rst:554
msgid ""
":samp:`{field-value} [, {field-value ...}]` is optional. If it is "
"omitted, then every key in the index is considered to be a match, "
"regardless of iterator type. Therefore, for the example above, "
"``box.space.tester:select{}`` will select every tuple in the tester space"
" via the first (primary-key) index."
msgstr ""
"Параметр :samp:`{field-value} [, {значение поля ...}]` необязателен. Если"
" он пропущен, то каждый ключ в индексе будет считаться совпадением "
"независимо от типа итератора. Таким образом, для примера выше, "
"``box.space.tester:select{}`` выберет каждый кортеж в спейсе tester по "
"первому индексу (первичный ключ)."

#: ../doc/book/box/box_index.rst:564
msgid ""
":samp:`box.space.{space-name}.index.{index-name}:select(...)[1]``. can be"
" replaced by :samp:`box.space.{space-name}.index.{index-name}:get(...)`. "
"That is, ``get`` can be used as a convenient shorthand to get the first "
"tuple in the tuple set that would be returned by ``select``. However, if "
"there is more than one tuple in the tuple set, then ``get`` throws an "
"error."
msgstr ""
":samp:`box.space.{имя-спейса}.index.{имя-индекса}:select(...)[1]`` можно "
"заменить :samp:`box.space.{имя-спейса}.index.{имя-индекса}:get(...)`. А "
"именно, ``get`` можно использовать в качестве удобного сокращения для "
"получения первого кортежа в наборе кортежей, который был бы выведен по "
"запросу ``select``. Однако, если в наборе кортежей больше одного кортежа,"
" ``get`` завершится с ошибкой."

#: ../doc/book/box/box_index.rst:572
msgid "**Example with BITSET index:**"
msgstr "**Пример с индексом BITSET:**"

#: ../doc/book/box/box_index.rst:574
msgid ""
"The following script shows creation and search with a BITSET index. "
"Notice: BITSET cannot be unique, so first a primary-key index is created."
" Notice: bit values are entered as hexadecimal literals for easier "
"reading."
msgstr ""
"Следующий скрипт показывает создание BITSET-индекса и поиск по нему. "
"Обратите внимание, что битовое множество BITSET не может быть уникальным,"
" поэтому сначала создается первичный индекс. Обратите внимание, что "
"битовые значения вводятся как шестнадцатеричные литералы для удобства "
"чтения."

#: ../doc/book/box/box_index.rst:578
msgid ""
"tarantool> s = box.schema.space.create('space_with_bitset')\n"
"tarantool> s:create_index('primary_index', {\n"
"         >   parts = {1, 'string'},\n"
"         >   unique = true,\n"
"         >   type = 'TREE'\n"
"         > })\n"
"tarantool> s:create_index('bitset_index', {\n"
"         >   parts = {2, 'unsigned'},\n"
"         >   unique = false,\n"
"         >   type = 'BITSET'\n"
"         > })\n"
"tarantool> s:insert{'Tuple with bit value = 01', 0x01}\n"
"tarantool> s:insert{'Tuple with bit value = 10', 0x02}\n"
"tarantool> s:insert{'Tuple with bit value = 11', 0x03}\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.EQ\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ANY_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_NOT_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 01', 1]\n"
"..."
msgstr ""
"tarantool> s = box.schema.space.create('space_with_bitset')\n"
"tarantool> s:create_index('primary_index', {\n"
"         >   parts = {1, 'string'},\n"
"         >   unique = true,\n"
"         >   type = 'TREE'\n"
"         > })\n"
"tarantool> s:create_index('bitset_index', {\n"
"         >   parts = {2, 'unsigned'},\n"
"         >   unique = false,\n"
"         >   type = 'BITSET'\n"
"         > })\n"
"tarantool> s:insert{'Tuple with bit value = 01', 0x01}\n"
"tarantool> s:insert{'Tuple with bit value = 10', 0x02}\n"
"tarantool> s:insert{'Tuple with bit value = 11', 0x03}\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.EQ\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ANY_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_NOT_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 01', 1]\n"
"..."

#: ../doc/book/box/box_index.rst:625
msgid ""
"Search for a tuple via the given index, as described :ref:`earlier "
"<box_index-note>`."
msgstr ""
"Поиск кортежа по заданному индексу, как описано :ref:`выше <box_index-"
"note>`."

#: ../doc/book/box/box_index.rst:631
msgid "the tuple whose index-key fields are equal to the passed key values."
msgstr "кортеж, в котором поля ключа в индексе равны переданным значениям ключа."

#: ../doc/book/box/box_index.rst:632 ../doc/book/box/box_index.rst:668
#: ../doc/book/box/box_index.rst:699 ../doc/book/box/box_index.rst:728
#: ../doc/book/box/box_index.rst:792 ../doc/book/box/box_index.rst:809
#: ../doc/book/box/box_space.rst:190 ../doc/book/box/box_space.rst:712
#: ../doc/book/box/box_space.rst:969 ../doc/book/box/box_space.rst:1021
#: ../doc/book/box/box_space.rst:1347 ../doc/book/box/box_space.rst:1573
#: ../doc/book/box/box_tuple.rst:89 ../doc/book/box/box_tuple.rst:364
#: ../doc/book/box/box_tuple.rst:365 ../doc/book/box/box_tuple.rst:552
msgid "tuple"
msgstr "кортеж"

#: ../doc/book/box/box_index.rst:636
msgid "no such index;"
msgstr "отсутствие такого индекса;"

#: ../doc/book/box/box_index.rst:637
msgid "wrong type;"
msgstr "неправильный тип;"

#: ../doc/book/box/box_index.rst:638
msgid "more than one tuple matches."
msgstr "больше одного кортежа подходят."

#: ../doc/book/box/box_index.rst:640
msgid ""
"**Complexity factors:** Index size, Index type. See also "
":ref:`space_object:get() <box_space-get>`."
msgstr ""
"**Факторы сложности:** Размер индекса, тип индекса. См. также "
":ref:`space_object:get() <box_space-get>`."

#: ../doc/book/box/box_index.rst:645
msgid ""
"tarantool> box.space.tester.index.primary:get(2)\n"
"---\n"
"- [2, 'Music']\n"
"..."
msgstr ""
"tarantool> box.space.tester.index.primary:get(2)\n"
"---\n"
"- [2, 'Music']\n"
"..."

#: ../doc/book/box/box_index.rst:656
msgid "Find the minimum value in the specified index."
msgstr "Поиск минимального значения в указанном индексе."

#: ../doc/book/box/box_index.rst:662
#, fuzzy
msgid ""
"the tuple for the first key in the index. If optional ``key`` value is "
"supplied, returns the first key which is greater than or equal to ``key``"
" value. Starting with Tarantool version 2.0, index_object:min(``key`` "
"value) will return nothing if ``key`` value is not equal to a value in "
"the index."
msgstr ""
"кортеж для первого ключа в индексе. Если указано необязательное значение "
"ключа ``key``, будет выведен первый ключ, который больше или равен "
"значению ключа ``key``. В будущей версии Tarantool'а index:min(значение "
"``key``) не вернет ничего, если значение ``key`` не равно значению в "
"индексе."

#: ../doc/book/box/box_index.rst:670 ../doc/book/box/box_index.rst:701
msgid "**Possible errors:** index is not of type 'TREE'."
msgstr "**Возможные ошибки:** тип индекса не 'TREE'."

#: ../doc/book/box/box_index.rst:672 ../doc/book/box/box_index.rst:703
#: ../doc/book/box/box_index.rst:730 ../doc/book/box/box_space.rst:1266
#: ../doc/book/box/box_space.rst:1425
msgid "**Complexity factors:** Index size, Index type."
msgstr "**Факторы сложности:** Размер индекса, тип индекса."

#: ../doc/book/box/box_index.rst:676
msgid ""
"tarantool> box.space.tester.index.primary:min()\n"
"---\n"
"- ['Alpha!', 55, 'This is the first tuple!']\n"
"..."
msgstr ""
"tarantool> box.space.tester.index.primary:min()\n"
"---\n"
"- ['Alpha!', 55, 'This is the first tuple!']\n"
"..."

#: ../doc/book/box/box_index.rst:687
msgid "Find the maximum value in the specified index."
msgstr "Поиск максимального значения в указанном индексе."

#: ../doc/book/box/box_index.rst:693
#, fuzzy
msgid ""
"the tuple for the last key in the index. If optional ``key`` value is "
"supplied, returns the last key which is less than or equal to ``key`` "
"value. Starting with Tarantool version 2.0, index_object:max(``key`` "
"value) will return nothing if ``key`` value is not equal to a value in "
"the index."
msgstr ""
"кортеж для последнего ключа в индексе. Если указано необязательное "
"значение ключа ``key``, будет выведен последний ключ, который меньше или "
"равен значению ключа ``key``. В будущей версии Tarantool'а "
"index:max(значение ``key``) не вернет ничего, если значение ``key`` не "
"равно значению в индексе."

#: ../doc/book/box/box_index.rst:707
msgid ""
"tarantool> box.space.tester.index.primary:max()\n"
"---\n"
"- ['Gamma!', 55, 'This is the third tuple!']\n"
"..."
msgstr ""
"tarantool> box.space.tester.index.primary:max()\n"
"---\n"
"- ['Gamma!', 55, 'This is the third tuple!']\n"
"..."

#: ../doc/book/box/box_index.rst:718
msgid ""
"Find a random value in the specified index. This method is useful when "
"it's important to get insight into data distribution in an index without "
"having to iterate over the entire data set."
msgstr ""
"Поиск случайного значения в заданном индексе. Данный метод используется, "
"когда важно получить представление о распределении данных в индексе без "
"необходимости проходить по всему набору данных."

#: ../doc/book/box/box_index.rst:725
msgid "an arbitrary non-negative integer"
msgstr "произвольное неотрицательное целое число"

#: ../doc/book/box/box_index.rst:727
msgid "the tuple for the random key in the index."
msgstr "кортеж для случайного ключа в индексе."

#: ../doc/book/box/box_index.rst:732
msgid "**Note re storage engine:** vinyl does not support ``random()``."
msgstr "**Примечание про движок базы данных:** vinyl не поддерживает ``random()``."

#: ../doc/book/box/box_index.rst:736
msgid ""
"tarantool> box.space.tester.index.secondary:random(1)\n"
"---\n"
"- ['Beta!', 66, 'This is the second tuple!']\n"
"..."
msgstr ""
"tarantool> box.space.tester.index.secondary:random(1)\n"
"---\n"
"- ['Beta!', 66, 'This is the second tuple!']\n"
"..."

#: ../doc/book/box/box_index.rst:747
msgid ""
"Iterate over an index, counting the number of tuples which match the key-"
"value."
msgstr ""
"Итерация по индексу с подсчетом количества кортежей, которые "
"соответствуют паре ключ-значение."

#: ../doc/book/box/box_index.rst:753 ../doc/book/box/box_space.rst:248
msgid "comparison method"
msgstr "метод сопоставления"

#: ../doc/book/box/box_index.rst:755
msgid "the number of matching tuples."
msgstr "количество совпадающих кортежей."

#: ../doc/book/box/box_index.rst:756 ../doc/book/box/box_index.rst:913
#: ../doc/book/box/box_schema.rst:135 ../doc/book/box/box_schema.rst:148
#: ../doc/book/box/box_session.rst:82 ../doc/book/box/box_session.rst:89
#: ../doc/book/box/box_session.rst:118 ../doc/book/box/box_session.rst:207
#: ../doc/book/box/box_session.rst:238 ../doc/book/box/box_space.rst:303
#: ../doc/book/box/box_space.rst:317 ../doc/book/box/box_space.rst:322
#: ../doc/book/box/box_space.rst:324 ../doc/book/box/box_space.rst:326
#: ../doc/book/box/box_space.rst:328 ../doc/book/box/box_space.rst:330
#: ../doc/book/box/box_tuple.rst:123 ../doc/book/box/box_tuple.rst:157
#: ../doc/book/box/box_tuple.rst:320
msgid "number"
msgstr "число"

#: ../doc/book/box/box_index.rst:760
msgid ""
"tarantool> box.space.tester.index.primary:count(999)\n"
"---\n"
"- 0\n"
"...\n"
"tarantool> box.space.tester.index.primary:count('Alpha!', { iterator = "
"'LE' })\n"
"---\n"
"- 1\n"
"..."
msgstr ""
"tarantool> box.space.tester.index.primary:count(999)\n"
"---\n"
"- 0\n"
"...\n"
"tarantool> box.space.tester.index.primary:count('Alpha!', { iterator = "
"'LE' })\n"
"---\n"
"- 1\n"
"..."

#: ../doc/book/box/box_index.rst:775 ../doc/book/box/box_space.rst:1531
#: ../doc/book/box/box_tuple.rst:529
msgid "Update a tuple."
msgstr "Обновление кортежа."

#: ../doc/book/box/box_index.rst:777
msgid ""
"Same as :ref:`box.space...update() <box_space-update>`, but key is "
"searched in this index instead of primary key. This index ought to be "
"unique."
msgstr ""
"То же, что и :ref:`box.space...update() <box_space-update>`, но поиск "
"ключа происходит в этом индексе, вместо первичного. Данный индекс должен "
"быть уникальным."

#: ../doc/book/box/box_index.rst:784 ../doc/book/box/box_space.rst:1565
#: ../doc/book/box/box_space.rst:1686
msgid "operation type represented in string"
msgstr "тип операции, представленный строкой"

#: ../doc/book/box/box_index.rst:785 ../doc/book/box/box_space.rst:1566
#: ../doc/book/box/box_space.rst:1687 ../doc/book/box/box_tuple.rst:545
msgid ""
"what field the operation will apply to. The field number can be negative,"
" meaning the position from the end of tuple. (#tuple + negative field "
"number + 1)"
msgstr ""
"к какому полю применяется операция. Номер поля может быть отрицательным, "
"что означает, что позиция рассчитывается с конца кортежа. (#кортеж + "
"отрицательный номер поля + 1)"

#: ../doc/book/box/box_index.rst:789 ../doc/book/box/box_space.rst:1570
#: ../doc/book/box/box_space.rst:1691 ../doc/book/box/box_tuple.rst:549
msgid "what value will be applied"
msgstr "какое значение применяется"

#: ../doc/book/box/box_index.rst:791 ../doc/book/box/box_space.rst:1572
msgid "the updated tuple."
msgstr "обновленный кортеж."

#: ../doc/book/box/box_index.rst:798
msgid "Delete a tuple identified by a key."
msgstr "Удаление кортежа по ключу."

#: ../doc/book/box/box_index.rst:800
msgid ""
"Same as :ref:`box.space...delete() <box_space-delete>`, but key is "
"searched in this index instead of in the primary-key index. This index "
"ought to be unique."
msgstr ""
"То же, что и :ref:`box.space...delete() <box_space-delete>`, но поиск "
"ключа происходит в этом индексе, вместо первичного. Данный индекс должен "
"быть уникальным."

#: ../doc/book/box/box_index.rst:808
msgid "the deleted tuple."
msgstr "удаленный кортеж."

#: ../doc/book/box/box_index.rst:811
msgid ""
"**Note re storage engine:** vinyl will return `nil`, rather than the "
"deleted tuple."
msgstr ""
"**Примечание про движок базы данных:** vinyl вернет `nil`, а не удаленный"
" кортеж."

#: ../doc/book/box/box_index.rst:818
msgid ""
"Alter an index. It is legal in some circumstances to change one or more "
"of the index characteristics, for example its type, its sequence options,"
" its parts, and whether it is unique, Usually this causes rebuilding of "
"the space,  except for the simple case where a part's ``is_nullable`` "
"flag is changed from ``false`` to ``true``."
msgstr ""
"Изменение индекса. В определенных обстоятельствах можно изменять "
"некоторые характеристики индекса, например тип, параметры "
"последовательности и определение его уникальности. Тем не менее, это "
"обычно приводит к перестроению спейса за исключением простого случая, "
"когда значение флага ``is_nullable`` меняется с ``false`` на ``true``."

#: ../doc/book/box/box_index.rst:827
msgid ""
"options list, same as the options list for ``create_index``, see the "
"chart named :ref:`Options for space_object:create_index() <box_space-"
"create_index>`."
msgstr ""
"список параметров, аналогичный списку параметров для ``create_index``, "
"см. таблицу под названием :ref:`Параметры для space_object:create_index()"
" <box_space-create_index>`."

#: ../doc/book/box/box_index.rst:831 ../doc/book/box/box_index.rst:889
#: ../doc/book/box/box_schema.rst:238 ../doc/book/box/box_schema.rst:456
#: ../doc/book/box/box_schema.rst:611 ../doc/book/box/box_schema.rst:661
#: ../doc/book/box/box_space.rst:749 ../doc/book/box/box_space.rst:1316
#: ../doc/book/box/box_space.rst:1375 ../doc/book/box/box_space.rst:1505
#: ../doc/book/box/data_model.rst:153
msgid "nil"
msgstr "nil"

#: ../doc/book/box/box_index.rst:835 ../doc/book/box/box_index.rst:867
msgid "index does not exist,"
msgstr "индекс не существует,"

#: ../doc/book/box/box_index.rst:836
msgid "the primary-key index cannot be changed to ``{unique = false}``."
msgstr ""
"индекс по первичному ключу не может быть неуникальным, то есть нельзя "
"задать ``{unique = false}``."

#: ../doc/book/box/box_index.rst:838
msgid ""
"**Note re storage engine:** vinyl does not support ``alter()`` of a "
"primary-key index unless the space is empty."
msgstr ""
"**Примечание про движок базы данных:** vinyl не поддерживает ``alter()`` "
"для первичного индекса, если спейс содержит данные."

#: ../doc/book/box/box_index.rst:843
msgid ""
"tarantool> box.space.space55.index.primary:alter({type = 'HASH'})\n"
"---\n"
"...\n"
"\n"
"tarantool> box.space.vinyl_space.index.i:alter({page_size=4096})\n"
"---\n"
"..."
msgstr ""
"tarantool> box.space.space55.index.primary:alter({type = 'HASH'})\n"
"---\n"
"...\n"
"\n"
"tarantool> box.space.vinyl_space.index.i:alter({page_size=4096})\n"
"---\n"
"..."

#: ../doc/book/box/box_index.rst:857
msgid ""
"Drop an index. Dropping a primary-key index has a side effect: all tuples"
" are deleted."
msgstr ""
"Удаление индекса. Побочный эффект удаления первичного индекса -- все "
"кортежи удалятся."

#: ../doc/book/box/box_index.rst:863
msgid "nil."
msgstr "nil."

#: ../doc/book/box/box_index.rst:868
msgid "a primary-key index cannot be dropped while a secondary-key index exists."
msgstr "первичный индекс невозможно удалить, если существует вторичный индекс."

#: ../doc/book/box/box_index.rst:873
msgid ""
"tarantool> box.space.space55.index.primary:drop()\n"
"---\n"
"..."
msgstr ""
"tarantool> box.space.space55.index.primary:drop()\n"
"---\n"
"..."

#: ../doc/book/box/box_index.rst:883
msgid "Rename an index."
msgstr "Переименование индекса."

#: ../doc/book/box/box_index.rst:887
msgid "new name for index"
msgstr "новое имя индекса"

#: ../doc/book/box/box_index.rst:891
msgid "**Possible errors:** index_object does not exist."
msgstr "**Возможные ошибки:** index_object не существует."

#: ../doc/book/box/box_index.rst:895
msgid ""
"tarantool> box.space.space55.index.primary:rename('secondary')\n"
"---\n"
"..."
msgstr ""
"tarantool> box.space.space55.index.primary:rename('secondary')\n"
"---\n"
"..."

#: ../doc/book/box/box_index.rst:901 ../doc/book/box/box_space.rst:1503
msgid "**Complexity factors:** Index size, Index type, Number of tuples accessed."
msgstr ""
"**Факторы сложности:** Размер индекса, тип индекса, количество кортежей, "
"к которым получен доступ."

#: ../doc/book/box/box_index.rst:907
msgid "Return the total number of bytes taken by the index."
msgstr "Возврат общего количества байтов, занятых индексом."

#: ../doc/book/box/box_index.rst:912 ../doc/book/box/box_tuple.rst:156
msgid "number of bytes"
msgstr "количество байтов"

#: ../doc/book/box/box_index.rst:919
msgid "Return statistics about actions taken that affect the index."
msgstr "Получение статистики о предпринятых действиях, которые влияют на индекс."

#: ../doc/book/box/box_index.rst:921
msgid "This is for use with the vinyl engine."
msgstr "Используется с движком базы данных vinyl."

#: ../doc/book/box/box_index.rst:923
msgid "Some detail items in the output from ``index_object:stat()`` are:"
msgstr "Подробные данные в выводе ``index_object:stat()``:"

#: ../doc/book/box/box_index.rst:925
msgid "``index_object:stat().latency`` -- timings subdivided by percentages;"
msgstr "``index_object:stat().latency`` содержит отметки времени в процентах;"

#: ../doc/book/box/box_index.rst:926
msgid "``index_object:stat().bytes`` -- the number of bytes total;"
msgstr "``index_object:stat().bytes`` содержит общее количество байтов;"

#: ../doc/book/box/box_index.rst:927
msgid ""
"``index_object:stat().disk.rows`` -- the approximate number of tuples in "
"each range;"
msgstr ""
"``index_object:stat().disk.rows`` содержит примерное количество кортежей "
"в каждом диапазоне;"

#: ../doc/book/box/box_index.rst:928
msgid ""
"``index_object:stat().disk.statement`` -- counts of "
"inserts|updates|upserts|deletes;"
msgstr ""
"``index_object:stat().disk.statement`` содержит количество вставок, "
"обновлений, обновлений и вставок, удалений "
"(inserts|updates|upserts|deletes);"

#: ../doc/book/box/box_index.rst:929
msgid ""
"``index_object:stat().disk.compaction`` -- counts of compactions and "
"their amounts;"
msgstr ""
"``index_object:stat().disk.compaction`` содержит количество слияний и их "
"объем;"

#: ../doc/book/box/box_index.rst:930
msgid "``index_object:stat().disk.dump`` -- counts of dumps and their amounts;"
msgstr "``index_object:stat().disk.dump`` содержит количество дампов и их объем;"

#: ../doc/book/box/box_index.rst:931
msgid ""
"``index_object:stat().disk.iterator.bloom`` -- counts of bloom filter "
"hits|misses;"
msgstr ""
"``index_object:stat().disk.iterator.bloom`` содержит количество "
"совпадений и несовпадений по фильтрами Блума;"

#: ../doc/book/box/box_index.rst:932
msgid "``index_object:stat().disk.pages`` -- the size in pages;"
msgstr "``index_object:stat().disk.pages`` содержит размер в страницах;"

#: ../doc/book/box/box_index.rst:933
msgid ""
"``index_object:stat().disk.last_level`` -- size of data in the last LSM "
"tree level;"
msgstr ""
"``index_object:stat().disk.last_level`` содержит объем данных на "
"последнем уровне LSM-дерева;"

#: ../doc/book/box/box_index.rst:934
msgid "``index_object:stat().cache.evict`` -- number of evictions from the cache;"
msgstr "``index_object:stat().cache.evict`` содержит количество освобождений кэша;"

#: ../doc/book/box/box_index.rst:935
msgid "``index_object:stat().range_size`` -- maximum number of bytes in a range;"
msgstr ""
"``index_object:stat().range_size`` содержит максимальное количество "
"байтов в диапазоне;"

#: ../doc/book/box/box_index.rst:936
msgid ""
"``index_object:stat().dumps_per_compaction`` -- average number of dumps "
"required to trigger major compaction in any range of the LSM tree."
msgstr ""
"``index_object:stat().dumps_per_compaction`` содержит среднее число "
"дампов, которое необходимо для запуска значительного слияния в любом "
"диапазоне LSM-дерева."

#: ../doc/book/box/box_index.rst:938
msgid ""
"Summary index statistics are also available via :ref:`box.stat.vinyl() "
"<box_introspection-box_stat_vinyl_details>`."
msgstr ""
"С помощью :ref:`box.stat.vinyl() <box_introspection-"
"box_stat_vinyl_details>` можно получить сводную статистику по индексу."

#: ../doc/book/box/box_index.rst:944
msgid "statistics"
msgstr "статистические данные"

#: ../doc/book/box/box_index.rst:951
msgid ""
"Remove unused index space. For the memtx storage engine this method does "
"nothing; ``index_object:compact()`` is only for the vinyl storage engine."
" For example, with vinyl, if a tuple is deleted, the space is not "
"immediately reclaimed. There is a scheduler for reclaiming space "
"automatically based on factors such as lsm shape and amplification as "
"discussed in the section :ref:`Storing data with vinyl <engines-vinyl>`, "
"so calling ``index_object:compact()`` manually is not always necessary."
msgstr ""
"Удаление неиспользуемого пространства индекса. Для движка базы данных "
"memtx метод бесполезен; ``index_object:compact()`` используется только "
"для движка vinyl. Например, на движке vinyl при удалении кортежа память "
"не возвращается незамедлительно. Существует планировщик автоматического "
"восстановления ресурсов на основании таких факторов, как форма LSM-дерева"
" и усложнение, как описано в разделе :ref:`Хранение данных с помощью "
"vinyl <engines-vinyl>`, поэтому выполнять ``index_object:compact()`` "
"вручную необходимости нет."

#: ../doc/book/box/box_index.rst:960
msgid "nil (Tarantool returns without waiting for compaction to complete)"
msgstr ""
"nil (Tarantool возвращает нулевое значение сразу же, не ожидая завершения"
" слияния)"

#: ../doc/book/box/box_index.rst:967
msgid ""
"Users can define any functions they want, and associate them with "
"indexes: in effect they can make their own index methods. They do this "
"by:"
msgstr ""
"Пользователи могут сами определять любые желаемые функции и связывать их "
"с индексами: фактически они могут создавать собственные методы для работы"
" с индексом. Это можно сделать так:"

#: ../doc/book/box/box_index.rst:971 ../doc/book/box/box_space.rst:1722
msgid "creating a Lua function,"
msgstr "создать Lua-функцию,"

#: ../doc/book/box/box_index.rst:972 ../doc/book/box/box_space.rst:1723
msgid ""
"adding the function name to a predefined global variable which has type ="
" table, and"
msgstr ""
"добавить имя функции в заданную глобальную переменную с типом \"таблица\""
" (table),"

#: ../doc/book/box/box_index.rst:974
msgid ""
"invoking the function any time thereafter, as long as the server is up, "
"by saying ``index_object:function-name([parameters])``."
msgstr ""
"впоследствии в любое время, пока работает сервер, вызвать функцию с "
"помощью ``объект_индекса:имя-функции([параметры])``."

#: ../doc/book/box/box_index.rst:977
msgid "There are three predefined global variables:"
msgstr "Есть три заданные глобальные переменные:"

#: ../doc/book/box/box_index.rst:979
msgid ""
"Adding to ``box_schema.index_mt`` makes the method available for all "
"indexes."
msgstr ""
"Метод, добавленный в ``box_schema.index_mt``, будет доступен для всех "
"индексов."

#: ../doc/book/box/box_index.rst:980
msgid ""
"Adding to ``box_schema.memtx_index_mt`` makes the method available for "
"all memtx indexes."
msgstr ""
"Метод, добавленный в ``box_schema.memtx_index_mt``, будет доступен для "
"всех индексов в memtx'е."

#: ../doc/book/box/box_index.rst:981
msgid ""
"Adding to ``box_schema.vinyl_index_mt`` makes the method available for "
"all vinyl indexes."
msgstr ""
"Метод, добавленный в ``box_schema.vinyl_index_mt``, будет доступен для "
"всех индексов в vinyl'е."

#: ../doc/book/box/box_index.rst:983
msgid ""
"Alternatively, user-defined methods can be made available for only one "
"index, by calling ``getmetatable(index_object)`` and then adding the "
"function name to the meta table."
msgstr ""
"Можно также сделать задаваемый пользователем метод доступным только для "
"одного индекса путем вызова ``getmetatable(объект_индекса)`` и "
"последующего добавления имени функции в метатаблицу."

#: ../doc/book/box/box_index.rst:989 ../doc/book/box/box_space.rst:1738
msgid "whatever the user defines"
msgstr "то, что определяет пользователь"

#: ../doc/book/box/box_index.rst:993
msgid ""
"-- Visible to any index of a memtx space, no parameters.\n"
"-- After these requests, the value of global_variable will be 6.\n"
"box.schema.space.create('t', {engine='memtx'})\n"
"box.space.t:create_index('i')\n"
"global_variable = 5\n"
"function f() global_variable = global_variable + 1 end\n"
"box.schema.memtx_index_mt.counter = f\n"
"box.space.t.index.i:counter()"
msgstr ""
"-- Доступный для любого индекса спейса memtx, без параметров.\n"
"-- После таких запросов значение глобальной переменной global_variable "
"будет 6.\n"
"box.schema.space.create('t', {engine='memtx'})\n"
"box.space.t:create_index('i')\n"
"global_variable = 5\n"
"function f() global_variable = global_variable + 1 end\n"
"box.schema.memtx_index_mt.counter = f\n"
"box.space.t.index.i:counter()"

#: ../doc/book/box/box_index.rst:1006
msgid ""
"-- Visible to index box.space.t.index.i only, 1 parameter.\n"
"-- After these requests, the value of X will be 1005.\n"
"box.schema.space.create('t', {engine='memtx', id = 1000})\n"
"box.space.t:create_index('i')\n"
"X = 0\n"
"i = box.space.t.index.i\n"
"function f(i_arg, param) X = X + param + i_arg.space_id end\n"
"box.schema.memtx_index_mt.counter = f\n"
"meta = getmetatable(i)\n"
"meta.counter = f\n"
"i:counter(5)"
msgstr ""
"-- Доступный только для индекса box.space.t.index.i, 1 параметр.\n"
"-- После таких запросов значение X будет 1005.\n"
"box.schema.space.create('t', {engine='memtx', id = 1000})\n"
"box.space.t:create_index('i')\n"
"X = 0\n"
"i = box.space.t.index.i\n"
"function f(i_arg, param) X = X + param + i_arg.space_id end\n"
"box.schema.memtx_index_mt.counter = f\n"
"meta = getmetatable(i)\n"
"meta.counter = f\n"
"i:counter(5)"

#: ../doc/book/box/box_index.rst:1022
msgid "Example showing use of the box functions"
msgstr "Пример использования функций box"

#: ../doc/book/box/box_index.rst:1024
msgid ""
"This example will work with the sandbox configuration described in the "
"preface. That is, there is a space named tester with a numeric primary "
"key. The example function will:"
msgstr ""
"Данный пример сработает на конфигурации из песочницы, описанной в "
"предисловии, то есть создан спейс под названием tester с первичным "
"числовым ключом. Функция в примере выполнит следующие действия:"

#: ../doc/book/box/box_index.rst:1028
msgid "select a tuple whose key value is 1000;"
msgstr "выбрать кортеж, значение ключа в котором равно 1000;"

#: ../doc/book/box/box_index.rst:1029
msgid "raise an error if the tuple already exists and already has 3 fields;"
msgstr ""
"выдать сообщение об ошибке, если такой кортеж уже существует и содержит 3"
" поля;"

#: ../doc/book/box/box_index.rst:1032
msgid "Insert or replace the tuple with:"
msgstr "вставить или заменить кортеж следующими данными:"

#: ../doc/book/box/box_index.rst:1031
msgid "field[1] = 1000"
msgstr "поле [1] = 1000"

#: ../doc/book/box/box_index.rst:1032
msgid "field[2] = a uuid"
msgstr "поле [2] = UUID"

#: ../doc/book/box/box_index.rst:1033
msgid "field[3] = number of seconds since 1970-01-01;"
msgstr "поле [3] = количество секунд с 01.01.1970;"

#: ../doc/book/box/box_index.rst:1034
msgid "Get field[3] from what was replaced;"
msgstr "получить поле [3] из того, что заменили;"

#: ../doc/book/box/box_index.rst:1035
msgid "Format the value from field[3] as yyyy-mm-dd hh:mm:ss.ffff;"
msgstr ""
"преобразовать значение из поля [3] в формат yyyy-mm-dd hh:mm:ss.ffff "
"(год-месяц-день час:минута:секунда.десятитысячные доли секунды);"

#: ../doc/book/box/box_index.rst:1036
msgid "Return the formatted value."
msgstr "вернуть преобразованное значение."

#: ../doc/book/box/box_index.rst:1038
msgid ""
"The function uses Tarantool box functions :ref:`box.space...select "
"<box_space-select>`, :ref:`box.space...replace <box_space-replace>`, "
":ref:`fiber.time <fiber-time>`, :ref:`uuid.str <uuid-str>`. The function "
"uses Lua functions `os.date()`_ and `string.sub()`_."
msgstr ""
"Данная функция использует функции box в Tarantool'е: "
":ref:`box.space...select <box_space-select>`, :ref:`box.space...replace "
"<box_space-replace>`, :ref:`fiber.time <fiber-time>`, :ref:`uuid.str "
"<uuid-str>`. Данная функция использует Lua-функции `os.date()`_ и "
"`string.sub()`_."

#: ../doc/book/box/box_index.rst:1047
#, python-format
msgid ""
"function example()\n"
"  local a, b, c, table_of_selected_tuples, d\n"
"  local replaced_tuple, time_field\n"
"  local formatted_time_field\n"
"  local fiber = require('fiber')\n"
"  table_of_selected_tuples = box.space.tester:select{1000}\n"
"  if table_of_selected_tuples ~= nil then\n"
"    if table_of_selected_tuples[1] ~= nil then\n"
"      if #table_of_selected_tuples[1] == 3 then\n"
"        box.error({code=1, reason='This tuple already has 3 fields'})\n"
"      end\n"
"    end\n"
"  end\n"
"  replaced_tuple = box.space.tester:replace\n"
"    {1000,  require('uuid').str(), tostring(fiber.time())}\n"
"  time_field = tonumber(replaced_tuple[3])\n"
"  formatted_time_field = os.date(\"%Y-%m-%d %H:%M:%S\", time_field)\n"
"  c = time_field % 1\n"
"  d = string.sub(c, 3, 6)\n"
"  formatted_time_field = formatted_time_field .. '.' .. d\n"
"  return formatted_time_field\n"
"end"
msgstr ""
"function example()\n"
"  local a, b, c, table_of_selected_tuples, d\n"
"  local replaced_tuple, time_field\n"
"  local formatted_time_field\n"
"  local fiber = require('fiber')\n"
"  table_of_selected_tuples = box.space.tester:select{1000}\n"
"  if table_of_selected_tuples ~= nil then\n"
"    if table_of_selected_tuples[1] ~= nil then\n"
"      if #table_of_selected_tuples[1] == 3 then\n"
"        box.error({code=1, reason='This tuple already has 3 fields'})\n"
"      end\n"
"    end\n"
"  end\n"
"  replaced_tuple = box.space.tester:replace\n"
"    {1000,  require('uuid').str(), tostring(fiber.time())}\n"
"  time_field = tonumber(replaced_tuple[3])\n"
"  formatted_time_field = os.date(\"%Y-%m-%d %H:%M:%S\", time_field)\n"
"  c = time_field % 1\n"
"  d = string.sub(c, 3, 6)\n"
"  formatted_time_field = formatted_time_field .. '.' .. d\n"
"  return formatted_time_field\n"
"end"

#: ../doc/book/box/box_index.rst:1072 ../doc/book/box/box_tuple.rst:601
msgid "... And here is what happens when one invokes the function:"
msgstr "... А вот что происходит, когда вызывается функция:"

#: ../doc/book/box/box_index.rst:1074
msgid ""
"tarantool> box.space.tester:delete(1000)\n"
"---\n"
"- [1000, '264ee2da03634f24972be76c43808254', '1391037015.6809']\n"
"...\n"
"tarantool> example(1000)\n"
"---\n"
"- 2014-01-29 16:11:51.1582\n"
"...\n"
"tarantool> example(1000)\n"
"---\n"
"- error: 'This tuple already has 3 fields'\n"
"..."
msgstr ""
"tarantool> box.space.tester:delete(1000)\n"
"---\n"
"- [1000, '264ee2da03634f24972be76c43808254', '1391037015.6809']\n"
"...\n"
"tarantool> example(1000)\n"
"---\n"
"- 2014-01-29 16:11:51.1582\n"
"...\n"
"tarantool> example(1000)\n"
"---\n"
"- error: 'This tuple already has 3 fields'\n"
"..."

#: ../doc/book/box/box_index.rst:1091
msgid "Example showing a user-defined iterator"
msgstr "Пример с заданным пользователем итератором"

#: ../doc/book/box/box_index.rst:1093
msgid ""
"Here is an example that shows how to build one's own iterator. The "
"``paged_iter`` function is an \"iterator function\", which will only be "
"understood by programmers who have read the Lua manual section `Iterators"
" and Closures <https://www.lua.org/pil/7.1.html>`_. It does paginated "
"retrievals, that is, it returns 10 tuples at a time from a table named "
"\"t\", whose primary key was defined with "
"``create_index('primary',{parts={1,'string'}})``."
msgstr ""
"Здесь приведен пример того, как создать свой собственный итератор. "
"Функция ``paged_iter`` представляет собой \"функцию с итератором\", что "
"поймут только разработчики, которые ознакомились с разделом руководства "
"по Lua `Итераторы и замыкания <https://www.lua.org/pil/7.1.html>`_. Она "
"делает постраничную выборку, то есть возвращает 10 кортежей одновременно "
"из таблицы под названием \"t\", первичный ключ которой определен с "
"помощью ``create_index('primary',{parts={1,'string'}})``."

#: ../doc/book/box/box_index.rst:1100
msgid ""
"function paged_iter(search_key, tuples_per_page)\n"
"  local iterator_string = \"GE\"\n"
"  return function ()\n"
"  local page = box.space.t.index[0]:select(search_key,\n"
"    {iterator = iterator_string, limit=tuples_per_page})\n"
"  if #page == 0 then return nil end\n"
"  search_key = page[#page][1]\n"
"  iterator_string = \"GT\"\n"
"  return page\n"
"  end\n"
"end"
msgstr ""
"function paged_iter(search_key, tuples_per_page)\n"
"  local iterator_string = \"GE\"\n"
"  return function ()\n"
"  local page = box.space.t.index[0]:select(search_key,\n"
"    {iterator = iterator_string, limit=tuples_per_page})\n"
"  if #page == 0 then return nil end\n"
"  search_key = page[#page][1]\n"
"  iterator_string = \"GT\"\n"
"  return page\n"
"  end\n"
"end"

#: ../doc/book/box/box_index.rst:1114
msgid ""
"Programmers who use ``paged_iter`` do not need to know why it works, they"
" only need to know that, if they call it within a loop, they will get 10 "
"tuples at a time until there are no more tuples."
msgstr ""
"Разработчикам, использующим ``paged_iter``, необязательно знать, почему "
"она работает, следует лишь понимать, что вызвав функцию в цикле, можно "
"получать 10 кортежей за раз до тех пор, пока кортежи не кончатся."

#: ../doc/book/box/box_index.rst:1118
msgid ""
"In this example the tuples are merely printed, a page at a time. But it "
"should be simple to change the functionality, for example by yielding "
"after each retrieval, or by breaking when the tuples fail to match some "
"additional criteria."
msgstr ""
"В данном примере кортежи лишь выводятся по странице за раз. Но легко "
"изменить функцию, например, путем передачи управления после каждой "
"выборки или с помощью прерывания, если кортежи не будут соответствовать "
"дополнительным критериям."

#: ../doc/book/box/box_index.rst:1123
msgid ""
"for page in paged_iter(\"X\", 10) do\n"
"  print(\"New Page. Number Of Tuples = \" .. #page)\n"
"  for i = 1, #page, 1 do\n"
"    print(page[i])\n"
"  end\n"
"end"
msgstr ""
"for page in paged_iter(\"X\", 10) do\n"
"  print(\"New Page. Number Of Tuples = \" .. #page)\n"
"  for i = 1, #page, 1 do\n"
"    print(page[i])\n"
"  end\n"
"end"

#: ../doc/book/box/box_index.rst:1136
msgid "Submodule `box.index` with index type = RTREE for spatial searches"
msgstr ""
"Вложенный модуль `box.index` с типом индекса RTREE для поиска в "
"пространственных данных"

#: ../doc/book/box/box_index.rst:1138
msgid ""
"The :ref:`box.index <box_index>` submodule may be used for spatial "
"searches if the index type is RTREE. There are operations for searching "
"*rectangles* (geometric objects with 4 corners and 4 sides) and *boxes* "
"(geometric objects with more than 4 corners and more than 4 sides, "
"sometimes called hyperrectangles). This manual uses the term *rectangle-"
"or-box* for the whole class of objects that includes both rectangles and "
"boxes. Only rectangles will be illustrated."
msgstr ""
"Вложенный модуль :ref:`box.index <box_index>` может использоваться для "
"поиска в пространственных данных, если тип индекса -- RTREE. Существуют "
"операции для поиска *прямоугольников* (геометрические фигуры с 4 углами и"
" 4 сторонами) и *параллелепипедов* (геометрические фигуры с количеством "
"углов более 4 и количеством сторон более 4, которые иногда называются "
"гиперпрямоугольниками). В данном руководстве используется термин "
"*прямоугольник-или-параллелепипед* для всего класса объектов, который "
"включает в себя прямоугольники и параллелепипеды. Примерами "
"иллюстрируются только прямоугольники."

#: ../doc/book/box/box_index.rst:1146
msgid ""
"Rectangles are described according to their X-axis (horizontal axis) and "
"Y-axis (vertical axis) coordinates in a grid of arbitrary size. Here is a"
" picture of four rectangles on a grid with 11 horizontal points and 11 "
"vertical points:"
msgstr ""
"Прямоугольники описаны в соответствии с координатами по оси X "
"(горизонтальной оси) и оси Y (вертикальной оси) на сетке произвольного "
"размера. Ниже представлен рисунок четырех прямоугольников на сетке с 11 "
"горизонтальными точками и 11 вертикальными точками:"

#: ../doc/book/box/box_index.rst:1150
msgid ""
"           X AXIS\n"
"           1   2   3   4   5   6   7   8   9   10  11\n"
"        1\n"
"        2  #-------+                                           "
"<-Rectangle#1\n"
"Y AXIS  3  |       |\n"
"        4  +-------#\n"
"        5          #-----------------------+                   "
"<-Rectangle#2\n"
"        6          |                       |\n"
"        7          |   #---+               |                   "
"<-Rectangle#3\n"
"        8          |   |   |               |\n"
"        9          |   +---#               |\n"
"        10         +-----------------------#\n"
"        11                                     #               "
"<-Rectangle#4"
msgstr ""
"           X AXIS\n"
"                1   2   3   4   5   6   7   8   9   10  11\n"
"             1\n"
"             2  #-------+                                           "
"<-Прямоугольник №1\n"
"     Y AXIS  3  |       |\n"
"             4  +-------#\n"
"             5          #-----------------------+                   "
"<-Прямоугольник №2\n"
"             6          |                       |\n"
"             7          |   #---+               |                   "
"<-Прямоугольник №3\n"
"             8          |   |   |               |\n"
"             9          |   +---#               |\n"
"             10         +-----------------------#\n"
"             11                                     #               "
"<-Прямоугольник №4"

#: ../doc/book/box/box_index.rst:1166
msgid ""
"The rectangles are defined according to this scheme: {X-axis coordinate "
"of top left, Y-axis coordinate of top left, X-axis coordinate of bottom "
"right, Y-axis coordinate of bottom right} -- or more succinctly: "
"{x1,y1,x2,y2}. So in the picture ... Rectangle#1 starts at position 1 on "
"the X axis and position 2 on the Y axis, and ends at position 3 on the X "
"axis and position 4 on the Y axis, so its coordinates are {1,2,3,4}. "
"Rectangle#2's coordinates are {3,5,9,10}. Rectangle#3's coordinates are "
"{4,7,5,9}. And finally Rectangle#4's coordinates are {10,11,10,11}. "
"Rectangle#4 is actually a \"point\" since it has zero width and zero "
"height, so it could have been described with only two digits: {10,11}."
msgstr ""
"Прямоугольники определяются в соответствии со следующей схемой: {верхняя "
"левая координата по оси X, верхняя левая координата по оси Y, нижняя "
"правая координата по оси X, нижняя правая координата по оси Y} -- или "
"коротко: {x1,y1,x2,y2}. Таким образом, на рисунке ... Прямоугольник № 1 "
"начинается в точке 1 по оси X и точке 2 по оси Y, а заканчивается в точке"
" 3 по оси X и точке 4 по оси Y, поэтому его координаты будут следующие: "
"{1,2,3,4}. Координаты Прямоугольника № 2: {3,5,9,10}. Координаты "
"Прямоугольника № 3: {4,7,5,9}. И наконец, координаты Прямоугольника № 4: "
"{10,11,10,11}. Прямоугольник № 4, на самом деле, является точкой, "
"поскольку у него нулевая ширина и нулевая высота, так что его можно "
"описать всего двумя числами: {10,11}."

#: ../doc/book/box/box_index.rst:1176
msgid ""
"Some relationships between the rectangles are: \"Rectangle#1's nearest "
"neighbor is Rectangle#2\", and \"Rectangle#3 is entirely inside "
"Rectangle#2\"."
msgstr ""
"Некоторые отношения между прямоугольниками могут быть описаны так: "
"\"Прямоугольник №1 является ближайшим соседом Прямоугольника №2\", а "
"\"Прямоугольник №3 полностью находится внутри Прямоугольника №2\"."

#: ../doc/book/box/box_index.rst:1179
msgid "Now let us create a space and add an RTREE index."
msgstr "Сейчас создадим спейс и добавим RTREE-индекс."

#: ../doc/book/box/box_index.rst:1181
msgid ""
"tarantool> s = box.schema.space.create('rectangles')\n"
"tarantool> i = s:create_index('primary', {\n"
"         >   type = 'HASH',\n"
"         >   parts = {1, 'unsigned'}\n"
"         > })\n"
"tarantool> r = s:create_index('rtree', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"
msgstr ""
"tarantool> s = box.schema.space.create('rectangles')\n"
"tarantool> i = s:create_index('primary', {\n"
"         >   type = 'HASH',\n"
"         >   parts = {1, 'unsigned'}\n"
"         > })\n"
"tarantool> r = s:create_index('rtree', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"

#: ../doc/book/box/box_index.rst:1194
msgid ""
"Field#1 doesn't matter, we just make it because we need a primary-key "
"index. (RTREE indexes cannot be unique and therefore cannot be primary-"
"key indexes.) The second field must be an \"array\", which means its "
"values must represent {x,y} points or {x1,y1,x2,y2} rectangles. Now let "
"us populate the table by inserting two tuples, containing the coordinates"
" of Rectangle#2 and Rectangle#4."
msgstr ""
"Поле №1 не имеет значения, мы создаем его лишь потому, что необходим "
"первичный индекс. (RTREE-индексы не могут быть уникальными, поэтому не "
"могут быть первичными индексами.) Второе поле должно быть массивом "
"(\"array\"), что означает, что его значения должны представлять собой "
"точки {x,y} или прямоугольники {x1,y1,x2,y2}. Заполним таблицу, вставив "
"два кортежа с координатами Прямоугольника №2 и Прямоугольника №4."

#: ../doc/book/box/box_index.rst:1200
msgid ""
"tarantool> s:insert{1, {3, 5, 9, 10}}\n"
"tarantool> s:insert{2, {10, 11}}"
msgstr ""
"tarantool> s:insert{1, {3, 5, 9, 10}}\n"
"tarantool> s:insert{2, {10, 11}}"

#: ../doc/book/box/box_index.rst:1205
msgid ""
"And now, following the description of `RTREE iterator types`_, we can "
"search the rectangles with these requests:"
msgstr ""
"Затем, после описания типов RTREE-итераторов (`RTREE iterator types`_), "
"можно произвести поиск прямоугольников с помощью данных запросов:"

#: ../doc/book/box/box_index.rst:1210
msgid ""
"tarantool> r:select({10, 11, 10, 11}, {iterator = 'EQ'})\n"
"---\n"
"- - [2, [10, 11]]\n"
"...\n"
"tarantool> r:select({4, 7, 5, 9}, {iterator = 'GT'})\n"
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"...\n"
"tarantool> r:select({1, 2, 3, 4}, {iterator = 'NEIGHBOR'})\n"
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"  - [2, [10, 11]]\n"
"..."
msgstr ""
"tarantool> r:select({10, 11, 10, 11}, {iterator = 'EQ'})\n"
"---\n"
"- - [2, [10, 11]]\n"
"...\n"
"tarantool> r:select({4, 7, 5, 9}, {iterator = 'GT'})\n"
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"...\n"
"tarantool> r:select({1, 2, 3, 4}, {iterator = 'NEIGHBOR'})\n"
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"  - [2, [10, 11]]\n"
"..."

#: ../doc/book/box/box_index.rst:1226
msgid ""
"Request#1 returns 1 tuple because the point {10,11} is the same as the "
"rectangle {10,11,10,11} (\"Rectangle#4\" in the picture). Request#2 "
"returns 1 tuple because the rectangle {4,7,5,9}, which was "
"\"Rectangle#3\" in the picture, is entirely within{3,5,9,10} which was "
"Rectangle#2. Request#3 returns 2 tuples, because the NEIGHBOR iterator "
"always returns all tuples, and the first returned tuple will be "
"{3,5,9,10} (\"Rectangle#2\" in the picture) because it is the closest "
"neighbor of {1,2,3,4} (\"Rectangle#1\" in the picture)."
msgstr ""
"Запрос №1 возвращает 1 кортеж, потому что точка {10,11} представляет "
"собой то же, что и прямоугольник {10,11,10,11} (\"Прямоугольник №4\" на "
"рисунке). Запрос № 2 возвращает 1 кортеж, потому что прямоугольник "
"{4,7,5,9}, который был \"Прямоугольником №3\" на рисунке находится "
"полностью внутри {3,5,9,10}, что представляет собой Прямоугольник № 2. "
"Запрос № 3 возвращает 2 кортежа, потому что итератор NEIGHBOR (сосед) "
"всегда возвращает все кортежи, а первым найденным кортежем будет "
"{3,5,9,10} (\"Прямоугольник №2\" на рисунке), потому что он является "
"ближайшим соседом {1,2,3,4} (\"Прямоугольник №1\" на рисунке)."

#: ../doc/book/box/box_index.rst:1234
msgid ""
"Now let us create a space and index for cuboids, which are rectangle-or-"
"boxes that have 6 corners and 6 sides."
msgstr ""
"Теперь создадим спейс и индекс для кубоидов, которые представляют собой "
"прямоугольники-или-параллелепипеды, у которых 6 углов и 6 сторон."

#: ../doc/book/box/box_index.rst:1237
msgid ""
"tarantool> s = box.schema.space.create('R')\n"
"tarantool> i = s:create_index('primary', {parts = {1, 'unsigned'}})\n"
"tarantool> r = s:create_index('S', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   dimension = 3,\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"
msgstr ""
"tarantool> s = box.schema.space.create('R')\n"
"tarantool> i = s:create_index('primary', {parts = {1, 'unsigned'}})\n"
"tarantool> r = s:create_index('S', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   dimension = 3,\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"

#: ../doc/book/box/box_index.rst:1248
msgid ""
"The additional option here is ``dimension=3``. The default dimension is "
"2, which is why it didn't need to be specified for the examples of "
"rectangle. The maximum dimension is 20. Now for insertions and selections"
" there will usually be 6 coordinates. For example:"
msgstr ""
"Здесь задается дополнительный параметр``dimension=3``. По умолчанию, "
"измерений 2, поэтому не было необходимости указывать данный параметр в "
"примерах для прямоугольника. Максимальное количество измерений -- 20. Что"
" касается вставки и выборки, здесь будет 6 координат. Например:"

#: ../doc/book/box/box_index.rst:1253
msgid ""
"tarantool> s:insert{1, {0, 3, 0, 3, 0, 3}}\n"
"tarantool> r:select({1, 2, 1, 2, 1, 2}, {iterator = box.index.GT})"
msgstr ""
"tarantool> s:insert{1, {0, 3, 0, 3, 0, 3}}\n"
"tarantool> r:select({1, 2, 1, 2, 1, 2}, {iterator = box.index.GT})"

#: ../doc/book/box/box_index.rst:1258
msgid ""
"Now let us create a space and index for Manhattan-style spatial objects, "
"which are rectangle-or-boxes that have a different way to calculate "
"neighbors."
msgstr ""
"Теперь создадим спейс и индекс для пространственных объектов с метрикой "
"расстояния городских кварталов (метрика Манхэттена), которые представляют"
" собой прямоугольники-или-параллелепипеды; соседи для них рассчитываются "
"иным образом."

#: ../doc/book/box/box_index.rst:1261
msgid ""
"tarantool> s = box.schema.space.create('R')\n"
"tarantool> i = s:create_index('primary', {parts = {1, 'unsigned'}})\n"
"tarantool> r = s:create_index('S', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   distance = 'manhattan',\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"
msgstr ""
"tarantool> s = box.schema.space.create('R')\n"
"tarantool> i = s:create_index('primary', {parts = {1, 'unsigned'}})\n"
"tarantool> r = s:create_index('S', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   distance = 'manhattan',\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"

#: ../doc/book/box/box_index.rst:1272
msgid ""
"The additional option here is ``distance='manhattan'``. The default "
"distance calculator is 'euclid', which is the straightforward as-the-"
"crow-flies method. The optional distance calculator is 'manhattan', which"
" can be a more appropriate method if one is following the lines of a grid"
" rather than traveling in a straight line."
msgstr ""
"Здесь задается дополнительный параметр ``distance='manhattan'``. По "
"умолчанию, расстояние измеряется по Евклидовой метрике, что лучше всего "
"подходит для измерений по прямой линии. Другой способ расчета расстояния "
"по метрике Манхэттена ('manhattan'), который больше подходит, если "
"необходимо следовать линиям сетки, а не по прямой."

#: ../doc/book/box/box_index.rst:1278
msgid ""
"tarantool> s:insert{1, {0, 3, 0, 3}}\n"
"tarantool> r:select({1, 2, 1, 2}, {iterator = box.index.NEIGHBOR})"
msgstr ""
"tarantool> s:insert{1, {0, 3, 0, 3}}\n"
"tarantool> r:select({1, 2, 1, 2}, {iterator = box.index.NEIGHBOR})"

#: ../doc/book/box/box_index.rst:1284
msgid ""
"More examples of spatial searching are online in the file `R tree index "
"quick start and usage`_."
msgstr ""
"Другие примеры поиска в пространственных данных см. по ссылке `R tree "
"index quick start and usage`_."

#: ../doc/book/box/box_info.rst:5 ../doc/book/box/box_introspection.rst:32
msgid "Submodule `box.info`"
msgstr "Вложенный модуль `box.info`"

#: ../doc/book/box/box_info.rst:9
msgid ""
"The ``box.info`` submodule provides access to information about server "
"instance variables."
msgstr ""
"Вложенный модуль ``box.info`` предоставляет доступ к информации о "
"переменных экземпляра сервера."

#: ../doc/book/box/box_info.rst:12
msgid ""
"**cluster.uuid** is the UUID of the replica set. Every instance in a "
"replica set will have the same ``cluster.uuid`` value. This value is also"
" stored in :ref:`box.space._schema <box_space-schema>` system space."
msgstr ""
"**cluster.uuid** -- это уникальный идентификатор набора реплик (UUID). У "
"каждого экземпляра в наборе реплик будет одно и то же значение "
"``cluster.uuid``. Данное значение также хранится в системном спейсе "
":ref:`box.space._schema <box_space-schema>`."

#: ../doc/book/box/box_info.rst:16
msgid ""
"**gc()** returns the state of the :ref:`Tarantool garbage collector "
"<cfg_checkpoint_daemon-garbage-collector>` including the checkpoints and "
"their consumers (users); see details :ref:`below <box_info_gc>`."
msgstr ""
"**gc()** возвращает состояние :ref:`сборщика мусора в Tarantool'е "
"<cfg_checkpoint_daemon-garbage-collector>`, в том числе контрольные точки"
" и их потребителей (пользователи); более подробную информацию см. :ref: "
"`ниже <box_info_gc>`."

#: ../doc/book/box/box_info.rst:20
msgid ""
"**id** corresponds to **replication.id** (see :ref:`below "
"<box_info_replication>`)."
msgstr ""
"**id** соответствует идентификатору **replication.id** (см. :ref:`ниже "
"<box_info_replication>`)."

#: ../doc/book/box/box_info.rst:22
msgid ""
"**lsn** corresponds to **replication.lsn** (see :ref:`below "
"<box_info_replication>`)."
msgstr ""
"**lsn** соответствует регистрационному номеру **replication.lsn** (см. "
":ref:`ниже <box_info_replication>`)."

#: ../doc/book/box/box_info.rst:24
msgid ""
"**memory()** returns the statistics about memory (see :ref:`below "
"<box_info_memory>`)."
msgstr ""
"**memory()** возвращает статистику об использовании памяти (см. "
":ref:`ниже <box_info_memory>`)."

#: ../doc/book/box/box_info.rst:26
msgid ""
"**pid** is the process ID. This value is also shown by :ref:`tarantool "
"<tarantool-build>` module and by the Linux command ``ps -A``."
msgstr ""
"**pid** – идентификатор процесса. Это значение также отображается с "
"помощью модуля :ref:`tarantool <tarantool-build>`  и по команде  ``ps "
"-A`` в Linux."

#: ../doc/book/box/box_info.rst:29
msgid ""
"**ro** is ``true`` if the instance is in \"read-only\" mode (same as "
":ref:`read_only <cfg_basic-read_only>` in ``box.cfg{}``), or if status is"
" 'orphan'."
msgstr ""
"**ro** принимает значение ``true``, если экземпляр находится в режиме "
"только для чтения \"read-only\" (как :ref:`read_only <cfg_basic-"
"read_only>` в ``box.cfg{}``), или в статусе 'orphan' (одиночный)."

#: ../doc/book/box/box_info.rst:32
msgid ""
"**signature** is the sum of all **lsn** values from the vector clocks "
"(**vclock**) of all instances in the replica set."
msgstr ""
"**signature** представляет собой сумму всех значений **lsn** из векторных"
" часов (**vclock**) всех экземпляров в наборе реплик."

#: ../doc/book/box/box_info.rst:34
msgid "**status** corresponds to **replication.upstream.status** (see below)."
msgstr ""
"**status** соответствует статусу **replication.upstream.status** (см. "
"ниже)."

#: ../doc/book/box/box_info.rst:35
msgid ""
"**uptime** is the number of seconds since the instance started. This "
"value can also be retrieved with :ref:`tarantool.uptime() <tarantool-"
"build>`."
msgstr ""
"**uptime** -- это количество секунд с момента запуска экземпляра. Данное "
"значение также можно получить с помощью :ref:`tarantool.uptime() "
"<tarantool-build>`."

#: ../doc/book/box/box_info.rst:38
msgid ""
"**uuid** corresponds to **replication.uuid** (see :ref:`below "
"<box_info_replication>`)."
msgstr ""
"**uuid** соответствует идентификатору **replication.uuid** (см. "
":ref:`ниже <box_info_replication>`)."

#: ../doc/book/box/box_info.rst:40
msgid ""
"**vclock** corresponds to **replication.downstream.vclock** (see "
":ref:`below <box_info_replication>`)."
msgstr ""
"**vclock** соответствует часам **replication.downstream.vclock** (см. "
":ref:`ниже <box_info_replication>`)."

#: ../doc/book/box/box_info.rst:42
msgid ""
"**version** is the Tarantool version. This value is also shown by "
":ref:`tarantool -V <index-tarantool_version>`."
msgstr ""
"**version** -- это версия Tarantool'а. Данное значение также можно "
"отобразить с помощью команды :ref:`tarantool -V <index-"
"tarantool_version>`."

#: ../doc/book/box/box_info.rst:44
msgid ""
"**vinyl()** returns runtime statistics for the vinyl storage engine. This"
" function is deprecated, use :ref:`box.stat.vinyl() <box_introspection-"
"box_stat_vinyl>` instead."
msgstr ""
"**vinyl** возвращает статистику времени работы для движка базы данных "
"vinyl. Данная функция объявлена устаревшей, используйте "
":ref:`box.stat.vinyl() <box_introspection-box_stat_vinyl>`."

#: ../doc/book/box/box_info.rst:52
msgid ""
"The **memory** function of ``box.info`` gives the ``admin`` user a "
"picture of the whole Tarantool instance."
msgstr ""
"Функция **memory** в ``box.info`` дает пользователю ``admin`` полное "
"представление об экземпляре Tarantool'а."

#: ../doc/book/box/box_info.rst:57
msgid ""
"To get a picture of the vinyl subsystem, use :ref:`box.stat.vinyl() "
"<box_introspection-box_stat_vinyl>` instead."
msgstr ""
"Чтобы получить представление о подсистеме vinyl'а, используйте "
":ref:`box.stat.vinyl() <box_introspection-box_stat_vinyl>`."

#: ../doc/book/box/box_info.rst:60
msgid ""
"**memory().cache** -- number of bytes used for caching user data. The "
"memtx storage engine does not require a cache, so in fact this is the "
"number of bytes in the cache for the tuples stored for the vinyl storage "
"engine."
msgstr ""
"**memory().cache** --это количество байтов, используемых для кэширования "
"данных пользователей. Движок базы данных memtx не нуждается в кэше, то "
"есть на самом деле это количество байтов в кэше для кортежей движка базы "
"данных vinyl."

#: ../doc/book/box/box_info.rst:64
msgid ""
"**memory().data** -- number of bytes used for storing user data (the "
"tuples) with the memtx engine and with level 0 of the vinyl engine, "
"without taking memory fragmentation into account."
msgstr ""
"**memory().data** -- количество байтов, используемых для хранения данных "
"пользователей (кортежи) в движке memtx и на уровне 0 движка vinyl, не "
"принимая во внимание фрагментацию памяти."

#: ../doc/book/box/box_info.rst:67
msgid ""
"**memory().index** -- number of bytes used for indexing user data, "
"including memtx and vinyl memory tree extents, the vinyl page index, and "
"the vinyl bloom filters."
msgstr ""
"**memory().index** -- количество байтов, используемых для индексирования "
"данных пользователей, включая экстенты для деревьев в memtx'е и vinyl'е, "
"индекс страниц и фильтры Блума в vinyl'е."

#: ../doc/book/box/box_info.rst:70
msgid "**memory().lua** -- number of bytes used for Lua runtime."
msgstr ""
"**memory().lua** -- количество байтов, используемых для времени "
"исполнения Lua-кода."

#: ../doc/book/box/box_info.rst:71
msgid "**memory().net** -- number of bytes used for network input/output buffers."
msgstr ""
"**memory().net** -- количество байтов, используемых буферами для сетевого"
" ввода-вывода."

#: ../doc/book/box/box_info.rst:72
msgid ""
"**memory().tx** -- number of bytes in use by active transactions. For the"
" vinyl storage engine, this is the total size of all allocated objects "
"(struct ``txv``, struct ``vy_tx``, struct ``vy_read_interval``) and "
"tuples pinned for those objects."
msgstr ""
"**memory().tx** -- количество байтов, используемых активными "
"транзакциями. Для движка базы данных vinyl это общий размер всех "
"размещаемых объектов (структура ``txv``, структура ``vy_tx``, структура "
"``vy_read_interval``) и кортежей, прикрепленных к этим объектам."

#: ../doc/book/box/box_info.rst:77
msgid ""
"An example with a minimum allocation while only the memtx storage engine "
"is in use:"
msgstr ""
"Пример с минимальным распределением, когда используется только движок "
"базы данных memtx:"

#: ../doc/book/box/box_info.rst:80
msgid ""
"tarantool> box.info.memory()\n"
"---\n"
"- cache: 0\n"
"  data: 6552\n"
"  tx: 0\n"
"  lua: 1315567\n"
"  net: 98304\n"
"  index: 1196032\n"
"..."
msgstr ""
"tarantool> box.info.memory()\n"
"---\n"
"- cache: 0\n"
"  data: 6552\n"
"  tx: 0\n"
"  lua: 1315567\n"
"  net: 98304\n"
"  index: 1196032\n"
"..."

#: ../doc/book/box/box_info.rst:96
msgid ""
"The **gc** function of ``box.info`` gives the ``admin`` user a picture of"
" the factors that affect the :ref:`Tarantool garbage collector "
"<cfg_checkpoint_daemon-garbage-collector>`. The garbage collector "
"compares vclock (:ref:`vector clock <replication-vector>`) values of "
"users and checkpoints, so a look at ``box.info.gc()`` may show why the "
"garbage collector has not removed old WAL files, or show what it may soon"
" remove."
msgstr ""
"Функция **gc** в ``box.info`` дает пользователю ``admin`` полное "
"представление о факторах, которые влияют на :ref:`сборщик мусора "
"Tarantool'а <cfg_checkpoint_daemon-garbage-collector>`. Сборщик мусора "
"сопоставляет значения vclock (:ref:`векторные часы <replication-vector>`)"
" пользователей и контрольных точек, поэтому взглянув на "
"``box.info.gc()``, можно понять, почему сборщик мусора не удалил старые "
"WAL-файлы или что он может вскоре удалить."

#: ../doc/book/box/box_info.rst:103
msgid ""
"**gc().consumers** -- a list of users whose requests might affect the "
"garbage collector."
msgstr ""
"**gc().consumers** -- список пользователей, запросы которых могут  "
"затронуть сборку мусора."

#: ../doc/book/box/box_info.rst:104
msgid "**gc().checkpoints** -- a list of preserved checkpoints."
msgstr "**gc().checkpoints** -- список сохраненных контрольных точек."

#: ../doc/book/box/box_info.rst:105
msgid ""
"**gc().checkpoints[n].references** -- a list of references to a "
"checkpoint."
msgstr "**gc().checkpoints[n].references** -- список ссылок на контрольную точку."

#: ../doc/book/box/box_info.rst:106
msgid "**gc().checkpoints[n].vclock** -- a checkpoint's vclock value."
msgstr "**gc().checkpoints[n].vclock** -- значение vclock контрольной точки."

#: ../doc/book/box/box_info.rst:107
msgid ""
"**gc().checkpoints[n].signature** -- a sum of a checkpoint's vclock's "
"components."
msgstr ""
"**gc().checkpoints[n].signature** -- сумма компонентов vclock контрольной"
" точки."

#: ../doc/book/box/box_info.rst:108
msgid ""
"**gc().checkpoint_is_in_progress** -- true if a checkpoint is in "
"progress, otherwise false"
msgstr ""
"**gc().checkpoint_is_in_progress** -- true если идет создание контрольной"
" точки, в противном случае false."

#: ../doc/book/box/box_info.rst:109
msgid "**gc().vclock** -- the garbage collector's vclock."
msgstr "**gc().vclock** -- vclock сборщика мусора."

#: ../doc/book/box/box_info.rst:110
msgid ""
"**gc().signature** -- the sum of the garbage collector's checkpoint's "
"components."
msgstr "**gc().signature** -- сумма компонентов контрольной точки сборщика мусора."

#: ../doc/book/box/box_info.rst:116
msgid ""
"The **replication** section of ``box.info()`` contains statistics for all"
" instances in the replica set in regard to the current instance (see also"
" :ref:`\"Monitoring a replica set\" <replication-monitoring>`):"
msgstr ""
"Раздел **replication** (репликация) во вложенном модуле ``box.info()`` "
"содержит статистику по всем экземплярам в наборе реплик относительно "
"текущего экземпляра (см. также :ref:`\"Мониторинг набора реплик\" "
"<replication-monitoring>`):"

#: ../doc/book/box/box_info.rst:120
msgid ""
"**replication.id** is a short numeric identifier of the instance within "
"the replica set."
msgstr ""
"**replication.id** -- это короткий числовой идентификатор экземпляра в "
"рамках набора реплик."

#: ../doc/book/box/box_info.rst:122
msgid ""
"**replication.uuid** is a globally unique identifier of the instance. "
"This value is also stored in :ref:`box.space._cluster <box_space-"
"cluster>` system space."
msgstr ""
"**replication.uuid** -- это глобально-уникальный идентификатор "
"экземпляра. Данное значение также хранится в системном спейсе "
":ref:`box.space._cluster <box_space-cluster>`."

#: ../doc/book/box/box_info.rst:125
msgid ""
"**replication.lsn** is the :ref:`log sequence number <replication-"
"mechanism>` (LSN) for the latest entry in the instance's :ref:`write "
"ahead log <index-box_persistence>` (WAL)."
msgstr ""
"**replication.lsn** -- это :ref:`номер в журнале <replication-mechanism>`"
" (LSN) для последней записи в :ref:`журнале упреждающей записи <index-"
"box_persistence>` (WAL) экземпляра."

#: ../doc/book/box/box_info.rst:129
msgid ""
"**replication.upstream** contains statistics for the replication data "
"uploaded by the instance."
msgstr ""
"**replication.upstream** содержит статистику по реплицируемым данным, "
"которые переданы экземпляром."

#: ../doc/book/box/box_info.rst:131
msgid "**replication.upstream.status** is the replication status of the instance:"
msgstr "**replication.upstream.status** -- это репликационный статус экземпляра:"

#: ../doc/book/box/box_info.rst:133
msgid ""
"``auth`` means that the instance is getting :ref:`authenticated "
"<authentication>` to connect to a replication source."
msgstr ""
"``auth`` означает, что экземпляр проходит :ref:`аутентификацию "
"<authentication>` для установки соединения с источником репликации."

#: ../doc/book/box/box_info.rst:136
msgid ""
"``connecting`` means that the instance is trying to connect to the "
"replications source(s) listed in its :ref:`replication <cfg_replication-"
"replication>` parameter."
msgstr ""
"``connecting`` означает, что экземпляр пытается установить соединение с "
"источниками репликации, перечисленными в параметре :ref:`replication "
"<cfg_replication-replication>`."

#: ../doc/book/box/box_info.rst:139
msgid ""
"``disconnected`` means that the instance is not connected to the replica "
"set (due to network problems, not replication errors)."
msgstr ""
"``disconnected`` означает, что экземпляр не подключен к набору реплик (по"
" причине проблем в сети, а не ошибок репликации)."

#: ../doc/book/box/box_info.rst:141
msgid "``follow`` means that replication is in progress."
msgstr "``follow`` означает, что идет репликация."

#: ../doc/book/box/box_info.rst:142
msgid ""
"``running`` means the instance's role is \"master\" (non read-only) and "
"replication is in progress."
msgstr ""
"``running`` означает, что роль экземпляра -- \"мастер\" (не только для "
"чтения), и идет репликация."

#: ../doc/book/box/box_info.rst:144
msgid ""
"``stopped`` means that replication was stopped due to a replication error"
" (e.g. :ref:`duplicate key <error_codes>`)."
msgstr ""
"``stopped`` означает, что репликация остановилась по причине ошибки "
"репликации (например, :ref:`повторяющийся ключ <error_codes>`)."

#: ../doc/book/box/box_info.rst:146
msgid ""
"``orphan`` means that the instance has not (yet) succeeded in joining the"
" required number of masters (see :ref:`orphan status <replication-"
"orphan_status>`)."
msgstr ""
"``orphan`` означает, что экземпляр (еще) не подключился к необходимому "
"количеству мастеров (см. :ref:`статус orphan <replication-"
"orphan_status>`)."

#: ../doc/book/box/box_info.rst:148
msgid ""
"``synch`` means that the master and replica are synchronizing to have the"
" same data."
msgstr ""
"``synch`` означает, что мастер и реплика в данный момент синхронизируются"
" для получения одинакового набора данных."

#: ../doc/book/box/box_info.rst:153
msgid ""
"**replication.upstream.idle** is the time (in seconds) since the instance"
" received the last event from a master. This is the primary indicator of "
"replication health. See more in :ref:`Monitoring a replica set "
"<replication-monitoring>`."
msgstr ""
"**replication.upstream.idle** -- это время (в секундах) с момента "
"получения экземпляром последнего события от мастера. Это основной "
"индикатор работоспособности репликации. Более подробную информацию см. в "
"разделе :ref:`Мониторинг набора реплик <replication-monitoring>`."

#: ../doc/book/box/box_info.rst:160
msgid ""
"**replication.upstream.peer** contains the replication user name, host IP"
" adress and port number used for the instance. See more in "
":ref:`Monitoring a replica set <replication-monitoring>`."
msgstr ""
"**replication.upstream.peer** содержит имя пользователя, запустившего "
"репликацию, IP-адрес хоста и номер порта, используемый для экземпляра. "
"Более подробную информацию см. в разделе :ref:`Мониторинг набора реплик "
"<replication-monitoring>`."

#: ../doc/book/box/box_info.rst:166
msgid ""
"**replication.upstream.lag** is the time difference between the local "
"time at the instance, recorded when the event was received, and the local"
" time at another master recorded when the event was written to the "
":ref:`write ahead log <internals-wal>` on that master. See more in "
":ref:`Monitoring a replica set <replication-monitoring>`."
msgstr ""
"**replication.upstream.lag** -- это разница во времени между локальным "
"временем на экземпляре, зарегистрированным при получении события, и "
"локальное время на другом мастере, зарегистрированное при записи события "
"в :ref:`журнал упреждающей записи <internals-wal>` на этом мастере. Более"
" подробную информацию см. в разделе :ref:`Мониторинг набора реплик "
"<replication-monitoring>`."

#: ../doc/book/box/box_info.rst:172
msgid ""
"**replication.upstream.message** contains an error message in case of a "
":ref:`degraded state <replication-recover>`, empty otherwise."
msgstr ""
"**replication.upstream.message** содержит сообщение об ошибке в случае "
":ref:`системного сбоя <replication-recover>`, в противном случае не "
"заполнен."

#: ../doc/book/box/box_info.rst:175
msgid ""
"**replication.downstream** contains statistics for the replication data "
"requested and downloaded from the instance."
msgstr ""
"**replication.downstream** содержит статистику по реплицируемым данным, "
"которые запрошены и загружены с экземпляра."

#: ../doc/book/box/box_info.rst:178
msgid ""
"**replication.downstream.vclock** contains the :ref:`vector clock "
"<replication-vector>`, which is a table of '**id**, **lsn**' pairs, for "
"example :code:`vclock: {1: 3054773, 4: 8938827, 3: 285902018}`. Even if "
"an instance is :ref:`removed <replication-remove_instances>`, its values "
"will still appear here."
msgstr ""
"**replication.downstream.vclock** содержит :ref:`векторные часы "
"<replication-vector>`, что представляет собой таблицу из пар '**id**, "
"**lsn**', например :code:`vclock: {1: 3054773, 4: 8938827, 3: "
"285902018}`. Даже если экземпляр :ref:`удален <replication-"
"remove_instances>`, тем не менее, значения с него появятся здесь."

#: ../doc/book/box/box_info.rst:185
#, fuzzy
msgid ""
"**replication.downstream.idle** is the time (in seconds) since the last "
"time this instance sent events through the downstream replication."
msgstr "**replication.upstream.status** -- это статус для downstream-репликации:"

#: ../doc/book/box/box_info.rst:188
msgid ""
"**replication.downstream.status** is the replication status for "
"downstream replications:"
msgstr "**replication.upstream.status** -- это статус для downstream-репликации:"

#: ../doc/book/box/box_info.rst:191
msgid "``stopped`` means that downstream replication has stopped."
msgstr "``stopped`` означает, что downstream-репликация остановлена."

#: ../doc/book/box/box_info.rst:192
msgid "``follow`` means that downstream replication is in progress."
msgstr "``follow`` означает, что downstream-репликация осуществляется."

#: ../doc/book/box/box_info.rst:196 ../doc/book/box/box_introspection.rst:70
msgid ""
"Since ``box.info`` contents are dynamic, it's not possible to iterate "
"over keys with the Lua ``pairs()`` function. For this purpose, "
"``box.info()`` builds and returns a Lua table with all keys and values "
"provided in the submodule."
msgstr ""
"Поскольку содержимое вложенного модуля ``box.info`` является "
"динамическим, невозможно провести итерацию по ключам с помощью "
"Lua-функции ``pairs()``. Для этой цели модуль ``box.info()`` создает и "
"возвращает Lua-таблицу со всеми ключами и значениями во вложенном модуле."

#: ../doc/book/box/box_info.rst:201
msgid "keys and values in the submodule"
msgstr "ключи и значения во вложенном модуле"

#: ../doc/book/box/box_info.rst:206
msgid ""
"This example is for a master-replica set that contains one master "
"instance and one replica instance. The request was issued at the replica "
"instance."
msgstr ""
"Данный пример приводится для набора со схемой мастер-реплика, который "
"включает в себя один мастер-экземпляр и один реплика-экземпляр. Запрос "
"был отправлен с реплики-экземпляра."

#: ../doc/book/box/box_info.rst:209
msgid ""
"tarantool> box.info()\n"
"---\n"
"- vinyl: []\n"
"  version: 2.2.0-482-g8c84932ad\n"
"  id: 2\n"
"  ro: true\n"
"  status: running\n"
"  vclock: {1: 9}\n"
"  uptime: 356\n"
"  lsn: 0\n"
"  memory: []\n"
"  cluster:\n"
"    uuid: e261a5bc-6303-4de3-9873-556f311255e0\n"
"  pid: 160\n"
"  gc: []\n"
"  signature: 9\n"
"  replication:\n"
"    1:\n"
"      id: 1\n"
"      uuid: fce71bb3-0e99-40ec-ab7e-5159487e18d1\n"
"      lsn: 9\n"
"      upstream:\n"
"        status: follow\n"
"        idle: 0.035709699994186\n"
"        peer: replicator@127.0.0.1:3401\n"
"        lag: 0.00016164779663086\n"
"      downstream:\n"
"        status: follow\n"
"        idle: 0.59840899999836\n"
"        vclock: {1: 9}\n"
"    2:\n"
"      id: 2\n"
"      uuid: bc4629ce-ea31-4f75-b805-a4807bcacc93\n"
"      lsn: 0\n"
"  uuid: bc4629ce-ea31-4f75-b805-a4807bcacc93\n"
"..."
msgstr ""

#: ../doc/book/box/box_introspection.rst:9
msgid ""
"The ``box.cfg`` submodule is for administrators to specify all the server"
" configuration parameters (see \"Configuration reference\" for :ref:`a "
"complete description of all configuration parameters <box_cfg_params>`). "
"Use ``box.cfg`` without braces to get read-only access to those "
"parameters."
msgstr ""
"С помощью вложенного модуля ``box.cfg`` администраторы могут указать все "
"конфигурационные параметры сервера (:ref:`полное описание всех "
"конфигурационных параметров <box_cfg_params>` см. в \"Справочнике по "
"настройке\"). Используйте ``box.cfg`` без скобок, чтобы получить доступ "
"для чтения этих параметров."

#: ../doc/book/box/box_introspection.rst:36
msgid ""
"The ``box.info`` submodule provides access to information about server "
"instance variables. Some of this information is also available from the "
":ref:`tarantool module <tarantool-module>`."
msgstr ""
"Вложенный модуль ``box.info`` предоставляет доступ к информации о "
"переменных экземпляра сервера. Часть этой информации также доступна из "
":ref:` модуля tarantool <tarantool-module>`."

#: ../doc/book/box/box_introspection.rst:39
msgid ""
"**server.lsn** Log Sequence Number for the latest entry in the :ref:`WAL "
"<internals-wal>`."
msgstr ""
"**server.lsn** Порядковый номер последней записи в журнале упреждающей "
"записи :ref:`WAL <internals-wal>`."

#: ../doc/book/box/box_introspection.rst:40
msgid ""
"**server.ro**  True if the instance is in \"read_only\" mode (same as "
":ref:`read_only <cfg_basic-read_only>` in box.cfg)."
msgstr ""
"**server.ro** Значение ``true`` (правда), если экземпляр находится в "
"режиме только для чтения \"read_only\" (как :ref:`read_only <cfg_basic-"
"read_only>` в box.cfg)."

#: ../doc/book/box/box_introspection.rst:42
msgid ""
"**server.uuid** The unique identifier of this instance, as stored in the "
"database. This value is also in the :ref:`box.space._cluster <box_space-"
"cluster>` system space."
msgstr ""
"**server.uuid** Уникальный идентификатор экземпляра, который хранится в "
"базе данных. Данное значение также хранится в системном спейсе "
":ref:`box.space._cluster <box_space-cluster>`."

#: ../doc/book/box/box_introspection.rst:45
msgid "**server.id** The number of this server's instance within a replica set."
msgstr "**server.id** Номер экземпляра сервера в пределах набора реплик."

#: ../doc/book/box/box_introspection.rst:46
msgid ""
"**version** Tarantool version. This value is also shown by "
":ref:`tarantool --version <index-tarantool_version>`."
msgstr ""
"**version** Версия Tarantool'а. Данное значение также можно отобразить с "
"помощью команды  :ref:`tarantool --version <index-tarantool_version>`."

#: ../doc/book/box/box_introspection.rst:48
msgid ""
"**status** Usually this is 'running', but it can be 'loading', 'orphan', "
"or 'hot_standby'."
msgstr ""
"**status** Как правило, статус будет 'running' (запущен), но также может "
"принимать значения 'loading' (загружается), 'orphan' (одиночный) или "
"'hot_standby' (горячее резервирование)."

#: ../doc/book/box/box_introspection.rst:49
msgid "**vclock** Same as :ref:`replication.vclock <replication-vector>`."
msgstr "**vclock** Аналогично :ref:`replication.vclock <replication-vector>`."

#: ../doc/book/box/box_introspection.rst:50
msgid ""
"**pid** Process ID. This value is also shown by the :ref:`tarantool "
"<tarantool-build>` module. This value is also shown by the Linux \"ps "
"-A\" command."
msgstr ""
"**pid** Идентификатор процесса. Это значение также отображается с помощью"
" модуля :ref:`tarantool <tarantool-build>`  и по команде \"ps -A\" в "
"Linux."

#: ../doc/book/box/box_introspection.rst:53
msgid ""
"**cluster.uuid** UUID of the :ref:`replica set <replication-mechanism>`. "
"Every instance in a replica set will have the same cluster.uuid value. "
"This value is also in the :ref:`box.space._schema <box_space-schema>` "
"system space."
msgstr ""
"**cluster.uuid** Уникальный идентификатор :ref:`набора реплик "
"<replication-mechanism>`. (UUID). У каждого экземпляра в наборе реплик "
"будет одно и то же значение cluster.uuid. Данное значение также хранится "
"в системном спейсе :ref:`box.space._schema <box_space-schema>`."

#: ../doc/book/box/box_introspection.rst:55
msgid "**vinyl()** Returns runtime statistics for the vinyl storage engine."
msgstr ""
"**vinyl()** Возвращает статистику времени работы для движка базы данных "
"vinyl."

#: ../doc/book/box/box_introspection.rst:56
msgid ""
"**replication.lag** Number of seconds that the replica is behind the "
"master."
msgstr ""
"**replication.lag** Количество секунд, когда реплика находится позади "
"мастера."

#: ../doc/book/box/box_introspection.rst:57
msgid ""
"**replication.status** Usually this is 'follow', but it can be 'off', "
"'stopped', 'connecting', 'auth', or 'disconnected'."
msgstr ""
"**replication.status** Как правило, статус будет 'follow' (следует), но "
"также может принимать значения 'off' (отключена), 'stopped' "
"(остановлена), 'connecting' (подключается), 'auth' (авторизация) или "
"'disconnected' (изолирована)."

#: ../doc/book/box/box_introspection.rst:59
msgid "**replication.idle** Number of seconds that the instancehas been idle."
msgstr "**replication.idle** Количество секунд, когда экземпляр бездействует."

#: ../doc/book/box/box_introspection.rst:60
msgid ""
"**replication.vclock** See the :ref:`discussion of \"vector clock\" "
"<replication-vector>` in the Internals section."
msgstr ""
"**replication.vclock** См. :ref:`информацию о \"vector clock\" "
"<replication-vector>` в разделе \"Внутренняя реализация\"."

#: ../doc/book/box/box_introspection.rst:61
msgid ""
"**replication.uuid** The unique identifier of a master to which this "
"instance is connected."
msgstr ""
"**replication.uuid** Уникальный идентификатор мастера, к которому "
"подключена данная реплика."

#: ../doc/book/box/box_introspection.rst:62
msgid ""
"**replication.uptime** Number of seconds since the instance started. This"
" value can also be retrieved with :ref:`tarantool.uptime() <tarantool-"
"build>`."
msgstr ""
"**uptime** Количество секунд с момента запуска экземпляра. Данное "
"значение также можно получить с помощью :ref:`tarantool.uptime() "
"<tarantool-build>`."

#: ../doc/book/box/box_introspection.rst:65
msgid ""
"The replication fields are blank unless the instance is a :ref:`replica "
"<index-box_replication>`. The replication fields are in an array if the "
"instance is a replica for more than one master."
msgstr ""
"Поля с данными по репликации остаются пустыми, если только экземпляр не "
"является :ref:`репликой <index-box_replication>`. Поля по репликации "
"упорядочены в массив, если реплика подключена к нескольким мастерам."

#: ../doc/book/box/box_introspection.rst:75
msgid "keys and values in the submodule."
msgstr "ключи и значения во вложенном модуле."

#: ../doc/book/box/box_introspection.rst:80
msgid ""
"tarantool> box.info()\n"
"---\n"
"- server:\n"
"    lsn: 158\n"
"    ro: false\n"
"    uuid: a2684219-b2b1-4334-88ab-50b0722283fd\n"
"    id: 1\n"
"  version: 1.7.2-435-g6ba8500\n"
"  pid: 12932\n"
"  status: running\n"
"  vclock:\n"
"  - 158\n"
"  replication:\n"
"    status: off\n"
"  uptime: 908\n"
"...\n"
"tarantool> box.info.pid\n"
"---\n"
"- 12932\n"
"...\n"
"tarantool> box.info.status\n"
"---\n"
"- running\n"
"...\n"
"tarantool> box.info.uptime\n"
"---\n"
"- 1065\n"
"...\n"
"tarantool> box.info.version\n"
"---\n"
"- 1.7.2-435-g6ba8500\n"
"..."
msgstr ""
"tarantool> box.info()\n"
"---\n"
"- server:\n"
"    lsn: 158\n"
"    ro: false\n"
"    uuid: a2684219-b2b1-4334-88ab-50b0722283fd\n"
"    id: 1\n"
"  version: 1.7.2-435-g6ba8500\n"
"  pid: 12932\n"
"  status: running\n"
"  vclock:\n"
"  - 158\n"
"  replication:\n"
"    status: off\n"
"  uptime: 908\n"
"...\n"
"tarantool> box.info.pid\n"
"---\n"
"- 12932\n"
"...\n"
"tarantool> box.info.status\n"
"---\n"
"- running\n"
"...\n"
"tarantool> box.info.uptime\n"
"---\n"
"- 1065\n"
"...\n"
"tarantool> box.info.version\n"
"---\n"
"- 1.7.2-435-g6ba8500\n"
"..."

#: ../doc/book/box/box_introspection.rst:119 ../doc/book/box/box_slab.rst:5
msgid "Submodule `box.slab`"
msgstr "Вложенный модуль `box.slab`"

#: ../doc/book/box/box_introspection.rst:123
msgid ""
"The ``box.slab`` submodule provides access to slab allocator statistics. "
"The slab allocator is the main allocator used to store tuples. This can "
"be used to monitor the total memory use and memory fragmentation."
msgstr ""
"Вложенный модуль ``box.slab`` предоставляет доступ к статистике "
"распределения slab. Механизм распределения slab представляет собой "
"основной тип распределения для хранения кортежей. Такое распределение "
"можно использовать для отслеживания использования памяти и фрагментации "
"памяти."

#: ../doc/book/box/box_introspection.rst:127
msgid ""
"The display of slabs is broken down by the slab size -- 64-byte, "
"136-byte, and so on. The example omits the slabs which are empty. The "
"example display is saying that:"
msgstr ""

#: ../doc/book/box/box_introspection.rst:131
msgid ""
"there are 16 items stored in the 64-byte slab (and 16*64=102 so "
"bytes_used = 1024);"
msgstr ""

#: ../doc/book/box/box_introspection.rst:132
msgid ""
"there is 1 item stored in the 136-byte slab (and 136*1=136 so bytes_used "
"= 136);"
msgstr ""

#: ../doc/book/box/box_introspection.rst:133
msgid ""
"the ``arena_used`` value is the total of all the bytes_used values "
"(1024+136 = 1160);"
msgstr ""

#: ../doc/book/box/box_introspection.rst:134
msgid ""
"the ``arena_size`` value is the ``arena_used`` value plus the total of "
"all the bytes_free values (1160+4193200+4194088 = 8388448)."
msgstr ""

#: ../doc/book/box/box_introspection.rst:137
#, python-format
msgid ""
"The ``arena_size`` and ``arena_used`` values are the amount of the % of "
":ref:`memtx_memory <cfg_storage-memtx_memory>` that is already "
"distributed to the slab allocator."
msgstr ""
"Значения ``arena_size`` и ``arena_used`` представляют собой объем памяти "
":ref:`memtx_memory <cfg_storage-memtx_memory>` в %,  уже выделенный для "
"распределения slab."

#: ../doc/book/box/box_introspection.rst:143
msgid ""
"tarantool> box.slab.info().arena_used\n"
"---\n"
"- 4194304\n"
"...\n"
"tarantool> box.slab.info().arena_size\n"
"---\n"
"- 104857600\n"
"...\n"
"tarantool> box.slab.stats()\n"
"---\n"
"- - mem_free: 16248\n"
"    mem_used: 48\n"
"    item_count: 2\n"
"    item_size: 24\n"
"    slab_count: 1\n"
"    slab_size: 16384\n"
"  - mem_free: 15736\n"
"    mem_used: 560\n"
"    item_count: 14\n"
"    item_size: 40\n"
"    slab_count: 1\n"
"    slab_size: 16384\n"
"    <...>\n"
"...\n"
"tarantool> box.slab.stats()[1]\n"
"---\n"
"- mem_free: 15736\n"
"  mem_used: 560\n"
"  item_count: 14\n"
"  item_size: 40\n"
"  slab_count: 1\n"
"  slab_size: 16384\n"
"..."
msgstr ""
"tarantool> box.slab.info().arena_used\n"
"---\n"
"- 4194304\n"
"...\n"
"tarantool> box.slab.info().arena_size\n"
"---\n"
"- 104857600\n"
"...\n"
"tarantool> box.slab.stats()\n"
"---\n"
"- - mem_free: 16248\n"
"    mem_used: 48\n"
"    item_count: 2\n"
"    item_size: 24\n"
"    slab_count: 1\n"
"    slab_size: 16384\n"
"  - mem_free: 15736\n"
"    mem_used: 560\n"
"    item_count: 14\n"
"    item_size: 40\n"
"    slab_count: 1\n"
"    slab_size: 16384\n"
"    <...>\n"
"...\n"
"tarantool> box.slab.stats()[1]\n"
"---\n"
"- mem_free: 15736\n"
"  mem_used: 560\n"
"  item_count: 14\n"
"  item_size: 40\n"
"  slab_count: 1\n"
"  slab_size: 16384\n"
"..."

#: ../doc/book/box/box_introspection.rst:183 ../doc/book/box/box_stat.rst:5
msgid "Submodule `box.stat`"
msgstr "Вложенный модуль `box.stat`"

#: ../doc/book/box/box_introspection.rst:185
msgid ""
"The ``box.stat`` submodule provides access to request and network "
"statistics. Show the average number of requests per second, and the total"
" number of requests since startup, broken down by request type. Also, "
"show network activity statistics."
msgstr ""
"Вложенный модуль `box.stat` предоставляет доступ к статистике Tarantool'а"
" по запросам и использованию сети. Можно просмотреть среднее количество "
"запросов в секунду и общее количество запросов с момента запуска с "
"разбивкой по типу запроса. Кроме того, можно просмотреть статистику "
"сетевой активности."

#: ../doc/book/box/box_introspection.rst:190
msgid ""
"tarantool> type(box.stat), type(box.stat.net) -- virtual tables\n"
"---\n"
"- table\n"
"- table\n"
"...\n"
"tarantool> box.stat, box.stat.net\n"
"---\n"
"- net: []\n"
"- []\n"
"...\n"
"tarantool> box.stat()\n"
"---\n"
"- DELETE:\n"
"    total: 1873949\n"
"    rps: 123\n"
"  SELECT:\n"
"    total: 1237723\n"
"    rps: 4099\n"
"  INSERT:\n"
"    total: 0\n"
"    rps: 0\n"
"  EVAL:\n"
"    total: 0\n"
"    rps: 0\n"
"  CALL:\n"
"    total: 0\n"
"    rps: 0\n"
"  REPLACE:\n"
"    total: 1239123\n"
"    rps: 7849\n"
"  UPSERT:\n"
"    total: 0\n"
"    rps: 0\n"
"  AUTH:\n"
"    total: 0\n"
"    rps: 0\n"
"  ERROR:\n"
"    total: 0\n"
"    rps: 0\n"
"  UPDATE:\n"
"    total: 0\n"
"    rps: 0\n"
"...\n"
"tarantool> box.stat().DELETE -- a selected item of the table\n"
"---\n"
"- total: 0\n"
"  rps: 0\n"
"...\n"
"tarantool> box.stat.net()\n"
"---\n"
"- SENT:\n"
"    total: 0\n"
"    rps: 0\n"
"  CONNECTIONS: 0\n"
"  RECEIVED:\n"
"    total: 0\n"
"    rps: 0\n"
"..."
msgstr ""

#: ../doc/book/box/box_schema.rst:5
msgid "Submodule `box.schema`"
msgstr "Вложенный модуль `box.schema`"

#: ../doc/book/box/box_schema.rst:13
msgid ""
"The ``box.schema`` submodule has data-definition functions for spaces, "
"users, roles, function tuples, and sequences."
msgstr ""
"Вложенный модуль ``box.schema`` содержит функции для определения данных "
"для спейсов, пользователей, ролей, кортежей и последовательностей."

#: ../doc/book/box/box_schema.rst:20
msgid "Below is a list of all ``box.schema`` functions."
msgstr "Ниже приведен перечень всех функций модуля ``box.schema``."

#: ../doc/book/box/box_schema.rst:30
msgid ":ref:`box.schema.space.create() <box_schema-space_create>`"
msgstr ":ref:`box.schema.space.create() <box_schema-space_create>`"

#: ../doc/book/box/box_schema.rst:30
msgid "Create a space"
msgstr "Создание спейса"

#: ../doc/book/box/box_schema.rst:33
msgid ":ref:`box.schema.user.create() <box_schema-user_create>`"
msgstr ":ref:`box.schema.user.create() <box_schema-user_create>`"

#: ../doc/book/box/box_schema.rst:33
msgid "Create a user"
msgstr "Создание пользователя"

#: ../doc/book/box/box_schema.rst:36
msgid ":ref:`box.schema.user.drop() <box_schema-user_drop>`"
msgstr ":ref:`box.schema.user.drop() <box_schema-user_drop>`"

#: ../doc/book/box/box_schema.rst:36
msgid "Drop a user"
msgstr "Удаление пользователя"

#: ../doc/book/box/box_schema.rst:39
msgid ":ref:`box.schema.user.exists() <box_schema-user_exists>`"
msgstr ":ref:`box.schema.user.exists() <box_schema-user_exists>`"

#: ../doc/book/box/box_schema.rst:39
msgid "Check if a user exists"
msgstr "Проверка существования пользователя"

#: ../doc/book/box/box_schema.rst:42
msgid ":ref:`box.schema.user.grant() <box_schema-user_grant>`"
msgstr ":ref:`box.schema.user.grant() <box_schema-user_grant>`"

#: ../doc/book/box/box_schema.rst:42
msgid "Grant privileges to a user or a role"
msgstr "Выдача прав пользователю или роли"

#: ../doc/book/box/box_schema.rst:45
msgid ":ref:`box.schema.user.revoke() <box_schema-user_revoke>`"
msgstr ":ref:`box.schema.user.revoke() <box_schema-user_revoke>`"

#: ../doc/book/box/box_schema.rst:45
msgid "Revoke privileges from a user or a role"
msgstr "Отмена прав пользователя или роли"

#: ../doc/book/box/box_schema.rst:48
msgid ":ref:`box.schema.user.password() <box_schema-user_password>`"
msgstr ":ref:`box.schema.user.password() <box_schema-user_password>`"

#: ../doc/book/box/box_schema.rst:48
msgid "Get a hash of a user's password"
msgstr "Получение хеша пароля пользователя"

#: ../doc/book/box/box_schema.rst:51
msgid ":ref:`box.schema.user.passwd() <box_schema-user_passwd>`"
msgstr ":ref:`box.schema.user.passwd() <box_schema-user_passwd>`"

#: ../doc/book/box/box_schema.rst:51
msgid "Associate a password with a user"
msgstr "Ассоциация пароля с пользователем"

#: ../doc/book/box/box_schema.rst:54
msgid ":ref:`box.schema.user.info() <box_schema-user_info>`"
msgstr ":ref:`box.schema.user.info() <box_schema-user_info>`"

#: ../doc/book/box/box_schema.rst:54
msgid "Get a description of a user's privileges"
msgstr "Получение описания прав пользователя"

#: ../doc/book/box/box_schema.rst:57
msgid ":ref:`box.schema.role.create() <box_schema-role_create>`"
msgstr ":ref:`box.schema.role.create() <box_schema-role_create>`"

#: ../doc/book/box/box_schema.rst:57
msgid "Create a role"
msgstr "Создание роли"

#: ../doc/book/box/box_schema.rst:60
msgid ":ref:`box.schema.role.drop() <box_schema-role_drop>`"
msgstr ":ref:`box.schema.role.drop() <box_schema-role_drop>`"

#: ../doc/book/box/box_schema.rst:60
msgid "Drop a role"
msgstr "Удаление роли"

#: ../doc/book/box/box_schema.rst:63
msgid ":ref:`box.schema.role.exists() <box_schema-role_exists>`"
msgstr ":ref:`box.schema.role.exists() <box_schema-role_exists>`"

#: ../doc/book/box/box_schema.rst:63
msgid "Check if a role exists"
msgstr "Проверка наличия роли"

#: ../doc/book/box/box_schema.rst:66
msgid ":ref:`box.schema.role.grant() <box_schema-role_grant>`"
msgstr ":ref:`box.schema.role.grant() <box_schema-role_grant>`"

#: ../doc/book/box/box_schema.rst:66
msgid "Grant privileges to a role"
msgstr "Выдача прав роли"

#: ../doc/book/box/box_schema.rst:69
msgid ":ref:`box.schema.role.revoke() <box_schema-role_revoke>`"
msgstr ":ref:`box.schema.role.revoke() <box_schema-role_revoke>`"

#: ../doc/book/box/box_schema.rst:69
msgid "Revoke privileges from a role"
msgstr "Отмена прав роли"

#: ../doc/book/box/box_schema.rst:72
msgid ":ref:`box.schema.role.info() <box_schema-role_info>`"
msgstr ":ref:`box.schema.role.info() <box_schema-role_info>`"

#: ../doc/book/box/box_schema.rst:72
msgid "Get a description of a role's privileges"
msgstr "Получение описания прав роли"

#: ../doc/book/box/box_schema.rst:75
msgid ":ref:`box.schema.func.create() <box_schema-func_create>`"
msgstr ":ref:`box.schema.func.create() <box_schema-func_create>`"

#: ../doc/book/box/box_schema.rst:75
msgid "Create a function tuple"
msgstr "Создание кортежа с функцией"

#: ../doc/book/box/box_schema.rst:78
msgid ":ref:`box.schema.func.drop() <box_schema-func_drop>`"
msgstr ":ref:`box.schema.func.drop() <box_schema-func_drop>`"

#: ../doc/book/box/box_schema.rst:78
msgid "Drop a function tuple"
msgstr "Удаление кортежа с функцией"

#: ../doc/book/box/box_schema.rst:81
msgid ":ref:`box.schema.func.exists() <box_schema-func_exists>`"
msgstr ":ref:`box.schema.func.exists() <box_schema-func_exists>`"

#: ../doc/book/box/box_schema.rst:81
msgid "Check if a function tuple exists"
msgstr "Проверка наличия кортежа с функцией"

#: ../doc/book/box/box_schema.rst:84
msgid ":ref:`box.schema.sequence.create() <box_schema-sequence_create>`"
msgstr ":ref:`box.schema.sequence.create() <box_schema-sequence_create>`"

#: ../doc/book/box/box_schema.rst:84
msgid "Create a new sequence generator"
msgstr "Создание нового генератора последовательностей"

#: ../doc/book/box/box_schema.rst:87
msgid ":ref:`sequence_object:next() <box_schema-sequence_next>`"
msgstr ":ref:`sequence_object:next() <box_schema-sequence_next>`"

#: ../doc/book/box/box_schema.rst:87
msgid "Generate and return the next value"
msgstr "Генерация и возврат следующего значения"

#: ../doc/book/box/box_schema.rst:90
msgid ":ref:`sequence_object:alter() <box_schema-sequence_alter>`"
msgstr ":ref:`sequence_object:alter() <box_schema-sequence_alter>`"

#: ../doc/book/box/box_schema.rst:90
msgid "Change sequence options"
msgstr "Изменение параметров последовательности"

#: ../doc/book/box/box_schema.rst:93
msgid ":ref:`sequence_object:reset() <box_schema-sequence_reset>`"
msgstr ":ref:`sequence_object:reset() <box_schema-sequence_reset>`"

#: ../doc/book/box/box_schema.rst:93
msgid "Reset sequence state"
msgstr "Сброс состояния последовательности"

#: ../doc/book/box/box_schema.rst:96
msgid ":ref:`sequence_object:set() <box_schema-sequence_set>`"
msgstr ":ref:`sequence_object:set() <box_schema-sequence_set>`"

#: ../doc/book/box/box_schema.rst:96
msgid "Set the new value"
msgstr "Установка нового значения"

#: ../doc/book/box/box_schema.rst:99
msgid ":ref:`sequence_object:drop() <box_schema-sequence_drop>`"
msgstr ":ref:`sequence_object:drop() <box_schema-sequence_drop>`"

#: ../doc/book/box/box_schema.rst:99
msgid "Drop the sequence"
msgstr "Удаление последовательности"

#: ../doc/book/box/box_schema.rst:102
msgid ":ref:`space_object:create_index() <box_schema-sequence_create_index>`"
msgstr ":ref:`space_object:create_index() <box_schema-sequence_create_index>`"

#: ../doc/book/box/box_schema.rst:102 ../doc/book/box/box_space.rst:40
msgid "Create an index"
msgstr "Создание индекса"

#: ../doc/book/box/box_schema.rst:110
msgid "Create a :ref:`space <index-box_space>`."
msgstr "Создание :ref:`спейса <index-box_space>`."

#: ../doc/book/box/box_schema.rst:112
msgid ""
"name of space, which should conform to the :ref:`rules for object names "
"<app_server-names>`"
msgstr ""
"имя спейса, которое должно соответствовать :ref:`правилам именования "
"объектов <app_server-names>`"

#: ../doc/book/box/box_schema.rst:114
msgid "see \"Options for box.schema.space.create\" chart, below"
msgstr "см. таблицу \"Параметры для box.schema.space.create\" ниже"

#: ../doc/book/box/box_schema.rst:116
msgid "space object"
msgstr "объект спейса"

#: ../doc/book/box/box_schema.rst:117
msgid "userdata"
msgstr "пользовательские данные"

#: ../doc/book/box/box_schema.rst:121
msgid "**Options for box.schema.space.create**"
msgstr "**Параметры для box.schema.space.create**"

#: ../doc/book/box/box_schema.rst:131 ../doc/book/box/box_space.rst:295
#: ../doc/book/box/data_model.rst:498
msgid "Default"
msgstr "Значение по умолчанию"

#: ../doc/book/box/box_schema.rst:133
msgid "engine"
msgstr "engine (движок)"

#: ../doc/book/box/box_schema.rst:133
msgid "'memtx' or 'vinyl'"
msgstr "'memtx' или 'vinyl'"

#: ../doc/book/box/box_schema.rst:133 ../doc/book/box/box_schema.rst:173
#: ../doc/book/box/box_schema.rst:389 ../doc/book/box/box_session.rst:106
#: ../doc/book/box/box_session.rst:130 ../doc/book/box/box_session.rst:138
#: ../doc/book/box/box_space.rst:336 ../doc/book/box/data_model.rst:157
msgid "string"
msgstr "string (строка)"

#: ../doc/book/box/box_schema.rst:133
msgid "'memtx'"
msgstr "'memtx'"

#: ../doc/book/box/box_schema.rst:135
msgid "field_count"
msgstr "field_count (количество полей)"

#: ../doc/book/box/box_schema.rst:135
msgid ""
"fixed count of :ref:`fields <index-box_tuple>`: for example if "
"field_count=5, it is illegal to insert a tuple with fewer than or more "
"than 5 fields"
msgstr ""
"заданное количество :ref:`полей <index-box_tuple>`: например, если "
"field_count=5, нельзя вставить кортеж с количеством полей, большим или "
"меньшим, чем 5"

#: ../doc/book/box/box_schema.rst:135
msgid "0 i.e. not fixed"
msgstr "0, то есть не задано"

#: ../doc/book/box/box_schema.rst:141
msgid "format"
msgstr "format (формат)"

#: ../doc/book/box/box_schema.rst:141
msgid ""
"field names and types: See the illustrations of format clauses in the "
":ref:`space_object:format() <box_space-format>` description and in the "
":ref:`box.space._space <box_space-space>` example. Optional and usually "
"not specified."
msgstr ""
"имена и типы полей: см. наглядные примеры операторов в описании "
":ref:`space_object:format() <box_space-format>` и в "
":ref:`box.space._space <box_space-space>`. Необязательный параметр, "
"обычно значение не указывается."

#: ../doc/book/box/box_schema.rst:141
msgid "(blank)"
msgstr "(пустое)"

#: ../doc/book/box/box_schema.rst:148 ../doc/book/box/box_space.rst:303
msgid "id"
msgstr "id"

#: ../doc/book/box/box_schema.rst:148
msgid ""
"unique identifier: users can refer to spaces with the id instead of the "
"name"
msgstr ""
"уникальный идентификатор: пользователи могут ссылаться на спейсы "
"посредством идентификатора вместо имени"

#: ../doc/book/box/box_schema.rst:148
msgid "last space's id, +1"
msgstr "идентификатор последнего спейса +1"

#: ../doc/book/box/box_schema.rst:152 ../doc/book/box/box_space.rst:307
msgid "if_not_exists"
msgstr "if_not_exists (если отсутствует)"

#: ../doc/book/box/box_schema.rst:152
msgid ""
"create space only if a space with the same name does not exist already, "
"otherwise do nothing but do not cause an error"
msgstr ""
"спейс создается, только если спейса с таким же именем нет в базе данных, "
"в противном случае эффект отсутствует, но ошибка не выдается"

#: ../doc/book/box/box_schema.rst:152 ../doc/book/box/box_schema.rst:158
#: ../doc/book/box/box_schema.rst:165 ../doc/book/box/data_model.rst:510
#: ../doc/book/box/data_model.rst:520
msgid "false"
msgstr "false (ложь)"

#: ../doc/book/box/box_schema.rst:158
msgid "is_local"
msgstr "is_local"

#: ../doc/book/box/box_schema.rst:158
msgid ""
"space contents are :ref:`replication-local <replication-local>`: changes "
"are stored in the :ref:`write-ahead log <internals-wal>` of the local "
"node but there is no :ref:`replication <replication>`."
msgstr ""
"содержимое спейса :ref:`реплицируется локально <replication-local>`: "
"изменения сохраняются в :ref:`журнале упреждающей записи <internals-wal>`"
" локального узла, но не происходит :ref:`репликация <replication>`."

#: ../doc/book/box/box_schema.rst:165
msgid "temporary"
msgstr "temporary (временный)"

#: ../doc/book/box/box_schema.rst:165
msgid ""
"space contents are temporary: changes are not stored in the :ref:`write-"
"ahead log <internals-wal>` and there is no :ref:`replication "
"<replication>`. Note re storage engine: vinyl does not support temporary "
"spaces."
msgstr ""
"содержимое спейса хранится временно: изменения не хранятся в "
":ref:`журнале упреждающей записи <internals-wal>`, и не проводится "
":ref:`репликация <replication>`. Примечание по движку базы данных: vinyl "
"не поддерживает временные спейсы."

#: ../doc/book/box/box_schema.rst:173 ../doc/book/box/box_space.rst:2296
#: ../doc/book/box/box_space.rst:2299
msgid "user"
msgstr "user (пользователь)"

#: ../doc/book/box/box_schema.rst:173
msgid ""
"name of the user who is considered to be the space's :ref:`owner "
"<authentication-owners_privileges>` for authorization purposes"
msgstr ""
"имя пользователя, который считается :ref:`владельцем <authentication-"
"owners_privileges>` спейса, для целей авторизации"

#: ../doc/book/box/box_schema.rst:173
msgid "current user's name"
msgstr "имя текущего пользователя"

#: ../doc/book/box/box_schema.rst:179
msgid ""
"There are three :ref:`syntax variations <app_server-object_reference>` "
"for object references targeting space objects, for example "
":samp:`box.schema.space.drop({space-id})` will drop a space. However, the"
" common approach is to use functions attached to the space objects, for "
"example :ref:`space_object:drop() <box_space-drop>`."
msgstr ""
"Существуют три :ref:`варианта синтаксиса <app_server-object_reference>` "
"для ссылок на объекты спейса, например, "
":samp:`box.schema.space.drop({id-спейса})` удалит спейс. Однако общий "
"подход заключается в использовании функций, прикрепленных к объектам "
"спейса, например :ref:`space_object:drop() <box_space-drop>`."

#: ../doc/book/box/box_schema.rst:188
msgid ""
"tarantool> s = box.schema.space.create('space55')\n"
"---\n"
"...\n"
"tarantool> s = box.schema.space.create('space55', {\n"
"         >   id = 555,\n"
"         >   temporary = false\n"
"         > })\n"
"---\n"
"- error: Space 'space55' already exists\n"
"...\n"
"tarantool> s = box.schema.space.create('space55', {\n"
"         >   if_not_exists = true\n"
"         > })\n"
"---\n"
"..."
msgstr ""
"tarantool> s = box.schema.space.create('space55')\n"
"---\n"
"...\n"
"tarantool> s = box.schema.space.create('space55', {\n"
"         >   id = 555,\n"
"         >   temporary = false\n"
"         > })\n"
"---\n"
"- error: Space 'space55' already exists\n"
"...\n"
"tarantool> s = box.schema.space.create('space55', {\n"
"         >   if_not_exists = true\n"
"         > })\n"
"---\n"
"..."

#: ../doc/book/box/box_schema.rst:206
msgid ""
"After a space is created, usually the next step is to :ref:`create an "
"index <box_space-create_index>` for it, and then it is available for "
"insert, select, and all the other :ref:`box.space <box_space>` functions."
msgstr ""
"Следующим шагом после создания спейса будет :ref:`создание индекса "
"<box_space-create_index>` для него, после чего можно будет выполнять "
"вставку, выборку и другие функции :ref:`box.space <box_space>`."

#: ../doc/book/box/box_schema.rst:215
msgid ""
"Create a user. For explanation of how Tarantool maintains user data, see "
"section :ref:`Users<authentication-users>` and reference on :ref:`_user "
"<box_space-user>` space."
msgstr ""
"Создание пользователя. Чтобы получить информацию о том, как происходит "
"управление данными пользователя в Tarantool'е, см. раздел "
":ref:`Пользователи <authentication-users>` и справочник по спейсу "
":ref:`_user <box_space-user>`."

#: ../doc/book/box/box_schema.rst:220 ../doc/book/box/box_schema.rst:312
#: ../doc/book/box/box_schema.rst:593 ../doc/book/box/box_schema.rst:636
msgid "The possible options are:"
msgstr "Возможные параметры:"

#: ../doc/book/box/box_schema.rst:222
msgid ""
"``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; "
"``true`` means there should be no error if the user already exists,"
msgstr ""
"``if_not_exists`` (если отсутствует) = ``true|false`` (правда/ложь, по "
"умолчанию ложь) - логическое значение boolean; ``true`` (правда) "
"означает, что ошибка не выпадет, если пользователь уже существует,"

#: ../doc/book/box/box_schema.rst:225
msgid ""
"``password`` (default = '') - string; the ``password`` = *password* "
"specification is good because in a :ref:`URI <index-uri>` (Uniform "
"Resource Identifier) it is usually illegal to include a user-name without"
" a password."
msgstr ""
"``password`` (пароль) -- строка; указать ``password`` = *password* "
"неплохо, поскольку в :ref:`URI <index-uri>` (унифицированный "
"идентификатор ресурса) обычно нельзя включать имя пользователя без "
"пароля."

#: ../doc/book/box/box_schema.rst:232 ../doc/book/box/box_space.rst:2386
msgid "The maximum number of users is 32."
msgstr "Максимальное количество пользователей -- 32."

#: ../doc/book/box/box_schema.rst:234
msgid ""
"name of user, which should conform to the :ref:`rules for object names "
"<app_server-names>`"
msgstr ""
"имя пользователя, которое должно соответствовать :ref:`правилам "
"именования объектов <app_server-names>`"

#: ../doc/book/box/box_schema.rst:236
msgid "``if_not_exists``, ``password``"
msgstr "``if_not_exists``, ``password``"

#: ../doc/book/box/box_schema.rst:240 ../doc/book/box/box_schema.rst:261
#: ../doc/book/box/data_model.rst:649
msgid "**Examples:**"
msgstr "**Примеры:**"

#: ../doc/book/box/box_schema.rst:242
msgid ""
"box.schema.user.create('Lena')\n"
"box.schema.user.create('Lena', {password = 'X'})\n"
"box.schema.user.create('Lena', {if_not_exists = false})"
msgstr ""
"box.schema.user.create('Lena')\n"
"box.schema.user.create('Lena', {password = 'X'})\n"
"box.schema.user.create('Lena', {if_not_exists = false})"

#: ../doc/book/box/box_schema.rst:252
msgid ""
"Drop a user. For explanation of how Tarantool maintains user data, see "
"section :ref:`Users <authentication-users>` and reference on :ref:`_user "
"<box_space-user>` space."
msgstr ""
"Удаление пользователя. Чтобы получить информацию о том, как происходит "
"управление данными пользователя в Tarantool'е, см. раздел "
":ref:`Пользователи <authentication-users>` и справочник по спейсу "
":ref:`_user <box_space-user>`."

#: ../doc/book/box/box_schema.rst:257 ../doc/book/box/box_schema.rst:277
msgid "the name of the user"
msgstr "имя пользователя"

#: ../doc/book/box/box_schema.rst:258
msgid ""
"``if_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` "
"means there should be no error if the user does not exist."
msgstr ""
"``if_exists`` (если существует) = ``true|false`` (правда/ложь, по "
"умолчанию ложь) - логическое значение boolean; ``true`` (правда) "
"означает, что ошибка не выпадет, если такой пользователь не существует."

#: ../doc/book/box/box_schema.rst:263
msgid ""
"box.schema.user.drop('Lena')\n"
"box.schema.user.drop('Lena',{if_exists=false})"
msgstr ""
"box.schema.user.drop('Lena')\n"
"box.schema.user.drop('Lena',{if_exists=false})"

#: ../doc/book/box/box_schema.rst:272
msgid ""
"Return ``true`` if a user exists; return ``false`` if a user does not "
"exist. For explanation of how Tarantool maintains user data, see section "
":ref:`Users <authentication-users>` and reference on :ref:`_user "
"<box_space-user>` space."
msgstr ""
"Возврат ``true`` (правда), если пользователь существует; возврат "
"``false`` (ложь), если пользователь отсутствует. Чтобы получить "
"информацию о том, как происходит управление данными пользователя в "
"Tarantool'е, см. раздел :ref:`Пользователи <authentication-users>` и "
"справочник по спейсу :ref:`_user <box_space-user>`."

#: ../doc/book/box/box_schema.rst:278 ../doc/book/box/box_schema.rst:490
#: ../doc/book/box/box_schema.rst:766
msgid "bool"
msgstr "логическое значение bool"

#: ../doc/book/box/box_schema.rst:282
msgid "box.schema.user.exists('Lena')"
msgstr "box.schema.user.exists('Lena')"

#: ../doc/book/box/box_schema.rst:292
msgid ""
"Grant :ref:`privileges <authentication-owners_privileges>` to a user or "
"to another role."
msgstr ""
"Выдача :ref:`прав <authentication-owners_privileges>` пользователю или "
"другой роли."

#: ../doc/book/box/box_schema.rst:295 ../doc/book/box/box_schema.rst:337
msgid "the name of the user."
msgstr "имя пользователя."

#: ../doc/book/box/box_schema.rst:296 ../doc/book/box/box_schema.rst:338
#: ../doc/book/box/box_schema.rst:507 ../doc/book/box/box_schema.rst:540
msgid ""
"'read' or 'write' or 'execute' or 'create' or 'alter' or 'drop' or a "
"combination."
msgstr ""
"'read' (чтение) или 'write' (запись), или 'execute' (выполнение), или "
"'create' (создание), или 'alter' (изменение), или 'drop' (удаление) или "
"их сочетание."

#: ../doc/book/box/box_schema.rst:298 ../doc/book/box/box_schema.rst:509
#: ../doc/book/box/box_schema.rst:542
msgid "'space' or 'function' or 'sequence' or 'role'."
msgstr ""
"'space' (спейс) или 'function' (функция), или 'sequence' "
"(последовательность), или 'role' (роль)."

#: ../doc/book/box/box_schema.rst:299
msgid "name of object to grant permissions for."
msgstr "имя объекта, на который выдаются права."

#: ../doc/book/box/box_schema.rst:300
msgid "name of role to grant to user."
msgstr "имя роли, которая назначается пользователю."

#: ../doc/book/box/box_schema.rst:301
msgid "``grantor``, ``if_not_exists``."
msgstr "``grantor``, ``if_not_exists``."

#: ../doc/book/box/box_schema.rst:303
msgid ""
"If :samp:`'function','{object-name}'` is specified, then a _func tuple "
"with that object-name must exist."
msgstr ""
"Если есть :samp:`'function','{имя-объекта}'`, то должен существовать "
"кортеж в _func с таким именем объекта."

#: ../doc/book/box/box_schema.rst:306 ../doc/book/box/box_schema.rst:517
msgid ""
"**Variation:** instead of ``object-type, object-name`` say 'universe' "
"which means 'all object-types and all objects'. In this case, object name"
" is omitted."
msgstr ""
"**Вариант:** вместо ``object-type, object-name`` введите 'universe', что "
"означает 'все типы объектов и все объекты'. В таком случае имя объекта "
"опускается."

#: ../doc/book/box/box_schema.rst:309 ../doc/book/box/box_schema.rst:349
msgid ""
"**Variation:** instead of ``privilege, object-type, object-name`` say "
"``role-name`` (see section :ref:`Roles <authentication-roles>`)."
msgstr ""
"**Вариант:** вместо ``privilege, object-type, object-name`` введите "
"``role-name`` (имя роли) (см. раздел :ref:`Роли <authentication-roles>`)."

#: ../doc/book/box/box_schema.rst:314
msgid ""
"``grantor`` = *grantor_name_or_id* -- string or number, for custom "
"grantor,"
msgstr ""
"``grantor`` = *grantor_name_or_id* -- строка или номер для заданного "
"пользователя, выдающего права,"

#: ../doc/book/box/box_schema.rst:315
msgid ""
"``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; "
"``true`` means there should be no error if the user already has the "
"privilege."
msgstr ""
"``if_not_exists`` (если отсутствует) = ``true|false`` (правда/ложь, по "
"умолчанию ложь) - логическое значение boolean; ``true`` (правда) "
"означает, что ошибка не выпадет, если у пользователя уже есть права."

#: ../doc/book/box/box_schema.rst:320
msgid ""
"box.schema.user.grant('Lena', 'read', 'space', 'tester')\n"
"box.schema.user.grant('Lena', 'execute', 'function', 'f')\n"
"box.schema.user.grant('Lena', 'read,write', 'universe')\n"
"box.schema.user.grant('Lena', 'Accountant')\n"
"box.schema.user.grant('Lena', 'read,write,execute', 'universe')\n"
"box.schema.user.grant('X', 'read', 'universe', nil, {if_not_exists=true}))"
msgstr ""
"box.schema.user.grant('Lena', 'read', 'space', 'tester')\n"
"box.schema.user.grant('Lena', 'execute', 'function', 'f')\n"
"box.schema.user.grant('Lena', 'read,write', 'universe')\n"
"box.schema.user.grant('Lena', 'Accountant')\n"
"box.schema.user.grant('Lena', 'read,write,execute', 'universe')\n"
"box.schema.user.grant('X', 'read', 'universe', nil, {if_not_exists=true}))"

#: ../doc/book/box/box_schema.rst:334
msgid ""
"Revoke :ref:`privileges <authentication-owners_privileges>` from a user "
"or from another role."
msgstr ""
"Отмена :ref:`прав <authentication-owners_privileges>` пользователя или "
"другой роли."

#: ../doc/book/box/box_schema.rst:340
msgid "'space' or 'function' or 'sequence'."
msgstr ""
"'space' (спейс) или 'function' (функция), или 'sequence' "
"(последовательность)."

#: ../doc/book/box/box_schema.rst:341
msgid "the name of a function or space or sequence."
msgstr "имя функции, спейса или последовательности."

#: ../doc/book/box/box_schema.rst:343
msgid ""
"The user must exist, and the object must exist, but it is not an error if"
" the user does not have the privilege."
msgstr ""
"Должен существовать пользователь, должен существовать объект, но ошибка "
"не выпадет, если у пользователя нет прав."

#: ../doc/book/box/box_schema.rst:346 ../doc/book/box/box_schema.rst:548
msgid ""
"**Variation:** instead of ``object-type, object-name`` say 'universe' "
"which means 'all object-types and all objects'."
msgstr ""
"**Вариант:** вместо ``object-type, object-name`` введите 'universe', что "
"означает 'все типы объектов и все объекты'."

#: ../doc/book/box/box_schema.rst:354
msgid ""
"box.schema.user.revoke('Lena', 'read', 'space', 'tester')\n"
"box.schema.user.revoke('Lena', 'execute', 'function', 'f')\n"
"box.schema.user.revoke('Lena', 'read,write', 'universe')\n"
"box.schema.user.revoke('Lena', 'Accountant')"
msgstr ""
"box.schema.user.revoke('Lena', 'read', 'space', 'tester')\n"
"box.schema.user.revoke('Lena', 'execute', 'function', 'f')\n"
"box.schema.user.revoke('Lena', 'read,write', 'universe')\n"
"box.schema.user.revoke('Lena', 'Accountant')"

#: ../doc/book/box/box_schema.rst:365
msgid ""
"Return a hash of a user's password. For explanation of how Tarantool "
"maintains passwords, see section :ref:`Passwords <authentication-"
"passwords>` and reference on :ref:`_user <box_space-user>` space."
msgstr ""
"Возврат хеша пароля пользователя. Чтобы получить информацию о том, как "
"происходит управление паролями в Tarantool'е, см. раздел :ref:`Пароли "
"<authentication-passwords>` и справочник по спейсу :ref:`_user "
"<box_space-user>`."

#: ../doc/book/box/box_schema.rst:371
msgid ""
"If a non-'guest' user has no password, it’s **impossible** to connect to "
"Tarantool using this user. The user is regarded as “internal” only, not "
"usable from a remote connection. Such users can be useful if they have "
"defined some procedures with the :ref:`SETUID <box_schema-func_create>` "
"option, on which privileges are granted to externally-connectable users. "
"This way, external users cannot create/drop objects, they can only invoke"
" procedures."
msgstr ""
"Если у пользователя, который не является пользователем 'guest' нет "
"пароля, **невозможно** подключиться к Tarantool'у через этого "
"пользователя. Пользователь считается только “внутренним”, его нельзя "
"использовать для удаленного подключения. Такие пользователи могут "
"работать, если они определили какие-либо процедуры с помощью :ref:`SETUID"
" <box_schema-func_create>`, на которые есть доступ у пользователей с "
"внешним подключением. Таким образом, внешние пользователи могут не "
"создавать/удалять объекты, а только вызывать процедуры."

#: ../doc/book/box/box_schema.rst:378
msgid ""
"For the 'guest' user, it’s impossible to set a password: that would be "
"misleading, since 'guest' is the default user on a newly-established "
"connection over a :ref:`binary port <admin-security>`, and Tarantool does"
" not require a password to establish a :ref:`binary connection "
"<box_protocol-iproto_protocol>`. It is, however, possible to change the "
"current user to ‘guest’ by providing the :ref:`AUTH packet <box_protocol-"
"authentication>` with no password at all or an empty password. This "
"feature is useful for connection pools, which want to reuse a connection "
"for a different user without re-establishing it."
msgstr ""
"Для пользователя 'guest' невозможно установить пароль: это бы привело к "
"путанице, поскольку 'guest' является пользователем по умолчанию для "
"любого установленного подключения по :ref:`бинарному порту <admin-"
"security>`, а Tarantool не требует пароль при установке :ref:`бинарного "
"подключения <box_protocol-iproto_protocol>`. Тем не менее, можно сменить "
"текущего пользователя на пользователя ‘guest’, предоставив "
":ref:`AUTH-пакет <box_protocol-authentication>` (пакет авторизации) без "
"пароля или с пустым паролем. Данная функция полезна для пулов соединений,"
" которые хотят повторно использовать соединение для другого пользователя "
"без повторного подключения."

#: ../doc/book/box/box_schema.rst:388
msgid "password to be hashed"
msgstr "пароль для хеширования"

#: ../doc/book/box/box_schema.rst:393
msgid "box.schema.user.password('ЛЕНА')"
msgstr "box.schema.user.password('ЛЕНА')"

#: ../doc/book/box/box_schema.rst:401
msgid ""
"Associate a password with the user who is currently logged in, or with "
"the user specified by user-name. The user must exist and must not be "
"'guest'."
msgstr ""
"Ассоциация пароля с авторизованным пользователем или с указанным именем "
"пользователя. Такой пользователь должен существовать и не быть "
"пользователем 'guest'."

#: ../doc/book/box/box_schema.rst:404
msgid ""
"Users who wish to change their own passwords should use "
"``box.schema.user.passwd(password)`` syntax."
msgstr ""
"Если пользователь хочет поменять свой пароль, ему следует использовать "
"синтаксис ``box.schema.user.passwd(password)``."

#: ../doc/book/box/box_schema.rst:407
msgid ""
"Administrators who wish to change passwords of other users should use "
"``box.schema.user.passwd(user-name, password)`` syntax."
msgstr ""
"Если администратор хочет поменять пароль других пользователей, ему "
"следует использовать синтаксис ``box.schema.user.passwd(user-name, "
"password)``."

#: ../doc/book/box/box_schema.rst:410
msgid "user-name"
msgstr "имя пользователя"

#: ../doc/book/box/box_schema.rst:411
msgid "password"
msgstr "пароль"

#: ../doc/book/box/box_schema.rst:415
msgid ""
"box.schema.user.passwd('ЛЕНА')\n"
"box.schema.user.passwd('Lena', 'ЛЕНА')"
msgstr ""
"box.schema.user.passwd('ЛЕНА')\n"
"box.schema.user.passwd('Lena', 'ЛЕНА')"

#: ../doc/book/box/box_schema.rst:424
#, fuzzy
msgid ""
"Return a description of a user's :ref:`privileges <authentication-"
"owners_privileges>`."
msgstr "Выдача :ref:`прав <authentication-owners_privileges>` роли."

#: ../doc/book/box/box_schema.rst:446
msgid ""
"Create a role. For explanation of how Tarantool maintains role data, see "
"section :ref:`Roles <authentication-roles>`."
msgstr ""
"Создание роли. Чтобы получить информацию о том, как происходит управление"
" данными о ролях в Tarantool'е, см. раздел :ref:`Роли <authentication-"
"roles>`."

#: ../doc/book/box/box_schema.rst:450
msgid ""
"name of role, which should conform to the :ref:`rules for object names "
"<app_server-names>`"
msgstr ""
"имя роли, которое должно соответствовать :ref:`правилам именования "
"объектов <app_server-names>`"

#: ../doc/book/box/box_schema.rst:452
msgid ""
"``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; "
"``true`` means there should be no error if the role already exists"
msgstr ""
"``if_not_exists`` (если отсутствует) = ``true|false`` (правда/ложь, по "
"умолчанию ложь) - логическое значение boolean; ``true`` (правда) "
"означает, что ошибка не выпадет, если роль уже существует."

#: ../doc/book/box/box_schema.rst:460
msgid ""
"box.schema.role.create('Accountant')\n"
"box.schema.role.create('Accountant', {if_not_exists = false})"
msgstr ""
"box.schema.role.create('Accountant')\n"
"box.schema.role.create('Accountant', {if_not_exists = false})"

#: ../doc/book/box/box_schema.rst:469
msgid ""
"Drop a role. For explanation of how Tarantool maintains role data, see "
"section :ref:`Roles <authentication-roles>`."
msgstr ""
"Удаление роли. Чтобы получить информацию о том, как происходит управление"
" данными о ролях в Tarantool'е, см. раздел :ref:`Роли <authentication-"
"roles>`."

#: ../doc/book/box/box_schema.rst:473 ../doc/book/box/box_schema.rst:489
msgid "the name of the role"
msgstr "имя роли"

#: ../doc/book/box/box_schema.rst:474
msgid ""
"``if_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` "
"means there should be no error if the role does not exist."
msgstr ""
"``if_exists`` (если существует) = ``true|false`` (правда/ложь, по "
"умолчанию ложь) - логическое значение boolean; ``true`` (правда) "
"означает, что ошибка не выпадет, если такая роль не существует."

#: ../doc/book/box/box_schema.rst:479
msgid "box.schema.role.drop('Accountant')"
msgstr "box.schema.role.drop('Accountant')"

#: ../doc/book/box/box_schema.rst:487
msgid ""
"Return ``true`` if a role exists; return ``false`` if a role does not "
"exist."
msgstr ""
"Возврат ``true`` (правда), если роль существует; возврат ``false`` "
"(ложь), если роль отсутствует."

#: ../doc/book/box/box_schema.rst:494
msgid "box.schema.role.exists('Accountant')"
msgstr "box.schema.role.exists('Accountant')"

#: ../doc/book/box/box_schema.rst:504
msgid "Grant :ref:`privileges <authentication-owners_privileges>` to a role."
msgstr "Выдача :ref:`прав <authentication-owners_privileges>` роли."

#: ../doc/book/box/box_schema.rst:506 ../doc/book/box/box_schema.rst:539
#: ../doc/book/box/box_schema.rst:569
msgid "the name of the role."
msgstr "имя роли."

#: ../doc/book/box/box_schema.rst:510 ../doc/book/box/box_schema.rst:543
msgid "the name of a function or space or sequence or role."
msgstr "имя функции, спейса, последовательности или роли."

#: ../doc/book/box/box_schema.rst:511
msgid ""
"``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; "
"``true`` means there should be no error if the role already has the "
"privilege."
msgstr ""
"``if_not_exists`` (если отсутствует) = ``true|false`` (правда/ложь, по "
"умолчанию ложь) - логическое значение boolean; ``true`` (правда) "
"означает, что ошибка не выпадет, если у роли уже есть права."

#: ../doc/book/box/box_schema.rst:515
msgid "The role must exist, and the object must exist."
msgstr "Должна существовать роль, должен существовать объект."

#: ../doc/book/box/box_schema.rst:520
msgid ""
"**Variation:** instead of ``privilege, object-type, object-name`` say "
"``role-name`` -- to grant a role to a role."
msgstr ""
"**Вариант:** вместо ``privilege, object-type, object-name`` введите "
"``role-name``, чтобы назначить роль для роли."

#: ../doc/book/box/box_schema.rst:525
msgid ""
"box.schema.role.grant('Accountant', 'read', 'space', 'tester')\n"
"box.schema.role.grant('Accountant', 'execute', 'function', 'f')\n"
"box.schema.role.grant('Accountant', 'read,write', 'universe')\n"
"box.schema.role.grant('public', 'Accountant')\n"
"box.schema.role.grant('role1', 'role2', nil, nil, {if_not_exists=false})"
msgstr ""
"box.schema.role.grant('Accountant', 'read', 'space', 'tester')\n"
"box.schema.role.grant('Accountant', 'execute', 'function', 'f')\n"
"box.schema.role.grant('Accountant', 'read,write', 'universe')\n"
"box.schema.role.grant('public', 'Accountant')\n"
"box.schema.role.grant('role1', 'role2', nil, nil, {if_not_exists=false})"

#: ../doc/book/box/box_schema.rst:537
msgid "Revoke :ref:`privileges <authentication-owners_privileges>` from a role."
msgstr "Отмена :ref:`прав <authentication-owners_privileges>` роли."

#: ../doc/book/box/box_schema.rst:545
msgid ""
"The role must exist, and the object must exist, but it is not an error if"
" the role does not have the privilege."
msgstr ""
"Должна существовать роль, должен существовать объект, но ошибка не "
"выпадет, если у роли нет прав."

#: ../doc/book/box/box_schema.rst:551
msgid ""
"**Variation:** instead of ``privilege, object-type, object-name`` say "
"``role-name``."
msgstr ""
"**Вариант:** вместо ``privilege, object-type, object-name`` введите "
"``role-name``."

#: ../doc/book/box/box_schema.rst:556
msgid ""
"box.schema.role.revoke('Accountant', 'read', 'space', 'tester')\n"
"box.schema.role.revoke('Accountant', 'execute', 'function', 'f')\n"
"box.schema.role.revoke('Accountant', 'read,write', 'universe')\n"
"box.schema.role.revoke('public', 'Accountant')"
msgstr ""
"box.schema.role.revoke('Accountant', 'read', 'space', 'tester')\n"
"box.schema.role.revoke('Accountant', 'execute', 'function', 'f')\n"
"box.schema.role.revoke('Accountant', 'read,write', 'universe')\n"
"box.schema.role.revoke('public', 'Accountant')"

#: ../doc/book/box/box_schema.rst:567
msgid "Return a description of a role's privileges."
msgstr "Возврат описания прав роли."

#: ../doc/book/box/box_schema.rst:573
msgid "box.schema.role.info('Accountant')"
msgstr "box.schema.role.info('Accountant')"

#: ../doc/book/box/box_schema.rst:581
msgid ""
"Create a function :ref:`tuple <index-box_tuple>`. without including the "
"``body`` option. (For functions created without the ``body`` option, see "
":ref:`box.schema.func.create(func-name [, {options-with-body}]) "
"<box_schema-func_create_with-body>`."
msgstr ""

#: ../doc/book/box/box_schema.rst:586
msgid ""
"This is called a \"not persistent\" function because functions without "
"bodies are not persistent. This does not create the function itself -- "
"that is done with Lua -- but if it is necessary to grant privileges for a"
" function, box.schema.func.create must be done first. For explanation of "
"how Tarantool maintains function data, see the reference for the "
":ref:`box.space._func <box_space-func>` space."
msgstr ""

#: ../doc/book/box/box_schema.rst:595
msgid ""
"``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; "
"``true`` means there should be no error if the ``_func`` tuple already "
"exists."
msgstr ""
"``if_not_exists`` (если отсутствует) = ``true|false`` (правда/ложь, по "
"умолчанию ложь) - логическое значение boolean; ``true`` (правда) "
"означает, что ошибка не выпадет, если кортеж в ``_func`` уже существует."

#: ../doc/book/box/box_schema.rst:598
#, fuzzy
msgid ""
"``setuid`` = ``true|false`` (default = ``false``) - boolean; ``true`` "
"means that Tarantool should treat the function’s caller as the function’s"
" owner, with owner privileges. ``setuid`` works only over :ref:`binary "
"ports <admin-security>`, ``setuid`` does not work if the function is "
"invoked via an :ref:`admin console <admin-security>` or inside a Lua "
"script."
msgstr ""
"``setuid`` = ``true|false`` (по умолчанию, false) -- значение ``true`` "
"(правда) заставит Tarantool рассматривать пользователя, вызвавшего "
"функцию, в качестве владельца функции с полными правами. Следует помнить,"
" что SETUID работает только по :ref:`бинарным портам <admin-security>`. "
"SETUID не сработает, если вызвать функцию через :ref:`административную "
"консоль <admin-security>` или в Lua-скрипте."

#: ../doc/book/box/box_schema.rst:605
#, fuzzy
msgid "``language`` = 'LUA'|'C' (default = ‘LUA’) - string."
msgstr "``language`` = 'LUA'|'C' (выбор языка из Lua и C; по умолчанию, ‘LUA’)."

#: ../doc/book/box/box_schema.rst:607 ../doc/book/box/box_schema.rst:657
msgid ""
"name of function, which should conform to the :ref:`rules for object "
"names <app_server-names>`"
msgstr ""
"имя функции, которое должно соответствовать :ref:`правилам именования "
"объектов <app_server-names>`"

#: ../doc/book/box/box_schema.rst:609
msgid "``if_not_exists``, ``setuid``, ``language``."
msgstr "``if_not_exists``, ``setuid``, ``language``."

#: ../doc/book/box/box_schema.rst:615
msgid ""
"box.schema.func.create('calculate')\n"
"box.schema.func.create('calculate', {if_not_exists = false})\n"
"box.schema.func.create('calculate', {setuid = false})\n"
"box.schema.func.create('calculate', {language = 'LUA'})"
msgstr ""
"box.schema.func.create('calculate')\n"
"box.schema.func.create('calculate', {if_not_exists = false})\n"
"box.schema.func.create('calculate', {setuid = false})\n"
"box.schema.func.create('calculate', {language = 'LUA'})"

#: ../doc/book/box/box_schema.rst:626
msgid ""
"Create a function :ref:`tuple <index-box_tuple>`. including the ``body`` "
"option. (For functions created without the ``body`` option, see "
":ref:`box.schema.func.create(func-name [, {options-without-body}]) "
"<box_schema-func_create>`."
msgstr ""

#: ../doc/book/box/box_schema.rst:631
msgid ""
"This is called a \"persistent\" function because only functions with "
"bodies are persistent. This does create the function itself, the body is "
"a function definition. For explanation of how Tarantool maintains "
"function data, see the reference for the :ref:`box.space._func "
"<box_space-func>` space."
msgstr ""

#: ../doc/book/box/box_schema.rst:638
msgid ""
"``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; same "
"as for :ref:`box.schema.func.create(func-name [, {options-without-body}])"
" <box_schema-func_create>`."
msgstr ""

#: ../doc/book/box/box_schema.rst:641
msgid ""
"``setuid`` = ``true|false`` (default = ``false``) - boolean; same as for "
":ref:`box.schema.func.create(func-name [, {options-without-body}]) "
"<box_schema-func_create>`."
msgstr ""

#: ../doc/book/box/box_schema.rst:644
msgid ""
"``language`` = 'LUA'|'C' (default = ‘LUA’) - string. same as for "
":ref:`box.schema.func.create(func-name [, {options-without-body}]) "
"<box_schema-func_create>`."
msgstr ""

#: ../doc/book/box/box_schema.rst:647
#, fuzzy
msgid ""
"``is_sandboxed`` = ``true|false`` (default = ``false``) - boolean; "
"whether the function should be executed in a sandbox."
msgstr ""
"``if_exists`` (если существует) = ``true|false`` (правда/ложь, по "
"умолчанию ложь) - логическое значение boolean; ``true`` (правда) "
"означает, что ошибка не выпадет, если такой пользователь не существует."

#: ../doc/book/box/box_schema.rst:650
#, fuzzy
msgid ""
"``is_deterministic`` = ``true|false`` (default = ``false``) - boolean; "
"``true`` means that the function should be deterministic, ``false`` means"
" that the function may or may not be deterministic."
msgstr ""
"``if_exists`` (если существует) = ``true|false`` (правда/ложь, по "
"умолчанию ложь) - логическое значение boolean; ``true`` (правда) "
"означает, что ошибка не выпадет, если кортеж в _func не существует."

#: ../doc/book/box/box_schema.rst:654
msgid ""
"``body`` = function definition (default = nil) - string; the function "
"definition."
msgstr ""

#: ../doc/book/box/box_schema.rst:659
#, fuzzy
msgid ""
"``if_not_exists``, ``setuid``, ``language``, ``is_sandboxed``, "
"``is_deterministic``, ``body``."
msgstr "``if_not_exists``, ``setuid``, ``language``."

#: ../doc/book/box/box_schema.rst:663
msgid ""
"C functions are imported from .so files, Lua functions can be defined "
"within ``body``. We will only describe Lua functions in this section."
msgstr ""

#: ../doc/book/box/box_schema.rst:666
msgid ""
"A function tuple with a body is \"persistent\" because the tuple is "
"stored in a snapshot and is recoverable if the server restarts. All of "
"the option values described in this section are visible in the "
":ref:`box.space._func <box_space-func>` system space."
msgstr ""

#: ../doc/book/box/box_schema.rst:671
msgid ""
"If ``is_sandboxed`` is true, then the function will be executed in an "
"isolated environment: any operation that accesses the world outside the "
"sandbox will be forbidden or will have no effect. Therefore a sandboxed "
"function can only use modules and functions which cannot affect "
"isolation: `assert <https://www.lua.org/manual/5.1/manual.html#pdf-"
"assert>`_ `error <://www.lua.org/manual/5.1/manual.html#pdf-error>`_ "
"`ipairs <https://www.lua.org/manual/5.1/manual.html#pdf-ipairs>`_ `math.*"
" <https://www.lua.org/manual/5.1/manual.html#5.6>`_ `next "
"<https://www.lua.org/manual/5.1/manual.html#pdf-next>`_ `pairs "
"<https://www.lua.org/manual/5.1/manual.html#pdf-pairs>`_ `pcall "
"<https://www.lua.org/manual/5.1/manual.html#pdf-pcall>`_ `print "
"<https://www.lua.org/manual/5.1/manual.html#pdf-print>`_ `select "
"<https://www.lua.org/manual/5.1/manual.html#pdf-select>`_ `string.* "
"<https://www.lua.org/manual/5.1/manual.html#5.4>`_ `table.* "
"<https://www.lua.org/manual/5.1/manual.html#5.5>`_ `tonumber "
"<https://www.lua.org/manual/5.1/manual.html#pdf-tonumber>`_ `tostring "
"<https://www.lua.org/manual/5.1/manual.html#pdf-tostring>`_ `type "
"<https://www.lua.org/manual/5.1/manual.html#pdf-type>`_ `unpack "
"<https://www.lua.org/manual/5.1/manual.html#pdf-unpack>`_ :ref:`utf8.* "
"<utf8-module>` `xpcall <https://www.lua.org/manual/5.1/manual.html#pdf-"
"xpcall>`_. Also a sandboxed function cannot refer to global variables -- "
"they will be treated as local variables because the sandbox is "
"established with `setfenv <https://www.lua.org/manual/5.1/manual.html"
"#pdf-setfenv>`_. So a sandboxed function will happen to be stateless and "
"deterministic."
msgstr ""

#: ../doc/book/box/box_schema.rst:698
msgid ""
"If ``is_deterministic`` is true, there is no immediate effect. Tarantool "
"plans to use the is_deterministic value in a future version. A function "
"is deterministic if it always returns the same outputs given the same "
"inputs. It is the function creator's responsibility to ensure that a "
"function is truly deterministic."
msgstr ""

#: ../doc/book/box/box_schema.rst:704
msgid "**Using a persistent Lua function**"
msgstr ""

#: ../doc/book/box/box_schema.rst:706
msgid ""
"After a persistent Lua function is created, it can be found in the "
":ref:`box.space._func <box_space-func>` system space, and it can be shown"
" with |br| :samp:`box.func.{func-name}` |br| and it can be invoked by any"
" user with :ref:`authorization <authentication-owners_privileges>` to "
"'execute' it. The syntax for invoking is: |br| :samp:`box.func.{func-"
"name}:call([parameters])` |br| or, if the connection is remote, the "
"syntax is as in :ref:`net_box:call() <net_box-call>`."
msgstr ""

#: ../doc/book/box/box_schema.rst:719
msgid ""
"tarantool> lua_code = [[function(a, b) return a + b end]]\n"
"tarantool> box.schema.func.create('sum', {body = lua_code})\n"
"\n"
"tarantool> box.func.sum\n"
"---\n"
"- is_sandboxed: false\n"
"  is_deterministic: false\n"
"  id: 2\n"
"  setuid: false\n"
"  body: function(a, b) return a + b end\n"
"  name: sum\n"
"  language: LUA\n"
"...\n"
"\n"
"tarantool> box.func.sum.call({1, 2})\n"
"---\n"
"- 3\n"
"..."
msgstr ""

#: ../doc/book/box/box_schema.rst:744
msgid ""
"Drop a function tuple. For explanation of how Tarantool maintains "
"function data, see reference on :ref:`_func space <box_space-func>`."
msgstr ""
"Удаление кортежа с функцией. Чтобы получить информацию о том, как "
"происходит управление данными функций в Tarantool'е, см. справочник по "
"спейсу :ref:`_func <box_space-func>`."

#: ../doc/book/box/box_schema.rst:748 ../doc/book/box/box_schema.rst:765
msgid "the name of the function"
msgstr "имя функции"

#: ../doc/book/box/box_schema.rst:749
msgid ""
"``if_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` "
"means there should be no error if the _func tuple does not exist."
msgstr ""
"``if_exists`` (если существует) = ``true|false`` (правда/ложь, по "
"умолчанию ложь) - логическое значение boolean; ``true`` (правда) "
"означает, что ошибка не выпадет, если кортеж в _func не существует."

#: ../doc/book/box/box_schema.rst:754
msgid "box.schema.func.drop('calculate')"
msgstr "box.schema.func.drop('calculate')"

#: ../doc/book/box/box_schema.rst:762
msgid ""
"Return true if a function tuple exists; return false if a function tuple "
"does not exist."
msgstr ""
"Возврат true (правда), если кортеж с функцией существует; возврат false "
"(ложь), если кортеж с функцией отсутствует."

#: ../doc/book/box/box_schema.rst:770
msgid "box.schema.func.exists('calculate')"
msgstr "box.schema.func.exists('calculate')"

#: ../doc/book/box/box_schema.rst:778
msgid "Reload a C module with all its functions without restarting the server."
msgstr "Перезагрузка модуля на C (со всеми его функциями) без перезапуска сервера."

#: ../doc/book/box/box_schema.rst:780
msgid ""
"Under the hood, Tarantool loads a new copy of the module (``*.so`` shared"
" library) and starts routing all new request to the new version. The "
"previous version remains active until all started calls are finished. All"
" shared libraries are loaded with ``RTLD_LOCAL`` (see \"man 3 dlopen\"), "
"therefore multiple copies can co-exist without any problems."
msgstr ""
"С точки зрения внутреннего устройства, Tarantool загружает новую копию "
"модуля (библиотека общего пользования ``*.so``) и запускает маршрутизацию"
" всех новых запросов на новую версию. Предыдущая версия остается активной"
" до тех пор, пока не завершатся все начатые вызовы. Все библиотеки общего"
" пользования загружены с ``RTLD_LOCAL`` (см. \"man 3 dlopen\"), таким "
"образом, множество копий могут работать одновременно без каких-либо "
"проблем."

#: ../doc/book/box/box_schema.rst:788
msgid ""
"Reload will fail if a module was loaded from Lua script with `ffi.load() "
"<http://luajit.org/ext_ffi_api.html#ffi_load>`_."
msgstr ""
"Перезагрузка не сработает, если модуль был загружен из Lua-скрипта с "
"`ffi.load() <http://luajit.org/ext_ffi_api.html#ffi_load>`_."

#: ../doc/book/box/box_schema.rst:791
msgid "the name of the module to reload"
msgstr "имя модуля для перезагрузки"

#: ../doc/book/box/box_schema.rst:795
msgid ""
"-- reload the entire module contents\n"
"box.schema.func.reload('module')"
msgstr ""
"-- перегрузить целиком всё содержимое модуля\n"
"box.schema.func.reload('module')"

#: ../doc/book/box/box_schema.rst:804 ../doc/book/box/data_model.rst:471
msgid "Sequences"
msgstr "Последовательности"

#: ../doc/book/box/box_schema.rst:806
msgid ""
"An introduction to sequences is in the :ref:`Sequences <index-"
"box_sequence>` section of the \"Data model\" chapter. Here are the "
"details for each function and option."
msgstr ""
"Вводная информация о последовательностях дается в разделе "
":ref:`Последовательности <index-box_sequence>` главы \"Модель данных\". "
"Здесь же приведена подробная информация о каждой функции и каждом "
"параметре."

#: ../doc/book/box/box_schema.rst:810
msgid ""
"All functions related to sequences require appropriate :ref:`privileges "
"<authentication-owners_privileges>`."
msgstr ""
"Все функции, связанные с последовательностями, требуют наличия "
"соответствующих :ref:`прав <authentication-owners_privileges>`."

#: ../doc/book/box/box_schema.rst:817
msgid "Create a new sequence generator."
msgstr "Создание нового генератора последовательностей."

#: ../doc/book/box/box_schema.rst:819
msgid "the name of the sequence"
msgstr "имя последовательности"

#: ../doc/book/box/box_schema.rst:821
msgid ""
"see a quick overview in the \"Options for "
"``box.schema.sequence.create()``\" :ref:`chart <index-box_sequence-"
"options>` (in the :ref:`Sequences <index-box_sequence>` section of the "
"\"Data model\" chapter), and see more details below."
msgstr ""
"см. краткий обзор в :ref:`таблице <index-box_sequence-options>` "
"\"Параметры для ``box.schema.sequence.create()``\"  (в разделе "
":ref:`Последовательности <index-box_sequence>` главы \"Модель данных\"), "
"а более подробную информацию ниже."

#: ../doc/book/box/box_schema.rst:828
msgid "a reference to a new sequence object."
msgstr "ссылка на новый объект последовательности."

#: ../doc/book/box/box_schema.rst:830
msgid "Options:"
msgstr "Параметры:"

#: ../doc/book/box/box_schema.rst:832
msgid "``start`` -- the STARTS WITH value. Type = integer, Default = 1."
msgstr "``start`` -- НАЧАЛЬНОЕ значение. Тип = целое число, по умолчанию = 1."

#: ../doc/book/box/box_schema.rst:834
msgid "``min`` -- the MINIMUM value. Type = integer, Default = 1."
msgstr "``min`` -- МИНИМАЛЬНОЕ значение. Тип = целое число, по умолчанию = 1."

#: ../doc/book/box/box_schema.rst:836
msgid ""
"``max`` - the MAXIMUM value. Type = integer, Default = "
"9223372036854775807."
msgstr ""
"``max`` --МАКСИМАЛЬНОЕ значение. Тип = целое число, по умолчанию = "
"9223372036854775807."

#: ../doc/book/box/box_schema.rst:838
msgid ""
"There is a rule: ``min`` <= ``start`` <= ``max``. For example it is "
"illegal to say ``{start=0}`` because then the specified start value (0) "
"would be less than the default min value (1)."
msgstr ""
"Есть следующее правило: ``min`` <= ``start`` <= ``max``. Например, нельзя"
" указать ``{start=0}``, поскольку указанное начальное значение (0) будет "
"меньше, чем минимальное значение, используемое по умолчанию (1)."

#: ../doc/book/box/box_schema.rst:842
msgid ""
"There is a rule: ``min`` <= next-value <= ``max``. For example, if the "
"next generated value would be 1000, but the maximum value is 999, then "
"that would be considered \"overflow\"."
msgstr ""
"Есть следующее правило: ``min`` <= следующее-значение <= ``max``. "
"Например, если сгенерированное значение будет 1000, но максимальное "
"значение -- 999, это будет считаться переполнением."

#: ../doc/book/box/box_schema.rst:847
msgid ""
"There is a rule: ``start`` and ``min`` and ``max`` must all be <= "
"9223372036854775807 which is 2^63 - 1 (not 2^64)."
msgstr ""

#: ../doc/book/box/box_schema.rst:850
msgid "``cycle`` -- the CYCLE value. Type = bool. Default = false."
msgstr ""
"``cycle`` -- значение ЦИКЛА. Тип = bool (логический), по умолчанию = "
"false (ложь)."

#: ../doc/book/box/box_schema.rst:852
msgid ""
"If the sequence generator's next value is an overflow number, it causes "
"an error return -- unless ``cycle == true``."
msgstr ""
"Если следующее значение в генераторе последовательности будет "
"переполнением, это вызовет ошибку -- не считая случаев, когда задан цикл "
"(``cycle == true``)."

#: ../doc/book/box/box_schema.rst:855
msgid ""
"But if ``cycle == true``, the count is started again, at the MINIMUM "
"value or at the MAXIMUM value (not the STARTS WITH value)."
msgstr ""
"Если же ``cycle == true``, отсчет начинается заново с МИНИМАЛЬНОГО "
"значения или с МАКСИМАЛЬНОГО значения (не с НАЧАЛЬНОГО значения)."

#: ../doc/book/box/box_schema.rst:858
msgid "``cache`` -- the CACHE value. Type = unsigned integer. Default = 0."
msgstr ""
"``cache`` -- значение КЭША. Тип = беззнаковое целое число, по умолчанию ="
" 0."

#: ../doc/book/box/box_schema.rst:860
msgid "Currently Tarantool ignores this value, it is reserved for future use."
msgstr ""
"В данный момент Tarantool игнорирует это значение, оно зарезервировано "
"для последующего использования."

#: ../doc/book/box/box_schema.rst:862
msgid "``step`` -- the INCREMENT BY value. Type = integer. Default = 1."
msgstr "``step`` -- значение УВЕЛИЧЕНИЯ. Тип = целое число, по умолчанию = 1."

#: ../doc/book/box/box_schema.rst:864
msgid "Ordinarily this is what is added to the previous value."
msgstr "Это значение прибавляется к предыдущему."

#: ../doc/book/box/box_schema.rst:870
msgid "Generate the next value and return it."
msgstr "Генерация и возврат следующего значения."

#: ../doc/book/box/box_schema.rst:872
msgid "The generation algorithm is simple:"
msgstr "Простой алгоритм для генерации:"

#: ../doc/book/box/box_schema.rst:874
msgid "If this is the first time, then return the STARTS WITH value."
msgstr "В первый раз вернуть НАЧАЛЬНОЕ значение."

#: ../doc/book/box/box_schema.rst:875
msgid ""
"If the previous value plus the INCREMENT value is less than the MINIMUM "
"value or greater than the MAXIMUM value, that is \"overflow\", so either "
"raise an error (if ``cycle`` = ``false``) or return the MAXIMUM value (if"
" ``cycle`` = ``true`` and ``step`` < 0) or return the MINIMUM value (if "
"``cycle`` = ``true`` and ``step`` > 0)."
msgstr ""
"Если предыдущее значение плюс значение УВЕЛИЧЕНИЯ меньше, чем МИНИМАЛЬНОЕ"
" значение, или больше, чем МАКСИМАЛЬНОЕ значение, будет переполнение, "
"поэтому либо выдать сообщение об ошибке (если цикл не задан -- ``cycle`` "
"= ``false``) или вернуть МАКСИМАЛЬНОЕ значение (если цикл задан -- "
"``cycle`` = ``true`` -- и ``step`` < 0), или вернуть МИНИМАЛЬНОЕ значение"
" (если цикл задан -- ``cycle`` = ``true`` -- и ``step`` > 0)."

#: ../doc/book/box/box_schema.rst:881
msgid ""
"If there was no error, then save the returned result, it is now the "
"\"previous value\"."
msgstr ""
"Если ошибки нет, сохранить результат, который становится \"предыдущим "
"значением\"."

#: ../doc/book/box/box_schema.rst:884
msgid "For example, suppose sequence 'S' has:"
msgstr "Например, предположим, что для последовательности 'S':"

#: ../doc/book/box/box_schema.rst:886
msgid "``min`` == -6,"
msgstr "``min`` == -6,"

#: ../doc/book/box/box_schema.rst:887
msgid "``max`` == -1,"
msgstr "``max`` == -1,"

#: ../doc/book/box/box_schema.rst:888
msgid "``step`` == -3,"
msgstr "``step`` == -3,"

#: ../doc/book/box/box_schema.rst:889
msgid "``start`` = -2,"
msgstr "``start`` = -2,"

#: ../doc/book/box/box_schema.rst:890
msgid "``cycle`` = true,"
msgstr "``cycle`` = true,"

#: ../doc/book/box/box_schema.rst:891
msgid "previous value = -2."
msgstr "предыдущее значение = -2."

#: ../doc/book/box/box_schema.rst:893
msgid "Then ``box.sequence.S:next()`` returns -5 because -2 + (-3) == -5."
msgstr "Тогда ``box.sequence.S:next()`` вернет -5, потому что -2 + (-3) == -5."

#: ../doc/book/box/box_schema.rst:895
msgid ""
"Then ``box.sequence.S:next()`` again returns -1 because -5 + (-3) < -6, "
"which is overflow, causing cycle, and ``max`` == -1."
msgstr ""
"Затем ``box.sequence.S:next()`` снова вернет -1, потому что -5 + (-3) < "
"-6, что будет переполнением, которое вызовет цикл, а ``max`` == -1."

#: ../doc/book/box/box_schema.rst:898
msgid ""
"This function requires a :ref:`'write' privilege <box_schema-user_grant>`"
" on the sequence."
msgstr ""
"Для данной функции необходимы права на :ref:`запись ('write') "
"<box_schema-user_grant>` на последовательность."

#: ../doc/book/box/box_schema.rst:903
msgid ""
"This function should not be used in \"cross-engine\" transactions "
"(transactions which use both the memtx and the vinyl storage engines)."
msgstr ""
"Данную функцию не следует использовать в транзакциях между движками "
"(транзакции, в которых используется и движок memtx, и движок vinyl)."

#: ../doc/book/box/box_schema.rst:906
msgid ""
"To see what the previous value was, without changing it, you can select "
"from the :ref:`_sequence_data <box_space-sequence_data>` system space."
msgstr ""
"Чтобы увидеть предыдущее значение, не изменяя его, сделайте выборку из "
"системного спейса :ref:`_sequence_data <box_space-sequence_data>`."

#: ../doc/book/box/box_schema.rst:914
msgid ""
"The ``alter()`` function can be used to change any of the sequence's "
"options. Requirements and restrictions are the same as for "
":ref:`box.schema.sequence.create() <box_schema-sequence_create>`."
msgstr ""
"Функцию ``alter()`` можно использовать для изменения любых параметров "
"последовательности. Требования и ограничения в данном случае такие же, "
"как для :ref:`box.schema.sequence.create() <box_schema-sequence_create>`."

#: ../doc/book/box/box_schema.rst:922
msgid ""
"Set the sequence back to its original state. The effect is that a "
"subsequent ``next()`` will return the ``start`` value. This function "
"requires a :ref:`'write' privilege <box_schema-user_grant>` on the "
"sequence."
msgstr ""
"Возврат последовательности в оригинальное состояние. Смысл в том, что "
"последующий вызов ``next()`` вернет начальное значение ``start``. Для "
"данной функции необходимы права на :ref:`запись ('write') <box_schema-"
"user_grant>` на последовательность."

#: ../doc/book/box/box_schema.rst:931
msgid ""
"Set the \"previous value\" to ``new-previous-value``. This function "
"requires a :ref:`'write' privilege <box_schema-user_grant>` on the "
"sequence."
msgstr ""
"Установите \"предыдущее значение\" на ``new-previous-value`` (новое "
"предыдущее значение). Для данной функции необходимы права на :ref:`запись"
" ('write') <box_schema-user_grant>` на последовательность."

#: ../doc/book/box/box_schema.rst:939
msgid "Drop an existing sequence."
msgstr "Удаление существующей последовательности."

#: ../doc/book/box/box_schema.rst:943
msgid "Here is an example showing all sequence options and operations:"
msgstr ""
"Ниже представлен пример, иллюстрирующий все параметры и операции для "
"последовательностей:"

#: ../doc/book/box/box_schema.rst:945
#, fuzzy
msgid ""
"s = box.schema.sequence.create(\n"
"               'S2',\n"
"               {start=100,\n"
"               min=100,\n"
"               max=tonumber64('9223372036854775807'),\n"
"               cache=100000,\n"
"               cycle=false,\n"
"               step=100\n"
"               })\n"
"s:alter({step=6})\n"
"s:next()\n"
"s:reset()\n"
"s:set(150)\n"
"s:drop()"
msgstr ""
"s = box.schema.sequence.create(\n"
"               'S2',\n"
"               {start=100,\n"
"               min=100,\n"
"               max=200,\n"
"               cache=100000,\n"
"               cycle=false,\n"
"               step=100\n"
"               })\n"
"s:alter({step=6})\n"
"s:next()\n"
"s:reset()\n"
"s:set(150)\n"
"s:drop()"

#: ../doc/book/box/box_schema.rst:966
#, fuzzy
msgid ""
"You can use the ``sequence`` option when :ref:`creating <box_space-"
"create_index>` or :ref:`altering <box_index-alter>` a primary-key index. "
"The sequence becomes associated with the index, so that the next "
"``insert()`` will put the next generated number into the primary-key "
"field, if the field value would otherwise be nil."
msgstr ""
"Можно использовать опцию :samp:`sequence={имя-последовательности}` (или "
":samp:`sequence={id-последовательности}`, или :samp:`sequence=true`) при "
":ref:`создании <box_space-create_index>` или :ref:`изменении <box_index-"
"alter>` первичного индекса. Происходит ассоциация последовательности с "
"индексом, так что следующий вызов ``insert()`` поместит следующее "
"сгенерированное число в поле первичного ключа, если в противном случае "
"поле было бы nil."

#: ../doc/book/box/box_schema.rst:973
msgid ""
"The syntax may be any of: |br| :samp:`sequence = {sequence identifier}` "
"|br| or :code:`sequence = {id =` :samp:`{sequence identifier}` :code:`}` "
"|br| or :code:`sequence = {field =` :samp:`{field number}` :code:`}` |br|"
" or :code:`sequence = {id =` :samp:`{sequence identifier}` :code:`, field"
" =` :samp:`{field number}` :code:`}` |br| or :code:`sequence = true` |br|"
" or :code:`sequence = {}`. |br| The sequence identifier may be either a "
"number (the sequence id) or a string (the sequence name). The field "
"number may be the ordinal number of any field in the index; default = 1. "
"Examples of all possibilities: ``sequence = 1`` or ``sequence = "
"'sequence_name'`` or ``sequence = {id = 1}`` or ``sequence = {id = "
"'sequence_name'}`` or ``sequence = {id = 1, field = 1}`` or ``sequence = "
"{id = 'sequence_name', field = 1}`` or ``sequence = {field = 1}`` or "
"``sequence = true`` or ``sequence = {}``. Notice that the sequence "
"identifier can be omitted, if it is omitted then a new sequence is "
"created automatically with default name = :samp:`{space-name}_seq`. "
"Notice that the field number does not have to be 1, that is, the sequence"
" can be associated with any field in the primary-key index."
msgstr ""

#: ../doc/book/box/box_schema.rst:1006
msgid ""
"For example, if 'Q' is a sequence and 'T' is a new space, then this will "
"work:"
msgstr ""
"Например, если 'Q' -- это последовательность, а 'T' -- это новый спейс, "
"то сработает:"

#: ../doc/book/box/box_schema.rst:1009
msgid ""
"tarantool> box.space.T:create_index('Q',{sequence='Q'})\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: unsigned\n"
"    is_nullable: false\n"
"    fieldno: 1\n"
"  sequence_id: 8\n"
"  id: 0\n"
"  space_id: 514\n"
"  name: Q\n"
"  type: TREE\n"
"..."
msgstr ""
"tarantool> box.space.T:create_index('Q',{sequence='Q'})\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: unsigned\n"
"    is_nullable: false\n"
"    fieldno: 1\n"
"  sequence_id: 8\n"
"  id: 0\n"
"  space_id: 514\n"
"  name: Q\n"
"  type: TREE\n"
"..."

#: ../doc/book/box/box_schema.rst:1025
msgid "(Notice that the index now has a ``sequence_id`` field.)"
msgstr ""
"(Обратите внимание, что теперь в индексе есть поле идентификатора "
"последовательности ``sequence_id``.)"

#: ../doc/book/box/box_schema.rst:1027
msgid "And this will work:"
msgstr "И сработает:"

#: ../doc/book/box/box_schema.rst:1029
msgid ""
"tarantool> box.space.T:insert{nil,0}\n"
"---\n"
"- [1, 0]\n"
"..."
msgstr ""
"tarantool> box.space.T:insert{nil,0}\n"
"---\n"
"- [1, 0]\n"
"..."

#: ../doc/book/box/box_schema.rst:1038
msgid ""
"The index key type may be either 'integer' or 'unsigned'. If any of the "
"sequence options is a negative number, then the index key type should be "
"'integer'."
msgstr ""

#: ../doc/book/box/box_schema.rst:1042
msgid ""
"Users should not insert a value greater than 9223372036854775807, which "
"is 2^63 - 1, in the indexed field. The sequence generator will ignore it."
msgstr ""

#: ../doc/book/box/box_schema.rst:1046
msgid ""
"A sequence cannot be dropped if it is associated with an index. However, "
":ref:`index_object:alter() <box_index-alter>` can be used to say that a "
"sequence is not associated with an index, for example "
"``box.space.T.index.I:alter({sequence=false})``."
msgstr ""
"Последовательность нельзя удалить, если она связана с индексом. Тем не "
"менее, можно использовать :ref:`index_object:alter() <box_index-alter>`, "
"чтобы показать, что последовательность не связана с индексом, например "
"так ``box.space.T.index.I:alter({sequence=false})``."

#: ../doc/book/box/box_schema.rst:1052
msgid ""
"If a sequence was created automatically because the sequence identifier "
"was omitted, then it will be dropped automatically if the index is "
"altered so that ``sequence=false``, or if the index is dropped."
msgstr ""

#: ../doc/book/box/box_schema.rst:1057
msgid ""
"``index_object:alter()`` can also be used to associate a sequence with an"
" existing index, with the same syntax for options."
msgstr ""

#: ../doc/book/box/box_schema.rst:1060
msgid ""
"When a sequence is used with an index based on a JSON path, inserted "
"tuples must have all components of the path preceding the autoincrement "
"field, and the autoincrement field. To achieve that use ``box.NULL`` "
"rather than ``nil``. Example:"
msgstr ""

#: ../doc/book/box/box_schema.rst:1065
msgid ""
"s = box.schema.space.create('test')\n"
"s:create_index('pk', {parts = {{'[1].a.b[1]', 'unsigned'}}, sequence = "
"true})\n"
"s:replace{} -- error\n"
"s:replace{{c = {}}} -- error\n"
"s:replace{{a = {c = {}}}} -- error\n"
"s:replace{{a = {b = {}}}} -- error\n"
"s:replace{{a = {b = {nil}}}} -- error\n"
"s:replace{{a = {b = {box.NULL}}}} -- ok"
msgstr ""

#: ../doc/book/box/box_session.rst:5
msgid "Submodule `box.session`"
msgstr "Вложенный модуль `box.session`"

#: ../doc/book/box/box_session.rst:11
msgid ""
"The ``box.session`` submodule allows querying the session state, writing "
"to a session-specific temporary Lua table, or sending out-of-band "
"messages, or setting up triggers which will fire when a session starts or"
" ends."
msgstr ""
"Вложенный модуль ``box.session`` позволяет делать запросы состояния "
"сессии, вносить записи во временную Lua-таблицу по отдельной сессии, "
"отправлять экстренные сообщения и настраивать триггеры, которые сработают"
" в начале или окончании сессии."

#: ../doc/book/box/box_session.rst:15
msgid "A *session* is an object associated with each client connection."
msgstr "*Сессия* -- это объект, связанный с каждым подключением клиента."

#: ../doc/book/box/box_session.rst:21
msgid "Below is a list of all ``box.session`` functions and members."
msgstr "Ниже приведен перечень всех функций и элементов модуля ``box.session``."

#: ../doc/book/box/box_session.rst:31
msgid ":ref:`box.session.id() <box_session-id>`"
msgstr ":ref:`box.session.id() <box_session-id>`"

#: ../doc/book/box/box_session.rst:31
msgid "Get the current session's ID"
msgstr "Получение идентификатора текущей сессии"

#: ../doc/book/box/box_session.rst:34
msgid ":ref:`box.session.exists() <box_session-exists>`"
msgstr ":ref:`box.session.exists() <box_session-exists>`"

#: ../doc/book/box/box_session.rst:34
msgid "Check if a session exists"
msgstr "Проверка наличия сессии"

#: ../doc/book/box/box_session.rst:37
msgid ":ref:`box.session.peer() <box_session-peer>`"
msgstr ":ref:`box.session.peer() <box_session-peer>`"

#: ../doc/book/box/box_session.rst:37
msgid "Get the session peer's host address and port"
msgstr "Получение адреса хоста и порта подключенного узла"

#: ../doc/book/box/box_session.rst:40
msgid ":ref:`box.session.sync() <box_session-sync>`"
msgstr ":ref:`box.session.sync() <box_session-sync>`"

#: ../doc/book/box/box_session.rst:40
msgid "Get the sync integer constant"
msgstr "Получение целочисленной константы sync"

#: ../doc/book/box/box_session.rst:43
msgid ":ref:`box.session.user() <box_session-user>`"
msgstr ":ref:`box.session.user() <box_session-user>`"

#: ../doc/book/box/box_session.rst:43
msgid "Get the current user's name"
msgstr "Получение имени текущего пользователя"

#: ../doc/book/box/box_session.rst:46
msgid ":ref:`box.session.type() <box_session-type>`"
msgstr ":ref:`box.session.type() <box_session-type>`"

#: ../doc/book/box/box_session.rst:46
msgid "Get the connection type or cause of action"
msgstr "Получение типа соединения или повода к действию"

#: ../doc/book/box/box_session.rst:49
msgid ":ref:`box.session.su() <box_session-su>`"
msgstr ":ref:`box.session.su() <box_session-su>`"

#: ../doc/book/box/box_session.rst:49
msgid "Change the current user"
msgstr "Изменение текущего пользователя"

#: ../doc/book/box/box_session.rst:52
msgid ":ref:`box.session.uid() <box_session-uid>`"
msgstr ":ref:`box.session.uid() <box_session-uid>`"

#: ../doc/book/box/box_session.rst:52
msgid "Get the current user's ID"
msgstr "Получение идентификатора текущего пользователя"

#: ../doc/book/box/box_session.rst:55
msgid ":ref:`box.session.euid() <box_session-euid>`"
msgstr ":ref:`box.session.euid() <box_session-euid>`"

#: ../doc/book/box/box_session.rst:55
msgid "Get the current effective user's ID"
msgstr "Получение идентификатора текущего действующего пользователя"

#: ../doc/book/box/box_session.rst:58
msgid ":ref:`box.session.storage <box_session-storage>`"
msgstr ":ref:`box.session.storage <box_session-storage>`"

#: ../doc/book/box/box_session.rst:58
msgid "Table with session-specific names and values"
msgstr "Таблица с именами и значениями по сессии"

#: ../doc/book/box/box_session.rst:61
msgid ":ref:`box.session.on_connect() <box_session-on_connect>`"
msgstr ":ref:`box.session.on_connect() <box_session-on_connect>`"

#: ../doc/book/box/box_session.rst:61
msgid "Define a connect trigger"
msgstr "Определение триггера для подключения"

#: ../doc/book/box/box_session.rst:64
msgid ":ref:`box.session.on_disconnect() <box_session-on_disconnect>`"
msgstr ":ref:`box.session.on_disconnect() <box_session-on_disconnect>`"

#: ../doc/book/box/box_session.rst:64
msgid "Define a disconnect trigger"
msgstr "Определение триггера для отключения"

#: ../doc/book/box/box_session.rst:67
msgid ":ref:`box.session.on_auth() <box_session-on_auth>`"
msgstr ":ref:`box.session.on_auth() <box_session-on_auth>`"

#: ../doc/book/box/box_session.rst:67
msgid "Define an authentication trigger"
msgstr "Определение триггера для аутентификации"

#: ../doc/book/box/box_session.rst:70
msgid ":ref:`box.session.push() <box_session-push>`"
msgstr ":ref:`box.session.push() <box_session-push>`"

#: ../doc/book/box/box_session.rst:70
msgid "Send an out-of-band message"
msgstr "Отправка внеполосного сообщения"

#: ../doc/book/box/box_session.rst:80
msgid ""
"the unique identifier (ID) for the current session. The result can be 0 "
"or -1 meaning there is no session."
msgstr ""
"уникальный идентификатор (ID) для текущей сессии. Результатом может быть "
"0 или -1, что означает, что сессии нет."

#: ../doc/book/box/box_session.rst:88
msgid "1 if the session exists, 0 if the session does not exist."
msgstr "1, если сессия есть; 0, если сессии нет."

#: ../doc/book/box/box_session.rst:95
msgid ""
"This function works only if there is a peer, that is, if a connection has"
" been made to a separate Tarantool instance."
msgstr ""
"Данная функция сработает только в том случае, если есть подключенная "
"программа, то есть если было выполнено подключение к отдельному "
"экземпляру Tarantool'а."

#: ../doc/book/box/box_session.rst:98
msgid ""
"The host address and port of the session peer, for example "
"\"127.0.0.1:55457\". If the session exists but there is no connection to "
"a separate instance, the return is null. The command is executed on the "
"server instance, so the \"local name\" is the server instance's host and "
"port, and the \"peer name\" is the client's host and port."
msgstr ""
"Адрес хоста и порт подключенного узла, например \"127.0.0.1:55457\". Если"
" существует сессия, но отсутствует подключение к отдельному экземпляру, "
"вернется null. Команда выполняется на экземпляре сервера,  поэтому "
"\"локальное имя\" -- это хост и порт экземпляра сервера, а \"имя узла\" "
"-- это хост и порт клиента."

#: ../doc/book/box/box_session.rst:108
msgid "Possible errors: 'session.peer(): session does not exist'"
msgstr "Возможные ошибки: 'session.peer(): сессия отсутствует'"

#: ../doc/book/box/box_session.rst:114
#, fuzzy
msgid ""
"the value of the :code:`sync` integer constant used in the `binary "
"protocol "
"<https://github.com/tarantool/tarantool/blob/2.1/src/box/iproto_constants.h>`_."
" This value becomes invalid when the session is disconnected."
msgstr ""
"значение целочисленной константы :code:`sync`, используемой в `бинарном "
"протоколе "
"<https://github.com/tarantool/tarantool/blob/1.10/src/box/iproto_constants.h>`_."
" Это значение будет недействительным после отключения сессии."

#: ../doc/book/box/box_session.rst:120
msgid ""
"This function is local for the request, i.e. not global for the session. "
"If the connection behind the session is multiplexed, this function can be"
" safely used inside the request processor."
msgstr ""

#: ../doc/book/box/box_session.rst:128
msgid "the name of the :ref:`current user <authentication-users>`"
msgstr "имя :ref:`текущего пользователя <authentication-users>`"

#: ../doc/book/box/box_session.rst:136
msgid "the type of connection or cause of action."
msgstr "тип соединения или повод к действию."

#: ../doc/book/box/box_session.rst:140
msgid "Possible return values are:"
msgstr "Возможные возвращаемые значения:"

#: ../doc/book/box/box_session.rst:142
msgid ""
"'binary' if the connection was done via the binary protocol, for example "
"to a target made with :ref:`box.cfg{listen=...} <cfg_basic-listen>`;"
msgstr ""
"'binary' (бинарное), если подключение было выполнено по бинарному "
"протоколу, например, к объекту с помощью :ref:`box.cfg{listen=...} "
"<cfg_basic-listen>`;"

#: ../doc/book/box/box_session.rst:145
msgid ""
"'console' if the connection was done via the administrative console, for "
"example to a target made with :ref:`console.listen <console-listen>`;"
msgstr ""
"'console' (консоль), если подключение было выполнено по административной "
"консоли, например, к объекту с помощью :ref:`console.listen <console-"
"listen>`;"

#: ../doc/book/box/box_session.rst:148
msgid ""
"'repl' if the connection was done directly, for example when :ref:`using "
"Tarantool as a client <admin-using_tarantool_as_a_client>`;"
msgstr ""
"'repl' (репликация), если подключение было выполнено напрямую, например, "
"при :ref:`использовании Tarantool'а в качестве клиента <admin-"
"using_tarantool_as_a_client>`;"

#: ../doc/book/box/box_session.rst:150
msgid ""
"'applier' if the action is due to :ref:`replication <replication>`, "
"regardless of how the connection was done;"
msgstr ""
"'applier' (наложение), если действие происходит по причине "
":ref:`репликации <replication>`, независимо от типа подключения;"

#: ../doc/book/box/box_session.rst:153
msgid ""
"'background' if the action is in a :ref:`background fiber <fiber-"
"module>`, regardless of whether the Tarantool server was :ref:`started in"
" the background <cfg_basic-background>`."
msgstr ""
"'background' (в фоне), если действие происходит в :ref:`фоновом файбере "
"<fiber-module>`, независимо от того, был ли Tarantool :ref:`запущен в "
"фоновом режиме <cfg_basic-background>`."

#: ../doc/book/box/box_session.rst:158
msgid ""
"``box.session.type()`` is useful for an :ref:`on_replace() <box_space-"
"on_replace>` trigger on a replica -- the value will be 'applier' if and "
"only if the trigger was activated because of a request that was done on "
"the master."
msgstr ""
"``box.session.type()`` используется для триггера при замене "
":ref:`on_replace() <box_space-on_replace>` на реплике -- значение будет "
"'applier' только в том случае, если триггер был активирован по причине "
"запроса, выполненного на мастере."

#: ../doc/book/box/box_session.rst:168
msgid ""
"Change Tarantool's :ref:`current user <authentication-users>` -- this is "
"analogous to the Unix command ``su``."
msgstr ""
"Изменение :ref:`текущего пользователя <authentication-users>` Tarantool'а"
" -- аналогично Unix-команде ``su``."

#: ../doc/book/box/box_session.rst:171
msgid ""
"Or, if function-to-execute is specified, change Tarantool's :ref:`current"
" user <authentication-users>` temporarily while executing the function --"
" this is analogous to the Unix command ``sudo``."
msgstr ""
"Или, если указана выполняемая функция (function-to-execute), временное "
"изменение :ref:`текущего пользователя <authentication-users>` Tarantool'а"
" во время выполнения функции – аналогично Unix-команде ``sudo``."

#: ../doc/book/box/box_session.rst:176
msgid "name of a target user"
msgstr "целевое имя пользователя"

#: ../doc/book/box/box_session.rst:177
msgid ""
"name of a function, or definition of a function. Additional parameters "
"may be passed to ``box.session.su``, they will be interpreted as "
"parameters of function-to-execute."
msgstr ""
"имя функции или определение функции. Дополнительные параметры могут "
"передаваться в ``box.session.su``, они будут интерпретироваться как "
"параметры выполняемой функции."

#: ../doc/book/box/box_session.rst:184
msgid ""
"tarantool> function f(a) return box.session.user() .. a end\n"
"---\n"
"...\n"
"\n"
"tarantool> box.session.su('guest', f, '-xxx')\n"
"---\n"
"- guest-xxx\n"
"...\n"
"\n"
"tarantool> box.session.su('guest',function(...) return ... end,1,2)\n"
"---\n"
"- 1\n"
"- 2\n"
"..."
msgstr ""
"tarantool> function f(a) return box.session.user() .. a end\n"
"---\n"
"...\n"
"\n"
"tarantool> box.session.su('guest', f, '-xxx')\n"
"---\n"
"- guest-xxx\n"
"...\n"
"\n"
"tarantool> box.session.su('guest',function(...) return ... end,1,2)\n"
"---\n"
"- 1\n"
"- 2\n"
"..."

#: ../doc/book/box/box_session.rst:205
msgid "the user ID of the :ref:`current user <authentication-users>`."
msgstr "ID :ref:`текущего пользователя <authentication-users>`."

#: ../doc/book/box/box_session.rst:209
msgid ""
"Every user has a unique name (seen with :ref:`box.session.user() "
"<box_session-user>`) and a unique ID (seen with ``box.session.uid()``). "
"The values are stored together in the ``_user`` space."
msgstr ""
"У каждого пользователя есть уникальное имя (узнать с помощью "
":ref:`box.session.user() <box_session-user>`) и уникальный идентификатор "
"(узнать с помощью ``box.session.uid()``). Значения хранятся вместе в "
"спейсе ``_user``."

#: ../doc/book/box/box_session.rst:217
msgid "the effective user ID of the :ref:`current user <authentication-users>`."
msgstr "рабочий ID :ref:`текущего пользователя <authentication-users>`."

#: ../doc/book/box/box_session.rst:219
msgid ""
"This is the same as :ref:`box.session.uid() <box_session-uid>`, except in"
" two cases:"
msgstr ""
"Аналогично :ref:`box.session.uid() <box_session-uid>`, за исключением "
"двух случаев:"

#: ../doc/book/box/box_session.rst:222
msgid ""
"The first case: if the call to ``box.session.euid()`` is within a "
"function invoked by :ref:`box.session.su(user-name, function-to-execute) "
"<box_session-su>` -- in that case, ``box.session.euid()`` returns the ID "
"of the changed user (the user who is specified by the ``user-name`` "
"parameter of the ``su`` function)  but ``box.session.uid()`` returns the "
"ID of the original user (the user who is calling the ``su`` function)."
msgstr ""
"Первый случай: если вызов ``box.session.euid()`` выполняется в рамках "
"функции, вызываемой по :ref:`box.session.su(user-name, function-to-"
"execute) <box_session-su>` -- в таком случае ``box.session.euid()`` "
"вернет измененный идентификатор пользователя (пользователь, который "
"указан в параметре ``user-name`` функции ``su``), но "
"``box.session.uid()`` вернет идентификатор оригинального пользователя "
"(пользователя, который вызывает функцию ``su``)."

#: ../doc/book/box/box_session.rst:230
msgid ""
"The second case: if the call to ``box.session.euid()`` is within a "
"function specified with :ref:`box.schema.func.create(function-name, "
"{setuid= true}) <box_schema-func_create>` and the binary protocol is in "
"use -- in that case, ``box.session.euid()`` returns the ID of the user "
"who created \"function-name\" but ``box.session.uid()`` returns the ID of"
" the the user who is calling \"function-name\"."
msgstr ""
"Второй случай: если вызов ``box.session.euid()`` выполняется в рамках "
"функции по :ref:`box.schema.func.create(function-name, {setuid= true}) "
"<box_schema-func_create>`, и используется бинарный протокол -- в таком "
"случае ``box.session.euid()`` вернет идентификатор пользователя, который "
"создал функцию \"function-name\", а ``box.session.uid()`` вернет "
"идентификатор пользователя, который вызывает эту функцию \"function-"
"name\"."

#: ../doc/book/box/box_session.rst:242
msgid ""
"tarantool> box.session.su('admin')\n"
"---\n"
"...\n"
"tarantool> box.session.uid(), box.session.euid()\n"
"---\n"
"- 1\n"
"- 1\n"
"...\n"
"tarantool> function f() return {box.session.uid(),box.session.euid()} end"
"\n"
"---\n"
"...\n"
"tarantool> box.session.su('guest', f)\n"
"---\n"
"- - 1\n"
"  - 0\n"
"..."
msgstr ""
"tarantool> box.session.su('admin')\n"
"---\n"
"...\n"
"tarantool> box.session.uid(), box.session.euid()\n"
"---\n"
"- 1\n"
"- 1\n"
"...\n"
"tarantool> function f() return {box.session.uid(),box.session.euid()} end"
"\n"
"---\n"
"...\n"
"tarantool> box.session.su('guest', f)\n"
"---\n"
"- - 1\n"
"  - 0\n"
"..."

#: ../doc/book/box/box_session.rst:265
msgid ""
"A Lua table that can hold arbitrary unordered session-specific names and "
"values, which will last until the session ends. For example, this table "
"could be useful to store current tasks when working with a `Tarantool "
"queue manager <https://github.com/tarantool/queue>`_."
msgstr ""
"Lua-таблица с произвольными неупорядоченными именами и значениями по "
"сессии, которая хранится до конца сессии. Например, эту таблицу можно "
"использовать для хранения текущих задач при работе с `очередями сообщений"
" в Tarantool'е <https://github.com/tarantool/queue>`_."

#: ../doc/book/box/box_session.rst:272
msgid ""
"tarantool> box.session.peer(box.session.id())\n"
"---\n"
"- 127.0.0.1:45129\n"
"...\n"
"tarantool> box.session.storage.random_memorandum = \"Don't forget the "
"eggs\"\n"
"---\n"
"...\n"
"tarantool> box.session.storage.radius_of_mars = 3396\n"
"---\n"
"...\n"
"tarantool> m = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in pairs(box.session.storage) do\n"
"         >   m = m .. k .. '='.. v .. ' '\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> m\n"
"---\n"
"- 'radius_of_mars=3396 random_memorandum=Don''t forget the eggs. '\n"
"..."
msgstr ""
"tarantool> box.session.peer(box.session.id())\n"
"---\n"
"- 127.0.0.1:45129\n"
"...\n"
"tarantool> box.session.storage.random_memorandum = \"Don't forget the "
"eggs\"\n"
"---\n"
"...\n"
"tarantool> box.session.storage.radius_of_mars = 3396\n"
"---\n"
"...\n"
"tarantool> m = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in pairs(box.session.storage) do\n"
"         >   m = m .. k .. '='.. v .. ' '\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> m\n"
"---\n"
"- 'radius_of_mars=3396 random_memorandum=Don''t forget the eggs. '\n"
"..."

#: ../doc/book/box/box_session.rst:301
msgid ""
"Define a trigger for execution when a new session is created due to an "
"event such as :ref:`console.connect <console-connect>`. The trigger "
"function will be the first thing executed after a new session is created."
" If the trigger execution fails and raises an error, the error is sent to"
" the client and the connection is closed."
msgstr ""
"Определение исполняемого триггера во время создания новой сессии при "
"подключению по консоли :ref:`console.connect <console-connect>`. Функция "
"с триггером будет первой исполняемой функцией после создания сессии. Если"
" триггер не выполняется и выдает ошибку, эта ошибка отправляется на "
"клиент, и подключение разрывается."

#: ../doc/book/box/box_session.rst:306 ../doc/book/box/box_session.rst:342
#: ../doc/book/box/box_session.rst:417
#: ../doc/book/box/box_txn_management.rst:201
msgid "function which will become the trigger function"
msgstr "функция, в которой будет триггер"

#: ../doc/book/box/box_session.rst:307 ../doc/book/box/box_session.rst:343
#: ../doc/book/box/box_session.rst:418
#: ../doc/book/box/box_txn_management.rst:203
msgid "existing trigger function which will be replaced by trigger-function"
msgstr "существующая функция с триггером, которую заменит новая"

#: ../doc/book/box/box_session.rst:308 ../doc/book/box/box_session.rst:344
#: ../doc/book/box/box_session.rst:419 ../doc/book/box/box_space.rst:1082
#: ../doc/book/box/box_space.rst:1168
#: ../doc/book/box/box_txn_management.rst:205
msgid "nil or function pointer"
msgstr "nil или указатель функции"

#: ../doc/book/box/box_session.rst:310 ../doc/book/box/box_session.rst:346
#: ../doc/book/box/box_session.rst:421 ../doc/book/box/box_space.rst:1084
msgid ""
"If the parameters are (nil, old-trigger-function), then the old trigger "
"is deleted."
msgstr ""
"Если указаны параметры (nil, old-trigger-function), старый триггер будет "
"удален."

#: ../doc/book/box/box_session.rst:312 ../doc/book/box/box_session.rst:348
#: ../doc/book/box/box_session.rst:423 ../doc/book/box/box_space.rst:1087
#: ../doc/book/box/box_space.rst:1173
msgid ""
"If both parameters are omitted, then the response is a list of existing "
"trigger functions."
msgstr ""
"Если не указан ни один параметр, ответом будет список существующих "
"функций с триггером."

#: ../doc/book/box/box_session.rst:314 ../doc/book/box/box_session.rst:350
#: ../doc/book/box/box_session.rst:425 ../doc/book/box/box_space.rst:1094
#: ../doc/book/box/box_space.rst:1179
#: ../doc/book/box/box_txn_management.rst:210
msgid ""
"Details about trigger characteristics are in the :ref:`triggers "
"<triggers-box_triggers>` section."
msgstr ""
"Подробная информация о характеристиках триггера находится в разделе "
":ref:`Триггеры <triggers-box_triggers>`."

#: ../doc/book/box/box_session.rst:318
msgid ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_connect(f)"
msgstr ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_connect(f)"

#: ../doc/book/box/box_session.rst:327
msgid ""
"If a trigger always results in an error, it may become impossible to "
"connect to a server to reset it."
msgstr ""
"Если триггер всегда приводит к ошибке, подключение к серверу для его "
"переустановки может стать невозможным."

#: ../doc/book/box/box_session.rst:334
msgid ""
"Define a trigger for execution after a client has disconnected. If the "
"trigger function causes an error, the error is logged but otherwise is "
"ignored. The trigger is invoked while the session associated with the "
"client still exists and can access session properties, such as "
":ref:`box.session.id() <box_session-id>`."
msgstr ""
"Определение исполняемого триггера после отключения клиента. Если функция "
"с триггером вызывает ошибку, то ошибка записывается в журнал, в противном"
" случае записей не будет. Триггер вызывается во время сессии клиента и "
"может получить доступ к свойствам сессии, как :ref:`box.session.id() "
"<box_session-id>`."

#: ../doc/book/box/box_session.rst:339
msgid ""
"Since version 1.10, the trigger function is invoked immediately after the"
" disconnect, even if requests that were made during the session have not "
"finished."
msgstr ""
"Начиная с версии 1.10, функция с триггером вызывается сразу же после "
"прерывания сессии, даже если сделанные запросы не были выполнены."

#: ../doc/book/box/box_session.rst:354
msgid ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_disconnect(f)"
msgstr ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_disconnect(f)"

#: ../doc/book/box/box_session.rst:363
msgid ""
"After the following series of requests, a Tarantool instance will write a"
" message using the :ref:`log <log-module>` module whenever any user "
"connects or disconnects."
msgstr ""
"После следующей серии запросов экземпляр Tarantool'а запишет сообщение с "
"помощью модуля :ref:`log <log-module>` при подключении или отключении "
"любого пользователя."

#: ../doc/book/box/box_session.rst:366
msgid ""
"function log_connect ()\n"
"  local log = require('log')\n"
"  local m = 'Connection. user=' .. box.session.user() .. ' id=' .. "
"box.session.id()\n"
"  log.info(m)\n"
"end\n"
"\n"
"function log_disconnect ()\n"
"  local log = require('log')\n"
"  local m = 'Disconnection. user=' .. box.session.user() .. ' id=' .. "
"box.session.id()\n"
"  log.info(m)\n"
"end\n"
"\n"
"box.session.on_connect(log_connect)\n"
"box.session.on_disconnect(log_disconnect)"
msgstr ""
"function log_connect ()\n"
"  local log = require('log')\n"
"  local m = 'Connection. user=' .. box.session.user() .. ' id=' .. "
"box.session.id()\n"
"  log.info(m)\n"
"end\n"
"\n"
"function log_disconnect ()\n"
"  local log = require('log')\n"
"  local m = 'Disconnection. user=' .. box.session.user() .. ' id=' .. "
"box.session.id()\n"
"  log.info(m)\n"
"end\n"
"\n"
"box.session.on_connect(log_connect)\n"
"box.session.on_disconnect(log_disconnect)"

#: ../doc/book/box/box_session.rst:383
msgid "Here is what might appear in the log file in a typical installation:"
msgstr "Вот что может быть записано в файл журнала при обычной установке:"

#: ../doc/book/box/box_session.rst:385
msgid ""
"2014-12-15 13:21:34.444 [11360] main/103/iproto I>\n"
"    Connection. user=guest id=3\n"
"2014-12-15 13:22:19.289 [11360] main/103/iproto I>\n"
"    Disconnection. user=guest id=3"
msgstr ""
"2014-12-15 13:21:34.444 [11360] main/103/iproto I>\n"
"    Connection. user=guest id=3\n"
"2014-12-15 13:22:19.289 [11360] main/103/iproto I>\n"
"    Disconnection. user=guest id=3"

#: ../doc/book/box/box_session.rst:396
msgid ""
"Define a trigger for execution during :ref:`authentication "
"<authentication-users>`."
msgstr ""
"Определение триггера, используемого во время :ref:`аутентификации "
"<authentication-users>`."

#: ../doc/book/box/box_session.rst:398
msgid "The ``on_auth`` trigger function is invoked in these circumstances:"
msgstr ""
"Вызов функции ``on_auth`` с триггером происходит в следующих "
"обстоятельствах:"

#: ../doc/book/box/box_session.rst:400
msgid ""
"The :ref:`console.connect <console-connect>` function includes an "
"authentication check for all users except 'guest'. For this case, the "
"``on_auth`` trigger function is invoked after the ``on_connect`` trigger "
"function, if and only if the connection has succeeded so far."
msgstr ""
"Функция :ref:`console.connect <console-connect>` включает в себя проверку"
" аутентификации всех пользователей, кроме 'guest'. Вызов функции "
"``on_auth`` с триггером происходит после триггера ``on_connect`` только в"
" том случае, если подключение было успешным."

#: ../doc/book/box/box_session.rst:405
msgid ""
"The :ref:`binary protocol <admin-security>` has a separate "
":ref:`authentication packet <box_protocol-authentication>`. For this "
"case, connection and authentication are considered to be separate steps."
msgstr ""
"В :ref:`бинарном протоколе <admin-security>` есть отдельный :ref:`пакет "
"для аутентификации <box_protocol-authentication>`. В этом случае "
"подключение и аутентификация считаются отдельными действиям."

#: ../doc/book/box/box_session.rst:409
msgid ""
"Unlike other trigger types, ``on_auth`` trigger functions are invoked "
"**before** the event. Therefore a trigger function like :code:`function "
"auth_function () v = box.session.user(); end` will set :code:`v` to "
"\"guest\", the user name before the authentication is done. To get the "
"user name **after** the authentication is done, use the special syntax: "
":code:`function auth_function (user_name) v = user_name; end`"
msgstr ""
"В отличие от других типов триггеров, вызов функций с триггером "
"``on_auth`` происходит **до** события. Таким образом, функция с таким "
"триггером, как :code:`function auth_function () v = box.session.user(); "
"end`, определит :code:`v` как \"guest\", то есть имя пользователя до "
"проведения аутентификации. Чтобы получить имя пользователя **после** "
"проведения аутентификации, используйте специальный синтаксис: "
":code:`function auth_function (user_name) v = user_name; end`"

#: ../doc/book/box/box_session.rst:415
msgid ""
"If the trigger fails by raising an error, the error is sent to the client"
" and the connection is closed."
msgstr ""
"Если триггер не выполняется и выдает ошибку, эта ошибка отправляется на "
"клиент, и подключение разрывается."

#: ../doc/book/box/box_session.rst:427
msgid "**Example 1**"
msgstr "**Пример 1**"

#: ../doc/book/box/box_session.rst:429
msgid ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_auth(f)"
msgstr ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_auth(f)"

#: ../doc/book/box/box_session.rst:436
msgid "**Example 2**"
msgstr "**Пример 2**"

#: ../doc/book/box/box_session.rst:438
msgid "This is a more complex example, with two server instances."
msgstr "Более сложный пример с двумя экземплярами сервера."

#: ../doc/book/box/box_session.rst:440
msgid ""
"The first server instance listens on port 3301; its default user name is "
"'admin'. There are three ``on_auth`` triggers:"
msgstr ""
"Первый экземпляр сервера настроен на прослушивание по порту 3301; имя "
"пользователя по умолчанию -- 'admin'. Есть три триггера ``on_auth``:"

#: ../doc/book/box/box_session.rst:444
msgid ""
"The first trigger has a function with no arguments, it can only look at "
"``box.session.user()``."
msgstr ""
"В первом триггере есть функция без аргументов, которая только смотрит на "
"``box.session.user()``."

#: ../doc/book/box/box_session.rst:446
msgid ""
"The second trigger has a function with a ``user_name`` argument, it can "
"look at both of: ``box.session.user()`` and ``user_name``."
msgstr ""
"Во втором триггере есть функция с аргументом ``user_name``, которая может"
" смотреть на ``box.session.user()`` и ``user_name``."

#: ../doc/book/box/box_session.rst:448
msgid ""
"The third trigger has a function with a ``user_name`` argument and a "
"``status`` argument, it can look at all three of: ``box.session.user()`` "
"and ``user_name`` and ``status``."
msgstr ""
"В третьем триггере есть функция с аргументом ``user_name`` и аргументом "
"``status``, которая может смотреть на ``box.session.user()`` и "
"``user_name``, и``status``."

#: ../doc/book/box/box_session.rst:453
msgid ""
"The second server instance will connect with :ref:`console.connect "
"<console-connect>`, and then will cause a display of the variables that "
"were set by the trigger functions."
msgstr ""
"Второй экземпляр сервера подключится по :ref:`console.connect <console-"
"connect>`, а затем отобразит переменные, определенные функциями с "
"триггером."

#: ../doc/book/box/box_session.rst:458
msgid ""
"-- On the first server instance, which listens on port 3301\n"
"box.cfg{listen=3301}\n"
"function function1()\n"
"  print('function 1, box.session.user()='..box.session.user())\n"
"  end\n"
"function function2(user_name)\n"
"  print('function 2, box.session.user()='..box.session.user())\n"
"  print('function 2, user_name='..user_name)\n"
"  end\n"
"function function3(user_name, status)\n"
"  print('function 3, box.session.user()='..box.session.user())\n"
"  print('function 3, user_name='..user_name)\n"
"  if status == true then\n"
"    print('function 3, status = true, authorization succeeded')\n"
"    end\n"
"  end\n"
"box.session.on_auth(function1)\n"
"box.session.on_auth(function2)\n"
"box.session.on_auth(function3)\n"
"box.schema.user.passwd('admin')"
msgstr ""
"-- На первом экземпляре сервера, прослушивание на котором настроено на "
"порт 3301\n"
"box.cfg{listen=3301}\n"
"function function1()\n"
"  print('function 1, box.session.user()='..box.session.user())\n"
"  end\n"
"function function2(user_name)\n"
"  print('function 2, box.session.user()='..box.session.user())\n"
"  print('function 2, user_name='..user_name)\n"
"  end\n"
"function function3(user_name, status)\n"
"  print('function 3, box.session.user()='..box.session.user())\n"
"  print('function 3, user_name='..user_name)\n"
"  if status == true then\n"
"    print('function 3, status = true, authorization succeeded')\n"
"    end\n"
"  end\n"
"box.session.on_auth(function1)\n"
"box.session.on_auth(function2)\n"
"box.session.on_auth(function3)\n"
"box.schema.user.passwd('admin')"

#: ../doc/book/box/box_session.rst:481
msgid ""
"-- On the second server instance, that connects to port 3301\n"
"console = require('console')\n"
"console.connect('admin:admin@localhost:3301')"
msgstr ""
"-- На втором экземпляре сервера, который подключается по порту 3301\n"
"console = require('console')\n"
"console.connect('admin:admin@localhost:3301')"

#: ../doc/book/box/box_session.rst:487
msgid "The result looks like this:"
msgstr "Теперь результат выглядит следующим образом:"

#: ../doc/book/box/box_session.rst:489
msgid ""
"function 3, box.session.user()=guest\n"
"function 3, user_name=admin\n"
"function 3, status = true, authorization succeeded\n"
"function 2, box.session.user()=guest\n"
"function 2, user_name=admin\n"
"function 1, box.session.user()=guest"
msgstr ""
"function 3, box.session.user()=guest\n"
"function 3, user_name=admin\n"
"function 3, status = true, authorization succeeded\n"
"function 2, box.session.user()=guest\n"
"function 2, user_name=admin\n"
"function 1, box.session.user()=guest"

#: ../doc/book/box/box_session.rst:502
msgid ""
"Generate an out-of-band message. By \"out-of-band\" we mean an extra "
"message which supplements what is passed in a network via the usual "
"channels. Although ``box.session.push()`` can be called at any time, in "
"practice it is used with networks that are set up with :ref:`module "
"net.box <net_box-module>`, and it is invoked by the server (on the "
"\"remote database system\" to use our terminology for net.box), and the "
"client has options for getting such messages."
msgstr ""
"Создание внеполосного сообщения. Под внеполосным мы понимаем "
"дополнительное сообщение, которое дополняет то, что отправляется в сети "
"по обычным каналам. Хотя ``box.session. push()`` можно вызвать в любое "
"время, на практике эта функция используется в сетях, настроенных с "
"помощью :ref:`модуля net.box <net_box-module>`, и вызывается сервером (на"
" \"удаленной системе с базой данных\", если использовать нашу "
"терминологию для net.box), а у клиента есть возможность принимать такие "
"сообщения."

#: ../doc/book/box/box_session.rst:511
msgid "This function returns an error if the session is disconnected."
msgstr "Функция возвращает ошибку, если сессия была прервана."

#: ../doc/book/box/box_session.rst:513
msgid "what to send"
msgstr "что отправляется"

#: ../doc/book/box/box_session.rst:514
msgid ""
"an optional argument to indicate what the session is, as taken from an "
"earlier call to :ref:`box_session:sync() <box_session-sync>`. If it is "
"omitted, the default is the current ``box.session.sync()`` value."
msgstr ""
"необязательный аргумент, который показывает информацию о сессии, "
"полученную из предшествующего вызова :ref:`box_session:sync() "
"<box_session-sync>`. Если не указать, по умолчанию используется текущее "
"значение ``box.session.sync()``."

#: ../doc/book/box/box_session.rst:517
msgid "{nil, error} or true:"
msgstr "{nil, ошибка} или true:"

#: ../doc/book/box/box_session.rst:519
msgid ""
"If the result is an error, then the first part of the return is ``nil`` "
"and the second part is the error object."
msgstr ""
"Если результатом будет ошибка, то вернется ``nil`` вместе с объектом "
"ошибки."

#: ../doc/book/box/box_session.rst:521
msgid ""
"If the result is not an error, then the return is the boolean value "
"``true``."
msgstr ""
"Если результатом будет не ошибка, то вернется логическое значение "
"``true`` (правда)."

#: ../doc/book/box/box_session.rst:522
msgid ""
"When the return is ``true``, the message has gone to the network buffer "
"as a :ref:`packet <box_protocol-iproto_protocol>` with the code "
"IPROTO_CHUNK (0x80)."
msgstr ""
"Если возвращается ``true``, сообщение отправлено в буфер сети в виде "
":ref:`пакета <box_protocol-iproto_protocol>` с кодом IPROTO_CHUNK (0x80)."

#: ../doc/book/box/box_session.rst:526
msgid ""
"The server's sole job is to call ``box.session.push()``, there is no "
"automatic mechanism for showing that the message was received."
msgstr ""
"Единственная задача сервера -- вызвать ``box.session.push()``, поскольку "
"нет автоматического механизма, который показал бы, что сообщение "
"получено."

#: ../doc/book/box/box_session.rst:529
msgid ""
"The client's job is to check for such messages after it sends something "
"to the server. The major client methods -- :ref:`conn:call <net_box-"
"call>`, :ref:`conn:eval <net_box-eval>`, :ref:`conn:select <conn-"
"select>`, :ref:`conn:insert <conn-insert>`, :ref:`conn:replace <conn-"
"replace>`, :ref:`conn:update <conn-update>`, :ref:`conn:upsert <conn-"
"upsert>`, :ref:`delete <conn-delete>` -- may cause the server to send a "
"message."
msgstr ""
"Задача клиента заключается в том, чтобы проверять наличие таких сообщений"
" после отправки чего-либо на сервер. Основные клиентские методы -- "
":ref:`conn:call <net_box-call>`, :ref:`conn:eval <net_box-eval>`, "
":ref:`conn:select <conn-select>`, :ref:`conn:insert <conn-insert>`, "
":ref:`conn:replace <conn-replace>`, :ref:`conn:update <conn-update>`, "
":ref:`conn:upsert <conn-upsert>`, :ref:`delete <conn-delete>` -- могут "
"привести к отправке такого сообщения сервером."

#: ../doc/book/box/box_session.rst:537
msgid ""
"Situation 1: when the client calls synchronously with the default "
"``{async=false}`` option. There are two optional additional options: "
":samp:`on_push={function-name}`, and :samp:`on_push_ctx={function-"
"argument}`. When the client receives an out-of-band message for the "
"session, it invokes \"function-name(function-argument)\". For example, "
"with options ``{on_push=table.insert, on_push_ctx=messages}``, the client"
" will insert whatever it receives into a table named 'messages'."
msgstr ""
"Ситуация 1: когда клиент делает синхронный вызов со значением параметра "
"``{async=false}`` по умолчанию. Есть два необязательных дополнительных "
"параметра: :samp:`on_push={function-name}` и :samp:`on_push_ctx"
"={function-argument}`. Когда клиент получает внеполосное сообщение в "
"сессии, он вызывает \"имя-функции(аргумент-функции)\". Например, с такими"
" значениями параметров: ``{on_push=table.insert, on_push_ctx=messages}`` "
"-- клиент произведет вставку полученных данных в таблицу под названием "
"'messages'."

#: ../doc/book/box/box_session.rst:545
msgid ""
"Situation 2: when the client calls asynchronously with the non-default "
"``{async=true}`` option. Here ``on_push`` and ``on_push_ctx`` are not "
"allowed, but the messages can be seen by calling ``pairs()`` in a loop."
msgstr ""
"Ситуация 2: когда клиент делает асинхронный вызов с измененным значением "
"параметра ``{async=true}``. Здесь не разрешены ``on_push`` и "
"``on_push_ctx``, но сообщения можно увидеть путем вызова ``pairs()`` в "
"цикле."

#: ../doc/book/box/box_session.rst:549
msgid ""
"Situation 2 complication: ``pairs()`` is subject to timeout. So there is "
"an optional argument = timeout per iteration. If timeout occurs before "
"there is a new message or a final response, there is an error return. To "
"check for an error one can use the first loop parameter (if the loop "
"starts with \"for i, message in future:pairs()\" then the first loop "
"parameter is i). If it is ``box.NULL`` then the second parameter (in our "
"example, \"message\") is the error object."
msgstr ""
"Осложненная ситуация 2: ``pairs()`` зависит от времени ожидания. Таким "
"образом, есть необязательный аргумент -- время ожидания для итерации. "
"Если время ожидания истечет до получения нового сообщения или "
"окончательного ответа, вернется ошибка. Чтобы проверить наличие ошибки, "
"можно использовать первый параметр в цикле (если цикл начинается с \"for "
"i, message in future:pairs()\", то первым параметром в цикле будет i). "
"Если это будет ``box.NULL``, то второй параметр (в нашем примере "
"\"message\") -- это объект ошибки."

#: ../doc/book/box/box_session.rst:559
msgid ""
"-- Make two shells. On Shell#1 set up a \"server\", and\n"
"-- in it have a function that includes box.session.push:\n"
"box.cfg{listen=3301}\n"
"box.schema.user.grant('guest','read,write,execute','universe')\n"
"x = 0\n"
"fiber = require('fiber')\n"
"function server_function() x=x+1; fiber.sleep(1); box.session.push(x); "
"end\n"
"\n"
"-- On Shell#2 connect to this server as a \"client\" that\n"
"-- can handle Lua (such as another Tarantool server operating\n"
"-- as a client), and initialize a table where we'll get messages:\n"
"net_box = require('net.box')\n"
"conn = net_box.connect(3301)\n"
"messages_from_server = {}\n"
"\n"
"-- On Shell#2 remotely call the server function and receive\n"
"-- a SYNCHRONOUS out-of-band message:\n"
"conn:call('server_function', {},\n"
"          {is_async = false,\n"
"           on_push = table.insert,\n"
"           on_push_ctx = messages_from_server})\n"
"messages_from_server\n"
"-- After a 1-second pause that is caused by the fiber.sleep()\n"
"-- request inside server_function, the result in the\n"
"--  messages_from_server table will be: 1. Like this:\n"
"-- tarantool> messages_from_server\n"
"-- ---\n"
"-- - - 1\n"
"-- ...\n"
"-- Good. That shows that box.session.push(x) worked,\n"
"-- because we know that x was 1.\n"
"\n"
"-- On Shell#2 remotely call the same server function and\n"
"-- get an ASYNCHRONOUS out-of-band message. For this we cannot\n"
"-- use on_push and on_push_ctx options, but we can use pairs():\n"
"future = conn:call('server_function', {}, {is_async = true})\n"
"messages = {}\n"
"keys = {}\n"
"for i, message in future:pairs() do\n"
"    table.insert(messages, message) table.insert(keys, i) end\n"
"messages\n"
"future:wait_result(1000)\n"
"for i, message in future:pairs() do\n"
"    table.insert(messages, message) table.insert(keys, i) end\n"
"messages\n"
"-- There is no pause because conn:call does not wait for\n"
"-- server_function to finish. The first time that we go through\n"
"-- the pairs() loop, we see the messages table is empty. Like this:\n"
"-- tarantool> messages\n"
"-- ---\n"
"-- - - 2\n"
"--   - []\n"
"-- ...\n"
"-- That is okay because the server hasn't yet called\n"
"-- box.session.push(). The second time that we go through\n"
"-- the pairs() loop, we see the value of x at the time of\n"
"-- the second call to box.session.push(). Like this:\n"
"-- tarantool> messages\n"
"-- ---\n"
"-- - - 2\n"
"--   - &0 []\n"
"--   - 2\n"
"--   - *0\n"
"-- ...\n"
"-- Good. That shows that the message was asynchronous, and\n"
"-- that box.session.push() did its job."
msgstr ""
"-- Создайте две оболочки. В оболочке №1 настройте сервер, а\n"
"-- в нем функцию, которая содержит box.session.push:\n"
"box.cfg{listen=3301}\n"
"box.schema.user.grant('guest','read,write,execute','universe')\n"
"x = 0\n"
"fiber = require('fiber')\n"
"function server_function() x=x+1; fiber.sleep(1); box.session.push(x); "
"end\n"
"\n"
"-- В оболочке №2 подключитесь к серверу в качестве клиента, который\n"
"-- поддерживает Lua (как второй Tarantool-сервер, работающий\n"
"-- в качестве клиента), и создайте таблицу, в которую мы будем получать "
"сообщения:\n"
"net_box = require('net.box')\n"
"conn = net_box.connect(3301)\n"
"messages_from_server = {}\n"
"\n"
"-- В оболочке №2 удаленно вызовите функцию и получите\n"
"-- СИНХРОННОЕ внеполосное сообщение:\n"
"conn:call('server_function', {},\n"
"          {is_async = false,\n"
"           on_push = table.insert,\n"
"           on_push_ctx = messages_from_server})\n"
"messages_from_server\n"
"-- Через секунду, во время которой происходит запрос fiber.sleep()\n"
"-- в server_function, результат в таблице\n"
"--  messages_from_server будет следующим: 1. Проверим:\n"
"-- tarantool> messages_from_server\n"
"-- ---\n"
"-- - - 1\n"
"-- ...\n"
"-- Хорошо. Это означает, что box.session.push(x) сработала,\n"
"-- поскольку мы знаем, что x был 1.\n"
"\n"
"-- В оболочке №2 удаленно вызовите ту же самую функцию\n"
"-- для получения АСИНХРОННОГО внеполосного сообщения. При этом мы не "
"можем\n"
"-- использовать параметры on_push и on_push_ctx, но можем использовать "
"pairs():\n"
"future = conn:call('server_function', {}, {is_async = true})\n"
"messages = {}\n"
"keys = {}\n"
"for i, message in future:pairs() do\n"
"    table.insert(messages, message) table.insert(keys, i) end\n"
"messages\n"
"future:wait_result(1000)\n"
"for i, message in future:pairs() do\n"
"    table.insert(messages, message) table.insert(keys, i) end\n"
"messages\n"
"-- Задержки нет, поскольку conn:call не ждет\n"
"-- окончания вызова функции server_function. После первой итерации\n"
"-- цикла pairs(), видим, что таблица пуста. Это выглядит так:\n"
"-- tarantool> messages\n"
"-- ---\n"
"-- - - 2\n"
"--   - []\n"
"-- ...\n"
"-- Это нормально, поскольку сервер еще не вызвал\n"
"-- box.session.push(). При второй итерации\n"
"-- цикла pairs(), видим значение x во время\n"
"-- второго вызова box.session.push(). Так:\n"
"-- tarantool> messages\n"
"-- ---\n"
"-- - - 2\n"
"--   - &0 []\n"
"--   - 2\n"
"--   - *0\n"
"-- ...\n"
"-- Хорошо. Это означает, что сообщение было асинхронным, и\n"
"-- box.session.push() выполнила свою задачу."

#: ../doc/book/box/box_slab.rst:13
msgid ""
"The ``box.slab`` submodule provides access to slab allocator statistics. "
"The slab allocator is the main allocator used to store :ref:`tuples "
"<index-box_tuple>`. This can be used to monitor the total memory usage "
"and memory fragmentation."
msgstr ""
"Вложенный модуль ``box.slab`` предоставляет доступ к статистике "
"распределения slab. Механизм распределения slab представляет собой "
"основной тип распределения для хранения :ref:`кортежей <index-"
"box_tuple>`. Такое распределение можно использовать для отслеживания "
"использования памяти и фрагментации памяти."

#: ../doc/book/box/box_slab.rst:21
msgid "Below is a list of all ``box.slab`` functions."
msgstr "Ниже приведен перечень всех функций модуля ``box.slab``."

#: ../doc/book/box/box_slab.rst:31
msgid ":ref:`box.runtime.info() <box_runtime_info>`"
msgstr ":ref:`box.runtime.info() <box_runtime_info>`"

#: ../doc/book/box/box_slab.rst:31
msgid "Show a memory usage report for Lua runtime"
msgstr "Отображение отчета по использованию памяти во время исполнения Lua-кода"

#: ../doc/book/box/box_slab.rst:34
msgid ":ref:`box.slab.info() <box_slab_info>`"
msgstr ":ref:`box.slab.info() <box_slab_info>`"

#: ../doc/book/box/box_slab.rst:34
msgid "Show an aggregated memory usage report for slab allocator"
msgstr ""
"Отображение обобщенного отчета по использованию памяти для распределения "
"slab"

#: ../doc/book/box/box_slab.rst:37
msgid ":ref:`box.slab.stats() <box_slab_stats>`"
msgstr ":ref:`box.slab.stats() <box_slab_stats>`"

#: ../doc/book/box/box_slab.rst:37
msgid "Show a detailed memory usage report for slab allocator"
msgstr ""
"Отображение подробного отчета по использованию памяти для распределения "
"slab"

#: ../doc/book/box/box_slab.rst:45
msgid "Show a memory usage report (in bytes) for the Lua runtime."
msgstr ""
"Отображение отчета по использованию памяти (в байтах) во время исполнения"
" Lua-кода."

#: ../doc/book/box/box_slab.rst:49
msgid "``lua`` is the heap size of the Lua garbage collector;"
msgstr "``lua`` -- это размер динамической памяти сборщика мусора в Lua;"

#: ../doc/book/box/box_slab.rst:50
msgid "``maxalloc`` is the maximal memory quota that can be allocated for Lua;"
msgstr ""
"``maxalloc`` -- это максимальная квота памяти, которую можно выделить для"
" Lua;"

#: ../doc/book/box/box_slab.rst:51
msgid "``used`` is the current memory size used by Lua."
msgstr "``used`` -- объем памяти, используемый Lua в данный момент."

#: ../doc/book/box/box_slab.rst:57
msgid ""
"tarantool> box.runtime.info()\n"
"---\n"
"- lua: 913710\n"
"  maxalloc: 4398046510080\n"
"  used: 12582912\n"
"...\n"
"tarantool> box.runtime.info().used\n"
"---\n"
"- used: 12582912\n"
"..."
msgstr ""
"tarantool> box.runtime.info()\n"
"---\n"
"- lua: 913710\n"
"  maxalloc: 4398046510080\n"
"  used: 12582912\n"
"...\n"
"tarantool> box.runtime.info().used\n"
"---\n"
"- used: 12582912\n"
"..."

#: ../doc/book/box/box_slab.rst:74
msgid "Show an aggregated memory usage report (in bytes) for the slab allocator."
msgstr ""
"Отображение обобщенного отчета по использованию памяти (в байтах) для "
"распределения slab."

#: ../doc/book/box/box_slab.rst:76
msgid ""
"This report is useful for assessing out-of-memory risks: the risks are "
"high if both ``arena_used_ratio`` and ``quota_used_ratio`` are high "
"(90-95%)."
msgstr ""
"Данный отчет используется для оценки риска нехватки памяти: риск высокий,"
" если высоки значения и ``arena_used_ratio``, и ``quota_used_ratio`` "
"(90-95%)."

#: ../doc/book/box/box_slab.rst:79
msgid ""
"If ``quota_used_ratio`` is low, then high ``arena_used_ratio`` and/or "
"``items_used_ratio`` indicate that the memory fragmentation is low (i.e. "
"the memory is used efficiently)."
msgstr ""
"Если значение ``quota_used_ratio`` низкое, то высокое значение "
"``arena_used_ratio`` и/или ``items_used_ratio`` указывает на низкую "
"фрагментацию памяти (т.е. память используется эффективно)."

#: ../doc/book/box/box_slab.rst:83
msgid ""
"If ``quota_used_ratio`` is high (approaching 100%), then low "
"``arena_used_ratio`` (50-60%) indicates that the memory is heavily "
"fragmentized. Most probably, there is no immediate out-of-memory risk in "
"this case, but generally this is an issue to consider. For example, "
"probable risks are that the entire memory quota is used for tuples, and "
"there is are no slabs left for a piece of an index. Or that all slabs are"
" allocated for storing tuples, but in fact all the slabs are half-empty."
msgstr ""
"Если значение ``quota_used_ratio`` высокое (достигает 100%), то низкое "
"значение ``arena_used_ratio`` (50-60%) указывает на значительную "
"фрагментацию памяти. Весьма вероятно, что в данном случае "
"непосредственного риска нехватки памяти нет, но такую проблему следует "
"тщательно рассмотреть. Например, есть риск того, что вся квота памяти "
"используется на кортежи, а для части индекса slab'ов нет. Или все slab'ы "
"выделены на хранение кортежей, а в действительности все они наполовину "
"пусты."

#: ../doc/book/box/box_slab.rst:93
msgid ""
"``items_size`` is the *total* amount of memory (including allocated, but "
"currently free slabs) used only for tuples, no indexes;"
msgstr ""
"``items_size`` -- это *общий* объем памяти (включая выделенные, но в "
"данный момент свободные slab'ы), который используется только для "
"кортежей, а не для индексов;"

#: ../doc/book/box/box_slab.rst:95
msgid ""
"``items_used_ratio`` = ``items_used`` / ``slab_count`` * ``slab_size`` "
"(these are slabs used only for tuples, no indexes);"
msgstr ""
"``items_used_ratio`` = ``items_used`` / ``slab_count`` * ``slab_size`` "
"(это slab'ы, которые используются только для кортежей, не для индексов);"

#: ../doc/book/box/box_slab.rst:97
msgid ""
"``quota_size`` is the maximum amount of memory that the slab allocator "
"can use for both tuples and indexes (as configured in the "
":ref:`memtx_memory <cfg_storage-memtx_memory>` parameter, the default is "
"2^28 bytes =  268,435,456 bytes);"
msgstr ""
"``quota_size`` -- максимальный объем памяти, который механизм "
"распределения slab может использовать как для кортежей, так и для "
"индексов (как настроено в параметре :ref:`memtx_memory <cfg_storage-"
"memtx_memory>`, по умолчанию 2^28 байтов =  268 435 456 байтов);"

#: ../doc/book/box/box_slab.rst:101
msgid "``quota_used_ratio`` = ``quota_used`` / ``quota_size``;"
msgstr "``quota_used_ratio`` = ``quota_used`` / ``quota_size``;"

#: ../doc/book/box/box_slab.rst:102
msgid "``arena_used_ratio`` = ``arena_used`` / ``arena_size``;"
msgstr "``arena_used_ratio`` = ``arena_used`` / ``arena_size``;"

#: ../doc/book/box/box_slab.rst:103
msgid ""
"``items_used`` is the *efficient* amount of memory (omitting allocated, "
"but currently free slabs) used only for tuples, no indexes;"
msgstr ""
"``items_used`` -- это *эффективный* объем памяти (не включая выделенные, "
"но в данный момент свободные slab'ы), который используется только для "
"кортежей, а не для индексов;"

#: ../doc/book/box/box_slab.rst:105
msgid ""
"``quota_used`` is the amount of memory that is already distributed to the"
" slab allocator;"
msgstr "``quota_used`` -- это объем памяти, уже выделенный для распределения slab;"

#: ../doc/book/box/box_slab.rst:107
msgid ""
"``arena_size`` is the *total* memory used for tuples and indexes together"
" (including allocated, but currently free slabs);"
msgstr ""
"``arena_size`` -- это *общий* объем памяти, используемый для кортежей и "
"индексов (включая выделенные, но в данный момент свободные slab'ы);"

#: ../doc/book/box/box_slab.rst:109
msgid ""
"``arena_used`` is the *efficient* memory used for storing tuples and "
"indexes together (omitting allocated, but currently free slabs)."
msgstr ""
"``arena_used`` -- это *эффективный* объем памяти, используемый для "
"кортежей и индексов (не включая выделенные, но в данный момент свободные "
"slab'ы)."

#: ../doc/book/box/box_slab.rst:116
msgid ""
"tarantool> box.slab.info()\n"
"---\n"
"- items_size: 228128\n"
"  items_used_ratio: 1.8%\n"
"  quota_size: 1073741824\n"
"  quota_used_ratio: 0.8%\n"
"  arena_used_ratio: 43.2%\n"
"  items_used: 4208\n"
"  quota_used: 8388608\n"
"  arena_size: 2325176\n"
"  arena_used: 1003632\n"
"...\n"
"\n"
"tarantool> box.slab.info().arena_used\n"
"---\n"
"- 1003632\n"
"..."
msgstr ""
"tarantool> box.slab.info()\n"
"---\n"
"- items_size: 228128\n"
"  items_used_ratio: 1.8%\n"
"  quota_size: 1073741824\n"
"  quota_used_ratio: 0.8%\n"
"  arena_used_ratio: 43.2%\n"
"  items_used: 4208\n"
"  quota_used: 8388608\n"
"  arena_size: 2325176\n"
"  arena_used: 1003632\n"
"...\n"
"\n"
"tarantool> box.slab.info().arena_used\n"
"---\n"
"- 1003632\n"
"..."

#: ../doc/book/box/box_slab.rst:140
msgid ""
"Show a detailed memory usage report (in bytes) for the slab allocator. "
"The report is broken down into groups by *data item size* as well as by "
"*slab size* (64-byte, 136-byte, etc). The report includes the memory "
"allocated for storing both tuples and indexes."
msgstr ""
"Отображение подробного отчета об использовании памяти (в байтах) для "
"распределения slab. Отчет разбивается на группы по *размеру элементов "
"данных*, а также по *размеру slab'а* (64 байта, 136 байтов и т.д.). Отчет"
" включает в себя информацию о памяти, выделенной на хранение и кортежей, "
"и индексов."

#: ../doc/book/box/box_slab.rst:147
msgid "``mem_free`` is the allocated, but currently unused memory;"
msgstr "``mem_free`` -- это выделенная, но не используемая в данный момент память;"

#: ../doc/book/box/box_slab.rst:148
msgid ""
"``mem_used`` is the memory used for storing data items (tuples and "
"indexes);"
msgstr ""
"``mem_used`` -- это память, используемая для хранения элементов данных "
"(кортежей и индексов);"

#: ../doc/book/box/box_slab.rst:149
msgid "``item_count`` is the number of stored items;"
msgstr "``item_count`` -- это количество хранимых элементов;"

#: ../doc/book/box/box_slab.rst:150
msgid "``item_size`` is the size of each data item;"
msgstr "``item_size`` -- это размер каждого элемента данных;"

#: ../doc/book/box/box_slab.rst:151
msgid "``slab_count`` is the number of slabs allocated;"
msgstr "``slab_count`` -- это количество выделенных slab'ов;"

#: ../doc/book/box/box_slab.rst:152
msgid "``slab_size`` is the size of each allocated slab."
msgstr "``slab_size`` -- это размер каждого выделенного slab'а."

#: ../doc/book/box/box_slab.rst:158
msgid "Here is a sample report for the first group:"
msgstr "Ниже представлен пример отчета для первой группы:"

#: ../doc/book/box/box_slab.rst:160
msgid ""
"tarantool> box.slab.stats()[1]\n"
"---\n"
"- mem_free: 16232\n"
"  mem_used: 48\n"
"  item_count: 2\n"
"  item_size: 24\n"
"  slab_count: 1\n"
"  slab_size: 16384\n"
"..."
msgstr ""
"tarantool> box.slab.stats()[1]\n"
"---\n"
"- mem_free: 16232\n"
"  mem_used: 48\n"
"  item_count: 2\n"
"  item_size: 24\n"
"  slab_count: 1\n"
"  slab_size: 16384\n"
"..."

#: ../doc/book/box/box_slab.rst:172
msgid ""
"This report is saying that there are 2 data items (``item_count`` = 2) "
"stored in one (``slab_count`` = 1) 24-byte slab (``item_size`` = 24), so "
"``mem_used`` = 2 * 24 = 48 bytes. Also, ``slab_size`` is 16384 bytes, of "
"which 16384 - 48 = 16232 bytes are free (``mem_free``)."
msgstr ""
"В отчете показано, что есть два элемента данных (``item_count`` = 2), "
"которые хранятся в одном (``slab_count`` = 1) 24-байтовом slab'е "
"(``item_size`` = 24), поэтому объем используемой памяти ``mem_used`` = 2 "
"* 24 = 48 байтов. Кроме того, размер slab'а ``slab_size`` составляет "
"16384 байта, из которых 16384 - 48 = 16232 байта свободны (``mem_free``)."

#: ../doc/book/box/box_slab.rst:177
msgid "A complete report would show memory usage statistics for all groups:"
msgstr "В полном отчете будет статистика по использованию памяти во всех группах:"

#: ../doc/book/box/box_slab.rst:179
msgid ""
"tarantool> box.slab.stats()\n"
"---\n"
"- - mem_free: 16232\n"
"    mem_used: 48\n"
"    item_count: 2\n"
"    item_size: 24\n"
"    slab_count: 1\n"
"    slab_size: 16384\n"
"  - mem_free: 15720\n"
"    mem_used: 560\n"
"    item_count: 14\n"
"    item_size: 40\n"
"    slab_count: 1\n"
"    slab_size: 16384\n"
"  <...>\n"
"  - mem_free: 32472\n"
"    mem_used: 192\n"
"    item_count: 1\n"
"    item_size: 192\n"
"    slab_count: 1\n"
"    slab_size: 32768\n"
"  - mem_free: 1097624\n"
"    mem_used: 999424\n"
"    item_count: 61\n"
"    item_size: 16384\n"
"    slab_count: 1\n"
"    slab_size: 2097152\n"
"  ..."
msgstr ""
"tarantool> box.slab.stats()\n"
"---\n"
"- - mem_free: 16232\n"
"    mem_used: 48\n"
"    item_count: 2\n"
"    item_size: 24\n"
"    slab_count: 1\n"
"    slab_size: 16384\n"
"  - mem_free: 15720\n"
"    mem_used: 560\n"
"    item_count: 14\n"
"    item_size: 40\n"
"    slab_count: 1\n"
"    slab_size: 16384\n"
"  <...>\n"
"  - mem_free: 32472\n"
"    mem_used: 192\n"
"    item_count: 1\n"
"    item_size: 192\n"
"    slab_count: 1\n"
"    slab_size: 32768\n"
"  - mem_free: 1097624\n"
"    mem_used: 999424\n"
"    item_count: 61\n"
"    item_size: 16384\n"
"    slab_count: 1\n"
"    slab_size: 2097152\n"
"  ..."

#: ../doc/book/box/box_slab.rst:210
msgid ""
"The total ``mem_used`` for all groups in this report equals "
"``arena_used`` in :ref:`box.slab.info() <box_slab_info>` report."
msgstr ""
"Общий объем используемой памяти ``mem_used`` для всех групп в данном "
"отчете равен ``arena_used`` в отчете :ref:`box.slab.info() "
"<box_slab_info>`."

#: ../doc/book/box/box_space.rst:5
msgid "Submodule `box.space`"
msgstr "Вложенный модуль `box.space`"

#: ../doc/book/box/box_space.rst:11
#, fuzzy
msgid ""
"The ``box.space`` submodule has the data-manipulation functions "
"``select``, ``insert``, ``replace``, ``update``, ``upsert``, ``delete``, "
"``get``, ``put``. It also has members, such as id, and whether or not a "
"space is enabled. Submodule source code is available in file "
"`src/box/lua/schema.lua "
"<https://github.com/tarantool/tarantool/blob/2.1/src/box/lua/schema.lua>`_."
msgstr ""
"Вложенный модуль ``box.space`` включает в себя функции по управлению "
"данными ``select`` (выборка), ``insert`` (вставка), ``replace`` (замена),"
" ``update`` (обновление), ``upsert`` (обновление и вставка), ``delete`` "
"(удаление), ``get`` (получение), ``put`` (выдача). Также в модуле есть "
"такие элементы, как id, и указание на активность спейса. Код вложенного "
"модуля находится в файле `src/box/lua/schema.lua "
"<https://github.com/tarantool/tarantool/blob/1.7/src/box/lua/schema.lua>`_."

#: ../doc/book/box/box_space.rst:21
msgid "Below is a list of all ``box.space`` functions and members."
msgstr "Ниже приведен перечень всех функций и элементов модуля ``box.space``."

#: ../doc/book/box/box_space.rst:31
msgid ":ref:`space_object:auto_increment() <box_space-auto_increment>`"
msgstr ":ref:`space_object:auto_increment() <box_space-auto_increment>`"

#: ../doc/book/box/box_space.rst:31
msgid "Generate key + Insert a tuple"
msgstr "Генерация ключа + вставка кортежа"

#: ../doc/book/box/box_space.rst:34
msgid ":ref:`space_object:bsize() <box_space-bsize>`"
msgstr ":ref:`space_object:bsize() <box_space-bsize>`"

#: ../doc/book/box/box_space.rst:34
msgid "Get count of bytes"
msgstr "Подсчет байтов"

#: ../doc/book/box/box_space.rst:37
msgid ":ref:`space_object:count() <box_space-count>`"
msgstr ":ref:`space_object:count() <box_space-count>`"

#: ../doc/book/box/box_space.rst:37 ../doc/book/box/box_space.rst:61
msgid "Get count of tuples"
msgstr "Подсчет кортежей"

#: ../doc/book/box/box_space.rst:40
msgid ":ref:`space_object:create_index() <box_space-create_index>`"
msgstr ":ref:`space_object:create_index() <box_space-create_index>`"

#: ../doc/book/box/box_space.rst:43
msgid ":ref:`space_object:delete() <box_space-delete>`"
msgstr ":ref:`space_object:delete() <box_space-delete>`"

#: ../doc/book/box/box_space.rst:43
msgid "Delete a tuple"
msgstr "Удаление кортежа"

#: ../doc/book/box/box_space.rst:46
msgid ":ref:`space_object:drop() <box_space-drop>`"
msgstr ":ref:`space_object:drop() <box_space-drop>`"

#: ../doc/book/box/box_space.rst:46
msgid "Destroy a space"
msgstr "Удаление спейса"

#: ../doc/book/box/box_space.rst:49
msgid ":ref:`space_object:format() <box_space-format>`"
msgstr ":ref:`space_object:format() <box_space-format>`"

#: ../doc/book/box/box_space.rst:49
msgid "Declare field names and types"
msgstr "Объявление имен и типов полей"

#: ../doc/book/box/box_space.rst:52
msgid ":ref:`space_object:frommap() <box_space-frommap>`"
msgstr ":ref:`space_object:frommap() <box_space-frommap>`"

#: ../doc/book/box/box_space.rst:52
msgid "Convert from map to tuple or table"
msgstr "Конвертация ассоциативного массива в кортеж или таблицу"

#: ../doc/book/box/box_space.rst:55
msgid ":ref:`space_object:get() <box_space-get>`"
msgstr ":ref:`space_object:get() <box_space-get>`"

#: ../doc/book/box/box_space.rst:55
msgid "Select a tuple"
msgstr "Выбор кортежа"

#: ../doc/book/box/box_space.rst:58
msgid ":ref:`space_object:insert() <box_space-insert>`"
msgstr ":ref:`space_object:insert() <box_space-insert>`"

#: ../doc/book/box/box_space.rst:58
msgid "Insert a tuple"
msgstr "Вставка кортежа"

#: ../doc/book/box/box_space.rst:61
msgid ":ref:`space_object:len() <box_space-len>`"
msgstr ":ref:`space_object:len() <box_space-len>`"

#: ../doc/book/box/box_space.rst:64
msgid ":ref:`space_object:on_replace() <box_space-on_replace>`"
msgstr ":ref:`space_object:on_replace() <box_space-on_replace>`"

#: ../doc/book/box/box_space.rst:64
msgid "Create a replace trigger with a function that cannot change the tuple"
msgstr "Создание триггера замены с функцией, которая не может изменять кортеж"

#: ../doc/book/box/box_space.rst:68
msgid ":ref:`space_object:before_replace() <box_space-before_replace>`"
msgstr ":ref:`space_object:before_replace() <box_space-before_replace>`"

#: ../doc/book/box/box_space.rst:68
msgid "Create a replace trigger with a function that can change the tuple"
msgstr "Создание триггера замены с функцией, которая может изменять кортеж"

#: ../doc/book/box/box_space.rst:72
msgid ":ref:`space_object:pairs() <box_space-pairs>`"
msgstr ":ref:`space_object:pairs() <box_space-pairs>`"

#: ../doc/book/box/box_space.rst:75
msgid ":ref:`space_object:put() <box_space-replace>`"
msgstr ":ref:`space_object:put() <box_space-replace>`"

#: ../doc/book/box/box_space.rst:75 ../doc/book/box/box_space.rst:81
msgid "Insert or replace a tuple"
msgstr "Вставка или замена кортежа"

#: ../doc/book/box/box_space.rst:78
msgid ":ref:`space_object:rename() <box_space-rename>`"
msgstr ":ref:`space_object:rename() <box_space-rename>`"

#: ../doc/book/box/box_space.rst:78
msgid "Rename a space"
msgstr "Переименование спейса"

#: ../doc/book/box/box_space.rst:81
msgid ":ref:`space_object:replace() <box_space-replace>`"
msgstr ":ref:`space_object:replace() <box_space-replace>`"

#: ../doc/book/box/box_space.rst:84
msgid ":ref:`space_object:run_triggers() <box_space-run_triggers>`"
msgstr ":ref:`space_object:run_triggers() <box_space-run_triggers>`"

#: ../doc/book/box/box_space.rst:84
msgid "Enable/disable a replace trigger"
msgstr "Включение/отключение триггера замены"

#: ../doc/book/box/box_space.rst:87
msgid ":ref:`space_object:select() <box_space-select>`"
msgstr ":ref:`space_object:select() <box_space-select>`"

#: ../doc/book/box/box_space.rst:87
msgid "Select one or more tuples"
msgstr "Выбор одного или более кортежей"

#: ../doc/book/box/box_space.rst:90
msgid ":ref:`space_object:truncate() <box_space-truncate>`"
msgstr ":ref:`space_object:truncate() <box_space-truncate>`"

#: ../doc/book/box/box_space.rst:90
msgid "Delete all tuples"
msgstr "Удаление всех кортежей"

#: ../doc/book/box/box_space.rst:93
msgid ":ref:`space_object:update() <box_space-update>`"
msgstr ":ref:`space_object:update() <box_space-update>`"

#: ../doc/book/box/box_space.rst:96
msgid ":ref:`space_object:upsert() <box_space-upsert>`"
msgstr ":ref:`space_object:upsert() <box_space-upsert>`"

#: ../doc/book/box/box_space.rst:99
msgid ":ref:`space_object:user_defined() <box_space-user_defined>`"
msgstr ":ref:`space_object:user_defined() <box_space-user_defined>`"

#: ../doc/book/box/box_space.rst:102
#, fuzzy
msgid ""
":ref:`space_object:create_check_constraint() <box_space-"
"create_check_constraint>`"
msgstr ":ref:`space_object:create_index() <box_space-create_index>`"

#: ../doc/book/box/box_space.rst:102
msgid "Create a check constraint"
msgstr ""

#: ../doc/book/box/box_space.rst:105
msgid ":ref:`space_object.enabled <box_space-enabled>`"
msgstr ":ref:`space_object.enabled <box_space-enabled>`"

#: ../doc/book/box/box_space.rst:105
msgid "Flag, true if space is enabled"
msgstr "Флаг, если спейс активен -- true"

#: ../doc/book/box/box_space.rst:108
msgid ":ref:`space_object.field_count <box_space-field_count>`"
msgstr ":ref:`space_object.field_count <box_space-field_count>`"

#: ../doc/book/box/box_space.rst:108
msgid "Required number of fields"
msgstr "Необходимое количество полей"

#: ../doc/book/box/box_space.rst:111
msgid ":ref:`space_object.id <box_space-id>`"
msgstr ":ref:`space_object.id <box_space-id>`"

#: ../doc/book/box/box_space.rst:111
msgid "Numeric identifier of space"
msgstr "Числовой идентификатор спейса"

#: ../doc/book/box/box_space.rst:114
msgid ":ref:`space_object.index <box_space-space_index>`"
msgstr ":ref:`space_object.index <box_space-space_index>`"

#: ../doc/book/box/box_space.rst:114
msgid "Container of space's indexes"
msgstr "Контейнер для индексов спейса"

#: ../doc/book/box/box_space.rst:117
msgid ":ref:`box.space._cluster <box_space-cluster>`"
msgstr ":ref:`box.space._cluster <box_space-cluster>`"

#: ../doc/book/box/box_space.rst:117
msgid "(Metadata) List of replica sets"
msgstr "(Метаданные) Список наборов реплик"

#: ../doc/book/box/box_space.rst:120
msgid ":ref:`box.space._func <box_space-func>`"
msgstr ":ref:`box.space._func <box_space-func>`"

#: ../doc/book/box/box_space.rst:120
msgid "(Metadata) List of function tuples"
msgstr "(Метаданные) Список кортежей с функциями"

#: ../doc/book/box/box_space.rst:123
msgid ":ref:`box.space._index <box_space-index>`"
msgstr ":ref:`box.space._index <box_space-index>`"

#: ../doc/book/box/box_space.rst:123
msgid "(Metadata) List of indexes"
msgstr "(Метаданные) Список индексов"

#: ../doc/book/box/box_space.rst:126
msgid ":ref:`box.space._vindex <box_space-vindex>`"
msgstr ":ref:`box.space._vindex <box_space-vindex>`"

#: ../doc/book/box/box_space.rst:126
msgid "(Metadata) List of indexes accessible for the current user"
msgstr "(Метаданные) Список индексов, доступных текущему пользователю"

#: ../doc/book/box/box_space.rst:129
msgid ":ref:`box.space._priv <box_space-priv>`"
msgstr ":ref:`box.space._priv <box_space-priv>`"

#: ../doc/book/box/box_space.rst:129
msgid "(Metadata) List of privileges"
msgstr "(Метаданные) Список прав"

#: ../doc/book/box/box_space.rst:132
msgid ":ref:`box.space._vpriv <box_space-vpriv>`"
msgstr ":ref:`box.space._vpriv <box_space-vpriv>`"

#: ../doc/book/box/box_space.rst:132
msgid "(Metadata) List of privileges accessible for the current user"
msgstr "(Метаданные) Список прав, доступных текущему пользователю"

#: ../doc/book/box/box_space.rst:135
msgid ":ref:`box.space._schema <box_space-schema>`"
msgstr ":ref:`box.space._schema <box_space-schema>`"

#: ../doc/book/box/box_space.rst:135
msgid "(Metadata) List of schemas"
msgstr "(Метаданные) Список схем"

#: ../doc/book/box/box_space.rst:138
msgid ":ref:`box.space._sequence <box_space-sequence>`"
msgstr ":ref:`box.space._sequence <box_space-sequence>`"

#: ../doc/book/box/box_space.rst:138 ../doc/book/box/box_space.rst:141
msgid "(Metadata) List of sequences"
msgstr "(Метаданные) Список последовательностей"

#: ../doc/book/box/box_space.rst:141
msgid ":ref:`box.space._sequence_data <box_space-sequence_data>`"
msgstr ":ref:`box.space._sequence_data <box_space-sequence_data>`"

#: ../doc/book/box/box_space.rst:144
msgid ":ref:`box.space._space <box_space-space>`"
msgstr ":ref:`box.space._space <box_space-space>`"

#: ../doc/book/box/box_space.rst:144
msgid "(Metadata) List of spaces"
msgstr "(Метаданные) Список спейсов"

#: ../doc/book/box/box_space.rst:147
msgid ":ref:`box.space._vspace <box_space-vspace>`"
msgstr ":ref:`box.space._vspace <box_space-vspace>`"

#: ../doc/book/box/box_space.rst:147
msgid "(Metadata) List of spaces accessible for the current user"
msgstr "(Метаданные) Список спейсов, доступных текущему пользователю"

#: ../doc/book/box/box_space.rst:150
msgid ":ref:`box.space._user <box_space-user>`"
msgstr ":ref:`box.space._user <box_space-user>`"

#: ../doc/book/box/box_space.rst:150
msgid "(Metadata) List of users"
msgstr "(Метаданные) Список пользователей"

#: ../doc/book/box/box_space.rst:153
#, fuzzy
msgid ":ref:`box.space._ck_constraint <box_space-ck_constraint>`"
msgstr ":ref:`box.space._cluster <box_space-cluster>`"

#: ../doc/book/box/box_space.rst:153
#, fuzzy
msgid "(Metadata) List of check constraints"
msgstr "(Метаданные) Список схем"

#: ../doc/book/box/box_space.rst:156
msgid ":ref:`box.space._vuser <box_space-vuser>`"
msgstr ":ref:`box.space._vuser <box_space-vuser>`"

#: ../doc/book/box/box_space.rst:156
msgid "(Metadata) List of users accessible for the current user"
msgstr "(Метаданные) Список пользователей, доступных текущему пользователю"

#: ../doc/book/box/box_space.rst:159
#, fuzzy
msgid ":ref:`box.space._collation <box_space-collation>`"
msgstr ":ref:`box.space._cluster <box_space-cluster>`"

#: ../doc/book/box/box_space.rst:159
#, fuzzy
msgid "(Metadata) List of collations"
msgstr "(Метаданные) Список кортежей с функциями"

#: ../doc/book/box/box_space.rst:162
#, fuzzy
msgid ":ref:`box.space._vcollation <box_space-vcollation>`"
msgstr ":ref:`box.space._vindex <box_space-vindex>`"

#: ../doc/book/box/box_space.rst:162
#, fuzzy
msgid "(Metadata) List of collations accessible for the current user"
msgstr "(Метаданные) Список индексов, доступных текущему пользователю"

#: ../doc/book/box/box_space.rst:175
msgid ""
"Insert a new tuple using an auto-increment primary key. The space "
"specified by space_object must have an :ref:`'unsigned' or 'integer' or "
"'number' <index-box_indexed-field-types>` primary key index of type "
"``TREE``. The primary-key field will be incremented before the insert."
msgstr ""
"Вставка нового кортежа, используя первичный ключ с автоматическим "
"увеличением. В спейсе, указанном через space_object должен быть первичный"
" TREE-индекс типа :ref:`'unsigned' или 'integer', или 'number' <index-"
"box_indexed-field-types>`. Поле первичного ключа будет увеличиваться "
"перед вставкой."

#: ../doc/book/box/box_space.rst:181
msgid ""
"Since version 1.7.5 this method is deprecated – it is better to use a "
":ref:`sequence <index-box_sequence>`."
msgstr ""
"Данный метод объявлен устаревшим с версии 1.7.5 -- лучше использовать "
":ref:`последовательности <index-box_sequence>`."

#: ../doc/book/box/box_space.rst:184 ../doc/book/box/box_space.rst:217
#: ../doc/book/box/box_space.rst:244 ../doc/book/box/box_space.rst:271
#: ../doc/book/box/box_space.rst:706 ../doc/book/box/box_space.rst:746
#: ../doc/book/box/box_space.rst:768 ../doc/book/box/box_space.rst:920
#: ../doc/book/box/box_space.rst:963 ../doc/book/box/box_space.rst:1016
#: ../doc/book/box/box_space.rst:1048 ../doc/book/box/box_space.rst:1250
#: ../doc/book/box/box_space.rst:1312 ../doc/book/box/box_space.rst:1342
#: ../doc/book/box/box_space.rst:1398 ../doc/book/box/box_space.rst:1500
#: ../doc/book/box/box_space.rst:1561 ../doc/book/box/box_space.rst:1682
#: ../doc/book/box/box_space.rst:1765
msgid "an :ref:`object reference <app_server-object_reference>`"
msgstr ":ref:`ссылка на объект <app_server-object_reference>`"

#: ../doc/book/box/box_space.rst:186
msgid "tuple's fields, other than the primary-key field"
msgstr "поля кортежа, не включая поле первичного ключа"

#: ../doc/book/box/box_space.rst:189 ../doc/book/box/box_space.rst:1346
msgid "the inserted tuple."
msgstr "вставленный кортеж."

#: ../doc/book/box/box_space.rst:192
msgid ""
"**Complexity factors:** Index size, Index type, Number of indexes "
"accessed, :ref:`WAL settings <cfg_binary_logging_snapshots-"
"rows_per_wal>`."
msgstr ""
"**Факторы сложности** Размер индекса, тип индекса, количество кортежей, к"
" которым получен доступ, :ref:`настройки журнала упреждающей записи (WAL)"
" <cfg_binary_logging_snapshots-rows_per_wal>`."

#: ../doc/book/box/box_space.rst:197
msgid "index has wrong type;"
msgstr "неподходящий тип индекса;"

#: ../doc/book/box/box_space.rst:198
msgid "primary-key indexed field is not a number."
msgstr "проиндексированное поле первичного ключа не является числовым."

#: ../doc/book/box/box_space.rst:202
msgid ""
"tarantool> box.space.tester:auto_increment{'Fld#1', 'Fld#2'}\n"
"---\n"
"- [1, 'Fld#1', 'Fld#2']\n"
"...\n"
"tarantool> box.space.tester:auto_increment{'Fld#3'}\n"
"---\n"
"- [2, 'Fld#3']\n"
"..."
msgstr ""
"tarantool> box.space.tester:auto_increment{'Fld#1', 'Fld#2'}\n"
"---\n"
"- [1, 'Fld#1', 'Fld#2']\n"
"...\n"
"tarantool> box.space.tester:auto_increment{'Fld#3'}\n"
"---\n"
"- [2, 'Fld#3']\n"
"..."

#: ../doc/book/box/box_space.rst:220
msgid ""
"Number of bytes in the space. This number, which is stored in Tarantool's"
" internal memory, represents the total number of bytes in all tuples, not"
" including index keys. For a measure of index size, see "
":ref:`index_object:bsize() <box_index-bsize>`."
msgstr ""
"Количество байтов в спейсе. Это число, которое хранится во внутренней "
"памяти Tarantool'а, представляет собой общее количество байтов во всех "
"кортежах, включая ключи индекса. Для получения информации об измерении "
"размера индекса, см. :ref:`index_object:bsize() <box_index-bsize>`."

#: ../doc/book/box/box_space.rst:228
msgid ""
"tarantool> box.space.tester:bsize()\n"
"---\n"
"- 22\n"
"..."
msgstr ""
"tarantool> box.space.tester:bsize()\n"
"---\n"
"- 22\n"
"..."

#: ../doc/book/box/box_space.rst:239
msgid ""
"Return the number of tuples. If compared with :ref:`len() <box_space-"
"len>`, this method works slower because ``count()`` scans the entire "
"space to count the tuples."
msgstr ""
"Возврат количества кортежей. Если сравнивать с :ref:`len() <box_space-"
"len>`, то данный метод работает медленнее, поскольку метод ``count()`` "
"сканирует весь спейс для подсчета кортежей."

#: ../doc/book/box/box_space.rst:246 ../doc/book/box/box_space.rst:708
#: ../doc/book/box/box_space.rst:1563
msgid ""
"primary-key field values, must be passed as a Lua table if key is multi-"
"part"
msgstr ""
"значения поля первичного ключа, которые должны возвращаться в виде "
"Lua-таблицы, если ключ составной"

#: ../doc/book/box/box_space.rst:250
msgid "Number of tuples."
msgstr "Количество кортежей."

#: ../doc/book/box/box_space.rst:254
msgid ""
"tarantool> box.space.tester:count(2, {iterator='GE'})\n"
"---\n"
"- 1\n"
"..."
msgstr ""
"tarantool> box.space.tester:count(2, {iterator='GE'})\n"
"---\n"
"- 1\n"
"..."

#: ../doc/book/box/box_space.rst:265
msgid ""
"Create an :ref:`index <index-box_index>`. It is mandatory to create an "
"index for a space before trying to insert tuples into it, or select "
"tuples from it. The first created index, which will be used as the "
"primary-key index, must be unique."
msgstr ""
"Создание :ref:`индекса <index-box_index>`. Индекс обязательно должен "
"создаваться для спейса до вставки в него кортежей или выборки. Первый "
"созданный индекс, который будет использоваться в качестве первичного "
"индекса, должен быть уникальным."

#: ../doc/book/box/box_space.rst:273
msgid ""
"name of index, which should conform to the :ref:`rules for object names "
"<app_server-names>`"
msgstr ""
"имя индекса, которое должно соответствовать :ref:`правилам именования "
"объектов <app_server-names>`"

#: ../doc/book/box/box_space.rst:275
msgid "see \"Options for space_object:create_index()\", below"
msgstr "см. \"Параметры для space_object:create_index()\" ниже"

#: ../doc/book/box/box_space.rst:278
msgid "index object"
msgstr "объект индекса"

#: ../doc/book/box/box_space.rst:279
msgid "index_object"
msgstr "объект индекса"

#: ../doc/book/box/box_space.rst:283
msgid "**Options for space_object:create_index()**"
msgstr "**Параметры для space_object:create_index()**"

#: ../doc/book/box/box_space.rst:297
msgid "type"
msgstr "type"

#: ../doc/book/box/box_space.rst:297
msgid "type of index"
msgstr "тип индекса"

#: ../doc/book/box/box_space.rst:297
msgid ""
"string ('HASH' or 'TREE' or 'BITSET' or 'RTREE') Note re storage engine: "
"vinyl only supports 'TREE'"
msgstr ""
"строка ('HASH' или 'TREE', или 'BITSET', или 'RTREE') Примечание про "
"движок базы данных: vinyl поддерживает только 'TREE'"

#: ../doc/book/box/box_space.rst:297
msgid "'TREE'"
msgstr "'TREE'"

#: ../doc/book/box/box_space.rst:303
msgid "unique identifier"
msgstr "уникальный идентификатор"

#: ../doc/book/box/box_space.rst:303
msgid "last index's id, +1"
msgstr "идентификатор последнего индекса +1"

#: ../doc/book/box/box_space.rst:305
msgid "unique"
msgstr "unique"

#: ../doc/book/box/box_space.rst:305
msgid "index is unique"
msgstr "индекс уникален"

#: ../doc/book/box/box_space.rst:305
msgid "``true``"
msgstr "``true`` (правда)"

#: ../doc/book/box/box_space.rst:307
msgid "no error if duplicate name"
msgstr "ошибки нет, если имя дублируется"

#: ../doc/book/box/box_space.rst:307
msgid "``false``"
msgstr "``false`` (ложь)"

#: ../doc/book/box/box_space.rst:309
msgid "parts"
msgstr "parts"

#: ../doc/book/box/box_space.rst:309
msgid "field-numbers  + types"
msgstr "номера поля + типы"

#: ../doc/book/box/box_space.rst:309
#, fuzzy
msgid ""
"{field_no, ``'unsigned'`` or ``'string'`` or ``'integer'`` or "
"``'number'`` or ``'boolean'`` or ``'varbinary'`` or ``'array'`` or "
"``'scalar'``, and optional collation or is_nullable value or path}"
msgstr ""
"{field_no, 'unsigned' или 'string', или 'integer', или 'number', или "
"'boolean', или 'array', или 'scalar', возможна сортировка, возможно "
"значение is_nullable}"

#: ../doc/book/box/box_space.rst:309
#, fuzzy
msgid "``{field = 1, type = 'unsigned'}``"
msgstr "``{1, 'unsigned'}``"

#: ../doc/book/box/box_space.rst:317
msgid "dimension"
msgstr "dimension"

#: ../doc/book/box/box_space.rst:317
msgid "affects :ref:`RTREE <box_index-rtree>` only"
msgstr "только для :ref:`RTREE <box_index-rtree>`"

#: ../doc/book/box/box_space.rst:317 ../doc/book/box/box_space.rst:2304
#: ../doc/book/cartridge/cartridge_admin.rst:658
#: ../doc/book/cartridge/cartridge_admin.rst:826
msgid "2"
msgstr "2"

#: ../doc/book/box/box_space.rst:319
msgid "distance"
msgstr "distance"

#: ../doc/book/box/box_space.rst:319
msgid "affects RTREE only"
msgstr "только для RTREE"

#: ../doc/book/box/box_space.rst:319
msgid "string ('euclid' or 'manhattan')"
msgstr "строка ('euclid' или 'manhattan')"

#: ../doc/book/box/box_space.rst:319
msgid "'euclid'"
msgstr "'euclid' (Евклидова)"

#: ../doc/book/box/box_space.rst:322
msgid "bloom_fpr"
msgstr "bloom_fpr"

#: ../doc/book/box/box_space.rst:322 ../doc/book/box/box_space.rst:324
#: ../doc/book/box/box_space.rst:326 ../doc/book/box/box_space.rst:328
#: ../doc/book/box/box_space.rst:330
msgid "affects vinyl only"
msgstr "только для vinyl"

#: ../doc/book/box/box_space.rst:322
msgid "``vinyl_bloom_fpr``"
msgstr "``vinyl_bloom_fpr``"

#: ../doc/book/box/box_space.rst:324
msgid "page_size"
msgstr "page_size"

#: ../doc/book/box/box_space.rst:324
msgid "``vinyl_page_size``"
msgstr "``vinyl_page_size``"

#: ../doc/book/box/box_space.rst:326
msgid "range_size"
msgstr "range_size"

#: ../doc/book/box/box_space.rst:326
msgid "``vinyl_range_size``"
msgstr "``vinyl_range_size``"

#: ../doc/book/box/box_space.rst:328
msgid "run_count_per_level"
msgstr "run_count_per_level"

#: ../doc/book/box/box_space.rst:328
msgid "``vinyl_run_count_per_level``"
msgstr "``vinyl_run_count_per_level``"

#: ../doc/book/box/box_space.rst:330
msgid "run_size_ratio"
msgstr "run_size_ratio"

#: ../doc/book/box/box_space.rst:330
msgid "``vinyl_run_size_ratio``"
msgstr "``vinyl_run_size_ratio``"

#: ../doc/book/box/box_space.rst:332
msgid "sequence"
msgstr "sequence"

#: ../doc/book/box/box_space.rst:332
msgid ""
"see section regarding :ref:`specifying a sequence in create_index() "
"<box_schema-sequence_create_index>`"
msgstr ""
"см. раздел об :ref:`указании последовательности для create_index() "
"<box_schema-sequence_create_index>`"

#: ../doc/book/box/box_space.rst:332
msgid "string or number"
msgstr "строка или число"

#: ../doc/book/box/box_space.rst:332 ../doc/book/box/box_space.rst:336
msgid "not present"
msgstr "отсутствует"

#: ../doc/book/box/box_space.rst:336
msgid "func"
msgstr ""

#: ../doc/book/box/box_space.rst:336
#, fuzzy
msgid ":ref:`functional index <box_space-index_func>`"
msgstr ":ref:`box.space._index <box_space-index>`"

#: ../doc/book/box/box_space.rst:339
msgid ""
"The options in the above chart are also applicable for "
":ref:`index_object:alter() <box_index-alter>`."
msgstr ""
"Параметры в вышеуказанной таблице также применимы к "
":ref:`index_object:alter() <box_index-alter>`."

#: ../doc/book/box/box_space.rst:342
msgid ""
"**Note re storage engine:** vinyl has extra options which by default are "
"based on configuration parameters :ref:`vinyl_bloom_fpr <cfg_storage-"
"vinyl_bloom_fpr>`, :ref:`vinyl_page_size <cfg_storage-vinyl_page_size>`, "
":ref:`vinyl_range_size <cfg_storage-vinyl_range_size>`, "
":ref:`vinyl_run_count_per_level <cfg_storage-vinyl_run_count_per_level>`,"
" and :ref:`vinyl_run_size_ratio <cfg_storage-vinyl_run_size_ratio>` -- "
"see the description of those parameters. The current values can be seen "
"by selecting from :ref:`box.space._index <box_space-index>`."
msgstr ""
"**Примечание про движок базы данных:** в vinyl'е есть дополнительные "
"параметры, которые по умолчанию основаны на конфигурационных параметрах "
":ref:`vinyl_bloom_fpr <cfg_storage-vinyl_bloom_fpr>`, "
":ref:`vinyl_page_size <cfg_storage-vinyl_page_size>`, "
":ref:`vinyl_range_size <cfg_storage-vinyl_range_size>`, "
":ref:`vinyl_run_count_per_level <cfg_storage-vinyl_run_count_per_level>` "
"и :ref:`vinyl_run_size_ratio <cfg_storage-vinyl_run_size_ratio>` -- см. "
"описание этих параметров. Текущие значения можно увидеть, сделав выборку "
"из :ref:`box.space._index <box_space-index>`."

#: ../doc/book/box/box_space.rst:353
msgid ""
"Building or rebuilding a large index will cause occasional :ref:`yields "
"<atomic-cooperative_multitasking>` so that other requests will not be "
"blocked. If the other requests cause an illegal situation such as a "
"duplicate key in a unique index, the index building or rebuilding will "
"fail."
msgstr ""

#: ../doc/book/box/box_space.rst:361
msgid "too many parts;"
msgstr "слишком много частей;"

#: ../doc/book/box/box_space.rst:362
msgid "index '...' already exists;"
msgstr "индекс '...' уже существует;"

#: ../doc/book/box/box_space.rst:363
msgid "primary key must be unique."
msgstr "первичный ключ должен быть уникальным."

#: ../doc/book/box/box_space.rst:365
#, fuzzy
msgid ""
"tarantool> s = box.space.tester\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {unique = true, parts = { {field = 1, "
"type = 'unsigned'}, {field = 2, type = 'string'}} })\n"
"---\n"
"..."
msgstr ""
"tarantool> s = box.space.tester\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {unique = true, parts = {1, "
"'unsigned', 2, 'string'}})\n"
"---\n"
"..."

#: ../doc/book/box/box_space.rst:376
msgid "**Details about index field types:**"
msgstr "**Подробнее о типах полей индекса:**"

#: ../doc/book/box/box_space.rst:378
#, fuzzy
msgid ""
"The eight index field types (unsigned | string | integer | number | "
"boolean | varbinary | array | scalar) differ depending on what values are"
" allowed, and what index types are allowed."
msgstr ""
"Семь типов полей индекса (unsigned | string | integer | number | boolean "
"| array | scalar) отличаются друг от друга возможными значениями и типами"
" индексов, где можно использовать такие поля."

#: ../doc/book/box/box_space.rst:382
msgid ""
"**unsigned**: unsigned integers between 0 and 18446744073709551615, about"
" 18 quintillion. May also be called 'uint' or 'num', but 'num' is "
"deprecated. Legal in memtx TREE or HASH indexes, and in vinyl TREE "
"indexes."
msgstr ""
"**unsigned**: беззнаковые целые числа от 0 до 18 446 744 073 709 551 615,"
" т.е. около18 квинтиллионов. Также может называться 'uint' или 'num', но "
"'num' объявлен устаревшим. Используется в индексах типа TREE или HASH в "
"memtx'е, и в TREE-индексах в vinyl'е."

#: ../doc/book/box/box_space.rst:386
msgid ""
"**string**: any set of octets, up to the :ref:`maximum length "
"<limitations_bytes_in_index_key>`. May also be called 'str'. Legal in "
"memtx TREE or HASH or BITSET indexes, and in vinyl TREE indexes. A string"
" may have a :ref:`collation <index-collation>`."
msgstr ""
"**string**: строка, то есть любая последовательность октетов до "
":ref:`максимальной длины <limitations_bytes_in_index_key>`. Также может "
"называться 'str'. Используется в индексах типа TREE, HASH или BITSET в "
"memtx'е и в TREE-индексах в vinyl'е. В строке может быть :ref:`сортировка"
" <index-collation>`."

#: ../doc/book/box/box_space.rst:390
msgid ""
"**integer**: integers between -9223372036854775808 and "
"18446744073709551615. May also be called 'int'. Legal in memtx TREE or "
"HASH indexes, and in vinyl TREE indexes."
msgstr ""
"**integer**: целые числа от -9 223 372 036 854 775 808 до 18 446 744 073 "
"709 551 615. Также может называться 'int'. Используется в индексах типа "
"TREE или HASH в memtx'е и в TREE-индексах в vinyl'е."

#: ../doc/book/box/box_space.rst:393
msgid ""
"**number**: integers between -9223372036854775808 and "
"18446744073709551615, single-precision floating point numbers, or double-"
"precision floating point numbers. Legal in memtx TREE or HASH indexes, "
"and in vinyl TREE indexes."
msgstr ""
"**number**: целые числа от -9 223 372 036 854 775 808 до 18 446 744 073 "
"709 551 615, числа с плавающей запятой с одинарной точностью или с "
"двойной точностью. Используется в индексах типа TREE или HASH в memtx'е и"
" в TREE-индексах в vinyl'е."

#: ../doc/book/box/box_space.rst:397
msgid ""
"**boolean**: true or false. Legal in memtx TREE or HASH indexes, and in "
"vinyl TREE indexes."
msgstr ""
"**boolean**: логическое значение, true (правда) или false (ложь). "
"Используется в индексах типа TREE или HASH в memtx'е и в TREE-индексах в "
"vinyl'е."

#: ../doc/book/box/box_space.rst:399
msgid ""
"**varbinary**: any set of octets, up to the :ref:`maximum length "
"<limitations_bytes_in_index_key>`. Legal in memtx TREE or HASH indexes, "
"and in vinyl TREE indexes. A varbinary byte sequence does not have a "
":ref:`collation <index-collation>` because its contents are not UTF-8 "
"characters."
msgstr ""

#: ../doc/book/box/box_space.rst:404
msgid ""
"**array**: array of numbers. Legal in memtx :ref:`RTREE <box_index-"
"rtree>` indexes."
msgstr ""
"**array**: массив чисел. Используется в :ref:`RTREE-индексах <box_index-"
"rtree>` в memtx'е."

#: ../doc/book/box/box_space.rst:405
#, fuzzy
msgid ""
"**scalar**: null (input with ``msgpack.NULL`` or ``yaml.NULL`` or "
"``json.NULL``), booleans (true or false), or integers between "
"-9223372036854775808 and 18446744073709551615, or single-precision "
"floating point numbers, or double-precison floating-point numbers, or "
"strings. When there is a mix of types, the key order is: null, then "
"booleans, then numbers, then strings. Legal in memtx TREE or HASH "
"indexes, and in vinyl TREE indexes."
msgstr ""
"**scalar**: логические значения (true или false), целые числа от integers"
" between -9 223 372 036 854 775 808 до 18 446 744 073 709 551 615, числа "
"с плавающей запятой с одинарной точностью или с двойной точностью или "
"строки. При использовании нескольких типов, порядок ключей должен быть "
"следующим: логические значения, затем числа, затем строки. Используется в"
" индексах типа TREE или HASH в memtx'е и в TREE-индексах в vinyl'е."

#: ../doc/book/box/box_space.rst:413
msgid ""
"Additionally, `nil` is allowed with any index field type if "
":ref:`is_nullable=true <box_space-is_nullable>` is specified."
msgstr ""
"Кроме того, допускается нулевое значение `nil` для любого типа поля, если"
" указана такая возможность :ref:`is_nullable=true <box_space-"
"is_nullable>`."

#: ../doc/book/box/box_space.rst:418
msgid "**Index field types to use in space_object:create_index()**"
msgstr "**Типы полей в индексах для использования в space_object:create_index()**"

#: ../doc/book/box/box_space.rst:431
msgid "Index field type"
msgstr "Тип поля для индексирования"

#: ../doc/book/box/box_space.rst:431
msgid "What can be in it"
msgstr "Чем может быть"

#: ../doc/book/box/box_space.rst:431
msgid "Where is it legal"
msgstr "Где может использоваться"

#: ../doc/book/box/box_space.rst:431 ../doc/book/box/data_model.rst:278
#: ../doc/book/box/data_model.rst:498
msgid "Examples"
msgstr "Примеры"

#: ../doc/book/box/box_space.rst:433
msgid "**unsigned**"
msgstr "**unsigned**"

#: ../doc/book/box/box_space.rst:433
msgid "integers between 0 and 18446744073709551615"
msgstr "целые числа от 0 до 18 446 744 073 709 551 615"

#: ../doc/book/box/box_space.rst:433 ../doc/book/box/box_space.rst:443
#: ../doc/book/box/box_space.rst:447 ../doc/book/box/box_space.rst:455
#: ../doc/book/box/box_space.rst:462
msgid "memtx TREE or HASH indexes, |br| vinyl TREE indexes"
msgstr "индексы типа TREE или HASH в memtx'е, |br| TREE-индексы в vinyl'е"

#: ../doc/book/box/box_space.rst:433
msgid "123456 |br|"
msgstr "123456 |br|"

#: ../doc/book/box/box_space.rst:437
msgid "**string**"
msgstr "**string**"

#: ../doc/book/box/box_space.rst:437
msgid "strings -- any set of octets"
msgstr "строки -- любой набор октетов"

#: ../doc/book/box/box_space.rst:437 ../doc/book/box/box_space.rst:440
msgid "memtx TREE or HASH indexes |br| vinyl TREE indexes"
msgstr "индексы типа TREE или HASH в memtx'е |br| TREE-индексы в vinyl'е"

#: ../doc/book/box/box_space.rst:437
msgid "'A B C' |br| '\\\\65 \\\\66 \\\\67'"
msgstr "'A B C' |br| '\\\\65 \\\\66 \\\\67'"

#: ../doc/book/box/box_space.rst:440 ../doc/book/box/data_model.rst:305
#, fuzzy
msgid "**varbinary**"
msgstr "**array**"

#: ../doc/book/box/box_space.rst:440
#, fuzzy
msgid "byte sequences -- any set of octets"
msgstr "строки -- любой набор октетов"

#: ../doc/book/box/box_space.rst:440
#, fuzzy
msgid "'\\\\65 \\\\66 \\\\67' |br|"
msgstr "‘\\65 \\66 \\67’"

#: ../doc/book/box/box_space.rst:443
msgid "**integer**"
msgstr "**integer**"

#: ../doc/book/box/box_space.rst:443
msgid "integers between -9223372036854775808 and 18446744073709551615"
msgstr "целые числа от -9 223 372 036 854 775 808 до 18 446 744 073 709 551 615"

#: ../doc/book/box/box_space.rst:443
msgid "-2^63 |br|"
msgstr "-2^63 |br|"

#: ../doc/book/box/box_space.rst:447 ../doc/book/box/data_model.rst:291
msgid "**number**"
msgstr "**number**"

#: ../doc/book/box/box_space.rst:447
msgid ""
"integers between -9223372036854775808 and 18446744073709551615, single-"
"precision floating point numbers, double-precision floating point numbers"
msgstr ""
"целые числа от -9 223 372 036 854 775 808 до 18 446 744 073 709 551 615, "
"числа с плавающей запятой с одинарной точностью или с двойной точностью"

#: ../doc/book/box/box_space.rst:447
msgid "1.234 |br| -44 |br| 1.447e+44"
msgstr "1.234 |br| -44 |br| 1.447e+44"

#: ../doc/book/box/box_space.rst:455 ../doc/book/box/data_model.rst:309
msgid "**boolean**"
msgstr "**boolean**"

#: ../doc/book/box/box_space.rst:455
msgid "true or false"
msgstr "true или false"

#: ../doc/book/box/box_space.rst:455
msgid "false |br| true"
msgstr "false |br| true"

#: ../doc/book/box/box_space.rst:458 ../doc/book/box/data_model.rst:312
msgid "**array**"
msgstr "**array**"

#: ../doc/book/box/box_space.rst:458
msgid "array of integers between -9223372036854775808 and 9223372036854775807"
msgstr ""
"массив целых чисел от -9 223 372 036 854 775 808 до 9 223 372 036 854 775"
" 807"

#: ../doc/book/box/box_space.rst:458
msgid "memtx RTREE indexes"
msgstr "RTREE-индексы в memtx'е"

#: ../doc/book/box/box_space.rst:458
msgid "{10, 11} |br| {3, 5, 9, 10}"
msgstr "{10, 11} |br| {3, 5, 9, 10}"

#: ../doc/book/box/box_space.rst:462 ../doc/book/box/data_model.rst:317
msgid "**scalar**"
msgstr "**scalar**"

#: ../doc/book/box/box_space.rst:462
#, fuzzy
msgid ""
"null, booleans (true or false), integers between -9223372036854775808 and"
" 18446744073709551615, single-precision floating point numbers, double-"
"precision floating point numbers, strings"
msgstr ""
"логические значения (true или false), целые числа от -9 223 372 036 854 "
"775 808 до 18 446 744 073 709 551 615, числа с плавающей запятой с "
"одинарной точностью или с двойной точностью, строки"

#: ../doc/book/box/box_space.rst:462
#, fuzzy
msgid "null |br| true |br| -1 |br| 1.234 |br| '' |br| 'ру'"
msgstr "true |br| -1 |br| 1.234 |br| '' |br| 'ру'"

#: ../doc/book/box/box_space.rst:475
msgid ""
"**Allowing null for an indexed key:** If the index type is TREE, and the "
"index is not the primary index, then the ``parts={...}`` clause may "
"include ``is_nullable=true`` or ``is_nullable=false`` (the default). If "
"``is_nullable`` is true, then it is legal to insert ``nil`` or an "
"equivalent such as ``msgpack.NULL`` (or it is legal to insert nothing at "
"all for trailing nullable fields). Within indexes, such \"null values\" "
"are always treated as equal to other null values, and are always treated "
"as less than non-null values. Nulls may appear multiple times even in a "
"unique index. Example:"
msgstr ""
"**Разрешение использования нулевых значений для индексируемого ключа:** "
"/Если тип индекса -- TREE, и индекс не является первичным, то оператор "
"``parts={...}`` может включать в себя ``is_nullable=true`` или "
"``is_nullable=false`` (по умолчанию). Если значение параметра "
"``is_nullable`` -- true, то можно вставлять ``nil`` или аналогичное "
"значение, например ``msgpack.NULL`` (или можно не вставлять вообще ничего"
" в завершающие ненулевые поля). В рамках индекса такие нулевые значения "
"считаются равными другим нулевым значениям и всегда меньше ненулевых "
"значений. Нулевые значения могут встречаться несколько раз даже в "
"уникальном индексе. Например:"

#: ../doc/book/box/box_space.rst:484
#, fuzzy
msgid ""
"box.space.tester:create_index('I',{unique=true,parts={{field = 2, type = "
"'number', is_nullable = true}}})"
msgstr "box.space.tester:create_index('I',{unique=true,parts={{2,'number',is_nullable=true}}})"

#: ../doc/book/box/box_space.rst:490
msgid ""
"It is legal to create multiple indexes for the same field with different "
"``is_nullable`` values, or to call :ref:`space_object:format() "
"<box_space-format>` with a different ``is_nullable`` value from what is "
"used for an index. When there is a contradiction, the rule is: null is "
"illegal unless ``is_nullable=true`` for every index and for the space "
"format."
msgstr ""
"Можно создать множество индексов для одного и того же поля с различными "
"значениями ``is_nullable`` или вызвать :ref:`space_object:format() "
"<box_space-format>` со значением ``is_nullable``, отличным от "
"используемого для индекса. При наличии несоответствий правило такое: "
"запрещается использовать null кроме случаев, когда ``is_nullable=true`` "
"для всех индексов и формата спейса."

#: ../doc/book/box/box_space.rst:498
msgid ""
"**Using field names instead of field numbers:** ``create_index()`` can "
"use field names and/or field types described by the optional "
":ref:`space_object:format() <box_space-format>` clause. In the following "
"example, we show ``format()`` for a space that has two columns named 'x' "
"and 'y', and then we show five variations of the ``parts={}`` clause of "
"``create_index()``, first for the 'x' column, second for both the 'x' and"
" 'y' columns. The variations include omitting the type, using numbers, "
"and adding extra braces."
msgstr ""
"**Использование имен полей вместо номеров полей:** в ``create_index()`` "
"можно использовать имена полей и/или типы полей, описанные в "
"необязательном операторе :ref:`space_object:format() <box_space-format>`."
" В следующем примере покажем ``format()`` для спейса с двумя столбцами "
"под названиями 'x' и 'y', а затем покажем пять вариантов оператора "
"``parts={}`` в ``create_index()``, сначала для столбца 'x', затем для "
"столбцов 'x' и 'y'. Варианты включают в себя пропуск типа, использование "
"номеров и добавление дополнительных фигурных скобок."

#: ../doc/book/box/box_space.rst:507
#, fuzzy
msgid ""
"box.space.tester:format({{name='x', type='scalar'}, {name='y', "
"type='integer'}})\n"
"box.space.tester:create_index('I2',{parts={{'x', 'scalar'}}})\n"
"box.space.tester:create_index('I3',{parts={{'x','scalar'},{'y','integer'}}})"
"\n"
"box.space.tester:create_index('I4',{parts={1,'scalar'}})\n"
"box.space.tester:create_index('I5',{parts={1,'scalar',2,'integer'}})\n"
"box.space.tester:create_index('I6',{parts={1}})\n"
"box.space.tester:create_index('I7',{parts={1,2}})\n"
"box.space.tester:create_index('I8',{parts={'x'}})\n"
"box.space.tester:create_index('I9',{parts={'x','y'}})\n"
"box.space.tester:create_index('I10',{parts={{'x'}}})\n"
"box.space.tester:create_index('I11',{parts={{'x'},{'y'}}})"
msgstr ""
"box.space.tester:format({{name='x', type='scalar'}, {name='y', "
"type='integer'}})\n"
"box.space.tester:create_index('I2',{parts={{'x','scalar'}}})\n"
"box.space.tester:create_index('I3',{parts={{'x','scalar'},{'y','integer'}}})"
"\n"
"box.space.tester:create_index('I4',{parts={1,'scalar'}})\n"
"box.space.tester:create_index('I5',{parts={1,'scalar',2,'integer'}})\n"
"box.space.tester:create_index('I6',{parts={1}})\n"
"box.space.tester:create_index('I7',{parts={1,2}})\n"
"box.space.tester:create_index('I8',{parts={'x'}})\n"
"box.space.tester:create_index('I9',{parts={'x','y'}})\n"
"box.space.tester:create_index('I10',{parts={{'x'}}})\n"
"box.space.tester:create_index('I11',{parts={{'x'},{'y'}}})"

#: ../doc/book/box/box_space.rst:523
msgid ""
"**Using the path option for map fields:** To create an index for a field "
"that is a map (a path string and a scalar value), specify the path string"
" during index_create, that is, :code:`parts={` :samp:`{field-number"
"},'{data-type}',path = '{path-name}'` :code:`}`. The index type must be "
"``'tree'`` or ``'hash'`` and the field's contents must always be maps "
"with the same path."
msgstr ""

#: ../doc/book/box/box_space.rst:529
msgid ""
"-- Example 1 -- The simplest use of path:\n"
"-- Result will be - - [{'age': 44}]\n"
"box.schema.space.create('T')\n"
"box.space.T:create_index('I',{parts={{field = 1, type = 'scalar', path = "
"'age'}}})\n"
"box.space.T:insert{{age=44}}\n"
"box.space.T:select(44)\n"
"-- Example 2 -- path plus format() plus JSON syntax to add clarity\n"
"-- Result will be: - [1, {'FIO': {'surname': 'Xi', 'firstname': "
"'Ahmed'}}]\n"
"s = box.schema.space.create('T')\n"
"format = {{'id', 'unsigned'}, {'data', 'map'}}\n"
"s:format(format)\n"
"parts = {{'data.FIO[\"firstname\"]', 'str'}, {'data.FIO[\"surname\"]', "
"'str'}}\n"
"i = s:create_index('info', {parts = parts})\n"
"s:insert({1, {FIO={firstname='Ahmed', surname='Xi'}}})"
msgstr ""

#: ../doc/book/box/box_space.rst:546
msgid ""
"**Note re storage engine:** vinyl supports only the TREE index type, and "
"vinyl secondary indexes must be created before tuples are inserted."
msgstr ""
"**Примечание про движок базы данных:** vinyl поддерживает только "
"TREE-индексы, и следует создать в vinyl'е вторичные индексы до вставки "
"кортежей."

#: ../doc/book/box/box_space.rst:551
msgid ""
"**Using the path option with [*]**  The string in a path option can "
"contain '[*]' which is called an array index placeholder. Indexes defined"
" with this are useful for JSON documents that all have the same "
"structure. For example, when creating an index on field#2 for a string "
"document that will start with ``{'data': [{'name': '...'}, {'name': "
"'...'}]``, the parts section in the create_index request could look like:"
" ``parts = {{field = 2, type = 'str', path = 'data[*].name'}}``. Then "
"tuples containing names can be retrieved quickly with "
"``index_object:select({key-value})``. In fact a single field can have "
"multiple keys, as in this example which retrieves the same tuple twice "
"because there are two keys 'A' and 'B' which both match the request:"
msgstr ""

#: ../doc/book/box/box_space.rst:561
msgid ""
"s = box.schema.space.create('json_documents')\n"
"s:create_index('primarykey')\n"
"i = s:create_index('multikey', {parts = {{field = 2, type = 'str', path ="
" 'data[*].name'}}})\n"
"s:insert({1,\n"
"         {data = {{name='A'},\n"
"                  {name='B'}},\n"
"          extra_field = 1}})\n"
"i:select({''},{iterator='GE'})\n"
"--  The result of the select request looks like this:\n"
"--  tarantool> i:select({''},{iterator='GE'})\n"
"--  ---\n"
"--  - - [1, {'data': [{'name': 'A'}, {'name': 'B'}], 'extra_field': 1}]\n"
"--    - [1, {'data': [{'name': 'A'}, {'name': 'B'}], 'extra_field': 1}]\n"
"--  ..."
msgstr ""

#: ../doc/book/box/box_space.rst:578
msgid ""
"Some restrictions exist: () '[*]' must be alone or must be at the end of "
"a name in the path; () '[*]' must not appear twice in the path; () if an "
"index has a path with x[*] then no other index can have a path with "
"x.component; () '[*]' must not appear in the path of a primary-key ; () "
"if an index has ``unique=true`` and has a path with '[*]' then duplicate "
"keys from different tuples are disallowed but duplicate keys for the same"
" tuple are allowed; () As with :ref:`Using the path option for map fields"
" <box_space-path>`, the field's value must have the structure that the "
"path definition implies, or be nil (nil is not indexed)."
msgstr ""

#: ../doc/book/box/box_space.rst:590
#, fuzzy
msgid "**Making a functional index with space_object:create_index()**"
msgstr "**Параметры для space_object:create_index()**"

#: ../doc/book/box/box_space.rst:592
msgid ""
"Functional indexes are indexes that call a user-defined function for "
"forming the index key, rather than depending entirely on the Tarantool "
"default formation. Functional indexes are useful for condensing or "
"truncating or reversing or any other way that users want to customize the"
" index."
msgstr ""

#: ../doc/book/box/box_space.rst:597
msgid ""
"The function definition must expect a tuple (which has the contents of "
"fields at the time a data-change request happens) and must return a tuple"
" (which has the contents that will actually be put in the index)."
msgstr ""

#: ../doc/book/box/box_space.rst:601
msgid ""
"The space must have a memtx engine. |br| The function must be "
":ref:`persistent <box_schema-func_create_with-body>` and deterministic. "
"|br| The key parts must not depend on JSON paths. |br| The "
"``create_index`` definition must include specification of all key parts, "
"and the function must return a table which has the same number of key "
"parts with the same types. |br| The function must access key-part values "
"by index, not by field name. |br| Functional indexes must not be primary-"
"key indexes. |br| Functional indexes cannot be altered and the function "
"cannot be changed if it is used for an index, so the only way to change "
"them is to drop the index and create it again."
msgstr ""

#: ../doc/book/box/box_space.rst:615
msgid "A function could make a key using only the first letter of a string field."
msgstr ""

#: ../doc/book/box/box_space.rst:617
msgid ""
"-- Step 1: Make the space.\n"
"-- The space needs a primary-key field, which is not the field that we\n"
"-- will use for the functional index.\n"
"box.schema.space.create('x', {engine = 'memtx'})\n"
"box.space.x:create_index('i',{parts={field = 1, type = 'string'}})\n"
"-- Step 2: Make the function.\n"
"-- The function expects a tuple. In this example it will work on tuple[2]"
"\n"
"-- because the key souce is field number 2 in what we will insert.\n"
"-- Use string.sub() from the string module to get the first character.\n"
"lua_code = [[function(tuple) return {string.sub(tuple[2],1,1)} end]]\n"
"-- Step 3: Make the function persistent.\n"
"-- Use the box.schema.func.create function for this.\n"
"box.schema.func.create('F',\n"
"    {body = lua_code, is_deterministic = true, is_sandboxed = true})\n"
"-- Step 4: Make the functional index.\n"
"-- Specify the fields whose values will be passed to the function.\n"
"-- Specify the function.\n"
"box.space.x:create_index('j',{parts={field = 1, type = 'string'},func = "
"'F'})\n"
"-- Step 5: Test.\n"
"-- Insert a few tuples.\n"
"-- Select using only the first letter, it will work because that is the "
"key\n"
"-- Or, select using the same function as was used for insertion\n"
"box.space.x:insert{'a', 'wombat'}\n"
"box.space.x:insert{'b', 'rabbit'}\n"
"-- Select using only the first letter, it will work because that is the "
"key\n"
"-- Or, select using the same function as was used for insertion\n"
"box.space.x:insert{'a', 'wombat'}\n"
"box.space.x:insert{'b', 'rabbit'}\n"
"box.space.x.index.j:select('w')\n"
"box.space.x.index.j:select(box.func.F:call({{'x', 'wombat'}}));"
msgstr ""

#: ../doc/book/box/box_space.rst:650
#, fuzzy
msgid "The results of the two ``select`` requests will look like this:"
msgstr "Результат будет выглядеть следующим образом:"

#: ../doc/book/box/box_space.rst:652
msgid ""
"tarantool>     box.space.x.index.j:select('w')\n"
"---\n"
"- - ['a', 'wombat']\n"
"...\n"
"\n"
"tarantool>     "
"box.space.x.index.j:select(box.func.F:call({{'x','wombat'}}));\n"
"---\n"
"- - ['a', 'wombat']\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:664
msgid ""
"Functions for functional indexes can return multiple keys. |br| Such "
"functions are called \"multikey\" functions. |br| The ``box.func.create``"
" options must include ``opts = {is_multikey = true}``. |br| The return "
"value must be a table of tuples. |br| If a multikey function returns N "
"tuples, then N keys will be added to the index."
msgstr ""

#: ../doc/book/box/box_space.rst:672
msgid ""
"s = box.schema.space.create('withdata')\n"
"s:format({{name = 'name', type = 'string'},\n"
"          {name = 'address', type = 'string'}})\n"
"pk = s:create_index('name', {parts = {{field = 1, type = 'string'}}})\n"
"lua_code = [[function(tuple)\n"
"               local address = string.split(tuple[2])\n"
"               local ret = {}\n"
"               for _, v in pairs(address) do\n"
"                 table.insert(ret, {utf8.upper(v)})\n"
"               end\n"
"               return ret\n"
"             end]]\n"
"box.schema.func.create('address',\n"
"                        {body = lua_code,\n"
"                         is_deterministic = true,\n"
"                         is_sandboxed = true,\n"
"                         opts = {is_multikey = true}})\n"
"idx = s:create_index('addr', {unique = false,\n"
"                              func = 'address',\n"
"                              parts = {{field = 1, type = 'string',\n"
"                                      collation = 'unicode_ci'}}})\n"
"s:insert({\"James\", \"SIS Building Lambeth London UK\"})\n"
"s:insert({\"Sherlock\", \"221B Baker St Marylebone London NW1 6XE UK\"})\n"
"idx:select('Uk')\n"
"-- Both tuples will be returned."
msgstr ""

#: ../doc/book/box/box_space.rst:704
msgid "Delete a tuple identified by a primary key."
msgstr "Удаление кортежа по первичному ключу."

#: ../doc/book/box/box_space.rst:711
msgid "the deleted tuple"
msgstr "удаленный кортеж."

#: ../doc/book/box/box_space.rst:714
msgid "**Complexity factors:** Index size, Index type"
msgstr "**Факторы сложности:** Размер индекса, тип индекса"

#: ../doc/book/box/box_space.rst:716
msgid ""
"**Note re storage engine:** vinyl will return ``nil``, rather than the "
"deleted tuple."
msgstr ""
"**Примечание про движок базы данных:** vinyl вернет ``nil``, а не "
"удаленный кортеж."

#: ../doc/book/box/box_space.rst:721
msgid ""
"tarantool> box.space.tester:delete(1)\n"
"---\n"
"- [1, 'My first tuple']\n"
"...\n"
"tarantool> box.space.tester:delete(1)\n"
"---\n"
"...\n"
"tarantool> box.space.tester:delete('a')\n"
"---\n"
"- error: 'Supplied key type of part 0 does not match index part type:\n"
"  expected unsigned'\n"
"..."
msgstr ""
"tarantool> box.space.tester:delete(1)\n"
"---\n"
"- [1, 'My first tuple']\n"
"...\n"
"tarantool> box.space.tester:delete(1)\n"
"---\n"
"...\n"
"tarantool> box.space.tester:delete('a')\n"
"---\n"
"- error: 'Supplied key type of part 0 does not match index part type:\n"
"  expected unsigned'\n"
"..."

#: ../doc/book/box/box_space.rst:736 ../doc/book/box/box_space.rst:1035
#: ../doc/book/box/box_space.rst:1362 ../doc/book/box/box_space.rst:1490
#: ../doc/book/box/box_space.rst:1662 ../doc/book/box/box_space.rst:1710
msgid ""
"For more usage scenarios and typical errors see :ref:`Example: using data"
" operations <box_space-operations-detailed-examples>` further in this "
"section."
msgstr ""
"Для получения дополнительной информации о сценариях использования и "
"типичных ошибках, см. :ref:`Пример: использование операций с данными "
"<box_space-operations-detailed-examples>` далее в разделе."

#: ../doc/book/box/box_space.rst:744
msgid "Drop a space."
msgstr "Удаление спейса."

#: ../doc/book/box/box_space.rst:751 ../doc/book/box/box_space.rst:971
#: ../doc/book/box/box_space.rst:1318
msgid "**Possible errors:** ``space_object`` does not exist."
msgstr "**Возможные ошибки:** ``space_object`` не существует."

#: ../doc/book/box/box_space.rst:753 ../doc/book/box/box_space.rst:973
#: ../doc/book/box/box_space.rst:1353
msgid ""
"**Complexity factors:** Index size, Index type, Number of indexes "
"accessed, WAL settings."
msgstr ""
"**Факторы сложности** Размер индекса, тип индекса, количество кортежей, к"
" которым получен доступ, настройки журнала упреждающей записи (WAL)."

#: ../doc/book/box/box_space.rst:758
msgid "box.space.space_that_does_not_exist:drop()"
msgstr "box.space.space_that_does_not_exist:drop()"

#: ../doc/book/box/box_space.rst:766
msgid "Declare field names and :ref:`types <index-box_data-types>`."
msgstr "Объявление имен и :ref:`типов <index-box_data-types>` полей."

#: ../doc/book/box/box_space.rst:770
msgid "a list of field names and types"
msgstr "список имен и типов полей"

#: ../doc/book/box/box_space.rst:772
msgid "nil, unless format-clause is omitted"
msgstr "nil, если не указан оператор формата"

#: ../doc/book/box/box_space.rst:776
msgid "``space_object`` does not exist;"
msgstr "``space_object`` не существует,"

#: ../doc/book/box/box_space.rst:777
msgid "field names are duplicated;"
msgstr "дублируются имена полей;"

#: ../doc/book/box/box_space.rst:778
msgid "type is not legal."
msgstr "тип не поддерживается."

#: ../doc/book/box/box_space.rst:780
msgid ""
"Ordinarily Tarantool allows unnamed untyped fields. But with ``format`` "
"users can, for example, document that the Nth field is the surname field "
"and must contain strings. It is also possible to specify a format clause "
"in :ref:`box.schema.space.create() <box_schema-space_create>`."
msgstr ""
"Как правило, Tarantool допускает поля без имен и без указания типа. Но с "
"помощью ``format`` можно, например, задокументировать, что N-ное поле "
"представляет собой поле для фамилии и должно содержать строковое "
"значение. Также оператор формата можно указать в "
":ref:`box.schema.space.create() <box_schema-space_create>`."

#: ../doc/book/box/box_space.rst:786
msgid ""
"The format clause contains, for each field, a definition within braces: "
"``{name='...',type='...'[,is_nullable=...]}``, where:"
msgstr ""
"Оператор формата для каждого поля содержит определение в фигурных "
"скобках: ``{name='...',type='...'[,is_nullable=...]}``, где:"

#: ../doc/book/box/box_space.rst:789
msgid ""
"the ``name`` value may be any string, provided that two fields do not "
"have the same name;"
msgstr ""
"значение ``name`` может представлять собой любую строку при условии, что "
"у двух полей не будет одинаковых имен;"

#: ../doc/book/box/box_space.rst:791
#, fuzzy
msgid ""
"the ``type`` value may be any of those allowed for :ref:`indexed fields "
"<index-box_indexed-field-types>`: unsigned | string | varbinary | integer"
" | number | boolean | array | scalar (the same as the requirement in "
":ref:`\"Options for space_object:create_index\" <box_space-create_index-"
"options>`);"
msgstr ""
"значением ``type`` может быть любой допустимый тип для "
":ref:`индексируемых полей <index-box_indexed-field-types>`: unsigned | "
"string | integer | number | boolean | array | scalar (такое же "
"требование, как для :ref:`\"Параметров для space_object:create_index\" "
"<box_space-create_index-options>`);"

#: ../doc/book/box/box_space.rst:796
msgid ""
"the optional ``is_nullable`` value may be either ``true`` or ``false`` "
"(the same as the requirement in :ref:`\"Options for "
"space_object:create_index\" <box_space-create_index-options>`). See also "
"the warning notice in section :ref:`Allowing null for an indexed key "
"<box_space-is_nullable>`."
msgstr ""
"значение необязательного параметра ``is_nullable`` может быть ``true`` "
"или ``false`` (такое же требование, как для :ref:`\"Параметров для "
"space_object:create_index\" <box_space-create_index-options>`). См. также"
" предупреждение в разделе :ref:`Разрешение использования нулевых значений"
" для индексируемого ключа<box_space-is_nullable>`."

#: ../doc/book/box/box_space.rst:802
msgid ""
"It is not legal for tuples to contain values that have the wrong type; "
"for example after ``box.space.tester:format({{' ',type='number'}})`` the "
"request ``box.space.tester:insert{'string-which-is-not-a-number'}`` will "
"cause an error."
msgstr ""
"В кортежах недопустимы значения неправильного типа; например, после "
"``box.space.tester:format({{' ',type='number'}})`` (тип = число) запрос "
"``box.space.tester:insert{'строка-которая-не-является-числом'}`` вызовет "
"ошибку."

#: ../doc/book/box/box_space.rst:806
msgid ""
"It is not legal for tuples to contain null values if "
"``is_nullable=false``, which is the default; for example after "
"``box.space.tester:format({{' ',type='number',is_nullable=false}})`` the "
"request ``box.space.tester:insert{nil,2}`` will cause an error."
msgstr ""
"В кортежах недопустимы нулевые значения, если ``is_nullable=false``, что "
"задано по умолчанию; например, после ``box.space.tester:format({{' "
"',type='number',is_nullable=false}})`` запрос "
"``box.space.tester:insert{nil,2}`` вызовет ошибку."

#: ../doc/book/box/box_space.rst:810
msgid ""
"It is legal for tuples to have more fields than are described by a format"
" clause. The way to constrain the number of fields is to specify a "
"space's :ref:`field_count <box_space-field_count>` member."
msgstr ""
"В кортежах может быть больше полей, чем описано в операторе формата. "
"Чтобы ограничить количество полей, необходимо указать элемент спейса "
":ref:`field_count <box_space-field_count>`."

#: ../doc/book/box/box_space.rst:814
msgid ""
"It is legal for tuples to have fewer fields than are described by a "
"format clause, if the omitted trailing fields are described with "
"``is_nullable=true``; for example after "
"``box.space.tester:format({{'a',type='number'},{'b',type='number',is_nullable=true}})``"
" the request ``box.space.tester:insert{2}`` will not cause a format-"
"related error."
msgstr ""
"В кортежах может быть меньше полей, чем описано в операторе формата, если"
" пропущенные завершающие поля описаны с помощью ``is_nullable=true``; "
"например после "
"``box.space.tester:format({{'a',type='number'},{'b',type='number',is_nullable=true}})``"
" запрос ``box.space.tester:insert{2}`` не приведет к ошибке формата."

#: ../doc/book/box/box_space.rst:819
msgid ""
"It is legal to use ``format`` on a space that already has a format, thus "
"replacing any previous definitions, provided that there is no conflict "
"with existing data or index definitions."
msgstr ""
"Можно использовать ``format`` для спейса, в котором уже определен формат,"
" заменяя таким образом предыдущие определения при условии, что нет "
"конфликта с существующими данными или определениями индекса."

#: ../doc/book/box/box_space.rst:823
msgid ""
"It is legal to use ``format`` to change the ``is_nullable`` flag; for "
"example after ``box.space.tester:format({{' "
"',type='scalar',is_nullable=false}})`` the request "
"``box.space.tester:format({{' ',type='scalar',is_nullable=true}})`` will "
"not cause an error -- and will not cause rebuilding of the space. But "
"going the other way and changing ``is_nullable`` from ``true`` to "
"``false`` might cause rebuilding and might cause an error if there are "
"existing tuples with nulls."
msgstr ""
"Можно использовать ``format`` для того, чтобы изменить значение флага "
"``is_nullable``; например, после ``box.space.tester:format({{' "
"',type='scalar',is_nullable=false}})`` запрос "
"``box.space.tester:format({{' ',type='scalar',is_nullable=true}})`` не "
"вызовет ошибку -- и не приведет к перестроению спейса. Но обратное "
"изменение значения ``is_nullable`` с ``true`` на ``false`` может вызвать "
"перестроение и привести к ошибке, если уже есть кортежи с нулевыми "
"значениями."

#: ../doc/book/box/box_space.rst:833
msgid ""
"box.space.tester:format({{name='surname',type='string'},{name='IDX',type='array'}})"
"\n"
"box.space.tester:format({{name='surname',type='string',is_nullable=true}})"
msgstr ""
"box.space.tester:format({{name='surname',type='string'},{name='IDX',type='array'}})"
"\n"
"box.space.tester:format({{name='surname',type='string',is_nullable=true}})"

#: ../doc/book/box/box_space.rst:839
msgid "There are legal variations of the format clause:"
msgstr "Можно использовать следующие варианты оператора:"

#: ../doc/book/box/box_space.rst:841
msgid "omitting both 'name=' and 'type=',"
msgstr "пропуск и 'name=', и 'type=',"

#: ../doc/book/box/box_space.rst:842
msgid "omitting 'type=' alone, and"
msgstr "пропуск 'type=' и"

#: ../doc/book/box/box_space.rst:843
msgid "adding extra braces."
msgstr "добавление дополнительных фигурных скобок."

#: ../doc/book/box/box_space.rst:845
msgid ""
"The following examples show all the variations, first for one field named"
" 'x', second for two fields named 'x' and 'y'."
msgstr ""
"В следующем примере иллюстрируются все варианты, первый для поля с именем"
" 'x', второй -- для двух полей с именами 'x' и 'y'."

#: ../doc/book/box/box_space.rst:848
msgid ""
"box.space.tester:format({{'x'}})\n"
"box.space.tester:format({{'x'},{'y'}})\n"
"box.space.tester:format({{name='x',type='scalar'}})\n"
"box.space.tester:format({{name='x',type='scalar'},{name='y',type='unsigned'}})"
"\n"
"box.space.tester:format({{name='x'}})\n"
"box.space.tester:format({{name='x'},{name='y'}})\n"
"box.space.tester:format({{'x',type='scalar'}})\n"
"box.space.tester:format({{'x',type='scalar'},{'y',type='unsigned'}})\n"
"box.space.tester:format({{'x','scalar'}})\n"
"box.space.tester:format({{'x','scalar'},{'y','unsigned'}})"
msgstr ""
"box.space.tester:format({{'x'}})\n"
"box.space.tester:format({{'x'},{'y'}})\n"
"box.space.tester:format({{name='x',type='scalar'}})\n"
"box.space.tester:format({{name='x',type='scalar'},{name='y',type='unsigned'}})"
"\n"
"box.space.tester:format({{name='x'}})\n"
"box.space.tester:format({{name='x'},{name='y'}})\n"
"box.space.tester:format({{'x',type='scalar'}})\n"
"box.space.tester:format({{'x',type='scalar'},{'y',type='unsigned'}})\n"
"box.space.tester:format({{'x','scalar'}})\n"
"box.space.tester:format({{'x','scalar'},{'y','unsigned'}})"

#: ../doc/book/box/box_space.rst:861
msgid ""
"The following example shows how to create a space, format it with all "
"possible types, and insert into it."
msgstr ""
"В следующем примере показывается создание спейса, определение формата для"
" него со всеми возможными типа и вставка данных."

#: ../doc/book/box/box_space.rst:864
#, fuzzy
msgid ""
"tarantool> box.schema.space.create('t')\n"
"--- ...\n"
"tarantool> box.space.t:format({{name='1',type='any'},\n"
"         >                     {name='2',type='unsigned'},\n"
"         >                     {name='3',type='string'},\n"
"         >                     {name='4',type='number'},\n"
"         >                     {name='5',type='integer'},\n"
"         >                     {name='6',type='boolean'},\n"
"         >                     {name='7',type='scalar'},\n"
"         >                     {name='8',type='array'},\n"
"         >                     {name='9',type='map'}})\n"
"--- ...\n"
"tarantool> box.space.t:create_index('i',{parts={field = 2, type = "
"'unsigned'}})\n"
"--- ...\n"
"tarantool> box.space.t:insert{{'a'},      -- any\n"
"         >                    1,          -- unsigned\n"
"         >                    'W?',       -- string\n"
"         >                    5.5,        -- number\n"
"         >                    -0,         -- integer\n"
"         >                    true,       -- boolean\n"
"         >                    true,       -- scalar\n"
"         >                    {{'a'}},    -- array\n"
"         >                    {val=1}}    -- map\n"
"---\n"
"- [['a'], 1, 'W?', 5.5, 0, true, true, [['a']], {'val': 1}]\n"
"..."
msgstr ""
"tarantool> box.schema.space.create('t')\n"
"--- ...\n"
"tarantool> box.space.t:format({{name='1',type='any'},\n"
"         >                     {name='2',type='unsigned'},\n"
"         >                     {name='3',type='string'},\n"
"         >                     {name='4',type='number'},\n"
"         >                     {name='5',type='integer'},\n"
"         >                     {name='6',type='boolean'},\n"
"         >                     {name='7',type='scalar'},\n"
"         >                     {name='8',type='array'},\n"
"         >                     {name='9',type='map'}})\n"
"--- ...\n"
"tarantool> box.space.t:create_index('i',{parts={2,'unsigned'}})\n"
"--- ...\n"
"tarantool> box.space.t:insert{{'a'},      -- any\n"
"         >                    1,          -- unsigned\n"
"         >                    'W?',       -- string\n"
"         >                    5.5,        -- number\n"
"         >                    -0,         -- integer\n"
"         >                    true,       -- boolean\n"
"         >                    true,       -- scalar\n"
"         >                    {{'a'}},    -- array\n"
"         >                    {val=1}}    -- map\n"
"---\n"
"- [['a'], 1, 'W?', 5.5, 0, true, true, [['a']], {'val': 1}]\n"
"..."

#: ../doc/book/box/box_space.rst:893
msgid ""
"Names specified with the format clause can be used in "
":ref:`space_object:get() <box_space-get>` and in "
":ref:`space_object:create_index() <box_space-create_index>` and in "
":ref:`tuple_object[field-name] <box_tuple-field_name>` and in "
":ref:`tuple_object[field-path] <box_tuple-field_path>`."
msgstr ""
"Имена, указанные с помощью оператора формата, можно использовать в "
":ref:`space_object:get() <box_space-get>`, в "
":ref:`space_object:create_index() <box_space-create_index>`, в "
":ref:`tuple_object[field-name] <box_tuple-field_name>` и в "
":ref:`tuple_object[field-path] <box_tuple-field_path>`."

#: ../doc/book/box/box_space.rst:899
msgid ""
"If the format clause is omitted, then the returned value is the table "
"that was used in a previous :samp:`{space_object}:format({format-"
"clause})` invocation. For example, after "
"``box.space.tester:format({{'x','scalar'}})``, "
"``box.space.tester:format()`` will return ``[{'name': 'x', 'type': "
"'scalar'}]``."
msgstr ""
"Если оператор формата не указан, то вернется таблица, которая "
"использовалась при предыдущем вызове "
":samp:`{объект-спейса}:format({оператор-формата})`. Например, после "
"``box.space.tester:format({{'x','scalar'}})``, "
"``box.space.tester:format()`` вернет ``[{'name': 'x', 'type': "
"'scalar'}]``."

#: ../doc/book/box/box_space.rst:904
msgid ""
"Formatting or reformatting a large space will cause occasional "
":ref:`yields <atomic-cooperative_multitasking>` so that other requests "
"will not be blocked. If the other requests cause an illegal situation "
"such as a field value of the wrong type, the formatting or reformatting "
"will fail."
msgstr ""

#: ../doc/book/box/box_space.rst:914
msgid ""
"Convert a map to a tuple instance or to a table. The map must consist of "
"\"field name = value\" pairs. The field names and the value types must "
"match names and types stated previously for the space, via "
":ref:`space_object:format() <box_space-format>`."
msgstr ""
"Конвертация ассоциативного массива в экземпляр кортежа или в таблицу. "
"Ассоциативный массив должен состоять из пар \"имя поля = значение\". "
"Имена полей и типы значений должны соответствовать именам и типам, ранее "
"заданным для спейса через :ref:`space_object:format() <box_space-"
"format>`."

#: ../doc/book/box/box_space.rst:922
msgid "a series of \"field = value\" pairs, in any order."
msgstr "ряд пар \"поле = значение\" в любом порядке."

#: ../doc/book/box/box_space.rst:923
msgid ""
"the only legal option is ``{table = true|false}``; |br| if the option is "
"omitted or if ``{table = false}``, then return type will be 'cdata' (i.e."
" tuple); |br| if ``{table = true}``, then return type will be 'table'."
msgstr ""
"единственный возможный параметр ``{table = true|false}``; |br| если "
"параметр не указан, или же ``{table = false}``, то возвращается 'cdata' "
"(то есть кортеж); |br| если ``{table = true}``, то возвращается таблица."

#: ../doc/book/box/box_space.rst:928
msgid "a tuple instance or table."
msgstr "кортеж или таблица."

#: ../doc/book/box/box_space.rst:929
msgid "tuple or table"
msgstr "кортеж или таблица"

#: ../doc/book/box/box_space.rst:931
msgid ""
"**Possible errors:** ``space_object`` does not exist or has no format; "
"\"unknown field\"."
msgstr ""
"**Возможные ошибки:** отсутствует объект спейса ``space_object``, или в "
"спейсе нет формата; \"unknown field\" (неизвестное поле)."

#: ../doc/book/box/box_space.rst:935
msgid ""
"-- Create a format with two fields named 'a' and 'b'.\n"
"-- Create a space with that format.\n"
"-- Create a tuple based on a map consistent with that space.\n"
"-- Create a table based on a map consistent with that space.\n"
"tarantool> format1 = "
"{{name='a',type='unsigned'},{name='b',type='scalar'}}\n"
"---\n"
"...\n"
"tarantool> s = box.schema.create_space('test', {format = format1})\n"
"---\n"
"...\n"
"tarantool> s:frommap({b = 'x', a = 123456})\n"
"---\n"
"- [123456, 'x']\n"
"...\n"
"tarantool> s:frommap({b = 'x', a = 123456}, {table = true})\n"
"---\n"
"- - 123456\n"
"  - x\n"
"..."
msgstr ""
"-- Создание формата с двумя полями под названиями 'a' и 'b'.\n"
"-- Создание спейса с таким форматом.\n"
"-- Создание кортежа на основе ассоциативного массива по данному спейсу.\n"
"-- Создание таблицы на основе ассоциативного массива по данному спейсу.\n"
"tarantool> format1 = "
"{{name='a',type='unsigned'},{name='b',type='scalar'}}\n"
"---\n"
"...\n"
"tarantool> s = box.schema.create_space('test', {format = format1})\n"
"---\n"
"...\n"
"tarantool> s:frommap({b = 'x', a = 123456})\n"
"---\n"
"- [123456, 'x']\n"
"...\n"
"tarantool> s:frommap({b = 'x', a = 123456}, {table = true})\n"
"---\n"
"- - 123456\n"
"  - x\n"
"..."

#: ../doc/book/box/box_space.rst:961
msgid "Search for a tuple in the given space."
msgstr "Поиск кортежа в данном спейсе."

#: ../doc/book/box/box_space.rst:965 ../doc/book/box/box_space.rst:1400
msgid "value to be matched against the index key, which may be multi-part."
msgstr "значение должно совпасть с индексным ключом, который может быть составным."

#: ../doc/book/box/box_space.rst:968
msgid "the tuple whose index key matches ``key``, or ``nil``."
msgstr "кортеж, ключ индекса в котором совпадает с ``key`` или ``nil``."

#: ../doc/book/box/box_space.rst:976
msgid ""
"The ``box.space...select`` function returns a set of tuples as a Lua "
"table; the ``box.space...get`` function returns at most a single tuple. "
"And it is possible to get the first tuple in a space by appending "
"``[1]``. Therefore ``box.space.tester:get{1}`` has the same effect as "
"``box.space.tester:select{1}[1]``, if exactly one tuple is found."
msgstr ""
"Функция ``box.space...select`` вернет набор кортежей в виде Lua-таблицы; "
"функция ``box.space...get`` вернет самое большее один кортеж. Можно "
"получить первый кортеж в спейсе, добавив ``[1]``. Таким образом, "
"``box.space.tester:get{1}`` эквивалентна "
"``box.space.tester:select{1}[1]``, если найден только один кортеж."

#: ../doc/book/box/box_space.rst:984
msgid "box.space.tester:get{1}"
msgstr "box.space.tester:get{1}"

#: ../doc/book/box/box_space.rst:988
msgid ""
"**Using field names instead of field numbers:** `get()` can use field "
"names described by the optional :ref:`space_object:format() <box_space-"
"format>` clause. This is true because the object returned by ``get()`` "
"can be used with most of the features described in the :ref:`Submodule "
"box.tuple <box_tuple>` description, including :ref:`tuple_object[field-"
"name] <box_tuple-field_name>`."
msgstr ""

#: ../doc/book/box/box_space.rst:994
msgid ""
"For example, we can format the `tester` space with a field named `x` and "
"use the name `x` in the index definition:"
msgstr ""

#: ../doc/book/box/box_space.rst:997
msgid ""
"box.space.tester:format({{name='x',type='scalar'}})\n"
"box.space.tester:create_index('I',{parts={'x'}})"
msgstr ""
"box.space.tester:format({{name='x',type='scalar'}})\n"
"box.space.tester:create_index('I',{parts={'x'}})"

#: ../doc/book/box/box_space.rst:1002
#, fuzzy
msgid ""
"Then, if ``get`` or ``select`` retrieves a single tuple, we can reference"
" the field 'x' in the tuple by its name:"
msgstr ""
"Тогда если ``get`` или ``select`` вернут отдельный кортеж, можно "
"сослаться на поле 'x' в кортеже по имени:"

#: ../doc/book/box/box_space.rst:1005
msgid ""
"box.space.tester:get{1}['x']\n"
"box.space.tester:select{1}[1]['x']"
msgstr ""
"box.space.tester:get{1}['x']\n"
"box.space.tester:select{1}[1]['x']"

#: ../doc/book/box/box_space.rst:1014
msgid "Insert a tuple into a space."
msgstr "Вставка кортежа в спейс."

#: ../doc/book/box/box_space.rst:1018
msgid "tuple to be inserted."
msgstr "вставляемый кортеж."

#: ../doc/book/box/box_space.rst:1020
msgid "the inserted tuple"
msgstr "вставленный кортеж"

#: ../doc/book/box/box_space.rst:1023
msgid ""
"**Possible errors:** :errcode:`ER_TUPLE_FOUND` if a tuple with the same "
"unique-key value already exists."
msgstr ""
"**Возможные ошибки:** ошибка :errcode:`ER_TUPLE_FOUND`, если уже "
"существует кортеж с тем же уникальным значением ключа."

#: ../doc/book/box/box_space.rst:1028
msgid ""
"tarantool> box.space.tester:insert{5000,'tuple number five thousand'}\n"
"---\n"
"- [5000, 'tuple number five thousand']\n"
"..."
msgstr ""
"tarantool> box.space.tester:insert{5000,'tuple number five thousand'}\n"
"---\n"
"- [5000, 'tuple number five thousand']\n"
"..."

#: ../doc/book/box/box_space.rst:1043
msgid ""
"Return the number of tuples in the space. If compared with :ref:`count() "
"<box_space-count>`, this method works faster because ``len()`` does not "
"scan the entire space to count the tuples."
msgstr ""
"Возврат количества кортежей в спейсе. Если сравнивать с :ref:`count() "
"<box_space-count>`, то данный метод работает быстрее, поскольку метод "
"``len()`` не сканирует весь спейс для подсчета кортежей."

#: ../doc/book/box/box_space.rst:1051
msgid "Number of tuples in the space."
msgstr "Количество кортежей в спейсе."

#: ../doc/book/box/box_space.rst:1055
msgid ""
"tarantool> box.space.tester:len()\n"
"---\n"
"- 2\n"
"..."
msgstr ""
"tarantool> box.space.tester:len()\n"
"---\n"
"- 2\n"
"..."

#: ../doc/book/box/box_space.rst:1062
msgid ""
"**Note re storage engine:** vinyl supports ``len()`` but the result may "
"be approximate. If an exact result is necessary then use :ref:`count() "
"<box_space-count>` or :ref:`pairs():length() <box_space-pairs>`."
msgstr ""
"**Примечание про движок базы данных:** vinyl поддерживает ``len()``, но "
"результат может быть неточным. Если необходим точный результат, "
"используйте :ref:`count() <box_space-count>` или :ref:`pairs():length() "
"<box_space-pairs>`."

#: ../doc/book/box/box_space.rst:1070 ../doc/book/box/box_space.rst:1155
msgid ""
"Create a \"replace :ref:`trigger <triggers>`\". The ``trigger-function`` "
"will be executed whenever a ``replace()`` or ``insert()`` or ``update()``"
" or ``upsert()`` or ``delete()`` happens to a tuple in ``<space-name>``."
msgstr ""
"Создание \":ref:`триггера <triggers>` замены\". Функция с триггером "
"``trigger-function`` будет выполняться в случае операции ``replace()`` "
"или ``insert()``, или ``update()``, или ``upsert()``, или ``delete()`` "
"над кортежем в спейсе ``<space-name>``."

#: ../doc/book/box/box_space.rst:1075
msgid ""
"function which will become the trigger function; see Example #2 below for"
" details about trigger function parameters"
msgstr ""
"функция, в которой будет триггер; для получения информации о параметрах "
"функции с триггером см. Пример №2 ниже"

#: ../doc/book/box/box_space.rst:1079 ../doc/book/box/box_space.rst:1165
msgid "existing trigger function which will be replaced by ``trigger-function``"
msgstr ""
"существующая функция с триггером, которую заменит новая ``trigger-"
"function``"

#: ../doc/book/box/box_space.rst:1090 ../doc/book/box/box_space.rst:1175
msgid ""
"If it is necessary to know whether the trigger activation happened due to"
" replication or on a specific connection type, the function can refer to "
":ref:`box.session.type() <box_session-type>`."
msgstr ""
"Следует знать, что если активация триггера произошла в случае репликации "
"или определенного вида подключения, функция может ссылаться на "
":ref:`box.session.type() <box_session-type>`."

#: ../doc/book/box/box_space.rst:1097
msgid "See also :ref:`space_object:before_replace() <box_space-before_replace>`."
msgstr "См. также :ref:`space_object:before_replace() <box_space-before_replace>`."

#: ../doc/book/box/box_space.rst:1099 ../doc/book/box/box_space.rst:2168
msgid "**Example #1:**"
msgstr "**Пример №1:**"

#: ../doc/book/box/box_space.rst:1101
msgid ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.space.X:on_replace(f)"
msgstr ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.space.X:on_replace(f)"

#: ../doc/book/box/box_space.rst:1108 ../doc/book/box/box_space.rst:2213
msgid "**Example #2:**"
msgstr "**Пример №2:**"

#: ../doc/book/box/box_space.rst:1110
msgid "The ``trigger-function`` can have up to four parameters:"
msgstr "В функции с триггером может быть до 4 параметров:"

#: ../doc/book/box/box_space.rst:1112
msgid "(tuple) old value which has the contents before the request started,"
msgstr "(кортеж) старое значение до начала запроса,"

#: ../doc/book/box/box_space.rst:1113
msgid "(tuple) new value which has the contents after the request ended,"
msgstr "(кортеж) новое значение после окончания выполнения запроса,"

#: ../doc/book/box/box_space.rst:1114
msgid "(string) space name,"
msgstr "(строка) имя спейса,"

#: ../doc/book/box/box_space.rst:1115
msgid ""
"(string) type of request which is 'INSERT', 'DELETE', 'UPDATE', or "
"'REPLACE'."
msgstr ""
"(строка) тип запроса: 'INSERT' (вставка), 'DELETE' (удаление), 'UPDATE' "
"(обновление) или 'REPLACE' (замена)."

#: ../doc/book/box/box_space.rst:1117
msgid ""
"For example, the following code causes nil and 'INSERT' to be printed "
"when the insert request is processed, and causes [1, 'Hi'] and 'DELETE' "
"to be printed when the delete request is processed:"
msgstr ""
"Например, следующий код вызывает вывод nil и 'INSERT' (вставка) при "
"обработке запроса на вставку и вывод [1, 'Hi'] и 'DELETE' (удаление) при "
"обработке запроса на удаление:"

#: ../doc/book/box/box_space.rst:1121
msgid ""
"box.schema.space.create('space_1')\n"
"box.space.space_1:create_index('space_1_index',{})\n"
"function on_replace_function (old, new, s, op) print(old) print(op) end\n"
"box.space.space_1:on_replace(on_replace_function)\n"
"box.space.space_1:insert{1,'Hi'}\n"
"box.space.space_1:delete{1}"
msgstr ""
"box.schema.space.create('space_1')\n"
"box.space.space_1:create_index('space_1_index',{})\n"
"function on_replace_function (old, new, s, op) print(old) print(op) end\n"
"box.space.space_1:on_replace(on_replace_function)\n"
"box.space.space_1:insert{1,'Hi'}\n"
"box.space.space_1:delete{1}"

#: ../doc/book/box/box_space.rst:1130
msgid "**Example #3:**"
msgstr "**Пример №3:**"

#: ../doc/book/box/box_space.rst:1132
msgid ""
"The following series of requests will create a space, create an index, "
"create a function which increments a counter, create a trigger, do two "
"inserts, drop the space, and display the counter value - which is 2, "
"because the function is executed once after each insert."
msgstr ""
"Следующая серия запросов создаст спейс, создаст индекс, создаст функцию, "
"которая увеличит содержимое счетчика, создаст триггер, сделает две "
"вставки, удалит спейс и отобразит значение счетчика -- 2, поскольку "
"функция выполняется однократно после каждой вставки."

#: ../doc/book/box/box_space.rst:1137
msgid ""
"tarantool> s = box.schema.space.create('space53')\n"
"tarantool> s:create_index('primary', {parts = {{field = 1, type = "
"'unsigned'}}})\n"
"tarantool> function replace_trigger()\n"
"         >   replace_counter = replace_counter + 1\n"
"         > end\n"
"tarantool> s:on_replace(replace_trigger)\n"
"tarantool> replace_counter = 0\n"
"tarantool> t = s:insert{1, 'First replace'}\n"
"tarantool> t = s:insert{2, 'Second replace'}\n"
"tarantool> s:drop()\n"
"tarantool> replace_counter"
msgstr ""

#: ../doc/book/box/box_space.rst:1160
msgid ""
"function which will become the trigger function; for the trigger "
"function's optional parameters see the description of :ref:`on_replace "
"<box_space-on_replace>`."
msgstr ""
"функция, в которой будет триггер; необязательные параметры функции с "
"триггером см. в описании :ref:`on_replace <box_space-on_replace>`."

#: ../doc/book/box/box_space.rst:1170
#: ../doc/book/box/box_txn_management.rst:207
msgid ""
"If the parameters are ``(nil, old-trigger-function)``, then the old "
"trigger is deleted."
msgstr ""
"Если указаны параметры ``(nil, old-trigger-function)``, старый триггер "
"будет удален."

#: ../doc/book/box/box_space.rst:1182
msgid "See also :ref:`space_object:on_replace() <box_space-on_replace>`."
msgstr "См. также :ref:`space_object:on_replace() <box_space-on_replace>`."

#: ../doc/book/box/box_space.rst:1184
msgid ""
"Administrators can make replace triggers with ``on_replace()``, or make "
"triggers with ``before_replace()``. If they make both types, then all "
"``before_replace`` triggers are executed before all ``on_replace`` "
"triggers. The functions for both ``on_replace`` and ``before_replace`` "
"triggers can make changes to the database, but only the functions for "
"``before_replace`` triggers can change the tuple that is being replaced."
msgstr ""
"Администраторы могут создавать триггеры замены с условием после замены "
"``on_replace()`` или до замены ``before_replace()``. Если созданы оба "
"типа, то все триггеры до замены ``before_replace`` выполняются до всех "
"триггеров после замены ``on_replace``. Функции для обоих типов триггеров "
"``on_replace`` и ``before_replace`` могут вносить изменения в базу "
"данных, но только функции с триггерами до замены ``before_replace`` могут"
" изменять кортеж, который будет заменен."

#: ../doc/book/box/box_space.rst:1193
msgid ""
"Since a ``before_replace`` trigger function has the extra capability of "
"making a change to the old tuple, it also can have extra overhead, to "
"fetch the old tuple before making the change. Therefore an ``on_replace``"
" trigger is better if there is no need to change the old tuple. However, "
"this only applies for the memtx engine -- for the vinyl engine, the fetch"
" will happen for either kind of trigger. (With memtx the tuple data is "
"stored along with the index key so no extra search is necessary; with "
"vinyl that is not the case so the extra search is necessary.)"
msgstr ""
"Поскольку функция с триггером до замены ``before_replace`` может вносить "
"дополнительные изменения в старый кортеж, для нее также потребуются "
"дополнительные ресурсы для вызова старого кортежа до внесения изменений. "
"Таким образом, лучше использовать триггер после замены ``on_replace``, "
"если нет необходимости изменять старый кортеж. Тем не менее, это "
"применимо только к движку memtx -- что касается движка vinyl, такой вызов"
" произойдет для любого типа триггера. (В memtx'е данные кортежа хранятся "
"вместе с ключом индекса, поэтому нет необходимости в дополнительном "
"поиске; для vinyl'а дело обстоит иначе, поэтому нужен дополнительный "
"поиск.)"

#: ../doc/book/box/box_space.rst:1205
msgid ""
"Where the extra capability is not needed, ``on_replace`` should be used "
"instead of ``before_replace``. Usually ``before_replace`` is used only "
"for certain replication scenarios -- it is useful for conflict "
"resolution."
msgstr ""
"Если нет необходимости в дополнительных изменениях, следует использовать "
"``on_replace`` вместо ``before_replace``. Как правило, ``before_replace``"
" используется только для определенных сценариев репликации -- в части "
"разрешения конфликтов."

#: ../doc/book/box/box_space.rst:1210
msgid ""
"The value that a ``before_replace`` trigger function can return affects "
"what will happen after the return. Specifically:"
msgstr ""
"Что случится после возврата значения, которое может вернуть функция с "
"триггером ``before_replace``, зависит от этого значения. А именно:"

#: ../doc/book/box/box_space.rst:1213
msgid ""
"if there is no return value, then execution proceeds, inserting|replacing"
" the new value;"
msgstr ""
"если нет возвращаемого значения, выполнение продолжается со "
"вставкой|заменой нового значения;"

#: ../doc/book/box/box_space.rst:1215
msgid "if the value is nil, then the tuple will be deleted;"
msgstr "если значение -- nil, то кортеж будет удален;"

#: ../doc/book/box/box_space.rst:1216
msgid ""
"if the value is the same as the old parameter, then no `on_replace`` "
"function will be called and the data change will be skipped"
msgstr ""
"если значение совпадает со старым, то вызывается функция ``on_replace``, "
"и изменение данных не происходит"

#: ../doc/book/box/box_space.rst:1219
msgid ""
"if the value is the same as the new parameter, then it's as if the "
"``before_replace`` function wasn't called;"
msgstr ""
"если значение совпадает с новым, то считаем, что вызова функции "
"``before_replace`` не было;"

#: ../doc/book/box/box_space.rst:1221
msgid ""
"if the value is something else, then execution proceeds, "
"inserting|replacing the new value."
msgstr ""
"если значение другое, выполнение продолжается со вставкой|заменой нового "
"значения."

#: ../doc/book/box/box_space.rst:1224
msgid ""
"However, if a trigger function returns an old tuple, or if a trigger "
"function calls :ref:`run_triggers(false) <box_space-run_triggers>`, that "
"will not affect other triggers that are activated for the same "
"insert|update|replace request."
msgstr ""
"Тем не менее, если функция с триггером возвращает старый кортеж или "
"вызывает :ref:`run_triggers(false) <box_space-run_triggers>`, это не "
"повлияет на другие триггеры, активируемые в том же запросе вставки, "
"обновления или замены."

#: ../doc/book/box/box_space.rst:1231
msgid ""
"The following are ``before_replace`` functions that have no return value,"
" or that return nil, or the same as the old parameter, or the same as the"
" new parameter, or something else."
msgstr ""
"Далее представлены функции ``before_replace``: не возвращает значение, "
"возвращает nil, возвращает совпадающее со старым значение, возвращает "
"совпадающее с новым значение, возвращает другое значение."

#: ../doc/book/box/box_space.rst:1235
msgid ""
"function f1 (old, new) return end\n"
"function f2 (old, new) return nil end\n"
"function f3 (old, new) return old end\n"
"function f4 (old, new) return new end\n"
"function f5 (old, new) return box.tuple.new({new[1],'b'}) end"
msgstr ""
"function f1 (old, new) return end\n"
"function f2 (old, new) return nil end\n"
"function f3 (old, new) return old end\n"
"function f4 (old, new) return new end\n"
"function f5 (old, new) return box.tuple.new({new[1],'b'}) end"

#: ../doc/book/box/box_space.rst:1247
msgid ""
"Search for a tuple or a set of tuples in the given space, and allow "
"iterating over one tuple at a time."
msgstr ""
"Поиск кортежа или набора кортежей в заданном спейсе и итерация по одному "
"кортежу за раз."

#: ../doc/book/box/box_space.rst:1254
msgid "see :ref:`index_object:pairs <box_index-index_pairs>`"
msgstr "см. :ref:`index_object:pairs <box_index-index_pairs>`"

#: ../doc/book/box/box_space.rst:1263 ../doc/book/box/box_space.rst:1422
msgid "no such space;"
msgstr "отсутствие такого спейса."

#: ../doc/book/box/box_space.rst:1264 ../doc/book/box/box_space.rst:1423
msgid "wrong type."
msgstr "неправильный тип."

#: ../doc/book/box/box_space.rst:1268
msgid ""
"For examples of complex ``pairs`` requests, where one can specify which "
"index to search and what condition to use (for example \"greater than\" "
"instead of \"equal to\"), see the later section :ref:`index_object:pairs "
"<box_index-index_pairs>`."
msgstr ""
"Чтобы посмотреть примеры сложных запросов ``pairs``, где можно указать "
"индекс для поиска и используемое условие (например, \"больше чем\" вместо"
" \"равен\"), см. раздел далее по тексту :ref:`index_object:pairs "
"<box_index-index_pairs>`."

#: ../doc/book/box/box_space.rst:1279
msgid ""
"tarantool> s = box.schema.space.create('space33')\n"
"---\n"
"...\n"
"tarantool> -- index 'X' has default parts {1, 'unsigned'}\n"
"tarantool> s:create_index('X', {})\n"
"---\n"
"...\n"
"tarantool> s:insert{0, 'Hello my '}, s:insert{1, 'Lua world'}\n"
"---\n"
"- [0, 'Hello my ']\n"
"- [1, 'Lua world']\n"
"...\n"
"tarantool> tmp = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in s:pairs() do\n"
"         >   tmp = tmp .. v[2]\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> tmp\n"
"---\n"
"- Hello my Lua world\n"
"..."
msgstr ""
"tarantool> s = box.schema.space.create('space33')\n"
"---\n"
"...\n"
"tarantool> -- в индексе 'X' количество частей по умолчанию {1, "
"'unsigned'}\n"
"tarantool> s:create_index('X', {})\n"
"---\n"
"...\n"
"tarantool> s:insert{0, 'Hello my '}, s:insert{1, 'Lua world'}\n"
"---\n"
"- [0, 'Hello my ']\n"
"- [1, 'Lua world']\n"
"...\n"
"tarantool> tmp = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in s:pairs() do\n"
"         >   tmp = tmp .. v[2]\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> tmp\n"
"---\n"
"- Hello my Lua world\n"
"..."

#: ../doc/book/box/box_space.rst:1310
msgid "Rename a space."
msgstr "Переименование спейса."

#: ../doc/book/box/box_space.rst:1314
msgid "new name for space"
msgstr "новое имя спейса"

#: ../doc/book/box/box_space.rst:1322
msgid ""
"tarantool> box.space.space55:rename('space56')\n"
"---\n"
"...\n"
"tarantool> box.space.space56:rename('space55')\n"
"---\n"
"..."
msgstr ""
"tarantool> box.space.space55:rename('space56')\n"
"---\n"
"...\n"
"tarantool> box.space.space56:rename('space55')\n"
"---\n"
"..."

#: ../doc/book/box/box_space.rst:1336
msgid ""
"Insert a tuple into a space. If a tuple with the same primary key already"
" exists, ``box.space...:replace()`` replaces the existing tuple with a "
"new one. The syntax variants ``box.space...:replace()`` and "
"``box.space...:put()`` have the same effect; the latter is sometimes used"
" to show that the effect is the converse of ``box.space...:get()``."
msgstr ""
"Вставка кортежа в спейс. Если уже существует кортеж с тем же первичным "
"ключом, ``box.space...:replace()`` заменит существующий кортеж новым. "
"Варианты синтаксиса (``box.space...:replace()`` и ``box.space...:put()``)"
" приведут к одному результату, но последний иногда используется как "
"противоположность ``box.space...:get()``."

#: ../doc/book/box/box_space.rst:1344
msgid "tuple to be inserted"
msgstr "вставляемый кортеж"

#: ../doc/book/box/box_space.rst:1349
msgid ""
"**Possible errors:** :errcode:`ER_TUPLE_FOUND` if a different tuple with "
"the same unique-key value already exists. (This will only happen if there"
" is a unique secondary index.)"
msgstr ""
"**Возможные ошибки:** ошибка :errcode:`ER_TUPLE_FOUND`, если уже "
"существует другой кортеж с тем же уникальным значением ключа (это "
"произойдет только в том случае, если есть уникальный вторичный индекс)."

#: ../doc/book/box/box_space.rst:1358
msgid "box.space.tester:replace{5000, 'tuple number five thousand'}"
msgstr "box.space.tester:replace{5000, 'tuple number five thousand'}"

#: ../doc/book/box/box_space.rst:1370
msgid ""
"At the time that a :ref:`trigger <triggers>` is defined, it is "
"automatically enabled - that is, it will be executed. :ref:`Replace "
"<box_space-on_replace>` triggers can be disabled with :samp:`box.space"
".{space-name}:run_triggers(false)` and re-enabled with :samp:`box.space"
".{space-name}:run_triggers(true)`."
msgstr ""
"На тот момент, когда :ref:`триггер <triggers>` определен, он "
"автоматически активируется, то есть он будет исполняться. Триггеры "
":ref:`для замены <box_space-on_replace>` можно отключить с помощью "
":samp:`box.space.{имя-спейса}:run_triggers(false)` и повторно "
"активировать с помощью :samp:`box.space.{имя-спейса}:run_triggers(true)`."

#: ../doc/book/box/box_space.rst:1379
msgid ""
"The following series of requests will associate an existing function "
"named `F` with an existing space named `T`, associate the function a "
"second time with the same space (so it will be called twice), disable all"
" triggers of `T`, and delete each trigger by replacing with ``nil``."
msgstr ""
"Следующая серия запросов ассоциирует существующую функцию с именем `F` с "
"существующим спейсом с именем `T`, ассоциирует функцию во второй раз с "
"тем же спейсом (чтобы вызвать ее дважды), отключит все триггеры на `T` и "
"удалит каждый триггер, заменив его на ``nil``."

#: ../doc/book/box/box_space.rst:1384
msgid ""
"tarantool> box.space.T:on_replace(F)\n"
"tarantool> box.space.T:on_replace(F)\n"
"tarantool> box.space.T:run_triggers(false)\n"
"tarantool> box.space.T:on_replace(nil, F)\n"
"tarantool> box.space.T:on_replace(nil, F)"
msgstr ""
"tarantool> box.space.T:on_replace(F)\n"
"tarantool> box.space.T:on_replace(F)\n"
"tarantool> box.space.T:run_triggers(false)\n"
"tarantool> box.space.T:on_replace(nil, F)\n"
"tarantool> box.space.T:on_replace(nil, F)"

#: ../doc/book/box/box_space.rst:1396
msgid "Search for a tuple or a set of tuples in the given space."
msgstr "Поиск кортежа или набора кортежей в заданном спейсе."

#: ../doc/book/box/box_space.rst:1402
msgid ""
"none, any or all of the same options that :ref:`index_object:select "
"<box_index-select>` allows:  * ``options.iterator`` (:ref:`type of "
"iterator <box_index-iterator-types>`) * ``options.limit`` (maximum number"
" of tuples) * ``options.offset`` (number of tuples to skip)"
msgstr ""
"ни один, любой или все параметры, которые допускает "
":ref:`index_object:select <box_index-select>`:  * ``options.iterator`` "
"(:ref:`тип итератора <box_index-iterator-types>`) * ``options.limit`` "
"(максимальное количество кортежей) * ``options.offset`` (количество "
"пропускаемых кортежей)"

#: ../doc/book/box/box_space.rst:1402
msgid ""
"none, any or all of the same options that :ref:`index_object:select "
"<box_index-select>` allows:"
msgstr ""
"ни один, любой или все параметры, которые допускает "
":ref:`index_object:select <box_index-select>`:"

#: ../doc/book/box/box_space.rst:1406
msgid "``options.iterator`` (:ref:`type of iterator <box_index-iterator-types>`)"
msgstr "``options.iterator`` (:ref:`тип итератора <box_index-iterator-types>`)"

#: ../doc/book/box/box_space.rst:1407
msgid "``options.limit`` (maximum number of tuples)"
msgstr "``options.limit`` (максимальное количество кортежей)"

#: ../doc/book/box/box_space.rst:1408
msgid "``options.offset`` (number of tuples to skip)"
msgstr "``options.offset`` (количество пропускаемых кортежей)"

#: ../doc/book/box/box_space.rst:1410
msgid ""
"the tuples whose primary-key fields are equal to the fields of the passed"
" key. If the number of passed fields is less than the number of fields in"
" the primary key, then only the passed fields are compared, so "
"``select{1,2}`` will match a tuple whose primary key is ``{1,2,3}``."
msgstr ""
"кортежи, поля первичного ключа в которых равны полям переданного ключа. "
"Если количество переданных полей меньшей количества полей первичного "
"ключа, сопоставляются только переданные поля, то есть для ``select{1,2}``"
" совпадением будет кортеж с первичным ключом ``{1,2,3}``."

#: ../doc/book/box/box_space.rst:1417
msgid ""
"A ``select`` request can also be done with a specific index and index "
"options, which are the subject of :ref:`index_object:select <box_index-"
"select>`."
msgstr ""
"Запрос выборки ``select`` также можно выполнить со специальными "
"параметрами индекса, которые указаны в :ref:`index_object:select "
"<box_index-select>`."

#: ../doc/book/box/box_space.rst:1429
#, fuzzy
msgid ""
"tarantool> s = box.schema.space.create('tmp', {temporary=true})\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary',{parts = {{field = 1, type = "
"'unsigned'}, {field = 2, type = 'string'}}})\n"
"---\n"
"...\n"
"tarantool> s:insert{1,'A'}\n"
"---\n"
"- [1, 'A']\n"
"...\n"
"tarantool> s:insert{1,'B'}\n"
"---\n"
"- [1, 'B']\n"
"...\n"
"tarantool> s:insert{1,'C'}\n"
"---\n"
"- [1, 'C']\n"
"...\n"
"tarantool> s:insert{2,'D'}\n"
"---\n"
"- [2, 'D']\n"
"...\n"
"tarantool> -- must equal both primary-key fields\n"
"tarantool> s:select{1,'B'}\n"
"---\n"
"- - [1, 'B']\n"
"...\n"
"tarantool> -- must equal only one primary-key field\n"
"tarantool> s:select{1}\n"
"---\n"
"- - [1, 'A']\n"
"  - [1, 'B']\n"
"  - [1, 'C']\n"
"...\n"
"tarantool> -- must equal 0 fields, so returns all tuples\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 'A']\n"
"  - [1, 'B']\n"
"  - [1, 'C']\n"
"  - [2, 'D']\n"
"...\n"
"tarantool> -- the first field must be greater than 0, and\n"
"tarantool> -- skip the first tuple, and return up to\n"
"tarantool> -- 2 tuples. This example's options all\n"
"tarantool> -- depend on index characteristics so see\n"
"tarantool> -- more explanation in index_object:select().\n"
"tarantool> s:select({0},{iterator='GT',offset=1,limit=2})\n"
"---\n"
"- - [1, 'B']\n"
"  - [1, 'C']\n"
"..."
msgstr ""
"tarantool> s = box.schema.space.create('tmp', {temporary=true})\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary',{parts = {1,'unsigned', 2, "
"'string'}})\n"
"---\n"
"...\n"
"tarantool> s:insert{1,'A'}\n"
"---\n"
"- [1, 'A']\n"
"...\n"
"tarantool> s:insert{1,'B'}\n"
"---\n"
"- [1, 'B']\n"
"...\n"
"tarantool> s:insert{1,'C'}\n"
"---\n"
"- [1, 'C']\n"
"...\n"
"tarantool> s:insert{2,'D'}\n"
"---\n"
"- [2, 'D']\n"
"...\n"
"tarantool> -- необходимо совпадение с двумя полями первичного ключа\n"
"tarantool> s:select{1,'B'}\n"
"---\n"
"- - [1, 'B']\n"
"...\n"
"tarantool> -- необходимо совпадение только одного поля первичного ключа\n"
"tarantool> s:select{1}\n"
"---\n"
"- - [1, 'A']\n"
"  - [1, 'B']\n"
"  - [1, 'C']\n"
"...\n"
"tarantool> -- необходимо совпадение с 0 полей, поэтому возвращает все "
"кортежи\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 'A']\n"
"  - [1, 'B']\n"
"  - [1, 'C']\n"
"  - [2, 'D']\n"
"...\n"
"tarantool> -- первое поле должно быть больше 0,\n"
"tarantool> -- пропуск первого кортежа и возврат до\n"
"tarantool> -- 2 кортежей. Все параметры в данном примере\n"
"tarantool> -- зависят от характеристик индекса, поэтому см.\n"
"tarantool> -- более подробное описание в index_object:select().\n"
"tarantool> s:select({0},{iterator='GT',offset=1,limit=2})\n"
"---\n"
"- - [1, 'B']\n"
"  - [1, 'C']\n"
"..."

#: ../doc/book/box/box_space.rst:1484
msgid ""
"As the last request in the above example shows: to make complex "
"``select`` requests, where you can specify which index to search and what"
" condition to use (for example \"greater than\" instead of \"equal to\") "
"and how many tuples to return, it will be necessary to become familiar "
"with :ref:`index_object:select <box_index-select>`."
msgstr ""
"Как показано в последнем запросе вышеприведенного примера, чтобы "
"выполнять сложные запросы выборки ``select``, где можно указать, в каком "
"индексе производится поиск и с какими условиями (например, \"больше, "
"чем\" вместо \"равный\"), а также необходимое количество возвращаемых "
"кортежей, необходимо ознакомиться с :ref:`index_object:select <box_index-"
"select>`."

#: ../doc/book/box/box_space.rst:1498
msgid "Deletes all tuples."
msgstr "Удаление всех кортежей."

#: ../doc/book/box/box_space.rst:1507
msgid ""
"The ``truncate`` method can only be called by the user who created the "
"space, or from within a ``setuid`` function created by the user who "
"created the space. Read more about `setuid` functions in the reference "
"for :ref:`box.schema.func.create() <box_schema-func_create>`."
msgstr ""
"Метод ``truncate`` может вызвать только тот пользователь, который создал "
"спейс, или другой пользователь через функцию ``setuid``, созданную "
"пользователем, который создал спейс. Более подробную информацию о "
"функциях `setuid` можно получить в справочнике по for "
":ref:`box.schema.func.create() <box_schema-func_create>`."

#: ../doc/book/box/box_space.rst:1513
msgid "The ``truncate`` method cannot be called from within a transaction."
msgstr "Метод ``truncate`` нельзя вызвать из транзакции."

#: ../doc/book/box/box_space.rst:1517
msgid ""
"tarantool> box.space.tester:truncate()\n"
"---\n"
"...\n"
"tarantool> box.space.tester:len()\n"
"---\n"
"- 0\n"
"..."
msgstr ""
"tarantool> box.space.tester:truncate()\n"
"---\n"
"...\n"
"tarantool> box.space.tester:len()\n"
"---\n"
"- 0\n"
"..."

#: ../doc/book/box/box_space.rst:1533
msgid ""
"The ``update`` function supports operations on fields — assignment, "
"arithmetic (if the field is numeric), cutting and pasting fragments of a "
"field, deleting or inserting a field. Multiple operations can be combined"
" in a single update request, and in this case they are performed "
"atomically and sequentially. Each operation requires specification of a "
"field number. When multiple operations are present, the field number for "
"each operation is assumed to be relative to the most recent state of the "
"tuple, that is, as if all previous operations in a multi-operation update"
" have already been applied. In other words, it is always safe to merge "
"multiple ``update`` invocations into a single invocation, with no change "
"in semantics."
msgstr ""
"Функция ``update`` поддерживает операции над полями -- присваивание, "
"арифметические операции (если поле числовое), вырезание и вставку "
"фрагментов поля, удаление или вставку поля. Несколько операций можно "
"объединить в отдельный запрос обновления, и в таком случае они будут "
"выполняться атомарно и последовательно. Для каждой операции необходимо "
"указать номер поля. Если выполняются несколько операций, то номер поля "
"для каждой операции считается относительно последнего состояния кортежа, "
"то есть как если бы все предыдущие операции в обновлении с несколькими "
"операциями уже были выполнены. Другими словами, всегда лучше объединить "
"несколько вызовов  ``update`` в один без изменений семантики."

#: ../doc/book/box/box_space.rst:1545
msgid "Possible operators are:"
msgstr "Возможные операторы:"

#: ../doc/book/box/box_space.rst:1547
msgid "``+`` for addition (values must be numeric)"
msgstr "``+`` для сложения (значения должны быть числовыми)"

#: ../doc/book/box/box_space.rst:1548
msgid "``-`` for subtraction (values must be numeric)"
msgstr "``-`` для вычитания (значения должны быть числовыми)"

#: ../doc/book/box/box_space.rst:1549
msgid "``&`` for bitwise AND (values must be unsigned numeric)"
msgstr ""
"``&`` для поразрядной операции И (значения должны быть беззнаковыми "
"числами)"

#: ../doc/book/box/box_space.rst:1550
msgid "``|`` for bitwise OR (values must be unsigned numeric)"
msgstr ""
"``|`` для поразрядной операции ИЛИ (значения должны быть беззнаковыми "
"числами)"

#: ../doc/book/box/box_space.rst:1551
msgid ""
"``^`` for bitwise :abbr:`XOR(exclusive OR)` (values must be unsigned "
"numeric)"
msgstr ""
"``^`` для поразрядной операции Исключающее ИЛИ (значения должны быть "
"беззнаковыми числами)"

#: ../doc/book/box/box_space.rst:1553
msgid "``:`` for string splice"
msgstr "``:`` для разделения строк"

#: ../doc/book/box/box_space.rst:1554
msgid "``!`` for insertion"
msgstr "``!`` для вставки"

#: ../doc/book/box/box_space.rst:1555
msgid "``#`` for deletion"
msgstr "``#`` для удаления"

#: ../doc/book/box/box_space.rst:1556
msgid "``=`` for assignment"
msgstr "``=`` для присваивания"

#: ../doc/book/box/box_space.rst:1558
msgid ""
"For ``!`` and ``=`` operations the field number can be ``-1``, meaning "
"the last field in the tuple."
msgstr ""
"Для операций ``!`` и ``=`` номер поля может быть ``-1``, что означает "
"последнее поле в кортеже."

#: ../doc/book/box/box_space.rst:1575
msgid "**Possible errors:** it is illegal to modify a primary-key field."
msgstr "**Возможные ошибки:** нельзя изменять поле первичного ключа."

#: ../doc/book/box/box_space.rst:1577 ../doc/book/box/box_space.rst:1701
msgid ""
"**Complexity factors:** Index size, Index type, number of indexes "
"accessed, WAL settings."
msgstr ""
"**Факторы сложности** Размер индекса, тип индекса, количество кортежей, к"
" которым получен доступ, настройки журнала упреждающей записи (WAL)."

#: ../doc/book/box/box_space.rst:1580
msgid "Thus, in the instruction:"
msgstr "Таким образом, в инструкции:"

#: ../doc/book/box/box_space.rst:1582
msgid "s:update(44, {{'+', 1, 55 }, {'=', 3, 'x'}})"
msgstr "s:update(44, {{'+', 1, 55 }, {'=', 3, 'x'}})"

#: ../doc/book/box/box_space.rst:1586
msgid ""
"the primary-key value is ``44``, the operators are ``'+'`` and ``'='`` "
"meaning *add a value to a field and then assign a value to a field*, the "
"first affected field is field ``1`` and the value which will be added to "
"it is ``55``, the second affected field is field ``3`` and the value "
"which will be assigned to it is ``'x'``."
msgstr ""
"значение первичного ключа равно ``44``, заданы операторы ``'+'`` и "
"``'='``, что означает *прибавление значение к полю, а затем присваивание "
"значения полю*, первое затронутое поле -- это поле ``1``, к нему "
"прибавляется значение ``55``, второе затронутое поле -- это поле ``3``, "
"ему присваивается значение ``'x'``."

#: ../doc/book/box/box_space.rst:1594
msgid ""
"Assume that initially there is a space named ``tester`` with a primary-"
"key index whose type is ``unsigned``. There is one tuple, with "
"``field[1]`` = ``999`` and ``field[2]`` = ``'A'``."
msgstr ""
"Предположим, что изначально есть спейс под названием ``tester`` с "
"первичным индексом, тип которого -- ``unsigned``. Есть один кортеж с "
"полем №1 ``field[1]`` = ``999`` и полем №2 ``field[2]`` = ``'A'``."

#: ../doc/book/box/box_space.rst:1598
msgid ""
"In the update: |br| ``box.space.tester:update(999, {{'=', 2, 'B'}})`` "
"|br| The first argument is ``tester``, that is, the affected space is "
"``tester``. The second argument is ``999``, that is, the affected tuple "
"is identified by primary key value = 999. The third argument is ``=``, "
"that is, there is one operation — *assignment to a field*. The fourth "
"argument is ``2``, that is, the affected field is ``field[2]``. The fifth"
" argument is ``'B'``, that is, ``field[2]`` contents change to ``'B'``. "
"Therefore, after this update, ``field[1]`` = ``999`` and ``field[2]`` = "
"``'B'``."
msgstr ""
"В обновлении: |br| ``box.space.tester:update(999, {{'=', 2, 'B'}})`` |br|"
" Первый аргумент -- это ``tester``, то есть обновление происходит в "
"спейсе ``tester``. Второй аргумент -- ``999``, то есть затронутый кортеж "
"определяется по значению первичного ключа = 999. Третий аргумент -- "
"``=``, то есть будет одна операция -- *присваивание полю*. Четвертый "
"аргумент -- ``2``, то есть будет затронуто поле №2 ``field[2]``. Пятый "
"аргумент -- ``'B'``, то есть содержимое ``field[2]`` изменится на "
"``'B'``. Таким образом, после данного обновления ``field[1]`` = ``999``, "
"а ``field[2]`` = ``'B'``."

#: ../doc/book/box/box_space.rst:1609
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'=', 2, 'B'}})`` "
"|br| the arguments are the same, except that the key is passed as a Lua "
"table (inside braces). This is unnecessary when the primary key has only "
"one field, but would be necessary if the primary key had more than one "
"field. Therefore, after this update, ``field[1]`` = ``999`` and "
"``field[2]`` = ``'B'`` (no change)."
msgstr ""
"В обновлении: |br| ``box.space.tester:update({999}, {{'=', 2, 'B'}})`` "
"|br| Аргументы повторяются за исключением того, что ключ передается в "
"виде Lua-таблицы (в фигурных скобках). В этом нет необходимости, если "
"первичный ключ содержит только одно поле, но было бы необходимо, если бы "
"в первичном ключе было больше одного поля. Таким образом, после данного "
"обновления ``field[1]`` = ``999``, а ``field[2]`` = ``'B'`` (без "
"изменений)."

#: ../doc/book/box/box_space.rst:1616
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'=', 3, 1}})`` "
"|br| the arguments are the same, except that the fourth argument is "
"``3``, that is, the affected field is ``field[3]``. It is okay that, "
"until now, ``field[3]`` has not existed. It gets added. Therefore, after "
"this update, ``field[1]`` = ``999``, ``field[2]`` = ``'B'``, ``field[3]``"
" = ``1``."
msgstr ""
"В обновлении: |br| ``box.space.tester:update({999}, {{'=', 3, 1}})`` |br|"
" Аргументы повторяются за исключением того, что четвертым аргументом "
"будет ``3``, то есть будет затронуто поле №3 ``field[3]``. Ничего "
"страшного, что до этого поле ``field[3]`` не существовало. Оно добавится."
" Таким образом, после данного обновления ``field[1]`` = ``999``, "
"``field[2]`` = ``'B'``, ``field[3]`` = ``1``."

#: ../doc/book/box/box_space.rst:1623
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'+', 3, 1}})`` "
"|br| the arguments are the same, except that the third argument is "
"``'+'``, that is, the operation is addition rather than assignment. Since"
" ``field[3]`` previously contained ``1``, this means we're adding ``1`` "
"to ``1``. Therefore, after this update, ``field[1]`` = ``999``, "
"``field[2]`` = ``'B'``, ``field[3]`` = ``2``."
msgstr ""
"В обновлении: |br| ``box.space.tester:update({999}, {{'+', 3, 1}})`` |br|"
" Аргументы повторяются за исключением того, что третьим аргументом будет "
"``'+'``, то есть будет операция добавления, а не присваивания. "
"Поскольку``field[3]`` ранее содержало значение ``1``, это означает, что к"
" ``1`` прибавится ``1``. Таким образом, после данного обновления "
"``field[1]`` = ``999``, ``field[2]`` = ``'B'``, ``field[3]`` = ``2``."

#: ../doc/book/box/box_space.rst:1631
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'|', 3, 1}, {'=', "
"2, 'C'}})`` |br| the idea is to modify two fields at once. The formats "
"are ``'|'`` and ``=``, that is, there are two operations, OR and "
"assignment. The fourth and fifth arguments mean that ``field[3]`` gets "
"OR'ed with ``1``. The seventh and eighth arguments mean that ``field[2]``"
" gets assigned ``'C'``. Therefore, after this update, ``field[1]`` = "
"``999``, ``field[2]`` = ``'C'``, ``field[3]`` = ``3``."
msgstr ""
"В обновлении: |br| ``box.space.tester:update({999}, {{'|', 3, 1}, {'=', "
"2, 'C'}})`` |br| Основная идея состоит в том, чтобы изменить одновременно"
" два поля. Форматами будут ``'|'`` и ``=``, то есть имеем две операции: "
"ИЛИ и присваивание. Четвертый и пятый аргументы означают, что над полем "
"``field[3]`` проводится операция ИЛИ со значением ``1``. Седьмой и "
"восьмой аргументы означают, что полю ``field[2]`` присваивается ``'C'``. "
"Таким образом, после данного обновления ``field[1]`` = ``999``, "
"``field[2]`` = ``'C'``, ``field[3]`` = ``3``."

#: ../doc/book/box/box_space.rst:1640
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'#', 2, 1}, {'-', "
"2, 3}})`` |br| The idea is to delete ``field[2]``, then subtract ``3`` "
"from ``field[3]``. But after the delete, there is a renumbering, so "
"``field[3]`` becomes ``field[2]`` before we subtract ``3`` from it, and "
"that's why the seventh argument is ``2``, not ``3``. Therefore, after "
"this update, ``field[1]`` = ``999``, ``field[2]`` = ``0``."
msgstr ""
"В обновлении: |br| ``box.space.tester:update({999}, {{'#', 2, 1}, {'-', "
"2, 3}})`` |br| Основная идея состоит в том, чтобы удалить поле "
"``field[2]``, а затем вычесть ``3`` из ``field[3]``. Но после удаления, "
"произойдет перенумерация, поэтому поле ``field[3]`` становится "
"``field[2]`` до того, как мы вычтем из него ``3``, вот почему седьмым "
"аргументом будет ``2``, а не ``3``. Таким образом, после данного "
"обновления ``field[1]`` = ``999``, ``field[2]`` = ``0``."

#: ../doc/book/box/box_space.rst:1648
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'=', 2, 'XYZ'}})``"
" |br| we're making a long string so that splice will work in the next "
"example. Therefore, after this update, ``field[1]`` = ``999``, "
"``field[2]`` = ``'XYZ'``."
msgstr ""
"В обновлении: |br| ``box.space.tester:update({999}, {{'=', 2, 'XYZ'}})`` "
"|br| Создаем длинную строку, чтобы в следующем примере сработало "
"разделение. Таким образом, после данного обновления ``field[1]`` = "
"``999``, ``field[2]`` = ``'XYZ'``."

#: ../doc/book/box/box_space.rst:1653
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{':', 2, 2, 1, "
"'!!'}})`` |br| The third argument is ``':'``, that is, this is the "
"example of splice. The fourth argument is ``2`` because the change will "
"occur in ``field[2]``. The fifth argument is 2 because deletion will "
"begin with the second byte. The sixth argument is 1 because the number of"
" bytes to delete is 1. The seventh argument is ``'!!'``, because ``'!!'``"
" is to be added at this position. Therefore, after this update, "
"``field[1]`` = ``999``, ``field[2]`` = ``'X!!Z'``."
msgstr ""
"В обновлении: |br| ``box.space.tester:update({999}, {{':', 2, 2, 1, "
"'!!'}})`` |br| Третьим аргументом будет ``':'``, то есть это пример "
"разделения. Четвертым аргументом будет ``2``, поскольку изменение "
"произойдет в поле ``field[2]``. Пятым аргументом будет 2, поскольку "
"удаление начнется со второго байта. Шестым аргументом будет 1, количество"
" удаляемых байтов -- 1. Седьмым аргументом будет ``'!!'``, поскольку в "
"данном положении будет добавляться ``'!!'``. Таким образом, после данного"
" обновления ``field[1]`` = ``999``, ``field[2]`` = ``'X!!Z'``."

#: ../doc/book/box/box_space.rst:1670
msgid "Update or insert a tuple."
msgstr "Обновление или вставка кортежа."

#: ../doc/book/box/box_space.rst:1672
msgid ""
"If there is an existing tuple which matches the key fields of ``tuple``, "
"then the request has the same effect as :ref:`space_object:update() "
"<box_space-update>` and the ``{{operator, field_no, value}, ...}`` "
"parameter is used. If there is no existing tuple which matches the key "
"fields of ``tuple``, then the request has the same effect as "
":ref:`space_object:insert() <box_space-insert>` and the ``{tuple}`` "
"parameter is used. However, unlike ``insert`` or ``update``, ``upsert`` "
"will not read a tuple and perform error checks before returning -- this "
"is a design feature which enhances throughput but requires more caution "
"on the part of the user."
msgstr ""
"Если существует кортеж, который совпадает с полями ключа ``tuple``, "
"запрос приведет к тому же результату, что и :ref:`space_object:update() "
"<box_space-update>`, и используется параметр ``{{operator, field_no, "
"value}, ...}``. Если нет кортежа, который совпадает с полями ключа "
"``tuple``, запрос приведет к тому же результату, что и  "
":ref:`space_object:insert() <box_space-insert>`, и используется параметр "
"``{tuple}``. Однако, в отличие от ``insert`` или ``update``, ``upsert`` "
"не считывает кортеж и не проверяет на ошибки перед возвратом -- это "
"конструктивная особенность, которая увеличивает быстродействие, но "
"требует большей осторожности со стороны пользователя."

#: ../doc/book/box/box_space.rst:1684
msgid "default tuple to be inserted, if analogue isn't found"
msgstr "вставляемый по умолчанию кортеж, если не найдет аналог"

#: ../doc/book/box/box_space.rst:1693
msgid "null"
msgstr "null"

#: ../doc/book/box/box_space.rst:1697
msgid "It is illegal to modify a primary-key field."
msgstr "Нельзя изменять поле первичного ключа."

#: ../doc/book/box/box_space.rst:1698
msgid ""
"It is illegal to use upsert with a space that has a unique secondary "
"index."
msgstr ""
"Нельзя проводить операцию upsert в спейсе, в котором есть уникальный "
"вторичный индекс."

#: ../doc/book/box/box_space.rst:1706
msgid "box.space.tester:upsert({12,'c'}, {{'=', 3, 'a'}, {'=', 4, 'b'}})"
msgstr "box.space.tester:upsert({12,'c'}, {{'=', 3, 'a'}, {'=', 4, 'b'}})"

#: ../doc/book/box/box_space.rst:1718
msgid ""
"Users can define any functions they want, and associate them with spaces:"
" in effect they can make their own space methods. They do this by:"
msgstr ""
"Пользователи могут сами определять любые желаемые функции и связывать их "
"со спейсами: фактически они могут создавать собственные методы для работы"
" со спейсом. Это можно сделать так:"

#: ../doc/book/box/box_space.rst:1725
msgid ""
"invoking the function any time thereafter, as long as the server is up, "
"by saying ``space_object:function-name([parameters])``."
msgstr ""
"впоследствии в любое время, пока работает сервер, вызвать функцию с "
"помощью ``объект_спейса:имя-функции([параметры])``."

#: ../doc/book/box/box_space.rst:1728
msgid ""
"The predefined global variable is ``box.schema.space_mt``. Adding to "
"``box.schema.space_mt`` makes the method available for all spaces."
msgstr ""
"Задана глобальная переменная ``box.schema.space_mt``. Метод, добавленный "
"в ``box.schema.space_mt``, будет доступен для всех спейсов."

#: ../doc/book/box/box_space.rst:1731
msgid ""
"Alternatively, user-defined methods can be made available for only one "
"space, by calling ``getmetatable(space_object)`` and then adding the "
"function name to the meta table. See also the example for "
":ref:`index_object:user_defined() <box_index-user_defined>`."
msgstr ""
"Можно также сделать задаваемый пользователем метод доступным только для "
"одного индекса путем вызова ``getmetatable(объект_спейса)`` и "
"последующего добавления имени функции в метатаблицу. См. также пример для"
" :ref:`index_object:user_defined() <box_index-user_defined>`."

#: ../doc/book/box/box_space.rst:1742
msgid ""
"-- Visible to any space, no parameters.\n"
"-- After these requests, the value of global_variable will be 6.\n"
"box.schema.space.create('t')\n"
"box.space.t:create_index('i')\n"
"global_variable = 5\n"
"function f(space_arg) global_variable = global_variable + 1 end\n"
"box.schema.space_mt.counter = f\n"
"box.space.t:counter()"
msgstr ""
"-- Доступный для любого спейса, без параметров.\n"
"-- После таких запросов значение глобальной переменной global_variable "
"будет 6.\n"
"box.schema.space.create('t')\n"
"box.space.t:create_index('i')\n"
"global_variable = 5\n"
"function f(space_arg) global_variable = global_variable + 1 end\n"
"box.schema.space_mt.counter = f\n"
"box.space.t:counter()"

#: ../doc/book/box/box_space.rst:1758
msgid ""
"Create a check constraint. A check constraint is a requirement that must "
"be met when a tuple is inserted or updated in a space. Check constraints "
"created with ``space_object:create_check_constraint`` have the same "
"effect as check constraints created with an SQL CHECK() clause in a "
":ref:`CREATE TABLE statement <sql_create_table>`."
msgstr ""

#: ../doc/book/box/box_space.rst:1767
#, fuzzy
msgid ""
"name of check constraint, which should conform to the :ref:`rules for "
"object names <app_server-names>`"
msgstr ""
"имя пользователя, которое должно соответствовать :ref:`правилам "
"именования объектов <app_server-names>`"

#: ../doc/book/box/box_space.rst:1769
msgid "SQL code of an expression which must return a boolean result"
msgstr ""

#: ../doc/book/box/box_space.rst:1771
msgid "check constraint object"
msgstr ""

#: ../doc/book/box/box_space.rst:1772
msgid "check_constraint_object"
msgstr ""

#: ../doc/book/box/box_space.rst:1774
msgid ""
"The space must be formatted with :ref:`space_object:format() <box_space-"
"format>` so that the expression can contain field names. The space must "
"be empty. The space must not be a system space."
msgstr ""

#: ../doc/book/box/box_space.rst:1778
msgid ""
"The expression must return true or false and should be deterministic. The"
" expresion may be any SQL (not Lua) expression containing field names, "
"built-in function names, literals, and operators. Not subqueries. If a "
"field name contains lower case characters, it must be enclosed in "
"\"double quotes\"."
msgstr ""

#: ../doc/book/box/box_space.rst:1783
msgid ""
"Check constraints are checked before the request is performed, at the "
"same time as Lua :ref:`before_replace triggers <box_space-"
"before_replace>`. If there is more than one check constraint or "
"before_replace trigger, then they are ordered according to time of "
"creation. (This is a change from the earlier behavior of check "
"constraints, which caused checking before the tuple was formed.)"
msgstr ""

#: ../doc/book/box/box_space.rst:1790
msgid ""
"Check constraints can be dropped with "
":samp:`space_object:{check_constraint_name}:drop()`."
msgstr ""

#: ../doc/book/box/box_space.rst:1794
msgid ""
"box.schema.space.create('t')\n"
"box.space.t:format({{name = 'f1', type = 'unsigned'},\n"
"                    {name = 'f2', type = 'string'},\n"
"                    {name = 'f3', type = 'string'}})\n"
"box.space.t:create_index('i')\n"
"box.space.t:create_check_constraint('c1', [[\"f2\" > 'A']])\n"
"box.space.t:create_check_constraint('c2',\n"
"                        [[\"f2\"=UPPER(\"f3\") AND NOT \"f2\" LIKE "
"'__']])\n"
"-- This insert will fail, constraint c1 expression returns false\n"
"box.space.t:insert{1, 'A', 'A'}\n"
"-- This insert will fail, constraint c2 expression returns false\n"
"box.space.t:insert{1, 'B', 'c'}\n"
"-- This insert will succeed, both constraint expressions return true\n"
"box.space.t:insert{1, 'B', 'b'}\n"
"-- This update will fail, constraint c2 expression returns false\n"
"box.space.t:update(1, {{'=', 2, 'xx'}, {'=', 3, 'xx'}})"
msgstr ""

#: ../doc/book/box/box_space.rst:1813
msgid ""
"A list of check constraints is in :ref:`space_object._ck_constraint "
"<box_space-ck_constraint>`."
msgstr ""

#: ../doc/book/box/box_space.rst:1819
msgid ""
"Whether or not this space is enabled. The value is ``false`` if the space"
" has no index."
msgstr ""
"Определение активности спейса. Значение ``false`` указывает на отсутствие"
" индекса."

#: ../doc/book/box/box_space.rst:1826
msgid ""
"The required field count for all tuples in this space. The field_count "
"can be set initially with:"
msgstr ""
"Необходимость подсчета полей всех кортежей в спейсе, который можно "
"изначально задать следующим образом:"

#: ../doc/book/box/box_space.rst:1866
msgid ""
"box.schema.space.create(..., {\n"
"    ... ,\n"
"    field_count = *field_count_value* ,\n"
"    ...\n"
"})"
msgstr ""
"box.schema.space.create(..., {\n"
"    ... ,\n"
"    field_count = *field_count_value* ,\n"
"    ...\n"
"})"

#: ../doc/book/box/box_space.rst:1838
msgid "The default value is ``0``, which means there is no required field count."
msgstr ""
"По умолчанию, будет использоваться значение ``0``, что указывает на "
"отсутствие необходимости подсчета полей."

#: ../doc/book/box/box_space.rst:1842
msgid ""
"tarantool> box.space.tester.field_count\n"
"---\n"
"- 0\n"
"..."
msgstr ""
"tarantool> box.space.tester.field_count\n"
"---\n"
"- 0\n"
"..."

#: ../doc/book/box/box_space.rst:1853
msgid ""
"Ordinal space number. Spaces can be referenced by either name or number. "
"Thus, if space ``tester`` has ``id = 800``, then "
"``box.space.tester:insert{0}`` and ``box.space[800]:insert{0}`` are "
"equivalent requests."
msgstr ""
"Порядковый номер спейса. На спейс можно ссылаться либо по имени, либо по "
"номеру. Таким образом, если идентификатором спейса ``tester`` будет ``id "
"= 800``, то ``box.space.tester:insert{0}`` и ``box.space[800]:insert{0}``"
" представляют собой равнозначные запросы."

#: ../doc/book/box/box_space.rst:1860
msgid ""
"tarantool> box.space.tester.id\n"
"---\n"
"- 512\n"
"..."
msgstr ""
"tarantool> box.space.tester.id\n"
"---\n"
"- 512\n"
"..."

#: ../doc/book/box/box_space.rst:1871
msgid ""
"A container for all defined indexes. There is a Lua object of type "
":ref:`box.index <box_index>` with methods to search tuples and iterate "
"over them in predefined order."
msgstr ""
"Контейнер для всех определенных индексов. Есть Lua-объект типа "
":ref:`box.index <box_index>` с методами поиска кортежей и итерации по ним"
" в заданном порядке."

#: ../doc/book/box/box_space.rst:1875
msgid "To reset, use :ref:`box.stat.reset() <box_introspection-box_stat_reset>`."
msgstr ""
"Чтобы сбросить, use :ref:`box.stat.reset() <box_introspection-"
"box_stat_reset>`."

#: ../doc/book/box/box_space.rst:1881
msgid ""
"# checking the number of indexes for space 'tester'\n"
"tarantool> local counter=0; for i=0,#box.space.tester.index do\n"
"  if box.space.tester.index[i]~=nil then counter=counter+1 end\n"
"  end; print(counter)\n"
"1\n"
"---\n"
"...\n"
"# checking the type of index 'primary'\n"
"tarantool> box.space.tester.index.primary.type\n"
"---\n"
"- TREE\n"
"..."
msgstr ""
"# проверка количества индексов для спейса 'tester'\n"
"tarantool> local counter=0; for i=0,#box.space.tester.index do\n"
"  if box.space.tester.index[i]~=nil then counter=counter+1 end\n"
"  end; print(counter)\n"
"1\n"
"---\n"
"...\n"
"# проверка, что тип индекса -- первичный 'primary'\n"
"tarantool> box.space.tester.index.primary.type\n"
"---\n"
"- TREE\n"
"..."

#: ../doc/book/box/box_space.rst:1900
msgid ""
"``_cluster`` is a system space for support of the :ref:`replication "
"feature <replication>`."
msgstr ""
"``_cluster`` -- это системный спейс для поддержки :ref:`функции "
"репликации <replication>`."

#: ../doc/book/box/box_space.rst:1907
#, fuzzy
msgid ""
"``_func`` is a system space with function tuples made by "
":ref:`box.schema.func.create() <box_schema-func_create>` or "
":ref:`box.schema.func.create(func-name [, {options-with-body}]) "
"<box_schema-func_create_with-body>`."
msgstr ""
"``_func`` -- это системный спейс, который содержит кортежи с функциями, "
"созданными с помощью :ref:`box.schema.func.create() <box_schema-"
"func_create>`."

#: ../doc/book/box/box_space.rst:1912 ../doc/book/box/box_space.rst:1978
#: ../doc/book/box/box_space.rst:2037 ../doc/book/box/box_space.rst:2157
#: ../doc/book/box/box_space.rst:2273 ../doc/book/box/box_space.rst:2412
msgid "Tuples in this space contain the following fields:"
msgstr "Кортежи в данном спейсе включают в себя следующие поля:"

#: ../doc/book/box/box_space.rst:1914
#, fuzzy
msgid "id (integer identifier),"
msgstr "уникальный идентификатор"

#: ../doc/book/box/box_space.rst:1915
#, fuzzy
msgid "owner (integer identifier),"
msgstr "Идентификаторы в нижнем регистре"

#: ../doc/book/box/box_space.rst:1916
msgid "the function name,"
msgstr "имя функции,"

#: ../doc/book/box/box_space.rst:1917
msgid "the setuid flag,"
msgstr ""

#: ../doc/book/box/box_space.rst:1918
msgid "a language name (optional): 'LUA' (default) or 'C'."
msgstr "название языка (необязательно): 'LUA' (по умолчанию) or 'C'."

#: ../doc/book/box/box_space.rst:1919
msgid "the body"
msgstr ""

#: ../doc/book/box/box_space.rst:1920
msgid "the is_deterministic flag"
msgstr ""

#: ../doc/book/box/box_space.rst:1921
msgid "the is_sandboxed flag"
msgstr ""

#: ../doc/book/box/box_space.rst:1922
#, fuzzy
msgid "options"
msgstr "Параметры:"

#: ../doc/book/box/box_space.rst:1924
#, fuzzy
msgid ""
"If the function tuple was made in the older way without specification of "
"``body``, then the ``_func`` space will contain default values for the "
"body and the is_deterministic flag and the is_sandboxed flag. Such "
"function tuples are called \"not persistent\". You continue to create Lua"
" functions in the usual way, by saying ``function function_name () ... "
"end``, without adding anything in the ``_func`` space. The ``_func`` "
"space only exists for storing function tuples so that their names can be "
"used within :ref:`grant/revoke <authentication-owners_privileges>` "
"functions."
msgstr ""
"Спейс ``_func`` не содержит саму функцию. Lua-функции создаются "
"по-прежнему с помощью ``function имя_функции () ... end`` без каких-либо "
"добавлений в спейс ``_func``. Спейс ``_func`` предназначен лишь для "
"хранения кортежей с функциями так, чтобы их имена могли использоваться в "
"функциях :ref:`выдачи/отмены прав <authentication-owners_privileges>`."

#: ../doc/book/box/box_space.rst:1935
msgid ""
"If the function tuple was made the newer way with specification of "
"``body``, then all the fields may contain non-default values. Such "
"functions are called \"persistent\". They should be invoked with "
":samp:`box.func.{func-name}:call([parameters])`."
msgstr ""

#: ../doc/book/box/box_space.rst:1940 ../doc/book/box/box_space.rst:2047
#: ../doc/book/cartridge/cartridge_dev.rst:501
msgid "You can:"
msgstr "Доступны следующие операции:"

#: ../doc/book/box/box_space.rst:1942
msgid ""
"Create a ``_func`` tuple with :ref:`box.schema.func.create() <box_schema-"
"func_create>`,"
msgstr ""
"Создание кортежа в ``_func`` с помощью :ref:`box.schema.func.create() "
"<box_schema-func_create>`,"

#: ../doc/book/box/box_space.rst:1944
msgid ""
"Drop a ``_func`` tuple with :ref:`box.schema.func.drop() <box_schema-"
"func_drop>`,"
msgstr ""
"Удаление кортежа в ``_func`` с помощью :ref:`box.schema.func.drop() "
"<box_schema-func_drop>`,"

#: ../doc/book/box/box_space.rst:1946
msgid ""
"Check whether a ``_func`` tuple exists with "
":ref:`box.schema.func.exists() <box_schema-func_exists>`."
msgstr ""
"Проверка наличия кортежа в ``_func`` с помощью "
":ref:`box.schema.func.exists() <box_schema-func_exists>`."

#: ../doc/book/box/box_space.rst:1951
msgid ""
"In the following example, we create a function named ‘f7’, put it into "
"Tarantool's ``_func`` space and grant 'execute' privilege for this "
"function to 'guest' user."
msgstr ""
"В следующем примере создадим функцию с именем ‘f7’, поместим ее в спейс "
"``_func`` в Tarantool'е и выдадим права на 'выполнение' этой функции "
"пользователю 'guest'."

#: ../doc/book/box/box_space.rst:1955
msgid ""
"tarantool> function f7()\n"
"         >  box.session.uid()\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> box.schema.func.create('f7')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('guest', 'execute', 'function', 'f7')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.revoke('guest', 'execute', 'function', 'f7')\n"
"---\n"
"..."
msgstr ""
"tarantool> function f7()\n"
"         >  box.session.uid()\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> box.schema.func.create('f7')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('guest', 'execute', 'function', 'f7')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.revoke('guest', 'execute', 'function', 'f7')\n"
"---\n"
"..."

#: ../doc/book/box/box_space.rst:1976
msgid "``_index`` is a system space."
msgstr "``_index`` -- это системный спейс."

#: ../doc/book/box/box_space.rst:1980
msgid "``id`` (= id of space),"
msgstr "``id`` (= идентификатор спейса),"

#: ../doc/book/box/box_space.rst:1981
msgid "``iid`` (= index number within space),"
msgstr "``iid`` (= номер индекса в спейсе),"

#: ../doc/book/box/box_space.rst:1982
msgid "``name``,"
msgstr "``name``,"

#: ../doc/book/box/box_space.rst:1983
msgid "``type``,"
msgstr "``type``,"

#: ../doc/book/box/box_space.rst:1984
msgid ""
"``opts`` (e.g. unique option), [``tuple-field-no``, ``tuple-field-type`` "
"...]."
msgstr ""
"``opts`` (например, уникальная опция), [``tuple-field-no``, ``tuple-"
"field-type`` ...]."

#: ../doc/book/box/box_space.rst:1986
msgid "Here is what ``_index`` contains in a typical installation:"
msgstr "Вот что при обычной установке включает в себя спейс ``_index``:"

#: ../doc/book/box/box_space.rst:1988
msgid ""
"tarantool> box.space._index:select{}\n"
"---\n"
"- - [272, 0, 'primary', 'tree', {'unique': true}, [[0, 'string']]]\n"
"  - [280, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned']]]\n"
"  - [280, 1, 'owner', 'tree', {'unique': false}, [[1, 'unsigned']]]\n"
"  - [280, 2, 'name', 'tree', {'unique': true}, [[2, 'string']]]\n"
"  - [281, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned']]]\n"
"  - [281, 1, 'owner', 'tree', {'unique': false}, [[1, 'unsigned']]]\n"
"  - [281, 2, 'name', 'tree', {'unique': true}, [[2, 'string']]]\n"
"  - [288, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned'], [1, "
"'unsigned']]]\n"
"  - [288, 2, 'name', 'tree', {'unique': true}, [[0, 'unsigned'], [2, "
"'string']]]\n"
"  - [289, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned'], [1, "
"'unsigned']]]\n"
"  - [289, 2, 'name', 'tree', {'unique': true}, [[0, 'unsigned'], [2, "
"'string']]]\n"
"  - [296, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned']]]\n"
"  - [296, 1, 'owner', 'tree', {'unique': false}, [[1, 'unsigned']]]\n"
"  - [296, 2, 'name', 'tree', {'unique': true}, [[2, 'string']]]\n"
"---\n"
"..."
msgstr ""
"tarantool> box.space._index:select{}\n"
"---\n"
"- - [272, 0, 'primary', 'tree', {'unique': true}, [[0, 'string']]]\n"
"  - [280, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned']]]\n"
"  - [280, 1, 'owner', 'tree', {'unique': false}, [[1, 'unsigned']]]\n"
"  - [280, 2, 'name', 'tree', {'unique': true}, [[2, 'string']]]\n"
"  - [281, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned']]]\n"
"  - [281, 1, 'owner', 'tree', {'unique': false}, [[1, 'unsigned']]]\n"
"  - [281, 2, 'name', 'tree', {'unique': true}, [[2, 'string']]]\n"
"  - [288, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned'], [1, "
"'unsigned']]]\n"
"  - [288, 2, 'name', 'tree', {'unique': true}, [[0, 'unsigned'], [2, "
"'string']]]\n"
"  - [289, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned'], [1, "
"'unsigned']]]\n"
"  - [289, 2, 'name', 'tree', {'unique': true}, [[0, 'unsigned'], [2, "
"'string']]]\n"
"  - [296, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned']]]\n"
"  - [296, 1, 'owner', 'tree', {'unique': false}, [[1, 'unsigned']]]\n"
"  - [296, 2, 'name', 'tree', {'unique': true}, [[2, 'string']]]\n"
"---\n"
"..."

#: ../doc/book/box/box_space.rst:2013
msgid ""
"``_vindex`` is a system space that represents a virtual view. The "
"structure of its tuples is identical to that of :ref:`_index <box_space-"
"index>`, but permissions for certain tuples are limited in accordance "
"with user privileges. ``_vindex`` contains only those tuples that are "
"accessible to the current user. See :ref:`Access control "
"<authentication>` for details about user privileges."
msgstr ""
"``_vindex`` -- это системный спейс, который реализует виртуальное "
"представление. Структура его кортежей совпадает со структурой кортежей в "
":ref:`_index <box_space-index>`, но права доступа на определенные кортежи"
" ограничены в соответствии с правами пользователя. ``_vindex`` содержит "
"только те кортежи, которые доступны текущему пользователю. Для получения "
"более подробной информации о правах пользователя см. раздел "
":ref:`Управление доступом <authentication>`."

#: ../doc/book/box/box_space.rst:2019
msgid ""
"If the user has the full set of privileges (like 'admin'), the contents "
"of ``_vindex`` match the contents of ``_index``. If the user has limited "
"access, ``_vindex`` contains only tuples accessible to this user."
msgstr ""
"Если у пользователя есть полный набор прав (как у пользователя 'admin'), "
"содержимое ``_vindex`` совпадает с содержимым ``_index``. Если же у "
"пользователя доступ ограничен, ``_vindex`` содержит только кортежи, "
"которые доступны текущему пользователю."

#: ../doc/book/box/box_space.rst:2025
msgid "``_vindex`` is a system view, so it allows only read requests."
msgstr ""
"``_vindex`` -- это виртуальное представление системы, поэтому допускаются"
" только запросы на чтение."

#: ../doc/book/box/box_space.rst:2027
msgid ""
"While the ``_index`` space requires proper access privileges, any user "
"can always read from ``_vindex``."
msgstr ""
"Если спейс ``_index`` требует наличия соответствующих прав доступа, то "
"любой пользователь всегда может выполнить чтение из ``_vindex``."

#: ../doc/book/box/box_space.rst:2034
msgid ""
"``_priv`` is a system space where :ref:`privileges <authentication-"
"owners_privileges>` are stored."
msgstr ""
"``_priv`` -- это системный спейс, где хранятся :ref:`права "
"<authentication-owners_privileges>`."

#: ../doc/book/box/box_space.rst:2039
msgid "the numeric id of the user who gave the privilege (\"grantor_id\"),"
msgstr "числовой идентификатор пользователя, который выдал права (\"grantor_id\"),"

#: ../doc/book/box/box_space.rst:2040
msgid "the numeric id of the user who received the privilege (\"grantee_id\"),"
msgstr ""
"числовой идентификатор пользователя, который получил права "
"(\"grantee_id\"),"

#: ../doc/book/box/box_space.rst:2041
msgid "the type of object: 'space', 'function', 'sequence' or 'universe',"
msgstr ""
"тип объекта: 'space' (спейс), 'function' (функция), 'sequence' "
"(последовательность) или 'universe' (вселенная),"

#: ../doc/book/box/box_space.rst:2042
msgid "the numeric id of the object,"
msgstr "числовой идентификатор объекта,"

#: ../doc/book/box/box_space.rst:2043
msgid ""
"the type of operation: \"read\" = 1, \"write\" = 2, \"execute\" = 4, "
"\"create\" = 32, \"drop\" = 64, \"alter\" = 128, or a combination such as"
" \"read,write,execute\"."
msgstr ""
"тип операции: \"read\" = 1, \"write\" = 2, \"execute\" = 4, \"create\" = "
"32, \"drop\" = 64, \"alter\" = 128, или их комбинация, например "
"\"read,write,execute\"."

#: ../doc/book/box/box_space.rst:2049
msgid ""
"Grant a privilege with :ref:`box.schema.user.grant() <box_schema-"
"user_grant>`."
msgstr ""
"Выдача прав с помощью :ref:`box.schema.user.grant() <box_schema-"
"user_grant>`."

#: ../doc/book/box/box_space.rst:2050
msgid ""
"Revoke a privilege with :ref:`box.schema.user.revoke() <box_schema-"
"user_revoke>`."
msgstr ""
"Отмена прав с помощью :ref:`box.schema.user.revoke() <box_schema-"
"user_revoke>`."

#: ../doc/book/box/box_space.rst:2054
msgid ""
"Generally, privileges are granted or revoked by the owner of the object "
"(the user who created it), or by the 'admin' user."
msgstr ""
"Как правило, права выдаются или отменяются владельцем объекта "
"(пользователем, который создал его) или пользователем 'admin'."

#: ../doc/book/box/box_space.rst:2057
msgid ""
"Before dropping any objects or users, make sure that all their associated"
" privileges have been revoked."
msgstr ""
"До удаления любых объектов или пользователей, убедитесь, что отменили все"
" связанные с ними права."

#: ../doc/book/box/box_space.rst:2060
msgid ""
"Only the :ref:`'admin' user <authentication-owners_privileges>` can grant"
" privileges for the 'universe'."
msgstr ""
"Только пользователь :ref:`'admin' <authentication-owners_privileges>` "
"может выдавать права на 'universe'."

#: ../doc/book/box/box_space.rst:2063
msgid ""
"Only the 'admin' user or the creator of a space can drop, alter, or "
"truncate the space."
msgstr ""
"Только пользователь 'admin' или создатель спейса может удалить, изменить "
"или очистить спейс."

#: ../doc/book/box/box_space.rst:2066
msgid ""
"Only the 'admin' user or the creator of a user can change a different "
"user’s password."
msgstr ""
"Только пользователь 'admin' или создатель спейса может изменять  change a"
" different user’s password."

#: ../doc/book/box/box_space.rst:2073
msgid ""
"``_vpriv`` is a system space that represents a virtual view. The "
"structure of its tuples is identical to that of :ref:`_priv <box_space-"
"priv>`, but permissions for certain tuples are limited in accordance with"
" user privileges. ``_vpriv`` contains only those tuples that are "
"accessible to the current user. See :ref:`Access control "
"<authentication>` for details about user privileges."
msgstr ""
"``_vpriv`` -- это системный спейс, который реализует виртуальное "
"представление. Структура его кортежей совпадает со структурой кортежей в "
":ref:`_priv <box_space-priv>`, но права доступа на определенные кортежи "
"ограничены в соответствии с правами пользователя. ``_vpriv`` содержит "
"только те кортежи, которые доступны текущему пользователю. Для получения "
"более подробной информации о правах пользователя см. раздел "
":ref:`Управление доступом <authentication>`."

#: ../doc/book/box/box_space.rst:2079
msgid ""
"If the user has the full set of privileges (like 'admin'), the contents "
"of ``_vpriv`` match the contents of ``_priv``. If the user has limited "
"access, ``_vpriv`` contains only tuples accessible to this user."
msgstr ""
"Если у пользователя есть полный набор прав (как у пользователя 'admin'), "
"содержимое ``_vpriv`` совпадает с содержимым ``_priv``. Если же у "
"пользователя доступ ограничен, ``_vpriv`` содержит только кортежи, "
"которые доступны текущему пользователю."

#: ../doc/book/box/box_space.rst:2085
msgid "``_vpriv`` is a system view, so it allows only read requests."
msgstr ""
"``_vpriv`` -- это виртуальное представление системы, поэтому допускаются "
"только запросы на чтение."

#: ../doc/book/box/box_space.rst:2087
msgid ""
"While the ``_priv`` space requires proper access privileges, any user can"
" always read from ``_vpriv``."
msgstr ""
"Если спейс ``_priv`` требует наличия соответствующих прав доступа, то "
"любой пользователь всегда может выполнить чтение из ``_vpriv``."

#: ../doc/book/box/box_space.rst:2094
msgid "``_schema`` is a system space."
msgstr "``_schema`` -- это системный спейс."

#: ../doc/book/box/box_space.rst:2096
msgid "This space contains the following tuples:"
msgstr "Этот спейс включает в себя следующие кортежи:"

#: ../doc/book/box/box_space.rst:2098
msgid "``version`` tuple with version information for this Tarantool instance,"
msgstr "кортеж ``version`` с информацией о версии данного экземпляра Tarantool'а,"

#: ../doc/book/box/box_space.rst:2099
msgid "``cluster`` tuple with the instance's replica set ID,"
msgstr "кортеж ``cluster`` с идентификатором набора реплик данного экземпляра,"

#: ../doc/book/box/box_space.rst:2100
msgid "``max_id`` tuple with the maximal space ID,"
msgstr "кортеж ``max_id`` с максимальным ID спейса,"

#: ../doc/book/box/box_space.rst:2101
msgid ""
"``once...`` tuples that correspond to specific :ref:`box.once() <box-"
"once>` blocks from the instance's :ref:`initialization file <index-"
"init_label>`. The first field in these tuples contains the ``key`` value "
"from the corresponding ``box.once()`` block prefixed with 'once' (e.g. "
"`oncehello`), so you can easily find a tuple that corresponds to a "
"specific ``box.once()`` block."
msgstr ""
"кортежи ``once...``, которые соответствуют определенным блокам "
":ref:`box.once() <box-once>` из :ref:`файла инициализации <index-"
"init_label>` экземпляра. Первое поле в таких кортежах содержит значение "
"ключа ``key`` из соответствующего блока ``box.once()`` с префиксом 'once'"
" (например, `oncehello`), поэтому можно легко найти кортеж, который "
"соответствует определенному блоку ``box.once()``."

#: ../doc/book/box/box_space.rst:2111
msgid ""
"Here is what ``_schema`` contains in a typical installation (notice the "
"tuples for two ``box.once()`` blocks, ``'oncebye'`` and ``'oncehello'``):"
msgstr ""
"Вот что при обычной установке включает в себя спейс ``_schema`` (обратите"
" внимание на кортежи для двух блоков ``box.once()``: ``'oncebye'`` и "
"``'oncehello'``):"

#: ../doc/book/box/box_space.rst:2114
msgid ""
"tarantool> box.space._schema:select{}\n"
"---\n"
"- - ['cluster', 'b4e15788-d962-4442-892e-d6c1dd5d13f2']\n"
"  - ['max_id', 512]\n"
"  - ['oncebye']\n"
"  - ['oncehello']\n"
"  - ['version', 1, 7, 2]"
msgstr ""
"tarantool> box.space._schema:select{}\n"
"---\n"
"- - ['cluster', 'b4e15788-d962-4442-892e-d6c1dd5d13f2']\n"
"  - ['max_id', 512]\n"
"  - ['oncebye']\n"
"  - ['oncehello']\n"
"  - ['version', 1, 7, 2]"

#: ../doc/book/box/box_space.rst:2128
msgid ""
"``_sequence`` is a system space for support of the :ref:`sequence feature"
" <index-box_sequence>`. It contains persistent information that was "
"established by :ref:`box.schema.sequence.create() <box_schema-"
"sequence_create>` or :ref:`box.schema.sequence.alter() <box_schema-"
"sequence_alter>`."
msgstr ""
"``_sequence`` -- это системный спейс для поддержки "
":ref:`последовательностей <index-box_sequence>`. Он содержит "
"персистентную информацию, определенную с помощью "
":ref:`box.schema.sequence.create() <box_schema-sequence_create>` или "
":ref:`box.schema.sequence.alter() <box_schema-sequence_alter>`."

#: ../doc/book/box/box_space.rst:2138
msgid ""
"``_sequence_data`` is a system space for support of the :ref:`sequence "
"feature <index-box_sequence>`."
msgstr ""
"``_sequence_data`` -- это системный спейс для поддержки "
":ref:`последовательностей <index-box_sequence>`."

#: ../doc/book/box/box_space.rst:2141
msgid "Each tuple in ``_sequence_data`` contains two fields:"
msgstr "Каждый кортеж в спейсе ``_sequence_data`` содержит два поля:"

#: ../doc/book/box/box_space.rst:2143
msgid "the id of the sequence, and"
msgstr "идентификатор последовательности и"

#: ../doc/book/box/box_space.rst:2144
msgid ""
"the last value that the sequence generator returned (non-persistent "
"information)."
msgstr ""
"последнее значение, возвращенное генератором последовательностей "
"(временная информация)."

#: ../doc/book/box/box_space.rst:2147
msgid ""
"There is no guarantee that this space will be updated immediately after "
"every data-change request."
msgstr ""

#: ../doc/book/box/box_space.rst:2154
msgid ""
"``_space`` is a system space. It contains all spaces hosted on the "
"current Tarantool instance, both system ones and created by users."
msgstr ""
"``_space`` – это системный спейс. Он содержит информацию о всех спейсах, "
"хранящихся в данном экземпляре Tarantool - как системные, так и созданные"
" пользователями."

#: ../doc/book/box/box_space.rst:2159
msgid "``id``,"
msgstr "``id``,"

#: ../doc/book/box/box_space.rst:2160
msgid "``owner`` (= id of user who owns the space),"
msgstr "``owner`` (= идентификатор пользователя, которому принадлежит спейс),"

#: ../doc/book/box/box_space.rst:2161
msgid "``name``, ``engine``, ``field_count``,"
msgstr "``name``, ``engine``, ``field_count``,"

#: ../doc/book/box/box_space.rst:2162
msgid "``flags`` (e.g. temporary),"
msgstr "``flags`` (например, временный),"

#: ../doc/book/box/box_space.rst:2163
msgid "``format`` (as made by a :ref:`format clause <box_space-format>`)."
msgstr "``format`` (как задано через :ref:`оператор формата <box_space-format>`)."

#: ../doc/book/box/box_space.rst:2165
msgid ""
"These fields are established by :ref:`space.create() <box_schema-"
"space_create>`."
msgstr ""
"Эти поля определены с помощью :ref:`space.create() <box_schema-"
"space_create>`."

#: ../doc/book/box/box_space.rst:2170
msgid ""
"The following function will display every simple field in all tuples of "
"``_space``."
msgstr ""
"Следующая функция отобразит все простые поля во всех кортежах спейса "
"``_space``."

#: ../doc/book/box/box_space.rst:2173
msgid ""
"function example()\n"
"  local ta = {}\n"
"  local i, line\n"
"  for k, v in box.space._space:pairs() do\n"
"    i = 1\n"
"    line = ''\n"
"    while i <= #v do\n"
"      if type(v[i]) ~= 'table' then\n"
"        line = line .. v[i] .. ' '\n"
"      end\n"
"    i = i + 1\n"
"    end\n"
"    table.insert(ta, line)\n"
"  end\n"
"  return ta\n"
"end"
msgstr ""
"function example()\n"
"  local ta = {}\n"
"  local i, line\n"
"  for k, v in box.space._space:pairs() do\n"
"    i = 1\n"
"    line = ''\n"
"    while i <= #v do\n"
"      if type(v[i]) ~= 'table' then\n"
"        line = line .. v[i] .. ' '\n"
"      end\n"
"    i = i + 1\n"
"    end\n"
"    table.insert(ta, line)\n"
"  end\n"
"  return ta\n"
"end"

#: ../doc/book/box/box_space.rst:2192
msgid "Here is what ``example()`` returns in a typical installation:"
msgstr "Вот что при обычной установке вернет ``example()``:"

#: ../doc/book/box/box_space.rst:2194
msgid ""
"tarantool> example()\n"
"---\n"
"- - '272 1 _schema memtx 0  '\n"
"  - '280 1 _space memtx 0  '\n"
"  - '281 1 _vspace sysview 0  '\n"
"  - '288 1 _index memtx 0  '\n"
"  - '296 1 _func memtx 0  '\n"
"  - '304 1 _user memtx 0  '\n"
"  - '305 1 _vuser sysview 0  '\n"
"  - '312 1 _priv memtx 0  '\n"
"  - '313 1 _vpriv sysview 0  '\n"
"  - '320 1 _cluster memtx 0  '\n"
"  - '512 1 tester memtx 0  '\n"
"  - '513 1 origin vinyl 0  '\n"
"  - '514 1 archive memtx 0  '\n"
"..."
msgstr ""
"tarantool> example()\n"
"---\n"
"- - '272 1 _schema memtx 0  '\n"
"  - '280 1 _space memtx 0  '\n"
"  - '281 1 _vspace sysview 0  '\n"
"  - '288 1 _index memtx 0  '\n"
"  - '296 1 _func memtx 0  '\n"
"  - '304 1 _user memtx 0  '\n"
"  - '305 1 _vuser sysview 0  '\n"
"  - '312 1 _priv memtx 0  '\n"
"  - '313 1 _vpriv sysview 0  '\n"
"  - '320 1 _cluster memtx 0  '\n"
"  - '512 1 tester memtx 0  '\n"
"  - '513 1 origin vinyl 0  '\n"
"  - '514 1 archive memtx 0  '\n"
"..."

#: ../doc/book/box/box_space.rst:2215
msgid ""
"The following requests will create a space using "
"``box.schema.space.create()`` with a :ref:`format clause <box_space-"
"format>`, then retrieve the ``_space`` tuple for the new space. This "
"illustrates the typical use of the ``format`` clause, it shows the "
"recommended names and data types for the fields."
msgstr ""
"Следующая серия запросов создаст спейс, используя "
"``box.schema.space.create()`` с :ref:`оператором формата <box_space-"
"format>`, затем выберет кортеж из ``_space`` для нового спейса. Этот "
"пример иллюстрирует стандартное применение оператора ``format``, "
"показывая рекомендованные имена и типы данных для полей."

#: ../doc/book/box/box_space.rst:2221
msgid ""
"tarantool> box.schema.space.create('TM', {\n"
"         >   id = 12345,\n"
"         >   format = {\n"
"         >     [1] = {[\"name\"] = \"field_1\"},\n"
"         >     [2] = {[\"type\"] = \"unsigned\"}\n"
"         >   }\n"
"         > })\n"
"---\n"
"- index: []\n"
"  on_replace: 'function: 0x41c67338'\n"
"  temporary: false\n"
"  id: 12345\n"
"  engine: memtx\n"
"  enabled: false\n"
"  name: TM\n"
"  field_count: 0\n"
"- created\n"
"...\n"
"tarantool> box.space._space:select(12345)\n"
"---\n"
"- - [12345, 1, 'TM', 'memtx', 0, {}, [{'name': 'field_1'}, {'type': "
"'unsigned'}]]\n"
"..."
msgstr ""
"tarantool> box.schema.space.create('TM', {\n"
"         >   id = 12345,\n"
"         >   format = {\n"
"         >     [1] = {[\"name\"] = \"field_1\"},\n"
"         >     [2] = {[\"type\"] = \"unsigned\"}\n"
"         >   }\n"
"         > })\n"
"---\n"
"- index: []\n"
"  on_replace: 'function: 0x41c67338'\n"
"  temporary: false\n"
"  id: 12345\n"
"  engine: memtx\n"
"  enabled: false\n"
"  name: TM\n"
"  field_count: 0\n"
"- created\n"
"...\n"
"tarantool> box.space._space:select(12345)\n"
"---\n"
"- - [12345, 1, 'TM', 'memtx', 0, {}, [{'name': 'field_1'}, {'type': "
"'unsigned'}]]\n"
"..."

#: ../doc/book/box/box_space.rst:2250
msgid ""
"``_vspace`` is a system space that represents a virtual view. The "
"structure of its tuples is identical to that of :ref:`_space <box_space-"
"space>`, but permissions for certain tuples are limited in accordance "
"with user privileges. ``_vspace`` contains only those tuples that are "
"accessible to the current user. See :ref:`Access control "
"<authentication>` for details about user privileges."
msgstr ""
"``_vspace`` -- это системный спейс, который реализует виртуальное "
"представление. Структура его кортежей совпадает со структурой кортежей в "
":ref:`_space <box_space-space>`, но права доступа на определенные кортежи"
" ограничены в соответствии с правами пользователя. ``_vspace`` содержит "
"только те кортежи, которые доступны текущему пользователю. Для получения "
"более подробной информации о правах пользователя см. раздел "
":ref:`Управление доступом <authentication>`."

#: ../doc/book/box/box_space.rst:2256
msgid ""
"If the user has the full set of privileges (like 'admin'), the contents "
"of ``_vspace`` match the contents of ``_space``. If the user has limited "
"access, ``_vspace`` contains only tuples accessible to this user."
msgstr ""
"Если у пользователя есть полный набор прав (как у пользователя 'admin'), "
"содержимое ``_vspace`` совпадает с содержимым ``_space``. Если же у "
"пользователя доступ ограничен, ``_vspace`` содержит только кортежи, "
"которые доступны текущему пользователю."

#: ../doc/book/box/box_space.rst:2262
msgid "``_vspace`` is a system view, so it allows only read requests."
msgstr ""
"``_vspace`` -- это виртуальное представление системы, поэтому допускаются"
" только запросы на чтение."

#: ../doc/book/box/box_space.rst:2264
msgid ""
"While the ``_space`` space requires proper access privileges, any user "
"can always read from ``_vspace``."
msgstr ""
"Если спейс ``_space`` требует наличия соответствующих прав доступа, то "
"любой пользователь всегда может выполнить чтение из ``_vspace``."

#: ../doc/book/box/box_space.rst:2271
msgid ""
"``_user`` is a system space where user-names and password hashes are "
"stored."
msgstr ""
"``_user`` -- это системный спейс, где хранятся имена пользователей и хеши"
" паролей."

#: ../doc/book/box/box_space.rst:2275
msgid "the numeric id of the tuple (\"id\"),"
msgstr "числовой идентификатор кортежа (\"id\"),"

#: ../doc/book/box/box_space.rst:2276
msgid "the numeric id of the tuple’s creator,"
msgstr "числовой идентификатор создателя кортежа,"

#: ../doc/book/box/box_space.rst:2277 ../doc/book/box/box_space.rst:2415
msgid "the name,"
msgstr "имя,"

#: ../doc/book/box/box_space.rst:2278
msgid "the type: 'user' or 'role',"
msgstr "тип: 'user' (пользователь) или 'role' (роль),"

#: ../doc/book/box/box_space.rst:2279
msgid "optional password."
msgstr "пароль по желанию"

#: ../doc/book/box/box_space.rst:2281
msgid ""
"There are five special tuples in the ``_user`` space: 'guest', 'admin', "
"'public', 'replication', and 'super'."
msgstr ""
"В спейсе ``_user`` есть пять специальных кортежей: 'guest', 'admin', "
"'public', 'replication' и 'super'."

#: ../doc/book/box/box_space.rst:2294
msgid "ID"
msgstr "ID"

#: ../doc/book/box/box_space.rst:2296
msgid "guest"
msgstr "guest"

#: ../doc/book/box/box_space.rst:2296 ../doc/book/box/data_model.rst:513
#: ../doc/book/cartridge/cartridge_admin.rst:651
#: ../doc/book/cartridge/cartridge_admin.rst:821
msgid "0"
msgstr "0"

#: ../doc/book/box/box_space.rst:2296
msgid ""
"Default user when connecting remotely. Usually an untrusted user with few"
" privileges."
msgstr ""
"Пользователь, который используется по умолчанию при удаленном "
"подключении. Как правило, это не заслуживающий доверия пользователь с "
"небольшим количеством прав."

#: ../doc/book/box/box_space.rst:2299
msgid "admin"
msgstr "admin"

#: ../doc/book/box/box_space.rst:2299 ../doc/book/box/data_model.rst:500
#: ../doc/book/box/data_model.rst:504 ../doc/book/box/data_model.rst:516
#: ../doc/book/cartridge/cartridge_admin.rst:653
#: ../doc/book/cartridge/cartridge_admin.rst:823
msgid "1"
msgstr "1"

#: ../doc/book/box/box_space.rst:2299
msgid ""
"Default user when using Tarantool as a console. Usually an "
":ref:`administrative user <authentication-owners_privileges>` with all "
"privileges."
msgstr ""
"Пользователь, который используется по умолчанию при работе с Tarantool'ом"
" как с консолью. Как правило, это :ref:`административный пользователь "
"<authentication-owners_privileges>` со всеми правами."

#: ../doc/book/box/box_space.rst:2304
msgid "public"
msgstr "public"

#: ../doc/book/box/box_space.rst:2304 ../doc/book/box/box_space.rst:2312
#: ../doc/book/box/box_space.rst:2316
msgid "role"
msgstr "роль"

#: ../doc/book/box/box_space.rst:2304
msgid ""
"Pre-defined :ref:`role <authentication-roles>`, automatically granted to "
"new users when they are created with ``box.schema.user.create(user-"
"name)``. Therefore a convenient way to grant 'read' on space 't' to every"
" user that will ever exist is with "
"``box.schema.role.grant('public','read','space','t')``."
msgstr ""
"Заданная :ref:`роль <authentication-roles>`, которая автоматически "
"выдается новым пользователям при их создании методом "
"``box.schema.user.create(имя-пользователя)``. Таким образом, лучше всего "
"выдать права на чтение 'read' спейса 't' каждому когда-либо созданному "
"пользователю с помощью "
"``box.schema.role.grant('public','read','space','t')``."

#: ../doc/book/box/box_space.rst:2312
msgid "replication"
msgstr "replication"

#: ../doc/book/box/box_space.rst:2312
#: ../doc/book/cartridge/cartridge_admin.rst:660
#: ../doc/book/cartridge/cartridge_admin.rst:828
msgid "3"
msgstr "3"

#: ../doc/book/box/box_space.rst:2312
msgid ""
"Pre-defined :ref:`role <authentication-roles>`, which the 'admin' user "
"can grant to users who need to use :ref:`replication <replication>` "
"features."
msgstr ""
"Заданная :ref:`роль <authentication-roles>`, выдаваемая пользователем "
"'admin' другим пользователям для использования функций :ref:`репликации "
"<replication>`."

#: ../doc/book/box/box_space.rst:2316
msgid "super"
msgstr "super"

#: ../doc/book/box/box_space.rst:2316
msgid "31"
msgstr "31"

#: ../doc/book/box/box_space.rst:2316
msgid ""
"Pre-defined :ref:`role <authentication-roles>`, which the 'admin' user "
"can grant to users who need all privileges on all objects. The 'super' "
"role has these privileges on 'universe': read, write, execute, create, "
"drop, alter."
msgstr ""
"Заданная :ref:`роль <authentication-roles>`, выдаваемая пользователем "
"'admin' другим пользователям для получения всех прав на все объекты. Для "
"роли 'super' такие права выданы на 'universe': чтение, запись, "
"выполнение, создание, удаление, изменение."

#: ../doc/book/box/box_space.rst:2324
msgid ""
"To select a tuple from the ``_user`` space, use "
"``box.space._user:select()``. For example, here is what happens with a "
"select for user id = 0, which is the 'guest' user, which by default has "
"no password:"
msgstr ""
"Чтобы выбрать кортеж из спейса ``_user``, используйте "
"``box.space._user:select()``. Например, при выборке от пользователя с id "
"= 0, который является пользователем 'guest' без пароля по умолчанию, "
"произойдет следующее:"

#: ../doc/book/box/box_space.rst:2328
msgid ""
"tarantool> box.space._user:select{0}\n"
"---\n"
"- - [0, 1, 'guest', 'user']\n"
"..."
msgstr ""
"tarantool> box.space._user:select{0}\n"
"---\n"
"- - [0, 1, 'guest', 'user']\n"
"..."

#: ../doc/book/box/box_space.rst:2337
msgid ""
"To change tuples in the ``_user`` space, do not use ordinary "
"``box.space`` functions for insert or update or delete. The ``_user`` "
"space is special, so there are special functions which have appropriate "
"error checking."
msgstr ""
"Чтобы изменить кортежи в спейсе ``_user``, не пользуйтесь стандартными "
"функциями ``box.space`` для вставки, обновления или удаления. Речь идет "
"об особом спейсе ``_user``, поэтому есть особые функции с соответствующей"
" проверкой на ошибки."

#: ../doc/book/box/box_space.rst:2341
msgid ""
"To create a new user, use :ref:`box.schema.user.create() <box_schema-"
"user_create>`:"
msgstr ""
"Чтобы создать нового пользователя, используйте "
":ref:`box.schema.user.create() <box_schema-user_create>`:"

#: ../doc/book/box/box_space.rst:2380
msgid ""
"box.schema.user.create(*user-name*)\n"
"box.schema.user.create(*user-name*, {if_not_exists = true})\n"
"box.schema.user.create(*user-name*, {password = *password*})"
msgstr ""
"box.schema.user.create(*имя-пользователя*)\n"
"box.schema.user.create(*имя-пользователя*, {if_not_exists = true})\n"
"box.schema.user.create(*имя-пользователя*, {password = *пароль*})"

#: ../doc/book/box/box_space.rst:2350
msgid ""
"To change the user's password, use :ref:`box.schema.user.password() "
"<box_schema-user_password>`:"
msgstr ""
"Чтобы изменить пароль пользователя, воспользуйтесь "
":ref:`box.schema.user.password() <box_schema-user_password>`:"

#: ../doc/book/box/box_space.rst:2389
msgid ""
"-- To change the current user's password\n"
"box.schema.user.passwd(*password*)\n"
"\n"
"-- To change a different user's password\n"
"-- (usually only 'admin' can do it)\n"
"box.schema.user.passwd(*user-name*, *password*)"
msgstr ""
"-- Чтобы изменить пароль текущего пользователя\n"
"box.schema.user.passwd(*пароль*)\n"
"\n"
"-- Чтобы изменить пароль другого пользователя\n"
"-- (обычно это может делать только 'admin')\n"
"box.schema.user.passwd(*имя-пользователя*, *пароль*)"

#: ../doc/book/box/box_space.rst:2362
msgid "To drop a user, use :ref:`box.schema.user.drop() <box_schema-user_drop>`:"
msgstr ""
"Чтобы удалить пользователя, используйте :ref:`box.schema.user.drop() "
"<box_schema-user_drop>`:"

#: ../doc/book/box/box_space.rst:2401
msgid "box.schema.user.drop(*user-name*)"
msgstr "box.schema.user.drop(*имя-пользователя*)"

#: ../doc/book/box/box_space.rst:2369
msgid ""
"To check whether a user exists, use :ref:`box.schema.user.exists() "
"<box_schema-user_exists>`, which returns ``true`` or ``false``:"
msgstr ""
"Чтобы проверить, существует ли пользователь, воспользуйтесь "
":ref:`box.schema.user.exists() <box_schema-user_exists>`, которая вернет "
"``true`` (правда) или ``false`` (ложь):"

#: ../doc/book/box/box_space.rst:2409
msgid "box.schema.user.exists(*user-name*)"
msgstr "box.schema.user.exists(*имя-пользователя*)"

#: ../doc/book/box/box_space.rst:2377
msgid ""
"To find what privileges a user has, use :ref:`box.schema.user.info() "
"<box_schema-user_info>`:"
msgstr ""
"Чтобы узнать, какие права есть у пользователя, используйте "
":ref:`box.schema.user.info() <box_schema-user_info>`:"

#: ../doc/book/box/box_space.rst:2416
msgid "box.schema.user.info(*user-name*)"
msgstr "box.schema.user.info(*имя-пользователя*)"

#: ../doc/book/box/box_space.rst:2390
msgid ""
"Here is a session which creates a new user with a strong password, "
"selects a tuple in the ``_user`` space, and then drops the user."
msgstr ""
"Ниже представлена сессия, в рамках которой создается новый пользователь с"
" надежным паролем, выбирается кортеж из спейса ``_user``, а затем "
"пользователь удаляется."

#: ../doc/book/box/box_space.rst:2393
msgid ""
"tarantool> box.schema.user.create('JeanMartin', {password = "
"'Iwtso_6_os$$'})\n"
"---\n"
"...\n"
"tarantool> box.space._user.index.name:select{'JeanMartin'}\n"
"---\n"
"- - [17, 1, 'JeanMartin', 'user', {'chap-sha1': "
"'t3xjUpQdrt857O+YRvGbMY5py8Q='}]\n"
"...\n"
"tarantool> box.schema.user.drop('JeanMartin')\n"
"---\n"
"..."
msgstr ""
"tarantool> box.schema.user.create('JeanMartin', {password = "
"'Iwtso_6_os$$'})\n"
"---\n"
"...\n"
"tarantool> box.space._user.index.name:select{'JeanMartin'}\n"
"---\n"
"- - [17, 1, 'JeanMartin', 'user', {'chap-sha1': "
"'t3xjUpQdrt857O+YRvGbMY5py8Q='}]\n"
"...\n"
"tarantool> box.schema.user.drop('JeanMartin')\n"
"---\n"
"..."

#: ../doc/book/box/box_space.rst:2410
#, fuzzy
msgid "``_ck_constraint`` is a system space where check constraints are stored."
msgstr ""
"``_user`` -- это системный спейс, где хранятся имена пользователей и хеши"
" паролей."

#: ../doc/book/box/box_space.rst:2414
#, fuzzy
msgid "the numeric id of the space (\"space_id\"),"
msgstr "числовой идентификатор кортежа (\"id\"),"

#: ../doc/book/box/box_space.rst:2416
msgid "whether the check is deferred (\"is_deferred\"),"
msgstr ""

#: ../doc/book/box/box_space.rst:2417
msgid "the language of the expression, such as 'SQL',"
msgstr ""

#: ../doc/book/box/box_space.rst:2418
msgid "the expression (\"code\")"
msgstr ""

#: ../doc/book/box/box_space.rst:2422
msgid ""
"tarantool> box.space._ck_constraint:select()\n"
"---\n"
"- - [527, 'c1', false, 'SQL', '\"f2\" > ''A''']\n"
"  - [527, 'c2', false, 'SQL', '\"f2\" == UPPER(\"f3\") AND NOT \"f2\" "
"LIKE ''__''']\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:2432
msgid "Example: using box.space functions to read _space tuples"
msgstr "Пример: использование функций box.space для чтения кортежей из _space"

#: ../doc/book/box/box_space.rst:2434
msgid ""
"This function will illustrate how to look at all the spaces, and for each"
" display: approximately how many tuples it contains, and the first field "
"of its first tuple. The function uses Tarantool ``box.space`` functions "
"``len()`` and ``pairs()``. The iteration through the spaces is coded as a"
" scan of the ``_space`` system space, which contains metadata. The third "
"field in ``_space`` contains the space name, so the key instruction "
"``space_name = v[3]`` means ``space_name`` is the ``space_name`` field in"
" the tuple of ``_space`` that we've just fetched with ``pairs()``. The "
"function returns a table:"
msgstr ""
"Функция ниже проиллюстрирует, как обращаться ко всем спейсам, и для "
"каждого отобразит примерное количество кортежей и первое поле первого "
"кортежа. В данной функции используются функции из ``box.space`` в "
"Tarantool'е: ``len()`` и ``pairs()``. Итерация по спейсам закодирована в "
"форме сканирования системного спейса ``_space``, который содержит "
"метаданные. Третье поле в ``_space`` содержит имя спейса, поэтому "
"ключевая команда ``space_name = v[3]`` означает, что ``space_name`` -- "
"это поле ``space_name`` в кортеже ``_space``, который мы только что "
"получили с помощью ``pairs()``. Функция возвращает таблицу:"

#: ../doc/book/box/box_space.rst:2444
msgid ""
"function example()\n"
"  local tuple_count, space_name, line\n"
"  local ta = {}\n"
"  for k, v in box.space._space:pairs() do\n"
"    space_name = v[3]\n"
"    if box.space[space_name].index[0] ~= nil then\n"
"      tuple_count = '1 or more'\n"
"    else\n"
"      tuple_count = '0'\n"
"    end\n"
"    line = space_name .. ' tuple_count =' .. tuple_count\n"
"    if tuple_count == '1 or more' then\n"
"      for k1, v1 in box.space[space_name]:pairs() do\n"
"        line = line .. '. first field in first tuple = ' .. v1[1]\n"
"        break\n"
"      end\n"
"    end\n"
"    table.insert(ta, line)\n"
"  end\n"
"  return ta\n"
"end"
msgstr ""
"function example()\n"
"  local tuple_count, space_name, line\n"
"  local ta = {}\n"
"  for k, v in box.space._space:pairs() do\n"
"    space_name = v[3]\n"
"    if box.space[space_name].index[0] ~= nil then\n"
"      tuple_count = '1 or more'\n"
"    else\n"
"      tuple_count = '0'\n"
"    end\n"
"    line = space_name .. ' tuple_count =' .. tuple_count\n"
"    if tuple_count == '1 or more' then\n"
"      for k1, v1 in box.space[space_name]:pairs() do\n"
"        line = line .. '. first field in first tuple = ' .. v1[1]\n"
"        break\n"
"      end\n"
"    end\n"
"    table.insert(ta, line)\n"
"  end\n"
"  return ta\n"
"end"

#: ../doc/book/box/box_space.rst:2468
msgid "And here is what happens when one invokes the function:"
msgstr "А вот что происходит, когда вызывается функция:"

#: ../doc/book/box/box_space.rst:2470
msgid ""
"tarantool> example()\n"
"---\n"
"- - _schema tuple_count =1 or more. first field in first tuple = cluster\n"
"  - _space tuple_count =1 or more. first field in first tuple = 272\n"
"  - _vspace tuple_count =1 or more. first field in first tuple = 272\n"
"  - _index tuple_count =1 or more. first field in first tuple = 272\n"
"  - _vindex tuple_count =1 or more. first field in first tuple = 272\n"
"  - _func tuple_count =1 or more. first field in first tuple = 1\n"
"  - _vfunc tuple_count =1 or more. first field in first tuple = 1\n"
"  - _user tuple_count =1 or more. first field in first tuple = 0\n"
"  - _vuser tuple_count =1 or more. first field in first tuple = 0\n"
"  - _priv tuple_count =1 or more. first field in first tuple = 1\n"
"  - _vpriv tuple_count =1 or more. first field in first tuple = 1\n"
"  - _cluster tuple_count =1 or more. first field in first tuple = 1\n"
"..."
msgstr ""
"tarantool> example()\n"
"---\n"
"- - _schema tuple_count =1 or more. first field in first tuple = cluster\n"
"  - _space tuple_count =1 or more. first field in first tuple = 272\n"
"  - _vspace tuple_count =1 or more. first field in first tuple = 272\n"
"  - _index tuple_count =1 or more. first field in first tuple = 272\n"
"  - _vindex tuple_count =1 or more. first field in first tuple = 272\n"
"  - _func tuple_count =1 or more. first field in first tuple = 1\n"
"  - _vfunc tuple_count =1 or more. first field in first tuple = 1\n"
"  - _user tuple_count =1 or more. first field in first tuple = 0\n"
"  - _vuser tuple_count =1 or more. first field in first tuple = 0\n"
"  - _priv tuple_count =1 or more. first field in first tuple = 1\n"
"  - _vpriv tuple_count =1 or more. first field in first tuple = 1\n"
"  - _cluster tuple_count =1 or more. first field in first tuple = 1\n"
"..."

#: ../doc/book/box/box_space.rst:2490
msgid "Example: using box.space functions to organize a _space tuple"
msgstr "Пример: использование функций box.space для организации кортежа из _space"

#: ../doc/book/box/box_space.rst:2492
msgid ""
"The objective is to display field names and field types of a system space"
" -- using metadata to find metadata."
msgstr ""
"Основная цель -- отобразить имена и типы полей системного спейса, то есть"
" использование метаданных для поиска метаданных."

#: ../doc/book/box/box_space.rst:2495
msgid ""
"To begin: how can one select the ``_space`` tuple that describes "
"``_space``?"
msgstr ""
"Для начала: как можно сделать выборку кортежа из ``_space``, который "
"описывает ``_space``?"

#: ../doc/book/box/box_space.rst:2497
msgid ""
"A simple way is to look at the constants in ``box.schema``, which tell us"
" that there is an item named SPACE_ID == 288, so these statements will "
"retrieve the correct tuple:"
msgstr ""
"Проще всего проверить постоянные в ``box.schema``, что укажет на наличие "
"элемента под названием SPACE_ID == 288. Таким образом, следующие запросы "
"вернут нужный кортеж:"

#: ../doc/book/box/box_space.rst:2501
msgid ""
"box.space._space:select{ 288 }\n"
"-- or --\n"
"box.space._space:select{ box.schema.SPACE_ID }"
msgstr ""
"box.space._space:select{ 288 }\n"
"-- или --\n"
"box.space._space:select{ box.schema.SPACE_ID }"

#: ../doc/book/box/box_space.rst:2507
msgid ""
"Another way is to look at the tuples in ``box.space._index``, which tell "
"us that there is a secondary index named 'name' for space number 288, so "
"this statement also will retrieve the correct tuple:"
msgstr ""
"Также можно обратиться к спейсам в ``box.space._index``, что укажет на "
"наличие вторичного индекса с именем 'name' для спейса под номером 288. "
"Таким образом, следующий запрос также вернет нужный кортеж:"

#: ../doc/book/box/box_space.rst:2511
msgid "box.space._space.index.name:select{ '_space' }"
msgstr "box.space._space.index.name:select{ '_space' }"

#: ../doc/book/box/box_space.rst:2515
msgid "However, the retrieved tuple is not easy to read:"
msgstr "Однако непросто прочитать информацию из полученного кортежа:"

#: ../doc/book/box/box_space.rst:2517
msgid ""
"tarantool> box.space._space.index.name:select{'_space'}\n"
"---\n"
"- - [280, 1, '_space', 'memtx', 0, {}, [{'name': 'id', 'type': 'num'}, "
"{'name': 'owner',\n"
"        'type': 'num'}, {'name': 'name', 'type': 'str'}, {'name': "
"'engine', 'type': 'str'},\n"
"      {'name': 'field_count', 'type': 'num'}, {'name': 'flags', 'type': "
"'str'}, {\n"
"        'name': 'format', 'type': '*'}]]\n"
"..."
msgstr ""
"tarantool> box.space._space.index.name:select{'_space'}\n"
"---\n"
"- - [280, 1, '_space', 'memtx', 0, {}, [{'name': 'id', 'type': 'num'}, "
"{'name': 'owner',\n"
"        'type': 'num'}, {'name': 'name', 'type': 'str'}, {'name': "
"'engine', 'type': 'str'},\n"
"      {'name': 'field_count', 'type': 'num'}, {'name': 'flags', 'type': "
"'str'}, {\n"
"        'name': 'format', 'type': '*'}]]\n"
"..."

#: ../doc/book/box/box_space.rst:2527
msgid ""
"It looks disorganized because field number 7 has been formatted with "
"recommended names and data types. How can one get those specific sub-"
"fields? Since it's visible that field number 7 is an array of maps, this "
"`for` loop will do the organizing:"
msgstr ""
"Информация подается бессистемно, поскольку по формату поле №7 содержит "
"рекомендованные имена и типы данных. Как же получить эти данные? "
"Поскольку очевидно, что поле №7 представляет собой ассоциативный массив, "
"цикл `for` проведет организацию данных:"

#: ../doc/book/box/box_space.rst:2532
msgid ""
"tarantool> do\n"
"         >   local tuple_of_space = "
"box.space._space.index.name:get{'_space'}\n"
"         >   for _, field in ipairs(tuple_of_space[7]) do\n"
"         >     print(field.name .. ', ' .. field.type)\n"
"         >   end\n"
"         > end\n"
"id, num\n"
"owner, num\n"
"name, str\n"
"engine, str\n"
"field_count, num\n"
"flags, str\n"
"format, *\n"
"---\n"
"..."
msgstr ""
"tarantool> do\n"
"         >   local tuple_of_space = "
"box.space._space.index.name:get{'_space'}\n"
"         >   for _, field in ipairs(tuple_of_space[7]) do\n"
"         >     print(field.name .. ', ' .. field.type)\n"
"         >   end\n"
"         > end\n"
"id, num\n"
"owner, num\n"
"name, str\n"
"engine, str\n"
"field_count, num\n"
"flags, str\n"
"format, *\n"
"---\n"
"..."

#: ../doc/book/box/box_space.rst:2554
msgid ""
"``_vuser`` is a system space that represents a virtual view. The "
"structure of its tuples is identical to that of :ref:`_user <box_space-"
"user>`, but permissions for certain tuples are limited in accordance with"
" user privileges. ``_vuser`` contains only those tuples that are "
"accessible to the current user. See :ref:`Access control "
"<authentication>` for details about user privileges."
msgstr ""
"``_vuser`` -- это системный спейс, который реализует виртуальное "
"представление. Структура его кортежей совпадает со структурой кортежей в "
":ref:`_user <box_space-user>`, но права доступа на определенные кортежи "
"ограничены в соответствии с правами пользователя. ``_vuser`` содержит "
"только те кортежи, которые доступны текущему пользователю. Для получения "
"более подробной информации о правах пользователя см. раздел "
":ref:`Управление доступом <authentication>`."

#: ../doc/book/box/box_space.rst:2560
msgid ""
"If the user has the full set of privileges (like 'admin'), the contents "
"of ``_vuser`` match the contents of ``_user``. If the user has limited "
"access, ``_vuser`` contains only tuples accessible to this user."
msgstr ""
"Если у пользователя есть полный набор прав (как у пользователя 'admin'), "
"содержимое ``_vuser`` совпадает с содержимым ``_user``. Если же у "
"пользователя доступ ограничен, ``_vuser`` содержит только кортежи, "
"которые доступны текущему пользователю."

#: ../doc/book/box/box_space.rst:2564
msgid ""
"To see how ``_vuser`` works, :ref:`connect to a Tarantool database "
"remotely <connecting-remotely>` via ``tarantoolctl`` and select all "
"tuples from the ``_user`` space, both when the 'guest' user *is* and *is "
"not* allowed to read from the database."
msgstr ""
"Чтобы посмотреть, как работать с ``_vuser``, :ref:`удаленно подключитесь "
"к базе данных Tarantool'а <connecting-remotely>` с помощью "
"``tarantoolctl`` и сделайте выборку кортежей из спейса ``_user`` в "
"следующих ситуациях: когда пользователь 'guest' *имеет* и когда он *не "
"имеет* права выполнять чтение данных из базы."

#: ../doc/book/box/box_space.rst:2570
msgid ""
"First, start Tarantool and grant the 'guest' user with read, write and "
"execute privileges:"
msgstr ""
"Для начала запустите Tarantool и выдайте пользователю 'guest' права на "
"чтение, запись и выполнение:"

#: ../doc/book/box/box_space.rst:2573
msgid ""
"tarantool> box.cfg{listen = 3301}\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('guest', 'read,write,execute', "
"'universe')\n"
"---\n"
"..."
msgstr ""
"tarantool> box.cfg{listen = 3301}\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('guest', 'read,write,execute', "
"'universe')\n"
"---\n"
"..."

#: ../doc/book/box/box_space.rst:2582
msgid ""
"Switch to the other terminal, connect to the Tarantool instance and "
"select all tuples from the ``_user`` space:"
msgstr ""
"Перейдите на другой терминал, подключитесь к экземпляру Tarantool'а и "
"произведите выборку всех кортежей из спейса ``_user``:"

#: ../doc/book/box/box_space.rst:2585
msgid ""
"$ tarantoolctl connect 3301\n"
"localhost:3301> box.space._user:select{}\n"
"---\n"
"- - [0, 1, 'guest', 'user', {}]\n"
"  - [1, 1, 'admin', 'user', {}]\n"
"  - [2, 1, 'public', 'role', {}]\n"
"  - [3, 1, 'replication', 'role', {}]\n"
"  - [31, 1, 'super', 'role', {}]\n"
"..."
msgstr ""
"$ tarantoolctl connect 3301\n"
"localhost:3301> box.space._user:select{}\n"
"---\n"
"- - [0, 1, 'guest', 'user', {}]\n"
"  - [1, 1, 'admin', 'user', {}]\n"
"  - [2, 1, 'public', 'role', {}]\n"
"  - [3, 1, 'replication', 'role', {}]\n"
"  - [31, 1, 'super', 'role', {}]\n"
"..."

#: ../doc/book/box/box_space.rst:2597
msgid ""
"This result contains the same set of users as if you made the request "
"from your Tarantool instance as 'admin'."
msgstr ""
"Результат включает в себя тот же набор пользователей, как если бы вы "
"выполнили запрос от пользователя 'admin' на своем экземпляре Tarantool'а."

#: ../doc/book/box/box_space.rst:2600
msgid ""
"Switch to the first terminal and revoke the read privileges from the "
"'guest' user:"
msgstr ""
"Вернитесь в первый терминал и отмените права на чтение пользователю "
"'guest':"

#: ../doc/book/box/box_space.rst:2602
msgid ""
"tarantool> box.schema.user.revoke('guest', 'read', 'universe')\n"
"---\n"
"..."
msgstr ""
"tarantool> box.schema.user.revoke('guest', 'read', 'universe')\n"
"---\n"
"..."

#: ../doc/book/box/box_space.rst:2608
msgid ""
"Switch to the other terminal, stop the session (to stop ``tarantoolctl``,"
" type Ctrl+C or Ctrl+D) and repeat the ``box.space._user:select{}`` "
"request. The access is denied:"
msgstr ""
"Перейдите на другой терминал, остановите сессию (чтобы остановить "
"``tarantoolctl``, нажмите Ctrl+C или Ctrl+D) и повторите запрос "
"``box.space._user:select{}``. В доступе отказано:"

#: ../doc/book/box/box_space.rst:2612
msgid ""
"$ tarantoolctl connect 3301\n"
"localhost:3301> box.space._user:select{}\n"
"---\n"
"- error: Read access to space '_user' is denied for user 'guest'\n"
"..."
msgstr ""
"$ tarantoolctl connect 3301\n"
"localhost:3301> box.space._user:select{}\n"
"---\n"
"- error: Read access to space '_user' is denied for user 'guest'\n"
"..."

#: ../doc/book/box/box_space.rst:2620
msgid ""
"However, if you select from ``_vuser`` instead, the users' data available"
" for the 'guest' user is displayed:"
msgstr ""
"Тем не менее, если вместо этого произвести выборку из ``_vuser``, "
"отображаются данные пользователей, доступные пользователю 'guest':"

#: ../doc/book/box/box_space.rst:2623
msgid ""
"localhost:3301> box.space._vuser:select{}\n"
"---\n"
"- - [0, 1, 'guest', 'user', {}]\n"
"..."
msgstr ""
"localhost:3301> box.space._vuser:select{}\n"
"---\n"
"- - [0, 1, 'guest', 'user', {}]\n"
"..."

#: ../doc/book/box/box_space.rst:2632
msgid "``_vuser`` is a system view, so it allows only read requests."
msgstr ""
"``_vuser`` -- это виртуальное представление системы, поэтому допускаются "
"только запросы на чтение."

#: ../doc/book/box/box_space.rst:2633
msgid ""
"While the ``_user`` space requires proper access privileges, any user can"
" always read from ``_vuser``."
msgstr ""
"Если спейс ``_user`` требует наличия соответствующих прав доступа, то "
"любой пользователь всегда может выполнить чтение из ``_vuser``."

#: ../doc/book/box/box_space.rst:2641
msgid ""
"``_collation`` is a system space with a list of :ref:`collations <index-"
"collation>`. There are over 270 built-in collations and users may add "
"more. Here is one example:"
msgstr ""

#: ../doc/book/box/box_space.rst:2644
#, fuzzy
msgid ""
"localhost:3301> box.space._collation:select(239)\n"
"---\n"
"- - [239, 'unicode_uk_s2', 1, 'ICU', 'uk', {'strength': 'secondary'}]\n"
"..."
msgstr ""
"localhost:3301> box.space._vuser:select{}\n"
"---\n"
"- - [0, 1, 'guest', 'user', {}]\n"
"..."

#: ../doc/book/box/box_space.rst:2651
msgid ""
"Explanation of the fields in the example: id = 239 i.e. Tarantool's "
"primary key is 239, name = 'unicode_uk_s2' i.e. according to Tarantool's "
"naming convention this is a Unicode collation + it is for the uk locale +"
" it has secondary strength, owner = 1 i.e. :ref:`the admin user "
"<authentication-owners_privileges>`, type = 'ICU' i.e. the rules are "
"according to `International Components for Unicode <http://site.icu-"
"project.org/home>`_, locale = 'uk' i.e. `Ukrainian "
"<http://www.unicode.org/cldr/charts/29/collation/uk.html>`_, opts = "
"'strength:secondary' i.e. with this collation comparisons use both "
"primary and secondary `weights "
"<https://unicode.org/reports/tr10/#Weight_Level_Defn>`_."
msgstr ""

#: ../doc/book/box/box_space.rst:2664
msgid ""
"``_vcollation`` is a system space with a list of :ref:`collations <index-"
"collation>`. The structure of its tuples is identical to that of "
":ref:`box.space._collation <box_space-collation>`, but permissions for "
"certain tuples are limited in accordance with user privileges."
msgstr ""

#: ../doc/book/box/box_space.rst:2673
msgid "Example: using data operations"
msgstr "Пример: использование операций с данными"

#: ../doc/book/box/box_space.rst:2675
msgid ""
"This example demonstrates all legal scenarios -- as well as typical "
"errors -- for each :ref:`data operation <index-box_data-operations>` in "
"Tarantool: :ref:`INSERT <box_space-operations-insert>`, :ref:`DELETE "
"<box_space-operations-delete>`, :ref:`UPDATE <box_space-operations-"
"update>`, :ref:`UPSERT <box_space-operations-upsert>`, :ref:`REPLACE "
"<box_space-operations-replace>`, and :ref:`SELECT <box_space-operations-"
"select>`."
msgstr ""
"Пример ниже иллюстрирует все возможные сценарии -- а также типичные "
"ошибки -- для всех :ref:`операций с данными <index-box_data-operations>` "
"в Tarantool'е: :ref:`INSERT <box_space-operations-insert>`, :ref:`DELETE "
"<box_space-operations-delete>`, :ref:`UPDATE <box_space-operations-"
"update>`, :ref:`UPSERT <box_space-operations-upsert>`, :ref:`REPLACE "
"<box_space-operations-replace>` и :ref:`SELECT <box_space-operations-"
"select>`."

#: ../doc/book/box/box_space.rst:2684
#, fuzzy
msgid ""
"-- Bootstrap the database --\n"
"box.cfg{}\n"
"format = {}\n"
"format[1] = {'field1', 'unsigned'}\n"
"format[2] = {'field2', 'unsigned'}\n"
"format[3] = {'field3', 'unsigned'}\n"
"s = box.schema.create_space('test', {format = format})\n"
"-- Create a primary index --\n"
"pk = s:create_index('pk', {parts = {{field = 'field1'}}})\n"
"-- Create a unique secondary index --\n"
"sk_uniq = s:create_index('sk_uniq', {parts = {{field = 'field2'}}})\n"
"-- Create a non-unique secondary index --\n"
"sk_non_uniq = s:create_index('sk_non_uniq', {parts = {{field = "
"'field3'}}, unique = false})"
msgstr ""
"-- Настройка базы данных --\n"
"box.cfg{}\n"
"format = {}\n"
"format[1] = {'field1', 'unsigned'}\n"
"format[2] = {'field2', 'unsigned'}\n"
"format[3] = {'field3', 'unsigned'}\n"
"s = box.schema.create_space('test', {format = format})\n"
"-- Создание первичного индекса --\n"
"pk = s:create_index('pk', {parts = {{'field1'}}})\n"
"-- Создание уникального вторичного индекса --\n"
"sk_uniq = s:create_index('sk_uniq', {parts = {{'field2'}}})\n"
"-- Создание неуникального вторичного индекса --\n"
"sk_non_uniq = s:create_index('sk_non_uniq', {parts = {{'field3'}}, unique"
" = false})"

#: ../doc/book/box/box_space.rst:2704
msgid "INSERT"
msgstr "INSERT"

#: ../doc/book/box/box_space.rst:2706
msgid ""
"``insert`` accepts a well-formatted tuple and checks all keys for "
"duplicates."
msgstr ""
"Операция ``insert`` (вставка) работает с кортежами с четким форматом и "
"проверяет все ключи на наличие совпадений."

#: ../doc/book/box/box_space.rst:2708
msgid ""
"tarantool> -- Unique indexes: ok --\n"
"tarantool> s:insert({1, 1, 1})\n"
"---\n"
"- [1, 1, 1]\n"
"...\n"
"tarantool> -- Conflicting primary key: error --\n"
"tarantool> s:insert({1, 1, 1})\n"
"---\n"
"- error: Duplicate key exists in unique index 'pk' in space 'test'\n"
"...\n"
"tarantool> -- Conflicting unique secondary key: error --\n"
"tarantool> s:insert({2, 1, 1})\n"
"---\n"
"- error: Duplicate key exists in unique index 'sk_uniq' in space 'test'\n"
"...\n"
"tarantool> -- Key {1} exists in sk_non_uniq index, but it is not unique: "
"ok --\n"
"tarantool> s:insert({2, 2, 1})\n"
"---\n"
"- [2, 2, 1]\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."
msgstr ""
"tarantool> -- Уникальные индексы: разрешено --\n"
"tarantool> s:insert({1, 1, 1})\n"
"---\n"
"- [1, 1, 1]\n"
"...\n"
"tarantool> -- Конфликт первичного ключа: ошибка --\n"
"tarantool> s:insert({1, 1, 1})\n"
"---\n"
"- error: Duplicate key exists in unique index 'pk' in space 'test'\n"
"...\n"
"tarantool> -- Конфликт уникального вторичного ключа: ошибка --\n"
"tarantool> s:insert({2, 1, 1})\n"
"---\n"
"- error: Duplicate key exists in unique index 'sk_uniq' in space 'test'\n"
"...\n"
"tarantool> -- Ключ {1} присутствует в индексе sk_non_uniq, но он не "
"уникален: разрешено --\n"
"tarantool> s:insert({2, 2, 1})\n"
"---\n"
"- [2, 2, 1]\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."

#: ../doc/book/box/box_space.rst:2738 ../doc/book/box/engines/vinyl.rst:139
msgid "DELETE"
msgstr "DELETE"

#: ../doc/book/box/box_space.rst:2740
msgid "``delete`` accepts a full key of any unique index."
msgstr ""
"``delete`` (удаление) работает с полными ключами любого уникального "
"индекса."

#: ../doc/book/box/box_space.rst:2742
msgid "``space:delete`` is an alias for \"delete by primary key\"."
msgstr ""
"``space:delete`` -- это псевдоним для операции \"удалить по первичному "
"ключу\"."

#: ../doc/book/box/box_space.rst:2744
msgid ""
"tarantool> -- Insert some test data --\n"
"tarantool> s:insert{3, 4, 5}\n"
"---\n"
"- [3, 4, 5]\n"
"...\n"
"tarantool> s:insert{6, 7, 8}\n"
"---\n"
"- [6, 7, 8]\n"
"...\n"
"tarantool> s:insert{9, 10, 11}\n"
"---\n"
"- [9, 10, 11]\n"
"...\n"
"tarantool> s:insert{12, 13, 14}\n"
"---\n"
"- [12, 13, 14]\n"
"...\n"
"tarantool> -- Nothing done here: no {4} key in pk index --\n"
"tarantool> s:delete{4}\n"
"---\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 4, 5]\n"
"  - [6, 7, 8]\n"
"  - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Delete by a primary key: ok --\n"
"tarantool> s:delete{3}\n"
"---\n"
"- [3, 4, 5]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [6, 7, 8]\n"
"  - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Explicitly delete by a primary key: ok --\n"
"tarantool> s.index.pk:delete{6}\n"
"---\n"
"- [6, 7, 8]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Delete by a unique secondary key: ok --\n"
"s.index.sk_uniq:delete{10}\n"
"---\n"
"- [9, 10, 11]\n"
"...\n"
"s:select{}\n"
"---\n"
"- - [12, 13, 14]\n"
"...\n"
"tarantool> -- Delete by a non-unique secondary index: error --\n"
"tarantool> s.index.sk_non_uniq:delete{14}\n"
"---\n"
"- error: Get() doesn't support partial keys and non-unique indexes\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [12, 13, 14]\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."
msgstr ""
"tarantool> -- Вставить некоторые тестовые данные --\n"
"tarantool> s:insert{3, 4, 5}\n"
"---\n"
"- [3, 4, 5]\n"
"...\n"
"tarantool> s:insert{6, 7, 8}\n"
"---\n"
"- [6, 7, 8]\n"
"...\n"
"tarantool> s:insert{9, 10, 11}\n"
"---\n"
"- [9, 10, 11]\n"
"...\n"
"tarantool> s:insert{12, 13, 14}\n"
"---\n"
"- [12, 13, 14]\n"
"...\n"
"tarantool> -- Здесь ничего не происходит: нет ключа {4} в индексе pk --\n"
"tarantool> s:delete{4}\n"
"---\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 4, 5]\n"
"  - [6, 7, 8]\n"
"  - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Удалить по первичному ключу: разрешено --\n"
"tarantool> s:delete{3}\n"
"---\n"
"- [3, 4, 5]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [6, 7, 8]\n"
"  - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Точно удалить по первичному ключу: разрешено --\n"
"tarantool> s.index.pk:delete{6}\n"
"---\n"
"- [6, 7, 8]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Удалить по уникальному вторичному ключу: разрешено --\n"
"s.index.sk_uniq:delete{10}\n"
"---\n"
"- [9, 10, 11]\n"
"...\n"
"s:select{}\n"
"---\n"
"- - [12, 13, 14]\n"
"...\n"
"tarantool> -- Удалить по неуникальному вторичному индексу: ошибка --\n"
"tarantool> s.index.sk_non_uniq:delete{14}\n"
"---\n"
"- error: Get() doesn't support partial keys and non-unique indexes\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [12, 13, 14]\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."

#: ../doc/book/box/box_space.rst:2817
msgid "The key must be full: ``delete`` cannot work with partial keys."
msgstr ""
"Ключ должен быть полным: операция ``delete`` не работает с компонентами "
"ключа."

#: ../doc/book/box/box_space.rst:2819
#, fuzzy
msgid ""
"tarantool> s2 = box.schema.create_space('test2')\n"
"---\n"
"...\n"
"tarantool> pk2 = s2:create_index('pk2', {parts = {{field = 1, type = "
"'unsigned'}, {field = 2, type = 'unsigned'}}})\n"
"---\n"
"...\n"
"tarantool> s2:insert{1, 1}\n"
"---\n"
"- [1, 1]\n"
"...\n"
"tarantool> -- Delete by a partial key: error --\n"
"tarantool> s2:delete{1}\n"
"---\n"
"- error: Invalid key part count in an exact match (expected 2, got 1)\n"
"...\n"
"tarantool> -- Delete by a full key: ok --\n"
"tarantool> s2:delete{1, 1}\n"
"---\n"
"- [1, 1]\n"
"...\n"
"tarantool> s2:select{}\n"
"---\n"
"- []\n"
"...\n"
"tarantool> s2:drop()\n"
"---\n"
"..."
msgstr ""
"tarantool> s2 = box.schema.create_space('test2')\n"
"---\n"
"...\n"
"tarantool> pk2 = s2:create_index('pk2', {parts = {{1, 'unsigned'}, {2, "
"'unsigned'}}})\n"
"---\n"
"...\n"
"tarantool> s2:insert{1, 1}\n"
"---\n"
"- [1, 1]\n"
"...\n"
"tarantool> -- Удалить по компоненту ключа: ошибка --\n"
"tarantool> s2:delete{1}\n"
"---\n"
"- error: Invalid key part count in an exact match (expected 2, got 1)\n"
"...\n"
"tarantool> -- Удалить по ключу целиком: разрешено --\n"
"tarantool> s2:delete{1, 1}\n"
"---\n"
"- [1, 1]\n"
"...\n"
"tarantool> s2:select{}\n"
"---\n"
"- []\n"
"...\n"
"tarantool> s2:drop()\n"
"---\n"
"..."

#: ../doc/book/box/box_space.rst:2853
msgid "UPDATE"
msgstr "UPDATE"

#: ../doc/book/box/box_space.rst:2855
msgid ""
"Similarly to ``delete``, ``update`` accepts a full key of any unique "
"index, and also the operations to execute."
msgstr ""
"Как и ``delete``, ``update`` работает с полными ключами любого "
"уникального индекса, а также выполняет операции."

#: ../doc/book/box/box_space.rst:2858
msgid "``space:update`` is an alias for \"update by primary key\"."
msgstr ""
"``space:update`` -- это псевдоним для операции \"обновить по первичному "
"ключу\"."

#: ../doc/book/box/box_space.rst:2860
msgid ""
"tarantool> -- Insert some test data --\n"
"tarantool> s:insert{3, 4, 5}\n"
"---\n"
"- [3, 4, 5]\n"
"...\n"
"tarantool> s:insert{6, 7, 8}\n"
"---\n"
"- [6, 7, 8]\n"
"...\n"
"tarantool> s:insert{9, 10, 11}\n"
"---\n"
"- [9, 10, 11]\n"
"...\n"
"tarantool> s:insert{12, 13, 14}\n"
"---\n"
"- [12, 13, 14]\n"
"...\n"
"tarantool> -- Nothing done here: no {4} key in pk index --\n"
"s:update({4}, {{'=', 2, 400}})\n"
"---\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 4, 5]\n"
"  - [6, 7, 8]\n"
"  - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Update by a primary key: ok --\n"
"tarantool> s:update({3}, {{'=', 2, 400}})\n"
"---\n"
"- [3, 400, 5]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 400, 5]\n"
"  - [6, 7, 8]\n"
"  - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Explicitly update by a primary key: ok --\n"
"tarantool> s.index.pk:update({6}, {{'=', 2, 700}})\n"
"---\n"
"- [6, 700, 8]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 400, 5]\n"
"  - [6, 700, 8]\n"
"  - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Update by a unique secondary key: ok --\n"
"tarantool> s.index.sk_uniq:update({10}, {{'=', 2, 1000}})\n"
"---\n"
"- [9, 1000, 11]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 400, 5]\n"
"  - [6, 700, 8]\n"
"  - [9, 1000, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Update by a non-unique secondary key: error --\n"
"tarantool> s.index.sk_non_uniq:update({14}, {{'=', 2, 1300}})\n"
"---\n"
"- error: Get() doesn't support partial keys and non-unique indexes\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 400, 5]\n"
"  - [6, 700, 8]\n"
"  - [9, 1000, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."
msgstr ""
"tarantool> -- Вставить некоторые тестовые данные --\n"
"tarantool> s:insert{3, 4, 5}\n"
"---\n"
"- [3, 4, 5]\n"
"...\n"
"tarantool> s:insert{6, 7, 8}\n"
"---\n"
"- [6, 7, 8]\n"
"...\n"
"tarantool> s:insert{9, 10, 11}\n"
"---\n"
"- [9, 10, 11]\n"
"...\n"
"tarantool> s:insert{12, 13, 14}\n"
"---\n"
"- [12, 13, 14]\n"
"...\n"
"tarantool> -- Здесь ничего не происходит: нет ключа {4} в индексе pk --\n"
"s:update({4}, {{'=', 2, 400}})\n"
"---\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 4, 5]\n"
"  - [6, 7, 8]\n"
"  - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Обновить по первичному ключу: разрешено --\n"
"tarantool> s:update({3}, {{'=', 2, 400}})\n"
"---\n"
"- [3, 400, 5]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 400, 5]\n"
"  - [6, 7, 8]\n"
"  - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Точно обновить по первичному ключу: разрешено --\n"
"tarantool> s.index.pk:update({6}, {{'=', 2, 700}})\n"
"---\n"
"- [6, 700, 8]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 400, 5]\n"
"  - [6, 700, 8]\n"
"  - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Обновить по уникальному вторичному ключу: разрешено --\n"
"tarantool> s.index.sk_uniq:update({10}, {{'=', 2, 1000}})\n"
"---\n"
"- [9, 1000, 11]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 400, 5]\n"
"  - [6, 700, 8]\n"
"  - [9, 1000, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Обновить по неуникальному вторичному ключу: ошибка --\n"
"tarantool> s.index.sk_non_uniq:update({14}, {{'=', 2, 1300}})\n"
"---\n"
"- error: Get() doesn't support partial keys and non-unique indexes\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 400, 5]\n"
"  - [6, 700, 8]\n"
"  - [9, 1000, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."

#: ../doc/book/box/box_space.rst:2946 ../doc/book/box/engines/vinyl.rst:140
msgid "UPSERT"
msgstr "UPSERT"

#: ../doc/book/box/box_space.rst:2948
msgid "``upsert`` accepts a well-formatted tuple and update operations."
msgstr ""
"``upsert`` (обновление и вставка) работает с кортежами с четким форматом "
"и выполняет операции обновления."

#: ../doc/book/box/box_space.rst:2950
msgid ""
"If an old tuple is found by the primary key of the specified tuple, then "
"the update operations are applied to the old tuple, and the new tuple is "
"ignored."
msgstr ""
"Если найден старый кортеж по первичному ключу, то операции обновления "
"применяются к старому кортежу, а новый кортеж игнорируется."

#: ../doc/book/box/box_space.rst:2954
msgid ""
"If no old tuple is found, then the new tuple is inserted, and the update "
"operations are **ignored**."
msgstr ""
"Если старый кортеж не найден, то происходит вставка нового кортежа, а "
"операции обновления **игнорируются**."

#: ../doc/book/box/box_space.rst:2957
msgid "Indexes have no ``upsert`` method - this is a method of a space."
msgstr "Для индексов нет метода ``upsert`` -- это метод для спейса."

#: ../doc/book/box/box_space.rst:2959
msgid ""
"tarantool> s.index.pk.upsert == nil\n"
"---\n"
"- true\n"
"...\n"
"tarantool> s.index.sk_uniq.upsert == nil\n"
"---\n"
"- true\n"
"...\n"
"tarantool> s.upsert ~= nil\n"
"---\n"
"- true\n"
"...\n"
"tarantool> -- As the first argument, upsert accepts --\n"
"tarantool> -- a well-formatted tuple, NOT a key! --\n"
"tarantool> s:insert{1, 2, 3}\n"
"---\n"
"- [1, 2, 3]\n"
"...\n"
"tarantool> s:upsert({1}, {{'=', 2, 200}})\n"
"---\n"
"- error: Tuple field count 1 is less than required by space format or "
"defined indexes\n"
"    (expected at least 3)\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 2, 3]\n"
"...\n"
"tarantool> s:delete{1}\n"
"---\n"
"- [1, 2, 3]\n"
"..."
msgstr ""
"tarantool> s.index.pk.upsert == nil\n"
"---\n"
"- true\n"
"...\n"
"tarantool> s.index.sk_uniq.upsert == nil\n"
"---\n"
"- true\n"
"...\n"
"tarantool> s.upsert ~= nil\n"
"---\n"
"- true\n"
"...\n"
"tarantool> -- В качестве первого аргумента upsert принимает --\n"
"tarantool> -- кортеж с четким форматом, НЕ ключ! --\n"
"tarantool> s:insert{1, 2, 3}\n"
"---\n"
"- [1, 2, 3]\n"
"...\n"
"tarantool> s:upsert({1}, {{'=', 2, 200}})\n"
"---\n"
"- error: Tuple field count 1 is less than required by space format or "
"defined indexes\n"
"    (expected at least 3)\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 2, 3]\n"
"...\n"
"tarantool> s:delete{1}\n"
"---\n"
"- [1, 2, 3]\n"
"..."

#: ../doc/book/box/box_space.rst:2993
msgid ""
"``upsert`` turns into ``insert`` when no old tuple is found by the "
"primary key."
msgstr ""
"``upsert`` превращается в ``insert``, когда старый кортеж не найден по "
"первичному ключу."

#: ../doc/book/box/box_space.rst:2995
msgid ""
"tarantool> s:upsert({1, 2, 3}, {{'=', 2, 200}})\n"
"---\n"
"...\n"
"tarantool> -- As you can see, {1, 2, 3} were inserted, --\n"
"tarantool> -- and the update operations were not applied. --\n"
"s:select{}\n"
"---\n"
"- - [1, 2, 3]\n"
"...\n"
"tarantool> -- Performing another upsert with the same primary key, --\n"
"tarantool> -- but different values in the other fields. --\n"
"s:upsert({1, 20, 30}, {{'=', 2, 200}})\n"
"---\n"
"...\n"
"tarantool> -- The old tuple was found by the primary key {1} --\n"
"tarantool> -- and update operations were applied. --\n"
"tarantool> -- The new tuple was ignored. --\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 200, 3]\n"
"..."
msgstr ""
"tarantool> s:upsert({1, 2, 3}, {{'=', 2, 200}})\n"
"---\n"
"...\n"
"tarantool> -- Как можно увидеть, произошла вставка {1, 2, 3}, --\n"
"tarantool> -- а операции обновления не применились. --\n"
"s:select{}\n"
"---\n"
"- - [1, 2, 3]\n"
"...\n"
"tarantool> -- Еще одна операция upsert с тем же первичным ключом, --\n"
"tarantool> -- но другими значениями прочих полей. --\n"
"s:upsert({1, 20, 30}, {{'=', 2, 200}})\n"
"---\n"
"...\n"
"tarantool> -- Старый кортеж был найден по первичному ключу {1}, --\n"
"tarantool> -- и применились операции обновления. --\n"
"tarantool> -- Новый кортеж игнорируется. --\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 200, 3]\n"
"..."

#: ../doc/book/box/box_space.rst:3019
msgid ""
"``upsert`` searches for an old tuple by the primary index, NOT by a "
"secondary index. This can lead to a duplication error if the new tuple "
"ruins the uniqueness of a secondary index."
msgstr ""
"``upsert`` ищет старый кортеж по первичному индексу, НЕ по вторичному. "
"Это может привести к ошибкам с дубликатами, если новый кортеж нарушает "
"уникальность вторичного индекса."

#: ../doc/book/box/box_space.rst:3023
msgid ""
"tarantool> s:upsert({2, 200, 3}, {{'=', 3, 300}})\n"
"---\n"
"- error: Duplicate key exists in unique index 'sk_uniq' in space 'test'\n"
"...\n"
"s:select{}\n"
"---\n"
"- - [1, 200, 3]\n"
"...\n"
"tarantool> -- But this works, when uniqueness is preserved. --\n"
"tarantool> s:upsert({2, 0, 0}, {{'=', 3, 300}})\n"
"---\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 200, 3]\n"
"  - [2, 0, 0]\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."
msgstr ""
"tarantool> s:upsert({2, 200, 3}, {{'=', 3, 300}})\n"
"---\n"
"- error: Duplicate key exists in unique index 'sk_uniq' in space 'test'\n"
"...\n"
"s:select{}\n"
"---\n"
"- - [1, 200, 3]\n"
"...\n"
"tarantool> -- Но сработает, если сохраняется уникальность. --\n"
"tarantool> s:upsert({2, 0, 0}, {{'=', 3, 300}})\n"
"---\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 200, 3]\n"
"  - [2, 0, 0]\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."

#: ../doc/book/box/box_space.rst:3050 ../doc/book/box/engines/vinyl.rst:138
msgid "REPLACE"
msgstr "REPLACE"

#: ../doc/book/box/box_space.rst:3052
msgid ""
"``replace`` accepts a well-formatted tuple and searches for an old tuple "
"by the primary key of the new tuple."
msgstr ""
"``replace`` (замена) работает с кортежами с четким форматом и ищет старый"
" кортеж по первичному ключу нового кортежа."

#: ../doc/book/box/box_space.rst:3055
msgid ""
"If the old tuple is found, then it is deleted, and the new tuple is "
"inserted."
msgstr ""
"Если найден старый кортеж, то происходит удаление старого кортежа и "
"вставка нового."

#: ../doc/book/box/box_space.rst:3057
msgid "If the old tuple was not found, then just the new tuple is inserted."
msgstr "Если старый кортеж не найден, вставляется новый кортеж."

#: ../doc/book/box/box_space.rst:3059
msgid ""
"tarantool> s:replace{1, 2, 3}\n"
"---\n"
"- [1, 2, 3]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 2, 3]\n"
"...\n"
"tarantool> s:replace{1, 3, 4}\n"
"---\n"
"- [1, 3, 4]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 3, 4]\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."
msgstr ""
"tarantool> s:replace{1, 2, 3}\n"
"---\n"
"- [1, 2, 3]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 2, 3]\n"
"...\n"
"tarantool> s:replace{1, 3, 4}\n"
"---\n"
"- [1, 3, 4]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 3, 4]\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."

#: ../doc/book/box/box_space.rst:3081
msgid "``replace`` can ruin unique constraints, like ``upsert`` does."
msgstr "Как и ``upsert``, ``replace`` может нарушить требования уникальности."

#: ../doc/book/box/box_space.rst:3083
msgid ""
"tarantool> s:insert{1, 1, 1}\n"
"---\n"
"- [1, 1, 1]\n"
"...\n"
"tarantool> s:insert{2, 2, 2}\n"
"---\n"
"- [2, 2, 2]\n"
"...\n"
"tarantool> -- This replace fails, because if the new tuple {1, 2, 0} "
"replaces --\n"
"tarantool> -- the old tuple by the primary key from 'pk' index {1, 1, 1},"
" --\n"
"tarantool> -- this results in a duplicate unique secondary key in "
"'sk_uniq' index: --\n"
"tarantool> -- key {2} is used both in the new tuple and in {2, 2, 2}. --\n"
"tarantool> s:replace{1, 2, 0}\n"
"---\n"
"- error: Duplicate key exists in unique index 'sk_uniq' in space 'test'\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."
msgstr ""
"tarantool> s:insert{1, 1, 1}\n"
"---\n"
"- [1, 1, 1]\n"
"...\n"
"tarantool> s:insert{2, 2, 2}\n"
"---\n"
"- [2, 2, 2]\n"
"...\n"
"tarantool> -- Такая замена не сработает, поскольку замена новым кортежем "
"{1, 2, 0} --\n"
"tarantool> -- старого кортежа по первичному ключу из индекса 'pk' {1, 1, "
"1}, --\n"
"tarantool> -- приведет к созданию дубликата уникального вторичного ключа "
"в индексе 'sk_uniq': --\n"
"tarantool> -- ключ {2} используется и в новом кортеже, и в {2, 2, 2}. --\n"
"tarantool> s:replace{1, 2, 0}\n"
"---\n"
"- error: Duplicate key exists in unique index 'sk_uniq' in space 'test'\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."

#: ../doc/book/box/box_space.rst:3109
msgid "SELECT"
msgstr "SELECT"

#: ../doc/book/box/box_space.rst:3111
msgid ""
"``select`` works with any indexes (primary/secondary) and with any keys "
"(unique/non-unique, full/partial)."
msgstr ""
"``select`` (выборка) работает с любыми индексами (первичными/вторичными) "
"и с любыми ключами (уникальными/неуникальными, полными/компонентами)."

#: ../doc/book/box/box_space.rst:3114
msgid ""
"If a key is partial, then ``select`` searches by all keys, where the "
"prefix matches the specified key part."
msgstr ""
"Если задан компонент ключа, ``select`` выполняет поиск всех ключей, "
"префикс которых совпадает с указанным компонентом ключа."

#: ../doc/book/box/box_space.rst:3117
msgid ""
"tarantool> s:insert{1, 2, 3}\n"
"---\n"
"- [1, 2, 3]\n"
"...\n"
"tarantool> s:insert{4, 5, 6}\n"
"---\n"
"- [4, 5, 6]\n"
"...\n"
"tarantool> s:insert{7, 8, 9}\n"
"---\n"
"- [7, 8, 9]\n"
"...\n"
"tarantool> s:insert{10, 11, 9}\n"
"---\n"
"- [10, 11, 9]\n"
"...\n"
"tarantool> s:select{1}\n"
"---\n"
"- - [1, 2, 3]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 2, 3]\n"
"  - [4, 5, 6]\n"
"  - [7, 8, 9]\n"
"  - [10, 11, 9]\n"
"...\n"
"tarantool> s.index.pk:select{4}\n"
"---\n"
"- - [4, 5, 6]\n"
"...\n"
"tarantool> s.index.sk_uniq:select{8}\n"
"---\n"
"- - [7, 8, 9]\n"
"...\n"
"tarantool> s.index.sk_non_uniq:select{9}\n"
"---\n"
"- - [7, 8, 9]\n"
"  - [10, 11, 9]\n"
"..."
msgstr ""
"tarantool> s:insert{1, 2, 3}\n"
"---\n"
"- [1, 2, 3]\n"
"...\n"
"tarantool> s:insert{4, 5, 6}\n"
"---\n"
"- [4, 5, 6]\n"
"...\n"
"tarantool> s:insert{7, 8, 9}\n"
"---\n"
"- [7, 8, 9]\n"
"...\n"
"tarantool> s:insert{10, 11, 9}\n"
"---\n"
"- [10, 11, 9]\n"
"...\n"
"tarantool> s:select{1}\n"
"---\n"
"- - [1, 2, 3]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 2, 3]\n"
"  - [4, 5, 6]\n"
"  - [7, 8, 9]\n"
"  - [10, 11, 9]\n"
"...\n"
"tarantool> s.index.pk:select{4}\n"
"---\n"
"- - [4, 5, 6]\n"
"...\n"
"tarantool> s.index.sk_uniq:select{8}\n"
"---\n"
"- - [7, 8, 9]\n"
"...\n"
"tarantool> s.index.sk_non_uniq:select{9}\n"
"---\n"
"- - [7, 8, 9]\n"
"  - [10, 11, 9]\n"
"..."

#: ../doc/book/box/box_sql.rst:5
#, fuzzy
msgid "Functions for SQL"
msgstr "Функции"

#: ../doc/book/box/box_sql.rst:7
msgid "The ``box`` module contains two functions related to SQL:"
msgstr ""

#: ../doc/book/box/box_sql.rst:9
msgid ""
"``box.internal.sql_create_function`` -- for making Lua functions callable"
" from SQL statements. This, or an SQL statement with the same effect, "
"will be part of the documentation regarding SQL Plus Lua."
msgstr ""

#: ../doc/book/box/box_sql.rst:13
msgid "``box.execute`` -- for making SQL statements callable from Lua functions."
msgstr ""

#: ../doc/book/box/box_sql.rst:15
msgid ""
"Some SQL statements are illustrated in the :ref:`SQL tutorial "
"<sql_tutorial>`."
msgstr ""

#: ../doc/book/box/box_sql.rst:21
msgid "Execute the SQL statement contained in the sql-statement parameter."
msgstr ""

#: ../doc/book/box/box_sql.rst:23
#, fuzzy
msgid "statement, which should conform to the rules for SQL grammar"
msgstr ""
"имя функции, которое должно соответствовать :ref:`правилам именования "
"объектов <app_server-names>`"

#: ../doc/book/box/box_sql.rst:24
msgid "optional list for placeholders in the statement"
msgstr ""

#: ../doc/book/box/box_sql.rst:26
#, fuzzy
msgid "depends on statement"
msgstr "Оператор определения схемы"

#: ../doc/book/box/box_sql.rst:28
msgid "There are two ways to pass extra parameters for ``box.execute()``:"
msgstr ""

#: ../doc/book/box/box_sql.rst:30
msgid ""
"The first way is to concatenate strings. For example, this Lua script "
"will insert 10 rows with different primary-key values into table t:"
msgstr ""

#: ../doc/book/box/box_sql.rst:34
msgid ""
"for i=1,10,1 do\n"
"  box.execute(\"insert into t values (\" .. i .. \")\")\n"
"end"
msgstr ""

#: ../doc/book/box/box_sql.rst:40
msgid ""
"The second way is to put one or more placeholder \"?\" tokens inside the "
"string, and pass a second argument, which must be a table containing "
"values for each placeholder. For example these two requests are "
"equivalent:"
msgstr ""

#: ../doc/book/box/box_sql.rst:44
msgid ""
"box.execute([[INSERT INTO tt VALUES (1,'x');]]);\n"
"x = {1,'x'}; box.execute([[INSERT INTO tt VALUES (?,?);]], x);"
msgstr ""

#: ../doc/book/box/box_sql.rst:49
msgid ""
"Since ``box.execute()`` is an invocation of a Lua function, it either "
"causes an error message or returns a value."
msgstr ""

#: ../doc/book/box/box_sql.rst:52
msgid ""
"For some statements the returned value will contain a field named "
"rowcount. For example;"
msgstr ""

#: ../doc/book/box/box_sql.rst:55
msgid ""
"tarantool> box.execute([[INSERT INTO tt VALUES (8,8),(9,9);]])\n"
"tarantool> box.execute([[CREATE TABLE table1 (column1 INT PRIMARY key, "
"column2 VARCHAR(10));]])\n"
"---\n"
"- rowcount: 1\n"
"...\n"
"tarantool> box.execute([[INSERT INTO table1 VALUES (55,'Hello SQL "
"world!');]])\n"
"---\n"
"- rowcount: 1\n"
"..."
msgstr ""

#: ../doc/book/box/box_sql.rst:67
msgid ""
"For statements that cause generation of values for PRIMARY KEY "
"AUTOINCREMENT columns, there will also be a field named "
"\"autoincrement_ids\"."
msgstr ""

#: ../doc/book/box/box_sql.rst:70
msgid ""
"For SELECT statements the returned value will contain a field named "
"metadata (a table with column names and data types) and a field named "
"\"rows\" (a table with the result set). For example:"
msgstr ""

#: ../doc/book/box/box_sql.rst:74
msgid ""
"tarantool> box.execute([[SELECT * FROM table1 WHERE column1 > 0;]])\n"
"---\n"
"- metadata:\n"
"  - name: COLUMN1\n"
"    type: integer\n"
"  - name: COLUMN2\n"
"    type: string\n"
"  rows:\n"
"  - [55, 'Hello SQL world!']\n"
"..."
msgstr ""

#: ../doc/book/box/box_sql.rst:87
msgid ""
"The result structure contains Tarantool/NoSQL data type names in MsgPack "
"format. For example, for a statement SELECT \"x\" FROM t WHERE \"x\"=5; "
"where \"x\" is an integer column and there is one row, the raw data for "
"the result set will look like this:"
msgstr ""

#: ../doc/book/box/box_sql.rst:92
msgid ""
"dd 00 00 00 01                  1-element array\n"
"82                              2-element map (for metadata + rows)\n"
"a8 6d 65 74 61 64 61 74 61      string = \"metadata\"\n"
"91                              1-element array (for column count)\n"
"82                              2-element map (for name + type)\n"
"a4 6e 61 6d 65                  string = \"name\"\n"
"a1 78                           string = \"x\"\n"
"a4 74 79 70 6                   string = \"type\"\n"
"a7 69 6e 74 65 67 65 72         string = \"integer\"\n"
"a4 72 6f 77 73                  string = \"rows\"\n"
"91                              1-element array (for row count)\n"
"91                              1-element array (for field count)\n"
"05                              contents"
msgstr ""

#: ../doc/book/box/box_sql.rst:108
msgid "The order of components within a map is not guaranteed."
msgstr ""

#: ../doc/book/box/box_sql.rst:110
msgid ""
"Alternative: if you are using the Tarantool server as a client, you can "
"switch languages thus:"
msgstr ""

#: ../doc/book/box/box_sql.rst:113
msgid ""
"\\set language sql\n"
"\\set delimiter ;"
msgstr ""

#: ../doc/book/box/box_sql.rst:118
msgid ""
"Afterwards, you can enter any SQL statement directly without needing "
"``box.execute()``."
msgstr ""

#: ../doc/book/box/box_sql.rst:120
msgid ""
"There is also an ``execute()`` function available via :ref:`module "
"net.box <net_box-module>`, for example after ``conn = net_box.connect"
"(url-string)`` one can say ``conn:execute(sql-statement])``."
msgstr ""

#: ../doc/book/box/box_stat.rst:7
msgid ""
"The ``box.stat`` submodule provides access to request and network "
"statistics."
msgstr ""
"Вложенный модуль ``box.stat`` предоставляет доступ к статистике "
"Tarantool'а по запросам и использованию сети."

#: ../doc/book/box/box_stat.rst:9
msgid ""
"Use ``box.stat()`` to show the average number of requests per second, and"
" the total number of requests since startup, broken down by request type."
msgstr ""
"Используйте ``box.stat()``, чтобы узнать среднее количество запросов в "
"секунду и общее количество запросов с момента запуска с разбивкой по типу"
" запроса."

#: ../doc/book/box/box_stat.rst:12
#, fuzzy
msgid ""
"Use ``box.stat.net()``  to see network activity: the number of packets "
"sent and received, the count of active iproto connections, and the "
"average number of requests per second."
msgstr ""
"Используйте ``box.stat()``, чтобы просмотреть статистику сетевой "
"активности: количество отправленных и полученных пакетов, а также общее "
"количество запросов в секунду."

#: ../doc/book/box/box_stat.rst:17
msgid ""
"Use ``box.stat.vinyl()`` to see vinyl-storage-engine activity, for "
"example ``box.stat.vinyl().tx`` has the number of commits and rollbacks. "
"See details at :ref:`the end of this section <box_introspection-"
"box_stat_vinyl_details>`."
msgstr ""
"Используйте ``box.stat.vinyl()``, чтобы просмотреть данные по работе "
"движка базы данных vinyl, например: ``box.stat.vinyl().tx`` содержит "
"количество коммитов и откатов. Более подробную информацию см. в "
":ref:`конце раздела <box_introspection-box_stat_vinyl_details>`."

#: ../doc/book/box/box_stat.rst:23
msgid ""
"Use ``box.stat.reset()`` to reset the statistics of ``box.stat()``, "
"``box.stat.net()``, ``box.stat.vinyl()`` and :ref:`box.space.index "
"<box_space-space_index>`."
msgstr ""
"Используйте ``box.stat.reset()``, чтобы сбросить статистику "
"``box.stat()``, ``box.stat.net()``, ``box.stat.vinyl()`` и "
":ref:`box.space.index <box_space-space_index>`."

#: ../doc/book/box/box_stat.rst:27
msgid ""
"In the tables that ``box.stat()`` and ``box.stat.net()`` return: ``rps`` "
"stands for \"[average number of] requests per second [in the last 5 "
"seconds]\", ``total`` stands for \"total [number processed since the "
"server began]\", ``current`` stands for \"[number of] current [requests "
"in progress, which can be limited by :ref:`box.cfg.net_msg_max "
"<cfg_networking-net_msg_max>`]\". \"ERROR\" is the count of requests that"
" resulted in an error."
msgstr ""
"В таблицах, которые возвращают ``box.stat()`` и ``box.stat.net()``: "
"``rps`` означает \"[среднее количество] запросы в секунду [за последние 5"
" секунд]\", ``total`` означает \"всего [количество запросов, обработанных"
" с момента запуска сервера]\", ``current`` означает \"[количество "
"запросов] в ходе выполнения [которое можно ограничить с помощью "
":ref:`box.cfg.net_msg_max <cfg_networking-net_msg_max>`]\". \"ERROR\" -- "
"это счетчик запросов, которые завершились с ошибкой."

#: ../doc/book/box/box_stat.rst:34
msgid ""
"tarantool> box.stat() -- return 10 tables\n"
"---\n"
"- DELETE:\n"
"    total: 1873949\n"
"    rps: 123\n"
"  SELECT:\n"
"    total: 1237723\n"
"    rps: 4099\n"
"  INSERT:\n"
"    total: 0\n"
"    rps: 0\n"
"  EVAL:\n"
"    total: 0\n"
"    rps: 0\n"
"  CALL:\n"
"    total: 0\n"
"    rps: 0\n"
"  REPLACE:\n"
"    total: 1239123\n"
"    rps: 7849\n"
"  UPSERT:\n"
"    total: 0\n"
"    rps: 0\n"
"  AUTH:\n"
"    total: 0\n"
"    rps: 0\n"
"  ERROR:\n"
"    total: 0\n"
"    rps: 0\n"
"  UPDATE:\n"
"    total: 0\n"
"    rps: 0\n"
"...\n"
"tarantool> box.stat().DELETE -- total + requests per second from one "
"table\n"
"---\n"
"- total: 0\n"
"  rps: 0\n"
"...\n"
"tarantool> box.stat.net() -- 4 tables\n"
"---\n"
"- SENT:\n"
"    total: 0\n"
"    rps: 0\n"
"  CONNECTIONS:\n"
"    current: 0\n"
"    rps: 0\n"
"    total: 0\n"
"  REQUESTS:\n"
"    current: 0\n"
"    rps: 0\n"
"    total: 0\n"
"  RECEIVED:\n"
"    total: 0\n"
"    rps: 0\n"
"...\n"
"tarantool> box.stat.vinyl().tx.commit -- one item of the vinyl table\n"
"---\n"
"- 1047632\n"
"..."
msgstr ""
"tarantool> box.stat() -- вернуть 10 таблиц\n"
"---\n"
"- DELETE:\n"
"    total: 1873949\n"
"    rps: 123\n"
"  SELECT:\n"
"    total: 1237723\n"
"    rps: 4099\n"
"  INSERT:\n"
"    total: 0\n"
"    rps: 0\n"
"  EVAL:\n"
"    total: 0\n"
"    rps: 0\n"
"  CALL:\n"
"    total: 0\n"
"    rps: 0\n"
"  REPLACE:\n"
"    total: 1239123\n"
"    rps: 7849\n"
"  UPSERT:\n"
"    total: 0\n"
"    rps: 0\n"
"  AUTH:\n"
"    total: 0\n"
"    rps: 0\n"
"  ERROR:\n"
"    total: 0\n"
"    rps: 0\n"
"  UPDATE:\n"
"    total: 0\n"
"    rps: 0\n"
"...\n"
"tarantool> box.stat().DELETE -- всего + запросов в секунду из одной "
"таблицы\n"
"---\n"
"- total: 0\n"
"  rps: 0\n"
"...\n"
"tarantool> box.stat.net() -- 4 таблицы\n"
"---\n"
"- SENT:\n"
"    total: 0\n"
"    rps: 0\n"
"  CONNECTIONS:\n"
"    current: 0\n"
"    rps: 0\n"
"    total: 0\n"
"  REQUESTS:\n"
"    current: 0\n"
"    rps: 0\n"
"    total: 0\n"
"  RECEIVED:\n"
"    total: 0\n"
"    rps: 0\n"
"...\n"
"tarantool> box.stat.vinyl().tx.commit -- один пункт из таблицы vinyl\n"
"---\n"
"- 1047632\n"
"..."

#: ../doc/book/box/box_stat.rst:98
msgid "Here are details about the ``box.stat.vinyl()`` items."
msgstr "Ниже приводится подробная информация о пунктах в ``box.stat.vinyl()``."

#: ../doc/book/box/box_stat.rst:102
msgid ""
"**Details about box.stat.vinyl().regulator:** The vinyl regulator decides"
" when to take or delay actions for disk IO, grouping activity in batches "
"so that it is consistent and efficient. The regulator is invoked by the "
"vinyl scheduler, once per second, and updates related variables whenever "
"it is invoked."
msgstr ""
"**Подробная информация о box.stat.vinyl().regulator:** Регулятор vinyl'а "
"определяет, когда следует предпринимать или отложить действия по "
"дисковому вводу-выводу, путем группировки действий в пакеты так, чтобы "
"обеспечить согласованность и эффективность. Регулятор вызывается "
"планировщиком vinyl'а раз в секунду и обновляет соответствующие "
"переменные при каждом вызове."

#: ../doc/book/box/box_stat.rst:109
msgid ""
"``box.stat.vinyl().regulator.dump_bandwidth`` is the estimated average "
"rate at which dumps are done. Initially this will appear as 10485760 (10 "
"megabytes per second). Only significant dumps (larger than one megabyte) "
"are used for estimating."
msgstr ""
"``box.stat.vinyl().regulator.dump_bandwidth`` представляет собой "
"предполагаемую среднюю скорость создания дампов. Изначально она "
"составляет 10 485 760 (10 мегабайтов в секунду). Только значительные "
"дампы (более одного мегабайта) используются при оценке."

#: ../doc/book/box/box_stat.rst:114
msgid ""
"``box.stat.vinyl().regulator.dump_watermark`` is the point when dumping "
"must occur. The value is slightly smaller than the amount of memory that "
"is allocated for vinyl trees, which is the :ref:`vinyl_memory "
"<cfg_storage-vinyl_memory>` parameter."
msgstr ""
"``box.stat.vinyl().regulator.dump_watermark`` -- это точка, когда должно "
"произойти создание дампа. Это значение несколько меньше объема памяти, "
"выделенного для деревьев в vinyl'е, которое указано в параметре "
":ref:`vinyl_memory <cfg_storage-vinyl_memory>`."

#: ../doc/book/box/box_stat.rst:120
msgid ""
"``box.stat.vinyl().regulator.write_rate`` is the actual average rate at "
"which recent writes to disk are done. Averaging is done over a 5-second "
"time window, so if there has been no activity for 5 seconds then "
"``regulator.write_rate = 0``. The ``write_rate`` may be slowed when a "
"dump is in progress or when the user has set :ref:`snap_io_rate_limit "
"<cfg_binary_logging_snapshots-snap_io_rate_limit>`."
msgstr ""
"``box.stat.vinyl().regulator.write_rate`` представляет собой "
"действительную среднюю скорость записи последних данных на диск. Средняя "
"скорость вычисляется в течение 5-секундного интервала, поэтому если за "
"последние 5 секунд ничего не происходило, то ``regulator.write_rate = "
"0``. Скорость ``write_rate`` может замедлиться во время создания дампа, "
"или если пользователь задал предел :ref:`snap_io_rate_limit "
"<cfg_binary_logging_snapshots-snap_io_rate_limit>`."

#: ../doc/book/box/box_stat.rst:128
msgid ""
"``box.stat.vinyl().regulator.rate_limit`` is the write rate limit, in "
"bytes per second, imposed on transactions by the regulator based on the "
"observed dump/compaction performance."
msgstr ""
"``box.stat.vinyl().regulator.rate_limit`` -- это предел скорости записи в"
" байтах в секунду, который налагается регулятором на основании "
"установленной производительности создания дампов / слияния."

#: ../doc/book/box/box_stat.rst:134
msgid ""
"**Details about box.stat.vinyl().disk:** Since vinyl is an on-disk "
"storage engine (unlike memtx which is an in-memory storage engine), it "
"can handle large databases -- but if a database is larger than the amount"
" of memory that is allocated for vinyl, then there will be more disk "
"activity."
msgstr ""
"**Подробная информация о box.stat.vinyl().disk:** Поскольку vinyl "
"является дисковым движком базы данных (в отличие от memtx'а, который "
"представляет собой in-memory движок), он может обрабатывать большие базы "
"данных -- однако если база данных больше объема памяти, выделенного для "
"vinyl'а, дисковых операций будет больше."

#: ../doc/book/box/box_stat.rst:141
msgid ""
"``box.stat.vinyl().disk.data`` and ``box.stat.vinyl().disk.index`` are "
"the amount of data that has gone into files in a subdirectory of "
":ref:`vinyl_dir <cfg_basic-vinyl_dir>`, with names like ``{lsn}.run`` and"
" ``{lsn}.index``. The size of the run will be related to the output of "
"``scheduler.dump_*``."
msgstr ""
"``box.stat.vinyl().disk.data`` и ``box.stat.vinyl().disk.index`` содержат"
" объем данных, который поступил в файлы во вложенной директории "
":ref:`vinyl_dir <cfg_basic-vinyl_dir>` с именами вида ``{lsn}.run`` и "
"``{lsn}.index``. Размер файла run зависит от вывода ``scheduler.dump_*``."

#: ../doc/book/box/box_stat.rst:148
msgid ""
"``box.stat.vinyl().disk.data_compacted`` Sum size of data stored at the "
"last LSM tree level, in bytes, without taking disk compression into "
"account. It can be thought of as the size of disk space that the user "
"data would occupy if there were no compression, indexing, or space "
"increase caused by the LSM tree design."
msgstr ""
"``box.stat.vinyl().disk.data_compacted`` представляет собой общий размер "
"данных, которые хранятся на последнем уровне LSM-дерева, в байтах. При "
"этом не учитывается сжатие диска. Его можно рассматривать как размер "
"места на диске, которое заняли бы пользовательские данные, если бы не "
"было компрессии, индексирования или увеличения спейса, вызванного "
"конструкцией LSM-дерева."

#: ../doc/book/box/box_stat.rst:156
msgid ""
"**Details about box.stat.vinyl().memory:** Although the vinyl storage "
"engine is not \"in-memory\", Tarantool does need to have memory for write"
" buffers and for caches:"
msgstr ""
"**Подробная информация о box.stat.vinyl().memory:** Хотя движок базы "
"данных vinyl не является \"in-memory\", Tarantool'у всё же требуется "
"память для записи буфера и для кэша:"

#: ../doc/book/box/box_stat.rst:160
msgid ""
"``box.stat.vinyl().memory.tuple_cache`` is the number of bytes that are "
"being used for tuples (data)."
msgstr ""
"``box.stat.vinyl().memory.tuple_cache`` содержит количество байтов, "
"используемых для кортежей (данные)."

#: ../doc/book/box/box_stat.rst:162
msgid ""
"``box.stat.vinyl().memory.tx`` is transactional memory. This will usually"
" be 0."
msgstr ""
"``box.stat.vinyl().memory.tx`` -- это транзакционная память, как правило,"
" равная 0."

#: ../doc/book/box/box_stat.rst:164
msgid ""
"``box.stat.vinyl().memory.level0`` is the \"level0\" memory area, "
"sometimes abbreviated \"L0\", which is the area that vinyl can use for "
"in-memory storage of an LSM tree."
msgstr ""
"``box.stat.vinyl().memory.level0`` -- это объем памяти уровня 0 "
"\"level0\", который иногда сокращается до \"L0\" и представляет собой "
"область, которую vinyl может использовать для хранения данных в "
"оперативной памяти в LSM-дереве."

#: ../doc/book/box/box_stat.rst:168
msgid ""
"Therefore we can say that \"L0 is becoming full\" when the amount in "
"``memory.level0`` is close to the maximum, which is "
":ref:`regulator.dump_watermark <box_introspection-"
"box_stat_vinyl_regulator>`. We can expect that \"L0 = 0\" immediately "
"after a dump. ``box.stat.vinyl().memory.page_index`` and  "
"``box.stat.vinyl().memory.bloom_filter`` have the current amount being "
"used for index-related structures. The size is a function of the number "
"and size of keys, plus :ref:`page_size <cfg_storage-vinyl_page_size>`, "
"plus :ref:`bloom_fpr <cfg_storage-vinyl_bloom_fpr>`. This is not a count "
"of bloom filter \"hits\" (the number of reads that could be avoided "
"because the bloom filter predicts their presence in a run file) -- that "
"statistic can be found with :ref:`index_object:stat() <box_index-stat>`."
msgstr ""
"Таким образом, можно сказать, что \"L0 заполняется\", когда объем данных "
"в ``memory.level0`` приближается к максимальному, а именно "
":ref:`regulator.dump_watermark <box_introspection-"
"box_stat_vinyl_regulator>`. Можно ожидать, что \"L0 = 0\" сразу после "
"создания дампа. Текущий объем в ``box.stat.vinyl().memory.page_index`` и"
"  ``box.stat.vinyl().memory.bloom_filter`` используется для структур, "
"связанных с индексами. Размер -- это количество и размер ключей плюс "
":ref:`page_size <cfg_storage-vinyl_page_size>` плюс :ref:`bloom_fpr "
"<cfg_storage-vinyl_bloom_fpr>`. Это не счетчик совпадений по фильтру "
"Блума (количество чтений, которых можно избежать, поскольку фильтра Блума"
" предсказывает их наличие в файле типа run) -- эта статистика указана в "
":ref:`index_object:stat() <box_index-stat>`."

#: ../doc/book/box/box_stat.rst:185
msgid ""
"**Details about box.stat.vinyl().tx:** This is about requests that affect"
" transactional activity (\"tx\" is used here as an abbreviation for "
"\"transaction\"):"
msgstr ""
"**Подробная информация о box.stat.vinyl().tx:** Информация о запросах, "
"которые влияют на операции транзакций (\"tx\" используется в качестве "
"сокращения слова \"транзакция\"):"

#: ../doc/book/box/box_stat.rst:189
msgid ""
"``box.stat.vinyl().tx.conflict`` counts conflicts that caused a "
"transaction to roll back."
msgstr ""
"``box.stat.vinyl().tx.conflict`` содержит счетчик конфликтов, которые "
"вызвали откат транзакции."

#: ../doc/book/box/box_stat.rst:191
msgid ""
"``box.stat.vinyl().tx.commit`` is the count of commits (successful "
"transaction ends). It includes implicit commits, for example any insert "
"causes a commit unless it is within a begin-end block."
msgstr ""
"``box.stat.vinyl().tx.commit`` -- это счетчик коммитов (успешно "
"завершенных транзакций). Он включает в себя неявные коммиты, например, "
"любая вставка вызывает коммит, если она не входит в блок begin-end."

#: ../doc/book/box/box_stat.rst:195
msgid ""
"``box.stat.vinyl().tx.rollback`` is the count of rollbacks (unsuccessful "
"transaction ends). This is not merely a count of explicit "
":ref:`box.rollback <box-rollback>` requests -- it includes requests that "
"ended in errors. For example, after an attempted insert request that "
"causes a \"Duplicate key exists in unique index\" error, ``tx.rollback`` "
"is incremented."
msgstr ""
"``box.stat.vinyl().tx.rollback`` -- это счетчик откатов (невыполненные "
"транзакции). Это не просто счетчик явных запросов :ref:`box.rollback "
"<box-rollback>`, он также включает в себя запросы, которые привели к "
"ошибке. Например, после попытки вставки, в результате которой была "
"выведена ошибка наличия дубликата ключа \"Duplicate key exists in unique "
"index\", значение счетчика ``tx.rollback`` увеличивается."

#: ../doc/book/box/box_stat.rst:203
msgid "``box.stat.vinyl().tx.statements`` will usually be 0."
msgstr "``box.stat.vinyl().tx.statements``, как правило, будет равен 0."

#: ../doc/book/box/box_stat.rst:205
msgid ""
"``box.stat.vinyl().tx.transactions`` is the number of transactions that "
"are currently running."
msgstr ""
"``box.stat.vinyl().tx.transactions`` содержит количество текущих "
"транзакций."

#: ../doc/book/box/box_stat.rst:207
msgid ""
"``box.stat.vinyl().tx.gap_locks`` is the number of gap locks that are "
"outstanding during execution of a request. For a low-level description of"
" Tarantool's implementation of gap locking, see `Gap locks in Vinyl "
"transaction manager "
"<https://github.com/tarantool/tarantool/issues/2671>`_."
msgstr ""
"``box.stat.vinyl().tx.gap_locks`` представляет собой число блокировок "
"разрывов во время выполнения запроса. Чтобы получить низкоуровневое "
"описание имплементации блокировки разрывов в Tarantool'е, см. `Блокировка"
" разрывов в менеджере транзакций Vinyl'а "
"<https://github.com/tarantool/tarantool/issues/2671>`_."

#: ../doc/book/box/box_stat.rst:211
msgid ""
"``box.stat.vinyl().tx.read_views`` shows whether a transaction has "
"entered a read-only state to avoid conflict temporarily. This will "
"usually be 0."
msgstr ""
"``box.stat.vinyl().tx.read_views`` показывает, получила ли транзакция "
"статус только для чтения, во избежание временного конфликта. Как правило,"
" 0."

#: ../doc/book/box/box_stat.rst:215
msgid ""
"**Details about box.stat.vinyl().scheduler:** This primarily has counters"
" related to tasks that the scheduler has arranged for dumping or "
"compaction: (most of these items are reset to 0 when the server restarts "
"or when :ref:`box.stat.reset() <box_introspection-box_stat_reset>` "
"occurs):"
msgstr ""
"**Подробная информация о box.stat.vinyl().scheduler:** В основном "
"содержит счетчики, связанные с задачами планировщика по созданию дампов "
"или слиянию: (большинство сбрасываются на 0 при перезапуске сервера или "
"вызове :ref:`box.stat.reset() <box_introspection-box_stat_reset>`):"

#: ../doc/book/box/box_stat.rst:221
msgid ""
"``box.stat.vinyl().scheduler.compaction_*`` is the amount of data from "
"recent changes that has been :ref:`compacted <box_index-compact>`. This "
"is divided into ``scheduler.compaction_input`` (the amount that is being "
"compacted), ``scheduler.compaction_queue`` (the amount that is waiting to"
" be compacted), ``scheduler.compaction_time`` (total time spent by all "
"worker threads performing compaction, in seconds), and "
"``scheduler.compaction_output`` (the amount that has been compacted, "
"which is presumably smaller than ``scheduler.compaction_input``)."
msgstr ""
"``box.stat.vinyl().scheduler.compaction_*`` содержит объем данных из "
"последних изменений, для которых было произведено :ref:`слияние "
"<box_index-compact>`. Он подразделяется на ``scheduler.compaction_input``"
" (объем данных текущего слияния), ``scheduler.compaction_queue`` (объем "
"данных в ожидании слияния), ``scheduler.compaction_time`` (общее время, "
"затраченное рабочими потоками на слияние, в секундах) и "
"``scheduler.compaction_output`` (объем данных после слияния, который, "
"предположительно, меньше ``scheduler.compaction_input``)."

#: ../doc/book/box/box_stat.rst:231
msgid ""
"``box.stat.vinyl().scheduler.tasks_*`` is about dump/compaction tasks, in"
" three categories, ``scheduler.tasks_inprogress`` (currently running), "
"``scheduler.tasks_completed`` (successfully completed) "
"``scheduler.tasks_failed`` (aborted due to errors)."
msgstr ""
"``box.stat.vinyl().scheduler.tasks_*`` содержит информацию о задачах по "
"созданию дампов или слиянию, разделенную на три категории: "
"``scheduler.tasks_inprogress`` (текущие), ``scheduler.tasks_completed`` "
"(успешно завершенные) ``scheduler.tasks_failed`` (прерванные из-за "
"ошибки)."

#: ../doc/book/box/box_stat.rst:237
msgid ""
"``box.stat.vinyl().scheduler_dump_*`` has the amount of data from recent "
"changes that has been dumped, including ``dump_time`` (total time spent "
"by all worker threads performing dumps, in seconds), and ``dump_count`` "
"(the count of completed dumps), ``dump_input`` and ``dump_output``."
msgstr ""
"``box.stat.vinyl().scheduler_dump_*`` содержит объем данных из последних "
"изменений, для которых был создан дамп, включая ``dump_time`` (общее "
"время, затраченное рабочими потоками на создание дампов, в секундах) и "
"``dump_count`` (счетчик созданных дампов), ``dump_input`` и "
"``dump_output``."

#: ../doc/book/box/box_stat.rst:243
msgid ""
"A \"dump\" is explained in section :ref:`Storing data with vinyl "
"<engines-algorithm_filling_lsm>`:"
msgstr ""
"Понятие \"дамп\" (dump) объясняется в разделе :ref:`Хранение данных с "
"помощью vinyl <engines-algorithm_filling_lsm>`:"

#: ../doc/book/box/box_stat.rst:245
msgid ""
"Sooner or later the number of elements in an LSM tree exceeds the L0 size"
" and that is when L0 gets written to a file on disk (called a 'run') and "
"then cleared for storing new elements. This operation is called a 'dump'."
msgstr ""
"Рано или поздно количество элементов в дереве превысит размер L0. Тогда "
"L0 записывается в файл на диске (который называется забегом -- 'run') и "
"освобождается под новые элементы. Эта операция называется 'дамп' (dump)."

#: ../doc/book/box/box_stat.rst:249
msgid ""
"Thus it can be predicted that a dump will occur if the size of L0 (which "
"is :ref:`memory.level0 <box_introspection-box_stat_vinyl_memory>`) is "
"approaching the maximum (which is :ref:`regulator.dump_watermark "
"<box_introspection-box_stat_vinyl_regulator>`) and a dump is not already "
"in progress. In fact Tarantool will try to arrange a dump before this "
"hard limit is reached."
msgstr ""
"Таким образом, можно предсказать создание дампа, если размер L0 (указан в"
" :ref:`memory.level0 <box_introspection-box_stat_vinyl_memory>`) "
"приближается к максимальному (указан в :ref:`regulator.dump_watermark "
"<box_introspection-box_stat_vinyl_regulator>`), и создание дампа еще не "
"началось. На самом деле Tarantool планирует дамп до достижения предела."

#: ../doc/book/box/box_stat.rst:259
msgid "A dump will also occur during a  :ref:`snapshot <box-snapshot>` operation."
msgstr ""
"Дамп также создается во время операции создания :ref:`снимка <box-"
"snapshot>`."

#: ../doc/book/box/box_tuple.rst:5
msgid "Submodule `box.tuple`"
msgstr "Вложенный модуль `box.tuple`"

#: ../doc/book/box/box_tuple.rst:13
msgid ""
"The ``box.tuple`` submodule provides read-only access for the ``tuple`` "
"userdata type. It allows, for a single :ref:`tuple <index-box_tuple>`: "
"selective retrieval of the field contents, retrieval of information about"
" size, iteration over all the fields, and conversion to a `Lua table "
"<https://www.lua.org/pil/2.5.html>`_."
msgstr ""
"Вложенный модуль ``box.tuple`` предоставляет доступ только для чтения к "
"пользовательским данным типа кортеж ``tuple``. С его помощью для "
"отдельного :ref:`кортежа <index-box_tuple>` можно сделать следующее: "
"выборочно искать содержимое поля, получать информацию о размере, "
"проводить итерацию по всем полям и выполнять преобразование в "
"`Lua-таблицу <https://www.lua.org/pil/2.5.html>`_."

#: ../doc/book/box/box_tuple.rst:22
msgid "Below is a list of all ``box.tuple`` functions."
msgstr "Ниже приведен перечень всех функций модуля ``box.tuple``."

#: ../doc/book/box/box_tuple.rst:32
msgid ":ref:`box.tuple.new() <box_tuple-new>`"
msgstr ":ref:`box.tuple.new() <box_tuple-new>`"

#: ../doc/book/box/box_tuple.rst:32
msgid "Create a tuple"
msgstr "Создание кортежа"

#: ../doc/book/box/box_tuple.rst:35
msgid ":ref:`#tuple_object <box_tuple-count_fields>`"
msgstr ":ref:`#tuple_object <box_tuple-count_fields>`"

#: ../doc/book/box/box_tuple.rst:35
msgid "Count tuple fields"
msgstr "Подсчет полей кортежа"

#: ../doc/book/box/box_tuple.rst:38
msgid ":ref:`tuple_object:bsize() <box_tuple-bsize>`"
msgstr ":ref:`tuple_object:bsize() <box_tuple-bsize>`"

#: ../doc/book/box/box_tuple.rst:38
msgid "Get count of bytes in a tuple"
msgstr "Подсчет байтов в кортеже"

#: ../doc/book/box/box_tuple.rst:41
msgid ":ref:`tuple_object[field-number] <box_tuple-field_number>`"
msgstr ":ref:`tuple_object[field-number] <box_tuple-field_number>`"

#: ../doc/book/box/box_tuple.rst:41
msgid "Get a tuple's field by specifying a number"
msgstr "Получение поля кортежа по номеру"

#: ../doc/book/box/box_tuple.rst:44
msgid ":ref:`tuple_object[field-name] <box_tuple-field_name>`"
msgstr ":ref:`tuple_object[field-name] <box_tuple-field_name>`"

#: ../doc/book/box/box_tuple.rst:44
msgid "Get a tuple's field by specifying a name"
msgstr "Получение поля кортежа по имени"

#: ../doc/book/box/box_tuple.rst:47
msgid ":ref:`tuple_object[field-path] <box_tuple-field_path>`"
msgstr ":ref:`tuple_object[field-path] <box_tuple-field_path>`"

#: ../doc/book/box/box_tuple.rst:47
msgid "Get a tuple's fields or parts by specifying a path"
msgstr "Получение полей кортежа или компонентов по пути"

#: ../doc/book/box/box_tuple.rst:50
msgid ":ref:`tuple_object:find() <box_tuple-find>`"
msgstr ":ref:`tuple_object:find() <box_tuple-find>`"

#: ../doc/book/box/box_tuple.rst:50
msgid "Get the number of the first field matching the search value"
msgstr "Получение номера первого поля, совпадающего с искомым значением"

#: ../doc/book/box/box_tuple.rst:53
msgid ":ref:`tuple_object:findall() <box_tuple-find>`"
msgstr ":ref:`tuple_object:findall() <box_tuple-find>`"

#: ../doc/book/box/box_tuple.rst:53
msgid "Get the number of all fields matching the search value"
msgstr "Получение номеров всех полей, совпадающих с искомым значением"

#: ../doc/book/box/box_tuple.rst:56
msgid ":ref:`tuple_object:transform() <box_tuple-transform>`"
msgstr ":ref:`tuple_object:transform() <box_tuple-transform>`"

#: ../doc/book/box/box_tuple.rst:56
msgid "Remove (and replace) a tuple's fields"
msgstr "Удаление (и замена) полей кортежа"

#: ../doc/book/box/box_tuple.rst:59
msgid ":ref:`tuple_object:unpack() <box_tuple-unpack>`"
msgstr ":ref:`tuple_object:unpack() <box_tuple-unpack>`"

#: ../doc/book/box/box_tuple.rst:59
msgid "Get a tuple's fields"
msgstr "Получение полей кортежа"

#: ../doc/book/box/box_tuple.rst:62
msgid ":ref:`tuple_object:totable() <box_tuple-totable>`"
msgstr ":ref:`tuple_object:totable() <box_tuple-totable>`"

#: ../doc/book/box/box_tuple.rst:62
msgid "Get a tuple's fields as a table"
msgstr "Получение полей кортежа в виде таблицы"

#: ../doc/book/box/box_tuple.rst:65
msgid ":ref:`tuple_object:tomap() <box_tuple-tomap>`"
msgstr ":ref:`tuple_object:tomap() <box_tuple-tomap>`"

#: ../doc/book/box/box_tuple.rst:65
msgid "Get a tuple's fields as a table along with key:value pairs"
msgstr "Получение полей кортежа в виде таблицы, а также пар ключ-значение"

#: ../doc/book/box/box_tuple.rst:68
msgid ":ref:`tuple_object:pairs() <box_tuple-pairs>`"
msgstr ":ref:`tuple_object:pairs() <box_tuple-pairs>`"

#: ../doc/book/box/box_tuple.rst:71
msgid ":ref:`tuple_object:update() <box_tuple-update>`"
msgstr ":ref:`tuple_object:update() <box_tuple-update>`"

#: ../doc/book/box/box_tuple.rst:79
msgid ""
"Construct a new tuple from either a scalar or a Lua table. Alternatively,"
" one can get new tuples from tarantool's :ref:`select <box_space-select>`"
" or :ref:`insert <box_space-insert>` or :ref:`replace <box_space-"
"replace>` or :ref:`update <box_space-update>` requests, which can be "
"regarded as statements that do ``new()`` implicitly."
msgstr ""
"Создание нового кортежа либо из скаляра, либо из Lua-таблицы.  Возможен и"
" вариант получения новых кортежей из запросов :ref:`select <box_space-"
"select>` или :ref:`insert <box_space-insert>`. или :ref:`replace "
"<box_space-replace>`, или :ref:`update <box_space-update>` Tarantool'а, "
"которые можно рассматривать в качестве операторов, косвенно выполняющих "
"операцию создания ``new()``."

#: ../doc/book/box/box_tuple.rst:86
msgid "the value that will become the tuple contents."
msgstr "значение, которое станет содержимым кортежа."

#: ../doc/book/box/box_tuple.rst:88
msgid "a new tuple"
msgstr "новый кортеж"

#: ../doc/book/box/box_tuple.rst:91
msgid ""
"In the following example, ``x`` will be a new table object containing one"
" tuple and ``t`` will be a new tuple object. Saying ``t`` returns the "
"entire tuple ``t``."
msgstr ""
"В следующем примере ``x`` будет представлять собой новый объект таблицы, "
"который содержит один кортеж, а ``t`` будет представлять собой объект "
"кортежа. Если ввести команду ``t``, будет получен весь кортеж ``t``."

#: ../doc/book/box/box_tuple.rst:97
msgid ""
"tarantool> x = box.space.tester:insert{\n"
"         >   33,\n"
"         >   tonumber('1'),\n"
"         >   tonumber64('2')\n"
"         > }:totable()\n"
"---\n"
"...\n"
"tarantool> t = box.tuple.new{'abc', 'def', 'ghi', 'abc'}\n"
"---\n"
"...\n"
"tarantool> t\n"
"---\n"
"- ['abc', 'def', 'ghi', 'abc']\n"
"..."
msgstr ""
"tarantool> x = box.space.tester:insert{\n"
"         >   33,\n"
"         >   tonumber('1'),\n"
"         >   tonumber64('2')\n"
"         > }:totable()\n"
"---\n"
"...\n"
"tarantool> t = box.tuple.new{'abc', 'def', 'ghi', 'abc'}\n"
"---\n"
"...\n"
"tarantool> t\n"
"---\n"
"- ['abc', 'def', 'ghi', 'abc']\n"
"..."

#: ../doc/book/box/box_tuple.rst:120
msgid ""
"The ``#`` operator in Lua means \"return count of components\". So, if "
"``t`` is a tuple instance, ``#t`` will return the number of fields."
msgstr ""
"Оператор ``#`` на языке Lua означает \"вернуть количество компонентов\". "
"Таким образом, если ``t`` представляет собой кортеж, то ``#t`` вернет "
"количество полей."

#: ../doc/book/box/box_tuple.rst:125
msgid ""
"In the following example, a tuple named ``t`` is created and then the "
"number of fields in ``t`` is returned."
msgstr ""
"В следующем примере создается кортеж под названием ``t``, а затем "
"возвращается количество полей в кортеже ``t``."

#: ../doc/book/box/box_tuple.rst:128
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4'}\n"
"---\n"
"...\n"
"tarantool> #t\n"
"---\n"
"- 4\n"
"..."
msgstr ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4'}\n"
"---\n"
"...\n"
"tarantool> #t\n"
"---\n"
"- 4\n"
"..."

#: ../doc/book/box/box_tuple.rst:142
msgid ""
"If ``t`` is a tuple instance, ``t:bsize()`` will return the number of "
"bytes in the tuple. With both the memtx storage engine and the vinyl "
"storage engine the default maximum is one megabyte "
"(:ref:`memtx_max_tuple_size <cfg_storage-memtx_max_tuple_size>` or "
":ref:`vinyl_max_tuple_size <cfg_storage-vinyl_max_tuple_size>`). Every "
"field has one or more \"length\" bytes preceding the actual contents, so "
"``bsize()`` returns a value which is slightly greater than the sum of the"
" lengths of the contents."
msgstr ""
"Если ``t`` -- это экземпляр кортежа, то ``t:bsize()`` вернет количество "
"байтов в кортеже. Как для движка базы данных memtx, так и для движка "
"vinyl максимальное количество, используемое по умолчанию, составляет один"
" мегабайт (:ref:`memtx_max_tuple_size <cfg_storage-memtx_max_tuple_size>`"
" или :ref:`vinyl_max_tuple_size <cfg_storage-vinyl_max_tuple_size>`). В "
"каждом поле есть один или более байтов \"длины\", которые предваряют само"
" содержимое поля, поэтому ``bsize()`` вернет значение, которое "
"незначительно больше, чем сумма длин всего содержимого."

#: ../doc/book/box/box_tuple.rst:151
#, fuzzy
msgid ""
"The value does not include the size of \"struct tuple\" (for the current "
"size of this structure look in the `tuple.h "
"<https://github.com/tarantool/tarantool/blob/2.1/src/box/tuple.h>`_ file "
"in Tarantool's source code)."
msgstr ""
"Значение не содержит размер кортежа \"struct tuple\" (чтобы узнать "
"текущий размер данной структуры, посмотрите файл `tuple.h "
"<https://github.com/tarantool/tarantool/blob/1.10/src/box/tuple.h>`_ в "
"исходном коде Tarantool'а)."

#: ../doc/book/box/box_tuple.rst:159
msgid ""
"In the following example, a tuple named ``t`` is created which has three "
"fields, and for each field it takes one byte to store the length and "
"three bytes to store the contents, and then there is one more byte to "
"store a count of the number of fields, so ``bsize()`` returns "
"``3*(1+3)+1``. This is the same as the size of the string that "
":ref:`msgpack.encode({'aaa','bbb','ccc'}) <msgpack-encode>` would return."
msgstr ""
"В следующем примере создается кортеж с именем ``t``, в котором три поля, "
"и для каждого поля один байт занимает хранение длины, и три байта "
"занимает хранение содержимого, кроме того, один бит используется на "
"ресурсы, поэтому ``bsize()`` вернет ``3*(1+3)+1``. Такой же размер строки"
" вернула бы функция :ref:`msgpack.encode({'aaa','bbb','ccc'}) <msgpack-"
"encode>`."

#: ../doc/book/box/box_tuple.rst:166
msgid ""
"tarantool> t = box.tuple.new{'aaa', 'bbb', 'ccc'}\n"
"---\n"
"...\n"
"tarantool> t:bsize()\n"
"---\n"
"- 13\n"
"..."
msgstr ""
"tarantool> t = box.tuple.new{'aaa', 'bbb', 'ccc'}\n"
"---\n"
"...\n"
"tarantool> t:bsize()\n"
"---\n"
"- 13\n"
"..."

#: ../doc/book/box/box_tuple.rst:180
msgid ""
"If ``t`` is a tuple instance, ``t[field-number]`` will return the field "
"numbered field-number in the tuple. The first field is ``t[1]``."
msgstr ""
"Если ``t`` -- это экземпляр кортежа, то ``t[номер-поля]`` вернет поле под"
" номером номер-поля в кортеже. Первое поле -- это ``t[1]``."

#: ../doc/book/box/box_tuple.rst:183 ../doc/book/box/box_tuple.rst:214
msgid "field value."
msgstr "значение поля."

#: ../doc/book/box/box_tuple.rst:184 ../doc/book/box/box_tuple.rst:215
msgid "lua-value"
msgstr "Lua-значение"

#: ../doc/book/box/box_tuple.rst:186
msgid ""
"In the following example, a tuple named ``t`` is created and then the "
"second field in ``t`` is returned."
msgstr ""
"В следующем примере создается кортеж под названием ``t``, а затем "
"возвращается второе поле в кортеже ``t``."

#: ../doc/book/box/box_tuple.rst:189
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4'}\n"
"---\n"
"...\n"
"tarantool> t[2]\n"
"---\n"
"- Fld#2\n"
"..."
msgstr ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4'}\n"
"---\n"
"...\n"
"tarantool> t[2]\n"
"---\n"
"- Fld#2\n"
"..."

#: ../doc/book/box/box_tuple.rst:203
#, fuzzy
msgid ""
"If ``t`` is a tuple instance, ``t['field-name']`` will return the field "
"named 'field-name' in the tuple. Fields have names if the tuple has been "
"retrieved from a space that has an associated :ref:`format <box_space-"
"format>`. :samp:`t[{lua-variable-name}]` will do the same thing if ``lua-"
"variable-name`` contains ``'field-name'``."
msgstr ""
"Если ``t`` -- это экземпляр кортежа, то ``t['field-name']`` вернет поле "
"под названием `field-name` в кортеже. У полей есть имена, если кортеж был"
" получен из спейса с определенным :ref:`форматом <box_space-format>`."

#: ../doc/book/box/box_tuple.rst:209
msgid ""
"There is a variation which the `Lua manual "
"<https://www.lua.org/pil/2.5.html>`_ calls \"syntactic sugar\": use ``t"
".field-name`` as an equivalent of ``t['field-name']``."
msgstr ""

#: ../doc/book/box/box_tuple.rst:217
msgid ""
"In the following example, a tuple named ``t`` is returned from "
"``replace`` and then the second field in ``t`` named 'field2' is "
"returned."
msgstr ""
"В следующем примере кортеж под названием ``t`` возвращается после "
"операции замены, а затем возвращается второе поле с именем 'field2' в "
"кортеже ``t``."

#: ../doc/book/box/box_tuple.rst:220
msgid ""
"tarantool> format = {}\n"
"---\n"
"...\n"
"tarantool> format[1] = {name = 'field1', type = 'unsigned'}\n"
"---\n"
"...\n"
"tarantool> format[2] = {name = 'field2', type = 'string'}\n"
"---\n"
"...\n"
"tarantool> s = box.schema.space.create('test', {format = format})\n"
"---\n"
"...\n"
"tarantool> pk = s:create_index('pk')\n"
"---\n"
"...\n"
"tarantool> t = s:replace{1, 'Я'}\n"
"---\n"
"...\n"
"tarantool> t['field2']\n"
"---\n"
"- Я\n"
"..."
msgstr ""
"tarantool> format = {}\n"
"---\n"
"...\n"
"tarantool> format[1] = {name = 'field1', type = 'unsigned'}\n"
"---\n"
"...\n"
"tarantool> format[2] = {name = 'field2', type = 'string'}\n"
"---\n"
"...\n"
"tarantool> s = box.schema.space.create('test', {format = format})\n"
"---\n"
"...\n"
"tarantool> pk = s:create_index('pk')\n"
"---\n"
"...\n"
"tarantool> t = s:replace{1, 'Я'}\n"
"---\n"
"...\n"
"tarantool> t['field2']\n"
"---\n"
"- Я\n"
"..."

#: ../doc/book/box/box_tuple.rst:249
msgid ""
"If ``t`` is a tuple instance, ``t['path']`` will return the field or "
"subset of fields that are in ``path``. ``path`` must be a well formed "
"JSON specification. ``path`` may contain field names if the tuple has "
"been retrieved from a space that has an associated :ref:`format "
"<box_space-format>`."
msgstr ""
"Если ``t`` -- это экземпляр кортежа, то ``t['path']`` вернет поле или ряд"
" полей, которые находятся в ``path``. Параметр ``path`` должен "
"представлять собой правильную JSON-спецификацию. ``path`` может содержать"
" имена полей, если кортеж был получен из спейса с заданным :ref:`форматом"
" <box_space-format>`."

#: ../doc/book/box/box_tuple.rst:254
msgid ""
"To prevent ambiguity, Tarantool first tries to interpret the request as "
":ref:`tuple_object[field-number] <box_tuple-field_number>` or "
":ref:`tuple_object[field-name] <box_tuple-field_name>`. If and only if "
"that fails, Tarantool tries to interpret the request as ``tuple_object"
"[field-path]``."
msgstr ""
"Во избежание неоднозначности Tarantool сначала пытается интерпретировать "
"запрос как :ref:`tuple_object[field-number] <box_tuple-field_number>` или"
"  :ref:`tuple_object[field-name] <box_tuple-field_name>`. И только в том "
"случае, если это не удается, Tarantool пытается интерпретировать запрос "
"как ``tuple_object[field-path]``."

#: ../doc/book/box/box_tuple.rst:260
msgid ""
"The path must be a well formed JSON specification, but it may be preceded"
" by '.'. The '.' is a signal that the path acts as a suffix for the "
"tuple."
msgstr ""
"Путь path должен представлять собой правильную JSON-спецификацию, но в "
"начале может стоять '.'. Символ '.' означает, что путь выступает в "
"качестве суффикса для кортежа."

#: ../doc/book/box/box_tuple.rst:264
msgid ""
"The advantage of specifying a path is that Tarantool will use it to "
"search through a tuple body and get only the tuple part, or parts, that "
"are actually necessary."
msgstr ""
"При указании пути Tarantool воспользуется им для поиска по телу кортежа и"
" вернет только тот компонент кортежа, который действительно необходим."

#: ../doc/book/box/box_tuple.rst:268
msgid ""
"In the following example, a tuple named ``t`` is returned from "
"``replace`` and then only the relevant part (in this case, matching a "
"name) of a relevant field is returned. Namely: the second field, the "
"sixth part, the value following 'value='."
msgstr ""
"В следующем примере кортеж под названием ``t`` возвращается после "
"операции замены, а затем возвращается только необходимый компонент (в "
"данном случае совпадение имени) соответствующего поля. В частности: "
"второе поле, шестой компонент, значение после 'value='."

#: ../doc/book/box/box_tuple.rst:273
msgid ""
"tarantool> format = {}\n"
"---\n"
"...\n"
"tarantool> format[1] = {name = 'field1', type = 'unsigned'}\n"
"---\n"
"...\n"
"tarantool> format[2] = {name = 'field2', type = 'array'}\n"
"---\n"
"...\n"
"tarantool> format[3] = {name = 'field4', type = 'string' }\n"
"---\n"
"...\n"
"tarantool> format[4] = {name = \"[2][6]['пw']['Я']\", type = 'string'}\n"
"---\n"
"...\n"
"tarantool> s = box.schema.space.create('test', {format = format})\n"
"---\n"
"...\n"
"tarantool> pk = s:create_index('pk')\n"
"---\n"
"...\n"
"tarantool> field2 = {1, 2, 3, \"4\", {5,6,7}, {пw={Я=\"п\"}, key=\"V!\", "
"value=\"K!\"}}\n"
"---\n"
"...\n"
"tarantool> t = s:replace{1, field2, \"123456\", \"Not K!\"}\n"
"---\n"
"...\n"
"tarantool> t[\"[2][6]['value']\"]\n"
"---\n"
"- K!\n"
"..."
msgstr ""
"tarantool> format = {}\n"
"---\n"
"...\n"
"tarantool> format[1] = {name = 'field1', type = 'unsigned'}\n"
"---\n"
"...\n"
"tarantool> format[2] = {name = 'field2', type = 'array'}\n"
"---\n"
"...\n"
"tarantool> format[3] = {name = 'field4', type = 'string' }\n"
"---\n"
"...\n"
"tarantool> format[4] = {name = \"[2][6]['пw']['Я']\", type = 'string'}\n"
"---\n"
"...\n"
"tarantool> s = box.schema.space.create('test', {format = format})\n"
"---\n"
"...\n"
"tarantool> pk = s:create_index('pk')\n"
"---\n"
"...\n"
"tarantool> field2 = {1, 2, 3, \"4\", {5,6,7}, {пw={Я=\"п\"}, key=\"V!\", "
"value=\"K!\"}}\n"
"---\n"
"...\n"
"tarantool> t = s:replace{1, field2, \"123456\", \"Not K!\"}\n"
"---\n"
"...\n"
"tarantool> t[\"[2][6]['value']\"]\n"
"---\n"
"- K!\n"
"..."

#: ../doc/book/box/box_tuple.rst:312
msgid ""
"If ``t`` is a tuple instance, ``t:find(search-value)`` will return the "
"number of the first field in ``t`` that matches the search value, and "
"``t:findall(search-value [, search-value ...])`` will return numbers of "
"all fields in ``t`` that match the search value. Optionally one can put a"
" numeric argument ``field-number`` before the search-value to indicate "
"“start searching at field number ``field-number``.”"
msgstr ""
"Если ``t`` -- это экземпляр кортежа, то ``t:find(search-value)`` вернет "
"номер первого поля в ``t``, которое совпадает с искомым значением, а "
"``t:findall(search-value [, search-value ...])`` вернет номера всех колей"
" в ``t``, которые совпадают с искомым значением. Можно дополнительно "
"добавить числовой аргумент ``field-number`` перед search-value, чтобы "
"задать условие “начинать поиск с номера поля ``field-number``.”"

#: ../doc/book/box/box_tuple.rst:319
msgid "the number of the field in the tuple."
msgstr "номер поля в кортеже."

#: ../doc/book/box/box_tuple.rst:322
msgid ""
"In the following example, a tuple named ``t`` is created and then: the "
"number of the first field in ``t`` which matches 'a' is returned, then "
"the numbers of all the fields in ``t`` which match 'a' are returned, then"
" the numbers of all the fields in t which match 'a' and are at or after "
"the second field are returned."
msgstr ""
"В следующем примере создается кортеж с именем ``t``, а затем: "
"возвращается номер первого поля в ``t``, которое совпадает с 'a', затем "
"возвращаются номера всех полей в ``t``, которые совпадают с 'a', затем "
"возвращаются номера всех полей в t, которые совпадают с 'a', и находятся "
"на втором месте или далее."

#: ../doc/book/box/box_tuple.rst:328
msgid ""
"tarantool> t = box.tuple.new{'a', 'b', 'c', 'a'}\n"
"---\n"
"...\n"
"tarantool> t:find('a')\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> t:findall('a')\n"
"---\n"
"- 1\n"
"- 4\n"
"...\n"
"tarantool> t:findall(2, 'a')\n"
"---\n"
"- 4\n"
"..."
msgstr ""
"tarantool> t = box.tuple.new{'a', 'b', 'c', 'a'}\n"
"---\n"
"...\n"
"tarantool> t:find('a')\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> t:findall('a')\n"
"---\n"
"- 1\n"
"- 4\n"
"...\n"
"tarantool> t:findall(2, 'a')\n"
"---\n"
"- 4\n"
"..."

#: ../doc/book/box/box_tuple.rst:351
msgid ""
"If ``t`` is a tuple instance, :samp:`t:transform({start-field-number"
"},{fields-to-remove})` will return a tuple where, starting from field "
"``start-field-number``, a number of fields (``fields-to-remove``) are "
"removed. Optionally one can add more arguments after ``fields-to-remove``"
" to indicate new values that will replace what was removed."
msgstr ""
"Если ``t`` -- это экземпляр кортежа, то :samp:`t:transform({start-field-"
"number},{fields-to-remove})` вернет кортеж, где начиная с поля ``start-"
"field-number``, удаляется количество полей (``fields-to-remove``). "
"Дополнительно можно добавить аргументы после ``fields-to-remove``, чтобы "
"указать новые значения на замену удаленных."

#: ../doc/book/box/box_tuple.rst:357
msgid ""
"If the original tuple comes from a space that has been formatted with a "
":ref:`format clause <box_space-format>`, the formatting will not be "
"preserved for the result tuple."
msgstr ""
"Если первоначальный кортеж приходит из спейса, который был форматирован "
"посредством :ref:`оператора формата <box_space-format>`, форматирование "
"возвращаемого кортежа не сохранится."

#: ../doc/book/box/box_tuple.rst:361
msgid "base 1, may be negative"
msgstr "начиная с 1, может быть отрицательным"

#: ../doc/book/box/box_tuple.rst:367
msgid ""
"In the following example, a tuple named ``t`` is created and then, "
"starting from the second field, two fields are removed but one new one is"
" added, then the result is returned."
msgstr ""
"В следующем примере создается кортеж под названием ``t``, а затем начиная"
" со второго поля, удаляются два поля, а одно новое поле добавляется, "
"затем возвращается результат."

#: ../doc/book/box/box_tuple.rst:371
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}"
"\n"
"---\n"
"...\n"
"tarantool> t:transform(2, 2, 'x')\n"
"---\n"
"- ['Fld#1', 'x', 'Fld#4', 'Fld#5']\n"
"..."
msgstr ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}"
"\n"
"---\n"
"...\n"
"tarantool> t:transform(2, 2, 'x')\n"
"---\n"
"- ['Fld#1', 'x', 'Fld#4', 'Fld#5']\n"
"..."

#: ../doc/book/box/box_tuple.rst:385
msgid ""
"If ``t`` is a tuple instance, ``t:unpack()`` will return all fields, "
"``t:unpack(1)`` will return all fields starting with field number 1, "
"``t:unpack(1,5)`` will return all fields between field number 1 and field"
" number 5."
msgstr ""
"Если ``t`` -- это экземпляр кортежа, то ``t:unpack()`` вернет все поля, "
"``t:unpack(1)`` вернет все поля, начиная с поля №1, ``t:unpack(1,5)`` "
"вернет все поля между полем №1 и полем №5."

#: ../doc/book/box/box_tuple.rst:389
msgid "field(s) from the tuple."
msgstr "поле или поля из кортежа."

#: ../doc/book/box/box_tuple.rst:390
msgid "lua-value(s)"
msgstr "Lua-значение(я)"

#: ../doc/book/box/box_tuple.rst:392
msgid ""
"In the following example, a tuple named ``t`` is created and then all its"
" fields are selected, then the result is returned."
msgstr ""
"В следующем примере создается кортеж под названием ``t``, а затем "
"делается выборка всех полей, возвращается результат."

#: ../doc/book/box/box_tuple.rst:395
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}"
"\n"
"---\n"
"...\n"
"tarantool> t:unpack()\n"
"---\n"
"- Fld#1\n"
"- Fld#2\n"
"- Fld#3\n"
"- Fld#4\n"
"- Fld#5\n"
"..."
msgstr ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}"
"\n"
"---\n"
"...\n"
"tarantool> t:unpack()\n"
"---\n"
"- Fld#1\n"
"- Fld#2\n"
"- Fld#3\n"
"- Fld#4\n"
"- Fld#5\n"
"..."

#: ../doc/book/box/box_tuple.rst:413
msgid ""
"If ``t`` is a tuple instance, ``t:totable()`` will return all fields, "
"``t:totable(1)`` will return all fields starting with field number 1, "
"``t:totable(1,5)`` will return all fields between field number 1 and "
"field number 5."
msgstr ""
"Если ``t`` -- это экземпляр кортежа, то ``t:totable()`` вернет все поля, "
"``t:totable(1)`` вернет все поля, начиная с поля №1, ``t:totable(1,5)`` "
"вернет все поля между полем №1 и полем №5."

#: ../doc/book/box/box_tuple.rst:417
msgid "It is preferable to use ``t:totable()`` rather than ``t:unpack()``."
msgstr "Рекомендуется использовать ``t:totable()``, а не ``t:unpack()``."

#: ../doc/book/box/box_tuple.rst:419
msgid "field(s) from the tuple"
msgstr "поле или поля из кортежа"

#: ../doc/book/box/box_tuple.rst:420 ../doc/book/box/box_tuple.rst:469
msgid "lua-table"
msgstr "Lua-таблица"

#: ../doc/book/box/box_tuple.rst:422
msgid ""
"In the following example, a tuple named ``t`` is created, then all its "
"fields are selected, then the result is returned."
msgstr ""
"В следующем примере создается кортеж под названием ``t``, а затем "
"делается выборка всех полей, возвращается результат."

#: ../doc/book/box/box_tuple.rst:425
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}"
"\n"
"---\n"
"...\n"
"tarantool> t:totable()\n"
"---\n"
"- ['Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5']\n"
"..."
msgstr ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}"
"\n"
"---\n"
"...\n"
"tarantool> t:totable()\n"
"---\n"
"- ['Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5']\n"
"..."

#: ../doc/book/box/box_tuple.rst:439
msgid ""
"A `Lua table <https://www.lua.org/pil/2.5.html>`_ can have indexed "
"values, also called key:value pairs. For example, here:"
msgstr ""
"В `Lua-таблице <https://www.lua.org/pil/2.5.html>`_ могут быть "
"индексированные значения, которые также называются пары ключ-значение. "
"Например, здесь:"

#: ../doc/book/box/box_tuple.rst:443
msgid "a = {}; a['field1'] = 10; a['field2'] = 20"
msgstr "a = {}; a['field1'] = 10; a['field2'] = 20"

#: ../doc/book/box/box_tuple.rst:447
msgid "``a`` is a table with \"field1: 10\" and \"field2: 20\"."
msgstr "``a`` -- это таблица с \"field1: 10\" и \"field2: 20\"."

#: ../doc/book/box/box_tuple.rst:449
msgid ""
"The :ref:`tuple_object:totable() <box_tuple-totable>` function only "
"returns a table containing the values. But the ``tuple_object:tomap()`` "
"function returns a table containing not only the values, but also the "
"key:value pairs."
msgstr ""
"Функция :ref:`tuple_object:totable() <box_tuple-totable>` вернет только "
"таблицу со значениями. А функция ``tuple_object:tomap()`` вернет таблицу "
"не только со значениями, но и с парами ключ-значение."

#: ../doc/book/box/box_tuple.rst:454
msgid ""
"This only works if the tuple comes from a space that has been formatted "
"with a :ref:`format clause <box_space-format>`."
msgstr ""
"Это сработает только в том случае, если кортеж приходит из спейса, "
"который был форматирован посредством :ref:`оператора формата <box_space-"
"format>`."

#: ../doc/book/box/box_tuple.rst:457
msgid ""
"the only possible option is ``names_only``.  If ``names_only`` is false "
"or omitted (default), then all the fields will appear twice, first with "
"numeric headings and second with name headings.  If ``names_only`` is "
"true, then all the fields will appear only once, with name headings."
msgstr ""
"единственный доступный параметр -- ``names_only``.  Если ``names_only`` "
"принимает значение false или не указан (по умолчанию), то все поля "
"появятся дважды: сначала с числовыми заголовками, а затем с именными "
"заголовками. Если же ``names_only`` = true, то все поля будут выведены "
"один раз с именными заголовками."

#: ../doc/book/box/box_tuple.rst:457
msgid "the only possible option is ``names_only``."
msgstr "единственный доступный параметр -- ``names_only``."

#: ../doc/book/box/box_tuple.rst:459
msgid ""
"If ``names_only`` is false or omitted (default), then all the fields will"
" appear twice, first with numeric headings and second with name headings."
msgstr ""
"Если ``names_only`` принимает значение false или не указан (по "
"умолчанию), то все поля появятся дважды: сначала с числовыми заголовками,"
" а затем с именными заголовками."

#: ../doc/book/box/box_tuple.rst:464
msgid ""
"If ``names_only`` is true, then all the fields will appear only once, "
"with name headings."
msgstr ""
"Если же ``names_only`` = true, то все поля будут выведены один раз с "
"именными заголовками."

#: ../doc/book/box/box_tuple.rst:468
msgid "field-number:value pair(s) and key:value pair(s) from the tuple"
msgstr "пары номер-поля:значение и пары ключ:значение из кортежа"

#: ../doc/book/box/box_tuple.rst:471
msgid ""
"In the following example, a tuple named ``t1`` is returned from a space "
"that has been formatted, then tables named ``t1map1`` and ``t1map2`` are "
"produced from ``t1``."
msgstr ""
"В следующем примере возвращается кортеж с именем ``t1`` из спейса после "
"форматирования, затем таблицы с именами ``t1map`` и ``t1map2`` создаются "
"из ``t1``."

#: ../doc/book/box/box_tuple.rst:475
msgid ""
"format = {{'field1', 'unsigned'}, {'field2', 'unsigned'}}\n"
"s = box.schema.space.create('test', {format = format})\n"
"s:create_index('pk',{parts={1,'unsigned',2,'unsigned'}})\n"
"t1 = s:insert{10, 20}\n"
"t1map = t1:tomap()\n"
"t1map_names_only = t1:tomap({names_only=true})"
msgstr ""
"format = {{'field1', 'unsigned'}, {'field2', 'unsigned'}}\n"
"s = box.schema.space.create('test', {format = format})\n"
"s:create_index('pk',{parts={1,'unsigned',2,'unsigned'}})\n"
"t1 = s:insert{10, 20}\n"
"t1map = t1:tomap()\n"
"t1map_names_only = t1:tomap({names_only=true})"

#: ../doc/book/box/box_tuple.rst:484
msgid ""
"``t1map`` will contain \"1: 10\", \"2: 20\", \"field1: 10\", \"field2: "
"20\"."
msgstr ""
"``t1map`` будет содержать \"1: 10\", \"2: 20\", \"field1: 10\", \"field2:"
" 20\"."

#: ../doc/book/box/box_tuple.rst:486
msgid "``t1map_names_only`` will contain \"field1: 10\", \"field2: 20\"."
msgstr "``t1map_names_only`` будет содержать \"field1: 10\" и \"field2: 20\"."

#: ../doc/book/box/box_tuple.rst:492
msgid ""
"In Lua, `lua-table-value:pairs() <https://www.lua.org/pil/7.3.html>`_ is "
"a method which returns: ``function``, ``lua-table-value``, ``nil``."
msgstr ""

#: ../doc/book/box/box_tuple.rst:496
msgid ""
"Tarantool has extended this so that ``tuple-value:pairs()`` returns: "
"``function``, ``tuple-value``, ``nil``. It is useful for Lua iterators, "
"because Lua iterators traverse a value's components until an end marker "
"is reached."
msgstr ""

#: ../doc/book/box/box_tuple.rst:501
msgid "function, tuple-value, nil"
msgstr "функция, значение кортежа, nil"

#: ../doc/book/box/box_tuple.rst:502
msgid "function, lua-value, nil"
msgstr "функция, Lua-значение, nil"

#: ../doc/book/box/box_tuple.rst:504
msgid ""
"In the following example, a tuple named ``t`` is created and then all its"
" fields are selected using a Lua for-end loop."
msgstr ""
"В следующем примере создается кортеж под названием ``t``, а затем все его"
" поля выбираются с помощью Lua-цикла for."

#: ../doc/book/box/box_tuple.rst:507
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}"
"\n"
"---\n"
"...\n"
"tarantool> tmp = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in t:pairs() do\n"
"         >   tmp = tmp .. v\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> tmp\n"
"---\n"
"- Fld#1Fld#2Fld#3Fld#4Fld#5\n"
"..."
msgstr ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}"
"\n"
"---\n"
"...\n"
"tarantool> tmp = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in t:pairs() do\n"
"         >   tmp = tmp .. v\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> tmp\n"
"---\n"
"- Fld#1Fld#2Fld#3Fld#4Fld#5\n"
"..."

#: ../doc/book/box/box_tuple.rst:531
msgid ""
"This function updates a tuple which is not in a space. Compare the "
"function :extsamp:`box.space.{*{space-name}*}:update({*{key}*}, "
"{{{*{format}*}, {*{field_no}*}, {*{value}*}}, ...})` which updates a "
"tuple in a space."
msgstr ""
"Эта функция обновляет кортеж, который находится не в спейсе. Ср. функцию "
":extsamp:`box.space.{*{space-name}*}:update({*{key}*}, {{{*{format}*}, "
"{*{field_no}*}, {*{value}*}}, ...})`, которая обновляет кортеж в спейсе."

#: ../doc/book/box/box_tuple.rst:535
msgid ""
"For details: see the description for ``operator``, ``field_no``, and "
"``value`` in the section :ref:`box.space.space-name:update{key, format, "
"{field_number, value}...) <box_space-update>`."
msgstr ""
"Более подробную информацию см. в описании ``operator``, ``field_no`` и "
"``value`` в разделе :ref:`box.space.space-name:update{key, format, "
"{field_number, value}...) <box_space-update>`."

#: ../doc/book/box/box_tuple.rst:539
msgid ""
"If the original tuple comes from a space that has been formatted with a "
":ref:`format clause <box_space-format>`, the formatting will be preserved"
" for the result tuple."
msgstr ""
"Если первоначальный кортеж приходит из спейса, который был форматирован "
"посредством :ref:`оператора формата <box_space-format>`, форматирование "
"возвращаемого кортежа сохранится."

#: ../doc/book/box/box_tuple.rst:543
msgid "operation type represented in string (e.g. '``=``' for 'assign new value')"
msgstr ""
"тип операции, представленный строкой (например, '``=``' означает "
"'присвоить новое значение')"

#: ../doc/book/box/box_tuple.rst:551
msgid "new tuple"
msgstr "новый кортеж"

#: ../doc/book/box/box_tuple.rst:554
msgid ""
"In the following example, a tuple named ``t`` is created and then its "
"second field is updated to equal 'B'."
msgstr ""
"В следующем примере создается кортеж под названием ``t``, а затем второе "
"поле обновляется до равного 'B'."

#: ../doc/book/box/box_tuple.rst:557
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}"
"\n"
"---\n"
"...\n"
"tarantool> t:update({{'=', 2, 'B'}})\n"
"---\n"
"- ['Fld#1', 'B', 'Fld#3', 'Fld#4', 'Fld#5']\n"
"..."
msgstr ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}"
"\n"
"---\n"
"...\n"
"tarantool> t:update({{'=', 2, 'B'}})\n"
"---\n"
"- ['Fld#1', 'B', 'Fld#3', 'Fld#4', 'Fld#5']\n"
"..."

#: ../doc/book/box/box_tuple.rst:569 ../doc/book/sql.rst:23
msgid "Example"
msgstr "Пример"

#: ../doc/book/box/box_tuple.rst:571
msgid ""
"This function will illustrate how to convert tuples to/from Lua tables "
"and lists of scalars:"
msgstr ""
"Представленная ниже функция проиллюстрирует, как можно преобразовать "
"кортежи в Lua-таблицы и списки скаляров и обратно:"

#: ../doc/book/box/box_tuple.rst:574
msgid ""
"tuple = box.tuple.new({scalar1, scalar2, ... scalar_n}) -- scalars to "
"tuple\n"
"lua_table = {tuple:unpack()}                            -- tuple to Lua "
"table\n"
"lua_table = tuple:totable()                             -- tuple to Lua "
"table\n"
"scalar1, scalar2, ... scalar_n = tuple:unpack()         -- tuple to "
"scalars\n"
"tuple = box.tuple.new(lua_table)                        -- Lua table to "
"tuple"
msgstr ""
"tuple = box.tuple.new({scalar1, scalar2, ... scalar_n}) -- скаляры в "
"кортеж\n"
"lua_table = {tuple:unpack()}                            -- кортеж в "
"Lua-таблицу\n"
"lua_table = tuple:totable()                             -- кортеж в "
"Lua-таблицу\n"
"scalar1, scalar2, ... scalar_n = tuple:unpack()         -- кортеж в "
"скаляры\n"
"tuple = box.tuple.new(lua_table)                        -- Lua-таблицу в "
"кортеж"

#: ../doc/book/box/box_tuple.rst:582
msgid ""
"Then it will find the field that contains 'b', remove that field from the"
" tuple, and display how many bytes remain in the tuple. The function uses"
" Tarantool ``box.tuple`` functions ``new()``, ``unpack()``, ``find()``, "
"``transform()``, ``bsize()``."
msgstr ""
"Затем она найдет поле, которое содержит значение 'b', удалит это поле из "
"кортежа и отобразит количество байтов, оставшихся в кортеже. Данная "
"функция использует следующие функции ``box.tuple`` Tarantool'а: "
"``new()``, ``unpack()``, ``find()``, ``transform()``, ``bsize()``."

#: ../doc/book/box/box_tuple.rst:587
msgid ""
"function example()\n"
"  local tuple1, tuple2, lua_table_1, scalar1, scalar2, scalar3, "
"field_number\n"
"  local luatable1 = {}\n"
"  tuple1 = box.tuple.new({'a', 'b', 'c'})\n"
"  luatable1 = tuple1:totable()\n"
"  scalar1, scalar2, scalar3 = tuple1:unpack()\n"
"  tuple2 = box.tuple.new(luatable1[1],luatable1[2],luatable1[3])\n"
"  field_number = tuple2:find('b')\n"
"  tuple2 = tuple2:transform(field_number, 1)\n"
"  return 'tuple2 = ' , tuple2 , ' # of bytes = ' , tuple2:bsize()\n"
"end"
msgstr ""
"function example()\n"
"  local tuple1, tuple2, lua_table_1, scalar1, scalar2, scalar3, "
"field_number\n"
"  local luatable1 = {}\n"
"  tuple1 = box.tuple.new({'a', 'b', 'c'})\n"
"  luatable1 = tuple1:totable()\n"
"  scalar1, scalar2, scalar3 = tuple1:unpack()\n"
"  tuple2 = box.tuple.new(luatable1[1],luatable1[2],luatable1[3])\n"
"  field_number = tuple2:find('b')\n"
"  tuple2 = tuple2:transform(field_number, 1)\n"
"  return 'tuple2 = ' , tuple2 , ' # of bytes = ' , tuple2:bsize()\n"
"end"

#: ../doc/book/box/box_tuple.rst:603
msgid ""
"tarantool> example()\n"
"---\n"
"- tuple2 =\n"
"- ['a', 'c']\n"
"- ' # of bytes = '\n"
"- 5\n"
"..."
msgstr ""
"tarantool> example()\n"
"---\n"
"- tuple2 =\n"
"- ['a', 'c']\n"
"- ' # of bytes = '\n"
"- 5\n"
"..."

#: ../doc/book/box/box_txn_management.rst:5
msgid "Functions for transaction management"
msgstr "Управление экземплярами"

#: ../doc/book/box/box_txn_management.rst:11
msgid ""
"For general information and examples, see section :ref:`Transaction "
"control <atomic-atomic_execution>`."
msgstr ""
"Чтобы получить общую информацию и взглянуть на примеры использования, см."
" раздел :ref:`Управление транзакциями <atomic-atomic_execution>`."

#: ../doc/book/box/box_txn_management.rst:14
msgid "Observe the following rules when working with transactions:"
msgstr "Соблюдайте следующие правила в работе с транзакциями:"

#: ../doc/book/box/box_txn_management.rst:16
msgid "Rule #1"
msgstr "Правило #1"

#: ../doc/book/box/box_txn_management.rst:19
msgid ""
"The requests in a transaction must be sent to a server as a single block."
" It is not enough to enclose them between begin and commit or rollback. "
"To ensure they are sent as a single block: put them in a function, or put"
" them all on one line, or use a delimiter so that multi-line requests are"
" handled together."
msgstr ""
"Запросы в транзакции должны отправляться на сервер в виде единого блока. "
"Недостаточно просто размещать их между началом транзакции и коммитом или "
"откатом. Чтобы убедиться, что они отправляются в виде единого блока: "
"поместите их в функцию, поместите их на одну строку или используйте "
"символы-разделители, чтобы многостроковые запросы обрабатывались "
"совместно."

#: ../doc/book/box/box_txn_management.rst:25
msgid "Rule #2"
msgstr "Правило #2"

#: ../doc/book/box/box_txn_management.rst:28
msgid ""
"All database operations in a transaction should use the same storage "
"engine. It is not safe to access tuple sets that are defined with "
"``{engine='vinyl'}`` and also access tuple sets that are defined with "
"``{engine='memtx'}``, in the same transaction."
msgstr ""
"Все операции с базой данных в рамках транзакции должны работать с одним "
"движком баз данных. Небезопасно в рамках одной транзакции получать доступ"
" к наборам кортежей, которые определяются по ``{engine='vinyl'}``, а "
"также к наборам кортежей, которые определяются по ``{engine='memtx'}``."

#: ../doc/book/box/box_txn_management.rst:33
msgid "Rule #3"
msgstr "Правило #3"

#: ../doc/book/box/box_txn_management.rst:36
msgid ""
"Requests which cause changes to the data definition -- create, alter, "
"drop, truncate -- are only allowed with Tarantool version 2.1 or later. "
"Data-definition requests which change an index or change a format, such "
"as :ref:`space_object:create_index() <box_schema-sequence_create_index>` "
"and :ref:`space_object:format() <box_space-format>`, are not allowed "
"inside transactions except as the first request after ``box.begin()``."
msgstr ""

#: ../doc/book/box/box_txn_management.rst:50
msgid "Below is a list of all functions for transaction management."
msgstr "Ниже приведен перечень всех функций для управления транзакциями."

#: ../doc/book/box/box_txn_management.rst:62
msgid ":ref:`box.begin() <box-begin>`"
msgstr ":ref:`box.begin() <box-begin>`"

#: ../doc/book/box/box_txn_management.rst:62
msgid "Begin the transaction"
msgstr "Начало транзакции"

#: ../doc/book/box/box_txn_management.rst:65
msgid ":ref:`box.commit() <box-commit>`"
msgstr ":ref:`box.commit() <box-commit>`"

#: ../doc/book/box/box_txn_management.rst:65
msgid "End the transaction and save all changes"
msgstr "Окончание транзакции и сохранение всех изменений"

#: ../doc/book/box/box_txn_management.rst:68
msgid ":ref:`box.rollback() <box-rollback>`"
msgstr ":ref:`box.rollback() <box-rollback>`"

#: ../doc/book/box/box_txn_management.rst:68
msgid "End the transaction and discard all changes"
msgstr "Окончание транзакции и отмена всех изменений"

#: ../doc/book/box/box_txn_management.rst:71
msgid ":ref:`box.savepoint() <box-savepoint>`"
msgstr ":ref:`box.savepoint() <box-savepoint>`"

#: ../doc/book/box/box_txn_management.rst:71
msgid "Get a savepoint descriptor"
msgstr "Получение дескриптора точки сохранения"

#: ../doc/book/box/box_txn_management.rst:74
msgid ":ref:`box.rollback_to_savepoint() <box-rollback_to_savepoint>`"
msgstr ":ref:`box.rollback_to_savepoint() <box-rollback_to_savepoint>`"

#: ../doc/book/box/box_txn_management.rst:74
msgid "Do not end the transaction and discard all changes made after a savepoint"
msgstr ""
"Запрещение окончания транзакции и отмена всех изменений, сделанных после "
"точки сохранения"

#: ../doc/book/box/box_txn_management.rst:78
msgid ":ref:`box.atomic() <box-atomic>`"
msgstr ":ref:`box.atomic() <box-atomic>`"

#: ../doc/book/box/box_txn_management.rst:78
msgid "Execute a function, treating it as a transaction"
msgstr "Выполнение функции как транзакции"

#: ../doc/book/box/box_txn_management.rst:81
msgid ":ref:`box.on_commit() <box-on_commit>`"
msgstr ":ref:`box.on_commit() <box-on_commit>`"

#: ../doc/book/box/box_txn_management.rst:81
#, fuzzy
msgid "Define a trigger that will be activated by box.commit"
msgstr "Определение триггера, активируемого по ``box.commit``"

#: ../doc/book/box/box_txn_management.rst:84
msgid ":ref:`box.on_rollback() <box-on_rollback>`"
msgstr ":ref:`box.on_rollback() <box-on_rollback>`"

#: ../doc/book/box/box_txn_management.rst:84
#, fuzzy
msgid "Define a trigger that will be activated by box.rollback"
msgstr "Определение триггера, активируемого по ``box.rollback``"

#: ../doc/book/box/box_txn_management.rst:87
msgid ":ref:`box.is_in_txn() <box-is_in_txn>`"
msgstr ":ref:`box.is_in_txn() <box-is_in_txn>`"

#: ../doc/book/box/box_txn_management.rst:87
msgid "State whether a transaction is in progress"
msgstr "Обозначение наличия активной транзакции"

#: ../doc/book/box/box_txn_management.rst:95
msgid ""
"Begin the transaction. Disable :ref:`implicit yields <atomic-implicit-"
"yields>` until the transaction ends. Signal that writes to the :ref"
":`write-ahead log <internals-wal>` will be deferred until the transaction"
" ends. In effect the fiber which executes ``box.begin()`` is starting an "
"\"active multi-request transaction\", blocking all other fibers."
msgstr ""
"Начало транзакции. Отключение :ref:`неявной передачи управления <atomic-"
"implicit-yields>` до окончания транзакции. Сигнал о записи в :ref "
":`журнал упреждающей записи <internals-wal>` будет задержан до окончания "
"транзакции. Фактически файбер, который выполняет функцию ``box.begin()``,"
" начинает \"активную транзакцию со множеством запросов\" с блокировкой "
"всех остальных файберов."

#: ../doc/book/box/box_txn_management.rst:103
msgid ""
"**Possible errors:** error if this operation is not permitted because "
"there"
msgstr ""
"**Возможные ошибки:** ошибка, если такая операция не допускается, потому "
"что"

#: ../doc/book/box/box_txn_management.rst:103
msgid ""
"is already an active transaction. error if for some reason memory cannot "
"be allocated."
msgstr ""
"уже есть активная транзакция. ошибка, если по какой-либо причине нельзя "
"выделить память."

#: ../doc/book/box/box_txn_management.rst:110
msgid "End the transaction, and make all its data-change operations permanent."
msgstr ""
"Окончание транзакции и применение результатов всех операций по изменению "
"данных."

#: ../doc/book/box/box_txn_management.rst:113
msgid ""
"**Possible errors:**  error and abort the transaction in case of a "
"conflict."
msgstr "**Возможные ошибки:** ошибка и прерывание транзакции в случае конфликта."

#: ../doc/book/box/box_txn_management.rst:113
msgid ""
"error if the operation fails to write to disk. error if for some reason "
"memory cannot be allocated."
msgstr ""
"ошибка, если операция не может выполнить запись на диск. ошибка, если по "
"какой-либо причине нельзя выделить память."

#: ../doc/book/box/box_txn_management.rst:120
msgid ""
"End the transaction, but cancel all its data-change operations. An "
"explicit call to functions outside ``box.space`` that always yield, such "
"as :ref:`fiber.sleep() <fiber-sleep>` or :ref:`fiber.yield() <fiber-"
"yield>`, will have the same effect."
msgstr ""
"Окончание транзакции, но отмена результатов всех операций по изменению "
"данных. Явный вызов функций не из модуля ``box.space``, которые всегда "
"передают управление, например :ref:`fiber.sleep() <fiber-sleep>` или "
":ref:`fiber.yield() <fiber-yield>`, приведет к тому же результату."

#: ../doc/book/box/box_txn_management.rst:129
msgid ""
"Return a descriptor of a savepoint (type = table), which can be used "
"later by :ref:`box.rollback_to_savepoint(savepoint) <box-"
"rollback_to_savepoint>`. Savepoints can only be created while a "
"transaction is active, and they are destroyed when a transaction ends."
msgstr ""
"Возврат дескриптора точки сохранения (тип = таблица), который может затем"
" использоваться в :ref:`box.rollback_to_savepoint(savepoint) <box-"
"rollback_to_savepoint>`. Точки сохранения могут быть созданы, пока "
"активна транзакция, и удаляются после окончания транзакции."

#: ../doc/book/box/box_txn_management.rst:134
msgid "savepoint table"
msgstr "таблица точки сохранения"

#: ../doc/book/box/box_txn_management.rst:135
msgid "Lua object"
msgstr "Lua-объект"

#: ../doc/book/box/box_txn_management.rst:137
#: ../doc/book/box/box_txn_management.rst:150
msgid "error if the savepoint cannot be set in absence of active transaction."
msgstr ""
"ошибка, если точку сохранения нельзя указать в отсутствие активной "
"транзакции."

#: ../doc/book/box/box_txn_management.rst:140
msgid "**Possible errors:** error if for some reason memory cannot be allocated."
msgstr ""
"**Возможные ошибки:** ошибка, если по какой-либо причине нельзя выделить "
"память."

#: ../doc/book/box/box_txn_management.rst:146
msgid ""
"Do not end the transaction, but cancel all its data-change and "
":ref:`box.savepoint() <box-savepoint>` operations that were done after "
"the specified savepoint."
msgstr ""
"Запрещение окончания транзакции, но отмена всех изменений и операций "
":ref:`box.savepoint() <box-savepoint>`, сделанных после точки сохранения."

#: ../doc/book/box/box_txn_management.rst:153
msgid "**Possible errors:** error if the savepoint does not exist."
msgstr "**Возможные ошибки:** ошибка, если отсутствует точка сохранения."

#: ../doc/book/box/box_txn_management.rst:157
msgid ""
"function f()\n"
"  box.begin()           -- start transaction\n"
"  box.space.t:insert{1} -- this will not be rolled back\n"
"  local s = box.savepoint()\n"
"  box.space.t:insert{2} -- this will be rolled back\n"
"  box.rollback_to_savepoint(s)\n"
"  box.commit()          -- end transaction\n"
"end"
msgstr ""
"function f()\n"
"  box.begin()           -- начало транзакции\n"
"  box.space.t:insert{1} -- это не отменится\n"
"  local s = box.savepoint()\n"
"  box.space.t:insert{2} -- это отменится\n"
"  box.rollback_to_savepoint(s)\n"
"  box.commit()          -- конец транзакции\n"
"end"

#: ../doc/book/box/box_txn_management.rst:172
msgid ""
"Execute a function, acting as if the function starts with an implicit "
":ref:`box.begin() <box-begin>` and ends with an implicit "
":ref:`box.commit() <box-commit>` if successful, or ends with an implicit "
":ref:`box.rollback() <box-rollback>` if there is an error."
msgstr ""
"Выполнение функции так, как будто функция начинается с явного вызова "
":ref:`box.begin() <box-begin>` и заканчивается неявным вызовом "
":ref:`box.commit() <box-commit>` после успешного выполнения или же "
"заканчивается неявным вызовом :ref:`box.rollback() <box-rollback>` в "
"случае ошибки."

#: ../doc/book/box/box_txn_management.rst:177
msgid "the result of the function passed to ``atomic()`` as an argument."
msgstr "результат функции передается в ``atomic()`` в качестве аргумента."

#: ../doc/book/box/box_txn_management.rst:179
msgid "**Possible errors:** any error that :ref:`box.begin() <box-begin>` and"
msgstr ""
"**Возможные ошибки:** любая ошибка, которую могут вызвать "
":ref:`box.begin() <box-begin>`"

#: ../doc/book/box/box_txn_management.rst:180
msgid ":ref:`box.commit() <box-commit>` can return."
msgstr "и :ref:`box.commit() <box-commit>`."

#: ../doc/book/box/box_txn_management.rst:186
msgid ""
"Define a trigger for execution when a transaction ends due to an event "
"such as :ref:`box.commit <box-commit>`."
msgstr ""
"Определения триггера, выполняемого в случае окончания транзакции в связи "
"с :ref:`box.commit <box-commit>`."

#: ../doc/book/box/box_txn_management.rst:189
msgid ""
"The trigger function may take an iterator parameter, as described in an "
"example for this section."
msgstr ""
"Функция с триггером может принимать параметр с итератором, как описано в "
"примере к данному разделу."

#: ../doc/book/box/box_txn_management.rst:192
msgid "The trigger function should not access any database spaces."
msgstr "Функция с триггером не должна получать доступ к любым спейсам базы данных."

#: ../doc/book/box/box_txn_management.rst:194
msgid ""
"If the trigger execution fails and raises an error, the effect is severe "
"and should be avoided -- use Lua's ``pcall()`` mechanism around code that"
" might fail."
msgstr ""
"Если триггер не сработает и выдаст ошибку, результат будет "
"неблагоприятным, чего следует избегать -- используйте Lua-механизм "
"``pcall()`` вокруг кода, который может не сработать."

#: ../doc/book/box/box_txn_management.rst:198
msgid ""
"``box.on_commit()`` must be invoked within a transaction, and the trigger"
" ceases to exist when the transaction ends."
msgstr ""
"``box.on_commit()`` следует вызывать в пределах транзакции, и триггер "
"прекращает существование по окончании транзакции."

#: ../doc/book/box/box_txn_management.rst:213
msgid "**Simple and useless example:** this will display 'commit happened':"
msgstr "**Простой и бесполезный пример:** покажет, что произошел коммит:"

#: ../doc/book/box/box_txn_management.rst:215
msgid ""
"function f()\n"
"function f() print('commit happened') end\n"
"box.begin() box.on_commit(f) box.commit()"
msgstr ""
"function f()\n"
"function f() print('commit happened') end\n"
"box.begin() box.on_commit(f) box.commit()"

#: ../doc/book/box/box_txn_management.rst:221
msgid ""
"But of course there is more to it: the function parameter can be an "
"ITERATOR."
msgstr "Но, конечно, это еще не всё: параметр функции может быть ИТЕРАТОРОМ."

#: ../doc/book/box/box_txn_management.rst:223
msgid ""
"The iterator goes through the effects of every request that changed a "
"space during the transaction."
msgstr ""
"Итератор проходит по результатам каждого запроса изменения спейса в "
"пределах транзакции."

#: ../doc/book/box/box_txn_management.rst:226
msgid "The iterator will have:"
msgstr "Итератор будет содержать:"

#: ../doc/book/box/box_txn_management.rst:228
msgid "an ordinal request number,"
msgstr "порядковый номер запроса,"

#: ../doc/book/box/box_txn_management.rst:229
msgid ""
"the old value of the tuple before the request (this will be nil for an "
"insert request),"
msgstr ""
"старое значение кортежа до запроса (для запросов вставки это будет "
"нулевое значение nil),"

#: ../doc/book/box/box_txn_management.rst:231
msgid ""
"the new value of the tuple after the request (this will be nil for a "
"delete request),"
msgstr ""
"новое значение кортежа после запроса (для запросов удаления это будет "
"нулевое значение nil),"

#: ../doc/book/box/box_txn_management.rst:233
msgid "and the id of the space."
msgstr "и идентификатор спейса."

#: ../doc/book/box/box_txn_management.rst:235
msgid ""
"**Less simple more useful example:** this will display the effects of two"
" replace requests:"
msgstr ""
"**Более сложный и более полезный пример:** покажет результат двух "
"запросов замены:"

#: ../doc/book/box/box_txn_management.rst:238
msgid ""
"box.space.test:drop()\n"
"s = box.schema.space.create('test')\n"
"i = box.space.test:create_index('i')\n"
"function f(iterator)\n"
"  for request_number, old_tuple, new_tuple, space_id in iterator() do\n"
"    print('request_number ' .. tostring(request_number))\n"
"    print('  old_tuple ' .. tostring(old_tuple[1]) .. ' ' .. "
"old_tuple[2])\n"
"    print('  new_tuple ' .. tostring(new_tuple[1]) .. ' ' .. "
"new_tuple[2])\n"
"    print('  space_id ' .. tostring(space_id))\n"
"  end\n"
"end\n"
"s:insert{1,'-'}\n"
"box.begin() s:replace{1,'x'} s:replace{1,'y'} box.on_commit(f) "
"box.commit()"
msgstr ""
"box.space.test:drop()\n"
"s = box.schema.space.create('test')\n"
"i = box.space.test:create_index('i')\n"
"function f(iterator)\n"
"  for request_number, old_tuple, new_tuple, space_id in iterator() do\n"
"    print('request_number ' .. tostring(request_number))\n"
"    print('  old_tuple ' .. tostring(old_tuple[1]) .. ' ' .. "
"old_tuple[2])\n"
"    print('  new_tuple ' .. tostring(new_tuple[1]) .. ' ' .. "
"new_tuple[2])\n"
"    print('  space_id ' .. tostring(space_id))\n"
"  end\n"
"end\n"
"s:insert{1,'-'}\n"
"box.begin() s:replace{1,'x'} s:replace{1,'y'} box.on_commit(f) "
"box.commit()"

#: ../doc/book/box/box_txn_management.rst:254
msgid "The result will look like this:"
msgstr "Результат будет выглядеть следующим образом:"

#: ../doc/book/box/box_txn_management.rst:256
msgid ""
"tarantool> box.begin() s:replace{1,'x'} s:replace{1,'y'} box.on_commit(f)"
" box.commit()\n"
"request_number 1\n"
"  old_tuple 1 -\n"
"  new_tuple 1 x\n"
"  space_id 517\n"
"request_number 2\n"
"  old_tuple 1 x\n"
"  new_tuple 1 y\n"
"  space_id 517"
msgstr ""
"tarantool> box.begin() s:replace{1,'x'} s:replace{1,'y'} box.on_commit(f)"
" box.commit()\n"
"request_number 1\n"
"  old_tuple 1 -\n"
"  new_tuple 1 x\n"
"  space_id 517\n"
"request_number 2\n"
"  old_tuple 1 x\n"
"  new_tuple 1 y\n"
"  space_id 517"

#: ../doc/book/box/box_txn_management.rst:272
msgid ""
"Define a trigger for execution when a transaction ends due to an event "
"such as :ref:`box.rollback <box-rollback>`."
msgstr ""
"Определение триггера, выполняемого по окончании транзакции в связи с "
":ref:`box.rollback <box-rollback>`."

#: ../doc/book/box/box_txn_management.rst:275
msgid ""
"The parameters and warnings are exactly the same as for :ref:`box.on-"
"commit <box-on_commit>`."
msgstr ""
"Используются точно такие же параметры и предупреждения, как в :ref:`box"
".on-commit <box-on_commit>`."

#: ../doc/book/box/box_txn_management.rst:282
msgid ""
"If a transaction is in progress (for example the user has called "
":ref:`box.begin <box-begin>` and has not yet called either "
":ref:`box.commit <box-commit>` or :ref:`box.rollback <box-rollback>`, "
"return ``true``. Otherwise return ``false``."
msgstr ""
"В процессе транзакции (например, пользователь вызвал :ref:`box.begin "
"<box-begin>` и еще не вызвал ни :ref:`box.commit <box-commit>`, ни "
":ref:`box.rollback <box-rollback>`) возвращается ``true``. В остальных "
"случаях возвращается ``false``."

#: ../doc/book/box/data_model.rst:5
msgid "Data model"
msgstr "Модель данных"

#: ../doc/book/box/data_model.rst:7
msgid ""
"This section describes how Tarantool stores values and what operations "
"with data it supports."
msgstr ""
"В этом разделе описывается то, как в Tarantool'е организовано хранение "
"данных и какие операции с данным он поддерживает."

#: ../doc/book/box/data_model.rst:10
msgid ""
"If you tried to create a database as suggested in our :ref:`\"Getting "
"started\" exercises <getting_started>`, then your test database now looks"
" like this:"
msgstr ""
"Если вы пробовали создать базу данных, как предлагается в упражнениях в "
":ref:`\"Руководстве для начинающих\" <getting_started>`, то ваша тестовая"
" база данных выглядит следующим образом:"

#: ../doc/book/box/data_model.rst:20
msgid "Space"
msgstr "Спейс"

#: ../doc/book/box/data_model.rst:22
msgid "A **space** -- 'tester' in our example -- is a container."
msgstr "*Спейс* -- с именем 'tester' в нашем примере -- это контейнер."

#: ../doc/book/box/data_model.rst:24
msgid ""
"When Tarantool is being used to store data, there is always at least one "
"space. Each space has a unique **name** specified by the user. Besides, "
"each space has a unique **numeric identifier** which can be specified by "
"the user, but usually is assigned automatically by Tarantool. Finally, a "
"space always has an **engine**: *memtx* (default) -- in-memory engine, "
"fast but limited in size, or *vinyl* -- on-disk engine for huge data "
"sets."
msgstr ""
"Когда Tarantool используется для хранения данных, всегда существует хотя "
"бы один спейс. У каждого спейса есть уникальное **имя**, указанное "
"пользователем. Кроме того, пользователь может указать уникальный "
"**числовой идентификатор**, но обычно Tarantool назначает его "
"автоматически. Наконец, в спейсе всегда есть **движок**: *memtx* (по "
"умолчанию) -- in-memory движок, быстрый, но ограниченный в размере, или "
"*vinyl* -- дисковый движок для огромного количества данных."

#: ../doc/book/box/data_model.rst:31
msgid ""
"A space is a container for :ref:`tuples <index-box_tuple>`. To be "
"functional, it needs to have a :ref:`primary index <index-box_index>`. It"
" can also have secondary indexes."
msgstr ""
"Спейс -- это контейнер для :ref:`кортежей <index-box_tuple>`. Для работы "
"ему необходим :ref:`первичный индекс <index-box_index>`. Также возможно "
"использование вторичных индексов."

#: ../doc/book/box/data_model.rst:39
msgid "Tuple"
msgstr "Кортеж"

#: ../doc/book/box/data_model.rst:41
msgid ""
"A **tuple** plays the same role as a “row” or a “record”, and the "
"components of a tuple (which we call “fields”) play the same role as a "
"“row column” or “record field”, except that:"
msgstr ""
"**Кортеж** играет такую же роль, как “строка” или “запись”, а компоненты "
"кортежа (которые мы называем “полями”) играют такую же роль, что и "
"“столбец” или “поле записи”, не считая того, что:"

#: ../doc/book/box/data_model.rst:45
msgid "fields can be composite structures, such as arrays or maps, and"
msgstr ""
"поля могут представлять собой композитные структуры, такие как таблицы "
"типа массива или ассоциативного массива, а также"

#: ../doc/book/box/data_model.rst:46
msgid "fields don't need to have names."
msgstr "полям не нужны имена."

#: ../doc/book/box/data_model.rst:48
msgid ""
"Any given tuple may have any number of fields, and the fields may be of "
"different :ref:`types <index-box_data-types>`. The identifier of a field "
"is the field's number, base 1 (in Lua and other 1-based languages) or "
"base 0 (in PHP or C/C++). For example, ``1`` or ``0`` can be used in some"
" contexts to refer to the first field of a tuple."
msgstr ""
"В любом кортеже может быть любое количество полей, и это могут быть поля "
"разных :ref:`типов <index-box_data-types>`. Идентификатором поля является"
" его номер, начиная с 1 (в Lua и других языках с индексацией с 1) или с 0"
" (в PHP или C/C++). Например, ``1`` или ``0`` могут использоваться в "
"некоторых контекстах для обозначения первого поля кортежа."

#: ../doc/book/box/data_model.rst:55
msgid ""
"Tuples in Tarantool are stored as `MsgPack "
"<https://en.wikipedia.org/wiki/MessagePack>`_ arrays."
msgstr ""
"Кортежи в Tarantool'е хранятся в виде массивов `MsgPack "
"<https://en.wikipedia.org/wiki/MessagePack>`_."

#: ../doc/book/box/data_model.rst:58
#, fuzzy
msgid ""
"When Tarantool returns a tuple value in the console, by default it uses "
":ref:`YAML <interactive_console>` format, for example: ``[3, 'Ace of "
"Base', 1993]``."
msgstr ""
"Когда Tarantool выводит значение в кортеже в консоль, используется формат"
" `YAML <https://ru.wikipedia.org/wiki/YAML>`_, например: ``[3, 'Ace of  "
"Base', 1993]``."

#: ../doc/book/box/data_model.rst:68
msgid "An **index** is a group of key values and pointers."
msgstr "**Индекс** -- это совокупность значений ключей и указателей."

#: ../doc/book/box/data_model.rst:70
msgid ""
"As with spaces, you should specify the index **name**, and let Tarantool "
"come up with a unique **numeric identifier** (\"index id\")."
msgstr ""
"Как и для спейсов, индексам следует указать **имена**, а Tarantool "
"определит уникальный **числовой идентификатор** (\"ID индекса\")."

#: ../doc/book/box/data_model.rst:73
msgid ""
"An index always has a **type**. The default index type is 'TREE'. TREE "
"indexes are provided by all Tarantool engines, can index unique and non-"
"unique values, support partial key searches, comparisons and ordered "
"results. Additionally, memtx engine supports HASH, RTREE and BITSET "
"indexes."
msgstr ""
"У индекса всегда есть определенный **тип**. Тип индекса по умолчанию -- "
"'TREE'. Все движки Tarantool'а предоставляют TREE-индексы, которые могут "
"индексировать уникальные и неуникальные значения, поддерживают поиск по "
"компонентам ключа, сравнение ключей и упорядоченные результаты. Кроме "
"того, движок memtx поддерживает следующие индексы: HASH, RTREE и BITSET."

#: ../doc/book/box/data_model.rst:78
msgid ""
"An index may be **multi-part**, that is, you can declare that an index "
"key value is composed of two or more fields in the tuple, in any order. "
"For example, for an ordinary TREE index, the maximum number of parts is "
"255."
msgstr ""
"Индекс может быть **многокомпонентным**, то есть можно объявить, что ключ"
" индекса состоит из двух или более полей в кортеже в любом порядке. "
"Например, для обычного TREE-индекса максимальное количество частей равно "
"255."

#: ../doc/book/box/data_model.rst:82
msgid ""
"An index may be **unique**, that is, you can declare that it would be "
"illegal to have the same key value twice."
msgstr ""
"Индекс может быть **уникальным**, то есть можно объявить, что недопустимо"
" дважды задавать одно значение ключа."

#: ../doc/book/box/data_model.rst:85
msgid ""
"The first index defined on a space is called the **primary key index**, "
"and it must be unique. All other indexes are called **secondary "
"indexes**, and they may be non-unique."
msgstr ""
"Первый индекс, определенный для спейса, называется **первичный индекс**. "
"Он должен быть уникальным. Все остальные индексы называются **вторичными "
"индексами**, они могут строиться по неуникальным значениям."

#: ../doc/book/box/data_model.rst:89
msgid ""
"An index definition may include identifiers of tuple fields and their "
"expected **types** (see allowed :ref:`indexed field types <index-"
"box_indexed-field-types>` below)."
msgstr ""
"Индекс может содержать идентификаторы полей кортежа и их предполагаемые "
"**типы** (см. допустимые :ref:`типы индексированных полей <index-"
"box_indexed-field-types>` ниже)."

#: ../doc/book/box/data_model.rst:93
msgid ""
"In our example, we first defined the primary index (named 'primary') "
"based on field #1 of each tuple:"
msgstr ""
"В нашем примере для начала определяем первичный индекс (под названием "
"'primary') по полю №1 каждого кортежа:"

#: ../doc/book/box/data_model.rst:96
#, fuzzy
msgid ""
"tarantool> i = s:create_index('primary', {type = 'hash', parts = {field ="
" 1, type = 'unsigned'}})"
msgstr ""
"tarantool> i = s:create_index('primary', {type = 'hash', parts = {1, "
"'unsigned'}})"

#: ../doc/book/box/data_model.rst:100
msgid ""
"The effect is that, for all tuples in space 'tester', field #1 must exist"
" and must contain an unsigned integer. The index type is 'hash', so "
"values in field #1 must be unique, because keys in HASH indexes are "
"unique."
msgstr ""
"Смысл в том, что поле №1 должно существовать и содержать целое число без "
"знака для всех кортежей в спейсе 'tester'. Тип индекса -- 'hash', поэтому"
" значения в поле №1 должны быть уникальными, поскольку ключи в "
"HASH-индексах уникальны."

#: ../doc/book/box/data_model.rst:105
msgid ""
"After that, we defined a secondary index (named 'secondary') based on "
"field #2 of each tuple:"
msgstr ""
"После этого мы определим вторичный индекс (под названием 'secondary') по "
"полю №2 каждого кортежа:"

#: ../doc/book/box/data_model.rst:108
#, fuzzy
msgid ""
"tarantool> i = s:create_index('secondary', {type = 'tree', parts = {field"
" = 2, type = 'string'}})"
msgstr ""
"tarantool> i = s:create_index('secondary', {type = 'tree', parts = {2, "
"'string'}})"

#: ../doc/book/box/data_model.rst:112
msgid ""
"The effect is that, for all tuples in space 'tester', field #2 must exist"
" and must contain a string. The index type is 'tree', so values in field "
"#2 must not be unique, because keys in TREE indexes may be non-unique."
msgstr ""
"Смысл в том, что поле №2 должно существовать и содержать строку для всех "
"кортежей в спейсе 'tester'. Тип индекса -- 'tree', поэтому значения в "
"поле №2 не должны быть уникальными, поскольку ключи в TREE-индексах могут"
" не быть уникальными."

#: ../doc/book/box/data_model.rst:119
msgid ""
"Space definitions and index definitions are stored permanently in "
"Tarantool's system spaces :ref:`_space <box_space-space>` and "
":ref:`_index <box_space-index>` (for details, see reference on "
":ref:`box.space <box_space>` submodule)."
msgstr ""
"Определения спейса и определения индексов хранятся в системных спейсах "
"Tarantool'а :ref:`_space <box_space-space>` и :ref:`_index <box_space-"
"index>` соответственно (для получения подробной информации см. справочник"
" по вложенному модулю :ref:`box.space <box_space>`)."

#: ../doc/book/box/data_model.rst:123
msgid ""
"You can add, drop, or alter the definitions at runtime, with some "
"restrictions. See syntax details in reference on :ref:`box <box-module>` "
"module."
msgstr ""
"Можно добавлять, опускать или изменять определения во время исполнения "
"кода с некоторыми ограничениями. Более подробно о синтаксисе см. в "
"справочнике по модулю :ref:`box <box-module>`."

#: ../doc/book/box/data_model.rst:130
msgid "Data types"
msgstr "Типы данных"

#: ../doc/book/box/data_model.rst:132
msgid ""
"Tarantool is both a database and an application server. Hence a developer"
" often deals with two type sets: the programming language types (e.g. "
"Lua) and the types of the Tarantool storage format (MsgPack)."
msgstr ""
"Tarantool представляет собой базу данных и сервер приложений "
"одновременно. Следовательно, разработчик часто работает с двумя наборами "
"типов: типы языка программирования (например, Lua) и типы формата "
"хранилища Tarantool (MsgPack)."

#: ../doc/book/box/data_model.rst:141
msgid "Lua vs MsgPack"
msgstr "Lua в сравнении с MsgPack"

#: ../doc/book/box/data_model.rst:151
msgid "Scalar / compound"
msgstr "Скалярный / составной"

#: ../doc/book/box/data_model.rst:151
msgid "MsgPack |nbsp| type"
msgstr "MsgPack-тип |nbsp|"

#: ../doc/book/box/data_model.rst:151
msgid "Lua type"
msgstr "Lua-тип"

#: ../doc/book/box/data_model.rst:151
msgid "Example value"
msgstr "Пример значения"

#: ../doc/book/box/data_model.rst:153 ../doc/book/box/data_model.rst:155
#: ../doc/book/box/data_model.rst:157 ../doc/book/box/data_model.rst:159
#: ../doc/book/box/data_model.rst:161 ../doc/book/box/data_model.rst:163
msgid "scalar"
msgstr "скалярный"

#: ../doc/book/box/data_model.rst:153
msgid "\"`nil`_\""
msgstr "\"`nil`_\" (нулевое значение)"

#: ../doc/book/box/data_model.rst:153 ../doc/book/box/data_model.rst:317
msgid "msgpack.NULL"
msgstr "msgpack.NULL"

#: ../doc/book/box/data_model.rst:155
msgid "\"`boolean`_\""
msgstr "\"`boolean`_\" (логическое значение)"

#: ../doc/book/box/data_model.rst:155 ../doc/book/box/data_model.rst:309
#: ../doc/book/box/data_model.rst:319
msgid "true"
msgstr "true"

#: ../doc/book/box/data_model.rst:157
msgid "\"`string`_\""
msgstr "\"`string`_\" (строка)"

#: ../doc/book/box/data_model.rst:157
msgid "'A B C'"
msgstr "'A B C'"

#: ../doc/book/box/data_model.rst:159
msgid "integer"
msgstr "integer (целое число)"

#: ../doc/book/box/data_model.rst:159 ../doc/book/box/data_model.rst:161
msgid "\"`number`_\""
msgstr "\"`number`_\" (число)"

#: ../doc/book/box/data_model.rst:159
msgid "12345"
msgstr "12345"

#: ../doc/book/box/data_model.rst:161
msgid "double"
msgstr "double (числа с двойной точностью)"

#: ../doc/book/box/data_model.rst:161
msgid "1.2345"
msgstr "1,2345"

#: ../doc/book/box/data_model.rst:163
msgid "bin"
msgstr ""

#: ../doc/book/box/data_model.rst:163
#, fuzzy
msgid "\"`cdata`_\""
msgstr "tuple (\"`cdata`_\") (кортеж)"

#: ../doc/book/box/data_model.rst:163
msgid "[!!binary 3t7e]"
msgstr ""

#: ../doc/book/box/data_model.rst:165 ../doc/book/box/data_model.rst:167
#: ../doc/book/box/data_model.rst:169
msgid "compound"
msgstr "составной"

#: ../doc/book/box/data_model.rst:165
msgid "map"
msgstr "map (ассоциативный массив)"

#: ../doc/book/box/data_model.rst:165
msgid "\"`table`_\" (with string keys)"
msgstr "\"`table`_\" (таблица со строковыми ключами)"

#: ../doc/book/box/data_model.rst:165
msgid "{'a': 5, 'b': 6}"
msgstr "{'a': 5, 'b': 6}"

#: ../doc/book/box/data_model.rst:167 ../doc/book/box/data_model.rst:169
msgid "array"
msgstr "array (массив)"

#: ../doc/book/box/data_model.rst:167
msgid "\"`table`_\" (with integer keys)"
msgstr "\"`table`_\" (таблица с целочисленными ключами)"

#: ../doc/book/box/data_model.rst:167
msgid "[1, 2, 3, 4, 5]"
msgstr "[1, 2, 3, 4, 5]"

#: ../doc/book/box/data_model.rst:169
msgid "tuple (\"`cdata`_\")"
msgstr "tuple (\"`cdata`_\") (кортеж)"

#: ../doc/book/box/data_model.rst:169
msgid "[12345, 'A B C']"
msgstr "[12345, 'A B C']"

#: ../doc/book/box/data_model.rst:179
msgid ""
"In Lua, a **nil** type has only one possible value, also called *nil* "
"(displayed as **null** on Tarantool's command line, since the output is "
"in the YAML format). Nils may be compared to values of any types with == "
"(is-equal) or ~= (is-not-equal), but other operations will not work. Nils"
" may not be used in Lua tables; the workaround is to use "
":ref:`msgpack.NULL <msgpack-null>`"
msgstr ""
"В языке Lua тип *nil* (нулевой) может иметь только одно значение, также "
"называемое *nil* (отображаемое как **null** в командной строке "
"Tarantool'а, поскольку значения выводятся в формате YAML). Нулевое "
"значение можно сравнивать со значениями любых типов с помощью операторов "
"== (равен) или ~= (не равен), но никакие другие операции для нулевых "
"значений не доступны. Нулевые значения также нельзя использовать в "
"Lua-таблицах; вместо нулевого значения в таком случае можно указать "
":ref:`msgpack.NULL <msgpack-null>`"

#: ../doc/book/box/data_model.rst:187
msgid "A **boolean** is either ``true`` or ``false``."
msgstr ""
"Тип *boolean* (логический) может иметь только значения ``true`` или "
"``false``."

#: ../doc/book/box/data_model.rst:191
msgid ""
"A **string** is a variable-length sequence of bytes, usually represented "
"with alphanumeric characters inside single quotes. In both Lua and "
"MsgPack, strings are treated as binary data, with no attempts to "
"determine a string's character set or to perform any string conversion --"
" unless there is an optional :ref:`collation <index-collation>`. So, "
"usually, string sorting and comparison are done byte-by-byte, without any"
" special collation rules applied. (Example: numbers are ordered by their "
"point on the number line, so 2345 is greater than 500; meanwhile, strings"
" are ordered by the encoding of the first byte, then the encoding of the "
"second byte, and so on, so '2345' is less than '500'.)"
msgstr ""
"Тип **string**  (строка) представляет собой последовательность байтов "
"переменной длины, обычно представленную буквенно-цифровые символы в "
"одинарных кавычках. Как в Lua, так и в MsgPack строки рассматриваются как"
" бинарные данные без попыток определить набор символов строки или "
"выполнить преобразование строки -- кроме случаев, когда есть опциональное"
" :ref:`сравнение символов <index-collation>`. Таким образом, обычно "
"сортировка и сравнение строк выполняются побайтово, не применяя "
"дополнительных правил сравнения символов. (Пример: числа упорядочены по "
"их положению на числовой прямой, поэтому 2345 больше, чем 500; а строки "
"упорядочены по кодировке первого байта, затем кодировке второго байта и "
"так далее, таким образом, '2345' меньше, чем '500'.)"

#: ../doc/book/box/data_model.rst:204
msgid ""
"In Lua, a **number** is double-precision floating-point, but Tarantool "
"allows both integer and floating-point values. Tarantool will try to "
"store a Lua number as floating-point if the value contains a decimal "
"point or is very large (greater than 100 trillion = 1e14), otherwise "
"Tarantool will store it as an integer. To ensure that even very large "
"numbers are stored as integers, use the :ref:`tonumber64 <other-"
"tonumber64>` function, or the LL (Long Long) suffix, or the ULL (Unsigned"
" Long Long) suffix. Here are examples of numbers using regular notation, "
"exponential notation, the ULL suffix and the ``tonumber64`` function: "
"``-55``, ``-2.7e+20``, ``100000000000000ULL``, "
"``tonumber64('18446744073709551615')``."
msgstr ""
"В языке Lua тип **number** (число) -- это число с плавающей запятой "
"двойной точности, но в Tarantool'е можно использовать как целые числа, "
"так и числа с плавающей запятой. Tarantool по возможности сохраняет числа"
" языка Lua в виде чисел с плавающей запятой, если числовое значение "
"содержит десятичную запятую или если оно очень велико (более 100 "
"триллионов = 1e14). В противном случае, Tarantool сохраняет такое "
"значение в виде целого числа. Чтобы даже очень большие величины "
"гарантированно обрабатывались как целые числа, используйте функцию "
":ref:`tonumber64 <other-tonumber64>`, либо приписывайте в конце суффикс "
"LL (Long Long) или ULL (Unsigned Long Long). Вот примеры записи чисел в "
"обычном представлении, экспоненциальном, с суффиксом ULL и с "
"использованием функции ``tonumber64``:  ``-55``, ``-2.7e+20``, "
"``100000000000000ULL``, ``tonumber64('18446744073709551615')``."

#: ../doc/book/box/data_model.rst:215
msgid ""
"A **bin** (binary) value is not directly supported by Lua but there is a "
"Tarantool type ``VARBINARY`` which is encoded as MessagePack binary. For "
"an (advanced) example showing how to insert VARBINARY into a database, "
"see the Cookbook Recipe for :ref:`ffi_varbinary_insert <cookbook-"
"ffi_varbinary_insert>`."
msgstr ""

#: ../doc/book/box/data_model.rst:220
msgid ""
"Lua **tables** with string keys are stored as MsgPack maps; Lua tables "
"with integer keys starting with 1 -- as MsgPack arrays. Nils may not be "
"used in Lua tables; the workaround is to use :ref:`msgpack.NULL <msgpack-"
"null>`"
msgstr ""
"В Lua **tables** (таблицы) со строковыми ключами хранятся как "
"ассоциативные массивы в MsgPack; Lua-таблицы с целочисленными ключами, "
"начиная с 1, хранятся как массивы в MsgPack. Нулевые значения нельзя "
"использовать в Lua-таблицах; вместо нулевого значения в таком случае "
"можно указать :ref:`msgpack.NULL <msgpack-null>`"

#: ../doc/book/box/data_model.rst:225
msgid ""
"A **tuple** is a light reference to a MsgPack array stored in the "
"database. It is a special type (cdata) to avoid conversion to a Lua table"
" on retrieval. A few functions may return tables with multiple tuples. "
"For more tuple examples, see :ref:`box.tuple <box_tuple>`."
msgstr ""
"Тип **tuple** (кортеж) представляет собой легкую ссылку на массив "
"MsgPack, который хранится в базе данных. Это особый тип (cdata), чтобы "
"избежать конвертации в Lua-таблицу при выборке данных. Некоторые функции "
"могут возвращать таблицы с множеством кортежей. Примеры с кортежами см. в"
" :ref:`box.tuple <box_tuple>`."

#: ../doc/book/box/data_model.rst:232
msgid ""
"Tarantool uses the MsgPack format for database storage, which is "
"variable-length. So, for example, the smallest number requires only one "
"byte, but the largest number requires nine bytes."
msgstr ""
"Tarantool использует формат MsgPack для хранения в базе данных переменной"
" длины. Поэтому, например, для наименьшего числа требуется только один "
"байт, но для наибольшего числа требуется девять байтов."

#: ../doc/book/box/data_model.rst:236
msgid "Examples of insert requests with different data types:"
msgstr "Примеры запроса вставки с разными типами данных:"

#: ../doc/book/box/data_model.rst:238
msgid ""
"tarantool> box.space.K:insert{1,nil,true,'A B C',12345,1.2345}\n"
"---\n"
"- [1, null, true, 'A B C', 12345, 1.2345]\n"
"...\n"
"tarantool> box.space.K:insert{2,{['a']=5,['b']=6}}\n"
"---\n"
"- [2, {'a': 5, 'b': 6}]\n"
"...\n"
"tarantool> box.space.K:insert{3,{1,2,3,4,5}}\n"
"---\n"
"- [3, [1, 2, 3, 4, 5]]\n"
"..."
msgstr ""
"tarantool> box.space.K:insert{1,nil,true,'A B C',12345,1.2345}\n"
"---\n"
"- [1, null, true, 'A B C', 12345, 1.2345]\n"
"...\n"
"tarantool> box.space.K:insert{2,{['a']=5,['b']=6}}\n"
"---\n"
"- [2, {'a': 5, 'b': 6}]\n"
"...\n"
"tarantool> box.space.K:insert{3,{1,2,3,4,5}}\n"
"---\n"
"- [3, [1, 2, 3, 4, 5]]\n"
"..."

#: ../doc/book/box/data_model.rst:257
msgid "Indexed field types"
msgstr "Типы индексированных полей"

#: ../doc/book/box/data_model.rst:259
msgid ""
"Indexes restrict values which Tarantool's MsgPack may contain. This is "
"why, for example, 'unsigned' is a separate **indexed field type**, "
"compared to ‘integer’ data type in MsgPack: they both store ‘integer’ "
"values, but an 'unsigned' index contains only *non-negative* integer "
"values and an ‘integer’ index contains *all* integer values."
msgstr ""
"Индексы ограничивают значения, которые может содержать MsgPack в "
"Tarantool'е. Вот почему, например, тип 'unsigned' (без знака) "
"представляет собой отдельный **тип индексированного поля** в сравнении с "
"типом данных ‘integer’ (целое число) в MsgPack: оба содержат значения с "
"целыми числами, но индекс 'unsigned' содержит только *неотрицательные* "
"целые числовые значения, а индекс ‘integer’ содержит *все* целые числовые"
" значения."

#: ../doc/book/box/data_model.rst:265
msgid "Here's how Tarantool indexed field types correspond to MsgPack data types."
msgstr ""
"Вот как типы индексированных полей в Tarantool'е соответствуют типам "
"данных MsgPack."

#: ../doc/book/box/data_model.rst:278
msgid "Indexed field type"
msgstr "Тип индексированного поля"

#: ../doc/book/box/data_model.rst:278
msgid "MsgPack data type |br| (and possible values)"
msgstr "Тип данных MsgPack |br| (и возможные значения)"

#: ../doc/book/box/data_model.rst:281
msgid "**unsigned** (may also be called ‘uint’ or ‘num’, but ‘num’ is deprecated)"
msgstr ""
"**unsigned** (без знака -- может также называться ‘uint’ или ‘num’, но "
"‘num’ объявлен устаревшим)"

#: ../doc/book/box/data_model.rst:281
msgid ""
"**integer** (integer between 0 and 18446744073709551615, i.e. about 18 "
"quintillion)"
msgstr ""
"**integer** (целое число в диапазоне от 0 до 18 446 744 073 709 551 615, "
"т.е. около 18 квинтиллионов)"

#: ../doc/book/box/data_model.rst:281 ../doc/book/box/data_model.rst:301
msgid "TREE, BITSET or HASH"
msgstr "TREE, BITSET или HASH"

#: ../doc/book/box/data_model.rst:281
msgid "123456"
msgstr "123456"

#: ../doc/book/box/data_model.rst:286
msgid "**integer** (may also be called ‘int’)"
msgstr "**integer** (целое число -- может также называться ‘int’)"

#: ../doc/book/box/data_model.rst:286 ../doc/book/box/data_model.rst:291
#: ../doc/book/box/data_model.rst:322
msgid ""
"**integer** (integer between -9223372036854775808 and "
"18446744073709551615)"
msgstr ""
"``integer`` (целое число в диапазоне от -9 223 372 036 854 775 808 до 18 "
"446 744 073 709 551 615)"

#: ../doc/book/box/data_model.rst:286 ../doc/book/box/data_model.rst:291
#: ../doc/book/box/data_model.rst:305 ../doc/book/box/data_model.rst:309
#: ../doc/book/box/data_model.rst:317
msgid "TREE or HASH"
msgstr "TREE или HASH"

#: ../doc/book/box/data_model.rst:286
msgid "-2^63"
msgstr "-2^63"

#: ../doc/book/box/data_model.rst:296 ../doc/book/box/data_model.rst:327
msgid ""
"**double** (single-precision floating point number or double-precision "
"floating point number)"
msgstr ""
"**double** (число с плавающей запятой с одинарной точностью или с двойной"
" точностью)"

#: ../doc/book/box/data_model.rst:291 ../doc/book/box/data_model.rst:323
msgid "1.234"
msgstr "1,234"

#: ../doc/book/box/data_model.rst:293
msgid "-44"
msgstr "-44"

#: ../doc/book/box/data_model.rst:295
msgid "1.447e+44"
msgstr "1,447e+44"

#: ../doc/book/box/data_model.rst:301
msgid "**string** (may also be called ‘str’)"
msgstr "**string** (строка -- может также называться ‘str’)"

#: ../doc/book/box/data_model.rst:301
msgid "**string** (any set of octets, up to the maximum length)"
msgstr ""
"**string** (строка -- любая последовательность октетов до максимальной "
"длины)"

#: ../doc/book/box/data_model.rst:301
msgid "‘A B C’"
msgstr "‘A B C’"

#: ../doc/book/box/data_model.rst:303 ../doc/book/box/data_model.rst:305
#, fuzzy
msgid "‘\\\\65 \\\\66 \\\\67’"
msgstr "‘\\65 \\66 \\67’"

#: ../doc/book/box/data_model.rst:305
#, fuzzy
msgid "**bin** (any set of octets, up to the maximum length)"
msgstr ""
"**string** (строка -- любая последовательность октетов до максимальной "
"длины)"

#: ../doc/book/box/data_model.rst:309 ../doc/book/box/data_model.rst:319
msgid "**bool** (true or false)"
msgstr "**bool** (логический -- true или false)"

#: ../doc/book/box/data_model.rst:312
msgid "**array** (list of numbers representing points in a geometric figure)"
msgstr ""
"**array** (массив -- список чисел, который представляет собой точки в "
"геометрической фигуре)"

#: ../doc/book/box/data_model.rst:312
msgid "RTREE"
msgstr "RTREE"

#: ../doc/book/box/data_model.rst:312
msgid "{10, 11}"
msgstr "{10, 11}"

#: ../doc/book/box/data_model.rst:314
msgid "{3, 5, 9, 10}"
msgstr "{3, 5, 9, 10}"

#: ../doc/book/box/data_model.rst:317
#, fuzzy
msgid "**null**"
msgstr "null"

#: ../doc/book/box/data_model.rst:332
msgid "**string** (any set of octets)"
msgstr "**string** (строковое значение, т.е. любая последовательность октетов)"

#: ../doc/book/box/data_model.rst:334
#, fuzzy
msgid "**varbinary** (any set of octets)"
msgstr "**string** (строковое значение, т.е. любая последовательность октетов)"

#: ../doc/book/box/data_model.rst:336
#, fuzzy
msgid ""
"Note: When there is a mix of types, the key order is: null, then "
"booleans, then numbers, then strings, then varbinary."
msgstr ""
"Примечание: в сочетании различных типов порядок будет следующим: "
"логические значения, затем числовые, затем строковые."

#: ../doc/book/box/data_model.rst:321
msgid "-1"
msgstr "-1"

#: ../doc/book/box/data_model.rst:325
msgid "‘’"
msgstr "‘’"

#: ../doc/book/box/data_model.rst:327
msgid "‘ру’"
msgstr "‘ру’"

#: ../doc/book/box/data_model.rst:346
msgid "Collations"
msgstr "Сортировка"

#: ../doc/book/box/data_model.rst:348
msgid ""
"By default, when Tarantool compares strings, it uses what we call a "
"**\"binary\" collation**. The only consideration here is the numeric "
"value of each byte in the string. Therefore, if the string is encoded "
"with ASCII or UTF-8, then ``'A' < 'B' < 'a'``, because the encoding of "
"'A' (what used to be called the \"ASCII value\") is 65, the encoding of "
"'B' is 66, and the encoding of 'a' is 98. Binary collation is best if you"
" prefer fast deterministic simple maintenance and searching with "
"Tarantool indexes."
msgstr ""
"По умолчанию, когда Tarantool сравнивает строки, он использует то, что мы"
" называем **\"бинарной\" сортировкой**. Единственный фактор, который "
"учитывается, это числовое значение каждого байта в строке. Таким образом,"
" если строка кодируется по ASCII или UTF-8, то ``'A' < 'B' < 'a'``, "
"поскольку в кодировке 'A' (что раньше называлось \"значение ASCII\") "
"соответствует 65, 'B' -- 66, а 'a' -- 98. Бинарная сортировка подходит "
"лучше всего для быстрого детерминированного простого обслуживания и "
"поиска с помощью индексов Tarantool'а."

#: ../doc/book/box/data_model.rst:357
#, fuzzy
msgid ""
"But if you want the ordering that you see in phone books and "
"dictionaries, then you need Tarantool's optional collations, such as "
"``unicode`` and ``unicode_ci``, which allow for ``'a' < 'A' < 'B'`` and "
"``'a' = 'A' < 'B'`` respectively."
msgstr ""
"Однако если необходимо распределение, как в телефонных справочниках и "
"словарях, то вам нужна **опциональная сортировка** Tarantool'а -- "
"``unicode`` и ``unicode_ci`` -- которые обеспечивают ``'a' < 'A' < 'B'`` "
"и ``'a' = 'A' < 'B'``  соответственно."

#: ../doc/book/box/data_model.rst:362
#, fuzzy
msgid ""
"**The unicode and unicode_ci optional collations** use the ordering "
"according to the `Default Unicode Collation Element Table (DUCET) "
"<http://unicode.org/reports/tr10/#Default_Unicode_Collation_Element_Table>`_"
" and the rules described in `Unicode® Technical Standard #10 Unicode "
"Collation Algorithm (UTS #10 UCA) <http://unicode.org/reports/tr10>`_. "
"The only difference between the two collations is about `weights "
"<https://unicode.org/reports/tr10/#Weight_Level_Defn>`_:"
msgstr ""
"Опциональная сортировка использует распределение в соответствии с "
"`Таблицей сортировки символов Юникода по умолчанию (DUCET) "
"<http://unicode.org/reports/tr10/#Default_Unicode_Collation_Element_Table>`_"
" и правилами, указанными в `Техническом стандарте Юникода №10 -- Алгоритм"
" сортировки по Юникоду (Unicode® Technical Standard #10 Unicode Collation"
" Algorithm (UTS #10 UCA)) <http://unicode.org/reports/tr10>`_. "
"Единственное отличие между двумя сортировками -- `вес "
"<https://unicode.org/reports/tr10/#Weight_Level_Defn>`_:"

#: ../doc/book/box/data_model.rst:369
msgid ""
"``unicode`` collation observes L1 and L2 and L3 weights (strength = "
"'tertiary'),"
msgstr ""
"сортировка ``unicode`` принимает во внимание уровни веса L1, L2 и L3 "
"(уровень = 'tertiary', третичный),"

#: ../doc/book/box/data_model.rst:370
msgid ""
"``unicode_ci`` collation observes only L1 weights (strength = 'primary'),"
" so for example 'a' = 'A' = 'á' = 'Á'."
msgstr ""
"сортировка ``unicode_ci`` принимает во внимание только вес L1 (уровень = "
"'primary', первичный), поэтому, например, 'a' = 'A' = 'á' = 'Á'."

#: ../doc/book/box/data_model.rst:372
#, fuzzy
msgid "As an example, take some Russian words:"
msgstr "Для примера возьмем некоторые русские слова:"

#: ../doc/book/box/data_model.rst:374
msgid ""
"'ЕЛЕ'\n"
"'елейный'\n"
"'ёлка'\n"
"'еловый'\n"
"'елозить'\n"
"'Ёлочка'\n"
"'ёлочный'\n"
"'ЕЛь'\n"
"'ель'"
msgstr ""
"'ЕЛЕ'\n"
"'елейный'\n"
"'ёлка'\n"
"'еловый'\n"
"'елозить'\n"
"'Ёлочка'\n"
"'ёлочный'\n"
"'ЕЛь'\n"
"'ель'"

#: ../doc/book/box/data_model.rst:386
msgid "...and show the difference in ordering and selecting by index:"
msgstr "...и покажем разницу в упорядочении и выборке по индексу:"

#: ../doc/book/box/data_model.rst:388
msgid "with ``unicode`` collation:"
msgstr "с сортировкой по ``unicode``:"

#: ../doc/book/box/data_model.rst:390
#, fuzzy
msgid ""
"tarantool> box.space.T:create_index('I', {parts = {{field = 1, type = "
"'str', collation='unicode'}}})\n"
"...\n"
"tarantool> box.space.T.index.I:select()\n"
"---\n"
"- - ['ЕЛЕ']\n"
"  - ['елейный']\n"
"  - ['ёлка']\n"
"  - ['еловый']\n"
"  - ['елозить']\n"
"  - ['Ёлочка']\n"
"  - ['ёлочный']\n"
"  - ['ель']\n"
"  - ['ЕЛь']\n"
"...\n"
"tarantool> box.space.T.index.I:select{'ЁлКа'}\n"
"---\n"
"- []\n"
"..."
msgstr ""
"tarantool> box.space.T:create_index('I', {parts = {{1,'str', "
"collation='unicode'}}})\n"
"...\n"
"tarantool> box.space.T.index.I:select()\n"
"---\n"
"- - ['ЕЛЕ']\n"
"  - ['елейный']\n"
"  - ['ёлка']\n"
"  - ['еловый']\n"
"  - ['елозить']\n"
"  - ['Ёлочка']\n"
"  - ['ёлочный']\n"
"  - ['ель']\n"
"  - ['ЕЛь']\n"
"...\n"
"tarantool> box.space.T.index.I:select{'ЁлКа'}\n"
"---\n"
"- []\n"
"..."

#: ../doc/book/box/data_model.rst:411
msgid "with ``unicode_ci`` collation:"
msgstr "с сортировкой по ``unicode_ci``:"

#: ../doc/book/box/data_model.rst:413
#, fuzzy
msgid ""
"tarantool> box.space.T:create_index('I', {parts = {{field = 1, type "
"='str', collation='unicode_ci'}}})\n"
"...\n"
"tarantool> box.space.S.index.I:select()\n"
"---\n"
"- - ['ЕЛЕ']\n"
"  - ['елейный']\n"
"  - ['ёлка']\n"
"  - ['еловый']\n"
"  - ['елозить']\n"
"  - ['Ёлочка']\n"
"  - ['ёлочный']\n"
"  - ['ЕЛь']\n"
"...\n"
"tarantool> box.space.S.index.I:select{'ЁлКа'}\n"
"---\n"
"- - ['ёлка']\n"
"..."
msgstr ""
"tarantool> box.space.T:create_index('I', {parts = {{1,'str', "
"collation='unicode'}}})\n"
"...\n"
"tarantool> box.space.T.index.I:select()\n"
"---\n"
"- - ['ЕЛЕ']\n"
"  - ['елейный']\n"
"  - ['ёлка']\n"
"  - ['еловый']\n"
"  - ['елозить']\n"
"  - ['Ёлочка']\n"
"  - ['ёлочный']\n"
"  - ['ель']\n"
"  - ['ЕЛь']\n"
"...\n"
"tarantool> box.space.T.index.I:select{'ЁлКа'}\n"
"---\n"
"- []\n"
"..."

#: ../doc/book/box/data_model.rst:434
msgid ""
"In all, collation involves much more than these simple examples of upper "
"case / lower case and accented / unaccented equivalence in alphabets. We "
"also consider variations of the same character, non-alphabetic writing "
"systems, and special rules that apply for combinations of characters."
msgstr ""

#: ../doc/book/box/data_model.rst:439
msgid ""
"For English: use \"unicode\" and \"unicode_ci\". For Russian: use "
"\"unicode\" and \"unicode_ci\" (although a few Russians might prefer the "
"Kyrgyz collation which says Cyrillic letters 'Е' and 'Ё' are the same "
"with level-1 weights). For Dutch, German (dictionary), French, "
"Indonesian, Irish, Italian, Lingala, Malay, Portuguese, Southern Soho, "
"Xhosa, or Zulu: \"unicode\" and \"unicode_ci\" will do."
msgstr ""

#: ../doc/book/box/data_model.rst:447
msgid ""
"**The tailored optional collations**: For other languages, Tarantool "
"supplies tailored collations for every modern language that has more than"
" a million native speakers, and for specialized situations such as the "
"difference between dictionary order and telephone book order. To see a "
"complete list say ``box.space._collation:select()``. The tailored "
"collation names have the form unicode_[language code]_[strength] where "
"language code is a standard 2-character or 3-character language "
"abbreviation, and strength is s1 for \"primary strength\" (level-1 "
"weights), s2 for \"secondary\", s3 for \"tertiary\". Tarantool uses the "
"same language codes as the ones in the \"list of tailorable locales\" on "
"man pages of `Ubuntu "
"<http://manpages.ubuntu.com/manpages/bionic/man3/Unicode::Collate::Locale.3perl.html>`_"
" and `Fedora "
"<http://www.polarhome.com/service/man/?qf=Unicode%3A%3ACollate%3A%3ALocale&af=0&tf=2&of=Fedora>`_."
" Charts explaining the precise differences from DUCET order are in the "
"`Common Language Data Repository "
"<https://unicode.org/cldr/charts/30/collation>`_."
msgstr ""

#: ../doc/book/box/data_model.rst:473
msgid "A **sequence** is a generator of ordered integer values."
msgstr ""
"**Последовательность** -- это генератор упорядоченных значений целых "
"чисел."

#: ../doc/book/box/data_model.rst:475
msgid ""
"As with spaces and indexes, you should specify the sequence **name**, and"
" let Tarantool come up with a unique **numeric identifier** (\"sequence "
"id\")."
msgstr ""
"Как и для спейсов и индексов, для последовательностей следует указать "
"**имена**, а Tarantool определит уникальный **числовой идентификатор** "
"(\"ID последовательности\")."

#: ../doc/book/box/data_model.rst:478
msgid ""
"As well, you can specify several options when creating a new sequence. "
"The options determine what value will be generated whenever the sequence "
"is used."
msgstr ""
"Кроме того, можно указать несколько параметров при создании новой "
"последовательности. Параметры определяют, какое значение будет "
"генерироваться при использовании последовательности."

#: ../doc/book/box/data_model.rst:485
msgid "Options for ``box.schema.sequence.create()``"
msgstr "Параметры для ``box.schema.sequence.create()``"

#: ../doc/book/box/data_model.rst:498
msgid "Option name"
msgstr "Имя параметра"

#: ../doc/book/box/data_model.rst:498
msgid "Type and meaning"
msgstr "Тип и значение"

#: ../doc/book/box/data_model.rst:500
msgid "**start**"
msgstr "**start** (начало)"

#: ../doc/book/box/data_model.rst:500
msgid "Integer. The value to generate the first time a sequence is used"
msgstr ""
"Целое число. Значение генерируется, когда последовательность используется"
" впервые"

#: ../doc/book/box/data_model.rst:500
msgid "start=0"
msgstr "start=0"

#: ../doc/book/box/data_model.rst:504
msgid "**min**"
msgstr "**min** (мин)"

#: ../doc/book/box/data_model.rst:504
msgid "Integer. Values smaller than this cannot be generated"
msgstr "Целое число. Ниже указанного значения не могут генерироваться"

#: ../doc/book/box/data_model.rst:504
msgid "min=-1000"
msgstr "min=-1000"

#: ../doc/book/box/data_model.rst:507
msgid "**max**"
msgstr "**max** (макс)"

#: ../doc/book/box/data_model.rst:507
msgid "Integer. Values larger than this cannot be generated"
msgstr "Целое число. Выше указанного значения не могут генерироваться"

#: ../doc/book/box/data_model.rst:507
msgid "9223372036854775807"
msgstr "9 223 372 036 854 775 807"

#: ../doc/book/box/data_model.rst:507
msgid "max=0"
msgstr "max=0"

#: ../doc/book/box/data_model.rst:510
msgid "**cycle**"
msgstr "**cycle** (цикл)"

#: ../doc/book/box/data_model.rst:510
msgid "Boolean. Whether to start again when values cannot be generated"
msgstr ""
"Логическое значение. Если значения не могут быть сгенерированы, начинать "
"ли заново"

#: ../doc/book/box/data_model.rst:510
msgid "cycle=true"
msgstr "cycle=true"

#: ../doc/book/box/data_model.rst:513
msgid "**cache**"
msgstr "**cache** (кэш)"

#: ../doc/book/box/data_model.rst:513
msgid "Integer. The number of values to store in a cache"
msgstr "Целое число. Количество значений для хранения в кэше"

#: ../doc/book/box/data_model.rst:513
msgid "cache=0"
msgstr "cache=0"

#: ../doc/book/box/data_model.rst:516
msgid "**step**"
msgstr "**step** (шаг)"

#: ../doc/book/box/data_model.rst:516
msgid ""
"Integer. What to add to the previous generated value, when generating a "
"new value"
msgstr ""
"Целое число. Что добавить к предыдущему сгенерированному значению, когда "
"генерируется новое значение"

#: ../doc/book/box/data_model.rst:516
msgid "step=-1"
msgstr "step=-1"

#: ../doc/book/box/data_model.rst:520
msgid "**if_not_exists**"
msgstr "**if_not_exists** (если отсутствует)"

#: ../doc/book/box/data_model.rst:520
msgid ""
"Boolean. If this is true and a sequence with this name exists already, "
"ignore other options and use the existing values"
msgstr ""
"Логическое значение. Если выставлено в true (истина) и существует "
"последовательность с таким именем, то игнорировать другие опции и "
"использовать текущие значения"

#: ../doc/book/box/data_model.rst:520
msgid "if_not_exists=true"
msgstr "if_not_exists=true"

#: ../doc/book/box/data_model.rst:526
msgid ""
"Once a sequence exists, it can be altered, dropped, reset, forced to "
"generate the next value, or associated with an index."
msgstr ""
"Существующую последовательность можно изменять, опускать, сбрасывать, "
"заставить сгенерировать новое значение или ассоциировать с индексом."

#: ../doc/book/box/data_model.rst:529
msgid "For an initial example, we generate a sequence named 'S'."
msgstr ""
"Для первоначального примера сгенерируем последовательность под названием "
"'S'."

#: ../doc/book/box/data_model.rst:531
msgid ""
"tarantool> box.schema.sequence.create('S',{min=5, start=5})\n"
"---\n"
"- step: 1\n"
"  id: 5\n"
"  min: 5\n"
"  cache: 0\n"
"  uid: 1\n"
"  max: 9223372036854775807\n"
"  cycle: false\n"
"  name: S\n"
"  start: 5\n"
"..."
msgstr ""
"tarantool> box.schema.sequence.create('S',{min=5, start=5})\n"
"---\n"
"- step: 1\n"
"  id: 5\n"
"  min: 5\n"
"  cache: 0\n"
"  uid: 1\n"
"  max: 9223372036854775807\n"
"  cycle: false\n"
"  name: S\n"
"  start: 5\n"
"..."

#: ../doc/book/box/data_model.rst:546
msgid ""
"The result shows that the new sequence has all default values, except for"
" the two that were specified, ``min`` and ``start``."
msgstr ""
"В результате видим, что в новой последовательность есть все значения по "
"умолчанию, за исключением указанных ``min`` и ``start``."

#: ../doc/book/box/data_model.rst:549
msgid "Then we get the next value, with the ``next()`` function."
msgstr "Затем получаем следующее значение с помощью функции ``next()``."

#: ../doc/book/box/data_model.rst:551
msgid ""
"tarantool> box.sequence.S:next()\n"
"---\n"
"- 5\n"
"..."
msgstr ""
"tarantool> box.sequence.S:next()\n"
"---\n"
"- 5\n"
"..."

#: ../doc/book/box/data_model.rst:558
msgid ""
"The result is the same as the start value. If we called ``next()`` again,"
" we would get 6 (because the previous value plus the step value is 6), "
"and so on."
msgstr ""
"Результат точно такой же, как и начальное значение. Если мы снова вызовем"
" ``next()``, то получим 6 (потому что предыдущее значение плюс значение "
"шага составит 6) и так далее."

#: ../doc/book/box/data_model.rst:562
msgid ""
"Then we create a new table, and say that its primary key may be generated"
" from the sequence."
msgstr ""
"Затем создадим новую таблицу и скажем, что ее первичный ключ можно "
"получить из последовательности."

#: ../doc/book/box/data_model.rst:565
msgid ""
"tarantool> "
"s=box.schema.space.create('T');s:create_index('I',{sequence='S'})\n"
"---\n"
"..."
msgstr ""
"tarantool> "
"s=box.schema.space.create('T');s:create_index('I',{sequence='S'})\n"
"---\n"
"..."

#: ../doc/book/box/data_model.rst:571
msgid "Then we insert a tuple, without specifying a value for the primary key."
msgstr "Затем вставим кортеж, не указывая значение первичного ключа."

#: ../doc/book/box/data_model.rst:573
msgid ""
"tarantool> box.space.T:insert{nil,'other stuff'}\n"
"---\n"
"- [6, 'other stuff']\n"
"..."
msgstr ""
"tarantool> box.space.T:insert{nil,'other stuff'}\n"
"---\n"
"- [6, 'other stuff']\n"
"..."

#: ../doc/book/box/data_model.rst:580
msgid ""
"The result is a new tuple where the first field has a value of 6. This "
"arrangement, where the system automatically generates the values for a "
"primary key, is sometimes called \"auto-incrementing\" or \"identity\"."
msgstr ""
"В результате имеем новый кортеж со значением 6 в первом поле. Такой "
"способ организации данных, когда система автоматически генерирует "
"значения для первичного ключа, иногда называется \"автоинкрементным\" "
"(т.е. с автоматическим увеличением) или \"по идентификатору\"."

#: ../doc/book/box/data_model.rst:585
msgid ""
"For syntax and implementation details, see the reference for "
":ref:`box.schema.sequence <box_schema-sequence>`."
msgstr ""
"Для получения подробной информации о синтаксисе и методах реализации см. "
"справочник по :ref:`box.schema.sequence <box_schema-sequence>`."

#: ../doc/book/box/data_model.rst:592
msgid "Persistence"
msgstr "Персистентность"

#: ../doc/book/box/data_model.rst:594
msgid ""
"In Tarantool, updates to the database are recorded in the so-called "
":ref:`write ahead log (WAL) <internals-wal>` files. This ensures data "
"persistence. When a power outage occurs or the Tarantool instance is "
"killed incidentally, the in-memory database is lost. In this situation, "
"WAL files are used to restore the data. Namely, Tarantool reads the WAL "
"files and redoes the requests (this is called the \"recovery process\"). "
"You can change the timing of the WAL writer, or turn it off, by setting "
":ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>`."
msgstr ""
"В Tarantool'е обновления базы данных записываются в так называемые "
":ref:`файлы журнала упреждающей записи (WAL-файлы) <internals-wal>`. Это "
"обеспечивает персистентность данных. При отключении электроэнергии или "
"случайном завершении работы экземпляра Tarantool'а данные в оперативной "
"памяти теряются. В такой ситуации WAL-файлы используются для "
"восстановления данных так: Tarantool прочитывает WAL-файлы и повторно "
"выполняет запросы (это называется \"процессом восстановления\"). Можно "
"изменить временные настройки метода записи WAL-файлов или отключить его с"
" помощью :ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>`."

#: ../doc/book/box/data_model.rst:603
msgid ""
"Tarantool also maintains a set of :ref:`snapshot files <internals-"
"snapshot>`. These files contain an on-disk copy of the entire data set "
"for a given moment. Instead of reading every WAL file since the databases"
" were created, the recovery process can load the latest snapshot file and"
" then read only those WAL files that were produced after the snapshot "
"file was made. After checkpointing, old WAL files can be removed to free "
"up space."
msgstr ""
"Tarantool также сохраняет ряд файлов со статическими снимками данных "
"(:ref:`snapshots <internals-snapshot>`). Файл со снимком -- это дисковая "
"копия всех данных в базе на какой-то момент. Вместо того, чтобы "
"зачитывать все WAL-файлы, появившиеся с момента создания базы, Tarantool "
"в процессе восстановления может загрузить самый свежий снимок и затем "
"зачитать только те WAL-файлы, которые были сделаны с момента сохранения "
"снимка. После создания новых файлов, старые WAL-файлы могут быть удалены "
"в целях экономии места на диске."

#: ../doc/book/box/data_model.rst:610
msgid ""
"To force immediate creation of a snapshot file, you can use Tarantool's "
":ref:`box.snapshot() <box-snapshot>` request. To enable automatic "
"creation of snapshot files, you can use Tarantool's :ref:`checkpoint "
"daemon <book_cfg_checkpoint_daemon>`. The checkpoint daemon sets "
"intervals for forced checkpoints. It makes sure that the states of both "
"memtx and vinyl storage engines are synchronized and saved to disk, and "
"automatically removes old WAL files."
msgstr ""
"Чтобы принудительно создать файл со снимком, можно использовать запрос "
":ref:`box.snapshot() <box-snapshot>` в Tarantool'е. Чтобы включить "
"автоматическое создание файлов со снимком, можно использовать :ref:`демон"
" создания контрольных точек <book_cfg_checkpoint_daemon>` Tarantool'а. "
"Демон создания контрольных точек определяет интервалы для принудительного"
" создания контрольных точек. Он обеспечивает синхронизацию и сохранение "
"на диск образов движков базы данных (как memtx, так и vinyl), а также "
"автоматически удаляет старые WAL-файлы."

#: ../doc/book/box/data_model.rst:618
msgid "Snapshot files can be created even if there is no WAL file."
msgstr "Файлы со снимками можно создавать, даже если WAL-файлы отсутствуют."

#: ../doc/book/box/data_model.rst:622
msgid ""
"The memtx engine makes only regular checkpoints with the interval set in "
":ref:`checkpoint daemon <book_cfg_checkpoint_daemon>` configuration."
msgstr ""
"Движок memtx регулярно создает контрольные точки с интервалом, указанным "
"в настройках :ref:`демона создания контрольных точек "
"<book_cfg_checkpoint_daemon>`."

#: ../doc/book/box/data_model.rst:625
msgid "The vinyl engine runs checkpointing in the background at all times."
msgstr ""
"Движок vinyl постоянно сохраняет состояние в контрольной точке в фоновом "
"режиме."

#: ../doc/book/box/data_model.rst:627
msgid ""
"See the :ref:`Internals <internals-data_persistence>` section for more "
"details about the WAL writer and the recovery process."
msgstr ""
"Для получения более подробной информации о методе записи WAL-файлов и "
"процессе восстановления см. раздел :ref:`Внутренняя реализация "
"<internals-data_persistence>`."

#: ../doc/book/box/data_model.rst:634
msgid "Operations"
msgstr "Операции"

#: ../doc/book/box/data_model.rst:640
msgid "Data operations"
msgstr "Операции с данными"

#: ../doc/book/box/data_model.rst:642
msgid "The basic data operations supported in Tarantool are:"
msgstr "Tarantool поддерживает следующие основные операции с данными:"

#: ../doc/book/box/data_model.rst:644
msgid ""
"five data-manipulation operations (INSERT, UPDATE, UPSERT, DELETE, "
"REPLACE), and"
msgstr ""
"пять операций по изменению данных (INSERT, UPDATE, UPSERT, DELETE, "
"REPLACE) и"

#: ../doc/book/box/data_model.rst:645
msgid "one data-retrieval operation (SELECT)."
msgstr "одну операция по выборке данных (SELECT)."

#: ../doc/book/box/data_model.rst:647
msgid ""
"All of them are implemented as functions in :ref:`box.space <box_space>` "
"submodule."
msgstr ""
"Все они реализованы в виде функций во вложенном модуле  :ref:`box.space "
"<box_space>`."

#: ../doc/book/box/data_model.rst:651
msgid ":ref:`INSERT <box_space-insert>`: Add a new tuple to space 'tester'."
msgstr ":ref:`INSERT <box_space-insert>`: добавить новый кортеж к спейсу 'tester'."

#: ../doc/book/box/data_model.rst:653
msgid "The first field, field[1], will be 999 (MsgPack type is `integer`)."
msgstr "Первое поле, field[1], будет 999 (тип MsgPack -- `integer`, целое число)."

#: ../doc/book/box/data_model.rst:655
msgid "The second field, field[2], will be 'Taranto' (MsgPack type is `string`)."
msgstr "Второе поле, field[2], будет 'Taranto' (тип MsgPack -- `string`, строка)."

#: ../doc/book/box/data_model.rst:657
msgid "tarantool> box.space.tester:insert{999, 'Taranto'}"
msgstr "tarantool> box.space.tester:insert{999, 'Taranto'}"

#: ../doc/book/box/data_model.rst:661
msgid ""
":ref:`UPDATE <box_space-update>`: Update the tuple, changing field "
"field[2]."
msgstr ":ref:`UPDATE <box_space-update>`: обновить кортеж, изменяя поле field[2]."

#: ../doc/book/box/data_model.rst:663
msgid ""
"The clause \"{999}\", which has the value to look up in the index of the "
"tuple's primary-key field, is mandatory, because ``update()`` requests "
"must always have a clause that specifies a unique key, which in this case"
" is field[1]."
msgstr ""
"Оператор \"{999}\" со значением, которое используется для поиска поля, "
"соответствующего ключу в первичном индексе, является обязательным, "
"поскольку в запросе ``update()`` должен быть оператор, который указывает "
"уникальный ключ, в данном случае -- field[1]."

#: ../doc/book/box/data_model.rst:667
msgid ""
"The clause \"{{'=', 2, 'Tarantino'}}\" specifies that assignment will "
"happen to field[2] with the new value."
msgstr ""
"Оператор \"{{'=', 2, 'Tarantino'}}\" указывает, что назначение нового "
"значения относится к field[2]."

#: ../doc/book/box/data_model.rst:670
msgid "tarantool> box.space.tester:update({999}, {{'=', 2, 'Tarantino'}})"
msgstr "tarantool> box.space.tester:update({999}, {{'=', 2, 'Tarantino'}})"

#: ../doc/book/box/data_model.rst:674
msgid ""
":ref:`UPSERT <box_space-upsert>`: Upsert the tuple, changing field "
"field[2] again."
msgstr ""
":ref:`UPSERT <box_space-upsert>`: обновить или вставить кортеж, снова "
"изменяя поле field[2]."

#: ../doc/book/box/data_model.rst:677
msgid ""
"The syntax of ``upsert()`` is similar to the syntax of ``update()``. "
"However, the execution logic of these two requests is different. UPSERT "
"is either UPDATE or INSERT, depending on the database's state. Also, "
"UPSERT execution is postponed until after transaction commit, so, unlike "
"``update()``, ``upsert()`` doesn't return data back."
msgstr ""
"Синтаксис ``upsert()`` похож на синтаксис ``update()``. Однако логика "
"выполнения двух запросов отличается. UPSERT означает UPDATE или INSERT, в"
" зависимости от состояния базы данных. Кроме того, выполнение UPSERT "
"откладывается до коммита транзакции, поэтому в отличие от``update()``, "
"``upsert()`` не возвращает данные."

#: ../doc/book/box/data_model.rst:683
msgid ""
"tarantool> box.space.tester:upsert({999, 'Taranted'}, {{'=', 2, "
"'Tarantism'}})"
msgstr ""
"tarantool> box.space.tester:upsert({999, 'Taranted'}, {{'=', 2, "
"'Tarantism'}})"

#: ../doc/book/box/data_model.rst:687
msgid ":ref:`REPLACE <box_space-replace>`: Replace the tuple, adding a new field."
msgstr ":ref:`REPLACE <box_space-replace>`: заменить кортеж, добавляя новое поле."

#: ../doc/book/box/data_model.rst:689
msgid ""
"This is also possible with the ``update()`` request, but the ``update()``"
" request is usually more complicated."
msgstr ""
"Это действие также можно выполнить с помощью запроса ``update()``, но "
"обычно запрос ``update()`` более сложен."

#: ../doc/book/box/data_model.rst:692
msgid "tarantool> box.space.tester:replace{999, 'Tarantella', 'Tarantula'}"
msgstr "tarantool> box.space.tester:replace{999, 'Tarantella', 'Tarantula'}"

#: ../doc/book/box/data_model.rst:696
msgid ":ref:`SELECT <box_space-select>`: Retrieve the tuple."
msgstr ":ref:`SELECT <box_space-select>`: провести выборку кортежа."

#: ../doc/book/box/data_model.rst:698
msgid ""
"The clause \"{999}\" is still mandatory, although it does not have to "
"mention the primary key."
msgstr ""
"Оператор \"{999}\" все еще обязателен, хотя в нем не должен упоминаться "
"первичный ключ."

#: ../doc/book/box/data_model.rst:701
msgid "tarantool> box.space.tester:select{999}"
msgstr "tarantool> box.space.tester:select{999}"

#: ../doc/book/box/data_model.rst:705
msgid ":ref:`DELETE <box_space-delete>`: Delete the tuple."
msgstr ":ref:`DELETE <box_space-delete>`: удалить кортеж."

#: ../doc/book/box/data_model.rst:707
msgid "In this example, we identify the primary-key field."
msgstr ""
"В этом примере мы определяем поле, соответствующее ключу в первичном "
"индексе."

#: ../doc/book/box/data_model.rst:709
msgid "tarantool> box.space.tester:delete{999}"
msgstr "tarantool> box.space.tester:delete{999}"

#: ../doc/book/box/data_model.rst:713
msgid "Summarizing the examples:"
msgstr "Подводя итоги по примерам:"

#: ../doc/book/box/data_model.rst:715
msgid ""
"Functions ``insert`` and ``replace`` accept a tuple (where a primary key "
"comes as part of the tuple)."
msgstr ""
"Функции ``insert`` и ``replace`` принимают кортеж (где первичный ключ -- "
"это часть кортежа)."

#: ../doc/book/box/data_model.rst:717
msgid ""
"Function ``upsert`` accepts a tuple (where a primary key comes as part of"
" the tuple), and also the update operations to execute."
msgstr ""
"Функция ``upsert`` принимает кортеж (где первичный ключ -- это часть "
"кортежа), а также операции по обновлению."

#: ../doc/book/box/data_model.rst:720
msgid ""
"Function ``delete`` accepts a full key of any unique index (primary or "
"secondary)."
msgstr ""
"Функция ``delete`` принимает полный ключ любого уникального индекса "
"(первичный или вторичный)."

#: ../doc/book/box/data_model.rst:722
msgid ""
"Function ``update`` accepts a full key of any unique index (primary or "
"secondary), and also the operations to execute."
msgstr ""
"Функция  ``update`` принимает полный ключ любого уникального индекса "
"(первичный или вторичный), а также операции к выполнению."

#: ../doc/book/box/data_model.rst:725
msgid ""
"Function ``select`` accepts any key: primary/secondary, unique/non-"
"unique, full/partial."
msgstr ""
"Функция ``select`` принимает любой ключ: первичный/вторичный, "
"уникальный/неуникальный, полный/часть."

#: ../doc/book/box/data_model.rst:728
msgid ""
"See reference on ``box.space`` for more :ref:`details on using data "
"operations <box_space-operations-detailed-examples>`."
msgstr ""
"Для получения более :ref:`подробной информации по использованию операций "
"с данными <box_space-operations-detailed-examples>` см. справочник по "
"``box.space``."

#: ../doc/book/box/data_model.rst:733
msgid ""
"Besides Lua, you can use :ref:`Perl, PHP, Python or other programming "
"language connectors <index-box_connectors>`. The client server protocol "
"is open and documented. See this :ref:`annotated BNF <box_protocol-"
"iproto_protocol>`."
msgstr ""
"Помимо Lua можно использовать :ref:`коннекторы к Perl, PHP, Python или "
"другому языку программирования <index-box_connectors>`. Клиент-серверный "
"протокол открыт и задокументирован. См. :ref:`БНФ с комментариями "
"<box_protocol-iproto_protocol>`."

#: ../doc/book/box/data_model.rst:742
msgid "Index operations"
msgstr "Операции с индексами"

#: ../doc/book/box/data_model.rst:744
msgid ""
"Index operations are automatic: if a data-manipulation request changes a "
"tuple, then it also changes the index keys defined for the tuple."
msgstr ""
"Операции с индексами производятся автоматически. Если запрос по "
"манипулированию данными меняет данные в кортеже, то меняются и ключи в "
"индексе для данного кортежа."

#: ../doc/book/box/data_model.rst:747
msgid "The simple index-creation operation that we've illustrated before is:"
msgstr ""
"Простая операция по созданию индекса, которую мы рассматривали ранее, "
"выглядит следующим образом:"

#: ../doc/book/box/data_model.rst:786
msgid ":samp:`box.space.{space-name}:create_index('{index-name}')`"
msgstr ":samp:`box.space.{имя-спейса}:create_index('{имя-индекса}')`"

#: ../doc/book/box/data_model.rst:754
msgid ""
"This creates a unique TREE index on the first field of all tuples (often "
"called \"Field#1\"), which is assumed to be numeric."
msgstr ""
"По умолчанию, при этом создается TREE-индекс по первому полю для всех "
"кортежей (обычно его называют \"Field#1\"). Предполагается, что "
"индексируемое поле является числовым."

#: ../doc/book/box/data_model.rst:757
msgid "The simple SELECT request that we've illustrated before is:"
msgstr "Вот простой SELECT-запрос, который мы рассматривали ранее:"

#: ../doc/book/box/data_model.rst:796
msgid ":extsamp:`box.space.{*{space-name}*}:select({*{value}*})`"
msgstr ":extsamp:`box.space.{*{space-name}*}:select({*{value}*})`"

#: ../doc/book/box/data_model.rst:764
msgid ""
"This looks for a single tuple via the first index. Since the first index "
"is always unique, the maximum number of returned tuples will be: one."
msgstr ""
"Такой запрос ищет отдельный кортеж по первичному индексу. Поскольку "
"первичный индекс всегда уникален, то данный запрос вернет не более одного"
" кортежа."

#: ../doc/book/box/data_model.rst:767
msgid "The following SELECT variations exist:"
msgstr "Возможны следующие варианты SELECT:"

#: ../doc/book/box/data_model.rst:769
msgid "The search can use comparisons other than equality."
msgstr ""
"Помимо условия равенства, при поиске могут использоваться и другие "
"условия сравнения."

#: ../doc/book/box/data_model.rst:808
msgid ":extsamp:`box.space.{*{space-name}*}:select(value, {iterator = 'GT'})`"
msgstr ":extsamp:`box.space.{*{space-name}*}:select(value, {iterator = 'GT'})`"

#: ../doc/book/box/data_model.rst:776
msgid ""
"The :ref:`comparison operators <box_index-iterator-types>` are LT, LE, "
"EQ, REQ, GE, GT (for \"less than\", \"less than or equal\", \"equal\", "
"\"reversed equal\", \"greater than or equal\", \"greater than\" "
"respectively). Comparisons make sense if and only if the index type is "
"‘TREE'."
msgstr ""
"Можно использовать следующие :ref:`операторы сравнения <box_index-"
"iterator-types>`: LT (меньше), LE (меньше  или равно), EQ (равно, "
"результаты отсортированы в порядке возрастания по ключу), REQ (равно, "
"результаты отсортированы в порядке убывания по ключу), GE (больше или "
"равно), GT (больше). Сравнения имеют смысл только для индексов типа "
"'TREE'."

#: ../doc/book/box/data_model.rst:781
msgid ""
"This type of search may return more than one tuple; if so, the tuples "
"will be in descending order by key when the comparison operator is LT or "
"LE or REQ, otherwise in ascending order."
msgstr ""
"Этот вариант поиска может вернуть более одного кортежа. В таком случае "
"кортежи будут отсортированы в порядке убывания по ключу (если "
"использовался оператор LT, LE или REQ), либо в порядке возрастания (во "
"всех остальных случаях)."

#: ../doc/book/box/data_model.rst:785
msgid "The search can use a secondary index."
msgstr "Поиск может производиться по вторичному индексу."

#: ../doc/book/box/data_model.rst:824
msgid ":extsamp:`box.space.{*{space-name}*}.index.{*{index-name}*}:select(value)`"
msgstr ":extsamp:`box.space.{*{space-name}*}.index.{*{index-name}*}:select(value)`"

#: ../doc/book/box/data_model.rst:792
msgid ""
"For a primary-key search, it is optional to specify an index name. For a "
"secondary-key search, it is mandatory."
msgstr ""
"При поиске по первичному индексу имя индекса можно не указывать. При "
"поиске же по вторичному индексу имя индекса указывать необходимо."

#: ../doc/book/box/data_model.rst:795
msgid "The search may be for some or all key parts."
msgstr "Поиск может производиться как по всему ключу, так и по его частям."

#: ../doc/book/box/data_model.rst:834
msgid ""
"-- Suppose an index has two parts\n"
":samp:`tarantool> box.space.{space-name}.index.{index-name}.parts`\n"
"---\n"
"- - type: unsigned\n"
"    fieldno: 1\n"
"  - type: string\n"
"    fieldno: 2\n"
"...\n"
"-- Suppose the space has three tuples\n"
":samp:`box.space.{space-name}:select()`\n"
"---\n"
"- - [1, 'A']\n"
"  - [1, 'B']\n"
"  - [2, '']\n"
"..."
msgstr ""
"-- Предположим, индекс состоит из двух частей\n"
":samp:`tarantool> box.space.{space-name}.index.{index-name}.parts`\n"
"---\n"
"- - type: unsigned\n"
"    fieldno: 1\n"
"  - type: string\n"
"    fieldno: 2\n"
"...\n"
"-- Предположим, в спейсе 3 кортежа\n"
":samp:`box.space.{space-name}:select()`\n"
"---\n"
"- - [1, 'A']\n"
"  - [1, 'B']\n"
"  - [2, '']\n"
"..."

#: ../doc/book/box/data_model.rst:816
msgid "The search may be for all fields, using a table for the value:"
msgstr "Поиск может производиться по всем полям с использованием таблицы значений:"

#: ../doc/book/box/data_model.rst:855
msgid ":extsamp:`box.space.{*{space-name}*}:select({1, 'A'})`"
msgstr ":extsamp:`box.space.{*{имя-спейса}*}:select({1, 'A'})`"

#: ../doc/book/box/data_model.rst:823
msgid "or the search can be for one field, using a table or a scalar:"
msgstr ""
"либо же по одному полю (в этом случае используется таблица или скалярное "
"значение):"

#: ../doc/book/box/data_model.rst:862
msgid ":samp:`box.space.{space-name}:select(1)`"
msgstr ":samp:`box.space.{имя-спейса}:select(1)`"

#: ../doc/book/box/data_model.rst:830
msgid ""
"In the second case, the result will be two tuples: ``{1, 'A'}`` and ``{1,"
" 'B'}``."
msgstr ""
"Во втором случае Tarantool вернет два кортежа: ``{1, 'A'}`` и ``{1,  "
"'B'}``."

#: ../doc/book/box/data_model.rst:833
msgid ""
"You can specify even zero fields, causing all three tuples to be "
"returned. (Notice that partial key searches are available only in TREE "
"indexes.)"
msgstr ""
"При необходимости можно задать даже нулевые поля, в результате чего "
"Tarantool вернет все три кортежа (обратите внимание, что поиск по "
"компонентам ключа доступен только для TREE-индексов)."

#: ../doc/book/box/data_model.rst:836
msgid "**Examples**"
msgstr "**Примеры**"

#: ../doc/book/box/data_model.rst:838
msgid "BITSET example:"
msgstr "Пример работы с BITSET-индексом:"

#: ../doc/book/box/data_model.rst:840
#, fuzzy
msgid ""
"tarantool> box.schema.space.create('bitset_example')\n"
"tarantool> box.space.bitset_example:create_index('primary')\n"
"tarantool> "
"box.space.bitset_example:create_index('bitset',{unique=false,type='BITSET',"
" parts={field = 2, type = 'unsigned'}})\n"
"tarantool> box.space.bitset_example:insert{1,1}\n"
"tarantool> box.space.bitset_example:insert{2,4}\n"
"tarantool> box.space.bitset_example:insert{3,7}\n"
"tarantool> box.space.bitset_example:insert{4,3}\n"
"tarantool> box.space.bitset_example.index.bitset:select(2, "
"{iterator='BITS_ANY_SET'})"
msgstr ""
"tarantool> box.schema.space.create('bitset_example')\n"
"tarantool> box.space.bitset_example:create_index('primary')\n"
"tarantool> "
"box.space.bitset_example:create_index('bitset',{unique=false,type='BITSET',"
" parts={2,'unsigned'}})\n"
"tarantool> box.space.bitset_example:insert{1,1}\n"
"tarantool> box.space.bitset_example:insert{2,4}\n"
"tarantool> box.space.bitset_example:insert{3,7}\n"
"tarantool> box.space.bitset_example:insert{4,3}\n"
"tarantool> box.space.bitset_example.index.bitset:select(2, "
"{iterator='BITS_ANY_SET'})"

#: ../doc/book/box/data_model.rst:851 ../doc/book/box/data_model.rst:873
msgid "The result will be:"
msgstr "Мы получим следующий результат:"

#: ../doc/book/box/data_model.rst:853
msgid ""
"---\n"
"- - [3, 7]\n"
"  - [4, 3]\n"
"..."
msgstr ""
"---\n"
"- - [3, 7]\n"
"  - [4, 3]\n"
"..."

#: ../doc/book/box/data_model.rst:860
msgid "because (7 AND 2) is not equal to 0, and (3 AND 2) is not equal to 0."
msgstr "поскольку (7 AND 2) не равно 0 и (3 AND 2) не равно 0."

#: ../doc/book/box/data_model.rst:862
msgid "RTREE example:"
msgstr "Пример работы с RTREE-индексом:"

#: ../doc/book/box/data_model.rst:864
#, fuzzy
msgid ""
"tarantool> box.schema.space.create('rtree_example')\n"
"tarantool> box.space.rtree_example:create_index('primary')\n"
"tarantool> "
"box.space.rtree_example:create_index('rtree',{unique=false,type='RTREE', "
"parts={field = 2, type = 'ARRAY'}})\n"
"tarantool> box.space.rtree_example:insert{1, {3, 5, 9, 10}}\n"
"tarantool> box.space.rtree_example:insert{2, {10, 11}}\n"
"tarantool> box.space.rtree_example.index.rtree:select({4, 7, 5, 9}, "
"{iterator = 'GT'})"
msgstr ""
"tarantool> box.schema.space.create('rtree_example')\n"
"tarantool> box.space.rtree_example:create_index('primary')\n"
"tarantool> "
"box.space.rtree_example:create_index('rtree',{unique=false,type='RTREE', "
"parts={2,'ARRAY'}})\n"
"tarantool> box.space.rtree_example:insert{1, {3, 5, 9, 10}}\n"
"tarantool> box.space.rtree_example:insert{2, {10, 11}}\n"
"tarantool> box.space.rtree_example.index.rtree:select({4, 7, 5, 9}, "
"{iterator = 'GT'})"

#: ../doc/book/box/data_model.rst:875
msgid ""
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"..."
msgstr ""
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"..."

#: ../doc/book/box/data_model.rst:881
msgid ""
"because a rectangle whose corners are at coordinates ``4,7,5,9`` is "
"entirely within a rectangle whose corners are at coordinates "
"``3,5,9,10``."
msgstr ""
"поскольку прямоугольник с углами в координатах ``4,7,5,9`` лежит целиком "
"внутри прямоугольника с углами в координатах ``3,5,9,10``."

#: ../doc/book/box/data_model.rst:884
msgid ""
"Additionally, there exist :ref:`index iterator operations <box_index-"
"index_pairs>`. They can only be used with code in Lua and C/C++. Index "
"iterators are for traversing indexes one key at a time, taking advantage "
"of features that are specific to an index type, for example evaluating "
"Boolean expressions when traversing BITSET indexes, or going in "
"descending order when traversing TREE indexes."
msgstr ""
"Кроме того, есть :ref:`операции с итераторами с индексом <box_index-"
"index_pairs>`. Их можно использовать только с кодом на языках Lua и "
"C/C++. Итераторы с индексом предназначены для обхода индексов по одному "
"ключу за раз, поскольку используют особенности каждого типа индекса, "
"например оценка логических выражений при обходе BITSET-индексов или обход"
" TREE-индексов в порядке по убыванию."

#: ../doc/book/box/data_model.rst:890
msgid ""
"See also other index operations like :ref:`alter() <box_index-alter>` and"
" :ref:`drop() <box_index-drop>` in reference for :ref:`box.index "
"<box_index>` submodule."
msgstr ""
"См. также информацию о других операциях с итераторами с индексом, таких "
"как :ref:`alter() <box_index-alter>` и :ref:`drop() <box_index-drop>` во "
"вложенном модуле :ref:`box.index <box_index>`."

#: ../doc/book/box/data_model.rst:895
msgid "Complexity factors"
msgstr "Факторы сложности"

#: ../doc/book/box/data_model.rst:897
msgid ""
"In reference for :ref:`box.space <box_space>` and :ref:`box.index "
"<box_index>` submodules, there are notes about which complexity factors "
"might affect the resource usage of each function."
msgstr ""
"Что касается вложенных модулей :ref:`box.space <box_space>` и "
":ref:`box.index <box_index>`, есть информация о том, как факторы "
"сложности могут повлиять на использование каждой функции."

#: ../doc/book/box/data_model.rst:909
msgid "Complexity factor"
msgstr "Фактор сложности"

#: ../doc/book/box/data_model.rst:912
msgid "Index size"
msgstr "Размер индекса"

#: ../doc/book/box/data_model.rst:912
msgid ""
"The number of index keys is the same as the number of tuples in the data "
"set. For a TREE index, if there are more keys, then the lookup time will "
"be greater, although of course the effect is not linear. For a HASH "
"index, if there are more keys, then there is more RAM used, but the "
"number of low-level steps tends to remain constant."
msgstr ""
"Количество ключей в индексе равно количеству кортежей в наборе данных. В "
"случае с TREE-индексом: с ростом количества ключей увеличивается время "
"поиска, хотя зависимость здесь, конечно же, не линейная. В случае с "
"HASH-индексом: с ростом количества ключей увеличивается объем оперативной"
" памяти, но количество низкоуровневых шагов остается примерно тем же."

#: ../doc/book/box/data_model.rst:920
msgid ""
"Typically, a HASH index is faster than a TREE index if the number of "
"tuples in the space is greater than one."
msgstr ""
"Как правило, поиск по HASH-индексу работает быстрее, чем по TREE-индексу,"
"  если в спейсе более одного кортежа."

#: ../doc/book/box/data_model.rst:924
msgid "Number of indexes accessed"
msgstr "Количество обращений к индексам"

#: ../doc/book/box/data_model.rst:924
msgid ""
"Ordinarily, only one index is accessed to retrieve one tuple. But to "
"update the tuple, there must be N accesses if the space has N different "
"indexes."
msgstr ""
"Обычно для выборки значений одного кортежа используется только один "
"индекс. Но при обновлении значений в кортеже требуется N обращений, если "
"в спейсе N индексов."

#: ../doc/book/box/data_model.rst:928
msgid ""
"Note re storage engine: Vinyl optimizes away such accesses if secondary "
"index fields are unchanged by the update. So, this complexity factor "
"applies only to memtx, since it always makes a full-tuple copy on every "
"update."
msgstr ""
"Примечание по движку базы данных: Vinyl отклоняет такой доступ, если "
"обновление не затрагивает поля вторичного индекса. Таким образом, этот "
"фактор сложности влияет только на memtx, поскольку он всегда создает "
"копию всего кортежа при каждом обновлении."

#: ../doc/book/box/data_model.rst:934
msgid "Number of tuples accessed"
msgstr "Количество обращений к кортежам"

#: ../doc/book/box/data_model.rst:934
msgid ""
"A few requests, for example SELECT, can retrieve multiple tuples. This "
"factor is usually less important than the others."
msgstr ""
"Некоторые запросы, например SELECT, могут возвращать несколько кортежей. "
"Как правило, это наименее важный фактор из всех."

#: ../doc/book/box/data_model.rst:938
msgid "WAL settings"
msgstr "Настройки WAL"

#: ../doc/book/box/data_model.rst:938
msgid ""
"The important setting for the write-ahead log is :ref:`wal_mode "
"<cfg_binary_logging_snapshots-wal_mode>`. If the setting causes no "
"writing or delayed writing, this factor is unimportant. If the setting "
"causes every data-change request to wait for writing to finish on a slow "
"device, this factor is more important than all the others."
msgstr ""
"Важным параметром для записи в WAL является :ref:`wal_mode "
"<cfg_binary_logging_snapshots-wal_mode>`. Если запись в WAL отключена или"
" задана запись с задержкой, но этот фактор не так важен. Если же запись в"
"  WAL производится при каждом запросе на изменение данных, то при каждом "
"таком запросе приходится ждать, пока отработает обращение к более "
"медленному диску, и данный фактор становится важнее всех остальных."

#: ../doc/book/box/engines/index.rst:5
msgid "Storage engines"
msgstr "Движки базы данных"

#: ../doc/book/box/engines/index.rst:7
msgid ""
"A storage engine is a set of very-low-level routines which actually store"
" and retrieve tuple values. Tarantool offers a choice of two storage "
"engines:"
msgstr ""
"Движок базы данных представляет собой набор очень низкоуровневых "
"процессов, которые фактически хранят и получают значения в кортежах. "
"Tarantool предлагает два движка базы данных на выбор:"

#: ../doc/book/box/engines/index.rst:10
msgid ""
"memtx (the in-memory storage engine) is the default and was the first to "
"arrive."
msgstr ""
"memtx (in-memory движок базы данных) используется по умолчанию, который "
"был первым."

#: ../doc/book/box/engines/index.rst:13
msgid ""
"vinyl (the on-disk storage engine) is a working key-value engine and will"
" especially appeal to users who like to see data go directly to disk, so "
"that recovery time might be shorter and database size might be larger."
msgstr ""
"vinyl (движок для хранения данных на диске) -- это рабочий движок на "
"основе пар ключ-значение, который особенно понравится пользователям, "
"предпочитающим записывать данные напрямую на диск, чтобы сократить время "
"восстановления и увеличить размер базы данных."

#: ../doc/book/box/engines/index.rst:17
msgid ""
"On the other hand, vinyl lacks some functions and options that are "
"available with memtx. Where that is the case, the relevant description in"
" this manual contains a note beginning with the words \"Note re storage "
"engine\"."
msgstr ""
"С другой стороны, vinyl'у не хватает некоторых функций и параметров, "
"доступных в memtx'е. В соответствующих случаях дается дополнительное "
"описание в виде примечания, которое начинается со слов **Примечание про "
"движок базы данных**."

#: ../doc/book/box/engines/index.rst:21
msgid ""
"Further in this section we discuss the details of storing data using the "
"vinyl storage engine."
msgstr ""
"Далее в разделе рассмотрим подробнее метод хранения данных с помощью "
"движка базы данных vinyl."

#: ../doc/book/box/engines/index.rst:24
msgid ""
"To specify that the engine should be vinyl, add the clause ``engine = "
"'vinyl'`` when creating a space, for example:"
msgstr ""
"Чтобы указать, что следует использовать именно vinyl, необходимо при "
"создании спейса добавить оператор ``engine = 'vinyl'``, например:"

#: ../doc/book/box/engines/index.rst:27
msgid "space = box.schema.space.create('name', {engine='vinyl'})"
msgstr "space = box.schema.space.create('name', {engine='vinyl'})"

#: ../doc/book/box/engines/index.rst:35
msgid "Differences between memtx and vinyl storage engines"
msgstr "Различия между движками memtx и vinyl"

#: ../doc/book/box/engines/index.rst:37
msgid ""
"The primary difference between memtx and vinyl is that memtx is an \"in-"
"memory\" engine while vinyl is an \"on-disk\" engine. An in-memory "
"storage engine is generally faster (each query is usually run under 1 "
"ms), and the memtx engine is justifiably the default for Tarantool, but "
"on-disk engine such as vinyl is preferable when the database is larger "
"than the available memory and adding more memory is not a realistic "
"option."
msgstr ""
"Основным различием между движками memtx и vinyl является то, что memtx "
"представляет собой \"in-memory\" движок, тогда как vinyl -- это "
"\"дисковый\" движок. Как правило, in-memory движок быстрее (каждый запрос"
" обычно выполняется меньше, чем за 1 мс), и движок memtx по праву "
"используется в Tarantool'е по умолчанию, но если база данных больше "
"объема доступной памяти, а добавление дополнительной памяти не "
"представляется возможным, рекомендуется использовать дисковый движок как "
"vinyl."

#: ../doc/book/box/engines/index.rst:50
msgid "Option"
msgstr "Характеристика"

#: ../doc/book/box/engines/index.rst:50
msgid "memtx"
msgstr "memtx"

#: ../doc/book/box/engines/index.rst:50
msgid "vinyl"
msgstr "vinyl"

#: ../doc/book/box/engines/index.rst:52
msgid "Supported index type"
msgstr "Поддерживаемый тип индекса"

#: ../doc/book/box/engines/index.rst:52
msgid "TREE, HASH, :ref:`RTREE <box_index-rtree>` or BITSET"
msgstr "TREE, HASH, :ref:`RTREE <box_index-rtree>` или BITSET"

#: ../doc/book/box/engines/index.rst:52
msgid "TREE"
msgstr "TREE"

#: ../doc/book/box/engines/index.rst:54
msgid "Temporary spaces"
msgstr "Временные спейсы"

#: ../doc/book/box/engines/index.rst:54 ../doc/book/box/engines/index.rst:56
#: ../doc/book/box/engines/index.rst:58
msgid "Supported"
msgstr "Поддерживается"

#: ../doc/book/box/engines/index.rst:54 ../doc/book/box/engines/index.rst:56
msgid "Not supported"
msgstr "Не поддерживается"

#: ../doc/book/box/engines/index.rst:56
msgid ":ref:`random() <box_index-random>` function"
msgstr "функция :ref:`random() <box_index-random>`"

#: ../doc/book/box/engines/index.rst:58
msgid ":ref:`alter() <box_index-alter>` function"
msgstr "функция :ref:`alter() <box_index-alter>`"

#: ../doc/book/box/engines/index.rst:58
msgid ""
"Supported starting from the 1.10.2 release (the primary index cannot be "
"modified)"
msgstr "Поддерживается с версии 1.10.2 (первичный индекс изменять нельзя)"

#: ../doc/book/box/engines/index.rst:61
msgid ":ref:`len() <box_space-len>` function"
msgstr "функция :ref:`len() <box_space-len>`"

#: ../doc/book/box/engines/index.rst:61
msgid "Returns the number of tuples in the space"
msgstr "Возвращает количество кортежей в спейсе"

#: ../doc/book/box/engines/index.rst:61
msgid "Returns the maximum approximate number of tuples in the space"
msgstr "Возвращает максимальное примерное количество кортежей в спейсе"

#: ../doc/book/box/engines/index.rst:64
msgid ":ref:`count() <box_index-count>` function"
msgstr "функция :ref:`count() <box_index-count>`"

#: ../doc/book/box/engines/index.rst:64
msgid "Takes a constant amount of time"
msgstr "Занимает одинаковые периоды времени"

#: ../doc/book/box/engines/index.rst:64
msgid "Takes a variable amount of time depending on a state of a DB"
msgstr "Занимает различное количество времени в зависимости от состояния БД"

#: ../doc/book/box/engines/index.rst:67
msgid ":ref:`delete() <box_space-delete>` function"
msgstr "функция :ref:`delete() <box_space-delete>`"

#: ../doc/book/box/engines/index.rst:67
msgid "Returns the deleted tuple, if any"
msgstr "Возвращает удаленный кортеж, если есть таковой"

#: ../doc/book/box/engines/index.rst:67
msgid "Always returns nil"
msgstr "Всегда возвращает nil"

#: ../doc/book/box/engines/index.rst:69
msgid "yield"
msgstr "передача управления"

#: ../doc/book/box/engines/index.rst:69
msgid ""
"Does not yield on the select requests unless the transaction is commited "
"to WAL"
msgstr ""
"Не передает управление на запросах выборки, если не происходит коммит "
"транзакции в журнал упреждающей записи (WAL)"

#: ../doc/book/box/engines/index.rst:69
msgid "Yields on the select requests or on its equivalents: get() or pairs()"
msgstr "Передает управление на запросах выборки или аналогичных: get() или pairs()"

#: ../doc/book/box/engines/vinyl.rst:5
msgid "Storing data with vinyl"
msgstr "Хранение данных с помощью vinyl"

#: ../doc/book/box/engines/vinyl.rst:7
#, python-format
msgid ""
"Tarantool is a transactional and persistent DBMS that maintains 100% of "
"its data in RAM. The greatest advantages of in-memory databases are their"
" speed and ease of use: they demonstrate consistently high performance, "
"but you never need to tune them."
msgstr ""
"Tarantool -- это транзакционная, персистентная СУБД, которая хранит 100% "
"данных в оперативной памяти. Основными преимущества хранения данных "
"оперативной памяти являются скорость и простота использования: нет "
"необходимости в оптимизации, однако производительность остается стабильно"
" высокой."

#: ../doc/book/box/engines/vinyl.rst:12
msgid ""
"A few years ago we decided to extend the product by implementing a "
"classical storage engine similar to those used by regular DBMSes: it uses"
" RAM for caching, while the bulk of its data is stored on disk. We "
"decided to make it possible to set a storage engine independently for "
"each table in the database, which is the same way that MySQL approaches "
"it, but we also wanted to support transactions from the very beginning."
msgstr ""
"Несколько лет назад мы решили расширить продукт посредством реализации "
"классической технологии хранения как в обычных СУБД: в оперативной памяти"
" хранится лишь кэш данных, а основной объем данных находится на диске. Мы"
" решили, что движок хранения можно будет выбирать независимо для каждой "
"таблицы, как это реализовано в MySQL, но при этом с самого начала будет "
"реализована поддержка транзакций."

#: ../doc/book/box/engines/vinyl.rst:19
msgid ""
"The first question we needed to answer was whether to create our own "
"storage engine or use an existing library. The open-source community "
"offered a few viable solutions. The RocksDB library was the fastest "
"growing open-source library and is currently one of the most prominent "
"out there. There were also several lesser-known libraries to consider, "
"such as WiredTiger, ForestDB, NestDB, and LMDB."
msgstr ""
"Первый вопрос, на который нужен был ответ: создавать свой движок или "
"использовать уже существующую библиотеку? Сообщество разработчиков "
"открытого ПО предлагает готовые библиотеки на выбор. Активнее всего "
"развивалась библиотека RocksDB, которая к настоящему времени стала одной "
"из самых популярных. Есть также несколько менее известных библиотек: "
"WiredTiger, ForestDB, NestDB, LMDB."

#: ../doc/book/box/engines/vinyl.rst:26
#, python-format
msgid ""
"Nevertheless, after studying the source code of existing libraries and "
"considering the pros and cons, we opted for our own storage engine. One "
"reason is that the existing third-party libraries expected requests to "
"come from multiple operating system threads and thus contained complex "
"synchronization primitives for controlling parallel data access. If we "
"had decided to embed one of these in Tarantool, we would have made our "
"users bear the overhead of a multithreaded application without getting "
"anything in return. The thing is, Tarantool has an actor-based "
"architecture. The way it processes transactions in a dedicated thread "
"allows it to do away with the unnecessary locks, interprocess "
"communication, and other overhead that accounts for up to 80% of "
"processor time in multithreaded DBMSes."
msgstr ""
"Тем не менее, изучив исходный код существующих библиотек и взвесив все "
"\"за\" и \"против\", мы решили написать свой движок. Одна из причин -- "
"все существующие сторонние библиотеки предполагают, что запросы к данным "
"могут поступать из множества потоков операционной системы, и поэтому "
"содержат сложные примитивы синхронизации для управления одновременным "
"доступом к данным. Если бы мы решили встраивать одну из них в Tarantool, "
"то пользователи были бы вынуждены нести издержки многопоточных "
"приложений, не получая ничего взамен. Дело в том, что в основе "
"Tarantool'а лежит архитектура на основе акторов. Обработка транзакций в "
"выделенном потоке позволяет обойтись без лишних блокировок, "
"межпроцессного взаимодействия и других затрат ресурсов, которые забирают "
"до 80% процессорного времени в многопоточных СУБД."

#: ../doc/book/box/engines/vinyl.rst:41
msgid "*The Tarantool process consists of a fixed number of \"actor\" threads*"
msgstr "*Процесс Tarantool'а состоит из заданного количества потоков*"

#: ../doc/book/box/engines/vinyl.rst:43
msgid ""
"If you design a database engine with cooperative multitasking in mind "
"right from the start, it not only significantly speeds up the development"
" process, but also allows the implementation of certain optimization "
"tricks that would be too complex for multithreaded engines. In short, "
"using a third-party solution wouldn’t have yielded the best result."
msgstr ""
"Если изначально проектировать движок с учетом кооперативной "
"многозадачности, можно не только существенно ускорить работу, но и "
"реализовать приемы оптимизации, слишком сложные для многопоточных "
"движков. В общем, использование стороннего решения не привело бы к "
"лучшему результату."

#: ../doc/book/box/engines/vinyl.rst:53
msgid "Algorithm"
msgstr "Алгоритм"

#: ../doc/book/box/engines/vinyl.rst:55
msgid ""
"Once the idea of using an existing library was off the table, we needed "
"to pick an architecture to build upon. There are two competing approaches"
" to on-disk data storage: the older one relies on B-trees and their "
"variations; the newer one advocates the use of log-structured merge-"
"trees, or \"LSM\" trees. MySQL, PostgreSQL, and Oracle use B-trees, while"
" Cassandra, MongoDB, and CockroachDB have adopted LSM trees."
msgstr ""
"Отказавшись от идеи внедрения существующих библиотек, необходимо было "
"выбрать архитектуру для использования в качестве основы. Есть два "
"альтернативных подхода к хранению данных на диске: старая модель с "
"использованием B-деревьев и их разновидностей и новая -- на основе "
"журнально-структурированных деревьев со слиянием, или LSM-деревьев (Log "
"Structured Merge Tree). MySQL, PostgreSQL и Oracle используют B-деревья, "
"а Cassandra, MongoDB и CockroachDB уже используют LSM-деревья."

#: ../doc/book/box/engines/vinyl.rst:62
msgid ""
"B-trees are considered better suited for reads and LSM trees—for writes. "
"However, with SSDs becoming more widespread and the fact that SSDs have "
"read throughput that’s several times greater than write throughput, the "
"advantages of LSM trees in most scenarios was more obvious to us."
msgstr ""
"Считается, что B-деревья более эффективны для чтения, а LSM-деревья -- "
"для записи. Тем не менее, с распространением SSD-дисков, у которых в "
"несколько раз выше производительность чтения по сравнению с "
"производительностью записи, преимущества LSM-деревьев стали очевидны в "
"большинстве сценариев."

#: ../doc/book/box/engines/vinyl.rst:67
msgid ""
"Before dissecting LSM trees in Tarantool, let’s take a look at how they "
"work. To do that, we’ll begin by analyzing a regular B-tree and the "
"issues it faces. A B-tree is a balanced tree made up of blocks, which "
"contain sorted lists of key- value pairs. (Topics such as filling and "
"balancing a B-tree or splitting and merging blocks are outside of the "
"scope of this article and can easily be found on Wikipedia). As a result,"
" we get a container sorted by key, where the smallest element is stored "
"in the leftmost node and the largest one in the rightmost node. Let’s "
"have a look at how insertions and searches in a B-tree happen."
msgstr ""
"Прежде чем разбираться с LSM-деревьями в Tarantool'е, посмотрим, как они "
"работают. Для этого разберем устройство обычного B-дерева и связанные с "
"ним проблемы. \"B\" в слове B-tree означает \"Block\", то есть это "
"сбалансированное дерево, состоящее из блоков, которые содержат "
"отсортированные списки пар ключ-значение. Вопросы наполнения дерева, "
"балансировки, разбиения и слияния блоков выходят за рамки данной статьи, "
"подробности вы сможете прочитать в Википедии. В итоге мы получаем "
"отсортированный по возрастанию ключа контейнер, минимальный элемент "
"которого хранится в крайнем левом узле, а максимальный -- в крайнем "
"правом. Посмотрим, как в B-дереве осуществляется поиск и вставка данных."

#: ../doc/book/box/engines/vinyl.rst:78
msgid "*Classical B-tree*"
msgstr "*Классическое B-дерево*"

#: ../doc/book/box/engines/vinyl.rst:80
msgid ""
"If you need to find an element or check its membership, the search starts"
" at the root, as usual. If the key is found in the root block, the search"
" stops; otherwise, the search visits the rightmost block holding the "
"largest element that’s not larger than the key being searched (recall "
"that elements at each level are sorted). If the first level yields no "
"results, the search proceeds to the next level. Finally, the search ends "
"up in one of the leaves and probably locates the needed key. Blocks are "
"stored and read into RAM one by one, meaning the algorithm reads "
":math:`logB(N)` blocks in a single search, where N is the number of "
"elements in the B-tree. In the simplest case, writes are done similarly: "
"the algorithm finds the block that holds the necessary element and "
"updates (inserts) its value."
msgstr ""
"Если необходимо найти элемент или проверить его наличие, поиск "
"начинается, как обычно, с вершины. Если ключ обнаружен в корневом блоке, "
"поиск заканчивается; в противном случае, переходим в блок с наибольшим "
"меньшим ключом, то есть в самый правый блок, в котором еще есть элементы "
"меньше искомого (элементы на всех уровнях расположены по возрастанию). "
"Если и там элемент не найден, снова переходим на уровень ниже. В конце "
"концов окажемся в одном из листьев и, возможно, обнаружим искомый "
"элемент. Блоки дерева хранятся на диске и читаются в оперативную память "
"по одному, то есть в рамках одного поиска алгоритм считывает "
":math:`logB(N)` блоков, где N -- это количество элементов в B-дереве. "
"Запись в самом простом случае осуществляется аналогично: алгоритм находит"
" блок, который содержит необходимый элемент, и обновляет (вставляет) его "
"значение."

#: ../doc/book/box/engines/vinyl.rst:92
msgid ""
"To better understand the data structure, let’s consider a practical "
"example: say we have a B-tree with 100,000,000 nodes, a block size of "
"4096 bytes, and an element size of 100 bytes. Thus each block will hold "
"up to 40 elements (all overhead considered), and the B-tree will consist "
"of around 2,570,000 blocks and 5 levels: the first four will have a size "
"of 256 Mb, while the last one will grow up to 10 Gb. Obviously, any "
"modern computer will be able to store all of the levels except the last "
"one in filesystem cache, so read requests will require just a single I/O "
"operation."
msgstr ""
"Чтобы наглядно представить себе эту структуру данных, возьмем B-дерево на"
" 100 000 000 узлов и предположим, что размер блока равен 4096 байтов, а "
"размер элемента -- 100 байтов. Таким образом, в каждом блоке можно будет "
"разместить до 40 элементов с учетом накладных расходов, а в B-дереве "
"будет около 2 570 000 блоков, пять уровней, при этом первые четыре займут"
" по 256 МБ, а последний -- до 10 ГБ. Очевидно, что на любом современном "
"компьютере все уровни, кроме последнего, успешно попадут в кэш файловой "
"системы, и фактически любая операция чтения будет требовать не более "
"одной операции ввода-вывода."

#: ../doc/book/box/engines/vinyl.rst:101
msgid ""
"But if we change our perspective —B-trees don’t look so good anymore. "
"Suppose we need to update a single element. Since working with B-trees "
"involves reading and writing whole blocks, we would have to read in one "
"whole block, change our 100 bytes out of 4096, and then write the whole "
"updated block to disk. In other words,we were forced to write 40 times "
"more data than we actually modified!"
msgstr ""
"Ситуация выглядит существенно менее радужно при смене точки зрения. "
"Предположим, что необходимо обновить один элемент дерева. Так как "
"операции с B-деревьями работают через чтение и запись целых блоков, "
"приходится прочитать 1 блок в память, изменить 100 байт из 4096, а затем "
"записать обновленный блок на диск. Таким образом, нам пришлось записать в"
" 40 раз больше, чем реальный объем измененных данных!"

#: ../doc/book/box/engines/vinyl.rst:108
msgid ""
"If you take into account the fact that an SSD block has a size of 64 Kb+ "
"and not every modification changes a whole element, the extra disk "
"workload can be greater still."
msgstr ""
"Принимая во внимание, что внутренний размер блока в SSD-дисках может быть"
" 64 КБ и больше, и не любое изменение элемента меняет его целиком, объем "
"\"паразитной\" нагрузки на диск может быть еще выше."

#: ../doc/book/box/engines/vinyl.rst:113
msgid ""
"Authors of specialized literature and blogs dedicated to on-disk data "
"storage have coined two terms for these phenomena: extra reads are "
"referred to as \"read amplification\" and writes as \"write "
"amplification\"."
msgstr ""
"Феномен таких \"паразитных\" чтений в литературе и блогах, посвященных "
"хранению на диске, называется read amplification (усложнение чтения), а "
"феномен \"паразитной\" записи -- write amplification (усложнение записи)."

#: ../doc/book/box/engines/vinyl.rst:117
msgid ""
"The amplification factor (multiplication coefficient) is calculated as "
"the ratio of the size of actual read (or written) data to the size of "
"data needed (or actually changed). In our B-tree example, the "
"amplification factor would be around 40 for both reads and writes."
msgstr ""
"Коэффициент усложнения, то есть коэффициент умножения, вычисляется как "
"отношение размера фактически прочитанных (или записанных) данных к "
"реально необходимому (или измененному) размеру. В нашем примере с "
"B-деревом коэффициент составит около 40 как для чтения, так и для записи."

#: ../doc/book/box/engines/vinyl.rst:123
msgid ""
"The huge number of extra I/O operations associated with updating data is "
"one of the main issues addressed by LSM trees. Let’s see how they work."
msgstr ""
"Объем \"паразитных\" операций ввода-вывода при обновлении данных является"
" одной из основных проблем, которую решают LSM-деревья. Рассмотрим, как "
"это работает."

#: ../doc/book/box/engines/vinyl.rst:127
msgid ""
"The key difference between LSM trees and regular B-trees is that LSM "
"trees don’t just store data (keys and values), but also data operations: "
"insertions and deletions."
msgstr ""
"Ключевое отличие LSM-деревьев от классических B-деревьев заключается в "
"том, что LSM-деревья не просто хранят данные (ключи и значения), а также "
"операции с данными: вставки и удаления."

#: ../doc/book/box/engines/vinyl.rst:133 ../doc/book/box/engines/vinyl.rst:189
#: ../doc/book/box/engines/vinyl.rst:204 ../doc/book/box/engines/vinyl.rst:226
#: ../doc/book/box/engines/vinyl.rst:278 ../doc/book/box/engines/vinyl.rst:303
#: ../doc/book/box/engines/vinyl.rst:640 ../doc/book/box/engines/vinyl.rst:792
msgid "|br|"
msgstr "|br|"

#: ../doc/book/box/engines/vinyl.rst:135
msgid "LSM tree:"
msgstr "LSM-дерево:"

#: ../doc/book/box/engines/vinyl.rst:140
msgid "Stores statements, not values:"
msgstr "Хранит операторы, а не значения:"

#: ../doc/book/box/engines/vinyl.rst:142
msgid ""
"Every statement is marked by LSN Append-only files, garbage is collected "
"after a checkpoint"
msgstr ""
"Для каждого оператора назначается LSN Обновление файлов происходит только"
" путем присоединения новых записей, сборка мусора проводится после "
"контрольной точки"

#: ../doc/book/box/engines/vinyl.rst:144
msgid "Transactional log of all filesystem changes: vylog"
msgstr "Журнал транзакций при любых изменениях в системе: vylog"

#: ../doc/book/box/engines/vinyl.rst:146
msgid ""
"For example, an element corresponding to an insertion operation has, "
"apart from a key and a value, an extra byte with an operation code "
"(\"REPLACE\" in the image above). An element representing the deletion "
"operation contains a key (since storing a value is unnecessary) and the "
"corresponding operation code—\"DELETE\". Also, each LSM tree element has "
"a log sequence number (LSN), which is the value of a monotonically "
"increasing sequence that uniquely identifies each operation. The whole "
"tree is first ordered by key in ascending order, and then, within a "
"single key scope, by LSN in descending order."
msgstr ""
"Например, элемент для операции вставки, помимо ключа и значения, содержит"
" дополнительный байт с кодом операции -- обозначенный выше как REPLACE. "
"Элемент для операции удаления содержит ключ элемента (хранить значение "
"нет необходимости) и соответствующий код операции -- DELETE. Также каждый"
" элемент LSM-дерева содержит порядковый номер операции (log sequence "
"number -- LSN), то есть значение монотонно возрастающей "
"последовательности, которое уникально идентифицирует каждую операцию. "
"Таким образом, всё дерево упорядочено сначала по возрастанию ключа, а в "
"пределах одного ключа -- по убыванию LSN."

#: ../doc/book/box/engines/vinyl.rst:157
msgid "*A single level of an LSM tree*"
msgstr "*Один уровень LSM-дерева*"

#: ../doc/book/box/engines/vinyl.rst:163
msgid "Filling an LSM tree"
msgstr "Наполнение LSM-дерева"

#: ../doc/book/box/engines/vinyl.rst:165
msgid ""
"Unlike a B-tree, which is stored completely on disk and can be partly "
"cached in RAM, when using an LSM tree, memory is explicitly separated "
"from disk right from the start. The issue of volatile memory and data "
"persistence is beyond the scope of the storage algorithm and can be "
"solved in various ways—for example, by logging changes."
msgstr ""
"В отличие от B-дерева, которое полностью хранится на диске и может "
"частично кэшироваться в оперативной памяти, в LSM-дереве разделение между"
" памятью и диском явно присутствует с самого начала. При этом проблема "
"сохранности данных, расположенных в энергозависимой памяти, выносится за "
"рамки алгоритма хранения: ее можно решить разными способами, например, "
"журналированием изменений."

#: ../doc/book/box/engines/vinyl.rst:171
msgid ""
"The part of an LSM tree that’s stored in RAM is called L0 (level zero). "
"The size of RAM is limited, so L0 is allocated a fixed amount of memory. "
"For example, in Tarantool, the L0 size is controlled by the "
"``vinyl_memory`` parameter. Initially, when an LSM tree is empty, "
"operations are written to L0. Recall that all elements are ordered by key"
" in ascending order, and then within a single key scope, by LSN in "
"descending order, so when a new value associated with a given key gets "
"inserted, it’s easy to locate the older value and delete it. L0 can be "
"structured as any container capable of storing a sorted sequence of "
"elements. For example, in Tarantool, L0 is implemented as a B+*-tree. "
"Lookups and insertions are standard operations for the data structure "
"underlying L0, so I won’t dwell on those."
msgstr ""
"Часть дерева, расположенную в оперативной памяти, называют L0 (level zero"
" -- уровень ноль). Объем оперативной памяти ограничен, поэтому для L0 "
"отводится фиксированная область. В конфигурации Tarantool'а, например, "
"размер L0 задается с помощью параметра ``vinyl_memory``. В начале, когда "
"LSM-дерево не содержит элементов, операции записываются в L0. Следует "
"отметить, что элементы в дереве упорядочены по возрастанию ключа, а затем"
" по убыванию LSN, так что в случае вставки нового значения по данному "
"ключу легко обнаружить и удалить предыдущее значение. L0 может быть "
"представлен любым контейнером, который сохраняет упорядоченность "
"элементов. Например, для хранения L0 Tarantool использует B+*-дерево. "
"Операции поиска и вставки -- это стандартные операции структуры данных, "
"используемой для представления L0, и мы их подробно рассматривать не "
"будем."

#: ../doc/book/box/engines/vinyl.rst:183
msgid ""
"Sooner or later the number of elements in an LSM tree exceeds the L0 size"
" and that’s when L0 gets written to a file on disk (called a \"run\") and"
" then cleared for storing new elements. This operation is called a "
"\"dump\"."
msgstr ""
"Рано или поздно количество элементов в дереве превысит размер L0. Тогда "
"L0 записывается в файл на диске (который называется забегом -- \"run\") и"
" освобождается под новые элементы. Эта операция называется \"дамп\" "
"(dump)."

#: ../doc/book/box/engines/vinyl.rst:191
msgid ""
"Dumps on disk form a sequence ordered by LSN: LSN ranges in different "
"runs don’t overlap, and the leftmost runs (at the head of the sequence) "
"hold newer operations. Think of these runs as a pyramid, with the newest "
"ones closer to the top. As runs keep getting dumped, the pyramid grows "
"higher. Note that newer runs may contain deletions or replacements for "
"existing keys. To remove older data, it’s necessary to perform garbage "
"collection (this process is sometimes called \"merge\" or \"compaction\")"
" by combining several older runs into a new one. If two versions of the "
"same key are encountered during a compaction, only the newer one is "
"retained; however, if a key insertion is followed by a deletion, then "
"both operations can be discarded."
msgstr ""
"Все дампы на диске образуют последовательность, упорядоченную по LSN: "
"диапазоны LSN в файлах не пересекаются, а ближе к началу "
"последовательности находятся файлы с более новыми операциями. Представим "
"эти файлы в виде пирамиды, где новые файлы расположены вверху, а старые "
"внизу. По мере появления новых файлов забегов, высота пирамиды растет. "
"При этом более свежие файлы могут содержать операции удаления или замены "
"для существующих ключей. Для удаления старых данных необходимо "
"производиться сборку мусора (этот процесс иногда называется \"слияние\" "
"-- в английском языке \"merge\" или \"compaction\"), объединяя нескольких"
" старых файлов в новый. Если при слиянии мы встречаем две версии одного и"
" того же ключа, то достаточно оставить только более новую версию, а если "
"после вставки ключа он был удален, то из результата можно исключить обе "
"операции."

#: ../doc/book/box/engines/vinyl.rst:206
msgid ""
"The key choices determining an LSM tree’s efficiency are which runs to "
"compact and when to compact them. Suppose an LSM tree stores a "
"monotonically increasing sequence of keys (1, 2, 3, ...,) with no "
"deletions. In this case, compacting runs would be useless: all of the "
"elements are sorted, the tree doesn’t have any garbage, and the location "
"of any key can unequivocally be determined. On the other hand, if an LSM "
"tree contains many deletions, doing a compaction would free up some disk "
"space. However, even if there are no deletions, but key ranges in "
"different runs overlap a lot, compacting such runs could speed up lookups"
" as there would be fewer runs to scan. In this case, it might make sense "
"to compact runs after each dump. But keep in mind that a compaction "
"causes all data stored on disk to be overwritten, so with few reads it’s "
"recommended to perform it less often."
msgstr ""
"Ключевым фактором эффективности LSM-дерева является то, в какой момент и "
"для каких файлов делается слияние. Представим, что LSM-дерево в качестве "
"ключей хранит монотонную последовательность вида 1, 2, 3 …, и операций "
"удаления нет. В этом случае слияние будет бесполезным -- все элементы уже"
" отсортированы, дерево не содержит мусор и можно однозначно определить, в"
" каком файле находится каждый ключ. Напротив, если LSM-дерево содержит "
"много операций удаления, слияние позволит освободить место на диске. Но "
"даже если удалений нет, а диапазоны ключей в разных файлах сильно "
"пересекаются, слияние может ускорить поиск, так как сократит число "
"просматриваемых файлов. В этом случае имеет смысл выполнять слияние после"
" каждого дампа. Однако следует отметить, что такое слияние приведет к "
"перезаписи всех данных на диске, поэтому если чтений мало, то лучше "
"делать слияния реже."

#: ../doc/book/box/engines/vinyl.rst:219
msgid ""
"To ensure it’s optimally configurable for any of the scenarios above, an "
"LSM tree organizes all runs into a pyramid: the newer the data "
"operations, the higher up the pyramid they are located. During a "
"compaction, the algorithm picks two or more neighboring runs of "
"approximately equal size, if possible."
msgstr ""
"Для оптимальной конфигурации под любой из описанных выше сценариев в "
"LSM-дереве все файлы организованы в пирамиду: чем новее операции с "
"данными, тем выше они находятся в пирамиде. При этом в слиянии участвуют "
"два или несколько соседних файлов в пирамиде; по возможности выбираются "
"файлы примерно одинакового размера."

#: ../doc/book/box/engines/vinyl.rst:228
msgid "Multi-level compaction can span any number of levels"
msgstr "Многоуровневое слияние может охватить любое количество уровней"

#: ../doc/book/box/engines/vinyl.rst:229
msgid "A level can contain multiple runs"
msgstr "Уровень может содержать несколько файлов"

#: ../doc/book/box/engines/vinyl.rst:231
msgid ""
"All of the neighboring runs of approximately equal size constitute an LSM"
" tree level on disk. The ratio of run sizes at different levels "
"determines the pyramid’s proportions, which allows optimizing the tree "
"for write-intensive or read-intensive scenarios."
msgstr ""
"Все соседние файлы примерно одинакового размера составляют уровень "
"LSM-дерева на диске. Соотношение размеров файлов на различных уровнях "
"определяет пропорции пирамиды, что позволяет оптимизировать дерево под "
"интенсивные вставки, либо интенсивные чтения."

#: ../doc/book/box/engines/vinyl.rst:236
msgid ""
"Suppose the L0 size is 100 Mb, the ratio of run sizes at each level (the "
"``vinyl_run_size_ratio`` parameter) is 5, and there can be no more than 2"
" runs per level (the ``vinyl_run_count_per_level`` parameter). After the "
"first 3 dumps, the disk will contain 3 runs of 100 Mb each—which "
"constitute L1 (level one). Since 3 > 2, the runs will be compacted into a"
" single 300 Mb run, with the older ones being deleted. After 2 more "
"dumps, there will be another compaction, this time of 2 runs of 100 Mb "
"each and the 300 Mb run, which will produce one 500 Mb run. It will be "
"moved to L2 (recall that the run size ratio is 5), leaving L1 empty. The "
"next 10 dumps will result in L2 having 3 runs of 500 Mb each, which will "
"be compacted into a single 1500 Mb run. Over the course of 10 more dumps,"
" the following will happen: 3 runs of 100 Mb each will be compacted "
"twice, as will two 100 Mb runs and one 300 Mb run, which will yield 2 new"
" 500 Mb runs in L2. Since L2 now has 3 runs, they will also be compacted:"
" two 500 Mb runs and one 1500 Mb run will produce a 2500 Mb run that will"
" be moved to L3, given its size."
msgstr ""
"Предположим, что размер L0 составляет 100 МБ, а соотношение размеров "
"файлов на каждом уровне (параметр ``vinyl_run_size_ratio``) равно 5, и на"
" каждом уровне может быть не более 2 файлов (параметр "
"``vinyl_run_count_per_level``). После первых трех дампов на диске "
"появятся 3 файла по 100 МБ, эти файлы образуют уровень L1. Так как 3 > 2,"
" запустится слияние файлов в новый файл размером 300 МБ, а старые будут "
"удалены. Спустя еще 2 дампа снова запустится слияние, на этот раз файлов "
"в 100, 100 и 300 МБ, в результате файл размером 500 МБ переместится на "
"уровень L2 (вспомним, что соотношение размеров уровней равно 5), а "
"уровень L1 останется пустым. Пройдут еще 10 дампов, и получим 3 файла по "
"500 МБ на уровне L2, в результате чего будет создан один файл размером "
"1500 МБ. Спустя еще 10 дампов произойдет следующее: 2 раза произведем "
"слияние 3 файлов по 100 МБ, а также 2 раза слияние файлов по 100, 100 и "
"300 МБ, что приведет к созданию двух файлов на уровне L2 по 500 МБ. "
"Поскольку на уровне L2 уже есть три файла, запустится слияние двух файлов"
" по 500 МБ и одного файла в 1500 МБ. Полученный в результате файл в 2500 "
"МБ, в силу своего размера, переедет на уровень L3."

#: ../doc/book/box/engines/vinyl.rst:251
msgid ""
"This can go on infinitely, but if an LSM tree contains lots of deletions,"
" the resulting compacted run can be moved not only down, but also up the "
"pyramid due to its size being smaller than the sizes of the original runs"
" that were compacted. In other words, it’s enough to logically track "
"which level a certain run belongs to, based on the run size and the "
"smallest and greatest LSN among all of its operations."
msgstr ""
"Процесс может продолжаться до бесконечности, а если в потоке операций с "
"LSM-деревом будет много удалений, образовавшийся в результате слияния "
"файл может переместиться не только вниз по пирамиде, но и вверх, так как "
"окажется меньше исходных файлов, использовавшихся при слиянии. Иными "
"словами, принадлежность файла к уровню достаточно отслеживать логически "
"на основе размера файла и минимального и максимального LSN среди всех "
"хранящихся в нем операций."

#: ../doc/book/box/engines/vinyl.rst:262
msgid "Controlling the form of an LSM tree"
msgstr "Управление формой LSM-дерева"

#: ../doc/book/box/engines/vinyl.rst:264
msgid ""
"If it’s necessary to reduce the number of runs for lookups, then the run "
"size ratio can be increased, thus bringing the number of levels down. If,"
" on the other hand, you need to minimize the compaction-related overhead,"
" then the run size ratio can be decreased: the pyramid will grow higher, "
"and even though runs will be compacted more often, they will be smaller, "
"which will reduce the total amount of work done. In general, write "
"amplification in an LSM tree is described by this formula: "
":math:`log_{x}(\\frac {N} {L0}) × x` or, alternatively, :math:`x × \\frac"
" {ln (\\frac {N} {C0})} {ln(x)}`, where N is the total size of all tree "
"elements, L0 is the level zero size, and x is the level size ratio (the "
"``level_size_ratio`` parameter). At :math:`\\frac {N} {C0}` = 40 (the "
"disk-to- memory ratio), the plot would look something like this:"
msgstr ""
"Если число файлов для поиска нужно уменьшить, то соотношение размеров "
"файлов на разных уровнях можно увеличить, и, как следствие, уменьшается "
"число уровней. Если, напротив, необходимо снизить затраты ресурсов, "
"вызванные слиянием, то можно уменьшить соотношение размеров уровней: "
"пирамида будет более высокой, а слияние хотя и выполняется чаще, но "
"работает в среднем с файлами меньшего размера, за счет чего суммарно "
"выполняет меньше работы. В целом, \"паразитная запись\" в LSM-дереве "
"описывается формулой :math:`log_{x}(\\\\frac {N} {L0}) × x` или :math:`x "
"× \\\\frac {ln (\\\\frac {N} {C0})} {ln(x)}`, где N -- это общий размер "
"всех элементов дерева, L0 -- это размер уровня ноль, а x -- это "
"соотношение размеров уровней (параметр ``level_size_ratio``). Если "
":math:`\\\\frac {N} {C0}` = 40 (соотношение диск-память), график выглядит"
" примерно вот так:"

#: ../doc/book/box/engines/vinyl.rst:280
msgid ""
"As for read amplification, it’s proportional to the number of levels. The"
" lookup cost at each level is no greater than that for a B-tree. Getting "
"back to the example of a tree with 100,000,000 elements: given 256 Mb of "
"RAM and the default values of ``vinyl_level_size_ratio`` and "
"``run_count_per_level``, write amplification would come out to about 13, "
"while read amplification could be as high as 150. Let’s try to figure out"
" why this happens."
msgstr ""
"\"Паразитное\" чтение при этом пропорционально количеству уровней. "
"Стоимость поиска на каждом уровне не превышает стоимости поиска в "
"B-дереве. Возвращаясь к нашему примеру дерева в 100 000 000 элементов: "
"при наличии 256 МБ оперативной памяти и стандартных значений параметров "
"``vinyl_level_size_ratio`` и ``run_count_per_level``, получим коэффициент"
" \"паразитной\" записи равным примерно 13, коэффициент \"паразитной\" "
"записи может доходить до 150. Разберемся, почему это происходит."

#: ../doc/book/box/engines/vinyl.rst:291
msgid "Search"
msgstr "Поиск"

#: ../doc/book/box/engines/vinyl.rst:293
msgid ""
"When doing a lookup in an LSM tree, what we need to find is not the "
"element itself, but the most recent operation associated with it. If it’s"
" a deletion, then the tree doesn’t contain this element. If it’s an "
"insertion, we need to grab the topmost value in the pyramid, and the "
"search can be stopped after finding the first matching key. In the worst-"
"case scenario, that is if the tree doesn’t hold the needed element, the "
"algorithm will have to sequentially visit all of the levels, starting "
"from L0."
msgstr ""
"При поиске в LSM-дереве нам необходимо найти не сам элемент, а последнюю "
"операцию с ним. Если это операция удаления, искомый элемент отсутствует в"
" дереве. Если это операция вставки, то искомому элементу соответствует "
"самое верхнее значение в LSM-пирамиде, и поиск можно остановить при "
"первом совпадении ключа. В худшем случае значение в дереве изначально "
"отсутствовало. Тогда поиск вынужден последовательно перебрать все уровни "
"дерева, начиная с L0."

#: ../doc/book/box/engines/vinyl.rst:305
msgid ""
"Unfortunately, this scenario is quite common in real life. For example, "
"when inserting a value into a tree, it’s necessary to make sure there are"
" no duplicates among primary/unique keys. So to speed up membership "
"checks, LSM trees use a probabilistic data structure called a \"Bloom "
"filter\", which will be covered a bit later, in a section on how vinyl "
"works under the hood."
msgstr ""
"К сожалению, на практике этот худший случай довольно распространен. "
"Например, при вставке в дерево необходимо убедиться в отсутствии "
"дубликатов для первичного или уникального ключа. Поэтому для ускорения "
"поиска несуществующих значений в LSM-деревьях применяется вероятностная "
"структура данных, которая называется \"фильтр Блума\". О нем мы поговорим"
" более детально в разделе, посвященном внутреннему устройству vinyl."

#: ../doc/book/box/engines/vinyl.rst:315
msgid "Range searching"
msgstr "Поиск по диапазону"

#: ../doc/book/box/engines/vinyl.rst:317
msgid ""
"In the case of a single-key search, the algorithm stops after "
"encountering the first match. However, when searching within a certain "
"key range (for example, looking for all the users with the last name "
"\"Ivanov\"), it’s necessary to scan all tree levels."
msgstr ""
"Если при поиске по одному ключу алгоритм завершается после первого "
"совпадения, то для поиска всех значений в диапазоне (например, всех "
"пользователей с фамилией \"Иванов\") необходимо просматривать все уровни "
"дерева."

#: ../doc/book/box/engines/vinyl.rst:324
msgid "*Searching within a range of [24,30)*"
msgstr "*Поиск по диапазону [24,30)*"

#: ../doc/book/box/engines/vinyl.rst:326
msgid ""
"The required range is formed the same way as when compacting several "
"runs: the algorithm picks the key with the largest LSN out of all the "
"sources, ignoring the other associated operations, then moves on to the "
"next key and repeats the procedure."
msgstr ""
"Формирование искомого диапазона при этом происходит так же, как и при "
"слиянии нескольких файлов: из всех источников алгоритм выбирает ключ с "
"максимальным LSN, отбрасывает остальные операции по этому ключу, сдвигает"
" позицию поиска на следующий ключ и повторяет процедуру."

#: ../doc/book/box/engines/vinyl.rst:335
msgid "Deletion"
msgstr "Удаление"

#: ../doc/book/box/engines/vinyl.rst:337
msgid ""
"Why would one store deletions? And why doesn’t it lead to a tree overflow"
" in the case of for i=1,10000000 put(i) delete(i) end?"
msgstr ""
"Зачем вообще хранить операции удаления? И почему это не приводит к "
"переполнению дерева, например, в сценарии for i=1,10000000 put(i) "
"delete(i) end?"

#: ../doc/book/box/engines/vinyl.rst:340
msgid ""
"With regards to lookups, deletions signal the absence of a value being "
"searched; with compactions, they clear the tree of \"garbage\" records "
"with older LSNs."
msgstr ""
"Роль операций удаления при поиске -- сообщать об отсутствии искомого "
"значения, а при слиянии -- очищать дерево от \"мусорных\" записей с более"
" старыми LSN."

#: ../doc/book/box/engines/vinyl.rst:343
msgid ""
"While the data is in RAM only, there’s no need to store deletions. "
"Similarly, you don’t need to keep them following a compaction if they "
"affect, among other things, the lowest tree level, which contains the "
"oldest dump. Indeed, if a value can’t be found at the lowest level, then "
"it doesn’t exist in the tree."
msgstr ""
"Пока данные хранятся только в оперативной памяти, нет необходимости "
"хранить операции удаления. Также нет необходимости сохранять операции "
"удаления после слияния, если оно затрагивает в том числе самый нижний "
"уровень дерева -- на нем находятся данные самого старого дампа. "
"Действительно, отсутствие значения на последнем уровне означает, что оно "
"отсутствует в дереве."

#: ../doc/book/box/engines/vinyl.rst:348
msgid "We can't delete from append-only files"
msgstr ""
"Нельзя производить удаление из файлов, которые обновляются только путем "
"присоединения новых записей"

#: ../doc/book/box/engines/vinyl.rst:349
msgid "Tombstones (delete markers) are inserted into L0 instead"
msgstr "Вместо этого на уровень L0 вносятся маркеры удаленных записей (tombstones)"

#: ../doc/book/box/engines/vinyl.rst:353
msgid "*Deletion, step 1: a tombstone is inserted into L0*"
msgstr "*Удаление, шаг 1: вставка удаленной записи в L0*"

#: ../doc/book/box/engines/vinyl.rst:357
msgid "*Deletion, step 2: the tombstone passes through intermediate levels*"
msgstr "*Удаление, шаг 2: удаленная запись проходит через промежуточные уровни*"

#: ../doc/book/box/engines/vinyl.rst:361
msgid ""
"*Deletion, step 3: in the case of a major compaction, the tombstone is "
"removed from the tree*"
msgstr ""
"*Удаление, шаг 3: при значительном слиянии удаленная запись удаляется из "
"дерева*"

#: ../doc/book/box/engines/vinyl.rst:363
msgid ""
"If a deletion is known to come right after the insertion of a unique "
"value, which is often the case when modifying a value in a secondary "
"index, then the deletion can safely be filtered out while compacting "
"intermediate tree levels. This optimization is implemented in vinyl."
msgstr ""
"Если мы знаем, что удаление следует сразу за вставкой уникального "
"значения -- а это частый случай при изменении значения во вторичном "
"индексе -- то операцию удаления можно отфильтровывать уже при слиянии "
"промежуточных уровней. Эта оптимизация реализована в vinyl'е."

#: ../doc/book/box/engines/vinyl.rst:372
msgid "Advantages of an LSM tree"
msgstr "Преимущества LSM-дерева"

#: ../doc/book/box/engines/vinyl.rst:374
msgid ""
"Apart from decreasing write amplification, the approach that involves "
"periodically dumping level L0 and compacting levels L1-Lk has a few "
"advantages over the approach to writes adopted by B-trees:"
msgstr ""
"Помимо снижения \"паразитной\" записи, подход с периодическими дампами "
"уровня L0 и слиянием уровней L1-Lk имеет ряд преимуществ перед подходом к"
" записи, используемым в B-деревьях:"

#: ../doc/book/box/engines/vinyl.rst:378
msgid ""
"Dumps and compactions write relatively large files: typically, the L0 "
"size is 50-100 Mb, which is thousands of times larger than the size of a "
"B-tree block."
msgstr ""
"При дампах и слиянии создаются относительно большие файлы: стандартный "
"размер L0 составляет 50-100 MБ, что в тысячи раз превышает размер блока "
"B-дерева."

#: ../doc/book/box/engines/vinyl.rst:381
msgid ""
"This large size allows efficiently compressing data before writing it. "
"Tarantool compresses data automatically, which further decreases write "
"amplification."
msgstr ""
"Большой размер позволяет эффективно сжимать данные перед записью. В "
"Tarantool'е сжатие происходит автоматически, что позволяет еще больше "
"уменьшить \"паразитную\" запись."

#: ../doc/book/box/engines/vinyl.rst:384
msgid ""
"There is no fragmentation overhead, since there’s no padding/empty space "
"between the elements inside a run."
msgstr ""
"Издержки фрагментации отсутствуют, потому что в файле элементы следуют "
"друг за другом без пустот/заполнений."

#: ../doc/book/box/engines/vinyl.rst:386
msgid ""
"All operations create new runs instead of modifying older data in place. "
"This allows avoiding those nasty locks that everyone hates so much. "
"Several operations can run in parallel without causing any conflicts. "
"This also simplifies making backups and moving data to replicas."
msgstr ""
"Все операции создают новые файлы, а не заменяют старые данные. Это "
"позволяет избавиться от столь ненавистных нам блокировок, при этом "
"несколько операций могут идти параллельно, не приводя к конфликтам. Это "
"также упрощает создание резервных копий и перенос данных на реплику."

#: ../doc/book/box/engines/vinyl.rst:391
msgid ""
"Storing older versions of data allows for the efficient implementation of"
" transaction support by using multiversion concurrency control."
msgstr ""
"Хранение старых версий данных позволяет эффективно реализовать поддержку "
"транзакций, используя подход управления параллельным доступом с помощью "
"многоверсионности."

#: ../doc/book/box/engines/vinyl.rst:399
msgid "Disadvantages of an LSM tree and how to deal with them"
msgstr "Недостатки LSM-дерева и их устранение"

#: ../doc/book/box/engines/vinyl.rst:401
msgid ""
"One of the key advantages of the B-tree as a search data structure is its"
" predictability: all operations take no longer than :math:`log_{B}(N)` to"
" run. Conversely, in a classical LSM tree, both read and write speeds can"
" differ by a factor of hundreds (best case scenario) or even thousands "
"(worst case scenario). For example, adding just one element to L0 can "
"cause it to overflow, which can trigger a chain reaction in levels L1, "
"L2, and so on. Lookups may find the needed element in L0 or may need to "
"scan all of the tree levels. It’s also necessary to optimize reads within"
" a single level to achieve speeds comparable to those of a B-tree. "
"Fortunately, most disadvantages can be mitigated or even eliminated with "
"additional algorithms and data structures. Let’s take a closer look at "
"these disadvantages and how they’re dealt with in Tarantool."
msgstr ""
"Одним из ключевых преимуществ B-дерева как структуры данных для поиска "
"является предсказуемость: любая операция занимает не более чем "
":math:`log_{B}(N)`. В классическом LSM-дереве скорость как чтения, так и "
"записи могут может отличаться в лучшем и худшем случае в сотни и тысячи "
"раз. Например, добавление всего лишь одного элемента в L0 может привести "
"к его переполнению, что в свою очередь, может привести к переполнению L1,"
" L2 и т.д. Процесс чтения может обнаружить исходный элемент в L0, а может"
" задействовать все уровни. Чтение в пределах одного уровня также "
"необходимо оптимизировать, чтобы добиться скорости, сравнимой с "
"B-деревом. К счастью, многие недостатки можно скрасить или полностью "
"устранить с помощью вспомогательных алгоритмов и структур данных. "
"Систематизируем эти недостатки и опишем способы борьбы с ними, "
"используемые в Tarantool'е."

#: ../doc/book/box/engines/vinyl.rst:417
msgid "Unpredictable write speed"
msgstr "Непредсказуемая скорость записи"

#: ../doc/book/box/engines/vinyl.rst:419
msgid ""
"In an LSM tree, insertions almost always affect L0 only. How do you avoid"
" idle time when the memory area allocated for L0 is full?"
msgstr ""
"Вставка данных в LSM-дерево почти всегда задействует исключительно L0. "
"Как избежать простоя, если заполнена область оперативной памяти, "
"отведенная под L0?"

#: ../doc/book/box/engines/vinyl.rst:422
msgid ""
"Clearing L0 involves two lengthy operations: writing to disk and memory "
"deallocation. To avoid idle time while L0 is being dumped, Tarantool uses"
" writeaheads. Suppose the L0 size is 256 Mb. The disk write speed is 10 "
"Mbps. Then it would take 26 seconds to dump L0. The insertion speed is "
"10,000 RPS, with each key having a size of 100 bytes. While L0 is being "
"dumped, it’s necessary to reserve 26 Mb of RAM, effectively slicing the "
"L0 size down to 230 Mb."
msgstr ""
"Освобождение L0 подразумевает две долгих операции: запись на диск и "
"освобождение памяти. Чтобы избежать простоя во время записи L0 на диск, "
"Tarantool использует упреждающую запись. Допустим, размер L0 составляет "
"256 MБ. Скорость записи на диск составляет 10 МБ/с. Тогда для записи L0 "
"на диск понадобится 26 секунд. Скорость вставки данных составляет 10 000 "
"запросов в секунду, а размер одного ключа -- 100 байтов. На время записи "
"необходимо зарезервировать около 26 MБ доступной оперативной памяти, "
"сократив реальный полезный размер L0 до 230 MБ."

#: ../doc/book/box/engines/vinyl.rst:430
msgid ""
"Tarantool does all of these calculations automatically, constantly "
"updating the rolling average of the DBMS workload and the histogram of "
"the disk speed. This allows using L0 as efficiently as possible and it "
"prevents write requests from timing out. But in the case of workload "
"surges, some wait time is still possible. That’s why we also introduced "
"an insertion timeout (the ``vinyl_timeout`` parameter), which is set to "
"60 seconds by default. The write operation itself is executed in "
"dedicated threads. The number of these threads (2 by default) is "
"controlled by the ``vinyl_write_threads`` parameter. The default value of"
" 2 allows doing dumps and compactions in parallel, which is also "
"necessary for ensuring system predictability."
msgstr ""
"Все эти расчеты Tarantool делает автоматически, постоянно поддерживая "
"скользящее среднее значение нагрузки на СУБД и гистограмму скорости "
"работы диска. Это позволяет максимально эффективно использовать L0 и "
"избежать истечения времени ожидания доступной памяти для операций записи."
" При резком всплеске нагрузки ожидание все же возможно, поэтому также "
"существует время ожидания операции вставки (параметр ``vinyl_timeout``), "
"значение которого по умолчанию составляет 60 секунд. Сама запись "
"осуществляется в выделенных потоках, число которых (2 по умолчанию) "
"задается в параметре ``vinyl_write_threads``. Используемое по умолчанию "
"значение 2 позволяет выполнять дамп параллельно со слиянием, что также "
"необходимо для предсказуемой работы системы."

#: ../doc/book/box/engines/vinyl.rst:441
msgid ""
"In Tarantool, compactions are always performed independently of dumps, in"
" a separate execution thread. This is made possible by the append-only "
"nature of an LSM tree: after dumps runs are never changed, and "
"compactions simply create new runs."
msgstr ""
"Слияния в Tarantool'е всегда выполняются независимо от дампов, в "
"отдельном потоке выполнения. Это возможно благодаря природе LSM-дерева --"
" после записи файлы в дереве никогда не меняются, а слияние лишь создает "
"новый файл."

#: ../doc/book/box/engines/vinyl.rst:446
msgid ""
"Delays can also be caused by L0 rotation and the deallocation of memory "
"dumped to disk: during a dump, L0 memory is owned by two operating system"
" threads, a transaction processing thread and a write thread. Even though"
" no elements are being added to the rotated L0, it can still be used for "
"lookups. To avoid read locks when doing lookups, the write thread doesn’t"
" deallocate the dumped memory, instead delegating this task to the "
"transaction processor thread. Following a dump, memory deallocation "
"itself happens instantaneously: to achieve this, L0 uses a special "
"allocator that deallocates all of the memory with a single operation."
msgstr ""
"К задержкам также может приводить ротация L0 и освобождение памяти, "
"записанной на диск: в процессе записи памятью L0 владеют два потока "
"операционной системы -- поток обработки транзакций и поток записи. Хотя в"
" L0 во время ротации элементы не добавляются, он может участвовать в "
"поиске. Чтобы избежать блокировок на чтение во время поиска, поток записи"
" не освобождает записанную память, а оставляет эту задачу потоку "
"обработки транзакций. Само освобождение после завершения дампа происходит"
" мгновенно: для этого в L0 используется специализированный механизм "
"распределения, позволяющий освободить всю память за одну операцию."

#: ../doc/book/box/engines/vinyl.rst:458
msgid "anticipatory dump"
msgstr "упреждающий дамп"

#: ../doc/book/box/engines/vinyl.rst:459
msgid "throttling"
msgstr "загрузка"

#: ../doc/book/box/engines/vinyl.rst:461
msgid ""
"The dump is performed from the so-called \"shadow\" L0 without blocking "
"new insertions and lookups"
msgstr ""
"Дамп происходит из так называемого \"теневого\" L0, не блокируя новые "
"вставки и чтения"

#: ../doc/book/box/engines/vinyl.rst:468
msgid "Unpredictable read speed"
msgstr "Непредсказуемая скорость чтений"

#: ../doc/book/box/engines/vinyl.rst:470
msgid ""
"Optimizing reads is the most difficult optimization task with regards to "
"LSM trees. The main complexity factor here is the number of levels: any "
"optimization causes not only much slower lookups, but also tends to "
"require significantly larger RAM resources. Fortunately, the append-only "
"nature of LSM trees allows us to address these problems in ways that "
"would be nontrivial for traditional data structures."
msgstr ""
"Чтение -- самая сложная задача для оптимизации в LSM-деревьях. Главным "
"фактором сложности является большое количество уровней: это не только "
"значительно замедляет поиск, но и потенциально значительно увеличивает "
"требования к оперативной памяти при почти любых попытках оптимизации. К "
"счастью, природа LSM-деревьев, где файлы обновляются только путем "
"присоединения новых записей, позволяет решать эти проблемы нестандартными"
" для традиционных структур данных способами."

#: ../doc/book/box/engines/vinyl.rst:479
msgid "page index"
msgstr "постраничный индекс"

#: ../doc/book/box/engines/vinyl.rst:480
msgid "bloom filters"
msgstr "фильтры Блума"

#: ../doc/book/box/engines/vinyl.rst:481
msgid "tuple range cache"
msgstr "кэш диапазона кортежей"

#: ../doc/book/box/engines/vinyl.rst:482
msgid "multi-level compaction"
msgstr "многоуровневое слияние"

#: ../doc/book/box/engines/vinyl.rst:488
msgid "Compression and page index"
msgstr "Сжатие и постраничный индекс"

#: ../doc/book/box/engines/vinyl.rst:490
msgid ""
"In B-trees, data compression is either the hardest problem to crack or a "
"great marketing tool—rather than something really useful. In LSM trees, "
"compression works as follows:"
msgstr ""
"Сжатие данных в B-деревьях -- это либо сложнейшая в реализации задача, "
"либо больше средство маркетинга, чем действительно полезный инструмент. "
"Сжатие в LSM-деревьях работает следующим образом:"

#: ../doc/book/box/engines/vinyl.rst:494
msgid ""
"During a dump or compaction all of the data within a single run is split "
"into pages. The page size (in bytes) is controlled by the "
"``vinyl_page_size`` parameter and can be set separately for each index. A"
" page doesn’t have to be exactly of ``vinyl_page_size`` size—depending on"
" the data it holds, it can be a little bit smaller or larger. Because of "
"this, pages never have any empty space inside."
msgstr ""
"При любом дампе или слиянии мы разбиваем все данные в одном файле на "
"страницы. Размер страницы в байтах задается в параметре "
"``vinyl_page_size``, который можно менять отдельно для каждого индекса. "
"Страница не обязана занимать строго то количество байт, которое прописано"
" ``vinyl_page_size`` -- она может быть чуть больше или чуть меньше, в "
"зависимости от хранящихся в ней данных. Благодаря этому страница никогда "
"не содержит пустот."

#: ../doc/book/box/engines/vinyl.rst:501
msgid ""
"Data is compressed by `Facebook’s streaming algorithm "
"<https://github.com/facebook/zstd>`_ called \"zstd\". The first key of "
"each page, along with the page offset, is added to a \"page index\", "
"which is a separate file that allows the quick retrieval of any page. "
"After a dump or compaction, the page index of the created run is also "
"written to disk."
msgstr ""
"Для сжатия используется `потоковый алгоритм Facebook "
"<https://github.com/facebook/zstd>`_ под названием \"zstd\". Первый ключ "
"каждой страницы и смещение страницы в файле добавляются в так называемый "
"постраничный индекс (page index) -- отдельный файл, который позволяет "
"быстро найти нужную страницу. После дампа или слияния постраничный индекс"
" созданного файла также записывается на диск."

#: ../doc/book/box/engines/vinyl.rst:508
msgid ""
"All `.index` files are cached in RAM, which allows finding the necessary "
"page with a single lookup in a `.run` file (in vinyl, this is the "
"extension of files resulting from a dump or compaction). Since data "
"within a page is sorted, after it’s read and decompressed, the needed key"
" can be found using a regular binary search. Decompression and reads are "
"handled by separate threads, and are controlled by the "
"``vinyl_read_threads`` parameter."
msgstr ""
"Все файлы типа `.index`  кэшируются в оперативной памяти, что позволяет "
"найти нужную страницу за одно чтение из файла `.run` (такое расширение "
"имени файла используется в vinyl'е для файлов, полученных в результате "
"дампа или слияния). Поскольку данные в странице отсортированы, после "
"чтения и декомпрессии нужный ключ можно найти с помощью простого "
"бинарного поиска. За чтение и декомпрессию отвечают отдельные потоки, их "
"количество определяется в параметре ``vinyl_read_threads``."

#: ../doc/book/box/engines/vinyl.rst:515
msgid ""
"Tarantool uses a universal file format: for example, the format of a "
"`.run` file is no different from that of an `.xlog` file (log file). This"
" simplifies backup and recovery as well as the usage of external tools."
msgstr ""
"Tarantool использует единый формат файлов: например, формат данных в "
"файле `.run` ничем не отличается от формата файла `.xlog`  (файл "
"журнала). Это упрощает резервное копирование и восстановление, а также "
"работу внешних инструментов."

#: ../doc/book/box/engines/vinyl.rst:523
msgid "Bloom filters"
msgstr "Фильтры Блума"

#: ../doc/book/box/engines/vinyl.rst:525
msgid ""
"Even though using a page index enables scanning fewer pages per run when "
"doing a lookup, it’s still necessary to traverse all of the tree levels. "
"There’s a special case, which involves checking if particular data is "
"absent when scanning all of the tree levels and it’s unavoidable: I’m "
"talking about insertions into a unique index. If the data being inserted "
"already exists, then inserting the same data into a unique index should "
"lead to an error. The only way to throw an error in an LSM tree before a "
"transaction is committed is to do a search before inserting the data. "
"Such reads form a class of their own in the DBMS world and are called "
"\"hidden\" or \"parasitic\" reads."
msgstr ""
"Хотя постраничный индекс позволяет уменьшить количество страниц, "
"просматриваемых при поиске в одном файле, он не отменяет необходимости "
"искать на всех уровнях дерева. Есть важный частный случай, когда "
"необходимо проверить отсутствие данных, и тогда просмотр всех уровней "
"неизбежен: вставка в уникальный индекс. Если данные уже существуют, то "
"вставка в уникальный индекс должна завершиться с ошибкой. Единственный "
"способ вернуть ошибку до завершения транзакции в LSM-дереве -- произвести"
" поиск перед вставкой. Такого рода чтения в СУБД образуют целый класс, "
"называемый \"скрытыми\" или \"паразитными\" чтениями."

#: ../doc/book/box/engines/vinyl.rst:535
msgid ""
"Another operation leading to hidden reads is updating a value in a field "
"on which a secondary index is defined. Secondary keys are regular LSM "
"trees that store differently ordered data. In most cases, in order not to"
" have to store all of the data in all of the indexes, a value associated "
"with a given key is kept in whole only in the primary index (any index "
"that stores both a key and a value is called \"covering\" or "
"\"clustered\"), whereas the secondary index only stores the fields on "
"which a secondary index is defined, and the values of the fields that are"
" part of the primary index. Thus, each time a change is made to a value "
"in a field on which a secondary index is defined, it’s necessary to first"
" remove the old key from the secondary index—and only then can the new "
"key be inserted. At update time, the old value is unknown, and it is this"
" value that needs to be read in from the primary key \"under the hood\"."
msgstr ""
"Другая операция, приводящая к скрытым чтениям, -- обновление значения, по"
" которому построен вторичный индекс. Вторичные ключи представляют собой "
"обычные LSM-деревья, в которых данные хранятся в другом порядке. Чаще "
"всего, чтобы не хранить все данные во всех индексах, значение, "
"соответствующее данному ключу, целиком сохраняется только в первичном "
"индексе (любой индекс, хранящий и ключ, и значение, называется "
"покрывающим или кластерным), а во вторичном индексе сохраняются лишь "
"поля, по которым построен вторичный индекс, и значения полей, участвующих"
" в первичном индексе. Тогда при любом изменении значения, по которому "
"построен вторичный ключ, приходится сначала удалять из вторичного индекса"
" старый ключ, и только потом вставлять новый. Старое значение во время "
"обновления неизвестно -- именно его и нужно читать из первичного ключа с "
"точки зрения внутреннего устройства."

#: ../doc/book/box/engines/vinyl.rst:550
msgid "update t1 set city=’Moscow’ where id=1"
msgstr "update t1 set city=’Moscow’ where id=1"

#: ../doc/book/box/engines/vinyl.rst:554
msgid ""
"To minimize the number of disk reads, especially for nonexistent data, "
"nearly all LSM trees use probabilistic data structures, and Tarantool is "
"no exception. A classical Bloom filter is made up of several (usually "
"3-to-5) bit arrays. When data is written, several hash functions are "
"calculated for each key in order to get corresponding array positions. "
"The bits at these positions are then set to 1. Due to possible hash "
"collisions, some bits might be set to 1 twice. We’re most interested in "
"the bits that remain 0 after all keys have been added. When looking for "
"an element within a run, the same hash functions are applied to produce "
"bit positions in the arrays. If any of the bits at these positions is 0, "
"then the element is definitely not in the run. The probability of a false"
" positive in a Bloom filter is calculated using Bayes’ theorem: each hash"
" function is an independent random variable, so the probability of a "
"collision simultaneously occurring in all of the bit arrays is "
"infinitesimal."
msgstr ""
"Чтобы уменьшить количество чтений с диска, особенно для несуществующих "
"значений, практически все LSM-деревья используют вероятностные структуры "
"данных. Tarantool не исключение. Классический фильтр Блума -- это набор "
"из нескольких (обычно 3-5) битовых массивов. При записи для каждого ключа"
" вычисляется несколько хеш-функций, и в каждом массиве выставляется бит, "
"соответствующий значению хеша. При хешировании могут возникнуть коллизии,"
" поэтому некоторые биты могут быть проставлены дважды. Интерес "
"представляют биты, которые оказались не проставлены после записи всех "
"ключей. При поиске также вычисляются выбранные хеш-функции. Если хотя бы "
"в одном из битовых массивов бит не стоит, то значение в файле "
"отсутствует. Вероятность срабатывания фильтра Блума определяется теоремой"
" Байеса: каждая хеш-функция представляет собой независимую случайную "
"величину, благодаря чему вероятность того, что во всех битовых массивах "
"одновременно произойдет коллизия, очень мала."

#: ../doc/book/box/engines/vinyl.rst:568
#, python-format
msgid ""
"The key advantage of Bloom filters in Tarantool is that they’re easily "
"configurable. The only parameter that can be specified separately for "
"each index is called ``bloom_fpr`` (FPR stands for \"false positive "
"ratio\") and it has the default value of 0.05, which translates to a 5% "
"FPR. Based on this parameter, Tarantool automatically creates Bloom "
"filters of the optimal size for partial- key and full-key searches. The "
"Bloom filters are stored in the `.index` file, along with the page index,"
" and are cached in RAM."
msgstr ""
"Ключевым преимуществом реализации фильтров Блума в Tarantool'е является "
"простота настройки. Единственный параметр, который можно менять "
"независимо для каждого индекса, называется ``bloom_fpr`` (FPR в данном "
"случае означает сокращение от \"false positive ratio\" -- коэффициент "
"ложноположительного срабатывания), который по умолчанию равен 0,05, или "
"5%. На основе этого параметра Tarantool автоматически строит фильтры "
"Блума оптимального размера для поиска как по полному ключу, так и по "
"компонентам ключа. Сами фильтры Блума хранятся вместе с постраничным "
"индексом в файле `.index` и кэшируются в оперативной памяти."

#: ../doc/book/box/engines/vinyl.rst:580
msgid "Caching"
msgstr "Кэширование"

#: ../doc/book/box/engines/vinyl.rst:582
msgid ""
"A lot of people think that caching is a silver bullet that can help with "
"any performance issue. \"When in doubt, add more cache\". In vinyl, "
"caching is viewed rather as a means of reducing the overall workload and "
"consequently, of getting a more stable response time for those requests "
"that don’t hit the cache. vinyl boasts a unique type of cache among "
"transactional systems called a \"range tuple cache\". Unlike, say, "
"RocksDB or MySQL, this cache doesn’t store pages, but rather ranges of "
"index values obtained  from disk, after having performed a compaction "
"spanning all tree levels. This allows the use of caching for both single-"
"key and key-range searches. Since this method of caching stores only hot "
"data and not, say, pages (you may need only some data from a page), RAM "
"is used in the most efficient way possible. The cache size is controlled "
"by the ``vinyl_cache`` parameter."
msgstr ""
"Многие привыкли считать кэширование панацеей от всех проблем с "
"производительностью: \"В любой непонятной ситуации добавляй кэш\". В "
"vinyl'е мы смотрим на кэш скорее как на средство снижения общей нагрузки "
"на диск, и, как следствие, получения более предсказуемого времени ответов"
" на запросы, которые не попали в кэш. В vinyl'е реализован уникальный для"
" транзакционных систем вид кэша под названием \"кэш диапазона кортежей\" "
"(range tuple cache). В отличие от RocksDB, например, или MySQL, этот кэш "
"хранит не страницы, а уже готовые диапазоны значений индекса, после их "
"чтения с диска и слияния всех уровней. Это позволяет использовать кэш для"
" запросов как по одному ключу, так и по диапазону ключей. Поскольку в "
"кэше хранятся только горячие данные, а не, скажем, страницы (в странице "
"может быть востребована лишь часть данных), оперативная память "
"используется наиболее оптимально. Размер кэша задается в параметре "
"``vinyl_cache``."

#: ../doc/book/box/engines/vinyl.rst:599
msgid "Garbage collection control"
msgstr "Управление сборкой мусора"

#: ../doc/book/box/engines/vinyl.rst:601
msgid ""
"Chances are that by now you’ve started losing focus and need a well-"
"deserved dopamine reward. Feel free to take a break, since working "
"through the rest of the article is going to take some serious mental "
"effort."
msgstr ""
"Возможно, добравшись до этого места вы уже начали терять концентрацию и "
"нуждаетесь в заслуженной дозе допамина. Самое время сделать перерыв, так "
"как для того, чтобы разобраться с оставшейся частью, понадобятся "
"серьезные усилия."

#: ../doc/book/box/engines/vinyl.rst:605
msgid ""
"An LSM tree in vinyl is just a small piece of the puzzle. Even with a "
"single table (or so-called \"space\"), vinyl creates and maintains "
"several LSM trees, one for each index. But even a single index can be "
"comprised of dozens of LSM trees. Let’s try to understand why this might "
"be necessary."
msgstr ""
"В vinyl'е устройство одного LSM-дерева -- это лишь фрагмент мозаики. "
"Vinyl создает и обслуживает несколько LSM-деревьев даже для одной таблицы"
" (так называемого спейса) -- по одному дереву на каждый индекс. Но даже "
"один единственный индекс может состоять из десятков LSM-деревьев. "
"Попробуем разобраться, зачем."

#: ../doc/book/box/engines/vinyl.rst:610
msgid ""
"Recall our example with a tree containing 100,000,000 records, 100 bytes "
"each. As time passes, the lowest LSM level may end up holding a 10 Gb "
"run. During compaction, a temporary run of approximately the same size "
"will be created. Data at intermediate levels takes up some space as well,"
" since the tree may store several operations associated with a single "
"key. In total, storing 10 Gb of actual data may require up to 30 Gb of "
"free space: 10 Gb for the last tree level, 10 Gb for a temporary run, and"
" 10 Gb for the remaining data. But what if the data size is not 10 Gb, "
"but 1 Tb? Requiring that the available disk space always be several times"
" greater than the actual data size is financially unpractical, not to "
"mention that it may take dozens of hours to create a 1 Tb run. And in the"
" case of an emergency shutdown or system restart, the process would have "
"to be started from scratch."
msgstr ""
"Рассмотрим наш стандартный пример: 100 000 000 записей по 100 байтов "
"каждая. Через некоторое время на самом нижнем уровне LSM у нас может "
"оказаться файл размером 10 ГБ. Во время слияния последнего уровня мы "
"создадим временный файл, который также будет занимать около 10 ГБ. Данные"
" на промежуточных уровнях тоже занимают место: по одному и тому же ключу "
"дерево может хранить несколько операций. Суммарно для хранения 10 ГБ "
"полезных данных нам может потребоваться до 30 ГБ свободного места: 10 ГБ "
"на последний уровень, 10 ГБ на временный файл и 10 ГБ на всё остальное. А"
" если данных не 1 ГБ, а 1 ТБ? Требовать, чтобы количество свободного "
"места на диске всегда в несколько раз превышало объем полезных данных, "
"экономически нецелесообразно, да и создание файла в 1ТБ может занимать "
"десятки часов. При любой аварии или перезапуске системы операцию придется"
" начинать заново."

#: ../doc/book/box/engines/vinyl.rst:623
msgid ""
"Here’s another scenario. Suppose the primary key is a monotonically "
"increasing sequence—for example, a time series. In this case, most "
"insertions will fall into the right part of the key range, so it wouldn’t"
" make much sense to do a compaction just to append a few million more "
"records to an already huge run."
msgstr ""
"Рассмотрим другую проблему. Представим, что первичный ключ дерева -- это "
"монотонная последовательность, например, временной ряд. В этом случае "
"основные вставки будут приходиться на правую часть диапазона ключей. Нет "
"смысла заново производить слияние лишь для того, чтобы дописать в конец и"
" без того огромного файла еще несколько миллионов записей."

#: ../doc/book/box/engines/vinyl.rst:628
msgid ""
"But what if writes predominantly occur in a particular region of the key "
"range, whereas most reads take place in a different region? How do you "
"optimize the form of the LSM tree in this case? If it’s too high, read "
"performance is impacted; if it’s too low—write speed is reduced."
msgstr ""
"А если вставки происходят, в основном, в одну часть диапазона ключей, а "
"чтения -- из другой части? Как в этом случае оптимизировать форму дерева?"
" Если оно будет слишком высоким, пострадают чтения, если слишком низким "
"-- запись."

#: ../doc/book/box/engines/vinyl.rst:633
msgid ""
"Tarantool \"factorizes\" this problem by creating multiple LSM trees for "
"each index. The approximate size of each subtree may be controlled by the"
" :ref:`vinyl_range_size <cfg_storage-vinyl_range_size>` configuration "
"parameter. We call such subtrees \"ranges\"."
msgstr ""
"Tarantool \"факторизует\" проблему, создавая не одно, а множество "
"LSM-деревьев для каждого индекса. Примерный размер каждого поддерева "
"можно задать в конфигурационном параметре ``vinyl_range_size``. Такие "
"поддеревья называется диапазонами (\"range\")."

#: ../doc/book/box/engines/vinyl.rst:642
msgid "Factorizing large LSM trees via ranging"
msgstr "Факторизация больших LSM-деревьев с помощью диапазонов"

#: ../doc/book/box/engines/vinyl.rst:644
msgid "Ranges reflect a static layout of sorted runs"
msgstr "Диапазоны отражают статичную структуру упорядоченных файлов"

#: ../doc/book/box/engines/vinyl.rst:645
msgid "Slices connect a sorted run into a range"
msgstr "Срезы объединяют упорядоченный файл в диапазон"

#: ../doc/book/box/engines/vinyl.rst:649
msgid ""
"Initially, when the index has few elements, it consists of a single "
"range. As more elements are added, its total size may exceed :ref:`the "
"maximum range size <cfg_storage-vinyl_range_size>`. In that case a "
"special operation called \"split\" divides the tree into two equal parts."
" The tree is split at the middle element in the range of keys stored in "
"the tree. For example, if  the tree initially stores the full range of "
"-inf…+inf, then after splitting it at the middle key X, we get two "
"subtrees: one that stores the range of -inf...X, and the other storing "
"the range of X…+inf. With this approach, we always know which subtree to "
"use for writes and which one for reads. If the tree contained deletions "
"and each of the neighboring ranges grew smaller as a result, the opposite"
" operation called \"coalesce\" combines two neighboring trees into one."
msgstr ""
"Изначально, пока в индексе мало элементов, он состоит из одного "
"диапазона. По мере добавления элементов суммарный объем может превысить "
":ref:`максимальный размер диапазона <cfg_storage-vinyl_range_size>`. В "
"таком случае выполняется операция под названием \"разделение\" (split), "
"которая делит дерево на две равные части. Разделение происходит по "
"срединному элементу диапазона ключей, хранящихся в дереве. Например, если"
" изначально дерево хранит полный диапазон -inf… +inf, то после разделения"
" по срединному ключу X получим два поддерева: одно будет хранить все "
"ключи от -inf до X, другое -- от X до +inf. Таким образом, при вставке "
"или чтении мы однозначно знаем, к какому поддереву обращаться. Если в "
"дереве были удаления и каждый из соседних диапазонов уменьшился, "
"выполняется обратная операция под названием \"объединение\" (coalesce). "
"Она объединяет два соседних дерева в одно."

#: ../doc/book/box/engines/vinyl.rst:662
msgid ""
"Split and coalesce don’t entail a compaction, the creation of new runs, "
"or other resource-intensive operations. An LSM tree is just a collection "
"of runs. vinyl has a special metadata log that helps keep track of which "
"run belongs to which subtree(s). This has the `.vylog` extension and its "
"format is compatible with an .xlog file. Similarly to an `.xlog` file, "
"the metadata log gets rotated at each checkpoint. To avoid the creation "
"of extra runs with split and coalesce, we have also introduced an "
"auxiliary entity called \"slice\". It’s a reference to a run containing a"
" key range and it’s stored only in the metadata log. Once the reference "
"counter drops to zero, the corresponding file gets removed. When it’s "
"necessary to perform a split or to coalesce, Tarantool creates slice "
"objects for each new tree, removes older slices, and writes these "
"operations to the metadata log, which literally stores records that look "
"like this: ``<tree id, slice id>`` or ``<slice id, run id, min, max>``."
msgstr ""
"Разделение и объединение не приводят к слиянию, созданию новых файлов и "
"прочим тяжеловесным операциям. LSM-дерево -- это лишь набор файлов. В "
"vinyl'е мы реализовали специальный журнал метаданных, позволяющий легко "
"отслеживать, какой файл принадлежит какому поддереву или поддеревьям. "
"Журнал имеет разрешение `.vylog`, по формату он совместим с файлом "
"`.xlog`. Как и файл `.xlog`, происходит автоматическая ротация файла при "
"каждой контрольной точке. Чтобы избежать повторного создания файлов при "
"разделении и объединении, мы ввели промежуточную сущность -- срез "
"(slice). Это ссылка на файл с указанием диапазона значений ключа, которая"
" хранится исключительно в журнале метаданных. Когда число ссылок на файл "
"становится равным нулю, файл удаляется. А когда необходимо произвести "
"разделение или объединение, Tarantool создает срезы для каждого нового "
"дерева, старые срезы удаляет, и записывает эти операции в журнал "
"метаданных. Буквально, журнал метаданных хранит записи вида "
"<идентификатор дерева, идентификатор среза> или <идентификатор среза, "
"идентификатор файла, мин, макс>."

#: ../doc/book/box/engines/vinyl.rst:676
msgid ""
"This way all of the heavy lifting associated with splitting a tree into "
"two subtrees is postponed until a compaction and then is performed "
"automatically. A huge advantage of dividing all of the keys into ranges "
"is the ability to independently control the L0 size as well as the dump "
"and compaction processes for each subtree, which makes these processes "
"manageable and predictable. Having a separate metadata log also "
"simplifies the implementation of both \"truncate\" and \"drop\". In "
"vinyl, they’re processed instantly, since they only work with the "
"metadata log, while garbage collection is done in the background."
msgstr ""
"Таким образом, непосредственно тяжелая работа по разбиению дерева на два "
"поддерева, откладывается до слияния и выполняется автоматически.\n"
"Огромным преимуществом подхода с разделением всего диапазона ключей на "
"диапазоны является возможность независимо управлять размером L0, а также "
"процессом создания дампов и слиянием для каждого поддерева. В результате "
"эти процессы являются управляемыми и предсказуемыми. Наличие отдельного "
"журнала метаданных также упрощает выполнение таких операций, как усечение"
" и удаление -- в vinyl'е они обрабатываются мгновенно, потому что "
"работают исключительно с журналом метаданных, а удаление мусора "
"выполняется в фоне."

#: ../doc/book/box/engines/vinyl.rst:689
msgid "Advanced features of vinyl"
msgstr "Расширенные возможности vinyl'а"

#: ../doc/book/box/engines/vinyl.rst:695
msgid "Upsert"
msgstr "Upsert (обновление и вставка)"

#: ../doc/book/box/engines/vinyl.rst:697
msgid ""
"In the previous sections, we mentioned only two operations stored by an "
"LSM tree: deletion and replacement. Let’s take a look at how all of the "
"other operations can be represented. An insertion can be represented via "
"a replacement—you just need to make sure there are no other elements with"
" the specified key. To perform an update, it’s necessary to read the "
"older value from the tree, so it’s easier to represent this operation as "
"a replacement as well—this speeds up future read requests by the key. "
"Besides, an update must return the new value, so there’s no avoiding "
"hidden reads."
msgstr ""
"В предыдущих разделах упоминались лишь две операции, которые хранит "
"LSM-дерево: удаление и замена. Давайте рассмотрим, как представлены все "
"остальные. Вставку можно представить с помощью замены -- необходимо лишь "
"предварительно убедиться в отсутствии элемента указанным ключом. Для "
"выполнения обновления необходимо предварительно считывать старое значение"
" из дерева, так что и эту операцию проще записать в дерево как замену -- "
"это ускорит будущие чтения по этому ключу. Кроме того, обновление должно "
"вернуть новое значение, так что скрытых чтений никак не избежать."

#: ../doc/book/box/engines/vinyl.rst:706
msgid ""
"In B-trees, the cost of hidden reads is negligible: to update a block, it"
" first needs to be read from disk anyway. Creating a special update "
"operation for an LSM tree that doesn’t cause any hidden reads is really "
"tempting."
msgstr ""
"В B-деревьях скрытые чтения почти ничего не стоят: чтобы обновить блок, "
"его в любом случае необходимо прочитать с диска. Для LSM-деревьев идея "
"создания специальной операции обновления, которая не приводила бы к "
"скрытым чтениям, выглядит очень заманчивой."

#: ../doc/book/box/engines/vinyl.rst:711
msgid ""
"Such an operation must contain not only a default value to be inserted if"
" a key has no value yet, but also a list of update operations to perform "
"if a value does exist."
msgstr ""
"Такая операция должна содержать как значение по умолчанию, которое нужно "
"вставить, если данных по ключу еще нет, так и список операций обновления,"
" которые нужно выполнить, если значение существует."

#: ../doc/book/box/engines/vinyl.rst:715
msgid ""
"At transaction execution time, Tarantool just saves the operation in an "
"LSM tree, then \"executes\" it later, during a compaction."
msgstr ""
"На этапе выполнения транзакции Tarantool лишь сохраняет всю операцию в "
"LSM-дереве, а \"выполняет\" ее уже только во время слияния."

#: ../doc/book/box/engines/vinyl.rst:719
msgid "The upsert operation:"
msgstr "Операция обновления и вставки:"

#: ../doc/book/box/engines/vinyl.rst:721
msgid "space:upsert(tuple, {{operator, field, value}, ... })"
msgstr "space:upsert(tuple, {{operator, field, value}, ... })"

#: ../doc/book/box/engines/vinyl.rst:725
msgid "Non-reading update or insert"
msgstr "Обновление без чтения или вставка"

#: ../doc/book/box/engines/vinyl.rst:726
msgid "Delayed execution"
msgstr "Отложенное выполнение"

#: ../doc/book/box/engines/vinyl.rst:727
msgid "Background upsert squashing prevents upserts from piling up"
msgstr ""
"Фоновое сжатие операций обновления и вставки предотвращает накапливание "
"операций"

#: ../doc/book/box/engines/vinyl.rst:729
msgid ""
"Unfortunately, postponing the operation execution until a compaction "
"doesn’t leave much leeway in terms of error handling. That’s why "
"Tarantool tries to validate upserts as fully as possible before writing "
"them to an LSM tree. However, some checks are only possible with older "
"data on hand, for example when the update operation is trying to add a "
"number to a string or to remove a field that doesn’t exist."
msgstr ""
"К сожалению, если откладывать выполнение операции на этап слияния, "
"возможностей для обработки ошибок не остается. Поэтому Tarantool "
"стремится максимально проверять операции обновления и вставки upsert "
"перед записью в дерево. Тем не менее, некоторые проверки можно выполнить "
"лишь имея старые данные на руках. Например, если обновление прибавляет "
"число к строке или удаляет несуществующее поле."

#: ../doc/book/box/engines/vinyl.rst:736
msgid ""
"A semantically similar operation exists in many products including "
"PostgreSQL and MongoDB. But anywhere you look, it’s just syntactic sugar "
"that combines the update and replace operations without avoiding hidden "
"reads. Most probably, the reason is that LSM trees as data storage "
"structures are relatively new."
msgstr ""
"Операция с похожей семантикой присутствует во многих продуктах, в том "
"числе в PostgreSQL и MongoDB. Но везде она представляет собой лишь "
"синтаксический сахар, объединяющий обновление и вставку, не избавляя СУБД"
" от необходимости выполнять скрытые чтения. Скорее всего, причиной этого "
"является относительная новизна LSM-деревьев в качестве структур данных "
"для хранения."

#: ../doc/book/box/engines/vinyl.rst:742
msgid ""
"Even though an upsert is a very important optimization and implementing "
"it cost us a lot of blood, sweat, and tears, we must admit that it has "
"limited applicability. If a table contains secondary keys or triggers, "
"hidden reads can’t be avoided. But if you have a scenario where secondary"
" keys are not required and the update following the transaction "
"completion will certainly not cause any errors, then the operation is for"
" you."
msgstr ""
"Хотя обновление и вставка upsert представляет собой очень важную "
"оптимизацию, и ее реализация стоила нам долгой напряженной работы, "
"следует признать, что ее применимость ограничена. Если в таблице есть "
"вторичные ключи или триггеры, скрытых чтений не избежать. А если у вас "
"есть сценарии, для которых не нужны вторичные ключи и обновление после "
"завершения транзакции однозначно не приведет к ошибкам -- эта операция "
"для вас."

#: ../doc/book/box/engines/vinyl.rst:749
msgid ""
"I’d like to tell you a short story about an upsert. It takes place back "
"when vinyl was only beginning to \"mature\" and we were using an upsert "
"in production for the first time. We had what seemed like an ideal "
"environment for it: we had tons of keys, the current time was being used "
"as values; update operations were inserting keys or modifying the current"
" time; and we had few reads. Load tests yielded great results."
msgstr ""
"Небольшая история, связанная с этим оператором: vinyl только начинал "
"\"взрослеть\", и мы впервые запустили операцию обновления и вставки "
"upsert на рабочие серверы. Казалось бы, идеальные условия: огромный набор"
" ключей, текущее время в качестве значения, операции обновления либо "
"вставляют ключ, либо обновляют текущее время, редкие операции чтения. "
"Нагрузочные тесты показали отличные результаты."

#: ../doc/book/box/engines/vinyl.rst:757
#, python-format
msgid ""
"Nevertheless, after a couple of days, the Tarantool process started "
"eating up 100% of our CPU, and the system performance dropped close to "
"zero."
msgstr ""
"Тем не менее, после пары дней работы процесс Tarantool'а начал потреблять"
" 100 % CPU, а производительность системы упала практически до нуля."

#: ../doc/book/box/engines/vinyl.rst:760
msgid ""
"We started digging into the issue and found out that the distribution of "
"requests across keys was significantly different from what we had seen in"
" the test environment. It was...well, quite nonuniform. Most keys were "
"updated once or twice a day, so the database was idle for the most part, "
"but there were much hotter keys with tens of thousands of updates per "
"day. Tarantool handled those just fine. But in the case of lookups by key"
" with tens of thousands of upserts, things quickly went downhill. To "
"return the most recent value, Tarantool had to read and \"replay\" the "
"whole history consisting of all of the upserts. When designing upserts, "
"we had hoped this would happen automatically during a compaction, but the"
" process never even got to that stage: the L0 size was more than enough, "
"so there were no dumps."
msgstr ""
"Начали подробно изучать проблему. Оказалось, что распределение запросов "
"по ключам существенно отличалось от того, что мы видели в тестовом "
"окружении. Оно было… очень неравномерное. Большая часть ключей "
"обновлялась 1-2 раза за сутки, и база для них не была нагружена. Но были "
"ключи гораздо более горячие -- десятки тысяч обновлений в сутки. "
"Tarantool прекрасно справлялся с этим потоком обновлений. А вот когда по "
"ключу с десятком тысяч операций обновления и вставки upsert происходило "
"чтение, всё шло под откос. Чтобы вернуть последнее значение, Tarantool'у "
"приходилось каждый раз прочитать и \"проиграть\" историю из десятков "
"тысяч команд обновления и вставки upsert. На стадии проекта мы надеялись,"
" что это произойдет автоматически во время слияния уровней, но до слияния"
" дело даже не доходило: памяти L0 было предостаточно, и дампы не "
"создавались."

#: ../doc/book/box/engines/vinyl.rst:773
msgid ""
"We solved the problem by adding a background process that performed "
"readaheads on any keys that had more than a few dozen upserts piled up, "
"so all those upserts were squashed and substituted with the read value."
msgstr ""
"Решили мы проблему добавлением фонового процесса, осуществляющего "
"упреждающие чтения для ключей, по которым накопилось больше нескольких "
"десятков операций обновления и вставки upsert с последующей заменой на "
"прочитанное значение."

#: ../doc/book/box/engines/vinyl.rst:782
msgid "Secondary keys"
msgstr "Вторичные ключи"

#: ../doc/book/box/engines/vinyl.rst:784
msgid ""
"Update is not the only operation where optimizing hidden reads is "
"critical. Even the replace operation, given secondary keys, has to read "
"the older value: it needs to be independently deleted from the secondary "
"indexes, and inserting a new element might not do this, leaving some "
"garbage behind."
msgstr ""
"Не только для операции обновления остро стоит проблема оптимизации "
"скрытых чтений. Даже операция замены при наличии вторичных ключей "
"вынуждена читать старое значение: его нужно независимо удалить из "
"вторичных индексов, а вставка нового элемента может этого не сделать, "
"оставив в индексе мусор."

#: ../doc/book/box/engines/vinyl.rst:794
#, python-format
msgid ""
"If secondary indexes are not unique, then collecting \"garbage\" from "
"them can be put off until a compaction, which is what we do in Tarantool."
" The append-only nature of LSM trees allowed us to implement full-blown "
"serializable transactions in vinyl. Read-only requests use older versions"
" of data without blocking any writes. The transaction manager itself is "
"fairly simple for now: in classical terms, it implements the MVTO "
"(multiversion timestamp ordering) class, whereby the winning transaction "
"is the one that finished earlier. There are no locks and associated "
"deadlocks. Strange as it may seem, this is a drawback rather than an "
"advantage: with parallel execution, you can increase the number of "
"successful transactions by simply holding some of them on lock when "
"necessary. We’re planning to improve the transaction manager soon. In the"
" current release, we focused on making the algorithm behave 100% "
"correctly and predictably. For example, our transaction manager is one of"
" the few on the NoSQL market that supports so-called \"gap locks\"."
msgstr ""
"Если вторичные индексы не уникальны, то удаление из них \"мусора\" также "
"можно перенести в фазу слияния, что мы и делаем в Tarantool'е. Природа "
"LSM-дерева, в котором файлы обновляются путем присоединения новых "
"записей, позволила нам реализовать в vinyl'е полноценные сериализуемые "
"транзакции. Запросы только для чтения при этом используют старые версии "
"данных и не блокируют запись. Сам менеджер транзакций пока довольно "
"простой: в традиционной классификации он реализует класс MVTO "
"(multiversion timestamp ordering -- упорядочение временных меток на "
"основе многоверсионности), при этом в конфликте побеждает та транзакция, "
"что завершилась первой. Блокировок и свойственных им взаимоблокировок "
"нет. Как ни странно, это скорее недостаток, чем преимущество: при "
"параллельном выполнении можно повысить количество успешных транзакций, "
"задерживая некоторые из них в нужный момент на блокировке. Развитие "
"менеджера транзакций в наших ближайших планах. В текущей версии мы "
"сфокусировались на том, чтобы сделать алгоритм корректным и предсказуемым"
" на 100%. Например, наш менеджер транзакций -- один из немногих в "
"NoSQL-среде, поддерживающих так называемые \"блокировки разрывов\" (gap "
"locks)."

#: ../doc/book/box/index.rst:5
msgid "Database"
msgstr "Функциональность СУБД"

#: ../doc/book/box/index.rst:7
msgid ""
"In this chapter, we introduce the basic concepts of working with "
"Tarantool as a database manager."
msgstr ""
"В данной главе мы рассмотрим основные понятия при работе с Tarantool'ом в"
" качестве системы управления базой данных."

#: ../doc/book/box/limitations.rst:5
msgid "Limitations"
msgstr "Ограничения"

#: ../doc/book/box/limitations.rst:7
msgid "**Number of parts in an index**"
msgstr "**Количество частей в индексе**"

#: ../doc/book/box/limitations.rst:9
msgid ""
"For TREE or HASH indexes, the maximum is 255 "
"(``box.schema.INDEX_PART_MAX``). For :ref:`RTREE <box_index-rtree>` "
"indexes, the maximum is 1 but the field is an ARRAY of up to 20 "
"dimensions. For BITSET indexes, the maximum is 1."
msgstr ""
"Для TREE-индексов или HASH-индексов максимальное количество -- 255 частей"
" (``box.schema.INDEX_PART_MAX``). Для :ref:`RTREE-индексов <box_index-"
"rtree>` максимальное количество -- 1, но это поля типа ARRAY (массив) с "
"размерностью до 20. Для BITSET-индексов максимальное количество -- 1."

#: ../doc/book/box/limitations.rst:16
msgid "**Number of indexes in a space**"
msgstr "**Количество индексов в спейсе**"

#: ../doc/book/box/limitations.rst:18
msgid "128 (``box.schema.INDEX_MAX``)."
msgstr "128 (``box.schema.INDEX_MAX``)."

#: ../doc/book/box/limitations.rst:22
msgid "**Number of fields in a tuple**"
msgstr "**Количество полей в кортеже**"

#: ../doc/book/box/limitations.rst:24
msgid ""
"The theoretical maximum is 2,147,483,647 (``box.schema.FIELD_MAX``). The "
"practical maximum is whatever is specified by the space's "
":ref:`field_count <box_space-field_count>` member, or the maximal tuple "
"length."
msgstr ""
"Теоретически максимальное количество составляет 2 147 483 647 полей "
"(``box.schema.FIELD_MAX``). Практически максимальное количество указано в"
" поле :ref:`field_count <box_space-field_count>` спейса или соответствует"
" максимальной длине кортежа."

#: ../doc/book/box/limitations.rst:31
msgid "**Number of bytes in a tuple**"
msgstr "**Количество байтов в кортеже**"

#: ../doc/book/box/limitations.rst:33
msgid ""
"The maximal number of bytes in a tuple is roughly equal to "
":ref:`memtx_max_tuple_size <cfg_storage-memtx_max_tuple_size>` or "
":ref:`vinyl_max_tuple_size <cfg_storage-vinyl_max_tuple_size>` (with a "
"metadata overhead of about 20 bytes per tuple, which is added on top of "
"useful bytes). By default, the value of either ``memtx_max_tuple_size`` "
"or ``vinyl_max_tuple_size`` is 1,048,576. To increase it, specify a "
"larger value when starting the Tarantool instance. For example, "
"``box.cfg{memtx_max_tuple_size=2*1048576}``."
msgstr ""
"Максимальное количество байтов в кортеже примерно равно "
":ref:`memtx_max_tuple_size <cfg_storage-memtx_max_tuple_size>` или "
":ref:`vinyl_max_tuple_size <cfg_storage-vinyl_max_tuple_size>` (с "
"ресурсами метаданных около 20 байтов на кортеж, которые добавляются к "
"полезным байтам). Значение ``memtx_max_tuple_size`` или "
"``vinyl_max_tuple_size`` по умолчанию составляет 1 048 576. Чтобы его "
"увеличить, укажите большее значение при запуске экземпляра Tarantool'а. "
"Например, ``box.cfg{memtx_max_tuple_size=2*1048576}``."

#: ../doc/book/box/limitations.rst:45
msgid "**Number of bytes in an index key**"
msgstr "**Количество байтов в индекс-ключе**"

#: ../doc/book/box/limitations.rst:47
msgid ""
"If a field in a tuple can contain a million bytes, then the index key can"
" contain a million bytes, so the maximum is determined by factors such as"
" :ref:`Number of bytes in a tuple <limitations_bytes_in_tuple>`, not by "
"the index support."
msgstr ""
"Если поле в кортеже может содержать миллион байтов, то индекс-ключ может "
"содержать миллион байтов, поэтому максимальное количество определяется "
"такими факторами, как :ref:`количество байтов в кортеже "
"<limitations_bytes_in_tuple>`, а не параметрами индекса."

#: ../doc/book/box/limitations.rst:54
msgid "**Number of spaces**"
msgstr "**Количество спейсов**"

#: ../doc/book/box/limitations.rst:56
msgid ""
"The theoretical maximum is 2147483647 (``box.schema.SPACE_MAX``) but the "
"practical maximum is around 65,000."
msgstr ""
"Теоретически максимальное количество составляет 2 147 483 647 "
"(``box.schema.SPACE_MAX``), но практически максимальное количество -- "
"около 65 000."

#: ../doc/book/box/limitations.rst:61
msgid "**Number of connections**"
msgstr "**Количество соединений**"

#: ../doc/book/box/limitations.rst:63
msgid ""
"The practical limit is the number of file descriptors that one can set "
"with the operating system."
msgstr ""
"Практически пределом является количество файловых дескрипторов, которые "
"можно определить с операционной системой."

#: ../doc/book/box/limitations.rst:68
msgid "**Space size**"
msgstr "**Размер спейса**"

#: ../doc/book/box/limitations.rst:70
msgid ""
"The total maximum size for all spaces is in effect set by "
":ref:`memtx_memory <cfg_storage-memtx_memory>`, which in turn is limited "
"by the total available memory."
msgstr ""
"Итоговый максимальный размер всех спейсов фактически определяется в "
":ref:`memtx_memory <cfg_storage-memtx_memory>`, который в свою очередь "
"ограничен общим размером свободной памяти."

#: ../doc/book/box/limitations.rst:76
msgid "**Update operations count**"
msgstr "**Число операций обновления**"

#: ../doc/book/box/limitations.rst:78
msgid ""
"The maximum number of operations per tuple that can be in a single update"
" is 4000 (``BOX_UPDATE_OP_CNT_MAX``)."
msgstr ""
"Максимальное количество операций, возможное в рамках одного обновления "
"(для одного тапла), составляет 4000 (``BOX_UPDATE_OP_CNT_MAX``)."

#: ../doc/book/box/limitations.rst:83
msgid "**Number of users and roles**"
msgstr "**Количество пользователей и ролей**"

#: ../doc/book/box/limitations.rst:85
msgid "32 (``BOX_USER_MAX``)."
msgstr "32 (``BOX_USER_MAX``)."

#: ../doc/book/box/limitations.rst:89
msgid "**Length of an index name or space name or user name**"
msgstr "**Длина имени индекса, имени спейса или имени пользователя**"

#: ../doc/book/box/limitations.rst:91
msgid "65000 (``box.schema.NAME_MAX``)."
msgstr "65000 (``box.schema.NAME_MAX``)."

#: ../doc/book/box/limitations.rst:95
msgid "**Number of replicas in a replica set**"
msgstr "**Количество реплик в наборе реплик**"

#: ../doc/book/box/limitations.rst:97
msgid "32 (``vclock.VCLOCK_MAX``)."
msgstr "32 (``vclock.VCLOCK_MAX``)."

#: ../doc/book/box/triggers.rst:6
msgid "Triggers"
msgstr "Триггеры"

#: ../doc/book/box/triggers.rst:8
msgid ""
"**Triggers**, also known as **callbacks**, are functions which the server"
" executes when certain events happen."
msgstr ""
"**Триггеры**, которые также называют **обратными вызовами**, представляют"
" собой функции, которые выполняет сервер при наступлении определенных "
"событий."

#: ../doc/book/box/triggers.rst:11
#, fuzzy
msgid "There are six types of triggers in Tarantool:"
msgstr "В Tarantool'е есть четыре типа триггеров:"

#: ../doc/book/box/triggers.rst:13
msgid ""
":ref:`connection triggers <box_session-on_connect>`, which are executed "
"when a session begins or ends,"
msgstr ""
":ref:`триггеры для обработки соединений <box_session-on_connect>`, "
"которые выполняются, когда начинается или заканчивается сессия,"

#: ../doc/book/box/triggers.rst:16
msgid ""
":ref:`authentication triggers <box_session-on_auth>`, which are executed "
"during authentication,"
msgstr ""
":ref:`триггеры для обработки аутентификации <box_session-on_auth>`, "
"которые выполняются при аутентификации,"

#: ../doc/book/box/triggers.rst:19
#, fuzzy
msgid ""
":ref:`replace triggers <box_space-on_replace>`, which are for database "
"events,"
msgstr ""
":ref:`триггеры для обработки замены <box_space-on_replace>`, которые "
"предназначены для событий в базе данных, и"

#: ../doc/book/box/triggers.rst:22
#, fuzzy
msgid ""
":ref:`transaction triggers <box-on_commit>`, which are executed during "
"commit or rollback,"
msgstr ""
":ref:`триггеры для обработки транзакций <box-on_commit>`, которые "
"выполняются во время коммита или отката."

#: ../doc/book/box/triggers.rst:25
#, fuzzy
msgid ""
":ref:`server triggers <box_ctl-on_schema_init>`, which are executed when "
"the server starts or stops."
msgstr ""
":ref:`триггеры для обработки соединений <box_session-on_connect>`, "
"которые выполняются, когда начинается или заканчивается сессия,"

#: ../doc/book/box/triggers.rst:28
#, fuzzy
msgid ""
":ref:`member triggers <swim-on_member_event>`, which are executed when a "
"SWIM member is updated."
msgstr ""
":ref:`триггеры для обработки соединений <box_session-on_connect>`, "
"которые выполняются, когда начинается или заканчивается сессия,"

#: ../doc/book/box/triggers.rst:31
msgid "All triggers have the following characteristics:"
msgstr "У всех триггеров есть следующие особенности:"

#: ../doc/book/box/triggers.rst:33
#, fuzzy
msgid ""
"Triggers associate a function with an event. The request to \"define a "
"trigger\" implies passing the trigger's function to one of the "
"\"on_event()\" functions:"
msgstr ""
"Триггеры связывают функцию с событием. Запрос \"определить триггер\" "
"подразумевает передачу функции с триггером в одну из функций обработки "
"событий \"on_event()\":"

#: ../doc/book/box/triggers.rst:37
#, fuzzy
msgid ""
":ref:`box.session.on_connect() <box_session-on_connect>` and "
":ref:`box.session.on_disconnect() <box_session-on_disconnect>`, or"
msgstr ":ref:`box.session.on_disconnect() <box_session-on_disconnect>`, or"

#: ../doc/book/box/triggers.rst:38
#, fuzzy
msgid ":ref:`box.session.on_auth() <box_session-on_auth>`, or"
msgstr ":ref:`box.session.on_auth() <box_session-on_auth>`,"

#: ../doc/book/box/triggers.rst:39
#, fuzzy
msgid ""
":ref:`space_object:on_replace() <box_space-on_replace>` and "
":ref:`space_object:before_replace() <box_space-before_replace>`, or"
msgstr ""
":ref:`space_object:on_replace() <box_space-on_replace>` (после замены), "
":ref:`space_object:before_replace() <box_space-before_replace>` (перед "
"заменой),  :ref:`box.on_commit() <box-on_commit>` (при коммите) и "
":ref:`box.on_rollback() <box-on_rollback>` (при откате)."

#: ../doc/book/box/triggers.rst:40
#, fuzzy
msgid ""
":ref:`box.on_commit() <box-on_commit>` and :ref:`box.on_rollback() <box-"
"on_rollback>`, or"
msgstr ":ref:`box.on_rollback() <box-on_rollback>`"

#: ../doc/book/box/triggers.rst:41
msgid ""
":ref:`box.ctl.on_schema_init() <box_ctl-on_schema_init>` and "
":ref:`box.ctl.on_shutdown() <box_ctl-on_shutdown>`, or"
msgstr ""

#: ../doc/book/box/triggers.rst:42
#, fuzzy
msgid ":ref:`swim_object:on_member_event() <swim-on_member_event>`."
msgstr ":ref:`space_object:on_replace() <box_space-on_replace>`"

#: ../doc/book/box/triggers.rst:44
msgid ""
"Triggers are defined only by the :ref:`'admin' user <authentication-"
"owners_privileges>`."
msgstr ""
"Только :ref:`пользователь 'admin' <authentication-owners_privileges>` "
"определяет триггеры."

#: ../doc/book/box/triggers.rst:46
msgid ""
"Triggers are stored in the Tarantool instance's memory, not in the "
"database. Therefore triggers disappear when the instance is shut down. To"
" make them permanent, put function definitions and trigger settings into "
"Tarantool's :ref:`initialization script <index-init_label>`."
msgstr ""
"Триггеры хранятся в памяти экземпляра Tarantool'а, а не в базе данных. "
"Поэтому триггеры пропадают, когда экземпляр отключают. Чтобы сохранить "
"их, поместите определения функции и настройки триггера в :ref:`скрипт "
"инициализации <index-init_label>` Tarantool'а."

#: ../doc/book/box/triggers.rst:51
msgid ""
"Triggers have low overhead. If a trigger is not defined, then the "
"overhead is minimal: merely a pointer dereference and check. If a trigger"
" is defined, then its overhead is equivalent to the overhead of calling a"
" function."
msgstr ""
"Триггеры не приводят к высокой затрате ресурсов. Если триггер не "
"определен, то затрата ресурсов минимальна: только разыменование указателя"
" и проверка. Если триггер определен, то затрата ресурсов аналогична "
"вызову функции."

#: ../doc/book/box/triggers.rst:55
#, fuzzy
msgid ""
"There can be multiple triggers for one event. In this case, triggers are "
"executed in the reverse order that they were defined in. (Exception: "
"member triggers are executed in the order that they appear in the member "
"list.)"
msgstr ""
"Для одного события можно определить несколько триггеров. В таком случае "
"триггеры выполняются в обратном порядке относительно того, как их "
"определили."

#: ../doc/book/box/triggers.rst:59
msgid ""
"Triggers must work within the event context. However, effects are "
"undefined if a function contains requests which normally could not occur "
"immediately after the event, but only before the return from the event. "
"For example, putting `os.exit() "
"<http://www.lua.org/manual/5.1/manual.html#pdf-os.exit>`_ or "
":ref:`box.rollback() <box-rollback>` in a trigger function would be "
"bringing in requests outside the event context."
msgstr ""
"Триггеры должны работать в контексте события. Однако результат не "
"определен, если функция содержит запросы, которые при нормальных условиях"
" не могут быть выполнены непосредственно после события, а только после "
"возврата из события. Например, если указать `os.exit() "
"<http://www.lua.org/manual/5.1/manual.html#pdf-os.exit>`_ или "
":ref:`box.rollback() <box-rollback>` в триггерной функции, запросы не "
"будут выполняться в контексте события."

#: ../doc/book/box/triggers.rst:66
msgid ""
"Triggers are replaceable. The request to \"redefine a trigger\" implies "
"passing a new trigger function and an old trigger function to one of the "
"\"on_event()\" functions."
msgstr ""
"Триггеры можно заменять. Запрос на \"замену триггера\" подразумевает "
"передачу новой триггерной функции и старой триггерной функции в одну из "
"функций обработки событий \"on_event()\"."

#: ../doc/book/box/triggers.rst:70
msgid ""
"The \"on_event()\" functions all have parameters which are function "
"pointers, and they all return function pointers. Remember that a Lua "
"function definition such as \"function f() x = x + 1 end\" is the same as"
" \"f = function () x = x + 1 end\" -- in both cases ``f`` gets a function"
" pointer. And \"trigger = box.session.on_connect(f)\" is the same as "
"\"trigger = box.session.on_connect(function () x = x + 1 end)\" -- in "
"both cases ``trigger`` gets the function pointer which was passed."
msgstr ""
"Во всех функциях обработки событий \"on_event()\" есть параметры, которые"
" представляют собой указатели функции, и все они возвращают указатели "
"функции. Следует запомнить, что определение Lua-функции, например, "
"\"function f() x = x + 1 end\" совпадает с \"f = function () x = x + 1 "
"end\" -- в обоих случаях ``f`` получит указатель функции. А \"trigger = "
"box.session.on_connect(f)\" -- это то же самое, что \"trigger = "
"box.session.on_connect(function () x = x + 1 end)\" -- в обоих случаях "
"``trigger`` получит переданный указатель функции."

#: ../doc/book/box/triggers.rst:78
msgid "To get a list of triggers, you can use:"
msgstr "Чтобы получить список триггеров, можно использовать следующее:"

#: ../doc/book/box/triggers.rst:80
#, fuzzy
msgid ""
"box.session.on_connect() – with no arguments – to return a table of all "
"connect-trigger functions;"
msgstr ""
"on_connect() – без аргументов – чтобы вернуть таблицу со всеми "
"триггерными функциями для обработки соединений;"

#: ../doc/book/box/triggers.rst:81
#, fuzzy
msgid "box.session.on_auth() to return all authentication-trigger functions;"
msgstr ""
"on_auth(), чтобы вернуть все триггерные функции для обработки "
"аутентификации;"

#: ../doc/book/box/triggers.rst:82
#, fuzzy
msgid "box.session.on_disconnect() to return all disconnect-trigger functions;"
msgstr ""
"on_disconnect(), чтобы вернуть все триггерные функции для обработки "
"отключений;"

#: ../doc/book/box/triggers.rst:83
#, fuzzy
msgid ""
"space_object:on_replace() to return all replace-trigger functions made "
"for on_replace()."
msgstr ""
"on_replace(), чтобы вернуть все триггерные функции для обработки замены, "
"сделанные для on_replace();"

#: ../doc/book/box/triggers.rst:84
#, fuzzy
msgid ""
"space_object:before_replace() to return all replace-trigger functions "
"made for before_replace()."
msgstr ""
"before_replace(), чтобы вернуть все триггерные функции для обработки "
"замены, сделанные для before_replace()."

#: ../doc/book/box/triggers.rst:85
#, fuzzy
msgid ""
"box.ctl.on_shutdown() to return all shutdown-trigger functions made for "
"on_shutdown()."
msgstr ""
"on_replace(), чтобы вернуть все триггерные функции для обработки замены, "
"сделанные для on_replace();"

#: ../doc/book/box/triggers.rst:86
#, fuzzy
msgid ""
"box.ctl.on_schema_init() to return all initialization-trigger functions "
"made for on_schema_init()."
msgstr ""
"on_replace(), чтобы вернуть все триггерные функции для обработки замены, "
"сделанные для on_replace();"

#: ../doc/book/box/triggers.rst:87
#, fuzzy
msgid ""
"swim_object:on_member_event() to return all member triggers made for "
"on_member_event()."
msgstr ""
"on_replace(), чтобы вернуть все триггерные функции для обработки замены, "
"сделанные для on_replace();"

#: ../doc/book/box/triggers.rst:91
msgid "Here we log connect and disconnect events into Tarantool server log."
msgstr ""
"Здесь мы записываем события подключения и отключения в журнал на сервере "
"Tarantool'а."

#: ../doc/book/box/triggers.rst:93
#, fuzzy
msgid ""
"log = require('log')\n"
"\n"
"function on_connect_impl()\n"
"  log.info(\"connected \"..box.session.peer()..\", sid "
"\"..box.session.id())\n"
"end\n"
"\n"
"function on_disconnect_impl()\n"
"  log.info(\"disconnected, sid \"..box.session.id())\n"
"end\n"
"\n"
"function on_auth_impl(user)\n"
"  log.info(\"authenticated sid \"..box.session.id()..\" as \"..user)\n"
"end\"\n"
"\n"
"function on_connect() pcall(on_connect_impl) end\n"
"function on_disconnect() pcall(on_disconnect_impl) end\n"
"function on_auth(user) pcall(on_auth_impl, user) end\n"
"\n"
"box.session.on_connect(on_connect)\n"
"box.session.on_disconnect(on_disconnect)\n"
"box.session.on_auth(on_auth)"
msgstr ""
"log = require('log')\n"
"\n"
"function on_connect_impl()\n"
"  log.info(\"connected \"..box.session.peer()..\", sid "
"\"..box.session.id())\n"
"end\n"
"\n"
"function on_disconnect_impl()\n"
"  log.info(\"disconnected, sid \"..box.session.id())\n"
"end\n"
"\n"
"function on_auth_impl(user)\n"
"  log.info(\"authenticated sid \"..box.session.id()..\" as \"..user)\n"
"end\n"
"\n"
"function on_connect() pcall(on_connect_impl) end\n"
"function on_disconnect() pcall(on_disconnect_impl) end\n"
"function on_auth(user) pcall(on_auth_impl, user) end\n"
"\n"
"box.session.on_connect(on_connect)\n"
"box.session.on_disconnect(on_disconnect)\n"
"box.session.on_auth(on_auth)"

#: ../doc/book/cartridge/cartridge_admin.rst:5
msgid "Tarantool Cartridge administrator's guide"
msgstr "Руководство администратора по Tarantool Cartridge"

#: ../doc/book/cartridge/cartridge_admin.rst:7
msgid ""
"This guide explains how to deploy and manage a Tarantool cluster with "
"Tarantool Cartridge."
msgstr ""
"В данном руководстве рассматривается развертывание и управление кластером"
" Tarantool'а с помощью Tarantool Cartridge."

#: ../doc/book/cartridge/cartridge_admin.rst:12
msgid ""
"For more information on managing Tarantool instances, see the "
":ref:`Server administration <admin>` section."
msgstr ""
"Дополнительную информацию по управлению экземплярами Tarantool'а см. в "
"разделе :ref:`Администрирование серверной части <admin>`."

#: ../doc/book/cartridge/cartridge_admin.rst:15
msgid ""
"Before deploying the cluster, familiarize yourself with the notion of "
":ref:`cluster roles <cartridge-roles>` and :ref:`deploy Tarantool "
"instances <cartridge-deploy>` according to the desired cluster topology."
msgstr ""
"Перед тем, как развертывать кластер, ознакомьтесь с понятием "
":ref:`кластерных ролей <cartridge-roles>` и :ref:`разверните экземпляры "
"Tarantool'а <cartridge-deploy>` в соответствии с предполагаемой "
"топологией кластера."

#: ../doc/book/cartridge/cartridge_admin.rst:24
msgid "Deploying the cluster"
msgstr "Развертывание кластера"

#: ../doc/book/cartridge/cartridge_admin.rst:26
msgid ""
"To deploy the cluster, first, :ref:`configure <cartridge-config>` your "
"Tarantool instances according to the desired cluster topology, for "
"example:"
msgstr ""
"Чтобы развернуть кластер, сначала :ref:`настройте <cartridge-config>` все"
" экземпляры Tarantool'а в соответствии с предполагаемой топологией "
"кластера, например:"

#: ../doc/book/cartridge/cartridge_admin.rst:29
msgid ""
"my_app.router: {\"advertise_uri\": \"localhost:3301\", \"http_port\": "
"3301, \"workdir\": \"./tmp/router\"}\n"
"my_app.storage_A_master: {\"advertise_uri\": \"localhost:3302\", "
"\"http_enabled\": False, \"workdir\": \"./tmp/storage-a-master\"}\n"
"my_app.storage_A_replica: {\"advertise_uri\": \"localhost:3303\", "
"\"http_enabled\": False, \"workdir\": \"./tmp/storage-a-replica\"}\n"
"my_app.storage_B_master: {\"advertise_uri\": \"localhost:3304\", "
"\"http_enabled\": False, \"workdir\": \"./tmp/storage-b-master\"}\n"
"my_app.storage_B_replica: {\"advertise_uri\": \"localhost:3305\", "
"\"http_enabled\": False, \"workdir\": \"./tmp/storage-b-replica\"}"
msgstr ""
"my_app.router: {\"advertise_uri\": \"localhost:3301\", \"http_port\": "
"3301, \"workdir\": \"./tmp/router\"}\n"
"my_app.storage_A_master: {\"advertise_uri\": \"localhost:3302\", "
"\"http_enabled\": False, \"workdir\": \"./tmp/storage-a-master\"}\n"
"my_app.storage_A_replica: {\"advertise_uri\": \"localhost:3303\", "
"\"http_enabled\": False, \"workdir\": \"./tmp/storage-a-replica\"}\n"
"my_app.storage_B_master: {\"advertise_uri\": \"localhost:3304\", "
"\"http_enabled\": False, \"workdir\": \"./tmp/storage-b-master\"}\n"
"my_app.storage_B_replica: {\"advertise_uri\": \"localhost:3305\", "
"\"http_enabled\": False, \"workdir\": \"./tmp/storage-b-replica\"}"

#: ../doc/book/cartridge/cartridge_admin.rst:37
msgid ""
"Then :ref:`start the instances <cartridge-run>`, for example using "
"``cartridge`` CLI:"
msgstr ""
"Затем, :ref:`запустите экземпляры <cartridge-run>`, например, используя "
"CLI в ``cartridge``:"

#: ../doc/book/cartridge/cartridge_admin.rst:40
#: ../doc/book/cartridge/cartridge_dev.rst:1231
msgid "cartridge start my_app --cfg demo.yml --run_dir ./tmp/run --foreground"
msgstr "cartridge start my_app --cfg demo.yml --run_dir ./tmp/run --foreground"

#: ../doc/book/cartridge/cartridge_admin.rst:44
msgid ""
"And bootstrap the cluster. You can do this via the Web interface which is"
" available at ``http://<instance_hostname>:<instance_http_port>`` (in "
"this example, ``http://localhost:3301``)."
msgstr ""
"И загрузите кластер. Это можно сделать через веб-интерфейс, который "
"доступен по адресу "
"``http://<имя_хоста_экземпляра>:<http_порт_экземпляра>`` (в данном "
"примере: ``http://localhost:3301``)."

#: ../doc/book/cartridge/cartridge_admin.rst:49
msgid "In the web interface, do the following:"
msgstr "В веб-интерфейсе выполните следующие действия:"

#: ../doc/book/cartridge/cartridge_admin.rst:51
msgid "Depending on the authentication state:"
msgstr "В зависимости от статуса аутентификации:"

#: ../doc/book/cartridge/cartridge_admin.rst:53
msgid "If enabled (in production), enter your credentials and click **Login**:"
msgstr ""
"Если аутентификация включена (в эксплуатационной среде), введите свои "
"учетные данные и нажмите **Login** (Войти):"

#: ../doc/book/cartridge/cartridge_admin.rst:60
msgid ""
"If disabled (for easier testing), simply proceed to configuring the "
"cluster."
msgstr ""
"Если отключен (для удобства тестирования), просто переходите к настройке "
"кластера."

#: ../doc/book/cartridge/cartridge_admin.rst:63
msgid ""
"Click **Сonfigure** next to the first unconfigured server to create the "
"first replica set -- solely for the router (intended for *compute-"
"intensive* workloads)."
msgstr ""
"Нажмите **Configure** (Настроить) рядом с первым ненастроенным сервером, "
"чтобы создать первый набор реплик исключительно для роутера (для "
"обработки *ресурсоемких вычислений*)."

#: ../doc/book/cartridge/cartridge_admin.rst:70
#: ../doc/book/cartridge/cartridge_admin.rst:82
#: ../doc/book/cartridge/cartridge_admin.rst:97
#: ../doc/book/cartridge/cartridge_admin.rst:170
#: ../doc/book/cartridge/cartridge_admin.rst:470
#: ../doc/book/cartridge/cartridge_admin.rst:513
msgid "|nbsp|"
msgstr "|nbsp|"

#: ../doc/book/cartridge/cartridge_admin.rst:72
msgid ""
"In the pop-up window, check the ``vshard-router`` role -- or any custom "
"role that has ``vshard-router`` as a dependent role (in this example, "
"this is a custom role named ``app.roles.api``)."
msgstr ""
"Во всплывающем окне отметьте флажок роли ``vshard-router`` или любой "
"пользовательской роли, для которой роль ``vshard-router`` будет зависимой"
" (в данном примере это пользовательская роль под названием "
"``app.roles.api``)."

#: ../doc/book/cartridge/cartridge_admin.rst:76
msgid ""
"(Optional) Specify a display name for the replica set, for example "
"``router``."
msgstr ""
"(Необязательно) Укажите отображаемое имя для набора реплик, например "
"``router``."

#: ../doc/book/cartridge/cartridge_admin.rst:86
msgid ""
"As described in the :ref:`built-in roles section <cartridge-built-in-"
"roles>`, it is a good practice to enable workload-specific cluster roles "
"on instances running on physical servers with workload-specific hardware."
msgstr ""
"Как описано в :ref:`разделе о встроенных ролях <cartridge-built-in-"
"roles>`, рекомендуется включать кластерные роли в зависимости от рабочей "
"нагрузки на экземпляры, которые работают на физических серверах с "
"аппаратным обеспечением, предназначенным для рабочей нагрузки "
"определенного типа."

#: ../doc/book/cartridge/cartridge_admin.rst:90
msgid ""
"Click **Create replica set** and see the newly-created replica set in the"
" web interface:"
msgstr ""
"Нажмите **Create replica set** (Создать набор реплик), и созданный набор "
"реплик отобразится в веб-интерфейсе"

#: ../doc/book/cartridge/cartridge_admin.rst:101
msgid ""
"Be careful: after an instance joins a replica set, you **CAN NOT** revert"
" this or make the instance join any other replica set."
msgstr ""
"Обратите внимание: после того, как экземпляр подключится к набору реплик,"
" **НЕВОЗМОЖНО** это отменить или переподключить его к другому набору "
"реплик."

#: ../doc/book/cartridge/cartridge_admin.rst:104
msgid ""
"Create another replica set -- for a master storage node (intended for "
"*transaction-intensive* workloads)."
msgstr ""
"Создайте новый набор реплик для мастер-узлов хранения данных (для "
"обработки *большого количества транзакций*)."

#: ../doc/book/cartridge/cartridge_admin.rst:107
msgid ""
"Check the ``vshard-storage`` role -- or any custom role that has "
"``vshard-storage`` as a dependent role (in this example, this is a custom"
" role named ``app.roles.storage``)."
msgstr ""
"Отметьте флажок роли ``vshard-storage`` или любой пользовательской роли, "
"для которой роль ``vshard-storage`` будет зависимой (в данном примере это"
" пользовательская роль под названием ``app.roles.storage``)."

#: ../doc/book/cartridge/cartridge_admin.rst:111
msgid ""
"(Optional) Check a specific group, for example ``hot``. Replica sets with"
" ``vshard-storage`` roles can belong to different groups. In our example,"
" these are ``hot`` or ``cold`` groups meant to process hot and cold data "
"independently. These groups are specified in the cluster's "
":ref:`configuration file <cartridge-vshard-groups>`; by default, a "
"cluster has no groups."
msgstr ""
"(Необязательно) Задайте определенную группу, например ``hot`` (горячие). "
"Наборы реплик с ролями ``vshard-storage`` могут относиться к различным "
"группам. В нашем примере группы ``hot`` и ``cold`` предназначены для "
"независимой обработки горячих и холодных данных соответственно. Эти "
"группы указаны в  :ref:`конфигурационном файле <cartridge-vshard-groups>`"
" кластера. По умолчанию, кластер не входит ни в одну группу."

#: ../doc/book/cartridge/cartridge_admin.rst:118
msgid ""
"(Optional) Specify a display name for the replica set, for example ``hot-"
"storage``."
msgstr ""
"(Необязательно) Укажите отображаемое имя для набора реплик, например "
"``hot-storage``."

#: ../doc/book/cartridge/cartridge_admin.rst:120
msgid "Click **Create replica set**."
msgstr "Нажмите **Create replica set** (Создать набор реплик)."

#: ../doc/book/cartridge/cartridge_admin.rst:126
msgid ""
"(Optional) If required by topology, populate the second replica set with "
"more storage nodes:"
msgstr ""
"(Необязательно) Если этого требует топология, добавьте во второй набор "
"реплик дополнительные хранилища:"

#: ../doc/book/cartridge/cartridge_admin.rst:129
msgid ""
"Click **Configure** next to another unconfigured server dedicated for "
"*transaction-intensive* workloads."
msgstr ""
"Нажмите **Configure** (Настроить) рядом с другим ненастроенным сервером, "
"который выделен для рабочей нагрузки с *большим количеством транзакций*."

#: ../doc/book/cartridge/cartridge_admin.rst:132
msgid "Click **Join Replica Set** tab."
msgstr "Нажмите на вкладку **Join Replica Set** (Присоединиться к набору реплик)."

#: ../doc/book/cartridge/cartridge_admin.rst:134
msgid ""
"Select the second replica set, and click **Join replica set** to add the "
"server to it."
msgstr ""
"Выберите второй набор реплик и нажмите **Join replica set** "
"(Присоединиться к набору реплик), чтобы добавить к нему сервер."

#: ../doc/book/cartridge/cartridge_admin.rst:141
msgid "Depending on cluster topology:"
msgstr "В зависимости от топологии кластера:"

#: ../doc/book/cartridge/cartridge_admin.rst:143
msgid "add more instances to the first or second replica sets, or"
msgstr ""
"добавьте дополнительные экземпляры к первому или второму набору реплик, "
"или же"

#: ../doc/book/cartridge/cartridge_admin.rst:144
msgid ""
"create more replica sets and populate them with instances meant to handle"
" a specific type of workload (compute or transactions)."
msgstr ""
"создайте дополнительные наборы реплик и добавьте в них экземпляры для "
"обработки определенной рабочей нагрузки (вычисления или транзакции)."

#: ../doc/book/cartridge/cartridge_admin.rst:153
msgid ""
"(Optional) By default, all new ``vshard-storage`` replica sets get a "
"weight of ``1`` before the ``vshard`` bootstrap in the next step."
msgstr ""
"(Необязательно) По умолчанию все новые наборы реплик ``vshard-storage`` "
"получают вес, равный ``1``, до загрузки ``vshard`` в следующем шаге."

#: ../doc/book/cartridge/cartridge_admin.rst:158
msgid ""
"In case you add a new replica set after ``vshard`` bootstrap, as "
"described in the :ref:`topology change section <cartridge-change-cluster-"
"topology>`, it will get a weight of 0 by default."
msgstr ""
"Если вы добавите новый набор реплик после начальной загрузки ``vshard``, "
"как описано в :ref:`разделе об изменении топологии <cartridge-change-"
"cluster-topology>`, он по умолчанию получит вес 0."

#: ../doc/book/cartridge/cartridge_admin.rst:162
msgid ""
"To make different replica sets store different numbers of buckets, click "
"**Edit** next to a replica set, change its default weight, and click "
"**Save**:"
msgstr ""
"Чтобы разные наборы реплик хранили разное количество сегментов, нажмите "
"**Edit** (Изменить) рядом с набором реплик, измените значение веса по "
"умолчанию и нажмите **Save** (Сохранить):"

#: ../doc/book/cartridge/cartridge_admin.rst:172
msgid ""
"For more information on buckets and replica set's weights, see the "
":ref:`vshard module documentation <vshard>`."
msgstr ""
"Для получения дополнительной информации о сегментах и весах набора реплик"
" см. :ref:`документацию по модулю vshard <vshard>`."

#: ../doc/book/cartridge/cartridge_admin.rst:175
msgid ""
"Bootstrap ``vshard`` by clicking the corresponding button, or by saying "
"``cartridge.admin.boostrap_vshard()`` over the administrative console."
msgstr ""
"Загрузите ``vshard``, нажав соответствующую кнопку или же выполнив "
"команду ``cartridge.admin.boostrap_vshard()`` в административной консоли."

#: ../doc/book/cartridge/cartridge_admin.rst:178
msgid "This command creates virtual buckets and distributes them among storages."
msgstr "Эта команда создает виртуальные сегменты и распределяет их по хранилищам."

#: ../doc/book/cartridge/cartridge_admin.rst:180
msgid "From now on, all cluster configuration can be done via the web interface."
msgstr ""
"С этого момента всю настройку кластера можно выполнять через "
"веб-интерфейс."

#: ../doc/book/cartridge/cartridge_admin.rst:186
msgid "Updating the configuration"
msgstr "Обновление конфигурации"

#: ../doc/book/cartridge/cartridge_admin.rst:188
msgid ""
"Cluster configuration is specified in a YAML configuration file. This "
"file includes cluster topology and role descriptions."
msgstr ""
"Конфигурация кластера задается в конфигурационном файле формата YAML. "
"Этот файл включает в себя топологию кластера и описания ролей."

#: ../doc/book/cartridge/cartridge_admin.rst:191
msgid ""
"All instances in Tarantool cluster have the same configuration. To this "
"end, every instance stores a copy of the configuration file, and the "
"cluster keeps these copies in sync: as you submit updated configuration "
"in the Web interface, the cluster validates it (and rejects inappropriate"
" changes) and distributes **automatically** across the cluster."
msgstr ""
"У всех экземпляров в кластере Tarantool'а одинаковые настройки. Для этого"
" каждый экземпляр в кластере хранит копию конфигурационного файла, а "
"кластер синхронизирует эти копии: как только вы подтверждаете обновление "
"конфигурации в веб-интерфейсе, кластер валидирует ее (и отклоняет "
"неприемлемые изменения) и передает ее *автоматически* по всему кластеру."

#: ../doc/book/cartridge/cartridge_admin.rst:197
msgid "To update the configuration:"
msgstr "Чтобы обновить конфигурацию:"

#: ../doc/book/cartridge/cartridge_admin.rst:199
msgid "Click **Configuration files** tab."
msgstr "Нажмите на вкладку **Configuration files** (Конфигурационные файлы)."

#: ../doc/book/cartridge/cartridge_admin.rst:201
msgid ""
"(Optional) Click **Downloaded** to get hold of the current configuration "
"file."
msgstr ""
"(Необязательно) Нажмите **Downloaded** (Загруженные), чтобы получить "
"текущую версию конфигурационного файла."

#: ../doc/book/cartridge/cartridge_admin.rst:203
msgid "Update the configuration file."
msgstr "Обновите конфигурационный файл."

#: ../doc/book/cartridge/cartridge_admin.rst:205
msgid ""
"You can add/change/remove any sections except system ones: ``topology``, "
"``vshard``, and ``vshard_groups``."
msgstr ""
"Можно добавлять/изменять/удалять любы разделы, кроме системных: "
"``topology``, ``vshard`` и ``vshard_groups``."

#: ../doc/book/cartridge/cartridge_admin.rst:208
msgid "To remove a section, simply remove it from the configuration file."
msgstr "Чтобы удалить раздел, просто удалите его из конфигурационного файла."

#: ../doc/book/cartridge/cartridge_admin.rst:210
msgid ""
"Compress the configuration file as a ``.zip`` archive and click **Upload "
"configuration** button to upload it."
msgstr ""
"Создайте сжатую копию конфигурационного файла в виде архива в формате "
"``.zip`` и нажмите кнопку **Upload configuration** (Загрузить "
"конфигурацию), чтобы загрузить ее."

#: ../doc/book/cartridge/cartridge_admin.rst:213
msgid ""
"You will see a message in the lower part of the screen saying whether "
"configuration was uploaded successfully, and an error description if the "
"new configuration was not applied."
msgstr ""
"В нижней части экрана вы увидите сообщение об успешной загрузке "
"конфигурации или ошибку, если новые настройки не были применены."

#: ../doc/book/cartridge/cartridge_admin.rst:221
msgid "Managing the cluster"
msgstr "Управление кластером"

#: ../doc/book/cartridge/cartridge_admin.rst:223
msgid "This chapter explains how to:"
msgstr "В данной главе описывается, как:"

#: ../doc/book/cartridge/cartridge_admin.rst:225
msgid "change the cluster topology,"
msgstr "изменять топологию кластера,"

#: ../doc/book/cartridge/cartridge_admin.rst:226
msgid "enable automatic failover,"
msgstr "включать автоматическое восстановление после отказа,"

#: ../doc/book/cartridge/cartridge_admin.rst:227
msgid "switch the replica set's master manually,"
msgstr "вручную менять мастера в наборе реплик,"

#: ../doc/book/cartridge/cartridge_admin.rst:228
msgid "deactivate replica sets, and"
msgstr "отключать наборы реплик,"

#: ../doc/book/cartridge/cartridge_admin.rst:229
msgid "expel instances."
msgstr "исключать экземпляры."

#: ../doc/book/cartridge/cartridge_admin.rst:235
msgid "Changing the cluster topology"
msgstr "Изменение топологии кластера"

#: ../doc/book/cartridge/cartridge_admin.rst:237
msgid "Upon adding a newly deployed instance to a new or existing replica set:"
msgstr ""
"При добавлении нового развернутого экземпляра в новый или уже "
"существующий набор реплик:"

#: ../doc/book/cartridge/cartridge_admin.rst:239
#, fuzzy
msgid ""
"The cluster validates the configuration update by checking if the new "
"instance is available using the `membership module "
"<https://www.tarantool.io/en/doc/2.2/reference/reference_rock/membership/>`_."
msgstr ""
"Кластер валидирует обновление конфигурации, проверяя доступность нового "
"экземпляра с помощью модуля `membership "
"<https://www.tarantool.io/en/doc/1.10/reference/reference_rock/membership/>`_."

#: ../doc/book/cartridge/cartridge_admin.rst:244
msgid ""
"The ``membership`` module works over the UDP protocol and can operate "
"before the ``box.cfg`` function is called."
msgstr ""
"Модуль ``membership`` работает по протоколу UDP и может производить "
"операции до вызова функции ``box.cfg``."

#: ../doc/book/cartridge/cartridge_admin.rst:247
msgid "All the nodes in the cluster must be healthy for validation success."
msgstr "Все узлы в кластере должны быть рабочими, чтобы валидация была пройдена."

#: ../doc/book/cartridge/cartridge_admin.rst:249
msgid ""
"The new instance waits until another instance in the cluster receives the"
" configuration update and discovers it, again, using the ``membership`` "
"module. On this step, the new instance does not have a UUID yet."
msgstr ""
"Новый экземпляр ожидает, пока другой экземпляр в кластере не получит "
"обновление конфигурации (оповещение реализовано с помощью того же модуля "
"``membership``). На этом шаге у нового экземпляра еще нет своего UUID."

#: ../doc/book/cartridge/cartridge_admin.rst:253
msgid ""
"Once the instance realizes its presence is known to the cluster, it calls"
" the ``box.cfg`` function and starts living its life."
msgstr ""
"Как только новый экземпляр понимает, что кластер знает о нем, экземпляр "
"вызывает функцию ``box.cfg`` и начинает работу."

#: ../doc/book/cartridge/cartridge_admin.rst:256
msgid ""
"For more information, see the :ref:`box.cfg submodule reference "
"<box_introspection-box_cfg>`_."
msgstr ""
"Дополнительную информацию см. в :ref:`справочнике по вложенному модулю "
"box.cfg <box_introspection-box_cfg>`_."

#: ../doc/book/cartridge/cartridge_admin.rst:259
msgid ""
"An optimal strategy for connecting new nodes to the cluster is to deploy "
"a new zero-weight replica set instance by instance, and then increase the"
" weight. Once the weight is updated and all cluster nodes are notified of"
" the configuration change, buckets start migrating to new nodes."
msgstr ""
"Оптимальная стратегия подключения новых узлов к кластеру состоит в том, "
"чтобы развертывать новые экземпляры в наборе реплик с нулевым весом для "
"каждого экземпляра, а затем увеличивать вес. Как только вес обновится и "
"все узлы кластера получат уведомление об изменении конфигурации, сегменты"
" начинают мигрировать на новые узлы."

#: ../doc/book/cartridge/cartridge_admin.rst:264
msgid "To populate the cluster with more nodes, do the following:"
msgstr "Чтобы добавить в кластер новые узлы, выполните следующие действия:"

#: ../doc/book/cartridge/cartridge_admin.rst:266
msgid ""
"Deploy new Tarantool instances as described in the :ref:`deployment "
"section <cartridge-deploy>`."
msgstr ""
"Разверните новые экземпляры Tarantool, как описано в :ref:`разделе по "
"развертыванию <cartridge-deploy>`."

#: ../doc/book/cartridge/cartridge_admin.rst:269
msgid ""
"If new nodes do not appear in the Web interface, click **Probe server** "
"and specify their URIs manually."
msgstr ""
"Если новые узлы не появились в веб-интерфейсе, нажмите **Probe server** "
"(Найти сервер) и укажите их URI вручную."

#: ../doc/book/cartridge/cartridge_admin.rst:276
msgid "If a node is accessible, it will appear in the list."
msgstr "Если узел доступен, он появится в списке."

#: ../doc/book/cartridge/cartridge_admin.rst:278
msgid "In the Web interface:"
msgstr "В веб-интерфейсе:"

#: ../doc/book/cartridge/cartridge_admin.rst:280
msgid ""
"Create a new replica set with one of the new instances: click "
"**Configure** next to an unconfigured server, check the necessary roles, "
"and click **Create replica set**:"
msgstr ""
"Создайте новый набор реплик с одним из новых экземпляров: нажмите "
"**Configure** (Настроить) рядом с ненастроенным сервером, отметьте "
"флажками необходимые роли и нажмите **Create replica set** (Создать набор"
" реплик):"

#: ../doc/book/cartridge/cartridge_admin.rst:286
msgid ""
"In case you are adding a new ``vshard-storage`` instance, remember that "
"all such instances get a ``0`` weight by default after the ``vshard`` "
"bootstrap which happened during the initial cluster deployment."
msgstr ""
"Если вы добавляете экземпляр ``vshard-storage``, следует помнить, что вес"
" всех таких экземпляров по умолчанию становится равным ``0`` после "
"начальной загрузки ``vshard``, которая происходит во время "
"первоначального развертывания кластера."

#: ../doc/book/cartridge/cartridge_admin.rst:294
msgid ""
"Or add the instances to existing replica sets: click **Configure** next "
"to an unconfigured server, click **Join replica set** tab, select a "
"replica set, and click **Join replica set**."
msgstr ""
"Или добавьте дополнительные экземпляры к существующему набору реплик: "
"нажмите **Configure** (Настроить) рядом с ненастроенным сервером, нажмите"
" на вкладку **Join replica set** (Присоединиться к набору реплик), "
"выберите набор реплик и нажмите **Join replica set**."

#: ../doc/book/cartridge/cartridge_admin.rst:298
msgid ""
"If necessary, repeat this for more instances to reach the desired "
"redundancy level."
msgstr ""
"При необходимости повторите действия для других экземпляров, чтобы "
"достичь необходимого уровня резервирования."

#: ../doc/book/cartridge/cartridge_admin.rst:301
msgid ""
"In case you are deploying a new ``vshard-storage`` replica set, populate "
"it with data when you are ready: click **Edit** next to the replica set "
"in question, increase its weight, and click **Save** to start :ref:`data "
"rebalancing <cartridge-rebalance-data>`."
msgstr ""
"При развертывании нового набора реплик ``vshard-storage`` заполните "
"необходимую информацию: нажмите **Edit** (Изменить) рядом с необходимым "
"набором реплик, увеличьте его вес и нажмите **Save** (Сохранить), чтобы "
"начать :ref:`балансировку данных <cartridge-rebalance-data>`."

#: ../doc/book/cartridge/cartridge_admin.rst:306
msgid ""
"As an alternative to the web interface, you can view and change cluster "
"topology via GraphQL. The cluster's endpoint for serving GraphQL queries "
"is ``/admin/api``. You can use any third-party GraphQL client like "
"`GraphiQL <https://github.com/graphql/graphiql>`_ or `Altair "
"<https://altair.sirmuel.design>`_."
msgstr ""
"Вместо веб-интерфейса можно использовать GraphQL для просмотра и "
"изменения топологии кластера. Конечная точка кластера для выполнения "
"запросов GraphQL -- ``/admin/api``. Можно пользоваться любыми сторонними "
"клиентами GraphQL, такими как `GraphiQL "
"<https://github.com/graphql/graphiql>`_ или `Altair "
"<https://altair.sirmuel.design>`_."

#: ../doc/book/cartridge/cartridge_admin.rst:312
msgid "Examples:"
msgstr "Примеры:"

#: ../doc/book/cartridge/cartridge_admin.rst:314
msgid "listing all servers in the cluster:"
msgstr "вывод списка всех серверов в кластере:"

#: ../doc/book/cartridge/cartridge_admin.rst:316
msgid ""
"query {\n"
"    servers { alias uri uuid }\n"
"}"
msgstr ""
"query {\n"
"    servers { alias uri uuid }\n"
"}"

#: ../doc/book/cartridge/cartridge_admin.rst:322
msgid "listing all replica sets with their servers:"
msgstr "вывод списка всех наборов реплик с серверами:"

#: ../doc/book/cartridge/cartridge_admin.rst:324
msgid ""
"query {\n"
"    replicasets {\n"
"        uuid\n"
"        roles\n"
"        servers { uri uuid }\n"
"    }\n"
"}"
msgstr ""
"query {\n"
"    replicasets {\n"
"        uuid\n"
"        roles\n"
"        servers { uri uuid }\n"
"    }\n"
"}"

#: ../doc/book/cartridge/cartridge_admin.rst:334
msgid "joining a server to a new replica set with a storage role enabled:"
msgstr "подключение сервера к новому набору реплик с включенной ролью хранилища:"

#: ../doc/book/cartridge/cartridge_admin.rst:336
msgid ""
"mutation {\n"
"    join_server(\n"
"        uri: \"localhost:33003\"\n"
"        roles: [\"vshard-storage\"]\n"
"    )\n"
"}"
msgstr ""
"mutation {\n"
"    join_server(\n"
"        uri: \"localhost:33003\"\n"
"        roles: [\"vshard-storage\"]\n"
"    )\n"
"}"

#: ../doc/book/cartridge/cartridge_admin.rst:349
msgid "Data rebalancing"
msgstr "Балансировка данных"

#: ../doc/book/cartridge/cartridge_admin.rst:351
msgid ""
"Rebalancing (resharding) is initiated periodically and upon adding a new "
"replica set with a non-zero weight to the cluster. For more information, "
"see the :ref:`rebalancing process section <vshard-rebalancing>` of the "
"``vshard`` module documentation."
msgstr ""
"Балансировка (решардинг) запускается через определенные промежутки "
"времени и при добавлении в кластер нового набора реплик с весом, отличным"
" от нуля. Для получения дополнительной информации см. :ref:`раздел по "
"балансировке <vshard-rebalancing>` в документации по модулю ``vshard``."

#: ../doc/book/cartridge/cartridge_admin.rst:356
msgid ""
"The most convenient way to trace through the process of rebalancing is to"
" monitor the number of active buckets on storage nodes. Initially, a "
"newly added replica set has 0 active buckets. After a few minutes, the "
"background rebalancing process begins to transfer buckets from other "
"replica sets to the new one. Rebalancing continues until the data is "
"distributed evenly among all replica sets."
msgstr ""
"Самый удобный способ мониторинга процесса балансировки заключается в том,"
" чтобы отслеживать количество активных сегментов на узлах хранения. "
"Сначала в новом наборе реплик 0 активных сегментов. Через некоторое время"
" фоновый процесс балансировки начинает переносить сегменты из других "
"наборов реплик в новый. Балансировка продолжается до тех пор, пока данные"
" не будут распределены равномерно по всем наборам реплик."

#: ../doc/book/cartridge/cartridge_admin.rst:362
msgid ""
"To monitor the current number of buckets, connect to any Tarantool "
"instance over the :ref:`administrative console <cartridge-manage-"
"sharding-cli>`, and say:"
msgstr ""
"Чтобы отслеживать текущее количество сегментов, подключитесь к любому "
"экземпляру Tarantool через :ref:`административную консоль <cartridge-"
"manage-sharding-cli>` и выполните команду:"

#: ../doc/book/cartridge/cartridge_admin.rst:365
msgid ""
"tarantool> vshard.storage.info().bucket\n"
"---\n"
"- receiving: 0\n"
"  active: 1000\n"
"  total: 1000\n"
"  garbage: 0\n"
"  sending: 0\n"
"..."
msgstr ""
"tarantool> vshard.storage.info().bucket\n"
"---\n"
"- receiving: 0\n"
"  active: 1000\n"
"  total: 1000\n"
"  garbage: 0\n"
"  sending: 0\n"
"..."

#: ../doc/book/cartridge/cartridge_admin.rst:376
msgid ""
"The number of buckets may be increasing or decreasing depending on "
"whether the rebalancer is migrating buckets to or from the storage node."
msgstr ""
"Количество сегментов может увеличиваться или уменьшаться в зависимости от"
" того, переносит ли балансировщик сегменты в узел хранения или из него."

#: ../doc/book/cartridge/cartridge_admin.rst:379
msgid ""
"For more information on the monitoring parameters, see the "
":ref:`monitoring storages section <cartridge-monitor-storage>`."
msgstr ""
"Для получения дополнительной информации о параметрах мониторинга см. "
":ref:`раздел по мониторингу хранилищ <cartridge-monitor-storage>`."

#: ../doc/book/cartridge/cartridge_admin.rst:386
msgid "Deactivating replica sets"
msgstr "Отключение наборов реплик"

#: ../doc/book/cartridge/cartridge_admin.rst:388
msgid ""
"To deactivate an entire replica set (e.g., to perform maintenance on it) "
"means to move all of its buckets to other sets."
msgstr ""
"Под отключением всего набора реплик (например, для технического "
"обслуживания) подразумевается перемещение всех его сегментов в другие "
"наборы реплик."

#: ../doc/book/cartridge/cartridge_admin.rst:391
msgid "To deactivate a set, do the following:"
msgstr "Чтобы отключить набор реплик, выполните следующие действия:"

#: ../doc/book/cartridge/cartridge_admin.rst:393
msgid "Click **Edit** next to the set in question."
msgstr "Нажмите **Edit** (Изменить) рядом с необходимым набором реплик."

#: ../doc/book/cartridge/cartridge_admin.rst:395
msgid "Set its weight to ``0`` and click **Save**:"
msgstr "Укажите ``0`` как значение веса и нажмите **Save** (Сохранить):"

#: ../doc/book/cartridge/cartridge_admin.rst:401
msgid ""
"Wait for the rebalancing process to finish migrating all the set's "
"buckets away. You can monitor the current bucket number as described in "
"the :ref:`data rebalancing section <cartridge-rebalance-data>`."
msgstr ""
"Подождите, пока процесс балансировки не завершит перенос всех сегментов "
"набора. Можно отслеживать текущее количество сегментов, как описано в "
":ref:`разделе по балансировке данных <cartridge-rebalance-data>`."

#: ../doc/book/cartridge/cartridge_admin.rst:409
msgid "Expelling instances"
msgstr "Исключение экземпляров"

#: ../doc/book/cartridge/cartridge_admin.rst:414
msgid ""
"Once an instance is *expelled*, it can never participate in the cluster "
"again as every instance will reject it."
msgstr ""
"После того, как экземпляр будет *исключен* из кластера, он никогда не "
"сможет снова участвовать в кластере, поскольку ни один экземпляр не будет"
" принимать его."

#: ../doc/book/cartridge/cartridge_admin.rst:417
msgid ""
"To expel an instance, click **...** next to it, then click **Expel "
"server** and **Expel**:"
msgstr ""
"Чтобы исключить экземпляр из кластера, нажмите **...** рядом с ним, затем"
" нажмите **Expel server** (Исключить сервер) и **Expel**:"

#: ../doc/book/cartridge/cartridge_admin.rst:428
msgid "Enabling automatic failover"
msgstr "Включение автоматического восстановления после отказа,"

#: ../doc/book/cartridge/cartridge_admin.rst:430
msgid ""
"In a master-replica cluster configuration with automatic failover "
"enabled, if the user-specified master of any replica set fails, the "
"cluster automatically chooses the next replica from the priority list and"
" grants it the active master role (read/write). When the failed master "
"comes back online, its role is restored and the active master, again, "
"becomes a replica (read-only). This works for any roles."
msgstr ""
"В конфигурации кластера мастер-реплика с включенным автоматическим "
"восстановлением после отказа, если происходит отказ указанного "
"пользователем мастера из любого набора реплик, кластер автоматически "
"выбирает следующую реплику из списка приоритетов и назначает ей роль "
"активного мастера (чтение/запись). Когда вышедший из строя мастер "
"возвращается к работе, его роль восстанавливается, и активный мастер "
"снова становится репликой (только для чтения). Это работает для всех "
"ролей."

#: ../doc/book/cartridge/cartridge_admin.rst:437
msgid "To set the priority in a replica set:"
msgstr "Чтобы задать приоритет в наборе реплик:"

#: ../doc/book/cartridge/cartridge_admin.rst:439
msgid "Click **Edit** next to the replica set in question."
msgstr "Нажмите **Edit** (Изменить) рядом с необходимым набором реплик."

#: ../doc/book/cartridge/cartridge_admin.rst:441
msgid ""
"Scroll to the bottom of the **Edit replica set** box to see the list of "
"servers."
msgstr ""
"Выполните прокрутку в окне **Edit replica set** (Изменить набор реплик), "
"чтобы увидеть весь список серверов."

#: ../doc/book/cartridge/cartridge_admin.rst:444
msgid "Drag replicas to their place in the priority list, and click **Save**:"
msgstr ""
"Перенесите реплики на необходимые места в списке приоритета и нажмите "
"**Save** (Сохранить):"

#: ../doc/book/cartridge/cartridge_admin.rst:450
msgid "The failover is disabled by default. To enable it:"
msgstr ""
"По умолчанию, автоматическое восстановление после отказа отключено. Чтобы"
" включить его:"

#: ../doc/book/cartridge/cartridge_admin.rst:452
msgid "Click **Failover**:"
msgstr "Нажмите **Failover** (Восстановление после отказа):"

#: ../doc/book/cartridge/cartridge_admin.rst:458
msgid "In the **Failover control** box, click **Enable**:"
msgstr ""
"В окне **Failover control** (Управление восстановлением после отказа) "
"нажмите **Enable** (Включить):"

#: ../doc/book/cartridge/cartridge_admin.rst:464
msgid "The failover status will change to enabled:"
msgstr "Статус восстановления после отказа изменится на enabled (включено):"

#: ../doc/book/cartridge/cartridge_admin.rst:472
msgid "For more information, see the :ref:`replication section <replication>`."
msgstr ""
"Для получения дополнительной информации см. :ref:`раздел по репликации "
"<replication>`."

#: ../doc/book/cartridge/cartridge_admin.rst:478
msgid "Switching the replica set's master"
msgstr "Смена мастера в наборе реплик"

#: ../doc/book/cartridge/cartridge_admin.rst:480
msgid "To manually switch the master in a replica set:"
msgstr "Чтобы вручную сменить мастера в наборе реплик:"

#: ../doc/book/cartridge/cartridge_admin.rst:482
msgid "Click the **Edit** button next to the replica set in question:"
msgstr "Нажмите кнопку **Edit** (Изменить) рядом с необходимым набором реплик:"

#: ../doc/book/cartridge/cartridge_admin.rst:488
msgid ""
"Scroll to the bottom of the **Edit replica set** box to see the list of "
"servers. The server on the top is the master."
msgstr ""
"Выполните прокрутку в окне **Edit replica set** (Изменить набор реплик), "
"чтобы увидеть весь список серверов. Мастером будет верхний сервер."

#: ../doc/book/cartridge/cartridge_admin.rst:495
msgid "Drag a required server to the top position and click **Save**."
msgstr "Перенесите необходимый сервер наверх и нажмите **Save** (Сохранить)."

#: ../doc/book/cartridge/cartridge_admin.rst:497
msgid ""
"The new master will automatically enter the read/write mode, while the "
"ex-master will become read-only. This works for any roles."
msgstr ""
"Новый мастер автоматически войдет в режим для чтения и записи, а "
"предыдущий мастер будет использоваться только для чтения. Это работает "
"для всех ролей."

#: ../doc/book/cartridge/cartridge_admin.rst:504
msgid "Managing users"
msgstr "Управление пользователями"

#: ../doc/book/cartridge/cartridge_admin.rst:506
msgid ""
"On the **Users** tab, you can enable/disable authentication as well as "
"add, remove, edit, and view existing users who can access the web "
"interface."
msgstr ""
"На вкладке **Users** (Пользователи) можно включать и отключать "
"аутентификацию, а также добавлять, удалять, изменять и просматривать "
"пользователей, у которых есть доступ к веб-интерфейсу."

#: ../doc/book/cartridge/cartridge_admin.rst:515
msgid ""
"Notice that the **Users** tab is available only if authorization in the "
"web interface is :ref:`implemented <cartridge-auth-enable>`."
msgstr ""
"Обратите внимание, что вкладка **Users** (Пользователи) доступна только в"
" том случае, если в веб-интерфейсе :ref:`реализована <cartridge-auth-"
"enable>` авторизация."

#: ../doc/book/cartridge/cartridge_admin.rst:518
msgid ""
"Also, some features (like deleting users) can be disabled in the cluster "
"configuration; this is regulated by the `auth_backend_name "
"<https://www.tarantool.io/en/rocks/cluster/1.0/modules/cluster/#cfg-opts-"
"box-opts>`_ option passed to ``cartridge.cfg()``."
msgstr ""
"Кроме того, некоторые функции (например, удаление пользователей) можно "
"отключить в конфигурации кластера, что регулируется при помощи настройки "
"`auth_backend_name "
"<https://www.tarantool.io/en/rocks/cluster/1.0/modules/cluster/#cfg-opts-"
"box-opts>`_, которая передается в ``cartridge.cfg()``."

#: ../doc/book/cartridge/cartridge_admin.rst:527
msgid "Resolving conflicts"
msgstr "Устранение конфликтов"

#: ../doc/book/cartridge/cartridge_admin.rst:529
msgid ""
"Tarantool has an embedded mechanism for asynchronous replication. As a "
"consequence, records are distributed among the replicas with a delay, so "
"conflicts can arise."
msgstr ""
"В Tarantool встроен механизм асинхронной репликации. Как следствие, "
"записи распределяются между репликами с задержкой, поэтому могут "
"возникнуть конфликты."

#: ../doc/book/cartridge/cartridge_admin.rst:532
msgid ""
"To prevent conflicts, the special trigger ``space.before_replace`` is "
"used. It is executed every time before making changes to the table for "
"which it was configured. The trigger function is implemented in the Lua "
"programming language. This function takes the original and new values of "
"the tuple to be modified as its arguments. The returned value of the "
"function is used to change the result of the operation: this will be the "
"new value of the modified tuple."
msgstr ""
"Для предотвращения конфликтов используется специальный триггер "
"``space.before_replace``. Он выполняется каждый раз перед внесением "
"изменений в таблицу, для которой он был настроен. Функция триггера "
"реализована на языке программирования Lua. Эта функция принимает в "
"качестве аргументов исходные значения изменяемого кортежа и новые "
"значения. Функция возвращает значение, которое используется для изменения"
" результата операции: это будет новое значение измененного кортежа."

#: ../doc/book/cartridge/cartridge_admin.rst:539
msgid ""
"For insert operations, the old value is absent, so ``nil`` is passed as "
"the first argument."
msgstr ""
"Для операций вставки старое значение отсутствует, поэтому в качестве "
"первого аргумента передается нулевое значение ``nil``."

#: ../doc/book/cartridge/cartridge_admin.rst:542
msgid ""
"For delete operations, the new value is absent, so ``nil`` is passed as "
"the second argument. The trigger function can also return ``nil``, thus "
"turning this operation into delete."
msgstr ""
"Для операций удаления отсутствует новое значение, поэтому нулевое "
"значение ``nil`` передается в качестве второго аргумента. Функция "
"триггера также может возвращать нулевое значение ``nil``, превращая эту "
"операцию в удаление."

#: ../doc/book/cartridge/cartridge_admin.rst:546
msgid ""
"This example shows how to use the ``space.before_replace`` trigger to "
"prevent replication conflicts. Suppose we have a ``box.space.test`` table"
" that is modified in multiple replicas at the same time. We store one "
"payload field in this table. To ensure consistency, we also store the "
"last modification time in each tuple of this table and set the "
"``space.before_replace`` trigger, which gives preference to newer tuples."
" Below is the code in Lua:"
msgstr ""
"В примере ниже показано, как использовать триггер "
"``space.before_replace``, чтобы предотвратить конфликты репликации. "
"Предположим, у нас есть таблица ``box.space.test``, которая изменяется в "
"нескольких репликах одновременно. В этой таблице мы храним одно поле "
"полезной нагрузки. Чтобы обеспечить согласованность, мы также сохраняем "
"время последнего изменения в каждом кортеже этой таблицы и устанавливаем "
"триггер ``space.before_replace``, который отдает предпочтение новым "
"кортежам. Ниже приведен код на Lua:"

#: ../doc/book/cartridge/cartridge_admin.rst:553
msgid ""
"fiber = require('fiber')\n"
"-- define a function that will modify the function test_replace(tuple)\n"
"        -- add a timestamp to each tuple in the space\n"
"        tuple = box.tuple.new(tuple):update{{'!', 2, fiber.time()}}\n"
"        box.space.test:replace(tuple)\n"
"end\n"
"box.cfg{ } -- restore from the local directory\n"
"-- set the trigger to avoid conflicts\n"
"box.space.test:before_replace(function(old, new)\n"
"        if old ~= nil and new ~= nil and new[2] < old[2] then\n"
"                return old -- ignore the request\n"
"        end\n"
"        -- otherwise apply as is\n"
"end)\n"
"box.cfg{ replication = {...} } -- subscribe"
msgstr ""
"fiber = require('fiber')\n"
"-- определение функции, которая изменит функцию test_replace(tuple)\n"
"        -- добавление временной метки к каждому кортежу в спейсе\n"
"        tuple = box.tuple.new(tuple):update{{'!', 2, fiber.time()}}\n"
"        box.space.test:replace(tuple)\n"
"end\n"
"box.cfg{ } -- восстановление из локальной директории\n"
"-- настройка триггера во избежание конфликтов\n"
"box.space.test:before_replace(function(old, new)\n"
"        if old ~= nil and new ~= nil and new[2] < old[2] then\n"
"                return old -- игнорирование запроса\n"
"        end\n"
"        -- либо применение как есть\n"
"end)\n"
"box.cfg{ replication = {...} } -- подписка"

#: ../doc/book/cartridge/cartridge_admin.rst:575
msgid "Monitoring cluster via CLI"
msgstr "Мониторинг кластера через CLI"

#: ../doc/book/cartridge/cartridge_admin.rst:577
msgid ""
"This section describes parameters you can monitor over the administrative"
" console."
msgstr ""
"В данном разделе описываются параметры, которые можно отслеживать в "
"административной консоли."

#: ../doc/book/cartridge/cartridge_admin.rst:584
msgid "Connecting to nodes via CLI"
msgstr "Подключение к узлам через CLI"

#: ../doc/book/cartridge/cartridge_admin.rst:586
msgid ""
"Each Tarantool node (``router``/``storage``) provides an administrative "
"console (Command Line Interface) for debugging, monitoring, and "
"troubleshooting. The console acts as a Lua interpreter and displays the "
"result in the human-readable YAML format. To connect to a Tarantool "
"instance via the console, say:"
msgstr ""
"В каждом узле Tarantool (роутер/хранилище) есть административная консоль "
"(интерфейс командной строки) для отладки, мониторинга и разрешения "
"проблем. Консоль выступает в качестве интерпретатора Lua и отображает "
"результат в удобном для восприятия формате YAML. Чтобы подключиться к "
"экземпляру Tarantool через консоль, выполните команду:"

#: ../doc/book/cartridge/cartridge_admin.rst:591
msgid "$ tarantoolctl connect <instance_hostname>:<port>"
msgstr "$ tarantoolctl connect <имя_хоста_экземпляра>:<порт>"

#: ../doc/book/cartridge/cartridge_admin.rst:595
msgid "where the ``<instance_hostname>:<port>`` is the instance's URI."
msgstr "где ``<имя_хоста_экземпляра>:<порт>`` -- это URI данного экземпляра."

#: ../doc/book/cartridge/cartridge_admin.rst:601
msgid "Monitoring storages"
msgstr "Мониторинг хранилищ"

#: ../doc/book/cartridge/cartridge_admin.rst:603
msgid "Use ``vshard.storage.info()`` to obtain information on storage nodes."
msgstr ""
"Для получения информации об узлах хранения данных используйте "
"``vshard.storage.info()``."

#: ../doc/book/cartridge/cartridge_admin.rst:609
#: ../doc/book/cartridge/cartridge_admin.rst:782
msgid "Output example"
msgstr "Пример вывода"

#: ../doc/book/cartridge/cartridge_admin.rst:611
msgid ""
"tarantool> vshard.storage.info()\n"
"---\n"
"- replicasets:\n"
"    <replicaset_2>:\n"
"    uuid: <replicaset_2>\n"
"    master:\n"
"        uri: storage:storage@127.0.0.1:3303\n"
"    <replicaset_1>:\n"
"    uuid: <replicaset_1>\n"
"    master:\n"
"        uri: storage:storage@127.0.0.1:3301\n"
"  bucket: <!-- buckets status\n"
"    receiving: 0 <!-- buckets in the RECEIVING state\n"
"    active: 2 <!-- buckets in the ACTIVE state\n"
"    garbage: 0 <!-- buckets in the GARBAGE state (are to be deleted)\n"
"    total: 2 <!-- total number of buckets\n"
"    sending: 0 <!-- buckets in the SENDING state\n"
"  status: 1 <!-- the status of the replica set\n"
"  replication:\n"
"    status: disconnected <!-- the status of the replication\n"
"    idle: <idle>\n"
"  alerts:\n"
"  - ['MASTER_IS_UNREACHABLE', 'Master is unreachable: disconnected']"
msgstr ""
"tarantool> vshard.storage.info()\n"
"---\n"
"- replicasets:\n"
"    <replicaset_2>:\n"
"    uuid: <replicaset_2>\n"
"    master:\n"
"        uri: storage:storage@127.0.0.1:3303\n"
"    <replicaset_1>:\n"
"    uuid: <replicaset_1>\n"
"    master:\n"
"        uri: storage:storage@127.0.0.1:3301\n"
"  bucket: <!-- buckets status\n"
"    receiving: 0 <!-- buckets in the RECEIVING state\n"
"    active: 2 <!-- buckets in the ACTIVE state\n"
"    garbage: 0 <!-- buckets in the GARBAGE state (are to be deleted)\n"
"    total: 2 <!-- total number of buckets\n"
"    sending: 0 <!-- buckets in the SENDING state\n"
"  status: 1 <!-- the status of the replica set\n"
"  replication:\n"
"    status: disconnected <!-- the status of the replication\n"
"    idle: <idle>\n"
"  alerts:\n"
"  - ['MASTER_IS_UNREACHABLE', 'Master is unreachable: disconnected']"

#: ../doc/book/cartridge/cartridge_admin.rst:641
#: ../doc/book/cartridge/cartridge_admin.rst:811
msgid "Status list"
msgstr "Список состояний"

#: ../doc/book/cartridge/cartridge_admin.rst:649
#: ../doc/book/cartridge/cartridge_admin.rst:819
msgid "**Code**"
msgstr "**Код**"

#: ../doc/book/cartridge/cartridge_admin.rst:649
#: ../doc/book/cartridge/cartridge_admin.rst:819
msgid "**Critical level**"
msgstr "**Уровень критичности**"

#: ../doc/book/cartridge/cartridge_admin.rst:649
#: ../doc/book/cartridge/cartridge_admin.rst:819
msgid "**Description**"
msgstr "**Описание**"

#: ../doc/book/cartridge/cartridge_admin.rst:651
#: ../doc/book/cartridge/cartridge_admin.rst:821
msgid "Green"
msgstr "Зеленый"

#: ../doc/book/cartridge/cartridge_admin.rst:651
msgid "A replica set works in a regular way."
msgstr "Набор реплик работает в обычном режиме."

#: ../doc/book/cartridge/cartridge_admin.rst:653
#: ../doc/book/cartridge/cartridge_admin.rst:823
msgid "Yellow"
msgstr "Желтый"

#: ../doc/book/cartridge/cartridge_admin.rst:653
msgid ""
"There are some issues, but they don’t affect a replica set efficiency "
"(worth noticing, but don't require immediate intervention)."
msgstr ""
"Есть некоторые проблемы, но они не влияют на эффективность набора реплик "
"(их стоит отметить, но они не требуют немедленного вмешательства)."

#: ../doc/book/cartridge/cartridge_admin.rst:658
#: ../doc/book/cartridge/cartridge_admin.rst:826
msgid "Orange"
msgstr "Оранжевый"

#: ../doc/book/cartridge/cartridge_admin.rst:658
msgid "A replica set is in a degraded state."
msgstr "Набор реплик не восстановился после сбоя."

#: ../doc/book/cartridge/cartridge_admin.rst:660
#: ../doc/book/cartridge/cartridge_admin.rst:828
msgid "Red"
msgstr "Красный"

#: ../doc/book/cartridge/cartridge_admin.rst:660
msgid "A replica set is disabled."
msgstr "Набор реплик отключен."

#: ../doc/book/cartridge/cartridge_admin.rst:667
#: ../doc/book/cartridge/cartridge_admin.rst:835
msgid "Potential issues"
msgstr "Возможные проблемы"

#: ../doc/book/cartridge/cartridge_admin.rst:669
msgid "``MISSING_MASTER`` — No master node in the replica set configuration."
msgstr "``MISSING_MASTER`` — В конфигурации набора реплик отсутствует мастер-узел."

#: ../doc/book/cartridge/cartridge_admin.rst:671
#: ../doc/book/cartridge/cartridge_admin.rst:845
#: ../doc/book/cartridge/cartridge_admin.rst:854
msgid "**Critical level:** Orange."
msgstr "**Уровень критичности**: Оранжевый."

#: ../doc/book/cartridge/cartridge_admin.rst:673
msgid ""
"**Cluster condition:** Service is degraded for data-change requests to "
"the replica set."
msgstr ""
"**Состояние кластера**: Ухудшение работы запросов на изменение данных к "
"набору реплик."

#: ../doc/book/cartridge/cartridge_admin.rst:676
msgid ""
"**Solution:** Set the master node for the replica set in the "
"configuration using API."
msgstr "**Решение**: Задайте мастер-узел для набора реплик, используя API."

#: ../doc/book/cartridge/cartridge_admin.rst:678
msgid "``UNREACHABLE_MASTER`` — No connection between the master and the replica."
msgstr "``UNREACHABLE_MASTER`` — Отсутствует соединение между мастером и репликой."

#: ../doc/book/cartridge/cartridge_admin.rst:680
#: ../doc/book/cartridge/cartridge_admin.rst:725
msgid "**Critical level:**"
msgstr "**Уровень критичности:**"

#: ../doc/book/cartridge/cartridge_admin.rst:682
msgid "If idle value doesn’t exceed T1 threshold (1 s.) — Yellow,"
msgstr "Если значение бездействия не превышает порог T1 (1 с.) -- Желтый,"

#: ../doc/book/cartridge/cartridge_admin.rst:683
msgid "If idle value doesn’t exceed T2 threshold (5 s.) — Orange,"
msgstr "Если значение бездействия не превышает порог T2 (5 с.) -- Оранжевый,"

#: ../doc/book/cartridge/cartridge_admin.rst:684
msgid "If idle value exceeds T3 threshold (10 s.) — Red."
msgstr "Если значение бездействия не превышает порог T3 (10 с.) -- Красный."

#: ../doc/book/cartridge/cartridge_admin.rst:686
msgid ""
"**Cluster condition:** For read requests to replica, the data may be "
"obsolete compared with the data on master."
msgstr ""
"**Состояние кластера:** При запросах на чтение из реплики данные могут "
"быть устаревшими по сравнению с данными на мастере."

#: ../doc/book/cartridge/cartridge_admin.rst:689
msgid ""
"**Solution:** Reconnect to the master: fix the network issues, reset the "
"current master, switch to another master."
msgstr ""
"**Решение:** Повторно подключитесь к мастеру: устраните проблемы с сетью,"
" сбросьте текущий мастер, переключитесь на другой мастер."

#: ../doc/book/cartridge/cartridge_admin.rst:692
msgid "``LOW_REDUNDANCY`` — Master has access to a single replica only."
msgstr "``LOW_REDUNDANCY`` — У мастера есть доступ только к одной реплике."

#: ../doc/book/cartridge/cartridge_admin.rst:694
#: ../doc/book/cartridge/cartridge_admin.rst:712
#: ../doc/book/cartridge/cartridge_admin.rst:750
#: ../doc/book/cartridge/cartridge_admin.rst:865
msgid "**Critical level:** Yellow."
msgstr "**Уровень критичности:** Желтый."

#: ../doc/book/cartridge/cartridge_admin.rst:696
msgid ""
"**Cluster condition:** The data storage redundancy factor is equal to 2. "
"It is lower than the minimal recommended value for production usage."
msgstr ""
"**Состояние кластера:** Коэффициент избыточности хранения данных равен 2."
" Он ниже минимального рекомендуемого значения для использования в "
"производстве."

#: ../doc/book/cartridge/cartridge_admin.rst:699
msgid "**Solution:** Check cluster configuration:"
msgstr "**Решение:** Проверить конфигурацию кластера:"

#: ../doc/book/cartridge/cartridge_admin.rst:701
msgid ""
"If only one master and one replica are specified in the configuration, it"
" is recommended to add at least one more replica to reach the redundancy "
"factor of 3."
msgstr ""
"Если в конфигурации указан только один мастер и одна реплика, "
"рекомендуется добавить хотя бы еще одну реплику, чтобы коэффициент "
"избыточности достиг 3."

#: ../doc/book/cartridge/cartridge_admin.rst:704
msgid ""
"If three or more replicas are specified in the configuration, consider "
"checking the replicas' states and network connection among the replicas."
msgstr ""
"Если в конфигурации указаны три или более реплик, проверьте статусы "
"реплик и сетевое соединение между репликами."

#: ../doc/book/cartridge/cartridge_admin.rst:707
msgid ""
"``INVALID_REBALANCING`` — Rebalancing invariant was violated. During "
"migration, a storage node can either send or receive buckets. So it "
"shouldn’t be the case that a replica set sends buckets to one replica set"
" and receives buckets from another replica set at the same time."
msgstr ""
"``INVALID_REBALANCING`` — Нарушен инвариант балансировки. Во время "
"миграции узел хранения может либо отправлять сегменты, либо получать их. "
"Поэтому не должно быть так, чтобы набор реплик отправлял сегменты в один "
"набор реплик и одновременно получал сегменты из другого набора реплик."

#: ../doc/book/cartridge/cartridge_admin.rst:714
msgid "**Cluster condition:** Rebalancing is on hold."
msgstr "**Состояние кластера:** Балансировка приостановлена."

#: ../doc/book/cartridge/cartridge_admin.rst:716
msgid "**Solution:** There are two possible reasons for invariant violation:"
msgstr "**Решение:** Есть две возможные причины нарушения инварианта:"

#: ../doc/book/cartridge/cartridge_admin.rst:718
msgid "The ``rebalancer`` has crashed."
msgstr "Отказ балансировщика."

#: ../doc/book/cartridge/cartridge_admin.rst:719
msgid "Bucket states were changed manually."
msgstr "Статус сегмента был изменен вручную."

#: ../doc/book/cartridge/cartridge_admin.rst:721
msgid "Either way, please contact Tarantool support."
msgstr "В любом случае обратитесь в техническую поддержку Tarantool'а."

#: ../doc/book/cartridge/cartridge_admin.rst:723
msgid "``HIGH_REPLICATION_LAG`` — Replica’s lag exceeds T1 threshold (1 sec.)."
msgstr "``HIGH_REPLICATION_LAG`` — Отставание реплики превышает порог T1 (1 с.)."

#: ../doc/book/cartridge/cartridge_admin.rst:727
msgid "If the lag doesn’t exceed T1 threshold (1 sec.) — Yellow;"
msgstr "Если отставание не превышает порог T1 (1 с.) -- Желтый;"

#: ../doc/book/cartridge/cartridge_admin.rst:728
msgid "If the lag exceeds T2 threshold (5 sec.) — Orange."
msgstr "Если отставание не превышает порог T2 (5 с.) -- Оранжевый."

#: ../doc/book/cartridge/cartridge_admin.rst:730
#: ../doc/book/cartridge/cartridge_admin.rst:740
msgid ""
"**Cluster condition:** For read-only requests to the replica, the data "
"may be obsolete compared with the data on the master."
msgstr ""
"**Состояние кластера:** При запросах только на чтение из реплики данные "
"могут быть устаревшими по сравнению с данными на мастере."

#: ../doc/book/cartridge/cartridge_admin.rst:733
#: ../doc/book/cartridge/cartridge_admin.rst:743
msgid ""
"**Solution:** Check the replication status of the replica. Further "
"instructions are given in the :ref:`Tarantool troubleshooting guide "
"<admin-troubleshooting-guide>`."
msgstr ""
"**Решение:** Проверьте статус репликации на реплике. Более подробные "
"инструкции приведены в :ref:`руководстве по разрешению проблем по <admin-"
"troubleshooting-guide>`."

#: ../doc/book/cartridge/cartridge_admin.rst:736
msgid ""
"``OUT_OF_SYNC`` — Mal-synchronization occured. The lag exceeds T3 "
"threshold (10 sec.)."
msgstr ""
"``OUT_OF_SYNC`` — Произошла рассинхронизация. Отставание превышает порог "
"T3 (10 с.)."

#: ../doc/book/cartridge/cartridge_admin.rst:738
msgid "**Critical level:** Red."
msgstr "**Уровень критичности:** Красный."

#: ../doc/book/cartridge/cartridge_admin.rst:748
msgid "``UNREACHABLE_REPLICA`` — One or multiple replicas are unreachable."
msgstr "``UNREACHABLE_REPLICA`` — Одна или несколько реплик недоступны."

#: ../doc/book/cartridge/cartridge_admin.rst:752
msgid ""
"**Cluster condition:** Data storage redundancy factor for the given "
"replica set is less than the configured factor. If the replica is next in"
" the queue for rebalancing (in accordance with the weight configuration),"
" the requests are forwarded to the replica that is still next in the "
"queue."
msgstr ""
"**Состояние кластера:** Коэффициент избыточности хранения данных для "
"данного набора реплик меньше заданного значения. Если реплика стоит "
"следующей в очереди на балансировку (в соответствии с настройками веса), "
"запросы перенаправляются в реплику, которая все еще находится в очереди."

#: ../doc/book/cartridge/cartridge_admin.rst:757
msgid ""
"**Solution:** Check the error message and find out which replica is "
"unreachable. If a replica is disabled, enable it. If this doesn’t help, "
"consider checking the network."
msgstr ""
"**Решение:** Проверьте сообщение об ошибке и выясните, какая реплика "
"недоступна. Если реплика отключена, включите ее. Если это не поможет, "
"проверьте состояние сети."

#: ../doc/book/cartridge/cartridge_admin.rst:761
msgid ""
"``UNREACHABLE_REPLICASET`` — All replicas except for the current one are "
"unreachable. **Critical level:** Red."
msgstr ""
"``UNREACHABLE_REPLICASET`` — Все реплики, кроме текущей, недоступны. "
"**Уровень критичности:** Красный."

#: ../doc/book/cartridge/cartridge_admin.rst:764
msgid "**Cluster condition:** The replica stores obsolete data."
msgstr "**Состояние кластера:** Реплика хранит устаревшие данные."

#: ../doc/book/cartridge/cartridge_admin.rst:766
msgid ""
"**Solution:** Check if the other replicas are enabled. If all replicas "
"are enabled, consider checking network issues on the master. If the "
"replicas are disabled, check them first: the master might be working "
"properly."
msgstr ""
"**Решение:** Проверьте, включены ли другие реплики. Если все реплики "
"включены, проверьте наличие сетевых проблем на мастере. Если реплики "
"отключены, сначала проверьте их: возможно, мастер работает правильно."

#: ../doc/book/cartridge/cartridge_admin.rst:774
msgid "Monitoring routers"
msgstr "Мониторинг роутеров"

#: ../doc/book/cartridge/cartridge_admin.rst:776
msgid "Use ``vshard.router.info()`` to obtain information on the router."
msgstr "Для получения информации о роутерах используйте ``vshard.router.info()``."

#: ../doc/book/cartridge/cartridge_admin.rst:784
msgid ""
"tarantool> vshard.router.info()\n"
"---\n"
"- replicasets:\n"
"    <replica set UUID>:\n"
"      master:\n"
"        status: <available / unreachable / missing>\n"
"        uri: <!-- URI of master\n"
"        uuid: <!-- UUID of instance\n"
"      replica:\n"
"        status: <available / unreachable / missing>\n"
"        uri: <!-- URI of replica used for slave requests\n"
"        uuid: <!-- UUID of instance\n"
"      uuid: <!-- UUID of replica set\n"
"    <replica set UUID>: ...\n"
"    ...\n"
"  status: <!-- status of router\n"
"  bucket:\n"
"    known: <!-- number of buckets with the known destination\n"
"    unknown: <!-- number of other buckets\n"
"  alerts: [<alert code>, <alert description>], ..."
msgstr ""
"tarantool> vshard.router.info()\n"
"---\n"
"- replicasets:\n"
"    <replica set UUID>:\n"
"      master:\n"
"        status: <available / unreachable / missing>\n"
"        uri: <!-- URI мастера\n"
"        uuid: <!-- UUID экземпляра\n"
"      replica:\n"
"        status: <available / unreachable / missing>\n"
"        uri: <!-- URI реплики, используемой для запросов\n"
"        uuid: <!-- UUID экземпляра\n"
"      uuid: <!-- UUID набора реплик\n"
"    <replica set UUID>: ...\n"
"    ...\n"
"  status: <!-- статус роутера\n"
"  bucket:\n"
"    known: <!-- количество сегментов с известным местом назначения\n"
"    unknown: <!-- количество других сегментов\n"
"  alerts: [<alert code>, <alert description>], ..."

#: ../doc/book/cartridge/cartridge_admin.rst:821
msgid "The ``router`` works in a regular way."
msgstr "Роутер работает в обычном режиме."

#: ../doc/book/cartridge/cartridge_admin.rst:823
msgid ""
"Some replicas sre unreachable (affects the speed of executing read "
"requests)."
msgstr ""
"Некоторые реплики недоступны, что влияет на скоость выполнения запросов "
"на чтение."

#: ../doc/book/cartridge/cartridge_admin.rst:826
msgid "Service is degraded for changing data."
msgstr "Работа запросов на изменение данных ухудшена."

#: ../doc/book/cartridge/cartridge_admin.rst:828
msgid "Service is degraded for reading data."
msgstr "Работа запросов на чтение данных ухудшена."

#: ../doc/book/cartridge/cartridge_admin.rst:839
msgid ""
"Depending on the nature of the issue, use either the UUID of a replica, "
"or the UUID of a replica set."
msgstr ""
"В зависимости от характера проблемы используйте либо UUID реплики, либо "
"UUID набора реплик."

#: ../doc/book/cartridge/cartridge_admin.rst:842
msgid ""
"``MISSING_MASTER`` — The master in one or multiple replica sets is not "
"specified in the configuration."
msgstr ""
"``MISSING_MASTER`` — В конфигурации одного или нескольких наборов реплик "
"не указан мастер."

#: ../doc/book/cartridge/cartridge_admin.rst:847
#: ../doc/book/cartridge/cartridge_admin.rst:856
msgid "**Cluster condition:** Partial degrade for data-change requests."
msgstr ""
"**Состояние кластера:** Частичное ухудшение работы запросов на изменение "
"данных."

#: ../doc/book/cartridge/cartridge_admin.rst:849
msgid "**Solution:** Specify the master in the configuration."
msgstr "**Решение:** Укажите мастера в конфигурации."

#: ../doc/book/cartridge/cartridge_admin.rst:851
msgid ""
"``UNREACHABLE_MASTER`` — The ``router`` lost connection with the master "
"of one or multiple replica sets."
msgstr ""
"``UNREACHABLE_MASTER`` — Роутер потерял соединение с мастером одного или "
"нескольких наборов реплик."

#: ../doc/book/cartridge/cartridge_admin.rst:858
msgid ""
"**Solution:** Restore connection with the master. First, check if the "
"master is enabled. If it is, consider checking the network."
msgstr ""
"**Решение:** Восстановите соединение с мастером. Сначала проверьте, "
"включен ли мастер. Если он включен, проверьте состояние сети."

#: ../doc/book/cartridge/cartridge_admin.rst:861
msgid ""
"``SUBOPTIMAL_REPLICA`` — There is a replica for read-only requests, but "
"this replica is not optimal according to the configured weights. This "
"means that the optimal replica is unreachable."
msgstr ""
"``SUBOPTIMAL_REPLICA`` — Восстановите соединение с мастером. Сначала "
"проверьте, включен ли мастер. Если он включен, проверьте состояние сети."

#: ../doc/book/cartridge/cartridge_admin.rst:867
msgid ""
"**Cluster condition:** Read-only requests are forwarded to a backup "
"replica."
msgstr ""
"**Состояние кластера:** Запросы только на чтение направляются на "
"резервную реплику."

#: ../doc/book/cartridge/cartridge_admin.rst:869
msgid ""
"**Solution:** Check the status of the optimal replica and its network "
"connection."
msgstr ""
"**Решение:** Проверьте статус оптимальной реплики и ее сетевого "
"подключения."

#: ../doc/book/cartridge/cartridge_admin.rst:871
msgid ""
"``UNREACHABLE_REPLICASET`` — A replica set is unreachable for both read-"
"only and data-change requests."
msgstr ""
"``UNREACHABLE_REPLICASET`` — Набор реплик недоступен как для запросов "
"только на чтение, так и для запросов на изменение данных."

#: ../doc/book/cartridge/cartridge_admin.rst:874
msgid "**Critical Level:** Red."
msgstr "**Уровень критичности:** Красный."

#: ../doc/book/cartridge/cartridge_admin.rst:876
msgid ""
"**Cluster condition:** Partial degrade for read-only and data-change "
"requests."
msgstr ""
"**Состояние кластера:** Частичное ухудшение работы запросов на изменение "
"данных и на чтение данных."

#: ../doc/book/cartridge/cartridge_admin.rst:878
msgid ""
"**Solution:** The replica set has an unreachable master and replica. "
"Check the error message to detect this replica set. Then fix the issue in"
" the same way as for :ref:`UNREACHABLE_REPLICA <unreachable_replica>`."
msgstr ""
"**Решение:** В наборе реплик недоступны мастер и реплика. Проверьте "
"сообщение об ошибке, чтобы найти этот набор реплик. Исправьте ошибку, как"
" описано в решении ошибки :ref:`UNREACHABLE_REPLICA "
"<unreachable_replica>`."

#: ../doc/book/cartridge/cartridge_admin.rst:886
msgid "Troubleshooting"
msgstr "Разрешение проблем"

#: ../doc/book/cartridge/cartridge_admin.rst:888
msgid "Please see the :ref:`Troubleshooting guide <admin-troubleshooting-guide>`."
msgstr ""
"См. :ref:`Руководство по разрешению проблем <admin-troubleshooting-"
"guide>`."

#: ../doc/book/cartridge/cartridge_admin.rst:896
msgid "Please see the section :ref:`Disaster recovery <admin-disaster_recovery>`."
msgstr "См. раздел :ref:`Аварийное восстановление <admin-disaster_recovery>`."

#: ../doc/book/cartridge/cartridge_admin.rst:904
msgid "Please see the section :ref:`Backups <admin-backups>`."
msgstr "См. раздел :ref:`Резервное копирование <admin-backups>`."

#: ../doc/book/cartridge/cartridge_dev.rst:5
msgid "Tarantool Cartridge developer's guide"
msgstr "Руководство разработчика Tarantool Cartridge"

#: ../doc/book/cartridge/cartridge_dev.rst:7
msgid ""
"For a quick start, skip the details below and jump right away to this "
"detailed `guide <https://github.com/tarantool/cartridge-"
"cli/blob/master/examples/getting-started-app/README.md>`_ to creating a "
"cluster-aware Tarantool application."
msgstr ""
"Если вам необходимо быстро начать работу, можете спокойно пропустить "
"подробное описание ниже и сразу перейти к подробному `руководству "
"<https://github.com/tarantool/cartridge-cli/blob/master/examples/getting-"
"started-app/README.md>`_ по созданию Tarantool-приложения с поддержкой "
"кластера."

#: ../doc/book/cartridge/cartridge_dev.rst:11
msgid ""
"For a deep dive into what you can do with Tarantool Cartridge, go on with"
" this section."
msgstr ""
"Если же вы хотите всесторонне изучить возможности Tarantool Cartridge, "
"продолжайте читать этот раздел."

#: ../doc/book/cartridge/cartridge_dev.rst:13
msgid ""
"To develop and start an application, in short, you need to go through the"
" following steps:"
msgstr ""
"Короче говоря, чтобы разработать и запустить приложение, вам необходимо "
"выполнить следующие шаги:"

#: ../doc/book/cartridge/cartridge_dev.rst:16
msgid ""
":ref:`Install <cartridge-install>` Tarantool Cartridge and other "
"components of the development environment."
msgstr ""
":ref:`Установить <cartridge-install>` Tarantool Cartridge и другие "
"компоненты среды разработки."

#: ../doc/book/cartridge/cartridge_dev.rst:18
msgid ""
"Choose a :ref:`template <cartridge-templates>` for the application and "
"create a project."
msgstr ""
"Выбрать :ref:`шаблон <cartridge-templates>` для приложения и создать "
"проект."

#: ../doc/book/cartridge/cartridge_dev.rst:20
msgid ""
"Develop the application. In case it is a cluster-aware application, "
"implement its logic in a custom (user-defined) :ref:`cluster role "
"<cartridge-roles>` to initialize the database in a cluster environment."
msgstr ""
"Разработать приложение. Если это приложение с поддержкой кластеров, "
"реализуйте его логику в виде отдельной (пользовательской) "
":ref:`кластерной роли <cartridge-roles>`, чтобы инициализировать базу "
"данных в кластерной среде."

#: ../doc/book/cartridge/cartridge_dev.rst:24
msgid ""
":ref:`Deploy <cartridge-deploy>` the application to target server(s). "
"This includes :ref:`configuring <cartridge-config>` and :ref:`starting "
"<cartridge-run>` the instance(s)."
msgstr ""
":ref:`Развернуть <cartridge-deploy>` приложение на сервере или серверах. "
"Это включает в себя :ref:`настройку <cartridge-config>` и :ref:`запуск "
"<cartridge-run>` экземпляров."

#: ../doc/book/cartridge/cartridge_dev.rst:27
msgid ""
"In case it is a cluster-aware application, :ref:`deploy the cluster "
"<cartridge-deployment>`."
msgstr ""
"Если это приложение с поддержкой кластеров, :ref:`развернуть кластер "
"<cartridge-deployment>`."

#: ../doc/book/cartridge/cartridge_dev.rst:30
msgid "The following sections provide details for each of these steps."
msgstr "В следующих разделах подробно описывается каждый из этих шагов."

#: ../doc/book/cartridge/cartridge_dev.rst:36
msgid "Installing Tarantool Cartridge"
msgstr "Установка Tarantool Cartridge"

#: ../doc/book/cartridge/cartridge_dev.rst:38
msgid ""
"Install ``catridge-cli``, a command-line tool for developing, deploying, "
"and managing Tarantool applications:"
msgstr ""
"Установите ``catridge-cli`` -- инструмент командной строки для "
"разработки, развертывания и управления Tarantool-приложениями:"

#: ../doc/book/cartridge/cartridge_dev.rst:41
msgid "$ tarantoolctl rocks install cartridge-cli"
msgstr "$ tarantoolctl rocks install cartridge-cli"

#: ../doc/book/cartridge/cartridge_dev.rst:45
msgid ""
"The Cartridge framework will come as a dependency when you create your "
"project."
msgstr "Среда Cartridge станет зависимостью при создании проекта."

#: ../doc/book/cartridge/cartridge_dev.rst:47
msgid ""
"Everything will be installed to ``.rocks/bin``, so for convenient usage "
"add ``.rocks/bin`` to the executable path:"
msgstr ""
"Все будет установлено в ``.rocks/bin``, поэтому для удобства "
"использования добавьте ``.rocks/bin`` в путь к исполняемому файлу:"

#: ../doc/book/cartridge/cartridge_dev.rst:50
msgid "$ export PATH=$PWD/.rocks/bin/:$PATH"
msgstr "$ export PATH=$PWD/.rocks/bin/:$PATH"

#: ../doc/book/cartridge/cartridge_dev.rst:54
msgid "Install ``git``, a version control system."
msgstr "Установите ``git``, систему управления версиями."

#: ../doc/book/cartridge/cartridge_dev.rst:56
msgid "Install ``npm``, a package manager for ``node.js``."
msgstr "Установите ``npm``, менеджер пакетов для ``node.js``."

#: ../doc/book/cartridge/cartridge_dev.rst:58
msgid "Install the ``unzip`` utility."
msgstr "Установите утилиту ``unzip``."

#: ../doc/book/cartridge/cartridge_dev.rst:64
msgid "Application templates"
msgstr "Шаблоны приложений"

#: ../doc/book/cartridge/cartridge_dev.rst:66
msgid ""
"Tarantool Cartridge provides you with two templates that help instantly "
"set up the application development environment:"
msgstr ""
"В Tarantool Cartridge есть два шаблона, которые помогут вам мгновенно "
"настроить среду разработки приложений:"

#: ../doc/book/cartridge/cartridge_dev.rst:69
msgid ""
"``plain``, for developing an application that runs on a single or "
"multiple independent Tarantool instances (e.g. acting as a proxy to "
"third-party databases) -- that's what you could do before, :ref:`without "
"Tarantool Cartridge <app_server-creating_app>`, but now it's more "
"convenient."
msgstr ""
"``plain`` -- для разработки приложения, которое работает на одном или "
"нескольких независимых экземплярах Tarantool'а (например, в качестве "
"прокси для сторонних баз данных), что можно было делать и раньше "
":ref:`без Tarantool Cartridge <app_server-creating_app>`, но теперь это "
"гораздо удобнее."

#: ../doc/book/cartridge/cartridge_dev.rst:74
msgid ""
"``cartridge``, for developing a cluster-aware application -- this is an "
"exclusive feature of Tarantool Cartridge."
msgstr ""
"``cartridge`` -- для разработки приложений с поддержкой кластеров -- "
"эксклюзивная функция Tarantool Cartridge."

#: ../doc/book/cartridge/cartridge_dev.rst:77
msgid "To create a project based on either template, in any directory say:"
msgstr ""
"Чтобы создать проект на основе одного из шаблонов, в любой директории "
"выполните команду:"

#: ../doc/book/cartridge/cartridge_dev.rst:79
msgid ""
"# plain application\n"
"$ plain create --name <app_name> /path/to/\n"
"\n"
"# - OR -\n"
"\n"
"# cluster application\n"
"$ cartridge create --name <app_name> /path/to/"
msgstr ""
"# простое приложение\n"
"$ plain create --name <имя_приложения> /path/to/\n"
"\n"
"# - ИЛИ -\n"
"\n"
"# кластерное приложение\n"
"$ cartridge create --name <имя_приложения> /path/to/"

#: ../doc/book/cartridge/cartridge_dev.rst:89
msgid ""
"This will automatically set up a Git repository in a new "
"``/path/to/<app_name>/`` directory, tag it with :ref:`version <cartridge-"
"versioning>` ``0.1.0``, and put the necessary files into it (read about "
"default files for each template below)."
msgstr ""
"Это автоматически настроит Git-репозиторий в новой директории "
"``/path/to/<имя_приложения>/``, проставит тег с :ref:`версией <cartridge-"
"versioning>` ``0.1.0`` и поместит туда необходимые файлы (файлы, "
"размещаемые по умолчанию в каждом шаблоне, описаны ниже)."

#: ../doc/book/cartridge/cartridge_dev.rst:94
msgid ""
"In this Git repository, you can develop the application (by simply "
"editing the default files provided by the template), plug the necessary "
"modules, and then easily pack everything to deploy on your server(s)."
msgstr ""
"В этом Git-репозитории можно разработать приложение (просто редактируя "
"файлы из шаблона), подключить необходимые модули, а затем с легкостью "
"упаковать все для развертывания на своих серверах."

#: ../doc/book/cartridge/cartridge_dev.rst:102
msgid "Plain template"
msgstr "Шаблон plain"

#: ../doc/book/cartridge/cartridge_dev.rst:104
msgid ""
"The plain template creates the ``<app_name>/`` directory with the "
"following contents:"
msgstr ""
"Шаблон plain создает директорию ``<имя_приложения>/``, которая содержит "
"следующее:"

#: ../doc/book/cartridge/cartridge_dev.rst:107
msgid ""
"``<app_name>-scm-1.rockspec`` file where you can specify the application "
"dependencies."
msgstr ""
"файл ``<имя_приложения>-scm-1.rockspec``, где можно указать зависимости "
"приложения."

#: ../doc/book/cartridge/cartridge_dev.rst:109
msgid "``deps.sh`` script that resolves dependencies from the ``.rockspec`` file."
msgstr ""
"скрипт ``deps.sh``, который решает проблемы с зависимостями из файла "
"``.rockspec``."

#: ../doc/book/cartridge/cartridge_dev.rst:110
msgid "``init.lua`` file which is the entry point for your application."
msgstr "файл ``init.lua``, который является точкой входа в ваше приложение."

#: ../doc/book/cartridge/cartridge_dev.rst:111
msgid "``.git`` file necessary for a Git repository."
msgstr "файл ``.git``, необходимый для Git-репозитория."

#: ../doc/book/cartridge/cartridge_dev.rst:112
msgid "``.gitignore`` file to ignore the unnecessary files."
msgstr "файл ``.gitignore``, чтобы не учитывать ненужные файлы."

#: ../doc/book/cartridge/cartridge_dev.rst:118
msgid "Cluster template"
msgstr "Шаблон cluster"

#: ../doc/book/cartridge/cartridge_dev.rst:120
msgid ""
"In addition to the files listed in the plain template section, the "
"cluster template contains the following:"
msgstr ""
"Помимо файлов, перечисленным в разделе о шаблоне plain, шаблон cluster "
"содержит следующее:"

#: ../doc/book/cartridge/cartridge_dev.rst:123
msgid ""
"``env.lua`` file that sets common rock paths so that the application can "
"be started from any directory."
msgstr ""
"файл ``env.lua``, который устанавливает общие пути для модулей, чтобы "
"приложение можно было запустить из любой директории."

#: ../doc/book/cartridge/cartridge_dev.rst:125
msgid ""
"``custom-role.lua`` file that is a placeholder for a custom (user-"
"defined) :ref:`cluster role <cartridge-roles>`."
msgstr ""
"файл ``custom-role.lua``, который представляет собой объект-заполнитель "
"для пользовательской :ref:`кластерной роли <cartridge-roles>`."

#: ../doc/book/cartridge/cartridge_dev.rst:128
msgid ""
"The entry point file (``init.lua``) of the cluster template differs from "
"the plain one. Among other things, it loads the ``cartridge`` module and "
"calls its initialization function:"
msgstr ""
"Файл входа в приложение (``init.lua``) в шаблоне cluster отличается от "
"аналогичного файла в шаблоне plain. Помимо прочего, он загружает модуль "
"``cartridge`` и вызывает его функцию инициализации:"

#: ../doc/book/cartridge/cartridge_dev.rst:132
msgid ""
"...\n"
"local cartridge = require('cartridge')\n"
"...\n"
"cartridge.cfg({\n"
"  workdir = ...,\n"
"  advertise_uri = ...,\n"
"  cluster_cookie = ...,\n"
"  ...\n"
"})\n"
"..."
msgstr ""
"...\n"
"local cartridge = require('cartridge')\n"
"...\n"
"cartridge.cfg({\n"
"  workdir = ...,\n"
"  advertise_uri = ...,\n"
"  cluster_cookie = ...,\n"
"  ...\n"
"})\n"
"..."

#: ../doc/book/cartridge/cartridge_dev.rst:145
msgid ""
"The ``cartridge.cfg()`` call renders the instance operable via the "
"administrative console but does not call ``box.cfg()`` to configure "
"instances."
msgstr ""
"Вызов ``cartridge.cfg()`` позволяет управлять экземпляром через "
"административную консоль, но не вызывает ``box.cfg()`` для настройки "
"экземпляров."

#: ../doc/book/cartridge/cartridge_dev.rst:150
msgid "Calling the ``box.cfg()`` function is forbidden."
msgstr "Запрещается вызывать функцию ``box.cfg()``."

#: ../doc/book/cartridge/cartridge_dev.rst:152
msgid "The cluster itself will do it for you when it is time to:"
msgstr "Сам кластер сделает это за вас, когда придет время:"

#: ../doc/book/cartridge/cartridge_dev.rst:154
msgid "bootstrap the current instance once you:"
msgstr "загрузить текущий экземпляр, когда вы:"

#: ../doc/book/cartridge/cartridge_dev.rst:156
msgid "run ``cartridge.bootstrap()`` via the administrative console, or"
msgstr "выполните ``cartridge.bootstrap()`` в административной консоли, или"

#: ../doc/book/cartridge/cartridge_dev.rst:157
msgid "click **Create** in the web interface;"
msgstr "нажмете **Create** (Создать) в веб-интерфейсе;"

#: ../doc/book/cartridge/cartridge_dev.rst:159
msgid "join the instance to an existing cluster once you:"
msgstr "присоединить экземпляр к существующему кластеру, когда вы:"

#: ../doc/book/cartridge/cartridge_dev.rst:161
msgid ""
"run ``cartridge.join_server({uri = 'other_instance_uri'})`` via the "
"console, or"
msgstr ""
"выполните ``cartridge.join_server({uri = ''uri_другого_экземпляра'})`` в "
"консоли, или"

#: ../doc/book/cartridge/cartridge_dev.rst:162
msgid ""
"click **Join** (an existing replica set) or **Create** (a new replica "
"set) in the web interface."
msgstr ""
"нажмете **Join** (Присоединить -- к уже существующему набору реплик) или "
"**Create** (Создать -- для нового набора реплик) в веб-интерфейсе."

#: ../doc/book/cartridge/cartridge_dev.rst:165
msgid ""
"Notice that you can specify a cookie for the cluster (``cluster_cookie`` "
"parameter) if you need to run several clusters in the same network. The "
"cookie can be any string value."
msgstr ""
"Обратите внимание, что вы можете указать cookie для кластера (параметр "
"``cluster_cookie``), если необходимо запустить несколько кластеров в "
"одной сети. Cookie может представлять собой любое строковое значение."

#: ../doc/book/cartridge/cartridge_dev.rst:169
msgid ""
"Before developing a cluster-aware application, familiarize yourself with "
"the notion of :ref:`cluster roles <cartridge-roles>` and make sure to "
"define a custom role to initialize the database for the cluster "
"application."
msgstr ""
"Перед тем как разрабатывать приложение с поддержкой кластеров, "
"ознакомьтесь с понятием :ref:`кластерных ролей <cartridge-roles>` и "
"обязательно определите специальную роль для инициализации базы данных для"
" кластерного приложения."

#: ../doc/book/cartridge/cartridge_dev.rst:178
msgid "Cluster roles"
msgstr "Кластерные роли"

#: ../doc/book/cartridge/cartridge_dev.rst:180
msgid ""
"A Tarantool Cartridge cluster segregates instance functionality in a "
"role-based way. **Cluster roles** are Lua modules that implement some "
"instance-specific functions and/or logic."
msgstr ""
"Кластер Tarantool Cartridge распределяет функции экземпляров на основе "
"ролей. **Кластерные роли** -- это Lua-модули, которые реализуют некоторые"
" заданные для экземпляра функции и/или логику."

#: ../doc/book/cartridge/cartridge_dev.rst:184
msgid ""
"Since all instances running cluster applications use the same source code"
" and are aware of all the defined roles (and plugged modules), multiple "
"different roles can be dynamically enabled and disabled on any number of "
"instances without restarts even during cluster operation."
msgstr ""
"Поскольку все экземпляры, на которых запущены кластерные приложения, "
"используют один и тот же исходный код и знают обо всех определенных ролях"
" (и подключенных модулях), можно динамически включать и отключать "
"несколько разных ролей на любом количестве экземпляров без перезапусков "
"даже во время работы кластера."

#: ../doc/book/cartridge/cartridge_dev.rst:193
msgid "Built-in roles"
msgstr "Встроенные роли"

#: ../doc/book/cartridge/cartridge_dev.rst:195
msgid ""
"The ``cartridge`` module comes with two *built-in* roles that implement "
"automatic sharding:"
msgstr ""
"В модуль ``cartridge`` входят две *встроенные* роли, которые реализуют "
"автоматический шардинг:"

#: ../doc/book/cartridge/cartridge_dev.rst:198
msgid ""
"``vshard-router`` that handles the ``vshard``'s *compute-intensive* "
"workload: routes requests to storage nodes."
msgstr ""
"``vshard-router`` обрабатывает *ресурсоемкие* вычисления в ``vshard``: "
"направляет запросы к узлам хранения данных."

#: ../doc/book/cartridge/cartridge_dev.rst:200
msgid ""
"``vshard-storage`` that handles the ``vshard``'s *transaction-intensive* "
"workload: stores and manages a subset of a dataset."
msgstr ""
"``vshard-storage`` работает с *большим количеством транзакций* в "
"``vshard``: хранит подмножество набора данных и управляет им."

#: ../doc/book/cartridge/cartridge_dev.rst:205
msgid ""
"For more information on sharding, see the :ref:`vshard module "
"documentation <vshard>`."
msgstr ""
"Для получения дополнительной информации о шардинге см. :ref:`докуемнтацию"
" по модулю vshard <vshard>`."

#: ../doc/book/cartridge/cartridge_dev.rst:208
msgid ""
"With the built-in and custom roles, Tarantool Cartridge allows you to "
"develop applications with separated compute and transaction handling. "
"Later, the relevant workload-specific roles can be enabled on different "
"instances running on physical servers with workload-dedicated hardware."
msgstr ""
"Благодаря встроенным и пользовательским ролям, Tarantool Cartridge "
"позволяет разрабатывать приложения, где вычисления отделены от обработки "
"транзакций. Позже соответствующие роли в зависимости от рабочей нагрузки "
"можно включить на разных экземплярах, которые работают на физических "
"серверах с оборудованием, выделенным для рабочей нагрузки."

#: ../doc/book/cartridge/cartridge_dev.rst:213
msgid ""
"Neither ``vshard-router`` nor ``vshard-storage`` manage spaces, indexes, "
"or formats. To start developing an application, edit the ``custom-"
"role.lua`` placeholder file: add a ``box.schema.space.create()`` call to "
"your first cluster role."
msgstr ""
"Ни ``vshard-router``, ни ``vshard-storage`` не управляют спейсами, "
"индексами и форматами. Чтобы начать разработку приложения, отредактируйте"
" файл-заглушку ``custom-role.lua``: добавьте вызов "
"``box.schema.space.create()`` в свою первую кластерную роль."

#: ../doc/book/cartridge/cartridge_dev.rst:218
msgid "Additionally, you can implement several such roles to:"
msgstr "Кроме того, можно реализовать несколько таких ролей, чтобы:"

#: ../doc/book/cartridge/cartridge_dev.rst:220
msgid "define stored procedures;"
msgstr "определять хранимые процедуры;"

#: ../doc/book/cartridge/cartridge_dev.rst:221
msgid "implement functionality on top of ``vshard``;"
msgstr "реализовать функции поверх ``vshard``;"

#: ../doc/book/cartridge/cartridge_dev.rst:222
msgid "go without ``vshard`` at all;"
msgstr "полностью обойтись без ``vshard``;"

#: ../doc/book/cartridge/cartridge_dev.rst:223
msgid ""
"implement one or multiple supplementary services such as e-mail notifier,"
" replicator, etc."
msgstr ""
"внедрить одну или несколько дополнительных служб, таких как средство "
"уведомления по электронной почте, репликатор и т.д."

#: ../doc/book/cartridge/cartridge_dev.rst:230
msgid "Custom roles"
msgstr "Пользовательские роли"

#: ../doc/book/cartridge/cartridge_dev.rst:232
msgid "To implement a *custom* cluster role, do the following:"
msgstr ""
"Чтобы внедрить *пользовательскую* кластерную роль, выполните следующие "
"действия:"

#: ../doc/book/cartridge/cartridge_dev.rst:234
msgid ""
"Register the new role in the cluster by modifying the ``cartridge.cfg()``"
" call in the ``init.lua`` entry point file:"
msgstr ""
"Зарегистрируйте новую роль в кластере, изменив вызов ``cartridge.cfg()`` "
"в файле входа в приложение ``init.lua``:"

#: ../doc/book/cartridge/cartridge_dev.rst:237
msgid ""
"...\n"
"local cartridge = require('cartridge')\n"
"...\n"
"cartridge.cfg({\n"
"  workdir = ...,\n"
"  advertise_uri = ...,\n"
"  roles = {'custom-role'},\n"
"})\n"
"..."
msgstr ""
"...\n"
"local cartridge = require('cartridge')\n"
"...\n"
"cartridge.cfg({\n"
"  workdir = ...,\n"
"  advertise_uri = ...,\n"
"  roles = {'custom-role'},\n"
"})\n"
"..."

#: ../doc/book/cartridge/cartridge_dev.rst:250
msgid "where ``custom-role`` is the name of the Lua module to be loaded."
msgstr ""
"где ``custom-role`` (пользовательская роль) -- это название загружаемого "
"Lua-модуля."

#: ../doc/book/cartridge/cartridge_dev.rst:252
msgid ""
"Implement the role in a file with the appropriate name (``custom-"
"role.lua``). For example:"
msgstr ""
"Поместите роль в файл с соответствующим именем (``custom-role.lua``). "
"Например:"

#: ../doc/book/cartridge/cartridge_dev.rst:255
msgid ""
"#!/usr/bin/env tarantool\n"
"-- Custom role implementation\n"
"local role_name = 'custom-role'\n"
"\n"
"local function init()\n"
"...\n"
"end\n"
"\n"
"local function stop()\n"
"...\n"
"end\n"
"\n"
"return {\n"
"    role_name = role_name,\n"
"    init = init,\n"
"    stop = stop,\n"
"}"
msgstr ""
"#!/usr/bin/env tarantool\n"
"-- Реализация пользовательской роли\n"
"local role_name = 'custom-role'\n"
"\n"
"local function init()\n"
"...\n"
"end\n"
"\n"
"local function stop()\n"
"...\n"
"end\n"
"\n"
"return {\n"
"    role_name = role_name,\n"
"    init = init,\n"
"    stop = stop,\n"
"}"

#: ../doc/book/cartridge/cartridge_dev.rst:275
msgid ""
"Where the ``role_name`` may differ from the module name passed to the "
"``cartridge.cfg()`` function. If the ``role_name`` variable is not "
"specified, the module name is the default value."
msgstr ""
"Где имя роли ``role_name`` может отличаться от имени модуля, переданного "
"в функции ``cartridge.cfg()``. Если не указать переменную ``role_name``, "
"по умолчанию будет использовано имя модуля."

#: ../doc/book/cartridge/cartridge_dev.rst:281
msgid ""
"Role names must be unique as it is impossible to register multiple roles "
"with the same name."
msgstr ""
"Имена ролей должны быть уникальными, поскольку невозможно "
"зарегистрировать несколько ролей с одним именем."

#: ../doc/book/cartridge/cartridge_dev.rst:284
msgid ""
"The role module does not have required functions but the cluster may "
"execute the following ones during the role's life cycle:"
msgstr ""
"В модуле роли нет необходимых функций, но в течение жизненного цикла роли"
" кластер может выполнять следующие функции:"

#: ../doc/book/cartridge/cartridge_dev.rst:287
msgid "``init()`` is the role's *initialization* function."
msgstr "``init()`` -- это функция *инициализации* роли."

#: ../doc/book/cartridge/cartridge_dev.rst:289
msgid ""
"Inside the function's body you can call any ``box`` functions: create "
"spaces, indexes, grant permissions, etc. Here is what the initialization "
"function may look like:"
msgstr ""
"В теле функции можно вызывать любые функции из ``box``: создавать спейсы,"
" индексы, выдавать права и т.д. Вот как может выглядеть функция "
"инициализации:"

#: ../doc/book/cartridge/cartridge_dev.rst:293
msgid ""
"local function init(opts)\n"
"    -- The cluster passes an 'opts' Lua table containing an 'is_master' "
"flag.\n"
"    if opts.is_master then\n"
"        local customer = box.schema.space.create('customer',\n"
"            { if_not_exists = true }\n"
"        )\n"
"        customer:format({\n"
"            {'customer_id', 'unsigned'},\n"
"            {'bucket_id', 'unsigned'},\n"
"            {'name', 'string'},\n"
"        })\n"
"        customer:create_index('customer_id', {\n"
"            parts = {'customer_id'},\n"
"            if_not_exists = true,\n"
"        })\n"
"    end\n"
"end"
msgstr ""
"local function init(opts)\n"
"    -- Кластер передает Lua-таблицу 'opts', которая содержит флаг "
"'is_master'.\n"
"    if opts.is_master then\n"
"        local customer = box.schema.space.create('customer',\n"
"            { if_not_exists = true }\n"
"        )\n"
"        customer:format({\n"
"            {'customer_id', 'unsigned'},\n"
"            {'bucket_id', 'unsigned'},\n"
"            {'name', 'string'},\n"
"        })\n"
"        customer:create_index('customer_id', {\n"
"            parts = {'customer_id'},\n"
"            if_not_exists = true,\n"
"        })\n"
"    end\n"
"end"

#: ../doc/book/cartridge/cartridge_dev.rst:316
msgid ""
"The function's body is wrapped in a conditional statement that lets you "
"call ``box`` functions on masters only. This protects against replication"
" collisions as data propagates to replicas automatically."
msgstr ""
"Тело функции заключено в условный оператор, который позволяет вызывать "
"функции ``box`` только на мастерах. Это предотвращает конфликты "
"репликации, так как данные автоматически передаются на реплики."

#: ../doc/book/cartridge/cartridge_dev.rst:321
msgid ""
"``stop()`` is the role's *termination* function. Implement it if "
"initialization starts a fiber that has to be stopped or does any job that"
" has to be undone on termination."
msgstr ""
"``stop()`` это функция *завершения работы* роли. Используйте ее, если "
"инициализация запускает файбер, который необходимо остановить, или же "
"выполняет любую задачу, которую следует отменить при завершении работы."

#: ../doc/book/cartridge/cartridge_dev.rst:325
msgid ""
"``validate_config()`` and ``apply_config()`` are *validation* and "
"*application* functions that make custom roles configurable. Implement "
"them if some configuration data has to be stored cluster-wide."
msgstr ""
"``validate_config()`` и ``apply_config()`` -- это функции *валидации* и "
"*применения  конфигурации* соответственно, которые обеспечивают "
"возможность настройки ролей. Используйте их, если некоторые настройки "
"должны храниться на уровне кластера."

#: ../doc/book/cartridge/cartridge_dev.rst:329
msgid ""
"Next, get a grip on the :ref:`role's life cycle <cartridge-role-"
"lifecycle>` to implement the necessary functions."
msgstr ""
"Затем изучите :ref:`жизненный цикл роли <cartridge-role-lifecycle>`, "
"чтобы реализовать необходимые функции."

#: ../doc/book/cartridge/cartridge_dev.rst:336
msgid "Defining role dependencies"
msgstr "Определение зависимостей для ролей"

#: ../doc/book/cartridge/cartridge_dev.rst:338
msgid ""
"You can instruct the cluster to apply some other roles if your custom "
"role is enabled."
msgstr ""
"Можно заставить кластер применить некоторые другие роли, если включена "
"пользовательская роль."

#: ../doc/book/cartridge/cartridge_dev.rst:343
msgid ""
"-- Role dependencies defined in custom-role.lua\n"
"local role_name = 'custom-role'\n"
"...\n"
"return {\n"
"    role_name = role_name,\n"
"    dependencies = {'cartridge.roles.vshard-router'},\n"
"    ...\n"
"}"
msgstr ""
"-- Зависимости между ролями, заданные в пользовательской роли custom-"
"role.lua\n"
"local role_name = 'custom-role'\n"
"...\n"
"return {\n"
"    role_name = role_name,\n"
"    dependencies = {'cartridge.roles.vshard-router'},\n"
"    ...\n"
"}"

#: ../doc/book/cartridge/cartridge_dev.rst:354
msgid ""
"Here ``vshard-router`` role will be initialized automatically for every "
"instance with ``custom-role`` enabled."
msgstr ""
"Здесь роль ``vshard-router`` будет инициализирована автоматически для "
"каждого экземпляра, в котором включена роль ``custom-role``."

#: ../doc/book/cartridge/cartridge_dev.rst:361
msgid "Using multiple vshard storage groups"
msgstr "Использование нескольких групп vshard storage"

#: ../doc/book/cartridge/cartridge_dev.rst:363
msgid ""
"Replica sets with ``vshard-storage`` roles can belong to different "
"*groups*. For example, ``hot`` or ``cold`` groups meant to independently "
"process hot and cold data."
msgstr ""
"Для наборов реплик с ролью ``vshard-storage`` можно задавать *группы*. "
"Например, группы ``hot`` и ``cold`` предназначены для независимой "
"обработки горячих и холодных данных."

#: ../doc/book/cartridge/cartridge_dev.rst:367
msgid "Groups are specified in the cluster's configuration:"
msgstr "Группы указаны в конфигурации кластера:"

#: ../doc/book/cartridge/cartridge_dev.rst:369
msgid ""
"cartridge.cfg({\n"
"    vshard_groups = {'hot', 'cold'},\n"
"    ...\n"
"})"
msgstr ""
"cartridge.cfg({\n"
"    vshard_groups = {'hot', 'cold'},\n"
"    ...\n"
"})"

#: ../doc/book/cartridge/cartridge_dev.rst:376
msgid ""
"If no groups are specified, the cluster assumes that all replica sets "
"belong to the ``default`` group."
msgstr ""
"Если ни одна группа не указана, кластер предполагает, что все наборы "
"реплик входят в группу ``default`` (по умолчанию)."

#: ../doc/book/cartridge/cartridge_dev.rst:379
msgid ""
"With multiple groups enabled, every replica set with a ``vshard-storage``"
" role enabled must be assigned to a particular group. The assignment can "
"never be changed."
msgstr ""
"Если включены несколько групп, каждый набор реплик с включенной ролью "
"``vshard-storage`` должен быть назначен в определенную группу. Эту "
"настройку нельзя изменить впоследствии."

#: ../doc/book/cartridge/cartridge_dev.rst:383
msgid ""
"Another limitation is that you cannot add groups dynamically (this will "
"become available in future)."
msgstr ""
"Есть еще одно ограничение -- нельзя добавлять группы динамически (такая "
"возможность появится в будущих версиях)."

#: ../doc/book/cartridge/cartridge_dev.rst:386
msgid ""
"Finally, mind the new syntax for router access. Every instance with a "
"``vshard-router`` role enabled initializes multiple routers. All of them "
"are accessible through the role:"
msgstr ""
"Наконец, обратите внимание на новый синтаксис для доступа к роутеру. "
"Каждый экземпляр со включенной ролью ``vshard-router`` инициализирует "
"несколько роутеров. Доступ к ним можно получить через роль:"

#: ../doc/book/cartridge/cartridge_dev.rst:390
msgid ""
"local router_role = cartridge.service_get('vshard-router')\n"
"router_role.get('hot'):call(...)"
msgstr ""
"local router_role = cartridge.service_get('vshard-router')\n"
"router_role.get('hot'):call(...)"

#: ../doc/book/cartridge/cartridge_dev.rst:395
msgid "If you have no roles specified, you can access a static router as before:"
msgstr ""
"Если роли не указаны, доступ к статическому роутеру можно получить, как и"
" прежде:"

#: ../doc/book/cartridge/cartridge_dev.rst:397
msgid ""
"local vhsard = require('vshard')\n"
"vshard.router.call(...)"
msgstr ""
"local vhsard = require('vshard')\n"
"vshard.router.call(...)"

#: ../doc/book/cartridge/cartridge_dev.rst:402
msgid ""
"However, when using the new API, you must call a static router with a "
"colon:"
msgstr ""
"Тем не менее, при использовании нового API следует вызывать статический "
"роутер при помощи двоеточия:"

#: ../doc/book/cartridge/cartridge_dev.rst:404
msgid ""
"local router_role = cartridge.service_get('vshard-router')\n"
"local default_router = router_role.get() -- or router_role.get('default')"
"\n"
"default_router:call(...)"
msgstr ""
"local router_role = cartridge.service_get('vshard-router')\n"
"local default_router = router_role.get() -- или "
"router_role.get('default')\n"
"default_router:call(...)"

#: ../doc/book/cartridge/cartridge_dev.rst:414
msgid "Role's life cycle and the order of function execution"
msgstr "Жизненный цикл роли и порядок выполнения функций"

#: ../doc/book/cartridge/cartridge_dev.rst:416
msgid ""
"The cluster displays all custom role names along with the built-in "
"``vshard`` ones in the web interface. Cluster administrators can enable "
"and disable them for particular instances either via the web interface or"
" cluster public API. For example:"
msgstr ""
"Кластер отображает все имена пользовательских ролей вместе с именами "
"встроенных ролей из ``vshard`` в веб-интерфейсе. Администраторы кластера "
"могут включать и отключать их для определенных экземпляров либо через "
"веб-интерфейс, либо через общедоступный API кластера. Например:"

#: ../doc/book/cartridge/cartridge_dev.rst:421
msgid ""
"cartridge.admin.edit_replicaset('replicaset-uuid', {roles = {'vshard-"
"router', 'custom-role'}})"
msgstr ""
"cartridge.admin.edit_replicaset('uuid-набора-реплик', {roles = {'vshard-"
"router', 'пользователськая-роль'}})"

#: ../doc/book/cartridge/cartridge_dev.rst:425
msgid ""
"If multiple roles are enabled on an instance at the same time, the "
"cluster first initializes the built-in roles (if any) and then the custom"
" ones (if any) in the order the latter were listed in "
"``cartridge.cfg()``."
msgstr ""
"Если несколько ролей одновременно включены на экземпляре, кластер сначала"
" инициализирует встроенные роли (если они есть), а затем пользовательские"
" (если они есть) в том порядке, в котором последние были перечислены в "
"``cartridge.cfg()``."

#: ../doc/book/cartridge/cartridge_dev.rst:429
msgid ""
"If a custom role has dependent roles, the dependencies are registered and"
" validated first, prior to the role itself."
msgstr ""
"Если у пользовательской роли есть зависимые роли, сначала происходит "
"регистрация и валидация зависимостей, а затем уже самой роли."

#: ../doc/book/cartridge/cartridge_dev.rst:432
msgid "The cluster calls the role's functions in the following circumstances:"
msgstr "Кластер вызывает функции роли в следующих случаях:"

#: ../doc/book/cartridge/cartridge_dev.rst:434
msgid ""
"The ``init()`` function, typically, once: either when the role is enabled"
" by the administrator or at the instance restart. Enabling a role once is"
" normally enough."
msgstr ""
"Функция ``init()`` обычно выполняется один раз: либо когда администратор "
"включает роль, либо при перезапуске экземпляра. Как правило, достаточно "
"один раз включить роль."

#: ../doc/book/cartridge/cartridge_dev.rst:438
msgid ""
"The ``stop()`` function -- only when the administrator disables the role,"
" not on instance termination."
msgstr ""
"Функция ``stop()`` -- только когда администратор отключает роль, а не во "
"время завершения работы экземпляра."

#: ../doc/book/cartridge/cartridge_dev.rst:441
msgid ""
"The ``validate_config()`` function, first, before the automatic "
"``box.cfg()`` call (database initialization), then -- upon every "
"configuration update."
msgstr ""
"Функция ``validate_config()``: сначала до автоматического вызова "
"`box.cfg()`` (инициализация базы данных), а затем при каждом обновлении "
"конфигурации."

#: ../doc/book/cartridge/cartridge_dev.rst:444
msgid "The ``apply_config()`` function upon every configuration update."
msgstr "Функция ``apply_config()`` -- при каждом обновлении конфигурации."

#: ../doc/book/cartridge/cartridge_dev.rst:446
msgid ""
"Hence, if the cluster is tasked with performing the following actions, it"
" will execute the functions listed in the following order:"
msgstr ""
"Таким образом, если поставить для кластера задачу выполнить следующие "
"действия, он будет выполнять перечисленные функции в следующем порядке:"

#: ../doc/book/cartridge/cartridge_dev.rst:449
msgid "Join an instance or create a replica set, both with an enabled role:"
msgstr ""
"Присоединение экземпляра или создание набора реплик (в обоих случаях с "
"включенной ролью):"

#: ../doc/book/cartridge/cartridge_dev.rst:451
#: ../doc/book/cartridge/cartridge_dev.rst:457
#: ../doc/book/cartridge/cartridge_dev.rst:465
#: ../doc/book/cartridge/cartridge_dev.rst:470
msgid "``validate_config()``"
msgstr "``validate_config()``"

#: ../doc/book/cartridge/cartridge_dev.rst:452
#: ../doc/book/cartridge/cartridge_dev.rst:458
msgid "``init()``"
msgstr "``init()``"

#: ../doc/book/cartridge/cartridge_dev.rst:453
#: ../doc/book/cartridge/cartridge_dev.rst:459
#: ../doc/book/cartridge/cartridge_dev.rst:466
#: ../doc/book/cartridge/cartridge_dev.rst:471
msgid "``apply_config()``"
msgstr "``apply_config()``"

#: ../doc/book/cartridge/cartridge_dev.rst:455
msgid "Restart an instance with an enabled role:"
msgstr "Перезапуск экземпляра с включенной ролью:"

#: ../doc/book/cartridge/cartridge_dev.rst:461
msgid "Disable role: ``stop()``."
msgstr "Отключение роли: ``stop()``."

#: ../doc/book/cartridge/cartridge_dev.rst:463
msgid "Upon the ``cartridge.confapplier.patch_clusterwide()`` call:"
msgstr "При вызове ``cartridge.confapplier.patch_clusterwide()``:"

#: ../doc/book/cartridge/cartridge_dev.rst:468
msgid "Upon a triggered failover:"
msgstr "При запущенном восстановлении после отказа:"

#: ../doc/book/cartridge/cartridge_dev.rst:473
msgid "Considering the described behavior:"
msgstr "Учитывая вышеописанное поведение:"

#: ../doc/book/cartridge/cartridge_dev.rst:475
msgid "The ``init()`` function may:"
msgstr "Функция ``init()`` может:"

#: ../doc/book/cartridge/cartridge_dev.rst:477
msgid "Call ``box`` functions."
msgstr "Вызывать функции ``box``."

#: ../doc/book/cartridge/cartridge_dev.rst:478
msgid ""
"Start a fiber and, in this case, the ``stop()`` function should take care"
" of the fiber's termination."
msgstr ""
"Запускать файбер, и в таком случае функция ``stop()`` должна позаботиться"
" о завершении работы файбера."

#: ../doc/book/cartridge/cartridge_dev.rst:480
msgid "Configure the built-in :ref:`HTTP server <cartridge-httpd-instance>`."
msgstr "Настраивать встроенный :ref:`HTTP-сервер <cartridge-httpd-instance>`."

#: ../doc/book/cartridge/cartridge_dev.rst:481
msgid "Execute any code related to the role's initialization."
msgstr "Выполнять любой код, связанный с инициализацией роли."

#: ../doc/book/cartridge/cartridge_dev.rst:483
msgid ""
"The ``stop()`` functions must undo any job that has to be undone on "
"role's termination."
msgstr ""
"Функции ``stop()`` должны отменять любую задачу, которую необходимо "
"отменить при завершении работы роли."

#: ../doc/book/cartridge/cartridge_dev.rst:486
msgid "The ``validate_config()`` function must validate any configuration change."
msgstr ""
"Функция ``validate_config()`` должна валидировать любые изменения "
"конфигурации."

#: ../doc/book/cartridge/cartridge_dev.rst:488
msgid ""
"The ``apply_config()`` function may execute any code related to a "
"configuration change, e.g., take care of an ``expirationd`` fiber."
msgstr ""
"Функция ``apply_config()`` может выполнять любой код, связанный с "
"изменением конфигурации, например, следить за файбером ``expirationd``."

#: ../doc/book/cartridge/cartridge_dev.rst:491
msgid ""
"The validation and application functions together allow you to customize "
"the cluster-wide configuration as described in the :ref:`next section "
"<cartridge-role-config>`."
msgstr ""
"Функции валидации и применения конфигурации вместе позволяют настраивать "
"конфигурацию всего кластера, как описано в :ref:`следующем разделе "
"<cartridge-role-config>`."

#: ../doc/book/cartridge/cartridge_dev.rst:499
msgid "Configuring custom roles"
msgstr "Конфигурация пользовательских ролей"

#: ../doc/book/cartridge/cartridge_dev.rst:503
msgid ""
"Store configurations for your custom roles as sections in cluster-wide "
"configuration, for example:"
msgstr ""
"Хранить настройки пользовательских ролей в виде разделов в конфигурации "
"на уровне кластера, например:"

#: ../doc/book/cartridge/cartridge_dev.rst:506
msgid ""
"# YAML configuration file\n"
"my_role:\n"
"  notify_url: \"https://localhost:8080\""
msgstr ""
"# YAML configuration file\n"
"my_role:\n"
"  notify_url: \"https://localhost:8080\""

#: ../doc/book/cartridge/cartridge_dev.rst:512
msgid ""
"-- init.lua file\n"
"local notify_url = 'http://localhost'\n"
"function my_role.apply_config(conf, opts)\n"
"  local conf = conf['my_role'] or {}\n"
"  notify_url = conf.notify_url or 'default'\n"
"end"
msgstr ""
"-- init.lua file\n"
"local notify_url = 'http://localhost'\n"
"function my_role.apply_config(conf, opts)\n"
"  local conf = conf['my_role'] or {}\n"
"  notify_url = conf.notify_url or 'default'\n"
"end"

#: ../doc/book/cartridge/cartridge_dev.rst:521
msgid ""
"Download and upload cluster-wide configuration using :ref:`cluster UI "
"<cartridge-ui-configuration>` or API (via GET/PUT queries to "
"``admin/config`` endpoint like ``curl localhost:8081/admin/config`` and "
"``curl -X PUT -d \"{'my_parameter': 'value'}\" "
"localhost:8081/admin/config``)."
msgstr ""
"Загружать и выгружать конфигурацию всего кластера через "
":ref:`веб-интерфейс кластера <cartridge-ui-configuration>` или с помощью "
"API (запросы GET/PUT к конечной точке ``admin/config``: ``curl "
"localhost:8081/admin/config`` и ``curl -X PUT -d \"{'my_parameter': "
"'value'}\" localhost:8081/admin/config``)."

#: ../doc/book/cartridge/cartridge_dev.rst:527
msgid "Utilize it in your role ``apply_config()`` function."
msgstr "Использовать ее в своей функции ``apply_config()``."

#: ../doc/book/cartridge/cartridge_dev.rst:529
msgid ""
"Every instance in the cluster stores a copy of the configuration file in "
"its working directory (configured by ``cartridge.cfg({workdir = ...})``):"
msgstr ""
"Каждый экземпляр в кластере хранит копию конфигурационного файла в своей "
"рабочей директории (которую можно задать с помощью "
"``cartridge.cfg({workdir = ...})``):"

#: ../doc/book/cartridge/cartridge_dev.rst:532
msgid ""
"``/var/lib/tarantool/<instance_name>/config.yml`` for instances deployed "
"from RPM packages and managed by ``systemd``."
msgstr ""
"``/var/lib/tarantool/<instance_name>/config.yml`` для экземпляров, "
"развернутых из RPM-пакетов, под управлением ``systemd``."

#: ../doc/book/cartridge/cartridge_dev.rst:534
msgid ""
"``/home/<username>/tarantool_state/var/lib/tarantool/config.yml`` for "
"instances deployed from archives."
msgstr ""
"``/home/<username>/tarantool_state/var/lib/tarantool/config.yml`` для "
"экземпляров, развернутых из архивов, под управлением ``tarantoolctl``."

#: ../doc/book/cartridge/cartridge_dev.rst:537
msgid ""
"The cluster's configuration is a Lua table, downloaded and uploaded as "
"YAML. If some application-specific configuration data, e.g., a database "
"schema as defined by DDL (data definition language), has to be stored on "
"every instance in the cluster, you can implement your own API by adding a"
" custom section to the table. The cluster will help you spread it safely "
"across all instances."
msgstr ""
"Конфигурация кластера представляет собой Lua-таблицу. Если некоторые "
"данные конфигурации для конкретного приложения (например, схему базы "
"данных, описанную с помощью языка определения данных DDL) необходимо "
"хранить в каждом экземпляре кластера, можно использовать свой собственный"
" API, добавив в таблицу специальный раздел. Кластер поможет вам безопасно"
" передать его всем экземплярам."

#: ../doc/book/cartridge/cartridge_dev.rst:543
msgid ""
"Such section goes in parallel (in the same file) with the topology-"
"specific and ``vshard``-specific ones the cluster automatically "
"generates. Unlike the generated, the custom section's modification, "
"validation, and application logic has to be defined."
msgstr ""
"Такой раздел создается параллельно (в одном файле) с разделами о "
"топологии и о ``vshard``, которые кластер генерирует автоматически. В "
"отличие от сгенерированных разделов, логику изменения, проверки и "
"применения конфигурации в специальном разделе необходимо определять "
"вручную."

#: ../doc/book/cartridge/cartridge_dev.rst:548
msgid "The common way is to define two functions:"
msgstr "Самый распространенный способ заключается в том, чтобы:"

#: ../doc/book/cartridge/cartridge_dev.rst:550
msgid ""
"``validate_config(conf_new, conf_old)`` to validate changes made in the "
"new configuration (``conf_new``) versus the old configuration "
"(``conf_old``)."
msgstr ""
"``validate_config(conf_new, conf_old)`` для валидации изменений, "
"сделанных в новой конфигурации (``conf_new``) по отношению к старой "
"конфигурации (``conf_old``)."

#: ../doc/book/cartridge/cartridge_dev.rst:552
msgid ""
"``apply_config(conf, opts)`` to execute any code related to a "
"configuration change. As input, this function takes the configuration to "
"apply (``conf``, which is actually the new configuration that you "
"validated earlier with ``validate_config()``) and options (the ``opts`` "
"argument that includes ``is_master``, a Boolean flag described later)."
msgstr ""
"``apply_config(conf, opts)`` для выполнения любого кода, связанного с "
"изменениями конфигурации. Входными данными для этой функции будут "
"применяемая конфигурация (``conf``, которая и есть новая конфигурация, "
"проверенная чуть ранее с помощью ``validate_config()``), а также "
"параметры (аргумент ``opts`` включает в себя описываемый ниже логический "
"флаг ``is_master`` )."

#: ../doc/book/cartridge/cartridge_dev.rst:560
msgid ""
"The ``validate_config()`` function must detect all configuration problems"
" that may lead to ``apply_config()`` errors. For more information, see "
"the :ref:`next section <cartridge-role-config-apply>`."
msgstr ""
"Функция ``validate_config()`` должна обнаружить все проблемы "
"конфигурации, которые могут привести к ошибкам ``apply_config()``. Для "
"получения дополнительной информации см. :ref:`следующий раздел "
"<cartridge-role-config-apply>`."

#: ../doc/book/cartridge/cartridge_dev.rst:564
msgid ""
"When implementing validation and application functions that call ``box`` "
"ones for some reason, the following precautions apply:"
msgstr ""
"При реализации функций валидации и применения конфигурации, которые по "
"какой-либо причине вызывают функции ``box``, следует принять следующие "
"меры предосторожности:"

#: ../doc/book/cartridge/cartridge_dev.rst:567
msgid ""
"Due to the :ref:`role's life cycle <cartridge-role-lifecycle>`, the "
"cluster does not guarantee an automatic ``box.cfg()`` call prior to "
"calling ``validate_config()``."
msgstr ""
":ref:`Жизненный цикл роли <cartridge-role-lifecycle>` не предполагает, "
"что кластер автоматически вызовет ``box.cfg()`` до вызова "
"``validate_config()``."

#: ../doc/book/cartridge/cartridge_dev.rst:571
msgid ""
"If the validation function is to call any ``box`` functions (e.g., to "
"check a format), make sure the calls are wrapped in a protective "
"conditional statement that checks if ``box.cfg()`` has already happened:"
msgstr ""
"Если функция валидации должна вызвать какие-либо функции из ``box`` "
"(например, для проверки формата), убедитесь, что вызовы заключены в "
"защитный условный оператор, который проверяет, произошел ли уже вызов "
"``box.cfg()``:"

#: ../doc/book/cartridge/cartridge_dev.rst:575
msgid ""
"-- Inside the validation function:\n"
"\n"
"if type(box.cfg) == 'function' then\n"
"\n"
"    -- Here you can call box functions\n"
"\n"
"end"
msgstr ""
"-- В рамках функции валидации:\n"
"\n"
"if type(box.cfg) == 'function' then\n"
"\n"
"    -- Здесь можно вызвать функции из box\n"
"\n"
"end"

#: ../doc/book/cartridge/cartridge_dev.rst:586
msgid ""
"Unlike the validation and similar to initialization function, "
"``apply_config()`` can call ``box`` functions freely as the cluster "
"applies custom configuration after the automatic ``box.cfg()`` call."
msgstr ""
"В отличие от функции валидации, как и в случае с функцией инициализации, "
"``apply_config()`` может свободно вызывать функции из ``box``, поскольку "
"кластер применяет пользовательскую конфигурацию после автоматического "
"вызова ``box.cfg()``."

#: ../doc/book/cartridge/cartridge_dev.rst:590
msgid ""
"However, creating spaces, users, etc., can cause replication collisions "
"when performed on both master and replica instances simultaneously. The "
"appropriate way is to call such ``box`` functions on masters only and let"
" the changes propagate to replicas automatically."
msgstr ""
"Однако создание спейсов, пользователей и т.п. может привести к конфликтам"
" репликации при одновременном выполнении на мастере и на реплике. "
"Оптимальный способ заключается в том, чтобы вызывать такие функции из "
"``box`` только на мастерах и автоматически передавать изменения на "
"реплики."

#: ../doc/book/cartridge/cartridge_dev.rst:595
msgid ""
"Upon the ``apply_config(conf, opts)`` execution, the cluster passes an "
"``is_master`` flag in the ``opts`` table which you can use to wrap "
"collision-inducing ``box`` functions in a protective conditional "
"statement:"
msgstr ""
"По выполнении ``apply_config(conf, opts)`` кластер передает флаг "
"``is_master`` в таблице ``opts``, который можно использовать для "
"заключения функций из ``box`` в защитный условный оператор, если они "
"могут вызвать конфликт:"

#: ../doc/book/cartridge/cartridge_dev.rst:599
msgid ""
"-- Inside the configuration application function:\n"
"\n"
"if opts.is_master then\n"
"\n"
"    -- Here you can call box functions\n"
"\n"
"end"
msgstr ""
"-- В рамках функции применения конфигурации:\n"
"\n"
"if opts.is_master then\n"
"\n"
"    -- Here you can call box functions\n"
"\n"
"end"

#: ../doc/book/cartridge/cartridge_dev.rst:614
msgid "Custom configuration example"
msgstr "Пример пользовательской конфигурации"

#: ../doc/book/cartridge/cartridge_dev.rst:616
msgid ""
"Consider the following code as part of the role's module (``custom-"
"role.lua``) implementation:"
msgstr ""
"Рассмотрим следующий код как часть реализации модуля роли (``custom-"
"role.lua``):"

#: ../doc/book/cartridge/cartridge_dev.rst:619
msgid ""
"#!/usr/bin/env tarantool\n"
"-- Custom role implementation\n"
"\n"
"local cartridge = require('cartridge')\n"
"\n"
"local role_name = 'custom-role'\n"
"\n"
"-- Modify the config by implementing some setter (an alternative to HTTP "
"PUT)\n"
"local function set_secret(secret)\n"
"    local custom_role_cfg = cartridge.confapplier.get_deepcopy(role_name)"
" or {}\n"
"    custom_role_cfg.secret = secret\n"
"    cartridge.confapplier.patch_clusterwide({\n"
"        [role_name] = custom_role_cfg,\n"
"    })\n"
"end\n"
"-- Validate\n"
"local function validate_config(cfg)\n"
"    local custom_role_cfg = cfg[role_name] or {}\n"
"    if custom_role_cfg.secret ~= nil then\n"
"        assert(type(custom_role_cfg.secret) == 'string', 'custom-"
"role.secret must be a string')\n"
"    end\n"
"    return true\n"
"end\n"
"-- Apply\n"
"local function apply_config(cfg)\n"
"    local custom_role_cfg = cfg[role_name] or {}\n"
"    local secret = custom_role_cfg.secret or 'default-secret'\n"
"    -- Make use of it\n"
"end\n"
"\n"
"return {\n"
"    role_name = role_name,\n"
"    set_secret = set_secret,\n"
"    validate_config = validate_config,\n"
"    apply_config = apply_config,\n"
"}"
msgstr ""
"#!/usr/bin/env tarantool\n"
"-- Реализация пользовательской роли\n"
"\n"
"local cartridge = require('cartridge')\n"
"\n"
"local role_name = 'custom-role'\n"
"\n"
"-- Изменение конфигурации с вводом сеттера (альтернатива HTTP PUT)\n"
"local function set_secret(secret)\n"
"    local custom_role_cfg = cartridge.confapplier.get_deepcopy(role_name)"
" or {}\n"
"    custom_role_cfg.secret = secret\n"
"    cartridge.confapplier.patch_clusterwide({\n"
"        [role_name] = custom_role_cfg,\n"
"    })\n"
"end\n"
"-- Валидация\n"
"local function validate_config(cfg)\n"
"    local custom_role_cfg = cfg[role_name] or {}\n"
"    if custom_role_cfg.secret ~= nil then\n"
"        assert(type(custom_role_cfg.secret) == 'string', 'custom-"
"role.secret must be a string')\n"
"    end\n"
"    return true\n"
"end\n"
"-- Применение\n"
"local function apply_config(cfg)\n"
"    local custom_role_cfg = cfg[role_name] or {}\n"
"    local secret = custom_role_cfg.secret or 'default-secret'\n"
"    -- Make use of it\n"
"end\n"
"\n"
"return {\n"
"    role_name = role_name,\n"
"    set_secret = set_secret,\n"
"    validate_config = validate_config,\n"
"    apply_config = apply_config,\n"
"}"

#: ../doc/book/cartridge/cartridge_dev.rst:658
msgid "Once the configuration is customized, do one of the following:"
msgstr "После настройки конфигурации выполните одно из следующих действий:"

#: ../doc/book/cartridge/cartridge_dev.rst:660
msgid ""
"continue developing your application and pay attention to its "
":ref:`versioning <cartridge-versioning>`;"
msgstr ""
"продолжите разработку приложения, обращая особое внимание на "
":ref:`управление версиями <cartridge-versioning>`;"

#: ../doc/book/cartridge/cartridge_dev.rst:662
msgid ""
"(optional) :ref:`enable authorization <cartridge-auth-enable>` in the web"
" interface."
msgstr ""
"(необязательно) :ref:`включите авторизацию <cartridge-auth-enable>` в "
"веб-интерфейсе."

#: ../doc/book/cartridge/cartridge_dev.rst:663
msgid ""
"in case the cluster is already deployed, :ref:`apply the configuration "
"<cartridge-role-config-apply>` cluster-wide."
msgstr ""
"если кластер уже развернут, :ref:`примените конфигурацию <cartridge-role-"
"config-apply>` для всего кластера."

#: ../doc/book/cartridge/cartridge_dev.rst:670
msgid "Applying custom role's configuration"
msgstr "Применение конфигурации пользовательской роли"

#: ../doc/book/cartridge/cartridge_dev.rst:672
msgid ""
"With the implementation showed by the :ref:`example <cartridge-role-"
"config-example>`, you can call the ``set_secret()`` function to apply the"
" new configuration via the administrative console or an HTTP endpoint if "
"the role exports one."
msgstr ""
"В :ref:`примере <cartridge-role-config-example>` реализации можно вызвать"
" функцию ``set_secret()``, чтобы применить новую конфигурацию с помощью "
"административной консоли или конечной точки HTTP, если роль экспортирует "
"таковую."

#: ../doc/book/cartridge/cartridge_dev.rst:676
msgid ""
"The ``set_secret()`` function calls "
"``cartridge.confapplier.patch_clusterwide()`` which performs a two-phase "
"commit:"
msgstr ""
"Функция ``set_secret()`` вызывает "
"``cartridge.confapplier.patch_clusterwide()``, которая производит "
"двухфазную фиксацию транзакций:"

#: ../doc/book/cartridge/cartridge_dev.rst:679
msgid ""
"It patches the active configuration in memory: copies the table and "
"replaces the ``\"custom-role\"`` section in the copy with the one given "
"by the ``set_secret()`` function."
msgstr ""
"Исправляет активную конфигурацию в памяти: копирует таблицу и заменяет "
"раздел ``\"custom-role\"`` в копии на раздел, который задан функцией "
"``set_secret()``."

#: ../doc/book/cartridge/cartridge_dev.rst:683
#, fuzzy
msgid ""
"The cluster checks if the new configuration can be applied on all "
"instances except disabled and expelled. All instances subject to update "
"must be healthy and ``alive`` according to the `membership module "
"<https://www.tarantool.io/en/doc/2.2/reference/reference_rock/membership/>`_."
msgstr ""
"Кластер проверяет, можно ли применить новую конфигурацию ко всем "
"экземплярам, кроме отключенных и исключенных. Все обновляемые экземпляры "
"должны быть исправными и рабочими в соответствии с требованиями `модуля "
"membership "
"<https://www.tarantool.io/en/doc/1.10/reference/reference_rock/membership/>`_."

#: ../doc/book/cartridge/cartridge_dev.rst:688
msgid ""
"(**Preparation phase**) The cluster propagates the patched configuration."
" Every instance validates it with the ``validate_config()`` function of "
"every registered role. Depending on the validation's result:"
msgstr ""
"(**Фаза подготовки**) Кластер передает исправленную конфигурацию. Каждый "
"экземпляр валидирует ее с помощью функции ``validate_config()`` каждой "
"зарегистрированной роли. В зависимости от результата валидации:"

#: ../doc/book/cartridge/cartridge_dev.rst:692
msgid ""
"If successful (i.e., returns ``true``), the instance saves the new "
"configuration to a temporary file named ``config.prepare.yml`` within the"
" working directory."
msgstr ""
"В случае успеха (то есть возврата значения ``true``) экземпляр сохраняет "
"новую конфигурацию во временный файл с именем ``config.prepare.yml`` в "
"рабочей директории."

#: ../doc/book/cartridge/cartridge_dev.rst:695
msgid ""
"(**Abort phase**) Otherwise, the instance reports an error and all other "
"instances roll back the update: remove the file they may have already "
"prepared."
msgstr ""
"(**Фаза отмены**) В противном случае экземпляр сообщает об ошибке, а все "
"остальные экземпляры откатывают обновление: удаляют файл, который они, "
"возможно, уже подготовили."

#: ../doc/book/cartridge/cartridge_dev.rst:699
msgid ""
"(**Commit phase**) Upon successful preparation of all instances, the "
"cluster commits the changes. Every instance:"
msgstr ""
"(**Фаза фиксации**) После успешной подготовки всех экземпляров кластер "
"фиксирует изменения. Каждый экземпляр:"

#: ../doc/book/cartridge/cartridge_dev.rst:702
msgid "Creates the active configuration's hard-link."
msgstr "Создает жесткую ссылку активной конфигурации."

#: ../doc/book/cartridge/cartridge_dev.rst:703
msgid ""
"Atomically replaces the active one with the prepared. The atomic "
"replacement is indivisible -- it can either succeed or fail entirely, "
"never partially."
msgstr ""
"Атомарно заменяет активную на подготовленную. Атомарная замена неделима, "
"то есть она может быть либо выполнена, либо не выполнена полностью, но не"
" частично."

#: ../doc/book/cartridge/cartridge_dev.rst:706
msgid "Calls the ``apply_config()`` function of every registered role."
msgstr "Вызывает функцию ``apply_config()`` каждой зарегистрированной роли."

#: ../doc/book/cartridge/cartridge_dev.rst:708
msgid ""
"If any of these steps fail, an error pops up in the web interface next to"
" the corresponding instance. The cluster does not handle such errors "
"automatically, they require manual repair."
msgstr ""
"Если любой из этих шагов не будет выполнен, в веб-интерфейсе появится "
"ошибка рядом с соответствующим экземпляром. Кластер не обрабатывает такие"
" ошибки автоматически, их необходимо исправлять вручную."

#: ../doc/book/cartridge/cartridge_dev.rst:712
msgid ""
"You will avoid the repair if the ``validate_config()`` function can "
"detect all configuration problems that may lead to ``apply_config()`` "
"errors."
msgstr ""
"Такого рода исправлений можно избежать, если функция "
"``validate_config()`` сможет обнаружить все проблемы конфигурации, "
"которые могут привести к ошибкам в ``apply_config()``."

#: ../doc/book/cartridge/cartridge_dev.rst:719
msgid "Using the built-in HTTP server"
msgstr "Использование встроенного HTTP-сервера"

#: ../doc/book/cartridge/cartridge_dev.rst:721
msgid ""
"The cluster launches an ``httpd`` server instance during initialization "
"(``cartridge.cfg()``). You can bind a port to the instance via an "
"environmental variable:"
msgstr ""
"Кластер запускает экземпляр ``httpd``-сервера во время инициализации "
"(``cartridge.cfg()``). Можно привязать порт к экземпляру через переменную"
" окружения:"

#: ../doc/book/cartridge/cartridge_dev.rst:725
msgid ""
"-- Get the port from an environmental variable or the default one:\n"
"local http_port = os.getenv('HTTP_PORT') or '8080'\n"
"\n"
"local ok, err = cartridge.cfg({\n"
"   ...\n"
"   -- Pass the port to the cluster:\n"
"   http_port = http_port,\n"
"   ...\n"
"})"
msgstr ""
"-- Получение порта из переменной окружения или используемого по "
"умолчанию:\n"
"local http_port = os.getenv('HTTP_PORT') or '8080'\n"
"\n"
"local ok, err = cartridge.cfg({\n"
"   ...\n"
"   -- Передача порта в кластер:\n"
"   http_port = http_port,\n"
"   ...\n"
"})"

#: ../doc/book/cartridge/cartridge_dev.rst:737
msgid ""
"To make use of the ``httpd`` instance, access it and configure routes "
"inside the ``init()`` function of some role, e.g. a role that exposes API"
" over HTTP:"
msgstr ""
"Чтобы использовать ``httpd``-экземпляр, получите к нему доступ и "
"настройте маршруты в рамках функции ``init()`` для какой-либо роли "
"(например, для  роли, которая предоставляет API через HTTP):"

#: ../doc/book/cartridge/cartridge_dev.rst:740
msgid ""
"local function init(opts)\n"
"\n"
"...\n"
"\n"
"   -- Get the httpd instance:\n"
"   local httpd = cartridge.service_get('httpd')\n"
"   if httpd ~= nil then\n"
"       -- Configure a route to, for example, metrics:\n"
"       httpd:route({\n"
"               method = 'GET',\n"
"               path = '/metrics',\n"
"               public = true,\n"
"           },\n"
"           function(req)\n"
"               return req:render({json = stat.stat()})\n"
"           end\n"
"       )\n"
"   end\n"
"end"
msgstr ""
"local function init(opts)\n"
"\n"
"...\n"
"\n"
"   -- Получение httpd-экземпляра:\n"
"   local httpd = cartridge.service_get('httpd')\n"
"   if httpd ~= nil then\n"
"       -- Настройка маршрута, к примеру, к метрике:\n"
"       httpd:route({\n"
"               method = 'GET',\n"
"               path = '/metrics',\n"
"               public = true,\n"
"           },\n"
"           function(req)\n"
"               return req:render({json = stat.stat()})\n"
"           end\n"
"       )\n"
"   end\n"
"end"

#: ../doc/book/cartridge/cartridge_dev.rst:762
msgid ""
"For more information on the usage of Tarantool's HTTP server, see `its "
"documentation <https://github.com/tarantool/http>`_."
msgstr ""
"Для получения дополнительной информации об использовании HTTP-сервера "
"Tarantool обратитесь к `соответствующей документации "
"<https://github.com/tarantool/http>`_."

#: ../doc/book/cartridge/cartridge_dev.rst:769
msgid "Implementing authorization in the web interface"
msgstr "Реализация авторизации в веб-интерфейсе"

#: ../doc/book/cartridge/cartridge_dev.rst:771
msgid ""
"To implement authorization in the web interface of every instance in "
"Tarantool cluster:"
msgstr ""
"Чтобы реализовать авторизацию в веб-интерфейсе каждого экземпляра в "
"кластере Tarantool'а:"

#: ../doc/book/cartridge/cartridge_dev.rst:774
msgid ""
"Implement a new, say, ``auth`` module with a ``check_password`` function."
" It should check the credentials of any user trying to log in to the web "
"interface."
msgstr ""
"Используйте модуль, к примеру, ``auth`` с функцией ``check_password``. "
"Данная функция проверяет учетные данные любого пользователя, который "
"пытается войти в веб-интерфейс."

#: ../doc/book/cartridge/cartridge_dev.rst:777
msgid ""
"The ``check_password`` function accepts a username and password and "
"returns an authentication success or failure."
msgstr ""
"Функция ``check_password`` принимает имя пользователя и пароль и "
"возвращает результат аутентификации: пройдена или нет."

#: ../doc/book/cartridge/cartridge_dev.rst:780
msgid ""
"-- auth.lua\n"
"\n"
"-- Add a function to check the credentials\n"
"local function check_password(username, password)\n"
"\n"
"    -- Check the credentials any way you like\n"
"\n"
"    -- Return an authentication success or failure\n"
"    if not ok then\n"
"        return false\n"
"    end\n"
"    return true\n"
"end\n"
"..."
msgstr ""
"-- auth.lua\n"
"\n"
"-- Добавление функции для проверки учетных данных\n"
"local function check_password(username, password)\n"
"\n"
"    -- Проверка учетных данных любым способом\n"
"\n"
"    -- Возврат пройденной или непройденной аутентификации\n"
"    if not ok then\n"
"        return false\n"
"    end\n"
"    return true\n"
"end\n"
"..."

#: ../doc/book/cartridge/cartridge_dev.rst:797
msgid ""
"Pass the implemented ``auth`` module name as a parameter to "
"``cartridge.cfg()``, so the cluster can use it:"
msgstr ""
"Передайте имя используемого модуля ``auth`` в качестве параметра для "
"``cartridge.cfg()``, чтобы кластер мог использовать его:"

#: ../doc/book/cartridge/cartridge_dev.rst:800
msgid ""
"-- init.lua\n"
"\n"
"local ok, err = cartridge.cfg({\n"
"    auth_backend_name = 'auth',\n"
"    -- The cluster will automatically call 'require()' on the 'auth' "
"module.\n"
"    ...\n"
"})"
msgstr ""
"-- init.lua\n"
"\n"
"local ok, err = cartridge.cfg({\n"
"    auth_backend_name = 'auth',\n"
"    -- Кластер автоматически вызовет 'require()' для модуля 'auth'.\n"
"    ...\n"
"})"

#: ../doc/book/cartridge/cartridge_dev.rst:810
msgid ""
"This adds a **Log in** button to the upper right corner of the web "
"interface but still lets the unsigned users interact with the interface. "
"This is convenient for testing."
msgstr ""
"Это добавит кнопку **Log in** (Войти) в верхний правый угол в "
"веб-интерфейсе, но все же позволит неавторизованным пользователям "
"взаимодействовать с интерфейсом, что удобно для тестирования."

#: ../doc/book/cartridge/cartridge_dev.rst:816
msgid ""
"Also, to authorize requests to cluster API, you can use the HTTP basic "
"authorization header."
msgstr ""
"Кроме того, для авторизации запросов к API кластера можно использовать "
"базовый заголовок HTTP для авторизации."

#: ../doc/book/cartridge/cartridge_dev.rst:819
msgid ""
"To require the authorization of every user in the web interface even "
"before the cluster bootstrap, add the following line:"
msgstr ""
"Чтобы требовать авторизацию каждого пользователя в веб-интерфейсе даже до"
" начальной загрузки кластера, добавьте следующую строку:"

#: ../doc/book/cartridge/cartridge_dev.rst:822
msgid ""
"-- init.lua\n"
"\n"
"local ok, err = cartridge.cfg({\n"
"    auth_backend_name = 'auth',\n"
"    auth_enabled = true,\n"
"    ...\n"
"})"
msgstr ""
"-- init.lua\n"
"\n"
"local ok, err = cartridge.cfg({\n"
"    auth_backend_name = 'auth',\n"
"    auth_enabled = true,\n"
"    ...\n"
"})"

#: ../doc/book/cartridge/cartridge_dev.rst:833
msgid ""
"With the authentication enabled and the ``auth`` module implemented, the "
"user will not be able to even bootstrap the cluster without logging in. "
"After the successful login and bootstrap, the authentication can be "
"enabled and disabled cluster-wide in the web interface and the "
"``auth_enabled`` parameter is ignored."
msgstr ""
"С включенной аутентификацией при использовании модуля ``auth`` "
"пользователь не сможет даже загрузить кластер без входа в систему. После "
"успешного входа в систему и начальной загрузки можно включить и отключить"
" аутентификацию для всего кластера в веб-интерфейсе, а параметр "
"``auth_enabled`` игнорируется."

#: ../doc/book/cartridge/cartridge_dev.rst:843
msgid "Application versioning"
msgstr "Управление версиями приложения"

#: ../doc/book/cartridge/cartridge_dev.rst:845
msgid ""
"Tarantool Cartridge understands semantic versioning as described at "
"`semver.org <https://semver.org>`_. When developing an application, "
"create new Git branches and tag them appropriately. These tags are used "
"to calculate version increments for subsequent packaging."
msgstr ""
"В Tarantool Cartridge семантическое управление версиями осуществляется "
"так, как описано на сайте `semver.org <https://semver.org>`_. При "
"разработке приложения создайте новые ветки Git и пометьте их "
"соответствующими тегами. Эти теги используются для расчета увеличения "
"значения версий для последующей упаковки."

#: ../doc/book/cartridge/cartridge_dev.rst:850
msgid ""
"For example, if your application has version 1.2.1, tag your current "
"branch with ``1.2.1`` (annotated or not)."
msgstr ""
"Например, если версия вашего приложения -- 1.2.1, пометьте текущую ветку "
"тегом ``1.2.1`` (с аннотациями или без них)."

#: ../doc/book/cartridge/cartridge_dev.rst:853
msgid "To retrieve the current version from Git, say:"
msgstr "Чтобы получить значение текущей версии из Git, выполните команду:"

#: ../doc/book/cartridge/cartridge_dev.rst:855
msgid ""
"$ git describe --long --tags\n"
"1.2.1-12-g74864f2"
msgstr ""
"$ git describe --long --tags\n"
"1.2.1-12-g74864f2"

#: ../doc/book/cartridge/cartridge_dev.rst:860
msgid ""
"This output shows that we are 12 commits after the version 1.2.1. If we "
"are to package the application at this point, it will have a full version"
" of ``1.2.1-12`` and its package will be named "
"``<app_name>-1.2.1-12.rpm``."
msgstr ""
"Вывод показывает, что после версии 1.2.1 было 12 коммитов. Если мы "
"соберемся упаковать приложение на данном этапе, его полная версия будет "
"``1.2.1-12``, а пакет будет называться ``<имя_приложения>-1.2.1-12.rpm``."

#: ../doc/book/cartridge/cartridge_dev.rst:864
msgid ""
"Non-semantic tags are prohibited. You will not be able to create a "
"package from a branch with the latest tag being non-semantic."
msgstr ""
"Запрещается использовать не семантические теги. Вы не сможете создать "
"пакет из ветки, если последний тег не будет семантическим."

#: ../doc/book/cartridge/cartridge_dev.rst:867
msgid ""
"Once you :ref:`package <cartridge-deploy>` your application, the version "
"is saved in a ``VERSION`` file in the package root."
msgstr ""
"После :ref:`упаковки <cartridge-deploy>` приложения его версия "
"сохраняется в файл ``VERSION`` в корневой каталог пакета."

#: ../doc/book/cartridge/cartridge_dev.rst:874
msgid "Using .cartridge-cli.ignore files"
msgstr "Использование файлов .cartridge-cli.ignore"

#: ../doc/book/cartridge/cartridge_dev.rst:876
msgid ""
"You can add a ``.cartridge-cli.ignore`` file to your application "
"repository to exclude particular files and/or directories from package "
"builds."
msgstr ""
"В репозиторий приложения можно добавить файл ``.cartridge-cli.ignore``, "
"чтобы не включать определенные файлы и/или директории в сборки пакета."

#: ../doc/book/cartridge/cartridge_dev.rst:879
msgid ""
"For the most part, the logic is similar to that of ``.gitignore`` files. "
"The major difference is that in ``.cartridge-cli.ignore`` files the order"
" of exceptions relative to the rest of the templates does not matter, "
"while in ``.gitignore`` files the order does matter."
msgstr ""
"По большей части логика похожа на логику файлов ``.gitignore``. Основное "
"отличие состоит в том, что в файлах ``.cartridge-cli.ignore`` порядок "
"исключения относительно остальных шаблонов не имеет значения, а в файлах "
"``.gitignore`` -- имеет."

#: ../doc/book/cartridge/cartridge_dev.rst:890
msgid "**.cartridge-cli.ignore** entry"
msgstr "запись в ``.cartridge-cli.ignore``"

#: ../doc/book/cartridge/cartridge_dev.rst:890
msgid "ignores every..."
msgstr "игнорирует все..."

#: ../doc/book/cartridge/cartridge_dev.rst:892
msgid "``target/``"
msgstr "``target/``"

#: ../doc/book/cartridge/cartridge_dev.rst:892
msgid "**folder** (due to the trailing ``/``) named ``target``, recursively"
msgstr ""
"**папки** (поскольку в конце стоит ``/``) под названием ``target`` "
"рекурсивно"

#: ../doc/book/cartridge/cartridge_dev.rst:895
msgid "``target``"
msgstr "``target``"

#: ../doc/book/cartridge/cartridge_dev.rst:895
msgid "**file or folder** named ``target``, recursively"
msgstr "**файлы или папки** под названием ``target`` рекурсивно"

#: ../doc/book/cartridge/cartridge_dev.rst:898
msgid "``/target``"
msgstr "``/target``"

#: ../doc/book/cartridge/cartridge_dev.rst:898
msgid ""
"**file or folder** named ``target`` in the top-most directory (due to the"
" leading ``/``)"
msgstr ""
"**файлы или папки** под названием ``target`` в самой верхней директории "
"(поскольку в начале стоит ``/``)"

#: ../doc/book/cartridge/cartridge_dev.rst:901
msgid "``/target/``"
msgstr "``/target/``"

#: ../doc/book/cartridge/cartridge_dev.rst:901
msgid ""
"**folder** named ``target`` in the top-most directory (leading and "
"trailing ``/``)"
msgstr ""
"**папки** под названием ``target`` в самой верхней директории (в начале и"
" в конце стоит ``/``)"

#: ../doc/book/cartridge/cartridge_dev.rst:904
msgid "``*.class``"
msgstr "``*.class``"

#: ../doc/book/cartridge/cartridge_dev.rst:904
msgid "every **file or folder** ending with ``.class``, recursively"
msgstr "**файлы или папки**, оканчивающиеся на ``.class``, рекурсивно"

#: ../doc/book/cartridge/cartridge_dev.rst:907
msgid "``#comment``"
msgstr "``#comment``"

#: ../doc/book/cartridge/cartridge_dev.rst:907
msgid "nothing, this is a comment (the first character is a ``#``)"
msgstr "ничего, это комментарий (первый символ -- ``#``)"

#: ../doc/book/cartridge/cartridge_dev.rst:910
msgid "``\\#comment``"
msgstr "``\\#comment``"

#: ../doc/book/cartridge/cartridge_dev.rst:910
msgid "every **file or folder** with name ``#comment`` (``\\`` for escaping)"
msgstr "**файлы или папки** под названием ``#comment`` (``\\\\`` для выделения)"

#: ../doc/book/cartridge/cartridge_dev.rst:913
msgid "``target/logs/``"
msgstr "``target/logs/``"

#: ../doc/book/cartridge/cartridge_dev.rst:913
msgid ""
"every **folder** named ``logs`` which is a subdirectory of a folder named"
" ``target``"
msgstr ""
"**папки** под названием ``logs``, которые представляют собой "
"поддиректорию папки под названием ``target``"

#: ../doc/book/cartridge/cartridge_dev.rst:916
msgid "``target/*/logs/``"
msgstr "``target/*/logs/``"

#: ../doc/book/cartridge/cartridge_dev.rst:916
msgid ""
"every **folder** named ``logs`` two levels under a folder named "
"``target`` (``*`` doesn’t include ``/``)"
msgstr ""
"**папки** под названием ``logs`` на два уровня ниже папки под названием "
"``target`` (``*`` не включает ``/``)"

#: ../doc/book/cartridge/cartridge_dev.rst:920
msgid "``target/**/logs/``"
msgstr "``target/**/logs/``"

#: ../doc/book/cartridge/cartridge_dev.rst:920
msgid ""
"every **folder** named ``logs`` somewhere under a folder named ``target``"
" (``**`` includes ``/``)"
msgstr ""
"**папки** под названием ``logs`` где угодно в пределах папки ``target`` "
"(``**`` включает ``/``)"

#: ../doc/book/cartridge/cartridge_dev.rst:924
msgid "``*.py[co]``"
msgstr "``*.py[co]``"

#: ../doc/book/cartridge/cartridge_dev.rst:924
msgid ""
"every **file or folder** ending in ``.pyc`` or ``.pyo``; however, it "
"doesn’t match ``.py!``"
msgstr ""
"**файлы или папки**, оканчивающиеся на ``.pyc`` или ``.pyo``, но не на "
"``.py!``"

#: ../doc/book/cartridge/cartridge_dev.rst:927
msgid "``*.py[!co]``"
msgstr "``*.py[!co]``"

#: ../doc/book/cartridge/cartridge_dev.rst:927
msgid "every **file or folder** ending in anything other than ``c`` or ``o``"
msgstr "**файлы или папки**, оканчивающиеся на что угодно, кроме ``c`` или ``o``"

#: ../doc/book/cartridge/cartridge_dev.rst:930
msgid "``*.file[0-9]``"
msgstr "``*.file[0-9]``"

#: ../doc/book/cartridge/cartridge_dev.rst:930
msgid "every **file or folder** ending in digit"
msgstr "**файлы или папки**, оканчивающиеся на цифру"

#: ../doc/book/cartridge/cartridge_dev.rst:932
msgid "``*.file[!0-9]``"
msgstr "``*.file[!0-9]``"

#: ../doc/book/cartridge/cartridge_dev.rst:932
msgid "every **file or folder** ending in anything other than digit"
msgstr "**файлы или папки**, оканчивающиеся на что угодно, кроме цифры"

#: ../doc/book/cartridge/cartridge_dev.rst:935
msgid "``*``"
msgstr "``*``"

#: ../doc/book/cartridge/cartridge_dev.rst:935
msgid "**every**"
msgstr "**всё**"

#: ../doc/book/cartridge/cartridge_dev.rst:937
msgid "``/*``"
msgstr "``/*``"

#: ../doc/book/cartridge/cartridge_dev.rst:937
msgid "**everything** in the top-most directory (due to the leading ``/``)"
msgstr "**всё** в самой верхней директории (поскольку в начале стоит ``/``)"

#: ../doc/book/cartridge/cartridge_dev.rst:940
msgid "``**/*.tar.gz``"
msgstr "``**/*.tar.gz``"

#: ../doc/book/cartridge/cartridge_dev.rst:940
msgid ""
"every ``*.tar.gz`` file or folder which is **one or more** levels under "
"the starting folder"
msgstr ""
"файлы ``*.tar.gz`` или папки, которые находятся на **один или несколько**"
" уровней ниже исходной папки"

#: ../doc/book/cartridge/cartridge_dev.rst:944
msgid "``!file``"
msgstr "``!file``"

#: ../doc/book/cartridge/cartridge_dev.rst:944
msgid "every **file or folder** will be ignored even if it matches other patterns"
msgstr ""
"**файлы и папки** будут проигнорированы, даже если они подходят под "
"другие типы"

#: ../doc/book/cartridge/cartridge_dev.rst:952
msgid "Deploying an application"
msgstr "Развертывание приложения"

#: ../doc/book/cartridge/cartridge_dev.rst:954
msgid "You have four options to deploy a Tarantool Cartridge application:"
msgstr "Развернуть приложение Tarantool Cartridge можно четырьмя способами:"

#: ../doc/book/cartridge/cartridge_dev.rst:956
msgid "as an :ref:`rpm <cartridge-deploy-rpm>` package (for production);"
msgstr ""
"в виде :ref:`rpm <cartridge-deploy-rpm>`-пакета (для эксплуатационной "
"среды);"

#: ../doc/book/cartridge/cartridge_dev.rst:957
msgid "as a :ref:`deb <cartridge-deploy-deb>` package (for production);"
msgstr ""
"в виде :ref:`deb <cartridge-deploy-deb>`-пакета (для эксплуатационной "
"среды);"

#: ../doc/book/cartridge/cartridge_dev.rst:958
msgid ""
"as a :ref:`tar+gz <cartridge-deploy-tgz>` archive (for testing, or as a "
"workaround for production if root access is unavailable)."
msgstr ""
"в виде архива :ref:`tar+gz <cartridge-deploy-tgz>` (для тестирования или "
"для эксплуатационной среды, если отсутствует доступ уровня root)."

#: ../doc/book/cartridge/cartridge_dev.rst:960
msgid ":ref:`from sources <cartridge-deploy-rock>` (for local testing only)."
msgstr ""
":ref:`из исходных файлов <cartridge-deploy-rock>` (только для локального "
"тестирования)."

#: ../doc/book/cartridge/cartridge_dev.rst:967
msgid "Deploying as an rpm or deb package"
msgstr "Развертывание приложения в виде пакета rpm или deb"

#: ../doc/book/cartridge/cartridge_dev.rst:969
#: ../doc/book/cartridge/cartridge_dev.rst:1014
msgid "Pack the application into a distributable:"
msgstr "Упакуйте файлы приложения в распространяемый пакет:"

#: ../doc/book/cartridge/cartridge_dev.rst:971
#, fuzzy
msgid ""
"$ cartridge pack rpm /path/to/<app_name>\n"
"# -- OR --\n"
"$ cartridge pack deb /path/to/<app_name>"
msgstr ""
"$ cartridge pack rpm ИМЯ_ПРИЛОЖЕНИЯ\n"
"# -- ИЛИ --\n"
"$ cartridge pack deb ИМЯ_ПРИЛОЖЕНИЯ"

#: ../doc/book/cartridge/cartridge_dev.rst:977
msgid ""
"This will create an RPM package (e.g. ``./my_app-0.1.0-1.rpm``) or a DEB "
"package (e.g. ``./my_app-0.1.0-1.deb``)."
msgstr ""
"Будет создан RPM-пакет (например, ``./my_app-0.1.0-1.rpm``) или же "
"DEB-пакет (например, ``./my_app-0.1.0-1.deb``)."

#: ../doc/book/cartridge/cartridge_dev.rst:980
msgid "Upload the package to target servers, with ``systemctl`` supported."
msgstr "Загрузите пакет на необходимые серверы с поддержкой ``systemctl``."

#: ../doc/book/cartridge/cartridge_dev.rst:982
msgid "Install:"
msgstr "Установите:"

#: ../doc/book/cartridge/cartridge_dev.rst:984
msgid ""
"$ yum install APP_NAME-VERSION.rpm\n"
"# -- OR --\n"
"$ dpkg -i APP_NAME-VERSION.deb"
msgstr ""
"$ yum install ИМЯ_ПРИЛОЖЕНИЯ-ВЕРСИЯ.rpm\n"
"# -- ИЛИ --\n"
"$ dpkg -i ИМЯ_ПРИЛОЖЕНИЯ-ВЕРСИЯ.deb"

#: ../doc/book/cartridge/cartridge_dev.rst:990
#: ../doc/book/cartridge/cartridge_dev.rst:1031
#: ../doc/book/cartridge/cartridge_dev.rst:1068
msgid ":ref:`Configure the instance(s) <cartridge-config>`."
msgstr ":ref:`Выполните конфигурацию экземпляров <cartridge-config>`."

#: ../doc/book/cartridge/cartridge_dev.rst:992
msgid ""
"Start Tarantool instances with the corresponding services. You can do it "
"using :ref:`systemctl <cartridge-run-systemctl>`, for example:"
msgstr ""
"Запустите экземпляры Tarantool'а с соответствующими службами. Например, "
"это можно сделать, используя :ref:`systemctl <cartridge-run-systemctl>`:"

#: ../doc/book/cartridge/cartridge_dev.rst:995
msgid ""
"# starts a single instance\n"
"$ systemctl start my_app\n"
"\n"
"# starts multiple instances\n"
"$ systemctl start my_app@router\n"
"$ systemctl start my_app@storage_A\n"
"$ systemctl start my_app@storage_B"
msgstr ""
"# запуск одного экземпляра\n"
"$ systemctl start my_app\n"
"\n"
"# запуск нескольких экземпляров\n"
"$ systemctl start my_app@router\n"
"$ systemctl start my_app@storage_A\n"
"$ systemctl start my_app@storage_B"

#: ../doc/book/cartridge/cartridge_dev.rst:1005
#: ../doc/book/cartridge/cartridge_dev.rst:1053
#: ../doc/book/cartridge/cartridge_dev.rst:1090
msgid ""
"In case it is a cluster-aware application, proceed to :ref:`deploying the"
" cluster <cartridge-deployment>`."
msgstr ""
"Если это приложение с поддержкой кластеров, далее переходите к "
":ref:`развертыванию кластера <cartridge-deployment>`."

#: ../doc/book/cartridge/cartridge_dev.rst:1012
msgid "Deploying as a tar+gz archive"
msgstr "Развертывание архива tar+gz"

#: ../doc/book/cartridge/cartridge_dev.rst:1016
#, fuzzy
msgid "$ cartridge pack tgz /path/to/<app_name>"
msgstr "$ cartridge pack tgz ИМЯ_ПРИЛОЖЕНИЯ"

#: ../doc/book/cartridge/cartridge_dev.rst:1020
msgid "This will create a tar+gz archive (e.g. ``./my_app-0.1.0-1.tgz``)."
msgstr "Будет создан архив tar+gz (например, ``./my_app-0.1.0-1.tgz``)."

#: ../doc/book/cartridge/cartridge_dev.rst:1022
msgid ""
"Upload the archive to target servers, with ``tarantool`` and (optionally)"
" :ref:`cartridge-cli <cartridge-install>` installed."
msgstr ""
"Загрузите архив на необходимый сервер с установленным ``tarantool`` и "
"(необязательно) :ref:`cartridge-cli <cartridge-install>`."

#: ../doc/book/cartridge/cartridge_dev.rst:1025
msgid "Extract the archive:"
msgstr "Распакуйте архив:"

#: ../doc/book/cartridge/cartridge_dev.rst:1027
msgid "$ tar -xzvf APP_NAME-VERSION.tgz"
msgstr "$ tar -xzvf ИМЯ_ПРИЛОЖЕНИЯ-ВЕРСИЯ.tgz"

#: ../doc/book/cartridge/cartridge_dev.rst:1033
#: ../doc/book/cartridge/cartridge_dev.rst:1070
msgid "Start Tarantool instance(s). You can do it using:"
msgstr "Запустите экземпляры Tarantool’а. Это можно сделать, используя:"

#: ../doc/book/cartridge/cartridge_dev.rst:1035
#: ../doc/book/cartridge/cartridge_dev.rst:1072
msgid ":ref:`tarantool <cartridge-run-tarantool>`, for example:"
msgstr ":ref:`tarantoolctl <cartridge-run-tarantool>`, например:"

#: ../doc/book/cartridge/cartridge_dev.rst:1037
#: ../doc/book/cartridge/cartridge_dev.rst:1074
msgid "$ tarantool init.lua # starts a single instance"
msgstr "$ tarantool init.lua # запускает одиночный экземпляр"

#: ../doc/book/cartridge/cartridge_dev.rst:1041
#: ../doc/book/cartridge/cartridge_dev.rst:1078
msgid "or :ref:`cartridge <cartridge-run-cartridge>`, for example:"
msgstr "или :ref:`cartridge <cartridge-run-cartridge>`, например:"

#: ../doc/book/cartridge/cartridge_dev.rst:1043
msgid ""
"# in application directory\n"
"$ cartridge start # starts all instances\n"
"$ cartridge start .router_1 # starts a single instance\n"
"\n"
"# in multi-application environment\n"
"$ cartridge start my_app # starts all instances of my_app\n"
"$ cartridge start my_app.router # starts a single instance"
msgstr ""
"# в директории приложения\n"
"$ cartridge start # запускает все экземпляры\n"
"$ cartridge start .router_1 # запускает один экземпляр\n"
"\n"
"# в среде с несколькими приложениями\n"
"$ cartridge start my_app # запускает все экземпляры my_app\n"
"$ cartridge start my_app.router # запускает один экземпляр"

#: ../doc/book/cartridge/cartridge_dev.rst:1060
msgid "Deploying from sources"
msgstr "Развертывание из исходных файлов"

#: ../doc/book/cartridge/cartridge_dev.rst:1062
msgid "This deployment method is intended for local testing only."
msgstr "Такой метод развертывания предназначен только для локального тестирования."

#: ../doc/book/cartridge/cartridge_dev.rst:1064
msgid "Pull all dependencies to the ``.rocks`` directory:"
msgstr "Вытяните все зависимости в директорию ``.rocks``:"

#: ../doc/book/cartridge/cartridge_dev.rst:1066
msgid "$ tarantoolctl rocks make"
msgstr "$ tarantoolctl rocks make"

#: ../doc/book/cartridge/cartridge_dev.rst:1080
msgid ""
"# in application directory\n"
"cartridge start # starts all instances\n"
"cartridge start .router_1 # starts a single instance\n"
"\n"
"# in multi-application environment\n"
"cartridge start my_app # starts all instances of my_app\n"
"cartridge start my_app.router # starts a single instance"
msgstr ""
"# в директории приложения\n"
"cartridge start # запускает все экземпляры\n"
"cartridge start .router_1 # запускает один экземпляр\n"
"\n"
"# в среде с несколькими приложениями\n"
"cartridge start my_app # запускает все экземпляры my_app\n"
"cartridge start my_app.router # запускает один экземпляр"

#: ../doc/book/cartridge/cartridge_dev.rst:1097
msgid "Configuring instances"
msgstr "Конфигурация экземпляров"

#: ../doc/book/cartridge/cartridge_dev.rst:1099
msgid "Instance configuration includes two sets of parameters:"
msgstr "Конфигурация экземпляра состоит из двух наборов параметров:"

#: ../doc/book/cartridge/cartridge_dev.rst:1101
msgid ""
"`cartridge.cfg() parameters "
"<https://www.tarantool.io/en/rocks/cartridge/1.0/modules/cartridge.argparse"
"/#cluster-opts>`_;"
msgstr ""
"параметры `cartridge.cfg() "
"<https://www.tarantool.io/en/rocks/cartridge/1.0/modules/cartridge.argparse"
"/#cluster-opts>`_;"

#: ../doc/book/cartridge/cartridge_dev.rst:1102
msgid ""
"`box.cfg() parameters "
"<https://www.tarantool.io/en/rocks/cartridge/1.0/modules/cartridge.argparse"
"/#box-opts>`_."
msgstr ""
"параметры `box.cfg() "
"<https://www.tarantool.io/en/rocks/cartridge/1.0/modules/cartridge.argparse"
"/#box-opts>`_."

#: ../doc/book/cartridge/cartridge_dev.rst:1104
msgid "You can set any of these parameters in:"
msgstr "Задать эти параметры можно:"

#: ../doc/book/cartridge/cartridge_dev.rst:1106
msgid "Command line arguments."
msgstr "В аргументах в командной строке."

#: ../doc/book/cartridge/cartridge_dev.rst:1107
msgid "Environment variables."
msgstr "В переменных окружения."

#: ../doc/book/cartridge/cartridge_dev.rst:1108
msgid "YAML configuration file."
msgstr "В конфигурационном файле формата YAML."

#: ../doc/book/cartridge/cartridge_dev.rst:1109
msgid "``init.lua`` file."
msgstr "В файле ``init.lua``."

#: ../doc/book/cartridge/cartridge_dev.rst:1111
msgid ""
"The order here indicates the priority: command-line arguments override "
"environment variables, and so forth."
msgstr ""
"Вышеуказанный порядок определяет приоритет: аргументы в командной строке "
"замещают переменные окружения и т.д."

#: ../doc/book/cartridge/cartridge_dev.rst:1114
msgid ""
"No matter how you :ref:`start the instances <cartridge-run>`, you need to"
" set the following ``cartridge.cfg()`` parameters for each instance:"
msgstr ""
"Независимо от того, как вы :ref:`запускаете экземпляры <cartridge-run>`, "
"необходимо задать следующие параметры ``cartridge.cfg()`` для каждого "
"экземпляра:"

#: ../doc/book/cartridge/cartridge_dev.rst:1117
msgid ""
"``advertise_uri`` -- either ``<HOST>:<PORT>``, or ``<HOST>:``, or "
"``<PORT>``. Used by other instances to connect to the current one. **DO "
"NOT** specify ``0.0.0.0`` -- this must be an external IP address, not a "
"socket bind."
msgstr ""
"``advertise_uri`` -- либо ``<ХОСТ>:<ПОРТ>``, либо ``<ХОСТ>:``, либо "
"``<ПОРТ>``. Используется другими экземплярами для подключения. **НЕ** "
"указывайте ``0.0.0.0`` -- это должен быть внешний IP-адрес, а не привязка"
" сокета."

#: ../doc/book/cartridge/cartridge_dev.rst:1121
msgid ""
"``http_port`` -- port to open administrative web interface and API on. "
"Defaults to ``8081``. To disable it, specify ``\"http_enabled\": False``."
msgstr ""
"``http_port`` -- порт, который используется, чтобы открывать "
"административный веб-интерфейс и API. По умолчанию: ``8081``. Чтобы "
"отключить, укажите ``\"http_enabled\": False``."

#: ../doc/book/cartridge/cartridge_dev.rst:1124
msgid ""
"``workdir`` -- a directory where all data will be stored: snapshots, wal "
"logs, and ``cartridge`` configuration file. Defaults to ``.``."
msgstr ""
"``workdir`` -- директория, где хранятся все данные: файлы снимка, журналы"
" упреждающей записи и конфигурационный файл ``cartridge``. По умолчанию: "
"``.``."

#: ../doc/book/cartridge/cartridge_dev.rst:1131
msgid ""
"If you start instances using ``cartridge`` CLI or ``systemctl``, save the"
" configuration as a YAML file, for example:"
msgstr ""
"Если вы запустите экземпляры, используя интерфейс командной строки "
"``cartridge`` или ``systemctl``, сохраните конфигурацию в формате YAML, "
"например:"

#: ../doc/book/cartridge/cartridge_dev.rst:1134
msgid ""
"my_app.router: {\"advertise_uri\": \"localhost:3301\", \"http_port\": "
"8080}\n"
"my_app.storage_A: {\"advertise_uri\": \"localhost:3302\", "
"\"http_enabled\": False}\n"
"my_app.storage_B: {\"advertise_uri\": \"localhost:3303\", "
"\"http_enabled\": False}"
msgstr ""
"my_app.router: {\"advertise_uri\": \"localhost:3301\", \"http_port\": "
"8080}\n"
"my_app.storage_A: {\"advertise_uri\": \"localhost:3302\", "
"\"http_enabled\": False}\n"
"my_app.storage_B: {\"advertise_uri\": \"localhost:3303\", "
"\"http_enabled\": False}"

#: ../doc/book/cartridge/cartridge_dev.rst:1140
msgid ""
"With ``cartridge`` CLI, you can pass the path to this file as the "
"``--cfg`` command-line argument to the ``cartridge start`` command -- or "
"specify the path in ``cartridge`` CLI configuration (in "
"``./.cartridge.yml`` or ``~/.cartridge.yml``):"
msgstr ""
"С помощью интерфейса командной строки ``cartridge`` вы можете передать "
"путь к этому файлу в качестве аргумента командной строки ``--cfg`` для "
"команды ``cartridge start`` -- или же указать путь в конфигурации "
"``cartridge`` (в ``./.cartridge.yml`` или ``~/.cartridge.yml``):"

#: ../doc/book/cartridge/cartridge_dev.rst:1144
msgid ""
"cfg: cartridge.yml\n"
"run_dir: tmp/run\n"
"apps_path: /usr/local/share/tarantool"
msgstr ""
"cfg: cartridge.yml\n"
"run_dir: tmp/run\n"
"apps_path: /usr/local/share/tarantool"

#: ../doc/book/cartridge/cartridge_dev.rst:1150
msgid ""
"With ``systemctl``, save the YAML file to ``/etc/tarantool/conf.d/`` (the"
" default ``systemd`` path) or to a location set in the ``TARANTOOL_CFG`` "
"environment variable."
msgstr ""
"С помощью ``systemctl`` сохраните файл в формате YAML в "
"``/etc/tarantool/conf.d/`` (по умолчанию путь ``systemd``) или в место, "
"указанное в переменной окружения ``TARANTOOL_CFG``."

#: ../doc/book/cartridge/cartridge_dev.rst:1156
msgid ""
"If you start instances with ``tarantool init.lua``, you need to pass "
"other configuration options as command-line parameters and environment "
"variables, for example:"
msgstr ""
"Если вы запускаете экземпляры с помощью ``tarantool init.lua``, "
"необходимо также передать другие параметры конфигурации в качестве "
"параметров командной строки и переменных окружения, например:"

#: ../doc/book/cartridge/cartridge_dev.rst:1160
msgid ""
"$ tarantool init.lua --alias router --memtx-memory 100 --workdir "
"\"~/db/3301\" --advertise_uri \"localhost:3301\" --http_port \"8080\""
msgstr ""
"$ tarantool init.lua --alias router --memtx-memory 100 --workdir "
"\"~/db/3301\" --advertise_uri \"localhost:3301\" --http_port \"8080\""

#: ../doc/book/cartridge/cartridge_dev.rst:1168
msgid "Starting/stopping instances"
msgstr "Запуск/остановка экземпляров"

#: ../doc/book/cartridge/cartridge_dev.rst:1170
msgid ""
"Depending on your :ref:`deployment method <cartridge-deploy>`, you can "
"start/stop the instances using :ref:`tarantool <cartridge-run-"
"tarantool>`, :ref:`cartridge CLI <cartridge-run-cartridge>`, or "
":ref:`systemctl <cartridge-run-systemctl>`."
msgstr ""
"В зависимости от :ref:`способа развертывания <cartridge-deploy>` вы "
"можете запускать/останавливать экземпляры, используя :ref:`tarantool "
"<cartridge-run-tarantool>`, :ref:`интерфейс командной строки cartridge "
"<cartridge-run-cartridge>` или :ref:`systemctl <cartridge-run-"
"systemctl>`."

#: ../doc/book/cartridge/cartridge_dev.rst:1179
msgid "Start/stop using ``tarantool``"
msgstr "Запуск/остановка с помощью ``tarantool``"

#: ../doc/book/cartridge/cartridge_dev.rst:1181
msgid "With ``tarantool``, you can start only a single instance:"
msgstr "С помощью ``tarantool`` можно запустить только один экземпляр:"

#: ../doc/book/cartridge/cartridge_dev.rst:1183
msgid "$ tarantool init.lua # the simplest command"
msgstr "$ tarantool init.lua # простейшая команда"

#: ../doc/book/cartridge/cartridge_dev.rst:1187
msgid ""
"You can also :ref:`specify more options <cartridge-config-tarantool>` on "
"the command line or in environment variables."
msgstr ""
"Можно также :ref:`задать дополнительные параметры <cartridge-config-"
"tarantool>` в командной строке или в переменных окружения."

#: ../doc/book/cartridge/cartridge_dev.rst:1190
msgid "To stop the instance, use Ctrl+C."
msgstr "Чтобы остановить экземпляр, используйте Ctrl+C."

#: ../doc/book/cartridge/cartridge_dev.rst:1196
msgid "Start/stop using ``cartridge`` CLI"
msgstr "Запуск/остановка с помощью CLI в ``cartridge``"

#: ../doc/book/cartridge/cartridge_dev.rst:1198
msgid "With ``cartridge`` CLI, you can start one or multiple instances:"
msgstr ""
"С помощью интерфейса командной строки ``cartridge``, можно запустить один"
" или несколько экземпляров:"

#: ../doc/book/cartridge/cartridge_dev.rst:1200
msgid "$ cartridge start [APP_NAME[.INSTANCE_NAME]] [options]"
msgstr "$ cartridge start [ИМЯ_ПРИЛОЖЕНИЯ[.ИМЯ_ЭКЗЕМПЛЯРА]] [параметры]"

#: ../doc/book/cartridge/cartridge_dev.rst:1204
msgid "The options are:"
msgstr "Возможные параметры:"

#: ../doc/book/cartridge/cartridge_dev.rst:1212
msgid "``--script FILE``"
msgstr "``--script FILE``"

#: ../doc/book/cartridge/cartridge_dev.rst:1207
msgid "Application's entry point. Defaults to:"
msgstr "Точка входа в приложение. По умолчанию:"

#: ../doc/book/cartridge/cartridge_dev.rst:1210
msgid "``TARANTOOL_SCRIPT``, or"
msgstr "``TARANTOOL_SCRIPT``, либо"

#: ../doc/book/cartridge/cartridge_dev.rst:1211
msgid "``./init.lua`` when running from the app's directory, or"
msgstr "``./init.lua``, если запуск идет из директории приложения, или же"

#: ../doc/book/cartridge/cartridge_dev.rst:1212
msgid "``:apps_path/:app_name/init.lua`` in a multi-app environment."
msgstr ""
"``:путь_к_приложениям/:имя_приложения/init.lua`` в среде с несколькими "
"приложениями."

#: ../doc/book/cartridge/cartridge_dev.rst:1216
msgid "``--apps_path PATH``"
msgstr "``--apps_path PATH``"

#: ../doc/book/cartridge/cartridge_dev.rst:1215
msgid ""
"Path to apps directory when running in a multi-app environment. Defaults "
"to ``/usr/share/tarantool``."
msgstr ""
"Путь к директории с приложениями при запуске из среды с несколькими "
"приложениями. По умолчанию: ``/usr/share/tarantool``."

#: ../doc/book/cartridge/cartridge_dev.rst:1220
#: ../doc/book/cartridge/cartridge_dev.rst:1262
msgid "``--run_dir DIR``"
msgstr "``--run_dir DIR``"

#: ../doc/book/cartridge/cartridge_dev.rst:1219
msgid ""
"Directory with pid and sock files. Defaults to ``TARANTOOL_RUN_DIR`` or "
"``/var/run/tarantool``."
msgstr ""
"Директория с файлами pid и sock. По умолчанию: ``TARANTOOL_RUN_DIR`` или "
"``/var/run/tarantool``."

#: ../doc/book/cartridge/cartridge_dev.rst:1224
#: ../doc/book/cartridge/cartridge_dev.rst:1263
msgid "``--cfg FILE``"
msgstr "``--cfg FILE``"

#: ../doc/book/cartridge/cartridge_dev.rst:1223
msgid ""
"Cartridge instances YAML configuration file. Defaults to "
"``TARANTOOL_CFG`` or ``./instances.yml``."
msgstr ""
"Конфигурациионный файл в формате YAML для экземпляров Cartridge. По "
"умолчанию: ``TARANTOOL_CFG`` или ``./instances.yml``."

#: ../doc/book/cartridge/cartridge_dev.rst:1227
msgid "``--foreground``"
msgstr "``--foreground``"

#: ../doc/book/cartridge/cartridge_dev.rst:1227
msgid "Do not daemonize."
msgstr "Не в фоне."

#: ../doc/book/cartridge/cartridge_dev.rst:1235
msgid ""
"It starts all ``tarantool`` instances specified in ``cfg`` file, in "
"foreground, with enforced :ref:`environment variables <cartridge-"
"config>`."
msgstr ""
"Это запустит все экземпляры Tarantool'а, указанные в файле ``cfg``, не в "
"фоновом режиме с принудительным использованием :ref:`переменных окружения"
" <cartridge-config>`."

#: ../doc/book/cartridge/cartridge_dev.rst:1238
msgid ""
"When ``APP_NAME`` is not provided, ``cartridge`` parses it from "
"``./*.rockspec`` filename."
msgstr ""
"Если ``ИМЯ_ПРИЛОЖЕНИЯ`` не указано, ``cartridge`` выделит его из имени "
"файла ``./*.rockspec``."

#: ../doc/book/cartridge/cartridge_dev.rst:1241
msgid ""
"When ``INSTANCE_NAME`` is not provided, ``cartridge`` reads ``cfg`` file "
"and starts all defined instances:"
msgstr ""
"Если ``ИМЯ_ЭКЗЕМПЛЯРА`` не указывается, ``cartridge`` прочитает файл "
"``cfg`` и запустит все указанные экземпляры:"

#: ../doc/book/cartridge/cartridge_dev.rst:1244
msgid ""
"# in application directory\n"
"cartridge start # starts all instances\n"
"cartridge start .router_1 # start single instance\n"
"\n"
"# in multi-application environment\n"
"cartridge start my_app # starts all instances of my_app\n"
"cartridge start my_app.router # start a single instance"
msgstr ""
"# в директории приложения\n"
"cartridge start # запускает все экземпляры\n"
"cartridge start .router_1 # запускает отдельный экземпляр\n"
"\n"
"# в среде с несколькими приложениями\n"
"cartridge start my_app # запускает все экземпляры my_app\n"
"cartridge start my_app.router # запускает отдельный экземпляр"

#: ../doc/book/cartridge/cartridge_dev.rst:1254
msgid "To stop the instances, say:"
msgstr "Чтобы остановить экземпляры, выполните команду:"

#: ../doc/book/cartridge/cartridge_dev.rst:1256
msgid "$ cartridge stop [APP_NAME[.INSTANCE_NAME]] [options]"
msgstr "$ cartridge stop [ИМЯ_ПРИЛОЖЕНИЯ[.ИМЯ_ЭКЗЕМПЛЯРА]] [параметры]"

#: ../doc/book/cartridge/cartridge_dev.rst:1260
msgid "These options from the ``cartridge start`` command are supported:"
msgstr "Поддерживаются следующие параметры из команды `cartridge start``:"

#: ../doc/book/cartridge/cartridge_dev.rst:1269
msgid "Start/stop using ``systemctl``"
msgstr "Запуск/остановка с помощью ``systemctl``"

#: ../doc/book/cartridge/cartridge_dev.rst:1271
msgid "To run a single instance:"
msgstr "Чтобы запустить отдельный экземпляр:"

#: ../doc/book/cartridge/cartridge_dev.rst:1273
msgid "$ systemctl start APP_NAME"
msgstr "$ systemctl start ИМЯ_ПРИЛОЖЕНИЯ"

#: ../doc/book/cartridge/cartridge_dev.rst:1277
msgid ""
"This will start a  ``systemd`` service that will listen to the port "
"specified in :ref:`instance configuration <cartridge-config>` "
"(``http_port`` parameter)."
msgstr ""
"Это запустит службу ``systemd``, которая будет прослушивать порт, "
"указанный в :ref:`конфигурации экземпляра <cartridge-config>` (параметр "
"``http_port``)."

#: ../doc/book/cartridge/cartridge_dev.rst:1281
msgid "To run multiple instances on one or multiple servers:"
msgstr "Чтобы запустить несколько экземпляров на одном или нескольких серверах:"

#: ../doc/book/cartridge/cartridge_dev.rst:1283
msgid ""
"$ systemctl start APP_NAME@INSTANCE_1\n"
"$ systemctl start APP_NAME@INSTANCE_2\n"
"...\n"
"$ systemctl start APP_NAME@INSTANCE_N"
msgstr ""
"$ systemctl start ИМЯ_ПРИЛОЖЕНИЯ@ЭКЗЕМПЛЯР_1\n"
"$ systemctl start ИМЯ_ПРИЛОЖЕНИЯ@ЭКЗЕМПЛЯР_2\n"
"...\n"
"$ systemctl start ИМЯ_ПРИЛОЖЕНИЯ@ЭКЗЕМПЛЯР_N"

#: ../doc/book/cartridge/cartridge_dev.rst:1290
msgid ""
"where ``APP_NAME@INSTANCE_N`` is the instantiated service name for "
"``systemd`` with an incremental ``N`` -- a number, unique for every "
"instance, added to the port the instance will listen to (e.g., ``3301``, "
"``3302``, etc.)"
msgstr ""
"где ``ИМЯ_ПРИЛОЖЕНИЯ@ЭКЗЕМПЛЯР_N`` -- это имя экземпляра сервиса "
"``systemd`` с инкрементным числом N (уникальным для каждого экземпляра), "
"которое следует добавить к порту ``3300`` для настройки прослушивания "
"(например, ``3301``, ``3302`` и т.д.)."

#: ../doc/book/cartridge/cartridge_dev.rst:1295
msgid ""
"To stop all services on a server, use the ``systemctl stop`` command and "
"specify instance names one by one. For example:"
msgstr ""
"Чтобы остановить все сервисы на сервере, используйте команду ``systemctl "
"stop`` и укажите имена экземпляров по одному. Например:"

#: ../doc/book/cartridge/cartridge_dev.rst:1298
msgid ""
"$ systemctl stop APP_NAME@INSTANCE_1 APP_NAME@INSTANCE_2 ... "
"APP_NAME@INSTANCE_<N>"
msgstr ""
"$ systemctl stop ИМЯ_ПРИЛОЖЕНИЯ@ЭКЗЕМПЛЯР_1 ИМЯ_ПРИЛОЖЕНИЯ@ЭКЗЕМПЛЯР_2 "
"... ИМЯ_ПРИЛОЖЕНИЯ@ЭКЗЕМПЛЯР_<N>"

#: ../doc/book/cartridge/cartridge_overview.rst:5
msgid "About Tarantool Cartridge"
msgstr "О Tarantool Cartridge"

#: ../doc/book/cartridge/cartridge_overview.rst:7
msgid ""
"Tarantool Cartridge is the recommended alternative to the :ref:`old-"
"school practices <app_server-creating_app>` of application development "
"for Tarantool."
msgstr ""
"Tarantool Cartridge рекомендуется в качестве альтернативы "
":ref:`традиционному подходу <app_server-creating_app>` разработки "
"приложений для Tarantool'а."

#: ../doc/book/cartridge/cartridge_overview.rst:13
msgid ""
"As a software development kit (SDK), Tarantool Cartridge provides you "
"with utilities and :ref:`templates <cartridge-templates>` to help:"
msgstr ""
"В качестве набора средств разработки (SDK) Tarantool Cartridge предлагает"
" утилиты и :ref:`шаблоны <cartridge-templates>`, которые помогут вам:"

#: ../doc/book/cartridge/cartridge_overview.rst:16
msgid "easily set up a development environment for your applications;"
msgstr "с легкостью настроить среду разработки для приложений;"

#: ../doc/book/cartridge/cartridge_overview.rst:17
msgid "plug the necessary Lua modules."
msgstr "подключить необходимые Lua-модули."

#: ../doc/book/cartridge/cartridge_overview.rst:19
msgid ""
"The resulting package can be installed and started on one or multiple "
"servers as one or multiple instantiated services -- independent or "
"organized into a **cluster**."
msgstr ""
"Полученный пакет можно установить и запустить на одном сервере или "
"нескольких серверах в качестве одного экземпляра службы или как "
"нескольких служб, независимо или в **кластере**."

#: ../doc/book/cartridge/cartridge_overview.rst:25
msgid ""
"A Tarantool cluster is a collection of Tarantool instances acting in "
"concert. While a single Tarantool instance can leverage the performance "
"of a single server and is vulnerable to failure, the cluster spans "
"multiple servers, utilizes their cumulative CPU power, and is fault-"
"tolerant."
msgstr ""
"Кластер в Tarantool'е представляет собой совокупность согласованно "
"действующих экземпляров Tarantool. Одиночный экземпляр Tarantool может "
"эффективно использовать один сервер и подвержен сбоям, тогда как кластер "
"охватывает несколько серверов, использует их совокупную "
"производительность и обеспечивает отказоустойчивость."

#: ../doc/book/cartridge/cartridge_overview.rst:30
msgid ""
"To fully utilize the capabilities of a Tarantool cluster, you need to "
"develop applications keeping in mind they are to run in a cluster "
"environment."
msgstr ""
"Чтобы полностью использовать возможности Tarantool-кластера, необходимо "
"разрабатывать приложения исходя из того, что они должны работать в "
"кластерной среде."

#: ../doc/book/cartridge/cartridge_overview.rst:33
msgid ""
"Further on, Tarantool Cartridge provides your cluster-aware applications "
"with the following benefits:"
msgstr ""
"Кроме того, кластер в Tarantool'е предоставляет следующие ключевые "
"преимущества для кластерных приложений:"

#: ../doc/book/cartridge/cartridge_overview.rst:36
msgid "horizontal scalability and load balancing via built-in automatic sharding;"
msgstr ""
"горизонтальная масштабируемость и балансировка нагрузки с помощью "
"встроенного автоматического шардинга;"

#: ../doc/book/cartridge/cartridge_overview.rst:37
msgid "asynchronous replication;"
msgstr "асинхронная репликация;"

#: ../doc/book/cartridge/cartridge_overview.rst:38
msgid "automatic failover;"
msgstr "автоматическое восстановление после отказа;"

#: ../doc/book/cartridge/cartridge_overview.rst:39
msgid "centralized cluster control via GUI or API;"
msgstr "централизованное управление кластером через графический интерфейс или API;"

#: ../doc/book/cartridge/cartridge_overview.rst:40
msgid "automatic configuration synchronization;"
msgstr "автоматическая синхронизации настроек;"

#: ../doc/book/cartridge/cartridge_overview.rst:41
msgid "instance functionality segregation."
msgstr "разделение функций экземпляров."

#: ../doc/book/cartridge/cartridge_overview.rst:43
msgid ""
"A Tarantool Cartridge cluster can segregate functionality between "
"instances via built-in and custom (user-defined) :ref:`cluster roles "
"<cartridge-roles>`. You can toggle instances on and off on the fly during"
" cluster operation. This allows you to put different types of workloads "
"(e.g., compute- and transaction-intensive ones) on different physical "
"servers with dedicated hardware."
msgstr ""
"Кластер в Tarantool Cartridge может распределять функции экземпляров с "
"помощью встроенных и пользовательских (настраиваемых) :ref:`кластерных "
"ролей <cartridge-roles>`. Во время работы кластера можно включить и "
"отключить роли на лету. Это позволяет по-разному нагружать физические "
"серверы с различным профилем оборудования (например, для ресурсоемких "
"вычислений или для обработки большого количества транзакций)."

#: ../doc/book/cartridge/index.rst:5
msgid "Tarantool Cartridge"
msgstr "Tarantool Cartridge"

#: ../doc/book/cartridge/index.rst:7
msgid ""
"In this chapter, we explain how you can benefit with Tarantool Cartridge,"
" a framework for developing, deploying, and managing applications based "
"on Tarantool."
msgstr ""
"В этой мы расскажем о том, какие преимущества предоставляет Tarantool "
"Cartridge, платформа для разработки, развертывания и управления "
"приложениями на основе Tarantool'а."

#: ../doc/book/connectors/__c.rst:3
msgid "C"
msgstr "C"

#: ../doc/book/connectors/__c.rst:5
msgid "Here follow two examples of using Tarantool's high-level C API."
msgstr ""
"В этом разделе даны два примера использования высокоуровневого API для "
"Tarantool'а и языка C."

#: ../doc/book/connectors/__c.rst:9
msgid "Example 1"
msgstr "Пример 1"

#: ../doc/book/connectors/__c.rst:11
msgid ""
"Here is a complete C program that inserts :code:`[99999,'B']` into space "
":code:`examples` via the high-level C API."
msgstr ""
"Далее приводится пример полноценной программы на языке C, которая "
"осуществляет вставку кортежа ``[99999,'B']`` в спейс :code:`examples` с "
"помощью высокоуровневого API для языка C."

#: ../doc/book/connectors/__c.rst:14
#, python-format
msgid ""
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"\n"
"void main() {\n"
"   struct tnt_stream *tnt = tnt_net(NULL);          /* See note = SETUP "
"*/\n"
"   tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"   if (tnt_connect(tnt) < 0) {                      /* See note = CONNECT"
" */\n"
"       printf(\"Connection refused\\n\");\n"
"       exit(-1);\n"
"   }\n"
"   struct tnt_stream *tuple = tnt_object(NULL);     /* See note = MAKE "
"REQUEST */\n"
"   tnt_object_format(tuple, \"[%d%s]\", 99999, \"B\");\n"
"   tnt_insert(tnt, 999, tuple);                     /* See note = SEND "
"REQUEST */\n"
"   tnt_flush(tnt);\n"
"   struct tnt_reply reply;  tnt_reply_init(&reply); /* See note = GET "
"REPLY */\n"
"   tnt->read_reply(tnt, &reply);\n"
"   if (reply.code != 0) {\n"
"       printf(\"Insert failed %lu.\\n\", reply.code);\n"
"   }\n"
"   tnt_close(tnt);                                  /* See below = "
"TEARDOWN */\n"
"   tnt_stream_free(tuple);\n"
"   tnt_stream_free(tnt);\n"
"}"
msgstr ""
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"\n"
"void main() {\n"
"   struct tnt_stream *tnt = tnt_net(NULL);          /* См. ниже = "
"НАСТРОЙКА */\n"
"   tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"   if (tnt_connect(tnt) < 0) {                      /* См. ниже = "
"СОЕДИНЕНИЕ */\n"
"       printf(\"Connection refused\\n\");\n"
"       exit(-1);\n"
"   }\n"
"   struct tnt_stream *tuple = tnt_object(NULL);     /* См. ниже = "
"СОЗДАНИЕ ЗАПРОСА */\n"
"   tnt_object_format(tuple, \"[%d%s]\", 99999, \"B\");\n"
"   tnt_insert(tnt, 999, tuple);                     /* См. ниже = "
"ОТПРАВКА ЗАПРОСА */\n"
"   tnt_flush(tnt);\n"
"   struct tnt_reply reply;  tnt_reply_init(&reply); /* См. ниже = "
"ПОЛУЧЕНИЕ ОТВЕТА */\n"
"   tnt->read_reply(tnt, &reply);\n"
"   if (reply.code != 0) {\n"
"       printf(\"Insert failed %lu.\\n\", reply.code);\n"
"   }\n"
"   tnt_close(tnt);                                  /* См. ниже = "
"ЗАВЕРШЕНИЕ */\n"
"   tnt_stream_free(tuple);\n"
"   tnt_stream_free(tnt);\n"
"}"

#: ../doc/book/connectors/__c.rst:44
msgid ""
"Paste the code into a file named :file:`example.c` and install "
"``tarantool-c``. One way to install ``tarantool-c`` (using Ubuntu) is:"
msgstr ""
"Скопируйте исходный код программы в файл с именем :file:`example.c` и "
"установите коннектор ``tarantool-c``. Вот один из способов установки "
"``tarantool-c`` (под Ubuntu):"

#: ../doc/book/connectors/__c.rst:47
msgid ""
"$ git clone git://github.com/tarantool/tarantool-c.git ~/tarantool-c\n"
"$ cd ~/tarantool-c\n"
"$ git submodule init\n"
"$ git submodule update\n"
"$ cmake .\n"
"$ make\n"
"$ make install"
msgstr ""
"$ git clone git://github.com/tarantool/tarantool-c.git ~/tarantool-c\n"
"$ cd ~/tarantool-c\n"
"$ git submodule init\n"
"$ git submodule update\n"
"$ cmake .\n"
"$ make\n"
"$ make install"

#: ../doc/book/connectors/__c.rst:57 ../doc/book/connectors/__c.rst:282
msgid "To compile and link the program, say:"
msgstr ""
"Чтобы скомпилировать и слинковать тестовую программу, выполните следующую"
"  команду:"

#: ../doc/book/connectors/__c.rst:59
msgid ""
"$ # sometimes this is necessary:\n"
"$ export LD_LIBRARY_PATH=/usr/local/lib\n"
"$ gcc -o example example.c -ltarantool"
msgstr ""
"$ # иногда это необходимо:\n"
"$ export LD_LIBRARY_PATH=/usr/local/lib\n"
"$ gcc -o example example.c -ltarantool"

#: ../doc/book/connectors/__c.rst:65
#, fuzzy
msgid ""
"Before trying to run, check that a server instance is listening at "
"``localhost:3301`` and that the space ``examples`` exists, as "
":ref:`described earlier <index-connector_setting>`. To run the program, "
"say :samp:`./example`. The program will connect to the Tarantool "
"instance, and will send the request. If Tarantool is not running on "
"localhost with listen address = 3301, the program will print “Connection "
"refused”. If the insert fails, the program will print \"Insert failed\" "
"and an error number (see all error codes in the source file "
"`/src/box/errcode.h "
"<https://github.com/tarantool/tarantool/blob/2.1/src/box/errcode.h>`_)."
msgstr ""
"Перед запуском проверьте, что у экземпляра задан порт для прослушивания "
"на``localhost:3301``, и в базе создан спейс ``examples``, как "
":ref:`описано выше <index-connector_setting>`. Чтобы запустить программу,"
" выполните команду :samp:`./example`. Программа установит соединение с "
"экземпляром Tarantool'а и отправит запрос. Если Tarantool не запущен на "
"localhost на прослушивание по порту 3301, то программа выдаст сообщение "
"об ошибке “Connection refused”. Если вставка не сработает, программа "
"выдаст сообщение об ошибке \"Insert failed\" и код ошибки (все коды "
"ошибок см. в исходном файле `/src/box/errcode.h "
"<https://github.com/tarantool/tarantool/blob/1.10/src/box/errcode.h>`_)."

#: ../doc/book/connectors/__c.rst:77
msgid "Here are notes corresponding to comments in the example program."
msgstr ""
"Далее следуют примечания, на которые мы ссылались в комментариях к "
"исходному коду тестовой программы."

#: ../doc/book/connectors/__c.rst:79
msgid "**SETUP:** The setup begins by creating a stream."
msgstr "**НАСТРОЙКА:** Настройка начинается с создания потока (``tnt_stream``)."

#: ../doc/book/connectors/__c.rst:81
msgid ""
"struct tnt_stream *tnt = tnt_net(NULL);\n"
"tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");"
msgstr ""
"struct tnt_stream *tnt = tnt_net(NULL);\n"
"tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");"

#: ../doc/book/connectors/__c.rst:86
msgid ""
"In this program, the stream will be named ``tnt``. Before connecting on "
"the ``tnt`` stream, some options may have to be set. The most important "
"option is TNT_OPT_URI. In this program, the :ref:`URI <index-uri>` is "
"``localhost:3301``, since that is where the Tarantool instance is "
"supposed to be listening."
msgstr ""
"В нашей программе поток назван ``tnt``. Перед установкой соединения с "
"потоком ``tnt`` нужно задать ряд опций. Самая важная из них -- "
"TNT_OPT_URI. Для этой опции указан :ref:`URI <index-uri>` "
"``localhost:3301``, т.е. адрес, по которому должно быть настроено "
"прослушивание на стороне экземпляра Tarantool'а."

#: ../doc/book/connectors/__c.rst:92 ../doc/book/connectors/__c.rst:107
#: ../doc/book/connectors/__c.rst:134 ../doc/book/connectors/__c.rst:153
#: ../doc/book/connectors/__c.rst:177 ../doc/book/connectors/__c.rst:195
msgid "Function description:"
msgstr "Описание функции:"

#: ../doc/book/connectors/__c.rst:94
msgid ""
"struct tnt_stream *tnt_net(struct tnt_stream *s)\n"
"int tnt_set(struct tnt_stream *s, int option, variant option-value)"
msgstr ""
"struct tnt_stream *tnt_net(struct tnt_stream *s)\n"
"int tnt_set(struct tnt_stream *s, int option, variant option-value)"

#: ../doc/book/connectors/__c.rst:99
msgid ""
"**CONNECT:** Now that the stream named ``tnt`` exists and is associated "
"with a URI, this example program can connect to a server instance."
msgstr ""
"**СОЕДИНЕНИЕ:** Теперь когда мы создали поток с именем ``tnt`` и связали "
"его с конкретным URI, наша программа может устанавливать соединение с "
"экземпляром."

#: ../doc/book/connectors/__c.rst:102
msgid ""
"if (tnt_connect(tnt) < 0)\n"
"   { printf(\"Connection refused\\n\"); exit(-1); }"
msgstr ""
"if (tnt_connect(tnt) < 0)\n"
"   { printf(\"Connection refused\\n\"); exit(-1); }"

#: ../doc/book/connectors/__c.rst:109
msgid "int tnt_connect(struct tnt_stream *s)"
msgstr "int tnt_connect(struct tnt_stream *s)"

#: ../doc/book/connectors/__c.rst:113
msgid ""
"The connection might fail for a variety of reasons, such as: the server "
"is not running, or the URI contains an invalid :ref:`password"
"<authentication-passwords>`. If the connection fails, the return value "
"will be -1."
msgstr ""
"Попытка соединения может и не удаться по разным причинам, например если "
"Tarantool-сервер не запущен или в URI-строке указан неверный :ref:`пароль"
" <authentication-passwords>`. В случае неудачи функция вернет -1."

#: ../doc/book/connectors/__c.rst:117
msgid ""
"**MAKE REQUEST:** Most requests require passing a structured value, such "
"as the contents of a tuple."
msgstr ""
"**СОЗДАНИЕ ЗАПРОСА:** В большинстве запросов требуется передавать "
"структурированные данные, например содержимое кортежа."

#: ../doc/book/connectors/__c.rst:120
#, python-format
msgid ""
"struct tnt_stream *tuple = tnt_object(NULL);\n"
"tnt_object_format(tuple, \"[%d%s]\", 99999, \"B\");"
msgstr ""
"struct tnt_stream *tuple = tnt_object(NULL);\n"
"tnt_object_format(tuple, \"[%d%s]\", 99999, \"B\");"

#: ../doc/book/connectors/__c.rst:125
#, python-format
msgid ""
"In this program, the request will be an :ref:`INSERT<box_space-insert>`, "
"and the tuple contents will be an integer and a string. This is a simple "
"serial set of values, that is, there are no sub-structures or arrays. "
"Therefore it is easy in this case to format what will be passed using the"
" same sort of arguments that one would use with a C ``printf()`` "
"function: ``%d`` for the integer, ``%s`` for the string, then the integer"
" value, then a pointer to the string value."
msgstr ""
"В данной программе мы используем запрос :ref:`INSERT<box_space-insert>`, "
"а кортеж содержит целое число и строку.  Это простой набор значений без "
"каких-либо вложенных структур или массивов. И передаваемые значения мы "
"можем указать самым простым образом -- аналогично тому, как это сделано в"
" стандартной C-функции ``printf()``: ``%d`` для обозначения целого числа,"
" ``%s`` для обозначения строки, затем числовое значение, затем указатель "
"на строковое значение."

#: ../doc/book/connectors/__c.rst:136
msgid "ssize_t tnt_object_format(struct tnt_stream *s, const char *fmt, ...)"
msgstr "ssize_t tnt_object_format(struct tnt_stream *s, const char *fmt, ...)"

#: ../doc/book/connectors/__c.rst:140
msgid ""
"**SEND REQUEST:** The database-manipulation requests are analogous to the"
" requests in the box library."
msgstr ""
"**ОТПРАВКА ЗАПРОСА:** Отправка запросов на изменение данных в базе "
"делается аналогично тому, как это делается в Tarantool-библиотеке "
"``box``."

#: ../doc/book/connectors/__c.rst:143
msgid ""
"tnt_insert(tnt, 999, tuple);\n"
"tnt_flush(tnt);"
msgstr ""
"tnt_insert(tnt, 999, tuple);\n"
"tnt_flush(tnt);"

#: ../doc/book/connectors/__c.rst:148
msgid ""
"In this program, the choice is to do an INSERT request, so the program "
"passes the ``tnt_stream`` that was used for connection (``tnt``) and the "
"``tnt_stream`` that was set up with "
":c:func:`tarantoolc:tnt_object_format` (``tuple``)."
msgstr ""
"В данной программе мы делаем INSERT-запрос. В этом запросе мы передаем "
"поток ``tnt``, который ранее использовали для установки соединения, и "
"поток :code:`tuple`, который также ранее настроили с помощью функции "
":c:func:`tarantoolc:tnt_object_format`."

#: ../doc/book/connectors/__c.rst:155
msgid ""
"ssize_t tnt_insert(struct tnt_stream *s, uint32_t space, struct "
"tnt_stream *tuple)\n"
"ssize_t tnt_replace(struct tnt_stream *s, uint32_t space, struct "
"tnt_stream *tuple)\n"
"ssize_t tnt_select(struct tnt_stream *s, uint32_t space, uint32_t index,\n"
"                   uint32_t limit, uint32_t offset, uint8_t iterator,\n"
"                   struct tnt_stream *key)\n"
"ssize_t tnt_update(struct tnt_stream *s, uint32_t space, uint32_t index,\n"
"                   struct tnt_stream *key, struct tnt_stream *ops)"
msgstr ""
"ssize_t tnt_insert(struct tnt_stream *s, uint32_t space, struct "
"tnt_stream *tuple)\n"
"ssize_t tnt_replace(struct tnt_stream *s, uint32_t space, struct "
"tnt_stream *tuple)\n"
"ssize_t tnt_select(struct tnt_stream *s, uint32_t space, uint32_t index,\n"
"                   uint32_t limit, uint32_t offset, uint8_t iterator,\n"
"                   struct tnt_stream *key)\n"
"ssize_t tnt_update(struct tnt_stream *s, uint32_t space, uint32_t index,\n"
"                   struct tnt_stream *key, struct tnt_stream *ops)"

#: ../doc/book/connectors/__c.rst:165
msgid ""
"**GET REPLY:** For most requests, the client will receive a reply "
"containing some indication whether the result was successful, and a set "
"of tuples."
msgstr ""
"**ПОЛУЧЕНИЕ ОТВЕТА:** На большинство запросов клиент получает ответ, "
"который содержит информацию о том, был ли данный запрос успешно выполнен,"
"  а также содержит набор кортежей."

#: ../doc/book/connectors/__c.rst:168
#, python-format
msgid ""
"struct tnt_reply reply;  tnt_reply_init(&reply);\n"
"tnt->read_reply(tnt, &reply);\n"
"if (reply.code != 0)\n"
"   { printf(\"Insert failed %lu.\\n\", reply.code); }"
msgstr ""
"struct tnt_reply reply;  tnt_reply_init(&reply);\n"
"tnt->read_reply(tnt, &reply);\n"
"if (reply.code != 0)\n"
"   { printf(\"Insert failed %lu.\\n\", reply.code); }"

#: ../doc/book/connectors/__c.rst:175
msgid "This program checks for success but does not decode the rest of the reply."
msgstr ""
"Данная программа проверяет, был ли запрос выполнен успешно, но никак не "
"интерпретирует оставшуюся часть ответа."

#: ../doc/book/connectors/__c.rst:179
msgid ""
"struct tnt_reply *tnt_reply_init(struct tnt_reply *r)\n"
"tnt->read_reply(struct tnt_stream *s, struct tnt_reply *r)\n"
"void tnt_reply_free(struct tnt_reply *r)"
msgstr ""
"struct tnt_reply *tnt_reply_init(struct tnt_reply *r)\n"
"tnt->read_reply(struct tnt_stream *s, struct tnt_reply *r)\n"
"void tnt_reply_free(struct tnt_reply *r)"

#: ../doc/book/connectors/__c.rst:185
msgid ""
"**TEARDOWN:** When a session ends, the connection that was made with "
":c:func:`tarantoolc:tnt_connect()` should be closed, and the objects that"
" were made in the setup should be destroyed."
msgstr ""
"**ЗАВЕРШЕНИЕ:** По окончании сессии нам нужно закрыть соединение, "
"созданное с помощью функции :c:func:`tarantoolc:tnt_connect()`, и удалить"
"  объекты, созданные на этапе настройки."

#: ../doc/book/connectors/__c.rst:189
msgid ""
"tnt_close(tnt);\n"
"tnt_stream_free(tuple);\n"
"tnt_stream_free(tnt);"
msgstr ""
"tnt_close(tnt);\n"
"tnt_stream_free(tuple);\n"
"tnt_stream_free(tnt);"

#: ../doc/book/connectors/__c.rst:197
msgid ""
"void tnt_close(struct tnt_stream *s)\n"
"void tnt_stream_free(struct tnt_stream *s)"
msgstr ""
"void tnt_close(struct tnt_stream *s)\n"
"void tnt_stream_free(struct tnt_stream *s)"

#: ../doc/book/connectors/__c.rst:204
msgid "Example 2"
msgstr "Пример 2"

#: ../doc/book/connectors/__c.rst:206
msgid ""
"Here is a complete C program that selects, using index key ``[99999]``, "
"from space ``examples`` via the high-level C API. To display the results,"
" the program uses functions in the `MsgPuck "
"<http://rtsisyk.github.io/msgpuck/>`_ library which allow decoding of "
"`MessagePack <https://en.wikipedia.org/wiki/MessagePack>`_  arrays."
msgstr ""
"Далее приводится еще один пример полноценной программы на языке C, "
"которая осуществляет выборку по индекс-ключу ``[99999]`` из спейса "
"``examples`` с помощью высокоуровневого Tarantool API для языка C. Для "
"вывода результатов в этой программе используются функции из библиотеки "
"`MsgPuck <http://rtsisyk.github.io/msgpuck/>`_. Эти функции нужны для "
"декодирования массивов значений в формате `MessagePack "
"<https://en.wikipedia.org/wiki/MessagePack>`_."

#: ../doc/book/connectors/__c.rst:212
#, python-format
msgid ""
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"\n"
"#define MP_SOURCE 1\n"
"#include <msgpuck.h>\n"
"\n"
"void main() {\n"
"    struct tnt_stream *tnt = tnt_net(NULL);\n"
"    tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"    if (tnt_connect(tnt) < 0) {\n"
"        printf(\"Connection refused\\n\");\n"
"        exit(1);\n"
"    }\n"
"    struct tnt_stream *tuple = tnt_object(NULL);\n"
"    tnt_object_format(tuple, \"[%d]\", 99999); /* tuple = search key */\n"
"    tnt_select(tnt, 999, 0, (2^32) - 1, 0, 0, tuple);\n"
"    tnt_flush(tnt);\n"
"    struct tnt_reply reply; tnt_reply_init(&reply);\n"
"    tnt->read_reply(tnt, &reply);\n"
"    if (reply.code != 0) {\n"
"        printf(\"Select failed.\\n\");\n"
"        exit(1);\n"
"    }\n"
"    char field_type;\n"
"    field_type = mp_typeof(*reply.data);\n"
"    if (field_type != MP_ARRAY) {\n"
"        printf(\"no tuple array\\n\");\n"
"        exit(1);\n"
"    }\n"
"    long unsigned int row_count;\n"
"    uint32_t tuple_count = mp_decode_array(&reply.data);\n"
"    printf(\"tuple count=%u\\n\", tuple_count);\n"
"    unsigned int i, j;\n"
"    for (i = 0; i < tuple_count; ++i) {\n"
"        field_type = mp_typeof(*reply.data);\n"
"        if (field_type != MP_ARRAY) {\n"
"            printf(\"no field array\\n\");\n"
"            exit(1);\n"
"        }\n"
"        uint32_t field_count = mp_decode_array(&reply.data);\n"
"        printf(\"  field count=%u\\n\", field_count);\n"
"        for (j = 0; j < field_count; ++j) {\n"
"            field_type = mp_typeof(*reply.data);\n"
"            if (field_type == MP_UINT) {\n"
"                uint64_t num_value = mp_decode_uint(&reply.data);\n"
"                printf(\"    value=%lu.\\n\", num_value);\n"
"            } else if (field_type == MP_STR) {\n"
"                const char *str_value;\n"
"                uint32_t str_value_length;\n"
"                str_value = mp_decode_str(&reply.data, "
"&str_value_length);\n"
"                printf(\"    value=%.*s.\\n\", str_value_length, "
"str_value);\n"
"            } else {\n"
"                printf(\"wrong field type\\n\");\n"
"                exit(1);\n"
"            }\n"
"        }\n"
"    }\n"
"    tnt_close(tnt);\n"
"    tnt_stream_free(tuple);\n"
"    tnt_stream_free(tnt);\n"
"}"
msgstr ""
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"\n"
"#define MP_SOURCE 1\n"
"#include <msgpuck.h>\n"
"\n"
"void main() {\n"
"    struct tnt_stream *tnt = tnt_net(NULL);\n"
"    tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"    if (tnt_connect(tnt) < 0) {\n"
"        printf(\"Connection refused\\n\");\n"
"        exit(1);\n"
"    }\n"
"    struct tnt_stream *tuple = tnt_object(NULL);\n"
"    tnt_object_format(tuple, \"[%d]\", 99999); /* кортеж tuple = ключ для"
" поиска */\n"
"    tnt_select(tnt, 999, 0, (2^32) - 1, 0, 0, tuple);\n"
"    tnt_flush(tnt);\n"
"    struct tnt_reply reply; tnt_reply_init(&reply);\n"
"    tnt->read_reply(tnt, &reply);\n"
"    if (reply.code != 0) {\n"
"        printf(\"Select failed.\\n\");\n"
"        exit(1);\n"
"    }\n"
"    char field_type;\n"
"    field_type = mp_typeof(*reply.data);\n"
"    if (field_type != MP_ARRAY) {\n"
"        printf(\"no tuple array\\n\");\n"
"        exit(1);\n"
"    }\n"
"    long unsigned int row_count;\n"
"    uint32_t tuple_count = mp_decode_array(&reply.data);\n"
"    printf(\"tuple count=%u\\n\", tuple_count);\n"
"    unsigned int i, j;\n"
"    for (i = 0; i < tuple_count; ++i) {\n"
"        field_type = mp_typeof(*reply.data);\n"
"        if (field_type != MP_ARRAY) {\n"
"            printf(\"no field array\\n\");\n"
"            exit(1);\n"
"        }\n"
"        uint32_t field_count = mp_decode_array(&reply.data);\n"
"        printf(\"  field count=%u\\n\", field_count);\n"
"        for (j = 0; j < field_count; ++j) {\n"
"            field_type = mp_typeof(*reply.data);\n"
"            if (field_type == MP_UINT) {\n"
"                uint64_t num_value = mp_decode_uint(&reply.data);\n"
"                printf(\"    value=%lu.\\n\", num_value);\n"
"            } else if (field_type == MP_STR) {\n"
"                const char *str_value;\n"
"                uint32_t str_value_length;\n"
"                str_value = mp_decode_str(&reply.data, "
"&str_value_length);\n"
"                printf(\"    value=%.*s.\\n\", str_value_length, "
"str_value);\n"
"            } else {\n"
"                printf(\"wrong field type\\n\");\n"
"                exit(1);\n"
"            }\n"
"        }\n"
"    }\n"
"    tnt_close(tnt);\n"
"    tnt_stream_free(tuple);\n"
"    tnt_stream_free(tnt);\n"
"}"

#: ../doc/book/connectors/__c.rst:279
msgid ""
"Similarly to the first example, paste the code into a file named "
":file:`example2.c`."
msgstr ""
"Аналогично первому примеру, сохраните исходный код программы в файле с "
"именем :file:`example2.c`."

#: ../doc/book/connectors/__c.rst:284
msgid "$ gcc -o example2 example2.c -ltarantool"
msgstr "$ gcc -o example2 example2.c -ltarantool"

#: ../doc/book/connectors/__c.rst:288
msgid "To run the program, say :samp:`./example2`."
msgstr "Для запуска программы выполните команду :samp:`./example2`."

#: ../doc/book/connectors/__c.rst:290
msgid ""
"The two example programs only show a few requests and do not show all "
"that's necessary for good practice. See more in the `tarantool-c "
"documentation at GitHub <http://github.com/tarantool/tarantool-c>`_."
msgstr ""
"В этих двух программах мы привели пример использования лишь двух "
"запросов. Для полноценной работы с Tarantool'ом с помощью C API, "
"пожалуйста, обратитесь к документации из `проекта tarantool-c на GitHub "
"<http://github.com/tarantool/tarantool-c>`_."

#: ../doc/book/connectors/__csharp.rst:3
msgid "C#"
msgstr "C#"

#: ../doc/book/connectors/__csharp.rst:5
msgid ""
"The most commonly used C# driver is `progaudi.tarantool "
"<https://github.com/progaudi/progaudi.tarantool>`_, previously named "
"``tarantool-csharp``. It is not supplied as part of the Tarantool "
"repository; it must be installed separately. The makers recommend `cross-"
"platform installation using Nuget "
"<https://www.nuget.org/packages/progaudi.tarantool>`_."
msgstr ""
"Самый используемый драйвер для C# -- `progaudi.tarantool "
"<https://github.com/progaudi/progaudi.tarantool>`_, который раньше "
"назывался ``tarantool-csharp``. Он не входит в репозиторий Tarantool'а, "
"его необходимо устанавливать отдельно. Создатели драйвера рекомендуют "
"`кроссплатформенную установку с помощью Nuget "
"<https://www.nuget.org/packages/progaudi.tarantool>`_."

#: ../doc/book/connectors/__csharp.rst:11
msgid ""
"To be consistent with the other instructions in this chapter, here is a "
"way to install the driver directly on Ubuntu 16.04."
msgstr ""
"Чтобы придерживаться метода оформления других инструкций в данной главе, "
"дадим описание способа установки драйвера напрямую на 16.04."

#: ../doc/book/connectors/__csharp.rst:14
msgid ""
"Install .net core from Microsoft. Follow `.net core installation "
"instructions <https://www.microsoft.com/net/core#ubuntu>`_."
msgstr ""
"Установите среду .NET Core от Microsoft. Следуйте `инструкциям по "
"установке .NET Core <https://www.microsoft.com/net/core#ubuntu>`_."

#: ../doc/book/connectors/__csharp.rst:19
msgid ""
"Mono will not work, nor will .Net from xbuild. Only .net core supported "
"on Linux and Mac."
msgstr ""
"Mono не сработает, как не сработает и .Net от xbuild. Только .NET Core "
"поддерживается на Linux и Mac."

#: ../doc/book/connectors/__csharp.rst:21
msgid ""
"Read the Microsoft End User License Agreement first, because it is not an"
" ordinary open-source agreement and there will be a message during "
"installation saying \"This software may collect information about you and"
" your use of the software, and send that to Microsoft.\" Still you can "
"`set environment variables <https://docs.microsoft.com/en-"
"us/dotnet/core/tools/telemetry#behavior>`_ to opt out from telemetry."
msgstr ""
"Сначала прочитайте Условия лицензионного соглашения с Microsoft, "
"поскольку оно не похоже на обычные соглашения для ПО с открытым кодом, и "
"во время установки система выдаст сообщение о том, что ПО может собирать "
"информацию (\"This software may collect information about you and your "
"use of the software, and send that to Microsoft.\"). Несмотря на это, "
"можно `определить переменные окружения  <https://docs.microsoft.com/en-"
"us/dotnet/core/tools/telemetry#behavior>`_, чтобы отказаться от участия в"
" сборе телеметрических данных."

#: ../doc/book/connectors/__csharp.rst:29
msgid "Create a new console project."
msgstr "Создайте новый консольный проект."

#: ../doc/book/connectors/__csharp.rst:31
msgid ""
"$ cd ~\n"
"$ mkdir progaudi.tarantool.test\n"
"$ cd progaudi.tarantool.test\n"
"$ dotnet new console"
msgstr ""
"$ cd ~\n"
"$ mkdir progaudi.tarantool.test\n"
"$ cd progaudi.tarantool.test\n"
"$ dotnet new console"

#: ../doc/book/connectors/__csharp.rst:38
msgid "Add ``progaudi.tarantool`` reference."
msgstr "Добавьте ссылку на ``progaudi.tarantool``."

#: ../doc/book/connectors/__csharp.rst:40
msgid "$ dotnet add package progaudi.tarantool"
msgstr "$ dotnet add package progaudi.tarantool"

#: ../doc/book/connectors/__csharp.rst:44
msgid "Change code in ``Program.cs``."
msgstr "Измените код в ``Program.cs``."

#: ../doc/book/connectors/__csharp.rst:46
msgid ""
"$ cat <<EOT > Program.cs\n"
"using System;\n"
"using System.Threading.Tasks;\n"
"using ProGaudi.Tarantool.Client;\n"
"\n"
"public class HelloWorld\n"
"{\n"
"  static public void Main ()\n"
"  {\n"
"    Test().GetAwaiter().GetResult();\n"
"  }\n"
"  static async Task Test()\n"
"  {\n"
"    var box = await Box.Connect(\"127.0.0.1:3301\");\n"
"    var schema = box.GetSchema();\n"
"    var space = await schema.GetSpace(\"examples\");\n"
"    await space.Insert((99999, \"BB\"));\n"
"  }\n"
"}\n"
"EOT"
msgstr ""
"$ cat <<EOT > Program.cs\n"
"using System;\n"
"using System.Threading.Tasks;\n"
"using ProGaudi.Tarantool.Client;\n"
"\n"
"public class HelloWorld\n"
"{\n"
"  static public void Main ()\n"
"  {\n"
"    Test().GetAwaiter().GetResult();\n"
"  }\n"
"  static async Task Test()\n"
"  {\n"
"    var box = await Box.Connect(\"127.0.0.1:3301\");\n"
"    var schema = box.GetSchema();\n"
"    var space = await schema.GetSpace(\"examples\");\n"
"    await space.Insert((99999, \"BB\"));\n"
"  }\n"
"}\n"
"EOT"

#: ../doc/book/connectors/__csharp.rst:69
msgid "Build and run your application."
msgstr "Соберите и запустите приложение."

#: ../doc/book/connectors/__csharp.rst:71
msgid ""
"Before trying to run, check that the server is listening at "
"``localhost:3301`` and that the space ``examples`` exists, as "
":ref:`described earlier <index-connector_setting>`."
msgstr ""
"Перед запуском проверьте, что у экземпляра задан порт для прослушивания "
"на``localhost:3301``, и в базе создан спейс ``examples``, как "
":ref:`описано выше <index-connector_setting>`."

#: ../doc/book/connectors/__csharp.rst:75
msgid ""
"$ dotnet restore\n"
"$ dotnet run"
msgstr ""
"$ dotnet restore\n"
"$ dotnet run"

#: ../doc/book/connectors/__csharp.rst:80
msgid "The program will:"
msgstr "Программа:"

#: ../doc/book/connectors/__csharp.rst:82
msgid "connect using an application-specific definition of the space,"
msgstr "установит соединение, используя определение спейса для этой цели,"

#: ../doc/book/connectors/__csharp.rst:83
msgid "open a socket connection with the Tarantool server at `localhost:3301`,"
msgstr "откроет сокет для соединения с экземпляром по ``localhost:3301``,"

#: ../doc/book/connectors/__csharp.rst:84
msgid ""
"send an INSERT request, and — if all is well — end without saying "
"anything."
msgstr ""
"отправит INSERT-запрос, а затем -- если всё хорошо -- закончит работу без"
" каких-либо сообщений."

#: ../doc/book/connectors/__csharp.rst:86
msgid ""
"If Tarantool is not running on localhost with listen port = 3301, or if "
"user 'guest' does not have authorization to connect, or if the INSERT "
"request fails for any reason, the program will print an error message, "
"among other things (stacktrace, etc)."
msgstr ""
"Если Tarantool не запущен на ``localhost`` на прослушивание по порту "
"3301, или у пользователя 'guest' нет прав на соединение, или запрос "
"вставки по какой-либо причине не сработает, то программа выдаст сообщение"
" об ошибке и другую информацию (трассировку стека и т.д.)."

#: ../doc/book/connectors/__csharp.rst:91
msgid ""
"The example program only shows one request and does not show all that’s "
"necessary for good practice. For that, please see the `progaudi.tarantool"
" driver repository <https://github.com/progaudi/progaudi.tarantool>`_."
msgstr ""
"В этой программе мы привели пример использования лишь одного запроса. Для"
"  полноценной работы с Tarantool'ом с помощью PHP API, пожалуйста, "
"обратитесь к документации из `проекта tarantool-php на GitHub "
"<https://github.com/tarantool/tarantool-php>`_."

#: ../doc/book/connectors/__erlang.rst:3
msgid "Erlang"
msgstr "Erlang"

#: ../doc/book/connectors/__erlang.rst:5
msgid "See `Erlang tarantool driver <https://github.com/stofel/taran>`_."
msgstr "См. `Erlang-драйвер для Tarantool'а <https://github.com/stofel/taran>`_."

#: ../doc/book/connectors/__go.rst:3
msgid "Go"
msgstr "Go"

#: ../doc/book/connectors/__go.rst:5
msgid "Please see https://github.com/mialinx/go-tarantool."
msgstr "См. https://github.com/mialinx/go-tarantool."

#: ../doc/book/connectors/__java.rst:3
msgid "Java"
msgstr "Java"

#: ../doc/book/connectors/__java.rst:5
msgid "See http://github.com/tarantool/tarantool-java/."
msgstr "См. http://github.com/tarantool/tarantool-java/."

#: ../doc/book/connectors/__nodejs.rst:3
msgid "Node.js"
msgstr "Node.js"

#: ../doc/book/connectors/__nodejs.rst:5
msgid ""
"The most commonly used node.js driver is the `Node Tarantool driver "
"<https://github.com/KlonD90/node-tarantool-driver>`_. It is not supplied "
"as part of the Tarantool repository; it must be installed separately. The"
" most common way to install it is with `npm <https://www.sitepoint.com"
"/beginners-guide-node-package-manager/>`_. For example, on Ubuntu, the "
"installation could look like this after npm has been installed:"
msgstr ""
"Самый используемый драйвер для node.js -- `Node Tarantool driver "
"<https://github.com/KlonD90/node-tarantool-driver>`_. Он не входит в "
"репозиторий Tarantool'а, его необходимо устанавливать отдельно. Проще "
"всего установить его вместе с `npm <https://www.sitepoint.com/beginners-"
"guide-node-package-manager/>`_. Например, на Ubuntu, когда npm уже "
"установлен, установка драйвера будет выглядеть следующим образом:"

#: ../doc/book/connectors/__nodejs.rst:13
msgid "$ npm install tarantool-driver --global"
msgstr "$ npm install tarantool-driver --global"

#: ../doc/book/connectors/__nodejs.rst:17
msgid ""
"Here is a complete node.js program that inserts ``[99999,'BB']`` into "
"``space[999]`` via the node.js API. Before trying to run, check that the "
"server instance is :ref:`listening <cfg_basic-listen>` at "
"``localhost:3301`` and that the space ``examples`` exists, as "
":ref:`described earlier <index-connector_setting>`. To run, paste the "
"code into a file named :file:`example.rs` and say ``node example.rs``. "
"The program will connect using an application-specific definition of the "
"space. The program will open a socket connection with the Tarantool "
"instance at ``localhost:3301``, then send an :ref:`INSERT <box_space-"
"insert>` request, then — if all is well — end after saying \"Insert "
"succeeded\". If Tarantool is not running on ``localhost`` with listen "
"port = 3301, the program will print “Connect failed”. If :ref:`the "
"'guest' user <box_space-user>` does not have authorization to connect, "
"the program will print \"Auth failed\". If the insert request fails for "
"any reason, for example because the tuple already exists, the program "
"will print \"Insert failed\"."
msgstr ""
"Далее приводится пример полноценной программы на языке node.js, которая "
"осуществляет вставку кортежа ``[99999,'BB']`` в спейс ``space[999]`` с "
"помощью API для языка node.js. Перед запуском проверьте, что у экземпляра"
" задан порт для :ref:`прослушивания <cfg_basic-listen>` на "
"``localhost:3301``, и в базе создан спейс ``examples``, как :ref:`описано"
" выше <index-connector_setting>`. Чтобы запустить программу, сохраните "
"код в файл с именем :file:`example.rs` и выполните команду ``node "
"example.rs``. Программа установит соединение, используя определение "
"спейса для этой цели, откроет сокет для соединения с экземпляром по "
"``localhost:3301``, отправит :ref:`INSERT-запрос <box_space-insert>`, а "
"затем -- если всё хорошо -- выдаст сообщение \"Insert succeeded\". Если "
"Tarantool не запущен на ``localhost`` на прослушивание по порту = 3301, "
"то программа выдаст сообщение об ошибке “Connect failed”. Если у "
":ref:`пользователя 'guest' <box_space-user>` нет прав на соединение, "
"программа выдаст сообщение об ошибке \"Auth failed\". Если запрос вставки"
" по какой-либо причине не сработает, например поскольку такой кортеж уже "
"существует, то программа выдаст сообщение об ошибке \"Insert failed\"."

#: ../doc/book/connectors/__nodejs.rst:31
msgid ""
"var TarantoolConnection = require('tarantool-driver');\n"
"var conn = new TarantoolConnection({port: 3301});\n"
"var insertTuple = [99999, \"BB\"];\n"
"conn.connect().then(function() {\n"
"    conn.auth(\"guest\", \"\").then(function() {\n"
"        conn.insert(999, insertTuple).then(function() {\n"
"            console.log(\"Insert succeeded\");\n"
"            process.exit(0);\n"
"    }, function(e) { console.log(\"Insert failed\");  process.exit(1); "
"});\n"
"    }, function(e) { console.log(\"Auth failed\");    process.exit(1); "
"});\n"
"    }, function(e) { console.log(\"Connect failed\"); process.exit(1); });"
msgstr ""
"var TarantoolConnection = require('tarantool-driver');\n"
"var conn = new TarantoolConnection({port: 3301});\n"
"var insertTuple = [99999, \"BB\"];\n"
"conn.connect().then(function() {\n"
"    conn.auth(\"guest\", \"\").then(function() {\n"
"        conn.insert(999, insertTuple).then(function() {\n"
"            console.log(\"Insert succeeded\");\n"
"            process.exit(0);\n"
"    }, function(e) { console.log(\"Insert failed\");  process.exit(1); "
"});\n"
"    }, function(e) { console.log(\"Auth failed\");    process.exit(1); "
"});\n"
"    }, function(e) { console.log(\"Connect failed\"); process.exit(1); });"

#: ../doc/book/connectors/__nodejs.rst:45
msgid ""
"The example program only shows one request and does not show all that's "
"necessary for good practice. For that, please see  `The node.js driver "
"repository <https://github.com/KlonD90/node-tarantool-driver>`_."
msgstr ""
"В этой программе мы привели пример использования лишь одного запроса. Для"
" полноценной работы с Tarantool'ом обратитесь к документации из "
"`репозитория драйвера для node.js <https://github.com/KlonD90/node-"
"tarantool-driver>`_."

#: ../doc/book/connectors/__perl.rst:3
msgid "Perl"
msgstr "Perl"

#: ../doc/book/connectors/__perl.rst:5
msgid ""
"The most commonly used Perl driver is `tarantool-perl "
"<https://github.com/tarantool/tarantool-perl>`_. It is not supplied as "
"part of the Tarantool repository; it must be installed separately. The "
"most common way to install it is by cloning from GitHub."
msgstr ""
"Самый используемый драйвер для Perl -- `tarantool-perl "
"<https://github.com/tarantool/tarantool-perl>`_. Он не входит в "
"репозиторий Tarantool'а, его необходимо устанавливать отдельно. Проще "
"всего установить его путем клонирования с GitHub."

#: ../doc/book/connectors/__perl.rst:10
msgid ""
"To avoid minor warnings that may appear the first time ``tarantool-perl``"
" is installed, start with installing some other modules that ``tarantool-"
"perl`` uses, with `CPAN, the Comprehensive Perl Archive Network "
"<https://en.wikipedia.org/wiki/Cpan>`_:"
msgstr ""
"Во избежание незначительных предупреждений, которые может выдать система "
"после первой установки ``tarantool-perl``, начните установку с некоторых "
"других модулей, которые использует ``tarantool-perl``, с `CPAN, the "
"Comprehensive Perl Archive Network (Всеобъемлющая сеть архивов Perl) "
"<https://ru.wikipedia.org/wiki/CPAN>`_:"

#: ../doc/book/connectors/__perl.rst:14
msgid ""
"$ sudo cpan install AnyEvent\n"
"$ sudo cpan install Devel::GlobalDestruction"
msgstr ""
"$ sudo cpan install AnyEvent\n"
"$ sudo cpan install Devel::GlobalDestruction"

#: ../doc/book/connectors/__perl.rst:19
msgid "Then, to install ``tarantool-perl`` itself, say:"
msgstr "Затем для установки самого ``tarantool-perl``, выполните:"

#: ../doc/book/connectors/__perl.rst:21
msgid ""
"$ git clone https://github.com/tarantool/tarantool-perl.git tarantool-"
"perl\n"
"$ cd tarantool-perl\n"
"$ git submodule init\n"
"$ git submodule update --recursive\n"
"$ perl Makefile.PL\n"
"$ make\n"
"$ sudo make install"
msgstr ""
"$ git clone https://github.com/tarantool/tarantool-perl.git tarantool-"
"perl\n"
"$ cd tarantool-perl\n"
"$ git submodule init\n"
"$ git submodule update --recursive\n"
"$ perl Makefile.PL\n"
"$ make\n"
"$ sudo make install"

#: ../doc/book/connectors/__perl.rst:31
msgid ""
"Here is a complete Perl program that inserts ``[99999,'BB']`` into "
"``space[999]`` via the Perl API. Before trying to run, check that the "
"server instance is listening at ``localhost:3301`` and that the space "
"``examples`` exists, as :ref:`described earlier <index-"
"connector_setting>`. To run, paste the code into a file named "
":file:`example.pl` and say :samp:`perl example.pl`. The program will "
"connect using an application-specific definition of the space. The "
"program will open a socket connection with the Tarantool instance at "
"``localhost:3301``, then send an :ref:`space_object:INSERT<box_space-"
"insert>` request, then — if all is well — end without displaying any "
"messages. If Tarantool is not running on ``localhost`` with :ref:`listen"
"<cfg_basic-listen>` port = 3301, the program will print “Connection "
"refused”."
msgstr ""
"Далее приводится пример полноценной программы на языке Perl, которая "
"осуществляет вставку кортежа ``[99999,'BB']`` в спейс ``space[999]`` с "
"помощью API для языка Perl. Перед запуском проверьте, что у экземпляра "
"задан порт для прослушивания на ``localhost:3301``, и в базе создан спейс"
" ``examples``, как :ref:`описано выше <index-connector_setting>`.  Чтобы "
"запустить программу, сохраните код в файл с именем :file:`example.pl` и "
"выполните команду :samp:`perl example.pl`. Программа установит "
"соединение, используя определение спейса для этой цели, откроет сокет для"
" соединения с экземпляром по ``localhost:3301``, пошлет запрос "
":ref:`space_object:INSERT<box_space-insert>`, а затем -- если всё хорошо "
"-- закончит работу без каких-либо сообщений. Если Tarantool не запущен на"
" ``localhost`` на :ref:`прослушивание <cfg_basic-listen>` по порту = "
"3301, то программа выдаст сообщение об ошибке \"Connection refused\"."

#: ../doc/book/connectors/__perl.rst:43
msgid ""
"#!/usr/bin/perl\n"
"use DR::Tarantool ':constant', 'tarantool';\n"
"use DR::Tarantool ':all';\n"
"use DR::Tarantool::MsgPack::SyncClient;\n"
"\n"
"my $tnt = DR::Tarantool::MsgPack::SyncClient->connect(\n"
"  host    => '127.0.0.1',                      # look for tarantool on "
"localhost\n"
"  port    => 3301,                             # on port 3301\n"
"  user    => 'guest',                          # username. for 'guest' we"
" do not also say 'password=>...'\n"
"\n"
"  spaces  => {\n"
"    999 => {                                   # definition of space[999]"
" ...\n"
"      name => 'examples',                      #   space[999] name = "
"'examples'\n"
"      default_type => 'STR',                   #   space[999] field type "
"is 'STR' if undefined\n"
"      fields => [ {                            #   definition of "
"space[999].fields ...\n"
"          name => 'field1', type => 'NUM' } ], #     space[999].field[1] "
"name='field1',type='NUM'\n"
"      indexes => {                             #   definition of "
"space[999] indexes ...\n"
"        0 => {\n"
"          name => 'primary', fields => [ 'field1' ] } } } } );\n"
"\n"
"$tnt->insert('examples' => [ 99999, 'BB' ]);"
msgstr ""
"#!/usr/bin/perl\n"
"#!/usr/bin/perl\n"
"use DR::Tarantool ':constant', 'tarantool';\n"
"use DR::Tarantool ':all';\n"
"use DR::Tarantool::MsgPack::SyncClient;\n"
"\n"
"  host    => '127.0.0.1',                      # поиск Tarantool-сервера "
"по адресу localhost\n"
"  port    => 3301,                             # на порту 3301\n"
"  user    => 'guest',                          # имя пользователя; здесь "
"же можно добавить 'password=>...'\n"
"\n"
"  spaces  => {\n"
"    999 => {                                   # определение спейса  "
"space[999] ...\n"
"      name => 'examples',                      # имя спейса space[999] = "
"'examples'\n"
"      default_type => 'STR',                   # если тип поля в "
"space[999] не задан, то = 'STR'\n"
"      fields => [ {                            # определение полей в "
"спейсе space[999] ...\n"
"          name => 'field1', type => 'NUM' } ], # имя поля "
"space[999].field[1]='field1', тип ='NUM'\n"
"      indexes => {                             # определение индексов "
"спейса space[999] ...\n"
"        0 => {\n"
"          name => 'primary', fields => [ 'field1' ] } } } } );\n"
"\n"
"$tnt->insert('examples' => [ 99999, 'BB' ]);"

#: ../doc/book/connectors/__perl.rst:67
msgid ""
"The example program uses field type names 'STR' and 'NUM' instead of "
":ref:`'string' and 'unsigned'<box_space-create_index>`, due to a "
"temporary Perl limitation."
msgstr ""
"Из-за временных ограничений в языке Perl, вместо полей типа "
":ref:`'string' и 'unsigned'<box_space-create_index>` в тестовой программе"
" указаны поля типа 'STR' и 'NUM'."

#: ../doc/book/connectors/__perl.rst:70
msgid ""
"The example program only shows one request and does not show all that's "
"necessary for good practice. For that, please see the `tarantool-perl "
"repository <https://github.com/tarantool/tarantool-perl>`_."
msgstr ""
"В этой программе мы привели пример использования лишь одного запроса. Для"
" полноценной работы с Tarantool'ом обратитесь к документации из "
"`репозитория tarantool-perl <https://github.com/tarantool/tarantool-"
"perl>`_."

#: ../doc/book/connectors/__php.rst:3
msgid "PHP"
msgstr "PHP"

#: ../doc/book/connectors/__php.rst:5
msgid ""
"`tarantool-php <https://github.com/tarantool/tarantool-php>`_ is the "
"official PHP connector for Tarantool. It is not supplied as part of the "
"Tarantool repository and must be installed separately (see `installation "
"instructions <https://github.com/tarantool/tarantool-php/#installing-and-"
"building>`_ in the connector's ``README`` file)."
msgstr ""
"`tarantool-php <https://github.com/tarantool/tarantool-php>`_ -- это "
"официальный PHP-коннектор для Tarantool'а. Он не входит в репозиторий "
"Tarantool'а, его необходимо устанавливать отдельно (`инструкции по "
"установке <https://github.com/tarantool/tarantool-php/#installing-and-"
"building>`_ см. в файле коннектора :file:`README`)."

#: ../doc/book/connectors/__php.rst:12
msgid ""
"Here is a complete PHP program that inserts ``[99999,'BB']`` into a space"
" named ``examples`` via the PHP API."
msgstr ""
"Далее приводится пример полноценной программы на языке PHP, которая "
"осуществляет вставку кортежа ``[99999,'BB']`` в спейс ``examples``  с "
"помощью API для языка PHP."

#: ../doc/book/connectors/__php.rst:15
msgid ""
"Before trying to run, check that the server instance is :ref:`listening "
"<cfg_basic-listen>` at ``localhost:3301`` and that the space ``examples``"
" exists, as :ref:`described earlier <index-connector_setting>`."
msgstr ""
"Перед запуском проверьте, что у экземпляра задан порт для "
":ref:`прослушивания <cfg_basic-listen>` на ``localhost:3301``, и в базе "
"создан спейс ``examples``, как :ref:`описано выше <index-"
"connector_setting>`."

#: ../doc/book/connectors/__php.rst:19
msgid "To run, paste the code into a file named :file:`example.php` and say:"
msgstr ""
"Чтобы запустить программу, сохраните код в файл с именем "
":file:`example.php` и выполните:"

#: ../doc/book/connectors/__php.rst:21
msgid "$ php -d extension=~/tarantool-php/modules/tarantool.so example.php"
msgstr "$ php -d extension=~/tarantool-php/modules/tarantool.so example.php"

#: ../doc/book/connectors/__php.rst:25
msgid ""
"The program will open a socket connection with the Tarantool instance at "
"``localhost:3301``, then send an :ref:`INSERT <box_space-insert>` "
"request, then -- if all is well -- print \"Insert succeeded\"."
msgstr ""
"Программа откроет сокет для соединения с экземпляром по "
"``localhost:3301``, отправит :ref:`INSERT-запрос <box_space-insert>`, а "
"затем -- если всё хорошо -- выдаст сообщение \"Insert succeeded\"."

#: ../doc/book/connectors/__php.rst:29
msgid ""
"If the tuple already exists, the program will print \"Duplicate key "
"exists in unique index 'primary' in space 'examples'\"."
msgstr ""
"Если такой кортеж уже существует, то программа выдаст сообщение об ошибке"
" “Duplicate key exists in unique index 'primary' in space 'examples'”."

#: ../doc/book/connectors/__php.rst:32
msgid ""
"<?php\n"
"$tarantool = new Tarantool('localhost', 3301);\n"
"\n"
"try {\n"
"    $tarantool->insert('examples', [99999, 'BB']);\n"
"    echo \"Insert succeeded\\n\";\n"
"} catch (Exception $e) {\n"
"    echo $e->getMessage(), \"\\n\";\n"
"}"
msgstr ""
"<?php\n"
"$tarantool = new Tarantool('localhost', 3301);\n"
"\n"
"try {\n"
"    $tarantool->insert('examples', [99999, 'BB']);\n"
"    echo \"Insert succeeded\\n\";\n"
"} catch (Exception $e) {\n"
"    echo $e->getMessage(), \"\\n\";\n"
"}"

#: ../doc/book/connectors/__php.rst:44
msgid ""
"The example program only shows one request and does not show all that's "
"necessary for good practice. For that, please see `tarantool/tarantool-"
"php <https://github.com/tarantool/tarantool-php>`_ project at GitHub."
msgstr ""
"В этой программе мы привели пример использования лишь одного запроса. Для"
" полноценной работы с Tarantool'ом обратитесь к документации из `проекта "
"tarantool-php на GitHub <https://github.com/tarantool/tarantool-php>`_."

#: ../doc/book/connectors/__php.rst:49
msgid ""
"Besides, there is another community-driven `GitHub project "
"<https://github.com/tarantool-php>`_ which includes an `alternative "
"connector <https://github.com/tarantool-php/client>`_ written in pure "
"PHP, an `object mapper <https://github.com/tarantool-php/mapper>`_, a "
"`queue <https://github.com/tarantool-php/queue>`_ and other packages."
msgstr ""
"Кроме того, сообщество разработчиков поддерживает `проект на GitHub "
"<https://github.com/tarantool-php>`_, который включает в себя `вариант "
"коннектора <https://github.com/tarantool-php/client>`_, написанный на "
"чистом PHP, `модуль сопоставления объектов <https://github.com/tarantool-"
"php/mapper>`_, `администратор очередей <https://github.com/tarantool-"
"php/queue>`_ и другие пакеты."

#: ../doc/book/connectors/__python.rst:3
msgid "Python"
msgstr "Python"

#: ../doc/book/connectors/__python.rst:5
msgid ""
"`tarantool-python <http://github.com/tarantool/tarantool-python>`_ is the"
" official Python connector for Tarantool. It is not supplied as part of "
"the Tarantool repository and must be installed separately (see below for "
"details)."
msgstr ""
"`tarantool-python <https://github.com/tarantool/tarantool-python>`_ -- "
"это официальный Python-коннектор для Tarantool'а. Он не входит в "
"репозиторий Tarantool'а, его необходимо устанавливать отдельно (см. ниже "
"подробную информацию)."

#: ../doc/book/connectors/__python.rst:9
msgid ""
"Here is a complete Python program that inserts "
"``[99999,'Value','Value']`` into space ``examples`` via the high-level "
"Python API."
msgstr ""
"Далее приводится пример полноценной программы на языке Python, которая "
"осуществляет вставку ``[99999,'Value','Value']`` в спейс ``examples`` с "
"помощью высокоуровневого API для языка Python."

#: ../doc/book/connectors/__python.rst:12
msgid ""
"#!/usr/bin/python\n"
"from tarantool import Connection\n"
"\n"
"c = Connection(\"127.0.0.1\", 3301)\n"
"result = c.insert(\"examples\",(99999,'Value', 'Value'))\n"
"print result"
msgstr ""
"#!/usr/bin/python\n"
"from tarantool import Connection\n"
"\n"
"c = Connection(\"127.0.0.1\", 3301)\n"
"result = c.insert(\"examples\",(99999,'Value', 'Value'))\n"
"print result"

#: ../doc/book/connectors/__python.rst:21
msgid ""
"To prepare, paste the code into a file named :file:`example.py` and "
"install the ``tarantool-python`` connector with either :samp:`pip install"
" tarantool\\>0.4` to install in :file:`/usr` (requires **root** "
"privilege) or :samp:`pip install tarantool\\>0.4 --user` to install in "
":file:`~` i.e. user's default directory."
msgstr ""
"Чтобы запустить тестовую программу, сохраните ее исходный код в файл с "
"именем :file:`example.py` и установите коннектор ``tarantool-python``. "
"Для установки коннектора воспользуйтесь либо командой :samp:`pip install "
"tarantool\\>0.4` (для установки в директорию :file:`/usr`; вам "
"потребуются права уровня  **root**), либо командой :samp:`pip install "
"tarantool\\>0.4 --user` (для установки в директорию :file:`~`, т.е. в "
"используемую по умолчанию директорию текущего пользователя)."

#: ../doc/book/connectors/__python.rst:27
msgid ""
"Before trying to run, check that the server instance is :ref:`listening "
"<cfg_basic-listen>` at ``localhost:3301`` and that the space ``examples``"
" exists, as :ref:`described earlier <index-connector_setting>`. To run "
"the program, say :samp:`python example.py`. The program will connect to "
"the Tarantool server, will send the :ref:`INSERT<box_space-insert>` "
"request, and will not throw any exception if all went well. If the tuple "
"already exists, the program will throw ``tarantool.error.DatabaseError: "
"(3, \"Duplicate key exists in unique index 'primary' in space "
"'examples'\")``."
msgstr ""
"Перед запуском данной программы проверьте, что у Tarantool-сервера задан "
"порт ``localhost:3301`` для :ref:`прослушивания <cfg_basic-listen>` и в "
"базе создан спейс ``examples``), как :ref:`описано выше <index-"
"connector_setting>`. Чтобы запустить тестовую программу, выполните "
"команду :samp:`python example.py`. Программа установит соединение с "
"Tarantool-сервером, пошлет запрос :ref:`INSERT<box_space-insert>` и не "
"сгенерирует никакого исключения, если всё прошло хорошо. Если окажется, "
"что такой кортеж уже существует, то программа сгенерирует исключение "
"`tarantool.error.DatabaseError: (3, \"Duplicate key exists in unique "
"index 'primary' in space 'examples'\")`."

#: ../doc/book/connectors/__python.rst:35
msgid ""
"The example program only shows one request and does not show all that's "
"necessary for good practice. For that, please see `tarantool-python "
"<http://github.com/tarantool/tarantool-python>`_ project at GitHub. For "
"an example of using Python API with `queue managers for Tarantool "
"<https://github.com/tarantool/queue>`_, see `queue-python "
"<https://github.com/tarantool/queue-python>`_ project at GitHub."
msgstr ""
"В этой программе мы привели пример использования лишь одного запроса. Для"
" полноценной работы с Tarantool'ом обратитесь к документации из `проекта "
"tarantool-python на GitHub <http://github.com/tarantool/tarantool-"
"python>`_. А на странице `проекта queue-python на GitHub "
"<https://github.com/tarantool/queue-python>`_ вы сможете найти примеры "
"использования Python API для работы с `очередями сообщений в Tarantool'е "
"<https://github.com/tarantool/queue>`_."

#: ../doc/book/connectors/__python.rst:42
msgid "Also there are several community-driven Python connectors:"
msgstr ""
"Кроме того, сообщество разработчиков поддерживает другие "
"Python-коннекторы:"

#: ../doc/book/connectors/__python.rst:44
msgid "`asynctnt <https://github.com/igorcoding/asynctnt>`_ with asyncio support"
msgstr "`asynctnt <https://github.com/igorcoding/asynctnt>`_ с поддержкой asyncio"

#: ../doc/book/connectors/__python.rst:45
msgid ""
"`aiotarantool <https://github.com/shveenkov/aiotarantool>`_ also with "
"asyncio support"
msgstr ""
"`aiotarantool <https://github.com/shveenkov/aiotarantool>`_ также с "
"поддержкой asyncio"

#: ../doc/book/connectors/__python.rst:46
msgid ""
"`gtarantool <https://github.com/shveenkov/gtarantool>`_ with gevent "
"support **no active maintenance**"
msgstr ""
"`gtarantool <https://github.com/shveenkov/gtarantool>`_ с поддержкой "
"gevent **не обновляется**"

#: ../doc/book/connectors/__r.rst:3
msgid "R"
msgstr "R"

#: ../doc/book/connectors/__r.rst:5
msgid "See https://github.com/thekvs/tarantoolr."
msgstr "См. https://github.com/thekvs/tarantoolr."

#: ../doc/book/connectors/__results.rst:4
msgid "Interpreting function return values"
msgstr "Интерпретация возвращаемых значений"

#: ../doc/book/connectors/__results.rst:6
msgid ""
"For all connectors, calling a function via Tarantool causes a return in "
"the MsgPack format. If the function is called using the connector's API, "
"some conversions may occur. All scalar values are returned as tuples "
"(with a MsgPack type-identifier followed by a value); all non-scalar "
"values are returned as a group of tuples (with a MsgPack array-identifier"
" followed by the scalar values). If the function is called via the binary"
" protocol command layer -- \"eval\" -- rather than via the connector's "
"API, no conversions occur."
msgstr ""
"При работе с любым Tarantool-коннектором функции, вызванные с помощью "
"Tarantool'а, возвращают значения в формате MsgPack. Если функция была "
"вызвана через API коннектора, то формат возвращаемых значений будет "
"следующим: скалярные значения возвращаются в виде кортежей (сначала идет "
"идентификатор типа из формата MsgPack, а затем идет значение); все прочие"
"  (не скалярные) значения возвращаются в виде групп кортежей (сначала "
"идет  идентификатор массива в формате MsgPack, а затем идут скалярные "
"значения). Но если функция была вызвана в рамках бинарного протокола (с "
"помощью команды ``eval``), а не через API коннектора, то подобных "
"изменений формата возвращаемых значений не происходит."

#: ../doc/book/connectors/__results.rst:14
msgid ""
"In the following example, a Lua function will be created. Since it will "
"be accessed externally by a :ref:`'guest' user<box_space-user>`, a "
":ref:`grant <box_schema-user_grant>` of an execute privilege will be "
"necessary. The function returns an empty array, a scalar string, two "
"booleans, and a short integer. The values are the ones described in the "
"table :ref:`Common Types and MsgPack Encodings <msgpack-"
"common_types_and_msgpack_encodings>`."
msgstr ""
"Далее приводится пример создания Lua-функции. Поскольку эту функцию будет"
"  вызывать внешний пользователь :ref:`'guest' user<box_space-user>`, то "
"нужно настроить права на исполнение с помощью :ref:`grant <box_schema-"
"user_grant>`. Эта функция возвращает пустой массив, строку-скаляр, два "
"логических значения и короткое целое число. Значение будут теми же, что "
"описаны в разделе про MsgPack в таблице :ref:`Стандартные типы в "
"MsgPack-кодировке <msgpack-common_types_and_msgpack_encodings>`."

#: ../doc/book/connectors/__results.rst:21
msgid ""
"tarantool> box.cfg{listen=3301}\n"
"2016-03-03 18:45:52.802 [27381] main/101/interactive I> ready to accept "
"requests\n"
"---\n"
"...\n"
"tarantool> function f() return {},'a',false,true,127; end\n"
"---\n"
"...\n"
"tarantool> box.schema.func.create('f')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('guest','execute','function','f')\n"
"---\n"
"..."
msgstr ""
"tarantool> box.cfg{listen=3301}\n"
"2016-03-03 18:45:52.802 [27381] main/101/interactive I> ready to accept "
"requests\n"
"---\n"
"...\n"
"tarantool> function f() return {},'a',false,true,127; end\n"
"---\n"
"...\n"
"tarantool> box.schema.func.create('f')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('guest','execute','function','f')\n"
"---\n"
"..."

#: ../doc/book/connectors/__results.rst:37
msgid ""
"Here is a C program which calls the function. Although C is being used "
"for the example, the result would be precisely the same if the calling "
"program was written in Perl, PHP, Python, Go, or Java."
msgstr ""
"Далее идет пример программы на C, из который мы вызываем эту Lua-функцию."
"  Хотя в примере использован код на C, результат будет одинаковым, на "
"каком бы языке ни была написана вызываемая программа: Perl, PHP, Python, "
"Go или Java."

#: ../doc/book/connectors/__results.rst:41
#, python-format
msgid ""
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"void main() {\n"
"  struct tnt_stream *tnt = tnt_net(NULL);              /* SETUP */\n"
"  tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"   if (tnt_connect(tnt) < 0) {                         /* CONNECT */\n"
"       printf(\"Connection refused\\n\");\n"
"       exit(-1);\n"
"   }\n"
"   struct tnt_stream *arg; arg = tnt_object(NULL);     /* MAKE REQUEST */"
"\n"
"   tnt_object_add_array(arg, 0);\n"
"   struct tnt_request *req1 = tnt_request_call(NULL);  /* CALL function "
"f() */\n"
"   tnt_request_set_funcz(req1, \"f\");\n"
"   uint64_t sync1 = tnt_request_compile(tnt, req1);\n"
"   tnt_flush(tnt);                                     /* SEND REQUEST */"
"\n"
"   struct tnt_reply reply;  tnt_reply_init(&reply);    /* GET REPLY */\n"
"   tnt->read_reply(tnt, &reply);\n"
"   if (reply.code != 0) {\n"
"     printf(\"Call failed %lu.\\n\", reply.code);\n"
"     exit(-1);\n"
"   }\n"
"   const unsigned char *p= (unsigned char*)reply.data; /* PRINT REPLY */\n"
"   while (p < (unsigned char *) reply.data_end)\n"
"   {\n"
"     printf(\"%x \", *p);\n"
"     ++p;\n"
"   }\n"
"   printf(\"\\n\");\n"
"   tnt_close(tnt);                                     /* TEARDOWN */\n"
"   tnt_stream_free(arg);\n"
"   tnt_stream_free(tnt);\n"
"}"
msgstr ""
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"void main() {\n"
"  struct tnt_stream *tnt = tnt_net(NULL);              /* НАСТРОЙКА */\n"
"  tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"   if (tnt_connect(tnt) < 0) {                         /* СОЕДИНЕНИЕ */\n"
"       printf(\"Connection refused\\n\");\n"
"       exit(-1);\n"
"   }\n"
"   struct tnt_stream *arg; arg = tnt_object(NULL);     /* СОЗДАНИЕ "
"ЗАПРОСА */\n"
"   tnt_object_add_array(arg, 0);\n"
"   struct tnt_request *req1 = tnt_request_call(NULL);  /* ВЫЗОВ функции "
"f() */\n"
"   tnt_request_set_funcz(req1, \"f\");\n"
"   uint64_t sync1 = tnt_request_compile(tnt, req1);\n"
"   tnt_flush(tnt);                                     /* ОТПРАВКА "
"ЗАПРОСА */\n"
"   struct tnt_reply reply;  tnt_reply_init(&reply);    /* ПОЛУЧЕНИЕ "
"ОТВЕТА */\n"
"   tnt->read_reply(tnt, &reply);\n"
"   if (reply.code != 0) {\n"
"     printf(\"Call failed %lu.\\n\", reply.code);\n"
"     exit(-1);\n"
"   }\n"
"   const unsigned char *p= (unsigned char*)reply.data; /* ВЫВОД ОТВЕТА */"
"\n"
"   while (p < (unsigned char *) reply.data_end)\n"
"   {\n"
"     printf(\"%x \", *p);\n"
"     ++p;\n"
"   }\n"
"   printf(\"\\n\");\n"
"   tnt_close(tnt);                                     /* ЗАВЕРШЕНИЕ */\n"
"   tnt_stream_free(arg);\n"
"   tnt_stream_free(tnt);\n"
"}"

#: ../doc/book/connectors/__results.rst:79
msgid "When this program is executed, it will print:"
msgstr "По завершении программа выведет на экран следующие значения:"

#: ../doc/book/connectors/__results.rst:81
msgid "dd 0 0 0 5 90 91 a1 61 91 c2 91 c3 91 7f"
msgstr "dd 0 0 0 5 90 91 a1 61 91 c2 91 c3 91 7f"

#: ../doc/book/connectors/__results.rst:85
msgid ""
"The first five bytes -- ``dd 0 0 0 5`` -- are the MsgPack encoding for "
"\"32-bit array header with value 5\" (see `MsgPack specification "
"<http://github.com/msgpack/msgpack/blob/master/spec.md>`_). The rest are "
"as described in the table :ref:`Common Types and MsgPack Encodings "
"<msgpack-common_types_and_msgpack_encodings>`."
msgstr ""
"Первые пять байт -- ``dd 0 0 0 5`` -- это фрагмент данных в формате "
"MsgPack, означающий \"32-битный заголовок массива со значением 5\" (см. "
"`спецификацию на формат MsgPack "
"<http://github.com/msgpack/msgpack/blob/master/spec.md>`_). Остальные "
"значения описаны в таблице :ref:`Стандартные типы в MsgPack-кодировке "
"<msgpack-common_types_and_msgpack_encodings>`."

#: ../doc/book/connectors/index.rst:5
msgid "Connectors"
msgstr "Коннекторы"

#: ../doc/book/connectors/index.rst:7
msgid "This chapter documents APIs for various programming languages."
msgstr "В этой главе описаны API для различных языков программирования."

#: ../doc/book/connectors/index.rst:11
msgid "Protocol"
msgstr "Протокол"

#: ../doc/book/connectors/index.rst:13
msgid ""
"Tarantool's binary protocol was designed with a focus on asynchronous I/O"
" and easy integration with proxies. Each client request starts with a "
"variable-length binary header, containing request id, request type, "
"instance id, log sequence number, and so on."
msgstr ""
"Бинарный протокол для передачи данных в Tarantool'е был разработан с "
"учетом потребностей асинхронного ввода-вывода для облегчения интеграции с"
" прокси-серверами. Каждый клиентский запрос начинается с бинарного "
"заголовка переменной длины. В заголовке указывается идентификатор и тип "
"запроса, идентификатор экземпляра, номер записи в журнале и т.д."

#: ../doc/book/connectors/index.rst:18
msgid ""
"The mandatory length, present in request header simplifies client or "
"proxy I/O. A response to a request is sent to the client as soon as it is"
" ready. It always carries in its header the same type and id as in the "
"request. The id makes it possible to match a request to a response, even "
"if the latter arrived out of order."
msgstr ""
"Также в заголовке обязательно указывается длина запроса, что облегчает "
"обработку данных. Ответ на запрос посылается по мере готовности. В "
"заголовке ответа указывается тот же идентификатор и тип запроса, что и в "
"изначальном запросе. По идентификатору можно легко соотнести запрос с "
"ответом, даже если ответ был получен не в порядке отсылки запросов."

#: ../doc/book/connectors/index.rst:24
msgid ""
"Unless implementing a client driver, you needn't concern yourself with "
"the complications of the binary protocol. Language-specific drivers "
"provide a friendly way to store domain language data structures in "
"Tarantool. A complete description of the binary protocol is maintained in"
" annotated Backus-Naur form in the source tree: please see the page about"
" :ref:`Tarantool's binary protocol <box_protocol-iproto_protocol>`."
msgstr ""
"Вдаваться в тонкости реализации Tarantool-протокола нужно только при "
"разработке нового коннектора для Tarantool'а -- см. :ref:`полное описание"
" бинарного протокола в Tarantool'е <box_protocol-iproto_protocol>` в виде"
" аннотированных BNF-диаграмм (Backus-Naur Form). В остальных случаях "
"достаточно взять уже существующий коннектор для нужного вам языка "
"программирования. Такие коннекторы позволяют легко хранить структуры "
"данных из разных языков в формате Tarantool'а."

#: ../doc/book/connectors/index.rst:33
msgid "Packet example"
msgstr "Пример пакета данных"

#: ../doc/book/connectors/index.rst:35
msgid ""
"The Tarantool API exists so that a client program can send a request "
"packet to a server instance, and receive a response. Here is an example "
"of a what the client would send for ``box.space[513]:insert{'A', 'BB'}``."
" The BNF description of the components is on the page about "
":ref:`Tarantool's binary protocol <box_protocol-iproto_protocol>`."
msgstr ""
"С помощью API Tarantool'а клиентские программы могут отправлять пакеты с "
"запросами в адрес экземпляра и получать на них ответы. Вот пример для "
"запроса :code:`box.space[513]:insert{'A', 'BB'}`. Описания компонентов "
"запроса (в виде BNF-диаграмм) вы найдете на странице о :ref:`бинарном "
"протоколе в Tarantool'е <box_protocol-iproto_protocol>`."

#: ../doc/book/connectors/index.rst:51
msgid "Component"
msgstr "Компонент"

#: ../doc/book/connectors/index.rst:51
msgid "Byte #0"
msgstr "Байт #0"

#: ../doc/book/connectors/index.rst:51
msgid "Byte #1"
msgstr "Байт #1"

#: ../doc/book/connectors/index.rst:51
msgid "Byte #2"
msgstr "Байт #2"

#: ../doc/book/connectors/index.rst:51
msgid "Byte #3"
msgstr "Байт #3"

#: ../doc/book/connectors/index.rst:53
msgid "code for insert"
msgstr "код для вставки"

#: ../doc/book/connectors/index.rst:53 ../doc/book/connectors/index.rst:57
msgid "02"
msgstr "02"

#: ../doc/book/connectors/index.rst:55
msgid "rest of header"
msgstr "остаток заголовка"

#: ../doc/book/connectors/index.rst:55
msgid "..."
msgstr "..."

#: ../doc/book/connectors/index.rst:57
msgid "2-digit number: space id"
msgstr "число из 2 цифр: ID спейса"

#: ../doc/book/connectors/index.rst:57
msgid "cd"
msgstr "cd"

#: ../doc/book/connectors/index.rst:57
msgid "01"
msgstr "01"

#: ../doc/book/connectors/index.rst:59
msgid "code for tuple"
msgstr "код для кортежа"

#: ../doc/book/connectors/index.rst:59
msgid "21"
msgstr "21"

#: ../doc/book/connectors/index.rst:61
msgid "1-digit number: field count = 2"
msgstr "число из 1 цифры: количество полей = 2"

#: ../doc/book/connectors/index.rst:61
msgid "92"
msgstr "92"

#: ../doc/book/connectors/index.rst:63
msgid "1-character string: field[1]"
msgstr "строка из 1 символа: поле[1]"

#: ../doc/book/connectors/index.rst:63
msgid "a1"
msgstr "a1"

#: ../doc/book/connectors/index.rst:63
msgid "41"
msgstr "41"

#: ../doc/book/connectors/index.rst:65
msgid "2-character string: field[2]"
msgstr "строка из 2 символов: поле[2]"

#: ../doc/book/connectors/index.rst:65
msgid "a2"
msgstr "a2"

#: ../doc/book/connectors/index.rst:65
msgid "42"
msgstr "42"

#: ../doc/book/connectors/index.rst:68
msgid ""
"Now, you could send that packet to the Tarantool instance, and interpret "
"the response (the page about :ref:`Tarantool's binary protocol "
"<box_protocol-iproto_protocol>` has a description of the packet format "
"for responses as well as requests). But it would be easier, and less "
"error-prone, if you could invoke a routine that formats the packet "
"according to typed parameters. Something like ``response = "
"tarantool_routine(\"insert\", 513, \"A\", \"B\");``. And that is why APIs"
" exist for drivers for Perl, Python, PHP, and so on."
msgstr ""
"Теперь получившийся пакет можно послать в адрес экземпляра Tarantool'а и "
"затем расшифровать ответ (описания формата пакета ответов и вопросов вы "
"найдете на той же странице о :ref:`бинарном протоколе в Tarantool'е "
"<box_protocol-iproto_protocol>`). Но более простым и верным способом "
"будет вызвать процедуру, которая сформирует готовый пакет с заданными "
"параметрами. Что-то вроде ``response = tarantool_routine(\"insert\", 513,"
" \"A\", \"B\");``. Для этого и существуют API для драйверов для Perl, "
"Python, PHP и т.д."

#: ../doc/book/connectors/index.rst:81
msgid "Setting up the server for connector examples"
msgstr "Настройка окружения для примеров работы с коннекторами"

#: ../doc/book/connectors/index.rst:83
msgid ""
"This chapter has examples that show how to connect to a Tarantool "
"instance via the Perl, PHP, Python, node.js, and C connectors. The "
"examples contain hard code that will work if and only if the following "
"conditions are met:"
msgstr ""
"В этой главе приводятся примеры того, как можно установить соединение с "
"Tarantool-сервером с помощью коннекторов для языков Perl, PHP, Python, "
"node.js и C. Обратите внимание, что в примерах указаны фиксированные "
"значения, поэтому для корректной работы всех примеров нужно соблюсти "
"следующие условия:"

#: ../doc/book/connectors/index.rst:87
msgid ""
"the Tarantool instance (tarantool) is running on localhost (127.0.0.1) "
"and is listening on port 3301 (``box.cfg.listen = '3301'``),"
msgstr ""
"экземпляр (Tarantool) запущен на локальной машине (``localhost = "
"127.0.0.1``),  а прослушивание для него настроено на порту 3301 "
"(``box.cfg.listen = '3301'``),"

#: ../doc/book/connectors/index.rst:90
msgid ""
"space ``examples`` has id = 999 (``box.space.examples.id = 999``) and has"
" a primary-key index for a numeric field "
"(``box.space[999].index[0].parts[1].type = \"unsigned\"``),"
msgstr ""
"в базе есть спейс``examples`` с идентификатором 999 "
"(``box.space.examples.id = 999``), и у него есть первичный индекс, "
"построенный по ключу числового типа "
"(``box.space[999].index[0].parts[1].type = \"unsigned\"``),"

#: ../doc/book/connectors/index.rst:94
msgid "user 'guest' has privileges for reading and writing."
msgstr "для пользователя 'guest' настроены права на чтение и запись."

#: ../doc/book/connectors/index.rst:96
msgid ""
"It is easy to meet all the conditions by starting the instance and "
"executing this script:"
msgstr ""
"Можно легко соблюсти все условия, запустив экземпляр и выполнив следующий"
" скрипт:"

#: ../doc/book/connectors/index.rst:99
msgid ""
"box.cfg{listen=3301}\n"
"box.schema.space.create('examples',{id=999})\n"
"box.space.examples:create_index('primary', {type = 'hash', parts = {1, "
"'unsigned'}})\n"
"box.schema.user.grant('guest','read,write','space','examples')\n"
"box.schema.user.grant('guest','read','space','_space')"
msgstr ""
"box.cfg{listen=3301}\n"
"box.schema.space.create('examples',{id=999})\n"
"box.space.examples:create_index('primary', {type = 'hash', parts = {1, "
"'unsigned'}})\n"
"box.schema.user.grant('guest','read,write','space','examples')\n"
"box.schema.user.grant('guest','read','space','_space')"

#: ../doc/book/faq.rst:5
msgid "FAQ"
msgstr "Вопросы и ответы"

#: ../doc/book/faq.rst
msgid "Q"
msgstr "В"

#: ../doc/book/faq.rst:9
msgid "Why Tarantool?"
msgstr "В чем особенности Tarantool'а?"

#: ../doc/book/faq.rst
msgid "A"
msgstr "О"

#: ../doc/book/faq.rst:10
msgid ""
"Tarantool is the latest generation of a family of in-memory data servers "
"developed for web applications. It is the result of practical experience "
"and trials within Mail.Ru since development began in 2008."
msgstr ""
"Tarantool -- представитель нового поколения семейства серверов для in-"
"memory базы данных, разработанный для веб-приложений.  Он создан в "
"компании Mail.Ru на основе практического опыта, полученного методом проб "
"и ошибок с начала разработки в 2008 году."

#: ../doc/book/faq.rst:14
msgid "Why Lua?"
msgstr "Почему Lua?"

#: ../doc/book/faq.rst:15
msgid ""
"Lua is a lightweight, fast, extensible multi-paradigm language. Lua also "
"happens to be very easy to embed. Lua coroutines relate very closely to "
"Tarantool fibers, and Lua architecture works well with Tarantool "
"internals. Lua acts well as a stored program language for Tarantool, "
"although connecting with other languages is also easy."
msgstr ""
"Lua -- это легкий, быстрый и расширяемый язык, позволяющий использовать "
"различные парадигмы программирования. Lua также легко встраивается в "
"различные приложения. Сопрограммы (coroutines) в Lua близко соотносятся с"
" файберами (fibers) в Tarantool'е, а вся Lua-архитектура гладко ложится "
"на его внутреннюю реализацию. Lua -- это первый язык, на котором можно "
"писать хранимые процедуры для Tarantool'а. В будущем список "
"поддерживаемых языков планируется расширить."

#: ../doc/book/faq.rst:21
msgid "What's the key advantage of Tarantool?"
msgstr "В чем ключевое преимущество Tarantool'а?"

#: ../doc/book/faq.rst
msgid ""
"Tarantool provides a rich database feature set (HASH, TREE, RTREE, BITSET"
" indexes, secondary indexes, composite indexes, transactions, triggers, "
"asynchronous replication) in a flexible environment of a Lua interpreter."
msgstr ""
"Tarantool обеспечивает богатый набор функций базы данных (HASH-индексы, "
"TREE-индексы, RTREE-индексы, BITSET-индексы, вторичные индексы, составные"
" индексы, транзакции, триггеры. асинхронная репликация) в гибкой среде "
"Lua-интерпретатора."

#: ../doc/book/faq.rst
msgid ""
"These two properties make it possible to be a fast, atomic and reliable "
"in-memory data server which handles non-trivial application-specific "
"logic. The advantage over traditional SQL servers is in performance: low-"
"overhead, lock-free architecture means Tarantool can serve an order of "
"magnitude more requests per second, on comparable hardware. The advantage"
" over NoSQL alternatives is in flexibility: Lua allows flexible "
"processing of data stored in a compact, denormalized format."
msgstr ""
"Благодаря этим характеристикам, он представляет собой быстрый и надежный "
"in-memory сервер с легким доступом к базе данных, который обрабатывает "
"нетривиальную проблемно-ориентированную логику. Преимущество по сравнению"
" с традиционными SQL-серверами -- в производительности: архитектура без "
"блокировок с малой перегрузкой означает, что Tarantool может обслуживать "
"на порядок больше запросов в секунду на аналогичном оборудовании. "
"Преимущество NoSQL-аналогов -- в гибкости: Lua допускает гибкую обработку"
" данных, хранимых в компактном денормализированном формате."

#: ../doc/book/faq.rst:35
msgid "Who is developing Tarantool?"
msgstr "Кто разрабатывает Tarantool?"

#: ../doc/book/faq.rst:36
msgid ""
"There is an engineering team employed by Mail.Ru -- check out our commit "
"logs on `github.com/tarantool <http://github.com/tarantool/>`_. The "
"development is fully open. Most of the connectors' authors, and the "
"maintainers for different distributions, come from the wider community."
msgstr ""
"Во-первых, этим занимается команда разработки в Mail.Ru -- см. историю "
"коммитов на `github.com/tarantool <http://github.com/tarantool/>`_. Вся "
"разработка ведется открытым образом. Кроме того, активную роль играют "
"члены сообщества разработчиков Tarantool'а. Их силами было создано "
"большинство коннекторов и ведутся доработки под разные дистрибутивы."

#: ../doc/book/faq.rst:41
msgid "Are there problems associated with being an in-memory server?"
msgstr ""
"Возникают ли проблемы из-за того, что Tarantool является in-memory "
"решением?"

#: ../doc/book/faq.rst:42
msgid ""
"The principal storage engine (memtx) is designed for RAM plus persistent "
"storage. It is immune to data loss because there is a write-ahead log. "
"Its memory-allocation and compression techniques ensure there is no "
"waste. And if Tarantool runs out of memory, then it will stop accepting "
"updates until more memory is available, but will continue to handle read "
"and delete requests without difficulty. However, for databases which are "
"much larger than the available RAM space, Tarantool has a second storage "
"engine (vinyl) which is only limited by the available disk space."
msgstr ""
"Основной движок баз данных в Tarantool'е работает с оперативной памятью, "
"но при этом он гарантирует сохранность данных благодаря механизму WAL "
"(write ahead log), т.е. журналу упреждающей записи. Также в Tarantool'е "
"используются технологии сжатия и распределения данных, которые позволяют "
"использовать все виды памяти наиболее эффективно. Если Tarantool "
"сталкивается с нехваткой оперативной памяти, то он приостанавливает прием"
" запросов на изменение данных до тех пор, пока не появится свободная "
"память, но при этом с успехом продолжает обработку запросов на чтение и "
"удаление данных. А для больших баз, где объем данных значительно "
"превосходит имеющийся объем оперативной памяти, у Tarantool'а есть второй"
" движок, чьи возможности ограничены лишь размером жесткого диска."

#: ../doc/book/faq.rst:51
msgid "Can I store (large) BLOBs in Tarantool?"
msgstr "Можно ли хранить (большие) объекты BLOB в Tarantool'е?"

#: ../doc/book/faq.rst:52
msgid ""
"Starting with Tarantool 1.7, there is no \"hard\" limit for the maximal "
"tuple size. Tarantool, however, is designed for high-velocity workload "
"with a lot of small chunks. For example, when you change an existing "
"tuple, Tarantool creates a new version of the tuple in memory. Thus, an "
"optimal tuple size is within kilobytes."
msgstr ""
"Начиная с Tarantool 1.7, нет \"жесткого\" ограничения на максимальный "
"размер кортежа. Однако Tarantool предназначен для работы с множеством "
"фрагментов на высокой скорости. Например, при изменении существующего "
"кортежа Tarantool создает новую версию кортежа в памяти. Таким образом, "
"оптимальный размер кортежа -- несколько килобайтов."

#: ../doc/book/faq.rst:59
msgid "I delete data from vinyl, but disk usage stays the same. What gives?"
msgstr ""
"Я удаляю данные из vinyl'а, но использование диска не изменяется. В чем "
"дело?"

#: ../doc/book/faq.rst:60
msgid ""
"Data you write to vinyl is persisted in append-only run files. These "
"files are immutable, and to perform a delete, a deletion marker "
"(tombstone) is written to a newer run file instead. On compaction, new "
"and old run files are merged, and a new run file is produced. "
"Independently, the checkpoint manager keeps track of all run files "
"involved in a checkpoint, and deletes obsolete files once they are no "
"longer needed."
msgstr ""
"Данные, записываемые в vinyl, сохраняются в исполняемых файлах, "
"обновление которых происходит только путем присоединения новых записей. "
"Такие файлы нельзя изменить, а для удаления маркер удаления (удаленная "
"запись) записывается в новый исполняемый файл. Для уплотнения данных "
"новый и старый исполняемые файлы объединяются, и создается новый "
"исполняемый файл. Независимо от этого, менеджер контрольных точек следит "
"за всеми исполняемыми файлами в контрольной точке и удаляет устаревшие "
"файлы, как только в них отпадает необходимость."

#: ../doc/book/getting_started/index.rst:5
msgid "Getting started"
msgstr "Руководство для начинающих"

#: ../doc/book/getting_started/index.rst:7
msgid ""
"In this chapter, we explain how to install Tarantool, how to start it, "
"and how to create a simple database."
msgstr ""
"В этой главе объясняется, как установить и запустить Tarantool, а также "
"как создать простую базу данных."

#: ../doc/book/getting_started/using_binary.rst:5
msgid "Using a binary package"
msgstr "Использование бинарного пакета"

#: ../doc/book/getting_started/using_binary.rst:7
msgid ""
"For production purposes, we recommend `official binary packages "
"<http://tarantool.org/download.html>`_. You can choose from two Tarantool"
" versions: ``1.10`` (stable) or ``2.2`` (beta). An automatic build system"
" creates, tests and publishes packages for every push into a "
"corresponding branch (``1.10`` or ``2.2``) at `Tarantool's GitHub "
"repository <https://github.com/tarantool/tarantool>`_."
msgstr ""
"Для промышленной разработки мы рекомендуем использовать `официальные "
"бинарные пакеты <http://tarantool.org/download.html>`_. Можно выбрать "
"одну из двух версий Tarantool’а: ``1.10`` (стабильная) или ``2.2`` "
"(бета). Автоматическая система сборки создает, тестирует и публикует "
"пакеты после  каждого коммита в соответствующую ветку (``1.10`` или "
"``2.2``) `репозитория Tarantool’а на GitHub "
"<https://github.com/tarantool/tarantool>`_."

#: ../doc/book/getting_started/using_binary.rst:14
msgid ""
"To download and install the package that’s appropriate for your OS, start"
" a shell (terminal) and enter the command-line instructions provided for "
"your OS at Tarantool's `download page "
"<http://tarantool.org/download.html>`_."
msgstr ""
"Чтобы скачать и установить бинарный пакет для вашей операционной системы,"
" откройте командную строку и введите инструкции, которые даны для вашей "
"операционной системы на `странице для скачивания "
"<http://tarantool.org/download.html>`_."

#: ../doc/book/getting_started/using_binary.rst:20
msgid "Starting Tarantool"
msgstr "Запуск экземпляра Tarantool’а"

#: ../doc/book/getting_started/using_binary.rst:22
msgid "To start a Tarantool instance, say this:"
msgstr "Для запуска экземпляра Tarantool’а выполните эту команду:"

#: ../doc/book/getting_started/using_binary.rst:24
msgid ""
"$ # if you downloaded a binary with apt-get or yum, say this:\n"
"$ /usr/bin/tarantool\n"
"$ # if you downloaded and untarred a binary tarball to ~/tarantool, say "
"this:\n"
"$ ~/tarantool/bin/tarantool"
msgstr ""
"$ # если вы скачали бинарный пакет с помощью apt-get или yum, введите:\n"
"$ /usr/bin/tarantool\n"
"$ # если вы скачали бинарный пакет в формате TAR\n"
"$ # и разархивировали его в директорию ~/tarantool, введите:\n"
"$ ~/tarantool/bin/tarantool"

#: ../doc/book/getting_started/using_binary.rst:31
msgid "Tarantool starts in the interactive mode and displays a prompt:"
msgstr ""
"Tarantool запускается в интерактивном режиме и показывает приглашение "
"командной строки:"

#: ../doc/book/getting_started/using_binary.rst:33
msgid "tarantool>"
msgstr "tarantool>"

#: ../doc/book/getting_started/using_binary.rst:37
#: ../doc/book/getting_started/using_docker.rst:84
msgid "Now you can enter requests on the command line."
msgstr "Теперь вы можете вводить запросы в командной строке."

#: ../doc/book/getting_started/using_binary.rst:41
#: ../doc/book/getting_started/using_docker.rst:88
msgid ""
"On production machines, Tarantool's interactive mode is for system "
"administration only. But we use it for most examples in this manual, "
"because the interactive mode is convenient for learning."
msgstr ""
"На боевых серверах интерактивный режим Tarantool’а предназначен только "
"для системных администраторов. Мы же используем его в большинстве "
"примеров в данном руководстве, потому что интерактивный режим хорошо "
"подходит для обучения."

#: ../doc/book/getting_started/using_binary.rst:47
#: ../doc/book/getting_started/using_docker.rst:94
msgid "Creating a database"
msgstr "Создание базы данных"

#: ../doc/book/getting_started/using_binary.rst:49
msgid "Here is how to create a simple test database after installation."
msgstr ""
"Далее объясняется, как создать простую тестовую базу данных после "
"установки Tarantool'а."

#: ../doc/book/getting_started/using_binary.rst:51
msgid ""
"To let Tarantool store data in a separate place, create a new directory "
"dedicated for tests:"
msgstr ""
"Чтобы Tarantool хранил данные в определенном месте, создайте "
"предназначенную специально для тестов директорию:"

#: ../doc/book/getting_started/using_binary.rst:54
msgid ""
"$ mkdir ~/tarantool_sandbox\n"
"$ cd ~/tarantool_sandbox"
msgstr ""
"$ mkdir ~/tarantool_sandbox\n"
"$ cd ~/tarantool_sandbox"

#: ../doc/book/getting_started/using_binary.rst:59
msgid "You can delete the directory when the tests are over."
msgstr "Ее можно удалить после окончания тестирования."

#: ../doc/book/getting_started/using_binary.rst:61
msgid "Check if the default port the database instance will listen to is vacant."
msgstr ""
"Проверьте доступность порта, используемого по умолчанию для прослушивания"
" на экземпляре базы данных."

#: ../doc/book/getting_started/using_binary.rst:63
msgid ""
"Depending on the release, during installation Tarantool may start a "
"demonstrative global ``example.lua`` instance that listens to the "
"``3301`` port by default. The ``example.lua`` file showcases basic "
"configuration and can be found in the "
"``/etc/tarantool/instances.enabled`` or "
"``/etc/tarantool/instances.available`` directories."
msgstr ""
"В зависимости от версии, Tarantool может во время установки запустить "
"экземпляр ``example.lua``, который настроен на прослушивание по порту "
"``3301`` по умолчанию. В файле ``example.lua`` показана базовая "
"конфигурация; его можно найти в директории "
"``/etc/tarantool/instances.enabled`` или "
"``/etc/tarantool/instances.available``."

#: ../doc/book/getting_started/using_binary.rst:69
msgid ""
"However, we encourage you to perform the instance startup manually, so "
"you can learn."
msgstr ""
"Тем не менее, мы предлагаем провести установку самостоятельно с целью "
"обучения."

#: ../doc/book/getting_started/using_binary.rst:72
msgid "Make sure the default port is vacant:"
msgstr "Убедитесь, что свободен порт, используемый по умолчанию:"

#: ../doc/book/getting_started/using_binary.rst:74
msgid "To check if the demonstrative instance is running, say:"
msgstr ""
"Чтобы проверить статус работы демонстрационного экземпляра, выполните "
"команду:"

#: ../doc/book/getting_started/using_binary.rst:76
msgid ""
"$ lsof -i :3301\n"
"COMMAND    PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME\n"
"tarantool 6851 root   12u  IPv4  40827      0t0  TCP *:3301 (LISTEN)"
msgstr ""
"$ lsof -i :3301\n"
"COMMAND    PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME\n"
"tarantool 6851 root   12u  IPv4  40827      0t0  TCP *:3301 (LISTEN)"

#: ../doc/book/getting_started/using_binary.rst:82
msgid "If it does, kill the corresponding process. In this example:"
msgstr "Если он запущен, отключите соответствующий процесс. В данном примере:"

#: ../doc/book/getting_started/using_binary.rst:84
msgid "$ kill 6851"
msgstr "$ kill 6851"

#: ../doc/book/getting_started/using_binary.rst:88
msgid ""
"To start Tarantool's database module and make the instance accept TCP "
"requests on port ``3301``, say:"
msgstr ""
"Чтобы запустить модуль Tarantool’а для работы с базой данных и сделать "
"так, чтобы запущенный экземпляр принимал TCP-запросы на порту ``3301``, "
"выполните эту команду:"

#: ../doc/book/getting_started/using_binary.rst:95
msgid "Create the first :ref:`space <index-box_space>` (named ``tester``):"
msgstr "Создайте первый :ref:`спейс <index-box_space>` (с именем ``tester``):"

#: ../doc/book/getting_started/using_binary.rst:97
msgid "tarantool> s = box.schema.space.create('tester')"
msgstr "tarantool> s = box.schema.space.create('tester')"

#: ../doc/book/getting_started/using_binary.rst:101
#: ../doc/book/getting_started/using_docker.rst:104
msgid "Format the created space by specifying field names and types:"
msgstr "Форматируйте созданный спейс, указав имена и типы полей:"

#: ../doc/book/getting_started/using_binary.rst:103
msgid ""
"tarantool> s:format({\n"
"         > {name = 'id', type = 'unsigned'},\n"
"         > {name = 'band_name', type = 'string'},\n"
"         > {name = 'year', type = 'unsigned'}\n"
"         > })"
msgstr ""
"tarantool> s:format({\n"
"         > {name = 'id', type = 'unsigned'},\n"
"         > {name = 'band_name', type = 'string'},\n"
"         > {name = 'year', type = 'unsigned'}\n"
"         > })"

#: ../doc/book/getting_started/using_binary.rst:111
#: ../doc/book/getting_started/using_docker.rst:114
msgid "Create the first :ref:`index <index-box_index>` (named ``primary``):"
msgstr "Создайте первый :ref:`индекс <index-box_index>` (с именем ``primary``):"

#: ../doc/book/getting_started/using_binary.rst:113
msgid ""
"tarantool> s:create_index('primary', {\n"
"         > type = 'hash',\n"
"         > parts = {'id'}\n"
"         > })"
msgstr ""
"tarantool> s:create_index('primary', {\n"
"         > type = 'hash',\n"
"         > parts = {'id'}\n"
"         > })"

#: ../doc/book/getting_started/using_binary.rst:120
#: ../doc/book/getting_started/using_docker.rst:123
msgid "This is a primary index based on the ``id`` field of each tuple."
msgstr "Это первичный индекс по полю ``id`` в каждом кортеже."

#: ../doc/book/getting_started/using_binary.rst:122
#: ../doc/book/getting_started/using_docker.rst:125
msgid ""
"Insert three :ref:`tuples <index-box_tuple>` (our name for records) into "
"the space:"
msgstr ""
"Вставьте в созданный спейс три :ref:`кортежа <index-box_tuple>` (наш "
"термин для записей):"

#: ../doc/book/getting_started/using_binary.rst:125
msgid ""
"tarantool> s:insert{1, 'Roxette', 1986}\n"
"tarantool> s:insert{2, 'Scorpions', 2015}\n"
"tarantool> s:insert{3, 'Ace of Base', 1993}"
msgstr ""
"tarantool> s:insert{1, 'Roxette', 1986}\n"
"tarantool> s:insert{2, 'Scorpions', 2015}\n"
"tarantool> s:insert{3, 'Ace of Base', 1993}"

#: ../doc/book/getting_started/using_binary.rst:131
#: ../doc/book/getting_started/using_docker.rst:134
msgid "To select a tuple using the ``primary`` index, say:"
msgstr "Для выборки кортежей по первичному индексу ``primary`` выполните команду:"

#: ../doc/book/getting_started/using_binary.rst:133
msgid "tarantool> s:select{3}"
msgstr "tarantool> s:select{3}"

#: ../doc/book/getting_started/using_binary.rst:137
#: ../doc/book/getting_started/using_docker.rst:140
msgid "The terminal screen now looks like this:"
msgstr "Теперь вывод в окне терминала выглядит следующим образом:"

#: ../doc/book/getting_started/using_binary.rst:139
msgid ""
"tarantool> s = box.schema.space.create('tester')\n"
"---\n"
"...\n"
"tarantool> s:format({\n"
"         > {name = 'id', type = 'unsigned'},\n"
"         > {name = 'band_name', type = 'string'},\n"
"         > {name = 'year', type = 'unsigned'}\n"
"         > })\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {\n"
"         > type = 'hash',\n"
"         > parts = {'id'}\n"
"         > })\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: unsigned\n"
"    is_nullable: false\n"
"    fieldno: 1\n"
"  id: 0\n"
"  space_id: 512\n"
"  name: primary\n"
"  type: HASH\n"
"...\n"
"tarantool> s:insert{1, 'Roxette', 1986}\n"
"---\n"
"- [1, 'Roxette', 1986]\n"
"...\n"
"tarantool> s:insert{2, 'Scorpions', 2015}\n"
"---\n"
"- [2, 'Scorpions', 2015]\n"
"...\n"
"tarantool> s:insert{3, 'Ace of Base', 1993}\n"
"---\n"
"- [3, 'Ace of Base', 1993]\n"
"...\n"
"tarantool> s:select{3}\n"
"---\n"
"- - [3, 'Ace of Base', 1993]\n"
"..."
msgstr ""
"tarantool> s = box.schema.space.create('tester')\n"
"---\n"
"...\n"
"tarantool> s:format({\n"
"         > {name = 'id', type = 'unsigned'},\n"
"         > {name = 'band_name', type = 'string'},\n"
"         > {name = 'year', type = 'unsigned'}\n"
"         > })\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {\n"
"         > type = 'hash',\n"
"         > parts = {'id'}\n"
"         > })\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: unsigned\n"
"    is_nullable: false\n"
"    fieldno: 1\n"
"  id: 0\n"
"  space_id: 512\n"
"  name: primary\n"
"  type: HASH\n"
"...\n"
"tarantool> s:insert{1, 'Roxette', 1986}\n"
"---\n"
"- [1, 'Roxette', 1986]\n"
"...\n"
"tarantool> s:insert{2, 'Scorpions', 2015}\n"
"---\n"
"- [2, 'Scorpions', 2015]\n"
"...\n"
"tarantool> s:insert{3, 'Ace of Base', 1993}\n"
"---\n"
"- [3, 'Ace of Base', 1993]\n"
"...\n"
"tarantool> s:select{3}\n"
"---\n"
"- - [3, 'Ace of Base', 1993]\n"
"..."

#: ../doc/book/getting_started/using_binary.rst:183
#: ../doc/book/getting_started/using_docker.rst:186
msgid "To add a secondary index based on the ``band_name`` field, say:"
msgstr ""
"Для добавления вторичного индекса по полю ``band_name`` используйте эту "
"команду:"

#: ../doc/book/getting_started/using_binary.rst:185
msgid ""
"tarantool> s:create_index('secondary', {\n"
"         > type = 'hash',\n"
"         > parts = {'band_name'}\n"
"         > })"
msgstr ""
"tarantool> s:create_index('secondary', {\n"
"         > type = 'hash',\n"
"         > parts = {'band_name'}\n"
"         > })"

#: ../doc/book/getting_started/using_binary.rst:192
#: ../doc/book/getting_started/using_docker.rst:195
msgid "To select tuples using the ``secondary`` index, say:"
msgstr ""
"Для выборки кортежей по вторичному индексу ``secondary`` выполните "
"команду:"

#: ../doc/book/getting_started/using_binary.rst:194
msgid ""
"tarantool> s.index.secondary:select{'Scorpions'}\n"
"---\n"
"- - [2, 'Scorpions', 2015]\n"
"..."
msgstr ""
"tarantool> s.index.secondary:select{'Scorpions'}\n"
"---\n"
"- - [2, 'Scorpions', 2015]\n"
"..."

#: ../doc/book/getting_started/using_binary.rst:201
msgid "Now, to prepare for the example in the next section, try this:"
msgstr ""
"Теперь, чтобы подготовиться к примеру в следующем разделе, попробуйте "
"следующее:"

#: ../doc/book/getting_started/using_binary.rst:203
msgid ""
"tarantool> box.schema.user.grant('guest', 'read,write,execute', "
"'universe')"
msgstr ""
"tarantool> box.schema.user.grant('guest', 'read,write,execute', "
"'universe')"

#: ../doc/book/getting_started/using_binary.rst:212
msgid "Connecting remotely"
msgstr "Установка удаленного подключения"

#: ../doc/book/getting_started/using_binary.rst:214
msgid ""
"In the request ``box.cfg{listen = 3301}`` that we made earlier, the "
"``listen`` value can be any form of a :ref:`URI <index-uri>` (uniform "
"resource identifier). In this case, it’s just a local port: port "
"``3301``. You can send requests to the listen URI via:"
msgstr ""
"В запросе ``box.cfg{listen = 3301}``, который мы отправили ранее, "
"параметр ``listen`` может принимать в качестве значения :ref:`URI <index-"
"uri>` (унифицированный идентификатор ресурса) любой формы. В нашем случае"
" это просто локальный порт ``3301``. Вы можете отправлять запросы на "
"указанный  URI, используя:"

#: ../doc/book/getting_started/using_binary.rst:219
msgid "``telnet``,"
msgstr "``telnet``,"

#: ../doc/book/getting_started/using_binary.rst:220
msgid "a :ref:`connector <index-box_connectors>`,"
msgstr ":ref:`коннектор <index-box_connectors>`,"

#: ../doc/book/getting_started/using_binary.rst:221
msgid ""
"another instance of Tarantool (using the :ref:`console <console-module>` "
"module), or"
msgstr ""
"другой экземпляр Tarantool'а (с помощью модуля :ref:`console <console-"
"module>`), либо"

#: ../doc/book/getting_started/using_binary.rst:222
msgid ":ref:`tarantoolctl <tarantoolctl>` utility."
msgstr "утилиту :ref:`tarantoolctl <tarantoolctl>`."

#: ../doc/book/getting_started/using_binary.rst:224
msgid "Let’s try (4)."
msgstr "Давайте попробуем вариант с ``tarantoolctl``."

#: ../doc/book/getting_started/using_binary.rst:226
msgid ""
"Switch to another terminal. On Linux, for example, this means starting "
"another instance of a Bash shell. You can switch to any working directory"
" in the new terminal, not necessarily to ``~/tarantool_sandbox``."
msgstr ""
"Переключитесь на другой терминал. Например, в Linux-системе для этого "
"нужно запустить еще один экземпляр Bash. В новом терминале можно сменить "
"текущую рабочую директорию на любую другую, необязательно использовать "
"``~/tarantool_sandbox``."

#: ../doc/book/getting_started/using_binary.rst:230
msgid "Start the ``tarantoolctl`` utility:"
msgstr "Запустите утилиту ``tarantoolctl``:"

#: ../doc/book/getting_started/using_binary.rst:232
msgid "$ tarantoolctl connect '3301'"
msgstr "$ tarantoolctl connect '3301'"

#: ../doc/book/getting_started/using_binary.rst:236
msgid ""
"This means \"use ``tarantoolctl connect`` to connect to the Tarantool "
"instance that’s listening on ``localhost:3301``\"."
msgstr ""
"Данная команда означает «использовать утилиту ``tarantoolctl`` для "
"подключения к Tarantool-серверу, который слушает по адресу "
"``localhost:3301``»."

#: ../doc/book/getting_started/using_binary.rst:239
msgid "Try this request:"
msgstr "Введите следующий запрос:"

#: ../doc/book/getting_started/using_binary.rst:241
msgid "localhost:3301> box.space.tester:select{2}"
msgstr "localhost:3301> box.space.tester:select{2}"

#: ../doc/book/getting_started/using_binary.rst:245
msgid ""
"This means \"send a request to that Tarantool instance, and display the "
"result\". The result in this case is one of the tuples that was inserted "
"earlier. Your terminal screen should now look like this:"
msgstr ""
"Это означает \"послать запрос тому Tarantool-серверу и вывести результат "
"на экран\". Результатом в данном случае будет один из кортежей, что вы "
"вставляли ранее. В окне терминала теперь должно отображаться примерно "
"следующее:"

#: ../doc/book/getting_started/using_binary.rst:249
msgid ""
"$ tarantoolctl connect 3301\n"
"/usr/local/bin/tarantoolctl: connected to localhost:3301\n"
"localhost:3301> box.space.tester:select{2}\n"
"---\n"
"- - [2, 'Scorpions', 2015]\n"
"..."
msgstr ""
"$ tarantoolctl connect 3301\n"
"/usr/local/bin/tarantoolctl: connected to localhost:3301\n"
"localhost:3301> box.space.tester:select{2}\n"
"---\n"
"- - [2, 'Scorpions', 2015]\n"
"..."

#: ../doc/book/getting_started/using_binary.rst:258
msgid ""
"You can repeat ``box.space...:insert{}`` and ``box.space...:select{}`` "
"indefinitely, on either Tarantool instance."
msgstr ""
"Вы можете посылать запросы ``box.space...:insert{}`` и "
"``box.space...:select{}`` неограниченное количество раз на любом из двух "
"запущенных экземпляров Tarantool’а."

#: ../doc/book/getting_started/using_binary.rst:261
msgid "When the testing is over:"
msgstr "Закончив тестирование, выполните следующие шаги:"

#: ../doc/book/getting_started/using_binary.rst:263
msgid "To drop the space: ``s:drop()``"
msgstr "Для удаления спейса: ``s:drop()``"

#: ../doc/book/getting_started/using_binary.rst:264
msgid "To stop ``tarantoolctl``: Ctrl+C or Ctrl+D"
msgstr "Для остановки ``tarantoolctl``:  ctrl+C или ctrl+D"

#: ../doc/book/getting_started/using_binary.rst:265
msgid ""
"To stop Tarantool (an alternative): the standard Lua function `os.exit() "
"<http://www.lua.org/manual/5.1/manual.html#pdf-os.exit>`_"
msgstr ""
"Для остановки Tarantool’а (альтернативный вариант): стандартная "
"Lua-функция `os.exit() <http://www.lua.org/manual/5.1/manual.html#pdf- "
"os.exit>`_"

#: ../doc/book/getting_started/using_binary.rst:267
msgid "To stop Tarantool (from another terminal): ``sudo pkill -f tarantool``"
msgstr ""
"Для остановки Tarantool’а (из другого терминала): ``sudo pkill -f "
"tarantool``"

#: ../doc/book/getting_started/using_binary.rst:268
msgid "To destroy the test: ``rm -r ~/tarantool_sandbox``"
msgstr "Для удаления директории-песочницы: ``rm -r ~/tarantool_sandbox``"

#: ../doc/book/getting_started/using_docker.rst:5
msgid "Using a Docker image"
msgstr "Использование Docker-образа"

#: ../doc/book/getting_started/using_docker.rst:7
msgid ""
"For trial and test purposes, we recommend using `official Tarantool "
"images for Docker <https://github.com/tarantool/docker>`_. An official "
"image contains a particular Tarantool version and all popular external "
"modules for Tarantool. Everything is already installed and configured in "
"Linux. These images are the easiest way to install and use Tarantool."
msgstr ""
"Для практики и тестирования мы рекомендуем использовать `официальные "
"образы Tarantool’а для Docker <https://github.com/tarantool/docker>`_. "
"Официальный образ содержит определенную версию Tarantool’а и все "
"популярные внешние модули для Tarantool’а. Все необходимое уже "
"установлено и настроено на платформе Linux. Данные образы - это самый "
"простой способ установить и запустить Tarantool."

#: ../doc/book/getting_started/using_docker.rst:16
msgid ""
"If you're new to Docker, we recommend going over `this tutorial "
"<https://docs.docker.com/engine/getstarted/step_one/>`_ before proceeding"
" with this chapter."
msgstr ""
"Если вы никогда раньше не работали с Docker, рекомендуем сперва прочитать"
" `эту обучающую статью "
"<https://docs.docker.com/engine/getstarted/step_one/>`_."

#: ../doc/book/getting_started/using_docker.rst:24
msgid "Launching a container"
msgstr "Запуск контейнера"

#: ../doc/book/getting_started/using_docker.rst:26
msgid ""
"If you don't have Docker installed, please follow the official "
"`installation guide "
"<https://docs.docker.com/engine/getstarted/step_one/#/step-1-get-"
"docker>`_ for your OS."
msgstr ""
"Если Docker не установлен на вашей машине, следуйте официальным "
"`инструкциям по установке "
"<https://docs.docker.com/engine/getstarted/step_one/#/step-1-get- "
"docker>`_ для вашей ОС."

#: ../doc/book/getting_started/using_docker.rst:30
msgid ""
"To start a fully functional Tarantool instance, run a container with "
"minimal options:"
msgstr ""
"Для использования полнофункционального экземпляра Tarantool’а запустите "
"контейнер с минимальными настройками:"

#: ../doc/book/getting_started/using_docker.rst:33
#, fuzzy
msgid ""
"$ docker run \\\n"
"  --name mytarantool \\\n"
"  -d -p 3301:3301 \\\n"
"  -v /data/dir/on/host:/var/lib/tarantool \\\n"
"  tarantool/tarantool:2"
msgstr ""
"$ docker run \\\n"
"  --name mytarantool \\\n"
"  -d -p 3301:3301 \\\n"
"  -v /data/dir/on/host:/var/lib/tarantool \\\n"
"  tarantool/tarantool:1"

#: ../doc/book/getting_started/using_docker.rst:41
#, fuzzy
msgid ""
"This command runs a new container named ``mytarantool``. Docker starts it"
" from an official image named ``tarantool/tarantool:2``, with Tarantool "
"version ``2.2`` and all external modules already installed."
msgstr ""
"Эта команда запускает новый контейнер с именем 'mytarantool'. Docker "
"запускает его из официального образа 'tarantool/tarantool:1' с "
"предустановленным Tarantool’ом ``1.10`` и всеми внешними модулями."

#: ../doc/book/getting_started/using_docker.rst:45
msgid ""
"Tarantool will be accepting incoming connections on ``localhost:3301``. "
"You may start using it as a key-value storage right away."
msgstr ""
"Tarantool будет принимать входящие подключения по адресу "
"``localhost:3301``. Можно сразу начать его использовать как key-value "
"хранилище."

#: ../doc/book/getting_started/using_docker.rst:48
msgid ""
"Tarantool :ref:`persists data <index-box_persistence>` inside the "
"container. To make your test data available after you stop the container,"
" this command also mounts the host's directory ``/data/dir/on/host`` (you"
" need to specify here an absolute path to an existing local directory) in"
" the container's directory ``/var/lib/tarantool`` (by convention, "
"Tarantool in a container uses this directory to persist data). So, all "
"changes made in the mounted directory on the container's side are applied"
" to the host's disk."
msgstr ""
"Tarantool :ref:`сохраняет данные <index-box_persistence>` внутри "
"контейнера. Чтобы ваше тестовые данные остались доступны после остановки "
"контейнера, эта команда также монтирует директорию ``/data/dir/on/host`` "
"(здесь необходимо указать абсолютный путь до существующей локальной "
"директории), расположенную на машине, в директорию ``/var/lib/tarantool``"
"  (Tarantool традиционно использует эту директорию в контейнере для "
"сохранения данных), расположенную в контейнере. Таким образом все "
"изменения в смонтированной директории, внесенные на стороне контейнера, "
"также отражаются в расположенной на пользовательском диске директории."

#: ../doc/book/getting_started/using_docker.rst:57
msgid ""
"Tarantool's database module in the container is already :ref:`configured "
"<box_introspection-box_cfg>` and started. You needn't do it manually, "
"unless you use Tarantool as an :ref:`application server <app_server>` and"
" run it with an application."
msgstr ""
"Модуль Tarantool’а для работы с базой данных уже :ref:`настроен "
"<box_introspection-box_cfg>` и запущен в контейнере. Ручная настройка не "
"требуется, если только вы не используете Tarantool как :ref:`сервер "
"приложений <app_server>` и не запускаете его вместе с приложением."

#: ../doc/book/getting_started/using_docker.rst:64
msgid "Attaching to Tarantool"
msgstr "Подключение к экземпляру Tarantool’а"

#: ../doc/book/getting_started/using_docker.rst:66
msgid "To attach to Tarantool that runs inside the container, say:"
msgstr ""
"Для подключения к запущенному в контейнере экземпляру Tarantool’а, "
"выполните эту команду:"

#: ../doc/book/getting_started/using_docker.rst:68
msgid "$ docker exec -i -t mytarantool console"
msgstr "$ docker exec -i -t mytarantool console"

#: ../doc/book/getting_started/using_docker.rst:72
msgid "This command:"
msgstr "Эта команда:"

#: ../doc/book/getting_started/using_docker.rst:74
msgid ""
"Instructs Tarantool to open an interactive console port for incoming "
"connections."
msgstr ""
"Требует от Tarantool’а открыть порт с интерактивной консолью для входящих"
"  подключений."

#: ../doc/book/getting_started/using_docker.rst:75
msgid ""
"Attaches to the Tarantool server inside the container under ``admin`` "
"user via a standard Unix socket."
msgstr ""
"Подключается через стандартный Unix-сокет к Tarantool-серверу, "
"запущенному внутри контейнера, из-под пользователя ``admin``."

#: ../doc/book/getting_started/using_docker.rst:78
msgid "Tarantool displays a prompt:"
msgstr "Tarantool показывает приглашение командной строки:"

#: ../doc/book/getting_started/using_docker.rst:80
msgid "tarantool.sock>"
msgstr "tarantool.sock>"

#: ../doc/book/getting_started/using_docker.rst:96
msgid "While you're attached to the console, let's create a simple test database."
msgstr "Подключившись к консоли, давайте создадим простую тестовую базу данных."

#: ../doc/book/getting_started/using_docker.rst:98
msgid "First, create the first :ref:`space <index-box_space>` (named ``tester``):"
msgstr ""
"Сначала создайте первый :ref:`спейс <index-box_space>` (с именем "
"``tester``):"

#: ../doc/book/getting_started/using_docker.rst:100
msgid "tarantool.sock> s = box.schema.space.create('tester')"
msgstr "tarantool.sock> s = box.schema.space.create('tester')"

#: ../doc/book/getting_started/using_docker.rst:106
msgid ""
"tarantool.sock> s:format({\n"
"              > {name = 'id', type = 'unsigned'},\n"
"              > {name = 'band_name', type = 'string'},\n"
"              > {name = 'year', type = 'unsigned'}\n"
"              > })"
msgstr ""
"tarantool.sock> s:format({\n"
"              > {name = 'id', type = 'unsigned'},\n"
"              > {name = 'band_name', type = 'string'},\n"
"              > {name = 'year', type = 'unsigned'}\n"
"              > })"

#: ../doc/book/getting_started/using_docker.rst:116
msgid ""
"tarantool.sock> s:create_index('primary', {\n"
"              > type = 'hash',\n"
"              > parts = {'id'}\n"
"              > })"
msgstr ""
"tarantool.sock> s:create_index('primary', {\n"
"              > type = 'hash',\n"
"              > parts = {'id'}\n"
"              > })"

#: ../doc/book/getting_started/using_docker.rst:128
msgid ""
"tarantool.sock> s:insert{1, 'Roxette', 1986}\n"
"tarantool.sock> s:insert{2, 'Scorpions', 2015}\n"
"tarantool.sock> s:insert{3, 'Ace of Base', 1993}"
msgstr ""
"tarantool.sock> s:insert{1, 'Roxette', 1986}\n"
"tarantool.sock> s:insert{2, 'Scorpions', 2015}\n"
"tarantool.sock> s:insert{3, 'Ace of Base', 1993}"

#: ../doc/book/getting_started/using_docker.rst:136
msgid "tarantool.sock> s:select{3}"
msgstr "tarantool.sock> s:select{3}"

#: ../doc/book/getting_started/using_docker.rst:142
msgid ""
"tarantool.sock> s = box.schema.space.create('tester')\n"
"---\n"
"...\n"
"tarantool.sock> s:format({\n"
"              > {name = 'id', type = 'unsigned'},\n"
"              > {name = 'band_name', type = 'string'},\n"
"              > {name = 'year', type = 'unsigned'}\n"
"              > })\n"
"---\n"
"...\n"
"tarantool.sock> s:create_index('primary', {\n"
"              > type = 'hash',\n"
"              > parts = {'id'}\n"
"              > })\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: unsigned\n"
"    is_nullable: false\n"
"    fieldno: 1\n"
"  id: 0\n"
"  space_id: 512\n"
"  name: primary\n"
"  type: HASH\n"
"...\n"
"tarantool.sock> s:insert{1, 'Roxette', 1986}\n"
"---\n"
"- [1, 'Roxette', 1986]\n"
"...\n"
"tarantool.sock> s:insert{2, 'Scorpions', 2015}\n"
"---\n"
"- [2, 'Scorpions', 2015]\n"
"...\n"
"tarantool.sock> s:insert{3, 'Ace of Base', 1993}\n"
"---\n"
"- [3, 'Ace of Base', 1993]\n"
"...\n"
"tarantool.sock> s:select{3}\n"
"---\n"
"- - [3, 'Ace of Base', 1993]\n"
"..."
msgstr ""
"tarantool.sock> s = box.schema.space.create('tester')\n"
"---\n"
"...\n"
"tarantool.sock> s:format({\n"
"              > {name = 'id', type = 'unsigned'},\n"
"              > {name = 'band_name', type = 'string'},\n"
"              > {name = 'year', type = 'unsigned'}\n"
"              > })\n"
"---\n"
"...\n"
"tarantool.sock> s:create_index('primary', {\n"
"              > type = 'hash',\n"
"              > parts = {'id'}\n"
"              > })\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: unsigned\n"
"    is_nullable: false\n"
"    fieldno: 1\n"
"  id: 0\n"
"  space_id: 512\n"
"  name: primary\n"
"  type: HASH\n"
"...\n"
"tarantool.sock> s:insert{1, 'Roxette', 1986}\n"
"---\n"
"- [1, 'Roxette', 1986]\n"
"...\n"
"tarantool.sock> s:insert{2, 'Scorpions', 2015}\n"
"---\n"
"- [2, 'Scorpions', 2015]\n"
"...\n"
"tarantool.sock> s:insert{3, 'Ace of Base', 1993}\n"
"---\n"
"- [3, 'Ace of Base', 1993]\n"
"...\n"
"tarantool.sock> s:select{3}\n"
"---\n"
"- - [3, 'Ace of Base', 1993]\n"
"..."

#: ../doc/book/getting_started/using_docker.rst:188
msgid ""
"tarantool.sock> s:create_index('secondary', {\n"
"              > type = 'hash',\n"
"              > parts = {'band_name'}\n"
"              > })"
msgstr ""
"tarantool.sock> s:create_index('secondary', {\n"
"              > type = 'hash',\n"
"              > parts = {'band_name'}\n"
"              > })"

#: ../doc/book/getting_started/using_docker.rst:197
msgid ""
"tarantool.sock> s.index.secondary:select{'Scorpions'}\n"
"---\n"
"- - [2, 'Scorpions', 2015]\n"
"..."
msgstr ""
"tarantool.sock> s.index.secondary:select{'Scorpions'}\n"
"---\n"
"- - [2, 'Scorpions', 2015]\n"
"..."

#: ../doc/book/getting_started/using_docker.rst:206
msgid "Stopping a container"
msgstr "Остановка контейнера"

#: ../doc/book/getting_started/using_docker.rst:208
msgid "When the testing is over, stop the container politely:"
msgstr ""
"После завершения тестирования для корректной остановки контейнера "
"выполните эту команду:"

#: ../doc/book/getting_started/using_docker.rst:210
msgid "$ docker stop mytarantool"
msgstr "$ docker stop mytarantool"

#: ../doc/book/getting_started/using_docker.rst:214
msgid ""
"This was a temporary container, and its disk/memory data were flushed "
"when you stopped it. But since you mounted a data directory from the host"
" in the container, Tarantool's data files were persisted to the host's "
"disk. Now if you start a new container and mount that data directory in "
"it, Tarantool will recover all data from disk and continue working with "
"the persisted data."
msgstr ""
"Это был временный контейнер, поэтому после остановки содержимое его "
"диска/памяти обнулилось. Но так как вы монтировали локальную директорию в"
"  контейнер, все данные Tarantool’а сохранились на диске вашей машины. "
"Если вы запустите новый контейнер и смонтируете в него ту же директорию с"
"  данными, Tarantool восстановит все данные с диска и продолжит с ними "
"работать."

#: ../doc/book/index.rst:5
msgid "User's Guide"
msgstr "Руководство пользователя"

#: ../doc/book/intro.rst:3
msgid "Preface"
msgstr "Предисловие"

#: ../doc/book/intro.rst:5
msgid ""
"Welcome to Tarantool! This is the User's Guide. We recommend reading it "
"first, and consulting :ref:`Reference <reference>` materials for more "
"detail afterwards, if needed."
msgstr ""
"Добро пожаловать в мир Tarantool! Сейчас вы читаете \"Руководство "
"пользователя\". Мы советуем начинать именно с него, а затем переходить к "
":ref:`\"Справочникам\" <reference>`, если вам понадобятся более подробные"
"  сведения."

#: ../doc/book/intro.rst:11
msgid "How to read the documentation"
msgstr "Как пользоваться документацией"

#: ../doc/book/intro.rst:13
msgid ""
"To get started, you can install and launch Tarantool using :ref:`a Docker"
" container <getting_started-using_docker>`, :ref:`a binary package "
"<getting_started-using_binary>`, or the online Tarantool server at "
"http://try.tarantool.org. Either way, as the first tryout, you can follow"
" the introductory exercises from :ref:`Chapter 2 \"Getting started\" "
"<getting_started>`. If you want more hands-on experience, proceed to "
":ref:`Tutorials <tutorials>` after you are through with Chapter 2."
msgstr ""
"Для начала можно установить и запустить Tarantool, используя "
":ref:`Docker-контейнер <getting_started-using_docker>`, :ref:`бинарный "
"пакет <getting_started-using_binary>` или онлайн-сервер Tarantool'а "
"http://try.tarantool.org. В любом случае для пробы можно сделать вводные "
"упражнения из :ref:`главы 2 \"Руководство для начинающих\" "
"<getting_started>`. Если хотите получить практический опыт, переходите к "
":ref:`Практическим заданиям <tutorials>` после работы с главой 2."

#: ../doc/book/intro.rst:22
msgid ""
":ref:`Chapter 3 \"Database\" <database-chapter>` is about using Tarantool"
" as a NoSQL DBMS, whereas :ref:`Chapter 4 \"Application server\" "
"<app_server>` is about using Tarantool as an application server."
msgstr ""
"В :ref:`главе 3 \"Функциональность СУБД\" <database-chapter>` рассказано "
"о возможностях Tarantool'а как NoSQL СУБД, а в :ref:`главе 4 \"Сервер "
"приложений\" <app_server>` -- о возможностях Tarantool'а как сервера "
"приложений Lua."

#: ../doc/book/intro.rst:26
msgid ""
":ref:`Chapter 5 \"Server administration\" <admin>` and :ref:`Chapter 6 "
"\"Replication\" <replication>` are primarily for administrators."
msgstr ""
":ref:`Глава 5 \"Администрирование серверной части\" <admin>` и "
":ref:`Глава 6 \"Репликация\" <replication>` предназначены в первую "
"очередь для системных администраторов."

#: ../doc/book/intro.rst:29
msgid ""
":ref:`Chapter 7 \"Connectors\" <index-box_connectors>` is strictly for "
"users who are connecting from a different language such as C or Perl or "
"Python — other users will find no immediate need for this chapter."
msgstr ""
":ref:`Глава 7 \"Коннекторы\" <index-box_connectors>` актуальна только для"
" тех пользователей, которые хотят устанавливать соединение с Tarantool'ом"
" с помощью программ на других языках программирования (например C, Perl "
"или Python) -- для прочих пользователей эта глава неактуальна."

#: ../doc/book/intro.rst:33
msgid ""
":ref:`Chapter 8 \"FAQ\" <faq>` gives answers to some frequently asked "
"questions about Tarantool."
msgstr ""
":ref:`Глава 8 \"Вопросы и ответы\" <faq>` содержит ответы на некоторые "
"часто задаваемые вопросы о Tarantool'е."

#: ../doc/book/intro.rst:36
msgid ""
"For experienced users, there are also :ref:`Reference <reference>` "
"materials, a :ref:`Contributor's Guide <contrib_guide>` and an extensive "
"set of comments in the source code."
msgstr ""
"Опытным же пользователям будут полезны :ref:`\"Справочники\" "
"<reference>`, :ref:`\"Руководство участника проекта\" <contrib_guide>` и "
"комментарии в исходном коде."

#: ../doc/book/intro.rst:42
msgid "Getting in touch with the Tarantool community"
msgstr "Как связаться с сообществом разработчиков Tarantool'а"

#: ../doc/book/intro.rst:44
msgid ""
"Please report bugs or make feature requests at "
"http://github.com/tarantool/tarantool/issues."
msgstr ""
"Оставить сообщение о найденных дефектах или сделать запрос на новые "
"функции можно тут: http://github.com/tarantool/tarantool/issues"

#: ../doc/book/intro.rst:46
msgid ""
"You can contact developers directly in `telegram "
"<http://telegram.me/tarantool>`_ or in a Tarantool discussion group "
"(`English <https://groups.google.com/forum/#!forum/tarantool>`_ or "
"`Russian <https://googlegroups.com/group/tarantool-ru>`_)."
msgstr ""
"Пообщаться напрямую с командой разработки Tarantool'а можно в `telegram "
"<http://telegram.me/tarantool>`_ или на форумах (`англоязычном "
"<https://groups.google.com/forum/#!forum/tarantool>`_ или `русскоязычном "
"<https://googlegroups.com/group/tarantool-ru>`_)."

#: ../doc/book/intro.rst:53
msgid "Conventions used in this manual"
msgstr "Условные обозначения, используемые в руководстве"

#: ../doc/book/intro.rst:55
msgid "Square brackets [ and ] enclose optional syntax."
msgstr "В квадратные скобки [ и ] включается синтаксис необязательных элементов."

#: ../doc/book/intro.rst:57
msgid "Two dots in a row .. mean the preceding tokens may be repeated."
msgstr "Две точки подряд .. означают, что предыдущие токены могут повторяться."

#: ../doc/book/intro.rst:59
msgid ""
"A vertical bar | means the preceding and following tokens are mutually "
"exclusive alternatives."
msgstr ""
"Вертикальная черта | означает, что предыдущий и последующий токены "
"представляют собой взаимоисключающие альтернативы."

#: ../doc/book/replication/1_1.rst:1
msgid ""
"$ # Terminal 1\n"
"$ mkdir -p ~/tarantool_test_node_1\n"
"$ cd ~/tarantool_test_node_1\n"
"$ rm -R ./*\n"
"$ ~/tarantool/src/tarantool\n"
"$ ~/tarantool/src/tarantool: version 1.7.0-1724-g033ed69\n"
"type 'help' for interactive help\n"
"tarantool> box.cfg{listen = 3301}\n"
"<... ...>\n"
"tarantool> box.schema.user.create('replicator', {password = 'password'})\n"
"<...> I> creating ./00000000000000000000.xlog.inprogress'\n"
"---\n"
"...\n"
"tarantool> "
"box.schema.user.grant('replicator','execute','role','replication')\n"
"---\n"
"...\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"..."
msgstr ""
"$ # Terminal 1\n"
"$ mkdir -p ~/tarantool_test_node_1\n"
"$ cd ~/tarantool_test_node_1\n"
"$ rm -R ./*\n"
"$ ~/tarantool/src/tarantool\n"
"$ ~/tarantool/src/tarantool: version 1.7.0-1724-g033ed69\n"
"type 'help' for interactive help\n"
"tarantool> box.cfg{listen = 3301}\n"
"<... ...>\n"
"tarantool> box.schema.user.create('replicator', {password = 'password'})\n"
"<...> I> creating ./00000000000000000000.xlog.inprogress'\n"
"---\n"
"...\n"
"tarantool> "
"box.schema.user.grant('replicator','execute','role','replication')\n"
"---\n"
"...\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"..."

#: ../doc/book/replication/1_2.rst:1
msgid "$"
msgstr "$"

#: ../doc/book/replication/2_1.rst:1
msgid ""
"$ # Terminal 1\n"
"$ mkdir -p ~/tarantool_test_node_1\n"
"<... ...>\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"...\n"
"tarantool>\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovery start\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovering from "
"`./00000000000000000000.snap'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> snapshot sent\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recover from "
"`./00000000000000000000.xlog'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main recovery.cc:211 W> file\n"
"      `./00000000000000000000.xlog` wasn't correctly closed\n"
"<...> [11031] relay/127.0.0.1:58734/102/main I> recover from "
"`./00000000000000000000.xlog'"
msgstr ""
"$ # Terminal 1\n"
"$ mkdir -p ~/tarantool_test_node_1\n"
"<... ...>\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"...\n"
"tarantool>\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovery start\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovering from "
"`./00000000000000000000.snap'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> snapshot sent\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recover from "
"`./00000000000000000000.xlog'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main recovery.cc:211 W> file\n"
"      `./00000000000000000000.xlog` wasn't correctly closed\n"
"<...> [11031] relay/127.0.0.1:58734/102/main I> recover from "
"`./00000000000000000000.xlog'"

#: ../doc/book/replication/2_2.rst:1 ../doc/book/replication/3_2.rst:1
msgid ""
"$ # Terminal 2\n"
"$ mkdir -p ~/tarantool_test_node_2\n"
"$ cd ~/tarantool_test_node_2\n"
"$ rm -R ./*\n"
"$ ~/tarantool/src/tarantool\n"
"/home/username/tarantool/src/tarantool: version 1.7.0-1724-g033ed69\n"
"type 'help' for interactive help\n"
"tarantool> box.cfg{\n"
"         >   listen = 3302,\n"
"         >   replication = 'replicator:password@localhost:3301'\n"
"         > }\n"
"<...>\n"
"<...> [11243] main/101/interactive I> mapping 1073741824 bytes for tuple "
"arena...\n"
"<...> [11243] main/101/interactive C> starting replication from "
"localhost:3301\n"
"<...> [11243] main/102/applier/localhost:3301 I> connected to 1.7.0 at "
"127.0.0.1:3301\n"
"<...> [11243] main/102/applier/localhost:3301 I> authenticated\n"
"<...> [11243] main/102/applier/localhost:3301 I> downloading a snapshot "
"from 127.0.0.1:3301\n"
"<...> [11243] main/102/applier/localhost:3301 I> done\n"
"<...> [11243] snapshot/101/main I> creating "
"`./00000000000000000000.snap.inprogress'\n"
"<...> [11243] snapshot/101/main I> saving snapshot "
"`./00000000000000000000.snap.inprogress'\n"
"<...> [11243] snapshot/101/main I> done\n"
"<...> [11243] iproto I> binary: started\n"
"<...> [11243] iproto I> binary: bound to 0.0.0.0:3302\n"
"<...> [11243] wal/101/main I> creating "
"`./00000000000000000000.xlog.inprogress'\n"
"<...> [11243] main/101/interactive I> ready to accept requests\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"  - [2, '236230b8-af3e-406b-b709-15a60b44c20c']\n"
"..."
msgstr ""
"$ # Terminal 2\n"
"$ mkdir -p ~/tarantool_test_node_2\n"
"$ cd ~/tarantool_test_node_2\n"
"$ rm -R ./*\n"
"$ ~/tarantool/src/tarantool\n"
"/home/username/tarantool/src/tarantool: version 1.7.0-1724-g033ed69\n"
"type 'help' for interactive help\n"
"tarantool> box.cfg{\n"
"         >   listen = 3302,\n"
"         >   replication = 'replicator:password@localhost:3301'\n"
"         > }\n"
"<...>\n"
"<...> [11243] main/101/interactive I> mapping 1073741824 bytes for tuple "
"arena...\n"
"<...> [11243] main/101/interactive C> starting replication from "
"localhost:3301\n"
"<...> [11243] main/102/applier/localhost:3301 I> connected to 1.7.0 at "
"127.0.0.1:3301\n"
"<...> [11243] main/102/applier/localhost:3301 I> authenticated\n"
"<...> [11243] main/102/applier/localhost:3301 I> downloading a snapshot "
"from 127.0.0.1:3301\n"
"<...> [11243] main/102/applier/localhost:3301 I> done\n"
"<...> [11243] snapshot/101/main I> creating "
"`./00000000000000000000.snap.inprogress'\n"
"<...> [11243] snapshot/101/main I> saving snapshot "
"`./00000000000000000000.snap.inprogress'\n"
"<...> [11243] snapshot/101/main I> done\n"
"<...> [11243] iproto I> binary: started\n"
"<...> [11243] iproto I> binary: bound to 0.0.0.0:3302\n"
"<...> [11243] wal/101/main I> creating "
"`./00000000000000000000.xlog.inprogress'\n"
"<...> [11243] main/101/interactive I> ready to accept requests\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"  - [2, '236230b8-af3e-406b-b709-15a60b44c20c']\n"
"..."

#: ../doc/book/replication/3_1.rst:1 ../doc/book/replication/4_1.rst:1
msgid ""
"<... ...>\n"
"tarantool>\n"
"tarantool>\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovery start\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovering from "
"`./00000000000000000000.snap'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> snapshot sent\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recover from "
"`./00000000000000000000.xlog'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main recovery.cc:211 W> file\n"
"      `./00000000000000000000.xlog` wasn't correctly closed\n"
"<...> [11031] relay/127.0.0.1:58734/102/main I> recover from "
"`./00000000000000000000.xlog'\n"
"tarantool> s = box.schema.space.create('tester')\n"
"---\n"
"...\n"
"tarantool> i = s:create_index('primary', {})\n"
"---\n"
"...\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}\n"
"---\n"
"- [1, 'Tuple inserted on Terminal #1']\n"
"..."
msgstr ""
"<... ...>\n"
"tarantool>\n"
"tarantool>\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovery start\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovering from "
"`./00000000000000000000.snap'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> snapshot sent\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recover from "
"`./00000000000000000000.xlog'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main recovery.cc:211 W> file\n"
"      `./00000000000000000000.xlog` wasn't correctly closed\n"
"<...> [11031] relay/127.0.0.1:58734/102/main I> recover from "
"`./00000000000000000000.xlog'\n"
"tarantool> s = box.schema.space.create('tester')\n"
"---\n"
"...\n"
"tarantool> i = s:create_index('primary', {})\n"
"---\n"
"...\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}\n"
"---\n"
"- [1, 'Tuple inserted on Terminal #1']\n"
"..."

#: ../doc/book/replication/4_2.rst:1
msgid ""
"<... ...>\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"  - [2, '236230b8-af3e-406b-b709-15a60b44c20c']\n"
"...\n"
"tarantool> s = box.space.tester\n"
"---\n"
"...\n"
"tarantool> s:select({1}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"..."
msgstr ""
"<... ...>\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"  - [2, '236230b8-af3e-406b-b709-15a60b44c20c']\n"
"...\n"
"tarantool> s = box.space.tester\n"
"---\n"
"...\n"
"tarantool> s:select({1}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"..."

#: ../doc/book/replication/5_1.rst:1 ../doc/book/replication/6_1.rst:1
msgid ""
"<... ...>\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}\n"
"---\n"
"- [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> os.exit()\n"
"$ ls -l ~/tarantool_test_node_1\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:12 00000000000000000000.snap\n"
"-rw-rw-r-- 1   634 May  5 11:45 00000000000000000000.xlog\n"
"$ ls -l ~/tarantool_test_node_2/\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:20 00000000000000000000.snap\n"
"-rw-rw-r-- 1   704 May  5 11:38 00000000000000000000.xlog\n"
"$"
msgstr ""
"<... ...>\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}\n"
"---\n"
"- [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> os.exit()\n"
"$ ls -l ~/tarantool_test_node_1\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:12 00000000000000000000.snap\n"
"-rw-rw-r-- 1   634 May  5 11:45 00000000000000000000.xlog\n"
"$ ls -l ~/tarantool_test_node_2/\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:20 00000000000000000000.snap\n"
"-rw-rw-r-- 1   704 May  5 11:38 00000000000000000000.xlog\n"
"$"

#: ../doc/book/replication/5_2.rst:1
msgid ""
"<... ...>\n"
"tarantool> s:select({1}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
"<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken "
"pipe\n"
"<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 second"
msgstr ""
"<... ...>\n"
"tarantool> s:select({1}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
"<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken "
"pipe\n"
"<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 second"

#: ../doc/book/replication/6_2.rst:1
msgid ""
"<... ...>\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [11243] main/105/applier/localhost:3301 I> can't read row\n"
"<...> [11243] main/105/applier/localhost:3301 coio.cc:352 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 6, aka 127.0.0.1:58734, peer of 127.0.0.1:3301: Broken "
"pipe\n"
"<...> [11243] main/105/applier/localhost:3301 I> will retry every 1 "
"second\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool> box.space.tester:insert{3, 'Another'}\n"
"---\n"
"- [3, 'Another']\n"
"..."
msgstr ""
"<... ...>\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [11243] main/105/applier/localhost:3301 I> can't read row\n"
"<...> [11243] main/105/applier/localhost:3301 coio.cc:352 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 6, aka 127.0.0.1:58734, peer of 127.0.0.1:3301: Broken "
"pipe\n"
"<...> [11243] main/105/applier/localhost:3301 I> will retry every 1 "
"second\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool> box.space.tester:insert{3, 'Another'}\n"
"---\n"
"- [3, 'Another']\n"
"..."

#: ../doc/book/replication/7_1.rst:1
msgid ""
"<... ...>\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}\n"
"---\n"
"- [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> os.exit()\n"
"$ ls -l ~/tarantool_test_node_1\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:12 00000000000000000000.snap\n"
"-rw-rw-r-- 1   634 May  5 11:45 00000000000000000000.xlog\n"
"$ ls -l ~/tarantool_test_node_2/\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:20 00000000000000000000.snap\n"
"-rw-rw-r-- 1   704 May  5 11:38 00000000000000000000.xlog\n"
"$ ~/tarantool/src/tarantool\n"
"<...>\n"
"tarantool> box.cfg{listen = 3301}\n"
"<...> [22612] main/101/interactive I> ready to accept requests\n"
"<... ...>\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"..."
msgstr ""
"<... ...>\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}\n"
"---\n"
"- [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> os.exit()\n"
"$ ls -l ~/tarantool_test_node_1\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:12 00000000000000000000.snap\n"
"-rw-rw-r-- 1   634 May  5 11:45 00000000000000000000.xlog\n"
"$ ls -l ~/tarantool_test_node_2/\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:20 00000000000000000000.snap\n"
"-rw-rw-r-- 1   704 May  5 11:38 00000000000000000000.xlog\n"
"$ ~/tarantool/src/tarantool\n"
"<...>\n"
"tarantool> box.cfg{listen = 3301}\n"
"<...> [22612] main/101/interactive I> ready to accept requests\n"
"<... ...>\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"..."

#: ../doc/book/replication/7_2.rst:1
msgid ""
"<... ...>\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
"<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken "
"pipe\n"
"<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 "
"second\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool> box.space.tester:insert{3, 'Another'}\n"
"---\n"
"- [3, 'Another']\n"
"...\n"
"<...> [11243] main/105/applier/localhost:3301 I> connected to 1.7.0 at "
"127.0.0.1:3301\n"
"<...> [11243] main/105/applier/localhost:3301 I> authenticated"
msgstr ""
"<... ...>\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
"<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken "
"pipe\n"
"<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 "
"second\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool> box.space.tester:insert{3, 'Another'}\n"
"---\n"
"- [3, 'Another']\n"
"...\n"
"<...> [11243] main/105/applier/localhost:3301 I> connected to 1.7.0 at "
"127.0.0.1:3301\n"
"<...> [11243] main/105/applier/localhost:3301 I> authenticated"

#: ../doc/book/replication/8_1.rst:1
msgid ""
"<... ...>\n"
"$ ~/tarantool/src/tarantool\n"
"<...>\n"
"tarantool> box.cfg{listen = 3301}\n"
"<...> [22612] main/101/interactive I> ready to accept requests\n"
"<... ...>\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> box.cfg{\n"
"         >   replication = 'replicator:password@localhost:3302'\n"
"         > }\n"
"[28987] main/101/interactive C> starting replication from localhost:3302\n"
"---\n"
"...\n"
"[22612] main/101/interactive C> starting replication from localhost:3302\n"
"[22612] main/101/interactive I> set 'replication' configuration\n"
"        option to \"replicator:password@localhost:3302\"\n"
"[22612] main/104/applier/localhost:3302 I> connected to 1.7.0 at "
"127.0.0.1:3302\n"
"[22612] main/104/applier/localhost:3302 I> authenticated\n"
"[22612] wal/101/main I> creating `./00000000000000000008.xlog.inprogress'"
"\n"
"[22612] relay/127.0.0.1:33510/102/main I> done "
"`./00000000000000000000.xlog'\n"
"[22612] relay/127.0.0.1:33510/102/main I> recover from "
"`./00000000000000000008.xlog'\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"  - [3, 'Another']\n"
"..."
msgstr ""
"<... ...>\n"
"$ ~/tarantool/src/tarantool\n"
"<...>\n"
"tarantool> box.cfg{listen = 3301}\n"
"<...> [22612] main/101/interactive I> ready to accept requests\n"
"<... ...>\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> box.cfg{\n"
"         >   replication = 'replicator:password@localhost:3302'\n"
"         > }\n"
"[28987] main/101/interactive C> starting replication from localhost:3302\n"
"---\n"
"...\n"
"[22612] main/101/interactive C> starting replication from localhost:3302\n"
"[22612] main/101/interactive I> set 'replication' configuration\n"
"        option to \"replicator:password@localhost:3302\"\n"
"[22612] main/104/applier/localhost:3302 I> connected to 1.7.0 at "
"127.0.0.1:3302\n"
"[22612] main/104/applier/localhost:3302 I> authenticated\n"
"[22612] wal/101/main I> creating `./00000000000000000008.xlog.inprogress'"
"\n"
"[22612] relay/127.0.0.1:33510/102/main I> done "
"`./00000000000000000000.xlog'\n"
"[22612] relay/127.0.0.1:33510/102/main I> recover from "
"`./00000000000000000008.xlog'\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"  - [3, 'Another']\n"
"..."

#: ../doc/book/replication/8_2.rst:1
msgid ""
"<... ...>\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
"<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken "
"pipe\n"
"<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 "
"second\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool> box.space.tester:insert{3, 'Another'}\n"
"---\n"
"- [3, 'Another']\n"
"...\n"
"<...> [11243] main/105/applier/localhost:3301 I> connected to 1.7.0 at "
"127.0.0.1:3301\n"
"<...> [11243] main/105/applier/localhost:3301 I> authenticated\n"
"tarantool>\n"
"<...> [11243] relay/127.0.0.1:36150/101/main I> recover from "
"`./00000000000000000000.xlog'\n"
"<...> [11243] relay/127.0.0.1:36150/101/main recovery.cc:211 W> file\n"
"     `./00000000000000000000.xlog` wasn't correctly closed\n"
"<...> [11243] relay/127.0.0.1:36150/102/main I> recover from "
"`./00000000000000000000.xlog'"
msgstr ""
"<... ...>\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
"<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken "
"pipe\n"
"<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 "
"second\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool> box.space.tester:insert{3, 'Another'}\n"
"---\n"
"- [3, 'Another']\n"
"...\n"
"<...> [11243] main/105/applier/localhost:3301 I> connected to 1.7.0 at "
"127.0.0.1:3301\n"
"<...> [11243] main/105/applier/localhost:3301 I> authenticated\n"
"tarantool>\n"
"<...> [11243] relay/127.0.0.1:36150/101/main I> recover from "
"`./00000000000000000000.xlog'\n"
"<...> [11243] relay/127.0.0.1:36150/101/main recovery.cc:211 W> file\n"
"     `./00000000000000000000.xlog` wasn't correctly closed\n"
"<...> [11243] relay/127.0.0.1:36150/102/main I> recover from "
"`./00000000000000000000.xlog'"

#: ../doc/book/replication/index.rst:5
msgid "Replication"
msgstr "Репликация"

#: ../doc/book/replication/index.rst:7
msgid ""
"Replication allows multiple Tarantool instances to work on copies of the "
"same databases. The databases are kept in sync because each instance can "
"communicate its changes to all the other instances."
msgstr ""
"Механизм репликации позволяет сразу многим экземплярам Tarantool'а "
"работать с копиями одних и тех же баз данных. При этом все базы остаются "
"в синхронизированном состоянии благодаря тому, что каждый экземпляр может"
" сообщать другим экземплярам о совершенных им изменениях."

#: ../doc/book/replication/repl_add_instances.rst:5
msgid "Adding instances"
msgstr "Добавление экземпляров"

#: ../doc/book/replication/repl_add_instances.rst:11
msgid "Adding a replica"
msgstr "Добавление реплики"

#: ../doc/book/replication/repl_add_instances.rst:16
msgid ""
"To add a second **replica** instance to the **master-replica** set from "
"our :ref:`bootstrapping example <replication-master_replica_bootstrap>`, "
"we need an analog of the instance file that we created for the first "
"replica in that set:"
msgstr ""
"Чтобы добавить вторую **реплику** в набор реплик с конфигурацией "
"**мастер-реплика** из нашего :ref:`примера настройки <replication-"
"master_replica_bootstrap>`, необходим аналог файла экземпляра, который мы"
" создали для первой реплики в этом наборе:"

#: ../doc/book/replication/repl_add_instances.rst:20
msgid ""
"-- instance file for replica #2\n"
"box.cfg{\n"
"  listen = 3301,\n"
"  replication = {'replicator:password@192.168.0.101:3301',  -- master URI"
"\n"
"                 'replicator:password@192.168.0.102:3301',  -- replica #1"
" URI\n"
"                 'replicator:password@192.168.0.103:3301'}, -- replica #2"
" URI\n"
"  read_only = true\n"
"}\n"
"box.once(\"schema\", function()\n"
"   box.schema.user.create('replicator', {password = 'password'})\n"
"   box.schema.user.grant('replicator', 'replication') -- grant "
"replication role\n"
"   box.schema.space.create(\"test\")\n"
"   box.space.test:create_index(\"primary\")\n"
"   print('box.once executed on replica #2')\n"
"end)"
msgstr ""
"-- файл экземпляра для реплики №2\n"
"box.cfg{\n"
"  listen = 3301,\n"
"  replication = {'replicator:password@192.168.0.101:3301',  -- URI "
"мастера\n"
"                 'replicator:password@192.168.0.102:3301',  -- URI "
"реплики №1\n"
"                 'replicator:password@192.168.0.103:3301'}, -- URI "
"реплики №2\n"
"  read_only = true\n"
"}\n"
"box.once(\"schema\", function()\n"
"   box.schema.user.create('replicator', {password = 'password'})\n"
"   box.schema.user.grant('replicator', 'replication') -- предоставить "
"роль для репликации\n"
"   box.schema.space.create(\"test\")\n"
"   box.space.test:create_index(\"primary\")\n"
"   print('box.once executed on replica #2')\n"
"end)"

#: ../doc/book/replication/repl_add_instances.rst:38
msgid ""
"Here we add the URI of replica #2 to the :ref:`replication "
"<cfg_replication-replication>` parameter, so now it contains three URIs."
msgstr ""
"Здесь мы добавляем URI реплики №2 в параметр :ref:`replication "
"<cfg_replication-replication>`, так что теперь он содержит три URI."

#: ../doc/book/replication/repl_add_instances.rst:41
msgid ""
"After we launch the new replica instance, it gets connected to the master"
" instance and retrieves the master's write-ahead-log and snapshot files:"
msgstr ""
"После запуска новая реплика подключается к мастер-серверу и получает от "
"него журнал упреждающей записи и файлы снимков:"

#: ../doc/book/replication/repl_add_instances.rst:44
msgid ""
"$ # launching replica #2\n"
"$ tarantool replica2.lua\n"
"2017-06-14 14:54:33.927 [46945] main/101/replica2.lua C> version "
"1.7.4-52-g980d30092\n"
"2017-06-14 14:54:33.927 [46945] main/101/replica2.lua C> log level 5\n"
"2017-06-14 14:54:33.928 [46945] main/101/replica2.lua I> mapping "
"268435456 bytes for tuple arena...\n"
"2017-06-14 14:54:33.930 [46945] main/104/applier/replicator@192.168.0.10 "
"I> remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 14:54:33.930 [46945] main/104/applier/replicator@192.168.0.10 "
"I> authenticated\n"
"2017-06-14 14:54:33.930 [46945] main/101/replica2.lua I> bootstrapping "
"replica from 192.168.0.101:3301\n"
"2017-06-14 14:54:33.933 [46945] main/104/applier/replicator@192.168.0.10 "
"I> initial data received\n"
"2017-06-14 14:54:33.933 [46945] main/104/applier/replicator@192.168.0.10 "
"I> final data received\n"
"2017-06-14 14:54:33.934 [46945] snapshot/101/main I> saving snapshot "
"`/var/lib/tarantool/replica2/00000000000000000010.snap.inprogress'\n"
"2017-06-14 14:54:33.934 [46945] snapshot/101/main I> done\n"
"2017-06-14 14:54:33.935 [46945] main/101/replica2.lua I> vinyl checkpoint"
" done\n"
"2017-06-14 14:54:33.935 [46945] main/101/replica2.lua I> ready to accept "
"requests\n"
"2017-06-14 14:54:33.935 [46945] main/101/replica2.lua I> set 'read_only' "
"configuration option to true\n"
"2017-06-14 14:54:33.936 [46945] main C> entering the event loop"
msgstr ""
"$ # запуск реплики №2\n"
"$ tarantool replica2.lua\n"
"2017-06-14 14:54:33.927 [46945] main/101/replica2.lua C> version "
"1.7.4-52-g980d30092\n"
"2017-06-14 14:54:33.927 [46945] main/101/replica2.lua C> log level 5\n"
"2017-06-14 14:54:33.928 [46945] main/101/replica2.lua I> mapping "
"268435456 bytes for tuple arena...\n"
"2017-06-14 14:54:33.930 [46945] main/104/applier/replicator@192.168.0.10 "
"I> remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 14:54:33.930 [46945] main/104/applier/replicator@192.168.0.10 "
"I> authenticated\n"
"2017-06-14 14:54:33.930 [46945] main/101/replica2.lua I> bootstrapping "
"replica from 192.168.0.101:3301\n"
"2017-06-14 14:54:33.933 [46945] main/104/applier/replicator@192.168.0.10 "
"I> initial data received\n"
"2017-06-14 14:54:33.933 [46945] main/104/applier/replicator@192.168.0.10 "
"I> final data received\n"
"2017-06-14 14:54:33.934 [46945] snapshot/101/main I> saving snapshot "
"`/var/lib/tarantool/replica2/00000000000000000010.snap.inprogress'\n"
"2017-06-14 14:54:33.934 [46945] snapshot/101/main I> done\n"
"2017-06-14 14:54:33.935 [46945] main/101/replica2.lua I> vinyl checkpoint"
" done\n"
"2017-06-14 14:54:33.935 [46945] main/101/replica2.lua I> ready to accept "
"requests\n"
"2017-06-14 14:54:33.935 [46945] main/101/replica2.lua I> set 'read_only' "
"configuration option to true\n"
"2017-06-14 14:54:33.936 [46945] main C> entering the event loop"

#: ../doc/book/replication/repl_add_instances.rst:63
msgid ""
"Since we are adding a read-only instance, there is no need to dynamically"
" update the ``replication`` parameter on the other running instances. "
"This update would be required if we :ref:`added a master instance "
"<replication-add_master>`."
msgstr ""
"Поскольку мы добавляем экземпляр только для чтения (read-only), нет "
"необходимости в динамическом обновлении параметра ``replication`` на "
"других работающих экземплярах. Такое обновление необходимо, если бы мы "
":ref:`добавляли мастера <replication-add_master>`."

#: ../doc/book/replication/repl_add_instances.rst:67
msgid ""
"However, we recommend specifying the URI of replica #3 in all instance "
"files of the replica set. This will keep all the files consistent with "
"each other and with the current replication topology, and so will help to"
" avoid configuration errors in case of further configuration updates and "
"replica set restart."
msgstr ""
"Тем не менее, рекомендуем указать URI реплики №3 во всех файлах "
"экземпляра в наборе реплик. Это поможет сохранить единообразие файлов и "
"согласовать их с текущей топологией репликации, а также не допустить "
"ошибок конфигурации в случае последующего обновления конфигурации и "
"перезапуска набора реплик."

#: ../doc/book/replication/repl_add_instances.rst:76
msgid "Adding a master"
msgstr "Добавление мастера"

#: ../doc/book/replication/repl_add_instances.rst:81
msgid ""
"To add a third master instance to the **master-master** set from our "
":ref:`bootstrapping example <replication-master_master_bootstrap>`, we "
"need an analog of the instance files that we created to bootstrap the "
"other master instances in that set:"
msgstr ""
"Чтобы добавить третьего мастера в набор реплик с конфигурацией "
"**мастер-мастер** из нашего :ref:`примера настройки <replication-"
"master_master_bootstrap>`, необходим аналог файлов экземпляров, которые "
"мы создали для настройки других мастеров в этом наборе:"

#: ../doc/book/replication/repl_add_instances.rst:86
msgid ""
"-- instance file for master #3\n"
"box.cfg{\n"
"  listen      = 3301,\n"
"  replication = {'replicator:password@192.168.0.101:3301',  -- master#1 "
"URI\n"
"                 'replicator:password@192.168.0.102:3301',  -- master#2 "
"URI\n"
"                 'replicator:password@192.168.0.103:3301'}, -- master#3 "
"URI\n"
"  read_only   = true, -- temporarily read-only\n"
"}\n"
"box.once(\"schema\", function()\n"
"   box.schema.user.create('replicator', {password = 'password'})\n"
"   box.schema.user.grant('replicator', 'replication') -- grant "
"replication role\n"
"   box.schema.space.create(\"test\")\n"
"   box.space.test:create_index(\"primary\")\n"
"end)"
msgstr ""
"-- файл экземпляра для мастера №3\n"
"box.cfg{\n"
"  listen      = 3301,\n"
"  replication = {'replicator:password@192.168.0.101:3301',  -- URI "
"мастера №1\n"
"                 'replicator:password@192.168.0.102:3301',  -- URI "
"мастера №2\n"
"                 'replicator:password@192.168.0.103:3301'}, -- URI "
"мастера №3\n"
"  read_only   = true, -- временно только для чтения\n"
"}\n"
"box.once(\"schema\", function()\n"
"   box.schema.user.create('replicator', {password = 'password'})\n"
"   box.schema.user.grant('replicator', 'replication') -- выдача роли для "
"репликации\n"
"   box.schema.space.create(\"test\")\n"
"   box.space.test:create_index(\"primary\")\n"
"end)"

#: ../doc/book/replication/repl_add_instances.rst:103
msgid "Here we make the following changes:"
msgstr "Здесь мы вносим следующие изменения:"

#: ../doc/book/replication/repl_add_instances.rst:105
msgid ""
"Add the URI of master #3 to the :ref:`replication <cfg_replication-"
"replication>` parameter."
msgstr ""
"Добавить URI мастера №3 в параметр :ref:`replication <cfg_replication-"
"replication>`."

#: ../doc/book/replication/repl_add_instances.rst:107
msgid ""
"Temporarily specify :ref:`read_only=true <cfg_basic-read_only>` to "
"disable data-change operations on the instance. After launch, master #3 "
"will act as a replica until it retrieves all data from the other masters "
"in the replica set."
msgstr ""
"Временно укажите :ref:`read_only=true <cfg_basic-read_only>`, чтобы "
"отключить операции по изменению данных на этом экземпляре. После запуска "
"мастер №3 будет работать в качестве реплики, пока не получит все данные "
"от других мастеров в наборе реплик."

#: ../doc/book/replication/repl_add_instances.rst:111
msgid ""
"After we launch master #3, it gets connected to the other master "
"instances and retrieves their write-ahead-log and snapshot files:"
msgstr ""
"После запуска мастер №3 подключается к другим мастер-экземплярам и "
"получает от них файлы журнала упреждающей записи и файлы снимков:"

#: ../doc/book/replication/repl_add_instances.rst:114
msgid ""
"$ # launching master #3\n"
"$ tarantool master3.lua\n"
"2017-06-14 17:10:00.556 [47121] main/101/master3.lua C> version "
"1.7.4-52-g980d30092\n"
"2017-06-14 17:10:00.557 [47121] main/101/master3.lua C> log level 5\n"
"2017-06-14 17:10:00.557 [47121] main/101/master3.lua I> mapping 268435456"
" bytes for tuple arena...\n"
"2017-06-14 17:10:00.559 [47121] iproto/101/main I> binary: bound to "
"[::]:3301\n"
"2017-06-14 17:10:00.559 [47121] main/104/applier/replicator@192.168.0.10 "
"I> remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 17:10:00.559 [47121] main/105/applier/replicator@192.168.0.10 "
"I> remote master is 1.7.4 at 192.168.0.102:3301\n"
"2017-06-14 17:10:00.559 [47121] main/106/applier/replicator@192.168.0.10 "
"I> remote master is 1.7.4 at 192.168.0.103:3301\n"
"2017-06-14 17:10:00.559 [47121] main/105/applier/replicator@192.168.0.10 "
"I> authenticated\n"
"2017-06-14 17:10:00.559 [47121] main/101/master3.lua I> bootstrapping "
"replica from 192.168.0.102:3301\n"
"2017-06-14 17:10:00.562 [47121] main/105/applier/replicator@192.168.0.10 "
"I> initial data received\n"
"2017-06-14 17:10:00.562 [47121] main/105/applier/replicator@192.168.0.10 "
"I> final data received\n"
"2017-06-14 17:10:00.562 [47121] snapshot/101/main I> saving snapshot "
"`/Users/e.shebunyaeva/work/tarantool-test-"
"repl/master3_dir/00000000000000000009.snap.inprogress'\n"
"2017-06-14 17:10:00.562 [47121] snapshot/101/main I> done\n"
"2017-06-14 17:10:00.564 [47121] main/101/master3.lua I> vinyl checkpoint "
"done\n"
"2017-06-14 17:10:00.564 [47121] main/101/master3.lua I> ready to accept "
"requests\n"
"2017-06-14 17:10:00.565 [47121] main/101/master3.lua I> set 'read_only' "
"configuration option to true\n"
"2017-06-14 17:10:00.565 [47121] main C> entering the event loop\n"
"2017-06-14 17:10:00.565 [47121] main/104/applier/replicator@192.168.0.10 "
"I> authenticated"
msgstr ""
"$ # запуск мастера №3\n"
"$ tarantool master3.lua\n"
"2017-06-14 17:10:00.556 [47121] main/101/master3.lua C> version "
"1.7.4-52-g980d30092\n"
"2017-06-14 17:10:00.557 [47121] main/101/master3.lua C> log level 5\n"
"2017-06-14 17:10:00.557 [47121] main/101/master3.lua I> mapping 268435456"
" bytes for tuple arena...\n"
"2017-06-14 17:10:00.559 [47121] iproto/101/main I> binary: bound to "
"[::]:3301\n"
"2017-06-14 17:10:00.559 [47121] main/104/applier/replicator@192.168.0.10 "
"I> remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 17:10:00.559 [47121] main/105/applier/replicator@192.168.0.10 "
"I> remote master is 1.7.4 at 192.168.0.102:3301\n"
"2017-06-14 17:10:00.559 [47121] main/106/applier/replicator@192.168.0.10 "
"I> remote master is 1.7.4 at 192.168.0.103:3301\n"
"2017-06-14 17:10:00.559 [47121] main/105/applier/replicator@192.168.0.10 "
"I> authenticated\n"
"2017-06-14 17:10:00.559 [47121] main/101/master3.lua I> bootstrapping "
"replica from 192.168.0.102:3301\n"
"2017-06-14 17:10:00.562 [47121] main/105/applier/replicator@192.168.0.10 "
"I> initial data received\n"
"2017-06-14 17:10:00.562 [47121] main/105/applier/replicator@192.168.0.10 "
"I> final data received\n"
"2017-06-14 17:10:00.562 [47121] snapshot/101/main I> saving snapshot "
"`/Users/e.shebunyaeva/work/tarantool-test-"
"repl/master3_dir/00000000000000000009.snap.inprogress'\n"
"2017-06-14 17:10:00.562 [47121] snapshot/101/main I> done\n"
"2017-06-14 17:10:00.564 [47121] main/101/master3.lua I> vinyl checkpoint "
"done\n"
"2017-06-14 17:10:00.564 [47121] main/101/master3.lua I> ready to accept "
"requests\n"
"2017-06-14 17:10:00.565 [47121] main/101/master3.lua I> set 'read_only' "
"configuration option to true\n"
"2017-06-14 17:10:00.565 [47121] main C> entering the event loop\n"
"2017-06-14 17:10:00.565 [47121] main/104/applier/replicator@192.168.0.10 "
"I> authenticated"

#: ../doc/book/replication/repl_add_instances.rst:137
msgid ""
"Next, we add the URI of master #3 to the ``replication`` parameter on the"
" existing two masters. Replication-related parameters are dynamic, so we "
"only need to make a ``box.cfg{}`` request on each of the running "
"instances:"
msgstr ""
"Затем добавляем URI мастера №3 в параметр ``replication`` на существующих"
" мастерах. В конфигурации репликации используются динамические параметры,"
" поэтому необходимо только выполнить запрос ``box.cfg{}`` на каждом "
"работающем экземпляре:"

#: ../doc/book/replication/repl_add_instances.rst:141
msgid ""
"# adding master #3 URI to replication sources\n"
"tarantool> box.cfg{replication =\n"
"         > {'replicator:password@192.168.0.101:3301',\n"
"         > 'replicator:password@192.168.0.102:3301',\n"
"         > 'replicator:password@192.168.0.103:3301'}}\n"
"---\n"
"..."
msgstr ""
"# добавление URI мастера №3 в источники репликации\n"
"tarantool> box.cfg{replication =\n"
"         > {'replicator:password@192.168.0.101:3301',\n"
"         > 'replicator:password@192.168.0.102:3301',\n"
"         > 'replicator:password@192.168.0.103:3301'}}\n"
"---\n"
"..."

#: ../doc/book/replication/repl_add_instances.rst:151
msgid ""
"When master #3 catches up with the other masters' state, we can disable "
"read-only mode for this instance:"
msgstr ""
"Когда мастер №3 получает все необходимые изменения от других мастеров, "
"можно отключить режим только для чтения:"

#: ../doc/book/replication/repl_add_instances.rst:154
msgid ""
"# making master #3 a real master\n"
"tarantool> box.cfg{read_only=false}\n"
"---\n"
"..."
msgstr ""
"# назначение мастера №3 настоящим мастером\n"
"tarantool> box.cfg{read_only=false}\n"
"---\n"
"..."

#: ../doc/book/replication/repl_add_instances.rst:161
msgid ""
"We also recommend to specify master #3 URI in all instance files in order"
" to keep all the files consistent with each other and with the current "
"replication topology."
msgstr ""
"Также рекомендуется указать URI мастера №3 во всех файлах экземпляра, "
"чтобы сохранить единообразие файлов и согласовать их с текущей топологией"
" репликации."

#: ../doc/book/replication/repl_add_instances.rst:169
msgid "Orphan status"
msgstr "Статус orphan (одиночный)"

#: ../doc/book/replication/repl_add_instances.rst:171
msgid ""
"Starting with Tarantool version 1.9, there is a change to the procedure "
"when an instance joins a replica set. During ``box.cfg()`` the instance "
"will try to join all masters listed in :ref:`box.cfg.replication "
"<cfg_replication-replication>`. If the instance does not succeed with at "
"least the number of masters specified in :ref:`replication_connect_quorum"
" <cfg_replication-replication_connect_quorum>`, then it will switch to "
"**orphan status**. While an instance is in orphan status, it is read-"
"only."
msgstr ""
"Начиная с версии Tarantool'а 1.9, процедура подключения реплики к набору "
"реплик изменяется. Во время ``box.cfg()`` экземпляр попытается "
"подключиться ко всем мастерам, указанным в :ref:`box.cfg.replication "
"<cfg_replication-replication>`. Если не было успешно выполнено "
"подключение к количеству мастеров, указанному в "
":ref:`replication_connect_quorum <cfg_replication-"
"replication_connect_quorum>`, экземпляр переходит в **статус orphan** "
"(одиночный). Когда экземпляр находится в статусе orphan, он доступен "
"только для чтения."

#: ../doc/book/replication/repl_add_instances.rst:181
msgid ""
"To \"join\" a master, a replica instance must \"connect\" to the master "
"node and then \"sync\"."
msgstr ""
"Чтобы \"подключиться\" к мастеру, реплика должна \"установить "
"соединение\" с узлом мастера, а затем \"выполнить синхронизацию\"."

#: ../doc/book/replication/repl_add_instances.rst:184
msgid ""
"\"Connect\" means contact the master over the physical network and "
"receive acknowledgment. If there is no acknowledgment after "
":ref:`box.replication_connect_timeout <cfg_replication-"
"replication_connect_timeout>` seconds (usually 4 seconds), and retries "
"fail, then the connect step fails."
msgstr ""
"\"Установка соединения\" означает контакт с мастером по физической сети и"
" получение подтверждения. Если нет подтверждения соединения через "
":ref:`box.replication_connect_timeout <cfg_replication-"
"replication_connect_timeout>` секунд (обычно 4 секунды), и повторные "
"попытки подключения не сработали, то соединение не установлено."

#: ../doc/book/replication/repl_add_instances.rst:189
msgid ""
"\"Sync\" means receive updates from the master in order to make a local "
"database copy. Syncing is complete when the replica has received all the "
"updates, or at least has received enough updates that the replica's lag "
"(see :ref:`replication.upstream.lag <box_info_replication_upstream_lag>` "
"in ``box.info()``) is less than or equal to the number of seconds "
"specified in :ref:`box.cfg.replication_sync_lag <cfg_replication-"
"replication_sync_lag>`. If ``replication_sync_lag`` is unset (nil) or set"
" to TIMEOUT_INFINITY, then the replica skips the \"sync\" state and "
"switches to \"follow\" immediately."
msgstr ""
"\"Синхронизация\" означает получение обновлений от мастера для создания "
"локальной копии базы данных. Синхронизация завершена, когда реплика "
"получила все обновления или хотя бы получила достаточное количество "
"обновлений, чтобы отставание реплики (см. :ref:`replication.upstream.lag "
"<box_info_replication_upstream_lag>` в ``box.info()``) было меньше или "
"равно количеству секунд, указанному в :ref:`box.cfg.replication_sync_lag "
"<cfg_replication-replication_sync_lag>`. Если значение "
"``replication_sync_lag`` не задано (nil) или указано как "
"\"TIMEOUT_INFINITY\", то реплика пропускает шаг \"синхронизация\" и сразу"
" же переходит на \"отслеживание\"."

#: ../doc/book/replication/repl_add_instances.rst:201
msgid ""
"In order to leave orphan mode you need to sync with a sufficient number "
"(:ref:`replication_connect_quorum <cfg_replication-"
"replication_connect_quorum>`) of instances. To do so, you may either:"
msgstr ""
"Чтобы вывести узел из одиночного статуса, нужно синхронизировать его с "
"достаточным (т.е. равным :ref:`replication_connect_quorum "
"<cfg_replication-replication_connect_quorum>`) количеством других узлов. "
"Этого можно добиться, выполнив любое из следующих действий:"

#: ../doc/book/replication/repl_add_instances.rst:205
msgid ""
"Set :ref:`replication_connect_quorum <cfg_replication-"
"replication_connect_quorum>` to a lower value."
msgstr ""
"Уменьшить значение :ref:`replication_connect_quorum <cfg_replication-"
"replication_connect_quorum>`."

#: ../doc/book/replication/repl_add_instances.rst:207
msgid ""
"Reset ``box.cfg.replication`` to exclude instances that cannot be reached"
" or synced with."
msgstr ""
"Убрать из списка ``box.cfg.replication`` недоступные и прочие узлы, с "
"которыми нельзя синхронизироваться."

#: ../doc/book/replication/repl_add_instances.rst:209
msgid "Set ``box.cfg.replication`` to ``\"\"`` (empty string)."
msgstr ""
"Вообще задать ``\"\"`` (пустую строку) в качестве "
"значения``box.cfg.replication``."

#: ../doc/book/replication/repl_add_instances.rst:211
msgid "The following situations are possible."
msgstr "Возможны следующие ситуации."

#: ../doc/book/replication/repl_add_instances.rst:215
msgid "**Situation 1: bootstrap**"
msgstr "**Ситуация 1: настройка**"

#: ../doc/book/replication/repl_add_instances.rst:217
msgid ""
"Here ``box.cfg{}`` is being called for the first time. A replica is "
"joining but no replica set exists yet."
msgstr ""
"Здесь впервые происходит вызов ``box.cfg{}``. Реплика подключается, но "
"набора реплик пока нет."

#: ../doc/book/replication/repl_add_instances.rst:220
msgid "Set status to 'orphan'."
msgstr "Установка статуса 'orphan' (одиночный)."

#: ../doc/book/replication/repl_add_instances.rst:221
msgid ""
"Try to connect to all nodes from ``box.cfg.replication``, or to the "
"number of nodes required by :ref:`replication_connect_quorum "
"<cfg_replication-replication_connect_quorum>`. Retrying up to 3 times in "
"30 seconds is possible because this is bootstrap, "
":ref:`replication_connect_timeout <cfg_replication-"
"replication_connect_timeout>` is overridden."
msgstr ""
"Попытка установить соединение со всеми узлами из ``box.cfg.replication`` "
"или с количеством узлов, указанным в параметре "
":ref:`replication_connect_quorum <cfg_replication-"
"replication_connect_quorum>`. Допускаются три повторные попытки за 30 "
"секунд, поскольку идет стадия настройки, параметр "
":ref:`replication_connect_timeout <cfg_replication-"
"replication_connect_timeout>` не учитывается."

#: ../doc/book/replication/repl_add_instances.rst:228
msgid ""
"Abort and throw an error if not connected to all nodes in "
"``box.cfg.replication`` or :ref:`replication_connect_quorum "
"<cfg_replication-replication_connect_quorum>`."
msgstr ""
"Прекращение работы и выдача ошибки в случае отсутствия соединения со "
"всеми узлами в ``box.cfg.replication`` или "
":ref:`replication_connect_quorum <cfg_replication-"
"replication_connect_quorum>`."

#: ../doc/book/replication/repl_add_instances.rst:231
msgid ""
"This instance might be elected as the replica set 'leader'. Criteria for "
"electing a leader include vclock value (largest is best), and whether it "
"is read-only or read-write (read-write is best unless there is no other "
"choice). The leader is the master that other instances must join. The "
"leader is the master that executes :ref:`box_once() <box-once>` "
"functions."
msgstr ""
"Экземпляр может быть выбран в качестве лидера 'leader' в наборе реплик. "
"Критерии выбора лидера включают в себя значение vclock (чем больше, тем "
"лучше), а также доступность только для чтения или для чтения и записи "
"(лучше всего для чтения и записи, кроме случаев, когда других вариантов "
"нет). Лидер является мастером, к которому должны подключиться другие "
"экземпляры. Лидер является мастером, который выполняет функции "
":ref:`box_once() <box-once>`."

#: ../doc/book/replication/repl_add_instances.rst:237
msgid ""
"If this instance is elected as the replica set leader, then perform an "
"\"automatic bootstrap\":"
msgstr ""
"Если данный экземпляр выбран лидером набора реплик, выполняется "
"\"самонастройка\":"

#: ../doc/book/replication/repl_add_instances.rst:241
msgid "Set status to 'running'."
msgstr "Установка статуса 'running' (запущен)."

#: ../doc/book/replication/repl_add_instances.rst:242
msgid "Return from ``box.cfg{}``."
msgstr "Возврат из ``box.cfg{}``."

#: ../doc/book/replication/repl_add_instances.rst:244
msgid ""
"Otherwise this instance will be a replica joining an existing replica "
"set, so:"
msgstr ""
"В противном случае, данный экземпляр будет репликой, которая подключается"
" к существующему набору реплик, поэтому:"

#: ../doc/book/replication/repl_add_instances.rst:247
msgid ""
"Bootstrap from the leader. See examples in section :ref:`Bootstrapping a "
"replica set <replication-bootstrap>`."
msgstr ""
"Настройка от лидера. См. примеры в разделе :ref:`Настройка набора реплик "
"<replication-bootstrap>`."

#: ../doc/book/replication/repl_add_instances.rst:249
msgid "In background, sync with all the other nodes in the replication set."
msgstr "Синхронизация со всеми остальными узлами в наборе реплик в фоновом режиме."

#: ../doc/book/replication/repl_add_instances.rst:251
msgid "**Situation 2: recovery**"
msgstr "**Ситуация 2: восстановление**"

#: ../doc/book/replication/repl_add_instances.rst:253
msgid ""
"Here ``box.cfg{}`` is not being called for the first time. It is being "
"called again in order to perform recovery."
msgstr ""
"Здесь вызов ``box.cfg{}`` происходит не впервые, а повторно для "
"осуществления восстановления."

#: ../doc/book/replication/repl_add_instances.rst:256
msgid ""
"Perform :ref:`recovery <internals-recovery_process>` from the last local "
"snapshot and the WAL files."
msgstr ""
"Проведение :ref:`восстановления <internals-recovery_process>` из "
"последнего локального снимка и WAL-файлов."

#: ../doc/book/replication/repl_add_instances.rst:259
msgid ""
"Connect to at least :ref:`replication_connect_quorum <cfg_replication-"
"replication_connect_quorum>` nodes. If failed - set status to 'orphan'. "
"(Attempts to sync will continue in the background and when/if they "
"succeed then 'orphan' will be changed to 'connected'.)"
msgstr ""
"Установить соединение с количеством узлов не меньшим, чем "
":ref:`replication_connect_quorum <cfg_replication-"
"replication_connect_quorum>`. Если не получается - установить статус "
"'orphan'. (Попытки синхронизации будут повторяться в фоновом режиме, и "
"когда/если они окажутся успешными, статус 'orphan' сменится на "
"'connected'.)"

#: ../doc/book/replication/repl_add_instances.rst:265
msgid ""
"If connected - sync with all connected nodes, until the difference is not"
" more than :ref:`replication_sync_lag <cfg_replication-"
"replication_sync_lag>` seconds."
msgstr ""
"Если соединение установлено - осуществлять синхронизацию со всеми "
"подключенными узлами до тех пор, пока отличия не будут более "
":ref:`replication_sync_lag <cfg_replication-replication_sync_lag>` "
"секунд."

#: ../doc/book/replication/repl_add_instances.rst:270
msgid "**Situation 3: configuration update**"
msgstr "**Ситуация 3: обновление конфигурации**"

#: ../doc/book/replication/repl_add_instances.rst:272
msgid ""
"Here ``box.cfg{}`` is not being called for the first time. It is being "
"called again because some replication parameter or something in the "
"replica set has changed."
msgstr ""
"Здесь вызов ``box.cfg{}`` происходит не впервые, а повторно, поскольку "
"изменились некоторые параметры репликации или что-то в наборе реплик."

#: ../doc/book/replication/repl_add_instances.rst:276
msgid ""
"Try to connect to all nodes from ``box.cfg.replication``, or to the "
"number of nodes required by :ref:`replication_connect_quorum "
"<cfg_replication-replication_connect_quorum>`, within the time period "
"specified in :ref:`replication_connect_timeout <cfg_replication-"
"replication_connect_timeout>`."
msgstr ""
"Попытка установить соединение со всеми узлами из ``box.cfg.replication`` "
"или с количеством узлов, указанным в параметре "
":ref:`replication_connect_quorum <cfg_replication-"
"replication_connect_quorum>` в течение периода времени, указанного в "
":ref:`replication_connect_timeout <cfg_replication-"
"replication_connect_timeout>`."

#: ../doc/book/replication/repl_add_instances.rst:282
msgid ""
"Try to sync with the connected nodes, within the time period specified in"
" :ref:`replication_sync_timeout <cfg_replication-"
"replication_sync_timeout>`."
msgstr ""
"Попытка синхронизации со всеми подключенными узлами в течение периода "
"времени, указанного в :ref:`replication_sync_timeout <cfg_replication-"
"replication_sync_timeout>`."

#: ../doc/book/replication/repl_add_instances.rst:286
msgid ""
"If earlier steps fail, change status to 'orphan'. (Attempts to sync will "
"continue in the background and when/if they succeed then 'orphan' status "
"will end.)"
msgstr ""
"Если предыдущие шаги не выполнены, статус изменяется на 'orphan' "
"(одиночный). (Попытки синхронизации будут продолжаться в фоновом режиме, "
"и когда/если они будут успешны, статус 'orphan' отключится.)"

#: ../doc/book/replication/repl_add_instances.rst:290
msgid ""
"If earlier steps succeed, set status to 'running' (master) or 'follow' "
"(replica)."
msgstr ""
"Если предыдущие шаги выполнены, статус изменяется на 'running' (мастер) "
"или 'follow' (реплика)."

#: ../doc/book/replication/repl_add_instances.rst:294
msgid "**Situation 4: rebootstrap**"
msgstr "**Ситуация 4: повторная настройка**"

#: ../doc/book/replication/repl_add_instances.rst:296
msgid ""
"Here ``box.cfg{}`` is not being called. The replica connected "
"successfully at some point in the past, and is now ready for an update "
"from the master. But the master cannot provide an update. This can happen"
" by accident, or more likely can happen because the replica is slow (its "
":ref:`lag <cfg_replication-replication_sync_lag>` is large), and the WAL "
"(.xlog) files containing the updates have been deleted. This is not "
"crippling. The replica can discard what it received earlier, and then ask"
" for the master's latest snapshot (.snap) file contents. Since it is "
"effectively going through the bootstrap process a second time, this is "
"called \"rebootstrapping\". However, there has to be one difference from "
"an ordinary bootstrap -- the replica's :ref:`replica id <replication-"
"replica-id>` will remain the same. If it changed, then the master would "
"think that the replica is a new addition to the cluster, and would "
"maintain a record of an instance ID of a replica that has ceased to "
"exist. Rebootstrapping was introduced in Tarantool version 1.10.2 and is "
"completely automatic."
msgstr ""
"Здесь не происходит вызов ``box.cfg{}``. В определенный момент в прошлом "
"реплика успешно установила соединение и в настоящий момент ожидает "
"обновления от мастера. Однако мастер не может передать обновления, что "
"может произойти случайно, или же если реплика работает слишком медленно "
"(большое значение :ref:`lag <cfg_replication-replication_sync_lag>`), а "
"WAL-файлы (.xlog) с обновлениями были удалены. Такая ситуация не является"
" критической -- реплика может сбросить ранее полученные данные, а затем "
"запросить содержание последнего файла снимка (.snap) мастера. Поскольку "
"фактически в таком случае повторно проводится процесс настройки, это "
"называется \"повторная настройка\". Тем не менее, есть отличие от обычной"
" настройки -- :ref:`идентификатор реплики <replication-replica-id>` "
"останется прежним. Если он изменится, то мастер посчитает, что в кластер "
"добавляется новая реплика, и сохранит идентификатор экземпляра реплики, "
"которой уже не существует. Полностью автоматизированный процесс повторной"
" настройки появился в версии Tarantool'а 1.10.2."

#: ../doc/book/replication/repl_add_instances.rst:317
msgid "Server startup with replication"
msgstr "Запуск сервера с репликацией"

#: ../doc/book/replication/repl_add_instances.rst:319
msgid ""
"In addition to the recovery process described in the section "
":ref:`Recovery process <internals-recovery_process>`, the server must "
"take additional steps and precautions if :ref:`replication <replication>`"
" is enabled."
msgstr ""
"Помимо процесса восстановления, описанного в разделе :ref:`Процесс "
"восстановления <internals-recovery_process>`, сервер должен предпринять "
"дополнительные шаги и меры предосторожности, если включена "
":ref:`репликация <replication>`."

#: ../doc/book/replication/repl_add_instances.rst:323
msgid ""
"Once again the startup procedure is initiated by the ``box.cfg{}`` "
"request. One of the ``box.cfg`` parameters may be :ref:`replication "
"<cfg_replication-replication>` which specifies replication source(-s). We"
" will refer to this replica, which is starting up due to ``box.cfg``, as "
"the \"local\" replica to distinguish it from the other replicas in a "
"replica set, which we will refer to as \"distant\" replicas."
msgstr ""
"И снова процедура запуска начинается с запроса ``box.cfg{}``. Одним из "
"параметров запроса ``box.cfg`` может быть :ref:`replication "
"<cfg_replication-replication>`, в котором указываются источники "
"репликации. Реплику, которая запускается сейчас с помощью ``box.cfg``, мы"
" будем называть локальной, чтобы отличать ее от других реплик в наборе "
"реплик, которые мы будем называть удаленными."

#: ../doc/book/replication/repl_add_instances.rst:330
msgid ""
"*If there is no snapshot .snap file and the 'replication' parameter is "
"empty*: |br| then the local replica assumes it is an unreplicated "
"\"standalone\" instance, or is the first replica of a new replica set. It"
" will generate new UUIDs for itself and for the replica set. The replica "
"UUID is stored in the ``_cluster`` space; the replica set UUID is stored "
"in the ``_schema`` space. Since a snapshot contains all the data in all "
"the spaces, that means the local replica's snapshot will contain the "
"replica UUID and the replica set UUID. Therefore, when the local replica "
"restarts on later occasions, it will be able to recover these UUIDs when "
"it reads the .snap file."
msgstr ""
"*Если нет файла снимка .snap и не указано значение параметра "
"`replication`*: |br| то локальная реплика предполагает, что является "
"нереплицируемым обособленным экземпляром или же первой репликой в новом "
"наборе реплик. Она сгенерирует новые UUID для себя и для набора реплик. "
"UUID реплики хранится в спейсе ``_cluster``; UUID набора реплик хранится "
"в спейсе ``_schema``. Поскольку снимок содержит все данные во всех "
"спейсах, это означает, что снимок локальной реплики будет содержать UUID "
"реплики и UUID набора реплик. Таким образом, когда локальная реплика "
"будет позднее перезапускаться, она сможет восстановить эти UUID после "
"прочтения файла снимка .snap."

#: ../doc/book/replication/repl_add_instances.rst:340
msgid ""
"*If there is no snapshot .snap file and the 'replication' parameter is "
"not empty and the '_cluster' space contains no other replica UUIDs*: |br|"
" then the local replica assumes it is not a standalone instance, but is "
"not yet part of a replica set. It must now join the replica set. It will "
"send its replica UUID to the first distant replica which is listed in "
"``replication`` and which will act as a master. This is called the \"join"
" request\". When a distant replica receives a join request, it will send "
"back:"
msgstr ""
"*Если нет файла снимка .snap, указано значение параметра `replication`, а"
" в спейсе `_cluster` отсутствуют UUID других реплик*: |br| то локальная "
"реплика предполагает, что не является обособленным экземпляром, но еще не"
" входит в набор реплик. Сейчас она должна быть подключиться в набор "
"реплик. Она отправит свой UUID реплики первой удаленной реплике, "
"указанной в параметре ``replication``, которая будет выступать в качестве"
" мастера. Это называется \"запрос на подключение\". Когда удаленная "
"реплика получает запрос на подключение, она отправляет в ответ:"

#: ../doc/book/replication/repl_add_instances.rst:348
msgid "the distant replica's replica set UUID,"
msgstr "UUID набора реплик, в который входит удаленная реплика"

#: ../doc/book/replication/repl_add_instances.rst:349
msgid ""
"the contents of the distant replica's .snap file. |br| When the local "
"replica receives this information, it puts the replica set UUID in its "
"``_schema`` space, puts the distant replica's UUID and connection "
"information in its ``_cluster`` space, and makes a snapshot containing "
"all the data sent by the distant replica. Then, if the local replica has "
"data in its WAL .xlog files, it sends that data to the distant replica. "
"The distant replica will receive this and update its own copy of the "
"data, and add the local replica's UUID to its ``_cluster`` space."
msgstr ""
"содержимое файла снимка .snap удаленной реплики. |br| Когда локальная "
"реплика получает эту информацию, она размещает UUID набора реплики в "
"своем спейсе ``_schema``, UUID удаленной реплики и информацию о "
"подключении в своем спейсе ``_cluster``, а затем создает снимок, который "
"содержит все данные, отправленные удаленной репликой. Затем, если в "
"WAL-файлах .xlog локальной реплики содержатся данные, они отправляются на"
" удаленную реплику. Удаленная реплика получается данные и обновляет свою "
"копию данных, а затем добавляет UUID локальной реплики в свой спейс "
"``_cluster``."

#: ../doc/book/replication/repl_add_instances.rst:358
msgid ""
"*If there is no snapshot .snap file and the 'replication' parameter is "
"not empty and the ``_cluster`` space contains other replica UUIDs*: |br| "
"then the local replica assumes it is not a standalone instance, and is "
"already part of a replica set. It will send its replica UUID and replica "
"set UUID to all the distant replicas which are listed in ``replication``."
" This is called the \"on-connect handshake\". When a distant replica "
"receives an on-connect handshake: |br|"
msgstr ""
"*Если нет файла снимка .snap, указано значение параметра `replication`, а"
" в спейсе ``_cluster`` есть UUID других реплик*: |br| то локальная "
"реплика предполагает, что не является обособленным экземпляром, и уже "
"входит в набор реплик. Она отправит свой UUID реплики и UUID набора "
"реплик всем удаленным репликам, указанным в параметре ``replication``. "
"Это называется \"подтверждение связи при подключении\". Когда удаленная "
"реплика получает подтверждение связи при подключении: |br|"

#: ../doc/book/replication/repl_add_instances.rst:365
msgid ""
"the distant replica compares its own copy of the replica set UUID to the "
"one in the on-connect handshake. If there is no match, then the handshake"
" fails and the local replica will display an error."
msgstr ""
"удаленная реплика сопоставляет свою версию UUID набора реплик с UUID, "
"переданным в ходе подтверждения связи при подключении. Если они не "
"совпадают, связь не устанавливается, и локальная реплика отобразит "
"ошибку."

#: ../doc/book/replication/repl_add_instances.rst:368
msgid ""
"the distant replica looks for a record of the connecting instance in its "
"``_cluster`` space. If there is none, then the handshake fails. |br| "
"Otherwise the handshake is successful. The distant replica will read any "
"new information from its own .snap and .xlog files, and send the new "
"requests to the local replica."
msgstr ""
"удаленная реплика ищет запись о подключающемся экземпляре в своем спейсе "
"``_cluster``. Если такой записи нет, связь не устанавливается. |br| Если "
"есть, связь подтверждается. Удаленная реплика выполняет чтение любой "
"новой информации из своих файлов .snap и .xlog и отправляет новые запросы"
" на локальную реплику."

#: ../doc/book/replication/repl_add_instances.rst:374
msgid ""
"In the end, the local replica knows what replica set it belongs to, the "
"distant replica knows that the local replica is a member of the replica "
"set, and both replicas have the same database contents."
msgstr ""
"Наконец, локальная реплика понимает, к какому набору реплик относится, "
"удаленная реплика понимает, что локальная реплика входит в набор реплик, "
"и у двух реплик одинаковое содержимое базы данных."

#: ../doc/book/replication/repl_add_instances.rst:380
msgid ""
"*If there is a snapshot file and replication source is not empty*: |br| "
"first the local replica goes through the recovery process described in "
"the previous section, using its own .snap and .xlog files. Then it sends "
"a \"subscribe\" request to all the other replicas of the replica set. The"
" subscribe request contains the server vector clock. The vector clock has"
" a collection of pairs 'server id, lsn' for every replica in the "
"``_cluster`` system space. Each distant replica, upon receiving a "
"subscribe request, will read its .xlog files' requests and send them to "
"the local replica if (lsn of .xlog file request) is greater than (lsn of "
"the vector clock in the subscribe request). After all the other replicas "
"of the replica set have responded to the local replica's subscribe "
"request, the replica startup is complete."
msgstr ""
"*Если есть файл снимка и указан источник репликации*: |br| сначала "
"локальная реплика проходит процесс восстановления, описанный в предыдущем"
" разделе, используя свои собственные файлы .snap и .xlog. Затем она "
"отправляет запрос подписки всем репликам в наборе реплик. Запрос подписки"
" содержит векторные часы сервера. Векторные часы включают набор пар "
"'идентификатор сервера, LSN' для каждой реплики в системном спейсе "
"``_cluster``. Каждая удаленная реплика, получив запрос подписки, "
"выполняет чтение запросов из файла .xlog и отправляет их на локальную "
"реплику, если LSN из запроса файла .xlog больше, чем LSN векторных часов "
"из запроса подписки. После того, как все реплики из набора реплик "
"отправили ответ на запрос подписки локальной реплики, запуск реплики "
"завершен."

#: ../doc/book/replication/repl_add_instances.rst:392
msgid ""
"The following temporary limitations applied for Tarantool versions "
"earlier than 1.7.7:"
msgstr ""
"Следующие временные ограничения применимы к версиям Tarantool'а ниже "
"1.7.7:"

#: ../doc/book/replication/repl_add_instances.rst:395
msgid ""
"The URIs in the ``replication`` parameter should all be in the same order"
" on all replicas. This is not mandatory but is an aid to consistency."
msgstr ""
"URI в параметре ``replication`` должны быть указаны в одинаковом порядке "
"на всех репликах. Это необязательно, но помогает соблюдать "
"консистентность."

#: ../doc/book/replication/repl_add_instances.rst:397
msgid ""
"The replicas of a replica set should be started up at slightly different "
"times. This is not mandatory but prevents a situation where each replica "
"is waiting for the other replica to be ready."
msgstr ""
"Реплики в наборе реплик должны запускаться не одновременно. Это "
"необязательно, но помогает избежать ситуации, когда все реплики ждут "
"готовности друг друга."

#: ../doc/book/replication/repl_add_instances.rst:401
msgid "The following limitation still applies for the current Tarantool version:"
msgstr "Следующее ограничение всё еще применимо к текущей версии Tarantool'а:"

#: ../doc/book/replication/repl_add_instances.rst:403
msgid ""
"The maximum number of entries in the ``_cluster`` space is :ref:`32 "
"<limitations_replicas>`. Tuples for out-of-date replicas are not "
"automatically re-used, so if this 32-replica limit is reached, users may "
"have to reorganize the ``_cluster`` space manually."
msgstr ""
"Максимальное количество записей в спейсе ``_cluster`` -- :ref:`32 "
"<limitations_replicas>`. Кортежи для устаревших реплик не "
"переиспользуются автоматически, поэтому по достижении предела в 32 "
"реплики, может понадобиться реорганизация спейса ``_cluster`` вручную."

#: ../doc/book/replication/repl_architecture.rst:5
msgid "Replication architecture"
msgstr "Архитектура механизма репликации"

#: ../doc/book/replication/repl_architecture.rst:11
msgid "Replication mechanism"
msgstr "Механизм репликации"

#: ../doc/book/replication/repl_architecture.rst:13
msgid ""
"A pack of instances which operate on copies of the same databases make up"
" a **replica set**. Each instance in a replica set has a role, **master**"
" or **replica**."
msgstr ""
"Набор экземпляров, которые работают на копиях одной базы данных, "
"составляют **набор реплик**. У каждого экземпляра в наборе реплик есть "
"роль: **мастер** или **реплика**."

#: ../doc/book/replication/repl_architecture.rst:17
msgid ""
"A replica gets all updates from the master by continuously fetching and "
"applying its :ref:`write ahead log (WAL)<internals-wal>`. Each record in "
"the WAL represents a single Tarantool data-change request such as "
":ref:`INSERT<box_space-insert>`, :ref:`UPDATE<box_space-update>` or "
":ref:`DELETE<box_space-delete>`, and is assigned a monotonically growing "
"log sequence number (**LSN**). In essence, Tarantool replication is "
"**row-based**: each data-change request is fully deterministic and "
"operates on a single :ref:`tuple<index-box_tuple>`. However, unlike a "
"classical row-based log, which contains entire copies of the changed "
"rows, Tarantool's WAL contains copies of the requests. For example, for "
"UPDATE requests, Tarantool only stores the primary key of the row and the"
" update operations, to save space."
msgstr ""
"Реплика получает все обновления от мастера, постоянно запрашивая и "
"применяя данные :ref:`журнала упреждающей записи (WAL)<internals-wal>`. "
"Каждая запись в WAL представляет собой отдельный запрос на изменение "
"данных в Tarantool’е, например, :ref:`INSERT<box_space-insert>`, "
":ref:`UPDATE<box_space-update>` или :ref:`DELETE<box_space-delete>`. "
"Такой записи присваивается монотонно возрастающее число, представляющее "
"регистрационный номер в журнале (**LSN**). По сути, репликация в "
"Tarantool’е является **построчной**: каждая команда на изменение данных "
"полностью детерминирована и относится к отдельному :ref:`кортежу<index-"
"box_tuple>`. Однако в отличие от типичного построчного журнала, который "
"содержит копии измененных строк полностью, WAL в Tarantool'е включает в "
"себя копии запросов. Например, для запросов типа UPDATE (обновление) "
"Tarantool сохранит только первичный ключ строки и операции обновления для"
" экономии места."

#: ../doc/book/replication/repl_architecture.rst:28
msgid ""
"Invocations of **stored programs** are not written to the WAL. Instead, "
"records of the actual **data-change requests, performed by the Lua "
"code**, are written to the WAL. This ensures that possible non-"
"determinism of Lua does not cause replication to go out of sync."
msgstr ""
"Вызовы **хранимых процедур** не регистрируются в журнале упреждающей "
"записи. Между тем, события по запросам **изменения фактических данных, "
"которые выполняют Lua-скрипты**, регистрируются в журнале. Таким образом,"
" возможное недетерминированное выполнение Lua гарантированно не приведет "
"к рассинхронизации."

#: ../doc/book/replication/repl_architecture.rst:33
msgid ""
"Data definition operations on **temporary spaces**, such as "
"creating/dropping, adding indexes, truncating, etc., are written to the "
"WAL, since information about temporary spaces is stored in non-temporary "
"system spaces, such as :ref:`box.space._space <box_space-space>`. Data "
"change operations on temporary spaces are not written to the WAL and are "
"not replicated."
msgstr ""
"Операции по определению данных во **временных спейсах**, такие как "
"создание/удаление, добавление индексов, усечение и т.д., регистрируются в"
" журнале, поскольку информация о временных спейсах хранится в постоянных "
"системных спейсах, например :ref:`box.space._space <box_space-space>`. "
"Операции по изменению данных во временных спейсах не регистрируются в "
"журнале и не реплицируются."

#: ../doc/book/replication/repl_architecture.rst:41
msgid ""
"Data change operations on **replication-local** spaces (spaces "
":ref:`created <box_schema-space_create>` with ``is_local`` = true) are "
"written to the WAL but are not replicated."
msgstr ""
"Операции по изменению данных в спейсах с **локальной репликацией** "
"(спейсах, :ref:`созданных <box_schema-space_create>` с параметром "
"``is_local`` = true) не регистрируются в журнале и не реплицируются."

#: ../doc/book/replication/repl_architecture.rst:45
msgid ""
"To create a valid initial state, to which WAL changes can be applied, "
"every instance of a replica set requires a start set of :ref:`checkpoint "
"files <index-box_persistence>`, such as .snap files for memtx and .run "
"files for vinyl. A replica joining an existing replica set, chooses an "
"existing master and automatically downloads the initial state from it. "
"This is called an **initial join**."
msgstr ""
"Чтобы создать подходящее начальное состояние, к которому можно применить "
"изменения из WAL-файла, для каждого экземпляра из набора реплик должен "
"быть исходный набор :ref:`файлов контрольной точки <index-"
"box_persistence>` -- .snap-файлы для memtx и .run-файлы для vinyl. Когда "
"реплика включается в существующий набор реплик, она выбирает "
"существующего мастера и автоматически загружает с него начальное "
"состояние. Это называется **начальным включением**."

#: ../doc/book/replication/repl_architecture.rst:52
msgid ""
"When an entire replica set is bootstrapped for the first time, there is "
"no master which could provide the initial checkpoint. In such a case, "
"replicas connect to each other and elect a master, which then creates the"
" starting set of checkpoint files, and distributes it to all the other "
"replicas. This is called an **automatic bootstrap** of a replica set."
msgstr ""
"При первой настройке целого набора реплик нет мастера, который "
"предоставил бы начальную контрольную точку. В таком случае реплики "
"подключаются друг к другу и выбирают мастера, который затем создает "
"начальный набор файлов контрольной точки и отправляет его всем репликам. "
"Это называется **самонастройкой** набора реплик."

#: ../doc/book/replication/repl_architecture.rst:58
msgid ""
"When a replica contacts a master (there can be many masters) for the "
"first time, it becomes part of a replica set. On subsequent occasions, it"
" should always contact a master in the same replica set. Once connected "
"to the master, the replica requests all changes that happened after the "
"latest local LSN (there can be many LSNs -- each master has its own LSN)."
msgstr ""
"Когда реплика впервые подключается к мастеру (может быть много мастеров),"
" она становится частью набора реплик. В последующих случаях она всегда "
"должна подключаться к мастеру в этом наборе реплик. После подключения к "
"мастеру реплика запрашивает все изменения, произошедшие с момента "
"последнего локального LSN (может быть много LSN -- у каждого мастера свой"
" LSN)."

#: ../doc/book/replication/repl_architecture.rst:64
msgid ""
"Each replica set is identified by a globally unique identifier, called "
"the **replica set UUID**. The identifier is created by the master which "
"creates the very first checkpoint, and is part of the checkpoint file. It"
" is stored in system space :ref:`box.space._schema <box_space-schema>`. "
"For example:"
msgstr ""
"Каждый набор реплик можно определить по глобально-уникальному "
"идентификатору, который называется **UUID набора реплик**. Идентификатор "
"создается мастером во время создания самой первой контрольной точки и "
"является частью файла контрольной точки. Он хранится в системном спейсе "
":ref:`box.space._schema <box_space-schema>`. Пример:"

#: ../doc/book/replication/repl_architecture.rst:69
msgid ""
"tarantool> box.space._schema:select{'cluster'}\n"
"---\n"
"- - ['cluster', '6308acb9-9788-42fa-8101-2e0cb9d3c9a0']\n"
"..."
msgstr ""
"tarantool> box.space._schema:select{'cluster'}\n"
"---\n"
"- - ['cluster', '6308acb9-9788-42fa-8101-2e0cb9d3c9a0']\n"
"..."

#: ../doc/book/replication/repl_architecture.rst:78
msgid ""
"Additionally, each instance in a replica set is assigned its own UUID, "
"when it joins the replica set. It is called an **instance UUID** and is a"
" globally unique identifier. The instance UUID is checked to ensure that "
"instances do not join a different replica set, e.g. because of a "
"configuration error. A unique instance identifier is also necessary to "
"apply rows originating from different masters only once, that is, to "
"implement multi-master replication. This is why each row in the write "
"ahead log, in addition to its log sequence number, stores the instance "
"identifier of the instance on which it was created. But using a UUID as "
"such an identifier would take too much space in the write ahead log, thus"
" a shorter integer number is assigned to the instance when it joins a "
"replica set. This number is then used to refer to the instance in the "
"write ahead log. It is called **instance id**. All identifiers are stored"
" in system space :ref:`box.space._cluster <box_space-cluster>`. For "
"example:"
msgstr ""
"Кроме того, каждому экземпляру в наборе реплик присваивается свой UUID, "
"когда он включается в набор реплик. Такой глобально-уникальный "
"идентификатор называется *UUID экземпляра**. UUID экземпляра проверяется,"
" чтобы экземпляры не подключались к различным наборам реплик, например, "
"из-за ошибки конфигурации. Уникальный идентификатор экземпляра также "
"необходим для однократного применения строк от разных мастеров, то есть "
"для многомастерной репликации. Вот почему каждая строка в журнале "
"упреждающей записи, помимо номер записи в журнале, хранит идентификатор "
"экземпляра, где запись была создана. Но использование UUID в качестве "
"такого идентификатора заняло бы слишком много места в журнале упреждающей"
" записи, поэтому экземпляру присваивается целое число при включении в "
"набор реплик. Это число, которое называется **ID экземпляра**, затем "
"используется для ссылок на экземпляр в журнале упреждающей записи. Все "
"идентификаторы хранятся в системном спейсе :ref:`box.space._cluster "
"<box_space-cluster>`. Например:"

#: ../doc/book/replication/repl_architecture.rst:99
msgid ""
"Here the instance ID is ``1`` (unique within the replica set), and the "
"instance UUID is ``88580b5c-4474-43ab-bd2b-2409a9af80d2`` (globally "
"unique)."
msgstr ""
"Здесь ID экземпляра -- ``1`` (уникальный номер в рамках набора реплик), а"
" UUID экземпляра -- ``88580b5c-4474-43ab-bd2b-2409a9af80d2`` (глобально "
"уникальный)."

#: ../doc/book/replication/repl_architecture.rst:102
msgid ""
"Using instance IDs is also handy for tracking the state of the entire "
"replica set. For example, :ref:`box.info.vclock <box_introspection-"
"box_info>` describes the state of replication in regard to each connected"
" peer."
msgstr ""
"Использование идентификаторов экземпляра также полезно для отслеживания "
"состояния всего набора реплик. Например, :ref:`box.info.vclock "
"<box_introspection-box_info>` описывает состояние репликации в отношении "
"каждого подключенного узла."

#: ../doc/book/replication/repl_architecture.rst:106
msgid ""
"tarantool> box.info.vclock\n"
"---\n"
"- {1: 827, 2: 584}\n"
"..."
msgstr ""
"tarantool> box.info.vclock\n"
"---\n"
"- {1: 827, 2: 584}\n"
"..."

#: ../doc/book/replication/repl_architecture.rst:113
msgid ""
"Here ``vclock`` contains log sequence numbers (827 and 584) for instances"
" with instance IDs 1 and 2."
msgstr ""
"Здесь ``vclock`` содержит номера записей в журнале (827 и 584) для "
"экземпляров с идентификаторами экземпляра 1 и 2."

#: ../doc/book/replication/repl_architecture.rst:116
msgid ""
"Starting in Tarantool 1.7.7, it is possible for administrators to assign "
"the instance UUID and the replica set UUID values, rather than let the "
"system generate them -- see the description of the :ref:`replicaset_uuid "
"<cfg_replication-replicaset_uuid>` configuration parameter."
msgstr ""
"Начиная с Tarantool 1.7.7, появилась возможность для администраторов "
"назначать UUID экземпляра и UUID набора реплик вместо сгенерированных "
"системой значений -- см. описание конфигурационного параметра "
":ref:`replicaset_uuid <cfg_replication-replicaset_uuid>`."

#: ../doc/book/replication/repl_architecture.rst:125
msgid "Replication setup"
msgstr "Настройка репликации"

#: ../doc/book/replication/repl_architecture.rst:127
msgid ""
"To enable replication, you need to specify two parameters in a "
"``box.cfg{}`` request:"
msgstr ""
"Чтобы включить репликацию, необходимо указать два параметра в запросе "
"``box.cfg{}``:"

#: ../doc/book/replication/repl_architecture.rst:130
msgid ""
":ref:`replication <cfg_replication-replication>` which defines the "
"replication source(s), and"
msgstr ""
":ref:`replication <cfg_replication-replication>`, который определяет "
"источники репликации, и"

#: ../doc/book/replication/repl_architecture.rst:132
msgid ""
":ref:`read_only <cfg_basic-read_only>` which is ``true`` for a replica "
"and ``false`` for a master."
msgstr ""
":ref:`read_only <cfg_basic-read_only>` со значением ``true`` для реплики "
"и ``false`` для мастера."

#: ../doc/book/replication/repl_architecture.rst:135
msgid ""
"Both these parameters are \"dynamic\". This allows a replica to become a "
"master and vice versa on the fly with the help of a ``box.cfg{}`` "
"request."
msgstr ""
"\"Динамические\" параметры репликации можно менять на лету, что позволяет"
" назначать реплику на роль мастера и наоборот. Для этого используется "
"запрос ``box.cfg{}``."

#: ../doc/book/replication/repl_architecture.rst:138
msgid ""
"Later we will give a detailed example of :ref:`bootstrapping a replica "
"set <replication-bootstrap>`."
msgstr ""
"Далее подробно рассмотрим пример :ref:`настройки набора реплик "
"<replication-bootstrap>`."

#: ../doc/book/replication/repl_architecture.rst:145
msgid "Replication roles: master and replica"
msgstr "Роли в репликации: мастер и реплика"

#: ../doc/book/replication/repl_architecture.rst:147
msgid ""
"The replication role (master or replica) is set by the :ref:`read_only "
"<cfg_basic-read_only>` configuration parameter. The recommended role is "
"\"read_only\" (replica) for all but one instance in the replica set."
msgstr ""
"Конфигурационный параметр :ref:`read_only <cfg_basic-read_only>` "
"определяет роль в репликации (мастер или реплика). Рекомендованная роль "
"для всех экземпляров в наборе реплик, кроме одного -- \"read-only\" "
"(реплика)."

#: ../doc/book/replication/repl_architecture.rst:151
msgid ""
"In a master-replica configuration, every change that happens on the "
"master will be visible on the replicas, but not vice versa."
msgstr ""
"В конфигурации мастер-реплика каждое изменение, сделанное на мастере, "
"будет отображаться на репликах, но не наоборот."

#: ../doc/book/replication/repl_architecture.rst:157
msgid ""
"A simple two-instance replica set with the master on one machine and the "
"replica on a different machine provides two benefits:"
msgstr ""
"Простой набор реплик с двумя экземплярами, один из которых является "
"мастером и расположен на одной машине, а другой -- реплика -- расположен "
"на другой машине, дает два преимущества:"

#: ../doc/book/replication/repl_architecture.rst:160
msgid ""
"**failover**, because if the master goes down then the replica can take "
"over, and"
msgstr ""
"**восстановление после отказа**, поскольку в случае отказа мастера "
"реплика может взять работу на себя, и"

#: ../doc/book/replication/repl_architecture.rst:162
msgid ""
"**load balancing**, because clients can connect to either the master or "
"the replica for read requests."
msgstr ""
"**балансировка нагрузки**, потому что клиенты во время запросов чтения "
"могут подключаться к мастеру или к реплике."

#: ../doc/book/replication/repl_architecture.rst:165
msgid ""
"In a **master-master** configuration (also called \"multi-master\"), "
"every change that happens on either instance will be visible on the other"
" one."
msgstr ""
"В конфигурации **мастер-мастер** (которая также называется "
"\"многомастерной\") каждое изменение на любом экземпляре будет также "
"отображаться на другом."

#: ../doc/book/replication/repl_architecture.rst:171
msgid ""
"The failover benefit in this case is still present, and the load-"
"balancing benefit is enhanced, because any instance can handle both read "
"and write requests. Meanwhile, for multi-master configurations, it is "
"necessary to understand the **replication guarantees** provided by the "
"asynchronous protocol that Tarantool implements."
msgstr ""
"Восстановление после отказа в таком случае также будет преимуществом, а "
"балансировка нагрузки улучшится, поскольку любой экземпляр может "
"обрабатывать запросы и на чтение, и на запись. В то же время, при "
"многомастерной конфигурации необходимо понимать **гарантии репликации**, "
"которые обеспечивает асинхронный протокол, внедренный в Tarantool."

#: ../doc/book/replication/repl_architecture.rst:177
msgid ""
"Tarantool multi-master replication guarantees that each change on each "
"master is propagated to all instances and is applied only once. Changes "
"from the same instance are applied in the same order as on the "
"originating instance. Changes from different instances, however, can be "
"mixed and applied in a different order on different instances. This may "
"lead to replication going out of sync in certain cases."
msgstr ""
"Многомастерная репликация Tarantool'а гарантирует, что каждое изменение "
"на каждом мастере передается на все экземпляры и применяется только один "
"раз. Изменения с одного экземпляра применяются в том же порядке, что и на"
" исходном экземпляре. Однако изменения с разных экземпляров могут "
"смешиваться и применяться в различном порядке на разных экземплярах. В "
"определенных случаях это может привести к рассинхронизации."

#: ../doc/book/replication/repl_architecture.rst:184
msgid ""
"For example, assuming the database is only appended to (i.e. it contains "
"only insertions), a multi-master configuration is safe. If there are also"
" deletions, but it is not mission critical that deletion happens in the "
"same order on all replicas (e.g. the DELETE is used to prune expired "
"data), a master-master configuration is also safe."
msgstr ""
"Например, принимая, что проводятся только операции добавления данных в "
"базу (т.е. она содержит только вставки), многомастерная конфигурация "
"сработает хорошо. Если данные также удаляются, но порядок операций "
"удаления на разных репликах не играет важной роли (например, DELETE "
"используется для отсечения устаревших данных), то конфигурация "
"мастер-мастер также безопасна."

#: ../doc/book/replication/repl_architecture.rst:190
msgid ""
"UPDATE operations, however, can easily go out of sync. For example, "
"assignment and increment are not commutative, and may yield different "
"results if applied in different order on different instances."
msgstr ""
"Однако операции обновления UPDATE могут с легкостью привести к "
"рассинхронизации. Например, операции присваивания и увеличения не "
"обладают коммутативностью и могут привести к различным результатам, если "
"применять их в различном порядке на разных экземплярах."

#: ../doc/book/replication/repl_architecture.rst:194
msgid ""
"More generally, it is only safe to use Tarantool master-master "
"replication if all database changes are **commutative**: the end result "
"does not depend on the order in which the changes are applied. You can "
"start learning more about conflict-free replicated data types `here "
"<https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type>`_."
msgstr ""
"В общем смысле, безопасно использовать репликацию мастер-мастер в "
"Tarantool'е, если все изменения в базе данных являются "
"**коммутативными**: конечный результат не зависит от порядка, в котором "
"применяются изменения. Дополнительную информацию о бесконфликтных типах "
"реплицируемых данных можно получить `здесь <https://en.wikipedia.org/wiki"
"/Conflict-free_replicated_data_type>`_."

#: ../doc/book/replication/repl_architecture.rst:204
msgid "Replication topologies: cascade, ring and full mesh"
msgstr "Топологии репликации: каскадная, кольцевая и полная ячеистая"

#: ../doc/book/replication/repl_architecture.rst:206
msgid ""
"Replication topology is set by the :ref:`replication <cfg_replication-"
"replication>` configuration parameter. The recommended topology is a "
"**full mesh**, because it makes potential failover easy."
msgstr ""
"Топология репликации определяется в конфигурационном параметре "
":ref:`replication <cfg_replication-replication>`. Рекомендована **полная "
"ячеистая** конфигурация, поскольку она облегчает возможное восстановление"
" после сбоя."

#: ../doc/book/replication/repl_architecture.rst:210
msgid ""
"Some database products offer **cascading replication** topologies: "
"creating a replica on a replica. Tarantool does not recommend such setup."
msgstr ""
"Некоторые СУБД предлагают топологии **каскадной репликации**: создание "
"реплики на реплике. Tarantool не рекомендует такие настройки."

#: ../doc/book/replication/repl_architecture.rst:216
msgid ""
"The problem with a cascading replica set is that some instances have no "
"connection to other instances and may not receive changes from them. One "
"essential change that must be propagated across all instances in a "
"replica set is an entry in ``box.space._cluster`` system space with the "
"replica set UUID. Without knowing the replica set UUID, a master refuses "
"to accept connections from such instances when replication topology "
"changes. Here is how this can happen:"
msgstr ""
"Недостаток каскадного набора реплик заключается в том, что некоторые "
"экземпляры не подключаются к другим экземплярам, поэтому не могут "
"получать от них изменения. Одно важное изменение, которое следует "
"передавать на все экземпляры в наборе реплик -- запись в системный спейс "
"``box.space._cluster`` с UUID набора реплик. Не зная UUID набора реплик, "
"мастер отклоняет подключения от таких экземпляров при изменении топологии"
" репликации. Вот как это может произойти:"

#: ../doc/book/replication/repl_architecture.rst:226
msgid ""
"We have a chain of three instances. Instance #1 contains entries for "
"instances #1 and #2 in its ``_cluster`` space. Instances #2 and #3 "
"contain entries for instances #1, #2 and #3 in their ``_cluster`` spaces."
msgstr ""
"У нас есть цепочка из трех экземпляров. Экземпляр №1 содержит записи для "
"экземпляров №1 и №2 в спейсе ``_cluster``. Экземпляры №2 и №3 содержат "
"записи для экземпляров №1, №2 и №3 в своих спейсах ``_cluster``."

#: ../doc/book/replication/repl_architecture.rst:233
msgid ""
"Now instance #2 is faulty. Instance #3 tries connecting to instance #1 as"
" its new master, but the master refuses the connection since it has no "
"entry for instance #3."
msgstr ""
"Теперь экземпляр №2 неисправен. Экземпляр №3 пытается подключиться к "
"экземпляру №1, как к новому мастеру, но мастер отклоняет подключение, "
"поскольку не содержит запись для экземпляра №3."

#: ../doc/book/replication/repl_architecture.rst:237
msgid "**Ring replication** topology is, however, supported:"
msgstr "Тем не менее, **кольцевая топология** поддерживается:"

#: ../doc/book/replication/repl_architecture.rst:242
msgid ""
"So, if you need a cascading topology, you may first create a ring to "
"ensure all instances know each other’s UUID, and then disconnect the "
"chain in the place you desire."
msgstr ""
"Поэтому если необходима каскадная топология, можно первоначально создать "
"кольцо, чтобы все экземпляры знали UUID друг друга, а затем разъединить "
"цепочку в необходимом месте."

#: ../doc/book/replication/repl_architecture.rst:246
msgid ""
"A stock recommendation for a master-master replication topology, however,"
" is a **full mesh**:"
msgstr ""
"Как бы то ни было, для репликации мастер-мастер рекомендуется **полная "
"ячеистая** топология:"

#: ../doc/book/replication/repl_architecture.rst:252
msgid ""
"You then can decide where to locate instances of the mesh -- within the "
"same data center, or spread across a few data centers. Tarantool will "
"automatically ensure that each row is applied only once on each instance."
" To remove a degraded instance from a mesh, simply change the "
"``replication`` configuration parameter."
msgstr ""
"В таком случае можно решить, где расположить экземпляры ячейки -- в том "
"же центре обработки данных или разместить в нескольких центрах. Tarantool"
" будет автоматически следить за тем, что каждая строка применяется "
"однократно на каждом экземпляре. Чтобы удалить экземпляр из ячейки после "
"отказа, просто измените конфигурационный параметр ``replication``."

#: ../doc/book/replication/repl_architecture.rst:257
msgid ""
"This ensures full cluster availability in case of a local failure, e.g. "
"one of the instances failing in one of the data centers, as well as in "
"case of an entire data center failure."
msgstr ""
"Таким образом можно обеспечить доступность всего кластера в случае "
"локального отказа, например отказа одного экземпляра в одном центре "
"обработки данных, а также в случае отказа всего центра обработки данных."

#: ../doc/book/replication/repl_architecture.rst:261
msgid "The maximal number of replicas in a mesh is 32."
msgstr "Максимальное количество реплик в ячейке -- 32."

#: ../doc/book/replication/repl_bootstrap.rst:5
msgid "Bootstrapping a replica set"
msgstr "Настройка набора реплик"

#: ../doc/book/replication/repl_bootstrap.rst:11
msgid "Master-replica bootstrap"
msgstr "Настройка репликации мастер-реплика"

#: ../doc/book/replication/repl_bootstrap.rst:13
msgid ""
"Let us first bootstrap a simple **master-replica** set containing two "
"instances, each located on its own machine. For easier administration, we"
" make the :ref:`instance files <admin-instance_file>` almost identical."
msgstr ""
"Сначала настроим простой набор **мастер-реплика** с двумя экземплярами, "
"каждый из которых находится на отдельном сервере. Для удобства "
"администрирования сделаем :ref:`файлы экземпляров <admin-instance_file>` "
"практически одинаковыми."

#: ../doc/book/replication/repl_bootstrap.rst:20
msgid "Here is an example of the master's instance file:"
msgstr "Ниже пример файла экземпляра для мастера:"

#: ../doc/book/replication/repl_bootstrap.rst:22
msgid ""
"-- instance file for the master\n"
"box.cfg{\n"
"  listen = 3301,\n"
"  replication = {'replicator:password@192.168.0.101:3301',  -- master URI"
"\n"
"                 'replicator:password@192.168.0.102:3301'}, -- replica "
"URI\n"
"  read_only = false\n"
"}\n"
"box.once(\"schema\", function()\n"
"   box.schema.user.create('replicator', {password = 'password'})\n"
"   box.schema.user.grant('replicator', 'replication') -- grant "
"replication role\n"
"   box.schema.space.create(\"test\")\n"
"   box.space.test:create_index(\"primary\")\n"
"   print('box.once executed on master')\n"
"end)"
msgstr ""
"-- файл экземпляра для мастера\n"
"box.cfg{\n"
"  listen = 3301,\n"
"  replication = {'replicator:password@192.168.0.101:3301',  -- URI "
"мастера\n"
"                 'replicator:password@192.168.0.102:3301'}, -- URI "
"реплики\n"
"  read_only = false\n"
"}\n"
"box.once(\"schema\", function()\n"
"  box.schema.user.create('replicator', {password = 'password'})\n"
"  box.schema.user.grant('replicator', 'replication') -- настроить роль "
"для репликации\n"
"  box.schema.space.create(\"test\")\n"
"  box.space.test:create_index(\"primary\")\n"
"  print('box.once executed on master')\n"
"end)"

#: ../doc/book/replication/repl_bootstrap.rst:41
msgid ""
"the ``box.cfg()`` :ref:`listen <cfg_basic-listen>` parameter defines a "
"URI (port 3301 in our example), on which the master can accept "
"connections from replicas."
msgstr ""
"параметр :ref:`listen <cfg_basic-listen>` в ``box.cfg{}`` определяет URI "
"(порт 3301 в нашем примере), на котором мастер может принимать "
"подключения от реплик."

#: ../doc/book/replication/repl_bootstrap.rst:44
msgid ""
"the ``box.cfg()`` :ref:`replication <cfg_replication-replication>` "
"parameter defines the URIs at which all instances in the replica set can "
"accept connections. It includes the replica's URI as well, although the "
"replica is not a replication source right now."
msgstr ""
"параметр :ref:`replication <cfg_replication-replication>` в ``box.cfg{}``"
" определяет URI, на которых все экземпляры в наборе реплик могут "
"принимать подключения. Он включает в себя также URI реплики, хотя реплики"
" в данном случае не является источником репликации."

#: ../doc/book/replication/repl_bootstrap.rst:51
msgid ""
"For security reasons, we recommend that administrators prevent "
"unauthorized replication sources by associating a password with every "
"user that has a replication :ref:`role <authentication-roles>`. That way,"
" the :ref:`URI <index-uri>` for ``replication`` parameter must have the "
"long form ``username:password@host:port``."
msgstr ""
"Для целей безопасности рекомендуем администраторам не допускать "
"репликацию из неавторизованных источников с помощью установки пароля для "
"каждого пользователя, у которого есть :ref:`роль <authentication-roles>` "
"для репликации. Таким образом, :ref:`URI <index-uri>` для параметра "
"``replication``  должен иметь развернутый вид "
"``username:password@host:port``."

#: ../doc/book/replication/repl_bootstrap.rst:57
msgid ""
"the :ref:`read_only = false <cfg_basic-read_only>` parameter setting "
"enables data-change operations on the instance and makes the instance act"
" as a master, not as a replica. *That is the only parameter setting in "
"our instance files that will differ.*"
msgstr ""
"параметр :ref:`read_only = false <cfg_basic-read_only>` разрешает "
"операции по изменению данных на экземпляре и заставляет данный экземпляр "
"работать в качестве мастера, а не реплики. *Это единственное значение "
"параметра, которое отличается в наших файлах экземпляров.*"

#: ../doc/book/replication/repl_bootstrap.rst:61
msgid ""
"the :ref:`box.once() <box-once>` function contains database "
"initialization logic that should be executed only once during the replica"
" set lifetime."
msgstr ""
"функция :ref:`box.once() <box-once>` содержит логику инициализации базы "
"данных, которая должна выполняться однократно в течение срока работы "
"набора реплик."

#: ../doc/book/replication/repl_bootstrap.rst:64
msgid ""
"In this example, we create a space with a primary index, and a user for "
"replication purposes. We also say ``print('box.once executed on "
"master')`` so that it will later be visible on a console whether "
"``box.once()`` was executed."
msgstr ""
"В данном примере создаем спейс с первичным индексом и пользователя для "
"целей репликации. Также выполним команду ``print('box.once executed on "
"master')``, чтобы позднее увидеть в консоли, была ли выполнена функция "
"``box.once()``."

#: ../doc/book/replication/repl_bootstrap.rst:70
msgid ""
"Replication requires privileges. We can grant privileges for accessing "
"spaces directly to the user who will start the instance. However, it is "
"more usual to grant privileges for accessing spaces to a :ref:`role "
"<authentication-roles>`, and then grant the role to the user who will "
"start the replica."
msgstr ""
"Репликация требует настройки прав. Права на доступ к спейсам можно задать"
" напрямую для пользователя, под чьим именем запущен экземпляр. Но обычно "
"права на доступ к спейсам задаются с помощью :ref:`роли <authentication-"
"roles>`, которая затем присваивается пользователю, под чьим именем "
"запущена реплика."

#: ../doc/book/replication/repl_bootstrap.rst:76
msgid ""
"Here we use Tarantool's predefined role named \"replication\" which by "
"default grants \"read\" privileges for all database objects "
"(\"universe\"), and we can change privileges for this role as required."
msgstr ""
"Здесь мы используем предварительно определенную роль Tarantool'а под "
"названием \"replication\", которая по умолчанию предоставляет права на "
"чтение всех объектов в базе данных (\"universe\"), а также сможем "
"настроить необходимые права для этой роли."

#: ../doc/book/replication/repl_bootstrap.rst:80
msgid ""
"In the replica's instance file, we set the ``read_only`` parameter to "
"\"true\", and say ``print('box.once executed on replica')`` so that later"
" it will be visible that ``box.once()`` was not executed more than once. "
"Otherwise the replica's instance file is identical to the master's "
"instance file."
msgstr ""
"В файле экземпляра для реплики устанавливаем значение \"true\" для "
"параметра ``read_only`` и выполняем команду ``print('box.once executed on"
" replica')``, чтобы позднее убедиться, что ``box.once()`` выполняется "
"только однократно. В других отношениях файл экземпляра для реплики "
"совпадает с файлом экземпляра для мастера."

#: ../doc/book/replication/repl_bootstrap.rst:85
msgid ""
"-- instance file for the replica\n"
"box.cfg{\n"
"  listen = 3301,\n"
"  replication = {'replicator:password@192.168.0.101:3301',  -- master URI"
"\n"
"                 'replicator:password@192.168.0.102:3301'}, -- replica "
"URI\n"
"  read_only = true\n"
"}\n"
"box.once(\"schema\", function()\n"
"   box.schema.user.create('replicator', {password = 'password'})\n"
"   box.schema.user.grant('replicator', 'replication') -- grant "
"replication role\n"
"   box.schema.space.create(\"test\")\n"
"   box.space.test:create_index(\"primary\")\n"
"   print('box.once executed on replica')\n"
"end)"
msgstr ""
"-- файл экземпляра для реплики\n"
"box.cfg{\n"
"  listen = 3301,\n"
"  replication = {'replicator:password@192.168.0.101:3301',  -- URI "
"мастера\n"
"                 'replicator:password@192.168.0.102:3301'}, -- URI "
"реплики\n"
"  read_only = true\n"
"}\n"
"box.once(\"schema\", function()\n"
"  box.schema.user.create('replicator', {password = 'password'})\n"
"  box.schema.user.grant('replicator', 'replication') -- настроить роль "
"для репликации\n"
"  box.schema.space.create(\"test\")\n"
"  box.space.test:create_index(\"primary\")\n"
"  print('box.once executed on replica')\n"
"end)"

#: ../doc/book/replication/repl_bootstrap.rst:104
msgid ""
"The replica does not inherit the master’s configuration parameters, such "
"as those making the :ref:`checkpoint daemon <book_cfg_checkpoint_daemon>`"
" run on the master. To get the same behavior, set the relevant parameters"
" explicitly so that they are the same on both master and replica."
msgstr ""
"Реплика не берет конфигурационные параметры с мастера, например настройки"
" запуска :ref:`фоновой программы для работы с контрольными точками "
"<book_cfg_checkpoint_daemon>` на мастере. Чтобы получить те же настройки "
"на реплике, необходимо задать их явным образом."

#: ../doc/book/replication/repl_bootstrap.rst:109
msgid "Now we can launch the two instances. The master..."
msgstr "Теперь можно запустить два экземпляра. Мастер..."

#: ../doc/book/replication/repl_bootstrap.rst:111
msgid ""
"$ # launching the master\n"
"$ tarantool master.lua\n"
"2017-06-14 14:12:03.847 [18933] main/101/master.lua C> version "
"1.7.4-52-g980d30092\n"
"2017-06-14 14:12:03.848 [18933] main/101/master.lua C> log level 5\n"
"2017-06-14 14:12:03.849 [18933] main/101/master.lua I> mapping 268435456 "
"bytes for tuple arena...\n"
"2017-06-14 14:12:03.859 [18933] iproto/101/main I> binary: bound to "
"[::]:3301\n"
"2017-06-14 14:12:03.861 [18933] main/105/applier/replicator@192.168.0. I>"
" can't connect to master\n"
"2017-06-14 14:12:03.861 [18933] main/105/applier/replicator@192.168.0. "
"coio.cc:105 !> SystemError connect, called on fd 14, aka "
"192.168.0.102:56736: Connection refused\n"
"2017-06-14 14:12:03.861 [18933] main/105/applier/replicator@192.168.0. I>"
" will retry every 1 second\n"
"2017-06-14 14:12:03.861 [18933] main/104/applier/replicator@192.168.0. I>"
" remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 14:12:19.878 [18933] main/105/applier/replicator@192.168.0. I>"
" remote master is 1.7.4 at 192.168.0.102:3301\n"
"2017-06-14 14:12:19.879 [18933] main/101/master.lua I> initializing an "
"empty data directory\n"
"2017-06-14 14:12:19.908 [18933] snapshot/101/main I> saving snapshot "
"`/var/lib/tarantool/master/00000000000000000000.snap.inprogress'\n"
"2017-06-14 14:12:19.914 [18933] snapshot/101/main I> done\n"
"2017-06-14 14:12:19.914 [18933] main/101/master.lua I> vinyl checkpoint "
"done\n"
"2017-06-14 14:12:19.917 [18933] main/101/master.lua I> ready to accept "
"requests\n"
"2017-06-14 14:12:19.918 [18933] main/105/applier/replicator@192.168.0. I>"
" failed to authenticate\n"
"2017-06-14 14:12:19.918 [18933] main/105/applier/replicator@192.168.0. "
"xrow.cc:431 E> ER_LOADING: Instance bootstrap hasn't finished yet\n"
"box.once executed on master\n"
"2017-06-14 14:12:19.920 [18933] main C> entering the event loop"
msgstr ""
"$ # запуск мастера\n"
"$ tarantool master.lua\n"
"2017-06-14 14:12:03.847 [18933] main/101/master.lua C> version "
"1.7.4-52-g980d30092\n"
"2017-06-14 14:12:03.848 [18933] main/101/master.lua C> log level 5\n"
"2017-06-14 14:12:03.849 [18933] main/101/master.lua I> mapping 268435456 "
"bytes for tuple arena...\n"
"2017-06-14 14:12:03.859 [18933] iproto/101/main I> binary: bound to "
"[::]:3301\n"
"2017-06-14 14:12:03.861 [18933] main/105/applier/replicator@192.168.0. I>"
" can't connect to master\n"
"2017-06-14 14:12:03.861 [18933] main/105/applier/replicator@192.168.0. "
"coio.cc:105 !> SystemError connect, called on fd 14, aka "
"192.168.0.102:56736: Connection refused\n"
"2017-06-14 14:12:03.861 [18933] main/105/applier/replicator@192.168.0. I>"
" will retry every 1 second\n"
"2017-06-14 14:12:03.861 [18933] main/104/applier/replicator@192.168.0. I>"
" remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 14:12:19.878 [18933] main/105/applier/replicator@192.168.0. I>"
" remote master is 1.7.4 at 192.168.0.102:3301\n"
"2017-06-14 14:12:19.879 [18933] main/101/master.lua I> initializing an "
"empty data directory\n"
"2017-06-14 14:12:19.908 [18933] snapshot/101/main I> saving snapshot "
"`/var/lib/tarantool/master/00000000000000000000.snap.inprogress'\n"
"2017-06-14 14:12:19.914 [18933] snapshot/101/main I> done\n"
"2017-06-14 14:12:19.914 [18933] main/101/master.lua I> vinyl checkpoint "
"done\n"
"2017-06-14 14:12:19.917 [18933] main/101/master.lua I> ready to accept "
"requests\n"
"2017-06-14 14:12:19.918 [18933] main/105/applier/replicator@192.168.0. I>"
" failed to authenticate\n"
"2017-06-14 14:12:19.918 [18933] main/105/applier/replicator@192.168.0. "
"xrow.cc:431 E> ER_LOADING: Instance bootstrap hasn't finished yet\n"
"box.once executed on master\n"
"2017-06-14 14:12:19.920 [18933] main C> entering the event loop"

#: ../doc/book/replication/repl_bootstrap.rst:134
msgid ""
"... (the display confirms that ``box.once()`` was executed on the master)"
" -- and the replica:"
msgstr ""
"... (выведенный результат подтверждает, что функция``box.once()`` была "
"выполнена на мастере) -- и реплику:"

#: ../doc/book/replication/repl_bootstrap.rst:136
msgid ""
"$ # launching the replica\n"
"$ tarantool replica.lua\n"
"2017-06-14 14:12:19.486 [18934] main/101/replica.lua C> version "
"1.7.4-52-g980d30092\n"
"2017-06-14 14:12:19.486 [18934] main/101/replica.lua C> log level 5\n"
"2017-06-14 14:12:19.487 [18934] main/101/replica.lua I> mapping 268435456"
" bytes for tuple arena...\n"
"2017-06-14 14:12:19.494 [18934] iproto/101/main I> binary: bound to "
"[::]:3311\n"
"2017-06-14 14:12:19.495 [18934] main/104/applier/replicator@192.168.0. I>"
" remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 14:12:19.495 [18934] main/105/applier/replicator@192.168.0. I>"
" remote master is 1.7.4 at 192.168.0.102:3302\n"
"2017-06-14 14:12:19.496 [18934] main/104/applier/replicator@192.168.0. I>"
" failed to authenticate\n"
"2017-06-14 14:12:19.496 [18934] main/104/applier/replicator@192.168.0. "
"xrow.cc:431 E> ER_LOADING: Instance bootstrap hasn't finished yet"
msgstr ""
"$ # запуск реплики\n"
"$ tarantool replica.lua\n"
"2017-06-14 14:12:19.486 [18934] main/101/replica.lua C> version "
"1.7.4-52-g980d30092\n"
"2017-06-14 14:12:19.486 [18934] main/101/replica.lua C> log level 5\n"
"2017-06-14 14:12:19.487 [18934] main/101/replica.lua I> mapping 268435456"
" bytes for tuple arena...\n"
"2017-06-14 14:12:19.494 [18934] iproto/101/main I> binary: bound to "
"[::]:3311\n"
"2017-06-14 14:12:19.495 [18934] main/104/applier/replicator@192.168.0. I>"
" remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 14:12:19.495 [18934] main/105/applier/replicator@192.168.0. I>"
" remote master is 1.7.4 at 192.168.0.102:3302\n"
"2017-06-14 14:12:19.496 [18934] main/104/applier/replicator@192.168.0. I>"
" failed to authenticate\n"
"2017-06-14 14:12:19.496 [18934] main/104/applier/replicator@192.168.0. "
"xrow.cc:431 E> ER_LOADING: Instance bootstrap hasn't finished yet"

#: ../doc/book/replication/repl_bootstrap.rst:149
msgid ""
"In both logs, there are messages saying that the replica was bootstrapped"
" from the master:"
msgstr ""
"В обоих журналах есть сообщения о том, что реплика получила настройки от "
"мастера:"

#: ../doc/book/replication/repl_bootstrap.rst:151
msgid ""
"$ # bootstrapping the replica (from the master's log)\n"
"<...>\n"
"2017-06-14 14:12:20.503 [18933] main/106/main I> initial data sent.\n"
"2017-06-14 14:12:20.505 [18933] relay/[::ffff:192.168.0.101]:/101/main I>"
" recover from `/var/lib/tarantool/master/00000000000000000000.xlog'\n"
"2017-06-14 14:12:20.505 [18933] main/106/main I> final data sent.\n"
"2017-06-14 14:12:20.522 [18933] relay/[::ffff:192.168.0.101]:/101/main I>"
" recover from `/Users/e.shebunyaeva/work/tarantool-test-"
"repl/master_dir/00000000000000000000.xlog'\n"
"2017-06-14 14:12:20.922 [18933] main/105/applier/replicator@192.168.0. I>"
" authenticated"
msgstr ""
"$ # настройка реплики (из журнала мастера)\n"
"<...>\n"
"2017-06-14 14:12:20.503 [18933] main/106/main I> initial data sent.\n"
"2017-06-14 14:12:20.505 [18933] relay/[::ffff:192.168.0.101]:/101/main I>"
" recover from `/var/lib/tarantool/master/00000000000000000000.xlog'\n"
"2017-06-14 14:12:20.505 [18933] main/106/main I> final data sent.\n"
"2017-06-14 14:12:20.522 [18933] relay/[::ffff:192.168.0.101]:/101/main I>"
" recover from `/Users/e.shebunyaeva/work/tarantool-test-"
"repl/master_dir/00000000000000000000.xlog'\n"
"2017-06-14 14:12:20.922 [18933] main/105/applier/replicator@192.168.0. I>"
" authenticated"

#: ../doc/book/replication/repl_bootstrap.rst:161
msgid ""
"$ # bootstrapping the replica (from the replica's log)\n"
"<...>\n"
"2017-06-14 14:12:20.498 [18934] main/104/applier/replicator@192.168.0. I>"
" authenticated\n"
"2017-06-14 14:12:20.498 [18934] main/101/replica.lua I> bootstrapping "
"replica from 192.168.0.101:3301\n"
"2017-06-14 14:12:20.512 [18934] main/104/applier/replicator@192.168.0. I>"
" initial data received\n"
"2017-06-14 14:12:20.512 [18934] main/104/applier/replicator@192.168.0. I>"
" final data received\n"
"2017-06-14 14:12:20.517 [18934] snapshot/101/main I> saving snapshot "
"`/var/lib/tarantool/replica/00000000000000000005.snap.inprogress'\n"
"2017-06-14 14:12:20.518 [18934] snapshot/101/main I> done\n"
"2017-06-14 14:12:20.519 [18934] main/101/replica.lua I> vinyl checkpoint "
"done\n"
"2017-06-14 14:12:20.520 [18934] main/101/replica.lua I> ready to accept "
"requests\n"
"2017-06-14 14:12:20.520 [18934] main/101/replica.lua I> set 'read_only' "
"configuration option to true\n"
"2017-06-14 14:12:20.520 [18934] main C> entering the event loop"
msgstr ""
"$ # настройка реплики (из журнала реплики)\n"
"<...>\n"
"2017-06-14 14:12:20.498 [18934] main/104/applier/replicator@192.168.0. I>"
" authenticated\n"
"2017-06-14 14:12:20.498 [18934] main/101/replica.lua I> bootstrapping "
"replica from 192.168.0.101:3301\n"
"2017-06-14 14:12:20.512 [18934] main/104/applier/replicator@192.168.0. I>"
" initial data received\n"
"2017-06-14 14:12:20.512 [18934] main/104/applier/replicator@192.168.0. I>"
" final data received\n"
"2017-06-14 14:12:20.517 [18934] snapshot/101/main I> saving snapshot "
"`/var/lib/tarantool/replica/00000000000000000005.snap.inprogress'\n"
"2017-06-14 14:12:20.518 [18934] snapshot/101/main I> done\n"
"2017-06-14 14:12:20.519 [18934] main/101/replica.lua I> vinyl checkpoint "
"done\n"
"2017-06-14 14:12:20.520 [18934] main/101/replica.lua I> ready to accept "
"requests\n"
"2017-06-14 14:12:20.520 [18934] main/101/replica.lua I> set 'read_only' "
"configuration option to true\n"
"2017-06-14 14:12:20.520 [18934] main C> entering the event loop"

#: ../doc/book/replication/repl_bootstrap.rst:176
msgid ""
"Notice that ``box.once()`` was executed only at the master, although we "
"added ``box.once()`` to both instance files."
msgstr ""
"Обратите внимание, что функция ``box.once()`` была выполнена только на "
"мастере, хотя мы добавили ``box.once()`` в оба файла экземпляра."

#: ../doc/book/replication/repl_bootstrap.rst:179
msgid "We could as well launch the replica first:"
msgstr "Также можно было сначала запустить реплику:"

#: ../doc/book/replication/repl_bootstrap.rst:181
msgid ""
"$ # launching the replica\n"
"$ tarantool replica.lua\n"
"2017-06-14 14:35:36.763 [18952] main/101/replica.lua C> version "
"1.7.4-52-g980d30092\n"
"2017-06-14 14:35:36.765 [18952] main/101/replica.lua C> log level 5\n"
"2017-06-14 14:35:36.765 [18952] main/101/replica.lua I> mapping 268435456"
" bytes for tuple arena...\n"
"2017-06-14 14:35:36.772 [18952] iproto/101/main I> binary: bound to "
"[::]:3301\n"
"2017-06-14 14:35:36.772 [18952] main/104/applier/replicator@192.168.0. I>"
" can't connect to master\n"
"2017-06-14 14:35:36.772 [18952] main/104/applier/replicator@192.168.0. "
"coio.cc:105 !> SystemError connect, called on fd 13, aka "
"192.168.0.101:56820: Connection refused\n"
"2017-06-14 14:35:36.772 [18952] main/104/applier/replicator@192.168.0. I>"
" will retry every 1 second\n"
"2017-06-14 14:35:36.772 [18952] main/105/applier/replicator@192.168.0. I>"
" remote master is 1.7.4 at 192.168.0.102:3301"
msgstr ""
"$ # запуск реплики\n"
"$ tarantool replica.lua\n"
"2017-06-14 14:35:36.763 [18952] main/101/replica.lua C> version "
"1.7.4-52-g980d30092\n"
"2017-06-14 14:35:36.765 [18952] main/101/replica.lua C> log level 5\n"
"2017-06-14 14:35:36.765 [18952] main/101/replica.lua I> mapping 268435456"
" bytes for tuple arena...\n"
"2017-06-14 14:35:36.772 [18952] iproto/101/main I> binary: bound to "
"[::]:3301\n"
"2017-06-14 14:35:36.772 [18952] main/104/applier/replicator@192.168.0. I>"
" can't connect to master\n"
"2017-06-14 14:35:36.772 [18952] main/104/applier/replicator@192.168.0. "
"coio.cc:105 !> SystemError connect, called on fd 13, aka "
"192.168.0.101:56820: Connection refused\n"
"2017-06-14 14:35:36.772 [18952] main/104/applier/replicator@192.168.0. I>"
" will retry every 1 second\n"
"2017-06-14 14:35:36.772 [18952] main/105/applier/replicator@192.168.0. I>"
" remote master is 1.7.4 at 192.168.0.102:3301"

#: ../doc/book/replication/repl_bootstrap.rst:194
msgid "... and the master later:"
msgstr "... а затем уже мастера:"

#: ../doc/book/replication/repl_bootstrap.rst:196
msgid ""
"$ # launching the master\n"
"$ tarantool master.lua\n"
"2017-06-14 14:35:43.701 [18953] main/101/master.lua C> version "
"1.7.4-52-g980d30092\n"
"2017-06-14 14:35:43.702 [18953] main/101/master.lua C> log level 5\n"
"2017-06-14 14:35:43.702 [18953] main/101/master.lua I> mapping 268435456 "
"bytes for tuple arena...\n"
"2017-06-14 14:35:43.709 [18953] iproto/101/main I> binary: bound to "
"[::]:3301\n"
"2017-06-14 14:35:43.709 [18953] main/105/applier/replicator@192.168.0. I>"
" remote master is 1.7.4 at 192.168.0.102:3301\n"
"2017-06-14 14:35:43.709 [18953] main/104/applier/replicator@192.168.0. I>"
" remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 14:35:43.709 [18953] main/101/master.lua I> initializing an "
"empty data directory\n"
"2017-06-14 14:35:43.721 [18953] snapshot/101/main I> saving snapshot "
"`/var/lib/tarantool/master/00000000000000000000.snap.inprogress'\n"
"2017-06-14 14:35:43.722 [18953] snapshot/101/main I> done\n"
"2017-06-14 14:35:43.723 [18953] main/101/master.lua I> vinyl checkpoint "
"done\n"
"2017-06-14 14:35:43.723 [18953] main/101/master.lua I> ready to accept "
"requests\n"
"2017-06-14 14:35:43.724 [18953] main/105/applier/replicator@192.168.0. I>"
" failed to authenticate\n"
"2017-06-14 14:35:43.724 [18953] main/105/applier/replicator@192.168.0. "
"xrow.cc:431 E> ER_LOADING: Instance bootstrap hasn't finished yet\n"
"box.once executed on master\n"
"2017-06-14 14:35:43.726 [18953] main C> entering the event loop\n"
"2017-06-14 14:35:43.779 [18953] main/103/main I> initial data sent.\n"
"2017-06-14 14:35:43.780 [18953] relay/[::ffff:192.168.0.101]:/101/main I>"
" recover from `/var/lib/tarantool/master/00000000000000000000.xlog'\n"
"2017-06-14 14:35:43.780 [18953] main/103/main I> final data sent.\n"
"2017-06-14 14:35:43.796 [18953] relay/[::ffff:192.168.0.102]:/101/main I>"
" recover from `/var/lib/tarantool/master/00000000000000000000.xlog'\n"
"2017-06-14 14:35:44.726 [18953] main/105/applier/replicator@192.168.0. I>"
" authenticated"
msgstr ""
"$ # запуск мастера\n"
"$ tarantool master.lua\n"
"2017-06-14 14:35:43.701 [18953] main/101/master.lua C> version "
"1.7.4-52-g980d30092\n"
"2017-06-14 14:35:43.702 [18953] main/101/master.lua C> log level 5\n"
"2017-06-14 14:35:43.702 [18953] main/101/master.lua I> mapping 268435456 "
"bytes for tuple arena...\n"
"2017-06-14 14:35:43.709 [18953] iproto/101/main I> binary: bound to "
"[::]:3301\n"
"2017-06-14 14:35:43.709 [18953] main/105/applier/replicator@192.168.0. I>"
" remote master is 1.7.4 at 192.168.0.102:3301\n"
"2017-06-14 14:35:43.709 [18953] main/104/applier/replicator@192.168.0. I>"
" remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 14:35:43.709 [18953] main/101/master.lua I> initializing an "
"empty data directory\n"
"2017-06-14 14:35:43.721 [18953] snapshot/101/main I> saving snapshot "
"`/var/lib/tarantool/master/00000000000000000000.snap.inprogress'\n"
"2017-06-14 14:35:43.722 [18953] snapshot/101/main I> done\n"
"2017-06-14 14:35:43.723 [18953] main/101/master.lua I> vinyl checkpoint "
"done\n"
"2017-06-14 14:35:43.723 [18953] main/101/master.lua I> ready to accept "
"requests\n"
"2017-06-14 14:35:43.724 [18953] main/105/applier/replicator@192.168.0. I>"
" failed to authenticate\n"
"2017-06-14 14:35:43.724 [18953] main/105/applier/replicator@192.168.0. "
"xrow.cc:431 E> ER_LOADING: Instance bootstrap hasn't finished yet\n"
"box.once executed on master\n"
"2017-06-14 14:35:43.726 [18953] main C> entering the event loop\n"
"2017-06-14 14:35:43.779 [18953] main/103/main I> initial data sent.\n"
"2017-06-14 14:35:43.780 [18953] relay/[::ffff:192.168.0.101]:/101/main I>"
" recover from `/var/lib/tarantool/master/00000000000000000000.xlog'\n"
"2017-06-14 14:35:43.780 [18953] main/103/main I> final data sent.\n"
"2017-06-14 14:35:43.796 [18953] relay/[::ffff:192.168.0.102]:/101/main I>"
" recover from `/var/lib/tarantool/master/00000000000000000000.xlog'\n"
"2017-06-14 14:35:44.726 [18953] main/105/applier/replicator@192.168.0. I>"
" authenticated"

#: ../doc/book/replication/repl_bootstrap.rst:221
msgid ""
"In this case, the replica would wait for the master to become available, "
"so the launch order doesn't matter. Our ``box.once()`` logic would also "
"be executed only once, at the master."
msgstr ""
"В данном случае реплика ожидает доступности мастера, поэтому порядок "
"запуска не имеет значения. Наша функция ``box.once()`` также будет "
"выполняться однократно, только на мастере."

#: ../doc/book/replication/repl_bootstrap.rst:225
msgid ""
"$ # the replica has eventually connected to the master\n"
"$ # and got bootstrapped (from the replica's log)\n"
"2017-06-14 14:35:43.777 [18952] main/104/applier/replicator@192.168.0. I>"
" remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 14:35:43.777 [18952] main/104/applier/replicator@192.168.0. I>"
" authenticated\n"
"2017-06-14 14:35:43.777 [18952] main/101/replica.lua I> bootstrapping "
"replica from 192.168.0.199:3310\n"
"2017-06-14 14:35:43.788 [18952] main/104/applier/replicator@192.168.0. I>"
" initial data received\n"
"2017-06-14 14:35:43.789 [18952] main/104/applier/replicator@192.168.0. I>"
" final data received\n"
"2017-06-14 14:35:43.793 [18952] snapshot/101/main I> saving snapshot "
"`/var/lib/tarantool/replica/00000000000000000005.snap.inprogress'\n"
"2017-06-14 14:35:43.793 [18952] snapshot/101/main I> done\n"
"2017-06-14 14:35:43.795 [18952] main/101/replica.lua I> vinyl checkpoint "
"done\n"
"2017-06-14 14:35:43.795 [18952] main/101/replica.lua I> ready to accept "
"requests\n"
"2017-06-14 14:35:43.795 [18952] main/101/replica.lua I> set 'read_only' "
"configuration option to true\n"
"2017-06-14 14:35:43.795 [18952] main C> entering the event loop"
msgstr ""
"$ # реплика в итоге подключена к мастеру\n"
"$ # и получила настройки (из журнала реплики)\n"
"2017-06-14 14:35:43.777 [18952] main/104/applier/replicator@192.168.0. I>"
" remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 14:35:43.777 [18952] main/104/applier/replicator@192.168.0. I>"
" authenticated\n"
"2017-06-14 14:35:43.777 [18952] main/101/replica.lua I> bootstrapping "
"replica from 192.168.0.199:3310\n"
"2017-06-14 14:35:43.788 [18952] main/104/applier/replicator@192.168.0. I>"
" initial data received\n"
"2017-06-14 14:35:43.789 [18952] main/104/applier/replicator@192.168.0. I>"
" final data received\n"
"2017-06-14 14:35:43.793 [18952] snapshot/101/main I> saving snapshot "
"`/var/lib/tarantool/replica/00000000000000000005.snap.inprogress'\n"
"2017-06-14 14:35:43.793 [18952] snapshot/101/main I> done\n"
"2017-06-14 14:35:43.795 [18952] main/101/replica.lua I> vinyl checkpoint "
"done\n"
"2017-06-14 14:35:43.795 [18952] main/101/replica.lua I> ready to accept "
"requests\n"
"2017-06-14 14:35:43.795 [18952] main/101/replica.lua I> set 'read_only' "
"configuration option to true\n"
"2017-06-14 14:35:43.795 [18952] main C> entering the event loop"

#: ../doc/book/replication/repl_bootstrap.rst:245
msgid "Controlled failover"
msgstr "Контролируемое восстановление после сбоя"

#: ../doc/book/replication/repl_bootstrap.rst:247
msgid ""
"To perform a **controlled failover**, that is, swap the roles of the "
"master and replica, all we need to do is to set ``read_only=true`` at the"
" master, and ``read_only=false`` at the replica. The order of actions is "
"important here. If a system is running in production, we do not want "
"concurrent writes happening both at the replica and the master. Nor do we"
" want the new replica to accept any writes until it has finished fetching"
" all replication data from the old master. To compare replica and master "
"state, we can use :ref:`box.info.signature <box_introspection-box_info>`."
msgstr ""
"Чтобы провести **контролируемое восстановление после сбоя**, то есть "
"поменять роли мастера и реплики, нужно лишь настроить параметры "
"``read_only=true`` на мастере и ``read_only=false`` на реплике. Порядок "
"действий в данном случае имеет значение. Если система принята в "
"эксплуатацию, нам не нужна параллельная запись на реплике и на мастере. "
"Нежелательно также, чтобы новая реплика принимала запись, пока не получит"
" все реплицируемые данные со старого мастера. Чтобы сопоставить состояние"
" реплики и мастера, можно использовать :ref:`box.info.signature "
"<box_introspection-box_info>`."

#: ../doc/book/replication/repl_bootstrap.rst:256
msgid "Set ``read_only=true`` at the master."
msgstr "Настройте ``read_only=true`` на мастере."

#: ../doc/book/replication/repl_bootstrap.rst:258
msgid ""
"# at the master\n"
"tarantool> box.cfg{read_only=true}"
msgstr ""
"# на мастере\n"
"tarantool> box.cfg{read_only=true}"

#: ../doc/book/replication/repl_bootstrap.rst:263
msgid ""
"Record the master’s current position with ``box.info.signature``, "
"containing the sum of all LSNs in the master’s vector clock."
msgstr ""
"Зарегистрируйте текущее состояние мастера с помощью "
"``box.info.signature``, которое содержит общее количество всех LSN в "
"векторных часах мастера."

#: ../doc/book/replication/repl_bootstrap.rst:266
msgid ""
"# at the master\n"
"tarantool> box.info.signature"
msgstr ""
"# на мастере\n"
"tarantool> box.info.signature"

#: ../doc/book/replication/repl_bootstrap.rst:271
msgid "Wait until the replica’s signature is the same as the master’s."
msgstr "Подождите, пока сигнатура реплики не совпадет с сигнатурой мастера."

#: ../doc/book/replication/repl_bootstrap.rst:273
msgid ""
"# at the replica\n"
"tarantool> box.info.signature"
msgstr ""
"# на реплике\n"
"tarantool> box.info.signature"

#: ../doc/book/replication/repl_bootstrap.rst:278
msgid "Set ``read_only=false`` at the replica to enable write operations."
msgstr ""
"Настройте `read_only=false`` на реплике, чтобы запустить операции записи "
"данных."

#: ../doc/book/replication/repl_bootstrap.rst:280
msgid ""
"# at the replica\n"
"tarantool> box.cfg{read_only=false}"
msgstr ""
"# на реплике\n"
"tarantool> box.cfg{read_only=false}"

#: ../doc/book/replication/repl_bootstrap.rst:285
msgid ""
"These four steps ensure that the replica doesn’t accept new writes until "
"it’s done fetching writes from the master."
msgstr ""
"Эти шаги нужны для того, чтобы реплика гарантированно не принимала новые "
"записи, пока не получит данные от мастера."

#: ../doc/book/replication/repl_bootstrap.rst:292
msgid "Master-master bootstrap"
msgstr "Настройка репликации мастер-мастер"

#: ../doc/book/replication/repl_bootstrap.rst:294
msgid ""
"Now let us bootstrap a two-instance **master-master** set. For easier "
"administration, we make master#1 and master#2 instance files fully "
"identical."
msgstr ""
"Теперь настроим набор с двумя экземплярами **мастер-мастер**. Для "
"удобства управления сделаем файлы экземпляра для мастера №1 и мастера №2 "
"практически одинаковыми."

#: ../doc/book/replication/repl_bootstrap.rst:300
msgid ""
"We re-use the master's instance file from the :ref:`master-replica "
"example <replication-master_replica_bootstrap>` above."
msgstr ""
"Переиспользуем файл экземпляра для мастера из вышеописанного "
":ref:`примера мастер-реплика <replication-master_replica_bootstrap>`."

#: ../doc/book/replication/repl_bootstrap.rst:303
msgid ""
"-- instance file for any of the two masters\n"
"box.cfg{\n"
"  listen      = 3301,\n"
"  replication = {'replicator:password@192.168.0.101:3301',  -- master1 "
"URI\n"
"                 'replicator:password@192.168.0.102:3301'}, -- master2 "
"URI\n"
"  read_only   = false\n"
"}\n"
"box.once(\"schema\", function()\n"
"   box.schema.user.create('replicator', {password = 'password'})\n"
"   box.schema.user.grant('replicator', 'replication') -- grant "
"replication role\n"
"   box.schema.space.create(\"test\")\n"
"   box.space.test:create_index(\"primary\")\n"
"   print('box.once executed on master #1')\n"
"end)"
msgstr ""
"-- файл экземпляра для любого из двух мастеров\n"
"  box.cfg{\n"
"  listen      = 3301,\n"
"  replication = {'replicator:password@192.168.0.101:3301',  -- URI "
"мастера 1\n"
"                 'replicator:password@192.168.0.102:3301'}, -- URI "
"мастера 2\n"
"  read_only   = false\n"
"}\n"
"box.once(\"schema\", function()\n"
"  box.schema.user.create('replicator', {password = 'password'})\n"
"  box.schema.user.grant('replicator', 'replication') -- настроить роль "
"для репликации\n"
"  box.schema.space.create(\"test\")\n"
"  box.space.test:create_index(\"primary\")\n"
"  print('box.once executed on master #1')\n"
"end)"

#: ../doc/book/replication/repl_bootstrap.rst:320
msgid ""
"In the :ref:`replication <cfg_replication-replication>` parameter, we "
"define the URIs of both masters in the replica set and say "
"``print('box.once executed on master #1')`` so it will be clear when and "
"where the ``box.once()`` logic is executed."
msgstr ""
"В параметре :ref:`replication <cfg_replication-replication>` определим "
"URI обоих мастеров в наборе реплик и выполним команду ``print('box.once "
"executed on master #1')``, чтобы увидеть, когда и где будет выполнена "
"логика функции ``box.once()``."

#: ../doc/book/replication/repl_bootstrap.rst:325
msgid ""
"Now we can launch the two masters. Again, the launch order doesn't "
"matter. The ``box.once()`` logic will also be executed only once, at the "
"master which is elected as the replica set :ref:`leader <replication-"
"leader>` at bootstrap."
msgstr ""
"Теперь можно запустить оба мастера. Повторимся, что порядок запуска не "
"имеет значения. Логика ``box.once()`` также будет выполняться лишь "
"однократно на мастере, который будет выбран лидером (:ref:`leader "
"<replication-leader>`) в наборе реплик при настройке."

#: ../doc/book/replication/repl_bootstrap.rst:329
msgid ""
"$ # launching master #1\n"
"$ tarantool master1.lua\n"
"2017-06-14 15:39:03.062 [47021] main/101/master1.lua C> version "
"1.7.4-52-g980d30092\n"
"2017-06-14 15:39:03.062 [47021] main/101/master1.lua C> log level 5\n"
"2017-06-14 15:39:03.063 [47021] main/101/master1.lua I> mapping 268435456"
" bytes for tuple arena...\n"
"2017-06-14 15:39:03.065 [47021] iproto/101/main I> binary: bound to "
"[::]:3301\n"
"2017-06-14 15:39:03.065 [47021] main/105/applier/replicator@192.168.0.10 "
"I> can't connect to master\n"
"2017-06-14 15:39:03.065 [47021] main/105/applier/replicator@192.168.0.10 "
"coio.cc:107 !> SystemError connect, called on fd 14, aka "
"192.168.0.102:57110: Connection refused\n"
"2017-06-14 15:39:03.065 [47021] main/105/applier/replicator@192.168.0.10 "
"I> will retry every 1 second\n"
"2017-06-14 15:39:03.065 [47021] main/104/applier/replicator@192.168.0.10 "
"I> remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 15:39:08.070 [47021] main/105/applier/replicator@192.168.0.10 "
"I> remote master is 1.7.4 at 192.168.0.102:3301\n"
"2017-06-14 15:39:08.071 [47021] main/105/applier/replicator@192.168.0.10 "
"I> authenticated\n"
"2017-06-14 15:39:08.071 [47021] main/101/master1.lua I> bootstrapping "
"replica from 192.168.0.102:3301\n"
"2017-06-14 15:39:08.073 [47021] main/105/applier/replicator@192.168.0.10 "
"I> initial data received\n"
"2017-06-14 15:39:08.074 [47021] main/105/applier/replicator@192.168.0.10 "
"I> final data received\n"
"2017-06-14 15:39:08.074 [47021] snapshot/101/main I> saving snapshot "
"`/Users/e.shebunyaeva/work/tarantool-test-"
"repl/master1_dir/00000000000000000008.snap.inprogress'\n"
"2017-06-14 15:39:08.074 [47021] snapshot/101/main I> done\n"
"2017-06-14 15:39:08.076 [47021] main/101/master1.lua I> vinyl checkpoint "
"done\n"
"2017-06-14 15:39:08.076 [47021] main/101/master1.lua I> ready to accept "
"requests\n"
"box.once executed on master #1\n"
"2017-06-14 15:39:08.077 [47021] main C> entering the event loop"
msgstr ""
"$ # запуск мастера №1\n"
"$ tarantool master1.lua\n"
"2017-06-14 15:39:03.062 [47021] main/101/master1.lua C> version "
"1.7.4-52-g980d30092\n"
"2017-06-14 15:39:03.062 [47021] main/101/master1.lua C> log level 5\n"
"2017-06-14 15:39:03.063 [47021] main/101/master1.lua I> mapping 268435456"
" bytes for tuple arena...\n"
"2017-06-14 15:39:03.065 [47021] iproto/101/main I> binary: bound to "
"[::]:3301\n"
"2017-06-14 15:39:03.065 [47021] main/105/applier/replicator@192.168.0.10 "
"I> can't connect to master\n"
"2017-06-14 15:39:03.065 [47021] main/105/applier/replicator@192.168.0.10 "
"coio.cc:107 !> SystemError connect, called on fd 14, aka "
"192.168.0.102:57110: Connection refused\n"
"2017-06-14 15:39:03.065 [47021] main/105/applier/replicator@192.168.0.10 "
"I> will retry every 1 second\n"
"2017-06-14 15:39:03.065 [47021] main/104/applier/replicator@192.168.0.10 "
"I> remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 15:39:08.070 [47021] main/105/applier/replicator@192.168.0.10 "
"I> remote master is 1.7.4 at 192.168.0.102:3301\n"
"2017-06-14 15:39:08.071 [47021] main/105/applier/replicator@192.168.0.10 "
"I> authenticated\n"
"2017-06-14 15:39:08.071 [47021] main/101/master1.lua I> bootstrapping "
"replica from 192.168.0.102:3301\n"
"2017-06-14 15:39:08.073 [47021] main/105/applier/replicator@192.168.0.10 "
"I> initial data received\n"
"2017-06-14 15:39:08.074 [47021] main/105/applier/replicator@192.168.0.10 "
"I> final data received\n"
"2017-06-14 15:39:08.074 [47021] snapshot/101/main I> saving snapshot "
"`/Users/e.shebunyaeva/work/tarantool-test-"
"repl/master1_dir/00000000000000000008.snap.inprogress'\n"
"2017-06-14 15:39:08.074 [47021] snapshot/101/main I> done\n"
"2017-06-14 15:39:08.076 [47021] main/101/master1.lua I> vinyl checkpoint "
"done\n"
"2017-06-14 15:39:08.076 [47021] main/101/master1.lua I> ready to accept "
"requests\n"
"box.once executed on master #1\n"
"2017-06-14 15:39:08.077 [47021] main C> entering the event loop"

#: ../doc/book/replication/repl_bootstrap.rst:353
msgid ""
"$ # launching master #2\n"
"$ tarantool master2.lua\n"
"2017-06-14 15:39:07.452 [47022] main/101/master2.lua C> version "
"1.7.4-52-g980d30092\n"
"2017-06-14 15:39:07.453 [47022] main/101/master2.lua C> log level 5\n"
"2017-06-14 15:39:07.453 [47022] main/101/master2.lua I> mapping 268435456"
" bytes for tuple arena...\n"
"2017-06-14 15:39:07.455 [47022] iproto/101/main I> binary: bound to "
"[::]:3301\n"
"2017-06-14 15:39:07.455 [47022] main/104/applier/replicator@192.168.0.19 "
"I> remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 15:39:07.455 [47022] main/105/applier/replicator@192.168.0.10 "
"I> remote master is 1.7.4 at 192.168.0.102:3301\n"
"2017-06-14 15:39:07.455 [47022] main/101/master2.lua I> initializing an "
"empty data directory\n"
"2017-06-14 15:39:07.457 [47022] snapshot/101/main I> saving snapshot "
"`/Users/e.shebunyaeva/work/tarantool-test-"
"repl/master2_dir/00000000000000000000.snap.inprogress'\n"
"2017-06-14 15:39:07.457 [47022] snapshot/101/main I> done\n"
"2017-06-14 15:39:07.458 [47022] main/101/master2.lua I> vinyl checkpoint "
"done\n"
"2017-06-14 15:39:07.459 [47022] main/101/master2.lua I> ready to accept "
"requests\n"
"2017-06-14 15:39:07.460 [47022] main C> entering the event loop\n"
"2017-06-14 15:39:08.072 [47022] main/103/main I> initial data sent.\n"
"2017-06-14 15:39:08.073 [47022] relay/[::ffff:192.168.0.102]:/101/main I>"
" recover from `/Users/e.shebunyaeva/work/tarantool-test-"
"repl/master2_dir/00000000000000000000.xlog'\n"
"2017-06-14 15:39:08.073 [47022] main/103/main I> final data sent.\n"
"2017-06-14 15:39:08.077 [47022] relay/[::ffff:192.168.0.102]:/101/main I>"
" recover from `/Users/e.shebunyaeva/work/tarantool-test-"
"repl/master2_dir/00000000000000000000.xlog'\n"
"2017-06-14 15:39:08.461 [47022] main/104/applier/replicator@192.168.0.10 "
"I> authenticated"
msgstr ""
"$ # запуск мастера №2\n"
"$ tarantool master2.lua\n"
"2017-06-14 15:39:07.452 [47022] main/101/master2.lua C> version "
"1.7.4-52-g980d30092\n"
"2017-06-14 15:39:07.453 [47022] main/101/master2.lua C> log level 5\n"
"2017-06-14 15:39:07.453 [47022] main/101/master2.lua I> mapping 268435456"
" bytes for tuple arena...\n"
"2017-06-14 15:39:07.455 [47022] iproto/101/main I> binary: bound to "
"[::]:3301\n"
"2017-06-14 15:39:07.455 [47022] main/104/applier/replicator@192.168.0.19 "
"I> remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 15:39:07.455 [47022] main/105/applier/replicator@192.168.0.10 "
"I> remote master is 1.7.4 at 192.168.0.102:3301\n"
"2017-06-14 15:39:07.455 [47022] main/101/master2.lua I> initializing an "
"empty data directory\n"
"2017-06-14 15:39:07.457 [47022] snapshot/101/main I> saving snapshot "
"`/Users/e.shebunyaeva/work/tarantool-test-"
"repl/master2_dir/00000000000000000000.snap.inprogress'\n"
"2017-06-14 15:39:07.457 [47022] snapshot/101/main I> done\n"
"2017-06-14 15:39:07.458 [47022] main/101/master2.lua I> vinyl checkpoint "
"done\n"
"2017-06-14 15:39:07.459 [47022] main/101/master2.lua I> ready to accept "
"requests\n"
"2017-06-14 15:39:07.460 [47022] main C> entering the event loop\n"
"2017-06-14 15:39:08.072 [47022] main/103/main I> initial data sent.\n"
"2017-06-14 15:39:08.073 [47022] relay/[::ffff:192.168.0.102]:/101/main I>"
" recover from `/Users/e.shebunyaeva/work/tarantool-test-"
"repl/master2_dir/00000000000000000000.xlog'\n"
"2017-06-14 15:39:08.073 [47022] main/103/main I> final data sent.\n"
"2017-06-14 15:39:08.077 [47022] relay/[::ffff:192.168.0.102]:/101/main I>"
" recover from `/Users/e.shebunyaeva/work/tarantool-test-"
"repl/master2_dir/00000000000000000000.xlog'\n"
"2017-06-14 15:39:08.461 [47022] main/104/applier/replicator@192.168.0.10 "
"I> authenticated"

#: ../doc/book/replication/repl_duplicates.rst:5
msgid "Preventing duplicate actions"
msgstr "Предотвращение дублирующихся действий"

#: ../doc/book/replication/repl_duplicates.rst:7
msgid ""
"Tarantool guarantees that every update is applied only once on every "
"replica. However, due to the asynchronous nature of replication, the "
"order of updates is not guaranteed. We now analyze this problem with more"
" details, provide examples of replication going out of sync, and suggest "
"solutions."
msgstr ""
"Tarantool гарантирует, что все обновления применяются однократно на "
"каждой реплике. Однако, поскольку репликация носит асинхронный характер, "
"порядок обновлений не гарантируется. Сейчас мы проанализируем данную "
"проблему более подробно с примерами рассинхронизации репликации и "
"предложим соответствующие решения."

#: ../doc/book/replication/repl_duplicates.rst:16
msgid "Replication stops"
msgstr "Остановка репликации"

#: ../doc/book/replication/repl_duplicates.rst:18
msgid ""
"In a replica set of two masters, suppose master #1 tries to do something "
"that master #2 has already done. For example, try to insert a tuple with "
"the same unique key:"
msgstr ""
"Предположим, что в наборе реплик с двумя мастерами мастер №1 пытается "
"сделать что-то, что уже было сделано мастером №2. Например, попробуйте "
"вставить кортеж с одинаковым уникальным ключом:"

#: ../doc/book/replication/repl_duplicates.rst:22
msgid "tarantool> box.space.tester:insert{1, 'data'}"
msgstr "tarantool> box.space.tester:insert{1, 'data'}"

#: ../doc/book/replication/repl_duplicates.rst:26
msgid ""
"This would cause an error saying ``Duplicate key exists in unique index "
"'primary' in space 'tester'`` and the replication would be stopped. (This"
" is the behavior when the :ref:`replication_skip_conflict "
"<cfg_replication-replication_skip_conflict>` configuration parameter has "
"its default recommended value, ``false``.)"
msgstr ""
"Это вызовет сообщение об ошибке дубликата ключа (``Duplicate key exists "
"in unique index 'primary' in space 'tester'``), и репликация остановится."
" Такое поведение системы обеспечивается использованием рекомендуемого "
"значения ``false`` (по умолчанию) для конфигурационного параметра "
":ref:`replication_skip_conflict <cfg_replication-"
"replication_skip_conflict>`."

#: ../doc/book/replication/repl_duplicates.rst:32
msgid ""
"$ # error messages from master #1\n"
"2017-06-26 21:17:03.233 [30444] main/104/applier/rep_user@100.96.166.1 I>"
" can't read row\n"
"2017-06-26 21:17:03.233 [30444] main/104/applier/rep_user@100.96.166.1 "
"memtx_hash.cc:226 E> ER_TUPLE_FOUND:\n"
"Duplicate key exists in unique index 'primary' in space 'tester'\n"
"2017-06-26 21:17:03.233 [30444] relay/[::ffff:100.96.166.178]/101/main I>"
" the replica has closed its socket, exiting\n"
"2017-06-26 21:17:03.233 [30444] relay/[::ffff:100.96.166.178]/101/main C>"
" exiting the relay loop\n"
"\n"
"$ # error messages from master #2\n"
"2017-06-26 21:17:03.233 [30445] main/104/applier/rep_user@100.96.166.1 I>"
" can't read row\n"
"2017-06-26 21:17:03.233 [30445] main/104/applier/rep_user@100.96.166.1 "
"memtx_hash.cc:226 E> ER_TUPLE_FOUND:\n"
"Duplicate key exists in unique index 'primary' in space 'tester'\n"
"2017-06-26 21:17:03.234 [30445] relay/[::ffff:100.96.166.178]/101/main I>"
" the replica has closed its socket, exiting\n"
"2017-06-26 21:17:03.234 [30445] relay/[::ffff:100.96.166.178]/101/main C>"
" exiting the relay loop"
msgstr ""
"$ # сообщения об ошибках от мастера №1\n"
"2017-06-26 21:17:03.233 [30444] main/104/applier/rep_user@100.96.166.1 I>"
" can't read row\n"
"2017-06-26 21:17:03.233 [30444] main/104/applier/rep_user@100.96.166.1 "
"memtx_hash.cc:226 E> ER_TUPLE_FOUND:\n"
"Duplicate key exists in unique index 'primary' in space 'tester'\n"
"2017-06-26 21:17:03.233 [30444] relay/[::ffff:100.96.166.178]/101/main I>"
" the replica has closed its socket, exiting\n"
"2017-06-26 21:17:03.233 [30444] relay/[::ffff:100.96.166.178]/101/main C>"
" exiting the relay loop\n"
"\n"
"$ # сообщения об ошибках от мастера №2\n"
"2017-06-26 21:17:03.233 [30445] main/104/applier/rep_user@100.96.166.1 I>"
" can't read row\n"
"2017-06-26 21:17:03.233 [30445] main/104/applier/rep_user@100.96.166.1 "
"memtx_hash.cc:226 E> ER_TUPLE_FOUND:\n"
"Duplicate key exists in unique index 'primary' in space 'tester'\n"
"2017-06-26 21:17:03.234 [30445] relay/[::ffff:100.96.166.178]/101/main I>"
" the replica has closed its socket, exiting\n"
"2017-06-26 21:17:03.234 [30445] relay/[::ffff:100.96.166.178]/101/main C>"
" exiting the relay loop"

#: ../doc/book/replication/repl_duplicates.rst:48
msgid ""
"If we check replication statuses with ``box.info``, we will see that "
"replication at master #1 is stopped (``1.upstream.status = stopped``). "
"Additionally, no data is replicated from that master (section "
"``1.downstream`` is missing in the report), because the downstream has "
"encountered the same error:"
msgstr ""
"Если мы проверим статус репликации с помощью ``box.info``, то увидим, что"
" репликация на мастере №1 остановлена (``1.upstream.status = stopped``). "
"Кроме того, данные с этого мастера не реплицируются (группа "
"``1.downstream`` отсутствует в отчете), поскольку встречается та же "
"ошибка:"

#: ../doc/book/replication/repl_duplicates.rst:53
msgid ""
"# replication statuses (report from master #3)\n"
"tarantool> box.info\n"
"---\n"
"- version: 1.7.4-52-g980d30092\n"
"  id: 3\n"
"  ro: false\n"
"  vclock: {1: 9, 2: 1000000, 3: 3}\n"
"  uptime: 557\n"
"  lsn: 3\n"
"  vinyl: []\n"
"  cluster:\n"
"    uuid: 34d13b1a-f851-45bb-8f57-57489d3b3c8b\n"
"  pid: 30445\n"
"  status: running\n"
"  signature: 1000012\n"
"  replication:\n"
"    1:\n"
"      id: 1\n"
"      uuid: 7ab6dee7-dc0f-4477-af2b-0e63452573cf\n"
"      lsn: 9\n"
"      upstream:\n"
"        peer: replicator@192.168.0.101:3301\n"
"        lag: 0.00050592422485352\n"
"        status: stopped\n"
"        idle: 445.8626639843\n"
"        message: Duplicate key exists in unique index 'primary' in space "
"'tester'\n"
"    2:\n"
"      id: 2\n"
"      uuid: 9afbe2d9-db84-4d05-9a7b-e0cbbf861e28\n"
"      lsn: 1000000\n"
"      upstream:\n"
"        status: follow\n"
"        idle: 201.99915885925\n"
"        peer: replicator@192.168.0.102:3301\n"
"        lag: 0.0015020370483398\n"
"      downstream:\n"
"        vclock: {1: 8, 2: 1000000, 3: 3}\n"
"    3:\n"
"      id: 3\n"
"      uuid: e826a667-eed7-48d5-a290-64299b159571\n"
"      lsn: 3\n"
"  uuid: e826a667-eed7-48d5-a290-64299b159571\n"
"..."
msgstr ""
"# статусы репликации (отчет от мастера №3)\n"
"tarantool> box.info\n"
"---\n"
"- version: 1.7.4-52-g980d30092\n"
"  id: 3\n"
"  ro: false\n"
"  vclock: {1: 9, 2: 1000000, 3: 3}\n"
"  uptime: 557\n"
"  lsn: 3\n"
"  vinyl: []\n"
"  cluster:\n"
"    uuid: 34d13b1a-f851-45bb-8f57-57489d3b3c8b\n"
"  pid: 30445\n"
"  status: running\n"
"  signature: 1000012\n"
"  replication:\n"
"    1:\n"
"      id: 1\n"
"      uuid: 7ab6dee7-dc0f-4477-af2b-0e63452573cf\n"
"      lsn: 9\n"
"      upstream:\n"
"        peer: replicator@192.168.0.101:3301\n"
"        lag: 0.00050592422485352\n"
"        status: stopped\n"
"        idle: 445.8626639843\n"
"        message: Duplicate key exists in unique index 'primary' in space "
"'tester'\n"
"    2:\n"
"      id: 2\n"
"      uuid: 9afbe2d9-db84-4d05-9a7b-e0cbbf861e28\n"
"      lsn: 1000000\n"
"      upstream:\n"
"        status: follow\n"
"        idle: 201.99915885925\n"
"        peer: replicator@192.168.0.102:3301\n"
"        lag: 0.0015020370483398\n"
"      downstream:\n"
"        vclock: {1: 8, 2: 1000000, 3: 3}\n"
"    3:\n"
"      id: 3\n"
"      uuid: e826a667-eed7-48d5-a290-64299b159571\n"
"      lsn: 3\n"
"  uuid: e826a667-eed7-48d5-a290-64299b159571\n"
"..."

#: ../doc/book/replication/repl_duplicates.rst:99
msgid "When replication is later manually resumed:"
msgstr "Когда позднее репликация возобновлена вручную:"

#: ../doc/book/replication/repl_duplicates.rst:101
msgid ""
"# resuming stopped replication (at all masters)\n"
"tarantool> original_value = box.cfg.replication\n"
"tarantool> box.cfg{replication={}}\n"
"tarantool> box.cfg{replication=original_value}"
msgstr ""
"# возобновление остановленной репликации (на всех мастерах)\n"
"tarantool> original_value = box.cfg.replication\n"
"tarantool> box.cfg{replication={}}\n"
"tarantool> box.cfg{replication=original_value}"

#: ../doc/book/replication/repl_duplicates.rst:108
msgid "... the faulty row in the write-ahead-log files is skipped."
msgstr "... запись с ошибкой в журнале упреждающей записи пропущена."

#: ../doc/book/replication/repl_duplicates.rst:114
msgid "Replication runs out of sync"
msgstr "Рассинхронизация репликации"

#: ../doc/book/replication/repl_duplicates.rst:116
msgid ""
"In a master-master cluster of two instances, suppose we make the "
"following operation:"
msgstr ""
"Предположим, что мы выполняем следующую операцию в кластере из двух "
"экземпляров с конфигурацией мастер-мастер:"

#: ../doc/book/replication/repl_duplicates.rst:119
msgid "tarantool> box.space.tester:upsert({1}, {{'=', 2, box.info.uuid}})"
msgstr "tarantool> box.space.tester:upsert({1}, {{'=', 2, box.info.uuid}})"

#: ../doc/book/replication/repl_duplicates.rst:123
msgid "When this operation is applied on both instances in the replica set:"
msgstr "Когда эта операция применяется на обоих экземплярах в наборе реплик:"

#: ../doc/book/replication/repl_duplicates.rst:125
msgid ""
"# at master #1\n"
"tarantool> box.space.tester:upsert({1}, {{'=', 2, box.info.uuid}})\n"
"# at master #2\n"
"tarantool> box.space.tester:upsert({1}, {{'=', 2, box.info.uuid}})"
msgstr ""
"# на мастере №1\n"
"tarantool> box.space.tester:upsert({1}, {{'=', 2, box.info.uuid}})\n"
"# на мастере №2\n"
"tarantool> box.space.tester:upsert({1}, {{'=', 2, box.info.uuid}})"

#: ../doc/book/replication/repl_duplicates.rst:132
msgid ""
"... we can have the following results, depending on the order of "
"execution:"
msgstr "... можно получить следующие результаты в зависимости порядка выполнения:"

#: ../doc/book/replication/repl_duplicates.rst:134
msgid "each master’s row contains the UUID from master #1,"
msgstr "каждая строка мастера содержит UUID из мастера №1,"

#: ../doc/book/replication/repl_duplicates.rst:135
msgid "each master’s row contains the UUID from master #2,"
msgstr "каждая строка мастера содержит UUID из мастера №2,"

#: ../doc/book/replication/repl_duplicates.rst:136
msgid "master #1 has the UUID of master #2, and vice versa."
msgstr "у мастера №1 UUID мастера №2, и наоборот."

#: ../doc/book/replication/repl_duplicates.rst:142
msgid "Commutative changes"
msgstr "Коммутативные изменения"

#: ../doc/book/replication/repl_duplicates.rst:144
msgid ""
"The cases described in the previous paragraphs represent examples of "
"**non-commutative** operations, i.e. operations whose result depends on "
"the execution order. On the contrary, for **commutative operations**, the"
" execution order does not matter."
msgstr ""
"Случаи, описанные в предыдущих абзацах, представляют собой примеры "
"**некоммутативных** операций, т.е. операций, результат которых зависит от"
" порядка их выполнения. Для **коммутативных операций** порядок выполнения"
" значения не имеет."

#: ../doc/book/replication/repl_duplicates.rst:149
msgid "Consider for example the following command:"
msgstr "Рассмотрим, например, следующую команду:"

#: ../doc/book/replication/repl_duplicates.rst:151
msgid "tarantool> box.space.tester:upsert{{1, 0}, {{'+', 2, 1)}"
msgstr "tarantool> box.space.tester:upsert{{1, 0}, {{'+', 2, 1)}"

#: ../doc/book/replication/repl_duplicates.rst:155
msgid ""
"This operation is commutative: we get the same result no matter in which "
"order the update is applied on the other masters."
msgstr ""
"Эта операция коммутативна: получаем одинаковый результат, независимо от "
"порядка, в котором обновление применяется на других мастерах."

#: ../doc/book/replication/repl_monitoring.rst:5
msgid "Monitoring a replica set"
msgstr "Мониторинг набора реплик"

#: ../doc/book/replication/repl_monitoring.rst:7
msgid ""
"To learn what instances belong in the replica set, and obtain statistics "
"for all these instances, issue a :ref:`box.info.replication "
"<box_info_replication>` request:"
msgstr ""
"Чтобы узнать, какие экземпляры входят в набор реплик и получить "
"статистику по всем этим экземплярам, передайте запрос "
":ref:`box.info.replication <box_info_replication>`:"

#: ../doc/book/replication/repl_monitoring.rst:10
msgid ""
"tarantool> box.info.replication\n"
"---\n"
"  replication:\n"
"    1:\n"
"      id: 1\n"
"      uuid: b8a7db60-745f-41b3-bf68-5fcce7a1e019\n"
"      lsn: 88\n"
"    2:\n"
"      id: 2\n"
"      uuid: cd3c7da2-a638-4c5d-ae63-e7767c3a6896\n"
"      lsn: 31\n"
"      upstream:\n"
"        status: follow\n"
"        idle: 43.187747001648\n"
"        peer: replicator@192.168.0.102:3301\n"
"        lag: 0\n"
"      downstream:\n"
"        vclock: {1: 31}\n"
"    3:\n"
"      id: 3\n"
"      uuid: e38ef895-5804-43b9-81ac-9f2cd872b9c4\n"
"      lsn: 54\n"
"      upstream:\n"
"        status: follow\n"
"        idle: 43.187621831894\n"
"        peer: replicator@192.168.0.103:3301\n"
"        lag: 2\n"
"      downstream:\n"
"        vclock: {1: 54}\n"
"..."
msgstr ""
"tarantool> box.info.replication\n"
"---\n"
"  replication:\n"
"    1:\n"
"      id: 1\n"
"      uuid: b8a7db60-745f-41b3-bf68-5fcce7a1e019\n"
"      lsn: 88\n"
"    2:\n"
"      id: 2\n"
"      uuid: cd3c7da2-a638-4c5d-ae63-e7767c3a6896\n"
"      lsn: 31\n"
"      upstream:\n"
"        status: follow\n"
"        idle: 43.187747001648\n"
"        peer: replicator@192.168.0.102:3301\n"
"        lag: 0\n"
"      downstream:\n"
"        vclock: {1: 31}\n"
"    3:\n"
"      id: 3\n"
"      uuid: e38ef895-5804-43b9-81ac-9f2cd872b9c4\n"
"      lsn: 54\n"
"      upstream:\n"
"        status: follow\n"
"        idle: 43.187621831894\n"
"        peer: replicator@192.168.0.103:3301\n"
"        lag: 2\n"
"      downstream:\n"
"        vclock: {1: 54}\n"
"..."

#: ../doc/book/replication/repl_monitoring.rst:43
msgid ""
"This report is for a master-master replica set of three instances, each "
"having its own instance id, UUID and log sequence number."
msgstr ""
"Данный отчет сгенерирован для набора реплик из трех экземпляров с "
"конфигурацией мастер-мастер, у каждого из которых есть свой собственный "
"ID экземпляра, UUID и номер записи в журнале."

#: ../doc/book/replication/repl_monitoring.rst:49
msgid ""
"The request was issued at master #1, and the reply includes statistics "
"for the other two masters, given in regard to master #1."
msgstr ""
"Запрос был выполнен с мастера №1, и ответ включает в себя статистику по "
"двум другим мастерам относительно мастера №1."

#: ../doc/book/replication/repl_monitoring.rst:52
msgid "The primary indicators of replication health are:"
msgstr "Основные индикаторы работоспособности репликации:"

#: ../doc/book/replication/repl_monitoring.rst:56
msgid ""
":ref:`idle <box_info_replication_upstream_idle>`, the time (in seconds) "
"since the instance received the last event from a master."
msgstr ""
":ref:`бездействие <box_info_replication_upstream_idle>`, время (в "
"секундах) с момента получения последнего события от мастера."

#: ../doc/book/replication/repl_monitoring.rst:59
msgid ""
"A replica sends heartbeat messages to the master every second, and the "
"master is programmed to reconnect automatically if it does not see "
"heartbeat messages within :ref:`replication_timeout <cfg_replication-"
"replication_timeout>` seconds."
msgstr ""
"Реплика отправляет сообщения контрольного сигнала на мастер каждую "
"секунду, и мастер запрограммирован на автоматическое переподключение, "
"если он не получает сообщения контрольного сигнала в течение количества "
"секунд, указанного в :ref:`replication_timeout <cfg_replication-"
"replication_timeout>`."

#: ../doc/book/replication/repl_monitoring.rst:64
msgid ""
"Therefore, in a healthy replication setup, ``idle`` should never exceed "
"``replication_timeout``: if it does, either the replication is lagging "
"seriously behind, because the master is running ahead of the replica, or "
"the network link between the instances is down."
msgstr ""
"Таким образом, в работоспособном состоянии значение ``idle`` никогда не "
"должно превышать значение ``replication_timeout``: в противном случае, "
"либо репликация сильно отстает, поскольку мастер опережает реплику, либо "
"отсутствует сетевое подключение между экземплярами."

#: ../doc/book/replication/repl_monitoring.rst:69
msgid ""
":ref:`lag <box_info_replication_upstream_lag>`, the time difference "
"between the local time at the instance, recorded when the event was "
"received, and the local time at another master recorded when the event "
"was written to the :ref:`write ahead log <internals-wal>` on that master."
msgstr ""
":ref:`отставание <box_info_replication_upstream_lag>`, разница во времени"
" между локальным временем на экземпляре, зарегистрированным при получении"
" события, и локальное время на другом мастере, зарегистрированное при "
"записи события в :ref:`журнал упреждающей записи <internals-wal>` на этом"
" мастере."

#: ../doc/book/replication/repl_monitoring.rst:74
msgid ""
"Since the ``lag`` calculation uses the operating system clocks from two "
"different machines, do not be surprised if it’s negative: a time drift "
"may lead to the remote master clock being consistently behind the local "
"instance's clock."
msgstr ""
"Поскольку при расчете ``отставания`` используются часы операционной "
"системы с двух разных машин, не удивляйтесь, получив отрицательное число:"
" смещение во времени может привести к постоянному запаздыванию времени на"
" удаленном мастере относительно часов на локальном экземпляре."

#: ../doc/book/replication/repl_monitoring.rst:78
msgid "For multi-master configurations, ``lag`` is the maximal lag."
msgstr "Для многомастерной конфигурации это максимально возможное отставание."

#: ../doc/book/replication/repl_recover.rst:5
msgid "Recovering from a degraded state"
msgstr "Восстановление после сбоя"

#: ../doc/book/replication/repl_recover.rst:7
msgid ""
"\"Degraded state\" is a situation when the master becomes unavailable -- "
"due to hardware or network failure, or due to a programming bug."
msgstr ""
"\"Сбой\" -- это ситуация, когда мастер становится недоступен вследствие "
"проблем с оборудованием, сетевых неполадок или программной ошибки."

#: ../doc/book/replication/repl_recover.rst:13
msgid ""
"In a master-replica set, if a master disappears, error messages appear on"
" the replicas stating that the connection is lost:"
msgstr ""
"В конфигурации мастер-реплика, если мастер пропадает, на репликах "
"выводятся сообщения об ошибке с указанием потери соединения:"

#: ../doc/book/replication/repl_recover.rst:16
msgid ""
"$ # messages from a replica's log\n"
"2017-06-14 16:23:10.993 [19153] main/105/applier/replicator@192.168.0. I>"
" can't read row\n"
"2017-06-14 16:23:10.993 [19153] main/105/applier/replicator@192.168.0. "
"coio.cc:349 !> SystemError\n"
"unexpected EOF when reading from socket, called on fd 17, aka "
"192.168.0.101:57815,\n"
"peer of 192.168.0.101:3301: Broken pipe\n"
"2017-06-14 16:23:10.993 [19153] main/105/applier/replicator@192.168.0. I>"
" will retry every 1 second\n"
"2017-06-14 16:23:10.993 [19153] relay/[::ffff:192.168.0.101]:/101/main I>"
" the replica has closed its socket, exiting\n"
"2017-06-14 16:23:10.993 [19153] relay/[::ffff:192.168.0.101]:/101/main C>"
" exiting the relay loop"
msgstr ""
"$ # сообщения из журнала реплики\n"
"2017-06-14 16:23:10.993 [19153] main/105/applier/replicator@192.168.0. I>"
" can't read row\n"
"2017-06-14 16:23:10.993 [19153] main/105/applier/replicator@192.168.0. "
"coio.cc:349 !> SystemError\n"
"unexpected EOF when reading from socket, called on fd 17, aka "
"192.168.0.101:57815,\n"
"peer of 192.168.0.101:3301: Broken pipe\n"
"2017-06-14 16:23:10.993 [19153] main/105/applier/replicator@192.168.0. I>"
" will retry every 1 second\n"
"2017-06-14 16:23:10.993 [19153] relay/[::ffff:192.168.0.101]:/101/main I>"
" the replica has closed its socket, exiting\n"
"2017-06-14 16:23:10.993 [19153] relay/[::ffff:192.168.0.101]:/101/main C>"
" exiting the relay loop"

#: ../doc/book/replication/repl_recover.rst:27
msgid "... and the master's status is reported as \"disconnected\":"
msgstr "... а статус мастера выводится как \"отключенный\" (disconnected):"

#: ../doc/book/replication/repl_recover.rst:29
msgid ""
"# report from replica #1\n"
"tarantool> box.info.replication\n"
"---\n"
"- 1:\n"
"    id: 1\n"
"    uuid: 70e8e9dc-e38d-4046-99e5-d25419267229\n"
"    lsn: 542\n"
"    upstream:\n"
"      peer: replicator@192.168.0.101:3301\n"
"      lag: 0.00026607513427734\n"
"      status: disconnected\n"
"      idle: 182.36929893494\n"
"      message: connect, called on fd 13, aka 192.168.0.101:58244\n"
"  2:\n"
"    id: 2\n"
"    uuid: fb252ac7-5c34-4459-84d0-54d248b8c87e\n"
"    lsn: 0\n"
"  3:\n"
"    id: 3\n"
"    uuid: fd7681d8-255f-4237-b8bb-c4fb9d99024d\n"
"    lsn: 0\n"
"    downstream:\n"
"      vclock: {1: 542}\n"
"..."
msgstr ""
"# отчет от реплики № 1\n"
"tarantool> box.info.replication\n"
"---\n"
"- 1:\n"
"    id: 1\n"
"    uuid: 70e8e9dc-e38d-4046-99e5-d25419267229\n"
"    lsn: 542\n"
"    upstream:\n"
"      peer: replicator@192.168.0.101:3301\n"
"      lag: 0.00026607513427734\n"
"      status: disconnected\n"
"      idle: 182.36929893494\n"
"      message: connect, called on fd 13, aka 192.168.0.101:58244\n"
"  2:\n"
"    id: 2\n"
"    uuid: fb252ac7-5c34-4459-84d0-54d248b8c87e\n"
"    lsn: 0\n"
"  3:\n"
"    id: 3\n"
"    uuid: fd7681d8-255f-4237-b8bb-c4fb9d99024d\n"
"    lsn: 0\n"
"    downstream:\n"
"      vclock: {1: 542}\n"
"..."

#: ../doc/book/replication/repl_recover.rst:56
msgid ""
"# report from replica #2\n"
"tarantool> box.info.replication\n"
"---\n"
"- 1:\n"
"    id: 1\n"
"    uuid: 70e8e9dc-e38d-4046-99e5-d25419267229\n"
"    lsn: 542\n"
"    upstream:\n"
"      peer: replicator@192.168.0.101:3301\n"
"      lag: 0.00027203559875488\n"
"      status: disconnected\n"
"      idle: 186.76988101006\n"
"      message: connect, called on fd 13, aka 192.168.0.101:58253\n"
"  2:\n"
"    id: 2\n"
"    uuid: fb252ac7-5c34-4459-84d0-54d248b8c87e\n"
"    lsn: 0\n"
"    upstream:\n"
"      status: follow\n"
"      idle: 186.76960110664\n"
"      peer: replicator@192.168.0.102:3301\n"
"      lag: 0.00020599365234375\n"
"  3:\n"
"    id: 3\n"
"    uuid: fd7681d8-255f-4237-b8bb-c4fb9d99024d\n"
"    lsn: 0\n"
"..."
msgstr ""
"# отчет от реплики № 2\n"
"tarantool> box.info.replication\n"
"---\n"
"- 1:\n"
"    id: 1\n"
"    uuid: 70e8e9dc-e38d-4046-99e5-d25419267229\n"
"    lsn: 542\n"
"    upstream:\n"
"      peer: replicator@192.168.0.101:3301\n"
"      lag: 0.00027203559875488\n"
"      status: disconnected\n"
"      idle: 186.76988101006\n"
"      message: connect, called on fd 13, aka 192.168.0.101:58253\n"
"  2:\n"
"    id: 2\n"
"    uuid: fb252ac7-5c34-4459-84d0-54d248b8c87e\n"
"    lsn: 0\n"
"    upstream:\n"
"      status: follow\n"
"      idle: 186.76960110664\n"
"      peer: replicator@192.168.0.102:3301\n"
"      lag: 0.00020599365234375\n"
"  3:\n"
"    id: 3\n"
"    uuid: fd7681d8-255f-4237-b8bb-c4fb9d99024d\n"
"    lsn: 0\n"
"..."

#: ../doc/book/replication/repl_recover.rst:86
msgid "To declare that one of the replicas must now take over as a new master:"
msgstr "Чтобы объявить, что одна из реплик должна стать новым мастером:"

#: ../doc/book/replication/repl_recover.rst:88
msgid "Make sure that the old master is gone for good:"
msgstr "Убедитесь, что старый мастер окончательно недоступен:"

#: ../doc/book/replication/repl_recover.rst:90
msgid ""
"change network routing rules to avoid any more packets being delivered to"
" the master, or"
msgstr ""
"измените правила маршрутизации в сети, чтобы больше не отправлять пакеты "
"на мастер, или"

#: ../doc/book/replication/repl_recover.rst:92
msgid "shut down the master instance, if you have access to the machine, or"
msgstr "отключите мастер-экземпляр, если у вас есть доступ к машине, или"

#: ../doc/book/replication/repl_recover.rst:93
msgid "power off the container or the machine."
msgstr "отключите питание контейнера или машины."

#: ../doc/book/replication/repl_recover.rst:95
msgid ""
"Say ``box.cfg{read_only=false, listen=URI}`` on the replica, and "
"``box.cfg{replication=URI}`` on the other replicas in the set."
msgstr ""
"Выполните ``box.cfg{read_only=false, listen=URI}`` на реплике и "
"``box.cfg{replication=URI}`` на других репликах в наборе."

#: ../doc/book/replication/repl_recover.rst:100
msgid ""
"If there are updates on the old master that were not propagated before "
"the old master went down, :ref:`re-apply them manually <admin-"
"disaster_recovery-master_replica>` to the new master using ``tarantoolctl"
" cat`` and ``tarantoolctl play`` commands."
msgstr ""
"Если на старом мастере есть обновления, не переданные до выхода старого "
"мастера из строя, :ref:`примените их вручную <admin-disaster_recovery-"
"master_replica>` на новом мастере с помощью команд ``tarantoolctl cat`` "
"и``tarantoolctl play``."

#: ../doc/book/replication/repl_recover.rst:105
msgid ""
"There is no automatic way for a replica to detect that the master is gone"
" forever, since sources of failure and replication environments vary "
"significantly. So the detection of degraded state requires an external "
"observer."
msgstr ""
"Реплика не может автоматически определить, что мастер не будет доступен в"
" будущем, поскольку причины отказа и среды репликации могут существенно "
"отличаться друг от друга. Поэтому обнаруживать сбой должен человек."

#: ../doc/book/replication/repl_remove_instances.rst:5
msgid "Removing instances"
msgstr "Удаление экземпляров"

#: ../doc/book/replication/repl_remove_instances.rst:7
msgid "To remove an instance from a replica set politely, follow these steps:"
msgstr ""
"Чтобы правильно удалить экземпляр из набора реплик, выполните следующие "
"действия:"

#: ../doc/book/replication/repl_remove_instances.rst:9
msgid "On the instance, run ``box.cfg{}`` with a blank replication source:"
msgstr "Выполните ``box.cfg{}`` с пустым источником репликации на экземпляре:"

#: ../doc/book/replication/repl_remove_instances.rst:11
msgid ""
"tarantool> box.cfg{replication=''}\n"
"---\n"
"..."
msgstr ""
"tarantool> box.cfg{replication=''}\n"
"---\n"
"..."

#: ../doc/book/replication/repl_remove_instances.rst:17
msgid ""
"The other instances in the replica set will carry on. If later the "
"removed instance rejoins, it will receive all the updates that the other "
"instances made while it was away."
msgstr ""
"Остальные экземпляры продолжают работать. Если выбывший экземпляр снова "
"возвращается в кластер, то он получит информацию о всех изменениях, "
"которые произошли на остальных экземплярах за время его отсутствия."

#: ../doc/book/replication/repl_remove_instances.rst:21
msgid ""
"If the instance is decommissioned forever, delete the instance's record "
"from the following locations:"
msgstr ""
"Если экземпляр больше не будет использоваться, удалите записи об "
"экземпляре из следующих мест:"

#: ../doc/book/replication/repl_remove_instances.rst:24
msgid ""
"the :ref:`replication <cfg_replication-replication>` parameter at all "
"running instances in the replica set:"
msgstr ""
"параметр :ref:`replication <cfg_replication-replication>` на всех "
"работающих экземплярах в наборе реплик:"

#: ../doc/book/replication/repl_remove_instances.rst:27
msgid "tarantool> box.cfg{replication=...}"
msgstr "tarantool> box.cfg{replication=...}"

#: ../doc/book/replication/repl_remove_instances.rst:31
msgid ""
"the :ref:`box.space._cluster <box_space-cluster>` tuple on any master "
"instance in the replica set. For example, for a record with instance id ="
" 3:"
msgstr ""
"кортеж :ref:`box.space._cluster <box_space-cluster>` на любом мастере в "
"наборе реплик. Например, для записи с ID экземпляра = 3:"

#: ../doc/book/replication/repl_remove_instances.rst:34
msgid ""
"tarantool> box.space._cluster:select{}\n"
"---\n"
"- - [1, '913f99c8-aee3-47f2-b414-53ed0ec5bf27']\n"
"  - [2, 'eac1aee7-cfeb-46cc-8503-3f8eb4c7de1e']\n"
"  - [3, '97f2d65f-2e03-4dc8-8df3-2469bd9ce61e']\n"
"...\n"
"tarantool> box.space._cluster:delete(3)\n"
"---\n"
"- [3, '97f2d65f-2e03-4dc8-8df3-2469bd9ce61e']\n"
"..."
msgstr ""
"tarantool> box.space._cluster:select{}\n"
"---\n"
"- - [1, '913f99c8-aee3-47f2-b414-53ed0ec5bf27']\n"
"  - [2, 'eac1aee7-cfeb-46cc-8503-3f8eb4c7de1e']\n"
"  - [3, '97f2d65f-2e03-4dc8-8df3-2469bd9ce61e']\n"
"...\n"
"tarantool> box.space._cluster:delete(3)\n"
"---\n"
"- [3, '97f2d65f-2e03-4dc8-8df3-2469bd9ce61e']\n"
"..."

#: ../doc/book/replication/repl_reseed.rst:5
msgid "Reseeding a replica"
msgstr "Перезагрузка реплики"

#: ../doc/book/replication/repl_reseed.rst:7
msgid ""
"If any of a replica's .xlog/.snap/.run files are corrupted or deleted, "
"you can \"re-seed\" the replica:"
msgstr ""
"Если один из файлов формата .xlog/.snap/.run на реплике поврежден или "
"удален, можно \"перезагрузить\" реплику данными:"

#: ../doc/book/replication/repl_reseed.rst:10
msgid ""
"Stop the replica and destroy all local database files (the ones with "
"extensions .xlog/.snap/.run/.inprogress)."
msgstr ""
"Остановите реплику и удалите все локальные файлы базы данных (с "
"расширениями .xlog/.snap/.run/.inprogress)."

#: ../doc/book/replication/repl_reseed.rst:13
msgid "Delete the replica's record from the following locations:"
msgstr "Удалите запись о реплике из следующих мест:"

#: ../doc/book/replication/repl_reseed.rst:15
msgid "the ``replication`` parameter at all running instances in the replica set."
msgstr "параметр ``replication`` на всех работающих экземплярах в наборе реплик."

#: ../doc/book/replication/repl_reseed.rst:16
msgid "the ``box.space._cluster`` tuple on the master instance."
msgstr "кортеж ``box.space._cluster`` на мастер-экземпляре."

#: ../doc/book/replication/repl_reseed.rst:18
msgid ""
"See section :ref:`Removing instances <replication-remove_instances>` for "
"details."
msgstr ""
"Для получения подробной информации см. Раздел :ref:`Удаление экземпляров "
"<replication-remove_instances>`."

#: ../doc/book/replication/repl_reseed.rst:21
msgid ""
"Restart the replica with the same instance file to contact the master "
"again. The replica will then catch up with the master by retrieving all "
"the master’s tuples."
msgstr ""
"Перезапустите реплику с тем же файлом экземпляра для повторного "
"подключения к мастеру. Реплика синхронизируется с мастером после "
"получения всех кортежей."

#: ../doc/book/replication/repl_reseed.rst:27
msgid ""
"Remember that this procedure works only if the master’s WAL files are "
"present."
msgstr ""
"Следует отметить, что эта процедура сработает только в том случае, если "
"на мастере есть WAL-файлы."

#: ../doc/book/sql.rst:5
msgid "SQL"
msgstr "SQL"

#: ../doc/book/sql.rst:7
msgid ""
"In this section we will go through SQL:2016's \"Feature taxonomy and "
"definition for mandatory features\"."
msgstr ""
"В данном разделе мы рассмотрим \"Классификацию функциональных "
"возможностей и определение обязательных функциональных возможностей\" по "
"стандарту SQL:2016."

#: ../doc/book/sql.rst:10
msgid ""
"For each feature in that list, we will come up with a simple example SQL "
"statement. If Tarantool appears to handle the example, we will mark it "
"\"Okay\", else we will mark it \"Fail\". Since this is rough and "
"arbitrary, we believe that tests which are unfairly marked \"Okay\" will "
"probably be balanced by tests which are unfairly marked \"Fail\"."
msgstr ""
"Для каждой функциональной возможности в таблице мы обозначим простой "
"пример оператора SQL. Если Tarantool сможет обработать пример, отметим "
"результат теста как \"Пройден\", в противном случае отметим его: \"Не "
"пройден\". Поскольку оценка приблизительная и произвольная, примем, что "
"количество несправедливо \"пройденных\" тестов будет примерно равно "
"количеству несправедливо \"не пройденных\" тестов."

#: ../doc/book/sql.rst:23
msgid "Feature ID"
msgstr "Идентификатор функциональной возможности"

#: ../doc/book/sql.rst:23
msgid "Feature"
msgstr "Функциональная возможность"

#: ../doc/book/sql.rst:23
msgid "Test"
msgstr "Результат теста"

#: ../doc/book/sql.rst:25
msgid "E011"
msgstr "E011"

#: ../doc/book/sql.rst:25
msgid "Numeric data types"
msgstr "Числовые типы данных"

#: ../doc/book/sql.rst:27
msgid "E011-01"
msgstr "E011-01"

#: ../doc/book/sql.rst:27
msgid "INTEGER and SMALLINT"
msgstr "INTEGER и SMALLINT"

#: ../doc/book/sql.rst:27
msgid "``create table t (s1 int primary key);``"
msgstr "``create table t (s1 int primary key);``"

#: ../doc/book/sql.rst:27 ../doc/book/sql.rst:29 ../doc/book/sql.rst:45
#: ../doc/book/sql.rst:47 ../doc/book/sql.rst:72 ../doc/book/sql.rst:77
#: ../doc/book/sql.rst:95 ../doc/book/sql.rst:97 ../doc/book/sql.rst:101
#: ../doc/book/sql.rst:103 ../doc/book/sql.rst:105 ../doc/book/sql.rst:108
#: ../doc/book/sql.rst:112 ../doc/book/sql.rst:114 ../doc/book/sql.rst:120
#: ../doc/book/sql.rst:122 ../doc/book/sql.rst:124 ../doc/book/sql.rst:126
#: ../doc/book/sql.rst:128 ../doc/book/sql.rst:130 ../doc/book/sql.rst:134
#: ../doc/book/sql.rst:136 ../doc/book/sql.rst:138 ../doc/book/sql.rst:142
#: ../doc/book/sql.rst:145 ../doc/book/sql.rst:153 ../doc/book/sql.rst:161
#: ../doc/book/sql.rst:191 ../doc/book/sql.rst:193 ../doc/book/sql.rst:195
#: ../doc/book/sql.rst:197 ../doc/book/sql.rst:199 ../doc/book/sql.rst:201
#: ../doc/book/sql.rst:205 ../doc/book/sql.rst:207 ../doc/book/sql.rst:210
#: ../doc/book/sql.rst:212 ../doc/book/sql.rst:218 ../doc/book/sql.rst:220
#: ../doc/book/sql.rst:234 ../doc/book/sql.rst:238 ../doc/book/sql.rst:241
#: ../doc/book/sql.rst:247 ../doc/book/sql.rst:251 ../doc/book/sql.rst:254
#: ../doc/book/sql.rst:260 ../doc/book/sql.rst:269 ../doc/book/sql.rst:281
#: ../doc/book/sql.rst:294 ../doc/book/sql.rst:310 ../doc/book/sql.rst:313
#: ../doc/book/sql.rst:315 ../doc/book/sql.rst:321 ../doc/book/sql.rst:327
#: ../doc/book/sql.rst:354 ../doc/book/sql.rst:359 ../doc/book/sql.rst:362
#: ../doc/book/sql.rst:365 ../doc/book/sql.rst:368 ../doc/book/sql.rst:373
#: ../doc/book/sql.rst:379 ../doc/book/sql.rst:381 ../doc/book/sql.rst:383
#: ../doc/book/sql.rst:385 ../doc/book/sql.rst:403 ../doc/book/sql.rst:427
msgid "Okay."
msgstr "Пройден."

#: ../doc/book/sql.rst:29
msgid "E011-02"
msgstr "E011-02"

#: ../doc/book/sql.rst:29
msgid "REAL, DOUBLE PRECISION, and FLOAT data types"
msgstr "Типы данных REAL, DOUBLE PRECISION и FLOAT"

#: ../doc/book/sql.rst:29
msgid "``create table tr (s1 float primary key);``"
msgstr "``create table tr (s1 float primary key);``"

#: ../doc/book/sql.rst:31
msgid ""
"**Note:** Floating point SQL types are not planned to be compatible "
"between 2.1 and 2.2 releases. The reason is that in 2.1 we set 'number' "
"format for columns of these types, but will restrict it to 'float32' and "
"'float64' in 2.2. The format change requires data migration and cannot be"
" done automatically, because in 2.1 we have no information to distinguish"
" 'number' columns (created from Lua) from FLOAT/DOUBLE/REAL ones (created"
" from SQL)."
msgstr ""

#: ../doc/book/sql.rst:41
msgid "E011-03"
msgstr "E011-03"

#: ../doc/book/sql.rst:41
msgid "DECIMAL and NUMERIC data types"
msgstr "Типы данных DECIMAL и NUMERIC"

#: ../doc/book/sql.rst:41
msgid "``create table td (s1 numeric primary key);``"
msgstr "``create table td (s1 numeric primary key);``"

#: ../doc/book/sql.rst:41
msgid ""
"Fail, DECIMAL and NUMERIC data types are not supported and a number "
"containing post-decimal digits will be treated as approximate numeric."
msgstr ""

#: ../doc/book/sql.rst:45
msgid "E011-04"
msgstr "E011-04"

#: ../doc/book/sql.rst:45
msgid "Arithmetic operators"
msgstr "Арифметические операции"

#: ../doc/book/sql.rst:45
msgid "``select 10+1,9-2,8*3,7/2 from t;``"
msgstr "``select 10+1,9-2,8*3,7/2 from t;``"

#: ../doc/book/sql.rst:47
msgid "E011-05"
msgstr "E011-05"

#: ../doc/book/sql.rst:47
msgid "Numeric comparisons"
msgstr "Сравнения числовых данных"

#: ../doc/book/sql.rst:47
msgid "``select * from t where 1 < 2;``"
msgstr "``select * from t where 1 < 2;``"

#: ../doc/book/sql.rst:49
msgid "E011-06"
msgstr "E011-06"

#: ../doc/book/sql.rst:49
msgid "Implicit casting among the numeric data types"
msgstr "Неявно определенное приведение числовых типов данных"

#: ../doc/book/sql.rst:49
msgid "``select * from t where s1 = 1.00;``"
msgstr "``select * from t where s1 = 1.00;``"

#: ../doc/book/sql.rst:49
msgid ""
"Okay, but only because Tarantool doesn't distinguish between numeric data"
" types."
msgstr ""
"Пройден, но только потому что Tarantool не различает отдельные числовые "
"типы данных."

#: ../doc/book/sql.rst:52
msgid "E021"
msgstr "E021"

#: ../doc/book/sql.rst:52
msgid "Character string types"
msgstr "Типы данных символьных строк"

#: ../doc/book/sql.rst:54
msgid "E021-01"
msgstr "E021-01"

#: ../doc/book/sql.rst:54
msgid "Character data type (including all its spellings)"
msgstr "Символьный тип данных (включая все варианты написания)"

#: ../doc/book/sql.rst:54
msgid "``create table t44 (s1 char primary key);``"
msgstr "``create table t44 (s1 char primary key);``"

#: ../doc/book/sql.rst:54
msgid "Fail, CHAR is not supported. This type of Fail will only be counted once."
msgstr ""
"Не пройден, поскольку допускается только написание CHAR. Такой тип "
"результата \"не пройден\" будет засчитан только один раз."

#: ../doc/book/sql.rst:57
msgid "E021-02"
msgstr "E021-02"

#: ../doc/book/sql.rst:57
msgid "CHARACTER VARYING data type (including all its spellings)"
msgstr "Тип данных CHARACTER VARYING (включая все варианты написания)"

#: ../doc/book/sql.rst:57
msgid "``create table t45 (s1 varchar primary key);``"
msgstr "``create table t45 (s1 varchar primary key);``"

#: ../doc/book/sql.rst:57
msgid "Fail, only the spelling VARCHAR is allowed."
msgstr "Не пройден, допускается только написание VARCHAR."

#: ../doc/book/sql.rst:59
msgid "**Note:** VARCHAR(N) does not check the string length."
msgstr ""

#: ../doc/book/sql.rst:61
msgid "E021-03"
msgstr "E021-03"

#: ../doc/book/sql.rst:61
msgid "Character literals"
msgstr "Символьные литералы"

#: ../doc/book/sql.rst:61
msgid "``insert into t45 values ('');``"
msgstr "``insert into t45 values ('');``"

#: ../doc/book/sql.rst:61
msgid ""
"Okay, and the bad practice of accepting \"\"'s for character literals is "
"avoided."
msgstr ""
"Пройден, кроме того, не принимаются нерекомендуемые символьные литералы "
"\"\"."

#: ../doc/book/sql.rst:64
msgid "E021-04"
msgstr "E021-04"

#: ../doc/book/sql.rst:64
msgid ":ref:`CHARACTER_LENGTH <sql_function_length>` function"
msgstr ""

#: ../doc/book/sql.rst:64
msgid "``select character_length(s1) from t;``"
msgstr "``select character_length(s1) from t;``"

#: ../doc/book/sql.rst:64
msgid ""
"Fail. There is no such function. There is a function LENGTH(), which is "
"okay."
msgstr ""
"Не пройден. Такой функции нет, есть функция LENGTH(), которую можно "
"использовать."

#: ../doc/book/sql.rst:67
msgid "E021-05"
msgstr "E021-05"

#: ../doc/book/sql.rst:67
msgid "OCTET_LENGTH"
msgstr "OCTET_LENGTH"

#: ../doc/book/sql.rst:67
msgid "``select octet_length(s1) from t;``"
msgstr "``select octet_length(s1) from t;``"

#: ../doc/book/sql.rst:67
msgid "Fail. There is no such function."
msgstr "Не пройден. Такой функции нет."

#: ../doc/book/sql.rst:69
msgid "E021-06"
msgstr "E021-06"

#: ../doc/book/sql.rst:69
msgid "SUBSTRING function."
msgstr "Функция SUBSTRING"

#: ../doc/book/sql.rst:69
msgid "``select substring(s1 from 1 for 1) from t;``"
msgstr "``select substring(s1 from 1 for 1) from t;``"

#: ../doc/book/sql.rst:69
msgid ""
"Fail. There is no such function. There is a function SUBSTR(x,n,n) which "
"is okay."
msgstr ""
"Не пройден. Такой функции нет, есть функция SUBSTR(x,n,n), которую можно "
"использовать."

#: ../doc/book/sql.rst:72
msgid "E021-07"
msgstr "E021-07"

#: ../doc/book/sql.rst:72
msgid "Character concatenation"
msgstr "Конкатенация символов"

#: ../doc/book/sql.rst:72
msgid "``select 'a' || 'b' from t;``"
msgstr "``select 'a' || 'b' from t;``"

#: ../doc/book/sql.rst:74
msgid "E021-08"
msgstr "E021-08"

#: ../doc/book/sql.rst:74
msgid ""
":ref:`UPPER <sql_function_upper>` and :ref:`LOWER <sql_function_lower>` "
"functions"
msgstr ""

#: ../doc/book/sql.rst:74
msgid "``select upper('a'),lower('B') from t;``"
msgstr "``select upper('a'),lower('B') from t;``"

#: ../doc/book/sql.rst:74
msgid "Okay. SUBSTR(x,n,n) which is okay."
msgstr ""

#: ../doc/book/sql.rst:77
msgid "E021-09"
msgstr "E021-09"

#: ../doc/book/sql.rst:77
msgid "TRIM function"
msgstr "Функция TRIM"

#: ../doc/book/sql.rst:77
msgid "``select trim('a ') from t;``"
msgstr "``select trim('a ') from t;``"

#: ../doc/book/sql.rst:79
msgid "E021-10"
msgstr "E021-10"

#: ../doc/book/sql.rst:79
msgid ""
"Implicit casting among the fixed-length and variable-length character "
"string types"
msgstr ""
"Неявно определенное приведение типов символьных строк фиксированной длины"
" и переменной длины"

#: ../doc/book/sql.rst:79
msgid "``select * from tm where char_column > varchar_column;``"
msgstr "``select * from tm where char_column > varchar_column;``"

#: ../doc/book/sql.rst:79
msgid "Fail, there is no fixed-length character string type."
msgstr ""

#: ../doc/book/sql.rst:82
msgid "E021-11"
msgstr "E021-11"

#: ../doc/book/sql.rst:82
msgid "POSITION function"
msgstr "Функция POSITION"

#: ../doc/book/sql.rst:82
msgid "``select position(x in y) from z;``"
msgstr "``select position(x in y) from z;``"

#: ../doc/book/sql.rst:82
msgid "Fail. Tarantool's function uses ',' rather than 'in'"
msgstr ""

#: ../doc/book/sql.rst:84
msgid "E021-12"
msgstr "E021-12"

#: ../doc/book/sql.rst:84
msgid "Character comparison"
msgstr "Сравнение символов"

#: ../doc/book/sql.rst:84
msgid "``select * from t where s1 > 'a';``"
msgstr "``select * from t where s1 > 'a';``"

#: ../doc/book/sql.rst:84
msgid ""
"Okay. We should note here that comparisons use a binary collation by "
"default, but it is easy to specify unicode or unicode_ci collations, or "
"create new collations."
msgstr ""
"Пройден. Здесь следует отметить, что по умолчанию в сравнениях "
"используется бинарная сортировка, но можно легко указать сортировку по "
"unicode или unicode_ci, или же создать новый тип сортировки."

#: ../doc/book/sql.rst:88
msgid "E031"
msgstr "E031"

#: ../doc/book/sql.rst:88
msgid "Identifiers"
msgstr "Идентификаторы"

#: ../doc/book/sql.rst:88
msgid "``create table rank (ceil int primary key);``"
msgstr "``create table rank (ceil int primary key);``"

#: ../doc/book/sql.rst:88
msgid ""
"Fail. Tarantool's list of reserved words differs from the standard's list"
" of reserved words."
msgstr ""
"Не пройден. Список зарезервированных слов в Tarantool'е отличается от "
"списка зарезервированных слов, заданного в стандарте."

#: ../doc/book/sql.rst:91
msgid "E031-01"
msgstr "E031-01"

#: ../doc/book/sql.rst:91
msgid "Delimited Identifiers"
msgstr "Идентификаторы с разделителями"

#: ../doc/book/sql.rst:91
msgid "``create table \"t47\" (s1 int primary key);``"
msgstr "``create table \"t47\" (s1 int primary key);``"

#: ../doc/book/sql.rst:91
msgid ""
"Okay. And enclosing identifiers inside double quotes means they won't be "
"converted to upper case or lower case, this is behavior that some other "
"DBMSs sadly lack."
msgstr ""
"Пройден. Использование идентификаторов, заключенных в двойные кавычки, "
"означает, что они не будут преобразованы в верхний или нижний регистр, "
"что, к сожалению, происходит в некоторых других СУБД."

#: ../doc/book/sql.rst:95
msgid "E031-02"
msgstr "E031-02"

#: ../doc/book/sql.rst:95
msgid "Lower case identifiers"
msgstr "Идентификаторы в нижнем регистре"

#: ../doc/book/sql.rst:95
msgid "``create table t48 (s1 int primary key);``"
msgstr "``create table t48 (s1 int primary key);``"

#: ../doc/book/sql.rst:97
msgid "E031-03"
msgstr "E031-03"

#: ../doc/book/sql.rst:97
msgid "Trailing underscore"
msgstr "Подчеркивание в конце строки"

#: ../doc/book/sql.rst:97
msgid "``create table t49_ (s1 int primary key);``"
msgstr "``create table t49_ (s1 int primary key);``"

#: ../doc/book/sql.rst:99
msgid "E051"
msgstr "E051"

#: ../doc/book/sql.rst:99
msgid "Basic query specification"
msgstr "Спецификация базового запроса"

#: ../doc/book/sql.rst:101
msgid "E051-01"
msgstr "E051-01"

#: ../doc/book/sql.rst:101
msgid "SELECT DISTINCT"
msgstr "SELECT DISTINCT"

#: ../doc/book/sql.rst:101
msgid "``select distinct s1 from t;``"
msgstr "``select distinct s1 from t;``"

#: ../doc/book/sql.rst:103
msgid "E051-02"
msgstr "E051-02"

#: ../doc/book/sql.rst:103
msgid ":ref:`GROUP BY <sql_group_by>` clause"
msgstr ""

#: ../doc/book/sql.rst:103
msgid "``select distinct s1 from t group by s1;``"
msgstr "``select distinct s1 from t group by s1;``"

#: ../doc/book/sql.rst:105
msgid "E051-04"
msgstr "E051-04"

#: ../doc/book/sql.rst:105
msgid "GROUP BY can contain columns not in select list"
msgstr "GROUP BY может содержать столбцы не из списка выборки select"

#: ../doc/book/sql.rst:105
msgid "``select s1 from t group by lower(s1);``"
msgstr "``select s1 from t group by lower(s1);``"

#: ../doc/book/sql.rst:108
msgid "E051-05"
msgstr "E051-05"

#: ../doc/book/sql.rst:108
msgid "Select list items can be renamed"
msgstr "Пункты списка выборки можно переименовать"

#: ../doc/book/sql.rst:108
msgid "``select s1 as K from t order by K;``"
msgstr "``select s1 as K from t order by K;``"

#: ../doc/book/sql.rst:110
msgid "E051-06"
msgstr "E051-06"

#: ../doc/book/sql.rst:110
msgid ":ref:`HAVING <sql_having>` clause"
msgstr ""

#: ../doc/book/sql.rst:110
msgid "``select count(*) from t having count(*) > 0;``"
msgstr "``select count(*) from t having count(*) > 0;``"

#: ../doc/book/sql.rst:110
msgid "Okay. GROUP BY is not mandatory before HAVING."
msgstr "Пройден. GROUP BY не обязательно указывать перед HAVING."

#: ../doc/book/sql.rst:112
msgid "E051-07"
msgstr "E051-07"

#: ../doc/book/sql.rst:112
msgid "Qualified * in select list"
msgstr "Список выборки select допускает использование *"

#: ../doc/book/sql.rst:112
msgid "``select t.* from t;``"
msgstr "``select t.* from t;``"

#: ../doc/book/sql.rst:114
msgid "E051-08"
msgstr "E051-08"

#: ../doc/book/sql.rst:114
msgid "Correlation names in the FROM clause"
msgstr "Внутриоперативные имена в операторе FROM"

#: ../doc/book/sql.rst:114
msgid "``select * from t as K;``"
msgstr "``select * from t as K;``"

#: ../doc/book/sql.rst:116
msgid "E051-09"
msgstr "E051-09"

#: ../doc/book/sql.rst:116
msgid "Rename columns in the FROM clause"
msgstr "Переименование столбцов в операторе FROM"

#: ../doc/book/sql.rst:116
msgid "``select * from t as x(q,c);``"
msgstr "``select * from t as x(q,c);``"

#: ../doc/book/sql.rst:116
msgid "Fail."
msgstr "Не пройден."

#: ../doc/book/sql.rst:118
msgid "E061"
msgstr "E061"

#: ../doc/book/sql.rst:118
msgid "Basic predicates and search conditions"
msgstr "Базовые предикаты и условия поиска"

#: ../doc/book/sql.rst:120
msgid "E061-01"
msgstr "E061-01"

#: ../doc/book/sql.rst:120
msgid "Comparison predicate"
msgstr "Предикат сравнения"

#: ../doc/book/sql.rst:120
msgid "``select * from t where 0 = 0;``"
msgstr "``select * from t where 0 = 0;``"

#: ../doc/book/sql.rst:122
msgid "E061-02"
msgstr "E061-02"

#: ../doc/book/sql.rst:122
msgid "BETWEEN predicate"
msgstr "Предикат BETWEEN"

#: ../doc/book/sql.rst:122
msgid "``select * from t where ' ' between '' and ' ';``"
msgstr "``select * from t where ' ' between '' and ' ';``"

#: ../doc/book/sql.rst:124
msgid "E061-03"
msgstr "E061-03"

#: ../doc/book/sql.rst:124
msgid "IN predicate with list of values"
msgstr "Предикат IN со списком значений"

#: ../doc/book/sql.rst:124
msgid "``select * from t where s1 in ('a',upper('a'));``"
msgstr "``select * from t where s1 in ('a',upper('a'));``"

#: ../doc/book/sql.rst:126
msgid "E061-04"
msgstr "E061-04"

#: ../doc/book/sql.rst:126
msgid "LIKE predicate"
msgstr "Предикат LIKE"

#: ../doc/book/sql.rst:126
msgid "``select * from t where s1 like '_';``"
msgstr "``select * from t where s1 like '_';``"

#: ../doc/book/sql.rst:128
msgid "E061-05"
msgstr "E061-05"

#: ../doc/book/sql.rst:128
msgid "LIKE predicate: ESCAPE clause"
msgstr "Предикат LIKE: оператор ESCAPE"

#: ../doc/book/sql.rst:128
msgid "``VALUES ('abc_' LIKE 'abcX_' ESCAPE 'X');``"
msgstr "``VALUES ('abc_' LIKE 'abcX_' ESCAPE 'X');``"

#: ../doc/book/sql.rst:130
msgid "E061-06"
msgstr "E061-06"

#: ../doc/book/sql.rst:130
msgid "NULL predicate"
msgstr "Предикат NULL"

#: ../doc/book/sql.rst:130
msgid "``select * from t where s1 is not null;``"
msgstr "``select * from t where s1 is not null;``"

#: ../doc/book/sql.rst:132
msgid "E061-07"
msgstr "E061-07"

#: ../doc/book/sql.rst:132
msgid "Quantified comparison predicate"
msgstr "Предикат количественного сравнения"

#: ../doc/book/sql.rst:132
msgid "``select * from t where s1 = any (select s1 from t);``"
msgstr "``select * from t where s1 = any (select s1 from t);``"

#: ../doc/book/sql.rst:132 ../doc/book/sql.rst:140 ../doc/book/sql.rst:273
#: ../doc/book/sql.rst:276 ../doc/book/sql.rst:318 ../doc/book/sql.rst:334
#: ../doc/book/sql.rst:337 ../doc/book/sql.rst:346 ../doc/book/sql.rst:348
#: ../doc/book/sql.rst:350 ../doc/book/sql.rst:352 ../doc/book/sql.rst:375
#: ../doc/book/sql.rst:405
msgid "Fail. Syntax error."
msgstr "Не пройден. Ошибка синтаксиса."

#: ../doc/book/sql.rst:134
msgid "E061-08"
msgstr "E061-08"

#: ../doc/book/sql.rst:134
msgid "EXISTS predicate"
msgstr "Предикат EXISTS"

#: ../doc/book/sql.rst:134
msgid "``select * from t where not exists (select * from t);``"
msgstr "``select * from t where not exists (select * from t);``"

#: ../doc/book/sql.rst:136
msgid "E061-09"
msgstr "E061-09"

#: ../doc/book/sql.rst:136
msgid "Subqueries in comparison predicate"
msgstr "Подзапросы в предикате сравнения"

#: ../doc/book/sql.rst:136
msgid "``select * from t where s1 > (select s1 from t);``"
msgstr "``select * from t where s1 > (select s1 from t);``"

#: ../doc/book/sql.rst:138
msgid "E061-11"
msgstr "E061-11"

#: ../doc/book/sql.rst:138
msgid "Subqueries in IN predicate"
msgstr "Подзапросы в предикате IN"

#: ../doc/book/sql.rst:138
msgid "``select * from t where s1 in (select s1 from t);``"
msgstr "``select * from t where s1 in (select s1 from t);``"

#: ../doc/book/sql.rst:140
msgid "E061-12"
msgstr "E061-12"

#: ../doc/book/sql.rst:140
msgid "Subqueries in quantified comparison predicate"
msgstr "Подзапросы в предикате количественного сравнения"

#: ../doc/book/sql.rst:140
msgid "``select * from t where s1 >= all (select s1 from t);``"
msgstr "``select * from t where s1 >= all (select s1 from t);``"

#: ../doc/book/sql.rst:142
msgid "E061-13"
msgstr "E061-13"

#: ../doc/book/sql.rst:142
msgid "Correlated subqueries"
msgstr "Связанные подзапросы"

#: ../doc/book/sql.rst:142
msgid "``select * from t where s1 = (select s1 from t2 where t2.s2 = t.s1);``"
msgstr "``select * from t where s1 = (select s1 from t2 where t2.s2 = t.s1);``"

#: ../doc/book/sql.rst:145
msgid "E061-14"
msgstr "E061-14"

#: ../doc/book/sql.rst:145
msgid "Search condition"
msgstr "Условие поиска"

#: ../doc/book/sql.rst:145
msgid "``select * from t where 0 <> 0 or 'a' < 'b' and s1 is null;``"
msgstr "``select * from t where 0 <> 0 or 'a' < 'b' and s1 is null;``"

#: ../doc/book/sql.rst:148
msgid "E071"
msgstr "E071"

#: ../doc/book/sql.rst:148
msgid "Basic query expressions"
msgstr "Базовые выражения запросов"

#: ../doc/book/sql.rst:150
msgid "E071-01"
msgstr "E071-01"

#: ../doc/book/sql.rst:150
msgid "UNION DISTINCT table operator"
msgstr "Оператор для таблиц UNION DISTINCT"

#: ../doc/book/sql.rst:150
msgid "``select * from t union distinct select * from t;``"
msgstr "``select * from t union distinct select * from t;``"

#: ../doc/book/sql.rst:150
msgid "Fail. However, \"select * from t union select * from t;\" is okay."
msgstr ""
"Не пройден. Однако пройден тест \"select * from t union select * from "
"t;\"."

#: ../doc/book/sql.rst:153
msgid "E071-02"
msgstr "E071-02"

#: ../doc/book/sql.rst:153
msgid "UNION ALL table operator"
msgstr "Оператор для таблиц UNION ALL"

#: ../doc/book/sql.rst:153
msgid "``select * from t union all select * from t;``"
msgstr "``select * from t union all select * from t;``"

#: ../doc/book/sql.rst:155
msgid "E071-03"
msgstr "E071-03"

#: ../doc/book/sql.rst:155
msgid "EXCEPT DISTINCT table operator"
msgstr "Оператор для таблиц EXCEPT DISTINCT"

#: ../doc/book/sql.rst:155
msgid "``select * from t except distinct select * from t;``"
msgstr "``select * from t except distinct select * from t;``"

#: ../doc/book/sql.rst:155
msgid "Fail. However, ``select * from t except select * from t;`` is okay."
msgstr ""
"Не пройден. Однако пройден тест ``select * from t except select * from "
"t;``."

#: ../doc/book/sql.rst:158
msgid "E071-05"
msgstr "E071-05"

#: ../doc/book/sql.rst:158
msgid ""
"Columns combined via table operators need not have exactly the same data "
"type."
msgstr ""
"Столбцы, объединенные с помощью операторов таблиц, не обязательно должны "
"содержать один и тот же тип данных."

#: ../doc/book/sql.rst:158
msgid "``select s1 from t union select 5 from t;``"
msgstr "``select s1 from t union select 5 from t;``"

#: ../doc/book/sql.rst:158
msgid "Okay, but only because Tarantool doesn't distinguish data types very well."
msgstr ""
"Пройден, но только потому что Tarantool не слишком хорошо различает типы "
"данных."

#: ../doc/book/sql.rst:161
msgid "E071-06"
msgstr "E071-06"

#: ../doc/book/sql.rst:161
msgid "Table operators in subqueries"
msgstr "Операторы для таблиц в подзапросах"

#: ../doc/book/sql.rst:161
msgid "``select * from t where 'a' in (select * from t union select * from t);``"
msgstr "``select * from t where 'a' in (select * from t union select * from t);``"

#: ../doc/book/sql.rst:164
msgid "E081"
msgstr "E081"

#: ../doc/book/sql.rst:164
msgid "Basic privileges"
msgstr "Базовые привилегии"

#: ../doc/book/sql.rst:166
msgid "E081-01"
msgstr "E081-01"

#: ../doc/book/sql.rst:166
msgid "Select privilege at the table level"
msgstr "Выбор привилегии на уровне таблицы"

#: ../doc/book/sql.rst:166
msgid "Fail. Syntax error. (Tarantool doesn't support privileges.)"
msgstr "Не пройден. Ошибка синтаксиса. (Tarantool не поддерживает привилегии.)"

#: ../doc/book/sql.rst:169
msgid "E081-02"
msgstr "E081-02"

#: ../doc/book/sql.rst:169
msgid "DELETE privilege"
msgstr "Привилегия DELETE"

#: ../doc/book/sql.rst:169 ../doc/book/sql.rst:171 ../doc/book/sql.rst:173
#: ../doc/book/sql.rst:175 ../doc/book/sql.rst:177 ../doc/book/sql.rst:179
#: ../doc/book/sql.rst:181 ../doc/book/sql.rst:183 ../doc/book/sql.rst:185
msgid "Fail. (Tarantool doesn't support privileges.)"
msgstr "Не пройден. (Tarantool не поддерживает привилегии.)"

#: ../doc/book/sql.rst:171
msgid "E081-03"
msgstr "E081-03"

#: ../doc/book/sql.rst:171
msgid "INSERT privilege at the table level"
msgstr "Привилегия INSERT на уровне таблицы"

#: ../doc/book/sql.rst:173
msgid "E081-04"
msgstr "E081-04"

#: ../doc/book/sql.rst:173
msgid "UPDATE privilege at the table level"
msgstr "Привилегия UPDATE на уровне таблицы"

#: ../doc/book/sql.rst:175
msgid "E081-05"
msgstr "E081-05"

#: ../doc/book/sql.rst:175
msgid "UPDATE privilege at column level"
msgstr "Привилегия UPDATE на уровне столбца"

#: ../doc/book/sql.rst:177
msgid "E081-06"
msgstr "E081-06"

#: ../doc/book/sql.rst:177
msgid "REFERENCES privilege at the table level"
msgstr "Привилегия REFERENCES на уровне таблицы"

#: ../doc/book/sql.rst:179
msgid "E081-07"
msgstr "E081-07"

#: ../doc/book/sql.rst:179
msgid "REFERENCES privilege at column level"
msgstr "Привилегия REFERENCES на уровне столбца"

#: ../doc/book/sql.rst:181
msgid "E081-08"
msgstr "E081-08"

#: ../doc/book/sql.rst:181
msgid "WITH GRANT OPTION"
msgstr "WITH GRANT OPTION"

#: ../doc/book/sql.rst:183
msgid "E081-09"
msgstr "E081-09"

#: ../doc/book/sql.rst:183
msgid "USAGE privilege"
msgstr "Привилегия USAGE"

#: ../doc/book/sql.rst:185
msgid "E081-10"
msgstr "E081-10"

#: ../doc/book/sql.rst:185
msgid "EXECUTE privilege"
msgstr "Привилегия EXECUTE"

#: ../doc/book/sql.rst:187
msgid "E091"
msgstr "E091"

#: ../doc/book/sql.rst:187
msgid "Set functions"
msgstr "Функции"

#: ../doc/book/sql.rst:189
msgid "E091-01"
msgstr "E091-01"

#: ../doc/book/sql.rst:189
msgid ":ref:`AVG <sql_aggregate_avg>`"
msgstr ""

#: ../doc/book/sql.rst:189
msgid "``select avg(s1) from t7;``"
msgstr "``select avg(s1) from t7;``"

#: ../doc/book/sql.rst:189
msgid "Fail. No warning that nulls were eliminated."
msgstr "Не пройден. Нет предупреждения, что нулевые значения null были удалены."

#: ../doc/book/sql.rst:191
msgid "E091-02"
msgstr "E091-02"

#: ../doc/book/sql.rst:191
msgid ":ref:`COUNT <sql_aggregate_count_row>`"
msgstr ""

#: ../doc/book/sql.rst:191
msgid "``select count(*) from t7 where s1 > 0;``"
msgstr "``select count(*) from t7 where s1 > 0;``"

#: ../doc/book/sql.rst:193
msgid "E091-03"
msgstr "E091-03"

#: ../doc/book/sql.rst:193
msgid ":ref:`MAX <sql_aggregate_max>`"
msgstr ""

#: ../doc/book/sql.rst:193
msgid "``select max(s1) from t7 where s1 > 0;``"
msgstr "``select max(s1) from t7 where s1 > 0;``"

#: ../doc/book/sql.rst:195
msgid "E091-04"
msgstr "E091-04"

#: ../doc/book/sql.rst:195
msgid ":ref:`MIN <sql_aggregate_min>`"
msgstr ""

#: ../doc/book/sql.rst:195
msgid "``select min(s1) from t7 where s1 > 0;``"
msgstr "``select min(s1) from t7 where s1 > 0;``"

#: ../doc/book/sql.rst:197
msgid "E091-05"
msgstr "E091-05"

#: ../doc/book/sql.rst:197
msgid ":ref:`SUM <sql_aggregate_sum>`"
msgstr ""

#: ../doc/book/sql.rst:197
msgid "``select sum(1) from t7 where s1 > 0;``"
msgstr "``select sum(1) from t7 where s1 > 0;``"

#: ../doc/book/sql.rst:199
msgid "E091-06"
msgstr "E091-06"

#: ../doc/book/sql.rst:199
msgid "ALL quantifier"
msgstr "Квантификатор ALL"

#: ../doc/book/sql.rst:199
msgid "``select sum(all s1) from t7 where s1 > 0;``"
msgstr "``select sum(all s1) from t7 where s1 > 0;``"

#: ../doc/book/sql.rst:201
msgid "E091-07"
msgstr "E091-07"

#: ../doc/book/sql.rst:201
msgid "DISTINCT quantifier"
msgstr "Квантификатор DISTINCT"

#: ../doc/book/sql.rst:201
msgid "``select sum(distinct s1) from t7 where s1 > 0;``"
msgstr "``select sum(distinct s1) from t7 where s1 > 0;``"

#: ../doc/book/sql.rst:203
msgid "E101"
msgstr "E101"

#: ../doc/book/sql.rst:203
msgid "Basic data manipulation"
msgstr "Стандартные операции с данными"

#: ../doc/book/sql.rst:205
msgid "E101-01"
msgstr "E101-01"

#: ../doc/book/sql.rst:205
msgid "INSERT statement"
msgstr "Оператор INSERT"

#: ../doc/book/sql.rst:205
msgid "``insert into t (s1,s2) values (1,''),(2,null),(3,55);``"
msgstr "``insert into t (s1,s2) values (1,''),(2,null),(3,55);``"

#: ../doc/book/sql.rst:207
msgid "E101-03"
msgstr "E101-03"

#: ../doc/book/sql.rst:207
msgid "Searched UPDATE statement"
msgstr "Оператор UPDATE с поиском"

#: ../doc/book/sql.rst:207
msgid "``update t set s1 = null where s1 in (select s1 from t2);``"
msgstr "``update t set s1 = null where s1 in (select s1 from t2);``"

#: ../doc/book/sql.rst:210
msgid "E101-04"
msgstr "E101-04"

#: ../doc/book/sql.rst:210
msgid "Searched DELETE statement"
msgstr "Оператор DELETE с поиском"

#: ../doc/book/sql.rst:210
msgid "``delete from t where s1 in (select s1 from t);``"
msgstr "``delete from t where s1 in (select s1 from t);``"

#: ../doc/book/sql.rst:212
msgid "E111"
msgstr "E111"

#: ../doc/book/sql.rst:212
msgid "Single row SELECT statement"
msgstr "Оператор SELECT в одну строку"

#: ../doc/book/sql.rst:212
msgid "``select count(*) from t;``"
msgstr "``select count(*) from t;``"

#: ../doc/book/sql.rst:214
msgid "E121"
msgstr "E121"

#: ../doc/book/sql.rst:214
msgid "Basic cursor support"
msgstr "Базовая поддержка курсора"

#: ../doc/book/sql.rst:216
msgid "E121-01"
msgstr "E121-01"

#: ../doc/book/sql.rst:216
msgid "DECLARE CURSOR"
msgstr "DECLARE CURSOR"

#: ../doc/book/sql.rst:216 ../doc/book/sql.rst:222 ../doc/book/sql.rst:224
#: ../doc/book/sql.rst:226 ../doc/book/sql.rst:228 ../doc/book/sql.rst:230
#: ../doc/book/sql.rst:232
msgid "Fail. Tarantool doesn't support cursors."
msgstr "Не пройден. Tarantool не поддерживает курсоры."

#: ../doc/book/sql.rst:218
msgid "E121-02"
msgstr "E121-02"

#: ../doc/book/sql.rst:218
msgid "ORDER BY columns need not be in select list"
msgstr "Колонки ORDER BY в списке выборки"

#: ../doc/book/sql.rst:218
msgid "``select s1 from t order by s2;``"
msgstr "``select s1 from t order by s2;``"

#: ../doc/book/sql.rst:220
msgid "E121-03"
msgstr "E121-03"

#: ../doc/book/sql.rst:220
msgid "Value expressions in select list"
msgstr "Выражения значений в списке выборки"

#: ../doc/book/sql.rst:220
msgid "``select s1 from t7 order by -s1;``"
msgstr "``select s1 from t7 order by -s1;``"

#: ../doc/book/sql.rst:222
msgid "E121-04"
msgstr "E121-04"

#: ../doc/book/sql.rst:222
msgid "OPEN statement"
msgstr "Оператор OPEN"

#: ../doc/book/sql.rst:224
msgid "E121-06"
msgstr "E121-06"

#: ../doc/book/sql.rst:224
msgid "Positioned UPDATE statement"
msgstr "Оператор UPDATE по позиции"

#: ../doc/book/sql.rst:226
msgid "E121-07"
msgstr "E121-07"

#: ../doc/book/sql.rst:226
msgid "Positioned DELETE statement"
msgstr "Оператор DELETE по позиции"

#: ../doc/book/sql.rst:228
msgid "E121-08"
msgstr "E121-08"

#: ../doc/book/sql.rst:228
msgid "CLOSE statement"
msgstr "Оператор CLOSE"

#: ../doc/book/sql.rst:230
msgid "E121-10"
msgstr "E121-10"

#: ../doc/book/sql.rst:230
msgid "FETCH statement implicit next"
msgstr "Неявный оператор FETCH"

#: ../doc/book/sql.rst:232
msgid "E121-17"
msgstr "E121-17"

#: ../doc/book/sql.rst:232
msgid "WITH HOLD cursors"
msgstr "Курсоры WITH HOLD"

#: ../doc/book/sql.rst:234
msgid "E131"
msgstr "E131"

#: ../doc/book/sql.rst:234
msgid "Null value support (nulls in lieu of values)"
msgstr "Поддержка нулевых значений null (нули вместо значений)"

#: ../doc/book/sql.rst:234
msgid "``select s1 from t7 where s1 is null;``"
msgstr "``select s1 from t7 where s1 is null;``"

#: ../doc/book/sql.rst:236
msgid "E141"
msgstr "E141"

#: ../doc/book/sql.rst:236
msgid "Basic integrity constraints"
msgstr "Базовые ограничения целостности"

#: ../doc/book/sql.rst:238
msgid "E141-01"
msgstr "E141-01"

#: ../doc/book/sql.rst:238
msgid "NOT NULL constraints"
msgstr "Ограничения NOT NULL"

#: ../doc/book/sql.rst:238
msgid "``create table t8 (s1 int primary key, s2 int not null);``"
msgstr "``create table t8 (s1 int primary key, s2 int not null);``"

#: ../doc/book/sql.rst:241
msgid "E141-02"
msgstr "E141-02"

#: ../doc/book/sql.rst:241
msgid "UNIQUE constraints of NOT NULL columns"
msgstr "Ограничения UNIQUE для столбцов NOT NULL"

#: ../doc/book/sql.rst:241
msgid "``create table t9 (s1 int primary key , s2 int not null unique);``"
msgstr "``create table t9 (s1 int primary key , s2 int not null unique);``"

#: ../doc/book/sql.rst:244
msgid "E141-03"
msgstr "E141-03"

#: ../doc/book/sql.rst:244
msgid "PRIMARY KEY constraints"
msgstr "Ограничения PRIMARY KEY"

#: ../doc/book/sql.rst:244
msgid "``create table t10 (s1 int primary key);``"
msgstr "``create table t10 (s1 int primary key);``"

#: ../doc/book/sql.rst:244
msgid "Okay, although Tarantool shouldn't always insist on having a primary key."
msgstr ""
"Пройден, хотя Tarantool не всегда должен настаивать на наличии первичного"
" ключа."

#: ../doc/book/sql.rst:247
msgid "E141-04"
msgstr "E141-04"

#: ../doc/book/sql.rst:247
msgid ""
"Basic FOREIGN KEY constraint with the NO ACTION default for both "
"referential delete action and referential update action."
msgstr ""
"Базовое ограничение FOREIGN KEY со значением NO ACTION по умолчанию для "
"delete по внешнему ключу и update по внешнему ключу."

#: ../doc/book/sql.rst:247
msgid "``create table t11 (s0 int primary key, s1 int references t10);``"
msgstr "``create table t11 (s0 int primary key, s1 int references t10);``"

#: ../doc/book/sql.rst:251
msgid "E141-06"
msgstr "E141-06"

#: ../doc/book/sql.rst:251
msgid "CHECK constraints"
msgstr "Ограничения CHECK"

#: ../doc/book/sql.rst:251
msgid "``create table t12 (s1 int primary key, s2 int, check (s1 = s2));``"
msgstr "``create table t12 (s1 int primary key, s2 int, check (s1 = s2));``"

#: ../doc/book/sql.rst:254
msgid "E141-07"
msgstr "E141-07"

#: ../doc/book/sql.rst:254
msgid "Column defaults"
msgstr "Значения по умолчанию в столбцах"

#: ../doc/book/sql.rst:254
msgid "``create table t13 (s1 int primary key, s2 int default -1);``"
msgstr "``create table t13 (s1 int primary key, s2 int default -1);``"

#: ../doc/book/sql.rst:257
msgid "E141-08"
msgstr "E141-08"

#: ../doc/book/sql.rst:257
msgid "NOT NULL inferred on primary key"
msgstr "NOT NULL, выведенный по первичному ключу"

#: ../doc/book/sql.rst:257
msgid "``create table t14 (s1 int primary key);``"
msgstr "``create table t14 (s1 int primary key);``"

#: ../doc/book/sql.rst:257
msgid ""
"Okay. We are unable to insert NULL although we don't explicitly say the "
"column is NOT NULL."
msgstr ""
"Пройден. Мы не может вставитьt NULL, хотя не задаем явным образом, что "
"столбец -- NOT NULL."

#: ../doc/book/sql.rst:260
msgid "E141-10"
msgstr "E141-10"

#: ../doc/book/sql.rst:260
msgid "Names in a foreign key can be specified in any order"
msgstr "Имена во внешнем ключе могут быть указаны в любом порядке"

#: ../doc/book/sql.rst:260
msgid ""
"``create table t15 (s1 int, s2 int, primary key (s1,s2));`` ``create "
"table t16 (s1 int primary key, s2 int, foreign key (s2,s1) references t15"
" (s1,s2));``"
msgstr ""
"``create table t15 (s1 int, s2 int, primary key (s1,s2));`` ``create "
"table t16 (s1 int primary key, s2 int, foreign key (s2,s1) references t15"
" (s1,s2));``"

#: ../doc/book/sql.rst:265
msgid "E151"
msgstr "E151"

#: ../doc/book/sql.rst:265
msgid "Transaction support"
msgstr "Поддержка транзакций"

#: ../doc/book/sql.rst:267
msgid "E151-01"
msgstr "E151-01"

#: ../doc/book/sql.rst:267
msgid "COMMIT statement"
msgstr "Оператор COMMIT"

#: ../doc/book/sql.rst:267
msgid "``commit;``"
msgstr "``commit;``"

#: ../doc/book/sql.rst:267
msgid "Fail. We have to say START TRANSACTION first."
msgstr "Не пройден. Сначала необходимо ввести START TRANSACTION."

#: ../doc/book/sql.rst:269
msgid "E151-02"
msgstr "E151-02"

#: ../doc/book/sql.rst:269
msgid "ROLLBACK statement"
msgstr "Оператор ROLLBACK"

#: ../doc/book/sql.rst:269
msgid "``rollback;``"
msgstr "``rollback;``"

#: ../doc/book/sql.rst:271
msgid "E152"
msgstr "E152"

#: ../doc/book/sql.rst:271
msgid "Basic SET TRANSACTION statement"
msgstr "Базовый оператор SET TRANSACTION"

#: ../doc/book/sql.rst:273
msgid "E152-01"
msgstr "E152-01"

#: ../doc/book/sql.rst:273
msgid "SET TRANSACTION statement ISOLATION SERIALIZABLE clause"
msgstr "Оператор SET TRANSACTION с выражением ISOLATION SERIALIZABLE"

#: ../doc/book/sql.rst:273
msgid "``set transaction isolation level serializable;``"
msgstr "``set transaction isolation level serializable;``"

#: ../doc/book/sql.rst:276
msgid "E152-02"
msgstr "E152-02"

#: ../doc/book/sql.rst:276
msgid "SET TRANSACTION statement READ ONLY and READ WRITE clauses"
msgstr "Оператор SET TRANSACTION с выражением READ ONLY и READ WRITE"

#: ../doc/book/sql.rst:276
msgid "``set transaction read only;``"
msgstr "``set transaction read only;``"

#: ../doc/book/sql.rst:279
msgid "E153"
msgstr "E153"

#: ../doc/book/sql.rst:279
msgid "Updatable queries with subqueries"
msgstr "Обновляемые запросы с подзапросами"

#: ../doc/book/sql.rst:281
msgid "E161"
msgstr "E161"

#: ../doc/book/sql.rst:281
msgid "SQL comments using leading double minus"
msgstr "Комментарии SQL с двойным ведущим знаком \"минус\""

#: ../doc/book/sql.rst:281
msgid "``--comment;``"
msgstr "``--comment;``"

#: ../doc/book/sql.rst:283
msgid "E171"
msgstr "E171"

#: ../doc/book/sql.rst:283
msgid "SQLSTATE support"
msgstr "Поддержка SQLSTATE"

#: ../doc/book/sql.rst:283
msgid "``drop table no_such_table;``"
msgstr "``drop table no_such_table;``"

#: ../doc/book/sql.rst:283
msgid "Fail. At least, the error message doesn't hint that SQLSTATE exists."
msgstr ""
"Не пройден. По крайней мере, сообщение об ошибке не указывает на "
"существование SQLSTATE. "

#: ../doc/book/sql.rst:286
msgid "E182"
msgstr "E182"

#: ../doc/book/sql.rst:286
msgid "Host language binding"
msgstr "Привязка к языку реализации"

#: ../doc/book/sql.rst:286
#, fuzzy
msgid ""
"Okay. Any of the Tarantool connectors should be able to call "
"``box.execute()``."
msgstr ""
"Пройден. Любые коннекторы Tarantool'а должны иметь возможность вызова "
"``box.sql.execute()``."

#: ../doc/book/sql.rst:289
msgid "F031"
msgstr "F031"

#: ../doc/book/sql.rst:289
msgid "Basic schema manipulation"
msgstr "Базовые операции со схемой"

#: ../doc/book/sql.rst:291
msgid "F031-01"
msgstr "F031-01"

#: ../doc/book/sql.rst:291
msgid "CREATE TABLE statement to create persistent base tables"
msgstr "Оператор CREATE TABLE для создания персистентных таблиц в базе"

#: ../doc/book/sql.rst:291
msgid "``create table t20 (t20_1 int not null);``"
msgstr "``create table t20 (t20_1 int not null);``"

#: ../doc/book/sql.rst:291
msgid "Fail. We always have to say PRIMARY KEY (we only count this flaw once)."
msgstr ""
"Не пройден. Всегда нужно вводить PRIMARY KEY (засчитываем эту ошибку "
"только один раз)."

#: ../doc/book/sql.rst:294
msgid "F031-02"
msgstr "F031-02"

#: ../doc/book/sql.rst:294
msgid "CREATE VIEW statement"
msgstr "Оператор CREATE VIEW"

#: ../doc/book/sql.rst:294
msgid "``create view t21 as select * from t20;``"
msgstr "``create view t21 as select * from t20;``"

#: ../doc/book/sql.rst:296
msgid "F031-03"
msgstr "F031-03"

#: ../doc/book/sql.rst:296 ../doc/book/sql.rst:400
msgid "GRANT statement"
msgstr "Оператор GRANT"

#: ../doc/book/sql.rst:296
msgid "Fail. Tarantool doesn't support privileges except via NoSQL."
msgstr ""
"Не пройден. Tarantool не поддерживает привилегии, кроме как с помощью "
"NoSQL."

#: ../doc/book/sql.rst:299
msgid "F031-04"
msgstr "F031-04"

#: ../doc/book/sql.rst:299
msgid "ALTER TABLE statement: add column"
msgstr "Оператор ALTER TABLE: добавить столбец"

#: ../doc/book/sql.rst:299
msgid "``alter table t7 add column t7_2 varchar default 'q';``"
msgstr "``alter table t7 add column t7_2 varchar default 'q';``"

#: ../doc/book/sql.rst:299
#, fuzzy
msgid "Fail. Table alterations work but not this clause."
msgstr "Не пройден. Изменения таблицы совсем не работают."

#: ../doc/book/sql.rst:301
msgid "F031-13"
msgstr "F031-13"

#: ../doc/book/sql.rst:301
msgid "DROP TABLE statement: RESTRICT clause"
msgstr "Оператор DROP TABLE: условие RESTRICT"

#: ../doc/book/sql.rst:301
msgid "``drop table t20 restrict;``"
msgstr "``drop table t20 restrict;``"

#: ../doc/book/sql.rst:301 ../doc/book/sql.rst:303
msgid "Fail. Syntax error, and RESTRICT is not assumed."
msgstr "Не пройден. Ошибка синтаксиса, RESTRICT не предполагается."

#: ../doc/book/sql.rst:303
msgid "F031-16"
msgstr "F031-16"

#: ../doc/book/sql.rst:303
msgid "DROP VIEW statement: RESTRICT clause"
msgstr "Оператор DROP VIEW: условие RESTRICT"

#: ../doc/book/sql.rst:303
msgid "``drop view v2 restrict;``"
msgstr "``drop view v2 restrict;``"

#: ../doc/book/sql.rst:305
msgid "F031-19"
msgstr "F031-19"

#: ../doc/book/sql.rst:305
msgid "REVOKE statement: RESTRICT clause"
msgstr "Оператор REVOKE: условие RESTRICT"

#: ../doc/book/sql.rst:305
msgid "Fail. Tarantool does not support privileges except via NoSQL."
msgstr ""
"Не пройден. Tarantool не поддерживает привилегии, кроме как с помощью "
"NoSQL."

#: ../doc/book/sql.rst:308
msgid "F041"
msgstr "F041"

#: ../doc/book/sql.rst:308
msgid "Basic joined table"
msgstr "Базовые объединения таблиц"

#: ../doc/book/sql.rst:310
msgid "F041-01"
msgstr "F041-01"

#: ../doc/book/sql.rst:310
msgid "Inner join but not necessarily the INNER keyword"
msgstr "Внутреннее объединение, но необязательно с ключевым словом INNER"

#: ../doc/book/sql.rst:310
msgid "``select a.s1 from t7 a join t7 b;``"
msgstr "``select a.s1 from t7 a join t7 b;``"

#: ../doc/book/sql.rst:313
msgid "F041-02"
msgstr "F041-02"

#: ../doc/book/sql.rst:313
msgid "INNER keyword"
msgstr "Ключевое слово INNER"

#: ../doc/book/sql.rst:313
msgid "``select a.s1 from t7 a inner join t7 b;``"
msgstr "``select a.s1 from t7 a inner join t7 b;``"

#: ../doc/book/sql.rst:315
msgid "F041-03"
msgstr "F041-03"

#: ../doc/book/sql.rst:315
msgid "LEFT OUTER JOIN"
msgstr "LEFT OUTER JOIN"

#: ../doc/book/sql.rst:315
msgid "``select t7.*,t22.* from t22 left outer join t7 on (t22_1=s1);``"
msgstr "``select t7.*,t22.* from t22 left outer join t7 on (t22_1=s1);``"

#: ../doc/book/sql.rst:318
msgid "F041-04"
msgstr "F041-04"

#: ../doc/book/sql.rst:318
msgid "RIGHT OUTER JOIN"
msgstr "RIGHT OUTER JOIN"

#: ../doc/book/sql.rst:318
msgid "``select t7.*,t22.* from t22 right outer join t7 on (t22_1=s1);``"
msgstr "``select t7.*,t22.* from t22 right outer join t7 on (t22_1=s1);``"

#: ../doc/book/sql.rst:321
msgid "F041-05"
msgstr "F041-05"

#: ../doc/book/sql.rst:321
msgid "Outer joins can be nested"
msgstr "Внешнее объединение может быть вложенным"

#: ../doc/book/sql.rst:321
msgid ""
"``select t7.*,t22.* from t22 left outer join t7 on (t22_1=s1) left outer "
"join t23;``."
msgstr ""
"``select t7.*,t22.* from t22 left outer join t7 on (t22_1=s1) left outer "
"join t23;``."

#: ../doc/book/sql.rst:324
msgid "F041-07"
msgstr "F041-07"

#: ../doc/book/sql.rst:324
msgid ""
"The inner table in a left or right outer join can also be used in an "
"inner join"
msgstr ""
"Внутренняя таблица в левом или правом внешнем объединении также может "
"использоваться во внутреннем объединении"

#: ../doc/book/sql.rst:324
msgid ""
"``select t7.* from t22 left outer join t7 on (t22_1=s1) inner join t22 on"
" (t22_4=t22_5);``"
msgstr ""
"``select t7.* from t22 left outer join t7 on (t22_1=s1) inner join t22 on"
" (t22_4=t22_5);``"

#: ../doc/book/sql.rst:324
msgid "Okay. The query fails due to a syntax error but that's expectable."
msgstr ""
"Пройден. Запрос завершается ошибкой по причине ошибки синтаксиса, но это "
"ожидаемо."

#: ../doc/book/sql.rst:327
msgid "F041-08"
msgstr "F041-08"

#: ../doc/book/sql.rst:327
msgid "All comparison operators are supported"
msgstr "Поддерживаются все операторы сравнения"

#: ../doc/book/sql.rst:327
msgid "``select * from t where 0=1 or 0>1 or 0<1 or 0<>1;``"
msgstr "``select * from t where 0=1 or 0>1 or 0<1 or 0<>1;``"

#: ../doc/book/sql.rst:329
msgid "F051 Basic date and time"
msgstr "F051 Базовые дата и время"

#: ../doc/book/sql.rst:331
msgid "F051-01"
msgstr "F051-01"

#: ../doc/book/sql.rst:331
msgid "DATE data type (including support of DATE literal)"
msgstr "Тип данных DATE (включая поддержку литерала DATE)"

#: ../doc/book/sql.rst:331
msgid "``create table dates (s1 date);``"
msgstr "``create table dates (s1 date);``"

#: ../doc/book/sql.rst:331
msgid "Fail. Tarantool does not support DATE data type."
msgstr "Не пройден. Tarantool не поддерживает тип DATE."

#: ../doc/book/sql.rst:334
msgid "F051-02"
msgstr "F051-02"

#: ../doc/book/sql.rst:334
msgid "TIME data type (including support of TIME literal)"
msgstr "Тип данных TIME (включая поддержку литерала TIME)"

#: ../doc/book/sql.rst:334
msgid "``create table times (s1 time default time '1:2:3');``"
msgstr "``create table times (s1 time default time '1:2:3');``"

#: ../doc/book/sql.rst:337
msgid "F051-03"
msgstr "F051-03"

#: ../doc/book/sql.rst:337
msgid "TIMESTAMP data type (including support of TIMESTAMP literal)"
msgstr "Тип данных TIMESTAMP (включая поддержку литерала TIMESTAMP)"

#: ../doc/book/sql.rst:337
msgid "``create table timestamps (s1 timestamp);``"
msgstr "``create table timestamps (s1 timestamp);``"

#: ../doc/book/sql.rst:340
msgid "F051-04"
msgstr "F051-04"

#: ../doc/book/sql.rst:340
msgid "Comparison predicate on DATE, TIME and TIMESTAMP data types"
msgstr "Предикат сравнения по типам данных DATE, TIME и TIMESTAMP"

#: ../doc/book/sql.rst:340
msgid "``select * from dates where s1 = s1;``"
msgstr "``select * from dates where s1 = s1;``"

#: ../doc/book/sql.rst:340 ../doc/book/sql.rst:343
msgid "Fail. The data types are not supported."
msgstr ""

#: ../doc/book/sql.rst:343
msgid "F051-05"
msgstr "F051-05"

#: ../doc/book/sql.rst:343
msgid "Explicit CAST between date-time types and character string types"
msgstr "Явный CAST между типами даты и времени и типами символьных строк"

#: ../doc/book/sql.rst:343
msgid "``select cast(s1 as varchar(10)) from dates;``"
msgstr "``select cast(s1 as varchar(10)) from dates;``"

#: ../doc/book/sql.rst:346
msgid "F051-06"
msgstr "F051-06"

#: ../doc/book/sql.rst:346
msgid "CURRENT_DATE"
msgstr "CURRENT_DATE"

#: ../doc/book/sql.rst:346
msgid "``select current_date from t;``"
msgstr "``select current_date from t;``"

#: ../doc/book/sql.rst:348
msgid "F051-07"
msgstr "F051-07"

#: ../doc/book/sql.rst:348
msgid "CURRENT_TIME"
msgstr "CURRENT_TIME"

#: ../doc/book/sql.rst:348
msgid "``select * from t where current_time < '23:23:23';``"
msgstr "``select * from t where current_time < '23:23:23';``"

#: ../doc/book/sql.rst:350
msgid "F051-08"
msgstr "F051-08"

#: ../doc/book/sql.rst:350
msgid "LOCALTIME"
msgstr "LOCALTIME"

#: ../doc/book/sql.rst:350
msgid "``select localtime from t;``"
msgstr "``select localtime from t;``"

#: ../doc/book/sql.rst:352
msgid "F051-09"
msgstr "F051-09"

#: ../doc/book/sql.rst:352
msgid "LOCALTIMESTAMP"
msgstr "LOCALTIMESTAMP"

#: ../doc/book/sql.rst:352
msgid "``select localtimestamp from t;``"
msgstr "``select localtimestamp from t;``"

#: ../doc/book/sql.rst:354
msgid "F081"
msgstr "F081"

#: ../doc/book/sql.rst:354
msgid "UNION and EXCEPT in views"
msgstr "UNION и EXCEPT в представлениях"

#: ../doc/book/sql.rst:354
msgid "``create view vv as select * from t7 except select * from t15;``"
msgstr "``create view vv as select * from t7 except select * from t15;``"

#: ../doc/book/sql.rst:357
msgid "F131"
msgstr "F131"

#: ../doc/book/sql.rst:357
msgid "Grouped operations"
msgstr "Групповые операции"

#: ../doc/book/sql.rst:359
msgid "F131-01"
msgstr "F131-01"

#: ../doc/book/sql.rst:359
msgid ""
"WHERE, GROUP BY, and HAVING clauses supported in queries with grouped "
"views"
msgstr ""
"Поддержка условий WHERE, GROUP BY и HAVING в запросах с групповыми "
"представлениями"

#: ../doc/book/sql.rst:359
msgid "``create view vv2 as select * from vv group by s1;``"
msgstr "``create view vv2 as select * from vv group by s1;``"

#: ../doc/book/sql.rst:362
msgid "F131-02"
msgstr "F131-02"

#: ../doc/book/sql.rst:362
msgid "Multiple tables supported in queries with grouped views"
msgstr "Поддержка множества таблиц в запросах с групповыми представлениями"

#: ../doc/book/sql.rst:362
msgid "``create view vv3 as select * from vv2,t30;``"
msgstr "``create view vv3 as select * from vv2,t30;``"

#: ../doc/book/sql.rst:365
msgid "F131-03"
msgstr "F131-03"

#: ../doc/book/sql.rst:365
msgid "Set functions supported in queries with grouped views"
msgstr "Поддержка функций множеств в запросах с групповыми представлениями"

#: ../doc/book/sql.rst:365
msgid "``create view vv4 as select count(*) from vv2;``"
msgstr "``create view vv4 as select count(*) from vv2;``"

#: ../doc/book/sql.rst:368
msgid "F131-04"
msgstr "F131-04"

#: ../doc/book/sql.rst:368
msgid "Subqueries with GROUP BY and HAVING clauses and grouped views"
msgstr "Подзапросы с условиями GROUP BY и HAVING и групповыми представлениями"

#: ../doc/book/sql.rst:368
msgid ""
"``create view vv5 as select count(*) from vv2 group by s1 having count(*)"
" > 0;``"
msgstr ""
"``create view vv5 as select count(*) from vv2 group by s1 having count(*)"
" > 0;``"

#: ../doc/book/sql.rst:371
msgid "F181"
msgstr "F181"

#: ../doc/book/sql.rst:371
msgid "Multiple module support"
msgstr "Поддержка множества модулей"

#: ../doc/book/sql.rst:371
msgid "Fail. Tarantool doesn't have modules."
msgstr "Не пройден. Tarantool не поддерживает модули."

#: ../doc/book/sql.rst:373
msgid "F201"
msgstr "F201"

#: ../doc/book/sql.rst:373
msgid "CAST function"
msgstr "Функция CAST"

#: ../doc/book/sql.rst:373
msgid "``select cast(s1 as int) from t;``"
msgstr "``select cast(s1 as int) from t;``"

#: ../doc/book/sql.rst:375
msgid "F221"
msgstr "F221"

#: ../doc/book/sql.rst:375
msgid "Explicit defaults"
msgstr "Явно заданные значения по умолчанию"

#: ../doc/book/sql.rst:375
msgid "``update t set s1 = default;``"
msgstr "``update t set s1 = default;``"

#: ../doc/book/sql.rst:377
msgid "F261"
msgstr "F261"

#: ../doc/book/sql.rst:377
msgid "CASE expression"
msgstr "Оператор CASE"

#: ../doc/book/sql.rst:379
msgid "F261-01"
msgstr "F261-01"

#: ../doc/book/sql.rst:379
msgid "Simple CASE"
msgstr "Простой CASE"

#: ../doc/book/sql.rst:379
msgid "``select case when 1 = 0 then 5 else 7 end from t;``"
msgstr "``select case when 1 = 0 then 5 else 7 end from t;``"

#: ../doc/book/sql.rst:381
msgid "F261-02"
msgstr "F261-02"

#: ../doc/book/sql.rst:381
msgid "Searched CASE"
msgstr "CASE с поиском"

#: ../doc/book/sql.rst:381
msgid "``select case 1 when 0 then 5 else 7 end from t;``"
msgstr "``select case 1 when 0 then 5 else 7 end from t;``"

#: ../doc/book/sql.rst:383
msgid "F261-03"
msgstr "F261-03"

#: ../doc/book/sql.rst:383
msgid "NULLIF"
msgstr "NULLIF"

#: ../doc/book/sql.rst:383
msgid "``select nullif(s1,7) from t;``"
msgstr "``select nullif(s1,7) from t;``"

#: ../doc/book/sql.rst:385
msgid "F261-04"
msgstr "F261-04"

#: ../doc/book/sql.rst:385
msgid "COALESCE"
msgstr "COALESCE"

#: ../doc/book/sql.rst:385
msgid "``select coalesce(s1,7) from t;``"
msgstr "``select coalesce(s1,7) from t;``"

#: ../doc/book/sql.rst:387
msgid "F311"
msgstr "F311"

#: ../doc/book/sql.rst:387
msgid "Schema definition statement"
msgstr "Оператор определения схемы"

#: ../doc/book/sql.rst:389
msgid "F311-01"
msgstr "F311-01"

#: ../doc/book/sql.rst:389
msgid "CREATE SCHEMA"
msgstr "CREATE SCHEMA"

#: ../doc/book/sql.rst:389
msgid "Fail. Tarantool doesn't have schemas or databases."
msgstr "Не пройден. В Tarantool'е нет схем или баз данных."

#: ../doc/book/sql.rst:391
msgid "F311-02"
msgstr "F311-02"

#: ../doc/book/sql.rst:391
msgid "CREATE TABLE for persistent base tables"
msgstr "CREATE TABLE для персистентых базовых таблиц"

#: ../doc/book/sql.rst:391
msgid "Fail. Tarantool doesn't have CREATE TABLE inside CREATE SCHEMA."
msgstr "Не пройден. В Tarantool'е нет CREATE TABLE в CREATE SCHEMA."

#: ../doc/book/sql.rst:394
msgid "F311-03"
msgstr "F311-03"

#: ../doc/book/sql.rst:394
msgid "CREATE VIEW"
msgstr "CREATE VIEW"

#: ../doc/book/sql.rst:394 ../doc/book/sql.rst:397
msgid "Fail. Tarantool doesn't have CREATE VIEW inside CREATE SCHEMA."
msgstr "Не пройден. В Tarantool'е нет CREATE VIEW в CREATE SCHEMA."

#: ../doc/book/sql.rst:397
msgid "F311-04"
msgstr "F311-04"

#: ../doc/book/sql.rst:397
msgid "CREATE VIEW: WITH CHECK OPTION"
msgstr "CREATE VIEW: WITH CHECK OPTION"

#: ../doc/book/sql.rst:400
msgid "F311-05"
msgstr "F311-05"

#: ../doc/book/sql.rst:400
msgid "Fail. Tarantool doesn't have GRANT inside CREATE SCHEMA."
msgstr "Не пройден. В Tarantool'е нет GRANT в CREATE SCHEMA."

#: ../doc/book/sql.rst:403
msgid "F471"
msgstr "F471"

#: ../doc/book/sql.rst:403
msgid "Scalar subquery values"
msgstr "Скалярные значения в подзапросе"

#: ../doc/book/sql.rst:403
msgid "``select s1 from t where s1 = (select count(*) from t);``"
msgstr "``select s1 from t where s1 = (select count(*) from t);``"

#: ../doc/book/sql.rst:405
msgid "F481"
msgstr "F481"

#: ../doc/book/sql.rst:405
msgid "Expanded NULL Predicate"
msgstr "Расширенный предикат NULL"

#: ../doc/book/sql.rst:405
msgid "``select * from t where row(s1,s1) is not null;``"
msgstr "``select * from t where row(s1,s1) is not null;``"

#: ../doc/book/sql.rst:407
msgid "F812"
msgstr "F812"

#: ../doc/book/sql.rst:407
msgid "Basic flagging"
msgstr "Базовое выделение флагами"

#: ../doc/book/sql.rst:407
msgid "Fail. Tarantool doesn't support any flagging."
msgstr "Не пройден. Tarantool не поддерживает выделение флагами."

#: ../doc/book/sql.rst:409
msgid "S011"
msgstr "S011"

#: ../doc/book/sql.rst:409
msgid "Distinct types"
msgstr "Отдельные типы"

#: ../doc/book/sql.rst:409
msgid "``create type x as float;``"
msgstr "``create type x as float;``"

#: ../doc/book/sql.rst:409
msgid "Fail. Tarantool doesn't support distinct types."
msgstr "Не пройден. Tarantool не поддерживает отдельные типы."

#: ../doc/book/sql.rst:411
msgid "T321"
msgstr "T321"

#: ../doc/book/sql.rst:411
msgid "Basic SQL-invoked routines"
msgstr "Базовые процедуры с помощью SQL  "

#: ../doc/book/sql.rst:413
msgid "T321-01"
msgstr "T321-01"

#: ../doc/book/sql.rst:413
msgid "User-defined functions with no overloading"
msgstr "Пользовательские функции без перегрузки"

#: ../doc/book/sql.rst:413
msgid "``create function f () returns int return 5;``"
msgstr "``create function f () returns int return 5;``"

#: ../doc/book/sql.rst:413
msgid "Fail. Tarantool doesn't support user-defined SQL functions."
msgstr ""
"Не пройден. Tarantool не поддерживает пользовательские функции на языке "
"SQL."

#: ../doc/book/sql.rst:416
msgid "T321-02"
msgstr "T321-02"

#: ../doc/book/sql.rst:416
msgid "User-defined procedures with no overloading"
msgstr "Пользовательские процедуры без перегрузки"

#: ../doc/book/sql.rst:416
msgid "``create procedure p () begin end;``"
msgstr "``create procedure p () begin end;``"

#: ../doc/book/sql.rst:416 ../doc/book/sql.rst:421
msgid "Fail. Tarantool doesn't support user-defined procedures."
msgstr "Не пройден. Tarantool не поддерживает пользовательские процедуры."

#: ../doc/book/sql.rst:419
msgid "T321-03"
msgstr "T321-03"

#: ../doc/book/sql.rst:419
msgid "Function invocation"
msgstr "Вызов функции"

#: ../doc/book/sql.rst:419
msgid "``select f(1) from t;``"
msgstr "``select f(1) from t;``"

#: ../doc/book/sql.rst:419
msgid "Okay. Tarantool can invoke Lua user-defined functions."
msgstr "Пройден. Tarantool может вызывать пользовательские Lua-функции."

#: ../doc/book/sql.rst:421
msgid "T321-04"
msgstr "T321-04"

#: ../doc/book/sql.rst:421
msgid "CALL statement."
msgstr "Оператор CALL."

#: ../doc/book/sql.rst:421
msgid "``call p();``"
msgstr "``call p();``"

#: ../doc/book/sql.rst:424
msgid "T321-05"
msgstr "T321-05"

#: ../doc/book/sql.rst:424
msgid "RETURN statement."
msgstr "Оператор RETURN."

#: ../doc/book/sql.rst:424
msgid "``create function f() returns int return 5;``"
msgstr "``create function f() returns int return 5;``"

#: ../doc/book/sql.rst:424
msgid "Fail. Tarantool doesn't support user-defined functions."
msgstr "Не пройден. Tarantool не поддерживает пользовательские функции."

#: ../doc/book/sql.rst:427
msgid "T631"
msgstr "T631"

#: ../doc/book/sql.rst:427
msgid "IN predicate with one list element"
msgstr "Предикат IN с одним элементом списка"

#: ../doc/book/sql.rst:427
msgid "``select * from t where 1 in (1);``"
msgstr "``select * from t where 1 in (1);``"

#: ../doc/book/sql.rst:429
msgid "F021"
msgstr "F021"

#: ../doc/book/sql.rst:429
msgid "Basic information schema"
msgstr "Базовая информационная схема"

#: ../doc/book/sql.rst:429
msgid "``select * from information_schema.tables;``"
msgstr "``select * from information_schema.tables;``"

#: ../doc/book/sql.rst:429
msgid "Fail. There is no schema with that name (not counted in the final score)."
msgstr ""
"Не пройден. Нет схемы с таким именем (не учитывается при окончательном "
"подсчете)."

#: ../doc/book/sql.rst:433
msgid "Total number of items marked \"Fail\": 69"
msgstr "Общее количество пунктов, отмеченных \"Не пройден\": 69"

#: ../doc/book/sql.rst:435
msgid "Total number of items marked \"Okay\": 77"
msgstr "Общее количество пунктов, отмеченных \"Пройден\": 77"

#~ msgid "backup.start() and backup.stop()"
#~ msgstr "Функции backup.start() и backup.stop()"

#~ msgid ""
#~ "tarantool> box.backup.start()\n"
#~ "---\n"
#~ "- - ./00000000000000000015.snap\n"
#~ "  - ./00000000000000000000.vylog\n"
#~ "  - ./513/0/00000000000000000002.index\n"
#~ "  - ./513/0/00000000000000000002.run\n"
#~ "..."
#~ msgstr ""
#~ "tarantool> box.backup.start()\n"
#~ "---\n"
#~ "- - ./00000000000000000015.snap\n"
#~ "  - ./00000000000000000000.vylog\n"
#~ "  - ./513/0/00000000000000000002.index\n"
#~ "  - ./513/0/00000000000000000002.run\n"
#~ "..."

#~ msgid ""
#~ "To guarantee an opportunity to copy "
#~ "these files Tarantool will not delete"
#~ " them. But there will be no "
#~ "read-only mode and checkpoints will "
#~ "continue by schedule as usual."
#~ msgstr ""
#~ "Чтобы обеспечить возможность копирования этих"
#~ " файлов, Tarantool не будет их "
#~ "удалять. Но не будет никакого режима "
#~ "только для чтения, и создание "
#~ "контрольных точек будет идти по "
#~ "расписанию, как обычно."

#~ msgid ""
#~ "Later ``box.backup.stop()`` informs the server"
#~ " that normal operations may resume. "
#~ "Starting with Tarantool 1.10.1 there is"
#~ " a new optional argument, "
#~ "``box.backup.start(n)``, where ``n`` indicates "
#~ "the checkpoint to use relative to "
#~ "the latest checkpoint -- for example "
#~ "``n = 0`` means \"backup will be"
#~ " based on the latest checkpoint\", "
#~ "``n = 1`` means \"backup will be"
#~ " based on the first checkpoint before"
#~ " the latest checkpoint (counting "
#~ "backwards)\", and so on, and the "
#~ "default value for ``n`` is zero."
#~ msgstr ""
#~ "Затем ``box.backup.stop()`` сообщает серверу, "
#~ "что можно возобновить нормальную работу. "
#~ "Начиная с версии Tarantool'а 1.10.1, "
#~ "добавлен необязательный аргумент "
#~ "``box.backup.start(n)``, где ``n`` обозначает "
#~ "используемую контрольную точку относительно "
#~ "последней контрольной точки --  например, "
#~ "``n = 0`` означает, что резервное "
#~ "копирование будет выполняться по последней "
#~ "контрольной точке, ``n = 1`` означает,"
#~ " что резервное копирование будет "
#~ "выполняться по первой контрольной точке "
#~ "от последней контрольной точки (счет в"
#~ " обратном порядке)\" и так далее, а"
#~ " по умолчанию для ``n`` используется "
#~ "ноль."

#~ msgid ""
#~ "Put all nodes in :ref:`read-only "
#~ "mode <cfg_basic-read_only>` and disable "
#~ "checkpointing with :ref:`box.backup.start() "
#~ "<admin-backups-backup_start>`. Disabling the "
#~ "checkpointing is necessary to prevent "
#~ "the Tarantool garbage collector from "
#~ "removing files made with older "
#~ "checkpoints."
#~ msgstr ""
#~ "Переключите все узлы в :ref:`режим "
#~ "только для чтения <cfg_basic-read_only>` "
#~ "и отключите командой :ref:`box.backup.start() "
#~ "<admin-backups-backup_start>` создание "
#~ "контрольных точек. Последнее действие "
#~ "необходимо, чтобы сборщик мусора автоматически"
#~ " не удалил более старые контрольные "
#~ "точки."

#~ msgid ""
#~ "**replication.downstream.status** ``= disconnected`` "
#~ "is displayed if the downstream instance"
#~ " disconnects from the upstream instance."
#~ " Otherwise the status is not "
#~ "reported."
#~ msgstr ""
#~ "**replication.downstream.status** ``= disconnected`` "
#~ "отображается, если последующий экземпляр "
#~ "отключается от предыдущего. В остальных "
#~ "случаях такой статус не отображается."

#~ msgid "``_space`` is a system space."
#~ msgstr "``_space`` -- это системный спейс."

#~ msgid "To upgrade from Tarantool 1.6 to 1.7 (or to 1.10.x):"
#~ msgstr "Чтобы обновить Tarantool 1.6 до 1.7 (или до 1.10.x):"

#~ msgid ""
#~ "$ tarantool myapp.lua\n"
#~ "Hello, world!\n"
#~ "2016-12-19 16:07:14.250 [41436] main/101/myapp.lua"
#~ " C> version 1.7.2-146-g021d36b\n"
#~ "2016-12-19 16:07:14.250 [41436] main/101/myapp.lua C> log level 5\n"
#~ "2016-12-19 16:07:14.251 [41436] main/101/myapp.lua"
#~ " I> mapping 1073741824 bytes for "
#~ "tuple arena...\n"
#~ "2016-12-19 16:07:14.255 [41436] main/101/myapp.lua I> recovery start\n"
#~ "2016-12-19 16:07:14.255 [41436] main/101/myapp.lua"
#~ " I> recovering from `./00000000000000000000.snap'"
#~ "\n"
#~ "2016-12-19 16:07:14.271 [41436] main/101/myapp.lua"
#~ " I> recover from `./00000000000000000000.xlog'"
#~ "\n"
#~ "2016-12-19 16:07:14.271 [41436] main/101/myapp.lua"
#~ " I> done `./00000000000000000000.xlog'\n"
#~ "2016-12-19 16:07:14.272 [41436] main/102/hot_standby"
#~ " I> recover from `./00000000000000000000.xlog'"
#~ "\n"
#~ "2016-12-19 16:07:14.274 [41436] iproto/102/iproto I> binary: started\n"
#~ "2016-12-19 16:07:14.275 [41436] iproto/102/iproto"
#~ " I> binary: bound to [::]:3301\n"
#~ "2016-12-19 16:07:14.275 [41436] main/101/myapp.lua"
#~ " I> done `./00000000000000000000.xlog'\n"
#~ "2016-12-19 16:07:14.278 [41436] main/101/myapp.lua"
#~ " I> ready to accept requests"
#~ msgstr ""
#~ "$ tarantool myapp.lua\n"
#~ "Hello, world!\n"
#~ "2016-12-19 16:07:14.250 [41436] main/101/myapp.lua"
#~ " C> version 1.7.2-146-g021d36b\n"
#~ "2016-12-19 16:07:14.250 [41436] main/101/myapp.lua C> log level 5\n"
#~ "2016-12-19 16:07:14.251 [41436] main/101/myapp.lua"
#~ " I> mapping 1073741824 bytes for "
#~ "tuple arena...\n"
#~ "2016-12-19 16:07:14.255 [41436] main/101/myapp.lua I> recovery start\n"
#~ "2016-12-19 16:07:14.255 [41436] main/101/myapp.lua"
#~ " I> recovering from `./00000000000000000000.snap'"
#~ "\n"
#~ "2016-12-19 16:07:14.271 [41436] main/101/myapp.lua"
#~ " I> recover from `./00000000000000000000.xlog'"
#~ "\n"
#~ "2016-12-19 16:07:14.271 [41436] main/101/myapp.lua"
#~ " I> done `./00000000000000000000.xlog'\n"
#~ "2016-12-19 16:07:14.272 [41436] main/102/hot_standby"
#~ " I> recover from `./00000000000000000000.xlog'"
#~ "\n"
#~ "2016-12-19 16:07:14.274 [41436] iproto/102/iproto I> binary: started\n"
#~ "2016-12-19 16:07:14.275 [41436] iproto/102/iproto"
#~ " I> binary: bound to [::]:3301\n"
#~ "2016-12-19 16:07:14.275 [41436] main/101/myapp.lua"
#~ " I> done `./00000000000000000000.xlog'\n"
#~ "2016-12-19 16:07:14.278 [41436] main/101/myapp.lua"
#~ " I> ready to accept requests"

#~ msgid ""
#~ "The first call to ``box.cfg{...}`` (with"
#~ " or without parameters) initiates "
#~ "Tarantool's database module :ref:`box <box-"
#~ "module>`. To perform any database "
#~ "operations, you must call ``box.cfg{...}`` "
#~ "first."
#~ msgstr ""
#~ "Первый вызов ``box.cfg{...}`` (с параметрами"
#~ " или без них) запускает модуль базы"
#~ " данных Tarantool'а под названием :ref:`box"
#~ " <box-module>`. Чтобы выполнить любые "
#~ "операции с базой данных, необходимо "
#~ "сначала вызвать ``box.cfg{...}``."

#~ msgid ""
#~ "tarantool> box.info()\n"
#~ "---\n"
#~ "- version: 1.7.6-68-g51fcffb77\n"
#~ "  id: 2\n"
#~ "  ro: true\n"
#~ "  vclock: {1: 5}\n"
#~ "  uptime: 917\n"
#~ "  lsn: 0\n"
#~ "  vinyl: []\n"
#~ "  cluster:\n"
#~ "    uuid: 783e2285-55b1-42d4-b93c-68dcbb7a8c18\n"
#~ "  pid: 35341\n"
#~ "  status: running\n"
#~ "  signature: 5\n"
#~ "  replication:\n"
#~ "    1:\n"
#~ "      id: 1\n"
#~ "      uuid: 471cd36e-cb2e-4447-ac66-2d28e9dd3b67\n"
#~ "      lsn: 5\n"
#~ "      upstream:\n"
#~ "        status: follow\n"
#~ "        idle: 124.98795700073\n"
#~ "        peer: replicator@192.168.0.101:3301\n"
#~ "        lag: 0\n"
#~ "      downstream:\n"
#~ "        vclock: {1: 5}\n"
#~ "    2:\n"
#~ "      id: 2\n"
#~ "      uuid: ac45d5d2-8a16-4520-ad5e-1abba6baba0a\n"
#~ "      lsn: 0\n"
#~ "  uuid: ac45d5d2-8a16-4520-ad5e-1abba6baba0a\n"
#~ "..."
#~ msgstr ""
#~ "tarantool> box.info()\n"
#~ "---\n"
#~ "- version: 1.7.6-68-g51fcffb77\n"
#~ "  id: 2\n"
#~ "  ro: true\n"
#~ "  vclock: {1: 5}\n"
#~ "  uptime: 917\n"
#~ "  lsn: 0\n"
#~ "  vinyl: []\n"
#~ "  cluster:\n"
#~ "    uuid: 783e2285-55b1-42d4-b93c-68dcbb7a8c18\n"
#~ "  pid: 35341\n"
#~ "  status: running\n"
#~ "  signature: 5\n"
#~ "  replication:\n"
#~ "    1:\n"
#~ "      id: 1\n"
#~ "      uuid: 471cd36e-cb2e-4447-ac66-2d28e9dd3b67\n"
#~ "      lsn: 5\n"
#~ "      upstream:\n"
#~ "        status: follow\n"
#~ "        idle: 124.98795700073\n"
#~ "        peer: replicator@192.168.0.101:3301\n"
#~ "        lag: 0\n"
#~ "      downstream:\n"
#~ "        vclock: {1: 5}\n"
#~ "    2:\n"
#~ "      id: 2\n"
#~ "      uuid: ac45d5d2-8a16-4520-ad5e-1abba6baba0a\n"
#~ "      lsn: 0\n"
#~ "  uuid: ac45d5d2-8a16-4520-ad5e-1abba6baba0a\n"
#~ "..."

#~ msgid ""
#~ "The display of slabs is broken "
#~ "down by the slab size -- 64-byte,"
#~ " 136-byte, and so on. The example "
#~ "omits the slabs which are empty. "
#~ "The example display is saying that: "
#~ "* there are 16 items stored in "
#~ "the 64-byte slab (and 16*64=102 so "
#~ "bytes_used = 1024); * there is 1"
#~ " item stored in the 136-byte slab "
#~ "(and 136*1=136 so bytes_used = 136); "
#~ "* the ``arena_used`` value is the "
#~ "total of all the bytes_used values "
#~ "(1024+136 = 1160); * the ``arena_size``"
#~ " value is the ``arena_used`` value "
#~ "plus the total of all the"
#~ msgstr ""
#~ "Отображение slab разбито по размеру slab"
#~ " -- 64 байта, 136 байтов и т.д."
#~ " В примере пропущены пустые slab, а"
#~ " показывается, что: * есть 16 "
#~ "элементов, которые хранятся в 64-байтном "
#~ "slab (и 16*64=102, то есть количество"
#~ " использованных байтов bytes_used = 1024);"
#~ " * есть 1 элемент, который хранится"
#~ " в 136-байтном slab (и 136*1=136, то"
#~ " есть количество использованных байтов "
#~ "bytes_used = 136); * значение "
#~ "``arena_used`` представляет собой общее "
#~ "количество всех значений bytes_used (1024+136"
#~ " = 1160); * значение ``arena_size`` "
#~ "-- это значение ``arena_used`` плюс "
#~ "общее количество всех"

#~ msgid "bytes_free values (1160+4193200+4194088 = 8388448)."
#~ msgstr "значений незанятых байтов bytes_free (1160+4193200+4194088 = 8388448)."

#~ msgid ""
#~ "tarantool> type(box.stat), type(box.stat.net) -- virtual tables\n"
#~ "---\n"
#~ "- table\n"
#~ "- table\n"
#~ "...\n"
#~ "tarantool> box.stat, box.stat.net\n"
#~ "---\n"
#~ "- net: []\n"
#~ "- []\n"
#~ "...\n"
#~ "tarantool> box.stat()\n"
#~ "---\n"
#~ "- DELETE:\n"
#~ "    total: 1873949\n"
#~ "    rps: 123\n"
#~ "  SELECT:\n"
#~ "    total: 1237723\n"
#~ "    rps: 4099\n"
#~ "  INSERT:\n"
#~ "    total: 0\n"
#~ "    rps: 0\n"
#~ "  EVAL:\n"
#~ "    total: 0\n"
#~ "    rps: 0\n"
#~ "  CALL:\n"
#~ "    total: 0\n"
#~ "    rps: 0\n"
#~ "  REPLACE:\n"
#~ "    total: 1239123\n"
#~ "    rps: 7849\n"
#~ "  UPSERT:\n"
#~ "    total: 0\n"
#~ "    rps: 0\n"
#~ "  AUTH:\n"
#~ "    total: 0\n"
#~ "    rps: 0\n"
#~ "  ERROR:\n"
#~ "    total: 0\n"
#~ "    rps: 0\n"
#~ "  UPDATE:\n"
#~ "    total: 0\n"
#~ "    rps: 0\n"
#~ "...\n"
#~ "tarantool> box.stat().DELETE -- a selected item of the table\n"
#~ "---\n"
#~ "- total: 0\n"
#~ "  rps: 0\n"
#~ "...\n"
#~ "tarantool> box.stat.net()\n"
#~ "---\n"
#~ "- SENT:\n"
#~ "    total: 0\n"
#~ "    rps: 0\n"
#~ "  RECEIVED:\n"
#~ "    total: 0\n"
#~ "    rps: 0\n"
#~ "..."
#~ msgstr ""
#~ "tarantool> type(box.stat), type(box.stat.net) -- виртуальные таблицы\n"
#~ "---\n"
#~ "- table\n"
#~ "- table\n"
#~ "...\n"
#~ "tarantool> box.stat, box.stat.net\n"
#~ "---\n"
#~ "- net: []\n"
#~ "- []\n"
#~ "...\n"
#~ "tarantool> box.stat()\n"
#~ "---\n"
#~ "- DELETE:\n"
#~ "    total: 1873949\n"
#~ "    rps: 123\n"
#~ "  SELECT:\n"
#~ "    total: 1237723\n"
#~ "    rps: 4099\n"
#~ "  INSERT:\n"
#~ "    total: 0\n"
#~ "    rps: 0\n"
#~ "  EVAL:\n"
#~ "    total: 0\n"
#~ "    rps: 0\n"
#~ "  CALL:\n"
#~ "    total: 0\n"
#~ "    rps: 0\n"
#~ "  REPLACE:\n"
#~ "    total: 1239123\n"
#~ "    rps: 7849\n"
#~ "  UPSERT:\n"
#~ "    total: 0\n"
#~ "    rps: 0\n"
#~ "  AUTH:\n"
#~ "    total: 0\n"
#~ "    rps: 0\n"
#~ "  ERROR:\n"
#~ "    total: 0\n"
#~ "    rps: 0\n"
#~ "  UPDATE:\n"
#~ "    total: 0\n"
#~ "    rps: 0\n"
#~ "...\n"
#~ "tarantool> box.stat().DELETE -- выбранный элемент таблицы\n"
#~ "---\n"
#~ "- total: 0\n"
#~ "  rps: 0\n"
#~ "...\n"
#~ "tarantool> box.stat.net()\n"
#~ "---\n"
#~ "- SENT:\n"
#~ "    total: 0\n"
#~ "    rps: 0\n"
#~ "  RECEIVED:\n"
#~ "    total: 0\n"
#~ "    rps: 0\n"
#~ "..."

#~ msgid ""
#~ "Return a description of a user's "
#~ ":ref:`privileges <authentication-owners_privileges>`. "
#~ "For explanation of how Tarantool "
#~ "maintains user data, see section "
#~ ":ref:`Users <authentication-users>` and "
#~ "reference on :ref:`_user <box_space-user>` "
#~ "space."
#~ msgstr ""
#~ "Возврат описания :ref:`прав <authentication-"
#~ "owners_privileges>` пользователя. Чтобы получить "
#~ "информацию о том, как происходит "
#~ "управление данными пользователя в Tarantool'е,"
#~ " см. раздел :ref:`Пользователи "
#~ "<authentication-users>` и справочник по "
#~ "спейсу :ref:`_user <box_space-user>`."

#~ msgid ""
#~ "the name of the user. This is "
#~ "optional; if it is not supplied, "
#~ "then the information will be for "
#~ "the user who is currently logged "
#~ "in."
#~ msgstr ""
#~ "имя пользователя. Необязательный параметр; "
#~ "если не указать, информация будет для"
#~ " авторизованного пользователя."

#~ msgid ""
#~ "box.schema.user.info()\n"
#~ "box.schema.user.info('Lena')"
#~ msgstr ""
#~ "box.schema.user.info()\n"
#~ "box.schema.user.info('Lena')"

#~ msgid ""
#~ "Create a function :ref:`tuple <index-"
#~ "box_tuple>`. This does not create the"
#~ " function itself -- that is done "
#~ "with Lua -- but if it is "
#~ "necessary to grant privileges for a "
#~ "function, box.schema.func.create must be done"
#~ " first. For explanation of how "
#~ "Tarantool maintains function data, see "
#~ "reference on :ref:`_func <box_space-func>` "
#~ "space."
#~ msgstr ""
#~ "Создание :ref:`кортежа <index-box_tuple>` с"
#~ " функцией. Сама функция не создается "
#~ "-- это делается с помощью Lua --"
#~ " но если необходимо выдать права "
#~ "функции, следует сначала выполнить "
#~ "box.schema.func.create. Чтобы получить информацию"
#~ " о том, как происходит управление "
#~ "данными функций в Tarantool'е, см. "
#~ "справочник по спейсу :ref:`_func "
#~ "<box_space-func>`."

#~ msgid ""
#~ "If you are using negative numbers "
#~ "for the sequence options, make sure "
#~ "that the index key type is "
#~ "'integer'. Otherwise the index key type"
#~ " may be either 'integer' or "
#~ "'unsigned'."
#~ msgstr ""
#~ "Если вы используете отрицательные числа "
#~ "в параметрах последовательности, убедитесь, "
#~ "что тип ключа индекса будет целое "
#~ "число 'integer'. В противном случае, тип"
#~ " ключа может быть либо 'integer', "
#~ "либо 'unsigned' (без знака)."

#~ msgid ""
#~ "**Note re storage engine:** vinyl "
#~ "supports formatting of non-empty spaces."
#~ " Primary index definition cannot be "
#~ "formatted."
#~ msgstr ""
#~ "**Примечание про движок базы данных:** "
#~ "vinyl поддерживает форматирование не пустых"
#~ " спейсов. Определение первичного индекса "
#~ "форматировать нельзя."

#~ msgid ""
#~ "**Using field names instead of field "
#~ "numbers:** `get()` can use field names"
#~ " described by the optional "
#~ ":ref:`space_object:format() <box_space-format>` "
#~ "clause. This is similar to a "
#~ "standard Lua feature, where a component"
#~ " can be referenced by its name "
#~ "instead of its number. For example, "
#~ "we can format the `tester` space "
#~ "with a field named `x` and use "
#~ "the name `x` in the index "
#~ "definition:"
#~ msgstr ""
#~ "**Использование имен полей вместо номеров "
#~ "полей:** в `get()` можно использовать "
#~ "имена полей, описанные в необязательном "
#~ "операторе :ref:`space_object:format() <box_space-"
#~ "format>`. Это аналогично стандартной "
#~ "Lua-функции, где на компонент можно "
#~ "ссылаться по имени, а не по "
#~ "номеру. Например, может форматировать спейс"
#~ " `tester` с полем под названием `x`"
#~ " и использовать имя `x` в определении"
#~ " индекса:"

#~ msgid ""
#~ "tarantool> s = box.schema.space.create('space53')\n"
#~ "tarantool> s:create_index('primary', {parts = {1, 'unsigned'}})\n"
#~ "tarantool> function replace_trigger()\n"
#~ "         >   replace_counter = replace_counter + 1\n"
#~ "         > end\n"
#~ "tarantool> s:on_replace(replace_trigger)\n"
#~ "tarantool> replace_counter = 0\n"
#~ "tarantool> t = s:insert{1, 'First replace'}\n"
#~ "tarantool> t = s:insert{2, 'Second replace'}\n"
#~ "tarantool> s:drop()\n"
#~ "tarantool> replace_counter"
#~ msgstr ""
#~ "tarantool> s = box.schema.space.create('space53')\n"
#~ "tarantool> s:create_index('primary', {parts = {1, 'unsigned'}})\n"
#~ "tarantool> function replace_trigger()\n"
#~ "         >   replace_counter = replace_counter + 1\n"
#~ "         > end\n"
#~ "tarantool> s:on_replace(replace_trigger)\n"
#~ "tarantool> replace_counter = 0\n"
#~ "tarantool> t = s:insert{1, 'First replace'}\n"
#~ "tarantool> t = s:insert{2, 'Second replace'}\n"
#~ "tarantool> s:drop()\n"
#~ "tarantool> replace_counter"

#~ msgid "the numeric function id, a number,"
#~ msgstr "числовой идентификатор функции, число,"

#~ msgid "flag,"
#~ msgstr "флаг,"

#~ msgid ""
#~ "In Lua, `lua-table-value:pairs() "
#~ "<https://www.lua.org/pil/7.3.html>`_ is a method "
#~ "which returns: ``function``, ``lua-table-"
#~ "value``, ``nil``. Tarantool has extended "
#~ "this so that ``tuple-value:pairs()`` "
#~ "returns: ``function``, ``tuple-value``, "
#~ "``nil``. It is useful for Lua "
#~ "iterators, because Lua iterators traverse "
#~ "a value's components until an end "
#~ "marker is reached."
#~ msgstr ""
#~ "В языке Lua метод `lua-table-"
#~ "value:pairs() <https://www.lua.org/pil/7.3.html>`_ "
#~ "возвращает: ``функция``, ``значение-Lua-таблицы``, "
#~ "``nil``. В Tarantool'е метод расширен "
#~ "так, что ``tuple-value:pairs()`` возвращает:"
#~ " ``функция``, ``значение-кортежа``, ``nil``, --"
#~ " что используется для Lua-итераторов, "
#~ "поскольку они обходят компоненты значения "
#~ "до тех пор, пока не достигнут "
#~ "маркера."

#~ msgid ""
#~ "Requests which cause changes to the "
#~ "data definition -- create, alter, drop,"
#~ " truncate -- must not be used."
#~ msgstr ""
#~ "Нельзя использовать запросы, которые могут "
#~ "приводить к изменению определения данных "
#~ "-- создание, изменение, удаление, очистка."

#~ msgid ""
#~ "tarantool> box.space.T:create_index('I', {parts ="
#~ " {{1,'str', collation='unicode_ci'}}})\n"
#~ "...\n"
#~ "tarantool> box.space.S.index.I:select()\n"
#~ "---\n"
#~ "- - ['ЕЛЕ']\n"
#~ "  - ['елейный']\n"
#~ "  - ['ёлка']\n"
#~ "  - ['еловый']\n"
#~ "  - ['елозить']\n"
#~ "  - ['Ёлочка']\n"
#~ "  - ['ёлочный']\n"
#~ "  - ['ЕЛь']\n"
#~ "...\n"
#~ "tarantool> box.space.S.index.I:select{'ЁлКа'}\n"
#~ "---\n"
#~ "- - ['ёлка']\n"
#~ "..."
#~ msgstr ""
#~ "tarantool> box.space.T:create_index('I', {parts ="
#~ " {{1,'str', collation='unicode_ci'}}})\n"
#~ "...\n"
#~ "tarantool> box.space.S.index.I:select()\n"
#~ "---\n"
#~ "- - ['ЕЛЕ']\n"
#~ "  - ['елейный']\n"
#~ "  - ['ёлка']\n"
#~ "  - ['еловый']\n"
#~ "  - ['елозить']\n"
#~ "  - ['Ёлочка']\n"
#~ "  - ['ёлочный']\n"
#~ "  - ['ЕЛь']\n"
#~ "...\n"
#~ "tarantool> box.space.S.index.I:select{'ЁлКа'}\n"
#~ "---\n"
#~ "- - ['ёлка']\n"
#~ "..."

#~ msgid ""
#~ "In fact, though, good collation involves"
#~ " much more than these simple examples"
#~ " of upper case / lower case and"
#~ " accented / unaccented equivalence in "
#~ "alphabets. We also consider variations "
#~ "of the same character, non-alphabetic"
#~ " writing systems, and special rules "
#~ "that apply for combinations of "
#~ "characters."
#~ msgstr ""
#~ "Фактически хорошая сортировка включает в "
#~ "себя гораздо больше, чем простые примеры"
#~ " эквивалентности заглавных и строчных букв,"
#~ " а также наличие или отсутствие "
#~ "диакритических знаков в алфавитах. Учитываются"
#~ " также варианты написания одного и "
#~ "того же символа, системы письменности "
#~ "без алфавита и специальные правила, "
#~ "которые применяются в отношении сочетания "
#~ "символов."

#~ msgid ":ref:`box.session.on_connect() <box_session-on_connect>`,"
#~ msgstr ":ref:`box.session.on_connect() <box_session-on_connect>`,"

#~ msgid "CHARACTER_LENGTH function"
#~ msgstr "Функция CHARACTER_LENGTH"

#~ msgid "UPPER and LOWER functions"
#~ msgstr "Функции UPPER и LOWER"

#~ msgid "GROUP BY clause"
#~ msgstr "Оператор GROUP BY"

#~ msgid "HAVING clause"
#~ msgstr "Оператор HAVING"

#~ msgid "AVG"
#~ msgstr "AVG"

#~ msgid "COUNT"
#~ msgstr "COUNT"

#~ msgid "MAX"
#~ msgstr "MAX"

#~ msgid "MIN"
#~ msgstr "MIN"

#~ msgid "SUM"
#~ msgstr "SUM"

