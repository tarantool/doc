
msgid "Cookbook recipes"
msgstr "Примеры и рекомендации по разработке"

msgid ""
"Here are contributions of Lua programs for some frequent or tricky "
"situations."
msgstr ""
"Ниже представлены дополнения в виде Lua-программ для часто встречающихся "
"или сложных случаев."

msgid ""
"You can execute any of these programs by copying the code into a ``.lua``"
" file, and then entering :samp:`chmod +x ./{program-name}.lua` and :samp"
":`./{program-name}.lua` on the terminal."
msgstr ""
"Любую из этих программ можно выполнить, скопировав код в ``.lua-файл``, а"
" затем выполнив в командной строке :samp:`chmod +x ./{имя-программы}.lua`"
" и :samp :`./{имя-программы}.lua`."

msgid "The first line is a \"hashbang\":"
msgstr "Первая строка -- это шебанг:"

msgid "#!/usr/bin/env tarantool"
msgstr "#!/usr/bin/env tarantool"

msgid ""
"This runs  Tarantool Lua application server, which should be on the "
"execution path."
msgstr ""
"Он запускает сервер приложений Tarantool'а на языке Lua, который должен "
"быть в пути выполнения."

msgid "This section contains the following recipes:"
msgstr "В этом разделе собраны следующие рецепты:"

msgid "Use freely."
msgstr "Можно использовать свободно."

msgid "hello_world.lua"
msgstr "hello_world.lua"

msgid "The standard example of a simple program."
msgstr "Стандартный пример простой программы."

msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"print('Hello, World!')"
msgstr ""
"#!/usr/bin/env tarantool\n"
" \n"
" print('Hello, World!')"

msgid "console_start.lua"
msgstr "console_start.lua"

msgid ""
"Use :doc:`box.once() </reference/reference_lua/box_once>` to initialize a"
" database (creating spaces) if this is the first time the server has been"
" run. Then use :ref:`console.start() <console-start>` to start "
"interactive mode."
msgstr ""
"Для инициализации базы данных (создания спейсов) используйте "
":doc:`box.once() </reference/reference_lua/box_once>`, если сервер "
"запускается впервые. Затем используйте :ref:`console.start() <console-"
"start>`, чтобы запустить интерактивный режим."

msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"-- Configure database\n"
"box.cfg {\n"
"    listen = 3313\n"
"}\n"
"\n"
"box.once(\"bootstrap\", function()\n"
"    box.schema.space.create('tweedledum')\n"
"    box.space.tweedledum:create_index('primary',\n"
"        { type = 'TREE', parts = {1, 'unsigned'}})\n"
"end)\n"
"\n"
"require('console').start()"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"-- Настроить базу данных\n"
"box.cfg {\n"
"    listen = 3313\n"
"}\n"
"\n"
"box.once(\"bootstrap\", function()\n"
"    box.schema.space.create('tweedledum')\n"
"    box.space.tweedledum:create_index('primary',\n"
"        { type = 'TREE', parts = {1, 'unsigned'}})\n"
"end)\n"
"\n"
"require('console').start()"

msgid "fio_read.lua"
msgstr "fio_read.lua"

msgid "Use the :ref:`fio module <fio-module>` to open, read, and close a file."
msgstr ""
"Используйте :ref:`Модуль fio <fio-module>`, чтобы открыть, прочитать и "
"закрыть файл."

msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local fio = require('fio')\n"
"local errno = require('errno')\n"
"local f = fio.open('/tmp/xxxx.txt', {'O_RDONLY' })\n"
"if not f then\n"
"    error(\"Failed to open file: \"..errno.strerror())\n"
"end\n"
"local data = f:read(4096)\n"
"f:close()\n"
"print(data)"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local fio = require('fio')\n"
"local errno = require('errno')\n"
"local f = fio.open('/tmp/xxxx.txt', {'O_RDONLY' })\n"
"if not f then\n"
"    error(\"Failed to open file: \"..errno.strerror())\n"
"end\n"
"local data = f:read(4096)\n"
"f:close()\n"
"print(data)"

msgid "fio_write.lua"
msgstr "fio_write.lua"

msgid "Use the :ref:`fio module <fio-module>` to open, write, and close a file."
msgstr ""
"Используйте :ref:`Модуль fio <fio-module>`, чтобы открыть, записать "
"данные и закрыть файл."

msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local fio = require('fio')\n"
"local errno = require('errno')\n"
"local f = fio.open('/tmp/xxxx.txt', {'O_CREAT', 'O_WRONLY', 'O_APPEND'},\n"
"    tonumber('0666', 8))\n"
"if not f then\n"
"    error(\"Failed to open file: \"..errno.strerror())\n"
"end\n"
"f:write(\"Hello\\n\");\n"
"f:close()"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local fio = require('fio')\n"
"local errno = require('errno')\n"
"local f = fio.open('/tmp/xxxx.txt', {'O_CREAT', 'O_WRONLY', 'O_APPEND'},\n"
"    tonumber('0666', 8))\n"
"if not f then\n"
"    error(\"Failed to open file: \"..errno.strerror())\n"
"end\n"
"f:write(\"Hello\\n\");\n"
"f:close()"

msgid "ffi_printf.lua"
msgstr "ffi_printf.lua"

msgid ""
"Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to call a "
"C built-in function: printf(). (For help understanding ffi, see the `FFI "
"tutorial <http://luajit.org/ext_ffi_tutorial.html>`_.)"
msgstr ""
"Используйте `Библиотеку LuaJIT FFI <http://luajit.org/ext_ffi.html>`_, "
"чтобы вызвать встроенную в C функцию: printf(). (Чтобы лучше понимать "
"FFI, см. `Учебное пособие по FFI "
"<http://luajit.org/ext_ffi_tutorial.html>`_.)"

#, python-format
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require('ffi')\n"
"ffi.cdef[[\n"
"    int printf(const char *format, ...);\n"
"]]\n"
"\n"
"ffi.C.printf(\"Hello, %s\\n\", os.getenv(\"USER\"));"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require('ffi')\n"
"ffi.cdef[[\n"
"    int printf(const char *format, ...);\n"
"]]\n"
"\n"
"ffi.C.printf(\"Hello, %s\\n\", os.getenv(\"USER\"));"

msgid "ffi_gettimeofday.lua"
msgstr "ffi_gettimeofday.lua"

msgid ""
"Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to call a "
"C function: gettimeofday(). This delivers time with millisecond "
"precision, unlike the time function in Tarantool's :ref:`clock module "
"<clock-module>`."
msgstr ""
"Используйте `Библиотеку LuaJIT FFI <http://luajit.org/ext_ffi.html>`_, "
"чтобы вызвать встроенную в C функцию: gettimeofday(). Она позволяет "
"получить значение времени с точностью в миллисекундах, в отличие от "
"функции времени в Tarantool'е :ref:`Модуль clock <clock-module>`."

msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require('ffi')\n"
"ffi.cdef[[\n"
"    typedef long time_t;\n"
"    typedef struct timeval {\n"
"    time_t tv_sec;\n"
"    time_t tv_usec;\n"
"} timeval;\n"
"    int gettimeofday(struct timeval *t, void *tzp);\n"
"]]\n"
"\n"
"local timeval_buf = ffi.new(\"timeval\")\n"
"local now = function()\n"
"    ffi.C.gettimeofday(timeval_buf, nil)\n"
"    return tonumber(timeval_buf.tv_sec * 1000 + (timeval_buf.tv_usec / "
"1000))\n"
"end"
msgstr ""

msgid "ffi_zlib.lua"
msgstr "ffi_zlib.lua"

msgid ""
"Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to call a "
"C library function. (For help understanding ffi, see the `FFI tutorial "
"<http://luajit.org/ext_ffi_tutorial.html>`_.)"
msgstr ""
"Используйте `Библиотеку LuaJIT FFI  <http://luajit.org/ext_ffi.html>`_, "
"чтобы вызвать библиотечную функцию в C. (Чтобы лучше понимать FFI, см. "
"`Учебное пособие по FFI <http://luajit.org/ext_ffi_tutorial.html>`_.)"

msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require(\"ffi\")\n"
"ffi.cdef[[\n"
"    unsigned long compressBound(unsigned long sourceLen);\n"
"    int compress2(uint8_t *dest, unsigned long *destLen,\n"
"    const uint8_t *source, unsigned long sourceLen, int level);\n"
"    int uncompress(uint8_t *dest, unsigned long *destLen,\n"
"    const uint8_t *source, unsigned long sourceLen);\n"
"]]\n"
"local zlib = ffi.load(ffi.os == \"Windows\" and \"zlib1\" or \"z\")\n"
"\n"
"-- Lua wrapper for compress2()\n"
"local function compress(txt)\n"
"    local n = zlib.compressBound(#txt)\n"
"    local buf = ffi.new(\"uint8_t[?]\", n)\n"
"    local buflen = ffi.new(\"unsigned long[1]\", n)\n"
"    local res = zlib.compress2(buf, buflen, txt, #txt, 9)\n"
"    assert(res == 0)\n"
"    return ffi.string(buf, buflen[0])\n"
"end\n"
"\n"
"-- Lua wrapper for uncompress\n"
"local function uncompress(comp, n)\n"
"    local buf = ffi.new(\"uint8_t[?]\", n)\n"
"    local buflen = ffi.new(\"unsigned long[1]\", n)\n"
"    local res = zlib.uncompress(buf, buflen, comp, #comp)\n"
"    assert(res == 0)\n"
"    return ffi.string(buf, buflen[0])\n"
"end\n"
"\n"
"-- Simple test code.\n"
"local txt = string.rep(\"abcd\", 1000)\n"
"print(\"Uncompressed size: \", #txt)\n"
"local c = compress(txt)\n"
"print(\"Compressed size: \", #c)\n"
"local txt2 = uncompress(c, #txt)\n"
"assert(txt2 == txt)"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require(\"ffi\")\n"
"ffi.cdef[[\n"
"    unsigned long compressBound(unsigned long sourceLen);\n"
"    int compress2(uint8_t *dest, unsigned long *destLen,\n"
"    const uint8_t *source, unsigned long sourceLen, int level);\n"
"    int uncompress(uint8_t *dest, unsigned long *destLen,\n"
"    const uint8_t *source, unsigned long sourceLen);\n"
"]]\n"
"local zlib = ffi.load(ffi.os == \"Windows\" and \"zlib1\" or \"z\")\n"
"\n"
"-- Надстройка Lua для функции compress2()\n"
"local function compress(txt)\n"
"    local n = zlib.compressBound(#txt)\n"
"    local buf = ffi.new(\"uint8_t[?]\", n)\n"
"    local buflen = ffi.new(\"unsigned long[1]\", n)\n"
"    local res = zlib.compress2(buf, buflen, txt, #txt, 9)\n"
"    assert(res == 0)\n"
"    return ffi.string(buf, buflen[0])\n"
"end\n"
"\n"
"-- Надстройка Lua для функции uncompress\n"
"local function uncompress(comp, n)\n"
"    local buf = ffi.new(\"uint8_t[?]\", n)\n"
"    local buflen = ffi.new(\"unsigned long[1]\", n)\n"
"    local res = zlib.uncompress(buf, buflen, comp, #comp)\n"
"    assert(res == 0)\n"
"    return ffi.string(buf, buflen[0])\n"
"end\n"
"\n"
"-- Простой код теста\n"
"local txt = string.rep(\"abcd\", 1000)\n"
"print(\"Uncompressed size: \", #txt)\n"
"local c = compress(txt)\n"
"print(\"Compressed size: \", #c)\n"
"local txt2 = uncompress(c, #txt)\n"
"assert(txt2 == txt)"

msgid "ffi_meta.lua"
msgstr "ffi_meta.lua"

msgid ""
"Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to access "
"a C object via a metamethod (a method which is defined with a metatable)."
msgstr ""
"Используйте `Библиотеку LuaJIT FFI <http://luajit.org/ext_ffi.html>`_, "
"чтобы получить доступ к объекту в C с помощью метаметода (метод, который "
"определен метатаблицей)."

msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require(\"ffi\")\n"
"ffi.cdef[[\n"
"typedef struct { double x, y; } point_t;\n"
"]]\n"
"\n"
"local point\n"
"local mt = {\n"
"  __add = function(a, b) return point(a.x+b.x, a.y+b.y) end,\n"
"  __len = function(a) return math.sqrt(a.x*a.x + a.y*a.y) end,\n"
"  __index = {\n"
"    area = function(a) return a.x*a.x + a.y*a.y end,\n"
"  },\n"
"}\n"
"point = ffi.metatype(\"point_t\", mt)\n"
"\n"
"local a = point(3, 4)\n"
"print(a.x, a.y)  --> 3  4\n"
"print(#a)        --> 5\n"
"print(a:area())  --> 25\n"
"local b = a + point(0.5, 8)\n"
"print(#b)        --> 12.5"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require(\"ffi\")\n"
"ffi.cdef[[\n"
"typedef struct { double x, y; } point_t;\n"
"]]\n"
"\n"
"local point\n"
"local mt = {\n"
"  __add = function(a, b) return point(a.x+b.x, a.y+b.y) end,\n"
"  __len = function(a) return math.sqrt(a.x*a.x + a.y*a.y) end,\n"
"  __index = {\n"
"    area = function(a) return a.x*a.x + a.y*a.y end,\n"
"  },\n"
"}\n"
"point = ffi.metatype(\"point_t\", mt)\n"
"\n"
"local a = point(3, 4)\n"
"print(a.x, a.y)  --> 3  4\n"
"print(#a)        --> 5\n"
"print(a:area())  --> 25\n"
"local b = a + point(0.5, 8)\n"
"print(#b)        --> 12.5"

msgid "print_arrays.lua"
msgstr "print_arrays.lua"

msgid ""
"Create Lua tables, and print them. Notice that for the 'array' table the "
"iterator function is ``ipairs()``, while for the 'map' table the iterator"
" function is pairs(). (``ipairs()`` is faster than ``pairs()``, but "
"``pairs()`` is recommended for map-like tables or mixed tables.) The "
"display will look like: \"1 Apple | 2 Orange | 3 Grapefruit | 4 Banana | "
"k3 v3 | k1 v1 | k2 v2\"."
msgstr ""
"Используйте, чтобы создать Lua-таблицы и вывести их. Следует отметить, "
"что для таблицы типа массива (array) функция-итератор будет ``ipairs()``,"
" а для таблицы типа ассоциативного массива (map) функция-итератор -- "
"``pairs()``. (``ipairs()`` быстрее, чем ``pairs()``, но ``pairs()`` "
"рекомендуется для ассоциативных массивов или смешанных таблиц.) Результат"
" будет выглядеть следующим образом: \"1 Apple | 2 Orange | 3 Grapefruit |"
" 4 Banana | k3 v3 | k1 v1 | k2  v2\"."

msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"array = { 'Apple', 'Orange', 'Grapefruit', 'Banana'}\n"
"for k, v in ipairs(array) do print(k, v) end\n"
"\n"
"map = { k1 = 'v1', k2 = 'v2', k3 = 'v3' }\n"
"for k, v in pairs(map) do print(k, v) end"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"array = { 'Apple', 'Orange', 'Grapefruit', 'Banana'}\n"
"for k, v in ipairs(array) do print(k, v) end\n"
"\n"
"map = { k1 = 'v1', k2 = 'v2', k3 = 'v3' }\n"
"for k, v in pairs(map) do print(k, v) end"

msgid "count_array.lua"
msgstr "count_array.lua"

msgid ""
"Use the '#' operator to get the number of items in an array-like Lua "
"table. This operation has O(log(N)) complexity."
msgstr ""
"Используйте оператор '#', чтобы получить количество элементов в "
"Lua-таблице типа массива. У этой операции сложность O(log(N))."

msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"array = { 1, 2, 3}\n"
"print(#array)"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"array = { 1, 2, 3}\n"
"print(#array)"

msgid "count_array_with_nils.lua"
msgstr "count_array_with_nils.lua"

msgid ""
"Missing elements in arrays, which Lua treats as \"nil\"s, cause the "
"simple \"#\" operator to deliver improper results. The \"print(#t)\" "
"instruction will print \"4\"; the \"print(counter)\" instruction will "
"print \"3\"; the \"print(max)\" instruction will print \"10\". Other "
"table functions, such as :ref:`table.sort() <table-sort>`, will also "
"misbehave when \"nils\" are present."
msgstr ""
"Отсутствующие элементы в массивах, которые Lua рассматривает как nil, "
"заставляют простой оператор '#' выдавать неправильные результаты. Команда"
" \"print(#t)\" выведет \"4\", команда \"print(counter)\" выведет \"3\", а"
" команда \"print(max)\" -- \"10\". Другие табличные функции, такие как "
":ref:`table.sort() <table-sort>`, также сработают неправильно при наличии"
" нулевых значений nil."

msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local t = {}\n"
"t[1] = 1\n"
"t[4] = 4\n"
"t[10] = 10\n"
"print(#t)\n"
"local counter = 0\n"
"for k,v in pairs(t) do counter = counter + 1 end\n"
"print(counter)\n"
"local max = 0\n"
"for k,v in pairs(t) do if k > max then max = k end end\n"
"print(max)"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local t = {}\n"
"t[1] = 1\n"
"t[4] = 4\n"
"t[10] = 10\n"
"print(#t)\n"
"local counter = 0\n"
"for k,v in pairs(t) do counter = counter + 1 end\n"
"print(counter)\n"
"local max = 0\n"
"for k,v in pairs(t) do if k > max then max = k end end\n"
"print(max)"

msgid "count_array_with_nulls.lua"
msgstr "count_array_with_nulls.lua"

msgid ""
"Use explicit ``NULL`` values to avoid the problems caused by Lua's nil =="
" missing value behavior. Although :code:`json.NULL == nil` is "
":code:`true`, all the print instructions in this program will print the "
"correct value: 10."
msgstr ""
"Используйте явные значения``NULL``, чтобы избежать проблем, вызванных  "
"nil в Lua == поведение с пропущенными значениями. Хотя :code:`json.NULL "
"== nil` является :code:`true`, все команды вывода в данной программе "
"выведут правильное значение: 10."

msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local json = require('json')\n"
"local t = {}\n"
"t[1] = 1; t[2] = json.NULL; t[3]= json.NULL;\n"
"t[4] = 4; t[5] = json.NULL; t[6]= json.NULL;\n"
"t[6] = 4; t[7] = json.NULL; t[8]= json.NULL;\n"
"t[9] = json.NULL\n"
"t[10] = 10\n"
"print(#t)\n"
"local counter = 0\n"
"for k,v in pairs(t) do counter = counter + 1 end\n"
"print(counter)\n"
"local max = 0\n"
"for k,v in pairs(t) do if k > max then max = k end end\n"
"print(max)"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local json = require('json')\n"
"local t = {}\n"
"t[1] = 1; t[2] = json.NULL; t[3]= json.NULL;\n"
"t[4] = 4; t[5] = json.NULL; t[6]= json.NULL;\n"
"t[6] = 4; t[7] = json.NULL; t[8]= json.NULL;\n"
"t[9] = json.NULL\n"
"t[10] = 10\n"
"print(#t)\n"
"local counter = 0\n"
"for k,v in pairs(t) do counter = counter + 1 end\n"
"print(counter)\n"
"local max = 0\n"
"for k,v in pairs(t) do if k > max then max = k end end\n"
"print(max)"

msgid "count_map.lua"
msgstr "count_map.lua"

msgid "Get the number of elements in a map-like table."
msgstr ""
"Программа используется для получения количества элементов в таблице типа "
"ассоциативного массива."

msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local map = { a = 10, b = 15, c = 20 }\n"
"local size = 0\n"
"for _ in pairs(map) do size = size + 1; end\n"
"print(size)"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local map = { a = 10, b = 15, c = 20 }\n"
"local size = 0\n"
"for _ in pairs(map) do size = size + 1; end\n"
"print(size)"

msgid "swap.lua"
msgstr "swap.lua"

msgid ""
"Use a Lua peculiarity to swap two variables without needing a third "
"variable."
msgstr ""
"Программа использует особенность Lua менять местами две переменные без "
"необходимости использования третьей переменной."

msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local x = 1\n"
"local y = 2\n"
"x, y = y, x\n"
"print(x, y)"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local x = 1\n"
"local y = 2\n"
"x, y = y, x\n"
"print(x, y)"

msgid "class.lua"
msgstr "class.lua"

msgid ""
"Create a class, create a metatable for the class, create an instance of "
"the class. Another illustration is at `http://lua-"
"users.org/wiki/LuaClassesWithMetatable <http://lua-"
"users.org/wiki/LuaClassesWithMetatable>`_."
msgstr ""
"Используется для создания класса, метатаблицы для класса, экземпляра "
"класса. Другой пример можно найти в `http://lua-"
"users.org/wiki/LuaClassesWithMetatable <http://lua-"
"users.org/wiki/LuaClassesWithMetatable>`_."

msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"-- define class objects\n"
"local myclass_somemethod = function(self)\n"
"    print('test 1', self.data)\n"
"end\n"
"\n"
"local myclass_someothermethod = function(self)\n"
"    print('test 2', self.data)\n"
"end\n"
"\n"
"local myclass_tostring = function(self)\n"
"    return 'MyClass <'..self.data..'>'\n"
"end\n"
"\n"
"local myclass_mt = {\n"
"    __tostring = myclass_tostring;\n"
"    __index = {\n"
"        somemethod = myclass_somemethod;\n"
"        someothermethod = myclass_someothermethod;\n"
"    }\n"
"}\n"
"\n"
"-- create a new object of myclass\n"
"local object = setmetatable({ data = 'data'}, myclass_mt)\n"
"print(object:somemethod())\n"
"print(object.data)"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"-- определить объекты класса\n"
"local myclass_somemethod = function(self)\n"
"    print('test 1', self.data)\n"
"end\n"
"\n"
"local myclass_someothermethod = function(self)\n"
"    print('test 2', self.data)\n"
"end\n"
"\n"
"local myclass_tostring = function(self)\n"
"    return 'MyClass <'..self.data..'>'\n"
"end\n"
"\n"
"local myclass_mt = {\n"
"    __tostring = myclass_tostring;\n"
"    __index = {\n"
"        somemethod = myclass_somemethod;\n"
"        someothermethod = myclass_someothermethod;\n"
"    }\n"
"}\n"
"\n"
"-- создать новый объект своего класса myclass\n"
"local object = setmetatable({ data = 'data'}, myclass_mt)\n"
"print(object:somemethod())\n"
"print(object.data)"

msgid "garbage.lua"
msgstr "garbage.lua"

msgid ""
"Activate the `Lua garbage collector "
"<https://www.lua.org/manual/5.1/manual.html#2.10>`_ with the "
"`collectgarbage function <https://www.lua.org/manual/5.1/manual.html#pdf-"
"collectgarbage>`_."
msgstr ""
"Запустите `сборщик мусора в Lua "
"<https://www.lua.org/manual/5.1/manual.html#2.10>`_ с помощью `функции "
"collectgarbage <https://www.lua.org/manual/5.1/manual.html#pdf- "
"collectgarbage>`_."

msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"collectgarbage('collect')"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"collectgarbage('collect')"

msgid "fiber_producer_and_consumer.lua"
msgstr "fiber_producer_and_consumer.lua"

msgid ""
"Start one fiber for producer and one fiber for consumer. Use "
":ref:`fiber.channel() <fiber_ipc-channel>` to exchange data and "
"synchronize. One can tweak the channel size (:code:`ch_size` in the "
"program code) to control the number of simultaneous tasks waiting for "
"processing."
msgstr ""
"Запустите один файбер для производителя и один файбер для потребителя. "
"Используйте :ref:`fiber.channel() <fiber_ipc-channel>` для обмена данных "
"и синхронизации. Можно настроить ширину канала (:code:`ch_size` в "
"программном коде) для управления количеством одновременных задач к "
"обработке."

msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local fiber = require('fiber')\n"
"local function consumer_loop(ch, i)\n"
"    -- initialize consumer synchronously or raise an error()\n"
"    fiber.sleep(0) -- allow fiber.create() to continue\n"
"    while true do\n"
"        local data = ch:get()\n"
"        if data == nil then\n"
"            break\n"
"        end\n"
"        print('consumed', i, data)\n"
"        fiber.sleep(math.random()) -- simulate some work\n"
"    end\n"
"end\n"
"\n"
"local function producer_loop(ch, i)\n"
"    -- initialize consumer synchronously or raise an error()\n"
"    fiber.sleep(0) -- allow fiber.create() to continue\n"
"    while true do\n"
"        local data = math.random()\n"
"        ch:put(data)\n"
"        print('produced', i, data)\n"
"    end\n"
"end\n"
"\n"
"local function start()\n"
"    local consumer_n = 5\n"
"    local producer_n = 3\n"
"\n"
"    -- Create a channel\n"
"    local ch_size = math.max(consumer_n, producer_n)\n"
"    local ch = fiber.channel(ch_size)\n"
"\n"
"    -- Start consumers\n"
"    for i=1, consumer_n,1 do\n"
"        fiber.create(consumer_loop, ch, i)\n"
"    end\n"
"\n"
"    -- Start producers\n"
"    for i=1, producer_n,1 do\n"
"        fiber.create(producer_loop, ch, i)\n"
"    end\n"
"end\n"
"\n"
"start()\n"
"print('started')"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local fiber = require('fiber')\n"
"local function consumer_loop(ch, i)\n"
"    -- инициализировать потребитель синхронно или выдать ошибку()\n"
"    fiber.sleep(0) -- позволить fiber.create() продолжать\n"
"    while true do\n"
"        local data = ch:get()\n"
"        if data == nil then\n"
"            break\n"
"        end\n"
"        print('consumed', i, data)\n"
"        fiber.sleep(math.random()) -- моделировать работу\n"
"    end\n"
"end\n"
"\n"
"local function producer_loop(ch, i)\n"
"    -- инициализировать потребитель синхронно или выдать ошибку()\n"
"    fiber.sleep(0) -- allow fiber.create() to continue\n"
"    while true do\n"
"        local data = math.random()\n"
"        ch:put(data)\n"
"        print('produced', i, data)\n"
"    end\n"
"end\n"
"\n"
"local function start()\n"
"    local consumer_n = 5\n"
"    local producer_n = 3\n"
"\n"
"    -- создать канал\n"
"    local ch_size = math.max(consumer_n, producer_n)\n"
"    local ch = fiber.channel(ch_size)\n"
"\n"
"    -- запустить потребители\n"
"    for i=1, consumer_n,1 do\n"
"        fiber.create(consumer_loop, ch, i)\n"
"    end\n"
"\n"
"    -- запустить производители\n"
"    for i=1, producer_n,1 do\n"
"        fiber.create(producer_loop, ch, i)\n"
"    end\n"
"end\n"
"\n"
"start()\n"
"print('started')"

msgid "socket_tcpconnect.lua"
msgstr "socket_tcpconnect.lua"

msgid ""
"Use :ref:`socket.tcp_connect() <socket-tcp_connect>` to connect to a "
"remote host via TCP. Display the connection details and the result of a "
"GET request."
msgstr ""
"Используйте :ref:`socket.tcp_connect() <socket-tcp_connect>` для "
"подключения к удаленному серверу по TCP. Можно отобразить информацию о "
"подключении и результат запроса GET."

msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local s = require('socket').tcp_connect('google.com', 80)\n"
"print(s:peer().host)\n"
"print(s:peer().family)\n"
"print(s:peer().type)\n"
"print(s:peer().protocol)\n"
"print(s:peer().port)\n"
"print(s:write(\"GET / HTTP/1.0\\r\\n\\r\\n\"))\n"
"print(s:read('\\r\\n'))\n"
"print(s:read('\\r\\n'))"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local s = require('socket').tcp_connect('google.com', 80)\n"
"print(s:peer().host)\n"
"print(s:peer().family)\n"
"print(s:peer().type)\n"
"print(s:peer().protocol)\n"
"print(s:peer().port)\n"
"print(s:write(\"GET / HTTP/1.0\\r\\n\\r\\n\"))\n"
"print(s:read('\\r\\n'))\n"
"print(s:read('\\r\\n'))"

msgid "socket_tcp_echo.lua"
msgstr "socket_tcp_echo.lua"

msgid ""
"Use :ref:`socket.tcp_connect() <socket-tcp_connect>` to set up a simple "
"TCP server, by creating a function that handles requests and echos them, "
"and passing the function to :ref:`socket.tcp_server() <socket-"
"tcp_server>`. This program has been used to test with 100,000 clients, "
"with each client getting a separate fiber."
msgstr ""
"Используйте :ref:`socket.tcp_connect() <socket-tcp_connect>` для "
"настройки простого TCP-сервера путем создания функции, которая "
"обрабатывает запросы и отражает их, а затем передачи функции на "
":ref:`socket.tcp_server() <socket-tcp_server>`. Данная программа была "
"протестирована на 100 000 клиентов, каждый из которых получил отдельный "
"файбер."

msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local function handler(s, peer)\n"
"    s:write(\"Welcome to test server, \" .. peer.host ..\"\\n\")\n"
"    while true do\n"
"        local line = s:read('\\n')\n"
"        if line == nil then\n"
"            break -- error or eof\n"
"        end\n"
"        if not s:write(\"pong: \"..line) then\n"
"            break -- error or eof\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"local server, addr = require('socket').tcp_server('localhost', 3311, "
"handler)"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local function handler(s, peer)\n"
"    s:write(\"Welcome to test server, \" .. peer.host ..\"\\n\")\n"
"    while true do\n"
"        local line = s:read('\\n')\n"
"        if line == nil then\n"
"            break -- ошибка или конец файла\n"
"        end\n"
"        if not s:write(\"pong: \"..line) then\n"
"            break -- ошибка или конец файла\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"local server, addr = require('socket').tcp_server('localhost', 3311, "
"handler)"

msgid "getaddrinfo.lua"
msgstr "getaddrinfo.lua"

msgid ""
"Use :ref:`socket.getaddrinfo() <socket-getaddrinfo>` to perform non-"
"blocking DNS resolution, getting both the AF_INET6 and AF_INET "
"information for 'google.com'. This technique is not always necessary for "
"tcp connections because :ref:`socket.tcp_connect() <socket-tcp_connect>` "
"performs `socket.getaddrinfo` under the hood, before trying to connect to"
" the first available address."
msgstr ""
"Используйте :ref:`socket.getaddrinfo() <socket-getaddrinfo>`, чтобы "
"провести неблокирующее разрешение имен DNS, получая как AF_INET6, так и "
"AF_INET информацию для 'google.com'. Данная техника не всегда необходима "
"для TCP-соединений, поскольку :ref:`socket.tcp_connect() <socket-"
"tcp_connect>` выполняет `socket.getaddrinfo` с точки зрения внутреннего "
"устройства до попытки соединения с первым доступным адресом."

msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local s = require('socket').getaddrinfo('google.com', 'http', { type = "
"'SOCK_STREAM' })\n"
"print('host=',s[1].host)\n"
"print('family=',s[1].family)\n"
"print('type=',s[1].type)\n"
"print('protocol=',s[1].protocol)\n"
"print('port=',s[1].port)\n"
"print('host=',s[2].host)\n"
"print('family=',s[2].family)\n"
"print('type=',s[2].type)\n"
"print('protocol=',s[2].protocol)\n"
"print('port=',s[2].port)"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local s = require('socket').getaddrinfo('google.com', 'http', { type = "
"'SOCK_STREAM' })\n"
"print('host=',s[1].host)\n"
"print('family=',s[1].family)\n"
"print('type=',s[1].type)\n"
"print('protocol=',s[1].protocol)\n"
"print('port=',s[1].port)\n"
"print('host=',s[2].host)\n"
"print('family=',s[2].family)\n"
"print('type=',s[2].type)\n"
"print('protocol=',s[2].protocol)\n"
"print('port=',s[2].port)"

msgid "socket_udp_echo.lua"
msgstr "socket_udp_echo.lua"

msgid ""
"Tarantool does not currently have a `udp_server` function, therefore "
"socket_udp_echo.lua is more complicated than socket_tcp_echo.lua. It can "
"be implemented with sockets and fibers."
msgstr ""
"В данный момент в Tarantool нет функции `udp_server`, поэтому "
"socket_udp_echo.lua -- более сложная программа, чем socket_tcp_echo.lua. "
"Ее можно реализовать с помощью сокетов и файберов."

msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local socket = require('socket')\n"
"local errno = require('errno')\n"
"local fiber = require('fiber')\n"
"\n"
"local function udp_server_loop(s, handler)\n"
"    fiber.name(\"udp_server\")\n"
"    while true do\n"
"        -- try to read a datagram first\n"
"        local msg, peer = s:recvfrom()\n"
"        if msg == \"\" then\n"
"            -- socket was closed via s:close()\n"
"            break\n"
"        elseif msg ~= nil then\n"
"            -- got a new datagram\n"
"            handler(s, peer, msg)\n"
"        else\n"
"            if s:errno() == errno.EAGAIN or s:errno() == errno.EINTR then"
"\n"
"                -- socket is not ready\n"
"                s:readable() -- yield, epoll will wake us when new data "
"arrives\n"
"            else\n"
"                -- socket error\n"
"                local msg = s:error()\n"
"                s:close() -- save resources and don't wait GC\n"
"                error(\"Socket error: \" .. msg)\n"
"            end\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"local function udp_server(host, port, handler)\n"
"    local s = socket('AF_INET', 'SOCK_DGRAM', 0)\n"
"    if not s then\n"
"        return nil -- check errno:strerror()\n"
"    end\n"
"    if not s:bind(host, port) then\n"
"        local e = s:errno() -- save errno\n"
"        s:close()\n"
"        errno(e) -- restore errno\n"
"        return nil -- check errno:strerror()\n"
"    end\n"
"\n"
"    fiber.create(udp_server_loop, s, handler) -- start a new background "
"fiber\n"
"    return s\n"
"end"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local socket = require('socket')\n"
"local errno = require('errno')\n"
"local fiber = require('fiber')\n"
"\n"
"local function udp_server_loop(s, handler)\n"
"    fiber.name(\"udp_server\")\n"
"    while true do\n"
"        -- попытка прочитать сначала датаграмму\n"
"        local msg, peer = s:recvfrom()\n"
"        if msg == \"\" then\n"
"            -- сокет был закрыт с помощью s:close()\n"
"            break\n"
"        elseif msg ~= nil then\n"
"            -- получена новая датаграмма\n"
"            handler(s, peer, msg)\n"
"        else\n"
"            if s:errno() == errno.EAGAIN or s:errno() == errno.EINTR then"
"\n"
"                -- сокет не готов\n"
"                s:readable() -- передача управления, epoll сообщит, когда"
" будут новые данные\n"
"            else\n"
"                -- ошибка сокета\n"
"                local msg = s:error()\n"
"                s:close() -- сохранить ресурсы и не ждать сборку мусора\n"
"                error(\"Socket error: \" .. msg)\n"
"            end\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"local function udp_server(host, port, handler)\n"
"    local s = socket('AF_INET', 'SOCK_DGRAM', 0)\n"
"    if not s then\n"
"        return nil -- проверить номер ошибки errno:strerror()\n"
"   end\n"
"    if not s:bind(host, port) then\n"
"        local e = s:errno() -- сохранить номер ошибки errno\n"
"        s:close()\n"
"        errno(e) -- восстановить номер ошибки errno\n"
"        return nil -- проверить номер ошибки errno:strerror()\n"
"    end\n"
"\n"
"    fiber.create(udp_server_loop, s, handler) -- запустить новый файбер в"
" фоновом режиме\n"
"    return s\n"
"end"

msgid ""
"A function for a client that connects to this server could look something"
" like this ..."
msgstr ""
"Функция для клиента, который подключается к этому серверу, может "
"выглядеть следующим образом:"

msgid ""
"local function handler(s, peer, msg)\n"
"    -- You don't have to wait until socket is ready to send UDP\n"
"    -- s:writable()\n"
"    s:sendto(peer.host, peer.port, \"Pong: \" .. msg)\n"
"end\n"
"\n"
"local server = udp_server('127.0.0.1', 3548, handler)\n"
"if not server then\n"
"    error('Failed to bind: ' .. errno.strerror())\n"
"end\n"
"\n"
"print('Started')\n"
"\n"
"require('console').start()"
msgstr ""
"local function handler(s, peer, msg)\n"
"    -- Необязательно ждать, пока сокет будет готов отправлять UDP\n"
"    -- s:writable()\n"
"    s:sendto(peer.host, peer.port, \"Pong: \" .. msg)\n"
"end\n"
"\n"
"local server = udp_server('127.0.0.1', 3548, handler)\n"
"if not server then\n"
"    error('Failed to bind: ' .. errno.strerror())\n"
"end\n"
"\n"
"print('Started')\n"
"\n"
"require('console').start()"

msgid "http_get.lua"
msgstr "http_get.lua"

msgid "Use the :ref:`http module <http-module>` to get data via HTTP."
msgstr "Используйте :ref:`Модуль HTTP <http-module>` для получения данных по HTTP."

msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local http_client = require('http.client')\n"
"local json = require('json')\n"
"local r = "
"http_client.get('https://api.frankfurter.app/latest?to=USD%2CRUB')\n"
"if r.status ~= 200 then\n"
"    print('Failed to get currency ', r.reason)\n"
"    return\n"
"end\n"
"local data = json.decode(r.body)\n"
"print(data.base, 'rate of', data.date, 'is', data.rates.RUB, 'RUB or', "
"data.rates.USD, 'USD')"
msgstr ""

msgid "http_send.lua"
msgstr "http_send.lua"

msgid "Use the :ref:`http module <http-module>` to send data via HTTP."
msgstr "Используйте :ref:`Модуль HTTP <http-module>` для отправки данных по HTTP."

msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local http_client = require('http.client')\n"
"local json = require('json')\n"
"local data = json.encode({ Key = 'Value'})\n"
"local headers = { Token = 'xxxx', ['X-Secret-Value'] = '42' }\n"
"local r = http_client.post('http://localhost:8081', data, { headers = "
"headers})\n"
"if r.status == 200 then\n"
"    print 'Success'\n"
"end"
msgstr ""

msgid "http_server.lua"
msgstr "http_server.lua"

msgid ""
"Use the `http`_ `rock`_ (which must first be installed) to turn Tarantool"
" into a web server."
msgstr ""
"Используйте `сторонний модуль`_ `http`_  (который необходимо "
"предварительно установить), чтобы превратить Tarantool в веб-сервер."

msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local function handler(self)\n"
"    return self:render{ json = { ['Your-IP-Is'] = self:peer().host } }\n"
"end\n"
"\n"
"local server = require('http.server').new(nil, 8080) -- listen *:8080\n"
"local router = require('http.router').new({charset = \"utf8\"})\n"
"server:set_router(router)\n"
"router:route({ path = '/' }, handler)\n"
"server:start()\n"
"-- connect to localhost:8080 and see json"
msgstr ""

msgid "http_generate_html.lua"
msgstr "http_generate_html.lua"

msgid ""
"Use the `http`_ `rock` (which must first be installed) to generate HTML "
"pages from templates. The `http`_ `rock`_ has a fairly simple template "
"engine which allows execution of regular Lua code inside text blocks "
"(like PHP). Therefore there is no need to learn new languages in order to"
" write templates."
msgstr ""
"Используйте сторонний модуль `http`_ (который необходимо предварительно "
"установить) для создания HTML-страниц из шаблонов. В `модуле "
"<https://tarantool.io/ru/download/rocks>`_ `http`_ достаточно простой "
"движок шаблонов, который позволяет выполнять регулярный код на Lua в "
"текстовых блоках (как в PHP). Таким образом, нет необходимости в изучении"
" новых языков, чтобы написать шаблоны."

msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local function handler(self)\n"
"local fruits = { 'Apple', 'Orange', 'Grapefruit', 'Banana'}\n"
"    return self:render{ fruits = fruits }\n"
"end\n"
"\n"
"local server = require('http.server').new(nil, 8080) -- nil means '*'\n"
"local router = require('http.router').new({charset = \"utf8\"})\n"
"server:set_router(router)\n"
"router:route({ path = '/', file = 'index.html.lua' }, handler)\n"
"server:start()"
msgstr ""

msgid ""
"An \"HTML\" file for this server, including Lua, could look like this (it"
" would produce \"1 Apple | 2 Orange | 3 Grapefruit | 4 Banana\")."
msgstr ""
"HTML-файл для этого сервера, включая Lua, может выглядеть следующим "
"образом (он выведет \"1 Apple | 2 Orange | 3 Grapefruit | 4 Banana\")."

#, python-format
msgid ""
"<html>\n"
"<body>\n"
"    <table border=\"1\">\n"
"        % for i,v in pairs(fruits) do\n"
"        <tr>\n"
"            <td><%= i %></td>\n"
"            <td><%= v %></td>\n"
"        </tr>\n"
"        % end\n"
"    </table>\n"
"</body>\n"
"</html>"
msgstr ""
"<html>\n"
"<body>\n"
"    <table border=\"1\">\n"
"        % for i,v in pairs(fruits) do\n"
"        <tr>\n"
"            <td><%= i %></td>\n"
"            <td><%= v %></td>\n"
"        </tr>\n"
"        % end\n"
"    </table>\n"
"</body>\n"
"</html>"

msgid "select_all.go"
msgstr "select_all.go"

msgid ""
"In Go, there is no one-liner to select all tuples from a Tarantool space."
" Yet you can use a script like this one. Call it on the instance you want"
" to connect to."
msgstr ""
"На языке Go выборка содержимого всего спейса не является тривиальной "
"задачей, которая решается в одну строчку. Ниже мы приводим пример "
"программы, которая осуществляет полную выборку из спейса 'tester'. Эту "
"программу нужно вызвать на том экземпляре, с которым вы собираетесь "
"установить соединение через Go-коннектор."

#, python-format
msgid ""
"package main\n"
"\n"
"import (\n"
"\t\"fmt\"\n"
"\t\"log\"\n"
"\n"
"\t\"github.com/tarantool/go-tarantool\"\n"
")\n"
"\n"
"/*\n"
"box.cfg{listen = 3301}\n"
"box.schema.user.passwd('pass')\n"
"\n"
"s = box.schema.space.create('tester')\n"
"s:format({\n"
"    {name = 'id', type = 'unsigned'},\n"
"    {name = 'band_name', type = 'string'},\n"
"    {name = 'year', type = 'unsigned'}\n"
"})\n"
"s:create_index('primary', { type = 'hash', parts = {'id'} })\n"
"s:create_index('scanner', { type = 'tree', parts = {'id', 'band_name'} })"
"\n"
"\n"
"s:insert{1, 'Roxette', 1986}\n"
"s:insert{2, 'Scorpions', 2015}\n"
"s:insert{3, 'Ace of Base', 1993}\n"
"*/\n"
"\n"
"func main() {\n"
"\tconn, err := tarantool.Connect(\"127.0.0.1:3301\", tarantool.Opts{\n"
"\t\tUser: \"admin\",\n"
"\t\tPass: \"pass\",\n"
"\t})\n"
"\n"
"\tif err != nil {\n"
"\t\tlog.Fatalf(\"Connection refused\")\n"
"\t}\n"
"\tdefer conn.Close()\n"
"\n"
"\tspaceName := \"tester\"\n"
"\tindexName := \"scanner\"\n"
"\tidFn := conn.Schema.Spaces[spaceName].Fields[\"id\"].Id\n"
"\tbandNameFn := conn.Schema.Spaces[spaceName].Fields[\"band_name\"].Id\n"
"\n"
"\tvar tuplesPerRequest uint32 = 2\n"
"\tcursor := []interface{}{}\n"
"\n"
"\tfor {\n"
"\t\tresp, err := conn.Select(spaceName, indexName, 0, tuplesPerRequest, "
"tarantool.IterGt, cursor)\n"
"\t\tif err != nil {\n"
"\t\t\tlog.Fatalf(\"Failed to select: %s\", err)\n"
"\t\t}\n"
"\n"
"\t\tif resp.Code != tarantool.OkCode {\n"
"\t\t\tlog.Fatalf(\"Select failed: %s\", resp.Error)\n"
"\t\t}\n"
"\n"
"\t\tif len(resp.Data) == 0 {\n"
"\t\t\tbreak\n"
"\t\t}\n"
"\n"
"\t\tfmt.Println(\"Iteration\")\n"
"\n"
"\t\ttuples := resp.Tuples()\n"
"\t\tfor _, tuple := range tuples {\n"
"\t\t\tfmt.Printf(\"\\t%v\\n\", tuple)\n"
"\t\t}\n"
"\n"
"\t\tlastTuple := tuples[len(tuples)-1]\n"
"\t\tcursor = []interface{}{lastTuple[idFn], lastTuple[bandNameFn]}\n"
"\t}\n"
"}\n"
msgstr ""
