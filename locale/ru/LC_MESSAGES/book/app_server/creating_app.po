
msgid "Creating an application"
msgstr "Создание приложения"

msgid ""
"Further we walk you through key programming practices that will give you "
"a good start in writing Lua applications for Tarantool. For an adventure,"
" this is a story of implementing... a real microservice based on "
"Tarantool! We implement a backend for a simplified version of `Pokémon Go"
" <https://en.wikipedia.org/wiki/Pokémon_Go>`_, a location-based augmented"
" reality game released in mid-2016. In this game, players use a mobile "
"device's GPS capability to locate, capture, battle and train virtual "
"monsters called \"pokémon\", who appear on the screen as if they were in "
"the same real-world location as the player."
msgstr ""
"Далее мы пошагово разберем ключевые методики программирования, что "
"послужит хорошим началом для написания Lua-приложений для Tarantool'а. "
"Для интереса возьмем историю реализации... настоящего микросервиса на "
"основе Tarantool'а! Мы реализуем бэкенд для упрощенной версии `Pokémon Go"
"  <https://ru.wikipedia.org/wiki/Pok%C3%A9mon_Go>`_, игры на основе "
"определения местоположения дополненной реальности, выпущенной в середине "
"2016 года. В этой игре игроки используют GPS-возможности мобильных "
"устройств, чтобы находить, захватывать, сражаться и тренировать "
"виртуальных существ, или покемонов, которые появляются на экране, как "
"если бы они находились в том же реальном месте, как и игрок."

msgid ""
"To stay within the walk-through format, let's narrow the original "
"gameplay as follows. We have a map with pokémon spawn locations. Next, we"
" have multiple players who can send catch-a-pokémon requests to the "
"server (which runs our Tarantool microservice). The server replies "
"whether the pokémon is caught or not, increases the player's pokémon "
"counter if yes, and triggers the respawn-a-pokémon method that spawns a "
"new pokémon at the same location in a while."
msgstr ""
"Чтобы не выходить за рамки пошагового примера, ограничим оригинальный "
"сюжет игры. У нас есть карта с местами появления покемонов. Далее у нас "
"есть несколько игроков, которые могут отправлять запросы на поимку "
"покемона на сервер (где работает микросервис Tarantool'а). Сервер "
"отвечает, пойман ли покемон, увеличивает счетчик покемонов, если пойман, "
"и вызывает метод респауна покемона, который через некоторое время создает"
" нового покемона на том же самом месте."

msgid ""
"We leave client-side applications outside the scope of this story. Yet we"
" promise a mini-demo in the end to simulate real users and give us some "
"fun. :-)"
msgstr ""
"Мы вынесем клиентские приложения за рамки рассказа. Но в конце обещаем "
"небольшую демонстрацию с моделированием настоящих пользователей, чтобы "
"немного поразвлечься. :-)"

msgid "First, what would be the best way to deliver our microservice?"
msgstr "Для начала как лучше всего предоставить микросервис?"

msgid "Modules, rocks and applications"
msgstr "Модули и приложения"

msgid ""
"To make our game logic available to other developers and Lua "
"applications, let's put it into a Lua module."
msgstr ""
"Чтобы наша логическая схема игры была доступна другим разработчикам и "
"Lua-приложениям, поместим ее в Lua-модуль."

msgid ""
"A **module** (called \"rock\" in Lua) is an optional library which "
"enhances Tarantool functionality. So, we can install our logic as a "
"module in Tarantool and use it from any Tarantool application or module. "
"Like applications, modules in Tarantool can be written in Lua (rocks), C "
"or C++."
msgstr ""
"**Модуль** (который называется \"rock\" в Lua) -- это дополнительная "
"библиотека, которая расширяет функции Tarantool'а. Поэтому можно "
"установить нашу логическую схему в виде модуля в Tarantool и использовать"
" ее из любого Tarantool-приложения или модуля. Как и приложения, модули в"
" Tarantool'е могут быть написаны на Lua (rocks), C или C++."

msgid "Modules are good for two things:"
msgstr "Модули хороши для двух целей:"

msgid "easier **code management** (reuse, packaging, versioning), and"
msgstr ""
"облегченное **управление кодом** (переиспользование, подготовка к "
"развертыванию, версионирование) и"

msgid "hot **code reload** without restarting the Tarantool instance."
msgstr "горячая **перезагрузка кода** без перезапуска экземпляра Tarantool'а."

msgid ""
"Technically, a module is a file with source code that exports its "
"functions in an API. For example, here is a Lua module named "
"``mymodule.lua`` that exports one function named ``myfun``:"
msgstr ""
"В техническом смысле, модуль - это файл с исходным кодом, который "
"экспортирует свои функции в API. Например, вот Lua-модуль под названием "
"``mymodule.lua``, который экспортирует одну функцию под названием "
"``myfun``:"

msgid ""
"local exports = {}\n"
"exports.myfun = function(input_string)\n"
"   print('Hello', input_string)\n"
"end\n"
"return exports"
msgstr ""
"local exports = {}\n"
"exports.myfun = function(input_string)\n"
"   print('Hello', input_string)\n"
"end\n"
"return exports"

msgid ""
"To launch the function ``myfun()`` -- from another module, from a Lua "
"application, or from Tarantool itself, -- we need to save this module as "
"a file, then load this module with the ``require()`` directive and call "
"the exported function."
msgstr ""
"Чтобы запустить функцию ``myfun()`` -- из другого модуля, из "
"Lua-приложения или из самого Tarantool'а -- необходимо сохранить этот "
"модуль в виде файла, а затем загрузить этот модуль с директивой "
"``require()`` и вызвать экспортированную функцию."

msgid ""
"For example, here's a Lua application that uses ``myfun()`` function from"
" ``mymodule.lua`` module:"
msgstr ""
"Например, вот Lua-приложение, которое использует функцию ``myfun()`` из "
"модуля ``mymodule.lua``:"

msgid ""
"-- loading the module\n"
"local mymodule = require('mymodule')\n"
"\n"
"-- calling myfun() from within test() function\n"
"local test = function()\n"
"  mymodule.myfun()\n"
"end"
msgstr ""
"-- загрузка модуля\n"
"local mymodule = require('mymodule')\n"
"\n"
"-- вызов myfun() из функции test\n"
"local test = function()\n"
"  mymodule.myfun()\n"
"end"

msgid ""
"A thing to remember here is that the ``require()`` directive takes load "
"paths to Lua modules from the ``package.path`` variable. This is a "
"semicolon-separated string, where a question mark is used to interpolate "
"the module name. By default, this variable contains system-wide Lua paths"
" and the working directory. But if we put our modules inside a specific "
"folder (e.g. ``scripts/``), we need to add this folder to "
"``package.path`` before any calls to ``require()``:"
msgstr ""
"Здесь важно запомнить, что директива ``require()`` берет пути загрузки к "
"Lua-модулям из переменной ``package.path``. Она представляет собой строку"
" с разделителями в виде точки с запятой, где знак вопроса используется "
"для вставки имени модуля. По умолчанию, эта переменная содержит пути в "
"системе и рабочую директорию. Но если мы поместим наши модули в особую "
"папку (например, ``scripts/``), необходимо будет добавить эту папку в "
"``package.path`` до вызова ``require()``:"

msgid "package.path = 'scripts/?.lua;' .. package.path"
msgstr "package.path = 'scripts/?.lua;' .. package.path"

msgid ""
"For our microservice, a simple and convenient solution would be to put "
"all methods in a Lua module (say ``pokemon.lua``) and to write a Lua "
"application (say ``game.lua``) that initializes the gaming environment "
"and starts the game loop."
msgstr ""
"Для нашего микросервиса простым и удобным решением будет разместить все "
"методы в Lua-модуле (скажем, ``pokemon.lua``) и написать Lua-приложение "
"(скажем, ``game.lua``), которое запустит игровое окружение и цикл игры."

msgid ""
"Now let's get down to implementation details. In our game, we need three "
"entities:"
msgstr "Теперь приступим к деталям реализации. В игре нам необходимы три сущности:"

msgid ""
"**map**, which is an array of pokémons with coordinates of respawn "
"locations; in this version of the game, let a location be a rectangle "
"identified with two points, upper-left and lower-right;"
msgstr ""
"**карта**, которая представляет собой массив покемонов с координатами "
"мест респауна; в данной версии игры пусть местом будет прямоугольник, "
"установленный по двум точкам, верхней левой и нижней правой;"

msgid ""
"**player**, which has an ID, a name, and coordinates of the player's "
"location point;"
msgstr "**игрок**, у которого есть ID, имя и координаты местонахождения игрока;"

msgid ""
"**pokémon**, which has the same fields as the player, plus a status "
"(active/inactive, that is present on the map or not) and a catch "
"probability (well, let's give our pokémons a chance to escape :-) )"
msgstr ""
"**покемон**, у которого такие же поля, как и у игрока, плюс статус "
"(активный/неактивный, то есть находится ли на карте) и возможность поимки"
" (давайте уж дадим нашим покемонам шанс сбежать :-) )"

msgid ""
"We'll store these entities as tuples in Tarantool spaces. But to deliver "
"our backend application as a microservice, the good practice would be to "
"send/receive our data in the universal JSON format, thus using Tarantool "
"as a document storage."
msgstr ""
"Эти данные будем хранить как кортежи в спейсах Tarantool'а. Но чтобы "
"бэкенд-приложение работало как микросервис, правильно будет "
"отправлять/получать данные в универсальном формате JSON, используя "
"Tarantool в качестве системы хранения документов."

msgid "Avro schemas"
msgstr "Avro-схемы"

msgid ""
"To store JSON data as tuples, we will apply a savvy practice which "
"reduces data footprint and ensures all stored documents are valid. We "
"will use Tarantool module `avro-schema <https://github.com/tarantool"
"/avro-schema>`_ which checks the schema of a JSON document and converts "
"it to a Tarantool tuple. The tuple will contain only field values, and "
"thus take a lot less space than the original document. In avro-schema "
"terms, converting JSON documents to tuples is \"flattening\", and "
"restoring the original documents is \"unflattening\"."
msgstr ""
"Чтобы хранить JSON-данные в виде кортежей, используем продвинутую "
"методику, которая уменьшит отпечаток данных и обеспечит пригодность всех "
"сохраняемых документов. Будем использовать Tarantool-модуль `avro-schema "
"<https://github.com/tarantool/avro-schema>`_, который проверяет схему "
"JSON-документа и конвертирует его в кортеж Tarantool'а. Кортеж будет "
"содержать только значения полей, таким образом, занимая меньше места, чем"
" оригинальный документ. С точки зрения avro-схемы, конвертация "
"JSON-документов в кортежи -- \"flattening\" (конвертация в плоские "
"файлы), а восстановление оригинальных документов -- \"unflattening\" "
"(конвертация из плоских файлов)."

msgid ""
"First you need to `install "
"<https://www.tarantool.io/en/doc/1.10/book/app_server/installing_module/>`_"
" the module with ``tarantoolctl rocks install avro-schema``."
msgstr ""
"Для начала необходимо `установить "
"<https://www.tarantool.io/en/doc/1.10/book/app_server/installing_module/>`_"
" модуль с помощью команды ``tarantoolctl rocks install avro-schema``."

msgid "Further usage is quite straightforward:"
msgstr "Использовать модуль достаточно просто:"

msgid ""
"For each entity, we need to define a schema in `Apache Avro schema "
"<https://en.wikipedia.org/wiki/Apache_Avro>`_ syntax, where we list the "
"entity's fields with their names and `Avro data types "
"<http://avro.apache.org/docs/current/spec.html#schema_primitive>`_."
msgstr ""
"Для каждой сущности необходимо определить схему в синтаксисе `схемы "
"Apache Avro <https://en.wikipedia.org/wiki/Apache_Avro>`_, где мы "
"перечисляем поля сущности с их наименованиями и `типами данных по Avro "
"<http://avro.apache.org/docs/current/spec.html#schema_primitive>`_."

msgid ""
"At initialization, we call ``avro-schema.create()`` that creates objects "
"in memory for all schema entities, and ``compile()`` that generates "
"flatten/unflatten methods for each entity."
msgstr ""
"При инициализации мы вызываем функцию ``avro-schema.create()``, которая "
"создает объекты в памяти для всех сущностей схемы, а также функцию "
"``compile()``, которая создает методы flatten/unflatten (конвертация в "
"плоские файлы и обратно) для каждой сущности."

msgid ""
"Further on, we just call flatten/unflatten methods for a respective "
"entity on receiving/sending the entity's data."
msgstr ""
"Далее мы просто вызываем методы flatten/unflatten для соответствующей "
"сущности при получении/отправке данных об этой сущности."

msgid ""
"Here's what our schema definitions for the player and pokémon entities "
"look like:"
msgstr "Вот как будут выглядеть определения схемы для сущностей игрока и покемона:"

msgid ""
"local schema = {\n"
"    player = {\n"
"        type=\"record\",\n"
"        name=\"player_schema\",\n"
"        fields={\n"
"            {name=\"id\", type=\"long\"},\n"
"            {name=\"name\", type=\"string\"},\n"
"            {\n"
"                name=\"location\",\n"
"                type= {\n"
"                    type=\"record\",\n"
"                    name=\"player_location\",\n"
"                    fields={\n"
"                        {name=\"x\", type=\"double\"},\n"
"                        {name=\"y\", type=\"double\"}\n"
"                    }\n"
"                }\n"
"            }\n"
"        }\n"
"    },\n"
"    pokemon = {\n"
"        type=\"record\",\n"
"        name=\"pokemon_schema\",\n"
"        fields={\n"
"            {name=\"id\", type=\"long\"},\n"
"            {name=\"status\", type=\"string\"},\n"
"            {name=\"name\", type=\"string\"},\n"
"            {name=\"chance\", type=\"double\"},\n"
"            {\n"
"                name=\"location\",\n"
"                type= {\n"
"                    type=\"record\",\n"
"                    name=\"pokemon_location\",\n"
"                    fields={\n"
"                        {name=\"x\", type=\"double\"},\n"
"                        {name=\"y\", type=\"double\"}\n"
"                    }\n"
"                }\n"
"            }\n"
"        }\n"
"    }\n"
"}"
msgstr ""
"local schema = {\n"
"    player = {\n"
"        type=\"record\",\n"
"        name=\"player_schema\",\n"
"        fields={\n"
"            {name=\"id\", type=\"long\"},\n"
"            {name=\"name\", type=\"string\"},\n"
"            {\n"
"                name=\"location\",\n"
"                type= {\n"
"                    type=\"record\",\n"
"                    name=\"player_location\",\n"
"                    fields={\n"
"                        {name=\"x\", type=\"double\"},\n"
"                        {name=\"y\", type=\"double\"}\n"
"                    }\n"
"                }\n"
"            }\n"
"        }\n"
"    },\n"
"    pokemon = {\n"
"        type=\"record\",\n"
"        name=\"pokemon_schema\",\n"
"        fields={\n"
"            {name=\"id\", type=\"long\"},\n"
"            {name=\"status\", type=\"string\"},\n"
"            {name=\"name\", type=\"string\"},\n"
"            {name=\"chance\", type=\"double\"},\n"
"            {\n"
"                name=\"location\",\n"
"                type= {\n"
"                    type=\"record\",\n"
"                    name=\"pokemon_location\",\n"
"                    fields={\n"
"                        {name=\"x\", type=\"double\"},\n"
"                        {name=\"y\", type=\"double\"}\n"
"                    }\n"
"                }\n"
"            }\n"
"        }\n"
"    }\n"
"}"

msgid "And here's how we create and compile our entities at initialization:"
msgstr "А вот как мы создадим и скомпилируем наши сущности при инициализации:"

msgid ""
"-- load avro-schema module with require()\n"
"local avro = require('avro_schema')\n"
"\n"
"-- create models\n"
"local ok_m, pokemon = avro.create(schema.pokemon)\n"
"local ok_p, player = avro.create(schema.player)\n"
"if ok_m and ok_p then\n"
"    -- compile models\n"
"    local ok_cm, compiled_pokemon = avro.compile(pokemon)\n"
"    local ok_cp, compiled_player = avro.compile(player)\n"
"    if ok_cm and ok_cp then\n"
"        -- start the game\n"
"        <...>\n"
"    else\n"
"        log.error('Schema compilation failed')\n"
"    end\n"
"else\n"
"    log.info('Schema creation failed')\n"
"end\n"
"return false"
msgstr ""
"-- загрузить модуль avro-schema с директивой require()\n"
"local avro = require('avro_schema')\n"
"\n"
"-- создать модели\n"
"local ok_m, pokemon = avro.create(schema.pokemon)\n"
"local ok_p, player = avro.create(schema.player)\n"
"if ok_m and ok_p then\n"
"    -- скомпилировать модели\n"
"    local ok_cm, compiled_pokemon = avro.compile(pokemon)\n"
"    local ok_cp, compiled_player = avro.compile(player)\n"
"    if ok_cm and ok_cp then\n"
"        -- начать игру\n"
"        <...>\n"
"    else\n"
"        log.error('Schema compilation failed')\n"
"    end\n"
"else\n"
"    log.info('Schema creation failed')\n"
"end\n"
"return false"

msgid ""
"As for the map entity, it would be an overkill to introduce a schema for "
"it, because we have only one map in the game, it has very few fields, and"
" -- which is most important -- we use the map only inside our logic, "
"never exposing it to external users."
msgstr ""
"Что касается сущности карты, вводить для нее схему будет перебор, потому "
"что в игре всего одна карта, у нее мало полей, и -- что самое главное -- "
"мы используем карту только внутри нашей логики, не показывая ее внешним "
"пользователям."

msgid ""
"Next, we need methods to implement the game logic. To simulate object-"
"oriented programming in our Lua code, let's store all Lua functions and "
"shared variables in a single local variable (let's name it as ``game``). "
"This will allow us to address functions or variables from within our "
"module as ``self.func_name`` or ``self.var_name``. Like this:"
msgstr ""
"Далее нам нужны методы для реализации игровой логики. Чтобы смоделировать"
" объектно-ориентированное программирование в нашем Lua-коде, будем "
"хранить все Lua-функции и общие переменные в одной внутренней переменной "
"(назовем ее ``game``). Это позволит нам обращаться к функциям или "
"переменным из нашего модуля с помощью ``self.func_name`` или "
"``self.var_name`` следующим образом:"

msgid ""
"local game = {\n"
"    -- a local variable\n"
"    num_players = 0,\n"
"\n"
"    -- a method that prints a local variable\n"
"    hello = function(self)\n"
"      print('Hello! Your player number is ' .. self.num_players .. '.')\n"
"    end,\n"
"\n"
"    -- a method that calls another method and returns a local variable\n"
"    sign_in = function(self)\n"
"      self.num_players = self.num_players + 1\n"
"      self:hello()\n"
"      return self.num_players\n"
"    end\n"
"}"
msgstr ""
"local game = {\n"
"    -- локальная переменная\n"
"    num_players = 0,\n"
"\n"
"    -- метод, который выводит локальную переменную\n"
"    hello = function(self)\n"
"      print('Hello! Your player number is ' .. self.num_players .. '.')\n"
"    end,\n"
"\n"
"    -- метод, который вызывает другой метод и возвращает локальную "
"переменную\n"
"    sign_in = function(self)\n"
"      self.num_players = self.num_players + 1\n"
"      self:hello()\n"
"      return self.num_players\n"
"    end\n"
"}"

msgid ""
"In OOP terms, we can now regard local variables inside ``game`` as object"
" fields, and local functions as object methods."
msgstr ""
"В терминах ООП сейчас мы можем рассматривать внутренние переменные внутри"
" переменной ``game`` как поля объекта, а внутренние функции -- как методы"
" объекта."

msgid ""
"In this manual, Lua examples use **local** variables. Use **global** "
"variables with caution, since the module’s users may be unaware of them."
msgstr ""
"Обратите внимание, что в текущей документации в примерах Lua-кода "
"используются *локальные* переменные. Используйте *глобальные* переменные "
"аккуратно, поскольку пользователи ваших модулей могут не знать об этих "
"переменных."

msgid ""
"To enable/disable the use of undeclared global variables in your Lua "
"code, use Tarantool's :ref:`strict <strict-module>` module."
msgstr ""
"Чтобы включить/отключить использование необъявленных глобальных "
"переменных в вашем коде на языке Lua, используйте модуль Tarantool'а "
":ref:`strict <strict-module>`."

msgid "So, our game module will have the following methods:"
msgstr "Таким образом, в модуле игры будут следующие методы:"

msgid ""
"``catch()`` to calculate whether the pokémon was caught (besides the "
"coordinates of both the player and pokémon, this method will apply a "
"probability factor, so not every pokémon within the player's reach will "
"be caught);"
msgstr ""
"``catch()`` (поймать) для расчета, когда был пойман покемон (помимо "
"координат как игрока, так и покемона, этот метод будет использовать "
"коэффициент вероятности, чтобы в пределах досягаемости игрока можно было "
"поймать не каждого покемона);"

msgid ""
"``respawn()`` to add missing pokémons to the map, say, every 60 seconds "
"(we assume that a frightened pokémon runs away, so we remove a pokémon "
"from the map on any catch attempt and add it back to the map in a while);"
msgstr ""
"``respawn()`` (респаун) для добавления отсутствующих покемонов на карту, "
"скажем, каждые 60 секунд (предположим, что испуганный покемон убегает, "
"поэтому мы убираем покемона с карты при любой попытке поймать его и через"
" некоторое время добавляем обратно на карту);"

msgid ""
"``notify()`` to log information about caught pokémons (like \"Player 1 "
"caught pokémon A\");"
msgstr ""
"``notify()`` (уведомить) для записи информации о пойманных покемонах "
"(например, \"Игрок 1 поймал покемона A\");"

msgid ""
"``start()`` to initialize the game (it will create database spaces, "
"create and compile avro schemas, and launch ``respawn()``)."
msgstr ""
"``start()`` (начать) для инициализации игры (метод создаст спейсы в базе "
"данных, создаст и скомпилирует avro-схемы, а также запустит метод "
"``respawn()``)."

msgid ""
"Besides, it would be convenient to have methods for working with "
"Tarantool storage. For example:"
msgstr ""
"Кроме того, было бы удобно завести методы для работы с хранилищем "
"Tarantool'а. Например:"

msgid "``add_pokemon()`` to add a pokémon to the database, and"
msgstr ""
"``add_pokemon()`` (добавить покемона) для добавления покемона в базу "
"данных и"

msgid "``map()`` to populate the map with all pokémons stored in Tarantool."
msgstr ""
"``map()`` (карта) для заполнения карты всеми покемонами, которые хранятся"
" в Tarantool'е."

msgid ""
"We'll need these two methods primarily when initializing our game, but we"
" can also call them later, for example to test our code."
msgstr ""
"Эти два метода будут главным образом использоваться во время "
"инициализации нашей игры, но их также можно вызывать позднее, например "
"для тестирования кода."

msgid "Bootstrapping a database"
msgstr "Настройка базы данных"

msgid ""
"Let's discuss game initialization. In ``start()`` method, we need to "
"populate Tarantool spaces with pokémon data. Why not keep all game data "
"in memory? Why use a database? The answer is: :ref:`persistence <index-"
"box_persistence>`. Without a database, we risk losing data on power "
"outage, for example. But if we store our data in an in-memory database, "
"Tarantool takes care to persist it on disk whenever it's changed. This "
"gives us one more benefit: quick startup in case of failure. Tarantool "
"has a :ref:`smart algorithm <internals-recovery_process>` that quickly "
"loads all data from disk into memory on startup, so the warm-up takes "
"little time."
msgstr ""
"Обсудим инициализацию игры. В методе ``start()`` нам нужно заполнить "
"спейсы Tarantool'а данными о покемонах. Почему бы не хранить все игровые "
"данные в памяти? Зачем нужна база данных? Ответ на это: "
":ref:`персистентность <index-box_persistence>`. Без базы данных мы "
"рискуем потерять данные при отключении электроэнергии, например. Но если "
"мы храним данные в in-memory базе данных, Tarantool позаботится о том, "
"чтобы обеспечить постоянное хранение данных при их изменении. Это дает "
"дополнительное преимущество: быстрая загрузка в случае отказа. "
":ref:`Умный алгоритм <internals-recovery_process>` Tarantool'а быстро "
"загружает все данные с диска в память при начале работы, так что "
"подготовка к работе не займет много времени."

msgid ""
"We'll be using functions from Tarantool built-in :ref:`box <box-module>` "
"module:"
msgstr ""
"Мы будем использовать функции из встроенного модуля Tarantool'а :ref:`box"
" <box-module>`:"

msgid ""
"``box.schema.create_space('pokemons')`` to create a space named "
"``pokemon`` for storing information about pokémons (we don't create a "
"similar space for players, because we intend to only send/receive player "
"information via API calls, so we needn't store it);"
msgstr ""
"``box.schema.create_space('pokemons')`` для создания спейса под названием"
" ``pokemon`` (покемон), чтобы хранить информацию о покемонах (мы не "
"создаем аналогичный спейс по игрокам, потому что планируем только "
"отправлять и получать информацию об игроках с помощью вызовов API, так "
"что нет необходимости хранить ее);"

msgid ""
"``box.space.pokemons:create_index('primary', {type = 'hash', parts = {1, "
"'unsigned'}})`` to create a primary HASH index by pokémon ID;"
msgstr ""
"``box.space.pokemons:create_index('primary', {type = 'hash', parts = {1, "
"'unsigned'}})`` для создания первичного HASH-индекса по ID покемона;"

msgid ""
"``box.space.pokemons:create_index('status', {type = 'tree', parts = {2, "
"'str'}})`` to create a secondary TREE index by pokémon status."
msgstr ""
"``box.space.pokemons:create_index('status', {type = 'tree', parts = {2, "
"'str'}})`` для создания вторичного TREE-индекса по статусу покемона."

msgid ""
"Notice the ``parts =`` argument in the index specification. The pokémon "
"ID is the first field in a Tarantool tuple since it’s the first member of"
" the respective Avro type. So does the pokémon status. The actual JSON "
"document may have ID or status fields at any position of the JSON map."
msgstr ""
"Обратите внимание на аргумент ``parts =`` в спецификации индекса. ID "
"покемона -- это первое поле в кортеже Tarantool'а, потому что это первый "
"элемент соответствующего типа Avro. То же относится к статусу покемона. В"
" самом JSON-файле поля ID или статуса могут быть в любом положении на "
"JSON-карте."

msgid "The implementation of ``start()`` method looks like this:"
msgstr "Реализация метода ``start()`` выглядит следующим образом:"

msgid ""
"-- create game object\n"
"start = function(self)\n"
"    -- create spaces and indexes\n"
"    box.once('init', function()\n"
"        box.schema.create_space('pokemons')\n"
"        box.space.pokemons:create_index(\n"
"            \"primary\", {type = 'hash', parts = {1, 'unsigned'}}\n"
"        )\n"
"        box.space.pokemons:create_index(\n"
"            \"status\", {type = \"tree\", parts = {2, 'str'}}\n"
"        )\n"
"    end)\n"
"\n"
"    -- create models\n"
"    local ok_m, pokemon = avro.create(schema.pokemon)\n"
"    local ok_p, player = avro.create(schema.player)\n"
"    if ok_m and ok_p then\n"
"        -- compile models\n"
"        local ok_cm, compiled_pokemon = avro.compile(pokemon)\n"
"        local ok_cp, compiled_player = avro.compile(player)\n"
"        if ok_cm and ok_cp then\n"
"            -- start the game\n"
"            <...>\n"
"        else\n"
"            log.error('Schema compilation failed')\n"
"        end\n"
"    else\n"
"        log.info('Schema creation failed')\n"
"    end\n"
"    return false\n"
"end"
msgstr ""
"-- создать игровой объект\n"
"start = function(self)\n"
"    -- создать спейсы и индексы\n"
"    box.once('init', function()\n"
"        box.schema.create_space('pokemons')\n"
"        box.space.pokemons:create_index(\n"
"            \"primary\", {type = 'hash', parts = {1, 'unsigned'}}\n"
"        )\n"
"        box.space.pokemons:create_index(\n"
"            \"status\", {type = \"tree\", parts = {2, 'str'}}\n"
"        )\n"
"    end)\n"
"\n"
"    -- создать модели\n"
"    local ok_m, pokemon = avro.create(schema.pokemon)\n"
"    local ok_p, player = avro.create(schema.player)\n"
"    if ok_m and ok_p then\n"
"        -- скомпилировать модели\n"
"        local ok_cm, compiled_pokemon = avro.compile(pokemon)\n"
"        local ok_cp, compiled_player = avro.compile(player)\n"
"        if ok_cm and ok_cp then\n"
"            -- начать игру\n"
"            <...>\n"
"        else\n"
"            log.error('Schema compilation failed')\n"
"        end\n"
"    else\n"
"        log.info('Schema creation failed')\n"
"    end\n"
"    return false\n"
"end"

msgid "GIS"
msgstr "ГИС"

msgid ""
"Now let's discuss ``catch()``, which is the main method in our gaming "
"logic."
msgstr ""
"Теперь обсудим метод ``catch()``, который является основным в логике "
"нашей игры."

msgid ""
"Here we receive the player's coordinates and the target pokémon's ID "
"number, and we need to answer whether the player has actually caught the "
"pokémon or not (remember that each pokémon has a chance to escape)."
msgstr ""
"Здесь мы получаем координаты игрока и номер ID искомого покемона, а нужен"
" нам ответ на вопрос, поймал ли игрок покемона (помните, что у каждого "
"покемона есть шанс убежать)."

msgid ""
"First thing, we validate the received player data against its :ref:`Avro "
"schema <app_server-avro_schemas>`. And we check whether such a pokémon "
"exists in our database and is displayed on the map (the pokémon must have"
" the active status):"
msgstr ""
"Для начала проверим полученные данные об игроке по :ref:`Avro-схеме "
"<app_server-avro_schemas>`. Также проверим, есть ли такой покемон в базе "
"данных, и отображается ли он на карте (у покемона должен быть активный "
"статус):"

msgid ""
"catch = function(self, pokemon_id, player)\n"
"    -- check player data\n"
"    local ok, tuple = self.player_model.flatten(player)\n"
"    if not ok then\n"
"        return false\n"
"    end\n"
"    -- get pokemon data\n"
"    local p_tuple = box.space.pokemons:get(pokemon_id)\n"
"    if p_tuple == nil then\n"
"        return false\n"
"    end\n"
"    local ok, pokemon = self.pokemon_model.unflatten(p_tuple)\n"
"    if not ok then\n"
"        return false\n"
"    end\n"
"    if pokemon.status ~= self.state.ACTIVE then\n"
"        return false\n"
"    end\n"
"    -- more catch logic to follow\n"
"    <...>\n"
"end"
msgstr ""
"catch = function(self, pokemon_id, player)\n"
"    -- проверить данные игрока\n"
"    local ok, tuple = self.player_model.flatten(player)\n"
"    if not ok then\n"
"        return false\n"
"    end\n"
"    -- получить данные покемона\n"
"    local p_tuple = box.space.pokemons:get(pokemon_id)\n"
"    if p_tuple == nil then\n"
"        return false\n"
"    end\n"
"    local ok, pokemon = self.pokemon_model.unflatten(p_tuple)\n"
"    if not ok then\n"
"        return false\n"
"    end\n"
"    if pokemon.status ~= self.state.ACTIVE then\n"
"        return false\n"
"    end\n"
"    -- логика поимки будет дополняться\n"
"    <...>\n"
"end"

msgid "Next, we calculate the answer: caught or not."
msgstr "Далее вычисляем ответ: пойман или нет."

msgid ""
"To work with geographical coordinates, we use Tarantool `gis "
"<https://github.com/tarantool/gis>`_ module."
msgstr ""
"Чтобы работать с географическими координатами, используем модуль "
"Tarantool'а `gis <https://github.com/tarantool/gis>`_."

msgid ""
"To keep things simple, we don't load any specific map, assuming that we "
"deal with a world map. And we do not validate incoming coordinates, "
"assuming again that all received locations are within the planet Earth."
msgstr ""
"Чтобы не усложнять, не будем загружать какую-то особую карту, допуская, "
"что рассматриваем карту мира. Также не будет проверять поступающие "
"координаты, снова допуская, что все места находятся на планете Земля."

msgid "We use two geo-specific variables:"
msgstr "Используем две географические переменные:"

msgid ""
"``wgs84``, which stands for the latest revision of the World Geodetic "
"System standard, `WGS84 "
"<https://en.wikipedia.org/wiki/World_Geodetic_System#WGS84>`_. Basically,"
" it comprises a standard coordinate system for the Earth and represents "
"the Earth as an ellipsoid."
msgstr ""
"``wgs84``, что означает последнюю редакцию стандарта Мировой "
"геодезической системы координат, `WGS84 "
"<https://en.wikipedia.org/wiki/World_Geodetic_System#WGS84>`_. В целом, "
"она представляет собой стандартную систему координат Земли и изображает "
"Землю как эллипсоид."

msgid ""
"``nationalmap``, which stands for the `US National Atlas Equal Area "
"<https://epsg.io/2163>`_. This is a projected coordinates system based on"
" WGS84. It gives us a zero base for location projection and allows "
"positioning our players and pokémons in meters."
msgstr ""
"``nationalmap``, что означает `Государственный атлас США в равновеликой "
"проекции (US National Atlas Equal Area) <https://epsg.io/2163>`_. Это "
"система спроецированных координат на основании WGS84. Она дает основу для"
" проецирования мест и позволяет определить местоположение наших игроков и"
" покемонов в метрах."

msgid ""
"Both these systems are listed in the EPSG Geodetic Parameter Registry, "
"where each system has a unique number. In our code, we assign these "
"listing numbers to respective variables:"
msgstr ""
"Обе системы указаны в Реестре геодезических параметров EPSG, где каждой "
"системе присвоен уникальный номер. Мы назначим эти числа соответствующим "
"переменным в нашем коде:"

msgid ""
"wgs84 = 4326,\n"
"nationalmap = 2163,"
msgstr ""
"wgs84 = 4326,\n"
"nationalmap = 2163,"

msgid ""
"For our game logic, we need one more variable, ``catch_distance``, which "
"defines how close a player must get to a pokémon before trying to catch "
"it. Let's set the distance to 100 meters."
msgstr ""
"Для игровой логики необходима еще одна переменная ``catch_distance``, "
"которая определяет, насколько близко игрок должен подойти к покемону, "
"чтобы попытаться поймать его. Определим это расстояние в 100 метров."

msgid "catch_distance = 100,"
msgstr "catch_distance = 100,"

msgid ""
"Now we're ready to calculate the answer. We need to project the current "
"location of both player (``p_pos``) and pokémon (``m_pos``) on the map, "
"check whether the player is close enough to the pokémon (using "
"``catch_distance``), and calculate whether the player has caught the "
"pokémon (here we generate some random value and let the pokémon escape if"
" the random value happens to be less than 100 minus pokémon's chance "
"value):"
msgstr ""
"Теперь можно рассчитать ответ. Необходимо спроецировать текущее "
"местоположение как игрока (``p_pos``), так и покемона (``m_pos``) на "
"карте, проверить, достаточно ли близко к покемону находится игрок (с "
"помощью ``catch_distance``), и рассчитать, поймал ли игрок покемона "
"(здесь мы генерируем случайное значение, и покемон убегает, если "
"случайное значение оказывается меньше, чем 100 минус случайная величина "
"покемона):"

msgid ""
"-- project locations\n"
"local m_pos = gis.Point(\n"
"    {pokemon.location.x, pokemon.location.y}, self.wgs84\n"
"):transform(self.nationalmap)\n"
"local p_pos = gis.Point(\n"
"    {player.location.x, player.location.y}, self.wgs84\n"
"):transform(self.nationalmap)\n"
"\n"
"-- check catch distance condition\n"
"if p_pos:distance(m_pos) > self.catch_distance then\n"
"    return false\n"
"end\n"
"-- try to catch pokemon\n"
"local caught = math.random(100) >= 100 - pokemon.chance\n"
"if caught then\n"
"    -- update and notify on success\n"
"    box.space.pokemons:update(\n"
"        pokemon_id, {{'=', self.STATUS, self.state.CAUGHT}}\n"
"    )\n"
"    self:notify(player, pokemon)\n"
"end\n"
"return caught"
msgstr ""
"-- спроецировать местоположение\n"
" local m_pos = gis.Point(\n"
"     {pokemon.location.x, pokemon.location.y}, self.wgs84\n"
" ):transform(self.nationalmap)\n"
" local p_pos = gis.Point(\n"
"     {player.location.x, player.location.y}, self.wgs84\n"
" ):transform(self.nationalmap)\n"
" \n"
" -- проверить условие близости игрока\n"
" if p_pos:distance(m_pos) > self.catch_distance then\n"
"     return false\n"
" end\n"
" -- попытаться поймать покемона\n"
" local caught = math.random(100) >= 100 - pokemon.chance\n"
" if caught then\n"
"     -- обновить и сообщить об успехе\n"
"     box.space.pokemons:update(\n"
"         pokemon_id, {{'=', self.STATUS, self.state.CAUGHT}}\n"
"     )\n"
"     self:notify(player, pokemon)\n"
" end\n"
" return caught"

msgid "Index iterators"
msgstr "Итератор с индексом"

msgid ""
"By our gameplay, all caught pokémons are returned back to the map. We do "
"this for all pokémons on the map every 60 seconds using ``respawn()`` "
"method. We iterate through pokémons by status using Tarantool index "
"iterator function :doc:`/reference/reference_lua/box_index/pairs` and "
"reset the statuses of all \"caught\" pokémons back to \"active\" using "
"``box.space.pokemons:update()``."
msgstr ""
"По сюжету игры все пойманные покемоны возвращаются на карту. Метод "
"``respawn()`` обеспечивает это для всех покемонов на карте каждые 60 "
"секунд. Мы выполняем перебор покемонов по статусу с помощью функции "
"Tarantool'а итератора с индексом "
":doc:`/reference/reference_lua/box_index/pairs` и сбрасываем статусы всех"
" \"пойманных\" покемонов обратно на \"активный\" с помощью "
"``box.space.pokemons:update()``."

msgid ""
"respawn = function(self)\n"
"    fiber.name('Respawn fiber')\n"
"    for _, tuple in box.space.pokemons.index.status:pairs(\n"
"           self.state.CAUGHT) do\n"
"        box.space.pokemons:update(\n"
"            tuple[self.ID],\n"
"            {{'=', self.STATUS, self.state.ACTIVE}}\n"
"        )\n"
"    end\n"
" end"
msgstr ""
"respawn = function(self)\n"
"    fiber.name('Respawn fiber')\n"
"    for _, tuple in box.space.pokemons.index.status:pairs(\n"
"           self.state.CAUGHT) do\n"
"        box.space.pokemons:update(\n"
"            tuple[self.ID],\n"
"            {{'=', self.STATUS, self.state.ACTIVE}}\n"
"        )\n"
"    end\n"
" end"

msgid "For readability, we introduce named fields:"
msgstr "Для удобства введем именованные поля:"

msgid "ID = 1, STATUS = 2,"
msgstr "ID = 1, STATUS = 2,"

msgid "The complete implementation of ``start()`` now looks like this:"
msgstr "Реализация метода ``start()`` полностью теперь выглядит так:"

msgid ""
"-- create game object\n"
"start = function(self)\n"
"    -- create spaces and indexes\n"
"    box.once('init', function()\n"
"       box.schema.create_space('pokemons')\n"
"       box.space.pokemons:create_index(\n"
"           \"primary\", {type = 'hash', parts = {1, 'unsigned'}}\n"
"       )\n"
"       box.space.pokemons:create_index(\n"
"           \"status\", {type = \"tree\", parts = {2, 'str'}}\n"
"       )\n"
"    end)\n"
"\n"
"    -- create models\n"
"    local ok_m, pokemon = avro.create(schema.pokemon)\n"
"    local ok_p, player = avro.create(schema.player)\n"
"    if ok_m and ok_p then\n"
"        -- compile models\n"
"        local ok_cm, compiled_pokemon = avro.compile(pokemon)\n"
"        local ok_cp, compiled_player = avro.compile(player)\n"
"        if ok_cm and ok_cp then\n"
"            -- start the game\n"
"            self.pokemon_model = compiled_pokemon\n"
"            self.player_model = compiled_player\n"
"            self.respawn()\n"
"            log.info('Started')\n"
"            return true\n"
"         else\n"
"            log.error('Schema compilation failed')\n"
"         end\n"
"    else\n"
"        log.info('Schema creation failed')\n"
"    end\n"
"    return false\n"
"end"
msgstr ""
"-- создать игровой объект\n"
"start = function(self)\n"
"    -- создать спейсы и индексы\n"
"    box.once('init', function()\n"
"       box.schema.create_space('pokemons')\n"
"       box.space.pokemons:create_index(\n"
"           \"primary\", {type = 'hash', parts = {1, 'unsigned'}}\n"
"       )\n"
"       box.space.pokemons:create_index(\n"
"           \"status\", {type = \"tree\", parts = {2, 'str'}}\n"
"       )\n"
"    end)\n"
"\n"
"    -- создать модели\n"
"    local ok_m, pokemon = avro.create(schema.pokemon)\n"
"    local ok_p, player = avro.create(schema.player)\n"
"    if ok_m and ok_p then\n"
"        -- скомпилировать модели\n"
"        local ok_cm, compiled_pokemon = avro.compile(pokemon)\n"
"        local ok_cp, compiled_player = avro.compile(player)\n"
"        if ok_cm and ok_cp then\n"
"            -- начать игру\n"
"            self.pokemon_model = compiled_pokemon\n"
"            self.player_model = compiled_player\n"
"            self.respawn()\n"
"            log.info('Started')\n"
"            return true\n"
"         else\n"
"            log.error('Schema compilation failed')\n"
"         end\n"
"    else\n"
"        log.info('Schema creation failed')\n"
"    end\n"
"    return false\n"
"end"

msgid "Fibers"
msgstr "Файберы"

msgid ""
"But wait! If we launch it as shown above -- ``self.respawn()`` -- the "
"function will be executed only once, just like all the other methods. But"
" we need to execute ``respawn()`` every 60 seconds. Creating a "
":ref:`fiber <fiber-module>` is the Tarantool way of making application "
"logic work in the background at all times."
msgstr ""
"Но подождите! Если мы запустим функцию ``self.respawn()``, как показано "
"выше, то она запустится только один раз, как и остальные методы. А нам "
"необходимо запускать ``respawn()`` каждые 60 секунд. Tarantool заставляет"
" логику приложения непрерывно работать в фоновом режиме с помощью "
":ref:`файбера <fiber-module>`."

msgid ""
"A **fiber** exists for executing instruction sequences but it is not a "
"thread. The key difference is that threads use preemptive multitasking, "
"while fibers use cooperative multitasking. This gives fibers the "
"following two advantages over threads:"
msgstr ""
"**Файбер** предназначен для выполнения последовательностей команд, но это"
" не поток. Ключевое отличие в том, что потоки используют многозадачность "
"с реализацией приоритетов, тогда как файберы используют кооперативную "
"многозадачность. Это дает файберам два преимущества над потоками:"

msgid ""
"Better controllability. Threads often depend on the kernel's thread "
"scheduler to preempt a busy thread and resume another thread, so "
"preemption may occur unpredictably. Fibers yield themselves to run "
"another fiber while executing, so yields are controlled by application "
"logic."
msgstr ""
"Улучшенная управляемость. Потоки часто зависят от планировщика потока "
"ядра в вопросе вытеснения занятого потока и возобновления другого потока,"
" поэтому вытеснение может быть непредвиденным. Файберы передают "
"управление самостоятельно другому файберу во время работы, поэтому "
"управление файберами осуществляется логикой приложения."

msgid ""
"Higher performance. Threads require more resources to preempt as they "
"need to address the system kernel. Fibers are lighter and faster as they "
"don't need to address the kernel to yield."
msgstr ""
"Повышенная производительность. Потокам необходимо больше ресурсов для "
"вытеснения, поскольку они обращаются к ядру системы. Файберы легче и "
"быстрее, поскольку для передачи управления им не нужно обращаться к ядру."

msgid ""
"Yet fibers have some limitations as compared with threads, the main "
"limitation being no multi-core mode. All fibers in an application belong "
"to a single thread, so they all use the same CPU core as the parent "
"thread. Meanwhile, this limitation is not really serious for Tarantool "
"applications, because a typical bottleneck for Tarantool is the HDD, not "
"the CPU."
msgstr ""
"Однако у файберов есть определенные ограничения, по сравнению с потоками,"
" основное из которых -- отсутствие режима работы с многоядерной системой."
" Все файберы в приложении относятся к одному потоку, поэтому они "
"используют то же ядро процессора, что и родительский поток. В то же "
"время, это ограничение незначительно для приложений Tarantool'а, "
"поскольку узкое место Tarantool'а -- жесткий диск, а не ЦП."

msgid ""
"A fiber has all the features of a Lua `coroutine "
"<http://www.lua.org/pil/contents.html#9>`_ and all programming concepts "
"that apply for Lua coroutines will apply for fibers as well. However, "
"Tarantool has made some enhancements for fibers and has used fibers "
"internally. So, although use of coroutines is possible and supported, use"
" of fibers is recommended."
msgstr ""
"У файбера есть все возможности `сопрограммы "
"<http://www.lua.org/pil/contents.html#9>`_ на языке Lua, и все принципы "
"программирования, которые применяются к сопрограммам на Lua, применимы и "
"к файберам. Однако Tarantool расширил возможности файберов для "
"внутреннего использования. Поэтому, несмотря на возможность и поддержку "
"использования сопрограмм, рекомендуется использовать файберы."

msgid ""
"Well, performance or controllability are of little importance in our "
"case. We'll launch ``respawn()`` in a fiber to make it work in the "
"background all the time. To do so, we'll need to amend ``respawn()``:"
msgstr ""
"Производительность или управляемость не слишком важны в нашем случае. "
"Запустим ``respawn()`` в файбере для непрерывной работы в фоновом режиме."
" Для этого необходимо изменить ``respawn()``:"

msgid ""
"respawn = function(self)\n"
"    -- let's give our fiber a name;\n"
"    -- this will produce neat output in fiber.info()\n"
"    fiber.name('Respawn fiber')\n"
"    while true do\n"
"        for _, tuple in box.space.pokemons.index.status:pairs(\n"
"                self.state.CAUGHT) do\n"
"            box.space.pokemons:update(\n"
"                tuple[self.ID],\n"
"                {{'=', self.STATUS, self.state.ACTIVE}}\n"
"            )\n"
"        end\n"
"        fiber.sleep(self.respawn_time)\n"
"    end\n"
"end"
msgstr ""
"respawn = function(self)\n"
"    -- назовем наш файбер;\n"
"    -- это выполнит чистый вывод в fiber.info()\n"
"    fiber.name('Respawn fiber')\n"
"    while true do\n"
"        for _, tuple in box.space.pokemons.index.status:pairs(\n"
"                self.state.CAUGHT) do\n"
"            box.space.pokemons:update(\n"
"                tuple[self.ID],\n"
"                {{'=', self.STATUS, self.state.ACTIVE}}\n"
"            )\n"
"        end\n"
"        fiber.sleep(self.respawn_time)\n"
"    end\n"
"end"

msgid "and call it as a fiber in ``start()``:"
msgstr "и назвать его файбером в ``start()``:"

msgid ""
"start = function(self)\n"
"    -- create spaces and indexes\n"
"        <...>\n"
"    -- create models\n"
"        <...>\n"
"    -- compile models\n"
"        <...>\n"
"    -- start the game\n"
"       self.pokemon_model = compiled_pokemon\n"
"       self.player_model = compiled_player\n"
"       fiber.create(self.respawn, self)\n"
"       log.info('Started')\n"
"    -- errors if schema creation or compilation fails\n"
"       <...>\n"
"end"
msgstr ""
"start = function(self)\n"
"    -- создать спейсы и индексы\n"
"        <...>\n"
"    -- создать модели\n"
"        <...>\n"
"    -- скомпилировать модели\n"
"        <...>\n"
"    -- начать игру\n"
"       self.pokemon_model = compiled_pokemon\n"
"       self.player_model = compiled_player\n"
"       fiber.create(self.respawn, self)\n"
"       log.info('Started')\n"
"    -- ошибки, если создание схемы или компиляция не работает\n"
"       <...>\n"
"end"

msgid "Logging"
msgstr "Запись в журнал"

msgid ""
"One more helpful function that we used in ``start()`` was ``log.infо()`` "
"from Tarantool :ref:`log <log-module>` module. We also need this function"
" in ``notify()`` to add a record to the log file on every successful "
"catch:"
msgstr ""
"В  ``start()`` мы использовали еще одну полезную функцию -- "
"``log.infо()`` из :ref:`модуля log <log-module>` Tarantool'а . Эта "
"функция также понадобится в ``notify()`` для добавления записи в файл "
"журнала при каждой успешной поимке:"

#, python-format
msgid ""
"-- event notification\n"
"notify = function(self, player, pokemon)\n"
"    log.info(\"Player '%s' caught '%s'\", player.name, pokemon.name)\n"
"end"
msgstr ""
"-- уведомление о событии\n"
"notify = function(self, player, pokemon)\n"
"    log.info(\"Player '%s' caught '%s'\", player.name, pokemon.name)\n"
"end"

msgid ""
"We use default Tarantool :ref:`log settings <cfg_logging>`, so we'll see "
"the log output in console when we launch our application in script mode."
msgstr ""
"Мы используем стандартные :ref:`настройки журнала <cfg_logging>` "
"Tarantool'а, поэтому увидим вывод записей журнала в консоли, когда "
"запустим приложение в режиме скрипта."

msgid ""
"Great! We've discussed all programming practices used in our Lua module "
"(see `pokemon.lua "
"<https://github.com/tarantool/pokemon/blob/1.9/src/pokemon.lua>`_)."
msgstr ""
"Отлично! Мы обсудили все методики программирования, используемые в нашем"
"  Lua-модуле (см. `pokemon.lua "
"<https://github.com/tarantool/pokemon/blob/1.9/src/pokemon.lua>`_)."

msgid ""
"Now let's prepare the test environment. As planned, we write a Lua "
"application (see `game.lua "
"<https://github.com/tarantool/pokemon/blob/1.9/game.lua>`_) to initialize"
" Tarantool's database module, initialize our game, call the game loop and"
" simulate a couple of player requests."
msgstr ""
"Теперь подготовим среду тестирования. Как и планировалось, напишем "
"приложение на языке Lua (см. `game.lua "
"<https://github.com/tarantool/pokemon/blob/1.9/game.lua>`_), чтобы "
"инициализировать модуль базы данных Tarantool'а, инициализировать нашу "
"игру, вызвать цикл игры и смоделировать пару запросов от игроков."

msgid ""
"To launch our microservice, we put both ``pokemon.lua`` module and "
"``game.lua`` application in the current directory, install all external "
"modules, and launch the Tarantool instance running our ``game.lua`` "
"application (this example is for Ubuntu):"
msgstr ""
"Чтобы запустить микросервис, поместим модуль ``pokemon.lua`` и приложение"
"  ``game.lua`` в текущую директорию, установим все внешние модули и "
"запустим экземпляр Tarantool'а с работают приложением ``game.lua`` (это "
"пример для Ubuntu):"

msgid ""
"$ ls\n"
"game.lua  pokemon.lua\n"
"$ sudo apt-get install tarantool-gis\n"
"$ sudo apt-get install tarantool-avro-schema\n"
"$ tarantool game.lua"
msgstr ""
"$ ls\n"
"game.lua  pokemon.lua\n"
"$ sudo apt-get install tarantool-gis\n"
"$ sudo apt-get install tarantool-avro-schema\n"
"$ tarantool game.lua"

msgid ""
"Tarantool starts and initializes the database. Then Tarantool executes "
"the demo logic from ``game.lua``: adds a pokémon named Pikachu (its "
"chance to be caught is very high, 99.1), displays the current map (it "
"contains one active pokémon, Pikachu) and processes catch requests from "
"two players. Player1 is located just near the lonely Pikachu pokémon and "
"Player2 is located far away from it. As expected, the catch results in "
"this output are \"true\" for Player1 and \"false\" for Player2. Finally, "
"Tarantool displays the current map which is empty, because Pikachu is "
"caught and temporarily inactive:"
msgstr ""
"Tarantool запускает и инициализирует базу данных. Затем Tarantool "
"выполняет демо-логику из ``game.lua``: добавляет покемона под названием "
"Пикачу (Pikachu) (шанс его поимки очень высок -- 99,1), отображает "
"текущую карту (на ней расположен один активный покемон, Пикачу) и "
"обрабатывает запросы поимки от двух игроков. Player1 (Игрок 1) находится "
"очень близко к одинокому покемону Пикачу, а Player2 (Игрок 2) находится "
"очень далеко от него. Как предполагается, результаты поимки в таком "
"выводе будут \"true\" для Player1 и \"false\" для Player2. Наконец, "
"Tarantool отображает текущую карту, которая пуста, потому что Пикачу "
"пойман и временно неактивен:"

msgid ""
"$ tarantool game.lua\n"
"2017-01-09 20:19:24.605 [6282] main/101/game.lua C> version "
"1.7.3-43-gf5fa1e1\n"
"2017-01-09 20:19:24.605 [6282] main/101/game.lua C> log level 5\n"
"2017-01-09 20:19:24.605 [6282] main/101/game.lua I> mapping 1073741824 "
"bytes for tuple arena...\n"
"2017-01-09 20:19:24.609 [6282] main/101/game.lua I> initializing an empty"
" data directory\n"
"2017-01-09 20:19:24.634 [6282] snapshot/101/main I> saving snapshot "
"`./00000000000000000000.snap.inprogress'\n"
"2017-01-09 20:19:24.635 [6282] snapshot/101/main I> done\n"
"2017-01-09 20:19:24.641 [6282] main/101/game.lua I> ready to accept "
"requests\n"
"2017-01-09 20:19:24.786 [6282] main/101/game.lua I> Started\n"
"---\n"
"- {'id': 1, 'status': 'active', 'location': {'y': 2, 'x': 1}, 'name': "
"'Pikachu', 'chance': 99.1}\n"
"...\n"
"\n"
"2017-01-09 20:19:24.789 [6282] main/101/game.lua I> Player 'Player1' "
"caught 'Pikachu'\n"
"true\n"
"false\n"
"--- []\n"
"...\n"
"\n"
"2017-01-09 20:19:24.789 [6282] main C> entering the event loop"
msgstr ""
"$ tarantool game.lua\n"
"2017-01-09 20:19:24.605 [6282] main/101/game.lua C> version "
"1.7.3-43-gf5fa1e1\n"
"2017-01-09 20:19:24.605 [6282] main/101/game.lua C> log level 5\n"
"2017-01-09 20:19:24.605 [6282] main/101/game.lua I> mapping 1073741824 "
"bytes for tuple arena...\n"
"2017-01-09 20:19:24.609 [6282] main/101/game.lua I> initializing an empty"
" data directory\n"
"2017-01-09 20:19:24.634 [6282] snapshot/101/main I> saving snapshot "
"`./00000000000000000000.snap.inprogress'\n"
"2017-01-09 20:19:24.635 [6282] snapshot/101/main I> done\n"
"2017-01-09 20:19:24.641 [6282] main/101/game.lua I> ready to accept "
"requests\n"
"2017-01-09 20:19:24.786 [6282] main/101/game.lua I> Started\n"
"---\n"
"- {'id': 1, 'status': 'active', 'location': {'y': 2, 'x': 1}, 'name': "
"'Pikachu', 'chance': 99.1}\n"
"...\n"
"\n"
"2017-01-09 20:19:24.789 [6282] main/101/game.lua I> Player 'Player1' "
"caught 'Pikachu'\n"
"true\n"
"false\n"
"--- []\n"
"...\n"
"\n"
"2017-01-09 20:19:24.789 [6282] main C> entering the event loop"

msgid "nginx"
msgstr "nginx"

msgid ""
"In the real life, this microservice would work over HTTP. Let's add "
"`nginx <https://nginx.org/en/>`_ web server to our environment and make a"
" similar demo. But how do we make Tarantool methods callable via REST "
"API? We use nginx with `Tarantool nginx upstream "
"<https://github.com/tarantool/nginx_upstream_module>`_ module and create "
"one more Lua script (`app.lua "
"<https://github.com/tarantool/pokemon/blob/1.9/src/app.lua>`_) that "
"exports three of our game methods -- ``add_pokemon()``, ``map()`` and "
"``catch()`` -- as REST endpoints of the nginx upstream module:"
msgstr ""
"В реальной жизни такой микросервис работал бы по HTTP. Добавим веб-сервер"
" `nginx <https://nginx.org/en/>`_ в нашу среду и сделаем аналогичный "
"пример. Но как вызывать методы Tarantool'а с помощью REST API? Мы "
"используем nginx с модулем `Tarantool nginx upstream "
"<https://github.com/tarantool/nginx_upstream_module>`_ и создадим еще "
"один скрипт на Lua (`app.lua "
"<https://github.com/tarantool/pokemon/blob/1.9/src/app.lua>`_), который "
"экспортирует три наших игровых метода -- ``add_pokemon()``, ``map()`` и "
"``catch()`` -- в качестве конечных точек обработки запросов REST модуля "
"nginx upstream:"

msgid ""
"local game = require('pokemon')\n"
"box.cfg{listen=3301}\n"
"game:start()\n"
"\n"
"-- add, map and catch functions exposed to REST API\n"
"function add(request, pokemon)\n"
"    return {\n"
"        result=game:add_pokemon(pokemon)\n"
"    }\n"
"end\n"
"\n"
"function map(request)\n"
"    return {\n"
"        map=game:map()\n"
"    }\n"
"end\n"
"\n"
"function catch(request, pid, player)\n"
"    local id = tonumber(pid)\n"
"    if id == nil then\n"
"        return {result=false}\n"
"    end\n"
"    return {\n"
"        result=game:catch(id, player)\n"
"    }\n"
"end"
msgstr ""
"local game = require('pokemon')\n"
"box.cfg{listen=3301}\n"
"game:start()\n"
"\n"
"-- функции add, map и catch по REST API\n"
"function add(request, pokemon)\n"
"    return {\n"
"        result=game:add_pokemon(pokemon)\n"
"    }\n"
"end\n"
"\n"
"function map(request)\n"
"    return {\n"
"        map=game:map()\n"
"    }\n"
"end\n"
"\n"
"function catch(request, pid, player)\n"
"    local id = tonumber(pid)\n"
"    if id == nil then\n"
"        return {result=false}\n"
"    end\n"
"    return {\n"
"        result=game:catch(id, player)\n"
"    }\n"
"end"

msgid ""
"An easy way to configure and launch nginx would be to create a Docker "
"container based on a `Docker image <https://hub.docker.com/r/tarantool"
"/tarantool-nginx/>`_ with nginx and the upstream module already installed"
" (see `http/Dockerfile "
"<https://github.com/tarantool/pokemon/blob/1.9/http/Dockerfile>`_). We "
"take a standard `nginx.conf "
"<https://github.com/tarantool/pokemon/blob/1.9/http/nginx.conf>`_, where "
"we define an upstream with our Tarantool backend running (this is another"
" Docker container, see details below):"
msgstr ""
"Чтобы с легкостью настроить и запустить nginx, необходимо создать "
"Docker-контейнер на основе `Docker-образа "
"<https://hub.docker.com/r/tarantool /tarantool-nginx/>`_ с уже "
"установленными nginx и модулем upstream (см. `http/Dockerfile "
"<https://github.com/tarantool/pokemon/blob/1.9/http/Dockerfile>`_). Берем"
" стандартный `nginx.conf "
"<https://github.com/tarantool/pokemon/blob/1.9/http/nginx.conf>`_, где "
"определяем upstream с работающим бэкендом Tarantool'а (это еще один "
"Docker-контейнер, см. нижеприведенную информацию):"

msgid ""
"upstream tnt {\n"
"      server pserver:3301 max_fails=1 fail_timeout=60s;\n"
"      keepalive 250000;\n"
"}"
msgstr ""
"upstream tnt {\n"
"      server pserver:3301 max_fails=1 fail_timeout=60s;\n"
"      keepalive 250000;\n"
"}"

msgid ""
"and add some Tarantool-specific parameters (see descriptions in the "
"upstream module's `README "
"<https://github.com/tarantool/nginx_upstream_module#directives>`_ file):"
msgstr ""
"и добавляем специальные параметры для Tarantool'а (см. описание в файле "
"`README <https://github.com/tarantool/nginx_upstream_module#directives>`_"
" модуля upstream):"

msgid ""
"server {\n"
"  server_name tnt_test;\n"
"\n"
"  listen 80 default deferred reuseport so_keepalive=on backlog=65535;\n"
"\n"
"  location = / {\n"
"      root /usr/local/nginx/html;\n"
"  }\n"
"\n"
"  location /api {\n"
"    # answers check infinity timeout\n"
"    tnt_read_timeout 60m;\n"
"    if ( $request_method = GET ) {\n"
"       tnt_method \"map\";\n"
"    }\n"
"    tnt_http_rest_methods get;\n"
"    tnt_http_methods all;\n"
"    tnt_multireturn_skip_count 2;\n"
"    tnt_pure_result on;\n"
"    tnt_pass_http_request on parse_args;\n"
"    tnt_pass tnt;\n"
"  }\n"
"}"
msgstr ""
"server {\n"
"  server_name tnt_test;\n"
"\n"
"  listen 80 default deferred reuseport so_keepalive=on backlog=65535;\n"
"\n"
"  location = / {\n"
"      root /usr/local/nginx/html;\n"
"  }\n"
"\n"
"  location /api {\n"
"    # ответы проверяют бесконечное время ожидания\n"
"    tnt_read_timeout 60m;\n"
"    if ( $request_method = GET ) {\n"
"       tnt_method \"map\";\n"
"    }\n"
"    tnt_http_rest_methods get;\n"
"    tnt_http_methods all;\n"
"    tnt_multireturn_skip_count 2;\n"
"    tnt_pure_result on;\n"
"    tnt_pass_http_request on parse_args;\n"
"    tnt_pass tnt;\n"
"  }\n"
"}"

msgid ""
"Likewise, we put Tarantool server and all our game logic in a second "
"Docker container based on the `official Tarantool 1.9 image "
"<https://github.com/tarantool/docker>`_ (see `src/Dockerfile "
"<https://github.com/tarantool/pokemon/blob/1.9/src/Dockerfile>`_) and set"
" the container's default command to ``tarantool app.lua``. This is the "
"backend."
msgstr ""
"Аналогичным образом, поместим Tarantool-сервер и всю игровую логику в "
"другой Docker-контейнер на основе `официального образа Tarantool'а 1.9 "
"<https://github.com/tarantool/docker>`_ (см. `src/Dockerfile "
"<https://github.com/tarantool/pokemon/blob/1.9/src/Dockerfile>`_) и "
"установим ``tarantool app.lua`` в качестве стандартной команды для "
"контейнера. Это бэкенд."

msgid "Non-blocking IO"
msgstr "Неблокирующий ввод-вывод"

msgid ""
"To test the REST API, we create a new script (`client.lua "
"<https://github.com/tarantool/pokemon/blob/1.9/client/client.lua>`_), "
"which is similar to our ``game.lua`` application, but makes HTTP POST and"
" GET requests rather than calling Lua functions:"
msgstr ""
"Чтобы протестировать REST API, создадим новый скрипт (`client.lua "
"<https://github.com/tarantool/pokemon/blob/1.9/client/client.lua>`_), "
"который похож на наше приложение ``game.lua``, но отправляет запросы HTTP"
" POST и GET, а не вызывает Lua-функции:"

#, python-format
msgid ""
"local http = require('curl').http()\n"
"local json = require('json')\n"
"local URI = os.getenv('SERVER_URI')\n"
"local fiber = require('fiber')\n"
"\n"
"local player1 = {\n"
"    name=\"Player1\",\n"
"    id=1,\n"
"    location = {\n"
"        x=1.0001,\n"
"        y=2.0003\n"
"    }\n"
"}\n"
"local player2 = {\n"
"    name=\"Player2\",\n"
"    id=2,\n"
"    location = {\n"
"        x=30.123,\n"
"        y=40.456\n"
"    }\n"
"}\n"
"\n"
"local pokemon = {\n"
"    name=\"Pikachu\",\n"
"    chance=99.1,\n"
"    id=1,\n"
"    status=\"active\",\n"
"    location = {\n"
"        x=1,\n"
"        y=2\n"
"    }\n"
"}\n"
"\n"
"function request(method, body, id)\n"
"    local resp = http:request(\n"
"        method, URI, body\n"
"    )\n"
"    if id ~= nil then\n"
"        print(string.format('Player %d result: %s',\n"
"            id, resp.body))\n"
"    else\n"
"        print(resp.body)\n"
"    end\n"
"end\n"
"\n"
"local players = {}\n"
"function catch(player)\n"
"    fiber.sleep(math.random(5))\n"
"    print('Catch pokemon by player ' .. tostring(player.id))\n"
"    request(\n"
"        'POST', '{\"method\": \"catch\",\n"
"        \"params\": [1, '..json.encode(player)..']}',\n"
"        tostring(player.id)\n"
"    )\n"
"    table.insert(players, player.id)\n"
"end\n"
"\n"
"print('Create pokemon')\n"
"request('POST', '{\"method\": \"add\",\n"
"    \"params\": ['..json.encode(pokemon)..']}')\n"
"request('GET', '')\n"
"\n"
"fiber.create(catch, player1)\n"
"fiber.create(catch, player2)\n"
"\n"
"-- wait for players\n"
"while #players ~= 2 do\n"
"    fiber.sleep(0.001)\n"
"end\n"
"\n"
"request('GET', '')\n"
"os.exit()"
msgstr ""
"local http = require('curl').http()\n"
"local json = require('json')\n"
"local URI = os.getenv('SERVER_URI')\n"
"local fiber = require('fiber')\n"
"\n"
"local player1 = {\n"
"    name=\"Player1\",\n"
"    id=1,\n"
"    location = {\n"
"        x=1.0001,\n"
"        y=2.0003\n"
"    }\n"
"}\n"
"local player2 = {\n"
"    name=\"Player2\",\n"
"    id=2,\n"
"    location = {\n"
"        x=30.123,\n"
"        y=40.456\n"
"    }\n"
"}\n"
"\n"
"local pokemon = {\n"
"    name=\"Pikachu\",\n"
"    chance=99.1,\n"
"    id=1,\n"
"    status=\"active\",\n"
"    location = {\n"
"        x=1,\n"
"        y=2\n"
"    }\n"
"}\n"
"\n"
"function request(method, body, id)\n"
"    local resp = http:request(\n"
"        method, URI, body\n"
"    )\n"
"    if id ~= nil then\n"
"        print(string.format('Player %d result: %s',\n"
"            id, resp.body))\n"
"    else\n"
"        print(resp.body)\n"
"    end\n"
"end\n"
"\n"
"local players = {}\n"
"function catch(player)\n"
"    fiber.sleep(math.random(5))\n"
"    print('Catch pokemon by player ' .. tostring(player.id))\n"
"    request(\n"
"        'POST', '{\"method\": \"catch\",\n"
"        \"params\": [1, '..json.encode(player)..']}',\n"
"        tostring(player.id)\n"
"    )\n"
"    table.insert(players, player.id)\n"
"end\n"
"\n"
"print('Create pokemon')\n"
"request('POST', '{\"method\": \"add\",\n"
"    \"params\": ['..json.encode(pokemon)..']}')\n"
"request('GET', '')\n"
"\n"
"fiber.create(catch, player1)\n"
"fiber.create(catch, player2)\n"
"\n"
"-- подождать игроков\n"
"while #players ~= 2 do\n"
"    fiber.sleep(0.001)\n"
"end\n"
"\n"
"request('GET', '')\n"
"os.exit()"

msgid ""
"When you run this script, you’ll notice that both players have equal "
"chances to make the first attempt at catching the pokémon. In a classical"
" Lua script, a networked call blocks the script until it’s finished, so "
"the first catch attempt can only be done by the player who entered the "
"game first. In Tarantool, both players play concurrently, since all "
"modules are integrated with Tarantool :ref:`cooperative multitasking "
"<atomic-cooperative_multitasking>` and use non-blocking I/O."
msgstr ""
"При запуске этого скрипта вы заметите, что у обоих игроков одинаковые "
"шансы сделать первую попытку поимки покемона. В классическом Lua-скрипте "
"сетевой вызов блокирует скрипт, пока он не будет выполнен, поэтому первым"
" попытаться поймать может тот игрок, который раньше зашел в игру. В "
"Tarantool'е оба игрока играют одновременно, поскольку все модули "
"объединены в :ref:`кооперативной многозадачности <atomic-"
"cooperative_multitasking>` и используют неблокирующий ввод-вывод."

msgid ""
"Indeed, when Player1 makes its first REST call, the script doesn’t block."
" The fiber running ``catch()`` function on behalf of Player1 issues a "
"non-blocking call to the operating system and yields control to the next "
"fiber, which happens to be the fiber of Player2. Player2’s fiber does the"
" same. When the network response is received, Player1's fiber is "
"activated by Tarantool cooperative scheduler, and resumes its work. All "
"Tarantool :ref:`modules <built_in_modules>` use non-blocking I/O and are "
"integrated with Tarantool cooperative scheduler. For module developers, "
"Tarantool provides an :ref:`API <index-c_api_reference>`."
msgstr ""
"Действительно, когда Player1 посылает первый REST-вызов, скрипт не "
"блокируется. Файбер, выполняющий функцию ``catch()`` от Player1, посылает"
" неблокирующий вызов в операционную систему и передает управление на "
"следующий файбер, которым оказывается файбер от Player2. Файбер от "
"Player2 делает то же самое. Когда получен сетевой ответ, файбер от "
"Player1 активируется  с помощью кооперативного планировщика Tarantool'а и"
" возобновляет работу. Все :ref:`модули <built_in_modules>` Tarantool'а "
"используют неблокирующий ввод-вывод и интегрированы с кооперативным "
"планировщиком Tarantool'а. Разработчикам модулей Tarantool предоставляет "
":ref:`API <index-c_api_reference>`."

msgid ""
"For our HTTP test, we create a third container based on the `official "
"Tarantool 1.9 image <https://github.com/tarantool/docker>`_ (see "
"`client/Dockerfile "
"<https://github.com/tarantool/pokemon/blob/1.9/client/Dockerfile>`_) and "
"set the container's default command to ``tarantool client.lua``."
msgstr ""
"Для HTTP-теста создадим третий контейнер на основе `официального образа "
"Tarantool'а 1.9 <https://github.com/tarantool/docker>`_ (см. "
"`client/Dockerfile "
"<https://github.com/tarantool/pokemon/blob/1.9/client/Dockerfile>`_)  "
"установим ``tarantool client.lua`` в качестве стандартной команды для "
"контейнера."

msgid ""
"To run this test locally, download our `pokemon "
"<https://github.com/tarantool/pokemon>`_ project from GitHub and say:"
msgstr ""
"Чтобы запустить тест локально, скачайте наш проект `покемон "
"<https://github.com/tarantool/pokemon>`_ из GitHub и вызовите:"

msgid ""
"$ docker-compose build\n"
"$ docker-compose up"
msgstr ""
"$ docker-compose build\n"
"$ docker-compose up"

msgid ""
"Docker Compose builds and runs all the three containers: ``pserver`` "
"(Tarantool backend), ``phttp`` (nginx) and ``pclient`` (demo client). You"
" can see log messages from all these containers in the console, pclient "
"saying that it made an HTTP request to create a pokémon, made two catch "
"requests, requested the map (empty since the pokémon is caught and "
"temporarily inactive) and exited:"
msgstr ""
"Docker Compose собирает и запускает все три контейнера: ``pserver`` "
"(бэкенд Tarantool'а), ``phttp`` (nginx) и``pclient`` (демо-клиент). ВЫ "
"можете увидеть все сообщения журнала из всех этих контейнеров в консоли. "
"pclient выведет, что сделал HTTP-запрос на создание покемона, два запроса"
" на поимку покемона, запросил карту (пустая, поскольку покемон пойман и "
"временно неактивен) и завершил работу:"

msgid ""
"pclient_1  | Create pokemon\n"
"<...>\n"
"pclient_1  | {\"result\":true}\n"
"pclient_1  | "
"{\"map\":[{\"id\":1,\"status\":\"active\",\"location\":{\"y\":2,\"x\":1},\"name\":\"Pikachu\",\"chance\":99.100000}]}"
"\n"
"pclient_1  | Catch pokemon by player 2\n"
"pclient_1  | Catch pokemon by player 1\n"
"pclient_1  | Player 1 result: {\"result\":true}\n"
"pclient_1  | Player 2 result: {\"result\":false}\n"
"pclient_1  | {\"map\":[]}\n"
"pokemon_pclient_1 exited with code 0"
msgstr ""
"pclient_1  | Create pokemon\n"
"<...>\n"
"pclient_1  | {\"result\":true}\n"
"pclient_1  | "
"{\"map\":[{\"id\":1,\"status\":\"active\",\"location\":{\"y\":2,\"x\":1},\"name\":\"Pikachu\",\"chance\":99.100000}]}"
"\n"
"pclient_1  | Catch pokemon by player 2\n"
"pclient_1  | Catch pokemon by player 1\n"
"pclient_1  | Player 1 result: {\"result\":true}\n"
"pclient_1  | Player 2 result: {\"result\":false}\n"
"pclient_1  | {\"map\":[]}\n"
"pokemon_pclient_1 exited with code 0"

msgid ""
"Congratulations! Here's the end point of our walk-through. As further "
"reading, see more about :ref:`installing <app_server-installing_module>` "
"and :ref:`contributing <app_server-contributing_module>` a module."
msgstr ""
"Поздравляем! Вот мы и закончили наш пошаговый пример. Для дальнейшего "
"изучения рекомендуем :ref:`установку <app_server-installing_module>` и "
":ref:`добавление <app_server-contributing_module>` модуля."

msgid ""
"See also reference on :ref:`Tarantool modules <built_in_modules>` and "
":ref:`C API <index-c_api_reference>`, and don't miss our :ref:`Lua "
"cookbook recipes <cookbook>`."
msgstr ""
"См. также справочник по :ref:`модулям Tarantool'а <built_in_modules>` и "
":ref:`C API <index-c_api_reference>` и не пропустите наши "
":ref:`рекомендации по разработке на Lua <cookbook>`."
