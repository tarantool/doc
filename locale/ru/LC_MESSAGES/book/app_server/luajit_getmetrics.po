
msgid "LuaJIT getmetrics"
msgstr "LuaJIT getmetrics"

msgid ""
"Tarantool can return metrics of a current instance via the Lua API or the C "
"API."
msgstr ""
"Tarantool может возвращать метрики текущего экземпляра через Lua API или C "
"API."

msgid "misc.getmetrics()"
msgstr "misc.getmetrics()"

msgid "Get the metrics values into a table."
msgstr "Получение значений метрик в таблицу."

msgid "Parameters: none"
msgstr "Параметры: нет"

msgid "return"
msgstr "возвращает"

msgid "table"
msgstr "таблицу"

msgid "Example: ``metrics_table = misc.getmetrics()``"
msgstr "Пример: ``metrics_table = misc.getmetrics()``"

msgid "getmetrics table values"
msgstr "значения в таблице getmetrics"

msgid ""
"The metrics table contains 19 values. All values have type = 'number' and "
"are the result of a cast to double, so there may be a very slight precision "
"loss. Values whose names begin with ``gc_`` are associated with the `LuaJIT "
"garbage collector <http://wiki.luajit.org/New-Garbage-Collector/>`_; a "
"fuller study of the garbage collector can be found at `a Lua-users wiki page"
" <http://lua-users.org/wiki/EmergencyGarbageCollector>`_ and `a slide from "
"the creator of Lua "
"<https://www.lua.org/wshop18/Ierusalimschy.pdf#page=16>`_. Values whose "
"names begin with ``jit_`` are associated with the `\"phases\" "
"<https://en.wikipedia.org/wiki/Tracing_just-in-time_compilation>`_ of the "
"just-in-time compilation process; a fuller study of JIT phases can be found "
"at `A masters thesis from cern.ch "
"<http://cds.cern.ch/record/2692915/files/CERN-"
"THESIS-2019-152.pdf?version=1>`_."
msgstr ""
"Таблица метрик содержит 19 значений. Все значения принадлежат типу 'number' "
"и получаются в результате приведения к вещественному типу двойной точности "
"(double), что хорошо сохраняет точность исходных значений. Значения с "
"именами, начинающимися на ``gc_``, относятся к `сборщику мусора в LuaJIT "
"<http://wiki.luajit.org/New-Garbage-Collector/>`_. Полную информацию о "
"сборщике мусора можно найти на `вики-странице Lua-users <http://lua-"
"users.org/wiki/EmergencyGarbageCollector>`_ и `слайде от создателя языка Lua"
" <https://www.lua.org/wshop18/Ierusalimschy.pdf#page=16>`_. Значения с "
"именами, начинающимися на ``jit_``, связаны с `\"фазами\" "
"<https://en.wikipedia.org/wiki/Tracing_just-in-time_compilation>`_ процесса "
"компиляции \"just-in-time\". Более подробно он описан в `магистерской "
"диссертации из cern.ch <http://cds.cern.ch/record/2692915/files/CERN-"
"THESIS-2019-152.pdf?version=1>`_."

msgid ""
"Values described as \"monotonic\" are cumulative, that is, they are \"totals"
" since all operations began\", rather than \"since the last getmetrics() "
"call\". Overflow is possible."
msgstr ""
"Значения, описанные как \"monotonic\" (\"монотонные\"), кумулятивны, то есть"
" они содержат \"итоги с момента начала всех операций\", а не \"с момента "
"последнего вызова getmetrics()\". Может возникнуть переполнение."

msgid ""
"Because many values are monotonic, a typical analysis involves calling "
"``getmetrics()``, saving the table, calling ``getmetrics()`` again and "
"comparing the table to what was saved. The difference is a \"slope curve\". "
"An interesting slope curve is one that shows acceleration, for example the "
"difference between the latest value and the previous value keeps increasing."
" Some of the table members shown here are used in the examples that come "
"later in this section."
msgstr ""
"Поскольку многие значения монотонны, типичный анализ включает вызов "
"``getmetrics()``, сохранение таблицы, повторный вызов ``getmetrics()`` и "
"сравнение таблицы с тем, что было сохранено. Разницу называют \"кривой "
"наклона\". Примером такой кривой, представляющей интерес, может быть та, что"
" показывает ускорение: разница между последним и предыдущим значениями все "
"время увеличивается. Некоторые из элементов таблицы, показанных здесь, "
"используются в примерах, приведенных далее в этом разделе."

msgid "Name"
msgstr "Имя"

msgid "Content"
msgstr "Содержимое"

msgid "Monotonic?"
msgstr "Монотонно?"

msgid "gc_allocated"
msgstr "gc_allocated"

msgid "number of bytes of allocated memory"
msgstr "количество выделенной памяти в байтах"

msgid "yes"
msgstr "да"

msgid "gc_cdatanum"
msgstr "gc_cdatanum"

msgid "number of allocated cdata objects"
msgstr "количество размещенных объектов cdata"

msgid "gc_freed"
msgstr "gc_freed"

msgid "number of bytes of freed memory"
msgstr "количество освобожденной памяти в байтах"

msgid "gc_steps_atomic"
msgstr "gc_steps_atomic"

msgid "number of steps of garbage collector, atomic phases, incremental"
msgstr ""
"количество шагов сборщика мусора, атомарные фазы, в инкрементальном виде"

msgid "gc_steps_finalize"
msgstr "gc_steps_finalize"

msgid "number of steps of garbage collector, finalize"
msgstr "количество шагов сборщика мусора, фаза finalize"

msgid "gc_steps_pause"
msgstr "gc_steps_pause"

msgid "number of steps of garbage collector, pauses"
msgstr "количество шагов сборщика мусора, фаза pauses"

msgid "gc_steps_propagate"
msgstr "gc_steps_propagate"

msgid "number of steps of garbage collector, propagate"
msgstr "количество шагов сборщика мусора, фаза propagate"

msgid "gc_steps_sweep"
msgstr "gc_steps_sweep"

msgid ""
"number of steps of garbage collector, sweep phases See external `Sweep Phase"
" Description`_"
msgstr ""
"количество шагов сборщика мусора, фазы sweep. См. внешнее `описание фазы "
"sweep`_"

msgid "gc_steps_sweepstring"
msgstr "gc_steps_sweepstring"

msgid "number of steps of garbage collector, sweep phases for strings"
msgstr "количество шагов сборщика мусора, фазы sweep для строк"

msgid "gc_strnum"
msgstr "gc_strnum"

msgid "number of allocated string objects"
msgstr "количество размещенных объектов-строк"

msgid "gc_tabnum"
msgstr "gc_tabnum"

msgid "number of allocated table objects"
msgstr "количество размещенных объектов-таблиц"

msgid "gc_total"
msgstr "gc_total"

msgid ""
"number of bytes of currently allocated memory (normally equals gc_allocated "
"minus gc_freed)"
msgstr ""
"текущее количество выделенной памяти в байтах of bytes of currently "
"allocated memory (обычно равно разности gc_allocated и gc_freed)"

msgid "gc_udatanum"
msgstr "gc_udatanum"

msgid "number of allocated udata objects"
msgstr "количество размещенных объектов udata"

msgid "jit_mcode_size"
msgstr "jit_mcode_size"

msgid "total size of all allocated machine code areas"
msgstr "общий размер всех размещенных областей машинного кода"

msgid "jit_snap_restore"
msgstr "jit_snap_restore"

msgid ""
"Overall number of snap restores (amount of guard assertions leading to "
"stopping trace executions) See external `Snap tutorial`_"
msgstr ""
"Общее количество snap restores (количество защитных утверждений, приводящих "
"к остановке исполнения трассировок). См внешнее `руководство по snap`_"

msgid "jit_trace_abort"
msgstr "jit_trace_abort"

msgid "overall number of aborted traces"
msgstr "общее количество прерванных трассировок"

msgid "jit_trace_num"
msgstr "jit_trace_num"

msgid "number of JIT traces"
msgstr "количество JIT-трассировок"

msgid "strhash_hit"
msgstr "strhash_hit"

msgid ""
"number of strings being interned because, if a string with the same value is"
" found via the hash, a new one is not created / allocated"
msgstr ""
"размер пула строк, если такая же строка уже в нём есть, новая копия не "
"создается и память под нее не выделяется"

msgid "strhash_miss"
msgstr "strhash_miss"

msgid "total number of strings allocations during the platform lifetime"
msgstr "общее количество выделения памяти для строк за время жизни платформы"

msgid ""
"Note: Although value names are similar to value names in `ujit.getmetrics() "
"<https://ujit.readthedocs.io/en/latest/public/ujit-024.html#ujit-"
"getmetrics>`_ the values are not the same, primarily because many ujit "
"numbers are not monotonic."
msgstr ""
"Замечание: хотя имена значений похожи на те, что встречались в "
"`ujit.getmetrics() "
"<https://ujit.readthedocs.io/en/latest/public/ujit-024.html#ujit-"
"getmetrics>`_, это другие значения, в основном потому, что многие ujit-числа"
" не монотонны."

msgid ""
"Note: Although value names are similar to value names in :ref:`LuaJIT "
"metrics <metrics-luajit>`, and the values are exactly the same, "
"misc.getmetrics() is slightly easier because there is no need to ‘require’ "
"the misc module."
msgstr ""
"Замечание: хотя имена значений похожи на те, что встречались в :ref:`LuaJIT "
"metrics <metrics-luajit>`, и значения те же самые, функция misc.getmetrics()"
" немного проще, так не требуется выполнять операцию ‘require’ для модуля "
"misc."

msgid "getmetrics C API"
msgstr "C API для getmetrics"

msgid ""
"The Lua ``getmetrics()`` function is a wrapper for the C function "
"``luaM_metrics()``. |br|"
msgstr ""
"Lua-функция ``getmetrics()`` --- обертка для C-функции ``luaM_metrics()``. "
"|br|"

msgid ""
"C programs may include a header named libmisclib.h. |br| The definitions in "
"libmisclib.h include |br| ``struct luam_Metrics { ... the same names as are "
"described earlier for Lua ... }`` |br| ``LUAMISC_API void "
"luaM_metrics(lua_State *L, struct luam_Metrics *metrics);`` |br| The names "
"of ``struct luam_Metrics`` members are the same as Lua's :ref:`getmetrics "
"table values <luajit_getmetrics_tablevalues>` names. |br| The data types of "
"``struct luam_Metrics`` members are all ``size_t``. |br| The "
"``luaM_metrics()`` function will fill the ``*metrics`` structure with the "
"metrics related to the Lua state anchored to the ``L`` coroutine."
msgstr ""
"Программы на C могут включать заголовок с именем libmisclib.h. |br| "
"Определения в libmisclib.h включают |br| ``struct luam_Metrics { ... те же "
"имена, описанные ранее для Lua ... }`` |br| ``LUAMISC_API void "
"luaM_metrics(lua_State *L, struct luam_Metrics *metrics);`` |br| Имена "
"членов структуры ``struct luam_Metrics`` совпадают с Lua-именами в "
":ref:`таблице значений для getmetrics <luajit_getmetrics_tablevalues>`. |br|"
" У всех членов структуры ``struct luam_Metrics`` тип данных --- ``size_t``. "
"|br| Функция ``luaM_metrics()`` заполнит структуру ``*metrics`` метриками, "
"относящимися к Lua-состоянию, привязанному к корутине ``L``."

msgid "**Example with a C program**"
msgstr "**Пример с программой на языке C**"

msgid ""
"Go through the :ref:`C stored procedures <f_c_tutorial-c_stored_procedures>`"
" tutorial. Replace the easy.c example with"
msgstr ""
"Просмотрите руководство по :ref:`хранимым процедурам на языке C "
"<f_c_tutorial-c_stored_procedures>`. Вместо файла easy.c используйте "
"следующий код:"

msgid ""
"#include \"module.h\"\n"
"#include <lmisclib.h>\n"
"\n"
"int easy(box_function_ctx_t *ctx, const char *args, const char *args_end)\n"
"{\n"
"  lua_State *ls = luaT_state();\n"
"  struct luam_Metrics m;\n"
"  luaM_metrics(ls, &m);\n"
"  printf(\"allocated memory = %lu\\n\", m.gc_allocated);\n"
"  return 0;\n"
"}"
msgstr ""
"#include \"module.h\"\n"
"#include <lmisclib.h>\n"
"\n"
"int easy(box_function_ctx_t *ctx, const char *args, const char *args_end)\n"
"{\n"
"  lua_State *ls = luaT_state();\n"
"  struct luam_Metrics m;\n"
"  luaM_metrics(ls, &m);\n"
"  printf(\"allocated memory = %lu\\n\", m.gc_allocated);\n"
"  return 0;\n"
"}"

msgid ""
"Now when you go back to the client and execute the requests up to and "
"including |br| ``capi_connection:call('easy')`` |br| you will see that the "
"display is something like |br| allocated memory = 4431950 |br| although the "
"number will vary."
msgstr ""
"Теперь, когда вы вернетесь к клиенту и выполните запросы до |br| "
"``capi_connection:call('easy')`` |br| включительно, вы увидите, что "
"отображается что-то вроде |br| allocated memory = 4431950 |br| (число может "
"быть другим)."

msgid "Example with gc_strnum and strhash_miss and strhash_hit"
msgstr "Пример с gc_strnum, strhash_miss и strhash_hit"

msgid "To track new string object allocations:"
msgstr "Чтобы отслеживать размещение новых строковых объектов:"

msgid ""
"function f()\n"
"  collectgarbage(\"collect\")\n"
"  local oldm = misc.getmetrics()\n"
"  local table_of_strings = {}\n"
"  for i = 3000, 4000 do table.insert(table_of_strings, tostring(i)) end\n"
"  for i = 3900, 4100 do table.insert(table_of_strings, tostring(i)) end\n"
"  local newm = misc.getmetrics()\n"
"  print(\"gc_strnum diff = \" .. newm.gc_strnum - oldm.gc_strnum)\n"
"  print(\"strhash_miss diff = \" .. newm.strhash_miss - oldm.strhash_miss)\n"
"  print(\"strhash_hit diff = \" .. newm.strhash_hit - oldm.strhash_hit)\n"
"end\n"
"f()"
msgstr ""
"function f()\n"
"  collectgarbage(\"collect\")\n"
"  local oldm = misc.getmetrics()\n"
"  local table_of_strings = {}\n"
"  for i = 3000, 4000 do table.insert(table_of_strings, tostring(i)) end\n"
"  for i = 3900, 4100 do table.insert(table_of_strings, tostring(i)) end\n"
"  local newm = misc.getmetrics()\n"
"  print(\"gc_strnum diff = \" .. newm.gc_strnum - oldm.gc_strnum)\n"
"  print(\"strhash_miss diff = \" .. newm.strhash_miss - oldm.strhash_miss)\n"
"  print(\"strhash_hit diff = \" .. newm.strhash_hit - oldm.strhash_hit)\n"
"end\n"
"f()"

msgid ""
"The result will probably be:. |br| gc_strnum diff = 1100 because we added "
"1202 strings but 100 were duplicates. |br| strhash_miss = 1100 for the same "
"reason. |br| strhash_hit = 100 plus some overhead, for the same reason. |br|"
" (There is always a slight overhead amount for ``strhash_hit``, which can be"
" ignored.) We say \"probably\" because there is a chance that the strings "
"were already allocated somewhere. It is a good thing if the slope curve of "
"``strhash_miss`` is less than the slope curve of ``strhash_hit``."
msgstr ""
"Результат, вероятно, будет следующим: |br| gc_strnum diff = 1100, так как мы"
" добавили 1202 строки, но 100 были дубликатами. |br| strhash_miss = 1100 по "
"той же причине. |br| strhash_hit = 100 плюс некоторые накладные расходы по "
"той же причине. |br| (Для ``strhash_hit`` всегда есть небольшие накладные "
"расходы, которые можно игнорировать.) Мы говорим \"вероятно\", потому что "
"есть вероятность, что строки уже были где-то распределены. Хорошо, если "
"кривая наклона для ``strhash_miss`` меньше, чем для ``strhash_hit``."

msgid ""
"The other gc_*num values -- ``gc_cdatanum``, ``gc_tabnum``, ``gc_udatanum`` "
"-- can be accessed in a similar way. Any of the gc_*num values can be useful"
" when looking for memory leaks – the total number of these objects should "
"not grow nonstop. A more general way to look for memory leaks is to watch "
"``gc_total``. Also ``jit_mcode_size`` can be used to watch the amount of "
"allocated memory for machine code traces."
msgstr ""
"Остальные значения gc_*num --- ``gc_cdatanum``, ``gc_tabnum`` и "
"``gc_udatanum`` --- доступны аналогичным образом. Любое из значений gc_*num "
"может быть полезно при поиске утечки памяти: общее количество этих объектов "
"не должно постоянно расти. Более общий способ поиска утечек памяти --- "
"наблюдение за ``gc_total``. Также можно отслеживать объем памяти, выделенной"
" для трассировок машинных кодов, с помощью значения ``jit_mcode_size``."

msgid "Example with gc_allocated and gc_freed"
msgstr "Пример с gc_allocated и gc_freed"

msgid ""
"To track an application's effect on the garbage collector (less is better):"
msgstr ""
"Чтобы отслеживать влияние приложения на сборщик мусора (чем меньше значение,"
" тем лучше):"

msgid ""
"function f()\n"
"  for i = 1, 10 do collectgarbage(\"collect\") end\n"
"  local oldm = misc.getmetrics()\n"
"  local newm = misc.getmetrics()\n"
"  oldm = misc.getmetrics()\n"
"  collectgarbage(\"collect\")\n"
"  newm = misc.getmetrics()\n"
"  print(\"gc_allocated diff = \" .. newm.gc_allocated - oldm.gc_allocated)\n"
"  print(\"gc_freed diff = \" .. newm.gc_freed - oldm.gc_freed)\n"
"end\n"
"f()"
msgstr ""
"function f()\n"
"  for i = 1, 10 do collectgarbage(\"collect\") end\n"
"  local oldm = misc.getmetrics()\n"
"  local newm = misc.getmetrics()\n"
"  oldm = misc.getmetrics()\n"
"  collectgarbage(\"collect\")\n"
"  newm = misc.getmetrics()\n"
"  print(\"gc_allocated diff = \" .. newm.gc_allocated - oldm.gc_allocated)\n"
"  print(\"gc_freed diff = \" .. newm.gc_freed - oldm.gc_freed)\n"
"end\n"
"f()"

msgid ""
"The result will be: gc_allocated diff = 800, gc_freed diff = 800. This shows"
" that ``local ... = getmetrics()`` itself causes memory allocation (because "
"it is creating a table and assigning to it), and shows that when the name of"
" a variable (in this case the ``oldm`` variable) is used again, that causes "
"freeing. Ordinarily the freeing would not occur immediately, but "
"``collectgarbage(\"collect\")`` forces it to happen so we can see the "
"effect."
msgstr ""
"Результатом будет: gc_allocated diff = 800, gc_freed diff = 800. Это "
"показывает, что ``local ... = getmetrics()`` само по себе вызывает выделение"
" памяти (так как создает таблицу и присваивает ей значения), и что что когда"
" имя переменной (в данном случае переменной ``oldm``) снова используется, "
"происходит освобождение памяти. Обычно оно происходит не сразу, но, чтобы "
"можно было увидеть описываемый эффект, вызов ``collectgarbage(\"collect\")``"
" принудительно запускает сборку мусора."

msgid "Example with gc_allocated and a space optimization"
msgstr "Пример с gc_allocated и оптимизацией по памяти"

msgid "To test whether optimizing for space is possible with tables:"
msgstr "Чтобы проверить, можно ли оптимизировать таблицы по размеру:"

msgid ""
"function f()\n"
"  collectgarbage(\"collect\")\n"
"  local oldm = misc.getmetrics()\n"
"  local t = {}\n"
"  for i = 1, 513 do\n"
"    t[i] = i\n"
"  end\n"
"  local newm = misc.getmetrics()\n"
"  local diff = newm.gc_allocated - oldm.gc_allocated\n"
"  print(\"diff = \" .. diff)\n"
"end\n"
"f()"
msgstr ""
"function f()\n"
"  collectgarbage(\"collect\")\n"
"  local oldm = misc.getmetrics()\n"
"  local t = {}\n"
"  for i = 1, 513 do\n"
"    t[i] = i\n"
"  end\n"
"  local newm = misc.getmetrics()\n"
"  local diff = newm.gc_allocated - oldm.gc_allocated\n"
"  print(\"diff = \" .. diff)\n"
"end\n"
"f()"

msgid "The result will show that diff equals approximately 18000."
msgstr "Результат покажет, что diff равен примерно 18000."

msgid "Now see what happens if the table initialization is different:"
msgstr "Если таблица будет инициализирована по-другому, получится вот что:"

msgid ""
"function f()\n"
"  local table_new = require \"table.new\"\n"
"  local oldm = misc.getmetrics()\n"
"  local t = table_new(513, 0)\n"
"  for i = 1, 513 do\n"
"    t[i] = i\n"
"  end\n"
"  local newm = misc.getmetrics()\n"
"  local diff = newm.gc_allocated - oldm.gc_allocated\n"
"  print(\"diff = \" .. diff)\n"
"end\n"
"f()"
msgstr ""
"function f()\n"
"  local table_new = require \"table.new\"\n"
"  local oldm = misc.getmetrics()\n"
"  local t = table_new(513, 0)\n"
"  for i = 1, 513 do\n"
"    t[i] = i\n"
"  end\n"
"  local newm = misc.getmetrics()\n"
"  local diff = newm.gc_allocated - oldm.gc_allocated\n"
"  print(\"diff = \" .. diff)\n"
"end\n"
"f()"

msgid "The result will show that diff equals approximately 6000."
msgstr "Результат покажет, что diff равен примерно 6000."

msgid "gc_steps_atomic and gc_steps_propagate"
msgstr "gc_steps_atomic и gc_steps_propagate"

msgid ""
"The slope curves of gc_steps_* items can be used for tracking pressure on "
"the garbage collector too. During long-running routines, gc_steps_* values "
"will increase, but long times between ``gc_steps_atomic`` increases are a "
"good sign, And, since ``gc_steps_atomic`` increases only once per garbage-"
"collector cycle, it shows how many garbage-collector cycles have occurred."
msgstr ""
"Кривые наклона элементов gc_steps_* также можно использовать для "
"отслеживания нагрузки на сборщик мусора. Во время долго выполняющихся "
"процедур значения gc_steps_* увеличиваются, но большие промежутки времени "
"между увеличениями ``gc_steps_atomic`` --- хороший признак, и можно увидеть,"
" сколько циклов сбора мусора произошло, так как ``gc_steps_atomic`` "
"увеличивается только однажды за цикл сбора мусора,."

msgid ""
"Also, increases in the ``gc_steps_propagate`` number can be used to estimate"
" indirectly how many objects there are. These values also correlate with the"
" garbage collector's `step multiplier "
"<https://www.lua.org/manual/5.4/manual.html#2.5.1>`_. The number of "
"incremental steps can grow, but one step can process a small number of "
"objects. So these metrics should be considered when configuring the garbage "
"collector."
msgstr ""
"Кроме того, увеличение числа ``gc_steps_propagate`` можно использовать для "
"косвенной оценки количества объектов. Эти значения также коррелируют с "
"множителем шага сборщика мусора "
"<https://www.lua.org/manual/5.4/manual.html#2.5.1>`_. Количество "
"инкрементальных шагов может увеличиваться, но за один шаг можно обработать "
"небольшое количество объектов. Поэтому эти показатели следует учитывать при "
"настройке сборщика мусора."

msgid ""
"The following function takes a casual look whether an SQL statement causes "
"much pressure:"
msgstr ""
"Следующая функция оценивает, вызывает ли оператор SQL большую нагрузку:"

msgid ""
"function f()\n"
"  collectgarbage(\"collect\")\n"
"  local oldm = misc.getmetrics()\n"
"  collectgarbage(\"collect\")\n"
"  box.execute([[DROP TABLE _vindex;]])\n"
"  local newm = misc.getmetrics()\n"
"  print(\"gc_steps_atomic = \" .. newm.gc_steps_atomic - oldm.gc_steps_atomic)\n"
"  print(\"gc_steps_finalize = \" .. newm.gc_steps_finalize - oldm.gc_steps_finalize)\n"
"  print(\"gc_steps_pause = \" .. newm.gc_steps_pause - oldm.gc_steps_pause)\n"
"  print(\"gc_steps_propagate = \" .. newm.gc_steps_propagate - oldm.gc_steps_propagate)\n"
"  print(\"gc_steps_sweep = \" .. newm.gc_steps_sweep - oldm.gc_steps_sweep)\n"
"end\n"
"f()"
msgstr ""
"function f()\n"
"  collectgarbage(\"collect\")\n"
"  local oldm = misc.getmetrics()\n"
"  collectgarbage(\"collect\")\n"
"  box.execute([[DROP TABLE _vindex;]])\n"
"  local newm = misc.getmetrics()\n"
"  print(\"gc_steps_atomic = \" .. newm.gc_steps_atomic - oldm.gc_steps_atomic)\n"
"  print(\"gc_steps_finalize = \" .. newm.gc_steps_finalize - oldm.gc_steps_finalize)\n"
"  print(\"gc_steps_pause = \" .. newm.gc_steps_pause - oldm.gc_steps_pause)\n"
"  print(\"gc_steps_propagate = \" .. newm.gc_steps_propagate - oldm.gc_steps_propagate)\n"
"  print(\"gc_steps_sweep = \" .. newm.gc_steps_sweep - oldm.gc_steps_sweep)\n"
"end\n"
"f()"

msgid ""
"And the display will show that the gc_steps_* metrics are not significantly "
"different from what they would be if the ``box.execute()`` was absent."
msgstr ""
"В результате будет видно, что метрики gc_steps_ * существенно не отличаются "
"от тех, что были бы без``box.execute()``."

msgid "Example with jit_trace_num and jit_trace_abort"
msgstr "Пример с jit_trace_num и jit_trace_abort"

msgid ""
"Just-in-time compilers will \"trace\" code looking for opportunities to "
"compile. ``jit_trace_abort`` can show how often there was a failed attempt "
"(less is better), and ``jit_trace_num`` can show how many traces were "
"generated since the last flush (usually more is better)."
msgstr ""
"JIT-компиляторы будут \"трассировать\" код, пытаясь найти возможность для "
"компиляции, повышающей производительность. Значение ``jit_trace_abort`` "
"может показать, как часто попытки были неудачными (чем меньше, тем лучше), а"
" ``jit_trace_num`` --- как много трассировок было сгенерировано с момента "
"последнего выполнения операции flush (обычно чем больше, тем лучше)."

msgid ""
"The following function does not contain code that can cause trouble for "
"LuaJIT:"
msgstr ""
"В следующей функции нет кода, который мог бы вызвать проблемы с LuaJIT:"

msgid ""
"function f()\n"
"  jit.flush()\n"
"  for i = 1, 10 do collectgarbage(\"collect\") end\n"
"  local oldm = misc.getmetrics()\n"
"  collectgarbage(\"collect\")\n"
"  local sum = 0\n"
"  for i = 1, 57 do\n"
"    sum = sum + 57\n"
"  end\n"
"  for i = 1, 10 do collectgarbage(\"collect\") end\n"
"  local newm = misc.getmetrics()\n"
"  print(\"trace_num = \" .. newm.jit_trace_num - oldm.jit_trace_num)\n"
"  print(\"trace_abort = \" .. newm.jit_trace_abort - oldm.jit_trace_abort)\n"
"end\n"
"f()"
msgstr ""
"function f()\n"
"  jit.flush()\n"
"  for i = 1, 10 do collectgarbage(\"collect\") end\n"
"  local oldm = misc.getmetrics()\n"
"  collectgarbage(\"collect\")\n"
"  local sum = 0\n"
"  for i = 1, 57 do\n"
"    sum = sum + 57\n"
"  end\n"
"  for i = 1, 10 do collectgarbage(\"collect\") end\n"
"  local newm = misc.getmetrics()\n"
"  print(\"trace_num = \" .. newm.jit_trace_num - oldm.jit_trace_num)\n"
"  print(\"trace_abort = \" .. newm.jit_trace_abort - oldm.jit_trace_abort)\n"
"end\n"
"f()"

msgid "The result is: trace_num = 1, trace_abort = 0. Fine."
msgstr "Результат: trace_num = 1, trace_abort = 0. Отлично."

msgid ""
"The following function seemingly does contain code that can cause trouble "
"for LuaJIT:"
msgstr ""
"Похоже, в следующей функции есть код, способный вызвать проблемы с LuaJIT:"

msgid ""
"jit.opt.start(0, \"hotloop=2\", \"hotexit=2\", \"minstitch=15\")\n"
"_G.globalthing = 5\n"
"function f()\n"
"  jit.flush()\n"
"  collectgarbage(\"collect\")\n"
"  local oldm = misc.getmetrics()\n"
"  collectgarbage(\"collect\")\n"
"  local sum = 0\n"
"  for i = 1, box.space._vindex:count()+ _G.globalthing do\n"
"    box.execute([[SELECT RANDOMBLOB(0);]])\n"
"    require('buffer').ibuf()\n"
"    _G.globalthing = _G.globalthing - 1\n"
"  end\n"
"  local newm = misc.getmetrics()\n"
"  print(\"trace_num = \" .. newm.jit_trace_num - oldm.jit_trace_num)\n"
"  print(\"trace_abort = \" .. newm.jit_trace_abort - oldm.jit_trace_abort)\n"
"end\n"
"f()"
msgstr ""
"jit.opt.start(0, \"hotloop=2\", \"hotexit=2\", \"minstitch=15\")\n"
"_G.globalthing = 5\n"
"function f()\n"
"  jit.flush()\n"
"  collectgarbage(\"collect\")\n"
"  local oldm = misc.getmetrics()\n"
"  collectgarbage(\"collect\")\n"
"  local sum = 0\n"
"  for i = 1, box.space._vindex:count()+ _G.globalthing do\n"
"    box.execute([[SELECT RANDOMBLOB(0);]])\n"
"    require('buffer').ibuf()\n"
"    _G.globalthing = _G.globalthing - 1\n"
"  end\n"
"  local newm = misc.getmetrics()\n"
"  print(\"trace_num = \" .. newm.jit_trace_num - oldm.jit_trace_num)\n"
"  print(\"trace_abort = \" .. newm.jit_trace_abort - oldm.jit_trace_abort)\n"
"end\n"
"f()"

msgid ""
"The result is: trace_num = between 2 and 4, trace_abort = 1. This means that"
" up to four traces needed to be generated instead of one, and this means "
"that something made LuaJIT give up in despair. Tracing more will reveal that"
" the problem is not the suspicious-looking statements within the function, "
"it is the ``jit.opt.start`` call. (A look at a jit.dump file might help in "
"examining the trace compilation process.)"
msgstr ""
"Результат: trace_num --- от 2 до 4, trace_abort = 1. Это означает, что нужно"
" было сгенерировать до четырех трассировок вместо одной, и это означает, что"
" что-то заставило LuaJIT в отчаянии сдаться. Дальнейшая трассировка "
"показывает, что проблема была не в подозрительно выглядящих операторах "
"внутри функции, а в вызове ``jit.opt.start``. (Содержимое файла jit.dump "
"может помочь в изучении процесса компиляции трассировки.)"

msgid "Example with jit_snap_restore and a performance unoptimization"
msgstr ""
"Пример с jit_snap_restore и отключением оптимизации производительности"

msgid ""
"If the slope curves of the ``jit_snap_restore`` metric grow after changes to"
" old code, that can mean LuaJIT is stopping trace execution more frequently,"
" and that can mean performance is degraded."
msgstr ""
"Если кривые наклона метрики ``jit_snap_restore`` растут после изменений в "
"старом коде, это может означать, что LuaJIT чаще останавливает выполнение "
"трассировки, что может указывать, что производительность снижается."

msgid "Start with this code:"
msgstr "Начнем со следующего кода:"

msgid ""
"function f()\n"
"  local function foo(i)\n"
"    return i <= 5 and i or tostring(i)\n"
"  end\n"
"  -- minstitch option needs to emulate nonstitching behaviour\n"
"  jit.opt.start(0, \"hotloop=2\", \"hotexit=2\", \"minstitch=15\")\n"
"  local sum = 0\n"
"  local oldm = misc.getmetrics()\n"
"  for i = 1, 10 do\n"
"    sum = sum + foo(i)\n"
"  end\n"
"  local newm = misc.getmetrics()\n"
"  local diff = newm.jit_snap_restore - oldm.jit_snap_restore\n"
"  print(\"diff = \" .. diff)\n"
"end\n"
"f()"
msgstr ""
"function f()\n"
"  local function foo(i)\n"
"    return i <= 5 and i or tostring(i)\n"
"  end\n"
"  -- параметр minstitch нужен, чтобы эмулировать nonstitching поведение\n"
"  jit.opt.start(0, \"hotloop=2\", \"hotexit=2\", \"minstitch=15\")\n"
"  local sum = 0\n"
"  local oldm = misc.getmetrics()\n"
"  for i = 1, 10 do\n"
"    sum = sum + foo(i)\n"
"  end\n"
"  local newm = misc.getmetrics()\n"
"  local diff = newm.jit_snap_restore - oldm.jit_snap_restore\n"
"  print(\"diff = \" .. diff)\n"
"end\n"
"f()"

msgid ""
"The result will be: diff = 3, because there is one side exit when the loop "
"ends, and there are two side exits to the interpreter before LuaJIT may "
"decide that the chunk of code is \"hot\" (the default value of the hotloop "
"parameter is 56 according to `Running LuaJIT  "
"<https://luajit.org/running.html#opt_O>`_)."
msgstr ""
"Результатом: diff = 3, потому что есть один сторонний выход, когда цикл "
"заканчивается, и есть сторонних выхода для интерпретатора, прежде чем LuaJIT"
" может решить, что фрагмент кода \"горячий\" (значение по умолчанию "
"параметра hotloop равно 56 в соответствии с `документацией по запуску LuaJIT"
"  <https://luajit.org/running.html#opt_O>`_)."

msgid ""
"And now change only one line within function ``local foo``, so now the code "
"is:"
msgstr ""
"А теперь изменим единственную строку в функции ``local foo``, что приведет к"
" следующему коду:"

msgid ""
"function f()\n"
"  local function foo(i)\n"
"    -- math.fmod is not yet compiled!\n"
"    return i <= 5 and i or math.fmod(i, 11)\n"
"  end\n"
"  -- minstitch option needs to emulate nonstitching behaviour\n"
"  jit.opt.start(0, \"hotloop=2\", \"hotexit=2\", \"minstitch=15\")\n"
"  local sum = 0\n"
"  local oldm = misc.getmetrics()\n"
"  for i = 1, 10 do\n"
"    sum = sum + foo(i)\n"
"  end\n"
"  local newm = misc.getmetrics()\n"
"  local diff = newm.jit_snap_restore - oldm.jit_snap_restore\n"
"  print(\"diff = \" .. diff)\n"
"end\n"
"f()"
msgstr ""
"function f()\n"
"  local function foo(i)\n"
"    -- math.fmod еще не скомпилирован!\n"
"    return i <= 5 and i or math.fmod(i, 11)\n"
"  end\n"
"  -- параметр minstitch нужен, чтобы эмулировать nonstitching поведение\n"
"  jit.opt.start(0, \"hotloop=2\", \"hotexit=2\", \"minstitch=15\")\n"
"  local sum = 0\n"
"  local oldm = misc.getmetrics()\n"
"  for i = 1, 10 do\n"
"    sum = sum + foo(i)\n"
"  end\n"
"  local newm = misc.getmetrics()\n"
"  local diff = newm.jit_snap_restore - oldm.jit_snap_restore\n"
"  print(\"diff = \" .. diff)\n"
"end\n"
"f()"

msgid ""
"The result will be: diff is larger, because there are more side exits. So "
"this test indicates that changing the code affected the performance."
msgstr ""
"Результат: значение diff увеличилось, так как стало больше сторонних "
"выходов. Этот тест показывает, что измение кода влияет на "
"производительность."
