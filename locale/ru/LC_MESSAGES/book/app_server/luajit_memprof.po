
msgid "LuaJIT memory profiler"
msgstr "Профилировщик памяти LuaJIT"

msgid ""
"Starting from version :doc:`2.7.1 </release/2.7.1>`, Tarantool has a "
"built‑in module called ``misc.memprof`` that implements a LuaJIT memory "
"profiler (which we will just call *the profiler* in this section). The "
"profiler provides a memory allocation report that helps analyze Lua code and"
" find the places that put the most pressure on the Lua garbage collector "
"(GC)."
msgstr ""
"В Tarantool, начиная с версии :doc:`2.7.1 </release/2.7.1>`, есть встроенный"
" модуль ``misc.memprof``, реализующий профилировщик памяти LuaJIT (далее в "
"разделе — *профилировщик*). Профилировщик предоставляет отчет об аллокации "
"памяти, который помогает проанализовать Lua-код и выявить области наибольшей"
" нагрузки на сборщик мусора на Lua."

msgid "Working with the profiler"
msgstr "Использование профилировщика"

msgid "Usage of the profiler involves two steps:"
msgstr "Работа с профилировщиком состоит из двух этапов:"

msgid ""
":ref:`Collecting <profiler_usage_get>` a binary profile of allocations, "
"reallocations, and deallocations in memory related to Lua (further, *binary "
"memory profile* or *binary profile* for short)."
msgstr ""
"События аллокации, реаллокации и деаллокации в Lua :ref:`собираются "
"<profiler_usage_get>` в бинарный профиль (далее по тексту — *бинарный "
"профиль памяти* или просто *бинарный профиль*)."

msgid ""
":ref:`Parsing <profiler_usage_parse>` the collected binary profile to get a "
"human-readable profiling report."
msgstr ""
"Выполняется :ref:`парсинг <profiler_usage_parse>` собранного бинарного "
"профиля. В результате формируется отчет о профилировании в удобном для "
"чтения формате."

msgid "Collecting binary profile"
msgstr "Сбор бинарного профиля"

msgid ""
"To collect a binary profile for a particular part of the Lua code, you need "
"to place this part between two ``misc.memprof`` functions, namely, "
"``misc.memprof.start()`` and ``misc.memprof.stop()``, and then execute the "
"code under Tarantool."
msgstr ""
"Чтобы сформировать бинарный профиль для определенного участка кода на Lua, "
"вставьте этот участок кода между функциями ``misc.memprof.start()`` и "
"``misc.memprof.stop()``, а затем выполните его в Tarantool."

msgid ""
"Below is a chunk of simple Lua code named ``test.lua`` to illustrate this."
msgstr ""
"Для наглядности ниже приведен фрагмент кода на Lua под названием "
"``test.lua``."

msgid ""
"-- Prevent allocations on traces.\n"
"jit.off()\n"
"local str, err = misc.memprof.start(\"memprof_new.bin\")\n"
"-- Lua doesn't create a new frame to call string.rep, and all allocations\n"
"-- are attributed not to the append() function but to the parent scope.\n"
"local function append(str, rep)\n"
"    return string.rep(str, rep)\n"
"end\n"
"\n"
"local t = {}\n"
"for i = 1, 1e4 do\n"
"    -- table.insert is the built-in function and all corresponding\n"
"    -- allocations are reported in the scope of the main chunk.\n"
"    table.insert(t,\n"
"        append('q', i)\n"
"    )\n"
"end\n"
"local stp, err = misc.memprof.stop()"
msgstr ""
"-- Отключение аллокации на трассах\n"
"jit.off()\n"
"local str, err = misc.memprof.start(\"memprof_new.bin\")\n"
"-- Lua не создает стековый фрейм для вызова string.rep,\n"
"-- поэтому все события аллокации\n"
"-- приписываются не функции append(), а родительской области\n"
"local function append(str, rep)\n"
"    return string.rep(str, rep)\n"
"end\n"
"\n"
"local t = {}\n"
"for i = 1, 1e4 do\n"
"    -- table.insert — встроенная функция,\n"
"    -- так что профилировщик включает все соответствующие ей\n"
"    -- события аллокации в отчет по основной части кода\n"
"    table.insert(t,\n"
"        append('q', i)\n"
"    )\n"
"end\n"
"local stp, err = misc.memprof.stop()"

msgid ""
"The Lua code for starting the profiler -- as in line 3 in the test.lua "
"example above -- is:"
msgstr ""
"В примере test.lua код для запуска профилировщика находится на строке 3:"

msgid "local str, err = misc.memprof.start(FILENAME)"
msgstr "local str, err = misc.memprof.start(ИМЯ_ФАЙЛА)"

msgid ""
"where ``FILENAME`` is the name of the binary file where profiling events are"
" written."
msgstr ""
"``ИМЯ_ФАЙЛА`` — имя бинарного файла, куда записываются профилируемые "
"события."

msgid ""
"If the operation fails, for example if it is not possible to open a file for"
" writing or if the profiler is already running, ``misc.memprof.start()`` "
"returns ``nil`` as the first result, an error-message string as the second "
"result, and a system-dependent error code number as the third result. If the"
" operation succeeds, ``misc.memprof.start()`` returns ``true``."
msgstr ""
"Если операция завершается ошибкой, функция ``misc.memprof.start()`` "
"возвращает результат, состоящий из трех частей: ``nil``; строка с сообщением"
" об ошибке; код ошибки в зависимости от системы. Ошибка может возникнуть, "
"например, когда не открывается файл для записи или профилировщик уже "
"запущен. Если операция выполняется успешно, ``misc.memprof.start()`` "
"возвращает ``true``."

msgid ""
"The Lua code for stopping the profiler -- as in line 18 in the test.lua "
"example above -- is:"
msgstr ""
"В примере test.lua код для остановки профилировщика находится на строке 18:"

msgid "local stp, err = misc.memprof.stop()"
msgstr "local stp, err = misc.memprof.stop()"

msgid ""
"If the operation fails, for example if  there is an error when the file "
"descriptor is being closed or if there is a failure during reporting, "
"``misc.memprof.stop()`` returns ``nil`` as the first result, an error-"
"message string as the second result, and a system-dependent error code "
"number as the third result. If the operation succeeds, "
"``misc.memprof.stop()`` returns ``true``."
msgstr ""
"Если операция завершается ошибкой, функция ``misc.memprof.stop()`` "
"возвращает результат, состоящий из трех частей: ``nil``; строка с сообщением"
" об ошибке; код ошибки в зависимости от системы. Ошибка может возникнуть, "
"например, когда закрыт файловый дескриптор или во время составления отчета "
"происходит сбой. Если операция выполняется успешно, ``misc.memprof.stop()`` "
"возвращает ``true``."

msgid ""
"To generate the file with memory profile in binary format (in the "
":ref:`test.lua code example above <profiler_usage_example01>` the file name "
"is ``memprof_new.bin``), execute the code under Tarantool:"
msgstr ""
"Теперь нужно сгенерировать файл с профилем памяти в бинарном формате. В "
":ref:`примере test.lua <profiler_usage_example01>` имя файла — "
"``memprof_new.bin``. Выполните код в Tarantool:"

msgid "$ tarantool test.lua"
msgstr "$ tarantool test.lua"

msgid ""
"Tarantool collects the allocation events in ``memprof_new.bin``, puts the "
"file in its :ref:`working directory <cfg_basic-work_dir>`, and closes the "
"session."
msgstr ""
"Tarantool собирает события аллокации в файл ``memprof_new.bin``, помещает "
"его в :ref:`рабочую директорию <cfg_basic-work_dir>` и завершает сеанс."

msgid ""
"The :ref:`test.lua code example <profiler_usage_example01>` above also "
"illustrates the memory allocation logic in some cases that are important to "
"understand for :ref:`reading <profiler_usage_parse>` and :ref:`analyzing "
"<profiler_analysis>` a profiling report:"
msgstr ""
":ref:`Пример test.lua <profiler_usage_example01>` также иллюстрирует логику,"
" по которой в некоторых случаях происходит аллокация памяти. Важно понимать "
"эту логику, чтобы :ref:`читать <profiler_usage_parse>` и :ref:`анализировать"
" <profiler_analysis>` отчеты о профилировании."

msgid ""
"Line 2: It is recommended to switch the JIT compilation off by calling "
"``jit.off()`` before the profiler start. Refer to the following :ref:`note "
"about jitoff <profiler_usage_internal_jitoff>` for more details."
msgstr ""
"Строка 2: Рекомендуется отключать JIT-компиляцию, вызывая ``jit.off()`` "
"перед запуском профилировщика. За дополнительными сведениями обратитесь к "
":ref:`примечанию о jitoff <profiler_usage_internal_jitoff>`."

msgid ""
"Lines 6-8: Tail call optimization doesn't create a new call frame, so all "
"allocations inside the function called via the ``CALLT/CALLMT`` `bytecodes "
"<http://wiki.luajit.org/Bytecode-2.0#calls-and-vararg-handling>`_ are "
"attributed to the function's caller. See also the comments preceding these "
"lines."
msgstr ""
"Строки 6–8: Оптимизация хвостового вызова не создает новый фрейм стека "
"вызовов, поэтому все события аллокации в `байт-коде "
"<http://wiki.luajit.org/Bytecode-2.0#calls-and-vararg-handling>`_ "
"``CALLT/CALLMT`` относятся на счет кода, вызывающего эту функцию. Обратите "
"внимание на комментарии перед этими строками."

msgid ""
"Lines 14-16: Usually the information about allocations inside Lua built‑ins "
"is not really useful for developers. That's why if a Lua built‑in function "
"is called from a Lua function, the profiler attributes all allocations to "
"the Lua function. Otherwise, this event is attributed to a C function. See "
"also the comments preceding these lines."
msgstr ""
"Строки 14–16: Как правило, разработчиков несильно интересует информация об "
"аллокации во встроенных функциях LuaJIT. Поэтому если встроенная функция "
"вызывается из функции на Lua, профилировщик собирает все события аллокации "
"для функции на Lua. В противном случае событие относится к функции на C. "
"Обратите внимание на комментарии перед этими строками."

msgid "Parsing binary profile and generating profiling report"
msgstr "Парсинг бинарного профиля и формирование отчета о профилировании"

msgid ""
"After getting the memory profile in binary format, the next step is to parse"
" it to get a human-readable profiling report. You can do this via Tarantool "
"by using the following command (mind the hyphen ``-`` prior to the file "
"name):"
msgstr ""
"Получив профиль памяти в двоичном формате, нужно выполнить парсинг, чтобы "
"отчет было удобно читать. Парсинг можно выполнить в Tarantool, "
"воспользовавшись следующей командой (обратите внимание на дефис ``-`` перед "
"именем файла):"

msgid "$ tarantool -e 'require(\"memprof\")(arg)' - memprof_new.bin"
msgstr "$ tarantool -e 'require(\"memprof\")(arg)' - memprof_new.bin"

msgid ""
"where ``memprof_new.bin`` is the binary profile :ref:`generated earlier "
"<profiler_usage_generate>` by ``tarantool test.lua``. (Warning: there is a "
"slight behavior change here, the ``tarantool -e ...`` command was slightly "
"different in Tarantool versions prior to Tarantool 2.8.1.)"
msgstr ""
"Здесь ``memprof_new.bin`` — бинарный профиль, :ref:`ранее сгенерированный "
"<profiler_usage_generate>` командой ``tarantool test.lua``. (Внимание: в "
"версии Tarantool 2.8.1 поведение команды ``tarantool -e`` немного "
"изменилось.)"

msgid ""
"Tarantool generates a profiling report and displays it on the console before"
" closing the session:"
msgstr ""
"Tarantool генерирует отчет о профилировании и выводит его в консоль перед "
"закрытием сеанса:"

msgid ""
"ALLOCATIONS\n"
"@test.lua:14: 10000 events  +50240518 bytes -0 bytes\n"
"@test.lua:9: 1 events       +32 bytes       -0 bytes\n"
"@test.lua:8: 1 events       +20 bytes       -0 bytes\n"
"@test.lua:13: 1 events      +24 bytes       -0 bytes\n"
"\n"
"REALLOCATIONS\n"
"@test.lua:13: 13 events     +262216 bytes   -131160 bytes\n"
"    Overrides:\n"
"        @test.lua:13\n"
"\n"
"@test.lua:14: 11 events     +49536 bytes    -24768 bytes\n"
"            Overrides:\n"
"        @test.lua:14\n"
"        INTERNAL\n"
"\n"
"INTERNAL: 3 events          +8448 bytes     -16896 bytes\n"
"    Overrides:\n"
"        @test.lua:14\n"
"\n"
"DEALLOCATIONS\n"
"INTERNAL: 1723 events       +0 bytes        -483515 bytes\n"
"@test.lua:14: 1 events      +0 bytes        -32768 bytes\n"
"\n"
"HEAP SUMMARY:\n"
"@test.lua:14 holds 50248326 bytes: 10010 allocs, 10 frees\n"
"@test.lua:13 holds 131080 bytes: 14 allocs, 13 frees\n"
"INTERNAL holds 8448 bytes: 3 allocs, 3 frees\n"
"@test.lua:9 holds 32 bytes: 1 allocs, 0 frees\n"
"@test.lua:8 holds 20 bytes: 1 allocs, 0 frees"
msgstr ""
"ALLOCATIONS\n"
"@test.lua:14: 10000 events  +50240518 bytes -0 bytes\n"
"@test.lua:9: 1 events       +32 bytes       -0 bytes\n"
"@test.lua:8: 1 events       +20 bytes       -0 bytes\n"
"@test.lua:13: 1 events      +24 bytes       -0 bytes\n"
"\n"
"REALLOCATIONS\n"
"@test.lua:13: 13 events     +262216 bytes   -131160 bytes\n"
"    Overrides:\n"
"        @test.lua:13\n"
"\n"
"@test.lua:14: 11 events     +49536 bytes    -24768 bytes\n"
"            Overrides:\n"
"        @test.lua:14\n"
"        INTERNAL\n"
"\n"
"INTERNAL: 3 events          +8448 bytes     -16896 bytes\n"
"    Overrides:\n"
"        @test.lua:14\n"
"\n"
"DEALLOCATIONS\n"
"INTERNAL: 1723 events       +0 bytes        -483515 bytes\n"
"@test.lua:14: 1 events      +0 bytes        -32768 bytes\n"
"\n"
"HEAP SUMMARY:\n"
"@test.lua:14 holds 50248326 bytes: 10010 allocs, 10 frees\n"
"@test.lua:13 holds 131080 bytes: 14 allocs, 13 frees\n"
"INTERNAL holds 8448 bytes: 3 allocs, 3 frees\n"
"@test.lua:9 holds 32 bytes: 1 allocs, 0 frees\n"
"@test.lua:8 holds 20 bytes: 1 allocs, 0 frees"

msgid ""
"On MacOS, a report will be different for the same chunk of code because "
"Tarantool and LuaJIT are built with the GC64 mode enabled for MacOS."
msgstr ""
"В macOS отчет по той же части кода выглядит по-другому, поскольку Tarantool "
"и LuaJIT собраны с поддержкой режима GC64 для macOS."

msgid "Let's examine the report structure. A report has four sections:"
msgstr "Рассмотрим структуру отчета. Он состоит из четырех разделов:"

msgid "ALLOCATIONS"
msgstr "ALLOCATIONS (аллокация)"

msgid "REALLOCATIONS"
msgstr "REALLOCATIONS (реаллокация)"

msgid "DEALLOCATIONS"
msgstr "DEALLOCATIONS (деаллокация)"

msgid ""
"HEAP SUMMARY (described later in :ref:`The heap summary and the --leak-only "
"option<luajit_memprof_leak_only>`)"
msgstr ""
"HEAP SUMMARY (cводка изменений в динамической памяти, раздел описан "
":ref:`ниже <luajit_memprof_leak_only>`)"

msgid ""
"Each section contains event records that are sorted from the most frequent "
"to the least frequent."
msgstr ""
"Записи в каждом разделе отсортированы в порядке от наиболее до наименее "
"частых событий."

msgid "An event record has the following format:"
msgstr "Запись о событии регистрируется в следующем формате:"

msgid ""
"@<filename>:<line_number>: <number_of_events> events +<allocated> bytes "
"-<freed> bytes"
msgstr ""
"@<имя_файла>:<номер_строки>: <количество_событий> events +<выделенные_байты>"
" bytes -<освобожденные_байты> bytes"

msgid "<filename>—a name of the file containing Lua code."
msgstr "<имя_файла> — имя файла, содержащего код на Lua."

msgid "<line_number>—the line number where the event is detected."
msgstr "<номер_строки> — номер строки, в которой обнаружено событие."

msgid "<number_of_events>—a number of events for this code line."
msgstr "<количество_событий> — количество событий для этой строки кода."

msgid ""
"+<allocated> bytes—amount of memory allocated during all the events on this "
"line."
msgstr ""
"+<выделенная_память_в_байтах> bytes — объем выделенной памяти для всех "
"событий в этой строке."

msgid ""
"-<freed> bytes—amount of memory freed during all the events on this line."
msgstr ""
"+<освобожденная_память_в_байтах> bytes — объем освобожденной памяти для всех"
" событий в этой строке."

msgid "The ``Overrides`` label shows what allocation has been overridden."
msgstr ""
"Метка ``Overrides`` на событии показывает, какое событие аллокации оно "
"замещает."

msgid ""
"See the :ref:`test.lua chunk above <profiler_usage_example01>` with the "
"explanation in the comments for some examples."
msgstr ""
"См. :ref:`код примера test.lua выше <profiler_usage_example01>` и пояснения "
"в комментариях к нему."

msgid ""
"The ``INTERNAL`` label indicates that this event is caused by internal "
"LuaJIT structures."
msgstr ""
"Метка ``INTERNAL`` показывает, что событие произошло во внутренних "
"структурах LuaJIT."

msgid ""
"Important note regarding the ``INTERNAL`` label and the recommendation of "
"switching the JIT compilation off (``jit.off()``): this version of the "
"profiler doesn't support verbose reporting for allocations on `traces "
"<https://en.wikipedia.org/wiki/Tracing_just-in-"
"time_compilation#Technical_details>`_. If memory allocations are made on a "
"trace, the profiler can't associate the allocations with the part of Lua "
"code that generated the trace. In this case, the profiler labels such "
"allocations as ``INTERNAL``."
msgstr ""
"Важное примечание о метке ``INTERNAL`` и рекомендации отключать компиляцию "
"JIT (``jit.off()``). В текущей версии профилировщика не поддерживается "
"подробное (verbose) описание событий аллокации при `трассировке "
"<https://en.wikipedia.org/wiki/Tracing_just-in-"
"time_compilation#Technical_details>`_. Если память выделяется во время "
"трассировки, профилировщик не может соотнести события аллокации с "
"соответствующей частью кода. В этом случае профилировщик помечает такие "
"события как ``INTERNAL``."

msgid ""
"So, if the JIT compilation is on, new traces will be generated and there "
"will be a mixture of events labeled ``INTERNAL`` in the profiling report: "
"some of them are really caused by internal LuaJIT structures, but some of "
"them are caused by allocations on traces."
msgstr ""
"Когда компиляция JIT включена, выполняется несколько процессов трассировки. "
"В результате пометку ``INTERNAL`` в отчете о профилировании получают самые "
"разные события: некоторые из них действительно возникают во внутренних "
"структурах LuaJIT, а другие вызваны аллокацией при трассировке."

msgid ""
"If you want to have a more definite report without JIT compiler allocations,"
" :ref:`call jit.off() <profiler_usage_example01>` before starting the "
"profiling. And if you want to completely exclude the trace allocations from "
"the report, remove also the old traces by additionally calling "
"``jit.flush()`` after ``jit.off()``."
msgstr ""
"Вы можете получить более конкретный отчет, в который не входят события "
"аллокации, вызванные JIT-компилятором. Для этого до запуска профилировщика "
":ref:`вызовите jit.off() <profiler_usage_example01>`. Чтобы полностью "
"исключить из отчета аллокацию на трассах, удалите предыдущие трассы, вызвав "
"после ``jit.off()`` функцию ``jit.flush()``."

msgid ""
"Nevertheless, switching the JIT compilation off before the profiling is not "
"\"a must\". It is rather a recommendation, and in some cases, for example in"
" a production environment, you may need to keep JIT compilation on to see "
"the full picture of all the memory allocations. In this case, the majority "
"of the ``INTERNAL`` events are most probably caused by traces."
msgstr ""
"Отключать компиляцию JIT перед запуском профилировщика рекомендуется, но это"
" не обязательно. Например, в производственной среде без компиляции JIT "
"полное представление об аллокациях памяти получить невозможно. В подобных "
"случаях большая часть событий ``INTERNAL``, вероятнее всего, происходит при "
"трассировках."

msgid ""
"As for investigating the Lua code with the help of profiling reports, it is "
"always code-dependent and there can't be hundred per cent definite "
"recommendations in this regard. Nevertheless, you can see some of the things"
" in the :ref:`Profiling report analysis example <profiler_analysis>` later."
msgstr ""
"Иногда отчет о профилировании помогает исследовать код на Lua. Однако этот "
"метод подходит не для любого кода, так что рекомендаций на этот счет нет. "
"Посмотрите :ref:`пример анализа отчета о профилировании "
"<profiler_analysis>`, чтобы узнать, как можно использовать отчет для "
"исследования кода."

msgid ""
"Also, below is the :ref:`FAQ <profiler_faq>` section with the questions that"
" most probably can arise while using profiler."
msgstr ""
"Больше информации о том, как использовать профилировщик, вы найдете ниже в "
"разделе :ref:`Вопросы и ответы <profiler_faq>`."

msgid "FAQ"
msgstr "Вопросы и ответы"

msgid ""
"In this section, some profiler-related points are discussed in a Q&A format."
msgstr ""
"В этом разделе даются ответы на часто задаваемые вопросы о работе "
"профилировщика."

msgid ""
"**Question (Q)**: Is the profiler suitable for C allocations or allocations "
"inside C code?"
msgstr "**Вопрос (В)**: Проверяет ли профилировщик аллокацию в C и коде на C?"

msgid ""
"**Answer (A)**: The profiler reports only allocation events caused by the "
"Lua allocator. All Lua-related allocations, like table or string creation "
"are reported. But the profiler doesn't report allocations made by "
"``malloc()`` or other non-Lua allocators. You can use ``valgrind`` to debug "
"them."
msgstr ""
"**Ответ (A)**: Профилировщик включает в отчет только события выделения "
"памяти Lua-аллокатором. Отчет содержит все события аллокации в Lua, например"
" создание таблиц и строк. Однако профилировщик не отслеживает выделение "
"памяти с помощью ``malloc()`` или действия аллокаторов, не связанных с Lua. "
"Чтобы фиксировать такие события, для отладки можно использовать "
"``valgrind``."

msgid ""
"**Q**: Why are there so many ``INTERNAL`` allocations in my profiling "
"report? What does it mean?"
msgstr ""
"**В**: Почему у меня в отчете о профилировании столько событий аллокации "
"``INTERNAL``? Что это значит?"

msgid ""
"**A**: ``INTERNAL`` means that these allocations/reallocations/deallocations"
" are related to the internal LuaJIT structures or are made on traces. "
"Currently, the profiler doesn't verbosely report allocations of objects that"
" are made during trace execution. Try :ref:`adding jit.off() "
"<profiler_usage_internal_jitoff>` before the profiler start."
msgstr ""
"**О**: Пометка ``INTERNAL`` означает, что событие "
"аллокации/реаллокации/деаллокации связано с внутренними структурами LuaJIT "
"или трассами. Сейчас профилировщик не включает в отчет подробное описание "
"событий аллокации для объектов, создаваемых на трассах. Попробуйте перед "
"запуском профилировщика :ref:`добавить jit.off() "
"<profiler_usage_internal_jitoff>`."

msgid ""
"**Q**: Why are there some reallocations/deallocations without an "
"``Overrides`` section?"
msgstr ""
"**В**: Почему на некоторых событиях аллокации/деаллокации нет метки "
"``Overrides``?"

msgid ""
"**A**: These objects can be created before the profiler starts. Adding "
"``collectgarbage()`` before the profiler's start enables collecting all "
"previously allocated objects that are dead when the profiler starts."
msgstr ""
"**О**: Вероятно, события связаны с объектами, созданными до запуска "
"профилировщика. Если перед запуском профилировщика добавить вызов "
"``collectgarbage()``, то будут учитываться и события, связанные с "
"\"мертвыми\" объектами: под такие объекты ранее была выделена память, но на "
"момент запуска профилировщика они уже недоступны."

msgid ""
"**Q**: Why are some objects not collected during profiling? Is it a memory "
"leak?"
msgstr ""
"**В**: Почему некоторые объекты не учитываются при профилировании? Это "
"связано с утечкой памяти?"

msgid ""
"**A**: LuaJIT uses incremental Garbage Collector (GC). A GC cycle may not be"
" finished at the moment the profiler stops. Add ``collectgarbage()`` before "
"stopping the profiler to collect all the dead objects for sure."
msgstr ""
"**О**: LuaJIT использует инкрементальный сборщик мусора. Когда профилировщик"
" завершает работу, цикл сборки мусора может все еще выполняться. Чтобы "
"обеспечить профилирование \"мертвых\" объектов, добавьте "
"``collectgarbage()`` перед командой остановки профилировщика."

msgid ""
"**Q**: Can I profile not just a current chunk but the entire running "
"application? Can I start the profiler when the application is already "
"running?"
msgstr ""
"**В**: Можно ли профилировать не только часть кода, а все приложение? Можно "
"ли запустить профилировщик во время работы приложения?"

msgid ""
"**A**: Yes. Here is an example of code that can be inserted in the Tarantool"
" console for a running instance."
msgstr ""
"**О**: Да. Вот пример кода, который можно вставить в консоль Tarantool, "
"когда приложение уже запущено:"

msgid ""
"local fiber = require \"fiber\"\n"
"local log = require \"log\"\n"
"\n"
"fiber.create(function()\n"
"  fiber.name(\"memprof\")\n"
"\n"
"  collectgarbage() -- Collect all objects already dead\n"
"  log.warn(\"start of profile\")\n"
"\n"
"  local st, err = misc.memprof.start(FILENAME)\n"
"  if not st then\n"
"    log.error(\"failed to start profiler: %s\", err)\n"
"  end\n"
"\n"
"  fiber.sleep(TIME)\n"
"\n"
"  collectgarbage()\n"
"  st, err = misc.memprof.stop()\n"
"\n"
"  if not st then\n"
"    log.error(\"profiler on stop error: %s\", err)\n"
"  end\n"
"\n"
"  log.warn(\"end of profile\")\n"
"end)"
msgstr ""
"local fiber = require \"fiber\"\n"
"local log = require \"log\"\n"
"\n"
"fiber.create(function()\n"
"  fiber.name(\"memprof\")\n"
"\n"
"  collectgarbage() -- Сбор мертвых объектов\n"
"  log.warn(\"start of profile\")\n"
"\n"
"  local st, err = misc.memprof.start(ИМЯ_ФАЙЛА)\n"
"  if not st then\n"
"    log.error(\"failed to start profiler: %s\", err)\n"
"  end\n"
"\n"
"  fiber.sleep(ВРЕМЯ)\n"
"\n"
"  collectgarbage()\n"
"  st, err = misc.memprof.stop()\n"
"\n"
"  if not st then\n"
"    log.error(\"profiler on stop error: %s\", err)\n"
"  end\n"
"\n"
"  log.warn(\"end of profile\")\n"
"end)"

msgid "where"
msgstr "Пояснения:"

msgid ""
"``FILENAME``—the name of the binary file where profiling events are written"
msgstr ""
"``ИМЯ_ФАЙЛА`` — имя бинарного файла, куда записываются профилируемые "
"события."

msgid "``TIME``—duration of profiling, in seconds."
msgstr "``ВРЕМЯ`` — продолжительность профилирования в секундах."

msgid ""
"Also, you can directly call ``misc.memprof.start()`` and "
"``misc.memprof.stop()`` from a console."
msgstr ""
"Кроме того, вызывать ``misc.memprof.start()`` и ``misc.memprof.stop()`` "
"можно напрямую из консоли."

msgid "Profiling report analysis example"
msgstr "Пример анализа отчета о профилировании"

msgid ""
"In the example below, the following Lua code named ``format_concat.lua`` is "
"investigated with the help of the memory profiler reports."
msgstr ""
"Ниже приведен код на Lua --- файл ``format_concat.lua``. Этот код будет "
"исследован с применением отчетов о профилировании памяти."

msgid ""
"-- Prevent allocations on new traces.\n"
"jit.off()\n"
"\n"
"local function concat(a)\n"
"  local nstr = a..\"a\"\n"
"  return nstr\n"
"end\n"
"\n"
"local function format(a)\n"
"  local nstr = string.format(\"%sa\", a)\n"
"  return nstr\n"
"end\n"
"\n"
"collectgarbage()\n"
"\n"
"local binfile = \"/tmp/memprof_\"..(arg[0]):match(\"([^/]*).lua\")..\".bin\"\n"
"\n"
"local st, err = misc.memprof.start(binfile)\n"
"assert(st, err)\n"
"\n"
"-- Payload.\n"
"for i = 1, 10000 do\n"
"  local f = format(i)\n"
"  local c = concat(i)\n"
"end\n"
"collectgarbage()\n"
"\n"
"local st, err = misc.memprof.stop()\n"
"assert(st, err)\n"
"\n"
"os.exit()"
msgstr ""
"-- Отключение аллокации на новых трассах\n"
"jit.off()\n"
"\n"
"local function concat(a)\n"
"  local nstr = a..\"a\"\n"
"  return nstr\n"
"end\n"
"\n"
"local function format(a)\n"
"  local nstr = string.format(\"%sa\", a)\n"
"  return nstr\n"
"end\n"
"\n"
"collectgarbage()\n"
"\n"
"local binfile = \"/tmp/memprof_\"..(arg[0]):match(\"([^/]*).lua\")..\".bin\"\n"
"\n"
"local st, err = misc.memprof.start(binfile)\n"
"assert(st, err)\n"
"\n"
"-- Нагрузка\n"
"for i = 1, 10000 do\n"
"  local f = format(i)\n"
"  local c = concat(i)\n"
"end\n"
"collectgarbage()\n"
"\n"
"local st, err = misc.memprof.stop()\n"
"assert(st, err)\n"
"\n"
"os.exit()"

msgid ""
"When you run this code :ref:`under Tarantool <profiler_usage_generate>` and "
"then :ref:`parse <profiler_usage_parse_command>` the binary memory profile "
"in /tmp/memprof_format_concat.bin, you will get the following profiling "
"report:"
msgstr ""
"Запустив этот код :ref:`в Tarantool <profiler_usage_generate>` и выполнив "
"последующий :ref:`парсинг <profiler_usage_parse_command>` бинарного профиля "
"в /tmp/memprof_format_concat.bin, вы получите такой отчет о профилировании:"

msgid ""
"ALLOCATIONS\n"
"@format_concat.lua:10: 19996 events +624284 bytes   -0 bytes\n"
"INTERNAL: 1 events                  +65536 bytes    -0 bytes\n"
"\n"
"REALLOCATIONS\n"
"\n"
"DEALLOCATIONS\n"
"INTERNAL: 19996 events              +0 bytes        -558778 bytes\n"
"    Overrides:\n"
"        @format_concat.lua:10\n"
"\n"
"@format_concat.lua:10: 2 events     +0 bytes        -98304 bytes\n"
"    Overrides:\n"
"        @format_concat.lua:10\n"
"\n"
"HEAP SUMMARY:\n"
"INTERNAL holds 65536 bytes: 1 allocs, 0 frees"
msgstr ""
"ALLOCATIONS\n"
"@format_concat.lua:10: 19996 events +624284 bytes   -0 bytes\n"
"INTERNAL: 1 events                  +65536 bytes    -0 bytes\n"
"\n"
"REALLOCATIONS\n"
"\n"
"DEALLOCATIONS\n"
"INTERNAL: 19996 events              +0 bytes        -558778 bytes\n"
"    Overrides:\n"
"        @format_concat.lua:10\n"
"\n"
"@format_concat.lua:10: 2 events     +0 bytes        -98304 bytes\n"
"    Overrides:\n"
"        @format_concat.lua:10\n"
"\n"
"HEAP SUMMARY:\n"
"INTERNAL holds 65536 bytes: 1 allocs, 0 frees"

msgid "Reasonable questions regarding the report can be:"
msgstr "Отчет может вызвать такие вопросы:"

msgid "Why are there no allocations related to the ``concat()`` function?"
msgstr "Почему нет событий по функции ``concat()``?"

msgid "Why is the number of allocations not a round number?"
msgstr "Почему количество событий — это не целое число?"

msgid "Why are there approximately 20K allocations instead of 10K?"
msgstr "Почему в отчете не 10 тысяч событий, а около 20 тысяч?"

msgid ""
"First of all, LuaJIT doesn't create a new string if the string with the same"
" payload exists (see details on `lua-users.org/wiki <http://lua-"
"users.org/wiki/ImmutableObjects>`_). This is called `string interning "
"<https://en.wikipedia.org/wiki/String_interning>`_. So, when a string is "
"created via the ``format()`` function, there is no need to create the same "
"string via the ``concat()`` function, and LuaJIT just uses the previous one."
msgstr ""
"Во-первых, LuaJIT не создает новую строку, если уже есть строка с такой же "
"нагрузкой (подробнее на сайте `lua-users.org/wiki <http://lua-"
"users.org/wiki/ImmutableObjects>`_). Это называется `интернированием строк "
"<https://en.wikipedia.org/wiki/String_interning>`_. Иными словами, если "
"строка создана с помощью функции ``format()``, нет необходимости создавать "
"такую же строку с помощью функции ``concat()`` — LuaJIT будет использовать "
"предыдущую."

msgid ""
"That is also the reason why the number of allocations is not a round number "
"as could be expected from the cycle operator ``for i = 1, 10000...``: "
"Tarantool creates some strings for internal needs and built‑in modules, so "
"some strings already exist."
msgstr ""
"По этой же причине количество событий аллокации — это не целое число, как "
"можно было бы ожидать при использовании оператора цикла ``for i = 1, "
"10000...``. Некоторые строки Tarantool создает для внутренних нужд и "
"встроенных модулей, поэтому часть строк уже существует."

msgid ""
"But why are there so many allocations? It's almost twice as big as the "
"expected amount. This is because the ``string.format()`` built‑in function "
"creates another string necessary for the ``%s`` identifier, so there are two"
" allocations for each iteration: for ``tostring(i)`` and for "
"``string.format(\"%sa\", string_i_value)``. You can see the difference in "
"behavior by adding the line ``local _ = tostring(i)`` between lines 22 and "
"23."
msgstr ""
"Но откуда столько событий аллокации? Их почти в 2 раза больше, чем можно "
"было бы ожидать. Это происходит потому, что встроенная функция "
"``string.format()`` каждый раз создает дополнительную строку для "
"идентификатора ``%s``. То есть в каждой итерации регистрируются два события "
"аллокации: для ``tostring(i)`` и для ``string.format(\"%sa\", "
"string_i_value)``. Добавив строку ``local _ = tostring(i)`` между строками "
"22 и 23, вы увидите разницу в поведении."

msgid ""
"To profile only the ``concat()`` function, comment out line 23 (which is "
"``local f = format(i)``) and run the profiler. Now the output will look like"
" this:"
msgstr ""
"Чтобы профилировать только функцию ``concat()``, закомментируйте строку 23 "
"(``local f = format(i)``) и запустите профилировщик. Теперь результат будет "
"такой:"

msgid ""
"ALLOCATIONS\n"
"@format_concat.lua:5: 10000 events  +284411 bytes    -0 bytes\n"
"\n"
"REALLOCATIONS\n"
"\n"
"DEALLOCATIONS\n"
"INTERNAL: 10000 events              +0 bytes         -218905 bytes\n"
"    Overrides:\n"
"        @format_concat.lua:5\n"
"\n"
"@format_concat.lua:5: 1 events      +0 bytes         -32768 bytes\n"
"\n"
"HEAP SUMMARY:\n"
"@format_concat.lua:5 holds 65536 bytes: 10000 allocs, 9999 frees"
msgstr ""
"ALLOCATIONS\n"
"@format_concat.lua:5: 10000 events  +284411 bytes    -0 bytes\n"
"\n"
"REALLOCATIONS\n"
"\n"
"DEALLOCATIONS\n"
"INTERNAL: 10000 events              +0 bytes         -218905 bytes\n"
"    Overrides:\n"
"        @format_concat.lua:5\n"
"\n"
"@format_concat.lua:5: 1 events      +0 bytes         -32768 bytes\n"
"\n"
"HEAP SUMMARY:\n"
"@format_concat.lua:5 holds 65536 bytes: 10000 allocs, 9999 frees"

msgid "**Q**: But what will change if JIT compilation is enabled?"
msgstr "**В**: Что изменится, если включить компиляцию JIT?"

msgid ""
"**A**: In the :ref:`code <profiler_usage_example03>`, comment out line 2 "
"(which is ``jit.off()``) and run the profiler . Now there are only 56 "
"allocations in the report, and all other allocations are JIT-related (see "
"also the related `dev issue "
"<https://github.com/tarantool/tarantool/issues/5679>`_):"
msgstr ""
"**О**: Закомментируйте вторую строку (``jit.off()``) в :ref:`коде "
"<profiler_usage_example03>` и запустите профилировщик. Теперь в отчете "
"только 56 событий. Остальные события связаны с JIT (см. также "
"соответствующую `задачу на GitHub "
"<https://github.com/tarantool/tarantool/issues/5679>`_):"

msgid ""
"ALLOCATIONS\n"
"@format_concat.lua:5: 56 events +1112 bytes -0 bytes\n"
"@format_concat.lua:0: 4 events  +640 bytes  -0 bytes\n"
"INTERNAL: 2 events              +382 bytes  -0 bytes\n"
"\n"
"REALLOCATIONS\n"
"\n"
"DEALLOCATIONS\n"
"INTERNAL: 58 events             +0 bytes    -1164 bytes\n"
"    Overrides:\n"
"        @format_concat.lua:5\n"
"        INTERNAL\n"
"\n"
"\n"
"HEAP SUMMARY:\n"
"@format_concat.lua:0 holds 640 bytes: 4 allocs, 0 frees\n"
"INTERNAL holds 360 bytes: 2 allocs, 1 frees"
msgstr ""
"ALLOCATIONS\n"
"@format_concat.lua:5: 56 events +1112 bytes -0 bytes\n"
"@format_concat.lua:0: 4 events  +640 bytes  -0 bytes\n"
"INTERNAL: 2 events              +382 bytes  -0 bytes\n"
"\n"
"REALLOCATIONS\n"
"\n"
"DEALLOCATIONS\n"
"INTERNAL: 58 events             +0 bytes    -1164 bytes\n"
"    Overrides:\n"
"        @format_concat.lua:5\n"
"        INTERNAL\n"
"\n"
"\n"
"HEAP SUMMARY:\n"
"@format_concat.lua:0 holds 640 bytes: 4 allocs, 0 frees\n"
"INTERNAL holds 360 bytes: 2 allocs, 1 frees"

msgid ""
"This happens because a trace has been compiled after 56 iterations (the "
"default value of the ``hotloop`` compiler parameter). Then, the JIT-compiler"
" removed the unused variable ``c`` from the trace, and, therefore, the dead "
"code of the ``concat()`` function is eliminated."
msgstr ""
"Так произошло потому, что трассировка была скомпилирована после 56 итераций "
"(это значение параметра компилятора ``hotloop`` по умолчанию). Затем JIT-"
"компилятор удалил из трассировки неиспользуемую переменную ``c``, а вместе с"
" ней и неиспользуемый код функции ``concat()``."

msgid ""
"Next, let's profile only the ``format()`` function with JIT enabled. For "
"that, comment out lines 2 and 24 (``jit.off()`` and ``local c = "
"concat(i)``), do not comment out line 23 (``local f = format(i)``), and run "
"the profiler. Now the output will look like this:"
msgstr ""
"Теперь включите компиляцию JIT и запустите профилирование только для функции"
" ``format()``. Для этого закомментируйте строки 2 и 24 (``jit.off()`` и "
"``local c = concat(i)``), раскомментируйте строку 23 (``local f = "
"format(i)``) и вызовите профилировщик. Результат будет такой:"

msgid ""
"ALLOCATIONS\n"
"@format_concat.lua:10: 19996 events +624284 bytes  -0 bytes\n"
"INTERNAL: 4 events                  +66928 bytes   -0 bytes\n"
"@format_concat.lua:0: 4 events      +640 bytes     -0 bytes\n"
"\n"
"REALLOCATIONS\n"
"\n"
"DEALLOCATIONS\n"
"INTERNAL: 19997 events              +0 bytes       -559034 bytes\n"
"    Overrides:\n"
"        @format_concat.lua:0\n"
"        @format_concat.lua:10\n"
"\n"
"@format_concat.lua:10: 2 events     +0 bytes       -98304 bytes\n"
"    Overrides:\n"
"        @format_concat.lua:10\n"
"\n"
"\n"
"HEAP SUMMARY:\n"
"INTERNAL holds 66928 bytes: 4 allocs, 0 frees\n"
"@format_concat.lua:0 holds 384 bytes: 4 allocs, 1 frees"
msgstr ""
"ALLOCATIONS\n"
"@format_concat.lua:10: 19996 events +624284 bytes  -0 bytes\n"
"INTERNAL: 4 events                  +66928 bytes   -0 bytes\n"
"@format_concat.lua:0: 4 events      +640 bytes     -0 bytes\n"
"\n"
"REALLOCATIONS\n"
"\n"
"DEALLOCATIONS\n"
"INTERNAL: 19997 events              +0 bytes       -559034 bytes\n"
"    Overrides:\n"
"        @format_concat.lua:0\n"
"        @format_concat.lua:10\n"
"\n"
"@format_concat.lua:10: 2 events     +0 bytes       -98304 bytes\n"
"    Overrides:\n"
"        @format_concat.lua:10\n"
"\n"
"\n"
"HEAP SUMMARY:\n"
"INTERNAL holds 66928 bytes: 4 allocs, 0 frees\n"
"@format_concat.lua:0 holds 384 bytes: 4 allocs, 1 frees"

msgid ""
"**Q**: Why are there so many allocations in comparison to the ``concat()`` "
"function?"
msgstr ""
"**В**: Откуда так много событий аллокации по сравнению с ``concat()``?"

msgid ""
"**A**: The answer is simple: the ``string.format()`` function with the "
"``%s`` identifier is not yet compiled via LuaJIT. So, a trace can't be "
"recorded and the compiler doesn't perform the corresponding optimizations."
msgstr ""
"**О**: Ответ прост: LuaJIT еще не скомпилировал функцию ``string.format()`` "
"с идентификатором ``%s``. Поэтому трассировка не регистрируется, а "
"компилятор не выполняет соответствующую оптимизацию."

msgid ""
"If we change the ``format()`` function in lines 9-12 of the :ref:`Profiling "
"report analysis example <profiler_usage_example03>` in the following way"
msgstr ""
"Изменим функцию ``format`` в строках 9--12 :ref:`примера для анализа отчета "
"о профилировании <profiler_usage_example03>` следующим образом:"

msgid ""
"local function format(a)\n"
"  local nstr = string.format(\"%sa\", tostring(a))\n"
"  return nstr\n"
"end"
msgstr ""
"local function format(a)\n"
"  local nstr = string.format(\"%sa\", tostring(a))\n"
"  return nstr\n"
"end"

msgid "the profiling report becomes much prettier:"
msgstr "Теперь отчет о профилировании будет выглядеть намного лучше:"

msgid ""
"ALLOCATIONS\n"
"@format_concat.lua:10: 109 events   +2112 bytes -0 bytes\n"
"@format_concat.lua:0: 4 events      +640 bytes  -0 bytes\n"
"INTERNAL: 3 events                  +1206 bytes -0 bytes\n"
"\n"
"REALLOCATIONS\n"
"\n"
"DEALLOCATIONS\n"
"INTERNAL: 112 events                +0 bytes    -2460 bytes\n"
"    Overrides:\n"
"        @format_concat.lua:0\n"
"        @format_concat.lua:10\n"
"        INTERNAL\n"
"\n"
"\n"
"HEAP SUMMARY:\n"
"INTERNAL holds 1144 bytes: 3 allocs, 1 frees\n"
"@format_concat.lua:0 holds 384 bytes: 4 allocs, 1 frees"
msgstr ""
"ALLOCATIONS\n"
"@format_concat.lua:10: 109 events   +2112 bytes -0 bytes\n"
"@format_concat.lua:0: 4 events      +640 bytes  -0 bytes\n"
"INTERNAL: 3 events                  +1206 bytes -0 bytes\n"
"\n"
"REALLOCATIONS\n"
"\n"
"DEALLOCATIONS\n"
"INTERNAL: 112 events                +0 bytes    -2460 bytes\n"
"    Overrides:\n"
"        @format_concat.lua:0\n"
"        @format_concat.lua:10\n"
"        INTERNAL\n"
"\n"
"\n"
"HEAP SUMMARY:\n"
"INTERNAL holds 1144 bytes: 3 allocs, 1 frees\n"
"@format_concat.lua:0 holds 384 bytes: 4 allocs, 1 frees"

msgid "The heap summary and the --leak-only option"
msgstr "Сводка изменений в динамической памяти и параметр --leak-only"

msgid "This feature was added in version :doc:`2.8.1 </release/2.8.1>`."
msgstr ""
"Эта функциональная возможность появилась в версии :doc:`2.8.1 "
"</release/2.8.1>`."

msgid ""
"The end of each display is a HEAP SUMMARY section which looks like this:"
msgstr ""
"В конце каждого отчета приводится раздел HEAP SUMMARY (сводка изменений в "
"динамической памяти). Этот раздел выглядит так:"

msgid ""
"@<filename>:<line number> holds <number of still reachable bytes> bytes:\n"
"<number of allocation events> allocs, <number of deallocation events> frees"
msgstr ""
"@<имя_файла>:<номер_строки> holds <количество_доступных_байтов> bytes: "
"<количество_событий_аллокации> allocs, <количество_событий_деаллокации> "
"frees"

msgid ""
"Sometimes a program can cause many deallocations, so the DEALLOCATION "
"section can become large, so the display is not easy to read. To minimize "
"output, start the parsing with an extra flag: ``--leak-only``, for example"
msgstr ""
"Иногда программа может вызывать множество событий деаллокации. В этом случае"
" раздел DEALLOCATION сильно увеличится и отчет будет сложно читать. Чтобы "
"уменьшить количество выводимых данных, запустите парсинг с дополнительным "
"параметром ``--leak-only``. Например, так:"

msgid "$ tarantool -e 'require(\"memprof\")(arg)' - --leak-only memprof_new.bin"
msgstr "$ tarantool -e 'require(\"memprof\")(arg)' - --leak-only memprof_new.bin"

msgid ""
"When `--leak-only`` is used, only the HEAP SUMMARY section is displayed."
msgstr ""
"При использовании параметра ``--leak-only`` выводится только раздел HEAP "
"SUMMARY."
