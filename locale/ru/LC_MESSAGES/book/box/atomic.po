
msgid "Transactions"
msgstr "Транзакции"

msgid ""
"Transactions in Tarantool occur in **fibers** on a single **thread**. That "
"is why Tarantool has a guarantee of execution atomicity. That requires "
"emphasis."
msgstr ""
"Транзакции в Tarantool'е происходят в **файберах** в одном **потоке**. Вот "
"почему Tarantool дает гарантию атомарности выполнения. На этом следует "
"сделать акцент."

msgid "Threads, fibers and yields"
msgstr "Потоки, файберы и передача управления"

msgid ""
"How does Tarantool process a basic operation? As an example, let's take this"
" query:"
msgstr ""
"Как Tarantool выполняет основные операции? Для примера возьмем такой запрос:"

msgid ""
"tarantool> box.space.tester:update({3}, {{'=', 2, 'size'}, {'=', 3, 0}})"
msgstr ""
"tarantool> box.space.tester:update({3}, {{'=', 2, 'size'}, {'=', 3, 0}})"

msgid ""
"This is equivalent to the following SQL statement for a table that stores "
"primary keys in ``field[1]``:"
msgstr ""
"Это эквивалентно следующему SQL-выражению (оно работает с таблицей, где "
"первичные ключи в ``field[1]``):"

msgid "UPDATE tester SET \"field[2]\" = 'size', \"field[3]\" = 0 WHERE \"field[1]\" = 3"
msgstr "UPDATE tester SET \"field[2]\" = 'size', \"field[3]\" = 0 WHERE \"field[1]\" = 3"

#, fuzzy
msgid ""
"Assuming this query is received by Tarantool via network, it will be "
"processed with three operating system **threads**:"
msgstr "Этот запрос будет обработан тремя **потоками** операционной системы:"

msgid ""
"The **network thread** on the server side receives the query, parses the "
"statement, checks if it's correct, and then transforms it into a special "
"structure--a message containing an executable statement and its options."
msgstr ""

msgid ""
"The network thread ships this message to the instance's **transaction "
"processor thread** using a lock-free message bus. Lua programs execute "
"directly in the transaction processor thread, and do not require parsing and"
" preparation."
msgstr ""
"Сетевой поток отправляет это сообщение в **поток обработки транзакций** с "
"помощью шины передачи сообщений без блокировок. Lua-программы выполняются "
"непосредственно в потоке обработки транзакций и не требуют разбора и "
"подготовки."

#, fuzzy
msgid ""
"The instance's transaction processor thread uses the primary-key index on "
"field[1] to find the location of the tuple. It determines that the tuple can"
" be updated (not much can go wrong when you're merely changing an unindexed "
"field value)."
msgstr ""
"Поток обработки транзакций экземпляра использует индекс на поле первичного "
"ключа field[1], чтобы найти нужный кортеж. Он проверяет, что данный кортеж "
"можно обновить (мы хотим лишь изменить значение не индексированного поля на "
"более короткое, и вряд ли что-то пойдет не так)."

#, fuzzy
msgid ""
"The transaction processor thread sends a message to the :ref:`write-ahead "
"logging (WAL) thread <internals-wal>` to commit the transaction. When done, "
"the WAL thread replies with a COMMIT or ROLLBACK result to the transaction "
"processor which gives it back to the network thread, and the network thread "
"returns the result to the client."
msgstr ""
"Поток обработки транзакций отправляет сообщение в :ref:`поток упреждающей "
"записи в журнал (WAL) <internals-wal>` для коммита транзакции. По завершении"
" поток WAL отправляет ответ с результатом COMMIT (коммит) или ROLLBACK "
"(откат) на клиент."

msgid ""
"Notice that there is only one transaction processor thread in Tarantool. "
"Some people are used to the idea that there can be multiple threads "
"operating on the database, with (say) thread #1 reading row #x, while thread"
" #2 writes row #y. With Tarantool, no such thing ever happens. Only the "
"transaction processor thread can access the database, and there is only one "
"transaction processor thread for each Tarantool instance."
msgstr ""
"Обратите внимание, что в Tarantool'е есть только один поток обработки "
"транзакций. Некоторые уже привыкли к мысли, что потоков для обработки данных"
" в базе данных может быть много (например, поток №1 читает данные из строки "
"№x, в то время как поток №2 записывает данные в столбец №y). В случае с "
"Tarantool'ом такого не происходит. Доступ к базе есть только у потока "
"обработки транзакций, и на  каждый экземпляр Tarantool'а есть только один "
"такой поток."

msgid ""
"Like any other Tarantool thread, the transaction processor thread can handle"
" many :ref:`fibers <fiber-fibers>`. A fiber is a set of computer "
"instructions that may contain \"**yield**\" signals. The transaction "
"processor thread will execute all computer instructions until a yield, then "
"switch to execute the instructions of a different fiber. Thus (say) the "
"thread reads row #x for the sake of fiber #1, then writes row #y for the "
"sake of fiber #2."
msgstr ""
"Как и любой другой поток Tarantool'а, поток обработки транзакций может "
"управлять множеством :ref:`файберов <fiber-fibers>`. Файбер -- это набор "
"команд, среди которых могут быть и сигналы \"**передачи управления**\". "
"Поток обработки транзакций выполняет все команды, пока не увидит такой "
"сигнал, и тогда он переключается на выполнение команд из другого файбера. "
"Например, таким образом поток обработки транзакций сначала выполняет чтение "
"данных из строки №x для файбера №1, а затем выполняет запись в строку №y для"
" файбера №2."

msgid ""
"Yields must happen, otherwise the transaction processor thread would stick "
"permanently on the same fiber. There are two types of yields:"
msgstr ""
"Передача управления необходима, в противном случае, поток обработки "
"транзакции заклинит на одном файбере. Есть два типа передачи управления:"

msgid ""
":ref:`implicit yields <atomic-implicit-yields>`: every data-change operation"
" or network-access causes an implicit yield, and every statement that goes "
"through the Tarantool client causes an implicit yield."
msgstr ""
":ref:`неявная передача управления <atomic-implicit-yields>`: каждая операция"
" по изменению данных или доступ к сети вызывают неявную передачу управления,"
" а также каждое выражение, которое проходит через клиент Tarantool'а, "
"вызывает неявную передачу управления."

msgid ""
"explicit yields: in a Lua function, you can (and should) add :ref:`\"yield\""
" <fiber-yield>` statements to prevent hogging. This is called **cooperative "
"multitasking**."
msgstr ""
"явная передача управления: в Lua-функции можно (и нужно) добавить выражения "
":ref:`\"передачи управления\" <fiber-yield>` для предотвращения захвата ЦП. "
"Это называется **кооперативной многозадачностью**."

msgid "Cooperative multitasking"
msgstr "Кооперативная многозадачность"

msgid ""
"Cooperative multitasking means: unless a running fiber deliberately yields "
"control, it is not preempted by some other fiber. But a running fiber will "
"deliberately yield when it encounters a “yield point”: a transaction commit,"
" an operating system call, or an explicit :ref:`\"yield\" <fiber-yield>` "
"request. Any system call which can block will be performed asynchronously, "
"and any running fiber which must wait for a system call will be preempted, "
"so that another ready-to-run fiber takes its place and becomes the new "
"running fiber."
msgstr ""
"Кооперативная многозадачность означает, что если запущенный файбер намеренно"
" не передаст управление, он не вытесняется каким-либо другим файбером. Но "
"запущенный файбер намеренно передает управление, когда обнаруживает “точку "
"передачи управления”: коммит транзакции, вызов операционной системы или "
"запрос явной :ref:`\"передачи управления\" <fiber-yield>`. Любой вызов "
"системы, который может блокировать файбер, будет производиться асинхронно, а"
" запущенный файбер, который должен ожидать системного вызова, будет вытеснен"
" так, что другой готовый к работе файбер занимает его место и становится "
"запущенным файбером."

#, fuzzy
msgid ""
"This model makes all programmatic locks unnecessary: cooperative "
"multitasking ensures that there will be no concurrency around a resource, no"
" race conditions, and no memory consistency issues. The way to achieve this "
"is quite simple: in critical sections, don't use yields, explicit or "
"implicit, and no one can interfere into the code execution."
msgstr ""
"Эта модель исключает необходимость любых программных блокировок -- "
"кооперативная многозадачность обеспечивает отсутствие многопоточности вокруг"
" ресурса, состояния гонки и проблем с согласованностью данных."

msgid ""
"When requests are small, for example simple UPDATE or INSERT or DELETE or "
"SELECT, fiber scheduling is fair: it takes only a little time to process the"
" request, schedule a disk write, and yield to a fiber serving the next "
"client."
msgstr ""
"При небольших запросах, таких как простые UPDATE, INSERT, DELETE или SELECT,"
" происходит справедливое планирование файберов: немного времени требуется на"
" обработку запроса, планирование записи на диск и передачу управления на "
"файбер, обслуживающий следующего клиента."

msgid ""
"However, a function might perform complex computations or might be written "
"in such a way that yields do not occur for a long time. This can lead to "
"unfair scheduling, when a single client throttles the rest of the system, or"
" to apparent stalls in request processing. Avoiding this situation is the "
"responsibility of the function’s author."
msgstr ""
"Однако функция может выполнять сложные расчеты  или может быть написана так,"
" что управление не передается в течение длительного времени. Это может "
"привести к несправедливому планированию, когда отдельный клиент перекрывает "
"работу остальной системы, или к явным задержкам в обработке запросов. Автору"
" функции следует не допускать таких ситуаций."

msgid ""
"In the absence of transactions, any function that contains yield points may "
"see changes in the database state caused by fibers that preempt. Multi-"
"statement transactions exist to provide **isolation**: each transaction sees"
" a consistent database state and commits all its changes atomically. At "
":doc:`commit </reference/reference_lua/box_txn_management/commit>` time, a "
"yield happens and all transaction changes are written to the :ref:`write "
"ahead log <internals-wal>` in a single batch. Or, if needed, transaction "
"changes can be rolled back -- :doc:`completely "
"</reference/reference_lua/box_txn_management/rollback>` or to a specific "
":doc:`savepoint "
"</reference/reference_lua/box_txn_management/rollback_to_savepoint>`."
msgstr ""
"В отсутствие транзакций любая функция, в которой есть точки передачи "
"управления, может видеть изменения в состоянии базы данных, вызванные "
"вытесняющими файберами. Составные транзакции предназначены для **изоляции**:"
" каждая транзакция видит постоянное состояние базы данных и делает атомарные"
" коммиты изменений. Во время :doc:`коммита "
"</reference/reference_lua/box_txn_management/commit>` происходит передача "
"управления, а все транзакционные изменения записываются в :ref:`журнал "
"упреждающей записи <internals-wal>` в отдельный пакет. Или, при "
"необходимости, можно откатить изменения -- :doc:`полностью "
"</reference/reference_lua/box_txn_management/rollback>` или на определенную "
":doc:`точку сохраниения "
"</reference/reference_lua/box_txn_management/rollback_to_savepoint>`."

msgid ""
"In Tarantool, `transaction isolation level "
"<https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels>`_"
" is *serializable* with the clause \"if no failure during writing to WAL\". "
"In case of such a failure that can happen, for example, if the disk space is"
" over, the transaction isolation level becomes *read uncommitted*."
msgstr ""

#, fuzzy
msgid ""
"In :ref:`vynil <engines-chapter>`, to implement isolation Tarantool uses a "
"simple optimistic scheduler: the first transaction to commit wins. If a "
"concurrent active transaction has read a value modified by a committed "
"transaction, it is aborted."
msgstr ""
"Чтобы осуществить изоляцию, Tarantool использует простой планировщик с "
"оптимистичным управлением: транзакция подтверждена первой -- выигрывает. "
"Если параллельная активная транзакция читает значение, измененное "
"подтвержденной транзакцией, она прерывается."

msgid ""
"The cooperative scheduler ensures that, in absence of yields, a multi-"
"statement transaction is not preempted and hence is never aborted. "
"Therefore, understanding yields is essential to writing abort-free code."
msgstr ""
"Кооперативный планировщик обеспечивает, что в отсутствие передачи управления"
" составная транзакция не вытесняется, поэтому никогда не прерывается. Таким "
"образом, понимание передачи управления необходимо для написания кода без "
"прерываний."

msgid ""
"Sometimes while testing the transaction mechanism in Tarantool you can "
"notice that yielding after ``box.begin()`` but before any read/write "
"operation does not cause an abort as it should according to the description."
" This happens because actually ``box.begin()`` does not start a transaction."
" It is a mark telling Tarantool to start a transaction after some database "
"request that follows."
msgstr ""
"Иногда при тестировании механизма транзакций в Tarantool можно заметить, что"
" выдача после ``box.begin()``, но перед любой операцией чтения/записи не "
"приводит к прерыванию, как это должно происходить согласно описанию. Причина"
" в том, что на самом деле ``box.begin()`` не запускает транзакцию: это "
"просто метка, указывающая Tarantool запустить транзакцию после некоторого "
"запроса к базе данных, который следует за этим."

msgid ""
"In memtx, if an instruction that implies yields, explicit or implicit, is "
"executed during a transaction, the transaction is fully rolled back. In "
"vynil, we use more complex transactional manager that allows yields."
msgstr ""

msgid "You can’t mix storage engines in a transaction today."
msgstr "На сегодняшний день нельзя смешивать движки базы данных в транзакции."

msgid "Implicit yields"
msgstr "Правила неявной передачи управления"

msgid ""
"The only explicit yield requests in Tarantool are :ref:`fiber.sleep() "
"<fiber-sleep>` and :ref:`fiber.yield() <fiber-yield>`, but many other "
"requests \"imply\" yields because Tarantool is designed to avoid blocking."
msgstr ""
"Единственные запросы явной передачи данных в Tarantool'е отправляют "
":ref:`fiber.sleep() <fiber-sleep>` и :ref:`fiber.yield() <fiber-yield>`, но "
"многие другие запросы \"неявно\" подразумевают передачу управления, "
"поскольку цель Tarantool'а -- избежать блокировок."

#, fuzzy
msgid ""
"Database requests imply yields if and only if there is disk I/O. For memtx, "
"since all data is in memory, there is no disk I/O during a read request. For"
" vinyl, since some data may not be in memory, there may be disk I/O for a "
"read (to fetch data from disk) or for a write (because a stall may occur "
"while waiting for memory to be free). For both memtx and vinyl, since data-"
"change requests must be recorded in the WAL, there is normally a commit. A "
"commit happens automatically after every request in default \"autocommit\" "
"mode, or a commit happens at the end of a transaction in \"transaction\" "
"mode, when a user deliberately commits by calling "
":doc:`/reference/reference_lua/box_txn_management/commit`. Therefore for "
"both memtx and vinyl, because there can be disk I/O, some database "
"operations may imply yields."
msgstr ""
"Запросы к базе данных подразумевают передачу управления исключительно при "
"вводе-выводе с диска. В memtx'е нет дискового ввода-вывода во время запроса,"
" поскольку все данные находятся в памяти. Что же касается vinyl'а, то "
"некоторых данных может не быть в памяти, поэтому для чтения дисковый ввод-"
"вывод может использоваться для чтения (для извлечения данных с диска) или "
"для записи (потому что в ожидании освобождения памяти может произойти "
"задержка). Как для memtx'а, так и для vinyl'а обычно используются коммиты, "
"поскольку запросы на изменение данных должны быть записаны в WAL. В режиме "
"автокоммита по умолчанию коммиты производятся автоматически после каждого "
"запроса. В режиме транзакций коммит производится в конце транзакции, когда "
"пользователь специально совершает коммит, вызывая "
":doc:`/reference/reference_lua/box_txn_management/commit`. Поэтому как для "
"memtx'а, так и для vinyl'а некоторые операции с базой данных могут вызывать "
"передачу управления, поскольку может производиться дисковый ввод-вывод."

msgid ""
"Many functions in modules :ref:`fio <fio-section>`, :ref:`net_box <net_box-"
"module>`, :ref:`console <console-module>` and :ref:`socket <socket-module>` "
"(the \"os\" and \"network\" requests) yield."
msgstr ""
"Многие функции в модулях :ref:`fio <fio-section>`, :ref:`net_box <net_box-"
"module>`, :ref:`console <console-module>` и :ref:`socket <socket-module>` "
"(запросы \"ОС\" и \"сети\") передают управление."

msgid ""
"That is why executing separate commands such as ``select()``, ``insert()``, "
"``update()`` in the console inside a transaction will cause an abort. This "
"is due to implicit yield happening after each chunk of code is executed in "
"the console."
msgstr ""
"Поэтому выполнение отдельных команд, таких как ``select()``, ``insert()``, "
"``update()`` в консоли внутри транзакции, приведет к прерыванию транзакции. "
"Это связано с тем, что после выполнения каждого фрагмента кода в консоли "
"происходит неявная передача управления (yield)."

msgid "**Example #1**"
msgstr "**Пример №1**"

#, fuzzy
msgid ""
"*Engine = memtx* |br| The sequence ``select() insert()`` has one yield, at "
"the end of insertion, caused by implicit commit; ``select()`` has nothing to"
" write to the WAL and so does not yield."
msgstr ""
"*Движок = memtx* |br| В ``select() insert()`` управление передается один раз"
" в конце вставки, что вызвано неявным коммитом; ``select()`` ничего не "
"записывает в WAL-файл, поэтому не передает управление."

msgid ""
"*Engine = vinyl* |br| The sequence ``select() insert()`` has one to three "
"yields, since ``select()`` may yield if the data is not in cache, "
"``insert()`` may yield waiting for available memory, and there is an "
"implicit yield at commit."
msgstr ""

msgid ""
"The sequence ``begin() insert() insert() commit()`` yields only at commit if"
" the engine is memtx, and can yield up to 3 times if the engine is vinyl."
msgstr ""
"Последовательность ``begin() insert() insert() commit()`` передает "
"управление только при коммите, если движок -- memtx, и может передавать "
"управление до 3 раз, если движок -- vinyl."

msgid "**Example #2**"
msgstr "**Пример №2**"

#, fuzzy
msgid ""
"Assume that in the memtx space ‘tester’ there are tuples in which the third "
"field represents a positive dollar amount. Let's start a transaction, "
"withdraw from tuple#1, deposit in tuple#2, and end the transaction, making "
"its effects permanent."
msgstr ""
"Предположим, что в спейсе ‘tester’ существуют кортежи, третье поле которых "
"представляет собой положительную сумму в долларах. Начнем транзакцию, снимем"
" сумму из кортежа №1, внесем ее в кортеж №2 и завершим транзакцию, "
"подтверждая изменения."

msgid ""
"tarantool> function txn_example(from, to, amount_of_money)\n"
"         >   box.begin()\n"
"         >   box.space.tester:update(from, {{'-', 3, amount_of_money}})\n"
"         >   box.space.tester:update(to,   {{'+', 3, amount_of_money}})\n"
"         >   box.commit()\n"
"         >   return \"ok\"\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> txn_example({999}, {1000}, 1.00)\n"
"---\n"
"- \"ok\"\n"
"..."
msgstr ""
"tarantool> function txn_example(from, to, amount_of_money)\n"
"         >   box.begin()\n"
"         >   box.space.tester:update(from, {{'-', 3, amount_of_money}})\n"
"         >   box.space.tester:update(to,   {{'+', 3, amount_of_money}})\n"
"         >   box.commit()\n"
"         >   return \"ok\"\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> txn_example({999}, {1000}, 1.00)\n"
"---\n"
"- \"ok\"\n"
"..."

msgid ""
"If :ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>` = ‘none’, then "
"implicit yielding at commit time does not take place, because there are no "
"writes to the WAL."
msgstr ""
"Если :ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>` = ‘none’, то "
"при коммите управление не передается неявно, потому что не идет запись в "
"WAL-файл."

#, fuzzy
msgid ""
"If a task is interactive -- sending requests to the server and receiving "
"responses -- then it involves network I/O, and therefore there is an "
"implicit yield, even if the request that is sent to the server is not itself"
" an implicit yield request. Therefore, the following sequence"
msgstr ""
"Если задача интерактивная -- отправка запроса на сервер и получение ответа "
"-- то она включает в себя сетевой ввод-вывод, поэтому наблюдается неявная "
"передача управления, даже если отправляемый на сервер запрос не представляет"
" собой запрос с неявной передачей управления. Таким образом, "
"последовательность:"

msgid ""
"conn.space.test:select{1}\n"
"conn.space.test:select{2}\n"
"conn.space.test:select{3}"
msgstr ""

msgid ""
"causes yields three times sequentially when sending requests to the network "
"and awaiting the results. On the server side, the same requests are executed"
" in common order possibly mixing with other requests from the network and "
"local fibers. Something similar happens when using clients that operate via "
"telnet, via one of the connectors, or via the :ref:`MySQL and PostgreSQL "
"rocks <dbms_modules>`, or via the interactive mode when :ref:`using "
"Tarantool as a client <admin-using_tarantool_as_a_client>`."
msgstr ""

msgid ""
"After a fiber has yielded and then has regained control, it immediately "
"issues :ref:`testcancel <fiber-testcancel>`."
msgstr ""
"После того, как файбер передал управление, а затем вернул его, он "
"незамедлительно вызывает :ref:`testcancel <fiber-testcancel>`."

#~ msgid ""
#~ "If we issue the query on a remote client, then the **network thread** on the"
#~ " server side receives the query, parses the statement and changes it to a "
#~ "server executable message which has already been checked, and which the "
#~ "server instance can understand without parsing everything again."
#~ msgstr ""
#~ "Если мы передадим запрос на удаленный клиент, **сетевой поток** на стороне "
#~ "сервера получит запрос, разберет выражение и преобразует его в выполняемое "
#~ "сообщение сервера, которое уже проверено. Такое сообщение экземпляр сервера "
#~ "может понимать без повторного разбора."

#~ msgid ""
#~ "*Engine = vinyl* |br| ``select() insert()`` has between one and three "
#~ "yields, since ``select()`` may yield if the data is not in cache, "
#~ "``insert()`` may yield waiting for available memory, and there is an "
#~ "implicit yield at commit."
#~ msgstr ""
#~ "*Движок = vinyl* |br| В ``select() insert()`` управление передается от "
#~ "одного до трех раз, поскольку ``select()`` может передавать управление, если"
#~ " данные не находятся в кэше, ``insert()`` может передавать управление в "
#~ "ожидании свободной памяти, а при коммите управление передается неявно."

#~ msgid ""
#~ "select\n"
#~ "select\n"
#~ "select"
#~ msgstr ""
#~ "select\n"
#~ "select\n"
#~ "select"

#~ msgid ""
#~ "causes blocking (in memtx), if it is inside a function or Lua program being "
#~ "executed on the server instance, but causes yielding (in both memtx and "
#~ "vinyl) if it is done as a series of transmissions from a client, including a"
#~ " client which operates via telnet, via one of the connectors, or via the "
#~ ":ref:`MySQL and PostgreSQL rocks <dbms_modules>`, or via the interactive "
#~ "mode when :ref:`using Tarantool as a client <admin-"
#~ "using_tarantool_as_a_client>`."
#~ msgstr ""
#~ "приводит к блокировке (в memtx'е), если находится внутри функции или Lua-"
#~ "программы, которая выполняется на экземпляре сервера. Однако она вызывает "
#~ "передачу управления (и в memtx'е, и в vinyl'е), если выполняется как серия "
#~ "передач от клиента, включая клиентов, работающих по telnet, по одному из "
#~ "коннекторов или :ref:`модулей MySQL и PostgreSQL <dbms_modules>` или в "
#~ "интерактивном режиме при :ref:`использовании Tarantool'а как клиента <admin-"
#~ "using_tarantool_as_a_client>`."
