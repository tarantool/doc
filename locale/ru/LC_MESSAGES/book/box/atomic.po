
msgid "Transactions"
msgstr "Транзакции"

msgid ""
"Transactions in Tarantool occur in **fibers** on a single **thread**. "
"That is why Tarantool has a guarantee of execution atomicity. That "
"requires emphasis."
msgstr ""
"Транзакции в Tarantool'е происходят в **файберах** в одном **потоке**. "
"Вот почему Tarantool дает гарантию атомарности выполнения. На этом "
"следует сделать акцент."

msgid "Threads, fibers and yields"
msgstr "Потоки, файберы и передача управления"

msgid ""
"How does Tarantool process a basic operation? As an example, let's take "
"this query:"
msgstr ""
"Как Tarantool выполняет основные операции? Для примера возьмем такой "
"запрос:"

msgid "tarantool> box.space.tester:update({3}, {{'=', 2, 'size'}, {'=', 3, 0}})"
msgstr "tarantool> box.space.tester:update({3}, {{'=', 2, 'size'}, {'=', 3, 0}})"

msgid ""
"This is equivalent to the following SQL statement for a table that stores"
" primary keys in ``field[1]``:"
msgstr ""
"Это эквивалентно следующему SQL-выражению (оно работает с таблицей, где "
"первичные ключи в ``field[1]``):"

msgid ""
"UPDATE tester SET \"field[2]\" = 'size', \"field[3]\" = 0 WHERE "
"\"field[1]\" = 3"
msgstr ""
"UPDATE tester SET \"field[2]\" = 'size', \"field[3]\" = 0 WHERE "
"\"field[1]\" = 3"

#, fuzzy
msgid ""
"Assuming this query is received by Tarantool via network, it will be "
"processed with three operating system **threads**:"
msgstr "Этот запрос будет обработан тремя **потоками** операционной системы:"

msgid ""
"The **network thread** on the server side receives the query, parses the "
"statement, checks if it's correct, and then transforms it into a special "
"structure--a message containing an executable statement and its options."
msgstr ""

msgid ""
"The network thread ships this message to the instance's **transaction "
"processor thread** using a lock-free message bus. Lua programs execute "
"directly in the transaction processor thread, and do not require parsing "
"and preparation."
msgstr ""
"Сетевой поток отправляет это сообщение в **поток обработки транзакций** с"
" помощью шины передачи сообщений без блокировок. Lua-программы "
"выполняются непосредственно в потоке обработки транзакций и не требуют "
"разбора и подготовки."

#, fuzzy
msgid ""
"The instance's transaction processor thread uses the primary-key index on"
" field[1] to find the location of the tuple. It determines that the tuple"
" can be updated (not much can go wrong when you're merely changing an "
"unindexed field value)."
msgstr ""
"Поток обработки транзакций экземпляра использует индекс на поле "
"первичного ключа field[1], чтобы найти нужный кортеж. Он проверяет, что "
"данный кортеж можно обновить (мы хотим лишь изменить значение не "
"индексированного поля на более короткое, и вряд ли что-то пойдет не так)."

#, fuzzy
msgid ""
"The transaction processor thread sends a message to the :ref:`write-ahead"
" logging (WAL) thread <internals-wal>` to commit the transaction. When "
"done, the WAL thread replies with a COMMIT or ROLLBACK result to the "
"transaction processor which gives it back to the network thread, and the "
"network thread returns the result to the client."
msgstr ""
"Поток обработки транзакций отправляет сообщение в :ref:`поток упреждающей"
" записи в журнал (WAL) <internals-wal>` для коммита транзакции. По "
"завершении поток WAL отправляет ответ с результатом COMMIT (коммит) или "
"ROLLBACK (откат) на клиент."

msgid ""
"Notice that there is only one transaction processor thread in Tarantool. "
"Some people are used to the idea that there can be multiple threads "
"operating on the database, with (say) thread #1 reading row #x, while "
"thread #2 writes row #y. With Tarantool, no such thing ever happens. Only"
" the transaction processor thread can access the database, and there is "
"only one transaction processor thread for each Tarantool instance."
msgstr ""
"Обратите внимание, что в Tarantool'е есть только один поток обработки "
"транзакций. Некоторые уже привыкли к мысли, что потоков для обработки "
"данных в базе данных может быть много (например, поток №1 читает данные "
"из строки №x, в то время как поток №2 записывает данные в столбец №y). В "
"случае с Tarantool'ом такого не происходит. Доступ к базе есть только у "
"потока обработки транзакций, и на  каждый экземпляр Tarantool'а есть "
"только один такой поток."

msgid ""
"Like any other Tarantool thread, the transaction processor thread can "
"handle many :ref:`fibers <fiber-fibers>`. A fiber is a set of computer "
"instructions that may contain \"**yield**\" signals. The transaction "
"processor thread will execute all computer instructions until a yield, "
"then switch to execute the instructions of a different fiber. Thus (say) "
"the thread reads row #x for the sake of fiber #1, then writes row #y for "
"the sake of fiber #2."
msgstr ""
"Как и любой другой поток Tarantool'а, поток обработки транзакций может "
"управлять множеством :ref:`файберов <fiber-fibers>`. Файбер -- это набор "
"команд, среди которых могут быть и сигналы \"**передачи управления**\". "
"Поток обработки транзакций выполняет все команды, пока не увидит такой "
"сигнал, и тогда он переключается на выполнение команд из другого файбера."
" Например, таким образом поток обработки транзакций сначала выполняет "
"чтение данных из строки №x для файбера №1, а затем выполняет запись в "
"строку №y для файбера №2."

msgid ""
"Yields must happen, otherwise the transaction processor thread would "
"stick permanently on the same fiber. There are two types of yields:"
msgstr ""
"Передача управления необходима, в противном случае, поток обработки "
"транзакции заклинит на одном файбере. Есть два типа передачи управления:"

msgid ""
":ref:`implicit yields <atomic-implicit-yields>`: every data-change "
"operation or network-access causes an implicit yield, and every statement"
" that goes through the Tarantool client causes an implicit yield."
msgstr ""
":ref:`неявная передача управления <atomic-implicit-yields>`: каждая "
"операция по изменению данных или доступ к сети вызывают неявную передачу "
"управления, а также каждое выражение, которое проходит через клиент "
"Tarantool'а, вызывает неявную передачу управления."

msgid ""
"explicit yields: in a Lua function, you can (and should) add "
":ref:`\"yield\" <fiber-yield>` statements to prevent hogging. This is "
"called **cooperative multitasking**."
msgstr ""
"явная передача управления: в Lua-функции можно (и нужно) добавить "
"выражения :ref:`\"передачи управления\" <fiber-yield>` для предотвращения"
" захвата ЦП. Это называется **кооперативной многозадачностью**."

msgid "Cooperative multitasking"
msgstr "Кооперативная многозадачность"

msgid ""
"Cooperative multitasking means: unless a running fiber deliberately "
"yields control, it is not preempted by some other fiber. But a running "
"fiber will deliberately yield when it encounters a “yield point”: a "
"transaction commit, an operating system call, or an explicit "
":ref:`\"yield\" <fiber-yield>` request. Any system call which can block "
"will be performed asynchronously, and any running fiber which must wait "
"for a system call will be preempted, so that another ready-to-run fiber "
"takes its place and becomes the new running fiber."
msgstr ""
"Кооперативная многозадачность означает, что если запущенный файбер "
"намеренно не передаст управление, он не вытесняется каким-либо другим "
"файбером. Но запущенный файбер намеренно передает управление, когда "
"обнаруживает “точку передачи управления”: коммит транзакции, вызов "
"операционной системы или запрос явной :ref:`\"передачи управления\" "
"<fiber-yield>`. Любой вызов системы, который может блокировать файбер, "
"будет производиться асинхронно, а запущенный файбер, который должен "
"ожидать системного вызова, будет вытеснен так, что другой готовый к "
"работе файбер занимает его место и становится запущенным файбером."

#, fuzzy
msgid ""
"This model makes all programmatic locks unnecessary: cooperative "
"multitasking ensures that there will be no concurrency around a resource,"
" no race conditions, and no memory consistency issues. The way to achieve"
" this is quite simple: in critical sections, don't use yields, explicit "
"or implicit, and no one can interfere into the code execution."
msgstr ""
"Эта модель исключает необходимость любых программных блокировок -- "
"кооперативная многозадачность обеспечивает отсутствие многопоточности "
"вокруг ресурса, состояния гонки и проблем с согласованностью данных."

msgid ""
"When requests are small, for example simple UPDATE or INSERT or DELETE or"
" SELECT, fiber scheduling is fair: it takes only a little time to process"
" the request, schedule a disk write, and yield to a fiber serving the "
"next client."
msgstr ""
"При небольших запросах, таких как простые UPDATE, INSERT, DELETE или "
"SELECT, происходит справедливое планирование файберов: немного времени "
"требуется на обработку запроса, планирование записи на диск и передачу "
"управления на файбер, обслуживающий следующего клиента."

msgid ""
"However, a function might perform complex computations or might be "
"written in such a way that yields do not occur for a long time. This can "
"lead to unfair scheduling, when a single client throttles the rest of the"
" system, or to apparent stalls in request processing. Avoiding this "
"situation is the responsibility of the function’s author."
msgstr ""
"Однако функция может выполнять сложные расчеты  или может быть написана "
"так, что управление не передается в течение длительного времени. Это "
"может привести к несправедливому планированию, когда отдельный клиент "
"перекрывает работу остальной системы, или к явным задержкам в обработке "
"запросов. Автору функции следует не допускать таких ситуаций."

msgid ""
"In the absence of transactions, any function that contains yield points "
"may see changes in the database state caused by fibers that preempt. "
"Multi-statement transactions exist to provide **isolation**: each "
"transaction sees a consistent database state and commits all its changes "
"atomically. At :ref:`commit <box-commit>` time, a yield happens and all "
"transaction changes are written to the :ref:`write ahead log <internals-"
"wal>` in a single batch. Or, if needed, transaction changes can be rolled"
" back -- :ref:`completely <box-rollback>` or to a specific "
":ref:`savepoint <box-rollback_to_savepoint>`."
msgstr ""
"В отсутствие транзакций любая функция, в которой есть точки передачи "
"управления, может видеть изменения в состоянии базы данных, вызванные "
"вытесняющими файберами. Составные транзакции предназначены для "
"**изоляции**: каждая транзакция видит постоянное состояние базы данных и "
"делает атомарные коммиты изменений. Во время :ref:`коммита <box-commit>` "
"происходит передача управления, а все транзакционные изменения "
"записываются в :ref:`журнал упреждающей записи <internals-wal>` в "
"отдельный пакет. Или, при необходимости, можно откатить изменения -- "
":ref:`полностью <box-rollback>` или на определенную :ref:`точку "
"сохранения <box-rollback_to_savepoint>`."

msgid ""
"In Tarantool, `transaction isolation level "
"<https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels>`_"
" is *serializable* with the clause \"if no failure during writing to "
"WAL\". In case of such a failure that can happen, for example, if the "
"disk space is over, the transaction isolation level becomes *read "
"uncommitted*."
msgstr ""

#, fuzzy
msgid ""
"In :ref:`vinyl <engines-chapter>`, to implement isolation Tarantool uses "
"a simple optimistic scheduler: the first transaction to commit wins. If a"
" concurrent active transaction has read a value modified by a committed "
"transaction, it is aborted."
msgstr ""
"Чтобы осуществить изоляцию, Tarantool использует простой планировщик с "
"оптимистичным управлением: транзакция подтверждена первой -- выигрывает. "
"Если параллельная активная транзакция читает значение, измененное "
"подтвержденной транзакцией, она прерывается."

msgid ""
"The cooperative scheduler ensures that, in absence of yields, a multi-"
"statement transaction is not preempted and hence is never aborted. "
"Therefore, understanding yields is essential to writing abort-free code."
msgstr ""
"Кооперативный планировщик обеспечивает, что в отсутствие передачи "
"управления составная транзакция не вытесняется, поэтому никогда не "
"прерывается. Таким образом, понимание передачи управления необходимо для "
"написания кода без прерываний."

msgid ""
"Sometimes while testing the transaction mechanism in Tarantool you can "
"notice that yielding after ``box.begin()`` but before any read/write "
"operation does not cause an abort as it should according to the "
"description. This happens because actually ``box.begin()`` does not start"
" a transaction. It is a mark telling Tarantool to start a transaction "
"after some database request that follows."
msgstr ""
"Иногда при тестировании механизма транзакций в Tarantool можно заметить, "
"что выдача после ``box.begin()``, но перед любой операцией чтения/записи "
"не приводит к прерыванию, как это должно происходить согласно описанию. "
"Причина в том, что на самом деле ``box.begin()`` не запускает транзакцию:"
" это просто метка, указывающая Tarantool запустить транзакцию после "
"некоторого запроса к базе данных, который следует за этим."

msgid ""
"In memtx, if an instruction that implies yields, explicit or implicit, is"
" executed during a transaction, the transaction is fully rolled back. In "
"vinyl, we use more complex transactional manager that allows yields."
msgstr ""

msgid "You can’t mix storage engines in a transaction today."
msgstr "На сегодняшний день нельзя смешивать движки базы данных в транзакции."

msgid "Implicit yields"
msgstr "Правила неявной передачи управления"

msgid ""
"The only explicit yield requests in Tarantool are :ref:`fiber.sleep() "
"<fiber-sleep>` and :ref:`fiber.yield() <fiber-yield>`, but many other "
"requests \"imply\" yields because Tarantool is designed to avoid "
"blocking."
msgstr ""
"Единственные запросы явной передачи данных в Tarantool'е отправляют "
":ref:`fiber.sleep() <fiber-sleep>` и :ref:`fiber.yield() <fiber-yield>`, "
"но многие другие запросы \"неявно\" подразумевают передачу управления, "
"поскольку цель Tarantool'а -- избежать блокировок."

#, fuzzy
msgid ""
"Database requests imply yields if and only if there is disk I/O. For "
"memtx, since all data is in memory, there is no disk I/O during a read "
"request. For vinyl, since some data may not be in memory, there may be "
"disk I/O for a read (to fetch data from disk) or for a write (because a "
"stall may occur while waiting for memory to be free). For both memtx and "
"vinyl, since data-change requests must be recorded in the WAL, there is "
"normally a commit. A commit happens automatically after every request in "
"default \"autocommit\" mode, or a commit happens at the end of a "
"transaction in \"transaction\" mode, when a user deliberately commits by "
"calling :ref:`box.commit() <box-commit>`. Therefore for both memtx and "
"vinyl, because there can be disk I/O, some database operations may imply "
"yields."
msgstr ""
"Запросы к базе данных подразумевают передачу управления исключительно при"
" вводе-выводе с диска. В memtx'е нет дискового ввода-вывода во время "
"запроса, поскольку все данные находятся в памяти. Что же касается "
"vinyl'а, то некоторых данных может не быть в памяти, поэтому для чтения "
"дисковый ввод-вывод может использоваться для чтения (для извлечения "
"данных с диска) или для записи (потому что в ожидании освобождения памяти"
" может произойти задержка). Как для memtx'а, так и для vinyl'а обычно "
"используются коммиты, поскольку запросы на изменение данных должны быть "
"записаны в WAL. В режиме автокоммита по умолчанию коммиты производятся "
"автоматически после каждого запроса. В режиме транзакций коммит "
"производится в конце транзакции, когда пользователь специально совершает "
"коммит, вызывая :ref:`box.commit() <box-commit>`. Поэтому как для "
"memtx'а, так и для vinyl'а некоторые операции с базой данных могут "
"вызывать передачу управления, поскольку может производиться дисковый "
"ввод-вывод."

msgid ""
"Many functions in modules :ref:`fio <fio-section>`, :ref:`net_box "
"<net_box-module>`, :ref:`console <console-module>` and :ref:`socket "
"<socket-module>` (the \"os\" and \"network\" requests) yield."
msgstr ""
"Многие функции в модулях :ref:`fio <fio-section>`, :ref:`net_box "
"<net_box-module>`, :ref:`console <console-module>` и :ref:`socket "
"<socket-module>` (запросы \"ОС\" и \"сети\") передают управление."

msgid ""
"That is why executing separate commands such as ``select()``, "
"``insert()``, ``update()`` in the console inside a transaction will cause"
" an abort. This is due to implicit yield happening after each chunk of "
"code is executed in the console."
msgstr ""
"Поэтому выполнение отдельных команд, таких как ``select()``, "
"``insert()``, ``update()`` в консоли внутри транзакции, приведет к "
"прерыванию транзакции. Это связано с тем, что после выполнения каждого "
"фрагмента кода в консоли происходит неявная передача управления (yield)."

msgid "**Example #1**"
msgstr "**Пример №1**"

#, fuzzy
msgid ""
"*Engine = memtx* |br| The sequence ``select() insert()`` has one yield, "
"at the end of insertion, caused by implicit commit; ``select()`` has "
"nothing to write to the WAL and so does not yield."
msgstr ""
"*Движок = memtx* |br| В ``select() insert()`` управление передается один "
"раз в конце вставки, что вызвано неявным коммитом; ``select()`` ничего не"
" записывает в WAL-файл, поэтому не передает управление."

msgid ""
"*Engine = vinyl* |br| The sequence ``select() insert()`` has one to three"
" yields, since ``select()`` may yield if the data is not in cache, "
"``insert()`` may yield waiting for available memory, and there is an "
"implicit yield at commit."
msgstr ""

msgid ""
"The sequence ``begin() insert() insert() commit()`` yields only at commit"
" if the engine is memtx, and can yield up to 3 times if the engine is "
"vinyl."
msgstr ""
"Последовательность ``begin() insert() insert() commit()`` передает "
"управление только при коммите, если движок -- memtx, и может передавать "
"управление до 3 раз, если движок -- vinyl."

msgid "**Example #2**"
msgstr "**Пример №2**"

#, fuzzy
msgid ""
"Assume that in the memtx space ‘tester’ there are tuples in which the "
"third field represents a positive dollar amount. Let's start a "
"transaction, withdraw from tuple#1, deposit in tuple#2, and end the "
"transaction, making its effects permanent."
msgstr ""
"Предположим, что в спейсе ‘tester’ существуют кортежи, третье поле "
"которых представляет собой положительную сумму в долларах. Начнем "
"транзакцию, снимем сумму из кортежа №1, внесем ее в кортеж №2 и завершим "
"транзакцию, подтверждая изменения."

msgid ""
"tarantool> function txn_example(from, to, amount_of_money)\n"
"         >   box.begin()\n"
"         >   box.space.tester:update(from, {{'-', 3, amount_of_money}})\n"
"         >   box.space.tester:update(to,   {{'+', 3, amount_of_money}})\n"
"         >   box.commit()\n"
"         >   return \"ok\"\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> txn_example({999}, {1000}, 1.00)\n"
"---\n"
"- \"ok\"\n"
"..."
msgstr ""
"tarantool> function txn_example(from, to, amount_of_money)\n"
"         >   box.begin()\n"
"         >   box.space.tester:update(from, {{'-', 3, amount_of_money}})\n"
"         >   box.space.tester:update(to,   {{'+', 3, amount_of_money}})\n"
"         >   box.commit()\n"
"         >   return \"ok\"\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> txn_example({999}, {1000}, 1.00)\n"
"---\n"
"- \"ok\"\n"
"..."

msgid ""
"If :ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>` = ‘none’, then"
" implicit yielding at commit time does not take place, because there are "
"no writes to the WAL."
msgstr ""
"Если :ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>` = ‘none’, то"
" при коммите управление не передается неявно, потому что не идет запись в"
" WAL-файл."

#, fuzzy
msgid ""
"If a task is interactive -- sending requests to the server and receiving "
"responses -- then it involves network I/O, and therefore there is an "
"implicit yield, even if the request that is sent to the server is not "
"itself an implicit yield request. Therefore, the following sequence"
msgstr ""
"Если задача интерактивная -- отправка запроса на сервер и получение "
"ответа -- то она включает в себя сетевой ввод-вывод, поэтому наблюдается "
"неявная передача управления, даже если отправляемый на сервер запрос не "
"представляет собой запрос с неявной передачей управления. Таким образом, "
"последовательность:"

msgid ""
"conn.space.test:select{1}\n"
"conn.space.test:select{2}\n"
"conn.space.test:select{3}"
msgstr ""

msgid ""
"causes yields three times sequentially when sending requests to the "
"network and awaiting the results. On the server side, the same requests "
"are executed in common order possibly mixing with other requests from the"
" network and local fibers. Something similar happens when using clients "
"that operate via telnet, via one of the connectors, or via the "
":ref:`MySQL and PostgreSQL rocks <dbms_modules>`, or via the interactive "
"mode when :ref:`using Tarantool as a client <admin-"
"using_tarantool_as_a_client>`."
msgstr ""

msgid ""
"After a fiber has yielded and then has regained control, it immediately "
"issues :ref:`testcancel <fiber-testcancel>`."
msgstr ""
"После того, как файбер передал управление, а затем вернул его, он "
"незамедлительно вызывает :ref:`testcancel <fiber-testcancel>`."

#, fuzzy
msgid "Transactional manager"
msgstr "Транзакции"

msgid ""
"Since version 2.6.1, Tarantool has another option for transaction "
"behavior that allows yielding inside a memtx transaction. This is "
"controled by the *transactional manager*."
msgstr ""

msgid ""
"The transactional manager is designed for isolation of concurrent "
"transactions and provides *serializable* `transaction isolation level "
"<https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels>`_."
" It consists of two parts:"
msgstr ""

msgid "*MVCC engine*"
msgstr ""

msgid "*conflict manager*."
msgstr ""

msgid ""
"The MVCC engine provides personal read views for transactions if "
"necessary. The conflict manager tracks transactions' changes and "
"determines their correctness in serialization order. Of course, once "
"yielded, a transaction could interfere with other transactions and could "
"be aborted due to conflict."
msgstr ""

msgid ""
"Another important thing to mention is that the transaction manager "
"provides non-classic snapshot isolation level. It means that a "
"transaction can get a consistent snapshot of the database (that is "
"common) but this snapshot is not necessarily bound to the moment of the "
"beginning of the transaction (that is not common). The conflict manager "
"makes decisions on whether and when each transaction gets which snapshot."
" That allows to avoid some conflicts comparing with classical snapshot "
"isolation approach."
msgstr ""

msgid ""
"The transactional manager can be switched on and off by the ``box.cfg`` "
"option :ref:`memtx_use_mvcc_engine <cfg_basic-memtx_use_mvcc_engine>`."
msgstr ""

#~ msgid ""
#~ "If we issue the query on a "
#~ "remote client, then the **network "
#~ "thread** on the server side receives "
#~ "the query, parses the statement and "
#~ "changes it to a server executable "
#~ "message which has already been checked,"
#~ " and which the server instance can"
#~ " understand without parsing everything "
#~ "again."
#~ msgstr ""
#~ "Если мы передадим запрос на удаленный"
#~ " клиент, **сетевой поток** на стороне "
#~ "сервера получит запрос, разберет выражение "
#~ "и преобразует его в выполняемое "
#~ "сообщение сервера, которое уже проверено. "
#~ "Такое сообщение экземпляр сервера может "
#~ "понимать без повторного разбора."

#~ msgid ""
#~ "*Engine = vinyl* |br| ``select() "
#~ "insert()`` has between one and three "
#~ "yields, since ``select()`` may yield if"
#~ " the data is not in cache, "
#~ "``insert()`` may yield waiting for "
#~ "available memory, and there is an "
#~ "implicit yield at commit."
#~ msgstr ""
#~ "*Движок = vinyl* |br| В ``select() "
#~ "insert()`` управление передается от одного "
#~ "до трех раз, поскольку ``select()`` "
#~ "может передавать управление, если данные "
#~ "не находятся в кэше, ``insert()`` может"
#~ " передавать управление в ожидании свободной"
#~ " памяти, а при коммите управление "
#~ "передается неявно."

#~ msgid ""
#~ "select\n"
#~ "select\n"
#~ "select"
#~ msgstr ""
#~ "select\n"
#~ "select\n"
#~ "select"

#~ msgid ""
#~ "causes blocking (in memtx), if it "
#~ "is inside a function or Lua "
#~ "program being executed on the server "
#~ "instance, but causes yielding (in both"
#~ " memtx and vinyl) if it is done"
#~ " as a series of transmissions from"
#~ " a client, including a client which"
#~ " operates via telnet, via one of "
#~ "the connectors, or via the :ref:`MySQL"
#~ " and PostgreSQL rocks <dbms_modules>`, or"
#~ " via the interactive mode when "
#~ ":ref:`using Tarantool as a client "
#~ "<admin-using_tarantool_as_a_client>`."
#~ msgstr ""
#~ "приводит к блокировке (в memtx'е), если"
#~ " находится внутри функции или "
#~ "Lua-программы, которая выполняется на "
#~ "экземпляре сервера. Однако она вызывает "
#~ "передачу управления (и в memtx'е, и "
#~ "в vinyl'е), если выполняется как серия"
#~ " передач от клиента, включая клиентов, "
#~ "работающих по telnet, по одному из "
#~ "коннекторов или :ref:`модулей MySQL и "
#~ "PostgreSQL <dbms_modules>` или в интерактивном"
#~ " режиме при :ref:`использовании Tarantool'а "
#~ "как клиента <admin-using_tarantool_as_a_client>`."
