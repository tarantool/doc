
msgid "Transactions"
msgstr "Транзакции"

msgid ""
"Transactions in Tarantool occur in **fibers** on a single **thread**. That "
"is why Tarantool has a guarantee of execution atomicity. That requires "
"emphasis."
msgstr ""
"Транзакции в Tarantool'е происходят в **файберах** в одном **потоке**. Вот "
"почему Tarantool дает гарантию атомарности выполнения. На этом следует "
"сделать акцент."

msgid "Threads, fibers and yields"
msgstr "Потоки, файберы и передача управления"

msgid ""
"How does Tarantool process a basic operation? As an example, let's take this"
" query:"
msgstr ""
"Как Tarantool выполняет основные операции? Для примера возьмем такой запрос:"

msgid ""
"tarantool> box.space.tester:update({3}, {{'=', 2, 'size'}, {'=', 3, 0}})"
msgstr ""
"tarantool> box.space.tester:update({3}, {{'=', 2, 'size'}, {'=', 3, 0}})"

msgid ""
"This is equivalent to the following SQL statement for a table that stores "
"primary keys in ``field[1]``:"
msgstr ""
"Это эквивалентно следующему SQL-выражению (оно работает с таблицей, где "
"первичные ключи в ``field[1]``):"

msgid "UPDATE tester SET \"field[2]\" = 'size', \"field[3]\" = 0 WHERE \"field[1]\" = 3"
msgstr "UPDATE tester SET \"field[2]\" = 'size', \"field[3]\" = 0 WHERE \"field[1]\" = 3"

msgid ""
"Assuming this query is received by Tarantool via network, it will be "
"processed with three operating system **threads**:"
msgstr ""
"Предположим, что этот запрос Tarantool получил по сети, — тогда три "
"**потока** операционной системы будут обрабатывать этот запрос:"

msgid ""
"The **network thread** on the server side receives the query, parses the "
"statement, checks if it's correct, and then transforms it into a special "
"structure--a message containing an executable statement and its options."
msgstr ""
"**Сетевой поток** на стороне сервера получает запрос, разбирает выражение, "
"проверяет его на правильность и преобразует его в специальную структуру — "
"сообщение, которое содержит готовый для исполнения запрос и его опции."

msgid ""
"The network thread ships this message to the instance's **transaction "
"processor thread** using a lock-free message bus. Lua programs execute "
"directly in the transaction processor thread, and do not require parsing and"
" preparation."
msgstr ""
"Сетевой поток отправляет это сообщение в **поток обработки транзакций** с "
"помощью шины передачи сообщений без блокировок. Lua-программы выполняются "
"непосредственно в потоке обработки транзакций и не требуют разбора и "
"подготовки."

msgid ""
"The instance's transaction processor thread uses the primary-key index on "
"field[1] to find the location of the tuple. It determines that the tuple can"
" be updated (not much can go wrong when you're merely changing an unindexed "
"field value)."
msgstr ""
"Чтобы найти нужный кортеж, поток обработки транзакций использует индекс на "
"поле первичного ключа field[1]. Он проверяет, что этот кортеж можно обновить"
" (вряд ли что-то пойдет не так, если мы всего лишь меняем значение не "
"индексированного поля)."

msgid ""
"The transaction processor thread sends a message to the :ref:`write-ahead "
"logging (WAL) thread <internals-wal>` to commit the transaction. When done, "
"the WAL thread replies with a COMMIT or ROLLBACK result to the transaction "
"processor which gives it back to the network thread, and the network thread "
"returns the result to the client."
msgstr ""
"Поток обработки транзакций отправляет сообщение в :ref:`поток упреждающей "
"записи в журнал (WAL) <internals-wal>` для коммита транзакции. По завершении"
" поток WAL отправляет результат транзакции — COMMIT или ROLLBACK — в поток "
"обработки транзакций, который передает его сетевому потоку, а тот возвращает"
" результат клиенту."

msgid ""
"Notice that there is only one transaction processor thread in Tarantool. "
"Some people are used to the idea that there can be multiple threads "
"operating on the database, with (say) thread #1 reading row #x, while thread"
" #2 writes row #y. With Tarantool, no such thing ever happens. Only the "
"transaction processor thread can access the database, and there is only one "
"transaction processor thread for each Tarantool instance."
msgstr ""
"Обратите внимание, что в Tarantool'е есть только один поток обработки "
"транзакций. Некоторые уже привыкли к мысли, что потоков для обработки данных"
" в базе данных может быть много (например, поток №1 читает данные из строки "
"№x, в то время как поток №2 записывает данные в столбец №y). В случае с "
"Tarantool'ом такого не происходит. Доступ к базе есть только у потока "
"обработки транзакций, и на  каждый экземпляр Tarantool'а есть только один "
"такой поток."

msgid ""
"Like any other Tarantool thread, the transaction processor thread can handle"
" many :ref:`fibers <fiber-fibers>`. A fiber is a set of computer "
"instructions that may contain \"**yield**\" signals. The transaction "
"processor thread will execute all computer instructions until a yield, then "
"switch to execute the instructions of a different fiber. Thus (say) the "
"thread reads row #x for the sake of fiber #1, then writes row #y for the "
"sake of fiber #2."
msgstr ""
"Как и любой другой поток Tarantool'а, поток обработки транзакций может "
"управлять множеством :ref:`файберов <fiber-fibers>`. Файбер -- это набор "
"команд, среди которых могут быть и сигналы \"**передачи управления**\". "
"Поток обработки транзакций выполняет все команды, пока не увидит такой "
"сигнал, и тогда он переключается на выполнение команд из другого файбера. "
"Например, таким образом поток обработки транзакций сначала выполняет чтение "
"данных из строки №x для файбера №1, а затем выполняет запись в строку №y для"
" файбера №2."

msgid ""
"Yields must happen, otherwise the transaction processor thread would stick "
"permanently on the same fiber. There are two types of yields:"
msgstr ""
"Передача управления необходима, в противном случае, поток обработки "
"транзакции заклинит на одном файбере. Есть два типа передачи управления:"

msgid ""
":ref:`implicit yields <atomic-implicit-yields>`: every data-change operation"
" or network-access causes an implicit yield, and every statement that goes "
"through the Tarantool client causes an implicit yield."
msgstr ""
":ref:`неявная передача управления <atomic-implicit-yields>`: каждая операция"
" по изменению данных или доступ к сети вызывают неявную передачу управления,"
" а также каждое выражение, которое проходит через клиент Tarantool'а, "
"вызывает неявную передачу управления."

msgid ""
"explicit yields: in a Lua function, you can (and should) add :ref:`\"yield\""
" <fiber-yield>` statements to prevent hogging. This is called **cooperative "
"multitasking**."
msgstr ""
"явная передача управления: в Lua-функции можно (и нужно) добавить выражения "
":ref:`\"передачи управления\" <fiber-yield>` для предотвращения захвата ЦП. "
"Это называется **кооперативной многозадачностью**."

msgid "Cooperative multitasking"
msgstr "Кооперативная многозадачность"

msgid ""
"Cooperative multitasking means: unless a running fiber deliberately yields "
"control, it is not preempted by some other fiber. But a running fiber will "
"deliberately yield when it encounters a “yield point”: a transaction commit,"
" an operating system call, or an explicit :ref:`\"yield\" <fiber-yield>` "
"request. Any system call which can block will be performed asynchronously, "
"and any running fiber which must wait for a system call will be preempted, "
"so that another ready-to-run fiber takes its place and becomes the new "
"running fiber."
msgstr ""
"Кооперативная многозадачность означает, что если запущенный файбер намеренно"
" не передаст управление, он не вытесняется каким-либо другим файбером. Но "
"запущенный файбер намеренно передает управление, когда обнаруживает “точку "
"передачи управления”: коммит транзакции, вызов операционной системы или "
"запрос явной :ref:`\"передачи управления\" <fiber-yield>`. Любой вызов "
"системы, который может блокировать файбер, будет производиться асинхронно, а"
" запущенный файбер, который должен ожидать системного вызова, будет вытеснен"
" так, что другой готовый к работе файбер занимает его место и становится "
"запущенным файбером."

msgid ""
"This model makes all programmatic locks unnecessary: cooperative "
"multitasking ensures that there will be no concurrency around a resource, no"
" race conditions, and no memory consistency issues. The way to achieve this "
"is quite simple: in critical sections, don't use yields, explicit or "
"implicit, and no one can interfere into the code execution."
msgstr ""
"Такая модель позволяет отказаться от программных блокировок, поскольку "
"кооперативная многозадачность обеспечивает отсутствие борьбы за ресурс, "
"гонки потоков и проблем с согласованностью данных. Добиться этого довольно "
"просто: не использовать явную или неявную передачу управления в критических "
"секциях, и никто не сможет вмешаться в выполнение кода."

msgid ""
"When requests are small, for example simple UPDATE or INSERT or DELETE or "
"SELECT, fiber scheduling is fair: it takes only a little time to process the"
" request, schedule a disk write, and yield to a fiber serving the next "
"client."
msgstr ""
"При небольших запросах, таких как простые UPDATE, INSERT, DELETE или SELECT,"
" происходит справедливое планирование файберов: немного времени требуется на"
" обработку запроса, планирование записи на диск и передачу управления на "
"файбер, обслуживающий следующего клиента."

msgid ""
"However, a function might perform complex computations or might be written "
"in such a way that yields do not occur for a long time. This can lead to "
"unfair scheduling, when a single client throttles the rest of the system, or"
" to apparent stalls in request processing. Avoiding this situation is the "
"responsibility of the function’s author."
msgstr ""
"Однако функция может выполнять сложные расчеты  или может быть написана так,"
" что управление не передается в течение длительного времени. Это может "
"привести к несправедливому планированию, когда отдельный клиент перекрывает "
"работу остальной системы, или к явным задержкам в обработке запросов. Автору"
" функции следует не допускать таких ситуаций."

msgid ""
"In the absence of transactions, any function that contains yield points may "
"see changes in the database state caused by fibers that preempt. Multi-"
"statement transactions exist to provide **isolation**: each transaction sees"
" a consistent database state and commits all its changes atomically. At "
":doc:`commit </reference/reference_lua/box_txn_management/commit>` time, a "
"yield happens and all transaction changes are written to the :ref:`write "
"ahead log <internals-wal>` in a single batch. Or, if needed, transaction "
"changes can be rolled back -- :doc:`completely "
"</reference/reference_lua/box_txn_management/rollback>` or to a specific "
":doc:`savepoint "
"</reference/reference_lua/box_txn_management/rollback_to_savepoint>`."
msgstr ""
"В отсутствие транзакций любая функция, в которой есть точки передачи "
"управления, может видеть изменения в состоянии базы данных, вызванные "
"вытесняющими файберами. Составные транзакции предназначены для **изоляции**:"
" каждая транзакция видит постоянное состояние базы данных и делает атомарные"
" коммиты изменений. Во время :doc:`коммита "
"</reference/reference_lua/box_txn_management/commit>` происходит передача "
"управления, а все транзакционные изменения записываются в :ref:`журнал "
"упреждающей записи <internals-wal>` в отдельный пакет. Или, при "
"необходимости, можно откатить изменения -- :doc:`полностью "
"</reference/reference_lua/box_txn_management/rollback>` или на определенную "
":doc:`точку сохраниения "
"</reference/reference_lua/box_txn_management/rollback_to_savepoint>`."

msgid ""
"In Tarantool, `transaction isolation level "
"<https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels>`_"
" is *serializable* with the clause \"if no failure during writing to WAL\". "
"In case of such a failure that can happen, for example, if the disk space is"
" over, the transaction isolation level becomes *read uncommitted*."
msgstr ""
"В Tarantool `транзакции изолированы "
"<https://ru.wikipedia.org/wiki/%D0%A3%D1%80%D0%BE%D0%B2%D0%B5%D0%BD%D1%8C_%D0%B8%D0%B7%D0%BE%D0%BB%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8_%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D0%B9>`_"
" полностью — на уровне *serializable* (упорядочиваемость) с оговоркой: "
"\"если нет сбоев при записи в WAL\". В случае такого сбоя, например при "
"переполнении дискового пространства, транзакции изолированы на уровне *read "
"uncommitted* (чтение незафиксированных данных)."

msgid ""
"In :ref:`vynil <engines-chapter>`, to implement isolation Tarantool uses a "
"simple optimistic scheduler: the first transaction to commit wins. If a "
"concurrent active transaction has read a value modified by a committed "
"transaction, it is aborted."
msgstr ""

msgid ""
"The cooperative scheduler ensures that, in absence of yields, a multi-"
"statement transaction is not preempted and hence is never aborted. "
"Therefore, understanding yields is essential to writing abort-free code."
msgstr ""
"Кооперативный планировщик обеспечивает, что в отсутствие передачи управления"
" составная транзакция не вытесняется, поэтому никогда не прерывается. Таким "
"образом, понимание передачи управления необходимо для написания кода без "
"прерываний."

msgid ""
"Sometimes while testing the transaction mechanism in Tarantool you can "
"notice that yielding after ``box.begin()`` but before any read/write "
"operation does not cause an abort as it should according to the description."
" This happens because actually ``box.begin()`` does not start a transaction."
" It is a mark telling Tarantool to start a transaction after some database "
"request that follows."
msgstr ""
"Иногда при тестировании механизма транзакций в Tarantool можно заметить, что"
" выдача после ``box.begin()``, но перед любой операцией чтения/записи не "
"приводит к прерыванию, как это должно происходить согласно описанию. Причина"
" в том, что на самом деле ``box.begin()`` не запускает транзакцию: это "
"просто метка, указывающая Tarantool запустить транзакцию после некоторого "
"запроса к базе данных, который следует за этим."

msgid ""
"In memtx, if an instruction that implies yields, explicit or implicit, is "
"executed during a transaction, the transaction is fully rolled back. In "
"vynil, we use more complex transactional manager that allows yields."
msgstr ""

msgid "You can’t mix storage engines in a transaction today."
msgstr "На сегодняшний день нельзя смешивать движки базы данных в транзакции."

msgid "Implicit yields"
msgstr "Правила неявной передачи управления"

msgid ""
"The only explicit yield requests in Tarantool are :ref:`fiber.sleep() "
"<fiber-sleep>` and :ref:`fiber.yield() <fiber-yield>`, but many other "
"requests \"imply\" yields because Tarantool is designed to avoid blocking."
msgstr ""
"Единственные запросы явной передачи данных в Tarantool'е отправляют "
":ref:`fiber.sleep() <fiber-sleep>` и :ref:`fiber.yield() <fiber-yield>`, но "
"многие другие запросы \"неявно\" подразумевают передачу управления, "
"поскольку цель Tarantool'а -- избежать блокировок."

msgid ""
"Database requests imply yields if and only if there is disk I/O. For memtx, "
"since all data is in memory, there is no disk I/O during a read request. For"
" vinyl, since some data may not be in memory, there may be disk I/O for a "
"read (to fetch data from disk) or for a write (because a stall may occur "
"while waiting for memory to be free). For both memtx and vinyl, since data-"
"change requests must be recorded in the WAL, there is normally a commit. A "
"commit happens automatically after every request in default \"autocommit\" "
"mode, or a commit happens at the end of a transaction in \"transaction\" "
"mode, when a user deliberately commits by calling "
":doc:`/reference/reference_lua/box_txn_management/commit`. Therefore for "
"both memtx and vinyl, because there can be disk I/O, some database "
"operations may imply yields."
msgstr ""
"Запросы к базе данных подразумевают передачу управления тогда и только "
"тогда, когда происходят дисковые операции ввода-вывода. Так как все данные в"
" memtx находятся в оперативной памяти, во время запроса на чтение дискового "
"ввода-вывода не происходит. В vinyl некоторые данные могут находиться не в "
"оперативной памяти, поэтому возможны дисковые операции при чтении (для "
"получения данных с диска) или при записи (потому что может произойти сбой в "
"ожидании освобождения памяти). Запросы на изменение данных и в memtx, и в "
"vinyl должны записываться в WAL, и обычно происходит коммит. Коммит "
"происходит автоматически после каждого запроса в режиме \"автоматических "
"коммитов\" (autocommit) по умолчанию или в конце транзакции в режиме "
"\"транзакция\" (transaction), когда пользователь вручную производит коммит, "
"вызывая :doc:`/reference/reference_lua/box_txn_management/commit`. Поэтому и"
" для memtx, и для vinyl некоторые операции с БД могут подразумевать передачу"
" управления при наличии дискового ввода-вывода."

msgid ""
"Many functions in modules :ref:`fio <fio-section>`, :ref:`net_box <net_box-"
"module>`, :ref:`console <console-module>` and :ref:`socket <socket-module>` "
"(the \"os\" and \"network\" requests) yield."
msgstr ""
"Многие функции в модулях :ref:`fio <fio-section>`, :ref:`net_box <net_box-"
"module>`, :ref:`console <console-module>` и :ref:`socket <socket-module>` "
"(запросы \"ОС\" и \"сети\") передают управление."

msgid ""
"That is why executing separate commands such as ``select()``, ``insert()``, "
"``update()`` in the console inside a transaction will cause an abort. This "
"is due to implicit yield happening after each chunk of code is executed in "
"the console."
msgstr ""
"Поэтому выполнение отдельных команд, таких как ``select()``, ``insert()``, "
"``update()`` в консоли внутри транзакции, приведет к прерыванию транзакции. "
"Это связано с тем, что после выполнения каждого фрагмента кода в консоли "
"происходит неявная передача управления (yield)."

msgid "**Example #1**"
msgstr "**Пример №1**"

msgid ""
"*Engine = memtx* |br| The sequence ``select() insert()`` has one yield, at "
"the end of insertion, caused by implicit commit; ``select()`` has nothing to"
" write to the WAL and so does not yield."
msgstr ""
"*Когда движок базы данных - memtx* |br| В последовательности ``select() "
"insert()`` управление передается один раз в конце вставки, что вызвано "
"неявным коммитом; ``select()`` ничего не записывает в WAL, поэтому не "
"передает управление."

msgid ""
"*Engine = vinyl* |br| The sequence ``select() insert()`` has one to three "
"yields, since ``select()`` may yield if the data is not in cache, "
"``insert()`` may yield waiting for available memory, and there is an "
"implicit yield at commit."
msgstr ""
"*Когда движок базы данных - vinyl* |br| В последовательности ``select() "
"insert()`` управление передается от одного до трех раз: ``select()`` может "
"передавать управление, если данных нет в кэше; ``insert()`` может передавать"
" управление, пока ожидает доступную память; и при коммите будет неявная "
"передача управления."

msgid ""
"The sequence ``begin() insert() insert() commit()`` yields only at commit if"
" the engine is memtx, and can yield up to 3 times if the engine is vinyl."
msgstr ""
"Последовательность ``begin() insert() insert() commit()`` передает "
"управление только при коммите, если движок -- memtx, и может передавать "
"управление до 3 раз, если движок -- vinyl."

msgid "**Example #2**"
msgstr "**Пример №2**"

msgid ""
"Assume that in the memtx space ‘tester’ there are tuples in which the third "
"field represents a positive dollar amount. Let's start a transaction, "
"withdraw from tuple#1, deposit in tuple#2, and end the transaction, making "
"its effects permanent."
msgstr ""
"Предположим, что в спейсе ‘tester’ в memtx есть кортежи, в которых третье "
"поле представляет собой положительную сумму в долларах. Начнем транзакцию, "
"снимем со счета из кортежа №1, пополним счет в кортеж №2 и закончим "
"транзакцию, подтвердив изменения."

msgid ""
"tarantool> function txn_example(from, to, amount_of_money)\n"
"         >   box.begin()\n"
"         >   box.space.tester:update(from, {{'-', 3, amount_of_money}})\n"
"         >   box.space.tester:update(to,   {{'+', 3, amount_of_money}})\n"
"         >   box.commit()\n"
"         >   return \"ok\"\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> txn_example({999}, {1000}, 1.00)\n"
"---\n"
"- \"ok\"\n"
"..."
msgstr ""
"tarantool> function txn_example(from, to, amount_of_money)\n"
"         >   box.begin()\n"
"         >   box.space.tester:update(from, {{'-', 3, amount_of_money}})\n"
"         >   box.space.tester:update(to,   {{'+', 3, amount_of_money}})\n"
"         >   box.commit()\n"
"         >   return \"ok\"\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> txn_example({999}, {1000}, 1.00)\n"
"---\n"
"- \"ok\"\n"
"..."

msgid ""
"If :ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>` = ‘none’, then "
"implicit yielding at commit time does not take place, because there are no "
"writes to the WAL."
msgstr ""
"Если :ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>` = ‘none’, то "
"при коммите управление не передается неявно, потому что не идет запись в "
"WAL-файл."

msgid ""
"If a task is interactive -- sending requests to the server and receiving "
"responses -- then it involves network I/O, and therefore there is an "
"implicit yield, even if the request that is sent to the server is not itself"
" an implicit yield request. Therefore, the following sequence"
msgstr ""
"Если задача интерактивная — отправка запросов к серверу и получение ответов "
"— то она подразумевает сетевой ввод-вывод и неявную передачу управления, "
"даже если запрос, который отправляется на сервер, сам по себе не будет "
"запросом на неявную передачу управления. Поэтому такая последовательность"

msgid ""
"conn.space.test:select{1}\n"
"conn.space.test:select{2}\n"
"conn.space.test:select{3}"
msgstr ""
"conn.space.test:select{1}\n"
"conn.space.test:select{2}\n"
"conn.space.test:select{3}"

msgid ""
"causes yields three times sequentially when sending requests to the network "
"and awaiting the results. On the server side, the same requests are executed"
" in common order possibly mixing with other requests from the network and "
"local fibers. Something similar happens when using clients that operate via "
"telnet, via one of the connectors, or via the :ref:`MySQL and PostgreSQL "
"rocks <dbms_modules>`, or via the interactive mode when :ref:`using "
"Tarantool as a client <admin-using_tarantool_as_a_client>`."
msgstr ""
"вызывает передачу управления три раза при отправке запросов в сеть и "
"ожидании результатов. На стороне сервера те же самые запросы выполняются в "
"общем порядке, возможно, смешиваясь с другими запросами из сети и локальных "
"файберов. Что-то подобное происходит, если использовать клиент, который "
"работает через telnet, с помощью одного из коннекторов или сторонних модулей"
" :ref:`MySQL и PostgreSQL <dbms_modules>` или в интерактивном режиме, когда "
":ref:`Tarantool используется в качестве клиента <admin-"
"using_tarantool_as_a_client>`."

msgid ""
"After a fiber has yielded and then has regained control, it immediately "
"issues :ref:`testcancel <fiber-testcancel>`."
msgstr ""
"После того, как файбер передал управление, а затем вернул его, он "
"незамедлительно вызывает :ref:`testcancel <fiber-testcancel>`."
