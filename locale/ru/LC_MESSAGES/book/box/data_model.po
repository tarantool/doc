
msgid "Data model"
msgstr "Модель данных"

msgid ""
"This section describes how Tarantool stores values and what operations "
"with data it supports."
msgstr ""
"В этом разделе описывается то, как в Tarantool'е организовано хранение "
"данных и какие операции с данными он поддерживает."

msgid ""
"If you tried to create a database as suggested in our :ref:`\"Getting "
"started\" exercises <getting_started>`, then your test database now looks"
" like this:"
msgstr ""
"Если вы пробовали создать базу данных, как предлагается в упражнениях в "
":ref:`\"Руководстве для начинающих\" <getting_started>`, то ваша тестовая"
" база данных выглядит следующим образом:"

msgid "Space"
msgstr "Спейс"

msgid "A **space** -- 'tester' in our example -- is a container."
msgstr "*Спейс* -- с именем 'tester' в нашем примере -- это контейнер."

msgid ""
"When Tarantool is being used to store data, there is always at least one "
"space. Each space has a unique **name** specified by the user. Besides, "
"each space has a unique **numeric identifier** which can be specified by "
"the user, but usually is assigned automatically by Tarantool. Finally, a "
"space always has an **engine**: *memtx* (default) -- in-memory engine, "
"fast but limited in size, or *vinyl* -- on-disk engine for huge data "
"sets."
msgstr ""
"Когда Tarantool используется для хранения данных, всегда существует хотя "
"бы один спейс. У каждого спейса есть уникальное **имя**, указанное "
"пользователем. Кроме того, пользователь может указать уникальный "
"**числовой идентификатор**, но обычно Tarantool назначает его "
"автоматически. Наконец, в спейсе всегда есть **движок**: *memtx* (по "
"умолчанию) -- in-memory движок, быстрый, но ограниченный в размере, или "
"*vinyl* -- дисковый движок для огромного количества данных."

msgid ""
"A space is a container for :ref:`tuples <index-box_tuple>`. To be "
"functional, it needs to have a :ref:`primary index <index-box_index>`. It"
" can also have secondary indexes."
msgstr ""
"Спейс -- это контейнер для :ref:`кортежей <index-box_tuple>`. Для работы "
"ему необходим :ref:`первичный индекс <index-box_index>`. Также возможно "
"использование вторичных индексов."

msgid "Tuple"
msgstr "Кортеж"

msgid ""
"A **tuple** plays the same role as a “row” or a “record”, and the "
"components of a tuple (which we call “fields”) play the same role as a "
"“row column” or “record field”, except that:"
msgstr ""
"**Кортеж** играет такую же роль, как “строка” или “запись”, а компоненты "
"кортежа (которые мы называем “полями”) играют такую же роль, что и "
"“столбец” или “поле записи”, не считая того, что:"

msgid "fields can be composite structures, such as arrays or maps, and"
msgstr ""
"поля могут представлять собой композитные структуры, такие как таблицы "
"типа массива или ассоциативного массива, а также"

msgid "fields don't need to have names."
msgstr "полям не нужны имена."

msgid ""
"Any given tuple may have any number of fields, and the fields may be of "
"different :ref:`types <index-box_data-types>`. The identifier of a field "
"is the field's number, base 1 (in Lua and other 1-based languages) or "
"base 0 (in PHP or C/C++). For example, ``1`` or ``0`` can be used in some"
" contexts to refer to the first field of a tuple."
msgstr ""
"В любом кортеже может быть любое количество полей, и это могут быть поля "
"разных :ref:`типов <index-box_data-types>`. Идентификатором поля является"
" его номер, начиная с 1 (в Lua и других языках с индексацией с 1) или с 0"
" (в PHP или C/C++). Например, ``1`` или ``0`` могут использоваться в "
"некоторых контекстах для обозначения первого поля кортежа."

msgid "The number of tuples in a space is unlimited."
msgstr "Количество кортежей в спейсе не ограничено."

msgid ""
"Tuples in Tarantool are stored as `MsgPack "
"<https://en.wikipedia.org/wiki/MessagePack>`_ arrays."
msgstr ""
"Кортежи в Tarantool'е хранятся в виде массивов `MsgPack "
"<https://en.wikipedia.org/wiki/MessagePack>`_."

msgid ""
"When Tarantool returns a tuple value in console, it uses the `YAML "
"<https://en.wikipedia.org/wiki/YAML>`_ format, for example: ``[3, 'Ace of"
" Base', 1993]``."
msgstr ""
"Когда Tarantool выводит значение в кортеже в консоль, используется формат"
" `YAML <https://ru.wikipedia.org/wiki/YAML>`_, например: ``[3, 'Ace of  "
"Base', 1993]``."

msgid "Index"
msgstr "Индекс"

msgid "An **index** is a group of key values and pointers."
msgstr "**Индекс** -- это совокупность значений ключей и указателей."

msgid ""
"As with spaces, you should specify the index **name**, and let Tarantool "
"come up with a unique **numeric identifier** (\"index id\")."
msgstr ""
"Как и для спейсов, индексам следует указать **имена**, а Tarantool "
"определит уникальный **числовой идентификатор** (\"ID индекса\")."

msgid ""
"An index always has a **type**. The default index type is 'TREE'. TREE "
"indexes are provided by all Tarantool engines, can index unique and non-"
"unique values, support partial key searches, comparisons and ordered "
"results. Additionally, memtx engine supports HASH, RTREE and BITSET "
"indexes."
msgstr ""
"У индекса всегда есть определенный **тип**. Тип индекса по умолчанию -- "
"'TREE'. Все движки Tarantool'а предоставляют TREE-индексы, которые могут "
"индексировать уникальные и неуникальные значения, поддерживают поиск по "
"компонентам ключа, сравнение ключей и упорядоченные результаты. Кроме "
"того, движок memtx поддерживает следующие индексы: HASH, RTREE и BITSET."

msgid ""
"An index may be **multi-part**, that is, you can declare that an index "
"key value is composed of two or more fields in the tuple, in any order. "
"For example, for an ordinary TREE index, the maximum number of parts is "
"255."
msgstr ""
"Индекс может быть **многокомпонентным**, то есть можно объявить, что ключ"
" индекса состоит из двух или более полей в кортеже в любом порядке. "
"Например, для обычного TREE-индекса максимальное количество частей равно "
"255."

msgid ""
"An index may be **unique**, that is, you can declare that it would be "
"illegal to have the same key value twice."
msgstr ""
"Индекс может быть **уникальным**, то есть можно объявить, что недопустимо"
" дважды задавать одно значение ключа."

msgid ""
"The first index defined on a space is called the **primary key index**, "
"and it must be unique. All other indexes are called **secondary "
"indexes**, and they may be non-unique."
msgstr ""
"Первый индекс, определенный для спейса, называется **первичный индекс**. "
"Он должен быть уникальным. Все остальные индексы называются **вторичными "
"индексами**, они могут строиться по неуникальным значениям."

msgid ""
"An index definition may include identifiers of tuple fields and their "
"expected **types** (see allowed :ref:`indexed field types <index-"
"box_indexed-field-types>` below)."
msgstr ""
"Индекс может содержать идентификаторы полей кортежа и их предполагаемые "
"**типы** (см. допустимые :ref:`типы индексированных полей <index-"
"box_indexed-field-types>` ниже)."

msgid ""
"A recommended design pattern for a data model is to base primary keys on "
"the first fields of a tuple, because this speeds up tuple comparison."
msgstr ""
"Рекомендуется проектировать модель данных так, чтобы первичные ключи были"
" первыми полями в котреже, чтобы их было быстрее сравнивать."

msgid ""
"In our example, we first defined the primary index (named 'primary') "
"based on field #1 of each tuple:"
msgstr ""
"В нашем примере для начала определяем первичный индекс (под названием "
"'primary') по полю №1 каждого кортежа:"

msgid ""
"tarantool> i = s:create_index('primary', {type = 'hash', parts = {{field "
"= 1, type = 'unsigned'}}}"
msgstr ""
"tarantool> i = s:create_index('primary', {type = 'hash', parts = {{field "
"= 1, type = 'unsigned'}}}"

msgid ""
"The effect is that, for all tuples in space 'tester', field #1 must exist"
" and must contain an unsigned integer. The index type is 'hash', so "
"values in field #1 must be unique, because keys in HASH indexes are "
"unique."
msgstr ""
"Смысл в том, что поле №1 должно существовать и содержать целое число без "
"знака для всех кортежей в спейсе 'tester'. Тип индекса -- 'hash', поэтому"
" значения в поле №1 должны быть уникальными, поскольку ключи в "
"HASH-индексах уникальны."

msgid ""
"After that, we defined a secondary index (named 'secondary') based on "
"field #2 of each tuple:"
msgstr ""
"После этого мы определим вторичный индекс (под названием 'secondary') по "
"полю №2 каждого кортежа:"

msgid ""
"tarantool> i = s:create_index('secondary', {type = 'tree', parts = {2, "
"'string'}})"
msgstr ""
"tarantool> i = s:create_index('secondary', {type = 'tree', parts = {2, "
"'string'}})"

msgid ""
"The effect is that, for all tuples in space 'tester', field #2 must exist"
" and must contain a string. The index type is 'tree', so values in field "
"#2 must not be unique, because keys in TREE indexes may be non-unique."
msgstr ""
"Смысл в том, что поле №2 должно существовать и содержать строку для всех "
"кортежей в спейсе 'tester'. Тип индекса -- 'tree', поэтому значения в "
"поле №2 не должны быть уникальными, поскольку ключи в TREE-индексах могут"
" не быть уникальными."

msgid ""
"Space definitions and index definitions are stored permanently in "
"Tarantool's system spaces :ref:`_space <box_space-space>` and "
":ref:`_index <box_space-index>` (for details, see reference on "
":ref:`box.space <box_space>` submodule)."
msgstr ""
"Определения спейса и определения индексов хранятся в системных спейсах "
"Tarantool'а :ref:`_space <box_space-space>` и :ref:`_index <box_space-"
"index>` соответственно (для получения подробной информации см. справочник"
" по вложенному модулю :ref:`box.space <box_space>`)."

msgid ""
"You can add, drop, or alter the definitions at runtime, with some "
"restrictions. See syntax details in reference on :ref:`box <box-module>` "
"module."
msgstr ""
"Можно добавлять, опускать или изменять определения во время исполнения "
"кода с некоторыми ограничениями. Более подробно о синтаксисе см. в "
"справочнике по модулю :ref:`box <box-module>`."

msgid ""
"Read more about index operations :ref:`below <index-box_index-"
"operations>`."
msgstr ""
"Подробнее об операциях с индексом читайте :ref:`ниже <index-box_index-"
"operations>`."

msgid "Data types"
msgstr "Типы данных"

msgid ""
"Tarantool is both a database and an application server. Hence a developer"
" often deals with two type sets: the programming language types (e.g. "
"Lua) and the types of the Tarantool storage format (MsgPack)."
msgstr ""
"Tarantool представляет собой базу данных и сервер приложений "
"одновременно. Следовательно, разработчик часто работает с двумя наборами "
"типов: типы языка программирования (например, Lua) и типы формата "
"хранилища Tarantool (MsgPack)."

msgid "Lua vs MsgPack"
msgstr "Lua в сравнении с MsgPack"

msgid "Scalar / compound"
msgstr "Скалярный / составной"

msgid "MsgPack |nbsp| type"
msgstr "MsgPack-тип |nbsp|"

msgid "Lua type"
msgstr "Lua-тип"

msgid "Example value"
msgstr "Пример значения"

msgid "scalar"
msgstr "скалярный"

msgid "nil"
msgstr "nil"

msgid "\"`nil`_\""
msgstr "\"`nil`_\" (нулевое значение)"

msgid "msgpack.NULL"
msgstr "msgpack.NULL"

msgid "boolean"
msgstr "boolean (логический)"

msgid "\"`boolean`_\""
msgstr "\"`boolean`_\" (логическое значение)"

msgid "true"
msgstr "true"

msgid "string"
msgstr "string (строка)"

msgid "\"`string`_\""
msgstr "\"`string`_\" (строка)"

msgid "'A B C'"
msgstr "'A B C'"

msgid "integer"
msgstr "integer (целое число)"

msgid "\"`number`_\""
msgstr "\"`number`_\" (число)"

msgid "12345"
msgstr "12345"

msgid "double"
msgstr "double (числа с двойной точностью)"

msgid "1.2345"
msgstr "1,2345"

msgid "compound"
msgstr "составной"

msgid "map"
msgstr "map (ассоциативный массив)"

msgid "\"`table`_\" (with string keys)"
msgstr "\"`table`_\" (таблица со строковыми ключами)"

msgid "{'a': 5, 'b': 6}"
msgstr "{'a': 5, 'b': 6}"

msgid "array"
msgstr "array (массив)"

msgid "\"`table`_\" (with integer keys)"
msgstr "\"`table`_\" (таблица с целочисленными ключами)"

msgid "[1, 2, 3, 4, 5]"
msgstr "[1, 2, 3, 4, 5]"

msgid "tuple (\"`cdata`_\")"
msgstr "tuple (\"`cdata`_\") (кортеж)"

msgid "[12345, 'A B C']"
msgstr "[12345, 'A B C']"

msgid ""
"In Lua, a **nil** type has only one possible value, also called *nil* "
"(displayed as **null** on Tarantool's command line, since the output is "
"in the YAML format). Nils may be compared to values of any types with == "
"(is-equal) or ~= (is-not-equal), but other operations will not work. Nils"
" may not be used in Lua tables; the workaround is to use "
":ref:`msgpack.NULL <msgpack-null>`"
msgstr ""
"В языке Lua тип *nil* (нулевой) может иметь только одно значение, также "
"называемое *nil* (отображаемое как **null** в командной строке "
"Tarantool'а, поскольку значения выводятся в формате YAML). Нулевое "
"значение можно сравнивать со значениями любых типов с помощью операторов "
"== (равен) или ~= (не равен), но никакие другие операции для нулевых "
"значений не доступны. Нулевые значения также нельзя использовать в "
"Lua-таблицах; вместо нулевого значения в таком случае можно указать "
":ref:`msgpack.NULL <msgpack-null>`"

msgid "A **boolean** is either ``true`` or ``false``."
msgstr ""
"Тип *boolean* (логический) может иметь только значения ``true`` или "
"``false``."

msgid ""
"A **string** is a variable-length sequence of bytes, usually represented "
"with alphanumeric characters inside single quotes. In both Lua and "
"MsgPack, strings are treated as binary data, with no attempts to "
"determine a string's character set or to perform any string conversion --"
" unless there is an optional :ref:`collation <index-collation>`. So, "
"usually, string sorting and comparison are done byte-by-byte, without any"
" special collation rules applied. (Example: numbers are ordered by their "
"point on the number line, so 2345 is greater than 500; meanwhile, strings"
" are ordered by the encoding of the first byte, then the encoding of the "
"second byte, and so on, so '2345' is less than '500'.)"
msgstr ""
"Тип **string**  (строка) представляет собой последовательность байтов "
"переменной длины, обычно представленную буквенно-цифровые символы в "
"одинарных кавычках. Как в Lua, так и в MsgPack строки рассматриваются как"
" бинарные данные без попыток определить набор символов строки или "
"выполнить преобразование строки -- кроме случаев, когда есть опциональное"
" :ref:`сравнение символов <index-collation>`. Таким образом, обычно "
"сортировка и сравнение строк выполняются побайтово, не применяя "
"дополнительных правил сравнения символов. (Пример: числа упорядочены по "
"их положению на числовой прямой, поэтому 2345 больше, чем 500; а строки "
"упорядочены по кодировке первого байта, затем кодировке второго байта и "
"так далее, таким образом, '2345' меньше, чем '500'.)"

msgid ""
"In Lua, a **number** is double-precision floating-point, but Tarantool "
"allows both integer and floating-point values. Tarantool will try to "
"store a Lua number as floating-point if the value contains a decimal "
"point or is very large (greater than 100 trillion = 1e14), otherwise "
"Tarantool will store it as an integer. To ensure that even very large "
"numbers are stored as integers, use the :ref:`tonumber64 <other-"
"tonumber64>` function, or the LL (Long Long) suffix, or the ULL (Unsigned"
" Long Long) suffix. Here are examples of numbers using regular notation, "
"exponential notation, the ULL suffix and the ``tonumber64`` function: "
"``-55``, ``-2.7e+20``, ``100000000000000ULL``, "
"``tonumber64('18446744073709551615')``."
msgstr ""
"В языке Lua тип **number** (число) -- это число с плавающей запятой "
"двойной точности, но в Tarantool'е можно использовать как целые числа, "
"так и числа с плавающей запятой. Tarantool по возможности сохраняет числа"
" языка Lua в виде чисел с плавающей запятой, если числовое значение "
"содержит десятичную запятую или если оно очень велико (более 100 "
"триллионов = 1e14). В противном случае, Tarantool сохраняет такое "
"значение в виде целого числа. Чтобы даже очень большие величины "
"гарантированно обрабатывались как целые числа, используйте функцию "
":ref:`tonumber64 <other-tonumber64>`, либо приписывайте в конце суффикс "
"LL (Long Long) или ULL (Unsigned Long Long). Вот примеры записи чисел в "
"обычном представлении, экспоненциальном, с суффиксом ULL и с "
"использованием функции ``tonumber64``:  ``-55``, ``-2.7e+20``, "
"``100000000000000ULL``, ``tonumber64('18446744073709551615')``."

msgid ""
"Lua **tables** with string keys are stored as MsgPack maps; Lua tables "
"with integer keys starting with 1 -- as MsgPack arrays. Nils may not be "
"used in Lua tables; the workaround is to use :ref:`msgpack.NULL <msgpack-"
"null>`"
msgstr ""
"В Lua **tables** (таблицы) со строковыми ключами хранятся как "
"ассоциативные массивы в MsgPack; Lua-таблицы с целочисленными ключами, "
"начиная с 1, хранятся как массивы в MsgPack. Нулевые значения нельзя "
"использовать в Lua-таблицах; вместо нулевого значения в таком случае "
"можно указать :ref:`msgpack.NULL <msgpack-null>`"

msgid ""
"A **tuple** is a light reference to a MsgPack array stored in the "
"database. It is a special type (cdata) to avoid conversion to a Lua table"
" on retrieval. A few functions may return tables with multiple tuples. "
"For more tuple examples, see :ref:`box.tuple <box_tuple>`."
msgstr ""
"Тип **tuple** (кортеж) представляет собой легкую ссылку на массив "
"MsgPack, который хранится в базе данных. Это особый тип (cdata), чтобы "
"избежать конвертации в Lua-таблицу при выборке данных. Некоторые функции "
"могут возвращать таблицы с множеством кортежей. Примеры с кортежами см. в"
" :ref:`box.tuple <box_tuple>`."

msgid ""
"Tarantool uses the MsgPack format for database storage, which is "
"variable-length. So, for example, the smallest number requires only one "
"byte, but the largest number requires nine bytes."
msgstr ""
"Tarantool использует формат MsgPack для хранения в базе данных переменной"
" длины. Поэтому, например, для наименьшего числа требуется только один "
"байт, но для наибольшего числа требуется девять байтов."

msgid "Examples of insert requests with different data types:"
msgstr "Примеры запроса вставки с разными типами данных:"

msgid ""
"tarantool> box.space.K:insert{1,nil,true,'A B C',12345,1.2345}\n"
"---\n"
"- [1, null, true, 'A B C', 12345, 1.2345]\n"
"...\n"
"tarantool> box.space.K:insert{2,{['a']=5,['b']=6}}\n"
"---\n"
"- [2, {'a': 5, 'b': 6}]\n"
"...\n"
"tarantool> box.space.K:insert{3,{1,2,3,4,5}}\n"
"---\n"
"- [3, [1, 2, 3, 4, 5]]\n"
"..."
msgstr ""
"tarantool> box.space.K:insert{1,nil,true,'A B C',12345,1.2345}\n"
"---\n"
"- [1, null, true, 'A B C', 12345, 1.2345]\n"
"...\n"
"tarantool> box.space.K:insert{2,{['a']=5,['b']=6}}\n"
"---\n"
"- [2, {'a': 5, 'b': 6}]\n"
"...\n"
"tarantool> box.space.K:insert{3,{1,2,3,4,5}}\n"
"---\n"
"- [3, [1, 2, 3, 4, 5]]\n"
"..."

msgid "Indexed field types"
msgstr "Типы индексированных полей"

msgid ""
"Indexes restrict values which Tarantool's MsgPack may contain. This is "
"why, for example, 'unsigned' is a separate **indexed field type**, "
"compared to ‘integer’ data type in MsgPack: they both store ‘integer’ "
"values, but an 'unsigned' index contains only *non-negative* integer "
"values and an ‘integer’ index contains *all* integer values."
msgstr ""
"Индексы ограничивают значения, которые может содержать MsgPack в "
"Tarantool'е. Вот почему, например, тип 'unsigned' (без знака) "
"представляет собой отдельный **тип индексированного поля** в сравнении с "
"типом данных ‘integer’ (целое число) в MsgPack: оба содержат значения с "
"целыми числами, но индекс 'unsigned' содержит только *неотрицательные* "
"целые числовые значения, а индекс ‘integer’ содержит *все* целые числовые"
" значения."

msgid "Here's how Tarantool indexed field types correspond to MsgPack data types."
msgstr ""
"Вот как типы индексированных полей в Tarantool'е соответствуют типам "
"данных MsgPack."

msgid "Indexed field type"
msgstr "Тип индексированного поля"

msgid "MsgPack data type |br| (and possible values)"
msgstr "Тип данных MsgPack |br| (и возможные значения)"

msgid "Index type"
msgstr "Тип индекса"

msgid "Examples"
msgstr "Примеры"

msgid "**unsigned** (may also be called ‘uint’ or ‘num’, but ‘num’ is deprecated)"
msgstr ""
"**unsigned** (без знака -- может также называться ‘uint’ или ‘num’, но "
"‘num’ объявлен устаревшим)"

msgid ""
"**integer** (integer between 0 and 18446744073709551615, i.e. about 18 "
"quintillion)"
msgstr ""
"**integer** (целое число в диапазоне от 0 до 18 446 744 073 709 551 615, "
"т.е. около 18 квинтиллионов)"

msgid "TREE, BITSET or HASH"
msgstr "TREE, BITSET или HASH"

msgid "123456"
msgstr "123456"

msgid "**integer** (may also be called ‘int’)"
msgstr "**integer** (целое число -- может также называться ‘int’)"

msgid ""
"**integer** (integer between -9223372036854775808 and "
"18446744073709551615)"
msgstr ""
"``integer`` (целое число в диапазоне от -9 223 372 036 854 775 808 до 18 "
"446 744 073 709 551 615)"

msgid "TREE or HASH"
msgstr "TREE или HASH"

msgid "-2^63"
msgstr "-2^63"

msgid "**number**"
msgstr "**number**"

msgid ""
"**double** (single-precision floating point number or double-precision "
"floating point number)"
msgstr ""
"**double** (число с плавающей запятой с одинарной точностью или с двойной"
" точностью)"

msgid "1.234"
msgstr "1,234"

msgid "-44"
msgstr "-44"

msgid "1.447e+44"
msgstr "1,447e+44"

msgid "**string** (may also be called ‘str’)"
msgstr "**string** (строка -- может также называться ‘str’)"

msgid "**string** (any set of octets, up to the maximum length)"
msgstr ""
"**string** (строка -- любая последовательность октетов до максимальной "
"длины)"

msgid "‘A B C’"
msgstr "‘A B C’"

msgid "‘\\65 \\66 \\67’"
msgstr "‘\\65 \\66 \\67’"

msgid "**boolean**"
msgstr "**boolean**"

msgid "**bool** (true or false)"
msgstr "**bool** (логический -- true или false)"

msgid "**array**"
msgstr "**array**"

msgid "**array** (list of numbers representing points in a geometric figure)"
msgstr ""
"**array** (массив -- список чисел, который представляет собой точки в "
"геометрической фигуре)"

msgid "RTREE"
msgstr "RTREE"

msgid "{10, 11}"
msgstr "{10, 11}"

msgid "{3, 5, 9, 10}"
msgstr "{3, 5, 9, 10}"

msgid "**scalar**"
msgstr "**scalar**"

msgid "**string** (any set of octets)"
msgstr "**string** (строковое значение, т.е. любая последовательность октетов)"

msgid ""
"Note: When there is a mix of types, the key order is: booleans, then "
"numbers, then strings."
msgstr ""
"Примечание: в сочетании различных типов порядок будет следующим: "
"логические значения, затем числовые, затем строковые."

msgid "-1"
msgstr "-1"

msgid "‘’"
msgstr "‘’"

msgid "‘ру’"
msgstr "‘ру’"

msgid "Collations"
msgstr "Сортировка"

msgid ""
"By default, when Tarantool compares strings, it uses what we call a "
"**\"binary\" collation**. The only consideration here is the numeric "
"value of each byte in the string. Therefore, if the string is encoded "
"with ASCII or UTF-8, then ``'A' < 'B' < 'a'``, because the encoding of "
"'A' (what used to be called the \"ASCII value\") is 65, the encoding of "
"'B' is 66, and the encoding of 'a' is 98. Binary collation is best if you"
" prefer fast deterministic simple maintenance and searching with "
"Tarantool indexes."
msgstr ""
"По умолчанию, когда Tarantool сравнивает строки, он использует то, что мы"
" называем **\"бинарной\" сортировкой**. Единственный фактор, который "
"учитывается, это числовое значение каждого байта в строке. Таким образом,"
" если строка кодируется по ASCII или UTF-8, то ``'A' < 'B' < 'a'``, "
"поскольку в кодировке 'A' (что раньше называлось \"значение ASCII\") "
"соответствует 65, 'B' -- 66, а 'a' -- 98. Бинарная сортировка подходит "
"лучше всего для быстрого детерминированного простого обслуживания и "
"поиска с помощью индексов Tarantool'а."

msgid ""
"But if you want the ordering that you see in phone books and "
"dictionaries, then you need Tarantool's **optional collations** -- "
"``unicode`` and ``unicode_ci`` -- that allow for ``'a' < 'A' < 'B'`` and "
"``'a' = 'A' < 'B'`` respectively."
msgstr ""
"Однако если необходимо распределение, как в телефонных справочниках и "
"словарях, то вам нужна **опциональная сортировка** Tarantool'а -- "
"``unicode`` и ``unicode_ci`` -- которые обеспечивают ``'a' < 'A' < 'B'`` "
"и ``'a' = 'A' < 'B'``  соответственно."

msgid ""
"Optional collations use the ordering according to the `Default Unicode "
"Collation Element Table (DUCET) "
"<http://unicode.org/reports/tr10/#Default_Unicode_Collation_Element_Table>`_"
" and the rules described in `Unicode® Technical Standard #10 Unicode "
"Collation Algorithm (UTS #10 UCA) <http://unicode.org/reports/tr10>`_. "
"The only difference between the two collations is about `weights "
"<https://unicode.org/reports/tr10/#Weight_Level_Defn>`_:"
msgstr ""
"Опциональная сортировка использует распределение в соответствии с "
"`Таблицей сортировки символов Юникода по умолчанию (DUCET) "
"<http://unicode.org/reports/tr10/#Default_Unicode_Collation_Element_Table>`_"
" и правилами, указанными в `Техническом стандарте Юникода №10 -- Алгоритм"
" сортировки по Юникоду (Unicode® Technical Standard #10 Unicode Collation"
" Algorithm (UTS #10 UCA)) <http://unicode.org/reports/tr10>`_. "
"Единственное отличие между двумя сортировками -- `вес "
"<https://unicode.org/reports/tr10/#Weight_Level_Defn>`_:"

msgid ""
"``unicode`` collation observes L1 and L2 and L3 weights (strength = "
"'tertiary'),"
msgstr ""
"сортировка ``unicode`` принимает во внимание уровни веса L1, L2 и L3 "
"(уровень = 'tertiary', третичный),"

msgid ""
"``unicode_ci`` collation observes only L1 weights (strength = 'primary'),"
" so for example 'a' = 'A' = 'á' = 'Á'."
msgstr ""
"сортировка ``unicode_ci`` принимает во внимание только вес L1 (уровень = "
"'primary', первичный), поэтому, например, 'a' = 'A' = 'á' = 'Á'."

msgid "As an example, let's take some Russian words:"
msgstr "Для примера возьмем некоторые русские слова:"

msgid ""
"'ЕЛЕ'\n"
"'елейный'\n"
"'ёлка'\n"
"'еловый'\n"
"'елозить'\n"
"'Ёлочка'\n"
"'ёлочный'\n"
"'ЕЛь'\n"
"'ель'"
msgstr ""
"'ЕЛЕ'\n"
"'елейный'\n"
"'ёлка'\n"
"'еловый'\n"
"'елозить'\n"
"'Ёлочка'\n"
"'ёлочный'\n"
"'ЕЛь'\n"
"'ель'"

msgid "...and show the difference in ordering and selecting by index:"
msgstr "...и покажем разницу в упорядочении и выборке по индексу:"

msgid "with ``unicode`` collation:"
msgstr "с сортировкой по ``unicode``:"

msgid ""
"tarantool> box.space.T:create_index('I', {parts = {{1,'str', "
"collation='unicode'}}})\n"
"...\n"
"tarantool> box.space.T.index.I:select()\n"
"---\n"
"- - ['ЕЛЕ']\n"
"  - ['елейный']\n"
"  - ['ёлка']\n"
"  - ['еловый']\n"
"  - ['елозить']\n"
"  - ['Ёлочка']\n"
"  - ['ёлочный']\n"
"  - ['ель']\n"
"  - ['ЕЛь']\n"
"...\n"
"tarantool> box.space.T.index.I:select{'ЁлКа'}\n"
"---\n"
"- []\n"
"..."
msgstr ""
"tarantool> box.space.T:create_index('I', {parts = {{1,'str', "
"collation='unicode'}}})\n"
"...\n"
"tarantool> box.space.T.index.I:select()\n"
"---\n"
"- - ['ЕЛЕ']\n"
"  - ['елейный']\n"
"  - ['ёлка']\n"
"  - ['еловый']\n"
"  - ['елозить']\n"
"  - ['Ёлочка']\n"
"  - ['ёлочный']\n"
"  - ['ель']\n"
"  - ['ЕЛь']\n"
"...\n"
"tarantool> box.space.T.index.I:select{'ЁлКа'}\n"
"---\n"
"- []\n"
"..."

msgid "with ``unicode_ci`` collation:"
msgstr "с сортировкой по ``unicode_ci``:"

msgid ""
"tarantool> box.space.T:create_index('I', {parts = {{1,'str', "
"collation='unicode_ci'}}})\n"
"...\n"
"tarantool> box.space.S.index.I:select()\n"
"---\n"
"- - ['ЕЛЕ']\n"
"  - ['елейный']\n"
"  - ['ёлка']\n"
"  - ['еловый']\n"
"  - ['елозить']\n"
"  - ['Ёлочка']\n"
"  - ['ёлочный']\n"
"  - ['ЕЛь']\n"
"...\n"
"tarantool> box.space.S.index.I:select{'ЁлКа'}\n"
"---\n"
"- - ['ёлка']\n"
"..."
msgstr ""
"tarantool> box.space.T:create_index('I', {parts = {{1,'str', "
"collation='unicode_ci'}}})\n"
"...\n"
"tarantool> box.space.S.index.I:select()\n"
"---\n"
"- - ['ЕЛЕ']\n"
"  - ['елейный']\n"
"  - ['ёлка']\n"
"  - ['еловый']\n"
"  - ['елозить']\n"
"  - ['Ёлочка']\n"
"  - ['ёлочный']\n"
"  - ['ЕЛь']\n"
"...\n"
"tarantool> box.space.S.index.I:select{'ЁлКа'}\n"
"---\n"
"- - ['ёлка']\n"
"..."

msgid ""
"In fact, though, good collation involves much more than these simple "
"examples of upper case / lower case and accented / unaccented equivalence"
" in alphabets. We also consider variations of the same character, non-"
"alphabetic writing systems, and special rules that apply for combinations"
" of characters."
msgstr ""
"Фактически хорошая сортировка включает в себя гораздо больше, чем простые"
" примеры эквивалентности заглавных и строчных букв, а также наличие или "
"отсутствие диакритических знаков в алфавитах. Учитываются также варианты "
"написания одного и того же символа, системы письменности без алфавита и "
"специальные правила, которые применяются в отношении сочетания символов."

msgid "Sequences"
msgstr "Последовательности"

msgid "A **sequence** is a generator of ordered integer values."
msgstr ""
"**Последовательность** -- это генератор упорядоченных значений целых "
"чисел."

msgid ""
"As with spaces and indexes, you should specify the sequence **name**, and"
" let Tarantool come up with a unique **numeric identifier** (\"sequence "
"id\")."
msgstr ""
"Как и для спейсов и индексов, для последовательностей следует указать "
"**имена**, а Tarantool определит уникальный **числовой идентификатор** "
"(\"ID последовательности\")."

msgid ""
"As well, you can specify several options when creating a new sequence. "
"The options determine what value will be generated whenever the sequence "
"is used."
msgstr ""
"Кроме того, можно указать несколько параметров при создании новой "
"последовательности. Параметры определяют, какое значение будет "
"генерироваться при использовании последовательности."

msgid "Options for ``box.schema.sequence.create()``"
msgstr "Параметры для ``box.schema.sequence.create()``"

msgid "Option name"
msgstr "Имя параметра"

msgid "Type and meaning"
msgstr "Тип и значение"

msgid "Default"
msgstr "Значение по умолчанию"

msgid "**start**"
msgstr "**start** (начало)"

msgid "Integer. The value to generate the first time a sequence is used"
msgstr ""
"Целое число. Значение генерируется, когда последовательность используется"
" впервые"

msgid "1"
msgstr "1"

msgid "start=0"
msgstr "start=0"

msgid "**min**"
msgstr "**min** (мин)"

msgid "Integer. Values smaller than this cannot be generated"
msgstr "Целое число. Ниже указанного значения не могут генерироваться"

msgid "min=-1000"
msgstr "min=-1000"

msgid "**max**"
msgstr "**max** (макс)"

msgid "Integer. Values larger than this cannot be generated"
msgstr "Целое число. Выше указанного значения не могут генерироваться"

msgid "9223372036854775807"
msgstr "9 223 372 036 854 775 807"

msgid "max=0"
msgstr "max=0"

msgid "**cycle**"
msgstr "**cycle** (цикл)"

msgid "Boolean. Whether to start again when values cannot be generated"
msgstr ""
"Логическое значение. Если значения не могут быть сгенерированы, начинать "
"ли заново"

msgid "false"
msgstr "false (ложь)"

msgid "cycle=true"
msgstr "cycle=true"

msgid "**cache**"
msgstr "**cache** (кэш)"

msgid "Integer. The number of values to store in a cache"
msgstr "Целое число. Количество значений для хранения в кэше"

msgid "0"
msgstr "0"

msgid "cache=0"
msgstr "cache=0"

msgid "**step**"
msgstr "**step** (шаг)"

msgid ""
"Integer. What to add to the previous generated value, when generating a "
"new value"
msgstr ""
"Целое число. Что добавить к предыдущему сгенерированному значению, когда "
"генерируется новое значение"

msgid "step=-1"
msgstr "step=-1"

msgid "**if_not_exists**"
msgstr "**if_not_exists** (если отсутствует)"

msgid ""
"Boolean. If this is true and a sequence with this name exists already, "
"ignore other options and use the existing values"
msgstr ""
"Логическое значение. Если выставлено в true (истина) и существует "
"последовательность с таким именем, то игнорировать другие опции и "
"использовать текущие значения"

msgid "if_not_exists=true"
msgstr "if_not_exists=true"

msgid ""
"Once a sequence exists, it can be altered, dropped, reset, forced to "
"generate the next value, or associated with an index."
msgstr ""
"Существующую последовательность можно изменять, опускать, сбрасывать, "
"заставить сгенерировать новое значение или ассоциировать с индексом."

msgid "For an initial example, we generate a sequence named 'S'."
msgstr ""
"Для первоначального примера сгенерируем последовательность под названием "
"'S'."

msgid ""
"tarantool> box.schema.sequence.create('S',{min=5, start=5})\n"
"---\n"
"- step: 1\n"
"  id: 5\n"
"  min: 5\n"
"  cache: 0\n"
"  uid: 1\n"
"  max: 9223372036854775807\n"
"  cycle: false\n"
"  name: S\n"
"  start: 5\n"
"..."
msgstr ""
"tarantool> box.schema.sequence.create('S',{min=5, start=5})\n"
"---\n"
"- step: 1\n"
"  id: 5\n"
"  min: 5\n"
"  cache: 0\n"
"  uid: 1\n"
"  max: 9223372036854775807\n"
"  cycle: false\n"
"  name: S\n"
"  start: 5\n"
"..."

msgid ""
"The result shows that the new sequence has all default values, except for"
" the two that were specified, ``min`` and ``start``."
msgstr ""
"В результате видим, что в новой последовательность есть все значения по "
"умолчанию, за исключением указанных ``min`` и ``start``."

msgid "Then we get the next value, with the ``next()`` function."
msgstr "Затем получаем следующее значение с помощью функции ``next()``."

msgid ""
"tarantool> box.sequence.S:next()\n"
"---\n"
"- 5\n"
"..."
msgstr ""
"tarantool> box.sequence.S:next()\n"
"---\n"
"- 5\n"
"..."

msgid ""
"The result is the same as the start value. If we called ``next()`` again,"
" we would get 6 (because the previous value plus the step value is 6), "
"and so on."
msgstr ""
"Результат точно такой же, как и начальное значение. Если мы снова вызовем"
" ``next()``, то получим 6 (потому что предыдущее значение плюс значение "
"шага составит 6) и так далее."

msgid ""
"Then we create a new table, and say that its primary key may be generated"
" from the sequence."
msgstr ""
"Затем создадим новую таблицу и скажем, что ее первичный ключ можно "
"получить из последовательности."

msgid ""
"tarantool> "
"s=box.schema.space.create('T');s:create_index('I',{sequence='S'})\n"
"---\n"
"..."
msgstr ""
"tarantool> "
"s=box.schema.space.create('T');s:create_index('I',{sequence='S'})\n"
"---\n"
"..."

msgid "Then we insert a tuple, without specifying a value for the primary key."
msgstr "Затем вставим кортеж, не указывая значение первичного ключа."

msgid ""
"tarantool> box.space.T:insert{nil,'other stuff'}\n"
"---\n"
"- [6, 'other stuff']\n"
"..."
msgstr ""
"tarantool> box.space.T:insert{nil,'other stuff'}\n"
"---\n"
"- [6, 'other stuff']\n"
"..."

msgid ""
"The result is a new tuple where the first field has a value of 6. This "
"arrangement, where the system automatically generates the values for a "
"primary key, is sometimes called \"auto-incrementing\" or \"identity\"."
msgstr ""
"В результате имеем новый кортеж со значением 6 в первом поле. Такой "
"способ организации данных, когда система автоматически генерирует "
"значения для первичного ключа, иногда называется \"автоинкрементным\" "
"(т.е. с автоматическим увеличением) или \"по идентификатору\"."

msgid ""
"For syntax and implementation details, see the reference for "
":ref:`box.schema.sequence <box_schema-sequence>`."
msgstr ""
"Для получения подробной информации о синтаксисе и методах реализации см. "
"справочник по :ref:`box.schema.sequence <box_schema-sequence>`."

msgid "Persistence"
msgstr "Персистентность"

msgid ""
"In Tarantool, updates to the database are recorded in the so-called "
":ref:`write ahead log (WAL) <internals-wal>` files. This ensures data "
"persistence. When a power outage occurs or the Tarantool instance is "
"killed incidentally, the in-memory database is lost. In this situation, "
"WAL files are used to restore the data. Namely, Tarantool reads the WAL "
"files and redoes the requests (this is called the \"recovery process\"). "
"You can change the timing of the WAL writer, or turn it off, by setting "
":ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>`."
msgstr ""
"В Tarantool'е обновления базы данных записываются в так называемые "
":ref:`файлы журнала упреждающей записи (WAL-файлы) <internals-wal>`. Это "
"обеспечивает персистентность данных. При отключении электроэнергии или "
"случайном завершении работы экземпляра Tarantool'а данные в оперативной "
"памяти теряются. В такой ситуации WAL-файлы используются для "
"восстановления данных так: Tarantool прочитывает WAL-файлы и повторно "
"выполняет запросы (это называется \"процессом восстановления\"). Можно "
"изменить временные настройки метода записи WAL-файлов или отключить его с"
" помощью :ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>`."

msgid ""
"Tarantool also maintains a set of :ref:`snapshot files <internals-"
"snapshot>`. These files contain an on-disk copy of the entire data set "
"for a given moment. Instead of reading every WAL file since the databases"
" were created, the recovery process can load the latest snapshot file and"
" then read only those WAL files that were produced after the snapshot "
"file was made. After checkpointing, old WAL files can be removed to free "
"up space."
msgstr ""
"Tarantool также сохраняет ряд файлов со статическими снимками данных "
"(:ref:`snapshots <internals-snapshot>`). Файл со снимком -- это дисковая "
"копия всех данных в базе на какой-то момент. Вместо того, чтобы "
"зачитывать все WAL-файлы, появившиеся с момента создания базы, Tarantool "
"в процессе восстановления может загрузить самый свежий снимок и затем "
"зачитать только те WAL-файлы, которые были сделаны с момента сохранения "
"снимка. После создания новых файлов, старые WAL-файлы могут быть удалены "
"в целях экономии места на диске."

msgid ""
"To force immediate creation of a snapshot file, you can use Tarantool's "
":ref:`box.snapshot() <box-snapshot>` request. To enable automatic "
"creation of snapshot files, you can use Tarantool's :ref:`checkpoint "
"daemon <book_cfg_checkpoint_daemon>`. The checkpoint daemon sets "
"intervals for forced checkpoints. It makes sure that the states of both "
"memtx and vinyl storage engines are synchronized and saved to disk, and "
"automatically removes old WAL files."
msgstr ""
"Чтобы принудительно создать файл со снимком, можно использовать запрос "
":ref:`box.snapshot() <box-snapshot>` в Tarantool'е. Чтобы включить "
"автоматическое создание файлов со снимком, можно использовать :ref:`демон"
" создания контрольных точек <book_cfg_checkpoint_daemon>` Tarantool'а. "
"Демон создания контрольных точек определяет интервалы для принудительного"
" создания контрольных точек. Он обеспечивает синхронизацию и сохранение "
"на диск образов движков базы данных (как memtx, так и vinyl), а также "
"автоматически удаляет старые WAL-файлы."

msgid "Snapshot files can be created even if there is no WAL file."
msgstr "Файлы со снимками можно создавать, даже если WAL-файлы отсутствуют."

msgid ""
"The memtx engine makes only regular checkpoints with the interval set in "
":ref:`checkpoint daemon <book_cfg_checkpoint_daemon>` configuration."
msgstr ""
"Движок memtx регулярно создает контрольные точки с интервалом, указанным "
"в настройках :ref:`демона создания контрольных точек "
"<book_cfg_checkpoint_daemon>`."

msgid "The vinyl engine runs checkpointing in the background at all times."
msgstr ""
"Движок vinyl постоянно сохраняет состояние в контрольной точке в фоновом "
"режиме."

msgid ""
"See the :ref:`Internals <internals-data_persistence>` section for more "
"details about the WAL writer and the recovery process."
msgstr ""
"Для получения более подробной информации о методе записи WAL-файлов и "
"процессе восстановления см. раздел :ref:`Внутренняя реализация "
"<internals-data_persistence>`."

msgid "Operations"
msgstr "Операции"

msgid "Data operations"
msgstr "Операции с данными"

msgid "The basic data operations supported in Tarantool are:"
msgstr "Tarantool поддерживает следующие основные операции с данными:"

msgid ""
"five data-manipulation operations (INSERT, UPDATE, UPSERT, DELETE, "
"REPLACE), and"
msgstr ""
"пять операций по изменению данных (INSERT, UPDATE, UPSERT, DELETE, "
"REPLACE) и"

msgid "one data-retrieval operation (SELECT)."
msgstr "одну операцию по выборке данных (SELECT)."

msgid ""
"All of them are implemented as functions in :ref:`box.space <box_space>` "
"submodule."
msgstr ""
"Все они реализованы в виде функций во вложенном модуле  :ref:`box.space "
"<box_space>`."

msgid "**Examples:**"
msgstr "**Примеры:**"

msgid ":ref:`INSERT <box_space-insert>`: Add a new tuple to space 'tester'."
msgstr ":ref:`INSERT <box_space-insert>`: добавить новый кортеж к спейсу 'tester'."

msgid "The first field, field[1], will be 999 (MsgPack type is `integer`)."
msgstr "Первое поле, field[1], будет 999 (тип MsgPack -- `integer`, целое число)."

msgid "The second field, field[2], will be 'Taranto' (MsgPack type is `string`)."
msgstr "Второе поле, field[2], будет 'Taranto' (тип MsgPack -- `string`, строка)."

msgid "tarantool> box.space.tester:insert{999, 'Taranto'}"
msgstr "tarantool> box.space.tester:insert{999, 'Taranto'}"

msgid ""
":ref:`UPDATE <box_space-update>`: Update the tuple, changing field "
"field[2]."
msgstr ":ref:`UPDATE <box_space-update>`: обновить кортеж, изменяя поле field[2]."

msgid ""
"The clause \"{999}\", which has the value to look up in the index of the "
"tuple's primary-key field, is mandatory, because ``update()`` requests "
"must always have a clause that specifies a unique key, which in this case"
" is field[1]."
msgstr ""
"Оператор \"{999}\" со значением, которое используется для поиска поля, "
"соответствующего ключу в первичном индексе, является обязательным, "
"поскольку в запросе ``update()`` должен быть оператор, который указывает "
"уникальный ключ, в данном случае -- field[1]."

msgid ""
"The clause \"{{'=', 2, 'Tarantino'}}\" specifies that assignment will "
"happen to field[2] with the new value."
msgstr ""
"Оператор \"{{'=', 2, 'Tarantino'}}\" указывает, что назначение нового "
"значения относится к field[2]."

msgid "tarantool> box.space.tester:update({999}, {{'=', 2, 'Tarantino'}})"
msgstr "tarantool> box.space.tester:update({999}, {{'=', 2, 'Tarantino'}})"

msgid ""
":ref:`UPSERT <box_space-upsert>`: Upsert the tuple, changing field "
"field[2] again."
msgstr ""
":ref:`UPSERT <box_space-upsert>`: обновить или вставить кортеж, снова "
"изменяя поле field[2]."

msgid ""
"The syntax of ``upsert()`` is similar to the syntax of ``update()``. "
"However, the execution logic of these two requests is different. UPSERT "
"is either UPDATE or INSERT, depending on the database's state. Also, "
"UPSERT execution is postponed until after transaction commit, so, unlike "
"``update()``, ``upsert()`` doesn't return data back."
msgstr ""
"Синтаксис ``upsert()`` похож на синтаксис ``update()``. Однако логика "
"выполнения двух запросов отличается. UPSERT означает UPDATE или INSERT, в"
" зависимости от состояния базы данных. Кроме того, выполнение UPSERT "
"откладывается до коммита транзакции, поэтому в отличие от``update()``, "
"``upsert()`` не возвращает данные."

msgid ""
"tarantool> box.space.tester:upsert({999, 'Taranted'}, {{'=', 2, "
"'Tarantism'}})"
msgstr ""
"tarantool> box.space.tester:upsert({999, 'Taranted'}, {{'=', 2, "
"'Tarantism'}})"

msgid ":ref:`REPLACE <box_space-replace>`: Replace the tuple, adding a new field."
msgstr ":ref:`REPLACE <box_space-replace>`: заменить кортеж, добавляя новое поле."

msgid ""
"This is also possible with the ``update()`` request, but the ``update()``"
" request is usually more complicated."
msgstr ""
"Это действие также можно выполнить с помощью запроса ``update()``, но "
"обычно запрос ``update()`` более сложен."

msgid "tarantool> box.space.tester:replace{999, 'Tarantella', 'Tarantula'}"
msgstr "tarantool> box.space.tester:replace{999, 'Tarantella', 'Tarantula'}"

msgid ":ref:`SELECT <box_space-select>`: Retrieve the tuple."
msgstr ":ref:`SELECT <box_space-select>`: провести выборку кортежа."

msgid ""
"The clause \"{999}\" is still mandatory, although it does not have to "
"mention the primary key."
msgstr ""
"Оператор \"{999}\" все еще обязателен, хотя в нем не должен упоминаться "
"первичный ключ."

msgid "tarantool> box.space.tester:select{999}"
msgstr "tarantool> box.space.tester:select{999}"

msgid ":ref:`DELETE <box_space-delete>`: Delete the tuple."
msgstr ":ref:`DELETE <box_space-delete>`: удалить кортеж."

msgid "In this example, we identify the primary-key field."
msgstr ""
"В этом примере мы определяем поле, соответствующее ключу в первичном "
"индексе."

msgid "tarantool> box.space.tester:delete{999}"
msgstr "tarantool> box.space.tester:delete{999}"

msgid "Summarizing the examples:"
msgstr "Подводя итоги по примерам:"

msgid ""
"Functions ``insert`` and ``replace`` accept a tuple (where a primary key "
"comes as part of the tuple)."
msgstr ""
"Функции ``insert`` и ``replace`` принимают кортеж (где первичный ключ -- "
"это часть кортежа)."

msgid ""
"Function ``upsert`` accepts a tuple (where a primary key comes as part of"
" the tuple), and also the update operations to execute."
msgstr ""
"Функция ``upsert`` принимает кортеж (где первичный ключ -- это часть "
"кортежа), а также операции по обновлению."

msgid ""
"Function ``delete`` accepts a full key of any unique index (primary or "
"secondary)."
msgstr ""
"Функция ``delete`` принимает полный ключ любого уникального индекса "
"(первичный или вторичный)."

msgid ""
"Function ``update`` accepts a full key of any unique index (primary or "
"secondary), and also the operations to execute."
msgstr ""
"Функция  ``update`` принимает полный ключ любого уникального индекса "
"(первичный или вторичный), а также операции к выполнению."

msgid ""
"Function ``select`` accepts any key: primary/secondary, unique/non-"
"unique, full/partial."
msgstr ""
"Функция ``select`` принимает любой ключ: первичный/вторичный, "
"уникальный/неуникальный, полный/часть."

msgid ""
"See reference on ``box.space`` for more :ref:`details on using data "
"operations <box_space-operations-detailed-examples>`."
msgstr ""
"Для получения более :ref:`подробной информации по использованию операций "
"с данными <box_space-operations-detailed-examples>` см. справочник по "
"``box.space``."

msgid ""
"Besides Lua, you can use :ref:`Perl, PHP, Python or other programming "
"language connectors <index-box_connectors>`. The client server protocol "
"is open and documented. See this :ref:`annotated BNF <box_protocol-"
"iproto_protocol>`."
msgstr ""
"Помимо Lua можно использовать :ref:`коннекторы к Perl, PHP, Python или "
"другому языку программирования <index-box_connectors>`. Клиент-серверный "
"протокол открыт и задокументирован. См. :ref:`БНФ с комментариями "
"<box_protocol-iproto_protocol>`."

msgid "Index operations"
msgstr "Операции с индексами"

msgid ""
"Index operations are automatic: if a data-manipulation request changes a "
"tuple, then it also changes the index keys defined for the tuple."
msgstr ""
"Операции с индексами производятся автоматически. Если запрос по "
"манипулированию данными меняет данные в кортеже, то меняются и ключи в "
"индексе для данного кортежа."

msgid "The simple index-creation operation that we've illustrated before is:"
msgstr ""
"Простая операция по созданию индекса, которую мы рассматривали ранее, "
"выглядит следующим образом:"

msgid ":samp:`box.space.{space-name}:create_index('{index-name}')`"
msgstr ""

msgid ""
"This creates a unique TREE index on the first field of all tuples (often "
"called \"Field#1\"), which is assumed to be numeric."
msgstr ""
"По умолчанию, при этом создается TREE-индекс по первому полю для всех "
"кортежей (обычно его называют \"Field#1\"). Предполагается, что "
"индексируемое поле является числовым."

msgid "The simple SELECT request that we've illustrated before is:"
msgstr "Вот простой SELECT-запрос, который мы рассматривали ранее:"

msgid ":extsamp:`box.space.{*{space-name}*}:select({*{value}*})`"
msgstr ":extsamp:`box.space.{*{space-name}*}:select({*{value}*})`"

msgid ""
"This looks for a single tuple via the first index. Since the first index "
"is always unique, the maximum number of returned tuples will be: one. You"
" can call ``select()`` without arguments, causing all tuples to be "
"returned."
msgstr ""
"Такой запрос ищет отдельный кортеж по первичному индексу. Поскольку "
"первичный индекс всегда уникален, то данный запрос вернет не более одного"
" кортежа. Можно также вызвать ``select()`` без аргументов, чтобы вернуть "
"все кортежи."

msgid ""
"Let's continue working with the space 'tester' created in the "
":ref:`\"Getting started\" exercises <getting_started>`:"
msgstr ""
"Продолжим работу со спейсом 'tester', созданным в упражнениях из "
":ref:`\"Руководства для начинающих\" <getting_started>`:"

msgid ""
"-- Let's modify our space 'tester'\n"
"tarantool> box.space.tester:format({\n"
"         > {name = 'id', type = 'unsigned'},\n"
"         > {name = 'band_name', type = 'string'},\n"
"         > {name = 'year', type = 'unsigned'},\n"
"         > {name = 'rate', type = 'unsigned', is_nullable=true}})\n"
"---\n"
"...\n"
"-- Create an index with three parts\n"
"tarantool> box.space.tester:create_index('tertiary', {parts = {{field = "
"2, type = 'string'},{field=3, type='unsigned'}, {field=4, "
"type='unsigned'}}})\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: string\n"
"    is_nullable: false\n"
"    fieldno: 2\n"
"  - type: unsigned\n"
"    is_nullable: false\n"
"    fieldno: 3\n"
"  - type: unsigned\n"
"    is_nullable: true\n"
"    fieldno: 4\n"
"  id: 6\n"
"  space_id: 513\n"
"  type: TREE\n"
"  name: tertiary\n"
"...\n"
"-- And make sure it has three parts\n"
"tarantool> box.space.tester.index.tertiary.parts\n"
"---\n"
"- - type: string\n"
"    is_nullable: false\n"
"    fieldno: 2\n"
"  - type: unsigned\n"
"    is_nullable: false\n"
"    fieldno: 3\n"
"  - type: unsigned\n"
"    is_nullable: true\n"
"    fieldno: 4\n"
"...\n"
"-- Add the rate to the tuple #1\n"
"tarantool> box.space.tester:update(1, {{'=', 4, 5}})\n"
"---\n"
"- [1, 'Roxette', 1986, 5]\n"
"...\n"
"-- And insert another tuple\n"
"tarantool> box.space.tester:insert({4, 'Roxette', 2016, 5})\n"
"---\n"
"- [4, 'Roxette', 2016, 5]\n"
"..."
msgstr ""
"-- Немного изменим наш спейс 'tester'\n"
"tarantool> box.space.tester:format({\n"
"         > {name = 'id', type = 'unsigned'},\n"
"         > {name = 'band_name', type = 'string'},\n"
"         > {name = 'year', type = 'unsigned'},\n"
"         > {name = 'rate', type = 'unsigned', is_nullable=true}})\n"
"---\n"
"...\n"
"-- Создадим индекс из трех частей\n"
"tarantool> box.space.tester:create_index('tertiary', {parts = {{field = "
"2, type = 'string'},{field=3, type='unsigned'}, {field=4, "
"type='unsigned'}}})\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: string\n"
"    is_nullable: false\n"
"    fieldno: 2\n"
"  - type: unsigned\n"
"    is_nullable: false\n"
"    fieldno: 3\n"
"  - type: unsigned\n"
"    is_nullable: true\n"
"    fieldno: 4\n"
"  id: 6\n"
"  space_id: 513\n"
"  type: TREE\n"
"  name: tertiary\n"
"...\n"
"-- И убедимся, что частей именно три\n"
"tarantool> box.space.tester.index.tertiary.parts\n"
"---\n"
"- - type: string\n"
"    is_nullable: false\n"
"    fieldno: 2\n"
"  - type: unsigned\n"
"    is_nullable: false\n"
"    fieldno: 3\n"
"  - type: unsigned\n"
"    is_nullable: true\n"
"    fieldno: 4\n"
"...\n"
"-- Добавим кортежу #1 значение для поля 'rate'\n"
"tarantool> box.space.tester:update(1, {{'=', 4, 5}})\n"
"---\n"
"- [1, 'Roxette', 1986, 5]\n"
"...\n"
"-- И вставим еще один кортеж\n"
"tarantool> box.space.tester:insert({4, 'Roxette', 2016, 5})\n"
"---\n"
"- [4, 'Roxette', 2016, 5]\n"
"..."

msgid "The existing SELECT variations:"
msgstr "Существующие вариации SELECT:"

msgid "The search can use comparisons other than equality."
msgstr ""
"Помимо условия равенства, при поиске могут использоваться и другие "
"условия сравнения."

msgid ""
"tarantool> box.space.tester:select(1, {iterator = 'GT'})\n"
"---\n"
"- - [2, 'Scorpions', 2015]\n"
"  - [3, 'Ace of Base', 1993]\n"
"  - [4, 'Roxette', 2016, 5]\n"
"..."
msgstr ""

msgid ""
"The :ref:`comparison operators <box_index-iterator-types>` are LT, LE, "
"EQ, REQ, GE, GT (for \"less than\", \"less than or equal\", \"equal\", "
"\"reversed equal\", \"greater than or equal\", \"greater than\" "
"respectively). Comparisons make sense if and only if the index type is "
"‘TREE'."
msgstr ""
"Можно использовать следующие :ref:`операторы сравнения <box_index-"
"iterator-types>`: LT (меньше), LE (меньше  или равно), EQ (равно, "
"результаты отсортированы в порядке возрастания по ключу), REQ (равно, "
"результаты отсортированы в порядке убывания по ключу), GE (больше или "
"равно), GT (больше). Сравнения имеют смысл только для индексов типа "
"'TREE'."

msgid ""
"This type of search may return more than one tuple; if so, the tuples "
"will be in descending order by key when the comparison operator is LT or "
"LE or REQ, otherwise in ascending order."
msgstr ""
"Этот вариант поиска может вернуть более одного кортежа. В таком случае "
"кортежи будут отсортированы в порядке убывания по ключу (если "
"использовался оператор LT, LE или REQ), либо в порядке возрастания (во "
"всех остальных случаях)."

msgid "The search can use a secondary index."
msgstr "Поиск может производиться по вторичному индексу."

msgid ""
"tarantool> box.space.tester.index.secondary:select({'Ace of Base'})\n"
"---\n"
"- - [3, 'Ace of Base', 1993]\n"
"..."
msgstr ""

msgid ""
"For a primary-key search, it is optional to specify an index name. For a "
"secondary-key search, it is mandatory."
msgstr ""
"При поиске по первичному индексу имя индекса можно не указывать. При "
"поиске же по вторичному индексу имя индекса указывать необходимо."

msgid ""
"The search may be for some or all key parts but should contain the "
"prefix of the key. Notice that partial key searches are available only in"
" TREE indexes."
msgstr ""
"Поиск может осуществляться по некоторым или по всем частям ключа, но "
"должен содержать префикс ключа. Обратите внимание, что частичный поиск по"
" частям ключа доступен только в TREE индексах."

msgid ""
"tarantool> box.space.tester.index.tertiary:select({'Roxette', 2016})\n"
"---\n"
"- - [1, 'Roxette', 2016, 5]\n"
"...\n"
"tarantool> box.space.tester.index.tertiary:select({'Roxette', nil, 5})\n"
"---\n"
"- - [1, 'Roxette', 1986, 5]\n"
"  - [4, 'Roxette', 2016, 5]\n"
"..."
msgstr ""

msgid "The search may be for all fields, using a table for the value:"
msgstr "Поиск может производиться по всем полям с использованием таблицы значений:"

msgid ""
"tarantool> box.space.tester.index.tertiary:select({'Roxette', 2016 ,5})\n"
"---\n"
"- - [4, 'Roxette', 2016, 5]\n"
"..."
msgstr ""

msgid "or the search can be for one field, using a table or a scalar:"
msgstr ""
"либо же по одному полю (в этом случае используется таблица или скалярное "
"значение):"

msgid ""
"tarantool> box.space.tester.index.tertiary:select('Roxette')\n"
"---\n"
"- - [1, 'Roxette', 1986, 5]\n"
"  - [4, 'Roxette', 2016, 5]\n"
"..."
msgstr ""

msgid "Working with BITSET and RTREE"
msgstr "Работа с BITSET и RTREE"

msgid "**BITSET example:**"
msgstr "**Примеры BITSET:**"

msgid ""
"tarantool> box.schema.space.create('bitset_example')\n"
"tarantool> box.space.bitset_example:create_index('primary')\n"
"tarantool> "
"box.space.bitset_example:create_index('bitset',{unique=false,type='BITSET',"
" parts={2,'unsigned'}})\n"
"tarantool> box.space.bitset_example:insert{1,1}\n"
"tarantool> box.space.bitset_example:insert{2,4}\n"
"tarantool> box.space.bitset_example:insert{3,7}\n"
"tarantool> box.space.bitset_example:insert{4,3}\n"
"tarantool> box.space.bitset_example.index.bitset:select(2, "
"{iterator='BITS_ANY_SET'})"
msgstr ""
"tarantool> box.schema.space.create('bitset_example')\n"
"tarantool> box.space.bitset_example:create_index('primary')\n"
"tarantool> "
"box.space.bitset_example:create_index('bitset',{unique=false,type='BITSET',"
" parts={2,'unsigned'}})\n"
"tarantool> box.space.bitset_example:insert{1,1}\n"
"tarantool> box.space.bitset_example:insert{2,4}\n"
"tarantool> box.space.bitset_example:insert{3,7}\n"
"tarantool> box.space.bitset_example:insert{4,3}\n"
"tarantool> box.space.bitset_example.index.bitset:select(2, "
"{iterator='BITS_ANY_SET'})"

msgid "The result will be:"
msgstr "Мы получим следующий результат:"

msgid ""
"---\n"
"- - [3, 7]\n"
"  - [4, 3]\n"
"..."
msgstr ""
"---\n"
"- - [3, 7]\n"
"  - [4, 3]\n"
"..."

msgid "because (7 AND 2) is not equal to 0, and (3 AND 2) is not equal to 0."
msgstr "поскольку (7 AND 2) не равно 0 и (3 AND 2) не равно 0."

msgid "**RTREE example:**"
msgstr "**Примеры RTREE:**"

msgid ""
"tarantool> box.schema.space.create('rtree_example')\n"
"tarantool> box.space.rtree_example:create_index('primary')\n"
"tarantool> "
"box.space.rtree_example:create_index('rtree',{unique=false,type='RTREE', "
"parts={2,'ARRAY'}})\n"
"tarantool> box.space.rtree_example:insert{1, {3, 5, 9, 10}}\n"
"tarantool> box.space.rtree_example:insert{2, {10, 11}}\n"
"tarantool> box.space.rtree_example.index.rtree:select({4, 7, 5, 9}, "
"{iterator = 'GT'})"
msgstr ""
"tarantool> box.schema.space.create('rtree_example')\n"
"tarantool> box.space.rtree_example:create_index('primary')\n"
"tarantool> "
"box.space.rtree_example:create_index('rtree',{unique=false,type='RTREE', "
"parts={2,'ARRAY'}})\n"
"tarantool> box.space.rtree_example:insert{1, {3, 5, 9, 10}}\n"
"tarantool> box.space.rtree_example:insert{2, {10, 11}}\n"
"tarantool> box.space.rtree_example.index.rtree:select({4, 7, 5, 9}, "
"{iterator = 'GT'})"

msgid ""
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"..."
msgstr ""
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"..."

msgid ""
"because a rectangle whose corners are at coordinates ``4,7,5,9`` is "
"entirely within a rectangle whose corners are at coordinates "
"``3,5,9,10``."
msgstr ""
"поскольку прямоугольник с углами в координатах ``4,7,5,9`` лежит целиком "
"внутри прямоугольника с углами в координатах ``3,5,9,10``."

msgid ""
"Additionally, there exist :ref:`index iterator operations <box_index-"
"index_pairs>`. They can only be used with code in Lua and C/C++. Index "
"iterators are for traversing indexes one key at a time, taking advantage "
"of features that are specific to an index type, for example evaluating "
"Boolean expressions when traversing BITSET indexes, or going in "
"descending order when traversing TREE indexes."
msgstr ""
"Кроме того, есть :ref:`операции с итераторами с индексом <box_index-"
"index_pairs>`. Их можно использовать только с кодом на языках Lua и "
"C/C++. Итераторы с индексом предназначены для обхода индексов по одному "
"ключу за раз, поскольку используют особенности каждого типа индекса, "
"например оценка логических выражений при обходе BITSET-индексов или обход"
" TREE-индексов в порядке по убыванию."

msgid ""
"See also other index operations like :ref:`alter() <box_index-alter>` "
"(modify index) and :ref:`drop() <box_index-drop>` (delete index) in "
"reference for :ref:`box.index <box_index>` submodule."
msgstr ""
"Полный список операций над индексами, таких как :ref:`alter() <box_index-"
"alter>` (изменение индекса) и :ref:`drop() <box_index-drop>` (удаление "
"индекса), приводится во вложенном модуле :ref:`box.index <box_index>`."

msgid "Complexity factors"
msgstr "Факторы сложности"

msgid ""
"In reference for :ref:`box.space <box_space>` and :ref:`box.index "
"<box_index>` submodules, there are notes about which complexity factors "
"might affect the resource usage of each function."
msgstr ""
"Во вложенных модулях :ref:`box.space <box_space>` и :ref:`box.index "
"<box_index>` содержится информация о том, как факторы сложности могут "
"повлиять на использование каждой функции."

msgid "Complexity factor"
msgstr "Фактор сложности"

msgid "Effect"
msgstr "Эффект"

msgid "Index size"
msgstr "Размер индекса"

msgid ""
"The number of index keys is the same as the number of tuples in the data "
"set. For a TREE index, if there are more keys, then the lookup time will "
"be greater, although of course the effect is not linear. For a HASH "
"index, if there are more keys, then there is more RAM used, but the "
"number of low-level steps tends to remain constant."
msgstr ""
"Количество ключей в индексе равно количеству кортежей в наборе данных. В "
"случае с TREE-индексом: с ростом количества ключей увеличивается время "
"поиска, хотя зависимость здесь, конечно же, не линейная. В случае с "
"HASH-индексом: с ростом количества ключей увеличивается объем оперативной"
" памяти, но количество низкоуровневых шагов остается примерно тем же."

msgid ""
"Typically, a HASH index is faster than a TREE index if the number of "
"tuples in the space is greater than one."
msgstr ""
"Как правило, поиск по HASH-индексу работает быстрее, чем по TREE-индексу,"
"  если в спейсе более одного кортежа."

msgid "Number of indexes accessed"
msgstr "Количество обращений к индексам"

msgid ""
"Ordinarily, only one index is accessed to retrieve one tuple. But to "
"update the tuple, there must be N accesses if the space has N different "
"indexes."
msgstr ""
"Обычно для выборки значений одного кортежа используется только один "
"индекс. Но при обновлении значений в кортеже требуется N обращений, если "
"в спейсе N индексов."

msgid ""
"Note re storage engine: Vinyl optimizes away such accesses if secondary "
"index fields are unchanged by the update. So, this complexity factor "
"applies only to memtx, since it always makes a full-tuple copy on every "
"update."
msgstr ""
"Примечание по движку базы данных: Vinyl отклоняет такой доступ, если "
"обновление не затрагивает поля вторичного индекса. Таким образом, этот "
"фактор сложности влияет только на memtx, поскольку он всегда создает "
"копию всего кортежа при каждом обновлении."

msgid "Number of tuples accessed"
msgstr "Количество обращений к кортежам"

msgid ""
"A few requests, for example SELECT, can retrieve multiple tuples. This "
"factor is usually less important than the others."
msgstr ""
"Некоторые запросы, например SELECT, могут возвращать несколько кортежей. "
"Как правило, это наименее важный фактор из всех."

msgid "WAL settings"
msgstr "Настройки WAL"

msgid ""
"The important setting for the write-ahead log is :ref:`wal_mode "
"<cfg_binary_logging_snapshots-wal_mode>`. If the setting causes no "
"writing or delayed writing, this factor is unimportant. If the setting "
"causes every data-change request to wait for writing to finish on a slow "
"device, this factor is more important than all the others."
msgstr ""
"Важным параметром для записи в WAL является :ref:`wal_mode "
"<cfg_binary_logging_snapshots-wal_mode>`. Если запись в WAL отключена или"
" задана запись с задержкой, но этот фактор не так важен. Если же запись в"
"  WAL производится при каждом запросе на изменение данных, то при каждом "
"таком запросе приходится ждать, пока отработает обращение к более "
"медленному диску, и данный фактор становится важнее всех остальных."
