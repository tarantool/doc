
msgid "Indexes"
msgstr "Индексы"

msgid ""
"An **index** is a special data structure that stores a group of key "
"values and pointers. It is used for efficient manipulations with data and"
" should be chosen depending on the task."
msgstr ""
"**Индекс** — это специальная структура данных, которая хранит группу "
"ключевых значений и указателей. Индекс используется для эффективного "
"управления данными, а выбор индекса зависит от выполняемой задачи."

msgid ""
"As with spaces, you should specify the index **name**, and let Tarantool "
"come up with a unique **numeric identifier** (\"index id\")."
msgstr ""
"Как и для спейсов, индексам следует указать **имена**, а Tarantool "
"определит уникальный **числовой идентификатор** (\"ID индекса\")."

msgid ""
"An index may be **multi-part**, that is, you can declare that an index "
"key value is composed of two or more fields in the tuple, in any order. "
"For example, for an ordinary TREE index, the maximum number of parts is "
"255."
msgstr ""
"Индекс может быть **многокомпонентным**, то есть можно объявить, что ключ"
" индекса состоит из двух или более полей в кортеже в любом порядке. "
"Например, для обычного TREE-индекса максимальное количество частей равно "
"255."

msgid ""
"An index may be **unique**, that is, you can declare that it would be "
"illegal to have the same key value twice."
msgstr ""
"Индекс может быть **уникальным**, то есть можно объявить, что недопустимо"
" дважды задавать одно значение ключа."

msgid ""
"The first index defined on a space is called the **primary key index**, "
"and it must be unique. All other indexes are called **secondary "
"indexes**, and they may be non-unique."
msgstr ""
"Первый индекс, определенный для спейса, называется **первичный индекс**. "
"Он должен быть уникальным. Все остальные индексы называются **вторичными "
"индексами**, они могут строиться по неуникальным значениям."

msgid ""
"Indexes have certain limitations. See details on page :doc:`Limitations "
"</book/box/limitations>`."
msgstr ""
"На индексы распространяются определенные ограничения. Более подробную "
"информацию см. на странице :doc:`Ограничения </book/box/limitations>`."

msgid "Creating an index"
msgstr "Создание индекса"

msgid ""
"An index definition may include identifiers of tuple fields and their "
"expected **types**. See allowed indexed field types in section "
":ref:`Details about indexed field types "
"<details_about_index_field_types>`."
msgstr ""
"Индекс может содержать идентификаторы полей кортежа и их предполагаемые "
"**типы**. См. допустимые типы полей в разделе :ref:`Описание типов "
"индексируемых полей <details_about_index_field_types>`."

msgid ""
"A recommended design pattern for a data model is to base primary keys on "
"the first fields of a tuple, because this speeds up tuple comparison."
msgstr ""
"Рекомендуется проектировать модель данных так, чтобы первичные ключи были"
" первыми полями в котреже, чтобы их было быстрее сравнивать."

msgid ""
"Let's look at an example where we first define the primary index (named "
"'primary') based on field #1 of each tuple:"
msgstr ""
"Рассмотрим пример, где для начала мы определяем первичный индекс (под "
"названием 'primary') по полю №1 каждого кортежа:"

msgid ""
"tarantool> i = s:create_index('primary', {type = 'hash', parts = {{field "
"= 1, type = 'unsigned'}}}"
msgstr ""
"tarantool> i = s:create_index('primary', {type = 'hash', parts = {{field "
"= 1, type = 'unsigned'}}}"

msgid ""
"The effect is that, for all tuples in space 'tester', field #1 must exist"
" and must contain an unsigned integer. The index type is HASH, so values "
"in field #1 must be unique, because keys in HASH indexes are unique."
msgstr ""
"Смысл в том, что все кортежи в спейсе 'tester' должны иметь поле №1, "
"которое содержит целое число без знака. Тип индекса — HASH, поэтому "
"значения в поле №1 должны быть уникальными, поскольку ключи в "
"HASH-индексах уникальны."

msgid ""
"After that, let's define a secondary index (named 'secondary') based on "
"field #2 of each tuple:"
msgstr ""
"После этого определим вторичный индекс (под названием 'secondary') по "
"полю №2 каждого кортежа:"

msgid ""
"tarantool> i = s:create_index('secondary', {type = 'tree', parts = {field"
" = 2, type = 'string'}})"
msgstr ""
"tarantool> i = s:create_index('secondary', {type = 'tree', parts = {field"
" = 2, type = 'string'}})"

msgid ""
"The effect is that, for all tuples in space 'tester', field #2 must exist"
" and must contain a string. The index type is TREE, so values in field #2"
" must not be unique, because keys in TREE indexes may be non-unique."
msgstr ""
"Смысл в том, что все кортежи в спейсе 'tester' должны иметь поле №2, "
"которое содержит строку. Тип индекса — TREE, поэтому значения в поле №2 "
"не должны быть уникальными, поскольку ключи в TREE-индексах могут не быть"
" уникальными."

msgid ""
"Space definitions and index definitions are stored permanently in "
"Tarantool's system spaces :ref:`_space <box_space-space>` and "
":ref:`_index <box_space-index>` (for details, see reference on "
":ref:`box.space <box_space>` submodule)."
msgstr ""
"Определения спейса и определения индексов хранятся в системных спейсах "
"Tarantool'а :ref:`_space <box_space-space>` и :ref:`_index <box_space-"
"index>` соответственно (для получения подробной информации см. справочник"
" по вложенному модулю :ref:`box.space <box_space>`)."

msgid "Tip"
msgstr "Примечание"

msgid ""
"The full information about creating an index is in section "
":doc:`/reference/reference_lua/box_space/create_index`."
msgstr ""
"Полная информация о создании индекса приведена в разделе "
":doc:`/reference/reference_lua/box_space/create_index`."

msgid "Index types"
msgstr "Типы индексов"

msgid ""
"An index always has a **type**. Different types are intended for "
"different usage scenarios."
msgstr ""
"Индекс всегда относится к определенному **типу**. Для разных сценариев "
"использования требуются разные типы индексов."

msgid "We give an overview of index features in the following table:"
msgstr "Обзор характеристик индексов приведен в следующей таблице:"

msgid "Feature"
msgstr "Характеристика"

msgid "TREE"
msgstr "TREE"

msgid "HASH"
msgstr "HASH"

msgid "RTREE"
msgstr "RTREE"

msgid "BITSET"
msgstr "BITSET"

msgid "unique"
msgstr "уникальный"

msgid "\\+"
msgstr "\\+"

msgid "\\-"
msgstr "\\-"

msgid "non-unique"
msgstr "неуникальный"

msgid ":ref:`is_nullable <box_space-is_nullable>`"
msgstr ":ref:`is_nullable <box_space-is_nullable>`"

msgid "can be multi-part"
msgstr "может быть многокомпонентным"

msgid ":ref:`multikey <box_space-path_multikey>`"
msgstr ":ref:`многоключевой <box_space-path_multikey>`"

msgid ":ref:`partial-key search <partial_key_search>`"
msgstr ":ref:`поиск по части ключа <partial_key_search>`"

msgid "can be primary key"
msgstr "может быть по первичному ключу"

msgid "``exclude_null`` (version 2.8+)"
msgstr "``exclude_null`` (версии 2.8+)"

msgid ":doc:`iterator types </reference/reference_lua/box_index/pairs>`"
msgstr ":doc:`типы итераторов </reference/reference_lua/box_index/pairs>`"

msgid "ALL, EQ, REQ, GT, GE, LT, LE"
msgstr "ALL, EQ, REQ, GT, GE, LT, LE"

msgid "ALL, EQ, GT"
msgstr "ALL, EQ, GT"

msgid "ALL, EQ, GT, GE, LT, LE, OVERLAPS, NEIGHBOR"
msgstr "ALL, EQ, GT, GE, LT, LE, OVERLAPS, NEIGHBOR"

msgid "ALL, EQ, BITS_ALL_SET, BITS_ANY_SET, BITS_ALL_NOT_SET"
msgstr "ALL, EQ, BITS_ALL_SET, BITS_ANY_SET, BITS_ALL_NOT_SET"

msgid "TREE indexes"
msgstr "TREE-индексы"

msgid ""
"The default index type is 'TREE'. TREE indexes are provided by memtx and "
"vinyl engines, can index unique and non-unique values, support partial "
"key searches, comparisons and ordered results."
msgstr ""
"Тип индекса по умолчанию — 'TREE'. Движки memtx и vinyl предоставляют "
"TREE-индексы, которые могут индексировать уникальные и неуникальные "
"значения, поддерживают поиск по компонентам ключа, сравнение ключей и "
"упорядоченные результаты."

msgid ""
"This is a universal type of indexes, for most cases it will be the best "
"choice."
msgstr ""
"Это универсальный тип индексов, в большинстве случаев он подойдет лучше "
"всего."

msgid "Additionally, memtx engine supports HASH, RTREE and BITSET indexes."
msgstr ""
"Кроме того, движок memtx поддерживает следующие типы индексов: HASH, "
"RTREE и BITSET."

msgid "HASH indexes"
msgstr "HASH-индексы"

msgid ""
"HASH indexes require unique fields and loses to TREE in almost all "
"respects. So we do not recommend to use it in the applications. HASH is "
"now present in Tarantool mainly because of backward compatibility."
msgstr ""
"HASH-индексы требуют уникальности полей и почти во всех отношениях "
"проигрывают индексам типа TREE. Поэтому мы не рекомендуем использовать их"
" в приложениях. В настоящее время Tarantool поддерживает HASH в основном "
"для обратной совместимости."

msgid "Here are some tips. Do not use HASH index:"
msgstr "Вот несколько советов. Не используйте HASH-индекс:"

msgid "just if you want to"
msgstr "если просто хочется"

msgid "if you think that HASH is faster with no performance metering"
msgstr "если вы думаете, что HASH быстрее, без учета производительности"

msgid "if you want to iterate over the data"
msgstr "если вы хотите выполнять перебор данных"

msgid "for primary key"
msgstr "по первичному ключу"

msgid "as an only index"
msgstr "как единственный индекс"

msgid "Use HASH index:"
msgstr "Используйте HASH-индекс:"

msgid "if it is a secondary key"
msgstr "на вторичный ключ"

msgid "if you 100% won't need to make it non-unique"
msgstr "если вы на сто процентов уверены, что его не придется делать неуникальным"

msgid "if you really need that 2-5% performance improvement"
msgstr "если действительно нужно улучшение производительности на 2-5%"

msgid ""
"if you have taken measurements on your data and you see an increase in "
"performance"
msgstr ""
"если вы провели измерения по данным и увидели увеличение "
"производительности"

msgid "if you save every byte on tuples (HASH is a little more compact)"
msgstr "если вы экономите каждый байт на кортежах (HASH немного компактнее)"

msgid "RTREE indexes"
msgstr "RTREE-индексы"

msgid ""
"RTREE is a multidimensional index supporting up to 20 dimensions. It is "
"used especially for indexing spatial information, such as geographical "
"objects. In :ref:`this example <box_index-rtree>` we demonstrate spatial "
"searches via RTREE index."
msgstr ""
"RTREE — это многомерный индекс, который поддерживает до 20 измерений. Он "
"используется, в частности, для индексирования пространственной "
"информации, такой как географические объекты. В :ref:`этом примере "
"<box_index-rtree>` мы показываем, как использовать пространственный поиск"
" с помощью RTREE-индекса."

msgid ""
"RTREE index could not be primary, and could not be unique. The option "
"list of this type of index may contain ``dimension`` and ``distance`` "
"options. The ``parts`` definition must contain the one and only part with"
" type ``array``. RTREE index can accept two types of ``distance`` "
"functions: ``euclid`` and ``manhattan``."
msgstr ""
"RTREE-индекс не может быть первичным и не может быть уникальным. Индекс "
"такого типа может содержать параметры измерения и расстояния — "
"``dimension`` и ``distance`` соответственно. Определение ``parts`` должно"
" включать только один компонент типа ``array``. RTREE-индекс может "
"принимать два типа функции расстояния ``distance``: ``euclid``, то есть "
"Евклидова метрика, или ``manhattan``, то есть расстояние городских "
"кварталов."

msgid "**Example 1:**"
msgstr "**Пример 1:**"

msgid ""
"s = box.schema.create_space(\"test\")\n"
"i = s:create_index('primary', { type = 'HASH', parts = {1, 'num'} })\n"
"r = s:create_index('spatial', { type = 'RTREE', unique = false, parts = "
"{2, 'array'} })"
msgstr ""
"s = box.schema.create_space(\"test\")\n"
"i = s:create_index('primary', { type = 'HASH', parts = {1, 'num'} })\n"
"r = s:create_index('spatial', { type = 'RTREE', unique = false, parts = "
"{2, 'array'} })"

msgid ""
"Corresponding tuple field thus must be an array of 2 or 4 numbers. 2 "
"numbers mean a point {x, y}; 4 numbers mean a rectangle {x1, y1, x2, y2},"
" where (x1, y1) and (x2, y2) - diagonal point of the rectangle."
msgstr ""
"Таким образом, соответствующее поле кортежа может быть массивом типа "
"array из 2 или 4 чисел. 2 числа обозначают точку {x, y}; 4 числа "
"обозначают прямоугольник {x1, y1, x2, y2}, где (x1, y1) и (x2, y2) — "
"диагональные точки прямоугольника."

msgid ""
"s:insert{1, {1, 1}}\n"
"s:insert{2, {2, 2, 3, 3}}"
msgstr ""
"s:insert{1, {1, 1}}\n"
"s:insert{2, {2, 2, 3, 3}}"

msgid ""
"Selection results depend on a chosen iterator. The default EQ iterator "
"searches for an exact rectangle, a point is treated as zero width and "
"height rectangle:"
msgstr ""
"Результаты выборки зависят от выбранного итератора. Итератор EQ, который "
"используется по умолчанию, ищет точный прямоугольник, точка "
"рассматривается как прямоугольник нулевой ширины и высоты:"

msgid ""
"tarantool> r:select{1, 1}\n"
"---\n"
"- - [1, [1, 1]]\n"
"...\n"
"\n"
"tarantool> r:select{1, 1, 1, 1}\n"
"---\n"
"- - [1, [1, 1]]\n"
"...\n"
"\n"
"tarantool> r:select{2, 2}\n"
"---\n"
"- []\n"
"...\n"
"\n"
"tarantool> r:select{2, 2, 3, 3}\n"
"---\n"
"- - [2, [2, 2, 3, 3]]\n"
"..."
msgstr ""
"tarantool> r:select{1, 1}\n"
"---\n"
"- - [1, [1, 1]]\n"
"...\n"
"\n"
"tarantool> r:select{1, 1, 1, 1}\n"
"---\n"
"- - [1, [1, 1]]\n"
"...\n"
"\n"
"tarantool> r:select{2, 2}\n"
"---\n"
"- []\n"
"...\n"
"\n"
"tarantool> r:select{2, 2, 3, 3}\n"
"---\n"
"- - [2, [2, 2, 3, 3]]\n"
"..."

msgid ""
"Iterator ALL, which is the default when no key is specified, selects all "
"tuples in arbitrary order:"
msgstr ""
"Итератор ALL, который используется по умолчанию, если не указан ключ, "
"выбирает все кортежи в произвольном порядке:"

msgid ""
"tarantool> r:select{}\n"
"---\n"
"- - [1, [1, 1]]\n"
"  - [2, [2, 2, 3, 3]]\n"
"..."
msgstr ""
"tarantool> r:select{}\n"
"---\n"
"- - [1, [1, 1]]\n"
"  - [2, [2, 2, 3, 3]]\n"
"..."

msgid ""
"Iterator LE (less or equal) searches for tuples with their rectangles "
"within a specified rectangle:"
msgstr ""
"Итератор LE (меньше или равно) ищет кортежи с прямоугольниками, которые "
"находятся в пределах заданного прямоугольника:"

msgid ""
"tarantool> r:select({1, 1, 2, 2}, {iterator='le'})\n"
"---\n"
"- - [1, [1, 1]]\n"
"..."
msgstr ""
"tarantool> r:select({1, 1, 2, 2}, {iterator='le'})\n"
"---\n"
"- - [1, [1, 1]]\n"
"..."

msgid ""
"Iterator LT (less than, or strictly less) searches for tuples with their "
"rectangles strictly within a specified rectangle:"
msgstr ""
"Итератор LT (меньше или строго меньше) ищет кортежи с прямоугольниками, "
"которые находятся строго в пределах заданного прямоугольника:"

msgid ""
"tarantool> r:select({0, 0, 3, 3}, {iterator='lt'})\n"
"---\n"
"- - [1, [1, 1]]\n"
"..."
msgstr ""
"tarantool> r:select({0, 0, 3, 3}, {iterator='lt'})\n"
"---\n"
"- - [1, [1, 1]]\n"
"..."

msgid ""
"Iterator GE searches for tuples with a specified rectangle within their "
"rectangles:"
msgstr ""
"Итератор GE ищет кортежи с прямоугольниками, в пределах которых находится"
" заданный прямоугольник:"

msgid ""
"tarantool> r:select({1, 1}, {iterator='ge'})\n"
"---\n"
"- - [1, [1, 1]]\n"
"..."
msgstr ""
"tarantool> r:select({1, 1}, {iterator='ge'})\n"
"---\n"
"- - [1, [1, 1]]\n"
"..."

msgid ""
"Iterator GT searches for tuples with a specified rectangle strictly "
"within their rectangles:"
msgstr ""
"Итератор GT ищет кортежи с прямоугольниками, строго в пределах которых "
"находится заданный прямоугольник:"

msgid ""
"tarantool> r:select({2.1, 2.1, 2.9, 2.9}, {itearator='gt'})\n"
"---\n"
"- []\n"
"..."
msgstr ""
"tarantool&gt; r:select({2.1, 2.1, 2.9, 2.9}, {itearator='gt'})\n"
"---\n"
"- []\n"
"..."

msgid ""
"Iterator OVERLAPS searches for tuples with their rectangles overlapping "
"specified rectangle:"
msgstr ""
"Итератор OVERLAPS ищет кортежи с прямоугольниками, перекрывающими "
"указанный прямоугольник:"

msgid ""
"tarantool> r:select({0, 0, 10, 2}, {iterator='overlaps'})\n"
"---\n"
"- - [1, [1, 1]]\n"
"  - [2, [2, 2, 3, 3]]\n"
"..."
msgstr ""
"tarantool> r:select({0, 0, 10, 2}, {iterator='overlaps'})\n"
"---\n"
"- - [1, [1, 1]]\n"
"  - [2, [2, 2, 3, 3]]\n"
"..."

msgid ""
"Iterator NEIGHBOR searches for all tuples and orders them by distance to "
"the specified point:"
msgstr ""
"Итератор NEIGHBOR ищет все кортежи и упорядочивает их по расстоянию до "
"заданной точки:"

msgid ""
"tarantool> for i=1,10 do\n"
"         >    for j=1,10 do\n"
"         >        s:insert{i*10+j, {i, j, i+1, j+1}}\n"
"         >    end\n"
"         > end\n"
"---\n"
"...\n"
"\n"
"tarantool> r:select({1, 1}, {iterator='neighbor', limit=5})\n"
"---\n"
"- - [11, [1, 1, 2, 2]]\n"
"  - [12, [1, 2, 2, 3]]\n"
"  - [21, [2, 1, 3, 2]]\n"
"  - [22, [2, 2, 3, 3]]\n"
"  - [31, [3, 1, 4, 2]]\n"
"..."
msgstr ""
"tarantool> for i=1,10 do\n"
"         >    for j=1,10 do\n"
"         >        s:insert{i*10+j, {i, j, i+1, j+1}}\n"
"         >    end\n"
"         > end\n"
"---\n"
"...\n"
"\n"
"tarantool> r:select({1, 1}, {iterator='neighbor', limit=5})\n"
"---\n"
"- - [11, [1, 1, 2, 2]]\n"
"  - [12, [1, 2, 2, 3]]\n"
"  - [21, [2, 1, 3, 2]]\n"
"  - [22, [2, 2, 3, 3]]\n"
"  - [31, [3, 1, 4, 2]]\n"
"..."

msgid "**Example 2:**"
msgstr "**Пример 2:**"

msgid ""
"3D, 4D and more dimensional RTREE indexes work in the same way as 2D "
"except that user must specify more coordinates in requests. Here's short "
"example of using 4D tree:"
msgstr ""
"RTREE для индексации 3-мерного, 4-мерного или многомерного пространства "
"используются так же, как и для двухмерного, только пользователь должен "
"указывать больше координат в запросах. Вот небольшой пример использования"
" дерева для 4-мерного пространства:"

msgid ""
"tarantool> s = box.schema.create_space('test')\n"
"---\n"
"...\n"
"\n"
"tarantool> i = s:create_index('primary', { type = 'HASH', parts = {1, "
"'num'} })\n"
"---\n"
"...\n"
"\n"
"tarantool> r = s:create_index('spatial', { type = 'RTREE', unique = "
"false, dimension = 4, parts = {2, 'array'} })\n"
"---\n"
"...\n"
"\n"
"tarantool> s:insert{1, {1, 2, 3, 4}} -- insert 4D point\n"
"---\n"
"- [1, [1, 2, 3, 4]]\n"
"...\n"
"\n"
"tarantool> s:insert{2, {1, 1, 1, 1, 2, 2, 2, 2}} -- insert 4D box\n"
"---\n"
"- [2, [1, 1, 1, 1, 2, 2, 2, 2]]\n"
"...\n"
"\n"
"tarantool> r:select{1, 2, 3, 4} -- find exact point\n"
"---\n"
"- - [1, [1, 2, 3, 4]]\n"
"...\n"
"\n"
"tarantool> r:select({0, 0, 0, 0, 3, 3, 3, 3}, {iterator = 'LE'}) -- "
"select from 4D box\n"
"---\n"
"- - [2, [1, 1, 1, 1, 2, 2, 2, 2]]\n"
"...\n"
"\n"
"tarantool> r:select({0, 0, 0, 0}, {iterator = 'neighbor'}) -- select "
"neighbours\n"
"---\n"
"- - [2, [1, 1, 1, 1, 2, 2, 2, 2]]\n"
"  - [1, [1, 2, 3, 4]]\n"
"..."
msgstr ""
"tarantool> s = box.schema.create_space('test')\n"
"---\n"
"...\n"
"\n"
"tarantool> i = s:create_index('primary', { type = 'HASH', parts = {1, "
"'num'} })\n"
"---\n"
"...\n"
"\n"
"tarantool> r = s:create_index('spatial', { type = 'RTREE', unique = "
"false, dimension = 4, parts = {2, 'array'} })\n"
"---\n"
"...\n"
"\n"
"tarantool> s:insert{1, {1, 2, 3, 4}} -- вставка 4D-точки\n"
"---\n"
"- [1, [1, 2, 3, 4]]\n"
"...\n"
"\n"
"tarantool> s:insert{2, {1, 1, 1, 1, 2, 2, 2, 2}} -- вставка 4D-тела\n"
"---\n"
"- [2, [1, 1, 1, 1, 2, 2, 2, 2]]\n"
"...\n"
"\n"
"tarantool> r:select{1, 2, 3, 4} -- поиск определенной точки\n"
"---\n"
"- - [1, [1, 2, 3, 4]]\n"
"...\n"
"\n"
"tarantool> r:select({0, 0, 0, 0, 3, 3, 3, 3}, {iterator = 'LE'}) -- "
"выборка из 4D-тела\n"
"---\n"
"- - [2, [1, 1, 1, 1, 2, 2, 2, 2]]\n"
"...\n"
"\n"
"tarantool> r:select({0, 0, 0, 0}, {iterator = 'neighbor'}) -- выборка "
"соседей\n"
"---\n"
"- - [2, [1, 1, 1, 1, 2, 2, 2, 2]]\n"
"  - [1, [1, 2, 3, 4]]\n"
"..."

msgid ""
"Don't forget that select NEIGHBOR iterator without limit extract entire "
"space in order of increasing distance and that could be tons of data with"
" corresponding performance."
msgstr ""
"Не забывайте, что итератор выборки соседей NEIGHBOR без ограничений "
"извлекает весь спейс в порядке возрастания расстояния, а это может быть "
"огромное количество данных, что повлечет за собой соответствующую "
"производительность."

msgid ""
"And another frequent mistake is to specify iterator type without quotes, "
"in such way: ``r:select(rect, {iterator = LE})``. This leads to silent EQ"
" select, because ``LE`` is undefined variable and treated as nil, so "
"iterator is unset and default used."
msgstr ""
"Другая типичная ошибка — указать тип итератора без кавычек следующим "
"образом: ``r:select(rect, {iterator = LE})``. В этом случае ``LE`` "
"представляет собой неопределенную переменную и обрабатывается как nil, "
"поэтому итератор считается незаданным, и будет использоваться итератор по"
" умолчанию EQ."

msgid "BITSET indexes"
msgstr "BITSET-индексы"

msgid ""
"Bitset is a bit mask. You should use it when you need to search by bit "
"masks. This can be, for example, storing a vector of attributes and "
"searching by these attributes."
msgstr ""
"Bitset — это битовая маска. BITSET следует использовать для поиска по "
"битовым маскам. Это может быть, например, сохранение вектора атрибутов и "
"поиск по этим атрибутам."

msgid ""
"The following script shows creating and searching with a BITSET index. "
"Notice that BITSET cannot be unique, so first a primary-key index is "
"created, and bit values are entered as hexadecimal literals for easier "
"reading."
msgstr ""
"Скрипт ниже показывает создание и поиск с помощью индекса BITSET. "
"Обратите внимание, что BITSET не может быть уникальным, поэтому сначала "
"создается индекс по первичному ключу, а битовые значения вводятся в "
"шестнадцатеричном виде для удобства чтения."

msgid ""
"tarantool> s = box.schema.space.create('space_with_bitset')\n"
"tarantool> s:create_index('primary_index', {\n"
"         >   parts = {1, 'string'},\n"
"         >   unique = true,\n"
"         >   type = 'TREE'\n"
"         > })\n"
"tarantool> s:create_index('bitset_index', {\n"
"         >   parts = {2, 'unsigned'},\n"
"         >   unique = false,\n"
"         >   type = 'BITSET'\n"
"         > })\n"
"tarantool> s:insert{'Tuple with bit value = 01', 0x01}\n"
"tarantool> s:insert{'Tuple with bit value = 10', 0x02}\n"
"tarantool> s:insert{'Tuple with bit value = 11', 0x03}\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.EQ\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ANY_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_NOT_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 01', 1]\n"
"..."
msgstr ""
"tarantool> s = box.schema.space.create('space_with_bitset')\n"
"tarantool> s:create_index('primary_index', {\n"
"         >   parts = {1, 'string'},\n"
"         >   unique = true,\n"
"         >   type = 'TREE'\n"
"         > })\n"
"tarantool> s:create_index('bitset_index', {\n"
"         >   parts = {2, 'unsigned'},\n"
"         >   unique = false,\n"
"         >   type = 'BITSET'\n"
"         > })\n"
"tarantool> s:insert{'Tuple with bit value = 01', 0x01}\n"
"tarantool> s:insert{'Tuple with bit value = 10', 0x02}\n"
"tarantool> s:insert{'Tuple with bit value = 11', 0x03}\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.EQ\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ANY_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_NOT_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 01', 1]\n"
"..."

msgid ""
"tarantool> box.schema.space.create('bitset_example')\n"
"tarantool> box.space.bitset_example:create_index('primary')\n"
"tarantool> "
"box.space.bitset_example:create_index('bitset',{unique=false,type='BITSET',"
" parts={2,'unsigned'}})\n"
"tarantool> box.space.bitset_example:insert{1,1}\n"
"tarantool> box.space.bitset_example:insert{2,4}\n"
"tarantool> box.space.bitset_example:insert{3,7}\n"
"tarantool> box.space.bitset_example:insert{4,3}\n"
"tarantool> box.space.bitset_example.index.bitset:select(2, "
"{iterator='BITS_ANY_SET'})"
msgstr ""
"tarantool> box.schema.space.create('bitset_example')\n"
"tarantool> box.space.bitset_example:create_index('primary')\n"
"tarantool> "
"box.space.bitset_example:create_index('bitset',{unique=false,type='BITSET',"
" parts={2,'unsigned'}})\n"
"tarantool> box.space.bitset_example:insert{1,1}\n"
"tarantool> box.space.bitset_example:insert{2,4}\n"
"tarantool> box.space.bitset_example:insert{3,7}\n"
"tarantool> box.space.bitset_example:insert{4,3}\n"
"tarantool> box.space.bitset_example.index.bitset:select(2, "
"{iterator='BITS_ANY_SET'})"

msgid "The result will be:"
msgstr "Получим следующий результат:"

msgid ""
"---\n"
"- - [3, 7]\n"
"  - [4, 3]\n"
"..."
msgstr ""
"---\n"
"- - [3, 7]\n"
"  - [4, 3]\n"
"..."

msgid "because (7 AND 2) is not equal to 0, and (3 AND 2) is not equal to 0."
msgstr "поскольку (7 AND 2) не равно 0, и (3 AND 2) не равно 0."

msgid ""
"Additionally, there exist :doc:`index iterator operations "
"</reference/reference_lua/box_index/pairs>`. They can only be used with "
"code in Lua and C/C++. Index iterators are for traversing indexes one key"
" at a time, taking advantage of features that are specific to an index "
"type. For example, they can be used for evaluating Boolean expressions "
"when traversing BITSET indexes, or for going in descending order when "
"traversing TREE indexes."
msgstr ""
"Кроме того, есть :doc:`операции с итераторами с индексом "
"</reference/reference_lua/box_index/pairs>`. Их можно использовать только"
" с кодом на языках Lua и C/C++. Итераторы с индексом предназначены для "
"обхода индексов по одному ключу за раз, поскольку используют особенности "
"каждого типа индекса. Например, их можно использовать для оценки "
"логических выражений при обходе BITSET-индексов или при обходе "
"TREE-индексов в порядке по убыванию."

msgid "Index operations"
msgstr "Операции с индексами"

msgid ""
"Index operations are automatic: if a data-manipulation request changes a "
"tuple, then it also changes the index keys defined for the tuple."
msgstr ""
"Операции с индексами производятся автоматически. Если запрос по "
"управлению данными меняет данные в кортеже, то меняются и ключи индекса "
"для данного кортежа."

msgid ""
"The simple :doc:`index-creation "
"</reference/reference_lua/box_space/create_index>` operation that we've "
"illustrated before is:"
msgstr ""
"Простая операция по :doc:`созданию индекса "
"</reference/reference_lua/box_space/create_index>`, которую мы "
"рассматривали ранее, выглядит следующим образом:"

msgid ":samp:`box.space.{space-name}:create_index('{index-name}')`"
msgstr ":samp:`box.space.{space-name}:create_index('{index-name}')`"

msgid ""
"This creates a unique TREE index on the first field of all tuples (often "
"called \"Field#1\"), which is assumed to be numeric."
msgstr ""
"По умолчанию, при этом создается TREE-индекс по первому полю для всех "
"кортежей (обычно его называют \"Field#1\"). Предполагается, что "
"индексируемое поле является числовым."

msgid ""
"The simple :doc:`SELECT </reference/reference_lua/box_index/select>` "
"request that we've illustrated before is:"
msgstr ""
"Вот простой запрос :doc:`SELECT "
"</reference/reference_lua/box_index/select>`, который мы рассматривали "
"ранее:"

msgid ":extsamp:`box.space.{*{space-name}*}:select({*{value}*})`"
msgstr ":extsamp:`box.space.{*{space-name}*}:select({*{value}*})`"

msgid ""
"This looks for a single tuple via the first index. Since the first index "
"is always unique, the maximum number of returned tuples will be 1. You "
"can call ``select()`` without arguments, and it will return all tuples."
msgstr ""
"Такой запрос ищет отдельный кортеж с помощью первичного индекса. "
"Поскольку первичный индекс всегда уникален, то данный запрос вернет не "
"более одного кортежа. Можно также вызвать ``select()`` без аргументов, "
"чтобы вернуть все кортежи."

msgid ""
"Let's continue working with the space 'tester' created in the "
":ref:`\"Getting started\" exercises <getting_started_db>` but first "
"modify it via :doc:`format() "
"</reference/reference_lua/box_space/format>`:"
msgstr ""
"Продолжим работать со спейсом 'tester', созданным в :ref:`упражнениях "
"\"Руководства для начинающих\" <getting_started_db>`, но сначала "
"форматируем его с помощью :doc:`format() "
"</reference/reference_lua/box_space/format>`:"

msgid ""
"tarantool> box.space.tester:format({\n"
"         > {name = 'id', type = 'unsigned'},\n"
"         > {name = 'band_name', type = 'string'},\n"
"         > {name = 'year', type = 'unsigned'},\n"
"         > {name = 'rate', type = 'unsigned', is_nullable=true}})\n"
"---\n"
"..."
msgstr ""
"tarantool> box.space.tester:format({\n"
"         > {name = 'id', type = 'unsigned'},\n"
"         > {name = 'band_name', type = 'string'},\n"
"         > {name = 'year', type = 'unsigned'},\n"
"         > {name = 'rate', type = 'unsigned', is_nullable=true}})\n"
"---\n"
"..."

msgid ""
"Add the rate to the tuple #1 and #2 via :doc:`update function "
"</reference/reference_lua/box_index/update>`:"
msgstr ""
"Добавим рейтинг для кортежей №1 и №2 с помощью :doc:`функции update "
"</reference/reference_lua/box_index/update>`:"

msgid ""
"tarantool> box.space.tester:update(1, {{'=', 4, 5}})\n"
"---\n"
"- [1, 'Roxette', 1986, 5]\n"
"...\n"
"tarantool> box.space.tester:update(2, {{'=', 4, 4}})\n"
"---\n"
"- [2, 'Scorpions', 2015, 4]\n"
"..."
msgstr ""
"tarantool> box.space.tester:update(1, {{'=', 4, 5}})\n"
"---\n"
"- [1, 'Roxette', 1986, 5]\n"
"...\n"
"tarantool> box.space.tester:update(2, {{'=', 4, 4}})\n"
"---\n"
"- [2, 'Scorpions', 2015, 4]\n"
"..."

msgid ""
"And :doc:`insert </reference/reference_lua/box_space/insert>` another "
"tuple:"
msgstr ""
"И :doc:`вставим </reference/reference_lua/box_space/insert>` еще один "
"кортеж:"

msgid ""
"tarantool> box.space.tester:insert({4, 'Roxette', 2016, 3})\n"
"---\n"
"- [4, 'Roxette', 2016, 3]\n"
"..."
msgstr ""
"tarantool> box.space.tester:insert({4, 'Roxette', 2016, 3})\n"
"---\n"
"- [4, 'Roxette', 2016, 3]\n"
"..."

msgid "**The existing SELECT variations:**"
msgstr "**Существующие варианты SELECT:**"

msgid "The search can use comparisons other than equality."
msgstr ""
"Помимо условия равенства, при поиске могут использоваться и другие "
"условия сравнения."

msgid ""
"tarantool> box.space.tester:select(1, {iterator = 'GT'})\n"
"---\n"
"- - [2, 'Scorpions', 2015, 4]\n"
"  - [3, 'Ace of Base', 1993]\n"
"  - [4, 'Roxette', 2016, 3]\n"
"..."
msgstr ""
"tarantool&gt; box.space.tester:select(1, {iterator = 'GT'})\n"
"---\n"
"- - [2, 'Scorpions', 2015, 4]\n"
"  - [3, 'Ace of Base', 1993]\n"
"  - [4, 'Roxette', 2016, 3]\n"
"..."

msgid ""
"The :ref:`comparison operators <box_index-iterator-types>` are LT, LE, "
"EQ, REQ, GE, GT (for \"less than\", \"less than or equal\", \"equal\", "
"\"reversed equal\", \"greater than or equal\", \"greater than\" "
"respectively). Comparisons make sense if and only if the index type is "
"TREE."
msgstr ""
"Можно использовать следующие :ref:`операторы сравнения <box_index-"
"iterator-types>`: LT — меньше; LE — меньше или равно; EQ — равно, "
"результаты отсортированы в порядке возрастания по ключу; REQ — равно, "
"результаты отсортированы в порядке убывания по ключу; GE — больше или "
"равно; GT — больше. Сравнения могут использоваться только для индексов "
"типа TREE."

msgid ""
"This type of search may return more than one tuple; if so, the tuples "
"will be in descending order by key when the comparison operator is LT or "
"LE or REQ, otherwise in ascending order."
msgstr ""
"Этот вариант поиска может вернуть более одного кортежа. В таком случае "
"кортежи будут отсортированы либо в порядке убывания по ключу, если "
"использовался оператор сравнения LT, LE или REQ, либо в порядке "
"возрастания во всех остальных случаях."

msgid "The search can use a secondary index."
msgstr "Поиск может производиться с помощью вторичного индекса."

msgid ""
"For a primary-key search, it is optional to specify an index name. For a "
"secondary-key search, it is mandatory."
msgstr ""
"При поиске по первичному индексу имя индекса можно не указывать. При "
"поиске по вторичному индексу имя индекса надо указать обязательно."

msgid ""
"tarantool> box.space.tester:create_index('secondary', {parts = {{field=3,"
" type='unsigned'}}})\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: unsigned\n"
"    is_nullable: false\n"
"    fieldno: 3\n"
"  id: 2\n"
"  space_id: 512\n"
"  type: TREE\n"
"  name: secondary\n"
"...\n"
"tarantool> box.space.tester.index.secondary:select({1993})\n"
"---\n"
"- - [3, 'Ace of Base', 1993]\n"
"..."
msgstr ""
"tarantool> box.space.tester:create_index('secondary', {parts = {{field=3,"
" type='unsigned'}}})\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: unsigned\n"
"    is_nullable: false\n"
"    fieldno: 3\n"
"  id: 2\n"
"  space_id: 512\n"
"  type: TREE\n"
"  name: secondary\n"
"...\n"
"tarantool> box.space.tester.index.secondary:select({1993})\n"
"---\n"
"- - [3, 'Ace of Base', 1993]\n"
"..."

msgid ""
"The search may be for some key parts starting with the prefix of the key."
" Notice that partial key searches are available only in TREE indexes."
msgstr ""
"Можно производить поиск по частям ключа, начиная с префикса ключа. "
"Обратите внимание, что поиск по части ключа доступен только в "
"TREE-индексах."

msgid ""
"-- Create an index with three parts\n"
"tarantool> box.space.tester:create_index('tertiary', {parts = {{field = "
"2, type = 'string'}, {field=3, type='unsigned'}, {field=4, "
"type='unsigned'}}})\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: string\n"
"    is_nullable: false\n"
"    fieldno: 2\n"
"  - type: unsigned\n"
"    is_nullable: false\n"
"    fieldno: 3\n"
"  - type: unsigned\n"
"    is_nullable: true\n"
"    fieldno: 4\n"
"  id: 6\n"
"  space_id: 513\n"
"  type: TREE\n"
"  name: tertiary\n"
"...\n"
"-- Make a partial search\n"
"tarantool> box.space.tester.index.tertiary:select({'Scorpions', 2015})\n"
"---\n"
"- - [2, 'Scorpions', 2015, 4]\n"
"..."
msgstr ""
"-- Создание индекса из трех частей\n"
"tarantool> box.space.tester:create_index('tertiary', {parts = {{field = "
"2, type = 'string'}, {field=3, type='unsigned'}, {field=4, "
"type='unsigned'}}})\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: string\n"
"    is_nullable: false\n"
"    fieldno: 2\n"
"  - type: unsigned\n"
"    is_nullable: false\n"
"    fieldno: 3\n"
"  - type: unsigned\n"
"    is_nullable: true\n"
"    fieldno: 4\n"
"  id: 6\n"
"  space_id: 513\n"
"  type: TREE\n"
"  name: tertiary\n"
"...\n"
"-- Поиск по части ключа\n"
"tarantool> box.space.tester.index.tertiary:select({'Scorpions', 2015})\n"
"---\n"
"- - [2, 'Scorpions', 2015, 4]\n"
"..."

msgid "The search may be for all fields, using a table for the value:"
msgstr "Поиск может производиться по всем полям через запись в виде таблицы:"

msgid ""
"tarantool> box.space.tester.index.tertiary:select({'Roxette', 2016, 3})\n"
"---\n"
"- - [4, 'Roxette', 2016, 3]\n"
"..."
msgstr ""
"tarantool> box.space.tester.index.tertiary:select({'Roxette', 2016, 3})\n"
"---\n"
"- - [4, 'Roxette', 2016, 3]\n"
"..."

msgid "or the search can be for one field, using a table or a scalar:"
msgstr ""
"либо же по одному полю, в этом случае используется таблица или скалярное "
"значение:"

msgid ""
"tarantool> box.space.tester.index.tertiary:select({'Roxette'})\n"
"---\n"
"- - [1, 'Roxette', 1986, 5]\n"
"  - [4, 'Roxette', 2016, 3]\n"
"..."
msgstr ""
"tarantool> box.space.tester.index.tertiary:select({'Roxette'})\n"
"---\n"
"- - [1, 'Roxette', 1986, 5]\n"
"  - [4, 'Roxette', 2016, 3]\n"
"..."

msgid ""
"You can add, drop, or alter the definitions at runtime, with some "
"restrictions. Read more in section :ref:`index operations <index-"
"box_index-operations>` and in reference for :doc:`box.index submodule "
"</reference/reference_lua/box_index>`."
msgstr ""
"С некоторыми ограничениями можно добавлять, удалять или изменять "
"определения во время исполнения кода. Более подробную информацию см. в "
"разделе :ref:`Операции с индексами <index-box_index-operations>` и в "
"справочнике по :doc:`вложенному модулю box.index "
"</reference/reference_lua/box_index>`."
