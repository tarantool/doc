msgid ""
msgstr ""
"Plural-Forms: nplurals=4; plural=((n%10==1 && n%100!=11) ? 0 : ((n%10 >= 2 && n%10 <=4 && (n%100 < 12 || n%100 > 14)) ? 1 : ((n%10 == 0 || (n%10 >= 5 && n%10 <=9)) || (n%100 >= 11 && n%100 <= 14)) ? 2 : 3));\n"
"X-Crowdin-Project: tarantool-docs\n"
"X-Crowdin-Project-ID: 442986\n"
"X-Crowdin-Language: ru\n"
"X-Crowdin-File: /en/book/box/indexes.pot\n"
"X-Crowdin-File-ID: 1656\n"
"Project-Id-Version: tarantool-docs\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Language-Team: Russian\n"
"Language: ru_RU\n"
"PO-Revision-Date: 2021-04-13 22:32\n"

msgid "Indexes"
msgstr "Индексы"

msgid "An **index** is a special data structure that stores a group of key values and pointers. It is used for efficient manipulations with data."
msgstr "**Индекс** — это специальная структура данных, которая хранит группу ключевых значений и указателей. Индекс используется для эффективного управления данными."

msgid "As with spaces, you should specify the index **name**, and let Tarantool come up with a unique **numeric identifier** (\"index id\")."
msgstr "Как и для спейсов, индексам следует указать **имена**, а Tarantool определит уникальный **числовой идентификатор** (\"ID индекса\")."

msgid "An index may be **multi-part**, that is, you can declare that an index key value is composed of two or more fields in the tuple, in any order. For example, for an ordinary TREE index, the maximum number of parts is 255."
msgstr "Индекс может быть **составным** (multi-part), то есть можно объявить, что ключ индекса состоит из двух или более полей в кортеже в любом порядке. Например, для обычного TREE-индекса максимальное количество частей равно 255."

msgid "An index may be **unique**, that is, you can declare that it would be illegal to have the same key value twice."
msgstr "Индекс может быть **уникальным**, то есть можно объявить, что недопустимо дважды задавать одно значение ключа."

msgid "The first index defined on a space is called the **primary key index**, and it must be unique. All other indexes are called **secondary indexes**, and they may be non-unique."
msgstr "Первый индекс, определенный для спейса, называется **первичный индекс** (primary key). Он должен быть уникальным. Все остальные индексы называются **вторичными индексами** (secondary), они могут строиться по неуникальным значениям."

msgid "Indexes have certain limitations. See details on page :doc:`Limitations </book/box/limitations>`."
msgstr "На индексы распространяются определенные ограничения. Более подробную информацию см. на странице :doc:`Ограничения </book/box/limitations>`."

msgid "Creating an index"
msgstr "Создание индекса"

msgid "It is mandatory to create an index for a space before trying to insert tuples into the space, or select tuples from the space."
msgstr "Перед тем, как вставлять кортежи в спейс или выбирать из него кортежи, нужно обязательно создать индекс для этого спейса."

msgid "The simple :doc:`index-creation </reference/reference_lua/box_space/create_index>` operation is:"
msgstr "Простая операция по :doc:`созданию индекса </reference/reference_lua/box_space/create_index>` выглядит следующим образом:"

msgid ":extsamp:`box.space.{**{space-name}**}:create_index('{*{index-name}*}')`"
msgstr ":extsamp:`box.space.{**{space-name}**}:create_index('{*{index-name}*}')`"

msgid "This creates a unique :ref:`TREE <indexes-tree>` index on the first field of all tuples (often called \"Field#1\"), which is assumed to be numeric."
msgstr "При этом создается уникальный :ref:`TREE-индекс <indexes-tree>` по первому полю всех кортежей (обычно его называют \"Field#1\"). Предполагается, что индексируемое поле является числовым."

msgid "A recommended design pattern for a data model is to base primary keys on the first fields of a tuple. This speeds up tuple comparison due to the specifics of data storage and the way comparisons are arranged in Tarantool."
msgstr "Рекомендуется проектировать модель данных так, чтобы первичные ключи были первыми полями в кортеже. Это позволяет быстрее сравнивать кортежи, учитывая специфику хранения данных и способ организации сравнений в Tarantool."

msgid "The simple :doc:`SELECT </reference/reference_lua/box_index/select>` request is:"
msgstr "Вот простой запрос :doc:`SELECT </reference/reference_lua/box_index/select>`:"

msgid ":extsamp:`box.space.{**{space-name}**}:select({*{value}*})`"
msgstr ":extsamp:`box.space.{**{space-name}**}:select({*{value}*})`"

msgid "This looks for a single tuple via the first index. Since the first index is always unique, the maximum number of returned tuples will be 1. You can call ``select()`` without arguments, and it will return all tuples. Be careful! Using ``select()`` for huge spaces hangs your instance."
msgstr "Такой запрос ищет отдельный кортеж, используя первичный индекс. Поскольку первичный индекс всегда уникален, то данный запрос вернет не более одного кортежа. Можно также вызвать ``select()`` без аргументов, чтобы вернуть все кортежи. Осторожно! Если вызвать ``select()`` без аргументов в огромном спейсе, ваш экземпляр зависнет."

msgid "An index definition may also include identifiers of tuple fields and their expected **types**. See allowed indexed field types in section :ref:`Details about indexed field types <details_about_index_field_types>`:"
msgstr "Определение индекса может также содержать идентификаторы полей кортежа и их предполагаемые **типы**. См. допустимые типы полей в разделе :ref:`Описание типов индексируемых полей <details_about_index_field_types>`:"

msgid ":extsamp:`box.space.{**{space-name}**}:create_index({**{index-name}**}, {type = 'tree', parts = {{field = 1, type = 'unsigned'}}}`"
msgstr ":extsamp:`box.space.{**{space-name}**}:create_index({**{index-name}**}, {type = 'tree', parts = {{field = 1, type = 'unsigned'}}}`"

msgid "Space definitions and index definitions are stored permanently in Tarantool's system spaces :ref:`_space <box_space-space>` and :ref:`_index <box_space-index>`."
msgstr "Определения спейса и определения индексов хранятся в системных спейсах Tarantool :ref:`_space <box_space-space>` и :ref:`_index <box_space-index>` соответственно."

msgid "Tip"
msgstr "Примечание"

msgid "See full information about creating indexes, such as how to create a multikey index, an index using the ``path`` option, or how to create a functional index in our reference for :doc:`/reference/reference_lua/box_space/create_index`."
msgstr "Полную информацию о создании индексов, например о создании индексов по массиву (multikey), индексов с использованием пути ``path`` или функциональных индексов см. в справочнике :doc:`/reference/reference_lua/box_space/create_index`."

msgid "Index operations"
msgstr "Операции с индексами"

msgid "Index operations are automatic: if a data manipulation request changes a tuple, then it also changes the index keys defined for the tuple."
msgstr "Операции с индексами производятся автоматически. Если запрос на изменение данных меняет данные в кортеже, то изменятся и ключи индекса для данного кортежа."

msgid "For further demonstrations let's create a sample space named ``tester`` and put it in a variable ``my_space``:"
msgstr "Для примера создадим спейс с именем ``tester`` и поместим его в переменную ``my_space``:"

msgid "tarantool> my_space = box.schema.space.create('tester')"
msgstr "tarantool> my_space = box.schema.space.create('tester')"

msgid "Format the created space by specifying field names and types:"
msgstr "Отформатируем созданный спейс, указав имена и типы полей:"

msgid "tarantool> my_space:format({\n"
"         > {name = 'id', type = 'unsigned'},\n"
"         > {name = 'band_name', type = 'string'},\n"
"         > {name = 'year', type = 'unsigned'},\n"
"         > {name = 'rate', type = 'unsigned', is_nullable = true}})"
msgstr "tarantool> my_space:format({\n"
"         > {name = 'id', type = 'unsigned'},\n"
"         > {name = 'band_name', type = 'string'},\n"
"         > {name = 'year', type = 'unsigned'},\n"
"         > {name = 'rate', type = 'unsigned', is_nullable = true}})"

msgid "Create the **primary** index (named ``primary``):"
msgstr "Создадим **первичный** индекс с именем ``primary``:"

msgid "tarantool> my_space:create_index('primary', {\n"
"         > type = 'tree',\n"
"         > parts = {'id'}\n"
"         > })"
msgstr "tarantool> my_space:create_index('primary', {\n"
"         > type = 'tree',\n"
"         > parts = {'id'}\n"
"         > })"

msgid "This is a primary index based on the ``id`` field of each tuple."
msgstr "Это первичный индекс по полю ``id`` в каждом кортеже."

msgid "Insert some :ref:`tuples <index-box_tuple>` into the space:"
msgstr "Вставим несколько :ref:`кортежей <index-box_tuple>` в спейс:"

msgid "tarantool> my_space:insert{1, 'Roxette', 1986, 1}\n"
"tarantool> my_space:insert{2, 'Scorpions', 2015, 4}\n"
"tarantool> my_space:insert{3, 'Ace of Base', 1993}\n"
"tarantool> my_space:insert{4, 'Roxette', 2016, 3}"
msgstr "tarantool> my_space:insert{1, 'Roxette', 1986, 1}\n"
"tarantool> my_space:insert{2, 'Scorpions', 2015, 4}\n"
"tarantool> my_space:insert{3, 'Ace of Base', 1993}\n"
"tarantool> my_space:insert{4, 'Roxette', 2016, 3}"

msgid "Create a **secondary index**:"
msgstr "Создадим **вторичный индекс**:"

msgid "tarantool> box.space.tester:create_index('secondary', {parts = {{field=3, type='unsigned'}}})\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: unsigned\n"
"    is_nullable: false\n"
"    fieldno: 3\n"
"  id: 2\n"
"  space_id: 512\n"
"  type: TREE\n"
"  name: secondary\n"
"..."
msgstr "tarantool> box.space.tester:create_index('secondary', {parts = {{field=3, type='unsigned'}}})\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: unsigned\n"
"    is_nullable: false\n"
"    fieldno: 3\n"
"  id: 2\n"
"  space_id: 512\n"
"  type: TREE\n"
"  name: secondary\n"
"..."

msgid "Create a **multi-part index** with three parts:"
msgstr "Создадим **составной индекс** (multi-part) из трех частей:"

msgid "tarantool> box.space.tester:create_index('thrine', {parts = {\n"
"         > {field = 2, type = 'string'},\n"
"         > {field = 3, type = 'unsigned'},\n"
"         > {field = 4, type = 'unsigned'}\n"
"         > }})\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: string\n"
"    is_nullable: false\n"
"    fieldno: 2\n"
"  - type: unsigned\n"
"    is_nullable: false\n"
"    fieldno: 3\n"
"  - type: unsigned\n"
"    is_nullable: true\n"
"    fieldno: 4\n"
"  id: 6\n"
"  space_id: 513\n"
"  type: TREE\n"
"  name: thrine\n"
"..."
msgstr "tarantool> box.space.tester:create_index('thrine', {parts = {\n"
"         > {field = 2, type = 'string'},\n"
"         > {field = 3, type = 'unsigned'},\n"
"         > {field = 4, type = 'unsigned'}\n"
"         > }})\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: string\n"
"    is_nullable: false\n"
"    fieldno: 2\n"
"  - type: unsigned\n"
"    is_nullable: false\n"
"    fieldno: 3\n"
"  - type: unsigned\n"
"    is_nullable: true\n"
"    fieldno: 4\n"
"  id: 6\n"
"  space_id: 513\n"
"  type: TREE\n"
"  name: thrine\n"
"..."

msgid "**There are the following SELECT variations:**"
msgstr "**Можно использовать такие варианты SELECT:**"

msgid "The search can use **comparisons** other than equality:"
msgstr "Помимо условия равенства, при поиске могут использоваться и другие **условия сравнения**:"

msgid "tarantool> box.space.tester:select(1, {iterator = 'GT'})\n"
"---\n"
"- - [2, 'Scorpions', 2015, 4]\n"
"  - [3, 'Ace of Base', 1993]\n"
"  - [4, 'Roxette', 2016, 3]\n"
"..."
msgstr "tarantool&gt; box.space.tester:select(1, {iterator = 'GT'})\n"
"---\n"
"- - [2, 'Scorpions', 2015, 4]\n"
"  - [3, 'Ace of Base', 1993]\n"
"  - [4, 'Roxette', 2016, 3]\n"
"..."

msgid "The :ref:`comparison operators <box_index-iterator-types>` are:"
msgstr "Есть такие :ref:`операторы сравнения <box_index-iterator-types>`:"

msgid "``LT`` for \"less than\""
msgstr "``LT`` — \"меньше\""

msgid "``LE`` for \"less than or equal\""
msgstr "``LE`` — \"меньше или равно\""

msgid "``GT`` for \"greater\""
msgstr "``GT`` — \"больше\""

msgid "``GE`` for \"greater than or equal\" ."
msgstr "``GE`` — \"больше или равно\""

msgid "``EQ`` for \"equal\","
msgstr "``EQ`` — \"равно\","

msgid "``REQ`` for \"reversed equal\""
msgstr "``REQ`` — \"равно, результаты отсортированы в порядке убывания по ключу\""

msgid "Value comparisons make sense if and only if the index type is TREE. The iterator types for other types of indexes are slightly different and work differently. See details in section :ref:`Iterator types <box_index-iterator-types>`."
msgstr "Только для TREE-индексов есть смысл в сравнении значений. Итераторы для других типов индексов немного отличаются и работают по-другому. Более подробную информацию см. в разделе :ref:`Типы итераторов <box_index-iterator-types>`."

msgid "Note that we don't use the name of the index, which means we use primary index here."
msgstr "Обратите внимание, что мы не используем имя индекса — значит, здесь мы используем первичный индекс."

msgid "This type of search may return more than one tuple. The tuples will be sorted in descending order by key if the comparison operator is LT or LE or REQ. Otherwise they will be sorted in ascending order."
msgstr "Этот вариант поиска может вернуть более одного кортежа. Если используется оператор сравнения LT, LE или REQ, то кортежи будут отсортированы по ключу в порядке убывания. Во всех остальных случаях — в порядке возрастания."

msgid "The search can use a **secondary index**."
msgstr "Для поиска можно использовать **вторичный индекс**."

msgid "For a primary-key search, it is optional to specify an index name as was demonstrated above. For a secondary-key search, it is mandatory."
msgstr "При поиске по первичному ключу имя индекса можно не указывать, как показано выше. При поиске же по вторичному ключу имя индекса нужно указать обязательно."

msgid "tarantool> box.space.tester.index.secondary:select({1993})\n"
"---\n"
"- - [3, 'Ace of Base', 1993]\n"
"..."
msgstr "tarantool> box.space.tester.index.secondary:select({1993})\n"
"---\n"
"- - [3, 'Ace of Base', 1993]\n"
"..."

msgid "**Partial key search:** The search may be for some key parts starting with the prefix of the key. Note that partial key searches are available only in TREE indexes."
msgstr "**Поиск по частям ключа:** Можно производить поиск по частям ключа, начиная с префикса ключа. Обратите внимание, что поиск по части ключа доступен только в TREE-индексах."

msgid "tarantool> box.space.tester.index.thrine:select({'Scorpions', 2015})\n"
"---\n"
"- - [2, 'Scorpions', 2015, 4]\n"
"..."
msgstr "tarantool> box.space.tester.index.thrine:select({'Scorpions', 2015})\n"
"---\n"
"- - [2, 'Scorpions', 2015, 4]\n"
"..."

msgid "The search can be for all fields, using a table as the value:"
msgstr "Поиск можно производить по всем полям через запись в виде таблицы:"

msgid "tarantool> box.space.tester.index.thrine:select({'Roxette', 2016, 3})\n"
"---\n"
"- - [4, 'Roxette', 2016, 3]\n"
"..."
msgstr "tarantool> box.space.tester.index.thrine:select({'Roxette', 2016, 3})\n"
"---\n"
"- - [4, 'Roxette', 2016, 3]\n"
"..."

msgid "or the search can be for one field, using a table or a scalar:"
msgstr "либо же по одному полю, в этом случае используется таблица или скалярное значение:"

msgid "tarantool> box.space.tester.index.thrine:select({'Roxette'})\n"
"---\n"
"- - [1, 'Roxette', 1986, 5]\n"
"  - [4, 'Roxette', 2016, 3]\n"
"..."
msgstr "tarantool> box.space.tester.index.thrine:select({'Roxette'})\n"
"---\n"
"- - [1, 'Roxette', 1986, 5]\n"
"  - [4, 'Roxette', 2016, 3]\n"
"..."

msgid "You can also add, drop, or alter the definitions at runtime, with some restrictions. Read more about index operations in reference for :doc:`box.index submodule </reference/reference_lua/box_index>`."
msgstr "С некоторыми ограничениями можно добавлять, удалять или изменять определения во время исполнения кода. Более подробную информацию об операциях с индексами см. в справочнике по :doc:`вложенному модулю box.index </reference/reference_lua/box_index>`."

msgid "Index types"
msgstr "Типы индексов"

msgid "An index always has a **type**. Different types are intended for different usage scenarios."
msgstr "Индекс всегда относится к определенному **типу**. Для разных сценариев использования требуются разные типы индексов."

msgid "We give an overview of index features in the following table:"
msgstr "Обзор характеристик индексов приведен в следующей таблице:"

msgid "Feature"
msgstr "Характеристика"

msgid "TREE"
msgstr "TREE"

msgid "HASH"
msgstr "HASH"

msgid "RTREE"
msgstr "RTREE"

msgid "BITSET"
msgstr "BITSET"

msgid "unique"
msgstr "уникальный"

msgid "\\+"
msgstr "\\+"

msgid "\\-"
msgstr "\\-"

msgid "non-unique"
msgstr "неуникальный"

msgid ":ref:`is_nullable <box_space-is_nullable>`"
msgstr ":ref:`is_nullable <box_space-is_nullable>`"

msgid "can be multi-part"
msgstr "может быть составным (multi-part)"

msgid ":ref:`multikey <box_space-path_multikey>`"
msgstr ":ref:`индекс по массиву (multikey) <box_space-path_multikey>`"

msgid ":ref:`partial-key search <partial_key_search>`"
msgstr ":ref:`поиск по части ключа <partial_key_search>`"

msgid "can be primary key"
msgstr "может быть по первичному ключу"

msgid "``exclude_null`` (version 2.8+)"
msgstr "``exclude_null`` (версии 2.8+)"

msgid ":doc:`iterator types </reference/reference_lua/box_index/pairs>`"
msgstr ":doc:`типы итераторов </reference/reference_lua/box_index/pairs>`"

msgid "ALL, EQ, REQ, GT, GE, LT, LE"
msgstr "ALL, EQ, REQ, GT, GE, LT, LE"

msgid "ALL, EQ, GT"
msgstr "ALL, EQ, GT"

msgid "ALL, EQ, GT, GE, LT, LE, OVERLAPS, NEIGHBOR"
msgstr "ALL, EQ, GT, GE, LT, LE, OVERLAPS, NEIGHBOR"

msgid "ALL, EQ, BITS_ALL_SET, BITS_ANY_SET, BITS_ALL_NOT_SET"
msgstr "ALL, EQ, BITS_ALL_SET, BITS_ANY_SET, BITS_ALL_NOT_SET"

msgid "TREE indexes"
msgstr "TREE-индексы"

msgid "The default index type is 'TREE'. TREE indexes are provided by memtx and vinyl engines, can index unique and non-unique values, support partial key searches, comparisons and ordered results."
msgstr "Тип индекса по умолчанию — 'TREE'. Движки memtx и vinyl предоставляют TREE-индексы, которые могут индексировать уникальные и неуникальные значения, поддерживают поиск по компонентам ключа, сравнение ключей и упорядоченные результаты."

msgid "This is a universal type of indexes, for most cases it will be the best choice."
msgstr "Это универсальный тип индексов, в большинстве случаев он подойдет лучше всего."

msgid "Additionally, memtx engine supports HASH, RTREE and BITSET indexes."
msgstr "Кроме того, движок memtx поддерживает следующие типы индексов: HASH, RTREE и BITSET."

msgid "HASH indexes"
msgstr "HASH-индексы"

msgid "HASH indexes require unique fields and loses to TREE in almost all respects. So we do not recommend to use it in the applications. HASH is now present in Tarantool mainly because of backward compatibility."
msgstr "HASH-индексы требуют уникальности полей и почти во всех отношениях проигрывают индексам типа TREE. Поэтому мы не рекомендуем использовать их в приложениях. В настоящее время Tarantool поддерживает HASH в основном для обратной совместимости."

msgid "Here are some tips. Do not use HASH index:"
msgstr "Вот несколько советов. Не используйте HASH-индекс:"

msgid "just if you want to"
msgstr "если просто хочется"

msgid "if you think that HASH is faster with no performance metering"
msgstr "если вы думаете, что HASH быстрее, без измерения производительности"

msgid "if you want to iterate over the data"
msgstr "если вы хотите выполнять перебор данных"

msgid "for primary key"
msgstr "по первичному ключу"

msgid "as an only index"
msgstr "как единственный индекс"

msgid "Use HASH index:"
msgstr "Используйте HASH-индекс:"

msgid "if it is a secondary key"
msgstr "если это вторичный ключ"

msgid "if you 100% won't need to make it non-unique"
msgstr "если вы на сто процентов уверены, что его не придется делать неуникальным"

msgid "if you have taken measurements on your data and you see an accountable increase in performance"
msgstr "если вы обнаружили значимое увеличение производительности в ходе проведенных измерений"

msgid "if you save every byte on tuples (HASH is a little more compact)"
msgstr "если вы экономите каждый байт на кортежах (HASH немного компактнее)"

msgid "RTREE indexes"
msgstr "RTREE-индексы"

msgid "RTREE is a multidimensional index supporting up to 20 dimensions. It is used especially for indexing spatial information, such as geographical objects. In :ref:`this example <box_index-rtree>` we demonstrate spatial searches via RTREE index."
msgstr "RTREE — это многомерный индекс, который поддерживает до 20 измерений. Он используется, в частности, для индексирования пространственной информации, такой как географические объекты. В :ref:`этом примере <box_index-rtree>` мы показываем, как использовать пространственный поиск с помощью RTREE-индекса."

msgid "RTREE index could not be primary, and could not be unique. The option list of this type of index may contain ``dimension`` and ``distance`` options. The ``parts`` definition must contain the one and only part with type ``array``. RTREE index can accept two types of ``distance`` functions: ``euclid`` and ``manhattan``."
msgstr "RTREE-индекс не может быть первичным и не может быть уникальным. Индекс такого типа может содержать параметры измерения и расстояния — ``dimension`` и ``distance`` соответственно. Определение ``parts`` должно включать только один компонент типа ``array``. RTREE-индекс может принимать два типа функции расстояния ``distance``: ``euclid``, то есть Евклидова метрика, или ``manhattan``, то есть расстояние городских кварталов."

msgid "**Example 1:**"
msgstr "**Пример 1:**"

msgid "my_space = box.schema.create_space(\"tester\")\n"
"my_space:format({ { type = 'number', name = 'id' }, { type = 'array', name = 'content' } })\n"
"hash_index = my_space:create_index('primary', { type = 'tree', parts = {'id'} })\n"
"rtree_index = my_space:create_index('spatial', { type = 'RTREE', unique = false, parts = {'content'} })"
msgstr "my_space = box.schema.create_space(\"tester\")\n"
"my_space:format({ { type = 'number', name = 'id' }, { type = 'array', name = 'content' } })\n"
"hash_index = my_space:create_index('primary', { type = 'tree', parts = {'id'} })\n"
"rtree_index = my_space:create_index('spatial', { type = 'RTREE', unique = false, parts = {'content'} })"

msgid "Corresponding tuple field thus must be an array of 2 or 4 numbers. 2 numbers mean a point {x, y}; 4 numbers mean a rectangle {x1, y1, x2, y2}, where (x1, y1) and (x2, y2) - diagonal point of the rectangle."
msgstr "Таким образом, соответствующее поле кортежа может быть массивом типа array из 2 или 4 чисел. 2 числа обозначают точку {x, y}; 4 числа обозначают прямоугольник {x1, y1, x2, y2}, где (x1, y1) и (x2, y2) — диагональные точки прямоугольника."

msgid "my_space:insert{1, {1, 1}}\n"
"my_space:insert{2, {2, 2, 3, 3}}"
msgstr "my_space:insert{1, {1, 1}}\n"
"my_space:insert{2, {2, 2, 3, 3}}"

msgid "Selection results depend on a chosen iterator. The default EQ iterator searches for an exact rectangle, a point is treated as zero width and height rectangle:"
msgstr "Результаты выборки зависят от выбранного итератора. Итератор EQ, который используется по умолчанию, ищет точный прямоугольник, точка рассматривается как прямоугольник нулевой ширины и высоты:"

msgid "tarantool> rtree_index:select{1, 1}\n"
"---\n"
"- - [1, [1, 1]]\n"
"...\n\n"
"tarantool> rtree_index:select{1, 1, 1, 1}\n"
"---\n"
"- - [1, [1, 1]]\n"
"...\n\n"
"tarantool> rtree_index:select{2, 2}\n"
"---\n"
"- []\n"
"...\n\n"
"tarantool> rtree_index:select{2, 2, 3, 3}\n"
"---\n"
"- - [2, [2, 2, 3, 3]]\n"
"..."
msgstr "tarantool> rtree_index:select{1, 1}\n"
"---\n"
"- - [1, [1, 1]]\n"
"...\n\n"
"tarantool> rtree_index:select{1, 1, 1, 1}\n"
"---\n"
"- - [1, [1, 1]]\n"
"...\n\n"
"tarantool> rtree_index:select{2, 2}\n"
"---\n"
"- []\n"
"...\n\n"
"tarantool> rtree_index:select{2, 2, 3, 3}\n"
"---\n"
"- - [2, [2, 2, 3, 3]]\n"
"..."

msgid "Iterator ALL, which is the default when no key is specified, selects all tuples in arbitrary order:"
msgstr "Итератор ALL, который используется по умолчанию, если не указан ключ, выбирает все кортежи в произвольном порядке:"

msgid "tarantool> rtree_index:select{}\n"
"---\n"
"- - [1, [1, 1]]\n"
"  - [2, [2, 2, 3, 3]]\n"
"..."
msgstr "tarantool> rtree_index:select{}\n"
"---\n"
"- - [1, [1, 1]]\n"
"  - [2, [2, 2, 3, 3]]\n"
"..."

msgid "Iterator LE (less or equal) searches for tuples with their rectangles within a specified rectangle:"
msgstr "Итератор LE (меньше или равно) ищет кортежи с прямоугольниками, которые находятся в пределах заданного прямоугольника:"

msgid "tarantool> rtree_index:select({1, 1, 2, 2}, {iterator='le'})\n"
"---\n"
"- - [1, [1, 1]]\n"
"..."
msgstr "tarantool> rtree_index:select({1, 1, 2, 2}, {iterator='le'})\n"
"---\n"
"- - [1, [1, 1]]\n"
"..."

msgid "Iterator LT (less than, or strictly less) searches for tuples with their rectangles strictly within a specified rectangle:"
msgstr "Итератор LT (меньше или строго меньше) ищет кортежи с прямоугольниками, которые находятся строго в пределах заданного прямоугольника:"

msgid "tarantool> rtree_index:select({0, 0, 3, 3}, {iterator = 'lt'})\n"
"---\n"
"- - [1, [1, 1]]\n"
"..."
msgstr "tarantool> rtree_index:select({0, 0, 3, 3}, {iterator = 'lt'})\n"
"---\n"
"- - [1, [1, 1]]\n"
"..."

msgid "Iterator GE searches for tuples with a specified rectangle within their rectangles:"
msgstr "Итератор GE ищет кортежи с прямоугольниками, в пределах которых находится заданный прямоугольник:"

msgid "tarantool> rtree_index:select({1, 1}, {iterator = 'ge'})\n"
"---\n"
"- - [1, [1, 1]]\n"
"..."
msgstr "tarantool> rtree_index:select({1, 1}, {iterator = 'ge'})\n"
"---\n"
"- - [1, [1, 1]]\n"
"..."

msgid "Iterator GT searches for tuples with a specified rectangle strictly within their rectangles:"
msgstr "Итератор GT ищет кортежи с прямоугольниками, строго в пределах которых находится заданный прямоугольник:"

msgid "tarantool> rtree_index:select({2.1, 2.1, 2.9, 2.9}, {itearator = 'gt'})\n"
"---\n"
"- []\n"
"..."
msgstr "tarantool> rtree_index:select({2.1, 2.1, 2.9, 2.9}, {iterator = 'gt'})\n"
"---\n"
"- []\n"
"..."

msgid "Iterator OVERLAPS searches for tuples with their rectangles overlapping specified rectangle:"
msgstr "Итератор OVERLAPS ищет кортежи с прямоугольниками, перекрывающими указанный прямоугольник:"

msgid "tarantool> rtree_index:select({0, 0, 10, 2}, {iterator='overlaps'})\n"
"---\n"
"- - [1, [1, 1]]\n"
"  - [2, [2, 2, 3, 3]]\n"
"..."
msgstr "tarantool> rtree_index:select({0, 0, 10, 2}, {iterator='overlaps'})\n"
"---\n"
"- - [1, [1, 1]]\n"
"  - [2, [2, 2, 3, 3]]\n"
"..."

msgid "Iterator NEIGHBOR searches for all tuples and orders them by distance to the specified point:"
msgstr "Итератор NEIGHBOR ищет все кортежи и упорядочивает их по расстоянию до заданной точки:"

msgid "tarantool> for i=1,10 do\n"
"         >    for j=1,10 do\n"
"         >        my_space:insert{i*10+j, {i, j, i+1, j+1}}\n"
"         >    end\n"
"         > end\n"
"---\n"
"...\n\n"
"tarantool> rtree_index:select({1, 1}, {iterator = 'neighbor', limit = 5})\n"
"---\n"
"- - [11, [1, 1, 2, 2]]\n"
"  - [12, [1, 2, 2, 3]]\n"
"  - [21, [2, 1, 3, 2]]\n"
"  - [22, [2, 2, 3, 3]]\n"
"  - [31, [3, 1, 4, 2]]\n"
"..."
msgstr "tarantool> for i=1,10 do\n"
"         >    for j=1,10 do\n"
"         >        my_space:insert{i*10+j, {i, j, i+1, j+1}}\n"
"         >    end\n"
"         > end\n"
"---\n"
"...\n\n"
"tarantool> rtree_index:select({1, 1}, {iterator = 'neighbor', limit = 5})\n"
"---\n"
"- - [11, [1, 1, 2, 2]]\n"
"  - [12, [1, 2, 2, 3]]\n"
"  - [21, [2, 1, 3, 2]]\n"
"  - [22, [2, 2, 3, 3]]\n"
"  - [31, [3, 1, 4, 2]]\n"
"..."

msgid "**Example 2:**"
msgstr "**Пример 2:**"

msgid "3D, 4D and more dimensional RTREE indexes work in the same way as 2D except that user must specify more coordinates in requests. Here's short example of using 4D tree:"
msgstr "3-мерные, 4-мерные или многомерные RTREE индексы используются так же, как и для двумерные, только пользователь должен указать больше координат в запросах. Вот небольшой пример использования для 4-мерного дерева:"

msgid "tarantool> my_space = box.schema.create_space(\"tester\")\n"
"tarantool> my_space:format{ { type = 'number', name = 'id' }, { type = 'array', name = 'content' } }\n"
"tarantool> primary_index = my_space:create_index('primary', { type = 'TREE', parts = {'id'} })\n"
"tarantool> rtree_index = my_space:create_index('spatial', { type = 'RTREE', unique = false, dimension = 4, parts = {'content'} })\n"
"tarantool> my_space:insert{1, {1, 2, 3, 4}} -- insert 4D point\n"
"tarantool> my_space:insert{2, {1, 1, 1, 1, 2, 2, 2, 2}} -- insert 4D box\n\n"
"tarantool> rtree_index:select{1, 2, 3, 4} -- find exact point\n"
"---\n"
"- - [1, [1, 2, 3, 4]]\n"
"...\n\n"
"tarantool> rtree_index:select({0, 0, 0, 0, 3, 3, 3, 3}, {iterator = 'LE'}) -- select from 4D box\n"
"---\n"
"- - [2, [1, 1, 1, 1, 2, 2, 2, 2]]\n"
"...\n\n"
"tarantool> rtree_index:select({0, 0, 0, 0}, {iterator = 'neighbor'}) -- select neighbours\n"
"---\n"
"- - [2, [1, 1, 1, 1, 2, 2, 2, 2]]\n"
"  - [1, [1, 2, 3, 4]]\n"
"..."
msgstr "tarantool> my_space = box.schema.create_space(\"tester\")\n"
"tarantool> my_space:format{ { type = 'number', name = 'id' }, { type = 'array', name = 'content' } }\n"
"tarantool> primary_index = my_space:create_index('primary', { type = 'TREE', parts = {'id'} })\n"
"tarantool> rtree_index = my_space:create_index('spatial', { type = 'RTREE', unique = false, dimension = 4, parts = {'content'} })\n"
"tarantool> my_space:insert{1, {1, 2, 3, 4}} -- вставка 4D-точки\n"
"tarantool> my_space:insert{2, {1, 1, 1, 1, 2, 2, 2, 2}} -- вставка 4D-тела\n\n"
"tarantool> rtree_index:select{1, 2, 3, 4} -- поиск определенной точки\n"
"---\n"
"- - [1, [1, 2, 3, 4]]\n"
"...\n\n"
"tarantool> rtree_index:select({0, 0, 0, 0, 3, 3, 3, 3}, {iterator = 'LE'}) -- выборка из 4D-тела\n"
"---\n"
"- - [2, [1, 1, 1, 1, 2, 2, 2, 2]]\n"
"...\n\n"
"tarantool> rtree_index:select({0, 0, 0, 0}, {iterator = 'neighbor'}) -- выборка соседей\n"
"---\n"
"- - [2, [1, 1, 1, 1, 2, 2, 2, 2]]\n"
"  - [1, [1, 2, 3, 4]]\n"
"..."

msgid "Don't forget that select NEIGHBOR iterator without limit extract entire space in order of increasing distance and that could be tons of data with corresponding performance."
msgstr "Не забывайте, что итератор выборки соседей NEIGHBOR без ограничений извлекает весь спейс в порядке возрастания расстояния, а это может быть огромное количество данных, что повлечет за собой соответствующую производительность."

msgid "And another frequent mistake is to specify iterator type without quotes, in such way: ``rtree_index:select(rect, {iterator = 'LE'})``. This leads to silent EQ select, because ``LE`` is undefined variable and treated as nil, so iterator is unset and default used."
msgstr "Другая типичная ошибка — указать тип итератора без кавычек следующим образом: ``rtree_index:select(rect, {iterator = 'LE'})``. В этом случае ``LE`` представляет собой неопределенную переменную и обрабатывается как nil, поэтому итератор считается незаданным, и будет использован итератор по умолчанию EQ."

msgid "BITSET indexes"
msgstr "BITSET-индексы"

msgid "Bitset is a bit mask. You should use it when you need to search by bit masks. This can be, for example, storing a vector of attributes and searching by these attributes."
msgstr "Bitset — это битовая маска. BITSET следует использовать для поиска по битовым маскам. Это может быть, например, сохранение вектора атрибутов и поиск по этим атрибутам."

msgid "The following script shows creating and searching with a BITSET index. Notice that BITSET cannot be unique, so first a primary-key index is created, and bit values are entered as hexadecimal literals for easier reading."
msgstr "Скрипт ниже показывает создание и поиск с помощью индекса BITSET. Обратите внимание, что BITSET не может быть уникальным, поэтому сначала создается индекс по первичному ключу, а битовые значения вводятся в шестнадцатеричном виде для удобства чтения."

msgid "tarantool> my_space = box.schema.space.create('space_with_bitset')\n"
"tarantool> my_space:create_index('primary_index', {\n"
"         >   parts = {1, 'string'},\n"
"         >   unique = true,\n"
"         >   type = 'TREE'\n"
"         > })\n"
"tarantool> my_space:create_index('bitset_index', {\n"
"         >   parts = {2, 'unsigned'},\n"
"         >   unique = false,\n"
"         >   type = 'BITSET'\n"
"         > })\n"
"tarantool> my_space:insert{'Tuple with bit value = 01', 0x01}\n"
"tarantool> my_space:insert{'Tuple with bit value = 10', 0x02}\n"
"tarantool> my_space:insert{'Tuple with bit value = 11', 0x03}\n"
"tarantool> my_space.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.EQ\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"...\n"
"tarantool> my_space.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ANY_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> my_space.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> my_space.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_NOT_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 01', 1]\n"
"..."
msgstr "tarantool> my_space = box.schema.space.create('space_with_bitset')\n"
"tarantool> my_space:create_index('primary_index', {\n"
"         >   parts = {1, 'string'},\n"
"         >   unique = true,\n"
"         >   type = 'TREE'\n"
"         > })\n"
"tarantool> my_space:create_index('bitset_index', {\n"
"         >   parts = {2, 'unsigned'},\n"
"         >   unique = false,\n"
"         >   type = 'BITSET'\n"
"         > })\n"
"tarantool> my_space:insert{'Tuple with bit value = 01', 0x01}\n"
"tarantool> my_space:insert{'Tuple with bit value = 10', 0x02}\n"
"tarantool> my_space:insert{'Tuple with bit value = 11', 0x03}\n"
"tarantool> my_space.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.EQ\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"...\n"
"tarantool> my_space.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ANY_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> my_space.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> my_space.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_NOT_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 01', 1]\n"
"..."

msgid "tarantool> box.schema.space.create('bitset_example')\n"
"tarantool> box.space.bitset_example:create_index('primary')\n"
"tarantool> box.space.bitset_example:create_index('bitset',{unique = false, type = 'BITSET', parts = {2,'unsigned'}})\n"
"tarantool> box.space.bitset_example:insert{1,1}\n"
"tarantool> box.space.bitset_example:insert{2,4}\n"
"tarantool> box.space.bitset_example:insert{3,7}\n"
"tarantool> box.space.bitset_example:insert{4,3}\n"
"tarantool> box.space.bitset_example.index.bitset:select(2, {iterator = 'BITS_ANY_SET'})"
msgstr "tarantool> box.schema.space.create('bitset_example')\n"
"tarantool> box.space.bitset_example:create_index('primary')\n"
"tarantool> box.space.bitset_example:create_index('bitset',{unique = false, type = 'BITSET', parts = {2,'unsigned'}})\n"
"tarantool> box.space.bitset_example:insert{1,1}\n"
"tarantool> box.space.bitset_example:insert{2,4}\n"
"tarantool> box.space.bitset_example:insert{3,7}\n"
"tarantool> box.space.bitset_example:insert{4,3}\n"
"tarantool> box.space.bitset_example.index.bitset:select(2, {iterator = 'BITS_ANY_SET'})"

msgid "The result will be:"
msgstr "Получим следующий результат:"

msgid "---\n"
"- - [3, 7]\n"
"  - [4, 3]\n"
"..."
msgstr "---\n"
"- - [3, 7]\n"
"  - [4, 3]\n"
"..."

msgid "because (7 AND 2) is not equal to 0, and (3 AND 2) is not equal to 0."
msgstr "поскольку (7 AND 2) не равно 0, и (3 AND 2) не равно 0."

msgid "Additionally, there exist :doc:`index iterator operations </reference/reference_lua/box_index/pairs>`. They can only be used with code in Lua and C/C++. Index iterators are for traversing indexes one key at a time, taking advantage of features that are specific to an index type. For example, they can be used for evaluating Boolean expressions when traversing BITSET indexes, or for going in descending order when traversing TREE indexes."
msgstr "Кроме того, есть :doc:`операции с итераторами с индексом </reference/reference_lua/box_index/pairs>`. Их можно использовать только с кодом на языках Lua и C/C++. Итераторы с индексом предназначены для обхода индексов по одному ключу за раз, поскольку используют особенности каждого типа индекса. Например, их можно использовать для оценки логических выражений при обходе BITSET-индексов или при обходе TREE-индексов в порядке по убыванию."

