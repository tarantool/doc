
msgid "Triggers"
msgstr "Триггеры"

msgid ""
"**Triggers**, also known as **callbacks**, are functions which the server "
"executes when certain events happen."
msgstr ""
"**Триггеры**, которые также называют **обратными вызовами**, представляют "
"собой функции, которые выполняет сервер при наступлении определенных "
"событий."

msgid ""
"To associate an event with a callback, one should pass the callback to the "
"corresponding :samp:`on_{event}` function:"
msgstr ""
"Чтобы связать событие с колбэк-функцией, необходимо передать её в "
"соответствующую функцию обработки событий :samp:`on_{event}`:"

msgid ""
":doc:`/reference/reference_lua/box_session/on_connect` or "
":doc:`/reference/reference_lua/box_session/on_disconnect`,"
msgstr ""
":doc:`/reference/reference_lua/box_session/on_connect` или "
":doc:`/reference/reference_lua/box_session/on_disconnect`,"

msgid ":doc:`/reference/reference_lua/box_session/on_auth`,"
msgstr ":doc:`/reference/reference_lua/box_session/on_auth`,"

msgid ""
":doc:`/reference/reference_lua/box_space/on_replace` or "
":doc:`/reference/reference_lua/box_space/before_replace`,"
msgstr ""
":doc:`/reference/reference_lua/box_space/on_replace` или "
":doc:`/reference/reference_lua/box_space/before_replace`,"

msgid ""
":doc:`/reference/reference_lua/box_txn_management/on_commit` or "
":doc:`/reference/reference_lua/box_txn_management/on_rollback`,"
msgstr ""
":doc:`/reference/reference_lua/box_txn_management/on_commit` или "
":doc:`/reference/reference_lua/box_txn_management/on_rollback`,"

msgid ""
":ref:`net.box.on_connect() <net_box-on_connect>` or "
":ref:`net.box.on_disconnect() <net_box-on_disconnect>`,"
msgstr ""
":ref:`net.box.on_connect() <net_box-on_connect>` или "
":ref:`net.box.on_disconnect() <net_box-on_disconnect>`,"

msgid ":ref:`net.box.on_schema_reload() <net_box-on_schema_reload>`,"
msgstr ":ref:`net.box.on_schema_reload() <net_box-on_schema_reload>`,"

msgid ""
":doc:`/reference/reference_lua/box_ctl/on_schema_init` or "
":doc:`/reference/reference_lua/box_ctl/on_shutdown`,"
msgstr ""
":doc:`/reference/reference_lua/box_ctl/on_schema_init` или "
":doc:`/reference/reference_lua/box_ctl/on_shutdown`,"

msgid ":ref:`swim_object:on_member_event() <swim-on_member_event>`,"
msgstr ":ref:`swim_object:on_member_event() <swim-on_member_event>`,"

msgid ":doc:`/reference/reference_lua/box_session/on_access_denied`."
msgstr ":doc:`/reference/reference_lua/box_session/on_access_denied`."

msgid ""
"Then the server will store the callback function and call it when the "
"corresponding event happens."
msgstr ""
"Тогда сервер сохранит колбэк-функцию и будет вызывать ее при наступлении "
"соответствующего события."

msgid "All triggers have the following characteristics:"
msgstr "У всех триггеров есть следующие особенности:"

msgid ""
"Triggers are defined only by the :ref:`'admin' user <authentication-"
"owners_privileges>`."
msgstr ""
"Только :ref:`пользователь \"admin\" <authentication-owners_privileges>` "
"определяет триггеры."

msgid ""
"Triggers are stored in the Tarantool instance's memory, not in the database."
" Therefore triggers disappear when the instance is shut down. To make them "
"permanent, put function definitions and trigger settings into Tarantool's "
":ref:`initialization script <index-init_label>`."
msgstr ""
"Триггеры хранятся в памяти экземпляра Tarantool, а не в базе данных. "
"Поэтому триггеры пропадают, когда экземпляр отключают. Чтобы сохранить их, "
"поместите определения функции и настройки триггера в :ref:`скрипт "
"инициализации <index-init_label>` Tarantool."

msgid ""
"Triggers have low overhead. If a trigger is not defined, then the overhead "
"is minimal: merely a pointer dereference and check. If a trigger is defined,"
" then its overhead is equivalent to the overhead of calling a function."
msgstr ""
"Триггеры не тратят много ресурсов. Если триггер не задан, то требуется "
"минимум вычислений — разыменование и проверка указателя. Если триггер "
"определен, то стоимость вызова равна стоимости вызова функции."

msgid ""
"There can be multiple triggers for one event. In this case, triggers are "
"executed in the reverse order that they were defined in."
msgstr ""
"Для одного события можно определить несколько триггеров. В таком случае "
"триггеры выполняются в обратном порядке относительно того, как их "
"определили."

msgid ""
"Triggers must work within the event context. If a trigger contains calls "
"which don't normally occur immediately after the event and before the return "
"from it (such as `os.exit() <http://www.lua.org/manual/5.1/manual.html#pdf-os.exit>`_"
" or :doc:`/reference/reference_lua/box_txn_management/rollback`),"
" the behavior is undefined."
msgstr ""
"Триггеры должны работать в контексте события. Если триггер содержит вызовы,"
" которые при нормальных условиях не могут "
"быть выполнены непосредственно после события и до возврата из него"
" (такие как `os.exit() <http://www.lua.org/manual/5.1/manual.html#pdf-os.exit>`_"
" или :doc:`/reference/reference_lua/box_txn_management/rollback`)"
", результат не определен."

msgid ""
"Triggers are replaceable. The request to \"redefine a trigger\" implies "
"passing a new trigger function and an old trigger function to one of the "
":samp:`on_{event}` functions."
msgstr ""
"Триггеры можно заменять. Запрос на \"замену триггера\" подразумевает "
"передачу новой функции-триггера и старой функции-триггера в одну из функций "
"обработки событий :samp:`on_{event}`."

msgid ""
"The :samp:`on_{event}` functions all have parameters which are function "
"pointers, and they all return function pointers. Remember that a Lua "
"function definition such as ``function f() x = x + 1 end`` is the same as "
"``f = function () x = x + 1 end`` - in both cases ``f`` gets a function "
"pointer. And ``trigger = box.session.on_connect(f)`` is the same as "
"``trigger = box.session.on_connect(function () x = x + 1 end)`` - in both "
"cases ``trigger`` gets the function pointer which was passed."
msgstr ""
"Во всех функциях обработки событий :samp:`on_{event}` есть параметры, "
"которые представляют собой указатели функции, и все они возвращают указатели"
" функции. Следует запомнить, что определение Lua-функции, например, "
"``function f() x = x + 1 end`` значит то же самое, что ``f = function () x ="
" x + 1 end``, поскольку в обоих случаях ``f`` получит указатель функции. А "
"``trigger = box.session.on_connect(f)`` значит то же самое, что ``trigger = "
"box.session.on_connect(function () x = x + 1 end)`` — в обоих случаях "
"``trigger`` получит переданный указатель функции."

msgid ""
"You can call any :samp:`on_{event}` function with no arguments to get a list"
" of its triggers. For example, use ``box.session.on_connect()`` to return a "
"table of all connect-trigger functions."
msgstr ""
"Если вызвать любую из функций обработки событий :samp:`on_{event}` без "
"аргументов, то она вернет список соответствующих триггеров. Например, "
"``box.session.on_connect()`` вернет таблицу со всеми функциями-триггерами на"
" подключение."

msgid ""
"Triggers can be useful in solving problems with replication. See details in "
":ref:`Resolving replication conflicts <replication-problem_solving>`."
msgstr ""
"Триггеры можно использовать для решения проблем с репликацией. Более "
"подробную информацию см. в разделе :ref:`Решение конфликтов репликации "
"<replication-problem_solving>`."

msgid "**Example:**"
msgstr "**Пример:**"

msgid "Here we log connect and disconnect events into Tarantool server log."
msgstr ""
"Здесь мы записываем события подключения и отключения в журнал на сервере "
"Tarantool."

msgid ""
"log = require('log')\n"
"\n"
"function on_connect_impl()\n"
" log.info(\"connected \"..box.session.peer()..\", sid \"..box.session.id())\n"
"end\n"
"\n"
"function on_disconnect_impl()\n"
" log.info(\"disconnected, sid \"..box.session.id())\n"
"end\n"
"\n"
"function on_auth_impl(user)\n"
" log.info(\"authenticated sid \"..box.session.id()..\" as \"..user)\n"
"end\n"
"\n"
"function on_connect() pcall(on_connect_impl) end\n"
"function on_disconnect() pcall(on_disconnect_impl) end\n"
"function on_auth(user) pcall(on_auth_impl, user) end\n"
"\n"
"box.session.on_connect(on_connect)\n"
"box.session.on_disconnect(on_disconnect)\n"
"box.session.on_auth(on_auth)"
msgstr ""
"log = require('log')\n"
"\n"
"function on_connect_impl()\n"
" log.info(\"connected \"..box.session.peer()..\", sid \"..box.session.id())\n"
"end\n"
"\n"
"function on_disconnect_impl()\n"
" log.info(\"disconnected, sid \"..box.session.id())\n"
"end\n"
"\n"
"function on_auth_impl(user)\n"
" log.info(\"authenticated sid \"..box.session.id()..\" as \"..user)\n"
"end\n"
"\n"
"function on_connect() pcall(on_connect_impl) end\n"
"function on_disconnect() pcall(on_disconnect_impl) end\n"
"function on_auth(user) pcall(on_auth_impl, user) end\n"
"\n"
"box.session.on_connect(on_connect)\n"
"box.session.on_disconnect(on_disconnect)\n"
"box.session.on_auth(on_auth)"
