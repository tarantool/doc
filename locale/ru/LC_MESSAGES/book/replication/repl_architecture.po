
msgid "Replication architecture"
msgstr "Архитектура механизма репликации"

msgid "Replication mechanism"
msgstr "Механизм репликации"

msgid ""
"A pack of instances which operate on copies of the same databases make up"
" a **replica set**. Each instance in a replica set has a role, **master**"
" or **replica**."
msgstr ""
"**Набор реплик** (replica set) -- это совокупность экземпляров, которые "
"работают на копиях одной базы данных. У каждого экземпляра в наборе "
"реплик есть роль: **мастер** или **реплика**."

msgid ""
"A replica gets all updates from the master by continuously fetching and "
"applying its :ref:`write ahead log (WAL)<internals-wal>`. Each record in "
"the WAL represents a single Tarantool data-change request such as "
":ref:`INSERT<box_space-insert>`, :ref:`UPDATE<box_space-update>` or "
":ref:`DELETE<box_space-delete>`, and is assigned a monotonically growing "
"log sequence number (**LSN**). In essence, Tarantool replication is "
"**row-based**: each data-change request is fully deterministic and "
"operates on a single :ref:`tuple<index-box_tuple>`. However, unlike a "
"classical row-based log, which contains entire copies of the changed "
"rows, Tarantool's WAL contains copies of the requests. For example, for "
"UPDATE requests, Tarantool only stores the primary key of the row and the"
" update operations, to save space."
msgstr ""
"Реплика получает все обновления от мастера, постоянно запрашивая и "
"применяя данные :ref:`журнала упреждающей записи (WAL)<internals-wal>`. "
"Каждая запись в WAL представляет собой отдельный запрос на изменение "
"данных в Tarantool’е, например, :ref:`INSERT<box_space-insert>`, "
":ref:`UPDATE<box_space-update>` или :ref:`DELETE<box_space-delete>`. "
"Такой записи присваивается монотонно возрастающее число, представляющее "
"регистрационный номер в журнале (**LSN**). По сути, репликация в "
"Tarantool’е является **построчной**: каждая команда на изменение данных "
"полностью детерминирована и относится к отдельному :ref:`кортежу<index-"
"box_tuple>`. Однако в отличие от типичного построчного журнала, который "
"содержит копии измененных строк полностью, WAL в Tarantool'е включает в "
"себя копии запросов. Например, для запросов типа UPDATE (обновление) "
"Tarantool сохранит только первичный ключ строки и операции обновления для"
" экономии места."

msgid ""
"Invocations of **stored programs** are not written to the WAL. Instead, "
"records of the actual **data-change requests, performed by the Lua "
"code**, are written to the WAL. This ensures that possible non-"
"determinism of Lua does not cause replication to go out of sync."
msgstr ""
"Вызовы **хранимых процедур** не регистрируются в журнале упреждающей "
"записи. Между тем, события по запросам **изменения фактических данных, "
"которые выполняют Lua-скрипты**, регистрируются в журнале. Таким образом,"
" возможное недетерминированное выполнение Lua гарантированно не приведет "
"к рассинхронизации."

msgid ""
"Data definition operations on **temporary spaces**, such as "
"creating/dropping, adding indexes, truncating, etc., are written to the "
"WAL, since information about temporary spaces is stored in non-temporary "
"system spaces, such as :ref:`box.space._space <box_space-space>`. Data "
"change operations on temporary spaces are not written to the WAL and are "
"not replicated."
msgstr ""
"Операции по определению данных во **временных спейсах**, такие как "
"создание/удаление, добавление индексов, усечение и т.д., регистрируются в"
" журнале, поскольку информация о временных спейсах хранится в постоянных "
"системных спейсах, например :ref:`box.space._space <box_space-space>`. "
"Операции по изменению данных во временных спейсах не регистрируются в "
"журнале и не реплицируются."

msgid ""
"Data change operations on **replication-local** spaces (spaces "
":doc:`created </reference/reference_lua/box_schema/space_create>` with "
"``is_local = true``) are written to the WAL but are not replicated."
msgstr ""
"Операции по изменению данных в спейсах с **локальной репликацией** "
"(спейсах, :doc:`созданных "
"</reference/reference_lua/box_schema/space_create>` с параметром "
"``is_local = true``) не регистрируются в журнале и не реплицируются."

msgid ""
"To create a valid initial state, to which WAL changes can be applied, "
"every instance of a replica set requires a start set of :ref:`checkpoint "
"files <index-box_persistence>`, such as .snap files for memtx and .run "
"files for vinyl. A replica joining an existing replica set, chooses an "
"existing master and automatically downloads the initial state from it. "
"This is called an **initial join**."
msgstr ""
"Чтобы создать подходящее начальное состояние, к которому можно применить "
"изменения из WAL-файла, для каждого экземпляра из набора реплик должен "
"быть исходный набор :ref:`файлов контрольной точки <index-"
"box_persistence>` -- .snap-файлы для memtx и .run-файлы для vinyl. Когда "
"реплика включается в существующий набор реплик, она выбирает "
"существующего мастера и автоматически загружает с него начальное "
"состояние. Это называется **начальным включением**."

msgid ""
"When an entire replica set is bootstrapped for the first time, there is "
"no master which could provide the initial checkpoint. In such a case, "
"replicas connect to each other and elect a master, which then creates the"
" starting set of checkpoint files, and distributes it to all the other "
"replicas. This is called an **automatic bootstrap** of a replica set."
msgstr ""
"При первой настройке целого набора реплик нет мастера, который "
"предоставил бы начальную контрольную точку. В таком случае реплики "
"подключаются друг к другу и выбирают мастера, который затем создает "
"начальный набор файлов контрольной точки и отправляет его всем репликам. "
"Это называется **самонастройкой** набора реплик."

msgid ""
"When a replica contacts a master (there can be many masters) for the "
"first time, it becomes part of a replica set. On subsequent occasions, it"
" should always contact a master in the same replica set. Once connected "
"to the master, the replica requests all changes that happened after the "
"latest local LSN (there can be many LSNs -- each master has its own LSN)."
msgstr ""
"Когда реплика впервые подключается к мастеру (может быть много мастеров),"
" она становится частью набора реплик. В последующих случаях она всегда "
"должна подключаться к мастеру в этом наборе реплик. После подключения к "
"мастеру реплика запрашивает все изменения, произошедшие с момента "
"последнего локального LSN (может быть много LSN -- у каждого мастера свой"
" LSN)."

msgid ""
"Each replica set is identified by a globally unique identifier, called "
"the **replica set UUID**. The identifier is created by the master which "
"creates the very first checkpoint, and is part of the checkpoint file. It"
" is stored in system space :ref:`box.space._schema <box_space-schema>`. "
"For example:"
msgstr ""
"Каждый набор реплик можно определить по глобально-уникальному "
"идентификатору, который называется **UUID набора реплик**. Идентификатор "
"создается мастером во время создания самой первой контрольной точки и "
"является частью файла контрольной точки. Он хранится в системном спейсе "
":ref:`box.space._schema <box_space-schema>`. Пример:"

msgid ""
"tarantool> box.space._schema:select{'cluster'}\n"
"---\n"
"- - ['cluster', '6308acb9-9788-42fa-8101-2e0cb9d3c9a0']\n"
"..."
msgstr ""
"tarantool> box.space._schema:select{'cluster'}\n"
"---\n"
"- - ['cluster', '6308acb9-9788-42fa-8101-2e0cb9d3c9a0']\n"
"..."

msgid ""
"Additionally, each instance in a replica set is assigned its own UUID, "
"when it joins the replica set. It is called an **instance UUID** and is a"
" globally unique identifier. The instance UUID is checked to ensure that "
"instances do not join a different replica set, e.g. because of a "
"configuration error. A unique instance identifier is also necessary to "
"apply rows originating from different masters only once, that is, to "
"implement multi-master replication. This is why each row in the write "
"ahead log, in addition to its log sequence number, stores the instance "
"identifier of the instance on which it was created. But using a UUID as "
"such an identifier would take too much space in the write ahead log, thus"
" a shorter integer number is assigned to the instance when it joins a "
"replica set. This number is then used to refer to the instance in the "
"write ahead log. It is called **instance id**. All identifiers are stored"
" in system space :ref:`box.space._cluster <box_space-cluster>`. For "
"example:"
msgstr ""
"Кроме того, каждому экземпляру в наборе реплик присваивается свой UUID, "
"когда он включается в набор реплик. Такой глобально-уникальный "
"идентификатор называется **UUID экземпляра**. UUID экземпляра "
"проверяется, чтобы экземпляры не подключались к различным наборам реплик,"
" например, из-за ошибки конфигурации. Уникальный идентификатор экземпляра"
" также необходим для однократного применения строк от разных мастеров, то"
" есть для многомастерной репликации. Вот почему каждая строка в журнале "
"упреждающей записи, помимо номер записи в журнале, хранит идентификатор "
"экземпляра, где запись была создана. Но использование UUID в качестве "
"такого идентификатора заняло бы слишком много места в журнале упреждающей"
" записи, поэтому экземпляру присваивается целое число при включении в "
"набор реплик. Это число, которое называется **ID экземпляра**, затем "
"используется для ссылок на экземпляр в журнале упреждающей записи. Все "
"идентификаторы хранятся в системном спейсе :ref:`box.space._cluster "
"<box_space-cluster>`. Например:"

msgid ""
"tarantool> box.space._cluster:select{}\n"
"---\n"
"- - [1, '88580b5c-4474-43ab-bd2b-2409a9af80d2']\n"
"..."
msgstr ""
"tarantool> box.space._cluster:select{}\n"
"---\n"
"- - [1, '88580b5c-4474-43ab-bd2b-2409a9af80d2']\n"
"..."

msgid ""
"Here the instance ID is ``1`` (unique within the replica set), and the "
"instance UUID is ``88580b5c-4474-43ab-bd2b-2409a9af80d2`` (globally "
"unique)."
msgstr ""
"Здесь ID экземпляра -- ``1`` (уникальный номер в рамках набора реплик), а"
" UUID экземпляра -- ``88580b5c-4474-43ab-bd2b-2409a9af80d2`` (глобально "
"уникальный)."

msgid ""
"Using instance IDs is also handy for tracking the state of the entire "
"replica set. For example, :ref:`box.info.vclock <box_introspection-"
"box_info>` describes the state of replication in regard to each connected"
" peer."
msgstr ""
"Использование идентификаторов экземпляра также полезно для отслеживания "
"состояния всего набора реплик. Например, :ref:`box.info.vclock "
"<box_introspection-box_info>` описывает состояние репликации в отношении "
"каждого подключенного узла."

msgid ""
"tarantool> box.info.vclock\n"
"---\n"
"- {1: 827, 2: 584}\n"
"..."
msgstr ""
"tarantool> box.info.vclock\n"
"---\n"
"- {1: 827, 2: 584}\n"
"..."

msgid ""
"Here ``vclock`` contains log sequence numbers (827 and 584) for instances"
" with instance IDs 1 and 2."
msgstr ""
"Здесь ``vclock`` содержит номера записей в журнале (827 и 584) для "
"экземпляров с идентификаторами экземпляра 1 и 2."

msgid ""
"Starting in Tarantool 1.7.7, it is possible for administrators to assign "
"the instance UUID and the replica set UUID values, rather than let the "
"system generate them -- see the description of the :ref:`replicaset_uuid "
"<cfg_replication-replicaset_uuid>` configuration parameter."
msgstr ""
"Начиная с Tarantool 1.7.7, появилась возможность для администраторов "
"назначать UUID экземпляра и UUID набора реплик вместо сгенерированных "
"системой значений -- см. описание конфигурационного параметра "
":ref:`replicaset_uuid <cfg_replication-replicaset_uuid>`."

msgid "Replication setup"
msgstr "Настройка репликации"

msgid ""
"To enable replication, you need to specify two parameters in a "
"``box.cfg{}`` request:"
msgstr ""
"Чтобы включить репликацию, необходимо указать два параметра в запросе "
"``box.cfg{}``:"

msgid ""
":ref:`replication <cfg_replication-replication>` which defines the "
"replication source(s), and"
msgstr ""
":ref:`replication <cfg_replication-replication>`, который определяет "
"источники репликации, и"

msgid ""
":ref:`read_only <cfg_basic-read_only>` which is ``true`` for a replica "
"and ``false`` for a master."
msgstr ""
":ref:`read_only <cfg_basic-read_only>` со значением ``true`` для реплики "
"и ``false`` для мастера."

msgid ""
"Both these parameters are \"dynamic\". This allows a replica to become a "
"master and vice versa on the fly with the help of a ``box.cfg{}`` "
"request."
msgstr ""
"\"Динамические\" параметры репликации можно менять на лету, что позволяет"
" назначать реплику на роль мастера и наоборот. Для этого используется "
"запрос ``box.cfg{}``."

msgid ""
"Later we will give a detailed example of :ref:`bootstrapping a replica "
"set <replication-bootstrap>`."
msgstr ""
"Далее подробно рассмотрим пример :ref:`настройки набора реплик "
"<replication-bootstrap>`."

msgid "Replication roles: master and replica"
msgstr "Роли в репликации: мастер и реплика"

msgid ""
"The replication role (master or replica) is set by the :ref:`read_only "
"<cfg_basic-read_only>` configuration parameter. The recommended role is "
"\"read_only\" (replica) for all but one instance in the replica set."
msgstr ""
"Конфигурационный параметр :ref:`read_only <cfg_basic-read_only>` "
"определяет роль в репликации (мастер или реплика). Рекомендованная роль "
"для всех экземпляров в наборе реплик, кроме одного -- \"read-only\" "
"(реплика)."

msgid ""
"In a master-replica configuration, every change that happens on the "
"master will be visible on the replicas, but not vice versa."
msgstr ""
"В конфигурации мастер-реплика каждое изменение, сделанное на мастере, "
"будет отображаться на репликах, но не наоборот."

msgid ""
"A simple two-instance replica set with the master on one machine and the "
"replica on a different machine provides two benefits:"
msgstr ""
"Простой набор реплик с двумя экземплярами, один из которых является "
"мастером и расположен на одной машине, а другой -- реплика -- расположен "
"на другой машине, дает два преимущества:"

msgid ""
"**failover**, because if the master goes down then the replica can take "
"over, and"
msgstr ""
"**восстановление после отказа**, поскольку в случае отказа мастера "
"реплика может взять работу на себя, и"

msgid ""
"**load balancing**, because clients can connect to either the master or "
"the replica for read requests."
msgstr ""
"**балансировка нагрузки**, потому что клиенты во время запросов чтения "
"могут подключаться к мастеру или к реплике."

msgid ""
"In a **master-master** configuration (also called \"multi-master\"), "
"every change that happens on either instance will be visible on the other"
" one."
msgstr ""
"В конфигурации **мастер-мастер** (которая также называется "
"\"многомастерной\") каждое изменение на любом экземпляре будет также "
"отображаться на другом."

msgid ""
"The failover benefit in this case is still present, and the load-"
"balancing benefit is enhanced, because any instance can handle both read "
"and write requests. Meanwhile, for multi-master configurations, it is "
"necessary to understand the **replication guarantees** provided by the "
"asynchronous protocol that Tarantool implements."
msgstr ""
"Восстановление после отказа в таком случае также будет преимуществом, а "
"балансировка нагрузки улучшится, поскольку любой экземпляр может "
"обрабатывать запросы и на чтение, и на запись. В то же время, при "
"многомастерной конфигурации необходимо понимать **гарантии репликации**, "
"которые обеспечивает асинхронный протокол, внедренный в Tarantool."

msgid ""
"Tarantool multi-master replication guarantees that each change on each "
"master is propagated to all instances and is applied only once. Changes "
"from the same instance are applied in the same order as on the "
"originating instance. Changes from different instances, however, can be "
"mixed and applied in a different order on different instances. This may "
"lead to replication going out of sync in certain cases."
msgstr ""
"Многомастерная репликация Tarantool'а гарантирует, что каждое изменение "
"на каждом мастере передается на все экземпляры и применяется только один "
"раз. Изменения с одного экземпляра применяются в том же порядке, что и на"
" исходном экземпляре. Однако изменения с разных экземпляров могут "
"смешиваться и применяться в различном порядке на разных экземплярах. В "
"определенных случаях это может привести к рассинхронизации."

msgid ""
"For example, assuming the database is only appended to (i.e. it contains "
"only insertions), a multi-master configuration is safe. If there are also"
" deletions, but it is not mission critical that deletion happens in the "
"same order on all replicas (e.g. the DELETE is used to prune expired "
"data), a master-master configuration is also safe."
msgstr ""
"Например, принимая, что проводятся только операции добавления данных в "
"базу (т.е. она содержит только вставки), многомастерная конфигурация "
"сработает хорошо. Если данные также удаляются, но порядок операций "
"удаления на разных репликах не играет важной роли (например, DELETE "
"используется для отсечения устаревших данных), то конфигурация "
"мастер-мастер также безопасна."

msgid ""
"UPDATE operations, however, can easily go out of sync. For example, "
"assignment and increment are not commutative, and may yield different "
"results if applied in different order on different instances."
msgstr ""
"Однако операции обновления UPDATE могут с легкостью привести к "
"рассинхронизации. Например, операции присваивания и увеличения не "
"обладают коммутативностью и могут привести к различным результатам, если "
"применять их в различном порядке на разных экземплярах."

msgid ""
"More generally, it is only safe to use Tarantool master-master "
"replication if all database changes are **commutative**: the end result "
"does not depend on the order in which the changes are applied. You can "
"start learning more about conflict-free replicated data types `here "
"<https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type>`_."
msgstr ""
"В общем смысле, безопасно использовать репликацию мастер-мастер в "
"Tarantool'е, если все изменения в базе данных являются "
"**коммутативными**: конечный результат не зависит от порядка, в котором "
"применяются изменения. Дополнительную информацию о бесконфликтных типах "
"реплицируемых данных можно получить `здесь <https://en.wikipedia.org/wiki"
"/Conflict-free_replicated_data_type>`_."

msgid "Replication topologies: cascade, ring and full mesh"
msgstr "Топологии репликации: каскадная, кольцевая и полная ячеистая"

msgid ""
"Replication topology is set by the :ref:`replication <cfg_replication-"
"replication>` configuration parameter. The recommended topology is a "
"**full mesh**, because it makes potential failover easy."
msgstr ""
"Топология репликации определяется в конфигурационном параметре "
":ref:`replication <cfg_replication-replication>`. Рекомендована **полная "
"ячеистая** конфигурация, поскольку она облегчает возможное восстановление"
" после сбоя."

msgid ""
"Some database products offer **cascading replication** topologies: "
"creating a replica on a replica. Tarantool does not recommend such setup."
msgstr ""
"Некоторые СУБД предлагают топологии **каскадной репликации**: создание "
"реплики на реплике. Tarantool не рекомендует такие настройки."

msgid ""
"The problem with a cascading replica set is that some instances have no "
"connection to other instances and may not receive changes from them. One "
"essential change that must be propagated across all instances in a "
"replica set is an entry in ``box.space._cluster`` system space with the "
"replica set UUID. Without knowing the replica set UUID, a master refuses "
"to accept connections from such instances when replication topology "
"changes. Here is how this can happen:"
msgstr ""
"Недостаток каскадного набора реплик заключается в том, что некоторые "
"экземпляры не подключаются к другим экземплярам, поэтому не могут "
"получать от них изменения. Одно важное изменение, которое следует "
"передавать на все экземпляры в наборе реплик -- запись в системный спейс "
"``box.space._cluster`` с UUID набора реплик. Не зная UUID набора реплик, "
"мастер отклоняет подключения от таких экземпляров при изменении топологии"
" репликации. Вот как это может произойти:"

msgid ""
"We have a chain of three instances. Instance #1 contains entries for "
"instances #1 and #2 in its ``_cluster`` space. Instances #2 and #3 "
"contain entries for instances #1, #2 and #3 in their ``_cluster`` spaces."
msgstr ""
"У нас есть цепочка из трех экземпляров. Экземпляр №1 содержит записи для "
"экземпляров №1 и №2 в спейсе ``_cluster``. Экземпляры №2 и №3 содержат "
"записи для экземпляров №1, №2 и №3 в своих спейсах ``_cluster``."

msgid ""
"Now instance #2 is faulty. Instance #3 tries connecting to instance #1 as"
" its new master, but the master refuses the connection since it has no "
"entry for instance #3."
msgstr ""
"Теперь экземпляр №2 неисправен. Экземпляр №3 пытается подключиться к "
"экземпляру №1, как к новому мастеру, но мастер отклоняет подключение, "
"поскольку не содержит запись для экземпляра №3."

msgid "**Ring replication** topology is, however, supported:"
msgstr "Тем не менее, **кольцевая топология** поддерживается:"

msgid ""
"So, if you need a cascading topology, you may first create a ring to "
"ensure all instances know each other’s UUID, and then disconnect the "
"chain in the place you desire."
msgstr ""
"Поэтому если необходима каскадная топология, можно первоначально создать "
"кольцо, чтобы все экземпляры знали UUID друг друга, а затем разъединить "
"цепочку в необходимом месте."

msgid ""
"A stock recommendation for a master-master replication topology, however,"
" is a **full mesh**:"
msgstr ""
"Как бы то ни было, для репликации мастер-мастер рекомендуется **полная "
"ячеистая** топология:"

msgid ""
"You then can decide where to locate instances of the mesh -- within the "
"same data center, or spread across a few data centers. Tarantool will "
"automatically ensure that each row is applied only once on each instance."
" To remove a degraded instance from a mesh, simply change the "
"``replication`` configuration parameter."
msgstr ""
"В таком случае можно решить, где расположить экземпляры ячейки -- в том "
"же центре обработки данных или разместить в нескольких центрах. Tarantool"
" будет автоматически следить за тем, что каждая строка применяется "
"однократно на каждом экземпляре. Чтобы удалить экземпляр из ячейки после "
"отказа, просто измените конфигурационный параметр ``replication``."

msgid ""
"This ensures full cluster availability in case of a local failure, e.g. "
"one of the instances failing in one of the data centers, as well as in "
"case of an entire data center failure."
msgstr ""
"Таким образом можно обеспечить доступность всего кластера в случае "
"локального отказа, например отказа одного экземпляра в одном центре "
"обработки данных, а также в случае отказа всего центра обработки данных."

msgid "The maximal number of replicas in a mesh is 32."
msgstr "Максимальное количество реплик в ячейке -- 32."
