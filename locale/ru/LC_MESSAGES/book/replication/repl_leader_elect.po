
msgid "Automated leader election"
msgstr "Автоматические выборы лидера"

msgid ""
"Starting from version :doc:`2.6.1 </release/2.6.1>`, Tarantool has the "
"built-in functionality managing automated *leader election* in a replica "
"set. This functionality increases the fault tolerance of the systems built "
"on the base of Tarantool and decreases dependency on the external tools for "
"replica set management."
msgstr ""
"В Tarantool, начиная с версии :doc:`2.6.1 </release/2.6.1>`, есть встроенная"
" функциональность для управления автоматическими *выборами лидера* "
"(automated leader election) в наборе реплик (replica set). Эта "
"функциональность повышает отказоустойчивость систем на базе Tarantool и "
"снижает зависимость от внешних инструментов для управления набором реплик."

msgid "The following topics are described below:"
msgstr "Ниже описаны следующие темы:"

msgid "Leader election and synchronous replication"
msgstr "Выборы лидера и синхронная репликация"

msgid ""
"Leader election and synchronous replication are implemented in Tarantool as "
"a modification of the `Raft "
"<https://en.wikipedia.org/wiki/Raft_(computer_science)>`__ algorithm. Raft "
"is an algorithm of synchronous replication and automatic leader election. "
"Its complete description can be found in the `corresponding document "
"<https://raft.github.io/raft.pdf>`_."
msgstr ""
"В Tarantool используется модификация `Raft "
"<https://en.wikipedia.org/wiki/Raft_(computer_science)>`__ — алгоритма "
"синхронной репликации и автоматических выборов лидера. Полное описание "
"алгоритма Raft можно прочитать `в соответствующем документе "
"<https://raft.github.io/raft.pdf>`_."

msgid ""
"In Tarantool, :ref:`synchronous replication <repl_sync>` and leader election"
" are supported as two separate subsystems. So it is possible to get "
"synchronous replication but use an alternative algorithm for leader "
"election. And vice versa -- elect a leader in the cluster but don't use "
"synchronous spaces at all. Synchronous replication has a separate "
":ref:`documentation section <repl_sync>`. Leader election is described "
"below."
msgstr ""
":ref:`Синхронная репликация <repl_sync>` и выборы лидера в Tarantool "
"реализованы как две независимые подсистемы. Это означает, что можно "
"настроить синхронную репликацию, а для выборов лидера использовать "
"альтернативный алгоритм. Встроенный механизм выборов лидера, в свою очередь,"
" не требует использования синхронных спейсов. Синхронной репликации посвящён"
" :ref:`этот раздел документации <repl_sync>`. Процесс выборов лидера описан "
"ниже."

msgid "Leader election process"
msgstr "Процесс выборов лидера"

msgid ""
"Automated leader election in Tarantool helps guarantee that there is at most"
" one leader at any given moment of time in a replica set. A *leader* is a "
"writable node, and all other nodes are non-writable -- they accept read-only"
" requests exclusively."
msgstr ""
"Автоматические выборы лидера в Tarantool гарантируют, что в каждый момент "
"времени в наборе реплик будет максимум один *лидер* — узел, доступный для "
"записи. Все остальные узлы будут принимать исключительно запросы на чтение."

msgid ""
"When :ref:`the election is enabled <repl_leader_elect_config>`, the life "
"cycle of a replica set is divided into so-called *terms*. Each term is "
"described by a monotonically growing number. After the first boot, each node"
" has its term equal to 1. When a node sees that it is not a leader and there"
" is no leader available for some time in the replica set, it increases the "
"term and starts a new leader election round."
msgstr ""
"Когда :ref:`функция выборов включена <repl_leader_elect_config>`, жизненный "
"цикл набора реплик разделён на так называемые *термы* (term). Каждый терм "
"описывается монотонно растущим числом. После первой загрузки узла значение "
"его терма равно 1. Когда узел обнаруживает, что не является лидером и при "
"этом лидера в наборе реплик уже какое-то время нет, он увеличивает значение "
"своего терма и начинает новый тур выборов."

msgid ""
"Leader election happens via votes. The node which started the election votes"
" for itself and sends vote requests to other nodes. Upon receiving vote "
"requests, a node votes for the first of them, and then cannot do anything in"
" the same term but wait for a leader being elected."
msgstr ""
"Выборы лидера происходят посредством голосования. Узел, начинающий выборы, "
"голосует сам за себя и отправляет другим запросы на голос. Каждый экземпляр "
"голосует за первый узел, от которого пришёл такой запрос, и далее в течение "
"всего терма ожидает избрания лидера, не выполняя никаких действий."

msgid ""
"The node that collected a :ref:`quorum of votes <repl_leader_elect_config>` "
"becomes the leader and notifies other nodes about that. Also, a split vote "
"can happen when no nodes received a quorum of votes. In this case, after a "
":ref:`random timeout <repl_leader_elect_config>`, each node increases its "
"term and starts a new election round if no new vote request with a greater "
"term arrives during this time period. Eventually, a leader is elected."
msgstr ""
"Узел, собравший :ref:`кворум голосов <repl_leader_elect_config>`, становится"
" лидером и оповещает об этом другие узлы. Голоса могут разделиться, если ни "
"один узел не получит кворума. В этом случае спустя :ref:`случайное время "
"<repl_leader_elect_config>` происходят перевыборы: каждый узел увеличивает "
"значение терма и начинает новый тур, если за период ожидания не получил "
"запроса на голос от узла, чей терм больше. В итоге определяется лидер "
"кластера."

msgid ""
"All the non-leader nodes are called *followers*. The nodes that start a new "
"election round are called *candidates*. The elected leader sends heartbeats "
"to the non-leader nodes to let them know it is alive. So if there are no "
"heartbeats for a period set by the :ref:`replication_timeout "
"<cfg_replication-replication_timeout>` option, a new election starts. Terms "
"and votes are persisted by each instance in order to preserve certain Raft "
"guarantees."
msgstr ""
"Узлы, не являющиеся лидерами, называются *последователями* (followers). "
"Узлы, которые начинают новый тур выборов, называются *кандидатами* "
"(candidates). Избранный лидер отправляет остальным узлам контрольные сигналы"
" (heartbeats), оповещая о том, что он работает (alive). Если контрольные "
"сигналы не приходят в течение времени, заданного параметром "
":ref:`replication_timeout <cfg_replication-replication_timeout>`, начинаются"
" новые выборы. Чтобы алгоритм Raft гарантированно выполнялся, термы и голоса"
" сохраняются на каждом экземпляре."

msgid ""
"During the election, the nodes prefer to vote for those ones that have the "
"newest data. So as if an old leader managed to send something before its "
"death to a quorum of replicas, that data wouldn't be lost."
msgstr ""
"При голосовании узлы отдают предпочтение экземплярам, где сохранены самые "
"новые данные. Поэтому, если прежний лидер перед тем, как стать недоступным, "
"отправит кворуму реплик какую-либо информацию, она не будет потеряна."

msgid ""
"When :ref:`election is enabled <repl_leader_elect_config>`, there must be "
"connections between each node pair so as it would be the full mesh topology."
" This is needed because election messages for voting and other internal "
"things need direct connection between the nodes."
msgstr ""
"Необходимо, чтобы все узлы, :ref:`включённые в процесс выборов "
"<repl_leader_elect_config>`, были соединены попарно и образовывали полную "
"ячеистую топологию (full mesh). Для передачи запросов, связанных с "
"голосованием, и других внутренних сообщений требуется прямая связь между "
"узлами."

msgid ""
"Also, if election is enabled on the node, it won't replicate from any nodes "
"except the newest leader. This is done to avoid the issue when a new leader "
"is elected, but the old leader has somehow survived and tries to send more "
"changes to the other nodes."
msgstr ""
"Любой узел, участвующий в процессе выборов, реплицирует данные только с "
"последнего избранного лидера. Это позволяет избежать ситуации, в которой "
"прежний лидер после выборов нового всё ещё пытается отправлять изменения на "
"реплики."

msgid ""
"Term numbers also work as a kind of a filter. For example, you can be sure "
"that if election is enabled on two nodes and ``node1`` has the term number "
"less than ``node2``, then ``node2`` won't accept any transactions from "
"``node1``."
msgstr ""
"Числовые значения термов также выполняют функцию своеобразного фильтра. "
"Например, если на двух узлах включена функция выборов и значение терма "
"``node1`` меньше значения терма ``node2``, то узел ``node2`` не будет "
"принимать транзакций от узла ``node1``."

msgid "Configuration"
msgstr "Настройка"

msgid ""
"box.cfg({\n"
"    election_mode = <string>,\n"
"    election_timeout = <seconds>,\n"
"    replication_timeout = <seconds>,\n"
"    replication_synchro_quorum = <count>,\n"
"})"
msgstr ""
"box.cfg({\n"
"    election_mode = <string>,\n"
"    election_timeout = <seconds>,\n"
"    replication_timeout = <seconds>,\n"
"    replication_synchro_quorum = <count>,\n"
"})"

msgid ""
"``election_mode`` -- specifies the role of a node in the leader election "
"process. For the details, refer to the :ref:`option description "
"<cfg_replication-election_mode>` in the configuration reference."
msgstr ""
"``election_mode`` — определяет роль узла в процессе выборов лидера. "
"Подробное :ref:`описание параметра <cfg_replication-election_mode>` "
"приводится в справочнике по настройке."

msgid ""
"``election_timeout`` -- specifies the timeout between election rounds if the"
" previous round ended up with a split vote. For the details, refer to the "
":ref:`option description <cfg_replication-election_timeout>` in the "
"configuration reference."
msgstr ""
"``election_timeout`` — задаёт промежуток времени между турами в случае "
"разделения голосов и последующих перевыборов. Подробное :ref:`описание "
"параметра <cfg_replication-election_timeout>` приводится в справочнике по "
"настройке."

msgid ""
"``replication_timeout`` -- reuse of the :ref:`replication_timeout "
"<cfg_replication-replication_timeout>` configuration option for the purpose "
"of the leader election process. Heartbeats sent by an active leader have a "
"timeout after which a new election starts. Heartbeats are sent once per "
"<replication_timeout> seconds. Default value is ``1``. The leader is "
"considered dead if it hasn't sent any heartbeats for the period of "
"``<replication_timeout> * 4``."
msgstr ""
"``replication_timeout`` — параметр репликации :ref:`replication_timeout "
"<cfg_replication-replication_timeout>`, используемый для выборов лидера. "
"Активный лидер отправляет сообщения контрольного сигнала каждые "
"<replication_timeout> секунд. Значение параметра по умолчанию — ``1``. Если "
"лидер не отправляет сообщений контрольного сигнала в течение "
"``<replication_timeout> * 4`` секунд, он считается недоступным (dead) и "
"начинаются новые выборы."

msgid ""
"``replication_synchro_quorum`` -- reuse of the "
":ref:`replication_synchro_quorum <cfg_replication-"
"replication_synchro_quorum>` option for the purpose of configuring the "
"election quorum. The default value is ``1``, meaning that each node becomes "
"a leader immediately after voting for itself. It is the best to set up this "
"option value to the ``(<cluster size> / 2) + 1``. Otherwise, there is no "
"guarantee that there is only one leader at a time."
msgstr ""
"``replication_synchro_quorum`` — параметр репликации "
":ref:`replication_synchro_quorum <cfg_replication-"
"replication_synchro_quorum>`, используемый для настройки кворума. Значение "
"по умолчанию — ``1``, то есть каждый узел, проголосовав за себя, немедленно "
"становится лидером. Лучше всего задать этому параметру значение ``(<размер "
"кластера> / 2) + 1``. В противном случае нет гарантий, что в каждый момент "
"времени в кластере будет только один лидер."

msgid ""
"Besides, it is important to know that being a leader is not the only "
"requirement for a node to be writable. A leader node should have its "
":ref:`read_only <cfg_basic-read_only>` option set to ``false`` "
"(``box.cfg{read_only = false}``), and its :ref:`connectivity quorum "
"<cfg_replication-replication_connect_quorum>` should be satisfied "
"(``box.cfg{replication_connect_quorum = <count>}``) or disabled "
"(``box.cfg{replication_connect_quorum = 0}``)."
msgstr ""
"Важно также понимать, что статус лидера — не единственное, что требуется "
"узлу, чтобы быть доступным для записи. Параметр :ref:`read_only <cfg_basic-"
"read_only>` на узле-лидере должен иметь значение ``false`` "
"(``box.cfg{read_only = false}``). Необходимо также, чтобы выполнялось "
"условие, заданное параметром :ref:`replication_connect_quorum "
"<cfg_replication-replication_connect_quorum>` "
"(``box.cfg{replication_connect_quorum = <count>}``), или же этот параметр "
"должен быть отключён (``box.cfg{replication_connect_quorum = 0}``)."

msgid ""
"Nothing prevents from setting the ``read_only`` option to ``true``, but the "
"leader just won't be writable then. The option doesn't affect the election "
"process itself, so a read-only instance can still vote and become a leader."
msgstr ""
"Ничто не мешает задать для параметра ``read_only`` значение ``true``, но это"
" сделает лидера недоступным для записи. На сам процесс выборов параметр "
"никак не влияет, поэтому голосовать и быть лидером может даже экземпляр, "
"доступный только для чтения."

msgid "Monitoring"
msgstr "Мониторинг"

msgid ""
"To monitor the current state of a node regarding the leader election, you "
"can use the ``box.info.election`` function. For details, refer to the "
":doc:`function description </reference/reference_lua/box_info/election>`."
msgstr ""
"Чтобы отслеживать текущий статус узла в выборах лидера, можно использовать "
"функцию ``box.info.election``. Подробные сведения читайте в :doc:`описании "
"функции </reference/reference_lua/box_info/election>`."

msgid "**Example:**"
msgstr "**Пример:**"

msgid ""
"tarantool> box.info.election\n"
"---\n"
"- state: follower\n"
"  vote: 0\n"
"  leader: 0\n"
"  term: 1\n"
"..."
msgstr ""
"tarantool> box.info.election\n"
"---\n"
"- state: follower\n"
"  vote: 0\n"
"  leader: 0\n"
"  term: 1\n"
"..."

msgid ""
"The Raft-based election implementation logs all its actions with the "
"``RAFT:`` prefix. The actions are new Raft message handling, node state "
"changing, voting, term bumping, and so on."
msgstr ""
"Журнальные записи о выборах на основе алгоритма Raft отмечаются префиксом "
"``RAFT:``. В журнал вносятся такие события, как обработка новых сообщений "
"Raft, изменение статуса узла, голосование, увеличение значения терма и пр."

msgid "Important notes"
msgstr "Важные замечания"

msgid ""
"Leader election won't work correctly if the election quorum is set to less "
"or equal than ``<cluster size> / 2`` because in that case, a split vote can "
"lead to a state when two leaders are elected at once."
msgstr ""
"Механизм выборов лидера не будет корректно работать, если кворум меньше "
"``<размер кластера> / 2`` или равен этому значению, поскольку в этом случае "
"два лидера могут быть избраны одновременно."

msgid ""
"For example, let's assume there are five nodes. When quorum is set to ``2``,"
" ``node1`` and ``node2`` can both vote for ``node1``. ``node3`` and "
"``node4`` can both vote for ``node5``. In this case, ``node1`` and ``node5``"
" both win the election. When the quorum is set to the cluster majority, that"
" is ``(<cluster size> / 2) + 1`` or bigger, the split vote is not possible."
msgstr ""
"Допустим, есть пять узлов. Если значение кворума — ``2``, то ``node1`` и "
"``node2`` оба могут проголосовать за ``node1``. При этом ``node3`` и "
"``node4`` оба могут проголосовать за ``node5``. Тогда выборы выиграют и "
"``node1``, и ``node5``. Но если в качестве значения кворума установлено "
"большинство, то есть ``(<размер кластера> / 2) + 1`` или больше, то "
"разделение голосов поровну невозможно."

msgid ""
"That should be considered when adding new nodes. If the majority value is "
"changing, it's better to update the quorum on all the existing nodes before "
"adding a new one."
msgstr ""
"Это особенно актуально при добавлении узлов в кластер. Прежде чем вводить "
"новый узел, рекомендуется обновить значение кворума на всех существующих "
"экземплярах."

msgid ""
"Also, the automated leader election won't bring many benefits in terms of "
"data safety when used *without* :ref:`synchronous replication <repl_sync>`. "
"If the replication is asynchronous and a new leader gets elected, the old "
"leader is still active and considers itself the leader. In such case, "
"nothing stops it from accepting requests from clients and making "
"transactions. Non-synchronous transactions will be successfully committed "
"because they won't be checked against the quorum of replicas. Synchronous "
"transactions will fail because they won't be able to collect the quorum -- "
"most of the replicas will reject these old leader's transactions since it is"
" not a leader anymore."
msgstr ""
"Если использовать автоматические выборы лидера *без* :ref:`синхронной "
"репликации <repl_sync>`, может наступить рассогласование данных. При "
"асинхронной репликации успешные выборы нового лидера не означают, что "
"прежний лидер немедленно сложит с себя полномочия. Он по-прежнему будет "
"считать себя активным лидером, принимать запросы от клиентов и совершать "
"транзакции. Асинхронные транзакции, минуя кворум реплик, будут успешно "
"проходить коммиты. При этом синхронные транзакции будут приводить к ошибке, "
"поскольку для их коммита не удастся собрать кворум: большинство реплик будут"
" отвергать транзакции, передаваемые прежним лидером, поскольку уже был "
"избран новый."

msgid ""
"Another point to keep in mind is that when a new leader is elected, it won't"
" automatically finalize synchronous transactions left from the previous "
"leader. This must be done manually using the :ref:`box.ctl.promote <box_ctl-"
"promote>` function. In the future, it is going to be done automatically."
msgstr ""
"Кроме того, синхронные транзакции, оставшиеся от прежнего лидера, не "
"финализируются автоматически при выборах нового. Финализацию следует "
"выполнять вручную с помощью функции :ref:`box.ctl.promote <box_ctl-"
"promote>`. В будущих релизах финализация станет автоматической."
