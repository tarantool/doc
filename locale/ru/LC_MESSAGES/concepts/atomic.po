
msgid "Transactions"
msgstr "Транзакции"

msgid "Transactions allow users to perform multiple operations atomically."
msgstr ""

msgid ""
"For more information on how transactions work in Tarantool, see the "
"following sections:"
msgstr ""

#~ msgid ""
#~ "Transactions in Tarantool occur in **fibers** on a single **thread**. That "
#~ "is why Tarantool has a guarantee of execution atomicity. That requires "
#~ "emphasis."
#~ msgstr ""
#~ "Транзакции в Tarantool выполняются в **файберах** в одном **потоке**. Вот "
#~ "почему Tarantool дает гарантию атомарности выполнения. На это следует "
#~ "обратить внимание."

#~ msgid ""
#~ "Since :tarantool-release:`2.10.0-beta1`, Tarantool supports streams and "
#~ "interactive transactions over them. See :ref:`Streams <box_stream>`."
#~ msgstr ""
#~ "Начиная с версии :tarantool-release:`2.10.0-beta1`, Tarantool поддерживает "
#~ "стримы и интерактивные транзакции. Больше информации можно найти здесь: "
#~ ":ref:`Стримы <box_stream>`."

#~ msgid "Threads, fibers and yields"
#~ msgstr "Потоки, файберы и передача управления"

#~ msgid ""
#~ "How does Tarantool process a basic operation? As an example, let's take this"
#~ " query:"
#~ msgstr ""
#~ "Как Tarantool выполняет основные операции? Для примера возьмем такой запрос:"

#~ msgid ""
#~ "tarantool> box.space.tester:update({3}, {{'=', 2, 'size'}, {'=', 3, 0}})"
#~ msgstr ""
#~ "tarantool> box.space.tester:update({3}, {{'=', 2, 'size'}, {'=', 3, 0}})"

#~ msgid ""
#~ "This is equivalent to the following SQL statement for a table that stores "
#~ "primary keys in ``field[1]``:"
#~ msgstr ""
#~ "Это соответствует следующему SQL-выражению для таблицы, где первичные ключи "
#~ "— поле ``field[1]``:"

#~ msgid "UPDATE tester SET \"field[2]\" = 'size', \"field[3]\" = 0 WHERE \"field[1]\" = 3"
#~ msgstr "UPDATE tester SET \"field[2]\" = 'size', \"field[3]\" = 0 WHERE \"field[1]\" = 3"

#~ msgid ""
#~ "Assuming this query is received by Tarantool via network, it will be "
#~ "processed with three operating system **threads**:"
#~ msgstr ""
#~ "Предположим, что этот запрос Tarantool получил по сети, — тогда три "
#~ "**потока** операционной системы будут обрабатывать этот запрос:"

#~ msgid ""
#~ "The **network thread** on the server side receives the query, parses the "
#~ "statement, checks if it's correct, and then transforms it into a special "
#~ "structure--a message containing an executable statement and its options."
#~ msgstr ""
#~ "**Сетевой поток** на стороне сервера получает запрос, разбирает выражение, "
#~ "проверяет его на правильность и преобразует его в специальную структуру — "
#~ "сообщение, которое содержит готовый для исполнения запрос и его опции."

#~ msgid ""
#~ "The network thread ships this message to the instance's **transaction "
#~ "processor thread** using a lock-free message bus. Lua programs execute "
#~ "directly in the transaction processor thread, and do not require parsing and"
#~ " preparation."
#~ msgstr ""
#~ "Сетевой поток отправляет это сообщение в **поток обработки транзакций** с "
#~ "помощью шины передачи сообщений без блокировок. Lua-программы выполняются "
#~ "непосредственно в потоке обработки транзакций и не требуют разбора и "
#~ "подготовки."

#~ msgid ""
#~ "The instance's transaction processor thread uses the primary-key index on "
#~ "field[1] to find the location of the tuple. It determines that the tuple can"
#~ " be updated (not much can go wrong when you're merely changing an unindexed "
#~ "field value)."
#~ msgstr ""
#~ "Чтобы найти нужный кортеж, поток обработки транзакций использует индекс на "
#~ "поле первичного ключа field[1]. Он проверяет, что этот кортеж можно обновить"
#~ " (вряд ли что-то пойдет не так, если мы всего лишь меняем значение не "
#~ "индексированного поля)."

#~ msgid ""
#~ "The transaction processor thread sends a message to the :ref:`write-ahead "
#~ "logging (WAL) thread <internals-wal>` to commit the transaction. When done, "
#~ "the WAL thread replies with a COMMIT or ROLLBACK result to the transaction "
#~ "processor which gives it back to the network thread, and the network thread "
#~ "returns the result to the client."
#~ msgstr ""
#~ "Поток обработки транзакций отправляет сообщение в :ref:`поток упреждающей "
#~ "записи в журнал (WAL) <internals-wal>` для коммита транзакции. По завершении"
#~ " поток WAL отправляет результат транзакции — COMMIT или ROLLBACK — в поток "
#~ "обработки транзакций, который передает его сетевому потоку, а тот возвращает"
#~ " результат клиенту."

#~ msgid ""
#~ "Notice that there is only one transaction processor thread in Tarantool. "
#~ "Some people are used to the idea that there can be multiple threads "
#~ "operating on the database, with (say) thread #1 reading row #x, while thread"
#~ " #2 writes row #y. With Tarantool, no such thing ever happens. Only the "
#~ "transaction processor thread can access the database, and there is only one "
#~ "transaction processor thread for each Tarantool instance."
#~ msgstr ""
#~ "Обратите внимание, что в Tarantool есть только один поток обработки "
#~ "транзакций. Некоторые уже привыкли к мысли, что в базе данных может быть "
#~ "множество потоков для обработки данных (например, один поток читает данные "
#~ "из строки x, а другой в это время записывает данные в столбец y). В "
#~ "Tarantool такого нет. Только у потока обработки транзакций есть доступ к "
#~ "базе, и на каждый экземпляр Tarantool есть только один такой поток."

#~ msgid ""
#~ "Like any other Tarantool thread, the transaction processor thread can handle"
#~ " many :ref:`fibers <fiber-fibers>`. A fiber is a set of computer "
#~ "instructions that may contain \"**yield**\" signals. The transaction "
#~ "processor thread will execute all computer instructions until a yield, then "
#~ "switch to execute the instructions of a different fiber. Thus (say) the "
#~ "thread reads row #x for the sake of fiber #1, then writes row #y for the "
#~ "sake of fiber #2."
#~ msgstr ""
#~ "Как и любой другой поток Tarantool, поток обработки транзакций может "
#~ "управлять множеством :ref:`файберов <fiber-fibers>`. Файбер — это набор "
#~ "команд, среди которых могут быть и сигналы \"**передачи управления**\". "
#~ "Поток обработки транзакций выполняет все команды, пока не увидит такой "
#~ "сигнал, и тогда он переключается на выполнение команд из другого файбера. "
#~ "Например, таким образом поток обработки транзакций сначала выполняет чтение "
#~ "данных из строки x для файбера №1, а затем выполняет запись в строку y для "
#~ "файбера №2."

#~ msgid ""
#~ "Yields must happen, otherwise the transaction processor thread would stick "
#~ "permanently on the same fiber. There are two types of yields:"
#~ msgstr ""
#~ "Без передачи управления поток обработки транзакции застрянет на одном "
#~ "файбере. Есть два типа передачи управления:"

#~ msgid ""
#~ ":ref:`implicit yields <atomic-implicit-yields>`: every data-change operation"
#~ " or network-access causes an implicit yield, and every statement that goes "
#~ "through the Tarantool client causes an implicit yield."
#~ msgstr ""
#~ ":ref:`неявная передача управления <atomic-implicit-yields>`: любое изменение"
#~ " данных или доступ к сети вызывает неявную передачу управления; любая "
#~ "команда, которая проходит через клиент Tarantool, вызывает неявную передачу "
#~ "управления."

#~ msgid ""
#~ "explicit yields: in a Lua function, you can (and should) add :ref:`\"yield\""
#~ " <fiber-yield>` statements to prevent hogging. This is called **cooperative "
#~ "multitasking**."
#~ msgstr ""
#~ "явная передача управления: в Lua-функции можно (и нужно) добавлять операторы"
#~ " :ref:`\"передачи управления\" <fiber-yield>`, чтобы не дать им захватить "
#~ "процессорное время. Это называется **кооперативной многозадачностью**."

#~ msgid "Cooperative multitasking"
#~ msgstr "Кооперативная многозадачность"

#~ msgid ""
#~ "Cooperative multitasking means: unless a running fiber deliberately yields "
#~ "control, it is not preempted by some other fiber. But a running fiber will "
#~ "deliberately yield when it encounters a “yield point”: a transaction commit,"
#~ " an operating system call, or an explicit :ref:`\"yield\" <fiber-yield>` "
#~ "request. Any system call which can block will be performed asynchronously, "
#~ "and any running fiber which must wait for a system call will be preempted, "
#~ "so that another ready-to-run fiber takes its place and becomes the new "
#~ "running fiber."
#~ msgstr ""
#~ "Кооперативная многозадачность означает, что пока запущенный файбер не "
#~ "передает управление явно, его не вытесняет какой-либо другой файбер. Однако "
#~ "запущенный файбер явно передаст управление, если обнаружит “точку передачи "
#~ "управления”: коммит транзакции, системный вызов или запрос на явную "
#~ ":ref:`\"передачу управления\" <fiber-yield>`. Любой системный вызов, который"
#~ " может блокировать файбер, будет асинхронным. Запущенный файбер, который "
#~ "должен ждать системный вызов, будет вытеснен: другой готовый к работе файбер"
#~ " занимает его место и становится запущенным файбером."

#~ msgid ""
#~ "This model makes all programmatic locks unnecessary: cooperative "
#~ "multitasking ensures that there will be no concurrency around a resource, no"
#~ " race conditions, and no memory consistency issues. The way to achieve this "
#~ "is quite simple: in critical sections, don't use yields, explicit or "
#~ "implicit, and no one can interfere into the code execution."
#~ msgstr ""
#~ "Такая модель позволяет отказаться от программных блокировок, поскольку "
#~ "кооперативная многозадачность обеспечивает отсутствие борьбы за ресурс, "
#~ "гонки потоков и проблем с согласованностью данных. Добиться этого довольно "
#~ "просто: не использовать явную или неявную передачу управления в критических "
#~ "секциях, и никто не сможет вмешаться в выполнение кода."

#~ msgid ""
#~ "When requests are small, for example simple UPDATE or INSERT or DELETE or "
#~ "SELECT, fiber scheduling is fair: it takes only a little time to process the"
#~ " request, schedule a disk write, and yield to a fiber serving the next "
#~ "client."
#~ msgstr ""
#~ "При небольших запросах, таких как простые UPDATE, INSERT, DELETE или SELECT,"
#~ " планирование файберов будет справедливым: мало времени требуется на "
#~ "обработку запроса, планирование записи на диск и передачу управления на "
#~ "файбер, обслуживающий следующего клиента."

#~ msgid ""
#~ "However, a function might perform complex computations or might be written "
#~ "in such a way that yields do not occur for a long time. This can lead to "
#~ "unfair scheduling, when a single client throttles the rest of the system, or"
#~ " to apparent stalls in request processing. Avoiding this situation is the "
#~ "responsibility of the function’s author."
#~ msgstr ""
#~ "Однако функция может выполнять сложные расчеты  или может быть написана так,"
#~ " что управление не передается в течение длительного времени. Это может "
#~ "привести к несправедливому планированию, когда отдельный клиент перекрывает "
#~ "работу остальной системы, или к явным задержкам в обработке запросов. Автору"
#~ " функции следует не допускать таких ситуаций."

#~ msgid ""
#~ "In the absence of transactions, any function that contains yield points may "
#~ "see changes in the database state caused by fibers that preempt. Multi-"
#~ "statement transactions exist to provide **isolation**: each transaction sees"
#~ " a consistent database state and commits all its changes atomically. At "
#~ ":doc:`commit </reference/reference_lua/box_txn_management/commit>` time, a "
#~ "yield happens and all transaction changes are written to the :ref:`write "
#~ "ahead log <internals-wal>` in a single batch. Or, if needed, transaction "
#~ "changes can be rolled back -- :doc:`completely "
#~ "</reference/reference_lua/box_txn_management/rollback>` or to a specific "
#~ ":doc:`savepoint "
#~ "</reference/reference_lua/box_txn_management/rollback_to_savepoint>`."
#~ msgstr ""
#~ "В отсутствие транзакций любая функция, в которой есть точки передачи "
#~ "управления, может видеть изменения в состоянии базы данных, вызванные "
#~ "вытесняющими файберами. Составные транзакции предназначены для **изоляции**:"
#~ " каждая транзакция видит постоянное состояние базы данных и делает атомарные"
#~ " коммиты изменений. Во время :doc:`коммита "
#~ "</reference/reference_lua/box_txn_management/commit>` происходит передача "
#~ "управления, а все транзакционные изменения записываются в :ref:`журнал "
#~ "упреждающей записи <internals-wal>` в отдельный пакет. Или, при "
#~ "необходимости, можно откатить изменения -- :doc:`полностью "
#~ "</reference/reference_lua/box_txn_management/rollback>` или на определенную "
#~ ":doc:`точку сохранения "
#~ "</reference/reference_lua/box_txn_management/rollback_to_savepoint>`."

#~ msgid ""
#~ "In Tarantool, `transaction isolation level "
#~ "<https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels>`_"
#~ " is *serializable* with the clause \"if no failure during writing to WAL\". "
#~ "In case of such a failure that can happen, for example, if the disk space is"
#~ " over, the transaction isolation level becomes *read uncommitted*."
#~ msgstr ""
#~ "В Tarantool `транзакции изолированы "
#~ "<https://ru.wikipedia.org/wiki/%D0%A3%D1%80%D0%BE%D0%B2%D0%B5%D0%BD%D1%8C_%D0%B8%D0%B7%D0%BE%D0%BB%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8_%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D0%B9>`_"
#~ " полностью — на уровне *serializable* (упорядочиваемость) с оговоркой: "
#~ "\"если нет сбоев при записи в WAL\". В случае такого сбоя, например при "
#~ "переполнении дискового пространства, транзакции изолированы на уровне *read "
#~ "uncommitted* (чтение незафиксированных данных)."

#~ msgid ""
#~ "In :ref:`vinyl <engines-chapter>`, to implement isolation Tarantool uses a "
#~ "simple optimistic scheduler: the first transaction to commit wins. If a "
#~ "concurrent active transaction has read a value modified by a committed "
#~ "transaction, it is aborted."
#~ msgstr ""
#~ "В :ref:`vinyl <engines-chapter>` Tarantool для изоляции использует простой "
#~ "планировщик с оптимистичными блокировками: проходит та транзакция, которая "
#~ "совершит коммит первой. Если параллельно другая активная транзакция "
#~ "прочитала значение, измененное первой транзакцией, то она прерывается."

#~ msgid ""
#~ "The cooperative scheduler ensures that, in absence of yields, a multi-"
#~ "statement transaction is not preempted and hence is never aborted. "
#~ "Therefore, understanding yields is essential to writing abort-free code."
#~ msgstr ""
#~ "Кооперативный планировщик обеспечивает, что в отсутствие передачи управления"
#~ " многооператорная транзакция не вытесняется, поэтому никогда не прерывается."
#~ " Таким образом, чтобы писать код без прерываний, надо понимать принципы "
#~ "передачи управления."

#~ msgid ""
#~ "Sometimes while testing the transaction mechanism in Tarantool you can "
#~ "notice that yielding after ``box.begin()`` but before any read/write "
#~ "operation does not cause an abort as it should according to the description."
#~ " This happens because actually ``box.begin()`` does not start a transaction."
#~ " It is a mark telling Tarantool to start a transaction after some database "
#~ "request that follows."
#~ msgstr ""
#~ "При тестировании механизма транзакций в Tarantool иногда можно заметить, что"
#~ " передача управления после ``box.begin()``, но перед любой операцией "
#~ "чтения/записи не приводит к прерыванию, как это должно происходить согласно "
#~ "описанию. Причина в том, что на самом деле ``box.begin()`` не запускает "
#~ "транзакцию: это просто метка, которая показывает Tarantool, что надо "
#~ "запустить транзакцию после некоторого последующего запроса к базе данных."

#~ msgid ""
#~ "In memtx, if an instruction that implies yields, explicit or implicit, is "
#~ "executed during a transaction, the transaction is fully rolled back. In "
#~ "vinyl, we use more complex transactional manager that allows yields."
#~ msgstr ""
#~ "Если в memtx команда предполагает передачу управления (явную или неявную) и "
#~ "выполняется в рамках транзакции, то транзакция откатывается полностью. В "
#~ "vinyl мы используем более сложный менеджер транзакций, который позволяет "
#~ "передавать управление в рамках транзакции."

#~ msgid "You can’t mix storage engines in a transaction today."
#~ msgstr ""
#~ "На сегодняшний день нельзя использовать разные движки базы данных в одной "
#~ "транзакции."

#~ msgid "Implicit yields"
#~ msgstr "Правила неявной передачи управления"

#~ msgid ""
#~ "The only explicit yield requests in Tarantool are :ref:`fiber.sleep() "
#~ "<fiber-sleep>` and :ref:`fiber.yield() <fiber-yield>`, but many other "
#~ "requests \"imply\" yields because Tarantool is designed to avoid blocking."
#~ msgstr ""
#~ "Единственные запросы явной передачи данных в Tarantool отправляют "
#~ ":ref:`fiber.sleep() <fiber-sleep>` и :ref:`fiber.yield() <fiber-yield>`, но "
#~ "многие другие запросы \"неявно\" подразумевают передачу управления, "
#~ "поскольку цель Tarantool -- избежать блокировок."

#~ msgid ""
#~ "Database requests imply yields if and only if there is disk I/O. For memtx, "
#~ "since all data is in memory, there is no disk I/O during a read request. For"
#~ " vinyl, since some data may not be in memory, there may be disk I/O for a "
#~ "read (to fetch data from disk) or for a write (because a stall may occur "
#~ "while waiting for memory to be free). For both memtx and vinyl, since data-"
#~ "change requests must be recorded in the WAL, there is normally a commit. A "
#~ "commit happens automatically after every request in default \"autocommit\" "
#~ "mode, or a commit happens at the end of a transaction in \"transaction\" "
#~ "mode, when a user deliberately commits by calling "
#~ ":doc:`/reference/reference_lua/box_txn_management/commit`. Therefore for "
#~ "both memtx and vinyl, because there can be disk I/O, some database "
#~ "operations may imply yields."
#~ msgstr ""
#~ "Запросы к базе данных подразумевают передачу управления тогда и только "
#~ "тогда, когда происходят дисковые операции ввода-вывода. Так как все данные в"
#~ " memtx находятся в оперативной памяти, во время запроса на чтение дискового "
#~ "ввода-вывода не происходит. В vinyl некоторые данные могут находиться не в "
#~ "оперативной памяти, поэтому возможны дисковые операции при чтении (для "
#~ "получения данных с диска) или при записи (потому что может произойти сбой в "
#~ "ожидании освобождения памяти). Запросы на изменение данных и в memtx, и в "
#~ "vinyl должны записываться в WAL, и обычно происходит коммит. Коммит "
#~ "происходит автоматически после каждого запроса в режиме \"автоматических "
#~ "коммитов\" (autocommit) по умолчанию или в конце транзакции в режиме "
#~ "\"транзакция\" (transaction), когда пользователь вручную производит коммит, "
#~ "вызывая :doc:`/reference/reference_lua/box_txn_management/commit`. Поэтому и"
#~ " для memtx, и для vinyl некоторые операции с БД могут подразумевать передачу"
#~ " управления при наличии дискового ввода-вывода."

#~ msgid ""
#~ "Many functions in modules :ref:`fio <fio-section>`, :ref:`net_box <net_box-"
#~ "module>`, :ref:`console <console-module>` and :ref:`socket <socket-module>` "
#~ "(the \"os\" and \"network\" requests) yield."
#~ msgstr ""
#~ "Многие функции в модулях :ref:`fio <fio-section>`, :ref:`net_box <net_box-"
#~ "module>`, :ref:`console <console-module>` и :ref:`socket <socket-module>` "
#~ "(запросы \"ОС\" и \"сети\") передают управление."

#~ msgid ""
#~ "That is why executing separate commands such as ``select()``, ``insert()``, "
#~ "``update()`` in the console inside a transaction will cause an abort. This "
#~ "is due to implicit yield happening after each chunk of code is executed in "
#~ "the console."
#~ msgstr ""
#~ "Поэтому выполнение отдельных команд, таких как ``select()``, ``insert()``, "
#~ "``update()`` в консоли внутри транзакции, приведет к прерыванию транзакции. "
#~ "Это связано с тем, что после выполнения каждого фрагмента кода в консоли "
#~ "происходит неявная передача управления (yield)."

#~ msgid "**Example #1**"
#~ msgstr "**Пример №1**"

#~ msgid ""
#~ "*Engine = memtx* |br| The sequence ``select() insert()`` has one yield, at "
#~ "the end of insertion, caused by implicit commit; ``select()`` has nothing to"
#~ " write to the WAL and so does not yield."
#~ msgstr ""
#~ "*Когда движок базы данных - memtx* |br| В последовательности ``select() "
#~ "insert()`` управление передается один раз в конце вставки, что вызвано "
#~ "неявным коммитом; ``select()`` ничего не записывает в WAL, поэтому не "
#~ "передает управление."

#~ msgid ""
#~ "*Engine = vinyl* |br| The sequence ``select() insert()`` has one to three "
#~ "yields, since ``select()`` may yield if the data is not in cache, "
#~ "``insert()`` may yield waiting for available memory, and there is an "
#~ "implicit yield at commit."
#~ msgstr ""
#~ "*Когда движок базы данных - vinyl* |br| В последовательности ``select() "
#~ "insert()`` управление передается от одного до трех раз: ``select()`` может "
#~ "передавать управление, если данных нет в кэше; ``insert()`` может передавать"
#~ " управление, пока ожидает доступную память; и при коммите будет неявная "
#~ "передача управления."

#~ msgid ""
#~ "The sequence ``begin() insert() insert() commit()`` yields only at commit if"
#~ " the engine is memtx, and can yield up to 3 times if the engine is vinyl."
#~ msgstr ""
#~ "Последовательность ``begin() insert() insert() commit()`` передает "
#~ "управление только при коммите, если движок = memtx, и может передавать "
#~ "управление до 3 раз, если движок = vinyl."

#~ msgid "**Example #2**"
#~ msgstr "**Пример №2**"

#~ msgid ""
#~ "Assume that in the memtx space ‘tester’ there are tuples in which the third "
#~ "field represents a positive dollar amount. Let's start a transaction, "
#~ "withdraw from tuple#1, deposit in tuple#2, and end the transaction, making "
#~ "its effects permanent."
#~ msgstr ""
#~ "Предположим, что в спейсе ‘tester’ в memtx есть кортежи, в которых третье "
#~ "поле представляет собой положительную сумму в долларах. Начнем транзакцию, "
#~ "снимем со счета из кортежа №1, пополним счет в кортеж №2 и закончим "
#~ "транзакцию, подтвердив изменения."

#~ msgid ""
#~ "tarantool> function txn_example(from, to, amount_of_money)\n"
#~ "         >   box.begin()\n"
#~ "         >   box.space.tester:update(from, {{'-', 3, amount_of_money}})\n"
#~ "         >   box.space.tester:update(to,   {{'+', 3, amount_of_money}})\n"
#~ "         >   box.commit()\n"
#~ "         >   return \"ok\"\n"
#~ "         > end\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> txn_example({999}, {1000}, 1.00)\n"
#~ "---\n"
#~ "- \"ok\"\n"
#~ "..."
#~ msgstr ""
#~ "tarantool> function txn_example(from, to, amount_of_money)\n"
#~ "         >   box.begin()\n"
#~ "         >   box.space.tester:update(from, {{'-', 3, amount_of_money}})\n"
#~ "         >   box.space.tester:update(to,   {{'+', 3, amount_of_money}})\n"
#~ "         >   box.commit()\n"
#~ "         >   return \"ok\"\n"
#~ "         > end\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> txn_example({999}, {1000}, 1.00)\n"
#~ "---\n"
#~ "- \"ok\"\n"
#~ "..."

#~ msgid ""
#~ "If :ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>` = ‘none’, then "
#~ "implicit yielding at commit time does not take place, because there are no "
#~ "writes to the WAL."
#~ msgstr ""
#~ "Если :ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>` = ‘none’, то "
#~ "при коммите управление не передается неявно, потому что не идет запись в "
#~ "WAL-файл."

#~ msgid ""
#~ "If a task is interactive -- sending requests to the server and receiving "
#~ "responses -- then it involves network I/O, and therefore there is an "
#~ "implicit yield, even if the request that is sent to the server is not itself"
#~ " an implicit yield request. Therefore, the following sequence"
#~ msgstr ""
#~ "Если задача интерактивная — отправка запросов к серверу и получение ответов "
#~ "— то она подразумевает сетевой ввод-вывод и неявную передачу управления, "
#~ "даже если запрос, который отправляется на сервер, сам по себе не будет "
#~ "запросом на неявную передачу управления. Поэтому такая последовательность"

#~ msgid ""
#~ "conn.space.test:select{1}\n"
#~ "conn.space.test:select{2}\n"
#~ "conn.space.test:select{3}"
#~ msgstr ""
#~ "conn.space.test:select{1}\n"
#~ "conn.space.test:select{2}\n"
#~ "conn.space.test:select{3}"

#~ msgid ""
#~ "causes yields three times sequentially when sending requests to the network "
#~ "and awaiting the results. On the server side, the same requests are executed"
#~ " in common order possibly mixing with other requests from the network and "
#~ "local fibers. Something similar happens when using clients that operate via "
#~ "telnet, via one of the connectors, or via the :ref:`MySQL and PostgreSQL "
#~ "rocks <dbms_modules>`, or via the interactive mode when :ref:`using "
#~ "Tarantool as a client <admin-using_tarantool_as_a_client>`."
#~ msgstr ""
#~ "вызывает передачу управления три раза при отправке запросов в сеть и "
#~ "ожидании результатов. На стороне сервера те же самые запросы выполняются в "
#~ "общем порядке, возможно, смешиваясь с другими запросами из сети и локальных "
#~ "файберов. Что-то подобное происходит, если использовать клиент, который "
#~ "работает через telnet, с помощью одного из коннекторов или сторонних модулей"
#~ " :ref:`MySQL и PostgreSQL <dbms_modules>` или в интерактивном режиме, когда "
#~ ":ref:`Tarantool используется в качестве клиента <admin-"
#~ "using_tarantool_as_a_client>`."

#~ msgid ""
#~ "After a fiber has yielded and then has regained control, it immediately "
#~ "issues :ref:`testcancel <fiber-testcancel>`."
#~ msgstr ""
#~ "После того, как файбер передал управление, а затем вернул его, он "
#~ "незамедлительно вызывает :ref:`testcancel <fiber-testcancel>`."

#~ msgid "Transactional manager"
#~ msgstr "Менеджер транзакций"

#~ msgid ""
#~ "Since version :doc:`2.6.1 </release/2.6.1>`, Tarantool has another option "
#~ "for transaction behavior that allows yielding inside a memtx transaction. "
#~ "This is controled by the *transactional manager*."
#~ msgstr ""
#~ "В версии :doc:`2.6.1 </release/2.6.1>` в Tarantool появился еще один вариант"
#~ " поведения транзакции, который позволяет передать управление в пределах "
#~ "memtx-транзакции. Этим занимается *менеджер транзакций*."

#~ msgid ""
#~ "The transactional manager is designed for isolation of concurrent "
#~ "transactions and provides *serializable* `transaction isolation level "
#~ "<https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels>`_."
#~ " It consists of two parts:"
#~ msgstr ""
#~ "Менеджер транзакций изолирует параллельные транзакции, обеспечивая их "
#~ "упорядочиваемость (`уровень изоляции транзакций "
#~ "<https://ru.wikipedia.org/wiki/%D0%A3%D1%80%D0%BE%D0%B2%D0%B5%D0%BD%D1%8C_%D0%B8%D0%B7%D0%BE%D0%BB%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8_%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D0%B9>`_"
#~ " — *serializable*). Менеджер транзакций состоит из двух частей:"

#~ msgid "*MVCC engine*"
#~ msgstr "*MVCC-менеджер*"

#~ msgid "*conflict manager*."
#~ msgstr "*менеджер конфликтов*"

#~ msgid ""
#~ "The MVCC engine provides personal read views for transactions if necessary. "
#~ "The conflict manager tracks transactions' changes and determines their "
#~ "correctness in serialization order. Of course, once yielded, a transaction "
#~ "could interfere with other transactions and could be aborted due to "
#~ "conflict."
#~ msgstr ""
#~ "MVCC-менеджер обеспечивает многоверсионность данных для управления "
#~ "параллельными транзакциями — при необходимости создает для транзакции ее "
#~ "видение состояния базы данных (read view). Менеджер конфликтов отслеживает, "
#~ "какие данные изменила транзакция, и определяет правильность изменений в "
#~ "порядке сериализации. Конечно, если после передачи управления одна "
#~ "транзакция конфликтует с другими, ее можно прервать."

#~ msgid ""
#~ "Another important thing to mention is that the transaction manager provides "
#~ "non-classic snapshot isolation level. It means that a transaction can get a "
#~ "consistent snapshot of the database (that is common) but this snapshot is "
#~ "not necessarily bound to the moment of the beginning of the transaction "
#~ "(that is not common). The conflict manager makes decisions on whether and "
#~ "when each transaction gets which snapshot. That allows to avoid some "
#~ "conflicts comparing with classical snapshot isolation approach."
#~ msgstr ""
#~ "Еще стоит отметить, что менеджер транзакций обеспечивает нестандартный "
#~ "уровень изоляции с помощью снимков. Это означает, что транзакция может "
#~ "видеть снимок состояния базы данных (в этом нет ничего необычного), но этот "
#~ "снимок не обязательно привязан к моменту начала транзакции (вот это уже "
#~ "необычно). Менеджер конфликтов принимает решение о том, видит ли транзакция "
#~ "снимок, какой именно и когда. Это позволяет избежать некоторых конфликтов в "
#~ "сравнении с классическим подходом к изоляции с помощью снимков."

#~ msgid ""
#~ "The transactional manager can be switched on and off by the ``box.cfg`` "
#~ "option :ref:`memtx_use_mvcc_engine <cfg_basic-memtx_use_mvcc_engine>`."
#~ msgstr ""
#~ "Менеджер транзакций можно включать и отключать с помощью параметра "
#~ ":ref:`memtx_use_mvcc_engine <cfg_basic-memtx_use_mvcc_engine>` в "
#~ "``box.cfg``."
