
msgid "Lua Style Guide"
msgstr "Руководство по написанию кода на Lua"

msgid "Inspiration:"
msgstr "Для вдохновения:"

msgid "https://github.com/Olivine-Labs/lua-style-guide"
msgstr "https://github.com/Olivine-Labs/lua-style-guide"

msgid "http://dev.minetest.net/Lua_code_style_guidelines"
msgstr "http://dev.minetest.net/Lua_code_style_guidelines"

msgid "http://sputnik.freewisdom.org/en/Coding_Standard"
msgstr "http://sputnik.freewisdom.org/en/Coding_Standard"

msgid ""
"Programming style is an art. There is some arbitrariness to the rules, but "
"there are sound rationales for them. It is useful not only to provide sound "
"advice on style but to understand the underlying rationale and human aspect "
"of why the style recommendations are formed:"
msgstr ""
"Придерживаться стиля в программировании -- это искусство. Даже учитывая "
"некоторую произвольность правил, для них есть надежное обоснование. Полезно "
"не только давать значимые советы по стилю, но также понимать "
"основополагающие причины и человеческий аспект того, почему формируются "
"рекомендации по стилю:"

msgid "http://mindprod.com/jgloss/unmain.html"
msgstr "http://mindprod.com/jgloss/unmain.html"

msgid "http://www.oreilly.com/catalog/perlbp/"
msgstr "http://www.oreilly.com/catalog/perlbp/"

msgid "http://books.google.com/books?id=QnghAQAAIAAJ"
msgstr "http://books.google.com/books?id=QnghAQAAIAAJ"

msgid "Zen of Python is good; understand it and use wisely:"
msgstr ""
"Дзен языка программирования Python подходит и здесь; используйте его с умом:"

msgid "Beautiful is better than ugly."
msgstr "Красивое лучше, чем уродливое."

msgid "Explicit is better than implicit."
msgstr "Явное лучше, чем неявное."

msgid "Simple is better than complex."
msgstr "Простое лучше, чем сложное."

msgid "Complex is better than complicated."
msgstr "Сложное лучше, чем запутанное."

msgid "Flat is better than nested."
msgstr "Плоское лучше, чем вложенное."

msgid "Sparse is better than dense."
msgstr "Разреженное лучше, чем плотное."

msgid "Readability counts."
msgstr "Читаемость имеет значение."

msgid "Special cases aren't special enough to break the rules."
msgstr "Особые случаи не настолько особые, чтобы нарушать правила."

msgid "Although practicality beats purity."
msgstr "При этом практичность важнее безупречности."

msgid "Errors should never pass silently."
msgstr "Ошибки никогда не должны замалчиваться."

msgid "Unless explicitly silenced."
msgstr "Если не замалчиваются явно."

msgid "In the face of ambiguity, refuse the temptation to guess."
msgstr "Встретив двусмысленность, отбрось искушение угадать."

msgid ""
"There should be one -- and preferably only one -- obvious way to do it."
msgstr ""
"Должен существовать один -- и, желательно, только один -- очевидный способ "
"сделать это."

msgid "Although that way may not be obvious at first unless you're Dutch."
msgstr "Хотя он поначалу может быть и не очевиден."

msgid "Now is better than never."
msgstr "Сейчас лучше, чем никогда."

msgid "Although never is often better than *right* now."
msgstr "Хотя никогда зачастую лучше, чем прямо сейчас."

msgid "If the implementation is hard to explain, it's a bad idea."
msgstr "Если реализацию сложно объяснить -- идея плоха."

msgid "If the implementation is easy to explain, it may be a good idea."
msgstr "Если реализацию легко объяснить -- идея, возможно, хороша."

msgid "Namespaces are one honking great idea -- let's do more of those!"
msgstr "Пространства имен -- отличная штука! Сделаем побольше!"

msgid "https://www.python.org/dev/peps/pep-0020/"
msgstr "https://www.python.org/dev/peps/pep-0020/"

msgid "Indentation and Formatting"
msgstr "Отступы и форматирование"

msgid ""
"4 spaces instead tabs. PIL suggests using of two spaces, but programmer "
"looks at code 4 up to 8 hours a day, so it's simpler to distinguish "
"indentation with 4 spaces. Why spaces? Similar representation everywhere."
msgstr ""
"4 пробела, а не табуляция. Библиотека PIL предлагает использовать два "
"пробела, но разработчик читает код от 4 до 8 часов в день, а различать "
"отступы с 4 пробелами легче. Почему именно пробелы? Соблюдение однородности."

msgid "You can use vim modelines:"
msgstr "Можно использовать строки режима (modelines) vim:"

msgid "-- vim:ts=4 ss=4 sw=4 expandtab"
msgstr "-- vim:ts=4 ss=4 sw=4 expandtab"

msgid ""
"A file should ends w/ one newline symbol, but shouldn't ends w/ blank line "
"(two newline symbols)."
msgstr ""
"Файл должен заканчиваться на один символ переноса строки, но не должен "
"заканчиваться на пустой строке (два символа переноса строки)."

msgid "Every do/while/for/if/function should indent 4 spaces."
msgstr "Отступы всех do/while/for/if/function должны составлять 4 пробела."

msgid ""
"related ``or``/``and`` in ``if`` must be enclosed in the round brackets (). "
"Example:"
msgstr ""
"``or``/``and`` в ``if`` должны быть обрамлены круглыми скобками (). Пример:"

msgid ""
"if (a == true and b == false) or (a == false and b == true) then\n"
"    <...>\n"
"end -- good\n"
"\n"
"if a == true and b == false or a == false and b == true then\n"
"    <...>\n"
"end -- bad\n"
"\n"
"if a ^ b == true then\n"
"end -- good, but not explicit"
msgstr ""
"if (a == true and b == false) or (a == false and b == true) then\n"
"    <...>\n"
"end -- хорошо\n"
"\n"
"if a == true and b == false or a == false and b == true then\n"
"    <...>\n"
"end -- плохо\n"
"\n"
"if a ^ b == true then\n"
"end -- хорошо, но не явно"

msgid "Type conversion"
msgstr "Преобразование типов"

msgid ""
"Do not use concatenation to convert to string or addition to convert to "
"number (use ``tostring``/``tonumber`` instead):"
msgstr ""
"Не используйте конкатенацию для конвертации в строку или в число (вместо "
"этого воспользуйтесь ``tostring``/``tonumber``):"

msgid ""
"local a = 123\n"
"a = a .. ''\n"
"-- bad\n"
"\n"
"local a = 123\n"
"a = tostring(a)\n"
"-- good\n"
"\n"
"local a = '123'\n"
"a = a + 5 -- 128\n"
"-- bad\n"
"\n"
"local a = '123'\n"
"a = tonumber(a) + 5 -- 128\n"
"-- good"
msgstr ""
"local a = 123\n"
"a = a .. ''\n"
"-- плохо\n"
"\n"
"local a = 123\n"
"a = tostring(a)\n"
"-- хорошо\n"
"\n"
"local a = '123'\n"
"a = a + 5 -- 128\n"
"-- плохо\n"
"\n"
"local a = '123'\n"
"a = tonumber(a) + 5 -- 128\n"
"-- хорошо"

msgid "Try to avoid multiple nested ``if``'s with common body:"
msgstr ""
"Постарайтесь избегать несколько вложенных ``if`` с общим телом оператора:"

msgid ""
"if (a == true and b == false) or (a == false and b == true) then\n"
"    do_something()\n"
"end\n"
"-- good\n"
"\n"
"if a == true then\n"
"    if b == false then\n"
"        do_something()\n"
"    end\n"
"if b == true then\n"
"    if a == false then\n"
"        do_something()\n"
"    end\n"
"end\n"
"-- bad"
msgstr ""
"if (a == true and b == false) or (a == false and b == true) then\n"
"    do_something()\n"
"end\n"
"-- хорошо\n"
"\n"
"if a == true then\n"
"    if b == false then\n"
"        do_something()\n"
"    end\n"
"if b == true then\n"
"    if a == false then\n"
"        do_something()\n"
"    end\n"
"end\n"
"-- плохо"

msgid ""
"Avoid multiple concatenations in one statement, use ``string.format`` "
"instead:"
msgstr ""
"Избегайте множества конкатенаций в одном операторе, лучше использовать "
"``string.format``:"

msgid ""
"function say_greeting(period, name)\n"
"    local a = \"good  \" .. period .. \", \" .. name\n"
"end\n"
"-- bad\n"
"\n"
"function say_greeting(period, name)\n"
"    local a = string.format(\"good %s, %s\", period, name)\n"
"end\n"
"-- good\n"
"\n"
"local say_greeting_fmt = \"good %s, %s\"\n"
"function say_greeting(period, name)\n"
"    local a = say_greeting_fmt:format(period, name)\n"
"end\n"
"-- best"
msgstr ""
"function say_greeting(period, name)\n"
"     local a = \"good  \" .. period .. \", \" .. name\n"
"end\n"
"-- плохо\n"
"\n"
"function say_greeting(period, name)\n"
"    local a = string.format(\"good %s, %s\", period, name)\n"
"end\n"
"-- хорошо\n"
"\n"
"local say_greeting_fmt = \"good %s, %s\"\n"
"function say_greeting(period, name)\n"
"    local a = say_greeting_fmt:format(period, name)\n"
"end\n"
"-- лучше всего"

msgid "Use ``and``/``or`` for default variable values"
msgstr ""
"Используйте ``and``/``or`` для указания значений переменных, используемых по"
" умолчанию,"

msgid ""
"function(input)\n"
"    input = input or 'default_value'\n"
"end -- good\n"
"\n"
"function(input)\n"
"    if input == nil then\n"
"        input = 'default_value'\n"
"    end\n"
"end -- ok, but excessive"
msgstr ""
"function(input)\n"
"    input = input or 'default_value'\n"
"end -- хорошо\n"
"\n"
"function(input)\n"
"    if input == nil then\n"
"        input = 'default_value'\n"
"    end\n"
"end -- нормально, но избыточно"

msgid "``if``'s and return statements:"
msgstr "операторов ``if`` и возврата:"

msgid ""
"if a == true then\n"
"    return do_something()\n"
"end\n"
"do_other_thing() -- good\n"
"\n"
"if a == true then\n"
"    return do_something()\n"
"else\n"
"    do_other_thing()\n"
"end -- bad"
msgstr ""
"if a == true then\n"
"    return do_something()\n"
"end\n"
"do_other_thing() -- хорошо\n"
"\n"
"if a == true then\n"
"    return do_something()\n"
"else\n"
"    do_other_thing()\n"
"end -- плохо"

msgid "Using spaces:"
msgstr "Использование пробелов:"

msgid ""
"one shouldn't use spaces between function name and opening round bracket, "
"but arguments must be split with one whitespace character"
msgstr ""
"не следует вставлять пробелы между именем функции и открывающей круглой "
"скобкой, но аргумент необходимо разделять одним символом пробела"

msgid ""
"function name (arg1,arg2,...)\n"
"end -- bad\n"
"\n"
"function name(arg1, arg2, ...)\n"
"end -- good"
msgstr ""
"function name (arg1,arg2,...)\n"
"end -- плохо\n"
"\n"
"function name(arg1, arg2, ...)\n"
"end -- хорошо"

msgid "use space after comment marker"
msgstr "добавляйте пробел после маркера комментария"

msgid ""
"while true do -- inline comment\n"
"-- comment\n"
"do_something()\n"
"end\n"
"--[[\n"
"  multiline\n"
"  comment\n"
"]]--"
msgstr ""
"while true do -- встроенный комментарий\n"
"-- комментарий\n"
"do_something()\n"
"end\n"
"--[[\n"
"  многострочный\n"
"  комментарий\n"
"]]--"

msgid "surrounding operators"
msgstr "примыкающие конструкции"

msgid ""
"local thing=1\n"
"thing = thing-1\n"
"thing = thing*1\n"
"thing = 'string'..'s'\n"
"-- bad\n"
"\n"
"local thing = 1\n"
"thing = thing - 1\n"
"thing = thing * 1\n"
"thing = 'string' .. 's'\n"
"-- good"
msgstr ""
"local thing=1\n"
"thing = thing-1\n"
"thing = thing*1\n"
"thing = 'string'..'s'\n"
"-- плохо\n"
"\n"
"local thing = 1\n"
"thing = thing - 1\n"
"thing = thing * 1\n"
"thing = 'string' .. 's'\n"
"-- хорошо"

msgid "use space after commas in tables"
msgstr "добавляйте пробел после запятых в таблицах"

msgid ""
"local thing = {1,2,3}\n"
"thing = {1 , 2 , 3}\n"
"thing = {1 ,2 ,3}\n"
"-- bad\n"
"\n"
"local thing = {1, 2, 3}\n"
"-- good"
msgstr ""
"local thing = {1,2,3}\n"
"thing = {1 , 2 , 3}\n"
"thing = {1 ,2 ,3}\n"
"-- плохо\n"
"\n"
"local thing = {1, 2, 3}\n"
"-- хорошо"

msgid "use space in map definitions around equality sign and commas"
msgstr ""
"используйте пробелы в определениях ассоциативного массива по сторонам от "
"знаков равенства и запятых"

msgid ""
"return {1,2,3,4}\n"
"return {\n"
"    key1 = val1,key2=val2\n"
"}\n"
"-- bad\n"
"\n"
"return {1, 2, 3, 4}\n"
"return {\n"
"    key1 = val1, key2 = val2,\n"
"    key3 = vallll\n"
"}\n"
"-- good"
msgstr ""
"return {1,2,3,4}\n"
"return {\n"
"    key1 = val1,key2=val2\n"
"}\n"
"-- плохо\n"
"\n"
"return {1, 2, 3, 4}\n"
"return {\n"
"    key1 = val1, key2 = val2,\n"
"    key3 = vallll\n"
"}\n"
"-- хорошо"

msgid "also, you may use alignment:"
msgstr "также можно применить выравнивание:"

msgid ""
"return {\n"
"    long_key  = 'vaaaaalue',\n"
"    key       = 'val',\n"
"    something = 'even better'\n"
"}"
msgstr ""
"return {\n"
"    long_key  = 'vaaaaalue',\n"
"    key       = 'val',\n"
"    something = 'even better'\n"
"}"

msgid ""
"extra blank lines may be used (sparingly) to separate groups of related "
"functions. Blank lines may be omitted between a bunch of related one-liners "
"(e.g. a set of dummy implementations)"
msgstr ""
"также можно добавлять пустые строки (не слишком часто) для выделения групп "
"связанных функций. Пустые строки не стоит добавлять между несколькими "
"связанными программами в одну строку (например, в формальной реализации)"

msgid "use blank lines in function, sparingly, to indicate logical sections"
msgstr ""
"не слишком часто можно добавлять пустые строки в коде функций, чтобы "
"отделить друг от друга логические части"

msgid ""
"if thing then\n"
"    -- ...stuff...\n"
"end\n"
"function derp()\n"
"    -- ...stuff...\n"
"end\n"
"local wat = 7\n"
"-- bad\n"
"\n"
"if thing then\n"
"    -- ...stuff...\n"
"end\n"
"\n"
"function derp()\n"
"    -- ...stuff...\n"
"end\n"
"\n"
"local wat = 7\n"
"-- good"
msgstr ""
"if thing then\n"
"    -- ...что-то...\n"
"end\n"
"function derp()\n"
"    -- ...что-то...\n"
"end\n"
"local wat = 7\n"
"-- плохо\n"
"\n"
"if thing then\n"
"    -- ...что-то...\n"
"end\n"
"\n"
"function derp()\n"
"    -- ...что-то...\n"
"end\n"
"\n"
"local wat = 7\n"
"-- хорошо"

msgid ""
"Delete whitespace at EOL (strongly forbidden. Use ``:s/\\s\\+$//gc`` in vim "
"to delete them)"
msgstr ""
"Удаляйте символы пробела в конце файла (они категорически запрещаются). Для "
"их удаления в vim используйте ``:s/\\s\\+$//gc``."

msgid "Avoid global variable"
msgstr "Недопущение глобальных переменных"

msgid ""
"You must avoid global variables. If you have an exceptional case, use ``_G``"
" variable to set it, add prefix or add table instead of prefix:"
msgstr ""
"Следует избегать глобальных переменных. В исключительных случаях используйте"
" переменную ``_G`` для объявления, добавьте префикс или таблицу вместо "
"префикса:"

msgid ""
"function bad_global_example()\n"
"end -- very, very bad\n"
"\n"
"function good_local_example()\n"
"end\n"
"_G.modulename_good_local_example = good_local_example -- good\n"
"_G.modulename = {}\n"
"_G.modulename.good_local_example = good_local_example -- better"
msgstr ""
"function bad_global_example()\n"
"end -- глобальная, очень-очень плохо\n"
"\n"
"function good_local_example()\n"
"end\n"
"_G.modulename_good_local_example = good_local_example -- локальная, хорошо\n"
"_G.modulename = {}\n"
"_G.modulename.good_local_example = good_local_example -- локальная, лучше"

msgid "Always use prefix to avoid name clash"
msgstr "Всегда добавляйте префиксы во избежание конфликта имен"

msgid "Naming"
msgstr "Именование"

msgid "names of variables/\"objects\" and \"methods\"/functions: snake_case"
msgstr "имена переменных/\"объектов\" и \"методов\"/функций: snake_case"

msgid "names of \"classes\": CamelCase"
msgstr "имена \"классов\": CamelCase"

msgid ""
"private variables/methods (properties in the future) of object starts with "
"underscores ``<object>._<name>``. Avoid using of ``local function "
"private_methods(self) end``"
msgstr ""
"частные переменные/методы (в будущем параметры) объекта начинаются с символа"
" подчеркивания ``<object>._<name>``. Избегайте ``local function "
"private_methods(self) end``"

msgid ""
"boolean - naming ``is_<...>``, ``isnt_<...>``, ``has_``, ``hasnt_`` is a "
"good style."
msgstr ""
"логическое именование приветствуется ``is_<...>``, ``isnt_<...>``, ``has_``,"
" ``hasnt_``."

msgid ""
"for \"very local\" variables: - ``t`` is for tables - ``i``, ``j`` are for "
"indexing - ``n`` is for counting - ``k``, ``v`` is what you get out of "
"``pairs()`` (are acceptable, ``_`` if unused) - ``i``, ``v`` is what you get"
" out of ``ipairs()`` (are acceptable, ``_`` if unused) - ``k``/``key`` is "
"for table keys - ``v``/``val``/``value`` is for values that are passed "
"around - ``x``/``y``/``z`` is for generic math quantities - "
"``s``/``str``/``string`` is for strings - ``c`` is for 1-char strings - "
"``f``/``func``/``cb`` are for functions - ``status, <rv>..`` or ``ok, "
"<rv>..`` is what you get out of pcall/xpcall - ``buf, sz`` is a (buffer, "
"size) pair - ``<name>_p`` is for pointers - ``t0``.. is for timestamps - "
"``err`` is for errors"
msgstr ""
"для \"самых локальных\" переменных: - ``t`` для таблиц - ``i``, ``j`` для "
"индексации - ``n`` для подсчета - ``k``, ``v`` для получения из ``pairs()`` "
"(допускаются, ``_`` если не используются) - ``i``, ``v`` is what you get out"
" of ``ipairs()`` (допускаются, ``_`` если не используются) - ``k``/``key`` "
"для ключей таблицы - ``v``/``val``/``value`` для передаваемых значений - "
"``x``/``y``/``z`` для общих математических величин - "
"``s``/``str``/``string`` для строк - ``c`` для односимвольных строк - "
"``f``/``func``/``cb`` для функций - ``status, <rv>..`` или ``ok, <rv>..`` "
"для получения из pcall/xpcall - ``buf, sz`` -- это пара (буфер, размер) - "
"``<name>_p`` для указателей - ``t0``.. для временных отметок - ``err`` для "
"ошибок"

msgid ""
"abbreviations are acceptable if they're unambiguous and if you'll document "
"(or they're too common) them."
msgstr ""
"допускается использование сокращений, если они недвусмысленны, и если вы "
"документируете их (или они слишком распространены)."

msgid ""
"global variables are written with ALL_CAPS. If it's some system variable, "
"then they're using underscore to define it (``_G``/``_VERSION``/..)"
msgstr ""
"глобальные переменные пишутся ЗАГЛАВНЫМИ_БУКВАМИ. Если это системная "
"переменная, для определения используется символ подчеркивания "
"(``_G``/``_VERSION``/..)"

msgid ""
"module naming snake_case (avoid underscores and dashes) - 'luasql', instead "
"of 'Lua-SQL'"
msgstr ""
"именование модулей -- с помощью snake_case (избегайте подчеркивания и "
"дефисов) - 'luasql', а не 'Lua-SQL'"

msgid "``*_mt`` and ``*_methods`` defines metatable and methods table"
msgstr "``*_mt`` и ``*_methods`` определяют метатаблицу и таблицу методов"

msgid "Idioms and patterns"
msgstr "Идиомы и шаблоны"

msgid ""
"Always use round brackets in call of functions except multiple cases (common"
" lua style idioms):"
msgstr ""
"Всегда пользуйтесь круглыми скобками при вызове функций, за исключением "
"множественных случаев (распространенные идиомы в Lua):"

msgid "``*.cfg{ }`` functions (``box.cfg``/``memcached.cfg``/..)"
msgstr "функции ``*.cfg{ }`` (``box.cfg``/``memcached.cfg``/..)"

msgid "``ffi.cdef[[ ]]`` function"
msgstr "функция ``ffi.cdef[[ ]]``"

msgid "Avoid these kind of constructions:"
msgstr "Избегайте конструкций такого типа:"

msgid "<func>'<name>' (strongly avoid require'..')"
msgstr "<func>'<name>' (особенно избегайте require'..')"

msgid ""
"``function object:method() end`` (use ``function object.method(self) end`` "
"instead)"
msgstr ""
"``function object:method() end`` (используйте ``function object.method(self)"
" end``)"

msgid "do not use semicolon as table separator (only comma)"
msgstr ""
"не вставляйте точку с запятой в качестве символа-разделителя в таблице "
"(только запятые)"

msgid ""
"semicolons at the end of line (only to split multiple statements on one "
"line)"
msgstr ""
"точки с запятой в конце строки (только для разделения нескольких операторов "
"в одной строке)"

msgid "try to avoid unnecessary function creation (closures/..)"
msgstr "старайтесь избегать создания ненужных функций (closures/..)"

msgid "Modules"
msgstr "Модули"

msgid ""
"Don't start modules with license/authors/descriptions, you can write it in "
"LICENSE/AUTHORS/README files. For writing modules use one of the two "
"patterns (don't use ``modules()``):"
msgstr ""
"Не начинайте создание модуля с указания лицензии/авторов/описания, это можно"
" сделать в файлах LICENSE/AUTHORS/README соответственно. Для написания "
"модулей используйте один из двух шаблонов (не используйте ``modules()``):"

msgid ""
"local M = {}\n"
"\n"
"function M.foo()\n"
"...\n"
"end\n"
"\n"
"function M.bar()\n"
"...\n"
"end\n"
"\n"
"return M"
msgstr ""
"local M = {}\n"
"\n"
"function M.foo()\n"
"...\n"
"end\n"
"\n"
"function M.bar()\n"
"...\n"
"end\n"
"\n"
"return M"

msgid "or"
msgstr "или"

msgid ""
"local function foo()\n"
"...\n"
"end\n"
"\n"
"local function bar()\n"
"...\n"
"end\n"
"\n"
"return {\n"
"foo = foo,\n"
"bar = bar,\n"
"}"
msgstr ""
"local function foo()\n"
"...\n"
"end\n"
"\n"
"local function bar()\n"
"...\n"
"end\n"
"\n"
"return {\n"
"foo = foo,\n"
"bar = bar,\n"
"}"

msgid "Commenting"
msgstr "Комментирование"

msgid ""
"You should write code the way it shouldn't be described, but don't forget "
"about commenting it. You shouldn't comment Lua syntax (assume that reader "
"already knows Lua language). Try to tell about functions/variable names/etc."
msgstr ""
"Пишите код так, чтобы его не нужно было описывать, но не забывайте о "
"комментировании. Не следует комментировать Lua-синтаксис (примите, что "
"читатель знаком с языком Lua). Постарайтесь рассказать о функциях, именах "
"переменных и так далее."

msgid ""
"Multiline comments: use matching (``--[[ ]]--``) instead of simple (``--[[ "
"]]``)."
msgstr ""
"Многострочные комментарии: используйте соответствующие скобки (``--[[ "
"]]--``) вместо простых (``--[[ ]]``)."

msgid "Public function comments (??):"
msgstr "Комментарии к доступным функциям (??):"

msgid ""
"--- Copy any table (shallow and deep version)\n"
"-- * deepcopy: copies all levels\n"
"-- * shallowcopy: copies only first level\n"
"-- Supports __copy metamethod for copying custom tables with metatables\n"
"-- @function gsplit\n"
"-- @table         inp  original table\n"
"-- @shallow[opt]  sep  flag for shallow copy\n"
"-- @returns            table (copy)"
msgstr ""
"--- Копирование любой таблицы (поверхностное и глубокое)\n"
"-- * deepcopy: копирует все уровни\n"
"-- * shallowcopy: копирует только первый уровень\n"
"-- Поддержка метаметода __copy для копирования специальных таблиц с метатаблицами\n"
"-- @function gsplit\n"
"-- @table         inp  оригинальная таблица\n"
"-- @shallow[opt]  sep  флаг для поверхностной копии\n"
"-- @returns            таблица (копия)"

msgid "Testing"
msgstr "Тестирование"

msgid "Use ``tap`` module for writing efficient tests. Example of test file:"
msgstr ""
"Используйте модуль ``tap``, чтобы написать эффективные тесты. Пример файла с"
" тестом:"

msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local test = require('tap').test('table')\n"
"test:plan(31)\n"
"\n"
"do -- check basic table.copy (deepcopy)\n"
"    local example_table = {\n"
"        {1, 2, 3},\n"
"        {\"help, I'm very nested\", {{{ }}} }\n"
"    }\n"
"\n"
"    local copy_table = table.copy(example_table)\n"
"\n"
"    test:is_deeply(\n"
"        example_table,\n"
"        copy_table,\n"
"        \"checking, that deepcopy behaves ok\"\n"
"    )\n"
"    test:isnt(\n"
"        example_table,\n"
"        copy_table,\n"
"        \"checking, that tables are different\"\n"
"    )\n"
"    test:isnt(\n"
"        example_table[1],\n"
"        copy_table[1],\n"
"        \"checking, that tables are different\"\n"
"    )\n"
"    test:isnt(\n"
"        example_table[2],\n"
"        copy_table[2],\n"
"        \"checking, that tables are different\"\n"
"    )\n"
"    test:isnt(\n"
"        example_table[2][2],\n"
"        copy_table[2][2],\n"
"        \"checking, that tables are different\"\n"
"    )\n"
"    test:isnt(\n"
"        example_table[2][2][1],\n"
"        copy_table[2][2][1],\n"
"        \"checking, that tables are different\"\n"
"    )\n"
"end\n"
"\n"
"<...>\n"
"\n"
"os.exit(test:check() and 0 or 1)"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local test = require('tap').test('table')\n"
"test:plan(31)\n"
"\n"
"do -- check basic table.copy (deepcopy)\n"
"    local example_table = {\n"
"        {1, 2, 3},\n"
"        {\"help, I'm very nested\", {{{ }}} }\n"
"    }\n"
"\n"
"    local copy_table = table.copy(example_table)\n"
"\n"
"    test:is_deeply(\n"
"        example_table,\n"
"        copy_table,\n"
"        \"checking, that deepcopy behaves ok\"\n"
"    )\n"
"    test:isnt(\n"
"        example_table,\n"
"        copy_table,\n"
"        \"checking, that tables are different\"\n"
"    )\n"
"    test:isnt(\n"
"        example_table[1],\n"
"        copy_table[1],\n"
"        \"checking, that tables are different\"\n"
"    )\n"
"    test:isnt(\n"
"        example_table[2],\n"
"        copy_table[2],\n"
"        \"checking, that tables are different\"\n"
"    )\n"
"    test:isnt(\n"
"        example_table[2][2],\n"
"        copy_table[2][2],\n"
"        \"checking, that tables are different\"\n"
"    )\n"
"    test:isnt(\n"
"        example_table[2][2][1],\n"
"        copy_table[2][2][1],\n"
"        \"checking, that tables are different\"\n"
"    )\n"
"end\n"
"\n"
"<...>\n"
"\n"
"os.exit(test:check() and 0 or 1)"

msgid "When you'll test your code output will be something like this:"
msgstr "После тестирования кода вывод будет примерно таким:"

msgid ""
"TAP version 13\n"
"1..31\n"
"ok - checking, that deepcopy behaves ok\n"
"ok - checking, that tables are different\n"
"ok - checking, that tables are different\n"
"ok - checking, that tables are different\n"
"ok - checking, that tables are different\n"
"ok - checking, that tables are different\n"
"..."
msgstr ""
"TAP version 13\n"
"1..31\n"
"ok - checking, that deepcopy behaves ok\n"
"ok - checking, that tables are different\n"
"ok - checking, that tables are different\n"
"ok - checking, that tables are different\n"
"ok - checking, that tables are different\n"
"ok - checking, that tables are different\n"
"..."

msgid "Error Handling"
msgstr "Обработка ошибок"

msgid "Be generous in what you accept and strict in what you return."
msgstr "Принимайте разнообразные значения и выдавайте строго определенные."

msgid ""
"With error handling this means that you must provide an error object as "
"second multi-return value in case of error. The error object can be a "
"string, a Lua table or cdata, in the latter cases it must have "
"``__tostring`` metamethod defined."
msgstr ""
"В рамках обработки ошибок это означает, что в случае ошибки вы должны "
"предоставить объект ошибки как второе возвращаемое значение. Объектом ошибки"
" может быть строка, Lua-таблица или cdata, в последнем случае должен быть "
"определен метаметод ``__tostring``."

msgid ""
"In case of error, use ``nil`` for the first return value. This makes the "
"error hard to ignore."
msgstr ""
"В случае ошибки нулевое значение ``nil`` должно быть первым возвращаемым "
"значением. В таком случае ошибку трудно игнорировать."

msgid ""
"When checking function return values, check the first argument first. If "
"it's ``nil``, look for error in the second argument:"
msgstr ""
"При проверке возвращаемых значений функции проверяйте сначала первый "
"аргумент. Если это ``nil``, ищите ошибку во втором аргументе:"

msgid ""
"local data, err = foo()\n"
"if not data then\n"
"    return nil, err\n"
"end\n"
"return bar(data)"
msgstr ""
"local data, err = foo()\n"
"if not data then\n"
"    return nil, err\n"
"end\n"
"return bar(data)"

msgid ""
"Unless performance of your code is paramount, try to avoid using more than "
"two return values."
msgstr ""
"Если производительность вашего кода не имеет первоочередное значение, "
"постарайтесь избегать использования более двух возвращаемых значений."

msgid ""
"In rare cases you may want to return ``nil`` as a legal return value. In "
"this case it's OK to check for error first, and return second:"
msgstr ""
"В редких случаях ``nil`` можно сделать возвращаемым значением. В таком "
"случае можно сначала проверить ошибку, а потом вернуть значение:"

msgid ""
"local data, err = foo()\n"
"if not err then\n"
"    return data\n"
"end\n"
"return nil, err"
msgstr ""
"local data, err = foo()\n"
"if not err then\n"
"    return data\n"
"end\n"
"return nil, err"

msgid "Luacheck"
msgstr "Luacheck"

msgid ""
"To check the code style, Tarantool uses ``luacheck``. It analyses different "
"aspects of code, such as unused variables, and sometimes it checks more "
"aspects than needed. So there is an agreement to ignore some warnings "
"generated by ``luacheck``:"
msgstr ""
"Для проверки стиля кода Tarantool использует ``luacheck``. Он анализирует "
"различные аспекты кода, например неиспользуемые переменные, и иногда "
"проверяет больше аспектов, чем нужно. Поэтому есть соглашение игнорировать "
"некоторые предупреждения, которые выдает ``luacheck``:"

msgid ""
"\"212/self\",   -- Unused argument <self>.\n"
"\"411\",        -- Redefining a local variable.\n"
"\"421\",        -- Shadowing a local variable.\n"
"\"431\",        -- Shadowing an upvalue.\n"
"\"432\",        -- Shadowing an upvalue argument."
msgstr ""
"\"212/self\",   -- Неиспользуемый аргумент <self>.\n"
"\"411\",        -- Переопределение локальной переменной.\n"
"\"421\",        -- Переопределение локальной переменной на вложенном уровне.\n"
"\"431\",        -- Переопределение значения, заданного ранее, в функции.\n"
"\"432\",        -- Перегрузка аргумента на вложенном уровне."
