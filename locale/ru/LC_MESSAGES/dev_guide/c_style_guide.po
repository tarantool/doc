
msgid "C Style Guide"
msgstr "Руководство по написанию кода на C"

msgid ""
"The project's coding style is based on a version of the Linux kernel "
"coding style."
msgstr ""
"Стиль программирования проекта основан на версии стиля программирования "
"ядра Linux."

msgid ""
"The latest version of the Linux style can be found at: "
"http://www.kernel.org/doc/Documentation/CodingStyle"
msgstr ""
"Последнюю версию стиля программирования Linux можно найти по ссылке: "
"http://www.kernel.org/doc/Documentation/CodingStyle"

msgid ""
"Since it is open for changes, the version of style that we follow, one "
"from 2007-July-13, will be also copied later in this document."
msgstr ""
"Мы придерживаемся версии от 13 июля 2007 года, которая приводится ниже в "
"документе."

msgid ""
"There are a few additional guidelines, either unique to Tarantool or "
"deviating from the Kernel guidelines."
msgstr ""
"Здесь мы приводим дополнительные рекомендации, которые либо специфичны "
"для Tarantool'а, либо отличаются от рекомендаций по программированию ядра"
" Linux."

msgid ""
"Chapters 10 \"Kconfig configuration files\", 11 \"Data structures\", 13 "
"\"Printing kernel messages\", 14 \"Allocating memory\" and 17 \"Don't re-"
"invent the kernel macros\" do not apply, since they are specific to Linux"
" kernel programming environment."
msgstr ""
"Следующие главы не применимы, поскольку они специфичны для среды "
"программирования ядра Linux: 10 \"Конфигурационные файлы Kconfig\", 11 "
"\"Структуры данных\", 13 \"Вывод сообщений ядра\", 14 \"Выделение "
"памяти\" и 17 \"Не изобретайте макросы снова\"."

msgid "The rest of Linux Kernel Coding Style is amended as follows:"
msgstr ""
"Остальные главы документа \"Стиль программирования ядра Linux\" "
"изменяются следующим образом:"

msgid "General guidelines"
msgstr "Общие рекомендации"

msgid ""
"We use Git for revision control. The latest development is happening in "
"the default branch (currently ``master``). Our git repository is hosted "
"on github, and can be checked out with ``git clone "
"git://github.com/tarantool/tarantool.git`` (anonymous read-only access)."
msgstr ""

msgid ""
"If you have any questions about Tarantool internals, please post them on "
"the developer discussion list, "
"https://groups.google.com/forum/#!forum/tarantool. However, please be "
"warned: Launchpad silently deletes posts from non-subscribed members, "
"thus please be sure to have subscribed to the list prior to posting. "
"Additionally, some engineers are always present on #tarantool channel on "
"irc.freenode.net."
msgstr ""
"Если у вас есть вопросы о внутреннем устройстве Tarantool'а, разместите "
"их в списке вопросов к обсуждению для разработчиков: "
"https://groups.google.com/forum/#!forum/tarantool. Однако, предупреждаем:"
" Launchpad молча удаляет сообщения от тех, кто не является подписчиком, "
"поэтому обязательно подпишитесь на список перед публикацией. Кроме того, "
"несколько инженеров всегда находятся на канале #tarantool в "
"irc.freenode.net."

msgid "Commenting style"
msgstr "Стиль комментирования кода"

msgid ""
"Use Doxygen comment format, Javadoc flavor, i.e. `@tag` rather than "
"`\\\\tag`. The main tags in use are @param, @retval, @return, @see, @note"
" and @todo."
msgstr ""
"Используйте формат комментирования Doxygen, разновидность Javadoc, то "
"есть `@tag` вместо `\\\\tag`. Основные используемые теги: @param, "
"@retval, @return, @see, @note и @todo."

msgid ""
"Every function, except perhaps a very short and obvious one, should have "
"a comment. A sample function comment may look like below:"
msgstr ""
"Каждая функция, за исключением, пожалуй, очень короткой и очевидной, "
"должна быть прокомментирована. Пример комментария функции может выглядеть"
" следующим образом:"

msgid ""
"/** Write all data to a descriptor.\n"
" *\n"
" * This function is equivalent to 'write', except it would ensure\n"
" * that all data is written to the file unless a non-ignorable\n"
" * error occurs.\n"
" *\n"
" * @retval 0  Success\n"
" *\n"
" * @retval  1  An error occurred (not EINTR)\n"
" * /\n"
"static int\n"
"write_all(int fd, void \\*data, size_t len);"
msgstr ""
"/** Запись всех данных в дескриптор.\n"
" *\n"
" * Эта функция аналогична 'write' во всём кроме того, что она "
"обеспечивает\n"
" * запись всех данных в файл, если не возникает ошибка,\n"
" * которую нельзя игнорировать.\n"
" *\n"
" * @retval 0  Выполнено\n"
" *\n"
" * @retval  1  Ошибка (не EINTR)\n"
" * /\n"
"static int\n"
"write_all(int fd, void \\*data, size_t len);"

msgid ""
"Public structures and important structure members should be commented as "
"well."
msgstr ""
"Доступные структуры и важные элементы структуры также должны быть "
"прокомментированы."

msgid "Header files"
msgstr "Файлы заголовка"

msgid ""
"Use header guards. Put the header guard in the first line in the header, "
"before the copyright or declarations. Use all-uppercase name for the "
"header guard. Derive the header guard name from the file name, and append"
" _INCLUDED to get a macro name. For example, core/log_io.h -> "
"CORE_LOG_IO_H_INCLUDED. In ``.c`` (implementation) file, include the "
"respective declaration header before all other headers, to ensure that "
"the header is self- sufficient. Header \"header.h\" is self-sufficient if"
" the following compiles without errors:"
msgstr ""
"Используйте защиту заголовка. Поместите защиту заголовка в первую строку "
"заголовка до авторского права или объявления. Для защиты заголовка "
"используйте имя в верхнем регистре. Выводите имя защиты заголовка из "
"имени файла и добавьте _INCLUDED, чтобы получить имя макроса. Например, "
"core/log_io.h -> CORE_LOG_IO_H_INCLUDE. В файле ``.c`` (реализация) "
"следует включить соответствующий заголовок с объявлением перед всеми "
"другими заголовками, чтобы убедиться, что заголовок является автономным. "
"Заголовок \"header.h\" является автономным, если компилируется без "
"ошибок:"

msgid "#include \"header.h\""
msgstr "#include \"header.h\""

msgid "Allocating memory"
msgstr "Выделение памяти"

msgid ""
"Prefer the supplied slab (salloc) and pool (palloc) allocators to "
"malloc()/free() for any performance-intensive or large  memory "
"allocations. Repetitive use of malloc()/free() can lead to memory "
"fragmentation and should therefore be avoided."
msgstr ""
"Предпочтительно использовать предоставляемые распределители slab'ов "
"(salloc) и пулов (palloc) вместо malloc()/free() для любых операций "
"выделения памяти большого объема. Многократное использование "
"malloc()/free() может привести к фрагментации памяти, чего следует "
"избегать."

msgid ""
"Always free all allocated memory, even allocated  at start-up. We aim at "
"being valgrind leak-check clean, and in most cases it's just as easy to "
"free() the allocated memory as it is to write a valgrind suppression. "
"Freeing all allocated memory is also dynamic-load friendly: assuming a "
"plug-in can be dynamically loaded and unloaded multiple times, reload "
"should not lead to a memory leak."
msgstr ""
"Всегда освобождайте всю выделенную память, даже выделенную при запуске. "
"Мы стремимся к тому, чтобы valgrind не находил утечек памяти, и в "
"большинстве случаев так же легко освободить выделенную память по free(), "
"как и записать подавление valgrind. Освобождение всей выделенной памяти "
"также помогает динамическому балансированию нагрузки: предполагается, что"
" подключаемый модуль может динамически загружаться и выгружаться "
"несколько раз, перезагрузка не должна приводить к утечке памяти."

msgid "Function naming"
msgstr ""

msgid "Our convention is to use:"
msgstr ""

msgid ""
"``new``/``delete`` for functions which allocate + initialize and destroy "
"+ deallocate an object,"
msgstr ""

msgid ""
"``create``/``destroy`` for functions which initialize/destroy an object "
"but do not handle memory management,"
msgstr ""

msgid ""
"``init``/``free`` for functions which initialize/destroy libraries and "
"subsystems."
msgstr ""

msgid "Other"
msgstr "Прочее"

msgid ""
"Select GNU C99 extensions are acceptable. It's OK to mix declarations and"
" statements, use true and false."
msgstr ""
"Допускаются расширения GNU C99. Можно смешивать операторы и объявления в "
"выражениях."

msgid ""
"The not-so-current list of all GCC C extensions can be found at: "
"http://gcc.gnu.org/onlinedocs/gcc-4.3.5/gcc/C-Extensions.html"
msgstr ""
"Не слишком актуальный список всех расширений семейства языка C можно "
"найти по ссылке: "
"http://gcc.gnu.org/onlinedocs/gcc-4.3.5/gcc/C-Extensions.html"

msgid "Linux kernel coding style"
msgstr "Стиль программирования ядра Linux"

msgid ""
"This is a short document describing the preferred coding style for the "
"linux kernel.  Coding style is very personal, and I won't _force_ my "
"views on anybody, but this is what goes for anything that I have to be "
"able to maintain, and I'd prefer it for most other things too.  Please at"
" least consider the points made here."
msgstr ""
"В данном коротком документе описывается предпочтительный стиль "
"программирования для ядра Linux. Стиль программирования -- это личное "
"дело каждого, и я не буду никому _навязывать_ свои убеждения, но "
"поскольку это касается всего, что я должен поддерживать, я бы предпочел, "
"чтобы эти правила использовали повсеместно. Пожалуйста, хотя бы "
"рассмотрите описываемые здесь пункты."

msgid ""
"First off, I'd suggest printing out a copy of the GNU coding standards, "
"and NOT read it.  Burn them, it's a great symbolic gesture."
msgstr ""
"Для начала я предлагаю вам распечатать копию стандартов написания кода "
"GNU и НЕ читать их. Сожгите их в качестве весьма символического жеста."

msgid "Anyway, here goes:"
msgstr "В любом случае, поехали:"

msgid "Chapter 1: Indentation"
msgstr "Глава 1: Отступы"

msgid ""
"Tabs are 8 characters, and thus indentations are also 8 characters. There"
" are heretic movements that try to make indentations 4 (or even 2!) "
"characters deep, and that is akin to trying to define the value of PI to "
"be 3."
msgstr ""
"Табуляция составляет 8 символов, то есть отступы будут также в 8 "
"символов. Появляются отступнические движения, которые призывают делать "
"отступы в 4 (или даже 2!) символа, а это сродни попытке округлить число "
"Пи до 3."

msgid ""
"Rationale: The whole idea behind indentation is to clearly define where a"
" block of control starts and ends.  Especially when you've been looking "
"at your screen for 20 straight hours, you'll find it a lot easier to see "
"how the indentation works if you have large indentations."
msgstr ""
"Обоснование: Основная идея отступов состоит в том, чтобы показать, где "
"начинается и заканчивается логический блок кода. Особенно если вы "
"смотрите на один и тот же код в течение 20 часов, трудно не заметить "
"пользу больших отступов."

msgid ""
"Now, some people will claim that having 8-character indentations makes "
"the code move too far to the right, and makes it hard to read on a "
"80-character terminal screen.  The answer to that is that if you need "
"more than 3 levels of indentation, you're screwed anyway, and should fix "
"your program."
msgstr ""
"Некоторые могут возразить, что отступ в 8 символов делает код слишком "
"широким, особенно на 80-знаковой строке терминала. Ответ: Если вам "
"понадобилось более трех уровней отступа, вы что-то делаете неправильно, и"
" вам следует переписать этот участок."

msgid ""
"In short, 8-char indents make things easier to read, and have the added "
"benefit of warning you when you're nesting your functions too deep. Heed "
"that warning."
msgstr ""
"Короче говоря, отступы в 8 символов облегчают чтение кода, да еще и "
"предупреждают, когда вы слишком глубоко встраиваете свои функции. "
"Прислушайтесь к этому."

msgid ""
"The preferred way to ease multiple indentation levels in a switch "
"statement is to align the \"switch\" and its subordinate \"case\" labels "
"in the same column instead of \"double-indenting\" the \"case\" labels. "
"e.g.:"
msgstr ""
"Лучше всего упростить несколько уровней отступов в операторе switch, "
"выравнивая \"switch\" и его вспомогательные метки \"case\" в одном "
"столбце вместо использования двойных отступов для меток \"case\", "
"например:"

msgid ""
"switch (suffix) {\n"
"case 'G':\n"
"case 'g':\n"
"    mem <<= 30;\n"
"    break;\n"
"case 'M':\n"
"case 'm':\n"
"    mem <<= 20;\n"
"    break;\n"
"case 'K':\n"
"case 'k':\n"
"    mem <<= 10;\n"
"    /* fall through */\n"
"default:\n"
"    break;\n"
"}"
msgstr ""
"switch (suffix) {\n"
"case 'G':\n"
"case 'g':\n"
"    mem <<= 30;\n"
"    break;\n"
"case 'M':\n"
"case 'm':\n"
"    mem <<= 20;\n"
"    break;\n"
"case 'K':\n"
"case 'k':\n"
"    mem <<= 10;\n"
"    /* fall through */\n"
"default:\n"
"    break;\n"
"}"

msgid ""
"Don't put multiple statements on a single line unless you have something "
"to hide:"
msgstr ""
"Не размещайте несколько операторов на одной строке, если вам нечего "
"скрывать:"

msgid ""
"if (condition) do_this;\n"
"  do_something_everytime;"
msgstr ""
"if (condition) do_this;\n"
"  do_something_everytime;"

msgid ""
"Don't put multiple assignments on a single line either. Kernel coding "
"style is super simple. Avoid tricky expressions."
msgstr ""
"И не размещайте несколько операторов присваивания на одной строке. Стиль "
"программирования ядра чрезвычайно прост. Избегайте сложных выражений."

msgid ""
"Outside of comments, documentation and except in Kconfig, spaces are "
"never used for indentation, and the above example is deliberately broken."
msgstr ""
"За пределами комментариев, документации и Kconfig, пробелы никогда не "
"используются для отступов, и приведенный выше пример намеренно нарушен."

msgid "Get a decent editor and don't leave whitespace at the end of lines."
msgstr "Найдите достойный редактор и не оставляйте пробелы в конце строки."

msgid "Chapter 2: Breaking long lines and strings"
msgstr "Глава 2: Разрыв длинных строк"

msgid ""
"Coding style is all about readability and maintainability using commonly "
"available tools."
msgstr ""
"Смысл стиля программирования заключается в читаемости и удобстве "
"сопровождения с использованием общедоступных средств."

msgid ""
"The limit on the length of lines is 80 columns, and this is a strongly "
"preferred limit. As for comments, the same limit of 80 columns is "
"applied."
msgstr ""
"Длина строк ограничена 80 символами, и этому следует уделить особое "
"внимание. Для комментариев установлен тот же лимит в 80 символов."

msgid ""
"Statements longer than 80 columns will be broken into sensible chunks. "
"Descendants are always substantially shorter than the parent and are "
"placed substantially to the right. The same applies to function headers "
"with a long argument list. Long strings are as well broken into shorter "
"strings. The only exception to this is where exceeding 80 columns "
"significantly increases readability and does not hide information."
msgstr ""
"Операторы длиной более 80 символов будут разбиты на логические части. "
"Последующие части значительно короче основной и смещены вправо. То же "
"относится к заголовкам функций с длинным списком аргументов. Длинные "
"строки также разбиваются на более короткие строки. Единственным "
"исключением может быть случай, если превышение ограничений повысит "
"читаемость и не скроет необходимую информацию."

#, python-format
msgid ""
"void fun(int a, int b, int c)\n"
"{\n"
"    if (condition)\n"
"        printk(KERN_WARNING \"Warning this is a long printk with \"\n"
"                        \"3 parameters a: %u b: %u \"\n"
"                        \"c: %u \\n\", a, b, c);\n"
"    else\n"
"        next_statement;\n"
"}"
msgstr ""
"void fun(int a, int b, int c)\n"
"{\n"
"    if (condition)\n"
"        printk(KERN_WARNING \"Warning this is a long printk with \"\n"
"                        \"3 parameters a: %u b: %u \"\n"
"                        \"c: %u \\n\", a, b, c);\n"
"    else\n"
"        next_statement;\n"
"}"

msgid "Chapter 3: Placing Braces and Spaces"
msgstr "Глава 3: Фигурные скобки и пробелы"

msgid ""
"The other issue that always comes up in C styling is the placement of "
"braces.  Unlike the indent size, there are few technical reasons to "
"choose one placement strategy over the other, but the preferred way, as "
"shown to us by the prophets Kernighan and Ritchie, is to put the opening "
"brace last on the line, and put the closing brace first, thus:"
msgstr ""

msgid ""
"if (x is true) {\n"
"    we do y\n"
"}"
msgstr ""
"if (x is true) {\n"
"    we do y\n"
"}"

msgid ""
"This applies to all non-function statement blocks (if, switch, for, "
"while, do). e.g.:"
msgstr ""
"Это применимо ко всем блокам операторов без функций (if, switch, for, "
"while, do), например:"

msgid ""
"switch (action) {\n"
"case KOBJ_ADD:\n"
"    return \"add\";\n"
"case KOBJ_REMOVE:\n"
"    return \"remove\";\n"
"case KOBJ_CHANGE:\n"
"    return \"change\";\n"
"default:\n"
"    return NULL;\n"
"}"
msgstr ""
"switch (action) {\n"
"case KOBJ_ADD:\n"
"    return \"add\";\n"
"case KOBJ_REMOVE:\n"
"    return \"remove\";\n"
"case KOBJ_CHANGE:\n"
"    return \"change\";\n"
"default:\n"
"    return NULL;\n"
"}"

msgid ""
"However, there is one special case, namely functions: they have the "
"opening brace at the beginning of the next line, thus:"
msgstr ""
"И только в особенных случаях, а именно для функций, открывающая скобка "
"размещается в начале следующей строки:"

msgid ""
"int function(int x)\n"
"{\n"
"    body of function;\n"
"}"
msgstr ""
"int function(int x)\n"
"{\n"
"    body of function;\n"
"}"

msgid ""
"Heretic people all over the world have claimed that this inconsistency is"
" ...  well ...  inconsistent, but all right-thinking people know that (a)"
" K&R are _right_ and (b) K&R are right.  Besides, functions are special "
"anyway (you can't nest them in C)."
msgstr ""
"Отступники по всему миру утверждали, что такая несогласованность ... ну "
"... несогласованна, но все здравомыслящие люди знают: (a) K&R _правы_, "
"(б) K&R правы. Кроме того, функции в любом случае будут особенными (в C "
"их нельзя вложить)."

msgid ""
"Note that the closing brace is empty on a line of its own, _except_ in "
"the cases where it is followed by a continuation of the same statement, "
"i.e. a \"while\" in a do-statement or an \"else\" in an if-statement, "
"like this:"
msgstr ""

msgid ""
"do {\n"
"    body of do-loop;\n"
"} while (condition);"
msgstr ""
"do {\n"
"    body of do-loop;\n"
"} while (condition);"

msgid "and"
msgstr "и"

msgid ""
"if (x == y) {\n"
"    ..\n"
"} else if (x > y) {\n"
"    ...\n"
"} else {\n"
"    ....\n"
"}"
msgstr ""
"if (x == y) {\n"
"    ..\n"
"} else if (x > y) {\n"
"    ...\n"
"} else {\n"
"    ....\n"
"}"

msgid "Rationale: K&R."
msgstr "Обоснование: K&R."

msgid ""
"Also, note that this brace-placement also minimizes the number of empty "
"(or almost empty) lines, without any loss of readability.  Thus, as the "
"supply of new-lines on your screen is not a renewable resource (think "
"25-line terminal screens here), you have more empty lines to put comments"
" on."
msgstr ""
"Кроме того, обратите внимание, что такое расположение скобок также сводит"
" к минимуму количество пустых (или почти пустых) строк без потери "
"читаемости. Таким образом, поскольку новые строки на экране -- это не "
"возобновляемый ресурс (вспомним о 25-строчных экранах терминала), у вас "
"будет больше пустых строк для комментариев."

msgid "Do not unnecessarily use braces where a single statement will do."
msgstr "Не используйте лишние фигурные скобки, если нужен всего один оператор."

msgid ""
"if (condition)\n"
"    action();"
msgstr ""
"if (condition)\n"
"    action();"

msgid ""
"This does not apply if one branch of a conditional statement is a single "
"statement. Use braces in both branches."
msgstr ""
"Это не применимо, если одна ветка условного оператора -- это отдельный "
"оператор. Используйте фигурные скобки в обеих ветках."

msgid ""
"if (condition) {\n"
"    do_this();\n"
"    do_that();\n"
"} else {\n"
"    otherwise();\n"
"}"
msgstr ""
"if (condition) {\n"
"    do_this();\n"
"    do_that();\n"
"} else {\n"
"    otherwise();\n"
"}"

msgid "Chapter 3.1:  Spaces"
msgstr "Глава 3.1: Пробелы"

msgid ""
"Linux kernel style for use of spaces depends (mostly) on function-versus-"
"keyword usage.  Use a space after (most) keywords.  The notable "
"exceptions are sizeof, typeof, alignof, and __attribute__, which look "
"somewhat like functions (and are usually used with parentheses in Linux, "
"although they are not required in the language, as in: \"sizeof info\" "
"after \"struct fileinfo info;\" is declared)."
msgstr ""
"Стиль программирования ядра Linux в том, что касается пробелов, зависит "
"(в основном) от использования функции или ключевого слова. Используйте "
"пробел после (большинства) ключевых слов. Значимые исключения: sizeof, "
"typeof, alignof и __attribute__, которые похожи на функции (и обычно "
"используются с круглыми скобками в Linux, хотя они и не требуются, как в "
"объявлении \"sizeof info\" после \"struct fileinfo info;\")."

msgid ""
"So use a space after these keywords: if, switch, case, for, do, while but"
" not with sizeof, typeof, alignof, or __attribute__.  E.g.,"
msgstr ""
"Поэтому добавляйте пробел после следующих ключевых слов: if, switch, "
"case, for, do, while, но не для sizeof, typeof, alignof или "
"__attribute__.  Пример:"

msgid "s = sizeof(struct file);"
msgstr "s = sizeof(struct file);"

msgid ""
"Do not add spaces around (inside) parenthesized expressions. This example"
" is **bad**:"
msgstr ""
"Не добавляйте пробелы вокруг (внутри) выражений в круглых скобках. Этот "
"пример **неправильный**:"

msgid "s = sizeof( struct file );"
msgstr "s = sizeof( struct file );"

msgid ""
"When declaring pointer data or a function that returns a pointer type, "
"the preferred use of '*' is adjacent to the data name or function name "
"and not adjacent to the type name.  Examples:"
msgstr ""
"Объявляя данных типа указателя или функцию, которая возвращает тип "
"указателя, предпочтительно использовать '*' рядом с именем данных или "
"именем функции, а не рядом с именем типа. Примеры:"

msgid ""
"char *linux_banner;\n"
"unsigned long long memparse(char *ptr, char **retptr);\n"
"char *match_strdup(substring_t *s);"
msgstr ""
"char *linux_banner;\n"
"unsigned long long memparse(char *ptr, char **retptr);\n"
"char *match_strdup(substring_t *s);"

msgid ""
"Use one space around (on each side of) most binary and ternary operators,"
" such as any of these:"
msgstr ""
"Добавляйте по одному пробелу вокруг (с каждой стороны) большинства знаков"
" двухместных и трехместных операций, например, любое из следующих:"

msgid "=  +  -  <  >  *  /  %  |  &  ^  <=  >=  ==  !=  ?  :"
msgstr "=  +  -  <  >  *  /  %  |  &  ^  <=  >=  ==  !=  ?  :"

msgid "but no space after unary operators:"
msgstr "но не добавляйте пробелы после знаков одноместных операций:"

msgid "&  *  +  -  ~  !  sizeof  typeof  alignof  __attribute__  defined"
msgstr "&  *  +  -  ~  !  sizeof  typeof  alignof  __attribute__  defined"

msgid "no space before the postfix increment & decrement unary operators:"
msgstr ""
"не нужны пробелы перед знаками одноместных операций увеличения или "
"уменьшения постфикса:"

msgid "++  --"
msgstr "++  --"

msgid "no space after the prefix increment & decrement unary operators:"
msgstr ""
"не нужны пробелы после знаков одноместных операций увеличения или "
"уменьшения префикса:"

msgid "and no space around the '.' and \"->\" structure member operators."
msgstr "и не нужны пробелы вокруг знаков элементов структуры '.' и \"->\"."

msgid ""
"Do not leave trailing whitespace at the ends of lines.  Some editors with"
" \"smart\" indentation will insert whitespace at the beginning of new "
"lines as appropriate, so you can start typing the next line of code right"
" away. However, some such editors do not remove the whitespace if you end"
" up not putting a line of code there, such as if you leave a blank line."
"  As a result, you end up with lines containing trailing whitespace."
msgstr ""
"Не оставляйте пробелы на концах строк. Некоторые редакторы с \"умным\" "
"отступом вставляют пробелы в начале новых строк, поэтому вы можете сразу "
"ввести следующую строку кода. Однако некоторые такие редакторы не удаляют"
" пробелы, если вы не пишете там код, например, если вы оставите пустую "
"строку. В результате имеем строки с пробелами в конце."

msgid ""
"Git will warn you about patches that introduce trailing whitespace, and "
"can optionally strip the trailing whitespace for you; however, if "
"applying a series of patches, this may make later patches in the series "
"fail by changing their context lines."
msgstr ""
"Git предупредит, если патчи содержат пробелы в конце строк, и может по "
"желанию удалить пробелы за вас; однако, в серии патчей, это может "
"привести к тому, что последующие патчи в серии не применятся, поскольку "
"изменены контекстные строки."

msgid "Chapter 4: Naming"
msgstr "Глава 4: Именование"

msgid ""
"C is a Spartan language, and so should your naming be.  Unlike Modula-2 "
"and Pascal programmers, C programmers do not use cute names like "
"ThisVariableIsATemporaryCounter.  A C programmer would call that variable"
" \"tmp\", which is much easier to write, and not the least more difficult"
" to understand."
msgstr ""
"C -- это спартанский язык, и именование должно быть спартанским. В "
"отличие от разработчиков на Modula-2 и Pascal, разработчики на языке C не"
" используют забавные имена, такие как ThisVariableIsATemporaryCounter. "
"Разработчик на языке C назвал бы такую переменную \"tmp\", что намного "
"легче написать и не менее сложно понять."

msgid ""
"HOWEVER, while mixed-case names are frowned upon, descriptive names for "
"global variables are a must.  To call a global function \"foo\" is a "
"shooting offense."
msgstr ""
"ОДНАКО, хотя на имена со смешанным регистром смотрят неодобрительно, "
"обязательным требованием будут описательные имена глобальных переменных. "
"Назвать глобальную функцию \"foo\" -- это оскорбление."

msgid ""
"GLOBAL variables (to be used only if you _really_ need them) need to have"
" descriptive names, as do global functions.  If you have a function that "
"counts the number of active users, you should call that "
"\"count_active_users()\" or similar, you should _not_ call it "
"\"cntusr()\"."
msgstr ""
"У ГЛОБАЛЬНЫХ переменных (которые надо использовать, только если без них "
"НЕЛЬЗЯ обойтись) должны быть описательные имена, равно как и у глобальных"
" функций. Если у вас есть функция, которая подсчитывает количество "
"активных пользователей, нужно назвать ее \"count_active_users()\" или "
"как-то похоже, _НЕ_ следует называть ее \"cntusr()\"."

msgid ""
"Encoding the type of a function into the name (so-called Hungarian "
"notation) is brain damaged - the compiler knows the types anyway and can "
"check those, and it only confuses the programmer.  No wonder MicroSoft "
"makes buggy programs."
msgstr ""
"Кодирование типа функции в названии (так называемая венгерская нотация) "
"-- это признак плохого тона, поскольку компилятор в любом случае знает "
"типы и может их проверять, и это только путает программиста. "
"Неудивительно, что MicroSoft делает глючные программы."

msgid ""
"LOCAL variable names should be short, and to the point.  If you have some"
" random integer loop counter, it should probably be called \"i\". Calling"
" it \"loop_counter\" is non-productive, if there is no chance of it being"
" misunderstood.  Similarly, \"tmp\" can be just about any type of "
"variable that is used to hold a temporary value."
msgstr ""

msgid ""
"If you are afraid to mix up your local variable names, you have another "
"problem, which is called the function-growth-hormone-imbalance syndrome. "
"See chapter 6 (Functions)."
msgstr ""
"Если вы боитесь перепутать имена своих локальных переменных, у вас другая"
" проблема, которая называется синдромом дисбаланса гормона роста функций."
" См. Главу 6 (Функции)."

msgid "Chapter 5: Typedefs"
msgstr "Глава 5: Директива Typedef"

msgid "Please don't use things like \"vps_t\"."
msgstr "Не используйте что-то вроде \"vps_t\"."

msgid ""
"It's a _mistake_ to use typedef for structures and pointers. When you see"
" a"
msgstr ""
"Будет _ошибкой_ использовать typedef для определения структур и "
"указателей. Если вы видите"

msgid "vps_t a;"
msgstr "vps_t a;"

msgid "in the source, what does it mean?"
msgstr "в исходном коде, что это означает?"

msgid "In contrast, if it says"
msgstr "И наоборот, если говорится"

msgid "struct virtual_container *a;"
msgstr "struct virtual_container *a;"

msgid "you can actually tell what \"a\" is."
msgstr "можно действительно понять, что такое \"a\"."

msgid ""
"Lots of people think that typedefs \"help readability\". Not so. They are"
" useful only for:"
msgstr ""
"Многие думают, что typedef \"способствует читаемости\". Это не так. Эту "
"директиву нужно использовать для:"

msgid ""
"totally opaque objects (where the typedef is actively used to _hide_ what"
" the object is)."
msgstr ""
"непрозрачных объектов (где typedef активно используется для _сокрытия_ "
"объекта)."

msgid ""
"Example: \"pte_t\" etc. opaque objects that you can only access using the"
" proper accessor functions."
msgstr ""
"Пример: \"pte_t\" и другие непрозрачные объекты, доступ к которым можно "
"получить с помощью соответствующих функций доступа."

msgid ""
"NOTE! Opaqueness and \"accessor functions\" are not good in themselves. "
"The reason we have them for things like pte_t etc. is that there really "
"is absolutely _zero_ portably accessible information there."
msgstr ""
"ВНИМАНИЕ! Непрозрачность и функции доступа сами по себе не слишком "
"хороши. Причина, по которой мы используем их для pte_t и т.п., состоит в "
"том, что на самом деле там _нет_ никакой информации для скачивания."

msgid ""
"Clear integer types, where the abstraction _helps_ avoid confusion "
"whether it is \"int\" or \"long\"."
msgstr ""
"Чисто целочисленные типы, где абстракция _помогает_ избежать путаницы, "
"\"int\" это или \"long\"."

msgid ""
"u8/u16/u32 are perfectly fine typedefs, although they fit into category "
"(d) better than here."
msgstr ""
"u8/u16/u32 -- вполне нормальные typedef, хотя они больше подходят для "
"категории (d)."

msgid ""
"NOTE! Again - there needs to be a _reason_ for this. If something is "
"\"unsigned long\", then there's no reason to do"
msgstr ""
"ВНИМАНИЕ! Опять же -- для этого должна быть _причина_. Если что-то "
"представляет собой \"unsigned long\", должна быть причина для"

msgid "typedef unsigned long myflags_t;"
msgstr "typedef unsigned long myflags_t;"

msgid ""
"but if there is a clear reason for why it under certain circumstances "
"might be an \"unsigned int\" and under other configurations might be "
"\"unsigned long\", then by all means go ahead and use a typedef."
msgstr ""
"но если есть четкая причина, почему при определенных обстоятельствах "
"может быть \"unsigned int\", а в других случаях может быть \"unsigned "
"long\", то на здоровье, используйте typedef."

msgid "when you use sparse to literally create a _new_ type for type-checking."
msgstr ""
"когда вы используете разрыв, чтобы буквально создать _новый_ тип для "
"проверки типов."

msgid ""
"New types which are identical to standard C99 types, in certain "
"exceptional circumstances."
msgstr ""
"Новые типы, идентичные стандартным типам C99, в определенных "
"исключительных обстоятельствах."

msgid ""
"Although it would only take a short amount of time for the eyes and brain"
" to become accustomed to the standard types like 'uint32_t', some people "
"object to their use anyway."
msgstr ""
"Хотя глазам и мозгу требуется лишь короткое время, чтобы привыкнуть к "
"стандартным типам, например, 'uint32_t', некоторые в любом случае "
"возражают против их использования."

msgid ""
"Therefore, the Linux-specific 'u8/u16/u32/u64' types and their signed "
"equivalents which are identical to standard types are permitted -- "
"although they are not mandatory in new code of your own."
msgstr ""
"Таким образом, допускаются специфичные для Linux типы 'u8/u16/u32/u64' и "
"их эквиваленты, идентичные стандартным типам, хотя они и не обязательны "
"новом коде."

msgid ""
"When editing existing code which already uses one or the other set of "
"types, you should conform to the existing choices in that code."
msgstr ""
"При редактировании существующего кода, в котором уже используется один "
"или другой набор типов, следует придерживаться выбранного типа."

msgid "Types safe for use in userspace."
msgstr "Типы, которые можно использовать в пользовательском пространстве."

msgid ""
"In certain structures which are visible to userspace, we cannot require "
"C99 types and cannot use the 'u32' form above. Thus, we use __u32 and "
"similar types in all structures which are shared with userspace."
msgstr ""
"В некоторых структурах, видимых в пользовательском пространстве, мы не "
"можем требовать использования типов C99 и не можем применять форму 'u32' "
"выше. Таким образом, мы используем __u32 и подобные типы во всех "
"структурах, которые используются и в пользовательском пространстве."

msgid ""
"Maybe there are other cases too, but the rule should basically be to "
"NEVER EVER use a typedef unless you can clearly match one of those rules."
msgstr ""
"Возможно, есть и другие случаи, но основное правило состоит в следующем: "
"НИКОГДА НЕ используйте typedef, если вы не соблюдаете одно из этих "
"правил."

msgid ""
"In general, a pointer, or a struct that has elements that can reasonably "
"be directly accessed should **never** be a typedef."
msgstr ""
"В общем, указатель или структура, содержащие элементы, к которым можно "
"получить прямой доступ, **никогда** не должны быть typedef."

msgid "Chapter 6: Functions"
msgstr "Глава 6: Функции"

msgid ""
"Functions should be short and sweet, and do just one thing.  They should "
"fit on one or two screenfuls of text (the ISO/ANSI screen size is 80x24, "
"as we all know), and do one thing and do that well."
msgstr ""
"Функции должны быть короткими и приятными, и выполнять только одно "
"действие. Они должны помещаться на одном или двух экранах текста (размер "
"экрана ISO/ANSI 80x24, как мы все знаем), и выполнять одно действие, но "
"делать это хорошо."

msgid ""
"The maximum length of a function is inversely proportional to the "
"complexity and indentation level of that function.  So, if you have a "
"conceptually simple function that is just one long (but simple) case-"
"statement, where you have to do lots of small things for a lot of "
"different cases, it's OK to have a longer function."
msgstr ""
"Максимальная длина функции обратно пропорциональна сложности функции и "
"уровню отступов. Итак, если у вас есть концептуально простая функция, "
"которая представляет собой лишь один длинный (но простой) оператор "
"вариант case, где вам нужно делать много мелочей для множества разных "
"случаев, длинная функция -- это нормально."

msgid ""
"However, if you have a complex function, and you suspect that a less-"
"than-gifted first-year high-school student might not even understand what"
" the function is all about, you should adhere to the maximum limits all "
"the more closely.  Use helper functions with descriptive names (you can "
"ask the compiler to in-line them if you think it's performance-critical, "
"and it will probably do a better job of it than you would have done)."
msgstr ""
"Однако, если у вас есть сложная функция, и вы подозреваете, что не "
"слишком одаренный старшеклассник может даже не понять, о чем эта функция,"
" следует придерживаться ограничений. Используйте вспомогательные функции "
"с описательными именами (можно попросить компилятор встроить их, если "
"считаете, что это критически важно для производительности, и он, "
"вероятно, справится лучше)."

msgid ""
"Another measure of the function is the number of local variables.  They "
"shouldn't exceed 5-10, or you're doing something wrong.  Re-think the "
"function, and split it into smaller pieces.  A human brain can generally "
"easily keep track of about 7 different things, anything more and it gets "
"confused.  You know you're brilliant, but maybe you'd like to understand "
"what you did 2 weeks from now."
msgstr ""

msgid ""
"In source files, separate functions with one blank line.  If the function"
" is exported, the EXPORT* macro for it should follow immediately after "
"the closing function brace line.  E.g.:"
msgstr ""
"В исходных файлах разделяйте функции пустой строкой. Если функция "
"экспортируется, макрос EXPORT* должен следовать сразу за строкой с "
"закрывающей фигурной скобкой. Например:"

msgid ""
"int system_is_up(void)\n"
"{\n"
"    return system_state == SYSTEM_RUNNING;\n"
"}\n"
"EXPORT_SYMBOL(system_is_up);"
msgstr ""
"int system_is_up(void)\n"
"{\n"
"    return system_state == SYSTEM_RUNNING;\n"
"}\n"
"EXPORT_SYMBOL(system_is_up);"

msgid ""
"In function prototypes, include parameter names with their data types. "
"Although this is not required by the C language, it is preferred in Linux"
" because it is a simple way to add valuable information for the reader."
msgstr ""
"В прототипах функций включайте имена параметров с типами данных. Хотя для"
" языка C это и не требуется, но рекомендуется для Linux, потому что это "
"простой способ добавить ценную информацию для читателя."

msgid "Chapter 7: Centralized exiting of functions"
msgstr "Глава 7: Централизованный выход из функции"

msgid ""
"Albeit deprecated by some people, the equivalent of the goto statement is"
" used frequently by compilers in form of the unconditional jump "
"instruction."
msgstr ""
"Хотя некоторые объявили аналог оператора goto устаревшим, его часто "
"используют компиляторы в виде инструкции безусловной передачи управления."

msgid ""
"The goto statement comes in handy when a function exits from multiple "
"locations and some common work such as cleanup has to be done."
msgstr ""
"Оператор goto пригодится, когда функция производит выход из нескольких "
"мест, и необходимо выполнить какие-то общие действия, такие как очистка."

msgid "The rationale is:"
msgstr "Обоснование:"

msgid "unconditional statements are easier to understand and follow"
msgstr "безусловные операторы легче понять и выполнять"

msgid "nesting is reduced"
msgstr "уменьшается глубина вложения"

msgid ""
"errors by not updating individual exit points when making modifications "
"are prevented"
msgstr ""
"предотвращаются ошибки по причине отсутствия обновления отдельных точек "
"выхода при внесении изменений"

msgid "saves the compiler work to optimize redundant code away ;)"
msgstr "уменьшает объем работы компилятора для оптимизации избыточного кода ;)"

msgid ""
"int fun(int a)\n"
"{\n"
"    int result = 0;\n"
"    char *buffer = kmalloc(SIZE);\n"
"\n"
"    if (buffer == NULL)\n"
"        return -ENOMEM;\n"
"\n"
"    if (condition1) {\n"
"        while (loop1) {\n"
"            ...\n"
"        }\n"
"        result = 1;\n"
"        goto out;\n"
"    }\n"
"    ...\n"
"out:\n"
"    kfree(buffer);\n"
"    return result;\n"
"}"
msgstr ""
"int fun(int a)\n"
"{\n"
"    int result = 0;\n"
"    char *buffer = kmalloc(SIZE);\n"
"\n"
"    if (buffer == NULL)\n"
"        return -ENOMEM;\n"
"\n"
"    if (condition1) {\n"
"        while (loop1) {\n"
"            ...\n"
"        }\n"
"        result = 1;\n"
"        goto out;\n"
"    }\n"
"    ...\n"
"out:\n"
"    kfree(buffer);\n"
"    return result;\n"
"}"

msgid "Chapter 8: Commenting"
msgstr "Глава 8: Комментирование"

msgid ""
"Comments are good, but there is also a danger of over-commenting. NEVER "
"try to explain HOW your code works in a comment: it's much better to "
"write the code so that the _working_ is obvious, and it's a waste of time"
" to explain badly written code. с Generally, you want your comments to "
"tell WHAT your code does, not HOW. Also, try to avoid putting comments "
"inside a function body: if the function is so complex that you need to "
"separately comment parts of it, you should probably go back to chapter 6 "
"for a while.  You can make small comments to note or warn about something"
" particularly clever (or ugly), but try to avoid excess.  Instead, put "
"the comments at the head of the function, telling people what it does, "
"and possibly WHY it does it."
msgstr ""
"Комментарии полезны, но есть и опасность чрезмерного комментирования. "
"НИКОГДА не пытайтесь объяснить в комментарии, КАК работает ваш код: "
"гораздо лучше написать код так, чтобы принцип _работы_ был очевиден, а "
"объяснять плохо написанный код -- это пустая трата времени. Как правило, "
"желательно, чтобы комментарии поясняли, ЧТО делает ваш код, а не КАК. "
"Кроме того, постарайтесь не размещать комментарии внутри тела функции: "
"если функция настолько сложна, что нужно отдельно комментировать ее "
"части, скорее всего, вам надо вернуться к главе 6. Можно давать небольшие"
" комментарии, чтобы отметить или предупредить о чем-то особенно умном "
"(или уродливом), но старайтесь избегать лишнего. Вместо этого поставьте "
"комментарии во главе функции, сообщите людям, что она делает, и, "
"возможно, ПОЧЕМУ она это делает."

msgid ""
"When commenting the kernel API functions, please use the kernel-doc "
"format. See the files Documentation/kernel-doc-nano-HOWTO.txt and scripts"
"/kernel-doc for details."
msgstr ""
"Комментируя функции API ядра, используйте формат kernel-doc. Более "
"подробную информацию см. в файлах Documentation/kernel-doc-nano-HOWTO.txt"
" и scripts/kernel-doc."

msgid ""
"Linux style for comments is the C89 :code:`/* ... */`` style. Don't use "
"C99-style :code:`// ...` comments."
msgstr ""
"Стиль Linux для комментариев -- стиль C89 :code:`/* ... */`` . Не "
"используйте стиль C99 :code:`// ...`."

msgid "The preferred style for long (multi-line) comments is:"
msgstr "Для длинных (многострочных) комментариев рекомендуется:"

msgid ""
"/*\n"
" * This is the preferred style for multi-line\n"
" * comments in the Linux kernel source code.\n"
" * Please use it consistently.\n"
" *\n"
" * Description:  A column of asterisks on the left side,\n"
" * with beginning and ending almost-blank lines.\n"
" */"
msgstr ""
"/*\n"
" * Рекомендуется использовать этот стиль для многострочных\n"
" * комментариев в исходном коде ядра Linux.\n"
" * Просьба использовать его согласованно.\n"
" *\n"
" * Описание:  Столбец звездочек слева,\n"
" * в начале и в конце почти пустые строки.\n"
" */"

msgid ""
"It's also important to comment data, whether they are basic types or "
"derived types.  To this end, use just one data declaration per line (no "
"commas for multiple data declarations).  This leaves you room for a small"
" comment on each item, explaining its use."
msgstr ""
"Также важно комментировать данные, являются ли они базовыми или "
"производными типами. Для этого используйте только одно объявление данных "
"в строке (без запятой для объявления массива данных). Это оставляет вам "
"место для небольшого комментария к каждому пункту с объяснением его "
"использования."

msgid "Chapter 9: You've made a mess of it"
msgstr "Глава 9: Вы устроили беспорядок"

msgid ""
"That's OK, we all do.  You've probably been told by your long-time Unix "
"user helper that \"GNU emacs\" automatically formats the C sources for "
"you, and you've noticed that yes, it does do that, but the defaults it "
"uses are less than desirable (in fact, they are worse than random typing "
"- an infinite number of monkeys typing into GNU emacs would never make a "
"good program)."
msgstr ""
"Всё в порядке, мы все так делаем. Наверное, опытный пользователь Unix, "
"который вам помогает, сказал, что \"GNU emacs\" автоматически форматирует"
" исходный код C, и вы заметили, что да, действительно, но используемые по"
" умолчанию значения оставляют желать лучшего ( на самом деле, они хуже, "
"чем случайные -- несметное количество обезьян, печатающих в GNU emacs, "
"никогда не создаст хорошую программу)."

msgid ""
"So, you can either get rid of GNU emacs, or change it to use saner "
"values.  To do the latter, you can stick the following in your .emacs "
"file:"
msgstr ""
"Итак, вы можете либо избавиться от GNU emacs, либо изменить его для "
"использования более адекватных значений. Чтобы сделать последнее, можно "
"вставить следующее в файл .emacs:"

msgid ""
"(defun c-lineup-arglist-tabs-only (ignored)\n"
"\"Line up argument lists by tabs, not spaces\"\n"
"(let* ((anchor (c-langelem-pos c-syntactic-element))\n"
"    (column (c-langelem-2nd-pos c-syntactic-element))\n"
"    (offset (- (1+ column) anchor))\n"
"    (steps (floor offset c-basic-offset)))\n"
"    (* (max steps 1)\n"
"    c-basic-offset)))\n"
"\n"
"(add-hook 'c-mode-common-hook\n"
"        (lambda ()\n"
"            ;; Add kernel style\n"
"            (c-add-style\n"
"            \"linux-tabs-only\"\n"
"            '(\"linux\" (c-offsets-alist\n"
"                        (arglist-cont-nonempty\n"
"                        c-lineup-gcc-asm-reg\n"
"                        c-lineup-arglist-tabs-only))))))\n"
"\n"
"(add-hook 'c-mode-hook\n"
"        (lambda ()\n"
"            (let ((filename (buffer-file-name)))\n"
"            ;; Enable kernel mode for the appropriate files\n"
"            (when (and filename\n"
"                        (string-match (expand-file-name \"~/src/linux-"
"trees\")\n"
"                                    filename))\n"
"                (setq indent-tabs-mode t)\n"
"                (c-set-style \"linux-tabs-only\")))))"
msgstr ""
"(defun c-lineup-arglist-tabs-only (ignored)\n"
"\"Line up argument lists by tabs, not spaces\"\n"
"(let* ((anchor (c-langelem-pos c-syntactic-element))\n"
"    (column (c-langelem-2nd-pos c-syntactic-element))\n"
"    (offset (- (1+ column) anchor))\n"
"    (steps (floor offset c-basic-offset)))\n"
"    (* (max steps 1)\n"
"    c-basic-offset)))\n"
"\n"
"(add-hook 'c-mode-common-hook\n"
"        (lambda ()\n"
"            ;; Add kernel style\n"
"            (c-add-style\n"
"            \"linux-tabs-only\"\n"
"            '(\"linux\" (c-offsets-alist\n"
"                        (arglist-cont-nonempty\n"
"                        c-lineup-gcc-asm-reg\n"
"                        c-lineup-arglist-tabs-only))))))\n"
"\n"
"(add-hook 'c-mode-hook\n"
"        (lambda ()\n"
"            (let ((filename (buffer-file-name)))\n"
"            ;; Enable kernel mode for the appropriate files\n"
"            (when (and filename\n"
"                        (string-match (expand-file-name \"~/src/linux-"
"trees\")\n"
"                                    filename))\n"
"                (setq indent-tabs-mode t)\n"
"                (c-set-style \"linux-tabs-only\")))))"

msgid ""
"This will make emacs go better with the kernel coding style for C files "
"below ~/src/linux-trees."
msgstr ""
"Это заставит emacs лучше работать со стилем программирования ядра для "
"файлов C в ~/src/linux-trees."

msgid ""
"But even if you fail in getting emacs to do sane formatting, not "
"everything is lost: use \"indent\"."
msgstr ""
"Но даже если вам не удастся заставить emacs форматировать нормально, не "
"все потеряно: используйте \"indent\"."

msgid ""
"Now, again, GNU indent has the same brain-dead settings that GNU emacs "
"has, which is why you need to give it a few command line options. "
"However, that's not too bad, because even the makers of GNU indent "
"recognize the authority of K&R (the GNU people aren't evil, they are just"
" severely misguided in this matter), so you just give indent the options "
"\"-kr -i8\" (stands for \"K&R, 8 character indents\"), or use "
"\"scripts/Lindent\", which indents in the latest style."
msgstr ""
"Опять же, у GNU indent такие же безмозглые настройки, как и у GNU emacs, "
"поэтому надо задать для него несколько параметров командной строки. Тем "
"не менее, это не так уж плохо, потому что даже разработчики GNU indent "
"признают авторитет K&R (люди из GNU не злые, они просто серьезно "
"ошибаются в этом вопросе), поэтому вы просто указываете опции \"-kr -i8\""
" (означает \"K&R, 8 символов отступа\") или используйте "
"\"scripts/Lindent\", которые делают отступы в новейшем стиле."

msgid ""
"\"indent\" has a lot of options, and especially when it comes to comment "
"re-formatting you may want to take a look at the man page.  But remember:"
" \"indent\" is not a fix for bad programming."
msgstr ""
"В \"indent\" есть много опций, и особенно когда дело доходит до "
"повторного форматирования комментариев, вы можете захотеть взглянуть на "
"страницу руководства. Но помните: \"indent\" -- это не залог хорошего "
"программирования."

msgid "Chapter 10: Kconfig configuration files"
msgstr "Глава 10: Конфигурационные файлы Kconfig"

msgid ""
"For all of the Kconfig* configuration files throughout the source tree, "
"the indentation is somewhat different.  Lines under a \"config\" "
"definition are indented with one tab, while help text is indented an "
"additional two spaces. Example:"
msgstr ""
"Для всех конфигурационных файлов Kconfig* в дереве источников отступы "
"несколько отличаются. Строки под определением \"config\" имеют отступы на"
" позицию табуляции, а текст справки с отступом еще на два пробела. "
"Пример:"

msgid ""
"config AUDIT\n"
"    bool \"Auditing support\"\n"
"    depends on NET\n"
"    help\n"
"    Enable auditing infrastructure that can be used with another\n"
"    kernel subsystem, such as SELinux (which requires this for\n"
"    logging of avc messages output).  Does not do system-call\n"
"    auditing without CONFIG_AUDITSYSCALL."
msgstr ""
"config AUDIT\n"
"    bool \"Auditing support\"\n"
"    depends on NET\n"
"    help\n"
"    Enable auditing infrastructure that can be used with another\n"
"    kernel subsystem, such as SELinux (which requires this for\n"
"    logging of avc messages output).  Does not do system-call\n"
"    auditing without CONFIG_AUDITSYSCALL."

msgid ""
"Features that might still be considered unstable should be defined as "
"dependent on \"EXPERIMENTAL\":"
msgstr ""
"Функции, которые все еще могут считаться нестабильными, должны "
"определяться как зависящие от \"EXPERIMENTAL\":"

msgid ""
"config SLUB\n"
"    depends on EXPERIMENTAL && !ARCH_USES_SLAB_PAGE_STRUCT\n"
"    bool \"SLUB (Unqueued Allocator)\"\n"
"    ..."
msgstr ""
"config SLUB\n"
"    depends on EXPERIMENTAL && !ARCH_USES_SLAB_PAGE_STRUCT\n"
"    bool \"SLUB (Unqueued Allocator)\"\n"
"    ..."

msgid ""
"while seriously dangerous features (such as write support for certain "
"filesystems) should advertise this prominently in their prompt string:"
msgstr ""
"тогда как крайне опасные функции (например, поддержка записи для "
"определенных файловых систем) должны подчеркнуть это в строке "
"приглашения:"

msgid ""
"config ADFS_FS_RW\n"
"    bool \"ADFS write support (DANGEROUS)\"\n"
"    depends on ADFS_FS\n"
"    ..."
msgstr ""
"config ADFS_FS_RW\n"
"    bool \"ADFS write support (DANGEROUS)\"\n"
"    depends on ADFS_FS\n"
"    ..."

msgid ""
"For full documentation on the configuration files, see the file "
"Documentation/kbuild/kconfig-language.txt."
msgstr ""
"Полную документацию по файлам конфигурации см. в файле "
"Documentation/kbuild/kconfig-language.txt."

msgid "Chapter 11: Data structures"
msgstr "Глава 11: Структуры данных"

msgid ""
"Data structures that have visibility outside the single-threaded "
"environment they are created and destroyed in should always have "
"reference counts.  In the kernel, garbage collection doesn't exist (and "
"outside the kernel garbage collection is slow and inefficient), which "
"means that you absolutely _have_ to reference count all your uses."
msgstr ""
"Для структур данных, которые видимы за пределами однопотоковой среды, в "
"которой они создаются и удаляются, всегда должен выполняться подсчет "
"ссылок. В ядре нет сборки мусора (и за пределами ядра сборка мусора "
"производится медленно и неэффективно), а это означает, что абсолютно "
"_необходимо_ подсчитывать ссылки на каждый случай использования."

msgid ""
"Reference counting means that you can avoid locking, and allows multiple "
"users to have access to the data structure in parallel - and not having "
"to worry about the structure suddenly going away from under them just "
"because they slept or did something else for a while."
msgstr ""
"Подсчет ссылок означает, что можно избежать блокировки и позволить "
"нескольким пользователям получать доступ к структуре данных одновременно "
"-- и не нужно беспокоиться о том, что структура внезапно исчезнет только "
"потому, что они спали или делали что-то еще."

msgid ""
"Note that locking is _not_ a replacement for reference counting. Locking "
"is used to keep data structures coherent, while reference counting is a "
"memory management technique.  Usually both are needed, and they are not "
"to be confused with each other."
msgstr ""
"Обратите внимание, что блокировка _не_ является заменой для подсчета "
"ссылок. Блокировка используется для обеспечения целостности структур "
"данных, а подсчет ссылок -- это метод управления памятью. Обычно "
"необходимо и то, и другое, и их нельзя путать друг с другом."

msgid ""
"Many data structures can indeed have two levels of reference counting, "
"when there are users of different \"classes\".  The subclass count counts"
" the number of subclass users, and decrements the global count just once "
"when the subclass count goes to zero."
msgstr ""
"Для многих структур данных действительно могут быть два уровня подсчета "
"ссылок, когда есть пользователи разных \"классов\". Подсчет подкласса "
"подсчитывает количество пользователей подкласса и уменьшает глобальный "
"счетчик только один раз, когда подсчет подкласса равен нулю."

msgid ""
"Examples of this kind of \"multi-level-reference-counting\" can be found "
"in memory management (\"struct mm_struct\": mm_users and mm_count), and "
"in filesystem code (\"struct super_block\": s_count and s_active)."
msgstr ""
"Примеры такого многоуровневого подсчета ссылок можно найти в управлении "
"памятью (\"struct mm_struct\": mm_users и mm_count) и в коде файловой "
"системы (\"struct super_block\": s_count и s_active)."

msgid ""
"Remember: if another thread can find your data structure, and you don't "
"have a reference count on it, you almost certainly have a bug."
msgstr ""
"Следует помнить, что если другой поток может найти вашу структуру данных,"
" и у вас нет счетчика ссылок, почти наверняка возникнет ошибка."

msgid "Chapter 12: Macros, Enums and RTL"
msgstr "Глава 12: Макросы, перечисления и уровни регистровых передач (RTL)"

msgid "Names of macros defining constants and labels in enums are capitalized."
msgstr ""
"Имена макросов, определяющих постоянные и метки в перечислениях, пишутся "
"заглавными буквами."

msgid "#define CONSTANT 0x12345"
msgstr "#define CONSTANT 0x12345"

msgid "Enums are preferred when defining several related constants."
msgstr ""
"Рекомендуется использовать перечисления при определении нескольких "
"связанных постоянных."

msgid ""
"CAPITALIZED macro names are appreciated but macros resembling functions "
"may be named in lower case."
msgstr ""
"Ценятся имена макросов, написанные ЗАГЛАВНЫМИ буквами, но похожие на "
"функции макросы можно называть, используя буквы в нижнем регистре."

msgid "Generally, inline functions are preferable to macros resembling functions."
msgstr ""
"Как правило, рекомендуется использовать встроенные функции для макросов, "
"похожих на функции."

msgid "Macros with multiple statements should be enclosed in a do - while block:"
msgstr "Макросы с несколькими операторами должны быть заключены в блок do - while:"

msgid ""
"#define macrofun(a, b, c)   \\\n"
"    do {                    \\\n"
"        if (a == 5)         \\\n"
"            do_this(b, c);  \\\n"
"    } while (0)"
msgstr ""
"#define macrofun(a, b, c)   \\\n"
"    do {                    \\\n"
"        if (a == 5)         \\\n"
"            do_this(b, c);  \\\n"
"    } while (0)"

msgid "Things to avoid when using macros:"
msgstr "Во время использования макросов постарайтесь избегать следующего:"

msgid "macros that affect control flow:"
msgstr "макросы, которые влияют на поток управления:"

msgid ""
"#define FOO(x)                  \\\n"
"    do {                        \\\n"
"        if (blah(x) < 0)        \\\n"
"            return -EBUGGERED;  \\\n"
"    } while(0)"
msgstr ""
"#define FOO(x)                  \\\n"
"    do {                        \\\n"
"        if (blah(x) < 0)        \\\n"
"            return -EBUGGERED;  \\\n"
"    } while(0)"

msgid ""
"is a _very_ bad idea.  It looks like a function call but exits the "
"\"calling\" function; don't break the internal parsers of those who will "
"read the code."
msgstr ""
"это _очень_ плохая идея. Он выглядит как вызов функции, но выходит из "
"вызывающей функции; не ломайте внутреннего анализатора у тех, кто "
"прочитает код."

msgid "macros that depend on having a local variable with a magic name:"
msgstr ""
"макросы, которые зависят от наличия локальной переменной с магическим "
"именем:"

msgid "#define FOO(val) bar(index, val)"
msgstr "#define FOO(val) bar(index, val)"

msgid ""
"might look like a good thing, but it's confusing as hell when one reads "
"the code and it's prone to breakage from seemingly innocent changes."
msgstr ""
"могут показаться хорошей идеей, но они сбивают с толку, когда читаешь "
"код, и такой код склонен ломаться от, казалось бы, невинных изменений."

msgid ""
"macros with arguments that are used as l-values: FOO(x) = y; will bite "
"you if somebody e.g. turns FOO into an inline function."
msgstr ""
"макросы с аргументами, которые используются как l-значения: FOO(x) = y; "
"это вам аукнется, если кто-то, например. сделает FOO встроенной функцией."

msgid ""
"forgetting about precedence: macros defining constants using expressions "
"must enclose the expression in parentheses. Beware of similar issues with"
" macros using parameters."
msgstr ""
"потеря приоритета: макросы, определяющие постоянные с использованием "
"выражений, должны заключать выражение в круглые скобки. Остерегайтесь "
"аналогичных проблем с макросами с использованием параметров."

msgid ""
"#define CONSTANT 0x4000\n"
"#define CONSTEXP (CONSTANT | 3)"
msgstr ""
"#define CONSTANT 0x4000\n"
"#define CONSTEXP (CONSTANT | 3)"

msgid ""
"The cpp manual deals with macros exhaustively. The gcc internals manual "
"also covers RTL which is used frequently with assembly language in the "
"kernel."
msgstr ""
"В руководстве cpp подробно рассматриваются макросы. Руководство по "
"внутреннему устройству gcc также рассматривает уровни регистровых передач"
" (RTL), которые часто используются с языком ассемблера в ядре."

msgid "Chapter 13: Printing kernel messages"
msgstr "Глава 13: Вывод сообщений ядра"

msgid ""
"Kernel developers like to be seen as literate. Do mind the spelling of "
"kernel messages to make a good impression. Do not use crippled words like"
" \"dont\"; use \"do not\" or \"don't\" instead.  Make the messages "
"concise, clear, and unambiguous."
msgstr ""
"Разработчики ядра любят выглядеть грамотными. Обращайте внимание на "
"орфографию в сообщениях ядра, чтобы произвести хорошее впечатление. Не "
"используйте искаженные слова типа \"dont\"; вместо этого используйте \"do"
" not\" или \"don't\". Пусть сообщения будут краткими, ясными и "
"недвусмысленными."

msgid "Kernel messages do not have to be terminated with a period."
msgstr "Сообщения ядра не должны заканчиваться точкой."

#, python-format
msgid "Printing numbers in parentheses (%d) adds no value and should be avoided."
msgstr ""
"Вывод номеров в круглых скобках (%d) не повышает их ценность, и его "
"следует избегать."

msgid ""
"There are a number of driver model diagnostic macros in <linux/device.h> "
"which you should use to make sure messages are matched to the right "
"device and driver, and are tagged with the right level:  dev_err(), "
"dev_warn(), dev_info(), and so forth.  For messages that aren't "
"associated with a particular device, <linux/kernel.h> defines pr_debug() "
"and pr_info()."
msgstr ""
"В <linux/device.h> есть несколько макросов для диагностики модели "
"драйвера, которые следует использовать, чтобы убедиться, что сообщения "
"соотнесены с правильным устройством и драйвером и помечены правильным "
"уровнем: dev_err(), dev_warn(), dev_info() и так далее. Для сообщений, не"
" связанных с определенным устройством, <linux/kernel.h> определяет "
"pr_debug() и pr_info()."

msgid ""
"Coming up with good debugging messages can be quite a challenge; and once"
" you have them, they can be a huge help for remote troubleshooting.  Such"
" messages should be compiled out when the DEBUG symbol is not defined "
"(that is, by default they are not included).  When you use dev_dbg() or "
"pr_debug(), that's automatic.  Many subsystems have Kconfig options to "
"turn on -DDEBUG. A related convention uses VERBOSE_DEBUG to add "
"dev_vdbg() messages to the ones already enabled by DEBUG."
msgstr ""
"Придумать хорошие сообщения отладки может быть довольно сложно; и как "
"только у вас будут такие, они могут стать огромным подспорьем для "
"удаленного устранения неполадок. Такие сообщения должны быть "
"скомпилированы, когда символ DEBUG не определен (то есть, по умолчанию "
"они не включены). Если вы используете dev_dbg() или pr_debug(), это "
"сработает автоматически. Во многих подсистемах есть опции Kconfig для "
"включения -DDEBUG. В соответствующем соглашении VERBOSE_DEBUG "
"используется для добавления сообщений dev_vdbg() в сообщения, которые уже"
" включены с помощью DEBUG."

msgid "Chapter 14: Allocating memory"
msgstr "Глава 14: Выделение памяти"

msgid ""
"The kernel provides the following general purpose memory allocators: "
"kmalloc(), kzalloc(), kcalloc(), and vmalloc().  Please refer to the API "
"documentation for further information about them."
msgstr ""
"В ядре поддерживаются следующие распределители памяти широкого "
"применения: kmalloc(), kzalloc(), kcalloc(), and vmalloc().  Для "
"получения дополнительной информации обратитесь к документации по API."

msgid "The preferred form for passing a size of a struct is the following:"
msgstr "Предпочтительна следующая форма передачи размера структуры:"

msgid "p = kmalloc(sizeof(*p), ...);"
msgstr "p = kmalloc(sizeof(*p), ...);"

msgid ""
"The alternative form where struct name is spelled out hurts readability "
"and introduces an opportunity for a bug when the pointer variable type is"
" changed but the corresponding sizeof that is passed to a memory "
"allocator is not."
msgstr ""
"Другая форма, в которой прописывается название структуры, ухудшает "
"читаемость и дает дополнительные возможности для возникновения ошибок при"
" изменении типа переменной указателя, когда соответствующий sizeof, "
"который передается в распределитель ресурсов, не меняется."

msgid ""
"Casting the return value which is a void pointer is redundant. The "
"conversion from void pointer to any other pointer type is guaranteed by "
"the C programming language."
msgstr ""
"Не нужно отбрасывать возвращаемое значение, представляющее собой "
"указатель на объект, тип которого неизвестен. Язык программирования C "
"обеспечивает преобразование из указателя на объект, тип которого "
"неизвестен, на любой другой тип указателя."

msgid "Chapter 15: The inline disease"
msgstr "Глава 15: Болезнь встраивания (inline)"

msgid ""
"There appears to be a common misperception that gcc has a magic \"make me"
" faster\" speedup option called \"inline\". While the use of inlines can "
"be appropriate (for example as a means of replacing macros, see Chapter "
"12), it very often is not. Abundant use of the inline keyword leads to a "
"much bigger kernel, which in turn slows the system as a whole down, due "
"to a bigger icache footprint for the CPU and simply because there is less"
" memory available for the pagecache. Just think about it; a pagecache "
"miss causes a disk seek, which easily takes 5 milliseconds. There are a "
"LOT of cpu cycles that can go into these 5 milliseconds."
msgstr ""
"Похоже, что распространено ошибочное представление о том, что в gcc есть "
"волшебная опция ускорения, называемая встраиванием \"inline\". Хотя "
"использование встроенных строк может быть оправдано (например, как "
"средство замены макросов, см. Главу 12), довольно часто это не так. "
"Избыток ключевого слова inline приводит к увеличению ядра, что в свою "
"очередь, замедляет работу системы в целом из-за большего объема отпечатка"
" icache для процессора и просто потому, что для pagecache доступно  "
"меньше памяти. Просто подумайте: непопадание в pagecache вызывает поиск "
"по диску, который легко занимает 5 миллисекунд. Есть МНОГО циклов "
"процессора, которые могут пройти в эти 5 миллисекунд."

msgid ""
"A reasonable rule of thumb is to not put inline at functions that have "
"more than 3 lines of code in them. An exception to this rule are the "
"cases where a parameter is known to be a compiletime constant, and as a "
"result of this constantness you *know* the compiler will be able to "
"optimize most of your function away at compile time. For a good example "
"of this later case, see the kmalloc() inline function."
msgstr ""
"Общее правило состоит в том, чтобы не вводить встраивание в функции, "
"содержащие больше трех строк кода. Исключением из этого правила являются "
"случаи, когда параметр известен как постоянная времени компиляции, и в "
"результате вы *знаете*, что компилятор сможет оптимизировать большую "
"часть ваших функций во время компиляции. Хороший пример последнего случая"
" -- встроенная функция kmalloc()."

msgid ""
"Often people argue that adding inline to functions that are static and "
"used only once is always a win since there is no space tradeoff. While "
"this is technically correct, gcc is capable of inlining these "
"automatically without help, and the maintenance issue of removing the "
"inline when a second user appears outweighs the potential value of the "
"hint that tells gcc to do something it would have done anyway."
msgstr ""
"Часто утверждают, что беспроигрышным вариантом будет встраивание "
"статических функций, используемых только один раз, поскольку нет "
"компромиссов пространства. Хотя это технически правильно, gcc способен "
"автоматически встраивать их, а проблема удаления встроенного, если "
"появляется второй пользователь, перевешивает потенциальную ценность "
"подсказки для gcc делать что-то, что он сделал бы в любом случае."

msgid "Chapter 16: Function return values and names"
msgstr "Глава 16: Возвращаемые значения и имена функций"

msgid ""
"Functions can return values of many different kinds, and one of the most "
"common is a value indicating whether the function succeeded or failed.  "
"Such a value can be represented as an error-code integer (-Exxx = "
"failure, 0 = success) or a \"succeeded\" boolean (0 = failure, non-zero ="
" success)."
msgstr ""
"Функции могут возвращать значения множества различных типов, и одним из "
"наиболее распространенных является значение, которое указывает, была "
"функция выполнена или нет. Такое значение может быть представлено как "
"целое число с кодом ошибки (-Exxx = сбой, 0 = выполнено) или логическое "
"значение выполнения (0 = сбой, ненулевое значение = выполнено)."

msgid ""
"Mixing up these two sorts of representations is a fertile source of "
"difficult-to-find bugs.  If the C language included a strong distinction "
"between integers and booleans then the compiler would find these mistakes"
" for us... but it doesn't.  To help prevent such bugs, always follow this"
" convention:"
msgstr ""
"Смешение этих двух видов дает богатую пищу для появления сложных для "
"обнаружения ошибок. Если бы в языке C были явные различия между целыми "
"числами и логическими значениями, тогда компилятор нашел бы для нас эти "
"ошибки... но это не так. Чтобы предотвратить такие ошибки, всегда "
"следуйте этому соглашению:"

msgid ""
"If the name of a function is an action or an imperative command,\n"
"the function should return an error-code integer.  If the name\n"
"is a predicate, the function should return a \"succeeded\" boolean."
msgstr ""
"Если имя функции представляет собой действие или команду,\n"
"функция должна возвращать целое число с кодом ошибки.  Если имя функции\n"
"является утверждением, функция должна возвращать логическое значение "
"выполнения."

msgid ""
"For example, \"add work\" is a command, and the add_work() function "
"returns 0 for success or -EBUSY for failure.  In the same way, \"PCI "
"device present\" is a predicate, and the pci_dev_present() function "
"returns 1 if it succeeds in finding a matching device or 0 if it doesn't."
msgstr ""
"Например, \"add work\" (добавить работу) -- это команда, а функция "
"add_work() возвращает 0 в случае выполнения или -EBUSY при сбое. Точно "
"так же \"PCI device present\" (есть PCI-устройство) представляет собой "
"утверждение, а функция pci_dev_present() возвращает 1, если ей удается "
"найти подходящее устройство, или 0, если это не так."

msgid ""
"All EXPORTed functions must respect this convention, and so should all "
"public functions.  Private (static) functions need not, but it is "
"recommended that they do."
msgstr ""
"Все экспортируемые функции (EXPORT) должны подчиняться этому соглашению, "
"то же относится и ко всем доступным функциям. Закрытые (статические) "
"функции не должны подчиняться, но это рекомендуется."

msgid ""
"Functions whose return value is the actual result of a computation, "
"rather than an indication of whether the computation succeeded, are not "
"subject to this rule.  Generally they indicate failure by returning some "
"out-of-range result.  Typical examples would be functions that return "
"pointers; they use NULL or the ERR_PTR mechanism to report failure."
msgstr ""
"Функции, возвращаемое значение которых является фактическим результатом "
"вычисления, а не указанием того, удалось ли выполнить вычисление, не "
"подпадают под это правило. Обычно они указывают на сбой, возвращая некое "
"недопустимое значение. Типичными примерами будут функции, возвращающие "
"указатели; чтобы сообщить об ошибке, они используют NULL или механизм "
"ERR_PTR."

msgid "Chapter 17:  Don't re-invent the kernel macros"
msgstr "Глава 17: Не изобретайте макросы снова"

msgid ""
"The header file include/linux/kernel.h contains a number of macros that "
"you should use, rather than explicitly coding some variant of them "
"yourself. For example, if you need to calculate the length of an array, "
"take advantage of the macro"
msgstr ""
"В файле заголовка include/linux/kernel.h содержатся несколько макросов, "
"которые следует использовать, а не программировать их самостоятельно. "
"Например, если необходимо рассчитать длину массива, воспользуйтесь "
"макросом"

msgid "#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))"
msgstr "#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))"

msgid "Similarly, if you need to calculate the size of some structure member, use"
msgstr ""
"Аналогичным образом, если необходимо рассчитать размер какого-либо "
"элемента структуры, используйте"

msgid "#define FIELD_SIZEOF(t, f) (sizeof(((t*)0)->f))"
msgstr "#define FIELD_SIZEOF(t, f) (sizeof(((t*)0)->f))"

msgid ""
"There are also min() and max() macros that do strict type checking if you"
" need them.  Feel free to peruse that header file to see what else is "
"already defined that you shouldn't reproduce in your code."
msgstr ""
"Есть также макросы min() и max(), которые выполняют строгую проверку "
"типов, если понадобится. Не стесняйтесь ознакомиться с этим файлом "
"заголовка, чтобы узнать, что еще не нужно воспроизводить в своем коде."

msgid "Chapter 18:  Editor modelines and other cruft"
msgstr "Глава 18: Редакторские строки режима (modelines) и прочий хлам"

msgid ""
"Some editors can interpret configuration information embedded in source "
"files, indicated with special markers.  For example, emacs interprets "
"lines marked like this:"
msgstr ""
"Некоторые редакторы могут интерпретировать встроенную в исходные файлы "
"информацию о конфигурации, указанную специальными маркерами. Например, "
"emacs интерпретирует строки, помеченные следующим образом:"

msgid "-*- mode: c -*-"
msgstr "-*- mode: c -*-"

msgid "Or like this:"
msgstr "Или так:"

msgid ""
"/*\n"
"Local Variables:\n"
"compile-command: \"gcc -DMAGIC_DEBUG_FLAG foo.c\"\n"
"End:\n"
"*/"
msgstr ""
"/*\n"
"Local Variables:\n"
"compile-command: \"gcc -DMAGIC_DEBUG_FLAG foo.c\"\n"
"End:\n"
"*/"

msgid "Vim interprets markers that look like this:"
msgstr "Vim интерпретирует маркеры, которые выглядят так:"

msgid "/* vim:set sw=8 noet */"
msgstr "/* vim:set sw=8 noet */"

msgid ""
"Do not include any of these in source files.  People have their own "
"personal editor configurations, and your source files should not override"
" them.  This includes markers for indentation and mode configuration.  "
"People may use their own custom mode, or may have some other magic method"
" for making indentation work correctly."
msgstr ""
"Не включайте их в исходные файлы. У людей есть свои собственные настройки"
" редакторов, и ваши исходные файлы не должны их переопределять. Это "
"относится к маркерам для отступов и конфигурации режима. У других людей "
"могут быть свои собственные режимы или  другие волшебные методы для "
"правильной работы отступов."

msgid "Appendix I: References"
msgstr "Приложение I: Источники"

msgid ""
"`The C Programming Language, Second Edition "
"<https://en.wikipedia.org/wiki/The_C_Programming_Language>`_ by Brian W. "
"Kernighan and Dennis M. Ritchie. |br| Prentice Hall, Inc., 1988. |br| "
"ISBN 0-13-110362-8 (paperback), 0-13-110370-9 (hardback)."
msgstr ""
"Керниган Брайан В., Ричи Деннис М. `Язык программирования Си "
"<https://ru.wikipedia.org/wiki/%D0%AF%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F_%D0%A1%D0%B8_(%D0%BA%D0%BD%D0%B8%D0%B3%D0%B0)>`_."
" |br| Prentice Hall, Inc., 1988. |br| ISBN 0-13-110362-8 (в мягкой "
"обложке), 0-13-110370-9 (в твердом переплете)."

msgid ""
"`The Practice of Programming "
"<https://en.wikipedia.org/wiki/The_Practice_of_Programming>`_ by Brian W."
" Kernighan and Rob Pike. |br| Addison-Wesley, Inc., 1999. |br| ISBN "
"0-201-61586-X."
msgstr ""
"Керниган Брайан В., Пайк Роб. `Практика программирования "
"<https://en.wikipedia.org/wiki/The_Practice_of_Programming>`_. |br| "
"Addison-Wesley, Inc., 1999. |br| ISBN 0-201-61586-X."

msgid ""
"`GNU manuals <http://www.gnu.org/manual/>`_ - where in compliance with "
"K&R and this text - for **cpp**, **gcc**, **gcc internals** and "
"**indent**"
msgstr ""
"`Рекомендации GNU <http://www.gnu.org/manual/>`_ в соответствии с K&R и "
"данным текстом -- для **cpp**, **gcc**, **gcc internals** и **indent**"

msgid ""
"`WG14 International standardization workgroup for the programming "
"language C <http://www.open-std.org/JTC1/SC22/WG14/>`_"
msgstr ""
"`Рабочая группа по международной стандартизации языка программирования C "
"WG14 <http://www.open-std.org/JTC1/SC22/WG14/>`_"

msgid ""
"`Kernel CodingStyle, by greg@kroah.com at OLS 2002 "
"<http://www.kroah.com/linux/talks/ols_2002_kernel_codingstyle_talk/html/>`_"
msgstr ""
"`Стиль программирования ядра, автор greg@kroah.com, презентация на OLS "
"2002 "
"<http://www.kroah.com/linux/talks/ols_2002_kernel_codingstyle_talk/html/>`_"
