
msgid "C Style Guide"
msgstr "Руководство по написанию кода на C"

msgid ""
"We use Git for revision control. The latest development is happening in the "
"default branch (currently ``master``). Our git repository is hosted on "
"GitHub, and can be checked out with ``git clone "
"git://github.com/tarantool/tarantool.git`` (anonymous read-only access)."
msgstr ""
"Для управления версиями мы используем Git. Разработки ведутся в ветке, "
"используемой по умолчанию (сейчас ``master``). Наш Git-репозиторий находится"
" на GitHub, его можно выгрузить с помощью ``git clone "
"git://github.com/tarantool/tarantool.git`` (анонимный пользователь получит "
"доступ только для чтения)."

msgid ""
"If you have any questions about Tarantool internals, please post them on "
"`StackOverflow <https://stackoverflow.com/questions/tagged/tarantool>`_ or "
"ask Tarantool developers directly in `telegram "
"<http://telegram.me/tarantool>`_."
msgstr ""
"Если у вас есть вопросы о внутреннем устройстве Tarantool, задайте их на "
"`StackOverflow <https://stackoverflow.com/questions/tagged/tarantool>`_ или "
"напрямую разработчикам Tarantool в `Telegram "
"<http://telegram.me/tarantool>`_."

msgid "**General guidelines**"
msgstr "**Общие рекомендации**"

msgid ""
"The project's coding style is inspired by the `Linux kernel coding style "
"<https://www.kernel.org/doc/html/v4.10/process/coding-style.html>`_."
msgstr ""
"Стиль разработки проекта основан на `стиле программирования ядра Linux "
"<https://www.kernel.org/doc/html/v4.10/process/coding-style.html>`_."

msgid ""
"However, we have some additional guidelines, either unique to Tarantool or "
"deviating from the Kernel guidelines. Below we rewrite the Linux kernel "
"coding style according to the Tarantool's style features."
msgstr ""
"Кроме того, мы даем дополнительные рекомендации, которые либо специфичны для"
" Tarantool, либо отличаются от рекомендаций по программированию ядра Linux. "
"Ниже приведен стиль программирования ядра Linux, переработанный с учетом "
"особенностей разработки Tarantool."

msgid "Tarantool coding style"
msgstr "Стиль программирования Tarantool"

msgid ""
"This is a short document describing the preferred coding style for the "
"Tarantool developers and contributors. We **insist** on following these "
"rules in order to make our code consistent and understandable to any "
"developer."
msgstr ""
"В этом документе описан приоритетный стиль программирования Tarantool для "
"разработчиков и участников сообщества. Мы **настаиваем** на соблюдении этих "
"правил, чтобы наш код был последовательным и понятным любому разработчику."

msgid "Chapter 1: Indentation"
msgstr "Глава 1: Отступы"

msgid ""
"Tabs are 8 characters (8-width tabs, not 8 whitespaces), and thus "
"indentations are also 8 characters. There are heretic movements that try to "
"make indentations 4 (or even 2!) characters deep, and that is akin to trying"
" to define the value of PI to be 3."
msgstr ""
"Табуляция составляет 8 символов (8 символов табуляции, а не 8 пробелов), то "
"есть отступы будут также составлять 8 символов. Появляются отступники, "
"которые призывают делать отступы в 4 (или даже 2!) символа, а это сродни "
"попытке округлить число Пи до 3."

msgid ""
"Rationale: The whole idea behind indentation is to clearly define where a "
"block of control starts and ends. Especially when you've been looking at "
"your screen for 20 straight hours, you'll find it a lot easier to see how "
"the indentation works if you have large indentations."
msgstr ""
"Обоснование: Основная идея отступов состоит в том, чтобы показать, где "
"начинается и заканчивается логический блок кода. Особенно если вы смотрите "
"на один и тот же код в течение 20 часов, трудно не заметить пользу больших "
"отступов."

msgid ""
"Now, some people will claim that having 8-character indentations makes the "
"code move too far to the right, and makes it hard to read on a 80-character "
"terminal screen. The answer to that is that if you need more than 3 levels "
"of indentation, you're screwed anyway, and should fix your program."
msgstr ""
"Некоторые могут возразить, что отступ в 8 символов делает код слишком "
"широким, особенно на 80-знаковой строке терминала. Ответ: Если вам "
"понадобилось более трех уровней отступа, вы что-то делаете неправильно, и "
"вам следует переписать этот участок."

msgid ""
"8-char indents make things easier to read and have the added benefit of "
"warning you when you're nesting your functions too deep. Heed that warning."
msgstr ""
"Отступы в 8 символов облегчают чтение кода. Кроме того, по ним можно понять,"
" когда у вас становится слишком много вложенных функций."

msgid ""
"The preferred way to ease multiple indentation levels in a switch statement "
"is to align the ``switch`` and its subordinate ``case`` labels in the same "
"column instead of ``double-indenting`` the ``case`` labels. E.g.:"
msgstr ""
"Лучше всего упростить несколько уровней отступов в операторе switch, "
"выравнивая ``switch`` и его вспомогательные метки ``case`` в одном столбце "
"вместо того, чтобы использовать двойные отступы для меток ``case``, "
"например:"

msgid ""
"switch (suffix) {\n"
"case 'G':\n"
"case 'g':\n"
"  mem <<= 30;\n"
"  break;\n"
"case 'M':\n"
"case 'm':\n"
"  mem <<= 20;\n"
"  break;\n"
"case 'K':\n"
"case 'k':\n"
"  mem <<= 10;\n"
"  /* fall through */\n"
"default:\n"
"  break;\n"
"}"
msgstr ""
"switch (suffix) {\n"
"case 'G':\n"
"case 'g':\n"
"  mem <<= 30;\n"
"  break;\n"
"case 'M':\n"
"case 'm':\n"
"  mem <<= 20;\n"
"  break;\n"
"case 'K':\n"
"case 'k':\n"
"  mem <<= 10;\n"
"  /* fall through */\n"
"default:\n"
"  break;\n"
"}"

msgid ""
"Don't put multiple statements on a single line unless you have something to "
"hide:"
msgstr ""
"Не размещайте несколько операторов на одной строке, если вам нечего "
"скрывать:"

msgid ""
"if (condition) do_this;\n"
"  do_something_everytime;"
msgstr ""
"if (condition) do_this;\n"
"  do_something_everytime;"

msgid ""
"Don't put multiple assignments on a single line either. Avoid tricky "
"expressions."
msgstr ""
"И не размещайте несколько операторов присваивания на одной строке. Избегайте"
" сложных выражений."

msgid ""
"Outside of comments and documentation, spaces are never used for "
"indentation, and the above example is deliberately broken."
msgstr ""
"Пробелы используются только в комментариях и документации, но никогда — для "
"отступов, и приведенный выше пример сломан намеренно."

msgid "Get a decent editor and don't leave whitespace at the end of lines."
msgstr "Найдите достойный редактор и не оставляйте пробелы в конце строки."

msgid "Chapter 2: Breaking long lines and strings"
msgstr "Глава 2: Разрыв длинных строк"

msgid ""
"Coding style is all about readability and maintainability using commonly "
"available tools."
msgstr ""
"Смысл стиля программирования заключается в читаемости и удобстве "
"сопровождения с использованием общедоступных средств."

msgid ""
"The limit on the length of lines is 80 columns and this is a strongly "
"preferred limit. As for comments, the same limit of 80 columns is applied."
msgstr ""
"Длина строк ограничена 80 символами, и этому следует уделить особое "
"внимание. Для комментариев установлен тот же лимит в 80 символов."

msgid ""
"Statements longer than 80 columns will be broken into sensible chunks, "
"unless exceeding 80 columns significantly increases readability and does not"
" hide information. Descendants are always substantially shorter than the "
"parent and are placed substantially to the right. The same applies to "
"function headers with a long argument list."
msgstr ""
"Операторы длиной более 80 символов будут разбиты на логические части. Можно "
"сделать исключение, если это значительно повысит читаемость и не скроет "
"информацию. Последующие части значительно короче основной и сильно смещены "
"вправо. То же относится к заголовкам функций с длинным списком аргументов."

msgid "Chapter 3: Placing Braces and Spaces"
msgstr "Глава 3: Фигурные скобки и пробелы"

msgid ""
"The other issue that always comes up in C styling is the placement of "
"braces. Unlike the indent size, there are few technical reasons to choose "
"one placement strategy over the other, but the preferred way, as shown to us"
" by the prophets Kernighan and Ritchie, is to put the opening brace last on "
"the line, and put the closing brace first, thus:"
msgstr ""
"Другая проблемой, которая всегда возникает в программировании на C, — "
"размещение фигурных скобок. В отличие от отступов, есть несколько "
"технических обоснований, чтобы выбрать один способ, а не другой, но всё же "
"предпочтительно, как нам показали великие Керниган и Ричи, поместить "
"открывающую скобку в конце строки, а закрывающую в начале новой строки:"

msgid ""
"if (x is true) {\n"
"  we do y\n"
"}"
msgstr ""
"if (x is true) {\n"
"  we do y\n"
"}"

msgid ""
"This applies to all non-function statement blocks (if, switch, for, while, "
"do). E.g.:"
msgstr ""
"Это применимо ко всем блокам операторов без функций (if, switch, for, while,"
" do), например:"

msgid ""
"switch (action) {\n"
"case KOBJ_ADD:\n"
"  return \"add\";\n"
"case KOBJ_REMOVE:\n"
"  return \"remove\";\n"
"case KOBJ_CHANGE:\n"
"  return \"change\";\n"
"default:\n"
"  return NULL;\n"
"}"
msgstr ""
"switch (action) {\n"
"case KOBJ_ADD:\n"
"  return \"add\";\n"
"case KOBJ_REMOVE:\n"
"  return \"remove\";\n"
"case KOBJ_CHANGE:\n"
"  return \"change\";\n"
"default:\n"
"  return NULL;\n"
"}"

msgid ""
"However, there is one special case, namely functions: they have the opening "
"brace at the beginning of the next line, thus:"
msgstr ""
"И только в особенных случаях, а именно для функций, открывающая скобка "
"размещается в начале следующей строки:"

msgid ""
"int\n"
"function(int x)\n"
"{\n"
"  body of function\n"
"}"
msgstr ""
"int\n"
"function(int x)\n"
"{\n"
"  body of function\n"
"}"

msgid ""
"Heretic people all over the world have claimed that this inconsistency is "
"... well ... inconsistent, but all right-thinking people know that (a) K&R "
"are **right** and (b) K&R are right. Besides, functions are special anyway "
"(you can't nest them in C)."
msgstr ""
"Отступники по всему миру утверждали, что такая несогласованность ... ну ... "
"несогласованна, но все здравомыслящие люди знают: (a) K&R **правы**, (б) K&R"
" правы. Кроме того, функции в любом случае будут особенными (в C их нельзя "
"вложить)."

msgid ""
"Note that the closing brace is empty on a line of its own, **except** in the"
" cases where it is followed by a continuation of the same statement, i.e. a "
"``while`` in a do-statement or an ``else`` in an if-statement, like this:"
msgstr ""
"Обратите внимание, что за закрывающей скобкой на отдельной строке ничего "
"нет; **кроме** тех случаев, когда за ней следует продолжение того же "
"оператора, то есть ``while`` в do-операторе или ``else`` в if-операторе, "
"например:"

msgid ""
"do {\n"
"  body of do-loop\n"
"} while (condition);"
msgstr ""
"do {\n"
"  body of do-loop\n"
"} while (condition);"

msgid "and"
msgstr "и"

msgid ""
"if (x == y) {\n"
"  ..\n"
"} else if (x > y) {\n"
"  ...\n"
"} else {\n"
"  ....\n"
"}"
msgstr ""
"if (x == y) {\n"
"  ..\n"
"} else if (x > y) {\n"
"  ...\n"
"} else {\n"
"  ....\n"
"}"

msgid "Rationale: K&R."
msgstr "Обоснование: K&R."

msgid ""
"Also, note that this brace-placement also minimizes the number of empty (or "
"almost empty) lines, without any loss of readability. Thus, as the supply of"
" new-lines on your screen is not a renewable resource (think 25-line "
"terminal screens here), you have more empty lines to put comments on."
msgstr ""
"Кроме того, обратите внимание, что такое расположение скобок также сводит к "
"минимуму количество пустых (или почти пустых) строк без потери читаемости. "
"Таким образом, поскольку новые строки на экране — это не возобновляемый "
"ресурс (вспомним о 25-строчных экранах терминала), у вас будет больше пустых"
" строк для комментариев."

msgid "Do not unnecessarily use braces where a single statement will do."
msgstr ""
"Не используйте лишние фигурные скобки, если нужен всего один оператор."

msgid ""
"if (condition)\n"
"  action();"
msgstr ""
"if (condition)\n"
"  action();"

msgid ""
"if (condition)\n"
"  do_this();\n"
"else\n"
"  do_that();"
msgstr ""
"if (condition)\n"
"  do_this();\n"
"else\n"
"  do_that();"

msgid ""
"This does not apply if only one branch of a conditional statement is a "
"single statement; in the latter case use braces in both branches:"
msgstr ""
"Это не применимо, если только одна ветка условного оператора — это отдельный"
" оператор. В последнем случае используйте фигурные скобки в обеих ветках:"

msgid ""
"if (condition) {\n"
"  do_this();\n"
"  do_that();\n"
"} else {\n"
"  otherwise();\n"
"}"
msgstr ""
"if (condition) {\n"
"  do_this();\n"
"  do_that();\n"
"} else {\n"
"  otherwise();\n"
"}"

msgid "Chapter 3.1: Spaces"
msgstr "Глава 3.1: Пробелы"

msgid ""
"Tarantool style for use of spaces depends (mostly) on function-versus-"
"keyword usage. Use a space after (most) keywords. The notable exceptions are"
" ``sizeof``, ``typeof``, ``alignof``, and ``__attribute__``, which look "
"somewhat like functions (and are usually used with parentheses, although "
"they are not required in the language, as in: ``sizeof info`` after ``struct"
" fileinfo info;`` is declared)."
msgstr ""
"В том, что касается пробелов, стиль программирования Tarantool зависит (в "
"основном) от использования функции или ключевого слова. Используйте пробел "
"после (большинства) ключевых слов. Значимые исключения: ``sizeof``, "
"``typeof``, ``alignof`` и ``__attribute__``, — которые похожи на функции (и "
"обычно используются с круглыми скобками, хотя они и не обязательны, как в "
"объявлении ``sizeof info`` после ``struct fileinfo info;``)."

msgid "So use a space after these keywords:"
msgstr "Итак, вставляйте пробелы после этих ключевых слов:"

msgid "if, switch, case, for, do, while"
msgstr "if, switch, case, for, do, while"

msgid ""
"but not with ``sizeof``, ``typeof``, ``alignof``, or ``__attribute__``. "
"E.g.,"
msgstr ""
"но не после ``sizeof``, ``typeof``, ``alignof`` или ``__attribute__``. "
"Например:"

msgid "s = sizeof(struct file);"
msgstr "s = sizeof(struct file);"

msgid ""
"Do not add spaces around (inside) parenthesized expressions. This example is"
" **bad**:"
msgstr ""
"Не добавляйте пробелы вокруг (внутри) выражений в круглых скобках. Этот "
"пример **неправильный**:"

msgid "s = sizeof( struct file );"
msgstr "s = sizeof( struct file );"

msgid ""
"When declaring pointer data or a function that returns a pointer type, the "
"preferred use of ``*`` is adjacent to the data name or function name and not"
" adjacent to the type name. Examples:"
msgstr ""
"Объявляя данных типа указателя или функцию, которая возвращает тип "
"указателя, лучше использовать ``*`` рядом с именем данных или именем "
"функции, а не рядом с именем типа. Примеры:"

msgid ""
"char *linux_banner;\n"
"unsigned long long memparse(char *ptr, char **retptr);\n"
"char *match_strdup(substring_t *s);"
msgstr ""
"char *linux_banner;\n"
"unsigned long long memparse(char *ptr, char **retptr);\n"
"char *match_strdup(substring_t *s);"

msgid ""
"Use one space around (on each side of) most binary and ternary operators, "
"such as any of these::"
msgstr ""
"Добавляйте по одному пробелу вокруг (с каждой стороны) большинства знаков "
"двухместных и трехместных операций, например, любое из следующих::"

msgid "=  +  -  <  >  *  /  %  |  &  ^  <=  >=  ==  !=  ?  :"
msgstr "=  +  -  <  >  *  /  %  |  &  ^  <=  >=  ==  !=  ?  :"

msgid "but no space after unary operators::"
msgstr "но не добавляйте пробелы после знаков одноместных операций::"

msgid "&  *  +  -  ~  !  sizeof  typeof  alignof  __attribute__  defined"
msgstr "&  *  +  -  ~  !  sizeof  typeof  alignof  __attribute__  defined"

msgid "no space before the postfix increment & decrement unary operators::"
msgstr ""
"не нужны пробелы перед знаками одноместных операций увеличения или "
"уменьшения постфикса::"

msgid "++  --"
msgstr "++  --"

msgid "no space after the prefix increment & decrement unary operators::"
msgstr ""
"не нужны пробелы после знаков одноместных операций увеличения или уменьшения"
" префикса::"

msgid "and no space around the ``.`` and ``->`` structure member operators."
msgstr "и не нужны пробелы вокруг знаков элементов структуры ``.`` и ``->``."

msgid ""
"Do not split a cast operator from its argument with a whitespace, e.g. "
"``(ssize_t)inj->iparam``."
msgstr ""
"Не отделяйте оператор приведения от аргумента пробелом, например "
"``(ssize_t)inj->iparam``."

msgid ""
"Do not leave trailing whitespace at the ends of lines. Some editors with "
"``smart`` indentation will insert whitespace at the beginning of new lines "
"as appropriate, so you can start typing the next line of code right away. "
"However, some such editors do not remove the whitespace if you end up not "
"putting a line of code there, such as if you leave a blank line. As a "
"result, you end up with lines containing trailing whitespace."
msgstr ""
"Не оставляйте пробелы на концах строк. Некоторые редакторы с ``smart`` "
"отступом вставляют пробелы в начале новых строк, поэтому вы можете сразу "
"ввести следующую строку кода. Однако некоторые такие редакторы не удаляют "
"пробелы, если вы не пишете там код, например, если вы оставите пустую "
"строку. В результате имеем строки с пробелами в конце."

msgid ""
"Git will warn you about patches that introduce trailing whitespace, and can "
"optionally strip the trailing whitespace for you; however, if applying a "
"series of patches, this may make later patches in the series fail by "
"changing their context lines."
msgstr ""
"Git предупредит, если патчи содержат пробелы в конце строк, и может по "
"желанию удалить пробелы за вас; однако, в серии патчей, это может привести к"
" тому, что последующие патчи в серии не применятся, поскольку изменены "
"контекстные строки."

msgid "Chapter 4: Naming"
msgstr "Глава 4: Именование"

msgid ""
"C is a Spartan language, and so should your naming be. Unlike Modula-2 and "
"Pascal programmers, C programmers do not use cute names like "
"ThisVariableIsATemporaryCounter. A C programmer would call that variable "
"``tmp``, which is much easier to write, and not the least more difficult to "
"understand."
msgstr ""
"C — это спартанский язык, и именование должно быть спартанским. В отличие от"
" разработчиков на Modula-2 и Pascal, разработчики на языке C не используют "
"забавные имена, такие как ThisVariableIsATemporaryCounter. Разработчик на "
"языке C назвал бы такую переменную ``tmp``, что намного легче написать и не "
"сложнее понять."

msgid ""
"HOWEVER, while mixed-case names are frowned upon, descriptive names for "
"global variables are a must. To call a global function ``foo`` is a shooting"
" offense."
msgstr ""
"ОДНАКО, хотя на имена со смешанным регистром смотрят неодобрительно, "
"обязательным требованием будут описательные имена глобальных переменных. "
"Назвать глобальную функцию ``foo`` — это оскорбление."

msgid ""
"GLOBAL variables (to be used only if you **really** need them) need to have "
"descriptive names, as do global functions. If you have a function that "
"counts the number of active users, you should call that "
"``count_active_users()`` or similar, you should **not** call it "
"``cntusr()``."
msgstr ""
"У ГЛОБАЛЬНЫХ переменных (которые надо использовать, только если без них "
"**нельзя** обойтись) должны быть описательные имена, равно как и у "
"глобальных функций. Если у вас есть функция, которая подсчитывает количество"
" активных пользователей, нужно назвать ее ``count_active_users()`` или как-"
"то похоже, **не** стоит называть ее ``cntusr()``."

msgid ""
"Encoding the type of a function into the name (so-called Hungarian notation)"
" is brain damaged - the compiler knows the types anyway and can check those,"
" and it only confuses the programmer. No wonder MicroSoft makes buggy "
"programs."
msgstr ""
"Кодирование типа функции в названии (так называемая венгерская нотация) — "
"это признак плохого тона, поскольку компилятор в любом случае знает типы и "
"может их проверять, и это только путает программиста. Неудивительно, что "
"MicroSoft делает глючные программы."

msgid ""
"LOCAL variable names should be short, and to the point. If you have some "
"random integer loop counter, it should probably be called ``i``. Calling it "
"``loop_counter`` is non-productive, if there is no chance of it being "
"misunderstood. Similarly, ``tmp`` can be just about any type of variable "
"that is used to hold a temporary value."
msgstr ""
"Имена ЛОКАЛЬНЫХ переменных должны быть короткими и точными. Если у вас есть "
"счетчик случайных целых чисел, его следует называть ``i``. Назвать его "
"``loop_counter`` непродуктивно, если нет никаких шансов, что его перепутают."
" Аналогично ``tmp`` может быть практически любой переменной, которая "
"используется для хранения временного значения."

msgid ""
"If you are afraid to mix up your local variable names, you have another "
"problem, which is called the function-growth-hormone-imbalance syndrome. See"
" chapter 6 (Functions)."
msgstr ""
"Если вы боитесь перепутать имена своих локальных переменных, у вас другая "
"проблема, которая называется синдромом дисбаланса гормона роста функций. См."
" Главу 6 (Функции)."

msgid "For function naming we have a convention is to use:"
msgstr "Для именования функций у нас есть такое правило:"

msgid ""
"``new``/``delete`` for functions which allocate + initialize and destroy + "
"deallocate an object,"
msgstr ""
"``new``/``delete`` для функций, которые выделяют + инициализируют и удаляют "
"+ освобождают объект,"

msgid ""
"``create``/``destroy`` for functions which initialize/destroy an object but "
"do not handle memory management,"
msgstr ""
"``create``/``destroy`` для функций, которые инициализируют/удаляют объект, "
"но не занимаются управлением памятью,"

msgid ""
"``init``/``free`` for functions which initialize/destroy libraries and "
"subsystems."
msgstr ""
"``init``/``free`` для функций, которые инициализируют/удаляют библиотеки и "
"подсистемы."

msgid "Chapter 5: Typedefs"
msgstr "Глава 5: Директива Typedef"

msgid ""
"Please don't use things like ``vps_t``. It's a **mistake** to use typedef "
"for structures and pointers. When you see a"
msgstr ""
"Не используйте что-то вроде ``vps_t``. Будет **ошибкой** использовать "
"typedef для определения структур и указателей. Если вы видите в исходном "
"коде"

msgid "vps_t a;"
msgstr "vps_t a;"

msgid "in the source, what does it mean? In contrast, if it says"
msgstr "что это означает? И наоборот, если говорится"

msgid "struct virtual_container *a;"
msgstr "struct virtual_container *a;"

msgid "you can actually tell what ``a`` is."
msgstr "можно действительно понять, что такое ``a``."

msgid ""
"Lots of people think that typedefs ``help readability``. Not so. They are "
"useful only for:"
msgstr ""
"Многие думают, что typedef ``способствует читаемости``. Это не так. Эту "
"директиву нужно использовать для:"

msgid ""
"Totally opaque objects (where the typedef is actively used to **hide** what "
"the object is)."
msgstr ""
"Непрозрачных объектов (где typedef активно используется для **сокрытия** "
"объекта)."

msgid ""
"Example: ``pte_t`` etc. opaque objects that you can only access using the "
"proper accessor functions."
msgstr ""
"Пример: ``pte_t`` и другие непрозрачные объекты, доступ к которым можно "
"получить с помощью соответствующих функций доступа."

msgid ""
"Opaqueness and ``accessor functions`` are not good in themselves. The reason"
" we have them for things like pte_t etc. is that there really is absolutely "
"**zero** portably accessible information there."
msgstr ""
"Непрозрачность и ``функции доступа`` сами по себе не слишком хороши. Мы "
"используем их для pte_t и т. п., потому что на самом деле там **нет** "
"никакой информации для скачивания."

msgid ""
"Clear integer types, where the abstraction **helps** avoid confusion whether"
" it is ``int`` or ``long``."
msgstr ""
"Явные целочисленные типы, где абстракция **помогает** не перепутать, ``int``"
" это или ``long``."

msgid ""
"u8/u16/u32 are perfectly fine typedefs, although they fit into point 4 "
"better than here."
msgstr ""
"u8/u16/u32 — вполне нормальные typedef, хотя они больше подходят для пункта "
"4."

msgid ""
"Again - there needs to be a **reason** for this. If something is ``unsigned "
"long``, then there's no reason to do typedef unsigned long myflags_t;"
msgstr ""
"Опять же — для этого должна быть **причина**. Если есть \"unsigned long\", "
"нет причины вводить typedef unsigned long myflags_t;"

msgid ""
"but if there is a clear reason for why it under certain circumstances might "
"be an ``unsigned int`` and under other configurations might be ``unsigned "
"long``, then by all means go ahead and use a typedef."
msgstr ""
"но если есть четкая причина, почему при определенных обстоятельствах может "
"быть ``unsigned int``, а в других случаях может быть ``unsigned long``, то "
"на здоровье — используйте typedef."

msgid ""
"When you use sparse to literally create a **new** type for type-checking."
msgstr ""
"Когда вы используете разрыв, чтобы буквально создать **новый** тип для "
"проверки типов."

msgid ""
"New types which are identical to standard C99 types, in certain exceptional "
"circumstances."
msgstr ""
"Новые типы, идентичные стандартным типам C99, в определенных исключительных "
"обстоятельствах."

msgid ""
"Although it would only take a short amount of time for the eyes and brain to"
" become accustomed to the standard types like ``uint32_t``, some people "
"object to their use anyway."
msgstr ""
"Хотя глазам и мозгу нужно лишь короткое время, чтобы привыкнуть к "
"стандартным типам, например ``uint32_t``, некоторые в любом случае возражают"
" против их использования."

msgid ""
"When editing existing code which already uses one or the other set of types,"
" you should conform to the existing choices in that code."
msgstr ""
"При редактировании существующего кода, в котором уже используется один или "
"другой набор типов, следует придерживаться выбранного типа."

msgid ""
"Maybe there are other cases too, but the rule should basically be to NEVER "
"EVER use a typedef unless you can clearly match one of those rules."
msgstr ""
"Возможно, есть и другие случаи, но основное правило состоит в следующем: "
"НИКОГДА НЕ используйте typedef, если вы не соблюдаете одно из этих правил."

msgid ""
"In general, a pointer, or a struct that has elements that can reasonably be "
"directly accessed should **never** be a typedef."
msgstr ""
"В общем, указатель или структура, содержащие элементы, к которым можно "
"получить прямой доступ, **никогда** не должны быть typedef."

msgid "Chapter 6: Functions"
msgstr "Глава 6: Функции"

msgid ""
"Functions should be short and sweet, and do just one thing. They should fit "
"on one or two screenfuls of text (the ISO/ANSI screen size is 80x24, as we "
"all know), and do one thing and do that well."
msgstr ""
"Функции должны быть короткими и приятными, и выполнять только одно действие."
" Они должны помещаться на одном или двух экранах текста (размер экрана "
"ISO/ANSI 80x24, как мы все знаем) и выполнять одно действие, но делать это "
"хорошо."

msgid ""
"The maximum length of a function is inversely proportional to the complexity"
" and indentation level of that function. So, if you have a conceptually "
"simple function that is just one long (but simple) case-statement, where you"
" have to do lots of small things for a lot of different cases, it's OK to "
"have a longer function."
msgstr ""
"Максимальная длина функции обратно пропорциональна сложности функции и "
"уровню отступов. Итак, если у вас есть концептуально простая функция, "
"которая представляет собой лишь один длинный (но простой) оператор вариант "
"case, где вам нужно делать много мелочей для множества разных случаев, "
"длинная функция — это нормально."

msgid ""
"However, if you have a complex function, and you suspect that a less-than-"
"gifted first-year high-school student might not even understand what the "
"function is all about, you should adhere to the maximum limits all the more "
"closely. Use helper functions with descriptive names (you can ask the "
"compiler to in-line them if you think it's performance-critical, and it will"
" probably do a better job of it than you would have done)."
msgstr ""
"Однако, если у вас есть сложная функция, и вы подозреваете, что не слишком "
"одаренный старшеклассник может даже не понять, о чем эта функция, следует "
"придерживаться ограничений. Используйте вспомогательные функции с "
"описательными именами (можно попросить компилятор встроить их, если "
"считаете, что это критически важно для производительности, и он, вероятно, "
"справится лучше)."

msgid ""
"Another measure of the function is the number of local variables. They "
"shouldn't exceed 5-10, or you're doing something wrong. Re-think the "
"function, and split it into smaller pieces. A human brain can generally "
"easily keep track of about 7 different things, anything more and it gets "
"confused. You know you're brilliant, but maybe you'd like to understand what"
" you did 2 weeks from now."
msgstr ""
"Другим критерием функции является количество локальных переменных. Их не "
"должно быть больше 5-10, или вы делаете что-то неправильно. Продумайте "
"функцию заново и разбейте ее на более мелкие части. Человеческий мозг обычно"
" легко отслеживает около 7 разных вещей, а больше — и он уже запутается. Вы "
"знаете, что сейчас вы гений, но, возможно, через пару недель вам захочется "
"понять, что именно вы делали."

msgid ""
"In function prototypes, include parameter names with their data types. "
"Although this is not required by the C language, it is preferred in "
"Tarantool because it is a simple way to add valuable information for the "
"reader."
msgstr ""
"В прототипах функций включайте имена параметров с типами данных. Хотя для "
"языка C это и не требуется, но рекомендуется для Tarantool, потому что это "
"простой способ добавить ценную информацию для читателя."

msgid ""
"Note that we place the function return type on the line before the name and "
"signature."
msgstr ""
"Обратите внимание, что тип возвращаемого значения функции располагается "
"перед именем и сигнатурой функции."

msgid "Chapter 7: Centralized exiting of functions"
msgstr "Глава 7: Централизованный выход из функции"

msgid ""
"Albeit deprecated by some people, the equivalent of the goto statement is "
"used frequently by compilers in form of the unconditional jump instruction."
msgstr ""
"Хотя некоторые объявили аналог оператора goto устаревшим, его часто "
"используют компиляторы в виде инструкции безусловной передачи управления."

msgid ""
"The goto statement comes in handy when a function exits from multiple "
"locations and some common work such as cleanup has to be done. If there is "
"no cleanup needed then just return directly."
msgstr ""
"Оператор goto пригодится, когда функция производит выход из нескольких мест "
"и необходимо выполнить какие-то общие действия, такие как очистка. Если "
"очистка не нужна, пусть функция возвращается напрямую."

msgid ""
"Choose label names which say what the goto does or why the goto exists. An "
"example of a good name could be ``out_free_buffer:`` if the goto frees "
"``buffer``. Avoid using GW-BASIC names like ``err1:`` and ``err2:``, as you "
"would have to renumber them if you ever add or remove exit paths, and they "
"make correctness difficult to verify anyway."
msgstr ""
"Выбирайте имена меток, которые объясняют, что делает goto или почему. Пример"
" хорошего имени: ``out_free_buffer:``, если goto освобождает ``буфер``. "
"Избегайте таких имен из GW-BASIC, как ``err1:`` и ``err2:``, поскольку вам "
"придется перенумеровать их, если вы будете добавлять или удалять пути "
"выхода, и в любом случае они затрудняют проверку."

msgid "The rationale for using gotos is:"
msgstr "Обоснование использования goto:"

msgid "unconditional statements are easier to understand and follow"
msgstr "безусловные операторы легче понять и выполнять"

msgid "nesting is reduced"
msgstr "уменьшается глубина вложения"

msgid ""
"errors by not updating individual exit points when making modifications are "
"prevented"
msgstr ""
"предотвращаются ошибки по причине отсутствия обновления отдельных точек "
"выхода при внесении изменений"

msgid "saves the compiler work to optimize redundant code away ;)"
msgstr ""
"уменьшает объем работы компилятора для оптимизации избыточного кода ;)"

msgid ""
"int\n"
"fun(int a)\n"
"{\n"
"  int result = 0;\n"
"  char *buffer;\n"
"\n"
"  buffer = kmalloc(SIZE, GFP_KERNEL);\n"
"  if (!buffer)\n"
"    return -ENOMEM;\n"
"\n"
"  if (condition1) {\n"
"    while (loop1) {\n"
"      ...\n"
"    }\n"
"    result = 1;\n"
"    goto out_free_buffer;\n"
"  }\n"
"  ...\n"
"out_free_buffer:\n"
"  kfree(buffer);\n"
"  return result;\n"
"}"
msgstr ""
"int\n"
"fun(int a)\n"
"{\n"
"  int result = 0;\n"
"  char *buffer;\n"
"\n"
"  buffer = kmalloc(SIZE, GFP_KERNEL);\n"
"  if (!buffer)\n"
"    return -ENOMEM;\n"
"\n"
"  if (condition1) {\n"
"    while (loop1) {\n"
"      ...\n"
"    }\n"
"    result = 1;\n"
"    goto out_free_buffer;\n"
"  }\n"
"  ...\n"
"out_free_buffer:\n"
"  kfree(buffer);\n"
"  return result;\n"
"}"

msgid ""
"A common type of bug to be aware of is ``one err bugs`` which look like "
"this:"
msgstr ""
"Распространенный тип ошибок, о котором следует помнить, — ``однократное "
"использование err``, что выглядит так:"

msgid ""
"err:\n"
"  kfree(foo->bar);\n"
"  kfree(foo);\n"
"  return ret;"
msgstr ""
"err:\n"
"  kfree(foo->bar);\n"
"  kfree(foo);\n"
"  return ret;"

msgid ""
"The bug in this code is that on some exit paths ``foo`` is NULL. Normally "
"the fix for this is to split it up into two error labels ``err_free_bar:`` "
"and ``err_free_foo:``:"
msgstr ""
"Ошибка в этом коде заключается в том, что на некоторых путях выхода ``foo`` "
"принимает значение NULL. Обычно это можно исправить разделением ошибки на "
"две метки ``err_free_bar:`` и ``err_free_foo:``:"

msgid ""
"err_free_bar:\n"
" kfree(foo->bar);\n"
"err_free_foo:\n"
" kfree(foo);\n"
" return ret;"
msgstr ""
"err_free_bar:\n"
" kfree(foo->bar);\n"
"err_free_foo:\n"
" kfree(foo);\n"
" return ret;"

msgid "Ideally you should simulate errors to test all exit paths."
msgstr ""
"В идеале следует моделировать ошибки, чтобы проверить все пути выхода."

msgid "Chapter 8: Commenting"
msgstr "Глава 8: Комментирование"

msgid ""
"Comments are good, but there is also a danger of over-commenting. NEVER try "
"to explain HOW your code works in a comment: it's much better to write the "
"code so that the **working** is obvious, and it's a waste of time to explain"
" badly written code."
msgstr ""
"Комментарии полезны, но есть и опасность чрезмерного комментирования. "
"НИКОГДА не пытайтесь объяснить в комментарии, КАК работает ваш код: гораздо "
"лучше написать код так, чтобы **принцип работы** был очевиден, а объяснять "
"плохо написанный код — это пустая трата времени."

msgid ""
"Generally, you want your comments to tell WHAT your code does, not HOW. "
"Also, try to avoid putting comments inside a function body: if the function "
"is so complex that you need to separately comment parts of it, you should "
"probably go back to chapter 6 for a while. You can make small comments to "
"note or warn about something particularly clever (or ugly), but try to avoid"
" excess. Instead, put the comments at the head of the function, telling "
"people what it does, and possibly WHY it does it."
msgstr ""
"Как правило, желательно, чтобы комментарии поясняли, ЧТО делает ваш код, а "
"не КАК. Кроме того, постарайтесь не размещать комментарии внутри тела "
"функции: если функция настолько сложна, что нужно отдельно комментировать ее"
" части, скорее всего, вам надо вернуться к главе 6. Можно давать небольшие "
"комментарии, чтобы отметить что-то особенно умное (или уродливое) или "
"предупредить об этом, но старайтесь избегать лишнего. Вместо этого поставьте"
" комментарии во главе функции, сообщите людям, что она делает, и, возможно, "
"ПОЧЕМУ она это делает."

msgid ""
"When commenting the Tarantool C API functions, please use Doxygen comment "
"format, Javadoc flavor, i.e. `@tag` rather than `\\\\tag`. The main tags in "
"use are ``@param``, ``@retval``, ``@return``, ``@see``, ``@note`` and "
"``@todo``."
msgstr ""
"При комментировании функций Tarantool C API используйте систему "
"комментирования Doxygen (разновидность Javadoc): то есть `@tag`, а не "
"`\\\\tag`. Основные используемые теги: ``@param``, ``@retval``, ``@return``,"
" ``@see``, ``@note`` и ``@todo``."

msgid ""
"Every function, except perhaps a very short and obvious one, should have a "
"comment. A sample function comment may look like below:"
msgstr ""
"Каждая функция, за исключением, пожалуй, очень короткой и очевидной, должна "
"быть прокомментирована. Пример комментария функции может выглядеть следующим"
" образом:"

msgid ""
"/**\n"
" * Write all data to a descriptor.\n"
" *\n"
" * This function is equivalent to 'write', except it would ensure\n"
" * that all data is written to the file unless a non-ignorable\n"
" * error occurs.\n"
" *\n"
" * @retval 0  Success\n"
" * @retval 1 An error occurred (not EINTR)\n"
" */\n"
"static int\n"
"write_all(int fd, void *data, size_t len);"
msgstr ""
"/**\n"
" * Запись всех данных в дескриптор.\n"
" *\n"
" * Эта функция аналогична 'write' во всём кроме того, что она обеспечивает\n"
" * запись всех данных в файл, если не возникает ошибка,\n"
" * которую нельзя игнорировать.\n"
" *\n"
" * @retval 0  Выполнено\n"
" * @retval 1 Ошибка (не EINTR)\n"
" */\n"
"static int\n"
"write_all(int fd, void *data, size_t len);"

msgid ""
"It's also important to comment data types, whether they are basic types or "
"derived ones. To this end, use just one data declaration per line (no commas"
" for multiple data declarations). This leaves you room for a small comment "
"on each item, explaining its use."
msgstr ""
"Также важно комментировать типы данных независимо от того, базовые это типы "
"или производные. Для этого используйте только одно объявление данных в "
"строке (без запятой для объявления массива данных). Это оставляет вам место "
"для небольшого комментария к каждому пункту с объяснением его использования."

msgid ""
"Public structures and important structure members should be commented as "
"well."
msgstr ""
"Доступные структуры и важные элементы структуры также должны быть "
"прокомментированы."

msgid ""
"In C comments out of functions and inside of functions should be different "
"in how they are started. Everything else is wrong. Below are correct "
"examples. ``/**`` comes for documentation comments, ``/*`` for local not "
"documented comments. However the difference is vague already, so the rule is"
" simple: out of function use ``/**``, inside use ``/*``."
msgstr ""
"В C комментарии внутри и снаружи функции должны отличаться тем, как они "
"начинаются. Все остальное — неправильно. Ниже приведены правильные примеры. "
"``/**`` используется для комментирования документации, ``/*`` — для "
"локальных незадокументированных комментариев. Однако разница уже неявная, "
"поэтому правило простое: снаружи функции используйте ``/**``, внутри — "
"``/*``."

msgid ""
"/**\n"
" * Out of function comment, option 1.\n"
" */\n"
"\n"
"/** Out of function comment, option 2. */\n"
"\n"
"int\n"
"function()\n"
"{\n"
"    /* Comment inside function, option 1. */\n"
"\n"
"    /*\n"
"     * Comment inside function, option 2.\n"
"     */\n"
"}"
msgstr ""
"/**\n"
" * Комментарий снаружи функции, вариант 1.\n"
" */\n"
"\n"
"/** Комментарий снаружи функции, вариант 2. */\n"
"\n"
"int\n"
"function()\n"
"{\n"
"    /* Комментарий внутри функции, вариант 1. */\n"
"\n"
"    /*\n"
"     * Комментарий внутри функции, вариант 2.\n"
"     */\n"
"}"

msgid ""
"If a function has declaration and implementation separated, the function "
"comment should be for the declaration. Usually in the header file. Don't "
"duplicate the comment."
msgstr ""
"Если объявление функции и ее реализация разделены, то комментарий к функции "
"должен относиться к части объявления функции. Обычно в файле заголовка. Не "
"дублируйте комментарий."

msgid ""
"A comment and the function signature should be synchronized. Double-check if"
" the parameter names are the same as used in the comment, and mean the same."
" Especially when you change one of them - ensure you changed the other."
msgstr ""
"Комментарий и сигнатура функции должны быть согласованы. Перепроверьте, что "
"имена параметров те же, что и в комментарии, и означают одно и то же. "
"Особенно, если вы изменили один из них, — убедитесь, что вы изменили и "
"другой."

msgid "Chapter 9: Macros, Enums and RTL"
msgstr "Глава 9: Макросы, перечисления и уровни регистровых передач (RTL)"

msgid ""
"Names of macros defining constants and labels in enums are capitalized."
msgstr ""
"Имена макросов, определяющих постоянные и метки в перечислениях, пишутся "
"заглавными буквами."

msgid "#define CONSTANT 0x12345"
msgstr "#define CONSTANT 0x12345"

msgid "Enums are preferred when defining several related constants."
msgstr ""
"Рекомендуется использовать перечисления при определении нескольких связанных"
" постоянных."

msgid ""
"CAPITALIZED macro names are appreciated but macros resembling functions may "
"be named in lower case."
msgstr ""
"Ценятся имена макросов, написанные ЗАГЛАВНЫМИ буквами, но похожие на функции"
" макросы можно называть, используя буквы в нижнем регистре."

msgid ""
"Generally, inline functions are preferable to macros resembling functions."
msgstr ""
"Как правило, рекомендуется использовать встроенные функции для макросов, "
"похожих на функции."

msgid ""
"Macros with multiple statements should be enclosed in a do - while block:"
msgstr ""
"Макросы с несколькими операторами должны быть заключены в блок do - while:"

msgid ""
"#define macrofun(a, b, c)       \\\n"
"  do {                          \\\n"
"    if (a == 5)                 \\\n"
"      do_this(b, c);            \\\n"
"  } while (0)"
msgstr ""
"#define macrofun(a, b, c)       \\\n"
"  do {                          \\\n"
"    if (a == 5)                 \\\n"
"      do_this(b, c);            \\\n"
"  } while (0)"

msgid "Things to avoid when using macros:"
msgstr "Во время использования макросов постарайтесь избегать следующего:"

msgid "macros that affect control flow:"
msgstr "Макросы, которые влияют на поток управления:"

msgid ""
"#define FOO(x)                  \\\n"
"  do {                          \\\n"
"    if (blah(x) < 0)            \\\n"
"      return -EBUGGERED;        \\\n"
"  } while (0)"
msgstr ""
"#define FOO(x)                  \\\n"
"  do {                          \\\n"
"    if (blah(x) < 0)            \\\n"
"      return -EBUGGERED;        \\\n"
"  } while (0)"

msgid ""
"is a **very** bad idea. It looks like a function call but exits the "
"``calling`` function; don't break the internal parsers of those who will "
"read the code."
msgstr ""
"это **очень** плохая идея. Он выглядит как вызов функции, но выходит из "
"``вызывающей`` функции; не ломайте внутреннего анализатора у того, кто будет"
" читать код."

msgid "macros that depend on having a local variable with a magic name:"
msgstr ""
"Макросы, которые зависят от наличия локальной переменной с магическим "
"именем:"

msgid "#define FOO(val) bar(index, val)"
msgstr "#define FOO(val) bar(index, val)"

msgid ""
"might look like a good thing, but it's confusing as hell when one reads the "
"code and it's prone to breakage from seemingly innocent changes."
msgstr ""
"могут показаться хорошей идеей, но они сбивают с толку, когда читаешь код, и"
" такой код склонен ломаться от, казалось бы, невинных изменений."

msgid ""
"macros with arguments that are used as l-values: ``FOO(x) = y;`` will bite "
"you if somebody e.g. turns FOO into an inline function."
msgstr ""
"Макросы с аргументами, которые используются как l-значения: ``FOO(x) = y;``."
" Это вам аукнется, если кто-то, например, сделает FOO встроенной функцией."

msgid ""
"forgetting about precedence: macros defining constants using expressions "
"must enclose the expression in parentheses. Beware of similar issues with "
"macros using parameters."
msgstr ""
"Потеря приоритета: макросы, определяющие постоянные с использованием "
"выражений, должны заключать выражение в круглые скобки. Остерегайтесь "
"аналогичных проблем с макросами с использованием параметров."

msgid ""
"#define CONSTANT 0x4000\n"
"#define CONSTEXP (CONSTANT | 3)"
msgstr ""
"#define CONSTANT 0x4000\n"
"#define CONSTEXP (CONSTANT | 3)"

msgid ""
"namespace collisions when defining local variables in macros resembling "
"functions:"
msgstr ""
"Конфликты в пространствах имен при определении локальных переменных в "
"макросах, напоминающих функции:"

msgid ""
"#define FOO(x)            \\\n"
"({                        \\\n"
"  typeof(x) ret;          \\\n"
"  ret = calc_ret(x);      \\\n"
"  (ret);                  \\\n"
"})"
msgstr ""
"#define FOO(x)            \\\n"
"({                        \\\n"
"  typeof(x) ret;          \\\n"
"  ret = calc_ret(x);      \\\n"
"  (ret);                  \\\n"
"})"

msgid ""
"ret is a common name for a local variable - ``__foo_ret`` is less likely to "
"collide with an existing variable."
msgstr ""
"ret — обычное имя для локальной переменной; имя ``__foo_ret`` вряд ли "
"вызовет конфликт с уже существующей переменной."

msgid "Chapter 10: Allocating memory"
msgstr "Глава 10: Выделение памяти"

msgid ""
"Prefer specialized allocators like ``region``, ``mempool``, ``smalloc`` to "
"``malloc()/free()`` for any performance-intensive or large memory "
"allocations. Repetitive use of ``malloc()``/``free()`` can lead to memory "
"fragmentation and should therefore be avoided."
msgstr ""
"Лучше использовать специализированные генераторы, такие как ``region``, "
"``mempool``, ``smalloc``, вместо ``malloc()/free()``для любых операций "
"выделения памяти большого объема. Многократное использование "
"``malloc()``/``free()`` может привести к фрагментации памяти, чего следует "
"избегать."

msgid ""
"Always free all allocated memory, even allocated  at start-up. We aim at "
"being valgrind leak-check clean, and in most cases it's just as easy to "
"``free()`` the allocated memory as it is to write a valgrind suppression. "
"Freeing all allocated memory is also dynamic-load friendly: assuming a plug-"
"in can be dynamically loaded and unloaded multiple times, reload should not "
"lead to a memory leak."
msgstr ""
"Всегда освобождайте всю выделенную память, даже выделенную при запуске. Мы "
"стремимся к тому, чтобы valgrind не находил утечек памяти, и в большинстве "
"случаев так же легко освободить выделенную память по ``free()``, как и "
"записать подавление valgrind. Освобождение всей выделенной памяти также "
"помогает динамическому балансированию нагрузки: предполагается, что "
"подключаемый модуль может динамически загружаться и выгружаться несколько "
"раз, перезагрузка не должна приводить к утечке памяти."

msgid "Chapter 11: The inline disease"
msgstr "Глава 11: Болезнь встраивания (inline)"

msgid ""
"There appears to be a common misperception that gcc has a magic \"make me "
"faster\" speedup option called ``inline``. While the use of inlines can be "
"appropriate, it very often is not. Abundant use of the inline keyword leads "
"to a much bigger kernel, which in turn slows the system as a whole down, due"
" to a bigger icache footprint for the CPU and simply because there is less "
"memory available for the pagecache. Just think about it; a pagecache miss "
"causes a disk seek, which easily takes 5 milliseconds. There are a LOT of "
"cpu cycles that can go into these 5 milliseconds."
msgstr ""
"Похоже, что распространено ошибочное представление о том, что в gcc есть "
"волшебная опция ускорения, называемая встраиванием ``inline``. Хотя "
"использование встроенных строк может быть оправдано, довольно часто это не "
"так. Избыток ключевого слова inline приводит к увеличению ядра, что в свою "
"очередь, замедляет работу системы в целом из-за большего объема отпечатка "
"icache для процессора и просто потому, что для pagecache доступно меньше "
"памяти. Просто подумайте: непопадание в pagecache вызывает поиск по диску, "
"который легко занимает 5 миллисекунд. Есть МНОГО циклов процессора, которые "
"могут пройти в эти 5 миллисекунд."

msgid ""
"A reasonable rule of thumb is to not put inline at functions that have more "
"than 3 lines of code in them. An exception to this rule are the cases where "
"a parameter is known to be a compiletime constant, and as a result of this "
"constantness you *know* the compiler will be able to optimize most of your "
"function away at compile time."
msgstr ""
"Общее правило состоит в том, чтобы не вводить встраивание в функции, "
"содержащие больше трех строк кода. Исключением из этого правила являются "
"случаи, когда параметр известен как постоянная времени компиляции, и в "
"результате вы *знаете*, что компилятор сможет оптимизировать большую часть "
"ваших функций во время компиляции."

msgid ""
"Often people argue that adding inline to functions that are static and used "
"only once is always a win since there is no space tradeoff. While this is "
"technically correct, gcc is capable of inlining these automatically without "
"help, and the maintenance issue of removing the inline when a second user "
"appears outweighs the potential value of the hint that tells gcc to do "
"something it would have done anyway."
msgstr ""
"Часто утверждают, что беспроигрышным вариантом будет встраивание статических"
" функций, используемых только один раз, поскольку нет компромиссов "
"пространства. Хотя это технически правильно, gcc способен автоматически "
"встраивать их, а проблема удаления встроенного, если появляется второй "
"пользователь, перевешивает потенциальную ценность подсказки для gcc делать "
"что-то, что он сделал бы в любом случае."

msgid "Chapter 12: Function return values and names"
msgstr "Глава 12: Возвращаемые значения и имена функций"

msgid ""
"Functions can return values of many different kinds, and one of the most "
"common is a value indicating whether the function succeeded or failed."
msgstr ""
"Функции могут возвращать значения множества различных типов, и одним из "
"наиболее распространенных является значение, которое указывает, была функция"
" выполнена или нет."

msgid ""
"In 99.99999% of all cases in Tarantool we return 0 on success, non-zero on "
"error (-1 usually). Errors are saved into a diagnostics area which is global"
" per fiber. We never return error codes as a result of a function."
msgstr ""
"В 99.99999% случаев в Tarantool при выполнении функции возвращается 0, в "
"случае ошибки — ненулевое значение (обычно -1). Ошибки сохраняются в рабочей"
" области диагностики (одна на файбер). Результатом функции никогда не будет "
"код ошибки."

msgid ""
"Functions whose return value is the actual result of a computation, rather "
"than an indication of whether the computation succeeded, are not subject to "
"this rule. Generally they indicate failure by returning some out-of-range "
"result. Typical examples would be functions that return pointers; they use "
"NULL or the mechanism to report failure."
msgstr ""
"Функции, возвращаемое значение которых является фактическим результатом "
"вычисления, а не указанием того, удалось ли выполнить вычисление, не "
"подпадают под это правило. Обычно они указывают на сбой, возвращая некое "
"недопустимое значение. Типичными примерами будут функции, возвращающие "
"указатели; чтобы сообщить об ошибке, они используют NULL."

msgid "Chapter 13: Editor modelines and other cruft"
msgstr "Глава 13: Редакторские строки режима (modelines) и прочий хлам"

msgid ""
"Some editors can interpret configuration information embedded in source "
"files, indicated with special markers. For example, emacs interprets lines "
"marked like this:"
msgstr ""
"Некоторые редакторы могут интерпретировать встроенную в исходные файлы "
"информацию о конфигурации, указанную специальными маркерами. Например, emacs"
" интерпретирует строки, помеченные следующим образом:"

msgid "-*- mode: c -*-"
msgstr "-*- mode: c -*-"

msgid "Or like this:"
msgstr "Или так:"

msgid ""
"/*\n"
"Local Variables:\n"
"compile-command: \"gcc -DMAGIC_DEBUG_FLAG foo.c\"\n"
"End:\n"
"*/"
msgstr ""
"/*\n"
"Local Variables:\n"
"compile-command: \"gcc -DMAGIC_DEBUG_FLAG foo.c\"\n"
"End:\n"
"*/"

msgid "Vim interprets markers that look like this:"
msgstr "Vim интерпретирует маркеры, которые выглядят так:"

msgid "/* vim:set sw=8 noet */"
msgstr "/* vim:set sw=8 noet */"

msgid ""
"Do not include any of these in source files. People have their own personal "
"editor configurations, and your source files should not override them. This "
"includes markers for indentation and mode configuration. People may use "
"their own custom mode, or may have some other magic method for making "
"indentation work correctly."
msgstr ""
"Не включайте их в исходные файлы. У людей есть свои собственные настройки "
"редакторов, и ваши исходные файлы не должны их переопределять. Это относится"
" к маркерам для отступов и конфигурации режима. У других людей могут быть "
"свои собственные режимы или другие волшебные методы для правильной работы "
"отступов."

msgid "Chapter 14: Conditional Compilation"
msgstr "Глава 14: Условная компиляция"

msgid ""
"Wherever possible, don't use preprocessor conditionals (``#if``, ``#ifdef``)"
" in .c files; doing so makes code harder to read and logic harder to follow."
" Instead, use such conditionals in a header file defining functions for use "
"in those .c files, providing no-op stub versions in the #else case, and then"
" call those functions unconditionally from .c files. The compiler will avoid"
" generating any code for the stub calls, producing identical results, but "
"the logic will remain easy to follow."
msgstr ""
"По возможности не используйте препроцессорные директивы (``#if``, "
"``#ifdef``) в файлах .c. Это затрудняет чтение кода и понимание логики. "
"Вместо этого используйте такие директивы в файле заголовка, чтобы определить"
" функции, используемые в этих файлах .c с заглушками в виде холостых команд "
"в случае #else, а затем вызывайте эти функции безусловно из файлов .c. "
"Компилятор не будет генерировать код для вызовов заглушек, при этом "
"результат останется таким же, но логику будет проще понять."

msgid ""
"Prefer to compile out entire functions, rather than portions of functions or"
" portions of expressions. Rather than putting an ``#ifdef`` in an "
"expression, factor out part or all of the expression into a separate helper "
"function and apply the condition to that function."
msgstr ""
"Лучше компилировать целые функции, а не части функций или части выражений. "
"Вместо того, чтобы вставить ``#ifdef`` в выражение, выделите часть или все "
"выражение в отдельную вспомогательную функцию и примените условие к этой "
"функции."

msgid ""
"If you have a function or variable which may potentially go unused in a "
"particular configuration, and the compiler would warn about its definition "
"going unused, do not compile it and use #if for this."
msgstr ""
"Если у вас есть функция или переменная, которая может не использоваться в "
"конкретной конфигурации, и компилятор предупредит о том, что она "
"использоваться не будет, не компилируйте ее и используйте для этого #if."

msgid ""
"At the end of any non-trivial ``#if`` or ``#ifdef`` block (more than a few "
"lines), place a comment after the #endif on the same line, noting the "
"conditional expression used. For instance:"
msgstr ""
"В конце любого крупного блока ``#if`` или ``#ifdef`` (более нескольких "
"строк) после #endif в той же строке поместите комментарий, отмечающий "
"используемое условное выражение. Например:"

msgid ""
"#ifdef CONFIG_SOMETHING\n"
"...\n"
"#endif /* CONFIG_SOMETHING */"
msgstr ""
"#ifdef CONFIG_SOMETHING\n"
"...\n"
"#endif /* CONFIG_SOMETHING */"

msgid "Chapter 15: Header files"
msgstr "Глава 15: Файлы заголовка"

msgid ""
"Use ``#pragma once`` in the headers. As the header guards we refer to this "
"construction:"
msgstr ""
"В заголовках используйте ``#pragma once``. Для защиты заголовков мы "
"используем такую конструкцию:"

msgid ""
"#ifndef THE_HEADER_IS_INCLUDED\n"
"#define THE_HEADER_IS_INCLUDED\n"
"\n"
"// ... the header code ...\n"
"\n"
"#endif // THE_HEADER_IS_INCLUDED"
msgstr ""
"#ifndef THE_HEADER_IS_INCLUDED\n"
"#define THE_HEADER_IS_INCLUDED\n"
"\n"
"// ... код заголовка ...\n"
"\n"
"#endif // THE_HEADER_IS_INCLUDED"

msgid ""
"It works fine, but the guard name ``THE_HEADER_IS_INCLUDED`` tends to become"
" outdated when the file is moved or renamed. This is especially painful with"
" multiple files having the same name in the project, but different path. For"
" instance, we have 3 ``error.h`` files, which means for each of them we need"
" to invent a new header guard name, and not forget to update them if the "
"files are moved or renamed."
msgstr ""
"Работает нормально, но имя защиты ``THE_HEADER_IS_INCLUDED`` обычно "
"перестает действовать при перемещении или переименовании файла. Это особенно"
" неудобно, если у нескольких файлов одинаковое имя в проекте, но разные "
"пути. Например, у нас есть 3 файла ``error.h``, а это значит, что для "
"каждого из них нужно придумать новое имя защиты заголовка, и не забыть "
"обновить их при перемещении или переименовании файлов."

msgid ""
"For that reason we use ``#pragma once`` in all the new code, which shortens "
"the header file down to this:"
msgstr ""
"По этой причине мы и используем ``#pragma once`` во всем новом коде, что "
"сокращает файл заголовка до такого:"

msgid ""
"#pragma once\n"
"\n"
"// ... header code ..."
msgstr ""
"#pragma once\n"
"\n"
"// ... код заголовка ..."

msgid "Chapter 16: Other"
msgstr "Глава 16: Прочие положения"

msgid ""
"We don't apply ``!`` operator to non-boolean values. It means, to check if "
"an integer is not 0, you use ``!= 0``. To check if a pointer is not NULL, "
"you use ``!= NULL``. The same for ``==``."
msgstr ""
"Мы не применяем оператор ``!`` к значениям, отличным от boolean. То есть, "
"чтобы проверить, не равно ли целое число 0, вы используете ``!= 0``. Чтобы "
"проверить, что указатель не NULL, используете ``!= NULL``. То же самое для "
"``==``."

msgid ""
"Select GNU C99 extensions are acceptable. It's OK to mix declarations and "
"statements, use true and false."
msgstr ""
"Допускаются расширения GNU C99. Можно смешивать операторы и объявления в "
"выражениях."

msgid ""
"The not-so-current list of all GCC C extensions can be found at: "
"http://gcc.gnu.org/onlinedocs/gcc-4.3.5/gcc/C-Extensions.html"
msgstr ""
"Не слишком актуальный список всех расширений семейства языка C можно найти "
"по ссылке: http://gcc.gnu.org/onlinedocs/gcc-4.3.5/gcc/C-Extensions.html"

msgid "Appendix I: References"
msgstr "Приложение I: Источники"

msgid ""
"`The C Programming Language, Second Edition "
"<https://en.wikipedia.org/wiki/The_C_Programming_Language>`_ by Brian W. "
"Kernighan and Dennis M. Ritchie. Prentice Hall, Inc., 1988. ISBN "
"0-13-110362-8 (paperback), 0-13-110370-9 (hardback)."
msgstr ""
"Керниган Брайан В., Ричи Деннис М. `Язык программирования Си "
"<https://ru.wikipedia.org/wiki/%D0%AF%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F_%D0%A1%D0%B8_(%D0%BA%D0%BD%D0%B8%D0%B3%D0%B0)>`_."
" Prentice Hall, Inc., 1988. ISBN 0-13-110362-8 (в мягкой обложке), "
"0-13-110370-9 (в твердом переплете)."

msgid ""
"`The Practice of Programming "
"<https://en.wikipedia.org/wiki/The_Practice_of_Programming>`_ by Brian W. "
"Kernighan and Rob Pike. Addison-Wesley, Inc., 1999. ISBN 0-201-61586-X."
msgstr ""
"Керниган Брайан В., Пайк Роб. `Практика программирования "
"<https://en.wikipedia.org/wiki/The_Practice_of_Programming>`_. Addison-"
"Wesley, Inc., 1999. ISBN 0-201-61586-X."

msgid ""
"`GNU manuals <http://www.gnu.org/manual/>`_ - where in compliance with K&R "
"and this text - for **cpp**, **gcc**, **gcc internals** and **indent**"
msgstr ""
"`Рекомендации GNU <http://www.gnu.org/manual/>`_ в соответствии с K&R и "
"данным текстом -- для **cpp**, **gcc**, **gcc internals** и **indent**"

msgid ""
"`WG14 International standardization workgroup for the programming language C"
" <http://www.open-std.org/JTC1/SC22/WG14/>`_"
msgstr ""
"`Рабочая группа по международной стандартизации языка программирования C "
"WG14 <http://www.open-std.org/JTC1/SC22/WG14/>`_"

msgid ""
"`Kernel CodingStyle, by greg@kroah.com at OLS 2002 "
"<http://www.kroah.com/linux/talks/ols_2002_kernel_codingstyle_talk/html/>`_"
msgstr ""
"`Стиль программирования ядра, автор greg@kroah.com, презентация на OLS 2002 "
"<http://www.kroah.com/linux/talks/ols_2002_kernel_codingstyle_talk/html/>`_"
