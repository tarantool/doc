
msgid "Binary protocol"
msgstr "Бинарный протокол"

msgid ""
"The binary protocol is called a \"request/response\" protocol because it is "
"for sending requests to a Tarantool server and receiving responses. There is"
" complete access to Tarantool functionality, including:"
msgstr ""
"Бинарный протокол передает данные по схеме \"запрос-ответ\", то есть он "
"предназначен для отправки запросов на сервер Tarantool и получения ответов. "
"Протокол предоставляет полный доступ к функциям Tarantool, включая:"

msgid ""
"request multiplexing, for example ability to issue multiple requests "
"asynchronously via the same connection"
msgstr ""
"мультиплексирование запросов, т.е. возможность асинхронной отправки "
"множества запросов по одному соединению;"

msgid "response format that supports zero-copy writes"
msgstr ""
"формат ответа, который поддерживает запись в режиме без копирования (zero-"
"copy)."

msgid ""
"The protocol can be called \"binary\" because the most-frequently-used "
"database accesses are done with binary codes instead of Lua request text. "
"Tarantool experts use it to write their own connectors, to understand "
"network messages, to support new features that their favorite connector "
"doesn't support yet, or to avoid repetitive parsing by the server."
msgstr ""
"Протокол можно назвать \"бинарным\", поскольку наиболее частые обращения к "
"базе данных выполняются с помощью бинарного кода, а не текста запроса на "
"языке Lua. Специалисты по Tarantool используют его, чтобы писать собственные"
" коннекторы, понимать сетевые сообщения, поддерживать новые функции, которые"
" их любимый коннектор еще не поддерживает, или чтобы избежать повторного "
"разбора на сервере."

msgid "Index"
msgstr "Указатель"

msgid "Section"
msgstr "Раздел"

msgid "Description"
msgstr "Описание"

msgid ":ref:`Symbols and terms <box_protocol-notation>`"
msgstr ":ref:`Обозначения и термины <box_protocol-notation>`"

msgid "Notation of binary protocol"
msgstr "Условные обозначения в бинарном протоколе"

msgid ":ref:`Header and body <box_protocol-header>`"
msgstr ":ref:`Заголовок и тело сообщения <box_protocol-header>`"

msgid "Header of a request"
msgstr "Заголовок запроса"

msgid ""
"Requests: |br|:ref:`IPROTO_SELECT <box_protocol-select>` "
"|br|:ref:`IPROTO_INSERT <box_protocol-insert>` |br|:ref:`IPROTO_REPLACE "
"<box_protocol-replace>` |br|:ref:`IPROTO_UPDATE <box_protocol-update>` "
"|br|:ref:`IPROTO_DELETE <box_protocol-delete>` |br|:ref:`IPROTO_CALL_16 "
"<box_protocol-call16>` |br|:ref:`IPROTO_AUTH <box_protocol-auth>` "
"|br|:ref:`IPROTO_EVAL <box_protocol-eval>` |br|:ref:`IPROTO_UPSERT "
"<box_protocol-upsert>` |br|:ref:`IPROTO_CALL <box_protocol-call>` "
"|br|:ref:`IPROTO_EXECUTE <box_protocol-execute>` |br|:ref:`IPROTO_NOP "
"<box_protocol-nop>` |br|:ref:`IPROTO_PREPARE <box_protocol-prepare>` "
"|br|:ref:`IPROTO_PING <box_protocol-ping>` |br|:ref:`IPROTO_JOIN "
"<box_protocol-join>` |br|:ref:`IPROTO_SUBSCRIBE <box_protocol-join>` "
"|br|:ref:`IPROTO_VOTE_DEPRECATED <box_protocol-join>` |br|:ref:`IPROTO_VOTE "
"<box_protocol-join>` |br|:ref:`IPROTO_FETCH_SNAPSHOT <box_protocol-join>` "
"|br|:ref:`IPROTO_REGISTER <box_protocol-join>` |br|:ref:`IPROTO_BEGIN "
"<box_protocol-begin>` |br|:ref:`IPROTO_COMMIT <box_protocol-commit>` "
"|br|:ref:`IPROTO_ROLLBACK <box_protocol-rollback>`"
msgstr ""
"Запросы: |br|:ref:`IPROTO_SELECT <box_protocol-select>` "
"|br|:ref:`IPROTO_INSERT <box_protocol-insert>` |br|:ref:`IPROTO_REPLACE "
"<box_protocol-replace>` |br|:ref:`IPROTO_UPDATE <box_protocol-update>` "
"|br|:ref:`IPROTO_DELETE <box_protocol-delete>` |br|:ref:`IPROTO_CALL_16 "
"<box_protocol-call16>` |br|:ref:`IPROTO_AUTH <box_protocol-auth>` "
"|br|:ref:`IPROTO_EVAL <box_protocol-eval>` |br|:ref:`IPROTO_UPSERT "
"<box_protocol-upsert>` |br|:ref:`IPROTO_CALL <box_protocol-call>` "
"|br|:ref:`IPROTO_EXECUTE <box_protocol-execute>` |br|:ref:`IPROTO_NOP "
"<box_protocol-nop>` |br|:ref:`IPROTO_PREPARE <box_protocol-prepare>` "
"|br|:ref:`IPROTO_PING <box_protocol-ping>` |br|:ref:`IPROTO_JOIN "
"<box_protocol-join>` |br|:ref:`IPROTO_SUBSCRIBE <box_protocol-join>` "
"|br|:ref:`IPROTO_VOTE_DEPRECATED <box_protocol-join>` |br|:ref:`IPROTO_VOTE "
"<box_protocol-join>` |br|:ref:`IPROTO_FETCH_SNAPSHOT <box_protocol-join>` "
"|br|:ref:`IPROTO_REGISTER <box_protocol-join>` |br|:ref:`IPROTO_BEGIN "
"<box_protocol-begin>` |br|:ref:`IPROTO_COMMIT <box_protocol-commit>` "
"|br|:ref:`IPROTO_ROLLBACK <box_protocol-rollback>`"

msgid "Body of a request"
msgstr "Тело запроса"

msgid ":ref:`Responses if no error and no SQL <box_protocol-responses>`"
msgstr ":ref:`Ответы на ошибки и запросы без SQL <box_protocol-responses>`"

msgid "Responses for no SQL"
msgstr "Ответы на запросы без SQL"

msgid ":ref:`Responses for errors <box_protocol-responses_error>`"
msgstr ":ref:`Ответы на ошибки <box_protocol-responses_error>`"

msgid "Responses for errors"
msgstr "Ответы на ошибки"

msgid ":ref:`Responses for SQL <box_protocol-sql_protocol>`"
msgstr ":ref:`Ответы на запросы с SQL <box_protocol-sql_protocol>`"

msgid "Responses for SQL"
msgstr "Ответы на запросы с SQL"

msgid ":ref:`Authentication <box_protocol-authentication>`"
msgstr ":ref:`Аутентификация <box_protocol-authentication>`"

msgid "Authentication after connection"
msgstr "Аутентификация после установления соединения"

msgid ":ref:`Replication <box_protocol-replication>`"
msgstr ":ref:`Репликация <box_protocol-replication>`"

msgid "Replication request"
msgstr "Запрос репликации"

msgid ":ref:`Illustration <box_protocol-illustration>`"
msgstr ":ref:`Примеры <box_protocol-illustration>`"

msgid "Illustration of use"
msgstr "Примеры использования"

msgid ":ref:`XLOG/SNAP <box_protocol-xlog>`"
msgstr ":ref:`XLOG/SNAP <box_protocol-xlog>`"

msgid "Format of .xlog and .snap files"
msgstr "Формат файлов .xlog и .snap"

msgid "Binary protocol -- symbols and terms"
msgstr "Бинарный протокол — обозначения и термины"

msgid ""
"Words that start with **MP_** mean: a `MessagePack "
"<http://MessagePack.org>`_ type or a range of MessagePack types, including "
"the signal and possibly including a value, with slight modification:"
msgstr ""
"Если слово начинается с **MP_**, это указывает на тип `MessagePack "
"<http://MessagePack.org>`_ или ряд типов MessagePack, включая сигнал и, "
"возможно, включая значение, с небольшими изменениями:"

msgid "**MP_NIL**    nil"
msgstr "**MP_NIL**    nil"

msgid "**MP_UINT**   unsigned integer"
msgstr "**MP_UINT**   unsigned integer"

msgid "**MP_INT**    either integer or unsigned integer"
msgstr "**MP_INT**    integer или unsigned integer"

msgid "**MP_STR**    string"
msgstr "**MP_STR**    string"

msgid "**MP_BIN**    binary string"
msgstr "**MP_BIN**    binary string"

msgid "**MP_ARRAY**  array"
msgstr "**MP_ARRAY**  array"

msgid "**MP_MAP**    map"
msgstr "**MP_MAP**    map"

msgid "**MP_BOOL**   boolean"
msgstr "**MP_BOOL**   boolean"

msgid "**MP_FLOAT**  float"
msgstr "**MP_FLOAT**  float"

msgid "**MP_DOUBLE** double"
msgstr "**MP_DOUBLE** double"

msgid ""
"**MP_EXT**    extension (including the :ref:`DECIMAL type <msgpack_ext-"
"decimal>` and UUID type)"
msgstr ""
"**MP_EXT**    extension (включая :ref:`тип DECIMAL <msgpack_ext-decimal>` и "
"тип UUID)"

msgid "**MP_OBJECT** any MessagePack object"
msgstr "**MP_OBJECT** любой объект формата MessagePack"

msgid ""
"Short descriptions are in MessagePack's `\"spec\" page "
"<https://github.com/msgpack/msgpack/blob/master/spec.md>`_."
msgstr ""
"Краткое описание приводится на `странице \"спецификации\" "
"<https://github.com/msgpack/msgpack/blob/master/spec.md>`_ MessagePack."

msgid ""
"And words that start with **IPROTO_** mean: a Tarantool constant which is "
"either defined or mentioned in the `iproto_constants.h file "
"<https://github.com/tarantool/tarantool/blob/master/src/box/iproto_constants.h>`_."
msgstr ""
"Если же слово начинается с **IPROTO_**, это указывает на константу "
"Tarantool, которая либо определена, либо упоминается в `файле "
"iproto_constants.h "
"<https://github.com/tarantool/tarantool/blob/master/src/box/iproto_constants.h>`_."

msgid ""
"The IPROTO constants that identify requests that we will mention in this "
"section are:"
msgstr ""
"В этом разделе мы будем упоминать следующие константы IPROTO, которые "
"идентифицируют запросы:"

msgid ""
"IPROTO_SELECT=0x01\n"
"IPROTO_INSERT=0x02\n"
"IPROTO_REPLACE=0x03\n"
"IPROTO_UPDATE=0x04\n"
"IPROTO_DELETE=0x05\n"
"IPROTO_CALL_16=0x06\n"
"IPROTO_AUTH=0x07\n"
"IPROTO_EVAL=0x08\n"
"IPROTO_UPSERT=0x09\n"
"IPROTO_CALL=0x0a\n"
"IPROTO_EXECUTE=0x0b\n"
"IPROTO_NOP=0x0c\n"
"IPROTO_PREPARE=0x0d\n"
"IPROTO_BEGIN=0x0e\n"
"IPROTO_COMMIT=0x0f\n"
"IPROTO_ROLLBACK=0x10\n"
"IPROTO_RAFT_CONFIRM=0x28\n"
"IPROTO_RAFT_ROLLBACK=0x29\n"
"IPROTO_PING=0x40\n"
"IPROTO_JOIN=0x41\n"
"IPROTO_SUBSCRIBE=0x42\n"
"IPROTO_VOTE_DEPRECATED=0x43\n"
"IPROTO_VOTE=0x44\n"
"IPROTO_FETCH_SNAPSHOT=0x45\n"
"IPROTO_REGISTER=0x46"
msgstr ""
"IPROTO_SELECT=0x01\n"
"IPROTO_INSERT=0x02\n"
"IPROTO_REPLACE=0x03\n"
"IPROTO_UPDATE=0x04\n"
"IPROTO_DELETE=0x05\n"
"IPROTO_CALL_16=0x06\n"
"IPROTO_AUTH=0x07\n"
"IPROTO_EVAL=0x08\n"
"IPROTO_UPSERT=0x09\n"
"IPROTO_CALL=0x0a\n"
"IPROTO_EXECUTE=0x0b\n"
"IPROTO_NOP=0x0c\n"
"IPROTO_PREPARE=0x0d\n"
"IPROTO_BEGIN=0x0e\n"
"IPROTO_COMMIT=0x0f\n"
"IPROTO_ROLLBACK=0x10\n"
"IPROTO_RAFT_CONFIRM=0x28\n"
"IPROTO_RAFT_ROLLBACK=0x29\n"
"IPROTO_PING=0x40\n"
"IPROTO_JOIN=0x41\n"
"IPROTO_SUBSCRIBE=0x42\n"
"IPROTO_VOTE_DEPRECATED=0x43\n"
"IPROTO_VOTE=0x44\n"
"IPROTO_FETCH_SNAPSHOT=0x45\n"
"IPROTO_REGISTER=0x46"

msgid ""
"The IPROTO constants that appear within requests or responses that we will "
"describe in this section are:"
msgstr ""
"В этом разделе мы опишем такие константы IPROTO, которые встречаются в "
"запросах или ответах:"

msgid ""
"IPROTO_OK=0x00\n"
"IPROTO_REQUEST_TYPE=0x00\n"
"IPROTO_SYNC=0x01\n"
"IPROTO_REPLICA_ID=0x02\n"
"IPROTO_LSN=0x03\n"
"IPROTO_TIMESTAMP=0x04\n"
"IPROTO_SCHEMA_VERSION=0x05\n"
"IPROTO_FLAGS=0x09\n"
"IPROTO_STREAM_ID=0x0a\n"
"IPROTO_SPACE_ID=0x10\n"
"IPROTO_INDEX_ID=0x11\n"
"IPROTO_LIMIT=0x12\n"
"IPROTO_OFFSET=0x13\n"
"IPROTO_ITERATOR=0x14\n"
"IPROTO_INDEX_BASE=0x15\n"
"IPROTO_KEY=0x20\n"
"IPROTO_TUPLE=0x21\n"
"IPROTO_FUNCTION_NAME=0x22\n"
"IPROTO_USER_NAME=0x23\n"
"IPROTO_INSTANCE_UUID=0x24\n"
"IPROTO_CLUSTER_UUID=0x25\n"
"IPROTO_VCLOCK=0x26\n"
"IPROTO_EXPR=0x27\n"
"IPROTO_OPS=0x28\n"
"IPROTO_BALLOT=0x29\n"
"IPROTO_BALLOT_IS_RO_CFG=0x01\n"
"IPROTO_BALLOT_VCLOCK=0x02\n"
"IPROTO_BALLOT_GC_VCLOCK=0x03\n"
"IPROTO_BALLOT_IS_RO=0x04\n"
"IPROTO_BALLOT_IS_ANON=0x05\n"
"IPROTO_BALLOT_IS_BOOTED=0x06\n"
"IPROTO_TUPLE_META=0x2a\n"
"IPROTO_OPTIONS=0x2b\n"
"IPROTO_DATA=0x30\n"
"IPROTO_ERROR_24=0x31\n"
"IPROTO_METADATA=0x32\n"
"IPROTO_BIND_METADATA=0x33\n"
"IPROTO_BIND_COUNT=0x34\n"
"IPROTO_SQL_TEXT=0x40\n"
"IPROTO_SQL_BIND=0x41\n"
"IPROTO_SQL_INF O=0x42\n"
"IPROTO_STMT_ID=0x43\n"
"IPROTO_ERROR=0x52\n"
"IPROTO_FIELD_NAME=0x00\n"
"IPROTO_FIELD_TYPE=0x01\n"
"IPROTO_FIELD_COLL=0x02\n"
"IPROTO_FIELD_IS_NULLABLE=0x03\n"
"IPROTO_FIELD_IS_AUTOINCREMENT=0x04\n"
"IPROTO_FIELD_SPAN=0x05"
msgstr ""
"IPROTO_OK=0x00\n"
"IPROTO_REQUEST_TYPE=0x00\n"
"IPROTO_SYNC=0x01\n"
"IPROTO_REPLICA_ID=0x02\n"
"IPROTO_LSN=0x03\n"
"IPROTO_TIMESTAMP=0x04\n"
"IPROTO_SCHEMA_VERSION=0x05\n"
"IPROTO_FLAGS=0x09\n"
"IPROTO_STREAM_ID=0x0a\n"
"IPROTO_SPACE_ID=0x10\n"
"IPROTO_INDEX_ID=0x11\n"
"IPROTO_LIMIT=0x12\n"
"IPROTO_OFFSET=0x13\n"
"IPROTO_ITERATOR=0x14\n"
"IPROTO_INDEX_BASE=0x15\n"
"IPROTO_KEY=0x20\n"
"IPROTO_TUPLE=0x21\n"
"IPROTO_FUNCTION_NAME=0x22\n"
"IPROTO_USER_NAME=0x23\n"
"IPROTO_INSTANCE_UUID=0x24\n"
"IPROTO_CLUSTER_UUID=0x25\n"
"IPROTO_VCLOCK=0x26\n"
"IPROTO_EXPR=0x27\n"
"IPROTO_OPS=0x28\n"
"IPROTO_BALLOT=0x29\n"
"IPROTO_BALLOT_IS_RO_CFG=0x01\n"
"IPROTO_BALLOT_VCLOCK=0x02\n"
"IPROTO_BALLOT_GC_VCLOCK=0x03\n"
"IPROTO_BALLOT_IS_RO=0x04\n"
"IPROTO_BALLOT_IS_ANON=0x05\n"
"IPROTO_BALLOT_IS_BOOTED=0x06\n"
"IPROTO_TUPLE_META=0x2a\n"
"IPROTO_OPTIONS=0x2b\n"
"IPROTO_DATA=0x30\n"
"IPROTO_ERROR_24=0x31\n"
"IPROTO_METADATA=0x32\n"
"IPROTO_BIND_METADATA=0x33\n"
"IPROTO_BIND_COUNT=0x34\n"
"IPROTO_SQL_TEXT=0x40\n"
"IPROTO_SQL_BIND=0x41\n"
"IPROTO_SQL_INF O=0x42\n"
"IPROTO_STMT_ID=0x43\n"
"IPROTO_ERROR=0x52\n"
"IPROTO_FIELD_NAME=0x00\n"
"IPROTO_FIELD_TYPE=0x01\n"
"IPROTO_FIELD_COLL=0x02\n"
"IPROTO_FIELD_IS_NULLABLE=0x03\n"
"IPROTO_FIELD_IS_AUTOINCREMENT=0x04\n"
"IPROTO_FIELD_SPAN=0x05"

msgid ""
"To denote message descriptions we will say ``msgpack(...)`` and within it we"
" will use modified `YAML <https://en.wikipedia.org/wiki/YAML>`_ so: |br|"
msgstr ""
"Для обозначения описаний сообщений мы будем вызывать ``msgpack(...)``, а "
"внутри него будем использовать модифицированный ``YAML "
"<https://en.wikipedia.org/wiki/YAML>`_ таким образом: |br|"

msgid ""
":code:`{...}` braces enclose an associative array, also called map, which in"
" MsgPack is MP_MAP, |br| :samp:`{k}: {v}` is a key-value pair, also called "
"map-item, in this section k is always an unsigned-integer value = one of the"
" IPROTO constants, |br| :samp:`{italics}` are for replaceable text, which is"
" the convention throughout this manual. Usually this is a data type but we "
"do not show types of IPROTO constants which happen to always be unsigned "
"8-bit integers, |br| :code:`[...]` is for non-associative arrays, |br| "
":code:`#` starts a comment, especially for the beginning of a section, |br| "
"everything else is \"as is\". |br| Map-items may appear in any order but in "
"examples we usually use the order that net_box.c happens to use."
msgstr ""
":code:`{...}` в фигурные скобки заключают ассоциативный массив, в MsgPack "
"это MP_MAP, |br| :samp:`{k}: {v}` — это пара \"ключ-значение\", также "
"называемая элементом ассоциативного массива, в этом разделе k всегда "
"является беззнаковым целым = одной из констант IPROTO, |br| "
":samp:`{italics}` используются для обозначения заменяемого текста в этом "
"руководстве. Обычно это тип данных, но мы не показываем типы констант "
"IPROTO, которые всегда будут беззнаковыми 8-битными целыми числами, |br| "
":code:`[...]` — для неассоциативных массивов, |br| :code:`#` начинает "
"комментарий, особенно в начале раздела, |br| все остальное приводится \"как "
"есть\". |br| Элементы ассоциативного массива могут появляться в любом "
"порядке, но в примерах мы обычно используем тот порядок, который "
"используется в net_box.c."

msgid "Binary protocol -- header and body"
msgstr "Бинарный протокол — заголовок и тело сообщения"

msgid ""
"Except during connection (which involves a greeting from the server and "
"optional :ref:`authentication <box_protocol-authentication>` that we will "
"discuss later in this section), the protocol is pure request/response (the "
"client requests and the server responds). It is legal to put more than one "
"request in a packet."
msgstr ""
"Кроме как во время соединения (что включает в себя приветствие сервера и "
"необязательную :ref:`аутентификацию <box_protocol-authentication>`, которую "
"мы обсудим далее в этом разделе), протокол идет по схеме \"запрос-ответ\" "
"(клиент запрашивает, сервер отвечает). Пакет может содержать более одного "
"запроса."

msgid ""
"Almost all requests and responses contain three sections: size, header, and "
"body. The size is an (MP_UINT) unsigned integer, usually a 32-bit unsigned "
"integer. The header and body are (MP_MAP) maps."
msgstr ""
"Почти все запросы и ответы состоят из трех частей: размер, заголовок и тело."
" Размер — это unsigned integer (MP_UINT), обычно 32-битное беззнаковое целое"
" число. Заголовок и тело — это ассоциативные массивы (MP_MAP)."

msgid ""
"# <size>\n"
":samp:`{{MP_UINT unsigned integer}}`\n"
"# <header>\n"
":samp:`{{MP_MAP with <header> map-items}}`\n"
"# <body>\n"
":samp:`{{MP_MAP with <body> map-items}}`"
msgstr ""
"# <size>\n"
":samp:`{{MP_UINT unsigned integer}}`\n"
"# <header>\n"
":samp:`{{MP_MAP with <header> map-items}}`\n"
"# <body>\n"
":samp:`{{MP_MAP with <body> map-items}}`"

msgid ""
"``<size>`` is the size of the header plus the size of the body. It may be "
"useful to compare it with the number of bytes remaining in the packet."
msgstr ""
"``<size>`` — это размер заголовка плюс размер тела сообщения. Есть смысл "
"сравнивать его с количеством байтов, оставшихся в пакете."

msgid "``<header>`` may contain, in any order:"
msgstr "Заголовок ``<header>`` может содержать такие данные в любом порядке:"

msgid ""
"msgpack({\n"
"    IPROTO_REQUEST_TYPE: :samp:`{{MP_UINT unsigned integer}}`,\n"
"    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`,\n"
"    IPROTO_SCHEMA_VERSION: :samp:`{{MP_UINT unsigned integer}}`\n"
"    IPROTO_STREAM_ID: :samp:`{{MP_UINT unsigned integer}}`\n"
"})"
msgstr ""
"msgpack({\n"
"    IPROTO_REQUEST_TYPE: :samp:`{{MP_UINT unsigned integer}}`,\n"
"    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`,\n"
"    IPROTO_SCHEMA_VERSION: :samp:`{{MP_UINT unsigned integer}}`\n"
"    IPROTO_STREAM_ID: :samp:`{{MP_UINT unsigned integer}}`\n"
"})"

msgid ""
"**IPROTO_REQUEST_TYPE** or Response-Code-Indicator = 0x00. An unsigned "
"number that indicates what will be in the ``<body>``. In requests "
"IPROTO_REQUEST_TYPE will be followed by IPROTO_SELECT etc. In responses "
"Response-Code-Indicator will be followed by IPROTO_OK etc."
msgstr ""
"**IPROTO_REQUEST_TYPE** или индикатор кода ответа (Response-Code-Indicator) "
"= 0x00. Это беззнаковое число, которое указывает на то, что будет находиться"
" в теле сообщения ``<body>``. В запросах за IPROTO_REQUEST_TYPE будет "
"следовать IPROTO_SELECT и т. д. В ответах за Response-Code-Indicator будет "
"следовать IPROTO_OK и т. д."

msgid ""
"**IPROTO_SYNC** = 0x01. An unsigned integer that should be incremented so "
"that it is unique in every request. This integer is also returned from "
":doc:`/reference/reference_lua/box_session/sync`. The IPROTO_SYNC value of a"
" response should be the same as the IPROTO_SYNC value of a request."
msgstr ""
"**IPROTO_SYNC** = 0x01. Это беззнаковое целое число должно увеличиваться "
"так, чтобы оно было уникальным в каждом запросе. Это целое число также "
"возвращается в результате :doc:`/reference/reference_lua/box_session/sync`. "
"Значение IPROTO_SYNC в ответе должно быть таким же, как значение IPROTO_SYNC"
" в запросе."

msgid ""
"**IPROTO_SCHEMA_VERSION** = 0x05. An unsigned number, sometimes called "
"SCHEMA_ID, that goes up when there is a major change. In a request header "
"IPROTO_SCHEMA_VERSION is optional, so the version will not be checked if it "
"is absent. In a response header IPROTO_SCHEMA_VERSION is always present, and"
" it is up to the client to check if it has changed."
msgstr ""
"**IPROTO_SCHEMA_VERSION** = 0x05. Беззнаковое число, иногда называемое "
"SCHEMA_ID, которое увеличивается при значительных изменениях. В заголовке "
"запроса IPROTO_SCHEMA_VERSION указываеть необязательно, поэтому версия не "
"будет проверяться, если она отсутствует. В заголовке ответа "
"IPROTO_SCHEMA_VERSION присутствует всегда, и клиент должен сам проверить, не"
" изменилась ли версия."

msgid ""
"**IPROTO_STREAM_ID** = 0x0a. An unsigned number that should be unique in "
"every stream. In requests IPROTO_STREAM_ID is optional and is useful for two"
" things: ensuring that requests within transactions are done in separate "
"groups, and ensuring strictly consistent execution of requests (whether or "
"not they are within transactions). In responses IPROTO_STREAM_ID does not "
"appear. See :ref:`Binary protocol -- streams <box_protocol-streams>`."
msgstr ""
"**IPROTO_STREAM_ID** = 0x0a. Беззнаковое число, которое должно быть "
"уникально для каждого стрима. В запросах указывать значение IPROTO_STREAM_ID"
" необязательно. Однако оно может понадобиться, если необходимо обрабатывать "
"запросы внутри транзакций отдельными группами или выполнять запросы строго "
"последовательно независимо от того, входят ли они в ту или иную транзакцию. "
"В ответах IPROTO_STREAM_ID отсутствует. См. :ref:`Бинарный протокол -- "
"стримы<box_protocol-streams>`."

msgid ""
"Have a look at file `xrow.c "
"<https://github.com/tarantool/tarantool/blob/master/src/box/xrow.c>`_ "
"function ``xrow_header_encode``, to see how Tarantool encodes the header. "
"Have a look at file net_box.c, function ``netbox_decode_data``, to see how "
"Tarantool decodes the header. For example, in a successful response to "
"``box.space:select()``, the Response-Code-Indicator value will be 0 = "
"IPROTO_OK and the array will have all the tuples of the result."
msgstr ""
"Чтобы понять, как Tarantool кодирует заголовок, обратите внимание на функцию"
" ``xrow_header_encode`` в файле `xrow.c "
"<https://github.com/tarantool/tarantool/blob/master/src/box/xrow.c>`_. Чтобы"
" увидеть, как Tarantool декодирует заголовок, посмотрите функцию "
"``netbox_decode_data`` в файле net_box.c. Например, при успешном ответе на "
"``box.space:select()`` значение индикатора кода ответа будет 0 = IPROTO_OK, "
"а массив будет содержать все кортежи из результата."

msgid ""
"The ``<body>`` has the details of the request or response. In a request, it "
"can also be absent or be an empty map. Both these states will be interpreted"
" equally. Responses will contain the ``<body>`` anyway even for an "
":ref:`IPROTO_PING <box_protocol-ping>` request."
msgstr ""
"Тело сообщения ``<body>`` содержит детали запроса или ответа. В запросе оно "
"может отсутствовать или представлять собой пустой ассоциативный массив. И "
"то, и другое будет интерпретироваться одинаково. Ответы будут содержать "
"``<body>`` в любом случае, даже после запроса :ref:`IPROTO_PING "
"<box_protocol-ping>`."

msgid "Binary protocol -- requests"
msgstr "Бинарный протокол — запросы"

msgid ""
"A request has a size, a :ref:`header <box_protocol-header>` that contains "
"the IPROTO key, and a body as described here."
msgstr ""
"Запрос содержит размер, :ref:`заголовок <box_protocol-header>`, который "
"содержит ключ IPROTO, и тело сообщения, как описано в этом разделе."

msgid "**IPROTO_SELECT** = 0x01."
msgstr "**IPROTO_SELECT** = 0x01."

msgid ""
"See :ref:`space_object:select()  <box_space-select>`. The body is a 6-item "
"map."
msgstr ""
"См. :ref:`space_object:select() <box_space-select>`. Тело сообщения "
"представляет собой ассоциативный массив из 6 элементов."

msgid ""
"# <size>\n"
"msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
"# <header>\n"
"msgpack({\n"
"    IPROTO_REQUEST_TYPE: IPROTO_SELECT,\n"
"    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_SPACE_ID: :samp:`{{MP_UINT unsigned integer}}`,\n"
"    IPROTO_INDEX_ID: :samp:`{{MP_UINT unsigned integer}}`,\n"
"    IPROTO_LIMIT: :samp:`{{MP_UINT unsigned integer}}`,\n"
"    IPROTO_OFFSET: :samp:`{{MP_UINT unsigned integer}}`,\n"
"    IPROTO_ITERATOR: :samp:`{{MP_UINT unsigned integer}}`,\n"
"    IPROTO_KEY: :samp:`{{MP_ARRAY array of key values}}`\n"
"})"
msgstr ""
"# <size>\n"
"msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
"# <header>\n"
"msgpack({\n"
"    IPROTO_REQUEST_TYPE: IPROTO_SELECT,\n"
"    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_SPACE_ID: :samp:`{{MP_UINT unsigned integer}}`,\n"
"    IPROTO_INDEX_ID: :samp:`{{MP_UINT unsigned integer}}`,\n"
"    IPROTO_LIMIT: :samp:`{{MP_UINT unsigned integer}}`,\n"
"    IPROTO_OFFSET: :samp:`{{MP_UINT unsigned integer}}`,\n"
"    IPROTO_ITERATOR: :samp:`{{MP_UINT unsigned integer}}`,\n"
"    IPROTO_KEY: :samp:`{{MP_ARRAY array of key values}}`\n"
"})"

msgid ""
"Example: if the id of 'tspace' is 512 and this is the fifth message, |br| "
":samp:`{conn}.`:code:`space.tspace:select({0},{iterator='GT',offset=1,limit=2})`"
" will cause:"
msgstr ""
"Пример: если ID спейса 'tspace' = 512 и это пятое сообщение, |br| "
":samp:`{conn}.`:code:`space.tspace:select({0},{iterator='GT',offset=1,limit=2})`"
" вызовет:"

msgid ""
"<size>\n"
"msgpack(21)\n"
"# <header>\n"
"msgpack({\n"
"    IPROTO_SYNC: 5,\n"
"    IPROTO_REQUEST_TYPE: IPROTO_SELECT\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_SPACE_ID: 512,\n"
"    IPROTO_INDEX_ID: 0,\n"
"    IPROTO_ITERATOR: 6,\n"
"    IPROTO_OFFSET: 1,\n"
"    IPROTO_LIMIT: 2,\n"
"    IPROTO_KEY: [1]\n"
"})"
msgstr ""
"<size>\n"
"msgpack(21)\n"
"# <header>\n"
"msgpack({\n"
"    IPROTO_SYNC: 5,\n"
"    IPROTO_REQUEST_TYPE: IPROTO_SELECT\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_SPACE_ID: 512,\n"
"    IPROTO_INDEX_ID: 0,\n"
"    IPROTO_ITERATOR: 6,\n"
"    IPROTO_OFFSET: 1,\n"
"    IPROTO_LIMIT: 2,\n"
"    IPROTO_KEY: [1]\n"
"})"

msgid ""
"Later in :ref:`Binary protocol -- illustration <box_protocol-illustration>` "
"we will show actual byte codes of an IPROTO_SELECT message."
msgstr ""
"Далее, в разделе :ref:`Бинарный протокол — примеры <box_protocol-"
"illustration>`, мы покажем фактические байт-коды сообщения IPROTO_SELECT."

msgid "**IPROTO_INSERT** = 0x02."
msgstr "**IPROTO_INSERT** = 0x02."

msgid ""
"See :ref:`space_object:insert()  <box_space-insert>`. The body is a 2-item "
"map:"
msgstr ""
"См. :ref:`space_object:insert()  <box_space-insert>`. Тело сообщения "
"представляет собой ассоциативный массив из 2 элементов:"

msgid ""
"# <size>\n"
"msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
"# <header>\n"
"msgpack({\n"
"    IPROTO_REQUEST_TYPE: IPROTO_INSERT,\n"
"    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_SPACE_ID: :samp:`{{MP_UINT unsigned integer}}`,\n"
"    IPROTO_TUPLE: :samp:`{{MP_ARRAY array of field values}}`\n"
"})"
msgstr ""
"# <size>\n"
"msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
"# <header>\n"
"msgpack({\n"
"    IPROTO_REQUEST_TYPE: IPROTO_INSERT,\n"
"    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_SPACE_ID: :samp:`{{MP_UINT unsigned integer}}`,\n"
"    IPROTO_TUPLE: :samp:`{{MP_ARRAY array of field values}}`\n"
"})"

msgid ""
"Example: if the id of 'tspace' is 512 and this is the fifth message, |br| "
":samp:`{conn}.`:code:`space.tspace:insert{1, 'AAA'}` will cause:"
msgstr ""
"Пример: если ID спейса 'tspace' = 512 и это пятое сообщение, |br| "
":samp:`{conn}.`:code:`space.tspace:insert{1, 'AAA'}` вызовет:"

msgid ""
"# <size>\n"
"msgpack(17)\n"
"# <header>\n"
"msgpack({\n"
"    IPROTO_REQUEST_TYPE: IPROTO_INSERT,\n"
"    IPROTO_SYNC: 5\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_SPACE_ID: 512,\n"
"    IPROTO_TUPLE: [1, 'AAA']\n"
"})"
msgstr ""
"# <size>\n"
"msgpack(17)\n"
"# <header>\n"
"msgpack({\n"
"    IPROTO_REQUEST_TYPE: IPROTO_INSERT,\n"
"    IPROTO_SYNC: 5\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_SPACE_ID: 512,\n"
"    IPROTO_TUPLE: [1, 'AAA']\n"
"})"

msgid ""
"**IPROTO_REPLACE** = 0x03, See :ref:`space_object:replace()  <box_space-"
"replace>`. The body is a 2-item map, the same as for IPROTO_INSERT:"
msgstr ""
"**IPROTO_REPLACE** = 0x03, см. :ref:`space_object:replace()  <box_space-"
"replace>`. Тело сообщения представляет собой ассоциативный массив из 2 "
"элементов, как для IPROTO_INSERT:"

msgid ""
"# <size>\n"
"msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
"# <header>\n"
"msgpack({\n"
"    IPROTO_REQUEST_TYPE: IPROTO_REPLACE,\n"
"    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_SPACE_ID: :samp:`{{MP_UINT unsigned integer}}`,\n"
"    IPROTO_TUPLE: :samp:`{{MP_ARRAY array of field values}}`\n"
"})"
msgstr ""
"# <size>\n"
"msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
"# <header>\n"
"msgpack({\n"
"    IPROTO_REQUEST_TYPE: IPROTO_REPLACE,\n"
"    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_SPACE_ID: :samp:`{{MP_UINT unsigned integer}}`,\n"
"    IPROTO_TUPLE: :samp:`{{MP_ARRAY array of field values}}`\n"
"})"

msgid "**IPROTO_UPDATE** = 0x04."
msgstr "**IPROTO_UPDATE** = 0x04."

msgid "See :ref:`space_object:update()  <box_space-update>`."
msgstr "См. :ref:`space_object:update()  <box_space-update>`."

msgid "The body is usually a 4-item map:"
msgstr ""
"Тело сообщения обычно представляет собой ассоциативный массив из 4 "
"элементов:"

msgid ""
"# <size>\n"
"msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
"# <header>\n"
"msgpack({\n"
"    IPROTO_REQUEST_TYPE: IPROTO_UPDATE,\n"
"    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_SPACE_ID: :samp:`{{MP_UINT unsigned integer}}`,\n"
"    IPROTO_INDEX_ID: :samp:`{{MP_UINT unsigned integer}}`,\n"
"    IPROTO_KEY: :samp:`{{MP_ARRAY array of index keys}}`,\n"
"    IPROTO_TUPLE: :samp:`{{MP_ARRAY array of update operations}}`\n"
"})"
msgstr ""
"# <size>\n"
"msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
"# <header>\n"
"msgpack({\n"
"    IPROTO_REQUEST_TYPE: IPROTO_UPDATE,\n"
"    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_SPACE_ID: :samp:`{{MP_UINT unsigned integer}}`,\n"
"    IPROTO_INDEX_ID: :samp:`{{MP_UINT unsigned integer}}`,\n"
"    IPROTO_KEY: :samp:`{{MP_ARRAY array of index keys}}`,\n"
"    IPROTO_TUPLE: :samp:`{{MP_ARRAY array of update operations}}`\n"
"})"

msgid ""
"If the operation specifies no values, then IPROTO_TUPLE is a 2-item array: "
"|br| :samp:`[{MP_STR OPERATOR = '#', {MP_INT FIELD_NO = field number "
"starting with 1}]`. Normally field numbers start with 1."
msgstr ""
"Если в операции не указаны значения, то IPROTO_TUPLE — это массив из 2 "
"элементов: |br| :samp:`[{MP_STR OPERATOR = '#', {MP_INT FIELD_NO = номер "
"поля, начиная с 1}]`. Обычно номера полей начинаются с 1."

msgid ""
"If the operation specifies one value, then IPROTO_TUPLE is a 3-item array: "
"|br| :samp:`[{MP_STR string OPERATOR = '+' or '-' or '^' or '^' or '|' or "
"'!' or '='}, {MP_INT FIELD_NO}, {MP_OBJECT VALUE}]`. |br|"
msgstr ""
"Если в операции задано одно значение, то IPROTO_TUPLE — это массив из трех "
"элементов: |br| :samp:`[{MP_STR string OPERATOR = '+' or '-' or '^' or '^' "
"or '|' or '!' or '='}, {MP_INT FIELD_NO}, {MP_OBJECT VALUE}]`. |br|"

msgid ""
"Otherwise IPROTO_TUPLE is a 5-item array: |br| :samp:`[{MP_STR string "
"OPERATOR = ':'}, {MP_INT integer FIELD_NO}, {MP_INT POSITION}, {MP_INT "
"OFFSET}, {MP_STR VALUE}]`. |br|"
msgstr ""
"В остальных случаях IPROTO_TUPLE — это массив из 5 элементов: |br| "
":samp:`[{MP_STR string OPERATOR = ':'}, {MP_INT integer FIELD_NO}, {MP_INT "
"POSITION}, {MP_INT OFFSET}, {MP_STR VALUE}]`. |br|"

msgid ""
"Example: if the id of 'tspace' is 512 and this is the fifth message, |br| "
":samp:`{conn}.`:code:`space.tspace:update(999, {{'=', 2, 'B'}})` will cause:"
msgstr ""
"Пример: если ID спейса 'tspace' = 512 и это пятое сообщение, br| "
":samp:`{conn}.`:code:`space.tspace:update(999, {{'=', 2, 'B'}})` вызовет:"

msgid ""
"# <size>\n"
"msgpack(17)\n"
"# <header>\n"
"msgpack({\n"
"    IPROTO_REQUEST_TYPE: IPROTO_UPDATE,\n"
"    IPROTO_SYNC: 5\n"
"})\n"
"# <body> ... the map-item IPROTO_INDEX_BASE is optional\n"
"msgpack({\n"
"    IPROTO_SPACE_ID: 512,\n"
"    IPROTO_INDEX_ID: 0,\n"
"    IPROTO_INDEX_BASE: 1,\n"
"    IPROTO_TUPLE: [['=',2,'B']],\n"
"    IPROTO_KEY: [999]\n"
"})"
msgstr ""
"# <size>\n"
"msgpack(17)\n"
"# <header>\n"
"msgpack({\n"
"    IPROTO_REQUEST_TYPE: IPROTO_UPDATE,\n"
"    IPROTO_SYNC: 5\n"
"})\n"
"# <body> ... the map-item IPROTO_INDEX_BASE is optional\n"
"msgpack({\n"
"    IPROTO_SPACE_ID: 512,\n"
"    IPROTO_INDEX_ID: 0,\n"
"    IPROTO_INDEX_BASE: 1,\n"
"    IPROTO_TUPLE: [['=',2,'B']],\n"
"    IPROTO_KEY: [999]\n"
"})"

msgid ""
"Later in :ref:`Binary protocol -- illustration <box_protocol-illustration>` "
"we will show actual byte codes of an IPROTO_UPDATE message."
msgstr ""
"Далее, в разделе :ref:`Бинарный протокол — примеры <box_protocol-"
"illustration>`, мы покажем фактические байт-коды сообщения IPROTO_UPDATE."

msgid "**IPROTO_DELETE** = 0x05."
msgstr "**IPROTO_DELETE** = 0x05."

msgid ""
"See :ref:`space_object:delete()  <box_space-delete>`. The body is a 3-item "
"map:"
msgstr ""
"См. :ref:`space_object:delete()  <box_space-delete>`. Тело сообщения "
"представляет собой ассоциативный массив из 3 элементов:"

msgid ""
"# <size>\n"
"msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
"# <header>\n"
"msgpack({\n"
"    IPROTO_REQUEST_TYPE: IPROTO_DELETE,\n"
"    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_SPACE_ID: :samp:`{{MP_UINT unsigned integer}}`,\n"
"    IPROTO_INDEX_ID: :samp:`{{MP_UINT unsigned integer}}`,\n"
"    IPROTO_KEY: :samp:`{{MP_ARRAY array of key values}}`\n"
"})"
msgstr ""
"# <size>\n"
"msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
"# <header>\n"
"msgpack({\n"
"    IPROTO_REQUEST_TYPE: IPROTO_DELETE,\n"
"    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_SPACE_ID: :samp:`{{MP_UINT unsigned integer}}`,\n"
"    IPROTO_INDEX_ID: :samp:`{{MP_UINT unsigned integer}}`,\n"
"    IPROTO_KEY: :samp:`{{MP_ARRAY array of key values}}`\n"
"})"

msgid "**IPROTO_CALL_16** = 0x06."
msgstr "**IPROTO_CALL_16** = 0x06."

msgid ""
"See :ref:`conn:call() <net_box-call>`. The suffix ``_16`` is a hint that "
"this is for the ``call()`` until Tarantool 1.6. It is deprecated. Use "
":ref:`IPROTO_CALL <box_protocol-call>` instead. The body is a 2-item map:"
msgstr ""
"См. :ref:`conn:call() <net_box-call>`. ``_16`` в конце подсказывает, что "
"константа используется для ``call()`` до версии Tarantool 1.6. Эта константа"
" объявлена устаревшей. Вместо нее используйте :ref:`IPROTO_CALL "
"<box_protocol-call>`. Тело сообщения представляет собой ассоциативный массив"
" из 2 элементов:"

msgid ""
"# <size>\n"
"msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
"# <header>\n"
"msgpack({\n"
"    IPROTO_REQUEST_TYPE: IPROTO_CALL_16,\n"
"    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_FUNCTION_NAME: :samp:`{{MP_STR string}}`,\n"
"    IPROTO_TUPLE: :samp:`{{MP_ARRAY array of arguments}}`\n"
"})"
msgstr ""
"# <size>\n"
"msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
"# <header>\n"
"msgpack({\n"
"    IPROTO_REQUEST_TYPE: IPROTO_CALL_16,\n"
"    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_FUNCTION_NAME: :samp:`{{MP_STR string}}`,\n"
"    IPROTO_TUPLE: :samp:`{{MP_ARRAY array of arguments}}`\n"
"})"

msgid "The return value is an array of tuples."
msgstr "Возвращается массив кортежей."

msgid "**IPROTO_AUTH** = 0x07."
msgstr "**IPROTO_AUTH** = 0x07."

msgid ""
"See :ref:`authentication <authentication-users>`. See the later section "
":ref:`Binary protocol -- authentication <box_protocol-authentication>`."
msgstr ""
"См. раздел :ref:`Аутентификация <authentication-users>`. См. раздел "
":ref:`Бинарный протокол — аутентификация <box_protocol-authentication>` "
"ниже."

msgid "**IPROTO_EVAL** = 0x08."
msgstr "**IPROTO_EVAL** = 0x08."

msgid ""
"See :ref:`conn:eval() <net_box-eval>`. Since the argument is a Lua "
"expression, this is Tarantool's way to handle non-binary with the binary "
"protocol. Any request that does not have its own code, for example "
":samp:`box.space.{space-name}:drop()`, will be handled either with "
":ref:`IPROTO_CALL <box_protocol-call>` or IPROTO_EVAL. The "
":ref:`tarantoolctl <tarantoolctl>` administrative utility makes extensive "
"use of ``eval``. The body is a 2-item map:"
msgstr ""
"См. :ref:`conn:eval() <net_box-eval>`. В качестве аргумента выступает "
"выражение на Lua — так Tarantool обрабатывает небинарный код с помощью "
"бинарного протокола. Любой запрос без собственного кода, например "
":samp:`box.space.{space-name}:drop()`, будет обработан с помощью либо "
":ref:`IPROTO_CALL <box_protocol-call>`, либо IPROTO_EVAL. Административная "
"утилита :ref:`tarantoolctl <tarantoolctl>` активно использует ``eval``. Тело"
" сообщения представляет собой ассоциативный массив из 2 элементов:"

msgid ""
"# <size>\n"
"msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
"# <header>\n"
"msgpack({\n"
"    IPROTO_REQUEST_TYPE: IPROTO_EVAL,\n"
"    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_EXPR: :samp:`{{MP_STR string}}`,\n"
"    IPROTO_TUPLE: :samp:`{{MP_ARRAY array of arguments}}`\n"
"})"
msgstr ""
"# <size>\n"
"msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
"# <header>\n"
"msgpack({\n"
"    IPROTO_REQUEST_TYPE: IPROTO_EVAL,\n"
"    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_EXPR: :samp:`{{MP_STR string}}`,\n"
"    IPROTO_TUPLE: :samp:`{{MP_ARRAY array of arguments}}`\n"
"})"

msgid ""
"Example: if this is the fifth message, :samp:`conn:eval('return 5;')` will "
"cause:"
msgstr ""
"Пример. Если это пятое сообщение, :samp:`conn:eval('return 5;')` приведет к "
"следующему:"

msgid ""
"# <size>\n"
"msgpack(19)\n"
"# <header>\n"
"msgpack({\n"
"    IPROTO_SYNC: 5\n"
"    IPROTO_REQUEST_TYPE: IPROTO_EVAL\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_EXPR: 'return 5;',\n"
"    IPROTO_TUPLE: []\n"
"})"
msgstr ""
"# <size>\n"
"msgpack(19)\n"
"# <header>\n"
"msgpack({\n"
"    IPROTO_SYNC: 5\n"
"    IPROTO_REQUEST_TYPE: IPROTO_EVAL\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_EXPR: 'return 5;',\n"
"    IPROTO_TUPLE: []\n"
"})"

msgid "**IPROTO_UPSERT** = 0x09."
msgstr "**IPROTO_UPSERT** = 0x09."

msgid "See :ref:`space_object:upsert()  <box_space-upsert>`."
msgstr "См. :ref:`space_object:upsert()  <box_space-upsert>`."

msgid ""
"# <size>\n"
"msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
"# <header>\n"
"msgpack({\n"
"    IPROTO_REQUEST_TYPE: IPROTO_UPSERT,\n"
"    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_SPACE_ID: :samp:`{{MP_UINT unsigned integer}}`,\n"
"    IPROTO_INDEX_BASE: :samp:`{{MP_UINT unsigned integer}}`,\n"
"    IPROTO_OPS: :samp:`{{MP_ARRAY array of update operations}}`,\n"
"    IPROTO_TUPLE: :samp:`{{MP_ARRAY array of primary-key field values}}`\n"
"})"
msgstr ""
"# <size>\n"
"msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
"# <header>\n"
"msgpack({\n"
"    IPROTO_REQUEST_TYPE: IPROTO_UPSERT,\n"
"    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_SPACE_ID: :samp:`{{MP_UINT unsigned integer}}`,\n"
"    IPROTO_INDEX_BASE: :samp:`{{MP_UINT unsigned integer}}`,\n"
"    IPROTO_OPS: :samp:`{{MP_ARRAY array of update operations}}`,\n"
"    IPROTO_TUPLE: :samp:`{{MP_ARRAY array of primary-key field values}}`\n"
"})"

msgid ""
"The IPROTO_OPS is the same as the IPROTO_TUPLE of :ref:`IPROTO_UPDATE "
"<box_protocol-update>`."
msgstr ""
"IPROTO_OPS — это то же самое, что и IPROTO_TUPLE в :ref:`IPROTO_UPDATE "
"<box_protocol-update>`."

msgid "**IPROTO_CALL** = 0x0a."
msgstr "**IPROTO_CALL** = 0x0a."

msgid "See :ref:`conn:call() <net_box-call>`. The body is a 2-item map:"
msgstr ""
"См. :ref:`conn:call() <net_box-call>`. Тело сообщения представляет собой "
"ассоциативный массив из 2 элементов:"

msgid ""
"# <size>\n"
"msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
"# <header>\n"
"msgpack({\n"
"    IPROTO_REQUEST_TYPE: IPROTO_CALL,\n"
"    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_FUNCTION_NAME: :samp:`{{MP_STR string}}`,\n"
"    IPROTO_TUPLE: :samp:`{{MP_ARRAY array of arguments}}`\n"
"})"
msgstr ""
"# <size>\n"
"msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
"# <header>\n"
"msgpack({\n"
"    IPROTO_REQUEST_TYPE: IPROTO_CALL,\n"
"    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_FUNCTION_NAME: :samp:`{{MP_STR string}}`,\n"
"    IPROTO_TUPLE: :samp:`{{MP_ARRAY array of arguments}}`\n"
"})"

msgid ""
"The response will be a list of values, similar to the :ref:`IPROTO_EVAL "
"<box_protocol-eval>` response."
msgstr ""
"Вернется список значений, наподобие ответа :ref:`IPROTO_EVAL <box_protocol-"
"eval>`."

msgid "**IPROTO_EXECUTE** = 0x0b."
msgstr "**IPROTO_EXECUTE** = 0x0b."

msgid ""
"See :ref:`box.execute() <box-sql_box_execute>`, this is only for SQL. The "
"body is a 3-item map:"
msgstr ""
"См. :ref:`box.execute() <box-sql_box_execute>`, используется только для SQL."
" Тело сообщения представляет собой ассоциативный массив из 3 элементов:"

msgid ""
"# <size>\n"
"msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
"# <header>\n"
"msgpack({\n"
"    IPROTO_REQUEST_TYPE: IPROTO_EXECUTE,\n"
"    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_STMT_ID: :samp:`{{MP_INT integer}}` or IPROTO_SQL_TEXT: :samp:`{{MP_STR string}}`,\n"
"    IPROTO_SQL_BIND: :samp:`{{MP_INT integer}}`,\n"
"    IPROTO_OPTIONS: :samp:`{{MP_ARRAY array}}`\n"
"})"
msgstr ""
"# <size>\n"
"msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
"# <header>\n"
"msgpack({\n"
"    IPROTO_REQUEST_TYPE: IPROTO_EXECUTE,\n"
"    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_STMT_ID: :samp:`{{MP_INT integer}}` или IPROTO_SQL_TEXT: :samp:`{{MP_STR string}}`,\n"
"    IPROTO_SQL_BIND: :samp:`{{MP_INT integer}}`,\n"
"    IPROTO_OPTIONS: :samp:`{{MP_ARRAY array}}`\n"
"})"

msgid ""
"Use IPROTO_STMT_ID (0x43) and statement-id (MP_INT) if executing a prepared "
"statement, or use IPROTO_SQL_TEXT (0x40) and statement-text (MP_STR) if "
"executing an SQL string, then IPROTO_SQL_BIND (0x41) and array of parameter "
"values to match ? placeholders or :name placeholders, IPROTO_OPTIONS (0x2b) "
"and array of options (usually empty)."
msgstr ""
"При выполнении подготовленного оператора используйте IPROTO_STMT_ID (0x43) и"
" ID оператора (MP_INT), при работе со строками SQL — IPROTO_SQL_TEXT (0x40) "
"и текст оператора (MP_STR), а затем IPROTO_SQL_BIND (0x41) и массив значений"
" параметров для подстановочных знаков ``?`` или ``:name``, IPROTO_OPTIONS "
"(0x2b) и массив параметров (обычно пустой)."

msgid ""
"For example, suppose we prepare a statement with two ? placeholders, and "
"execute with two parameters, thus: |br| :code:`n = conn:prepare([[VALUES (?,"
" ?);]])` |br| :code:`conn:execute(n.stmt_id, {1,'a'})` |br| Then the body "
"will look like this:"
msgstr ""
"Например, предположим, что мы создаем подготовленный оператор с двумя "
"подстановочными знаками ? и выполняем его с двумя параметрами таким образом:"
" |br| :code:`n = conn:prepare([[VALUES (?, ?);]])` |br| "
":code:`conn:execute(n.stmt_id, {1,'a'})` |br| Тогда тело сообщения будет "
"выглядеть так:"

msgid ""
"# <body>\n"
"msgpack({\n"
"    IPROTO_STMT_ID: 0xd7aa741b,\n"
"    IPROTO_SQL_BIND: [1, 'a'],\n"
"    IPROTO_OPTIONS: []\n"
"})"
msgstr ""
"# <body>\n"
"msgpack({\n"
"    IPROTO_STMT_ID: 0xd7aa741b,\n"
"    IPROTO_SQL_BIND: [1, 'a'],\n"
"    IPROTO_OPTIONS: []\n"
"})"

msgid ""
"Later in :ref:`Binary protocol -- illustration <box_protocol-illustration>` "
"we will show actual byte codes of the IPROTO_EXECUTE message."
msgstr ""
"Далее, в разделе :ref:`Бинарный протокол — примеры <box_protocol-"
"illustration>`, мы покажем фактические байт-коды сообщения IPROTO_EXECUTE."

msgid ""
"To call a prepared statement with named parameters from a connector pass the"
" parameters within an array of maps. A client should wrap each element into "
"a map, where the key holds a name of the parameter (with a colon) and the "
"value holds an actual value. So, to bind foo and bar to 42 and 43, a client "
"should send ``IPROTO_SQL_TEXT: <...>, IPROTO_SQL_BIND: [{\"foo\": 42}, "
"{\"bar\": 43}]``."
msgstr ""
"Чтобы вызвать подготовленный оператор с именованными параметрами из "
"коннектора, передайте параметры в массиве ассоциативных массивов. Клиент "
"должен поместить каждый элемент в ассоциативный массив, где ключ содержит "
"имя параметра (с двоеточием), а значение — фактическое значение. Так, чтобы "
"связать foo и bar с 42 и 43, клиент должен отправить ``IPROTO_SQL_TEXT: "
"<...>, IPROTO_SQL_BIND: [{\"foo\": 42}, {\"bar\": 43}]``."

msgid ""
"If a statement has both named and non-named parameters, wrap only named ones"
" into a map. The rest of the parameters are positional and will be "
"substituted in order."
msgstr ""
"Если оператор содержит как именованные, так и неименованные параметры, "
"поместите в ассоциативный массив только именованные параметры. Остальные "
"параметры являются позиционными и будут подставляться по порядку."

msgid "**IPROTO_NOP** = 0x0c."
msgstr "**IPROTO_NOP** = 0x0c."

msgid ""
"There is no Lua request exactly equivalent to IPROTO_NOP. It causes the LSN "
"to be incremented. It could be sometimes used for updates where the old and "
"new values are the same, but the LSN must be increased because a data-change"
" must be recorded. The body is: nothing."
msgstr ""
"Нет такого запроса на Lua, который бы соответствовал IPROTO_NOP. IPROTO_NOP "
"приводит к увеличению LSN. Иногда константу можно использовать для "
"обновления значения, когда старое и новое значения одинаковы, но LSN нужно "
"увеличить, поскольку нужно зарегистрировать изменение данных. Тело сообщения"
" пустое."

msgid "**IPROTO_PREPARE** = 0x0d."
msgstr "**IPROTO_PREPARE** = 0x0d."

msgid ""
"See :ref:`box.prepare <box-sql_box_prepare>`, this is only for SQL. The body"
" is a 1-item map:"
msgstr ""
"См. :ref:`box.prepare <box-sql_box_prepare>`, используется только для SQL. "
"Тело сообщения представляет собой ассоциативный массив из 1 элемента:"

msgid ""
"# <size>\n"
"msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
"# <header>\n"
"msgpack({\n"
"    IPROTO_REQUEST_TYPE: IPROTO_PREPARE,\n"
"    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_STMT_ID: :samp:`{{MP_INT integer}}` or IPROTO_SQL_TEXT: :samp:`{{MP_STR string}}`\n"
"})"
msgstr ""
"# <size>\n"
"msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
"# <header>\n"
"msgpack({\n"
"    IPROTO_REQUEST_TYPE: IPROTO_PREPARE,\n"
"    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_STMT_ID: :samp:`{{MP_INT integer}}` или IPROTO_SQL_TEXT: :samp:`{{MP_STR string}}`\n"
"})"

msgid ""
"IPROTO_STMT_ID (0x43) and statement-id (MP_INT) if executing a prepared "
"statement or IPROTO_SQL_TEXT (0x40) and statement-text (string) if executing"
" an SQL string. Thus the IPROTO_PREPARE map item is the same as the first "
"item of the :ref:`IPROTO_EXECUTE <box_protocol-execute>` body."
msgstr ""
"При выполнении подготовленного оператора используйте IPROTO_STMT_ID (0x43) и"
" ID оператора (MP_INT), при работе со строками SQL --- IPROTO_SQL_TEXT "
"(0x40) и текст оператора (string). Таким образом, элемент ассоциативного "
"массива IPROTO_PREPARE — это то же самое, что и первый элемент тела "
"сообщения :ref:`IPROTO_EXECUTE <box_protocol-execute>`."

msgid "**IPROTO_BEGIN** = 0x0e."
msgstr "**IPROTO_BEGIN** = 0x0e."

msgid ""
"This is for starting a transaction. Typically the header will include "
"IPROTO_STREAM_ID. The body is: nothing. See the later section :ref:`Binary "
"protocol -- streams <box_protocol-streams>`."
msgstr ""
"Этот запрос начинает транзакцию. Как правило, заголовок запроса включает "
"IPROTO_STREAM_ID. Тело запроса пустое. См. раздел ниже :ref:`Бинарный "
"протокол -- стримы<box_protocol-streams>`."

msgid "**IPROTO_COMMIT** = 0x0f."
msgstr "**IPROTO_COMMIT** = 0x0f."

msgid ""
"This is for ending a transaction. Typically the header will include "
"IPROTO_STREAM_ID. The body is: nothing. See the later section :ref:`Binary "
"protocol -- streams <box_protocol-streams>`."
msgstr ""
"Этот запрос завершает транзакцию. Как правило, заголовок запроса включает "
"IPROTO_STREAM_ID. Тело запроса пустое. См. раздел ниже :ref:`Бинарный "
"протокол -- стримы<box_protocol-streams>`."

msgid "**IPROTO_ROLLBACK** = 0x10."
msgstr "**IPROTO_ROLLBACK** = 0x10."

msgid "**IPROTO_PING** = 0x40."
msgstr "**IPROTO_PING** = 0x40."

msgid ""
"See :ref:`conn:ping() <conn-ping>`. The body will be an empty map because "
"IPROTO_PING in the header contains all the information that the server "
"instance needs."
msgstr ""
"См. :ref:`conn:ping() <conn-ping>`. В теле сообщения будет пустой "
"ассоциативный массив, потому что IPROTO_PING в заголовке содержит всю "
"информацию, необходимую экземпляру сервера."

msgid ""
"# <size>\n"
"msgpack(5)\n"
"# <header>\n"
"msgpack({\n"
"    IPROTO_REQUEST_TYPE: IPROTO_PING,\n"
"    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`\n"
"})"
msgstr ""
"# <size>\n"
"msgpack(5)\n"
"# <header>\n"
"msgpack({\n"
"    IPROTO_REQUEST_TYPE: IPROTO_PING,\n"
"    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`\n"
"})"

msgid ""
"IPROTO_JOIN = 0x41 -- for replication\n"
"IPROTO_SUBSCRIBE = 0x42 -- for replication SUBSCRIBE\n"
"IPROTO_VOTE_DEPRECATED = 0x43 -- for old style vote, superseded by IPROTO_VOTE\n"
"IPROTO_VOTE = 0x44 -- for master election\n"
"IPROTO_FETCH_SNAPSHOT = 0x45 -- for starting anonymous replication\n"
"IPROTO_REGISTER = 0x46 -- for leaving anonymous replication."
msgstr ""
"IPROTO_JOIN = 0x41 — для репликации\n"
"IPROTO_SUBSCRIBE = 0x42 — для репликации SUBSCRIBE\n"
"IPROTO_VOTE_DEPRECATED = 0x43 — для устаревшего типа голосования, взамен используется IPROTO_VOTE\n"
"IPROTO_VOTE = 0x44 — для выбора мастера\n"
"IPROTO_FETCH_SNAPSHOT = 0x45 — для начала анонимной репликации\n"
"IPROTO_REGISTER = 0x46 — для выхода из анонимной репликации"

msgid ""
"Tarantool constants 0x41 to 0x46 (decimal 65 to 70) are for replication. "
"Connectors and clients do not need to send replication packets. See "
":ref:`Binary protocol -- replication <box_protocol-replication>`."
msgstr ""
"Константы Tarantool 0x41-0x46 (в десятичной системе 65-70) предназначены для"
" репликации. Коннекторы и клиенты не должны отправлять репликационные "
"пакеты. См. :ref:`Бинарный протокол — репликация <box_protocol-"
"replication>`."

msgid ""
"The next two IPROTO messages are used in replication connections between "
"Tarantool nodes in :ref:`synchronous replication <repl_sync>`. The messages "
"are not supposed to be used by any client applications in their regular "
"connections."
msgstr ""
"Следующие два сообщения IPROTO используются в соединениях репликации между "
"узлами Tarantool при :ref:`синхронной репликации <repl_sync>`. Эти сообщения"
" не должны использоваться клиентскими приложениями при обычном соединении."

msgid "**IPROTO_RAFT_CONFIRM** = 0x28"
msgstr "**IPROTO_RAFT_CONFIRM** = 0x28"

msgid ""
"This message confirms that the transactions originated from the instance "
"with id = IPROTO_REPLICA_ID have achieved quorum and can be committed, up to"
" and including LSN = IPROTO_LSN. Prior to Tarantool version 2.10-beta1, "
"IPROTO_RAFT_CONFIRM was called IPROTO_CONFIRM."
msgstr ""
"Это сообщение подтверждает, что транзакции до ``LSN = IPROTO_LSN`` "
"включительно из экземпляра с ``id = IPROTO_REPLICA_ID`` набрали кворум и "
"могут пройти коммит. До версии Tarantool 2.10-beta1 запрос "
"IPROTO_RAFT_CONFIRM назывался IPROTO_CONFIRM."

msgid "The body is a 2-item map:"
msgstr ""
"Тело сообщения представляет собой ассоциативный массив из 2 элементов:"

msgid ""
"# <size>\n"
"msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
"# <header>\n"
"msgpack({\n"
"    IPROTO_REQUEST_TYPE: IPROTO_RAFT_CONFIRM,\n"
"    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_REPLICA_ID: :samp:`{{MP_INT integer}}`,\n"
"    IPROTO_LSN: :samp:`{{MP_INT integer}}`\n"
"})"
msgstr ""
"# <size>\n"
"msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
"# <header>\n"
"msgpack({\n"
"    IPROTO_REQUEST_TYPE: IPROTO_RAFT_CONFIRM,\n"
"    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_REPLICA_ID: :samp:`{{MP_INT integer}}`,\n"
"    IPROTO_LSN: :samp:`{{MP_INT integer}}`\n"
"})"

msgid "**IPROTO_RAFT_ROLLBACK** = 0x29"
msgstr "**IPROTO_RAFT_ROLLBACK** = 0x29"

msgid ""
"This message says that the transactions originated from the instance with id"
" = IPROTO_REPLICA_ID couldn't achieve quorum for some reason and should be "
"rolled back, down to LSN = IPROTO_LSN and including it. Prior to Tarantool "
"version 2.10, IPROTO_RAFT_ROLLBACK was called IPROTO_ROLLBACK."
msgstr ""
"В этом сообщении говорится, что транзакции до ``LSN = IPROTO_LSN`` "
"включительно из экземпляра с ``id = IPROTO_REPLICA_ID`` не смогли набрать "
"кворум и будут отменены. До версии Tarantool 2.10 запрос "
"IPROTO_RAFT_ROLLBACK назывался IPROTO_ROLLBACK."

msgid ""
"# <size>\n"
"msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
"# <header>\n"
"msgpack({\n"
"    IPROTO_REQUEST_TYPE: IPROTO_RAFT_ROLLBACK,\n"
"    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_REPLICA_ID: :samp:`{{MP_INT integer}}`,\n"
"    IPROTO_LSN: :samp:`{{MP_INT integer}}`\n"
"})"
msgstr ""
"# <size>\n"
"msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
"# <header>\n"
"msgpack({\n"
"    IPROTO_REQUEST_TYPE: IPROTO_RAFT_ROLLBACK,\n"
"    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_REPLICA_ID: :samp:`{{MP_INT integer}}`,\n"
"    IPROTO_LSN: :samp:`{{MP_INT integer}}`\n"
"})"

msgid "Binary protocol -- responses if no error and no SQL"
msgstr "Бинарный протокол — ответы на запросы без ошибок и без SQL"

msgid ""
"After the :ref:`header <box_protocol-header>`, for a response, there will be"
" a body. If there was no error, it will contain IPROTO_OK (0x00). If there "
"was an error, it will contain an error code other than IPROTO_OK. Responses "
"to SQL statements are slightly different and will be described in the later "
"section, :ref:`Binary protocol -- responses for SQL <box_protocol-"
"sql_protocol>`."
msgstr ""
"В ответе после :ref:`заголовка <box_protocol-header>` идет тело сообщения. "
"Если ошибки не было, оно будет содержать IPROTO_OK (0x00). Если была ошибка,"
" то он будет содержать код ошибки, отличный от IPROTO_OK. Ответы на "
"операторы SQL немного отличаются и будут описаны в последующем разделе "
":ref:`Бинарный протокол — ответы на SQL-запросы <box_protocol-"
"sql_protocol>`."

msgid ""
"For IPROTO_OK, the header Response-Code-Indicator will be 0 and the body is "
"a 1-item map."
msgstr ""
"Для IPROTO_OK индикатор кода ответа в заголовке будет 0, а тело сообщения "
"будет представлять собой ассоциативный массив, состоящий из 1 элемента."

msgid ""
"# <size>\n"
"msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
"# <header>\n"
"msgpack({\n"
"    Response-Code-Indicator: IPROTO_OK,\n"
"    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer, may be 64-bit}}`,\n"
"    IPROTO_SCHEMA_VERSION: :samp:`{{MP_UINT unsigned integer}}`\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_DATA: :samp:`{{any type}}`\n"
"})"
msgstr ""
"# <size>\n"
"msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
"# <header>\n"
"msgpack({\n"
"    Response-Code-Indicator: IPROTO_OK,\n"
"    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer, may be 64-bit}}`,\n"
"    IPROTO_SCHEMA_VERSION: :samp:`{{MP_UINT unsigned integer}}`\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_DATA: :samp:`{{any type}}`\n"
"})"

msgid ""
"For :ref:`IPROTO_PING <box_protocol-ping>` the body will be an empty map. "
"For most data-access requests (IPROTO_SELECT IPROTO_INSERT IPROTO_DELETE "
"etc.) the body is an IPROTO_DATA map with an array of tuples that contain an"
" array of fields. For :ref:`IPROTO_EVAL <box_protocol-eval>` and "
":ref:`IPROTO_CALL <box_protocol-call>` it will usually be an array but, "
"since Lua requests can result in a wide variety of structures, bodies can "
"have a wide variety of structures."
msgstr ""
"В теле сообщения :ref:`IPROTO_PING <box_protocol-ping>` будет пустой "
"ассоциативный массив. В теле большинства запросов доступа к данным "
"(IPROTO_SELECT, IPROTO_INSERT, IPROTO_DELETE и т.д.) будет ассоциативный "
"массив IPROTO_DATA с массивом кортежей, содержащих массив полей. Для "
":ref:`IPROTO_EVAL <box_protocol-eval>` и :ref:`IPROTO_CALL <box_protocol-"
"call>` телом обычно будет массив, но поскольку запросы на Lua могут "
"возвращать самые разные структуры, сами тела могут содержать самые разные "
"структуры."

msgid ""
"Example: if this is the fifth message and the request is "
":codenormal:`box.space.`:codeitalic:`space-name`:codenormal:`:insert{6}`, "
"and the previous schema version was 100, a successful response will look "
"like this:"
msgstr ""
"Пример: если это пятое сообщение, запрос такой: "
":codenormal:`box.space.`:codeitalic:`space-name`:codenormal:`:insert{6}`, и "
"предыдущая версия схемы была 100, ответ после успешного выполнения будет "
"выглядеть следующим образом:"

msgid ""
"# <size>\n"
"msgpack(32)\n"
"# <header>\n"
"msgpack({\n"
"    Response-Code-Indicator: IPROTO_OK,\n"
"    IPROTO_SYNC: 5,\n"
"    IPROTO_SCHEMA_VERSION: 100\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_DATA: [[6]]\n"
"})"
msgstr ""
"# <size>\n"
"msgpack(32)\n"
"# <header>\n"
"msgpack({\n"
"    Response-Code-Indicator: IPROTO_OK,\n"
"    IPROTO_SYNC: 5,\n"
"    IPROTO_SCHEMA_VERSION: 100\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_DATA: [[6]]\n"
"})"

msgid ""
"Later in :ref:`Binary protocol -- illustration <box_protocol-illustration>` "
"we will show actual byte codes of the response to the IPROTO_INSERT message."
msgstr ""
"Далее, в разделе :ref:`Бинарный протокол — примеры <box_protocol-"
"illustration>`, мы покажем фактические байт-коды ответа на сообщение "
"IPROTO_INSERT."

msgid ""
"IPROTO_DATA is what we get with net_box and :ref:`Module buffer <buffer-"
"module>` so if we were using net_box we could decode with "
":ref:`msgpack.decode_unchecked() <msgpack-decode_unchecked_string>`, or we "
"could convert to a string with :samp:`ffi.string({pointer},{length})`. The "
":ref:`pickle.unpack() <pickle-unpack>` function might also be helpful."
msgstr ""
"IPROTO_DATA возвращается в результате использования net_box и :ref:`модуля "
"buffer <buffer-module>`. То есть если бы мы использовали net_box, то могли "
"бы интерпретировать результат с помощью :ref:`msgpack.decode_unchecked() "
"<msgpack-decode_unchecked_string>` или преобразовать его в строку с помощью "
":samp:`ffi.string({pointer},{length})`. Также здесь можно использовать "
"функцию :ref:`pickle.unpack() <pickle-unpack>`."

msgid "Binary protocol -- responses for errors"
msgstr "Бинарный протокол — ответы на запросы c ошибками"

msgid ""
"For a response other than IPROTO_OK, the header Response-Code-Indicator will"
" be ``0x8XXX`` and the body will be a 1-item map."
msgstr ""
"Для ответа, отличного от IPROTO_OK, индикатор кода ответа в заголовке будет "
"``0x8XXX``, а тело будет представлять собой ассоциативный массив, состоящий "
"из 1 элемента."

msgid ""
"# <size>\n"
"msgpack(32)\n"
"# <header>\n"
"msgpack({\n"
"    Response-Code-Indicator: :samp:`{{0x8XXX}}`,\n"
"    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer, may be 64-bit}}`,\n"
"    IPROTO_SCHEMA_VERSION: :samp:`{{MP_UINT unsigned integer}}`\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_ERROR: :samp:`{{MP_STRING string}}`\n"
"})"
msgstr ""
"# <size>\n"
"msgpack(32)\n"
"# <header>\n"
"msgpack({\n"
"    Response-Code-Indicator: :samp:`{{0x8XXX}}`,\n"
"    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer, may be 64-bit}}`,\n"
"    IPROTO_SCHEMA_VERSION: :samp:`{{MP_UINT unsigned integer}}`\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_ERROR: :samp:`{{MP_STRING string}}`\n"
"})"

msgid ""
"where ``0x8XXX`` is the indicator for an error and ``XXX`` is a value in "
"`src/box/errcode.h "
"<https://github.com/tarantool/tarantool/blob/master/src/box/errcode.h>`_. "
"``src/box/errcode.h`` also has some convenience macros which define "
"hexadecimal constants for return codes."
msgstr ""
"где ``0x8XXX`` — это индикатор ошибки, а ``XXX`` — это значение из файла "
"`src/box/errcode.h "
"<https://github.com/tarantool/tarantool/blob/master/src/box/errcode.h>`_. В "
"``src/box/errcode.h`` также есть несколько удобных макросов, которые "
"определяют шестнадцатеричные константы для кодов возврата."

msgid ""
"Example: in version 2.4.0 and earlier, if this is the fifth message and the "
"request is to create a duplicate space with "
"``conn:eval([[box.schema.space.create('_space');]])`` the unsuccessful "
"response will look like this:"
msgstr ""
"Пример: в версии 2.4.0 и раньше, если это пятое сообщение и отправляется "
"запрос на создание дубликата спейса с помощью "
"``conn:eval([[box.schema.space.create('_space');]])``, то ответ на "
"невыполненный запрос будет выглядеть следующим образом:"

msgid ""
"# <size>\n"
"msgpack(32)\n"
"# <header>\n"
"msgpack({\n"
"    Response-Code-Indicator: 0x800a,\n"
"    IPROTO_SYNC: 5,\n"
"    IPROTO_SCHEMA_VERSION: 0x78\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_ERROR:  \"Space '_space' already exists\"\n"
"})"
msgstr ""
"# <size>\n"
"msgpack(32)\n"
"# <header>\n"
"msgpack({\n"
"    Response-Code-Indicator: 0x800a,\n"
"    IPROTO_SYNC: 5,\n"
"    IPROTO_SCHEMA_VERSION: 0x78\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_ERROR:  \"Space '_space' already exists\"\n"
"})"

msgid ""
"Later in :ref:`Binary protocol -- illustration <box_protocol-illustration>` "
"we will show actual byte codes of the response to the IPROTO_EVAL message."
msgstr ""
"Далее, в разделе :ref:`Бинарный протокол — примеры <box_protocol-"
"illustration>`, мы покажем фактические байт-коды ответа на сообщение "
"IPROTO_EVAL."

msgid ""
"Looking in errcode.h we find that error code 0x0a (decimal 10) is "
"ER_SPACE_EXISTS, and the string associated with ER_SPACE_EXISTS is \"Space "
"'%s' already exists\"."
msgstr ""
"Заглянув в errcode.h, по коду ошибки 0x0a (10 в десятичной системе) мы "
"обнаружим ER_SPACE_EXISTS, чему соответствует строка \"Space '%s' already "
"exists\" (\"Спейс '%s' уже существует\")."

msgid ""
"Since version :doc:`2.4.1 </release/2.4.1>`, responses for errors have extra"
" information following what was described above. This extra information is "
"given via MP_ERROR extension type. See details in :ref:`MessagePack "
"extensions <msgpack_ext-error>` section."
msgstr ""
"Начиная с версии :doc:`2.4.1 </release/2.4.1>`, ответы на ошибки содержат "
"дополнительную информацию, как описано выше. Эта дополнительная информация "
"передается с помощью расширения MP_ERROR. Подробную информацию см. в разделе"
" :ref:`расширения MessagePack <msgpack_ext-error>`."

msgid "Binary protocol -- responses for SQL"
msgstr "Бинарный протокол — ответы на запросы с SQL"

msgid ""
"After the :ref:`header <box_protocol-header>`, for a response to an SQL "
"statement, there will be a body that is slightly different from the body for"
" :ref:`Binary protocol -- responses if no error and no SQL <box_protocol-"
"responses>`."
msgstr ""
"В ответе на SQL-запрос после :ref:`заголовка <box_protocol-header>` идет "
"тело сообщения, которое немного отличается от тела сообщения, описанного в "
"разделе :ref:`Бинарный протокол — ответы на запросы без ошибок и без SQL "
"<box_protocol-responses>`."

msgid ""
"If the SQL request is not SELECT or VALUES or PRAGMA, then the response body"
" contains only IPROTO_SQL_INFO (0x42). Usually IPROTO_SQL_INFO is a map with"
" only one item -- SQL_INFO_ROW_COUNT (0x00) -- which is the number of "
"changed rows."
msgstr ""
"Если SQL-запрос не содержит операторы SELECT, VALUES или PRAGMA, то тело "
"ответа содержит только IPROTO_SQL_INFO (0x42). Обычно IPROTO_SQL_INFO "
"представляет собой ассоциативный массив с одним элементом — "
"SQL_INFO_ROW_COUNT (0x00) — количество измененных строк."

msgid ""
"# <size>\n"
"msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
"# <header>\n"
"msgpack({\n"
"    Response-Code-Indicator: IPROTO_OK,\n"
"    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer, may be 64-bit}}`,\n"
"    IPROTO_SCHEMA_VERSION: :samp:`{{MP_UINT unsigned integer}}`\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_SQL_INFO: {\n"
"        SQL_INFO_ROW_COUNT: :samp:`{{MP_UINT}}`\n"
"    }\n"
"})"
msgstr ""
"# <size>\n"
"msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
"# <header>\n"
"msgpack({\n"
"    Response-Code-Indicator: IPROTO_OK,\n"
"    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer, may be 64-bit}}`,\n"
"    IPROTO_SCHEMA_VERSION: :samp:`{{MP_UINT unsigned integer}}`\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_SQL_INFO: {\n"
"        SQL_INFO_ROW_COUNT: :samp:`{{MP_UINT}}`\n"
"    }\n"
"})"

msgid ""
"For example, if the request is :samp:`INSERT INTO {table-name} VALUES (1), "
"(2), (3)`, then the response body contains an :samp:`IPROTO_SQL_INFO map "
"with SQL_INFO_ROW_COUNT = 3`. :samp:`SQL_INFO_ROW_COUNT` can be 0 for "
"statements that do not change rows, but can be 1 for statements that create "
"new objects."
msgstr ""
"Например, для запроса :samp:`INSERT INTO {table-name} VALUES (1), (2), (3)` "
"тело ответа содержит ассоциативный массив :samp:`IPROTO_SQL_INFO с "
"SQL_INFO_ROW_COUNT = 3`. :samp:`SQL_INFO_ROW_COUNT` может быть 0, если "
"оператор не изменяет строку, и может быть 1, если оператор создает новый "
"объект."

msgid ""
"The IPROTO_SQL_INFO map may contain a second item -- "
":samp:`SQL_INFO_AUTO_INCREMENT_IDS (0x01)` -- which is the new primary-key "
"value (or values) for an INSERT in a table defined with PRIMARY KEY "
"AUTOINCREMENT. In this case the MP_MAP will have two keys, and  one of the "
"two keys will be 0x01: SQL_INFO_AUTO_INCREMENT_IDS, which is an array of "
"unsigned integers."
msgstr ""
"Ассоциативный массив IPROTO_SQL_INFO может содержать второй элемент "
":samp:`SQL_INFO_AUTO_INCREMENT_IDS (0x01)`, который представляет собой новое"
" значение (или значения) первичного ключа в операции вставки INSERT в "
"таблицу с автоматическим увеличением первичного ключа PRIMARY KEY "
"AUTOINCREMENT. В этом случае MP_MAP будет содержать два ключа, и одним из "
"двух ключей будет 0x01: SQL_INFO_AUTO_INCREMENT_IDS, который представляет "
"собой массив целых беззнаковых чисел."

msgid ""
"If the SQL statement is SELECT or VALUES or PRAGMA, the response contains:"
msgstr ""
"Если запрос содержит SQL-оператор SELECT, VALUES или PRAGMA, ответ будет:"

msgid ""
"# <size>\n"
"msgpack(32)\n"
"# <header>\n"
"msgpack({\n"
"    Response-Code-Indicator: IPROTO_OK,\n"
"    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer, may be 64-bit}}`,\n"
"    IPROTO_SCHEMA_VERSION: :samp:`{{MP_UINT unsigned integer}}`\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_METADATA: :samp:`{{array of column maps}}`,\n"
"    IPROTO_DATA: :samp:`{{array of tuples}}`\n"
"})"
msgstr ""
"# <size>\n"
"msgpack(32)\n"
"# <header>\n"
"msgpack({\n"
"    Response-Code-Indicator: IPROTO_OK,\n"
"    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer, may be 64-bit}}`,\n"
"    IPROTO_SCHEMA_VERSION: :samp:`{{MP_UINT unsigned integer}}`\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_METADATA: :samp:`{{array of column maps}}`,\n"
"    IPROTO_DATA: :samp:`{{array of tuples}}`\n"
"})"

msgid ""
":samp:`IPROTO_METADATA: {array of column maps}` = array of column maps, with"
" each column map containing at least IPROTO_FIELD_NAME (0x00) and MP_STR, "
"and IPROTO_FIELD_TYPE (0x01) and MP_STR. Additionally, if "
"``sql_full_metadata`` in the :ref:`_session_settings <box_space-"
"session_settings>` system space is TRUE, then the array will have these "
"additional column maps which correspond to components described in the "
":ref:`box.execute() <box-sql_if_full_metadata>` section:"
msgstr ""
":samp:`IPROTO_METADATA: {array of column maps}` --- массив ассоциативных "
"массивов, причем каждый ассоциативный массив содержит по крайней мере "
"IPROTO_FIELD_NAME (0x00) + MP_STR и IPROTO_FIELD_TYPE (0x01) + MP_STR. Кроме"
" того, если в системном спейсе :ref:`_session_settings <box_space-"
"session_settings>` задано значение TRUE для ``sql_full_metadata``, то массив"
" будет содержать такие дополнительные ассоциативные массивы, которые "
"соответствуют компонентам, описанным в разделе :ref:`box.execute() <box-"
"sql_if_full_metadata>`:"

msgid ""
"IPROTO_FIELD_COLL (0x02) and MP_STR\n"
"IPROTO_FIELD_IS_NULLABLE (0x03) and MP_BOOL\n"
"IPROTO_FIELD_IS_AUTOINCREMENT (0x04) and MP_BOOL\n"
"IPROTO_FIELD_SPAN (0x05) and MP_STR or MP_NIL"
msgstr ""
"IPROTO_FIELD_COLL (0x02) + MP_STR\n"
"IPROTO_FIELD_IS_NULLABLE (0x03) + MP_BOOL\n"
"IPROTO_FIELD_IS_AUTOINCREMENT (0x04) + MP_BOOL\n"
"IPROTO_FIELD_SPAN (0x05) + MP_STR или MP_NIL"

msgid ":samp:`IPROTO_DATA:{array of tuples}` = the result set \"rows\"."
msgstr ""
":samp:`IPROTO_DATA:{array of tuples}` = строки результирующего набора."

msgid ""
"Example: If we ask for full metadata by saying |br| "
":code:`conn.space._session_settings:update('sql_full_metadata', {{'=', "
"'value', true}})` |br| and we select the two rows from a table named t1 that"
" has columns named DD and Д, with |br| :code:`conn:execute([[SELECT dd, дд "
"AS д FROM t1;]])` |br| we could get this response, in the body:"
msgstr ""
"Пример: Если мы запросим полные метаданные, вызвав |br| "
":code:`conn.space._session_settings:update('sql_full_metadata', {{'=', "
"'value', true}})` |br| и выберем две строки из таблицы t1, в которой есть "
"столбцы DD и Д, с помощью |br| :code:`conn:execute([[SELECT dd, дд AS д FROM"
" t1;]])` |br| мы можем получить такой ответ:"

msgid ""
"# <body>\n"
"msgpack({\n"
"    IPROTO_METADATA: [\n"
"        IPROTO_FIELD_NAME: 'DD',\n"
"        IPROTO_FIELD_TYPE: 'integer',\n"
"        IPROTO_FIELD_IS_NULLABLE: false,\n"
"        IPROTO_FIELD_IS_AUTOINCREMENT: true,\n"
"        IPROTO_FIELD_SPAN: nil,\n"
"        IPROTO_FIELD_NAME: 'Д',\n"
"        IPROTO_FIELD_TYPE: 'string',\n"
"        IPROTO_FIELD_COLL: 'unicode',\n"
"        IPROTO_FIELD_IS_NULLABLE: true,\n"
"        IPROTO_FIELD_SPAN: 'дд'\n"
"    ],\n"
"    IPROTO_DATA: [\n"
"        [1,'a'],\n"
"        [2,'b']'\n"
"    ]\n"
"})"
msgstr ""
"# <body>\n"
"msgpack({\n"
"    IPROTO_METADATA: [\n"
"        IPROTO_FIELD_NAME: 'DD',\n"
"        IPROTO_FIELD_TYPE: 'integer',\n"
"        IPROTO_FIELD_IS_NULLABLE: false,\n"
"        IPROTO_FIELD_IS_AUTOINCREMENT: true,\n"
"        IPROTO_FIELD_SPAN: nil,\n"
"        IPROTO_FIELD_NAME: 'Д',\n"
"        IPROTO_FIELD_TYPE: 'string',\n"
"        IPROTO_FIELD_COLL: 'unicode',\n"
"        IPROTO_FIELD_IS_NULLABLE: true,\n"
"        IPROTO_FIELD_SPAN: 'дд'\n"
"    ],\n"
"    IPROTO_DATA: [\n"
"        [1,'a'],\n"
"        [2,'b']'\n"
"    ]\n"
"})"

msgid ""
"If instead we said |br| :code:`conn:prepare([[SELECT dd, дд AS д FROM "
"t1;]])` |br| then we could get almost the same response, but there would be "
"no IPROTO_DATA and there would be two additional items: |br| ``34 00 = "
"IPROTO_BIND_COUNT and MP_UINT = 0`` (there are no parameters to bind), |br| "
"``33 90 = IPROTO_BIND_METADATA and MP_ARRAY, size 0`` (there are no "
"parameters to bind)."
msgstr ""
"Если бы вместо этого мы вызвали :code:`conn:prepare([[SELECT dd, дд AS д "
"FROM t1;]])`, мы получили бы почти такой же ответ, но без IPROTO_DATA и с "
"двумя дополнительными элементами: |br| ``34`` (IPROTO_BIND_COUNT) и ``00`` "
"(MP_UINT = 0, нет параметров), ``33`` (IPROTO_BIND_METADATA) и ``90`` "
"(MP_ARRAY размера 0, нет параметров)."

msgid ""
"# <body>\n"
"msgpack({\n"
"    IPROTO_STMT_ID: :samp:`{{MP_UINT unsigned integer}}`,\n"
"    IPROTO_BIND_COUNT: :samp:`{{MP_INT integer}}`,\n"
"    IPROTO_BIND_METADATA: :samp:`{{array of parameter descriptors}}`,\n"
"        IPROTO_METADATA: [\n"
"            IPROTO_FIELD_NAME: 'DD',\n"
"            IPROTO_FIELD_TYPE: 'integer',\n"
"            IPROTO_FIELD_IS_NULLABLE: false\n"
"            IPROTO_FIELD_IS_AUTOINCREMENT: true\n"
"            IPROTO_FIELD_SPAN: nil,\n"
"            IPROTO_FIELD_NAME: 'Д',\n"
"            IPROTO_FIELD_TYPE: 'string',\n"
"            IPROTO_FIELD_COLL: 'unicode',\n"
"            IPROTO_FIELD_IS_NULLABLE: true,\n"
"            IPROTO_FIELD_SPAN: 'дд'\n"
"        ]\n"
"    })"
msgstr ""
"# <body>\n"
"msgpack({\n"
"    IPROTO_STMT_ID: :samp:`{{MP_UINT unsigned integer}}`,\n"
"    IPROTO_BIND_COUNT: :samp:`{{MP_INT integer}}`,\n"
"    IPROTO_BIND_METADATA: :samp:`{{array of parameter descriptors}}`,\n"
"        IPROTO_METADATA: [\n"
"            IPROTO_FIELD_NAME: 'DD',\n"
"            IPROTO_FIELD_TYPE: 'integer',\n"
"            IPROTO_FIELD_IS_NULLABLE: false\n"
"            IPROTO_FIELD_IS_AUTOINCREMENT: true\n"
"            IPROTO_FIELD_SPAN: nil,\n"
"            IPROTO_FIELD_NAME: 'Д',\n"
"            IPROTO_FIELD_TYPE: 'string',\n"
"            IPROTO_FIELD_COLL: 'unicode',\n"
"            IPROTO_FIELD_IS_NULLABLE: true,\n"
"            IPROTO_FIELD_SPAN: 'дд'\n"
"        ]\n"
"    })"

msgid ""
"Now read the source code file `net_box.c "
"<https://github.com/tarantool/tarantool/blob/master/src/box/lua/net_box.c>`_"
" where the function \"decode_metadata_optional\" is an example of how "
"Tarantool itself decodes extra items."
msgstr ""
"Теперь обратитесь к файлу исходного кода `net_box.c "
"<https://github.com/tarantool/tarantool/blob/master/src/box/lua/net_box.c>`_,"
" где функция \"decode_metadata_optional\" показывает, как Tarantool сам "
"интерпретирует дополнительные элементы."

msgid ""
"Later in :ref:`Binary protocol -- illustration <box_protocol-illustration>` "
"we will show actual byte codes of responses to the above SQL messages."
msgstr ""
"Далее, в разделе :ref:`Бинарный протокол — примеры <box_protocol-"
"illustration>`, мы покажем фактические байт-коды ответов на вышеприведенные "
"SQL сообщения."

msgid "Binary protocol -- authentication"
msgstr "Бинарный протокол — аутентификация"

msgid ""
"When a client connects to the server instance, the instance responds with a "
"128-byte text greeting message, not in MsgPack format: |br| 64-byte Greeting"
" text line 1 |br| 64-byte Greeting text line 2 |br| 44-byte base64-encoded "
"salt |br| 20-byte NULL"
msgstr ""
"Когда клиент подключается к экземпляру сервера, тот выдает в ответе "
"128-байтовое текстовое сообщение приветствия не в формате MsgPack: |br| 64 "
"байта — строка 1 текста приветствия |br| 64 байта — строка 2 текста "
"приветствия |br| 44 байта —закодированное в формате base-64 значение соль "
"|br| 20 байтов — NULL"

msgid ""
"The greeting contains two 64-byte lines of ASCII text. Each line ends with a"
" newline character (:code:`\\n`). The first line contains the instance "
"version and protocol type. The second line contains up to 44 bytes of "
"base64-encoded random string, to use in the authentication packet, and ends "
"with up to 23 spaces."
msgstr ""
"Приветствие содержит две 64-байтные строки текста в формате ASCII. Каждая "
"строка заканчивается символом разрыва строки (:code:`\\n`). Первая строка "
"описывает версию экземпляра и тип протокола. Вторая строка содержит "
"случайную строку в кодировке base-64 размером до 44 байтов для использования"
" в пакете аутентификации и заканчивается на пробелы (до 23)."

msgid ""
"Part of the greeting is a base64-encoded session salt - a random string "
"which can be used for authentication. The maximum length of an encoded salt "
"(44 bytes) is more than the amount necessary to create the authentication "
"message. An excess is reserved for future authentication schemas."
msgstr ""
"Часть приветствия представляет собой закодированное в формате base-64 "
"значение соль для сессии (случайная строка), которое можно использовать для "
"аутентификации. Максимальная длина закодированного значения соль (44 байта) "
"больше, чем размер создаваемого сообщения аутентификации. Остаток "
"предназначается для будущих схем аутентификации."

msgid ""
"Authentication is optional -- if it is skipped, then the session user is "
"``'guest'`` (the ``'guest'`` user does not need a password)."
msgstr ""
"Аутентификация необязательна: если аутентификация не проводится, то "
"пользователем в сеансе будет ``'guest'`` (пользователю ``'guest'`` пароль не"
" нужен)."

msgid ""
"If authentication is not skipped, then at any time an authentication packet "
"can be prepared using the greeting, the user's name and password, and `sha-1"
" <https://en.wikipedia.org/wiki/SHA-1>`_ functions, as follows."
msgstr ""
"Если аутентификация проводится, то в любое время может быть подготовлен "
"пакет аутентификации с использованием приветствия, имени и пароля "
"пользователя и функции `sha-1 <https://en.wikipedia.org/wiki/SHA-1>`_, как "
"показано ниже."

msgid ""
"PREPARE SCRAMBLE:\n"
"\n"
"    size_of_encoded_salt_in_greeting = 44;\n"
"    size_of_salt_after_base64_decode = 32;\n"
"     /* sha1() will only use the first 20 bytes */\n"
"    size_of_any_sha1_digest = 20;\n"
"    size_of_scramble = 20;\n"
"\n"
"prepare 'chap-sha1' scramble:\n"
"\n"
"    salt = base64_decode(encoded_salt);\n"
"    step_1 = sha1(password);\n"
"    step_2 = sha1(step_1);\n"
"    step_3 = sha1(first_20_bytes_of_salt, step_2);\n"
"    scramble = xor(step_1, step_3);\n"
"    return scramble;"
msgstr ""
"PREPARE SCRAMBLE:\n"
"\n"
"    size_of_encoded_salt_in_greeting = 44;\n"
"    size_of_salt_after_base64_decode = 32;\n"
"     /* sha1() will only use the first 20 bytes */\n"
"    size_of_any_sha1_digest = 20;\n"
"    size_of_scramble = 20;\n"
"\n"
"prepare 'chap-sha1' scramble:\n"
"\n"
"    salt = base64_decode(encoded_salt);\n"
"    step_1 = sha1(password);\n"
"    step_2 = sha1(step_1);\n"
"    step_3 = sha1(first_20_bytes_of_salt, step_2);\n"
"    scramble = xor(step_1, step_3);\n"
"    return scramble;"

msgid "**IPROTO_AUTH** = 0x07"
msgstr "**IPROTO_AUTH** = 0x07"

msgid "The client sends an authentication packet as an IPROTO_AUTH message:"
msgstr "Клиент отправляет пакет аутентификации в виде сообщения IPROTO_AUTH:"

msgid ""
"# <size>\n"
"msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
"# <header>\n"
"msgpack({\n"
"    IPROTO_REQUEST_TYPE: IPROTO_AUTH,\n"
"    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer, usually = 1}}`\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_USER_NAME: :samp:`{{MP_STRING string <key>}}`,\n"
"    IPROTO_TUPLE: ['chap-sha1', :samp:`{{MP_STRING 20-byte string}}`]\n"
"})"
msgstr ""
"# <size>\n"
"msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
"# <header>\n"
"msgpack({\n"
"    IPROTO_REQUEST_TYPE: IPROTO_AUTH,\n"
"    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer, usually = 1}}`\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_USER_NAME: :samp:`{{MP_STRING string <key>}}`,\n"
"    IPROTO_TUPLE: ['chap-sha1', :samp:`{{MP_STRING 20-byte string}}`]\n"
"})"

msgid ""
":code:`<key>` holds the user name. :code:`<tuple>` must be an array of 2 "
"fields: authentication mechanism (\"chap-sha1\" is the only supported "
"mechanism right now) and scramble, encrypted according to the specified "
"mechanism."
msgstr ""
":code:`<key>` содержит имя пользователя. :code:`<tuple>` должен представлять"
" собой массив из 2 полей: механизм аутентификации (на данный момент "
"поддерживается только механизм \"chap-sha1\") и сообщение, зашифрованное в "
"соответствии с указанным механизмом."

msgid ""
"The server instance responds to an authentication packet with a standard "
"response with 0 tuples."
msgstr ""
"На пакет аутентификации экземпляр сервера отправляет стандартный ответ с 0 "
"кортежей."

msgid ""
"To see how Tarantool handles this, look at `net_box.c "
"<https://github.com/tarantool/tarantool/blob/master/src/box/lua/net_box.c>`_"
" function ``netbox_encode_auth``."
msgstr ""
"Чтобы понять, как Tarantool это обрабатывает, обратите внимание на функцию "
"`netbox_encode_auth`` в файле `net_box.c "
"<https://github.com/tarantool/tarantool/blob/master/src/box/lua/net_box.c>`_."

msgid "Binary protocol -- streams"
msgstr "Бинарный протокол — стримы"

msgid ""
"The :ref:`Streams and interactive transactions <box_stream>` feature, which "
"was added in Tarantool version :tarantool-release:`2.10.0-beta1`, allows two"
" things: sequential processing and interleaving."
msgstr ""
":ref:`Стримы и интерактивные транзакции <box_stream>`, добавленные в "
"Tarantool :tarantool-release:`2.10.0-beta1`, делают возможными две "
"процедуры: последовательную обработку и чередование."

msgid ""
"Sequential processing: With streams there is a guarantee that the server "
"instance will not handle the next request in a stream until it has completed"
" the previous one."
msgstr ""
"Последовательная обработка гарантирует, что экземпляр не будет обрабатывать "
"следующий запрос в стриме, пока не завершит работу с предыдущим."

msgid ""
"Interleaving: For example, a series of requests can include \"begin for "
"stream #1\", \"begin for stream #2\", \"insert for stream #1\", \"insert for"
" stream #2\", \"delete for stream #1\", \"commit for stream #1\", \"rollback"
" for stream #2\"."
msgstr ""
"Чередование допускает, например, такую последовательность запросов: \"begin "
"для стрима 1\", \"begin для стрима 2\", \"insert для стрима 1\", \"insert "
"для стрима 2\", \"delete для стрима 1\", \"commit для стрима 1\", \"rollback"
" для стрима 2\"."

msgid ""
"To make these things possible, the engine should be :ref:`vinyl <engines-"
"vinyl>` or :ref:`memtx with mvcc <cfg_basic-memtx_use_mvcc_engine>`, and the"
" client is responsible for ensuring that the stream identifier, unsigned "
"integer :ref:`IPROTO_STREAM_ID <box_protocol-iproto_stream_id>`, is in the "
"request header. IPROTO_STREAM_ID can be any positive 64-bit number, and "
"should be unique for the connection. If IPROTO_STREAM_ID equals zero the "
"server instance will ignore it."
msgstr ""
"Эти процедуры возможны, если используется движок :ref:`vinyl <engines-"
"vinyl>` или :ref:`memtx с mvcc <cfg_basic-memtx_use_mvcc_engine>`. При этом "
"клиент отвечает за наличие идентификатора стрима, беззнакового целого числа "
":ref:`IPROTO_STREAM_ID <box_protocol-iproto_stream_id>`, в заголовке "
"запроса. Идентификатор IPROTO_STREAM_ID должен быть положительным 64-битовым"
" числом, уникальным для соединения. Если IPROTO_STREAM_ID стрима равен нулю,"
" экземпляр его проигнорирует."

msgid ""
"For example, suppose that the client has started a stream with the "
":ref:`net.box module <net_box-module>`"
msgstr ""
"Предположим, что клиент запустил стрим с помощью :ref:`модуля "
"net.box<net_box-module>`."

msgid ""
"net_box = require('net.box')\n"
"conn = net_box.connect('localhost:3302')\n"
"stream = conn:new_stream()"
msgstr ""
"net_box = require('net.box')\n"
"conn = net_box.connect('localhost:3302')\n"
"stream = conn:new_stream()"

msgid ""
"At this point the stream object will look like a duplicate of the conn "
"object, with just one additional member: ``stream_id``. Now, using stream "
"instead of conn, the client sends two requests:"
msgstr ""
"В этот момент объект ``stream`` будет выглядеть так же, как объект ``conn``,"
" но включать один дополнительный элемент: ``stream_id``. Пусть теперь "
"клиент, используя ``stream`` вместо ``conn``, отправит два запроса:"

msgid ""
"stream.space.T:insert{1}\n"
"stream.space.T:insert{2}"
msgstr ""
"stream.space.T:insert{1}\n"
"stream.space.T:insert{2}"

msgid ""
"The header and body of these requests will be the same as in non-stream "
":ref:`IPROTO_INSERT <box_protocol-insert>` requests, except that the header "
"will contain an additional item: IPROTO_STREAM_ID=0x0a with MP_UINT=0x01. It"
" happens to equal 1 for this example because each call to conn:new_stream() "
"assigns a new number, starting with 1."
msgstr ""
"Заголовок и тело этих запросов будут такими же, как в обычных запросах "
":ref:`IPROTO_INSERT <box_protocol-insert>`, но заголовок будет содержать "
"дополнительный элемент ``IPROTO_STREAM_ID=0x0a``, где ``MP_UINT=0x01``. В "
"этом примере значение IPROTO_STREAM_ID равно 1, так как при вызове "
"``conn:new_stream()`` идентификатору каждого нового стрима присваивается "
"уникальное значение, начиная с 1."

msgid ""
"The client makes stream transactions by sending, in order: IPROTO_BEGIN, the"
" transaction data-change and query requests, IPROTO_COMMIT or "
"IPROTO_ROLLBACK. Each request must contain the same IPROTO_STREAM_ID value. "
"With streaming there is no need to add :ref:`IPROTO_FLAGS <box_protocol-"
"flags>` and IPROTO_FLAG_COMMIT in the header of the last request of a "
"transaction. Rollback will be automatic if disconnect occurs before commit "
"is possible."
msgstr ""
"Клиент запускает транзакцию внутри стрима, отправляя запросы в следующем "
"порядке: IPROTO_BEGIN, запросы на изменение и получение данных транзакции, "
"затем IPROTO_COMMIT или IPROTO_ROLLBACK. Каждый запрос должен содержать "
"переменную IPROTO_STREAM_ID с одним и тем же значением. Используя стримы, не"
" нужно добавлять в заголовок последнего запроса транзакции "
":ref:`IPROTO_FLAGS <box_protocol-flags>` и IPROTO_FLAG_COMMIT. Если "
"транзакция прервется до того, как можно будет выполнить коммит, она будет "
"автоматически отменена."

msgid ""
"Thus there are now multiple ways to do transactions: with net_box and "
"stream:begin() and stream:commit() or stream:rollback() which cause "
"IPROTO_BEGIN and IPROTO_COMMIT or IPROTO_ROLLBACK with the current value of "
"stream.stream_id; with :ref:`box.begin() <box-begin>` and :ref:`box.commit()"
" <box-commit>` or :ref:`box.rollback() <box-rollback>`; with SQL and "
":ref:`START TRANSACTION <sql_start_transaction>` and :ref:`COMMIT "
"<sql_commit>` or :ref:`ROLLBACK <sql_rollback>`. An application can use any "
"or all of these ways."
msgstr ""
"Таким образом, у приложения есть несколько способов выполнять транзакции. "
"Во-первых, можно использовать модуль ``net_box`` с методами "
"``stream:begin()`` и ``stream:commit()``/``stream:rollback()``, которые "
"отправляют запросы IPROTO_BEGIN и IPROTO_COMMIT/IPROTO_ROLLBACK с текущим "
"значением ``stream.stream_id``. Другой способ --- применять методы "
":ref:`box.begin() <box-begin>` и :ref:`box.commit() <box-"
"commit>`/:ref:`box.rollback() <box-rollback>`. Наконец, можно пользоваться "
"инструкциями SQL :ref:`START TRANSACTION <sql_start_transaction>` и "
":ref:`COMMIT <sql_commit>`/:ref:`ROLLBACK <sql_rollback>`."

msgid "Binary protocol -- replication"
msgstr "Бинарный протокол — репликация"

msgid ""
"**IPROTO_JOIN** = 0x41. First you must send an initial IPROTO_JOIN request."
msgstr ""
"**IPROTO_JOIN** = 0x41. Сначала нужно отправить первоначальный запрос "
"IPROTO_JOIN."

msgid ""
"# <size>\n"
"msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
"# <header>\n"
"msgpack({\n"
"    IPROTO_REQUEST_TYPE: IPROTO_JOIN,\n"
"    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_INSTANCE_UUID: :samp:`{{uuid}}`\n"
"})"
msgstr ""
"# <size>\n"
"msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
"# <header>\n"
"msgpack({\n"
"    IPROTO_REQUEST_TYPE: IPROTO_JOIN,\n"
"    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_INSTANCE_UUID: :samp:`{{uuid}}`\n"
"})"

msgid ""
"Then the instance which you want to connect to will send its last SNAP file,"
" by simply creating a number of INSERTs (with additional LSN and ServerID) "
"(do not reply to this). Then that instance will send a vclock's MP_MAP and "
"close a socket."
msgstr ""
"Затем экземпляр, к которому вы хотите подключиться, отправит свой последний "
"SNAP-файл, просто создав несколько запросов типа INSERT (с дополнительными "
"LSN и ServerID) (не отвечайте на них). Затем этот экземпляр отправит MP_MAP "
"vclock и закроет сокет."

msgid ""
"# <size>\n"
"msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
"# <header>\n"
"msgpack({\n"
"    Response-Code-Indicator: 0,\n"
"    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_VCLOCK: :samp:`{{MP_INT SRV_ID, MP_INT SRV_LSN}}`\n"
"})"
msgstr ""
"# <size>\n"
"msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
"# <header>\n"
"msgpack({\n"
"    Response-Code-Indicator: 0,\n"
"    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_VCLOCK: :samp:`{{MP_INT SRV_ID, MP_INT SRV_LSN}}`\n"
"})"

msgid ""
"**IPROTO_SUBSCRIBE** = 0x42. Then you must send an IPROTO_SUBSCRIBE request."
msgstr ""
"**IPROTO_SUBSCRIBE** = 0x42. Затем нужно отправить запрос IPROTO_SUBSCRIBE."

msgid ""
"# <size>\n"
"msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
"# <header>\n"
"msgpack({\n"
"    IPROTO_REQUEST_TYPE: IPROTO_SUBSCRIBE,\n"
"    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`,\n"
"    IPROTO_INSTANCE_UUID: :samp:`{{uuid}}`,\n"
"    IPROTO_CLUSTER_UUID: :samp:`{{uuid}}`,\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_VCLOCK: :samp:`{{MP_INT SRV_ID, MP_INT SRV_LSN}}`\n"
"})"
msgstr ""
"# <size>\n"
"msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
"# <header>\n"
"msgpack({\n"
"    IPROTO_REQUEST_TYPE: IPROTO_SUBSCRIBE,\n"
"    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`,\n"
"    IPROTO_INSTANCE_UUID: :samp:`{{uuid}}`,\n"
"    IPROTO_CLUSTER_UUID: :samp:`{{uuid}}`,\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_VCLOCK: :samp:`{{MP_INT SRV_ID, MP_INT SRV_LSN}}`\n"
"})"

msgid ""
"Then you must process every request that could come through other masters. "
"Every request between masters will have additional LSN and SERVER_ID."
msgstr ""
"Затем нужно обработать каждый запрос, который может прийти через других "
"мастеров. В каждом запросе между мастерами будут дополнительные LSN и "
"SERVER_ID."

msgid "**HEARTBEATS**"
msgstr "**КОНТРОЛЬНЫЕ СИГНАЛЫ**"

msgid ""
"Frequently a master sends a :ref:`heartbeat <heartbeat>` message to a "
"replica. For example, if there is a replica with id = 2, and a timestamp "
"with a moment in 2020, a master might send this:"
msgstr ""
"Часто мастер отправляет реплике сообщение :ref:`контрольного сигнала "
"<heartbeat>`. Например, если есть реплика с ID = 2 и метка с моментом "
"времени в 2020 году, мастер может послать такое сообщение:"

msgid ""
"# <header>\n"
"msgpack({\n"
"    IPROTO_REQUEST_TYPE: 0\n"
"    IPROTO_REPLICA_ID: 2\n"
"    IPROTO_TIMESTAMP: :samp:`{{Float 64 MP_DOUBLE 8-byte timestamp}}`\n"
"})"
msgstr ""
"# <header>\n"
"msgpack({\n"
"    IPROTO_REQUEST_TYPE: 0\n"
"    IPROTO_REPLICA_ID: 2\n"
"    IPROTO_TIMESTAMP: :samp:`{{Float 64 MP_DOUBLE 8-byte timestamp}}`\n"
"})"

msgid "and the replica might send back this:"
msgstr "и реплика может отправить в ответ следующее:"

msgid ""
"# <header>\n"
"msgpack({\n"
"    Response-Code-Indicator: IPROTO_OK\n"
"    IPROTO_REPLICA_ID: 2\n"
"    IPROTO_VCLOCK: {1, 6}\n"
"})"
msgstr ""
"# <header>\n"
"msgpack({\n"
"    Response-Code-Indicator: IPROTO_OK\n"
"    IPROTO_REPLICA_ID: 2\n"
"    IPROTO_VCLOCK: {1, 6}\n"
"})"

msgid ""
"Later in :ref:`Binary protocol -- illustration <box_protocol-illustration>` "
"we will show actual byte codes of the above heartbeat examples."
msgstr ""
"Далее, в разделе :ref:`Бинарный протокол — примеры <box_protocol-"
"illustration>`, мы покажем фактические байт-коды вышеприведенных сообщений "
"контрольного сигнала."

msgid "**BALLOTS**"
msgstr "**ГОЛОСОВАНИЕ**"

msgid ""
"While connecting for replication, an instance sends a request with header "
"IPROTO_VOTE (0x44). The normal response is ER_OK,and IPROTO_BALLOT (0x29). "
"The fields within IPROTO_BALLOT are map items:"
msgstr ""
"При подключении для репликации экземпляр отправляет запрос с заголовком "
"IPROTO_VOTE (0x44). Обычно ответом будет ER_OK и IPROTO_BALLOT (0x29). Поля "
"в IPROTO_BALLOT — это элементы ассоциативного массива:"

msgid ""
"IPROTO_BALLOT_IS_RO_CFG (0x01) and MP_BOOL\n"
"IPROTO_BALLOT_VCLOCK (0x02) and vclock\n"
"IPROTO_BALLOT_GC_VCLOCK (0x03) and vclock\n"
"IPROTO_BALLOT_IS_RO (0x04) and MP_BOOL\n"
"IPROTO_BALLOT_IS_ANON = 0x05 and MP_BOOL\n"
"IPROTO_BALLOT_IS_BOOTED = 0x06 and MP_BOOL"
msgstr ""
"IPROTO_BALLOT_IS_RO_CFG (0x01) и MP_BOOL\n"
"IPROTO_BALLOT_VCLOCK (0x02) и vclock\n"
"IPROTO_BALLOT_GC_VCLOCK (0x03) и vclock\n"
"IPROTO_BALLOT_IS_RO (0x04) и MP_BOOL\n"
"IPROTO_BALLOT_IS_ANON = 0x05 и MP_BOOL\n"
"IPROTO_BALLOT_IS_BOOTED = 0x06 и MP_BOOL"

msgid ""
"IPROTO_BALLOT_IS_RO_CFG and IPRO_BALLOT_VCLOCK and IPROTO_BALLOT_GC_VCLOCK "
"and IPROTO_BALLOT_IS_RO were added in version :doc:`2.6.1 </release/2.6.1>`."
" IPROTO_BALLOT_IS_ANON was added in version :doc:`2.7.1 </release/2.7.1>`. "
"IPROTO_BALLOT_IS_BOOTED was added in version 2.7.3 and 2.8.2 and 2.9.1. "
"There have been some name changes starting with version 2.7.3 and 2.8.2 and "
"2.9.1: IPROTO_BALLOT_IS_RO_CFG was formerly called IPROTO_BALLOT_IS_RO, and "
"IPROTO_BALLOT_IS_RO was formerly called IPROTO_BALLOT_IS_LOADING."
msgstr ""
"IPROTO_BALLOT_IS_RO_CFG, IPRO_BALLOT_VCLOCK, IPROTO_BALLOT_GC_VCLOCK и "
"IPROTO_BALLOT_IS_RO добавлены в версии :doc:`2.6.1 </release/2.6.1>`. "
"Константа IPROTO_BALLOT_IS_ANON добавлена в версии :doc:`2.7.1 "
"</release/2.7.1>`. Константа IPROTO_BALLOT_IS_BOOTED добавлена в версиях "
"2.7.3, 2.8.2 и 2.9.1. В версиях 2.7.3, 2.8.2, 2.9.1 и более поздних "
"константа IPROTO_BALLOT_IS_RO переименована в IPROTO_BALLOT_IS_RO_CFG, а "
"IPROTO_BALLOT_IS_LOADING — в IPROTO_BALLOT_IS_RO."

msgid ""
"IPROTO_BALLOT_IS_RO_CFG corresponds to :ref:`box.cfg.read_only <cfg_basic-"
"read_only>`."
msgstr ""
"Значение IPROTO_BALLOT_IS_RO_CFG соответствует значению "
":ref:`box.cfg.read_only <cfg_basic-read_only>`."

msgid ""
"IPROTO_BALLOT_GC_VCLOCK can be the vclock value of the instance's oldest WAL"
" entry, which corresponds to :ref:`box.info.gc().vclock <box_info_gc>`."
msgstr ""
"IPROTO_BALLOT_GC_VCLOCK может принимать значение vclock самой старой записи "
"журнала WAL на экземпляре. Это соответствует значению "
":ref:`box.info.gc().vclock <box_info_gc>`."

msgid ""
"IPROTO_BALLOT_IS_RO is true if the instance is not writable, which may "
"happen for a variety of reasons, such as: it was configured as "
":ref:`read_only <cfg_basic-read_only>`, or it has :ref:`orphan status "
"<replication-orphan_status>`, or it is a :ref:`Raft <repl_leader_elect>` "
"follower."
msgstr ""
"IPROTO_BALLOT_IS_RO принимает значение ``true``, если экземпляр недоступен "
"для записи. Причины у этого могут быть разные: например, экземпляр настроен "
"как :ref:`read_only <cfg_basic-read_only>`, :ref:`имеет статус orphan "
"<replication-orphan_status>` или является последователем (follower) при "
":ref:`выполнении алгоритма Raft <repl_leader_elect>`."

msgid ""
"IPROTO_BALLOT_IS_ANON corresponds to :ref:`box.cfg.replication_anon "
"<cfg_replication-replication_anon>`."
msgstr ""
"Значение IPROTO_BALLOT_IS_ANON соответствует значению "
":ref:`box.cfg.replication_anon <cfg_replication-replication_anon>`."

msgid ""
"IPROTO_BALLOT_IS_BOOTED is true if the instance has finished its bootstrap "
"or recovery process."
msgstr ""
"IPROTO_BALLOT_IS_BOOTED принимает значение ``true``, если экземпляр завершил"
" инициализацию или восстановление."

msgid "**FLAGS**"
msgstr "**ФЛАГИ**"

msgid ""
"For replication of :doc:`synchronous transactions "
"</book/replication/repl_sync>` a header may contain a key = IPROTO_FLAGS and"
" an MP_UINT value = one or more bits: IPROTO_FLAG_COMMIT or "
"IPROTO_FLAG_WAIT_SYNC or IPROTO_FLAG_WAIT_ACK."
msgstr ""
"При репликации :doc:`синхронных транзакций </book/replication/repl_sync>` "
"заголовок может содержать ключ = IPROTO_FLAGS и значение MP_UINT = один или "
"несколько битов: IPROTO_FLAG_COMMIT, IPROTO_FLAG_WAIT_SYNC или "
"IPROTO_FLAG_WAIT_ACK."

msgid ""
"# <size>\n"
"msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
"# <header>\n"
"msgpack({\n"
"    # ... other header items ...,\n"
"    IPROTO_FLAGS: :samp:`{{MP_UINT unsigned integer}}`\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    # ... message for a transaction ...\n"
"})"
msgstr ""
"# <size>\n"
"msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
"# <header>\n"
"msgpack({\n"
"    # ... другие элементы заголовка ...,\n"
"    IPROTO_FLAGS: :samp:`{{MP_UINT unsigned integer}}`\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    # ... message for a transaction ...\n"
"})"

msgid ""
"IPROTO_FLAG_COMMIT (0x01) will be set if this is the last message for a "
"transaction, IPROTO_FLAG_WAIT_SYNC (0x02) will be set if this is the last "
"message for a transaction which cannot be completed immediately, "
"IPROTO_FLAG_WAIT_ACK (0x04) will be set if this is the last message for a "
"synchronous transaction."
msgstr ""
"IPROTO_FLAG_COMMIT (0x01) указывает на последнее сообщение для транзакции. "
"IPROTO_FLAG_WAIT_SYNC (0x02) указывает на последнее сообщение для "
"транзакции, которую нельзя завершить немедленно. IPROTO_FLAG_WAIT_ACK (0x04)"
" указывает на последнее сообщение для синхронной транзакции."

msgid "Binary protocol -- illustration"
msgstr "Бинарный протокол — примеры"

msgid ""
"To follow the examples in this section, get a single Linux computer and "
"start three command-line shells (\"terminals\")."
msgstr ""
"Чтобы выполнить примеры, приведенные в этом разделе, запустите на компьютере"
" с Linux три командных оболочки (терминала)."

msgid ""
"-- On terminal #1, Start monitoring port 3302 with `tcpdump "
"<https://www.tcpdump.org/manpages/tcpdump.1.html>`_: |br|"
msgstr ""
"-- На терминале №1 запустите мониторинг порта 3302 с помощью `tcpdump "
"<https://www.tcpdump.org/manpages/tcpdump.1.html>`_: |br|"

msgid "sudo tcpdump -i lo 'port 3302' -X"
msgstr "sudo tcpdump -i lo 'port 3302' -X"

msgid "On terminal #2, start a server with:"
msgstr "На терминале №2 запустите сервер так:"

msgid ""
"box.cfg{listen=3302}\n"
"box.schema.space.create('tspace')\n"
"box.space.tspace:create_index('I')\n"
"box.space.tspace:insert{280}\n"
"box.schema.user.grant('guest','read,write,execute,create,drop','universe')"
msgstr ""
"box.cfg{listen=3302}\n"
"box.schema.space.create('tspace')\n"
"box.space.tspace:create_index('I')\n"
"box.space.tspace:insert{280}\n"
"box.schema.user.grant('guest','read,write,execute,create,drop','universe')"

msgid ""
"On terminal #3, start another server, which will act as a client, with:"
msgstr ""
"На терминале №3 запустите ещё один сервер, который будет выступать в "
"качестве клиента, так:"

msgid ""
"box.cfg{}\n"
"net_box = require('net.box')\n"
"conn = net_box.connect('localhost:3302')\n"
"conn.space.tspace:select(280)"
msgstr ""
"box.cfg{}\n"
"net_box = require('net.box')\n"
"conn = net_box.connect('localhost:3302')\n"
"conn.space.tspace:select(280)"

msgid ""
"Now look at what tcpdump shows for the job connecting to 3302. -- the "
"\"request\". After the words \"length 32\" is a packet that ends with with "
"these 32 bytes: (we have added indented comments):"
msgstr ""
"Теперь посмотрите, что tcpdump покажет для запроса — задания подключения к "
"порту 3302. После слов \"length 32\" идет пакет, который заканчивается этими"
" 32 байтами (мы добавили комментарии после отступов):"

msgid ""
"ce 00 00 00 1b   MP_UINT = decimal 27 = number of bytes after this\n"
"82               MP_MAP, size 2 (we'll call this \"Main-Map\")\n"
"01                 IPROTO_SYNC (Main-Map Item#1)\n"
"04                 MP_INT = 4 = number that gets incremented with each request\n"
"00                 IPROTO_REQUEST_TYPE (Main-Map Item#2)\n"
"01                 IPROTO_SELECT\n"
"86                 MP_MAP, size 6 (we'll call this \"Select-Map\")\n"
"10                   IPROTO_SPACE_ID (Select-Map Item#1)\n"
"cd 02 00             MP_UINT = decimal 512 = id of tspace (could be larger)\n"
"11                   IPROTO_INDEX_ID (Select-Map Item#2)\n"
"00                   MP_INT = 0 = id of index within tspace\n"
"14                   IPROTO_ITERATOR (Select-Map Item#3)\n"
"00                   MP_INT = 0 = Tarantool iterator_type.h constant ITER_EQ\n"
"13                   IPROTO_OFFSET (Select-Map Item#4)\n"
"00                   MP_INT = 0 = amount to offset\n"
"12                   IPROTO_LIMIT (Select-Map Item#5)\n"
"ce ff ff ff ff       MP_UINT = 4294967295 = biggest possible limit\n"
"20                   IPROTO_KEY (Select-Map Item#6)\n"
"91                   MP_ARRAY, size 1 (we'll call this \"Key-Array\")\n"
"cd 01 18               MP_UINT = 280 (Select-Map Item#6, Key-Array Item#1)\n"
"                       -- 280 is the key value that we are searching for"
msgstr ""
"ce 00 00 00 1b   MP_UINT = 27, десятичное число = число байт после этого\n"
"82               MP_MAP, размер 2 (назовем это Main-Map)\n"
"01                 IPROTO_SYNC (1-й элемент Main-Map)\n"
"04                 MP_INT = 4 = число, которое увеличивается на 1 с каждым запросом\n"
"00                 IPROTO_REQUEST_TYPE (2-й элемент Main-Map)\n"
"01                 IPROTO_SELECT\n"
"86                 MP_MAP, размер 6 (назовем это Select-Map)\n"
"10                   IPROTO_SPACE_ID (1-й элемент Select-Map)\n"
"cd 02 00             MP_UINT = 512, десятичное число = id tspace (может быть больше)\n"
"11                   IPROTO_INDEX_ID (2-й элемент Select-Map)\n"
"00                   MP_INT = 0 = id индекса в tspace\n"
"14                   IPROTO_ITERATOR (3-й элемент Select-Map)\n"
"00                   MP_INT = 0 = константа Tarantool iterator_type.h ITER_EQ\n"
"13                   IPROTO_OFFSET (4-й элемент Select-Map)\n"
"00                   MP_INT = 0 = смещение\n"
"12                   IPROTO_LIMIT (5-й элемент Select-Map)\n"
"ce ff ff ff ff       MP_UINT = 4294967295 = наибольший возможный предел\n"
"20                   IPROTO_KEY (6-й элемент Select-Map)\n"
"91                   MP_ARRAY, размер 1 (назовем это Key-Array)\n"
"cd 01 18               MP_UINT = 280 (6-й элемент Select-Map, 1-й элемент Key-Array)\n"
"                       -- 280, ключевое значение, которое мы ищем"

msgid ""
"Now read the source code file `net_box.c "
"<https://github.com/tarantool/tarantool/blob/master/src/box/lua/net_box.c>`_"
" and skip to the line ``netbox_encode_select(lua_State *L)``. From the "
"comments and from simple function calls like ``mpstream_encode_uint(&stream,"
" IPROTO_SPACE_ID);`` you will be able to see how net_box put together the "
"packet contents that you have just observed with tcpdump."
msgstr ""
"Теперь в файле исходного кода `net_box.c "
"<https://github.com/tarantool/tarantool/blob/master/src/box/lua/net_box.c>`_"
" перейдите к строке ``netbox_encode_select(lua_State *L)``. Из комментариев "
"и из простых вызовов функций типа ``mpstream_encode_uint(&stream, "
"IPROTO_SPACE_ID);`` можно понять, как net_box собирает воедино содержимое "
"пакета, описанного выше с помощью tcpdump."

msgid ""
"There are libraries for reading and writing MessagePack objects. C "
"programmers sometimes include `msgpuck.h "
"<https://github.com/rtsisyk/msgpuck>`_."
msgstr ""
"Существуют библиотеки для чтения и записи объектов в формате MessagePack. "
"Программисты на языке C иногда включают `msgpuck.h "
"<https://github.com/rtsisyk/msgpuck>`_."

msgid ""
"Now you know how Tarantool itself makes requests with the binary protocol. "
"When in doubt about a detail, consult ``net_box.c`` -- it has routines for "
"each request. Some :ref:`connectors <index-box_connectors>` have similar "
"code."
msgstr ""
"Теперь вы знаете, как сам Tarantool выполняет запросы по бинарному "
"протоколу. Если какие-то детали остаются неясными, обратитесь к файлу "
"``net_box.c``, где описаны процедуры для каждого запроса. Некоторые "
":ref:`коннекторы <index-box_connectors>` написаны аналогично."

msgid ""
"For an IPROTO_UPDATE example, suppose a user changes field #2 in tuple #2 in"
" space #256 to ``'BBBB'``. The body will look like this: (notice that in "
"this case there is an extra map item IPROTO_INDEX_BASE, to emphasize that "
"field numbers start with 1, which is optional and can be omitted):"
msgstr ""
"Рассмотрим пример IPROTO_UPDATE. Предположим, пользователь изменяет поле №2 "
"кортежа №2 в спейсе №256 на `'BBBB'``. Тело будет выглядеть так (обратите "
"внимание, что в этом случае дополнительный необязательный элемент "
"ассоциативного массива IPROTO_INDEX_BASE подчеркивает, что номера полей "
"начинаются с 1 — это можно опустить):"

msgid ""
"04               IPROTO_UPDATE\n"
"85               IPROTO_MAP, size 5\n"
"10                 IPROTO_SPACE_ID, Map Item#1\n"
"cd 02 00           MP_UINT 256\n"
"11                 IPROTO_INDEX_ID, Map Item#2\n"
"00                 MP_INT 0 = primary-key index number\n"
"15                 IPROTO_INDEX_BASE, Map Item#3\n"
"01                 MP_INT = 1 i.e. field numbers start at 1\n"
"21                 IPROTO_TUPLE, Map Item#4\n"
"91                 MP_ARRAY, size 1, for array of operations\n"
"93                   MP_ARRAY, size 3\n"
"a1 3d                   MP_STR = OPERATOR = '='\n"
"02                      MP_INT = FIELD_NO = 2\n"
"a5 42 42 42 42 42       MP_STR = VALUE = 'BBBB'\n"
"20                 IPROTO_KEY, Map Item#5\n"
"91                 MP_ARRAY, size 1, for array of key values\n"
"02                   MP_UINT = primary-key value = 2"
msgstr ""
"04               IPROTO_UPDATE\n"
"85               IPROTO_MAP, размер 5\n"
"10                 IPROTO_SPACE_ID, 1-й элемент ассоциативного массива\n"
"cd 02 00           MP_UINT 256\n"
"11                 IPROTO_INDEX_ID, 2-й элемент ассоциативного массива\n"
"00                 MP_INT 0 = номер индекса первичного ключа\n"
"15                 IPROTO_INDEX_BASE, 3-й элемент ассоциативного массива\n"
"01                 MP_INT = 1, т.е. нумерация полей начинается с 1\n"
"21                 IPROTO_TUPLE, 4-й элемент ассоциативного массива\n"
"91                 MP_ARRAY, размер 1, для массива операций\n"
"93                   MP_ARRAY, размер 3\n"
"a1 3d                   MP_STR = OPERATOR = '='\n"
"02                      MP_INT = FIELD_NO = 2\n"
"a5 42 42 42 42 42       MP_STR = VALUE = 'BBBB'\n"
"20                 IPROTO_KEY, 5--й элемент ассоциативного массива\n"
"91                 MP_ARRAY, размер 1, для массива ключей\n"
"02                   MP_UINT = значение первичного ключа = 2"

msgid ""
"Byte codes for the :ref:`IPROTO_EXECUTE <box_protocol-execute>` example:"
msgstr "Байт-код для примера :ref:`IPROTO_EXECUTE <box_protocol-execute>`:"

msgid ""
"0b               IPROTO_EXECUTE\n"
"83               MP_MAP, size 3\n"
"43                 IPROTO_STMT_ID Map Item#1\n"
"ce d7 aa 74 1b     MP_UINT value of n.stmt_id\n"
"41                 IPROTO_SQL_BIND Map Item#2\n"
"92                 MP_ARRAY, size 2\n"
"01                   MP_INT = 1 = value for first parameter\n"
"a1 61                MP_STR = 'a' = value for second parameter\n"
"2b                 IPROTO_OPTIONS Map Item#3\n"
"90                 MP_ARRAY, size 0 (there are no options)"
msgstr ""
"0b               IPROTO_EXECUTE\n"
"83               MP_MAP, размер 3\n"
"43                 IPROTO_STMT_ID 1-й элемент ассоциативного массива\n"
"ce d7 aa 74 1b     MP_UINT значение n.stmt_id\n"
"41                 IPROTO_SQL_BIND 2-й элемент ассоциативного массива\n"
"92                 MP_ARRAY, размер 2\n"
"01                   MP_INT = 1 = значение первого параметра\n"
"a1 61                MP_STR = 'a' = значение второго параметра\n"
"2b                 IPROTO_OPTIONS 3-й элемент ассоциативного массива\n"
"90                 MP_ARRAY, размер 0 (никакие опции не выбраны)"

msgid ""
"Byte codes for the response to the "
":codenormal:`box.space.`:codeitalic:`space-name`:codenormal:`:insert{6}` "
"example:"
msgstr ""
"Байт-код для ответа на пример :codenormal:`box.space.`:codeitalic:`space-"
"name`:codenormal:`:insert{6}`:"

msgid ""
"ce 00 00 00 20                MP_UINT = HEADER AND BODY SIZE\n"
"83                            MP_MAP, size 3\n"
"00                              Response-Code-Indicator\n"
"ce 00 00 00 00                  MP_UINT = IPROTO_OK\n"
"01                              IPROTO_SYNC\n"
"cf 00 00 00 00 00 00 00 53      MP_UINT = sync value\n"
"05                              IPROTO_SCHEMA_VERSION\n"
"ce 00 00 00 68                  MP_UINT = schema version\n"
"81                            MP_MAP, size 1\n"
"30                              IPROTO_DATA\n"
"dd 00 00 00 01                  MP_ARRAY, size 1 (row count)\n"
"91                              MP_ARRAY, size 1 (field count)\n"
"06                              MP_INT = 6 = the value that was inserted"
msgstr ""
"ce 00 00 00 20                MP_UINT = размер заголовка и тела\n"
"83                            MP_MAP, размер 3\n"
"00                              индикатор кода ответа\n"
"ce 00 00 00 00                  MP_UINT = IPROTO_OK\n"
"01                              IPROTO_SYNC\n"
"cf 00 00 00 00 00 00 00 53      MP_UINT = значение синхронизации\n"
"05                              IPROTO_SCHEMA_VERSION\n"
"ce 00 00 00 68                  MP_UINT = версия схемы\n"
"81                            MP_MAP, размер 1\n"
"30                              IPROTO_DATA\n"
"dd 00 00 00 01                  MP_ARRAY, размер 1 (число строк)\n"
"91                              MP_ARRAY, размер 1 (число полей)\n"
"06                              MP_INT = 6 = добавленное значение"

msgid ""
"Byte codes for the response to the "
"``conn:eval([[box.schema.space.create('_space');]])`` example:"
msgstr ""
"Байт-код для ответа на пример "
"``conn:eval([[box.schema.space.create('_space');]])``:"

msgid ""
"ce 00 00 00 3b                  MP_UINT = HEADER AND BODY SIZE\n"
"83                              MP_MAP, size 3 (i.e. 3 items in header)\n"
"   00                              Response-Code-Indicator\n"
"   ce 00 00 80 0a                  MP_UINT = hexadecimal 800a\n"
"   01                              IPROTO_SYNC\n"
"   cf 00 00 00 00 00 00 00 26      MP_UINT = sync value\n"
"   05                              IPROTO_SCHEMA_VERSION\n"
"   ce 00 00 00 78                  MP_UINT = schema version value\n"
"   81                              MP_MAP, size 1\n"
"     31                              IPROTO_ERROR_24\n"
"     db 00 00 00 1d 53 70 61 63 etc. MP_STR = \"Space '_space' already exists\""
msgstr ""
"ce 00 00 00 3b                  MP_UINT = размер заголовка и тела\n"
"83                              MP_MAP, размер 3 (3 элемента в заголовке)\n"
"   00                              индикатор кода ответа\n"
"   ce 00 00 80 0a                  MP_UINT = шестнадцатеричное значение 800a\n"
"   01                              IPROTO_SYNC\n"
"   cf 00 00 00 00 00 00 00 26      MP_UINT = значение синхронизации\n"
"   05                              IPROTO_SCHEMA_VERSION\n"
"   ce 00 00 00 78                  MP_UINT = версия схемы \n"
"   81                              MP_MAP, размер 1\n"
"     31                              IPROTO_ERROR_24\n"
"     db 00 00 00 1d 53 70 61 63 ... MP_STR = \"Space '_space' already exists\""

msgid ""
"Byte codes, if we use the same net.box connection that we used for "
":ref:`Binary protocol -- illustration <box_protocol-illustration>` and we "
"say |br| ``conn:execute([[CREATE TABLE t1 (dd INT PRIMARY KEY AUTOINCREMENT,"
" дд STRING COLLATE \"unicode\");]])`` |br| ``conn:execute([[INSERT INTO t1 "
"VALUES (NULL, 'a'), (NULL, 'b');]])`` |br| and we watch what tcpdump "
"displays, we will see two noticeable things: (1) the CREATE statement caused"
" a schema change so the response has a new IPROTO_SCHEMA_VERSION value and "
"the body includes the new contents of some system tables (caused by requests"
" from net.box which users will not see); (2) the final bytes of the response"
" to the INSERT will be:"
msgstr ""
"Подключимся через то же соединение net.box, что приводилось в разделе "
":ref:`Бинарный протокол --- примеры <box_protocol-illustration>`, и выполним"
" следующее: |br| ``conn:execute([[CREATE TABLE t1 (dd INT PRIMARY KEY "
"AUTOINCREMENT, дд STRING COLLATE \"unicode\");]])`` |br| "
"``conn:execute([[INSERT INTO t1 VALUES (NULL, 'a'), (NULL, 'b');]])`` |br| "
"Результат вывода tcpdump покажет два интересных момента: (1) инструкция "
"CREATE привела к изменению схемы, так что в ответе указано новое значение "
"IPROTO_SCHEMA_VERSION. При этом тело включает новое содержимое некоторых "
"системных таблиц, полученное в результате невидимых для пользователя "
"запросов от net.box; (2) последние байты ответа на INSERT будут следующими:"

msgid ""
"81   MP_MAP, size 1\n"
"42     IPROTO_SQL_INFO\n"
"82     MP_MAP, size 2\n"
"00       Tarantool constant (not in iproto_constants.h) = SQL_INFO_ROW_COUNT\n"
"02       1 = row count\n"
"01       Tarantool constant (not in iproto_constants.h) = SQL_INFO_AUTOINCREMENT_ID\n"
"92       MP_ARRAY, size 2\n"
"01         first autoincrement number\n"
"02         second autoincrement number"
msgstr ""
"81   MP_MAP, размер 1\n"
"42     IPROTO_SQL_INFO\n"
"82     MP_MAP, размер 2\n"
"00       константа Tarantool (не из iproto_constants.h) = SQL_INFO_ROW_COUNT\n"
"02       1 = число строк\n"
"01       константа Tarantool (не из iproto_constants.h) = SQL_INFO_AUTOINCREMENT_ID\n"
"92       MP_ARRAY, размер 2\n"
"01         первое число с автоинкрементом\n"
"02         второе число с автоинкрементом"

msgid ""
"Byte codes for the SQL SELECT example, if we ask for full metadata by saying"
" |br| :code:`conn.space._session_settings:update('sql_full_metadata', {{'=',"
" 'value', true}})` |br| and we select the two rows from the table that we "
"just created |br| :code:`conn:execute([[SELECT dd, дд AS д FROM t1;]])` |br|"
" then tcpdump will show this response, after the header:"
msgstr ""
"Байт-код для примера с SQL SELECT. Запросим полные метаданные, вызвав "
":code:`conn.space._session_settings:update('sql_full_metadata', {{'=', "
"'value', true}})`, и выберем две строки из только что созданной таблицы: "
":code:`conn:execute([[SELECT dd, дд AS д FROM t1;]])`. tcpdump выдаст "
"следующий ответ (после заголовка):"

msgid ""
"82                       MP_MAP, size 2 (i.e. metadata and rows)\n"
"32                         IPROTO_METADATA\n"
"92                         MP_ARRAY, size 2 (i.e. 2 columns)\n"
"85                           MP_MAP, size 5 (i.e. 5 items for column#1)\n"
"00 a2 44 44                    IPROTO_FIELD_NAME and 'DD'\n"
"01 a7 69 6e 74 65 67 65 72     IPROTO_FIELD_TYPE and 'integer'\n"
"03 c2                          IPROTO_FIELD_IS_NULLABLE and false\n"
"04 c3                          IPROTO_FIELD_IS_AUTOINCREMENT and true\n"
"05 c0                          PROTO_FIELD_SPAN and nil\n"
"85                           MP_MAP, size 5 (i.e. 5 items for column#2)\n"
"00 a2 d0 94                    IPROTO_FIELD_NAME and 'Д' upper case\n"
"01 a6 73 74 72 69 6e 67        IPROTO_FIELD_TYPE and 'string'\n"
"02 a7 75 6e 69 63 6f 64 65     IPROTO_FIELD_COLL and 'unicode'\n"
"03 c3                          IPROTO_FIELD_IS_NULLABLE and true\n"
"05 a4 d0 b4 d0 b4              IPROTO_FIELD_SPAN and 'дд' lower case\n"
"30                         IPROTO_DATA\n"
"92                         MP_ARRAY, size 2\n"
"92                           MP_ARRAY, size 2\n"
"01                             MP_INT = 1 i.e. contents of row#1 column#1\n"
"a1 61                          MP_STR = 'a' i.e. contents of row#1 column#2\n"
"92                           MP_ARRAY, size 2\n"
"02                             MP_INT = 2 i.e. contents of row#2 column#1\n"
"a1 62                          MP_STR = 'b' i.e. contents of row#2 column#2"
msgstr ""
"82                       MP_MAP, размер 2 (метаданные и строки)\n"
"32                         IPROTO_METADATA\n"
"92                         MP_ARRAY, размер 2 (2 столбца)\n"
"85                           MP_MAP, размер 5 (5 элементов для столбца 1)\n"
"00 a2 44 44                    IPROTO_FIELD_NAME и 'DD'\n"
"01 a7 69 6e 74 65 67 65 72     IPROTO_FIELD_TYPE и 'integer'\n"
"03 c2                          IPROTO_FIELD_IS_NULLABLE и false\n"
"04 c3                          IPROTO_FIELD_IS_AUTOINCREMENT и true\n"
"05 c0                          PROTO_FIELD_SPAN и nil\n"
"85                           MP_MAP, размер 5 (5 элементов для столбца 2)\n"
"00 a2 d0 94                    IPROTO_FIELD_NAME и 'Д' в верхнем регистре\n"
"01 a6 73 74 72 69 6e 67        IPROTO_FIELD_TYPE и 'string'\n"
"02 a7 75 6e 69 63 6f 64 65     IPROTO_FIELD_COLL и 'unicode'\n"
"03 c3                          IPROTO_FIELD_IS_NULLABLE и true\n"
"05 a4 d0 b4 d0 b4              IPROTO_FIELD_SPAN и 'дд' в нижнем регистре\n"
"30                         IPROTO_DATA\n"
"92                         MP_ARRAY, размер 2\n"
"92                           MP_ARRAY, размер 2\n"
"01                             MP_INT = 1: содержимое строки 1, столбца 1\n"
"a1 61                          MP_STR = 'a': содержимое строки 1, столбца 2\n"
"92                           MP_ARRAY, размер 2\n"
"02                             MP_INT = 2: содержимое строки 2, столбца 1\n"
"a1 62                          MP_STR = 'b': содержимое строки 2, столбца 2"

msgid ""
"Byte code for the SQL PREPARE example. If we said |br| "
":code:`conn:prepare([[SELECT dd, дд AS д FROM t1;]])` |br| then tcpdump "
"would show almost the same response, but there would be no IPROTO_DATA. "
"Instead, additional items will appear:"
msgstr ""
"Байт-код для примера SQL PREPARE. Если вызвать :code:`conn:prepare([[SELECT "
"dd, дд AS д FROM t1;]])`, вывод tcpdump будет почти таким же, но исчезнет "
"IPROTO_DATA. Вместо этого появятся дополнительные байты:"

msgid ""
"34                       IPROTO_BIND_COUNT\n"
"00                       MP_UINT = 0\n"
"\n"
"33                       IPROTO_BIND_METADATA\n"
"90                       MP_ARRAY, size 0"
msgstr ""
"34                       IPROTO_BIND_COUNT\n"
"00                       MP_UINT = 0\n"
"\n"
"33                       IPROTO_BIND_METADATA\n"
"90                       MP_ARRAY, размер 0"

msgid ""
"``MP_UINT = 0`` and ``MP_ARRAY`` has size 0 because there are no parameters "
"to bind. Full output:"
msgstr ""
"``MP_UINT = 0``. Массив ``MP_ARRAY`` имеет размер 0, поскольку параметров "
"нет. Вывод целиком:"

msgid ""
"84                       MP_MAP, size 4\n"
"43                         IPROTO_STMT_ID\n"
"ce c2 3c 2c 1e             MP_UINT = statement id\n"
"34                         IPROTO_BIND_COUNT\n"
"00                         MP_INT = 0 = number of parameters to bind\n"
"33                         IPROTO_BIND_METADATA\n"
"90                         MP_ARRAY, size 0 = there are no parameters to bind\n"
"32                         IPROTO_METADATA\n"
"92                         MP_ARRAY, size 2 (i.e. 2 columns)\n"
"85                           MP_MAP, size 5 (i.e. 5 items for column#1)\n"
"00 a2 44 44                    IPROTO_FIELD_NAME and 'DD'\n"
"01 a7 69 6e 74 65 67 65 72     IPROTO_FIELD_TYPE and 'integer'\n"
"03 c2                          IPROTO_FIELD_IS_NULLABLE and false\n"
"04 c3                          IPROTO_FIELD_IS_AUTOINCREMENT and true\n"
"05 c0                          PROTO_FIELD_SPAN and nil\n"
"85                           MP_MAP, size 5 (i.e. 5 items for column#2)\n"
"00 a2 d0 94                    IPROTO_FIELD_NAME and 'Д' upper case\n"
"01 a6 73 74 72 69 6e 67        IPROTO_FIELD_TYPE and 'string'\n"
"02 a7 75 6e 69 63 6f 64 65     IPROTO_FIELD_COLL and 'unicode'\n"
"03 c3                          IPROTO_FIELD_IS_NULLABLE and true\n"
"05 a4 d0 b4 d0 b4              IPROTO_FIELD_SPAN and 'дд' lower case"
msgstr ""
"84                       MP_MAP, размер 4\n"
"43                         IPROTO_STMT_ID\n"
"ce c2 3c 2c 1e             MP_UINT = ID инструкции\n"
"34                         IPROTO_BIND_COUNT\n"
"00                         MP_INT = 0 = число привязываемых параметров\n"
"33                         IPROTO_BIND_METADATA\n"
"90                         MP_ARRAY, размер 0 = нет привязываемых параметров\n"
"32                         IPROTO_METADATA\n"
"92                         MP_ARRAY, размер 2 (2 столбца)\n"
"85                           MP_MAP, размер 5 (5 элементов для столбца 1)\n"
"00 a2 44 44                    IPROTO_FIELD_NAME и 'DD'\n"
"01 a7 69 6e 74 65 67 65 72     IPROTO_FIELD_TYPE и 'integer'\n"
"03 c2                          IPROTO_FIELD_IS_NULLABLE и false\n"
"04 c3                          IPROTO_FIELD_IS_AUTOINCREMENT и true\n"
"05 c0                          PROTO_FIELD_SPAN и nil\n"
"85                           MP_MAP, размер 5 (5 элементов для столбца 2)\n"
"00 a2 d0 94                    IPROTO_FIELD_NAME + 'Д' в верхнем регистре\n"
"01 a6 73 74 72 69 6e 67        IPROTO_FIELD_TYPE и 'string'\n"
"02 a7 75 6e 69 63 6f 64 65     IPROTO_FIELD_COLL и 'unicode'\n"
"03 c3                          IPROTO_FIELD_IS_NULLABLE и true\n"
"05 a4 d0 b4 d0 b4              IPROTO_FIELD_SPAN и 'дд' в нижнем регистре"

msgid "Byte code for the heartbeat example. The master might send this body:"
msgstr ""
"Байт-код для примера с контрольным сигналом. Мастер может отправить "
"следующее тело:"

msgid ""
"83                      MP_MAP, size 3\n"
"00                        Main-Map Item #1 IPROTO_REQUEST_TYPE\n"
"00                          MP_UINT = 0\n"
"02                        Main-Map Item #2 IPROTO_REPLICA_ID\n"
"02                          MP_UINT = 2 = id\n"
"04                        Main-Map Item #3 IPROTO_TIMESTAMP\n"
"cb                          MP_DOUBLE (MessagePack \"Float 64\")\n"
"41 d7 ba 06 7b 3a 03 21     8-byte timestamp"
msgstr ""
"83                      MP_MAP, размер 3\n"
"00                        1-й элемент Main-Map IPROTO_REQUEST_TYPE\n"
"00                          MP_UINT = 0\n"
"02                        2-й элемент Main-Map IPROTO_REPLICA_ID\n"
"02                          MP_UINT = 2 = id\n"
"04                        3-й элемент Main-Map IPROTO_TIMESTAMP\n"
"cb                          MP_DOUBLE (MessagePack \"Float 64\")\n"
"41 d7 ba 06 7b 3a 03 21     8-байтовая временная отметка"

msgid ""
"Byte code for the heartbeat example. The replica might send back this body"
msgstr ""
"Байт-код ответа на пример с контрольным сигналом. Реплика может вернуть "
"следующее тело:"

msgid ""
"81                       MP_MAP, size 1\n"
"00                         Main-Map Item #1 Response-code-indicator\n"
"00                         MP_UINT = 0 = IPROTO_OK\n"
"81                         Main-Map Item #2, MP_MAP, size 1\n"
"26                           Sub-Map Item #1 IPROTO_VCLOCK\n"
"81                           Sub-Map Item #2, MP_MAP, size 1\n"
"01                             MP_UINT = 1 = id (part 1 of vclock)\n"
"06                             MP_UINT = 6 = lsn (part 2 of vclock)"
msgstr ""
"81                       MP_MAP, размер 1\n"
"00                         1-й элемент Main-Map: индикатор кода ответа\n"
"00                         MP_UINT = 0 = IPROTO_OK\n"
"81                         2-й элемент Main-Map: MP_MAP, размер 1 (Sub-Map)\n"
"26                           1-й элемент Sub-Map: IPROTO_VCLOCK\n"
"81                           2-й элемент Sub-Map: MP_MAP, размер 1\n"
"01                             MP_UINT = 1 = id (1-я часть vclock)\n"
"06                             MP_UINT = 6 = lsn (2-я часть vclock)"

msgid "XLOG / SNAP"
msgstr "XLOG / SNAP"

msgid ""
".xlog and .snap files have nearly the same format. The header looks like:"
msgstr ""
"Файлы форматов .xlog и .snap выглядят практически одинаково. Заголовок "
"выглядит так:"

msgid ""
"<type>\\n                  SNAP\\n or XLOG\\n\n"
"<version>\\n               currently 0.13\\n\n"
"Server: <server_uuid>\\n   where UUID is a 36-byte string\n"
"VClock: <vclock_map>\\n    e.g. {1: 0}\\n\n"
"\\n"
msgstr ""
"<type>\\n                  SNAP\\n или XLOG\\n\n"
"<version>\\n               в данный момент 0.13\\n\n"
"Server: <server_uuid>\\n   где UUID -- это 36-байтная строка\n"
"VClock: <vclock_map>\\n    например, {1: 0}\\n\n"
"\\n"

msgid ""
"After the file header come the data tuples. Tuples begin with a row marker "
"``0xd5ba0bab`` and the last tuple may be followed by an EOF marker "
"``0xd510aded``. Thus, between the file header and the EOF marker, there may "
"be data tuples that have this form:"
msgstr ""
"После файла заголовка идут кортежи с данными. Кортежи начинаются с маркера "
"строки ``0xd5ba0bab``, а после последнего кортежа может стоять маркер конца "
"файла ``0xd510aded``. Таким образом, между заголовком файла и маркером конца"
" файла могут быть кортежи с данными в следующем виде:"

msgid ""
"0            3 4                                         17\n"
"+-------------+========+============+===========+=========+\n"
"|             |        |            |           |         |\n"
"| 0xd5ba0bab  | LENGTH | CRC32 PREV | CRC32 CUR | PADDING |\n"
"|             |        |            |           |         |\n"
"+-------------+========+============+===========+=========+\n"
"   MP_FIXEXT2    MP_INT     MP_INT       MP_INT      ---\n"
"\n"
"+============+ +===================================+\n"
"|            | |                                   |\n"
"|   HEADER   | |                BODY               |\n"
"|            | |                                   |\n"
"+============+ +===================================+\n"
"     MP_MAP                     MP_MAP"
msgstr ""
"0            3 4                                         17\n"
"+-------------+========+============+===========+=========+\n"
"|             |        |            |           |         |\n"
"| 0xd5ba0bab  | LENGTH | CRC32 PREV | CRC32 CUR | PADDING |\n"
"|             |        |            |           |         |\n"
"+-------------+========+============+===========+=========+\n"
"   MP_FIXEXT2    MP_INT     MP_INT       MP_INT      ---\n"
"\n"
"+============+ +===================================+\n"
"|            | |                                   |\n"
"|   HEADER   | |                BODY               |\n"
"|            | |                                   |\n"
"+============+ +===================================+\n"
"     MP_MAP                     MP_MAP"

msgid ""
"See the example in the :ref:`File formats <internals-data_persistence>` "
"section."
msgstr ""
"См. пример в разделе :ref:`Форматы файлов <internals-data_persistence>`."
