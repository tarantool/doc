
#, fuzzy
msgid "Binary protocol"
msgstr "Бинарный протокол Tarantool'а"

msgid ""
"The binary protocol is called a \"request/response\" protocol because it "
"is for sending requests to a Tarantool server and receiving responses. "
"There is complete access to Tarantool functionality, including:"
msgstr ""

#, fuzzy
msgid ""
"request multiplexing, for example ability to issue multiple requests "
"asynchronously via the same connection"
msgstr ""
"мультиплексирование запросов, т.е. возможность асинхронной отправки "
"множества запросов по одному соединению;"

msgid "response format that supports zero-copy writes"
msgstr ""
"формат ответа, который поддерживает запись в режиме без копирования "
"(zero-copy)."

msgid ""
"The protocol can be called \"binary\" because the most-frequently-used "
"database accesses are done with binary codes instead of Lua request text."
" Tarantool experts use it to write their own connectors, to understand "
"network messages, to support new features that their favorite connector "
"doesn't support yet, or to avoid repetitive parsing by the server."
msgstr ""

msgid "Index"
msgstr ""

msgid "Section"
msgstr ""

msgid "Description"
msgstr ""

msgid ":ref:`Symbols and terms <box_protocol-notation>`"
msgstr ""

#, fuzzy
msgid "Notation of binary protocol"
msgstr "Бинарный протокол Tarantool'а"

msgid ":ref:`Header and body <box_protocol-header>`"
msgstr ""

msgid "Header of a request"
msgstr ""

msgid ""
"Requests: |br|:ref:`IPROTO_SELECT <box_protocol-select>` "
"|br|:ref:`IPROTO_INSERT <box_protocol-insert>` |br|:ref:`IPROTO_REPLACE "
"<box_protocol-replace>` |br|:ref:`IPROTO_UPDATE <box_protocol-update>` "
"|br|:ref:`IPROTO_DELETE <box_protocol-delete>` |br|:ref:`IPROTO_CALL_16 "
"<box_protocol-call16>` |br|:ref:`IPROTO_AUTH <box_protocol-auth>` "
"|br|:ref:`IPROTO_EVAL <box_protocol-eval>` |br|:ref:`IPROTO_UPSERT "
"<box_protocol-upsert>` |br|:ref:`IPROTO_CALL <box_protocol-call>` "
"|br|:ref:`IPROTO_EXECUTE <box_protocol-execute>` |br|:ref:`IPROTO_NOP "
"<box_protocol-nop>` |br|:ref:`IPROTO_PREPARE <box_protocol-prepare>` "
"|br|:ref:`IPROTO_PING <box_protocol-ping>` |br|:ref:`IPROTO_JOIN "
"<box_protocol-join>` |br|:ref:`IPROTO_SUBSCRIBE <box_protocol-join>` "
"|br|:ref:`IPROTO_VOTE_DEPRECATED <box_protocol-join>` "
"|br|:ref:`IPROTO_VOTE <box_protocol-join>` "
"|br|:ref:`IPROTO_FETCH_SNAPSHOT <box_protocol-join>` "
"|br|:ref:`IPROTO_REGISTER <box_protocol-join>`"
msgstr ""

msgid "Body of a request"
msgstr ""

msgid ":ref:`Responses if no error and no SQL <box_protocol-responses>`"
msgstr ""

msgid "Responses for no SQL"
msgstr ""

msgid ":ref:`Responses for errors <box_protocol-responses_error>`"
msgstr ""

msgid "Responses for errors"
msgstr ""

msgid ":ref:`Responses for SQL <box_protocol-sql_protocol>`"
msgstr ""

msgid "Responses for SQL"
msgstr ""

msgid ":ref:`Authentication <box_protocol-authentication>`"
msgstr ""

msgid "Authentication after connection"
msgstr ""

msgid ":ref:`Replication <box_protocol-replication>`"
msgstr ""

msgid "Replication request"
msgstr ""

msgid ":ref:`Illustration <box_protocol-illustration>`"
msgstr ""

msgid "Illustration of use"
msgstr ""

msgid ":ref:`XLOG/SNAP <box_protocol-xlog>`"
msgstr ""

msgid "Format of .xlog and .snap files"
msgstr ""

msgid "Binary protocol -- symbols and terms"
msgstr ""

msgid ""
"Words that start with **MP_** mean: a `MessagePack "
"<http://MessagePack.org>`_ type or a range of MessagePack types, "
"including the signal and possibly including a value, with slight "
"modification:"
msgstr ""

msgid "**MP_NIL**    nil"
msgstr ""

msgid "**MP_UINT**   unsigned integer"
msgstr ""

msgid "**MP_INT**    either integer or unsigned integer"
msgstr ""

msgid "**MP_STR**    string"
msgstr ""

msgid "**MP_BIN**    binary string"
msgstr ""

msgid "**MP_ARRAY**  array"
msgstr ""

msgid "**MP_MAP**    map"
msgstr ""

msgid "**MP_BOOL**   boolean"
msgstr ""

msgid "**MP_FLOAT**  float"
msgstr ""

msgid "**MP_DOUBLE** double"
msgstr ""

msgid ""
"**MP_EXT**    extension (including the :ref:`DECIMAL type <msgpack_ext-"
"decimal>` and UUID type)"
msgstr ""

#, fuzzy
msgid "**MP_OBJECT** any MessagePack object"
msgstr "**MP_OBJECT** - любой MsgPack-объект"

msgid ""
"Short descriptions are in MessagePack's `\"spec\" page "
"<https://github.com/msgpack/msgpack/blob/master/spec.md>`_."
msgstr ""

msgid ""
"And words that start with **IPROTO_** mean: a Tarantool constant which is"
" either defined or mentioned in the `iproto_constants.h file "
"<https://github.com/tarantool/tarantool/blob/master/src/box/iproto_constants.h>`_."
msgstr ""

msgid ""
"The IPROTO constants that identify requests that we will mention in this "
"section are: IPROTO_SELECT=0x01, IPROTO_INSERT=0x02, IPROTO_REPLACE=0x03,"
" IPROTO_UPDATE=0x04, IPROTO_DELETE=0x05, IPROTO_CALL_16=0x06, "
"IPROTO_AUTH=0x07, IPROTO_EVAL=0x08, IPROTO_UPSERT=0x09, IPROTO_CALL=0x0a,"
" IPROTO_EXECUTE=0x0b, IPROTO_NOP=0x0c, IPROTO_PREPARE=0x0d, "
"IPROTO_CONFIRM=0x28, IPROTO_ROLLBACK=0x29, IPROTO_PING=0x40, "
"IPROTO_JOIN=0x41, IPROTO_SUBSCRIBE=0x42, IPROTO_VOTE_DEPRECATED=0x43, "
"IPROTO_VOTE=0x44, IPROTO_FETCH_SNAPSHOT=0x45, IPROTO_REGISTER=0x46."
msgstr ""

msgid ""
"The IPROTO constants that appear within requests or responses that we "
"will describe in this section are: IPROTO_OK=0x00, "
"IPROTO_REQUEST_TYPE=0x00, IPROTO_SYNC=0x01, IPROTO_REPLICA_ID=0x02, "
"IPROTO_LSN=0x03, IPROTO_TIMESTAMP=0x04, IPROTO_SCHEMA_VERSION=0x05, "
"IPROTO_SPACE_ID=0x10, IPROTO_INDEX_ID=0x11, IPROTO_LIMIT=0x12, "
"IPROTO_OFFSET=0x13, IPROTO_ITERATOR=0x14, IPROTO_INDEX_BASE=0x15, "
"IPROTO_KEY=0x20, IPROTO_TUPLE=0x21, IPROTO_FUNCTION_NAME=0x22, "
"IPROTO_USER_NAME=0x23, IPROTO_INSTANCE_UUID=0x24, "
"IPROTO_CLUSTER_UUID=0x25, IPROTO_VCLOCK=0x26, IPROTO_EXPR=0x27, "
"IPROTO_OPS=0x28, IPROTO_BALLOT=0x29, IPROTO_TUPLE_META=0x2a, "
"IPROTO_OPTIONS=0x2b, IPROTO_DATA=0x30, IPROTO_ERROR_24=0x31, "
"IPROTO_METADATA=0x32, IPROTO_BIND_METADATA=0x33, IPROTO_BIND_COUNT=0x34, "
"IPROTO_SQL_TEXT=0x40, IPROTO_SQL_BIND=0x41, IPROTO_SQL_INFO=0x42, "
"IPROTO_STMT_ID=0x43, IPROTO_ERROR=0x52, IPROTO_FIELD_NAME=0x00, "
"IPROTO_FIELD_TYPE=0x01, IPROTO_FIELD_COLL=0x02, "
"IPROTO_FIELD_IS_NULLABLE=0x03, IPROTO_FIELD_IS_AUTOINCREMENT=0x04, "
"IPROTO_FIELD_SPAN=0x05."
msgstr ""

msgid ""
"To denote message descriptions we will say ``msgpack(...)`` and within it"
" we will use modified `YAML <https://en.wikipedia.org/wiki/YAML>`_ so: "
"|br| :code:`{...}` braces enclose an associative array, also called map, "
"which in MsgPack is MP_MAP, |br| :samp:`{k}: {v}` is a key-value pair, "
"also called map-item, in this section k is always an unsigned-integer "
"value = one of the IPROTO constants, |br| :samp:`{italics}` are for "
"replaceable text, which is the convention throughout this manual. Usually"
" this is a data type but we do not show types of IPROTO constants which "
"happen to always be unsigned 8-bit integers, |br| :code:`[...]` is for "
"non-associative arrays, |br| :code:`#` starts a comment, especially for "
"the beginning of a section, |br| everything else is \"as is\". |br| Map-"
"items may appear in any order but in examples we usually use the order "
"that net_box.c happens to use."
msgstr ""

msgid "Binary protocol -- header and body"
msgstr ""

msgid ""
"Except during connection (which involves a greeting from the server and "
"optional :ref:`authentication <box_protocol-authentication>` that we will"
" discuss later in this section), the protocol is pure request/response "
"(the client requests and the server responds). It is legal to put more "
"than one request in a packet."
msgstr ""

msgid ""
"Almost all requests and responses contain three sections: size, header, "
"and body. The size is an (MP_UINT) unsigned integer, usually a 32-bit "
"unsigned integer. The header and body are (MP_MAP) maps."
msgstr ""

msgid ""
":code:`# <size>` |br| :samp:`{MP_UINT unsigned integer}` |br| :code:`# "
"<header>` |br| :samp:`{MP_MAP with <header> map-items}` |br| :code:`# "
"<body>` |br| :samp:`{MP_MAP with <body> map-items}` |br|"
msgstr ""

msgid ""
"<size> is the size of the header plus the size of the body. It may be "
"useful to compare it with the number of bytes remaining in the packet."
msgstr ""

msgid ""
"<header> may contain, in any order: |br| :code:`msgpack({` |br| |nbsp| "
"|nbsp| |nbsp| :samp:`IPROTO_REQUEST_TYPE: {MP_UINT unsigned integer},` "
"|br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_SYNC: {MP_UINT unsigned integer}`"
" |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_SCHEMA_VERSION: {MP_UINT "
"unsigned integer}` |br| :code:`})` |br|"
msgstr ""

msgid ""
"**IPROTO_REQUEST_TYPE** or Response-Code-Indicator = 0x00. An unsigned "
"number that indicates what will be in the <body>. In requests "
"IPROTO_REQUEST_TYPE will be followed by IPROTO_SELECT etc. In responses "
"Response-Code-Indicator will be followed by IPROTO_OK etc."
msgstr ""

msgid ""
"**IPROTO_SYNC** = 0x01. An unsigned integer that should be incremented so"
" that it is unique in every request. This integer is also returned from "
":doc:`/reference/reference_lua/box_session/sync`. The IPROTO_SYNC value "
"of a response should be the same as the IPROTO_SYNC value of a request."
msgstr ""

msgid ""
"**IPROTO_SCHEMA_VERSION** = 0x05. An unsigned number, sometimes called "
"SCHEMA_ID, that goes up when there is a major change. In a request header"
" IPROTO_SCHEMA_VERSION is optional, so the version will not be checked if"
" it is absent. In a response header IPROTO_SCHEMA_VERSION is always "
"present, and it is up to the client to check if it has changed."
msgstr ""

msgid ""
"Have a look at file `xrow.c "
"<https://github.com/tarantool/tarantool/blob/master/src/box/xrow.c>`_ "
"function xrow_header_encode, to see how Tarantool encodes the header. "
"Have a look at file net_box.c, function netbox_decode_data, to see how "
"Tarantool decodes the header. For example, in a successful response to "
"``box.space:select()``, the Response-Code-Indicator value will be 0 = "
"IPROTO_OK and the array will have all the tuples of the result."
msgstr ""

msgid ""
"The <body> has the details of the request or response. In a request, it "
"can also be absent or be an empty map. Both these states will be "
"interpreted equally. Responses will contain the <body> anyway even for an"
" :ref:`IPROTO_PING <box_protocol-ping>` request."
msgstr ""

#, fuzzy
msgid "Binary protocol -- requests"
msgstr "Бинарный протокол Tarantool'а"

msgid ""
"A request has a size, a :ref:`header <box_protocol-header>` that contains"
" the IPROTO key, and a body as described here."
msgstr ""

msgid "**IPROTO_SELECT** = 0x01."
msgstr ""

msgid ""
"See :ref:`space_object:select()  <box_space-select>`. The body is a "
"6-item map."
msgstr ""

msgid ""
":code:`# <size>` |br| :samp:`msgpack({MP_UINT unsigned integer = "
"size(<header>) + size(<body>)})` |br| :code:`# <header>` |br| "
":code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_REQUEST_TYPE: "
"IPROTO_SELECT,` |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_SYNC: {MP_UINT "
"unsigned integer}` |br| :code:`})` |br| :code:`# <body>` |br| "
":code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_SPACE_ID: "
"{MP_UINT unsigned integer}`, |br| |nbsp| |nbsp| |nbsp| "
":samp:`IPROTO_INDEX_ID: {MP_UINT unsigned integer}`, |br| |nbsp| |nbsp| "
"|nbsp| :samp:`IPROTO_LIMIT: {MP_UINT unsigned integer}`, |br| |nbsp| "
"|nbsp| |nbsp| :samp:`IPROTO_OFFSET: {MP_UINT unsigned integer}`, |br| "
"|nbsp| |nbsp| |nbsp| :samp:`IPROTO_ITERATOR: {MP_UINT unsigned integer}`,"
" |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_KEY: {MP_ARRAY array of key "
"values}` |br| :code:`})` |br|"
msgstr ""

msgid ""
"Example: if the id of 'tspace' is 512 and this is the fifth message, |br|"
" "
":samp:`{conn}.`:code:`space.tspace:select({0},{iterator='GT',offset=1,limit=2})`"
" will cause:"
msgstr ""

msgid ""
":code:`# <size>` |br| :samp:`msgpack(21)` |br| :code:`# <header>` |br| "
":code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_SYNC: 5`, |br| "
"|nbsp| |nbsp| |nbsp| :samp:`IPROTO_REQUEST_TYPE: IPROTO_SELECT` |br| "
":code:`})` |br| :code:`# <body>` |br| :code:`msgpack({` |br| |nbsp| "
"|nbsp| |nbsp| :samp:`IPROTO_SPACE_ID: 512`, |br| |nbsp| |nbsp| |nbsp| "
":samp:`IPROTO_INDEX_ID: 0`, |br| |nbsp| |nbsp| |nbsp| "
":samp:`IPROTO_ITERATOR: 6`, |br| |nbsp| |nbsp| |nbsp| "
":samp:`IPROTO_OFFSET: 1`, |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_LIMIT: "
"2`, |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_KEY: [1]` |br| :code:`})` "
"|br|"
msgstr ""

msgid ""
"Later in :ref:`Binary protocol -- illustration <box_protocol-"
"illustration>` we will show actual byte codes of an IPROTO_SELECT "
"message."
msgstr ""

msgid "**IPROTO_INSERT** = 0x02."
msgstr ""

msgid ""
"See :ref:`space_object:insert()  <box_space-insert>`. The body is a "
"2-item map:"
msgstr ""

msgid ""
":code:`# <size>` |br| :samp:`msgpack({MP_UINT unsigned integer = "
"size(<header>) + size(<body>)})` |br| :code:`# <header>` |br| "
":code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_REQUEST_TYPE: "
"IPROTO_INSERT`, |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_SYNC: {MP_UINT "
"unsigned integer}` |br| :code:`})` |br| :code:`# <body>` |br| "
":code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_SPACE_ID: "
"{MP_UINT unsigned integer}`, |br| |nbsp| |nbsp| |nbsp| "
":samp:`IPROTO_TUPLE: {MP_ARRAY array of field values}` |br| :code:`})` "
"|br|"
msgstr ""

msgid ""
"Example: if the id of 'tspace' is 512 and this is the fifth message, |br|"
" :samp:`{conn}.`:code:`space.tspace:insert{1, 'AAA'}` will cause:"
msgstr ""

msgid ""
":code:`# <size>` |br| :samp:`msgpack(17)` |br| :code:`# <header>` |br| "
":code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_REQUEST_TYPE: "
"IPROTO_INSERT`, |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_SYNC: 5` |br| "
":code:`})` |br| :code:`# <body>` |br| :code:`msgpack({` |br| |nbsp| "
"|nbsp| |nbsp| :samp:`IPROTO_SPACE_ID: 512`, |br| |nbsp| |nbsp| |nbsp| "
":samp:`IPROTO_TUPLE: [1, 'AAA']` |br| :code:`})` |br|"
msgstr ""

msgid ""
"**IPROTO_REPLACE** = 0x03, See :ref:`space_object:replace()  <box_space-"
"replace>`. The body is a 2-item map, the same as for IPROTO_INSERT:"
msgstr ""

msgid ""
":code:`# <size>` |br| :samp:`msgpack({MP_UINT unsigned integer = "
"size(<header>) + size(<body>)})` |br| :code:`# <header>` |br| "
":code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_REQUEST_TYPE: "
"IPROTO_REPLACE`, |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_SYNC: {MP_UINT "
"unsigned integer}` |br| :code:`})` |br| :code:`# <body>` |br| "
":code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_SPACE_ID: "
"{MP_UINT unsigned integer}`, |br| |nbsp| |nbsp| |nbsp| "
":samp:`IPROTO_TUPLE: {MP_ARRAY array of field values}` |br| :code:`})` "
"|br|"
msgstr ""

msgid "**IPROTO_UPDATE** = 0x04."
msgstr ""

msgid "See :ref:`space_object:update()  <box_space-update>`."
msgstr ""

msgid "The body is usually a 4-item map:"
msgstr ""

msgid ""
":code:`# <size>` |br| :samp:`msgpack({MP_UINT unsigned integer = "
"size(<header>) + size(<body>)})` |br| :code:`# <header>` |br| "
":code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_REQUEST_TYPE: "
"IPROTO_UPDATE`, |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_SYNC: {MP_UINT "
"unsigned integer}` |br| :code:`})` |br| :code:`# <body>` |br| "
":code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_SPACE_ID: "
"{MP_UINT unsigned integer}`, |br| |nbsp| |nbsp| |nbsp| "
":samp:`IPROTO_INDEX_ID: {MP_UINT unsigned integer}`, |br| |nbsp| |nbsp| "
"|nbsp| :samp:`IPROTO_KEY: {MP_ARRAY array of index keys}`, |br| |nbsp| "
"|nbsp| |nbsp| :samp:`IPROTO_TUPLE: {MP_ARRAY array of update operations}`"
" |br| :code:`})` |br|"
msgstr ""

msgid ""
"If the operation specifies no values, then IPROTO_TUPLE is a 2-item "
"array: |br| :samp:`[{MP_STR OPERATOR = '#', {MP_INT FIELD_NO = field "
"number starting with 1}]`. Normally field numbers start with 1."
msgstr ""

msgid ""
"If the operation specifies one value, then IPROTO_TUPLE is a 3-item "
"array: |br| :samp:`[{MP_STR string OPERATOR = '+' or '-' or '^' or '^' or"
" '|' or '!' or '='}, {MP_INT FIELD_NO}, {MP_OBJECT VALUE}]`. |br|"
msgstr ""

msgid ""
"Otherwise IPROTO_TUPLE is a 5-item array: |br| :samp:`[{MP_STR string "
"OPERATOR = ':'}, {MP_INT integer FIELD_NO}, {MP_INT POSITION}, {MP_INT "
"OFFSET}, {MP_STR VALUE}]`. |br|"
msgstr ""

msgid ""
"Example: if the id of 'tspace' is 512 and this is the fifth message, |br|"
" :samp:`{conn}.`:code:`space.tspace:update(999, {{'=', 2, 'B'}})` will "
"cause:"
msgstr ""

msgid ""
":code:`# <size>` |br| :samp:`msgpack(17)` |br| :code:`# <header>` |br| "
":code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_REQUEST_TYPE: "
"IPROTO_UPDATE`, |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_SYNC: 5` |br| "
":code:`})` |br| :code:`# <body> ... the map-item IPROTO_INDEX_BASE is "
"optional` |br| :code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| "
":samp:`IPROTO_SPACE_ID: 512`, |br| |nbsp| |nbsp| |nbsp| "
":samp:`IPROTO_INDEX_ID: 0`, |br| |nbsp| |nbsp| |nbsp| "
":samp:`IPROTO_INDEX_BASE: 1`, |br| |nbsp| |nbsp| |nbsp| "
":samp:`IPROTO_TUPLE: [['=',2,'B']]`, |br| |nbsp| |nbsp| |nbsp| "
":samp:`IPROTO_KEY: [999]` |br| :code:`})`"
msgstr ""

msgid ""
"Later in :ref:`Binary protocol -- illustration <box_protocol-"
"illustration>` we will show actual byte codes of an IPROTO_UPDATE "
"message."
msgstr ""

msgid "**IPROTO_DELETE** = 0x05."
msgstr ""

msgid ""
"See :ref:`space_object:delete()  <box_space-delete>`. The body is a "
"3-item map:"
msgstr ""

msgid ""
":code:`# <size>` |br| :samp:`msgpack({MP_UINT unsigned integer = "
"size(<header>) + size(<body>)})` |br| :code:`# <header>` |br| "
":code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_REQUEST_TYPE: "
"IPROTO_DELETE`, |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_SYNC: {MP_UINT "
"unsigned integer}` |br| :code:`})` |br| :code:`# <body>` |br| "
":code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_SPACE_ID: "
"{MP_UINT unsigned integer}`, |br| |nbsp| |nbsp| |nbsp| "
":samp:`IPROTO_INDEX_ID: {MP_UINT unsigned integer}`, |br| |nbsp| |nbsp| "
"|nbsp| :samp:`IPROTO_KEY: {MP_ARRAY array of key values}` |br| :code:`})`"
" |br|"
msgstr ""

msgid "**IPROTO_CALL_16** = 0x06."
msgstr ""

msgid ""
"See :ref:`conn:call() <net_box-call>`. The suffix ``_16`` is a hint that "
"this is for the ``call()`` until Tarantool 1.6. It is deprecated. Use "
":ref:`IPROTO_CALL <box_protocol-call>` instead. The body is a 2-item map:"
msgstr ""

msgid ""
":code:`# <size>` |br| :samp:`msgpack({MP_UINT unsigned integer = "
"size(<header>) + size(<body>)})` |br| :code:`# <header>` |br| "
":code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_REQUEST_TYPE: "
"IPROTO_CALL_16`, |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_SYNC: {MP_UINT "
"unsigned integer}` |br| :code:`})` |br| :code:`# <body>` |br| "
":code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_FUNCTION_NAME: "
"{MP_STR string}`, |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_TUPLE: "
"{MP_ARRAY array of arguments}` |br| :code:`})` |br|"
msgstr ""

msgid "The return value is an array of tuples."
msgstr ""

msgid "**IPROTO_AUTH** = 0x07."
msgstr ""

msgid ""
"See :ref:`authentication <authentication-users>`. See the later section "
":ref:`Binary protocol -- authentication <box_protocol-authentication>`."
msgstr ""

msgid "**IPROTO_EVAL** = 0x08."
msgstr ""

msgid ""
"See :ref:`conn:eval() <net_box-eval>`. Since the argument is a Lua "
"expression, this is Tarantool's way to handle non-binary with the binary "
"protocol. Any request that does not have its own code, for example "
":samp:`box.space.{space-name}:drop()`, will be handled either with "
":ref:`IPROTO_CALL <box_protocol-call>` or IPROTO_EVAL. The "
":ref:`tarantoolctl <tarantoolctl>` administrative utility makes extensive"
" use of ``eval``. The body is a 2-item map:"
msgstr ""

msgid ""
":code:`# <size>` |br| :samp:`msgpack({MP_UINT unsigned integer = "
"size(<header>) + size(<body>)})` |br| :code:`# <header>` |br| "
":code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_REQUEST_TYPE: "
"IPROTO_EVAL`, |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_SYNC: {MP_UINT "
"unsigned integer}` |br| :code:`})` |br| :code:`# <body>` |br| "
":code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_EXPR: {MP_STR "
"string}`, |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_TUPLE: {MP_ARRAY array "
"of arguments}` |br| :code:`})` |br|"
msgstr ""

msgid ""
"Example: if this is the fifth message, |br| "
":samp:`{conn}.`:code:`eval('return 5;')` will cause:"
msgstr ""

msgid ""
":code:`# <size>` |br| :samp:`msgpack(19)` |br| :code:`# <header>` |br| "
":code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_SYNC: 5` |br| "
"|nbsp| |nbsp| |nbsp| :samp:`IPROTO_REQUEST_TYPE: IPROTO_EVAL` |br| "
":code:`})` |br| :code:`# <body>` |br| :code:`msgpack({` |br| |nbsp| "
"|nbsp| |nbsp| :samp:`IPROTO_EXPR: 'return 5;'`, |br| |nbsp| |nbsp| |nbsp|"
" :samp:`IPROTO_TUPLE: []` |br| :code:`})`"
msgstr ""

msgid "**IPROTO_UPSERT** = 0x09."
msgstr ""

msgid "See :ref:`space_object:upsert()  <box_space-upsert>`."
msgstr ""

msgid ""
":code:`# <size>` |br| :samp:`msgpack({MP_UINT unsigned integer = "
"size(<header>) + size(<body>)})` |br| :code:`# <header>` |br| "
":code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_REQUEST_TYPE: "
"IPROTO_UPSERT`, |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_SYNC: {MP_UINT "
"unsigned integer}` |br| :code:`})` |br| :code:`# <body>` |br| "
":code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_SPACE_ID: "
"{MP_UINT unsigned integer}`, |br| |nbsp| |nbsp| |nbsp| "
":samp:`IPROTO_INDEX_BASE: {MP_UINT unsigned integer}`, |br| |nbsp| |nbsp|"
" |nbsp| :samp:`IPROTO_OPS: {MP_ARRAY array of update operations}`, |br| "
"|nbsp| |nbsp| |nbsp| :samp:`IPROTO_TUPLE: {MP_ARRAY array of primary-key "
"field values}` |br| :code:`})` |br|"
msgstr ""

msgid ""
"The IPROTO_OPS is the same as the IPROTO_TUPLE of :ref:`IPROTO_UPDATE "
"<box_protocol-update>`."
msgstr ""

msgid "**IPROTO_CALL** = 0x0a."
msgstr ""

msgid "See :ref:`conn:call() <net_box-call>`. The body is a 2-item map:"
msgstr ""

msgid ""
":code:`# <size>` |br| :samp:`msgpack({MP_UINT unsigned integer = "
"size(<header>) + size(<body>)})` |br| :code:`# <header>` |br| "
":code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_REQUEST_TYPE: "
"IPROTO_CALL`, |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_SYNC: {MP_UINT "
"unsigned integer}` |br| :code:`})` |br| :code:`# <body>` |br| "
":code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_FUNCTION_NAME: "
"{MP_STR string}`, |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_TUPLE: "
"{MP_ARRAY array of arguments}` |br| :code:`})` |br|"
msgstr ""

msgid ""
"The response will be a list of values, similar to the :ref:`IPROTO_EVAL "
"<box_protocol-eval>` response."
msgstr ""

msgid "**IPROTO_EXECUTE** = 0x0b."
msgstr ""

msgid ""
"See :ref:`box.execute() <box-sql_box_execute>`, this is only for SQL. The"
" body is a 3-item map:"
msgstr ""

msgid ""
":code:`# <size>` |br| :samp:`msgpack({MP_UINT unsigned integer = "
"size(<header>) + size(<body>)})` |br| :code:`# <header>` |br| "
":code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_REQUEST_TYPE: "
"IPROTO_EXECUTE`, |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_SYNC: {MP_UINT "
"unsigned integer}` |br| :code:`})` |br| :code:`# <body>` |br| "
":code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_STMT_ID: "
"{MP_INT integer}` or :samp:`IPROTO_SQL_TEXT: {MP_STR string}`, |br| "
"|nbsp| |nbsp| |nbsp| :samp:`IPROTO_SQL_BIND: {MP_INT integer}`, |br| "
"|nbsp| |nbsp| |nbsp| :samp:`IPROTO_OPTIONS: {MP_ARRAY array}` |br| "
":code:`})` |br|"
msgstr ""

msgid ""
"Use IPROTO_STMT_ID (0x43) + statement-id (MP_INT) if executing a prepared"
" statement, or use IPROTO_SQL_TEXT (0x40) + statement-text (MP_STR) if "
"executing an SQL string, then IPROTO_SQL_BIND (0x41) + array of parameter"
" values to match ? placeholders or :name placeholders, IPROTO_OPTIONS "
"(0x2b) + array of options (usually empty)."
msgstr ""

msgid ""
"For example, suppose we prepare a statement with two ? placeholders, and "
"execute with two parameters, thus: |br| :code:`n = conn:prepare([[VALUES "
"(?, ?);]])` |br| :code:`conn:execute(n.stmt_id, {1,'a'})` |br| Then the "
"body will look like this:"
msgstr ""

msgid ""
":code:`# <body>` |br| :code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| "
":samp:`IPROTO_STMT_ID: 0xd7aa741b`, |br| |nbsp| |nbsp| |nbsp| "
":samp:`IPROTO_SQL_BIND: [1, 'a']`, |br| |nbsp| |nbsp| |nbsp| "
":samp:`IPROTO_OPTIONS: []` |br| :code:`})` |br|"
msgstr ""

msgid ""
"Later in :ref:`Binary protocol -- illustration <box_protocol-"
"illustration>` we will show actual byte codes of the IPROTO_EXECUTE "
"message."
msgstr ""

msgid ""
"To call a prepared statement with named parameters from a connector pass "
"the parameters within an array of maps. A client should wrap each element"
" into a map, where the key holds a name of the parameter (with a colon) "
"and the value holds an actual value. So, to bind foo and bar to 42 and "
"43, a client should send ``IPROTO_SQL_TEXT: <...>, IPROTO_SQL_BIND: "
"[{\"foo\": 42}, {\"bar\": 43}]``."
msgstr ""

msgid ""
"If a statement has both named and non-named parameters, wrap only named "
"ones into a map. The rest of the parameters are positional and will be "
"substituted in order."
msgstr ""

msgid "**IPROTO_NOP** = 0x0c."
msgstr ""

msgid ""
"There is no Lua request exactly equivalent to IPROTO_NOP. It causes the "
"LSN to be incremented. It could be sometimes used for updates where the "
"old and new values are the same, but the LSN must be increased because a "
"data-change must be recorded. The body is: nothing."
msgstr ""

msgid "**IPROTO_PREPARE** = 0x0d."
msgstr ""

msgid ""
"See :ref:`box.prepare <box-sql_box_prepare>`, this is only for SQL. The "
"body is a 1-item map:"
msgstr ""

msgid ""
":code:`# <size>` |br| :samp:`msgpack({MP_UINT unsigned integer = "
"size(<header>) + size(<body>)})` |br| :code:`# <header>` |br| "
":code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_REQUEST_TYPE: "
"IPROTO_PREPARE`, |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_SYNC: {MP_UINT "
"unsigned integer}` |br| :code:`})` |br| :code:`# <body>` |br| "
":code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_STMT_ID: "
"{MP_INT integer}` or :samp:`IPROTO_SQL_TEXT: {MP_STR string}` |br| "
":code:`})` |br|"
msgstr ""

msgid ""
"IPROTO_STMT_ID (0x43) + statement-id (MP_INT) if executing a prepared "
"statement or IPROTO_SQL_TEXT (0x40) + statement-text (string) if "
"executing an SQL string. Thus the IPROTO_PREPARE map item is the same as "
"the first item of the :ref:`IPROTO_EXECUTE <box_protocol-execute>` body."
msgstr ""

msgid "**IPROTO_PING** = 0x40."
msgstr ""

msgid ""
"See :ref:`conn:ping() <conn-ping>`. The body will be an empty map because"
" IPROTO_PING in the header contains all the information that the server "
"instance needs."
msgstr ""

msgid ""
":code:`# <size>` |br| :samp:`msgpack(5)` |br| :code:`# <header>` |br| "
":code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_REQUEST_TYPE: "
"IPROTO_PING`, |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_SYNC: {MP_UINT "
"unsigned integer}` |br| :code:`})` |br|"
msgstr ""

msgid ""
"**IPROTO_JOIN** = 0x41, for replication  |br| **IPROTO_SUBSCRIBE** = "
"0x42, for replication SUBSCRIBE |br| **IPROTO_VOTE_DEPRECATED** = 0x43, "
"for old style vote, superseded by IPROTO_VOTE |br| **IPROTO_VOTE** = "
"0x44, for master election |br| **IPROTO_FETCH_SNAPSHOT** = 0x45, for "
"starting anonymous replication |br| **IPROTO_REGISTER** = 0x46, for "
"leaving anonymous replication."
msgstr ""

msgid ""
"Tarantool constants 0x41 to 0x46 (decimal 65 to 70) are for replication. "
"Connectors and clients do not need to send replication packets. See "
":ref:`Binary protocol -- replication <box_protocol-replication>`."
msgstr ""

msgid ""
"The next two IPROTO messages are used in replication connections between "
"Tarantool nodes in :ref:`synchronous replication <repl_sync>`. The "
"messages are not supposed to be used by any client applications in their "
"regular connections."
msgstr ""

msgid "**IPROTO_CONFIRM** = 0x28"
msgstr ""

msgid ""
"This message confirms that the transactions originated from the instance "
"with id = IPROTO_REPLICA_ID have achieved quorum and can be committed, up"
" to and including LSN = IPROTO_LSN."
msgstr ""

msgid "The body is a 2-item map:"
msgstr ""

msgid ""
":code:`# <size>` |br| :samp:`msgpack({MP_UINT unsigned integer = "
"size(<header>) + size(<body>)})` |br| :code:`# <header>` |br| "
":code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_REQUEST_TYPE: "
"IPROTO_CONFIRM`, |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_SYNC: {MP_UINT "
"unsigned integer}` |br| :code:`})` |br| :code:`# <body>` |br| "
":code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_REPLICA_ID: "
"{MP_INT integer}`, |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_LSN: {MP_INT "
"integer}` |br| :code:`})` |br|"
msgstr ""

msgid "**IPROTO_ROLLBACK** = 0x29"
msgstr ""

msgid ""
"This message says that the transactions originated from the instance with"
" id = IPROTO_REPLICA_ID couldn't achieve quorum for some reason and "
"should be rolled back, down to LSN = IPROTO_LSN and including it."
msgstr ""

msgid ""
":code:`# <size>` |br| :samp:`msgpack({MP_UINT unsigned integer = "
"size(<header>) + size(<body>)})` |br| :code:`# <header>` |br| "
":code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_REQUEST_TYPE: "
"IPROTO_ROLLBACK`, |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_SYNC: {MP_UINT "
"unsigned integer}` |br| :code:`})` |br| :code:`# <body>` |br| "
":code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_REPLICA_ID: "
"{MP_INT integer}`, |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_LSN: {MP_INT "
"integer}` |br| :code:`})` |br|"
msgstr ""

msgid "Binary protocol -- responses if no error and no SQL"
msgstr ""

msgid ""
"After the :ref:`header <box_protocol-header>`, for a response, there will"
" be a body. If there was no error, tt will contain IPROTO_OK (0x00). If "
"there was an error, it will contain an error code other than IPROTO_OK. "
"Responses to SQL statements are slightly different and will be described "
"in the later section, :ref:`Binary protocol -- responses for SQL "
"<box_protocol-sql_protocol>`."
msgstr ""

msgid ""
"For IPROTO_OK, the header Response-Code-Indicator will be 0 and the body "
"is a 1-item map."
msgstr ""

msgid ""
":code:`# <size>` |br| :samp:`msgpack({MP_UINT unsigned integer = "
"size(<header>) + size(<body>)})` |br| :code:`# <header>` |br| "
":code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| :samp:`Response-Code-"
"Indicator: IPROTO_OK`, |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_SYNC: "
"{MP_UINT unsigned integer, may be 64-bit}`, |br| |nbsp| |nbsp| |nbsp| "
":samp:`IPROTO_SCHEMA_VERSION: {MP_UINT unsigned integer}` |br| :code:`})`"
" |br| :code:`# <body>` |br| :code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| "
":samp:`IPROTO_DATA: {any type}` |br| :code:`})` |br|"
msgstr ""

msgid ""
"For :ref:`IPROTO_PING <box_protocol-ping>` the body will be an empty map."
" For most data-access requests (IPROTO_SELECT IPROTO_INSERT IPROTO_DELETE"
" etc.) the body is an IPROTO_DATA map with an array of tuples that "
"contain an array of fields. For :ref:`IPROTO_EVAL <box_protocol-eval>` "
"and :ref:`IPROTO_CALL <box_protocol-call>` it will usually be an array "
"but, since Lua requests can result in a wide variety of structures, "
"bodies can have a wide variety of structures."
msgstr ""

msgid ""
"Example: if this is the fifth message and the request is "
":codenormal:`box.space.`:codeitalic:`space-name`:codenormal:`:insert{6}`,"
" and the previous schema version was 100, a successful response will look"
" like this:"
msgstr ""

msgid ""
":code:`# <size>` |br| :samp:`msgpack(32)` |br| :code:`# <header>` |br| "
":code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| :samp:`Response-Code-"
"Indicator: IPROTO_OK`, |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_SYNC: 5`, "
"|br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_SCHEMA_VERSION: 100` |br| "
":code:`})` |br| :code:`# <body>` |br| :code:`msgpack({` |br| |nbsp| "
"|nbsp| |nbsp| :samp:`IPROTO_DATA: [[6]]` |br| :code:`})` |br|"
msgstr ""

msgid ""
"Later in :ref:`Binary protocol -- illustration <box_protocol-"
"illustration>` we will show actual byte codes of the response to the "
"IPROTO_INSERT message."
msgstr ""

msgid ""
"IPROTO_DATA is what we get with net_box and :ref:`Module buffer <buffer-"
"module>` so if we were using net_box we could decode with "
":ref:`msgpack.decode_unchecked() <msgpack-decode_unchecked_string>`, or "
"we could convert to a string with :samp:`ffi.string({pointer},{length})`."
" The :ref:`pickle.unpack() <pickle-unpack>` function might also be "
"helpful."
msgstr ""

msgid "Binary protocol -- responses for errors"
msgstr ""

msgid ""
"For a response other than IPROTO_OK, the header Response-Code-Indicator "
"will be 0x8XXX and the body will be a 1-item map."
msgstr ""

msgid ""
":code:`# <size>` |br| :samp:`msgpack(32)` |br| :code:`# <header>` |br| "
":code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| :samp:`Response-Code-"
"Indicator: {0x8XXX}`, |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_SYNC: "
"{MP_UINT unsigned integer, may be 64-bit}`, |br| |nbsp| |nbsp| |nbsp| "
":samp:`IPROTO_SCHEMA_VERSION: {MP_UINT unsigned integer}` |br| :code:`})`"
" |br| :code:`# <body>` |br| :code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| "
":samp:`IPROTO_ERROR: {MP_STRING string}` |br| :code:`})` |br|"
msgstr ""

msgid ""
"where 0x8XXX is the indicator for an error and XXX is a value in "
"`src/box/errcode.h "
"<https://github.com/tarantool/tarantool/blob/master/src/box/errcode.h>`_."
" ``src/box/errcode.h`` also has some convenience macros which define "
"hexadecimal constants for return codes."
msgstr ""

msgid ""
"Example: in version 2.4.0 and earlier, if this is the fifth message and "
"the request is to create a duplicate space with "
"``conn:eval([[box.schema.space.create('_space');]])`` the unsuccessful "
"response will look like this:"
msgstr ""

msgid ""
":code:`# <size>` |br| :samp:`msgpack(32)` |br| :code:`# <header>` |br| "
":code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| :samp:`Response-Code-"
"Indicator: 0x800a`, |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_SYNC: 5`, "
"|br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_SCHEMA_VERSION: 0x78`, |br| "
":code:`})` |br| :code:`# <body>` |br| :code:`msgpack({` |br| |nbsp| "
"|nbsp| |nbsp| :samp:`IPROTO_ERROR:  \"Space '_space' already exists\"` "
"|br| :code:`})` |br|"
msgstr ""

msgid ""
"Later in :ref:`Binary protocol -- illustration <box_protocol-"
"illustration>` we will show actual byte codes of the response to the "
"IPROTO_EVAL message."
msgstr ""

#, python-format
msgid ""
"Looking in errcode.h we find that error code 0x0a (decimal 10) is "
"ER_SPACE_EXISTS, and the string associated with ER_SPACE_EXISTS is "
"\"Space '%s' already exists\"."
msgstr ""

msgid ""
"Beginning in version 2.4.1, responses for errors have extra information "
"following what was described above. This extra information is given via "
"MP_ERROR extension type. See details in :ref:`MessagePack extensions "
"<msgpack_ext-error>` section."
msgstr ""

msgid "Binary protocol -- responses for SQL"
msgstr ""

msgid ""
"After the :ref:`header <box_protocol-header>`, for a response to an SQL "
"statement, there will be a body that is slightly different from the body "
"for :ref:`Binary protocol -- responses if no error and no SQL "
"<box_protocol-responses>`."
msgstr ""

msgid ""
"If the SQL request is not SELECT or VALUES or PRAGMA, then the response "
"body contains only IPROTO_SQL_INFO (0x42). Usually IPROTO_SQL_INFO is a "
"map with only one item -- SQL_INFO_ROW_COUNT (0x00) -- which is the "
"number of changed rows."
msgstr ""

msgid ""
":code:`# <size>` |br| :samp:`msgpack({MP_UINT unsigned integer = "
"size(<header>) + size(<body>)})` |br| :code:`# <header>` |br| "
":code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| :samp:`Response-Code-"
"Indicator: IPROTO_OK`, |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_SYNC: "
"{MP_UINT unsigned integer, may be 64-bit}`, |br| |nbsp| |nbsp| |nbsp| "
":samp:`IPROTO_SCHEMA_VERSION: {MP_UINT unsigned integer}` |br| :code:`})`"
" |br| :code:`# <body>` |br| :code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| "
":code:`IPROTO_SQL_INFO: {` |br| |nbsp| |nbsp| |nbsp| |nbsp| |nbsp| |nbsp|"
" :samp:`SQL_INFO_ROW_COUNT: {MP_UINT}` |br| |nbsp| |nbsp| |nbsp| |nbsp| "
"|nbsp| |nbsp| :code:`}` |br| :code:`})` |br|"
msgstr ""

msgid ""
"For example, if the request is :samp:`INSERT INTO {table-name} VALUES "
"(1), (2), (3)`, then the response body contains an IPROTO_SQL_INFO map "
"with SQL_INFO_ROW_COUNT = 3. SQL_INFO_ROW_COUNT can be 0 for statements "
"that do not change rows, but can be 1 for statements that create new "
"objects."
msgstr ""

msgid ""
"The IPROTO_SQL_INFO map may contain a second item -- "
"SQL_INFO_AUTO_INCREMENT_IDS (0x01) -- which is the new primary-key value "
"(or values) for an INSERT in a table defined with PRIMARY KEY "
"AUTOINCREMENT. In this case the MP_MAP will have two keys, and  one of "
"the two keys will be 0x01: SQL_INFO_AUTO_INCREMENT_IDS, which is an array"
" of unsigned integers."
msgstr ""

msgid "If the SQL statement is SELECT or VALUES or PRAGMA, the response contains:"
msgstr ""

msgid ""
":code:`# <size>` |br| :samp:`msgpack(32)` |br| :code:`# <header>` |br| "
":code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| :samp:`Response-Code-"
"Indicator: IPROTO_OK`, |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_SYNC: "
"{MP_UINT unsigned integer, may be 64-bit}`, |br| |nbsp| |nbsp| |nbsp| "
":samp:`IPROTO_SCHEMA_VERSION: {MP_UINT unsigned integer}` |br| :code:`})`"
" |br| :code:`# <body>` |br| :code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| "
":samp:`IPROTO_METADATA: {array of column maps}`, |br| |nbsp| |nbsp| "
"|nbsp| :samp:`IPROTO_DATA: {array of tuples}` |br| :code:`})` |br|"
msgstr ""

msgid ""
":samp:`IPROTO_METADATA: {array of column maps}` = array of column maps, "
"with each column map containing at least IPROTO_FIELD_NAME (0x00) + "
"MP_STR, and IPROTO_FIELD_TYPE (0x01) + MP_STR. Additionally, if "
"``sql_full_metadata`` in the :ref:`_session_settings <box_space-"
"session_settings>` system space is TRUE, then the array will have these "
"additional column maps which correspond to components described in the "
":ref:`box.execute() <box-sql_if_full_metadata>` section: "
"IPROTO_FIELD_COLL (0x02) + MP_STR, IPROTO_FIELD_IS_NULLABLE (0x03) + "
"MP_BOOL, IPROTO_FIELD_IS_AUTOINCREMENT (0x04) + MP_BOOL, "
"IPROTO_FIELD_SPAN (0x05) + MP_STR or MP_NIL."
msgstr ""

msgid ":samp:`IPROTO_DATA:{array of tuples}` = the result set \"rows\"."
msgstr ""

msgid ""
"Example: If we ask for full metadata by saying |br| "
":code:`conn.space._session_settings:update('sql_full_metadata', {{'=', "
"'value', true}})` |br| and we select the two rows from a table named t1 "
"that has columns named DD and Д, with |br| :code:`conn:execute([[SELECT "
"dd, дд AS д FROM t1;]])` |br| we could get this response, in the body:"
msgstr ""

msgid ""
":code:`# <body>` |br| :code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| "
":samp:`IPROTO_METADATA: [` |br| |nbsp| |nbsp| |nbsp| |nbsp| |nbsp| |nbsp|"
" :samp:`IPROTO_FIELD_NAME: 'DD'`, |br| |nbsp| |nbsp| |nbsp| |nbsp| |nbsp|"
" |nbsp| :samp:`IPROTO_FIELD_TYPE: 'integer'`, |br| |nbsp| |nbsp| |nbsp| "
"|nbsp| |nbsp| |nbsp| :samp:`IPROTO_FIELD_IS_NULLABLE: false`, |br| |nbsp|"
" |nbsp| |nbsp| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_FIELD_IS_AUTOINCREMENT:"
" true`, |br| |nbsp| |nbsp| |nbsp| |nbsp| |nbsp| |nbsp| "
":samp:`IPROTO_FIELD_SPAN: nil`, |br| |nbsp| |nbsp| |nbsp| |nbsp| |nbsp| "
"|nbsp| , |br| |nbsp| |nbsp| |nbsp| |nbsp| |nbsp| |nbsp| "
":samp:`IPROTO_FIELD_NAME: 'Д'`, |br| |nbsp| |nbsp| |nbsp| |nbsp| |nbsp| "
"|nbsp| :samp:`IPROTO_FIELD_TYPE: 'string'`, |br| |nbsp| |nbsp| |nbsp| "
"|nbsp| |nbsp| |nbsp| :samp:`IPROTO_FIELD_COLL: 'unicode'`, |br| |nbsp| "
"|nbsp| |nbsp| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_FIELD_IS_NULLABLE: "
"true`, |br| |nbsp| |nbsp| |nbsp| |nbsp| |nbsp| |nbsp| "
":samp:`IPROTO_FIELD_SPAN: 'дд'` |br| |nbsp| |nbsp| |nbsp| :samp:`]`, |br|"
" |nbsp| |nbsp| |nbsp| :samp:`IPROTO_DATA: [` |br| |nbsp| |nbsp| |nbsp| "
"|nbsp| |nbsp| |nbsp| :samp:`[1,'a']`, |br| |nbsp| |nbsp| |nbsp| |nbsp| "
"|nbsp| |nbsp| :samp:`[2,'b']'` |br| |nbsp| |nbsp| |nbsp| :samp:`]` |br| "
":code:`})` |br|"
msgstr ""

msgid ""
"If instead we said |br| :code:`conn:prepare([[SELECT dd, дд AS д FROM "
"t1;]])` |br| then we could get almost the same response, but there would "
"be no IPROTO_DATA and there would be two additional items: |br| 34 00 = "
"IPROTO_BIND_COUNT + MP_UINT = 0 (there are no parameters to bind), |br| "
"33 90 = IPROTO_BIND_METADATA + MP_ARRAY, size 0 (there are no parameters "
"to bind)."
msgstr ""

msgid ""
":code:`# <body>` |br| :code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| "
":samp:`IPROTO_STMT_ID: {MP_UINT unsigned integer}`, |br| |nbsp| |nbsp| "
"|nbsp| :samp:`IPROTO_BIND_COUNT: {MP_INT integer}`, |br| |nbsp| |nbsp| "
"|nbsp| :samp:`IPROTO_BIND_METADATA: {array of parameter descriptors}`, "
"|br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_METADATA: [` |br| |nbsp| |nbsp| "
"|nbsp| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_FIELD_NAME: 'DD'`, |br| |nbsp| "
"|nbsp| |nbsp| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_FIELD_TYPE: 'integer'`, "
"|br| |nbsp| |nbsp| |nbsp| |nbsp| |nbsp| |nbsp| "
":samp:`IPROTO_FIELD_IS_NULLABLE: false`, |br| |nbsp| |nbsp| |nbsp| |nbsp|"
" |nbsp| |nbsp| :samp:`IPROTO_FIELD_IS_AUTOINCREMENT: true`, |br| |nbsp| "
"|nbsp| |nbsp| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_FIELD_SPAN: nil`, |br| "
"|nbsp| |nbsp| |nbsp| |nbsp| |nbsp| |nbsp| , |br| |nbsp| |nbsp| |nbsp| "
"|nbsp| |nbsp| |nbsp| :samp:`IPROTO_FIELD_NAME: 'Д'`, |br| |nbsp| |nbsp| "
"|nbsp| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_FIELD_TYPE: 'string'`, |br| "
"|nbsp| |nbsp| |nbsp| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_FIELD_COLL: "
"'unicode'`, |br| |nbsp| |nbsp| |nbsp| |nbsp| |nbsp| |nbsp| "
":samp:`IPROTO_FIELD_IS_NULLABLE: true`, |br| |nbsp| |nbsp| |nbsp| |nbsp| "
"|nbsp| |nbsp| :samp:`IPROTO_FIELD_SPAN: 'дд'` |br| |nbsp| |nbsp| |nbsp| "
":samp:`]` |br| :code:`})` |br|"
msgstr ""

msgid ""
"Now read the source code file `net_box.c "
"<https://github.com/tarantool/tarantool/blob/master/src/box/lua/net_box.c>`_"
" where the function \"decode_metadata_optional\" is an example of how "
"Tarantool itself decodes extra items."
msgstr ""

msgid ""
"Later in :ref:`Binary protocol -- illustration <box_protocol-"
"illustration>` we will show actual byte codes of responses to the above "
"SQL messages."
msgstr ""

msgid "Binary protocol -- authentication"
msgstr ""

msgid ""
"When a client connects to the server instance, the instance responds with"
" a 128-byte text greeting message, not in MsgPack format: |br| 64-byte "
"Greeting text line 1 |br| 64-byte Greeting text line 2 |br| 44-byte "
"base64-encoded salt |br| 20-byte NULL"
msgstr ""

#, fuzzy
msgid ""
"The greeting contains two 64-byte lines of ASCII text. Each line ends "
"with a newline character (:code:`\\n`). The first line contains the "
"instance version and protocol type. The second line contains up to 44 "
"bytes of base64-encoded random string, to use in the authentication "
"packet, and ends with up to 23 spaces."
msgstr ""
"Экземпляр сервера начинает диалог с отправки клиенту текста приветствия "
"фиксированного размера (128 байтов). Приветствие всегда содержит две "
"64-байтные строки текста в формате ASCII, каждая строка заканчивается "
"символом разрыва строки (:code:`\\n`). Первая строка описывает версию "
"экземпляра и тип протокола. Вторая строка содержит случайную строку в "
"кодировке base64 размером до 44 байтов для использования в пакете "
"аутентификации и заканчивается на пробелы (до 23)."

msgid ""
"Part of the greeting is a base64-encoded session salt - a random string "
"which can be used for authentication. The maximum length of an encoded "
"salt (44 bytes) is more than the amount necessary to create the "
"authentication message. An excess is reserved for future authentication "
"schemas."
msgstr ""

msgid ""
"Authentication is optional -- if it is skipped, then the session user is "
"``'guest'`` (the ``'guest'`` user does not need a password)."
msgstr ""

msgid ""
"If authentication is not skipped, then at any time an authentication "
"packet can be prepared using the greeting, the user's name and password, "
"and `sha-1 <https://en.wikipedia.org/wiki/SHA-1>`_ functions, as follows."
msgstr ""

msgid ""
"PREPARE SCRAMBLE:\n"
"\n"
"    size_of_encoded_salt_in_greeting = 44;\n"
"    size_of_salt_after_base64_decode = 32;\n"
"    /* sha1() will only use the first 20 bytes */\n"
"    size_of_any_sha1_digest = 20;\n"
"    size_of_scramble = 20;\n"
"\n"
"prepare 'chap-sha1' scramble:\n"
"\n"
"    salt = base64_decode(encoded_salt);\n"
"    step_1 = sha1(password);\n"
"    step_2 = sha1(step_1);\n"
"    step_3 = sha1(first_20_bytes_of_salt, step_2);\n"
"    scramble = xor(step_1, step_3);\n"
"    return scramble;"
msgstr ""

msgid "**IPROTO_AUTH** = 0x07"
msgstr ""

msgid "The client sends an authentication packet as an IPROTO_AUTH message:"
msgstr ""

msgid ""
":code:`# <size>` |br| :samp:`msgpack({MP_UINT unsigned integer = "
"size(<header>) + size(<body>)})` |br| :code:`# <header>` |br| "
":code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_REQUEST_TYPE: "
"IPROTO_AUTH`, |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_SYNC: {MP_UINT "
"unsigned integer, usually = 1}` |br| :code:`})` |br| :code:`# <body>` "
"|br| :code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_USER_NAME:"
" {MP_STRING string <key>}`, |br| |nbsp| |nbsp| |nbsp| "
":samp:`IPROTO_TUPLE: ['chap-sha1', {MP_STRING 20-byte string}]` |br| "
":code:`})` |br|"
msgstr ""

#, fuzzy
msgid ""
":code:`<key>` holds the user name. :code:`<tuple>` must be an array of 2 "
"fields: authentication mechanism (\"chap-sha1\" is the only supported "
"mechanism right now) and scramble, encrypted according to the specified "
"mechanism."
msgstr ""
":code:`<key>` содержит имя пользователя. :code:`<tuple>` должен "
"представлять собой массив из 2 полей: механизм аутентификации (в данный "
"момент поддерживается только механизм \"chap-sha1\") и пароль, "
"закодированный в соответствии с указанным механизмом. Аутентификация в "
"Tarantool'е необязательна: если аутентификация не проводится, то "
"пользователем в сессии будет 'guest'. Экземпляр отвечает на пакет "
"аутентификации стандартным ответом с 0 кортежей."

msgid ""
"The server instance responds to an authentication packet with a standard "
"response with 0 tuples."
msgstr ""

msgid ""
"To see how Tarantool handles this, look at `net_box.c "
"<https://github.com/tarantool/tarantool/blob/master/src/box/lua/net_box.c>`_"
" function netbox_encode_auth."
msgstr ""

#, fuzzy
msgid "Binary protocol -- replication"
msgstr "Бинарный протокол Tarantool'а"

msgid ""
"**IPROTO_JOIN** = 0x41. First you must send an initial IPROTO_JOIN "
"request."
msgstr ""

msgid ""
":code:`# <size>` |br| :samp:`msgpack({MP_UINT unsigned integer = "
"size(<header>) + size(<body>)})` |br| :code:`# <header>` |br| "
":code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_REQUEST_TYPE: "
"IPROTO_JOIN`, |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_SYNC: {MP_UINT "
"unsigned integer}` |br| :code:`})` |br| :code:`# <body>` |br| "
":code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_INSTANCE_UUID: "
"{uuid}` |br| :code:`})` |br|"
msgstr ""

msgid ""
"Then the instance which you want to connect to will send its last SNAP "
"file, by simply creating a number of INSERTs (with additional LSN and "
"ServerID) (do not reply to this). Then that instance will send a vclock's"
" MP_MAP and close a socket."
msgstr ""

msgid ""
":code:`# <size>` |br| :samp:`msgpack({MP_UINT unsigned integer = "
"size(<header>) + size(<body>)})` |br| :code:`# <header>` |br| "
":code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| :samp:`Response-Code-"
"Indicator: 0`, |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_SYNC: {MP_UINT "
"unsigned integer}` |br| :code:`})` |br| :code:`# <body>` |br| "
":code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| "
":samp:`IPROTO_VCLOCK:`:code:`{`:samp:`{MP_INT SRV_ID, MP_INT "
"SRV_LSN}`:code:`}` |br| :code:`})` |br|"
msgstr ""

msgid ""
"**IPROTO_SUBSCRIBE** = 0x42. Then you must send an IPROTO_SUBSCRIBE "
"request."
msgstr ""

msgid ""
":code:`# <size>` |br| :samp:`msgpack({MP_UINT unsigned integer = "
"size(<header>) + size(<body>)})` |br| :code:`# <header>` |br| "
":code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_REQUEST_TYPE: "
"IPROTO_SUBSCRIBE`, |br| |nbsp| |nbsp| |nbsp| :samp:`IPROTO_SYNC: {MP_UINT"
" unsigned integer}`, |br| |nbsp| |nbsp| |nbsp| "
":samp:`IPROTO_INSTANCE_UUID: {uuid}`, |br| |nbsp| |nbsp| |nbsp| "
":samp:`IPROTO_CLUSTER_UUID: {uuid}`, |br| :code:`})` |br| :code:`# "
"<body>` |br| :code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| "
":samp:`IPROTO_VCLOCK:`:code:`{`:samp:`{MP_INT SRV_ID, MP_INT "
"SRV_LSN}`:code:`}` |br| :code:`})` |br|"
msgstr ""

msgid ""
"Then you must process every request that could come through other "
"masters. Every request between masters will have additional LSN and "
"SERVER_ID."
msgstr ""

msgid "**HEARTBEATS**"
msgstr ""

msgid ""
"Frequently a master sends a :ref:`heartbeat <heartbeat>` message to a "
"replica. For example, if there is a replica with id = 2, and a timestamp "
"with a moment in 2020, a master might send this:"
msgstr ""

msgid ""
":code:`# <header>` |br| :code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| "
":samp:`IPROTO_REQUEST_TYPE: 0` |br| |nbsp| |nbsp| |nbsp| "
":samp:`IPROTO_REPLICA_ID: 2` |br| |nbsp| |nbsp| |nbsp| "
":samp:`IPROTO_TIMESTAMP: {Float 64 MP_DOUBLE 8-byte timestamp}` |br| "
":code:`})` |br|"
msgstr ""

msgid "and the replica might send back this:"
msgstr ""

msgid ""
":code:`# <header>` |br| :code:`msgpack({` |br| |nbsp| |nbsp| |nbsp| :samp"
":`Response-Code-Indicator: IPROTO_OK` |br| |nbsp| |nbsp| |nbsp| "
":samp:`IPROTO_REPLICA_ID: 2` |br| |nbsp| |nbsp| |nbsp| "
":code:`IPROTO_VCLOCK: {1, 6}` |br| :code:`})` |br|"
msgstr ""

msgid ""
"Later in :ref:`Binary protocol -- illustration <box_protocol-"
"illustration>` we will show actual byte codes of the above heartbeat "
"examples."
msgstr ""

#, fuzzy
msgid "Binary protocol -- illustration"
msgstr "Бинарный протокол Tarantool'а"

msgid ""
"To follow the examples in this section, get a single Linux computer and "
"start three command-line shells (\"terminals\")."
msgstr ""

msgid ""
"-- On terminal #1, Start monitoring port 3302 with `tcpdump "
"<https://www.tcpdump.org/manpages/tcpdump.1.html>`_: |br| ``sudo tcpdump "
"-i lo 'port 3302' -X``"
msgstr ""

msgid ""
"On terminal #2, start a server with: |br| ``box.cfg{listen=3302}`` |br| "
"``box.schema.space.create('tspace')`` |br| "
"``box.space.tspace:create_index('I')`` |br| "
"``box.space.tspace:insert{280}`` |br| "
"``box.schema.user.grant('guest','read,write,execute,create,drop','universe')``"
" |br|"
msgstr ""

msgid ""
"On terminal #3, start another server, which will act as a client, with: "
"|br| ``box.cfg{}`` |br| ``net_box = require('net.box')`` |br| ``conn = "
"net_box.connect('localhost:3302')`` |br| "
"``conn.space.tspace:select(280)`` |br|"
msgstr ""

msgid ""
"Now look at what tcpdump shows for the job connecting to 3302. -- the "
"\"request\". After the words \"length 32\" is a packet that ends with "
"with these 32 bytes: (we have added indented comments):"
msgstr ""

msgid ""
"ce 00 00 00 1b   MP_UINT = decimal 27 = number of bytes after this\n"
"82               MP_MAP, size 2 (we'll call this \"Main-Map\")\n"
"01                 IPROTO_SYNC (Main-Map Item#1)\n"
"04                 MP_INT = 4 = number that gets incremented with each "
"request\n"
"00                 IPROTO_REQUEST_TYPE (Main-Map Item#2)\n"
"01                 IPROTO_SELECT\n"
"86                 MP_MAP, size 6 (we'll call this \"Select-Map\")\n"
"10                   IPROTO_SPACE_ID (Select-Map Item#1)\n"
"cd 02 00             MP_UINT = decimal 512 = id of tspace (could be "
"larger)\n"
"11                   IPROTO_INDEX_ID (Select-Map Item#2)\n"
"00                   MP_INT = 0 = id of index within tspace\n"
"14                   IPROTO_ITERATOR (Select-Map Item#3)\n"
"00                   MP_INT = 0 = Tarantool iterator_type.h constant "
"ITER_EQ\n"
"13                   IPROTO_OFFSET (Select-Map Item#4)\n"
"00                   MP_INT = 0 = amount to offset\n"
"12                   IPROTO_LIMIT (Select-Map Item#5)\n"
"ce ff ff ff ff       MP_UINT = 4294967295 = biggest possible limit\n"
"20                   IPROTO_KEY (Select-Map Item#6)\n"
"91                   MP_ARRAY, size 1 (we'll call this \"Key-Array\")\n"
"cd 01 18               MP_UINT = 280 (Select-Map Item#6, Key-Array "
"Item#1)\n"
"                       -- 280 is the key value that we are searching for"
msgstr ""

msgid ""
"Now read the source code file `net_box.c "
"<https://github.com/tarantool/tarantool/blob/master/src/box/lua/net_box.c>`_"
" and skip to the line ``netbox_encode_select(lua_State *L)``. From the "
"comments and from simple function calls like "
"``mpstream_encode_uint(&stream, IPROTO_SPACE_ID);`` you will be able to "
"see how net_box put together the packet contents that you have just "
"observed with tcpdump."
msgstr ""

msgid ""
"There are libraries for reading and writing MessagePack objects. C "
"programmers sometimes include `msgpuck.h "
"<https://github.com/rtsisyk/msgpuck>`_."
msgstr ""

msgid ""
"Now you know how Tarantool itself makes requests with the binary "
"protocol. When in doubt about a detail, consult ``net_box.c`` -- it has "
"routines for each request. Some :ref:`connectors <index-box_connectors>` "
"have similar code."
msgstr ""

msgid ""
"For an IPROTO_UPDATE example, suppose a user changes field #2 in tuple #2"
" in space #256 to 'BBBB'. The body will look like this: (notice that in "
"this case there is an extra map item IPROTO_INDEX_BASE, to emphasize that"
" field numbers start with 1, which is optional and can be omitted):"
msgstr ""

msgid ""
"04               IPROTO_UPDATE\n"
"85               IPROTO_MAP, size 5\n"
"10                 IPROTO_SPACE_ID, Map Item#1\n"
"cd 02 00           MP_UINT 256\n"
"11                 IPROTO_INDEX_ID, Map Item#2\n"
"00                 MP_INT 0 = primary-key index number\n"
"15                 IPROTO_INDEX_BASE, Map Item#3\n"
"01                 MP_INT = 1 i.e. field numbers start at 1\n"
"21                 IPROTO_TUPLE, Map Item#4\n"
"91                 MP_ARRAY, size 1, for array of operations\n"
"93                   MP_ARRAY, size 3\n"
"a1 3d                   MP_STR = OPERATOR = '='\n"
"02                      MP_INT = FIELD_NO = 2\n"
"a5 42 42 42 42 42       MP_STR = VALUE = 'BBBB'\n"
"20                 IPROTO_KEY, Map Item#5\n"
"91                 MP_ARRAY, size 1, for array of key values\n"
"02                   MP_UINT = primary-key value = 2"
msgstr ""

msgid "Byte codes for the :ref:`IPROTO_EXECUTE <box_protocol-execute>` example:"
msgstr ""

msgid ""
"0b               IPROTO_EXECUTE\n"
"83               MP_MAP, size 3\n"
"43                 IPROTO_STMT_ID Map Item#1\n"
"ce d7 aa 74 1b     MP_UINT value of n.stmt_id\n"
"41                 IPROTO_SQL_BIND Map Item#2\n"
"92                 MP_ARRAY, size 2\n"
"01                   MP_INT = 1 = value for first parameter\n"
"a1 61                MP_STR = 'a' = value for second parameter\n"
"2b                 IPROTO_OPTIONS Map Item#3\n"
"90                 MP_ARRAY, size 0 (there are no options)"
msgstr ""

msgid ""
"Byte codes for the response to the :codenormal:`box.space.`:codeitalic"
":`space-name`:codenormal:`:insert{6}` example:"
msgstr ""

msgid ""
"ce 00 00 00 20                MP_UINT = HEADER + BODY SIZE\n"
"83                            MP_MAP, size 3\n"
"00                              Response-Code-Indicator\n"
"ce 00 00 00 00                  MP_UINT = IPROTO_OK\n"
"01                              IPROTO_SYNC\n"
"cf 00 00 00 00 00 00 00 53      MP_UINT = sync value\n"
"05                              IPROTO_SCHEMA_VERSION\n"
"ce 00 00 00 68                  MP_UINT = schema version\n"
"81                            MP_MAP, size 1\n"
"30                              IPROTO_DATA\n"
"dd 00 00 00 01                  MP_ARRAY, size 1 (row count)\n"
"91                              MP_ARRAY, size 1 (field count)\n"
"06                              MP_INT = 6 = the value that was inserted"
msgstr ""

msgid ""
"Byte codes for the response to the "
"``conn:eval([[box.schema.space.create('_space');]])`` example:"
msgstr ""

msgid ""
"ce 00 00 00 3b                  MP_UINT = HEADER + BODY SIZE\n"
"83                              MP_MAP, size 3 (i.e. 3 items in header)\n"
"  00                              Response-Code-Indicator\n"
"  ce 00 00 80 0a                  MP_UINT = hexadecimal 800a\n"
"  01                              IPROTO_SYNC\n"
"  cf 00 00 00 00 00 00 00 26      MP_UINT = sync value\n"
"  05                              IPROTO_SCHEMA_VERSION\n"
"  ce 00 00 00 78                  MP_UINT = schema version value\n"
"  81                              MP_MAP, size 1\n"
"    31                              IPROTO_ERROR_24\n"
"    db 00 00 00 1d 53 70 61 63 etc. MP_STR = \"Space '_space' already "
"exists\""
msgstr ""

msgid ""
"Byte codes, if we use the same net.box connection that we used for "
":ref:`Binary protocol -- illustration <box_protocol-illustration>` and we"
" say |br| ``conn:execute([[CREATE TABLE t1 (dd INT PRIMARY KEY "
"AUTOINCREMENT, дд STRING COLLATE \"unicode\");]])`` |br| "
"``conn:execute([[INSERT INTO t1 VALUES (NULL, 'a'), (NULL, 'b');]])`` "
"|br| and we watch what tcpdump displays, we will see two noticeable "
"things: (1) the CREATE statement caused a schema change so the response "
"has a new IPROTO_SCHEMA_VERSION value and the body includes the new "
"contents of some system tables (caused by requests from net.box which "
"users will not see); (2) the final bytes of the response to the INSERT "
"will be:"
msgstr ""

msgid ""
"81   MP_MAP, size 1\n"
"42     IPROTO_SQL_INFO\n"
"82     MP_MAP, size 2\n"
"00       Tarantool constant (not in iproto_constants.h) = "
"SQL_INFO_ROW_COUNT\n"
"02       1 = row count\n"
"01       Tarantool constant (not in iproto_constants.h) = "
"SQL_INFO_AUTOINCREMENT_ID\n"
"92       MP_ARRAY, size 2\n"
"01         first autoincrement number\n"
"02         second autoincrement number"
msgstr ""

msgid ""
"Byte codes for the SQL SELECT example, if we ask for full metadata by "
"saying |br| "
":code:`conn.space._session_settings:update('sql_full_metadata', {{'=', "
"'value', true}})` |br| and we select the two rows from the table that we "
"just created |br| :code:`conn:execute([[SELECT dd, дд AS д FROM t1;]])` "
"|br| then tcpdump will show this response, after the header:"
msgstr ""

msgid ""
"82                       MP_MAP, size 2 (i.e. metadata and rows)\n"
"32                         IPROTO_METADATA\n"
"92                         MP_ARRAY, size 2 (i.e. 2 columns)\n"
"85                           MP_MAP, size 5 (i.e. 5 items for column#1)\n"
"00 a2 44 44                    IPROTO_FIELD_NAME + 'DD'\n"
"01 a7 69 6e 74 65 67 65 72     IPROTO_FIELD_TYPE + 'integer'\n"
"03 c2                          IPROTO_FIELD_IS_NULLABLE + false\n"
"04 c3                          IPROTO_FIELD_IS_AUTOINCREMENT + true\n"
"05 c0                          PROTO_FIELD_SPAN + nil\n"
"85                           MP_MAP, size 5 (i.e. 5 items for column#2)\n"
"00 a2 d0 94                    IPROTO_FIELD_NAME + 'Д' upper case\n"
"01 a6 73 74 72 69 6e 67        IPROTO_FIELD_TYPE + 'string'\n"
"02 a7 75 6e 69 63 6f 64 65     IPROTO_FIELD_COLL + 'unicode'\n"
"03 c3                          IPROTO_FIELD_IS_NULLABLE + true\n"
"05 a4 d0 b4 d0 b4              IPROTO_FIELD_SPAN + 'дд' lower case\n"
"30                         IPROTO_DATA\n"
"92                         MP_ARRAY, size 2\n"
"92                           MP_ARRAY, size 2\n"
"01                             MP_INT = 1 i.e. contents of row#1 column#1"
"\n"
"a1 61                          MP_STR = 'a' i.e. contents of row#1 "
"column#2\n"
"92                           MP_ARRAY, size 2\n"
"02                             MP_INT = 2 i.e. contents of row#2 column#1"
"\n"
"a1 62                          MP_STR = 'b' i.e. contents of row#2 "
"column#2"
msgstr ""

msgid ""
"Byte code for the SQL PREPARE example. If we said |br| "
":code:`conn:prepare([[SELECT dd, дд AS д FROM t1;]])` |br| then tcpdump "
"would should show almost the same response, but there would be no "
"IPROTO_DATA and there would be two additional items: |br| 34 00 = "
"IPROTO_BIND_COUNT + MP_UINT = 0 (there are no parameters to bind), |br| "
"33 90 = IPROTO_BIND_METADATA + MP_ARRAY, size 0 (there are no parameters "
"to bind)."
msgstr ""

msgid ""
"84                       MP_MAP, size 4\n"
"43                         IPROTO_STMT_ID\n"
"ce c2 3c 2c 1e             MP_UINT = statement id\n"
"34                         IPROTO_BIND_COUNT\n"
"00                         MP_INT = 0 = number of parameters to bind\n"
"33                         IPROTO_BIND_METADATA\n"
"90                         MP_ARRAY, size 0 = there are no parameters to "
"bind\n"
"32                         IPROTO_METADATA\n"
"92                         MP_ARRAY, size 2 (i.e. 2 columns)\n"
"85                           MP_MAP, size 5 (i.e. 5 items for column#1)\n"
"00 a2 44 44                    IPROTO_FIELD_NAME + 'DD'\n"
"01 a7 69 6e 74 65 67 65 72     IPROTO_FIELD_TYPE + 'integer'\n"
"03 c2                          IPROTO_FIELD_IS_NULLABLE + false\n"
"04 c3                          IPROTO_FIELD_IS_AUTOINCREMENT + true\n"
"05 c0                          PROTO_FIELD_SPAN + nil\n"
"85                           MP_MAP, size 5 (i.e. 5 items for column#2)\n"
"00 a2 d0 94                    IPROTO_FIELD_NAME + 'Д' upper case\n"
"01 a6 73 74 72 69 6e 67        IPROTO_FIELD_TYPE + 'string'\n"
"02 a7 75 6e 69 63 6f 64 65     IPROTO_FIELD_COLL + 'unicode'\n"
"03 c3                          IPROTO_FIELD_IS_NULLABLE + true\n"
"05 a4 d0 b4 d0 b4              IPROTO_FIELD_SPAN + 'дд' lower case"
msgstr ""

msgid "Byte code for the heartbeat example. The master might send this body:"
msgstr ""

msgid ""
"83                      MP_MAP, size 3\n"
"00                        Main-Map Item #1 IPROTO_REQUEST_TYPE\n"
"00                          MP_UINT = 0\n"
"02                        Main-Map Item #2 IPROTO_REPLICA_ID\n"
"02                          MP_UINT = 2 = id\n"
"04                        Main-Map Item #3 IPROTO_TIMESTAMP\n"
"cb                          MP_DOUBLE (MessagePack \"Float 64\")\n"
"41 d7 ba 06 7b 3a 03 21     8-byte timestamp"
msgstr ""

msgid "Byte code for the heartbeat example. The replica might send back this body"
msgstr ""

msgid ""
"81                       MP_MAP, size 1\n"
"00                         Main-Map Item #1 Response-code-indicator\n"
"00                         MP_UINT = 0 = IPROTO_OK\n"
"81                         Main-Map Item #2, MP_MAP, size 1\n"
"26                           Sub-Map Item #1 IPROTO_VCLOCK\n"
"81                           Sub-Map Item #2, MP_MAP, size 1\n"
"01                             MP_UINT = 1 = id (part 1 of vclock)\n"
"06                             MP_UINT = 6 = lsn (part 2 of vclock)"
msgstr ""

msgid "XLOG / SNAP"
msgstr "XLOG / SNAP"

#, fuzzy
msgid ".xlog and .snap files have nearly the same format. The header looks like:"
msgstr ""
"Файлы форматов XLOG и SNAP выглядят практически одинаково. Заголовок "
"выглядит следующим образом:"

msgid ""
"<type>\\n                  SNAP\\n or XLOG\\n\n"
"<version>\\n               currently 0.13\\n\n"
"Server: <server_uuid>\\n   where UUID is a 36-byte string\n"
"VClock: <vclock_map>\\n    e.g. {1: 0}\\n\n"
"\\n"
msgstr ""
"<type>\\n                  SNAP\\n или XLOG\\n\n"
"<version>\\n               в данный момент 0.13\\n\n"
"Server: <server_uuid>\\n   где UUID -- это 36-байтная строка\n"
"VClock: <vclock_map>\\n    например, {1: 0}\\n\n"
"\\n"

msgid ""
"After the file header come the data tuples. Tuples begin with a row "
"marker ``0xd5ba0bab`` and the last tuple may be followed by an EOF marker"
" ``0xd510aded``. Thus, between the file header and the EOF marker, there "
"may be data tuples that have this form:"
msgstr ""
"После файла заголовка идут кортежи с данными. Кортежи начинаются с "
"маркера строки ``0xd5ba0bab``, а после последнего кортежа может стоять "
"маркер конца файла ``0xd510aded``. Таким образом, между заголовком файла "
"и маркером конца файла могут быть кортежи с данными в следующем виде:"

msgid ""
"0            3 4                                         17\n"
"+-------------+========+============+===========+=========+\n"
"|             |        |            |           |         |\n"
"| 0xd5ba0bab  | LENGTH | CRC32 PREV | CRC32 CUR | PADDING |\n"
"|             |        |            |           |         |\n"
"+-------------+========+============+===========+=========+\n"
"  MP_FIXEXT2    MP_INT     MP_INT       MP_INT      ---\n"
"\n"
"+============+ +===================================+\n"
"|            | |                                   |\n"
"|   HEADER   | |                BODY               |\n"
"|            | |                                   |\n"
"+============+ +===================================+\n"
"    MP_MAP                     MP_MAP"
msgstr ""
"0            3 4                                         17\n"
"+-------------+========+============+===========+=========+\n"
"|             |        |            |           |         |\n"
"| 0xd5ba0bab  | LENGTH | CRC32 PREV | CRC32 CUR | PADDING |\n"
"|             |        |            |           |         |\n"
"+-------------+========+============+===========+=========+\n"
"  MP_FIXEXT2    MP_INT     MP_INT       MP_INT      ---\n"
"\n"
"+============+ +===================================+\n"
"|            | |                                   |\n"
"|   HEADER   | |                BODY               |\n"
"|            | |                                   |\n"
"+============+ +===================================+\n"
"    MP_MAP                     MP_MAP"

msgid ""
"See the example in the :ref:`File formats <internals-data_persistence>` "
"section."
msgstr "См. пример в разделе :ref:`Форматы файлов <internals-data_persistence>`."

#~ msgid ""
#~ "**MP_EXT**    extension (including the "
#~ ":ref:`DECIMAL type <box_protocol-decimal>`)"
#~ msgstr ""

#~ msgid "**IPROTO_INSERT** == 0x02."
#~ msgstr ""

#~ msgid ""
#~ "IPROTO_DATA is what we get with "
#~ "net_box and :ref:`Module buffer <buffer-"
#~ "module>` so if we were using "
#~ "net_box we could decode with "
#~ ":ref:`msgpack.decode_unchecked() <msgpack-"
#~ "decode_unchecked>`, or we could convert "
#~ "to a string with "
#~ ":samp:`ffi.string({pointer},{length})`. The "
#~ ":ref:`pickle.unpack() <pickle-unpack>` function "
#~ "might also be helpful."
#~ msgstr ""

#~ msgid ""
#~ "++======================+\n"
#~ "||                      |\n"
#~ "||   0x31: IPROTO_ERROR |\n"
#~ "|| MP_INT: MP_STRING    |\n"
#~ "||                      |\n"
#~ "++======================+\n"
#~ "      MP_MAP"
#~ msgstr ""

#~ msgid ""
#~ "For example, if we try to create"
#~ " a duplicate space with |br| "
#~ "``conn:eval([[box.schema.space.create('_space');]])`` |br| "
#~ "the server response will look like "
#~ "this:"
#~ msgstr ""

#~ msgid ""
#~ "ce 00 00 00 3b                  MP_UINT = HEADER + BODY SIZE\n"
#~ "83                              MP_MAP, size 3 "
#~ "(i.e. 3 items in header)\n"
#~ "  00                              Response-Code-Indicator\n"
#~ "  ce 00 00 80 0a                  MP_UINT = hexadecimal 800a\n"
#~ "  01                              IPROTO_SYNC\n"
#~ "  cf 00 00 00 00 00 00 00 26      MP_UINT = sync value\n"
#~ "  05                              IPROTO_SCHEMA_VERSION\n"
#~ "  ce 00 00 00 78                  MP_UINT = schema version value\n"
#~ "  81                              MP_MAP, size 1\n"
#~ "    31                              IPROTO_ERROR\n"
#~ "    db 00 00 00 1d 53 70 "
#~ "61 63 etc. MP_STR = \"Space "
#~ "'_space' already exists\""
#~ msgstr ""

#~ msgid ""
#~ "Part of the greeting is a "
#~ "base-64-encoded session salt - a random"
#~ " string which can be used for "
#~ "authentication. The length of a decoded"
#~ " salt (44 bytes) exceeds the amount"
#~ " necessary to sign the authentication "
#~ "message (the first 20 bytes). An "
#~ "excess is reserved for future "
#~ "authentication schemas."
#~ msgstr ""
#~ "Когда клиент подключается к экземпляру "
#~ "сервера, экземпляр отвечает 128-байтным "
#~ "текстовым сообщением приветствия. Часть "
#~ "приветствия представляет собой закодированное "
#~ "в формате base-64 значение соль для "
#~ "сессии (случайная строка), которое можно "
#~ "использовать для аутентификации. Длина "
#~ "расшифрованного значения соль (44 байта) "
#~ "выходит за пределы сообщения для "
#~ "аутентификации (первые 20 байтов). Остаток "
#~ "предназначается для будущих схем "
#~ "аутентификации."

#~ msgid ""
#~ "If authentication is not skipped, then"
#~ " at any time an authentication packet"
#~ " can be prepared using the greeting,"
#~ " as follows."
#~ msgstr ""

#~ msgid ""
#~ "PREPARE SCRAMBLE:\n"
#~ "\n"
#~ "    LEN(ENCODED_SALT) = 44;\n"
#~ "    LEN(SCRAMBLE)     = 20;\n"
#~ "\n"
#~ "prepare 'chap-sha1' scramble:\n"
#~ "\n"
#~ "    salt = base64_decode(encoded_salt);\n"
#~ "    step_1 = sha1(password);\n"
#~ "    step_2 = sha1(step_1);\n"
#~ "    step_3 = sha1(salt, step_2);\n"
#~ "    scramble = xor(step_1, step_3);\n"
#~ "    return scramble;\n"
#~ "\n"
#~ "AUTHORIZATION BODY: CODE = IPROTO_AUTH (0x07)\n"
#~ "\n"
#~ "+==========================+====================================+\n"
#~ "|                          |        +-------------+-----------+ |\n"
#~ "|  (KEY)                   | (TUPLE)|  len == 9   | len == 20 | |\n"
#~ "|   0x23: IPROTO_USER_NAME |   0x21:| \"chap-sha1\" |  SCRAMBLE | |\n"
#~ "| MP_INT: MP_STRING        | MP_INT:|  MP_STRING  |  MP_BIN   | |\n"
#~ "|                          |        +-------------+-----------+ |\n"
#~ "|                          |                   MP_ARRAY         |\n"
#~ "+==========================+====================================+\n"
#~ "                        MP_MAP"
#~ msgstr ""

#~ msgid "The DECIMAL type"
#~ msgstr ""

#~ msgid ""
#~ "MessagePack EXT type ``MP_EXT`` together "
#~ "with the extension type ``MP_DECIMAL`` "
#~ "is used as a record header."
#~ msgstr ""

#~ msgid "MP_DECIMAL is 1."
#~ msgstr ""

#~ msgid ""
#~ "`MessagePack spec "
#~ "<https://github.com/MessagePack/MessagePack/blob/master/spec.md"
#~ "#ext-format-family>`_ defines two kinds "
#~ "of types:"
#~ msgstr ""

#~ msgid ""
#~ "``fixext 1/2/4/8/16`` types have fixed "
#~ "length so the length is not "
#~ "encoded explicitly;"
#~ msgstr ""

#~ msgid "``ext 8/16/32`` types require the data length to be encoded."
#~ msgstr ""

#~ msgid "``MP_EXP`` + optional ``length`` imply using one of these types."
#~ msgstr ""

#~ msgid "The decimal MessagePack representation looks like this:"
#~ msgstr ""

#~ msgid ""
#~ "+--------+-------------------+------------+===============+\n"
#~ "| MP_EXT | length (optional) | MP_DECIMAL | PackedDecimal |\n"
#~ "+--------+-------------------+------------+===============+"
#~ msgstr ""

#~ msgid ""
#~ "Here ``length`` is the length of "
#~ "``PackedDecimal`` field, and it is of"
#~ " type ``MP_UINT``, when encoded explicitly"
#~ " (i.e. when the type is ``ext "
#~ "8/16/32``)."
#~ msgstr ""

#~ msgid "``PackedDecimal`` has the following structure:"
#~ msgstr ""

#~ msgid ""
#~ " <--- length bytes -->\n"
#~ "+-------+=============+\n"
#~ "| scale |     BCD     |\n"
#~ "+-------+=============+"
#~ msgstr ""

#~ msgid ""
#~ "Here ``scale`` is either ``MP_INT`` or"
#~ " ``MP_UINT``. |br| ``scale`` = -exponent"
#~ " (exponent negated!)"
#~ msgstr ""

#~ msgid ""
#~ "``BCD`` is a sequence of bytes "
#~ "representing decimal digits of the "
#~ "encoded number (each byte represents two"
#~ " decimal digits each encoded using 4"
#~ " bits), so ``byte >> 4`` is the"
#~ " first digit and ``byte & 0x0f`` "
#~ "is the second digit. The leftmost "
#~ "digit in the array is the most "
#~ "significant. The rightmost digit in the"
#~ " array is the least significant."
#~ msgstr ""

#~ msgid ""
#~ "The first byte of the ``BCD`` "
#~ "array contains the first digit of "
#~ "the number, represented as follows:"
#~ msgstr ""

#~ msgid ""
#~ "|  4 bits           |  4 bits           |\n"
#~ "   = 0x                = the 1st digit"
#~ msgstr ""

#~ msgid ""
#~ "The last byte of the ``BCD`` array"
#~ " contains the last digit of the "
#~ "number and the ``nibble``, represented "
#~ "as follows:"
#~ msgstr ""

#~ msgid ""
#~ "|  4 bits           |  4 bits           |\n"
#~ "   = the last digit    = nibble"
#~ msgstr ""

#~ msgid "The ``nibble`` represents the number's sign:"
#~ msgstr ""

#~ msgid "``0x0a``, ``0x0c``, ``0x0e``, ``0x0f`` stand for plus,"
#~ msgstr ""

#~ msgid "``0x0b`` and ``0x0d`` stand for minus."
#~ msgstr ""

#~ msgid "**Examples**"
#~ msgstr "**Пример:**"

#~ msgid ""
#~ "The decimal ``-12.34`` will be encoded"
#~ " as ``0xd6,0x01,0x02,0x01,0x23,0x4d``:"
#~ msgstr ""

#~ msgid ""
#~ "|MP_EXT (fixext 4) | MP_DECIMAL | scale |  1   |  2,3 |  4 (minus) |\n"
#~ "|       0xd6       |    0x01    | 0x02  | 0x01 | 0x23 | 0x4d       |"
#~ msgstr ""

#~ msgid ""
#~ "The decimal 0.000000000000000000000000000000000010 "
#~ "will be encoded as "
#~ "``0xc7,0x03,0x01,0x24,0x01,0x0c``:"
#~ msgstr ""

#~ msgid ""
#~ "| MP_EXT (ext 8) | length | MP_DECIMAL | scale |  1   | 0 (plus) |\n"
#~ "|      0xc7      |  0x03  |    0x01    | 0x24  | 0x01 | 0x0c     |"
#~ msgstr ""

#~ msgid ""
#~ "Now read the source code file "
#~ "`net_box.c "
#~ "<https://github.com/tarantool/tarantool/blob/master/src/box/lua/net_box.c>`_"
#~ " and skip to the line "
#~ "``netbox_encode_select(lua_State *L)``. From the "
#~ "comments and from simple function calls"
#~ " like \"mpstream_encode_uint(&stream, "
#~ "IPROTO_SPACE_ID);\" you will be able to"
#~ " see how net_box put together the "
#~ "packet contents that you have just "
#~ "observed with tcpdump."
#~ msgstr ""

#~ msgid ""
#~ "Now you know how Tarantool itself "
#~ "makes requests with the binary protocol."
#~ " When in doubt about a detail, "
#~ "consult net_box.c -- it has routines "
#~ "for each request. Some :ref:`connectors "
#~ "<index-box_connectors>` have similar code."
#~ msgstr ""

#~ msgid "**IPROTO_INSERT** = 0x02."
#~ msgstr ""

#~ msgid ""
#~ "See :ref:`conn:eval() <net_box-eval>`. Since"
#~ " the argument is a Lua expression,"
#~ " this is Tarantool's way to handle"
#~ " non-binary with the binary protocol."
#~ " Any request that does not have "
#~ "its own code, for example "
#~ ":samp:`box.space.{space-name}:drop()`, will be "
#~ "handled either with :ref:`IPROTO_CALL "
#~ "<box_protocol-call>` or IPROTO_EVAL. Some "
#~ "client-like utilities, such as "
#~ ":ref:`tarantoolctl <tarantoolctl>`, make extensive"
#~ " use of ``eval``. The body is a"
#~ " 2-item map:"
#~ msgstr ""

#~ msgid ""
#~ "See :ref:`space_object:upsert()  <box_space-"
#~ "upsert>`. The body is the same as"
#~ " the body of :ref:`IPROTO_UPDATE "
#~ "<box_protocol-update>`."
#~ msgstr ""

#~ msgid ""
#~ "84                       MP_MAP, size 4\n"
#~ "43                         IPROTO_STMT_ID\n"
#~ "ce c2 3c 2c 1e             MP_UINT = statement id\n"
#~ "34                         IPROTO_BIND_COUNT\n"
#~ "00                         MP_INT = 0 = number of parameters to bind\n"
#~ "33                         IPROTO_BIND_METADATA\n"
#~ "90                         MP_ARRAY, size 0 ="
#~ " there are no parameters to bind\n"
#~ ""
#~ "32                         IPROTO_METADATA\n"
#~ "92                         MP_ARRAY, size 2 (i.e. 2 columns)\n"
#~ "85                           MP_MAP, size 5 "
#~ "(i.e. 5 items for column#1)\n"
#~ "00 a2 44 44                    IPROTO_FELD_NAME + 'DD'\n"
#~ "01 a7 69 6e 74 65 67 65 72     IPROTO_FIELD_TYPE + 'integer'\n"
#~ "03 c2                          IPROTO_FIELD_IS_NULLABLE + false\n"
#~ "04 c3                          IPROTO_FIELD_IS_AUTOINCREMENT + true\n"
#~ "05 c0                          PROTO_FIELD_SPAN + nil\n"
#~ "85                           MP_MAP, size 5 "
#~ "(i.e. 5 items for column#2)\n"
#~ "00 a2 d0 94                    IPROTO_FIELD_NAME + 'Д' upper case\n"
#~ "01 a6 73 74 72 69 6e 67        IPROTO_FIELD_TYPE + 'string'\n"
#~ "02 a7 75 6e 69 63 6f 64 65     IPROTO_FIELD_COLL + 'unicode'\n"
#~ "03 c3                          IPROTO_FIELD_IS_NULLABLE + true\n"
#~ "05 a4 d0 b4 d0 b4              IPROTO_FIELD_SPAN + 'дд' lower case"
#~ msgstr ""

#~ msgid ""
#~ "JOIN:\n"
#~ "\n"
#~ "In the beginning you must send an initial IPROTO_JOIN request (0x41)\n"
#~ "               HEADER                      BODY\n"
#~ "+================+=======================++========================+\n"
#~ "|                |                       ||   IPROTO_INSTANCE_UUID |\n"
#~ "|   0x00: 0x41   |   0x01: IPROTO_SYNC   ||   0x24: UUID           |\n"
#~ "| MP_INT: MP_INT | MP_INT: MP_INT        || MP_INT: MP_STRING      |\n"
#~ "|                |                       ||                        |\n"
#~ "+================+=======================++========================+\n"
#~ "               MP_MAP                     MP_MAP\n"
#~ "\n"
#~ "Then the instance which you want "
#~ "to connect to will send its last"
#~ " SNAP file, by simply\n"
#~ "creating a number of INSERTs (with additional LSN and ServerID)\n"
#~ "(do not reply to this). Then that"
#~ " instance will send a vclock's MP_MAP"
#~ " and close a socket.\n"
#~ "\n"
#~ "+================+=======================++============================+"
#~ "\n"
#~ "|                |                       ||        "
#~ "+~~~~~~~~~~~~~~~~~+ |\n"
#~ "|                |                       ||        |"
#~ "                 | |\n"
#~ "|   0x00: 0x00   |   0x01: IPROTO_SYNC"
#~ "   ||   0x26:| SRV_ID: SRV_LSN | |"
#~ "\n"
#~ "| MP_INT: MP_INT | MP_INT: MP_INT"
#~ "        || MP_INT:| MP_INT: MP_INT  | "
#~ "|\n"
#~ "|                |                       ||        "
#~ "+~~~~~~~~~~~~~~~~~+ |\n"
#~ "|                |                       ||"
#~ "               MP_MAP       |\n"
#~ "+================+=======================++============================+"
#~ "\n"
#~ "               MP_MAP                      MP_MAP\n"
#~ "\n"
#~ "SUBSCRIBE:\n"
#~ "\n"
#~ "Then you must send an IPROTO_SUBSCRIBE request (0x42)\n"
#~ "\n"
#~ "                              HEADER\n"
#~ "+=========================+========================+\n"
#~ "|                         |                        |\n"
#~ "|     0x00: 0x42          |    0x01: IPROTO_SYNC   |\n"
#~ "|   MP_INT: MP_INT        |  MP_INT: MP_INT        |\n"
#~ "|                         |                        |\n"
#~ "+=========================+========================+\n"
#~ "|    IPROTO_INSTANCE_UUID |    IPROTO_CLUSTER_UUID |\n"
#~ "|   0x24: UUID            |   0x25: UUID           |\n"
#~ "| MP_INT: MP_STRING       | MP_INT: MP_STRING      |\n"
#~ "|                         |                        |\n"
#~ "+=========================+========================+\n"
#~ "                 MP_MAP\n"
#~ "\n"
#~ "      BODY\n"
#~ "+=======================+\n"
#~ "|                       |\n"
#~ "|   0x26: IPROTO_VCLOCK |\n"
#~ "| MP_INT: MP_INT        |\n"
#~ "|                       |\n"
#~ "+=======================+\n"
#~ "      MP_MAP\n"
#~ "\n"
#~ "Then you must process every request "
#~ "that could come through other masters."
#~ "\n"
#~ "Every request between masters will have Additional LSN and SERVER_ID."
#~ msgstr ""

#~ msgid ""
#~ "**IPROTO_SYNC** = 0x01. An unsigned "
#~ "integer that should be incremented so"
#~ " that it is unique in every "
#~ "request. This integer is also returned"
#~ " from :ref:`box.session.sync() <box_session-"
#~ "sync>`. The IPROTO_SYNC value of a "
#~ "response should be the same as the"
#~ " IPROTO_SYNC value of a request."
#~ msgstr ""

#~ msgid "For diagrams in this section, the box borders have special meanings:"
#~ msgstr ""

#~ msgid ""
#~ "0    X\n"
#~ "+----+\n"
#~ "|    | - X + 1 bytes\n"
#~ "+----+\n"
#~ " TYPE - type of MessagePack value (if it is a MessagePack object)\n"
#~ "\n"
#~ "+====+\n"
#~ "|    | - Variable size MessagePack object\n"
#~ "+====+\n"
#~ " TYPE - type of MessagePack value\n"
#~ "\n"
#~ "+~~~~+\n"
#~ "|    | - Variable size MessagePack Array/Map\n"
#~ "+~~~~+\n"
#~ " TYPE - type of MessagePack value"
#~ msgstr ""

#~ msgid ""
#~ "And words that start with **MP_** "
#~ "mean: a `MessagePack <http://MessagePack.org>`_ "
#~ "type or a range of MessagePack "
#~ "types, including the signal and possibly"
#~ " including a value, with slight "
#~ "modification:"
#~ msgstr ""

#~ msgid ""
#~ "**MP_EXT**    extension (including the "
#~ ":ref:`DECIMAL type <msgpack_ext-decimal>`)"
#~ msgstr ""

#~ msgid ""
#~ "And words that start with **IPROTO_**"
#~ " mean: a Tarantool constant which is"
#~ " either defined or mentioned in the"
#~ " `iproto_constants.h file "
#~ "<https://github.com/tarantool/tarantool/blob/master/src/box/iproto_constants.h>`_."
#~ " These constants are used as keys "
#~ "within MP_MAP maps."
#~ msgstr ""

#~ msgid ""
#~ "On terminal #2, start a server "
#~ "with: |br| ``box.cfg{listen=3302}`` |br| "
#~ "``box.schema.user.grant('guest','read,write,execute,create,drop','universe')``"
#~ " |br|"
#~ msgstr ""

#~ msgid ""
#~ "On terminal #3, start another server,"
#~ " which will act as a client, "
#~ "with: |br| ``box.cfg{}`` |br| ``net_box "
#~ "= require('net.box')`` |br| ``conn = "
#~ "net_box.connect('localhost:3302')`` |br| "
#~ "``conn.space._space:select(280)`` |br|"
#~ msgstr ""

#~ msgid ""
#~ "ce 00 00 00 1b   MP_UINT = decimal 27 = number of bytes after this\n"
#~ "82               MP_MAP, size 2 (we'll call this \"Main-Map\")\n"
#~ "01                 IPROTO_SYNC (Main-Map Item#1)\n"
#~ "04                 MP_INT = 4 = number"
#~ " that gets incremented with each "
#~ "request\n"
#~ "00                 IPROTO_REQUEST_TYPE (Main-Map Item#2)\n"
#~ "01                 IPROTO_SELECT\n"
#~ "86                 MP_MAP, size 6 (we'll call this \"Select-Map\")\n"
#~ "10                   IPROTO_SPACE_ID (Select-Map Item#1)\n"
#~ "cd 01 18             MP_UINT = decimal 280 = id of _space\n"
#~ "11                   IPROTO_INDEX_ID (Select-Map Item#2)\n"
#~ "00                   MP_INT = 0 = id of index within _space\n"
#~ "14                   IPROTO_ITERATOR (Select-Map Item#3)\n"
#~ "00                   MP_INT = 0 = "
#~ "Tarantool iterator_type.h constant ITER_EQ\n"
#~ "13                   IPROTO_OFFSET (Select-Map Item#4)\n"
#~ "00                   MP_INT = 0 = amount to offset\n"
#~ "12                   IPROTO_LIMIT (Select-Map Item#5)\n"
#~ "ce ff ff ff ff       MP_UINT = 4294967295 = biggest possible limit\n"
#~ "20                   IPROTO_KEY (Select-Map Item#6)\n"
#~ "91                   MP_ARRAY, size 1 (we'll call this \"Key-Array\")\n"
#~ "cd 01 18               MP_UINT = 280 "
#~ "(Select-Map Item#6, Key-Array Item#1)"
#~ "\n"
#~ "                       -- 280 is the key"
#~ " value that we are searching for"
#~ msgstr ""

#~ msgid "Almost all requests and responses contain both a header and a body."
#~ msgstr ""

#~ msgid ""
#~ "Normal Request/Response header and body:\n"
#~ "\n"
#~ "0        5\n"
#~ "+--------+ +============+ +===================================+\n"
#~ "| HEADER | |            | |                                   |\n"
#~ "| + BODY | |   HEADER   | |               BODY                |\n"
#~ "|  SIZE  | |            | |                                   |\n"
#~ "+--------+ +============+ +===================================+\n"
#~ "  MP_INT       MP_MAP                     MP_MAP"
#~ msgstr ""

#~ msgid ""
#~ "HEADER + BODY SIZE is the size "
#~ "of the header plus the size of "
#~ "the body. It may be useful to "
#~ "compare it with the number of "
#~ "bytes remaining in the packet."
#~ msgstr ""

#~ msgid "HEADER may contain, in any order:"
#~ msgstr ""

#~ msgid ""
#~ "HEADER:\n"
#~ "\n"
#~ "+====================================+=====================+===============================+"
#~ "\n"
#~ "|                                    |                     "
#~ "|                               |\n"
#~ "|   0x00: IPROTO_REQUEST_TYPE        |   0x01:"
#~ " IPROTO_SYNC |   0x05: IPROTO_SCHEMA_VERSION "
#~ "|\n"
#~ "|         or Response-Code-Indicator |"
#~ " MP_INT: MP_INT      | MP_INT: MP_INT"
#~ "                |\n"
#~ "| MP_INT: MP_INT                     |"
#~ "                     |                               |\n"
#~ ""
#~ "|                                    |                     "
#~ "|                               |\n"
#~ "+====================================+=====================+===============================+"
#~ "\n"
#~ "                          MP_MAP"
#~ msgstr ""

#~ msgid ""
#~ "**IPROTO_REQUEST_TYPE** or Response-Code-"
#~ "Indicator = 0x00. An unsigned number "
#~ "that indicates what will be in the"
#~ " BODY. In requests IPROTO_REQUEST_TYPE will"
#~ " be followed by IPROTO_SELECT etc. In"
#~ " responses Response-Code-Indicator will "
#~ "be followed by IPROTO_OK etc."
#~ msgstr ""

#~ msgid ""
#~ "The BODY has the details of the"
#~ " request or response. In a request,"
#~ " it can also be absent or be"
#~ " an empty map. Both these states "
#~ "will be interpreted equally. Responses "
#~ "will contain the BODY anyway even "
#~ "if it is a :ref:`IPROTO_PING "
#~ "<box_protocol-ping>` request."
#~ msgstr ""

#~ msgid ""
#~ "After the :ref:`HEADER <box_protocol-header>`,"
#~ " for a request, there will be a"
#~ " body that begins with these "
#~ "request-type IPROTO codes."
#~ msgstr ""

#~ msgid ""
#~ "See :ref:`space_object:select()  <box_space-"
#~ "select>`. The body is a 6-item "
#~ "map:"
#~ msgstr ""

#~ msgid ""
#~ "+=========================+=========================+=========================+"
#~ "\n"
#~ "|                         |                         |"
#~ "                         |\n"
#~ "|   0x10: IPROTO_SPACE_ID |   0x11: "
#~ "IPROTO_INDEX_ID |   0x12: IPROTO_LIMIT    |"
#~ "\n"
#~ "| MP_INT: MP_INT          | MP_INT: "
#~ "MP_INT          | MP_INT: MP_INT          |"
#~ "\n"
#~ "|                         |                         |"
#~ "                         |\n"
#~ "+=========================+=========================+=========================+"
#~ "\n"
#~ "|                         |                         |"
#~ "                         |\n"
#~ "|   0x13: IPROTO_OFFSET   |   0x14: "
#~ "IPROTO_ITERATOR |   0x20: IPROTO_KEY      |"
#~ "\n"
#~ "| MP_INT: MP_INT          | MP_INT: "
#~ "MP_INT          | MP_INT: MP_ARRAY        |"
#~ "\n"
#~ "|                         |                         |"
#~ "                         |\n"
#~ "+=========================+=========================+=========================+"
#~ "\n"
#~ "             MP_MAP"
#~ msgstr ""

#~ msgid ""
#~ "IPROTO_SPACE_ID (0x10) + MP_INT, "
#~ "IPROTO_INDEX_ID (0x11) + MP_INT, "
#~ "IPROTO_ITERATOR (0x14) + MP_INT, IPROTO_OFFSET"
#~ " (0x13) + MP_INT, IPROTO_LIMIT (0x12) "
#~ "+ MP_INT, IPROTO_KEY (0x20) + MP_ARRAY"
#~ " (array of key values). See the "
#~ "illustration of IPROTO_SELECT in the "
#~ "earlier section, :ref:`Binary protocol -- "
#~ "illustration <box_protocol-illustration>`."
#~ msgstr ""

#~ msgid ""
#~ "+=========================+======================+\n"
#~ "|                         |                      |\n"
#~ "|   0x10: IPROTO_SPACE_ID |   0x21: IPROTO_TUPLE |\n"
#~ "| MP_INT: MP_INT          | MP_INT: MP_ARRAY     |\n"
#~ "|                         |                      |\n"
#~ "+=========================+======================+\n"
#~ "                 MP_MAP"
#~ msgstr ""

#~ msgid ""
#~ "IPROTO_SPACE_ID (0x10) + MP_INT, IPROTO_TUPLE"
#~ " + MP_ARRAY (array of field values)."
#~ msgstr ""

#~ msgid ""
#~ "+=========================+======================+\n"
#~ "|                         |                      |\n"
#~ "|   0x10: IPROTO_SPACE_ID |   0x21: IPROTO_TUPLE |\n"
#~ "| MP_INT: MP_INT          | MP_INT: MP_ARRAY     |\n"
#~ "|                         |                      |\n"
#~ "+=========================+======================+\n"
#~ "               MP_MAP"
#~ msgstr ""

#~ msgid ""
#~ "IPROTO_SPACE_ID (0x10) + MP_INT, IPROTO_TUPLE"
#~ " (0x21) + MP_ARRAY (array of field"
#~ " values)."
#~ msgstr ""

#~ msgid ""
#~ "See :ref:`space_object:update()  <box_space-"
#~ "update>`. The body is usually a "
#~ "4-item map,"
#~ msgstr ""

#~ msgid ""
#~ "+=========================+===============================+\n"
#~ "|                         |                               |\n"
#~ "|   0x10: IPROTO_SPACE_ID |   0x11: IPROTO_INDEX_ID       |\n"
#~ "| MP_INT: MP_INT          | MP_INT: MP_INT                |\n"
#~ "|                         |                               |\n"
#~ "+=========================+===============================+\n"
#~ "|                         |                 +~~~~~~~~~~~+ |\n"
#~ "|                         |                 | usually   | |\n"
#~ "|                         |                 | OPERATOR, | |\n"
#~ "|                         | (IPROTO_TUPLE)  | FIELD_NO, | |\n"
#~ "|   0x20: IPROTO_KEY      |    0x21:        | VALUE     | |\n"
#~ "| MP_INT: MP_ARRAY        |  MP_INT:        +~~~~~~~~~~~+ |\n"
#~ "|                         |                   MP_ARRAY    |\n"
#~ "+=========================+===============================+\n"
#~ "                MP_MAP"
#~ msgstr ""

#~ msgid ""
#~ "IPROTO_SPACE_ID (0x10) + MP_INT, "
#~ "IPROTO_INDEX_ID (0x11) + MP_INT with "
#~ "index number starting with 0, IPROTO_KEY"
#~ " (0x20) + MP_ARRAY (array of index"
#~ " keys), IPROTO_TUPLE (0x21) + MP_ARRAY "
#~ "(array of update operations). |br| If"
#~ " the operation specifies no values, "
#~ "it is a 2-item array: OPERATOR "
#~ "MP_STR = ``\"#\"``, FIELD_NO MP_INT ="
#~ " field number starting with 1. |br|"
#~ " If the operation specifies one "
#~ "value, it is a 3-item array: |br|"
#~ msgstr ""

#~ msgid ""
#~ "0           2\n"
#~ "+-------------+==========+===========+\n"
#~ "|             |          |           |\n"
#~ "| OPERATOR    | FIELD_NO | VALUE     |\n"
#~ "| MP_STR      | MP_INT   | MP_OBJECT |\n"
#~ "|             |          |           |\n"
#~ "+-------------+==========+===========+\n"
#~ "          MP_ARRAY"
#~ msgstr ""

#~ msgid ""
#~ "OPERATOR MP_STR = ``\"+\"`` or ``\"-\"``"
#~ " or ``\"&\"`` or ``\"^\"`` or "
#~ "``\"|\"`` or ``\"!\"`` or ``\"=\"``), "
#~ "FIELD_NO MP_INT = field number starting"
#~ " with 1, VALUE MP_OBJECT, that is,"
#~ " any type, MP_INT, MP_STR, etc.. |br|"
#~ " Otherwise the operation is a 5-item"
#~ " array: |br|"
#~ msgstr ""

#~ msgid ""
#~ "0           2\n"
#~ "+-----------+==========+==========+========+==========+\n"
#~ "|           |          |          |        |          |\n"
#~ "| ':'       | FIELD_NO | POSITION | OFFSET | VALUE    |\n"
#~ "| MP_STR    | MP_INT   | MP_INT   | MP_INT | MP_STR   |\n"
#~ "|           |          |          |        |          |\n"
#~ "+-----------+==========+==========+========+==========+\n"
#~ "                      MP_ARRAY"
#~ msgstr ""

#~ msgid ""
#~ "OPERATOR MP_STR = ``\":\"``, FIELD_NO "
#~ "MP_INT = field number starting with "
#~ "1, POSITION MP_INT, OFFSET MP_INT, VALUE"
#~ " MP_STR."
#~ msgstr ""

#~ msgid ""
#~ "For example, suppose a user changes "
#~ "field #2 in tuple #2 in space "
#~ "#256 to 'BBBB'. The body will look"
#~ " like this: (notice that in this "
#~ "case there is an extra map item"
#~ " IPROTO_INDEX_BASE, to emphasize that field"
#~ " numbers start with 1, which is "
#~ "optional and can be omitted):"
#~ msgstr ""

#~ msgid ""
#~ "+=========================+=========================+====================+"
#~ "\n"
#~ "|                         |                         |"
#~ "                    |\n"
#~ "|   0x10: IPROTO_SPACE_ID |   0x11: "
#~ "IPROTO_INDEX_ID |   0x20: IPROTO_KEY |\n"
#~ "| MP_INT: MP_INT          | MP_INT: "
#~ "MP_INT          | MP_INT: MP_ARRAY   |\n"
#~ "|                         |                         |"
#~ "                    |\n"
#~ "+=========================+=========================+====================+"
#~ "\n"
#~ "                          MP_MAP"
#~ msgstr ""

#~ msgid ""
#~ "IPROTO_SPACE_ID (0x10) + MP_INT, "
#~ "IPROTO_INDEX_ID (0x11) + MP_INT, IPROTO_KEY"
#~ " (0x20) + MP_ARRAY (array of key "
#~ "values)."
#~ msgstr ""

#~ msgid ""
#~ "+==============================+=======================+\n"
#~ "|                              |                       |\n"
#~ "|   0x22: IPROTO_FUNCTION_NAME |   0x21: IPROTO_TUPLE  |\n"
#~ "| MP_INT: MP_STRING            | MP_INT: MP_ARRAY      |\n"
#~ "|                              |                       |\n"
#~ "+==============================+=======================+\n"
#~ "                    MP_MAP"
#~ msgstr ""

#~ msgid ""
#~ "IPROTO_FUNCTION_NAME (0x22) +  function name"
#~ " (MP_STRING), IPROTO_TUPLE (0x22) + array"
#~ " of arguments (MP_ARRAY). The return "
#~ "value is an array of tuples."
#~ msgstr ""

#~ msgid ""
#~ "+=======================+======================+\n"
#~ "|                       |                      |\n"
#~ "|   0x27: IPROTO_EXPR   |   0x21: IPROTO_TUPLE |\n"
#~ "| MP_INT: MP_STRING     | MP_INT: MP_ARRAY     |\n"
#~ "|                       |                      |\n"
#~ "+=======================+======================+\n"
#~ "                MP_MAP"
#~ msgstr ""

#~ msgid ""
#~ "IPROTO_EXPR (0x27) + expression (MP_STRING),"
#~ " IPROTO_TUPLE (0x21) + array of "
#~ "arguments to match placeholders."
#~ msgstr ""

#~ msgid ""
#~ "+===============================+===============================+\n"
#~ "|                               |                               |\n"
#~ "|   0x10: IPROTO_SPACE_ID       |   0x15: IPROTO_INDEX_BASE     |\n"
#~ "| MP_INT: MP_INT                | MP_INT: MP_INT                |\n"
#~ "|                               |                               |\n"
#~ "+===============================+===============================+\n"
#~ "|                 +~~~~~~~~~~~+ |                               |\n"
#~ "|                 | usually   | |   0x21: IPROTO_TUPLE          |\n"
#~ "|                 | OPERATOR, | | MP_INT: MP_ARRAY              |\n"
#~ "| (IPROTO_OPS)    | FIELD_NO, | |                               |\n"
#~ "|    0x28:        | VALUE     | |                               |\n"
#~ "|  MP_INT:        +~~~~~~~~~~~+ |                               |\n"
#~ "|                   MP_ARRAY    |                               |\n"
#~ "+===============================+===============================+\n"
#~ "            MP_MAP"
#~ msgstr ""

#~ msgid ""
#~ "IPROTO_SPACE_ID (0x10) + MP_INT, "
#~ "IPROTO_INDEX_BASE (0x15) + MP_INT with "
#~ "index number starting with 1, IPROTO_OPS"
#~ " (0x28) + MP_ARRAY (array of upsert"
#~ " operations), IPROTO_TUPLE (0x21) + "
#~ "MP_ARRAY (array of primary-key-field "
#~ "values). |br|"
#~ msgstr ""

#~ msgid ""
#~ "The IPROTO_OPS is the same as the"
#~ " IPROTO_OPS of :ref:`IPROTO_UPDATE "
#~ "<box_protocol-update>`."
#~ msgstr ""

#~ msgid ""
#~ "+==============================+======================+\n"
#~ "|                              |                      |\n"
#~ "|   0x22: IPROTO_FUNCTION_NAME |   0x21: IPROTO_TUPLE |\n"
#~ "| MP_INT: MP_STRING            | MP_INT: MP_ARRAY     |\n"
#~ "|                              |                      |\n"
#~ "+==============================+======================+\n"
#~ "                        MP_MAP"
#~ msgstr ""

#~ msgid ""
#~ "IPROTO_FUNCTION_NAME (0x22) +  function name"
#~ " (MP_STRING), IPROTO_TUPLE (0x22) + array"
#~ " of arguments (MP_ARRAY). The response "
#~ "will be a list of values, similar"
#~ " to the :ref:`IPROTO_EVAL <box_protocol-"
#~ "eval>` response."
#~ msgstr ""

#~ msgid ""
#~ "+=========================+=========================+========================+"
#~ "\n"
#~ "|                         |                         |"
#~ "                        |\n"
#~ "|   0x43: IPROTO_STMT_ID  |   0x11: "
#~ "IPROTO_SQL_BIND |   0x20: IPROTO_OPTIONS |"
#~ "\n"
#~ "| MP_INT: MP_INT          | MP_INT: "
#~ "MP_INT          | MP_INT: MP_ARRAY       |"
#~ "\n"
#~ "|   or                    |                         "
#~ "|                        |\n"
#~ "|   0x40: IPROTO_SQL_TEXT |"
#~ "                         |                        |\n"
#~ "| MP_INT: MP_STR          |"
#~ "                         |                        |\n"
#~ "|                         |                         |"
#~ "                        |\n"
#~ "+=========================+=========================+========================+"
#~ "\n"
#~ "                          MP_MAP"
#~ msgstr ""

#~ msgid ""
#~ "IPROTO_STMT_ID (0x43) + statement-id "
#~ "(MP_INT) if executing a prepared "
#~ "statement or IPROTO_SQL_TEXT (0x40) + "
#~ "statement-text (MP_STR) if executing an "
#~ "SQL string, IPROTO_SQL_BIND (0x41) + "
#~ "array of parameter values to match "
#~ "? placeholders or :name placeholders, "
#~ "IPROTO_OPTIONS (0x2b) + array of options"
#~ " (usually empty)."
#~ msgstr ""

#~ msgid ""
#~ "If a statement has both named and"
#~ " non-named parameters, wrap only "
#~ "named ones into a map. The rest"
#~ " of parameters are positional and "
#~ "substituted in order."
#~ msgstr ""

#~ msgid ""
#~ "+=========================+\n"
#~ "|                         |\n"
#~ "|   0x10: IPROTO_STMT_ID  |\n"
#~ "| MP_INT: MP_INT          |\n"
#~ "|   or                    |\n"
#~ "|   0x10: IPROTO_SQL_TEXT |\n"
#~ "| MP_INT: MP_STR          |\n"
#~ "|                         |\n"
#~ "+=========================+\n"
#~ "     MP_MAP"
#~ msgstr ""

#~ msgid ""
#~ "IPROTO_STMT_ID (0x43) + statement-id "
#~ "(MP_INT) if executing a prepared "
#~ "statement or IPROTO_SQL_TEXT (0x40) + "
#~ "statement-text (string) if executing an "
#~ "SQL string. Thus the IPROTO_PREPARE map"
#~ " item is the same as the first"
#~ " item of the :ref:`IPROTO_EXECUTE "
#~ "<box_protocol-execute>` map."
#~ msgstr ""

#~ msgid ""
#~ "See :ref:`conn:ping() <conn-ping>`. The "
#~ "BODY will be an empty map because"
#~ " IPROTO_PING in the HEADER contains "
#~ "all the information that the server "
#~ "instance needs."
#~ msgstr ""

#~ msgid ""
#~ "**IPROTO_JOIN** = 0x41, for replication  "
#~ "|br| **IPROTO_SUBSCRIBE** = 0x42, for "
#~ "replication SUBSCRIBE |br| "
#~ "**IPROTO_VOTE_DEPRECATED** = 0x43, for old "
#~ "style vote, superseded by IPROTO_VOTE "
#~ "|br| **IPROTO_VOTE** = 0x44, for master"
#~ " election |br| **IPROTO_FETCH_SNAPSHOT** = "
#~ "0x45, for starting anonymous replication "
#~ "|br| **IPROTO_REGISTER** =0x46, for leaving"
#~ " anonymous replication."
#~ msgstr ""

#~ msgid ""
#~ "The next two IProto messages are "
#~ "used in replication connections between "
#~ "Tarantool nodes in :ref:`synchronous "
#~ "replication <repl_sync>`. The messages are "
#~ "not supposed to be used by any "
#~ "client applications in their regular "
#~ "connections."
#~ msgstr ""

#~ msgid ""
#~ "This message confirms that the "
#~ "transactions originated from the instance "
#~ "with id = IPROTO_REPLICA_ID have "
#~ "achieved quorum and can be committed,"
#~ " up to LSN = IPROTO_LSN and "
#~ "including it."
#~ msgstr ""

#~ msgid ""
#~ "+===========================+====================+\n"
#~ "|                           |                    |\n"
#~ "|   0x02: IPROTO_REPLICA_ID |   0x03: IPROTO_LSN |\n"
#~ "| MP_UINT: MP_UINT          | MP_UINT: MP_UINT   |\n"
#~ "|                           |                    |\n"
#~ "+===========================+====================+\n"
#~ "                    MP_MAP"
#~ msgstr ""

#~ msgid ""
#~ "After the :ref:`HEADER <box_protocol-header>`,"
#~ " for a response, there will be "
#~ "a body. It will contain IPROTO_OK "
#~ "(0x00) (there was no error), or an"
#~ " error code other than IPROTO_OK "
#~ "(there was an error). Responses to "
#~ "SQL statements are slightly different "
#~ "and will be described in the later"
#~ " section, :ref:`Binary protocol -- "
#~ "responses for SQL <box_protocol-"
#~ "sql_protocol>`."
#~ msgstr ""

#~ msgid ""
#~ "For IPROTO_OK, the header Response-"
#~ "Code-Indicator will be 0 and the "
#~ "body will be:"
#~ msgstr ""

#~ msgid ""
#~ "++=====================+\n"
#~ "||                     |\n"
#~ "||   0x30: IPROTO_DATA |\n"
#~ "|| MP_INT: MP_OBJECT   |\n"
#~ "||                     |\n"
#~ "++=====================+\n"
#~ "    MP_MAP"
#~ msgstr ""

#~ msgid ""
#~ "For :ref:`IPROTO_PING <box_protocol-ping>` the"
#~ " body will be an empty map. For"
#~ " most data-access requests (IPROTO_SELECT"
#~ " IPROTO_INSERT IPROTO_DELETE etc.) it will"
#~ " be an array of tuples that "
#~ "contain an array of fields. For "
#~ ":ref:`IPROTO_EVAL <box_protocol-eval>` and "
#~ ":ref:`IPROTO_CALL <box_protocol-call>` it will"
#~ " usually be an array but, since "
#~ "Lua requests can result in a wide"
#~ " variety of structures, bodies can "
#~ "have a wide variety of structures."
#~ msgstr ""

#~ msgid ""
#~ "For example, after "
#~ ":codenormal:`box.space.`:codeitalic:`space-"
#~ "name`:codenormal:`:insert{6}` a successful response"
#~ " will look like this:"
#~ msgstr ""

#~ msgid ""
#~ "For a response other than IPROTO_OK, "
#~ "the header Response-Code-Indicator will"
#~ " be 0x8XXX and the body will "
#~ "be:"
#~ msgstr ""

#~ msgid ""
#~ "++=========================+\n"
#~ "||                         |\n"
#~ "||   0x31: IPROTO_ERROR_24 |\n"
#~ "|| MP_INT: MP_STRING       |\n"
#~ "||                         |\n"
#~ "++=========================+\n"
#~ "      MP_MAP"
#~ msgstr ""

#~ msgid ""
#~ "For example, in version 2.4.0 or "
#~ "earlier, if we try to create a "
#~ "duplicate space with |br| "
#~ "``conn:eval([[box.schema.space.create('_space');]])`` |br| "
#~ "the server response will look like "
#~ "this:"
#~ msgstr ""

#~ msgid ""
#~ "After the :ref:`HEADER <box_protocol-header>`,"
#~ " for a response to an SQL "
#~ "statement, there will be a body "
#~ "that is slightly different from the "
#~ "body for :ref:`Binary protocol -- "
#~ "responses if no error and no SQL"
#~ " <box_protocol-responses>`."
#~ msgstr ""

#~ msgid ""
#~ "+=========================================================+\n"
#~ "|                                                         |\n"
#~ "|   0x42: IPROTO_SQL_INFO                                 |\n"
#~ "| MP_MAP: usually 1 item  +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+ |\n"
#~ "|                         |                             | |\n"
#~ "|                         |    0x00: SQL_INFO_ROW_COUNT | |\n"
#~ "|                         | MP_UINT: changed row count  | |\n"
#~ "|                         |                             | |\n"
#~ "|                         +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+ |\n"
#~ "|                                                         |\n"
#~ "+=========================================================+"
#~ msgstr ""

#~ msgid ""
#~ "For example, if we use the same"
#~ " net.box connection that we used for"
#~ " :ref:`Binary protocol -- illustration "
#~ "<box_protocol-illustration>` and we say "
#~ "|br| ``conn:execute([[CREATE TABLE t1 (dd "
#~ "INT PRIMARY KEY AUTOINCREMENT, дд STRING"
#~ " COLLATE \"unicode\");]])`` |br| "
#~ "``conn:execute([[INSERT INTO t1 VALUES (NULL,"
#~ " 'a'), (NULL, 'b');]])`` |br| and we"
#~ " watch what tcpdump displays, we will"
#~ " see two noticeable things: (1) the"
#~ " CREATE statement caused a schema "
#~ "change so the response has a new"
#~ " IPROTO_SCHEMA_VERSION value and the body"
#~ " includes the new contents of some"
#~ " system tables (caused by requests "
#~ "from net.box which users will not "
#~ "see); (2) the final bytes of the"
#~ " response to the INSERT will be:"
#~ msgstr ""

#~ msgid ""
#~ "IPROTO_METADATA + array of column maps,"
#~ " with each column map containing at"
#~ " least IPROTO_FIELD_NAME (0x00) + MP_STR,"
#~ " and IPROTO_FIELD_TYPE (0x01) + MP_STR. "
#~ "Additionally, if ``sql_full_metadata`` in the"
#~ " :ref:`_session_settings <box_space-session_settings>`"
#~ " system space is TRUE, then the "
#~ "array will have these additional column"
#~ " maps which correspond to components "
#~ "described in the :ref:`box.execute() <box-"
#~ "sql_if_full_metadata>` section: IPROTO_FIELD_COLL "
#~ "(0x02) + MP_STR, IPROTO_FIELD_IS_NULLABLE "
#~ "(0x03) + MP_BOOL, IPROTO_FIELD_IS_AUTOINCREMENT "
#~ "(0x04) + MP_BOOL, IPROTO_FIELD_SPAN (0x05) "
#~ "+ MP_STR or MP_NIL."
#~ msgstr ""

#~ msgid "IPROTO_DATA + array of tuples = the result set \"rows\""
#~ msgstr ""

#~ msgid ""
#~ "EXECUTE SELECT RESPONSE BODY:\n"
#~ "                              MAP\n"
#~ "+=============================================+===========================+"
#~ "\n"
#~ "|                                             |"
#~ "                           |\n"
#~ "|     0x32: IPROTO_METADATA                   |"
#~ "                           |\n"
#~ "| MP_ARRAY: array of maps:"
#~ "                    |                           |\n"
#~ "|           +~~~~~~~~~~~~~~~~~~~~~~-------~~+ |"
#~ "                           |\n"
#~ "|           | +~~~~~~~~~~~~~-------~~~~~~~+ | "
#~ "|     0x30: IPROTO_DATA     |\n"
#~ "|           | |   0x00: IPROTO_FIELD_NAME "
#~ "| | | MP_ARRAY: array of tuples"
#~ " |\n"
#~ "|           | | MP_STR: field name"
#~ "        | | |                           |\n"
#~ "|           | |   0x01: IPROTO_FIELD_TYPE "
#~ "| | |                           |\n"
#~ "|           | | MP_STR: field type"
#~ "        | | |                           |\n"
#~ "|           | | + more if full "
#~ "metadata   | | |                           |"
#~ "\n"
#~ "|           | +~~~~~~~~~~~~~~~~~~~~~~~~~~~+ | "
#~ "|                           |\n"
#~ "|           |        MP_MAP                 | "
#~ "|                           |\n"
#~ "|           +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+ |"
#~ "                           |\n"
#~ "|                   MP_ARRAY                  |"
#~ "                           |\n"
#~ "|                                             |"
#~ "                           |\n"
#~ "+=============================================+===========================+"
#~ msgstr ""

#~ msgid ""
#~ "For example, if we use the same"
#~ " net_box connection that we used for"
#~ " :ref:`Binary protocol -- illustration "
#~ "<box_protocol-illustration>` and we ask for"
#~ " full metadata by saying |br| "
#~ ":code:`conn.space._session_settings:update('sql_full_metadata', "
#~ "{{'=', 'value', true}})` |br| and we "
#~ "select the two rows from the table"
#~ " that we just created |br| "
#~ ":code:`conn:execute([[SELECT dd, дд AS д "
#~ "FROM t1;]])` |br| then tcpdump will "
#~ "show this response, after the header:"
#~ msgstr ""

#~ msgid ""
#~ "If instead we said |br| "
#~ ":code:`conn:prepare([[SELECT dd, дд AS д "
#~ "FROM t1;]])` |br| then tcpdump would "
#~ "should show almost the same response,"
#~ " but there would be no IPROTO_DATA"
#~ " and there would be two additional"
#~ " items: |br| 34 00 = "
#~ "IPROTO_BIND_COUNT + MP_UINT = 0 (there"
#~ " are no parameters to bind), |br| "
#~ "33 90 = IPROTO_BIND_METADATA + MP_ARRAY,"
#~ " size 0 (there are no parameters "
#~ "to bind)."
#~ msgstr ""

#~ msgid ""
#~ "When a client connects to the "
#~ "server instance, the instance responds "
#~ "with a 128-byte text greeting message,"
#~ " like this:"
#~ msgstr ""

#~ msgid ""
#~ "Greeting packet sent by server after connect:\n"
#~ "\n"
#~ "0                                     63\n"
#~ "+--------------------------------------+\n"
#~ "|                                      |\n"
#~ "| Tarantool Greeting (server version)  |\n"
#~ "|               64 bytes               |\n"
#~ "+---------------------+----------------+\n"
#~ "|                     |                |\n"
#~ "| BASE64 encoded SALT |      NULL      |\n"
#~ "|      44 bytes       |                |\n"
#~ "+---------------------+----------------+\n"
#~ "64                  107              127"
#~ msgstr ""
#~ "ПРИВЕТСТВИЕ TARANTOOL'А:\n"
#~ " \n"
#~ " 0                                     63\n"
#~ " +--------------------------------------+\n"
#~ " |                                      |\n"
#~ " | Приветствие Tarantool'а (версия сервера)  |\n"
#~ " |               64 байта               |\n"
#~ " +---------------------+----------------+\n"
#~ " |                     |                |\n"
#~ " | СОЛЬ в кодировке BASE64 |      NULL      |\n"
#~ " |      44 байта       |                |\n"
#~ " +---------------------+----------------+\n"
#~ " 64                  107              127"

#~ msgid ""
#~ "Part of the greeting is a "
#~ "base-64-encoded session salt - a random"
#~ " string which can be used for "
#~ "authentication. The maximum length of an"
#~ " encoded salt (44 bytes) is more "
#~ "than the amount necessary to create "
#~ "the authentication message. An excess is"
#~ " reserved for future authentication "
#~ "schemas."
#~ msgstr ""

#~ msgid ""
#~ "PREPARE SCRAMBLE:\n"
#~ "\n"
#~ "    size_of_encoded_salt_in_greeting = 44;\n"
#~ "    size_of_salt_after_base64_decode = 32;\n"
#~ "    /* sha1() will only use the first 20 bytes */\n"
#~ "    size_of_any_sha1_digest = 20;\n"
#~ "    size_of_scramble = 20;\n"
#~ "\n"
#~ "prepare 'chap-sha1' scramble:\n"
#~ "\n"
#~ "    salt = base64_decode(encoded_salt);\n"
#~ "    step_1 = sha1(password);\n"
#~ "    step_2 = sha1(step_1);\n"
#~ "    step_3 = sha1(first_20_bytes_of_salt, step_2);\n"
#~ "    scramble = xor(step_1, step_3);\n"
#~ "    return scramble;\n"
#~ "\n"
#~ "AUTHORIZATION BODY: CODE = IPROTO_AUTH (0x07)\n"
#~ "\n"
#~ "+==========================+=====================================+\n"
#~ "|                          |        +-------------+------------+ |\n"
#~ "|  (KEY)                   | (TUPLE)| size == 9   | size == 20 | |\n"
#~ "|   0x23: IPROTO_USER_NAME |   0x21:| \"chap-sha1\" |  SCRAMBLE  | |\n"
#~ "| MP_INT: MP_STRING        | MP_INT:|  MP_STRING  |  MP_STRING | |\n"
#~ "|                          |        +-------------+------------+ |\n"
#~ "|                          |                   MP_ARRAY          |\n"
#~ "+==========================+=====================================+\n"
#~ "                        MP_MAP"
#~ msgstr ""

#~ msgid ""
#~ "-- replication keys\n"
#~ "<server_id>    ::= 0x02\n"
#~ "<lsn>          ::= 0x03\n"
#~ "<timestamp>    ::= 0x04\n"
#~ "<server_uuid>  ::= 0x24\n"
#~ "<cluster_uuid> ::= 0x25\n"
#~ "<vclock>       ::= 0x26"
#~ msgstr ""
#~ "-- ключи для репликации\n"
#~ " <server_id>     ::= 0x02\n"
#~ " <lsn>           ::= 0x03\n"
#~ " <timestamp>     ::= 0x04\n"
#~ " <server_uuid>   ::= 0x24\n"
#~ " <cluster_uuid>  ::= 0x25\n"
#~ " <vclock>        ::= 0x26"

#~ msgid ""
#~ "-- replication codes\n"
#~ "<join>         ::= 0x41\n"
#~ "<subscribe>    ::= 0x42"
#~ msgstr ""
#~ "-- коды для репликации\n"
#~ "<join>      ::= 0x41\n"
#~ "<subscribe> ::= 0x42"

#~ msgid ""
#~ "JOIN:\n"
#~ "\n"
#~ "In the beginning you must send an initial IPROTO_JOIN request (0x41)\n"
#~ "               HEADER                      BODY\n"
#~ "+================+=======================++========================+\n"
#~ "|                |                       ||   IPROTO_INSTANCE_UUID |\n"
#~ "|   0x00: 0x41   |   0x01: IPROTO_SYNC   ||   0x24: UUID           |\n"
#~ "| MP_INT: MP_INT | MP_INT: MP_INT        || MP_INT: MP_STRING      |\n"
#~ "|                |                       ||                        |\n"
#~ "+================+=======================++========================+\n"
#~ "               MP_MAP                     MP_MAP\n"
#~ "\n"
#~ "Then the instance which you want "
#~ "to connect to will send its last"
#~ " SNAP file,\n"
#~ "by simply creating a number of "
#~ "INSERTs (with additional LSN and "
#~ "ServerID)\n"
#~ "(do not reply to this). Then that"
#~ " instance will send a vclock's MP_MAP"
#~ " and\n"
#~ "close a socket.\n"
#~ "\n"
#~ "+================+=======================++============================+"
#~ "\n"
#~ "|                |                       ||        "
#~ "+~~~~~~~~~~~~~~~~~+ |\n"
#~ "|                |                       ||        |"
#~ "                 | |\n"
#~ "|   0x00: 0x00   |   0x01: IPROTO_SYNC"
#~ "   ||   0x26:| SRV_ID: SRV_LSN | |"
#~ "\n"
#~ "| MP_INT: MP_INT | MP_INT: MP_INT"
#~ "        || MP_INT:| MP_INT: MP_INT  | "
#~ "|\n"
#~ "|                |                       ||        "
#~ "+~~~~~~~~~~~~~~~~~+ |\n"
#~ "|                |                       ||"
#~ "               MP_MAP       |\n"
#~ "+================+=======================++============================+"
#~ "\n"
#~ "               MP_MAP                      MP_MAP\n"
#~ "\n"
#~ "SUBSCRIBE:\n"
#~ "\n"
#~ "Then you must send an IPROTO_SUBSCRIBE request (0x42)\n"
#~ "\n"
#~ "                              HEADER\n"
#~ "+=========================+========================+\n"
#~ "|                         |                        |\n"
#~ "|     0x00: 0x42          |    0x01: IPROTO_SYNC   |\n"
#~ "|   MP_INT: MP_INT        |  MP_INT: MP_INT        |\n"
#~ "|                         |                        |\n"
#~ "+=========================+========================+\n"
#~ "|    IPROTO_INSTANCE_UUID |    IPROTO_CLUSTER_UUID |\n"
#~ "|   0x24: UUID            |   0x25: UUID           |\n"
#~ "| MP_INT: MP_STRING       | MP_INT: MP_STRING      |\n"
#~ "|                         |                        |\n"
#~ "+=========================+========================+\n"
#~ "                 MP_MAP\n"
#~ "\n"
#~ "      BODY\n"
#~ "+=======================+\n"
#~ "|                       |\n"
#~ "|   0x26: IPROTO_VCLOCK |\n"
#~ "| MP_INT: MP_INT        |\n"
#~ "|                       |\n"
#~ "+=======================+\n"
#~ "      MP_MAP\n"
#~ "\n"
#~ "Then you must process every request "
#~ "that could come through other masters."
#~ "\n"
#~ "Every request between masters will have Additional LSN and SERVER_ID."
#~ msgstr ""
