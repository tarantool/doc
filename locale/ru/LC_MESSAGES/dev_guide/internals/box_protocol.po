
msgid "Examples"
msgstr "Примеры"

msgid "Binary protocol"
msgstr "Бинарный протокол"

msgid ""
"This section provides information on the Tarantool binary protocol, iproto. "
"The protocol is called \"binary\" because the database is most frequently "
"accessed via binary code instead of Lua request text. Tarantool experts use "
"it:"
msgstr ""

msgid "to write their own connectors"
msgstr ""

msgid "to understand network messages"
msgstr ""

msgid ""
"to support new features that their favorite connector doesn't support yet"
msgstr ""

msgid "to avoid repetitive parsing by the server"
msgstr ""

msgid ""
"The binary protocol provides complete access to Tarantool functionality, "
"including:"
msgstr ""

msgid ""
"request multiplexing, for example ability to issue multiple requests "
"asynchronously via the same connection"
msgstr ""
"мультиплексирование запросов, т.е. возможность асинхронной отправки "
"множества запросов по одному соединению;"

msgid "response format that supports zero-copy writes"
msgstr ""
"формат ответа, который поддерживает запись в режиме без копирования (zero-"
"copy)."

msgid ""
"Since version :doc:`2.11.0 </release/2.11.0>`, you can use the "
":ref:`box.iproto <box_iproto>` submodule to access IPROTO constants and "
"features from Lua. The submodule enables to :ref:`send arbitrary IPROTO "
"packets <reference_lua-box_iproto_send>` over the session's socket and "
":ref:`override the behavior <reference_lua-box_iproto_override>` for all "
"IPROTO request types. Also, :ref:`IPROTO_UNKNOWN <box_iproto-unknown>` "
"constant is introduced. The constant is used for the "
":ref:`box.iproto.override() <reference_lua-box_iproto_override>` API, which "
"allows setting a handler for incoming requests with an unknown type."
msgstr ""

#~ msgid "Introduction"
#~ msgstr "Введение"

#~ msgid ""
#~ "The binary protocol, iproto, is called a \"request/response\" protocol "
#~ "because it is for sending requests to a Tarantool server and receiving "
#~ "responses. There is complete access to Tarantool functionality, including:"
#~ msgstr ""
#~ "Бинарный протокол iproto передает данные по схеме \"запрос-ответ\", то есть "
#~ "он предназначен для отправки запросов на сервер Tarantool и получения "
#~ "ответов. Протокол предоставляет полный доступ к функциям Tarantool, включая:"

#~ msgid ""
#~ "The protocol can be called \"binary\" because the most-frequently-used "
#~ "database accesses are done with binary codes instead of Lua request text. "
#~ "Tarantool experts use it to write their own connectors, to understand "
#~ "network messages, to support new features that their favorite connector "
#~ "doesn't support yet, or to avoid repetitive parsing by the server."
#~ msgstr ""
#~ "Протокол можно назвать \"бинарным\", поскольку наиболее частые обращения к "
#~ "базе данных выполняются с помощью бинарного кода, а не текста запроса на "
#~ "языке Lua. Специалисты по Tarantool используют его, чтобы писать собственные"
#~ " коннекторы, понимать сетевые сообщения, поддерживать новые функции, которые"
#~ " их любимый коннектор еще не поддерживает, или чтобы избежать повторного "
#~ "разбора на сервере."

#~ msgid "Index"
#~ msgstr "Указатель"

#~ msgid "Section"
#~ msgstr "Раздел"

#~ msgid "Description"
#~ msgstr "Описание"

#~ msgid ":ref:`Symbols and terms <box_protocol-notation>`"
#~ msgstr ":ref:`Обозначения и термины <box_protocol-notation>`"

#~ msgid "Notation of binary protocol"
#~ msgstr "Условные обозначения в бинарном протоколе"

#~ msgid ":ref:`Header and body <box_protocol-header>`"
#~ msgstr ":ref:`Заголовок и тело сообщения <box_protocol-header>`"

#~ msgid "Header of a request"
#~ msgstr "Заголовок запроса"

#~ msgid ""
#~ "Requests: |br|:ref:`IPROTO_SELECT <box_protocol-select>` "
#~ "|br|:ref:`IPROTO_INSERT <box_protocol-insert>` |br|:ref:`IPROTO_REPLACE "
#~ "<box_protocol-replace>` |br|:ref:`IPROTO_UPDATE <box_protocol-update>` "
#~ "|br|:ref:`IPROTO_DELETE <box_protocol-delete>` |br|:ref:`IPROTO_CALL_16 "
#~ "<box_protocol-call16>` |br|:ref:`IPROTO_AUTH <box_protocol-auth>` "
#~ "|br|:ref:`IPROTO_EVAL <box_protocol-eval>` |br|:ref:`IPROTO_UPSERT "
#~ "<box_protocol-upsert>` |br|:ref:`IPROTO_CALL <box_protocol-call>` "
#~ "|br|:ref:`IPROTO_EXECUTE <box_protocol-execute>` |br|:ref:`IPROTO_NOP "
#~ "<box_protocol-nop>` |br|:ref:`IPROTO_PREPARE <box_protocol-prepare>` "
#~ "|br|:ref:`IPROTO_PING <box_protocol-ping>` |br|:ref:`IPROTO_JOIN "
#~ "<box_protocol-join>` |br|:ref:`IPROTO_SUBSCRIBE <box_protocol-join>` "
#~ "|br|:ref:`IPROTO_VOTE_DEPRECATED <box_protocol-join>` |br|:ref:`IPROTO_VOTE "
#~ "<box_protocol-join>` |br|:ref:`IPROTO_FETCH_SNAPSHOT <box_protocol-join>` "
#~ "|br|:ref:`IPROTO_REGISTER <box_protocol-join>` |br|:ref:`IPROTO_BEGIN "
#~ "<box_protocol-begin>` |br|:ref:`IPROTO_COMMIT <box_protocol-commit>` "
#~ "|br|:ref:`IPROTO_ROLLBACK <box_protocol-rollback>`"
#~ msgstr ""
#~ "Запросы: |br|:ref:`IPROTO_SELECT <box_protocol-select>` "
#~ "|br|:ref:`IPROTO_INSERT <box_protocol-insert>` |br|:ref:`IPROTO_REPLACE "
#~ "<box_protocol-replace>` |br|:ref:`IPROTO_UPDATE <box_protocol-update>` "
#~ "|br|:ref:`IPROTO_DELETE <box_protocol-delete>` |br|:ref:`IPROTO_CALL_16 "
#~ "<box_protocol-call16>` |br|:ref:`IPROTO_AUTH <box_protocol-auth>` "
#~ "|br|:ref:`IPROTO_EVAL <box_protocol-eval>` |br|:ref:`IPROTO_UPSERT "
#~ "<box_protocol-upsert>` |br|:ref:`IPROTO_CALL <box_protocol-call>` "
#~ "|br|:ref:`IPROTO_EXECUTE <box_protocol-execute>` |br|:ref:`IPROTO_NOP "
#~ "<box_protocol-nop>` |br|:ref:`IPROTO_PREPARE <box_protocol-prepare>` "
#~ "|br|:ref:`IPROTO_PING <box_protocol-ping>` |br|:ref:`IPROTO_JOIN "
#~ "<box_protocol-join>` |br|:ref:`IPROTO_SUBSCRIBE <box_protocol-join>` "
#~ "|br|:ref:`IPROTO_VOTE_DEPRECATED <box_protocol-join>` |br|:ref:`IPROTO_VOTE "
#~ "<box_protocol-join>` |br|:ref:`IPROTO_FETCH_SNAPSHOT <box_protocol-join>` "
#~ "|br|:ref:`IPROTO_REGISTER <box_protocol-join>` |br|:ref:`IPROTO_BEGIN "
#~ "<box_protocol-begin>` |br|:ref:`IPROTO_COMMIT <box_protocol-commit>` "
#~ "|br|:ref:`IPROTO_ROLLBACK <box_protocol-rollback>`"

#~ msgid "Body of a request"
#~ msgstr "Тело запроса"

#~ msgid ":ref:`Responses if no error and no SQL <box_protocol-responses>`"
#~ msgstr ":ref:`Ответы на ошибки и запросы без SQL <box_protocol-responses>`"

#~ msgid "Responses for no SQL"
#~ msgstr "Ответы на запросы без SQL"

#~ msgid ":ref:`Responses for errors <box_protocol-responses_error>`"
#~ msgstr ":ref:`Ответы на ошибки <box_protocol-responses_error>`"

#~ msgid "Responses for errors"
#~ msgstr "Ответы на ошибки"

#~ msgid ":ref:`Responses for SQL <box_protocol-sql_protocol>`"
#~ msgstr ":ref:`Ответы на запросы с SQL <box_protocol-sql_protocol>`"

#~ msgid "Responses for SQL"
#~ msgstr "Ответы на запросы с SQL"

#~ msgid ":ref:`Authentication <box_protocol-authentication>`"
#~ msgstr ":ref:`Аутентификация <box_protocol-authentication>`"

#~ msgid "Authentication after connection"
#~ msgstr "Аутентификация после установления соединения"

#~ msgid ":ref:`Replication <box_protocol-replication>`"
#~ msgstr ":ref:`Репликация <box_protocol-replication>`"

#~ msgid "Replication request"
#~ msgstr "Запрос репликации"

#~ msgid ":ref:`Illustration <box_protocol-illustration>`"
#~ msgstr ":ref:`Примеры <box_protocol-illustration>`"

#~ msgid "Illustration of use"
#~ msgstr "Примеры использования"

#~ msgid ":ref:`XLOG/SNAP <box_protocol-xlog>`"
#~ msgstr ":ref:`XLOG/SNAP <box_protocol-xlog>`"

#~ msgid "Format of .xlog and .snap files"
#~ msgstr "Формат файлов .xlog и .snap"

#~ msgid "Symbols and terms"
#~ msgstr "Обозначения и термины"

#~ msgid ""
#~ "Words that start with **MP_** mean: a `MessagePack "
#~ "<http://MessagePack.org>`_ type or a range of MessagePack types, including "
#~ "the signal and possibly including a value, with slight modification:"
#~ msgstr ""
#~ "Если слово начинается с **MP_**, это указывает на тип `MessagePack "
#~ "<http://MessagePack.org>`_ или ряд типов MessagePack, включая сигнал и, "
#~ "возможно, включая значение, с небольшими изменениями:"

#~ msgid "**MP_NIL**    nil"
#~ msgstr "**MP_NIL**    nil"

#~ msgid "**MP_UINT**   unsigned integer"
#~ msgstr "**MP_UINT**   unsigned integer"

#~ msgid "**MP_INT**    either integer or unsigned integer"
#~ msgstr "**MP_INT**    integer или unsigned integer"

#~ msgid "**MP_STR**    string"
#~ msgstr "**MP_STR**    string"

#~ msgid "**MP_BIN**    binary string"
#~ msgstr "**MP_BIN**    binary string"

#~ msgid "**MP_ARRAY**  array"
#~ msgstr "**MP_ARRAY**  array"

#~ msgid "**MP_MAP**    map"
#~ msgstr "**MP_MAP**    map"

#~ msgid "**MP_BOOL**   boolean"
#~ msgstr "**MP_BOOL**   boolean"

#~ msgid "**MP_FLOAT**  float"
#~ msgstr "**MP_FLOAT**  float"

#~ msgid "**MP_DOUBLE** double"
#~ msgstr "**MP_DOUBLE** double"

#~ msgid ""
#~ "**MP_EXT**    extension (including the :ref:`DECIMAL type <msgpack_ext-"
#~ "decimal>` and UUID type)"
#~ msgstr ""
#~ "**MP_EXT**    extension (включая :ref:`тип DECIMAL <msgpack_ext-decimal>` и "
#~ "тип UUID)"

#~ msgid "**MP_OBJECT** any MessagePack object"
#~ msgstr "**MP_OBJECT** любой объект формата MessagePack"

#~ msgid ""
#~ "Short descriptions are in MessagePack's `\"spec\" page "
#~ "<https://github.com/msgpack/msgpack/blob/master/spec.md>`_."
#~ msgstr ""
#~ "Краткое описание приводится на `странице \"спецификации\" "
#~ "<https://github.com/msgpack/msgpack/blob/master/spec.md>`_ MessagePack."

#~ msgid ""
#~ "And words that start with **IPROTO_** mean: a Tarantool constant which is "
#~ "either defined or mentioned in the `iproto_constants.h file "
#~ "<https://github.com/tarantool/tarantool/blob/master/src/box/iproto_constants.h>`_."
#~ msgstr ""
#~ "Если же слово начинается с **IPROTO_**, это указывает на константу "
#~ "Tarantool, которая либо определена, либо упоминается в `файле "
#~ "iproto_constants.h "
#~ "<https://github.com/tarantool/tarantool/blob/master/src/box/iproto_constants.h>`_."

#~ msgid ""
#~ "The IPROTO constants that identify requests that we will mention in this "
#~ "section are:"
#~ msgstr ""
#~ "В этом разделе мы будем упоминать следующие константы IPROTO, которые "
#~ "идентифицируют запросы:"

#~ msgid ""
#~ "IPROTO_SELECT=0x01\n"
#~ "IPROTO_INSERT=0x02\n"
#~ "IPROTO_REPLACE=0x03\n"
#~ "IPROTO_UPDATE=0x04\n"
#~ "IPROTO_DELETE=0x05\n"
#~ "IPROTO_CALL_16=0x06\n"
#~ "IPROTO_AUTH=0x07\n"
#~ "IPROTO_EVAL=0x08\n"
#~ "IPROTO_UPSERT=0x09\n"
#~ "IPROTO_CALL=0x0a\n"
#~ "IPROTO_EXECUTE=0x0b\n"
#~ "IPROTO_NOP=0x0c\n"
#~ "IPROTO_PREPARE=0x0d\n"
#~ "IPROTO_BEGIN=0x0e\n"
#~ "IPROTO_COMMIT=0x0f\n"
#~ "IPROTO_ROLLBACK=0x10\n"
#~ "IPROTO_RAFT_CONFIRM=0x28\n"
#~ "IPROTO_RAFT_ROLLBACK=0x29\n"
#~ "IPROTO_PING=0x40\n"
#~ "IPROTO_JOIN=0x41\n"
#~ "IPROTO_SUBSCRIBE=0x42\n"
#~ "IPROTO_VOTE_DEPRECATED=0x43\n"
#~ "IPROTO_VOTE=0x44\n"
#~ "IPROTO_FETCH_SNAPSHOT=0x45\n"
#~ "IPROTO_REGISTER=0x46"
#~ msgstr ""
#~ "IPROTO_SELECT=0x01\n"
#~ "IPROTO_INSERT=0x02\n"
#~ "IPROTO_REPLACE=0x03\n"
#~ "IPROTO_UPDATE=0x04\n"
#~ "IPROTO_DELETE=0x05\n"
#~ "IPROTO_CALL_16=0x06\n"
#~ "IPROTO_AUTH=0x07\n"
#~ "IPROTO_EVAL=0x08\n"
#~ "IPROTO_UPSERT=0x09\n"
#~ "IPROTO_CALL=0x0a\n"
#~ "IPROTO_EXECUTE=0x0b\n"
#~ "IPROTO_NOP=0x0c\n"
#~ "IPROTO_PREPARE=0x0d\n"
#~ "IPROTO_BEGIN=0x0e\n"
#~ "IPROTO_COMMIT=0x0f\n"
#~ "IPROTO_ROLLBACK=0x10\n"
#~ "IPROTO_RAFT_CONFIRM=0x28\n"
#~ "IPROTO_RAFT_ROLLBACK=0x29\n"
#~ "IPROTO_PING=0x40\n"
#~ "IPROTO_JOIN=0x41\n"
#~ "IPROTO_SUBSCRIBE=0x42\n"
#~ "IPROTO_VOTE_DEPRECATED=0x43\n"
#~ "IPROTO_VOTE=0x44\n"
#~ "IPROTO_FETCH_SNAPSHOT=0x45\n"
#~ "IPROTO_REGISTER=0x46"

#~ msgid ""
#~ "The IPROTO constants that appear within requests or responses that we will "
#~ "describe in this section are:"
#~ msgstr ""
#~ "В этом разделе мы опишем такие константы IPROTO, которые встречаются в "
#~ "запросах или ответах:"

#~ msgid ""
#~ "IPROTO_OK=0x00\n"
#~ "IPROTO_REQUEST_TYPE=0x00\n"
#~ "IPROTO_SYNC=0x01\n"
#~ "IPROTO_REPLICA_ID=0x02\n"
#~ "IPROTO_LSN=0x03\n"
#~ "IPROTO_TIMESTAMP=0x04\n"
#~ "IPROTO_SCHEMA_VERSION=0x05\n"
#~ "IPROTO_FLAGS=0x09\n"
#~ "IPROTO_STREAM_ID=0x0a\n"
#~ "IPROTO_SPACE_ID=0x10\n"
#~ "IPROTO_INDEX_ID=0x11\n"
#~ "IPROTO_LIMIT=0x12\n"
#~ "IPROTO_OFFSET=0x13\n"
#~ "IPROTO_ITERATOR=0x14\n"
#~ "IPROTO_INDEX_BASE=0x15\n"
#~ "IPROTO_KEY=0x20\n"
#~ "IPROTO_TUPLE=0x21\n"
#~ "IPROTO_FUNCTION_NAME=0x22\n"
#~ "IPROTO_USER_NAME=0x23\n"
#~ "IPROTO_INSTANCE_UUID=0x24\n"
#~ "IPROTO_CLUSTER_UUID=0x25\n"
#~ "IPROTO_VCLOCK=0x26\n"
#~ "IPROTO_EXPR=0x27\n"
#~ "IPROTO_OPS=0x28\n"
#~ "IPROTO_BALLOT=0x29\n"
#~ "IPROTO_BALLOT_IS_RO_CFG=0x01\n"
#~ "IPROTO_BALLOT_VCLOCK=0x02\n"
#~ "IPROTO_BALLOT_GC_VCLOCK=0x03\n"
#~ "IPROTO_BALLOT_IS_RO=0x04\n"
#~ "IPROTO_BALLOT_IS_ANON=0x05\n"
#~ "IPROTO_BALLOT_IS_BOOTED=0x06\n"
#~ "IPROTO_BALLOT_CAN_LEAD=0x07\n"
#~ "IPROTO_TUPLE_META=0x2a\n"
#~ "IPROTO_OPTIONS=0x2b\n"
#~ "IPROTO_DATA=0x30\n"
#~ "IPROTO_ERROR_24=0x31\n"
#~ "IPROTO_METADATA=0x32\n"
#~ "IPROTO_BIND_METADATA=0x33\n"
#~ "IPROTO_BIND_COUNT=0x34\n"
#~ "IPROTO_SQL_TEXT=0x40\n"
#~ "IPROTO_SQL_BIND=0x41\n"
#~ "IPROTO_SQL_INF O=0x42\n"
#~ "IPROTO_STMT_ID=0x43\n"
#~ "IPROTO_ERROR=0x52\n"
#~ "IPROTO_FIELD_NAME=0x00\n"
#~ "IPROTO_FIELD_TYPE=0x01\n"
#~ "IPROTO_FIELD_COLL=0x02\n"
#~ "IPROTO_FIELD_IS_NULLABLE=0x03\n"
#~ "IPROTO_FIELD_IS_AUTOINCREMENT=0x04\n"
#~ "IPROTO_FIELD_SPAN=0x05"
#~ msgstr ""

#~ msgid ""
#~ "To denote message descriptions we will say ``msgpack(...)`` and within it we"
#~ " will use modified `YAML <https://en.wikipedia.org/wiki/YAML>`_ so: |br|"
#~ msgstr ""
#~ "Для обозначения описаний сообщений мы будем вызывать ``msgpack(...)``, а "
#~ "внутри него будем использовать модифицированный `YAML "
#~ "<https://en.wikipedia.org/wiki/YAML>`_ таким образом: |br|"

#~ msgid ""
#~ ":code:`{...}` braces enclose an associative array, also called map, which in"
#~ " MsgPack is MP_MAP, |br| :samp:`{k}: {v}` is a key-value pair, also called "
#~ "map-item, in this section k is always an unsigned-integer value = one of the"
#~ " IPROTO constants, |br| :samp:`{italics}` are for replaceable text, which is"
#~ " the convention throughout this manual. Usually this is a data type but we "
#~ "do not show types of IPROTO constants which happen to always be unsigned "
#~ "8-bit integers, |br| :code:`[...]` is for non-associative arrays, |br| "
#~ ":code:`#` starts a comment, especially for the beginning of a section, |br| "
#~ "everything else is \"as is\". |br| Map-items may appear in any order but in "
#~ "examples we usually use the order that net_box.c happens to use."
#~ msgstr ""
#~ ":code:`{...}` в фигурные скобки заключают ассоциативный массив, в MsgPack "
#~ "это MP_MAP, |br| :samp:`{k}: {v}` — это пара \"ключ-значение\", также "
#~ "называемая элементом ассоциативного массива, в этом разделе k всегда "
#~ "является беззнаковым целым = одной из констант IPROTO, |br| "
#~ ":samp:`{italics}` используются для обозначения заменяемого текста в этом "
#~ "руководстве. Обычно это тип данных, но мы не показываем типы констант "
#~ "IPROTO, которые всегда будут беззнаковыми 8-битными целыми числами, |br| "
#~ ":code:`[...]` — для неассоциативных массивов, |br| :code:`#` начинает "
#~ "комментарий, особенно в начале раздела, |br| все остальное приводится \"как "
#~ "есть\". |br| Элементы ассоциативного массива могут появляться в любом "
#~ "порядке, но в примерах мы обычно используем тот порядок, который "
#~ "используется в net_box.c."

#~ msgid "Header and body"
#~ msgstr "Заголовок и тело сообщения"

#~ msgid ""
#~ "Except during connection (which involves a greeting from the server and "
#~ "optional :ref:`authentication <box_protocol-authentication>` that we will "
#~ "discuss later in this section), the protocol is pure request/response (the "
#~ "client requests and the server responds). It is legal to put more than one "
#~ "request in a packet."
#~ msgstr ""
#~ "Кроме как во время соединения (что включает в себя приветствие сервера и "
#~ "необязательную :ref:`аутентификацию <box_protocol-authentication>`, которую "
#~ "мы обсудим далее в этом разделе), протокол идет по схеме \"запрос-ответ\" "
#~ "(клиент запрашивает, сервер отвечает). Пакет может содержать более одного "
#~ "запроса."

#~ msgid ""
#~ "Almost all requests and responses contain three sections: size, header, and "
#~ "body. The size is an (MP_UINT) unsigned integer, usually a 32-bit unsigned "
#~ "integer. The header and body are (MP_MAP) maps."
#~ msgstr ""
#~ "Почти все запросы и ответы состоят из трех частей: размер, заголовок и тело."
#~ " Размер — это unsigned integer (MP_UINT), обычно 32-битное беззнаковое целое"
#~ " число. Заголовок и тело — это ассоциативные массивы (MP_MAP)."

#~ msgid ""
#~ "# <size>\n"
#~ ":samp:`{{MP_UINT unsigned integer}}`\n"
#~ "# <header>\n"
#~ ":samp:`{{MP_MAP with <header> map-items}}`\n"
#~ "# <body>\n"
#~ ":samp:`{{MP_MAP with <body> map-items}}`"
#~ msgstr ""
#~ "# <size>\n"
#~ ":samp:`{{MP_UINT unsigned integer}}`\n"
#~ "# <header>\n"
#~ ":samp:`{{MP_MAP with <header> map-items}}`\n"
#~ "# <body>\n"
#~ ":samp:`{{MP_MAP with <body> map-items}}`"

#~ msgid ""
#~ "``<size>`` is the size of the header plus the size of the body. It may be "
#~ "useful to compare it with the number of bytes remaining in the packet."
#~ msgstr ""
#~ "``<size>`` — это размер заголовка плюс размер тела сообщения. Есть смысл "
#~ "сравнивать его с количеством байтов, оставшихся в пакете."

#~ msgid "``<header>`` may contain, in any order:"
#~ msgstr "Заголовок ``<header>`` может содержать такие данные в любом порядке:"

#~ msgid ""
#~ "msgpack({\n"
#~ "    IPROTO_REQUEST_TYPE: :samp:`{{MP_UINT unsigned integer}}`,\n"
#~ "    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`,\n"
#~ "    IPROTO_SCHEMA_VERSION: :samp:`{{MP_UINT unsigned integer}}`\n"
#~ "    IPROTO_STREAM_ID: :samp:`{{MP_UINT unsigned integer}}`\n"
#~ "})"
#~ msgstr ""
#~ "msgpack({\n"
#~ "    IPROTO_REQUEST_TYPE: :samp:`{{MP_UINT unsigned integer}}`,\n"
#~ "    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`,\n"
#~ "    IPROTO_SCHEMA_VERSION: :samp:`{{MP_UINT unsigned integer}}`\n"
#~ "    IPROTO_STREAM_ID: :samp:`{{MP_UINT unsigned integer}}`\n"
#~ "})"

#~ msgid ""
#~ "**IPROTO_REQUEST_TYPE** or Response-Code-Indicator = 0x00. An unsigned "
#~ "number that indicates what will be in the ``<body>``. In requests "
#~ "IPROTO_REQUEST_TYPE will be followed by IPROTO_SELECT etc. In responses "
#~ "Response-Code-Indicator will be followed by IPROTO_OK etc."
#~ msgstr ""
#~ "**IPROTO_REQUEST_TYPE** или индикатор кода ответа (Response-Code-Indicator) "
#~ "= 0x00. Это беззнаковое число, которое указывает на то, что будет находиться"
#~ " в теле сообщения ``<body>``. В запросах за IPROTO_REQUEST_TYPE будет "
#~ "следовать IPROTO_SELECT и т. д. В ответах за Response-Code-Indicator будет "
#~ "следовать IPROTO_OK и т. д."

#~ msgid ""
#~ "**IPROTO_SYNC** = 0x01. An unsigned integer that should be incremented so "
#~ "that it is unique in every request. This integer is also returned from "
#~ ":doc:`/reference/reference_lua/box_session/sync`. The IPROTO_SYNC value of a"
#~ " response should be the same as the IPROTO_SYNC value of a request."
#~ msgstr ""
#~ "**IPROTO_SYNC** = 0x01. Это беззнаковое целое число должно увеличиваться "
#~ "так, чтобы оно было уникальным в каждом запросе. Это целое число также "
#~ "возвращается в результате :doc:`/reference/reference_lua/box_session/sync`. "
#~ "Значение IPROTO_SYNC в ответе должно быть таким же, как значение IPROTO_SYNC"
#~ " в запросе."

#~ msgid ""
#~ "**IPROTO_SCHEMA_VERSION** = 0x05. An unsigned number, sometimes called "
#~ "SCHEMA_ID, that goes up when there is a major change. In a request header "
#~ "IPROTO_SCHEMA_VERSION is optional, so the version will not be checked if it "
#~ "is absent. In a response header IPROTO_SCHEMA_VERSION is always present, and"
#~ " it is up to the client to check if it has changed."
#~ msgstr ""
#~ "**IPROTO_SCHEMA_VERSION** = 0x05. Беззнаковое число, иногда называемое "
#~ "SCHEMA_ID, которое увеличивается при значительных изменениях. В заголовке "
#~ "запроса IPROTO_SCHEMA_VERSION указываеть необязательно, поэтому версия не "
#~ "будет проверяться, если она отсутствует. В заголовке ответа "
#~ "IPROTO_SCHEMA_VERSION присутствует всегда, и клиент должен сам проверить, не"
#~ " изменилась ли версия."

#~ msgid ""
#~ "**IPROTO_STREAM_ID** = 0x0a. An unsigned number that should be unique in "
#~ "every stream. In requests IPROTO_STREAM_ID is optional and is useful for two"
#~ " things: ensuring that requests within transactions are done in separate "
#~ "groups, and ensuring strictly consistent execution of requests (whether or "
#~ "not they are within transactions). In responses IPROTO_STREAM_ID does not "
#~ "appear. See :ref:`Binary protocol -- streams <box_protocol-streams>`."
#~ msgstr ""
#~ "**IPROTO_STREAM_ID** = 0x0a. Беззнаковое число, которое должно быть "
#~ "уникально для каждого стрима. В запросах указывать значение IPROTO_STREAM_ID"
#~ " необязательно. Однако оно может понадобиться, если необходимо обрабатывать "
#~ "запросы внутри транзакций отдельными группами или выполнять запросы строго "
#~ "последовательно независимо от того, входят ли они в ту или иную транзакцию. "
#~ "В ответах IPROTO_STREAM_ID отсутствует. См. :ref:`Бинарный протокол -- "
#~ "стримы<box_protocol-streams>`."

#~ msgid ""
#~ "Have a look at file `xrow.c "
#~ "<https://github.com/tarantool/tarantool/blob/master/src/box/xrow.c>`_ "
#~ "function ``xrow_header_encode``, to see how Tarantool encodes the header. "
#~ "Have a look at file net_box.c, function ``netbox_decode_data``, to see how "
#~ "Tarantool decodes the header. For example, in a successful response to "
#~ "``box.space:select()``, the Response-Code-Indicator value will be 0 = "
#~ "IPROTO_OK and the array will have all the tuples of the result."
#~ msgstr ""
#~ "Чтобы понять, как Tarantool кодирует заголовок, обратите внимание на функцию"
#~ " ``xrow_header_encode`` в файле `xrow.c "
#~ "<https://github.com/tarantool/tarantool/blob/master/src/box/xrow.c>`_. Чтобы"
#~ " увидеть, как Tarantool декодирует заголовок, посмотрите функцию "
#~ "``netbox_decode_data`` в файле net_box.c. Например, при успешном ответе на "
#~ "``box.space:select()`` значение индикатора кода ответа будет 0 = IPROTO_OK, "
#~ "а массив будет содержать все кортежи из результата."

#~ msgid "IPROTO_CONFIRM = 0x28"
#~ msgstr "IPROTO_CONFIRM = 0x28"

#~ msgid ""
#~ "This message confirms that the transactions originated from the instance "
#~ "with id = IPROTO_REPLICA_ID have achieved quorum and can be committed, up to"
#~ " and including LSN = IPROTO_LSN. Prior to Tarantool :tarantool-"
#~ "release:`2.10.0`, IPROTO_RAFT_CONFIRM was called IPROTO_CONFIRM."
#~ msgstr ""
#~ "Это сообщение подтверждает, что транзакции до ``LSN = IPROTO_LSN`` "
#~ "включительно из экземпляра с ``id = IPROTO_REPLICA_ID`` набрали кворум и "
#~ "могут пройти коммит. До версии Tarantool :tarantool-release:`2.10.0` запрос "
#~ "IPROTO_RAFT_CONFIRM назывался IPROTO_CONFIRM."

#~ msgid "The body is a 2-item map:"
#~ msgstr ""
#~ "Тело сообщения представляет собой ассоциативный массив из 2 элементов:"

#~ msgid ""
#~ "# <size>\n"
#~ "msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
#~ "# <header>\n"
#~ "msgpack({\n"
#~ "    IPROTO_REQUEST_TYPE: IPROTO_RAFT_CONFIRM,\n"
#~ "    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`\n"
#~ "})\n"
#~ "# <body>\n"
#~ "msgpack({\n"
#~ "    IPROTO_REPLICA_ID: :samp:`{{MP_INT integer}}`,\n"
#~ "    IPROTO_LSN: :samp:`{{MP_INT integer}}`\n"
#~ "})"
#~ msgstr ""
#~ "# <size>\n"
#~ "msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
#~ "# <header>\n"
#~ "msgpack({\n"
#~ "    IPROTO_REQUEST_TYPE: IPROTO_RAFT_CONFIRM,\n"
#~ "    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`\n"
#~ "})\n"
#~ "# <body>\n"
#~ "msgpack({\n"
#~ "    IPROTO_REPLICA_ID: :samp:`{{MP_INT integer}}`,\n"
#~ "    IPROTO_LSN: :samp:`{{MP_INT integer}}`\n"
#~ "})"

#~ msgid "IPROTO_ROLLBACK = 0x29"
#~ msgstr "IPROTO_ROLLBACK = 0x29"

#~ msgid ""
#~ "This message says that the transactions originated from the instance with id"
#~ " = IPROTO_REPLICA_ID couldn't achieve quorum for some reason and should be "
#~ "rolled back, down to LSN = IPROTO_LSN and including it. Prior to Tarantool "
#~ "version 2.10, IPROTO_RAFT_ROLLBACK was called IPROTO_ROLLBACK."
#~ msgstr ""
#~ "В этом сообщении говорится, что транзакции до ``LSN = IPROTO_LSN`` "
#~ "включительно из экземпляра с ``id = IPROTO_REPLICA_ID`` не смогли набрать "
#~ "кворум и будут отменены. До версии Tarantool 2.10 запрос "
#~ "IPROTO_RAFT_ROLLBACK назывался IPROTO_ROLLBACK."

#~ msgid ""
#~ "# <size>\n"
#~ "msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
#~ "# <header>\n"
#~ "msgpack({\n"
#~ "    IPROTO_REQUEST_TYPE: IPROTO_RAFT_ROLLBACK,\n"
#~ "    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`\n"
#~ "})\n"
#~ "# <body>\n"
#~ "msgpack({\n"
#~ "    IPROTO_REPLICA_ID: :samp:`{{MP_INT integer}}`,\n"
#~ "    IPROTO_LSN: :samp:`{{MP_INT integer}}`\n"
#~ "})"
#~ msgstr ""
#~ "# <size>\n"
#~ "msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
#~ "# <header>\n"
#~ "msgpack({\n"
#~ "    IPROTO_REQUEST_TYPE: IPROTO_RAFT_ROLLBACK,\n"
#~ "    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`\n"
#~ "})\n"
#~ "# <body>\n"
#~ "msgpack({\n"
#~ "    IPROTO_REPLICA_ID: :samp:`{{MP_INT integer}}`,\n"
#~ "    IPROTO_LSN: :samp:`{{MP_INT integer}}`\n"
#~ "})"

#~ msgid "Responses if no error and no SQL"
#~ msgstr "Ответы на запросы без ошибок и без SQL"

#~ msgid ""
#~ "After the :ref:`header <box_protocol-header>`, for a response, there will be"
#~ " a body. If there was no error, it will contain IPROTO_OK (0x00). If there "
#~ "was an error, it will contain an error code other than IPROTO_OK. Responses "
#~ "to SQL statements are slightly different and will be described in the later "
#~ "section, :ref:`Binary protocol -- responses for SQL <box_protocol-"
#~ "sql_protocol>`."
#~ msgstr ""
#~ "В ответе после :ref:`заголовка <box_protocol-header>` идет тело сообщения. "
#~ "Если ошибки не было, оно будет содержать IPROTO_OK (0x00). Если была ошибка,"
#~ " то он будет содержать код ошибки, отличный от IPROTO_OK. Ответы на "
#~ "операторы SQL немного отличаются и будут описаны в последующем разделе "
#~ ":ref:`Ответы на SQL-запросы <box_protocol-sql_protocol>`."

#~ msgid ""
#~ "For IPROTO_OK, the header Response-Code-Indicator will be 0 and the body is "
#~ "a 1-item map."
#~ msgstr ""
#~ "Для IPROTO_OK индикатор кода ответа в заголовке будет 0, а тело сообщения "
#~ "будет представлять собой ассоциативный массив, состоящий из 1 элемента."

#~ msgid ""
#~ "# <size>\n"
#~ "msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
#~ "# <header>\n"
#~ "msgpack({\n"
#~ "    Response-Code-Indicator: IPROTO_OK,\n"
#~ "    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer, may be 64-bit}}`,\n"
#~ "    IPROTO_SCHEMA_VERSION: :samp:`{{MP_UINT unsigned integer}}`\n"
#~ "})\n"
#~ "# <body>\n"
#~ "msgpack({\n"
#~ "    IPROTO_DATA: :samp:`{{any type}}`\n"
#~ "})"
#~ msgstr ""
#~ "# <size>\n"
#~ "msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
#~ "# <header>\n"
#~ "msgpack({\n"
#~ "    Response-Code-Indicator: IPROTO_OK,\n"
#~ "    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer, may be 64-bit}}`,\n"
#~ "    IPROTO_SCHEMA_VERSION: :samp:`{{MP_UINT unsigned integer}}`\n"
#~ "})\n"
#~ "# <body>\n"
#~ "msgpack({\n"
#~ "    IPROTO_DATA: :samp:`{{any type}}`\n"
#~ "})"

#~ msgid ""
#~ "For :ref:`IPROTO_PING <box_protocol-ping>` the body will be an empty map. "
#~ "For most data-access requests (IPROTO_SELECT IPROTO_INSERT IPROTO_DELETE "
#~ "etc.) the body is an IPROTO_DATA map with an array of tuples that contain an"
#~ " array of fields. For :ref:`IPROTO_EVAL <box_protocol-eval>` and "
#~ ":ref:`IPROTO_CALL <box_protocol-call>` it will usually be an array but, "
#~ "since Lua requests can result in a wide variety of structures, bodies can "
#~ "have a wide variety of structures."
#~ msgstr ""
#~ "В теле сообщения :ref:`IPROTO_PING <box_protocol-ping>` будет пустой "
#~ "ассоциативный массив. В теле большинства запросов доступа к данным "
#~ "(IPROTO_SELECT, IPROTO_INSERT, IPROTO_DELETE и т.д.) будет ассоциативный "
#~ "массив IPROTO_DATA с массивом кортежей, содержащих массив полей. Для "
#~ ":ref:`IPROTO_EVAL <box_protocol-eval>` и :ref:`IPROTO_CALL <box_protocol-"
#~ "call>` телом обычно будет массив, но поскольку запросы на Lua могут "
#~ "возвращать самые разные структуры, сами тела могут содержать самые разные "
#~ "структуры."

#~ msgid ""
#~ "If this is the fifth message and the request is "
#~ ":codenormal:`box.space.`:codeitalic:`space-name`:codenormal:`:insert{6}`, "
#~ "and the previous schema version was 100, a successful response will look "
#~ "like this:"
#~ msgstr ""
#~ "Если это пятое сообщение, запрос такой: "
#~ ":codenormal:`box.space.`:codeitalic:`space-name`:codenormal:`:insert{6}`, и "
#~ "предыдущая версия схемы была 100, ответ после успешного выполнения будет "
#~ "выглядеть следующим образом:"

#~ msgid ""
#~ "# <size>\n"
#~ "msgpack(32)\n"
#~ "# <header>\n"
#~ "msgpack({\n"
#~ "    Response-Code-Indicator: IPROTO_OK,\n"
#~ "    IPROTO_SYNC: 5,\n"
#~ "    IPROTO_SCHEMA_VERSION: 100\n"
#~ "})\n"
#~ "# <body>\n"
#~ "msgpack({\n"
#~ "    IPROTO_DATA: [[6]]\n"
#~ "})"
#~ msgstr ""
#~ "# <size>\n"
#~ "msgpack(32)\n"
#~ "# <header>\n"
#~ "msgpack({\n"
#~ "    Response-Code-Indicator: IPROTO_OK,\n"
#~ "    IPROTO_SYNC: 5,\n"
#~ "    IPROTO_SCHEMA_VERSION: 100\n"
#~ "})\n"
#~ "# <body>\n"
#~ "msgpack({\n"
#~ "    IPROTO_DATA: [[6]]\n"
#~ "})"

#~ msgid ""
#~ "Later in :ref:`Binary protocol -- illustration <box_protocol-illustration>` "
#~ "we will show actual byte codes of the response to the IPROTO_INSERT message."
#~ msgstr ""
#~ "Далее в разделе :ref:`Примеры <box_protocol-illustration>` будут приведены "
#~ "байт-коды ответа на сообщение IPROTO_INSERT."

#~ msgid ""
#~ "IPROTO_DATA is what we get with net_box and :ref:`Module buffer <buffer-"
#~ "module>` so if we were using net_box we could decode with "
#~ ":ref:`msgpack.decode_unchecked() <msgpack-decode_unchecked_string>`, or we "
#~ "could convert to a string with :samp:`ffi.string({pointer},{length})`. The "
#~ ":ref:`pickle.unpack() <pickle-unpack>` function might also be helpful."
#~ msgstr ""
#~ "IPROTO_DATA возвращается в результате использования net_box и :ref:`модуля "
#~ "buffer <buffer-module>`. То есть если бы мы использовали net_box, то могли "
#~ "бы интерпретировать результат с помощью :ref:`msgpack.decode_unchecked() "
#~ "<msgpack-decode_unchecked_string>` или преобразовать его в строку с помощью "
#~ ":samp:`ffi.string({pointer},{length})`. Также здесь можно использовать "
#~ "функцию :ref:`pickle.unpack() <pickle-unpack>`."

#~ msgid "Responses for no error and out-of-band"
#~ msgstr "Ответы на внеполосные сообщения"

#~ msgid ""
#~ "If the response is out-of-band, due to use of :ref:`box.session.push() "
#~ "<box_session-push>`, then the header Response-Code-Indicator will be "
#~ "IPROTO_CHUNK instead of IPROTO_OK."
#~ msgstr ""
#~ "Если используется :ref:`box.session.push() <box_session-push>`, значением "
#~ "заголовка Response-Code-Indicator для внеполосных сообщений будет "
#~ "IPROTO_CHUNK, а не IPROTO_OK."

#~ msgid ""
#~ "For a response other than IPROTO_OK, the header Response-Code-Indicator will"
#~ " be ``0x8XXX`` and the body will be a 1-item map."
#~ msgstr ""
#~ "Для ответа, отличного от IPROTO_OK, индикатор кода ответа в заголовке будет "
#~ "``0x8XXX``, а тело будет представлять собой ассоциативный массив, состоящий "
#~ "из 1 элемента."

#~ msgid ""
#~ "# <size>\n"
#~ "msgpack(32)\n"
#~ "# <header>\n"
#~ "msgpack({\n"
#~ "    Response-Code-Indicator: :samp:`{{0x8XXX}}`,\n"
#~ "    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer, may be 64-bit}}`,\n"
#~ "    IPROTO_SCHEMA_VERSION: :samp:`{{MP_UINT unsigned integer}}`\n"
#~ "})\n"
#~ "# <body>\n"
#~ "msgpack({\n"
#~ "    IPROTO_ERROR: :samp:`{{MP_STRING string}}`\n"
#~ "})"
#~ msgstr ""
#~ "# <size>\n"
#~ "msgpack(32)\n"
#~ "# <header>\n"
#~ "msgpack({\n"
#~ "    Response-Code-Indicator: :samp:`{{0x8XXX}}`,\n"
#~ "    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer, may be 64-bit}}`,\n"
#~ "    IPROTO_SCHEMA_VERSION: :samp:`{{MP_UINT unsigned integer}}`\n"
#~ "})\n"
#~ "# <body>\n"
#~ "msgpack({\n"
#~ "    IPROTO_ERROR: :samp:`{{MP_STRING string}}`\n"
#~ "})"

#~ msgid ""
#~ "where ``0x8XXX`` is the indicator for an error and ``XXX`` is a value in "
#~ "`src/box/errcode.h "
#~ "<https://github.com/tarantool/tarantool/blob/master/src/box/errcode.h>`_. "
#~ "``src/box/errcode.h`` also has some convenience macros which define "
#~ "hexadecimal constants for return codes."
#~ msgstr ""
#~ "где ``0x8XXX`` — это индикатор ошибки, а ``XXX`` — это значение из файла "
#~ "`src/box/errcode.h "
#~ "<https://github.com/tarantool/tarantool/blob/master/src/box/errcode.h>`_. В "
#~ "``src/box/errcode.h`` также есть несколько удобных макросов, которые "
#~ "определяют шестнадцатеричные константы для кодов возврата."

#~ msgid ""
#~ "In version 2.4.0 and earlier, if this is the fifth message and the request "
#~ "is to create a duplicate space with "
#~ "``conn:eval([[box.schema.space.create('_space');]])`` the unsuccessful "
#~ "response will look like this:"
#~ msgstr ""
#~ "В версии 2.4.0 и раньше, если это пятое сообщение и отправляется запрос на "
#~ "создание дубликата спейса с помощью "
#~ "``conn:eval([[box.schema.space.create('_space');]])``, то ответ на "
#~ "невыполненный запрос будет выглядеть следующим образом:"

#~ msgid ""
#~ "# <size>\n"
#~ "msgpack(32)\n"
#~ "# <header>\n"
#~ "msgpack({\n"
#~ "    Response-Code-Indicator: 0x800a,\n"
#~ "    IPROTO_SYNC: 5,\n"
#~ "    IPROTO_SCHEMA_VERSION: 0x78\n"
#~ "})\n"
#~ "# <body>\n"
#~ "msgpack({\n"
#~ "    IPROTO_ERROR:  \"Space '_space' already exists\"\n"
#~ "})"
#~ msgstr ""
#~ "# <size>\n"
#~ "msgpack(32)\n"
#~ "# <header>\n"
#~ "msgpack({\n"
#~ "    Response-Code-Indicator: 0x800a,\n"
#~ "    IPROTO_SYNC: 5,\n"
#~ "    IPROTO_SCHEMA_VERSION: 0x78\n"
#~ "})\n"
#~ "# <body>\n"
#~ "msgpack({\n"
#~ "    IPROTO_ERROR:  \"Space '_space' already exists\"\n"
#~ "})"

#~ msgid ""
#~ "Later in :ref:`Binary protocol -- illustration <box_protocol-illustration>` "
#~ "we will show actual byte codes of the response to the IPROTO_EVAL message."
#~ msgstr ""
#~ "Далее в разделе :ref:`Примеры <box_protocol-illustration>` будут приведены "
#~ "байт-коды ответа на сообщение IPROTO_EVAL."

#~ msgid ""
#~ "Looking in errcode.h we find that error code 0x0a (decimal 10) is "
#~ "ER_SPACE_EXISTS, and the string associated with ER_SPACE_EXISTS is \"Space "
#~ "'%s' already exists\"."
#~ msgstr ""
#~ "Заглянув в errcode.h, по коду ошибки 0x0a (10 в десятичной системе) мы "
#~ "обнаружим ER_SPACE_EXISTS, чему соответствует строка \"Space '%s' already "
#~ "exists\" (\"Спейс '%s' уже существует\")."

#~ msgid ""
#~ "Since version :doc:`2.4.1 </release/2.4.1>`, responses for errors have extra"
#~ " information following what was described above. This extra information is "
#~ "given via MP_ERROR extension type. See details in :ref:`MessagePack "
#~ "extensions <msgpack_ext-error>` section."
#~ msgstr ""
#~ "Начиная с версии :doc:`2.4.1 </release/2.4.1>`, ответы на ошибки содержат "
#~ "дополнительную информацию, как описано выше. Эта дополнительная информация "
#~ "передается с помощью расширения MP_ERROR. Подробную информацию см. в разделе"
#~ " :ref:`расширения MessagePack <msgpack_ext-error>`."

#~ msgid ""
#~ "After the :ref:`header <box_protocol-header>`, for a response to an SQL "
#~ "statement, there will be a body that is slightly different from the body for"
#~ " :ref:`Binary protocol -- responses if no error and no SQL <box_protocol-"
#~ "responses>`."
#~ msgstr ""
#~ "В ответе на SQL-запрос после :ref:`заголовка <box_protocol-header>` идет "
#~ "тело сообщения, которое немного отличается от тела сообщения, описанного в "
#~ "разделе :ref:`Ответы на запросы без ошибок и без SQL <box_protocol-"
#~ "responses>`."

#~ msgid ""
#~ "If the SQL request is not SELECT or VALUES or PRAGMA, then the response body"
#~ " contains only IPROTO_SQL_INFO (0x42). Usually IPROTO_SQL_INFO is a map with"
#~ " only one item -- SQL_INFO_ROW_COUNT (0x00) -- which is the number of "
#~ "changed rows."
#~ msgstr ""
#~ "Если SQL-запрос не содержит операторы SELECT, VALUES или PRAGMA, то тело "
#~ "ответа содержит только IPROTO_SQL_INFO (0x42). Обычно IPROTO_SQL_INFO "
#~ "представляет собой ассоциативный массив с одним элементом — "
#~ "SQL_INFO_ROW_COUNT (0x00) — количество измененных строк."

#~ msgid ""
#~ "# <size>\n"
#~ "msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
#~ "# <header>\n"
#~ "msgpack({\n"
#~ "    Response-Code-Indicator: IPROTO_OK,\n"
#~ "    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer, may be 64-bit}}`,\n"
#~ "    IPROTO_SCHEMA_VERSION: :samp:`{{MP_UINT unsigned integer}}`\n"
#~ "})\n"
#~ "# <body>\n"
#~ "msgpack({\n"
#~ "    IPROTO_SQL_INFO: {\n"
#~ "        SQL_INFO_ROW_COUNT: :samp:`{{MP_UINT}}`\n"
#~ "    }\n"
#~ "})"
#~ msgstr ""
#~ "# <size>\n"
#~ "msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
#~ "# <header>\n"
#~ "msgpack({\n"
#~ "    Response-Code-Indicator: IPROTO_OK,\n"
#~ "    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer, may be 64-bit}}`,\n"
#~ "    IPROTO_SCHEMA_VERSION: :samp:`{{MP_UINT unsigned integer}}`\n"
#~ "})\n"
#~ "# <body>\n"
#~ "msgpack({\n"
#~ "    IPROTO_SQL_INFO: {\n"
#~ "        SQL_INFO_ROW_COUNT: :samp:`{{MP_UINT}}`\n"
#~ "    }\n"
#~ "})"

#~ msgid ""
#~ "For example, if the request is :samp:`INSERT INTO {table-name} VALUES (1), "
#~ "(2), (3)`, then the response body contains an :samp:`IPROTO_SQL_INFO map "
#~ "with SQL_INFO_ROW_COUNT = 3`. :samp:`SQL_INFO_ROW_COUNT` can be 0 for "
#~ "statements that do not change rows, but can be 1 for statements that create "
#~ "new objects."
#~ msgstr ""
#~ "Например, для запроса :samp:`INSERT INTO {table-name} VALUES (1), (2), (3)` "
#~ "тело ответа содержит ассоциативный массив :samp:`IPROTO_SQL_INFO с "
#~ "SQL_INFO_ROW_COUNT = 3`. :samp:`SQL_INFO_ROW_COUNT` может быть 0, если "
#~ "оператор не изменяет строку, и может быть 1, если оператор создает новый "
#~ "объект."

#~ msgid ""
#~ "The IPROTO_SQL_INFO map may contain a second item -- "
#~ ":samp:`SQL_INFO_AUTO_INCREMENT_IDS (0x01)` -- which is the new primary-key "
#~ "value (or values) for an INSERT in a table defined with PRIMARY KEY "
#~ "AUTOINCREMENT. In this case the MP_MAP will have two keys, and  one of the "
#~ "two keys will be 0x01: SQL_INFO_AUTO_INCREMENT_IDS, which is an array of "
#~ "unsigned integers."
#~ msgstr ""
#~ "Ассоциативный массив IPROTO_SQL_INFO может содержать второй элемент "
#~ ":samp:`SQL_INFO_AUTO_INCREMENT_IDS (0x01)`, который представляет собой новое"
#~ " значение (или значения) первичного ключа в операции вставки INSERT в "
#~ "таблицу с автоматическим увеличением первичного ключа PRIMARY KEY "
#~ "AUTOINCREMENT. В этом случае MP_MAP будет содержать два ключа, и одним из "
#~ "двух ключей будет 0x01: SQL_INFO_AUTO_INCREMENT_IDS, который представляет "
#~ "собой массив целых беззнаковых чисел."

#~ msgid ""
#~ "If the SQL statement is SELECT or VALUES or PRAGMA, the response contains:"
#~ msgstr ""
#~ "Если запрос содержит SQL-оператор SELECT, VALUES или PRAGMA, ответ будет:"

#~ msgid ""
#~ "# <size>\n"
#~ "msgpack(32)\n"
#~ "# <header>\n"
#~ "msgpack({\n"
#~ "    Response-Code-Indicator: IPROTO_OK,\n"
#~ "    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer, may be 64-bit}}`,\n"
#~ "    IPROTO_SCHEMA_VERSION: :samp:`{{MP_UINT unsigned integer}}`\n"
#~ "})\n"
#~ "# <body>\n"
#~ "msgpack({\n"
#~ "    IPROTO_METADATA: :samp:`{{array of column maps}}`,\n"
#~ "    IPROTO_DATA: :samp:`{{array of tuples}}`\n"
#~ "})"
#~ msgstr ""
#~ "# <size>\n"
#~ "msgpack(32)\n"
#~ "# <header>\n"
#~ "msgpack({\n"
#~ "    Response-Code-Indicator: IPROTO_OK,\n"
#~ "    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer, may be 64-bit}}`,\n"
#~ "    IPROTO_SCHEMA_VERSION: :samp:`{{MP_UINT unsigned integer}}`\n"
#~ "})\n"
#~ "# <body>\n"
#~ "msgpack({\n"
#~ "    IPROTO_METADATA: :samp:`{{array of column maps}}`,\n"
#~ "    IPROTO_DATA: :samp:`{{array of tuples}}`\n"
#~ "})"

#~ msgid ""
#~ ":samp:`IPROTO_METADATA: {array of column maps}` = array of column maps, with"
#~ " each column map containing at least IPROTO_FIELD_NAME (0x00) and MP_STR, "
#~ "and IPROTO_FIELD_TYPE (0x01) and MP_STR. Additionally, if "
#~ "``sql_full_metadata`` in the :ref:`_session_settings <box_space-"
#~ "session_settings>` system space is TRUE, then the array will have these "
#~ "additional column maps which correspond to components described in the "
#~ ":ref:`box.execute() <box-sql_if_full_metadata>` section:"
#~ msgstr ""
#~ ":samp:`IPROTO_METADATA: {array of column maps}` --- массив ассоциативных "
#~ "массивов, причем каждый ассоциативный массив содержит по крайней мере "
#~ "IPROTO_FIELD_NAME (0x00) + MP_STR и IPROTO_FIELD_TYPE (0x01) + MP_STR. Кроме"
#~ " того, если в системном спейсе :ref:`_session_settings <box_space-"
#~ "session_settings>` задано значение TRUE для ``sql_full_metadata``, то массив"
#~ " будет содержать такие дополнительные ассоциативные массивы, которые "
#~ "соответствуют компонентам, описанным в разделе :ref:`box.execute() <box-"
#~ "sql_if_full_metadata>`:"

#~ msgid ""
#~ "IPROTO_FIELD_COLL (0x02) and MP_STR\n"
#~ "IPROTO_FIELD_IS_NULLABLE (0x03) and MP_BOOL\n"
#~ "IPROTO_FIELD_IS_AUTOINCREMENT (0x04) and MP_BOOL\n"
#~ "IPROTO_FIELD_SPAN (0x05) and MP_STR or MP_NIL"
#~ msgstr ""
#~ "IPROTO_FIELD_COLL (0x02) + MP_STR\n"
#~ "IPROTO_FIELD_IS_NULLABLE (0x03) + MP_BOOL\n"
#~ "IPROTO_FIELD_IS_AUTOINCREMENT (0x04) + MP_BOOL\n"
#~ "IPROTO_FIELD_SPAN (0x05) + MP_STR или MP_NIL"

#~ msgid ":samp:`IPROTO_DATA:{array of tuples}` = the result set \"rows\"."
#~ msgstr ""
#~ ":samp:`IPROTO_DATA:{array of tuples}` = строки результирующего набора."

#~ msgid ""
#~ "If we ask for full metadata by saying |br| "
#~ ":code:`conn.space._session_settings:update('sql_full_metadata', {{'=', "
#~ "'value', true}})` |br| and we select the two rows from a table named t1 that"
#~ " has columns named DD and Д, with |br| :code:`conn:execute([[SELECT dd, дд "
#~ "AS д FROM t1;]])` |br| we could get this response, in the body:"
#~ msgstr ""
#~ "Если мы запросим полные метаданные, вызвав |br| "
#~ ":code:`conn.space._session_settings:update('sql_full_metadata', {{'=', "
#~ "'value', true}})` |br| и выберем две строки из таблицы t1, в которой есть "
#~ "столбцы DD и Д, с помощью |br| :code:`conn:execute([[SELECT dd, дд AS д FROM"
#~ " t1;]])` |br| мы можем получить такой ответ:"

#~ msgid ""
#~ "# <body>\n"
#~ "msgpack({\n"
#~ "    IPROTO_METADATA: [\n"
#~ "        IPROTO_FIELD_NAME: 'DD',\n"
#~ "        IPROTO_FIELD_TYPE: 'integer',\n"
#~ "        IPROTO_FIELD_IS_NULLABLE: false,\n"
#~ "        IPROTO_FIELD_IS_AUTOINCREMENT: true,\n"
#~ "        IPROTO_FIELD_SPAN: nil,\n"
#~ "        IPROTO_FIELD_NAME: 'Д',\n"
#~ "        IPROTO_FIELD_TYPE: 'string',\n"
#~ "        IPROTO_FIELD_COLL: 'unicode',\n"
#~ "        IPROTO_FIELD_IS_NULLABLE: true,\n"
#~ "        IPROTO_FIELD_SPAN: 'дд'\n"
#~ "    ],\n"
#~ "    IPROTO_DATA: [\n"
#~ "        [1,'a'],\n"
#~ "        [2,'b']'\n"
#~ "    ]\n"
#~ "})"
#~ msgstr ""
#~ "# <body>\n"
#~ "msgpack({\n"
#~ "    IPROTO_METADATA: [\n"
#~ "        IPROTO_FIELD_NAME: 'DD',\n"
#~ "        IPROTO_FIELD_TYPE: 'integer',\n"
#~ "        IPROTO_FIELD_IS_NULLABLE: false,\n"
#~ "        IPROTO_FIELD_IS_AUTOINCREMENT: true,\n"
#~ "        IPROTO_FIELD_SPAN: nil,\n"
#~ "        IPROTO_FIELD_NAME: 'Д',\n"
#~ "        IPROTO_FIELD_TYPE: 'string',\n"
#~ "        IPROTO_FIELD_COLL: 'unicode',\n"
#~ "        IPROTO_FIELD_IS_NULLABLE: true,\n"
#~ "        IPROTO_FIELD_SPAN: 'дд'\n"
#~ "    ],\n"
#~ "    IPROTO_DATA: [\n"
#~ "        [1,'a'],\n"
#~ "        [2,'b']'\n"
#~ "    ]\n"
#~ "})"

#~ msgid ""
#~ "If instead we said |br| :code:`conn:prepare([[SELECT dd, дд AS д FROM "
#~ "t1;]])` |br| then we could get almost the same response, but there would be "
#~ "no IPROTO_DATA and there would be two additional items: |br| ``34 00 = "
#~ "IPROTO_BIND_COUNT and MP_UINT = 0`` (there are no parameters to bind), |br| "
#~ "``33 90 = IPROTO_BIND_METADATA and MP_ARRAY, size 0`` (there are no "
#~ "parameters to bind)."
#~ msgstr ""
#~ "Если бы вместо этого мы вызвали :code:`conn:prepare([[SELECT dd, дд AS д "
#~ "FROM t1;]])`, мы получили бы почти такой же ответ, но без IPROTO_DATA и с "
#~ "двумя дополнительными элементами: |br| ``34`` (IPROTO_BIND_COUNT) и ``00`` "
#~ "(MP_UINT = 0, нет параметров), ``33`` (IPROTO_BIND_METADATA) и ``90`` "
#~ "(MP_ARRAY размера 0, нет параметров)."

#~ msgid ""
#~ "# <body>\n"
#~ "msgpack({\n"
#~ "    IPROTO_STMT_ID: :samp:`{{MP_UINT unsigned integer}}`,\n"
#~ "    IPROTO_BIND_COUNT: :samp:`{{MP_INT integer}}`,\n"
#~ "    IPROTO_BIND_METADATA: :samp:`{{array of parameter descriptors}}`,\n"
#~ "        IPROTO_METADATA: [\n"
#~ "            IPROTO_FIELD_NAME: 'DD',\n"
#~ "            IPROTO_FIELD_TYPE: 'integer',\n"
#~ "            IPROTO_FIELD_IS_NULLABLE: false\n"
#~ "            IPROTO_FIELD_IS_AUTOINCREMENT: true\n"
#~ "            IPROTO_FIELD_SPAN: nil,\n"
#~ "            IPROTO_FIELD_NAME: 'Д',\n"
#~ "            IPROTO_FIELD_TYPE: 'string',\n"
#~ "            IPROTO_FIELD_COLL: 'unicode',\n"
#~ "            IPROTO_FIELD_IS_NULLABLE: true,\n"
#~ "            IPROTO_FIELD_SPAN: 'дд'\n"
#~ "        ]\n"
#~ "    })"
#~ msgstr ""
#~ "# <body>\n"
#~ "msgpack({\n"
#~ "    IPROTO_STMT_ID: :samp:`{{MP_UINT unsigned integer}}`,\n"
#~ "    IPROTO_BIND_COUNT: :samp:`{{MP_INT integer}}`,\n"
#~ "    IPROTO_BIND_METADATA: :samp:`{{array of parameter descriptors}}`,\n"
#~ "        IPROTO_METADATA: [\n"
#~ "            IPROTO_FIELD_NAME: 'DD',\n"
#~ "            IPROTO_FIELD_TYPE: 'integer',\n"
#~ "            IPROTO_FIELD_IS_NULLABLE: false\n"
#~ "            IPROTO_FIELD_IS_AUTOINCREMENT: true\n"
#~ "            IPROTO_FIELD_SPAN: nil,\n"
#~ "            IPROTO_FIELD_NAME: 'Д',\n"
#~ "            IPROTO_FIELD_TYPE: 'string',\n"
#~ "            IPROTO_FIELD_COLL: 'unicode',\n"
#~ "            IPROTO_FIELD_IS_NULLABLE: true,\n"
#~ "            IPROTO_FIELD_SPAN: 'дд'\n"
#~ "        ]\n"
#~ "    })"

#~ msgid ""
#~ "Now read the source code file `net_box.c "
#~ "<https://github.com/tarantool/tarantool/blob/master/src/box/lua/net_box.c>`_"
#~ " where the function \"decode_metadata_optional\" is an example of how "
#~ "Tarantool itself decodes extra items."
#~ msgstr ""
#~ "Теперь обратитесь к файлу исходного кода `net_box.c "
#~ "<https://github.com/tarantool/tarantool/blob/master/src/box/lua/net_box.c>`_,"
#~ " где функция \"decode_metadata_optional\" показывает, как Tarantool сам "
#~ "интерпретирует дополнительные элементы."

#~ msgid ""
#~ "Later in :ref:`Binary protocol -- illustration <box_protocol-illustration>` "
#~ "we will show actual byte codes of responses to the above SQL messages."
#~ msgstr ""
#~ "Далее в разделе :ref:`Примеры <box_protocol-illustration>` будут рассмотрены"
#~ " байт-коды ответов на вышеприведенные SQL сообщения."

#~ msgid "Authentication"
#~ msgstr "Аутентификация"

#~ msgid "Greeting message"
#~ msgstr "Приветствие"

#~ msgid ""
#~ "When a client connects to the server instance, the instance responds with a "
#~ "128-byte text greeting message, not in MsgPack format: |br| 64-byte Greeting"
#~ " text line 1 |br| 64-byte Greeting text line 2 |br| 44-byte base64-encoded "
#~ "salt |br| 20-byte NULL"
#~ msgstr ""
#~ "Когда клиент подключается к экземпляру сервера, тот выдает в ответе "
#~ "128-байтовое текстовое сообщение приветствия не в формате MsgPack: |br| 64 "
#~ "байта — строка 1 текста приветствия |br| 64 байта — строка 2 текста "
#~ "приветствия |br| 44 байта —закодированное в формате base-64 значение соль "
#~ "|br| 20 байтов — NULL"

#~ msgid ""
#~ "The greeting contains two 64-byte lines of ASCII text. Each line ends with a"
#~ " newline character (:code:`\\n`). The first line contains the instance "
#~ "version and protocol type. The second line contains up to 44 bytes of "
#~ "base64-encoded random string, to use in the authentication packet, and ends "
#~ "with up to 23 spaces."
#~ msgstr ""
#~ "Приветствие содержит две 64-байтные строки текста в формате ASCII. Каждая "
#~ "строка заканчивается символом разрыва строки (:code:`\\n`). Первая строка "
#~ "описывает версию экземпляра и тип протокола. Вторая строка содержит "
#~ "случайную строку в кодировке base-64 размером до 44 байтов для использования"
#~ " в пакете аутентификации и заканчивается на пробелы (до 23)."

#~ msgid ""
#~ "Part of the greeting is a base64-encoded session salt - a random string "
#~ "which can be used for authentication. The maximum length of an encoded salt "
#~ "(44 bytes) is more than the amount necessary to create the authentication "
#~ "message. An excess is reserved for future authentication schemas."
#~ msgstr ""
#~ "Часть приветствия представляет собой закодированное в формате base-64 "
#~ "значение соль для сессии (случайная строка), которое можно использовать для "
#~ "аутентификации. Максимальная длина закодированного значения соль (44 байта) "
#~ "больше, чем размер создаваемого сообщения аутентификации. Остаток "
#~ "предназначается для будущих схем аутентификации."

#~ msgid ""
#~ "Authentication is optional -- if it is skipped, then the session user is "
#~ "``'guest'`` (the ``'guest'`` user does not need a password)."
#~ msgstr ""
#~ "Аутентификация необязательна: если аутентификация не проводится, то "
#~ "пользователем в сеансе будет ``'guest'`` (пользователю ``'guest'`` пароль не"
#~ " нужен)."

#~ msgid ""
#~ "If authentication is not skipped, then at any time an authentication packet "
#~ "can be prepared using the greeting, the user's name and password, and `sha-1"
#~ " <https://en.wikipedia.org/wiki/SHA-1>`_ functions, as follows."
#~ msgstr ""
#~ "Если аутентификация проводится, то в любое время может быть подготовлен "
#~ "пакет аутентификации с использованием приветствия, имени и пароля "
#~ "пользователя и функции `sha-1 <https://en.wikipedia.org/wiki/SHA-1>`_, как "
#~ "показано ниже."

#~ msgid ""
#~ "PREPARE SCRAMBLE:\n"
#~ "\n"
#~ "    size_of_encoded_salt_in_greeting = 44;\n"
#~ "    size_of_salt_after_base64_decode = 32;\n"
#~ "     /* sha1() will only use the first 20 bytes */\n"
#~ "    size_of_any_sha1_digest = 20;\n"
#~ "    size_of_scramble = 20;\n"
#~ "\n"
#~ "prepare 'chap-sha1' scramble:\n"
#~ "\n"
#~ "    salt = base64_decode(encoded_salt);\n"
#~ "    step_1 = sha1(password);\n"
#~ "    step_2 = sha1(step_1);\n"
#~ "    step_3 = sha1(first_20_bytes_of_salt, step_2);\n"
#~ "    scramble = xor(step_1, step_3);\n"
#~ "    return scramble;"
#~ msgstr ""
#~ "PREPARE SCRAMBLE:\n"
#~ "\n"
#~ "    size_of_encoded_salt_in_greeting = 44;\n"
#~ "    size_of_salt_after_base64_decode = 32;\n"
#~ "     /* sha1() will only use the first 20 bytes */\n"
#~ "    size_of_any_sha1_digest = 20;\n"
#~ "    size_of_scramble = 20;\n"
#~ "\n"
#~ "prepare 'chap-sha1' scramble:\n"
#~ "\n"
#~ "    salt = base64_decode(encoded_salt);\n"
#~ "    step_1 = sha1(password);\n"
#~ "    step_2 = sha1(step_1);\n"
#~ "    step_3 = sha1(first_20_bytes_of_salt, step_2);\n"
#~ "    scramble = xor(step_1, step_3);\n"
#~ "    return scramble;"

#~ msgid "The client sends an authentication packet as an IPROTO_AUTH message:"
#~ msgstr "Клиент отправляет пакет аутентификации в виде сообщения IPROTO_AUTH:"

#~ msgid ""
#~ "# <size>\n"
#~ "msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
#~ "# <header>\n"
#~ "msgpack({\n"
#~ "    IPROTO_REQUEST_TYPE: IPROTO_AUTH,\n"
#~ "    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer, usually = 1}}`\n"
#~ "})\n"
#~ "# <body>\n"
#~ "msgpack({\n"
#~ "    IPROTO_USER_NAME: :samp:`{{MP_STRING string <key>}}`,\n"
#~ "    IPROTO_TUPLE: ['chap-sha1', :samp:`{{MP_STRING 20-byte string}}`]\n"
#~ "})"
#~ msgstr ""
#~ "# <size>\n"
#~ "msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
#~ "# <header>\n"
#~ "msgpack({\n"
#~ "    IPROTO_REQUEST_TYPE: IPROTO_AUTH,\n"
#~ "    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer, usually = 1}}`\n"
#~ "})\n"
#~ "# <body>\n"
#~ "msgpack({\n"
#~ "    IPROTO_USER_NAME: :samp:`{{MP_STRING string <key>}}`,\n"
#~ "    IPROTO_TUPLE: ['chap-sha1', :samp:`{{MP_STRING 20-byte string}}`]\n"
#~ "})"

#~ msgid ""
#~ ":code:`<key>` holds the user name. :code:`<tuple>` must be an array of 2 "
#~ "fields: authentication mechanism (\"chap-sha1\" is the only supported "
#~ "mechanism right now) and scramble, encrypted according to the specified "
#~ "mechanism."
#~ msgstr ""
#~ ":code:`<key>` содержит имя пользователя. :code:`<tuple>` должен представлять"
#~ " собой массив из 2 полей: механизм аутентификации (на данный момент "
#~ "поддерживается только механизм \"chap-sha1\") и сообщение, зашифрованное в "
#~ "соответствии с указанным механизмом."

#~ msgid ""
#~ "The server instance responds to an authentication packet with a standard "
#~ "response with 0 tuples."
#~ msgstr ""
#~ "На пакет аутентификации экземпляр сервера отправляет стандартный ответ с 0 "
#~ "кортежей."

#~ msgid ""
#~ "To see how Tarantool handles this, look at `net_box.c "
#~ "<https://github.com/tarantool/tarantool/blob/master/src/box/lua/net_box.c>`_"
#~ " function ``netbox_encode_auth``."
#~ msgstr ""
#~ "Чтобы понять, как Tarantool это обрабатывает, обратите внимание на функцию "
#~ "`netbox_encode_auth`` в файле `net_box.c "
#~ "<https://github.com/tarantool/tarantool/blob/master/src/box/lua/net_box.c>`_."

#~ msgid "Binary protocol -- streams"
#~ msgstr "Бинарный протокол — стримы"

#~ msgid ""
#~ "The :ref:`Streams and interactive transactions <box_stream>` feature, which "
#~ "was added in Tarantool version :tarantool-release:`2.10.0`, allows two "
#~ "things: sequential processing and interleaving."
#~ msgstr ""
#~ ":ref:`Стримы и интерактивные транзакции <box_stream>`, добавленные в "
#~ "Tarantool :tarantool-release:`2.10.0`, делают возможными две процедуры: "
#~ "последовательную обработку и чередование."

#~ msgid ""
#~ "Sequential processing: With streams there is a guarantee that the server "
#~ "instance will not handle the next request in a stream until it has completed"
#~ " the previous one."
#~ msgstr ""
#~ "Последовательная обработка гарантирует, что экземпляр не будет обрабатывать "
#~ "следующий запрос в стриме, пока не завершит работу с предыдущим."

#~ msgid ""
#~ "Interleaving: For example, a series of requests can include \"begin for "
#~ "stream #1\", \"begin for stream #2\", \"insert for stream #1\", \"insert for"
#~ " stream #2\", \"delete for stream #1\", \"commit for stream #1\", \"rollback"
#~ " for stream #2\"."
#~ msgstr ""
#~ "Чередование допускает, например, такую последовательность запросов: \"begin "
#~ "для стрима 1\", \"begin для стрима 2\", \"insert для стрима 1\", \"insert "
#~ "для стрима 2\", \"delete для стрима 1\", \"commit для стрима 1\", \"rollback"
#~ " для стрима 2\"."

#~ msgid ""
#~ "To make these things possible, the engine should be :ref:`vinyl <engines-"
#~ "vinyl>` or :ref:`memtx with mvcc <cfg_basic-memtx_use_mvcc_engine>`, and the"
#~ " client is responsible for ensuring that the stream identifier, unsigned "
#~ "integer :ref:`IPROTO_STREAM_ID <box_protocol-iproto_stream_id>`, is in the "
#~ "request header. IPROTO_STREAM_ID can be any positive 64-bit number, and "
#~ "should be unique for the connection. If IPROTO_STREAM_ID equals zero the "
#~ "server instance will ignore it."
#~ msgstr ""
#~ "Эти процедуры возможны, если используется движок :ref:`vinyl <engines-"
#~ "vinyl>` или :ref:`memtx с mvcc <cfg_basic-memtx_use_mvcc_engine>`. При этом "
#~ "клиент отвечает за наличие идентификатора стрима, беззнакового целого числа "
#~ ":ref:`IPROTO_STREAM_ID <box_protocol-iproto_stream_id>`, в заголовке "
#~ "запроса. Идентификатор IPROTO_STREAM_ID должен быть положительным 64-битовым"
#~ " числом, уникальным для соединения. Если IPROTO_STREAM_ID стрима равен нулю,"
#~ " экземпляр его проигнорирует."

#~ msgid ""
#~ "For example, suppose that the client has started a stream with the "
#~ ":ref:`net.box module <net_box-module>`"
#~ msgstr ""
#~ "Предположим, что клиент запустил стрим с помощью :ref:`модуля "
#~ "net.box<net_box-module>`."

#~ msgid ""
#~ "net_box = require('net.box')\n"
#~ "conn = net_box.connect('localhost:3302')\n"
#~ "stream = conn:new_stream()"
#~ msgstr ""
#~ "net_box = require('net.box')\n"
#~ "conn = net_box.connect('localhost:3302')\n"
#~ "stream = conn:new_stream()"

#~ msgid ""
#~ "At this point the stream object will look like a duplicate of the conn "
#~ "object, with just one additional member: ``stream_id``. Now, using stream "
#~ "instead of conn, the client sends two requests:"
#~ msgstr ""
#~ "В этот момент объект ``stream`` будет выглядеть так же, как объект ``conn``,"
#~ " но включать один дополнительный элемент: ``stream_id``. Пусть теперь "
#~ "клиент, используя ``stream`` вместо ``conn``, отправит два запроса:"

#~ msgid ""
#~ "stream.space.T:insert{1}\n"
#~ "stream.space.T:insert{2}"
#~ msgstr ""
#~ "stream.space.T:insert{1}\n"
#~ "stream.space.T:insert{2}"

#~ msgid ""
#~ "The header and body of these requests will be the same as in non-stream "
#~ ":ref:`IPROTO_INSERT <box_protocol-insert>` requests, except that the header "
#~ "will contain an additional item: IPROTO_STREAM_ID=0x0a with MP_UINT=0x01. It"
#~ " happens to equal 1 for this example because each call to conn:new_stream() "
#~ "assigns a new number, starting with 1."
#~ msgstr ""
#~ "Заголовок и тело этих запросов будут такими же, как в обычных запросах "
#~ ":ref:`IPROTO_INSERT <box_protocol-insert>`, но заголовок будет содержать "
#~ "дополнительный элемент ``IPROTO_STREAM_ID=0x0a``, где ``MP_UINT=0x01``. В "
#~ "этом примере значение IPROTO_STREAM_ID равно 1, так как при вызове "
#~ "``conn:new_stream()`` идентификатору каждого нового стрима присваивается "
#~ "уникальное значение, начиная с 1."

#~ msgid ""
#~ "The client makes stream transactions by sending, in order: IPROTO_BEGIN, the"
#~ " transaction data-change and query requests, IPROTO_COMMIT or "
#~ "IPROTO_ROLLBACK. Each request must contain the same IPROTO_STREAM_ID value. "
#~ "With streaming there is no need to add :ref:`IPROTO_FLAGS <box_protocol-"
#~ "flags>` and IPROTO_FLAG_COMMIT in the header of the last request of a "
#~ "transaction. Rollback will be automatic if disconnect occurs before commit "
#~ "is possible."
#~ msgstr ""
#~ "Клиент запускает транзакцию внутри стрима, отправляя запросы в следующем "
#~ "порядке: IPROTO_BEGIN, запросы на изменение и получение данных транзакции, "
#~ "затем IPROTO_COMMIT или IPROTO_ROLLBACK. Каждый запрос должен содержать "
#~ "переменную IPROTO_STREAM_ID с одним и тем же значением. Используя стримы, не"
#~ " нужно добавлять в заголовок последнего запроса транзакции "
#~ ":ref:`IPROTO_FLAGS <box_protocol-flags>` и IPROTO_FLAG_COMMIT. Если "
#~ "транзакция прервется до того, как можно будет выполнить коммит, она будет "
#~ "автоматически отменена."

#~ msgid ""
#~ "Thus there are now multiple ways to do transactions: with net_box and "
#~ "stream:begin() and stream:commit() or stream:rollback() which cause "
#~ "IPROTO_BEGIN and IPROTO_COMMIT or IPROTO_ROLLBACK with the current value of "
#~ "stream.stream_id; with :ref:`box.begin() <box-begin>` and :ref:`box.commit()"
#~ " <box-commit>` or :ref:`box.rollback() <box-rollback>`; with SQL and "
#~ ":ref:`START TRANSACTION <sql_start_transaction>` and :ref:`COMMIT "
#~ "<sql_commit>` or :ref:`ROLLBACK <sql_rollback>`. An application can use any "
#~ "or all of these ways."
#~ msgstr ""
#~ "Таким образом, у приложения есть несколько способов выполнять транзакции. "
#~ "Во-первых, можно использовать модуль ``net_box`` с методами "
#~ "``stream:begin()`` и ``stream:commit()``/``stream:rollback()``, которые "
#~ "отправляют запросы IPROTO_BEGIN и IPROTO_COMMIT/IPROTO_ROLLBACK с текущим "
#~ "значением ``stream.stream_id``. Другой способ --- применять методы "
#~ ":ref:`box.begin() <box-begin>` и :ref:`box.commit() <box-"
#~ "commit>`/:ref:`box.rollback() <box-rollback>`. Наконец, можно пользоваться "
#~ "инструкциями SQL :ref:`START TRANSACTION <sql_start_transaction>` и "
#~ ":ref:`COMMIT <sql_commit>`/:ref:`ROLLBACK <sql_rollback>`."

#~ msgid "Replication"
#~ msgstr "Репликация"

#~ msgid "IPROTO_JOIN = 0x41"
#~ msgstr "IPROTO_JOIN = 0x41"

#~ msgid "First you must send an initial IPROTO_JOIN request."
#~ msgstr "Сначала нужно отправить запрос IPROTO_JOIN."

#~ msgid ""
#~ "# <size>\n"
#~ "msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
#~ "# <header>\n"
#~ "msgpack({\n"
#~ "    IPROTO_REQUEST_TYPE: IPROTO_JOIN,\n"
#~ "    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`\n"
#~ "})\n"
#~ "# <body>\n"
#~ "msgpack({\n"
#~ "    IPROTO_INSTANCE_UUID: :samp:`{{uuid}}`\n"
#~ "})"
#~ msgstr ""
#~ "# <size>\n"
#~ "msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
#~ "# <header>\n"
#~ "msgpack({\n"
#~ "    IPROTO_REQUEST_TYPE: IPROTO_JOIN,\n"
#~ "    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`\n"
#~ "})\n"
#~ "# <body>\n"
#~ "msgpack({\n"
#~ "    IPROTO_INSTANCE_UUID: :samp:`{{uuid}}`\n"
#~ "})"

#~ msgid ""
#~ "Then the instance which you want to connect to will send its last SNAP file,"
#~ " by simply creating a number of INSERTs (with additional LSN and ServerID) "
#~ "(do not reply to this). Then that instance will send a vclock's MP_MAP and "
#~ "close a socket."
#~ msgstr ""
#~ "Затем экземпляр, к которому вы хотите подключиться, отправит свой последний "
#~ "SNAP-файл, просто создав несколько запросов типа INSERT (с дополнительными "
#~ "LSN и ServerID) (не отвечайте на них). Затем этот экземпляр отправит MP_MAP "
#~ "vclock и закроет сокет."

#~ msgid ""
#~ "# <size>\n"
#~ "msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
#~ "# <header>\n"
#~ "msgpack({\n"
#~ "    Response-Code-Indicator: 0,\n"
#~ "    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`\n"
#~ "})\n"
#~ "# <body>\n"
#~ "msgpack({\n"
#~ "    IPROTO_VCLOCK: :samp:`{{MP_INT SRV_ID, MP_INT SRV_LSN}}`\n"
#~ "})"
#~ msgstr ""
#~ "# <size>\n"
#~ "msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
#~ "# <header>\n"
#~ "msgpack({\n"
#~ "    Response-Code-Indicator: 0,\n"
#~ "    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`\n"
#~ "})\n"
#~ "# <body>\n"
#~ "msgpack({\n"
#~ "    IPROTO_VCLOCK: :samp:`{{MP_INT SRV_ID, MP_INT SRV_LSN}}`\n"
#~ "})"

#~ msgid "IPROTO_SUBSCRIBE = 0x42"
#~ msgstr "IPROTO_SUBSCRIBE = 0x42"

#~ msgid "Then you must send an IPROTO_SUBSCRIBE request."
#~ msgstr "Теперь нужно отправить запрос IPROTO_SUBSCRIBE."

#~ msgid ""
#~ "# <size>\n"
#~ "msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
#~ "# <header>\n"
#~ "msgpack({\n"
#~ "    IPROTO_REQUEST_TYPE: IPROTO_SUBSCRIBE,\n"
#~ "    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`,\n"
#~ "    IPROTO_INSTANCE_UUID: :samp:`{{uuid}}`,\n"
#~ "    IPROTO_CLUSTER_UUID: :samp:`{{uuid}}`,\n"
#~ "})\n"
#~ "# <body>\n"
#~ "msgpack({\n"
#~ "    IPROTO_VCLOCK: :samp:`{{MP_INT SRV_ID, MP_INT SRV_LSN}}`\n"
#~ "})"
#~ msgstr ""
#~ "# <size>\n"
#~ "msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
#~ "# <header>\n"
#~ "msgpack({\n"
#~ "    IPROTO_REQUEST_TYPE: IPROTO_SUBSCRIBE,\n"
#~ "    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`,\n"
#~ "    IPROTO_INSTANCE_UUID: :samp:`{{uuid}}`,\n"
#~ "    IPROTO_CLUSTER_UUID: :samp:`{{uuid}}`,\n"
#~ "})\n"
#~ "# <body>\n"
#~ "msgpack({\n"
#~ "    IPROTO_VCLOCK: :samp:`{{MP_INT SRV_ID, MP_INT SRV_LSN}}`\n"
#~ "})"

#~ msgid ""
#~ "Then you must process every request that could come through other masters. "
#~ "Every request between masters will have additional LSN and SERVER_ID."
#~ msgstr ""
#~ "Затем нужно обработать каждый запрос, который может прийти через других "
#~ "мастеров. В каждом запросе между мастерами будут дополнительные LSN и "
#~ "SERVER_ID."

#~ msgid "HEARTBEATS"
#~ msgstr "Контрольные сигналы"

#~ msgid ""
#~ "Frequently a master sends a :ref:`heartbeat <heartbeat>` message to a "
#~ "replica. For example, if there is a replica with id = 2, and a timestamp "
#~ "with a moment in 2020, a master might send this:"
#~ msgstr ""
#~ "Часто мастер отправляет реплике сообщение :ref:`контрольного сигнала "
#~ "<heartbeat>`. Например, если есть реплика с ID = 2 и метка с моментом "
#~ "времени в 2020 году, мастер может послать такое сообщение:"

#~ msgid ""
#~ "# <header>\n"
#~ "msgpack({\n"
#~ "    IPROTO_REQUEST_TYPE: 0\n"
#~ "    IPROTO_REPLICA_ID: 2\n"
#~ "    IPROTO_TIMESTAMP: :samp:`{{Float 64 MP_DOUBLE 8-byte timestamp}}`\n"
#~ "})"
#~ msgstr ""
#~ "# <header>\n"
#~ "msgpack({\n"
#~ "    IPROTO_REQUEST_TYPE: 0\n"
#~ "    IPROTO_REPLICA_ID: 2\n"
#~ "    IPROTO_TIMESTAMP: :samp:`{{Float 64 MP_DOUBLE 8-byte timestamp}}`\n"
#~ "})"

#~ msgid "and the replica might send back this:"
#~ msgstr "и реплика может отправить в ответ следующее:"

#~ msgid ""
#~ "# <header>\n"
#~ "msgpack({\n"
#~ "    Response-Code-Indicator: IPROTO_OK\n"
#~ "    IPROTO_REPLICA_ID: 2\n"
#~ "    IPROTO_VCLOCK: {1, 6}\n"
#~ "})"
#~ msgstr ""
#~ "# <header>\n"
#~ "msgpack({\n"
#~ "    Response-Code-Indicator: IPROTO_OK\n"
#~ "    IPROTO_REPLICA_ID: 2\n"
#~ "    IPROTO_VCLOCK: {1, 6}\n"
#~ "})"

#~ msgid ""
#~ "Later in :ref:`Binary protocol -- illustration <box_protocol-illustration>` "
#~ "we will show actual byte codes of the above heartbeat examples."
#~ msgstr ""
#~ "Далее в разделе :ref:`Примеры <box_protocol-illustration>` будут рассмотрены"
#~ " байт-коды вышеприведенных сообщений контрольного сигнала."

#~ msgid "BALLOTS"
#~ msgstr "Сообщения с идентификатором BALLOT"

#~ msgid ""
#~ "While connecting for replication, an instance sends a request with header "
#~ "IPROTO_VOTE (0x44). The normal response is ER_OK,and IPROTO_BALLOT (0x29). "
#~ "The fields within IPROTO_BALLOT are map items:"
#~ msgstr ""
#~ "При подключении для репликации экземпляр отправляет запрос с заголовком "
#~ "IPROTO_VOTE (0x44). Обычно ответом будет ER_OK и IPROTO_BALLOT (0x29). Поля "
#~ "в IPROTO_BALLOT — это элементы ассоциативного массива:"

#~ msgid ""
#~ "IPROTO_BALLOT_IS_RO_CFG (0x01) + MP_BOOL\n"
#~ "IPROTO_BALLOT_VCLOCK (0x02) + vclock\n"
#~ "IPROTO_BALLOT_GC_VCLOCK (0x03) + vclock\n"
#~ "IPROTO_BALLOT_IS_RO (0x04) + MP_BOOL\n"
#~ "IPROTO_BALLOT_IS_ANON = 0x05 + MP_BOOL\n"
#~ "IPROTO_BALLOT_IS_BOOTED = 0x06 + MP_BOOL\n"
#~ "IPROTO_BALLOT_CAN_LEAD = 0x07 + MP_BOOL"
#~ msgstr ""

#~ msgid ""
#~ "IPROTO_BALLOT_IS_RO_CFG and IPRO_BALLOT_VCLOCK and IPROTO_BALLOT_GC_VCLOCK "
#~ "and IPROTO_BALLOT_IS_RO were added in version :doc:`2.6.1 </release/2.6.1>`."
#~ " IPROTO_BALLOT_IS_ANON was added in version :doc:`2.7.1 </release/2.7.1>`. "
#~ "IPROTO_BALLOT_IS_BOOTED was added in version 2.7.3 and 2.8.2 and 2.9.1. "
#~ "There have been some name changes starting with version 2.7.3 and 2.8.2 and "
#~ "2.9.1: IPROTO_BALLOT_IS_RO_CFG was formerly called IPROTO_BALLOT_IS_RO, and "
#~ "IPROTO_BALLOT_IS_RO was formerly called IPROTO_BALLOT_IS_LOADING."
#~ msgstr ""
#~ "IPROTO_BALLOT_IS_RO_CFG, IPRO_BALLOT_VCLOCK, IPROTO_BALLOT_GC_VCLOCK и "
#~ "IPROTO_BALLOT_IS_RO добавлены в версии :doc:`2.6.1 </release/2.6.1>`. "
#~ "Константа IPROTO_BALLOT_IS_ANON добавлена в версии :doc:`2.7.1 "
#~ "</release/2.7.1>`. Константа IPROTO_BALLOT_IS_BOOTED добавлена в версиях "
#~ "2.7.3, 2.8.2 и 2.9.1. В версиях 2.7.3, 2.8.2, 2.9.1 и более поздних "
#~ "константа IPROTO_BALLOT_IS_RO переименована в IPROTO_BALLOT_IS_RO_CFG, а "
#~ "IPROTO_BALLOT_IS_LOADING — в IPROTO_BALLOT_IS_RO."

#~ msgid ""
#~ "IPROTO_BALLOT_IS_RO_CFG corresponds to :ref:`box.cfg.read_only <cfg_basic-"
#~ "read_only>`."
#~ msgstr ""
#~ "Значение IPROTO_BALLOT_IS_RO_CFG соответствует значению "
#~ ":ref:`box.cfg.read_only <cfg_basic-read_only>`."

#~ msgid ""
#~ "IPROTO_BALLOT_GC_VCLOCK can be the vclock value of the instance's oldest WAL"
#~ " entry, which corresponds to :ref:`box.info.gc().vclock <box_info_gc>`."
#~ msgstr ""
#~ "IPROTO_BALLOT_GC_VCLOCK может принимать значение vclock самой старой записи "
#~ "журнала WAL на экземпляре. Это соответствует значению "
#~ ":ref:`box.info.gc().vclock <box_info_gc>`."

#~ msgid ""
#~ "IPROTO_BALLOT_IS_RO is true if the instance is not writable, which may "
#~ "happen for a variety of reasons, such as: it was configured as "
#~ ":ref:`read_only <cfg_basic-read_only>`, or it has :ref:`orphan status "
#~ "<replication-orphan_status>`, or it is a :ref:`Raft <repl_leader_elect>` "
#~ "follower."
#~ msgstr ""
#~ "IPROTO_BALLOT_IS_RO принимает значение ``true``, если экземпляр недоступен "
#~ "для записи. Причины у этого могут быть разные: например, экземпляр настроен "
#~ "как :ref:`read_only <cfg_basic-read_only>`, :ref:`имеет статус orphan "
#~ "<replication-orphan_status>` или является последователем (follower) при "
#~ ":ref:`выполнении алгоритма Raft <repl_leader_elect>`."

#~ msgid ""
#~ "IPROTO_BALLOT_IS_ANON corresponds to :ref:`box.cfg.replication_anon "
#~ "<cfg_replication-replication_anon>`."
#~ msgstr ""
#~ "Значение IPROTO_BALLOT_IS_ANON соответствует значению "
#~ ":ref:`box.cfg.replication_anon <cfg_replication-replication_anon>`."

#~ msgid ""
#~ "IPROTO_BALLOT_IS_BOOTED is true if the instance has finished its bootstrap "
#~ "or recovery process."
#~ msgstr ""
#~ "IPROTO_BALLOT_IS_BOOTED принимает значение ``true``, если экземпляр завершил"
#~ " инициализацию или восстановление."

#~ msgid ""
#~ "IPROTO_BALLOT_CAN_LEAD is true if the :ref:`election_mode <cfg_replication-"
#~ "election_mode>` configuration setting is either 'candidate' or 'manual', so "
#~ "that during the :ref:`leader election process <repl_leader_elect_process>` "
#~ "this instance may be preferred over instances whose configuration setting is"
#~ " 'voter'. IPROTO_BALLOT_CAN_LEAD support was added simultaneously in version"
#~ " :doc:`2.7.3 </release/2.7.3>` and version :doc:`2.8.2 </release/2.8.2>`."
#~ msgstr ""

#~ msgid "FLAGS"
#~ msgstr "Сообщения с идентификатором FLAG"

#~ msgid ""
#~ "For replication of :ref:`synchronous transactions <repl_sync>` a header may "
#~ "contain a key = IPROTO_FLAGS and an MP_UINT value = one or more bits: "
#~ "IPROTO_FLAG_COMMIT or IPROTO_FLAG_WAIT_SYNC or IPROTO_FLAG_WAIT_ACK."
#~ msgstr ""
#~ "При репликации :ref:`синхронных транзакций <repl_sync>` заголовок может "
#~ "содержать ключ = IPROTO_FLAGS и значение MP_UINT = один или несколько битов:"
#~ " IPROTO_FLAG_COMMIT, IPROTO_FLAG_WAIT_SYNC или IPROTO_FLAG_WAIT_ACK."

#~ msgid ""
#~ "# <size>\n"
#~ "msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
#~ "# <header>\n"
#~ "msgpack({\n"
#~ "    # ... other header items ...,\n"
#~ "    IPROTO_FLAGS: :samp:`{{MP_UINT unsigned integer}}`\n"
#~ "})\n"
#~ "# <body>\n"
#~ "msgpack({\n"
#~ "    # ... message for a transaction ...\n"
#~ "})"
#~ msgstr ""
#~ "# <size>\n"
#~ "msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
#~ "# <header>\n"
#~ "msgpack({\n"
#~ "    # ... другие элементы заголовка ...,\n"
#~ "    IPROTO_FLAGS: :samp:`{{MP_UINT unsigned integer}}`\n"
#~ "})\n"
#~ "# <body>\n"
#~ "msgpack({\n"
#~ "    # ... message for a transaction ...\n"
#~ "})"

#~ msgid ""
#~ "IPROTO_FLAG_COMMIT (0x01) will be set if this is the last message for a "
#~ "transaction, IPROTO_FLAG_WAIT_SYNC (0x02) will be set if this is the last "
#~ "message for a transaction which cannot be completed immediately, "
#~ "IPROTO_FLAG_WAIT_ACK (0x04) will be set if this is the last message for a "
#~ "synchronous transaction."
#~ msgstr ""
#~ "IPROTO_FLAG_COMMIT (0x01) указывает на последнее сообщение для транзакции. "
#~ "IPROTO_FLAG_WAIT_SYNC (0x02) указывает на последнее сообщение для "
#~ "транзакции, которую нельзя завершить немедленно. IPROTO_FLAG_WAIT_ACK (0x04)"
#~ " указывает на последнее сообщение для синхронной транзакции."

#~ msgid ""
#~ "To follow the examples in this section, get a single Linux computer and "
#~ "start three command-line shells (\"terminals\")."
#~ msgstr ""
#~ "Чтобы выполнить примеры, приведенные в этом разделе, запустите на компьютере"
#~ " с Linux три командных оболочки (терминала)."

#~ msgid ""
#~ "-- On terminal #1, Start monitoring port 3302 with `tcpdump "
#~ "<https://www.tcpdump.org/manpages/tcpdump.1.html>`_: |br|"
#~ msgstr ""
#~ "-- На терминале №1 запустите мониторинг порта 3302 с помощью `tcpdump "
#~ "<https://www.tcpdump.org/manpages/tcpdump.1.html>`_: |br|"

#~ msgid "sudo tcpdump -i lo 'port 3302' -X"
#~ msgstr "sudo tcpdump -i lo 'port 3302' -X"

#~ msgid "On terminal #2, start a server with:"
#~ msgstr "На терминале №2 запустите сервер так:"

#~ msgid ""
#~ "box.cfg{listen=3302}\n"
#~ "box.schema.space.create('tspace')\n"
#~ "box.space.tspace:create_index('I')\n"
#~ "box.space.tspace:insert{280}\n"
#~ "box.schema.user.grant('guest','read,write,execute,create,drop','universe')"
#~ msgstr ""
#~ "box.cfg{listen=3302}\n"
#~ "box.schema.space.create('tspace')\n"
#~ "box.space.tspace:create_index('I')\n"
#~ "box.space.tspace:insert{280}\n"
#~ "box.schema.user.grant('guest','read,write,execute,create,drop','universe')"

#~ msgid ""
#~ "On terminal #3, start another server, which will act as a client, with:"
#~ msgstr ""
#~ "На терминале №3 запустите ещё один сервер, который будет выступать в "
#~ "качестве клиента, так:"

#~ msgid ""
#~ "box.cfg{}\n"
#~ "net_box = require('net.box')\n"
#~ "conn = net_box.connect('localhost:3302')\n"
#~ "conn.space.tspace:select(280)"
#~ msgstr ""
#~ "box.cfg{}\n"
#~ "net_box = require('net.box')\n"
#~ "conn = net_box.connect('localhost:3302')\n"
#~ "conn.space.tspace:select(280)"

#~ msgid ""
#~ "Now look at what tcpdump shows for the job connecting to 3302 -- the "
#~ "\"request\". After the words \"length 32\" is a packet that ends with these "
#~ "32 bytes (we have added indented comments):"
#~ msgstr ""
#~ "Теперь посмотрите, что tcpdump покажет для запроса на подключение к порту "
#~ "3302. После слов «length 32» идет пакет, который заканчивается этими 32 "
#~ "байтами (комментарии отделены отступами):"

#~ msgid ""
#~ "ce 00 00 00 1b   MP_UINT = decimal 27 = number of bytes after this\n"
#~ "82               MP_MAP, size 2 (we'll call this \"Main-Map\")\n"
#~ "01                 IPROTO_SYNC (Main-Map Item#1)\n"
#~ "04                 MP_INT = 4 = number that gets incremented with each request\n"
#~ "00                 IPROTO_REQUEST_TYPE (Main-Map Item#2)\n"
#~ "01                 IPROTO_SELECT\n"
#~ "86                 MP_MAP, size 6 (we'll call this \"Select-Map\")\n"
#~ "10                   IPROTO_SPACE_ID (Select-Map Item#1)\n"
#~ "cd 02 00             MP_UINT = decimal 512 = id of tspace (could be larger)\n"
#~ "11                   IPROTO_INDEX_ID (Select-Map Item#2)\n"
#~ "00                   MP_INT = 0 = id of index within tspace\n"
#~ "14                   IPROTO_ITERATOR (Select-Map Item#3)\n"
#~ "00                   MP_INT = 0 = Tarantool iterator_type.h constant ITER_EQ\n"
#~ "13                   IPROTO_OFFSET (Select-Map Item#4)\n"
#~ "00                   MP_INT = 0 = amount to offset\n"
#~ "12                   IPROTO_LIMIT (Select-Map Item#5)\n"
#~ "ce ff ff ff ff       MP_UINT = 4294967295 = biggest possible limit\n"
#~ "20                   IPROTO_KEY (Select-Map Item#6)\n"
#~ "91                   MP_ARRAY, size 1 (we'll call this \"Key-Array\")\n"
#~ "cd 01 18               MP_UINT = 280 (Select-Map Item#6, Key-Array Item#1)\n"
#~ "                       -- 280 is the key value that we are searching for"
#~ msgstr ""
#~ "ce 00 00 00 1b   MP_UINT = 27, десятичное число = число байт после этого\n"
#~ "82               MP_MAP, размер 2 (назовем это Main-Map)\n"
#~ "01                 IPROTO_SYNC (1-й элемент Main-Map)\n"
#~ "04                 MP_INT = 4 = число, которое увеличивается на 1 с каждым запросом\n"
#~ "00                 IPROTO_REQUEST_TYPE (2-й элемент Main-Map)\n"
#~ "01                 IPROTO_SELECT\n"
#~ "86                 MP_MAP, размер 6 (назовем это Select-Map)\n"
#~ "10                   IPROTO_SPACE_ID (1-й элемент Select-Map)\n"
#~ "cd 02 00             MP_UINT = 512, десятичное число = id tspace (может быть больше)\n"
#~ "11                   IPROTO_INDEX_ID (2-й элемент Select-Map)\n"
#~ "00                   MP_INT = 0 = id индекса в tspace\n"
#~ "14                   IPROTO_ITERATOR (3-й элемент Select-Map)\n"
#~ "00                   MP_INT = 0 = константа Tarantool iterator_type.h ITER_EQ\n"
#~ "13                   IPROTO_OFFSET (4-й элемент Select-Map)\n"
#~ "00                   MP_INT = 0 = смещение\n"
#~ "12                   IPROTO_LIMIT (5-й элемент Select-Map)\n"
#~ "ce ff ff ff ff       MP_UINT = 4294967295 = наибольший возможный предел\n"
#~ "20                   IPROTO_KEY (6-й элемент Select-Map)\n"
#~ "91                   MP_ARRAY, размер 1 (назовем это Key-Array)\n"
#~ "cd 01 18               MP_UINT = 280 (6-й элемент Select-Map, 1-й элемент Key-Array)\n"
#~ "                       -- 280, ключевое значение, которое мы ищем"

#~ msgid ""
#~ "Now read the source code file `net_box.c "
#~ "<https://github.com/tarantool/tarantool/blob/master/src/box/lua/net_box.c>`_"
#~ " and skip to the line ``netbox_encode_select(lua_State *L)``. From the "
#~ "comments and from simple function calls like ``mpstream_encode_uint(&stream,"
#~ " IPROTO_SPACE_ID);`` you will be able to see how net_box put together the "
#~ "packet contents that you have just observed with tcpdump."
#~ msgstr ""
#~ "Теперь в файле исходного кода `net_box.c "
#~ "<https://github.com/tarantool/tarantool/blob/master/src/box/lua/net_box.c>`_"
#~ " перейдите к строке ``netbox_encode_select(lua_State *L)``. Из комментариев "
#~ "и из простых вызовов функций типа ``mpstream_encode_uint(&stream, "
#~ "IPROTO_SPACE_ID);`` можно понять, как net_box собирает воедино содержимое "
#~ "пакета, описанного выше с помощью tcpdump."

#~ msgid ""
#~ "There are libraries for reading and writing MessagePack objects. C "
#~ "programmers sometimes include `msgpuck.h "
#~ "<https://github.com/rtsisyk/msgpuck>`_."
#~ msgstr ""
#~ "Существуют библиотеки для чтения и записи объектов в формате MessagePack. "
#~ "Программисты на языке C иногда включают `msgpuck.h "
#~ "<https://github.com/rtsisyk/msgpuck>`_."

#~ msgid ""
#~ "Now you know how Tarantool itself makes requests with the binary protocol. "
#~ "When in doubt about a detail, consult ``net_box.c`` -- it has routines for "
#~ "each request. Some :ref:`connectors <index-box_connectors>` have similar "
#~ "code."
#~ msgstr ""
#~ "Теперь вы знаете, как сам Tarantool выполняет запросы по бинарному "
#~ "протоколу. Если какие-то детали остаются неясными, обратитесь к файлу "
#~ "``net_box.c``, где описаны процедуры для каждого запроса. Некоторые "
#~ ":ref:`коннекторы <index-box_connectors>` написаны аналогично."

#~ msgid ""
#~ "For an IPROTO_UPDATE example, suppose a user changes field #2 in tuple #2 in"
#~ " space #256 to ``'BBBB'``. The body will look like this: (notice that in "
#~ "this case there is an extra map item IPROTO_INDEX_BASE, to emphasize that "
#~ "field numbers start with 1, which is optional and can be omitted):"
#~ msgstr ""
#~ "Рассмотрим пример IPROTO_UPDATE. Предположим, пользователь изменяет поле №2 "
#~ "кортежа №2 в спейсе №256 на `'BBBB'``. Тело будет выглядеть так (обратите "
#~ "внимание, что в этом случае дополнительный необязательный элемент "
#~ "ассоциативного массива IPROTO_INDEX_BASE подчеркивает, что номера полей "
#~ "начинаются с 1 — это можно опустить):"

#~ msgid ""
#~ "04               IPROTO_UPDATE\n"
#~ "85               IPROTO_MAP, size 5\n"
#~ "10                 IPROTO_SPACE_ID, Map Item#1\n"
#~ "cd 02 00           MP_UINT 256\n"
#~ "11                 IPROTO_INDEX_ID, Map Item#2\n"
#~ "00                 MP_INT 0 = primary-key index number\n"
#~ "15                 IPROTO_INDEX_BASE, Map Item#3\n"
#~ "01                 MP_INT = 1 i.e. field numbers start at 1\n"
#~ "21                 IPROTO_TUPLE, Map Item#4\n"
#~ "91                 MP_ARRAY, size 1, for array of operations\n"
#~ "93                   MP_ARRAY, size 3\n"
#~ "a1 3d                   MP_STR = OPERATOR = '='\n"
#~ "02                      MP_INT = FIELD_NO = 2\n"
#~ "a5 42 42 42 42 42       MP_STR = VALUE = 'BBBB'\n"
#~ "20                 IPROTO_KEY, Map Item#5\n"
#~ "91                 MP_ARRAY, size 1, for array of key values\n"
#~ "02                   MP_UINT = primary-key value = 2"
#~ msgstr ""
#~ "04               IPROTO_UPDATE\n"
#~ "85               IPROTO_MAP, размер 5\n"
#~ "10                 IPROTO_SPACE_ID, 1-й элемент ассоциативного массива\n"
#~ "cd 02 00           MP_UINT 256\n"
#~ "11                 IPROTO_INDEX_ID, 2-й элемент ассоциативного массива\n"
#~ "00                 MP_INT 0 = номер индекса первичного ключа\n"
#~ "15                 IPROTO_INDEX_BASE, 3-й элемент ассоциативного массива\n"
#~ "01                 MP_INT = 1, т.е. нумерация полей начинается с 1\n"
#~ "21                 IPROTO_TUPLE, 4-й элемент ассоциативного массива\n"
#~ "91                 MP_ARRAY, размер 1, для массива операций\n"
#~ "93                   MP_ARRAY, размер 3\n"
#~ "a1 3d                   MP_STR = OPERATOR = '='\n"
#~ "02                      MP_INT = FIELD_NO = 2\n"
#~ "a5 42 42 42 42 42       MP_STR = VALUE = 'BBBB'\n"
#~ "20                 IPROTO_KEY, 5--й элемент ассоциативного массива\n"
#~ "91                 MP_ARRAY, размер 1, для массива ключей\n"
#~ "02                   MP_UINT = значение первичного ключа = 2"

#~ msgid ""
#~ "Byte codes for the :ref:`IPROTO_EXECUTE <box_protocol-execute>` example:"
#~ msgstr "Пример байт-кода :ref:`IPROTO_EXECUTE <box_protocol-execute>`:"

#~ msgid ""
#~ "0b               IPROTO_EXECUTE\n"
#~ "83               MP_MAP, size 3\n"
#~ "43                 IPROTO_STMT_ID Map Item#1\n"
#~ "ce d7 aa 74 1b     MP_UINT value of n.stmt_id\n"
#~ "41                 IPROTO_SQL_BIND Map Item#2\n"
#~ "92                 MP_ARRAY, size 2\n"
#~ "01                   MP_INT = 1 = value for first parameter\n"
#~ "a1 61                MP_STR = 'a' = value for second parameter\n"
#~ "2b                 IPROTO_OPTIONS Map Item#3\n"
#~ "90                 MP_ARRAY, size 0 (there are no options)"
#~ msgstr ""
#~ "0b               IPROTO_EXECUTE\n"
#~ "83               MP_MAP, размер 3\n"
#~ "43                 IPROTO_STMT_ID 1-й элемент ассоциативного массива\n"
#~ "ce d7 aa 74 1b     MP_UINT значение n.stmt_id\n"
#~ "41                 IPROTO_SQL_BIND 2-й элемент ассоциативного массива\n"
#~ "92                 MP_ARRAY, размер 2\n"
#~ "01                   MP_INT = 1 = значение первого параметра\n"
#~ "a1 61                MP_STR = 'a' = значение второго параметра\n"
#~ "2b                 IPROTO_OPTIONS 3-й элемент ассоциативного массива\n"
#~ "90                 MP_ARRAY, размер 0 (никакие опции не выбраны)"

#~ msgid ""
#~ "Byte codes for the response to the "
#~ ":codenormal:`box.space.`:codeitalic:`space-name`:codenormal:`:insert{6}` "
#~ "example:"
#~ msgstr ""
#~ "Пример байт-кода ответа на запрос "
#~ ":codenormal:`box.space.`:codeitalic:`space-name`:codenormal:`:insert{6}`:"

#~ msgid ""
#~ "ce 00 00 00 20                MP_UINT = HEADER AND BODY SIZE\n"
#~ "83                            MP_MAP, size 3\n"
#~ "00                              Response-Code-Indicator\n"
#~ "ce 00 00 00 00                  MP_UINT = IPROTO_OK\n"
#~ "01                              IPROTO_SYNC\n"
#~ "cf 00 00 00 00 00 00 00 53      MP_UINT = sync value\n"
#~ "05                              IPROTO_SCHEMA_VERSION\n"
#~ "ce 00 00 00 68                  MP_UINT = schema version\n"
#~ "81                            MP_MAP, size 1\n"
#~ "30                              IPROTO_DATA\n"
#~ "dd 00 00 00 01                  MP_ARRAY, size 1 (row count)\n"
#~ "91                              MP_ARRAY, size 1 (field count)\n"
#~ "06                              MP_INT = 6 = the value that was inserted"
#~ msgstr ""
#~ "ce 00 00 00 20                MP_UINT = размер заголовка и тела\n"
#~ "83                            MP_MAP, размер 3\n"
#~ "00                              индикатор кода ответа\n"
#~ "ce 00 00 00 00                  MP_UINT = IPROTO_OK\n"
#~ "01                              IPROTO_SYNC\n"
#~ "cf 00 00 00 00 00 00 00 53      MP_UINT = значение синхронизации\n"
#~ "05                              IPROTO_SCHEMA_VERSION\n"
#~ "ce 00 00 00 68                  MP_UINT = версия схемы\n"
#~ "81                            MP_MAP, размер 1\n"
#~ "30                              IPROTO_DATA\n"
#~ "dd 00 00 00 01                  MP_ARRAY, размер 1 (число строк)\n"
#~ "91                              MP_ARRAY, размер 1 (число полей)\n"
#~ "06                              MP_INT = 6 = добавленное значение"

#~ msgid ""
#~ "Byte codes for the response to the "
#~ "``conn:eval([[box.schema.space.create('_space');]])`` example:"
#~ msgstr ""
#~ "Пример байт-кода ответа на запрос "
#~ "``conn:eval([[box.schema.space.create('_space');]])``:"

#~ msgid ""
#~ "ce 00 00 00 3b                  MP_UINT = HEADER AND BODY SIZE\n"
#~ "83                              MP_MAP, size 3 (i.e. 3 items in header)\n"
#~ "   00                              Response-Code-Indicator\n"
#~ "   ce 00 00 80 0a                  MP_UINT = hexadecimal 800a\n"
#~ "   01                              IPROTO_SYNC\n"
#~ "   cf 00 00 00 00 00 00 00 26      MP_UINT = sync value\n"
#~ "   05                              IPROTO_SCHEMA_VERSION\n"
#~ "   ce 00 00 00 78                  MP_UINT = schema version value\n"
#~ "   81                              MP_MAP, size 1\n"
#~ "     31                              IPROTO_ERROR_24\n"
#~ "     db 00 00 00 1d 53 70 61 63 etc. MP_STR = \"Space '_space' already exists\""
#~ msgstr ""
#~ "ce 00 00 00 3b                  MP_UINT = размер заголовка и тела\n"
#~ "83                              MP_MAP, размер 3 (3 элемента в заголовке)\n"
#~ "   00                              индикатор кода ответа\n"
#~ "   ce 00 00 80 0a                  MP_UINT = шестнадцатеричное значение 800a\n"
#~ "   01                              IPROTO_SYNC\n"
#~ "   cf 00 00 00 00 00 00 00 26      MP_UINT = значение синхронизации\n"
#~ "   05                              IPROTO_SCHEMA_VERSION\n"
#~ "   ce 00 00 00 78                  MP_UINT = версия схемы \n"
#~ "   81                              MP_MAP, размер 1\n"
#~ "     31                              IPROTO_ERROR_24\n"
#~ "     db 00 00 00 1d 53 70 61 63 ... MP_STR = \"Space '_space' already exists\""

#~ msgid ""
#~ "Byte codes, if we use the same net.box connection that we used for "
#~ ":ref:`Binary protocol -- illustration <box_protocol-illustration>` and we "
#~ "say |br| ``conn:execute([[CREATE TABLE t1 (dd INT PRIMARY KEY AUTOINCREMENT,"
#~ " дд STRING COLLATE \"unicode\");]])`` |br| ``conn:execute([[INSERT INTO t1 "
#~ "VALUES (NULL, 'a'), (NULL, 'b');]])`` |br| and we watch what tcpdump "
#~ "displays, we will see two noticeable things: (1) the CREATE statement caused"
#~ " a schema change so the response has a new IPROTO_SCHEMA_VERSION value and "
#~ "the body includes the new contents of some system tables (caused by requests"
#~ " from net.box which users will not see); (2) the final bytes of the response"
#~ " to the INSERT will be:"
#~ msgstr ""
#~ "Подключимся через то же соединение net.box, что приводилось в :ref:`примерах"
#~ " <box_protocol-illustration>`, и выполним следующее: |br| "
#~ "``conn:execute([[CREATE TABLE t1 (dd INT PRIMARY KEY AUTOINCREMENT, дд "
#~ "STRING COLLATE \"unicode\");]])`` |br| ``conn:execute([[INSERT INTO t1 "
#~ "VALUES (NULL, 'a'), (NULL, 'b');]])`` |br| Результат вывода tcpdump покажет "
#~ "два интересных момента: (1) инструкция CREATE привела к изменению схемы, так"
#~ " что в ответе указано новое значение IPROTO_SCHEMA_VERSION. При этом тело "
#~ "включает новое содержимое некоторых системных таблиц, полученное в "
#~ "результате невидимых для пользователя запросов от net.box; (2) последние "
#~ "байты ответа на INSERT будут следующими:"

#~ msgid ""
#~ "81   MP_MAP, size 1\n"
#~ "42     IPROTO_SQL_INFO\n"
#~ "82     MP_MAP, size 2\n"
#~ "00       Tarantool constant (not in iproto_constants.h) = SQL_INFO_ROW_COUNT\n"
#~ "02       1 = row count\n"
#~ "01       Tarantool constant (not in iproto_constants.h) = SQL_INFO_AUTOINCREMENT_ID\n"
#~ "92       MP_ARRAY, size 2\n"
#~ "01         first autoincrement number\n"
#~ "02         second autoincrement number"
#~ msgstr ""
#~ "81   MP_MAP, размер 1\n"
#~ "42     IPROTO_SQL_INFO\n"
#~ "82     MP_MAP, размер 2\n"
#~ "00       константа Tarantool (не из iproto_constants.h) = SQL_INFO_ROW_COUNT\n"
#~ "02       1 = число строк\n"
#~ "01       константа Tarantool (не из iproto_constants.h) = SQL_INFO_AUTOINCREMENT_ID\n"
#~ "92       MP_ARRAY, размер 2\n"
#~ "01         первое число с автоинкрементом\n"
#~ "02         второе число с автоинкрементом"

#~ msgid ""
#~ "Byte codes for the SQL SELECT example, if we ask for full metadata by saying"
#~ " |br| :code:`conn.space._session_settings:update('sql_full_metadata', {{'=',"
#~ " 'value', true}})` |br| and we select the two rows from the table that we "
#~ "just created |br| :code:`conn:execute([[SELECT dd, дд AS д FROM t1;]])` |br|"
#~ " then tcpdump will show this response, after the header:"
#~ msgstr ""
#~ "Пример байт-кода SQL SELECT. Запросим полные метаданные, вызвав "
#~ ":code:`conn.space._session_settings:update('sql_full_metadata', {{'=', "
#~ "'value', true}})`, и выберем две строки из только что созданной таблицы: "
#~ ":code:`conn:execute([[SELECT dd, дд AS д FROM t1;]])`. tcpdump выдаст "
#~ "следующий ответ (после заголовка):"

#~ msgid ""
#~ "82                       MP_MAP, size 2 (i.e. metadata and rows)\n"
#~ "32                         IPROTO_METADATA\n"
#~ "92                         MP_ARRAY, size 2 (i.e. 2 columns)\n"
#~ "85                           MP_MAP, size 5 (i.e. 5 items for column#1)\n"
#~ "00 a2 44 44                    IPROTO_FIELD_NAME and 'DD'\n"
#~ "01 a7 69 6e 74 65 67 65 72     IPROTO_FIELD_TYPE and 'integer'\n"
#~ "03 c2                          IPROTO_FIELD_IS_NULLABLE and false\n"
#~ "04 c3                          IPROTO_FIELD_IS_AUTOINCREMENT and true\n"
#~ "05 c0                          PROTO_FIELD_SPAN and nil\n"
#~ "85                           MP_MAP, size 5 (i.e. 5 items for column#2)\n"
#~ "00 a2 d0 94                    IPROTO_FIELD_NAME and 'Д' upper case\n"
#~ "01 a6 73 74 72 69 6e 67        IPROTO_FIELD_TYPE and 'string'\n"
#~ "02 a7 75 6e 69 63 6f 64 65     IPROTO_FIELD_COLL and 'unicode'\n"
#~ "03 c3                          IPROTO_FIELD_IS_NULLABLE and true\n"
#~ "05 a4 d0 b4 d0 b4              IPROTO_FIELD_SPAN and 'дд' lower case\n"
#~ "30                         IPROTO_DATA\n"
#~ "92                         MP_ARRAY, size 2\n"
#~ "92                           MP_ARRAY, size 2\n"
#~ "01                             MP_INT = 1 i.e. contents of row#1 column#1\n"
#~ "a1 61                          MP_STR = 'a' i.e. contents of row#1 column#2\n"
#~ "92                           MP_ARRAY, size 2\n"
#~ "02                             MP_INT = 2 i.e. contents of row#2 column#1\n"
#~ "a1 62                          MP_STR = 'b' i.e. contents of row#2 column#2"
#~ msgstr ""
#~ "82                       MP_MAP, размер 2 (метаданные и строки)\n"
#~ "32                         IPROTO_METADATA\n"
#~ "92                         MP_ARRAY, размер 2 (2 столбца)\n"
#~ "85                           MP_MAP, размер 5 (5 элементов для столбца 1)\n"
#~ "00 a2 44 44                    IPROTO_FIELD_NAME и 'DD'\n"
#~ "01 a7 69 6e 74 65 67 65 72     IPROTO_FIELD_TYPE и 'integer'\n"
#~ "03 c2                          IPROTO_FIELD_IS_NULLABLE и false\n"
#~ "04 c3                          IPROTO_FIELD_IS_AUTOINCREMENT и true\n"
#~ "05 c0                          PROTO_FIELD_SPAN и nil\n"
#~ "85                           MP_MAP, размер 5 (5 элементов для столбца 2)\n"
#~ "00 a2 d0 94                    IPROTO_FIELD_NAME и 'Д' в верхнем регистре\n"
#~ "01 a6 73 74 72 69 6e 67        IPROTO_FIELD_TYPE и 'string'\n"
#~ "02 a7 75 6e 69 63 6f 64 65     IPROTO_FIELD_COLL и 'unicode'\n"
#~ "03 c3                          IPROTO_FIELD_IS_NULLABLE и true\n"
#~ "05 a4 d0 b4 d0 b4              IPROTO_FIELD_SPAN и 'дд' в нижнем регистре\n"
#~ "30                         IPROTO_DATA\n"
#~ "92                         MP_ARRAY, размер 2\n"
#~ "92                           MP_ARRAY, размер 2\n"
#~ "01                             MP_INT = 1: содержимое строки 1, столбца 1\n"
#~ "a1 61                          MP_STR = 'a': содержимое строки 1, столбца 2\n"
#~ "92                           MP_ARRAY, размер 2\n"
#~ "02                             MP_INT = 2: содержимое строки 2, столбца 1\n"
#~ "a1 62                          MP_STR = 'b': содержимое строки 2, столбца 2"

#~ msgid ""
#~ "Byte code for the SQL PREPARE example. If we said |br| "
#~ ":code:`conn:prepare([[SELECT dd, дд AS д FROM t1;]])` |br| then tcpdump "
#~ "would show almost the same response, but there would be no IPROTO_DATA. "
#~ "Instead, additional items will appear:"
#~ msgstr ""
#~ "Пример байт-кода SQL PREPARE. Если вызвать :code:`conn:prepare([[SELECT dd, "
#~ "дд AS д FROM t1;]])`, вывод tcpdump будет почти таким же, но исчезнет "
#~ "IPROTO_DATA. Вместо этого появятся дополнительные байты:"

#~ msgid ""
#~ "34                       IPROTO_BIND_COUNT\n"
#~ "00                       MP_UINT = 0\n"
#~ "\n"
#~ "33                       IPROTO_BIND_METADATA\n"
#~ "90                       MP_ARRAY, size 0"
#~ msgstr ""
#~ "34                       IPROTO_BIND_COUNT\n"
#~ "00                       MP_UINT = 0\n"
#~ "\n"
#~ "33                       IPROTO_BIND_METADATA\n"
#~ "90                       MP_ARRAY, размер 0"

#~ msgid ""
#~ "``MP_UINT = 0`` and ``MP_ARRAY`` has size 0 because there are no parameters "
#~ "to bind. Full output:"
#~ msgstr ""
#~ "``MP_UINT = 0``. Массив ``MP_ARRAY`` имеет размер 0, поскольку параметров "
#~ "нет. Вывод целиком:"

#~ msgid ""
#~ "84                       MP_MAP, size 4\n"
#~ "43                         IPROTO_STMT_ID\n"
#~ "ce c2 3c 2c 1e             MP_UINT = statement id\n"
#~ "34                         IPROTO_BIND_COUNT\n"
#~ "00                         MP_INT = 0 = number of parameters to bind\n"
#~ "33                         IPROTO_BIND_METADATA\n"
#~ "90                         MP_ARRAY, size 0 = there are no parameters to bind\n"
#~ "32                         IPROTO_METADATA\n"
#~ "92                         MP_ARRAY, size 2 (i.e. 2 columns)\n"
#~ "85                           MP_MAP, size 5 (i.e. 5 items for column#1)\n"
#~ "00 a2 44 44                    IPROTO_FIELD_NAME and 'DD'\n"
#~ "01 a7 69 6e 74 65 67 65 72     IPROTO_FIELD_TYPE and 'integer'\n"
#~ "03 c2                          IPROTO_FIELD_IS_NULLABLE and false\n"
#~ "04 c3                          IPROTO_FIELD_IS_AUTOINCREMENT and true\n"
#~ "05 c0                          PROTO_FIELD_SPAN and nil\n"
#~ "85                           MP_MAP, size 5 (i.e. 5 items for column#2)\n"
#~ "00 a2 d0 94                    IPROTO_FIELD_NAME and 'Д' upper case\n"
#~ "01 a6 73 74 72 69 6e 67        IPROTO_FIELD_TYPE and 'string'\n"
#~ "02 a7 75 6e 69 63 6f 64 65     IPROTO_FIELD_COLL and 'unicode'\n"
#~ "03 c3                          IPROTO_FIELD_IS_NULLABLE and true\n"
#~ "05 a4 d0 b4 d0 b4              IPROTO_FIELD_SPAN and 'дд' lower case"
#~ msgstr ""
#~ "84                       MP_MAP, размер 4\n"
#~ "43                         IPROTO_STMT_ID\n"
#~ "ce c2 3c 2c 1e             MP_UINT = ID инструкции\n"
#~ "34                         IPROTO_BIND_COUNT\n"
#~ "00                         MP_INT = 0 = число привязываемых параметров\n"
#~ "33                         IPROTO_BIND_METADATA\n"
#~ "90                         MP_ARRAY, размер 0 = нет привязываемых параметров\n"
#~ "32                         IPROTO_METADATA\n"
#~ "92                         MP_ARRAY, размер 2 (2 столбца)\n"
#~ "85                           MP_MAP, размер 5 (5 элементов для столбца 1)\n"
#~ "00 a2 44 44                    IPROTO_FIELD_NAME и 'DD'\n"
#~ "01 a7 69 6e 74 65 67 65 72     IPROTO_FIELD_TYPE и 'integer'\n"
#~ "03 c2                          IPROTO_FIELD_IS_NULLABLE и false\n"
#~ "04 c3                          IPROTO_FIELD_IS_AUTOINCREMENT и true\n"
#~ "05 c0                          PROTO_FIELD_SPAN и nil\n"
#~ "85                           MP_MAP, размер 5 (5 элементов для столбца 2)\n"
#~ "00 a2 d0 94                    IPROTO_FIELD_NAME + 'Д' в верхнем регистре\n"
#~ "01 a6 73 74 72 69 6e 67        IPROTO_FIELD_TYPE и 'string'\n"
#~ "02 a7 75 6e 69 63 6f 64 65     IPROTO_FIELD_COLL и 'unicode'\n"
#~ "03 c3                          IPROTO_FIELD_IS_NULLABLE и true\n"
#~ "05 a4 d0 b4 d0 b4              IPROTO_FIELD_SPAN и 'дд' в нижнем регистре"

#~ msgid "Byte code for the heartbeat example. The master might send this body:"
#~ msgstr ""
#~ "Пример байт-кода контрольного сигнала. Мастер может отправить следующее "
#~ "тело:"

#~ msgid ""
#~ "83                      MP_MAP, size 3\n"
#~ "00                        Main-Map Item #1 IPROTO_REQUEST_TYPE\n"
#~ "00                          MP_UINT = 0\n"
#~ "02                        Main-Map Item #2 IPROTO_REPLICA_ID\n"
#~ "02                          MP_UINT = 2 = id\n"
#~ "04                        Main-Map Item #3 IPROTO_TIMESTAMP\n"
#~ "cb                          MP_DOUBLE (MessagePack \"Float 64\")\n"
#~ "41 d7 ba 06 7b 3a 03 21     8-byte timestamp"
#~ msgstr ""
#~ "83                      MP_MAP, размер 3\n"
#~ "00                        1-й элемент Main-Map IPROTO_REQUEST_TYPE\n"
#~ "00                          MP_UINT = 0\n"
#~ "02                        2-й элемент Main-Map IPROTO_REPLICA_ID\n"
#~ "02                          MP_UINT = 2 = id\n"
#~ "04                        3-й элемент Main-Map IPROTO_TIMESTAMP\n"
#~ "cb                          MP_DOUBLE (MessagePack \"Float 64\")\n"
#~ "41 d7 ba 06 7b 3a 03 21     8-байтовая временная отметка"

#~ msgid ""
#~ "Byte code for the heartbeat example. The replica might send back this body"
#~ msgstr ""
#~ "Пример байт-кода ответа на контрольный сигнал. Реплика может вернуть "
#~ "следующее тело:"

#~ msgid ""
#~ "81                       MP_MAP, size 1\n"
#~ "00                         Main-Map Item #1 Response-code-indicator\n"
#~ "00                         MP_UINT = 0 = IPROTO_OK\n"
#~ "81                         Main-Map Item #2, MP_MAP, size 1\n"
#~ "26                           Sub-Map Item #1 IPROTO_VCLOCK\n"
#~ "81                           Sub-Map Item #2, MP_MAP, size 1\n"
#~ "01                             MP_UINT = 1 = id (part 1 of vclock)\n"
#~ "06                             MP_UINT = 6 = lsn (part 2 of vclock)"
#~ msgstr ""
#~ "81                       MP_MAP, размер 1\n"
#~ "00                         1-й элемент Main-Map: индикатор кода ответа\n"
#~ "00                         MP_UINT = 0 = IPROTO_OK\n"
#~ "81                         2-й элемент Main-Map: MP_MAP, размер 1 (Sub-Map)\n"
#~ "26                           1-й элемент Sub-Map: IPROTO_VCLOCK\n"
#~ "81                           2-й элемент Sub-Map: MP_MAP, размер 1\n"
#~ "01                             MP_UINT = 1 = id (1-я часть vclock)\n"
#~ "06                             MP_UINT = 6 = lsn (2-я часть vclock)"

#~ msgid "XLOG / SNAP"
#~ msgstr "XLOG / SNAP"

#~ msgid ""
#~ ".xlog and .snap files have nearly the same format. The header looks like:"
#~ msgstr ""
#~ "Файлы форматов .xlog и .snap выглядят практически одинаково. Заголовок "
#~ "выглядит так:"

#~ msgid ""
#~ "<type>\\n                  SNAP\\n or XLOG\\n\n"
#~ "<version>\\n               currently 0.13\\n\n"
#~ "Server: <server_uuid>\\n   where UUID is a 36-byte string\n"
#~ "VClock: <vclock_map>\\n    e.g. {1: 0}\\n\n"
#~ "\\n"
#~ msgstr ""
#~ "<type>\\n                  SNAP\\n или XLOG\\n\n"
#~ "<version>\\n               в данный момент 0.13\\n\n"
#~ "Server: <server_uuid>\\n   где UUID -- это 36-байтная строка\n"
#~ "VClock: <vclock_map>\\n    например, {1: 0}\\n\n"
#~ "\\n"

#~ msgid ""
#~ "After the file header come the data tuples. Tuples begin with a row marker "
#~ "``0xd5ba0bab`` and the last tuple may be followed by an EOF marker "
#~ "``0xd510aded``. Thus, between the file header and the EOF marker, there may "
#~ "be data tuples that have this form:"
#~ msgstr ""
#~ "После файла заголовка идут кортежи с данными. Кортежи начинаются с маркера "
#~ "строки ``0xd5ba0bab``, а после последнего кортежа может стоять маркер конца "
#~ "файла ``0xd510aded``. Таким образом, между заголовком файла и маркером конца"
#~ " файла могут быть кортежи с данными в следующем виде:"

#~ msgid ""
#~ "0            3 4                                         17\n"
#~ "+-------------+========+============+===========+=========+\n"
#~ "|             |        |            |           |         |\n"
#~ "| 0xd5ba0bab  | LENGTH | CRC32 PREV | CRC32 CUR | PADDING |\n"
#~ "|             |        |            |           |         |\n"
#~ "+-------------+========+============+===========+=========+\n"
#~ "   MP_FIXEXT2    MP_INT     MP_INT       MP_INT      ---\n"
#~ "\n"
#~ "+============+ +===================================+\n"
#~ "|            | |                                   |\n"
#~ "|   HEADER   | |                BODY               |\n"
#~ "|            | |                                   |\n"
#~ "+============+ +===================================+\n"
#~ "     MP_MAP                     MP_MAP"
#~ msgstr ""
#~ "0            3 4                                         17\n"
#~ "+-------------+========+============+===========+=========+\n"
#~ "|             |        |            |           |         |\n"
#~ "| 0xd5ba0bab  | LENGTH | CRC32 PREV | CRC32 CUR | PADDING |\n"
#~ "|             |        |            |           |         |\n"
#~ "+-------------+========+============+===========+=========+\n"
#~ "   MP_FIXEXT2    MP_INT     MP_INT       MP_INT      ---\n"
#~ "\n"
#~ "+============+ +===================================+\n"
#~ "|            | |                                   |\n"
#~ "|   HEADER   | |                BODY               |\n"
#~ "|            | |                                   |\n"
#~ "+============+ +===================================+\n"
#~ "     MP_MAP                     MP_MAP"

#~ msgid ""
#~ "See the example in the :ref:`File formats <internals-data_persistence>` "
#~ "section."
#~ msgstr ""
#~ "См. пример в разделе :ref:`Форматы файлов <internals-data_persistence>`."
