
#, fuzzy
msgid "Binary protocol"
msgstr "Бинарный протокол Tarantool'а"

msgid ""
"The binary protocol is called a \"request/response\" protocol because it "
"is for sending requests to a Tarantool server and receiving responses. "
"There is complete access to Tarantool functionality, including:"
msgstr ""

#, fuzzy
msgid ""
"request multiplexing, for example ability to issue multiple requests "
"asynchronously via the same connection"
msgstr ""
"мультиплексирование запросов, т.е. возможность асинхронной отправки "
"множества запросов по одному соединению;"

msgid "response format that supports zero-copy writes"
msgstr ""
"формат ответа, который поддерживает запись в режиме без копирования "
"(zero-copy)."

msgid ""
"The protocol can be called \"binary\" because the most-frequently-used "
"database accesses are done with binary codes instead of Lua request text."
" Tarantool experts use it to write their own connectors, to understand "
"network messages, to support new features that their favorite connector "
"doesn't support yet, or to avoid repetitive parsing by the server."
msgstr ""

msgid "Binary protocol -- symbols and terms"
msgstr ""

msgid "For diagrams in this section, the box borders have special meanings:"
msgstr ""

msgid ""
"0    X\n"
"+----+\n"
"|    | - X + 1 bytes\n"
"+----+\n"
" TYPE - type of MessagePack value (if it is a MessagePack object)\n"
"\n"
"+====+\n"
"|    | - Variable size MessagePack object\n"
"+====+\n"
" TYPE - type of MessagePack value\n"
"\n"
"+~~~~+\n"
"|    | - Variable size MessagePack Array/Map\n"
"+~~~~+\n"
" TYPE - type of MessagePack value"
msgstr ""

msgid ""
"And words that start with **MP_** mean: a `MessagePack "
"<http://MessagePack.org>`_ type or a range of MessagePack types, "
"including the signal and possibly including a value, with slight "
"modification:"
msgstr ""

msgid "**MP_NIL**    nil"
msgstr ""

msgid "**MP_UINT**   unsigned integer"
msgstr ""

msgid "**MP_INT**    either integer or unsigned integer"
msgstr ""

msgid "**MP_STR**    string"
msgstr ""

msgid "**MP_BIN**    binary string"
msgstr ""

msgid "**MP_ARRAY**  array"
msgstr ""

msgid "**MP_MAP**    map"
msgstr ""

msgid "**MP_BOOL**   boolean"
msgstr ""

msgid "**MP_FLOAT**  float"
msgstr ""

msgid "**MP_DOUBLE** double"
msgstr ""

msgid ""
"**MP_EXT**    extension (including the :ref:`DECIMAL type <msgpack_ext-"
"decimal>`)"
msgstr ""

#, fuzzy
msgid "**MP_OBJECT** any MessagePack object"
msgstr "**MP_OBJECT** - любой MsgPack-объект"

msgid ""
"Short descriptions are in MessagePack's `\"spec\" page "
"<https://github.com/msgpack/msgpack/blob/master/spec.md>`_."
msgstr ""

msgid ""
"And words that start with **IPROTO_** mean: a Tarantool constant which is"
" either defined or mentioned in the `iproto_constants.h file "
"<https://github.com/tarantool/tarantool/blob/master/src/box/iproto_constants.h>`_."
" These constants are used as keys within MP_MAP maps."
msgstr ""

#, fuzzy
msgid "Binary protocol -- illustration"
msgstr "Бинарный протокол Tarantool'а"

msgid ""
"To follow the examples in this section, get a single Linux computer and "
"start three command-line shells (\"terminals\")."
msgstr ""

msgid ""
"-- On terminal #1, Start monitoring port 3302 with `tcpdump "
"<https://www.tcpdump.org/manpages/tcpdump.1.html>`_: |br| ``sudo tcpdump "
"-i lo 'port 3302' -X``"
msgstr ""

msgid ""
"On terminal #2, start a server with: |br| ``box.cfg{listen=3302}`` |br| "
"``box.schema.user.grant('guest','read,write,execute,create,drop','universe')``"
" |br|"
msgstr ""

msgid ""
"On terminal #3, start another server, which will act as a client, with: "
"|br| ``box.cfg{}`` |br| ``net_box = require('net.box')`` |br| ``conn = "
"net_box.connect('localhost:3302')`` |br| "
"``conn.space._space:select(280)`` |br|"
msgstr ""

msgid ""
"Now look at what tcpdump shows for the job connecting to 3302. -- the "
"\"request\". After the words \"length 32\" is a packet that ends with "
"with these 32 bytes: (we have added indented comments):"
msgstr ""

msgid ""
"ce 00 00 00 1b   MP_UINT = decimal 27 = number of bytes after this\n"
"82               MP_MAP, size 2 (we'll call this \"Main-Map\")\n"
"01                 IPROTO_SYNC (Main-Map Item#1)\n"
"04                 MP_INT = 4 = number that gets incremented with each "
"request\n"
"00                 IPROTO_REQUEST_TYPE (Main-Map Item#2)\n"
"01                 IPROTO_SELECT\n"
"86                 MP_MAP, size 6 (we'll call this \"Select-Map\")\n"
"10                   IPROTO_SPACE_ID (Select-Map Item#1)\n"
"cd 01 18             MP_UINT = decimal 280 = id of _space\n"
"11                   IPROTO_INDEX_ID (Select-Map Item#2)\n"
"00                   MP_INT = 0 = id of index within _space\n"
"14                   IPROTO_ITERATOR (Select-Map Item#3)\n"
"00                   MP_INT = 0 = Tarantool iterator_type.h constant "
"ITER_EQ\n"
"13                   IPROTO_OFFSET (Select-Map Item#4)\n"
"00                   MP_INT = 0 = amount to offset\n"
"12                   IPROTO_LIMIT (Select-Map Item#5)\n"
"ce ff ff ff ff       MP_UINT = 4294967295 = biggest possible limit\n"
"20                   IPROTO_KEY (Select-Map Item#6)\n"
"91                   MP_ARRAY, size 1 (we'll call this \"Key-Array\")\n"
"cd 01 18               MP_UINT = 280 (Select-Map Item#6, Key-Array "
"Item#1)\n"
"                       -- 280 is the key value that we are searching for"
msgstr ""

msgid ""
"Now read the source code file `net_box.c "
"<https://github.com/tarantool/tarantool/blob/master/src/box/lua/net_box.c>`_"
" and skip to the line ``netbox_encode_select(lua_State *L)``. From the "
"comments and from simple function calls like "
"\"mpstream_encode_uint(&stream, IPROTO_SPACE_ID);\" you will be able to "
"see how net_box put together the packet contents that you have just "
"observed with tcpdump."
msgstr ""

msgid ""
"There are libraries for reading and writing MessagePack objects. C "
"programmers sometimes include `msgpuck.h "
"<https://github.com/rtsisyk/msgpuck>`_."
msgstr ""

msgid ""
"Now you know how Tarantool itself makes requests with the binary "
"protocol. When in doubt about a detail, consult net_box.c -- it has "
"routines for each request. Some :ref:`connectors <index-box_connectors>` "
"have similar code."
msgstr ""

msgid "Binary protocol -- header and body"
msgstr ""

msgid ""
"Except during connection (which involves a greeting from the server and "
"optional :ref:`authentication <box_protocol-authentication>` that we will"
" discuss later in this section), the protocol is pure request/response "
"(the client requests and the server responds). It is legal to put more "
"than one request in a packet."
msgstr ""

msgid "Almost all requests and responses contain both a header and a body."
msgstr ""

msgid ""
"Normal Request/Response header and body:\n"
"\n"
"0        5\n"
"+--------+ +============+ +===================================+\n"
"| HEADER | |            | |                                   |\n"
"| + BODY | |   HEADER   | |               BODY                |\n"
"|  SIZE  | |            | |                                   |\n"
"+--------+ +============+ +===================================+\n"
"  MP_INT       MP_MAP                     MP_MAP"
msgstr ""

msgid ""
"HEADER + BODY SIZE is the size of the header plus the size of the body. "
"It may be useful to compare it with the number of bytes remaining in the "
"packet."
msgstr ""

msgid "HEADER may contain, in any order:"
msgstr ""

msgid ""
"HEADER:\n"
"\n"
"+====================================+=====================+===============================+"
"\n"
"|                                    |                     |"
"                               |\n"
"|   0x00: IPROTO_REQUEST_TYPE        |   0x01: IPROTO_SYNC |   0x05: "
"IPROTO_SCHEMA_VERSION |\n"
"|         or Response-Code-Indicator | MP_INT: MP_INT      | MP_INT: "
"MP_INT                |\n"
"| MP_INT: MP_INT                     |                     |"
"                               |\n"
"|                                    |                     |"
"                               |\n"
"+====================================+=====================+===============================+"
"\n"
"                          MP_MAP"
msgstr ""

msgid ""
"**IPROTO_SYNC** = 0x01. An unsigned integer that should be incremented so"
" that it is unique in every request. This integer is also returned from "
":ref:`box.session.sync() <box_session-sync>`. The IPROTO_SYNC value of a "
"response should be the same as the IPROTO_SYNC value of a request."
msgstr ""

msgid ""
"**IPROTO_SCHEMA_VERSION** = 0x05. An unsigned number, sometimes called "
"SCHEMA_ID, that goes up when there is a major change. In a request header"
" IPROTO_SCHEMA_VERSION is optional, so the version will not be checked if"
" it is absent. In a response header IPROTO_SCHEMA_VERSION is always "
"present, and it is up to the client to check if it has changed."
msgstr ""

msgid ""
"**IPROTO_REQUEST_TYPE** or Response-Code-Indicator = 0x00. An unsigned "
"number that indicates what will be in the BODY. In requests "
"IPROTO_REQUEST_TYPE will be followed by IPROTO_SELECT etc. In responses "
"Response-Code-Indicator will be followed by IPROTO_OK etc."
msgstr ""

msgid ""
"The BODY has the details of the request or response. In a request, it can"
" also be absent or be an empty map. Both these states will be interpreted"
" equally. Responses will contain the BODY anyway even if it is a "
":ref:`IPROTO_PING <box_protocol-ping>` request."
msgstr ""

msgid ""
"Have a look at file `xrow.c "
"<https://github.com/tarantool/tarantool/blob/master/src/box/xrow.c>`_ "
"function xrow_header_encode, to see how Tarantool encodes the header. "
"Have a look at file net_box.c, function netbox_decode_data, to see how "
"Tarantool decodes the header. For example, in a successful response to "
"``box.space:select()``, the Response-Code-Indicator value will be 0 = "
"IPROTO_OK and the array will have all the tuples of the result."
msgstr ""

#, fuzzy
msgid "Binary protocol -- requests"
msgstr "Бинарный протокол Tarantool'а"

msgid ""
"After the :ref:`HEADER <box_protocol-header>`, for a request, there will "
"be a body that begins with these request-type IPROTO codes."
msgstr ""

msgid "**IPROTO_SELECT** = 0x01."
msgstr ""

msgid ""
"See :ref:`space_object:select()  <box_space-select>`. The body is a "
"6-item map:"
msgstr ""

msgid ""
"+=========================+=========================+=========================+"
"\n"
"|                         |                         |"
"                         |\n"
"|   0x10: IPROTO_SPACE_ID |   0x11: IPROTO_INDEX_ID |   0x12: "
"IPROTO_LIMIT    |\n"
"| MP_INT: MP_INT          | MP_INT: MP_INT          | MP_INT: MP_INT"
"          |\n"
"|                         |                         |"
"                         |\n"
"+=========================+=========================+=========================+"
"\n"
"|                         |                         |"
"                         |\n"
"|   0x13: IPROTO_OFFSET   |   0x14: IPROTO_ITERATOR |   0x20: IPROTO_KEY"
"      |\n"
"| MP_INT: MP_INT          | MP_INT: MP_INT          | MP_INT: MP_ARRAY"
"        |\n"
"|                         |                         |"
"                         |\n"
"+=========================+=========================+=========================+"
"\n"
"             MP_MAP"
msgstr ""

msgid ""
"IPROTO_SPACE_ID (0x10) + MP_INT, IPROTO_INDEX_ID (0x11) + MP_INT, "
"IPROTO_ITERATOR (0x14) + MP_INT, IPROTO_OFFSET (0x13) + MP_INT, "
"IPROTO_LIMIT (0x12) + MP_INT, IPROTO_KEY (0x20) + MP_ARRAY (array of key "
"values). See the illustration of IPROTO_SELECT in the earlier section, "
":ref:`Binary protocol -- illustration <box_protocol-illustration>`."
msgstr ""

msgid "**IPROTO_INSERT** = 0x02."
msgstr ""

msgid ""
"See :ref:`space_object:insert()  <box_space-insert>`. The body is a "
"2-item map:"
msgstr ""

msgid ""
"+=========================+======================+\n"
"|                         |                      |\n"
"|   0x10: IPROTO_SPACE_ID |   0x21: IPROTO_TUPLE |\n"
"| MP_INT: MP_INT          | MP_INT: MP_ARRAY     |\n"
"|                         |                      |\n"
"+=========================+======================+\n"
"                 MP_MAP"
msgstr ""

msgid ""
"IPROTO_SPACE_ID (0x10) + MP_INT, IPROTO_TUPLE + MP_ARRAY (array of field "
"values)."
msgstr ""

msgid ""
"**IPROTO_REPLACE** = 0x03, See :ref:`space_object:replace()  <box_space-"
"replace>`. The body is a 2-item map, the same as for IPROTO_INSERT:"
msgstr ""

msgid ""
"+=========================+======================+\n"
"|                         |                      |\n"
"|   0x10: IPROTO_SPACE_ID |   0x21: IPROTO_TUPLE |\n"
"| MP_INT: MP_INT          | MP_INT: MP_ARRAY     |\n"
"|                         |                      |\n"
"+=========================+======================+\n"
"               MP_MAP"
msgstr ""

msgid ""
"IPROTO_SPACE_ID (0x10) + MP_INT, IPROTO_TUPLE (0x21) + MP_ARRAY (array of"
" field values)."
msgstr ""

msgid "**IPROTO_UPDATE** = 0x04."
msgstr ""

msgid ""
"See :ref:`space_object:update()  <box_space-update>`. The body is usually"
" a 4-item map,"
msgstr ""

msgid ""
"+=========================+===============================+\n"
"|                         |                               |\n"
"|   0x10: IPROTO_SPACE_ID |   0x11: IPROTO_INDEX_ID       |\n"
"| MP_INT: MP_INT          | MP_INT: MP_INT                |\n"
"|                         |                               |\n"
"+=========================+===============================+\n"
"|                         |                 +~~~~~~~~~~~+ |\n"
"|                         |                 | usually   | |\n"
"|                         |                 | OPERATOR, | |\n"
"|                         | (IPROTO_TUPLE)  | FIELD_NO, | |\n"
"|   0x20: IPROTO_KEY      |    0x21:        | VALUE     | |\n"
"| MP_INT: MP_ARRAY        |  MP_INT:        +~~~~~~~~~~~+ |\n"
"|                         |                   MP_ARRAY    |\n"
"+=========================+===============================+\n"
"                MP_MAP"
msgstr ""

msgid ""
"IPROTO_SPACE_ID (0x10) + MP_INT, IPROTO_INDEX_ID (0x11) + MP_INT with "
"index number starting with 0, IPROTO_KEY (0x20) + MP_ARRAY (array of "
"index keys), IPROTO_TUPLE (0x21) + MP_ARRAY (array of update operations)."
" |br| If the operation specifies no values, it is a 2-item array: "
"OPERATOR MP_STR = ``\"#\"``, FIELD_NO MP_INT = field number starting with"
" 1. |br| If the operation specifies one value, it is a 3-item array: |br|"
msgstr ""

msgid ""
"0           2\n"
"+-------------+==========+===========+\n"
"|             |          |           |\n"
"| OPERATOR    | FIELD_NO | VALUE     |\n"
"| MP_STR      | MP_INT   | MP_OBJECT |\n"
"|             |          |           |\n"
"+-------------+==========+===========+\n"
"          MP_ARRAY"
msgstr ""

msgid ""
"OPERATOR MP_STR = ``\"+\"`` or ``\"-\"`` or ``\"&\"`` or ``\"^\"`` or "
"``\"|\"`` or ``\"!\"`` or ``\"=\"``), FIELD_NO MP_INT = field number "
"starting with 1, VALUE MP_OBJECT, that is, any type, MP_INT, MP_STR, "
"etc.. |br| Otherwise the operation is a 5-item array: |br|"
msgstr ""

msgid ""
"0           2\n"
"+-----------+==========+==========+========+==========+\n"
"|           |          |          |        |          |\n"
"| ':'       | FIELD_NO | POSITION | OFFSET | VALUE    |\n"
"| MP_STR    | MP_INT   | MP_INT   | MP_INT | MP_STR   |\n"
"|           |          |          |        |          |\n"
"+-----------+==========+==========+========+==========+\n"
"                      MP_ARRAY"
msgstr ""

msgid ""
"OPERATOR MP_STR = ``\":\"``, FIELD_NO MP_INT = field number starting with"
" 1, POSITION MP_INT, OFFSET MP_INT, VALUE MP_STR."
msgstr ""

msgid ""
"For example, suppose a user changes field #2 in tuple #2 in space #256 to"
" 'BBBB'. The body will look like this: (notice that in this case there is"
" an extra map item IPROTO_INDEX_BASE, to emphasize that field numbers "
"start with 1, which is optional and can be omitted):"
msgstr ""

msgid ""
"04               IPROTO_UPDATE\n"
"85               IPROTO_MAP, size 5\n"
"10                 IPROTO_SPACE_ID, Map Item#1\n"
"cd 02 00           MP_UINT 256\n"
"11                 IPROTO_INDEX_ID, Map Item#2\n"
"00                 MP_INT 0 = primary-key index number\n"
"15                 IPROTO_INDEX_BASE, Map Item#3\n"
"01                 MP_INT = 1 i.e. field numbers start at 1\n"
"21                 IPROTO_TUPLE, Map Item#4\n"
"91                 MP_ARRAY, size 1, for array of operations\n"
"93                   MP_ARRAY, size 3\n"
"a1 3d                   MP_STR = OPERATOR = '='\n"
"02                      MP_INT = FIELD_NO = 2\n"
"a5 42 42 42 42 42       MP_STR = VALUE = 'BBBB'\n"
"20                 IPROTO_KEY, Map Item#5\n"
"91                 MP_ARRAY, size 1, for array of key values\n"
"02                   MP_UINT = primary-key value = 2"
msgstr ""

msgid "**IPROTO_DELETE** = 0x05."
msgstr ""

msgid ""
"See :ref:`space_object:delete()  <box_space-delete>`. The body is a "
"3-item map:"
msgstr ""

msgid ""
"+=========================+=========================+====================+"
"\n"
"|                         |                         |                    "
"|\n"
"|   0x10: IPROTO_SPACE_ID |   0x11: IPROTO_INDEX_ID |   0x20: IPROTO_KEY "
"|\n"
"| MP_INT: MP_INT          | MP_INT: MP_INT          | MP_INT: MP_ARRAY   "
"|\n"
"|                         |                         |                    "
"|\n"
"+=========================+=========================+====================+"
"\n"
"                          MP_MAP"
msgstr ""

msgid ""
"IPROTO_SPACE_ID (0x10) + MP_INT, IPROTO_INDEX_ID (0x11) + MP_INT, "
"IPROTO_KEY (0x20) + MP_ARRAY (array of key values)."
msgstr ""

msgid "**IPROTO_CALL_16** = 0x06."
msgstr ""

msgid ""
"See :ref:`conn:call() <net_box-call>`. The suffix ``_16`` is a hint that "
"this is for the ``call()`` until Tarantool 1.6. It is deprecated. Use "
":ref:`IPROTO_CALL <box_protocol-call>` instead. The body is a 2-item map:"
msgstr ""

msgid ""
"+==============================+=======================+\n"
"|                              |                       |\n"
"|   0x22: IPROTO_FUNCTION_NAME |   0x21: IPROTO_TUPLE  |\n"
"| MP_INT: MP_STRING            | MP_INT: MP_ARRAY      |\n"
"|                              |                       |\n"
"+==============================+=======================+\n"
"                    MP_MAP"
msgstr ""

msgid ""
"IPROTO_FUNCTION_NAME (0x22) +  function name (MP_STRING), IPROTO_TUPLE "
"(0x22) + array of arguments (MP_ARRAY). The return value is an array of "
"tuples."
msgstr ""

msgid "**IPROTO_AUTH** = 0x07."
msgstr ""

msgid ""
"See :ref:`authentication <authentication-users>`. See the later section "
":ref:`Binary protocol -- authentication <box_protocol-authentication>`."
msgstr ""

msgid "**IPROTO_EVAL** = 0x08."
msgstr ""

msgid ""
"See :ref:`conn:eval() <net_box-eval>`. Since the argument is a Lua "
"expression, this is Tarantool's way to handle non-binary with the binary "
"protocol. Any request that does not have its own code, for example "
":samp:`box.space.{space-name}:drop()`, will be handled either with "
":ref:`IPROTO_CALL <box_protocol-call>` or IPROTO_EVAL. Some client-like "
"utilities, such as :ref:`tarantoolctl <tarantoolctl>`, make extensive use"
" of ``eval``. The body is a 2-item map:"
msgstr ""

msgid ""
"+=======================+======================+\n"
"|                       |                      |\n"
"|   0x27: IPROTO_EXPR   |   0x21: IPROTO_TUPLE |\n"
"| MP_INT: MP_STRING     | MP_INT: MP_ARRAY     |\n"
"|                       |                      |\n"
"+=======================+======================+\n"
"                MP_MAP"
msgstr ""

msgid ""
"IPROTO_EXPR (0x27) + expression (MP_STRING), IPROTO_TUPLE (0x21) + array "
"of arguments to match placeholders."
msgstr ""

msgid "**IPROTO_UPSERT** = 0x09."
msgstr ""

msgid ""
"See :ref:`space_object:upsert()  <box_space-upsert>`. The body is the "
"same as the body of :ref:`IPROTO_UPDATE <box_protocol-update>`."
msgstr ""

msgid "**IPROTO_CALL** = 0x0a."
msgstr ""

msgid "See :ref:`conn:call() <net_box-call>`. The body is a 2-item map:"
msgstr ""

msgid ""
"+==============================+======================+\n"
"|                              |                      |\n"
"|   0x22: IPROTO_FUNCTION_NAME |   0x21: IPROTO_TUPLE |\n"
"| MP_INT: MP_STRING            | MP_INT: MP_ARRAY     |\n"
"|                              |                      |\n"
"+==============================+======================+\n"
"                        MP_MAP"
msgstr ""

msgid ""
"IPROTO_FUNCTION_NAME (0x22) +  function name (MP_STRING), IPROTO_TUPLE "
"(0x22) + array of arguments (MP_ARRAY). The response will be a list of "
"values, similar to the :ref:`IPROTO_EVAL <box_protocol-eval>` response."
msgstr ""

msgid "**IPROTO_EXECUTE** = 0x0b."
msgstr ""

msgid ""
"See :ref:`box.execute() <box-sql_box_execute>`, this is only for SQL. The"
" body is a 3-item map:"
msgstr ""

msgid ""
"+=========================+=========================+========================+"
"\n"
"|                         |                         |"
"                        |\n"
"|   0x43: IPROTO_STMT_ID  |   0x11: IPROTO_SQL_BIND |   0x20: "
"IPROTO_OPTIONS |\n"
"| MP_INT: MP_INT          | MP_INT: MP_INT          | MP_INT: MP_ARRAY"
"       |\n"
"|   or                    |                         |"
"                        |\n"
"|   0x40: IPROTO_SQL_TEXT |                         |"
"                        |\n"
"| MP_INT: MP_STR          |                         |"
"                        |\n"
"|                         |                         |"
"                        |\n"
"+=========================+=========================+========================+"
"\n"
"                          MP_MAP"
msgstr ""

msgid ""
"IPROTO_STMT_ID (0x43) + statement-id (MP_INT) if executing a prepared "
"statement or IPROTO_SQL_TEXT (0x40) + statement-text (MP_STR) if "
"executing an SQL string, IPROTO_SQL_BIND (0x41) + array of parameter "
"values to match ? placeholders or :name placeholders, IPROTO_OPTIONS "
"(0x2b) + array of options (usually empty)."
msgstr ""

msgid ""
"For example, suppose we prepare a statement with two ? placeholders, and "
"execute with two parameters, thus: |br| :code:`n = conn:prepare([[VALUES "
"(?, ?);]])` |br| :code:`conn:execute(n.stmt_id, {1,'a'})` |br| Then the "
"body will look like this:"
msgstr ""

msgid ""
"0b               IPROTO_EXECUTE\n"
"83               MP_MAP, size 3\n"
"43                 IPROTO_STMT_ID Map Item#1\n"
"ce d7 aa 74 1b     MP_UINT value of n.stmt_id\n"
"41                 IPROTO_SQL_BIND Map Item#2\n"
"92                 MP_ARRAY, size 2\n"
"01                   MP_INT = 1 = value for first parameter\n"
"a1 61                MP_STR = 'a' = value for second parameter\n"
"2b                 IPROTO_OPTIONS Map Item#3\n"
"90                 MP_ARRAY, size 0 (there are no options)"
msgstr ""

msgid "**IPROTO_NOP** = 0x0c."
msgstr ""

msgid ""
"There is no Lua request exactly equivalent to IPROTO_NOP. It causes the "
"LSN to be incremented. It could be sometimes used for updates where the "
"old and new values are the same, but the LSN must be increased because a "
"data-change must be recorded. The body is: nothing."
msgstr ""

msgid "**IPROTO_PREPARE** = 0x0d."
msgstr ""

msgid ""
"See :ref:`box.prepare <box-sql_box_prepare>`, this is only for SQL. The "
"body is a 1-item map:"
msgstr ""

msgid ""
"+=========================+\n"
"|                         |\n"
"|   0x10: IPROTO_STMT_ID  |\n"
"| MP_INT: MP_INT          |\n"
"|   or                    |\n"
"|   0x10: IPROTO_SQL_TEXT |\n"
"| MP_INT: MP_STR          |\n"
"|                         |\n"
"+=========================+\n"
"     MP_MAP"
msgstr ""

msgid ""
"IPROTO_STMT_ID (0x43) + statement-id (MP_INT) if executing a prepared "
"statement or IPROTO_SQL_TEXT (0x40) + statement-text (string) if "
"executing an SQL string. Thus the IPROTO_PREPARE map item is the same as "
"the first item of the :ref:`IPROTO_EXECUTE <box_protocol-execute>` map."
msgstr ""

msgid "**IPROTO_PING** = 0x40."
msgstr ""

msgid ""
"See :ref:`conn:ping() <conn-ping>`. The BODY will be an empty map because"
" IPROTO_PING in the HEADER contains all the information that the server "
"instance needs."
msgstr ""

msgid ""
"**IPROTO_JOIN** = 0x41, for replication  |br| **IPROTO_SUBSCRIBE** = "
"0x42, for replication SUBSCRIBE |br| **IPROTO_VOTE_DEPRECATED** = 0x43, "
"for old style vote, superseded by IPROTO_VOTE |br| **IPROTO_VOTE** = "
"0x44, for master election |br| **IPROTO_FETCH_SNAPSHOT** = 0x45, for "
"starting anonymous replication |br| **IPROTO_REGISTER** =0x46, for "
"leaving anonymous replication."
msgstr ""

msgid ""
"Tarantool constants 0x41 to 0x46 (decimal 65 to 70) are for replication. "
"Connectors and clients do not need to send replication packets. See "
":ref:`Binary protocol -- replication <box_protocol-replication>`."
msgstr ""

msgid "Binary protocol -- responses if no error and no SQL"
msgstr ""

msgid ""
"After the :ref:`HEADER <box_protocol-header>`, for a response, there will"
" be a body. It will contain IPROTO_OK (0x00) (there was no error), or an "
"error code other than IPROTO_OK (there was an error). Responses to SQL "
"statements are slightly different and will be described in the later "
"section, :ref:`Binary protocol -- responses for SQL <box_protocol-"
"sql_protocol>`."
msgstr ""

msgid ""
"For IPROTO_OK, the header Response-Code-Indicator will be 0 and the body "
"will be:"
msgstr ""

msgid ""
"++=====================+\n"
"||                     |\n"
"||   0x30: IPROTO_DATA |\n"
"|| MP_INT: MP_OBJECT   |\n"
"||                     |\n"
"++=====================+\n"
"    MP_MAP"
msgstr ""

msgid ""
"For :ref:`IPROTO_PING <box_protocol-ping>` the body will be an empty map."
" For most data-access requests (IPROTO_SELECT IPROTO_INSERT IPROTO_DELETE"
" etc.) it will be an array of tuples that contain an array of fields. For"
" :ref:`IPROTO_EVAL <box_protocol-eval>` and :ref:`IPROTO_CALL "
"<box_protocol-call>` it will usually be an array but, since Lua requests "
"can result in a wide variety of structures, bodies can have a wide "
"variety of structures."
msgstr ""

msgid ""
"For example, after :codenormal:`box.space.`:codeitalic:`space-"
"name`:codenormal:`:insert{6}` a successful response will look like this:"
msgstr ""

msgid ""
"ce 00 00 00 20                MP_UINT = HEADER + BODY SIZE\n"
"83                            MP_MAP, size 3\n"
"00                              Response-Code-Indicator\n"
"ce 00 00 00 00                  MP_UINT = IPROTO_OK\n"
"01                              IPROTO_SYNC\n"
"cf 00 00 00 00 00 00 00 53      MP_UINT = sync value\n"
"05                              IPROTO_SCHEMA_VERSION\n"
"ce 00 00 00 68                  MP_UINT = schema version\n"
"81                            MP_MAP, size 1\n"
"30                              IPROTO_DATA\n"
"dd 00 00 00 01                  MP_ARRAY, size 1 (row count)\n"
"91                              MP_ARRAY, size 1 (field count)\n"
"06                              MP_INT = 6 = the value that was inserted"
msgstr ""

msgid ""
"IPROTO_DATA is what we get with net_box and :ref:`Module buffer <buffer-"
"module>` so if we were using net_box we could decode with "
":ref:`msgpack.decode_unchecked() <msgpack-decode_unchecked_string>`, or "
"we could convert to a string with :samp:`ffi.string({pointer},{length})`."
" The :ref:`pickle.unpack() <pickle-unpack>` function might also be "
"helpful."
msgstr ""

msgid "Binary protocol -- responses for errors"
msgstr ""

msgid ""
"For a response other than IPROTO_OK, the header Response-Code-Indicator "
"will be 0x8XXX and the body will be:"
msgstr ""

msgid ""
"++=========================+\n"
"||                         |\n"
"||   0x31: IPROTO_ERROR_24 |\n"
"|| MP_INT: MP_STRING       |\n"
"||                         |\n"
"++=========================+\n"
"      MP_MAP"
msgstr ""

msgid ""
"where 0x8XXX is the indicator for an error and XXX is a value in "
"`src/box/errcode.h "
"<https://github.com/tarantool/tarantool/blob/master/src/box/errcode.h>`_."
" ``src/box/errcode.h`` also has some convenience macros which define "
"hexadecimal constants for return codes."
msgstr ""

msgid ""
"For example, in version 2.4.0 or earlier, if we try to create a duplicate"
" space with |br| ``conn:eval([[box.schema.space.create('_space');]])`` "
"|br| the server response will look like this:"
msgstr ""

msgid ""
"ce 00 00 00 3b                  MP_UINT = HEADER + BODY SIZE\n"
"83                              MP_MAP, size 3 (i.e. 3 items in header)\n"
"  00                              Response-Code-Indicator\n"
"  ce 00 00 80 0a                  MP_UINT = hexadecimal 800a\n"
"  01                              IPROTO_SYNC\n"
"  cf 00 00 00 00 00 00 00 26      MP_UINT = sync value\n"
"  05                              IPROTO_SCHEMA_VERSION\n"
"  ce 00 00 00 78                  MP_UINT = schema version value\n"
"  81                              MP_MAP, size 1\n"
"    31                              IPROTO_ERROR_24\n"
"    db 00 00 00 1d 53 70 61 63 etc. MP_STR = \"Space '_space' already "
"exists\""
msgstr ""

#, python-format
msgid ""
"Looking in errcode.h we find that error code 0x0a (decimal 10) is "
"ER_SPACE_EXISTS, and the string associated with ER_SPACE_EXISTS is "
"\"Space '%s' already exists\"."
msgstr ""

msgid ""
"Beginning in version 2.4.1, responses for errors have extra information "
"following what was described above. This extra information is given via "
"MP_ERROR extension type. See details in :ref:`MessagePack extensions "
"<msgpack_ext-error>` section."
msgstr ""

msgid "Binary protocol -- responses for SQL"
msgstr ""

msgid ""
"After the :ref:`HEADER <box_protocol-header>`, for a response to an SQL "
"statement, there will be a body that is slightly different from the body "
"for :ref:`Binary protocol -- responses if no error and no SQL "
"<box_protocol-responses>`."
msgstr ""

msgid ""
"If the SQL request is not SELECT or VALUES or PRAGMA, then the response "
"body contains only IPROTO_SQL_INFO (0x42). Usually IPROTO_SQL_INFO is a "
"map with only one item -- SQL_INFO_ROW_COUNT (0x00) -- which is the "
"number of changed rows."
msgstr ""

msgid ""
"+=========================================================+\n"
"|                                                         |\n"
"|   0x42: IPROTO_SQL_INFO                                 |\n"
"| MP_MAP: usually 1 item  +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+ |\n"
"|                         |                             | |\n"
"|                         |    0x00: SQL_INFO_ROW_COUNT | |\n"
"|                         | MP_UINT: changed row count  | |\n"
"|                         |                             | |\n"
"|                         +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+ |\n"
"|                                                         |\n"
"+=========================================================+"
msgstr ""

msgid ""
"For example, if the request is :samp:`INSERT INTO {table-name} VALUES "
"(1), (2), (3)`, then the response body contains an IPROTO_SQL_INFO map "
"with SQL_INFO_ROW_COUNT = 3. SQL_INFO_ROW_COUNT can be 0 for statements "
"that do not change rows, but can be 1 for statements that create new "
"objects."
msgstr ""

msgid ""
"The IPROTO_SQL_INFO map may contain a second item -- "
"SQL_INFO_AUTO_INCREMENT_IDS (0x01) -- which is the new primary-key value "
"(or values) for an INSERT in a table defined with PRIMARY KEY "
"AUTOINCREMENT. In this case the MP_MAP will have two keys, and  one of "
"the two keys will be 0x01: SQL_INFO_AUTO_INCREMENT_IDS, which is an array"
" of unsigned integers."
msgstr ""

msgid ""
"For example, if we use the same net.box connection that we used for "
":ref:`Binary protocol -- illustration <box_protocol-illustration>` and we"
" say |br| ``conn:execute([[CREATE TABLE t1 (dd INT PRIMARY KEY "
"AUTOINCREMENT, дд STRING COLLATE \"unicode\");]])`` |br| "
"``conn:execute([[INSERT INTO t1 VALUES (NULL, 'a'), (NULL, 'b');]])`` "
"|br| and we watch what tcpdump displays, we will see two noticeable "
"things: (1) the CREATE statement caused a schema change so the response "
"has a new IPROTO_SCHEMA_VERSION value and the body includes the new "
"contents of some system tables (caused by requests from net.box which "
"users will not see); (2) the final bytes of the response to the INSERT "
"will be:"
msgstr ""

msgid ""
"81   MP_MAP, size 1\n"
"42     IPROTO_SQL_INFO\n"
"82     MP_MAP, size 2\n"
"00       Tarantool constant (not in iproto_constants.h) = "
"SQL_INFO_ROW_COUNT\n"
"02       1 = row count\n"
"01       Tarantool constant (not in iproto_constants.h) = "
"SQL_INFO_AUTOINCREMENT_ID\n"
"92       MP_ARRAY, size 2\n"
"01         first autoincrement number\n"
"02         second autoincrement number"
msgstr ""

msgid "If the SQL statement is SELECT or VALUES or PRAGMA, the response contains:"
msgstr ""

msgid ""
"IPROTO_METADATA + array of column maps, with each column map containing "
"at least IPROTO_FIELD_NAME (0x00) + MP_STR, and IPROTO_FIELD_TYPE (0x01) "
"+ MP_STR. Additionally, if ``sql_full_metadata`` in the "
":ref:`_session_settings <box_space-session_settings>` system space is "
"TRUE, then the array will have these additional column maps which "
"correspond to components described in the :ref:`box.execute() <box-"
"sql_if_full_metadata>` section: IPROTO_FIELD_COLL (0x02) + MP_STR, "
"IPROTO_FIELD_IS_NULLABLE (0x03) + MP_BOOL, IPROTO_FIELD_IS_AUTOINCREMENT "
"(0x04) + MP_BOOL, IPROTO_FIELD_SPAN (0x05) + MP_STR or MP_NIL."
msgstr ""

msgid "IPROTO_DATA + array of tuples = the result set \"rows\""
msgstr ""

msgid ""
"EXECUTE SELECT RESPONSE BODY:\n"
"                              MAP\n"
"+=============================================+===========================+"
"\n"
"|                                             |"
"                           |\n"
"|     0x32: IPROTO_METADATA                   |"
"                           |\n"
"| MP_ARRAY: array of maps:                    |"
"                           |\n"
"|           +~~~~~~~~~~~~~~~~~~~~~~-------~~+ |"
"                           |\n"
"|           | +~~~~~~~~~~~~~-------~~~~~~~+ | |     0x30: IPROTO_DATA"
"     |\n"
"|           | |   0x00: IPROTO_FIELD_NAME | | | MP_ARRAY: array of tuples"
" |\n"
"|           | | MP_STR: field name        | | |"
"                           |\n"
"|           | |   0x01: IPROTO_FIELD_TYPE | | |"
"                           |\n"
"|           | | MP_STR: field type        | | |"
"                           |\n"
"|           | | + more if full metadata   | | |"
"                           |\n"
"|           | +~~~~~~~~~~~~~~~~~~~~~~~~~~~+ | |"
"                           |\n"
"|           |        MP_MAP                 | |"
"                           |\n"
"|           +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+ |"
"                           |\n"
"|                   MP_ARRAY                  |"
"                           |\n"
"|                                             |"
"                           |\n"
"+=============================================+===========================+"
msgstr ""

msgid ""
"For example, if we use the same net_box connection that we used for "
":ref:`Binary protocol -- illustration <box_protocol-illustration>` and we"
" ask for full metadata by saying |br| "
":code:`conn.space._session_settings:update('sql_full_metadata', {{'=', "
"'value', true}})` |br| and we select the two rows from the table that we "
"just created |br| :code:`conn:execute([[SELECT dd, дд AS д FROM t1;]])` "
"|br| then tcpdump will show this response, after the header:"
msgstr ""

msgid ""
"82                       MP_MAP, size 2 (i.e. metadata and rows)\n"
"32                         IPROTO_METADATA\n"
"92                         MP_ARRAY, size 2 (i.e. 2 columns)\n"
"85                           MP_MAP, size 5 (i.e. 5 items for column#1)\n"
"00 a2 44 44                    IPROTO_FIELD_NAME + 'DD'\n"
"01 a7 69 6e 74 65 67 65 72     IPROTO_FIELD_TYPE + 'integer'\n"
"03 c2                          IPROTO_FIELD_IS_NULLABLE + false\n"
"04 c3                          IPROTO_FIELD_IS_AUTOINCREMENT + true\n"
"05 c0                          PROTO_FIELD_SPAN + nil\n"
"85                           MP_MAP, size 5 (i.e. 5 items for column#2)\n"
"00 a2 d0 94                    IPROTO_FIELD_NAME + 'Д' upper case\n"
"01 a6 73 74 72 69 6e 67        IPROTO_FIELD_TYPE + 'string'\n"
"02 a7 75 6e 69 63 6f 64 65     IPROTO_FIELD_COLL + 'unicode'\n"
"03 c3                          IPROTO_FIELD_IS_NULLABLE + true\n"
"05 a4 d0 b4 d0 b4              IPROTO_FIELD_SPAN + 'дд' lower case\n"
"30                         IPROTO_DATA\n"
"92                         MP_ARRAY, size 2\n"
"92                           MP_ARRAY, size 2\n"
"01                             MP_INT = 1 i.e. contents of row#1 column#1"
"\n"
"a1 61                          MP_STR = 'a' i.e. contents of row#1 "
"column#2\n"
"92                           MP_ARRAY, size 2\n"
"02                             MP_INT = 2 i.e. contents of row#2 column#1"
"\n"
"a1 62                          MP_STR = 'b' i.e. contents of row#2 "
"column#2"
msgstr ""

msgid ""
"If instead we said |br| :code:`conn:prepare([[SELECT dd, дд AS д FROM "
"t1;]])` |br| then tcpdump would should show almost the same response, but"
" there would be no IPROTO_DATA and there would be two additional items: "
"|br| 34 00 = IPROTO_BIND_COUNT + MP_UINT = 0 (there are no parameters to "
"bind), |br| 33 90 = IPROTO_BIND_METADATA + MP_ARRAY, size 0 (there are no"
" parameters to bind)."
msgstr ""

msgid ""
"84                       MP_MAP, size 4\n"
"43                         IPROTO_STMT_ID\n"
"ce c2 3c 2c 1e             MP_UINT = statement id\n"
"34                         IPROTO_BIND_COUNT\n"
"00                         MP_INT = 0 = number of parameters to bind\n"
"33                         IPROTO_BIND_METADATA\n"
"90                         MP_ARRAY, size 0 = there are no parameters to "
"bind\n"
"32                         IPROTO_METADATA\n"
"92                         MP_ARRAY, size 2 (i.e. 2 columns)\n"
"85                           MP_MAP, size 5 (i.e. 5 items for column#1)\n"
"00 a2 44 44                    IPROTO_FELD_NAME + 'DD'\n"
"01 a7 69 6e 74 65 67 65 72     IPROTO_FIELD_TYPE + 'integer'\n"
"03 c2                          IPROTO_FIELD_IS_NULLABLE + false\n"
"04 c3                          IPROTO_FIELD_IS_AUTOINCREMENT + true\n"
"05 c0                          PROTO_FIELD_SPAN + nil\n"
"85                           MP_MAP, size 5 (i.e. 5 items for column#2)\n"
"00 a2 d0 94                    IPROTO_FIELD_NAME + 'Д' upper case\n"
"01 a6 73 74 72 69 6e 67        IPROTO_FIELD_TYPE + 'string'\n"
"02 a7 75 6e 69 63 6f 64 65     IPROTO_FIELD_COLL + 'unicode'\n"
"03 c3                          IPROTO_FIELD_IS_NULLABLE + true\n"
"05 a4 d0 b4 d0 b4              IPROTO_FIELD_SPAN + 'дд' lower case"
msgstr ""

msgid ""
"Now read the source code file `net_box.c "
"<https://github.com/tarantool/tarantool/blob/master/src/box/lua/net_box.c>`_"
" where the function \"decode_metadata_optional\" is an example of how "
"Tarantool itself decodes extra items."
msgstr ""

msgid "Binary protocol -- authentication"
msgstr ""

msgid ""
"When a client connects to the server instance, the instance responds with"
" a 128-byte text greeting message, like this:"
msgstr ""

#, fuzzy
msgid ""
"Greeting packet sent by server after connect:\n"
"\n"
"0                                     63\n"
"+--------------------------------------+\n"
"|                                      |\n"
"| Tarantool Greeting (server version)  |\n"
"|               64 bytes               |\n"
"+---------------------+----------------+\n"
"|                     |                |\n"
"| BASE64 encoded SALT |      NULL      |\n"
"|      44 bytes       |                |\n"
"+---------------------+----------------+\n"
"64                  107              127"
msgstr ""
"ПРИВЕТСТВИЕ TARANTOOL'А:\n"
" \n"
" 0                                     63\n"
" +--------------------------------------+\n"
" |                                      |\n"
" | Приветствие Tarantool'а (версия сервера)  |\n"
" |               64 байта               |\n"
" +---------------------+----------------+\n"
" |                     |                |\n"
" | СОЛЬ в кодировке BASE64 |      NULL      |\n"
" |      44 байта       |                |\n"
" +---------------------+----------------+\n"
" 64                  107              127"

#, fuzzy
msgid ""
"The greeting contains two 64-byte lines of ASCII text. Each line ends "
"with a newline character (:code:`\\n`). The first line contains the "
"instance version and protocol type. The second line contains up to 44 "
"bytes of base64-encoded random string, to use in the authentication "
"packet, and ends with up to 23 spaces."
msgstr ""
"Экземпляр сервера начинает диалог с отправки клиенту текста приветствия "
"фиксированного размера (128 байтов). Приветствие всегда содержит две "
"64-байтные строки текста в формате ASCII, каждая строка заканчивается "
"символом разрыва строки (:code:`\\n`). Первая строка описывает версию "
"экземпляра и тип протокола. Вторая строка содержит случайную строку в "
"кодировке base64 размером до 44 байтов для использования в пакете "
"аутентификации и заканчивается на пробелы (до 23)."

msgid ""
"Part of the greeting is a base-64-encoded session salt - a random string "
"which can be used for authentication. The maximum length of an encoded "
"salt (44 bytes) is more than the amount necessary to create the "
"authentication message. An excess is reserved for future authentication "
"schemas."
msgstr ""

msgid ""
"Authentication is optional -- if it is skipped, then the session user is "
"``'guest'`` (the ``'guest'`` user does not need a password)."
msgstr ""

msgid ""
"If authentication is not skipped, then at any time an authentication "
"packet can be prepared using the greeting, the user's name and password, "
"and `sha-1 <https://en.wikipedia.org/wiki/SHA-1>`_ functions, as follows."
msgstr ""

msgid ""
"PREPARE SCRAMBLE:\n"
"\n"
"    size_of_encoded_salt_in_greeting = 44;\n"
"    size_of_salt_after_base64_decode = 32;\n"
"    /* sha1() will only use the first 20 bytes */\n"
"    size_of_any_sha1_digest = 20;\n"
"    size_of_scramble = 20;\n"
"\n"
"prepare 'chap-sha1' scramble:\n"
"\n"
"    salt = base64_decode(encoded_salt);\n"
"    step_1 = sha1(password);\n"
"    step_2 = sha1(step_1);\n"
"    step_3 = sha1(first_20_bytes_of_salt, step_2);\n"
"    scramble = xor(step_1, step_3);\n"
"    return scramble;\n"
"\n"
"AUTHORIZATION BODY: CODE = IPROTO_AUTH (0x07)\n"
"\n"
"+==========================+=====================================+\n"
"|                          |        +-------------+------------+ |\n"
"|  (KEY)                   | (TUPLE)| size == 9   | size == 20 | |\n"
"|   0x23: IPROTO_USER_NAME |   0x21:| \"chap-sha1\" |  SCRAMBLE  | |\n"
"| MP_INT: MP_STRING        | MP_INT:|  MP_STRING  |  MP_STRING | |\n"
"|                          |        +-------------+------------+ |\n"
"|                          |                   MP_ARRAY          |\n"
"+==========================+=====================================+\n"
"                        MP_MAP"
msgstr ""

#, fuzzy
msgid ""
":code:`<key>` holds the user name. :code:`<tuple>` must be an array of 2 "
"fields: authentication mechanism (\"chap-sha1\" is the only supported "
"mechanism right now) and scramble, encrypted according to the specified "
"mechanism."
msgstr ""
":code:`<key>` содержит имя пользователя. :code:`<tuple>` должен "
"представлять собой массив из 2 полей: механизм аутентификации (в данный "
"момент поддерживается только механизм \"chap-sha1\") и пароль, "
"закодированный в соответствии с указанным механизмом. Аутентификация в "
"Tarantool'е необязательна: если аутентификация не проводится, то "
"пользователем в сессии будет 'guest'. Экземпляр отвечает на пакет "
"аутентификации стандартным ответом с 0 кортежей."

msgid ""
"The server instance responds to an authentication packet with a standard "
"response with 0 tuples."
msgstr ""

msgid ""
"To see how Tarantool handles this, look at `net_box.c "
"<https://github.com/tarantool/tarantool/blob/master/src/box/lua/net_box.c>`_"
" function netbox_encode_auth."
msgstr ""

#, fuzzy
msgid "Binary protocol -- replication"
msgstr "Бинарный протокол Tarantool'а"

#, fuzzy
msgid ""
"-- replication keys\n"
"<server_id>    ::= 0x02\n"
"<lsn>          ::= 0x03\n"
"<timestamp>    ::= 0x04\n"
"<server_uuid>  ::= 0x24\n"
"<cluster_uuid> ::= 0x25\n"
"<vclock>       ::= 0x26"
msgstr ""
"-- ключи для репликации\n"
" <server_id>     ::= 0x02\n"
" <lsn>           ::= 0x03\n"
" <timestamp>     ::= 0x04\n"
" <server_uuid>   ::= 0x24\n"
" <cluster_uuid>  ::= 0x25\n"
" <vclock>        ::= 0x26"

#, fuzzy
msgid ""
"-- replication codes\n"
"<join>         ::= 0x41\n"
"<subscribe>    ::= 0x42"
msgstr ""
"-- коды для репликации\n"
"<join>      ::= 0x41\n"
"<subscribe> ::= 0x42"

msgid ""
"JOIN:\n"
"\n"
"In the beginning you must send an initial IPROTO_JOIN request (0x41)\n"
"               HEADER                      BODY\n"
"+================+=======================++========================+\n"
"|                |                       ||   IPROTO_INSTANCE_UUID |\n"
"|   0x00: 0x41   |   0x01: IPROTO_SYNC   ||   0x24: UUID           |\n"
"| MP_INT: MP_INT | MP_INT: MP_INT        || MP_INT: MP_STRING      |\n"
"|                |                       ||                        |\n"
"+================+=======================++========================+\n"
"               MP_MAP                     MP_MAP\n"
"\n"
"Then the instance which you want to connect to will send its last SNAP "
"file, by simply\n"
"creating a number of INSERTs (with additional LSN and ServerID)\n"
"(do not reply to this). Then that instance will send a vclock's MP_MAP "
"and close a socket.\n"
"\n"
"+================+=======================++============================+\n"
"|                |                       ||        +~~~~~~~~~~~~~~~~~+ |\n"
"|                |                       ||        |                 | |\n"
"|   0x00: 0x00   |   0x01: IPROTO_SYNC   ||   0x26:| SRV_ID: SRV_LSN | |\n"
"| MP_INT: MP_INT | MP_INT: MP_INT        || MP_INT:| MP_INT: MP_INT  | |\n"
"|                |                       ||        +~~~~~~~~~~~~~~~~~+ |\n"
"|                |                       ||               MP_MAP       |\n"
"+================+=======================++============================+\n"
"               MP_MAP                      MP_MAP\n"
"\n"
"SUBSCRIBE:\n"
"\n"
"Then you must send an IPROTO_SUBSCRIBE request (0x42)\n"
"\n"
"                              HEADER\n"
"+=========================+========================+\n"
"|                         |                        |\n"
"|     0x00: 0x42          |    0x01: IPROTO_SYNC   |\n"
"|   MP_INT: MP_INT        |  MP_INT: MP_INT        |\n"
"|                         |                        |\n"
"+=========================+========================+\n"
"|    IPROTO_INSTANCE_UUID |    IPROTO_CLUSTER_UUID |\n"
"|   0x24: UUID            |   0x25: UUID           |\n"
"| MP_INT: MP_STRING       | MP_INT: MP_STRING      |\n"
"|                         |                        |\n"
"+=========================+========================+\n"
"                 MP_MAP\n"
"\n"
"      BODY\n"
"+=======================+\n"
"|                       |\n"
"|   0x26: IPROTO_VCLOCK |\n"
"| MP_INT: MP_INT        |\n"
"|                       |\n"
"+=======================+\n"
"      MP_MAP\n"
"\n"
"Then you must process every request that could come through other "
"masters.\n"
"Every request between masters will have Additional LSN and SERVER_ID."
msgstr ""

msgid "XLOG / SNAP"
msgstr "XLOG / SNAP"

#, fuzzy
msgid ".xlog and .snap files have nearly the same format. The header looks like:"
msgstr ""
"Файлы форматов XLOG и SNAP выглядят практически одинаково. Заголовок "
"выглядит следующим образом:"

msgid ""
"<type>\\n                  SNAP\\n or XLOG\\n\n"
"<version>\\n               currently 0.13\\n\n"
"Server: <server_uuid>\\n   where UUID is a 36-byte string\n"
"VClock: <vclock_map>\\n    e.g. {1: 0}\\n\n"
"\\n"
msgstr ""
"<type>\\n                  SNAP\\n или XLOG\\n\n"
"<version>\\n               в данный момент 0.13\\n\n"
"Server: <server_uuid>\\n   где UUID -- это 36-байтная строка\n"
"VClock: <vclock_map>\\n    например, {1: 0}\\n\n"
"\\n"

msgid ""
"After the file header come the data tuples. Tuples begin with a row "
"marker ``0xd5ba0bab`` and the last tuple may be followed by an EOF marker"
" ``0xd510aded``. Thus, between the file header and the EOF marker, there "
"may be data tuples that have this form:"
msgstr ""
"После файла заголовка идут кортежи с данными. Кортежи начинаются с "
"маркера строки ``0xd5ba0bab``, а после последнего кортежа может стоять "
"маркер конца файла ``0xd510aded``. Таким образом, между заголовком файла "
"и маркером конца файла могут быть кортежи с данными в следующем виде:"

msgid ""
"0            3 4                                         17\n"
"+-------------+========+============+===========+=========+\n"
"|             |        |            |           |         |\n"
"| 0xd5ba0bab  | LENGTH | CRC32 PREV | CRC32 CUR | PADDING |\n"
"|             |        |            |           |         |\n"
"+-------------+========+============+===========+=========+\n"
"  MP_FIXEXT2    MP_INT     MP_INT       MP_INT      ---\n"
"\n"
"+============+ +===================================+\n"
"|            | |                                   |\n"
"|   HEADER   | |                BODY               |\n"
"|            | |                                   |\n"
"+============+ +===================================+\n"
"    MP_MAP                     MP_MAP"
msgstr ""
"0            3 4                                         17\n"
"+-------------+========+============+===========+=========+\n"
"|             |        |            |           |         |\n"
"| 0xd5ba0bab  | LENGTH | CRC32 PREV | CRC32 CUR | PADDING |\n"
"|             |        |            |           |         |\n"
"+-------------+========+============+===========+=========+\n"
"  MP_FIXEXT2    MP_INT     MP_INT       MP_INT      ---\n"
"\n"
"+============+ +===================================+\n"
"|            | |                                   |\n"
"|   HEADER   | |                BODY               |\n"
"|            | |                                   |\n"
"+============+ +===================================+\n"
"    MP_MAP                     MP_MAP"

msgid ""
"See the example in the :ref:`File formats <internals-data_persistence>` "
"section."
msgstr "См. пример в разделе :ref:`Форматы файлов <internals-data_persistence>`."

#~ msgid ""
#~ "**MP_EXT**    extension (including the "
#~ ":ref:`DECIMAL type <box_protocol-decimal>`)"
#~ msgstr ""

#~ msgid "**IPROTO_INSERT** == 0x02."
#~ msgstr ""

#~ msgid ""
#~ "IPROTO_DATA is what we get with "
#~ "net_box and :ref:`Module buffer <buffer-"
#~ "module>` so if we were using "
#~ "net_box we could decode with "
#~ ":ref:`msgpack.decode_unchecked() <msgpack-"
#~ "decode_unchecked>`, or we could convert "
#~ "to a string with "
#~ ":samp:`ffi.string({pointer},{length})`. The "
#~ ":ref:`pickle.unpack() <pickle-unpack>` function "
#~ "might also be helpful."
#~ msgstr ""

#~ msgid ""
#~ "++======================+\n"
#~ "||                      |\n"
#~ "||   0x31: IPROTO_ERROR |\n"
#~ "|| MP_INT: MP_STRING    |\n"
#~ "||                      |\n"
#~ "++======================+\n"
#~ "      MP_MAP"
#~ msgstr ""

#~ msgid ""
#~ "For example, if we try to create"
#~ " a duplicate space with |br| "
#~ "``conn:eval([[box.schema.space.create('_space');]])`` |br| "
#~ "the server response will look like "
#~ "this:"
#~ msgstr ""

#~ msgid ""
#~ "ce 00 00 00 3b                  MP_UINT = HEADER + BODY SIZE\n"
#~ "83                              MP_MAP, size 3 "
#~ "(i.e. 3 items in header)\n"
#~ "  00                              Response-Code-Indicator\n"
#~ "  ce 00 00 80 0a                  MP_UINT = hexadecimal 800a\n"
#~ "  01                              IPROTO_SYNC\n"
#~ "  cf 00 00 00 00 00 00 00 26      MP_UINT = sync value\n"
#~ "  05                              IPROTO_SCHEMA_VERSION\n"
#~ "  ce 00 00 00 78                  MP_UINT = schema version value\n"
#~ "  81                              MP_MAP, size 1\n"
#~ "    31                              IPROTO_ERROR\n"
#~ "    db 00 00 00 1d 53 70 "
#~ "61 63 etc. MP_STR = \"Space "
#~ "'_space' already exists\""
#~ msgstr ""

#~ msgid ""
#~ "Part of the greeting is a "
#~ "base-64-encoded session salt - a random"
#~ " string which can be used for "
#~ "authentication. The length of a decoded"
#~ " salt (44 bytes) exceeds the amount"
#~ " necessary to sign the authentication "
#~ "message (the first 20 bytes). An "
#~ "excess is reserved for future "
#~ "authentication schemas."
#~ msgstr ""
#~ "Когда клиент подключается к экземпляру "
#~ "сервера, экземпляр отвечает 128-байтным "
#~ "текстовым сообщением приветствия. Часть "
#~ "приветствия представляет собой закодированное "
#~ "в формате base-64 значение соль для "
#~ "сессии (случайная строка), которое можно "
#~ "использовать для аутентификации. Длина "
#~ "расшифрованного значения соль (44 байта) "
#~ "выходит за пределы сообщения для "
#~ "аутентификации (первые 20 байтов). Остаток "
#~ "предназначается для будущих схем "
#~ "аутентификации."

#~ msgid ""
#~ "If authentication is not skipped, then"
#~ " at any time an authentication packet"
#~ " can be prepared using the greeting,"
#~ " as follows."
#~ msgstr ""

#~ msgid ""
#~ "PREPARE SCRAMBLE:\n"
#~ "\n"
#~ "    LEN(ENCODED_SALT) = 44;\n"
#~ "    LEN(SCRAMBLE)     = 20;\n"
#~ "\n"
#~ "prepare 'chap-sha1' scramble:\n"
#~ "\n"
#~ "    salt = base64_decode(encoded_salt);\n"
#~ "    step_1 = sha1(password);\n"
#~ "    step_2 = sha1(step_1);\n"
#~ "    step_3 = sha1(salt, step_2);\n"
#~ "    scramble = xor(step_1, step_3);\n"
#~ "    return scramble;\n"
#~ "\n"
#~ "AUTHORIZATION BODY: CODE = IPROTO_AUTH (0x07)\n"
#~ "\n"
#~ "+==========================+====================================+\n"
#~ "|                          |        +-------------+-----------+ |\n"
#~ "|  (KEY)                   | (TUPLE)|  len == 9   | len == 20 | |\n"
#~ "|   0x23: IPROTO_USER_NAME |   0x21:| \"chap-sha1\" |  SCRAMBLE | |\n"
#~ "| MP_INT: MP_STRING        | MP_INT:|  MP_STRING  |  MP_BIN   | |\n"
#~ "|                          |        +-------------+-----------+ |\n"
#~ "|                          |                   MP_ARRAY         |\n"
#~ "+==========================+====================================+\n"
#~ "                        MP_MAP"
#~ msgstr ""

#~ msgid "The DECIMAL type"
#~ msgstr ""

#~ msgid ""
#~ "MessagePack EXT type ``MP_EXT`` together "
#~ "with the extension type ``MP_DECIMAL`` "
#~ "is used as a record header."
#~ msgstr ""

#~ msgid "MP_DECIMAL is 1."
#~ msgstr ""

#~ msgid ""
#~ "`MessagePack spec "
#~ "<https://github.com/MessagePack/MessagePack/blob/master/spec.md"
#~ "#ext-format-family>`_ defines two kinds "
#~ "of types:"
#~ msgstr ""

#~ msgid ""
#~ "``fixext 1/2/4/8/16`` types have fixed "
#~ "length so the length is not "
#~ "encoded explicitly;"
#~ msgstr ""

#~ msgid "``ext 8/16/32`` types require the data length to be encoded."
#~ msgstr ""

#~ msgid "``MP_EXP`` + optional ``length`` imply using one of these types."
#~ msgstr ""

#~ msgid "The decimal MessagePack representation looks like this:"
#~ msgstr ""

#~ msgid ""
#~ "+--------+-------------------+------------+===============+\n"
#~ "| MP_EXT | length (optional) | MP_DECIMAL | PackedDecimal |\n"
#~ "+--------+-------------------+------------+===============+"
#~ msgstr ""

#~ msgid ""
#~ "Here ``length`` is the length of "
#~ "``PackedDecimal`` field, and it is of"
#~ " type ``MP_UINT``, when encoded explicitly"
#~ " (i.e. when the type is ``ext "
#~ "8/16/32``)."
#~ msgstr ""

#~ msgid "``PackedDecimal`` has the following structure:"
#~ msgstr ""

#~ msgid ""
#~ " <--- length bytes -->\n"
#~ "+-------+=============+\n"
#~ "| scale |     BCD     |\n"
#~ "+-------+=============+"
#~ msgstr ""

#~ msgid ""
#~ "Here ``scale`` is either ``MP_INT`` or"
#~ " ``MP_UINT``. |br| ``scale`` = -exponent"
#~ " (exponent negated!)"
#~ msgstr ""

#~ msgid ""
#~ "``BCD`` is a sequence of bytes "
#~ "representing decimal digits of the "
#~ "encoded number (each byte represents two"
#~ " decimal digits each encoded using 4"
#~ " bits), so ``byte >> 4`` is the"
#~ " first digit and ``byte & 0x0f`` "
#~ "is the second digit. The leftmost "
#~ "digit in the array is the most "
#~ "significant. The rightmost digit in the"
#~ " array is the least significant."
#~ msgstr ""

#~ msgid ""
#~ "The first byte of the ``BCD`` "
#~ "array contains the first digit of "
#~ "the number, represented as follows:"
#~ msgstr ""

#~ msgid ""
#~ "|  4 bits           |  4 bits           |\n"
#~ "   = 0x                = the 1st digit"
#~ msgstr ""

#~ msgid ""
#~ "The last byte of the ``BCD`` array"
#~ " contains the last digit of the "
#~ "number and the ``nibble``, represented "
#~ "as follows:"
#~ msgstr ""

#~ msgid ""
#~ "|  4 bits           |  4 bits           |\n"
#~ "   = the last digit    = nibble"
#~ msgstr ""

#~ msgid "The ``nibble`` represents the number's sign:"
#~ msgstr ""

#~ msgid "``0x0a``, ``0x0c``, ``0x0e``, ``0x0f`` stand for plus,"
#~ msgstr ""

#~ msgid "``0x0b`` and ``0x0d`` stand for minus."
#~ msgstr ""

#~ msgid "**Examples**"
#~ msgstr "**Пример:**"

#~ msgid ""
#~ "The decimal ``-12.34`` will be encoded"
#~ " as ``0xd6,0x01,0x02,0x01,0x23,0x4d``:"
#~ msgstr ""

#~ msgid ""
#~ "|MP_EXT (fixext 4) | MP_DECIMAL | scale |  1   |  2,3 |  4 (minus) |\n"
#~ "|       0xd6       |    0x01    | 0x02  | 0x01 | 0x23 | 0x4d       |"
#~ msgstr ""

#~ msgid ""
#~ "The decimal 0.000000000000000000000000000000000010 "
#~ "will be encoded as "
#~ "``0xc7,0x03,0x01,0x24,0x01,0x0c``:"
#~ msgstr ""

#~ msgid ""
#~ "| MP_EXT (ext 8) | length | MP_DECIMAL | scale |  1   | 0 (plus) |\n"
#~ "|      0xc7      |  0x03  |    0x01    | 0x24  | 0x01 | 0x0c     |"
#~ msgstr ""
