
msgid "Replication requests and responses"
msgstr ""

msgid ""
"This section describes internal requests and responses that happen during "
"replication. Each of them is distinguished by the header, containing a "
"unique :ref:`IPROTO_REQUEST_TYPE <internals-iproto-keys-request_type>` "
"value. These values and the corresponding packet body structures are "
"considered below."
msgstr ""

msgid "Connectors and clients do not need to send replication packets."
msgstr ""

msgid "General"
msgstr ""

msgid "Name"
msgstr ""

msgid "Code"
msgstr ""

msgid "Description"
msgstr ""

msgid ":ref:`IPROTO_JOIN <box_protocol-join>`"
msgstr ""

msgid "0x41"
msgstr ""

msgid "Request to join a replica set"
msgstr ""

msgid ":ref:`IPROTO_SUBSCRIBE <internals-iproto-replication-subscribe>`"
msgstr ""

msgid "0x42"
msgstr ""

msgid "Request to subscribe to a specific node in a replica set"
msgstr ""

msgid ":ref:`IPROTO_VOTE <internals-iproto-replication-vote>`"
msgstr ""

msgid "0x44"
msgstr ""

#, fuzzy
msgid "Request for replication"
msgstr "Репликация"

msgid ":ref:`IPROTO_BALLOT <box_protocol-ballots>`"
msgstr ""

msgid "0x29"
msgstr ""

msgid "Response to IPROTO_VOTE. Used during replica set bootstrap"
msgstr ""

msgid "IPROTO_FETCH_SNAPSHOT"
msgstr ""

msgid "0x45"
msgstr ""

#, fuzzy
msgid ""
"Fetch the master's snapshot and start anonymous replication. See "
":ref:`replication_anon <cfg_replication-replication_anon>`"
msgstr ""
"Значение IPROTO_BALLOT_IS_ANON соответствует значению "
":ref:`box.cfg.replication_anon <cfg_replication-replication_anon>`."

msgid "IPROTO_REGISTER"
msgstr ""

msgid "0x46"
msgstr ""

msgid "Register an anonymous replica so it is not anonymous anymore"
msgstr ""

msgid ""
"The master also sends :ref:`heartbeat <heartbeat>` messages to the replicas."
" The heartbeat message's IPROTO_REQUEST_TYPE is ``0``."
msgstr ""

msgid ""
"Below are details on individual replication requests. For synchronous "
"replication requests, see :ref:`below <internals-iproto-replication-"
"synchronous>`."
msgstr ""

#, fuzzy
msgid "Heartbeats"
msgstr "Контрольные сигналы"

msgid ""
"Once in :ref:`replication_timeout <cfg_replication-replication_timeout>` "
"seconds, a master sends a :ref:`heartbeat <heartbeat>` message to a replica,"
" and the replica sends a response. Both messages' IPROTO_REQUEST_TYPE is "
"IPROTO_OK. IPROTO_TIMESTAMP is a float-64 MP_DOUBLE 8-byte timestamp."
msgstr ""

msgid ""
"Since version 2.11, both messages have an optional field in the body that "
"contains the :ref:`IPROTO_VCLOCK_SYNC <internals-iproto-keys-vclock>` key. "
"The master's heartbeat has no body if the IPROTO_VCLOCK_SYNC key is omitted."
msgstr ""

msgid "The message from master to a replica:"
msgstr ""

msgid "The response from the replica:"
msgstr ""

#, fuzzy
msgid ""
"The tutorial :ref:`Understanding the binary protocol <box_protocol-"
"illustration>` shows actual byte codes of the above heartbeat examples."
msgstr ""
"Далее в разделе :ref:`Примеры <box_protocol-illustration>` будут рассмотрены"
" байт-коды вышеприведенных сообщений контрольного сигнала."

#, fuzzy
msgid "IPROTO_JOIN"
msgstr "IPROTO_JOIN = 0x41"

msgid "Code: 0x41."
msgstr ""

msgid ""
"To join a replica set, an instance must send an initial IPROTO_JOIN request "
"to any node in the replica set:"
msgstr ""

msgid "The node that receives the request does the following in response:"
msgstr ""

msgid "It sends its vclock:"
msgstr ""

msgid ""
"It sends a number of :ref:`INSERT <box_protocol-insert>` requests (with "
"additional LSN and ServerID). In this way, the data is updated on the "
"instance that sent the IPROTO_JOIN request. The instance should not reply to"
" these INSERT requests."
msgstr ""

msgid ""
"It sends the new vclock's MP_MAP in a response similar to the one above and "
"closes the socket."
msgstr ""

#, fuzzy
msgid "IPROTO_SUBSCRIBE"
msgstr "IPROTO_SUBSCRIBE = 0x42"

msgid "Code: 0x42."
msgstr ""

msgid ""
"If :ref:`IPROTO_JOIN <box_protocol-join>` was successful, the initiator "
"instance must send an IPROTO_SUBSCRIBE request to all the nodes listed in "
"its :ref:`box.cfg.replication <cfg_replication-replication>`:"
msgstr ""

msgid ""
"After a successful IPROTO_SUBSCRIBE request, the instance must process every"
" request that could come from other masters. Each master's request includes "
"a vclock pair corresponding to that master -- its instance ID and its LSN, "
"independent from other masters."
msgstr ""

msgid ""
"IPROTO_ID_FILTER (0x51) is an optional key used in the SUBSCRIBE request "
"followed by an array of ids of instances whose rows won't be relayed to the "
"replica. The field is encoded only when the ID list is not empty."
msgstr ""

msgid "IPROTO_VOTE"
msgstr ""

msgid "Code: 0x44."
msgstr ""

msgid ""
"When connecting for replication, an instance sends an IPROTO_VOTE request. "
"It has no body:"
msgstr ""

msgid ""
"IPROTO_VOTE is critical during replica set bootstrap. The response to this "
"request is :ref:`IPROTO_BALLOT <box_protocol-ballots>`."
msgstr ""

#, fuzzy
msgid "IPROTO_BALLOT"
msgstr "Сообщения с идентификатором BALLOT"

msgid "Code: 0x29."
msgstr ""

msgid ""
"This value of IPROTO_REQUEST_TYPE indicates a message sent in response to "
":ref:`IPROTO_VOTE <internals-iproto-replication-vote>` (not to be confused "
"with the key IPROTO_RAFT_VOTE)."
msgstr ""

msgid ""
"IPROTO_BALLOT and IPROTO_VOTE are critical during replica set bootstrap. "
"IPROTO_BALLOT corresponds to a map containing the following fields:"
msgstr ""

msgid ""
"IPROTO_BALLOT_REGISTERED_REPLICA_UUIDS has the MP_ARRAY type. The array "
"contains MP_STR elements."
msgstr ""

msgid "Synchronous"
msgstr ""

msgid ":ref:`IPROTO_RAFT <box_protocol-raft>`"
msgstr ""

msgid "0x1e"
msgstr ""

msgid ""
"Inform that the node changed its :ref:`RAFT status <repl_leader_elect>`"
msgstr ""

msgid ":ref:`IPROTO_RAFT_PROMOTE <internals-iproto-replication-raft_promote>`"
msgstr ""

msgid "0x1f"
msgstr ""

msgid "Wait, then choose new replication leader"
msgstr ""

msgid ":ref:`IPROTO_RAFT_DEMOTE <internals-iproto-replication-raft_demote>`"
msgstr ""

msgid "0x20"
msgstr ""

msgid "Revoke the leader role from the instance"
msgstr ""

msgid ":ref:`IPROTO_RAFT_CONFIRM <box_protocol-raft_confirm>`"
msgstr ""

msgid "0x28"
msgstr ""

msgid ""
"Confirm that the RAFT transactions have achieved quorum and can be committed"
msgstr ""

msgid ":ref:`IPROTO_RAFT_ROLLBACK <box_protocol-raft_rollback>`"
msgstr ""

msgid "Roll back the RAFT transactions because they haven't achieved quorum"
msgstr ""

msgid "IPROTO_RAFT"
msgstr ""

msgid "Code: 0x1e."
msgstr ""

msgid ""
"A node broadcasts the IPROTO_RAFT request to all the replicas connected to "
"it when the RAFT state of the node changes. It can be any actions changing "
"the state, like starting a new election, bumping the term, voting for "
"another node, becoming the leader, and so on."
msgstr ""

msgid ""
"If there should be a response, for example, in case of a vote request to "
"other nodes, the response will also be an IPROTO_RAFT message. In this case,"
" the node should be connected as a replica to another node from which the "
"response is expected because the response is sent via the replication "
"channel. In other words, there should be a full-mesh connection between the "
"nodes."
msgstr ""

msgid ""
"IPROTO_REPLICA_ID is the ID of the replica from which the request came."
msgstr ""

msgid "IPROTO_RAFT_PROMOTE"
msgstr ""

msgid "Code: 0x1f."
msgstr ""

msgid "See :ref:`box.ctl.promote() <box_ctl-promote>`."
msgstr ""

msgid "In the header:"
msgstr ""

msgid "IPROTO_REPLICA_ID is the replica ID of the node that sent the request."
msgstr ""

msgid ""
"IPROTO_LSN is the actual LSN of the promote operation as recorded in the "
"WAL."
msgstr ""

msgid "In the body:"
msgstr ""

msgid ""
"IPROTO_REPLICA_ID is the replica ID of the previous :ref:`synchronous queue "
"owner <box_info_synchro>`."
msgstr ""

msgid ""
"IPROTO_LSN is the LSN of the last operation on the previous synchronous "
"queue owner."
msgstr ""

msgid ""
"IPROTO_TERM is the term in which the node that sent the request becomes the "
"synchronous queue owner. This term corresponds to the value of "
":ref:`box.info.synchro.queue.term <box_info_synchro>` on the instance."
msgstr ""

msgid "IPROTO_RAFT_DEMOTE"
msgstr ""

msgid "Code: 0x20."
msgstr ""

msgid "See :ref:`box.ctl.demote() <box_ctl-demote>`."
msgstr ""

msgid ""
"IPROTO_LSN is the actual LSN of the demote operation as recorded in the WAL."
msgstr ""

msgid ""
"IPROTO_REPLICA_ID is the replica ID of the node that sent the request (same "
"as the value in the header)."
msgstr ""

msgid ""
"IPROTO_LSN is the LSN of the last synchronous transaction recorded in the "
"node's WAL."
msgstr ""

msgid "IPROTO_TERM is the term in which the queue becomes empty."
msgstr ""

msgid "IPROTO_RAFT_CONFIRM"
msgstr ""

msgid "Code: 0x28."
msgstr ""

#, fuzzy
msgid ""
"This message is used in replication connections between Tarantool nodes in "
":ref:`synchronous replication <repl_sync>`. It is not supposed to be used by"
" any client applications in their regular connections."
msgstr ""
"Следующие два сообщения IPROTO используются в соединениях репликации между "
"узлами Tarantool при :ref:`синхронной репликации <repl_sync>`. Эти сообщения"
" не должны использоваться клиентскими приложениями при обычном соединении."

msgid ""
"This message confirms that the transactions that originated from the "
"instance with id = IPROTO_REPLICA_ID (body) have achieved quorum and can be "
"committed, up to and including LSN = IPROTO_LSN (body)."
msgstr ""

msgid "The body is a 2-item map:"
msgstr ""

msgid ""
"IPROTO_REPLICA_ID is the ID of the replica that sends the confirm message."
msgstr ""

msgid "IPROTO_LSN is the LSN of the confirmation action."
msgstr ""

msgid ""
"IPROTO_REPLICA_ID is the ID of the instance from which the transactions "
"originated."
msgstr ""

msgid ""
"IPROTO_LSN is the LSN up to which the transactions should be confirmed."
msgstr ""

msgid ""
"Prior to Tarantool :tarantool-release:`2.10.0`, IPROTO_RAFT_CONFIRM was "
"called IPROTO_CONFIRM."
msgstr ""

msgid "IPROTO_RAFT_ROLLBACK"
msgstr ""

msgid ""
"This message says that the transactions that originated from the instance "
"with id = IPROTO_REPLICA_ID (body) couldn't achieve quorum for some reason "
"and should be rolled back, down to LSN = IPROTO_LSN (body) and including it."
msgstr ""

msgid ""
"IPROTO_REPLICA_ID is the ID of the replica that sends the rollback message."
msgstr ""

msgid "IPROTO_LSN is the LSN of the rollback action."
msgstr ""

msgid ""
"IPROTO_LSN is the LSN starting with which all pending synchronous "
"transactions should be rolled back."
msgstr ""

msgid ""
"Prior to Tarantool :tarantool-release:`2.10.0`, IPROTO_RAFT_ROLLBACK was "
"called IPROTO_ROLLBACK."
msgstr ""

#~ msgid ""
#~ "IPROTO_JOIN = 0x41 -- for replication\n"
#~ "IPROTO_SUBSCRIBE = 0x42 -- for replication SUBSCRIBE\n"
#~ "IPROTO_VOTE_DEPRECATED = 0x43 -- for old style vote, superseded by IPROTO_VOTE\n"
#~ "IPROTO_VOTE = 0x44 -- for master election\n"
#~ "IPROTO_FETCH_SNAPSHOT = 0x45 -- for starting anonymous replication\n"
#~ "IPROTO_REGISTER = 0x46 -- for leaving anonymous replication."
#~ msgstr ""
#~ "IPROTO_JOIN = 0x41 — для репликации\n"
#~ "IPROTO_SUBSCRIBE = 0x42 — для репликации SUBSCRIBE\n"
#~ "IPROTO_VOTE_DEPRECATED = 0x43 — для устаревшего типа голосования, взамен используется IPROTO_VOTE\n"
#~ "IPROTO_VOTE = 0x44 — для выбора мастера\n"
#~ "IPROTO_FETCH_SNAPSHOT = 0x45 — для начала анонимной репликации\n"
#~ "IPROTO_REGISTER = 0x46 — для выхода из анонимной репликации"

#~ msgid ""
#~ "Tarantool constants 0x41 to 0x46 (decimal 65 to 70) are for replication. "
#~ "Connectors and clients do not need to send replication packets. See "
#~ ":ref:`Binary protocol -- replication <box_protocol-replication>`."
#~ msgstr ""
#~ "Константы Tarantool 0x41–0x46 (в десятичной системе 65-70) предназначены для"
#~ " репликации. Коннекторы и клиенты не должны отправлять репликационные "
#~ "пакеты. См. раздел о :ref:`репликации <box_protocol-replication>`."

#~ msgid "First you must send an initial IPROTO_JOIN request."
#~ msgstr "Сначала нужно отправить запрос IPROTO_JOIN."

#~ msgid ""
#~ "# <size>\n"
#~ "msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
#~ "# <header>\n"
#~ "msgpack({\n"
#~ "    IPROTO_REQUEST_TYPE: IPROTO_JOIN,\n"
#~ "    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`\n"
#~ "})\n"
#~ "# <body>\n"
#~ "msgpack({\n"
#~ "    IPROTO_INSTANCE_UUID: :samp:`{{uuid}}`\n"
#~ "})"
#~ msgstr ""
#~ "# <size>\n"
#~ "msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
#~ "# <header>\n"
#~ "msgpack({\n"
#~ "    IPROTO_REQUEST_TYPE: IPROTO_JOIN,\n"
#~ "    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`\n"
#~ "})\n"
#~ "# <body>\n"
#~ "msgpack({\n"
#~ "    IPROTO_INSTANCE_UUID: :samp:`{{uuid}}`\n"
#~ "})"

#~ msgid ""
#~ "Then the instance which you want to connect to will send its last SNAP file,"
#~ " by simply creating a number of INSERTs (with additional LSN and ServerID) "
#~ "(do not reply to this). Then that instance will send a vclock's MP_MAP and "
#~ "close a socket."
#~ msgstr ""
#~ "Затем экземпляр, к которому вы хотите подключиться, отправит свой последний "
#~ "SNAP-файл, просто создав несколько запросов типа INSERT (с дополнительными "
#~ "LSN и ServerID) (не отвечайте на них). Затем этот экземпляр отправит MP_MAP "
#~ "vclock и закроет сокет."

#~ msgid ""
#~ "# <size>\n"
#~ "msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
#~ "# <header>\n"
#~ "msgpack({\n"
#~ "    Response-Code-Indicator: 0,\n"
#~ "    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`\n"
#~ "})\n"
#~ "# <body>\n"
#~ "msgpack({\n"
#~ "    IPROTO_VCLOCK: :samp:`{{MP_INT SRV_ID, MP_INT SRV_LSN}}`\n"
#~ "})"
#~ msgstr ""
#~ "# <size>\n"
#~ "msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
#~ "# <header>\n"
#~ "msgpack({\n"
#~ "    Response-Code-Indicator: 0,\n"
#~ "    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`\n"
#~ "})\n"
#~ "# <body>\n"
#~ "msgpack({\n"
#~ "    IPROTO_VCLOCK: :samp:`{{MP_INT SRV_ID, MP_INT SRV_LSN}}`\n"
#~ "})"

#~ msgid "Then you must send an IPROTO_SUBSCRIBE request."
#~ msgstr "Теперь нужно отправить запрос IPROTO_SUBSCRIBE."

#~ msgid ""
#~ "# <size>\n"
#~ "msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
#~ "# <header>\n"
#~ "msgpack({\n"
#~ "    IPROTO_REQUEST_TYPE: IPROTO_SUBSCRIBE,\n"
#~ "    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`,\n"
#~ "    IPROTO_INSTANCE_UUID: :samp:`{{uuid}}`,\n"
#~ "    IPROTO_CLUSTER_UUID: :samp:`{{uuid}}`,\n"
#~ "})\n"
#~ "# <body>\n"
#~ "msgpack({\n"
#~ "    IPROTO_VCLOCK: :samp:`{{MP_INT SRV_ID, MP_INT SRV_LSN}}`\n"
#~ "})"
#~ msgstr ""
#~ "# <size>\n"
#~ "msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
#~ "# <header>\n"
#~ "msgpack({\n"
#~ "    IPROTO_REQUEST_TYPE: IPROTO_SUBSCRIBE,\n"
#~ "    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`,\n"
#~ "    IPROTO_INSTANCE_UUID: :samp:`{{uuid}}`,\n"
#~ "    IPROTO_CLUSTER_UUID: :samp:`{{uuid}}`,\n"
#~ "})\n"
#~ "# <body>\n"
#~ "msgpack({\n"
#~ "    IPROTO_VCLOCK: :samp:`{{MP_INT SRV_ID, MP_INT SRV_LSN}}`\n"
#~ "})"

#~ msgid ""
#~ "Then you must process every request that could come through other masters. "
#~ "Every request between masters will have additional LSN and SERVER_ID."
#~ msgstr ""
#~ "Затем нужно обработать каждый запрос, который может прийти через других "
#~ "мастеров. В каждом запросе между мастерами будут дополнительные LSN и "
#~ "SERVER_ID."

#~ msgid ""
#~ "Frequently a master sends a :ref:`heartbeat <heartbeat>` message to a "
#~ "replica. For example, if there is a replica with id = 2, and a timestamp "
#~ "with a moment in 2020, a master might send this:"
#~ msgstr ""
#~ "Часто мастер отправляет реплике сообщение :ref:`контрольного сигнала "
#~ "<heartbeat>`. Например, если есть реплика с ID = 2 и метка с моментом "
#~ "времени в 2020 году, мастер может послать такое сообщение:"

#~ msgid ""
#~ "# <header>\n"
#~ "msgpack({\n"
#~ "    IPROTO_REQUEST_TYPE: 0\n"
#~ "    IPROTO_REPLICA_ID: 2\n"
#~ "    IPROTO_TIMESTAMP: :samp:`{{Float 64 MP_DOUBLE 8-byte timestamp}}`\n"
#~ "})"
#~ msgstr ""
#~ "# <header>\n"
#~ "msgpack({\n"
#~ "    IPROTO_REQUEST_TYPE: 0\n"
#~ "    IPROTO_REPLICA_ID: 2\n"
#~ "    IPROTO_TIMESTAMP: :samp:`{{Float 64 MP_DOUBLE 8-byte timestamp}}`\n"
#~ "})"

#~ msgid "and the replica might send back this:"
#~ msgstr "и реплика может отправить в ответ следующее:"

#~ msgid ""
#~ "# <header>\n"
#~ "msgpack({\n"
#~ "    Response-Code-Indicator: IPROTO_OK\n"
#~ "    IPROTO_REPLICA_ID: 2\n"
#~ "    IPROTO_VCLOCK: {1, 6}\n"
#~ "})"
#~ msgstr ""
#~ "# <header>\n"
#~ "msgpack({\n"
#~ "    Response-Code-Indicator: IPROTO_OK\n"
#~ "    IPROTO_REPLICA_ID: 2\n"
#~ "    IPROTO_VCLOCK: {1, 6}\n"
#~ "})"

#~ msgid ""
#~ "While connecting for replication, an instance sends a request with header "
#~ "IPROTO_VOTE (0x44). The normal response is ER_OK,and IPROTO_BALLOT (0x29). "
#~ "The fields within IPROTO_BALLOT are map items:"
#~ msgstr ""
#~ "При подключении для репликации экземпляр отправляет запрос с заголовком "
#~ "IPROTO_VOTE (0x44). Обычно ответом будет ER_OK и IPROTO_BALLOT (0x29). Поля "
#~ "в IPROTO_BALLOT — это элементы ассоциативного массива:"

#~ msgid ""
#~ "IPROTO_BALLOT_IS_RO_CFG (0x01) + MP_BOOL\n"
#~ "IPROTO_BALLOT_VCLOCK (0x02) + vclock\n"
#~ "IPROTO_BALLOT_GC_VCLOCK (0x03) + vclock\n"
#~ "IPROTO_BALLOT_IS_RO (0x04) + MP_BOOL\n"
#~ "IPROTO_BALLOT_IS_ANON = 0x05 + MP_BOOL\n"
#~ "IPROTO_BALLOT_IS_BOOTED = 0x06 + MP_BOOL\n"
#~ "IPROTO_BALLOT_CAN_LEAD = 0x07 + MP_BOOL"
#~ msgstr ""

#~ msgid ""
#~ "IPROTO_BALLOT_IS_RO_CFG and IPRO_BALLOT_VCLOCK and IPROTO_BALLOT_GC_VCLOCK "
#~ "and IPROTO_BALLOT_IS_RO were added in version :doc:`2.6.1 </release/2.6.1>`."
#~ " IPROTO_BALLOT_IS_ANON was added in version :doc:`2.7.1 </release/2.7.1>`. "
#~ "IPROTO_BALLOT_IS_BOOTED was added in version 2.7.3 and 2.8.2 and 2.9.1. "
#~ "There have been some name changes starting with version 2.7.3 and 2.8.2 and "
#~ "2.9.1: IPROTO_BALLOT_IS_RO_CFG was formerly called IPROTO_BALLOT_IS_RO, and "
#~ "IPROTO_BALLOT_IS_RO was formerly called IPROTO_BALLOT_IS_LOADING."
#~ msgstr ""
#~ "IPROTO_BALLOT_IS_RO_CFG, IPRO_BALLOT_VCLOCK, IPROTO_BALLOT_GC_VCLOCK и "
#~ "IPROTO_BALLOT_IS_RO добавлены в версии :doc:`2.6.1 </release/2.6.1>`. "
#~ "Константа IPROTO_BALLOT_IS_ANON добавлена в версии :doc:`2.7.1 "
#~ "</release/2.7.1>`. Константа IPROTO_BALLOT_IS_BOOTED добавлена в версиях "
#~ "2.7.3, 2.8.2 и 2.9.1. В версиях 2.7.3, 2.8.2, 2.9.1 и более поздних "
#~ "константа IPROTO_BALLOT_IS_RO переименована в IPROTO_BALLOT_IS_RO_CFG, а "
#~ "IPROTO_BALLOT_IS_LOADING — в IPROTO_BALLOT_IS_RO."

#~ msgid ""
#~ "IPROTO_BALLOT_IS_RO_CFG corresponds to :ref:`box.cfg.read_only <cfg_basic-"
#~ "read_only>`."
#~ msgstr ""
#~ "Значение IPROTO_BALLOT_IS_RO_CFG соответствует значению "
#~ ":ref:`box.cfg.read_only <cfg_basic-read_only>`."

#~ msgid ""
#~ "IPROTO_BALLOT_GC_VCLOCK can be the vclock value of the instance's oldest WAL"
#~ " entry, which corresponds to :ref:`box.info.gc().vclock <box_info_gc>`."
#~ msgstr ""
#~ "IPROTO_BALLOT_GC_VCLOCK может принимать значение vclock самой старой записи "
#~ "журнала WAL на экземпляре. Это соответствует значению "
#~ ":ref:`box.info.gc().vclock <box_info_gc>`."

#~ msgid ""
#~ "IPROTO_BALLOT_IS_RO is true if the instance is not writable, which may "
#~ "happen for a variety of reasons, such as: it was configured as "
#~ ":ref:`read_only <cfg_basic-read_only>`, or it has :ref:`orphan status "
#~ "<replication-orphan_status>`, or it is a :ref:`Raft <repl_leader_elect>` "
#~ "follower."
#~ msgstr ""
#~ "IPROTO_BALLOT_IS_RO принимает значение ``true``, если экземпляр недоступен "
#~ "для записи. Причины у этого могут быть разные: например, экземпляр настроен "
#~ "как :ref:`read_only <cfg_basic-read_only>`, :ref:`имеет статус orphan "
#~ "<replication-orphan_status>` или является последователем (follower) при "
#~ ":ref:`выполнении алгоритма Raft <repl_leader_elect>`."

#~ msgid ""
#~ "IPROTO_BALLOT_IS_BOOTED is true if the instance has finished its bootstrap "
#~ "or recovery process."
#~ msgstr ""
#~ "IPROTO_BALLOT_IS_BOOTED принимает значение ``true``, если экземпляр завершил"
#~ " инициализацию или восстановление."

#~ msgid ""
#~ "IPROTO_BALLOT_CAN_LEAD is true if the :ref:`election_mode <cfg_replication-"
#~ "election_mode>` configuration setting is either 'candidate' or 'manual', so "
#~ "that during the :ref:`leader election process <repl_leader_elect_process>` "
#~ "this instance may be preferred over instances whose configuration setting is"
#~ " 'voter'. IPROTO_BALLOT_CAN_LEAD support was added simultaneously in version"
#~ " :doc:`2.7.3 </release/2.7.3>` and version :doc:`2.8.2 </release/2.8.2>`."
#~ msgstr ""

#~ msgid "FLAGS"
#~ msgstr "Сообщения с идентификатором FLAG"

#~ msgid ""
#~ "For replication of :doc:`synchronous transactions "
#~ "</book/replication/repl_sync>` a header may contain a key = IPROTO_FLAGS and"
#~ " an MP_UINT value = one or more bits: IPROTO_FLAG_COMMIT or "
#~ "IPROTO_FLAG_WAIT_SYNC or IPROTO_FLAG_WAIT_ACK."
#~ msgstr ""
#~ "При репликации :doc:`синхронных транзакций </book/replication/repl_sync>` "
#~ "заголовок может содержать ключ = IPROTO_FLAGS и значение MP_UINT = один или "
#~ "несколько битов: IPROTO_FLAG_COMMIT, IPROTO_FLAG_WAIT_SYNC или "
#~ "IPROTO_FLAG_WAIT_ACK."

#~ msgid ""
#~ "# <size>\n"
#~ "msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
#~ "# <header>\n"
#~ "msgpack({\n"
#~ "    # ... other header items ...,\n"
#~ "    IPROTO_FLAGS: :samp:`{{MP_UINT unsigned integer}}`\n"
#~ "})\n"
#~ "# <body>\n"
#~ "msgpack({\n"
#~ "    # ... message for a transaction ...\n"
#~ "})"
#~ msgstr ""
#~ "# <size>\n"
#~ "msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
#~ "# <header>\n"
#~ "msgpack({\n"
#~ "    # ... другие элементы заголовка ...,\n"
#~ "    IPROTO_FLAGS: :samp:`{{MP_UINT unsigned integer}}`\n"
#~ "})\n"
#~ "# <body>\n"
#~ "msgpack({\n"
#~ "    # ... message for a transaction ...\n"
#~ "})"

#~ msgid ""
#~ "IPROTO_FLAG_COMMIT (0x01) will be set if this is the last message for a "
#~ "transaction, IPROTO_FLAG_WAIT_SYNC (0x02) will be set if this is the last "
#~ "message for a transaction which cannot be completed immediately, "
#~ "IPROTO_FLAG_WAIT_ACK (0x04) will be set if this is the last message for a "
#~ "synchronous transaction."
#~ msgstr ""
#~ "IPROTO_FLAG_COMMIT (0x01) указывает на последнее сообщение для транзакции. "
#~ "IPROTO_FLAG_WAIT_SYNC (0x02) указывает на последнее сообщение для "
#~ "транзакции, которую нельзя завершить немедленно. IPROTO_FLAG_WAIT_ACK (0x04)"
#~ " указывает на последнее сообщение для синхронной транзакции."
