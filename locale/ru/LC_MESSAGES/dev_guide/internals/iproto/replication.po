
msgid "Replication"
msgstr "Репликация"


msgid ""
"IPROTO_JOIN = 0x41 -- for replication\n"
"IPROTO_SUBSCRIBE = 0x42 -- for replication SUBSCRIBE\n"
"IPROTO_VOTE_DEPRECATED = 0x43 -- for old style vote, superseded by IPROTO_VOTE\n"
"IPROTO_VOTE = 0x44 -- for master election\n"
"IPROTO_FETCH_SNAPSHOT = 0x45 -- for starting anonymous replication\n"
"IPROTO_REGISTER = 0x46 -- for leaving anonymous replication."
msgstr ""
"IPROTO_JOIN = 0x41 — для репликации\n"
"IPROTO_SUBSCRIBE = 0x42 — для репликации SUBSCRIBE\n"
"IPROTO_VOTE_DEPRECATED = 0x43 — для устаревшего типа голосования, взамен используется IPROTO_VOTE\n"
"IPROTO_VOTE = 0x44 — для выбора мастера\n"
"IPROTO_FETCH_SNAPSHOT = 0x45 — для начала анонимной репликации\n"
"IPROTO_REGISTER = 0x46 — для выхода из анонимной репликации"

msgid ""
"Tarantool constants 0x41 to 0x46 (decimal 65 to 70) are for replication. "
"Connectors and clients do not need to send replication packets. See "
":ref:`Binary protocol -- replication <box_protocol-replication>`."
msgstr ""
"Константы Tarantool 0x41–0x46 (в десятичной системе 65-70) предназначены для"
" репликации. Коннекторы и клиенты не должны отправлять репликационные "
"пакеты. См. раздел о :ref:`репликации <box_protocol-replication>`."

msgid ""
"The next two IPROTO messages are used in replication connections between "
"Tarantool nodes in :ref:`synchronous replication <repl_sync>`. The messages "
"are not supposed to be used by any client applications in their regular "
"connections."
msgstr ""
"Следующие два сообщения IPROTO используются в соединениях репликации между "
"узлами Tarantool при :ref:`синхронной репликации <repl_sync>`. Эти сообщения"
" не должны использоваться клиентскими приложениями при обычном соединении."


msgid "IPROTO_JOIN = 0x41"
msgstr "IPROTO_JOIN = 0x41"

msgid "First you must send an initial IPROTO_JOIN request."
msgstr "Сначала нужно отправить запрос IPROTO_JOIN."

msgid ""
"# <size>\n"
"msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
"# <header>\n"
"msgpack({\n"
"    IPROTO_REQUEST_TYPE: IPROTO_JOIN,\n"
"    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_INSTANCE_UUID: :samp:`{{uuid}}`\n"
"})"
msgstr ""
"# <size>\n"
"msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
"# <header>\n"
"msgpack({\n"
"    IPROTO_REQUEST_TYPE: IPROTO_JOIN,\n"
"    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_INSTANCE_UUID: :samp:`{{uuid}}`\n"
"})"

msgid ""
"Then the instance which you want to connect to will send its last SNAP file,"
" by simply creating a number of INSERTs (with additional LSN and ServerID) "
"(do not reply to this). Then that instance will send a vclock's MP_MAP and "
"close a socket."
msgstr ""
"Затем экземпляр, к которому вы хотите подключиться, отправит свой последний "
"SNAP-файл, просто создав несколько запросов типа INSERT (с дополнительными "
"LSN и ServerID) (не отвечайте на них). Затем этот экземпляр отправит MP_MAP "
"vclock и закроет сокет."

msgid ""
"# <size>\n"
"msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
"# <header>\n"
"msgpack({\n"
"    Response-Code-Indicator: 0,\n"
"    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_VCLOCK: :samp:`{{MP_INT SRV_ID, MP_INT SRV_LSN}}`\n"
"})"
msgstr ""
"# <size>\n"
"msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
"# <header>\n"
"msgpack({\n"
"    Response-Code-Indicator: 0,\n"
"    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_VCLOCK: :samp:`{{MP_INT SRV_ID, MP_INT SRV_LSN}}`\n"
"})"

msgid "IPROTO_SUBSCRIBE = 0x42"
msgstr "IPROTO_SUBSCRIBE = 0x42"

msgid "Then you must send an IPROTO_SUBSCRIBE request."
msgstr "Теперь нужно отправить запрос IPROTO_SUBSCRIBE."

msgid ""
"# <size>\n"
"msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
"# <header>\n"
"msgpack({\n"
"    IPROTO_REQUEST_TYPE: IPROTO_SUBSCRIBE,\n"
"    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`,\n"
"    IPROTO_INSTANCE_UUID: :samp:`{{uuid}}`,\n"
"    IPROTO_CLUSTER_UUID: :samp:`{{uuid}}`,\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_VCLOCK: :samp:`{{MP_INT SRV_ID, MP_INT SRV_LSN}}`\n"
"})"
msgstr ""
"# <size>\n"
"msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
"# <header>\n"
"msgpack({\n"
"    IPROTO_REQUEST_TYPE: IPROTO_SUBSCRIBE,\n"
"    IPROTO_SYNC: :samp:`{{MP_UINT unsigned integer}}`,\n"
"    IPROTO_INSTANCE_UUID: :samp:`{{uuid}}`,\n"
"    IPROTO_CLUSTER_UUID: :samp:`{{uuid}}`,\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    IPROTO_VCLOCK: :samp:`{{MP_INT SRV_ID, MP_INT SRV_LSN}}`\n"
"})"

msgid ""
"Then you must process every request that could come through other masters. "
"Every request between masters will have additional LSN and SERVER_ID."
msgstr ""
"Затем нужно обработать каждый запрос, который может прийти через других "
"мастеров. В каждом запросе между мастерами будут дополнительные LSN и "
"SERVER_ID."

msgid "HEARTBEATS"
msgstr "Контрольные сигналы"

msgid ""
"Frequently a master sends a :ref:`heartbeat <heartbeat>` message to a "
"replica. For example, if there is a replica with id = 2, and a timestamp "
"with a moment in 2020, a master might send this:"
msgstr ""
"Часто мастер отправляет реплике сообщение :ref:`контрольного сигнала "
"<heartbeat>`. Например, если есть реплика с ID = 2 и метка с моментом "
"времени в 2020 году, мастер может послать такое сообщение:"

msgid ""
"# <header>\n"
"msgpack({\n"
"    IPROTO_REQUEST_TYPE: 0\n"
"    IPROTO_REPLICA_ID: 2\n"
"    IPROTO_TIMESTAMP: :samp:`{{Float 64 MP_DOUBLE 8-byte timestamp}}`\n"
"})"
msgstr ""
"# <header>\n"
"msgpack({\n"
"    IPROTO_REQUEST_TYPE: 0\n"
"    IPROTO_REPLICA_ID: 2\n"
"    IPROTO_TIMESTAMP: :samp:`{{Float 64 MP_DOUBLE 8-byte timestamp}}`\n"
"})"

msgid "and the replica might send back this:"
msgstr "и реплика может отправить в ответ следующее:"

msgid ""
"# <header>\n"
"msgpack({\n"
"    Response-Code-Indicator: IPROTO_OK\n"
"    IPROTO_REPLICA_ID: 2\n"
"    IPROTO_VCLOCK: {1, 6}\n"
"})"
msgstr ""
"# <header>\n"
"msgpack({\n"
"    Response-Code-Indicator: IPROTO_OK\n"
"    IPROTO_REPLICA_ID: 2\n"
"    IPROTO_VCLOCK: {1, 6}\n"
"})"

msgid ""
"Later in :ref:`Binary protocol -- illustration <box_protocol-illustration>` "
"we will show actual byte codes of the above heartbeat examples."
msgstr ""
"Далее в разделе :ref:`Примеры <box_protocol-illustration>` будут рассмотрены"
" байт-коды вышеприведенных сообщений контрольного сигнала."

msgid "BALLOTS"
msgstr "Сообщения с идентификатором BALLOT"

msgid ""
"While connecting for replication, an instance sends a request with header "
"IPROTO_VOTE (0x44). The normal response is ER_OK,and IPROTO_BALLOT (0x29). "
"The fields within IPROTO_BALLOT are map items:"
msgstr ""
"При подключении для репликации экземпляр отправляет запрос с заголовком "
"IPROTO_VOTE (0x44). Обычно ответом будет ER_OK и IPROTO_BALLOT (0x29). Поля "
"в IPROTO_BALLOT — это элементы ассоциативного массива:"

msgid ""
"IPROTO_BALLOT_IS_RO_CFG (0x01) + MP_BOOL\n"
"IPROTO_BALLOT_VCLOCK (0x02) + vclock\n"
"IPROTO_BALLOT_GC_VCLOCK (0x03) + vclock\n"
"IPROTO_BALLOT_IS_RO (0x04) + MP_BOOL\n"
"IPROTO_BALLOT_IS_ANON = 0x05 + MP_BOOL\n"
"IPROTO_BALLOT_IS_BOOTED = 0x06 + MP_BOOL\n"
"IPROTO_BALLOT_CAN_LEAD = 0x07 + MP_BOOL"
msgstr ""

msgid ""
"IPROTO_BALLOT_IS_RO_CFG and IPRO_BALLOT_VCLOCK and IPROTO_BALLOT_GC_VCLOCK "
"and IPROTO_BALLOT_IS_RO were added in version :doc:`2.6.1 </release/2.6.1>`."
" IPROTO_BALLOT_IS_ANON was added in version :doc:`2.7.1 </release/2.7.1>`. "
"IPROTO_BALLOT_IS_BOOTED was added in version 2.7.3 and 2.8.2 and 2.9.1. "
"There have been some name changes starting with version 2.7.3 and 2.8.2 and "
"2.9.1: IPROTO_BALLOT_IS_RO_CFG was formerly called IPROTO_BALLOT_IS_RO, and "
"IPROTO_BALLOT_IS_RO was formerly called IPROTO_BALLOT_IS_LOADING."
msgstr ""
"IPROTO_BALLOT_IS_RO_CFG, IPRO_BALLOT_VCLOCK, IPROTO_BALLOT_GC_VCLOCK и "
"IPROTO_BALLOT_IS_RO добавлены в версии :doc:`2.6.1 </release/2.6.1>`. "
"Константа IPROTO_BALLOT_IS_ANON добавлена в версии :doc:`2.7.1 "
"</release/2.7.1>`. Константа IPROTO_BALLOT_IS_BOOTED добавлена в версиях "
"2.7.3, 2.8.2 и 2.9.1. В версиях 2.7.3, 2.8.2, 2.9.1 и более поздних "
"константа IPROTO_BALLOT_IS_RO переименована в IPROTO_BALLOT_IS_RO_CFG, а "
"IPROTO_BALLOT_IS_LOADING — в IPROTO_BALLOT_IS_RO."

msgid ""
"IPROTO_BALLOT_IS_RO_CFG corresponds to :ref:`box.cfg.read_only <cfg_basic-"
"read_only>`."
msgstr ""
"Значение IPROTO_BALLOT_IS_RO_CFG соответствует значению "
":ref:`box.cfg.read_only <cfg_basic-read_only>`."

msgid ""
"IPROTO_BALLOT_GC_VCLOCK can be the vclock value of the instance's oldest WAL"
" entry, which corresponds to :ref:`box.info.gc().vclock <box_info_gc>`."
msgstr ""
"IPROTO_BALLOT_GC_VCLOCK может принимать значение vclock самой старой записи "
"журнала WAL на экземпляре. Это соответствует значению "
":ref:`box.info.gc().vclock <box_info_gc>`."

msgid ""
"IPROTO_BALLOT_IS_RO is true if the instance is not writable, which may "
"happen for a variety of reasons, such as: it was configured as "
":ref:`read_only <cfg_basic-read_only>`, or it has :ref:`orphan status "
"<replication-orphan_status>`, or it is a :ref:`Raft <repl_leader_elect>` "
"follower."
msgstr ""
"IPROTO_BALLOT_IS_RO принимает значение ``true``, если экземпляр недоступен "
"для записи. Причины у этого могут быть разные: например, экземпляр настроен "
"как :ref:`read_only <cfg_basic-read_only>`, :ref:`имеет статус orphan "
"<replication-orphan_status>` или является последователем (follower) при "
":ref:`выполнении алгоритма Raft <repl_leader_elect>`."

msgid ""
"IPROTO_BALLOT_IS_ANON corresponds to :ref:`box.cfg.replication_anon "
"<cfg_replication-replication_anon>`."
msgstr ""
"Значение IPROTO_BALLOT_IS_ANON соответствует значению "
":ref:`box.cfg.replication_anon <cfg_replication-replication_anon>`."

msgid ""
"IPROTO_BALLOT_IS_BOOTED is true if the instance has finished its bootstrap "
"or recovery process."
msgstr ""
"IPROTO_BALLOT_IS_BOOTED принимает значение ``true``, если экземпляр завершил"
" инициализацию или восстановление."

msgid ""
"IPROTO_BALLOT_CAN_LEAD is true if the :ref:`election_mode <cfg_replication-"
"election_mode>` configuration setting is either 'candidate' or 'manual', so "
"that during the :ref:`leader election process <repl_leader_elect_process>` "
"this instance may be preferred over instances whose configuration setting is"
" 'voter'. IPROTO_BALLOT_CAN_LEAD support was added simultaneously in version"
" :doc:`2.7.3 </release/2.7.3>` and version :doc:`2.8.2 </release/2.8.2>`."
msgstr ""

msgid "FLAGS"
msgstr "Сообщения с идентификатором FLAG"

msgid ""
"For replication of :doc:`synchronous transactions "
"</book/replication/repl_sync>` a header may contain a key = IPROTO_FLAGS and"
" an MP_UINT value = one or more bits: IPROTO_FLAG_COMMIT or "
"IPROTO_FLAG_WAIT_SYNC or IPROTO_FLAG_WAIT_ACK."
msgstr ""
"При репликации :doc:`синхронных транзакций </book/replication/repl_sync>` "
"заголовок может содержать ключ = IPROTO_FLAGS и значение MP_UINT = один или "
"несколько битов: IPROTO_FLAG_COMMIT, IPROTO_FLAG_WAIT_SYNC или "
"IPROTO_FLAG_WAIT_ACK."

msgid ""
"# <size>\n"
"msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
"# <header>\n"
"msgpack({\n"
"    # ... other header items ...,\n"
"    IPROTO_FLAGS: :samp:`{{MP_UINT unsigned integer}}`\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    # ... message for a transaction ...\n"
"})"
msgstr ""
"# <size>\n"
"msgpack(:samp:`{{MP_UINT unsigned integer = size(<header>) + size(<body>)}}`)\n"
"# <header>\n"
"msgpack({\n"
"    # ... другие элементы заголовка ...,\n"
"    IPROTO_FLAGS: :samp:`{{MP_UINT unsigned integer}}`\n"
"})\n"
"# <body>\n"
"msgpack({\n"
"    # ... message for a transaction ...\n"
"})"

msgid ""
"IPROTO_FLAG_COMMIT (0x01) will be set if this is the last message for a "
"transaction, IPROTO_FLAG_WAIT_SYNC (0x02) will be set if this is the last "
"message for a transaction which cannot be completed immediately, "
"IPROTO_FLAG_WAIT_ACK (0x04) will be set if this is the last message for a "
"synchronous transaction."
msgstr ""
"IPROTO_FLAG_COMMIT (0x01) указывает на последнее сообщение для транзакции. "
"IPROTO_FLAG_WAIT_SYNC (0x02) указывает на последнее сообщение для "
"транзакции, которую нельзя завершить немедленно. IPROTO_FLAG_WAIT_ACK (0x04)"
" указывает на последнее сообщение для синхронной транзакции."
