
msgid "MessagePack extensions"
msgstr "Дополнительные типы MessagePack"

msgid ""
"Tarantool uses predefined MessagePack extension types to represent some of "
"the special values. Extension types include ``MP_DECIMAL``, ``MP_UUID``, "
"``MP_ERROR``, ``MP_DATETIME``, and ``MP_INTERVAL``. "
"These types require special attention from the connector "
"developers, as they must be treated separately from the default MessagePack "
"types, and correctly mapped to programming language types."
msgstr ""
"Tarantool использует предопределенные дополнительные типы MessagePack для "
"представления некоторых специальных значений. Дополнительные типы включают "
"``MP_DECIMAL``, ``MP_UUID``,``MP_ERROR``, ``MP_DATETIME``, and ``MP_INTERVAL``. "
"Эти типы требуют особого внимания со стороны разработчиков коннекторов, так как должны "
"рассматриваться отдельно от типов MessagePack по умолчанию и корректно "
"приводиться к типам языков программирования."

msgid "The DECIMAL type"
msgstr "Тип DECIMAL"

msgid ""
"The MessagePack EXT type ``MP_EXT`` together with the extension type "
"``MP_DECIMAL`` is a header for values of the DECIMAL type."
msgstr ""
"Тип MessagePack EXT ``MP_EXT`` вместе с типом расширения ``MP_DECIMAL`` "
"является заголовком для значений типа DECIMAL."

msgid "``MP_DECIMAL`` type is 1."
msgstr "MP_DECIMAL -- это 1."

msgid ""
"`MessagePack spec <https://github.com/msgpack/msgpack/blob/master/spec.md>`_"
" defines two kinds of types:"
msgstr ""
"`Спецификация MessagePack "
"<https://github.com/msgpack/msgpack/blob/master/spec.md>`_ определяет два "
"вида типов:"

msgid ""
"``fixext 1/2/4/8/16`` types have fixed length so the length is not encoded "
"explicitly."
msgstr ""
"типы ``fixext 1/2/4/8/16`` имеют фиксированную длину, поэтому длина не "
"кодируется явно;"

msgid "``ext 8/16/32`` types require the data length to be encoded."
msgstr "типы ``ext 8/16/32`` требуют кодирования длины данных."

msgid "``MP_EXP`` + optional ``length`` imply using one of these types."
msgstr ""
"``MP_EXP`` + (не обязательно) ``length`` подразумевает использование одного "
"из этих типов."

msgid "The decimal MessagePack representation looks like this:"
msgstr "Десятичное представление MessagePack выглядит следующим образом:"

msgid ""
"+--------+-------------------+------------+===============+\n"
"| MP_EXT | length (optional) | MP_DECIMAL | PackedDecimal |\n"
"+--------+-------------------+------------+===============+"
msgstr ""

msgid ""
"Here ``length`` is the length of ``PackedDecimal`` field, and it is of type "
"``MP_UINT``, when encoded explicitly (i.e. when the type is ``ext "
"8/16/32``)."
msgstr ""
"Здесь ``length`` -- это длина поля ``PackedDecimal``, и оно имеет тип "
"``MP_UINT``, когда кодируется явно (т.е. когда тип -- ``ext 8/16/32``)."

msgid "``PackedDecimal`` has the following structure:"
msgstr "``PackedDecimal`` имеет следующую структуру:"

msgid ""
" <--- length bytes -->\n"
"+-------+=============+\n"
"| scale |     BCD     |\n"
"+-------+=============+"
msgstr ""
" <--- длина в байтах -->\n"
"+-------+=============+\n"
"| scale |     BCD     |\n"
"+-------+=============+"

msgid ""
"Here ``scale`` is either ``MP_INT`` or ``MP_UINT``. |br| ``scale`` = number "
"of digits after the decimal point"
msgstr ""
"Здесь ``scale`` -- это либо ``MP_INT``, либо ``MP_UINT``. |br| ``scale`` = "
"количество цифр после запятой."

msgid ""
"``BCD`` is a sequence of bytes representing decimal digits of the encoded "
"number (each byte has two decimal digits each encoded using 4-bit "
"``nibbles``), so ``byte >> 4`` is the first digit and ``byte & 0x0f`` is the"
" second digit. The leftmost digit in the array is the most significant. The "
"rightmost digit in the array is the least significant."
msgstr ""
"``BCD`` - это последовательность байтов, обозначающая десятичные цифры "
"кодируемого числа (каждый байт имеет две десятичные цифры, каждая из которых"
" кодируется с использованием 4-битных ``nibbles``), поэтому ``byte >> 4`` - "
"первая цифра, а ``byte & 0x0f`` - вторая цифра. Самая левая цифра в массиве "
"- самая значимая. Самая правая цифра в массиве - наименее значимая."

msgid ""
"The first byte of the ``BCD`` array contains the first digit of the number, "
"represented as follows:"
msgstr ""
"Первый байт ``BCD``-массива содержит первую цифру числа, представленную "
"следующим образом:"

msgid ""
"|  4 bits           |  4 bits           |\n"
"   = 0x                = the 1st digit"
msgstr ""

msgid ""
"(The first ``nibble`` contains 0 if the decimal number has an even number of"
" digits.) The last byte of the ``BCD`` array contains the last digit of the "
"number and the final ``nibble``, represented as follows:"
msgstr ""
"(Первый ``nibble`` содержит 0, если десятичное число имеет четное число "
"цифр). Последний байт BCD-массива содержит последнюю цифру числа и последний"
" ``nibble``, представленный следующим образом:"

msgid ""
"|  4 bits           |  4 bits           |\n"
"   = the last digit    = nibble"
msgstr ""

msgid "The final ``nibble`` represents the number's sign:"
msgstr "Последний ``nibble`` обозначает знак числа:"

msgid "``0x0a``, ``0x0c``, ``0x0e``, ``0x0f`` stand for plus,"
msgstr "``0x0a``, ``0x0c``, ``0x0e``, ``0x0f`` обозначают плюс,"

msgid "``0x0b`` and ``0x0d`` stand for minus."
msgstr "``0x0b`` and ``0x0d`` обозначают минус."

msgid "**Examples**"
msgstr "**Примеры**"

msgid ""
"The decimal ``-12.34`` will be encoded as ``0xd6,0x01,0x02,0x01,0x23,0x4d``:"
msgstr ""
"Десятичное число ``-12.34`` будет закодировано как "
"``0xd6,0x01,0x02,0x01,0x23,0x4d``:"

msgid ""
"|MP_EXT (fixext 4) | MP_DECIMAL | scale |  1   |  2,3 |  4 (minus) |\n"
"|       0xd6       |    0x01    | 0x02  | 0x01 | 0x23 | 0x4d       |"
msgstr ""

msgid ""
"The decimal 0.000000000000000000000000000000000010 will be encoded as "
"``0xc7,0x03,0x01,0x24,0x01,0x0c``:"
msgstr ""
"Десятичное число 0.000000000000000000000000000000000010 будет закодировано "
"как ``0xc7,0x03,0x01,0x24,0x01,0x0c``:"

msgid ""
"| MP_EXT (ext 8) | length | MP_DECIMAL | scale |  1   | 0 (plus) |\n"
"|      0xc7      |  0x03  |    0x01    | 0x24  | 0x01 | 0x0c     |"
msgstr ""

msgid "The UUID type"
msgstr "Тип UUID"

msgid ""
"The MessagePack EXT type ``MP_EXT`` together with the extension type "
"``MP_UUID`` for values of the UUID type. Since version :doc:`2.4.1 "
"</release/2.4.1>`."
msgstr ""

msgid "``MP_UUID`` type is 2."
msgstr "MP_UUID -- это 2."

msgid ""
"The `MessagePack spec "
"<https://github.com/msgpack/msgpack/blob/master/spec.md>`_ defines ``d8`` to"
" mean ``fixext`` with size 16, and a UUID's size is always 16. So the UUID "
"MessagePack representation looks like this:"
msgstr ""
"`Спецификация MessagePack "
"<https://github.com/msgpack/msgpack/blob/master/spec.md>`_ определяет ``d8``"
" как ``fixext`` с размером 16, а размер ``UUID`` всегда равен 16. Таким "
"образом, представление ``UUID`` в MessagePack выглядит следующим образом:"

msgid ""
"+--------+------------+-----------------+\n"
"| MP_EXT | MP_UUID    | UuidValue       |\n"
"| = d8   | = 2        | = 16-byte value |\n"
"+--------+------------+-----------------+"
msgstr ""

msgid ""
"The 16-byte value has 2 digits per byte. Typically, it consists of 11 fields,"
" which are encoded as big-endian unsigned integers in the following order: "
msgstr ""
"16-байтовое значение имеет 2 цифры на байт. Обычно оно состоит из 11 полей, "
"которые кодируются от большего к меньшему беззнаковыми целыми числами в следующем порядке:"

msgid ""
"time_low (4 bytes)"
msgstr ""
"time_low (4 байта)"

msgid ""
"time_mid (2 bytes)"
msgstr ""
"time_mid (2 байта)"

msgid ""
"time_hi_and_version (2 bytes)"
msgstr ""
"time_hi_and_version (2 байта)"

msgid ""
"clock_seq_hi_and_reserved (1 byte)"
msgstr ""
"clock_seq_hi_and_reserved (1 байт)"

msgid ""
"clock_seq_low (1 byte)"
msgstr ""
"clock_seq_low (1 байт)"

msgid ""
"node[0], ..., node[5] (1 byte each)"
msgstr ""
"node[0], ..., node[5] (по 1 байту)"

msgid ""
"Some of the functions in :ref:`Module uuid <uuid-module>` can produce values"
" which are compatible with the UUID data type. For example, after"
msgstr ""
"Некоторые функции в :ref:`модуле UUID <uuid-module>` могут выдавать "
"значения, совместимые с типом данных UUID. Например, после"

msgid ""
"uuid = require('uuid')\n"
"box.schema.space.create('t')\n"
"box.space.t:create_index('i', {parts={1,'uuid'}})\n"
"box.space.t:insert{uuid.fromstr('f6423bdf-b49e-4913-b361-0740c9702e4b')}\n"
"box.space.t:select()"
msgstr ""

msgid "a peek at the server response packet will show that it contains"
msgstr "пакет ответа сервера покажет, что он содержит"

msgid "d8 02 f6 42 3b df b4 9e 49 13 b3 61 07 40 c9 70 2e 4b"
msgstr ""

msgid "The ERROR type"
msgstr "Тип ERROR"

msgid ""
"Since version :doc:`2.4.1 </release/2.4.1>`, responses for errors have extra"
" information following what was described in :ref:`Box protocol -- responses"
" for errors <box_protocol-responses_error>`. This is a \"compatible\" "
"enhancement, because clients that expect old-style server responses should "
"ignore map components that they do not recognize. Notice, however, that "
"there has been a renaming of a constant: formerly ``IPROTO_ERROR`` in "
":file:`./box/iproto_constants.h` was ``0x31``, now ``IPROTO_ERROR`` is ``0x52`` and "
"``IPROTO_ERROR_24`` is ``0x31``."
msgstr ""
"Начиная с версии :doc:`2.4.1 </release/2.4.1>`, в ответах на ошибки "
"содержится дополнительная информация, соответствующая описанию в разделе "
":ref:`Бинарный протокол — ответы на ошибки <box_protocol-responses_error>`. "
"Это \"совместимое\" улучшение, потому что клиенты, которые ожидают ответы "
"сервера старого образца, должны игнорировать компоненты ассоциативного "
"массива, которые они не распознают. Обратите внимание, что константа "
"``IPROTO_ERROR`` в :file:`./box/iproto_constants.h` была ``0x31``, а теперь ``IPROTO_ERROR`` -- "
"``0x52``, а ``IPROTO_ERROR_24`` -- ``0x31``."

msgid "``MP_ERROR`` type is 3."
msgstr "MP_ERROR -- это 3."

msgid ""
"++=========================+============================+\n"
"||                         |                            |\n"
"||   0x31: IPROTO_ERROR_24 |   0x52: IPROTO_ERROR       |\n"
"|| MP_INT: MP_STRING       | MP_MAP: extra information  |\n"
"||                         |                            |\n"
"++=========================+============================+\n"
"                        MP_MAP"
msgstr ""
"++=========================+============================+\n"
"||                         |                            |\n"
"||   0x31: IPROTO_ERROR_24 |   0x52: IPROTO_ERROR                                 |\n"
"|| MP_INT: MP_STRING       | MP_MAP: дополнительная информация  |\n"
"||                         |                            |\n"
"++=========================+============================+\n"
"                        MP_MAP"

msgid ""
"The extra information, most of which is also in :doc:`error object "
"</reference/reference_lua/box_error/new>` fields, is:"
msgstr ""
"Дополнительная информация, большая часть которой также хранится в полях "
":doc:`объекта ошибки </reference/reference_lua/box_error/new>`:"

msgid ""
"``MP_ERROR_TYPE`` (0x00) (MP_STR) Type that implies source, as in "
":samp:`{error_object}.base_type`, for example \"ClientError\"."
msgstr ""
"``MP_ERROR_TYPE`` (0x00) (MP_STR) Тип, подразумевающий источник, как в "
":samp:`{error_object}.base_type`, например \"ClientError\"."

msgid ""
"``MP_ERROR_FILE`` (0x01) (MP_STR)  Source code file where error was caught, "
"as in :samp:`{error_object}.trace`."
msgstr ""
"``MP_ERROR_FILE`` (0x01) (MP_STR) Файл с исходным кодом, в котором была "
"перехвачена ошибка, как в :samp:`{error_object}.trace`."

msgid ""
"``MP_ERROR_LINE`` (0x02) (MP_UINT) Line number in source code file, as in "
":samp:`{error_object}.trace`."
msgstr ""
"``MP_ERROR_LINE`` (0x02) (MP_UINT) Номер строки в файле исходных кодов, как "
"в :samp:`{error_object}.trace`."

msgid ""
"``MP_ERROR_MESSAGE`` (0x03) (MP_STR) Text of reason, as in "
":samp:`{error_object}.message`. The value here will be the same as in the "
"``IPROTO_ERROR_24`` value."
msgstr ""
"``MP_ERROR_MESSAGE`` (0x03) (MP_STR) Текст причины, как в "
":samp:`{error_object}.message`. Значение здесь будет таким же, как и "
"значение ``IPROTO_ERROR_24``"

msgid ""
"``MP_ERROR_ERRNO`` (0x04) (MP_UINT) Ordinal number of the error, as in "
":samp:`{error_object}.errno`. Not to be confused with ``MP_ERROR_ERRCODE``."
msgstr ""
"``MP_ERROR_ERRNO`` (0x04) (MP_UINT) Порядковый номер ошибки, как в "
":samp:`{error_object}.errno`. Не путать с ``MP_ERROR_ERRCODE``."

msgid ""
"``MP_ERROR_ERRCODE`` (0x05) (MP_UINT) Number of the error as defined in "
"errcode.h, as in :samp:`{error_object}.code`, which can also be retrieved "
"with the C function :ref:`box_error_code() <capi-box_error_code_code>`. The "
"value here will be the same as the lower part of the Response-Code-Indicator"
" value."
msgstr ""
"``MP_ERROR_ERRCODE`` (0x05) (MP_UINT) Номер ошибки, как в файле errcode.h, "
"как в :samp:`{error_object}.code`, который также можно получить функцией C "
":ref:`box_error_code() <capi-box_error_code_code>`. Значение здесь будет "
"таким же, как и в нижней части значения Response-Code-Indicator."

msgid ""
"``MP_ERROR_FIELDS`` (0x06) (MP_MAPs) Additional fields depending on error "
"type. For example, if ``MP_ERROR_TYPE`` is \"AccessDeniedError\", then "
"``MP_ERROR_FIELDS`` will include \"object_type\", \"object_name\", "
"\"access_type\". This field will be omitted from the response body if there "
"are no additional fields available."
msgstr ""
"``MP_ERROR_FIELDS`` (0x06) (MP_MAPs) Дополнительные поля в зависимости от "
"типа ошибки. Например, если ``MP_ERROR_TYPE`` имеет значение "
"\"AccessDeniedError\", то ``MP_ERROR_FIELDS`` будет включать "
"\"object_type\", \"object_name\", \"access_type\". При отсутствии "
"дополнительных полей это поле будет пропущено в теле ответа."

msgid ""
"Client and connector programmers should ensure that unknown map keys are "
"ignored, and should check for addition of new keys in the Tarantool source "
"code file where error object creation is defined. In version 2.4.1 the name "
"of this source code file is mp_error.cc."
msgstr ""
"Разработчики клиента и коннекторов должны убедиться, что неизвестные ключи "
"ассоциативных массивов игнорируются, а также проверить наличие новых ключей "
"в файле исходного кода Tarantool, в котором определено создание объекта "
"ошибки. В версии 2.4.1 имя этого файла с исходным кодом mp_error.cc."

msgid ""
"For example, in version 2.4.1 or later, if we try to create a duplicate "
"space with |br| ``conn:eval([[box.schema.space.create('_space');]])`` |br| "
"the server response will look like this:"
msgstr ""
"Например, в версии 2.4.1 или более поздней, если мы попытаемся создать "
"дубликат пробела с помощью команды |br| "
"``conn:eval([[box.schema.space.create('_space');]))``, |br| ответ сервера "
"будет выглядеть так:"

msgid ""
"ce 00 00 00 88                  MP_UINT = HEADER + BODY SIZE\n"
"83                              MP_MAP, size 3 (i.e. 3 items in header)\n"
"  00                              Response-Code-Indicator\n"
"  ce 00 00 80 0a                  MP_UINT = hexadecimal 800a\n"
"  01                              IPROTO_SYNC\n"
"  cf 00 00 00 00 00 00 00 05      MP_UINT = sync value\n"
"  05                              IPROTO_SCHEMA_VERSION\n"
"  ce 00 00 00 4e                  MP_UINT = schema version value\n"
"82                              MP_MAP, size 2\n"
"  31                              IPROTO_ERROR_24\n"
"  bd 53 70 61 63 etc.             MP_STR = \"Space '_space' already exists\"\n"
"  52                              IPROTO_ERROR\n"
"  81                              MP_MAP, size 1\n"
"    00                              MP_ERROR_STACK\n"
"    91                              MP_ARRAY, size 1\n"
"      86                              MP_MAP, size 6\n"
"        00                              MP_ERROR_TYPE\n"
"        ab 43 6c 69 65 6e 74 etc.       MP_STR = \"ClientError\"\n"
"        02                              MP_ERROR_LINE\n"
"        cd                              MP_UINT = line number\n"
"        01                              MP_ERROR_FILE\n"
"        aa 01 b6 62 75 69 6c etc.       MP_STR \"builtin/box/schema.lua\"\n"
"        03                              MP_ERROR_MESSAGE\n"
"        bd 53 70 61 63 65 20 etc.       MP_STR = Space.'_space'.already.exists\"\n"
"        04                              MP_ERROR_ERRNO\n"
"        00                              MP_UINT = error number\n"
"        05                              MP_ERROR_ERRCODE\n"
"        0a                              MP_UINT = eror code ER_SPACE_EXISTS"
msgstr ""
