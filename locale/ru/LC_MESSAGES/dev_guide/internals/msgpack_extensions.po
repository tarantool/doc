
msgid "MessagePack extensions"
msgstr "Расширения MessagePack"

msgid ""
"Tarantool uses predefined MessagePack extension types to represent some "
"of the special values. Extension types include ``MP_DECIMAL``, "
"``MP_UUID`` and ``MP_ERROR``. These types require special attention from "
"the connector developers, as they must be treated separately from the "
"default MessagePack types, and correctly mapped to programming language "
"types."
msgstr ""
"Tarantool использует предопределенные типы расширений MessagePack для "
"представления некоторых специальных значений. Типы расширений включают "
"``MP_DECIMAL``, ``MP_UUID`` и ``MP_ERROR``. Эти типы требуют особого "
"внимания со стороны разработчиков коннекторов, так как должны "
"рассматриваться отдельно от типов MessagePack по умолчанию и корректно "
"приводиться к типам языков программирования."

msgid "The DECIMAL type"
msgstr "Тип DECIMAL"

msgid ""
"The MessagePack EXT type ``MP_EXT`` together with the extension type "
"``MP_DECIMAL`` is a header for values of the DECIMAL type."
msgstr ""
"Тип MessagePack EXT ``MP_EXT`` вместе с типом расширения ``MP_DECIMAL`` "
"является заголовком для значений типа DECIMAL."

msgid "MP_DECIMAL is 1."
msgstr "MP_DECIMAL -- это 1."

msgid ""
"`MessagePack spec "
"<https://github.com/msgpack/msgpack/blob/master/spec.md>`_ defines two "
"kinds of types:"
msgstr ""
"`Спецификация MessagePack "
"<https://github.com/msgpack/msgpack/blob/master/spec.md>`_ определяет два"
" вида типов:"

msgid ""
"``fixext 1/2/4/8/16`` types have fixed length so the length is not "
"encoded explicitly;"
msgstr ""
"типы ``fixext 1/2/4/8/16`` имеют фиксированную длину, поэтому длина не "
"кодируется явно;"

msgid "``ext 8/16/32`` types require the data length to be encoded."
msgstr "типы ``ext 8/16/32`` требуют кодирования длины данных."

msgid "``MP_EXP`` + optional ``length`` imply using one of these types."
msgstr ""
"``MP_EXP`` + (не обязательно) ``length`` подразумевает использование "
"одного из этих типов."

msgid "The decimal MessagePack representation looks like this:"
msgstr "Десятичное представление MessagePack выглядит следующим образом:"

msgid ""
"+--------+-------------------+------------+===============+\n"
"| MP_EXT | length (optional) | MP_DECIMAL | PackedDecimal |\n"
"+--------+-------------------+------------+===============+"
msgstr ""

msgid ""
"Here ``length`` is the length of ``PackedDecimal`` field, and it is of "
"type ``MP_UINT``, when encoded explicitly (i.e. when the type is ``ext "
"8/16/32``)."
msgstr ""
"Здесь ``length`` -- это длина поля ``PackedDecimal``, и оно имеет тип "
"``MP_UINT``, когда кодируется явно (т.е. когда тип -- ``ext 8/16/32``)."

msgid "``PackedDecimal`` has the following structure:"
msgstr "``PackedDecimal`` имеет следующую структуру:"

msgid ""
" <--- length bytes -->\n"
"+-------+=============+\n"
"| scale |     BCD     |\n"
"+-------+=============+"
msgstr ""
" <--- длина в байтах -->\n"
"+-------+=============+\n"
"| scale |     BCD     |\n"
"+-------+=============+"

msgid ""
"Here ``scale`` is either ``MP_INT`` or ``MP_UINT``. |br| ``scale`` = "
"number of digits after the decimal point"
msgstr ""
"Здесь ``scale`` -- это либо ``MP_INT``, либо ``MP_UINT``. |br| ``scale`` "
"= количество цифр после запятой."

msgid ""
"``BCD`` is a sequence of bytes representing decimal digits of the encoded"
" number (each byte has two decimal digits each encoded using 4-bit "
"``nibbles``), so ``byte >> 4`` is the first digit and ``byte & 0x0f`` is "
"the second digit. The leftmost digit in the array is the most "
"significant. The rightmost digit in the array is the least significant."
msgstr ""
"``BCD`` - это последовательность байтов, обозначающая десятичные цифры "
"кодируемого числа (каждый байт имеет две десятичные цифры, каждая из "
"которых кодируется с использованием 4-битных ``nibbles``), поэтому ``byte"
" >> 4`` - первая цифра, а ``byte & 0x0f`` - вторая цифра. Самая левая "
"цифра в массиве - самая значимая. Самая правая цифра в массиве - наименее"
" значимая."

msgid ""
"The first byte of the ``BCD`` array contains the first digit of the "
"number, represented as follows:"
msgstr ""
"Первый байт ``BCD``-массива содержит первую цифру числа, представленную "
"следующим образом:"

msgid ""
"|  4 bits           |  4 bits           |\n"
"   = 0x                = the 1st digit"
msgstr ""

msgid ""
"(The first ``nibble`` contains 0 if the decimal number has an even number"
" of digits.) The last byte of the ``BCD`` array contains the last digit "
"of the number and the final ``nibble``, represented as follows:"
msgstr ""
"(Первый ``nibble`` содержит 0, если десятичное число имеет четное число "
"цифр). Последний байт BCD-массива содержит последнюю цифру числа и "
"последний ``nibble``, представленный следующим образом:"

msgid ""
"|  4 bits           |  4 bits           |\n"
"   = the last digit    = nibble"
msgstr ""

msgid "The final ``nibble`` represents the number's sign:"
msgstr "Последний ``nibble`` обозначает знак числа:"

msgid "``0x0a``, ``0x0c``, ``0x0e``, ``0x0f`` stand for plus,"
msgstr "``0x0a``, ``0x0c``, ``0x0e``, ``0x0f`` обозначают плюс,"

msgid "``0x0b`` and ``0x0d`` stand for minus."
msgstr "``0x0b`` and ``0x0d`` обозначают минус."

msgid "**Examples**"
msgstr "**Примеры**"

msgid ""
"The decimal ``-12.34`` will be encoded as "
"``0xd6,0x01,0x02,0x01,0x23,0x4d``:"
msgstr ""
"Десятичное число ``-12.34`` будет закодировано как "
"``0xd6,0x01,0x02,0x01,0x23,0x4d``:"

msgid ""
"|MP_EXT (fixext 4) | MP_DECIMAL | scale |  1   |  2,3 |  4 (minus) |\n"
"|       0xd6       |    0x01    | 0x02  | 0x01 | 0x23 | 0x4d       |"
msgstr ""

msgid ""
"The decimal 0.000000000000000000000000000000000010 will be encoded as "
"``0xc7,0x03,0x01,0x24,0x01,0x0c``:"
msgstr ""
"Десятичное число 0.000000000000000000000000000000000010 будет "
"закодировано как ``0xc7,0x03,0x01,0x24,0x01,0x0c``:"

msgid ""
"| MP_EXT (ext 8) | length | MP_DECIMAL | scale |  1   | 0 (plus) |\n"
"|      0xc7      |  0x03  |    0x01    | 0x24  | 0x01 | 0x0c     |"
msgstr ""

msgid "The UUID type"
msgstr "Тип UUID"

msgid ""
"The MessagePack EXT type ``MP_EXT`` together with the extension type "
"``MP_UUID`` for values of the UUID type."
msgstr ""
"MessagePack EXT тип ``MP_EXT`` вместе с типом расширения ``MP_UUID`` "
"предназначен для значений типа UUID."

msgid "MP_UUID is 2."
msgstr "MP_UUID -- это 2."

msgid ""
"The `MessagePack spec "
"<https://github.com/msgpack/msgpack/blob/master/spec.md>`_ defines ``d8``"
" to mean fixext with size 16, and a uuid's size is always 16. So the uuid"
" MessagePack representation looks like this:"
msgstr ""
"`Спецификация MessagePack "
"<https://github.com/msgpack/msgpack/blob/master/spec.md>`_ определяет "
"``d8`` как ``fixext`` с размером 16, а размер ``uuid`` всегда равен 16. Таким "
"образом, представление ``uuid`` MessagePack выглядит следующим образом:"

msgid ""
"+--------+------------+-----------------+\n"
"| MP_EXT | MP_UUID    | PackedDecimal   |\n"
"| = d8   | = 2        | = 16-byte value |\n"
"+--------+------------+-----------------+"
msgstr ""

msgid ""
"The 16-byte value has 2 digits per byte. Typically it consists of 11 "
"fields, which are encoded as big endian unsigned integers in the "
"following order: time_low (4 bytes), time_mid (2 bytes), "
"time_hi_and_version (2 bytes), clock_seq_hi_and_reserved (1 byte), "
"clock_seq_low (1 byte), node[0], ..., node[5] (1 byte each)."
msgstr ""
"16-байтовое значение имеет 2 цифры на байт. Обычно оно состоит из 11 "
"полей, которые кодируются от большего к меньшему беззнаковыми целыми "
"числами в следующем порядке: time_low (4 байта), time_mid (2 байта), "
"time_hi_and_version (2 байта), clock_seq_hi_and_reserved (1 байт), "
"clock_seq_low (1 байт), node[0], ..., node[5] (по 1 байту)."

msgid ""
"Some of the functions in :ref:`Module uuid <uuid-module>` can produce "
"values which are compatible with the UUID data type. For example, after"
msgstr ""
"Некоторые функции в :ref:`модуле uuid <uuid-module>` могут выдавать "
"значения, совместимые с типом данных UUID. Например, после"

msgid ""
"uuid = require('uuid')\n"
"box.schema.space.create('t')\n"
"box.space.t:create_index('i', {parts={1,'uuid'}})\n"
"box.space.t:insert{uuid.fromstr('f6423bdf-b49e-4913-b361-0740c9702e4b')}\n"
"box.space.t:select()"
msgstr ""

msgid "a peek at the server response packet will show that it contains"
msgstr "пакет ответа сервера покажет, что он содержит"

msgid "d8 02 f6 42 3b df b4 9e 49 13 b3 61 07 40 c9 70 2e 4b"
msgstr ""

msgid "The ERROR type"
msgstr "Тип ERROR"

#, fuzzy
msgid ""
"Beginning in version 2.4.1, responses for errors have extra information "
"following what was described in :ref:`Box protocol -- responses for "
"errors <box_protocol-responses_error>`. This is a \"compatible\" "
"enhancement, because clients that expect old-style server responses "
"should ignore map components that they do not recognize. Notice, however,"
" that there has been a renaming of a constant: formerly IPROTO_ERROR in "
"./box/iproto_constants.h was 0x31, now IPROTO_ERROR is 0x52 and "
"IPROTO_ERROR_24 is 0x31."
msgstr ""
"Начиная с версии 2.4.1, в ответах на ошибки содержится дополнительная "
"информация, соответствующая описанию в разделе :ref:`Box protocol -- responses "
"for errors<box_protocol-responses_error>`. Это \"совместимое\" улучшение,"
" потому что клиенты, которые ожидают ответы сервера старого образца, "
"должны игнорировать компоненты ассоциативного массива, которые они не "
"распознают. Обратите внимание, что константа IPROTO_ERROR в "
"./box/iproto_constants.h была 0x31, а теперь IPROTO_ERROR -- 0x52, а "
"IPROTO_ERROR_24 -- 0x31."

msgid ""
"++=========================+============================+\n"
"||                         |                            |\n"
"||   0x31: IPROTO_ERROR_24 |   0x52: IPROTO_ERROR       |\n"
"|| MP_INT: MP_STRING       | MP_MAP: extra information  |\n"
"||                         |                            |\n"
"++=========================+============================+\n"
"                        MP_MAP"
msgstr ""

msgid ""
"The extra information, most of which is also in :ref:`error object "
"<box_error-new>` fields, is:"
msgstr ""
"Дополнительная информация, большая часть которой также хранится в полях "
":ref:`объекта ошибки <box_error-new>`:"

msgid ""
"``MP_ERROR_TYPE`` (0x00) (MP_STR) Type that implies source, as in "
":samp:`{error_object}.base_type`, for example \"ClientError\"."
msgstr ""
"``MP_ERROR_TYPE`` (0x00) (MP_STR) Тип, подразумевающий источник, как в "
":samp:`{error_object}.base_type`, например \"ClientError\"."

msgid ""
"``MP_ERROR_FILE`` (0x01) (MP_STR)  Source code file where error was "
"caught, as in :samp:`{error_object}.trace`."
msgstr ""
"``MP_ERROR_FILE`` (0x01) (MP_STR) Файл с исходным кодом, в котором была "
"перехвачена ошибка, как в :samp:`{error_object}.trace`."

msgid ""
"``MP_ERROR_LINE`` (0x02) (MP_UINT) Line number in source code file, as in"
" :samp:`{error_object}.trace`."
msgstr ""
"``MP_ERROR_LINE`` (0x02) (MP_UINT) Номер строки в файле исходных кодов, "
"как в :samp:`{error_object}.trace`."

msgid ""
"``MP_ERROR_MESSAGE`` (0x03) (MP_STR) Text of reason, as in "
":samp:`{error_object}.message`. The value here will be the same as in the"
" ``IPROTO_ERROR_24`` value."
msgstr ""
"``MP_ERROR_MESSAGE`` (0x03) (MP_STR) Текст причины, как в "
":samp:`{error_object}.message`. Значение здесь будет таким же, как и "
"значение ``IPROTO_ERROR_24``"

msgid ""
"``MP_ERROR_ERRNO`` (0x04) (MP_UINT) Ordinal number of the error, as in "
":samp:`{error_object}.errno`. Not to be confused with "
"``MP_ERROR_ERRCODE``."
msgstr ""
"``MP_ERROR_ERRNO`` (0x04) (MP_UINT) Порядковый номер ошибки, как в "
":samp:`{error_object}.errno`. Не путать с ``MP_ERROR_ERRCODE``."

msgid ""
"``MP_ERROR_ERRCODE`` (0x05) (MP_UINT) Number of the error as defined in "
"errcode.h, as in :samp:`{error_object}.code`, which can also be retrieved"
" with the C function :ref:`box_error_code() <capi-box_error_code_code>`. "
"The value here will be the same as the lower part of the Response-Code-"
"Indicator value."
msgstr ""
"``MP_ERROR_ERRCODE`` (0x05) (MP_UINT) Номер ошибки, как в файле "
"errcode.h, как в :samp:`{error_object}.code`, который также можно "
"получить функцией C :ref:`box_error_code() <capi-box_error_code_code>`. "
"Значение здесь будет таким же, как и в нижней части значения Response-"
"Code-Indicator."

msgid ""
"``MP_ERROR_FIELDS`` (0x06) (MP_MAPs) Additional fields depending on error"
" type. For example, if ``MP_ERROR_TYPE`` is \"AccessDeniedError\", then "
"``MP_ERROR_FIELDS`` will include \"object_type\", \"object_name\", "
"\"access_type\". This field will be omitted from the response body if "
"there are no additional fields available."
msgstr ""
"``MP_ERROR_FIELDS`` (0x06) (MP_MAPs) Дополнительные поля в зависимости от"
" типа ошибки. Например, если ``MP_ERROR_TYPE`` имеет значение "
"\"AccessDeniedError\", то ``MP_ERROR_FIELDS`` будет включать "
"\"object_type\", \"object_name\", \"access_type\". При отсутствии "
"дополнительных полей это поле будет пропущено в теле ответа."

msgid ""
"Client and connector programmers should ensure that unknown map keys are "
"ignored, and should check for addition of new keys in the Tarantool "
"source code file where error object creation is defined. In version 2.4.1"
" the name of this source code file is mp_error.cc."
msgstr ""
"Разработчики клиента и коннекторов должны убедиться, что неизвестные "
"ключи ассоциативных массивов игнорируются, а также проверить наличие "
"новых ключей в файле исходного кода Tarantool, в котором определено "
"создание объекта ошибки. В версии 2.4.1 имя этого файла с исходным кодом "
"mp_error.cc."

msgid ""
"For example, in version 2.4.1 or later, if we try to create a duplicate "
"space with |br| ``conn:eval([[box.schema.space.create('_space');]])`` "
"|br| the server response will look like this:"
msgstr ""
"Например, в версии 2.4.1 или более поздней, если мы попытаемся создать "
"дубликат пробела с помощью команды |br| "
"``conn:eval([[box.schema.space.create('_space');]))``, |br| ответ сервера "
"будет выглядеть так:"

msgid ""
"ce 00 00 00 88                  MP_UINT = HEADER + BODY SIZE\n"
"83                              MP_MAP, size 3 (i.e. 3 items in header)\n"
"  00                              Response-Code-Indicator\n"
"  ce 00 00 80 0a                  MP_UINT = hexadecimal 800a\n"
"  01                              IPROTO_SYNC\n"
"  cf 00 00 00 00 00 00 00 05      MP_UINT = sync value\n"
"  05                              IPROTO_SCHEMA_VERSION\n"
"  ce 00 00 00 4e                  MP_UINT = schema version value\n"
"82                              MP_MAP, size 2\n"
"  31                              IPROTO_ERROR_24\n"
"  bd 53 70 61 63 etc.             MP_STR = \"Space '_space' already "
"exists\"\n"
"  52                              IPROTO_ERROR\n"
"  81                              MP_MAP, size 1\n"
"    00                              MP_ERROR_STACK\n"
"    91                              MP_ARRAY, size 1\n"
"      86                              MP_MAP, size 6\n"
"        00                              MP_ERROR_TYPE\n"
"        ab 43 6c 69 65 6e 74 etc.       MP_STR = \"ClientError\"\n"
"        02                              MP_ERROR_LINE\n"
"        cd                              MP_UINT = line number\n"
"        01                              MP_ERROR_FILE\n"
"        aa 01 b6 62 75 69 6c etc.       MP_STR \"builtin/box/schema.lua\""
"\n"
"        03                              MP_ERROR_MESSAGE\n"
"        bd 53 70 61 63 65 20 etc.       MP_STR = "
"Space.'_space'.already.exists\"\n"
"        04                              MP_ERROR_ERRNO\n"
"        00                              MP_UINT = error number\n"
"        05                              MP_ERROR_ERRCODE\n"
"        0a                              MP_UINT = eror code "
"ER_SPACE_EXISTS"
msgstr ""
