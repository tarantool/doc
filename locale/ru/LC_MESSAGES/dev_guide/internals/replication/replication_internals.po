
msgid "Server startup with replication"
msgstr "Запуск сервера с репликацией"

msgid ""
"In addition to the recovery process described in the section :ref:`Recovery "
"process <internals-recovery_process>`, the server must take additional steps"
" and precautions if :ref:`replication <replication>` is enabled."
msgstr ""
"Помимо процесса восстановления, описанного в разделе :ref:`Процесс "
"восстановления <internals-recovery_process>`, сервер должен предпринять "
"дополнительные шаги и меры предосторожности, если включена :ref:`репликация "
"<replication>`."

msgid ""
"Once again the startup procedure is initiated by the ``box.cfg{}`` request. "
"One of the ``box.cfg`` parameters may be :ref:`replication <cfg_replication-"
"replication>` which specifies replication source(-s). We will refer to this "
"replica, which is starting up due to ``box.cfg``, as the \"local\" replica "
"to distinguish it from the other replicas in a replica set, which we will "
"refer to as \"distant\" replicas."
msgstr ""
"И снова процедура запуска начинается с запроса ``box.cfg{}``. Одним из "
"параметров запроса ``box.cfg`` может быть :ref:`replication "
"<cfg_replication-replication>`, в котором указываются источники репликации. "
"Реплику, которая запускается сейчас с помощью ``box.cfg``, мы будем называть"
" локальной, чтобы отличать ее от других реплик в наборе реплик, которые мы "
"будем называть удаленными."

msgid ""
"*If there is no snapshot .snap file and the* ``replication`` *parameter is "
"empty and* ``cfg.read_only=false``: |br| then the local replica assumes it "
"is an unreplicated \"standalone\" instance, or is the first replica of a new"
" replica set. It will generate new UUIDs for itself and for the replica set."
" The replica UUID is stored in the ``_cluster`` space; the replica set UUID "
"is stored in the ``_schema`` space. Since a snapshot contains all the data "
"in all the spaces, that means the local replica's snapshot will contain the "
"replica UUID and the replica set UUID. Therefore, when the local replica "
"restarts on later occasions, it will be able to recover these UUIDs when it "
"reads the .snap file."
msgstr ""
"*Если нет файла снимка .snap и не указано значение параметра* "
"``replication`` *и* ``cfg.read_only=false``: |br| то локальная реплика "
"предполагает, что является нереплицируемым обособленным экземпляром или же "
"первой репликой в новом наборе реплик. Она сгенерирует новые UUID для себя и"
" для набора реплик. UUID реплики хранится в спейсе ``_cluster``; UUID набора"
" реплик хранится в спейсе ``_schema``. Поскольку снимок содержит все данные "
"во всех спейсах, это означает, что снимок локальной реплики будет содержать "
"UUID реплики и UUID набора реплик. Таким образом, когда локальная реплика "
"будет позднее перезапускаться, она сможет восстановить эти UUID после "
"прочтения файла снимка .snap."

msgid ""
"*If there is no snapshot .snap file and the* ``replication`` *parameter is "
"empty and* ``cfg.read_only=true``: |br| it cannot be the first replica of a "
"new replica set because the first replica must be a master. Therefore an "
"error message will occur: ER_BOOTSTRAP_READONLY. To avoid this, change the "
"setting for this (local) instance to ``read_only = false``, or ensure that "
"another (distant) instance starts first and has the local instance's UUID in"
" its ``_cluster`` space. In the latter case, if ER_BOOTSTRAP_READONLY still "
"occurs, set the local instance's :ref:`box.replication_connect_timeout "
"<cfg_replication-replication_connect_timeout>` to a larger value."
msgstr ""
"*Если нет файла снимка .snap, не указано значение параметра* ``replication``"
" *и* ``cfg.read_only=true``:|br| такая реплика не может быть первой, потому "
"что первая реплика должна быть мастером. Поэтому выдастся ошибка: "
"ER_BOOTSTRAP_READONLY. Чтобы этого избежать, измените в настройке локального"
" экземпляра ``read_only`` на ``false``, или убедитесь, что удаленный "
"экземпляр запускается первым и имеет UUID локального экземпляра в спейсе "
"``_cluster``. Во втором случае, если произойдет ER_BOOTSTRAP_READONLY, "
"выставите на локальном экземпляре :ref:`box.replication_connect_timeout "
"<cfg_replication-replication_connect_timeout>` на большее значение."

msgid ""
"*If there is no snapshot .snap file and the* ``replication`` *parameter is "
"not empty and the* ``_cluster`` *space contains no other replica UUIDs*: "
"|br| then the local replica assumes it is not a standalone instance, but is "
"not yet part of a replica set. It must now join the replica set. It will "
"send its replica UUID to the first distant replica which is listed in "
"``replication`` and which will act as a master. This is called the \"join "
"request\". When a distant replica receives a join request, it will send "
"back:"
msgstr ""
"*Если нет файла снимка .snap, указано значение параметра* ``replication``, "
"*а в спейсе* ``_cluster`` *отсутствуют UUID других реплик*: |br| то "
"локальная реплика предполагает, что не является обособленным экземпляром, но"
" еще не входит в набор реплик. Сейчас она должна подключиться в набор "
"реплик. Она отправит свой UUID реплики первой удаленной реплике, указанной в"
" параметре ``replication``, которая будет выступать в качестве мастера. Это "
"называется \"запрос на подключение\". Когда удаленная реплика получает "
"запрос на подключение, она отправляет в ответ:"

msgid "the distant replica's replica set UUID,"
msgstr "UUID набора реплик, в который входит удаленная реплика"

msgid ""
"the contents of the distant replica's .snap file. |br| When the local "
"replica receives this information, it puts the replica set UUID in its "
"``_schema`` space, puts the distant replica's UUID and connection "
"information in its ``_cluster`` space, and makes a snapshot containing all "
"the data sent by the distant replica. Then, if the local replica has data in"
" its WAL .xlog files, it sends that data to the distant replica. The distant"
" replica will receive this and update its own copy of the data, and add the "
"local replica's UUID to its ``_cluster`` space."
msgstr ""
"содержимое файла снимка .snap удаленной реплики. |br| Когда локальная "
"реплика получает эту информацию, она размещает UUID набора реплики в своем "
"спейсе ``_schema``, UUID удаленной реплики и информацию о подключении в "
"своем спейсе ``_cluster``, а затем создает снимок, который содержит все "
"данные, отправленные удаленной репликой. Затем, если в WAL-файлах .xlog "
"локальной реплики содержатся данные, они отправляются на удаленную реплику. "
"Удаленная реплика получается данные и обновляет свою копию данных, а затем "
"добавляет UUID локальной реплики в свой спейс ``_cluster``."

msgid ""
"*If there is no snapshot .snap file and the* ``replication`` *parameter is "
"not empty and the* ``_cluster`` *space contains other replica UUIDs*: |br| "
"then the local replica assumes it is not a standalone instance, and is "
"already part of a replica set. It will send its replica UUID and replica set"
" UUID to all the distant replicas which are listed in ``replication``. This "
"is called the \"on-connect handshake\". When a distant replica receives an "
"on-connect handshake: |br|"
msgstr ""
"*Если нет файла снимка .snap, указано значение параметра* ``replication``, "
"*а в спейсе* ``_cluster`` *есть UUID других реплик*: |br| то локальная "
"реплика предполагает, что не является обособленным экземпляром, и уже входит"
" в набор реплик. Она отправит свой UUID реплики и UUID набора реплик всем "
"удаленным репликам, указанным в параметре ``replication``. Это называется "
"\"подтверждение связи при подключении\". Когда удаленная реплика получает "
"подтверждение связи при подключении: |br|"

msgid ""
"the distant replica compares its own copy of the replica set UUID to the one"
" in the on-connect handshake. If there is no match, then the handshake fails"
" and the local replica will display an error."
msgstr ""
"удаленная реплика сопоставляет свою версию UUID набора реплик с UUID, "
"переданным в ходе подтверждения связи при подключении. Если они не "
"совпадают, связь не устанавливается, и локальная реплика отобразит ошибку."

msgid ""
"the distant replica looks for a record of the connecting instance in its "
"``_cluster`` space. If there is none, then the handshake fails. |br| "
"Otherwise the handshake is successful. The distant replica will read any new"
" information from its own .snap and .xlog files, and send the new requests "
"to the local replica."
msgstr ""
"удаленная реплика ищет запись о подключающемся экземпляре в своем спейсе "
"``_cluster``. Если такой записи нет, связь не устанавливается. |br| Если "
"есть, связь подтверждается. Удаленная реплика выполняет чтение любой новой "
"информации из своих файлов .snap и .xlog и отправляет новые запросы на "
"локальную реплику."

msgid ""
"In the end, the local replica knows what replica set it belongs to, the "
"distant replica knows that the local replica is a member of the replica set,"
" and both replicas have the same database contents."
msgstr ""
"Наконец, локальная реплика понимает, к какому набору реплик относится, "
"удаленная реплика понимает, что локальная реплика входит в набор реплик, и у"
" двух реплик одинаковое содержимое базы данных."

msgid ""
"*If there is a snapshot file and replication source is not empty*: |br| "
"first the local replica goes through the recovery process described in the "
"previous section, using its own .snap and .xlog files. Then it sends a "
"\"subscribe\" request to all the other replicas of the replica set. The "
"subscribe request contains the server vector clock. The vector clock has a "
"collection of pairs 'server id, lsn' for every replica in the ``_cluster`` "
"system space. Each distant replica, upon receiving a subscribe request, will"
" read its .xlog files' requests and send them to the local replica if (lsn "
"of .xlog file request) is greater than (lsn of the vector clock in the "
"subscribe request). After all the other replicas of the replica set have "
"responded to the local replica's subscribe request, the replica startup is "
"complete."
msgstr ""
"*Если есть файл снимка и указан источник репликации*: |br| сначала локальная"
" реплика проходит процесс восстановления, описанный в предыдущем разделе, "
"используя свои собственные файлы .snap и .xlog. Затем она отправляет запрос "
"подписки всем репликам в наборе реплик. Запрос подписки содержит векторные "
"часы сервера. Векторные часы включают набор пар 'идентификатор сервера, LSN'"
" для каждой реплики в системном спейсе ``_cluster``. Каждая удаленная "
"реплика, получив запрос подписки, выполняет чтение запросов из файла .xlog и"
" отправляет их на локальную реплику, если LSN из запроса файла .xlog больше,"
" чем LSN векторных часов из запроса подписки. После того, как все реплики из"
" набора реплик отправили ответ на запрос подписки локальной реплики, запуск "
"реплики завершен."

msgid ""
"The following temporary limitations applied for Tarantool versions earlier "
"than 1.7.7:"
msgstr ""
"Следующие временные ограничения применимы к версиям Tarantool ниже 1.7.7:"

msgid ""
"The URIs in the ``replication`` parameter should all be in the same order on"
" all replicas. This is not mandatory but is an aid to consistency."
msgstr ""
"URI в параметре ``replication`` должны быть указаны в одинаковом порядке на "
"всех репликах. Это необязательно, но помогает соблюдать консистентность."

msgid ""
"The replicas of a replica set should be started up at slightly different "
"times. This is not mandatory but prevents a situation where each replica is "
"waiting for the other replica to be ready."
msgstr ""
"Реплики в наборе реплик должны запускаться не одновременно. Это "
"необязательно, но помогает избежать ситуации, когда все реплики ждут "
"готовности друг друга."

msgid ""
"The following limitation still applies for the current Tarantool version:"
msgstr "Следующее ограничение всё еще применимо к текущей версии Tarantool:"

msgid ""
"The maximum number of entries in the ``_cluster`` space is :ref:`32 "
"<limitations_replicas>`. Tuples for out-of-date replicas are not "
"automatically re-used, so if this 32-replica limit is reached, users may "
"have to reorganize the ``_cluster`` space manually."
msgstr ""
"Максимальное количество записей в спейсе ``_cluster`` -- :ref:`32 "
"<limitations_replicas>`. Кортежи для устаревших реплик не переиспользуются "
"автоматически, поэтому по достижении предела в 32 реплики, может "
"понадобиться реорганизация спейса ``_cluster`` вручную."
