
msgid "Internals"
msgstr "Внутреннее устройство"

msgid "Tarantool's binary protocol"
msgstr "Бинарный протокол Tarantool'а"

msgid "Tarantool's binary protocol is a binary request/response protocol."
msgstr ""
"Бинарный протокол Tarantool'а представляет собой бинарный "
"запросно-ответный протокол."

msgid "Notation in diagrams"
msgstr "Система обозначений в схематическом представлении"

msgid ""
"0    X\n"
"+----+\n"
"|    | - X + 1 bytes\n"
"+----+\n"
" TYPE - type of MsgPack value (if it is a MsgPack object)\n"
"\n"
"+====+\n"
"|    | - Variable size MsgPack object\n"
"+====+\n"
" TYPE - type of MsgPack value\n"
"\n"
"+~~~~+\n"
"|    | - Variable size MsgPack Array/Map\n"
"+~~~~+\n"
" TYPE - type of MsgPack value"
msgstr ""
"0    X\n"
"+----+\n"
"|    | - X + 1 байт\n"
"+----+\n"
" TYPE - тип MsgPack-значения (если это MsgPack-объект)\n"
"\n"
"+====+\n"
"|    | - MsgPack-объект изменяемого размера\n"
"+====+\n"
" TYPE - тип MsgPack-значения\n"
"\n"
"+~~~~+\n"
"|    | - Массив или ассоциативный массив в формате MsgPack изменяемого "
"размера\n"
"+~~~~+\n"
" TYPE - тип MsgPack-значения"

msgid "MsgPack data types:"
msgstr "Типы MsgPack-данных:"

msgid "**MP_INT** - Integer"
msgstr "**MP_INT** - целое число"

msgid "**MP_MAP** - Map"
msgstr "**MP_MAP** - ассоциативный массив"

msgid "**MP_ARR** - Array"
msgstr "**MP_ARR** - массив"

msgid "**MP_STRING** - String"
msgstr "**MP_STRING** - строка"

msgid "**MP_FIXSTR** - Fixed size string"
msgstr "**MP_FIXSTR** - строка фиксированной длины"

msgid "**MP_OBJECT** - Any MsgPack object"
msgstr "**MP_OBJECT** - любой MsgPack-объект"

msgid "**MP_BIN** - MsgPack binary format"
msgstr "**MP_BIN** - бинарный формат MsgPack"

msgid "Greeting packet"
msgstr "Пакет приветствия"

msgid ""
"TARANTOOL'S GREETING:\n"
"\n"
"0                                     63\n"
"+--------------------------------------+\n"
"|                                      |\n"
"| Tarantool Greeting (server version)  |\n"
"|               64 bytes               |\n"
"+---------------------+----------------+\n"
"|                     |                |\n"
"| BASE64 encoded SALT |      NULL      |\n"
"|      44 bytes       |                |\n"
"+---------------------+----------------+\n"
"64                  107              127"
msgstr ""
"ПРИВЕТСТВИЕ TARANTOOL'А:\n"
" \n"
" 0                                     63\n"
" +--------------------------------------+\n"
" |                                      |\n"
" | Приветствие Tarantool'а (версия сервера)  |\n"
" |               64 байта               |\n"
" +---------------------+----------------+\n"
" |                     |                |\n"
" | СОЛЬ в кодировке BASE64 |      NULL      |\n"
" |      44 байта       |                |\n"
" +---------------------+----------------+\n"
" 64                  107              127"

msgid ""
"The server instance begins the dialogue by sending a fixed-size "
"(128-byte) text greeting to the client. The greeting always contains two "
"64-byte lines of ASCII text, each line ending with a newline character "
"(:code:`\\n`). The first line contains the instance version and protocol "
"type. The second line contains up to 44 bytes of base64-encoded random "
"string, to use in the authentication packet, and ends with up to 23 "
"spaces."
msgstr ""
"Экземпляр сервера начинает диалог с отправки клиенту текста приветствия "
"фиксированного размера (128 байтов). Приветствие всегда содержит две "
"64-байтные строки текста в формате ASCII, каждая строка заканчивается "
"символом разрыва строки (:code:`\\n`). Первая строка описывает версию "
"экземпляра и тип протокола. Вторая строка содержит случайную строку в "
"кодировке base64 размером до 44 байтов для использования в пакете "
"аутентификации и заканчивается на пробелы (до 23)."

msgid "Unified packet structure"
msgstr "Унифицированная структура пакета"

msgid ""
"Once a greeting is read, the protocol becomes pure request/response and "
"features a complete access to Tarantool functionality, including:"
msgstr ""
"После того, как приветствие прочитано, протокол становится простым "
"запросно-ответным протоколом и предоставляет полный доступ к функциям "
"Tarantool'а, включая:"

msgid ""
"request multiplexing, e.g. ability to asynchronously issue multiple "
"requests via the same connection"
msgstr ""
"мультиплексирование запросов, т.е. возможность асинхронной отправки "
"множества запросов по одному соединению;"

msgid "response format that supports zero-copy writes"
msgstr ""
"формат ответа, который поддерживает запись в режиме без копирования "
"(zero-copy)."

msgid ""
"The protocol uses `msgpack <http://msgpack.org>`_ for data structures and"
" encoding."
msgstr ""
"Для структуризации и кодирования данных протокол использует формат данных"
" `msgpack <http://msgpack.org>`_."

msgid ""
"The protocol uses maps that contain some integer constants as keys. These"
" constants are defined in `src/box/iproto_constants.h "
"<https://github.com/tarantool/tarantool/blob/1.9/src/box/iproto_constants.h>`_."
" We list common constants here:"
msgstr ""
"Протокол использует ассоциативные массивы, которые содержат несколько "
"целочисленных постоянных, в качестве ключей. Эти постоянные указаны по "
"ссылке `src/box/iproto_constants.h "
"<https://github.com/tarantool/tarantool/blob/1.9/src/box/iproto_constants.h>`_."
" Ниже приведены часто используемые постоянные:"

msgid ""
"-- user keys\n"
"<iproto_sync>          ::= 0x01\n"
"<iproto_schema_id>     ::= 0x05  /* also known as schema_version */\n"
"<iproto_space_id>      ::= 0x10\n"
"<iproto_index_id>      ::= 0x11\n"
"<iproto_limit>         ::= 0x12\n"
"<iproto_offset>        ::= 0x13\n"
"<iproto_iterator>      ::= 0x14\n"
"<iproto_key>           ::= 0x20\n"
"<iproto_tuple>         ::= 0x21\n"
"<iproto_function_name> ::= 0x22\n"
"<iproto_username>      ::= 0x23\n"
"<iproto_expr>          ::= 0x27 /* also known as expression */\n"
"<iproto_ops>           ::= 0x28\n"
"<iproto_data>          ::= 0x30\n"
"<iproto_error>         ::= 0x31"
msgstr ""
"-- пользовательские ключи\n"
"<iproto_sync>          ::= 0x01\n"
"<iproto_schema_id>     ::= 0x05  /* также schema_version */\n"
"<iproto_space_id>      ::= 0x10\n"
"<iproto_index_id>      ::= 0x11\n"
"<iproto_limit>         ::= 0x12\n"
"<iproto_offset>        ::= 0x13\n"
"<iproto_iterator>      ::= 0x14\n"
"<iproto_key>           ::= 0x20\n"
"<iproto_tuple>         ::= 0x21\n"
"<iproto_function_name> ::= 0x22\n"
"<iproto_username>      ::= 0x23\n"
"<iproto_expr>          ::= 0x27 /* также expression */\n"
"<iproto_ops>           ::= 0x28\n"
"<iproto_data>          ::= 0x30\n"
"<iproto_error>         ::= 0x31"

msgid ""
"-- -- Value for <code> key in request can be:\n"
"-- User command codes\n"
"<iproto_select>       ::= 0x01\n"
"<iproto_insert>       ::= 0x02\n"
"<iproto_replace>      ::= 0x03\n"
"<iproto_update>       ::= 0x04\n"
"<iproto_delete>       ::= 0x05\n"
"<iproto_call_16>      ::= 0x06 /* as used in version 1.6 */\n"
"<iproto_auth>         ::= 0x07\n"
"<iproto_eval>         ::= 0x08\n"
"<iproto_upsert>       ::= 0x09\n"
"<iproto_call>         ::= 0x0a\n"
"-- Admin command codes\n"
"-- (including codes for replica-set initialization and master election)\n"
"<iproto_ping>         ::= 0x40\n"
"<iproto_join>         ::= 0x41 /* i.e. replication join */\n"
"<iproto_subscribe>    ::= 0x42\n"
"<iproto_request_vote> ::= 0x43\n"
"\n"
"-- -- Value for <code> key in response can be:\n"
"<iproto_ok>           ::= 0x00\n"
"<iproto_type_error>   ::= 0x8XXX /* where XXX is a value in errcode.h */"
msgstr ""
"-- -- Значение ключа <code> в запросе может быть следующим:\n"
"-- Ключи для команд пользователя\n"
"<iproto_select>       ::= 0x01\n"
"<iproto_insert>       ::= 0x02\n"
"<iproto_replace>      ::= 0x03\n"
"<iproto_update>       ::= 0x04\n"
"<iproto_delete>       ::= 0x05\n"
"<iproto_call_16>      ::= 0x06 /* as used in version 1.6 */\n"
"<iproto_auth>         ::= 0x07\n"
"<iproto_eval>         ::= 0x08\n"
"<iproto_upsert>       ::= 0x09\n"
"<iproto_call>         ::= 0x0a\n"
"-- Коды для команд администратора\n"
"-- (включая коды для инициализации набора реплик и выбора мастера)\n"
"<iproto_ping>         ::= 0x40\n"
"<iproto_join>         ::= 0x41 /* i.e. replication join */\n"
"<iproto_subscribe>    ::= 0x42\n"
"<iproto_request_vote> ::= 0x43\n"
"\n"
"-- -- Значение для ключа <code> в ответе может быть следующим:\n"
"<iproto_ok>           ::= 0x00\n"
"<iproto_type_error>   ::= 0x8XXX /* где XXX -- это значение в errcode.h */"

msgid "Both :code:`<header>` and :code:`<body>` are msgpack maps:"
msgstr ""
"И заголовок :code:`<header>` и тело сообщения :code:`<body>` представляют"
" собой ассоциативные массивы в формате msgpack:"

msgid ""
"Request/Response:\n"
"\n"
"0        5\n"
"+--------+ +============+ +===================================+\n"
"| BODY + | |            | |                                   |\n"
"| HEADER | |   HEADER   | |               BODY                |\n"
"|  SIZE  | |            | |                                   |\n"
"+--------+ +============+ +===================================+\n"
"  MP_INT       MP_MAP                     MP_MAP"
msgstr ""
"Запрос / ответ:\n"
" \n"
"0        5\n"
"+--------+ +============+ +===================================+\n"
"| BODY + | |            | |                                   |\n"
"| HEADER | |   HEADER   | |               BODY                |\n"
"|  SIZE  | |            | |                                   |\n"
"+--------+ +============+ +===================================+\n"
"  MP_INT       MP_MAP                     MP_MAP"

msgid ""
"UNIFIED HEADER:\n"
"\n"
"+================+================+=====================+\n"
"|                |                |                     |\n"
"|   0x00: CODE   |   0x01: SYNC   |    0x05: SCHEMA_ID  |\n"
"| MP_INT: MP_INT | MP_INT: MP_INT |  MP_INT: MP_INT     |\n"
"|                |                |                     |\n"
"+================+================+=====================+\n"
"                          MP_MAP"
msgstr ""
"УНИФИЦИРОВАННЫЙ ЗАГОЛОВОК:\n"
"\n"
"+================+================+=====================+\n"
"|                |                |                     |\n"
"|   0x00: CODE   |   0x01: SYNC   |    0x05: SCHEMA_ID  |\n"
"| MP_INT: MP_INT | MP_INT: MP_INT |  MP_INT: MP_INT     |\n"
"|                |                |                     |\n"
"+================+================+=====================+\n"
"                          MP_MAP"

msgid ""
"They only differ in the allowed set of keys and values. The key defines "
"the type of value that follows. In a request, the body map can be absent."
" Responses will contain it anyway even if it is a ``PING``. ``schema_id``"
" may be absent in the request's header, meaning that there will be no "
"version checking, but it must be present in the response. If "
"``schema_id`` is sent in the header, then it will be checked."
msgstr ""
"Они различаются лишь набором допустимых ключей и значений. Ключ "
"определяет тип следующего за ним значения. В запросе может отсутствовать "
"ассоциативный массив в теле сообщения. В ответе же он всегда будет "
"присутствовать (даже при запросе проверки связи ``PING``). ``schema_id`` "
"может отсутствовать в заголовке запроса, что означает отсутствие проверки"
" версии, но этот ключ обязательно должен присутствовать в ответе. Если "
"``schema_id`` отправляется в заголовке, будет выполнена соответствующая "
"проверка."

msgid "Authentication"
msgstr "Аутентификация"

msgid ""
"When a client connects to the server instance, the instance responds with"
" a 128-byte text greeting message. Part of the greeting is base-64 "
"encoded session salt - a random string which can be used for "
"authentication. The length of decoded salt (44 bytes) exceeds the amount "
"necessary to sign the authentication message (first 20 bytes). An excess "
"is reserved for future authentication schemas."
msgstr ""
"Когда клиент подключается к экземпляру сервера, экземпляр отвечает "
"128-байтным текстовым сообщением приветствия. Часть приветствия "
"представляет собой закодированное в формате base-64 значение соль для "
"сессии (случайная строка), которое можно использовать для аутентификации."
" Длина расшифрованного значения соль (44 байта) выходит за пределы "
"сообщения для аутентификации (первые 20 байтов). Остаток предназначается "
"для будущих схем аутентификации."

msgid ""
"PREPARE SCRAMBLE:\n"
"\n"
"    LEN(ENCODED_SALT) = 44;\n"
"    LEN(SCRAMBLE)     = 20;\n"
"\n"
"prepare 'chap-sha1' scramble:\n"
"\n"
"    salt = base64_decode(encoded_salt);\n"
"    step_1 = sha1(password);\n"
"    step_2 = sha1(step_1);\n"
"    step_3 = sha1(salt, step_2);\n"
"    scramble = xor(step_1, step_3);\n"
"    return scramble;\n"
"\n"
"AUTHORIZATION BODY: CODE = 0x07\n"
"\n"
"+==================+====================================+\n"
"|                  |        +-------------+-----------+ |\n"
"|  (KEY)           | (TUPLE)|  len == 9   | len == 20 | |\n"
"|   0x23:USERNAME  |   0x21:| \"chap-sha1\" |  SCRAMBLE | |\n"
"| MP_INT:MP_STRING | MP_INT:|  MP_STRING  |  MP_BIN   | |\n"
"|                  |        +-------------+-----------+ |\n"
"|                  |                   MP_ARRAY         |\n"
"+==================+====================================+\n"
"                        MP_MAP"
msgstr ""
"ПОДГОТОВКА КОДИРОВАНИЯ:\n"
"\n"
"    LEN(ENCODED_SALT) = 44;\n"
"    LEN(SCRAMBLE)     = 20;\n"
"\n"
"подготовить кодирование 'chap-sha1':\n"
"\n"
"    salt = base64_decode(encoded_salt);\n"
"    step_1 = sha1(password);\n"
"    step_2 = sha1(step_1);\n"
"    step_3 = sha1(salt, step_2);\n"
"    scramble = xor(step_1, step_3);\n"
"    return scramble;\n"
"\n"
"ТЕЛО СООБЩЕНИЯ АВТОРИЗАЦИИ: CODE = 0x07\n"
"\n"
"+==================+====================================+\n"
"|                  |        +-------------+-----------+ |\n"
"|  (KEY)           | (TUPLE)|  len == 9   | len == 20 | |\n"
"|   0x23:USERNAME  |   0x21:| \"chap-sha1\" |  SCRAMBLE | |\n"
"| MP_INT:MP_STRING | MP_INT:|  MP_STRING  |  MP_BIN   | |\n"
"|                  |        +-------------+-----------+ |\n"
"|                  |                   MP_ARRAY         |\n"
"+==================+====================================+\n"
"                        MP_MAP"

msgid ""
":code:`<key>` holds the user name. :code:`<tuple>` must be an array of 2 "
"fields: authentication mechanism (\"chap-sha1\" is the only supported "
"mechanism right now) and password, encrypted according to the specified "
"mechanism. Authentication in Tarantool is optional, if no authentication "
"is performed, session user is 'guest'. The instance responds to "
"authentication packet with a standard response with 0 tuples."
msgstr ""
":code:`<key>` содержит имя пользователя. :code:`<tuple>` должен "
"представлять собой массив из 2 полей: механизм аутентификации (в данный "
"момент поддерживается только механизм \"chap-sha1\") и пароль, "
"закодированный в соответствии с указанным механизмом. Аутентификация в "
"Tarantool'е необязательна: если аутентификация не проводится, то "
"пользователем в сессии будет 'guest'. Экземпляр отвечает на пакет "
"аутентификации стандартным ответом с 0 кортежей."

msgid "Requests"
msgstr "Запросы"

msgid "SELECT: CODE - 0x01 Find tuples matching the search pattern"
msgstr "SELECT: CODE - 0x01 Поиск кортежей, соответствующих шаблону поиска"

msgid ""
"SELECT BODY:\n"
"\n"
"+==================+==================+==================+\n"
"|                  |                  |                  |\n"
"|   0x10: SPACE_ID |   0x11: INDEX_ID |   0x12: LIMIT    |\n"
"| MP_INT: MP_INT   | MP_INT: MP_INT   | MP_INT: MP_INT   |\n"
"|                  |                  |                  |\n"
"+==================+==================+==================+\n"
"|                  |                  |                  |\n"
"|   0x13: OFFSET   |   0x14: ITERATOR |   0x20: KEY      |\n"
"| MP_INT: MP_INT   | MP_INT: MP_INT   | MP_INT: MP_ARRAY |\n"
"|                  |                  |                  |\n"
"+==================+==================+==================+\n"
"                          MP_MAP"
msgstr ""
"ТЕЛО СООБЩЕНИЯ ВЫБОРКИ SELECT:\n"
"\n"
"+==================+==================+==================+\n"
"|                  |                  |                  |\n"
"|   0x10: SPACE_ID |   0x11: INDEX_ID |   0x12: LIMIT    |\n"
"| MP_INT: MP_INT   | MP_INT: MP_INT   | MP_INT: MP_INT   |\n"
"|                  |                  |                  |\n"
"+==================+==================+==================+\n"
"|                  |                  |                  |\n"
"|   0x13: OFFSET   |   0x14: ITERATOR |   0x20: KEY      |\n"
"| MP_INT: MP_INT   | MP_INT: MP_INT   | MP_INT: MP_ARRAY |\n"
"|                  |                  |                  |\n"
"+==================+==================+==================+\n"
"                          MP_MAP"

msgid ""
"INSERT:  CODE - 0x02 Inserts tuple into the space, if no tuple with same "
"unique keys exists. Otherwise throw *duplicate key* error."
msgstr ""
"INSERT:  CODE - 0x02 Вставка кортежа в спейс, если нет кортежей с такими "
"же уникальными ключами. Если есть, выдать ошибку *duplicate key* "
"(повторяющееся значение ключа)."

msgid ""
"REPLACE: CODE - 0x03 Insert a tuple into the space or replace an existing"
" one."
msgstr ""
"REPLACE: CODE - 0x03 Вставка кортежа в спейс или замена существующего "
"кортежа."

msgid ""
"INSERT/REPLACE BODY:\n"
"\n"
"+==================+==================+\n"
"|                  |                  |\n"
"|   0x10: SPACE_ID |   0x21: TUPLE    |\n"
"| MP_INT: MP_INT   | MP_INT: MP_ARRAY |\n"
"|                  |                  |\n"
"+==================+==================+\n"
"                 MP_MAP"
msgstr ""
"ТЕЛО СООБЩЕНИЯ ВСТАВКИ/ЗАМЕНЫ INSERT/REPLACE:\n"
"\n"
"+==================+==================+\n"
"|                  |                  |\n"
"|   0x10: SPACE_ID |   0x21: TUPLE    |\n"
"| MP_INT: MP_INT   | MP_INT: MP_ARRAY |\n"
"|                  |                  |\n"
"+==================+==================+\n"
"                 MP_MAP"

msgid "UPDATE: CODE - 0x04 Update a tuple"
msgstr "UPDATE: CODE - 0x04 Обновление кортежа"

msgid ""
"UPDATE BODY:\n"
"\n"
"+==================+=======================+\n"
"|                  |                       |\n"
"|   0x10: SPACE_ID |   0x11: INDEX_ID      |\n"
"| MP_INT: MP_INT   | MP_INT: MP_INT        |\n"
"|                  |                       |\n"
"+==================+=======================+\n"
"|                  |          +~~~~~~~~~~+ |\n"
"|                  |          |          | |\n"
"|                  | (TUPLE)  |    OP    | |\n"
"|   0x20: KEY      |    0x21: |          | |\n"
"| MP_INT: MP_ARRAY |  MP_INT: +~~~~~~~~~~+ |\n"
"|                  |            MP_ARRAY   |\n"
"+==================+=======================+\n"
"                 MP_MAP"
msgstr ""
"ТЕЛО СООБЩЕНИЯ ОБНОВЛЕНИЯ UPDATE:\n"
"\n"
"+==================+=======================+\n"
"|                  |                       |\n"
"|   0x10: SPACE_ID |   0x11: INDEX_ID      |\n"
"| MP_INT: MP_INT   | MP_INT: MP_INT        |\n"
"|                  |                       |\n"
"+==================+=======================+\n"
"|                  |          +~~~~~~~~~~+ |\n"
"|                  |          |          | |\n"
"|                  | (TUPLE)  |    OP    | |\n"
"|   0x20: KEY      |    0x21: |          | |\n"
"| MP_INT: MP_ARRAY |  MP_INT: +~~~~~~~~~~+ |\n"
"|                  |            MP_ARRAY   |\n"
"+==================+=======================+\n"
"                 MP_MAP"

msgid ""
"OP:\n"
"    Works only for integer fields:\n"
"    * Addition    OP = '+' . space[key][field_no] += argument\n"
"    * Subtraction OP = '-' . space[key][field_no] -= argument\n"
"    * Bitwise AND OP = '&' . space[key][field_no] &= argument\n"
"    * Bitwise XOR OP = '^' . space[key][field_no] ^= argument\n"
"    * Bitwise OR  OP = '|' . space[key][field_no] |= argument\n"
"    Works on any fields:\n"
"    * Delete      OP = '#'\n"
"      delete <argument> fields starting\n"
"      from <field_no> in the space[<key>]\n"
"\n"
"0           2\n"
"+-----------+==========+==========+\n"
"|           |          |          |\n"
"|    OP     | FIELD_NO | ARGUMENT |\n"
"| MP_FIXSTR |  MP_INT  |  MP_INT  |\n"
"|           |          |          |\n"
"+-----------+==========+==========+\n"
"              MP_ARRAY"
msgstr ""
"OP:\n"
"    Работает только для целочисленных полей:\n"
"    * Сложение    OP = '+' . space[key][field_no] += argument\n"
"    * Вычитание OP = '-' . space[key][field_no] -= argument\n"
"    * Побитовое И OP = '&' . space[key][field_no] &= argument\n"
"    * Исключающее ИЛИ OP = '^' . space[key][field_no] ^= argument\n"
"    * Побитовое ИЛИ  OP = '|' . space[key][field_no] |= аргумент\n"
"    Работает для любых полей:\n"
"    * Удаление      OP = '#'\n"
"      удалить поля <argument>, начиная\n"
"      с поля <field_no> в спейсе с ключом space[<key>]\n"
"\n"
"0           2\n"
"+-----------+==========+==========+\n"
"|           |          |          |\n"
"|    OP     | FIELD_NO | ARGUMENT |\n"
"| MP_FIXSTR |  MP_INT  |  MP_INT  |\n"
"|           |          |          |\n"
"+-----------+==========+==========+\n"
"              MP_ARRAY"

msgid ""
"    * Insert      OP = '!'\n"
"      insert <argument> before <field_no>\n"
"    * Assign      OP = '='\n"
"      assign <argument> to field <field_no>.\n"
"      will extend the tuple if <field_no> == <max_field_no> + 1\n"
"\n"
"0           2\n"
"+-----------+==========+===========+\n"
"|           |          |           |\n"
"|    OP     | FIELD_NO | ARGUMENT  |\n"
"| MP_FIXSTR |  MP_INT  | MP_OBJECT |\n"
"|           |          |           |\n"
"+-----------+==========+===========+\n"
"              MP_ARRAY\n"
"\n"
"    Works on string fields:\n"
"    * Splice      OP = ':'\n"
"      take the string from space[key][field_no] and\n"
"      substitute <offset> bytes from <position> with <argument>"
msgstr ""
"    * Вставка      OP = '!'\n"
"      вставить <argument> до поля <field_no>\n"
"    * Присвоение      OP = '='\n"
"      присвоить <argument> полю <field_no>.\n"
"      увеличит кортеж, если <field_no> == <max_field_no> + 1\n"
"\n"
"0           2\n"
"+-----------+==========+===========+\n"
"|           |          |           |\n"
"|    OP     | FIELD_NO | ARGUMENT  |\n"
"| MP_FIXSTR |  MP_INT  | MP_OBJECT |\n"
"|           |          |           |\n"
"+-----------+==========+===========+\n"
"              MP_ARRAY\n"
"\n"
"    Работает со строковыми полями:\n"
"    * Разделение      OP = ':'\n"
"      взять строку из space[key][field_no] и\n"
"      заменить <offset> байтов из положения <position> на <argument>"

msgid ""
"0           2\n"
"+-----------+==========+==========+========+==========+\n"
"|           |          |          |        |          |\n"
"|    ':'    | FIELD_NO | POSITION | OFFSET | ARGUMENT |\n"
"| MP_FIXSTR |  MP_INT  |  MP_INT  | MP_INT |  MP_STR  |\n"
"|           |          |          |        |          |\n"
"+-----------+==========+==========+========+==========+\n"
"                         MP_ARRAY"
msgstr ""
"0           2\n"
"+-----------+==========+==========+========+==========+\n"
"|           |          |          |        |          |\n"
"|    ':'    | FIELD_NO | POSITION | OFFSET | ARGUMENT |\n"
"| MP_FIXSTR |  MP_INT  |  MP_INT  | MP_INT |  MP_STR  |\n"
"|           |          |          |        |          |\n"
"+-----------+==========+==========+========+==========+\n"
"                         MP_ARRAY"

msgid ""
"It is an error to specify an argument of a type that differs from the "
"expected type."
msgstr ""
"Указать аргумент типа, который отличается от ожидаемого типа, будет "
"ошибкой."

msgid "DELETE: CODE - 0x05 Delete a tuple"
msgstr "DELETE: CODE - 0x05 Удаление кортежа"

msgid ""
"DELETE BODY:\n"
"\n"
"+==================+==================+==================+\n"
"|                  |                  |                  |\n"
"|   0x10: SPACE_ID |   0x11: INDEX_ID |   0x20: KEY      |\n"
"| MP_INT: MP_INT   | MP_INT: MP_INT   | MP_INT: MP_ARRAY |\n"
"|                  |                  |                  |\n"
"+==================+==================+==================+\n"
"                          MP_MAP"
msgstr ""
"ТЕЛО СООБЩЕНИЯ УДАЛЕНИЯ DELETE:\n"
"\n"
"+==================+==================+==================+\n"
"|                  |                  |                  |\n"
"|   0x10: SPACE_ID |   0x11: INDEX_ID |   0x20: KEY      |\n"
"| MP_INT: MP_INT   | MP_INT: MP_INT   | MP_INT: MP_ARRAY |\n"
"|                  |                  |                  |\n"
"+==================+==================+==================+\n"
"                          MP_MAP"

msgid ""
"CALL_16: CODE - 0x06 Call a stored function, returning an array of "
"tuples. This is deprecated; CALL (0x0a) is recommended instead."
msgstr ""
"CALL_16: CODE - 0x06 Вызов хранимой функции с возвратом массива кортежей."
" Объявлен устаревшим; рекомендуется использовать CALL (0x0a)."

msgid ""
"CALL_16 BODY:\n"
"\n"
"+=======================+==================+\n"
"|                       |                  |\n"
"|   0x22: FUNCTION_NAME |   0x21: TUPLE    |\n"
"| MP_INT: MP_STRING     | MP_INT: MP_ARRAY |\n"
"|                       |                  |\n"
"+=======================+==================+\n"
"                    MP_MAP"
msgstr ""
"ТЕЛО СООБЩЕНИЯ CALL_16:\n"
"\n"
"+=======================+==================+\n"
"|                       |                  |\n"
"|   0x22: FUNCTION_NAME |   0x21: TUPLE    |\n"
"| MP_INT: MP_STRING     | MP_INT: MP_ARRAY |\n"
"|                       |                  |\n"
"+=======================+==================+\n"
"                    MP_MAP"

msgid "EVAL: CODE - 0x08 Evaulate Lua expression"
msgstr "EVAL: CODE - 0x08 Оценка Lua-выражения"

msgid ""
"EVAL BODY:\n"
"\n"
"+=======================+==================+\n"
"|                       |                  |\n"
"|   0x27: EXPRESSION    |   0x21: TUPLE    |\n"
"| MP_INT: MP_STRING     | MP_INT: MP_ARRAY |\n"
"|                       |                  |\n"
"+=======================+==================+\n"
"                    MP_MAP"
msgstr ""
"ТЕЛО СООБЩЕНИЯ EVAL:\n"
"\n"
"+=======================+==================+\n"
"|                       |                  |\n"
"|   0x27: EXPRESSION    |   0x21: TUPLE    |\n"
"| MP_INT: MP_STRING     | MP_INT: MP_ARRAY |\n"
"|                       |                  |\n"
"+=======================+==================+\n"
"                    MP_MAP"

msgid ""
"UPSERT: CODE - 0x09 Update tuple if it would be found elsewhere try to "
"insert tuple. Always use primary index for key."
msgstr ""
"UPSERT: CODE - 0x09 Обновление кортежа, если он уже существует, попытка "
"вставить кортеж. Всегда используйте первичный индекс."

msgid ""
"UPSERT BODY:\n"
"\n"
"+==================+==================+==========================+\n"
"|                  |                  |             +~~~~~~~~~~+ |\n"
"|                  |                  |             |          | |\n"
"|   0x10: SPACE_ID |   0x21: TUPLE    |       (OPS) |    OP    | |\n"
"| MP_INT: MP_INT   | MP_INT: MP_ARRAY |       0x28: |          | |\n"
"|                  |                  |     MP_INT: +~~~~~~~~~~+ |\n"
"|                  |                  |               MP_ARRAY   |\n"
"+==================+==================+==========================+\n"
"                                MP_MAP\n"
"\n"
"Operations structure same as for UPDATE operation.\n"
"   0           2\n"
"+-----------+==========+==========+\n"
"|           |          |          |\n"
"|    OP     | FIELD_NO | ARGUMENT |\n"
"| MP_FIXSTR |  MP_INT  |  MP_INT  |\n"
"|           |          |          |\n"
"+-----------+==========+==========+\n"
"              MP_ARRAY\n"
"\n"
"Supported operations:\n"
"\n"
"'+' - add a value to a numeric field. If the filed is not numeric, it's\n"
"      changed to 0 first. If the field does not exist, the operation is\n"
"      skipped. There is no error in case of overflow either, the value\n"
"      simply wraps around in C style. The range of the integer is "
"MsgPack:\n"
"      from -2^63 to 2^64-1\n"
"'-' - same as the previous, but subtract a value\n"
"'=' - assign a field to a value. The field must exist, if it does not "
"exist,\n"
"      the operation is skipped.\n"
"'!' - insert a field. It's only possible to insert a field if this create"
" no\n"
"      nil \"gaps\" between fields. E.g. it's possible to add a field "
"between\n"
"      existing fields or as the last field of the tuple.\n"
"'#' - delete a field. If the field does not exist, the operation is "
"skipped.\n"
"      It's not possible to change with update operations a part of the "
"primary\n"
"      key (this is validated before performing upsert)."
msgstr ""
"ТЕЛО СООБЩЕНИЯ ОБНОВЛЕНИЯ И ВСТАВКИ UPSERT:\n"
"\n"
"+==================+==================+==========================+\n"
"|                  |                  |             +~~~~~~~~~~+ |\n"
"|                  |                  |             |          | |\n"
"|   0x10: SPACE_ID |   0x21: TUPLE    |       (OPS) |    OP    | |\n"
"| MP_INT: MP_INT   | MP_INT: MP_ARRAY |       0x28: |          | |\n"
"|                  |                  |     MP_INT: +~~~~~~~~~~+ |\n"
"|                  |                  |               MP_ARRAY   |\n"
"+==================+==================+==========================+\n"
"                                MP_MAP\n"
"\n"
"Структура операции аналогична структуре операции обновления UPDATE.\n"
"   0           2\n"
"+-----------+==========+==========+\n"
"|           |          |          |\n"
"|    OP     | FIELD_NO | ARGUMENT |\n"
"| MP_FIXSTR |  MP_INT  |  MP_INT  |\n"
"|           |          |          |\n"
"+-----------+==========+==========+\n"
"              MP_ARRAY\n"
"\n"
"Поддерживаются следующие операции:\n"
"\n"
"'+' - прибавление значения к числовому полю. Если поле не является "
"числовым, оно\n"
"      сначала изменяется на 0. Если поле отсутствует, операция\n"
"      пропускается. В случае переполнения ошибки также не будет, значение"
"\n"
"      просто переносится в стиле языка C. Диапазон целых чисел в формате "
"MsgPack:\n"
"      от -2^63 до 2^64-1\n"
"'-' - как в предыдущей операции, но значение вычитается\n"
"'=' - присвоение значения полю. Если поле отсутствует,\n"
"      операция пропускается.\n"
"'!' - вставка поля. Можно вставить поле, если при этом не будут созданы\n"
"      промежутки с нулевым значением nil между полями. Например, можно "
"добавить поле между\n"
"      существующими полями или последнее поле в кортеже.\n"
"'#' - удаление поля. Если поле отсутствует, операция пропускается.\n"
"      Нельзя с помощью операции обновления update изменить компонент "
"первичного\n"
"      ключа (это проверяется перед выполнением операции upsert)."

msgid ""
"CALL: CODE - 0x0a Similar to CALL_16, but -- like EVAL, CALL returns a "
"list of values, unconverted"
msgstr ""
"CALL: CODE - 0x0a Аналог CALL_16, но как и операция EVAL, CALL возвращает"
" список неконвертированных значений"

msgid ""
"CALL BODY:\n"
"\n"
"+=======================+==================+\n"
"|                       |                  |\n"
"|   0x22: FUNCTION_NAME |   0x21: TUPLE    |\n"
"| MP_INT: MP_STRING     | MP_INT: MP_ARRAY |\n"
"|                       |                  |\n"
"+=======================+==================+\n"
"                    MP_MAP"
msgstr ""
"ТЕЛО СООБЩЕНИЯ CALL:\n"
"\n"
"+=======================+==================+\n"
"|                       |                  |\n"
"|   0x22: FUNCTION_NAME |   0x21: TUPLE    |\n"
"| MP_INT: MP_STRING     | MP_INT: MP_ARRAY |\n"
"|                       |                  |\n"
"+=======================+==================+\n"
"                    MP_MAP"

msgid "Response packet structure"
msgstr "Структура пакета ответа"

msgid "We will show whole packets here:"
msgstr "Здесь мы продемонстрируем пакеты полностью:"

msgid ""
"OK:    LEN + HEADER + BODY\n"
"\n"
"0      5                                          OPTIONAL\n"
"+------++================+================++===================+\n"
"|      ||                |                ||                   |\n"
"| BODY ||   0x00: 0x00   |   0x01: SYNC   ||   0x30: DATA      |\n"
"|HEADER|| MP_INT: MP_INT | MP_INT: MP_INT || MP_INT: MP_OBJECT |\n"
"| SIZE ||                |                ||                   |\n"
"+------++================+================++===================+\n"
" MP_INT                MP_MAP                      MP_MAP"
msgstr ""
"OK:    LEN + HEADER + BODY\n"
"\n"
"0      5                                          OPTIONAL\n"
"+------++================+================++===================+\n"
"|      ||                |                ||                   |\n"
"| BODY ||   0x00: 0x00   |   0x01: SYNC   ||   0x30: DATA      |\n"
"|HEADER|| MP_INT: MP_INT | MP_INT: MP_INT || MP_INT: MP_OBJECT |\n"
"| SIZE ||                |                ||                   |\n"
"+------++================+================++===================+\n"
" MP_INT                MP_MAP                      MP_MAP"

msgid ""
"Set of tuples in the response :code:`<data>` expects a msgpack array of "
"tuples as value EVAL command returns arbitrary `MP_ARRAY` with arbitrary "
"MsgPack values."
msgstr ""
"Предполагается, что набор кортежей в ответе :code:`<data>` будет "
"представлять собой msgpack-массив кортежей, поскольку команда EVAL "
"возвращается произвольный MsgPack-массив `MP_ARRAY` с произвольными "
"MsgPack-значениями."

msgid ""
"ERROR: LEN + HEADER + BODY\n"
"\n"
"0      5\n"
"+------++================+================++===================+\n"
"|      ||                |                ||                   |\n"
"| BODY ||   0x00: 0x8XXX |   0x01: SYNC   ||   0x31: ERROR     |\n"
"|HEADER|| MP_INT: MP_INT | MP_INT: MP_INT || MP_INT: MP_STRING |\n"
"| SIZE ||                |                ||                   |\n"
"+------++================+================++===================+\n"
" MP_INT                MP_MAP                      MP_MAP\n"
"\n"
"Where 0xXXX is ERRCODE."
msgstr ""
"ОШИБКА: LEN + HEADER + BODY\n"
"\n"
"0      5\n"
"+------++================+================++===================+\n"
"|      ||                |                ||                   |\n"
"| BODY ||   0x00: 0x8XXX |   0x01: SYNC   ||   0x31: ERROR     |\n"
"|HEADER|| MP_INT: MP_INT | MP_INT: MP_INT || MP_INT: MP_STRING |\n"
"| SIZE ||                |                ||                   |\n"
"+------++================+================++===================+\n"
" MP_INT                MP_MAP                      MP_MAP\n"
"\n"
"Где 0xXXX -- это код ошибки ERRCODE."

msgid ""
"An error message is present in the response only if there is an error; "
":code:`<error>` expects as value a msgpack string."
msgstr ""
"Сообщение об ошибке будет включено в ответ только в случае ошибки; "
"предполагается, что значение :code:`<error>` будет msgpack-строкой."

msgid ""
"Convenience macros which define hexadecimal constants for return codes "
"can be found in `src/box/errcode.h "
"<https://github.com/tarantool/tarantool/blob/1.10/src/box/errcode.h>`_"
msgstr ""
"Удобные макросы для определения шестнадцатеричных постоянных для "
"возвращаемых кодов можно найти по ссылке `src/box/errcode.h "
"<https://github.com/tarantool/tarantool/blob/1.10/src/box/errcode.h>`_"

msgid "Replication packet structure"
msgstr "Структура пакета при репликации"

msgid ""
"-- replication keys\n"
"<server_id>     ::= 0x02\n"
"<lsn>           ::= 0x03\n"
"<timestamp>     ::= 0x04\n"
"<server_uuid>   ::= 0x24\n"
"<cluster_uuid>  ::= 0x25\n"
"<vclock>        ::= 0x26"
msgstr ""
"-- ключи для репликации\n"
" <server_id>     ::= 0x02\n"
" <lsn>           ::= 0x03\n"
" <timestamp>     ::= 0x04\n"
" <server_uuid>   ::= 0x24\n"
" <cluster_uuid>  ::= 0x25\n"
" <vclock>        ::= 0x26"

msgid ""
"-- replication codes\n"
"<join>      ::= 0x41\n"
"<subscribe> ::= 0x42"
msgstr ""
"-- коды для репликации\n"
"<join>      ::= 0x41\n"
"<subscribe> ::= 0x42"

msgid ""
"JOIN:\n"
"\n"
"In the beginning you must send initial JOIN\n"
"               HEADER                      BODY\n"
"+================+================++===================+\n"
"|                |                ||   SERVER_UUID     |\n"
"|   0x00: 0x41   |   0x01: SYNC   ||   0x24: UUID      |\n"
"| MP_INT: MP_INT | MP_INT: MP_INT || MP_INT: MP_STRING |\n"
"|                |                ||                   |\n"
"+================+================++===================+\n"
"               MP_MAP                     MP_MAP\n"
"\n"
"Then instance, which we connect to, will send last SNAP file by, simply,\n"
"creating a number of INSERTs (with additional LSN and ServerID)\n"
"(don't reply). Then it'll send a vclock's MP_MAP and close a socket.\n"
"\n"
"+================+================++============================+\n"
"|                |                ||        +~~~~~~~~~~~~~~~~~+ |\n"
"|                |                ||        |                 | |\n"
"|   0x00: 0x00   |   0x01: SYNC   ||   0x26:| SRV_ID: SRV_LSN | |\n"
"| MP_INT: MP_INT | MP_INT: MP_INT || MP_INT:| MP_INT: MP_INT  | |\n"
"|                |                ||        +~~~~~~~~~~~~~~~~~+ |\n"
"|                |                ||               MP_MAP       |\n"
"+================+================++============================+\n"
"               MP_MAP                      MP_MAP\n"
"\n"
"SUBSCRIBE:\n"
"\n"
"Then you must send SUBSCRIBE:\n"
"\n"
"                              HEADER\n"
"+===================+===================+\n"
"|                   |                   |\n"
"|     0x00: 0x42    |    0x01: SYNC     |\n"
"|   MP_INT: MP_INT  |  MP_INT: MP_INT   |\n"
"|                   |                   |\n"
"+===================+===================+\n"
"|    SERVER_UUID    |    CLUSTER_UUID   |\n"
"|   0x24: UUID      |   0x25: UUID      |\n"
"| MP_INT: MP_STRING | MP_INT: MP_STRING |\n"
"|                   |                   |\n"
"+===================+===================+\n"
"                 MP_MAP\n"
"\n"
"      BODY\n"
"+================+\n"
"|                |\n"
"|   0x26: VCLOCK |\n"
"| MP_INT: MP_INT |\n"
"|                |\n"
"+================+\n"
"      MP_MAP\n"
"\n"
"Then you must process every query that'll came through other masters.\n"
"Every request between masters will have Additional LSN and SERVER_ID."
msgstr ""
"JOIN:\n"
"\n"
"Сначала необходимо отправить изначальный запрос JOIN\n"
"               HEADER                      BODY\n"
"+================+================++===================+\n"
"|                |                ||   SERVER_UUID     |\n"
"|   0x00: 0x41   |   0x01: SYNC   ||   0x24: UUID      |\n"
"| MP_INT: MP_INT | MP_INT: MP_INT || MP_INT: MP_STRING |\n"
"|                |                ||                   |\n"
"+================+================++===================+\n"
"               MP_MAP                     MP_MAP\n"
"\n"
"Затем экземпляр, к которому мы подключаемся, отправит последний файл "
"снимка SNAP,\n"
"просто создав количество запросов вставки INSERT (с дополнительным LSN и "
"ServerID)\n"
"(не отвечайте). Затем он отправит MP_MAP из vclock и закроет сокет.\n"
"\n"
"+================+================++============================+\n"
"|                |                ||        +~~~~~~~~~~~~~~~~~+ |\n"
"|                |                ||        |                 | |\n"
"|   0x00: 0x00   |   0x01: SYNC   ||   0x26:| SRV_ID: SRV_LSN | |\n"
"| MP_INT: MP_INT | MP_INT: MP_INT || MP_INT:| MP_INT: MP_INT  | |\n"
"|                |                ||        +~~~~~~~~~~~~~~~~~+ |\n"
"|                |                ||               MP_MAP       |\n"
"+================+================++============================+\n"
"               MP_MAP                      MP_MAP\n"
"\n"
"SUBSCRIBE:\n"
"\n"
"Далее необходимо отправить запрос SUBSCRIBE:\n"
"\n"
"                              HEADER\n"
"+===================+===================+\n"
"|                   |                   |\n"
"|     0x00: 0x42    |    0x01: SYNC     |\n"
"|   MP_INT: MP_INT  |  MP_INT: MP_INT   |\n"
"|                   |                   |\n"
"+===================+===================+\n"
"|    SERVER_UUID    |    CLUSTER_UUID   |\n"
"|   0x24: UUID      |   0x25: UUID      |\n"
"| MP_INT: MP_STRING | MP_INT: MP_STRING |\n"
"|                   |                   |\n"
"+===================+===================+\n"
"                 MP_MAP\n"
"\n"
"      BODY\n"
"+================+\n"
"|                |\n"
"|   0x26: VCLOCK |\n"
"| MP_INT: MP_INT |\n"
"|                |\n"
"+================+\n"
"      MP_MAP\n"
"\n"
" Затем следует обработать каждый запрос, который пришел от других "
"мастеров.\n"
" Каждый запрос между мастерами получит дополнительный LSN и SERVER_ID."

msgid "XLOG / SNAP"
msgstr "XLOG / SNAP"

msgid "XLOG and SNAP files have nearly the same format. The header looks like:"
msgstr ""
"Файлы форматов XLOG и SNAP выглядят практически одинаково. Заголовок "
"выглядит следующим образом:"

msgid ""
"<type>\\n                  SNAP\\n or XLOG\\n\n"
"<version>\\n               currently 0.13\\n\n"
"Server: <server_uuid>\\n   where UUID is a 36-byte string\n"
"VClock: <vclock_map>\\n    e.g. {1: 0}\\n\n"
"\\n"
msgstr ""
"<type>\\n                  SNAP\\n или XLOG\\n\n"
"<version>\\n               в данный момент 0.13\\n\n"
"Server: <server_uuid>\\n   где UUID -- это 36-байтная строка\n"
"VClock: <vclock_map>\\n    например, {1: 0}\\n\n"
"\\n"

msgid ""
"After the file header come the data tuples. Tuples begin with a row "
"marker ``0xd5ba0bab`` and the last tuple may be followed by an EOF marker"
" ``0xd510aded``. Thus, between the file header and the EOF marker, there "
"may be data tuples that have this form:"
msgstr ""
"После файла заголовка идут кортежи с данными. Кортежи начинаются с "
"маркера строки ``0xd5ba0bab``, а после последнего кортежа может стоять "
"маркер конца файла ``0xd510aded``. Таким образом, между заголовком файла "
"и маркером конца файла могут быть кортежи с данными в следующем виде:"

msgid ""
"0            3 4                                         17\n"
"+-------------+========+============+===========+=========+\n"
"|             |        |            |           |         |\n"
"| 0xd5ba0bab  | LENGTH | CRC32 PREV | CRC32 CUR | PADDING |\n"
"|             |        |            |           |         |\n"
"+-------------+========+============+===========+=========+\n"
"  MP_FIXEXT2    MP_INT     MP_INT       MP_INT      ---\n"
"\n"
"+============+ +===================================+\n"
"|            | |                                   |\n"
"|   HEADER   | |                BODY               |\n"
"|            | |                                   |\n"
"+============+ +===================================+\n"
"    MP_MAP                     MP_MAP"
msgstr ""
"0            3 4                                         17\n"
"+-------------+========+============+===========+=========+\n"
"|             |        |            |           |         |\n"
"| 0xd5ba0bab  | LENGTH | CRC32 PREV | CRC32 CUR | PADDING |\n"
"|             |        |            |           |         |\n"
"+-------------+========+============+===========+=========+\n"
"  MP_FIXEXT2    MP_INT     MP_INT       MP_INT      ---\n"
"\n"
"+============+ +===================================+\n"
"|            | |                                   |\n"
"|   HEADER   | |                BODY               |\n"
"|            | |                                   |\n"
"+============+ +===================================+\n"
"    MP_MAP                     MP_MAP"

msgid "See the example in the following section."
msgstr "См. пример в предыдущем разделе."

msgid "Data persistence and the WAL file format"
msgstr "Персистентность данных и формат WAL-файла"

msgid ""
"To maintain data persistence, Tarantool writes each data change request "
"(insert, update, delete, replace, upsert) into a write-ahead log (WAL) "
"file in the :ref:`wal_dir <cfg_basic-wal_dir>` directory. A new WAL file "
"is created for every :ref:`rows_per_wal <cfg_binary_logging_snapshots-"
"rows_per_wal>` records, or for every :ref:`wal_max_size "
"<cfg_binary_logging_snapshots-wal_max_size>` bytes. Each data change "
"request gets assigned a continuously growing 64-bit log sequence number. "
"The name of the WAL file is based on the log sequence number of the first"
" record in the file, plus an extension ``.xlog``."
msgstr ""
"Чтобы поддерживать персистентность данных, Tarantool записывает каждый "
"запрос изменения данных (insert, update, delete, replace, upsert) в файл "
"журнала упреждающей записи (WAL-файл) в директорию :ref:`wal_dir "
"<cfg_basic-wal_dir>`. Новый WAL-файл создается для количества записей, "
"определенного в параметре :ref:`rows_per_wal "
"<cfg_binary_logging_snapshots-rows_per_wal>`, или для количества байтов, "
"указанного в :ref:`wal_max_size <cfg_binary_logging_snapshots-"
"wal_max_size>` . Каждому запросу на изменение данных присваивается "
"постоянно возрастающее 64-битное число, представляющее собой "
"регистрационный номер в журнале (LSN). Название WAL-файла состоит из LSN "
"первой записи в файле плюс расширение ``.xlog``."

msgid ""
"Apart from a log sequence number and the data change request (formatted "
"as in :ref:`Tarantool's binary protocol <box_protocol-iproto_protocol>`),"
" each WAL record contains a header, some metadata, and then the data "
"formatted according to `msgpack "
"<https://en.wikipedia.org/wiki/MessagePack>`_ rules. For example, this is"
" what the WAL file looks like after the first INSERT request "
"(\"s:insert({1})\") for the sandbox database created in our "
":ref:`\"Getting started\" exercises <getting_started>`. On the left are "
"the hexadecimal bytes that you would see with:"
msgstr ""
"Помимо номера записи в журнале (LSN) и запроса на изменение данных (в "
"формате :ref:`бинарного протокола Tarantool'а <box_protocol-"
"iproto_protocol>`), каждая запись в WAL-файле содержит заголовок, "
"некоторые метаданные, а также данные, форматированные по правилам "
"`msgpack <https://en.wikipedia.org/wiki/MessagePack>`_. Например, так "
"выглядит WAL-файл после первого запроса вставки INSERT "
"(\"s:insert({1})\") для базы данных из песочницы, созданной в упражнениях"
" в :ref:`\"Руководстве для начинающих\" <getting_started>`. Слева "
"представлены шестнадцатеричные байты, которые можно просмотреть с "
"помощью:"

msgid "$ hexdump 00000000000000000000.xlog"
msgstr "$ hexdump 00000000000000000000.xlog"

msgid "and on the right are comments."
msgstr "а справа -- комментарии."

msgid ""
"Hex dump of WAL file       Comment\n"
"--------------------       -------\n"
"58 4c 4f 47 0a             \"XLOG\\n\"\n"
"30 2e 31 33 0a             \"0.13\\n\" = version\n"
"53 65 72 76 65 72 3a 20    \"Server: \"\n"
"38 62 66 32 32 33 65 30 2d [Server UUID]\\n\n"
"36 39 31 34 2d 34 62 35 35\n"
"2d 39 34 64 32 2d 64 32 62\n"
"36 64 30 39 62 30 31 39 36\n"
"0a\n"
"56 43 6c 6f 63 6b 3a 20    \"Vclock: \"\n"
"7b 7d                      \"{}\" = vclock value, initially blank\n"
"...                        (not shown = tuples for system spaces)\n"
"d5 ba 0b ab                Magic row marker always = 0xab0bbad5\n"
"19                         Length, not including length of header, = 25 "
"bytes\n"
"00                           Record header: previous crc32\n"
"ce 8c 3e d6 70               Record header: current crc32\n"
"a7 cc 73 7f 00 00 66 39      Record header: padding\n"
"84                         msgpack code meaning \"Map of 4 elements\" "
"follows\n"
"00 02                         element#1: tag=request type, "
"value=0x02=IPROTO_INSERT\n"
"02 01                         element#2: tag=server id, value=0x01\n"
"03 04                         element#3: tag=lsn, value=0x04\n"
"04 cb 41 d4 e2 2f 62 fd d5 d4 element#4: tag=timestamp, value=an 8-byte "
"\"Float64\"\n"
"82                         msgpack code meaning \"map of 2 elements\" "
"follows\n"
"10 cd 02 00                   element#1: tag=space id, value=512, big "
"byte first\n"
"21 91 01                      element#2: tag=tuple, value=1-element fixed"
" array={1}"
msgstr ""
"Шестнадцатеричный дамп WAL-файла       Комментарий\n"
"--------------------       -------\n"
"58 4c 4f 47 0a             \"XLOG\\n\"\n"
"30 2e 31 33 0a             \"0.13\\n\" = version\n"
"53 65 72 76 65 72 3a 20    \"Server: \"\n"
"38 62 66 32 32 33 65 30 2d [Server UUID]\\n\n"
"36 39 31 34 2d 34 62 35 35\n"
"2d 39 34 64 32 2d 64 32 62\n"
"36 64 30 39 62 30 31 39 36\n"
"0a\n"
"56 43 6c 6f 63 6b 3a 20    \"Vclock: \"\n"
"7b 7d                      \"{}\" = vclock value, initially blank\n"
"...                        (not shown = tuples for system spaces)\n"
"d5 ba 0b ab                Magic row marker always = 0xab0bbad5\n"
"19                         Length, not including length of header, = 25 "
"bytes\n"
"00                           Record header: previous crc32\n"
"ce 8c 3e d6 70               Record header: current crc32\n"
"a7 cc 73 7f 00 00 66 39      Record header: padding\n"
"84                         msgpack code meaning \"Map of 4 elements\" "
"follows\n"
"00 02                         element#1: tag=request type, "
"value=0x02=IPROTO_INSERT\n"
"02 01                         element#2: tag=server id, value=0x01\n"
"03 04                         element#3: tag=lsn, value=0x04\n"
"04 cb 41 d4 e2 2f 62 fd d5 d4 element#4: tag=timestamp, value=an 8-byte "
"\"Float64\"\n"
"82                         msgpack code meaning \"map of 2 elements\" "
"follows\n"
"10 cd 02 00                   element#1: tag=space id, value=512, big "
"byte first\n"
"21 91 01                      element#2: tag=tuple, value=1-element fixed"
" array={1}"

msgid "A tool for reading .xlog files is Tarantool's :ref:`xlog module <xlog>`."
msgstr ""
"Для чтения файлов в формате .xlog в Tarantool'е предусмотрен :ref:`модуль"
" xlog <xlog>`."

msgid ""
"Tarantool processes requests atomically: a change is either accepted and "
"recorded in the WAL, or discarded completely. Let's clarify how this "
"happens, using the REPLACE request as an example:"
msgstr ""
"Tarantool обрабатывает запросы атомарно: изменение либо принимается и "
"записывается в WAL-файл, или полностью исключается. Проясним, как этом "
"работает, используя в качестве примера REPLACE-запрос:"

msgid ""
"The server instance attempts to locate the original tuple by primary key."
" If found, a reference to the tuple is retained for later use."
msgstr ""
"Экземпляр сервера пытается найти оригинальный кортеж по первичному ключу."
" Если кортеж найден, ссылка на него сохраняется для дальнейшего "
"использования."

msgid ""
"The new tuple is validated. If for example it does not contain an indexed"
" field, or it has an indexed field whose type does not match the type "
"according to the index definition, the change is aborted."
msgstr ""
"Происходит проверка нового кортежа. Например, если в нем нет "
"проиндексированного поля, или же тип проиндексированного поля не "
"совпадает с типом в определении индекса, изменение прерывается."

msgid "The new tuple replaces the old tuple in all existing indexes."
msgstr "Новый кортеж заменяет старый кортеж во всех существующих индексах."

msgid ""
"A message is sent to the writer process running in the WAL thread, "
"requesting that the change be recorded in the WAL. The instance switches "
"to work on the next request until the write is acknowledged."
msgstr ""
"В процесс записи, запущенный в потоке журнала упреждающей записи, "
"отправляется сообщение о необходимости внесения записи в WAL-файл. "
"Экземпляр переключается на работу со следующим запросом, пока запись не "
"будет подтверждена."

msgid ""
"On success, a confirmation is sent to the client. On failure, a rollback "
"procedure is begun. During the rollback procedure, the transaction "
"processor rolls back all changes to the database which occurred after the"
" first failed change, from latest to oldest, up to the first failed "
"change. All rolled back requests are aborted with :errcode:`ER_WAL_IO "
"<ER_WAL_IO>` error. No new change is applied while rollback is in "
"progress. When the rollback procedure is finished, the server restarts "
"the processing pipeline."
msgstr ""
"При успешном выполнении на клиент отправляется подтверждение. В случае "
"ошибки начинается процедура отката. Во время процедуры отката поток "
"обработки транзакций откатывается все изменения в базу данных, которые "
"произошли после первого невыполненного изменения, от последнего с "
"первому, вплоть до первого невыполненного изменения. Все запросы, которые"
" подверглись откату, прерываются с ошибкой :errcode:`ER_WAL_IO "
"<ER_WAL_IO>`. Новые изменения не применяются во время отката. По "
"окончании процедуры отката сервер повторно запускает конвейер обработки "
"операций."

msgid ""
"One advantage of the described algorithm is that complete request "
"pipelining is achieved, even for requests on the same value of the "
"primary key. As a result, database performance doesn't degrade even if "
"all requests refer to the same key in the same space."
msgstr ""
"Одно из преимуществ описанного алгоритма заключается в том, что "
"достигается полная обработка запроса по конвейеру даже для запросов с "
"одинаковым значением первичного ключа. В результате производительность "
"базы данных не падает, даже если все запросы относятся к одному ключу в "
"одном спейсе."

msgid ""
"The transaction processor thread communicates with the WAL writer thread "
"using asynchronous (yet reliable) messaging; the transaction processor "
"thread, not being blocked on WAL tasks, continues to handle requests "
"quickly even at high volumes of disk I/O. A response to a request is sent"
" as soon as it is ready, even if there were earlier incomplete requests "
"on the same connection. In particular, SELECT performance, even for "
"SELECTs running on a connection packed with UPDATEs and DELETEs, remains "
"unaffected by disk load."
msgstr ""
"Поток обработки транзакций взаимодействует с потоком записи в журнал "
"упреждающей записи с помощью асинхронного (однако надежного) обмена "
"сообщениями. Поток обработки транзакций, который не блокируется при "
"задачах записи в журнал, продолжает быстро обрабатывать запрос даже при "
"большом объеме дискового ввода-вывода. Ответ на запрос отправляется по "
"готовности, даже если ранее на том же соединении были незавершенные "
"запросы. В частности, на производительность выборки не влияет загрузка "
"диска, даже если SELECT-запросы передаются вместе с запросами UPDATE и "
"DELETE."

msgid ""
"The WAL writer employs a number of durability modes, as defined in "
"configuration variable :ref:`wal_mode <index-wal_mode>`. It is possible "
"to turn the write-ahead log completely off, by setting :ref:`wal_mode "
"<cfg_binary_logging_snapshots-wal_mode>` to *none*. Even without the "
"write-ahead log it's still possible to take a persistent copy of the "
"entire data set with the :doc:`box.snapshot() "
"</reference/reference_lua/box_snapshot>` request."
msgstr ""
"При записи в WAL можно применять различные режимы долговечности, что "
"определяет конфигурационная переменная :ref:`wal_mode <index-wal_mode>`. "
"Можно полностью отключить журнал упреждающей записи, присвоив "
":ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>` значение *none*. "
"Даже без журнала упреждающей записи возможно сделать персистентную копию "
"всего набора данных с помощью запроса :doc:`box.snapshot() "
"</reference/reference_lua/box_snapshot>`."

msgid ""
"An .xlog file always contains changes based on the primary key. Even if "
"the client requested an update or delete using a secondary key, the "
"record in the .xlog file will contain the primary key."
msgstr ""
"Файл в формате .xlog всегда содержит изменения на основании первичного "
"ключа. Даже если клиент запрашивает обновление или удаление по вторичному"
" ключу, запись в файле в формате .xlog будет содержать первичный ключ."

msgid "The snapshot file format"
msgstr "Формат файла снимка"

msgid ""
"The format of a snapshot .snap file is nearly the same as the format of a"
" WAL .xlog file. However, the snapshot header differs: it contains the "
"instance's global unique identifier and the snapshot file's position in "
"history, relative to earlier snapshot files. Also, the content differs: "
"an .xlog file may contain records for any data-change requests (inserts, "
"updates, upserts, and deletes), a .snap file may only contain records of "
"inserts to memtx spaces."
msgstr ""
"Формат файла снимка .snap практически такой же, что и формат WAL-файла "
".xlog. Тем не менее, заголовок снимка отличается: он содержит глобально "
"уникальный идентификатор экземпляра и положения файла снимка в истории "
"относительно более ранних файлов снимка. Кроме того, отличается "
"содержание: .xlog-файл может содержать записи о любых запросах изменения "
"данных (вставка, обновление, обновление и вставка и удаление), а "
".snap-файл может содержать лишь записи о вставках в спейсы memtx'а."

msgid ""
"Primarily, the .snap file's records are ordered by space id. Therefore "
"the records of system spaces -- such as ``_schema``, ``_space``, "
"``_index``, ``_func``, ``_priv`` and ``_cluster`` -- will be at the start"
" of the .snap file, before the records of any spaces that were created by"
" users."
msgstr ""
"В первую очередь записи в .snap-файле упорядочены по идентификатору "
"спейса. Таким образом, записи в системные спейсы -- такие как "
"``_schema``, ``_space``, ``_index``, ``_func``, ``_priv`` и ``_cluster`` "
"-- будут находиться в начале .snap-файла до записей в другие спейсы, "
"созданные пользователями."

msgid ""
"Secondarily, the .snap file's records are ordered by primary key within "
"space id."
msgstr "Во вторую очередь записи в .snap-файле упорядочены по первичному ключу."

msgid "The recovery process"
msgstr "Процесс восстановления"

msgid ""
"The recovery process begins when box.cfg{} happens for the first time "
"after the Tarantool server instance starts."
msgstr ""
"Процесс восстановления начинается, когда box.cfg{} впервые используется "
"после запуска экземпляра Tarantool-сервера."

msgid ""
"The recovery process must recover the databases as of the moment when the"
" instance was last shut down. For this it may use the latest snapshot "
"file and any WAL files that were written after the snapshot. One "
"complicating factor is that Tarantool has two engines -- the memtx data "
"must be reconstructed entirely from the snapshot and the WAL files, while"
" the vinyl data will be on disk but might require updating around the "
"time of a checkpoint. (When a snapshot happens, Tarantool tells the vinyl"
" engine to make a checkpoint, and the snapshot operation is rolled back "
"if anything goes wrong, so vinyl's checkpoint is at least as fresh as the"
" snapshot file.)"
msgstr ""
"Процесс восстановления должен восстановить базы данных на момент "
"последнего отключения экземпляра. Для этого можно использовать последний "
"файл снимка и любые WAL-файлы, которые были записаны после создания "
"снимка. Ситуацию осложняет фактор того, что в Tarantool'е используются "
"два движка -- данные memtx'а должны быть реконструированы полностью из "
"снимка и WAL-файлов, тогда как данные vinyl'а будут находиться на диске, "
"но может потребоваться их обновление на время создания контрольной точки."
" (При создании снимка Tarantool передает движку vinyl команду создания "
"контрольной точки, а операция создания снимка откатывается в случае "
"какой-либо ошибки, поэтому контрольная точка vinyl'а будет настолько же "
"актуальной, как и файл снимка.)"

msgid "Step 1"
msgstr "Шаг 1"

msgid ""
"Read the configuration parameters in the ``box.cfg{}`` request. "
"Parameters which affect recovery may include :ref:`work_dir <cfg_basic-"
"work_dir>`, :ref:`wal_dir <cfg_basic-wal_dir>`, :ref:`memtx_dir "
"<cfg_basic-memtx_dir>`, :ref:`vinyl_dir <cfg_basic-vinyl_dir>` and "
":ref:`force_recovery <cfg_binary_logging_snapshots-force_recovery>`."
msgstr ""
"Выполнить чтение конфигурационных параметров из запроса ``box.cfg{}``. "
"Параметры, которые могут повлиять на восстановление: :ref:`work_dir "
"<cfg_basic-work_dir>`, :ref:`wal_dir <cfg_basic-wal_dir>`, "
":ref:`memtx_dir <cfg_basic-memtx_dir>`, :ref:`vinyl_dir <cfg_basic-"
"vinyl_dir>` и :ref:`force_recovery <cfg_binary_logging_snapshots-"
"force_recovery>`."

msgid "Step 2"
msgstr "Шаг 2"

msgid ""
"Find the latest snapshot file. Use its data to reconstruct the in-memory "
"databases. Instruct the vinyl engine to recover to the latest checkpoint."
msgstr ""
"Найти последний файл снимка. Использовать данные для реконструкции in-"
"memory баз данных. Передать команду vinyl'у о восстановлении до последней"
" контрольной точки."

msgid ""
"There are actually two variations of the reconstruction procedure for "
"memtx databases, depending on whether the recovery process is "
"\"default\"."
msgstr ""
"На самом деле, есть два варианта реконструкции баз данных memtx'а в "
"зависимости от того, выполняется ли стандартная процедура."

msgid ""
"If the recovery process is default (``force_recovery`` is ``false``), "
"memtx can read data in the snapshot with all indexes disabled. First, all"
" tuples are read into memory. Then, primary keys are built in bulk, "
"taking advantage of the fact that the data is already sorted by primary "
"key within each space."
msgstr ""
"Если выполняется стандартная процедура (``force_recovery`` = ``false``), "
"memtx может выполнить чтение данных из снимка с отключенными индексами. "
"Сначала все кортежи считываются в память. Затем происходит массовая "
"загрузка первичных ключей с учетом того, что данные уже отсортированы по "
"первичному ключу в каждом спейсе."

msgid ""
"If the recovery process is non-default (``force_recovery`` is ``true``), "
"Tarantool performs additional checking. Indexes are enabled at the start,"
" and tuples are added one by one. This means that any unique-key "
"constraint violations will be caught, and any duplicates will be skipped."
" Normally there will be no constraint violations or duplicates, so these "
"checks are only made if an error has occurred."
msgstr ""
"Если выполняется нестандартная процедура принудительного восстановления "
"(``force_recovery`` = ``true``), Tarantool проводит дополнительную "
"проверку. Сначала индексы активны, и кортежи добавляются по одному. Это "
"означает, что будут выявлены любые нарушения ограничений уникальности "
"ключей, и все повторяющиеся значения пропускаются. Как правило, не будет "
"нарушений ограничений или повторяющихся значений, поэтому такие проверки "
"проводятся только в случае ошибки."

msgid "Step 3"
msgstr "Шаг 3"

msgid ""
"Find the WAL file that was made at the time of, or after, the snapshot "
"file. Read its log entries until the log-entry LSN is greater than the "
"LSN of the snapshot, or greater than the LSN of the vinyl checkpoint. "
"This is the recovery process's \"start position\"; it matches the current"
" state of the engines."
msgstr ""
"Найти WAL-файл, который был создан во время создания файла снимка или "
"позже. Выполнить чтение записей журнала до тех пор, пока LSN записи в "
"журнале не будет больше LSN снимка или больше LSN контрольной точки в "
"vinyl'е. Это и будет начальной точкой для процесса восстановления, "
"которая соответствует текущему состоянию движков."

msgid "Step 4"
msgstr "Шаг 4"

msgid ""
"Redo the log entries, from the start position to the end of the WAL. The "
"engine skips a redo instruction if it is older than the engine's "
"checkpoint."
msgstr ""
"Повторить записи журнала с начальной точки до конца WAL. Движок "
"пропускает команду повторения, если данные старше контрольной точки "
"движка."

msgid "Step 5"
msgstr "Шаг 5"

msgid "For the memtx engine, re-create all secondary indexes."
msgstr "Повторно создать все вторичные индексы для движка memtx."
