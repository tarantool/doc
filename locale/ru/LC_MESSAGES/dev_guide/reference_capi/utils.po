# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the Tarantool package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
msgid ""
msgstr ""
"Project-Id-Version: Tarantool 1.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-02-06 14:05+0000\n"
"PO-Revision-Date: 2019-11-14 20:46+0300\n"
"Last-Translator: \n"
"Language: ru\n"
"Language-Team: \n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"

msgid "Module `lua/utils`"
msgstr "Модуль `lua/utils`"

msgid "Push cdata of given ``ctypeid`` onto the stack."
msgstr "Принудительная передача cdata заданного ``ctypeid`` в стек."

msgid ""
"CTypeID must be used from FFI at least once. Allocated memory returned "
"uninitialized. Only numbers and pointers are supported."
msgstr ""
"CTypeID должен быть использован хотя бы один раз из FFI. Выделенная "
"область памяти возвращается неинициализированной. Поддерживаются только "
"числа и указатели."

msgid "Parameters"
msgstr "Параметры"

msgid "Lua State"
msgstr "Lua_State"

msgid "FFI's CTypeID of this cdata"
msgstr "CTypeID из FFI для cdata "

msgid "Returns"
msgstr "Возвращает"

msgid "memory associated with this cdata"
msgstr "область памяти, ассоциированная с cdata"

msgid "See also: :ref:`luaL_checkcdata()<c_api-utils-luaL_checkcdata>`"
msgstr "См. также :ref:`luaL_checkcdata()<c_api-utils-luaL_checkcdata>`"

msgid "Check whether the function argument ``idx`` is a cdata."
msgstr "Проверка, является ли аргумент функции ``idx`` cdata."

msgid "stack index"
msgstr "индекс стека"

msgid "output argument. FFI's CTypeID of returned cdata"
msgstr "аргумент вывода. CTypeID из FFI для возвращаемого cdata "

msgid "See also: :ref:`luaL_pushcdata()<c_api-utils-luaL_pushcdata>`"
msgstr "См. также :ref:`luaL_pushcdata()<c_api-utils-luaL_pushcdata>`"

msgid "Set finalizer function on a cdata object."
msgstr "Определение функции-финализатора для cdata."

msgid ""
"Equivalent to call `ffi.gc(obj, function)`. Finalizer function must be on"
" the top of the stack."
msgstr ""
"Аналог вызова `ffi.gc(obj, function)`. Функция-финализатор должна быть на"
" вершине стека."

msgid "Return CTypeID (FFI) of given СDATA type."
msgstr "Возврат CTypeID (FFI) заданного типа СDATA."

msgid "C type name as string (e.g. \"struct request\" or \"uint32_t\")"
msgstr "Имя типа в C в виде строки (например, \"struct request\" или \"uint32_t\")"

msgid "CTypeID"
msgstr "CTypeID"

msgid ""
"See also: :ref:`luaL_pushcdata()<c_api-utils-luaL_pushcdata>`, "
":ref:`luaL_checkcdata()<c_api-utils-luaL_checkcdata>`"
msgstr ""
"См. также :ref:`luaL_pushcdata()<c_api-utils-luaL_pushcdata>`, "
":ref:`luaL_checkcdata()<c_api-utils-luaL_checkcdata>`"

msgid "Declare symbols for FFI."
msgstr "Объявление символов для FFI."

msgid "C definitions (e.g. \"struct stat\")"
msgstr "C-определения (например, \"struct stat\")"

msgid "0 on success"
msgstr "0, если выполнено"

msgid "``LUA_ERRRUN``, ``LUA_ERRMEM` or ``LUA_ERRERR`` otherwise."
msgstr "``LUA_ERRRUN``, ``LUA_ERRMEM` или ``LUA_ERRERR``, в противном случае."

msgid "See also: ``ffi.cdef(def)``"
msgstr "См. также ``ffi.cdef(def)``"

msgid "Push uint64_t onto the stack."
msgstr "Принудительная передача uint64_t в стек."

msgid "value to push"
msgstr "передаваемое значение"

msgid "Push int64_t onto the stack."
msgstr "Принудительная передача int64_t в стек."

msgid ""
"Check whether the argument idx is a uint64 or a convertable string and "
"returns this number."
msgstr ""
"Проверка, является ли аргумент idx uint64 или конвертируемой строкой, и "
"возврат этого числа."

msgid "throws"
msgstr "выбрасывает"

msgid "error if the argument can't be converted"
msgstr "ошибку, если аргумент нельзя конвертировать"

msgid ""
"Check whether the argument idx is a int64 or a convertable string and "
"returns this number."
msgstr ""
"Проверка, является ли аргумент idx int64 или конвертируемой строкой, и "
"возврат этого числа."

msgid "the converted number or 0 of argument can't be converted"
msgstr "конвертированное число или 0, если аргумент нельзя конвертировать"

msgid "Push a tuple onto the stack."
msgstr "Принудительная передача кортежа в стек."

msgid "error on OOM"
msgstr "ошибка при нехватке памяти"

msgid "See also: :ref:`luaT_istuple <c_api-utils-luaT_istuple>`"
msgstr "См. также :ref:`luaT_istuple <c_api-utils-luaT_istuple>`"

msgid "Check whether ``idx`` is a tuple."
msgstr "Проверка, является ли ``idx`` кортежем."

msgid "the stack index"
msgstr "индекс стека"

msgid "non-NULL if ``idx`` is a tuple"
msgstr "не NULL, если ``idx`` -- это кортеж"

msgid "NULL if ``idx`` is not a tuple"
msgstr "NULL, если ``idx`` -- это не кортеж"

msgid "Re-throw the last Tarantool error as a Lua object."
msgstr "Повторение последней ошибки в Tarantool'е в виде Lua-объекта."

msgid ""
"See also: `lua_error() "
"<https://www.lua.org/manual/5.1/manual.html#lua_error>`_,"
msgstr ""
"См. также `lua_error() "
"<https://www.lua.org/manual/5.1/manual.html#lua_error>`_,"

msgid ":ref:`box_error_last() <c_api-error-box_error_last>`."
msgstr ":ref:`box_error_last() <c_api-error-box_error_last>`."

msgid ""
"Similar to `lua_cpcall() "
"<https://www.lua.org/manual/5.1/manual.html#lua_cpcall>`_, but with the "
"proper support of Tarantool errors."
msgstr ""
"Аналог `lua_cpcall() "
"<https://www.lua.org/manual/5.1/manual.html#lua_cpcall>`_, но с "
"соответствующей поддержкой ошибок Tarantool'а."

msgid "Get the global Lua state used by Tarantool."
msgstr "Получение глобального состояния Lua, используемого Tarantool'ом."
