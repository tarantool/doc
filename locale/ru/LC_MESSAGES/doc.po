# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the Tarantool package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
#
msgid ""
msgstr ""
"Project-Id-Version: PROJECT VERSION\n"
"Report-Msgid-Bugs-To: EMAIL@ADDRESS\n"
"POT-Creation-Date: 2017-09-26 12:17+0300\n"
"PO-Revision-Date: 2017-09-27 19:51+0300\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.4.0\n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: ru\n"
"X-Generator: Poedit 2.0.3\n"

#: ../doc/1.7/book/admin/backups.rst:39
msgid "Backups"
msgstr "Резервное копирование"

#: ../doc/1.7/book/admin/backups.rst:41
msgid ""
"Tarantool storage architecture is append-only: files are only appended to, and "
"are never overwritten. Old files are removed by garbage collection after a "
"checkpoint. You can configure the amount of past checkpoints preserved by "
"garbage collection by configuring Tarantool's :ref:`checkpoint daemon "
"<book_cfg_checkpoint_daemon>`. Backups can be taken at any time, with minimal "
"overhead on database performance."
msgstr ""
"Архитектура Tarantool-хранилища позволяет производить только запись в конец "
"файлов: сами файлы никогда не перезаписываются. Старые файлы удаляются сборщиком "
"мусора после определенной контрольной точки. В настройках :ref:`файбера "
"<book_cfg_checkpoint_daemon>`, отвечающего за работу с контрольными точками, "
"можно указать, какое количество предыдущих контрольных точек сборщик мусора "
"должен оставить."

#: ../doc/1.7/book/admin/backups.rst:52
msgid "Hot backup (memtx)"
msgstr "Горячее резервирование (memtx)"

#: ../doc/1.7/book/admin/backups.rst:54
msgid "This is a special case when there are only in-memory tables."
msgstr "Это особый случай, когда все таблицы хранятся в памяти."

#: ../doc/1.7/book/admin/backups.rst:56
msgid ""
"The last :ref:`snapshot file<index-box_persistence>` is a backup of the entire "
"database; and the :ref:`WAL<internals-wal>` files that are made after the last "
"snapshot are incremental backups. Therefore taking a backup is a matter of "
"copying the snapshot and WAL files."
msgstr ""
"Последний созданный Tarantool'ом :ref:`файл-снимок <index-box_persistence>` "
"является резервной копией всей базы данных; а созданные следом :ref:`WAL-файлы "
"<internals-wal>` являются инкрементными копиями. Поэтому процедура "
"резервирования сводится к копированию последнего файла-снимка и следующих за ним "
"WAL-файлов."

#: ../doc/1.7/book/admin/backups.rst:61
msgid ""
"Use ``tar`` to make a (possibly compressed) copy of the latest .snap and .xlog "
"files on the :ref:`memtx_dir <cfg_basic-memtx_dir>` and :ref:`wal_dir <cfg_basic-"
"wal_dir>` directories."
msgstr ""
"С помощью ``tar`` создайте (сжатую) копию последнего .snap-файла и следующих за "
"ним .xlog-файлов из директорий :ref:`memtx_dir <cfg_basic-memtx_dir>` и :ref:"
"`wal_dir <cfg_basic-wal_dir>`."

#: ../doc/1.7/book/admin/backups.rst:65
msgid "If there is a security policy, encrypt the .tar file."
msgstr "Если того требуют правила безопасности, зашифруйте получившийся .tar-файл."

#: ../doc/1.7/book/admin/backups.rst:67
msgid "Copy the .tar file to a safe place."
msgstr "Скопируйте .tar-файл в надежное место."

#: ../doc/1.7/book/admin/backups.rst:69
msgid ""
"Later, restoring the database is a matter of taking the .tar file and putting "
"its contents back in the memtx_dir and wal_dir directories."
msgstr ""
"В дальнейшем базу данных можно восстановить, разархивировав содержимое .tar-"
"файла в директории ``memtx_dir`` и ``wal_dir``."

#: ../doc/1.7/book/admin/backups.rst:76
msgid "Hot backup (vinyl/memtx)"
msgstr "Горячее резервирование (vinyl/memtx)"

#: ../doc/1.7/book/admin/backups.rst:78
msgid ""
"Vinyl stores its files in :ref:`vinyl_dir <cfg_basic-vinyl_dir>`, and creates a "
"folder for each database space. Dump and compaction processes are append-only "
"and create new files. Old files are garbage collected after each checkpoint."
msgstr ""
"Vinyl хранит свои файлы в :ref:`vinyl_dir <cfg_basic-vinyl_dir>` и создает для "
"каждого спейса в базе данных отдельную поддиректорию. Создание дампов и "
"компактификация - это процессы, которые могут лишь добавлять записи в конец "
"файла, поэтому в результате создаются новые файлы. Старые же удаляются сборщиком "
"мусора после каждой контрольной точки."

#: ../doc/1.7/book/admin/backups.rst:82
msgid "To take a mixed backup:"
msgstr "Для создания смешанной резервной копии:"

#: ../doc/1.7/book/admin/backups.rst:84
msgid ""
"Issue ``box.backup.start()`` on the :ref:`administrative console <admin-"
"security>`. This will suspend garbage collection till the next ``box.backup."
"stop()`` and will return a list of files to backup."
msgstr ""
"Выполните команду `box.backup.start()`` в :ref:`административной консоли <admin-"
"security>`. Эта команда приостановит сборку мусора до вызова ``box.backup."
"stop()`` и покажет список файлов для резервирования."

#: ../doc/1.7/book/admin/backups.rst:88
msgid ""
"Copy the files from the list to a safe location. This will include memtx "
"snapshot files, vinyl run and index files, at a state consistent with the last "
"checkpoint."
msgstr ""
"Скопируйте файлы из списка в надежное место. Это касается файлов-снимков memtx, "
"выполняемых vinyl-файлов и индексных файлов, соответствующих последней "
"контрольной точке."

#: ../doc/1.7/book/admin/backups.rst:92
msgid "Resume garbage collection with ``box.backup.stop()``."
msgstr "Возобновите сборку мусора с помощью команды ``box.backup.stop()``."

#: ../doc/1.7/book/admin/backups.rst:98
msgid "Continuous remote backup (memtx)"
msgstr "Непрерывное удаленное резервирование"

#: ../doc/1.7/book/admin/backups.rst:100
msgid ""
"The :ref:`replication <replication>` feature is useful for backup as well as for "
"load balancing."
msgstr ""
":ref:`Репликация <replication>` используется не только для резервирования, но и "
"для выравнивания нагрузки."

#: ../doc/1.7/book/admin/backups.rst:103
msgid ""
"Therefore taking a backup is a matter of ensuring that any given replica is up "
"to date, and doing a cold backup on it. Since all the other replicas continue to "
"operate, this is not a cold backup from the end user’s point of view. This could "
"be done on a regular basis, with a ``cron`` job or with a Tarantool fiber."
msgstr ""
"Поэтому процесс создания резервной копии сводится к обновлению (при "
"необходимости) одной из реплик с последующим холодным резервированием. Так как "
"все остальные реплики продолжают функционировать, с точки зрения конечного "
"пользователя, этот процесс не является холодным резервированием. Такое "
"резервирование можно выполнять регулярно с помощью планировщика ``cron`` или "
"файбера Tarantool'а."

#: ../doc/1.7/book/admin/backups.rst:112
msgid "Continuous backup (memtx)"
msgstr "Непрерывное резервирование"

#: ../doc/1.7/book/admin/backups.rst:114
msgid ""
"The logged changes done since the last cold backup must be secured, while the "
"system is running."
msgstr ""
"По ходу работы системы необходимо сохранять записи об изменениях, внесенных со "
"времени последнего холодного резервирования."

#: ../doc/1.7/book/admin/backups.rst:117
msgid ""
"For this purpose, you need a file copy utility that will do the copying remotely "
"and continuously, copying only the parts of a write ahead log file that are "
"changing. One such utility is `rsync <https://en.wikipedia.org/wiki/Rsync>`_."
msgstr ""
"Для этого нужна специальная утилита для копирования файлов (например, `rsync "
"<https://en.wikipedia.org/wiki/rsync>`_), которая позволит удаленно и на "
"постоянной основе копировать только изменившиеся части WAL-файла, а не весь файл "
"целиком."

#: ../doc/1.7/book/admin/backups.rst:122
msgid ""
"Alternatively, you need an ordinary file copy utility, but there should be "
"frequent production of new snapshot files or new WAL files as changes occur, so "
"that only the new files need to be copied."
msgstr ""
"Можно взять и обычную утилиту для копирования целых файлов, но тогда придется "
"создавать файлы-снимки и WAL-файлы на каждое изменение, чтобы нужно было "
"копировать только новые файлы."

#: ../doc/1.7/book/admin/bug_reports.rst:39
msgid "Bug reports"
msgstr "Сообщения об ошибках"

#: ../doc/1.7/book/admin/bug_reports.rst:41
msgid ""
"If you found a bug in Tarantool, you’re doing us a favor by taking the time to "
"tell us about it."
msgstr "Если вы нашли ошибку в Tarantool, вы окажете нам услугу, сообщив о ней."

#: ../doc/1.7/book/admin/bug_reports.rst:44
msgid ""
"Please create an issue at Tarantool repository at GitHub. We encourage you to "
"include the following information:"
msgstr ""
"Пожалуйста, откройте тикет в репозитории Tarantool на GitHub. Рекомендуем "
"включить следующую информацию:"

#: ../doc/1.7/book/admin/bug_reports.rst:47
msgid ""
"Steps needed to reproduce the bug, and an explanation why this differs from the "
"expected behavior according to our manual. Please provide specific unique "
"information. For example, instead of \"I can’t get certain information\", say "
"\"box.space.x:delete() didn’t report what was deleted\"."
msgstr ""
"Шаги для воспроизведения ошибки с объяснением того, как ошибочное поведение "
"отличается от описанного в документации ожидаемого поведения. Пожалуйста, "
"указывайте как можно более конкретную информацию. Например, вместо \"Я не могу "
"получить определенную информацию\" лучше написать \"box.space.x:delete() не "
"указывает, что именно было удалено\"."

#: ../doc/1.7/book/admin/bug_reports.rst:52
msgid ""
"Your operating system name and version, the Tarantool name and version, and any "
"unusual details about your machine and its configuration."
msgstr ""
"Название и версию вашей операционной системы, название и версию Tarantool и "
"любую информацию об особенностях вашей машины и ее конфигурации."

#: ../doc/1.7/book/admin/bug_reports.rst:55
msgid ""
"Related files like a :ref:`stack trace <admin-stack_traces>` or a Tarantool :ref:"
"`log file <admin-logs>`."
msgstr ""
"Сопутствующие файлы -- такие как :ref:`трассировка стека <admin-stack_traces>` "
"или :ref:`файл журнала <admin-logs>` Tarantool'а."

#: ../doc/1.7/book/admin/bug_reports.rst:58
msgid ""
"If this is a feature request or if it affects a special category of users, be "
"sure to mention that."
msgstr ""
"Если это запрос новой функциональности или это затрагивает определенную группу "
"пользователей, не забудьте это указать."

#: ../doc/1.7/book/admin/bug_reports.rst:61
msgid ""
"Usually within one or two workdays a Tarantool team member will write an "
"acknowledgment, or some questions, or suggestions for a workaround."
msgstr ""
"Обычно член команды Tarantool отвечает в течение одного-двух рабочих дней, чтобы "
"подтвердить, что тикет взят в работу, задать уточняющие вопросы или предложить "
"альтернативное решение описанной проблемы."

#: ../doc/1.7/book/admin/daemon_supervision.rst:39
msgid "Daemon supervision"
msgstr "Контроль за фоновыми программами"

#: ../doc/1.7/book/admin/daemon_supervision.rst:45
msgid "Server signals"
msgstr "Сигналы от сервера"

#: ../doc/1.7/book/admin/daemon_supervision.rst:47
#, fuzzy
msgid ""
"Tarantool processes these signals during the event loop in the transaction "
"processor thread:"
msgstr ""
"Во время основного событийного цикла Tarantool-сервер обрабатывает следующие "
"сигналы:"

#: ../doc/1.7/book/admin/daemon_supervision.rst:56
msgid "Signal"
msgstr "Сигнал"

#: ../doc/1.7/book/admin/daemon_supervision.rst:56
#: ../doc/1.7/book/box/box_schema.rst:69 ../doc/1.7/book/box/box_space.rst:266
#: ../doc/1.7/book/box/data_model.rst:659
msgid "Effect"
msgstr "Эффект"

#: ../doc/1.7/book/admin/daemon_supervision.rst:58
msgid "SIGHUP"
msgstr "SIGHUP"

#: ../doc/1.7/book/admin/daemon_supervision.rst:58
msgid ""
"May cause log file rotation. See the :ref:`example <cfg_logging-"
"logging_example>` in reference on Tarantool logging parameters."
msgstr ""
"Может привести к ротации журналов, см. :ref:`пример <cfg_logging-"
"logging_example>` в справочнике по параметрам журналирования Tarantool'а."

#: ../doc/1.7/book/admin/daemon_supervision.rst:62
msgid "SIGUSR1"
msgstr "SIGUSR1"

#: ../doc/1.7/book/admin/daemon_supervision.rst:62
msgid "May cause a database checkpoint. See :ref:`box.snapshot <box-snapshot>`."
msgstr ""
"Может привести к созданию снимка состояния базы данных, см. описание функции :"
"ref:`box.snapshot <box-snapshot>`."

#: ../doc/1.7/book/admin/daemon_supervision.rst:65
msgid "SIGTERM"
msgstr "SIGTERM"

#: ../doc/1.7/book/admin/daemon_supervision.rst:65
msgid "May cause graceful shutdown (information will be saved first)."
msgstr ""
"Может привести к корректному завершению работы (с предварительным сохранением "
"всех данных)."

#: ../doc/1.7/book/admin/daemon_supervision.rst:68
msgid "SIGINT (also known as keyboard interrupt)"
msgstr "SIGINT (или \"прерывание от клавиатуры\")"

#: ../doc/1.7/book/admin/daemon_supervision.rst:68
msgid "May cause graceful shutdown."
msgstr "Может привести к корректному завершению работы."

#: ../doc/1.7/book/admin/daemon_supervision.rst:72
msgid "SIGKILL"
msgstr "SIGKILL"

#: ../doc/1.7/book/admin/daemon_supervision.rst:72
msgid "Causes an immediate shutdown."
msgstr "Приводит к аварийному завершению работы."

#: ../doc/1.7/book/admin/daemon_supervision.rst:75
#, fuzzy
msgid ""
"Other signals will result in behavior defined by the operating system. Signals "
"other than SIGKILL may be ignored, especially if Tarantool is executing a long-"
"running procedure which prevents return to the event loop in the transaction "
"processor thread."
msgstr ""
"Остальные сигналы приводят к заданному операционной системой поведению. Все "
"сигналы, за исключением SIGKILL, можно игнорировать, особенно если Tarantool "
"выполняет требующую много времени процедуру и не может вернуться в основной "
"событийный цикл."

#: ../doc/1.7/book/admin/daemon_supervision.rst:84
msgid "Automatic instance restart"
msgstr "Автоматическая перезагрузка экземпляра"

#: ../doc/1.7/book/admin/daemon_supervision.rst:86
msgid ""
"On ``systemd``-enabled platforms, ``systemd`` automatically restarts all "
"Tarantool instances in case of failure. To demonstrate it, let’s try to destroy "
"an instance:"
msgstr ""
"На платформах, где доступна утилита ``systemd``, ``systemd`` автоматически "
"перезагружает все экземпляры Tarantool'а при сбое. Чтобы продемонстрировать это, "
"отключим один из экземпляров:"

#: ../doc/1.7/book/admin/daemon_supervision.rst:90
msgid ""
"$ systemctl status tarantool@my_app|grep PID\n"
"Main PID: 5885 (tarantool)\n"
"$ tarantoolctl enter my_app\n"
"/bin/tarantoolctl: Found my_app.lua in /etc/tarantool/instances.available\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/my_app.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/my_app.control\n"
"unix/:/var/run/tarantool/my_app.control> os.exit(-1)\n"
"/bin/tarantoolctl: unix/:/var/run/tarantool/my_app.control: Remote host closed "
"connection"
msgstr ""
"$ systemctl status tarantool@my_app|grep PID\n"
"Main PID: 5885 (tarantool)\n"
"$ tarantoolctl enter my_app\n"
"/bin/tarantoolctl: Found my_app.lua in /etc/tarantool/instances.available\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/my_app.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/my_app.control\n"
"unix/:/var/run/tarantool/my_app.control> os.exit(-1)\n"
"/bin/tarantoolctl: unix/:/var/run/tarantool/my_app.control: Remote host closed "
"connection"

#: ../doc/1.7/book/admin/daemon_supervision.rst:101
msgid "Now let’s make sure that ``systemd`` has restarted the instance:"
msgstr "А теперь убедимся, что ``systemd`` перезапустила его:"

#: ../doc/1.7/book/admin/daemon_supervision.rst:103
msgid ""
"$ systemctl status tarantool@my_app|grep PID\n"
"Main PID: 5914 (tarantool)"
msgstr ""
"$ systemctl status tarantool@my_app|grep PID\n"
"Main PID: 5914 (tarantool)"

#: ../doc/1.7/book/admin/daemon_supervision.rst:108
msgid "Finally, let’s check the boot logs:"
msgstr "И под конец проверим содержимое журнала загрузки:"

#: ../doc/1.7/book/admin/daemon_supervision.rst:110
msgid ""
"$ journalctl -u tarantool@my_app -n 8\n"
"-- Logs begin at Fri 2016-01-08 12:21:53 MSK, end at Thu 2016-01-21 21:09:45 "
"MSK. --\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: tarantool@my_app.service: Unit "
"entered failed state.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: tarantool@my_app.service: "
"Failed with result 'exit-code'.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: tarantool@my_app.service: "
"Service hold-off time over, scheduling restart.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Stopped Tarantool Database "
"Server.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Starting Tarantool Database "
"Server...\n"
"Jan 21 21:09:45 localhost.localdomain tarantoolctl[5910]: /usr/bin/tarantoolctl: "
"Found my_app.lua in /etc/tarantool/instances.available\n"
"Jan 21 21:09:45 localhost.localdomain tarantoolctl[5910]: /usr/bin/tarantoolctl: "
"Starting instance...\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Started Tarantool Database "
"Server."
msgstr ""
"$ journalctl -u tarantool@my_app -n 8\n"
"-- Logs begin at Fri 2016-01-08 12:21:53 MSK, end at Thu 2016-01-21 21:09:45 "
"MSK. --\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: tarantool@my_app.service: Unit "
"entered failed state.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: tarantool@my_app.service: "
"Failed with result 'exit-code'.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: tarantool@my_app.service: "
"Service hold-off time over, scheduling restart.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Stopped Tarantool Database "
"Server.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Starting Tarantool Database "
"Server...\n"
"Jan 21 21:09:45 localhost.localdomain tarantoolctl[5910]: /usr/bin/tarantoolctl: "
"Found my_app.lua in /etc/tarantool/instances.available\n"
"Jan 21 21:09:45 localhost.localdomain tarantoolctl[5910]: /usr/bin/tarantoolctl: "
"Starting instance...\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Started Tarantool Database "
"Server."

#: ../doc/1.7/book/admin/daemon_supervision.rst:127
msgid "Core dumps"
msgstr "Создание дампов памяти"

#: ../doc/1.7/book/admin/daemon_supervision.rst:129
msgid ""
"Tarantool makes a core dump if it receives any of the following signals: "
"SIGSEGV, SIGFPE, SIGABRT or SIGQUIT. This is automatic if Tarantool crashes."
msgstr ""
"Tarantool создает дамп памяти при получении одного из следующих сигналов: "
"SIGSEGV, SIGFPE, SIGABRT или SIGQUIT. При сбое Tarantool'а дамп создается "
"автоматически."

#: ../doc/1.7/book/admin/daemon_supervision.rst:132
msgid ""
"On ``systemd``-enabled platforms, ``coredumpctl`` automatically saves core dumps "
"and stack traces in case of a crash. Here is a general \"how to\" for how to "
"enable core dumps on a Unix system:"
msgstr ""
"На платформах, где доступна утилита ``systemd``, ``coredumpctl`` автоматически "
"сохраняет дампы памяти и трассировку стека при аварийном завершении Tarantool-"
"сервера. Вот как включить создание дампов памяти в Unix-системе:"

#: ../doc/1.7/book/admin/daemon_supervision.rst:136
msgid ""
"Ensure session limits are configured to enable core dumps, i.e. say ``ulimit -c "
"unlimited``. Check  \"man 5 core\" for other reasons why a core dump may not be "
"produced."
msgstr ""
"Убедитесь, что лимиты для сессии установлены таким образом, чтобы можно было "
"создавать дампы памяти, - выполните команду ``ulimit -c unlimited``. Также "
"проверьте \"man 5 core\" на другие причины, по которым дамп памяти может не "
"создаваться."

#: ../doc/1.7/book/admin/daemon_supervision.rst:140
msgid ""
"Set a directory for writing core dumps to, and make sure that the directory is "
"writable. On Linux, the directory path is set in a kernel parameter configurable "
"via ``/proc/sys/kernel/core_pattern``."
msgstr ""
"Создайте директорию для записи дампов памяти и убедитесь, что в эту директорию "
"действительно можно производить запись. На Linux путь до директории задается в "
"параметре ядра, который настраивается через ``/proc/sys/kernel/core_pattern``."

#: ../doc/1.7/book/admin/daemon_supervision.rst:144
msgid ""
"Make sure that core dumps include stack trace information. If you use a binary "
"Tarantool distribution, this is automatic. If you build Tarantool from source, "
"you will not get detailed information if you pass ``-DCMAKE_BUILD_TYPE=Release`` "
"to CMake."
msgstr ""
"Убедитесь, что дампы памяти включают трассировку стека. При использовании "
"бинарного дистрибутива Tarantool'а эта информация включается автоматически. При "
"сборке Tarantool'а из исходников, если передать CMake флаг ``-"
"DCMAKE_BUILD_TYPE=Release``, вы не получите подробной информации."

#: ../doc/1.7/book/admin/daemon_supervision.rst:149
msgid ""
"To simulate a crash, you can execute an illegal command against a Tarantool "
"instance:"
msgstr ""
"Для симуляции сбоя можно попытаться выполнить нелегальную команду на работающем "
"экземпляре Tarantool'а:"

#: ../doc/1.7/book/admin/daemon_supervision.rst:152
msgid ""
"$ # !!! please never do this on a production system !!!\n"
"$ tarantoolctl enter my_app\n"
"unix/:/var/run/tarantool/my_app.control> require('ffi').cast('char *', 0)[0] = "
"48\n"
"/bin/tarantoolctl: unix/:/var/run/tarantool/my_app.control: Remote host closed "
"connection"
msgstr ""
"$ # !!! пожалуйста, никогда не делайте этого на боевом сервере !!!\n"
"$ tarantoolctl enter my_app\n"
"unix/:/var/run/tarantool/my_app.control> require('ffi').cast('char *', 0)[0] = "
"48\n"
"/bin/tarantoolctl: unix/:/var/run/tarantool/my_app.control: Remote host closed "
"connection"

#: ../doc/1.7/book/admin/daemon_supervision.rst:159
msgid ""
"Alternatively, if you know the process ID of the instance (here we refer to it "
"as $PID), you can abort a Tarantool instance by running ``gdb`` debugger:"
msgstr ""
"Есть другой способ: если вы знаете PID экземпляра ($PID в нашем примере), можно "
"остановить этот экземпляр, запустив отладчик ``gdb``:"

#: ../doc/1.7/book/admin/daemon_supervision.rst:162
msgid "$ gdb -batch -ex \"generate-core-file\" -p $PID"
msgstr "$ gdb -batch -ex \"generate-core-file\" -p $PID"

#: ../doc/1.7/book/admin/daemon_supervision.rst:166
msgid "or manually sending a SIGABRT signal:"
msgstr "или послав вручную сигнал SIGABRT:"

#: ../doc/1.7/book/admin/daemon_supervision.rst:168
msgid "$ kill -SIGABRT $PID"
msgstr "$ kill -SIGABRT $PID"

#: ../doc/1.7/book/admin/daemon_supervision.rst:174
msgid "To find out the process id of the instance ($PID), you can:"
msgstr "Чтобы узнать PID экземпляра, можно:"

#: ../doc/1.7/book/admin/daemon_supervision.rst:176
msgid ""
"look it up in the instance's :ref:`box.info.pid <box_introspection-box_info>`,"
msgstr "посмотреть его с помощью :ref:`box.info.pid <box_introspection-box_info>`,"

#: ../doc/1.7/book/admin/daemon_supervision.rst:178
msgid "find it with ``ps -A | grep tarantool``, or"
msgstr "использовать команду ``ps -A | grep tarantool``, или"

#: ../doc/1.7/book/admin/daemon_supervision.rst:180
msgid "say ``systemctl status tarantool@my_app|grep PID``."
msgstr "выполнить ``systemctl status tarantool@my_app|grep PID``."

#: ../doc/1.7/book/admin/daemon_supervision.rst:182
msgid ""
"On a ``systemd-enabled`` system, to see the latest crashes of the Tarantool "
"daemon, say:"
msgstr ""
"Чтобы посмотреть на последние сбои Tarantool-демона на платформах, где доступна "
"утилита ``systemd``, выполните команду:"

#: ../doc/1.7/book/admin/daemon_supervision.rst:185
msgid ""
"$ coredumpctl list /usr/bin/tarantool\n"
"MTIME                            PID   UID   GID SIG PRESENT EXE\n"
"Sat 2016-01-23 15:21:24 MSK   20681  1000  1000   6   /usr/bin/tarantool\n"
"Sat 2016-01-23 15:51:56 MSK   21035   995   992   6   /usr/bin/tarantool"
msgstr ""
"$ coredumpctl list /usr/bin/tarantool\n"
"MTIME                            PID   UID   GID SIG PRESENT EXE\n"
"Sat 2016-01-23 15:21:24 MSK   20681  1000  1000   6   /usr/bin/tarantool\n"
"Sat 2016-01-23 15:51:56 MSK   21035   995   992   6   /usr/bin/tarantool"

#: ../doc/1.7/book/admin/daemon_supervision.rst:192
msgid "To save a core dump into a file, say:"
msgstr "Чтобы сохранить дамп памяти в файл, выполните команду:"

#: ../doc/1.7/book/admin/daemon_supervision.rst:194
msgid "$ coredumpctl -o filename.core info <pid>"
msgstr "$ coredumpctl -o filename.core info <pid>"

#: ../doc/1.7/book/admin/daemon_supervision.rst:202
msgid "Stack traces"
msgstr "Трассировка стека"

#: ../doc/1.7/book/admin/daemon_supervision.rst:204
msgid ""
"Since Tarantool stores tuples in memory, core files may be large. For "
"investigation, you normally don't need the whole file, but only a \"stack trace"
"\" or \"backtrace\"."
msgstr ""
"Так как Tarantool хранит кортежи в памяти, файлы с дампами памяти могут быть "
"довольно большими. Чтобы найти проблему, обычно целый файл не нужен - достаточно "
"только \"трассировки стека\" или \"обратной трассировки\"."

#: ../doc/1.7/book/admin/daemon_supervision.rst:208
msgid "To save a stack trace into a file, say:"
msgstr "Чтобы сохранить трассировку стека в файл, выполните команду:"

#: ../doc/1.7/book/admin/daemon_supervision.rst:210
msgid ""
"$ gdb -se \"tarantool\" -ex \"bt full\" -ex \"thread apply all bt\" --batch -c "
"core> /tmp/tarantool_trace.txt"
msgstr ""
"$ gdb -se \"tarantool\" -ex \"bt full\" -ex \"thread apply all bt\" --batch -c "
"core> /tmp/tarantool_trace.txt"

#: ../doc/1.7/book/admin/daemon_supervision.rst:214
#: ../doc/1.7/book/admin/instance_config.rst:146
#: ../doc/1.7/book/replication/repl_bootstrap.rst:73
#: ../doc/1.7/reference/tarantoolctl.rst:58
msgid "where:"
msgstr "где:"

#: ../doc/1.7/book/admin/daemon_supervision.rst:216
msgid "\"tarantool\" is the path to the Tarantool executable,"
msgstr "\"tarantool\" - это путь до исполняемого файла Tarantool'а,"

#: ../doc/1.7/book/admin/daemon_supervision.rst:217
msgid "\"core\" is the path to the core file, and"
msgstr "\"core\" - это путь до файла с дампом памяти, и"

#: ../doc/1.7/book/admin/daemon_supervision.rst:218
msgid ""
"\"/tmp/tarantool_trace.txt\" is a sample path to a file for saving the stack "
"trace."
msgstr ""
"\"/tmp/tarantool_trace.txt\" - это пример пути до файла, в который сохраняется "
"трассировка стека."

#: ../doc/1.7/book/admin/daemon_supervision.rst:222
msgid ""
"Occasionally, you may find that the trace file contains output without debug "
"symbols – the lines will contain ”??” instead of names. If this happens, check "
"the instructions on these Tarantool wiki pages: `How to debug core dump of "
"stripped tarantool <https://github.com/tarantool/tarantool/wiki/How-to-debug-"
"core-dump-of-stripped-tarantool>`_ and `How to debug core from different OS "
"<https://github.com/tarantool/tarantool/wiki/How-to-debug-core-from-different-"
"OS>`_."
msgstr ""
"Иногда может оказаться, что файл с трассировкой стека не содержит отладочных "
"символов - в таких строках вместо имени будет стоять ”??”. Если это произошло, "
"ознакомьтесь с инструкциями на этих двух wiki-страницах Tarantool'а: `How to "
"debug core dump of stripped tarantool <https://github.com/tarantool/tarantool/"
"wiki/How-to-debug-core-dump-of-stripped-tarantool>`_ и `How to debug core from "
"different OS <https://github.com/tarantool/tarantool/wiki/How-to-debug-core-from-"
"different-OS>`_."

#: ../doc/1.7/book/admin/daemon_supervision.rst:229
msgid "To see the stack trace and other useful information in console, say:"
msgstr ""
"Чтобы получить трассировку стека и прочую полезную информацию в консоли, "
"выполните команду:"

#: ../doc/1.7/book/admin/daemon_supervision.rst:231
msgid ""
"$ coredumpctl info 21035\n"
"          PID: 21035 (tarantool)\n"
"          UID: 995 (tarantool)\n"
"          GID: 992 (tarantool)\n"
"       Signal: 6 (ABRT)\n"
"    Timestamp: Sat 2016-01-23 15:51:42 MSK (4h 36min ago)\n"
" Command Line: tarantool my_app.lua <running>\n"
"   Executable: /usr/bin/tarantool\n"
"Control Group: /system.slice/system-tarantool.slice/tarantool@my_app.service\n"
"         Unit: tarantool@my_app.service\n"
"        Slice: system-tarantool.slice\n"
"      Boot ID: 7c686e2ef4dc4e3ea59122757e3067e2\n"
"   Machine ID: a4a878729c654c7093dc6693f6a8e5ee\n"
"     Hostname: localhost.localdomain\n"
"      Message: Process 21035 (tarantool) of user 995 dumped core.\n"
"\n"
"               Stack trace of thread 21035:\n"
"               #0  0x00007f84993aa618 raise (libc.so.6)\n"
"               #1  0x00007f84993ac21a abort (libc.so.6)\n"
"               #2  0x0000560d0a9e9233 _ZL12sig_fatal_cbi (tarantool)\n"
"               #3  0x00007f849a211220 __restore_rt (libpthread.so.0)\n"
"               #4  0x0000560d0aaa5d9d lj_cconv_ct_ct (tarantool)\n"
"               #5  0x0000560d0aaa687f lj_cconv_ct_tv (tarantool)\n"
"               #6  0x0000560d0aaabe33 lj_cf_ffi_meta___newindex (tarantool)\n"
"               #7  0x0000560d0aaae2f7 lj_BC_FUNCC (tarantool)\n"
"               #8  0x0000560d0aa9aabd lua_pcall (tarantool)\n"
"               #9  0x0000560d0aa71400 lbox_call (tarantool)\n"
"               #10 0x0000560d0aa6ce36 lua_fiber_run_f (tarantool)\n"
"               #11 0x0000560d0a9e8d0c "
"_ZL16fiber_cxx_invokePFiP13__va_list_tagES0_ (tarantool)\n"
"               #12 0x0000560d0aa7b255 fiber_loop (tarantool)\n"
"               #13 0x0000560d0ab38ed1 coro_init (tarantool)\n"
"               ..."
msgstr ""
"$ coredumpctl info 21035\n"
"          PID: 21035 (tarantool)\n"
"          UID: 995 (tarantool)\n"
"          GID: 992 (tarantool)\n"
"       Signal: 6 (ABRT)\n"
"    Timestamp: Sat 2016-01-23 15:51:42 MSK (4h 36min ago)\n"
" Command Line: tarantool my_app.lua <running>\n"
"   Executable: /usr/bin/tarantool\n"
"Control Group: /system.slice/system-tarantool.slice/tarantool@my_app.service\n"
"         Unit: tarantool@my_app.service\n"
"        Slice: system-tarantool.slice\n"
"      Boot ID: 7c686e2ef4dc4e3ea59122757e3067e2\n"
"   Machine ID: a4a878729c654c7093dc6693f6a8e5ee\n"
"     Hostname: localhost.localdomain\n"
"      Message: Process 21035 (tarantool) of user 995 dumped core.\n"
"\n"
"               Stack trace of thread 21035:\n"
"               #0  0x00007f84993aa618 raise (libc.so.6)\n"
"               #1  0x00007f84993ac21a abort (libc.so.6)\n"
"               #2  0x0000560d0a9e9233 _ZL12sig_fatal_cbi (tarantool)\n"
"               #3  0x00007f849a211220 __restore_rt (libpthread.so.0)\n"
"               #4  0x0000560d0aaa5d9d lj_cconv_ct_ct (tarantool)\n"
"               #5  0x0000560d0aaa687f lj_cconv_ct_tv (tarantool)\n"
"               #6  0x0000560d0aaabe33 lj_cf_ffi_meta___newindex (tarantool)\n"
"               #7  0x0000560d0aaae2f7 lj_BC_FUNCC (tarantool)\n"
"               #8  0x0000560d0aa9aabd lua_pcall (tarantool)\n"
"               #9  0x0000560d0aa71400 lbox_call (tarantool)\n"
"               #10 0x0000560d0aa6ce36 lua_fiber_run_f (tarantool)\n"
"               #11 0x0000560d0a9e8d0c "
"_ZL16fiber_cxx_invokePFiP13__va_list_tagES0_ (tarantool)\n"
"               #12 0x0000560d0aa7b255 fiber_loop (tarantool)\n"
"               #13 0x0000560d0ab38ed1 coro_init (tarantool)\n"
"               ..."

#: ../doc/1.7/book/admin/daemon_supervision.rst:270
msgid "Debugger"
msgstr "Отладчик"

#: ../doc/1.7/book/admin/daemon_supervision.rst:272
msgid "To start ``gdb`` debugger on the core dump, say:"
msgstr "Для запуска отладчика ``gdb``, выполните команду:"

#: ../doc/1.7/book/admin/daemon_supervision.rst:274
msgid "$ coredumpctl gdb <pid>"
msgstr "$ coredumpctl gdb <pid>"

#: ../doc/1.7/book/admin/daemon_supervision.rst:278
msgid ""
"It is highly recommended to install ``tarantool-debuginfo`` package to improve "
"``gdb`` experience, for example:"
msgstr ""
"Мы очень рекомендуем установить пакет ``tarantool-debuginfo``, чтобы сделать "
"отладку средствами ``gdb`` более эффективной. Например:"

#: ../doc/1.7/book/admin/daemon_supervision.rst:281
msgid "$ dnf debuginfo-install tarantool"
msgstr "$ dnf debuginfo-install tarantool"

#: ../doc/1.7/book/admin/daemon_supervision.rst:285
msgid ""
"``gdb`` also provides information about the debuginfo packages you need to "
"install:"
msgstr ""
"С помощью ``gdb`` можно узнать, какие еще ``debuginfo``-пакеты нужно установить:"

#: ../doc/1.7/book/admin/daemon_supervision.rst:288
msgid ""
"$ # gdb -p <pid>\n"
"...\n"
"Missing separate debuginfos, use: dnf debuginfo-install\n"
"glibc-2.22.90-26.fc24.x86_64 krb5-libs-1.14-12.fc24.x86_64\n"
"libgcc-5.3.1-3.fc24.x86_64 libgomp-5.3.1-3.fc24.x86_64\n"
"libselinux-2.4-6.fc24.x86_64 libstdc++-5.3.1-3.fc24.x86_64\n"
"libyaml-0.1.6-7.fc23.x86_64 ncurses-libs-6.0-1.20150810.fc24.x86_64\n"
"openssl-libs-1.0.2e-3.fc24.x86_64"
msgstr ""
"$ # gdb -p <pid>\n"
"...\n"
"Missing separate debuginfos, use: dnf debuginfo-install\n"
"glibc-2.22.90-26.fc24.x86_64 krb5-libs-1.14-12.fc24.x86_64\n"
"libgcc-5.3.1-3.fc24.x86_64 libgomp-5.3.1-3.fc24.x86_64\n"
"libselinux-2.4-6.fc24.x86_64 libstdc++-5.3.1-3.fc24.x86_64\n"
"libyaml-0.1.6-7.fc23.x86_64 ncurses-libs-6.0-1.20150810.fc24.x86_64\n"
"openssl-libs-1.0.2e-3.fc24.x86_64"

#: ../doc/1.7/book/admin/daemon_supervision.rst:299
msgid ""
"Symbolic names are present in stack traces even if you don’t have ``tarantool-"
"debuginfo`` package installed."
msgstr ""
"В трассировке стека присутствуют символические имена, даже если у вас не "
"установлен пакет ``tarantool-debuginfo``."

#: ../doc/1.7/book/admin/disaster_recovery.rst:39
msgid "Disaster recovery"
msgstr "Аварийное восстановление"

#: ../doc/1.7/book/admin/disaster_recovery.rst:41
msgid ""
"The minimal fault-tolerant Tarantool configuration would be a :ref:`replication "
"cluster<replication-topologies>` that includes a master and a replica, or two "
"masters."
msgstr ""
"Минимальная отказоустойчивая конфигурация Tarantool'а - это :ref:`репликационный "
"кластер <replication-topologies>`, содержащий мастер и реплику или два мастера."

#: ../doc/1.7/book/admin/disaster_recovery.rst:45
msgid ""
"The basic recommendation is to configure all Tarantool instances in a cluster to "
"create :ref:`snapshot files <index-box_persistence>` at a regular basis."
msgstr ""
"Основная рекомендация - настраивать все экземпляры Tarantool'а в кластере таким "
"образом, чтобы они регулярно создавали :ref:`файлы-снимки <index-"
"box_persistence>`."

#: ../doc/1.7/book/admin/disaster_recovery.rst:48
msgid "Here follow action plans for typical crash scenarios."
msgstr "Ниже дано несколько инструкций для типовых аварийных сценариев."

#: ../doc/1.7/book/admin/disaster_recovery.rst:54
msgid "Master-replica"
msgstr "Master-replica"

#: ../doc/1.7/book/admin/disaster_recovery.rst:56
msgid "Configuration: One master and one replica."
msgstr "Конфигурация: один мастер и одна реплика."

#: ../doc/1.7/book/admin/disaster_recovery.rst:58
msgid "Problem: The master has crashed."
msgstr "Проблема: мастер вышел из строя."

#: ../doc/1.7/book/admin/disaster_recovery.rst:60
#: ../doc/1.7/book/admin/disaster_recovery.rst:127
msgid "Your actions:"
msgstr "План действий:"

#: ../doc/1.7/book/admin/disaster_recovery.rst:62
msgid ""
"Ensure the master is stopped for good. For example, log in to the master machine "
"and use ``systemctl stop tarantool@<instance_name>``."
msgstr ""
"Убедитесь, что мастер полностью остановлен. Например, подключитесь к мастеру и "
"используйте команду ``systemctl stop tarantool@<имя_экземпляра>``."

#: ../doc/1.7/book/admin/disaster_recovery.rst:65
msgid ""
"Switch the replica to master mode by setting :ref:`box.cfg.read_only <cfg_basic-"
"read_only>` parameter to *false* and let the load be handled by the replica "
"(effective master)."
msgstr ""
"Переключите реплику в режим мастера, установив параметру :ref:`box.cfg.read_only "
"<cfg_basic-read_only>` значение *false*. Теперь вся нагрузка пойдет только на "
"реплику (по сути ставшую мастером)."

#: ../doc/1.7/book/admin/disaster_recovery.rst:69
msgid ""
"Set up a replacement for the crashed master on a spare host, with :ref:"
"`replication <cfg_replication-replication>` parameter set to replica (effective "
"master), so it begins to catch up with the new master’s state. The new instance "
"should have :ref:`box.cfg.read_only <cfg_basic-read_only>` parameter set to "
"*true*."
msgstr ""
"Настройте на свободной машине замену вышедшему из строя мастеру, установив "
"параметру :ref:`replication <cfg_replication-replication>` в качестве значения "
"URI реплики (которая в данный момент выполняет роль мастера), чтобы новая "
"реплика начала синхронизироваться с текущим мастером. Значение параметра :ref:"
"`box.cfg.read_only <cfg_basic-read_only>` в новом экземпляре должно быть "
"установлено на *true*."

#: ../doc/1.7/book/admin/disaster_recovery.rst:75
msgid ""
"You lose the few transactions in the master :ref:`write ahead log file <index-"
"box_persistence>`, which it may have not transferred to the replica before "
"crash. If you were able to salvage the master .xlog file, you may be able to "
"recover these. In order to do it:"
msgstr ""
"Все немногочисленные транзакции в :ref:`WAL-файле <index-box_persistence>` "
"мастера, которые он не успел передать реплике до выхода из строя, будут "
"потеряны. Однако если удастся получить .xlog-файл мастера, их можно будет "
"восстановить. Для этого:"

#: ../doc/1.7/book/admin/disaster_recovery.rst:80
msgid ""
"Find out the position of the crashed master, as reflected on the new master."
msgstr ""
"Узнайте позицию вышедшего из строя мастера - эта информация доступна из нового "
"мастера."

#: ../doc/1.7/book/admin/disaster_recovery.rst:82
msgid "Find out instance UUID from the crashed master :ref:`xlog <internals-wal>`:"
msgstr ""
"Посмотрите UUID экземпляра в .:ref:`xlog-файле <internals-wal>` вышедшего из "
"строя мастера:"

#: ../doc/1.7/book/admin/disaster_recovery.rst:84
msgid ""
"$ head -5 *.xlog | grep Instance\n"
"Instance: ed607cad-8b6d-48d8-ba0b-dae371b79155"
msgstr ""
"$ head -5 *.xlog | grep Instance\n"
"Instance: ed607cad-8b6d-48d8-ba0b-dae371b79155"

#: ../doc/1.7/book/admin/disaster_recovery.rst:89
msgid "On the new master, use the UUID to find the position:"
msgstr "Используйте этот UUID на новом мастере для поиска позиции:"

#: ../doc/1.7/book/admin/disaster_recovery.rst:91
msgid ""
"tarantool>box.info.vclock[box.space._cluster.index.uuid:"
"select{'ed607cad-8b6d-48d8-ba0b-dae371b79155'}[1][1]]\n"
"---\n"
"- 23425\n"
"<...>"
msgstr ""
"tarantool>box.info.vclock[box.space._cluster.index.uuid:"
"select{'ed607cad-8b6d-48d8-ba0b-dae371b79155'}[1][1]]\n"
"---\n"
"- 23425\n"
"<...>"

#: ../doc/1.7/book/admin/disaster_recovery.rst:98
msgid ""
"Play the records from the crashed .xlog to the new master, starting from the new "
"master position:"
msgstr ""
"Запишите транзакции из .xlog-файла вышедшего из строя мастера в новый мастер, "
"начиная с позиции нового мастера:"

#: ../doc/1.7/book/admin/disaster_recovery.rst:101
msgid ""
"Issue this request locally at the new master's machine to find out instance ID "
"of the new master:"
msgstr ""
"Локально выполните эту команду на новом мастере, чтобы узнать его ID экземпляра:"

#: ../doc/1.7/book/admin/disaster_recovery.rst:104
#: ../doc/1.7/book/replication/repl_architecture.rst:118
msgid ""
"tarantool> box.space._cluster:select{}\n"
"---\n"
"- - [1, '88580b5c-4474-43ab-bd2b-2409a9af80d2']\n"
"..."
msgstr ""
"tarantool> box.space._cluster:select{}\n"
"---\n"
"- - [1, '88580b5c-4474-43ab-bd2b-2409a9af80d2']\n"
"..."

#: ../doc/1.7/book/admin/disaster_recovery.rst:111
msgid "Play the records to the new master:"
msgstr "Запишите транзакции в новый мастер:"

#: ../doc/1.7/book/admin/disaster_recovery.rst:113
msgid ""
"$ tarantoolctl <new_master_uri> <xlog_file> play --from-lsn 23425 --replica 1"
msgstr ""
"$ tarantoolctl <uri_нового_мастера> <xlog_файл> play --from-lsn 23425 --replica 1"

#: ../doc/1.7/book/admin/disaster_recovery.rst:121
msgid "Master-master"
msgstr "Master-master"

#: ../doc/1.7/book/admin/disaster_recovery.rst:123
msgid "Configuration: Two masters."
msgstr "Конфигурация: два мастера."

#: ../doc/1.7/book/admin/disaster_recovery.rst:125
msgid "Problem: Master#1 has crashed."
msgstr "Проблема: мастер #1 вышел из строя."

#: ../doc/1.7/book/admin/disaster_recovery.rst:129
msgid "Let the load be handled by master#2 (effective master) alone."
msgstr "Пусть вся нагрузка идет только на мастер #2 (действующий мастер)."

#: ../doc/1.7/book/admin/disaster_recovery.rst:131
msgid ""
"2. Follow the same steps as in the :ref:`master-replica <admin-disaster_recovery-"
"master_replica>` recovery scenario to create a new master and salvage lost data."
msgstr ""
"2. Создайте новый мастер и восстановите данные, проделав те же шаги, что и в "
"сценарии для конфигурации :ref:`master-replica <admin-disaster_recovery-"
"master_replica>`."

#: ../doc/1.7/book/admin/disaster_recovery.rst:139
msgid "Data loss"
msgstr "Потеря данных"

#: ../doc/1.7/book/admin/disaster_recovery.rst:141
msgid "Configuration: Master-master or master-replica."
msgstr "Конфигурация: master-master или master-replica."

#: ../doc/1.7/book/admin/disaster_recovery.rst:143
msgid ""
"Problem: Data was deleted at one master and this data loss was propagated to the "
"other node (master or replica)."
msgstr ""
"Проблема: данные были удалены на одном мастере, а затем эти изменения "
"реплицировались на другом узле (мастере или реплике)."

#: ../doc/1.7/book/admin/disaster_recovery.rst:146
msgid ""
"The following steps are applicable only to data in memtx storage engine. Your "
"actions:"
msgstr ""
"Эта инструкция применима только для данных, хранящихся на движке memtx. План "
"действий:"

#: ../doc/1.7/book/admin/disaster_recovery.rst:149
msgid ""
"Put all nodes in :ref:`read-only mode <cfg_basic-read_only>` and disable "
"checkpointing with ``box.backup.start()``. Disabling the checkpointing is "
"necessary to prevent automatic garbage collection of older checkpoints."
msgstr ""
"Переключите все узлы в :ref:`режим read-only <cfg_basic-read_only>` и отключите "
"командой ``box.backup.begin()`` создание контрольных точек. Последнее действие "
"необходимо, чтобы сборщик мусора автоматически не удалил более старые "
"контрольные точки."

#: ../doc/1.7/book/admin/disaster_recovery.rst:153
msgid ""
"Get the latest valid :ref:`.snap file <internals-snapshot>` and use "
"``tarantoolctl cat`` command to calculate at which lsn the data loss occurred."
msgstr ""
"Возьмите последний корректный :ref:`.snap-файл <internals-snapshot>` и, "
"используя команду ``tarantoolctl cat``, выясните, на каком именно lsn произошла "
"потеря данных."

#: ../doc/1.7/book/admin/disaster_recovery.rst:156
msgid ""
"Start a new instance (instance#1) and use ``tarantoolctl play`` command to play "
"to it the contents of .snap/.xlog files up to the calculated lsn."
msgstr ""
"Запустите новый экземпляр (экземпляр #1) и с помощью команды ``tarantoolctl "
"play`` скопируйте в него содержимое .snap/.xlog-файлов вплоть до вычисленного "
"lsn."

#: ../doc/1.7/book/admin/disaster_recovery.rst:159
msgid "Bootstrap a new replica from the recovered master (instance#1)."
msgstr ""
"Настройте новую реплику с помощью восстановленного мастера (экземпляра #1)."

#: ../doc/1.7/book/admin/index.rst:39
msgid "Server administration"
msgstr "Администрирование серверной части"

#: ../doc/1.7/book/admin/index.rst:41
msgid "Tarantool is designed to have multiple running instances on the same host."
msgstr ""
"Tarantool устроен таким образом, что возможно запустить несколько экземпляров "
"программы на одном компьютере."

#: ../doc/1.7/book/admin/index.rst:43
msgid ""
"Here we show how to administer Tarantool instances using any of the following "
"utilities:"
msgstr ""
"Здесь мы показываем, как администрировать экземпляры Tarantool’а с помощью любой "
"из следующих утилит:"

#: ../doc/1.7/book/admin/index.rst:46
msgid "``systemd`` native utilities, or"
msgstr "встроенные утилиты ``systemd`` или"

#: ../doc/1.7/book/admin/index.rst:47
msgid ""
":ref:`tarantoolctl <tarantoolctl>`, a utility shipped and installed as part of "
"Tarantool distribution."
msgstr ""
":ref:`tarantoolctl <tarantoolctl>`, утилита, поставляемая и устанавливаемая "
"вместе с дистрибутивом Tarantool’а."

#: ../doc/1.7/book/admin/index.rst:52
msgid "Unlike the rest of this manual, here we use system-wide paths."
msgstr ""
"В отличие от остальной части руководства, в этой главе мы используем "
"общесистемные пути."

#: ../doc/1.7/book/admin/index.rst:53
msgid "Console examples here are for Fedora."
msgstr "Здесь мы приводим примеры консольного вывода для Fedora."

#: ../doc/1.7/book/admin/index.rst:55 ../doc/1.7/book/replication/index.rst:45
msgid "This chapter includes the following sections:"
msgstr "Эта глава включает в себя следующие разделы:"

#: ../doc/1.7/book/admin/instance_config.rst:39
msgid "Instance configuration"
msgstr "Настройка экземпляров Tarantool’а"

#: ../doc/1.7/book/admin/instance_config.rst:41
msgid "For each Tarantool instance, you need two files:"
msgstr "Для каждого экземпляра Tarantool’а понадобится два файла:"

#: ../doc/1.7/book/admin/instance_config.rst:43
msgid ""
"[Optional] An :ref:`application file <app_server-launching_app>` with instance-"
"specific logic. Put this file into the ``/usr/share/tarantool/`` directory."
msgstr ""
"[Необязательный] :ref:`Файл приложения <app_server-launching_app>`, содержащий "
"логику данного экземпляра. Поместите его в папку ``/usr/share/tarantool/``."

#: ../doc/1.7/book/admin/instance_config.rst:47
msgid ""
"For example, ``/usr/share/tarantool/my_app.lua`` (here we implement it as a :ref:"
"`Lua module <app_server-modules>` that bootstraps the database and exports "
"``start()`` function for API calls):"
msgstr ""
"Например, ``/usr/share/tarantool/my_app.lua`` (здесь мы реализуем его как :ref:"
"`Lua-модуль <app_server-modules>`, который запускает базу данных и экспортирует "
"функцию ``start()`` для API -вызовов):"

#: ../doc/1.7/book/admin/instance_config.rst:51
msgid ""
"local function start()\n"
"    box.schema.space.create(\"somedata\")\n"
"    box.space.somedata:create_index(\"primary\")\n"
"    <...>\n"
"end\n"
"\n"
"return {\n"
"  start = start;\n"
"}"
msgstr ""
"local function start()\n"
"    box.schema.space.create(\"somedata\")\n"
"    box.space.somedata:create_index(\"primary\")\n"
"    <...>\n"
"end\n"
"\n"
"return {\n"
"  start = start;\n"
"}"

#: ../doc/1.7/book/admin/instance_config.rst:63
msgid ""
"An :ref:`instance file <admin-instance_file>` with instance-specific "
"initialization logic and parameters. Put this file, or a symlink to it, into the "
"``/etc/tarantool/instances.enabled`` directory."
msgstr ""
":ref:`Файл экземпляра <admin-instance_file>`, содержащий логику и параметры "
"инициализации данного экземпляра. Поместите этот файл или символьную ссылку на "
"него в папку ``/etc/tarantool/instances.enabled``."

#: ../doc/1.7/book/admin/instance_config.rst:67
msgid ""
"For example, ``/etc/tarantool/instances.enabled/my_app.lua`` (here we load "
"``my_app.lua`` module and make a call to ``start()`` function from that module):"
msgstr ""
"Например, ``/etc/tarantool/instances.enabled/my_app.lua`` (здесь мы загружаем "
"модуль ``my_app.lua`` и вызываем из него функцию ``start()``):"

#: ../doc/1.7/book/admin/instance_config.rst:71
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"box.cfg {\n"
"    listen = 3301;\n"
"}\n"
"\n"
"-- load my_app module and call start() function\n"
"-- with some app options controlled by sysadmins\n"
"local m = require('my_app').start({...})"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"box.cfg {\n"
"    listen = 3301;\n"
"}\n"
"\n"
"-- load my_app module and call start() function\n"
"-- with some app options controlled by sysadmins\n"
"local m = require('my_app').start({...})"

#: ../doc/1.7/book/admin/instance_config.rst:87
msgid "Instance file"
msgstr "Файл экземпляра"

#: ../doc/1.7/book/admin/instance_config.rst:89
msgid ""
"After this short introduction, you may wonder what an instance file is, what it "
"is for, and how ``tarantoolctl`` uses it. After all, Tarantool is an application "
"server, so why not start the application stored in ``/usr/share/tarantool`` "
"directly?"
msgstr ""
"После столь краткого предисловия может возникнуть вопрос: что из себя "
"представляет файл экземпляра, для чего он нужен и как ``tarantoolctl`` "
"использует его? Если Tarantool - это сервер приложений, так почему бы не "
"запускать хранящееся в ``/usr/share/tarantool`` приложение напрямую?"

#: ../doc/1.7/book/admin/instance_config.rst:94
msgid ""
"A typical Tarantool application is not a script, but a daemon running in "
"background mode and processing requests, usually sent to it over a TCP/IP "
"socket. This daemon needs to be started automatically when the operating system "
"starts, and managed with the operating system standard tools for service "
"management -- such as ``systemd`` or ``init.d``. To serve this very purpose, we "
"created **instance files**."
msgstr ""
"Типичное приложение для Tarantool - это не скрипт, а демон, запущенный в фоновом "
"режиме и обрабатывающий запросы, которые, как правило, посылаются через TCP/IP-"
"сокет. Необходимо запускать этот демон со стартом операционной системы и "
"управлять им с помощью стандартных средств операционной системы для управления "
"сервисами -- таких как ``systemd`` или ``init.d``. С этой целью и были созданы "
"**файлы экземпляра**."

#: ../doc/1.7/book/admin/instance_config.rst:101
msgid ""
"You can have more than one instance file. For example, a single application in "
"``/usr/share/tarantool`` can run in multiple instances, each of them having its "
"own instance file. Or you can have multiple applications in ``/usr/share/"
"tarantool`` -- again, each of them having its own instance file."
msgstr ""
"Файлов экземпляра может быть больше одного. Например, одно и то же приложение в "
"``/usr/share/tarantool`` может быть запущено на нескольких экземплярах "
"Tarantool'а, у каждого из которых есть свой файл экземпляра. Или в ``/usr/share/"
"tarantool`` может быть несколько приложений, и на каждое из них будет опять же "
"приходиться свой файл экземпляра."

#: ../doc/1.7/book/admin/instance_config.rst:106
msgid ""
"An instance file is typically created by a system administrator. An application "
"file is often provided by a developer, in a Lua rock or an rpm/deb package."
msgstr ""
"Обычно файл экземпляра создает системный администратор, а файл приложения "
"предоставляет разработчик в Lua-модуле или rpm/deb-пакете."

#: ../doc/1.7/book/admin/instance_config.rst:109
msgid ""
"An instance file is designed to not differ in any way from a Lua application. It "
"must, however, configure the database, i.e. contain a call to :ref:`box.cfg{} "
"<box_introspection-box_cfg>` somewhere in it, because it’s the only way to turn "
"a Tarantool script into a background process, and ``tarantoolctl`` is a tool to "
"manage background processes. Other than that, an instance file may contain "
"arbitrary Lua code, and, in theory, even include the entire application business "
"logic in it. We, however, do not recommend this, since it clutters the instance "
"file and leads to unnecessary copy-paste when you need to run multiple instances "
"of an application."
msgstr ""
"По своему устройству файл экземпляра ничем не отличается от Lua-приложения. "
"Однако с его помощью должна настраиваться база данных, поэтому в нем должен "
"содержаться вызов :ref:`box.cfg{} <box_introspection-box_cfg>`, потому что это "
"единственный способ превратить Tarantool-скрипт в фоновый процесс, а "
"``tarantoolctl`` - это инструмент для управления фоновыми процессами. За "
"исключением этого вызова, файл экземпляра может содержать произвольный код на "
"Lua и, теоретически, даже всю бизнес-логику приложения. Однако мы не рекомендуем "
"хранить весь код в файле экземпляра, потому что это приводит как к замусориванию "
"самого файла, так и к ненужному копированию кода при необходимости запустить "
"несколько экземпляров приложения."

#: ../doc/1.7/book/admin/instance_config.rst:123
msgid "`tarantoolctl` configuration file"
msgstr "Конфигурационный файл `tarantoolctl`"

#: ../doc/1.7/book/admin/instance_config.rst:125
msgid ""
"While instance files contain instance configuration, ``tarantoolctl`` "
"configuration file contains the configuration that ``tarantoolctl`` uses to "
"override instance configuration. In other words, it contains system-wide "
"configuration defaults."
msgstr ""
"Файлы экземпляра содержат конфигурацию экземпляра, тогда как конфигурационный "
"файл ``tarantoolctl`` содержит конфигурацию, которую ``tarantoolctl`` "
"использует, чтобы переопределять конфигурацию экземпляров. Другими словами, он "
"содержит общесистемную конфигурацию по умолчанию."

#: ../doc/1.7/book/admin/instance_config.rst:130
msgid ""
"Most of the parameters are similar to those used by :ref:`box.cfg{} "
"<box_introspection-box_cfg>`. Here are the default settings (installed to ``/etc/"
"default/tarantool`` as part of Tarantool distribution):"
msgstr ""
"Большинство параметров схожи с теми, которые используются в :ref:`box.cfg{} "
"<box_introspection-box_cfg>`. Ниже даны настройки по умолчанию (устанавливаемые "
"в ``/etc/default/tarantool`` как часть дистрибутива Tarantool):"

#: ../doc/1.7/book/admin/instance_config.rst:134
msgid ""
"default_cfg = {\n"
"    pid_file  = \"/var/run/tarantool\",\n"
"    wal_dir   = \"/var/lib/tarantool\",\n"
"    memtx_dir = \"/var/lib/tarantool\",\n"
"    vinyl_dir = \"/var/lib/tarantool\",\n"
"    log       = \"/var/log/tarantool\",\n"
"    username  = \"tarantool\",\n"
"}\n"
"instance_dir = \"/etc/tarantool/instances.enabled\""
msgstr ""
"default_cfg = {\n"
"    pid_file  = \"/var/run/tarantool\",\n"
"    wal_dir   = \"/var/lib/tarantool\",\n"
"    memtx_dir = \"/var/lib/tarantool\",\n"
"    vinyl_dir = \"/var/lib/tarantool\",\n"
"    log       = \"/var/log/tarantool\",\n"
"    username  = \"tarantool\",\n"
"}\n"
"instance_dir = \"/etc/tarantool/instances.enabled\""

#: ../doc/1.7/book/admin/instance_config.rst
msgid "``pid_file``"
msgstr "``pid_file``"

#: ../doc/1.7/book/admin/instance_config.rst
msgid ""
"Directory for the pid file and control-socket file; ``tarantoolctl`` will add “/"
"instance_name” to the directory name."
msgstr ""
"Директория, где хранятся pid-файл и socket-файл; ``tarantoolctl`` добавляет “/"
"имя_экземпляра” к имени директории."

#: ../doc/1.7/book/admin/instance_config.rst
msgid "``wal_dir``"
msgstr "``wal_dir``"

#: ../doc/1.7/book/admin/instance_config.rst
msgid ""
"Directory for write-ahead .xlog files; ``tarantoolctl`` will add \"/instance_name"
"\" to the directory name."
msgstr ""
"Директория, где хранятся .xlog-файлы; ``tarantoolctl`` добавляет “/"
"имя_экземпляра” к имени директории."

#: ../doc/1.7/book/admin/instance_config.rst
msgid "``memtx_dir``"
msgstr "``memtx_dir``"

#: ../doc/1.7/book/admin/instance_config.rst
msgid ""
"Directory for snapshot .snap files; ``tarantoolctl`` will add \"/instance_name\" "
"to the directory name."
msgstr ""
"Директория, где хранятся .snap-файлы; ``tarantoolctl`` добавляет “/"
"имя_экземпляра” к имени директории."

#: ../doc/1.7/book/admin/instance_config.rst
msgid "``vinyl_dir``"
msgstr "``vinyl_dir``"

#: ../doc/1.7/book/admin/instance_config.rst
msgid ""
"Directory for vinyl files; ``tarantoolctl`` will add \"/instance_name\" to the "
"directory name."
msgstr ""
"Директория, где хранятся vinyl-файлы; ``tarantoolctl`` добавляет “/"
"имя_экземпляра” к имени директории."

#: ../doc/1.7/book/admin/instance_config.rst
msgid "``log``"
msgstr "``log``"

#: ../doc/1.7/book/admin/instance_config.rst
msgid ""
"The place where the application log will go; ``tarantoolctl`` will add \"/"
"instance_name.log\" to the name."
msgstr ""
"Директория, где хранятся файлы журнала с сообщениями от Tarantool-приложения; "
"``tarantoolctl`` добавляет “/имя_экземпляра” к имени директории."

#: ../doc/1.7/book/admin/instance_config.rst
msgid "``username``"
msgstr "``username``"

#: ../doc/1.7/book/admin/instance_config.rst
msgid ""
"The user that runs the Tarantool instance. This is the operating-system user "
"name rather than the Tarantool-client user name. Tarantool will change its "
"effective user to this user after becoming a daemon."
msgstr ""
"Пользователь, запускающий экземпляр Tarantool'а. Это пользователь операционной "
"системы, а не Tarantool-клиента. Став демоном, Tarantool сменит своего "
"пользователя на указанного."

#: ../doc/1.7/book/admin/instance_config.rst
msgid "``instance_dir``"
msgstr "``instance_dir``"

#: ../doc/1.7/book/admin/instance_config.rst
msgid ""
"The directory where all instance files for this host are stored. Put instance "
"files in this directory, or create symbolic links."
msgstr ""
"Директория, где хранятся все файлы экземпляра для данного компьютера. Поместите "
"сюда файлы экземпляра или создайте символьные ссылки на них."

#: ../doc/1.7/book/admin/instance_config.rst:177
msgid ""
"As a full-featured example, you can take `example.lua <https://github.com/"
"tarantool/tarantool/blob/1.7/extra/dist/example.lua>`_ script that ships with "
"Tarantool and defines all configuration options."
msgstr ""
"В качестве полноценного примера можно использовать скрипт `example.lua <https://"
"github.com/tarantool/tarantool/blob/1.7/extra/dist/example.lua>`_, который "
"поставляется вместе с Tarantool и задает все конфигурационные параметры."

#: ../doc/1.7/book/admin/logs.rst:39
msgid "Logs"
msgstr "Журналирование"

#: ../doc/1.7/book/admin/logs.rst:41
msgid ""
"Tarantool logs important events to a file, e.g. ``/var/log/tarantool/my_app."
"log``. To build the log file path, ``tarantoolctl`` takes the instance name, "
"prepends the instance directory and appends “.log” extension."
msgstr ""
"Все важные события Tarantool записывает в файл журнала - например, в ``/var/log/"
"tarantool/my_app.log``.  ``tarantoolctl`` строит путь до файла журнала следующим "
"образом: \"путь до директории с экземплярами\" + \"имя экземпляра\" + \".lua\"."

#: ../doc/1.7/book/admin/logs.rst:45
msgid "Let’s write something to the log file:"
msgstr "Запишем что-нибудь в файл журнала:"

#: ../doc/1.7/book/admin/logs.rst:47
msgid ""
"$ tarantoolctl enter my_app\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/my_app.control\n"
"unix/:/var/run/tarantool/my_app.control> require('log').info(\"Hello for the "
"manual readers\")\n"
"---\n"
"..."
msgstr ""
"$ tarantoolctl enter my_app\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/my_app.control\n"
"unix/:/var/run/tarantool/my_app.control> require('log').info(\"Hello for the "
"manual readers\")\n"
"---\n"
"..."

#: ../doc/1.7/book/admin/logs.rst:55
msgid "Then check the logs:"
msgstr "Затем проверим содержимое журнала:"

#: ../doc/1.7/book/admin/logs.rst:57
msgid ""
"$ tail /var/log/tarantool/my_app.log\n"
"2017-04-04 15:54:04.977 [29255] main/101/tarantoolctl C> version 1.7.3-382-"
"g68ef3f6a9\n"
"2017-04-04 15:54:04.977 [29255] main/101/tarantoolctl C> log level 5\n"
"2017-04-04 15:54:04.978 [29255] main/101/tarantoolctl I> mapping 134217728 bytes "
"for tuple arena...\n"
"2017-04-04 15:54:04.985 [29255] iproto/101/main I> binary: bound to [::1]:3301\n"
"2017-04-04 15:54:04.986 [29255] main/101/tarantoolctl I> recovery start\n"
"2017-04-04 15:54:04.986 [29255] main/101/tarantoolctl I> recovering from `/var/"
"lib/tarantool/my_app/00000000000000000000.snap'\n"
"2017-04-04 15:54:04.988 [29255] main/101/tarantoolctl I> ready to accept "
"requests\n"
"2017-04-04 15:54:04.988 [29255] main/101/tarantoolctl I> set "
"'checkpoint_interval' configuration option to 3600\n"
"2017-04-04 15:54:04.988 [29255] main/101/my_app I> Run console at unix/:/var/run/"
"tarantool/my_app.control\n"
"2017-04-04 15:54:04.989 [29255] main/106/console/unix/:/var/ I> started\n"
"2017-04-04 15:54:04.989 [29255] main C> entering the event loop\n"
"2017-04-04 15:54:47.147 [29255] main/107/console/unix/: I> Hello for the manual "
"readers"
msgstr ""
"$ tail /var/log/tarantool/my_app.log\n"
"2017-04-04 15:54:04.977 [29255] main/101/tarantoolctl C> version 1.7.3-382-"
"g68ef3f6a9\n"
"2017-04-04 15:54:04.977 [29255] main/101/tarantoolctl C> log level 5\n"
"2017-04-04 15:54:04.978 [29255] main/101/tarantoolctl I> mapping 134217728 bytes "
"for tuple arena...\n"
"2017-04-04 15:54:04.985 [29255] iproto/101/main I> binary: bound to [::1]:3301\n"
"2017-04-04 15:54:04.986 [29255] main/101/tarantoolctl I> recovery start\n"
"2017-04-04 15:54:04.986 [29255] main/101/tarantoolctl I> recovering from `/var/"
"lib/tarantool/my_app/00000000000000000000.snap'\n"
"2017-04-04 15:54:04.988 [29255] main/101/tarantoolctl I> ready to accept "
"requests\n"
"2017-04-04 15:54:04.988 [29255] main/101/tarantoolctl I> set "
"'checkpoint_interval' configuration option to 3600\n"
"2017-04-04 15:54:04.988 [29255] main/101/my_app I> Run console at unix/:/var/run/"
"tarantool/my_app.control\n"
"2017-04-04 15:54:04.989 [29255] main/106/console/unix/:/var/ I> started\n"
"2017-04-04 15:54:04.989 [29255] main C> entering the event loop\n"
"2017-04-04 15:54:47.147 [29255] main/107/console/unix/: I> Hello for the manual "
"readers"

#: ../doc/1.7/book/admin/logs.rst:73
msgid ""
"When logging to a file, the system administrator must ensure logs are rotated "
"timely and do not take up all the available disk space. With ``tarantoolctl``, "
"log rotation is pre-configured to use ``logrotate`` program, which you must have "
"installed."
msgstr ""
"При включенном журналировании системный администратор должен обеспечивать "
"своевременную ротацию журналов, чтобы избежать переполнения дискового "
"пространства. Ротация журналов в ``tarantoolctl`` производится с помощью "
"программы ``logrotate``, которую необходимо установить заранее."

#: ../doc/1.7/book/admin/logs.rst:78
msgid ""
"File ``/etc/logrotate.d/tarantool`` is part of the standard Tarantool "
"distribution, and you can modify it to change the default behavior. This is what "
"this file is usually like:"
msgstr ""
"Файл ``/etc/logrotate.d/tarantool`` поставляется со стандартным дистрибутивом "
"Tarantool. Его можно редактировать для изменения поведения по умолчанию. "
"Содержимое файла обычно выглядит так:"

#: ../doc/1.7/book/admin/logs.rst:82
#, python-format
msgid ""
"/var/log/tarantool/*.log {\n"
"    daily\n"
"    size 512k\n"
"    missingok\n"
"    rotate 10\n"
"    compress\n"
"    delaycompress\n"
"    create 0640 tarantool adm\n"
"    postrotate\n"
"        /usr/bin/tarantoolctl logrotate `basename ${1%%.*}`\n"
"    endscript\n"
"}"
msgstr ""
"/var/log/tarantool/*.log {\n"
"    daily\n"
"    size 512k\n"
"    missingok\n"
"    rotate 10\n"
"    compress\n"
"    delaycompress\n"
"    create 0640 tarantool adm\n"
"    postrotate\n"
"        /usr/bin/tarantoolctl logrotate `basename ${1%%.*}`\n"
"    endscript\n"
"}"

#: ../doc/1.7/book/admin/logs.rst:97
msgid ""
"If you use a different log rotation program, you can invoke ``tarantoolctl "
"logrotate`` command to request instances to reopen their log files after they "
"were moved by the program of your choice."
msgstr ""
"Если вы используете другую программу для ротации журналов, можно вызвать команду "
"``tarantoolctl logrotate``, чтобы экземпляры переоткрыли свои файлы журнала "
"после того, как выбранная вами программа переместила их."

#: ../doc/1.7/book/admin/logs.rst:103
msgid ""
"Tarantool can write its logs to a log file, ``syslog`` or a program specified in "
"the configuration file (see :ref:`log <cfg_logging-log>` parameter)."
msgstr ""
"Tarantool может писать события в файл журнала, ``syslog`` или программу, "
"указанную в конфигурационном файле (см. параметр :ref:`log <cfg_logging-log>`)."

#: ../doc/1.7/book/admin/logs.rst:106
msgid ""
"By default, logs are written to a file as defined in ``tarantoolctl`` defaults. "
"``tarantoolctl`` automatically detects if an instance is using ``syslog`` or an "
"external program for logging, and does not override the log destination in this "
"case. In such configurations, log rotation is usually handled by the external "
"program used for logging. So, ``tarantoolctl logrotate`` command works only if "
"logging-into-file is enabled in the instance file."
msgstr ""
"По умолчанию запись производится в файл журнала, как указано в исходных "
"настройках ``tarantoolctl``. Скрипт ``tarantoolctl`` автоматически определяет, "
"когда экземпляр использует для журналирования ``syslog`` или внешнюю программу, "
"и не изменяет то, куда ведется запись. В таких случаях ротацию журналов обычно "
"выполняет та же программа, которая используется для журналирования. Именно "
"поэтому команда ``tarantoolctl logrotate`` сработает только в том случае, если в "
"файле экземпляра включена возможность вести запись в файл."

#: ../doc/1.7/book/admin/os_notes.rst:39
msgid "Notes for operating systems"
msgstr "Замечания по поводу некоторых операционных систем"

#: ../doc/1.7/book/admin/os_notes.rst:45
msgid "Mac OS"
msgstr "Mac OS"

#: ../doc/1.7/book/admin/os_notes.rst:47
msgid ""
"On Mac OS, you can administer Tarantool instances only with ``tarantoolctl``. No "
"native system tools are supported."
msgstr ""
"Администрирование экземпляров Tarantool'а на Mac OS возможно только с помощью "
"``tarantoolctl``. Встроенные системные инструменты не поддерживаются."

#: ../doc/1.7/book/admin/os_notes.rst:54
msgid "FreeBSD"
msgstr "FreeBSD"

#: ../doc/1.7/book/admin/os_notes.rst:56
msgid ""
"To make ``tarantoolctl`` work along with ``init.d`` utilities on FreeBSD, use "
"paths other than those suggested in :ref:`Instance configuration <admin-"
"instance_config>`. Instead of ``/usr/share/tarantool/`` directory, use ``/usr/"
"local/etc/tarantool/`` and create the following subdirectories:"
msgstr ""
"Чтобы ``tarantoolctl`` и утилиты ``init.d`` работали на FreeBSD, используйте "
"пути, отличные от предложенных в разделе :ref:`Настройка экземпляров Tarantool’а "
"<admin-instance_config>`. Используйте ``/usr/local/etc/tarantool/`` вместо ``/"
"usr/share/tarantool/`` и создайте следующие поддиректории:"

#: ../doc/1.7/book/admin/os_notes.rst:62
msgid "``default`` for ``tarantoolctl`` defaults (see example below),"
msgstr ""
"``default`` для хранения настроек ``tarantoolctl`` по умолчанию (см. пример "
"ниже),"

#: ../doc/1.7/book/admin/os_notes.rst:63
msgid "``instances.available`` for all available instance files, and"
msgstr "``instances.available`` для хранения всех доступных файлов экземпляра, и"

#: ../doc/1.7/book/admin/os_notes.rst:64
msgid "``instances.enabled`` for instance files to be auto-started by sysvinit."
msgstr ""
"``instances.enabled`` для хранения файлов экземпляра, которые необходимо "
"запускать автоматически с помощью sysvinit."

#: ../doc/1.7/book/admin/os_notes.rst:66
msgid "Here is an example of ``tarantoolctl`` defaults on FreeBSD:"
msgstr "Так выглядят настройки ``tarantoolctl`` по умолчанию на FreeBSD:"

#: ../doc/1.7/book/admin/os_notes.rst:68
msgid ""
"default_cfg = {\n"
"    pid_file   = \"/var/run/tarantool\", -- /var/run/tarantool/${INSTANCE}.pid\n"
"    wal_dir    = \"/var/db/tarantool\", -- /var/db/tarantool/${INSTANCE}/\n"
"    snap_dir   = \"/var/db/tarantool\", -- /var/db/tarantool/${INSTANCE}\n"
"    vinyl_dir = \"/var/db/tarantool\", -- /var/db/tarantool/${INSTANCE}\n"
"    logger     = \"/var/log/tarantool\", -- /var/log/tarantool/${INSTANCE}.log\n"
"    username   = \"tarantool\",\n"
"}\n"
"\n"
"-- instances.available - all available instances\n"
"-- instances.enabled - instances to autostart by sysvinit\n"
"instance_dir = \"/usr/local/etc/tarantool/instances.available\""
msgstr ""
"default_cfg = {\n"
"    pid_file   = \"/var/run/tarantool\", -- /var/run/tarantool/${INSTANCE}.pid\n"
"    wal_dir    = \"/var/db/tarantool\", -- /var/db/tarantool/${INSTANCE}/\n"
"    snap_dir   = \"/var/db/tarantool\", -- /var/db/tarantool/${INSTANCE}\n"
"    vinyl_dir = \"/var/db/tarantool\", -- /var/db/tarantool/${INSTANCE}\n"
"    logger     = \"/var/log/tarantool\", -- /var/log/tarantool/${INSTANCE}.log\n"
"    username   = \"tarantool\",\n"
"}\n"
"\n"
"-- instances.available - все доступные экземпляры\n"
"-- instances.enabled - экземпляры для автоматического запуска через sysvinit\n"
"instance_dir = \"/usr/local/etc/tarantool/instances.available\""

#: ../doc/1.7/book/admin/security.rst:39
msgid "Security"
msgstr "Безопасность"

#: ../doc/1.7/book/admin/security.rst:41
msgid "Tarantool allows for two types of connections:"
msgstr "Tarantool разрешает два типа подключений:"

#: ../doc/1.7/book/admin/security.rst:43
msgid ""
"With :ref:`console.listen() <console-listen>` function from ``console`` module, "
"you can set up a port which can be used to open an administrative console to the "
"server. This is for administrators to connect to a running instance and make "
"requests. ``tarantoolctl`` invokes ``console.listen()`` to create a control "
"socket for each started instance."
msgstr ""
"Используя функцию :ref:`console.listen() <console-listen>` из модуля "
"``console``, можно настроить порт для подключения к серверной административной "
"консоли. Этот вариант для администраторов, которым необходимо подключиться к "
"работающему экземпляру и послать некоторые запросы. ``tarantoolctl`` вызывает "
"``console.listen()``, чтобы создать управляющий сокет для каждого запущенного "
"экземпляра."

#: ../doc/1.7/book/admin/security.rst:49
msgid ""
"With :ref:`box.cfg{listen=...} <cfg_basic-listen>` parameter from ``box`` "
"module, you can set up a binary port for connections which read and write to the "
"database or invoke stored procedures."
msgstr ""
"Используя параметр :ref:`box.cfg{listen=...} <cfg_basic-listen>` из модуля "
"``box``, можно настроить бинарный порт для соединений, которые читают и пишут в "
"базу данных или вызывают хранимые процедуры."

#: ../doc/1.7/book/admin/security.rst:53
msgid "When you connect to an admin console:"
msgstr "Если вы подключены к административной консоли:"

#: ../doc/1.7/book/admin/security.rst:55
msgid "The client-server protocol is plain text."
msgstr "Клиент-серверный протокол - это простой текст."

#: ../doc/1.7/book/admin/security.rst:56
msgid "No password is necessary."
msgstr "Пароль не требуется."

#: ../doc/1.7/book/admin/security.rst:57
msgid "The user is automatically 'admin'."
msgstr "Пользователь автоматически получает права администратора."

#: ../doc/1.7/book/admin/security.rst:58
msgid "Each command is fed directly to the built-in Lua interpreter."
msgstr "Каждая команда напрямую обрабатывается встроенным интерпретатором Lua."

#: ../doc/1.7/book/admin/security.rst:60
msgid ""
"Therefore you must set up ports for the admin console very cautiously. If it is "
"a TCP port, it should only be opened for a specific IP. Ideally, it should not "
"be a TCP port at all, it should be a Unix domain socket, so that access to the "
"server machine is required. Thus a typical port setup for admin console is:"
msgstr ""
"Поэтому порты для административной консоли следует настраивать очень осторожно. "
"Если это TCP-порт, он должен быть открыть только для определенного IP-адреса. В "
"идеале вместо TCP-порта лучше настроить доменный Unix-сокет, который требует "
"наличие прав доступа к серверной машине. Тогда типичная настройка порта для "
"административной консоли будет выглядеть следующим образом:"

#: ../doc/1.7/book/admin/security.rst:65
msgid "console.listen('/var/lib/tarantool/socket_name.sock')"
msgstr "console.listen('/var/lib/tarantool/socket_name.sock')"

#: ../doc/1.7/book/admin/security.rst:69
msgid "and a typical connection :ref:`URI <index-uri>` is:"
msgstr "а типичный :ref:`URI <index-uri>` для соединения будет таким:"

#: ../doc/1.7/book/admin/security.rst:71
msgid "/var/lib/tarantool/socket_name.sock"
msgstr "/var/lib/tarantool/socket_name.sock"

#: ../doc/1.7/book/admin/security.rst:75
msgid ""
"if the listener has the privilege to write on ``/var/lib/tarantool`` and the "
"connector has the privilege to read on ``/var/lib/tarantool``. Alternatively, to "
"connect to an admin console of an instance started with ``tarantoolctl``, use :"
"ref:`tarantoolctl enter <admin-executing_code_on_an_instance>`."
msgstr ""
"если у приемника событий есть права на запись в ``/var/lib/tarantool`` и у "
"коннектора есть права на чтение из ``/var/lib/tarantool``. Еще один способ "
"подключиться к административной консоли экземпляра, запущенного с помощью "
"``tarantoolctl``, - использовать  :ref:`tarantoolctl enter <admin-"
"executing_code_on_an_instance>`."

#: ../doc/1.7/book/admin/security.rst:80
msgid ""
"To find out whether a TCP port is a port for admin console, use ``telnet``. For "
"example:"
msgstr ""
"Выяснить, является ли некоторый TCP-порт портом для административной консоли, "
"можно с помощью ``telnet``. Например:"

#: ../doc/1.7/book/admin/security.rst:83
msgid ""
"$ telnet 0 3303\n"
"Trying 0.0.0.0...\n"
"Connected to 0.\n"
"Escape character is '^]'.\n"
"Tarantool 1.7.3 (Lua console)\n"
"type 'help' for interactive help"
msgstr ""
"$ telnet 0 3303\n"
"Trying 0.0.0.0...\n"
"Connected to 0.\n"
"Escape character is '^]'.\n"
"Tarantool 1.7.3 (Lua console)\n"
"type 'help' for interactive help"

#: ../doc/1.7/book/admin/security.rst:92
msgid ""
"In this example, the response does not include the word \"binary\" and does "
"include the words \"Lua console\". Therefore it is clear that this is a "
"successful connection to a port for admin console, and you can now enter admin "
"requests on this terminal."
msgstr ""
"В этом примере в ответе от сервера нет слова \"binary\" и есть слова \"Lua "
"console\". Это значит, что мы успешно подключились к порту для административной "
"консоли и можем вводить администраторские запросы на этом терминале."

#: ../doc/1.7/book/admin/security.rst:97
msgid "When you connect to a binary port:"
msgstr "Если вы подключены к бинарному порту:"

#: ../doc/1.7/book/admin/security.rst:99
msgid "The client-server protocol is :ref:`binary <box_protocol-iproto_protocol>`."
msgstr ""
"Клиент-серверный протокол - :ref:`бинарный <box_protocol-iproto_protocol>`."

#: ../doc/1.7/book/admin/security.rst:100
msgid "The user is automatically ':ref:`guest <authentication-users>`'."
msgstr ""
"Автоматически выбирается пользователь ':ref:`guest <authentication-users>`'."

#: ../doc/1.7/book/admin/security.rst:101
msgid "To change the user, it’s necessary to authenticate."
msgstr "Для смены пользователя необходимо пройти аутентификацию."

#: ../doc/1.7/book/admin/security.rst:103
msgid ""
"For ease of use, ``tarantoolctl connect`` command automatically detects the type "
"of connection during handshake and uses :ref:`EVAL <box_protocol-eval>` binary "
"protocol command when it’s necessary to execute Lua commands over a binary "
"connection. To execute EVAL, the authenticated user must have global \"EXECUTE\" "
"privilege."
msgstr ""
"Для удобства использования команда ``tarantoolctl connect`` автоматически "
"определяет тип подключения при установке соединения и использует команду "
"бинарного протокола :ref:`EVAL <box_protocol-eval>` для выполнения Lua-команд по "
"бинарному подключению. Чтобы выполнить команду EVAL, аутентифицированный "
"пользователь должен иметь глобальные \"EXECUTE\"-права."

#: ../doc/1.7/book/admin/security.rst:109
msgid ""
"Therefore, when ``ssh`` access to the machine is not available, creating a "
"Tarantool user with global \"EXECUTE\" privilege and non-empty password can be "
"used to provide a system administrator **remote** access to an instance."
msgstr ""
"Поэтому при невозможности подключиться к машине по ``ssh`` системный "
"администратор может получить **удаленный** доступ к экземпляру, создав "
"пользователя Tarantool с глобальными \"EXECUTE\"-правами и непустым паролем."

#: ../doc/1.7/book/admin/server_introspection.rst:39
msgid "Server introspection"
msgstr "Просмотр состояния сервера"

#: ../doc/1.7/book/admin/server_introspection.rst:45
msgid "Using Tarantool as a client"
msgstr "Использование Tarantool'а в качестве клиента"

#: ../doc/1.7/book/admin/server_introspection.rst:47
msgid "Tarantool enters the interactive mode if:"
msgstr "Tarantool входит в интерактивный режим, если:"

#: ../doc/1.7/book/admin/server_introspection.rst:49
msgid ""
"you start Tarantool without an :ref:`instance file <admin-instance_file>`, or"
msgstr "вы запускаете его без :ref:`файла экземпляра <admin-instance_file>`, либо"

#: ../doc/1.7/book/admin/server_introspection.rst:52
msgid "the instance file contains :ref:`console.start() <console-start>`."
msgstr ""
"в файле экземпляра содержится команда :ref:`console.start() <console-start>`."

#: ../doc/1.7/book/admin/server_introspection.rst:54
msgid ""
"Tarantool displays a prompt (e.g. \"tarantool>\") and you can enter requests. "
"When used this way, Tarantool can be a client for a remote server. See basic "
"examples in :ref:`Getting started <getting_started>`."
msgstr ""
"Tarantool выводит приглашение командной строки (например, \"tarantool>\") - и вы "
"можете посылать запросы. Если использовать Tarantool таким образом, он может "
"выступать клиентом для удаленного сервера, см. простые примеры в :ref:"
"`Руководстве для начинающих <getting_started>`."

#: ../doc/1.7/book/admin/server_introspection.rst:58
msgid ""
"The interactive mode is used by ``tarantoolctl`` to implement \"enter\" and "
"\"connect\" commands."
msgstr ""
"Скрипт ``tarantoolctl`` использует интерактивный режим для реализации команд  "
"\"enter\" и \"connect\"."

#: ../doc/1.7/book/admin/server_introspection.rst:65
msgid "Executing code on an instance"
msgstr "Выполнение кода на экземпляре Tarantool'а"

#: ../doc/1.7/book/admin/server_introspection.rst:67
#, fuzzy
msgid ""
"You can attach to an instance's :ref:`admin console <admin-security>` and "
"execute some Lua code using ``tarantoolctl``:"
msgstr ""
"Можно подключиться к административной консоли запущенного экземпляра Tarantool-"
"сервера и выполнить некий Lua-код с помощью утилиты ``tarantoolctl``:"

#: ../doc/1.7/book/admin/server_introspection.rst:70
msgid ""
"$ # for local instances:\n"
"$ tarantoolctl enter my_app\n"
"/bin/tarantoolctl: Found my_app.lua in /etc/tarantool/instances.available\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/my_app.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/my_app.control\n"
"unix/:/var/run/tarantool/my_app.control> 1 + 1\n"
"---\n"
"- 2\n"
"...\n"
"unix/:/var/run/tarantool/my_app.control>\n"
"\n"
"$ # for local and remote instances:\n"
"$ tarantoolctl connect username:password@127.0.0.1:3306"
msgstr ""
"$ # для локальных экземпляров:\n"
"$ tarantoolctl enter my_app\n"
"/bin/tarantoolctl: Found my_app.lua in /etc/tarantool/instances.available\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/my_app.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/my_app.control\n"
"unix/:/var/run/tarantool/my_app.control> 1 + 1\n"
"---\n"
"- 2\n"
"...\n"
"unix/:/var/run/tarantool/my_app.control>\n"
"\n"
"$ # для локальных и удаленных экземпляров:\n"
"$ tarantoolctl connect username:password@127.0.0.1:3306"

#: ../doc/1.7/book/admin/server_introspection.rst:86
msgid ""
"You can also use ``tarantoolctl`` to execute Lua code on an instance without "
"attaching to its admin console. For example:"
msgstr ""
"Можно также использовать ``tarantoolctl`` для выполнения Lua-кода на запущенном "
"экземпляре Tarantool-сервера, не подключаясь к его административной консоли. "
"Например:"

#: ../doc/1.7/book/admin/server_introspection.rst:89
msgid ""
"# executing commands directly from the command line\n"
"$ <command> | tarantoolctl eval my_app\n"
"<...>\n"
"$ # - OR -\n"
"# executing commands from a script file\n"
"$ tarantoolctl eval my_app script.lua\n"
"<...>"
msgstr ""
"# выполнение команд напрямую из командной строки\n"
"$ <комманда> | tarantoolctl eval my_app\n"
"<...>\n"
"$ # - ИЛИ -\n"
"# выполнение команд из скрипта\n"
"$ tarantoolctl eval my_app script.lua\n"
"<...>"

#: ../doc/1.7/book/admin/server_introspection.rst:101
msgid ""
"Alternatively, you can use the :ref:`console <console-module>` module or the :"
"ref:`net.box <net_box-module>` module from a Tarantool server. Also, you can "
"write your client programs with any of the :ref:`connectors <index-"
"box_connectors>`. However, most of the examples in this manual illustrate usage "
"with either ``tarantoolctl connect`` or :ref:`using the Tarantool server as a "
"client <admin-using_tarantool_as_a_client>`."
msgstr ""
"Еще можно использовать модули :ref:`console <console-module>` и :ref:`net.box "
"<net_box-module>` из Tarantool-сервера. Также вы можете писать свои клиентские "
"программы с использованием любого из доступных :ref:`коннекторов <index-"
"box_connectors>`. Однако большинство примеров в данном документе использует или "
"``tarantoolctl connect``, или :ref:`Tarantool-сервер как клиент <admin-"
"using_tarantool_as_a_client>`."

#: ../doc/1.7/book/admin/server_introspection.rst:112
msgid "Health checks"
msgstr "Проверка состояния экземпляра"

#: ../doc/1.7/book/admin/server_introspection.rst:114
msgid "To check the instance status, say:"
msgstr "Чтобы проверить статус экземпляра Tarantool-сервера, выполните команду:"

#: ../doc/1.7/book/admin/server_introspection.rst:116
msgid ""
"$ tarantoolctl status my_app\n"
"my_app is running (pid: /var/run/tarantool/my_app.pid)\n"
"$ # - OR -\n"
"$ systemctl status tarantool@my_app\n"
"tarantool@my_app.service - Tarantool Database Server\n"
"Loaded: loaded (/etc/systemd/system/tarantool@.service; disabled; vendor preset: "
"disabled)\n"
"Active: active (running)\n"
"Docs: man:tarantool(1)\n"
"Process: 5346 ExecStart=/usr/bin/tarantoolctl start %I (code=exited, status=0/"
"SUCCESS)\n"
"Main PID: 5350 (tarantool)\n"
"Tasks: 11 (limit: 512)\n"
"CGroup: /system.slice/system-tarantool.slice/tarantool@my_app.service\n"
"+ 5350 tarantool my_app.lua <running>"
msgstr ""
"$ tarantoolctl status my_app\n"
"my_app is running (pid: /var/run/tarantool/my_app.pid)\n"
"$ # - ИЛИ -\n"
"$ systemctl status tarantool@my_app\n"
"tarantool@my_app.service - Tarantool Database Server\n"
"Loaded: loaded (/etc/systemd/system/tarantool@.service; disabled; vendor preset: "
"disabled)\n"
"Active: active (running)\n"
"Docs: man:tarantool(1)\n"
"Process: 5346 ExecStart=/usr/bin/tarantoolctl start %I (code=exited, status=0/"
"SUCCESS)\n"
"Main PID: 5350 (tarantool)\n"
"Tasks: 11 (limit: 512)\n"
"CGroup: /system.slice/system-tarantool.slice/tarantool@my_app.service\n"
"+ 5350 tarantool my_app.lua <running>"

#: ../doc/1.7/book/admin/server_introspection.rst:132
msgid "To check the boot log, on systems with ``systemd``, say:"
msgstr ""
"Если вы используете систему, на которой доступна утилита ``systemd``, выполните "
"следующую команду для проверки содержимого журнала загрузки:"

#: ../doc/1.7/book/admin/server_introspection.rst:134
msgid ""
"$ journalctl -u tarantool@my_app -n 5\n"
"-- Logs begin at Fri 2016-01-08 12:21:53 MSK, end at Thu 2016-01-21 21:17:47 "
"MSK. --\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Stopped Tarantool Database "
"Server.\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Starting Tarantool Database "
"Server...\n"
"Jan 21 21:17:47 localhost.localdomain tarantoolctl[5969]: /usr/bin/tarantoolctl: "
"Found my_app.lua in /etc/tarantool/instances.available\n"
"Jan 21 21:17:47 localhost.localdomain tarantoolctl[5969]: /usr/bin/tarantoolctl: "
"Starting instance...\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Started Tarantool Database "
"Server"
msgstr ""
"$ journalctl -u tarantool@my_app -n 5\n"
"-- Logs begin at Fri 2016-01-08 12:21:53 MSK, end at Thu 2016-01-21 21:17:47 "
"MSK. --\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Stopped Tarantool Database "
"Server.\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Starting Tarantool Database "
"Server...\n"
"Jan 21 21:17:47 localhost.localdomain tarantoolctl[5969]: /usr/bin/tarantoolctl: "
"Found my_app.lua in /etc/tarantool/instances.available\n"
"Jan 21 21:17:47 localhost.localdomain tarantoolctl[5969]: /usr/bin/tarantoolctl: "
"Starting instance...\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Started Tarantool Database "
"Server"

#: ../doc/1.7/book/admin/server_introspection.rst:144
msgid ""
"For more details, use the reports provided by functions in the following "
"submodules:"
msgstr ""
"Более подробная информация содержится в отчетах, которые можно получить с "
"помощью функций из следующих подмодулей:"

#: ../doc/1.7/book/admin/server_introspection.rst:146
msgid ""
":ref:`box.cfg <box_introspection-box_cfg>` submodule (check and specify all "
"configuration parameters for the Tarantool server)"
msgstr ""
":ref:`box.cfg <box_introspection-box_cfg>` - проверка и указание всех "
"конфигурационных параметров Tarantool-сервера,"

#: ../doc/1.7/book/admin/server_introspection.rst:149
msgid ""
":ref:`box.slab <box_introspection-box_slab>` submodule (monitor the total use "
"and fragmentation of memory allocated for storing data in Tarantool)"
msgstr ""
":ref:`box.slab <box_introspection-box_slab>` - мониторинг использования и "
"фрагментированности памяти, выделенной для хранение данных в Tarantool'е,"

#: ../doc/1.7/book/admin/server_introspection.rst:152
msgid ""
":ref:`box.info <box_introspection-box_info>` submodule (introspect Tarantool "
"server variables, primarily those related to replication)"
msgstr ""
":ref:`box.info <box_introspection-box_info>` - просмотр переменных Tarantool-"
"сервера - в первую очередь тех, что относятся к репликации,"

#: ../doc/1.7/book/admin/server_introspection.rst:155
msgid ""
":ref:`box.stat <box_introspection-box_stat>` submodule (introspect Tarantool "
"request and network statistics)"
msgstr ""
":ref:`box.stat <box_introspection-box_stat>` - просмотр статистики Tarantool'а "
"по запросам и использованию сети,"

#: ../doc/1.7/book/admin/server_introspection.rst:158
msgid ""
"You can also try `tarantool/prometheus <https://github.com/tarantool/"
"prometheus>`_, a Lua module that makes it easy to collect metrics (e.g. memory "
"usage or number of requests) from Tarantool applications and databases and "
"expose them via the Prometheus protocol."
msgstr ""
"Можно также попробовать воспользоваться Lua-модулем `tarantool/prometheus "
"<https://github.com/tarantool/prometheus>`_, который облегчает сбор метрик "
"(например, использование памяти или количество запросов) с Tarantool-приложений "
"и баз данных и их публикацию через протокол Prometheus."

#: ../doc/1.7/book/admin/server_introspection.rst:163
#: ../doc/1.7/book/box/authentication.rst:255
#: ../doc/1.7/book/box/box_schema.rst:116 ../doc/1.7/book/box/box_session.rst:143
#: ../doc/1.7/book/box/box_session.rst:172 ../doc/1.7/book/box/box_session.rst:216
#: ../doc/1.7/book/box/triggers.rst:106
msgid "**Example**"
msgstr "**Пример**"

#: ../doc/1.7/book/admin/server_introspection.rst:165
msgid ""
"A very popular administrator request is :ref:`box.slab.info() <box_slab_info>`, "
"which displays detailed memory usage statistics for a Tarantool instance."
msgstr ""
"Очень часто администраторам приходится вызывать функцию :ref:`box.slab.info() "
"<box_slab_info>`, которая показывает подробную статистику по использованию "
"памяти для конкретного экземпляра Tarantool'а."

#: ../doc/1.7/book/admin/server_introspection.rst:168
msgid ""
"tarantool> box.slab.info()\n"
"---\n"
"- items_size: 228128\n"
"  items_used_ratio: 1.8%\n"
"  quota_size: 1073741824\n"
"  quota_used_ratio: 0.8%\n"
"  arena_used_ratio: 43.2%\n"
"  items_used: 4208\n"
"  quota_used: 8388608\n"
"  arena_size: 2325176\n"
"  arena_used: 1003632\n"
"..."
msgstr ""
"tarantool> box.slab.info()\n"
"---\n"
"- items_size: 228128\n"
"  items_used_ratio: 1.8%\n"
"  quota_size: 1073741824\n"
"  quota_used_ratio: 0.8%\n"
"  arena_used_ratio: 43.2%\n"
"  items_used: 4208\n"
"  quota_used: 8388608\n"
"  arena_size: 2325176\n"
"  arena_used: 1003632\n"
"..."

#: ../doc/1.7/book/admin/server_introspection.rst:187
msgid "Profiling performance issues"
msgstr "Профилирование производительности"

#: ../doc/1.7/book/admin/server_introspection.rst:189
msgid ""
"Tarantool can at times work slower than usual. There can be multiple reasons, "
"such as disk issues, CPU-intensive Lua scripts or misconfiguration. Tarantool’s "
"log may lack details in such cases, so the only indications that something goes "
"wrong are log entries like this: ``W> too long DELETE: 8.546 sec``. Here are "
"tools and techniques that can help you collect Tarantool’s performance profile, "
"which is helpful in troubleshooting slowdowns."
msgstr ""
"Иногда Tarantool может работать медленнее, чем обычно. Причин такого поведения "
"может быть несколько: проблемы с диском, Lua-скрипты, активно использующие "
"процессор, или неправильная настройка. В таких случаях в журнале Tarantool’а "
"могут отсутствовать необходимые подробности, поэтому единственным признаком "
"неправильного поведения является наличие в журнале записей вида ``W> too long "
"DELETE: 8.546 sec``. Ниже приведены инструменты и приемы, которые облегчают "
"снятие профиля производительности Tarantool’а. Эта процедура может помочь при "
"решении проблем с замедлением."

#: ../doc/1.7/book/admin/server_introspection.rst:198
msgid ""
"Most of these tools -- except ``fiber.info()`` -- are intended for generic GNU/"
"Linux distributions, but not FreeBSD or Mac OS."
msgstr ""
"Большинство инструментов, за исключением ``fiber.info()``, предназначено для "
"дистрибутивов GNU/Linux, но не для FreeBSD или Mac OS."

#: ../doc/1.7/book/admin/server_introspection.rst:203
msgid "fiber.info()"
msgstr "fiber.info()"

#: ../doc/1.7/book/admin/server_introspection.rst:205
msgid ""
"The simplest profiling method is to take advantage of Tarantool’s built-in "
"functionality. :ref:`fiber.info() <fiber-info>` returns information about all "
"running fibers with their corresponding C stack traces. You can use this data to "
"see how many fibers are running and which C functions are executed more often "
"than others."
msgstr ""
"Самый простой способ профилирования - это использование встроенного функционала "
"Tarantool’а. :ref:`fiber.info() <fiber-info>` возвращает информацию обо всех "
"работающих файберах с соответствующей трассировкой стека для языка C. Эти данные "
"показывают, сколько файберов запущенно на данный момент и какие функции, "
"написанные на C, вызываются чаще остальных."

#: ../doc/1.7/book/admin/server_introspection.rst:211
msgid "First, enter your instance’s interactive administrator console:"
msgstr ""
"Сначала войдите в интерактивную административную консоль вашего экземпляра "
"Tarantool’а:"

#: ../doc/1.7/book/admin/server_introspection.rst:213
#: ../doc/1.7/book/admin/server_introspection.rst:491
msgid "$ tarantoolctl enter NAME"
msgstr "$ tarantoolctl enter NAME"

#: ../doc/1.7/book/admin/server_introspection.rst:217
msgid "Once there, load the ``fiber`` module:"
msgstr "После этого загрузите модуль ``fiber``:"

#: ../doc/1.7/book/admin/server_introspection.rst:219
msgid "tarantool> fiber = require('fiber')"
msgstr "tarantool> fiber = require('fiber')"

#: ../doc/1.7/book/admin/server_introspection.rst:223
msgid "After that you can get the required information with ``fiber.info()``."
msgstr "Теперь можно получить необходимую информацию с помощью `fiber.info()`."

#: ../doc/1.7/book/admin/server_introspection.rst:225
msgid "At this point, you console output should look something like this:"
msgstr "На этом шаге в вашей консоли должно выводиться следующее:"

#: ../doc/1.7/book/admin/server_introspection.rst:227
msgid ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> fiber.info()\n"
"---\n"
"- 360:\n"
"    csw: 2098165\n"
"    backtrace:\n"
"    - '#0 0x4d1b77 in wal_write(journal*, journal_entry*)+487'\n"
"    - '#1 0x4bbf68 in txn_commit(txn*)+152'\n"
"    - '#2 0x4bd5d8 in process_rw(request*, space*, tuple**)+136'\n"
"    - '#3 0x4bed48 in box_process1+104'\n"
"    - '#4 0x4d72f8 in lbox_replace+120'\n"
"    - '#5 0x50f317 in lj_BC_FUNCC+52'\n"
"    fid: 360\n"
"    memory:\n"
"      total: 61744\n"
"      used: 480\n"
"    name: main\n"
"  129:\n"
"    csw: 113\n"
"    backtrace: []\n"
"    fid: 129\n"
"    memory:\n"
"      total: 57648\n"
"      used: 0\n"
"    name: 'console/unix/:'\n"
"..."
msgstr ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> fiber.info()\n"
"---\n"
"- 360:\n"
"    csw: 2098165\n"
"    backtrace:\n"
"    - '#0 0x4d1b77 in wal_write(journal*, journal_entry*)+487'\n"
"    - '#1 0x4bbf68 in txn_commit(txn*)+152'\n"
"    - '#2 0x4bd5d8 in process_rw(request*, space*, tuple**)+136'\n"
"    - '#3 0x4bed48 in box_process1+104'\n"
"    - '#4 0x4d72f8 in lbox_replace+120'\n"
"    - '#5 0x50f317 in lj_BC_FUNCC+52'\n"
"    fid: 360\n"
"    memory:\n"
"      total: 61744\n"
"      used: 480\n"
"    name: main\n"
"  129:\n"
"    csw: 113\n"
"    backtrace: []\n"
"    fid: 129\n"
"    memory:\n"
"      total: 57648\n"
"      used: 0\n"
"    name: 'console/unix/:'\n"
"..."

#: ../doc/1.7/book/admin/server_introspection.rst:258
msgid ""
"We highly recommend to assign meaningful names to fibers you create so that you "
"can find them in the ``fiber.info()`` list. In the example below, we create a "
"fiber named ``myworker``:"
msgstr ""
"Мы рекомендуем присваивать создаваемым файберам понятные имена, чтобы их можно "
"было легко найти в списке, выводимом ``fiber.info()``. В примере ниже создается "
"файбер с именем ``myworker``:"

#: ../doc/1.7/book/admin/server_introspection.rst:262
msgid ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> f = fiber.create(function() while true do fiber.sleep(0.5) end end)\n"
"---\n"
"...\n"
"tarantool> f:name('myworker') <!-- assigning the name to a fiber\n"
"---\n"
"...\n"
"tarantool> fiber.info()\n"
"---\n"
"- 102:\n"
"    csw: 14\n"
"    backtrace:\n"
"    - '#0 0x501a1a in fiber_yield_timeout+90'\n"
"    - '#1 0x4f2008 in lbox_fiber_sleep+72'\n"
"    - '#2 0x5112a7 in lj_BC_FUNCC+52'\n"
"    fid: 102\n"
"    memory:\n"
"      total: 57656\n"
"      used: 0\n"
"    name: myworker <!-- newly created background fiber\n"
"  101:\n"
"    csw: 284\n"
"    backtrace: []\n"
"    fid: 101\n"
"    memory:\n"
"      total: 57656\n"
"      used: 0\n"
"    name: interactive\n"
"..."
msgstr ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> f = fiber.create(function() while true do fiber.sleep(0.5) end end)\n"
"---\n"
"...\n"
"tarantool> f:name('myworker') <!-- assigning the name to a fiber\n"
"---\n"
"...\n"
"tarantool> fiber.info()\n"
"---\n"
"- 102:\n"
"    csw: 14\n"
"    backtrace:\n"
"    - '#0 0x501a1a in fiber_yield_timeout+90'\n"
"    - '#1 0x4f2008 in lbox_fiber_sleep+72'\n"
"    - '#2 0x5112a7 in lj_BC_FUNCC+52'\n"
"    fid: 102\n"
"    memory:\n"
"      total: 57656\n"
"      used: 0\n"
"    name: myworker <!-- newly created background fiber\n"
"  101:\n"
"    csw: 284\n"
"    backtrace: []\n"
"    fid: 101\n"
"    memory:\n"
"      total: 57656\n"
"      used: 0\n"
"    name: interactive\n"
"..."

#: ../doc/1.7/book/admin/server_introspection.rst:296
msgid "You can kill any fiber with :ref:`fiber.kill(fid) <fiber-kill>`:"
msgstr ""
"Для принудительного завершения файбера используется команда :ref:`fiber."
"kill(fid) <fiber-kill>`:"

#: ../doc/1.7/book/admin/server_introspection.rst:298
msgid ""
"tarantool> fiber.kill(102)\n"
"---\n"
"...\n"
"tarantool> fiber.info()\n"
"---\n"
"- 101:\n"
"    csw: 324\n"
"    backtrace: []\n"
"    fid: 101\n"
"    memory:\n"
"      total: 57656\n"
"      used: 0\n"
"    name: interactive\n"
"..."
msgstr ""
"tarantool> fiber.kill(102)\n"
"---\n"
"...\n"
"tarantool> fiber.info()\n"
"---\n"
"- 101:\n"
"    csw: 324\n"
"    backtrace: []\n"
"    fid: 101\n"
"    memory:\n"
"      total: 57656\n"
"      used: 0\n"
"    name: interactive\n"
"..."

#: ../doc/1.7/book/admin/server_introspection.rst:315
msgid ""
"If you want to dynamically obtain information with ``fiber.info()``, the shell "
"script below may come in handy. It connects to a Tarantool instance specified by "
"``NAME`` every 0.5 seconds, grabs the ``fiber.info()`` output and writes it to "
"the ``fiber-info.txt`` file:"
msgstr ""
"Если вам необходимо динамически получать информацию с помощью ``fiber.info()``, "
"вам может пригодиться приведенный ниже скрипт. Он каждые полсекунды подключается "
"к экземпляру Tarantool’а, указанному в переменной ``NAME``, выполняет команду "
"``fiber.info()`` и записывает ее выход в файл ``fiber-info.txt``:"

#: ../doc/1.7/book/admin/server_introspection.rst:320
msgid ""
"$ rm -f fiber.info.txt\n"
"$ watch -n 0.5 \"echo 'require(\\\"fiber\\\").info()' | tarantoolctl enter NAME "
"| tee -a fiber-info.txt\""
msgstr ""
"$ rm -f fiber.info.txt\n"
"$ watch -n 0.5 \"echo 'require(\\\"fiber\\\").info()' | tarantoolctl enter NAME "
"| tee -a fiber-info.txt\""

#: ../doc/1.7/book/admin/server_introspection.rst:325
msgid ""
"If you can't understand which fiber causes performance issues, collect the "
"metrics of the ``fiber.info()`` output for 10-15 seconds using the script above "
"and contact the Tarantool team at support@tarantool.org."
msgstr ""
"Если вы не можете самостоятельно разобраться, какой именно файбер вызывает "
"проблемы с производительностью, запустите данный скрипт на 10-15 секунд и "
"пришлите получившийся файл команде Tarantool’а на адрес support@tarantool.org."

#: ../doc/1.7/book/admin/server_introspection.rst:331
msgid "Poor man’s profilers"
msgstr "Простейшие профилировщики"

#: ../doc/1.7/book/admin/server_introspection.rst:333
msgid "**pstack <pid>**"
msgstr "**pstack <pid>**"

#: ../doc/1.7/book/admin/server_introspection.rst:335
msgid ""
"To use this tool, first install it with a package manager that comes with your "
"Linux distribution. This command prints an execution stack trace of a running "
"process specified by the PID. You might want to run this command several times "
"in a row to pinpoint the bottleneck that causes the slowdown."
msgstr ""
"Чтобы использовать этот инструмент, его необходимо установить с помощью "
"пакетного менеджера, поставляемого с вашим дистрибутивом Linux. Данная команда "
"выводит трассировку стека выполнения для работающего процесса с соответствующим "
"PID. При необходимости команду можно запустить несколько раз, чтобы выявить "
"узкое место, которое вызывает падение производительности."

#: ../doc/1.7/book/admin/server_introspection.rst:340
msgid "Once installed, say:"
msgstr "После установки воспользуйтесь следующей командой:"

#: ../doc/1.7/book/admin/server_introspection.rst:342
msgid "$ pstack $(pidof tarantool INSTANCENAME.lua)"
msgstr "$ pstack $(pidof tarantool INSTANCENAME.lua)"

#: ../doc/1.7/book/admin/server_introspection.rst:346
#: ../doc/1.7/book/admin/server_introspection.rst:393
msgid "Next, say:"
msgstr "Затем выполните:"

#: ../doc/1.7/book/admin/server_introspection.rst:348
#: ../doc/1.7/book/admin/server_introspection.rst:395
msgid "$ echo $(pidof tarantool INSTANCENAME.lua)"
msgstr "$ echo $(pidof tarantool INSTANCENAME.lua)"

#: ../doc/1.7/book/admin/server_introspection.rst:352
#: ../doc/1.7/book/admin/server_introspection.rst:399
msgid ""
"to show the PID of the Tarantool instance that runs the ``INSTANCENAME.lua`` "
"file."
msgstr ""
"чтобы вывести на экран PID экземпляра Tarantool’а, использующего файл "
"``INSTANCENAME.lua``."

#: ../doc/1.7/book/admin/server_introspection.rst:354
msgid "You should get similar output:"
msgstr "В вашей консоли должно отображаться приблизительно следующее:"

#: ../doc/1.7/book/admin/server_introspection.rst:356
msgid ""
"Thread 19 (Thread 0x7f09d1bff700 (LWP 24173)):\n"
"#0 0x00007f0a1a5423f2 in ?? () from /lib64/libgomp.so.1\n"
"#1 0x00007f0a1a53fdc0 in ?? () from /lib64/libgomp.so.1\n"
"#2 0x00007f0a1ad5adc5 in start_thread () from /lib64/libpthread.so.0\n"
"#3 0x00007f0a1a050ced in clone () from /lib64/libc.so.6\n"
"Thread 18 (Thread 0x7f09d13fe700 (LWP 24174)):\n"
"#0 0x00007f0a1a5423f2 in ?? () from /lib64/libgomp.so.1\n"
"#1 0x00007f0a1a53fdc0 in ?? () from /lib64/libgomp.so.1\n"
"#2 0x00007f0a1ad5adc5 in start_thread () from /lib64/libpthread.so.0\n"
"#3 0x00007f0a1a050ced in clone () from /lib64/libc.so.6\n"
"<...>\n"
"Thread 2 (Thread 0x7f09c8bfe700 (LWP 24191)):\n"
"#0 0x00007f0a1ad5e6d5 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/"
"libpthread.so.0\n"
"#1 0x000000000045d901 in wal_writer_pop(wal_writer*) ()\n"
"#2 0x000000000045db01 in wal_writer_f(__va_list_tag*) ()\n"
"#3 0x0000000000429abc in fiber_cxx_invoke(int (*)(__va_list_tag*), "
"__va_list_tag*) ()\n"
"#4 0x00000000004b52a0 in fiber_loop ()\n"
"#5 0x00000000006099cf in coro_init ()\n"
"Thread 1 (Thread 0x7f0a1c47fd80 (LWP 24172)):\n"
"#0 0x00007f0a1a0512c3 in epoll_wait () from /lib64/libc.so.6\n"
"#1 0x00000000006051c8 in epoll_poll ()\n"
"#2 0x0000000000607533 in ev_run ()\n"
"#3 0x0000000000428e13 in main ()"
msgstr ""
"Thread 19 (Thread 0x7f09d1bff700 (LWP 24173)):\n"
"#0 0x00007f0a1a5423f2 in ?? () from /lib64/libgomp.so.1\n"
"#1 0x00007f0a1a53fdc0 in ?? () from /lib64/libgomp.so.1\n"
"#2 0x00007f0a1ad5adc5 in start_thread () from /lib64/libpthread.so.0\n"
"#3 0x00007f0a1a050ced in clone () from /lib64/libc.so.6\n"
"Thread 18 (Thread 0x7f09d13fe700 (LWP 24174)):\n"
"#0 0x00007f0a1a5423f2 in ?? () from /lib64/libgomp.so.1\n"
"#1 0x00007f0a1a53fdc0 in ?? () from /lib64/libgomp.so.1\n"
"#2 0x00007f0a1ad5adc5 in start_thread () from /lib64/libpthread.so.0\n"
"#3 0x00007f0a1a050ced in clone () from /lib64/libc.so.6\n"
"<...>\n"
"Thread 2 (Thread 0x7f09c8bfe700 (LWP 24191)):\n"
"#0 0x00007f0a1ad5e6d5 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/"
"libpthread.so.0\n"
"#1 0x000000000045d901 in wal_writer_pop(wal_writer*) ()\n"
"#2 0x000000000045db01 in wal_writer_f(__va_list_tag*) ()\n"
"#3 0x0000000000429abc in fiber_cxx_invoke(int (*)(__va_list_tag*), "
"__va_list_tag*) ()\n"
"#4 0x00000000004b52a0 in fiber_loop ()\n"
"#5 0x00000000006099cf in coro_init ()\n"
"Thread 1 (Thread 0x7f0a1c47fd80 (LWP 24172)):\n"
"#0 0x00007f0a1a0512c3 in epoll_wait () from /lib64/libc.so.6\n"
"#1 0x00000000006051c8 in epoll_poll ()\n"
"#2 0x0000000000607533 in ev_run ()\n"
"#3 0x0000000000428e13 in main ()"

#: ../doc/1.7/book/admin/server_introspection.rst:382
msgid "**gdb -ex \"bt\" -p <pid>**"
msgstr "**gdb -ex \"bt\" -p <pid>**"

#: ../doc/1.7/book/admin/server_introspection.rst:384
msgid ""
"As with ``pstack``, the GNU debugger (also known as ``gdb``) needs to be "
"installed before you can start using it. Your Linux package manager can help you "
"with that."
msgstr ""
"Как и в случае с ``pstack``,  перед использованием GNU-отладчик (также известный "
"как ``gdb``) необходимо сначала установить через пакетный менеджер, встроенный в "
"ваш дистрибутив Linux."

#: ../doc/1.7/book/admin/server_introspection.rst:387
msgid "Once the debugger is installed, say:"
msgstr "После установки воспользуйтесь следующей командой:"

#: ../doc/1.7/book/admin/server_introspection.rst:389
msgid ""
"$ gdb -ex \"set pagination 0\" -ex \"thread apply all bt\" --batch -p $(pidof "
"tarantool INSTANCENAME.lua)"
msgstr ""
"$ gdb -ex \"set pagination 0\" -ex \"thread apply all bt\" --batch -p $(pidof "
"tarantool INSTANCENAME.lua)"

#: ../doc/1.7/book/admin/server_introspection.rst:401
msgid "After using the debugger, your console output should look like this:"
msgstr ""
"После использования отладчика в консоль должна выводиться следующая информация:"

#: ../doc/1.7/book/admin/server_introspection.rst:403
msgid ""
"[Thread debugging using libthread_db enabled]\n"
"Using host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\".\n"
"\n"
"[CUT]\n"
"\n"
"Thread 1 (Thread 0x7f72289ba940 (LWP 20535)):\n"
"#0 _int_malloc (av=av@entry=0x7f7226e0eb20 <main_arena>, bytes=bytes@entry=504) "
"at malloc.c:3697\n"
"#1 0x00007f7226acf21a in __libc_calloc (n=<optimized out>, elem_size=<optimized "
"out>) at malloc.c:3234\n"
"#2 0x00000000004631f8 in vy_merge_iterator_reserve (capacity=3, "
"itr=0x7f72264af9e0) at /usr/src/tarantool/src/box/vinyl.c:7629\n"
"#3 vy_merge_iterator_add (itr=itr@entry=0x7f72264af9e0, "
"is_mutable=is_mutable@entry=true, belong_range=belong_range@entry=false) at /usr/"
"src/tarantool/src/box/vinyl.c:7660\n"
"#4 0x00000000004703df in vy_read_iterator_add_mem (itr=0x7f72264af990) at /usr/"
"src/tarantool/src/box/vinyl.c:8387\n"
"#5 vy_read_iterator_use_range (itr=0x7f72264af990) at /usr/src/tarantool/src/box/"
"vinyl.c:8453\n"
"#6 0x000000000047657d in vy_read_iterator_start (itr=<optimized out>) at /usr/"
"src/tarantool/src/box/vinyl.c:8501\n"
"#7 0x00000000004766b5 in vy_read_iterator_next (itr=itr@entry=0x7f72264af990, "
"result=result@entry=0x7f72264afad8) at /usr/src/tarantool/src/box/vinyl.c:8592\n"
"#8 0x000000000047689d in vy_index_get (tx=tx@entry=0x7f7226468158, "
"index=index@entry=0x2563860, key=<optimized out>, part_count=<optimized out>, "
"result=result@entry=0x7f72264afad8) at /usr/src/tarantool/src/box/vinyl.c:5705\n"
"#9 0x0000000000477601 in vy_replace_impl (request=<optimized out>, "
"request=<optimized out>, stmt=0x7f72265a7150, space=0x2567ea0, "
"tx=0x7f7226468158) at /usr/src/tarantool/src/box/vinyl.c:5920\n"
"#10 vy_replace (tx=0x7f7226468158, stmt=stmt@entry=0x7f72265a7150, "
"space=0x2567ea0, request=<optimized out>) at /usr/src/tarantool/src/box/vinyl."
"c:6608\n"
"#11 0x00000000004615a9 in VinylSpace::executeReplace (this=<optimized out>, "
"txn=<optimized out>, space=<optimized out>, request=<optimized out>) at /usr/src/"
"tarantool/src/box/vinyl_space.cc:108\n"
"#12 0x00000000004bd723 in process_rw (request=request@entry=0x7f72265a70f8, "
"space=space@entry=0x2567ea0, result=result@entry=0x7f72264afbc8) at /usr/src/"
"tarantool/src/box/box.cc:182\n"
"#13 0x00000000004bed48 in box_process1 (request=0x7f72265a70f8, "
"result=result@entry=0x7f72264afbc8) at /usr/src/tarantool/src/box/box.cc:700\n"
"#14 0x00000000004bf389 in box_replace (space_id=space_id@entry=513, "
"tuple=<optimized out>, tuple_end=<optimized out>, "
"result=result@entry=0x7f72264afbc8) at /usr/src/tarantool/src/box/box.cc:754\n"
"#15 0x00000000004d72f8 in lbox_replace (L=0x413c5780) at /usr/src/tarantool/src/"
"box/lua/index.c:72\n"
"#16 0x000000000050f317 in lj_BC_FUNCC ()\n"
"#17 0x00000000004d37c7 in execute_lua_call (L=0x413c5780) at /usr/src/tarantool/"
"src/box/lua/call.c:282\n"
"#18 0x000000000050f317 in lj_BC_FUNCC ()\n"
"#19 0x0000000000529c7b in lua_cpcall ()\n"
"#20 0x00000000004f6aa3 in luaT_cpcall (L=L@entry=0x413c5780, "
"func=func@entry=0x4d36d0 <execute_lua_call>, ud=ud@entry=0x7f72264afde0) at /usr/"
"src/tarantool/src/lua/utils.c:962\n"
"#21 0x00000000004d3fe7 in box_process_lua (handler=0x4d36d0 <execute_lua_call>, "
"out=out@entry=0x7f7213020600, request=request@entry=0x413c5780) at /usr/src/"
"tarantool/src/box/lua/call.c:382\n"
"#22 box_lua_call (request=request@entry=0x7f72130401d8, "
"out=out@entry=0x7f7213020600) at /usr/src/tarantool/src/box/lua/call.c:405\n"
"#23 0x00000000004c0f27 in box_process_call "
"(request=request@entry=0x7f72130401d8, out=out@entry=0x7f7213020600) at /usr/src/"
"tarantool/src/box/box.cc:1074\n"
"#24 0x000000000041326c in tx_process_misc (m=0x7f7213040170) at /usr/src/"
"tarantool/src/box/iproto.cc:942\n"
"#25 0x0000000000504554 in cmsg_deliver (msg=0x7f7213040170) at /usr/src/"
"tarantool/src/cbus.c:302\n"
"#26 0x0000000000504c2e in fiber_pool_f (ap=<error reading variable: value has "
"been optimized out>) at /usr/src/tarantool/src/fiber_pool.c:64\n"
"#27 0x000000000041122c in fiber_cxx_invoke(fiber_func, typedef __va_list_tag "
"__va_list_tag *) (f=<optimized out>, ap=<optimized out>) at /usr/src/tarantool/"
"src/fiber.h:645\n"
"#28 0x00000000005011a0 in fiber_loop (data=<optimized out>) at /usr/src/"
"tarantool/src/fiber.c:641\n"
"#29 0x0000000000688fbf in coro_init () at /usr/src/tarantool/third_party/coro/"
"coro.c:110"
msgstr ""
"[Thread debugging using libthread_db enabled]\n"
"Using host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\".\n"
"\n"
"[CUT]\n"
"\n"
"Thread 1 (Thread 0x7f72289ba940 (LWP 20535)):\n"
"#0 _int_malloc (av=av@entry=0x7f7226e0eb20 <main_arena>, bytes=bytes@entry=504) "
"at malloc.c:3697\n"
"#1 0x00007f7226acf21a in __libc_calloc (n=<optimized out>, elem_size=<optimized "
"out>) at malloc.c:3234\n"
"#2 0x00000000004631f8 in vy_merge_iterator_reserve (capacity=3, "
"itr=0x7f72264af9e0) at /usr/src/tarantool/src/box/vinyl.c:7629\n"
"#3 vy_merge_iterator_add (itr=itr@entry=0x7f72264af9e0, "
"is_mutable=is_mutable@entry=true, belong_range=belong_range@entry=false) at /usr/"
"src/tarantool/src/box/vinyl.c:7660\n"
"#4 0x00000000004703df in vy_read_iterator_add_mem (itr=0x7f72264af990) at /usr/"
"src/tarantool/src/box/vinyl.c:8387\n"
"#5 vy_read_iterator_use_range (itr=0x7f72264af990) at /usr/src/tarantool/src/box/"
"vinyl.c:8453\n"
"#6 0x000000000047657d in vy_read_iterator_start (itr=<optimized out>) at /usr/"
"src/tarantool/src/box/vinyl.c:8501\n"
"#7 0x00000000004766b5 in vy_read_iterator_next (itr=itr@entry=0x7f72264af990, "
"result=result@entry=0x7f72264afad8) at /usr/src/tarantool/src/box/vinyl.c:8592\n"
"#8 0x000000000047689d in vy_index_get (tx=tx@entry=0x7f7226468158, "
"index=index@entry=0x2563860, key=<optimized out>, part_count=<optimized out>, "
"result=result@entry=0x7f72264afad8) at /usr/src/tarantool/src/box/vinyl.c:5705\n"
"#9 0x0000000000477601 in vy_replace_impl (request=<optimized out>, "
"request=<optimized out>, stmt=0x7f72265a7150, space=0x2567ea0, "
"tx=0x7f7226468158) at /usr/src/tarantool/src/box/vinyl.c:5920\n"
"#10 vy_replace (tx=0x7f7226468158, stmt=stmt@entry=0x7f72265a7150, "
"space=0x2567ea0, request=<optimized out>) at /usr/src/tarantool/src/box/vinyl."
"c:6608\n"
"#11 0x00000000004615a9 in VinylSpace::executeReplace (this=<optimized out>, "
"txn=<optimized out>, space=<optimized out>, request=<optimized out>) at /usr/src/"
"tarantool/src/box/vinyl_space.cc:108\n"
"#12 0x00000000004bd723 in process_rw (request=request@entry=0x7f72265a70f8, "
"space=space@entry=0x2567ea0, result=result@entry=0x7f72264afbc8) at /usr/src/"
"tarantool/src/box/box.cc:182\n"
"#13 0x00000000004bed48 in box_process1 (request=0x7f72265a70f8, "
"result=result@entry=0x7f72264afbc8) at /usr/src/tarantool/src/box/box.cc:700\n"
"#14 0x00000000004bf389 in box_replace (space_id=space_id@entry=513, "
"tuple=<optimized out>, tuple_end=<optimized out>, "
"result=result@entry=0x7f72264afbc8) at /usr/src/tarantool/src/box/box.cc:754\n"
"#15 0x00000000004d72f8 in lbox_replace (L=0x413c5780) at /usr/src/tarantool/src/"
"box/lua/index.c:72\n"
"#16 0x000000000050f317 in lj_BC_FUNCC ()\n"
"#17 0x00000000004d37c7 in execute_lua_call (L=0x413c5780) at /usr/src/tarantool/"
"src/box/lua/call.c:282\n"
"#18 0x000000000050f317 in lj_BC_FUNCC ()\n"
"#19 0x0000000000529c7b in lua_cpcall ()\n"
"#20 0x00000000004f6aa3 in luaT_cpcall (L=L@entry=0x413c5780, "
"func=func@entry=0x4d36d0 <execute_lua_call>, ud=ud@entry=0x7f72264afde0) at /usr/"
"src/tarantool/src/lua/utils.c:962\n"
"#21 0x00000000004d3fe7 in box_process_lua (handler=0x4d36d0 <execute_lua_call>, "
"out=out@entry=0x7f7213020600, request=request@entry=0x413c5780) at /usr/src/"
"tarantool/src/box/lua/call.c:382\n"
"#22 box_lua_call (request=request@entry=0x7f72130401d8, "
"out=out@entry=0x7f7213020600) at /usr/src/tarantool/src/box/lua/call.c:405\n"
"#23 0x00000000004c0f27 in box_process_call "
"(request=request@entry=0x7f72130401d8, out=out@entry=0x7f7213020600) at /usr/src/"
"tarantool/src/box/box.cc:1074\n"
"#24 0x000000000041326c in tx_process_misc (m=0x7f7213040170) at /usr/src/"
"tarantool/src/box/iproto.cc:942\n"
"#25 0x0000000000504554 in cmsg_deliver (msg=0x7f7213040170) at /usr/src/"
"tarantool/src/cbus.c:302\n"
"#26 0x0000000000504c2e in fiber_pool_f (ap=<error reading variable: value has "
"been optimized out>) at /usr/src/tarantool/src/fiber_pool.c:64\n"
"#27 0x000000000041122c in fiber_cxx_invoke(fiber_func, typedef __va_list_tag "
"__va_list_tag *) (f=<optimized out>, ap=<optimized out>) at /usr/src/tarantool/"
"src/fiber.h:645\n"
"#28 0x00000000005011a0 in fiber_loop (data=<optimized out>) at /usr/src/"
"tarantool/src/fiber.c:641\n"
"#29 0x0000000000688fbf in coro_init () at /usr/src/tarantool/third_party/coro/"
"coro.c:110"

#: ../doc/1.7/book/admin/server_introspection.rst:442
msgid ""
"Run the debugger in a loop a few times to collect enough samples for making "
"conclusions about why Tarantool demonstrates suboptimal performance. Use the "
"following script:"
msgstr ""
"Запустите отладчик в цикле, чтобы собрать достаточно информации, которая поможет "
"установить причину спада производительности Tarantool’а. Можно воспользоваться "
"следующим скриптом:"

#: ../doc/1.7/book/admin/server_introspection.rst:446
msgid ""
"$ rm -f stack-trace.txt\n"
"$ watch -n 0.5 \"gdb -ex 'set pagination 0' -ex 'thread apply all bt' --batch -p "
"$(pidof tarantool INSTANCENAME.lua) | tee -a stack-trace.txt\""
msgstr ""
"$ rm -f stack-trace.txt\n"
"$ watch -n 0.5 \"gdb -ex 'set pagination 0' -ex 'thread apply all bt' --batch -p "
"$(pidof tarantool INSTANCENAME.lua) | tee -a stack-trace.txt\""

#: ../doc/1.7/book/admin/server_introspection.rst:451
msgid ""
"Structurally and functionally, this script is very similar to the one used with "
"``fiber.info()`` above."
msgstr ""
"С точки зрения структуры и функциональности, этот скрипт идентичен тому, что "
"используется выше с ``fiber.info()``."

#: ../doc/1.7/book/admin/server_introspection.rst:454
msgid ""
"If you have any difficulties troubleshooting, let the script run for 10-15 "
"seconds and then send the resulting ``stack-trace.txt`` file to the Tarantool "
"team at support@tarantool.org."
msgstr ""
"Если вам не удается отыскать причину пониженной производительности, запустите "
"данный скрипт на 10-15 секунд и пришлите получившийся файл ``stack-trace.txt`` "
"команде Tarantool’а на адрес support@tarantool.org."

#: ../doc/1.7/book/admin/server_introspection.rst:460
msgid ""
"Use the poor man’s profilers with caution: each time they attach to a running "
"process, this stops the process execution for about a second, which may leave a "
"serious footprint in high-load services."
msgstr ""
"Следует использовать ``pstack`` и ``gdb`` с осторожностью: каждый раз, "
"подключаясь с работающему процессу, они приостанавливают выполнение этого "
"процесса приблизительно на одну секунду, что может иметь серьезные последствия "
"для высоконагруженных сервисов."

#: ../doc/1.7/book/admin/server_introspection.rst:466
msgid "gperftools"
msgstr "gperftools"

#: ../doc/1.7/book/admin/server_introspection.rst:468
msgid ""
"To use the CPU profiler from the Google Performance Tools suite with Tarantool, "
"first take care of the prerequisites:"
msgstr ""
"Чтобы использовать профилировщик процессора из набора Google Performance Tools с "
"Tarantool’ом, необходимо сначала установить зависимости:"

#: ../doc/1.7/book/admin/server_introspection.rst:471
msgid "For Debian/Ubuntu, run:"
msgstr "Если вы используете Debian/Ubuntu, запустите эту команду:"

#: ../doc/1.7/book/admin/server_introspection.rst:473
msgid "$ apt-get install libgoogle-perftools4"
msgstr "$ apt-get install libgoogle-perftools4"

#: ../doc/1.7/book/admin/server_introspection.rst:477
msgid "For RHEL/CentOS/Fedora, run:"
msgstr "Если вы используете RHEL/CentOS/Fedora, запустите эту команду:"

#: ../doc/1.7/book/admin/server_introspection.rst:479
msgid "$ yum install gperftools-libs"
msgstr "$ yum install gperftools-libs"

#: ../doc/1.7/book/admin/server_introspection.rst:483
msgid "Once you do this, install Lua bindings:"
msgstr "После этого установите привязки для Lua:"

#: ../doc/1.7/book/admin/server_introspection.rst:485
msgid "$ tarantoolctl rocks install gperftools"
msgstr "$ tarantoolctl rocks install gperftools"

#: ../doc/1.7/book/admin/server_introspection.rst:489
msgid ""
"Now you're ready to go. Enter your instance’s interactive administrator console:"
msgstr ""
"После окончания установки войдите в интерактивную административную консоль "
"вашего экземпляра Tarantool’а:"

#: ../doc/1.7/book/admin/server_introspection.rst:495
msgid "To start profiling, say:"
msgstr "Для запуска профилировщика выполните следующий код:"

#: ../doc/1.7/book/admin/server_introspection.rst:497
msgid ""
"tarantool> cpuprof = require('gperftools.cpu')\n"
"tarantool> cpuprof.start('/home/<username>/tarantool-on-production.prof')"
msgstr ""
"tarantool> cpuprof = require('gperftools.cpu')\n"
"tarantool> cpuprof.start('/home/<имя_пользователя>/tarantool-on-production.prof')"

#: ../doc/1.7/book/admin/server_introspection.rst:502
msgid ""
"It takes at least a couple of minutes for the profiler to gather performance "
"metrics. After that, save the results to disk (you can do that as many times as "
"you need):"
msgstr ""
"На сбор метрик производительности у профилировщика уходит по крайней мере пара "
"минут. По истечении этого времени можно сохранять информацию на диск "
"(неограниченное количество раз):"

#: ../doc/1.7/book/admin/server_introspection.rst:506
msgid "tarantool> cpuprof.flush()"
msgstr "tarantool> cpuprof.flush()"

#: ../doc/1.7/book/admin/server_introspection.rst:510
msgid "To stop profiling, say:"
msgstr "Для остановки профилировщика выполните следующую команду:"

#: ../doc/1.7/book/admin/server_introspection.rst:512
msgid "tarantool> cpuprof.stop()"
msgstr "tarantool> cpuprof.stop()"

#: ../doc/1.7/book/admin/server_introspection.rst:516
msgid ""
"You can now analyze the output with the ``pprof`` utility that comes with the "
"``gperftools`` package:"
msgstr ""
"Теперь можно проанализировать собранные данные с помощью утилиты ``pprof``, "
"которая входит в пакет ``gperftools``:"

#: ../doc/1.7/book/admin/server_introspection.rst:519
msgid ""
"$ pprof --text /usr/bin/tarantool /home/<username>/tarantool-on-production.prof"
msgstr ""
"$ pprof --text /usr/bin/tarantool /home/<имя_пользователя>/tarantool-on-"
"production.prof"

#: ../doc/1.7/book/admin/server_introspection.rst:525
msgid "On Debian/Ubuntu, the ``pprof`` utility is called ``google-pprof``."
msgstr ""
"В дистрибутивах Debian/Ubuntu утилита ``pprof`` называется ``google-pprof``."

#: ../doc/1.7/book/admin/server_introspection.rst:527
msgid "Your output should look similar to this:"
msgstr "В консоль должно выводиться приблизительно следующее:"

#: ../doc/1.7/book/admin/server_introspection.rst:529
#, python-format
msgid ""
"Total: 598 samples\n"
"      83 13.9% 13.9% 83 13.9% epoll_wait\n"
"      54 9.0% 22.9% 102 17.1%\n"
"vy_mem_tree_insert.constprop.35\n"
"      32 5.4% 28.3% 34 5.7% __write_nocancel\n"
"      28 4.7% 32.9% 42 7.0% vy_mem_iterator_start_from\n"
"      26 4.3% 37.3% 26 4.3% _IO_str_seekoff\n"
"      21 3.5% 40.8% 21 3.5% tuple_compare_field\n"
"      19 3.2% 44.0% 19 3.2%\n"
"::TupleCompareWithKey::compare\n"
"      19 3.2% 47.2% 38 6.4% tuple_compare_slowpath\n"
"      12 2.0% 49.2% 23 3.8% __libc_calloc\n"
"       9 1.5% 50.7% 9 1.5%\n"
"::TupleCompare::compare@42efc0\n"
"       9 1.5% 52.2% 9 1.5% vy_cache_on_write\n"
"       9 1.5% 53.7% 57 9.5% vy_merge_iterator_next_key\n"
"       8 1.3% 55.0% 8 1.3% __nss_passwd_lookup\n"
"       6 1.0% 56.0% 25 4.2% gc_onestep\n"
"       6 1.0% 57.0% 6 1.0% lj_tab_next\n"
"       5 0.8% 57.9% 5 0.8% lj_alloc_malloc\n"
"       5 0.8% 58.7% 131 21.9% vy_prepare"
msgstr ""
"Total: 598 samples\n"
"      83 13.9% 13.9% 83 13.9% epoll_wait\n"
"      54 9.0% 22.9% 102 17.1%\n"
"vy_mem_tree_insert.constprop.35\n"
"      32 5.4% 28.3% 34 5.7% __write_nocancel\n"
"      28 4.7% 32.9% 42 7.0% vy_mem_iterator_start_from\n"
"      26 4.3% 37.3% 26 4.3% _IO_str_seekoff\n"
"      21 3.5% 40.8% 21 3.5% tuple_compare_field\n"
"      19 3.2% 44.0% 19 3.2%\n"
"::TupleCompareWithKey::compare\n"
"      19 3.2% 47.2% 38 6.4% tuple_compare_slowpath\n"
"      12 2.0% 49.2% 23 3.8% __libc_calloc\n"
"       9 1.5% 50.7% 9 1.5%\n"
"::TupleCompare::compare@42efc0\n"
"       9 1.5% 52.2% 9 1.5% vy_cache_on_write\n"
"       9 1.5% 53.7% 57 9.5% vy_merge_iterator_next_key\n"
"       8 1.3% 55.0% 8 1.3% __nss_passwd_lookup\n"
"       6 1.0% 56.0% 25 4.2% gc_onestep\n"
"       6 1.0% 57.0% 6 1.0% lj_tab_next\n"
"       5 0.8% 57.9% 5 0.8% lj_alloc_malloc\n"
"       5 0.8% 58.7% 131 21.9% vy_prepare"

#: ../doc/1.7/book/admin/server_introspection.rst:555
msgid "perf"
msgstr "perf"

#: ../doc/1.7/book/admin/server_introspection.rst:557
msgid ""
"This tool for performance monitoring and analysis is installed separately via "
"your package manager. Try running the ``perf`` command in the terminal and "
"follow the prompts to install the necessary package(s)."
msgstr ""
"Этот инструмент для мониторинга и анализа производительности устанавливается "
"отдельно с помощью пакетного менеджера. Попробуйте ввести в окне консоли команду "
"``perf`` и следуйте подсказкам, чтобы установить необходимые пакеты."

#: ../doc/1.7/book/admin/server_introspection.rst:563
msgid ""
"By default, some ``perf`` commands are restricted to **root**, so, to be on the "
"safe side, either run all commands as **root** or prepend them with ``sudo``."
msgstr ""
"По умолчанию некоторые команды из пакета ``perf`` можно выполнять только с "
"**root**-правами, поэтому необходимо либо зайти в систему из-под пользователя "
"**root**, либо добавлять перед каждой командой ``sudo``."

#: ../doc/1.7/book/admin/server_introspection.rst:567
msgid "To start gathering performance statistics, say:"
msgstr ""
"Чтобы начать сбор показателей производительности, выполните следующую команду:"

#: ../doc/1.7/book/admin/server_introspection.rst:569
msgid "$ perf record -g -p $(pidof tarantool INSTANCENAME.lua)"
msgstr "$ perf record -g -p $(pidof tarantool INSTANCENAME.lua)"

#: ../doc/1.7/book/admin/server_introspection.rst:573
msgid ""
"This command saves the gathered data to a file named ``perf.data`` inside the "
"current working directory. To stop this process (usually, after 10-15 seconds), "
"press **ctrl+C**. In your console, you’ll see:"
msgstr ""
"Эта команда сохраняет собранные данные в файл ``perf.data``, который находится в "
"текущей рабочей папке. Для остановки процесса (обычно через 10-15 секунд) "
"нажмите **ctrl+C**. В консоли должно появиться следующее:"

#: ../doc/1.7/book/admin/server_introspection.rst:577
msgid ""
"^C[ perf record: Woken up 1 times to write data ]\n"
"[ perf record: Captured and wrote 0.225 MB perf.data (1573 samples) ]"
msgstr ""
"^C[ perf record: Woken up 1 times to write data ]\n"
"[ perf record: Captured and wrote 0.225 MB perf.data (1573 samples) ]"

#: ../doc/1.7/book/admin/server_introspection.rst:582
msgid "Now run the following command:"
msgstr "Затем выполните эту команду:"

#: ../doc/1.7/book/admin/server_introspection.rst:584
msgid "$ perf report -n -g --stdio | tee perf-report.txt"
msgstr "$ perf report -n -g --stdio | tee perf-report.txt"

#: ../doc/1.7/book/admin/server_introspection.rst:588
msgid ""
"It formats the statistical data in the ``perf.data`` file into a performance "
"report and writes it to the ``perf-report.txt`` file."
msgstr ""
"Она превращает содержащиеся в ``perf.data`` статистические данные в отчет о "
"производительности, который сохраняется в файл ``perf-report.txt``."

#: ../doc/1.7/book/admin/server_introspection.rst:591
msgid "The resulting output should look similar to this:"
msgstr "Получившийся отчет выглядит следующим образом:"

#: ../doc/1.7/book/admin/server_introspection.rst:593
#, python-format
msgid ""
"# Samples: 14K of event 'cycles'\n"
"# Event count (approx.): 9927346847\n"
"#\n"
"# Children Self Samples Command Shared Object Symbol\n"
"# ........ ........ ............ ......... .................. .......................................\n"
"#\n"
"    35.50% 0.55% 79 tarantool tarantool [.] lj_gc_step\n"
"            |\n"
"             --34.95%--lj_gc_step\n"
"                       |\n"
"                       |--29.26%--gc_onestep\n"
"                       | |\n"
"                       | |--13.85%--gc_sweep\n"
"                       | | |\n"
"                       | | |--5.59%--lj_alloc_free\n"
"                       | | |\n"
"                       | | |--1.33%--lj_tab_free\n"
"                       | | | |\n"
"                       | | | --1.01%--lj_alloc_free\n"
"                       | | |\n"
"                       | | --1.17%--lj_cdata_free\n"
"                       | |\n"
"                       | |--5.41%--gc_finalize\n"
"                       | | |\n"
"                       | | |--1.06%--lj_obj_equal\n"
"                       | | |\n"
"                       | | --0.95%--lj_tab_set\n"
"                       | |\n"
"                       | |--4.97%--rehashtab\n"
"                       | | |\n"
"                       | | --3.65%--lj_tab_resize\n"
"                       | | |\n"
"                       | | |--0.74%--lj_tab_set\n"
"                       | | |\n"
"                       | | --0.72%--lj_tab_newkey\n"
"                       | |\n"
"                       | |--0.91%--propagatemark\n"
"                       | |\n"
"                       | --0.67%--lj_cdata_free\n"
"                       |\n"
"                        --5.43%--propagatemark\n"
"                                  |\n"
"                                   --0.73%--gc_mark"
msgstr ""
"# Samples: 14K of event 'cycles'\n"
"# Event count (approx.): 9927346847\n"
"#\n"
"# Children Self Samples Command Shared Object Symbol\n"
"# ........ ........ ............ ......... .................. .......................................\n"
"#\n"
"    35.50% 0.55% 79 tarantool tarantool [.] lj_gc_step\n"
"            |\n"
"             --34.95%--lj_gc_step\n"
"                       |\n"
"                       |--29.26%--gc_onestep\n"
"                       | |\n"
"                       | |--13.85%--gc_sweep\n"
"                       | | |\n"
"                       | | |--5.59%--lj_alloc_free\n"
"                       | | |\n"
"                       | | |--1.33%--lj_tab_free\n"
"                       | | | |\n"
"                       | | | --1.01%--lj_alloc_free\n"
"                       | | |\n"
"                       | | --1.17%--lj_cdata_free\n"
"                       | |\n"
"                       | |--5.41%--gc_finalize\n"
"                       | | |\n"
"                       | | |--1.06%--lj_obj_equal\n"
"                       | | |\n"
"                       | | --0.95%--lj_tab_set\n"
"                       | |\n"
"                       | |--4.97%--rehashtab\n"
"                       | | |\n"
"                       | | --3.65%--lj_tab_resize\n"
"                       | | |\n"
"                       | | |--0.74%--lj_tab_set\n"
"                       | | |\n"
"                       | | --0.72%--lj_tab_newkey\n"
"                       | |\n"
"                       | |--0.91%--propagatemark\n"
"                       | |\n"
"                       | --0.67%--lj_cdata_free\n"
"                       |\n"
"                        --5.43%--propagatemark\n"
"                                  |\n"
"                                   --0.73%--gc_mark"

#: ../doc/1.7/book/admin/server_introspection.rst:639
msgid ""
"Unlike the poor man’s profilers, ``gperftools`` and ``perf`` have low overhead "
"(almost negligible as compared with ``pstack`` and ``gdb``): they don’t result "
"in long delays when attaching to a process and therefore can be used without "
"serious consequences."
msgstr ""
"Инструменты ``gperftools`` и ``perf`` отличаются от ``pstack`` и ``gdb`` низкими "
"накладными расходами (пренебрежимо малыми по сравнению с ``pstack`` и ``gdb``): "
"они подключаются к работающим процессам без больших задержек, а потому могут "
"использоваться без серьезных последствий."

#: ../doc/1.7/book/admin/start_stop_instance.rst:39
msgid "Starting/stopping an instance"
msgstr "Запуск/остановка экземпляра"

#: ../doc/1.7/book/admin/start_stop_instance.rst:41
msgid ""
"While a Lua application is executed by Tarantool, an instance file is executed "
"by ``tarantoolctl`` which is a Tarantool script."
msgstr ""
"Lua-приложение выполняется Tarantool'ом, тогда как файл экземпляра выполняется "
"Tarantool-скриптом ``tarantoolctl``."

#: ../doc/1.7/book/admin/start_stop_instance.rst:44
msgid "Here is what ``tarantoolctl`` does when you issue the command:"
msgstr "Вот что делает ``tarantoolctl`` при вводе следующей команды:"

#: ../doc/1.7/book/admin/start_stop_instance.rst:46
msgid "$ tarantoolctl start <instance_name>"
msgstr "$ tarantoolctl start <имя_экземпляра>"

#: ../doc/1.7/book/admin/start_stop_instance.rst:50
msgid ""
"Read and parse the command line arguments. The last argument, in our case, "
"contains an instance name."
msgstr ""
"Считывает и разбирает аргументы командной строки. В нашем случае последний "
"аргумент содержит имя экземпляра."

#: ../doc/1.7/book/admin/start_stop_instance.rst:53
msgid ""
"Read and parse its own configuration file. This file contains ``tarantoolctl`` "
"defaults, like the path to the directory where instances should be searched for."
msgstr ""
"Считывает и разбирает собственный конфигурационный файл. Этот файл содержит "
"параметры ``tarantoolctl`` по умолчанию -- такие как путь до директории, в "
"которой располагаются экземпляры."

#: ../doc/1.7/book/admin/start_stop_instance.rst:57
msgid ""
"The default ``tarantoolctl`` configuration file is installed in ``/etc/default/"
"tarantool``. This file is used when ``tarantoolctl`` is invoked by root. When "
"invoked by a local user, ``tarantoolctl`` first looks for its defaults file in "
"the current directory (``$PWD/.tarantoolctl``), and then in the current user’s "
"home directory (``$HOME/.config/tarantool/tarantool``). If not found, "
"``tarantoolctl`` falls back to :ref:`built-in defaults <admin-"
"tarantoolctl_config_file>`."
msgstr ""
"Конфигурационный файл с параметрами ``tarantoolctl`` по умолчанию "
"устанавливается в ``/etc/default/tarantool``. Этот файл используется, когда "
"``tarantoolctl`` вызывается с root-правами. Если вызов производит локальный "
"пользователь, ``tarantoolctl`` сперва ищет свой файл с параметрами по умолчанию "
"в текущей директории (``$PWD/.tarantoolctl``), затем в домашней директории "
"текущего пользователя (``$HOME/.config/tarantool/tarantool``). Если файл не "
"найден, ``tarantoolctl`` принимает :ref:`встроенные параметры по умолчанию "
"<admin-tarantoolctl_config_file>`."

#: ../doc/1.7/book/admin/start_stop_instance.rst:65
msgid ""
"Look up the instance file in the instance directory, e.g. ``/etc/tarantool/"
"instances.enabled``. To build the instance file path, ``tarantoolctl`` takes the "
"instance name, prepends the instance directory and appends \".lua\" extension to "
"the instance file."
msgstr ""
"Ищет файл экземпляра в директории, где располагаются экземпляры, - например, в "
"``/etc/tarantool/instances.enabled``. ``tarantoolctl`` строит путь до файла "
"экземпляра следующим образом: \"путь до директории с экземплярами\" + \"имя "
"экземпляра\" + \".lua\"."

#: ../doc/1.7/book/admin/start_stop_instance.rst:70
msgid ""
"Override :ref:`box.cfg{} <box_introspection-box_cfg>` function to pre-process "
"its parameters and ensure that instance paths are pointing to the paths defined "
"in the ``tarantoolctl`` configuration file. For example, if the configuration "
"file specifies that instance work directory must be in ``/var/tarantool``, then "
"the new implementation of ``box.cfg{}`` ensures that :ref:`work_dir <cfg_basic-"
"work_dir>` parameter in ``box.cfg{}`` is set to ``/var/tarantool/"
"<instance_name>``, regardless of what the path is set to in the instance file "
"itself."
msgstr ""
"Переопределяет функцию :ref:`box.cfg{} <box_introspection-box_cfg>`, чтобы "
"предобработать ее параметры и сделать так, чтобы пути к экземплярам указывали на "
"пути, прописанные в конфигурационном файле ``tarantoolctl``. Например, если в "
"конфигурационном файле указано, что рабочей директорией экземпляра является ``/"
"var/tarantool``, то новая реализация ``box.cfg{}`` сделает так, чтобы параметр :"
"ref:`work_dir <cfg_basic-work_dir>` в ``box.cfg{}`` имел значение ``/var/"
"tarantool/<имя_экземпляра>``, независимо от того, какой путь указан в самом "
"файле экземпляра."

#: ../doc/1.7/book/admin/start_stop_instance.rst:79
msgid ""
"Create a so-called \"instance control file\". This is a Unix socket with Lua "
"console attached to it. This file is used later by ``tarantoolctl`` to query the "
"instance state, send commands to the instance and so on."
msgstr ""
"Создает так называемый \"файл для управления экземпляром\". Это Unix-сокет с "
"прикрепленной к нему Lua-консолью. В дальнейшем ``tarantoolctl`` использует этот "
"файл для получения состояния экземпляра, отправки команд и т.д."

#: ../doc/1.7/book/admin/start_stop_instance.rst:83
msgid "Finally, use Lua ``dofile`` command to execute the instance file."
msgstr ""
"Наконец, использует Lua-команду ``dofile`` для выполнения файла экземпляра."

#: ../doc/1.7/book/admin/start_stop_instance.rst:85
msgid ""
"If you start an instance using ``systemd`` tools, like this (the instance name "
"is ``my_app``):"
msgstr ""
"При запуске экземпляра с помощью инструментария ``systemd`` указанным ниже "
"способом (имя экземпляра - ``my_app``):"

#: ../doc/1.7/book/admin/start_stop_instance.rst:88
msgid ""
"$ systemctl start tarantool@my_app\n"
"$ ps axuf|grep exampl[e]\n"
"taranto+  5350  1.3  0.3 1448872 7736 ?        Ssl  20:05   0:28 tarantool "
"my_app.lua <running>"
msgstr ""
"$ systemctl start tarantool@my_app\n"
"$ ps axuf|grep exampl[e]\n"
"taranto+  5350  1.3  0.3 1448872 7736 ?        Ssl  20:05   0:28 tarantool "
"my_app.lua <running>"

#: ../doc/1.7/book/admin/start_stop_instance.rst:94
msgid ""
"... this actually calls ``tarantoolctl`` like in case of ``tarantoolctl start "
"my_app``."
msgstr ""
"...на самом деле вызывается ``tarantoolctl`` - так же, как и в случае "
"``tarantoolctl start my_app``."

#: ../doc/1.7/book/admin/start_stop_instance.rst:97
msgid ""
"To check the instance file for syntax errors prior to starting ``my_app`` "
"instance, say:"
msgstr ""
"Для проверки файла экземпляра на наличие синтаксических ошибок перед запуском "
"экземпляра ``my_app`` используйте команду:"

#: ../doc/1.7/book/admin/start_stop_instance.rst:100
msgid "$ tarantoolctl check my_app"
msgstr "$ tarantoolctl check my_app"

#: ../doc/1.7/book/admin/start_stop_instance.rst:104
msgid "To enable ``my_app`` instance for auto-load during system startup, say:"
msgstr ""
"Для включения автоматической загрузки экземпляра ``my_app`` при запуске всей "
"системы используйте команду:"

#: ../doc/1.7/book/admin/start_stop_instance.rst:106
msgid "$ systemctl enable tarantool@my_app"
msgstr "$ systemctl enable tarantool@my_app"

#: ../doc/1.7/book/admin/start_stop_instance.rst:110
msgid "To stop a running ``my_app`` instance, say:"
msgstr "Для остановки работающего экземпляра ``my_app`` используйте команду:"

#: ../doc/1.7/book/admin/start_stop_instance.rst:112
msgid ""
"$ tarantoolctl stop my_app\n"
"$ # - OR -\n"
"$ systemctl stop tarantool@my_app"
msgstr ""
"$ tarantoolctl stop my_app\n"
"$ # - ИЛИ -\n"
"$ systemctl stop tarantool@my_app"

#: ../doc/1.7/book/admin/start_stop_instance.rst:118
msgid "To restart (i.e. stop and start) a running ``my_app`` instance, say:"
msgstr ""
"Для перезапуска (т.е. остановки и запуска) работающего экземпляра ``my_app`` "
"используйте команду:"

#: ../doc/1.7/book/admin/start_stop_instance.rst:120
msgid ""
"$ tarantoolctl restart my_app\n"
"$ # - OR -\n"
"$ systemctl restart tarantool@my_app"
msgstr ""
"$ tarantoolctl restart my_app\n"
"$ # - ИЛИ -\n"
"$ systemctl restart tarantool@my_app"

#: ../doc/1.7/book/admin/start_stop_instance.rst:130
msgid "Running Tarantool locally"
msgstr "Локальный запуск Tarantool"

#: ../doc/1.7/book/admin/start_stop_instance.rst:132
msgid ""
"Sometimes you may need to run a Tarantool instance locally, e.g. for test "
"purposes. Let's configure a local instance, then start and monitor it with "
"``tarantoolctl``."
msgstr ""
"Иногда бывает необходимо запустить Tarantool локально - например, для "
"тестирования. Давайте настроим локальный экземпляр, запустим его и будем "
"мониторить с помощью ``tarantoolctl``."

#: ../doc/1.7/book/admin/start_stop_instance.rst:136
msgid "First, we create a sandbox directory on the user's path:"
msgstr "Сперва создадим директорию-песочницу по следующему пути:"

#: ../doc/1.7/book/admin/start_stop_instance.rst:138
msgid "$ mkdir ~/tarantool_test"
msgstr "$ mkdir ~/tarantool_test"

#: ../doc/1.7/book/admin/start_stop_instance.rst:142
msgid ""
"... and set default ``tarantoolctl`` configuration in ``$HOME/.config/tarantool/"
"tarantool``. Let the file contents be:"
msgstr ""
"...и поместим конфигурационный файл с параметрами ``tarantoolctl`` по умолчанию "
"в ``$HOME/.config/tarantool/tarantool``. Содержимое файла будет таким:"

#: ../doc/1.7/book/admin/start_stop_instance.rst:145
msgid ""
"default_cfg = {\n"
"    pid_file  = \"/home/user/tarantool_test/my_app.pid\",\n"
"    wal_dir   = \"/home/user/tarantool_test\",\n"
"    snap_dir  = \"/home/user/tarantool_test\",\n"
"    vinyl_dir = \"/home/user/tarantool_test\",\n"
"    log       = \"/home/user/tarantool_test/log\",\n"
"}\n"
"instance_dir = \"/home/user/tarantool_test\""
msgstr ""
"default_cfg = {\n"
"    pid_file  = \"/home/user/tarantool_test/my_app.pid\",\n"
"    wal_dir   = \"/home/user/tarantool_test\",\n"
"    snap_dir  = \"/home/user/tarantool_test\",\n"
"    vinyl_dir = \"/home/user/tarantool_test\",\n"
"    log       = \"/home/user/tarantool_test/log\",\n"
"}\n"
"instance_dir = \"/home/user/tarantool_test\""

#: ../doc/1.7/book/admin/start_stop_instance.rst:158
msgid "Specify a full path to the user's home directory instead of \"~/\"."
msgstr "Указывайте полный путь к домашней директории пользователя вместо \"~/\"."

#: ../doc/1.7/book/admin/start_stop_instance.rst:160
msgid ""
"Omit ``username`` parameter. ``tarantoolctl`` normally doesn't have permissions "
"to switch current user when invoked by a local user. The instance will be "
"running under 'admin'."
msgstr ""
"Опустите параметр ``username``. Обычно, когда запуск производит локальный "
"пользователь, у ``tarantoolctl`` нет разрешения на смену текущего пользователя. "
"Экземпляр будет работать с пользователем 'admin'."

#: ../doc/1.7/book/admin/start_stop_instance.rst:164
msgid ""
"Next, we create the instance file ``~/tarantool_test/my_app.lua``. Let the file "
"contents be:"
msgstr ""
"Далее создадим файл экземпляра ``~/tarantool_test/my_app.lua``. Содержимое файла "
"будет таким:"

#: ../doc/1.7/book/admin/start_stop_instance.rst:167
msgid ""
"box.cfg{listen = 3301}\n"
"box.schema.user.passwd('Gx5!')\n"
"box.schema.user.grant('guest','read,write,execute','universe')\n"
"fiber = require('fiber')\n"
"box.schema.space.create('tester')\n"
"box.space.tester:create_index('primary',{})\n"
"i = 0\n"
"while 0 == 0 do\n"
"    fiber.sleep(5)\n"
"    i = i + 1\n"
"    print('insert ' .. i)\n"
"    box.space.tester:insert{i, 'my_app tuple'}\n"
"end"
msgstr ""
"box.cfg{listen = 3301}\n"
"box.schema.user.passwd('Gx5!')\n"
"box.schema.user.grant('guest','read,write,execute','universe')\n"
"fiber = require('fiber')\n"
"box.schema.space.create('tester')\n"
"box.space.tester:create_index('primary',{})\n"
"i = 0\n"
"while 0 == 0 do\n"
"    fiber.sleep(5)\n"
"    i = i + 1\n"
"    print('insert ' .. i)\n"
"    box.space.tester:insert{i, 'my_app tuple'}\n"
"end"

#: ../doc/1.7/book/admin/start_stop_instance.rst:183
msgid ""
"Let’s verify our instance file by starting it without ``tarantoolctl`` first:"
msgstr "Проверим наш файл экземпляра, сперва запустив его без ``tarantoolctl``:"

#: ../doc/1.7/book/admin/start_stop_instance.rst:185
msgid ""
"$ cd ~/tarantool_test\n"
"$ tarantool my_app.lua\n"
"2017-04-06 10:42:15.762 [54085] main/101/my_app.lua C> version 1.7.3-489-"
"gd86e36d5b\n"
"2017-04-06 10:42:15.763 [54085] main/101/my_app.lua C> log level 5\n"
"2017-04-06 10:42:15.764 [54085] main/101/my_app.lua I> mapping 268435456 bytes "
"for tuple arena...\n"
"2017-04-06 10:42:15.774 [54085] iproto/101/main I> binary: bound to [::]:3301\n"
"2017-04-06 10:42:15.774 [54085] main/101/my_app.lua I> initializing an empty "
"data directory\n"
"2017-04-06 10:42:15.789 [54085] snapshot/101/main I> saving snapshot "
"`./00000000000000000000.snap.inprogress'\n"
"2017-04-06 10:42:15.790 [54085] snapshot/101/main I> done\n"
"2017-04-06 10:42:15.791 [54085] main/101/my_app.lua I> vinyl checkpoint done\n"
"2017-04-06 10:42:15.791 [54085] main/101/my_app.lua I> ready to accept requests\n"
"insert 1\n"
"insert 2\n"
"insert 3\n"
"<...>"
msgstr ""
"$ cd ~/tarantool_test\n"
"$ tarantool my_app.lua\n"
"2017-04-06 10:42:15.762 [54085] main/101/my_app.lua C> version 1.7.3-489-"
"gd86e36d5b\n"
"2017-04-06 10:42:15.763 [54085] main/101/my_app.lua C> log level 5\n"
"2017-04-06 10:42:15.764 [54085] main/101/my_app.lua I> mapping 268435456 bytes "
"for tuple arena...\n"
"2017-04-06 10:42:15.774 [54085] iproto/101/main I> binary: bound to [::]:3301\n"
"2017-04-06 10:42:15.774 [54085] main/101/my_app.lua I> initializing an empty "
"data directory\n"
"2017-04-06 10:42:15.789 [54085] snapshot/101/main I> saving snapshot "
"`./00000000000000000000.snap.inprogress'\n"
"2017-04-06 10:42:15.790 [54085] snapshot/101/main I> done\n"
"2017-04-06 10:42:15.791 [54085] main/101/my_app.lua I> vinyl checkpoint done\n"
"2017-04-06 10:42:15.791 [54085] main/101/my_app.lua I> ready to accept requests\n"
"insert 1\n"
"insert 2\n"
"insert 3\n"
"<...>"

#: ../doc/1.7/book/admin/start_stop_instance.rst:203
msgid "Now we tell ``tarantoolctl`` to start the Tarantool instance:"
msgstr "Запустим экземпляр Tarantool'а с помощью ``tarantoolctl``:"

#: ../doc/1.7/book/admin/start_stop_instance.rst:205
msgid "$ tarantoolctl start my_app"
msgstr "$ tarantoolctl start my_app"

#: ../doc/1.7/book/admin/start_stop_instance.rst:209
msgid "Expect to see messages indicating that the instance has started. Then:"
msgstr ""
"В консоли должны появиться сообщения о том, что экземпляр запущен. Затем "
"выполним следующую команду:"

#: ../doc/1.7/book/admin/start_stop_instance.rst:211
msgid "$ ls -l ~/tarantool_test/my_app"
msgstr "$ ls -l ~/tarantool_test/my_app"

#: ../doc/1.7/book/admin/start_stop_instance.rst:215
msgid "Expect to see the .snap file and the .xlog file. Then:"
msgstr ""
"В консоли должны появиться .snap-файл и .xlog-файл. Затем выполним следующую "
"команду:"

#: ../doc/1.7/book/admin/start_stop_instance.rst:217
msgid "$ less ~/tarantool_test/log/my_app.log"
msgstr "$ less ~/tarantool_test/log/my_app.log"

#: ../doc/1.7/book/admin/start_stop_instance.rst:221
msgid ""
"Expect to see the contents of ``my_app``‘s log, including error messages, if "
"any. Then:"
msgstr ""
"В консоли должно отобразиться содержимое файла журнала для приложения "
"``my_app``, в том числе сообщения об ошибках, если они были. Затем выполним "
"серию команд:"

#: ../doc/1.7/book/admin/start_stop_instance.rst:224
msgid ""
"$ tarantoolctl enter my_app\n"
"tarantool> box.cfg{}\n"
"tarantool> console = require('console')\n"
"tarantool> console.connect('localhost:3301')\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})"
msgstr ""
"$ tarantoolctl enter my_app\n"
"tarantool> box.cfg{}\n"
"tarantool> console = require('console')\n"
"tarantool> console.connect('localhost:3301')\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})"

#: ../doc/1.7/book/admin/start_stop_instance.rst:232
msgid "Expect to see several tuples that ``my_app`` has created."
msgstr ""
"В консоли должны появиться несколько кортежей, которые создало приложение "
"``my_app``."

#: ../doc/1.7/book/admin/start_stop_instance.rst:234
msgid ""
"Stop now. A polite way to stop ``my_app`` is with ``tarantoolctl``, thus we say:"
msgstr ""
"Теперь остановим приложение ``my_app``. Корректный способ остановки - это "
"использовать``tarantoolctl``:"

#: ../doc/1.7/book/admin/start_stop_instance.rst:236
msgid "$ tarantoolctl stop my_app"
msgstr "$ tarantoolctl stop my_app"

#: ../doc/1.7/book/admin/start_stop_instance.rst:240
msgid "Finally, we make a cleanup."
msgstr "Последний шаг - удаление тестовых данных."

#: ../doc/1.7/book/admin/start_stop_instance.rst:242
msgid "$ rm -R tarantool_test"
msgstr "$ rm -R tarantool_test"

#: ../doc/1.7/book/admin/upgrades.rst:39
msgid "Upgrades"
msgstr "Обновление"

#: ../doc/1.7/book/admin/upgrades.rst:45
msgid "Upgrading a Tarantool database"
msgstr "Обновление базы данных Tarantool"

#: ../doc/1.7/book/admin/upgrades.rst:47
msgid ""
"If you created a database with an older Tarantool version and have now installed "
"a newer version, make the request ``box.schema.upgrade()``. This updates "
"Tarantool system spaces to match the currently installed version of Tarantool."
msgstr ""
"Если вы создали базу данных в старой версии Tarantool'а, а потом обновили "
"Tarantool до более свежей версии, вызовите команду ``box.schema.upgrade()``. Она "
"обновляет системные спейсы Tarantool'а так, чтобы они совпадали с текущей "
"установленной версией Tarantool'а."

#: ../doc/1.7/book/admin/upgrades.rst:51
msgid ""
"For example, here is what happens when you run ``box.schema.upgrade()`` with a "
"database created with Tarantool version 1.6.4 to version 1.7.2 (only a small "
"part of the output is shown):"
msgstr ""
"Например, вот что происходит, если выполнить команду ``box.schema.upgrade()`` "
"для базы данных, созданной в Tarantool версии 1.6.4 (показана лишь малая часть "
"выводимых сообщений):"

#: ../doc/1.7/book/admin/upgrades.rst:55
msgid ""
"tarantool> box.schema.upgrade()\n"
"alter index primary on _space set options to {\"unique\":true}, parts to [[0,"
"\"unsigned\"]]\n"
"alter space _schema set options to {}\n"
"create view _vindex...\n"
"grant read access to 'public' role for _vindex view\n"
"set schema version to 1.7.0\n"
"---\n"
"..."
msgstr ""
"tarantool> box.schema.upgrade()\n"
"alter index primary on _space set options to {\"unique\":true}, parts to [[0,"
"\"unsigned\"]]\n"
"alter space _schema set options to {}\n"
"create view _vindex...\n"
"grant read access to 'public' role for _vindex view\n"
"set schema version to 1.7.0\n"
"---\n"
"..."

#: ../doc/1.7/book/admin/upgrades.rst:70
msgid "Upgrading a Tarantool instance"
msgstr "Обновление экземпляра Tarantool'а"

#: ../doc/1.7/book/admin/upgrades.rst:72
msgid ""
"Tarantool is backward compatible between two adjacent versions. For example, you "
"should have no or little trouble when upgrading from Tarantool 1.6 to 1.7, or "
"from Tarantool 1.7 to 1.8. Meanwhile Tarantool 1.8 may have incompatible changes "
"when migrating from Tarantool 1.6. to 1.8 directly."
msgstr ""
"Tarantool поддерживает обратную совместимость между двумя последовательными "
"версиями. Например, обновление Tarantool 1.6 до 1.7 или Tarantool 1.7 до 1.8 не "
"должно вызвать затруднений, тогда как миграции с Tarantool 1.6 прямиком на 1.8 "
"могут препятствовать несовместимые изменения."

#: ../doc/1.7/book/admin/upgrades.rst:79
msgid "How to upgrade from Tarantool 1.6 to 1.7"
msgstr "Как обновить Tarantool 1.6 до 1.7"

#: ../doc/1.7/book/admin/upgrades.rst:81
msgid ""
"This procedure is for upgrading a standalone Tarantool instance in production "
"from 1.6.x to 1.7.x. Notice that this will **always imply a downtime**. To "
"upgrade **without downtime**, you need several Tarantool servers running in a "
"replication cluster (see :ref:`below <admin-upgrades_replication_cluster>`)."
msgstr ""
"Этот процесс предназначен для обновления индивидуальных экземпляров Tarantool'а "
"с 1.6.х до 1.7.х на боевом сервере. Обратите внимание, что это **всегда приводит "
"к некоторому простою**. Для обновления **без простоев** необходимо, чтобы "
"несколько работающих Tarantool-серверов были объединены в репликационный кластер "
"(см. :ref:`ниже <admin-upgrades_replication_cluster>`)."

#: ../doc/1.7/book/admin/upgrades.rst:86
msgid ""
"Tarantool 1.7 has an incompatible :ref:`.snap <internals-snapshot>` and :ref:`."
"xlog <internals-wal>` file format: 1.6 files are supported during upgrade, but "
"you won’t be able to return to 1.6 after running under 1.7 for a while. It also "
"renames a few configuration parameters, but old parameters are supported. The "
"full list of breaking changes is available in `release notes for Tarantool 1.7 "
"<https://github.com/tarantool/tarantool/releases>`_."
msgstr ""
"Tarantool 1.7 работает с несовместимыми форматами файлов - :ref:`.snap "
"<internals-snapshot>` и :ref:`.xlog <internals-wal>`. Файлы Tarantool'а 1.6 "
"поддерживаются при обновлении, но после непродолжительного использования "
"Tarantool'а 1.7 вернуться к 1.6 уже нельзя. В Tarantool'е 1.7 также были "
"переименованы некоторые конфигурационные параметры, но старые имена параметров "
"еще поддерживаются. Список критических изменений доступен в `Release notes для "
"Tarantool'а 1.7 <https://github.com/tarantool/tarantool/releases>`_."

#: ../doc/1.7/book/admin/upgrades.rst:93
msgid ""
"Check with application developers whether application files need to be updated "
"due to incompatible changes (see `1.7 release notes <https://github.com/"
"tarantool/tarantool/releases>`_). If yes, back up the old application files."
msgstr ""
"Уточните у разработчиков, необходимо ли обновлять файлы приложения из-за наличия "
"несовместимых изменений (см. `Release notes для Tarantool'а 1.7 <https://github."
"com/tarantool/tarantool/releases>`_). Если да, то создайте резервные копии "
"старых файлов приложения."

#: ../doc/1.7/book/admin/upgrades.rst:98
msgid "Stop the Tarantool server."
msgstr "Остановите Tarantool-сервер."

#: ../doc/1.7/book/admin/upgrades.rst:100
msgid ""
"Make a copy of all data (see an appropriate hot backup procedure in :ref:"
"`Backups <admin-backups>`) and the package from which the current (old) version "
"was installed (for rollback purposes)."
msgstr ""
"Создайте копию всех данных (см. подразделы про горячее резервное копирование в "
"разделе :ref:`Резервное копирование <admin-backups>`) и пакета, из которого была "
"установлена текущая (старая) версия (на случай отката)."

#: ../doc/1.7/book/admin/upgrades.rst:104
msgid ""
"Update the Tarantool server. See installation instructions at Tarantool "
"`download page <http://tarantool.org/download.html>`_."
msgstr ""
"Обновите Tarantool-сервер. Инструкции по установке доступны на `странице "
"загрузок Tarantool'а <http://tarantool.org/download.html>`_."

#: ../doc/1.7/book/admin/upgrades.rst:107
msgid ""
"Update the Tarantool database. Put the request ``box.schema.upgrade()`` inside "
"a :ref:`box.once() <box-once>` function in your Tarantool :ref:`initialization "
"file <index-init_label>`. On startup, this will create new system spaces, update "
"data type names (e.g. num -> unsigned, str -> string) and options in Tarantool "
"system spaces."
msgstr ""
"Обновите базу данных Tarantool. Выполните команду ``box.schema.upgrade()``, "
"поместив ее внутрь функции :ref:`box.once() <box-once>` в :ref:`файле "
"инициализации <index-init_label>` Tarantool'а. В результате на этапе запуска "
"Tarantool создаст новые системные спейсы, обновит названия типов данных "
"(например, num -> unsigned, str -> string) и список доступных типов данных в "
"системных спейсах."

#: ../doc/1.7/book/admin/upgrades.rst:113
msgid "Update application files, if needed."
msgstr "При необходимости обновите файлы приложения."

#: ../doc/1.7/book/admin/upgrades.rst:115
msgid ""
"Launch the updated Tarantool server using ``tarantoolctl`` or ``systemctl``."
msgstr ""
"Запустите обновленный Tarantool-сервер с помощью ``tarantoolctl`` или "
"``systemctl``."

#: ../doc/1.7/book/admin/upgrades.rst:121
msgid "Upgrading Tarantool in a replication cluster"
msgstr "Обновление Tarantool'а в репликационном кластере"

#: ../doc/1.7/book/admin/upgrades.rst:123
msgid ""
"Tarantool 1.7 can work as a :ref:`replica <replication-architecture>` for "
"Tarantool 1.6 and vice versa. Replicas perform capability negotiation on "
"handshake, and new 1.7 replication features are not used with 1.6 replicas. This "
"allows upgrading clustered configurations."
msgstr ""
"Tarantool 1.7 может служить :ref:`репликой <replication-architecture>` для "
"Tarantool'а 1.6 - и наоборот. При установке соединения происходит обсуждение "
"возможностей, и новый для 1.7 репликационный функционал не используется при "
"работе с репликами версии 1.6. Такой подход позволяет обновлять кластерные "
"конфигурации."

#: ../doc/1.7/book/admin/upgrades.rst:127
msgid ""
"This procedure allows for a rolling upgrade **without downtime** and works for "
"any cluster configuration: master-master or master-replica."
msgstr ""
"Этот процесс позволяет осуществить последовательное обновление **без простоев** "
"и подходит для любой конфигурации кластера: master-master или master-replica."

#: ../doc/1.7/book/admin/upgrades.rst:130
msgid ""
"Upgrade Tarantool at all replicas (or at any master in a master-master cluster). "
"See details in :ref:`Upgrading a Tarantool instance <admin-upgrades_instance>`."
msgstr ""
"Обновите Tarantool на всех репликах (или на любом мастере в кластере master-"
"master). Подробные инструкции доступны в подразделе :ref:`Обновление экземпляра "
"Tarantool'а <admin-upgrades_instance>`."

#: ../doc/1.7/book/admin/upgrades.rst:134
msgid "Verify installation on the replicas:"
msgstr "Проверьте работу реплик:"

#: ../doc/1.7/book/admin/upgrades.rst:136
msgid "Start Tarantool."
msgstr "Запустите Tarantool."

#: ../doc/1.7/book/admin/upgrades.rst:138
msgid "Attach to the master and start working as before."
msgstr "Присоединитесь к мастеру и начните работать, как раньше."

#: ../doc/1.7/book/admin/upgrades.rst:140
msgid ""
"The master runs the old Tarantool version, which is always compatible with the "
"next major version."
msgstr ""
"На мастере установлена старая версия Tarantool'а, которая всегда совместима со "
"следующей мажорной версией."

#: ../doc/1.7/book/admin/upgrades.rst:143
msgid "Upgrade the master. The procedure is similar to upgrading a replica."
msgstr "Обновите мастер. Процесс такой же, как и при обновлении реплики."

#: ../doc/1.7/book/admin/upgrades.rst:145
msgid "Verify master installation:"
msgstr "Проверьте работу мастера:"

#: ../doc/1.7/book/admin/upgrades.rst:147
msgid "Start Tarantool with replica configuration to catch up."
msgstr ""
"Запустите Tarantool в режиме реплики для получения последней версии данных."

#: ../doc/1.7/book/admin/upgrades.rst:149
msgid "Switch to master mode."
msgstr "Переключитесь в режим мастера."

#: ../doc/1.7/book/admin/upgrades.rst:151
msgid ""
"Upgrade the database on any master node in the cluster. Make the request ``box."
"schema.upgrade()``. This updates Tarantool system spaces to match the currently "
"installed version of Tarantool. Changes are propagated to other nodes via the "
"regular replication mechanism."
msgstr ""
"Обновите базу данных на любом мастере в кластере. Выполните команду ``box.schema."
"upgrade()``. Это обновит системные спейсы Tarantool'а так, чтобы они совпадали с "
"текущей установленной версией Tarantool'а. Изменения распространятся на другие "
"узлы кластера через обычный механизм репликации."

#: ../doc/1.7/book/app_server/contributing_module.rst:39
msgid "Contributing a module"
msgstr ""

#: ../doc/1.7/book/app_server/contributing_module.rst:41
msgid ""
"We have already discussed :ref:`how to create a simple module in Lua for local "
"usage <app_server-modules>`. Now let's discuss how to create a more advanced "
"Tarantool module and then get it published on `Tarantool rocks page <http://"
"tarantool.org/rocks.html>`_ and included in `official Tarantool images <http://"
"github.com/tarantool/docker>`_ for Docker."
msgstr ""

#: ../doc/1.7/book/app_server/contributing_module.rst:48
msgid ""
"To help our contributors, we have created `modulekit <http://github.com/"
"tarantool/modulekit>`_, a set of templates for creating Tarantool modules in Lua "
"and C."
msgstr ""

#: ../doc/1.7/book/app_server/contributing_module.rst:54
msgid ""
"As a prerequisite for using ``modulekit``, install ``tarantool-dev`` package "
"first. For example, in Ubuntu say:"
msgstr ""

#: ../doc/1.7/book/app_server/contributing_module.rst:57
#, fuzzy
msgid "$ sudo apt-get install tarantool-dev"
msgstr "$ sudo apt-get install luarocks"

#: ../doc/1.7/book/app_server/contributing_module.rst:65
msgid "Contributing a module in Lua"
msgstr ""

#: ../doc/1.7/book/app_server/contributing_module.rst:67
msgid ""
"See `README in \"luakit\" branch of tarantool/modulekit repository <http://"
"github.com/tarantool/modulekit/blob/luakit/README.md>`_ for detailed "
"instructions and examples."
msgstr ""

#: ../doc/1.7/book/app_server/contributing_module.rst:75
msgid "Contributing a module in C"
msgstr ""

#: ../doc/1.7/book/app_server/contributing_module.rst:77
msgid ""
"In some cases, you may want to create a Tarantool module in C rather than in "
"Lua. For example, to work with specific hardware or low-level system interfaces."
msgstr ""

#: ../doc/1.7/book/app_server/contributing_module.rst:80
msgid ""
"See `README in \"ckit\" branch of tarantool/modulekit repository <http://github."
"com/tarantool/modulekit/blob/ckit/README.md>`_ for detailed instructions and "
"examples."
msgstr ""

#: ../doc/1.7/book/app_server/contributing_module.rst:86
msgid ""
"You can also create modules with C++, provided that the code does not throw "
"exceptions."
msgstr ""
"Вы можете аналогичным образом создавать модули на C++ при условии, что в их коде "
"не будут выбрасываться исключения."

#: ../doc/1.7/book/app_server/cookbook.rst:39
msgid "Cookbook recipes"
msgstr "Книга рецептов"

#: ../doc/1.7/book/app_server/cookbook.rst:41
msgid ""
"Here are contributions of Lua programs for some frequent or tricky situations."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:43
msgid ""
"You can execute any of these programs by copying the code into a ``.lua`` file, "
"and then entering :samp:`chmod +x ./{program-name}.lua` and :samp:`./{program-"
"name}.lua` on the terminal."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:47
msgid "The first line is a \"hashbang\":"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:49
msgid "#!/usr/bin/env tarantool"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:53
msgid ""
"This runs  Tarantool Lua application server, which should be on the execution "
"path."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:56
msgid "Use freely."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:62
msgid "hello_world.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:64
msgid "The standard example of a simple program."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:66
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"print('Hello, World!')"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:76
msgid "console_start.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:78
msgid ""
"Use :ref:`box.once() <box-once>` to initialize a database (creating spaces) if "
"this is the first time the server has been run. Then use :ref:`console.start() "
"<console-start>` to start interactive mode."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:82
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"-- Configure database\n"
"box.cfg {\n"
"    listen = 3313\n"
"}\n"
"\n"
"box.once(\"bootstrap\", function()\n"
"    box.schema.space.create('tweedledum')\n"
"    box.space.tweedledum:create_index('primary',\n"
"        { type = 'TREE', parts = {1, 'unsigned'}})\n"
"end)\n"
"\n"
"require('console').start()"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:103
msgid "fio_read.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:105
msgid "Use the :ref:`fio module <fio-module>` to open, read, and close a file."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:107
#: ../doc/1.7/reference/reference_lua/errcodes.rst:143
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local fio = require('fio')\n"
"local errno = require('errno')\n"
"local f = fio.open('/tmp/xxxx.txt', {'O_RDONLY' })\n"
"if not f then\n"
"    error(\"Failed to open file: \"..errno.strerror())\n"
"end\n"
"local data = f:read(4096)\n"
"f:close()\n"
"print(data)"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:125
msgid "fio_write.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:127
msgid "Use the :ref:`fio module <fio-module>` to open, write, and close a file."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:129
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local fio = require('fio')\n"
"local errno = require('errno')\n"
"local f = fio.open('/tmp/xxxx.txt', {'O_CREAT', 'O_WRONLY', 'O_APPEND'},\n"
"    tonumber('0666', 8))\n"
"if not f then\n"
"    error(\"Failed to open file: \"..errno.strerror())\n"
"end\n"
"f:write(\"Hello\\n\");\n"
"f:close()"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:147
msgid "ffi_printf.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:149
msgid ""
"Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to call a C built-"
"in function: printf(). (For help understanding ffi, see the `FFI tutorial "
"<http://luajit.org/ext_ffi_tutorial.html>`_.)"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:152
#, python-format
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require('ffi')\n"
"ffi.cdef[[\n"
"    int printf(const char *format, ...);\n"
"]]\n"
"\n"
"ffi.C.printf(\"Hello, %s\\n\", os.getenv(\"USER\"));"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:167
msgid "ffi_gettimeofday.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:169
msgid ""
"Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to call a C "
"function: gettimeofday(). This delivers time with millisecond precision, unlike "
"the time function in Tarantool's :ref:`clock module <clock-module>`."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:173
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require('ffi')\n"
"ffi.cdef[[\n"
"    typedef long time_t;\n"
"    typedef struct timeval {\n"
"    time_t tv_sec;\n"
"    time_t tv_usec;\n"
"} timeval;\n"
"    int gettimeofday(struct timeval *t, void *tzp);\n"
"]]\n"
"\n"
"local timeval_buf = ffi.new(\"timeval\")\n"
"local now = function()\n"
"    ffi.C.gettimeofday(timeval_buf, nil)\n"
"    return tonumber(timeval_buf.tv_sec * 1000 + (timeval_buf.tv_usec / 1000))\n"
"end"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:197
msgid "ffi_zlib.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:199
msgid ""
"Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to call a C "
"library function. (For help understanding ffi, see the `FFI tutorial <http://"
"luajit.org/ext_ffi_tutorial.html>`_.)"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:202
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require(\"ffi\")\n"
"ffi.cdef[[\n"
"    unsigned long compressBound(unsigned long sourceLen);\n"
"    int compress2(uint8_t *dest, unsigned long *destLen,\n"
"    const uint8_t *source, unsigned long sourceLen, int level);\n"
"    int uncompress(uint8_t *dest, unsigned long *destLen,\n"
"    const uint8_t *source, unsigned long sourceLen);\n"
"]]\n"
"local zlib = ffi.load(ffi.os == \"Windows\" and \"zlib1\" or \"z\")\n"
"\n"
"-- Lua wrapper for compress2()\n"
"local function compress(txt)\n"
"    local n = zlib.compressBound(#txt)\n"
"    local buf = ffi.new(\"uint8_t[?]\", n)\n"
"    local buflen = ffi.new(\"unsigned long[1]\", n)\n"
"    local res = zlib.compress2(buf, buflen, txt, #txt, 9)\n"
"    assert(res == 0)\n"
"    return ffi.string(buf, buflen[0])\n"
"end\n"
"\n"
"-- Lua wrapper for uncompress\n"
"local function uncompress(comp, n)\n"
"    local buf = ffi.new(\"uint8_t[?]\", n)\n"
"    local buflen = ffi.new(\"unsigned long[1]\", n)\n"
"    local res = zlib.uncompress(buf, buflen, comp, #comp)\n"
"    assert(res == 0)\n"
"    return ffi.string(buf, buflen[0])\n"
"end\n"
"\n"
"-- Simple test code.\n"
"local txt = string.rep(\"abcd\", 1000)\n"
"print(\"Uncompressed size: \", #txt)\n"
"local c = compress(txt)\n"
"print(\"Compressed size: \", #c)\n"
"local txt2 = uncompress(c, #txt)\n"
"assert(txt2 == txt)"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:247
msgid "ffi_meta.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:249
msgid ""
"Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to access a C "
"object via a metamethod (a method which is defined with a metatable)."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:253
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require(\"ffi\")\n"
"ffi.cdef[[\n"
"typedef struct { double x, y; } point_t;\n"
"]]\n"
"\n"
"local point\n"
"local mt = {\n"
"  __add = function(a, b) return point(a.x+b.x, a.y+b.y) end,\n"
"  __len = function(a) return math.sqrt(a.x*a.x + a.y*a.y) end,\n"
"  __index = {\n"
"    area = function(a) return a.x*a.x + a.y*a.y end,\n"
"  },\n"
"}\n"
"point = ffi.metatype(\"point_t\", mt)\n"
"\n"
"local a = point(3, 4)\n"
"print(a.x, a.y)  --> 3  4\n"
"print(#a)        --> 5\n"
"print(a:area())  --> 25\n"
"local b = a + point(0.5, 8)\n"
"print(#b)        --> 12.5"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:283
msgid "print_arrays.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:285
msgid ""
"Create Lua tables, and print them. Notice that for the 'array' table the "
"iterator function is ipairs(), while for the 'map' table the iterator function "
"is pairs(). (`ipairs()` is faster than `pairs()`, but pairs() is recommended for "
"map-like tables or mixed tables.) The display will look like: \"1 Apple | 2 "
"Orange | 3 Grapefruit | 4 Banana | k3 v3 | k1 v1 | k2 v2\"."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:293
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"array = { 'Apple', 'Orange', 'Grapefruit', 'Banana'}\n"
"for k, v in ipairs(array) do print(k, v) end\n"
"\n"
"map = { k1 = 'v1', k2 = 'v2', k3 = 'v3' }\n"
"for k, v in pairs(map) do print(k, v) end"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:307
msgid "count_array.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:309
msgid ""
"Use the '#' operator to get the number of items in an array-like Lua table. This "
"operation has O(log(N)) complexity."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:312
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"array = { 1, 2, 3}\n"
"print(#array)"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:323
msgid "count_array_with_nils.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:325
msgid ""
"Missing elements in arrays, which Lua treats as \"nil\"s, cause the simple \"#\" "
"operator to deliver improper results. The \"print(#t)\" instruction will print "
"\"4\"; the \"print(counter)\" instruction will print \"3\"; the \"print(max)\" "
"instruction will print \"10\". Other table functions, such as table.sort(), will "
"also misbehave when \"nils\" are present."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:333
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local t = {}\n"
"t[1] = 1\n"
"t[4] = 4\n"
"t[10] = 10\n"
"print(#t)\n"
"local counter = 0\n"
"for k,v in pairs(t) do counter = counter + 1 end\n"
"print(counter)\n"
"local max = 0\n"
"for k,v in pairs(t) do if k > max then max = k end end\n"
"print(max)"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:353
msgid "count_array_with_nulls.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:355
msgid ""
"Use explicit ``NULL`` values to avoid the problems caused by Lua's nil == "
"missing value behavior. Although :code:`json.NULL == nil` is :code:`true`, all "
"the print instructions in this program will print the correct value: 10."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:360
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local json = require('json')\n"
"local t = {}\n"
"t[1] = 1; t[2] = json.NULL; t[3]= json.NULL;\n"
"t[4] = 4; t[5] = json.NULL; t[6]= json.NULL;\n"
"t[6] = 4; t[7] = json.NULL; t[8]= json.NULL;\n"
"t[9] = json.NULL\n"
"t[10] = 10\n"
"print(#t)\n"
"local counter = 0\n"
"for k,v in pairs(t) do counter = counter + 1 end\n"
"print(counter)\n"
"local max = 0\n"
"for k,v in pairs(t) do if k > max then max = k end end\n"
"print(max)"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:383
msgid "count_map.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:385
msgid "Get the number of elements in a map-like table."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:387
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local map = { a = 10, b = 15, c = 20 }\n"
"local size = 0\n"
"for _ in pairs(map) do size = size + 1; end\n"
"print(size)"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:400
msgid "swap.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:402
msgid ""
"Use a Lua peculiarity to swap two variables without needing a third variable."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:404
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local x = 1\n"
"local y = 2\n"
"x, y = y, x\n"
"print(x, y)"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:417
msgid "class.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:419
msgid ""
"Create a class, create a metatable for the class, create an instance of the "
"class. Another illustration is at `http://lua-users.org/wiki/"
"LuaClassesWithMetatable <http://lua-users.org/wiki/LuaClassesWithMetatable>`_."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:423
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"-- define class objects\n"
"local myclass_somemethod = function(self)\n"
"    print('test 1', self.data)\n"
"end\n"
"\n"
"local myclass_someothermethod = function(self)\n"
"    print('test 2', self.data)\n"
"end\n"
"\n"
"local myclass_tostring = function(self)\n"
"    return 'MyClass <'..self.data..'>'\n"
"end\n"
"\n"
"local myclass_mt = {\n"
"    __tostring = myclass_tostring;\n"
"    __index = {\n"
"        somemethod = myclass_somemethod;\n"
"        someothermethod = myclass_someothermethod;\n"
"    }\n"
"}\n"
"\n"
"-- create a new object of myclass\n"
"local object = setmetatable({ data = 'data'}, myclass_mt)\n"
"print(object:somemethod())\n"
"print(object.data)"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:457
msgid "garbage.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:459
msgid ""
"Force Lua `garbage collection <https://www.lua.org/manual/5.1/manual."
"html#2.10>`_ with the `collectgarbage function <https://www.lua.org/manual/5.1/"
"manual.html#pdf-collectgarbage>`_."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:462
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"collectgarbage('collect')"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:472
msgid "fiber_producer_and_consumer.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:474
msgid ""
"Start one fiber for producer and one fiber for consumer. Use :ref:`fiber."
"channel() <fiber_ipc-channel>` to exchange data and synchronize. One can tweak "
"the channel size (:code:`ch_size` in the program code) to control the number of "
"simultaneous tasks waiting for processing."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:479
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local fiber = require('fiber')\n"
"local function consumer_loop(ch, i)\n"
"    -- initialize consumer synchronously or raise an error()\n"
"    fiber.sleep(0) -- allow fiber.create() to continue\n"
"    while true do\n"
"        local data = ch:get()\n"
"        if data == nil then\n"
"            break\n"
"        end\n"
"        print('consumed', i, data)\n"
"        fiber.sleep(math.random()) -- simulate some work\n"
"    end\n"
"end\n"
"\n"
"local function producer_loop(ch, i)\n"
"    -- initialize consumer synchronously or raise an error()\n"
"    fiber.sleep(0) -- allow fiber.create() to continue\n"
"    while true do\n"
"        local data = math.random()\n"
"        ch:put(data)\n"
"        print('produced', i, data)\n"
"    end\n"
"end\n"
"\n"
"local function start()\n"
"    local consumer_n = 5\n"
"    local producer_n = 3\n"
"\n"
"    -- Create a channel\n"
"    local ch_size = math.max(consumer_n, producer_n)\n"
"    local ch = fiber.channel(ch_size)\n"
"\n"
"    -- Start consumers\n"
"    for i=1, consumer_n,1 do\n"
"        fiber.create(consumer_loop, ch, i)\n"
"    end\n"
"\n"
"    -- Start producers\n"
"    for i=1, producer_n,1 do\n"
"        fiber.create(producer_loop, ch, i)\n"
"    end\n"
"end\n"
"\n"
"start()\n"
"print('started')"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:533
msgid "socket_tcpconnect.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:535
msgid ""
"Use :ref:`socket.tcp_connect() <socket-tcp_connect>` to connect to a remote host "
"via TCP. Display the connection details and the result of a GET request."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:539
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local s = require('socket').tcp_connect('google.com', 80)\n"
"print(s:peer().host)\n"
"print(s:peer().family)\n"
"print(s:peer().type)\n"
"print(s:peer().protocol)\n"
"print(s:peer().port)\n"
"print(s:write(\"GET / HTTP/1.0\\r\\n\\r\\n\"))\n"
"print(s:read('\\r\\n'))\n"
"print(s:read('\\r\\n'))"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:557
msgid "socket_tcp_echo.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:559
msgid ""
"Use :ref:`socket.tcp_connect() <socket-tcp_connect>` to set up a simple TCP "
"server, by creating a function that handles requests and echos them, and passing "
"the function to :ref:`socket.tcp_server() <socket-tcp_server>`. This program has "
"been used to test with 100,000 clients, with each client getting a separate "
"fiber."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:567
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local function handler(s, peer)\n"
"    s:write(\"Welcome to test server, \" .. peer.host ..\"\\n\")\n"
"    while true do\n"
"        local line = s:read('\\n')\n"
"        if line == nil then\n"
"            break -- error or eof\n"
"        end\n"
"        if not s:write(\"pong: \"..line) then\n"
"            break -- error or eof\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"local server, addr = require('socket').tcp_server('localhost', 3311, handler)"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:590
msgid "getaddrinfo.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:592
msgid ""
"Use :ref:`socket.getaddrinfo() <socket-getaddrinfo>` to perform non-blocking DNS "
"resolution, getting both the AF_INET6 and AF_INET information for 'google.com'. "
"This technique is not always necessary for tcp connections because :ref:`socket."
"tcp_connect() <socket-tcp_connect>` performs `socket.getaddrinfo` under the "
"hood, before trying to connect to the first available address."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:600
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local s = require('socket').getaddrinfo('google.com', 'http', { type = "
"'SOCK_STREAM' })\n"
"print('host=',s[1].host)\n"
"print('family=',s[1].family)\n"
"print('type=',s[1].type)\n"
"print('protocol=',s[1].protocol)\n"
"print('port=',s[1].port)\n"
"print('host=',s[2].host)\n"
"print('family=',s[2].family)\n"
"print('type=',s[2].type)\n"
"print('protocol=',s[2].protocol)\n"
"print('port=',s[2].port)"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:620
msgid "socket_udp_echo.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:622
msgid ""
"Tarantool does not currently have a `udp_server` function, therefore "
"socket_udp_echo.lua is more complicated than socket_tcp_echo.lua. It can be "
"implemented with sockets and fibers."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:627
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local socket = require('socket')\n"
"local errno = require('errno')\n"
"local fiber = require('fiber')\n"
"\n"
"local function udp_server_loop(s, handler)\n"
"    fiber.name(\"udp_server\")\n"
"    while true do\n"
"        -- try to read a datagram first\n"
"        local msg, peer = s:recvfrom()\n"
"        if msg == \"\" then\n"
"            -- socket was closed via s:close()\n"
"            break\n"
"        elseif msg ~= nil then\n"
"            -- got a new datagram\n"
"            handler(s, peer, msg)\n"
"        else\n"
"            if s:errno() == errno.EAGAIN or s:errno() == errno.EINTR then\n"
"                -- socket is not ready\n"
"                s:readable() -- yield, epoll will wake us when new data arrives\n"
"            else\n"
"                -- socket error\n"
"                local msg = s:error()\n"
"                s:close() -- save resources and don't wait GC\n"
"                error(\"Socket error: \" .. msg)\n"
"            end\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"local function udp_server(host, port, handler)\n"
"    local s = socket('AF_INET', 'SOCK_DGRAM', 0)\n"
"    if not s then\n"
"        return nil -- check errno:strerror()\n"
"    end\n"
"    if not s:bind(host, port) then\n"
"        local e = s:errno() -- save errno\n"
"        s:close()\n"
"        errno(e) -- restore errno\n"
"        return nil -- check errno:strerror()\n"
"    end\n"
"\n"
"    fiber.create(udp_server_loop, s, handler) -- start a new background fiber\n"
"    return s\n"
"end"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:676
msgid ""
"A function for a client that connects to this server could look something like "
"this ..."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:679
msgid ""
"local function handler(s, peer, msg)\n"
"    -- You don't have to wait until socket is ready to send UDP\n"
"    -- s:writable()\n"
"    s:sendto(peer.host, peer.port, \"Pong: \" .. msg)\n"
"end\n"
"\n"
"local server = udp_server('127.0.0.1', 3548, handler)\n"
"if not server then\n"
"    error('Failed to bind: ' .. errno.strerror())\n"
"end\n"
"\n"
"print('Started')\n"
"\n"
"require('console').start()"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:700
msgid "http_get.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:702
msgid "Use the :ref:`http module <http-module>` to get data via HTTP."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:705
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local http_client = require('http.client')\n"
"local json = require('json')\n"
"local r = http_client.get('http://api.openweathermap.org/data/2.5/weather?"
"q=Oakland,us')\n"
"if r.status ~= 200 then\n"
"    print('Failed to get weather forecast ', r.reason)\n"
"    return\n"
"end\n"
"local data = json.decode(r.body)\n"
"print('Oakland wind speed: ', data.wind.speed)"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:723
msgid "http_send.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:725
msgid "Use the :ref:`http module <http-module>` to send data via HTTP."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:728
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local http_client = require('http.client')\n"
"local json = require('json')\n"
"local data = json.encode({ Key = 'Value'})\n"
"local headers = { Token = 'xxxx', ['X-Secret-Value'] = 42 }\n"
"local r = http_client.post('http://localhost:8081', data, { headers = headers})\n"
"if r.status == 200 then\n"
"    print 'Success'\n"
"end"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:745
msgid "http_server.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:747
msgid ""
"Use the `http`_ `rock`_ (which must first be installed) to turn Tarantool into a "
"web server."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:750
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local function handler(self)\n"
"    return self:render{ json = { ['Your-IP-Is'] = self.peer.host } }\n"
"end\n"
"\n"
"local server = require('http.server').new(nil, 8080) -- listen *:8080\n"
"server:route({ path = '/' }, handler)\n"
"server:start()\n"
"-- connect to localhost:8080 and see json"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:767
msgid "http_generate_html.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:769
msgid ""
"Use the `http`_ `rock` (which must first be installed) to generate HTML pages "
"from templates. The `http`_ `rock`_ has a fairly simple template engine which "
"allows execution of regular Lua code inside text blocks (like PHP). Therefore "
"there is no need to learn new languages in order to write templates."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:775
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local function handler(self)\n"
"local fruits = { 'Apple', 'Orange', 'Grapefruit', 'Banana'}\n"
"    return self:render{ fruits = fruits }\n"
"end\n"
"\n"
"local server = require('http.server').new(nil, 8080) -- nil means '*'\n"
"server:route({ path = '/', file = 'index.html.lua' }, handler)\n"
"server:start()"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:788
msgid ""
"An \"HTML\" file for this server, including Lua, could look like this (it would "
"produce \"1 Apple | 2 Orange | 3 Grapefruit | 4 Banana\")."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:791
#, python-format
msgid ""
"<html>\n"
"<body>\n"
"    <table border=\"1\">\n"
"        % for i,v in pairs(fruits) do\n"
"        <tr>\n"
"            <td><%= i %></td>\n"
"            <td><%= v %></td>\n"
"        </tr>\n"
"        % end\n"
"    </table>\n"
"</body>\n"
"</html>"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:39
#, fuzzy
msgid "Creating an application"
msgstr "Остановить приложение"

#: ../doc/1.7/book/app_server/creating_app.rst:41
msgid ""
"Further we walk you through key programming practices that will give you a good "
"start in writing Lua applications for Tarantool. For an adventure, this is a "
"story of implementing... a real microservice based on Tarantool! We implement a "
"backend for a simplified version of `Pokémon Go <https://en.wikipedia.org/wiki/"
"Pokémon_Go>`_, a location-based augmented reality game released in mid-2016. In "
"this game, players use a mobile device's GPS capability to locate, capture, "
"battle and train virtual monsters called \"pokémon\", who appear on the screen "
"as if they were in the same real-world location as the player."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:51
msgid ""
"To stay within the walk-through format, let's narrow the original gameplay as "
"follows. We have a map with pokémon spawn locations. Next, we have multiple "
"players who can send catch-a-pokémon requests to the server (which runs our "
"Tarantool microservice). The server replies whether the pokémon is caught or "
"not, increases the player's pokémon counter if yes, and triggers the respawn-a-"
"pokémon method that spawns a new pokémon at the same location in a while."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:59
msgid ""
"We leave client-side applications outside the scope of this story. Yet we "
"promise a mini-demo in the end to simulate real users and give us some fun. :-)"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:65
msgid "First, what would be the best way to deliver our microservice?"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:71
msgid "Modules, rocks and applications"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:73
msgid ""
"To make our game logic available to other developers and Lua applications, let's "
"put it into a Lua module."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:76
msgid ""
"A **module** (called \"rock\" in Lua) is an optional library which enhances "
"Tarantool functionality. So, we can install our logic as a module in Tarantool "
"and use it from any Tarantool application or module. Like applications, modules "
"in Tarantool can be written in Lua (rocks), C or C++."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:81
msgid "Modules are good for two things:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:83
msgid "easier **code management** (reuse, packaging, versioning), and"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:84
msgid "hot **code reload** without restarting the Tarantool instance."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:86
msgid ""
"Technically, a module is a file with source code that exports its functions in "
"an API. For example, here is a Lua module named ``mymodule.lua`` that exports "
"one function named ``myfun``:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:90
#, fuzzy
msgid ""
"local exports = {}\n"
"exports.myfun = function(input_string)\n"
"   print('Hello', input_string)\n"
"end\n"
"return exports"
msgstr ""
"-- mymodule - простейший Lua-модуль для Tarantool'а\n"
"local exports = {}\n"
"exports.myfun = function(input_string)\n"
"    print('Hello', input_string)\n"
"end\n"
"return exports"

#: ../doc/1.7/book/app_server/creating_app.rst:98
msgid ""
"To launch the function ``myfun()`` -- from another module, from a Lua "
"application, or from Tarantool itself, -- we need to save this module as a file, "
"then load this module with the ``require()`` directive and call the exported "
"function."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:102
msgid ""
"For example, here's a Lua application that uses ``myfun()`` function from "
"``mymodule.lua`` module:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:105
msgid ""
"-- loading the module\n"
"local mymodule = require('mymodule')\n"
"\n"
"-- calling myfun() from within test() function\n"
"local test = function()\n"
"  mymodule.myfun()\n"
"end"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:115
msgid ""
"A thing to remember here is that the ``require()`` directive takes load paths to "
"Lua modules from the ``package.path`` variable. This is a semicolon-separated "
"string, where a question mark is used to interpolate the module name. By "
"default, this variable contains system-wide Lua paths and the working directory. "
"But if we put our modules inside a specific folder (e.g. ``scripts/``), we need "
"to add this folder to ``package.path`` before any calls to ``require()``:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:122
msgid "package.path = 'scripts/?.lua;' .. package.path"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:126
msgid ""
"For our microservice, a simple and convenient solution would be to put all "
"methods in a Lua module (say ``pokemon.lua``) and to write a Lua application "
"(say ``game.lua``) that initializes the gaming environment and starts the game "
"loop."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:134
msgid ""
"Now let's get down to implementation details. In our game, we need three "
"entities:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:136
msgid ""
"**map**, which is an array of pokémons with coordinates of respawn locations; in "
"this version of the game, let a location be a rectangle identified with two "
"points, upper-left and lower-right;"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:139
msgid ""
"**player**, which has an ID, a name, and coordinates of the player's location "
"point;"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:141
msgid ""
"**pokémon**, which has the same fields as the player, plus a status (active/"
"inactive, that is present on the map or not) and a catch probability (well, "
"let's give our pokémons a chance to escape :-) )"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:145
msgid ""
"We'll store these entities as tuples in Tarantool spaces. But to deliver our "
"backend application as a microservice, the good practice would be to send/"
"receive our data in the universal JSON format, thus using Tarantool as a "
"document storage."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:153
msgid "Avro schemas"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:155
msgid ""
"To store JSON data as tuples, we will apply a savvy practice which reduces data "
"footprint and ensures all stored documents are valid. We will use Tarantool "
"module `avro-schema <https://github.com/tarantool/avro-schema>`_ which checks "
"the schema of a JSON document and converts it to a Tarantool tuple. The tuple "
"will contain only field values, and thus take a lot less space than the original "
"document. In avro-schema terms, converting JSON documents to tuples is "
"\"flattening\", and restoring the original documents is \"unflattening\". The "
"usage is quite straightforward:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:164
msgid ""
"For each entity, we need to define a schema in `Apache Avro schema <https://en."
"wikipedia.org/wiki/Apache_Avro>`_ syntax, where we list the entity's fields with "
"their names and `Avro data types <http://avro.apache.org/docs/current/spec."
"html#schema_primitive>`_."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:168
msgid ""
"At initialization, we call ``avro-schema.create()`` that creates objects in "
"memory for all schema entities, and ``compile()`` that generates flatten/"
"unflatten methods for each entity."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:171
msgid ""
"Further on, we just call flatten/unflatten methods for a respective entity on "
"receiving/sending the entity's data."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:174
msgid ""
"Here's what our schema definitions for the player and pokémon entities look like:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:176
msgid ""
"local schema = {\n"
"    player = {\n"
"        type=\"record\",\n"
"        name=\"player_schema\",\n"
"        fields={\n"
"            {name=\"id\", type=\"long\"},\n"
"            {name=\"name\", type=\"string\"},\n"
"            {\n"
"                name=\"location\",\n"
"                type= {\n"
"                    type=\"record\",\n"
"                    name=\"player_location\",\n"
"                    fields={\n"
"                        {name=\"x\", type=\"double\"},\n"
"                        {name=\"y\", type=\"double\"}\n"
"                    }\n"
"                }\n"
"            }\n"
"        }\n"
"    },\n"
"    pokemon = {\n"
"        type=\"record\",\n"
"        name=\"pokemon_schema\",\n"
"        fields={\n"
"            {name=\"id\", type=\"long\"},\n"
"            {name=\"status\", type=\"string\"},\n"
"            {name=\"name\", type=\"string\"},\n"
"            {name=\"chance\", type=\"double\"},\n"
"            {\n"
"                name=\"location\",\n"
"                type= {\n"
"                    type=\"record\",\n"
"                    name=\"pokemon_location\",\n"
"                    fields={\n"
"                        {name=\"x\", type=\"double\"},\n"
"                        {name=\"y\", type=\"double\"}\n"
"                    }\n"
"                }\n"
"            }\n"
"        }\n"
"    }\n"
"}"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:221
msgid "And here's how we create and compile our entities at initialization:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:223
msgid ""
"-- load avro-schema module with require()\n"
"local avro = require('avro_schema')\n"
"\n"
"-- create models\n"
"local ok_m, pokemon = avro.create(schema.pokemon)\n"
"local ok_p, player = avro.create(schema.player)\n"
"if ok_m and ok_p then\n"
"    -- compile models\n"
"    local ok_cm, compiled_pokemon = avro.compile(pokemon)\n"
"    local ok_cp, compiled_player = avro.compile(player)\n"
"    if ok_cm and ok_cp then\n"
"        -- start the game\n"
"        <...>\n"
"    else\n"
"        log.error('Schema compilation failed')\n"
"    end\n"
"else\n"
"    log.info('Schema creation failed')\n"
"end\n"
"return false"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:246
msgid ""
"As for the map entity, it would be an overkill to introduce a schema for it, "
"because we have only one map in the game, it has very few fields, and -- which "
"is most important -- we use the map only inside our logic, never exposing it to "
"external users."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:254
msgid ""
"Next, we need methods to implement the game logic. To simulate object-oriented "
"programming in our Lua code, let's store all Lua functions and shared variables "
"in a single local variable (let's name it as ``game``). This will allow us to "
"address functions or variables from within our module as ``self.func_name`` or "
"``self.var_name``. Like this:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:260
msgid ""
"local game = {\n"
"    -- a local variable\n"
"    num_players = 0,\n"
"\n"
"    -- a method that prints a local variable\n"
"    hello = function(self)\n"
"      print('Hello! Your player number is ' .. self.num_players .. '.')\n"
"    end,\n"
"\n"
"    -- a method that calls another method and returns a local variable\n"
"    sign_in = function(self)\n"
"      self.num_players = self.num_players + 1\n"
"      self:hello()\n"
"      return self.num_players\n"
"    end\n"
"}"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:279
msgid ""
"In OOP terms, we can now regard local variables inside ``game`` as object "
"fields, and local functions as object methods."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:284
#, fuzzy
msgid ""
"In this manual, Lua examples use **local** variables. Use **global** variables "
"with caution, since the module’s users may be unaware of them."
msgstr ""
"Обратите внимание, что в текущей документации в примерах Lua-кода используются "
"*локальные* переменные. Будьте аккуратны, если в своих модулях вы будете "
"использовать *глобальные* переменные, поскольку пользователи ваших модулей могут "
"не знать об этих переменных."

#: ../doc/1.7/book/app_server/creating_app.rst:287
msgid ""
"To enable/disable the use of undeclared global variables in your Lua code, use "
"Tarantool's :ref:`strict <strict-module>` module."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:290
msgid "So, our game module will have the following methods:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:292
msgid ""
"``catch()`` to calculate whether the pokémon was caught (besides the coordinates "
"of both the player and pokémon, this method will apply a probability factor, so "
"not every pokémon within the player's reach will be caught);"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:296
msgid ""
"``respawn()`` to add missing pokémons to the map, say, every 60 seconds (we "
"assume that a frightened pokémon runs away, so we remove a pokémon from the map "
"on any catch attempt and add it back to the map in a while);"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:299
msgid ""
"``notify()`` to log information about caught pokémons (like \"Player 1 caught "
"pokémon A\");"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:301
msgid ""
"``start()`` to initialize the game (it will create database spaces, create and "
"compile avro schemas, and launch ``respawn()``)."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:304
msgid ""
"Besides, it would be convenient to have methods for working with Tarantool "
"storage. For example:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:307
msgid "``add_pokemon()`` to add a pokémon to the database, and"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:308
msgid "``map()`` to populate the map with all pokémons stored in Tarantool."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:310
msgid ""
"We'll need these two methods primarily when initializing our game, but we can "
"also call them later, for example to test our code."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:317
msgid "Bootstrapping a database"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:319
msgid ""
"Let's discuss game initialization. In ``start()`` method, we need to populate "
"Tarantool spaces with pokémon data. Why not keep all game data in memory? Why "
"use a database? The answer is: :ref:`persistence <index-box_persistence>`. "
"Without a database, we risk losing data on power outage, for example. But if we "
"store our data in an in-memory database, Tarantool takes care to persist it on "
"disk whenever it's changed. This gives us one more benefit: quick startup in "
"case of failure. Tarantool has a :ref:`smart algorithm <internals-"
"recovery_process>` that quickly loads all data from disk into memory on startup, "
"so the warm-up takes little time."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:329
msgid ""
"We'll be using functions from Tarantool built-in :ref:`box <box-module>` module:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:331
msgid ""
"``box.schema.create_space('pokemons')`` to create a space named ``pokemon`` for "
"storing information about pokémons (we don't create a similar space for players, "
"because we intend to only send/receive player information via API calls, so we "
"needn't store it);"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:335
#, fuzzy
msgid ""
"``box.space.pokemons:create_index('primary', {type = 'hash', parts = {1, "
"'unsigned'}})`` to create a primary HASH index by pokémon ID;"
msgstr ""
"tarantool> i = s:create_index('primary', {type = 'hash', parts = {1, "
"'unsigned'}})"

#: ../doc/1.7/book/app_server/creating_app.rst:337
msgid ""
"``box.space.pokemons:create_index('status', {type = 'tree', parts = {2, "
"'str'}})`` to create a secondary TREE index by pokémon status."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:340
msgid ""
"Notice the ``parts =`` argument in the index specification. The pokémon ID is "
"the first field in a Tarantool tuple since it’s the first member of the "
"respective Avro type. So does the pokémon status. The actual JSON document may "
"have ID or status fields at any position of the JSON map."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:345
#, fuzzy
msgid "The implementation of ``start()`` method looks like this:"
msgstr "C-файл в нашем примере будет таким:"

#: ../doc/1.7/book/app_server/creating_app.rst:347
msgid ""
"-- create game object\n"
"start = function(self)\n"
"    -- create spaces and indexes\n"
"    box.once('init', function()\n"
"        box.schema.create_space('pokemons')\n"
"        box.space.pokemons:create_index(\n"
"            \"primary\", {type = 'hash', parts = {1, 'unsigned'}}\n"
"        )\n"
"        box.space.pokemons:create_index(\n"
"            \"status\", {type = \"tree\", parts = {2, 'str'}}\n"
"        )\n"
"    end)\n"
"\n"
"    -- create models\n"
"    local ok_m, pokemon = avro.create(schema.pokemon)\n"
"    local ok_p, player = avro.create(schema.player)\n"
"    if ok_m and ok_p then\n"
"        -- compile models\n"
"        local ok_cm, compiled_pokemon = avro.compile(pokemon)\n"
"        local ok_cp, compiled_player = avro.compile(player)\n"
"        if ok_cm and ok_cp then\n"
"            -- start the game\n"
"            <...>\n"
"        else\n"
"            log.error('Schema compilation failed')\n"
"        end\n"
"    else\n"
"        log.info('Schema creation failed')\n"
"    end\n"
"    return false\n"
"end"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:385
msgid "GIS"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:387
msgid ""
"Now let's discuss ``catch()``, which is the main method in our gaming logic."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:389
msgid ""
"Here we receive the player's coordinates and the target pokémon's ID number, and "
"we need to answer whether the player has actually caught the pokémon or not "
"(remember that each pokémon has a chance to escape)."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:393
msgid ""
"First thing, we validate the received player data against its :ref:`Avro schema "
"<app_server-avro_schemas>`. And we check whether such a pokémon exists in our "
"database and is displayed on the map (the pokémon must have the active status):"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:398
msgid ""
"catch = function(self, pokemon_id, player)\n"
"    -- check player data\n"
"    local ok, tuple = self.player_model.flatten(player)\n"
"    if not ok then\n"
"        return false\n"
"    end\n"
"    -- get pokemon data\n"
"    local p_tuple = box.space.pokemons:get(pokemon_id)\n"
"    if p_tuple == nil then\n"
"        return false\n"
"    end\n"
"    local ok, pokemon = self.pokemon_model.unflatten(p_tuple)\n"
"    if not ok then\n"
"        return false\n"
"    end\n"
"    if pokemon.status ~= self.state.ACTIVE then\n"
"        return false\n"
"    end\n"
"    -- more catch logic to follow\n"
"    <...>\n"
"end"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:422
msgid "Next, we calculate the answer: caught or not."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:424
msgid ""
"To work with geographical coordinates, we use Tarantool `gis <https://github.com/"
"tarantool/gis>`_ module."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:427
msgid ""
"To keep things simple, we don't load any specific map, assuming that we deal "
"with a world map. And we do not validate incoming coordinates, assuming again "
"that all received locations are within the planet Earth."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:431
msgid "We use two geo-specific variables:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:433
msgid ""
"``wgs84``, which stands for the latest revision of the World Geodetic System "
"standard, `WGS84 <https://en.wikipedia.org/wiki/World_Geodetic_System#WGS84>`_. "
"Basically, it comprises a standard coordinate system for the Earth and "
"represents the Earth as an ellipsoid."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:437
msgid ""
"``nationalmap``, which stands for the `US National Atlas Equal Area <https://"
"epsg.io/2163>`_. This is a projected coordinates system based on WGS84. It gives "
"us a zero base for location projection and allows positioning our players and "
"pokémons in meters."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:442
msgid ""
"Both these systems are listed in the EPSG Geodetic Parameter Registry, where "
"each system has a unique number. In our code, we assign these listing numbers to "
"respective variables:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:446
msgid ""
"wgs84 = 4326,\n"
"nationalmap = 2163,"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:451
msgid ""
"For our game logic, we need one more variable, ``catch_distance``, which defines "
"how close a player must get to a pokémon before trying to catch it. Let's set "
"the distance to 100 meters."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:455
msgid "catch_distance = 100,"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:459
msgid ""
"Now we're ready to calculate the answer. We need to project the current location "
"of both player (``p_pos``) and pokémon (``m_pos``) on the map, check whether the "
"player is close enough to the pokémon (using ``catch_distance``), and calculate "
"whether the player has caught the pokémon (here we generate some random value "
"and let the pokémon escape if the random value happens to be less than 100 minus "
"pokémon's chance value):"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:466
msgid ""
"-- project locations\n"
"local m_pos = gis.Point(\n"
"    {pokemon.location.x, pokemon.location.y}, self.wgs84\n"
"):transform(self.nationalmap)\n"
"local p_pos = gis.Point(\n"
"    {player.location.x, player.location.y}, self.wgs84\n"
"):transform(self.nationalmap)\n"
"\n"
"-- check catch distance condition\n"
"if p_pos:distance(m_pos) > self.catch_distance then\n"
"    return false\n"
"end\n"
"-- try to catch pokemon\n"
"local caught = math.random(100) >= 100 - pokemon.chance\n"
"if caught then\n"
"    -- update and notify on success\n"
"    box.space.pokemons:update(\n"
"        pokemon_id, {{'=', self.STATUS, self.state.CAUGHT}}\n"
"    )\n"
"    self:notify(player, pokemon)\n"
"end\n"
"return caught"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:495
#, fuzzy
msgid "Index iterators"
msgstr "Операции с индексами"

#: ../doc/1.7/book/app_server/creating_app.rst:497
msgid ""
"By our gameplay, all caught pokémons are returned back to the map. We do this "
"for all pokémons on the map every 60 seconds using ``respawn()`` method. We "
"iterate through pokémons by status using Tarantool index iterator function :ref:"
"`index:pairs <box_index-index_pairs>` and reset the statuses of all \"caught\" "
"pokémons back to \"active\" using ``box.space.pokemons:update()``."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:503
msgid ""
"respawn = function(self)\n"
"    fiber.name('Respawn fiber')\n"
"    for _, tuple in box.space.pokemons.index.status:pairs(\n"
"           self.state.CAUGHT) do\n"
"        box.space.pokemons:update(\n"
"            tuple[self.ID],\n"
"            {{'=', self.STATUS, self.state.ACTIVE}}\n"
"        )\n"
"    end\n"
" end"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:516
msgid "For readability, we introduce named fields:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:518
msgid "ID = 1, STATUS = 2,"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:521
msgid "The complete implementation of ``start()`` now looks like this:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:523
msgid ""
"-- create game object\n"
"start = function(self)\n"
"    -- create spaces and indexes\n"
"    box.once('init', function()\n"
"       box.schema.create_space('pokemons')\n"
"       box.space.pokemons:create_index(\n"
"           \"primary\", {type = 'hash', parts = {1, 'unsigned'}}\n"
"       )\n"
"       box.space.pokemons:create_index(\n"
"           \"status\", {type = \"tree\", parts = {2, 'str'}}\n"
"       )\n"
"    end)\n"
"\n"
"    -- create models\n"
"    local ok_m, pokemon = avro.create(schema.pokemon)\n"
"    local ok_p, player = avro.create(schema.player)\n"
"    if ok_m and ok_p then\n"
"        -- compile models\n"
"        local ok_cm, compiled_pokemon = avro.compile(pokemon)\n"
"        local ok_cp, compiled_player = avro.compile(player)\n"
"        if ok_cm and ok_cp then\n"
"            -- start the game\n"
"            self.pokemon_model = compiled_pokemon\n"
"            self.player_model = compiled_player\n"
"            self.respawn()\n"
"            log.info('Started')\n"
"            return true\n"
"         else\n"
"            log.error('Schema compilation failed')\n"
"         end\n"
"    else\n"
"        log.info('Schema creation failed')\n"
"    end\n"
"    return false\n"
"end"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:563
#: ../doc/1.7/reference/reference_lua/fiber.rst:54
msgid "Fibers"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:565
msgid ""
"But wait! If we launch it as shown above -- ``self.respawn()`` -- the function "
"will be executed only once, just like all the other methods. But we need to "
"execute ``respawn()`` every 60 seconds. Creating a :ref:`fiber <fiber-module>` "
"is the Tarantool way of making application logic work in the background at all "
"times."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:571
msgid ""
"A **fiber** exists for executing instruction sequences but it is not a thread. "
"The key difference is that threads use preemptive multitasking, while fibers use "
"cooperative multitasking. This gives fibers the following two advantages over "
"threads:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:576
msgid ""
"Better controllability. Threads often depend on the kernel's thread scheduler to "
"preempt a busy thread and resume another thread, so preemption may occur "
"unpredictably. Fibers yield themselves to run another fiber while executing, so "
"yields are controlled by application logic."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:580
msgid ""
"Higher performance. Threads require more resources to preempt as they need to "
"address the system kernel. Fibers are lighter and faster as they don't need to "
"address the kernel to yield."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:584
msgid ""
"Yet fibers have some limitations as compared with threads, the main limitation "
"being no multi-core mode. All fibers in an application belong to a single "
"thread, so they all use the same CPU core as the parent thread. Meanwhile, this "
"limitation is not really serious for Tarantool applications, because a typical "
"bottleneck for Tarantool is the HDD, not the CPU."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:590
msgid ""
"A fiber has all the features of a Lua `coroutine <http://www.lua.org/pil/"
"contents.html#9>`_ and all programming concepts that apply for Lua coroutines "
"will apply for fibers as well. However, Tarantool has made some enhancements for "
"fibers and has used fibers internally. So, although use of coroutines is "
"possible and supported, use of fibers is recommended."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:597
msgid ""
"Well, performance or controllability are of little importance in our case. We'll "
"launch ``respawn()`` in a fiber to make it work in the background all the time. "
"To do so, we'll need to amend ``respawn()``:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:601
msgid ""
"respawn = function(self)\n"
"    -- let's give our fiber a name;\n"
"    -- this will produce neat output in fiber.info()\n"
"    fiber.name('Respawn fiber')\n"
"    while true do\n"
"        for _, tuple in box.space.pokemons.index.status:pairs(\n"
"                self.state.CAUGHT) do\n"
"            box.space.pokemons:update(\n"
"                tuple[self.ID],\n"
"                {{'=', self.STATUS, self.state.ACTIVE}}\n"
"            )\n"
"        end\n"
"        fiber.sleep(self.respawn_time)\n"
"    end\n"
"end"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:619
msgid "and call it as a fiber in ``start()``:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:621
msgid ""
"start = function(self)\n"
"    -- create spaces and indexes\n"
"        <...>\n"
"    -- create models\n"
"        <...>\n"
"    -- compile models\n"
"        <...>\n"
"    -- start the game\n"
"       self.pokemon_model = compiled_pokemon\n"
"       self.player_model = compiled_player\n"
"       fiber.create(self.respawn, self)\n"
"       log.info('Started')\n"
"    -- errors if schema creation or compilation fails\n"
"       <...>\n"
"end"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:641
#: ../doc/1.7/reference/configuration/index.rst:269
#, fuzzy
msgid "Logging"
msgstr "Отладка"

#: ../doc/1.7/book/app_server/creating_app.rst:643
msgid ""
"One more helpful function that we used in ``start()`` was ``log.infо()`` from "
"Tarantool :ref:`log <log-module>` module. We also need this function in "
"``notify()`` to add a record to the log file on every successful catch:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:647
#, python-format
msgid ""
"-- event notification\n"
"notify = function(self, player, pokemon)\n"
"    log.info(\"Player '%s' caught '%s'\", player.name, pokemon.name)\n"
"end"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:654
msgid ""
"We use default Tarantool :ref:`log settings <cfg_logging>`, so we'll see the log "
"output in console when we launch our application in script mode."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:660
msgid ""
"Great! We've discussed all programming practices used in our Lua module (see "
"`pokemon.lua <https://github.com/Sulverus/pokemon/blob/master/src/pokemon."
"lua>`_)."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:663
msgid ""
"Now let's prepare the test environment. As planned, we write a Lua application "
"(see `game.lua <https://github.com/Sulverus/pokemon/blob/master/game.lua>`_) to "
"initialize Tarantool's database module, initialize our game, call the game loop "
"and simulate a couple of player requests."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:668
msgid ""
"To launch our microservice, we put both ``pokemon.lua`` module and ``game.lua`` "
"application in the current directory, install all external modules, and launch "
"the Tarantool instance running our ``game.lua`` application (this example is for "
"Ubuntu):"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:673
msgid ""
"$ ls\n"
"game.lua  pokemon.lua\n"
"$ sudo apt-get install tarantool-gis\n"
"$ sudo apt-get install tarantool-avro-schema\n"
"$ tarantool game.lua"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:681
msgid ""
"Tarantool starts and initializes the database. Then Tarantool executes the demo "
"logic from ``game.lua``: adds a pokémon named Pikachu (its chance to be caught "
"is very high, 99.1), displays the current map (it contains one active pokémon, "
"Pikachu) and processes catch requests from two players. Player1 is located just "
"near the lonely Pikachu pokémon and Player2 is located far away from it. As "
"expected, the catch results in this output are \"true\" for Player1 and \"false"
"\" for Player2. Finally, Tarantool displays the current map which is empty, "
"because Pikachu is caught and temporarily inactive:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:690
msgid ""
"$ tarantool game.lua\n"
"2017-01-09 20:19:24.605 [6282] main/101/game.lua C> version 1.7.3-43-gf5fa1e1\n"
"2017-01-09 20:19:24.605 [6282] main/101/game.lua C> log level 5\n"
"2017-01-09 20:19:24.605 [6282] main/101/game.lua I> mapping 1073741824 bytes for "
"tuple arena...\n"
"2017-01-09 20:19:24.609 [6282] main/101/game.lua I> initializing an empty data "
"directory\n"
"2017-01-09 20:19:24.634 [6282] snapshot/101/main I> saving snapshot "
"`./00000000000000000000.snap.inprogress'\n"
"2017-01-09 20:19:24.635 [6282] snapshot/101/main I> done\n"
"2017-01-09 20:19:24.641 [6282] main/101/game.lua I> ready to accept requests\n"
"2017-01-09 20:19:24.786 [6282] main/101/game.lua I> Started\n"
"---\n"
"- {'id': 1, 'status': 'active', 'location': {'y': 2, 'x': 1}, 'name': 'Pikachu', "
"'chance': 99.1}\n"
"...\n"
"\n"
"2017-01-09 20:19:24.789 [6282] main/101/game.lua I> Player 'Player1' caught "
"'Pikachu'\n"
"true\n"
"false\n"
"--- []\n"
"...\n"
"\n"
"2017-01-09 20:19:24.789 [6282] main C> entering the event loop"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:715
msgid "nginx"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:717
msgid ""
"In the real life, this microservice would work over HTTP. Let's add `nginx "
"<https://nginx.org/en/>`_ web server to our environment and make a similar demo. "
"But how do we make Tarantool methods callable via REST API? We use nginx with "
"`Tarantool nginx upstream <https://github.com/tarantool/nginx_upstream_module>`_ "
"module and create one more Lua script (`app.lua <https://github.com/Sulverus/"
"pokemon/blob/master/src/app.lua>`_) that exports three of our game methods -- "
"``add_pokemon()``, ``map()`` and ``catch()`` -- as REST endpoints of the nginx "
"upstream module:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:726
msgid ""
"local game = require('pokemon')\n"
"box.cfg{listen=3301}\n"
"game:start()\n"
"\n"
"-- add, map and catch functions exposed to REST API\n"
"function add(request, pokemon)\n"
"    return {\n"
"        result=game:add_pokemon(pokemon)\n"
"    }\n"
"end\n"
"\n"
"function map(request)\n"
"    return {\n"
"        map=game:map()\n"
"    }\n"
"end\n"
"\n"
"function catch(request, pid, player)\n"
"    local id = tonumber(pid)\n"
"    if id == nil then\n"
"        return {result=false}\n"
"    end\n"
"    return {\n"
"        result=game:catch(id, player)\n"
"    }\n"
"end"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:755
msgid ""
"An easy way to configure and launch nginx would be to create a Docker container "
"based on a `Docker image <https://hub.docker.com/r/tarantool/tarantool-nginx/>`_ "
"with nginx and the upstream module already installed (see `http/Dockerfile "
"<https://github.com/Sulverus/pokemon/blob/master/http/Dockerfile>`_). We take a "
"standard `nginx.conf <https://github.com/Sulverus/pokemon/blob/master/http/nginx."
"conf>`_, where we define an upstream with our Tarantool backend running (this is "
"another Docker container, see details below):"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:764
msgid ""
"upstream tnt {\n"
"      server pserver:3301 max_fails=1 fail_timeout=60s;\n"
"      keepalive 250000;\n"
"}"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:771
msgid ""
"and add some Tarantool-specific parameters (see descriptions in the upstream "
"module's `README <https://github.com/tarantool/"
"nginx_upstream_module#directives>`_ file):"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:775
msgid ""
"server {\n"
"  server_name tnt_test;\n"
"\n"
"  listen 80 default deferred reuseport so_keepalive=on backlog=65535;\n"
"\n"
"  location = / {\n"
"      root /usr/local/nginx/html;\n"
"  }\n"
"\n"
"  location /api {\n"
"    # answers check infinity timeout\n"
"    tnt_read_timeout 60m;\n"
"    if ( $request_method = GET ) {\n"
"       tnt_method \"map\";\n"
"    }\n"
"    tnt_http_rest_methods get;\n"
"    tnt_http_methods all;\n"
"    tnt_multireturn_skip_count 2;\n"
"    tnt_pure_result on;\n"
"    tnt_pass_http_request on parse_args;\n"
"    tnt_pass tnt;\n"
"  }\n"
"}"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:801
msgid ""
"Likewise, we put Tarantool server and all our game logic in a second Docker "
"container based on the `official Tarantool 1.7 image <https://github.com/"
"tarantool/docker>`_ (see `src/Dockerfile <https://github.com/Sulverus/pokemon/"
"blob/master/src/Dockerfile>`_) and set the container's default command to "
"``tarantool app.lua``. This is the backend."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:810
msgid "Non-blocking IO"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:812
msgid ""
"To test the REST API, we create a new script (`client.lua <https://github.com/"
"Sulverus/pokemon/blob/master/client/client.lua>`_), which is similar to our "
"``game.lua`` application, but makes HTTP POST and GET requests rather than "
"calling Lua functions:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:817
#, python-format
msgid ""
"local http = require('curl').http()\n"
"local json = require('json')\n"
"local URI = os.getenv('SERVER_URI')\n"
"local fiber = require('fiber')\n"
"\n"
"local player1 = {\n"
"    name=\"Player1\",\n"
"    id=1,\n"
"    location = {\n"
"        x=1.0001,\n"
"        y=2.0003\n"
"    }\n"
"}\n"
"local player2 = {\n"
"    name=\"Player2\",\n"
"    id=2,\n"
"    location = {\n"
"        x=30.123,\n"
"        y=40.456\n"
"    }\n"
"}\n"
"\n"
"local pokemon = {\n"
"    name=\"Pikachu\",\n"
"    chance=99.1,\n"
"    id=1,\n"
"    status=\"active\",\n"
"    location = {\n"
"        x=1,\n"
"        y=2\n"
"    }\n"
"}\n"
"\n"
"function request(method, body, id)\n"
"    local resp = http:request(\n"
"        method, URI, body\n"
"    )\n"
"    if id ~= nil then\n"
"        print(string.format('Player %d result: %s',\n"
"            id, resp.body))\n"
"    else\n"
"        print(resp.body)\n"
"    end\n"
"end\n"
"\n"
"local players = {}\n"
"function catch(player)\n"
"    fiber.sleep(math.random(5))\n"
"    print('Catch pokemon by player ' .. tostring(player.id))\n"
"    request(\n"
"        'POST', '{\"method\": \"catch\",\n"
"        \"params\": [1, '..json.encode(player)..']}',\n"
"        tostring(player.id)\n"
"    )\n"
"    table.insert(players, player.id)\n"
"end\n"
"\n"
"print('Create pokemon')\n"
"request('POST', '{\"method\": \"add\",\n"
"    \"params\": ['..json.encode(pokemon)..']}')\n"
"request('GET', '')\n"
"\n"
"fiber.create(catch, player1)\n"
"fiber.create(catch, player2)\n"
"\n"
"-- wait for players\n"
"while #players ~= 2 do\n"
"    fiber.sleep(0.001)\n"
"end\n"
"\n"
"request('GET', '')\n"
"os.exit()"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:892
msgid ""
"When you run this script, you’ll notice that both players have equal chances to "
"make the first attempt at catching the pokémon. In a classical Lua script, a "
"networked call blocks the script until it’s finished, so the first catch attempt "
"can only be done by the player who entered the game first. In Tarantool, both "
"players play concurrently, since all modules are integrated with Tarantool :ref:"
"`cooperative multitasking <atomic-cooperative_multitasking>` and use non-"
"blocking I/O."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:900
msgid ""
"Indeed, when Player1 makes its first REST call, the script doesn’t block. The "
"fiber running ``catch()`` function on behalf of Player1 issues a non-blocking "
"call to the operating system and yields control to the next fiber, which happens "
"to be the fiber of Player2. Player2’s fiber does the same. When the network "
"response is received, Player1's fiber is activated by Tarantool cooperative "
"scheduler, and resumes its work. All Tarantool :ref:`modules <built_in_modules>` "
"use non-blocking I/O and are integrated with Tarantool cooperative scheduler. "
"For module developers, Tarantool provides an :ref:`API <index-c_api_reference>`."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:909
msgid ""
"For our HTTP test, we create a third container based on the `official Tarantool "
"1.7 image <https://github.com/tarantool/docker>`_ (see `client/Dockerfile "
"<https://github.com/Sulverus/pokemon/blob/master/client/Dockerfile>`_) and set "
"the container's default command to ``tarantool client.lua``."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:917
msgid ""
"To run this test locally, download our `pokemon <https://github.com/Sulverus/"
"pokemon>`_ project from GitHub and say:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:920
msgid ""
"$ docker-compose build\n"
"$ docker-compose up"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:925
msgid ""
"Docker Compose builds and runs all the three containers: ``pserver`` (Tarantool "
"backend), ``phttp`` (nginx) and ``pclient`` (demo client). You can see log "
"messages from all these containers in the console, pclient saying that it made "
"an HTTP request to create a pokémon, made two catch requests, requested the map "
"(empty since the pokémon is caught and temporarily inactive) and exited:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:931
msgid ""
"pclient_1  | Create pokemon\n"
"<...>\n"
"pclient_1  | {\"result\":true}\n"
"pclient_1  | {\"map\":[{\"id\":1,\"status\":\"active\",\"location\":{\"y\":2,\"x"
"\":1},\"name\":\"Pikachu\",\"chance\":99.100000}]}\n"
"pclient_1  | Catch pokemon by player 2\n"
"pclient_1  | Catch pokemon by player 1\n"
"pclient_1  | Player 1 result: {\"result\":true}\n"
"pclient_1  | Player 2 result: {\"result\":false}\n"
"pclient_1  | {\"map\":[]}\n"
"pokemon_pclient_1 exited with code 0"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:944
msgid ""
"Congratulations! Here's the end point of our walk-through. As further reading, "
"see more about :ref:`installing <app_server-installing_module>` and :ref:"
"`contributing <app_server-contributing_module>` a module."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:948
msgid ""
"See also reference on :ref:`Tarantool modules <built_in_modules>` and :ref:`C "
"API <index-c_api_reference>`, and don't miss our :ref:`Lua cookbook recipes "
"<cookbook>`."
msgstr ""

#: ../doc/1.7/book/app_server/index.rst:39
msgid "Application server"
msgstr "Сервер приложений"

#: ../doc/1.7/book/app_server/index.rst:41
msgid ""
"In this chapter, we introduce the basics of working with Tarantool as a Lua "
"application server."
msgstr ""

#: ../doc/1.7/book/app_server/index.rst:44 ../doc/1.7/book/box/index.rst:44
#: ../doc/1.7/book/getting_started/index.rst:44
msgid "This chapter contains the following sections:"
msgstr ""

#: ../doc/1.7/book/app_server/installing_module.rst:39
#, fuzzy
msgid "Installing a module"
msgstr "Установка существующего модуля"

#: ../doc/1.7/book/app_server/installing_module.rst:41
msgid ""
"Modules in Lua and C that come from Tarantool developers and community "
"contributors are available in the following locations:"
msgstr ""

#: ../doc/1.7/book/app_server/installing_module.rst:44
msgid "Tarantool modules repository, and"
msgstr ""

#: ../doc/1.7/book/app_server/installing_module.rst:45
msgid "Tarantool deb/rpm repositories."
msgstr ""

#: ../doc/1.7/book/app_server/installing_module.rst:51
#, fuzzy
msgid "Installing a module from a repository"
msgstr "Установка существующего модуля"

#: ../doc/1.7/book/app_server/installing_module.rst:53
#, fuzzy
msgid ""
"See `README in tarantool/rocks repository <https://github.com/tarantool/"
"rocks#managing-modules-with-tarantool-174>`_ for detailed instructions."
msgstr ""
"Далее на странице `репозитория \"tarantool/rocks\" на GitHub <https://github.com/"
"tarantool/rocks>`_ вы можете посмотреть примеры модулей и инструкции по "
"добавлению собственных модулей в общий репозиторий."

#: ../doc/1.7/book/app_server/installing_module.rst:61
msgid "Installing a module from deb/rpm"
msgstr ""

#: ../doc/1.7/book/app_server/installing_module.rst:63
msgid "Follow these steps:"
msgstr ""

#: ../doc/1.7/book/app_server/installing_module.rst:65
msgid ""
"Install Tarantool as recommended on the `download page <http://tarantool.org/"
"download.html>`_."
msgstr ""

#: ../doc/1.7/book/app_server/installing_module.rst:68
msgid ""
"Install the module you need. Look up the module's name on `Tarantool rocks page "
"<http://tarantool.org/rocks.html>`_ and put the prefix \"tarantool-\" before the "
"module name to avoid ambiguity:"
msgstr ""

#: ../doc/1.7/book/app_server/installing_module.rst:72
msgid ""
"# for Ubuntu/Debian:\n"
"$ sudo apt-get install tarantool-<module-name>\n"
"\n"
"# for RHEL/CentOS/Amazon:\n"
"$ sudo yum install tarantool-<module-name>"
msgstr ""

#: ../doc/1.7/book/app_server/installing_module.rst:80
msgid ""
"For example, to install the module `shard <http://github.com/tarantool/shard>`_ "
"on Ubuntu, say:"
msgstr ""

#: ../doc/1.7/book/app_server/installing_module.rst:83
#: ../doc/1.7/reference/reference_rock/shard.rst:120
#, fuzzy
msgid "$ sudo apt-get install tarantool-shard"
msgstr "$ sudo apt-get install luarocks"

#: ../doc/1.7/book/app_server/installing_module.rst:87
msgid "Once these steps are complete, you can:"
msgstr "Теперь можно:"

#: ../doc/1.7/book/app_server/installing_module.rst:89
#, fuzzy
msgid "load any module with"
msgstr "загружать любой модуль для Tarantool'а с помощью ``require``"

#: ../doc/1.7/book/app_server/installing_module.rst:91
msgid "tarantool> local-name = require('module-name')"
msgstr ""

#: ../doc/1.7/book/app_server/installing_module.rst:95
msgid ""
"search locally for installed modules using ``package.path`` (Lua) or ``package."
"cpath`` (C):"
msgstr ""

#: ../doc/1.7/book/app_server/installing_module.rst:98
msgid ""
"tarantool> package.path\n"
"---\n"
"- ./?.lua;./?/init.lua; /usr/local/share/tarantool/?.lua;/usr/local/share/\n"
"tarantool/?/init.lua;/usr/share/tarantool/?.lua;/usr/share/tarantool/?/ini\n"
"t.lua;/usr/local/share/lua/5.1/?.lua;/usr/local/share/lua/5.1/?/init.lua;/\n"
"usr/share/lua/5.1/?.lua;/usr/share/lua/5.1/?/init.lua;\n"
"...\n"
"\n"
"tarantool> package.cpath\n"
"---\n"
"- ./?.so;/usr/local/lib/x86_64-linux-gnu/tarantool/?.so;/usr/lib/x86_64-li\n"
"nux-gnu/tarantool/?.so;/usr/local/lib/tarantool/?.so;/usr/local/lib/x86_64\n"
"-linux-gnu/lua/5.1/?.so;/usr/lib/x86_64-linux-gnu/lua/5.1/?.so;/usr/local/\n"
"lib/lua/5.1/?.so;\n"
"..."
msgstr ""

#: ../doc/1.7/book/app_server/installing_module.rst:118
#, fuzzy
msgid ""
"Question-marks stand for the module name that was specified earlier when saying "
"``require('module-name')``."
msgstr ""
"Знаки вопроса стоят вместо имени модуля, которое было указано ранее при вызове :"
"extsamp:`require('{*{имя_модуля}*}')`."

#: ../doc/1.7/book/app_server/launching_app.rst:39
#, fuzzy
msgid "Launching an application"
msgstr "Остановить приложение"

#: ../doc/1.7/book/app_server/launching_app.rst:41
msgid ""
"Using Tarantool as an application server, you can write your own applications. "
"Tarantool’s native language for writing applications is `Lua <http://www.lua.org/"
"about.html>`_, so a typical application would be a file that contains your Lua "
"script. But you can also write applications in C or C++."
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:49
msgid ""
"If you're new to Lua, we recommend going over the interactive Tarantool tutorial "
"before proceeding with this chapter. To launch the tutorial, say ``tutorial()`` "
"in Tarantool console:"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:53
msgid ""
"tarantool> tutorial()\n"
"---\n"
"- |\n"
" Tutorial -- Screen #1 -- Hello, Moon\n"
" ====================================\n"
"\n"
" Welcome to the Tarantool tutorial.\n"
" It will introduce you to Tarantool’s Lua application server\n"
" and database server, which is what’s running what you’re seeing.\n"
" This is INTERACTIVE -- you’re expected to enter requests\n"
" based on the suggestions or examples in the screen’s text.\n"
" <...>"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:68
msgid ""
"Let's create and launch our first Lua application for Tarantool. Here's a "
"simplest Lua application, the good old \"Hello, world!\":"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:71
msgid ""
"#!/usr/bin/env tarantool\n"
"print('Hello, world!')"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:76
msgid "We save it in a file. Let it be ``myapp.lua`` in the current directory."
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:78
msgid "Now let's discuss how we can launch our application with Tarantool."
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:84
msgid "Launching in Docker"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:86
msgid ""
"If we run Tarantool in a :ref:`Docker container <getting_started-using_docker>`, "
"the following command will start Tarantool without any application:"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:89
msgid ""
"# create a temporary container and run it in interactive mode\n"
"$ docker run --rm -t -i tarantool/tarantool"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:94
msgid "To run Tarantool with our application, we can say:"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:96
msgid ""
"# create a temporary container and\n"
"# launch Tarantool with our application\n"
"$ docker run --rm -t -i \\\n"
"             -v `pwd`/myapp.lua:/opt/tarantool/myapp.lua \\\n"
"             -v /data/dir/on/host:/var/lib/tarantool \\\n"
"             tarantool/tarantool tarantool /opt/tarantool/myapp.lua"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:105
msgid "Here two resources on the host get mounted in the container:"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:107
msgid "our application file (``\\`pwd\\`/myapp.lua``) and"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:108
msgid "Tarantool data directory (``/data/dir/on/host``)."
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:110
msgid ""
"By convention, the directory for Tarantool application code inside a container "
"is ``/opt/tarantool``, and the directory for data is ``/var/lib/tarantool``."
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:117
msgid "Launching a binary program"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:119
msgid ""
"If we run Tarantool from a :ref:`binary package <getting_started-using_binary>` "
"or from a :ref:`source build <building_from_source>`, we can launch our "
"application:"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:123
msgid "in the script mode,"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:124
msgid "as a server application, or"
msgstr "как серверное приложение, либо"

#: ../doc/1.7/book/app_server/launching_app.rst:125
msgid "as a daemon service."
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:127
msgid "The simplest way is to pass the filename to Tarantool at start:"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:135
msgid "Tarantool starts, executes our script in the **script mode** and exits."
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:137
msgid ""
"Now let’s turn this script into a **server application**. We use :ref:`box.cfg "
"<box_introspection-box_cfg>` from Tarantool’s built-in Lua module to:"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:141
msgid ""
"launch the database (a database has a persistent on-disk state, which needs to "
"be restored after we start an application) and"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:143
msgid "configure Tarantool as a server that accepts requests over a TCP port."
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:145
msgid ""
"We also add some simple database logic, using :ref:`space.create() <box_schema-"
"space_create>` and :ref:`create_index() <box_space-create_index>` to create a "
"space with a primary index. We use the function :ref:`box.once() <box-once>` to "
"make sure that our logic will be executed only once when the database is "
"initialized for the first time, so we don't try to create an existing space or "
"index on each invocation of the script:"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:166
msgid "Now we launch our application in the same manner as before:"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:185
msgid ""
"This time, Tarantool executes our script and keeps working as a server, "
"accepting TCP requests on port 3301. We can see Tarantool in the current "
"session’s process list:"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:195
msgid ""
"But the Tarantool instance will stop if we close the current terminal window. To "
"detach Tarantool and our application from the terminal window, we can launch it "
"in the **daemon mode**. To do so, we add some parameters to ``box.cfg{}``:"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:199
msgid ""
":ref:`background <cfg_basic-background>` = ``true`` that actually tells "
"Tarantool to work as a daemon service,"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:201
msgid ""
":ref:`log <cfg_logging-log>` = ``'dir-name'`` that tells the Tarantool daemon "
"where to store its log file (other log settings are available in Tarantool :ref:"
"`log <log-module>` module), and"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:204
msgid ""
":ref:`pid_file <cfg_basic-pid_file>` = ``'file-name'`` that tells the Tarantool "
"daemon where to store its pid file."
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:207
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:34
#: ../doc/1.7/reference/reference_lua/box_error.rst:73
#: ../doc/1.7/reference/reference_rock/dbms.rst:116
#: ../doc/1.7/reference/reference_rock/dbms.rst:469
msgid "For example:"
msgstr "Например:"

#: ../doc/1.7/book/app_server/launching_app.rst:209
msgid ""
"box.cfg {\n"
"   listen = 3301\n"
"   background = true,\n"
"   log = '1.log',\n"
"   pid_file = '1.pid'\n"
"}"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:218
msgid "We launch our application in the same manner as before:"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:226
msgid ""
"Tarantool executes our script, gets detached from the current shell session (you "
"won't see it with ``ps | grep \"tarantool\"``) and continues working in the "
"background as a daemon attached to the global session (with SID = 0):"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:236
msgid ""
"Now that we have discussed how to create and launch a Lua application for "
"Tarantool, let's dive deeper into programming practices."
msgstr ""

#: ../doc/1.7/book/app_server/reloading_module.rst:39
#, fuzzy
msgid "Reloading a module"
msgstr "Установка существующего модуля"

#: ../doc/1.7/book/app_server/reloading_module.rst:41
msgid "You can reload any Tarantool application or module with zero downtime."
msgstr ""

#: ../doc/1.7/book/app_server/reloading_module.rst:47
msgid "Reloading a module in Lua"
msgstr "Перезагрузка модуля на Lua"

#: ../doc/1.7/book/app_server/reloading_module.rst:49
msgid ""
"Here's an example that illustrates the most typical case -- \"update and reload"
"\"."
msgstr ""

#: ../doc/1.7/book/app_server/reloading_module.rst:53
msgid ""
"In this example, we use recommended :ref:`administration practices <admin>` "
"based on :ref:`instance files <admin-instance_file>` and :ref:`tarantoolctl "
"<tarantoolctl>` utility."
msgstr ""

#: ../doc/1.7/book/app_server/reloading_module.rst:57
#, fuzzy
msgid "Update the application file."
msgstr "При необходимости обновите файлы приложения."

#: ../doc/1.7/book/app_server/reloading_module.rst:59
msgid "For example, a module in ``/usr/share/tarantool/app.lua``:"
msgstr ""

#: ../doc/1.7/book/app_server/reloading_module.rst:61
msgid ""
"local function start()\n"
"  -- initial version\n"
"  box.once(\"myapp:v1.0\", function()\n"
"    box.schema.space.create(\"somedata\")\n"
"    box.space.somedata:create_index(\"primary\")\n"
"    ...\n"
"  end)\n"
"\n"
"  -- migration code from 1.0 to 1.1\n"
"  box.once(\"myapp:v1.1\", function()\n"
"    box.space.somedata.index.primary:alter(...)\n"
"    ...\n"
"  end)\n"
"\n"
"  -- migration code from 1.1 to 1.2\n"
"  box.once(\"myapp:v1.2\", function()\n"
"    box.space.somedata.space:alter(...)\n"
"    box.space.somedata:insert(...)\n"
"    ...\n"
"  end)\n"
"end\n"
"\n"
"-- start some background fibers if you need\n"
"\n"
"local function stop()\n"
"  -- stop all background fibers and clean up resources\n"
"end\n"
"\n"
"local function api_for_call(xxx)\n"
"  -- do some business\n"
"end\n"
"\n"
"return {\n"
"  start = start,\n"
"  stop = stop,\n"
"  api_for_call = api_for_call\n"
"}"
msgstr ""

#: ../doc/1.7/book/app_server/reloading_module.rst:101
msgid "Update the :ref:`instance file <admin-instance_file>`."
msgstr "Обновить :ref:`файл экземпляра <admin-instance_file>`."

#: ../doc/1.7/book/app_server/reloading_module.rst:103
msgid "For example, ``/etc/tarantool/instances.enabled/my_app.lua``:"
msgstr ""

#: ../doc/1.7/book/app_server/reloading_module.rst:105
msgid ""
"#!/usr/bin/env tarantool\n"
"--\n"
"-- hot code reload example\n"
"--\n"
"\n"
"box.cfg({listen = 3302})\n"
"\n"
"-- ATTENTION: unload it all properly!\n"
"local app = package.loaded['app']\n"
"if app ~= nil then\n"
"  -- stop the old application version\n"
"  app.stop()\n"
"  -- unload the application\n"
"  package.loaded['app'] = nil\n"
"  -- unload all dependencies\n"
"  package.loaded['somedep'] = nil\n"
"end\n"
"\n"
"-- load the application\n"
"log.info('require app')\n"
"app = require('app')\n"
"\n"
"-- start the application\n"
"app.start({some app options controlled by sysadmins})"
msgstr ""

#: ../doc/1.7/book/app_server/reloading_module.rst:132
msgid ""
"The important thing here is to properly unload the application and its "
"dependencies."
msgstr ""

#: ../doc/1.7/book/app_server/reloading_module.rst:135
msgid "Manually reload the application file."
msgstr ""

#: ../doc/1.7/book/app_server/reloading_module.rst:137
msgid "For example, using ``tarantoolctl``:"
msgstr ""

#: ../doc/1.7/book/app_server/reloading_module.rst:139
msgid "$ tarantoolctl eval my_app /etc/tarantool/instances.enabled/my_app.lua"
msgstr ""

#: ../doc/1.7/book/app_server/reloading_module.rst:147
msgid "Reloading a module in C"
msgstr "Перезагрузка модуля на С"

#: ../doc/1.7/book/app_server/reloading_module.rst:149
msgid ""
"After you compiled a new version of a C module (``*.so`` shared library), call :"
"ref:`box.schema.func.reload('module-name') <box_schema-func_reload>` from your "
"Lua script to reload the module."
msgstr ""

#: ../doc/1.7/book/app_server/using_ide.rst:39
msgid "Developing with an IDE"
msgstr ""

#: ../doc/1.7/book/app_server/using_ide.rst:41
msgid ""
"You can use IntelliJ IDEA as an IDE to develop and debug Lua applications for "
"Tarantool."
msgstr ""

#: ../doc/1.7/book/app_server/using_ide.rst:44
msgid ""
"Download and install the IDE from the `official web-site <https://www.jetbrains."
"com/idea/>`_."
msgstr ""

#: ../doc/1.7/book/app_server/using_ide.rst:47
msgid ""
"JetBrains provides specialized editions for particular languages: IntelliJ IDEA "
"(Java), PHPStorm (PHP), PyCharm (Python), RubyMine (Ruby), CLion (C/C++), "
"WebStorm (Web) and others. So, download a version that suits your primary "
"programming language."
msgstr ""

#: ../doc/1.7/book/app_server/using_ide.rst:52
msgid "Tarantool integration is supported for all editions."
msgstr ""

#: ../doc/1.7/book/app_server/using_ide.rst:54
msgid "Configure the IDE:"
msgstr ""

#: ../doc/1.7/book/app_server/using_ide.rst:56
msgid "Start IntelliJ IDEA."
msgstr ""

#: ../doc/1.7/book/app_server/using_ide.rst:57
msgid "Click ``Configure`` button and select ``Plugins``."
msgstr ""

#: ../doc/1.7/book/app_server/using_ide.rst:64
msgid "Click ``Browse repositories``."
msgstr ""

#: ../doc/1.7/book/app_server/using_ide.rst:71
msgid "Install ``EmmyLua`` plugin."
msgstr ""

#: ../doc/1.7/book/app_server/using_ide.rst:75
msgid ""
"Please don’t be confused with ``Lua`` plugin, which is less powerful than "
"``EmmyLua``."
msgstr ""

#: ../doc/1.7/book/app_server/using_ide.rst:83
msgid "Restart IntelliJ IDEA."
msgstr ""

#: ../doc/1.7/book/app_server/using_ide.rst:84
msgid ""
"Click ``Configure``, select ``Project Defaults`` and then ``Run Configurations``."
msgstr ""

#: ../doc/1.7/book/app_server/using_ide.rst:92
msgid "Find ``Lua Application`` in the sidebar at the left."
msgstr ""

#: ../doc/1.7/book/app_server/using_ide.rst:94
msgid "In ``Program``, type a path to an installed ``tarantool`` binary."
msgstr ""

#: ../doc/1.7/book/app_server/using_ide.rst:96
msgid ""
"By default, this is ``tarantool`` or ``/usr/bin/tarantool`` on most platforms."
msgstr ""

#: ../doc/1.7/book/app_server/using_ide.rst:99
msgid ""
"If you installed ``tarantool`` from sources to a custom directory, please "
"specify the proper path here."
msgstr ""

#: ../doc/1.7/book/app_server/using_ide.rst:107
msgid "Now IntelliJ IDEA is ready to use with Tarantool."
msgstr ""

#: ../doc/1.7/book/app_server/using_ide.rst:109
msgid "Create a new Lua project."
msgstr ""

#: ../doc/1.7/book/app_server/using_ide.rst:116
msgid "Add a new Lua file, for example ``init.lua``."
msgstr ""

#: ../doc/1.7/book/app_server/using_ide.rst:123
msgid "Write your code, save the file."
msgstr ""

#: ../doc/1.7/book/app_server/using_ide.rst:125
msgid ""
"To run you application, click ``Run -> Run`` in the main menu and select your "
"source file in the list."
msgstr ""

#: ../doc/1.7/book/app_server/using_ide.rst:133
msgid "Or click ``Run -> Debug`` to start debugging."
msgstr ""

#: ../doc/1.7/book/app_server/using_ide.rst:137
msgid ""
"To use Lua debugger, please upgrade Tarantool to version 1.7.5-29-gbb6170e4b or "
"later."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:39
msgid "Transaction control"
msgstr "Контроль транзакций"

#: ../doc/1.7/book/box/atomic.rst:41
msgid ""
"Transactions in Tarantool occur in **fibers** on a single **thread**. That is "
"why Tarantool has a guarantee of execution atomicity. That requires emphasis."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:49
msgid "Threads, fibers and yields"
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:51
#, fuzzy
msgid ""
"How does Tarantool process a basic operation? As an example, let's take this "
"query:"
msgstr ""
"Как Tarantool выполняет основные операции? Давайте рассмотрим это на следующем "
"примере:"

#: ../doc/1.7/book/box/atomic.rst:54
msgid "tarantool> box.space.tester:update({3}, {{'=', 2, 'size'}, {'=', 3, 0}})"
msgstr "tarantool> box.space.tester:update({3}, {{'=', 2, 'size'}, {'=', 3, 0}})"

#: ../doc/1.7/book/box/atomic.rst:58
#, fuzzy
msgid "This is equivalent to an SQL statement like:"
msgstr "Это аналогично следующему выражению на языке SQL:"

#: ../doc/1.7/book/box/atomic.rst:60
#, fuzzy
msgid ""
"UPDATE tester SET \"field[2]\" = 'size', \"field[3]\" = 0 WHERE \"field[1]\" = 3"
msgstr ""
"UPDATE tester SET \"field[2]\" = 'size', \"field[3]\" = 0 WHERE \"field[[1]\" = 3"

#: ../doc/1.7/book/box/atomic.rst:64
msgid "This query will be processed with three operating system **threads**:"
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:66
msgid ""
"If we issue the query on a remote client, then the **network thread** on the "
"server side receives the query, parses the statement and changes it to a server "
"executable message which has already been checked, and which the server instance "
"can understand without parsing everything again."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:71
msgid ""
"The network thread ships this message to the instance's **\"transaction processor"
"\" thread** using a lock-free message bus. Lua programs execute directly in the "
"transaction processor thread, and do not require parsing and preparation."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:76
#, fuzzy
msgid ""
"The instance's transaction processor thread uses the primary-key index on "
"field[1] to find the location of the tuple. It determines that the tuple can be "
"updated (not much can go wrong when you're merely changing an unindexed field "
"value to something shorter)."
msgstr ""
"Поток, выполняющий обработку транзакций на стороне сервера, использует первичный "
"индекс по полю field[1], чтобы найти нужный кортеж в памяти. Он проверяет, что "
"данный кортеж можно обновить (мы хотим лишь изменить значение не "
"индексированного поля, и вряд ли что-то пойдет не так в таком простом случае)."

#: ../doc/1.7/book/box/atomic.rst:81
msgid ""
"The transaction processor thread sends a message to the :ref:`write-ahead "
"logging (WAL) thread <internals-wal>` to commit the transaction. When done, the "
"WAL thread replies with a COMMIT or ROLLBACK result, which is returned to the "
"client."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:86
#, fuzzy
msgid ""
"Notice that there is only one transaction processor thread in Tarantool. Some "
"people are used to the idea that there can be multiple threads operating on the "
"database, with (say) thread #1 reading row #x, while thread #2 writes row #y. "
"With Tarantool, no such thing ever happens. Only the transaction processor "
"thread can access the database, and there is only one transaction processor "
"thread for each Tarantool instance."
msgstr ""
"В Tarantool'е есть только один поток обработки транзакций. Многие люди уже "
"привыкли к мысли, что потоков для обработки данных может быть много (например, "
"поток #1 читает данные из строки #x, в то время как поток #2 записывает данные в "
"столбец #y). В случае с Tarantool'ом такого не происходит. доступ к базе есть "
"только у потока обработки транзакций, и на каждый экземпляр Tarantool'а есть "
"только один такой поток."

#: ../doc/1.7/book/box/atomic.rst:93
#, fuzzy
msgid ""
"Like any other Tarantool thread, the transaction processor thread can handle "
"many :ref:`fibers <fiber-fibers>`. A fiber is a set of computer instructions "
"that may contain \"**yield**\" signals. The transaction processor thread will "
"execute all computer instructions until a yield, then switch to execute the "
"instructions of a different fiber. Thus (say) the thread reads row #x for the "
"sake of fiber #1, then writes row #y for the sake of fiber #2."
msgstr ""
"Поток обработки транзакций может управлять множеством *файберов*. Файбер — это "
"набор инструкций, среди которых могут быть и сигналы \"передать управление\". "
"Поток обработки транзакций выполняет инструкции, пока не увидит такой сигнал, и "
"тогда он переключается на выполнение инструкций из другого файбера. Например, "
"таким образом поток обработки транзакций сначала выполняет чтение данных из "
"строки #x для файбера #1, а затем выполняет запись в строку #y для файбер #2."

#: ../doc/1.7/book/box/atomic.rst:100
msgid ""
"Yields must happen, otherwise the transaction processor thread would stick "
"permanently on the same fiber. There are two types of yields:"
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:103
msgid ""
":ref:`implicit yields <atomic-implicit-yields>`: every data-change operation or "
"network-access causes an implicit yield, and every statement that goes through "
"the Tarantool client causes an implicit yield."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:107
msgid ""
"explicit yields: in a Lua function, you can (and should) add :ref:`\"yield\" "
"<fiber-yield>` statements to prevent hogging. This is called **cooperative "
"multitasking**."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:115
#, fuzzy
msgid "Cooperative multitasking"
msgstr "Среда взаимной многозадачности"

#: ../doc/1.7/book/box/atomic.rst:117
msgid ""
"Cooperative multitasking means: unless a running fiber deliberately yields "
"control, it is not preempted by some other fiber. But a running fiber will "
"deliberately yield when it encounters a “yield point”: a transaction commit, an "
"operating system call, or an explicit :ref:`\"yield\" <fiber-yield>` request. "
"Any system call which can block will be performed asynchronously, and any "
"running fiber which must wait for a system call will be preempted, so that "
"another ready-to-run fiber takes its place and becomes the new running fiber."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:125
msgid ""
"This model makes all programmatic locks unnecessary: cooperative multitasking "
"ensures that there will be no concurrency around a resource, no race conditions, "
"and no memory consistency issues."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:129
msgid ""
"When requests are small, for example simple UPDATE or INSERT or DELETE or "
"SELECT, fiber scheduling is fair: it takes only a little time to process the "
"request, schedule a disk write, and yield to a fiber serving the next client."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:133
msgid ""
"However, a function might perform complex computations or might be written in "
"such a way that yields do not occur for a long time. This can lead to unfair "
"scheduling, when a single client throttles the rest of the system, or to "
"apparent stalls in request processing. Avoiding this situation is the "
"responsibility of the function’s author."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:143
#, fuzzy
msgid "Transactions"
msgstr "Контроль транзакций"

#: ../doc/1.7/book/box/atomic.rst:145
msgid ""
"In the absence of transactions, any function that contains yield points may see "
"changes in the database state caused by fibers that preempt. Multi-statement "
"transactions exist to provide isolation: each transaction sees a consistent "
"database state and commits all its changes atomically. At :ref:`commit <box-"
"commit>` time, a yield happens and all transaction changes are written to the :"
"ref:`write ahead log <internals-wal>` in a single batch."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:152
msgid ""
"To implement isolation, Tarantool uses a simple optimistic scheduler: the first "
"transaction to commit wins. If a concurrent active transaction has read a value "
"modified by a committed transaction, it is aborted."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:156
msgid ""
"The cooperative scheduler ensures that, in absence of yields, a multi-statement "
"transaction is not preempted and hence is never aborted. Therefore, "
"understanding yields is essential to writing abort-free code."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:162
msgid "You can’t mix storage engines in a transaction today."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:168
#, fuzzy
msgid "Implicit yields"
msgstr "Правила неявной передачи управления"

#: ../doc/1.7/book/box/atomic.rst:170
msgid ""
"The only explicit yield requests in Tarantool are :ref:`fiber.sleep() <fiber-"
"sleep>` and :ref:`fiber.yield() <fiber-yield>`, but many other requests \"imply"
"\" yields because Tarantool is designed to avoid blocking."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:174
msgid "Database operations usually do not yield, but it depends on the engine:"
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:176
msgid "In memtx, reads or writes do not require I/O and do not yield."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:178
msgid ""
"In vinyl, not all data is in memory, and SELECT often incurs a disc I/O, and "
"therefore yields, while a write may stall waiting for memory to free up, thus "
"also causing a yield."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:182
msgid ""
"In the \"autocommit\" mode, all data change operations are followed by an "
"automatic commit, which yields. So does an explicit commit of a multi-statement "
"transaction, :ref:`box.commit() <box-commit>`."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:186
msgid ""
"Many functions in modules :ref:`fio <fio-section>`, :ref:`net_box <net_box-"
"module>`, :ref:`console <console-module>` and :ref:`socket <socket-module>` (the "
"\"os\" and \"network\" requests) yield."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:190 ../doc/1.7/book/box/authentication.rst:188
#: ../doc/1.7/book/box/box_session.rst:247
#, fuzzy
msgid "**Example #1**"
msgstr "**Примеры:**"

#: ../doc/1.7/book/box/atomic.rst:192
msgid ""
"*Engine = memtx* |br| ``select() insert()`` has one yield, at the end of "
"insertion, caused by implicit commit; ``select()`` has nothing to write to the "
"WAL and so does not yield."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:197
msgid ""
"*Engine = vinyl* |br| ``select() insert()`` has between one and three yields, "
"since ``select()`` may yield if the data is not in cache, ``insert()`` may yield "
"waiting for available memory, and there is an implicit yield at commit."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:202
msgid ""
"The sequence ``begin() insert() insert() commit()`` yields only at commit if the "
"engine is memtx, and can yield up to 3 times if the engine is vinyl."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:205 ../doc/1.7/book/box/authentication.rst:196
#: ../doc/1.7/book/box/box_session.rst:256
#, fuzzy
msgid "**Example #2**"
msgstr "**Примеры:**"

#: ../doc/1.7/book/box/atomic.rst:207
msgid ""
"Assume that in space ‘tester’ there are tuples in which the third field "
"represents a positive dollar amount. Let's start a transaction, withdraw from "
"tuple#1, deposit in tuple#2, and end the transaction, making its effects "
"permanent."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:212
msgid ""
"tarantool> function txn_example(from, to, amount_of_money)\n"
"         >   box.begin()\n"
"         >   box.space.tester:update(from, {{'-', 3, amount_of_money}})\n"
"         >   box.space.tester:update(to,   {{'+', 3, amount_of_money}})\n"
"         >   box.commit()\n"
"         >   return \"ok\"\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> txn_example({999}, {1000}, 1.00)\n"
"---\n"
"- \"ok\"\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:228
msgid ""
"If :ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>` = ‘none’, then "
"implicit yielding at commit time does not take place, because there are no "
"writes to the WAL."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:232
msgid ""
"If a task is interactive -- sending requests to the server and receiving "
"responses -- then it involves network IO, and therefore there is an implicit "
"yield, even if the request that is sent to the server is not itself an implicit "
"yield request. Therefore, the sequence:"
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:240
msgid ""
"select\n"
"select\n"
"select"
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:244
msgid ""
"causes blocking (in memtx), if it is inside a function or Lua program being "
"executed on the server instance, but causes yielding (in both memtx and vinyl) "
"if it is done as a series of transmissions from a client, including a client "
"which operates via telnet, via one of the connectors, or via the :ref:`MySQL and "
"PostgreSQL rocks <dbms_modules>`, or via the interactive mode when :ref:`using "
"Tarantool as a client <admin-using_tarantool_as_a_client>`."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:251
msgid ""
"After a fiber has yielded and then has regained control, it immediately issues :"
"ref:`testcancel <fiber-testcancel>`."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:39
msgid "Access control"
msgstr "Ограничение доступа"

#: ../doc/1.7/book/box/authentication.rst:41
msgid ""
"Understanding security details is primarily an issue for administrators. "
"Meanwhile, ordinary users should at least skim this section to get an idea of "
"how Tarantool makes it possible for administrators to prevent unauthorized "
"access to the database and to certain functions."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:46
msgid "In a nutshell:"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:48
msgid ""
"There is a method to guarantee with password checks that users really are who "
"they say they are (“authentication”)."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:51
msgid ""
"There is a :ref:`_user <box_space-user>` system space, where usernames and "
"password-hashes are stored."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:54
msgid ""
"There are functions for saying that certain users are allowed to do certain "
"things (“privileges”)."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:57
msgid ""
"There is a :ref:`_priv <box_space-priv>` system space, where privileges are "
"stored. Whenever a user tries to do an operation, there is a check whether the "
"user has the privilege to do the operation (“access control”)."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:61
msgid "Further on, we explain all of this in more detail."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:67
msgid "Users"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:69
msgid ""
"There is a **current user** for any program working with Tarantool, local or "
"remote. If a remote connection is using a :ref:`binary port <admin-security>`, "
"the current user, by default, is '**guest**'. If the connection is using an :ref:"
"`admin-console port <admin-security>`, the current user is '**admin**'. When "
"executing a :ref:`Lua initialization script <index-init_label>`, the current "
"user is also ‘admin’."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:78
msgid ""
"The current user name can be found with :ref:`box.session.user() <box_session-"
"user>`."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:80
msgid "The current user can be changed:"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:82
msgid ""
"For a binary port connection -- with AUTH protocol command, supported by most "
"clients;"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:85
msgid ""
"For an admin-console connection and in a Lua initialization script -- with :ref:"
"`box.session.su <box_session-su>`;"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:88
msgid ""
"For a stored function invoked with CALL command over a binary port -- with :ref:"
"`SETUID <box_schema-func_create>` property enabled for the function, which makes "
"Tarantool temporarily replace the current user with the function’s creator, with "
"all creator's privileges, during function execution."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:97
msgid "Passwords"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:99
msgid ""
"Each user (except 'guest') may have a **password**. The password is any "
"alphanumeric string."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:101
#, python-format
msgid ""
"Tarantool passwords are stored in the :ref:`_user <box_space-user>` system space "
"with a `cryptographic hash function <https://en.wikipedia.org/wiki/"
"Cryptographic_hash_function>`_ so that, if the password is ‘x’, the stored hash-"
"password is a long string like ‘lL3OvhkIPOKh+Vn9Avlkx69M/Ck=‘. When a client "
"connects to a Tarantool instance, the instance sends a random `salt value "
"<https://en.wikipedia.org/wiki/Salt_%28cryptography%29>`_ which the client must "
"mix with the hashed-password before sending to the instance. Thus the original "
"value ‘x’ is never stored anywhere except in the user’s head, and the hashed "
"value is never passed down a network wire except when mixed with a random salt."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:115
msgid ""
"For more details of the password hashing algorithm (e.g. for the purpose of "
"writing a new client application), read the `scramble.h <https://github.com/"
"tarantool/tarantool/blob/1.7/src/scramble.h>`_ header file."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:120
msgid ""
"This system prevents malicious onlookers from finding passwords by snooping in "
"the log files or snooping on the wire. It is the same system that `MySQL "
"introduced several years ago <http://dev.mysql.com/doc/refman/5.7/en/password-"
"hashing.html>`_, which has proved adequate for medium-security installations. "
"Nevertheless, administrators should warn users that no system is foolproof "
"against determined long-term attacks, so passwords should be guarded and changed "
"occasionally. Administrators should also advise users to choose long unobvious "
"passwords, but it is ultimately up to the users to choose or change their own "
"passwords."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:130
msgid ""
"There are two functions for managing passwords in Tarantool: :ref:`box.schema."
"user.password() <box_schema-user_password>` for changing a user's password and :"
"ref:`box.schema.user.passwd() <box_schema-user_passwd>` for getting a hash-"
"password."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:139
msgid "Owners and privileges"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:141
msgid ""
"In Tarantool, all objects are organized into a hierarchy of ownership. "
"Ordinarily the **owner** of every object is its creator. The creator of the "
"initial database state (we call it ‘universe’) --  including the database "
"itself, the system spaces, the users -- is ‘admin’."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:146
msgid ""
"An object's owner can share some rights on the object by **granting privileges** "
"to other users. The following privileges are implemented:"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:149
msgid "Read an object,"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:150
msgid "Write, i.e. modify contents of an object,"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:151
msgid ""
"Execute, i.e. use an object (if the privilege makes sense for the object; for "
"example, spaces can not be \"executed\", but functions can)."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:156
msgid ""
"Currently, \"drop\" and \"grant\" privileges can not be granted to other users. "
"This possibility will be added in future versions of Tarantool."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:159
msgid ""
"This is how the privilege system works under the hood. To be able to create "
"objects, a user needs to have write access to Tarantool's system spaces. The "
"'admin' user, who is at the top of the hierarchy and who is the ultimate source "
"of privileges, shares write access to a system space (e.g. :ref:`_space "
"<box_space-space>`) with some users. Now the users can insert data into the "
"system space (e.g. creating new spaces) and themselves become creators/definers "
"of new objects. For the objects they created, the users can in turn share "
"privileges with other users."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:168
msgid ""
"This is why only an object's owner can drop the object, but other ordinary users "
"cannot. Meanwhile, 'admin' can drop any object or delete any other user, because "
"'admin' is the creator and ultimate owner of them all."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:172
msgid ""
"The syntax of all :ref:`grant() <box_schema-user_grant>`/:ref:`revoke() "
"<box_schema-user_revoke>` commands in Tarantool follows this basic idea."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:176
msgid ""
"Their first argument is the user who gets the grant or whose grant is revoked."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:178
msgid ""
"Their second argument is the type of privilege granted, or a list of privileges."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:180
msgid ""
"Their third argument is the object type on which the privilege is granted, or "
"the word 'universe'."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:183
msgid ""
"Their fourth argument is the object name if the object type was specified "
"('universe' has no name, because there is only one 'universe', but you need to "
"specify names for functions/users/spaces/etc)."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:190
msgid "Here we say that user 'guest' can do common operations on any object."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:192
#, fuzzy
msgid "box.schema.user.grant('guest', 'read,write,execute', 'universe')"
msgstr ""
"tarantool> box.schema.user.grant('guest', 'read,write,execute', 'universe')"

#: ../doc/1.7/book/box/authentication.rst:198
msgid ""
"Here we create a Lua function that will be executed under the user id of its "
"creator, even if called by another user."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:201
msgid ""
"First, we create two spaces ('u' and 'i') and grant a no-password user "
"('internal') full access to them. Then we define a function ('read_and_modify') "
"and the no-password user becomes this function's creator. Finally, we grant "
"another user ('public_user') access to execute Lua functions created by the no-"
"password user."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:206
msgid ""
"box.schema.space.create('u')\n"
"box.schema.space.create('i')\n"
"box.space.u:create_index('pk')\n"
"box.space.i:create_index('pk')\n"
"\n"
"box.schema.user.create('internal')\n"
"\n"
"box.schema.user.grant('internal', 'read,write', 'space', 'u')\n"
"box.schema.user.grant('internal', 'read,write', 'space', 'i')\n"
"box.schema.user.grant('internal', 'read,write', 'space', '_func')\n"
"\n"
"function read_and_modify(key)\n"
"  local u = box.space.u\n"
"  local i = box.space.i\n"
"  local fiber = require('fiber')\n"
"  local t = u:get{key}\n"
"  if t ~= nil then\n"
"           u:put{key, box.session.uid()}\n"
"           i:put{key, fiber.time()}\n"
"  end\n"
"end\n"
"\n"
"box.session.su('internal')\n"
"box.schema.func.create('read_and_modify', {setuid= true})\n"
"box.session.su('admin')\n"
"box.schema.user.create('public_user', {password = 'secret'})\n"
"box.schema.user.grant('public_user', 'execute', 'function', 'read_and_modify')"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:240
msgid "Roles"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:242
msgid ""
"A **role** is a container for privileges which can be granted to regular users. "
"Instead of granting or revoking individual privileges, you can put all the "
"privileges in a role and then grant or revoke the role."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:246
msgid ""
"Role information is stored in the :ref:`_user <box_space-user>` space, but the "
"third field in the tuple -- the type field -- is ‘role’ rather than ‘user’."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:249
msgid ""
"An important feature in role management is that roles can be **nested**. For "
"example, role R1 can be granted a privilege \"role R2\", so users with the role "
"R1 will subsequently get all privileges from both roles R1 and R2. In other "
"words, a user gets all the privileges that are granted to a user’s roles, "
"directly or indirectly."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:257
msgid ""
"-- This example will work for a user with many privileges, such as 'admin'\n"
"-- Create space T with a primary index\n"
"box.schema.space.create('T')\n"
"box.space.T:create_index('primary', {})\n"
"-- Create user U1 so that later we can change the current user to U1\n"
"box.schema.user.create('U1')\n"
"-- Create two roles, R1 and R2\n"
"box.schema.role.create('R1')\n"
"box.schema.role.create('R2')\n"
"-- Grant role R2 to role R1 and role R1 to user U1 (order doesn't matter)\n"
"box.schema.role.grant('R1', 'execute', 'role', 'R2')\n"
"box.schema.user.grant('U1', 'execute', 'role', 'R1')\n"
"-- Grant read/write privileges for space T to role R2\n"
"-- (but not to role R1 and not to user U1)\n"
"box.schema.role.grant('R2', 'read,write', 'space', 'T')\n"
"-- Change the current user to user U1\n"
"box.session.su('U1')\n"
"-- An insertion to space T will now succeed because, due to nested roles,\n"
"-- user U1 has write privilege on space T\n"
"box.space.T:insert{1}"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:280
msgid ""
"For details about Tarantool functions related to role management, see reference "
"on :ref:`box.schema <box_schema>` submodule."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:287
msgid "Sessions and security"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:289
msgid "A **session** is the state of a connection to Tarantool. It contains:"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:291
msgid "an integer id identifying the connection,"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:292
msgid ""
"the :ref:`current user <authentication-users>` associated with the connection,"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:293
msgid "text description of the connected peer, and"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:294
msgid "session local state, such as Lua variables and functions."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:296
msgid ""
"In Tarantool, a single session can execute multiple concurrent transactions. "
"Each transaction is identified by a unique integer id, which can be queried at "
"start of the transaction using :ref:`box.session.sync() <box_session-sync>`."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:302
msgid ""
"To track all connects and disconnects, you can use :ref:`connection and "
"authentication triggers <triggers>`."
msgstr ""

#: ../doc/1.7/book/box/box_cfg.rst:39
msgid "Submodule `box.cfg`"
msgstr ""

#: ../doc/1.7/book/box/box_cfg.rst:43
msgid ""
"The ``box.cfg`` submodule is for administrators to specify all the server "
"configuration parameters (see \"Configuration reference\" for :ref:`a complete "
"description of all configuration parameters <box_cfg_params>`). Use ``box.cfg`` "
"without braces to get read-only access to those parameters."
msgstr ""

#: ../doc/1.7/book/box/box_cfg.rst:48 ../doc/1.7/book/box/box_index.rst:67
#: ../doc/1.7/book/box/box_index.rst:469 ../doc/1.7/book/box/box_index.rst:605
#: ../doc/1.7/book/box/box_index.rst:633 ../doc/1.7/book/box/box_index.rst:661
#: ../doc/1.7/book/box/box_index.rst:693 ../doc/1.7/book/box/box_index.rst:717
#: ../doc/1.7/book/box/box_index.rst:793 ../doc/1.7/book/box/box_index.rst:816
#: ../doc/1.7/book/box/box_index.rst:836 ../doc/1.7/book/box/box_info.rst:128
#: ../doc/1.7/book/box/box_schema.rst:209 ../doc/1.7/book/box/box_schema.rst:246
#: ../doc/1.7/book/box/box_schema.rst:279 ../doc/1.7/book/box/box_schema.rst:316
#: ../doc/1.7/book/box/box_schema.rst:338 ../doc/1.7/book/box/box_schema.rst:360
#: ../doc/1.7/book/box/box_schema.rst:383 ../doc/1.7/book/box/box_schema.rst:402
#: ../doc/1.7/book/box/box_schema.rst:417 ../doc/1.7/book/box/box_schema.rst:447
#: ../doc/1.7/book/box/box_schema.rst:477 ../doc/1.7/book/box/box_schema.rst:494
#: ../doc/1.7/book/box/box_schema.rst:531 ../doc/1.7/book/box/box_schema.rst:552
#: ../doc/1.7/book/box/box_schema.rst:568 ../doc/1.7/book/box/box_slab.rst:61
#: ../doc/1.7/book/box/box_slab.rst:120 ../doc/1.7/book/box/box_slab.rst:162
#: ../doc/1.7/book/box/box_space.rst:178 ../doc/1.7/book/box/box_space.rst:200
#: ../doc/1.7/book/box/box_space.rst:229 ../doc/1.7/book/box/box_space.rst:427
#: ../doc/1.7/book/box/box_space.rst:460 ../doc/1.7/book/box/box_space.rst:491
#: ../doc/1.7/book/box/box_space.rst:514 ../doc/1.7/book/box/box_space.rst:537
#: ../doc/1.7/book/box/box_space.rst:645 ../doc/1.7/book/box/box_space.rst:688
#: ../doc/1.7/book/box/box_space.rst:724 ../doc/1.7/book/box/box_space.rst:742
#: ../doc/1.7/book/box/box_space.rst:779 ../doc/1.7/book/box/box_space.rst:851
#: ../doc/1.7/book/box/box_space.rst:928 ../doc/1.7/book/box/box_space.rst:1033
#: ../doc/1.7/book/box/box_space.rst:1069 ../doc/1.7/book/box/box_space.rst:1088
#: ../doc/1.7/book/box/box_space.rst:1105 ../doc/1.7/book/box/box_space.rst:1156
#: ../doc/1.7/book/box/box_space.rst:1273 ../doc/1.7/book/box/box_space.rst:1495
#: ../doc/1.7/book/box/box_tuple.rst:69
#: ../doc/1.7/book/box/box_txn_management.rst:106
#: ../doc/1.7/dev_guide/documentation_guidelines.rst:245
#: ../doc/1.7/dev_guide/documentation_guidelines.rst:283
#: ../doc/1.7/dev_guide/reference_capi/coio.rst:80
#: ../doc/1.7/dev_guide/reference_capi/say.rst:86
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:267
#: ../doc/1.7/reference/reference_lua/box_error.rst:83
#: ../doc/1.7/reference/reference_lua/box_error.rst:121
#: ../doc/1.7/reference/reference_lua/box_snapshot.rst:79
#: ../doc/1.7/reference/reference_lua/buffer.rst:57
#: ../doc/1.7/reference/reference_lua/clock.rst:60
#: ../doc/1.7/reference/reference_lua/clock.rst:83
#: ../doc/1.7/reference/reference_lua/clock.rst:102
#: ../doc/1.7/reference/reference_lua/clock.rst:121
#: ../doc/1.7/reference/reference_lua/clock.rst:141
#: ../doc/1.7/reference/reference_lua/console.rst:79
#: ../doc/1.7/reference/reference_lua/console.rst:110
#: ../doc/1.7/reference/reference_lua/console.rst:135
#: ../doc/1.7/reference/reference_lua/console.rst:174
#: ../doc/1.7/reference/reference_lua/crypto.rst:73
#: ../doc/1.7/reference/reference_lua/crypto.rst:102
#: ../doc/1.7/reference/reference_lua/csv.rst:83
#: ../doc/1.7/reference/reference_lua/csv.rst:165
#: ../doc/1.7/reference/reference_lua/csv.rst:210
#: ../doc/1.7/reference/reference_lua/errno.rst:75
#: ../doc/1.7/reference/reference_lua/fiber.rst:112
#: ../doc/1.7/reference/reference_lua/fiber.rst:136
#: ../doc/1.7/reference/reference_lua/fiber.rst:156
#: ../doc/1.7/reference/reference_lua/fiber.rst:176
#: ../doc/1.7/reference/reference_lua/fiber.rst:191
#: ../doc/1.7/reference/reference_lua/fiber.rst:208
#: ../doc/1.7/reference/reference_lua/fiber.rst:227
#: ../doc/1.7/reference/reference_lua/fiber.rst:254
#: ../doc/1.7/reference/reference_lua/fiber.rst:271
#: ../doc/1.7/reference/reference_lua/fiber.rst:291
#: ../doc/1.7/reference/reference_lua/fiber.rst:312
#: ../doc/1.7/reference/reference_lua/fiber.rst:337
#: ../doc/1.7/reference/reference_lua/fiber.rst:357
#: ../doc/1.7/reference/reference_lua/fiber.rst:382
#: ../doc/1.7/reference/reference_lua/fiber.rst:402
#: ../doc/1.7/reference/reference_lua/fiber.rst:447
#: ../doc/1.7/reference/reference_lua/fiber.rst:466
#: ../doc/1.7/reference/reference_lua/fio.rst:70
#: ../doc/1.7/reference/reference_lua/fio.rst:90
#: ../doc/1.7/reference/reference_lua/fio.rst:108
#: ../doc/1.7/reference/reference_lua/fio.rst:132
#: ../doc/1.7/reference/reference_lua/fio.rst:165
#: ../doc/1.7/reference/reference_lua/fio.rst:203
#: ../doc/1.7/reference/reference_lua/fio.rst:224
#: ../doc/1.7/reference/reference_lua/fio.rst:239
#: ../doc/1.7/reference/reference_lua/fio.rst:252
#: ../doc/1.7/reference/reference_lua/fio.rst:276
#: ../doc/1.7/reference/reference_lua/fio.rst:299
#: ../doc/1.7/reference/reference_lua/fio.rst:318
#: ../doc/1.7/reference/reference_lua/fio.rst:341
#: ../doc/1.7/reference/reference_lua/fio.rst:357
#: ../doc/1.7/reference/reference_lua/fio.rst:392
#: ../doc/1.7/reference/reference_lua/fio.rst:414
#: ../doc/1.7/reference/reference_lua/fio.rst:437
#: ../doc/1.7/reference/reference_lua/fio.rst:467
#: ../doc/1.7/reference/reference_lua/fio.rst:485
#: ../doc/1.7/reference/reference_lua/fio.rst:508
#: ../doc/1.7/reference/reference_lua/fio.rst:526
#: ../doc/1.7/reference/reference_lua/fio.rst:558
#: ../doc/1.7/reference/reference_lua/fio.rst:578
#: ../doc/1.7/reference/reference_lua/http.rst:58
#: ../doc/1.7/reference/reference_lua/http.rst:161
#: ../doc/1.7/reference/reference_lua/iconv.rst:66
#: ../doc/1.7/reference/reference_lua/iconv.rst:85
#: ../doc/1.7/reference/reference_lua/json.rst:57
#: ../doc/1.7/reference/reference_lua/json.rst:95
#: ../doc/1.7/reference/reference_lua/json.rst:126
#: ../doc/1.7/reference/reference_lua/net_box.rst:182
#: ../doc/1.7/reference/reference_lua/net_box.rst:196
#: ../doc/1.7/reference/reference_lua/net_box.rst:209
#: ../doc/1.7/reference/reference_lua/net_box.rst:246
#: ../doc/1.7/reference/reference_lua/net_box.rst:257
#: ../doc/1.7/reference/reference_lua/net_box.rst:277
#: ../doc/1.7/reference/reference_lua/net_box.rst:288
#: ../doc/1.7/reference/reference_lua/net_box.rst:299
#: ../doc/1.7/reference/reference_lua/net_box.rst:310
#: ../doc/1.7/reference/reference_lua/net_box.rst:351
#: ../doc/1.7/reference/reference_lua/net_box.rst:365
#: ../doc/1.7/reference/reference_lua/osmodule.rst:64
#: ../doc/1.7/reference/reference_lua/osmodule.rst:87
#: ../doc/1.7/reference/reference_lua/osmodule.rst:106
#: ../doc/1.7/reference/reference_lua/osmodule.rst:123
#: ../doc/1.7/reference/reference_lua/osmodule.rst:141
#: ../doc/1.7/reference/reference_lua/osmodule.rst:156
#: ../doc/1.7/reference/reference_lua/osmodule.rst:169
#: ../doc/1.7/reference/reference_lua/osmodule.rst:184
#: ../doc/1.7/reference/reference_lua/osmodule.rst:199
#: ../doc/1.7/reference/reference_lua/osmodule.rst:214
#: ../doc/1.7/reference/reference_lua/osmodule.rst:229
#: ../doc/1.7/reference/reference_lua/osmodule.rst:245
#: ../doc/1.7/reference/reference_lua/osmodule.rst:260
#: ../doc/1.7/reference/reference_lua/other.rst:51
#: ../doc/1.7/reference/reference_lua/other.rst:89
#: ../doc/1.7/reference/reference_lua/pickle.rst:98
#: ../doc/1.7/reference/reference_lua/pickle.rst:143
#: ../doc/1.7/reference/reference_lua/socket.rst:147
#: ../doc/1.7/reference/reference_lua/socket.rst:165
#: ../doc/1.7/reference/reference_lua/socket.rst:184
#: ../doc/1.7/reference/reference_lua/socket.rst:256
#: ../doc/1.7/reference/reference_lua/socket.rst:412
#: ../doc/1.7/reference/reference_lua/strict.rst:52
#: ../doc/1.7/reference/reference_lua/string.rst:68
#: ../doc/1.7/reference/reference_lua/string.rst:93
#: ../doc/1.7/reference/reference_lua/string.rst:116
#: ../doc/1.7/reference/reference_lua/string.rst:146
#: ../doc/1.7/reference/reference_lua/string.rst:176
#: ../doc/1.7/reference/reference_lua/string.rst:203
#: ../doc/1.7/reference/reference_lua/tap.rst:103
#: ../doc/1.7/reference/reference_lua/tap.rst:145
#: ../doc/1.7/reference/reference_lua/tarantool.rst:54
#: ../doc/1.7/reference/reference_lua/uri.rst:61
#: ../doc/1.7/reference/reference_lua/uri.rst:84
#: ../doc/1.7/reference/reference_lua/xlog.rst:61
#: ../doc/1.7/reference/reference_rock/dbms.rst:222
#: ../doc/1.7/reference/reference_rock/dbms.rst:246
#: ../doc/1.7/reference/reference_rock/dbms.rst:270
#: ../doc/1.7/reference/reference_rock/dbms.rst:565
#: ../doc/1.7/reference/reference_rock/dbms.rst:589
#: ../doc/1.7/reference/reference_rock/dbms.rst:612
msgid "**Example:**"
msgstr ""

#: ../doc/1.7/book/box/box_cfg.rst:50
msgid ""
"tarantool> box.cfg\n"
"---\n"
"- checkpoint_count: 2\n"
"  too_long_threshold: 0.5\n"
"  slab_alloc_factor: 1.1\n"
"  memtx_max_tuple_size: 1048576\n"
"  background: false\n"
"  <...>\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:39
msgid "Submodule `box.index`"
msgstr "Вложенный модуль `box.index`"

#: ../doc/1.7/book/box/box_index.rst:41
msgid ""
"The ``box.index`` submodule provides read-only access for index definitions and "
"index keys. Indexes are contained in :samp:`box.space.{space-name}.index` array "
"within each space object. They provide an API for ordered iteration over tuples. "
"This API is a direct binding to corresponding methods of index objects of type "
"``box.index`` in the storage engine."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:53
msgid "True if the index is unique, false if the index is not unique."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst ../doc/1.7/book/box/box_info.rst
#: ../doc/1.7/book/box/box_schema.rst ../doc/1.7/book/box/box_session.rst
#: ../doc/1.7/book/box/box_slab.rst ../doc/1.7/book/box/box_space.rst
#: ../doc/1.7/book/box/box_tuple.rst
#: ../doc/1.7/dev_guide/documentation_guidelines.rst
#: ../doc/1.7/reference/reference_lua/buffer.rst
#: ../doc/1.7/reference/reference_lua/clock.rst
#: ../doc/1.7/reference/reference_lua/csv.rst
#: ../doc/1.7/reference/reference_lua/errno.rst
#: ../doc/1.7/reference/reference_lua/fiber.rst
#: ../doc/1.7/reference/reference_lua/fio.rst
#: ../doc/1.7/reference/reference_lua/http.rst
#: ../doc/1.7/reference/reference_lua/iconv.rst
#: ../doc/1.7/reference/reference_lua/json.rst
#: ../doc/1.7/reference/reference_lua/msgpack.rst
#: ../doc/1.7/reference/reference_lua/net_box.rst
#: ../doc/1.7/reference/reference_lua/pickle.rst
#: ../doc/1.7/reference/reference_lua/socket.rst
#: ../doc/1.7/reference/reference_lua/tap.rst
#: ../doc/1.7/reference/reference_lua/uri.rst
#: ../doc/1.7/reference/reference_lua/uuid.rst
#: ../doc/1.7/reference/reference_lua/xlog.rst
#: ../doc/1.7/reference/reference_lua/yaml.rst
msgid "rtype"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:55 ../doc/1.7/book/box/box_schema.rst:71
#: ../doc/1.7/book/box/box_schema.rst:89 ../doc/1.7/book/box/box_space.rst:274
#: ../doc/1.7/book/box/box_space.rst:276 ../doc/1.7/book/box/data_model.rst:189
#: ../doc/1.7/reference/reference_lua/fiber.rst:586
#: ../doc/1.7/reference/reference_lua/fiber.rst:612
#: ../doc/1.7/reference/reference_lua/fiber.rst:628
#: ../doc/1.7/reference/reference_lua/fiber.rst:636
#: ../doc/1.7/reference/reference_lua/fiber.rst:644
#: ../doc/1.7/reference/reference_lua/fiber.rst:650
#: ../doc/1.7/reference/reference_lua/fiber.rst:758
#: ../doc/1.7/reference/reference_lua/fio.rst:201
#: ../doc/1.7/reference/reference_lua/fio.rst:297
#: ../doc/1.7/reference/reference_lua/fio.rst:339
#: ../doc/1.7/reference/reference_lua/fio.rst:355
#: ../doc/1.7/reference/reference_lua/fio.rst:412
#: ../doc/1.7/reference/reference_lua/fio.rst:483
#: ../doc/1.7/reference/reference_lua/net_box.rst:180
#: ../doc/1.7/reference/reference_lua/net_box.rst:194
#: ../doc/1.7/reference/reference_lua/net_box.rst:207
#: ../doc/1.7/reference/reference_lua/net_box.rst:222
#: ../doc/1.7/reference/reference_lua/socket.rst:254
#: ../doc/1.7/reference/reference_lua/socket.rst:433
#: ../doc/1.7/reference/reference_lua/socket.rst:444
#: ../doc/1.7/reference/reference_lua/string.rst:141
#: ../doc/1.7/reference/reference_lua/string.rst:171
#: ../doc/1.7/reference/reference_lua/tap.rst:101
#: ../doc/1.7/reference/reference_lua/tap.rst:133
#: ../doc/1.7/reference/reference_lua/tap.rst:164
#: ../doc/1.7/reference/reference_lua/tap.rst:175
#: ../doc/1.7/reference/reference_lua/tap.rst:192
#: ../doc/1.7/reference/reference_lua/tap.rst:200
msgid "boolean"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:59
msgid "Index type, 'TREE' or 'HASH' or 'BITSET' or 'RTREE'."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:63
msgid "An array describing index key fields."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:65 ../doc/1.7/book/box/box_info.rst:126
#: ../doc/1.7/book/box/box_schema.rst:102 ../doc/1.7/book/box/box_slab.rst:59
#: ../doc/1.7/book/box/box_slab.rst:118 ../doc/1.7/book/box/box_slab.rst:160
#: ../doc/1.7/book/box/box_space.rst:1103
#: ../doc/1.7/reference/reference_lua/csv.rst:81
#: ../doc/1.7/reference/reference_lua/fiber.rst:225
#: ../doc/1.7/reference/reference_lua/fio.rst:150
#: ../doc/1.7/reference/reference_lua/fio.rst:220
#: ../doc/1.7/reference/reference_lua/fio.rst:524
#: ../doc/1.7/reference/reference_lua/http.rst:123
#: ../doc/1.7/reference/reference_lua/json.rst:93
#: ../doc/1.7/reference/reference_lua/pickle.rst:141
#: ../doc/1.7/reference/reference_lua/socket.rst:182
#: ../doc/1.7/reference/reference_lua/socket.rst:556
#: ../doc/1.7/reference/reference_lua/socket.rst:568
#: ../doc/1.7/reference/reference_lua/string.rst:201
#: ../doc/1.7/reference/reference_lua/yaml.rst:60
msgid "table"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:69
msgid ""
"tarantool> box.space.tester.index.primary\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: unsigned\n"
"    fieldno: 1\n"
"  id: 0\n"
"  space_id: 513\n"
"  name: primary\n"
"  type: TREE\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:87
msgid ""
"Search for a tuple or a set of tuples via the given index, and allow iterating "
"over one tuple at a time."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:90
msgid ""
"The :samp:`{key}` parameter specifies what must match within the index. The :"
"samp:`{iterator}` parameter specifies the rule for matching and ordering. "
"Different index types support different iterators. For example, a TREE index "
"maintains a strict order of keys and can return all tuples in ascending or "
"descending order, starting from the specified key. Other index types, however, "
"do not support ordering."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:97
msgid ""
"To understand consistency of tuples returned by an iterator, it's essential to "
"know the principles of the Tarantool transaction processing subsystem. An "
"iterator in Tarantool does not own a consistent read view. Instead, each "
"procedure is granted exclusive access to all tuples and spaces until there is a "
"\"context switch\": which may happen due to :ref:`the implicit yield rules "
"<atomic-implicit-yields>`, or by an explicit call to :ref:`fiber.yield <fiber-"
"yield>`. When the execution flow returns to the yielded procedure, the data set "
"could have changed significantly. Iteration, resumed after a yield point, does "
"not preserve the read view, but continues with the new content of the database. "
"The tutorial :ref:`Indexed pattern search <c_lua_tutorial-"
"indexed_pattern_search>` shows one way that iterators and yields can be used "
"together."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst ../doc/1.7/book/box/box_schema.rst
#: ../doc/1.7/book/box/box_session.rst ../doc/1.7/book/box/box_space.rst
#: ../doc/1.7/book/box/box_tuple.rst
#: ../doc/1.7/dev_guide/documentation_guidelines.rst
#: ../doc/1.7/dev_guide/reference_capi/box.rst
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst
#: ../doc/1.7/dev_guide/reference_capi/coio.rst
#: ../doc/1.7/dev_guide/reference_capi/error.rst
#: ../doc/1.7/dev_guide/reference_capi/fiber.rst
#: ../doc/1.7/dev_guide/reference_capi/latch.rst
#: ../doc/1.7/dev_guide/reference_capi/say.rst
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst
#: ../doc/1.7/dev_guide/reference_capi/utils.rst
#: ../doc/1.7/reference/reference_lua/box_error.rst
#: ../doc/1.7/reference/reference_lua/box_once.rst
#: ../doc/1.7/reference/reference_lua/clock.rst
#: ../doc/1.7/reference/reference_lua/console.rst
#: ../doc/1.7/reference/reference_lua/csv.rst
#: ../doc/1.7/reference/reference_lua/debug_facilities.rst
#: ../doc/1.7/reference/reference_lua/errno.rst
#: ../doc/1.7/reference/reference_lua/fiber.rst
#: ../doc/1.7/reference/reference_lua/fio.rst
#: ../doc/1.7/reference/reference_lua/http.rst
#: ../doc/1.7/reference/reference_lua/iconv.rst
#: ../doc/1.7/reference/reference_lua/json.rst
#: ../doc/1.7/reference/reference_lua/log.rst
#: ../doc/1.7/reference/reference_lua/msgpack.rst
#: ../doc/1.7/reference/reference_lua/net_box.rst
#: ../doc/1.7/reference/reference_lua/osmodule.rst
#: ../doc/1.7/reference/reference_lua/other.rst
#: ../doc/1.7/reference/reference_lua/pickle.rst
#: ../doc/1.7/reference/reference_lua/socket.rst
#: ../doc/1.7/reference/reference_lua/string.rst
#: ../doc/1.7/reference/reference_lua/tap.rst
#: ../doc/1.7/reference/reference_lua/uri.rst
#: ../doc/1.7/reference/reference_lua/uuid.rst
#: ../doc/1.7/reference/reference_lua/yaml.rst
msgid "Parameters"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:111 ../doc/1.7/book/box/box_index.rst:458
#: ../doc/1.7/book/box/box_index.rst:593 ../doc/1.7/book/box/box_index.rst:620
#: ../doc/1.7/book/box/box_index.rst:648 ../doc/1.7/book/box/box_index.rst:679
#: ../doc/1.7/book/box/box_index.rst:709 ../doc/1.7/book/box/box_index.rst:738
#: ../doc/1.7/book/box/box_index.rst:759 ../doc/1.7/book/box/box_index.rst:777
#: ../doc/1.7/book/box/box_index.rst:808 ../doc/1.7/book/box/box_index.rst:828
#: ../doc/1.7/book/box/box_index.rst:850
msgid "an :ref:`object reference <app_server-object_reference>`."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:113 ../doc/1.7/book/box/box_space.rst:627
msgid "value to be matched against the index key, which may be multi-part"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:115
msgid "as defined in tables below. The default iterator type is 'EQ'"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst ../doc/1.7/book/box/box_info.rst
#: ../doc/1.7/book/box/box_schema.rst ../doc/1.7/book/box/box_session.rst
#: ../doc/1.7/book/box/box_slab.rst ../doc/1.7/book/box/box_space.rst
#: ../doc/1.7/book/box/box_tuple.rst
#: ../doc/1.7/dev_guide/documentation_guidelines.rst
#: ../doc/1.7/reference/reference_lua/buffer.rst
#: ../doc/1.7/reference/reference_lua/clock.rst
#: ../doc/1.7/reference/reference_lua/console.rst
#: ../doc/1.7/reference/reference_lua/csv.rst
#: ../doc/1.7/reference/reference_lua/debug_facilities.rst
#: ../doc/1.7/reference/reference_lua/fiber.rst
#: ../doc/1.7/reference/reference_lua/fio.rst
#: ../doc/1.7/reference/reference_lua/http.rst
#: ../doc/1.7/reference/reference_lua/iconv.rst
#: ../doc/1.7/reference/reference_lua/json.rst
#: ../doc/1.7/reference/reference_lua/log.rst
#: ../doc/1.7/reference/reference_lua/msgpack.rst
#: ../doc/1.7/reference/reference_lua/net_box.rst
#: ../doc/1.7/reference/reference_lua/other.rst
#: ../doc/1.7/reference/reference_lua/pickle.rst
#: ../doc/1.7/reference/reference_lua/socket.rst
#: ../doc/1.7/reference/reference_lua/tap.rst
#: ../doc/1.7/reference/reference_lua/uuid.rst
#: ../doc/1.7/reference/reference_lua/yaml.rst
msgid "return"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:119 ../doc/1.7/book/box/box_space.rst:632
msgid ""
"`iterator <https://www.lua.org/pil/7.1.html>`_ which can be used in a for/end "
"loop or with `totable() <https://rtsisyk.github.io/luafun/reducing.html#fun."
"totable>`_"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:123
msgid ""
"**Possible errors:** No such space; wrong type; Selected iteration type is not "
"supported for the index type; or key is not supported for the iteration type."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:127
msgid "**Complexity factors:** Index size, Index type; Number of tuples accessed."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:130
msgid ""
"A search-key-value can be a number (for example ``1234``), a string (for example "
"``'abcd'``), or a table of numbers and strings (for example ``{1234, 'abcd'}``). "
"Each part of a key will be compared to each part of an index key."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:137
msgid "**Iterator types for TREE indexes**"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:146 ../doc/1.7/book/box/box_index.rst:246
#: ../doc/1.7/book/box/box_index.rst:280 ../doc/1.7/book/box/box_index.rst:316
#: ../doc/1.7/book/box/box_schema.rst:69 ../doc/1.7/book/box/box_space.rst:266
#: ../doc/1.7/book/box/box_space.rst:1407
msgid "Type"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:146 ../doc/1.7/book/box/box_index.rst:246
#: ../doc/1.7/book/box/box_index.rst:280 ../doc/1.7/book/box/box_index.rst:316
msgid "Arguments"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:146 ../doc/1.7/book/box/box_index.rst:246
#: ../doc/1.7/book/box/box_index.rst:280 ../doc/1.7/book/box/box_index.rst:316
#: ../doc/1.7/book/box/box_space.rst:1407
msgid "Description"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:148 ../doc/1.7/book/box/box_index.rst:253
#: ../doc/1.7/book/box/box_index.rst:286 ../doc/1.7/book/box/box_index.rst:321
msgid "box.index.EQ or 'EQ'"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:148 ../doc/1.7/book/box/box_index.rst:154
#: ../doc/1.7/book/box/box_index.rst:159 ../doc/1.7/book/box/box_index.rst:166
#: ../doc/1.7/book/box/box_index.rst:173 ../doc/1.7/book/box/box_index.rst:177
#: ../doc/1.7/book/box/box_index.rst:183 ../doc/1.7/book/box/box_index.rst:253
#: ../doc/1.7/book/box/box_index.rst:259 ../doc/1.7/book/box/box_index.rst:321
#: ../doc/1.7/book/box/box_index.rst:329 ../doc/1.7/book/box/box_index.rst:334
#: ../doc/1.7/book/box/box_index.rst:339 ../doc/1.7/book/box/box_index.rst:344
#: ../doc/1.7/book/box/box_index.rst:354
msgid "search value"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:148
msgid ""
"The comparison operator is '==' (equal to). If an index key is equal to a search "
"value, it matches. Tuples are returned in ascending order by index key. This is "
"the default."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:154
msgid "box.index.REQ or 'REQ'"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:154
msgid ""
"Matching is the same as for ``box.index.EQ``. Tuples are returned in descending "
"order by index key."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:159 ../doc/1.7/book/box/box_index.rst:259
#: ../doc/1.7/book/box/box_index.rst:329
msgid "box.index.GT or 'GT'"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:159
msgid ""
"The comparison operator is '>' (greater than). If an index key is greater than a "
"search value, it matches. Tuples are returned in ascending order by index key."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:166 ../doc/1.7/book/box/box_index.rst:334
msgid "box.index.GE or 'GE'"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:166
msgid ""
"The comparison operator is '>=' (greater than or equal to). If an index key is "
"greater than or equal to a search value, it matches. Tuples are returned in "
"ascending order by index key."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:173 ../doc/1.7/book/box/box_index.rst:282
#: ../doc/1.7/book/box/box_index.rst:318
msgid "box.index.ALL or 'ALL'"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:173
msgid "Same as box.index.GE."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:177 ../doc/1.7/book/box/box_index.rst:339
msgid "box.index.LT or 'LT'"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:177
msgid ""
"The comparison operator is '<' (less than). If an index key is less than a "
"search value, it matches. Tuples are returned in descending order by index key."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:183 ../doc/1.7/book/box/box_index.rst:344
msgid "box.index.LE or 'LE'"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:183
msgid ""
"The comparison operator is '<=' (less than or equal to). If an index key is less "
"than or equal to a search value, it matches. Tuples are returned in descending "
"order by index key."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:192
msgid ""
"Informally, we can state that searches with TREE indexes are generally what "
"users will find is intuitive, provided that there are no nils and no missing "
"parts. Formally, the logic is as follows. A search key has zero or more parts, "
"for example {}, {1,2,3},{1,nil,3}. An index key has one or more parts, for "
"example {1}, {1,2,3},{1,2,3}. A search key may contain nil (but not msgpack."
"NULL, which is the wrong type). An index key may not contain nil or msgpack."
"NULL, although a later version of Tarantool will have different rules --  the "
"behavior of searches with nil is subject to change. Possible iterators are LT, "
"LE, EQ, REQ, GE, GT. A search key is said to \"match\" an index key if the "
"following statements, which are pseudocode for the comparison operation, return "
"TRUE."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:239
msgid "**Iterator types for HASH indexes**"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:248
msgid "box.index.ALL"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:248 ../doc/1.7/book/box/box_index.rst:282
#: ../doc/1.7/book/box/box_index.rst:318
msgid "none"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:248
msgid ""
"All index keys match. Tuples are returned in ascending order by hash of index "
"key, which will appear to be random."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:253
msgid ""
"The comparison operator is '==' (equal to). If an index key is equal to a search "
"value, it matches. The number of returned tuples will be 0 or 1. This is the "
"default."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:259
msgid ""
"The comparison operator is '>' (greater than). If a hash of an index key is "
"greater than a hash of a search value, it matches. Tuples are returned in "
"ascending order by hash of index key, which will appear to be random. Provided "
"that the space is not being updated, one can retrieve all the tuples in a space, "
"N tuples at a time, by using {iterator='GT', limit=N} in each search, and using "
"the last returned value from the previous result as the start search value for "
"the next search."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:273
msgid "**Iterator types for BITSET indexes**"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:282
msgid "All index keys match. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:286 ../doc/1.7/book/box/box_index.rst:291
#: ../doc/1.7/book/box/box_index.rst:296 ../doc/1.7/book/box/box_index.rst:301
msgid "bitset value"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:286
msgid ""
"If an index key is equal to a bitset value, it matches. Tuples are returned in "
"their order within the space. This is the default."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:291
msgid "box.index.BITS_ALL_SET"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:291
msgid ""
"If all of the bits which are 1 in the bitset value are 1 in the index key, it "
"matches. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:296
msgid "box.index.BITS_ANY_SET"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:296
msgid ""
"If any of the bits which are 1 in the bitset value are 1 in the index key, it "
"matches. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:301
msgid "box.index.BITS_ALL_NOT_SET"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:301
msgid ""
"If all of the bits which are 1 in the bitset value are 0 in the index key, it "
"matches. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:309
msgid "**Iterator types for RTREE indexes**"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:318
msgid "All keys match. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:321
msgid ""
"If all points of the rectangle-or-box defined by the search value are the same "
"as the rectangle-or-box defined by the index key, it matches. Tuples are "
"returned in their order within the space. \"Rectangle-or-box\" means \"rectangle-"
"or-box as explained in section about :ref:`RTREE <box_index-rtree>`\". This is "
"the default."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:329
msgid ""
"If all points of the rectangle-or-box defined by the search value are within the "
"rectangle-or-box defined by the index key, it matches. Tuples are returned in "
"their order within the space."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:334
msgid ""
"If all points of the rectangle-or-box defined by the search value are within, or "
"at the side of, the rectangle-or-box defined by the index key, it matches. "
"Tuples are returned in their order within the space."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:339
msgid ""
"If all points of the rectangle-or-box defined by the index key are within the "
"rectangle-or-box defined by the search key, it matches. Tuples are returned in "
"their order within the space."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:344
msgid ""
"If all points of the rectangle-or-box defined by the index key are within, or at "
"the side of, the rectangle-or-box defined by the search key, it matches. Tuples "
"are returned in their order within the space."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:349
msgid "box.index.OVERLAPS or 'OVERLAPS'"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:349
msgid "search values"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:349
msgid ""
"If some points of the rectangle-or-box defined by the search value are within "
"the rectangle-or-box defined by the index key, it matches. Tuples are returned "
"in their order within the space."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:354
msgid "box.index.NEIGHBOR or 'NEIGHBOR'"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:354
msgid ""
"If some points of the rectangle-or-box defined by the defined by the key are "
"within, or at the side of, defined by the index key, it matches. Tuples are "
"returned in order: nearest neighbor first."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:360
msgid "**First Example of index pairs():**"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:362
msgid "Default 'TREE' Index and ``pairs()`` function:"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:364
msgid ""
"tarantool> s = box.schema.space.create('space17')\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {\n"
"         >   parts = {1, 'string', 2, 'string'}\n"
"         > })\n"
"---\n"
"...\n"
"tarantool> s:insert{'C', 'C'}\n"
"---\n"
"- ['C', 'C']\n"
"...\n"
"tarantool> s:insert{'B', 'A'}\n"
"---\n"
"- ['B', 'A']\n"
"...\n"
"tarantool> s:insert{'C', '!'}\n"
"---\n"
"- ['C', '!']\n"
"...\n"
"tarantool> s:insert{'A', 'C'}\n"
"---\n"
"- ['A', 'C']\n"
"...\n"
"tarantool> function example()\n"
"         >   for _, tuple in\n"
"         >     s.index.primary:pairs(nil, {\n"
"         >         iterator = box.index.ALL}) do\n"
"         >       print(tuple)\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> example()\n"
"['A', 'C']\n"
"['B', 'A']\n"
"['C', '!']\n"
"['C', 'C']\n"
"---\n"
"...\n"
"tarantool> s:drop()\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:410
msgid "**Second Example of index pairs():**"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:412
msgid ""
"This Lua code finds all the tuples whose primary key values begin with 'XY'. The "
"assumptions include that there is a one-part primary-key TREE index on the first "
"field, which must be a string. The iterator loop ensures that the search will "
"return tuples where the first value is greater than or equal to 'XY'. The "
"conditional statement within the loop ensures that the looping will stop when "
"the first two letters are not 'XY'."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:420
msgid ""
"for _, tuple in\n"
"box.space.t.index.primary:pairs(\"XY\",{iterator = \"GE\"}) do\n"
"  if (string.sub(tuple[1], 1, 2) ~= \"XY\") then break end\n"
"  print(tuple)\n"
"end"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:428
msgid "**Third Example of index pairs():**"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:430
msgid ""
"This Lua code finds all the tuples whose primary key values are greater than or "
"equal to 1000, and less than or equal to 1999 (this type of request is sometimes "
"called a \"range search\" or a \"between search\"). The assumptions include that "
"there is a one-part primary-key TREE index on the first field, which must be a :"
"ref:`number <index-box_number>`. The iterator loop ensures that the search will "
"return tuples where the first value is greater than or equal to 1000. The "
"conditional statement within the loop ensures that the looping will stop when "
"the first value is greater than 1999."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:440
msgid ""
"for _, tuple in\n"
"box.space.t2.index.primary:pairs(1000,{iterator = \"GE\"}) do\n"
"  if (tuple[1] > 1999) then break end\n"
"  print(tuple)\n"
"end"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:452
msgid ""
"This is an alternative to :ref:`box.space...select() <box_space-select>` which "
"goes via a particular index and can make use of additional parameters that "
"specify the iterator type, and the limit (that is, the maximum number of tuples "
"to return) and the offset (that is, which tuple to start with in the list)."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:460 ../doc/1.7/book/box/box_index.rst:595
#: ../doc/1.7/book/box/box_index.rst:622 ../doc/1.7/book/box/box_index.rst:650
#: ../doc/1.7/book/box/box_index.rst:711 ../doc/1.7/book/box/box_index.rst:740
#: ../doc/1.7/book/box/box_index.rst:761
msgid "values to be matched against the index key"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:461
msgid "none, any or all of next parameters"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:462
msgid "type of iterator"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:463
msgid "maximum number of tuples"
msgstr "максимальное количество таплов"

#: ../doc/1.7/book/box/box_index.rst:464
msgid "start tuple number"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:466
msgid "the tuple or tuples that match the field values."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:467 ../doc/1.7/book/box/box_space.rst:773
msgid "array of tuples"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:471
msgid ""
"-- Create a space named tester.\n"
"tarantool> sp = box.schema.space.create('tester')\n"
"-- Create a unique index 'primary'\n"
"-- which won't be needed for this example.\n"
"tarantool> sp:create_index('primary', {parts = {1, 'unsigned' }})\n"
"-- Create a non-unique index 'secondary'\n"
"-- with an index on the second field.\n"
"tarantool> sp:create_index('secondary', {\n"
"         >   type = 'tree',\n"
"         >   unique = false,\n"
"         >   parts = {2, 'string'}\n"
"         > })\n"
"-- Insert three tuples, values in field[2]\n"
"-- equal to 'X', 'Y', and 'Z'.\n"
"tarantool> sp:insert{1, 'X', 'Row with field[2]=X'}\n"
"tarantool> sp:insert{2, 'Y', 'Row with field[2]=Y'}\n"
"tarantool> sp:insert{3, 'Z', 'Row with field[2]=Z'}\n"
"-- Select all tuples where the secondary index\n"
"-- keys are greater than 'X'.`\n"
"tarantool> sp.index.secondary:select({'X'}, {\n"
"         >   iterator = 'GT',\n"
"         >   limit = 1000\n"
"         > })"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:497
msgid "The result will be a table of tuple and will look like this:"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:499
msgid ""
"---\n"
"- - [2, 'Y', 'Row with field[2]=Y']\n"
"  - [3, 'Z', 'Row with field[2]=Z']\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:508
msgid ""
":samp:`index.{index-name}` is optional. If it is omitted, then the assumed index "
"is the first (primary-key) index. Therefore, for the example above, ``box.space."
"tester:select({1}, {iterator = 'GT'})`` would have returned the same two rows, "
"via the 'primary' index."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:515
msgid ""
":samp:`iterator = {iterator-type}` is optional. If it is omitted, then "
"``iterator = 'EQ'`` is assumed."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:520
msgid ""
":samp:`{field-value} [, {field-value ...}]` is optional. If it is omitted, then "
"every key in the index is considered to be a match, regardless of iterator type. "
"Therefore, for the example above, ``box.space.tester:select{}`` will select "
"every tuple in the tester space via the first (primary-key) index."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:530
msgid ""
":samp:`box.space.{space-name}.index.{index-name}:select(...)[1]``. can be "
"replaced by :samp:`box.space.{space-name}.index.{index-name}:get(...)`. That is, "
"``get`` can be used as a convenient shorthand to get the first tuple in the "
"tuple set that would be returned by ``select``. However, if there is more than "
"one tuple in the tuple set, then ``get`` returns an error."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:538
msgid "**Example with BITSET index:**"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:540
msgid ""
"The following script shows creation and search with a BITSET index. Notice: "
"BITSET cannot be unique, so first a primary-key index is created. Notice: bit "
"values are entered as hexadecimal literals for easier reading."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:544
msgid ""
"tarantool> s = box.schema.space.create('space_with_bitset')\n"
"tarantool> s:create_index('primary_index', {\n"
"         >   parts = {1, 'string'},\n"
"         >   unique = true,\n"
"         >   type = 'TREE'\n"
"         > })\n"
"tarantool> s:create_index('bitset_index', {\n"
"         >   parts = {2, 'unsigned'},\n"
"         >   unique = false,\n"
"         >   type = 'BITSET'\n"
"         > })\n"
"tarantool> s:insert{'Tuple with bit value = 01', 0x01}\n"
"tarantool> s:insert{'Tuple with bit value = 10', 0x02}\n"
"tarantool> s:insert{'Tuple with bit value = 11', 0x03}\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.EQ\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ANY_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_NOT_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 01', 1]\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:591
msgid ""
"Search for a tuple via the given index, as described :ref:`earlier <box_index-"
"note>`."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:597
msgid "the tuple whose index-key fields are equal to the passed key values."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:598 ../doc/1.7/book/box/box_index.rst:627
#: ../doc/1.7/book/box/box_index.rst:655 ../doc/1.7/book/box/box_index.rst:684
#: ../doc/1.7/book/box/box_index.rst:749 ../doc/1.7/book/box/box_index.rst:764
#: ../doc/1.7/book/box/box_space.rst:171 ../doc/1.7/book/box/box_space.rst:418
#: ../doc/1.7/book/box/box_space.rst:478 ../doc/1.7/book/box/box_space.rst:509
#: ../doc/1.7/book/box/box_space.rst:715 ../doc/1.7/book/box/box_space.rst:909
#: ../doc/1.7/book/box/box_tuple.rst:63 ../doc/1.7/book/box/box_tuple.rst:209
#: ../doc/1.7/book/box/box_tuple.rst:210 ../doc/1.7/book/box/box_tuple.rst:329
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:248
msgid "tuple"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:600
msgid ""
"**Possible errors:** No such index; wrong type; more than one tuple matches."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:602
msgid ""
"**Complexity factors:** Index size, Index type. See also :ref:`space_object:"
"get() <box_space-get>`."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:607
msgid ""
"tarantool> box.space.tester.index.primary:get(2)\n"
"---\n"
"- [2, 'Music']\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:618
msgid "Find the minimum value in the specified index."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:624
msgid ""
"the tuple for the first key in the index. If optional ``key-value`` is supplied, "
"returns the first key which is greater than or equal to ``key-value``."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:629 ../doc/1.7/book/box/box_index.rst:657
msgid "**Possible errors:** index is not of type 'TREE'."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:631 ../doc/1.7/book/box/box_index.rst:659
#: ../doc/1.7/book/box/box_index.rst:686 ../doc/1.7/book/box/box_space.rst:638
#: ../doc/1.7/book/box/box_space.rst:777
msgid "**Complexity factors:** Index size, Index type."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:635
msgid ""
"tarantool> box.space.tester.index.primary:min()\n"
"---\n"
"- ['Alpha!', 55, 'This is the first tuple!']\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:646
msgid "Find the maximum value in the specified index."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:652
msgid ""
"the tuple for the last key in the index. If optional ``key-value`` is supplied, "
"returns the last key which is less than or equal to ``key-value``."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:663
msgid ""
"tarantool> box.space.tester.index.primary:max()\n"
"---\n"
"- ['Gamma!', 55, 'This is the third tuple!']\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:674
msgid ""
"Find a random value in the specified index. This method is useful when it's "
"important to get insight into data distribution in an index without having to "
"iterate over the entire data set."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:681
msgid "an arbitrary non-negative integer"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:683
msgid "the tuple for the random key in the index."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst ../doc/1.7/book/box/box_space.rst
msgid "Note re storage engine:"
msgstr "Примечание:"

#: ../doc/1.7/book/box/box_index.rst
msgid "vinyl does not support ``random()``."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:695
msgid ""
"tarantool> box.space.tester.index.secondary:random(1)\n"
"---\n"
"- ['Beta!', 66, 'This is the second tuple!']\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:706
msgid ""
"Iterate over an index, counting the number of tuples which match the key-value."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:712 ../doc/1.7/book/box/box_space.rst:225
msgid "comparison method"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:714
msgid "the number of matching index keys."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:715 ../doc/1.7/book/box/box_index.rst:854
#: ../doc/1.7/book/box/box_schema.rst:79 ../doc/1.7/book/box/box_schema.rst:83
#: ../doc/1.7/book/box/box_session.rst:52 ../doc/1.7/book/box/box_session.rst:57
#: ../doc/1.7/book/box/box_session.rst:83 ../doc/1.7/book/box/box_space.rst:272
#: ../doc/1.7/book/box/box_space.rst:283 ../doc/1.7/book/box/box_space.rst:288
#: ../doc/1.7/book/box/box_space.rst:290 ../doc/1.7/book/box/box_space.rst:292
#: ../doc/1.7/book/box/box_space.rst:294 ../doc/1.7/book/box/box_space.rst:296
#: ../doc/1.7/book/box/box_tuple.rst:95 ../doc/1.7/book/box/box_tuple.rst:122
#: ../doc/1.7/book/box/box_tuple.rst:171
#: ../doc/1.7/reference/reference_lua/fiber.rst:289
#: ../doc/1.7/reference/reference_lua/fiber.rst:619
#: ../doc/1.7/reference/reference_lua/fio.rst:130
#: ../doc/1.7/reference/reference_lua/fio.rst:504
#: ../doc/1.7/reference/reference_lua/socket.rst:273
#: ../doc/1.7/reference/reference_lua/socket.rst:396
msgid "number"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:719
msgid ""
"tarantool> box.space.tester.index.primary:count(999)\n"
"---\n"
"- 0\n"
"...\n"
"tarantool> box.space.tester.index.primary:count('Alpha!', { iterator = 'LE' })\n"
"---\n"
"- 1\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:732 ../doc/1.7/book/box/box_space.rst:867
#: ../doc/1.7/book/box/box_tuple.rst:310
msgid "Update a tuple."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:734
msgid ""
"Same as :ref:`box.space...update() <box_space-update>`, but key is searched in "
"this index instead of primary key. This index ought to be unique."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:741 ../doc/1.7/book/box/box_space.rst:901
#: ../doc/1.7/book/box/box_space.rst:1018
msgid "operation type represented in string"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:742 ../doc/1.7/book/box/box_space.rst:902
#: ../doc/1.7/book/box/box_space.rst:1019 ../doc/1.7/book/box/box_tuple.rst:322
msgid ""
"what field the operation will apply to. The field number can be negative, "
"meaning the position from the end of tuple. (#tuple + negative field number + 1)"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:746 ../doc/1.7/book/box/box_space.rst:906
#: ../doc/1.7/book/box/box_space.rst:1023 ../doc/1.7/book/box/box_tuple.rst:326
msgid "what value will be applied"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:748 ../doc/1.7/book/box/box_space.rst:908
msgid "the updated tuple."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:753
msgid "Delete a tuple identified by a key."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:755
msgid ""
"Same as :ref:`box.space...delete() <box_space-delete>`, but key is searched in "
"this index instead of in the primary-key index. This index ought to be unique."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:763
msgid "the deleted tuple."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst
msgid "vinyl will return `nil`, rather than the deleted tuple."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:775
msgid "Alter an index."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:779
msgid ""
"options list, same as the options list for :ref:`create_index <box_space-"
"create_index>`"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:782 ../doc/1.7/book/box/box_index.rst:832
#: ../doc/1.7/book/box/box_schema.rst:167 ../doc/1.7/book/box/box_schema.rst:381
#: ../doc/1.7/book/box/box_schema.rst:529 ../doc/1.7/book/box/box_space.rst:453
#: ../doc/1.7/book/box/box_space.rst:684 ../doc/1.7/book/box/box_space.rst:740
#: ../doc/1.7/book/box/box_space.rst:842 ../doc/1.7/book/box/data_model.rst:187
#: ../doc/1.7/dev_guide/documentation_guidelines.rst:279
#: ../doc/1.7/reference/reference_lua/console.rst:74
#: ../doc/1.7/reference/reference_lua/fiber.rst:335
#: ../doc/1.7/reference/reference_lua/fiber.rst:378
#: ../doc/1.7/reference/reference_lua/fiber.rst:765
#: ../doc/1.7/reference/reference_lua/fiber.rst:771
#: ../doc/1.7/reference/reference_lua/log.rst:90
#: ../doc/1.7/reference/reference_lua/msgpack.rst:183
#: ../doc/1.7/reference/reference_lua/tap.rst:71
#: ../doc/1.7/reference/reference_lua/tap.rst:82
#: ../doc/1.7/reference/reference_lua/tap.rst:89
#: ../doc/1.7/reference/reference_lua/tap.rst:143
msgid "nil"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:784
msgid ""
"**Possible errors:** Index does not exist, or the first index cannot be changed "
"to {unique = false}, or the alter function is only applicable for the memtx "
"storage engine."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst
msgid "vinyl does not support ``alter()``."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:795
msgid ""
"tarantool> box.space.space55.index.primary:alter({type = 'HASH'})\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:805
msgid ""
"Drop an index. Dropping a primary-key index has a side effect: all tuples are "
"deleted."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:811
msgid "nil."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:813
msgid ""
"**Possible errors:** Index does not exist, or a primary-key index cannot be "
"dropped while a secondary-key index exists."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:818
msgid ""
"tarantool> box.space.space55.index.primary:drop()\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:826
#: ../doc/1.7/dev_guide/documentation_guidelines.rst:274
msgid "Rename an index."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:830
msgid "new name for index"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:834
msgid "**Possible errors:** index_object does not exist."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:838
#: ../doc/1.7/dev_guide/documentation_guidelines.rst:285
msgid ""
"tarantool> box.space.space55.index.primary:rename('secondary')\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:844 ../doc/1.7/book/box/box_space.rst:840
msgid "**Complexity factors:** Index size, Index type, Number of tuples accessed."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:848
msgid "Return the total number of bytes taken by the index."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:853 ../doc/1.7/book/box/box_tuple.rst:121
msgid "number of bytes"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:858
msgid "Example showing use of the box functions"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:860
msgid ""
"This example will work with the sandbox configuration described in the preface. "
"That is, there is a space named tester with a numeric primary key. The example "
"function will:"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:864
msgid "select a tuple whose key value is 1000;"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:865
msgid "return an error if the tuple already exists and already has 3 fields;"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:868
msgid "Insert or replace the tuple with:"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:867
msgid "field[1] = 1000"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:868
msgid "field[2] = a uuid"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:869
msgid "field[3] = number of seconds since 1970-01-01;"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:870
msgid "Get field[3] from what was replaced;"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:871
msgid "Format the value from field[3] as yyyy-mm-dd hh:mm:ss.ffff;"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:872
msgid "Return the formatted value."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:874
msgid ""
"The function uses Tarantool box functions :ref:`box.space...select <box_space-"
"select>`, :ref:`box.space...replace <box_space-replace>`, :ref:`fiber.time "
"<fiber-time>`, :ref:`uuid.str <uuid-str>`. The function uses Lua functions `os."
"date()`_ and `string.sub()`_."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:883
#, python-format
msgid ""
"function example()\n"
"  local a, b, c, table_of_selected_tuples, d\n"
"  local replaced_tuple, time_field\n"
"  local formatted_time_field\n"
"  local fiber = require('fiber')\n"
"  table_of_selected_tuples = box.space.tester:select{1000}\n"
"  if table_of_selected_tuples ~= nil then\n"
"    if table_of_selected_tuples[1] ~= nil then\n"
"      if #table_of_selected_tuples[1] == 3 then\n"
"        box.error({code=1, reason='This tuple already has 3 fields'})\n"
"      end\n"
"    end\n"
"  end\n"
"  replaced_tuple = box.space.tester:replace\n"
"    {1000,  require('uuid').str(), tostring(fiber.time())}\n"
"  time_field = tonumber(replaced_tuple[3])\n"
"  formatted_time_field = os.date(\"%Y-%m-%d %H:%M:%S\", time_field)\n"
"  c = time_field % 1\n"
"  d = string.sub(c, 3, 6)\n"
"  formatted_time_field = formatted_time_field .. '.' .. d\n"
"  return formatted_time_field\n"
"end"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:908 ../doc/1.7/book/box/box_tuple.rst:378
msgid "... And here is what happens when one invokes the function:"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:910
msgid ""
"tarantool> box.space.tester:delete(1000)\n"
"---\n"
"- [1000, '264ee2da03634f24972be76c43808254', '1391037015.6809']\n"
"...\n"
"tarantool> example(1000)\n"
"---\n"
"- 2014-01-29 16:11:51.1582\n"
"...\n"
"tarantool> example(1000)\n"
"---\n"
"- error: 'This tuple already has 3 fields'\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:927
msgid "Example showing a user-defined iterator"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:929
msgid ""
"Here is an example that shows how to build one's own iterator. The "
"``paged_iter`` function is an \"iterator function\", which will only be "
"understood by programmers who have read the Lua manual section `Iterators and "
"Closures <https://www.lua.org/pil/7.1.html>`_. It does paginated retrievals, "
"that is, it returns 10 tuples at a time from a table named \"t\", whose primary "
"key was defined with ``create_index('primary',{parts={1,'string'}})``."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:936
msgid ""
"function paged_iter(search_key, tuples_per_page)\n"
"  local iterator_string = \"GE\"\n"
"  return function ()\n"
"  local page = box.space.t.index[0]:select(search_key,\n"
"    {iterator = iterator_string, limit=tuples_per_page})\n"
"  if #page == 0 then return nil end\n"
"  search_key = page[#page][1]\n"
"  iterator_string = \"GT\"\n"
"  return page\n"
"  end\n"
"end"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:950
msgid ""
"Programmers who use ``paged_iter`` do not need to know why it works, they only "
"need to know that, if they call it within a loop, they will get 10 tuples at a "
"time until there are no more tuples. In this example the tuples are merely "
"printed, a page at a time. But it should be simple to change the functionality, "
"for example by yielding after each retrieval, or by breaking when the tuples "
"fail to match some additional criteria."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:957
msgid ""
"for page in paged_iter(\"X\", 10) do\n"
"  print(\"New Page. Number Of Tuples = \" .. #page)\n"
"  for i = 1, #page, 1 do\n"
"    print(page[i])\n"
"  end\n"
"end"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:970
msgid "Submodule `box.index` with index type = RTREE for spatial searches"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:972
msgid ""
"The :ref:`box.index <box_index>` submodule may be used for spatial searches if "
"the index type is RTREE. There are operations for searching *rectangles* "
"(geometric objects with 4 corners and 4 sides) and *boxes* (geometric objects "
"with more than 4 corners and more than 4 sides, sometimes called "
"hyperrectangles). This manual uses the term *rectangle-or-box* for the whole "
"class of objects that includes both rectangles and boxes. Only rectangles will "
"be illustrated."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:980
msgid ""
"Rectangles are described according to their X-axis (horizontal axis) and Y-axis "
"(vertical axis) coordinates in a grid of arbitrary size. Here is a picture of "
"four rectangles on a grid with 11 horizontal points and 11 vertical points:"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:986
msgid ""
"           X AXIS\n"
"           1   2   3   4   5   6   7   8   9   10  11\n"
"        1\n"
"        2  #-------+                                           <-Rectangle#1\n"
"Y AXIS  3  |       |\n"
"        4  +-------#\n"
"        5          #-----------------------+                   <-Rectangle#2\n"
"        6          |                       |\n"
"        7          |   #---+               |                   <-Rectangle#3\n"
"        8          |   |   |               |\n"
"        9          |   +---#               |\n"
"        10         +-----------------------#\n"
"        11                                     #               <-Rectangle#4"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1000
msgid ""
"The rectangles are defined according to this scheme: {X-axis coordinate of top "
"left, Y-axis coordinate of top left, X-axis coordinate of bottom right, Y-axis "
"coordinate of bottom right} -- or more succinctly: {x1,y1,x2,y2}. So in the "
"picture ... Rectangle#1 starts at position 1 on the X axis and position 2 on the "
"Y axis, and ends at position 3 on the X axis and position 4 on the Y axis, so "
"its coordinates are {1,2,3,4}. Rectangle#2's coordinates are {3,5,9,10}. "
"Rectangle#3's coordinates are {4,7,5,9}. And finally Rectangle#4's coordinates "
"are {10,11,10,11}. Rectangle#4 is actually a \"point\" since it has zero width "
"and zero height, so it could have been described with only two digits: {10,11}."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1010
msgid ""
"Some relationships between the rectangles are: \"Rectangle#1's nearest neighbor "
"is Rectangle#2\", and \"Rectangle#3 is entirely inside Rectangle#2\"."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1013
msgid "Now let us create a space and add an RTREE index."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1015
msgid ""
"tarantool> s = box.schema.space.create('rectangles')\n"
"tarantool> i = s:create_index('primary', {\n"
"         >   type = 'HASH',\n"
"         >   parts = {1, 'unsigned'}\n"
"         > })\n"
"tarantool> r = s:create_index('rtree', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1028
msgid ""
"Field#1 doesn't matter, we just make it because we need a primary-key index. "
"(RTREE indexes cannot be unique and therefore cannot be primary-key indexes.) "
"The second field must be an \"array\", which means its values must represent {x,"
"y} points or {x1,y1,x2,y2} rectangles. Now let us populate the table by "
"inserting two tuples, containing the coordinates of Rectangle#2 and Rectangle#4."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1034
msgid ""
"tarantool> s:insert{1, {3, 5, 9, 10}}\n"
"tarantool> s:insert{2, {10, 11}}"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1039
msgid ""
"And now, following the description of `RTREE iterator types`_, we can search the "
"rectangles with these requests:"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1044
msgid ""
"tarantool> r:select({10, 11, 10, 11}, {iterator = 'EQ'})\n"
"---\n"
"- - [2, [10, 11]]\n"
"...\n"
"tarantool> r:select({4, 7, 5, 9}, {iterator = 'GT'})\n"
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"...\n"
"tarantool> r:select({1, 2, 3, 4}, {iterator = 'NEIGHBOR'})\n"
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"  - [2, [10, 11]]\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1060
msgid ""
"Request#1 returns 1 tuple because the point {10,11} is the same as the rectangle "
"{10,11,10,11} (\"Rectangle#4\" in the picture). Request#2 returns 1 tuple "
"because the rectangle {4,7,5,9}, which was \"Rectangle#3\" in the picture, is "
"entirely within{3,5,9,10} which was Rectangle#2. Request#3 returns 2 tuples, "
"because the NEIGHBOR iterator always returns all tuples, and the first returned "
"tuple will be {3,5,9,10} (\"Rectangle#2\" in the picture) because it is the "
"closest neighbor of {1,2,3,4} (\"Rectangle#1\" in the picture)."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1068
msgid ""
"Now let us create a space and index for cuboids, which are rectangle-or-boxes "
"that have 6 corners and 6 sides."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1071
msgid ""
"tarantool> s = box.schema.space.create('R')\n"
"tarantool> i = s:create_index('primary', {parts = {1, 'unsigned'}})\n"
"tarantool> r = s:create_index('S', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   dimension = 3,\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1082
msgid ""
"The additional option here is ``dimension=3``. The default dimension is 2, which "
"is why it didn't need to be specified for the examples of rectangle. The maximum "
"dimension is 20. Now for insertions and selections there will usually be 6 "
"coordinates. For example:"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1087
msgid ""
"tarantool> s:insert{1, {0, 3, 0, 3, 0, 3}}\n"
"tarantool> r:select({1, 2, 1, 2, 1, 2}, {iterator = box.index.GT})"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1092
msgid ""
"Now let us create a space and index for Manhattan-style spatial objects, which "
"are rectangle-or-boxes that have a different way to calculate neighbors."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1095
msgid ""
"tarantool> s = box.schema.space.create('R')\n"
"tarantool> i = s:create_index('primary', {parts = {1, 'unsigned'}})\n"
"tarantool> r = s:create_index('S', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   distance = 'manhattan',\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1106
msgid ""
"The additional option here is ``distance='manhattan'``. The default distance "
"calculator is 'euclid', which is the straightforward as-the-crow-flies method. "
"The optional distance calculator is 'manhattan', which can be a more appropriate "
"method if one is following the lines of a grid rather than traveling in a "
"straight line."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1112
msgid ""
"tarantool> s:insert{1, {0, 3, 0, 3}}\n"
"tarantool> r:select({1, 2, 1, 2}, {iterator = box.index.NEIGHBOR})"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1118
msgid ""
"More examples of spatial searching are online in the file `R tree index quick "
"start and usage`_."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:39
msgid "Submodule `box.info`"
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:43
msgid ""
"The ``box.info`` submodule provides access to information about server instance "
"variables."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:46
msgid ""
"**version** is the Tarantool version. This value is also shown by :ref:"
"`tarantool --version <index-tarantool_version>`."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:48
msgid "**id** corresponds to **replication.id** (see below)."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:49
msgid ""
"**ro** is ``true`` if the instance is in \"read-only\" mode (same as :ref:"
"`read_only <cfg_basic-read_only>` in ``box.cfg{}``)."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:51
msgid "**vclock** corresponds to **replication.downstream.vclock** (see below)."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:52
msgid ""
"**uptime** is the number of seconds since the instance started. This value can "
"also be retrieved with :ref:`tarantool.uptime() <tarantool-build>`."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:54
msgid "**lsn** corresponds to **replication.lsn** (see below)."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:55
msgid "**vinyl** returns runtime statistics for vinyl storage engine."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:56
msgid ""
"**cluster.uuid** is the UUID of the replica set. Every instance in a replica set "
"will have the same ``cluster.uuid`` value. This value is also stored in :ref:"
"`box.space._schema <box_space-schema>` system space."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:60
msgid ""
"**pid** is the process ID. This value is also shown by :ref:`tarantool "
"<tarantool-build>` module and by the Linux command ``ps -A``."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:63
msgid "**status** corresponds to **replication.upstream.status** (see below)."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:64
msgid ""
"**signature** is the sum of all **lsn** values from the vector clocks "
"(**vclock**) of all instances in the replica set."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:66
msgid "**uuid** corresponds to **replication.uuid**  (see below)."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:70
msgid ""
"**replication** part contains statistics for all instances in the replica set in "
"regard to the current instance (see an example in the section :ref:`\"Monitoring "
"a replica set\" <replication-monitoring>`):"
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:74
msgid ""
"**replication.id** is a short numeric identifier of the instance within the "
"replica set."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:76
msgid ""
"**replication.uuid** is a globally unique identifier of the instance. This value "
"is also stored in :ref:`box.space._cluster <box_space-cluster>` system space."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:79
msgid ""
"**replication.lsn** is the :ref:`log sequence number <replication-mechanism>` "
"(LSN) for the latest entry in the instance's :ref:`write ahead log <index-"
"box_persistence>` (WAL)."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:82
msgid ""
"**replication.upstream** contains statistics for the replication data uploaded "
"by the instance."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:84
msgid "**replication.upstream.status** is the replication status of the instance."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:86
msgid ""
"``auth`` means that the instance is getting :ref:`authenticated "
"<authentication>` to connect to a replication source."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:88
msgid ""
"``connecting`` means that the instance is trying to connect to the replications "
"source(s) listed in its :ref:`replication <cfg_replication-replication>` "
"parameter."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:91
msgid ""
"``disconnected`` means that the instance is not connected to the replica set "
"(due to network problems, not replication errors)."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:93
msgid ""
"``follow`` means that the instance's :ref:`role <replication-roles>` is \"replica"
"\" (read-only) and replication is in progress."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:95
msgid ""
"``running`` means the instance's role is \"master\" (non read-only) and "
"replication is in progress."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:97
msgid ""
"``stopped`` means that replication was stopped due to a replication error (e.g. :"
"ref:`duplicate key <error_codes>`)."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:100
msgid ""
"**replication.upstream.idle** is the time (in seconds) since the instance "
"received the last event from a master."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:102
msgid ""
"**replication.upstream.lag** is the time difference between the local time at "
"the instance, recorded when the event was received, and the local time at "
"another master recorded when the event was written to the :ref:`write ahead log "
"<internals-wal>` on that master."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:107
msgid ""
"Since ``lag`` calculation uses operating system clock from two different "
"machines, don’t be surprised if it’s negative: a time drift may lead to the "
"remote master clock being consistently behind the local instance's clock."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:111
msgid "For multi-master configurations, this is the maximal lag."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:113
msgid ""
"**replication.downstream** contains statistics for the replication data "
"requested and downloaded from the instance."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:115
msgid ""
"**replication.downstream.vclock** is the instance's :ref:`vector clock "
"<internals-vector>`, which contains a pair '**id**, **lsn**'."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:120
msgid ""
"Since ``box.info`` contents are dynamic, it's not possible to iterate over keys "
"with the Lua ``pairs()`` function. For this purpose, ``box.info()`` builds and "
"returns a Lua table with all keys and values provided in the submodule."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:125
msgid "keys and values in the submodule."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:130
msgid ""
"tarantool> box.info\n"
"---\n"
"- version: 1.7.4-52-g980d30092\n"
"  id: 1\n"
"  ro: false\n"
"  vclock: {1: 8}\n"
"  uptime: 7280\n"
"  lsn: 8\n"
"  vinyl: []\n"
"  cluster:\n"
"    uuid: f7c0c1c6-f9d8-4df7-82ff-d4bd00610a6c\n"
"  pid: 16162\n"
"  status: running\n"
"  signature: 8\n"
"  replication:\n"
"    1:\n"
"      id: 1\n"
"      uuid: 1899631e-6369-40a1-81c9-7d170e909276\n"
"      lsn: 8\n"
"    2:\n"
"      id: 2\n"
"      uuid: bd949e5d-7ff9-413e-b4f2-c9b0149fdda6\n"
"      lsn: 0\n"
"      upstream:\n"
"        status: follow\n"
"        idle: 7256.7571430206\n"
"        lag: 0\n"
"      downstream:\n"
"        vclock: {1: 8}\n"
"    3:\n"
"      id: 3\n"
"      uuid: c5cb61d5-fa48-460d-abd7-3f13709d07a7\n"
"      lsn: 0\n"
"      upstream:\n"
"        status: follow\n"
"        idle: 7255.7510120869\n"
"        lag: 0\n"
"      downstream:\n"
"        vclock: {1: 8}\n"
"  uuid: 1899631e-6369-40a1-81c9-7d170e909276\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:39
msgid "Submodule `box.schema`"
msgstr "Вложенный модуль `box.schema`"

#: ../doc/1.7/book/box/box_schema.rst:43
msgid ""
"The ``box.schema`` submodule has data-definition functions for spaces, users, "
"roles, and function tuples."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:50
msgid "Create a :ref:`space <index-box_space>`."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:52
msgid ""
"name of space, which should not be a number and should not contain special "
"characters"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:54
msgid "see \"Options for box.schema.space.create\" chart, below"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:56
msgid "space object"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:57
#: ../doc/1.7/dev_guide/documentation_guidelines.rst:243
#: ../doc/1.7/reference/reference_lua/fiber.rst:110
#: ../doc/1.7/reference/reference_lua/fiber.rst:134
#: ../doc/1.7/reference/reference_lua/fiber.rst:154
#: ../doc/1.7/reference/reference_lua/fio.rst:388
#: ../doc/1.7/reference/reference_lua/http.rst:56
#: ../doc/1.7/reference/reference_lua/iconv.rst:62
#: ../doc/1.7/reference/reference_lua/net_box.rst:163
#: ../doc/1.7/reference/reference_lua/socket.rst:145
#: ../doc/1.7/reference/reference_lua/socket.rst:163
#: ../doc/1.7/reference/reference_lua/socket.rst:355
#: ../doc/1.7/reference/reference_lua/socket.rst:381
#: ../doc/1.7/reference/reference_lua/tap.rst:57
msgid "userdata"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:61
msgid "**Options for box.schema.space.create**"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:69 ../doc/1.7/book/box/box_space.rst:58
#: ../doc/1.7/book/box/box_space.rst:266 ../doc/1.7/book/box/box_space.rst:1407
msgid "Name"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:69 ../doc/1.7/book/box/box_space.rst:266
msgid "Default"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:71
msgid "temporary"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:71
msgid ""
"space contents are temporary: changes are not stored in the :ref:`write-ahead "
"log <internals-wal>` and there is no :ref:`replication <replication>`. Note re "
"storage engine: vinyl does not support temporary spaces."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:71 ../doc/1.7/book/box/box_schema.rst:89
#: ../doc/1.7/reference/reference_lua/msgpack.rst:173
msgid "false"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:79 ../doc/1.7/book/box/box_space.rst:272
msgid "id"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:79
msgid ""
"unique identifier: users can refer to spaces with the id instead of the name"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:79
msgid "last space's id, +1"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:83
msgid "field_count"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:83
msgid ""
"fixed count of :ref:`fields <index-box_tuple>`: for example if field_count=5, it "
"is illegal to insert a tuple with fewer than or more than 5 fields"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:83
msgid "0 i.e. not fixed"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:89 ../doc/1.7/book/box/box_space.rst:276
msgid "if_not_exists"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:89
msgid ""
"create space only if a space with the same name does not exist already, "
"otherwise do nothing but do not cause an error"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:95
msgid "engine"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:95
msgid "'memtx' or 'vinyl'"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:95 ../doc/1.7/book/box/box_schema.rst:97
#: ../doc/1.7/book/box/box_schema.rst:314 ../doc/1.7/book/box/box_session.rst:72
#: ../doc/1.7/book/box/box_session.rst:91 ../doc/1.7/book/box/box_session.rst:99
#: ../doc/1.7/book/box/data_model.rst:191
#: ../doc/1.7/reference/reference_lua/errno.rst:73
#: ../doc/1.7/reference/reference_lua/fiber.rst:206
#: ../doc/1.7/reference/reference_lua/fiber.rst:310
#: ../doc/1.7/reference/reference_lua/fiber.rst:355
#: ../doc/1.7/reference/reference_lua/fio.rst:68
#: ../doc/1.7/reference/reference_lua/fio.rst:88
#: ../doc/1.7/reference/reference_lua/fio.rst:106
#: ../doc/1.7/reference/reference_lua/json.rst:55
#: ../doc/1.7/reference/reference_lua/msgpack.rst:54
#: ../doc/1.7/reference/reference_lua/pickle.rst:94
#: ../doc/1.7/reference/reference_lua/socket.rst:293
#: ../doc/1.7/reference/reference_lua/socket.rst:324
#: ../doc/1.7/reference/reference_lua/socket.rst:340
#: ../doc/1.7/reference/reference_lua/string.rst:66
#: ../doc/1.7/reference/reference_lua/string.rst:91
#: ../doc/1.7/reference/reference_lua/string.rst:114
#: ../doc/1.7/reference/reference_lua/uri.rst:82
#: ../doc/1.7/reference/reference_lua/yaml.rst:52
msgid "string"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:95
msgid "'memtx'"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:97 ../doc/1.7/book/box/box_space.rst:1409
#: ../doc/1.7/book/box/box_space.rst:1412
msgid "user"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:97
msgid ""
"name of the user who is considered to be the space's :ref:`owner <authentication-"
"owners_privileges>` for authorization purposes"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:97
msgid "current user's name"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:102
msgid "format"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:102
msgid ""
"field names and types: For an illustration with the ``format`` option, see the :"
"ref:`box.space._space <box_space-space>` example."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:102
msgid "(blank)"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:109
msgid ""
"There are three :ref:`syntax variations <app_server-object_reference>` for "
"object references targeting space objects, for example :samp:`box.schema.space."
"drop({space-id})` will drop a space. However, the common approach is to use "
"functions attached to the space objects, for example :ref:`space_object:drop() "
"<box_space-drop>`."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:118
msgid ""
"tarantool> s = box.schema.space.create('space55')\n"
"---\n"
"...\n"
"tarantool> s = box.schema.space.create('space55', {\n"
"         >   id = 555,\n"
"         >   temporary = false\n"
"         > })\n"
"---\n"
"- error: Space 'space55' already exists\n"
"...\n"
"tarantool> s = box.schema.space.create('space55', {\n"
"         >   if_not_exists = true\n"
"         > })\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:136
msgid ""
"After a space is created, usually the next step is to :ref:`create an index "
"<box_space-create_index>` for it, and then it is available for insert, select, "
"and all the other :ref:`box.space <box_space>` functions."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:144
msgid ""
"Create a user. For explanation of how Tarantool maintains user data, see "
"section :ref:`Users<authentication-users>` and reference on :ref:`_user "
"<box_space-user>` space."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:149 ../doc/1.7/book/box/box_schema.rst:240
#: ../doc/1.7/book/box/box_schema.rst:511
msgid "The possible options are:"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:151
msgid ""
"``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` "
"means there should be no error if the user already exists,"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:154
msgid ""
"``password`` (default = '') - string; the ``password`` = *password* "
"specification is good because in a :ref:`URI <index-uri>` (Uniform Resource "
"Identifier) it is usually illegal to include a user-name without a password."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:161 ../doc/1.7/book/box/box_space.rst:1493
msgid "The maximum number of users is 32."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:163
msgid ""
"name of user, which should not be a number and should not contain special "
"characters"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:165
msgid "``if_not_exists``, ``password``"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:169 ../doc/1.7/book/box/box_schema.rst:190
#: ../doc/1.7/book/box/box_schema.rst:595
#: ../doc/1.7/reference/reference_lua/net_box.rst:165
#: ../doc/1.7/reference/reference_lua/net_box.rst:224
#: ../doc/1.7/reference/reference_lua/net_box.rst:334
msgid "**Examples:**"
msgstr "**Примеры:**"

#: ../doc/1.7/book/box/box_schema.rst:171
msgid ""
"box.schema.user.create('Lena')\n"
"box.schema.user.create('Lena', {password = 'X'})\n"
"box.schema.user.create('Lena', {if_not_exists = false})"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:181
msgid ""
"Drop a user. For explanation of how Tarantool maintains user data, see section :"
"ref:`Users <authentication-users>` and reference on :ref:`_user <box_space-"
"user>` space."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:186 ../doc/1.7/book/box/box_schema.rst:206
#: ../doc/1.7/book/box/box_schema.rst:224 ../doc/1.7/book/box/box_schema.rst:265
msgid "the name of the user"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:187
msgid ""
"``if_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` means "
"there should be no error if the user does not exist."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:192
msgid ""
"box.schema.user.drop('Lena')\n"
"box.schema.user.drop('Lena',{if_exists=false})"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:201
msgid ""
"Return ``true`` if a user exists; return ``false`` if a user does not exist. For "
"explanation of how Tarantool maintains user data, see section :ref:`Users "
"<authentication-users>` and reference on :ref:`_user <box_space-user>` space."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:207 ../doc/1.7/book/box/box_schema.rst:415
#: ../doc/1.7/book/box/box_schema.rst:566
#: ../doc/1.7/reference/reference_lua/uuid.rst:140
msgid "bool"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:211
msgid "box.schema.user.exists('Lena')"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:221
msgid ""
"Grant :ref:`privileges <authentication-owners_privileges>` to a user or to "
"another role."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:225
msgid "'read' or 'write' or 'execute' or a combination,"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:226
msgid "'space' or 'function'."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:227
msgid "name of object to grant permissions to"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:228
msgid "name of role to grant to user."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:229
msgid "``grantor``, ``if_not_exists``"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:231
msgid ""
"If :samp:`'function','{object-name}'` is specified, then a _func tuple with that "
"object-name must exist."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:234
msgid ""
"**Variation:** instead of ``object-type, object-name`` say 'universe' which "
"means 'all object-types and all objects'. In this case, object name is omitted."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:237 ../doc/1.7/book/box/box_schema.rst:276
msgid ""
"**Variation:** instead of ``privilege, object-type, object-name`` say ``role-"
"name`` (see section :ref:`Roles <authentication-roles>`)."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:242
msgid "``grantor`` = *grantor_name_or_id* -- string or number, for custom grantor,"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:243
msgid ""
"``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` "
"means there should be no error if the user already has the privilege."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:248
msgid ""
"box.schema.user.grant('Lena', 'read', 'space', 'tester')\n"
"box.schema.user.grant('Lena', 'execute', 'function', 'f')\n"
"box.schema.user.grant('Lena', 'read,write', 'universe')\n"
"box.schema.user.grant('Lena', 'Accountant')\n"
"box.schema.user.grant('Lena', 'read,write,execute', 'universe')\n"
"box.schema.user.grant('X', 'read', 'universe', nil, {if_not_exists=true}))"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:262
msgid ""
"Revoke :ref:`privileges <authentication-owners_privileges>` from a user or from "
"another role."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:266 ../doc/1.7/book/box/box_schema.rst:432
#: ../doc/1.7/book/box/box_schema.rst:464
msgid "'read' or 'write' or 'execute' or a combination"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:267 ../doc/1.7/book/box/box_schema.rst:433
#: ../doc/1.7/book/box/box_schema.rst:465
msgid "'space' or 'function'"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:268 ../doc/1.7/book/box/box_schema.rst:434
#: ../doc/1.7/book/box/box_schema.rst:466
msgid "the name of a function or space"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:270
msgid ""
"The user must exist, and the object must exist, but it is not an error if the "
"user does not have the privilege."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:273 ../doc/1.7/book/box/box_schema.rst:441
#: ../doc/1.7/book/box/box_schema.rst:471
msgid ""
"**Variation:** instead of ``object-type, object-name`` say 'universe' which "
"means 'all object-types and all objects'."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:281
msgid ""
"box.schema.user.revoke('Lena', 'read', 'space', 'tester')\n"
"box.schema.user.revoke('Lena', 'execute', 'function', 'f')\n"
"box.schema.user.revoke('Lena', 'read,write', 'universe')\n"
"box.schema.user.revoke('Lena', 'Accountant')"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:292
msgid ""
"Return a hash of a user's password. For explanation of how Tarantool maintains "
"passwords, see section :ref:`Passwords <authentication-passwords>` and reference "
"on :ref:`_user <box_space-user>` space."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:298
msgid ""
"If a non-'guest' user has no password, it’s **impossible** to connect to "
"Tarantool using this user. The user is regarded as “internal” only, not usable "
"from a remote connection. Such users can be useful if they have defined some "
"procedures with the :ref:`SETUID <box_schema-func_create>` option, on which "
"privileges are granted to externally-connectable users. This way, external users "
"cannot create/drop objects, they can only invoke procedures."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:305
msgid ""
"For the 'guest' user, it’s impossible to set a password: that would be "
"misleading, since 'guest' is the default user on a newly-established connection "
"over a :ref:`binary port <admin-security>`, and Tarantool does not require a "
"password to establish a :ref:`binary connection <box_protocol-iproto_protocol>`. "
"It is, however, possible to change the current user to ‘guest’ by providing the :"
"ref:`AUTH packet <box_protocol-authentication>` with no password at all or an "
"empty password. This feature is useful for connection pools, which want to reuse "
"a connection for a different user without re-establishing it."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:313
msgid "password to be hashed"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:318
msgid "box.schema.user.password('ЛЕНА')"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:326
msgid ""
"Associate a password with the user who is currently logged in, or with the user "
"specified by user-name. The user must exist and must not be 'guest'."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:329
msgid ""
"Users who wish to change their own passwords should use ``box.schema.user."
"passwd(password)`` syntax."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:332
msgid ""
"Administrators who wish to change passwords of other users should use ``box."
"schema.user.passwd(user-name, password)`` syntax."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:335
msgid "user-name"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:336
msgid "password"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:340
msgid ""
"box.schema.user.passwd('ЛЕНА')\n"
"box.schema.user.passwd('Lena', 'ЛЕНА')"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:349
msgid ""
"Return a description of a user's :ref:`privileges <authentication-"
"owners_privileges>`. For explanation of how Tarantool maintains user data, see "
"section :ref:`Users <authentication-users>` and reference on :ref:`_user "
"<box_space-user>` space."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:354
msgid ""
"the name of the user. This is optional; if it is not supplied, then the "
"information will be for the user who is currently logged in."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:362
msgid ""
"box.schema.user.info()\n"
"box.schema.user.info('Lena')"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:371
msgid ""
"Create a role. For explanation of how Tarantool maintains role data, see "
"section :ref:`Roles <authentication-roles>`."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:375
msgid ""
"name of role, which should not be a number and should not contain special "
"characters"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:377
msgid ""
"``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` "
"means there should be no error if the role already exists"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:385
msgid ""
"box.schema.role.create('Accountant')\n"
"box.schema.role.create('Accountant', {if_not_exists = false})"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:394
msgid ""
"Drop a role. For explanation of how Tarantool maintains role data, see section :"
"ref:`Roles <authentication-roles>`."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:398 ../doc/1.7/book/box/box_schema.rst:414
#: ../doc/1.7/book/box/box_schema.rst:431 ../doc/1.7/book/box/box_schema.rst:463
msgid "the name of the role"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:399
msgid ""
"``if_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` means "
"there should be no error if the role does not exist."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:404
msgid "box.schema.role.drop('Accountant')"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:412
msgid ""
"Return ``true`` if a role exists; return ``false`` if a role does not exist."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:419
msgid "box.schema.role.exists('Accountant')"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:429
msgid "Grant :ref:`privileges <authentication-owners_privileges>` to a role."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:435
msgid ""
"``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` "
"means there should be no error if the role already has the privilege"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:439
msgid "The role must exist, and the object must exist."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:444
msgid ""
"**Variation:** instead of ``privilege, object-type, object-name`` say ``role-"
"name`` -- to grant a role to a role."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:449
msgid ""
"box.schema.role.grant('Accountant', 'read', 'space', 'tester')\n"
"box.schema.role.grant('Accountant', 'execute', 'function', 'f')\n"
"box.schema.role.grant('Accountant', 'read,write', 'universe')\n"
"box.schema.role.grant('public', 'Accountant')\n"
"box.schema.role.grant('role1', 'role2', nil, nil, {if_not_exists=false})"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:461
msgid "Revoke :ref:`privileges <authentication-owners_privileges>` from a role."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:468
msgid ""
"The role must exist, and the object must exist, but it is not an error if the "
"role does not have the privilege."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:474
msgid ""
"**Variation:** instead of ``privilege, object-type, object-name`` say ``role-"
"name``."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:479
msgid ""
"box.schema.role.revoke('Accountant', 'read', 'space', 'tester')\n"
"box.schema.role.revoke('Accountant', 'execute', 'function', 'f')\n"
"box.schema.role.revoke('Accountant', 'read,write', 'universe')\n"
"box.schema.role.revoke('public', 'Accountant')"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:490
msgid "Return a description of a role's privileges."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:492
msgid "the name of the role."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:496
msgid "box.schema.role.info('Accountant')"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:504
msgid ""
"Create a function :ref:`tuple <index-box_tuple>`. This does not create the "
"function itself -- that is done with Lua -- but if it is necessary to grant "
"privileges for a function, box.schema.func.create must be done first. For "
"explanation of how Tarantool maintains function data, see reference on :ref:"
"`_func <box_space-func>` space."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:513
msgid ""
"``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` "
"means there should be no error if the ``_func`` tuple already exists."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:516
msgid ""
"``setuid`` = ``true|false`` (default = false) - with ``true`` to make Tarantool "
"treat the function’s caller as the function’s creator, with full privileges. "
"Remember that SETUID works only over :ref:`binary ports <admin-security>`. "
"SETUID doesn't work if you invoke a function via an :ref:`admin console <admin-"
"security>` or inside a Lua script."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:523
msgid "``language`` = 'LUA'|'C' (default = ‘LUA’)."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:525
msgid ""
"name of function, which should not be a number and should not contain special "
"characters"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:527
msgid "``if_not_exists``, ``setuid``, ``language``."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:533
msgid ""
"box.schema.func.create('calculate')\n"
"box.schema.func.create('calculate', {if_not_exists = false})\n"
"box.schema.func.create('calculate', {setuid = false})\n"
"box.schema.func.create('calculate', {language = 'LUA'})"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:544
msgid ""
"Drop a function tuple. For explanation of how Tarantool maintains function data, "
"see reference on :ref:`_func space <box_space-func>`."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:548 ../doc/1.7/book/box/box_schema.rst:565
msgid "the name of the function"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:549
msgid ""
"``if_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` means "
"there should be no error if the _func tuple does not exist."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:554
msgid "box.schema.func.drop('calculate')"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:562
msgid ""
"Return true if a function tuple exists; return false if a function tuple does "
"not exist."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:570
msgid "box.schema.func.exists('calculate')"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:578
msgid "Reload a C module or function without restarting the server."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:580
msgid ""
"Under the hood, Tarantool loads a new copy of the module (``*.so`` shared "
"library) and starts routing all new request to the new version. The previous "
"version remains active until all started calls are finished. All shared "
"libraries are loaded with ``RTLD_LOCAL`` (see \"man 3 dlopen\"), therefore "
"multiple copies can co-exist without any problems."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:588
msgid ""
"When a function from a certain module is reloaded, all the other functions from "
"this module are also reloaded."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:590
msgid ""
"Reload will fail if a module was loaded from Lua script with `ffi.load() <http://"
"luajit.org/ext_ffi_api.html#ffi_load>`_."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:593
msgid "the name of the module or function to reload"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:597
msgid ""
"-- reload a function\n"
"box.schema.func.reload('module.function')\n"
"-- reload the entire module contents\n"
"box.schema.func.reload('module')\n"
"-- reload everything\n"
"box.schema.func.reload()"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:39
msgid "Submodule `box.session`"
msgstr "Вложенный модуль `box.session`"

#: ../doc/1.7/book/box/box_session.rst:41
msgid ""
"The ``box.session`` submodule allows querying the session state, writing to a "
"session-specific temporary Lua table, or setting up triggers which will fire "
"when a session starts or ends. A *session* is an object associated with each "
"client connection."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:50
msgid ""
"the unique identifier (ID) for the current session. The result can be 0 meaning "
"there is no session."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:56
msgid "1 if the session exists, 0 if the session does not exist."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:61
msgid ""
"This function works only if there is a peer, that is, if a connection has been "
"made to a separate Tarantool instance."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:64
msgid ""
"The host address and port of the session peer, for example \"127.0.0.1:55457\". "
"If the session exists but there is no connection to a separate instance, the "
"return is null. The command is executed on the server instance, so the \"local "
"name\" is the server instance's host and port, and the \"peer name\" is the "
"client's host and port."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:74
msgid "Possible errors: 'session.peer(): session does not exist'"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:80
msgid ""
"the value of the :code:`sync` integer constant used in the `binary protocol "
"<https://github.com/tarantool/tarantool/blob/1.7/src/box/iproto_constants.h>`_."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:89
msgid "the name of the :ref:`current user <authentication-users>`"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:97
msgid "the type of connection or cause of action."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:101
msgid "Possible return values are:"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:103
msgid ""
"'binary' if the connection was done via the binary protocol, for example to a "
"target made with :ref:`box.cfg{listen=...} <cfg_basic-listen>`;"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:106
msgid ""
"'console' if the connection was done via the administrative console, for example "
"to a target made with :ref:`console.listen <console-listen>`;"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:109
msgid ""
"'repl' if the connection was done directly, for example when :ref:`using "
"Tarantool as a client <admin-using_tarantool_as_a_client>`;"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:111
msgid ""
"'applier' if the action is due to :ref:`replication <replication>`, regardless "
"of how the connection was done;"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:114
msgid ""
"'background' if the action is in a :ref:`background fiber <fiber-module>`, "
"regardless of whether the Tarantool server was :ref:`started in the background "
"<cfg_basic-background>`."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:119
msgid ""
"``box.session.type()`` is useful for an :ref:`on_replace() <box_space-"
"on_replace>` trigger on a replica -- the value will be 'applier' if and only if "
"the trigger was activated because of a request that was done on the master."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:129
msgid ""
"Change Tarantool's :ref:`current user <authentication-users>` -- this is "
"analogous to the Unix command ``su``."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:132
msgid ""
"Or, if function-to-execute is specified, change Tarantool's :ref:`current user "
"<authentication-users>` temporarily while executing the function -- this is "
"analogous to the Unix command ``sudo``."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:137
msgid "name of a target user"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:138
msgid ""
"name of a function, or definition of a function. Additional parameters may be "
"passed to ``box.session.su``, they will be interpreted as parameters of function-"
"to-execute."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:145
msgid ""
"tarantool> function f(a) return box.session.user() .. a end\n"
"---\n"
"...\n"
"\n"
"tarantool> box.session.su('guest', f, '-xxx')\n"
"---\n"
"- guest-xxx\n"
"...\n"
"\n"
"tarantool> box.session.su('guest',function(...) return ... end,1,2)\n"
"---\n"
"- 1\n"
"- 2\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:167
msgid ""
"A Lua table that can hold arbitrary unordered session-specific names and values, "
"which will last until the session ends. For example, this table could be useful "
"to store current tasks when working with a `Tarantool queue manager <https://"
"github.com/tarantool/queue>`_."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:174
msgid ""
"tarantool> box.session.peer(box.session.id())\n"
"---\n"
"- 127.0.0.1:45129\n"
"...\n"
"tarantool> box.session.storage.random_memorandum = \"Don't forget the eggs\"\n"
"---\n"
"...\n"
"tarantool> box.session.storage.radius_of_mars = 3396\n"
"---\n"
"...\n"
"tarantool> m = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in pairs(box.session.storage) do\n"
"         >   m = m .. k .. '='.. v .. ' '\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> m\n"
"---\n"
"- 'radius_of_mars=3396 random_memorandum=Don''t forget the eggs. '\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:203
msgid ""
"Define a trigger for execution when a new session is created due to an event "
"such as :ref:`console.connect <console-connect>`. The trigger function will be "
"the first thing executed after a new session is created. If the trigger "
"execution fails and raises an error, the error is sent to the client and the "
"connection is closed."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:208 ../doc/1.7/book/box/box_session.rst:239
#: ../doc/1.7/book/box/box_session.rst:312 ../doc/1.7/book/box/box_space.rst:558
msgid "function which will become the trigger function"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:209 ../doc/1.7/book/box/box_session.rst:240
#: ../doc/1.7/book/box/box_session.rst:313 ../doc/1.7/book/box/box_space.rst:560
msgid "existing trigger function which will be replaced by trigger-function"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:210 ../doc/1.7/book/box/box_session.rst:241
#: ../doc/1.7/book/box/box_session.rst:314 ../doc/1.7/book/box/box_space.rst:563
msgid "nil or function pointer"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:212 ../doc/1.7/book/box/box_session.rst:243
#: ../doc/1.7/book/box/box_session.rst:316 ../doc/1.7/book/box/box_space.rst:565
msgid ""
"If the parameters are (nil, old-trigger-function), then the old trigger is "
"deleted."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:214 ../doc/1.7/book/box/box_session.rst:245
#: ../doc/1.7/book/box/box_session.rst:318 ../doc/1.7/book/box/box_space.rst:572
#, fuzzy
msgid ""
"Details about trigger characteristics are in the :ref:`triggers <triggers-"
"box_triggers>` section."
msgstr ""
"См. подробности о работе потока записи в WAL в разделе  :ref:`Детали реализации "
"<b_internals>`."

#: ../doc/1.7/book/box/box_session.rst:218
msgid ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_connect(f)"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:227
msgid ""
"If a trigger always results in an error, it may become impossible to connect to "
"a server to reset it."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:234
msgid ""
"Define a trigger for execution after a client has disconnected. If the trigger "
"function causes an error, the error is logged but otherwise is ignored. The "
"trigger is invoked while the session associated with the client still exists and "
"can access session properties, such as box.session.id."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:249
msgid ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_disconnect(f)"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:258
msgid ""
"After the following series of requests, a Tarantool instance will write a "
"message using the :ref:`log <log-module>` module whenever any user connects or "
"disconnects."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:261
msgid ""
"function log_connect ()\n"
"  local log = require('log')\n"
"  local m = 'Connection. user=' .. box.session.user() .. ' id=' .. box.session."
"id()\n"
"  log.info(m)\n"
"end\n"
"\n"
"function log_disconnect ()\n"
"  local log = require('log')\n"
"  local m = 'Disconnection. user=' .. box.session.user() .. ' id=' .. box."
"session.id()\n"
"  log.info(m)\n"
"end\n"
"\n"
"box.session.on_connect(log_connect)\n"
"box.session.on_disconnect(log_disconnect)"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:278
msgid "Here is what might appear in the log file in a typical installation:"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:280
msgid ""
"2014-12-15 13:21:34.444 [11360] main/103/iproto I>\n"
"    Connection. user=guest id=3\n"
"2014-12-15 13:22:19.289 [11360] main/103/iproto I>\n"
"    Disconnection. user=guest id=3"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:291
#, fuzzy
msgid ""
"Define a trigger for execution during :ref:`authentication <authentication-"
"users>`."
msgstr ""
"Автоматически выбирается пользователь ':ref:`guest <authentication-users>`'."

#: ../doc/1.7/book/box/box_session.rst:293
msgid "The ``on_auth`` trigger function is invoked in these circumstances:"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:295
msgid ""
"The :ref:`console.connect <console-connect>` function includes an authentication "
"check for all users except 'guest'. For this case, the ``on_auth`` trigger "
"function is invoked after the ``on_connect`` trigger function, if and only if "
"the connection has succeeded so far."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:300
msgid ""
"The :ref:`binary protocol <admin-security>` has a separate :ref:`authentication "
"packet <box_protocol-authentication>`. For this case, connection and "
"authentication are considered to be separate steps."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:304
msgid ""
"Unlike other trigger types, ``on_auth`` trigger functions are invoked **before** "
"the event. Therefore a trigger function like :code:`function auth_function () v "
"= box.session.user(); end` will set :code:`v` to \"guest\", the user name before "
"the authentication is done. To get the user name **after** the authentication is "
"done, use the special syntax: :code:`function auth_function (user_name) v = "
"user_name; end`"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:310
msgid ""
"If the trigger fails by raising an error, the error is sent to the client and "
"the connection is closed."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:320
#, fuzzy
msgid "**Example 1**"
msgstr "**Примеры:**"

#: ../doc/1.7/book/box/box_session.rst:322
msgid ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_auth(f)"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:329
#, fuzzy
msgid "**Example 2**"
msgstr "**Примеры:**"

#: ../doc/1.7/book/box/box_session.rst:331
msgid "This is a more complex example, with two server instances."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:333
msgid ""
"The first server instance listens on port 3301; its default user name is "
"'admin'. There are two ``on_auth`` triggers:"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:337
msgid ""
"The first trigger has a function with no arguments, it can only look at ``box."
"session.user()``."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:339
msgid ""
"The second trigger has a function with a ``user_name`` argument, it can look at "
"both ``box.session.user()`` and ``user_name``."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:342
msgid ""
"The second server instance will connect with :ref:`console.connect <console-"
"connect>`, and then will display the variables that were set by the trigger "
"functions."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:347
msgid ""
"-- On the first server instance, which listens on port 3301\n"
"box.cfg{listen=3301}\n"
"function function1()\n"
"  print('function 1, box.session.user()='..box.session.user())\n"
"  end\n"
"function function2(user_name)\n"
"  print('function 2, box.session.user()='..box.session.user())\n"
"  print('function 2, user_name='..user_name)\n"
"  end\n"
"box.session.on_auth(function1)\n"
"box.session.on_auth(function2)\n"
"box.schema.user.passwd('admin')"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:362
msgid ""
"-- On the second server instance, that connects to port 3301\n"
"console = require('console')\n"
"console.connect('admin:admin@localhost:3301')"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:368
#, fuzzy
msgid "The result looks like this:"
msgstr "Теперь вывод на экране выглядит следующим образом:"

#: ../doc/1.7/book/box/box_session.rst:370
msgid ""
"function 2, box.session.user()=guest\n"
"function 2, user_name=admin\n"
"function 1, box.session.user()=guest"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:39
msgid "Submodule `box.slab`"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:43
msgid ""
"The ``box.slab`` submodule provides access to slab allocator statistics. The "
"slab allocator is the main allocator used to store :ref:`tuples <index-"
"box_tuple>`. This can be used to monitor the total memory usage and memory "
"fragmentation."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:51
msgid "Show a memory usage report (in bytes) for the Lua runtime."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:55
msgid "``lua`` is the heap size of the Lua garbage collector;"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:56
msgid "``maxalloc`` is the maximal memory quota that can be allocated for Lua;"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:57
msgid "``used`` is the current memory size used by Lua."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:63
msgid ""
"tarantool> box.runtime.info()\n"
"---\n"
"- lua: 913710\n"
"  maxalloc: 4398046510080\n"
"  used: 12582912\n"
"...\n"
"tarantool> box.runtime.info().used\n"
"---\n"
"- used: 12582912\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:80
msgid "Show an aggregated memory usage report (in bytes) for the slab allocator."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:82
msgid ""
"This report is useful for assessing out-of-memory risks: the risks are high if "
"both ``arena_used_ratio`` and ``quota_used_ratio`` are high (90-95%)."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:85
msgid ""
"If ``quota_used_ratio`` is low, then high ``arena_used_ratio`` and/or "
"``items_used_ratio`` indicate that the memory fragmentation is low (i.e. the "
"memory is used efficiently)."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:89
msgid ""
"If ``quota_used_ratio`` is high (approaching 100%), then low "
"``arena_used_ratio`` (50-60%) indicates that the memory is heavily fragmentized. "
"Most probably, there is no immediate out-of-memory risk in this case, but "
"generally this is an issue to consider. For example, probable risks are that the "
"entire memory quota is used for tuples, and there is are no slabs left for a "
"piece of an index. Or that all slabs are allocated for storing tuples, but in "
"fact all the slabs are half-empty."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:99
msgid ""
"``items_size`` is the *total* amount of memory (including allocated, but "
"currently free slabs) used only for tuples, no indexes;"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:101
msgid ""
"``items_used_ratio`` = ``items_used`` / ``slab_count`` * ``slab_size`` (these "
"are slabs used only for tuples, no indexes);"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:103
msgid ""
"``quota_size`` is the maximum amount of memory that the slab allocator can use "
"for both tuples and indexes (as configured in :ref:`memtx_memory <cfg_storage-"
"memtx_memory>` parameter, e.g. the default is 1 gigabyte = 2^30 bytes = "
"1,073,741,824 bytes);"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:107
msgid "``quota_used_ratio`` = ``quota_used`` / ``quota_size``;"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:108
msgid "``arena_used_ratio`` = ``arena_used`` / ``arena_size``;"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:109
msgid ""
"``items_used`` is the *efficient* amount of memory (omitting allocated, but "
"currently free slabs) used only for tuples, no indexes;"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:111
msgid ""
"``quota_used`` is the amount of memory that is already distributed to the slab "
"allocator;"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:113
msgid ""
"``arena_size`` is the *total* memory used for tuples and indexes together "
"(including allocated, but currently free slabs);"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:115
msgid ""
"``arena_used`` is the *efficient* memory used for storing tuples and indexes "
"together (omitting allocated, but currently free slabs)."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:122
msgid ""
"tarantool> box.slab.info()\n"
"---\n"
"- items_size: 228128\n"
"  items_used_ratio: 1.8%\n"
"  quota_size: 1073741824\n"
"  quota_used_ratio: 0.8%\n"
"  arena_used_ratio: 43.2%\n"
"  items_used: 4208\n"
"  quota_used: 8388608\n"
"  arena_size: 2325176\n"
"  arena_used: 1003632\n"
"...\n"
"\n"
"tarantool> box.slab.info().arena_used\n"
"---\n"
"- 1003632\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:146
msgid ""
"Show a detailed memory usage report (in bytes) for the slab allocator. The "
"report is broken down into groups by *data item size* as well as by *slab size* "
"(64-byte, 136-byte, etc). The report includes the memory allocated for storing "
"both tuples and indexes."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:153
msgid "``mem_free`` is the allocated, but currently unused memory;"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:154
msgid ""
"``mem_used`` is the memory used for storing data items (tuples and indexes);"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:155
msgid "``item_count`` is the number of stored items;"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:156
msgid "``item_size`` is the size of each data item;"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:157
msgid "``slab_count`` is the number of slabs allocated;"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:158
msgid "``slab_size`` is the size of each allocated slab."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:164
msgid "Here is a sample report for the first group:"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:166
msgid ""
"tarantool> box.slab.stats()[1]\n"
"---\n"
"- mem_free: 16232\n"
"  mem_used: 48\n"
"  item_count: 2\n"
"  item_size: 24\n"
"  slab_count: 1\n"
"  slab_size: 16384\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:178
msgid ""
"This report is saying that there are 2 data items (``item_count`` = 2) stored in "
"one (``slab_count`` = 1) 24-byte slab (``item_size`` = 24), so ``mem_used`` = 2 "
"* 24 = 48 bytes. Also, ``slab_size`` is 16384 bytes, of which 16384 - 48 = 16232 "
"bytes are free (``mem_free``)."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:183
msgid "A complete report would show memory usage statistics for all groups:"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:185
msgid ""
"tarantool> box.slab.stats()\n"
"---\n"
"- - mem_free: 16232\n"
"    mem_used: 48\n"
"    item_count: 2\n"
"    item_size: 24\n"
"    slab_count: 1\n"
"    slab_size: 16384\n"
"  - mem_free: 15720\n"
"    mem_used: 560\n"
"    item_count: 14\n"
"    item_size: 40\n"
"    slab_count: 1\n"
"    slab_size: 16384\n"
"  <...>\n"
"  - mem_free: 32472\n"
"    mem_used: 192\n"
"    item_count: 1\n"
"    item_size: 192\n"
"    slab_count: 1\n"
"    slab_size: 32768\n"
"  - mem_free: 1097624\n"
"    mem_used: 999424\n"
"    item_count: 61\n"
"    item_size: 16384\n"
"    slab_count: 1\n"
"    slab_size: 2097152\n"
"  ..."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:216
msgid ""
"The total ``mem_used`` for all groups in this report equals ``arena_used`` in :"
"ref:`box.slab.info() <box_slab_info>` report."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:39
msgid "Submodule `box.space`"
msgstr "Вложенный модуль `box.space`"

#: ../doc/1.7/book/box/box_space.rst:41
msgid ""
"The ``box.space`` submodule has the data-manipulation functions ``select``, "
"``insert``, ``replace``, ``update``, ``upsert``, ``delete``, ``get``, ``put``. "
"It also has members, such as id, and whether or not a space is enabled. "
"Submodule source code is available in file `src/box/lua/schema.lua <https://"
"github.com/tarantool/tarantool/blob/1.7/src/box/lua/schema.lua>`_."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:47
msgid ""
"A list of all ``box.space`` functions follows, then comes a list of all ``box."
"space`` members."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:50
msgid "**The functions and members of box.space**"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:58
msgid "Use"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:60
msgid ":ref:`space_object:auto_increment() <box_space-auto_increment>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:60
msgid "Generate key + Insert a tuple"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:63
msgid ":ref:`space_object:bsize() <box_space-bsize>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:63
msgid "Get count of bytes"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:66
msgid ":ref:`space_object:count() <box_space-count>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:66 ../doc/1.7/book/box/box_space.rst:84
msgid "Get count of tuples"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:69
msgid ":ref:`space_object:create_index() <box_space-create_index>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:69
msgid "Create an index"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:72
msgid ":ref:`space_object:delete() <box_space-delete>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:72
msgid "Delete a tuple"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:75
msgid ":ref:`space_object:drop() <box_space-drop>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:75
msgid "Destroy a space"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:78
msgid ":ref:`space_object:get() <box_space-get>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:78
msgid "Select a tuple"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:81
msgid ":ref:`space_object:insert() <box_space-insert>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:81
msgid "Insert a tuple"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:84
msgid ":ref:`space_object:len() <box_space-len>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:87
msgid ":ref:`space_object:on_replace() <box_space-on_replace>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:87
msgid "Create a replace trigger"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:90
msgid ":ref:`space_object:pairs() <box_space-pairs>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:90
msgid "Prepare for iterating"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:93
msgid ":ref:`space_object:put() <box_space-replace>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:93 ../doc/1.7/book/box/box_space.rst:99
msgid "Insert or replace a tuple"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:96
msgid ":ref:`space_object:rename() <box_space-rename>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:96
msgid "Rename a space"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:99
msgid ":ref:`space_object:replace() <box_space-replace>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:102
msgid ":ref:`space_object:run_triggers() <box_space-run_triggers>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:102
msgid "Enable/disable a replace trigger"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:105
msgid ":ref:`space_object:select() <box_space-select>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:105
msgid "Select one or more tuples"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:108
msgid ":ref:`space_object:truncate() <box_space-truncate>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:108
msgid "Delete all tuples"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:111
msgid ":ref:`space_object:update() <box_space-update>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:111 ../doc/1.7/book/box/box_space.rst:114
msgid "Update a tuple"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:114
msgid ":ref:`space_object:upsert() <box_space-upsert>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:117
msgid ":ref:`space_object.enabled <box_space-enabled>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:117
msgid "Flag, true if space is enabled"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:120
msgid ":ref:`space_object.field_count <box_space-field_count>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:120
msgid "Required number of fields"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:123
msgid ":ref:`space_object.id <box_space-id>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:123
msgid "Numeric identifier of space"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:126
msgid ":ref:`space_object.index <box_space-field_count>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:126
msgid "Container of space's indexes"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:129
msgid ":ref:`box.space._cluster <box_space-cluster>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:129
msgid "(Metadata) List of replica sets"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:132
msgid ":ref:`box.space._func <box_space-func>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:132
msgid "(Metadata) List of function tuples"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:135
msgid ":ref:`box.space._index <box_space-index>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:135
msgid "(Metadata) List of indexes"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:138
msgid ":ref:`box.space._priv <box_space-priv>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:138
msgid "(Metadata) List of privileges"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:141
msgid ":ref:`box.space._schema <box_space-schema>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:141
msgid "(Metadata) List of schemas"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:144
msgid ":ref:`box.space._space <box_space-space>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:144
msgid "(Metadata) List of spaces"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:147
msgid ":ref:`box.space._user <box_space-user>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:147
msgid "(Metadata) List of users"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:159
msgid ""
"Insert a new tuple using an auto-increment primary key. The space specified by "
"space_object must have an :ref:`'unsigned' or 'integer' or 'number' <index-"
"box_indexed-field-types>` primary key index of type ``TREE``. The primary-key "
"field will be incremented before the insert."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:165 ../doc/1.7/book/box/box_space.rst:195
#: ../doc/1.7/book/box/box_space.rst:221 ../doc/1.7/book/box/box_space.rst:247
#: ../doc/1.7/book/box/box_space.rst:412 ../doc/1.7/book/box/box_space.rst:450
#: ../doc/1.7/book/box/box_space.rst:472 ../doc/1.7/book/box/box_space.rst:504
#: ../doc/1.7/book/box/box_space.rst:532 ../doc/1.7/book/box/box_space.rst:625
#: ../doc/1.7/book/box/box_space.rst:680 ../doc/1.7/book/box/box_space.rst:710
#: ../doc/1.7/book/box/box_space.rst:763 ../doc/1.7/book/box/box_space.rst:837
#: ../doc/1.7/book/box/box_space.rst:897 ../doc/1.7/book/box/box_space.rst:1014
msgid "an :ref:`object reference <app_server-object_reference>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:167
msgid "tuple's fields, other than the primary-key field"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:170 ../doc/1.7/book/box/box_space.rst:714
msgid "the inserted tuple."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:173
msgid ""
"**Complexity factors:** Index size, Index type, Number of indexes accessed, :ref:"
"`WAL settings <cfg_binary_logging_snapshots-rows_per_wal>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:176
msgid ""
"**Possible errors:** index has wrong type or primary-key indexed field is not a "
"number."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:180
msgid ""
"tarantool> box.space.tester:auto_increment{'Fld#1', 'Fld#2'}\n"
"---\n"
"- [1, 'Fld#1', 'Fld#2']\n"
"...\n"
"tarantool> box.space.tester:auto_increment{'Fld#3'}\n"
"---\n"
"- [2, 'Fld#3']\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:198
msgid "Number of bytes in the space."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:202
#, fuzzy
msgid ""
"tarantool> box.space.tester:bsize()\n"
"---\n"
"- 22\n"
"..."
msgstr "tarantool> {**{box.space.tester:select{2}}**}"

#: ../doc/1.7/book/box/box_space.rst:209
#, fuzzy
msgid "Note re storage engine: vinyl does not support ``bsize()``."
msgstr ""
"Примечание про движок: при организации резервирования для баз данных на движке "
"vinyl понадобятся дополнительные действия."

#: ../doc/1.7/book/box/box_space.rst:216
msgid ""
"Return the number of tuples. If compared with :ref:`len() <box_space-len>`, this "
"method works slower because ``count()`` scans the entire space to count the "
"tuples."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:223 ../doc/1.7/book/box/box_space.rst:414
#: ../doc/1.7/book/box/box_space.rst:899
msgid ""
"primary-key field values, must be passed as a Lua table if key is multi-part"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:227
msgid "Number of tuples."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:231
msgid ""
"tarantool> box.space.tester:count(2, {iterator='GE'})\n"
"---\n"
"- 1\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:242
msgid ""
"Create an :ref:`index <index-box_index>`. It is mandatory to create an index for "
"a space before trying to insert tuples into it, or select tuples from it. The "
"first created index, which will be used as the primary-key index, must be unique."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:249
msgid ""
"name of index, which should not be a number and should not contain special "
"characters"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:253
msgid "index object"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:254
msgid "index_object"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:258
msgid "Options for ``space_object:create_index``:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:268
msgid "type"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:268
msgid "type of index"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:268
msgid "string ('HASH' or 'TREE' or 'BITSET' or 'RTREE')"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:268
msgid "'TREE'"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:272
msgid "unique identifier"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:272
msgid "last index's id, +1"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:274
msgid "unique"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:274
msgid "index is unique"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:274
msgid "``true``"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:276
msgid "no error if duplicate name"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:276
msgid "``false``"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:278
msgid "parts"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:278
msgid "field-numbers  + types"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:278
msgid ""
"{field_no, 'unsigned' or 'string' or 'integer' or 'number' or 'boolean' or "
"'array' or 'scalar'}"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:278
msgid "``{1, 'unsigned'}``"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:283
msgid "dimension"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:283
msgid "affects :ref:`RTREE <box_index-rtree>` only"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:283 ../doc/1.7/book/box/box_space.rst:1417
msgid "2"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:285
msgid "distance"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:285
msgid "affects RTREE only"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:285
msgid "string ('euclid' or 'manhattan')"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:285
msgid "'euclid'"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:288
msgid "bloom_fpr"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:288 ../doc/1.7/book/box/box_space.rst:290
#: ../doc/1.7/book/box/box_space.rst:292 ../doc/1.7/book/box/box_space.rst:294
#: ../doc/1.7/book/box/box_space.rst:296
msgid "affects vinyl only"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:288
#, fuzzy
msgid "``vinyl_bloom_fpr``"
msgstr "``vinyl_dir``"

#: ../doc/1.7/book/box/box_space.rst:290
msgid "page_size"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:290
#, fuzzy
msgid "``vinyl_page_size``"
msgstr "``vinyl_dir``"

#: ../doc/1.7/book/box/box_space.rst:292
msgid "range_size"
msgstr "range_size"

#: ../doc/1.7/book/box/box_space.rst:292
#, fuzzy
msgid "``vinyl_range_size``"
msgstr "``vinyl_dir``"

#: ../doc/1.7/book/box/box_space.rst:294
msgid "run_count_per_level"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:294
msgid "``vinyl_run_count_per_level``"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:296
msgid "run_size_ratio"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:296
#, fuzzy
msgid "``vinyl_run_size_ratio``"
msgstr "``vinyl_dir``"

#: ../doc/1.7/book/box/box_space.rst:299
msgid ""
"Note re storage engine: vinyl has extra options which by default are based on "
"configuration parameters :ref:`vinyl_bloom_fpr <cfg_storage-vinyl_bloom_fpr>`, :"
"ref:`vinyl_page_size <cfg_storage-vinyl_page_size>`, :ref:`vinyl_range_size "
"<cfg_storage-vinyl_range_size>`, :ref:`vinyl_run_count_per_level <cfg_storage-"
"vinyl_run_count_per_level>`, and :ref:`vinyl_run_size_ratio <cfg_storage-"
"vinyl_run_size_ratio>` -- see the description of those parameters. The current "
"values can be seen by selecting from :ref:`box.space._index <box_space-index>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:310
msgid ""
"**Possible errors:** too many parts. Index '...' already exists. Primary key "
"must be unique."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:312
msgid ""
"tarantool> s = box.space.space55\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {unique = true, parts = {1, 'unsigned', 2, "
"'string'}})\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:323
msgid "Details about index field types:"
msgstr "Подробнее о типах индексируемых полей:"

#: ../doc/1.7/book/box/box_space.rst:325
msgid ""
"The seven index field types (unsigned | string | integer | number | boolean | "
"array | scalar) differ depending on what values are allowed, and what index "
"types are allowed."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:329
msgid ""
"**unsigned**: unsigned integers between 0 and 18446744073709551615, about 18 "
"quintillion. May also be called 'uint' or 'num', but 'num' is deprecated. Legal "
"in memtx TREE or HASH indexes, and in vinyl TREE indexes."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:333
msgid ""
"**string**: any set of octets, up to the :ref:`maximum length "
"<limitations_bytes_in_index_key>`. May also be called 'str'. Legal in memtx TREE "
"or HASH or BITSET indexes, and in vinyl TREE indexes."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:336
msgid ""
"**integer**: integers between -9223372036854775808 and 18446744073709551615. May "
"also be called 'int'. Legal in memtx TREE or HASH indexes, and in vinyl TREE "
"indexes."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:339
msgid ""
"**number**: integers between -9223372036854775808 and 18446744073709551615, "
"single-precision floating point numbers, or double-precision floating point "
"numbers. Legal in memtx TREE or HASH indexes, and in vinyl TREE indexes."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:343
msgid ""
"**boolean**: true or false. Legal in memtx TREE or HASH indexes, and in vinyl "
"TREE indexes."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:345
msgid ""
"**array**: array of numbers. Legal in memtx :ref:`RTREE <box_index-rtree>` "
"indexes."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:346
msgid ""
"**scalar**: booleans (true or false), or integers between -9223372036854775808 "
"and 18446744073709551615, or single-precision floating point numbers, or double-"
"precison floating-point numbers, or strings. When there is a mix of types, the "
"key order is: booleans, then numbers, then strings. Legal in memtx TREE or HASH "
"indexes, and in vinyl TREE indexes."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:355
msgid "**Index field types to use in create_index**"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:364
msgid "Index field type"
msgstr "Тип поля для индексирования"

#: ../doc/1.7/book/box/box_space.rst:364
msgid "What can be in it"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:364
msgid "Where is it legal"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:364 ../doc/1.7/book/box/data_model.rst:302
#: ../doc/1.7/reference/reference_lua/socket.rst:592
msgid "Examples"
msgstr "Примеры"

#: ../doc/1.7/book/box/box_space.rst:366
msgid "**unsigned**"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:366
msgid "integers between 0 and 18446744073709551615"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:366 ../doc/1.7/book/box/box_space.rst:373
#: ../doc/1.7/book/box/box_space.rst:377 ../doc/1.7/book/box/box_space.rst:385
#: ../doc/1.7/book/box/box_space.rst:392
msgid "memtx TREE or HASH indexes, |br| vinyl TREE indexes"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:366
msgid "123456 |br|"
msgstr "123456 |br|"

#: ../doc/1.7/book/box/box_space.rst:370
msgid "**string**"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:370
msgid "strings -- any set of octets"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:370
msgid "memtx TREE or HASH indexes |br| vinyl TREE indexes"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:370
msgid "'A B C' |br| '\\\\65 \\\\66 \\\\67'"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:373
msgid "**integer**"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:373
msgid "integers between -9223372036854775808 and 18446744073709551615"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:373
msgid "-2^63 |br|"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:377 ../doc/1.7/book/box/data_model.rst:315
msgid "**number**"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:377
msgid ""
"integers between -9223372036854775808 and 18446744073709551615, single-precision "
"floating point numbers, double-precision floating point numbers"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:377
msgid "1.234 |br| -44 |br| 1.447e+44"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:385 ../doc/1.7/book/box/data_model.rst:329
msgid "**boolean**"
msgstr "**boolean**"

#: ../doc/1.7/book/box/box_space.rst:385
#: ../doc/1.7/reference/reference_lua/string.rst:140
#: ../doc/1.7/reference/reference_lua/string.rst:170
msgid "true or false"
msgstr "true  / false"

#: ../doc/1.7/book/box/box_space.rst:385
msgid "false |br| true"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:388 ../doc/1.7/book/box/data_model.rst:332
msgid "**array**"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:388
msgid "array of integers between -9223372036854775808 and 9223372036854775807"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:388
msgid "memtx RTREE indexes"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:388
msgid "{10, 11} |br| {3, 5, 9, 10}"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:392 ../doc/1.7/book/box/data_model.rst:337
msgid "**scalar**"
msgstr "**scalar**"

#: ../doc/1.7/book/box/box_space.rst:392
msgid ""
"booleans (true or false), integers between -9223372036854775808 and "
"18446744073709551615, single-precision floating point numbers, double-precision "
"floating point numbers, strings"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:392
msgid "true |br| -1 |br| 1.234 |br| '' |br| 'ру'"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:402
msgid ""
"Note re storage engine: vinyl supports only the TREE index type, and vinyl "
"secondary indexes must be created before tuples are inserted."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:410
msgid "Delete a tuple identified by a primary key."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:417
msgid "the deleted tuple"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:420
msgid "**Complexity factors:** Index size, Index type"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst
msgid "vinyl will return ``nil``, rather than the deleted tuple."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:429
msgid ""
"tarantool> box.space.tester:delete(1)\n"
"---\n"
"- [1, 'My first tuple']\n"
"...\n"
"tarantool> box.space.tester:delete(1)\n"
"---\n"
"...\n"
"tarantool> box.space.tester:delete('a')\n"
"---\n"
"- error: 'Supplied key type of part 0 does not match index part type:\n"
"  expected unsigned'\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:448
msgid "Drop a space."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:455
msgid "**Possible errors:** If ``space_object`` does not exist."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:457 ../doc/1.7/book/box/box_space.rst:482
#: ../doc/1.7/book/box/box_space.rst:721
msgid ""
"**Complexity factors:** Index size, Index type, Number of indexes accessed, WAL "
"settings."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:462
msgid "box.space.space_that_does_not_exist:drop()"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:470
msgid "Search for a tuple in the given space."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:474 ../doc/1.7/book/box/box_space.rst:765
msgid "value to be matched against the index key, which may be multi-part."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:477
msgid "the tuple whose index key matches ``key``, or ``nil``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:480
msgid "**Possible errors:** If space_object does not exist."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:485
msgid ""
"The ``box.space...select`` function returns a set of tuples as a Lua table; the "
"``box.space...get`` function returns at most a single tuple. And it is possible "
"to get the first tuple in a space by appending ``[1]``. Therefore ``box.space."
"tester:get{1}`` has the same effect as ``box.space.tester:select{1}[1]``, if "
"exactly one tuple is found."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:493
msgid "box.space.tester:get{1}"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:502
msgid "Insert a tuple into a space."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:506
msgid "tuple to be inserted."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:508
msgid "the inserted tuple"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:511
msgid ""
"**Possible errors:** If a tuple with the same unique-key value already exists, "
"returns :errcode:`ER_TUPLE_FOUND`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:516
msgid ""
"tarantool> box.space.tester:insert{5000,'tuple number five thousand'}\n"
"---\n"
"- [5000, 'tuple number five thousand']\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:527
msgid ""
"Return the number of tuples in the space. If compared with :ref:`count() "
"<box_space-count>`, this method works faster because ``len()`` does not scan the "
"entire space to count the tuples."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:535
msgid "Number of tuples in the space."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:539
msgid ""
"tarantool> box.space.tester:len()\n"
"---\n"
"- 2\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:546
msgid ""
"Note re storage engine: vinyl does not support ``len()``. Possible workarounds "
"are to use :ref:`count() <box_space-count>` or ``#select(...)``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:554
msgid ""
"Create a \"replace :ref:`trigger <triggers>`\". The ``trigger-function`` will be "
"executed whenever a ``replace()`` or ``insert()`` or ``update()`` or "
"``upsert()`` or ``delete()`` happens to a tuple in ``<space-name>``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:568
msgid ""
"If it is necessary to know whether the trigger activation happened due to "
"replication or on a specific connection type, the function can refer to :ref:"
"`box.session.type() <box_session-type>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:574 ../doc/1.7/book/box/box_space.rst:1304
#, fuzzy
msgid "**Example #1:**"
msgstr "**Примеры:**"

#: ../doc/1.7/book/box/box_space.rst:576
msgid ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.space.X:on_replace(f)"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:583
msgid ""
"The ``trigger-function`` can have two parameters: old tuple, new tuple. For "
"example, the following code causes nil to be printed when the insert request is "
"processed, and causes [1, 'Hi'] to be printed when the delete request is "
"processed:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:588
msgid ""
"box.schema.space.create('space_1')\n"
"box.space.space_1:create_index('space_1_index',{})\n"
"function on_replace_function (old, new) print(old) end\n"
"box.space.space_1:on_replace(on_replace_function)\n"
"box.space.space_1:insert{1,'Hi'}\n"
"box.space.space_1:delete{1}"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:597 ../doc/1.7/book/box/box_space.rst:1349
#, fuzzy
msgid "**Example #2:**"
msgstr "**Примеры:**"

#: ../doc/1.7/book/box/box_space.rst:599
msgid ""
"The following series of requests will create a space, create an index, create a "
"function which increments a counter, create a trigger, do two inserts, drop the "
"space, and display the counter value - which is 2, because the function is "
"executed once after each insert."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:604
msgid ""
"tarantool> s = box.schema.space.create('space53')\n"
"tarantool> s:create_index('primary', {parts = {1, 'unsigned'}})\n"
"tarantool> function replace_trigger()\n"
"         >   replace_counter = replace_counter + 1\n"
"         > end\n"
"tarantool> s:on_replace(replace_trigger)\n"
"tarantool> replace_counter = 0\n"
"tarantool> t = s:insert{1, 'First replace'}\n"
"tarantool> t = s:insert{2, 'Second replace'}\n"
"tarantool> s:drop()\n"
"tarantool> replace_counter"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:622
msgid ""
"Search for a tuple or a set of tuples in the given space, and allow iterating "
"over one tuple at a time."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:629
msgid "see :ref:`index_object:pairs <box_index-index_pairs>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:636 ../doc/1.7/book/box/box_space.rst:775
msgid "**Possible errors:** No such space; wrong type."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:640
msgid ""
"For examples of complex ``pairs`` requests, where one can specify which index to "
"search and what condition to use (for example \"greater than\" instead of "
"\"equal to\"), see the later section :ref:`index_object:pairs <box_index-"
"index_pairs>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:647
msgid ""
"tarantool> s = box.schema.space.create('space33')\n"
"---\n"
"...\n"
"tarantool> -- index 'X' has default parts {1, 'unsigned'}\n"
"tarantool> s:create_index('X', {})\n"
"---\n"
"...\n"
"tarantool> s:insert{0, 'Hello my '}, s:insert{1, 'Lua world'}\n"
"---\n"
"- [0, 'Hello my ']\n"
"- [1, 'Lua world']\n"
"...\n"
"tarantool> tmp = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in s:pairs() do\n"
"         >   tmp = tmp .. v[2]\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> tmp\n"
"---\n"
"- Hello my Lua world\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:678
msgid "Rename a space."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:682
msgid "new name for space"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:686
msgid "**Possible errors:** ``space_object`` does not exist."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:690
msgid ""
"tarantool> box.space.space55:rename('space56')\n"
"---\n"
"...\n"
"tarantool> box.space.space56:rename('space55')\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:704
msgid ""
"Insert a tuple into a space. If a tuple with the same primary key already "
"exists, ``box.space...:replace()`` replaces the existing tuple with a new one. "
"The syntax variants ``box.space...:replace()`` and ``box.space...:put()`` have "
"the same effect; the latter is sometimes used to show that the effect is the "
"converse of ``box.space...:get()``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:712
msgid "tuple to be inserted"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:717
msgid ""
"**Possible errors:** If a different tuple with the same unique-key value already "
"exists, returns :errcode:`ER_TUPLE_FOUND`. (This will only happen if there is a "
"unique secondary index.)"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:726
msgid "box.space.tester:replace{5000, 'tuple number five thousand'}"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:735
msgid ""
"At the time that a :ref:`trigger <triggers>` is defined, it is automatically "
"enabled - that is, it will be executed. :ref:`Replace <box_space-on_replace>` "
"triggers can be disabled with :samp:`box.space.{space-name}:run_triggers(false)` "
"and re-enabled with :samp:`box.space.{space-name}:run_triggers(true)`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:744
msgid ""
"The following series of requests will associate an existing function named F "
"with an existing space named T, associate the function a second time with the "
"same space (so it will be called twice), disable all triggers of T, and delete "
"each trigger by replacing with ``nil``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:749
msgid ""
"tarantool> box.space.T:on_replace(F)\n"
"tarantool> box.space.T:on_replace(F)\n"
"tarantool> box.space.T:run_triggers(false)\n"
"tarantool> box.space.T:on_replace(nil, F)\n"
"tarantool> box.space.T:on_replace(nil, F)"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:761
msgid "Search for a tuple or a set of tuples in the given space."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:768
msgid ""
"the tuples whose primary-key fields are equal to the fields of the passed key. "
"If the number of passed fields is less than the number of fields in the primary "
"key, then only the passed fields are compared, so ``select{1,2}`` will match a "
"tuple whose primary key is ``{1,2,3}``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:781
msgid ""
"tarantool> s = box.schema.space.create('tmp', {temporary=true})\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary',{parts = {1,'unsigned', 2, 'string'}})\n"
"---\n"
"...\n"
"tarantool> s:insert{1,'A'}\n"
"---\n"
"- [1, 'A']\n"
"...\n"
"tarantool> s:insert{1,'B'}\n"
"---\n"
"- [1, 'B']\n"
"...\n"
"tarantool> s:insert{1,'C'}\n"
"---\n"
"- [1, 'C']\n"
"...\n"
"tarantool> s:insert{2,'D'}\n"
"---\n"
"- [2, 'D']\n"
"...\n"
"tarantool> -- must equal both primary-key fields\n"
"tarantool> s:select{1,'B'}\n"
"---\n"
"- - [1, 'B']\n"
"...\n"
"tarantool> -- must equal only one primary-key field\n"
"tarantool> s:select{1}\n"
"---\n"
"- - [1, 'A']\n"
"  - [1, 'B']\n"
"  - [1, 'C']\n"
"...\n"
"tarantool> -- must equal 0 fields, so returns all tuples\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 'A']\n"
"  - [1, 'B']\n"
"  - [1, 'C']\n"
"  - [2, 'D']\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:826
msgid ""
"For examples of complex ``select`` requests, where one can specify which index "
"to search and what condition to use (for example \"greater than\" instead of "
"\"equal to\") and how many tuples to return, see the later section :ref:"
"`index_object:select <box_index-select>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:835
msgid "Deletes all tuples."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:846
msgid ""
"Note that ``truncate`` must be called only by the user who created the space OR "
"under a `setuid` function created by that user. Read more about `setuid` "
"functions in reference on :ref:`box.schema.func.create() <box_schema-"
"func_create>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:853
msgid ""
"tarantool> box.space.tester:truncate()\n"
"---\n"
"...\n"
"tarantool> box.space.tester:len()\n"
"---\n"
"- 0\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:869
msgid ""
"The ``update`` function supports operations on fields — assignment, arithmetic "
"(if the field is numeric), cutting and pasting fragments of a field, deleting or "
"inserting a field. Multiple operations can be combined in a single update "
"request, and in this case they are performed atomically and sequentially. Each "
"operation requires specification of a field number. When multiple operations are "
"present, the field number for each operation is assumed to be relative to the "
"most recent state of the tuple, that is, as if all previous operations in a "
"multi-operation update have already been applied. In other words, it is always "
"safe to merge multiple ``update`` invocations into a single invocation, with no "
"change in semantics."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:881
msgid "Possible operators are:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:883
msgid "``+`` for addition (values must be numeric)"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:884
msgid "``-`` for subtraction (values must be numeric)"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:885
msgid "``&`` for bitwise AND (values must be unsigned numeric)"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:886
msgid "``|`` for bitwise OR (values must be unsigned numeric)"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:887
msgid ""
"``^`` for bitwise :abbr:`XOR(exclusive OR)` (values must be unsigned numeric)"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:889
msgid "``:`` for string splice"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:890
msgid "``!`` for insertion"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:891
msgid "``#`` for deletion"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:892
msgid "``=`` for assignment"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:894
msgid ""
"For ``!`` and ``=`` operations the field number can be ``-1``, meaning the last "
"field in the tuple."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:911
msgid "**Possible errors:** it is illegal to modify a primary-key field."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:913 ../doc/1.7/book/box/box_space.rst:1030
msgid ""
"**Complexity factors:** Index size, Index type, number of indexes accessed, WAL "
"settings."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:916
msgid "Thus, in the instruction:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:918
msgid "s:update(44, {{'+', 1, 55 }, {'=', 3, 'x'}})"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:922
msgid ""
"the primary-key value is ``44``, the operators are ``'+'`` and ``'='`` meaning "
"*add a value to a field and then assign a value to a field*, the first affected "
"field is field ``1`` and the value which will be added to it is ``55``, the "
"second affected field is field ``3`` and the value which will be assigned to it "
"is ``'x'``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:930
msgid ""
"Assume that initially there is a space named ``tester`` with a primary-key index "
"whose type is ``unsigned``. There is one tuple, with ``field[1]`` = ``999`` and "
"``field[2]`` = ``'A'``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:934
msgid ""
"In the update: |br| ``box.space.tester:update(999, {{'=', 2, 'B'}})`` |br| The "
"first argument is ``tester``, that is, the affected space is ``tester``. The "
"second argument is ``999``, that is, the affected tuple is identified by primary "
"key value = 999. The third argument is ``=``, that is, there is one operation — "
"*assignment to a field*. The fourth argument is ``2``, that is, the affected "
"field is ``field[2]``. The fifth argument is ``'B'``, that is, ``field[2]`` "
"contents change to ``'B'``. Therefore, after this update, ``field[1]`` = ``999`` "
"and ``field[2]`` = ``'B'``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:945
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'=', 2, 'B'}})`` |br| the "
"arguments are the same, except that the key is passed as a Lua table (inside "
"braces). This is unnecessary when the primary key has only one field, but would "
"be necessary if the primary key had more than one field. Therefore, after this "
"update, ``field[1]`` = ``999`` and ``field[2]`` = ``'B'`` (no change)."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:952
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'=', 3, 1}})`` |br| the "
"arguments are the same, except that the fourth argument is ``3``, that is, the "
"affected field is ``field[3]``. It is okay that, until now, ``field[3]`` has not "
"existed. It gets added. Therefore, after this update, ``field[1]`` = ``999``, "
"``field[2]`` = ``'B'``, ``field[3]`` = ``1``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:959
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'+', 3, 1}})`` |br| the "
"arguments are the same, except that the third argument is ``'+'``, that is, the "
"operation is addition rather than assignment. Since ``field[3]`` previously "
"contained ``1``, this means we're adding ``1`` to ``1``. Therefore, after this "
"update, ``field[1]`` = ``999``, ``field[2]`` = ``'B'``, ``field[3]`` = ``2``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:967
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'|', 3, 1}, {'=', 2, "
"'C'}})`` |br| the idea is to modify two fields at once. The formats are ``'|'`` "
"and ``=``, that is, there are two operations, OR and assignment. The fourth and "
"fifth arguments mean that ``field[3]`` gets OR'ed with ``1``. The seventh and "
"eighth arguments mean that ``field[2]`` gets assigned ``'C'``. Therefore, after "
"this update, ``field[1]`` = ``999``, ``field[2]`` = ``'C'``, ``field[3]`` = "
"``3``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:976
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'#', 2, 1}, {'-', 2, "
"3}})`` |br| The idea is to delete ``field[2]``, then subtract ``3`` from "
"``field[3]``. But after the delete, there is a renumbering, so ``field[3]`` "
"becomes ``field[2]`` before we subtract ``3`` from it, and that's why the "
"seventh argument is ``2``, not ``3``. Therefore, after this update, ``field[1]`` "
"= ``999``, ``field[2]`` = ``0``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:984
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'=', 2, 'XYZ'}})`` |br| "
"we're making a long string so that splice will work in the next example. "
"Therefore, after this update, ``field[1]`` = ``999``, ``field[2]`` = ``'XYZ'``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:989
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{':', 2, 2, 1, '!!'}})`` |"
"br| The third argument is ``':'``, that is, this is the example of splice. The "
"fourth argument is ``2`` because the change will occur in ``field[2]``. The "
"fifth argument is 2 because deletion will begin with the second byte. The sixth "
"argument is 1 because the number of bytes to delete is 1. The seventh argument "
"is ``'!!'``, because ``'!!'`` is to be added at this position. Therefore, after "
"this update, ``field[1]`` = ``999``, ``field[2]`` = ``'X!!Z'``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1002
msgid "Update or insert a tuple."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1004
msgid ""
"If there is an existing tuple which matches the key fields of ``tuple_value``, "
"then the request has the same effect as :ref:`space_object:update() <box_space-"
"update>` and the ``{{operator, field_no, value}, ...}`` parameter is used. If "
"there is no existing tuple which matches the key fields of ``tuple_value``, then "
"the request has the same effect as :ref:`space_object:insert() <box_space-"
"insert>` and the ``{tuple_value}`` parameter is used. However, unlike ``insert`` "
"or ``update``, ``upsert`` will not read a tuple and perform error checks before "
"returning -- this is a design feature which enhances throughput but requires "
"more caution on the part of the user."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1016
msgid "default tuple to be inserted, if analogue isn't found"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1025
msgid "null"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1027
msgid ""
"**Possible errors:** it is illegal to modify a primary-key field. It is illegal "
"to use upsert with a space that has a unique secondary index."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1035
msgid "box.space.tester:upsert({12,'c'}, {{'=', 3, 'a'}, {'=', 4, 'b'}})"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1048
msgid ""
"Whether or not this space is enabled. The value is ``false`` if the space has no "
"index."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1055
msgid ""
"The required field count for all tuples in this space. The field_count can be "
"set initially with:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1061
msgid ""
"box.schema.space.create(..., {\n"
"    ... ,\n"
"    field_count = *field_count_value* ,\n"
"    ...\n"
"})"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1067
msgid "The default value is ``0``, which means there is no required field count."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1071
msgid ""
"tarantool> box.space.tester.field_count\n"
"---\n"
"- 0\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1083
msgid ""
"Ordinal space number. Spaces can be referenced by either name or number. Thus, "
"if space ``tester`` has ``id = 800``, then ``box.space.tester:insert{0}`` and "
"``box.space[800]:insert{0}`` are equivalent requests."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1090
msgid ""
"tarantool> box.space.tester.id\n"
"---\n"
"- 512\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1099
msgid ""
"A container for all defined indexes. There is a Lua object of type :ref:`box."
"index <box_index>` with methods to search tuples and iterate over them in "
"predefined order."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1107
msgid ""
"tarantool> #box.space.tester.index\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> box.space.tester.index.primary.type\n"
"---\n"
"- TREE\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1122
msgid ""
"``_cluster`` is a system space for support of the :ref:`replication feature "
"<replication>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1129
msgid ""
"``_func`` is a system space with function tuples made by :ref:`box.schema.func."
"create() <box_schema-func_create>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1132 ../doc/1.7/book/box/box_space.rst:1185
#: ../doc/1.7/book/box/box_space.rst:1223 ../doc/1.7/book/box/box_space.rst:1294
#: ../doc/1.7/book/box/box_space.rst:1388
msgid "Tuples in this space contain the following fields:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1134
msgid "the numeric function id, a number,"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1135
msgid "the function name,"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1136
msgid "flag,"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1137
msgid "a language name (optional): 'LUA' (default) or 'C'."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1139
msgid ""
"The ``_func`` space does not include the function’s body. You continue to create "
"Lua functions in the usual way, by saying ``function function_name () ... end``, "
"without adding anything in the ``_func`` space. The ``_func`` space only exists "
"for storing function tuples so that their names can be used within :ref:`grant/"
"revoke <authentication-owners_privileges>` functions."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1147 ../doc/1.7/book/box/box_space.rst:1232
msgid "You can:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1149
msgid ""
"Create a ``_func`` tuple with :ref:`box.schema.func.create() <box_schema-"
"func_create>`,"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1151
msgid ""
"Drop a ``_func`` tuple with :ref:`box.schema.func.drop() <box_schema-func_drop>`,"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1153
msgid ""
"Check whether a ``_func`` tuple exists with :ref:`box.schema.func.exists() "
"<box_schema-func_exists>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1158
msgid ""
"In the following example, we create a function named ‘f7’, put it into "
"Tarantool's ``_func`` space and grant 'execute' privilege for this function to "
"'guest' user."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1162
msgid ""
"tarantool> function f7()\n"
"         >  box.session.uid()\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> box.schema.func.create('f7')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('guest', 'execute', 'function', 'f7')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.revoke('guest', 'execute', 'function', 'f7')\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1183
msgid "``_index`` is a system space."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1187
msgid "``id`` (= id of space),"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1188
msgid "``iid`` (= index number within space),"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1189
msgid "``name``,"
msgstr "``name``,"

#: ../doc/1.7/book/box/box_space.rst:1190
msgid "``type``,"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1191
msgid ""
"``opts`` (e.g. unique option), [``tuple-field-no``, ``tuple-field-type`` ...]."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1193
msgid "Here is what ``_index`` contains in a typical installation:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1195
msgid ""
"tarantool> box.space._index:select{}\n"
"---\n"
"- - [272, 0, 'primary', 'tree', {'unique': true}, [[0, 'string']]]\n"
"  - [280, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned']]]\n"
"  - [280, 1, 'owner', 'tree', {'unique': false}, [[1, 'unsigned']]]\n"
"  - [280, 2, 'name', 'tree', {'unique': true}, [[2, 'string']]]\n"
"  - [281, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned']]]\n"
"  - [281, 1, 'owner', 'tree', {'unique': false}, [[1, 'unsigned']]]\n"
"  - [281, 2, 'name', 'tree', {'unique': true}, [[2, 'string']]]\n"
"  - [288, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned'], [1, "
"'unsigned']]]\n"
"  - [288, 2, 'name', 'tree', {'unique': true}, [[0, 'unsigned'], [2, "
"'string']]]\n"
"  - [289, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned'], [1, "
"'unsigned']]]\n"
"  - [289, 2, 'name', 'tree', {'unique': true}, [[0, 'unsigned'], [2, "
"'string']]]\n"
"  - [296, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned']]]\n"
"  - [296, 1, 'owner', 'tree', {'unique': false}, [[1, 'unsigned']]]\n"
"  - [296, 2, 'name', 'tree', {'unique': true}, [[2, 'string']]]\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1220
msgid ""
"``_priv`` is a system space where :ref:`privileges <authentication-"
"owners_privileges>` are stored."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1225
msgid "the numeric id of the user who gave the privilege (\"grantor_id\"),"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1226
msgid "the numeric id of the user who received the privilege (\"grantee_id\"),"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1227
msgid "the type of object: 'space', 'function' or 'universe',"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1228
msgid "the numeric id of the object,"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1229
msgid ""
"the type of operation: \"read\" = 1, \"write\" = 2, \"execute\" = 4, or a "
"combination such as \"read,write,execute\"."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1234
msgid ""
"Grant a privilege with :ref:`box.schema.user.grant() <box_schema-user_grant>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1235
msgid ""
"Revoke a privilege with :ref:`box.schema.user.revoke() <box_schema-user_revoke>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1239
msgid ""
"Generally, privileges are granted or revoked by the owner of the object (the "
"user who created it), or by the 'admin' user."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1242
msgid ""
"Before dropping any objects or users, make sure that all their associated "
"privileges have been revoked."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1245
msgid ""
"Only the :ref:`'admin' user <authentication-owners_privileges>` can grant "
"privileges for the 'universe'."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1248
msgid ""
"Only the 'admin' user or the creator of a space can drop, alter, or truncate the "
"space."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1251
msgid ""
"Only the 'admin' user or the creator of a user can change a different user’s "
"password."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1258
msgid "``_schema`` is a system space."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1260
msgid "This space contains the following tuples:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1262
msgid "``version`` tuple with version information for this Tarantool instance,"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1263
msgid "``cluster`` tuple with the instance's replica set ID,"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1264
msgid "``max_id`` tuple with the maximal space ID,"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1265
msgid ""
"``once...`` tuples that correspond to specific :ref:`box.once() <box-once>` "
"blocks from the instance's :ref:`initialization file <index-init_label>`. The "
"first field in these tuples contains the ``key`` value from the corresponding "
"``box.once()`` block prefixed with 'once' (e.g. `oncehello`), so you can easily "
"find a tuple that corresponds to a specific ``box.once()`` block."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1275
msgid ""
"Here is what ``_schema`` contains in a typical installation (notice the tuples "
"for two ``box.once()`` blocks, ``'oncebye'`` and ``'oncehello'``):"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1278
msgid ""
"tarantool> box.space._schema:select{}\n"
"---\n"
"- - ['cluster', 'b4e15788-d962-4442-892e-d6c1dd5d13f2']\n"
"  - ['max_id', 512]\n"
"  - ['oncebye']\n"
"  - ['oncehello']\n"
"  - ['version', 1, 7, 2]"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1292
msgid "``_space`` is a system space."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1296
msgid "``id``,"
msgstr "``id``,"

#: ../doc/1.7/book/box/box_space.rst:1297
msgid "``owner`` (= id of user who owns the space),"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1298
msgid "``name``, ``engine``, ``field_count``,"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1299
msgid "``flags`` (e.g. temporary), ``format``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1301
msgid ""
"These fields are established by :ref:`space.create() <box_schema-space_create>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1306
msgid ""
"The following function will display all simple fields in all tuples of "
"``_space``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1309
msgid ""
"function example()\n"
"  local ta = {}\n"
"  local i, line\n"
"  for k, v in box.space._space:pairs() do\n"
"    i = 1\n"
"    line = ''\n"
"    while i <= #v do\n"
"      if type(v[i]) ~= 'table' then\n"
"        line = line .. v[i] .. ' '\n"
"      end\n"
"    i = i + 1\n"
"    end\n"
"    table.insert(ta, line)\n"
"  end\n"
"  return ta\n"
"end"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1328
msgid "Here is what ``example()`` returns in a typical installation:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1330
msgid ""
"tarantool> example()\n"
"---\n"
"- - '272 1 _schema memtx 0  '\n"
"  - '280 1 _space memtx 0  '\n"
"  - '281 1 _vspace sysview 0  '\n"
"  - '288 1 _index memtx 0  '\n"
"  - '296 1 _func memtx 0  '\n"
"  - '304 1 _user memtx 0  '\n"
"  - '305 1 _vuser sysview 0  '\n"
"  - '312 1 _priv memtx 0  '\n"
"  - '313 1 _vpriv sysview 0  '\n"
"  - '320 1 _cluster memtx 0  '\n"
"  - '512 1 tester memtx 0  '\n"
"  - '513 1 origin vinyl 0  '\n"
"  - '514 1 archive memtx 0  '\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1351
msgid ""
"The following requests will create a space using ``box.schema.space.create()`` "
"with a ``format`` clause. Then it retrieves the ``_space`` tuple for the new "
"space. This illustrates the typical use of the ``format`` clause, it shows the "
"recommended names and data types for the fields."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1357
msgid ""
"tarantool> box.schema.space.create('TM', {\n"
"         >   id = 12345,\n"
"         >   format = {\n"
"         >     [1] = {[\"name\"] = \"field_1\"},\n"
"         >     [2] = {[\"type\"] = \"unsigned\"}\n"
"         >   }\n"
"         > })\n"
"---\n"
"- index: []\n"
"  on_replace: 'function: 0x41c67338'\n"
"  temporary: false\n"
"  id: 12345\n"
"  engine: memtx\n"
"  enabled: false\n"
"  name: TM\n"
"  field_count: 0\n"
"- created\n"
"...\n"
"tarantool> box.space._space:select(12345)\n"
"---\n"
"- - [12345, 1, 'TM', 'memtx', 0, {}, [{'name': 'field_1'}, {'type': "
"'unsigned'}]]\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1386
msgid ""
"``_user`` is a system space where user-names and password hashes are stored."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1390
msgid "the numeric id of the tuple (\"id\"),"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1391
msgid "the numeric id of the tuple’s creator,"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1392
#, fuzzy
msgid "the name,"
msgstr "telnet,"

#: ../doc/1.7/book/box/box_space.rst:1393
msgid "the type: 'user' or 'role',"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1394
msgid "optional password."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1396
msgid ""
"There are four special tuples in the ``_user`` space: 'guest', 'admin', 'public' "
"and 'replication'."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1407
msgid "ID"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1409
msgid "guest"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1409
msgid "0"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1409
msgid ""
"Default user when connecting remotely. Usually an untrusted user with few "
"privileges."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1412
msgid "admin"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1412
msgid "1"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1412
msgid ""
"Default user when using Tarantool as a console. Usually an :ref:`administrative "
"user <authentication-owners_privileges>` with all privileges."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1417
msgid "public"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1417 ../doc/1.7/book/box/box_space.rst:1425
msgid "role"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1417
msgid ""
"Pre-defined :ref:`role <authentication-roles>`, automatically assigned to new "
"users when they are created with ``box.schema.user.create(user-name)``. "
"Therefore, a convenient way to grant 'read' on space 't' to every user that will "
"ever exist is with ``box.schema.role.grant('public','read','space','t')``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1425
msgid "replication"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1425
msgid "3"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1425
msgid ""
"Pre-defined :ref:`role <authentication-roles>`, assigned by the 'admin' user to "
"users who need to use :ref:`replication <replication>` features."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1430
msgid ""
"To select a tuple from the ``_user`` space, use ``box.space._user:select()``. "
"For example, here is what happens with a select for user id = 0, which is the "
"'guest' user, which by default has no password:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1434
msgid ""
"tarantool> box.space._user:select{0}\n"
"---\n"
"- - [0, 1, 'guest', 'user']\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1443
msgid ""
"To change tuples in the ``_user`` space, do not use ordinary ``box.space`` "
"functions for insert or update or delete. The ``_user`` space is special, so "
"there are special functions which have appropriate error checking."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1447
msgid ""
"To create a new user, use :ref:`box.schema.user.create() <box_schema-"
"user_create>`:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1452
msgid ""
"box.schema.user.create(*user-name*)\n"
"box.schema.user.create(*user-name*, {if_not_exists = true})\n"
"box.schema.user.create(*user-name*, {password = *password*})"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1456
msgid ""
"To change the user's password, use :ref:`box.schema.user.password() <box_schema-"
"user_password>`:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1461
msgid ""
"-- To change the current user's password\n"
"box.schema.user.passwd(*password*)\n"
"\n"
"-- To change a different user's password\n"
"-- (usually only 'admin' can do it)\n"
"box.schema.user.passwd(*user-name*, *password*)"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1469
msgid "To drop a user, use :ref:`box.schema.user.drop() <box_schema-user_drop>`:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1474
msgid "box.schema.user.drop(*user-name*)"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1476
msgid ""
"To check whether a user exists, use :ref:`box.schema.user.exists() <box_schema-"
"user_exists>`, which returns ``true`` or ``false``:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1482
msgid "box.schema.user.exists(*user-name*)"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1484
msgid ""
"To find what privileges a user has, use :ref:`box.schema.user.info() <box_schema-"
"user_info>`:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1489
msgid "box.schema.user.info(*user-name*)"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1497
msgid ""
"Here is a session which creates a new user with a strong password, selects a "
"tuple in the ``_user`` space, and then drops the user."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1500
msgid ""
"tarantool> box.schema.user.create('JeanMartin', {password = 'Iwtso_6_os$$'})\n"
"---\n"
"...\n"
"tarantool> box.space._user.index.name:select{'JeanMartin'}\n"
"---\n"
"- - [17, 1, 'JeanMartin', 'user', {'chap-sha1': 't3xjUpQdrt857O"
"+YRvGbMY5py8Q='}]\n"
"...\n"
"tarantool> box.schema.user.drop('JeanMartin')\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1516
msgid "Example: use box.space functions to read _space tuples"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1518
msgid ""
"This function will illustrate how to look at all the spaces, and for each "
"display: approximately how many tuples it contains, and the first field of its "
"first tuple. The function uses Tarantool ``box.space`` functions ``len()`` and "
"``pairs()``. The iteration through the spaces is coded as a scan of the "
"``_space`` system space, which contains metadata. The third field in ``_space`` "
"contains the space name, so the key instruction ``space_name = v[3]`` means "
"``space_name`` is the ``space_name`` field in the tuple of ``_space`` that we've "
"just fetched with ``pairs()``. The function returns a table:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1528
msgid ""
"function example()\n"
"  local tuple_count, space_name, line\n"
"  local ta = {}\n"
"  for k, v in box.space._space:pairs() do\n"
"    space_name = v[3]\n"
"    if box.space[space_name].index[0] ~= nil then\n"
"      tuple_count = '1 or more'\n"
"    else\n"
"      tuple_count = '0'\n"
"    end\n"
"    line = space_name .. ' tuple_count =' .. tuple_count\n"
"    if tuple_count == '1 or more' then\n"
"      for k1, v1 in box.space[space_name]:pairs() do\n"
"        line = line .. '. first field in first tuple = ' .. v1[1]\n"
"        break\n"
"      end\n"
"    end\n"
"    table.insert(ta, line)\n"
"  end\n"
"  return ta\n"
"end"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1552
msgid "And here is what happens when one invokes the function:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1554
msgid ""
"tarantool> example()\n"
"---\n"
"- - _schema tuple_count =1 or more. first field in first tuple = cluster\n"
"  - _space tuple_count =1 or more. first field in first tuple = 272\n"
"  - _vspace tuple_count =1 or more. first field in first tuple = 272\n"
"  - _index tuple_count =1 or more. first field in first tuple = 272\n"
"  - _vindex tuple_count =1 or more. first field in first tuple = 272\n"
"  - _func tuple_count =1 or more. first field in first tuple = 1\n"
"  - _vfunc tuple_count =1 or more. first field in first tuple = 1\n"
"  - _user tuple_count =1 or more. first field in first tuple = 0\n"
"  - _vuser tuple_count =1 or more. first field in first tuple = 0\n"
"  - _priv tuple_count =1 or more. first field in first tuple = 1\n"
"  - _vpriv tuple_count =1 or more. first field in first tuple = 1\n"
"  - _cluster tuple_count =1 or more. first field in first tuple = 1\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1574
msgid "Example: use box.space functions to organize a _space tuple"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1576
msgid ""
"The objective is to display field names and field types of a system space -- "
"using metadata to find metadata."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1579
msgid "To begin: how can one select the _space tuple that describes _space?"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1581
msgid ""
"A simple way is to look at the constants in box.schema, which tell us that there "
"is an item named SPACE_ID == 288, so these statements will retrieve the correct "
"tuple:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1585
msgid "``box.space._space:select{ 288 }``"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1586
#: ../doc/1.7/dev_guide/lua_style_guide.rst:409
msgid "or"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1587
msgid "``box.space._space:select{ box.schema.SPACE_ID }``"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1589
msgid ""
"Another way is to look at the tuples in box.space._index, which tell us that "
"there is a secondary index named 'name' for space number 288, so this statement "
"also will retrieve the correct tuple:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1593
msgid "``box.space._space.index.name:select{ '_space' }``"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1595
msgid "However, the retrieved tuple is not easy to read:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1597
msgid ""
"tarantool> box.space._space.index.name:select{'_space'}\n"
"---\n"
"- - [280, 1, '_space', 'memtx', 0, {}, [{'name': 'id', 'type': 'num'}, {'name': "
"'owner',\n"
"        'type': 'num'}, {'name': 'name', 'type': 'str'}, {'name': 'engine', "
"'type': 'str'},\n"
"      {'name': 'field_count', 'type': 'num'}, {'name': 'flags', 'type': 'str'}, "
"{\n"
"        'name': 'format', 'type': '*'}]]\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1607
msgid ""
"It looks disorganized because field number 7 has been formatted with recommended "
"names and data types. How can one get those specific sub-fields? Since it's "
"visible that field number 7 is an array of maps, this `for` loop will do the "
"organizing:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1612
msgid ""
"tarantool> do\n"
"         >   local tuple_of_space = box.space._space.index.name:get{'_space'}\n"
"         >   for _, field in ipairs(tuple_of_space[7]) do\n"
"         >     print(field.name .. ', ' .. field.type)\n"
"         >   end\n"
"         > end\n"
"id, num\n"
"owner, num\n"
"name, str\n"
"engine, str\n"
"field_count, num\n"
"flags, str\n"
"format, *\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_stat.rst:39
msgid "Submodule `box.stat`"
msgstr ""

#: ../doc/1.7/book/box/box_stat.rst:41
msgid ""
"The ``box.stat`` submodule provides access to request and network statistics. "
"Show the average number of requests per second, and the total number of requests "
"since startup, broken down by request type and network events statistics."
msgstr ""

#: ../doc/1.7/book/box/box_stat.rst:45
msgid ""
"tarantool> type(box.stat), type(box.stat.net) -- virtual tables\n"
"---\n"
"- table\n"
"- table\n"
"...\n"
"tarantool> box.stat, box.stat.net\n"
"---\n"
"- net: &0 []\n"
"- *0\n"
"...\n"
"tarantool> box.stat()\n"
"---\n"
"- DELETE:\n"
"    total: 1873949\n"
"    rps: 123\n"
"  SELECT:\n"
"    total: 1237723\n"
"    rps: 4099\n"
"  INSERT:\n"
"    total: 0\n"
"    rps: 0\n"
"  EVAL:\n"
"    total: 0\n"
"    rps: 0\n"
"  CALL:\n"
"    total: 0\n"
"    rps: 0\n"
"  REPLACE:\n"
"    total: 1239123\n"
"    rps: 7849\n"
"  UPSERT:\n"
"    total: 0\n"
"    rps: 0\n"
"  AUTH:\n"
"    total: 0\n"
"    rps: 0\n"
"  ERROR:\n"
"    total: 0\n"
"    rps: 0\n"
"  UPDATE:\n"
"    total: 0\n"
"    rps: 0\n"
"...\n"
"tarantool> box.stat().DELETE -- a selected item of the table\n"
"---\n"
"- total: 0\n"
"  rps: 0\n"
"...\n"
"tarantool> box.stat.net()\n"
"---\n"
"- SENT:\n"
"    total: 0\n"
"    rps: 0\n"
"  EVENTS:\n"
"    total: 2\n"
"    rps: 0\n"
"  LOCKS:\n"
"    total: 6\n"
"    rps: 0\n"
"  RECEIVED:\n"
"    total: 0\n"
"    rps: 0\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:39
msgid "Submodule `box.tuple`"
msgstr "Вложенный модуль `box.tuple`"

#: ../doc/1.7/book/box/box_tuple.rst:43
msgid ""
"The ``box.tuple`` submodule provides read-only access for the ``tuple`` userdata "
"type. It allows, for a single :ref:`tuple <index-box_tuple>`: selective "
"retrieval of the field contents, retrieval of information about size, iteration "
"over all the fields, and conversion to a `Lua table <https://www.lua.org/pil/2.5."
"html>`_."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:53
msgid ""
"Construct a new tuple from either a scalar or a Lua table. Alternatively, one "
"can get new tuples from tarantool's :ref:`select <box_space-select>` or :ref:"
"`insert <box_space-insert>` or :ref:`replace <box_space-replace>` or :ref:"
"`update <box_space-update>` requests, which can be regarded as statements that "
"do ``new()`` implicitly."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:60
msgid "the value that will become the tuple contents."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:62
msgid "a new tuple"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:65
msgid ""
"In the following example, ``x`` will be a new table object containing one tuple "
"and ``t`` will be a new tuple object. Saying ``t`` returns the entire tuple "
"``t``."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:71
msgid ""
"tarantool> x = box.space.tester:insert{\n"
"         >   33,\n"
"         >   tonumber('1'),\n"
"         >   tonumber64('2')\n"
"         > }:totable()\n"
"---\n"
"...\n"
"tarantool> t = box.tuple.new{'abc', 'def', 'ghi', 'abc'}\n"
"---\n"
"...\n"
"tarantool> t\n"
"---\n"
"- ['abc', 'def', 'ghi', 'abc']\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:92
msgid ""
"The ``#`` operator in Lua means \"return count of components\". So, if ``t`` is "
"a tuple instance, ``#t`` will return the number of fields."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:97
msgid ""
"In the following example, a tuple named ``t`` is created and then the number of "
"fields in ``t`` is returned."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:100
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4'}\n"
"---\n"
"...\n"
"tarantool> #t\n"
"---\n"
"- 4\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:112
msgid ""
"If ``t`` is a tuple instance, ``t:bsize()`` will return the number of bytes in "
"the tuple. With both the memtx storage engine and the vinyl storage engine the "
"default maximum is one megabyte (:ref:`memtx_max_tuple_size <cfg_storage-"
"memtx_max_tuple_size>` or :ref:`vinyl_max_tuple_size <cfg_storage-"
"vinyl_max_tuple_size>`). Every field has one or more \"length\" bytes preceding "
"the actual contents, so ``bsize()`` returns a value which is slightly greater "
"than the sum of the lengths of the contents."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:124
msgid ""
"In the following example, a tuple named ``t`` is created which has three fields, "
"and for each field it takes one byte to store the length and three bytes to "
"store the contents, and a bit for overhead, so ``bsize()`` returns ``3*(1+3)+1``."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:129
msgid ""
"tarantool> t = box.tuple.new{'aaa', 'bbb', 'ccc'}\n"
"---\n"
"...\n"
"tarantool> t:bsize()\n"
"---\n"
"- 13\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:141
msgid ""
"If ``t`` is a tuple instance, ``t[field-number]`` will return the field numbered "
"field-number in the tuple. The first field is ``t[1]``."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:144
msgid "field value."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:145
msgid "lua-value"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:147
msgid ""
"In the following example, a tuple named ``t`` is created and then the second "
"field in ``t`` is returned."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:150
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4'}\n"
"---\n"
"...\n"
"tarantool> t[2]\n"
"---\n"
"- Fld#2\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:163
msgid ""
"If ``t`` is a tuple instance, ``t:find(search-value)`` will return the number of "
"the first field in ``t`` that matches the search value, and ``t:findall(search-"
"value [, search-value ...])`` will return numbers of all fields in ``t`` that "
"match the search value. Optionally one can put a numeric argument ``field-"
"number`` before the search-value to indicate “start searching at field number "
"``field-number``.”"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:170
msgid "the number of the field in the tuple."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:173
msgid ""
"In the following example, a tuple named ``t`` is created and then: the number of "
"the first field in ``t`` which matches 'a' is returned, then the numbers of all "
"the fields in ``t`` which match 'a' are returned, then the numbers of all the "
"fields in t which match 'a' and are at or after the second field are returned."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:179
msgid ""
"tarantool> t = box.tuple.new{'a', 'b', 'c', 'a'}\n"
"---\n"
"...\n"
"tarantool> t:find('a')\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> t:findall('a')\n"
"---\n"
"- 1\n"
"- 4\n"
"...\n"
"tarantool> t:findall(2, 'a')\n"
"---\n"
"- 4\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:200
msgid ""
"If ``t`` is a tuple instance, :samp:`t:transform({start-field-number},{fields-to-"
"remove})` will return a tuple where, starting from field ``start-field-number``, "
"a number of fields (``fields-to-remove``) are removed. Optionally one can add "
"more arguments after ``fields-to-remove`` to indicate new values that will "
"replace what was removed."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:206
msgid "base 1, may be negative"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:212
msgid ""
"In the following example, a tuple named ``t`` is created and then, starting from "
"the second field, two fields are removed but one new one is added, then the "
"result is returned."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:216
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}\n"
"---\n"
"...\n"
"tarantool> t:transform(2, 2, 'x')\n"
"---\n"
"- ['Fld#1', 'x', 'Fld#4', 'Fld#5']\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:228
msgid ""
"If ``t`` is a tuple instance, ``t:unpack()`` will return all fields, ``t:"
"unpack(1)`` will return all fields starting with field number 1, ``t:"
"unpack(1,5)`` will return all fields between field number 1 and field number 5."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:232
msgid "field(s) from the tuple."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:233
msgid "lua-value(s)"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:235
msgid ""
"In the following example, a tuple named ``t`` is created and then all its fields "
"are selected, then the result is returned."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:238
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}\n"
"---\n"
"...\n"
"tarantool> t:unpack()\n"
"---\n"
"- Fld#1\n"
"- Fld#2\n"
"- Fld#3\n"
"- Fld#4\n"
"- Fld#5\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:254
msgid ""
"If ``t`` is a tuple instance, ``t:totable()`` will return all fields, ``t:"
"totable(1)`` will return all fields starting with field number 1, ``t:"
"totable(1,5)`` will return all fields between field number 1 and field number 5. "
"It is preferable to use ``t:totable()`` rather than ``t:unpack()``."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:259
msgid "field(s) from the tuple"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:260
msgid "lua-table"
msgstr "lua-table"

#: ../doc/1.7/book/box/box_tuple.rst:262
msgid ""
"In the following example, a tuple named ``t`` is created, then all its fields "
"are selected, then the result is returned."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:265
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}\n"
"---\n"
"...\n"
"tarantool> t:totable()\n"
"---\n"
"- ['Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5']\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:278
msgid ""
"In Lua, `lua-table-value:pairs() <https://www.lua.org/pil/7.3.html>`_ is a "
"method which returns: ``function``, ``lua-table-value``, ``nil``. Tarantool has "
"extended this so that ``tuple-value:pairs()`` returns: ``function``, ``tuple-"
"value``, ``nil``. It is useful for Lua iterators, because Lua iterators traverse "
"a value's components until an end marker is reached."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:284
msgid "function, tuple-value, nil"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:285
msgid "function, lua-value, nil"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:287
msgid ""
"In the following example, a tuple named ``t`` is created and then all its fields "
"are selected using a Lua for-end loop."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:290
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}\n"
"---\n"
"...\n"
"tarantool> tmp = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in t:pairs() do\n"
"         >   tmp = tmp .. v\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> tmp\n"
"---\n"
"- Fld#1Fld#2Fld#3Fld#4Fld#5\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:312
msgid ""
"This function updates a tuple which is not in a space. Compare the function :"
"extsamp:`box.space.{*{space-name}*}:update({*{key}*}, {{{*{format}*}, "
"{*{field_no}*}, {*{value}*}}, ...})` which updates a tuple in a space."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:316
msgid ""
"For details: see the description for ``operator``, ``field_no``, and ``value`` "
"in the section :ref:`box.space.space-name:update{key, format, {field_number, "
"value}...) <box_space-update>`."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:320
msgid "operation type represented in string (e.g. '``=``' for 'assign new value')"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:328
msgid "new tuple"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:331
msgid ""
"In the following example, a tuple named ``t`` is created and then its second "
"field is updated to equal 'B'."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:334
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}\n"
"---\n"
"...\n"
"tarantool> t:update({{'=', 2, 'B'}})\n"
"---\n"
"- ['Fld#1', 'B', 'Fld#3', 'Fld#4', 'Fld#5']\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:346
#: ../doc/1.7/reference/configuration/index.rst:125
#: ../doc/1.7/reference/reference_lua/digest.rst:230
#: ../doc/1.7/reference/reference_lua/fiber.rst:478
#: ../doc/1.7/reference/reference_lua/fiber.rst:654
#: ../doc/1.7/reference/reference_lua/fiber.rst:775
#: ../doc/1.7/reference/reference_lua/log.rst:100
#: ../doc/1.7/reference/reference_lua/msgpack.rst:76
#: ../doc/1.7/reference/reference_lua/net_box.rst:381
#: ../doc/1.7/reference/reference_lua/tap.rst:212
#: ../doc/1.7/reference/reference_lua/uuid.rst:144
#: ../doc/1.7/reference/reference_lua/yaml.rst:70
#: ../doc/1.7/reference/reference_rock/dbms.rst:283
#: ../doc/1.7/reference/reference_rock/dbms.rst:625
msgid "Example"
msgstr "Пример"

#: ../doc/1.7/book/box/box_tuple.rst:348
msgid ""
"This function will illustrate how to convert tuples to/from Lua tables and lists "
"of scalars:"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:351
msgid ""
"tuple = box.tuple.new({scalar1, scalar2, ... scalar_n}) -- scalars to tuple\n"
"lua_table = {tuple:unpack()}                            -- tuple to Lua table\n"
"lua_table = tuple:totable()                             -- tuple to Lua table\n"
"scalar1, scalar2, ... scalar_n = tuple:unpack()         -- tuple to scalars\n"
"tuple = box.tuple.new(lua_table)                        -- Lua table to tuple"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:359
msgid ""
"Then it will find the field that contains 'b', remove that field from the tuple, "
"and display how many bytes remain in the tuple. The function uses Tarantool "
"``box.tuple`` functions ``new()``, ``unpack()``, ``find()``, ``transform()``, "
"``bsize()``."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:364
msgid ""
"function example()\n"
"  local tuple1, tuple2, lua_table_1, scalar1, scalar2, scalar3, field_number\n"
"  local luatable1 = {}\n"
"  tuple1 = box.tuple.new({'a', 'b', 'c'})\n"
"  luatable1 = tuple1:totable()\n"
"  scalar1, scalar2, scalar3 = tuple1:unpack()\n"
"  tuple2 = box.tuple.new(luatable1[1],luatable1[2],luatable1[3])\n"
"  field_number = tuple2:find('b')\n"
"  tuple2 = tuple2:transform(field_number, 1)\n"
"  return 'tuple2 = ' , tuple2 , ' # of bytes = ' , tuple2:bsize()\n"
"end"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:380
msgid ""
"tarantool> example()\n"
"---\n"
"- tuple2 =\n"
"- ['a', 'c']\n"
"- ' # of bytes = '\n"
"- 5\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:39
#, fuzzy
msgid "Functions for transaction management"
msgstr "Управление экземплярами"

#: ../doc/1.7/book/box/box_txn_management.rst:41
msgid ""
"For general information and examples, see section :ref:`Transaction control "
"<atomic-atomic_execution>`."
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:44
msgid "Observe the following rules when working with transactions:"
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:46
msgid "Rule #1"
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:49
msgid ""
"The requests in a transaction must be sent to a server as a single block. It is "
"not enough to enclose them between begin and commit or rollback. To ensure they "
"are sent as a single block: put them in a function, or put them all on one line, "
"or use a delimiter so that multi-line requests are handled together."
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:55
msgid "Rule #2"
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:58
msgid ""
"All database operations in a transaction should use the same storage engine. It "
"is not safe to access tuple sets that are defined with ``{engine='vinyl'}`` and "
"also access tuple sets that are defined with ``{engine='memtx'}``, in the same "
"transaction."
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:67
msgid ""
"Begin the transaction. Disable :ref:`implicit yields <atomic-implicit-yields>` "
"until the transaction ends. Signal that writes to the :ref:`write-ahead log "
"<internals-wal>` will be deferred until the transaction ends. In effect the "
"fiber which executes ``box.begin()`` is starting an \"active multi-request "
"transaction\", blocking all other fibers."
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:78
msgid "End the transaction, and make all its data-change operations permanent."
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:84
msgid ""
"End the transaction, but cancel all its data-change operations. An explicit call "
"to functions outside ``box.space`` that always yield, such as :ref:`fiber."
"sleep() <fiber-sleep>` or :ref:`fiber.yield() <fiber-yield>`, will have the same "
"effect."
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:93
msgid ""
"Return a descriptor of a savepoint (type = table), which can be used later by :"
"ref:`box.rollback_to_savepoint(savepoint) <box-rollback_to_savepoint>`. "
"Savepoints can only be created while a transaction is active, and they are "
"destroyed when a transaction ends."
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:102
msgid ""
"Do not end the transaction, but cancel all its data-change and :ref:`box."
"savepoint() <box-savepoint>` operations that were done after the specified "
"savepoint."
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:108
msgid ""
"function f()\n"
"  box.begin()           -- start transaction\n"
"  box.space.t:insert{1} -- this will not be rolled back\n"
"  local s = box.savepoint()\n"
"  box.space.t:insert{2} -- this will be rolled back\n"
"  box.rollback_to_savepoint(s)\n"
"  box.commit()          -- end transaction\n"
"end"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:39
msgid "Data model"
msgstr "Модель данных"

#: ../doc/1.7/book/box/data_model.rst:41
msgid ""
"This section describes how Tarantool stores values and what operations with data "
"it supports."
msgstr ""
"В этом разделе описывается то, как в Tarantool'е организовано хранение данных и "
"какие операции с данным он поддерживает."

#: ../doc/1.7/book/box/data_model.rst:44
msgid ""
"If you tried to create a database as suggested in our :ref:`\"Getting started\" "
"exercises <getting_started>`, then your test database now looks like this:"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:54
msgid "Space"
msgstr "Пространство"

#: ../doc/1.7/book/box/data_model.rst:56
#, fuzzy
msgid "A **space** -- 'tester' in our example -- is a container."
msgstr "*Пространство* с именем 'tester' в нашем примере — это контейнер."

#: ../doc/1.7/book/box/data_model.rst:58
msgid ""
"When Tarantool is being used to store data, there is always at least one space. "
"Each space has a unique **name** specified by the user. Besides, each space has "
"a unique **numeric identifier** which can be specified by the user, but usually "
"is assigned automatically by Tarantool. Finally, a space always has an "
"**engine**: *memtx* (default) -- in-memory engine, fast but limited in size, or "
"*vinyl* -- on-disk engine for huge data sets."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:65
msgid ""
"A space is a container for :ref:`tuples <index-box_tuple>`. To be functional, it "
"needs to have a :ref:`primary index <index-box_index>`. It can also have "
"secondary indexes."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:73
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:52
msgid "Tuple"
msgstr "Tuple"

#: ../doc/1.7/book/box/data_model.rst:75
msgid ""
"A **tuple** plays the same role as a “row” or a “record”, and the components of "
"a tuple (which we call “fields”) play the same role as a “row column” or “record "
"field”, except that:"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:79
msgid "fields can be composite structures, such as arrays or maps, and"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:80
msgid "fields don't need to have names."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:82
#, fuzzy
msgid ""
"Any given tuple may have any number of fields, and the fields may be of "
"different :ref:`types <index-box_data-types>`. The identifier of a field is the "
"field's number, base 1 (in Lua and other 1-based languages) or base 0 (in PHP or "
"C/C++). For example, “1” or \"0\" can be used in some contexts to refer to the "
"first field of a tuple."
msgstr ""
"Кортеж может иметь любое количество полей, и это могут быть поля разных типов. "
"Идентификатором поля является его номер. Поля нумеруются, начиная с 1. Так, "
"например, “1” может использоваться в некоторых контекстах для обозначения "
"первого поля кортежа."

#: ../doc/1.7/book/box/data_model.rst:89
msgid ""
"Tuples in Tarantool are stored as `MsgPack <https://en.wikipedia.org/wiki/"
"MessagePack>`_ arrays."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:92
msgid ""
"When Tarantool returns a tuple value in console, it uses the `YAML <https://en."
"wikipedia.org/wiki/YAML>`_ format, for example: ``[3, 'Ace of Base', 1993]``."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:100
msgid "Index"
msgstr "Индекс"

#: ../doc/1.7/book/box/data_model.rst:102
#, fuzzy
msgid "An **index** is a group of key values and pointers."
msgstr ""
"*Индекс* — в нашем примере он первичный — это совокупность значений ключей и "
"указателей."

#: ../doc/1.7/book/box/data_model.rst:104
msgid ""
"As with spaces, you should specify the index **name**, and let Tarantool come up "
"with a unique **numeric identifier** (\"index id\")."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:107
msgid ""
"An index always has a **type**. The default index type is 'TREE'. TREE indexes "
"are provided by all Tarantool engines, can index unique and non-unique values, "
"support partial key searches, comparisons and ordered results. Additionally, "
"memtx engine supports HASH, RTREE and BITSET indexes."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:112
msgid ""
"An index may be **multi-part**, that is, you can declare that an index key value "
"is composed of two or more fields in the tuple, in any order. For example, for "
"an ordinary TREE index, the maximum number of parts is 255."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:116
msgid ""
"An index may be **unique**, that is, you can declare that it would be illegal to "
"have the same key value twice."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:119
#, fuzzy
msgid ""
"The first index defined on a space is called the **primary key index**, and it "
"must be unique. All other indexes are called **secondary indexes**, and they may "
"be non-unique."
msgstr ""
"Первичный индекс для кортежа должен строиться по уникальным значениям полей, но "
"остальные (вторичные) индексы могут строиться по неуникальным значениям."

#: ../doc/1.7/book/box/data_model.rst:123
#, fuzzy
msgid ""
"An index definition may include identifiers of tuple fields and their expected "
"**types** (see allowed :ref:`indexed field types <index-box_indexed-field-"
"types>` below)."
msgstr ""
"Индекс может содержать идентификаторы полей кортежа и типы данных для этих "
"полей. Индексированные поля могут содержать данные следующих типов:"

#: ../doc/1.7/book/box/data_model.rst:127
msgid ""
"In our example, we first defined the primary index (named 'primary') based on "
"field #1 of each tuple:"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:130
msgid ""
"tarantool> i = s:create_index('primary', {type = 'hash', parts = {1, "
"'unsigned'}})"
msgstr ""
"tarantool> i = s:create_index('primary', {type = 'hash', parts = {1, "
"'unsigned'}})"

#: ../doc/1.7/book/box/data_model.rst:134
msgid ""
"The effect is that, for all tuples in space 'tester', field #1 must exist and "
"must contain an unsigned integer. The index type is 'hash', so values in field "
"#1 must be unique, because keys in HASH indexes are unique."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:139
msgid ""
"After that, we defined a secondary index (named 'secondary') based on field #2 "
"of each tuple:"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:142
#, fuzzy
msgid ""
"tarantool> i = s:create_index('secondary', {type = 'tree', parts = {2, "
"'string'}})"
msgstr ""
"tarantool> i = s:create_index('primary', {type = 'hash', parts = {1, "
"'unsigned'}})"

#: ../doc/1.7/book/box/data_model.rst:146
msgid ""
"The effect is that, for all tuples in space 'tester', field #2 must exist and "
"must contain a string. The index type is 'tree', so values in field #2 must not "
"be unique, because keys in TREE indexes may be non-unique."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:153
msgid ""
"Space definitions and index definitions are stored permanently in Tarantool's "
"system spaces :ref:`_space <box_space-space>` and :ref:`_index <box_space-"
"index>` (for details, see reference on :ref:`box.space <box_space>` submodule)."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:157
msgid ""
"You can add, drop, or alter the definitions at runtime, with some restrictions. "
"See syntax details in reference on :ref:`box <box-module>` module."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:164
msgid "Data types"
msgstr "Типы данных"

#: ../doc/1.7/book/box/data_model.rst:166
msgid ""
"Tarantool is both a database and an application server. Hence a developer often "
"deals with two type sets: the programming language types (e.g. Lua) and the "
"types of the Tarantool storage format (MsgPack)."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:175
msgid "Lua vs MsgPack"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:185
msgid "Scalar / compound"
msgstr "Scalar / compound"

#: ../doc/1.7/book/box/data_model.rst:185
msgid "MsgPack |nbsp| type"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:185
#, fuzzy
msgid "Lua type"
msgstr "Типы данных"

#: ../doc/1.7/book/box/data_model.rst:185
#, fuzzy
msgid "Example value"
msgstr "Пример 2"

#: ../doc/1.7/book/box/data_model.rst:187 ../doc/1.7/book/box/data_model.rst:189
#: ../doc/1.7/book/box/data_model.rst:191 ../doc/1.7/book/box/data_model.rst:193
#: ../doc/1.7/book/box/data_model.rst:195
msgid "scalar"
msgstr "scalar"

#: ../doc/1.7/book/box/data_model.rst:187
msgid "\"`nil`_\""
msgstr "\"`nil`_\""

#: ../doc/1.7/book/box/data_model.rst:187
#: ../doc/1.7/reference/reference_lua/msgpack.rst:185
msgid "msgpack.NULL"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:189
msgid "\"`boolean`_\""
msgstr "\"`boolean`_\""

#: ../doc/1.7/book/box/data_model.rst:189 ../doc/1.7/book/box/data_model.rst:329
#: ../doc/1.7/book/box/data_model.rst:337
#: ../doc/1.7/reference/reference_lua/msgpack.rst:175
msgid "true"
msgstr "true"

#: ../doc/1.7/book/box/data_model.rst:191
msgid "\"`string`_\""
msgstr "\"`string`_\""

#: ../doc/1.7/book/box/data_model.rst:191
msgid "'A B C'"
msgstr "'A B C'"

#: ../doc/1.7/book/box/data_model.rst:193
#: ../doc/1.7/reference/reference_lua/errno.rst:60
msgid "integer"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:193 ../doc/1.7/book/box/data_model.rst:195
msgid "\"`number`_\""
msgstr "\"`number`_\""

#: ../doc/1.7/book/box/data_model.rst:193
msgid "12345"
msgstr "12345"

#: ../doc/1.7/book/box/data_model.rst:195
msgid "double"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:195
#, fuzzy
msgid "1.2345"
msgstr "12345"

#: ../doc/1.7/book/box/data_model.rst:197 ../doc/1.7/book/box/data_model.rst:199
#: ../doc/1.7/book/box/data_model.rst:201
msgid "compound"
msgstr "compound"

#: ../doc/1.7/book/box/data_model.rst:197
msgid "map"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:197
msgid "\"`table`_\" (with string keys)"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:197
msgid "{'a': 5, 'b': 6}"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:199 ../doc/1.7/book/box/data_model.rst:201
msgid "array"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:199
msgid "\"`table`_\" (with integer keys)"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:199
msgid "[1, 2, 3, 4, 5]"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:201
msgid "tuple (\"`cdata`_\")"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:201
msgid "[12345, 'A B C']"
msgstr "[12345, 'A B C']"

#: ../doc/1.7/book/box/data_model.rst:211
msgid ""
"In Lua, a **nil** type has only one possible value, also called *nil* (displayed "
"as **null** on Tarantool's command line, since the output is in the YAML "
"format). Nils may be compared to values of any types with == (is-equal) or ~= "
"(is-not-equal), but other operations will not work. Nils may not be used in Lua "
"tables; the workaround is to use :ref:`msgpack.NULL <msgpack-null>`"
msgstr ""
"Тип *nil* (нулевой) может иметь только одно значение, также называемое *nil*, но "
"часто отображаемое как *null*. Нулевое значение можно сравнивать со значениями "
"любых типов с помощью операторов == (равен) или ~= (не равен), но никакие другие "
"операции для нулевых значений не доступны. Нулевые значения также нельзя "
"использовать в Lua-таблицах; вместо нулевого значения в таком случае можно "
"указать :ref:`yaml.NULL <yaml-null>`, либо :ref:`json.NULL <json-null>`, либо :"
"ref:`msgpack.NULL <msgpack-null>`"

#: ../doc/1.7/book/box/data_model.rst:219
#, fuzzy
msgid "A **boolean** is either ``true`` or ``false``."
msgstr ""
"Тип *boolean* (логический) может иметь только значения ``true`` или ``false``."

#: ../doc/1.7/book/box/data_model.rst:223
msgid ""
"A **string** is a variable-length sequence of bytes, usually represented with "
"alphanumeric characters inside single quotes. In both Lua and MsgPack, strings "
"are treated as binary data, with no attempts to determine a string's character "
"set or to perform any string conversion. So, string sorting and comparison are "
"done byte-by-byte, without any special collation rules applied. (Example: "
"numbers are ordered by their point on the number line, so 2345 is greater than "
"500; meanwhile, strings are ordered by the encoding of the first byte, then the "
"encoding of the second byte, and so on, so '2345' is less than '500'.)"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:235
#, fuzzy
msgid ""
"In Lua, a **number** is double-precision floating-point, but Tarantool allows "
"both integer and floating-point values. Tarantool will try to store a Lua number "
"as floating-point if the value contains a decimal point or is very large "
"(greater than 100 trillion = 1e14), otherwise Tarantool will store it as an "
"integer. To ensure that even very large numbers are stored as integers, use the :"
"ref:`tonumber64 <other-tonumber64>` function, or the LL (Long Long) suffix, or "
"the ULL (Unsigned Long Long) suffix. Here are examples of numbers using regular "
"notation, exponential notation, the ULL suffix and the ``tonumber64`` function: "
"``-55``, ``-2.7e+20``, ``100000000000000ULL``, "
"``tonumber64('18446744073709551615')``."
msgstr ""
"В языке Lua тип *number* (число) — это число с плавающей точкой двойной "
"точности, но в Tarantool'е можно использовать как целые числа, так и числа с "
"плавающей запятой. Tarantool по возможности сохраняет числовые значения в виде "
"чисел с плавающей точкой, если числовое значение содержит десятичную запятую или "
"если оно очень велико (более 100 триллионов = 1e14). Если в формате с плавающей "
"точкой сохранить не удается, то Tarantool сохраняет такое значение в виде целого "
"числа. Чтобы даже очень большие величины гарантированно обрабатывались как целые "
"числа, используйте функцию :ref:`tonumber64 <other-tonumber64>`, либо "
"приписывайте в конце суффикс LL (Long Long) или ULL (Unsigned Long Long). Вот "
"примеры записи чисел в различных представлениях (обычном, экспоненциальном, с "
"суффиксом ULL и с использованием функции tonumber64): ``-55``, ``-2.7e+20``, "
"``100000000000000ULL``, ``tonumber64('18446744073709551615')``."

#: ../doc/1.7/book/box/data_model.rst:246
msgid ""
"Lua **tables** with string keys are stored as MsgPack maps; Lua tables with "
"integer keys starting with 1 -- as MsgPack arrays. Nils may not be used in Lua "
"tables; the workaround is to use :ref:`msgpack.NULL <msgpack-null>`"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:251
msgid ""
"A **tuple** is a light reference to a MsgPack array stored in the database. It "
"is a special type (cdata) to avoid conversion to a Lua table on retrieval. A few "
"functions may return tables with multiple tuples. For more tuple examples, see :"
"ref:`box.tuple <box_tuple>`."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:258
msgid ""
"Tarantool uses the MsgPack format for database storage, which is variable-"
"length. So, for example, the smallest number requires only one byte, but the "
"largest number requires nine bytes."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:262
msgid "Examples of insert requests with different data types:"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:264
msgid ""
"tarantool> box.space.K:insert{1,nil,true,'A B C',12345,1.2345}\n"
"---\n"
"- [1, null, true, 'A B C', 12345, 1.2345]\n"
"...\n"
"tarantool> box.space.K:insert{2,{['a']=5,['b']=6}}\n"
"---\n"
"- [2, {'a': 5, 'b': 6}]\n"
"...\n"
"tarantool> box.space.K:insert{3,{1,2,3,4,5}}\n"
"---\n"
"- [3, [1, 2, 3, 4, 5]]\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:283
#, fuzzy
msgid "Indexed field types"
msgstr "Тип поля для индексирования"

#: ../doc/1.7/book/box/data_model.rst:285
msgid ""
"Indexes restrict values which Tarantool's MsgPack may contain. This is why, for "
"example, 'unsigned' is a separate **indexed field type**, compared to ‘integer’ "
"data type in MsgPack: they both store ‘integer’ values, but an 'unsigned' index "
"contains only *non-negative* integer values and an ‘integer’ index contains "
"*all* integer values."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:291
msgid "Here's how Tarantool indexed field types correspond to MsgPack data types."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:302
#, fuzzy
msgid "Indexed field type"
msgstr "Тип поля для индексирования"

#: ../doc/1.7/book/box/data_model.rst:302
msgid "MsgPack data type |br| (and possible values)"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:302 ../doc/1.7/book/box/data_model.rst:670
msgid "Index type"
msgstr "Тип индекса"

#: ../doc/1.7/book/box/data_model.rst:305
msgid "**unsigned** (may also be called ‘uint’ or ‘num’, but ‘num’ is deprecated)"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:305
#, fuzzy
msgid ""
"**integer** (integer between 0 and 18446744073709551615, i.e. about 18 "
"quintillion)"
msgstr ""
"``unsigned`` (беззнаковое целое число в диапазоне от 0 до "
"18,446,744,073,709,551,615)"

#: ../doc/1.7/book/box/data_model.rst:305 ../doc/1.7/book/box/data_model.rst:325
msgid "TREE, BITSET or HASH"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:305
#, fuzzy
msgid "123456"
msgstr "12345"

#: ../doc/1.7/book/box/data_model.rst:310
msgid "**integer** (may also be called ‘int’)"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:310 ../doc/1.7/book/box/data_model.rst:315
#: ../doc/1.7/book/box/data_model.rst:340
#, fuzzy
msgid "**integer** (integer between -9223372036854775808 and 18446744073709551615)"
msgstr ""
"``integer`` (знаковое целое число в диапазоне от -9,223,372,036,854,775,808 до "
"9,223,372,036,854,775,807)"

#: ../doc/1.7/book/box/data_model.rst:310 ../doc/1.7/book/box/data_model.rst:315
#: ../doc/1.7/book/box/data_model.rst:329 ../doc/1.7/book/box/data_model.rst:337
msgid "TREE or HASH"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:310
msgid "-2^63"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:320 ../doc/1.7/book/box/data_model.rst:345
msgid ""
"**double** (single-precision floating point number or double-precision floating "
"point number)"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:315 ../doc/1.7/book/box/data_model.rst:341
#, fuzzy
msgid "1.234"
msgstr "12345"

#: ../doc/1.7/book/box/data_model.rst:317
msgid "-44"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:319
msgid "1.447e+44"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:325
msgid "**string** (may also be called ‘str’)"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:325
msgid "**string** (any set of octets, up to the maximum length)"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:325
msgid "‘A B C’"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:327
msgid "‘\\65 \\66 \\67’"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:329 ../doc/1.7/book/box/data_model.rst:337
#, fuzzy
msgid "**bool** (true or false)"
msgstr ""
"Тип *boolean* (логический) может иметь только значения ``true`` или ``false``."

#: ../doc/1.7/book/box/data_model.rst:332
msgid "**array** (list of numbers representing points in a geometric figure)"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:332
msgid "RTREE"
msgstr "RTREE"

#: ../doc/1.7/book/box/data_model.rst:332
msgid "{10, 11}"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:334
msgid "{3, 5, 9, 10}"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:350
#, fuzzy
msgid "**string** (any set of octets)"
msgstr "``string`` (строковое значение, т.е. любая последовательность октетов)"

#: ../doc/1.7/book/box/data_model.rst:352
msgid ""
"Note: When there is a mix of types, the key order is: booleans, then numbers, "
"then strings."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:339
msgid "-1"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:343
msgid "‘’"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:345
msgid "‘ру’"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:362
msgid "Persistence"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:364
msgid ""
"In Tarantool, updates to the database are recorded in the so-called :ref:`write "
"ahead log (WAL) <internals-wal>` files. This ensures data persistence. When a "
"power outage occurs or the Tarantool instance is killed incidentally, the in-"
"memory database is lost. In this situation, WAL files are used to restore the "
"data. Namely, Tarantool reads the WAL files and redoes the requests (this is "
"called the \"recovery process\"). You can change the timing of the WAL writer, "
"or turn it off, by setting :ref:`wal_mode <cfg_binary_logging_snapshots-"
"wal_mode>`."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:373
msgid ""
"Tarantool also maintains a set of :ref:`snapshot files <internals-snapshot>`. "
"These files contain an on-disk copy of the entire data set for a given moment. "
"Instead of reading every WAL file since the databases were created, the recovery "
"process can load the latest snapshot file and then read only those WAL files "
"that were produced after the snapshot file was made. After checkpointing, old "
"WAL files can be removed to free up space."
msgstr ""
"Tarantool также сохраняет ряд файлов со статическими снимками данных (:ref:"
"`snapshots <internals-snapshot>`). Файл со снимком — это дисковая копия всех "
"данных в базе на какой-то момент. Вместо того, чтобы зачитывать все WAL-файлы, "
"появившиеся с момента создания базы, Tarantool в процессе восстановления может "
"загрузить самый свежий снимок и затем зачитать только те WAL-файлы, которые были "
"сделаны с момента сохранения снимка. После создания новых файлов, старые WAL-"
"файлы могут быть удалены в целях экономии места на диске."

#: ../doc/1.7/book/box/data_model.rst:380
msgid ""
"To force immediate creation of a snapshot file, you can use Tarantool's :ref:"
"`box.snapshot() <box-snapshot>` request. To enable automatic creation of "
"snapshot files, you can use Tarantool's :ref:`checkpoint daemon "
"<book_cfg_checkpoint_daemon>`. The checkpoint daemon sets intervals for forced "
"checkpoints. It makes sure that the states of both memtx and vinyl storage "
"engines are synchronized and saved to disk, and automatically removes old WAL "
"files."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:388
msgid "Snapshot files can be created even if there is no WAL file."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:392
msgid ""
"The memtx engine makes only regular checkpoints with the interval set in :ref:"
"`checkpoint daemon <book_cfg_checkpoint_daemon>` configuration."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:395
msgid "The vinyl engine runs checkpointing in the background at all times."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:397
msgid ""
"See the :ref:`Internals <internals-data_persistence>` section for more details "
"about the WAL writer and the recovery process."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:402
msgid "Operations"
msgstr "Операции"

#: ../doc/1.7/book/box/data_model.rst:408
#, fuzzy
msgid "Data operations"
msgstr "Операции с индексами"

#: ../doc/1.7/book/box/data_model.rst:410
msgid "The basic data operations supported in Tarantool are:"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:412
msgid "one data-retrieval operation (SELECT), and"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:413
msgid ""
"five data-manipulation operations (INSERT, UPDATE, UPSERT, DELETE, REPLACE)."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:415
msgid ""
"All of them are implemented as functions in :ref:`box.space <box_space>` "
"submodule."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:417 ../doc/1.7/book/box/data_model.rst:588
#, fuzzy
msgid "**Examples**"
msgstr "**Примеры:**"

#: ../doc/1.7/book/box/data_model.rst:419
msgid ":ref:`INSERT <box_space-insert>`: Add a new tuple to space 'tester'."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:421
msgid "The first field, field[1], will be 999 (MsgPack type is `integer`)."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:423
msgid "The second field, field[2], will be 'Taranto' (MsgPack type is `string`)."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:425
#, fuzzy
msgid "tarantool> box.space.tester:insert{999, 'Taranto'}"
msgstr "tarantool> {**{box.space.tester:select{2}}**}"

#: ../doc/1.7/book/box/data_model.rst:429
msgid ""
":ref:`UPDATE <box_space-update>`: Update the tuple, changing field field[2]."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:431
msgid ""
"The clause \"{999}\", which has the value to look up in the index of the tuple's "
"primary-key field, is mandatory, because ``update()`` requests must always have "
"a clause that specifies a unique key, which in this case is field[1]."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:435
msgid ""
"The clause \"{{'=', 2, 'Tarantino'}}\" specifies that assignment will happen to "
"field[2] with the new value."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:438
#, fuzzy
msgid "tarantool> box.space.tester:update({999}, {{'=', 2, 'Tarantino'}})"
msgstr "tarantool> box.space.tester:update({3}, {{'=', 2, 'size'}, {'=', 3, 0}})"

#: ../doc/1.7/book/box/data_model.rst:442
msgid ""
":ref:`UPSERT <box_space-upsert>`: Upsert the tuple, changing field field[2] "
"again."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:444
msgid ""
"The syntax of ``upsert()`` is similar to the syntax of ``update()``. However, "
"the execution logic of these two requests is different. UPSERT is either UPDATE "
"or INSERT, depending on the database's state. Also, UPSERT execution is "
"postponed after transaction commit, so, unlike ``update()``, ``upsert()`` "
"doesn't return data back."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:450
#, fuzzy
msgid "tarantool> box.space.tester:upsert({999}, {{'=', 2, 'Tarantism'}})"
msgstr "tarantool> box.space.tester:update({3}, {{'=', 2, 'size'}, {'=', 3, 0}})"

#: ../doc/1.7/book/box/data_model.rst:454
msgid ":ref:`REPLACE <box_space-replace>`: Replace the tuple, adding a new field."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:456
msgid ""
"This is also possible with the ``update()`` request, but the ``update()`` "
"request is usually more complicated."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:459
msgid "tarantool> box.space.tester:replace{999, 'Tarantella', 'Tarantula'}"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:463
msgid ":ref:`SELECT <box_space-select>`: Retrieve the tuple."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:465
msgid ""
"The clause \"{999}\" is still mandatory, although it does not have to mention "
"the primary key."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:467
#, fuzzy
msgid "tarantool> box.space.tester:select{999}"
msgstr "tarantool> {**{box.space.tester:select{2}}**}"

#: ../doc/1.7/book/box/data_model.rst:470
msgid ":ref:`DELETE <box_space-delete>`: Delete the tuple."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:472
msgid "In this example, we identify the primary-key field."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:474
#, fuzzy
msgid "tarantool> box.space.tester:delete{999}"
msgstr "tarantool> {**{box.space.tester:select{2}}**}"

#: ../doc/1.7/book/box/data_model.rst:478
msgid ""
"All the functions operate on tuples and accept only unique key values. So, the "
"number of tuples in the space is always 0 or 1, since the keys are unique."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:481
msgid ""
"Functions ``insert()``, ``upsert()`` and ``replace()`` accept only primary-key "
"values. Functions ``select()``, ``delete()`` and ``update()`` may accept either "
"a primary-key value or a secondary-key value."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:487
msgid ""
"Besides Lua, you can use :ref:`Perl, PHP, Python or other programming language "
"connectors <index-box_connectors>`. The client server protocol is open and "
"documented. See this :ref:`annotated BNF <box_protocol-iproto_protocol>`."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:494
msgid "Index operations"
msgstr "Операции с индексами"

#: ../doc/1.7/book/box/data_model.rst:496
#, fuzzy
msgid ""
"Index operations are automatic: if a data-manipulation request changes a tuple, "
"then it also changes the index keys defined for the tuple."
msgstr ""
"Операции с индексами производятся автоматически. Если запрос по манипулированию "
"данными меняет данные в кортеже, то меняются и ключи в индексе для данного "
"кортежа. Поэтому пользователю нужно знать только как и зачем задавать индексы."

#: ../doc/1.7/book/box/data_model.rst:499
#, fuzzy
msgid "The simple index-creation operation that we've illustrated before is:"
msgstr ""
"Простая операция для создания индекса, которую мы рассматривали ранее, имела "
"следующий вид:"

#: ../doc/1.7/book/box/data_model.rst:504
msgid ":samp:`box.space.{space-name}:create_index('{index-name}')`"
msgstr ":samp:`box.space.{имя-пространства}:create_index('{имя-индекса}')`"

#: ../doc/1.7/book/box/data_model.rst:506
#, fuzzy
msgid ""
"This creates a unique TREE index on the first field of all tuples (often called "
"\"Field#1\"), which is assumed to be numeric."
msgstr ""
"По умолчанию, при этом создается TREE-индекс по первому полю (обычно его "
"называют \"Field#1\") для всех кортежей в пространстве. Предполагается, что "
"индексируемое поле является числовым."

#: ../doc/1.7/book/box/data_model.rst:509
#, fuzzy
msgid "The simple SELECT request that we've illustrated before is:"
msgstr "Вот простой SELECT-запрос, который мы рассматривали ранее:"

#: ../doc/1.7/book/box/data_model.rst:514
msgid ":extsamp:`box.space.{*{space-name}*}:select({*{value}*})`"
msgstr ":extsamp:`box.space.{*{имя-пространства}*}:select({*{значение}*})`"

#: ../doc/1.7/book/box/data_model.rst:516
#, fuzzy
msgid ""
"This looks for a single tuple via the first index. Since the first index is "
"always unique, the maximum number of returned tuples will be: one."
msgstr ""
"По умолчанию, такой запрос ищет нужный кортеж по значению в первом (первичном) "
"индексе. Поскольку первичный индекс всегда уникален, то данный запрос вернет не "
"более одного кортежа."

#: ../doc/1.7/book/box/data_model.rst:519
#, fuzzy
msgid "The following SELECT variations exist:"
msgstr "Также возможны следующие варианты:"

#: ../doc/1.7/book/box/data_model.rst:521
msgid "The search can use comparisons other than equality."
msgstr ""
"Помимо условия равенства, при поиске могут использоваться и другие условия "
"сравнения."

#: ../doc/1.7/book/box/data_model.rst:528
#, fuzzy
msgid ""
"The :ref:`comparison operators <box_index-iterator-types>` are LT, LE, EQ, REQ, "
"GE, GT (for \"less than\", \"less than or equal\", \"equal\", \"reversed equal"
"\", \"greater than or equal\", \"greater than\" respectively). Comparisons make "
"sense if and only if the index type is ‘TREE'."
msgstr ""
"Можно использовать следующие операторы сравнения: LT (меньше), LE (меньше или "
"равно), EQ (равно), REQ (неравно), GE (больше или равно), GT (больше). Сравнения "
"имеют смысл только для индексов типа 'tree'."

#: ../doc/1.7/book/box/data_model.rst:533
msgid ""
"This type of search may return more than one tuple; if so, the tuples will be in "
"descending order by key when the comparison operator is LT or LE or REQ, "
"otherwise in ascending order."
msgstr ""
"Этот вариант поиска может вернуть более одного кортежа. В таком случае кортежи "
"будут отсортированы в порядке убывания по ключу (если использовался оператор LT, "
"LE или REQ), либо в порядке возрастания (во всех остальных случаях)."

#: ../doc/1.7/book/box/data_model.rst:537
msgid "The search can use a secondary index."
msgstr "Поиск может производиться по вторичному индексу."

#: ../doc/1.7/book/box/data_model.rst:544
msgid ""
"For a primary-key search, it is optional to specify an index name. For a "
"secondary-key search, it is mandatory."
msgstr ""
"При поиске по первичному индексу имя индекса можно не указывать. При поиске же "
"по вторичному индексу имя индекса указывать необходимо."

#: ../doc/1.7/book/box/data_model.rst:547
msgid "The search may be for some or all key parts."
msgstr "Поиск может производиться как по всему ключу, так и по его частям."

#: ../doc/1.7/book/box/data_model.rst:568
#, fuzzy
msgid "The search may be for all fields, using a table for the value:"
msgstr ""
"Поиск может производиться по всем полям (в этом случае используется таблица "
"значений):"

#: ../doc/1.7/book/box/data_model.rst:575
msgid "or the search can be for one field, using a table or a scalar:"
msgstr ""
"либо же по одному полю (в этом случае используется таблица или скалярное "
"значение):"

#: ../doc/1.7/book/box/data_model.rst:582
#, fuzzy
msgid ""
"In the second case, the result will be two tuples: ``{1, 'A'}`` and ``{1, 'B'}``."
msgstr ""
"Во втором случае Tarantool вернет два кортежа: ``{1, 'A'}`` и ``{1, 'B'}``. При "
"необходимости можно задать даже нулевые поля, в результате чего Tarantool вернет "
"все три кортежа."

#: ../doc/1.7/book/box/data_model.rst:585
msgid ""
"You can specify even zero fields, causing all three tuples to be returned. "
"(Notice that partial key searches are available only in TREE indexes.)"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:590
msgid "BITSET example:"
msgstr "Пример работы с BITSET-индексом:"

#: ../doc/1.7/book/box/data_model.rst:592
msgid ""
"tarantool> box.schema.space.create('bitset_example')\n"
"tarantool> box.space.bitset_example:create_index('primary')\n"
"tarantool> box.space.bitset_example:create_index('bitset',{unique=false,"
"type='BITSET', parts={2,'unsigned'}})\n"
"tarantool> box.space.bitset_example:insert{1,1}\n"
"tarantool> box.space.bitset_example:insert{2,4}\n"
"tarantool> box.space.bitset_example:insert{3,7}\n"
"tarantool> box.space.bitset_example:insert{4,3}\n"
"tarantool> box.space.bitset_example.index.bitset:select(2, "
"{iterator='BITS_ANY_SET'})"
msgstr ""
"tarantool> box.schema.space.create('bitset_example')\n"
"tarantool> box.space.bitset_example:create_index('primary')\n"
"tarantool> box.space.bitset_example:create_index('bitset',{unique=false,"
"type='BITSET', parts={2,'unsigned'}})\n"
"tarantool> box.space.bitset_example:insert{1,1}\n"
"tarantool> box.space.bitset_example:insert{2,4}\n"
"tarantool> box.space.bitset_example:insert{3,7}\n"
"tarantool> box.space.bitset_example:insert{4,3}\n"
"tarantool> box.space.bitset_example.index.bitset:select(2, "
"{iterator='BITS_ANY_SET'})"

#: ../doc/1.7/book/box/data_model.rst:603 ../doc/1.7/book/box/data_model.rst:625
#: ../doc/1.7/tutorials/lua_tutorials.rst:877
msgid "The result will be:"
msgstr "Мы получим следующий результат:"

#: ../doc/1.7/book/box/data_model.rst:605
msgid ""
"---\n"
"- - [3, 7]\n"
"  - [4, 3]\n"
"..."
msgstr ""
"---\n"
"- - [3, 7]\n"
"  - [4, 3]\n"
"..."

#: ../doc/1.7/book/box/data_model.rst:612
msgid "because (7 AND 2) is not equal to 0, and (3 AND 2) is not equal to 0."
msgstr "поскольку (7 AND 2) не равно 0 и (3 AND 2) не равно 0."

#: ../doc/1.7/book/box/data_model.rst:614
msgid "RTREE example:"
msgstr "Пример работы с RTREE-индексом:"

#: ../doc/1.7/book/box/data_model.rst:616
msgid ""
"tarantool> box.schema.space.create('rtree_example')\n"
"tarantool> box.space.rtree_example:create_index('primary')\n"
"tarantool> box.space.rtree_example:create_index('rtree',{unique=false,"
"type='RTREE', parts={2,'ARRAY'}})\n"
"tarantool> box.space.rtree_example:insert{1, {3, 5, 9, 10}}\n"
"tarantool> box.space.rtree_example:insert{2, {10, 11}}\n"
"tarantool> box.space.rtree_example.index.rtree:select({4, 7, 5, 9}, {iterator = "
"'GT'})"
msgstr ""
"tarantool> box.schema.space.create('rtree_example')\n"
"tarantool> box.space.rtree_example:create_index('primary')\n"
"tarantool> box.space.rtree_example:create_index('rtree',{unique=false,"
"type='RTREE', parts={2,'ARRAY'}})\n"
"tarantool> box.space.rtree_example:insert{1, {3, 5, 9, 10}}\n"
"tarantool> box.space.rtree_example:insert{2, {10, 11}}\n"
"tarantool> box.space.rtree_example.index.rtree:select({4, 7, 5, 9}, {iterator = "
"'GT'})"

#: ../doc/1.7/book/box/data_model.rst:627
msgid ""
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"..."
msgstr ""
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"..."

#: ../doc/1.7/book/box/data_model.rst:633
#, fuzzy
msgid ""
"because a rectangle whose corners are at coordinates ``4,7,5,9`` is entirely "
"within a rectangle whose corners are at coordinates ``3,5,9,10``."
msgstr ""
"поскольку прямоугольник с углами в координатах 4,7,5,9 лежит целиком внутри "
"прямоугольника с углами в координатах 3,5,9,10."

#: ../doc/1.7/book/box/data_model.rst:636
msgid ""
"Additionally, there exist :ref:`index iterator operations <box_index-"
"index_pairs>`. They can only be used with code in Lua and C/C++. Index iterators "
"are for traversing indexes one key at a time, taking advantage of features that "
"are specific to an index type, for example evaluating Boolean expressions when "
"traversing BITSET indexes, or going in descending order when traversing TREE "
"indexes."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:642
msgid ""
"See also other index operations like :ref:`alter() <box_index-alter>` and :ref:"
"`drop() <box_index-drop>` in reference for :ref:`box.index <box_index>` "
"submodule."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:647
msgid "Complexity factors"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:649
msgid ""
"In reference for :ref:`box.space <box_space>` and :ref:`box.index <box_index>` "
"submodules, there are notes about which complexity factors might affect the "
"resource usage of each function."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:659
msgid "Complexity factor"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:662
msgid "Index size"
msgstr "Размер индекса"

#: ../doc/1.7/book/box/data_model.rst:662
#, fuzzy
msgid ""
"The number of index keys is the same as the number of tuples in the data set. "
"For a TREE index, if there are more keys, then the lookup time will be greater, "
"although of course the effect is not linear. For a HASH index, if there are more "
"keys, then there is more RAM used, but the number of low-level steps tends to "
"remain constant."
msgstr ""
"Количество ключей в индексе равно количеству кортежей в наборе данных. В случае "
"с TREE-индексом: с ростом количества ключей увеличивается время поиска, хотя "
"зависимость здесь, конечно же, не линейная. В случае с HASH-индексом: с ростом "
"количества ключей увеличивается объем используемой памяти, но количество "
"низкоуровневых шагов остается примерно тем же."

#: ../doc/1.7/book/box/data_model.rst:670
#, fuzzy
msgid ""
"Typically, a HASH index is faster than a TREE index if the number of tuples in "
"the space is greater than one."
msgstr ""
"Как правило, поиск по HASH-индексу работает быстрее, чем по TREE-индексу, если в "
"наборе есть более одного кортежа."

#: ../doc/1.7/book/box/data_model.rst:674
msgid "Number of indexes accessed"
msgstr "Количество обращений к индексам"

#: ../doc/1.7/book/box/data_model.rst:674
#, fuzzy
msgid ""
"Ordinarily, only one index is accessed to retrieve one tuple. But to update the "
"tuple, there must be N accesses if the space has N different indexes."
msgstr ""
"Обычно для выборки значений одного кортежа используется только один индекс. Но "
"при обновлении значений в кортеже требуется N обращений, если у набора кортежей "
"есть N индексов."

#: ../doc/1.7/book/box/data_model.rst:678
msgid ""
"Note re storage engine: Vinyl optimizes away such accesses if secondary index "
"fields are unchanged by the update. So, this complexity factor applies only to "
"memtx, since it always makes a full-tuple copy on every update."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:684
msgid "Number of tuples accessed"
msgstr "Количество обращений к кортежам"

#: ../doc/1.7/book/box/data_model.rst:684
#, fuzzy
msgid ""
"A few requests, for example SELECT, can retrieve multiple tuples. This factor is "
"usually less important than the others."
msgstr ""
"Некоторые запросы, например SELECT, могут возвращать несколько кортежей. Как "
"правило, это наименее важный фактор из всех."

#: ../doc/1.7/book/box/data_model.rst:688
msgid "WAL settings"
msgstr "Настройки WAL"

#: ../doc/1.7/book/box/data_model.rst:688
msgid ""
"The important setting for the write-ahead log is :ref:`wal_mode "
"<cfg_binary_logging_snapshots-wal_mode>`. If the setting causes no writing or "
"delayed writing, this factor is unimportant. If the setting causes every data-"
"change request to wait for writing to finish on a slow device, this factor is "
"more important than all the others."
msgstr ""
"Важным параметром для записи в WAL является :ref:`wal_mode "
"<cfg_binary_logging_snapshots-wal_mode>`. Если запись в WAL отключена или задана "
"запись с задержкой, но этот фактор не так важен. Если же запись в WAL "
"производится при каждом запросе на изменение данных, то при каждом таком запросе "
"приходится ждать, пока отработает обращение к более медленному диску, и данный "
"фактор становится важнее всех остальных."

#: ../doc/1.7/book/box/index.rst:39
msgid "Database"
msgstr "Функционал СУБД"

#: ../doc/1.7/book/box/index.rst:41
msgid ""
"In this chapter, we introduce the basic concepts of working with Tarantool as a "
"database manager."
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:39
msgid "Limitations"
msgstr "Ограничения"

#: ../doc/1.7/book/box/limitations.rst:41
msgid "**Number of parts in an index**"
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:43
msgid ""
"For TREE or HASH indexes, the maximum is 255 (``box.schema.INDEX_PART_MAX``). "
"For ref:`RTREE <box_index-rtree>` indexes, the maximum is 1 but the field is an "
"ARRAY of up to 20 dimensions. For BITSET indexes, the maximum is 1."
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:50
msgid "**Number of indexes in a space**"
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:52
msgid "128 (``box.schema.INDEX_MAX``)."
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:56
msgid "**Number of fields in a tuple**"
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:58
msgid ""
"The theoretical maximum is 2,147,483,647 (``box.schema.FIELD_MAX``). The "
"practical maximum is whatever is specified by the space's :ref:`field_count "
"<box_space-field_count>` member, or the maximal tuple length."
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:65
msgid "**Number of bytes in a tuple**"
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:67
msgid ""
"The maximal number of bytes in a tuple is roughly equal to :ref:"
"`memtx_max_tuple_size <cfg_storage-memtx_max_tuple_size>` or :ref:"
"`vinyl_max_tuple_size <cfg_storage-vinyl_max_tuple_size>` (with a metadata "
"overhead of about 20 bytes per tuple, which is added on top of useful bytes). By "
"default, the value of either ``memtx_max_tuple_size`` or "
"``vinyl_max_tuple_size`` is 1,048,576. To increase it, specify a larger value "
"when starting the Tarantool instance. For example, ``box."
"cfg{memtx_max_tuple_size=2*1048576}``."
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:79
msgid "**Number of bytes in an index key**"
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:81
msgid ""
"If a field in a tuple can contain a million bytes, then the index key can "
"contain a million bytes, so the maximum is determined by factors such as :ref:"
"`Number of bytes in a tuple <limitations_bytes_in_tuple>`, not by the index "
"support."
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:88
msgid "**Number of spaces**"
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:90
msgid ""
"The theoretical maximum is 2147483647 (``box.schema.SPACE_MAX``) but the "
"practical maximum is around 65,000."
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:95
msgid "**Number of connections**"
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:97
msgid ""
"The practical limit is the number of file descriptors that one can set with the "
"operating system."
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:102
msgid "**Space size**"
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:104
msgid ""
"The total maximum size for all spaces is in effect set by :ref:`memtx_memory "
"<cfg_storage-memtx_memory>`, which in turn is limited by the total available "
"memory."
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:110
msgid "**Update operations count**"
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:112
msgid ""
"The maximum number of operations that can be in a single update is 4000 "
"(``BOX_UPDATE_OP_CNT_MAX``)."
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:117
msgid "**Number of users and roles**"
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:119
msgid "32 (``BOX_USER_MAX``)."
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:123
msgid "**Length of an index name or space name or user name**"
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:125
msgid "65000 (``box.schema.NAME_MAX``)."
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:129
msgid "**Number of replicas in a replica set**"
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:131
msgid "32 (``box.schema.REPLICA_MAX``)."
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:40
msgid "Triggers"
msgstr "Триггеры"

#: ../doc/1.7/book/box/triggers.rst:42
msgid ""
"**Triggers**, also known as **callbacks**, are functions which the server "
"executes when certain events happen."
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:45
msgid "There are three types of triggers in Tarantool:"
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:47
msgid ""
":ref:`connection triggers <box_session-on_connect>`, which are executed when a "
"session begins or ends,"
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:50
msgid ""
":ref:`authentication triggers <box_session-on_auth>`, which are executed during "
"authentication, and"
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:53
msgid ""
":ref:`replace triggers <box_space-on_replace>`, which are for database events."
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:56
msgid "All triggers have the following characteristics:"
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:58
msgid ""
"Triggers associate a function with an event. The request to \"define a trigger\" "
"implies passing the trigger’s function to one of the \"on_event()\" functions: :"
"ref:`box.session.on_connect() <box_session-on_connect>`, :ref:`box.session."
"on_auth() <box_session-on_auth>`, :ref:`box.session.on_disconnect() <box_session-"
"on_disconnect>`, or :ref:`space_object:on_replace() <box_space-on_replace>`."
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:66
msgid ""
"Triggers are defined only by the :ref:`'admin' user <authentication-"
"owners_privileges>`."
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:68
msgid ""
"Triggers are stored in the Tarantool instance's memory, not in the database. "
"Therefore triggers disappear when the instance is shut down. To make them "
"permanent, put function definitions and trigger settings into Tarantool's :ref:"
"`initialization script <index-init_label>`."
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:73
msgid ""
"Triggers have low overhead. If a trigger is not defined, then the overhead is "
"minimal: merely a pointer dereference and check. If a trigger is defined, then "
"its overhead is equivalent to the overhead of calling a function."
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:77
msgid ""
"There can be multiple triggers for one event. In this case, triggers are "
"executed in the reverse order that they were defined in."
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:80
msgid ""
"Triggers must work within the event context. However, effects are undefined if a "
"function contains requests which normally could not occur immediately after the "
"event, but only before the return from the event. For example, putting `os."
"exit() <http://www.lua.org/manual/5.1/manual.html#pdf-os.exit>`_ or :ref:`box."
"rollback() <box-rollback>` in a trigger function would be bringing in requests "
"outside the event context."
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:87
msgid ""
"Triggers are replaceable. The request to \"redefine a trigger\" implies passing "
"a new trigger function and an old trigger function to one of the \"on_event()\" "
"functions."
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:91
msgid ""
"The \"on_event()\" functions all have parameters which are function pointers, "
"and they all return function pointers. Remember that a Lua function definition "
"such as \"function f() x = x + 1 end\" is the same as \"f = function () x = x + "
"1 end\" -- in both cases ``f`` gets a function pointer. And \"trigger = box."
"session.on_connect(f)\" is the same as \"trigger = box.session."
"on_connect(function () x = x + 1 end)\" -- in both cases ``trigger`` gets the "
"function pointer which was passed."
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:99
msgid "To get a list of triggers, you can use:"
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:101
msgid ""
"on_connect() – with no arguments – to return a table of all connect-trigger "
"functions;"
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:102
msgid "on_auth() to return all authentication-trigger functions;"
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:103
msgid "on_disconnect() to return all disconnect-trigger functions;"
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:104
msgid "on_replace() to return all replace-trigger functions."
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:108
msgid "Here we log connect and disconnect events into Tarantool server log."
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:110
msgid ""
"log = require('log')\n"
"\n"
"function on_connect_impl()\n"
"  log.info(\"connected \"..box.session.peer()..\", sid \"..box.session.id())\n"
"end\n"
"\n"
"function on_disconnect_impl()\n"
"  log.info(\"disconnected, sid \"..box.session.id())\n"
"end\n"
"\n"
"function on_auth_impl(user)\n"
"  log.info(\"authenticated sid \"..box.session.id()..\" as \"..user)\n"
"end\n"
"\n"
"function on_connect() pcall(on_connect_impl) end\n"
"function on_disconnect() pcall(on_disconnect_impl) end\n"
"function on_auth(user) pcall(on_auth_impl, user) end\n"
"\n"
"box.session.on_connect(on_connect)\n"
"box.session.on_disconnect(on_disconnect)\n"
"box.session.on_auth(on_auth)"
msgstr ""

#: ../doc/1.7/book/connectors/index.rst:39
msgid "Connectors"
msgstr "Коннекторы"

#: ../doc/1.7/book/connectors/index.rst:41
msgid "This chapter documents APIs for various programming languages."
msgstr "В этой главе описаны API для различных языков программирования."

#: ../doc/1.7/book/connectors/index.rst:45
msgid "Protocol"
msgstr "Протокол"

#: ../doc/1.7/book/connectors/index.rst:47
#, fuzzy
msgid ""
"Tarantool's binary protocol was designed with a focus on asynchronous I/O and "
"easy integration with proxies. Each client request starts with a variable-length "
"binary header, containing request id, request type, instance id, log sequence "
"number, and so on."
msgstr ""
"Бинарный протокол для передачи данных в Tarantool'е был разработан с учетом "
"потребностей асинхронного ввода-вывода. Основная его задача — облегчить "
"интеграцию Tarantool'а с клиентскими приложениями. Клиентский запрос в Tarantool-"
"протоколе начинается с бинарного заголовка переменной длины. В заголовке "
"указывается идентификатор и тип запроса, идентификатор сервера, номер записи в "
"журнале и т.д."

#: ../doc/1.7/book/connectors/index.rst:52
msgid ""
"The mandatory length, present in request header simplifies client or proxy I/O. "
"A response to a request is sent to the client as soon as it is ready. It always "
"carries in its header the same type and id as in the request. The id makes it "
"possible to match a request to a response, even if the latter arrived out of "
"order."
msgstr ""
"Также в заголовке обязательно указывается длина запроса, что облегчает обработку "
"данных. Ответ на запрос посылается по мере готовности. В заголовке ответа "
"указывается тот же идентификатор и тип запроса, что и в изначальном запросе. По "
"идентификатору можно легко соотнести запрос с ответом, даже если ответ был "
"получен не в порядке отсылки запросов."

#: ../doc/1.7/book/connectors/index.rst:58
msgid ""
"Unless implementing a client driver, you needn't concern yourself with the "
"complications of the binary protocol. Language-specific drivers provide a "
"friendly way to store domain language data structures in Tarantool. A complete "
"description of the binary protocol is maintained in annotated Backus-Naur form "
"in the source tree: please see the page about :ref:`Tarantool's binary protocol "
"<box_protocol-iproto_protocol>`."
msgstr ""
"Вдаваться в тонкости реализации Tarantool-протокола нужно только при разработке "
"нового коннектора для Tarantool'а — см. :ref:`полное описание бинарного "
"протокола в Tarantool'е <box_protocol-iproto_protocol>` в виде аннотированных "
"BNF-диаграмм (Backus-Naur Form). В остальных случаях достаточно взять уже "
"существующий коннектор для нужного вам языка программирования. Такие коннекторы "
"позволяют легко хранить структуры данных из разных языков в формате Tarantool'а."

#: ../doc/1.7/book/connectors/index.rst:67
msgid "Packet example"
msgstr "Пример пакета данных"

#: ../doc/1.7/book/connectors/index.rst:69
#, fuzzy
msgid ""
"The Tarantool API exists so that a client program can send a request packet to a "
"server instance, and receive a response. Here is an example of a what the client "
"would send for ``box.space[513]:insert{'A', 'BB'}``. The BNF description of the "
"components is on the page about :ref:`Tarantool's binary protocol <box_protocol-"
"iproto_protocol>`."
msgstr ""
"С помощью Tarantool API клиентские программы могут посылать в адрес Tarantool-"
"сервера пакеты с запросами и получать на них ответы. Вот пример исходящего "
"пакета, который будет сформирован для запроса :code:`box.space[513]:insert{'A', "
"'BB'}`. Описания компонентов запроса (в виде BNF-диаграмм) вы найдете на "
"странице о :ref:`бинарном протоколе в Tarantool'е <box_protocol-"
"iproto_protocol>`."

#: ../doc/1.7/book/connectors/index.rst:85
msgid "Component"
msgstr "Компонент"

#: ../doc/1.7/book/connectors/index.rst:85
msgid "Byte #0"
msgstr "Байт #0"

#: ../doc/1.7/book/connectors/index.rst:85
msgid "Byte #1"
msgstr "Байт #1"

#: ../doc/1.7/book/connectors/index.rst:85
msgid "Byte #2"
msgstr "Байт #2"

#: ../doc/1.7/book/connectors/index.rst:85
msgid "Byte #3"
msgstr "Байт #3"

#: ../doc/1.7/book/connectors/index.rst:87
msgid "code for insert"
msgstr "код для вставки"

#: ../doc/1.7/book/connectors/index.rst:87 ../doc/1.7/book/connectors/index.rst:91
msgid "02"
msgstr "02"

#: ../doc/1.7/book/connectors/index.rst:89
msgid "rest of header"
msgstr "остаток заголовка"

#: ../doc/1.7/book/connectors/index.rst:89
msgid "..."
msgstr "..."

#: ../doc/1.7/book/connectors/index.rst:91
msgid "2-digit number: space id"
msgstr "число из 2 цифр: ID пространства"

#: ../doc/1.7/book/connectors/index.rst:91
msgid "cd"
msgstr "cd"

#: ../doc/1.7/book/connectors/index.rst:91
msgid "01"
msgstr "01"

#: ../doc/1.7/book/connectors/index.rst:93
msgid "code for tuple"
msgstr "код для кортежа"

#: ../doc/1.7/book/connectors/index.rst:93
msgid "21"
msgstr "21"

#: ../doc/1.7/book/connectors/index.rst:95
msgid "1-digit number: field count = 2"
msgstr "число из 1 цифры: количество полей = 2"

#: ../doc/1.7/book/connectors/index.rst:95
msgid "92"
msgstr "92"

#: ../doc/1.7/book/connectors/index.rst:97
msgid "1-character string: field[1]"
msgstr "строка из 1 символа: поле[1]"

#: ../doc/1.7/book/connectors/index.rst:97
msgid "a1"
msgstr "a1"

#: ../doc/1.7/book/connectors/index.rst:97
msgid "41"
msgstr "41"

#: ../doc/1.7/book/connectors/index.rst:99
msgid "2-character string: field[2]"
msgstr "строка из 2 символов: поле[2]"

#: ../doc/1.7/book/connectors/index.rst:99
msgid "a2"
msgstr "a2"

#: ../doc/1.7/book/connectors/index.rst:99
msgid "42"
msgstr "42"

#: ../doc/1.7/book/connectors/index.rst:102
#, fuzzy
msgid ""
"Now, you could send that packet to the Tarantool instance, and interpret the "
"response (the page about :ref:`Tarantool's binary protocol <box_protocol-"
"iproto_protocol>` has a description of the packet format for responses as well "
"as requests). But it would be easier, and less error-prone, if you could invoke "
"a routine that formats the packet according to typed parameters. Something like "
"``response = tarantool_routine(\"insert\", 513, \"A\", \"B\");``. And that is "
"why APIs exist for drivers for Perl, Python, PHP, and so on."
msgstr ""
"Теперь получившийся пакет можно послать Tarantool-серверу и затем "
"проинтерпретировать полученный ответ (описания компонентов ответа вы найдете на "
"той же странице о :ref:`бинарном протоколе в Tarantool'е <box_protocol-"
"iproto_protocol>`). Но более простым и верным способом будет вызвать процедуру, "
"которая за вас сформирует готовый пакет с заданными параметрами. Что-то вроде :"
"samp:`response=tarantool_routine(\"insert\",513,\"A\",\"B\");`. Для этого в "
"Tarantool'е существуют API для Perl, Python, PHP и других программных языков."

#: ../doc/1.7/book/connectors/index.rst:115
msgid "Setting up the server for connector examples"
msgstr "Настройка окружения для примеров работы с коннекторами"

#: ../doc/1.7/book/connectors/index.rst:117
#, fuzzy
msgid ""
"This chapter has examples that show how to connect to a Tarantool instance via "
"the Perl, PHP, Python, node.js, and C connectors. The examples contain hard code "
"that will work if and only if the following conditions are met:"
msgstr ""
"В этой главе приводятся примеры того, как можно установить соединение с "
"Tarantool-сервером с помощью коннекторов для языков Perl, PHP, Python и C. "
"Обратите внимание, что в примерах исходного кода указаны фиксированные значения "
"для элементов тестового окружения, поэтому для корректной работы всех примеров "
"нужно соблюсти следующие условия:"

#: ../doc/1.7/book/connectors/index.rst:121
msgid ""
"the Tarantool instance (tarantool) is running on localhost (127.0.0.1) and is "
"listening on port 3301 (``box.cfg.listen = '3301'``),"
msgstr ""
"tarantool-сервер запущен на локальной машине (``localhost = 127.0.0.1``), а "
"прослушивание для него настроено на порту 3301 (:samp:`box.cfg.listen = '3301'`),"

#: ../doc/1.7/book/connectors/index.rst:124
#, fuzzy
msgid ""
"space ``examples`` has id = 999 (``box.space.examples.id = 999``) and has a "
"primary-key index for a numeric field (``box.space[999].index[0].parts[1].type = "
"\"unsigned\"``),"
msgstr ""
"в базе есть пространство ``examples`` с идентификатором 999 (:samp:`box.space."
"examples.id = 999`) и у него есть первичный индекс, построенный по ключу "
"числового типа (:samp:`box.space[999].index[0].parts[1].type = \"unsigned\"`),"

#: ../doc/1.7/book/connectors/index.rst:128
msgid "user 'guest' has privileges for reading and writing."
msgstr "для пользователя 'guest' настроены привилегии на чтение и запись."

#: ../doc/1.7/book/connectors/index.rst:130
#, fuzzy
msgid ""
"It is easy to meet all the conditions by starting the instance and executing "
"this script:"
msgstr ""
"Такое тестовое окружение легко настроить, запустив Tarantool-сервер локально и "
"выполнив следующие запросы:"

#: ../doc/1.7/book/connectors/index.rst:133
msgid ""
"box.cfg{listen=3301}\n"
"box.schema.space.create('examples',{id=999})\n"
"box.space.examples:create_index('primary', {type = 'hash', parts = {1, "
"'unsigned'}})\n"
"box.schema.user.grant('guest','read,write','space','examples')\n"
"box.schema.user.grant('guest','read','space','_space')"
msgstr ""
"box.cfg{listen=3301}\n"
"box.schema.space.create('examples',{id=999})\n"
"box.space.examples:create_index('primary', {type = 'hash', parts = {1, "
"'unsigned'}})\n"
"box.schema.user.grant('guest','read,write','space','examples')\n"
"box.schema.user.grant('guest','read','space','_space')"

#: ../doc/1.7/book/connectors/__java.rst:3
msgid "Java"
msgstr "Java"

#: ../doc/1.7/book/connectors/__java.rst:5
msgid "See http://github.com/tarantool/tarantool-java/."
msgstr "См. http://github.com/tarantool/tarantool-java/."

#: ../doc/1.7/book/connectors/__go.rst:3
msgid "Go"
msgstr "Go"

#: ../doc/1.7/book/connectors/__go.rst:5
msgid "Please see https://github.com/mialinx/go-tarantool."
msgstr "См. https://github.com/mialinx/go-tarantool."

#: ../doc/1.7/book/connectors/__r.rst:3
msgid "R"
msgstr "R"

#: ../doc/1.7/book/connectors/__r.rst:5
msgid "See https://github.com/thekvs/tarantoolr."
msgstr "См. https://github.com/thekvs/tarantoolr."

#: ../doc/1.7/book/connectors/__erlang.rst:3
#, fuzzy
msgid "Erlang"
msgstr "Perl"

#: ../doc/1.7/book/connectors/__erlang.rst:5
msgid "See `Erlang tarantool driver <https://github.com/stofel/taran>`_."
msgstr ""

#: ../doc/1.7/book/connectors/__perl.rst:3
msgid "Perl"
msgstr "Perl"

#: ../doc/1.7/book/connectors/__perl.rst:5
msgid ""
"The most commonly used Perl driver is `tarantool-perl <https://github.com/"
"tarantool/tarantool-perl>`_. It is not supplied as part of the Tarantool "
"repository; it must be installed separately. The most common way to install it "
"is by cloning from GitHub."
msgstr ""

#: ../doc/1.7/book/connectors/__perl.rst:10
msgid ""
"To avoid minor warnings that may appear the first time ``tarantool-perl`` is "
"installed, start with installing some other modules that ``tarantool-perl`` "
"uses, with `CPAN, the Comprehensive Perl Archive Network <https://en.wikipedia."
"org/wiki/Cpan>`_:"
msgstr ""

#: ../doc/1.7/book/connectors/__perl.rst:14
msgid ""
"$ sudo cpan install AnyEvent\n"
"$ sudo cpan install Devel::GlobalDestruction"
msgstr ""

#: ../doc/1.7/book/connectors/__perl.rst:19
msgid "Then, to install ``tarantool-perl`` itself, say:"
msgstr ""

#: ../doc/1.7/book/connectors/__perl.rst:21
#, fuzzy
msgid ""
"$ git clone https://github.com/tarantool/tarantool-perl.git tarantool-perl\n"
"$ cd tarantool-perl\n"
"$ git submodule init\n"
"$ git submodule update --recursive\n"
"$ perl Makefile.PL\n"
"$ make\n"
"$ sudo make install"
msgstr ""
"$ git clone git://github.com/tarantool/tarantool-c.git ~/tarantool-c\n"
"$ cd ~/tarantool-c\n"
"$ git submodule init\n"
"$ git submodule update\n"
"$ cmake .\n"
"$ make\n"
"$ make install"

#: ../doc/1.7/book/connectors/__perl.rst:31
#, fuzzy
msgid ""
"Here is a complete Perl program that inserts ``[99999,'BB']`` into "
"``space[999]`` via the Perl API. Before trying to run, check that the server "
"instance is listening at ``localhost:3301`` and that the space ``examples`` "
"exists, as :ref:`described earlier <index-connector_setting>`. To run, paste the "
"code into a file named :file:`example.pl` and say :samp:`perl example.pl`. The "
"program will connect using an application-specific definition of the space. The "
"program will open a socket connection with the Tarantool instance at "
"``localhost:3301``, then send an :ref:`space_object:INSERT<box_space-insert>` "
"request, then — if all is well — end without displaying any messages. If "
"Tarantool is not running on ``localhost`` with :ref:`listen<cfg_basic-listen>` "
"port = 3301, the program will print “Connection refused”."
msgstr ""
"Далее приводится пример полноценной программы на языке Perl, которая "
"осуществляет вставку кортежа ``[99999,'BB']`` в пространство ``space[999]`` с "
"помощью Tarantool API для языка Perl. Перед запуском данной программы проверьте, "
"что ваше тестовое окружение настроено так, как :ref:`описано выше <index-"
"connector_setting>` (у Tarantool-сервера задан порт для прослушивания и в базе "
"создано пространство ``examples``). Чтобы запустить тестовую программу, "
"сохраните ее исходный код в файл с именем :file:`example.pl` и выполните "
"команду :samp:`perl example.pl`. Программа установит соединение, используя "
"указанное в ней описание пространства, откроет сокет для соединения с Tarantool-"
"сервером по адресу ``localhost:3301``, пошлет INSERT-запрос, а затем — если всё "
"хорошо — закончит работу без каких-либо сообщений. Если окажется, что Tarantool-"
"сервер не запущен на прослушивание по указанному адресу, то программа выдаст "
"сообщение об ошибке “Connection refused”."

#: ../doc/1.7/book/connectors/__perl.rst:43
#, fuzzy
msgid ""
"#!/usr/bin/perl\n"
"use DR::Tarantool ':constant', 'tarantool';\n"
"use DR::Tarantool ':all';\n"
"use DR::Tarantool::MsgPack::SyncClient;\n"
"\n"
"my $tnt = DR::Tarantool::MsgPack::SyncClient->connect(\n"
"  host    => '127.0.0.1',                      # look for tarantool on "
"localhost\n"
"  port    => 3301,                             # on port 3301\n"
"  user    => 'guest',                          # username. for 'guest' we do not "
"also say 'password=>...'\n"
"\n"
"  spaces  => {\n"
"    999 => {                                   # definition of space[999] ...\n"
"      name => 'examples',                      #   space[999] name = 'examples'\n"
"      default_type => 'STR',                   #   space[999] field type is "
"'STR' if undefined\n"
"      fields => [ {                            #   definition of space[999]."
"fields ...\n"
"          name => 'field1', type => 'NUM' } ], #     space[999].field[1] "
"name='field1',type='NUM'\n"
"      indexes => {                             #   definition of space[999] "
"indexes ...\n"
"        0 => {\n"
"          name => 'primary', fields => [ 'field1' ] } } } } );\n"
"\n"
"$tnt->insert('examples' => [ 99999, 'BB' ]);"
msgstr ""
"#!/usr/bin/perl\n"
"use DR::Tarantool ':constant', 'tarantool';\n"
"use DR::Tarantool ':all';\n"
"use DR::Tarantool::MsgPack::SyncClient;\n"
"\n"
"my $tnt = DR::Tarantool::MsgPack::SyncClient->connect(\n"
"  host    => '127.0.0.1',                      # поиск Tarantool-сервера по "
"адресу localhost\n"
"  port    => 3301,                             # на порту 3301\n"
"  user    => 'guest',                          # имя пользователя; здесь же "
"можно добавить 'password=>...'\n"
"\n"
"  spaces  => {\n"
"    999 => {                                   # определение пространства "
"space[999] ...\n"
"      name => 'examples',                      # имя пространства space[999] = "
"'examples'\n"
"      default_type => 'STR',                   # если тип поля в space[999] не "
"задан, то = 'STR'\n"
"      fields => [ {                            # определение полей в "
"пространстве space[999] ...\n"
"          name => 'field1', type => 'NUM' } ], # имя поля space[999]."
"field[1]='field1', тип ='NUM'\n"
"      indexes => {                             # определение индексов "
"пространства space[999] ...\n"
"        0 => {\n"
"          name => 'primary', fields => [ 'field1' ] } } } } );\n"
"\n"
"$tnt->insert('examples' => [ 99999, 'BB' ]);"

#: ../doc/1.7/book/connectors/__perl.rst:67
#, fuzzy
msgid ""
"The example program uses field type names 'STR' and 'NUM' instead of :ref:"
"`'string' and 'unsigned'<box_space-create_index>`, due to a temporary Perl "
"limitation."
msgstr ""
"Из-за существующих ограничений в языке Perl, вместо полей типа 'string' и "
"'unsigned' в тестовой программе указаны поля типа 'STR' и 'NUM'."

#: ../doc/1.7/book/connectors/__perl.rst:70
#, fuzzy
msgid ""
"The example program only shows one request and does not show all that's "
"necessary for good practice. For that, please see the `tarantool-perl repository "
"<https://github.com/tarantool/tarantool-perl>`_."
msgstr ""
"В этой программе мы привели пример использования лишь одного запроса. Для "
"полноценной работы с Tarantool'ом с помощью PHP API, пожалуйста, обратитесь к "
"документации из `проекта tarantool-php на GitHub <https://github.com/tarantool/"
"tarantool-php>`_."

#: ../doc/1.7/book/connectors/__php.rst:3
msgid "PHP"
msgstr "PHP"

#: ../doc/1.7/book/connectors/__php.rst:5
msgid ""
"The most commonly used PHP driver is `tarantool-php <https://github.com/"
"tarantool/tarantool-php>`_. It is not supplied as part of the Tarantool "
"repository; it must be installed separately, for example with :program:`git`. "
"See `installation instructions <https://github.com/tarantool/tarantool-php/blob/"
"master/#installing-and-building>`_. in the driver's :file:`README` file."
msgstr ""

#: ../doc/1.7/book/connectors/__php.rst:12
#, fuzzy
msgid ""
"Here is a complete PHP program that inserts ``[99999,'BB']`` into a space named "
"``examples`` via the PHP API. Before trying to run, check that the server "
"instance is :ref:`listening <cfg_basic-listen>` at ``localhost:3301`` and that "
"the space ``examples`` exists, as :ref:`described earlier <index-"
"connector_setting>`. To run, paste the code into a file named :file:`example."
"php` and say ``php -d extension=~/tarantool-php/modules/tarantool.so example."
"php``. The program will open a socket connection with the Tarantool instance at "
"``localhost:3301``, then send an :ref:`INSERT<box_space-insert>` request, then — "
"if all is well — print \"Insert succeeded\". If the tuple already exists, the "
"program will print “Duplicate key exists in unique index 'primary' in space "
"'examples'”."
msgstr ""
"Далее приводится пример полноценной программы на языке PHP, которая осуществляет "
"вставку кортежа ``[99999,'BB']`` в пространство ``examples`` с помощью Tarantool "
"API для языка PHP. Перед запуском данной программы проверьте, что ваше тестовое "
"окружение настроено так, как :ref:`описано выше <index-connector_setting>` (у "
"Tarantool-сервера задан порт для прослушивания и в базе создано пространство "
"``examples``). Чтобы запустить тестовую программу, сохраните ее исходный код в "
"файл с именем :file:`example.php` и выполните команду :samp:`php -d extension=~/"
"tarantool-php/modules/tarantool.so example.php`. Программа откроет сокет для "
"соединения с Tarantool-сервером по адресу ``localhost:3301``, пошлет INSERT-"
"запрос, а затем — если всё хорошо — выдаст сообщение \"Insert succeeded\". Если "
"окажется, что такой кортеж уже существует, то программа выдаст сообщение об "
"ошибке “Duplicate key exists in unique index 'primary' in space 'examples'”."

#: ../doc/1.7/book/connectors/__php.rst:23
msgid ""
"<?php\n"
"$tarantool = new Tarantool('localhost', 3301);\n"
"\n"
"try {\n"
"    $tarantool->insert('examples', array(99999, 'BB'));\n"
"    echo \"Insert succeeded\\n\";\n"
"} catch (Exception $e) {\n"
"    echo \"Exception: \", $e->getMessage(), \"\\n\";\n"
"}"
msgstr ""
"<?php\n"
"$tarantool = new Tarantool('localhost', 3301);\n"
"\n"
"try {\n"
"    $tarantool->insert('examples', array(99999, 'BB'));\n"
"    echo \"Insert succeeded\\n\";\n"
"} catch (Exception $e) {\n"
"    echo \"Exception: \", $e->getMessage(), \"\\n\";\n"
"}"

#: ../doc/1.7/book/connectors/__php.rst:35
#, fuzzy
msgid ""
"The example program only shows one request and does not show all that's "
"necessary for good practice. For that, please see `tarantool/tarantool-php "
"<https://github.com/tarantool/tarantool-php>`_ project at GitHub."
msgstr ""
"В этой программе мы привели пример использования лишь одного запроса. Для "
"полноценной работы с Tarantool'ом с помощью PHP API, пожалуйста, обратитесь к "
"документации из `проекта tarantool-php на GitHub <https://github.com/tarantool/"
"tarantool-php>`_."

#: ../doc/1.7/book/connectors/__php.rst:40
msgid ""
"Besides, you can use an alternative PHP driver from another GitHub project: it "
"includes a *client* (see `tarantool-php/client <https://github.com/tarantool-php/"
"client>`_) and a *mapper* for that client (see `tarantool-php/mapper <https://"
"github.com/tarantool-php/mapper>`_)."
msgstr ""

#: ../doc/1.7/book/connectors/__python.rst:3
msgid "Python"
msgstr "Python"

#: ../doc/1.7/book/connectors/__python.rst:5
msgid ""
"Here is a complete Python program that inserts ``[99999,'Value','Value']`` into "
"space ``examples`` via the high-level Python API."
msgstr ""
"Далее приводится пример полноценной программы на языке Python, которая "
"осуществляет вставку кортежа ``[99999,'Value','Value']`` в пространство "
"``examples`` с помощью высокоуровневого Tarantool API для языка Python. "

#: ../doc/1.7/book/connectors/__python.rst:8
msgid ""
"#!/usr/bin/python\n"
"from tarantool import Connection\n"
"\n"
"c = Connection(\"127.0.0.1\", 3301)\n"
"result = c.insert(\"examples\",(99999,'Value', 'Value'))\n"
"print result"
msgstr ""
"#!/usr/bin/python\n"
"from tarantool import Connection\n"
"\n"
"c = Connection(\"127.0.0.1\", 3301)\n"
"result = c.insert(\"examples\",(99999,'Value', 'Value'))\n"
"print result"

#: ../doc/1.7/book/connectors/__python.rst:17
#, fuzzy
msgid ""
"To prepare, paste the code into a file named :file:`example.py` and install the "
"``tarantool-python`` connector with either :samp:`pip install tarantool\\>0.4` "
"to install in :file:`/usr` (requires **root** privilege) or :samp:`pip install "
"tarantool\\>0.4 --user` to install in :file:`~` i.e. user's default directory. "
"Before trying to run, check that the server instance is :ref:`listening "
"<cfg_basic-listen>` at ``localhost:3301`` and that the space ``examples`` "
"exists, as :ref:`described earlier <index-connector_setting>`. To run the "
"program, say :samp:`python example.py`. The program will connect to the "
"Tarantool server, will send the :ref:`INSERT<box_space-insert>` request, and "
"will not throw any exception if all went well. If the tuple already exists, the "
"program will throw ``tarantool.error.DatabaseError: (3, \"Duplicate key exists "
"in unique index 'primary' in space 'examples'\")``."
msgstr ""
"Перед запуском данной программы проверьте, что ваше тестовое окружение настроено "
"так, как :ref:`описано выше <index-connector_setting>` (у Tarantool-сервера "
"задан порт для прослушивания и в базе создано пространство ``examples``), и "
"установите коннектор ``tarantool-python``. Для установки коннектора "
"воспользуйтесь либо командой :samp:`pip install tarantool\\>0.4` (для установки "
"в директорию :file:`/usr`; вам потребуются права уровня  **root**), либо "
"командой :samp:`pip install tarantool\\>0.4 --user` (для установки в директорию :"
"file:`~`, т.е. в используемую по умолчанию директорию текущего пользователя). "
"Чтобы запустить тестовую программу, сохраните ее исходный код в файл с именем :"
"file:`example.py` и выполните команду :samp:`python example.py`. Программа "
"установит соединение с Tarantool-сервером, пошлет запрос и не сгенерирует "
"никакого исключения, если всё прошло хорошо. Если окажется, что такой кортеж уже "
"существует, то программа сгенерирует исключение :samp:`tarantool.error."
"DatabaseError: (3, \"Duplicate key exists in unique index 'primary' in space "
"'examples'\")`."

#: ../doc/1.7/book/connectors/__python.rst:29
#, fuzzy
msgid ""
"The example program only shows one request and does not show all that's "
"necessary for good practice. For that, please see `tarantool-python <http://"
"github.com/tarantool/tarantool-python>`_ project at GitHub. For an example of "
"using Python API with `queue managers for Tarantool <https://github.com/"
"tarantool/queue>`_, see `queue-python <https://github.com/tarantool/queue-"
"python>`_ project at GitHub."
msgstr ""
"В этой программе мы привели пример использования лишь одного запроса. Для "
"полноценной работы с Tarantool'ом с помощью Python API, пожалуйста, обратитесь к "
"документации из `проекта tarantool-python на GitHub <http://github.com/tarantool/"
"tarantool-python>`_. А на странице `проекта queue-python на GitHub <https://"
"github.com/tarantool/queue-python>`_ вы сможете найти примеры использования "
"Python API для работы с `очередями сообщений в Tarantool'е <https://github.com/"
"tarantool/queue>`_."

#: ../doc/1.7/book/connectors/__nodejs.rst:3
msgid "Node.js"
msgstr ""

#: ../doc/1.7/book/connectors/__nodejs.rst:5
msgid ""
"The most commonly used node.js driver is the `Node Tarantool driver <https://"
"github.com/KlonD90/node-tarantool-driver>`_. It is not supplied as part of the "
"Tarantool repository; it must be installed separately. The most common way to "
"install it is with `npm <https://www.sitepoint.com/beginners-guide-node-package-"
"manager/>`_. For example, on Ubuntu, the installation could look like this after "
"npm has been installed:"
msgstr ""

#: ../doc/1.7/book/connectors/__nodejs.rst:13
msgid "npm install tarantool-driver --global"
msgstr ""

#: ../doc/1.7/book/connectors/__nodejs.rst:17
#, fuzzy
msgid ""
"Here is a complete node.js program that inserts ``[99999,'BB']`` into "
"``space[999]`` via the node.js API. Before trying to run, check that the server "
"instance is :ref:`listening<cfg_basic-listen>` at ``localhost:3301`` and that "
"the space ``examples`` exists, as :ref:`described earlier <index-"
"connector_setting>`. To run, paste the code into a file named :file:`example.rs` "
"and say ``node example.rs``. The program will connect using an application-"
"specific definition of the space. The program will open a socket connection with "
"the Tarantool instance at ``localhost:3301``, then send an :ref:"
"`INSERT<box_space-insert>` request, then — if all is well — end after saying "
"\"Insert succeeded\". If Tarantool is not running on ``localhost`` with listen "
"port = 3301, the program will print “Connect failed”. If :ref:`user 'guest' "
"user<box_space-user>` does not have authorization to connect, the program will "
"print \"Auth failed\". If the insert request fails for any reason, for example "
"because the tuple already exists, the program will print \"Insert failed\"."
msgstr ""
"Далее приводится пример полноценной программы на языке Perl, которая "
"осуществляет вставку кортежа ``[99999,'BB']`` в пространство ``space[999]`` с "
"помощью Tarantool API для языка Perl. Перед запуском данной программы проверьте, "
"что ваше тестовое окружение настроено так, как :ref:`описано выше <index-"
"connector_setting>` (у Tarantool-сервера задан порт для прослушивания и в базе "
"создано пространство ``examples``). Чтобы запустить тестовую программу, "
"сохраните ее исходный код в файл с именем :file:`example.pl` и выполните "
"команду :samp:`perl example.pl`. Программа установит соединение, используя "
"указанное в ней описание пространства, откроет сокет для соединения с Tarantool-"
"сервером по адресу ``localhost:3301``, пошлет INSERT-запрос, а затем — если всё "
"хорошо — закончит работу без каких-либо сообщений. Если окажется, что Tarantool-"
"сервер не запущен на прослушивание по указанному адресу, то программа выдаст "
"сообщение об ошибке “Connection refused”."

#: ../doc/1.7/book/connectors/__nodejs.rst:31
msgid ""
"var TarantoolConnection = require('tarantool-driver');\n"
"var conn = new TarantoolConnection({port: 3301});\n"
"var insertTuple = [99999, \"BB\"];\n"
"conn.connect().then(function() {\n"
"    conn.auth(\"guest\", \"\").then(function() {\n"
"        conn.insert(999, insertTuple).then(function() {\n"
"            console.log(\"Insert succeeded\");\n"
"            process.exit(0);\n"
"    }, function(e) { console.log(\"Insert failed\");  process.exit(1); });\n"
"    }, function(e) { console.log(\"Auth failed\");    process.exit(1); });\n"
"    }, function(e) { console.log(\"Connect failed\"); process.exit(1); });"
msgstr ""

#: ../doc/1.7/book/connectors/__nodejs.rst:45
#, fuzzy
msgid ""
"The example program only shows one request and does not show all that's "
"necessary for good practice. For that, please see  `The node.js driver "
"repository <https://github.com/KlonD90/node-tarantool-driver>`_."
msgstr ""
"В этой программе мы привели пример использования лишь одного запроса. Для "
"полноценной работы с Tarantool'ом с помощью PHP API, пожалуйста, обратитесь к "
"документации из `проекта tarantool-php на GitHub <https://github.com/tarantool/"
"tarantool-php>`_."

#: ../doc/1.7/book/connectors/__csharp.rst:3
msgid "C#"
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:5
msgid ""
"The most commonly used C# driver is `progaudi.tarantool <https://github.com/"
"progaudi/progaudi.tarantool>`_, previously named ``tarantool-csharp``. It is not "
"supplied as part of the Tarantool repository; it must be installed separately. "
"The makers recommend `cross-platform installation using Nuget <https://www.nuget."
"org/packages/progaudi.tarantool>`_."
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:11
msgid ""
"To be consistent with the other instructions in this chapter, here is a way to "
"install the driver directly on Ubuntu 16.04."
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:14
msgid ""
"Install .net core from Microsoft. Follow `.net core installation instructions "
"<https://www.microsoft.com/net/core#ubuntu>`_."
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:19
msgid ""
"Mono will not work, nor will .Net from xbuild. Only .net core supported on Linux "
"and Mac."
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:21
msgid ""
"Read the Microsoft End User License Agreement first, because it is not an "
"ordinary open-source agreement and there will be a message during installation "
"saying \"This software may collect information about you and your use of the "
"software, and send that to Microsoft.\" Still you can `set environment variables "
"<https://docs.microsoft.com/en-us/dotnet/core/tools/telemetry#behavior>`_ to opt "
"out from telemetry."
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:29
msgid "Create a new console project."
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:31
msgid ""
"$ cd ~\n"
"$ mkdir progaudi.tarantool.test\n"
"$ cd progaudi.tarantool.test\n"
"$ dotnet new console"
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:38
msgid "Add ``progaudi.tarantool`` reference."
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:40
msgid "$ dotnet add package progaudi.tarantool"
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:44
msgid "Change code in ``Program.cs``."
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:46
msgid ""
"$ cat <<EOT > Program.cs\n"
"using System;\n"
"using System.Threading.Tasks;\n"
"using ProGaudi.Tarantool.Client;\n"
"\n"
"public class HelloWorld\n"
"{\n"
"  static public void Main ()\n"
"  {\n"
"    Test().GetAwaiter().GetResult();\n"
"  }\n"
"  static async Task Test()\n"
"  {\n"
"    var box = await Box.Connect(\"127.0.0.1:3301\");\n"
"    var schema = box.GetSchema();\n"
"    var space = await schema.GetSpace(\"examples\");\n"
"    await space.Insert((99999, \"BB\"));\n"
"  }\n"
"}\n"
"EOT"
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:69
msgid "Build and run your application."
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:71
msgid ""
"Before trying to run, check that the server is listening at ``localhost:3301`` "
"and that the space ``examples`` exists, as :ref:`described earlier <index-"
"connector_setting>`."
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:75
msgid ""
"$ dotnet restore\n"
"$ dotnet run"
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:80
msgid "The program will:"
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:82
msgid "connect using an application-specific definition of the space,"
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:83
msgid "open a socket connection with the Tarantool server at `localhost:3301`,"
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:84
msgid "send an INSERT request, and — if all is well — end without saying anything."
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:86
msgid ""
"If Tarantool is not running on localhost with listen port = 3301, or if user "
"'guest' does not have authorization to connect, or if the INSERT request fails "
"for any reason, the program will print an error message, among other things "
"(stacktrace, etc)."
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:91
#, fuzzy
msgid ""
"The example program only shows one request and does not show all that’s "
"necessary for good practice. For that, please see the `progaudi.tarantool driver "
"repository <https://github.com/progaudi/progaudi.tarantool>`_."
msgstr ""
"В этой программе мы привели пример использования лишь одного запроса. Для "
"полноценной работы с Tarantool'ом с помощью PHP API, пожалуйста, обратитесь к "
"документации из `проекта tarantool-php на GitHub <https://github.com/tarantool/"
"tarantool-php>`_."

#: ../doc/1.7/book/connectors/__c.rst:3
msgid "C"
msgstr "C"

#: ../doc/1.7/book/connectors/__c.rst:5
msgid "Here follow two examples of using Tarantool's high-level C API."
msgstr ""
"В этом разделе даны два примера использования высокоуровневого API для "
"Tarantool'а и языка C."

#: ../doc/1.7/book/connectors/__c.rst:9
msgid "Example 1"
msgstr "Пример 1"

#: ../doc/1.7/book/connectors/__c.rst:11
msgid ""
"Here is a complete C program that inserts :code:`[99999,'B']` into space :code:"
"`examples` via the high-level C API."
msgstr ""
"Далее приводится пример полноценной программы на языке C, которая осуществляет "
"вставку кортежа ``[99999,'B']`` в пространство ``examples`` с помощью "
"высокоуровневого Tarantool API для языка C. "

#: ../doc/1.7/book/connectors/__c.rst:14
#, python-format
msgid ""
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"\n"
"void main() {\n"
"   struct tnt_stream *tnt = tnt_net(NULL);          /* See note = SETUP */\n"
"   tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"   if (tnt_connect(tnt) < 0) {                      /* See note = CONNECT */\n"
"       printf(\"Connection refused\\n\");\n"
"       exit(-1);\n"
"   }\n"
"   struct tnt_stream *tuple = tnt_object(NULL);     /* See note = MAKE REQUEST "
"*/\n"
"   tnt_object_format(tuple, \"[%d%s]\", 99999, \"B\");\n"
"   tnt_insert(tnt, 999, tuple);                     /* See note = SEND REQUEST "
"*/\n"
"   tnt_flush(tnt);\n"
"   struct tnt_reply reply;  tnt_reply_init(&reply); /* See note = GET REPLY */\n"
"   tnt->read_reply(tnt, &reply);\n"
"   if (reply.code != 0) {\n"
"       printf(\"Insert failed %lu.\\n\", reply.code);\n"
"   }\n"
"   tnt_close(tnt);                                  /* See below = TEARDOWN */\n"
"   tnt_stream_free(tuple);\n"
"   tnt_stream_free(tnt);\n"
"}"
msgstr ""
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"\n"
"void main() {\n"
"   struct tnt_stream *tnt = tnt_net(NULL);          /* См. ниже = НАСТРОЙКА */\n"
"   tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"   if (tnt_connect(tnt) < 0) {                      /* См. ниже = СОЕДИНЕНИЕ */\n"
"       printf(\"Connection refused\\n\");\n"
"       exit(-1);\n"
"   }\n"
"   struct tnt_stream *tuple = tnt_object(NULL);     /* См. ниже = СОЗДАНИЕ "
"ЗАПРОСА */\n"
"   tnt_object_format(tuple, \"[%d%s]\", 99999, \"B\");\n"
"   tnt_insert(tnt, 999, tuple);                     /* См. ниже = ОТПРАВКА "
"ЗАПРОСА */\n"
"   tnt_flush(tnt);\n"
"   struct tnt_reply reply;  tnt_reply_init(&reply); /* См. ниже = ПОЛУЧЕНИЕ "
"ОТВЕТА */\n"
"   tnt->read_reply(tnt, &reply);\n"
"   if (reply.code != 0) {\n"
"       printf(\"Insert failed %lu.\\n\", reply.code);\n"
"   }\n"
"   tnt_close(tnt);                                  /* См. ниже = ЗАВЕРШЕНИЕ */\n"
"   tnt_stream_free(tuple);\n"
"   tnt_stream_free(tnt);\n"
"}"

#: ../doc/1.7/book/connectors/__c.rst:44
msgid ""
"Paste the code into a file named :file:`example.c` and install ``tarantool-c``. "
"One way to install ``tarantool-c`` (using Ubuntu) is:"
msgstr ""
"Скопируйте исходный код программы в файл с именем :file:`example.c` и установите "
"коннектор ``tarantool-c``. Вот один из способов установки ``tarantool-c`` (под "
"Ubuntu):"

#: ../doc/1.7/book/connectors/__c.rst:47
msgid ""
"$ git clone git://github.com/tarantool/tarantool-c.git ~/tarantool-c\n"
"$ cd ~/tarantool-c\n"
"$ git submodule init\n"
"$ git submodule update\n"
"$ cmake .\n"
"$ make\n"
"$ make install"
msgstr ""
"$ git clone git://github.com/tarantool/tarantool-c.git ~/tarantool-c\n"
"$ cd ~/tarantool-c\n"
"$ git submodule init\n"
"$ git submodule update\n"
"$ cmake .\n"
"$ make\n"
"$ make install"

#: ../doc/1.7/book/connectors/__c.rst:57 ../doc/1.7/book/connectors/__c.rst:288
msgid "To compile and link the program, say:"
msgstr ""
"Чтобы скомпилировать и слинковать тестовую программу, выполните следующую "
"команду:"

#: ../doc/1.7/book/connectors/__c.rst:59
msgid ""
"$ # sometimes this is necessary:\n"
"$ export LD_LIBRARY_PATH=/usr/local/lib\n"
"$ gcc -o example example.c -ltarantool"
msgstr ""
"$ # иногда это необходимо:\n"
"$ export LD_LIBRARY_PATH=/usr/local/lib\n"
"$ gcc -o example example.c -ltarantool"

#: ../doc/1.7/book/connectors/__c.rst:65
#, fuzzy
msgid ""
"Before trying to run, check that a server instance is listening at "
"``localhost:3301`` and that the space ``examples`` exists, as :ref:`described "
"earlier <index-connector_setting>`. To run the program, say :samp:`./example`. "
"The program will connect to the Tarantool instance, and will send the request. "
"If Tarantool is not running on localhost with listen address = 3301, the program "
"will print “Connection refused”. If the insert fails, the program will print "
"\"Insert failed\" and an error number (see all error codes in the source file `/"
"src/box/errcode.h <https://github.com/tarantool/tarantool/blob/1.7/src/box/"
"errcode.h>`_)."
msgstr ""
"Перед запуском программы проверьте, что ваше тестовое окружение настроено так, "
"как :ref:`описано выше <index-connector_setting>` (у Tarantool-сервера задан "
"порт для прослушивания и в базе создано пространство ``examples``). Чтобы "
"запустить тестовую программу, выполните команду :samp:`./example`. Программа "
"установит соединение с Tarantool-сервером и пошлет запрос. Если окажется, что "
"Tarantool-сервер не запущен на прослушивание по указанному адресу, то программа "
"выдаст сообщение об ошибке “Connection refused”. А если не пройдет INSERT-"
"запрос, то программа выдаст сообщение \"Insert failed\" и код ошибки (все коды "
"ошибок в Tarantool'е см. в исходном файле `/src/box/errcode.h <https://github."
"com/tarantool/tarantool/blob/1.7/src/box/errcode.h>`_)."

#: ../doc/1.7/book/connectors/__c.rst:77
msgid "Here are notes corresponding to comments in the example program."
msgstr ""
"Далее следуют примечания, на которые мы ссылались в комментариях к исходному "
"коду тестовой программы."

#: ../doc/1.7/book/connectors/__c.rst:79
msgid "**SETUP:** The setup begins by creating a stream."
msgstr "**НАСТРОЙКА:** Настройка начинается с создания потока (``tnt_stream``)."

#: ../doc/1.7/book/connectors/__c.rst:81
msgid ""
"struct tnt_stream *tnt = tnt_net(NULL);\n"
"tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");"
msgstr ""
"struct tnt_stream *tnt = tnt_net(NULL);\n"
"tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");"

#: ../doc/1.7/book/connectors/__c.rst:86
#, fuzzy
msgid ""
"In this program, the stream will be named ``tnt``. Before connecting on the "
"``tnt`` stream, some options may have to be set. The most important option is "
"TNT_OPT_URI. In this program, the :ref:`URI <index-uri>` is ``localhost:3301``, "
"since that is where the Tarantool instance is supposed to be :ref:`listening "
"<cfg_basic-listen>`."
msgstr ""
"В нашей тестовой программе поток назван ``tnt``. Перед установкой соединения "
"нужно задать ряд настроечных опций. Самая важная из них — TNT_OPT_URI. Для этой "
"опции указана URI-строка ``localhost:3301``, т.е. адрес, по которому должно быть "
"настроено прослушивание на стороне Tarantool-сервера."

#: ../doc/1.7/book/connectors/__c.rst:92 ../doc/1.7/book/connectors/__c.rst:108
#: ../doc/1.7/book/connectors/__c.rst:136 ../doc/1.7/book/connectors/__c.rst:156
#: ../doc/1.7/book/connectors/__c.rst:181 ../doc/1.7/book/connectors/__c.rst:200
msgid "Function description:"
msgstr "Описание функции:"

#: ../doc/1.7/book/connectors/__c.rst:587
msgid ""
"`struct tnt_stream *tnt_net(struct tnt_stream *s)`\n"
"`int tnt_set(struct tnt_stream *s, int option, variant option-value)`"
msgstr ""
"`struct tnt_stream *tnt_net(struct tnt_stream *s)`\n"
"`int tnt_set(struct tnt_stream *s, int option, variant option-value)`"

#: ../doc/1.7/book/connectors/__c.rst:100
#, fuzzy
msgid ""
"**CONNECT:** Now that the stream named ``tnt`` exists and is associated with a "
"URI, this example program can connect to a server instance."
msgstr ""
"**СОЕДИНЕНИЕ:** Теперь когда мы создали поток с именем ``tnt`` и связали его с "
"конкретным URI, наша программа может устанавливать соединение с Tarantool-"
"сервером."

#: ../doc/1.7/book/connectors/__c.rst:103
msgid ""
"if (tnt_connect(tnt) < 0)\n"
"   { printf(\"Connection refused\\n\"); exit(-1); }"
msgstr ""
"if (tnt_connect(tnt) < 0)\n"
"   { printf(\"Connection refused\\n\"); exit(-1); }"

#: ../doc/1.7/book/connectors/__c.rst:603
msgid "int tnt_connect(struct tnt_stream \\*s)"
msgstr "int tnt_connect(struct tnt_stream \\*s)"

#: ../doc/1.7/book/connectors/__c.rst:115
#, fuzzy
msgid ""
"The connection might fail for a variety of reasons, such as: the server is not "
"running, or the URI contains an invalid :ref:`password<authentication-"
"passwords>`. If the connection fails, the return value will be -1."
msgstr ""
"Попытка соединения может и не удаться, например если Tarantool-сервер не запущен "
"или в URI-строке указан неверный пароль. В случае неудачи функция "
"``tnt_connect()`` вернет -1."

#: ../doc/1.7/book/connectors/__c.rst:119
msgid ""
"**MAKE REQUEST:** Most requests require passing a structured value, such as the "
"contents of a tuple."
msgstr ""
"**СОЗДАНИЕ ЗАПРОСА:** В большинстве запросов требуется передавать "
"структурированные данные, например содержимое кортежа."

#: ../doc/1.7/book/connectors/__c.rst:122
#, python-format
msgid ""
"struct tnt_stream *tuple = tnt_object(NULL);\n"
"tnt_object_format(tuple, \"[%d%s]\", 99999, \"B\");"
msgstr ""
"struct tnt_stream *tuple = tnt_object(NULL);\n"
"tnt_object_format(tuple, \"[%d%s]\", 99999, \"B\");"

#: ../doc/1.7/book/connectors/__c.rst:127
#, fuzzy, python-format
msgid ""
"In this program, the request will be an :ref:`INSERT<box_space-insert>`, and the "
"tuple contents will be an integer and a string. This is a simple serial set of "
"values, that is, there are no sub-structures or arrays. Therefore it is easy in "
"this case to format what will be passed using the same sort of arguments that "
"one would use with a C ``printf()`` function: ``%d`` for the integer, ``%s`` for "
"the string, then the integer value, then a pointer to the string value."
msgstr ""
"В данной программе мы используем запрос INSERT, а кортеж содержит целое число и "
"строку.  Это простой набор значений без каких-либо вложенных структур или "
"массивов. И передаваемые значения мы можем указать самым простым образом — "
"аналогично тому, как это сделано в стандартной C-функции ``printf()``: ``%d`` "
"для обозначения целого числа, ``%s`` для обозначения строки, затем числовое "
"значение, затем указатель на строковое значение."

#: ../doc/1.7/book/connectors/__c.rst:631
msgid "ssize_t tnt_object_format(struct tnt_stream \\*s, const char \\*fmt, ...)"
msgstr "ssize_t tnt_object_format(struct tnt_stream \\*s, const char \\*fmt, ...)"

#: ../doc/1.7/book/connectors/__c.rst:143
msgid ""
"**SEND REQUEST:** The database-manipulation requests are analogous to the "
"requests in the box library."
msgstr ""
"**ОТПРАВКА ЗАПРОСА:** Отправка запросов на изменение данных в базе делается "
"аналогично тому, как это делается в Tarantool-библиотеке ``box``."

#: ../doc/1.7/book/connectors/__c.rst:146
msgid ""
"tnt_insert(tnt, 999, tuple);\n"
"tnt_flush(tnt);"
msgstr ""
"tnt_insert(tnt, 999, tuple);\n"
"tnt_flush(tnt);"

#: ../doc/1.7/book/connectors/__c.rst:151
msgid ""
"In this program, the choice is to do an INSERT request, so the program passes "
"the ``tnt_stream`` that was used for connection (``tnt``) and the ``tnt_stream`` "
"that was set up with :c:func:`tarantoolc:tnt_object_format` (``tuple``)."
msgstr ""
"В данной программе мы делаем INSERT-запрос. В этом запросе мы передаем поток "
"``tnt``, который ранее использовали для установки соединения, и поток :code:"
"`tuple`, который также ранее настроили с помощью функции :c:func:`tarantoolc:"
"tnt_object_format`."

#: ../doc/1.7/book/connectors/__c.rst:651
msgid ""
"ssize_t tnt_insert(struct tnt_stream \\*s, uint32_t space, struct tnt_stream "
"\\*tuple)\n"
"ssize_t tnt_replace(struct tnt_stream \\*s, uint32_t space, struct tnt_stream "
"\\*tuple)\n"
"ssize_t tnt_select(struct tnt_stream \\*s, uint32_t space, uint32_t index,\n"
"                   uint32_t limit, uint32_t offset, uint8_t iterator,\n"
"                   struct tnt_stream \\*key)\n"
"ssize_t tnt_update(struct tnt_stream \\*s, uint32_t space, uint32_t index,\n"
"                   struct tnt_stream \\*key, struct tnt_stream \\*ops)"
msgstr ""
"ssize_t tnt_insert(struct tnt_stream \\*s, uint32_t space, struct tnt_stream "
"\\*tuple)\n"
"ssize_t tnt_replace(struct tnt_stream \\*s, uint32_t space, struct tnt_stream "
"\\*tuple)\n"
"ssize_t tnt_select(struct tnt_stream \\*s, uint32_t space, uint32_t index,\n"
"                   uint32_t limit, uint32_t offset, uint8_t iterator,\n"
"                   struct tnt_stream \\*key)\n"
"ssize_t tnt_update(struct tnt_stream \\*s, uint32_t space, uint32_t index,\n"
"                   struct tnt_stream \\*key, struct tnt_stream \\*ops)"

#: ../doc/1.7/book/connectors/__c.rst:169
msgid ""
"**GET REPLY:** For most requests, the client will receive a reply containing "
"some indication whether the result was successful, and a set of tuples."
msgstr ""
"**ПОЛУЧЕНИЕ ОТВЕТА:** На большинство запросов клиент получает ответ, который "
"содержит информацию о том, был ли данный запрос успешно выполнен, а также "
"содержит набор кортежей."

#: ../doc/1.7/book/connectors/__c.rst:172
#, python-format
msgid ""
"struct tnt_reply reply;  tnt_reply_init(&reply);\n"
"tnt->read_reply(tnt, &reply);\n"
"if (reply.code != 0)\n"
"   { printf(\"Insert failed %lu.\\n\", reply.code); }"
msgstr ""
"struct tnt_reply reply;  tnt_reply_init(&reply);\n"
"tnt->read_reply(tnt, &reply);\n"
"if (reply.code != 0)\n"
"   { printf(\"Insert failed %lu.\\n\", reply.code); }"

#: ../doc/1.7/book/connectors/__c.rst:179
msgid "This program checks for success but does not decode the rest of the reply."
msgstr ""
"Данная программа проверяет, был ли запрос выполнен успешно, но никак не "
"интерпретирует оставшуюся часть ответа."

#: ../doc/1.7/book/connectors/__c.rst:676
msgid ""
"struct tnt_reply \\*tnt_reply_init(struct tnt_reply \\*r)\n"
"tnt->read_reply(struct tnt_stream \\*s, struct tnt_reply \\*r)\n"
"void tnt_reply_free(struct tnt_reply \\*r)"
msgstr ""
"struct tnt_reply \\*tnt_reply_init(struct tnt_reply \\*r)\n"
"tnt->read_reply(struct tnt_stream \\*s, struct tnt_reply \\*r)\n"
"void tnt_reply_free(struct tnt_reply \\*r)"

#: ../doc/1.7/book/connectors/__c.rst:190
msgid ""
"**TEARDOWN:** When a session ends, the connection that was made with :c:func:"
"`tarantoolc:tnt_connect()` should be closed, and the objects that were made in "
"the setup should be destroyed."
msgstr ""
"**ЗАВЕРШЕНИЕ:** По окончании сессии нам нужно закрыть соединение, созданное с "
"помощью функции :c:func:`tarantoolc:tnt_connect()`, и удалить объекты, созданные "
"на этапе настройки."

#: ../doc/1.7/book/connectors/__c.rst:194
msgid ""
"tnt_close(tnt);\n"
"tnt_stream_free(tuple);\n"
"tnt_stream_free(tnt);"
msgstr ""
"tnt_close(tnt);\n"
"tnt_stream_free(tuple);\n"
"tnt_stream_free(tnt);"

#: ../doc/1.7/book/connectors/__c.rst:695
msgid ""
"void tnt_close(struct tnt_stream \\*s)\n"
"void tnt_stream_free(struct tnt_stream \\*s)"
msgstr ""
"void tnt_close(struct tnt_stream \\*s)\n"
"void tnt_stream_free(struct tnt_stream \\*s)"

#: ../doc/1.7/book/connectors/__c.rst:210
msgid "Example 2"
msgstr "Пример 2"

#: ../doc/1.7/book/connectors/__c.rst:212
msgid ""
"Here is a complete C program that selects, using index key ``[99999]``, from "
"space ``examples`` via the high-level C API. To display the results, the program "
"uses functions in the `MsgPuck <http://rtsisyk.github.io/msgpuck/>`_ library "
"which allow decoding of `MessagePack <https://en.wikipedia.org/wiki/"
"MessagePack>`_  arrays."
msgstr ""
"Далее приводится еще один пример полноценной программы на языке C, которая "
"осуществляет выборку по индекс-ключу ``[99999]`` из пространства ``examples`` с "
"помощью высокоуровневого Tarantool API для языка C. Для вывода результатов в "
"этой программе используются функции из библиотеки `MsgPuck <http://rtsisyk."
"github.io/msgpuck/>`_. Эти функции нужны для декодирования массивов значений в "
"формате `MessagePack <https://en.wikipedia.org/wiki/MessagePack>`_."

#: ../doc/1.7/book/connectors/__c.rst:218
#, python-format
msgid ""
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"\n"
"#define MP_SOURCE 1\n"
"#include <msgpuck.h>\n"
"\n"
"void main() {\n"
"    struct tnt_stream *tnt = tnt_net(NULL);\n"
"    tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"    if (tnt_connect(tnt) < 0) {\n"
"        printf(\"Connection refused\\n\");\n"
"        exit(1);\n"
"    }\n"
"    struct tnt_stream *tuple = tnt_object(NULL);\n"
"    tnt_object_format(tuple, \"[%d]\", 99999); /* tuple = search key */\n"
"    tnt_select(tnt, 999, 0, (2^32) - 1, 0, 0, tuple);\n"
"    tnt_flush(tnt);\n"
"    struct tnt_reply reply; tnt_reply_init(&reply);\n"
"    tnt->read_reply(tnt, &reply);\n"
"    if (reply.code != 0) {\n"
"        printf(\"Select failed.\\n\");\n"
"        exit(1);\n"
"    }\n"
"    char field_type;\n"
"    field_type = mp_typeof(*reply.data);\n"
"    if (field_type != MP_ARRAY) {\n"
"        printf(\"no tuple array\\n\");\n"
"        exit(1);\n"
"    }\n"
"    long unsigned int row_count;\n"
"    uint32_t tuple_count = mp_decode_array(&reply.data);\n"
"    printf(\"tuple count=%u\\n\", tuple_count);\n"
"    unsigned int i, j;\n"
"    for (i = 0; i < tuple_count; ++i) {\n"
"        field_type = mp_typeof(*reply.data);\n"
"        if (field_type != MP_ARRAY) {\n"
"            printf(\"no field array\\n\");\n"
"            exit(1);\n"
"        }\n"
"        uint32_t field_count = mp_decode_array(&reply.data);\n"
"        printf(\"  field count=%u\\n\", field_count);\n"
"        for (j = 0; j < field_count; ++j) {\n"
"            field_type = mp_typeof(*reply.data);\n"
"            if (field_type == MP_UINT) {\n"
"                uint64_t num_value = mp_decode_uint(&reply.data);\n"
"                printf(\"    value=%lu.\\n\", num_value);\n"
"            } else if (field_type == MP_STR) {\n"
"                const char *str_value;\n"
"                uint32_t str_value_length;\n"
"                str_value = mp_decode_str(&reply.data, &str_value_length);\n"
"                printf(\"    value=%.*s.\\n\", str_value_length, str_value);\n"
"            } else {\n"
"                printf(\"wrong field type\\n\");\n"
"                exit(1);\n"
"            }\n"
"        }\n"
"    }\n"
"    tnt_close(tnt);\n"
"    tnt_stream_free(tuple);\n"
"    tnt_stream_free(tnt);\n"
"}"
msgstr ""
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"\n"
"#define MP_SOURCE 1\n"
"#include <msgpuck.h>\n"
"\n"
"void main() {\n"
"    struct tnt_stream *tnt = tnt_net(NULL);\n"
"    tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"    if (tnt_connect(tnt) < 0) {\n"
"        printf(\"Connection refused\\n\");\n"
"        exit(1);\n"
"    }\n"
"    struct tnt_stream *tuple = tnt_object(NULL);\n"
"    tnt_object_format(tuple, \"[%d]\", 99999); /* кортеж tuple = ключ для поиска "
"*/\n"
"    tnt_select(tnt, 999, 0, (2^32) - 1, 0, 0, tuple);\n"
"    tnt_flush(tnt);\n"
"    struct tnt_reply reply; tnt_reply_init(&reply);\n"
"    tnt->read_reply(tnt, &reply);\n"
"    if (reply.code != 0) {\n"
"        printf(\"Select failed.\\n\");\n"
"        exit(1);\n"
"    }\n"
"    char field_type;\n"
"    field_type = mp_typeof(*reply.data);\n"
"    if (field_type != MP_ARRAY) {\n"
"        printf(\"no tuple array\\n\");\n"
"        exit(1);\n"
"    }\n"
"    long unsigned int row_count;\n"
"    uint32_t tuple_count = mp_decode_array(&reply.data);\n"
"    printf(\"tuple count=%u\\n\", tuple_count);\n"
"    unsigned int i, j;\n"
"    for (i = 0; i < tuple_count; ++i) {\n"
"        field_type = mp_typeof(*reply.data);\n"
"        if (field_type != MP_ARRAY) {\n"
"            printf(\"no field array\\n\");\n"
"            exit(1);\n"
"        }\n"
"        uint32_t field_count = mp_decode_array(&reply.data);\n"
"        printf(\"  field count=%u\\n\", field_count);\n"
"        for (j = 0; j < field_count; ++j) {\n"
"            field_type = mp_typeof(*reply.data);\n"
"            if (field_type == MP_UINT) {\n"
"                uint64_t num_value = mp_decode_uint(&reply.data);\n"
"                printf(\"    value=%lu.\\n\", num_value);\n"
"            } else if (field_type == MP_STR) {\n"
"                const char *str_value;\n"
"                uint32_t str_value_length;\n"
"                str_value = mp_decode_str(&reply.data, &str_value_length);\n"
"                printf(\"    value=%.*s.\\n\", str_value_length, str_value);\n"
"            } else {\n"
"                printf(\"wrong field type\\n\");\n"
"                exit(1);\n"
"            }\n"
"        }\n"
"    }\n"
"    tnt_close(tnt);\n"
"    tnt_stream_free(tuple);\n"
"    tnt_stream_free(tnt);\n"
"}"

#: ../doc/1.7/book/connectors/__c.rst:285
msgid ""
"Similarly to the first example, paste the code into a file named :file:`example2."
"c`."
msgstr ""
"Аналогично первому примеру, сохраните исходный код программы в файле с именем :"
"file:`example2.c`."

#: ../doc/1.7/book/connectors/__c.rst:290
msgid "$ gcc -o example2 example2.c -ltarantool"
msgstr "$ gcc -o example2 example2.c -ltarantool"

#: ../doc/1.7/book/connectors/__c.rst:294
msgid "To run the program, say :samp:`./example2`."
msgstr "Для запуска программы выполните команду :samp:`./example2`."

#: ../doc/1.7/book/connectors/__c.rst:296
msgid ""
"The two example programs only show a few requests and do not show all that's "
"necessary for good practice. See more in the `tarantool-c documentation at "
"GitHub <http://github.com/tarantool/tarantool-c>`_."
msgstr ""
"В этих двух программах мы привели пример использования лишь двух запросов. Для "
"полноценной работы с Tarantool'ом с помощью C API, пожалуйста, обратитесь к "
"документации из `проекта tarantool-c на GitHub <http://github.com/tarantool/"
"tarantool-c>`_."

#: ../doc/1.7/book/connectors/__results.rst:4
msgid "Interpreting function return values"
msgstr "Интерпретация возвращаемых значений"

#: ../doc/1.7/book/connectors/__results.rst:6
msgid ""
"For all connectors, calling a function via Tarantool causes a return in the "
"MsgPack format. If the function is called using the connector's API, some "
"conversions may occur. All scalar values are returned as tuples (with a MsgPack "
"type-identifier followed by a value); all non-scalar values are returned as a "
"group of tuples (with a MsgPack array-identifier followed by the scalar values). "
"If the function is called via the binary protocol command layer -- \"eval\" -- "
"rather than via the connector's API, no conversions occur."
msgstr ""
"При работе с любым Tarantool-коннектором функции, вызванные с помощью "
"Tarantool'а, возвращают значения в формате MsgPack. Если функция была вызвана "
"через API коннектора, то формат возвращаемых значений будет следующим: скалярные "
"значения возвращаются в виде кортежей (сначала идет идентификатор типа из "
"формата MsgPack, а затем идет значение); все прочие (не скалярные) значения "
"возвращаются в виде групп кортежей (сначала идет идентификатор массива в формате "
"MsgPack, а затем идут скалярные значения). Но если функция была вызвана в рамках "
"бинарного протокола (с помощью команды ``eval``), а не через API коннектора, то "
"подобных изменений формата возвращаемых значений не происходит."

#: ../doc/1.7/book/connectors/__results.rst:14
#, fuzzy
msgid ""
"In the following example, a Lua function will be created. Since it will be "
"accessed externally by a :ref:`'guest' user<box_space-user>`, a :ref:`grant "
"<box_schema-user_grant>` of an execute privilege will be necessary. The function "
"returns an empty array, a scalar string, two booleans, and a short integer. The "
"values are the ones described in the table :ref:`Common Types and MsgPack "
"Encodings <msgpack-common_types_and_msgpack_encodings>`."
msgstr ""
"Далее приводится пример создания Lua-функции. Поскольку эту функцию будет "
"вызывать внешний пользователь 'guest', то нужно настроить привилегии на "
"исполнение с помощью ``grant``. Эта функция возвращает пустой массив, строку-"
"скаляр, два логических значения и короткое целое число. Значение будут теми же, "
"что описаны в разделе про MsgPack в таблице :ref:`Стандартные типы в MsgPack-"
"кодировке <msgpack-common_types_and_msgpack_encodings>`."

#: ../doc/1.7/book/connectors/__results.rst:21
msgid ""
"tarantool> box.cfg{listen=3301}\n"
"2016-03-03 18:45:52.802 [27381] main/101/interactive I> ready to accept "
"requests\n"
"---\n"
"...\n"
"tarantool> function f() return {},'a',false,true,127; end\n"
"---\n"
"...\n"
"tarantool> box.schema.func.create('f')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('guest','execute','function','f')\n"
"---\n"
"..."
msgstr ""
"tarantool> box.cfg{listen=3301}\n"
"2016-03-03 18:45:52.802 [27381] main/101/interactive I> ready to accept "
"requests\n"
"---\n"
"...\n"
"tarantool> function f() return {},'a',false,true,127; end\n"
"---\n"
"...\n"
"tarantool> box.schema.func.create('f')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('guest','execute','function','f')\n"
"---\n"
"..."

#: ../doc/1.7/book/connectors/__results.rst:37
msgid ""
"Here is a C program which calls the function. Although C is being used for the "
"example, the result would be precisely the same if the calling program was "
"written in Perl, PHP, Python, Go, or Java."
msgstr ""
"Далее идет пример программы на C, из который мы вызываем эту Lua-функцию. Хотя в "
"примере использован код на C, результат будет одинаковым, на каком бы языке ни "
"была написана вызываемая программа: Perl, PHP, Python, Go или Java."

#: ../doc/1.7/book/connectors/__results.rst:41
#, fuzzy, python-format
msgid ""
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"void main() {\n"
"  struct tnt_stream *tnt = tnt_net(NULL);              /* SETUP */\n"
"  tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"   if (tnt_connect(tnt) < 0) {                         /* CONNECT */\n"
"       printf(\"Connection refused\\n\");\n"
"       exit(-1);\n"
"   }\n"
"   struct tnt_stream *arg; arg = tnt_object(NULL);     /* MAKE REQUEST */\n"
"   tnt_object_add_array(arg, 0);\n"
"   struct tnt_request *req1 = tnt_request_call(NULL);  /* CALL function f() */\n"
"   tnt_request_set_funcz(req1, \"f\");\n"
"   uint64_t sync1 = tnt_request_compile(tnt, req1);\n"
"   tnt_flush(tnt);                                     /* SEND REQUEST */\n"
"   struct tnt_reply reply;  tnt_reply_init(&reply);    /* GET REPLY */\n"
"   tnt->read_reply(tnt, &reply);\n"
"   if (reply.code != 0) {\n"
"     printf(\"Call failed %lu.\\n\", reply.code);\n"
"     exit(-1);\n"
"   }\n"
"   const unsigned char *p= (unsigned char*)reply.data; /* PRINT REPLY */\n"
"   while (p < (unsigned char *) reply.data_end)\n"
"   {\n"
"     printf(\"%x \", *p);\n"
"     ++p;\n"
"   }\n"
"   printf(\"\\n\");\n"
"   tnt_close(tnt);                                     /* TEARDOWN */\n"
"   tnt_stream_free(arg);\n"
"   tnt_stream_free(tnt);\n"
"}"
msgstr ""
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"void main() {\n"
"  struct tnt_stream *tnt = tnt_net(NULL);            /* НАСТРОЙКА */\n"
"  tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"   if (tnt_connect(tnt) < 0) {                        /* СОЕДИНЕНИЕ */\n"
"       printf(\"Connection refused\\n\");\n"
"       exit(-1);\n"
"   }\n"
"   struct tnt_stream *tuple = tnt_object(NULL);       /* СОЗДАНИЕ ЗАПРОСА */\n"
"   struct tnt_stream *arg; arg = tnt_object(NULL);\n"
"   tnt_object_add_array(arg, 0);\n"
"   struct tnt_request *req1 = tnt_request_call(NULL); /* ВЫЗОВ function f() */\n"
"   tnt_request_set_funcz(req1, \"f\");\n"
"   tnt_request_set_tuple(req1, arg);\n"
"   uint64_t sync1 = tnt_request_compile(tnt, req1);\n"
"   tnt_flush(tnt);                                    /* ОТПРАВКА ЗАПРОСА */\n"
"   struct tnt_reply reply;  tnt_reply_init(&reply);   /* ПОЛУЧЕНИЕ ОТВЕТА */\n"
"   tnt->read_reply(tnt, &reply);\n"
"   if (reply.code != 0) {\n"
"     printf(\"Call failed %lu.\\n\", reply.code);\n"
"     exit(-1);\n"
"   }\n"
"   const unsigned char *p= (unsigned char*)reply.data;/* ВЫВОД ОТВЕТА */\n"
"   while (p < (unsigned char *) reply.data_end)\n"
"   {\n"
"     printf(\"%x \", *p);\n"
"     ++p;\n"
"   }\n"
"   printf(\"\\n\");\n"
"   tnt_close(tnt);                                    /* ЗАВЕРШЕНИЕ */\n"
"   tnt_stream_free(tuple);\n"
"   tnt_stream_free(tnt);\n"
"}"

#: ../doc/1.7/book/connectors/__results.rst:79
msgid "When this program is executed, it will print:"
msgstr "По завершении программа выведет на экран следующие значения:"

#: ../doc/1.7/book/connectors/__results.rst:81
msgid "dd 0 0 0 5 90 91 a1 61 91 c2 91 c3 91 7f"
msgstr "dd 0 0 0 5 90 91 a1 61 91 c2 91 c3 91 7f"

#: ../doc/1.7/book/connectors/__results.rst:85
msgid ""
"The first five bytes -- ``dd 0 0 0 5`` -- are the MsgPack encoding for \"32-bit "
"array header with value 5\" (see `MsgPack specification <http://github.com/"
"msgpack/msgpack/blob/master/spec.md>`_). The rest are as described in the table :"
"ref:`Common Types and MsgPack Encodings <msgpack-"
"common_types_and_msgpack_encodings>`."
msgstr ""
"Первые пять байт — ``dd 0 0 0 5`` — это фрагмент данных в формате MsgPack, "
"означающий \"32-битный заголовок массива со значением 5\" (см. `спецификацию на "
"формат MsgPack <http://github.com/msgpack/msgpack/blob/master/spec.md>`_). "
"Остальные значения описаны в таблице :ref:`Стандартные типы в MsgPack-кодировке "
"<msgpack-common_types_and_msgpack_encodings>`."

#: ../doc/1.7/book/faq.rst:39
msgid "FAQ"
msgstr "Вопросы и ответы"

#: ../doc/1.7/book/faq.rst
msgid "Q"
msgstr ""

#: ../doc/1.7/book/faq.rst:43
msgid "Why Tarantool?"
msgstr "Чем особен Tarantool?"

#: ../doc/1.7/book/faq.rst
msgid "A"
msgstr "A"

#: ../doc/1.7/book/faq.rst:44
msgid ""
"Tarantool is the latest generation of a family of in-memory data servers "
"developed for web applications. It is the result of practical experience and "
"trials within Mail.Ru since development began in 2008."
msgstr ""

#: ../doc/1.7/book/faq.rst:48
msgid "Why Lua?"
msgstr ""

#: ../doc/1.7/book/faq.rst:49
#, fuzzy
msgid ""
"Lua is a lightweight, fast, extensible multi-paradigm language. Lua also happens "
"to be very easy to embed. Lua coroutines relate very closely to Tarantool "
"fibers, and Lua architecture works well with Tarantool internals. Lua acts well "
"as a stored program language for Tarantool, although connecting with other "
"languages is also easy."
msgstr ""
"Почему Lua? |br| Lua — это легкий, быстрый и расширяемый язык, позволяющий "
"использовать различные парадигмы программирования. Lua также легко встраивается "
"в различные приложения. Ко-рутины (coroutines) в Lua близко соотносятся с "
"файберами (fibers) в Tarantool'е, а вся Lua-архитектура гладко ложится на его "
"внутреннюю реализацию. Lua — это первый язык, на котором можно писать хранимые "
"процедуры для Tarantool'а. В будущем список поддерживаемых языков планируется "
"расширить."

#: ../doc/1.7/book/faq.rst:55
msgid "What's the key advantage of Tarantool?"
msgstr ""

#: ../doc/1.7/book/faq.rst
msgid ""
"Tarantool provides a rich database feature set (HASH, TREE, RTREE, BITSET "
"indexes, secondary indexes, composite indexes, transactions, triggers, "
"asynchronous replication) in a flexible environment of a Lua interpreter."
msgstr ""

#: ../doc/1.7/book/faq.rst
msgid ""
"These two properties make it possible to be a fast, atomic and reliable in-"
"memory data server which handles non-trivial application-specific logic. The "
"advantage over traditional SQL servers is in performance: low-overhead, lock-"
"free architecture means Tarantool can serve an order of magnitude more requests "
"per second, on comparable hardware. The advantage over NoSQL alternatives is in "
"flexibility: Lua allows flexible processing of data stored in a compact, "
"denormalized format."
msgstr ""

#: ../doc/1.7/book/faq.rst:69
msgid "Who is developing Tarantool?"
msgstr ""

#: ../doc/1.7/book/faq.rst:70
#, fuzzy
msgid ""
"There is an engineering team employed by Mail.Ru -- check out our commit logs on "
"`github.com/tarantool <http://github.com/tarantool/>`_. The development is fully "
"open. Most of the connectors' authors, and the maintainers for different "
"distributions, come from the wider community."
msgstr ""
"Кто разрабатывает Tarantool? |br| Во-первых, этим занимается команда разработки "
"в Mail.Ru — см. историю коммитов на `github.com/tarantool <http://github.com/"
"tarantool/>`_. Вся разработка ведется открытым образом. Кроме того, активную "
"роль играют члены сообщества разработчиков Tarantool'а. Их силами было создано "
"большинство коннекторов и ведутся доработки под разные дистрибутивы."

#: ../doc/1.7/book/faq.rst:75
msgid "Are there problems associated with being an in-memory server?"
msgstr ""

#: ../doc/1.7/book/faq.rst:76
#, fuzzy
msgid ""
"The principal storage engine (memtx) is designed for RAM plus persistent "
"storage. It is immune to data loss because there is a write-ahead log. Its "
"memory-allocation and compression techniques ensure there is no waste. And if "
"Tarantool runs out of memory, then it will stop accepting updates until more "
"memory is available, but will continue to handle read and delete requests "
"without difficulty. However, for databases which are much larger than the "
"available RAM space, Tarantool has a second storage engine (vinyl) which is only "
"limited by the available disk space."
msgstr ""
"Возникают ли проблемы из-за того, что Tarantool является in-memory решением? |"
"br| Основной движок баз данных в Tarantool'е работает с оперативной памятью, но "
"при этом он гарантирует сохранность данных благодаря механизму WAL (write ahead "
"log), т.е. журналу упреждающей записи. Также в Tarantool'е используются "
"технологии сжатия и распределения данных, которые позволяют использовать все "
"виды памяти наиболее эффективно. Если Tarantool сталкивается с нехваткой "
"оперативной памяти, то он приостанавливает прием запросов на изменение данных до "
"тех пор, пока не появится свободная память, но при этом с успехом продолжает "
"обработку запросов на чтение и удаление данных. А для больших баз, где объем "
"данных значительно превосходит имеющийся объем оперативной памяти, у Tarantool'а "
"есть второй движок, чьи возможности ограничены лишь размером жесткого диска."

#: ../doc/1.7/book/faq.rst:85
msgid "Can I store (large) BLOBs in Tarantool?"
msgstr ""

#: ../doc/1.7/book/faq.rst:86
msgid ""
"Starting with Tarantool 1.7, there is no \"hard\" limit for the maximal tuple "
"size. Tarantool, however, is designed for high-velocity workload with a lot of "
"small chunks. For example, when you change an existing tuple, Tarantool creates "
"a new version of the tuple in memory. Thus, an optimal tuple size is within "
"kilobytes."
msgstr ""

#: ../doc/1.7/book/faq.rst:93
msgid "I delete data from vinyl, but disk usage stays the same. What gives?"
msgstr ""

#: ../doc/1.7/book/faq.rst:94
msgid ""
"Data you write to vinyl is persisted in append-only run files. These files are "
"immutable, and to perform a delete, a deletion marker (tombstone) is written to "
"a newer run file instead. On compaction, new and old run files are merged, and a "
"new run file is produced. Independently, the checkpoint manager keeps track of "
"all run files involved in a checkpoint, and deletes obsolete files once they are "
"no longer needed."
msgstr ""

#: ../doc/1.7/book/getting_started/index.rst:39
msgid "Getting started"
msgstr "Начало работы"

#: ../doc/1.7/book/getting_started/index.rst:41
msgid ""
"In this chapter, we explain how to install Tarantool, how to start it, and how "
"to create a simple database."
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:39
#, fuzzy
msgid "Using a binary package"
msgstr "Скачивание и установка бинарного пакета"

#: ../doc/1.7/book/getting_started/using_binary.rst:41
msgid ""
"For production purposes, we recommend `official binary packages <http://"
"tarantool.org/download.html>`_. You can choose from two Tarantool versions: 1.7 "
"(stable) or 1.8 (alpha). An automatic build system creates, tests and publishes "
"packages for every push into a corresponding branch (``1.7`` or ``1.8``) at "
"`Tarantool's GitHub repository <https://github.com/tarantool/tarantool>`_."
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:48
#, fuzzy
msgid ""
"To download and install the package that’s appropriate for your OS, start a "
"shell (terminal) and enter the command-line instructions provided for your OS at "
"Tarantool's `download page <http://tarantool.org/download.html>`_."
msgstr ""
"Чтобы скачать и установить бинарный пакет для вашей операционной системы, "
"откройте терминал с командной строкой и введите инструкции, которые даны для "
"вашей операционной системы на странице http://tarantool.org/download.html."

#: ../doc/1.7/book/getting_started/using_binary.rst:54
#, fuzzy
msgid "Starting Tarantool"
msgstr "Утилита tarantoolctl"

#: ../doc/1.7/book/getting_started/using_binary.rst:56
msgid "To start a Tarantool instance, say this:"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:58
#, fuzzy
msgid ""
"$ # if you downloaded a binary with apt-get or yum, say this:\n"
"$ /usr/bin/tarantool\n"
"$ # if you downloaded and untarred a binary tarball to ~/tarantool, say this:\n"
"$ ~/tarantool/bin/tarantool"
msgstr ""
"$ # Если вы скачали бинарный пакет с помощью apt-get или yum, введите:\n"
"$ /usr/bin/tarantool\n"
"$ # Если вы скачали бинарный пакет в формате TAR\n"
"$ # и разархивировали его в директорию ~/tarantool, введите:\n"
"$ ~/tarantool/bin/tarantool\n"
"$ # Если вы собрали Tarantool из исходных файлов, введите:\n"
"$ ~/tarantool/src/tarantool"

#: ../doc/1.7/book/getting_started/using_binary.rst:65
msgid "Tarantool starts in the interactive mode and displays a prompt:"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:67
#, fuzzy
msgid "tarantool>"
msgstr "tarantool> s:select{3}"

#: ../doc/1.7/book/getting_started/using_binary.rst:71
#: ../doc/1.7/book/getting_started/using_docker.rst:118
msgid "Now you can enter requests on the command line."
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:75
#: ../doc/1.7/book/getting_started/using_docker.rst:122
msgid ""
"On production machines, Tarantool's interactive mode is for system "
"administration only. But we use it for most examples in this manual, because the "
"interactive mode is convenient for learning."
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:81
#: ../doc/1.7/book/getting_started/using_docker.rst:128
msgid "Creating a database"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:83
msgid "Here is how to create a simple test database after installing."
msgstr ""
"Далее рассказывается, как создать простую тестовую базу данных после установки "
"Tarantool'а."

#: ../doc/1.7/book/getting_started/using_binary.rst:85
msgid ""
"Create a new directory (it’s just for tests, so you can delete it when the tests "
"are over):"
msgstr ""
"Создайте новую директорию. Она понадобится только для тестовых целей, и ее можно "
"будет удалить по окончании экспериментов:"

#: ../doc/1.7/book/getting_started/using_binary.rst:88
msgid ""
"$ mkdir ~/tarantool_sandbox\n"
"$ cd ~/tarantool_sandbox"
msgstr ""
"$ mkdir ~/tarantool_sandbox\n"
"$ cd ~/tarantool_sandbox"

#: ../doc/1.7/book/getting_started/using_binary.rst:93
msgid ""
"To start Tarantool's database module and make the instance accept TCP requests "
"on port 3301, say this:"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:96
msgid "tarantool> box.cfg{listen = 3301}"
msgstr "tarantool> box.cfg{listen = 3301}"

#: ../doc/1.7/book/getting_started/using_binary.rst:100
#: ../doc/1.7/book/getting_started/using_docker.rst:132
#, fuzzy
msgid ""
"First, create the first :ref:`space <index-box_space>` (named 'tester') and the "
"first :ref:`index <index-box_index>` (named 'primary'):"
msgstr "Создайте первое пространство и первый :ref:`индекс <box_index>`:"

#: ../doc/1.7/book/getting_started/using_binary.rst:103
#, fuzzy
msgid ""
"tarantool> s = box.schema.space.create('tester')\n"
"tarantool> s:create_index('primary', {\n"
"              >  type = 'hash',\n"
"              >  parts = {1, 'unsigned'}\n"
"              > })"
msgstr ""
"tarantool> s = box.schema.space.create('tester')\n"
"tarantool> s:create_index('primary', {\n"
"         >   type = 'hash',\n"
"         >   parts = {1, 'unsigned'}\n"
"         > })"

#: ../doc/1.7/book/getting_started/using_binary.rst:111
#: ../doc/1.7/book/getting_started/using_docker.rst:143
#, fuzzy
msgid ""
"Next, insert three :ref:`tuples <index-box_tuple>` (our name for \"records\") "
"into the space:"
msgstr ""
"Выполните вставку трех \"кортежей\" (tuple) в первое \"пространство\" (space) из "
"вашей базы данных:"

#: ../doc/1.7/book/getting_started/using_binary.rst:114
#, fuzzy
msgid ""
"tarantool> t = s:insert({1, 'Roxette'})\n"
"tarantool> t = s:insert({2, 'Scorpions', 2015})\n"
"tarantool> t = s:insert({3, 'Ace of Base', 1993})"
msgstr ""
"tarantool> t = s:insert({1})\n"
"tarantool> t = s:insert({2, 'Music'})\n"
"tarantool> t = s:insert({3, 'Length', 93})"

#: ../doc/1.7/book/getting_started/using_binary.rst:121
#: ../doc/1.7/book/getting_started/using_docker.rst:152
#, fuzzy
msgid ""
"To select a tuple from the first space of the database, using the first defined "
"key, say:"
msgstr ""
"Произведите выборку кортежа из первого пространства в базе по первому указанному "
"ключу:"

#: ../doc/1.7/book/getting_started/using_binary.rst:124
msgid "tarantool> s:select{3}"
msgstr "tarantool> s:select{3}"

#: ../doc/1.7/book/getting_started/using_binary.rst:128
#: ../doc/1.7/book/getting_started/using_docker.rst:159
#, fuzzy
msgid "The terminal screen now looks like this:"
msgstr "Теперь вывод на экране выглядит следующим образом:"

#: ../doc/1.7/book/getting_started/using_binary.rst:130
#, fuzzy
msgid ""
"tarantool> s = box.schema.space.create('tester')\n"
"2017-01-17 12:04:18.158 ... creating './00000000000000000000.xlog.inprogress'\n"
"---\n"
"...\n"
"tarantool>s:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
"---\n"
"...\n"
"tarantool> t = s:insert{1, 'Roxette'}\n"
"---\n"
"...\n"
"tarantool> t = s:insert{2, 'Scorpions', 2015}\n"
"---\n"
"...\n"
"tarantool> t = s:insert{3, 'Ace of Base', 1993}\n"
"---\n"
"...\n"
"tarantool> s:select{3}\n"
"---\n"
"- - [3, 'Ace of Base', 1993]\n"
"...\n"
"tarantool>"
msgstr ""
"tarantool> s = box.schema.space.create('tester')\n"
"2015-06-10 12:04:18.158 ... creating './00000000000000000000.xlog.inprogress'\n"
"---\n"
"...\n"
"tarantool>s:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
"---\n"
"...\n"
"tarantool> t = s:insert{1}\n"
"---\n"
"...\n"
"tarantool> t = s:insert{2, 'Music'}\n"
"---\n"
"...\n"
"tarantool> t = s:insert{3, 'Length', 93}\n"
"---\n"
"...\n"
"tarantool> s:select{3}\n"
"---\n"
"- - [3, 'Length', 93]\n"
"...\n"
"tarantool>"

#: ../doc/1.7/book/getting_started/using_binary.rst:154
#: ../doc/1.7/book/getting_started/using_docker.rst:185
msgid "To add another index on the second field, say:"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:156
#, fuzzy
msgid ""
"tarantool> s:create_index('secondary', {\n"
"         >  type = 'hash',\n"
"         >  parts = {2, 'string'}\n"
"         > })"
msgstr ""
"tarantool> i = s:create_index('primary', {type = 'hash', parts = {1, "
"'unsigned'}})"

#: ../doc/1.7/book/getting_started/using_binary.rst:165
msgid "Connecting remotely"
msgstr "Установка удаленного соединения"

#: ../doc/1.7/book/getting_started/using_binary.rst:167
msgid ""
"In the request ``box.cfg{listen = 3301}`` that we made earlier, the ``listen`` "
"value can be any form of a :ref:`URI <index-uri>` (uniform resource identifier). "
"In this case, it’s just a local port: port 3301. You can send requests to the "
"listen URI via:"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:172
#, fuzzy
msgid "``telnet``,"
msgstr "telnet,"

#: ../doc/1.7/book/getting_started/using_binary.rst:173
msgid "a :ref:`connector <index-box_connectors>`,"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:174
#, fuzzy
msgid ""
"another instance of Tarantool (using the :ref:`console <console-module>` "
"module), or"
msgstr ""
"другого экземпляра Tarantool'а с помощью :ref:`console module <console-module>`, "
"либо"

#: ../doc/1.7/book/getting_started/using_binary.rst:175
msgid ":ref:`tarantoolctl <tarantoolctl>` utility."
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:177
#, fuzzy
msgid "Let’s try (4)."
msgstr "Давайте попробуем вариант с ``tarantoolctl connect``."

#: ../doc/1.7/book/getting_started/using_binary.rst:179
#, fuzzy
msgid ""
"Switch to another terminal. On Linux, for example, this means starting another "
"instance of a Bash shell. You can switch to any working directory in the new "
"terminal, not necessarily to ``~/tarantool_sandbox``."
msgstr ""
"Переключитесь на другой терминал. Например, в Linux-системе для этого нужно "
"запустить новый экземпляр Bash. При этом вам не потребуется вызывать cd, чтобы "
"переключиться на директорию :code:`~/tarantool_sandbox`."

#: ../doc/1.7/book/getting_started/using_binary.rst:183
#, fuzzy
msgid "Start the ``tarantoolctl`` utility:"
msgstr "Запустите утилиту ``tarantoolctl``:"

#: ../doc/1.7/book/getting_started/using_binary.rst:185
msgid "$ tarantoolctl connect '3301'"
msgstr "$ tarantoolctl connect '3301'"

#: ../doc/1.7/book/getting_started/using_binary.rst:189
#, fuzzy
msgid ""
"This means \"use ``tarantoolctl connect`` to connect to the Tarantool instance "
"that’s listening on ``localhost:3301``\"."
msgstr ""
"Данная команда означает \"использовать утилиту :ref:`tarantoolctl "
"<administration-tarantoolctl_connect>` для соединения с Tarantool-сервером, "
"который слушает на ``localhost:3301``.\""

#: ../doc/1.7/book/getting_started/using_binary.rst:192
msgid "Try this request:"
msgstr "Введите следующий запрос:"

#: ../doc/1.7/book/getting_started/using_binary.rst:194
#, fuzzy
msgid "tarantool> box.space.tester:select{2}"
msgstr "tarantool> {**{box.space.tester:select{2}}**}"

#: ../doc/1.7/book/getting_started/using_binary.rst:198
#, fuzzy
msgid ""
"This means \"send a request to that Tarantool instance, and display the result"
"\". The result in this case is one of the tuples that was inserted earlier. Your "
"terminal screen should now look like this:"
msgstr ""
"Это означает \"послать запрос тому Tarantool-серверу и вывести результат на "
"экран.\" Результатом в данном случае будет один из кортежей, что вы вставляли "
"ранее. На терминале теперь должно отображаться примерно следующее:"

#: ../doc/1.7/book/getting_started/using_binary.rst:202
#, fuzzy
msgid ""
"$ tarantoolctl connect 3301\n"
"/usr/local/bin/tarantoolctl: connected to localhost:3301\n"
"localhost:3301> box.space.tester:select{2}\n"
"---\n"
"- - [2, 'Scorpions', 2015]\n"
"...\n"
"\n"
"localhost:3301>"
msgstr ""
"$ tarantoolctl connect 3301\n"
"/usr/local/bin/tarantoolctl: connected to localhost:3301\n"
"localhost:3301> box.space.tester:select{2}\n"
"---\n"
"- - [2, 'Music']\n"
"...\n"
"\n"
"localhost:3301>"

#: ../doc/1.7/book/getting_started/using_binary.rst:213
msgid ""
"You can repeat ``box.space...:insert{}`` and ``box.space...:select{}`` "
"indefinitely, on either Tarantool instance."
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:216
msgid "When the testing is over:"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:218
msgid "To drop the space: ``s:drop()``"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:219
msgid "To stop ``tarantoolctl``: Ctrl+C or Ctrl+D"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:220
msgid ""
"To stop Tarantool (an alternative): the standard Lua function `os.exit() <http://"
"www.lua.org/manual/5.1/manual.html#pdf-os.exit>`_"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:222
msgid "To stop Tarantool (from another terminal): ``sudo pkill -f tarantool``"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:223
msgid "To destroy the test: ``rm -r ~/tarantool_sandbox``"
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:39
msgid "Using a Docker image"
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:41
msgid ""
"For trial and test purposes, we recommend using `official Tarantool images for "
"Docker <https://github.com/tarantool/docker>`_. An official image contains a "
"particular Tarantool version (1.6 or 1.7) and all popular external modules for "
"Tarantool. Everything is already installed and configured in Linux. These images "
"are the easiest way to install and use Tarantool."
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:50
msgid ""
"If you're new to Docker, we recommend going over `this tutorial <https://docs."
"docker.com/engine/getstarted/step_one/>`_ before proceeding with this chapter."
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:58
msgid "Launching a container"
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:60
msgid ""
"If you don't have Docker installed, please follow the official `installation "
"guide <https://docs.docker.com/engine/getstarted/step_one/#/step-1-get-docker>`_ "
"for your OS."
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:64
msgid ""
"To start a fully functional Tarantool instance, run a container with minimal "
"options:"
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:67
msgid ""
"$ docker run \\\n"
"  --name mytarantool \\\n"
"  -d -p 3301:3301 \\\n"
"  -v /data/dir/on/host:/var/lib/tarantool \\\n"
"  tarantool/tarantool:1.7"
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:75
msgid ""
"This command runs a new container named 'mytarantool'. Docker starts it from an "
"official image named 'tarantool/tarantool:1.7', with Tarantool version 1.7 and "
"all external modules already installed."
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:79
msgid ""
"Tarantool will be accepting incoming connections on ``localhost:3301``. You may "
"start using it as a key-value storage right away."
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:82
msgid ""
"Tarantool :ref:`persists data <index-box_persistence>` inside the container. To "
"make your test data available after you stop the container, this command also "
"mounts the host's directory ``/data/dir/on/host`` (you need to specify here an "
"absolute path to an existing local directory) in the container's directory ``/"
"var/lib/tarantool`` (by convention, Tarantool in a container uses this directory "
"to persist data). So, all changes made in the mounted directory on the "
"container's side are applied to the host's disk."
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:91
msgid ""
"Tarantool's database module in the container is already :ref:`configured "
"<box_introspection-box_cfg>` and started. You needn't do it manually, unless you "
"use Tarantool as an :ref:`application server <app_server>` and run it with an "
"application."
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:98
#, fuzzy
msgid "Attaching to Tarantool"
msgstr "Подсоединение к экземплярам"

#: ../doc/1.7/book/getting_started/using_docker.rst:100
msgid "To attach to Tarantool that runs inside the container, say:"
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:102
msgid "$ docker exec -i -t mytarantool console"
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:106
msgid "This command:"
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:108
msgid ""
"Instructs Tarantool to open an interactive console port for incoming connections."
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:109
msgid ""
"Attaches to the Tarantool server inside the container under 'admin' user via a "
"standard Unix socket."
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:112
msgid "Tarantool displays a prompt:"
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:114
msgid "tarantool.sock>"
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:130
msgid "While you're attached to the console, let's create a simple test database."
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:135
#, fuzzy
msgid ""
"tarantool.sock> s = box.schema.space.create('tester')\n"
"tarantool.sock> s:create_index('primary', {\n"
"              >  type = 'hash',\n"
"              >  parts = {1, 'unsigned'}\n"
"              > })"
msgstr ""
"tarantool> s = box.schema.space.create('tester')\n"
"tarantool> s:create_index('primary', {\n"
"         >   type = 'hash',\n"
"         >   parts = {1, 'unsigned'}\n"
"         > })"

#: ../doc/1.7/book/getting_started/using_docker.rst:146
#, fuzzy
msgid ""
"tarantool.sock> t = s:insert({1, 'Roxette'})\n"
"tarantool.sock> t = s:insert({2, 'Scorpions', 2015})\n"
"tarantool.sock> t = s:insert({3, 'Ace of Base', 1993})"
msgstr ""
"tarantool> t = s:insert({1})\n"
"tarantool> t = s:insert({2, 'Music'})\n"
"tarantool> t = s:insert({3, 'Length', 93})"

#: ../doc/1.7/book/getting_started/using_docker.rst:155
#, fuzzy
msgid "tarantool.sock> s:select{3}"
msgstr "tarantool> s:select{3}"

#: ../doc/1.7/book/getting_started/using_docker.rst:161
#, fuzzy
msgid ""
"tarantool.sock> s = box.schema.space.create('tester')\n"
"2017-01-17 12:04:18.158 ... creating './00000000000000000000.xlog.inprogress'\n"
"---\n"
"...\n"
"tarantool.sock> s:create_index('primary', {type = 'hash', parts = {1, "
"'unsigned'}})\n"
"---\n"
"...\n"
"tarantool.sock> t = s:insert{1, 'Roxette'}\n"
"---\n"
"...\n"
"tarantool.sock> t = s:insert{2, 'Scorpions', 2015}\n"
"---\n"
"...\n"
"tarantool.sock> t = s:insert{3, 'Ace of Base', 1993}\n"
"---\n"
"...\n"
"tarantool.sock> s:select{3}\n"
"---\n"
"- - [3, 'Ace of Base', 1993]\n"
"...\n"
"tarantool.sock>"
msgstr ""
"tarantool> s = box.schema.space.create('tester')\n"
"2015-06-10 12:04:18.158 ... creating './00000000000000000000.xlog.inprogress'\n"
"---\n"
"...\n"
"tarantool>s:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
"---\n"
"...\n"
"tarantool> t = s:insert{1}\n"
"---\n"
"...\n"
"tarantool> t = s:insert{2, 'Music'}\n"
"---\n"
"...\n"
"tarantool> t = s:insert{3, 'Length', 93}\n"
"---\n"
"...\n"
"tarantool> s:select{3}\n"
"---\n"
"- - [3, 'Length', 93]\n"
"...\n"
"tarantool>"

#: ../doc/1.7/book/getting_started/using_docker.rst:187
#, fuzzy
msgid ""
"tarantool.sock> s:create_index('secondary', {\n"
"              >  type = 'hash',\n"
"              >  parts = {2, 'string'}\n"
"              > })"
msgstr ""
"tarantool> s = box.schema.space.create('tester')\n"
"tarantool> s:create_index('primary', {\n"
"         >   type = 'hash',\n"
"         >   parts = {1, 'unsigned'}\n"
"         > })"

#: ../doc/1.7/book/getting_started/using_docker.rst:196
#, fuzzy
msgid "Stopping a container"
msgstr "Остановка всех экземпляров:"

#: ../doc/1.7/book/getting_started/using_docker.rst:198
msgid "When the testing is over, stop the container politely:"
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:200
#, fuzzy
msgid "$ docker stop mytarantool"
msgstr "$ systemctl stop tarantool@example"

#: ../doc/1.7/book/getting_started/using_docker.rst:204
msgid ""
"This was a temporary container, and its disk/memory data were flushed when you "
"stopped it. But since you mounted a data directory from the host in the "
"container, Tarantool's data files were persisted to the host's disk. Now if you "
"start a new container and mount that data directory in it, Tarantool will "
"recover all data from disk and continue working with the persisted data."
msgstr ""

#: ../doc/1.7/book/index.rst:39
msgid "User's Guide"
msgstr "Руководство пользователя"

#: ../doc/1.7/book/intro.rst:37
msgid "Preface"
msgstr "Предисловие"

#: ../doc/1.7/book/intro.rst:39
msgid ""
"Welcome to Tarantool! This is the User's Guide. We recommend reading it first, "
"and consulting :ref:`Reference <reference>` materials for more detail "
"afterwards, if needed."
msgstr ""
"Добро пожаловать в мир Tarantool! Сейчас вы читаете \"Руководство пользователя"
"\". Мы советуем начинать именно с него, а затем переходить к :ref:`\"Справочникам"
"\" <reference>`, если вам понадобятся более подробные сведения."

#: ../doc/1.7/book/intro.rst:45
msgid "How to read the documentation"
msgstr "Как пользоваться документацией"

#: ../doc/1.7/book/intro.rst:47
msgid ""
"To get started, you can install and launch Tarantool using :ref:`a Docker "
"container <getting_started-using_docker>`, :ref:`a binary package "
"<getting_started-using_binary>`, or the online Tarantool server at http://try."
"tarantool.org. Either way, as the first tryout, you can follow the introductory "
"exercises from :ref:`Chapter 2 \"Getting started\" <getting_started>`. If you "
"want more hands-on experience, proceed to :ref:`Tutorials <tutorials>` after you "
"are through with Chapter 2."
msgstr ""

#: ../doc/1.7/book/intro.rst:56
msgid ""
":ref:`Chapter 3 \"Database\" <database-chapter>` is about using Tarantool as a "
"NoSQL DBMS, whereas :ref:`Chapter 4 \"Application server\" <app_server>` is "
"about using Tarantool as an application server."
msgstr ""
"В :ref:`главе 3 \"Функционал СУБД\" <database-chapter>` рассказано о "
"возможностях Tarantool'а как NoSQL СУБД, а в :ref:`главе 4 \"Сервер приложений\" "
"<app_server>` — о возможностях Tarantool'а как сервера приложений Lua."

#: ../doc/1.7/book/intro.rst:60
#, fuzzy
msgid ""
":ref:`Chapter 5 \"Server administration\" <admin>` and :ref:`Chapter 6 "
"\"Replication\" <replication>` are primarily for administrators."
msgstr ""
":ref:`Глава 5 \"Администрирование серверной части\" <server_admin>` "
"предназначена в первую очередь для системных администраторов."

#: ../doc/1.7/book/intro.rst:63
#, fuzzy
msgid ""
":ref:`Chapter 7 \"Connectors\" <index-box_connectors>` is strictly for users who "
"are connecting from a different language such as C or Perl or Python — other "
"users will find no immediate need for this chapter."
msgstr ""
":ref:`Глава 6 \"Коннекторы\" <index-box_connectors>` актуальна только для тех "
"пользователей, которые хотят устанавливать соединение с Tarantool'ом с помощью "
"программ на других языках программирования (например C, Perl или Python) — для "
"прочих пользователей эта глава неактуальна."

#: ../doc/1.7/book/intro.rst:67
#, fuzzy
msgid ""
":ref:`Chapter 8 \"FAQ\" <faq>` gives answers to some frequently asked questions "
"about Tarantool."
msgstr ""
":ref:`Глава 7 \"Вопросы и ответы\" <faq>` содержит ответы на некоторые часто "
"задаваемые вопросы о Tarantool'е."

#: ../doc/1.7/book/intro.rst:70
msgid ""
"For experienced users, there are also :ref:`Reference <reference>` materials, a :"
"ref:`Contributor's Guide <contrib_guide>` and an extensive set of comments in "
"the source code."
msgstr ""
"Опытным же пользователям будут полезны :ref:`\"Справочники\" <reference>`, :ref:`"
"\"Руководство участника проекта\" <contrib_guide>` и комментарии в исходном коде."

#: ../doc/1.7/book/intro.rst:76
msgid "Getting in touch with the Tarantool community"
msgstr "Как связаться с сообществом разработчиков Tarantool'а"

#: ../doc/1.7/book/intro.rst:78
msgid ""
"Please report bugs or make feature requests at http://github.com/tarantool/"
"tarantool/issues."
msgstr ""
"Оставить сообщение о найденых дефектах или сделать запрос на новый функционал "
"можно тут: http://github.com/tarantool/tarantool/issues"

#: ../doc/1.7/book/intro.rst:80
msgid ""
"You can contact developers directly in `telegram <http://telegram.me/"
"tarantool>`_ or in a Tarantool discussion group (`English <https://groups.google."
"com/forum/#!forum/tarantool>`_ or `Russian <https://googlegroups.com/group/"
"tarantool-ru>`_)."
msgstr ""
"Пообщаться напрямую с командой разработки Tarantool'а можно в `telegram <http://"
"telegram.me/tarantool>`_ или на форумах (`англоязычном <https://groups.google."
"com/forum/#!forum/tarantool>`_ или `русскоязычном <https://googlegroups.com/"
"group/tarantool-ru>`_)."

#: ../doc/1.7/book/intro.rst:87
#, fuzzy
msgid "Conventions used in this manual"
msgstr "Условные обозначения, используемые в этом разделе"

#: ../doc/1.7/book/intro.rst:89
msgid "Square brackets [ and ] enclose optional syntax."
msgstr ""

#: ../doc/1.7/book/intro.rst:91
msgid "Two dots in a row .. mean the preceding tokens may be repeated."
msgstr ""

#: ../doc/1.7/book/intro.rst:93
msgid ""
"A vertical bar | means the preceding and following tokens are mutually exclusive "
"alternatives."
msgstr ""

#: ../doc/1.7/book/replication/index.rst:39
#: ../doc/1.7/reference/configuration/index.rst:257
msgid "Replication"
msgstr "Репликация"

#: ../doc/1.7/book/replication/index.rst:41
#, fuzzy
msgid ""
"Replication allows multiple Tarantool instances to work on copies of the same "
"databases. The databases are kept in sync because each instance can communicate "
"its changes to all the other instances."
msgstr ""
"Механизм репликации позволяет сразу многим Tarantool-серверам работать с копиями "
"одних и тех же баз данных. При этом все базы остаются в синхронизированном "
"состоянии благодаря тому, что каждый сервер может сообщать другим серверам о "
"совершенных им изменениях. Сервера, которые работают над одними и теми же "
"базами, представляют собой \"кластер\". У каждого сервера в кластере есть "
"числовой идентификатор (server id), уникальный в рамках кластера."

#: ../doc/1.7/book/replication/repl_add_instances.rst:39
#, fuzzy
msgid "Adding instances"
msgstr "Запуск экземпляров"

#: ../doc/1.7/book/replication/repl_add_instances.rst:45
#, fuzzy
msgid "Adding a replica"
msgstr "Настройка сервера-реплики"

#: ../doc/1.7/book/replication/repl_add_instances.rst:50
msgid ""
"To add a second **replica** instance to the **master-replica** set from our :ref:"
"`bootstrapping example <replication-master_replica_bootstrap>`, we need an "
"analog of the instance file that we created for the first replica in that set:"
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:54
msgid ""
"-- instance file for replica #2\n"
"box.cfg{\n"
"  listen = 3301,\n"
"  replication = ('replicator:password@192.168.0.101:3301',  -- master URI\n"
"                 'replicator:password@192.168.0.102:3301',  -- replica #1 URI\n"
"                 'replicator:password@192.168.0.103:3301'), -- replica #2 URI\n"
"  read_only = true\n"
"}\n"
"box.once(\"schema\", function()\n"
"   box.schema.user.create('replicator', {password = 'password'})\n"
"   box.schema.user.grant('replicator', 'replication’) -- grant replication role\n"
"   box.schema.space.create(\"test\")\n"
"   box.space.test:create_index(\"primary\")\n"
"   print('box.once executed on replica #2')\n"
"end)"
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:72
msgid ""
"Here we add replica #2 URI to :ref:`replication <cfg_replication-replication>` "
"parameter, so now it contains three URIs."
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:75
msgid ""
"After we launch the new replica instance, it gets connected to the master "
"instance and retrieves the master's write ahead log and snapshot files:"
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:78
msgid ""
"$ # launching replica #2\n"
"$ tarantool replica2.lua\n"
"2017-06-14 14:54:33.927 [46945] main/101/replica2.lua C> version 1.7.4-52-"
"g980d30092\n"
"2017-06-14 14:54:33.927 [46945] main/101/replica2.lua C> log level 5\n"
"2017-06-14 14:54:33.928 [46945] main/101/replica2.lua I> mapping 268435456 bytes "
"for tuple arena...\n"
"2017-06-14 14:54:33.930 [46945] main/104/applier/replicator@192.168.0.10 I> "
"remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 14:54:33.930 [46945] main/104/applier/replicator@192.168.0.10 I> "
"authenticated\n"
"2017-06-14 14:54:33.930 [46945] main/101/replica2.lua I> bootstrapping replica "
"from 192.168.0.101:3301\n"
"2017-06-14 14:54:33.933 [46945] main/104/applier/replicator@192.168.0.10 I> "
"initial data received\n"
"2017-06-14 14:54:33.933 [46945] main/104/applier/replicator@192.168.0.10 I> "
"final data received\n"
"2017-06-14 14:54:33.934 [46945] snapshot/101/main I> saving snapshot `/var/lib/"
"tarantool/replica2/00000000000000000010.snap.inprogress'\n"
"2017-06-14 14:54:33.934 [46945] snapshot/101/main I> done\n"
"2017-06-14 14:54:33.935 [46945] main/101/replica2.lua I> vinyl checkpoint done\n"
"2017-06-14 14:54:33.935 [46945] main/101/replica2.lua I> ready to accept "
"requests\n"
"2017-06-14 14:54:33.935 [46945] main/101/replica2.lua I> set 'read_only' "
"configuration option to true\n"
"2017-06-14 14:54:33.936 [46945] main C> entering the event loop"
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:97
msgid ""
"Since we're adding a read-only instance, there is no need to dynamically update "
"``replication`` parameter on the other running instances. This update would be "
"required if we :ref:`added a master instance <replication-add_master>`."
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:101
msgid ""
"However, we recommend to specify replica #3 URI in all instance files of the "
"replica set. This will keep all the files consistent with each other and with "
"the current replication topology, and so will help to avoid configuration errors "
"in case of further reconfigurations and replica set restart."
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:110
#, fuzzy
msgid "Adding a master"
msgstr "Настройка главного сервера"

#: ../doc/1.7/book/replication/repl_add_instances.rst:115
msgid ""
"To add a third master instance to the **master-master** set from our :ref:"
"`bootstrapping example <replication-master_master_bootstrap>`, we need an analog "
"of the instance files that we created to bootstrap the other master instances in "
"that set:"
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:120
msgid ""
"-- instance file for master #3\n"
"box.cfg{\n"
"  listen      = 3301,\n"
"  replication = {'replicator:password@192.168.0.101:3301',  -- master#1 URI\n"
"                 'replicator:password@192.168.0.102:3301',  -- master#2 URI\n"
"                 'replicator:password@192.168.0.103:3301'}, -- master#3 URI\n"
"  read_only   = true, -- temporarily read-only\n"
"}\n"
"box.once(\"schema\", function()\n"
"   box.schema.user.create('replicator', {password = 'password'})\n"
"   box.schema.user.grant('replicator', 'replication’) -- grant \"replication\" "
"role\n"
"   box.schema.space.create(\"test\")\n"
"   box.space.test:create_index(\"primary\")\n"
"end)"
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:137
msgid "Here we make the following changes:"
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:139
#, fuzzy
msgid ""
"Add master#3 URI to :ref:`replication <cfg_replication-replication>` parameter."
msgstr ""
"Этот запрос можно выполнить в любой момент, т.к. параметр :ref:"
"`replication_source <cfg_replication-replication_source>` можно задавать на ходу."

#: ../doc/1.7/book/replication/repl_add_instances.rst:141
msgid ""
"Temporarily specify :ref:`read_only=true <cfg_basic-read_only>` to disable data-"
"change operations on the instance. After launch, master #3 will act as a replica "
"until it retrieves all data from the other masters in the replica set."
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:145
msgid ""
"After we launch the third master instance, it gets connected to the other master "
"instances and retrieves their write ahead logs and snapshot files:"
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:148
msgid ""
"$ # launching master #3\n"
"$ tarantool master3.lua\n"
"2017-06-14 17:10:00.556 [47121] main/101/master3.lua C> version 1.7.4-52-"
"g980d30092\n"
"2017-06-14 17:10:00.557 [47121] main/101/master3.lua C> log level 5\n"
"2017-06-14 17:10:00.557 [47121] main/101/master3.lua I> mapping 268435456 bytes "
"for tuple arena...\n"
"2017-06-14 17:10:00.559 [47121] iproto/101/main I> binary: bound to [::]:3301\n"
"2017-06-14 17:10:00.559 [47121] main/104/applier/replicator@192.168.0.10 I> "
"remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 17:10:00.559 [47121] main/105/applier/replicator@192.168.0.10 I> "
"remote master is 1.7.4 at 192.168.0.102:3301\n"
"2017-06-14 17:10:00.559 [47121] main/106/applier/replicator@192.168.0.10 I> "
"remote master is 1.7.4 at 192.168.0.103:3301\n"
"2017-06-14 17:10:00.559 [47121] main/105/applier/replicator@192.168.0.10 I> "
"authenticated\n"
"2017-06-14 17:10:00.559 [47121] main/101/master3.lua I> bootstrapping replica "
"from 192.168.0.102:3301\n"
"2017-06-14 17:10:00.562 [47121] main/105/applier/replicator@192.168.0.10 I> "
"initial data received\n"
"2017-06-14 17:10:00.562 [47121] main/105/applier/replicator@192.168.0.10 I> "
"final data received\n"
"2017-06-14 17:10:00.562 [47121] snapshot/101/main I> saving snapshot `/Users/e."
"shebunyaeva/work/tarantool-test-repl/master3_dir/00000000000000000009.snap."
"inprogress'\n"
"2017-06-14 17:10:00.562 [47121] snapshot/101/main I> done\n"
"2017-06-14 17:10:00.564 [47121] main/101/master3.lua I> vinyl checkpoint done\n"
"2017-06-14 17:10:00.564 [47121] main/101/master3.lua I> ready to accept "
"requests\n"
"2017-06-14 17:10:00.565 [47121] main/101/master3.lua I> set 'read_only' "
"configuration option to true\n"
"2017-06-14 17:10:00.565 [47121] main C> entering the event loop\n"
"2017-06-14 17:10:00.565 [47121] main/104/applier/replicator@192.168.0.10 I> "
"authenticated"
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:171
msgid ""
"Next, we add master#3 URI to ``replication`` parameter on the existing two "
"masters. Replication-related parameters are dynamic, so we only need to make a "
"``box.cfg{}`` request on each of the running instances:"
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:175
msgid ""
"# adding master #3 URI to replication sources\n"
"tarantool> box.cfg{replication =\n"
"         > {'replicator:password@192.168.0.101:3301',\n"
"         > 'replicator:password@192.168.0.102:3301',\n"
"         > 'replicator:password@192.168.0.103:3301'}}\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:185
msgid ""
"When master #3 catches up with the other masters' state, we can disable read-"
"only mode for this instance:"
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:188
msgid ""
"# making master #3 a real master\n"
"tarantool> box.cfg{read_only=false}\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:195
msgid ""
"We also recommend to specify master #3 URI in all instance files in order to "
"keep all the files consistent with each other and with the current replication "
"topology."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:39
msgid "Replication architecture"
msgstr "Архитектура механизма репликации"

#: ../doc/1.7/book/replication/repl_architecture.rst:45
#, fuzzy
msgid "Replication mechanism"
msgstr "Репликация"

#: ../doc/1.7/book/replication/repl_architecture.rst:47
msgid ""
"A pack of instances which operate on copies of the same databases make up a "
"**replica set**. Each instance in a replica set has a role, **master** or "
"**replica**."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:51
msgid ""
"A replica gets all updates from the master by continuously fetching and applying "
"its :ref:`write ahead log (WAL)<internals-wal>`. Each record in the WAL "
"represents a single Tarantool data-change request such as :ref:`INSERT<box_space-"
"insert>`, :ref:`UPDATE<box_space-update>` or :ref:`DELETE<box_space-delete>`, "
"and is assigned a monotonically growing log sequence number (**LSN**). In "
"essence, Tarantool replication is **row-based**: each data-change request is "
"fully deterministic and operates on a single :ref:`tuple<index-box_tuple>`. "
"However, unlike a classical row-based log, which contains entire copies of the "
"changed rows, Tarantool's WAL contains copies of the requests. For example, for "
"UPDATE requests, Tarantool only stores the primary key of the row and the update "
"operations, to save space."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:62
msgid ""
"Invocations of **stored programs** are not written to the WAL. Instead, records "
"of the actual **data-change requests, performed by the Lua code**, are written "
"to the WAL. This ensures that possible non-determinism of Lua does not cause "
"replication to go out of sync."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:67
msgid ""
"Data definition operations on **temporary spaces**, such as creating/dropping, "
"adding indexes, truncating, etc., are written to the WAL, since information "
"about temporary spaces is stored in non-temporary system spaces, such as :ref:"
"`box.space._space <box_space-space>`. Data change operations on temporary spaces "
"are not written to the WAL and are not replicated."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:73
msgid ""
"To create a valid initial state, to which WAL changes can be applied, every "
"instance of a replica set requires a start set of :ref:`checkpoint files <index-"
"box_persistence>`, such as .snap files for memtx and .run files for vinyl. A "
"replica joining an existing replica set, chooses an existing master and "
"automatically downloads the initial state from it. This is called an **initial "
"join**."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:80
msgid ""
"When an entire replica set is bootstrapped for the first time, there is no "
"master which could provide the initial checkpoint. In such case, replicas "
"connect to each other, elect a master, which then creates the starting set of "
"checkpoint files, and distributes it across all other replicas. This is called "
"an **automatic bootstrap** of a replica set."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:86
msgid ""
"When a replica contacts a master (there can be many masters) for the first time, "
"it becomes part of a replica set. On subsequent occasions, it should always "
"contact a master in the same replica set. Once connected to the master, the "
"replica requests all changes that happened after the latest local LSN (there can "
"be many LSNs -- each master has its own LSN)."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:92
msgid ""
"Each replica set is identified by a globally unique identifier, called **replica "
"set UUID**. The identifier is created by the master which creates the very first "
"checkpoint, and is part of the checkpoint file. It is stored in system space :"
"ref:`box.space._schema <box_space-schema>`. For example:"
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:97
msgid ""
"tarantool> box.space._schema:select{'cluster'}\n"
"---\n"
"- - ['cluster', '6308acb9-9788-42fa-8101-2e0cb9d3c9a0']\n"
"..."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:104
msgid ""
"Additionally, each instance in a replica set is assigned its own UUID, when it "
"joins the replica set. It is called an **instance UUID** and is a globally "
"unique identifier. This UUID is used to ensure that instances do not join a "
"different replica set, e.g. because of a configuration error. A unique instance "
"identifier is also necessary to apply rows originating from different masters "
"only once, that is, implement multi-master replication. This is why each row in "
"the write ahead log, in addition to its log sequence number, stores the instance "
"identifier of the instance on which it was created. But using UUID as such an "
"identifier would take too much space in the write ahead log, thus a shorter "
"integer number is assigned to the instance when it joins a replica set. This "
"number is then used to refer to the instance in the write ahead log. It is "
"called **instance id**. All identifiers are stored in system space :ref:`box."
"space._cluster <box_space-cluster>`. For example:"
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:125
msgid ""
"Here the instance ID is ``1`` (unique within the replica set), and the instance "
"UUID is ``88580b5c-4474-43ab-bd2b-2409a9af80d2`` (globally unique)."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:128
msgid ""
"Using shorter numeric identifiers is also handy to track the state of the entire "
"replica set. For example, :ref:`box.info.vclock <box_introspection-box_info>` "
"describes the state of replication in regard to each connected peer."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:132
msgid ""
"box.info.vclock\n"
"---\n"
"- {1: 827, 2: 584}\n"
"..."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:139
msgid ""
"Here ``vclock`` contains log sequence numbers (827 and 584) for instances with "
"short identifiers 1 and 2."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:146
#, fuzzy
msgid "Replication setup"
msgstr "Репликация"

#: ../doc/1.7/book/replication/repl_architecture.rst:148
msgid ""
"To enable replication, you need to specify two parameters in a ``box.cfg{}`` "
"request:"
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:151
msgid ""
":ref:`replication <cfg_replication-replication>` parameter which defines the "
"replication source(s), and"
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:153
msgid ""
":ref:`read_only <cfg_basic-read_only>` parameter which is ``true`` for a replica "
"and ``false`` for a master."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:156
#, fuzzy
msgid ""
"Both these parameters are \"dynamic\". This allows a replica to become a master "
"and vice versa on the fly with the help of a ``box.cfg{}`` request."
msgstr ""
"Параметры репликации можно менять на лету, что позволяет назначать реплику на "
"роль главного сервера и наоборот. Для этого используется запрос :ref:`box.cfg "
"<box_introspection-box_cfg>`."

#: ../doc/1.7/book/replication/repl_architecture.rst:159
msgid ""
"Further we're giving a detailed example of :ref:`bootstrapping a replica set "
"<replication-bootstrap>`."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:166
msgid "Replication roles: master and replica"
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:168
msgid ""
"Replication role (master or replica) is set in :ref:`read_only <cfg_basic-"
"read_only>` configuration parameter. The recommended role for **all-but-one** "
"instances in a replica set is \"read-only\" (replica)."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:172
msgid ""
"In a master-replica configuration, every change that happens on the master will "
"be visible on the replicas, but not vice versa."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:178
msgid ""
"A simple two-instance replica set with the master on one machine and the replica "
"on a different machine provides two benefits:"
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:181
msgid ""
"**failover**, because if the master goes down then the replica can take over, and"
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:183
msgid ""
"**load balancing**, because clients can connect to either the master or the "
"replica for read requests."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:186
msgid ""
"In a **master-master** configuration (also called \"multi-master\"), every "
"change that happens on either instance will be visible on the other one."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:192
msgid ""
"The failover benefit in this case is still present, and the load-balancing "
"benefit is enhanced, because any instance can handle both read and write "
"requests. Meanwhile, for multi-master configurations, it is necessary to "
"understand the **replication guarantees** provided by the asynchronous protocol "
"that Tarantool implements."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:198
msgid ""
"Tarantool multi-master replication guarantees that each change on each master is "
"propagated to all instances and is applied only once. Changes from the same "
"instance are applied in the same order as on the originating instance. Changes "
"from different instances, however, can mix and apply in a different order on "
"different instances. This may lead to replication going out of sync in certain "
"cases."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:205
msgid ""
"For example, assuming the database is only appended to (i.e. it contains only "
"insertions), it is safe to set each instance to a master. If there are also "
"deletions, but it is not mission critical that deletion happens in the same "
"order on all replicas (e.g. the DELETE is used to prune expired data), a master-"
"master configuration is also safe."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:211
msgid ""
"UPDATE operations, however, can easily go out of sync. For example, assignment "
"and increment are not commutative, and may yield different results if applied in "
"different order on different instances."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:215
msgid ""
"More generally, it is only safe to use Tarantool master-master replication if "
"all database changes are **commutative**: the end result does not depend on the "
"order in which the changes are applied. You can start learning more about "
"conflict-free replicated data types `here <https://en.wikipedia.org/wiki/"
"Conflict-free_replicated_data_type>`_."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:225
msgid "Replication topologies: cascade, ring and full mesh"
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:227
msgid ""
"Replication topology is set in :ref:`replication <cfg_replication-replication>` "
"configuration parameter. The recommended topology is a **full mesh**, because it "
"makes potential failover easy."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:231
msgid ""
"Some database products offer **cascading replication** topologies: creating a "
"replica on a replica. Tarantool does not recommend such setup."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:237
msgid ""
"The problem with a cascading replica set is that some instances have no "
"connection to other instances and may not receive changes from them. One "
"essential change that must be propagated across all instances in a replica set "
"is an entry in ``box.space._cluster`` system space with replica set UUID. "
"Without knowing a replica set UUID, a master refuses to accept connections from "
"such instances when replication topology changes. Here is how this can happen:"
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:247
msgid ""
"We have a chain of three instances. Instance #1 contains entries for instances "
"#1 and #2 in its ``_cluster`` space. Instances #2 and #3 contain entries for "
"instances #1, #2 and #3 in their ``_cluster`` spaces."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:254
msgid ""
"Now instance #2 is faulty. Instance #3 tries connecting to instance #1 as its "
"new master, but the master refuses the connection since it has no entry for "
"instance #3."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:258
msgid "**Ring replication** topology is, however, supported:"
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:263
msgid ""
"So, if you need a cascading topology, you may first create a ring to ensure all "
"instances know each other’s UUID, and then disconnect the chain in the place you "
"desire."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:267
msgid ""
"A stock recommendation for a master-master replication topology, however, is a "
"**full mesh**:"
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:273
msgid ""
"You then can decide where to locate instances of the mesh -- within the same "
"data center, or spread across a few data centers. Tarantool will automatically "
"ensure that each row is applied only once on each instance. To remove a degraded "
"instance from a mesh, simply change ``replication`` configuration parameter."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:278
msgid ""
"This ensures full cluster availability in case of a local failure, e.g. one of "
"the instances failing in one of the data centers, as well as in case of an "
"entire data center failure."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:282
msgid "The maximal number of replicas in a mesh is 32."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:39
#, fuzzy
msgid "Bootstrapping a replica set"
msgstr "Настройка сервера-реплики"

#: ../doc/1.7/book/replication/repl_bootstrap.rst:45
msgid "Master-replica bootstrap"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:47
msgid ""
"Let's first bootstrap a simple **master-replica** set containing two instances, "
"each located on its own machine. For easier administration, we make the :ref:"
"`instance files <admin-instance_file>` almost identical."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:54
msgid "Here is an example of the master's instance file:"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:56
msgid ""
"-- instance file for the master\n"
"box.cfg{\n"
"  listen = 3301,\n"
"  replication = {'replicator:password@192.168.0.101:3301',  -- master URI\n"
"                 'replicator:password@192.168.0.102:3301'}, -- replica URI\n"
"  read_only = false\n"
"}\n"
"box.once(\"schema\", function()\n"
"   box.schema.user.create('replicator', {password = 'password'})\n"
"   box.schema.user.grant('replicator', 'replication') -- grant replication role\n"
"   box.schema.space.create(\"test\")\n"
"   box.space.test:create_index(\"primary\")\n"
"   print('box.once executed on master')\n"
"end)"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:75
msgid ""
":ref:`listen <cfg_basic-listen>` parameter from ``box.cfg{}`` defines a URI "
"(port 3301 in our example), on which the master can accept connections from "
"replicas."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:78
msgid ""
":ref:`replication <cfg_replication-replication>` parameter defines the URIs at "
"which all instances in the replica set can accept connections. It includes the "
"replica's URI as well, although the replica is not a replication source right "
"now."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:85
msgid ""
"For security reasons, we recommend to prevent unauthorized replication sources "
"by associating a password with every user that has a replication :ref:`role "
"<authentication-roles>`. That way, the :ref:`URI <index-uri>` for "
"``replication`` parameter must have the long form ``username:password@host:"
"port``."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:91
msgid ""
":ref:`read_only <cfg_basic-read_only>` parameter enables data-change operations "
"on the instance and makes this Tarantool instance act as a master, not as a "
"replica. *That's the only parameter in our instance files that will differ.*"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:95
msgid ""
":ref:`box.once() <box-once>` function contains database initialization logic "
"that should be executed only once during the replica set lifetime."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:98
msgid ""
"In this example, we create a space with a primary index, and a user for "
"replication purposes. We also say ``print('box.once executed on master')`` to "
"see later in console whether ``box.once()`` is executed."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:104
#, fuzzy
msgid ""
"Replication requires privileges. We can grant privileges for accessing spaces "
"directly to the user who will start the instance. However, it is more usual to "
"grant privileges for accessing spaces to a :ref:`role <authentication-roles>`, "
"and then grant the role to the user who will start the replica."
msgstr ""
"Репликация требует настройки привилегий. Привилегии для доступа к пространствам "
"можно задать напрямую для пользователя, под чьим именем запущен сервер-реплика. "
"Но обычно привилегии на доступ к пространствам задаются с помощью :ref:`роли "
"<authentication-rep_role>`, которая затем присваивается пользователю, под чьим "
"именем запущен сервер-реплика."

#: ../doc/1.7/book/replication/repl_bootstrap.rst:110
msgid ""
"Here we use Tarantool's predefined role named \"replication\" which by default "
"grants \"read\" privileges for all database objects (\"universe\"), and we can "
"further set up privileges for this role as required."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:114
msgid ""
"In the replica's instance file, we only set read-only parameter to \"true\", and "
"say ``print('box.once executed on replica')`` to make sure that box.once() is "
"not executed more than once. Otherwise the replica's instance file is fully "
"identical to the master's instance file."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:119
msgid ""
"-- instance file for the replica\n"
"box.cfg{\n"
"  listen = 3301,\n"
"  replication = {'replicator:password@192.168.0.101:3301',  -- master URI\n"
"                 'replicator:password@192.168.0.102:3301'}, -- replica URI\n"
"  read_only = true\n"
"}\n"
"box.once(\"schema\", function()\n"
"   box.schema.user.create('replicator', {password = 'password'})\n"
"   box.schema.user.grant('replicator', 'replication') -- grant replication role\n"
"   box.schema.space.create(\"test\")\n"
"   box.space.test:create_index(\"primary\")\n"
"   print('box.once executed on replica')\n"
"end)"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:138
#, fuzzy
msgid ""
"The replica does not inherit the master’s configuration parameters, such as "
"those making the :ref:`checkpoint daemon <book_cfg_checkpoint_daemon>` run on "
"the master. To get the same behavior, please set the relevant parameters "
"explicitly so that they are the same on both master and replica."
msgstr ""
"Реплика не берет настройки конфигурации с главного сервера, например настройки "
"запуска :ref:`фоновой программы для работы со снимками "
"<book_cfg_snapshot_daemon>` на главном сервере. Чтобы получить те же настройки "
"на реплике, нужно задать их явным образом."

#: ../doc/1.7/book/replication/repl_bootstrap.rst:143
msgid "Now we can launch the two instances. The master..."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:145
msgid ""
"$ # launching the master\n"
"$ tarantool master.lua\n"
"2017-06-14 14:12:03.847 [18933] main/101/master.lua C> version 1.7.4-52-"
"g980d30092\n"
"2017-06-14 14:12:03.848 [18933] main/101/master.lua C> log level 5\n"
"2017-06-14 14:12:03.849 [18933] main/101/master.lua I> mapping 268435456 bytes "
"for tuple arena...\n"
"2017-06-14 14:12:03.859 [18933] iproto/101/main I> binary: bound to [::]:3301\n"
"2017-06-14 14:12:03.861 [18933] main/105/applier/replicator@192.168.0. I> can't "
"connect to master\n"
"2017-06-14 14:12:03.861 [18933] main/105/applier/replicator@192.168.0. coio."
"cc:105 !> SystemError connect, called on fd 14, aka 192.168.0.102:56736: "
"Connection refused\n"
"2017-06-14 14:12:03.861 [18933] main/105/applier/replicator@192.168.0. I> will "
"retry every 1 second\n"
"2017-06-14 14:12:03.861 [18933] main/104/applier/replicator@192.168.0. I> remote "
"master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 14:12:19.878 [18933] main/105/applier/replicator@192.168.0. I> remote "
"master is 1.7.4 at 192.168.0.102:3301\n"
"2017-06-14 14:12:19.879 [18933] main/101/master.lua I> initializing an empty "
"data directory\n"
"2017-06-14 14:12:19.908 [18933] snapshot/101/main I> saving snapshot `/var/lib/"
"tarantool/master/00000000000000000000.snap.inprogress'\n"
"2017-06-14 14:12:19.914 [18933] snapshot/101/main I> done\n"
"2017-06-14 14:12:19.914 [18933] main/101/master.lua I> vinyl checkpoint done\n"
"2017-06-14 14:12:19.917 [18933] main/101/master.lua I> ready to accept requests\n"
"2017-06-14 14:12:19.918 [18933] main/105/applier/replicator@192.168.0. I> failed "
"to authenticate\n"
"2017-06-14 14:12:19.918 [18933] main/105/applier/replicator@192.168.0. xrow."
"cc:431 E> ER_LOADING: Instance bootstrap hasn't finished yet\n"
"box.once executed on master\n"
"2017-06-14 14:12:19.920 [18933] main C> entering the event loop"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:168
msgid "... (yep, ``box.once()`` got executed on the master) -- and the replica:"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:170
msgid ""
"$ # launching the replica\n"
"$ tarantool replica.lua\n"
"2017-06-14 14:12:19.486 [18934] main/101/replica.lua C> version 1.7.4-52-"
"g980d30092\n"
"2017-06-14 14:12:19.486 [18934] main/101/replica.lua C> log level 5\n"
"2017-06-14 14:12:19.487 [18934] main/101/replica.lua I> mapping 268435456 bytes "
"for tuple arena...\n"
"2017-06-14 14:12:19.494 [18934] iproto/101/main I> binary: bound to [::]:3311\n"
"2017-06-14 14:12:19.495 [18934] main/104/applier/replicator@192.168.0. I> remote "
"master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 14:12:19.495 [18934] main/105/applier/replicator@192.168.0. I> remote "
"master is 1.7.4 at 192.168.0.102:3302\n"
"2017-06-14 14:12:19.496 [18934] main/104/applier/replicator@192.168.0. I> failed "
"to authenticate\n"
"2017-06-14 14:12:19.496 [18934] main/104/applier/replicator@192.168.0. xrow."
"cc:431 E> ER_LOADING: Instance bootstrap hasn't finished yet"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:183
msgid ""
"In both logs, there are messages saying that the replica got bootstrapped from "
"the master:"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:185
msgid ""
"$ # bootstrapping the replica (from the master's log)\n"
"<...>\n"
"2017-06-14 14:12:20.503 [18933] main/106/main I> initial data sent.\n"
"2017-06-14 14:12:20.505 [18933] relay/[::ffff:192.168.0.101]:/101/main I> "
"recover from `/var/lib/tarantool/master/00000000000000000000.xlog'\n"
"2017-06-14 14:12:20.505 [18933] main/106/main I> final data sent.\n"
"2017-06-14 14:12:20.522 [18933] relay/[::ffff:192.168.0.101]:/101/main I> "
"recover from `/Users/e.shebunyaeva/work/tarantool-test-repl/"
"master_dir/00000000000000000000.xlog'\n"
"2017-06-14 14:12:20.922 [18933] main/105/applier/replicator@192.168.0. I> "
"authenticated"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:195
msgid ""
"$ # bootstrapping the replica (from the replica's log)\n"
"<...>\n"
"2017-06-14 14:12:20.498 [18934] main/104/applier/replicator@192.168.0. I> "
"authenticated\n"
"2017-06-14 14:12:20.498 [18934] main/101/replica.lua I> bootstrapping replica "
"from 192.168.0.101:3301\n"
"2017-06-14 14:12:20.512 [18934] main/104/applier/replicator@192.168.0. I> "
"initial data received\n"
"2017-06-14 14:12:20.512 [18934] main/104/applier/replicator@192.168.0. I> final "
"data received\n"
"2017-06-14 14:12:20.517 [18934] snapshot/101/main I> saving snapshot `/var/lib/"
"tarantool/replica/00000000000000000005.snap.inprogress'\n"
"2017-06-14 14:12:20.518 [18934] snapshot/101/main I> done\n"
"2017-06-14 14:12:20.519 [18934] main/101/replica.lua I> vinyl checkpoint done\n"
"2017-06-14 14:12:20.520 [18934] main/101/replica.lua I> ready to accept "
"requests\n"
"2017-06-14 14:12:20.520 [18934] main/101/replica.lua I> set 'read_only' "
"configuration option to true\n"
"2017-06-14 14:12:20.520 [18934] main C> entering the event loop"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:210
msgid ""
"Notice that ``box.once()`` was executed only at the master, although we added "
"``box.once()`` to both instance files."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:213
msgid "We could as well launch the replica first:"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:215
msgid ""
"$ # launching the replica\n"
"$ tarantool replica.lua\n"
"2017-06-14 14:35:36.763 [18952] main/101/replica.lua C> version 1.7.4-52-"
"g980d30092\n"
"2017-06-14 14:35:36.765 [18952] main/101/replica.lua C> log level 5\n"
"2017-06-14 14:35:36.765 [18952] main/101/replica.lua I> mapping 268435456 bytes "
"for tuple arena...\n"
"2017-06-14 14:35:36.772 [18952] iproto/101/main I> binary: bound to [::]:3301\n"
"2017-06-14 14:35:36.772 [18952] main/104/applier/replicator@192.168.0. I> can't "
"connect to master\n"
"2017-06-14 14:35:36.772 [18952] main/104/applier/replicator@192.168.0. coio."
"cc:105 !> SystemError connect, called on fd 13, aka 192.168.0.101:56820: "
"Connection refused\n"
"2017-06-14 14:35:36.772 [18952] main/104/applier/replicator@192.168.0. I> will "
"retry every 1 second\n"
"2017-06-14 14:35:36.772 [18952] main/105/applier/replicator@192.168.0. I> remote "
"master is 1.7.4 at 192.168.0.102:3301"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:228
msgid "... and the master later:"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:230
msgid ""
"$ # launching the master\n"
"$ tarantool master.lua\n"
"2017-06-14 14:35:43.701 [18953] main/101/master.lua C> version 1.7.4-52-"
"g980d30092\n"
"2017-06-14 14:35:43.702 [18953] main/101/master.lua C> log level 5\n"
"2017-06-14 14:35:43.702 [18953] main/101/master.lua I> mapping 268435456 bytes "
"for tuple arena...\n"
"2017-06-14 14:35:43.709 [18953] iproto/101/main I> binary: bound to [::]:3301\n"
"2017-06-14 14:35:43.709 [18953] main/105/applier/replicator@192.168.0. I> remote "
"master is 1.7.4 at 192.168.0.102:3301\n"
"2017-06-14 14:35:43.709 [18953] main/104/applier/replicator@192.168.0. I> remote "
"master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 14:35:43.709 [18953] main/101/master.lua I> initializing an empty "
"data directory\n"
"2017-06-14 14:35:43.721 [18953] snapshot/101/main I> saving snapshot `/var/lib/"
"tarantool/master/00000000000000000000.snap.inprogress'\n"
"2017-06-14 14:35:43.722 [18953] snapshot/101/main I> done\n"
"2017-06-14 14:35:43.723 [18953] main/101/master.lua I> vinyl checkpoint done\n"
"2017-06-14 14:35:43.723 [18953] main/101/master.lua I> ready to accept requests\n"
"2017-06-14 14:35:43.724 [18953] main/105/applier/replicator@192.168.0. I> failed "
"to authenticate\n"
"2017-06-14 14:35:43.724 [18953] main/105/applier/replicator@192.168.0. xrow."
"cc:431 E> ER_LOADING: Instance bootstrap hasn't finished yet\n"
"box.once executed on master\n"
"2017-06-14 14:35:43.726 [18953] main C> entering the event loop\n"
"2017-06-14 14:35:43.779 [18953] main/103/main I> initial data sent.\n"
"2017-06-14 14:35:43.780 [18953] relay/[::ffff:192.168.0.101]:/101/main I> "
"recover from `/var/lib/tarantool/master/00000000000000000000.xlog'\n"
"2017-06-14 14:35:43.780 [18953] main/103/main I> final data sent.\n"
"2017-06-14 14:35:43.796 [18953] relay/[::ffff:192.168.0.102]:/101/main I> "
"recover from `/var/lib/tarantool/master/00000000000000000000.xlog'\n"
"2017-06-14 14:35:44.726 [18953] main/105/applier/replicator@192.168.0. I> "
"authenticated"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:255
msgid ""
"In this case, the replica would wait for the master to become available, so the "
"launch order doesn't matter. Our ``box.once()`` logic would also be executed "
"only once, at the master."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:259
msgid ""
"$ # the replica has eventually connected to the master\n"
"$ # and got bootstrapped (from the replica's log)\n"
"2017-06-14 14:35:43.777 [18952] main/104/applier/replicator@192.168.0. I> remote "
"master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 14:35:43.777 [18952] main/104/applier/replicator@192.168.0. I> "
"authenticated\n"
"2017-06-14 14:35:43.777 [18952] main/101/replica.lua I> bootstrapping replica "
"from 192.168.0.199:3310\n"
"2017-06-14 14:35:43.788 [18952] main/104/applier/replicator@192.168.0. I> "
"initial data received\n"
"2017-06-14 14:35:43.789 [18952] main/104/applier/replicator@192.168.0. I> final "
"data received\n"
"2017-06-14 14:35:43.793 [18952] snapshot/101/main I> saving snapshot `/var/lib/"
"tarantool/replica/00000000000000000005.snap.inprogress'\n"
"2017-06-14 14:35:43.793 [18952] snapshot/101/main I> done\n"
"2017-06-14 14:35:43.795 [18952] main/101/replica.lua I> vinyl checkpoint done\n"
"2017-06-14 14:35:43.795 [18952] main/101/replica.lua I> ready to accept "
"requests\n"
"2017-06-14 14:35:43.795 [18952] main/101/replica.lua I> set 'read_only' "
"configuration option to true\n"
"2017-06-14 14:35:43.795 [18952] main C> entering the event loop"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:279
msgid "Controlled failover"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:281
msgid ""
"To perform a **controlled failover**, that is, swap the roles of the master and "
"replica, all we need to do is to set ``read_only=true`` at the master, and "
"``read_only=false`` at the replica. The **order of actions** is important here. "
"If a system is running in production, we don’t want concurrent writes happen "
"both at the replica and the master. Nor do we want the new replica to accept any "
"writes until it has finished fetching all replication data from the old master. "
"To compare replica and master state, we can use :ref:`box.info.signature "
"<box_introspection-box_info>`."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:290
msgid "Set ``read_only=true`` at the master."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:292
msgid ""
"# at the master\n"
"tarantool> box.cfg{read_only=true}"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:297
msgid ""
"Record the master’s current position with ``box.info.signature``, containing the "
"sum of all LSNs in the master’s vector clock."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:300
msgid ""
"# at the master\n"
"tarantool> box.info.signature"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:305
msgid "Wait until the replica’s signature is the same as the master’s."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:307
msgid ""
"# at the replica\n"
"tarantool> box.info.signature"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:312
msgid "Set ``read_only=false`` at the replica to enable write operations."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:314
msgid ""
"# at the replica\n"
"tarantool> box.cfg{read_only=false}"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:319
msgid ""
"These 4 steps ensure that the replica doesn’t accept new writes until it’s done "
"fetching writes from the master."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:326
#, fuzzy
msgid "Master-master bootstrap"
msgstr "Репликация по схеме master-master"

#: ../doc/1.7/book/replication/repl_bootstrap.rst:328
msgid ""
"Now let's bootstrap a two-instance **master-master** set. For easier "
"administration, we make master#1 and master#2 instance files fully identical."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:334
msgid ""
"We re-use the master's instance file from the :ref:`master-replica example "
"<replication-master_replica_bootstrap>` above."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:337
msgid ""
"-- instance file for any of the two masters\n"
"box.cfg{\n"
"  listen      = 3301,\n"
"  replication = {'replicator:password@192.168.0.101:3301',  -- master1 URI\n"
"                 'replicator:password@192.168.0.102:3301'}, -- master2 URI\n"
"  read_only   = false\n"
"}\n"
"box.once(\"schema\", function()\n"
"   box.schema.user.create('replicator', {password = 'password'})\n"
"   box.schema.user.grant('replicator', 'replication') -- grant replication role\n"
"   box.schema.space.create(\"test\")\n"
"   box.space.test:create_index(\"primary\")\n"
"   print('box.once executed on master #1')\n"
"end)"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:354
msgid ""
"In :ref:`replication <cfg_replication-replication>` parameter, we define the "
"URIs of both masters in the replica set and say ``print('box.once executed on "
"master #1')`` to see when and where the ``box.once()`` logic is executed."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:359
msgid ""
"Now we can launch the two masters. Again, the launch order doesn't matter. The "
"``box.once()`` logic will also be executed only once, at the master which is "
"elected as the replica set leader at bootstrap."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:363
msgid ""
"$ # launching master #1\n"
"$ tarantool master1.lua\n"
"2017-06-14 15:39:03.062 [47021] main/101/master1.lua C> version 1.7.4-52-"
"g980d30092\n"
"2017-06-14 15:39:03.062 [47021] main/101/master1.lua C> log level 5\n"
"2017-06-14 15:39:03.063 [47021] main/101/master1.lua I> mapping 268435456 bytes "
"for tuple arena...\n"
"2017-06-14 15:39:03.065 [47021] iproto/101/main I> binary: bound to [::]:3301\n"
"2017-06-14 15:39:03.065 [47021] main/105/applier/replicator@192.168.0.10 I> "
"can't connect to master\n"
"2017-06-14 15:39:03.065 [47021] main/105/applier/replicator@192.168.0.10 coio."
"cc:107 !> SystemError connect, called on fd 14, aka 192.168.0.102:57110: "
"Connection refused\n"
"2017-06-14 15:39:03.065 [47021] main/105/applier/replicator@192.168.0.10 I> will "
"retry every 1 second\n"
"2017-06-14 15:39:03.065 [47021] main/104/applier/replicator@192.168.0.10 I> "
"remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 15:39:08.070 [47021] main/105/applier/replicator@192.168.0.10 I> "
"remote master is 1.7.4 at 192.168.0.102:3301\n"
"2017-06-14 15:39:08.071 [47021] main/105/applier/replicator@192.168.0.10 I> "
"authenticated\n"
"2017-06-14 15:39:08.071 [47021] main/101/master1.lua I> bootstrapping replica "
"from 192.168.0.102:3301\n"
"2017-06-14 15:39:08.073 [47021] main/105/applier/replicator@192.168.0.10 I> "
"initial data received\n"
"2017-06-14 15:39:08.074 [47021] main/105/applier/replicator@192.168.0.10 I> "
"final data received\n"
"2017-06-14 15:39:08.074 [47021] snapshot/101/main I> saving snapshot `/Users/e."
"shebunyaeva/work/tarantool-test-repl/master1_dir/00000000000000000008.snap."
"inprogress'\n"
"2017-06-14 15:39:08.074 [47021] snapshot/101/main I> done\n"
"2017-06-14 15:39:08.076 [47021] main/101/master1.lua I> vinyl checkpoint done\n"
"2017-06-14 15:39:08.076 [47021] main/101/master1.lua I> ready to accept "
"requests\n"
"box.once executed on master #1\n"
"2017-06-14 15:39:08.077 [47021] main C> entering the event loop"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:387
msgid ""
"$ # launching master #2\n"
"$ tarantool master2.lua\n"
"2017-06-14 15:39:07.452 [47022] main/101/master2.lua C> version 1.7.4-52-"
"g980d30092\n"
"2017-06-14 15:39:07.453 [47022] main/101/master2.lua C> log level 5\n"
"2017-06-14 15:39:07.453 [47022] main/101/master2.lua I> mapping 268435456 bytes "
"for tuple arena...\n"
"2017-06-14 15:39:07.455 [47022] iproto/101/main I> binary: bound to [::]:3301\n"
"2017-06-14 15:39:07.455 [47022] main/104/applier/replicator@192.168.0.19 I> "
"remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 15:39:07.455 [47022] main/105/applier/replicator@192.168.0.10 I> "
"remote master is 1.7.4 at 192.168.0.102:3301\n"
"2017-06-14 15:39:07.455 [47022] main/101/master2.lua I> initializing an empty "
"data directory\n"
"2017-06-14 15:39:07.457 [47022] snapshot/101/main I> saving snapshot `/Users/e."
"shebunyaeva/work/tarantool-test-repl/master2_dir/00000000000000000000.snap."
"inprogress'\n"
"2017-06-14 15:39:07.457 [47022] snapshot/101/main I> done\n"
"2017-06-14 15:39:07.458 [47022] main/101/master2.lua I> vinyl checkpoint done\n"
"2017-06-14 15:39:07.459 [47022] main/101/master2.lua I> ready to accept "
"requests\n"
"2017-06-14 15:39:07.460 [47022] main C> entering the event loop\n"
"2017-06-14 15:39:08.072 [47022] main/103/main I> initial data sent.\n"
"2017-06-14 15:39:08.073 [47022] relay/[::ffff:192.168.0.102]:/101/main I> "
"recover from `/Users/e.shebunyaeva/work/tarantool-test-repl/"
"master2_dir/00000000000000000000.xlog'\n"
"2017-06-14 15:39:08.073 [47022] main/103/main I> final data sent.\n"
"2017-06-14 15:39:08.077 [47022] relay/[::ffff:192.168.0.102]:/101/main I> "
"recover from `/Users/e.shebunyaeva/work/tarantool-test-repl/"
"master2_dir/00000000000000000000.xlog'\n"
"2017-06-14 15:39:08.461 [47022] main/104/applier/replicator@192.168.0.10 I> "
"authenticated"
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:39
msgid "Preventing duplicate actions"
msgstr "Предотвращение дублирующихся действий"

#: ../doc/1.7/book/replication/repl_duplicates.rst:41
msgid ""
"Tarantool guarantees that every update is applied only once at every replica. "
"However, due to asynchronous nature of the replication, the order of updates is "
"not guaranteed. Further we analyse this problem in more details, provide "
"examples of replication going out of sync, and suggest solutions."
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:50
#, fuzzy
msgid "Replication stops"
msgstr "Репликация"

#: ../doc/1.7/book/replication/repl_duplicates.rst:52
msgid ""
"In a replica set of two masters, suppose master #1 tries to do something that "
"master #2 has already done. For example, try to simultaneously insert a tuple "
"with the same unique key:"
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:56
#, fuzzy
msgid "tarantool> box.space.tester:insert{1, 'data'}"
msgstr "tarantool> {**{box.space.tester:select{2}}**}"

#: ../doc/1.7/book/replication/repl_duplicates.rst:60
msgid ""
"This would cause an error saying ``Duplicate key exists in unique index "
"'primary' in space 'tester'`` and the replication would be stopped."
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:63
msgid ""
"$ # error messages from master #1\n"
"2017-06-26 21:17:03.233 [30444] main/104/applier/rep_user@100.96.166.1 I> can't "
"read row\n"
"2017-06-26 21:17:03.233 [30444] main/104/applier/rep_user@100.96.166.1 "
"memtx_hash.cc:226 E> ER_TUPLE_FOUND:\n"
"Duplicate key exists in unique index 'primary' in space 'tester'\n"
"2017-06-26 21:17:03.233 [30444] relay/[::ffff:100.96.166.178]/101/main I> the "
"replica has closed its socket, exiting\n"
"2017-06-26 21:17:03.233 [30444] relay/[::ffff:100.96.166.178]/101/main C> "
"exiting the relay loop\n"
"\n"
"$ # error messages from master #2\n"
"2017-06-26 21:17:03.233 [30445] main/104/applier/rep_user@100.96.166.1 I> can't "
"read row\n"
"2017-06-26 21:17:03.233 [30445] main/104/applier/rep_user@100.96.166.1 "
"memtx_hash.cc:226 E> ER_TUPLE_FOUND:\n"
"Duplicate key exists in unique index 'primary' in space 'tester'\n"
"2017-06-26 21:17:03.234 [30445] relay/[::ffff:100.96.166.178]/101/main I> the "
"replica has closed its socket, exiting\n"
"2017-06-26 21:17:03.234 [30445] relay/[::ffff:100.96.166.178]/101/main C> "
"exiting the relay loop"
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:79
msgid ""
"If we check replication statuses with ``box.info``, we'll see that replication "
"at master #1 is stopped (``1.upstream.status = stopped``). Additionally, no data "
"is replicated from that master (section ``1.downstream`` is missing in the "
"report), because the downstream has encountered the same error:"
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:84
msgid ""
"# replication statuses (report from master #3)\n"
"tarantool> box.info\n"
"---\n"
"- version: 1.7.4-52-g980d30092\n"
"  id: 3\n"
"  ro: false\n"
"  vclock: {1: 9, 2: 1000000, 3: 3}\n"
"  uptime: 557\n"
"  lsn: 3\n"
"  vinyl: []\n"
"  cluster:\n"
"    uuid: 34d13b1a-f851-45bb-8f57-57489d3b3c8b\n"
"  pid: 30445\n"
"  status: running\n"
"  signature: 1000012\n"
"  replication:\n"
"    1:\n"
"      id: 1\n"
"      uuid: 7ab6dee7-dc0f-4477-af2b-0e63452573cf\n"
"      lsn: 9\n"
"      upstream:\n"
"        status: stopped\n"
"        idle: 445.8626639843\n"
"        message: Duplicate key exists in unique index 'primary' in space "
"'tester'\n"
"        lag: 0.00050592422485352\n"
"    2:\n"
"      id: 2\n"
"      uuid: 9afbe2d9-db84-4d05-9a7b-e0cbbf861e28\n"
"      lsn: 1000000\n"
"      upstream:\n"
"        status: follow\n"
"        idle: 201.99915885925\n"
"        lag: 0.0015020370483398\n"
"      downstream:\n"
"        vclock: {1: 8, 2: 1000000, 3: 3}\n"
"    3:\n"
"      id: 3\n"
"      uuid: e826a667-eed7-48d5-a290-64299b159571\n"
"      lsn: 3\n"
"  uuid: e826a667-eed7-48d5-a290-64299b159571\n"
"..."
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:128
msgid "When replication is later manually resumed:"
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:130
msgid ""
"# resuming stopped replication (at all masters)\n"
"tarantool> original_value = box.cfg.replication\n"
"tarantool> box.cfg{replication={}}\n"
"tarantool> box.cfg{replication=original_value}"
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:137
msgid "... the faulty row in the write ahead log files is skipped."
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:143
msgid "Replication runs out of sync"
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:145
msgid ""
"In a master-master cluster of two instances, suppose we make the following "
"operation:"
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:148
#, fuzzy
msgid "tarantool> box.space.tester:upsert({1}, {{'=', 2, box.info.uuid}})"
msgstr "tarantool> box.space.tester:update({3}, {{'=', 2, 'size'}, {'=', 3, 0}})"

#: ../doc/1.7/book/replication/repl_duplicates.rst:152
msgid "When we get this operation applied on both instances in the replica set:"
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:154
msgid ""
"-- at master #1\n"
"tarantool> box.space.tester:upsert({1}, {{'=', 2, box.info.uuid}})\n"
"-- at master #2\n"
"tarantool> box.space.tester:upsert({1}, {{'=', 2, box.info.uuid}})"
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:161
msgid "... we can have the following results, depending on the order of execution:"
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:163
msgid "each master’s row contains the uuid from master #1,"
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:164
msgid "each master’s row contains the uuid from master #2,"
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:165
msgid "master #1 has the uuid of master #2, and vice versa."
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:171
msgid "Commutative changes"
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:173
msgid ""
"The cases described in previous paragraphs represent examples of **non-"
"commutative** operations, i.e. operations, which result depends on the execution "
"order. On the contrary, for **commutative operations**, the execution order "
"doesn’t matter."
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:178
msgid "Consider for example the following command:"
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:180
#, fuzzy
msgid "tarantool> box.space.tester:upsert{{1, 0}, {{'+', 2, 1)}"
msgstr "tarantool> box.space.tester:update({3}, {{'=', 2, 'size'}, {'=', 3, 0}})"

#: ../doc/1.7/book/replication/repl_duplicates.rst:184
msgid ""
"This operation is commutative: we get the same result no matter in which order "
"the update is applied on the other masters."
msgstr ""

#: ../doc/1.7/book/replication/repl_monitoring.rst:39
#, fuzzy
msgid "Monitoring a replica set"
msgstr "Мониторинг действий реплики"

#: ../doc/1.7/book/replication/repl_monitoring.rst:41
msgid ""
"To learn what instances belong in the replica set, and obtain statistics for all "
"these instances, use ``box.info.replication`` request:"
msgstr ""

#: ../doc/1.7/book/replication/repl_monitoring.rst:44
msgid ""
"box.info.replication\n"
"---\n"
"  replication:\n"
"    1:\n"
"      id: 1\n"
"      uuid: b8a7db60-745f-41b3-bf68-5fcce7a1e019\n"
"      lsn: 88\n"
"    2:\n"
"      id: 2\n"
"      uuid: cd3c7da2-a638-4c5d-ae63-e7767c3a6896\n"
"      lsn: 31\n"
"      upstream:\n"
"        status: follow\n"
"        idle: 43.187747001648\n"
"        lag: 0\n"
"      downstream:\n"
"     vclock: {1: 31}\n"
"    3:\n"
"      id: 3\n"
"      uuid: e38ef895-5804-43b9-81ac-9f2cd872b9c4\n"
"      lsn: 54\n"
"      upstream:\n"
"        status: follow\n"
"        idle: 43.187621831894\n"
"        lag: 2\n"
"      downstream:\n"
"        vclock: {1: 54}\n"
"..."
msgstr ""

#: ../doc/1.7/book/replication/repl_monitoring.rst:75
msgid ""
"This report is for a master-master replica set of three instances, each having "
"its own instance id, UUID and log sequence number."
msgstr ""

#: ../doc/1.7/book/replication/repl_monitoring.rst:81
msgid ""
"The request was issued at master #1, and the reply includes statistics for the "
"other two masters, given in regard to master #1."
msgstr ""

#: ../doc/1.7/book/replication/repl_monitoring.rst:84
msgid ""
"The primary indicators of replication health are ``idle`` and ``lag`` parameters "
"(see reference on :ref:`box.info.replication <box_info_replication>` for "
"details)."
msgstr ""

#: ../doc/1.7/book/replication/repl_recover.rst:39
msgid "Recovering from a degraded state"
msgstr "Восстановление после сбоя"

#: ../doc/1.7/book/replication/repl_recover.rst:41
msgid ""
"\"Degraded state\" is a situation when the master becomes unavailable -- due to "
"hardware or network failure, or due to a programming bug."
msgstr ""

#: ../doc/1.7/book/replication/repl_recover.rst:47
msgid ""
"In a master-replica set, if a master disappears, error messages appear on the "
"replicas stating that the connection is lost:"
msgstr ""

#: ../doc/1.7/book/replication/repl_recover.rst:50
msgid ""
"$ # messages from a replica's log\n"
"2017-06-14 16:23:10.993 [19153] main/105/applier/replicator@192.168.0. I> can't "
"read row\n"
"2017-06-14 16:23:10.993 [19153] main/105/applier/replicator@192.168.0. coio."
"cc:349 !> SystemError\n"
"unexpected EOF when reading from socket, called on fd 17, aka "
"192.168.0.101:57815,\n"
"peer of 192.168.0.101:3301: Broken pipe\n"
"2017-06-14 16:23:10.993 [19153] main/105/applier/replicator@192.168.0. I> will "
"retry every 1 second\n"
"2017-06-14 16:23:10.993 [19153] relay/[::ffff:192.168.0.101]:/101/main I> the "
"replica has closed its socket, exiting\n"
"2017-06-14 16:23:10.993 [19153] relay/[::ffff:192.168.0.101]:/101/main C> "
"exiting the relay loop"
msgstr ""

#: ../doc/1.7/book/replication/repl_recover.rst:61
msgid "... and the master's status is reported as \"disconnected\":"
msgstr ""

#: ../doc/1.7/book/replication/repl_recover.rst:63
msgid ""
"# report from replica #1\n"
"tarantool> box.info.replication\n"
"---\n"
"- 1:\n"
"    id: 1\n"
"    uuid: 70e8e9dc-e38d-4046-99e5-d25419267229\n"
"    lsn: 542\n"
"    upstream:\n"
"      status: disconnected\n"
"      idle: 182.36929893494\n"
"      message: connect, called on fd 13, aka 192.168.0.101:58244\n"
"      lag: 0.00026607513427734\n"
"  2:\n"
"    id: 2\n"
"    uuid: fb252ac7-5c34-4459-84d0-54d248b8c87e\n"
"    lsn: 0\n"
"  3:\n"
"    id: 3\n"
"    uuid: fd7681d8-255f-4237-b8bb-c4fb9d99024d\n"
"    lsn: 0\n"
"    downstream:\n"
"      vclock: {1: 542}\n"
"..."
msgstr ""

#: ../doc/1.7/book/replication/repl_recover.rst:89
msgid ""
"# report from replica #2\n"
"box.info.replication\n"
"---\n"
"- 1:\n"
"    id: 1\n"
"    uuid: 70e8e9dc-e38d-4046-99e5-d25419267229\n"
"    lsn: 542\n"
"    upstream:\n"
"      status: disconnected\n"
"      idle: 186.76988101006\n"
"      message: connect, called on fd 13, aka 192.168.0.101:58253\n"
"      lag: 0.00027203559875488\n"
"  2:\n"
"    id: 2\n"
"    uuid: fb252ac7-5c34-4459-84d0-54d248b8c87e\n"
"    lsn: 0\n"
"    upstream:\n"
"      status: follow\n"
"      idle: 186.76960110664\n"
"      lag: 0.00020599365234375\n"
"  3:\n"
"    id: 3\n"
"    uuid: fd7681d8-255f-4237-b8bb-c4fb9d99024d\n"
"    lsn: 0\n"
"..."
msgstr ""

#: ../doc/1.7/book/replication/repl_recover.rst:117
msgid "To declare that one of the replicas must now take over as a new master:"
msgstr ""

#: ../doc/1.7/book/replication/repl_recover.rst:119
msgid "Make sure that the old master is gone for good:"
msgstr ""

#: ../doc/1.7/book/replication/repl_recover.rst:121
msgid ""
"change network routing rules to avoid any more packets being delivered to the "
"master, or"
msgstr ""

#: ../doc/1.7/book/replication/repl_recover.rst:123
msgid "shut down the master instance, if you have access to the machine, or"
msgstr ""

#: ../doc/1.7/book/replication/repl_recover.rst:124
msgid "power off the container or the machine."
msgstr ""

#: ../doc/1.7/book/replication/repl_recover.rst:126
msgid ""
"Say ``box.cfg{read_only=false, listen=URI}`` on the replica, and ``box."
"cfg{replication=URI}`` on the other replicas in the set."
msgstr ""

#: ../doc/1.7/book/replication/repl_recover.rst:131
msgid ""
"If there are updates on the old master that were not propagated before the old "
"master went down, :ref:`re-apply them manually <admin-disaster_recovery-"
"master_replica>` to the new master using ``tarantoolctl cat`` and ``tarantoolctl "
"play`` commands."
msgstr ""

#: ../doc/1.7/book/replication/repl_recover.rst:136
#, fuzzy
msgid ""
"There is no automatic way for a replica to detect that the master is gone "
"forever, since sources of failure and replication environments vary "
"significantly. So the detection of degraded state requires an external observer."
msgstr ""
"\"Сбой\" — это ситуация, когда главный сервер становится недоступен вследствие "
"проблем с оборудованием, сетевых неполадок или программной ошибки. У реплики нет "
"способа автоматически обнаружить, что связь с главным сервером утеряна насовсем, "
"поскольку причины сбоя и окружение, в котором развернута репликация, могут быть "
"очень разными. Поэтому обнаруживать сбой должен человек."

#: ../doc/1.7/book/replication/repl_remove_instances.rst:39
#, fuzzy
msgid "Removing instances"
msgstr "Создание экземпляров"

#: ../doc/1.7/book/replication/repl_remove_instances.rst:41
msgid "To politely remove an instance from a replica set, follow these steps:"
msgstr ""

#: ../doc/1.7/book/replication/repl_remove_instances.rst:43
msgid "On the instance, run ``box.cfg{}`` with a blank replication source:"
msgstr ""

#: ../doc/1.7/book/replication/repl_remove_instances.rst:45
#, fuzzy
msgid ""
"tarantool> box.cfg{replication=''}\n"
"---\n"
"..."
msgstr "tarantool> box.cfg{listen = 3301}"

#: ../doc/1.7/book/replication/repl_remove_instances.rst:51
#, fuzzy
msgid ""
"The other instances in the replica set will carry on. If later the removed "
"instance rejoins, it will receive all the updates that the other instances made "
"while it was away."
msgstr ""
"Вопрос: Что если какой-то сервер вдруг выбывает из кластера? |br| Ответ: "
"Остальные сервера продолжают работать. Если выбывший сервер снова возвращается в "
"кластер, то он получит информацию о всех изменениях, которые произошли на "
"остальных серверах за время его отсутствия."

#: ../doc/1.7/book/replication/repl_remove_instances.rst:55
msgid ""
"If the instance is decommissioned forever, delete the instance's record from the "
"following locations:"
msgstr ""

#: ../doc/1.7/book/replication/repl_remove_instances.rst:58
msgid ""
":ref:`replication <cfg_replication-replication>` parameter at all running "
"instances in the replica set:"
msgstr ""

#: ../doc/1.7/book/replication/repl_remove_instances.rst:61
#, fuzzy
msgid "tarantool> box.cfg{replication=...}"
msgstr "tarantool> box.cfg{listen = 3301}"

#: ../doc/1.7/book/replication/repl_remove_instances.rst:65
msgid ""
":ref:`box.space._cluster <box_space-cluster>` on any master instance in the "
"replica set. For example, a record with instance id = 3:"
msgstr ""

#: ../doc/1.7/book/replication/repl_remove_instances.rst:68
msgid ""
"tarantool> box.space._cluster:select{}\n"
"---\n"
"- - [1, '913f99c8-aee3-47f2-b414-53ed0ec5bf27']\n"
"  - [2, 'eac1aee7-cfeb-46cc-8503-3f8eb4c7de1e']\n"
"  - [3, '97f2d65f-2e03-4dc8-8df3-2469bd9ce61e']\n"
"...\n"
"tarantool> box.space._cluster:delete(3)\n"
"---\n"
"- [3, '97f2d65f-2e03-4dc8-8df3-2469bd9ce61e']\n"
"..."
msgstr ""

#: ../doc/1.7/book/replication/repl_reseed.rst:39
#, fuzzy
msgid "Reseeding a replica"
msgstr "Настройка сервера-реплики"

#: ../doc/1.7/book/replication/repl_reseed.rst:41
msgid ""
"If any of a replica's .xlog/.snap/.run files are corrupted or deleted, you can "
"\"re-seed\" the replica:"
msgstr ""

#: ../doc/1.7/book/replication/repl_reseed.rst:44
msgid ""
"Stop the replica and destroy all local database files (the ones with extensions ."
"xlog/.snap/.run/.inprogress)."
msgstr ""

#: ../doc/1.7/book/replication/repl_reseed.rst:47
msgid "Delete the replica's record from the following locations:"
msgstr ""

#: ../doc/1.7/book/replication/repl_reseed.rst:49
msgid "``replication`` parameter at all running instances in the replica set."
msgstr ""

#: ../doc/1.7/book/replication/repl_reseed.rst:50
msgid "``box.space._cluster`` on the master instance."
msgstr ""

#: ../doc/1.7/book/replication/repl_reseed.rst:52
msgid ""
"See section :ref:`Removing instances <replication-remove_instances>` for details."
msgstr ""

#: ../doc/1.7/book/replication/repl_reseed.rst:55
msgid ""
"Restart the replica with the same instance file to contact the master again. The "
"replica will then catch up with the master by retrieving all the master’s tuples."
msgstr ""

#: ../doc/1.7/book/replication/repl_reseed.rst:61
msgid ""
"Remember that this procedure works only if the master’s WAL files are present."
msgstr ""

#: ../doc/1.7/dev_guide/build_contribute_index.rst:37
msgid "Build and contribute"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:39
msgid "Building documentation"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:41
msgid ""
"Tarantool documentation is built using a simplified markup system named "
"``Sphinx`` (see http://sphinx-doc.org). You can build a local version of this "
"documentation and you can contribute to Tarantool's version."
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:45
msgid "You need to install these packages:"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:47
msgid "``git`` (a program for downloading source repositories)"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:48
msgid "``CMake`` version 2.8 or later (a program for managing the build process)"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:49
msgid ""
"``Python`` version greater than 2.6 -- preferably 2.7 -- and less than 3.0 "
"(Sphinx is a Python-based tool)"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:51
msgid ""
"``LaTeX`` (a system for document preparation, the installable package name "
"usually begins with the word texlive or tetex, on Ubuntu the name is texlive-"
"latex-base)"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:55
msgid "You need to install these Python modules:"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:57
msgid "`pip <https://pypi.python.org/pypi/pip>`_, any version"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:58
msgid "`Sphinx <https://pypi.python.org/pypi/Sphinx>`_ version 1.4.4 or later"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:59
msgid "`sphinx-intl <https://pypi.python.org/pypi/sphinx-intl>`_ version 0.9.9"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:60
msgid "`lupa <https://pypi.python.org/pypi/lupa>`_ -- any version"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:62
msgid ""
"See more details about installation in the :ref:`build-from-source "
"<building_from_source>` section of this documentation."
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:65
msgid ""
"Use ``git`` to download the latest source code of this documentation from the "
"GitHub repository ``tarantool/doc``, branch 1.7. For example, to download to a "
"local directory named ``~/tarantool-doc``:"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:69
msgid "git clone https://github.com/tarantool/doc.git ~/tarantool-doc"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:73
msgid "Use ``CMake`` to initiate the build."
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:75
msgid ""
"cd ~/tarantool-doc\n"
"make clean         # unnecessary, added for good luck\n"
"rm CMakeCache.txt  # unnecessary, added for good luck\n"
"cmake .            # initiate"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:82
#, fuzzy
msgid "Build a local version of the documentation."
msgstr "Как пользоваться документацией"

#: ../doc/1.7/dev_guide/building_documentation.rst:84
msgid ""
"Run the ``make`` command with an appropriate option to specify which "
"documentation version to build."
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:87
msgid ""
"cd ~/tarantool-doc\n"
"make sphinx-html           # multi-page English version\n"
"make sphinx-singlehtml     # one-page English version\n"
"make sphinx-html-ru        # multi-page Russian version\n"
"make sphinx-singlehtml-ru  # one-page Russian version\n"
"make all                   # all versions plus the entire web-site"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:96
msgid "Documentation will be created in subdirectories of ``/output``:"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:98
msgid "``/output/en`` (files of the English version)"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:99
msgid "``/output/ru`` (files of the Russian version)"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:101
msgid ""
"The entry point for each version is the ``index.html`` file in the appropriate "
"directory."
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:104
msgid "Set up a web-server."
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:106
msgid ""
"Run the following command to set up a web-server. The example below is for "
"Ubuntu, but the procedure is similar for other supported operating systems. Make "
"sure to run it from the documentation output folder, ``output/en`` or ``output/"
"ru``, as in the example below:"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:111
msgid ""
"cd ~/tarantool-doc/output/en\n"
"python -m SimpleHTTPServer 8000"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:116
msgid ""
"Open your browser and enter ``127.0.0.1:8000/doc/1.7`` into the address box. If "
"your local documentation build is valid, the manual will appear in the browser."
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:119
msgid ""
"To contribute to documentation, use the ``.rst`` format for drafting and submit "
"your updates as a `pull request <https://help.github.com/articles/creating-a-"
"pull-request/>`_ via GitHub."
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:124
msgid ""
"To comply with the writing and formatting style, use the :ref:`guidelines "
"<documentation_guidelines>` provided in the documentation, common sense and "
"existing documents."
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:130
msgid ""
"If you suggest creating a new documentation section (a whole new page), it has "
"to be saved to the relevant section at GitHub."
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:133
msgid ""
"If you want to contribute to localizing this documentation (for example into "
"Russian), add your translation strings to ``.po`` files stored in the "
"corresponding locale directory (for example ``/locale/ru/LC_MESSAGES/`` for "
"Russian). See more about localizing with Sphinx at http://www.sphinx-doc.org/en/"
"stable/intl.html"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:39
msgid "Building from source"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:41
msgid ""
"For downloading Tarantool source and building it, the platforms can differ and "
"the preferences can differ. But strategically the steps are always the same."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:44
msgid "Get tools and libraries that will be necessary for building and testing."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:47
msgid "The absolutely necessary ones are:"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:49
msgid ""
"A program for downloading source repositories. |br| For all platforms, this is "
"``git``. It allows downloading the latest complete set of source files from the "
"Tarantool repository on GitHub."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:53
msgid ""
"A C/C++ compiler. |br| Ordinarily, this is ``gcc`` and ``g++`` version 4.6 or "
"later. On Mac OS X, this is ``Clang`` version 3.2+."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:56
msgid ""
"A program for managing the build process. |br| For all platforms, this is "
"``CMake`` version 2.8+."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:59
msgid "`ReadLine <http://www.gnu.org/software/readline/>`_ library, any version"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:60
msgid "`ncurses <https://www.gnu.org/software/ncurses/>`_ library, any version"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:61
msgid "`OpenSSL <https://www.openssl.org>`_ library, version 1.0.1+"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:62
msgid "`cURL <https://curl.haxx.se/>`_ library, version 0.725+"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:63
msgid "`LibYAML <http://pyyaml.org/wiki/LibYAML>`_ library, version 0.1.4+"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:65
msgid ""
"Python and modules. |br| Python interpreter is not necessary for building "
"Tarantool itself, unless you intend to use the \"Run the test suite\" option in "
"step 5. For all platforms, this is ``python`` version 2.7+ (but not 3.x). You "
"need the following Python modules:"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:70
msgid "`pyyaml <https://pypi.python.org/pypi/PyYAML>`_ version 3.10"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:71
msgid "`argparse <https://pypi.python.org/pypi/argparse>`_ version 1.1"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:72
msgid ""
"`msgpack-python <https://pypi.python.org/pypi/msgpack-python>`_ version 0.4.6"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:73
msgid "`gevent <https://pypi.python.org/pypi/gevent>`_ version 1.1.2"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:74
msgid "`six <https://pypi.python.org/pypi/six>`_ version 1.8.0"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:76
msgid "To install all required dependencies, follow the instructions for your OS:"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:78
msgid "For Debian/Ubuntu, say:"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:80
msgid ""
"$ apt install -y build-essential cmake coreutils sed \\\n"
"      libreadline-dev libncurses5-dev libyaml-dev libssl-dev \\\n"
"      libcurl4-openssl-dev libunwind-dev \\\n"
"      python python-pip python-setuptools python-dev \\\n"
"      python-msgpack python-yaml python-argparse python-six python-gevent"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:88
msgid "For RHEL/CentOS/Fedora, say:"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:90
msgid ""
"$ yum install -y gcc gcc-c++ cmake coreutils sed \\\n"
"      readline-devel ncurses-devel libyaml-devel openssl-devel \\\n"
"      libcurl-devel libunwind-devel \\\n"
"      python python-pip python-setuptools python-devel \\\n"
"      python-msgpack python-yaml python-argparse python-six python-gevent"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:98
msgid "For Mac OS X (instructions below are for OS X El Capitan):"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:100
msgid "If you're using Homebrew as your package manager, say:"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:102
msgid ""
"$ brew install cmake autoconf binutils zlib \\\n"
"       readline ncurses libyaml openssl curl libunwind-headers \\\n"
"       && pip install python-daemon \\\n"
"       msgpack-python pyyaml configargparse six gevent"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:109
msgid "Alternatively, download Apple's default Xcode toolset:"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:111
msgid ""
"$ xcode-select --install\n"
"$ xcode-select -switch /Applications/Xcode.app/Contents/Developer"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:116
msgid "For FreeBSD (instructions below are for FreeBSD 10.1 release), say:"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:118
msgid ""
"$ pkg install -y sudo git cmake gmake gcc coreutils \\\n"
"      readline ncurses libyaml openssl curl libunwind \\\n"
"      python27 py27-pip py27-setuptools py27-daemon \\\n"
"      py27-msgpack-python py27-yaml py27-argparse py27-six py27-gevent"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:125
msgid ""
"If some Python modules are not available in a repository, it is best to set up "
"the modules by getting a tarball and doing the setup with ``python setup.py`` "
"like this:"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:129
msgid ""
"# On some machines, this initial command may be necessary:\n"
"$ wget https://bootstrap.pypa.io/ez_setup.py -O - | sudo python\n"
"\n"
"# Python module for parsing YAML (pyYAML), for test suite:\n"
"# (If wget fails, check at http://pyyaml.org/wiki/PyYAML\n"
"# what the current version is.)\n"
"$ cd ~\n"
"$ wget http://pyyaml.org/download/pyyaml/PyYAML-3.10.tar.gz\n"
"$ tar -xzf PyYAML-3.10.tar.gz\n"
"$ cd PyYAML-3.10\n"
"$ sudo python setup.py install"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:143
msgid ""
"Finally, use Python ``pip`` to bring in Python packages that may not be up-to-"
"date in the distro repositories. (On CentOS 7, it will be necessary to install "
"``pip`` first, with :code:`sudo yum install epel-release` followed by :code:"
"`sudo yum install python-pip`.)"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:149
msgid ""
"$ pip install -r \\\n"
"      https://raw.githubusercontent.com/tarantool/test-run/master/requirements."
"txt \\\n"
"      --user"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:155
msgid "This step is only necessary once, the first time you do a download."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:157
msgid ""
"Use ``git`` to download the latest Tarantool source code from the GitHub "
"repository ``tarantool/tarantool``, branch 1.7, to a local directory named ``~/"
"tarantool``, for example:"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:161
#, fuzzy
msgid ""
"$ git clone --recursive https://github.com/tarantool/tarantool.git -b 1.7 ~/"
"tarantool"
msgstr "См. http://github.com/tarantool/tarantool-java/."

#: ../doc/1.7/dev_guide/building_from_source.rst:165
msgid ""
"On rare occasions, the submodules need to be updated again with the command:"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:168
msgid "$ git submodule update --init --recursive"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:172
msgid "Use CMake to initiate the build."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:174
msgid ""
"$ cd ~/tarantool\n"
"$ make clean         # unnecessary, added for good luck\n"
"$ rm CMakeCache.txt  # unnecessary, added for good luck\n"
"$ cmake .            # start initiating with build type=Debug"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:181
msgid ""
"On some platforms, it may be necessary to specify the C and C++ versions, for "
"example:"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:184
msgid "$ CC=gcc-4.8 CXX=g++-4.8 cmake ."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:188
msgid ""
"The CMake option for specifying build type is :samp:`-DCMAKE_BUILD_TYPE={type}`, "
"where :samp:`{type}` can be:"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:191
msgid "``Debug`` -- used by project maintainers"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:192
msgid "``Release`` -- used only if the highest performance is required"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:193
msgid ""
"``RelWithDebInfo`` -- used for production, also provides debugging capabilities"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:195
msgid ""
"The CMake option for hinting that the result will be distributed is :code:`-"
"DENABLE_DIST=ON`. If this option is on, then later ``make install`` will install "
"``tarantoolctl`` files in addition to ``tarantool`` files."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:199
msgid "Use ``make`` to complete the build."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:201
msgid "$ make"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:207
msgid "For FreeBSD, use ``gmake`` instead."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:209
msgid "This creates the 'tarantool' executable in the ``src/`` directory."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:211
msgid ""
"Next, it's highly recommended to say ``make install`` to install Tarantool to "
"the ``/usr/local`` directory and keep your system clean. However, it is possible "
"to run the Tarantool executable without installation."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:215
msgid "Run the test suite."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:217
msgid ""
"This step is optional. Tarantool's developers always run the test suite before "
"they publish new versions. You should run the test suite too, if you make any "
"changes in the code. Assuming you downloaded to ``~/tarantool``, the principal "
"steps are:"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:222
msgid ""
"# make a subdirectory named `bin`\n"
"$ mkdir ~/tarantool/bin\n"
"\n"
"# link Python to bin (this may require superuser privileges)\n"
"$ ln /usr/bin/python ~/tarantool/bin/python\n"
"\n"
"# get to the test subdirectory\n"
"$ cd ~/tarantool/test\n"
"\n"
"# run tests using Python\n"
"$ PATH=~/tarantool/bin:$PATH ./test-run.py"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:236
msgid "The output should contain reassuring reports, for example:"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:238
msgid ""
"======================================================================\n"
"TEST                                            RESULT\n"
"------------------------------------------------------------\n"
"box/bad_trigger.test.py                         [ pass ]\n"
"box/call.test.py                                [ pass ]\n"
"box/iproto.test.py                              [ pass ]\n"
"box/xlog.test.py                                [ pass ]\n"
"box/admin.test.lua                              [ pass ]\n"
"box/auth_access.test.lua                        [ pass ]\n"
"... etc."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:251
msgid "To prevent later confusion, clean up what's in the ``bin`` subdirectory:"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:253
msgid ""
"$ rm ~/tarantool/bin/python\n"
"$ rmdir ~/tarantool/bin"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:258
msgid "Make RPM and Debian packages."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:260
msgid ""
"This step is optional. It's only for people who want to redistribute Tarantool. "
"We highly recommend to use official packages from the `tarantool.org <https://"
"tarantool.org/download.html>`_ web-site. However, you can build RPM and Debian "
"packages using `PackPack <https://github.com/packpack/packpack>`_ or using the "
"``dpkg-buildpackage`` or ``rpmbuild`` tools. Please consult ``dpkg`` or "
"``rpmbuild`` documentation for details."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:268
msgid "Verify your Tarantool installation."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:270
msgid ""
"# if you installed tarantool locally after build\n"
"$ tarantool\n"
"# - OR -\n"
"# if you didn't install tarantool locally after build\n"
"$ ./src/tarantool"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:278
msgid "This starts Tarantool in the interactive mode."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:280
msgid "See also:"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:282
#, fuzzy
msgid ""
"`Tarantool README.md <https://github.com/tarantool/tarantool/blob/1.7/README."
"md>`_"
msgstr "См. http://github.com/tarantool/tarantool-java/."

#: ../doc/1.7/dev_guide/c_style_guide.rst:37
msgid "C Style Guide"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:39
msgid ""
"The project's coding style is based on a version of the Linux kernel coding "
"style."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:41
msgid ""
"The latest version of the Linux style can be found at: http://www.kernel.org/doc/"
"Documentation/CodingStyle"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:44
msgid ""
"Since it is open for changes, the version of style that we follow, one from 2007-"
"July-13, will be also copied later in this document."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:47
msgid ""
"There are a few additional guidelines, either unique to Tarantool or deviating "
"from the Kernel guidelines."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:50
msgid ""
"Chapters 10 \"Kconfig configuration files\", 11 \"Data structures\", 13 "
"\"Printing kernel messages\", 14 \"Allocating memory\" and 17 \"Don't re-invent "
"the kernel macros\" do not apply, since they are specific to Linux kernel "
"programming environment."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:55
msgid "The rest of Linux Kernel Coding Style is amended as follows:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:59
msgid "General guidelines"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:61
msgid ""
"We use Git for revision control. The latest development is happening in the "
"'master' branch. Our git repository is hosted on github, and can be checked out "
"with git clone git://github.com/tarantool/tarantool.git # anonymous read-only "
"access"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:65
msgid ""
"If you have any questions about Tarantool internals, please post them on the "
"developer discussion list, https://groups.google.com/forum/#!forum/tarantool. "
"However, please be warned: Launchpad silently deletes posts from non-subscribed "
"members, thus please be sure to have subscribed to the list prior to posting. "
"Additionally, some engineers are always present on #tarantool channel on irc."
"freenode.net."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:73
msgid "Commenting style"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:75
msgid ""
"Use Doxygen comment format, Javadoc flavor, i.e. `@tag` rather than `\\tag`. The "
"main tags in use are @param, @retval, @return, @see, @note and @todo."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:78
msgid ""
"Every function, except perhaps a very short and obvious one, should have a "
"comment. A sample function comment may look like below:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:81
msgid ""
"/** Write all data to a descriptor.\n"
" *\n"
" * This function is equivalent to 'write', except it would ensure\n"
" * that all data is written to the file unless a non-ignorable\n"
" * error occurs.\n"
" *\n"
" * @retval 0  Success\n"
" *\n"
" * @reval  1  An error occurred (not EINTR)\n"
" * /\n"
"static int\n"
"write_all(int fd, void \\*data, size_t len);"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:96
msgid ""
"Public structures and important structure members should be commented as well."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:100
msgid "Header files"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:102
msgid ""
"Use header guards. Put the header guard in the first line in the header, before "
"the copyright or declarations. Use all-uppercase name for the header guard. "
"Derive the header guard name from the file name, and append _INCLUDED to get a "
"macro name. For example, core/log_io.h -> CORE_LOG_IO_H_INCLUDED. In ``.c`` "
"(implementation) file, include the respective declaration header before all "
"other headers, to ensure that the header is self- sufficient. Header \"header.h"
"\" is self-sufficient if the following compiles without errors:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:110
msgid "#include \"header.h\""
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:116
msgid "Allocating memory"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:118
msgid ""
"Prefer the supplied slab (salloc) and pool (palloc) allocators to malloc()/"
"free() for any performance-intensive or large  memory allocations. Repetitive "
"use of malloc()/free() can lead to memory fragmentation and should therefore be "
"avoided."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:122
msgid ""
"Always free all allocated memory, even allocated  at start-up. We aim at being "
"valgrind leak-check clean, and in most cases it's just as easy to free() the "
"allocated memory as it is to write a valgrind suppression. Freeing all allocated "
"memory is also dynamic-load friendly: assuming a plug-in can be dynamically "
"loaded and unloaded multiple times, reload should not lead to a memory leak."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:130
msgid "Other"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:132
msgid ""
"Select GNU C99 extensions are acceptable. It's OK to mix declarations and "
"statements, use true and false."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:135
msgid ""
"The not-so-current list of all GCC C extensions can be found at: http://gcc.gnu."
"org/onlinedocs/gcc-4.3.5/gcc/C-Extensions.html"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:140
msgid "Linux kernel coding style"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:142
msgid ""
"This is a short document describing the preferred coding style for the linux "
"kernel.  Coding style is very personal, and I won't _force_ my views on anybody, "
"but this is what goes for anything that I have to be able to maintain, and I'd "
"prefer it for most other things too.  Please at least consider the points made "
"here."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:148
msgid ""
"First off, I'd suggest printing out a copy of the GNU coding standards, and NOT "
"read it.  Burn them, it's a great symbolic gesture."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:151
msgid "Anyway, here goes:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:155
msgid "Chapter 1: Indentation"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:157
msgid ""
"Tabs are 8 characters, and thus indentations are also 8 characters. There are "
"heretic movements that try to make indentations 4 (or even 2!) characters deep, "
"and that is akin to trying to define the value of PI to be 3."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:162
msgid ""
"Rationale: The whole idea behind indentation is to clearly define where a block "
"of control starts and ends.  Especially when you've been looking at your screen "
"for 20 straight hours, you'll find it a lot easier to see how the indentation "
"works if you have large indentations."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:167
msgid ""
"Now, some people will claim that having 8-character indentations makes the code "
"move too far to the right, and makes it hard to read on a 80-character terminal "
"screen.  The answer to that is that if you need more than 3 levels of "
"indentation, you're screwed anyway, and should fix your program."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:173
msgid ""
"In short, 8-char indents make things easier to read, and have the added benefit "
"of warning you when you're nesting your functions too deep. Heed that warning."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:177
msgid ""
"The preferred way to ease multiple indentation levels in a switch statement is "
"to align the \"switch\" and its subordinate \"case\" labels in the same column "
"instead of \"double-indenting\" the \"case\" labels. e.g.:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:181
msgid ""
"switch (suffix) {\n"
"case 'G':\n"
"case 'g':\n"
"    mem <<= 30;\n"
"    break;\n"
"case 'M':\n"
"case 'm':\n"
"    mem <<= 20;\n"
"    break;\n"
"case 'K':\n"
"case 'k':\n"
"    mem <<= 10;\n"
"    /* fall through */\n"
"default:\n"
"    break;\n"
"}"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:201
msgid ""
"Don't put multiple statements on a single line unless you have something to hide:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:204
msgid ""
"if (condition) do_this;\n"
"  do_something_everytime;"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:209
msgid ""
"Don't put multiple assignments on a single line either. Kernel coding style is "
"super simple. Avoid tricky expressions."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:212
msgid ""
"Outside of comments, documentation and except in Kconfig, spaces are never used "
"for indentation, and the above example is deliberately broken."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:215
msgid "Get a decent editor and don't leave whitespace at the end of lines."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:220
msgid "Chapter 2: Breaking long lines and strings"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:222
msgid ""
"Coding style is all about readability and maintainability using commonly "
"available tools."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:225
msgid ""
"The limit on the length of lines is 80 columns and this is a strongly preferred "
"limit."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:228
msgid ""
"Statements longer than 80 columns will be broken into sensible chunks. "
"Descendants are always substantially shorter than the parent and are placed "
"substantially to the right. The same applies to function headers with a long "
"argument list. Long strings are as well broken into shorter strings. The only "
"exception to this is where exceeding 80 columns significantly increases "
"readability and does not hide information."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:235
#, python-format
msgid ""
"void fun(int a, int b, int c)\n"
"{\n"
"    if (condition)\n"
"        printk(KERN_WARNING \"Warning this is a long printk with \"\n"
"                        \"3 parameters a: %u b: %u \"\n"
"                        \"c: %u \\n\", a, b, c);\n"
"    else\n"
"        next_statement;\n"
"}"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:249
msgid "Chapter 3: Placing Braces and Spaces"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:251
msgid ""
"The other issue that always comes up in C styling is the placement of braces.  "
"Unlike the indent size, there are few technical reasons to choose one placement "
"strategy over the other, but the preferred way, as shown to us by the prophets "
"Kernighan and Ritchie, is to put the opening brace last on the line, and put the "
"closing brace first, thusly:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:257
msgid ""
"if (x is true) {\n"
"    we do y\n"
"}"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:263
msgid ""
"This applies to all non-function statement blocks (if, switch, for, while, do). "
"e.g.:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:266
msgid ""
"switch (action) {\n"
"case KOBJ_ADD:\n"
"    return \"add\";\n"
"case KOBJ_REMOVE:\n"
"    return \"remove\";\n"
"case KOBJ_CHANGE:\n"
"    return \"change\";\n"
"default:\n"
"    return NULL;\n"
"}"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:279
msgid ""
"However, there is one special case, namely functions: they have the opening "
"brace at the beginning of the next line, thus:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:282
msgid ""
"int function(int x)\n"
"{\n"
"    body of function;\n"
"}"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:289
msgid ""
"Heretic people all over the world have claimed that this inconsistency is ...  "
"well ...  inconsistent, but all right-thinking people know that (a) K&R are "
"_right_ and (b) K&R are right.  Besides, functions are special anyway (you can't "
"nest them in C)."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:294
msgid ""
"Note that the closing brace is empty on a line of its own, _except_ in the cases "
"where it is followed by a continuation of the same statement, ie a \"while\" in "
"a do-statement or an \"else\" in an if-statement, like this:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:299
msgid ""
"do {\n"
"    body of do-loop;\n"
"} while (condition);"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:305
msgid "and"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:307
msgid ""
"if (x == y) {\n"
"    ..\n"
"} else if (x > y) {\n"
"    ...\n"
"} else {\n"
"    ....\n"
"}"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:317
msgid "Rationale: K&R."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:319
msgid ""
"Also, note that this brace-placement also minimizes the number of empty (or "
"almost empty) lines, without any loss of readability.  Thus, as the supply of "
"new-lines on your screen is not a renewable resource (think 25-line terminal "
"screens here), you have more empty lines to put comments on."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:325
msgid "Do not unnecessarily use braces where a single statement will do."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:327
msgid ""
"if (condition)\n"
"    action();"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:332
msgid ""
"This does not apply if one branch of a conditional statement is a single "
"statement. Use braces in both branches."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:335
msgid ""
"if (condition) {\n"
"    do_this();\n"
"    do_that();\n"
"} else {\n"
"    otherwise();\n"
"}"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:346
msgid "Chapter 3.1:  Spaces"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:348
msgid ""
"Linux kernel style for use of spaces depends (mostly) on function-versus-keyword "
"usage.  Use a space after (most) keywords.  The notable exceptions are sizeof, "
"typeof, alignof, and __attribute__, which look somewhat like functions (and are "
"usually used with parentheses in Linux, although they are not required in the "
"language, as in: \"sizeof info\" after \"struct fileinfo info;\" is declared)."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:355
msgid ""
"So use a space after these keywords: if, switch, case, for, do, while but not "
"with sizeof, typeof, alignof, or __attribute__.  E.g.,"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:358
msgid "s = sizeof(struct file);"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:362
msgid ""
"Do not add spaces around (inside) parenthesized expressions. This example is "
"**bad**:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:365
msgid "s = sizeof( struct file );"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:369
msgid ""
"When declaring pointer data or a function that returns a pointer type, the "
"preferred use of '*' is adjacent to the data name or function name and not "
"adjacent to the type name.  Examples:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:373
msgid ""
"char *linux_banner;\n"
"unsigned long long memparse(char *ptr, char **retptr);\n"
"char *match_strdup(substring_t *s);"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:379
msgid ""
"Use one space around (on each side of) most binary and ternary operators, such "
"as any of these:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:382
msgid "=  +  -  <  >  *  /  %  |  &  ^  <=  >=  ==  !=  ?  :"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:384
msgid "but no space after unary operators:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:386
msgid "&  *  +  -  ~  !  sizeof  typeof  alignof  __attribute__  defined"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:388
msgid "no space before the postfix increment & decrement unary operators:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:390
#: ../doc/1.7/dev_guide/c_style_guide.rst:394
msgid "++  --"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:392
msgid "no space after the prefix increment & decrement unary operators:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:396
msgid "and no space around the '.' and \"->\" structure member operators."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:398
msgid ""
"Do not leave trailing whitespace at the ends of lines.  Some editors with \"smart"
"\" indentation will insert whitespace at the beginning of new lines as "
"appropriate, so you can start typing the next line of code right away. However, "
"some such editors do not remove the whitespace if you end up not putting a line "
"of code there, such as if you leave a blank line.  As a result, you end up with "
"lines containing trailing whitespace."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:405
msgid ""
"Git will warn you about patches that introduce trailing whitespace, and can "
"optionally strip the trailing whitespace for you; however, if applying a series "
"of patches, this may make later patches in the series fail by changing their "
"context lines."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:413
msgid "Chapter 4: Naming"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:415
msgid ""
"C is a Spartan language, and so should your naming be.  Unlike Modula-2 and "
"Pascal programmers, C programmers do not use cute names like "
"ThisVariableIsATemporaryCounter.  A C programmer would call that variable \"tmp"
"\", which is much easier to write, and not the least more difficult to "
"understand."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:421
msgid ""
"HOWEVER, while mixed-case names are frowned upon, descriptive names for global "
"variables are a must.  To call a global function \"foo\" is a shooting offense."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:425
msgid ""
"GLOBAL variables (to be used only if you _really_ need them) need to have "
"descriptive names, as do global functions.  If you have a function that counts "
"the number of active users, you should call that \"count_active_users()\" or "
"similar, you should _not_ call it \"cntusr()\"."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:430
msgid ""
"Encoding the type of a function into the name (so-called Hungarian notation) is "
"brain damaged - the compiler knows the types anyway and can check those, and it "
"only confuses the programmer.  No wonder MicroSoft makes buggy programs."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:435
msgid ""
"LOCAL variable names should be short, and to the point.  If you have some random "
"integer loop counter, it should probably be called \"i\". Calling it "
"\"loop_counter\" is non-productive, if there is no chance of it being mis-"
"understood.  Similarly, \"tmp\" can be just about any type of variable that is "
"used to hold a temporary value."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:441
msgid ""
"If you are afraid to mix up your local variable names, you have another problem, "
"which is called the function-growth-hormone-imbalance syndrome. See chapter 6 "
"(Functions)."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:448
msgid "Chapter 5: Typedefs"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:450
msgid "Please don't use things like \"vps_t\"."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:452
msgid "It's a _mistake_ to use typedef for structures and pointers. When you see a"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:454
msgid "vps_t a;"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:458
msgid "in the source, what does it mean?"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:460
msgid "In contrast, if it says"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:462
msgid "struct virtual_container *a;"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:466
msgid "you can actually tell what \"a\" is."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:468
msgid ""
"Lots of people think that typedefs \"help readability\". Not so. They are useful "
"only for:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:471
msgid ""
"totally opaque objects (where the typedef is actively used to _hide_ what the "
"object is)."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:474
msgid ""
"Example: \"pte_t\" etc. opaque objects that you can only access using the proper "
"accessor functions."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:477
msgid ""
"NOTE! Opaqueness and \"accessor functions\" are not good in themselves. The "
"reason we have them for things like pte_t etc. is that there really is "
"absolutely _zero_ portably accessible information there."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:481
msgid ""
"Clear integer types, where the abstraction _helps_ avoid confusion whether it is "
"\"int\" or \"long\"."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:484
msgid ""
"u8/u16/u32 are perfectly fine typedefs, although they fit into category (d) "
"better than here."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:487
msgid ""
"NOTE! Again - there needs to be a _reason_ for this. If something is \"unsigned "
"long\", then there's no reason to do"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:490
msgid "typedef unsigned long myflags_t;"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:494
msgid ""
"but if there is a clear reason for why it under certain circumstances might be "
"an \"unsigned int\" and under other configurations might be \"unsigned long\", "
"then by all means go ahead and use a typedef."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:498
msgid "when you use sparse to literally create a _new_ type for type-checking."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:501
msgid ""
"New types which are identical to standard C99 types, in certain exceptional "
"circumstances."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:504
msgid ""
"Although it would only take a short amount of time for the eyes and brain to "
"become accustomed to the standard types like 'uint32_t', some people object to "
"their use anyway."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:508
msgid ""
"Therefore, the Linux-specific 'u8/u16/u32/u64' types and their signed "
"equivalents which are identical to standard types are permitted -- although they "
"are not mandatory in new code of your own."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:513
msgid ""
"When editing existing code which already uses one or the other set of types, you "
"should conform to the existing choices in that code."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:516
msgid "Types safe for use in userspace."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:518
msgid ""
"In certain structures which are visible to userspace, we cannot require C99 "
"types and cannot use the 'u32' form above. Thus, we use __u32 and similar types "
"in all structures which are shared with userspace."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:523
msgid ""
"Maybe there are other cases too, but the rule should basically be to NEVER EVER "
"use a typedef unless you can clearly match one of those rules."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:526
msgid ""
"In general, a pointer, or a struct that has elements that can reasonably be "
"directly accessed should **never** be a typedef."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:532
msgid "Chapter 6: Functions"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:534
msgid ""
"Functions should be short and sweet, and do just one thing.  They should fit on "
"one or two screenfuls of text (the ISO/ANSI screen size is 80x24, as we all "
"know), and do one thing and do that well."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:538
msgid ""
"The maximum length of a function is inversely proportional to the complexity and "
"indentation level of that function.  So, if you have a conceptually simple "
"function that is just one long (but simple) case-statement, where you have to do "
"lots of small things for a lot of different cases, it's OK to have a longer "
"function."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:544
msgid ""
"However, if you have a complex function, and you suspect that a less-than-gifted "
"first-year high-school student might not even understand what the function is "
"all about, you should adhere to the maximum limits all the more closely.  Use "
"helper functions with descriptive names (you can ask the compiler to in-line "
"them if you think it's performance-critical, and it will probably do a better "
"job of it than you would have done)."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:552
msgid ""
"Another measure of the function is the number of local variables.  They "
"shouldn't exceed 5-10, or you're doing something wrong.  Re-think the function, "
"and split it into smaller pieces.  A human brain can generally easily keep track "
"of about 7 different things, anything more and it gets confu/sed.  You know "
"you're brilliant, but maybe you'd like to understand what you did 2 weeks from "
"now."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:559
msgid ""
"In source files, separate functions with one blank line.  If the function is "
"exported, the EXPORT* macro for it should follow immediately after the closing "
"function brace line.  E.g.:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:563
msgid ""
"int system_is_up(void)\n"
"{\n"
"    return system_state == SYSTEM_RUNNING;\n"
"}\n"
"EXPORT_SYMBOL(system_is_up);"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:571
msgid ""
"In function prototypes, include parameter names with their data types. Although "
"this is not required by the C language, it is preferred in Linux because it is a "
"simple way to add valuable information for the reader."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:577
msgid "Chapter 7: Centralized exiting of functions"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:579
msgid ""
"Albeit deprecated by some people, the equivalent of the goto statement is used "
"frequently by compilers in form of the unconditional jump instruction."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:582
msgid ""
"The goto statement comes in handy when a function exits from multiple locations "
"and some common work such as cleanup has to be done."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:585
msgid "The rationale is:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:587
msgid "unconditional statements are easier to understand and follow"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:588
msgid "nesting is reduced"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:589
msgid ""
"errors by not updating individual exit points when making modifications are "
"prevented"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:591
msgid "saves the compiler work to optimize redundant code away ;)"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:593
msgid ""
"int fun(int a)\n"
"{\n"
"    int result = 0;\n"
"    char *buffer = kmalloc(SIZE);\n"
"\n"
"    if (buffer == NULL)\n"
"        return -ENOMEM;\n"
"\n"
"    if (condition1) {\n"
"        while (loop1) {\n"
"            ...\n"
"        }\n"
"        result = 1;\n"
"        goto out;\n"
"    }\n"
"    ...\n"
"out:\n"
"    kfree(buffer);\n"
"    return result;\n"
"}"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:618
msgid "Chapter 8: Commenting"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:620
msgid ""
"Comments are good, but there is also a danger of over-commenting. NEVER try to "
"explain HOW your code works in a comment: it's much better to write the code so "
"that the _working_ is obvious, and it's a waste of time to explain badly written "
"code. с Generally, you want your comments to tell WHAT your code does, not HOW. "
"Also, try to avoid putting comments inside a function body: if the function is "
"so complex that you need to separately comment parts of it, you should probably "
"go back to chapter 6 for a while.  You can make small comments to note or warn "
"about something particularly clever (or ugly), but try to avoid excess.  "
"Instead, put the comments at the head of the function, telling people what it "
"does, and possibly WHY it does it."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:634
msgid ""
"When commenting the kernel API functions, please use the kernel-doc format. See "
"the files Documentation/kernel-doc-nano-HOWTO.txt and scripts/kernel-doc for "
"details."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:638
msgid ""
"Linux style for comments is the C89 ``\"/\\* ... \\*/\"`` style. Don't use C99-"
"style ``\"// ...\"`` comments."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:641
msgid "The preferred style for long (multi-line) comments is:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:643
msgid ""
"/*\n"
" * This is the preferred style for multi-line\n"
" * comments in the Linux kernel source code.\n"
" * Please use it consistently.\n"
" *\n"
" * Description:  A column of asterisks on the left side,\n"
" * with beginning and ending almost-blank lines.\n"
" */"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:654
msgid ""
"It's also important to comment data, whether they are basic types or derived "
"types.  To this end, use just one data declaration per line (no commas for "
"multiple data declarations).  This leaves you room for a small comment on each "
"item, explaining its use."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:661
msgid "Chapter 9: You've made a mess of it"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:663
msgid ""
"That's OK, we all do.  You've probably been told by your long-time Unix user "
"helper that \"GNU emacs\" automatically formats the C sources for you, and "
"you've noticed that yes, it does do that, but the defaults it uses are less than "
"desirable (in fact, they are worse than random typing - an infinite number of "
"monkeys typing into GNU emacs would never make a good program)."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:670
msgid ""
"So, you can either get rid of GNU emacs, or change it to use saner values.  To "
"do the latter, you can stick the following in your .emacs file:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:673
msgid ""
"(defun c-lineup-arglist-tabs-only (ignored)\n"
"\"Line up argument lists by tabs, not spaces\"\n"
"(let* ((anchor (c-langelem-pos c-syntactic-element))\n"
"    (column (c-langelem-2nd-pos c-syntactic-element))\n"
"    (offset (- (1+ column) anchor))\n"
"    (steps (floor offset c-basic-offset)))\n"
"    (* (max steps 1)\n"
"    c-basic-offset)))\n"
"\n"
"(add-hook 'c-mode-common-hook\n"
"        (lambda ()\n"
"            ;; Add kernel style\n"
"            (c-add-style\n"
"            \"linux-tabs-only\"\n"
"            '(\"linux\" (c-offsets-alist\n"
"                        (arglist-cont-nonempty\n"
"                        c-lineup-gcc-asm-reg\n"
"                        c-lineup-arglist-tabs-only))))))\n"
"\n"
"(add-hook 'c-mode-hook\n"
"        (lambda ()\n"
"            (let ((filename (buffer-file-name)))\n"
"            ;; Enable kernel mode for the appropriate files\n"
"            (when (and filename\n"
"                        (string-match (expand-file-name \"~/src/linux-trees\")\n"
"                                    filename))\n"
"                (setq indent-tabs-mode t)\n"
"                (c-set-style \"linux-tabs-only\")))))"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:704
msgid ""
"This will make emacs go better with the kernel coding style for C files below ~/"
"src/linux-trees."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:707
msgid ""
"But even if you fail in getting emacs to do sane formatting, not everything is "
"lost: use \"indent\"."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:710
msgid ""
"Now, again, GNU indent has the same brain-dead settings that GNU emacs has, "
"which is why you need to give it a few command line options. However, that's not "
"too bad, because even the makers of GNU indent recognize the authority of K&R "
"(the GNU people aren't evil, they are just severely misguided in this matter), "
"so you just give indent the options \"-kr -i8\" (stands for \"K&R, 8 character "
"indents\"), or use \"scripts/Lindent\", which indents in the latest style."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:718
msgid ""
"\"indent\" has a lot of options, and especially when it comes to comment re-"
"formatting you may want to take a look at the man page.  But remember: \"indent"
"\" is not a fix for bad programming."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:725
msgid "Chapter 10: Kconfig configuration files"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:727
msgid ""
"For all of the Kconfig* configuration files throughout the source tree, the "
"indentation is somewhat different.  Lines under a \"config\" definition are "
"indented with one tab, while help text is indented an additional two spaces. "
"Example:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:732
msgid ""
"config AUDIT\n"
"    bool \"Auditing support\"\n"
"    depends on NET\n"
"    help\n"
"    Enable auditing infrastructure that can be used with another\n"
"    kernel subsystem, such as SELinux (which requires this for\n"
"    logging of avc messages output).  Does not do system-call\n"
"    auditing without CONFIG_AUDITSYSCALL."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:743
msgid ""
"Features that might still be considered unstable should be defined as dependent "
"on \"EXPERIMENTAL\":"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:746
msgid ""
"config SLUB\n"
"    depends on EXPERIMENTAL && !ARCH_USES_SLAB_PAGE_STRUCT\n"
"    bool \"SLUB (Unqueued Allocator)\"\n"
"    ..."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:753
msgid ""
"while seriously dangerous features (such as write support for certain "
"filesystems) should advertise this prominently in their prompt string:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:756
msgid ""
"config ADFS_FS_RW\n"
"    bool \"ADFS write support (DANGEROUS)\"\n"
"    depends on ADFS_FS\n"
"    ..."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:763
msgid ""
"For full documentation on the configuration files, see the file Documentation/"
"kbuild/kconfig-language.txt."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:769
msgid "Chapter 11: Data structures"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:771
msgid ""
"Data structures that have visibility outside the single-threaded environment "
"they are created and destroyed in should always have reference counts.  In the "
"kernel, garbage collection doesn't exist (and outside the kernel garbage "
"collection is slow and inefficient), which means that you absolutely _have_ to "
"reference count all your uses."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:777
msgid ""
"Reference counting means that you can avoid locking, and allows multiple users "
"to have access to the data structure in parallel - and not having to worry about "
"the structure suddenly going away from under them just because they slept or did "
"something else for a while."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:782
msgid ""
"Note that locking is _not_ a replacement for reference counting. Locking is used "
"to keep data structures coherent, while reference counting is a memory "
"management technique.  Usually both are needed, and they are not to be confused "
"with each other."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:787
msgid ""
"Many data structures can indeed have two levels of reference counting, when "
"there are users of different \"classes\".  The subclass count counts the number "
"of subclass users, and decrements the global count just once when the subclass "
"count goes to zero."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:792
msgid ""
"Examples of this kind of \"multi-level-reference-counting\" can be found in "
"memory management (\"struct mm_struct\": mm_users and mm_count), and in "
"filesystem code (\"struct super_block\": s_count and s_active)."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:796
msgid ""
"Remember: if another thread can find your data structure, and you don't have a "
"reference count on it, you almost certainly have a bug."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:801
msgid "Chapter 12: Macros, Enums and RTL"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:803
msgid "Names of macros defining constants and labels in enums are capitalized."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:805
msgid "#define CONSTANT 0x12345"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:809
msgid "Enums are preferred when defining several related constants."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:811
msgid ""
"CAPITALIZED macro names are appreciated but macros resembling functions may be "
"named in lower case."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:814
msgid "Generally, inline functions are preferable to macros resembling functions."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:816
msgid "Macros with multiple statements should be enclosed in a do - while block:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:818
msgid ""
"#define macrofun(a, b, c)   \\\n"
"    do {                    \\\n"
"        if (a == 5)         \\\n"
"            do_this(b, c);  \\\n"
"    } while (0)"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:826
msgid "Things to avoid when using macros:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:828
msgid "macros that affect control flow:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:830
msgid ""
"#define FOO(x)                  \\\n"
"    do {                        \\\n"
"        if (blah(x) < 0)        \\\n"
"            return -EBUGGERED;  \\\n"
"    } while(0)"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:838
msgid ""
"is a _very_ bad idea.  It looks like a function call but exits the \"calling\" "
"function; don't break the internal parsers of those who will read the code."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:841
msgid "macros that depend on having a local variable with a magic name:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:843
msgid "#define FOO(val) bar(index, val)"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:847
msgid ""
"might look like a good thing, but it's confusing as hell when one reads the code "
"and it's prone to breakage from seemingly innocent changes."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:850
msgid ""
"macros with arguments that are used as l-values: FOO(x) = y; will bite you if "
"somebody e.g. turns FOO into an inline function."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:853
msgid ""
"forgetting about precedence: macros defining constants using expressions must "
"enclose the expression in parentheses. Beware of similar issues with macros "
"using parameters."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:857
msgid ""
"#define CONSTANT 0x4000\n"
"#define CONSTEXP (CONSTANT | 3)"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:862
msgid ""
"The cpp manual deals with macros exhaustively. The gcc internals manual also "
"covers RTL which is used frequently with assembly language in the kernel."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:867
msgid "Chapter 13: Printing kernel messages"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:869
msgid ""
"Kernel developers like to be seen as literate. Do mind the spelling of kernel "
"messages to make a good impression. Do not use crippled words like \"dont\"; use "
"\"do not\" or \"don't\" instead.  Make the messages concise, clear, and "
"unambiguous."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:874
msgid "Kernel messages do not have to be terminated with a period."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:876
#, python-format
msgid "Printing numbers in parentheses (%d) adds no value and should be avoided."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:878
msgid ""
"There are a number of driver model diagnostic macros in <linux/device.h> which "
"you should use to make sure messages are matched to the right device and driver, "
"and are tagged with the right level:  dev_err(), dev_warn(), dev_info(), and so "
"forth.  For messages that aren't associated with a particular device, <linux/"
"kernel.h> defines pr_debug() and pr_info()."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:884
msgid ""
"Coming up with good debugging messages can be quite a challenge; and once you "
"have them, they can be a huge help for remote troubleshooting.  Such messages "
"should be compiled out when the DEBUG symbol is not defined (that is, by default "
"they are not included).  When you use dev_dbg() or pr_debug(), that's "
"automatic.  Many subsystems have Kconfig options to turn on -DDEBUG. A related "
"convention uses VERBOSE_DEBUG to add dev_vdbg() messages to the ones already "
"enabled by DEBUG."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:894
msgid "Chapter 14: Allocating memory"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:896
msgid ""
"The kernel provides the following general purpose memory allocators: kmalloc(), "
"kzalloc(), kcalloc(), and vmalloc().  Please refer to the API documentation for "
"further information about them."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:900
msgid "The preferred form for passing a size of a struct is the following:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:902
msgid "p = kmalloc(sizeof(*p), ...);"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:906
msgid ""
"The alternative form where struct name is spelled out hurts readability and "
"introduces an opportunity for a bug when the pointer variable type is changed "
"but the corresponding sizeof that is passed to a memory allocator is not."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:910
msgid ""
"Casting the return value which is a void pointer is redundant. The conversion "
"from void pointer to any other pointer type is guaranteed by the C programming "
"language."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:916
msgid "Chapter 15: The inline disease"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:918
msgid ""
"There appears to be a common misperception that gcc has a magic \"make me faster"
"\" speedup option called \"inline\". While the use of inlines can be appropriate "
"(for example as a means of replacing macros, see Chapter 12), it very often is "
"not. Abundant use of the inline keyword leads to a much bigger kernel, which in "
"turn slows the system as a whole down, due to a bigger icache footprint for the "
"CPU and simply because there is less memory available for the pagecache. Just "
"think about it; a pagecache miss causes a disk seek, which easily takes 5 "
"milliseconds. There are a LOT of cpu cycles that can go into these 5 "
"milliseconds."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:928
msgid ""
"A reasonable rule of thumb is to not put inline at functions that have more than "
"3 lines of code in them. An exception to this rule are the cases where a "
"parameter is known to be a compiletime constant, and as a result of this "
"constantness you *know* the compiler will be able to optimize most of your "
"function away at compile time. For a good example of this later case, see the "
"kmalloc() inline function."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:935
msgid ""
"Often people argue that adding inline to functions that are static and used only "
"once is always a win since there is no space tradeoff. While this is technically "
"correct, gcc is capable of inlining these automatically without help, and the "
"maintenance issue of removing the inline when a second user appears outweighs "
"the potential value of the hint that tells gcc to do something it would have "
"done anyway."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:944
msgid "Chapter 16: Function return values and names"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:946
msgid ""
"Functions can return values of many different kinds, and one of the most common "
"is a value indicating whether the function succeeded or failed.  Such a value "
"can be represented as an error-code integer (-Exxx = failure, 0 = success) or a "
"\"succeeded\" boolean (0 = failure, non-zero = success)."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:952
msgid ""
"Mixing up these two sorts of representations is a fertile source of difficult-to-"
"find bugs.  If the C language included a strong distinction between integers and "
"booleans then the compiler would find these mistakes for us... but it doesn't.  "
"To help prevent such bugs, always follow this convention:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:960
msgid ""
"If the name of a function is an action or an imperative command,\n"
"the function should return an error-code integer.  If the name\n"
"is a predicate, the function should return a \"succeeded\" boolean."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:964
msgid ""
"For example, \"add work\" is a command, and the add_work() function returns 0 "
"for success or -EBUSY for failure.  In the same way, \"PCI device present\" is a "
"predicate, and the pci_dev_present() function returns 1 if it succeeds in "
"finding a matching device or 0 if it doesn't."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:969
msgid ""
"All EXPORTed functions must respect this convention, and so should all public "
"functions.  Private (static) functions need not, but it is recommended that they "
"do."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:973
msgid ""
"Functions whose return value is the actual result of a computation, rather than "
"an indication of whether the computation succeeded, are not subject to this "
"rule.  Generally they indicate failure by returning some out-of-range result.  "
"Typical examples would be functions that return pointers; they use NULL or the "
"ERR_PTR mechanism to report failure."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:982
msgid "Chapter 17:  Don't re-invent the kernel macros"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:984
msgid ""
"The header file include/linux/kernel.h contains a number of macros that you "
"should use, rather than explicitly coding some variant of them yourself. For "
"example, if you need to calculate the length of an array, take advantage of the "
"macro"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:989
msgid "#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:993
msgid "Similarly, if you need to calculate the size of some structure member, use"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:995
msgid "#define FIELD_SIZEOF(t, f) (sizeof(((t*)0)->f))"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:999
msgid ""
"There are also min() and max() macros that do strict type checking if you need "
"them.  Feel free to peruse that header file to see what else is already defined "
"that you shouldn't reproduce in your code."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:1005
msgid "Chapter 18:  Editor modelines and other cruft"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:1007
msgid ""
"Some editors can interpret configuration information embedded in source files, "
"indicated with special markers.  For example, emacs interprets lines marked like "
"this:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:1011
msgid "-*- mode: c -*-"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:1015
msgid "Or like this:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:1017
msgid ""
"/*\n"
"Local Variables:\n"
"compile-command: \"gcc -DMAGIC_DEBUG_FLAG foo.c\"\n"
"End:\n"
"*/"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:1025
msgid "Vim interprets markers that look like this:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:1027
msgid "/* vim:set sw=8 noet */"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:1031
msgid ""
"Do not include any of these in source files.  People have their own personal "
"editor configurations, and your source files should not override them.  This "
"includes markers for indentation and mode configuration.  People may use their "
"own custom mode, or may have some other magic method for making indentation work "
"correctly."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:1039
msgid "Appendix I: References"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:1041
msgid ""
"`The C Programming Language, Second Edition <https://en.wikipedia.org/wiki/"
"The_C_Programming_Language>`_ by Brian W. Kernighan and Dennis M. Ritchie. |br| "
"Prentice Hall, Inc., 1988. |br| ISBN 0-13-110362-8 (paperback), 0-13-110370-9 "
"(hardback)."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:1046
msgid ""
"`The Practice of Programming <https://en.wikipedia.org/wiki/"
"The_Practice_of_Programming>`_ by Brian W. Kernighan and Rob Pike. |br| Addison-"
"Wesley, Inc., 1999. |br| ISBN 0-201-61586-X."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:1051
msgid ""
"`GNU manuals <http://www.gnu.org/manual/>`_ - where in compliance with K&R and "
"this text - for **cpp**, **gcc**, **gcc internals** and **indent**"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:1054
msgid ""
"`WG14 International standardization workgroup for the programming language C "
"<http://www.open-std.org/JTC1/SC22/WG14/>`_"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:1057
msgid ""
"`Kernel CodingStyle, by greg@kroah.com at OLS 2002 <http://www.kroah.com/linux/"
"talks/ols_2002_kernel_codingstyle_talk/html/>`_"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:37
msgid "Developer guidelines"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:43
msgid "How to work on a bug"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:45
msgid ""
"Any defect, even minor, if it changes the user-visible server behavior, needs a "
"bug report. Report a bug at http://github.com/tarantool/tarantool/issues."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:48
msgid ""
"When reporting a bug, try to come up with a test case right away. Set the "
"current maintenance milestone for the bug fix, and specify the series. Assign "
"the bug to yourself. Put the status to 'In progress' Once the patch is ready, "
"put the bug the bug to 'In review' and solicit a review for the fix."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:53
msgid ""
"Once there is a positive code review, push the patch and set the status to "
"'Closed'"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:55
msgid ""
"Patches for bugs should contain a reference to the respective Launchpad bug page "
"or at least bug id. Each patch should have a test, unless coming up with one is "
"difficult in the current framework, in which case QA should be alerted."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:59
msgid ""
"There are two things you need to do when your patch makes it into the master:"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:61
msgid "put the bug to 'fix committed',"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:62
msgid "delete the remote branch."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:68
msgid "How to write a commit message"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:70
msgid ""
"Any commit needs a helpful message. Mind the following guidelines when "
"committing to any of Tarantool repositories at GitHub."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:73
msgid "Separate subject from body with a blank line."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:74
msgid "Try to limit the subject line to **50 characters** or so."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:75
msgid ""
"Start the subject line with a capital letter unless it prefixed with a subsystem "
"name and semicolon:"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:78
msgid "memtx:"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:79
msgid "vinyl:"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:80
msgid "xlog:"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:81
#, fuzzy
msgid "replication:"
msgstr "Репликация"

#: ../doc/1.7/dev_guide/developer_guidelines.rst:82
msgid "recovery:"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:83
msgid "iproto:"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:84
msgid "net.box:"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:85
msgid "lua:"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:87
msgid "Do not end the subject line with a period."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:88
msgid "Do not put \"gh-xx\", \"closes #xxx\" to the subject line."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:89
msgid ""
"Use the imperative mood in the subject line. A properly formed Git commit "
"subject line should always be able to complete the following sentence: \"If "
"applied, this commit will */your subject line here/*\"."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:92
msgid "Wrap the body to **72 characters** or so."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:93
msgid "Use the body to explain **what and why** vs. how."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:94
msgid ""
"Link GitHub issues on the lasts lines (`see how <https://help.github.com/"
"articles/closing-issues-via-commit-messages>`_)."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:96
msgid ""
"Use your real name and real email address. For Tarantool team members, "
"**@tarantool.org** email is preferred, but not mandatory."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:100
#, fuzzy
msgid "A template:"
msgstr "Например:"

#: ../doc/1.7/dev_guide/developer_guidelines.rst:102
msgid ""
"Summarize changes in 50 characters or less\n"
"\n"
"More detailed explanatory text, if necessary.\n"
"Wrap it to 72 characters or so.\n"
"In some contexts, the first line is treated as the subject of the\n"
"commit, and the rest of the text as the body.\n"
"The blank line separating the summary from the body is critical\n"
"(unless you omit the body entirely); various tools like `log`,\n"
"`shortlog` and `rebase` can get confused if you run the two together.\n"
"\n"
"Explain the problem that this commit is solving. Focus on why you\n"
"are making this change as opposed to how (the code explains that).\n"
"Are there side effects or other unintuitive consequences of this\n"
"change? Here's the place to explain them.\n"
"\n"
"Further paragraphs come after blank lines.\n"
"\n"
"- Bullet points are okay, too.\n"
"\n"
"- Typically a hyphen or asterisk is used for the bullet, preceded\n"
"  by a single space, with blank lines in between, but conventions\n"
"  vary here.\n"
"\n"
"Fixes: #123\n"
"Closes: #456\n"
"Needed for: #859\n"
"See also: #343, #789"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:132
msgid "Some real-world examples:"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:134
msgid ""
"`tarantool/tarantool@2993a75 <https://github.com/tarantool/tarantool/"
"commit/2993a75858352f101deb4a15cefd497ae6a78cf7>`_"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:135
msgid ""
"`tarantool/tarantool@ccacba2 <https://github.com/tarantool/tarantool/commit/"
"ccacba28f813fb99fd9eaf07fb41bf604dd341bc>`_"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:136
msgid ""
"`tarantool/tarantool@386df3d <https://github.com/tarantool/tarantool/"
"commit/386df3d3eb9c5239fc83fd4dd3292d1b49446b89>`_"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:137
msgid ""
"`tarantool/tarantool@076a842 <https://github.com/tarantool/tarantool/"
"commit/076a842011e09c84c25fb5e68f1b23c9917a3750>`_"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:139
msgid "Based on [1_] and [2_]."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:39
msgid "Documentation guidelines"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:41
msgid ""
"These guidelines are updated on the on-demand basis, covering only those issues "
"that cause pains to the existing writers. At this point, we do not aim to come "
"up with an exhaustive Documentation Style Guide for the Tarantool project."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:47
msgid "Markup issues"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:51
msgid "Wrapping text"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:53
msgid ""
"The limit is 80 characters per line for plain text, and no limit for any other "
"constructions when wrapping affects ReST readability and/or HTML output. Also, "
"it makes no sense to wrap text into lines shorter than 80 characters unless you "
"have a good reason to do so."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:58
msgid ""
"The 80-character limit comes from the ISO/ANSI 80x24 screen resolution, and it's "
"unlikely that readers/writers will use 80-character consoles. Yet it's still a "
"standard for many coding guidelines (including Tarantool). As for writers, the "
"benefit is that an 80-character page guide allows keeping the text window rather "
"narrow most of the time, leaving more space for other applications in a wide-"
"screen environment."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:67
msgid "Formatting code snippets"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:69
msgid ""
"For code snippets, we mainly use the ``code-block`` directive with an "
"appropriate highlighting language. The most commonly used highlighting languages "
"are:"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:73
msgid "``.. code-block:: tarantoolsession``"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:74
msgid "``.. code-block:: console``"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:75
msgid "``.. code-block:: lua``"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:77
msgid "For example (a code snippet in Lua):"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:79
msgid ""
"for page in paged_iter(\"X\", 10) do\n"
"  print(\"New Page. Number Of Tuples = \" .. #page)\n"
"  for i=1,#page,1 do print(page[i]) end\n"
"end"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:86
msgid ""
"In rare cases, when we need custom highlight for specific parts of a code "
"snippet and the ``code-block`` directive is not enough, we use the per-line "
"``codenormal`` directive together and explicit output formatting (defined in :"
"file:`doc/sphinx/_static/sphinx_design.css`)."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:91
msgid "Examples:"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:93
msgid "Function syntax (the placeholder `space-name` is displayed in italics):"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:95
msgid ""
":codenormal:`box.space.`:codeitalic:`space-name`:codenormal:`:"
"create_index('index-name')`"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:97
msgid ""
"A tdb session (user input is in bold, command prompt is in blue, computer output "
"is in green):"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:109
msgid ""
"Warning: Every entry of explicit output formatting (``codenormal``, "
"``codebold``, etc) tends to cause troubles when this documentation is translated "
"to other languages. Please avoid using explicit output formatting unless it is "
"REALLY needed."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:116
msgid "Using separated links"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:118
msgid "Avoid separating the link and the target definition (ref), like this:"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:120
msgid ""
"This is a paragraph that contains `a link`_.\n"
"\n"
".. _a link: http://example.com/"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:126
msgid "Use non-separated links instead:"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:128
msgid "This is a paragraph that contains `a link <http://example.com/>`_."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:132
msgid ""
"Warning: Every separated link tends to cause troubles when this documentation is "
"translated to other languages. Please avoid using separated links unless it is "
"REALLY needed (e.g. in tables)."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:138
msgid "Creating labels for local links"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:140
msgid ""
"We avoid using links that sphinx generates automatically for most objects. "
"Instead, we add our own labels for linking to any place in this documentation."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:143
msgid "Our naming convention is as follows:"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:145
msgid "Character set: a through z, 0 through 9, dash, underscore."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:147
msgid "Format: ``path dash filename dash tag``"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:149
msgid ""
"Example: ``_c_api-box_index-iterator_type`` |br| where: |br| ``c_api`` is the "
"directory name, |br| ``box_index`` is the file name (without \".rst\"), and |br| "
"``iterator_type`` is the tag."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:155
msgid ""
"The file name is useful for knowing, when you see \"ref\", where it is pointing "
"to. And if the file name is meaningful, you see that better."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:158
msgid ""
"The file name alone, without a path, is enough when the file name is unique "
"within ``doc/sphinx``. So, for ``fiber.rst`` it should be just \"fiber\", not "
"\"reference-fiber\". While for \"index.rst\" (we have a handful of \"index.rst\" "
"in different directories) please specify the path before the file name, e.g. "
"\"reference-index\"."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:165
msgid ""
"Use a dash \"-\" to delimit the path and the file name. In the documentation "
"source, we use only underscores \"_\" in paths and file names, reserving dash \"-"
"\" as the delimiter for local links."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:169
msgid ""
"The tag can be anything meaningful. The only guideline is for Tarantool syntax "
"items (such as members), where the preferred tag syntax is "
"``module_or_object_name dash member_name``. For example, ``box_space-drop``."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:175
msgid "Making comments"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:177
msgid ""
"Sometimes we may need to leave comments in a ReST file. To make sphinx ignore "
"some text during processing, use the following per-line notation with \".. //\" "
"as the comment marker:"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:181
msgid ".. // your comment here"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:185
msgid ""
"The starting symbols \".. //\" do not interfere with the other ReST markup, and "
"they are easy to find both visually and using grep. There are no symbols to "
"escape in grep search, just go ahead with something like this:"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:189
msgid "grep \".. //\" doc/sphinx/dev_guide/*.rst"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:193
msgid ""
"These comments don't work properly in nested documentation, though (e.g. if you "
"leave a comment in module -> object -> method, sphinx ignores the comment and "
"all nested content that follows in the method description)."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:199
msgid "Language and style issues"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:203
msgid "US vs British spelling"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:205
msgid "We use English US spelling."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:209
msgid "Instance vs server"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:211
msgid ""
"We say \"instance\" rather than \"server\" to refer to an instance of Tarantool "
"server. This keeps the manual terminology consistent with names like ``/etc/"
"tarantool/instances.enabled`` in the Tarantool environment."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:215
msgid ""
"Wrong usage: \"Replication allows multiple Tarantool *servers* to work on copies "
"of the same databases.\""
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:218
msgid ""
"Correct usage: \"Replication allows multiple Tarantool *instances* to work on "
"copies of the same databases.\""
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:223
msgid "Examples and templates"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:227
msgid "Module and function"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:229
msgid ""
"Here is an example of documenting a module (``my_fiber``) and a function "
"(``my_fiber.create``)."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:236
msgid ""
"Create and start a ``my_fiber`` object. The object is created and begins to run "
"immediately."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:239
msgid "the function to be associated with the ``my_fiber`` object"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:240
#: ../doc/1.7/reference/reference_lua/fiber.rst:107
msgid "what will be passed to function"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:242
msgid "created ``my_fiber`` object"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:247
msgid ""
"tarantool> my_fiber = require('my_fiber')\n"
"---\n"
"...\n"
"tarantool> function function_name()\n"
"         >   my_fiber.sleep(1000)\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> my_fiber_object = my_fiber.create(function_name)\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:263
msgid "Module, class and method"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:265
msgid ""
"Here is an example of documenting a module (``my_box.index``), a class "
"(``my_index_object``) and a function (``my_index_object.rename``)."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:276
msgid "an object reference"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:277
msgid "a new name for the index (type = string)"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:281
msgid "Possible errors: index_object does not exist."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:291
msgid "Complexity Factors: Index size, Index type, Number of tuples accessed."
msgstr ""

#: ../doc/1.7/dev_guide/guidelines_index.rst:37
msgid "Guidelines"
msgstr ""

#: ../doc/1.7/dev_guide/index.rst:39
msgid "Contributor's Guide"
msgstr ""

#: ../doc/1.7/dev_guide/internals_index.rst:37
msgid "Internals"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:5
msgid "Tarantool's binary protocol"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:7
msgid "Tarantool's binary protocol is a binary request/response protocol."
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:11
msgid "Notation in diagrams"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:13
msgid ""
"0    X\n"
"+----+\n"
"|    | - X bytes\n"
"+----+\n"
" TYPE - type of MsgPack value (if it is a MsgPack object)\n"
"\n"
"+====+\n"
"|    | - Variable size MsgPack object\n"
"+====+\n"
" TYPE - type of MsgPack value\n"
"\n"
"+~~~~+\n"
"|    | - Variable size MsgPack Array/Map\n"
"+~~~~+\n"
" TYPE - type of MsgPack value"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:32
msgid "MsgPack data types:"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:34
msgid "**MP_INT** - Integer"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:35
msgid "**MP_MAP** - Map"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:36
msgid "**MP_ARR** - Array"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:37
msgid "**MP_STRING** - String"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:38
msgid "**MP_FIXSTR** - Fixed size string"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:39
msgid "**MP_OBJECT** - Any MsgPack object"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:40
msgid "**MP_BIN** - MsgPack binary format"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:44
msgid "Greeting packet"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:46
msgid ""
"TARANTOOL'S GREETING:\n"
"\n"
"0                                     63\n"
"+--------------------------------------+\n"
"|                                      |\n"
"| Tarantool Greeting (server version)  |\n"
"|               64 bytes               |\n"
"+---------------------+----------------+\n"
"|                     |                |\n"
"| BASE64 encoded SALT |      NULL      |\n"
"|      44 bytes       |                |\n"
"+---------------------+----------------+\n"
"64                  107              127"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:62
msgid ""
"The server instance begins the dialogue by sending a fixed-size (128-byte) text "
"greeting to the client. The greeting always contains two 64-byte lines of ASCII "
"text, each line ending with a newline character ('\\\\n'). The first line "
"contains the instance version and protocol type. The second line contains up to "
"44 bytes of base64-encoded random string, to use in the authentication packet, "
"and ends with up to 23 spaces."
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:70
msgid "Unified packet structure"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:72
msgid ""
"Once a greeting is read, the protocol becomes pure request/response and features "
"a complete access to Tarantool functionality, including:"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:75
msgid ""
"request multiplexing, e.g. ability to asynchronously issue multiple requests via "
"the same connection"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:77
msgid "response format that supports zero-copy writes"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:79
msgid ""
"For data structuring and encoding, the protocol uses msgpack data format, see "
"http://msgpack.org"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:82
msgid ""
"The Tarantool protocol mandates use of a few integer constants serving as keys "
"in maps used in the protocol. These constants are defined in `src/box/"
"iproto_constants.h <https://github.com/tarantool/tarantool/blob/1.7/src/box/"
"iproto_constants.h>`_"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:86
msgid "We list them here too:"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:88
msgid ""
"-- user keys\n"
"<code>          ::= 0x00\n"
"<sync>          ::= 0x01\n"
"<schema_id>     ::= 0x05\n"
"<space_id>      ::= 0x10\n"
"<index_id>      ::= 0x11\n"
"<limit>         ::= 0x12\n"
"<offset>        ::= 0x13\n"
"<iterator>      ::= 0x14\n"
"<key>           ::= 0x20\n"
"<tuple>         ::= 0x21\n"
"<function_name> ::= 0x22\n"
"<username>      ::= 0x23\n"
"<expression>    ::= 0x27\n"
"<ops>           ::= 0x28\n"
"<data>          ::= 0x30\n"
"<error>         ::= 0x31"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:108
msgid ""
"-- -- Value for <code> key in request can be:\n"
"-- User command codes\n"
"<select>  ::= 0x01\n"
"<insert>  ::= 0x02\n"
"<replace> ::= 0x03\n"
"<update>  ::= 0x04\n"
"<delete>  ::= 0x05\n"
"<call_16> ::= 0x06\n"
"<auth>    ::= 0x07\n"
"<eval>    ::= 0x08\n"
"<upsert>  ::= 0x09\n"
"<call>    ::= 0x0a\n"
"-- Admin command codes\n"
"<ping>    ::= 0x40\n"
"\n"
"-- -- Value for <code> key in response can be:\n"
"<OK>      ::= 0x00\n"
"<ERROR>   ::= 0x8XXX"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:130
msgid "Both :code:`<header>` and :code:`<body>` are msgpack maps:"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:132
msgid ""
"Request/Response:\n"
"\n"
"0        5\n"
"+--------+ +============+ +===================================+\n"
"| BODY + | |            | |                                   |\n"
"| HEADER | |   HEADER   | |               BODY                |\n"
"|  SIZE  | |            | |                                   |\n"
"+--------+ +============+ +===================================+\n"
"  MP_INT       MP_MAP                     MP_MAP"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:144
msgid ""
"UNIFIED HEADER:\n"
"\n"
"+================+================+=====================+\n"
"|                |                |                     |\n"
"|   0x00: CODE   |   0x01: SYNC   |    0x05: SCHEMA_ID  |\n"
"| MP_INT: MP_INT | MP_INT: MP_INT |  MP_INT: MP_INT     |\n"
"|                |                |                     |\n"
"+================+================+=====================+\n"
"                          MP_MAP"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:156
msgid ""
"They only differ in the allowed set of keys and values. The key defines the type "
"of value that follows. If a body has no keys, the entire msgpack map for the "
"body may be missing. Such is the case, for example, for a <ping> request. "
"``schema_id`` may be absent in the request's header, meaning that there will be "
"no version checking, but it must be present in the response. If ``schema_id`` is "
"sent in the header, then it will be checked."
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:167
msgid "Authentication"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:169
msgid ""
"When a client connects to the server instance, the instance responds with a 128-"
"byte text greeting message. Part of the greeting is base-64 encoded session salt "
"- a random string which can be used for authentication. The length of decoded "
"salt (44 bytes) exceeds the amount necessary to sign the authentication message "
"(first 20 bytes). An excess is reserved for future authentication schemas."
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:176
msgid ""
"PREPARE SCRAMBLE:\n"
"\n"
"    LEN(ENCODED_SALT) = 44;\n"
"    LEN(SCRAMBLE)     = 20;\n"
"\n"
"prepare 'chap-sha1' scramble:\n"
"\n"
"    salt = base64_decode(encoded_salt);\n"
"    step_1 = sha1(password);\n"
"    step_2 = sha1(step_1);\n"
"    step_3 = sha1(salt, step_2);\n"
"    scramble = xor(step_1, step_3);\n"
"    return scramble;\n"
"\n"
"AUTHORIZATION BODY: CODE = 0x07\n"
"\n"
"+==================+====================================+\n"
"|                  |        +-------------+-----------+ |\n"
"|  (KEY)           | (TUPLE)|  len == 9   | len == 20 | |\n"
"|   0x23:USERNAME  |   0x21:| \"chap-sha1\" |  SCRAMBLE | |\n"
"| MP_INT:MP_STRING | MP_INT:|  MP_STRING  |  MP_BIN   | |\n"
"|                  |        +-------------+-----------+ |\n"
"|                  |                   MP_ARRAY         |\n"
"+==================+====================================+\n"
"                        MP_MAP"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:204
msgid ""
":code:`<key>` holds the user name. :code:`<tuple>` must be an array of 2 fields: "
"authentication mechanism (\"chap-sha1\" is the only supported mechanism right "
"now) and password, encrypted according to the specified mechanism. "
"Authentication in Tarantool is optional, if no authentication is performed, "
"session user is 'guest'. The instance responds to authentication packet with a "
"standard response with 0 tuples."
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:212
msgid "Requests"
msgstr "Запросы"

#: ../doc/1.7/dev_guide/box_protocol.rst:214
msgid "SELECT: CODE - 0x01 Find tuples matching the search pattern"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:217
msgid ""
"SELECT BODY:\n"
"\n"
"+==================+==================+==================+\n"
"|                  |                  |                  |\n"
"|   0x10: SPACE_ID |   0x11: INDEX_ID |   0x12: LIMIT    |\n"
"| MP_INT: MP_INT   | MP_INT: MP_INT   | MP_INT: MP_INT   |\n"
"|                  |                  |                  |\n"
"+==================+==================+==================+\n"
"|                  |                  |                  |\n"
"|   0x13: OFFSET   |   0x14: ITERATOR |   0x20: KEY      |\n"
"| MP_INT: MP_INT   | MP_INT: MP_INT   | MP_INT: MP_ARRAY |\n"
"|                  |                  |                  |\n"
"+==================+==================+==================+\n"
"                          MP_MAP"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:234
msgid ""
"INSERT:  CODE - 0x02 Inserts tuple into the space, if no tuple with same unique "
"keys exists. Otherwise throw *duplicate key* error."
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:236
msgid ""
"REPLACE: CODE - 0x03 Insert a tuple into the space or replace an existing one."
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:239
msgid ""
"INSERT/REPLACE BODY:\n"
"\n"
"+==================+==================+\n"
"|                  |                  |\n"
"|   0x10: SPACE_ID |   0x21: TUPLE    |\n"
"| MP_INT: MP_INT   | MP_INT: MP_ARRAY |\n"
"|                  |                  |\n"
"+==================+==================+\n"
"                 MP_MAP"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:252
msgid "UPDATE: CODE - 0x04 Update a tuple"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:255
msgid ""
"UPDATE BODY:\n"
"\n"
"+==================+=======================+\n"
"|                  |                       |\n"
"|   0x10: SPACE_ID |   0x11: INDEX_ID      |\n"
"| MP_INT: MP_INT   | MP_INT: MP_INT        |\n"
"|                  |                       |\n"
"+==================+=======================+\n"
"|                  |          +~~~~~~~~~~+ |\n"
"|                  |          |          | |\n"
"|                  | (TUPLE)  |    OP    | |\n"
"|   0x20: KEY      |    0x21: |          | |\n"
"| MP_INT: MP_ARRAY |  MP_INT: +~~~~~~~~~~+ |\n"
"|                  |            MP_ARRAY   |\n"
"+==================+=======================+\n"
"                 MP_MAP"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:274
msgid ""
"OP:\n"
"    Works only for integer fields:\n"
"    * Addition    OP = '+' . space[key][field_no] += argument\n"
"    * Subtraction OP = '-' . space[key][field_no] -= argument\n"
"    * Bitwise AND OP = '&' . space[key][field_no] &= argument\n"
"    * Bitwise XOR OP = '^' . space[key][field_no] ^= argument\n"
"    * Bitwise OR  OP = '|' . space[key][field_no] |= argument\n"
"    Works on any fields:\n"
"    * Delete      OP = '#'\n"
"      delete <argument> fields starting\n"
"      from <field_no> in the space[<key>]\n"
"\n"
"0           2\n"
"+-----------+==========+==========+\n"
"|           |          |          |\n"
"|    OP     | FIELD_NO | ARGUMENT |\n"
"| MP_FIXSTR |  MP_INT  |  MP_INT  |\n"
"|           |          |          |\n"
"+-----------+==========+==========+\n"
"              MP_ARRAY"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:297
msgid ""
"    * Insert      OP = '!'\n"
"      insert <argument> before <field_no>\n"
"    * Assign      OP = '='\n"
"      assign <argument> to field <field_no>.\n"
"      will extend the tuple if <field_no> == <max_field_no> + 1\n"
"\n"
"0           2\n"
"+-----------+==========+===========+\n"
"|           |          |           |\n"
"|    OP     | FIELD_NO | ARGUMENT  |\n"
"| MP_FIXSTR |  MP_INT  | MP_OBJECT |\n"
"|           |          |           |\n"
"+-----------+==========+===========+\n"
"              MP_ARRAY\n"
"\n"
"    Works on string fields:\n"
"    * Splice      OP = ':'\n"
"      take the string from space[key][field_no] and\n"
"      substitute <offset> bytes from <position> with <argument>"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:319
msgid ""
"0           2\n"
"+-----------+==========+==========+========+==========+\n"
"|           |          |          |        |          |\n"
"|    ':'    | FIELD_NO | POSITION | OFFSET | ARGUMENT |\n"
"| MP_FIXSTR |  MP_INT  |  MP_INT  | MP_INT |  MP_STR  |\n"
"|           |          |          |        |          |\n"
"+-----------+==========+==========+========+==========+\n"
"                         MP_ARRAY"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:331
msgid ""
"It is an error to specify an argument of a type that differs from the expected "
"type."
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:333
msgid "DELETE: CODE - 0x05 Delete a tuple"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:336
msgid ""
"DELETE BODY:\n"
"\n"
"+==================+==================+==================+\n"
"|                  |                  |                  |\n"
"|   0x10: SPACE_ID |   0x11: INDEX_ID |   0x20: KEY      |\n"
"| MP_INT: MP_INT   | MP_INT: MP_INT   | MP_INT: MP_ARRAY |\n"
"|                  |                  |                  |\n"
"+==================+==================+==================+\n"
"                          MP_MAP"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:349
msgid ""
"CALL_16: CODE - 0x06 Call a stored function, returning an array of tuples. This "
"is deprecated; CALL (0x0a) is recommended instead."
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:352
msgid ""
"CALL_16 BODY:\n"
"\n"
"+=======================+==================+\n"
"|                       |                  |\n"
"|   0x22: FUNCTION_NAME |   0x21: TUPLE    |\n"
"| MP_INT: MP_STRING     | MP_INT: MP_ARRAY |\n"
"|                       |                  |\n"
"+=======================+==================+\n"
"                    MP_MAP"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:366
msgid "EVAL: CODE - 0x08 Evaulate Lua expression"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:369
msgid ""
"EVAL BODY:\n"
"\n"
"+=======================+==================+\n"
"|                       |                  |\n"
"|   0x27: EXPRESSION    |   0x21: TUPLE    |\n"
"| MP_INT: MP_STRING     | MP_INT: MP_ARRAY |\n"
"|                       |                  |\n"
"+=======================+==================+\n"
"                    MP_MAP"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:382
msgid ""
"UPSERT: CODE - 0x09 Update tuple if it would be found elsewhere try to insert "
"tuple. Always use primary index for key."
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:385
msgid ""
"UPSERT BODY:\n"
"\n"
"+==================+==================+==========================+\n"
"|                  |                  |             +~~~~~~~~~~+ |\n"
"|                  |                  |             |          | |\n"
"|   0x10: SPACE_ID |   0x21: TUPLE    |       (OPS) |    OP    | |\n"
"| MP_INT: MP_INT   | MP_INT: MP_ARRAY |       0x28: |          | |\n"
"|                  |                  |     MP_INT: +~~~~~~~~~~+ |\n"
"|                  |                  |               MP_ARRAY   |\n"
"+==================+==================+==========================+\n"
"                                MP_MAP\n"
"\n"
"Operations structure same as for UPDATE operation.\n"
"   0           2\n"
"+-----------+==========+==========+\n"
"|           |          |          |\n"
"|    OP     | FIELD_NO | ARGUMENT |\n"
"| MP_FIXSTR |  MP_INT  |  MP_INT  |\n"
"|           |          |          |\n"
"+-----------+==========+==========+\n"
"              MP_ARRAY\n"
"\n"
"Supported operations:\n"
"\n"
"'+' - add a value to a numeric field. If the filed is not numeric, it's\n"
"      changed to 0 first. If the field does not exist, the operation is\n"
"      skipped. There is no error in case of overflow either, the value\n"
"      simply wraps around in C style. The range of the integer is MsgPack:\n"
"      from -2^63 to 2^64-1\n"
"'-' - same as the previous, but subtract a value\n"
"'=' - assign a field to a value. The field must exist, if it does not exist,\n"
"      the operation is skipped.\n"
"'!' - insert a field. It's only possible to insert a field if this create no\n"
"      nil \"gaps\" between fields. E.g. it's possible to add a field between\n"
"      existing fields or as the last field of the tuple.\n"
"'#' - delete a field. If the field does not exist, the operation is skipped.\n"
"      It's not possible to change with update operations a part of the primary\n"
"      key (this is validated before performing upsert)."
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:426
msgid ""
"CALL: CODE - 0x0a Similar to CALL_16, but -- like EVAL, CALL returns a list of "
"values, unconverted"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:429
msgid ""
"CALL BODY:\n"
"\n"
"+=======================+==================+\n"
"|                       |                  |\n"
"|   0x22: FUNCTION_NAME |   0x21: TUPLE    |\n"
"| MP_INT: MP_STRING     | MP_INT: MP_ARRAY |\n"
"|                       |                  |\n"
"+=======================+==================+\n"
"                    MP_MAP"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:444
msgid "Response packet structure"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:446
msgid "We will show whole packets here:"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:448
msgid ""
"OK:    LEN + HEADER + BODY\n"
"\n"
"0      5                                          OPTIONAL\n"
"+------++================+================++===================+\n"
"|      ||                |                ||                   |\n"
"| BODY ||   0x00: 0x00   |   0x01: SYNC   ||   0x30: DATA      |\n"
"|HEADER|| MP_INT: MP_INT | MP_INT: MP_INT || MP_INT: MP_OBJECT |\n"
"| SIZE ||                |                ||                   |\n"
"+------++================+================++===================+\n"
" MP_INT                MP_MAP                      MP_MAP"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:462
msgid ""
"Set of tuples in the response :code:`<data>` expects a msgpack array of tuples "
"as value EVAL command returns arbitrary `MP_ARRAY` with arbitrary MsgPack values."
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:465
msgid ""
"ERROR: LEN + HEADER + BODY\n"
"\n"
"0      5\n"
"+------++================+================++===================+\n"
"|      ||                |                ||                   |\n"
"| BODY ||   0x00: 0x8XXX |   0x01: SYNC   ||   0x31: ERROR     |\n"
"|HEADER|| MP_INT: MP_INT | MP_INT: MP_INT || MP_INT: MP_STRING |\n"
"| SIZE ||                |                ||                   |\n"
"+------++================+================++===================+\n"
" MP_INT                MP_MAP                      MP_MAP\n"
"\n"
"Where 0xXXX is ERRCODE."
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:480
msgid ""
"An error message is present in the response only if there is an error; :code:"
"`<error>` expects as value a msgpack string."
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:483
msgid ""
"Convenience macros which define hexadecimal constants for return codes can be "
"found in `src/box/errcode.h <https://github.com/tarantool/tarantool/blob/1.7/src/"
"box/errcode.h>`_"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:489
msgid "Replication packet structure"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:491
msgid ""
"-- replication keys\n"
"<server_id>     ::= 0x02\n"
"<lsn>           ::= 0x03\n"
"<timestamp>     ::= 0x04\n"
"<server_uuid>   ::= 0x24\n"
"<cluster_uuid>  ::= 0x25\n"
"<vclock>        ::= 0x26"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:501
msgid ""
"-- replication codes\n"
"<join>      ::= 0x41\n"
"<subscribe> ::= 0x42"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:508
msgid ""
"JOIN:\n"
"\n"
"In the beginning you must send initial JOIN\n"
"               HEADER                      BODY\n"
"+================+================++===================+\n"
"|                |                ||   SERVER_UUID     |\n"
"|   0x00: 0x41   |   0x01: SYNC   ||   0x24: UUID      |\n"
"| MP_INT: MP_INT | MP_INT: MP_INT || MP_INT: MP_STRING |\n"
"|                |                ||                   |\n"
"+================+================++===================+\n"
"               MP_MAP                     MP_MAP\n"
"\n"
"Then instance, which we connect to, will send last SNAP file by, simply,\n"
"creating a number of INSERTs (with additional LSN and ServerID)\n"
"(don't reply). Then it'll send a vclock's MP_MAP and close a socket.\n"
"\n"
"+================+================++============================+\n"
"|                |                ||        +~~~~~~~~~~~~~~~~~+ |\n"
"|                |                ||        |                 | |\n"
"|   0x00: 0x00   |   0x01: SYNC   ||   0x26:| SRV_ID: SRV_LSN | |\n"
"| MP_INT: MP_INT | MP_INT: MP_INT || MP_INT:| MP_INT: MP_INT  | |\n"
"|                |                ||        +~~~~~~~~~~~~~~~~~+ |\n"
"|                |                ||               MP_MAP       |\n"
"+================+================++============================+\n"
"               MP_MAP                      MP_MAP\n"
"\n"
"SUBSCRIBE:\n"
"\n"
"Then you must send SUBSCRIBE:\n"
"\n"
"                              HEADER\n"
"+===================+===================+\n"
"|                   |                   |\n"
"|     0x00: 0x41    |    0x01: SYNC     |\n"
"|   MP_INT: MP_INT  |  MP_INT: MP_INT   |\n"
"|                   |                   |\n"
"+===================+===================+\n"
"|    SERVER_UUID    |    CLUSTER_UUID   |\n"
"|   0x24: UUID      |   0x25: UUID      |\n"
"| MP_INT: MP_STRING | MP_INT: MP_STRING |\n"
"|                   |                   |\n"
"+===================+===================+\n"
"                 MP_MAP\n"
"\n"
"      BODY\n"
"+================+\n"
"|                |\n"
"|   0x26: VCLOCK |\n"
"| MP_INT: MP_INT |\n"
"|                |\n"
"+================+\n"
"      MP_MAP\n"
"\n"
"Then you must process every query that'll came through other masters.\n"
"Every request between masters will have Additional LSN and SERVER_ID."
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:568
msgid "XLOG / SNAP"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:570
msgid "XLOG and SNAP files have nearly the same format. The header looks like:"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:572
msgid ""
"<type>\\n                  SNAP\\n or XLOG\\n\n"
"<version>\\n               currently 0.13\\n\n"
"Server: <server_uuid>\\n   where UUID is a 36-byte string\n"
"VClock: <vclock_map>\\n    e.g. {1: 0}\\n\n"
"\\n"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:580
msgid ""
"After the file header come the data tuples. Tuples begin with a row marker "
"``0xd5ba0bab`` and the last tuple may be followed by an EOF marker "
"``0xd510aded``. Thus, between the file header and the EOF marker, there may be "
"data tuples that have this form:"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:587
msgid ""
"0            3 4                                         17\n"
"+-------------+========+============+===========+=========+\n"
"|             |        |            |           |         |\n"
"| 0xd5ba0bab  | LENGTH | CRC32 PREV | CRC32 CUR | PADDING |\n"
"|             |        |            |           |         |\n"
"+-------------+========+============+===========+=========+\n"
"  MP_FIXEXT2    MP_INT     MP_INT       MP_INT      ---\n"
"\n"
"+============+ +===================================+\n"
"|            | |                                   |\n"
"|   HEADER   | |                BODY               |\n"
"|            | |                                   |\n"
"+============+ +===================================+\n"
"    MP_MAP                     MP_MAP"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:604
msgid "See the example in the following section."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:9
msgid "Data persistence and the WAL file format"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:11
msgid ""
"To maintain data persistence, Tarantool writes each data change request (insert, "
"update, delete, replace, upsert) into a write-ahead log (WAL) file in the :ref:"
"`wal_dir <cfg_basic-wal_dir>` directory. A new WAL file is created for every :"
"ref:`rows_per_wal <cfg_binary_logging_snapshots-rows_per_wal>` records. Each "
"data change request gets assigned a continuously growing 64-bit log sequence "
"number. The name of the WAL file is based on the log sequence number of the "
"first record in the file, plus an extension ``.xlog``."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:19
msgid ""
"Apart from a log sequence number and the data change request (formatted as in :"
"ref:`Tarantool's binary protocol <box_protocol-iproto_protocol>`), each WAL "
"record contains a header, some metadata, and then the data formatted according "
"to `msgpack <https://en.wikipedia.org/wiki/MessagePack>`_ rules. For example, "
"this is what the WAL file looks like after the first INSERT request (\"s:"
"insert({1})\") for the sandbox database created in our :ref:`\"Getting started\" "
"exercises <getting_started>`. On the left are the hexadecimal bytes that you "
"would see with:"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:28
msgid "$ hexdump 00000000000000000000.xlog"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:32
msgid "and on the right are comments."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:34
msgid ""
"Hex dump of WAL file       Comment\n"
"--------------------       -------\n"
"58 4c 4f 47 0a             \"XLOG\\n\"\n"
"30 2e 31 33 0a             \"0.13\\n\" = version\n"
"53 65 72 76 65 72 3a 20    \"Server: \"\n"
"38 62 66 32 32 33 65 30 2d [Server UUID]\\n\n"
"36 39 31 34 2d 34 62 35 35\n"
"2d 39 34 64 32 2d 64 32 62\n"
"36 64 30 39 62 30 31 39 36\n"
"0a\n"
"56 43 6c 6f 63 6b 3a 20    \"Vclock: \"\n"
"7b 7d                      \"{}\" = vclock value, initially blank\n"
"...                        (not shown = tuples for system spaces)\n"
"d5 ba 0b ab                Magic row marker always = 0xab0bbad5\n"
"19                         Length, not including length of header, = 25 bytes\n"
"00                           Record header: previous crc32\n"
"ce 8c 3e d6 70               Record header: current crc32\n"
"a7 cc 73 7f 00 00 66 39      Record header: padding\n"
"84                         msgpack code meaning \"Map of 4 elements\" follows\n"
"00 02                         element#1: tag=request type, "
"value=0x02=IPROTO_INSERT\n"
"02 01                         element#2: tag=server id, value=0x01\n"
"03 04                         element#3: tag=lsn, value=0x04\n"
"04 cb 41 d4 e2 2f 62 fd d5 d4 element#4: tag=timestamp, value=an 8-byte "
"\"Float64\"\n"
"82                         msgpack code meaning \"map of 2 elements\" follows\n"
"10 cd 02 00                   element#1: tag=space id, value=512, big byte "
"first\n"
"21 91 01                      element#2: tag=tuple, value=1-element fixed "
"array={1}"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:63
msgid "A tool for reading .xlog files is Tarantool's :ref:`xlog module <xlog>`."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:65
msgid ""
"Tarantool processes requests atomically: a change is either accepted and "
"recorded in the WAL, or discarded completely. Let's clarify how this happens, "
"using the REPLACE request as an example:"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:69
msgid ""
"The server instance attempts to locate the original tuple by primary key. If "
"found, a reference to the tuple is retained for later use."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:72
msgid ""
"The new tuple is validated. If for example it does not contain an indexed field, "
"or it has an indexed field whose type does not match the type according to the "
"index definition, the change is aborted."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:76
msgid "The new tuple replaces the old tuple in all existing indexes."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:78
msgid ""
"A message is sent to the writer process running in the WAL thread, requesting "
"that the change be recorded in the WAL. The instance switches to work on the "
"next request until the write is acknowledged."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:82
msgid ""
"On success, a confirmation is sent to the client. On failure, a rollback "
"procedure is begun. During the rollback procedure, the transaction processor "
"rolls back all changes to the database which occurred after the first failed "
"change, from latest to oldest, up to the first failed change. All rolled back "
"requests are aborted with :errcode:`ER_WAL_IO <ER_WAL_IO>` error. No new change "
"is applied while rollback is in progress. When the rollback procedure is "
"finished, the server restarts the processing pipeline."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:90
msgid ""
"One advantage of the described algorithm is that complete request pipelining is "
"achieved, even for requests on the same value of the primary key. As a result, "
"database performance doesn't degrade even if all requests refer to the same key "
"in the same space."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:95
msgid ""
"The transaction processor thread communicates with the WAL writer thread using "
"asynchronous (yet reliable) messaging; the transaction processor thread, not "
"being blocked on WAL tasks, continues to handle requests quickly even at high "
"volumes of disk I/O. A response to a request is sent as soon as it is ready, "
"even if there were earlier incomplete requests on the same connection. In "
"particular, SELECT performance, even for SELECTs running on a connection packed "
"with UPDATEs and DELETEs, remains unaffected by disk load."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:103
msgid ""
"The WAL writer employs a number of durability modes, as defined in configuration "
"variable :ref:`wal_mode <index-wal_mode>`. It is possible to turn the write-"
"ahead log completely off, by setting :ref:`wal_mode "
"<cfg_binary_logging_snapshots-wal_mode>` to *none*. Even without the write-ahead "
"log it's still possible to take a persistent copy of the entire data set with "
"the :ref:`box.snapshot() <box-snapshot>` request."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:110
msgid ""
"An .xlog file always contains changes based on the primary key. Even if the "
"client requested an update or delete using a secondary key, the record in the ."
"xlog file will contain the primary key."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:118
msgid "The snapshot file format"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:120
msgid ""
"The format of a snapshot .snap file is nearly the same as the format of a WAL ."
"xlog file. However, the snapshot header differs: it contains the instance's "
"global unique identifier and the snapshot file's position in history, relative "
"to earlier snapshot files. Also, the content differs: an .xlog file may contain "
"records for any data-change requests (inserts, updates, upserts, and deletes), "
"a .snap file may only contain records of inserts to memtx spaces."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:127
msgid ""
"Primarily, the .snap file's records are ordered by space id. Therefore the "
"records of system spaces -- such as ``_schema``, ``_space``, ``_index``, "
"``_func``, ``_priv`` and ``_cluster`` -- will be at the start of the .snap file, "
"before the records of any spaces that were created by users."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:132
msgid ""
"Secondarily, the .snap file's records are ordered by primary key within space id."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:138
msgid "The recovery process"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:140
msgid ""
"The recovery process begins when box.cfg{} happens for the first time after the "
"Tarantool server instance starts."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:143
msgid ""
"The recovery process must recover the databases as of the moment when the "
"instance was last shut down. For this it may use the latest snapshot file and "
"any WAL files that were written after the snapshot. One complicating factor is "
"that Tarantool has two engines -- the memtx data must be reconstructed entirely "
"from the snapshot and the WAL files, while the vinyl data will be on disk but "
"might require updating around the time of a checkpoint. (When a snapshot "
"happens, Tarantool tells the vinyl engine to make a checkpoint, and the snapshot "
"operation is rolled back if anything goes wrong, so vinyl's checkpoint is at "
"least as fresh as the snapshot file.)"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:160
msgid "Step 1"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:156
msgid ""
"Read the configuration parameters in the ``box.cfg{}`` request. Parameters which "
"affect recovery may include :ref:`work_dir <cfg_basic-work_dir>`, :ref:`wal_dir "
"<cfg_basic-wal_dir>`, :ref:`memtx_dir <cfg_basic-memtx_dir>`, :ref:`vinyl_dir "
"<cfg_basic-vinyl_dir>` and :ref:`force_recovery <cfg_binary_logging_snapshots-"
"force_recovery>`."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:180
msgid "Step 2"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:163
msgid ""
"Find the latest snapshot file. Use its data to reconstruct the in-memory "
"databases. Instruct the vinyl engine to recover to the latest checkpoint."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:166
msgid ""
"There are actually two variations of the reconstruction procedure for memtx "
"databases, depending on whether the recovery process is \"default\"."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:169
msgid ""
"If the recovery process is default (``force_recovery`` is ``false``), memtx can "
"read data in the snapshot with all indexes disabled. First, all tuples are read "
"into memory. Then, primary keys are built in bulk, taking advantage of the fact "
"that the data is already sorted by primary key within each space."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:175
msgid ""
"If the recovery process is non-default (``force_recovery`` is ``true``), "
"Tarantool performs additional checking. Indexes are enabled at the start, and "
"tuples are added one by one. This means that any unique-key constraint "
"violations will be caught, and any duplicates will be skipped. Normally there "
"will be no constraint violations or duplicates, so these checks are only made if "
"an error has occurred."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:187
msgid "Step 3"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:183
msgid ""
"Find the WAL file that was made at the time of, or after, the snapshot file. "
"Read its log entries until the log-entry LSN is greater than the LSN of the "
"snapshot, or greater than the LSN of the vinyl checkpoint. This is the recovery "
"process's \"start position\"; it matches the current state of the engines."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:191
msgid "Step 4"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:190
msgid ""
"Redo the log entries, from the start position to the end of the WAL. The engine "
"skips a redo instruction if it is older than the engine's checkpoint."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:194
msgid "Step 5"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:194
msgid "For the memtx engine, re-create all secondary indexes."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:200
msgid "Server startup with replication"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:202
msgid ""
"In addition to the recovery process described above, the server must take "
"additional steps and precautions if :ref:`replication <replication>` is enabled."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:205
msgid ""
"Once again the startup procedure is initiated by the ``box.cfg{}`` request. One "
"of the ``box.cfg`` parameters may be :ref:`replication <cfg_replication-"
"replication>` that specifies replication source(-s). We will refer to this "
"replica, which is starting up due to ``box.cfg``, as the \"local\" replica to "
"distinguish it from the other replicas in a replica set, which we will refer to "
"as \"distant\" replicas."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:212
msgid ""
"*If there is no snapshot .snap file and the ``replication`` parameter is empty*: "
"|br| then the local replica assumes it is an unreplicated \"standalone\" "
"instance, or is the first replica of a new replica set. It will generate new "
"UUIDs for itself and for the replica set. The replica UUID is stored in the "
"``_cluster`` space; the replica set UUID is stored in the ``_schema`` space. "
"Since a snapshot contains all the data in all the spaces, that means the local "
"replica's snapshot will contain the replica UUID and the replica set UUID. "
"Therefore, when the local replica restarts on later occasions, it will be able "
"to recover these UUIDs when it reads the .snap file."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:222
msgid ""
"*If there is no snapshot .snap file and the ``replication`` parameter is not "
"empty and the ``_cluster`` space contains no other replica UUIDs*: |br| then the "
"local replica assumes it is not a standalone instance, but is not yet part of a "
"replica set. It must now join the replica set. It will send its replica UUID to "
"the first distant replica which is listed in ``replication`` and which will act "
"as a master. This is called the \"join request\". When a distant replica "
"receives a join request, it will send back:"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:230
msgid "the distant replica's replica set UUID,"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:231
msgid ""
"the contents of the distant replica's .snap file. |br| When the local replica "
"receives this information, it puts the replica set UUID in its ``_schema`` "
"space, puts the distant replica's UUID and connection information in its "
"``_cluster`` space, and makes a snapshot containing all the data sent by the "
"distant replica. Then, if the local replica has data in its WAL .xlog files, it "
"sends that data to the distant replica. The distant replica will receive this "
"and update its own copy of the data, and add the local replica's UUID to its "
"``_cluster`` space."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:240
msgid ""
"*If there is no snapshot .snap file and the ``replication`` parameter is not "
"empty and the ``_cluster`` space contains other replica UUIDs*: |br| then the "
"local replica assumes it is not a standalone instance, and is already part of a "
"replica set. It will send its replica UUID and replica set UUID to all the "
"distant replicas which are listed in ``replication``. This is called the \"on-"
"connect handshake\". When a distant replica receives an on-connect handshake: |"
"br|"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:247
msgid ""
"the distant replica compares its own copy of the replica set UUID to the one in "
"the on-connect handshake. If there is no match, then the handshake fails and the "
"local replica will display an error."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:250
msgid ""
"the distant replica looks for a record of the connecting instance in its "
"``_cluster`` space. If there is none, then the handshake fails. |br| Otherwise "
"the handshake is successful. The distant replica will read any new information "
"from its own .snap and .xlog files, and send the new requests to the local "
"replica."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:256
msgid ""
"In the end ... the local replica knows what replica set it belongs to, the "
"distant replica knows that the local replica is a member of the replica set, and "
"both replicas have the same database contents."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:262
msgid ""
"*If there is a snapshot file and replication source is not empty*: |br| first "
"the local replica goes through the recovery process described in the previous "
"section, using its own .snap and .xlog files. Then it sends a \"subscribe\" "
"request to all the other replicas of the replica set. The subscribe request "
"contains the server vector clock. The vector clock has a collection of pairs "
"'server id, lsn' for every replica in the ``_cluster`` system space. Each "
"distant replica, upon receiving a subscribe request, will read its .xlog files' "
"requests and send them to the local replica if (lsn of .xlog file request) is "
"greater than (lsn of the vector clock in the subscribe request). After all the "
"other replicas of the replica set have responded to the local replica's "
"subscribe request, the replica startup is complete."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:274
msgid "The following temporary limitations apply for version 1.7:"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:276
msgid ""
"The URIs in the ``replication`` parameter should all be in the same order on all "
"replicas. This is not mandatory but is an aid to consistency."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:278
msgid ""
"The replicas of a replica set should be started up at slightly different times. "
"This is not mandatory but prevents a situation where each replica is waiting for "
"the other replica to be ready."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:281
msgid ""
"The maximum number of entries in the ``_cluster`` space is 32. Tuples for out-of-"
"date replicas are not automatically re-used, so if this 32-replica limit is "
"reached, users may have to reorganize the ``_cluster`` space manually."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:37
msgid "Lua Style Guide"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:39
#, fuzzy
msgid "Inspiration:"
msgstr "Операции"

#: ../doc/1.7/dev_guide/lua_style_guide.rst:41
msgid "https://github.com/Olivine-Labs/lua-style-guide"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:42
msgid "http://dev.minetest.net/Lua_code_style_guidelines"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:43
msgid "http://sputnik.freewisdom.org/en/Coding_Standard"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:45
msgid ""
"Programming style is an art. There is some arbitrariness to the rules, but there "
"are sound rationales for them. It is useful not only to provide sound advice on "
"style but to understand the underlying rationale and human aspect of why the "
"style recommendations are formed:"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:50
msgid "http://mindprod.com/jgloss/unmain.html"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:51
msgid "http://www.oreilly.com/catalog/perlbp/"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:52
msgid "http://books.google.com/books?id=QnghAQAAIAAJ"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:54
msgid "Zen of Python is good; understand it and use wisely:"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "Beautiful is better than ugly."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "Explicit is better than implicit."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "Simple is better than complex."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "Complex is better than complicated."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "Flat is better than nested."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "Sparse is better than dense."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "Readability counts."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "Special cases aren't special enough to break the rules."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "Although practicality beats purity."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "Errors should never pass silently."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "Unless explicitly silenced."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "In the face of ambiguity, refuse the temptation to guess."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "There should be one -- and preferably only one -- obvious way to do it."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "Although that way may not be obvious at first unless you're Dutch."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "Now is better than never."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "Although never is often better than *right* now."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "If the implementation is hard to explain, it's a bad idea."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "If the implementation is easy to explain, it may be a good idea."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "Namespaces are one honking great idea -- let's do more of those!"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "https://www.python.org/dev/peps/pep-0020/"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:80
msgid "Indentation and Formatting"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:82
msgid ""
"4 spaces instead tabs. PIL suggests using of two spaces, but programmer looks at "
"code 4 up to 8 hours a day, so it's simplier to distinguish indentation with 4 "
"spaces. Why spaces? Similar representation everywhere."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:86
msgid "You can use vim modelines:"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:88
msgid "-- vim:ts=4 ss=4 sw=4 expandtab"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:92
msgid ""
"A file should ends w/ one newline symbol, but shouldn't ends w/ blank line (two "
"newline symbols)."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:95
msgid "Every do/while/for/if/function should indent 4 spaces."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:97
msgid ""
"related ``or``/``and`` in ``if`` must be enclosed in the round brackets (). "
"Example:"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:99
msgid ""
"if (a == true and b == false) or (a == false and b == true) then\n"
"    <...>\n"
"end -- good\n"
"\n"
"if a == true and b == false or a == false and b == true then\n"
"    <...>\n"
"end -- bad\n"
"\n"
"if a ^ b == true then\n"
"end -- good, but not explicit"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:112
msgid "Type conversion"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:114
msgid ""
"Do not use concatenation to convert to string or addition to convert to number "
"(use ``tostring``/``tonumber`` instead):"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:117
msgid ""
"local a = 123\n"
"a = a .. ''\n"
"-- bad\n"
"\n"
"local a = 123\n"
"a = tostring(a)\n"
"-- good\n"
"\n"
"local a = '123'\n"
"a = a + 5 -- 128\n"
"-- bad\n"
"\n"
"local a = '123'\n"
"a = tonumber(a) + 5 -- 128\n"
"-- good"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:135
msgid "Try to avoid multiple nested ``if``'s with common body:"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:137
msgid ""
"if (a == true and b == false) or (a == false and b == true) then\n"
"    do_something()\n"
"end\n"
"-- good\n"
"\n"
"if a == true then\n"
"    if b == false then\n"
"        do_something()\n"
"    end\n"
"if b == true then\n"
"    if a == false then\n"
"        do_something()\n"
"    end\n"
"end\n"
"-- bad"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:155
msgid ""
"Avoid multiple concatenations in one statement, use ``string.format`` instead:"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:157
#, python-format
msgid ""
"function say_greeting(period, name)\n"
"    local a = \"good  \" .. period .. \", \" .. name\n"
"end\n"
"-- bad\n"
"\n"
"function say_greeting(period, name)\n"
"    local a = string.format(\"good %s, %s\", period, name)\n"
"end\n"
"-- good\n"
"\n"
"local say_greeting_fmt = \"good %s, %s\"\n"
"function say_greeting(period, name)\n"
"    local a = say_greeting_fmt:format(period, name)\n"
"end\n"
"-- best"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:175
msgid "Use ``and``/``or`` for default variable values"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:177
msgid ""
"function(input)\n"
"    input = input or 'default_value'\n"
"end -- good\n"
"\n"
"function(input)\n"
"    if input == nil then\n"
"        input = 'default_value'\n"
"    end\n"
"end -- ok, but excessive"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:189
msgid "``if``'s and return statements:"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:191
msgid ""
"if a == true then\n"
"    return do_something()\n"
"end\n"
"do_other_thing() -- good\n"
"\n"
"if a == true then\n"
"    return do_something()\n"
"else\n"
"    do_other_thing()\n"
"end -- bad"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:204
msgid "Using spaces:"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:206
msgid ""
"one shouldn't use spaces between function name and opening round bracket, but "
"arguments must be splitted with one whitespace charachter"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:209
msgid ""
"function name (arg1,arg2,...)\n"
"end -- bad\n"
"\n"
"function name(arg1, arg2, ...)\n"
"end -- good"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:217
msgid "use space after comment marker"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:219
msgid ""
"while true do -- inline comment\n"
"-- comment\n"
"do_something()\n"
"end\n"
"--[[\n"
"  multiline\n"
"  comment\n"
"]]--"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:230
msgid "surrounding operators"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:232
msgid ""
"local thing=1\n"
"thing = thing-1\n"
"thing = thing*1\n"
"thing = 'string'..'s'\n"
"-- bad\n"
"\n"
"local thing = 1\n"
"thing = thing - 1\n"
"thing = thing * 1\n"
"thing = 'string' .. 's'\n"
"-- good"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:246
msgid "use space after commas in tables"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:248
msgid ""
"local thing = {1,2,3}\n"
"thing = {1 , 2 , 3}\n"
"thing = {1 ,2 ,3}\n"
"-- bad\n"
"\n"
"local thing = {1, 2, 3}\n"
"-- good"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:258
msgid "use space in map definitions around equality sign and commas"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:260
msgid ""
"return {1,2,3,4} -- bad\n"
"return {\n"
"    key1 = val1,key2=val2\n"
"} -- bad\n"
"\n"
"return {\n"
"    1, 2, 3, 4\n"
"    key1 = val1, key2 = val2,\n"
"    key3 = vallll\n"
"} -- good"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:273
msgid "also, you may use alignment:"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:275
msgid ""
"return {\n"
"    long_key  = 'vaaaaalue',\n"
"    key       = 'val',\n"
"    something = 'even better'\n"
"}"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:283
msgid ""
"extra blank lines may be used (sparingly) to separate groups of related "
"functions. Blank lines may be omitted between a bunch of related one-liners (e."
"g. a set of dummy implementations)"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:287
msgid "use blank lines in function, sparingly, to indicate logical sections"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:289
msgid ""
"if thing then\n"
"    -- ...stuff...\n"
"end\n"
"function derp()\n"
"    -- ...stuff...\n"
"end\n"
"local wat = 7\n"
"-- bad\n"
"\n"
"if thing then\n"
"    -- ...stuff...\n"
"end\n"
"\n"
"function derp()\n"
"    -- ...stuff...\n"
"end\n"
"\n"
"local wat = 7\n"
"-- good"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:311
msgid ""
"Delete whitespace at EOL (strongly forbidden. Use ``:s/\\s\\+$//gc`` in vim to "
"delete them)"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:316
msgid "Avoid global variable"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:318
msgid ""
"You must avoid global variables. If you have an exceptional case, use ``_G`` "
"variable to set it, add prefix or add table instead of prefix:"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:321
msgid ""
"function bad_global_example()\n"
"end -- very, very bad\n"
"\n"
"function good_local_example()\n"
"end\n"
"_G.modulename_good_local_example = good_local_example -- good\n"
"_G.modulename = {}\n"
"_G.modulename.good_local_example = good_local_example -- better"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:332
msgid "Always use prefix to avoid name clash"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:336
msgid "Naming"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:338
msgid "names of variables/\"objects\" and \"methods\"/functions: snake_case"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:339
msgid "names of \"classes\": CamelCase"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:340
msgid ""
"private variables/methods (properties in the future) of object starts with "
"underscores ``<object>._<name>``. Avoid using of ``local function "
"private_methods(self) end``"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:343
msgid ""
"boolean - naming ``is_<...>``, ``isnt_<...>``, ``has_``, ``hasnt_`` is a good "
"style."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:344
msgid ""
"for \"very local\" variables: - ``t`` is for tables - ``i``, ``j`` are for "
"indexing - ``n`` is for counting - ``k``, ``v`` is what you get out of "
"``pairs()`` (are acceptable, ``_`` if unused) - ``i``, ``v`` is what you get out "
"of ``ipairs()`` (are acceptable, ``_`` if unused) - ``k``/``key`` is for table "
"keys - ``v``/``val``/``value`` is for values that are passed around - ``x``/"
"``y``/``z`` is for generic math quantities - ``s``/``str``/``string`` is for "
"strings - ``c`` is for 1-char strings - ``f``/``func``/``cb`` are for functions "
"- ``status, <rv>..`` or ``ok, <rv>..`` is what you get out of pcall/xpcall - "
"``buf, sz`` is a (buffer, size) pair - ``<name>_p`` is for pointers - ``t0``.. "
"is for timestamps - ``err`` is for errors"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:361
msgid ""
"abbrevations are acceptable if they're unambigous and if you'll document (or "
"they're too common) them."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:363
msgid ""
"global variables are written with ALL_CAPS. If it's some system variable, then "
"they're using underscore to define it (``_G``/``_VERSION``/..)"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:365
msgid ""
"module naming snake_case (avoid underscores and dashes) - 'luasql', instead of "
"'Lua-SQL'"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:367
msgid "``*_mt`` and ``*_methods`` defines metatable and methods table"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:371
msgid "Idioms and patterns"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:373
msgid ""
"Always use round brackets in call of functions except multiple cases (common lua "
"style idioms):"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:376
msgid "``*.cfg{ }`` functions (``box.cfg``/``memcached.cfg``/..)"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:377
msgid "``ffi.cdef[[ ]]`` function"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:379
msgid "Avoid these kind of constructions:"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:381
msgid "<func>'<name>' (strongly avoid require'..')"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:382
msgid ""
"``function object:method() end`` (use ``functon object.method(self) end`` "
"instead)"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:383
msgid "do not use semicolon as table separator (only comma)"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:384
msgid ""
"semicolons at the end of line (only to split multiple statements on one line)"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:385
msgid "try to avoid unnecessary function creation (closures/..)"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:389
msgid "Modules"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:391
msgid ""
"Don't start modules with license/authors/descriptions, you can write it in "
"LICENSE/AUTHORS/README files. For writing modules use one of the two patterns "
"(dont use ``modules()``):"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:395
msgid ""
"local M = {}\n"
"\n"
"function M.foo()\n"
"...\n"
"end\n"
"\n"
"function M.bar()\n"
"...\n"
"end\n"
"\n"
"return M"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:411
msgid ""
"local function foo()\n"
"...\n"
"end\n"
"\n"
"local function bar()\n"
"...\n"
"end\n"
"\n"
"return {\n"
"foo = foo,\n"
"bar = bar,\n"
"}"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:428
#, fuzzy
msgid "Commenting"
msgstr "Документация"

#: ../doc/1.7/dev_guide/lua_style_guide.rst:430
msgid ""
"You should write code the way it shouldn't be described, but don't forget about "
"commenting it. You shouldn't comment Lua syntax (assume that reader already "
"knows Lua language). Try to tell about functions/variable names/etc."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:434
msgid ""
"Multiline comments: use matching (``--[[ ]]--``) instead of simple (``--[[ ]]``)."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:437
msgid "Public function comments (??):"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:439
msgid ""
"--- Copy any table (shallow and deep version)\n"
"-- * deepcopy: copies all levels\n"
"-- * shallowcopy: copies only first level\n"
"-- Supports __copy metamethod for copying custom tables with metatables\n"
"-- @function gsplit\n"
"-- @table         inp  original table\n"
"-- @shallow[opt]  sep  flag for shallow copy\n"
"-- @returns            table (copy)"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:452
msgid "Testing"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:454
msgid "Use ``tap`` module for writing efficient tests. Example of test file:"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:456
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local test = require('tap').test('table')\n"
"test:plan(31)\n"
"\n"
"do -- check basic table.copy (deepcopy)\n"
"    local example_table = {\n"
"        {1, 2, 3},\n"
"        {\"help, I'm very nested\", {{{ }}} }\n"
"    }\n"
"\n"
"    local copy_table = table.copy(example_table)\n"
"\n"
"    test:is_deeply(\n"
"        example_table,\n"
"        copy_table,\n"
"        \"checking, that deepcopy behaves ok\"\n"
"    )\n"
"    test:isnt(\n"
"        example_table,\n"
"        copy_table,\n"
"        \"checking, that tables are different\"\n"
"    )\n"
"    test:isnt(\n"
"        example_table[1],\n"
"        copy_table[1],\n"
"        \"checking, that tables are different\"\n"
"    )\n"
"    test:isnt(\n"
"        example_table[2],\n"
"        copy_table[2],\n"
"        \"checking, that tables are different\"\n"
"    )\n"
"    test:isnt(\n"
"        example_table[2][2],\n"
"        copy_table[2][2],\n"
"        \"checking, that tables are different\"\n"
"    )\n"
"    test:isnt(\n"
"        example_table[2][2][1],\n"
"        copy_table[2][2][1],\n"
"        \"checking, that tables are different\"\n"
"    )\n"
"end\n"
"\n"
"<...>\n"
"\n"
"os.exit(test:check() == true and 0 or 1)"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:507
msgid "When you'll test your code output will be something like this:"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:509
msgid ""
"TAP version 13\n"
"1..31\n"
"ok - checking, that deepcopy behaves ok\n"
"ok - checking, that tables are different\n"
"ok - checking, that tables are different\n"
"ok - checking, that tables are different\n"
"ok - checking, that tables are different\n"
"ok - checking, that tables are different\n"
"..."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:37
msgid "Python Style Guide"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:41
msgid "Introduction"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:43
msgid ""
"This document gives coding conventions for the Python code comprising the "
"standard library in the main Python distribution.  Please see the companion "
"informational PEP describing style guidelines for the C code in the C "
"implementation of Python [1]_."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:48
msgid ""
"This document and PEP 257 (Docstring Conventions) were adapted from Guido's "
"original Python Style Guide essay, with some additions from Barry's style guide "
"[2]_."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:55
msgid "A Foolish Consistency is the Hobgoblin of Little Minds"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:57
msgid ""
"One of Guido's key insights is that code is read much more often than it is "
"written.  The guidelines provided here are intended to improve the readability "
"of code and make it consistent across the wide spectrum of Python code.  As PEP "
"20 says, \"Readability counts\"."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:62
msgid ""
"A style guide is about consistency.  Consistency with this style guide is "
"important.  Consistency within a project is more important. Consistency within "
"one module or function is the most important."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:66
msgid ""
"But most importantly: know when to be inconsistent -- sometimes the style guide "
"just doesn't apply.  When in doubt, use your best judgment.  Look at other "
"examples and decide what looks best.  And don't hesitate to ask!"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:71
msgid "Two good reasons to break a particular rule:"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:73
msgid ""
"When applying the rule would make the code less readable, even for someone who "
"is used to reading code that follows the rules."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:76
msgid ""
"To be consistent with surrounding code that also breaks it (maybe for historic "
"reasons) -- although this is also an opportunity to clean up someone else's mess "
"(in true XP style)."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:83
msgid "Code lay-out"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:87
msgid "Indentation"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:89
msgid "Use 4 spaces per indentation level."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:91
msgid ""
"For really old code that you don't want to mess up, you can continue to use 8-"
"space tabs."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:94
msgid ""
"Continuation lines should align wrapped elements either vertically using "
"Python's implicit line joining inside parentheses, brackets and braces, or using "
"a hanging indent.  When using a hanging indent the following considerations "
"should be applied; there should be no arguments on the first line and further "
"indentation should be used to clearly distinguish itself as a continuation line."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:101
#: ../doc/1.7/dev_guide/python_style_guide.rst:358
#: ../doc/1.7/dev_guide/python_style_guide.rst:387
#: ../doc/1.7/dev_guide/python_style_guide.rst:406
#: ../doc/1.7/dev_guide/python_style_guide.rst:419
msgid "Yes::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:103
msgid ""
"# Aligned with opening delimiter\n"
"foo = long_function_name(var_one, var_two,\n"
"                         var_three, var_four)\n"
"\n"
"# More indentation included to distinguish this from the rest.\n"
"def long_function_name(\n"
"        var_one, var_two, var_three,\n"
"        var_four):\n"
"    print(var_one)"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:113
#: ../doc/1.7/dev_guide/python_style_guide.rst:364
#: ../doc/1.7/dev_guide/python_style_guide.rst:395
#: ../doc/1.7/dev_guide/python_style_guide.rst:411
msgid "No::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:115
msgid ""
"# Arguments on first line forbidden when not using vertical alignment\n"
"foo = long_function_name(var_one, var_two,\n"
"    var_three, var_four)\n"
"\n"
"# Further indentation required as indentation is not distinguishable\n"
"def long_function_name(\n"
"    var_one, var_two, var_three,\n"
"    var_four):\n"
"    print(var_one)"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:125
msgid "Optional::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:127
msgid ""
"# Extra indentation is not necessary.\n"
"foo = long_function_name(\n"
"  var_one, var_two,\n"
"  var_three, var_four)"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:132
msgid ""
"The closing brace/bracket/parenthesis on multi-line constructs may either line "
"up under the first non-whitespace character of the last line of list, as in::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:136
msgid ""
"my_list = [\n"
"    1, 2, 3,\n"
"    4, 5, 6,\n"
"    ]\n"
"result = some_function_that_takes_arguments(\n"
"    'a', 'b', 'c',\n"
"    'd', 'e', 'f',\n"
"    )"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:145
msgid ""
"or it may be lined up under the first character of the line that starts the "
"multi-line construct, as in::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:148
msgid ""
"my_list = [\n"
"    1, 2, 3,\n"
"    4, 5, 6,\n"
"]\n"
"result = some_function_that_takes_arguments(\n"
"    'a', 'b', 'c',\n"
"    'd', 'e', 'f',\n"
")"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:160
msgid "Tabs or Spaces?"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:162
msgid "Never mix tabs and spaces."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:164
msgid ""
"The most popular way of indenting Python is with spaces only.  The second-most "
"popular way is with tabs only.  Code indented with a mixture of tabs and spaces "
"should be converted to using spaces exclusively.  When invoking the Python "
"command line interpreter with the ``-t`` option, it issues warnings about code "
"that illegally mixes tabs and spaces.  When using ``-tt`` these warnings become "
"errors. These options are highly recommended!"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:172
msgid ""
"For new projects, spaces-only are strongly recommended over tabs. Most editors "
"have features that make this easy to do."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:177
msgid "Maximum Line Length"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:179
msgid "Limit all lines to a maximum of 79 characters."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:181
msgid ""
"There are still many devices around that are limited to 80 character lines; "
"plus, limiting windows to 80 characters makes it possible to have several "
"windows side-by-side.  The default wrapping on such devices disrupts the visual "
"structure of the code, making it more difficult to understand.  Therefore, "
"please limit all lines to a maximum of 79 characters.  For flowing long blocks "
"of text (docstrings or comments), limiting the length to 72 characters is "
"recommended."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:189
msgid ""
"The preferred way of wrapping long lines is by using Python's implied line "
"continuation inside parentheses, brackets and braces.  Long lines can be broken "
"over multiple lines by wrapping expressions in parentheses. These should be used "
"in preference to using a backslash for line continuation."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:195
msgid ""
"Backslashes may still be appropriate at times.  For example, long, multiple "
"``with``-statements cannot use implicit continuation, so backslashes are "
"acceptable::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:199
msgid ""
"with open('/path/to/some/file/you/want/to/read') as file_1, \\\n"
"        open('/path/to/some/file/being/written', 'w') as file_2:\n"
"    file_2.write(file_1.read())"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:203
msgid "Another such case is with ``assert`` statements."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:205
msgid ""
"Make sure to indent the continued line appropriately.  The preferred place to "
"break around a binary operator is *after* the operator, not before it.  Some "
"examples::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:209
#, python-format
msgid ""
"class Rectangle(Blob):\n"
"\n"
"    def __init__(self, width, height,\n"
"                 color='black', emphasis=None, highlight=0):\n"
"        if (width == 0 and height == 0 and\n"
"            color == 'red' and emphasis == 'strong' or\n"
"            highlight > 100):\n"
"            raise ValueError(\"sorry, you lose\")\n"
"        if width == 0 and height == 0 and (color == 'red' or\n"
"                                           emphasis is None):\n"
"            raise ValueError(\"I don't think so -- values are %s, %s\" %\n"
"                             (width, height))\n"
"        Blob.__init__(self, width, height,\n"
"                      color, emphasis, highlight)"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:226
msgid "Blank Lines"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:228
msgid "Separate top-level function and class definitions with two blank lines."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:231
msgid "Method definitions inside a class are separated by a single blank line."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:234
msgid ""
"Extra blank lines may be used (sparingly) to separate groups of related "
"functions.  Blank lines may be omitted between a bunch of related one-liners (e."
"g. a set of dummy implementations)."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:238
msgid "Use blank lines in functions, sparingly, to indicate logical sections."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:240
msgid ""
"Python accepts the control-L (i.e. ^L) form feed character as whitespace; Many "
"tools treat these characters as page separators, so you may use them to separate "
"pages of related sections of your file. Note, some editors and web-based code "
"viewers may not recognize control-L as a form feed and will show another glyph "
"in its place."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:248
msgid "Encodings (PEP 263)"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:250
msgid ""
"Code in the core Python distribution should always use the ASCII or Latin-1 "
"encoding (a.k.a. ISO-8859-1).  For Python 3.0 and beyond, UTF-8 is preferred "
"over Latin-1, see PEP 3120."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:254
msgid ""
"Files using ASCII should not have a coding cookie.  Latin-1 (or UTF-8) should "
"only be used when a comment or docstring needs to mention an author name that "
"requires Latin-1; otherwise, using ``\\x``, ``\\u`` or ``\\U`` escapes is the "
"preferred way to include non-ASCII data in string literals."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:260
msgid ""
"For Python 3.0 and beyond, the following policy is prescribed for the standard "
"library (see PEP 3131): All identifiers in the Python standard library MUST use "
"ASCII-only identifiers, and SHOULD use English words wherever feasible (in many "
"cases, abbreviations and technical terms are used which aren't English). In "
"addition, string literals and comments must also be in ASCII. The only "
"exceptions are (a) test cases testing the non-ASCII features, and (b) names of "
"authors. Authors whose names are not based on the latin alphabet MUST provide a "
"latin transliteration of their names."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:271
msgid ""
"Open source projects with a global audience are encouraged to adopt a similar "
"policy."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:277
msgid "Imports"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:279
msgid "Imports should usually be on separate lines, e.g.::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:286
msgid "It's okay to say this though::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:290
msgid ""
"Imports are always put at the top of the file, just after any module comments "
"and docstrings, and before module globals and constants."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:293
msgid "Imports should be grouped in the following order:"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:295
msgid "standard library imports"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:296
msgid "related third party imports"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:297
msgid "local application/library specific imports"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:299
msgid "You should put a blank line between each group of imports."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:301
msgid "Put any relevant ``__all__`` specification after the imports."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:303
msgid ""
"Relative imports for intra-package imports are highly discouraged. Always use "
"the absolute package path for all imports.  Even now that PEP 328 is fully "
"implemented in Python 2.5, its style of explicit relative imports is actively "
"discouraged; absolute imports are more portable and usually more readable."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:309
msgid ""
"When importing a class from a class-containing module, it's usually okay to "
"spell this::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:315
msgid "If this spelling causes local name clashes, then spell them ::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:320
msgid "and use \"myclass.MyClass\" and \"foo.bar.yourclass.YourClass\"."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:325
msgid "Whitespace in Expressions and Statements"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:329
msgid "Pet Peeves"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:331
msgid "Avoid extraneous whitespace in the following situations:"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:333
msgid "Immediately inside parentheses, brackets or braces. ::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:338
msgid "Immediately before a comma, semicolon, or colon::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:343
msgid ""
"Immediately before the open parenthesis that starts the argument list of a "
"function call::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:349
msgid ""
"Immediately before the open parenthesis that starts an indexing or slicing::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:355
msgid ""
"More than one space around an assignment (or other) operator to align it with "
"another."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:373
msgid "Other Recommendations"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:375
msgid ""
"Always surround these binary operators with a single space on either side: "
"assignment (``=``), augmented assignment (``+=``, ``-=`` etc.), comparisons "
"(``==``, ``<``, ``>``, ``!=``, ``<>``, ``<=``, ``>=``, ``in``, ``not in``, "
"``is``, ``is not``), Booleans (``and``, ``or``, ``not``)."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:381
msgid ""
"If operators with different priorities are used, consider adding whitespace "
"around the operators with the lowest priority(ies). Use your own judgement; "
"however, never use more than one space, and always have the same amount of "
"whitespace on both sides of a binary operator."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:403
msgid ""
"Don't use spaces around the ``=`` sign when used to indicate a keyword argument "
"or a default parameter value."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:416
msgid ""
"Compound statements (multiple statements on the same line) are generally "
"discouraged."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:427
#: ../doc/1.7/dev_guide/python_style_guide.rst:436
msgid "Rather not::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:432
msgid ""
"While sometimes it's okay to put an if/for/while with a small body on the same "
"line, never do this for multi-clause statements.  Also avoid folding such long "
"lines!"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:442
msgid "Definitely not::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:457
msgid "Comments"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:459
msgid ""
"Comments that contradict the code are worse than no comments.  Always make a "
"priority of keeping the comments up-to-date when the code changes!"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:463
msgid ""
"Comments should be complete sentences.  If a comment is a phrase or sentence, "
"its first word should be capitalized, unless it is an identifier that begins "
"with a lower case letter (never alter the case of identifiers!)."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:468
msgid ""
"If a comment is short, the period at the end can be omitted.  Block comments "
"generally consist of one or more paragraphs built out of complete sentences, and "
"each sentence should end in a period."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:472
msgid "You should use two spaces after a sentence-ending period."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:474
msgid "When writing English, Strunk and White apply."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:476
#, python-format
msgid ""
"Python coders from non-English speaking countries: please write your comments in "
"English, unless you are 120% sure that the code will never be read by people who "
"don't speak your language."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:482
msgid "Block Comments"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:484
msgid ""
"Block comments generally apply to some (or all) code that follows them, and are "
"indented to the same level as that code.  Each line of a block comment starts "
"with a ``#`` and a single space (unless it is indented text inside the comment)."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:489
msgid ""
"Paragraphs inside a block comment are separated by a line containing a single "
"``#``."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:494
msgid "Inline Comments"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:496
msgid "Use inline comments sparingly."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:498
msgid ""
"An inline comment is a comment on the same line as a statement. Inline comments "
"should be separated by at least two spaces from the statement.  They should "
"start with a # and a single space."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:502
msgid ""
"Inline comments are unnecessary and in fact distracting if they state the "
"obvious.  Don't do this::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:505
msgid "x = x + 1                 # Increment x"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:507
msgid "But sometimes, this is useful::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:509
msgid "x = x + 1                 # Compensate for border"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:513
msgid "Documentation Strings"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:515
msgid ""
"Conventions for writing good documentation strings (a.k.a. \"docstrings\") are "
"immortalized in PEP 257."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:518
msgid ""
"Write docstrings for all public modules, functions, classes, and methods.  "
"Docstrings are not necessary for non-public methods, but you should have a "
"comment that describes what the method does.  This comment should appear after "
"the ``def`` line."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:523
msgid ""
"PEP 257 describes good docstring conventions.  Note that most importantly, the ``"
"\"\"\"`` that ends a multiline docstring should be on a line by itself, and "
"preferably preceded by a blank line, e.g.::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:533
msgid ""
"For one liner docstrings, it's okay to keep the closing ``\"\"\"`` on the same "
"line."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:539
msgid "Version Bookkeeping"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:541
msgid ""
"If you have to have Subversion, CVS, or RCS crud in your source file, do it as "
"follows. ::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:544
msgid ""
"__version__ = \"$Revision$\"\n"
"# $Source$"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:547
msgid ""
"These lines should be included after the module's docstring, before any other "
"code, separated by a blank line above and below."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:553
msgid "Naming Conventions"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:555
msgid ""
"The naming conventions of Python's library are a bit of a mess, so we'll never "
"get this completely consistent -- nevertheless, here are the currently "
"recommended naming standards.  New modules and packages (including third party "
"frameworks) should be written to these standards, but where an existing library "
"has a different style, internal consistency is preferred."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:564
msgid "Descriptive: Naming Styles"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:566
msgid ""
"There are a lot of different naming styles.  It helps to be able to recognize "
"what naming style is being used, independently from what they are used for."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:570
msgid "The following naming styles are commonly distinguished:"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:572
msgid "``b`` (single lowercase letter)"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:573
msgid "``B`` (single uppercase letter)"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:574
msgid "``lowercase``"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:575
msgid "``lower_case_with_underscores``"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:576
msgid "``UPPERCASE``"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:577
msgid "``UPPER_CASE_WITH_UNDERSCORES``"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:578
msgid ""
"``CapitalizedWords`` (or CapWords, or CamelCase -- so named because of the bumpy "
"look of its letters [3]_).  This is also sometimes known as StudlyCaps."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:582
msgid ""
"Note: When using abbreviations in CapWords, capitalize all the letters of the "
"abbreviation.  Thus HTTPServerError is better than HttpServerError."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:585
msgid ""
"``mixedCase`` (differs from CapitalizedWords by initial lowercase character!)"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:587
msgid "``Capitalized_Words_With_Underscores`` (ugly!)"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:589
msgid ""
"There's also the style of using a short unique prefix to group related names "
"together.  This is not used much in Python, but it is mentioned for "
"completeness.  For example, the ``os.stat()`` function returns a tuple whose "
"items traditionally have names like ``st_mode``, ``st_size``, ``st_mtime`` and "
"so on.  (This is done to emphasize the correspondence with the fields of the "
"POSIX system call struct, which helps programmers familiar with that.)"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:597
msgid ""
"The X11 library uses a leading X for all its public functions.  In Python, this "
"style is generally deemed unnecessary because attribute and method names are "
"prefixed with an object, and function names are prefixed with a module name."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:602
msgid ""
"In addition, the following special forms using leading or trailing underscores "
"are recognized (these can generally be combined with any case convention):"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:606
msgid ""
"``_single_leading_underscore``: weak \"internal use\" indicator. E.g. ``from M "
"import *`` does not import objects whose name starts with an underscore."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:610
msgid ""
"``single_trailing_underscore_``: used by convention to avoid conflicts with "
"Python keyword, e.g. ::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:615
msgid ""
"``__double_leading_underscore``: when naming a class attribute, invokes name "
"mangling (inside class FooBar, ``__boo`` becomes ``_FooBar__boo``; see below)."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:619
msgid ""
"``__double_leading_and_trailing_underscore__``: \"magic\" objects or attributes "
"that live in user-controlled namespaces. E.g. ``__init__``, ``__import__`` or "
"``__file__``.  Never invent such names; only use them as documented."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:626
msgid "Prescriptive: Naming Conventions"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:630
msgid "Names to Avoid"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:632
msgid ""
"Never use the characters 'l' (lowercase letter el), 'O' (uppercase letter oh), "
"or 'I' (uppercase letter eye) as single character variable names."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:636
msgid ""
"In some fonts, these characters are indistinguishable from the numerals one and "
"zero.  When tempted to use 'l', use 'L' instead."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:641
msgid "Package and Module Names"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:643
msgid ""
"Modules should have short, all-lowercase names.  Underscores can be used in the "
"module name if it improves readability.  Python packages should also have short, "
"all-lowercase names, although the use of underscores is discouraged."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:648
msgid ""
"Since module names are mapped to file names, and some file systems are case "
"insensitive and truncate long names, it is important that module names be chosen "
"to be fairly short -- this won't be a problem on Unix, but it may be a problem "
"when the code is transported to older Mac or Windows versions, or DOS."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:654
msgid ""
"When an extension module written in C or C++ has an accompanying Python module "
"that provides a higher level (e.g. more object oriented) interface, the C/C++ "
"module has a leading underscore (e.g. ``_socket``)."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:661
msgid "Class Names"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:663
msgid ""
"Almost without exception, class names use the CapWords convention. Classes for "
"internal use have a leading underscore in addition."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:668
msgid "Exception Names"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:670
msgid ""
"Because exceptions should be classes, the class naming convention applies here.  "
"However, you should use the suffix \"Error\" on your exception names (if the "
"exception actually is an error)."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:676
msgid "Global Variable Names"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:678
msgid ""
"(Let's hope that these variables are meant for use inside one module only.)  The "
"conventions are about the same as those for functions."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:681
msgid ""
"Modules that are designed for use via ``from M import *`` should use the "
"``__all__`` mechanism to prevent exporting globals, or use the older convention "
"of prefixing such globals with an underscore (which you might want to do to "
"indicate these globals are \"module non-public\")."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:689
msgid "Function Names"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:691
msgid ""
"Function names should be lowercase, with words separated by underscores as "
"necessary to improve readability."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:694
msgid ""
"mixedCase is allowed only in contexts where that's already the prevailing style "
"(e.g. threading.py), to retain backwards compatibility."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:700
msgid "Function and method arguments"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:702
msgid "Always use ``self`` for the first argument to instance methods."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:704
msgid "Always use ``cls`` for the first argument to class methods."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:706
msgid ""
"If a function argument's name clashes with a reserved keyword, it is generally "
"better to append a single trailing underscore rather than use an abbreviation or "
"spelling corruption.  Thus ``class_`` is better than ``clss``.  (Perhaps better "
"is to avoid such clashes by using a synonym.)"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:714
msgid "Method Names and Instance Variables"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:716
msgid ""
"Use the function naming rules: lowercase with words separated by underscores as "
"necessary to improve readability."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:719
msgid ""
"Use one leading underscore only for non-public methods and instance variables."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:722
msgid ""
"To avoid name clashes with subclasses, use two leading underscores to invoke "
"Python's name mangling rules."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:725
msgid ""
"Python mangles these names with the class name: if class Foo has an attribute "
"named ``__a``, it cannot be accessed by ``Foo.__a``.  (An insistent user could "
"still gain access by calling ``Foo._Foo__a``.) Generally, double leading "
"underscores should be used only to avoid name conflicts with attributes in "
"classes designed to be subclassed."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:731
msgid "Note: there is some controversy about the use of __names (see below)."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:735
msgid "Constants"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:737
msgid ""
"Constants are usually defined on a module level and written in all capital "
"letters with underscores separating words.  Examples include ``MAX_OVERFLOW`` "
"and ``TOTAL``."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:743
msgid "Designing for inheritance"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:745
msgid ""
"Always decide whether a class's methods and instance variables (collectively: "
"\"attributes\") should be public or non-public.  If in doubt, choose non-public; "
"it's easier to make it public later than to make a public attribute non-public."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:750
msgid ""
"Public attributes are those that you expect unrelated clients of your class to "
"use, with your commitment to avoid backward incompatible changes.  Non-public "
"attributes are those that are not intended to be used by third parties; you make "
"no guarantees that non-public attributes won't change or even be removed."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:756
msgid ""
"We don't use the term \"private\" here, since no attribute is really private in "
"Python (without a generally unnecessary amount of work)."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:759
msgid ""
"Another category of attributes are those that are part of the \"subclass API"
"\" (often called \"protected\" in other languages).  Some classes are designed "
"to be inherited from, either to extend or modify aspects of the class's "
"behavior.  When designing such a class, take care to make explicit decisions "
"about which attributes are public, which are part of the subclass API, and which "
"are truly only to be used by your base class."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:767
msgid "With this in mind, here are the Pythonic guidelines:"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:769
msgid "Public attributes should have no leading underscores."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:771
msgid ""
"If your public attribute name collides with a reserved keyword, append a single "
"trailing underscore to your attribute name.  This is preferable to an "
"abbreviation or corrupted spelling.  (However, not withstanding this rule, 'cls' "
"is the preferred spelling for any variable or argument which is known to be a "
"class, especially the first argument to a class method.)"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:779
#: ../doc/1.7/dev_guide/python_style_guide.rst:790
#: ../doc/1.7/dev_guide/python_style_guide.rst:812
msgid "Note 1:"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:779
msgid "See the argument name recommendation above for class methods."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:781
msgid ""
"For simple public data attributes, it is best to expose just the attribute name, "
"without complicated accessor/mutator methods.  Keep in mind that Python provides "
"an easy path to future enhancement, should you find that a simple data attribute "
"needs to grow functional behavior.  In that case, use properties to hide "
"functional implementation behind simple data attribute access syntax."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:790
msgid "Properties only work on new-style classes."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:794
#: ../doc/1.7/dev_guide/python_style_guide.rst:817
msgid "Note 2:"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:793
msgid ""
"Try to keep the functional behavior side-effect free, although side-effects such "
"as caching are generally fine."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:799
#: ../doc/1.7/dev_guide/python_style_guide.rst:822
msgid "Note 3:"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:797
msgid ""
"Avoid using properties for computationally expensive operations; the attribute "
"notation makes the caller believe that access is (relatively) cheap."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:801
msgid ""
"If your class is intended to be subclassed, and you have attributes that you do "
"not want subclasses to use, consider naming them with double leading underscores "
"and no trailing underscores.  This invokes Python's name mangling algorithm, "
"where the name of the class is mangled into the attribute name.  This helps "
"avoid attribute name collisions should subclasses inadvertently contain "
"attributes with the same name."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:810
msgid ""
"Note that only the simple class name is used in the mangled name, so if a "
"subclass chooses both the same class name and attribute name, you can still get "
"name collisions."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:815
msgid ""
"Name mangling can make certain uses, such as debugging and ``__getattr__()``, "
"less convenient.  However the name mangling algorithm is well documented and "
"easy to perform manually."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:820
msgid ""
"Not everyone likes name mangling.  Try to balance the need to avoid accidental "
"name clashes with potential use by advanced callers."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:826
msgid "References"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:828
msgid ""
"`PEP 7, Style Guide for C Code, van Rossum <https://www.python.org/dev/peps/"
"pep-0007/>`_"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:829
msgid ""
"`Barry's GNU Mailman style guide <http://barry.warsaw.us/software/STYLEGUIDE."
"txt>`_"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:830
msgid "`CamelCase Wikipedia page <http://www.wikipedia.com/wiki/CamelCase>`_"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:834
msgid "Copyright"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:836
msgid "Author:"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:838
msgid "Guido van Rossum <guido@python.org>"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:839
msgid "Barry Warsaw <barry@python.org>"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:37
#: ../doc/1.7/reference/reference_lua/box.rst:39
msgid "Module `box`"
msgstr "Модуль `box`"

#: ../doc/1.7/dev_guide/reference_capi/box.rst:41
msgid "Opaque structure passed to the stored C procedure"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:45
msgid "Return a tuple from stored C procedure."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:47
msgid "Returned tuple is automatically reference counted by Tarantool."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:49
msgid "an opaque structure passed to the stored C procedure by Tarantool"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:51
msgid "a tuple to return"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst
#: ../doc/1.7/dev_guide/reference_capi/coio.rst
#: ../doc/1.7/dev_guide/reference_capi/error.rst
#: ../doc/1.7/dev_guide/reference_capi/fiber.rst
#: ../doc/1.7/dev_guide/reference_capi/latch.rst
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst
#: ../doc/1.7/dev_guide/reference_capi/txn.rst
#: ../doc/1.7/dev_guide/reference_capi/utils.rst
msgid "Returns"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:53
msgid ""
"-1 on error (perhaps, out of memory; check :ref:`box_error_last()<c_api-error-"
"box_error_last>`)"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:55
#: ../doc/1.7/dev_guide/reference_capi/box.rst:103
#: ../doc/1.7/dev_guide/reference_capi/box.rst:118
#: ../doc/1.7/dev_guide/reference_capi/box.rst:134
#: ../doc/1.7/dev_guide/reference_capi/box.rst:156
#: ../doc/1.7/dev_guide/reference_capi/box.rst:178
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:91
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:104
msgid "0 otherwise"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:61
msgid "Find space id by name."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:63
msgid "This function performs SELECT request to _vspace system space."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:65
msgid "space name"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:66
#: ../doc/1.7/dev_guide/reference_capi/box.rst:80
msgid "length of ``name``"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:68
#: ../doc/1.7/dev_guide/reference_capi/box.rst:82
msgid ""
":c:macro:`BOX_ID_NIL` on error or if not found (check :ref:"
"`box_error_last()<c_api-error-box_error_last>`)"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:70
#: ../doc/1.7/dev_guide/reference_capi/box.rst:84
msgid "space_id otherwise"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:72
msgid "See also: :c:type:`box_index_id_by_name`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:76
msgid "Find index id by name."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:78
#: ../doc/1.7/dev_guide/reference_capi/box.rst:96
#: ../doc/1.7/dev_guide/reference_capi/box.rst:111
#: ../doc/1.7/dev_guide/reference_capi/box.rst:126
#: ../doc/1.7/dev_guide/reference_capi/box.rst:142
#: ../doc/1.7/dev_guide/reference_capi/box.rst:164
#: ../doc/1.7/dev_guide/reference_capi/box.rst:186
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:119
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:163
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:173
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:183
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:202
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:218
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:234
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:250
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:268
msgid "space identifier"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:79
msgid "index name"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:86
msgid "This function performs SELECT request to _vindex system space."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:88
msgid "See also: :c:type:`box_space_id_by_name`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:94
msgid "Execute an INSERT/REPLACE request."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:97
#: ../doc/1.7/dev_guide/reference_capi/box.rst:112
#: ../doc/1.7/dev_guide/reference_capi/box.rst:166
msgid "encoded tuple in MsgPack Array format ([ field1, field2, ...])"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:98
#: ../doc/1.7/dev_guide/reference_capi/box.rst:113
#: ../doc/1.7/dev_guide/reference_capi/box.rst:167
msgid "end of a ``tuple``"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:99
#: ../doc/1.7/dev_guide/reference_capi/box.rst:114
msgid "output argument. Resulted tuple. Can be set to NULL to discard result"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:102
#: ../doc/1.7/dev_guide/reference_capi/box.rst:117
#: ../doc/1.7/dev_guide/reference_capi/box.rst:133
#: ../doc/1.7/dev_guide/reference_capi/box.rst:155
msgid "-1 on error (check :ref:`box_error_last()<c_api-error-box_error_last>`)"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:105
msgid "See also :ref:`space_object.insert()<box_space-insert>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:109
msgid "Execute an REPLACE request."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:120
msgid "See also :ref:`space_object.replace()<box_space-replace>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:124
msgid "Execute a DELETE request."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:127
#: ../doc/1.7/dev_guide/reference_capi/box.rst:143
#: ../doc/1.7/dev_guide/reference_capi/box.rst:165
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:120
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:164
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:174
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:184
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:203
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:219
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:235
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:251
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:269
msgid "index identifier"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:128
#: ../doc/1.7/dev_guide/reference_capi/box.rst:144
msgid "encoded key in MsgPack Array format ([ field1, field2, ...])"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:129
#: ../doc/1.7/dev_guide/reference_capi/box.rst:145
msgid "end of a ``key``"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:130
#: ../doc/1.7/dev_guide/reference_capi/box.rst:152
#: ../doc/1.7/dev_guide/reference_capi/box.rst:174
msgid "output argument. Result an old tuple. Can be set to NULL to discard result"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:136
msgid "See also :ref:`space_object.delete()<box_space-delete>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:140
msgid "Execute an UPDATE request."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:146
#: ../doc/1.7/dev_guide/reference_capi/box.rst:168
msgid ""
"encoded operations in MsgPack Arrat format, e.g. ``[[ '=', field_id,  value ], "
"['!', 2, 'xxx']]``"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:148
#: ../doc/1.7/dev_guide/reference_capi/box.rst:170
msgid "end of a ``ops``"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:149
#: ../doc/1.7/dev_guide/reference_capi/box.rst:171
msgid ""
"0 if field_ids in update operation are zero-based indexed (like C) or 1 if for "
"one-based indexed field ids (like Lua)."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:158
msgid "See also :ref:`space_object.update()<box_space-update>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:162
msgid "Execute an UPSERT request."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:177
msgid "-1 on error (check ::ref:`box_error_last()<c_api-error-box_error_last>`)"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:180
msgid "See also :ref:`space_object.upsert()<box_space-upsert>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:184
msgid "Truncate space."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:37
msgid "Module `index`"
msgstr "Модуль `index`"

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:41
msgid "A space iterator"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:47
msgid ""
"Controls how to iterate over tuples in an index. Different index types support "
"different iterator types. For example, one can start iteration from a particular "
"value (request key) and then retrieve all tuples where keys are greater or equal "
"(= GE) to this key."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:52
msgid ""
"If iterator type is not supported by the selected index type, iterator "
"constructor must fail with ER_UNSUPPORTED. To be selectable for primary key, an "
"index must support at least ITER_EQ and ITER_GE types."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:56
msgid ""
"NULL value of request key corresponds to the first or last key in the index, "
"depending on iteration direction. (first key for GE and GT types, and last key "
"for LE and LT). Therefore, to iterate over all tuples in an index, one can use "
"ITER_GE or ITER_LE iteration types with start key equal to NULL. For ITER_EQ, "
"the key must not be NULL."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:64
msgid "key == x ASC order"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:68
msgid "key == x DESC order"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:72
msgid "all tuples"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:76
msgid "key < x"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:80
msgid "key <= x"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:84
msgid "key >= x"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:88
msgid "key > x"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:92
msgid "all bits from x are set in key"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:96
msgid "at least one x's bit is set"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:100
msgid "all bits are not set"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:104
msgid "key overlaps x"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:108
msgid "tuples in distance ascending order from specified point"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:114
msgid "Allocate and initialize iterator for space_id, index_id."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:116
msgid ""
"The returned iterator must be destroyed by :ref:`box_iterator_free<c_api-"
"box_index-box_iterator_free>`."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:121
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:252
msgid ":ref:`iterator_type<c_api-box_index-iterator_type>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:122
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:204
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:220
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:236
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:253
msgid "encode key in MsgPack Array format ([part1, part2, ...])"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:123
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:205
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:221
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:237
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:254
msgid "the end of encoded ``key``"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:125
msgid "NULL on error (check :ref:`box_error_last <c_api-error-box_error_last>`)"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:126
msgid "iterator otherwise"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:128
msgid ""
"See also :ref:`box_iterator_next<c_api-box_index-box_iterator_next>`, :ref:"
"`box_iterator_free<c_api-box_index-box_iterator_free>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:135
msgid "Retrieve the next item from the ``iterator``."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:137
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:151
msgid ""
"an iterator returned by :ref:`box_index_iterator <c_api-box_index-"
"box_index_iterator>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:139
msgid "output argument. result a tuple or NULL if there is no more data."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:142
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:166
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:176
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:209
msgid "-1 on error (check :ref:`box_error_last <c_api-error-box_error_last>`)"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:143
msgid "0 on success. The end of data is not an error."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:149
msgid "Destroy and deallocate iterator."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:156
msgid ""
"Determine a direction of the given iterator type: -1 for REQ, LT, LE, and +1 for "
"all others."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:161
msgid "Return the number of element in the index."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:167
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:177
msgid ">= 0 otherwise"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:171
msgid "Return the number of bytes used in memory by the index."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:181
msgid "Return a random tuple from the index (useful for statistical analysis)."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:185
msgid "random seed"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:186
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:206
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:222
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:238
msgid "output argument. result a tuple or NULL if there is no tuples in space"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:189
msgid "See also: :ref:`index_object.random<box_index-random>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:195
msgid "Get a tuple from index by the key."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:197
msgid ""
"Please note that this function works much more faster than :ref:`index_object."
"select<box_index-select>` or :ref:`box_index_iterator<c_api-box_index-"
"box_index_iterator>` + :ref:`box_iterator_next<c_api-box_index-"
"box_iterator_next>`."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:210
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:226
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:242
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:257
#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:206
#: ../doc/1.7/dev_guide/reference_capi/txn.rst:50
#: ../doc/1.7/dev_guide/reference_capi/txn.rst:57
#: ../doc/1.7/dev_guide/reference_capi/utils.rst:99
msgid "0 on success"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:212
msgid "See also: ``index_object.get()``"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:216
msgid "Return a first (minimal) tuple matched the provided key."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:225
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:241
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:256
msgid "-1 on error (check :ref:`box_error_last() <c_api-error-box_error_last>`)"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:228
msgid "See also: :ref:`index_object.min()<box_index-min>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:232
msgid "Return a last (maximal) tuple matched the provided key."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:244
msgid "See also: :ref:`index_object.max()<box_index-max>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:248
msgid "Count the number of tuple matched the provided key."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:259
msgid "See also: :ref:`index_object.count()<box_index-count>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:264
msgid "Return :ref:`key definition <capi-tuple_key_def>` for an index"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:266
msgid "Returned object is valid until the next yield."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:271
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:195
msgid "key definition on success"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:272
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:196
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:214
msgid "NULL on error"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:274
msgid "See also: :ref:`box_tuple_compare() <capi-tuple_box_tuple_compare>`,"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:275
msgid ":ref:`box_tuple_format_new() <capi-tuple_box_tuple_format_new>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/clock.rst:37
#: ../doc/1.7/reference/reference_lua/clock.rst:39
msgid "Module `clock`"
msgstr "Модуль `clock`"

#: ../doc/1.7/dev_guide/reference_capi/coio.rst:37
msgid "Module `coio`"
msgstr "Модуль `coio`"

#: ../doc/1.7/dev_guide/reference_capi/coio.rst:43
msgid "READ event"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/coio.rst:47
msgid "WRITE event"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/coio.rst:53
msgid "Wait until READ or WRITE event on socket (``fd``). Yields."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/coio.rst:55
#: ../doc/1.7/dev_guide/reference_capi/coio.rst:104
msgid "non-blocking socket file description"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/coio.rst:56
msgid ""
"requested events to wait. Combination of ``COIO_READ | COIO_WRITE`` bit flags."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/coio.rst:58
msgid "timeout in seconds."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/coio.rst:60
msgid "0 - timeout"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/coio.rst:61
msgid ""
">0 - returned events. Combination of ``TNT_IO_READ | TNT_IO_WRITE`` bit flags."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/coio.rst:67
msgid ""
"Create new eio task with specified function and arguments. Yield and wait until "
"the task is complete or a timeout occurs. This function may use the :ref:"
"`worker_pool_threads <cfg_basic-worker_pool_threads>` configuration parameter."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/coio.rst:72
msgid ""
"To avoid double error checking, this function does not throw exceptions. In most "
"cases it is also necessary to check the return value of the called function and "
"perform necessary actions. If func sets errno, the errno is preserved across the "
"call."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/coio.rst:77
msgid "-1 and ``errno`` = ENOMEM if failed to create a task"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/coio.rst:78
msgid "the function return (``errno`` is preserved)."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/coio.rst:82
msgid ""
"static ssize_t openfile_cb(va_list ap)\n"
"{\n"
"        const char* filename = va_arg(ap);\n"
"        int flags = va_arg(ap);\n"
"        return open(filename, flags);\n"
"}\n"
"\n"
"if (coio_call(openfile_cb, 0.10, \"/tmp/file\", 0) == -1)\n"
"    // handle errors.\n"
"..."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/coio.rst:97
msgid "Fiber-friendly version of :manpage:`getaddrinfo(3)`."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/coio.rst:101
msgid ""
"Close the ``fd`` and wake any fiber blocked in :ref:`coio_wait() <c_api-coio-"
"coio_wait>` call on this ``fd``."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/coio.rst:106
msgid "the result of ``close(fd)``, see :manpage:`close(2)`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:37
msgid "Module `error`"
msgstr "Модуль `error`"

#: ../doc/1.7/dev_guide/reference_capi/error.rst:187
msgid "Error - contains information about error."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:191
msgid "Return the error type, e.g. \"ClientError\", \"SocketError\", etc."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:193
#: ../doc/1.7/dev_guide/reference_capi/error.rst:200
#: ../doc/1.7/dev_guide/reference_capi/error.rst:207
msgid "error"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:194
#: ../doc/1.7/dev_guide/reference_capi/error.rst:208
msgid "not-null string"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:198
msgid "Return IPROTO error code"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:201
msgid "enum :ref:`box_error_code <capi-box_error_code>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:205
msgid "Return the error message"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:214
msgid "Get the information about the last API call error."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:216
msgid ""
"The Tarantool error handling works most like libc's errno. All API calls return "
"-1 or NULL in the event of error. An internal pointer to box_error_t type is set "
"by API functions to indicate what went wrong. This value is only significant if "
"API call failed (returned -1 or NULL)."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:221
msgid ""
"Successful function can also touch the last error in some cases. You don't have "
"to clear the last error before calling API functions. The returned object is "
"valid only until next call to **any** API function."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:225
msgid ""
"You must set the last error using box_error_set() in your stored C procedures if "
"you want to return a custom error message. You can re-throw the last API error "
"to IPROTO client by keeping the current value and returning -1 to Tarantool from "
"your stored procedure."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:230
msgid "last error"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:234
msgid "Clear the last error."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:238
msgid "Set the last error."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:242
msgid "IPROTO :ref:`error code<capi-box_error_code>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:244
#: ../doc/1.7/dev_guide/reference_capi/say.rst:67
#: ../doc/1.7/dev_guide/reference_capi/say.rst:82
msgid "format arguments"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:246
msgid "See also: IPROTO :ref:`error code<capi-box_error_code>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:250
msgid "A backward-compatible API define."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:37
#: ../doc/1.7/reference/reference_lua/fiber.rst:39
msgid "Module `fiber`"
msgstr "Модуль `fiber`"

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:41
msgid ""
"Fiber - contains information about a :ref:`fiber <atomic-threads_fibers_yields>`."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:45
msgid "Function to run inside a fiber."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:49
msgid "Create a new fiber."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:51
msgid ""
"Takes a fiber from the fiber cache, if it's not empty. Can fail only if there is "
"not enough memory for the fiber structure or fiber stack."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:54
msgid ""
"The created fiber automatically returns itself to the fiber cache when its \"main"
"\" function completes."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:57
#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:73
msgid "string with fiber name"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:58
msgid "func for run inside fiber"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:60
#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:77
msgid "See also: :ref:`fiber_start()<c_api-fiber-fiber_start>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:64
msgid "Create a new fiber with defined attributes."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:66
msgid ""
"Can fail only if there is not enough memory for the fiber structure or fiber "
"stack."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:69
msgid ""
"The created fiber automatically returns itself to the fiber cache if has a "
"default stack size when its \"main\" function completes."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:74
#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:197
#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:203
msgid "fiber attributes container"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:75
msgid "function to run inside the fiber"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:83
msgid "Start execution of created fiber."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:85
msgid "fiber to start"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:86
msgid "arguments to start the fiber with"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:90
msgid "Return control to another fiber and wait until it'll be woken."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:92
msgid "See also: :ref:`fiber_wakeup()<c_api-fiber-fiber_wakeup>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:98
msgid "Interrupt a synchronous wait of a fiber"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:100
#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:138
msgid "fiber to be woken up"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:106
msgid "Cancel the subject fiber (set ``FIBER_IS_CANCELLED`` flag)"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:108
msgid ""
"If target fiber's flag ``FIBER_IS_CANCELLABLE`` set, then it would be woken up "
"(maybe prematurely). Then current fiber yields until the target fiber is dead "
"(or is woken up by :ref:`fiber_wakeup()<c_api-fiber-fiber_wakeup>`)."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:112
msgid "fiber to be cancelled"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:116
msgid ""
"Make it possible or not possible to wakeup the current fiber immediately when "
"it's cancelled."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:119
#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:130
msgid "fiber"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:120
#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:131
msgid "status to set"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:122
msgid "previous state"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:128
msgid "Set fiber to be joinable (``false`` by default)."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:135
msgid ""
"Wait until the fiber is dead and then move its execution status to the caller. "
"The fiber must not be detached."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:140
msgid "Before: ``FIBER_IS_JOINABLE`` flag is set."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:142
msgid "See also: :ref:`fiber_set_joinable()<c_api-fiber-fiber_set_joinable>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:146
msgid "Put the current fiber to sleep for at least 's' seconds."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:148
msgid "time to sleep"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:150
msgid "Note: this is a cancellation point."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:152
msgid "See also: :ref:`fiber_is_cancelled()<c_api-fiber-fiber_is_cancelled>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:158
msgid "Check current fiber for cancellation (it must be checked manually)."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:162
msgid "Report loop begin time as double (cheap)."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:166
msgid "Report loop begin time as 64-bit int."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:170
msgid "Reschedule fiber to end of event loop cycle."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:176
msgid "Return ``slab_cache`` suitable to use with ``tarantool/small`` library"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:180
msgid "Return the current fiber."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:186
msgid ""
"Create a new fiber attributes container and initialize it with default "
"parameters."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:189
msgid ""
"Can be used for creating many fibers: corresponding fibers will not take "
"ownership."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:194
msgid ""
"Delete the ``fiber_attr`` and free all allocated resources. This is safe when "
"fibers created with this attribute still exist."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:201
msgid "Set the fiber's stack size in the fiber attributes container."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:204
msgid "stack size for new fibers (in bytes)"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:207
msgid ""
"-1 on failure (if ``stack_size`` is smaller than the minimum allowable fiber "
"stack size)"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:212
msgid "Get the fiber's stack size from the fiber attributes container."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:214
msgid "fiber attributes container, or NULL for default"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:217
msgid "stack size (in bytes)"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:223
msgid ""
"A conditional variable: a synchronization primitive that allow fibers in "
"Tarantool's :ref:`cooperative multitasking <atomic-cooperative_multitasking>` "
"environment to yield until some predicate is satisfied."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:227
msgid ""
"Fiber conditions have two basic operations -- \"wait\" and \"signal\", -- where "
"\"wait\" suspends the execution of a fiber (i.e. yields) until \"signal\" is "
"called."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:231
msgid ""
"Unlike ``pthread_cond``, ``fiber_cond`` doesn't require mutex/latch wrapping."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:235
msgid "Create a new conditional variable."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:239
msgid "Delete the conditional variable."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:241
msgid ""
"Note: behavior is undefined if there are fibers waiting for the conditional "
"variable."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:244
msgid "conditional variable to delete"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:250
msgid "Wake up **one** (any) of the fibers waiting for the conditional variable."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:252
#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:260
msgid "Does nothing if no one is waiting."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:254
#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:262
#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:278
msgid "conditional variable"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:258
msgid "Wake up **all** fibers waiting for the conditional variable."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:268
msgid ""
"Suspend the execution of the current fiber (i.e. yield) until :ref:"
"`fiber_cond_signal() <c_api-fiber_cond_signal>` is called."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:271
msgid ""
"Like ``pthread_cond``, ``fiber_cond`` can issue spurious wake ups caused by "
"explicit :ref:`fiber_wakeup()<c_api-fiber-fiber_wakeup>` or :ref:"
"`fiber_cancel()<c_api-fiber-fiber_cancel>` calls. It is highly recommended to "
"wrap calls to this function into a loop and check the actual predicate and :ref:"
"`fiber_is_cancelled()<c_api-fiber-fiber_is_cancelled>` on every iteration."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:279
msgid "timeout in seconds"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:281
msgid ""
"0 on :ref:`fiber_cond_signal() <c_api-fiber_cond_signal>` call or a spurious "
"wake up"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:283
msgid "-1 on timeout, and the error code is set to 'TimedOut'"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:287
msgid ""
"Shortcut for :ref:`fiber_cond_wait_timeout() <c_api-fiber_cond_wait_timeout>`."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/index.rst:39
msgid "C API reference"
msgstr "Справочник по C API"

#: ../doc/1.7/dev_guide/reference_capi/index.rst:41
#, fuzzy
msgid "List of C API headers"
msgstr "остаток заголовка"

#: ../doc/1.7/dev_guide/reference_capi/latch.rst:37
msgid "Module `latch`"
msgstr "Модуль `latch`"

#: ../doc/1.7/dev_guide/reference_capi/latch.rst:41
msgid "A lock for cooperative multitasking environment"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/latch.rst:45
msgid "Allocate and initialize the new latch."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/latch.rst:47
msgid "allocated latch object"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/latch.rst
#, fuzzy
msgid "Return type"
msgstr "Общий тип"

#: ../doc/1.7/dev_guide/reference_capi/latch.rst:48
msgid "box_latch_t *"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/latch.rst:52
msgid "Destroy and free the latch."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/latch.rst:54
msgid "latch to destroy"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/latch.rst:58
msgid ""
"Lock a latch. Waits indefinitely until the current fiber can gain access to the "
"latch."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/latch.rst
msgid "param box_latch_t* latch"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/latch.rst:61
#: ../doc/1.7/dev_guide/reference_capi/latch.rst:67
msgid "latch to lock"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/latch.rst:65
msgid "Try to lock a latch. Return immediately if the latch is locked."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/latch.rst:68
msgid "status of operation. 0 - success, 1 - latch is locked"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/latch.rst:69
msgid "int"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/latch.rst:73
msgid "Unlock a latch. The fiber calling this function must own the latch."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/latch.rst:75
msgid "latch to unlock"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/say.rst:37
msgid "Module `say` (logging)"
msgstr "Модуль `say` (логирование)"

#: ../doc/1.7/dev_guide/reference_capi/say.rst:45
msgid "do not use this value directly"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/say.rst:63
#: ../doc/1.7/dev_guide/reference_capi/say.rst:79
msgid "Format and print a message to Tarantool log file."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/say.rst:65
msgid ":ref:`log level <c_api-say-say_level>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/say.rst:66
#: ../doc/1.7/dev_guide/reference_capi/say.rst:81
msgid "``printf()``-like format string"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/say.rst:69
#: ../doc/1.7/dev_guide/reference_capi/say.rst:84
msgid "See also :manpage:`printf(3)`, :ref:`say_level<c_api-say-say_level>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/say.rst:88
#, python-format
msgid "say_info(\"Some useful information: %s\", status);"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/schema.rst:37
msgid "Module `schema`"
msgstr "Модуль `schema`"

#: ../doc/1.7/dev_guide/reference_capi/schema.rst:45
msgid "Start of the reserved range of system spaces."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/schema.rst:49
msgid "Space id of _schema."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/schema.rst:53
msgid "Space id of _space."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/schema.rst:57
msgid "Space id of _vspace view."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/schema.rst:61
msgid "Space id of _index."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/schema.rst:65
msgid "Space id of _vindex view."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/schema.rst:69
msgid "Space id of _func."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/schema.rst:73
msgid "Space id of _vfunc view."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/schema.rst:77
msgid "Space id of _user."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/schema.rst:81
msgid "Space id of _vuser view."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/schema.rst:85
msgid "Space id of _priv."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/schema.rst:89
msgid "Space id of _vpriv view."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/schema.rst:93
msgid "Space id of _cluster."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/schema.rst:97
msgid "Space id of _truncate."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/schema.rst:101
msgid "End of reserved range of system spaces."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/schema.rst:105
msgid "NULL value, returned on error."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:37
msgid "Module `trivia/config`"
msgstr "Модуль `trivia/config`"

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:41
msgid "Extern modifier for all public functions."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:45
msgid "Package major version - 1 for 1.7.0."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:49
msgid "Package minor version - 7 for 1.7.0."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:53
msgid "Package patch version - 0 for 1.7.0."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:57
msgid ""
"A string with major-minor-patch-commit-id identifier of the release, e.g. "
"1.7.0-1216-g73f7154."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:62
msgid "System configuration dir (e.g ``/etc``)"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:66
msgid "Install prefix (e.g. ``/usr``)"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:70
msgid "Build type, e.g. Debug or Release"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:74
msgid "CMake build type signature, e.g. ``Linux-x86_64-Debug``"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:78
msgid "Command line used to run CMake."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:82
msgid "Pathes to C and CXX compilers."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:86
msgid "C compile flags used to build Tarantool."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:90
msgid "CXX compile flags used to build Tarantool."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:94
msgid "A path to install ``*.lua`` module files."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:98
msgid "A path to install ``*.so``/``*.dylib`` module files."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:102
msgid "A path to Lua includes (the same directory where this file is contained)"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:106
msgid "A constant added to ``package.path`` in Lua to find ``*.lua`` module files."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:110
msgid "A constant added to ``package.cpath`` in Lua to find ``*.so`` module files."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:37
msgid "Module `tuple`"
msgstr "Модуль `tuple`"

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:45
msgid "Tuple format."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:47
msgid ""
"Each Tuple has associated format (class). Default format is used to create "
"tuples which are not attach to any particular space."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:58
msgid "Allocate and initialize a new tuple from a raw MsgPack Array data."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:60
msgid ""
"tuple format. Use :ref:`box_tuple_format_default()<c_api-tuple-"
"box_tuple_format_default>` to create space-independent tuple."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:63
msgid "tuple data in MsgPack Array format ([field1, field2, ...])"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:64
msgid "the end of ``data``"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:66
#: ../doc/1.7/dev_guide/reference_capi/txn.rst:79
msgid "NULL on out of memory"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:67
msgid "tuple otherwise"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:69
msgid "See also: :ref:`box.tuple.new()<box_tuple-new>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:75
msgid "Increase the reference counter of tuple."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:77
msgid ""
"Tuples are reference counted. All functions that return tuples guarantee that "
"the last returned tuple is refcounted internally until the next call to API "
"function that yields or returns another tuple."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:81
msgid ""
"You should increase the reference counter before taking tuples for long "
"processing in your code. Such tuples will not be garbage collected even if "
"another fiber remove they from space. After processing please decrement the "
"reference counter using :ref:`box_tuple_unref()<c_api-tuple-box_tuple_unref>`, "
"otherwise the tuple will leak."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:88
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:101
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:114
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:120
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:139
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:154
msgid "a tuple"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:90
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:103
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:132
msgid "-1 on error"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:93
msgid "See also: :ref:`box_tuple_unref()<c_api-tuple-box_tuple_unref>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:99
msgid "Decrease the reference counter of tuple."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:106
msgid "See also: :ref:`box_tuple_ref()<c_api-tuple-box_tuple_ref>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:112
msgid "Return the number of fields in tuple (the size of MsgPack Array)."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:118
msgid ""
"Return the number of bytes used to store internal tuple data (MsgPack Array)."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:124
msgid "Dump raw MsgPack data to the memory buffer ``buf`` of size ``size``."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:126
msgid "Store tuple fields in the memory buffer."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:128
msgid ""
"Upon successful return, the function returns the number of bytes written. If "
"buffer size is not enough then the return value is the number of bytes which "
"would have been written if enough space had been available."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:133
msgid "number of bytes written on success."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:137
msgid "Return the associated format."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:141
msgid "tuple format"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:147
msgid ""
"Return the raw tuple field in MsgPack format. The result is a pointer to raw "
"MessagePack data which can be decoded with mp_decode functions, for an example "
"see the tutorial program :ref:`read.c <f_c_tutorial-read>`."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:152
msgid "The buffer is valid until next call to box_tuple_* functions."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:155
msgid "zero-based index in MsgPack array."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:157
msgid ""
"NULL if i >= :ref:`box_tuple_field_count()<c_api-tuple-box_tuple_field_count>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:158
msgid "msgpack otherwise"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:173
#, fuzzy
msgid "Possible data types for tuple fields."
msgstr "Добавлены новые типы индексируемых полей."

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:175
msgid ""
"Can't use STRS/ENUM macros for them, since there is a mismatch between enum name "
"(STRING) and type name literal (\"STR\"). STR is already used as Objective C "
"type."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:183
msgid "Key definition"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:187
msgid ""
"Create key definition with the key fields with passed typed on passed positions."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:189
msgid "May be used for tuple format creation and/or tuple comparison."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:191
msgid "array with key field identifiers"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:192
msgid "array with key :ref:`field types <capi-tuple_field_type>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:193
msgid "the number of key fields"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:200
msgid "Delete key definition"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:202
msgid "key definition to delete"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:208
msgid "Return new in-memory tuple format based on passed key definitions"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:210
msgid "array of keys defined for the format"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:211
msgid "count of keys"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:213
msgid "new tuple format on success"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:218
msgid "Increment tuple format ref count"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:220
msgid "tuple format to ref"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:224
msgid "Decrement tuple format ref count"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:226
msgid "tuple format to unref"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:232
msgid "Compare tuples using key definition"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:234
#, fuzzy
msgid "the first tuple"
msgstr "код для кортежа"

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:235
#, fuzzy
msgid "the second tuple"
msgstr "код для кортежа"

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:236
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:250
msgid "key definition"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:238
msgid "0  if ``key_fields(tuple_a)`` == ``key_fields(tuple_b)``"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:239
msgid "<0 if ``key_fields(tuple_a)`` < ``key_fields(tuple_b)``"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:240
msgid ">0 if ``key_fields(tuple_a)`` > ``key_fields(tuple_b)``"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:242
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:256
msgid "See also: enum :ref:`field_type <capi-tuple_field_type>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:246
msgid "Compare a tuple with a key using key definition"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:249
msgid "key with MessagePack array header"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:252
msgid "0  if ``key_fields(tuple)`` == ``parts(key)``"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:253
msgid "<0 if ``key_fields(tuple)`` < ``parts(key)``"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:254
msgid ">0 if ``key_fields(tuple)`` > ``parts(key)``"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:260
msgid "Tuple iterator"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:264
msgid ""
"Allocate and initialize a new tuple iterator. The tuple iterator allow to "
"iterate over fields at root level of MsgPack array."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:269
msgid ""
"box_tuple_iterator_t* it = box_tuple_iterator(tuple);\n"
"if (it == NULL) {\n"
"    // error handling using box_error_last()\n"
"}\n"
"const char* field;\n"
"while (field = box_tuple_next(it)) {\n"
"    // process raw MsgPack data\n"
"}\n"
"\n"
"// rewind iterator to first position\n"
"box_tuple_rewind(it)\n"
"assert(box_tuple_position(it) == 0);\n"
"\n"
"// rewind three fields\n"
"field = box_tuple_seek(it, 3);\n"
"assert(box_tuple_position(it) == 4);\n"
"\n"
"box_iterator_free(it);"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:292
msgid "Destroy and free tuple iterator"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:298
msgid ""
"Return zero-based next position in iterator. That is, this function return the "
"field id of field that will be returned by the next call to :ref:"
"`box_tuple_next()<c_api-tuple-box_tuple_next>`. Returned value is zero after "
"initialization or rewind and :ref:`box_tuple_field_count()<c_api-tuple-"
"box_tuple_field_count>` after the end of iteration."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:305
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:312
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:326
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:347
msgid "a tuple iterator"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:306
msgid "position"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:310
msgid "Rewind iterator to the initial position."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:314
msgid "After: ``box_tuple_position(it) == 0``"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:318
msgid "Seek the tuple iterator."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:320
msgid ""
"The result is a pointer to raw MessagePack data which can be decoded with "
"mp_decode functions, for an example see the tutorial program :ref:`read.c "
"<f_c_tutorial-read>`. The returned buffer is valid until next call to "
"box_tuple_* API. Requested field_no returned by next call to box_tuple_next(it)."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:327
msgid "field number - zero-based position in MsgPack array"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:330
msgid "After:"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:332
msgid "``box_tuple_position(it) == field_not`` if returned value is not NULL."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:333
msgid ""
"``box_tuple_position(it) == box_tuple_field_count(tuple)`` if returned value is "
"NULL."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:340
msgid "Return the next tuple field from tuple iterator."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:342
msgid ""
"The result is a pointer to raw MessagePack data which can be decoded with "
"mp_decode functions, for an example see the tutorial program :ref:`read.c "
"<f_c_tutorial-read>`. The returned buffer is valid until next call to "
"box_tuple_* API."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:348
msgid "NULL if there are no more fields"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:349
msgid "MsgPack otherwise"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:351
msgid ""
"Before: :ref:`box_tuple_position()<c_api-tuple-box_tuple_position>` is zero-"
"based ID of returned field."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:354
msgid ""
"After: ``box_tuple_position(it) == box_tuple_field_count(tuple)`` if returned "
"value is NULL."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/txn.rst:37
msgid "Module `txn`"
msgstr "Модуль `txn`"

#: ../doc/1.7/dev_guide/reference_capi/txn.rst:41
msgid "Return true if there is an active transaction."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/txn.rst:45
msgid "Begin a transaction in the current fiber."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/txn.rst:47
msgid ""
"A transaction is attached to caller fiber, therefore one fiber can have only one "
"active transaction."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/txn.rst:51
msgid "-1 on error. Perhaps a transaction has already been started"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/txn.rst:55
msgid "Commit the current transaction."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/txn.rst:58
msgid "-1 on error. Perhaps a disk write failure"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/txn.rst:62
msgid "Roll back the current transaction."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/txn.rst:66
msgid "Return a descriptor of a savepoint."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/txn.rst:70
msgid "Roll back the current transaction as far as the specified savepoint."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/txn.rst:74
msgid "Allocate memory on txn memory pool."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/txn.rst:76
msgid ""
"The memory is automatically deallocated when the transaction is committed or "
"rolled back."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:37
msgid "Module `lua/utils`"
msgstr "Модуль `lua/utils`"

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:43
msgid "Push cdata of given ``ctypeid`` onto the stack."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:45
msgid ""
"CTypeID must be used from FFI at least once. Allocated memory returned "
"uninitialized. Only numbers and pointers are supported."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:48
#: ../doc/1.7/dev_guide/reference_capi/utils.rst:61
#: ../doc/1.7/dev_guide/reference_capi/utils.rst:76
#: ../doc/1.7/dev_guide/reference_capi/utils.rst:83
#: ../doc/1.7/dev_guide/reference_capi/utils.rst:96
#: ../doc/1.7/dev_guide/reference_capi/utils.rst:108
#: ../doc/1.7/dev_guide/reference_capi/utils.rst:115
#: ../doc/1.7/dev_guide/reference_capi/utils.rst:150
#: ../doc/1.7/dev_guide/reference_capi/utils.rst:162
msgid "Lua State"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:49
msgid "FFI's CTypeID of this cdata"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:51
#: ../doc/1.7/dev_guide/reference_capi/utils.rst:65
msgid "memory associated with this cdata"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:53
msgid "See also: :ref:`luaL_checkcdata()<c_api-utils-luaL_checkcdata>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:59
msgid "Check whether the function argument ``idx`` is a cdata."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:62
#: ../doc/1.7/dev_guide/reference_capi/utils.rst:77
msgid "stack index"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:63
msgid "output argument. FFI's CTypeID of returned cdata"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:67
msgid "See also: :ref:`luaL_pushcdata()<c_api-utils-luaL_pushcdata>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:71
msgid "Set finalizer function on a cdata object."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:73
msgid ""
"Equivalent to call `ffi.gc(obj, function)`. Finalizer function must be on the "
"top of the stack."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:81
msgid "Return CTypeID (FFI) of given СDATA type."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:84
msgid "C type name as string (e.g. \"struct request\" or \"uint32_t\")"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:87
msgid "CTypeID"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:89
msgid ""
"See also: :ref:`luaL_pushcdata()<c_api-utils-luaL_pushcdata>`, :ref:"
"`luaL_checkcdata()<c_api-utils-luaL_checkcdata>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:94
msgid "Declare symbols for FFI."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:97
msgid "C definitions (e.g. \"struct stat\")"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:100
msgid "``LUA_ERRRUN``, ``LUA_ERRMEM` or ``LUA_ERRERR`` otherwise."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:102
msgid "See also: ``ffi.cdef(def)``"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:106
msgid "Push uint64_t onto the stack."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:109
#: ../doc/1.7/dev_guide/reference_capi/utils.rst:116
msgid "value to push"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:113
msgid "Push int64_t onto the stack."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:120
#: ../doc/1.7/dev_guide/reference_capi/utils.rst:134
msgid ""
"Check whether the argument idx is a uint64 or a convertable string and returns "
"this number."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst
msgid "throws"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:123
#: ../doc/1.7/dev_guide/reference_capi/utils.rst:130
msgid "error if the argument can't be converted"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:127
#: ../doc/1.7/dev_guide/reference_capi/utils.rst:141
msgid ""
"Check whether the argument idx is a int64 or a convertable string and returns "
"this number."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:137
#: ../doc/1.7/dev_guide/reference_capi/utils.rst:144
msgid "the converted number or 0 of argument can't be converted"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:148
msgid "Push a tuple onto the stack."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:152
msgid "error on OOM"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:154
msgid "See also: :ref:`luaT_istuple <c_api-utils-luaT_istuple>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:160
msgid "Check whether ``idx`` is a tuple."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:163
msgid "the stack index"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:165
msgid "non-NULL if ``idx`` is a tuple"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:166
msgid "NULL if ``idx`` is not a tuple"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:170
msgid "Re-throw the last Tarantool error as a Lua object."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:172
msgid ""
"See also: `lua_error() <https://www.lua.org/manual/5.1/manual.html#lua_error>`_,"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:173
msgid ":ref:`box_error_last() <c_api-error-box_error_last>`."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:177
msgid ""
"Similar to `lua_cpcall() <https://www.lua.org/manual/5.1/manual."
"html#lua_cpcall>`_, but with the proper support of Tarantool errors."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:182
msgid "Get the global Lua state used by Tarantool."
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:37
msgid "Release management"
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:40
msgid "How to make a minor release"
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:42
msgid ""
"$ git tag -a 1.4.4 -m \"Next minor in 1.4 series\"\n"
"$ vim CMakeLists.txt # edit CPACK_PACKAGE_VERSION_PATCH\n"
"$ git push --tags"
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:48
msgid "Update the Web site in doc/www"
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:50
msgid ""
"Update all issues, upload the ChangeLog based on ``git log`` output. The "
"ChangeLog must only include items which are mentioned as issues on github. If "
"anything significant is there, which is not mentioned, something went wrong in "
"release planning and the release should be held up until this is cleared."
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:56
msgid ""
"Click 'Release milestone'. Create a milestone for the next minor release. Alert "
"the driver to target bugs and blueprints to the new milestone."
msgstr ""

#: ../doc/1.7/index.rst:40
msgid "Tarantool - Documentation"
msgstr ""

#: ../doc/1.7/index.rst:47
msgid ":doc:`Documentation Overview <index>`"
msgstr ""

#: ../doc/1.7/index.rst:88
msgid ""
"Tarantool 1.7 manual  This manual embraces all aspects of using Tarantool: from "
"introductory information and exercises for beginners -- to advanced instructions "
"and detailed references for power users and contributors.  Документация "
"находится в процессе перевода и может отставать от английской версии.      <div "
"class=\"badge-icon\"></div>  Other sources  Single page  PDF  English  Russian  "
"Telegram chat"
msgstr ""

#: ../doc/1.7/index.rst:56
msgid "Tarantool 1.7 manual"
msgstr ""

#: ../doc/1.7/index.rst:60
msgid ""
"This manual embraces all aspects of using Tarantool: from introductory "
"information and exercises for beginners -- to advanced instructions and detailed "
"references for power users and contributors."
msgstr ""

#: ../doc/1.7/index.rst:81
msgid "Other sources"
msgstr ""

#: ../doc/1.7/index.rst:83
msgid "`Single page <singlehtml.html>`_"
msgstr ""

#: ../doc/1.7/index.rst:84
#, fuzzy
msgid "`PDF <Tarantool.pdf>`_"
msgstr "Модуль `tarantool`"

#: ../doc/1.7/index.rst:85
msgid "`English`_"
msgstr ""

#: ../doc/1.7/index.rst:86
msgid "`Russian`_"
msgstr ""

#: ../doc/1.7/index.rst:87
msgid "`Telegram chat`_"
msgstr ""

#: ../doc/1.7/intro.rst:37
msgid "Overview"
msgstr "Общие сведения"

#: ../doc/1.7/intro.rst:41
msgid "An application server together with a database manager"
msgstr "Сервер приложений + СУБД"

#: ../doc/1.7/intro.rst:43
#, fuzzy
msgid ""
"Tarantool is a Lua application server integrated with a database management "
"system. It has a \"fiber\" model which means that many Tarantool applications "
"can run simultaneously on a single thread, while each instance of the Tarantool "
"server itself can run multiple threads for input-output and background "
"maintenance. It incorporates the LuaJIT -- \"Just In Time\" -- Lua compiler, Lua "
"libraries for most common applications, and the Tarantool Database Server which "
"is an established NoSQL DBMS. Thus Tarantool serves all the purposes that have "
"made node.js and Twisted popular, plus it supports data persistence."
msgstr ""
"Tarantool представляет собой сервер приложений на языке Lua, интегрированный с "
"СУБД. В основе Tarantool лежат файберы (fibers), что позволяет нескольким Lua-"
"приложениям работать в одном потоке (thread), при этом Tarantool-сервер может "
"одновременно запускать другие потоки для обработки ввода-вывода данных и фоновых "
"сервисных задач. Tarantool включает в себя LuaJIT (Just In Time) Lua-компилятор, "
"Lua-библиотеки для решения наиболее частых задач, а также сервер баз данных "
"Tarantool, представляющий собой NoSQL СУБД. Таким образом, Tarantool может всё "
"то же, что node.js и Twisted, а кроме того обеспечивает сохранность данных."

#: ../doc/1.7/intro.rst:51
msgid ""
"The code is free. The open-source license is `BSD license`_. The supported "
"platforms are GNU/Linux, Mac OS and FreeBSD."
msgstr ""
"Tarantool — это open-source проект. Исходный код открыт для всех и "
"распространяется бесплатно согласно лицензии `BSD license`_. Поддерживаемые "
"платформы: GNU / Linux, Mac OS и FreeBSD."

#: ../doc/1.7/intro.rst:54
msgid ""
"Tarantool's creator and biggest user is `Mail.Ru`_, the largest internet company "
"in Russia, with 30 million users, 25 million emails per day, and a web site "
"whose Alexa global rank is in the `top 40`_ worldwide. Tarantool services Mail."
"Ru's hottest data, such as the session data of online users, the properties of "
"online applications, the caches of the underlying data, the distribution and "
"sharding algorithms, and much more. Outside Mail.Ru the software is used by a "
"growing number of projects in online gaming, digital marketing, and social media "
"industries. Although Mail.Ru is the sponsor for product development, the roadmap "
"and the bugs database and the development process are fully open. The software "
"incorporates patches from dozens of community contributors. The Tarantool "
"community writes and maintains most of the drivers for programming languages.  "
"The greater Lua community has hundreds of useful packages most of which can "
"become Tarantool extensions."
msgstr ""
"Создателем Tarantool'а — а также его основным пользователем — является компания "
"`Mail.Ru`_, крупнейшая Интернет-компания России (30 млн пользователей, 25 млн "
"электронных писем в день, веб-сайт в списке `top 40`_ международного Alexa-"
"рейтинга). Tarantool используется для обработки самых \"горячих\" данных Mail."
"Ru, таких как данные пользовательских онлайн-сессий, настройки онлайн-"
"приложений, кеширование сервисных данных, алгоритмы распределения данных и "
"шардинга, и т.д. Tarantool также используется во всё большем количестве проектов "
"вне стен Mail.Ru. Это, к примеру, онлайн-игры, цифровой маркетинг, социальные "
"сети. Несмотря на то что Mail.Ru спонсирует разработку Tarantool'а, весь процесс "
"разработки, в т.ч. дальнейшие планы и база обнаруженных ошибок, является "
"полностью открытым. В Tarantool включены патчи от большого числа сторонних "
"разработчиков. Усилиями сообщества разработчиков Tarantool'а были написаны (и "
"далее поддерживаются) библиотеки для подключения модулей на внешних языках "
"программирования. А сообщество Lua-разработчиков предоставило сотни полезных "
"пакетов, большинство из которых можно использовать в качестве расширений для "
"Tarantool'а."

#: ../doc/1.7/intro.rst:68
msgid ""
"Users can create, modify and drop **Lua functions** at runtime. Or they can "
"define **Lua programs** that are loaded during startup for triggers, background "
"tasks, and interacting with networked peers. Unlike popular application "
"development frameworks based on a \"reactor\" pattern, networking in server-side "
"Lua is sequential, yet very efficient, as it is built on top of the "
"**cooperative multitasking** environment that Tarantool itself uses."
msgstr ""
"Пользователи Tarantool'а могут создавать, изменять и удалять **Lua-функции** "
"прямо во время исполнения кода. Также они могут указывать **Lua-программы**, "
"которые будут загружаться во время запуска Tarantool'а. Такие программы могут "
"служить триггерами, выполнять фоновые задачи и взаимодействовать с другими "
"программами по сети. В отличие от многих популярных сред разработки приложений, "
"которые используют \"реактивный\" принцип, сетевое взаимодействие в Lua устроено "
"последовательно, но очень эффективно, т.к. оно использует среду **взаимной "
"многозадачности** самого Tarantool'а."

#: ../doc/1.7/intro.rst:76
msgid ""
"One of the built-in Lua packages provides an API for the Database Management "
"System. Thus some developers see Tarantool as a DBMS with a popular stored "
"procedure language, while others see it as a Lua interpreter, while still others "
"see it as a replacement for many components of multi-tier Web applications. "
"Performance can be a few hundred thousand transactions per second on a laptop, "
"scalable upwards or outwards to server farms."
msgstr ""
"Один из встраиваемых Lua-пакетов — это API для функционала СУБД. Таким образом, "
"некоторые разработчики рассматривают Tarantool как СУБД с популярным языком для "
"написания хранимых процедур, другие рассматривают его как Lua-интерпретатор, а "
"третьи -- как вариант замены сразу нескольких компонентов в многозвенных веб-"
"приложениях. Производительность Tarantool'а может достигать сотен тысяч "
"транзакций в секунду на ноутбуке, и ее можно наращивать \"вверх\" или \"вширь\" "
"за счет новых серверных ферм."

#: ../doc/1.7/intro.rst:86
msgid "Database features"
msgstr "Возможности СУБД"

#: ../doc/1.7/intro.rst:88
msgid ""
"Tarantool can run without it, but \"The Box\" -- the DBMS server -- is a strong "
"distinguishing feature."
msgstr ""
"Компонент \"box\" — серверная часть с функционалом СУБД — это важная часть "
"Tarantool'а, хотя он может работать и без данного компонента."

#: ../doc/1.7/intro.rst:91
msgid ""
"The database API allows for permanently storing Lua objects, managing object "
"collections, creating or dropping secondary keys, making changes atomically, "
"configuring and monitoring replication, performing controlled fail-over, and "
"executing Lua code triggered by database events. Remote database instances are "
"accessible transparently via a remote-procedure-invocation API."
msgstr ""
"API для функционала СУБД позволяет хранить Lua-объекты, управлять коллекциями "
"объектов, создавать и удалять вторичные ключи, делать атомарные изменения, "
"конфигурировать и мониторить репликацию, производить контролируемое переключение "
"при отказе (failover), а также исполнять код на Lua, который вызывается "
"событиями в базе. А для прозрачного доступа к удаленным (remote) экземплярам баз "
"данных разработан API для вызова удаленных процедур."

#: ../doc/1.7/intro.rst:99
msgid ""
"Tarantool's DBMS server uses the **storage engine** concept, where different "
"sets of algorithms and data structures can be used for different situations. Two "
"storage engines are built-in: an in-memory engine which has all the data and "
"indexes in RAM, and a two-level B-tree engine for data sets whose size is 10 to "
"1000 times the amount of available RAM. All storage engines in Tarantool support "
"transactions and replication by using a common **write ahead log** (WAL). This "
"ensures consistency and crash safety of the persistent state. Changes are not "
"considered complete until the WAL is written. The logging subsystem supports "
"group commit."
msgstr ""
"В архитектуре серверной части СУБД Tarantool'а реализована концепция \"движков\" "
"базы данных (storage engines), где в разных ситуациях используются разные наборы "
"алгоритмов и структуры данных. В Tarantool'е есть два встроенных движка: in-"
"memory движок, который держит все данные и индексы в оперативной памяти, и "
"двухуровневый движок для B-деревьев, который обрабатывает данные размером в "
"10-1000 раз больше того, что может поместиться в оперативной памяти. Все движки "
"в Tarantool'е поддерживают транзакции и репликацию, поскольку они используют "
"единый механизм **упреждающей записи** (WAL = write ahead log). Это механизм "
"обеспечивает согласованность и сохранность данных при сбоях. Таким образом, "
"изменения не считаются завершенными, пока не проходит запись в лог WAL. "
"Подсистема логирования также поддерживает групповые коммиты. "

#: ../doc/1.7/intro.rst:110
#, fuzzy
msgid ""
"**Tarantool's in-memory storage engine** (memtx) keeps all the data in random-"
"access memory, and therefore has very low read latency. It also keeps persistent "
"copies of the data in non-volatile storage, such as disk, when users request "
"\"snapshots\". If an instance of the server stops and the random-access memory "
"is lost, then restarts, it reads the latest snapshot and then replays the "
"transactions that are in the log -- therefore no data is lost."
msgstr ""
"**In-memory движок** (memtx) хранит все данные в оперативной памяти, поэтому "
"время ожидания при чтении у него очень мало. Также, когда пользователи "
"запрашивают статические снимки (snapshots), этот движок создает персистентные "
"копии данных в постоянной памяти, например на жестком диске. Если Tarantool-"
"сервер прекращает работать и данные в оперативной памяти теряются, то при "
"следующем запуске Tarantool-сервер загружает в память самую свежую копию данных "
"с диска и применяет к ней все транзакции из лога, которые были сделаны с момента "
"создания копии. Таким образом, данные при сбое не теряются."

#: ../doc/1.7/intro.rst:119
#, fuzzy
msgid ""
"**Tarantool's in-memory engine is lock-free** in typical situations. Instead of "
"the operating system's concurrency primitives, such as mutexes, Tarantool uses "
"cooperative multitasking to handle thousands of connections simultaneously. "
"There is a fixed number of independent execution threads. The threads do not "
"share state. Instead they exchange data using low-overhead message queues. While "
"this approach limits the number of cores that the instance will use, it removes "
"competition for the memory bus and ensures peak scalability of memory access and "
"network throughput. CPU utilization of a typical highly-loaded Tarantool "
"instance is under 10%. Searches are possible via **secondary index keys** as "
"well as primary keys."
msgstr ""
"В штатных ситуациях **in-memory движок работает без блокировок**. Вместо "
"низкоуровневых механизмов параллельной обработки данных, которые предлагает "
"операционная система (например, mutex'ов), Tarantool использует среду взаимной "
"многозадачности, и таким образом может работать с тысячами соединений "
"одновременно. В Tarantool'е есть фиксированное количество независимых нитей "
"(thread), и у них нет общего состояния. Для обмена данными между нитями "
"используются очереди сообщений, что позволяет уменьшить накладные расходы. Такой "
"подход накладывает ограничение на количество процессорных ядер, которые "
"Tarantool-сервер может использовать, но в то же время он позволяет избежать "
"конкуренции за шину памяти, а также дает запас масштабируемости по скорости "
"доступа к памяти и производительности сети. В результате даже сильно нагруженный "
"Tarantool-сервер в среднем использует процессор не более чем на 10%. Кроме того, "
"Tarantool поддерживает поиск как по первичным, так и по **вторичным ключам в "
"индексах**."

#: ../doc/1.7/intro.rst:129
#, fuzzy
msgid ""
"**Tarantool's disk-based storage engine** is a fusion of ideas from modern "
"filesystems, log-structured merge trees and classical B-trees. All data is "
"organized into **ranges**. Each range is represented by a file on disk. Range "
"size is a configuration option and normally is around 64MB. Each range is a "
"collection of pages, serving different purposes. Pages in a fully merged range "
"contain non-overlapping ranges of keys. A range can be partially merged if there "
"were a lot of changes in its key range recently. In that case some pages "
"represent new keys and values in the range. The disk-based storage engine is "
"append only: new data never overwrites old data. The disk-based storage engine "
"is named *vinyl*."
msgstr ""
"**Дисковый движок** (:ref:`vinyl <index-vinyl>`) совмещает в себе подходы, "
"заимствованные из современных файловых систем, журналируемых merge-деревьев (log-"
"structured merge trees) и классических B-деревьев. Все данные в этом движке "
"разбиты по забегам (runs), где каждый забег представляет собой файл на диске. "
"Максимальный размер забега обычно равен 64МБ, и его можно настраивать. Каждый "
"забег -- это набор страниц, которые нужны для каких-то целей. Если забег "
"полностью смержен, то диапазоны ключей на его страницах не пересекаются. Если же "
"диапазоны ключей в забеге в какой-то момент сильно изменялись, то мы имеем дело "
"с частично смерженным забегом. В этом случае на некоторых страницах появились "
"новые ключи и значения, которых ранее не было в данном забеге. Дисковый движок "
"обновляет данные по принципу дописывания в конец: новые данные никогда не "
"затирают старые."

#: ../doc/1.7/intro.rst:140
msgid ""
"Tarantool supports **multi-part index keys**. The possible index types are HASH, "
"TREE, BITSET, and RTREE."
msgstr ""
"Tarantool поддерживает работу с **составными ключами в индексах**. Возможные "
"типы ключей: HASH, TREE, BITSET и RTREE."

#: ../doc/1.7/intro.rst:143
msgid ""
"Tarantool supports **asynchronous replication**, locally or to remote hosts. The "
"replication architecture can be **master-master**, that is, many nodes may both "
"handle the loads and receive what others have handled, for the same data sets."
msgstr ""
"Tarantool также поддерживает **асинхронную репликацию** — как локальную, так и "
"на удаленных серверах. При этом репликацию можно настроить по принципу **мастер-"
"мастер**, когда несколько узлов могут не только обрабатывать входящую нагрузку, "
"но и получать данные от других узлов."

#: ../doc/1.7/reference/configuration/index.rst:39
msgid "Configuration reference"
msgstr "Справочник по настройке"

#: ../doc/1.7/reference/configuration/index.rst:41
msgid ""
"This reference covers all options and parameters which can be set for Tarantool "
"on the command line or in an :ref:`initialization file <index-init_label>`."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:44
msgid "Tarantool is started by entering the following command:"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:49
msgid ""
"$ **tarantool**\n"
"# OR\n"
"$ **tarantool** *options*\n"
"# OR\n"
"$ **tarantool** *lua-initialization-file* **[** *arguments* **]**"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:57
msgid "Command options"
msgstr "Опции комнандной строки"

#: ../doc/1.7/reference/configuration/index.rst:61
msgid "Print an annotated list of all available options and exit."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:67
msgid "Print product name and version, for example:"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:69
msgid ""
"$ ./tarantool --version\n"
"Tarantool 1.7.0-1216-g73f7154\n"
"Target: Linux-x86_64-Debug\n"
"..."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:76
msgid "In this example:"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:78
msgid ""
"“Tarantool” is the name of the reusable asynchronous networking programming "
"framework."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:81
msgid ""
"The 3-number version follows the standard ``<major>-<minor>-<patch>`` scheme, in "
"which ``<major>`` number is changed only rarely, ``<minor>`` is incremented for "
"each new milestone and indicates possible incompatible changes, and ``<patch>`` "
"stands for the number of bug fix releases made after the start of the milestone. "
"For non-released versions only, there may be a commit number and commit SHA1 to "
"indicate how much this particular build has diverged from the last release."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:89
msgid ""
"“Target” is the platform tarantool was built on. Some platform-specific details "
"may follow this line."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:94
msgid ""
"Tarantool uses `git describe <http://www.kernel.org/pub/software/scm/git/docs/"
"git-describe.html>`_ to produce its version id, and this id can be used at any "
"time to check out the corresponding source from our `git repository <http://"
"github.com/tarantool/tarantool.git>`_."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:104
msgid "URI"
msgstr "Универсальный код ресурса (URI)"

#: ../doc/1.7/reference/configuration/index.rst:106
msgid ""
"Some configuration parameters and some functions depend on a URI, or \"Universal "
"Resource Identifier\". The URI string format is similar to the `generic syntax "
"for a URI schema <http://en.wikipedia.org/wiki/URI_scheme#Generic_syntax>`_. So "
"it may contain (in order) a user name for login, a password, a host name or host "
"IP address, and a port number. Only the port number is always mandatory. The "
"password is mandatory if the user name is specified, unless the user name is "
"'guest'. So, formally, the URI syntax is ``[host:]port`` or ``[username:"
"password@]host:port``. If host is omitted, then '0.0.0.0' or '[::]' is assumed, "
"meaning respectively any IPv4 address or any IPv6 address, on the local machine. "
"If username:password is omitted, then 'guest' is assumed. Some examples:"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:125
msgid "URI fragment"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:127
msgid "port"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:127
msgid "3301"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:129
msgid "host:port"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:129
msgid "127.0.0.1:3301"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:131
msgid "username:password@host:port"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:131
msgid "notguest:sesame@mail.ru:3301"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:134
msgid ""
"In certain circumstances a Unix domain socket may be used where a URI is "
"expected, for example \"unix/:/tmp/unix_domain_socket.sock\" or simply \"/tmp/"
"unix_domain_socket.sock\"."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:138
msgid "A method for parsing URIs is illustrated in :ref:`Module uri <uri-parse>`."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:144
msgid "Initialization file"
msgstr "Файл инициализации"

#: ../doc/1.7/reference/configuration/index.rst:146
msgid ""
"If the command to start Tarantool includes :codeitalic:`lua-initialization-"
"file`, then Tarantool begins by invoking the Lua program in the file, which by "
"convention may have the name \"``script.lua``\". The Lua program may get further "
"arguments from the command line or may use operating-system functions, such as "
"``getenv()``. The Lua program almost always begins by invoking ``box.cfg()``, if "
"the database server will be used or if ports need to be opened. For example, "
"suppose ``script.lua`` contains the lines"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:154
msgid ""
"#!/usr/bin/env tarantool\n"
"box.cfg{\n"
"    listen              = os.getenv(\"LISTEN_URI\"),\n"
"    memtx_memory        = 100000,\n"
"    pid_file            = \"tarantool.pid\",\n"
"    rows_per_wal        = 50\n"
"}\n"
"print('Starting ', arg[1])"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:165
msgid ""
"and suppose the environment variable LISTEN_URI contains 3301, and suppose the "
"command line is ``~/tarantool/src/tarantool script.lua ARG``. Then the screen "
"might look like this:"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:169
msgid ""
"$ export LISTEN_URI=3301\n"
"$ ~/tarantool/src/tarantool script.lua ARG\n"
"... main/101/script.lua C> version 1.7.0-1216-g73f7154\n"
"... main/101/script.lua C> log level 5\n"
"... main/101/script.lua I> mapping 107374184 bytes for a shared arena...\n"
"... main/101/script.lua I> recovery start\n"
"... main/101/script.lua I> recovering from './00000000000000000000.snap'\n"
"... main/101/script.lua I> primary: bound to 0.0.0.0:3301\n"
"... main/102/leave_local_hot_standby I> ready to accept requests\n"
"Starting  ARG\n"
"... main C> entering the event loop"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:183
msgid ""
"If you wish to start an interactive session on the same terminal after "
"initialization is complete, you can use :ref:`console.start() <console-start>`."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:199
msgid "Configuration parameters"
msgstr "Параметры конфигурации"

#: ../doc/1.7/reference/configuration/index.rst:201
#, fuzzy
msgid "Configuration parameters have the form:"
msgstr "Параметры конфигурации"

#: ../doc/1.7/reference/configuration/index.rst:203
msgid ":extsamp:`{**{box.cfg}**}{[{*{key = value}*} [, {*{key = value ...}*}]]}`"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:205
msgid ""
"Since ``box.cfg`` may contain many configuration parameters and since some of "
"the parameters (such as directory addresses) are semi-permanent, it's best to "
"keep ``box.cfg`` in a Lua file. Typically this Lua file is the initialization "
"file which is specified on the tarantool command line."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:210
msgid ""
"Most configuration parameters are for allocating resources, opening ports, and "
"specifying database behavior. All parameters are optional. A few parameters are "
"dynamic, that is, they can be changed at runtime by calling ``box.cfg{}`` a "
"second time."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:215
msgid ""
"To see all the non-null parameters, say ``box.cfg`` (no parentheses). To see a "
"particular parameter, for example the listen address, say ``box.cfg.listen``."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:218
msgid ""
"The following sections describe all parameters for basic operation, for storage, "
"for binary logging and snapshots, for replication, for networking, and for "
"logging."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:223
msgid "Basic parameters"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:1
msgid ":ref:`background <cfg_basic-background>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:2
msgid ":ref:`custom_proc_title <cfg_basic-custom_proc_title>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:3
msgid ":ref:`listen <cfg_basic-listen>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:4
msgid ":ref:`memtx_dir <cfg_basic-memtx_dir>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:5
msgid ":ref:`pid_file <cfg_basic-pid_file>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:6
msgid ":ref:`read_only <cfg_basic-read_only>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:7
msgid ":ref:`vinyl_dir <cfg_basic-vinyl_dir>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:8
msgid ":ref:`vinyl_timeout <cfg_basic-vinyl_timeout>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:9
msgid ":ref:`username <cfg_basic-username>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:10
msgid ":ref:`wal_dir <cfg_basic-wal_dir>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:11
msgid ":ref:`work_dir <cfg_basic-work_dir>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:12
msgid ":ref:`worker_pool_threads <cfg_basic-worker_pool_threads>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:18
msgid ""
"Run the server as a background task. The :ref:`log <cfg_logging-log>` and :ref:"
"`pid_file <cfg_basic-pid_file>` parameters must be non-null for this to work."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:22
#: ../doc/1.7/reference/configuration/cfg_basic.rst:111
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:19
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:25
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:55
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:66
#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:46
#: ../doc/1.7/reference/configuration/cfg_logging.rst:116
msgid "Type: boolean"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:23
#: ../doc/1.7/reference/configuration/cfg_basic.rst:112
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:26
#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:47
msgid "Default: false"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:24
#: ../doc/1.7/reference/configuration/cfg_basic.rst:86
#: ../doc/1.7/reference/configuration/cfg_basic.rst:97
#: ../doc/1.7/reference/configuration/cfg_basic.rst:125
#: ../doc/1.7/reference/configuration/cfg_basic.rst:150
#: ../doc/1.7/reference/configuration/cfg_basic.rst:164
#: ../doc/1.7/reference/configuration/cfg_basic.rst:189
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:21
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:34
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:77
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:27
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:57
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:95
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:110
#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:48
#: ../doc/1.7/reference/configuration/cfg_logging.rst:104
#: ../doc/1.7/reference/configuration/cfg_logging.rst:118
#: ../doc/1.7/reference/configuration/cfg_storage.rst:30
#: ../doc/1.7/reference/configuration/cfg_storage.rst:43
#: ../doc/1.7/reference/configuration/cfg_storage.rst:55
#: ../doc/1.7/reference/configuration/cfg_storage.rst:69
#: ../doc/1.7/reference/configuration/cfg_storage.rst:79
#: ../doc/1.7/reference/configuration/cfg_storage.rst:92
#: ../doc/1.7/reference/configuration/cfg_storage.rst:102
#: ../doc/1.7/reference/configuration/cfg_storage.rst:114
#: ../doc/1.7/reference/configuration/cfg_storage.rst:126
#: ../doc/1.7/reference/configuration/cfg_storage.rst:138
#: ../doc/1.7/reference/configuration/cfg_storage.rst:150
#: ../doc/1.7/reference/configuration/cfg_storage.rst:161
#: ../doc/1.7/reference/configuration/cfg_storage.rst:172
msgid "Dynamic: no"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:30
msgid ""
"Add the given string to the server's process title (what’s shown in the COMMAND "
"column for ``ps -ef`` and ``top -c`` commands)."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:34
msgid ""
"For example, ordinarily :samp:`ps -ef` shows the Tarantool server process thus:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:37
msgid ""
"$ ps -ef | grep tarantool\n"
"1000     14939 14188  1 10:53 pts/2    00:00:13 tarantool <running>"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:42
msgid ""
"But if the configuration parameters include ``custom_proc_title='sessions'`` "
"then the output looks like:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:45
msgid ""
"$ ps -ef | grep tarantool\n"
"1000     14939 14188  1 10:53 pts/2    00:00:16 tarantool <running>: sessions"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:50
#: ../doc/1.7/reference/configuration/cfg_basic.rst:84
#: ../doc/1.7/reference/configuration/cfg_basic.rst:95
#: ../doc/1.7/reference/configuration/cfg_basic.rst:123
#: ../doc/1.7/reference/configuration/cfg_basic.rst:148
#: ../doc/1.7/reference/configuration/cfg_basic.rst:162
#: ../doc/1.7/reference/configuration/cfg_basic.rst:187
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:63
#: ../doc/1.7/reference/configuration/cfg_logging.rst:102
#: ../doc/1.7/reference/configuration/cfg_replication.rst:31
msgid "Type: string"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:51
#: ../doc/1.7/reference/configuration/cfg_basic.rst:73
#: ../doc/1.7/reference/configuration/cfg_basic.rst:96
#: ../doc/1.7/reference/configuration/cfg_basic.rst:149
#: ../doc/1.7/reference/configuration/cfg_basic.rst:188
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:48
#: ../doc/1.7/reference/configuration/cfg_logging.rst:103
#: ../doc/1.7/reference/configuration/cfg_networking.rst:14
#: ../doc/1.7/reference/configuration/cfg_replication.rst:32
msgid "Default: null"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:52
#: ../doc/1.7/reference/configuration/cfg_basic.rst:74
#: ../doc/1.7/reference/configuration/cfg_basic.rst:113
#: ../doc/1.7/reference/configuration/cfg_basic.rst:140
#: ../doc/1.7/reference/configuration/cfg_basic.rst:203
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:68
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:45
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:69
msgid "Dynamic: yes"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:58
msgid ""
"The read/write data port number or :ref:`URI <index-uri>` (Universal Resource "
"Identifier) string. Has no default value, so **must be specified** if "
"connections will occur from remote clients that do not use the :ref:`“admin "
"port” <admin-security>`. Connections made with :samp:`listen = {URI}` are called "
"\"binary port\" or \"binary protocol\" connections."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:65
msgid "A typical value is 3301."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:69
msgid ""
"A replica also binds to this port, and accepts connections, but these "
"connections can only serve reads until the replica becomes a master."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:72
msgid "Type: integer or string"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:80
msgid ""
"A directory where memtx stores snapshot (.snap) files. Can be relative to :ref:"
"`work_dir <cfg_basic-work_dir>`. If not specified, defaults to ``work_dir``. See "
"also :ref:`wal_dir <cfg_basic-wal_dir>`."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:85
#: ../doc/1.7/reference/configuration/cfg_basic.rst:124
#: ../doc/1.7/reference/configuration/cfg_basic.rst:163
msgid "Default: \".\""
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:92
msgid ""
"Store the process id in this file. Can be relative to :ref:`work_dir <cfg_basic-"
"work_dir>`. A typical value is “:file:`tarantool.pid`”."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:103
msgid ""
"Say ``box.cfg{read_only=true...}`` to put the server instance in read-only mode. "
"After this, any requests that try to change persistent data will fail with "
"error :errcode:`ER_READONLY`. Read-only mode should be used for master-replica :"
"ref:`replication <replication>`. Read-only mode does not affect data-change "
"requests for spaces defined as :ref:`temporary <box_schema-space_create>`. "
"Although read-only mode prevents the server from writing to the :ref:`WAL "
"<internals-wal>`, it does not prevent writing diagnostics with the :ref:`log "
"module <log-module>`."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:119
msgid ""
"A directory where vinyl files or subdirectories will be stored. Can be relative "
"to :ref:`work_dir <cfg_basic-work_dir>`. If not specified, defaults to "
"``work_dir``."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:131
msgid ""
"The vinyl storage engine has a scheduler which does compaction. When vinyl is "
"low on available memory, the compaction scheduler may be unable to keep up with "
"incoming update requests. In that situation, queries may time out after "
"``vinyl_timeout`` seconds. This should rarely occur, since normally vinyl would "
"throttle inserts when it is running low on compaction bandwidth."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:138
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:47
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:75
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:93
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:108
#: ../doc/1.7/reference/configuration/cfg_logging.rst:128
#: ../doc/1.7/reference/configuration/cfg_networking.rst:13
#: ../doc/1.7/reference/configuration/cfg_storage.rst:28
#: ../doc/1.7/reference/configuration/cfg_storage.rst:67
#: ../doc/1.7/reference/configuration/cfg_storage.rst:148
msgid "Type: float"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:139
msgid "Default: 60"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:146
msgid "UNIX user name to switch to after start."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:156
msgid ""
"A directory where write-ahead log (.xlog) files are stored. Can be relative to :"
"ref:`work_dir <cfg_basic-work_dir>`. Sometimes ``wal_dir`` and :ref:`memtx_dir "
"<cfg_basic-memtx_dir>` are specified with different values, so that write-ahead "
"log files and snapshot files can be stored on different disks. If not specified, "
"defaults to ``work_dir``."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:170
msgid ""
"A directory where database working files will be stored. The server instance "
"switches to ``work_dir`` with :manpage:`chdir(2)` after start. Can be relative "
"to the current directory. If not specified, defaults to the current directory. "
"Other directory parameters may be relative to ``work_dir``, for example:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:176
msgid ""
"box.cfg{\n"
"    work_dir = '/home/user/A',\n"
"    wal_dir = 'B',\n"
"    memtx_dir = 'C'\n"
"}"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:184
msgid ""
"will put xlog files in ``/home/user/A/B``, snapshot files in ``/home/user/A/C``, "
"and all other files or subdirectories in ``/home/user/A``."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:196
msgid ""
"The maximum number of threads to use during execution of certain internal "
"processes (currently :ref:`socket.getaddrinfo() <socket-getaddrinfo>` and :ref:"
"`coio_call() <c_api-coio-coio_call>`)."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:201
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:32
#: ../doc/1.7/reference/configuration/cfg_logging.rst:27
#: ../doc/1.7/reference/configuration/cfg_networking.rst:30
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:43
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:67
#: ../doc/1.7/reference/configuration/cfg_storage.rst:41
#: ../doc/1.7/reference/configuration/cfg_storage.rst:53
#: ../doc/1.7/reference/configuration/cfg_storage.rst:77
#: ../doc/1.7/reference/configuration/cfg_storage.rst:90
#: ../doc/1.7/reference/configuration/cfg_storage.rst:100
#: ../doc/1.7/reference/configuration/cfg_storage.rst:112
#: ../doc/1.7/reference/configuration/cfg_storage.rst:124
#: ../doc/1.7/reference/configuration/cfg_storage.rst:136
#: ../doc/1.7/reference/configuration/cfg_storage.rst:159
#: ../doc/1.7/reference/configuration/cfg_storage.rst:170
msgid "Type: integer"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:202
msgid "Default: 4"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:229
msgid "Configuring the storage"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:1
msgid ":ref:`memtx_memory <cfg_storage-memtx_memory>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:2
msgid ":ref:`memtx_max_tuple_size <cfg_storage-memtx_max_tuple_size>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:3
msgid ":ref:`memtx_min_tuple_size <cfg_storage-memtx_min_tuple_size>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:4
msgid ":ref:`vinyl_bloom_fpr <cfg_storage-vinyl_bloom_fpr>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:5
msgid ":ref:`vinyl_cache <cfg_storage-vinyl_cache>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:6
msgid ":ref:`vinyl_max_tuple_size <cfg_storage-vinyl_max_tuple_size>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:7
msgid ":ref:`vinyl_memory <cfg_storage-vinyl_memory>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:8
msgid ":ref:`vinyl_page_size <cfg_storage-vinyl_page_size>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:9
msgid ":ref:`vinyl_range_size <cfg_storage-vinyl_range_size>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:10
msgid ":ref:`vinyl_run_count_per_level <cfg_storage-vinyl_run_count_per_level>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:11
msgid ":ref:`vinyl_run_size_ratio <cfg_storage-vinyl_run_size_ratio>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:12
msgid ":ref:`vinyl_read_threads <cfg_storage-vinyl_read_threads>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:13
msgid ":ref:`vinyl_write_threads <cfg_storage-vinyl_write_threads>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:19
msgid ""
"How much memory Tarantool allocates to actually store tuples, in bytes. When the "
"limit is reached, :ref:`INSERT <box_space-insert>` or :ref:`UPDATE <box_space-"
"insert>` requests begin failing with error :errcode:`ER_MEMORY_ISSUE`. The "
"server does not go beyond the ``memtx_memory`` limit to allocate tuples, but "
"there is additional memory used to store indexes and connection information. "
"Depending on actual configuration and workload, Tarantool can consume up to 20% "
"more than the ``memtx_memory`` limit."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:29
msgid "Default: 256 * 1024 * 1024 = 268435456"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:36
msgid ""
"Size of the largest allocation unit, in bytes, for the memtx storage engine. It "
"can be increased if it is necessary to store large tuples. See also: :ref:"
"`vinyl_max_tuple_size <cfg_storage-vinyl_max_tuple_size>`."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:42
#: ../doc/1.7/reference/configuration/cfg_storage.rst:91
msgid "Default: 1024 * 1024 = 1048576"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:49
msgid ""
"Size of the smallest allocation unit, in bytes. It can be decreased if most of "
"the tuples are very small. The value must be between 8 and 1048280 inclusive."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:54
msgid "Default: 16"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:61
msgid ""
"Bloom filter false positive rate -- the suitable probability of the `bloom "
"filter <https://en.wikipedia.org/wiki/Bloom_filter>`_ to give a wrong result. "
"The ``vinyl_bloom_fpr`` setting can be overridden by a :ref:`create_index "
"<box_space-create_index>` option."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:68
msgid "Default = 0.05"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:75
msgid "The maximal cache size for the vinyl storage engine, in bytes."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:78
#: ../doc/1.7/reference/configuration/cfg_storage.rst:101
msgid "Default = 128 * 1024 * 1024 = 134217728"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:85
msgid ""
"Size of the largest allocation unit, in bytes, for the vinyl storage engine. It "
"can be increased if it is necessary to store large tuples. See also: :ref:"
"`memtx_max_tuple_size <cfg_storage-memtx_max_tuple_size>`."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:98
msgid "The maximum number of in-memory bytes that vinyl uses."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:108
msgid ""
"Page size, in bytes. Page is a read/write unit for vinyl disk operations. The "
"``vinyl_page_size`` setting can be overridden by a :ref:`create_index <box_space-"
"create_index>` option."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:113
msgid "Default = 8 * 1024 = 8192"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:120
msgid ""
"The maximal range size for vinyl, in bytes. The ``vinyl_range_size`` setting can "
"be overridden by a :ref:`create_index <box_space-create_index>` option."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:125
msgid "Default = 1024 * 1024 * 1024 = 1073741824"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:132
msgid ""
"The maximal number of runs per level in vinyl LSM tree. If this number is "
"exceeded, a new level is created. This can be overridden by a :ref:`create_index "
"<box_space-create_index>` option."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:137
#: ../doc/1.7/reference/configuration/cfg_storage.rst:171
msgid "Default = 2"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:144
msgid ""
"Ratio between the sizes of different levels in the LSM tree. The "
"``vinyl_run_size_ratio`` setting can be overridden by a :ref:`create_index "
"<box_space-create_index>` option."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:149
msgid "Default = 3.5"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:156
msgid ""
"The maximum number of read threads that vinyl can use for some concurrent "
"operations, such as I/O and compression."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:160
msgid "Default = 1"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:167
msgid ""
"The maximum number of write threads that vinyl can use for some concurrent "
"operations, such as I/O and compression."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:237
msgid "Checkpoint daemon"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:1
msgid ":ref:`checkpoint_count <cfg_checkpoint_daemon-checkpoint_count>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:2
msgid ":ref:`checkpoint_interval <cfg_checkpoint_daemon-checkpoint_interval>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:4
msgid ""
"The checkpoint daemon is a fiber which is constantly running. At intervals, it "
"may make new :ref:`snapshot (.snap) files <index-box_persistence>` and then may "
"delete old snapshot files. If the checkpoint daemon deletes an old snapshot "
"file, then it will also delete any :ref:`write-ahead log (.xlog) <internals-"
"wal>` files which are older than the snapshot file and which contain information "
"that is present in the snapshot file. It will also delete obsolete vinyl .run "
"files."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:11
msgid ""
"Exceptions: the checkpoint daemon will not delete a file if a backup is ongoing "
"and the file has not been backed up (see :ref:`\"Hot backup\" <admin-backups-"
"hot_backup_vinyl_memtx>`), or if replication is ongoing and the file has not "
"been relayed to a replica (see :ref:`\"Replication architecture\" <replication-"
"architecture>`), or if a replica is connecting."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:18
msgid ""
"The :ref:`checkpoint_interval <cfg_checkpoint_daemon-checkpoint_interval>` and :"
"ref:`checkpoint_count <cfg_checkpoint_daemon-checkpoint_count>` configuration "
"settings determine how long the intervals are, and how many snapshots should "
"exist before deletions occur."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:27
msgid ""
"The interval between actions by the checkpoint daemon, in seconds. If "
"``checkpoint_interval`` is set to a value greater than zero, and there is "
"activity which causes change to a database, then the checkpoint daemon will "
"call :ref:`box.snapshot <box-snapshot>` every ``checkpoint_interval`` seconds, "
"creating a new snapshot file each time. If ``checkpoint_interval`` is set to "
"zero, then the checkpoint daemon is disabled."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:36
msgid "box.cfg{checkpoint_interval=60}"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:40
msgid ""
"will cause the checkpoint daemon to create a new database snapshot once per "
"minute, if there is activity."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:44
msgid "Default: 3600 (one hour)"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:51
msgid ""
"The maximum number of snapshots that may exist on the  :ref:`memtx_dir "
"<cfg_basic-memtx_dir>` directory before the checkpoint daemon will delete old "
"snapshots. If ``checkpoint_count`` equals zero, then the checkpoint daemon does "
"not delete old snapshots. For example:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:56
msgid ""
"box.cfg{\n"
"    checkpoint_interval = 3600,\n"
"    checkpoint_count  = 10\n"
"}"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:63
msgid ""
"will cause the checkpoint daemon to create a new snapshot each hour until it has "
"created ten snapshots. After that, it will delete the oldest snapshot (and any "
"associated write-ahead-log files) after creating a new one."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:76
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:68
msgid "Default: 2"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:243
msgid "Binary logging and snapshots"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:1
msgid ":ref:`force_recovery <cfg_binary_logging_snapshots-force_recovery>`,"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:2
msgid ":ref:`rows_per_wal <cfg_binary_logging_snapshots-rows_per_wal>`,"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:3
msgid ""
":ref:`snap_io_rate_limit <cfg_binary_logging_snapshots-snap_io_rate_limit>`,"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:4
msgid ":ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>`,"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:5
msgid ""
":ref:`wal_dir_rescan_delay <cfg_binary_logging_snapshots-wal_dir_rescan_delay>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:11
msgid ""
"If ``force_recovery`` equals true, Tarantool tries to continue if there is an "
"error while reading a :ref:`snapshot file<index-box_persistence>` (at server "
"instance start) or a :ref:`write-ahead log file<internals-wal>` (at server "
"instance start or when applying an update at a replica): skips invalid records, "
"reads as much data as possible and re-builds the file."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:17
msgid "Otherwise, Tarantool aborts recovery on read errors."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:20
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:56
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:67
#: ../doc/1.7/reference/configuration/cfg_logging.rst:117
msgid "Default: true"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:27
msgid ""
"How many log records to store in a single write-ahead log file. When this limit "
"is reached, Tarantool creates another WAL file named :samp:`{<first-lsn-in-wal>}."
"xlog`. This can be useful for simple rsync-based backups."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:33
msgid "Default: 500000"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:40
msgid ""
"Reduce the throttling effect of :ref:`box.snapshot <box-snapshot>` on INSERT/"
"UPDATE/DELETE performance by setting a limit on how many megabytes per second it "
"can write to disk. The same can be achieved by splitting :ref:`wal_dir "
"<cfg_basic-wal_dir>` and :ref:`memtx_dir <cfg_basic-memtx_dir>` locations and "
"moving snapshots to a separate disk."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:49
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:65
#: ../doc/1.7/reference/configuration/cfg_logging.rst:29
#: ../doc/1.7/reference/configuration/cfg_logging.rst:130
#: ../doc/1.7/reference/configuration/cfg_networking.rst:15
#: ../doc/1.7/reference/configuration/cfg_networking.rst:32
#: ../doc/1.7/reference/configuration/cfg_replication.rst:33
msgid "Dynamic: **yes**"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:55
msgid "Specify fiber-WAL-disk synchronization mode as:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:57
msgid "``none``: write-ahead log is not maintained;"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:58
msgid ""
"``write``: :ref:`fibers <fiber-fibers>` wait for their data to be written to the "
"write-ahead log (no :manpage:`fsync(2)`);"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:60
msgid ""
"``fsync``: fibers wait for their data, :manpage:`fsync(2)` follows each :manpage:"
"`write(2)`;"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:64
msgid "Default: \"write\""
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:71
msgid ""
"Number of seconds between periodic scans of the write-ahead-log file directory, "
"when checking for changes to write-ahead-log files for the sake of :ref:"
"`replication <replication>` or :ref:`hot standby <index-hot_standby>`."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:251
msgid "Hot standby"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:3
msgid "Whether to start the server in **hot standby** mode."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:5
msgid ""
"Hot standby is a feature which provides a simple form of failover without :ref:"
"`replication <replication>`."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:8
msgid ""
"The expectation is that there will be two instances of the server using the same "
"configuration. The first one to start will be the \"primary\" instance. The "
"second one to start will be the \"standby\" instance."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:12
msgid ""
"To initiate the standby instance, start a second instance of the Tarantool "
"server on the same computer with the same :ref:`box.cfg <box_introspection-"
"box_cfg>` configuration settings -- including the same directories and same non-"
"null URIs -- and with the additional configuration setting ``hot_standby = "
"true``. Expect to see a notification ending with the words ``I> Entering hot "
"standby mode``. This is fine. It means that the standby instance is ready to "
"take over if the primary instance goes down."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:21
msgid ""
"The standby instance will initialize and will try to take a lock on :ref:"
"`wal_dir <cfg_basic-wal_dir>`, but will fail because the primary instance has "
"made a lock on ``wal_dir``. So the standby instance goes into a loop, reading "
"the write ahead log which the primary instance is writing (so the two instances "
"are always in synch), and trying to take the lock. If the primary instance goes "
"down for any reason, the lock will be released. in this case, the standby "
"instance will succeed in taking the lock, will connect on the :ref:`listen "
"<cfg_basic-listen>` address and will become the primary instance. Expect to see "
"a notification ending with the words ``I> ready to accept requests``."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:33
msgid "Thus there is no noticeable downtime if the primary instance goes down."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:35
msgid "Hot standby feature has no effect:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:37
msgid ""
"if :ref:`wal_dir_rescan_delay = a large number <cfg_binary_logging_snapshots-"
"wal_dir_rescan_delay>` (on Mac OS and FreeBSD); on these platforms, it is "
"designed so that the loop repeats every ``wal_dir_rescan_delay`` seconds."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:41
msgid ""
"if :ref:`wal_mode = 'none' <cfg_binary_logging_snapshots-wal_mode>`; it is "
"designed to work with ``wal_mode = 'write'`` or ``wal_mode = 'fsync'``."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:43
msgid ""
"for spaces created with :ref:`engine = 'vinyl' <box_schema-space_create>`; it is "
"designed to work for spaces created with ``engine = 'memtx'``."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_replication.rst:1
msgid ":ref:`replication <cfg_replication-replication>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_replication.rst:7
msgid ""
"If ``replication`` is not an empty string, the instance is considered to be a "
"Tarantool :ref:`replica <replication>`. The replica will try to connect to the "
"master specified in ``replication`` with a :ref:`URI <index-uri>` (Universal "
"Resource Identifier), for example:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_replication.rst:12
msgid ":samp:`{konstantin}:{secret_password}@{tarantool.org}:{3301}`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_replication.rst:14
msgid ""
"If there is more than one replication source in a replica set, specify an array "
"of URIs, for example: (replace 'uri' and 'uri2' in this example with valid URIs):"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_replication.rst:17
msgid ":extsamp:`box.cfg{ replication = { {*{'uri1'}*}, {*{'uri2'}*} } }`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_replication.rst:19
msgid ""
"If one of the URIs is \"self\" -- that is, if one of the URIs is for the "
"instance where ``box.cfg{}`` is being executed on -- then it is ignored. Thus it "
"is possible to use the same ``replication`` specification on multiple server "
"instances."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_replication.rst:24
msgid ""
"The default user name is ‘guest’. A replica does not accept data-change requests "
"on the :ref:`listen <cfg_basic-listen>` port. The ``replication`` parameter is "
"dynamic, that is, to enter master mode, simply set ``replication`` to an empty "
"string and issue:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_replication.rst:29
#, fuzzy
msgid ":extsamp:`box.cfg{ replication = {*{new-value}*} }`"
msgstr "box.cfg{ replication_source = *uri#2* }"

#: ../doc/1.7/reference/configuration/index.rst:263
msgid "Networking"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_networking.rst:1
msgid ":ref:`io_collect_interval <cfg_networking-io_collect_interval>`,"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_networking.rst:2
msgid ":ref:`readahead <cfg_networking-readahead>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_networking.rst:8
msgid ""
"The instance will sleep for io_collect_interval seconds between iterations of "
"the event loop. Can be used to reduce CPU load in deployments in which the "
"number of client connections is large, but requests are not so frequent (for "
"example, each connection issues just a handful of requests per second)."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_networking.rst:21
msgid ""
"The size of the read-ahead buffer associated with a client connection. The "
"larger the buffer, the more memory an active connection consumes and the more "
"requests can be read from the operating system buffer in a single system call. "
"The rule of thumb is to make sure the buffer can contain at least a few dozen "
"requests. Therefore, if a typical tuple in a request is large, e.g. a few "
"kilobytes or even megabytes, the read-ahead buffer size should be increased. If "
"batched request processing is not used, it’s prudent to leave this setting at "
"its default."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_networking.rst:31
msgid "Default: 16320"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:3
msgid ":ref:`log_level <cfg_logging-log_level>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:4
msgid ":ref:`log <cfg_logging-log>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:5
msgid ":ref:`log_nonblock <cfg_logging-log_nonblock>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:6
msgid ":ref:`too_long_threshold <cfg_logging-too_long_threshold>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:12
msgid ""
"What level of detail the :ref:`log <admin-logs>` will have. There are seven "
"levels:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:14
#: ../doc/1.7/reference/reference_lua/log.rst:61
msgid "1 – ``SYSERROR``"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:15
msgid "2 – ``ERROR``"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:16
#: ../doc/1.7/reference/reference_lua/log.rst:63
msgid "3 – ``CRITICAL``"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:17
msgid "4 – ``WARNING``"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:18
msgid "5 – ``INFO``"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:19
msgid "6 – ``VERBOSE``"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:20
msgid "7 – ``DEBUG``"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:22
msgid ""
"By setting log_level, one can enable logging of all classes below or equal to "
"the given level. Tarantool prints its logs to the standard error stream by "
"default, but this can be changed with the :ref:`log <cfg_logging-log>` "
"configuration parameter."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:28
msgid "Default: 5"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:31
msgid ""
"Warning: prior to Tarantool 1.7.5 there were only six levels and ``DEBUG`` was "
"level 6. Starting with Tarantool 1.7.5 ``VERBOSE`` is level 6 and ``DEBUG`` is "
"level 7. ``VERBOSE`` is a new level for monitoring repetitive events which would "
"cause too much log writing if ``INFO`` were used instead."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:40
msgid ""
"By default, Tarantool sends the log to the standard error stream (``stderr``). "
"If ``log`` is specified, Tarantool sends the log to a file, or to a pipe, or to "
"the system logger."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:44
#: ../doc/1.7/reference/configuration/cfg_logging.rst:56
#: ../doc/1.7/reference/configuration/cfg_logging.rst:70
msgid "Example setting:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:46
msgid ""
"box.cfg{log = 'tarantool.log'}\n"
"-- or\n"
"box.cfg{log = 'file: tarantool.log'}"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:52
msgid ""
"This will open the file ``tarantool.log`` for output on the server’s default "
"directory. If the ``log`` string has no prefix or has the prefix \"file:\", then "
"the string is interpreted as a file path."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:58
msgid ""
"box.cfg{log = '| cronolog tarantool.log'}\n"
"-- or\n"
"box.cfg{log = 'pipe: cronolog tarantool.log'}'"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:64
msgid ""
"This will start the program `cronolog <https://linux.die.net/man/1/cronolog>`_ "
"when the server starts, and will send all log messages to the standard input "
"(``stdin``) of cronolog. If the ``log`` string begins with '|' or has the prefix "
"\"pipe:\", then the string is interpreted as a Unix `pipeline <https://en."
"wikipedia.org/wiki/Pipeline_%28Unix%29>`_."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:72
msgid ""
"box.cfg{log = 'syslog:identity=tarantool'}\n"
"-- or\n"
"box.cfg{log = 'syslog:facility=user'}\n"
"-- or\n"
"box.cfg{log = 'syslog:identity=tarantool,facility=user'}"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:80
msgid ""
"If the ``log`` string has the prefix \"syslog:\", then the string is interpreted "
"as a message for the `syslogd <http://www.rfc-base.org/txt/rfc-5424.txt>`_ "
"program which normally is running in the background of any Unix-like platform. "
"One can optionally specify an ``identity``, a ``facility``, or both. The "
"``identity`` is an arbitrary string, default value = ``tarantool``, which will "
"be placed at the beginning of all messages. The facility is an abbreviation for "
"the name of one of the `syslog <https://en.wikipedia.org/wiki/Syslog>`_ "
"facilities, default value = ``user``, which tell syslogd where the message "
"should go."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:91
msgid ""
"Possible values for ``facility`` are: auth, authpriv, cron, daemon, ftp, kern, "
"lpr, mail, news, security, syslog, user, uucp, local0, local1, local2, local3, "
"local4, local5, local6, local7."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:95
msgid ""
"The ``facility`` setting is currently ignored but will be used in the future."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:97
msgid ""
"When logging to a file, Tarantool reopens the log on `SIGHUP <https://en."
"wikipedia.org/wiki/SIGHUP>`_. When log is a program, its pid is saved in the :"
"ref:`log.logger_pid <log-logger_pid>` variable. You need to send it a signal to "
"rotate logs."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:110
msgid ""
"If ``log_nonblock`` equals true, Tarantool does not block on the log file "
"descriptor when it’s not ready for write, and drops the message instead. If :ref:"
"`log_level <cfg_logging-log_level>` is high, and many messages go to the log "
"file, setting ``log_nonblock`` to true may improve logging performance at the "
"cost of some log messages getting lost."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:124
msgid ""
"If processing a request takes longer than the given value (in seconds), warn "
"about it in the log. Has effect only if :ref:`log_level <cfg_logging-log_level>` "
"is more than or equal to 4 (WARNING)."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:129
msgid "Default: 0.5"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:136
#, fuzzy
msgid "Logging example"
msgstr "Например:"

#: ../doc/1.7/reference/configuration/cfg_logging.rst:138
msgid ""
"This will illustrate how \"rotation\" works, that is, what happens when the "
"server instance is writing to a log and signals are used when archiving it."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:141
msgid "Start with two terminal shells, Terminal #1 and Terminal #2."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:143
msgid ""
"On Terminal #1: start an interactive Tarantool session, then say the logging "
"will go to `Log_file`, then put a message \"Log Line #1\" in the log file:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:146
msgid ""
"box.cfg{log='Log_file'}\n"
"log = require('log')\n"
"log.info('Log Line #1')"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:152
msgid ""
"On Terminal #2: use ``mv`` so the log file is now named `Log_file.bak`. The "
"result of this is: the next log message will go to `Log_file.bak`."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:1082
msgid "mv Log_file Log_file.bak"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:160
msgid "On Terminal #1: put a message \"Log Line #2\" in the log file."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:162
msgid "log.info('Log Line #2')"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:166
msgid ""
"On Terminal #2: use ``ps`` to find the process ID of the Tarantool instance."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:1095
msgid "ps -A | grep tarantool"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:173
msgid ""
"On Terminal #2: use ``kill -HUP`` to send a SIGHUP signal to the Tarantool "
"instance. The result of this is: Tarantool will open `Log_file` again, and the "
"next log message will go to `Log_file`. (The same effect could be accomplished "
"by executing log.rotate() on the instance.)"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:1105
msgid "kill -HUP *process_id*"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:183
msgid "On Terminal #1: put a message \"Log Line #3\" in the log file."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:185
msgid "log.info('Log Line #3')"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:189
msgid ""
"On Terminal #2: use ``less`` to examine files. `Log_file.bak` will have these "
"lines, except that the date and time will depend on when the example is done:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:1119
msgid ""
"2015-11-30 15:13:06.373 [27469] main/101/interactive I> Log Line #1`\n"
"2015-11-30 15:14:25.973 [27469] main/101/interactive I> Log Line #2`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:198
msgid "and `Log_file` will have"
msgstr ""

#: ../internal after doc/1.7/reference/configuration/cfg_logging.rst:1127 padding
msgid ""
"log file has been reopened\n"
"2015-11-30 15:15:32.629 [27469] main/101/interactive I> Log Line #3"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:275
#, fuzzy
msgid "Deprecated parameters"
msgstr "Параметры конфигурации"

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:3
msgid "These parameters are deprecated since Tarantool version 1.7.4:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:5
msgid ":ref:`coredump <cfg_basic-coredump_deprecated>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:6
msgid ":ref:`logger <cfg_logging-logger_deprecated>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:7
msgid ":ref:`logger_nonblock <cfg_logging-logger_nonblock_deprecated>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:8
msgid ""
":ref:`panic_on_snap_error <cfg_binary_logging_snapshots-"
"panic_on_snap_error_deprecated>`,"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:9
msgid ""
":ref:`panic_on_wal_error <cfg_binary_logging_snapshots-"
"panic_on_wal_error_deprecated>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:10
#, fuzzy
msgid ":ref:`replication_source <cfg_replication-replication_source_deprecated>`"
msgstr ""
"Этот запрос можно выполнить в любой момент, т.к. параметр :ref:"
"`replication_source <cfg_replication-replication_source>` можно задавать на ходу."

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:11
msgid ":ref:`slab_alloc_arena <cfg_storage-slab_alloc_arena_deprecated>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:12
msgid ":ref:`slab_alloc_factor <cfg_storage-slab_alloc_factor_deprecated>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:13
msgid ":ref:`slab_alloc_maximal <cfg_storage-slab_alloc_maximal_deprecated>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:14
msgid ":ref:`slab_alloc_minimal <cfg_storage-slab_alloc_minimal_deprecated>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:15
msgid ":ref:`snap_dir <cfg_basic-snap_dir_deprecated>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:16
msgid ":ref:`snapshot_count <cfg_checkpoint_daemon-snapshot_count_deprecated>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:17
msgid ":ref:`snapshot_period <cfg_checkpoint_daemon-snapshot_period_deprecated>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:23
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:101
msgid "**Deprecated**, do not use."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:33
msgid ""
"**Deprecated** in favor of :ref:`log <cfg_logging-log>`. The parameter was only "
"renamed, while the type, values and semantics remained intact."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:41
msgid ""
"**Deprecated** in favor of :ref:`log_nonblock <cfg_logging-log_nonblock>`. The "
"parameter was only renamed, while the type, values and semantics remained intact."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:49
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:63
msgid ""
"**Deprecated** in favor of :ref:`force_recovery <cfg_binary_logging_snapshots-"
"force_recovery>`."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:52
msgid ""
"If there is an error while reading a snapshot file (at server instance start), "
"abort."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:74
msgid ""
"**Deprecated** in favor of :ref:`replication <cfg_replication-replication>`. The "
"parameter was only renamed, while the type, values and semantics remained intact."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:83
msgid "**Deprecated** in favor of :ref:`memtx_memory <cfg_storage-memtx_memory>`."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:86
msgid ""
"How much memory Tarantool allocates to actually store tuples, **in gigabytes**. "
"When the limit is reached, INSERT or UPDATE requests begin failing with error :"
"errcode:`ER_MEMORY_ISSUE`. While the server does not go beyond the defined limit "
"to allocate tuples, there is additional memory used to store indexes and "
"connection information. Depending on actual configuration and workload, "
"Tarantool can consume up to 20% more than the limit set here."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:94
msgid "Default: 1.0"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:103
msgid ""
"The multiplier for computing the sizes of memory chunks that tuples are stored "
"in. A lower value may result in less wasted memory depending on the total amount "
"of memory available and the distribution of item sizes."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:109
msgid "Default: 1.1"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:116
msgid ""
"**Deprecated** in favor of :ref:`memtx_max_tuple_size <cfg_storage-"
"memtx_max_tuple_size>`. The parameter was only renamed, while the type, values "
"and semantics remained intact."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:125
msgid ""
"**Deprecated** in favor of :ref:`memtx_min_tuple_size <cfg_storage-"
"memtx_min_tuple_size>`. The parameter was only renamed, while the type, values "
"and semantics remained intact."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:134
msgid ""
"**Deprecated** in favor of :ref:`memtx_dir <cfg_basic-memtx_dir>`. The parameter "
"was only renamed, while the type, values and semantics remained intact."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:142
msgid ""
"**Deprecated** in favor of :ref:`checkpoint_interval <cfg_checkpoint_daemon-"
"checkpoint_interval>`. The parameter was only renamed, while the type, values "
"and semantics remained intact."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:151
msgid ""
"**Deprecated** in favor of :ref:`checkpoint_count <cfg_checkpoint_daemon-"
"checkpoint_count>`. The parameter was only renamed, while the type, values and "
"semantics remained intact."
msgstr ""

#: ../doc/1.7/reference/index.rst:39
msgid "Reference"
msgstr "Справочники"

#: ../doc/1.7/reference/lua_tips.rst:39
msgid "Tips on Lua syntax"
msgstr ""

#: ../doc/1.7/reference/lua_tips.rst:41
msgid ""
"The Lua syntax for :ref:`data-manipulation functions <index-box_data-"
"operations>` can vary. Here are examples of the variations with ``select()`` "
"requests. The same rules exist for the other data-manipulation functions."
msgstr ""

#: ../doc/1.7/reference/lua_tips.rst:45
#, fuzzy
msgid ""
"Every one of the examples does the same thing: select a tuple set from a space "
"named 'tester' where the primary-key field value equals 1. For these examples, "
"we assume that the numeric id of 'tester' is 512, which happens to be the case "
"in our sandbox example only."
msgstr ""
"Lua-синтаксис в данных функциях может различаться. Далее приводятся варианты "
"таких различий на примере SELECT-запросов. Аналогичные правила существуют и для "
"остальных функций. В каждом из приведенных примеров выполняются следующие "
"действия: производится выборка по набору кортежей из пространства с именем "
"'tester', где значение поля, которое соответствует ключу в первичном индексе, "
"равно 1. Также во всех примерах мы подразумеваем, что числовой идентификатор "
"пространства 'tester' равен 512, но это верно только для нашей тестовой базы."

#: ../doc/1.7/reference/lua_tips.rst:52
#, fuzzy
msgid "First, there are three **object reference variations**:"
msgstr "Во-первых, есть пять *способов ссылки на объект*:"

#: ../doc/1.7/reference/lua_tips.rst:54
msgid ""
"-- #1 module . submodule . name\n"
"tarantool> box.space.tester:select{1}\n"
"-- #2 replace name with a literal in square brackets\n"
"tarantool> box.space['tester']:select{1}\n"
"-- #3 use a variable for the entire object reference\n"
"tarantool> s = box.space.tester\n"
"tarantool> s:select{1}"
msgstr ""

#: ../doc/1.7/reference/lua_tips.rst:64
#, fuzzy
msgid ""
"Examples in this manual usually have the \":samp:`box.space.{tester}:`\" form "
"(#1). However, this is a matter of user preference and all the variations exist "
"in the wild."
msgstr ""
"Для примеров в остальной части документации мы будем, как правило, использовать "
"вариант синтаксиса #1, например \":samp:`box.space.{tester}:`\". Но вы можете с "
"тем же успехом пользоваться любым из пяти описанных выше вариантов."

#: ../doc/1.7/reference/lua_tips.rst:68
#, fuzzy
msgid ""
"Also, descriptions in this manual use the syntax \"``space_object:``\" for "
"references to objects which are spaces, and \"``index_object:``\" for references "
"to objects which are indexes (for example :samp:`box.space.{tester}.index."
"{primary}:`)."
msgstr ""
"Также мы в дальнейшем будем использовать синтаксис типа  \":code:`space_object:`"
"\" для ссылки на пространства (как в приведенных выше примерах) и \":code:"
"`index_object:`\" для ссылки на индексы (например, :samp:`box.space.{tester}."
"index.{primary}:`)."

#: ../doc/1.7/reference/lua_tips.rst:75
#, fuzzy
msgid "Then, there are seven **parameter variations**:"
msgstr "Во-вторых, есть семь *способов задания параметров*:"

#: ../doc/1.7/reference/lua_tips.rst:77
msgid ""
"-- #1\n"
"tarantool> box.space.tester:select{1}\n"
"-- #2\n"
"tarantool> box.space.tester:select({1})\n"
"-- #3\n"
"tarantool> box.space.tester:select(1)\n"
"-- #4\n"
"tarantool> box.space.tester.select(box.space.tester,1)\n"
"-- #5\n"
"tarantool> box.space.tester:select({1},{iterator='EQ'})\n"
"-- #6\n"
"tarantool> variable = 1\n"
"tarantool> box.space.tester:select{variable}\n"
"-- #7\n"
"tarantool> variable = {1}\n"
"tarantool> box.space.tester:select(variable)"
msgstr ""
"-- #1\n"
"tarantool> box.space.tester:select{1}\n"
"-- #2\n"
"tarantool> box.space.tester:select({1})\n"
"-- #3\n"
"tarantool> box.space.tester:select(1)\n"
"-- #4\n"
"tarantool> box.space.tester.select(box.space.tester,1)\n"
"-- #5\n"
"tarantool> box.space.tester:select({1},{iterator='EQ'})\n"
"-- #6\n"
"tarantool> variable = 1\n"
"tarantool> box.space.tester:select{variable}\n"
"-- #7\n"
"tarantool> variable = {1}\n"
"tarantool> box.space.tester:select(variable)"

#: ../doc/1.7/reference/lua_tips.rst:96
msgid ""
"Lua allows to omit parentheses ``()`` when invoking a function if its only "
"argument is a Lua table, and we use it sometimes in our examples. This is why "
"``select{1}`` is equivalent to ``select({1})``. Literal values such as ``1`` (a "
"scalar value) or ``{1}`` (a Lua table value) may be replaced by variable names, "
"as in examples #6 and #7. Although there are special cases where braces can be "
"omitted, they are preferable because they signal \"Lua table\". Examples and "
"descriptions in this manual have the ``{1}`` form. However, this too is a matter "
"of user preference and all the variations exist in the wild."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box.rst:41
msgid ""
"As well as executing Lua chunks or defining their own functions, you can exploit "
"Tarantool's storage functionality with the ``box`` module and its submodules."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box.rst:44
msgid ""
"The contents of the ``box`` module can be inspected at runtime with ``box``, "
"with no arguments. The ``box`` module contains:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/box.rst:67
msgid ""
"Every submodule contains one or more Lua functions. A few submodules contain "
"members as well as functions. The functions allow data definition (create alter "
"drop), data manipulation (insert delete update upsert select replace), and "
"introspection (inspecting contents of spaces, accessing server configuration)."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:37
msgid "Submodule `box.error`"
msgstr "Вложенный модуль `box.error`"

#: ../doc/1.7/reference/reference_lua/box_error.rst:41
msgid ""
"The ``box.error`` function is for raising an error. The difference between this "
"function and Lua's built-in `error <https://www.lua.org/pil/8.3.html>`_ function "
"is that when the error reaches the client, its error code is preserved. In "
"contrast, a Lua error would always be presented to the client as :errcode:"
"`ER_PROC_LUA`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:49
msgid ""
"When called with a Lua-table argument, the code and reason have any user-desired "
"values. The result will be those values."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:57
msgid ""
"When called without arguments, ``box.error()`` re-throws whatever the last error "
"was."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:64
msgid ""
"Emulate a request error, with text based on one of the pre-defined Tarantool "
"errors defined in the file `errcode.h <https://github.com/tarantool/tarantool/"
"blob/1.7/src/box/errcode.h>`_ in the source tree. Lua constants which correspond "
"to those Tarantool errors are defined as members of ``box.error``, for example "
"``box.error.NO_SUCH_USER == 45``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:70
msgid "number of a pre-defined error"
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:71
msgid "part of the message which will accompany the error"
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:75
#, python-format
msgid ""
"the ``NO_SUCH_USER`` message is \"``User '%s' is not found``\" -- it includes "
"one \"``%s``\" component which will be replaced with errtext. Thus a call to "
"``box.error(box.error.NO_SUCH_USER, 'joe')`` or ``box.error(45, 'joe')`` will "
"result in an error with the accompanying message \"``User 'joe' is not found``\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst
msgid "except"
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:81
msgid "whatever is specified in errcode-number."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:85
msgid ""
"tarantool> box.error{code = 555, reason = 'Arbitrary message'}\n"
"---\n"
"- error: Arbitrary message\n"
"...\n"
"tarantool> box.error()\n"
"---\n"
"- error: Arbitrary message\n"
"...\n"
"tarantool> box.error(box.error.FUNCTION_ACCESS_DENIED, 'A', 'B', 'C')\n"
"---\n"
"- error: A access denied for user 'B' to function 'C'\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:104
msgid ""
"Returns a description of the last error, as a Lua table with five members: \"line"
"\" (number) Tarantool source file line number, \"code\" (number) error's number, "
"\"type\", (string) error's C++ class, \"message\" (string) error's message, "
"\"file\" (string) Tarantool source file. Additionally, if the error is a system "
"error (for example due to a failure in socket or file io), there may be a sixth "
"member: \"errno\" (number) C standard error number."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:114
msgid "rtype: table"
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:118
msgid ""
"Clears the record of errors, so functions like `box.error()` or `box.error."
"last()` will have no effect."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:123
msgid ""
"tarantool> box.error{code = 555, reason = 'Arbitrary message'}\n"
"---\n"
"- error: Arbitrary message\n"
"...\n"
"tarantool> box.schema.space.create('#')\n"
"---\n"
"- error: Invalid identifier '#' (expected letters, digits or an underscore)\n"
"...\n"
"tarantool> box.error.last()\n"
"---\n"
"- line: 278\n"
"  code: 70\n"
"  type: ClientError\n"
"  message: Invalid identifier '#' (expected letters, digits or an underscore)\n"
"  file: /tmp/buildd/tarantool-1.7.0.252.g1654e31~precise/src/box/key_def.cc\n"
"...\n"
"tarantool> box.error.clear()\n"
"---\n"
"...\n"
"tarantool> box.error.last()\n"
"---\n"
"- null\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_once.rst:39
msgid "Function `box.once`"
msgstr "Функция `box.once`"

#: ../doc/1.7/reference/reference_lua/box_once.rst:43
msgid ""
"Execute a function, provided it has not been executed before. A passed value is "
"checked to see whether the function has already been executed. If it has been "
"executed before, nothing happens. If it has not been executed before, the "
"function is invoked."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_once.rst:48
msgid ""
"See an example of using ``box.once()`` while :ref:`bootstrapping a replica set "
"<replication-bootstrap>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_once.rst:51
msgid ""
"If an error occurs inside ``box.once()`` when initializing a database, you can "
"re-execute the failed ``box.once()`` block without stopping the database. The "
"solution is to delete the ``once`` object from the system space :ref:`_schema "
"<box_space-schema>`. Say ``box.space._schema:select{}``, find your ``once`` "
"object there and delete it. For example, re-executing a block with "
"``key='hello'`` :"
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_once.rst:58
msgid ""
"tarantool> box.space._schema:select{}\n"
"---\n"
"- - ['cluster', 'b4e15788-d962-4442-892e-d6c1dd5d13f2']\n"
"  - ['max_id', 512]\n"
"  - ['oncebye']\n"
"  - ['oncehello']\n"
"  - ['version', 1, 7, 2]\n"
"...\n"
"\n"
"tarantool> box.space._schema:delete('oncehello')\n"
"---\n"
"- ['oncehello']\n"
"...\n"
"\n"
"tarantool> box.once('hello', function() end)\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_once.rst:78
msgid "a value that will be checked"
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_once.rst:79
msgid "a function"
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_once.rst:80
msgid "arguments that must be passed to function"
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_snapshot.rst:39
#, fuzzy
msgid "Function `box.snapshot`"
msgstr "Функция `box.once`"

#: ../doc/1.7/reference/reference_lua/box_snapshot.rst:43
msgid ""
"Take a snapshot of all data and store it in :ref:`memtx_dir <cfg_basic-"
"memtx_dir>`:samp:`/{<latest-lsn>}.snap`. To take a snapshot, Tarantool first "
"enters the delayed garbage collection mode for all data. In this mode, tuples "
"which were allocated before the snapshot has started are not freed until the "
"snapshot has finished. To preserve consistency of the primary key, used to "
"iterate over tuples, a copy-on-write technique is employed. If the master "
"process changes part of a primary key, the corresponding process page is split, "
"and the snapshot process obtains an old copy of the page. In effect, the "
"snapshot process uses multi-version concurrency control in order to avoid "
"copying changes which are superseded while it is running."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_snapshot.rst:55
msgid ""
"Since a snapshot is written sequentially, one can expect a very high write "
"performance (averaging to 80MB/second on modern disks), which means an average "
"database instance gets saved in a matter of minutes."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_snapshot.rst:61
#, python-format
msgid ""
"As long as there are any changes to the parent index memory through concurrent "
"updates, there are going to be page splits, and therefore you need to have some "
"extra free memory to run this command. 10% of :ref:`memtx_memory <cfg_storage-"
"memtx_memory>` is, on average, sufficient. This statement waits until a snapshot "
"is taken and returns operation result."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_snapshot.rst:69
msgid ""
"**Change notice:** Prior to Tarantool version 1.6.6, the snapshot process caused "
"a fork, which could cause occasional latency spikes. Starting with Tarantool "
"version 1.6.6, the snapshot process creates a consistent read view and this view "
"is written to the snapshot file by a separate thread (the \"Write Ahead Log\" "
"thread)."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_snapshot.rst:75
msgid ""
"Although ``box.snapshot()`` does not cause a fork, there is a separate fiber "
"which may produce snapshots at regular intervals -- see the discussion of the :"
"ref:`checkpoint daemon <book_cfg_checkpoint_daemon>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_snapshot.rst:81
msgid ""
"tarantool> box.info.version\n"
"---\n"
"- 1.7.0-1216-g73f7154\n"
"...\n"
"tarantool> box.snapshot()\n"
"---\n"
"- ok\n"
"...\n"
"tarantool> box.snapshot()\n"
"---\n"
"- error: can't save snapshot, errno 17 (File exists)\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_snapshot.rst:96
msgid ""
"Taking a snapshot does not cause the server to start a new write-ahead log. Once "
"a snapshot is taken, old WALs can be deleted as long as all replicated data is "
"up to date. But the WAL which was current at the time ``box.snapshot()`` started "
"must be kept for recovery, since it still contains log records written after the "
"start of ``box.snapshot()``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_snapshot.rst:102
msgid ""
"An alternative way to save a snapshot is to send a SIGUSR1 signal to the "
"instance. While this approach could be handy, it is not recommended for use in "
"automation: a signal provides no way to find out whether the snapshot was taken "
"successfully or not."
msgstr ""

#: ../doc/1.7/reference/reference_lua/buffer.rst:39
#, fuzzy
msgid "Module `buffer`"
msgstr "Модуль `fiber`"

#: ../doc/1.7/reference/reference_lua/buffer.rst:41
msgid ""
"The ``buffer`` module returns a dynamically resizable buffer which is solely for "
"use as an option for methods of the :ref:`net.box module <net_box-module>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/buffer.rst:44
msgid ""
"Ordinarily the ``net.box`` methods return a Lua table. If a ``buffer`` option is "
"used, then the ``net.box`` methods return a raw MsgPack_ string. This saves time "
"on the server, if the client application has its own routine for decoding "
"MsgPack strings."
msgstr ""

#: ../doc/1.7/reference/reference_lua/buffer.rst:54
msgid "a descriptor of a buffer."
msgstr ""

#: ../doc/1.7/reference/reference_lua/buffer.rst:55
#: ../doc/1.7/reference/reference_lua/uuid.rst:73
#: ../doc/1.7/reference/reference_lua/uuid.rst:95
#: ../doc/1.7/reference/reference_lua/uuid.rst:103
msgid "cdata"
msgstr ""

#: ../doc/1.7/reference/reference_lua/buffer.rst:59
msgid ""
"Assume a Tarantool server is listening on farhost:3301. Assume it has a space "
"``T`` with one tuple: ``'ABCDE', 12345``. In this example we start up a server "
"on localhost:3302 and then use ``net.box`` routines to connect to farhost. Then "
"we create a buffer, and use it as an option for a ``conn.space...select()`` "
"call. The result will be in MsgPack_ format. To show this, we will use ``msgpack."
"ibuf_decode()`` on ``ibuf.rpos`` (the \"read position\" of the buffer). Thus we "
"do not decode on the remote server, but we do decode on the local server."
msgstr ""

#: ../doc/1.7/reference/reference_lua/buffer.rst:71
msgid ""
"box.cfg{listen=3302}\n"
"ibuf = buffer.ibuf()\n"
"net_box = require('net.box')\n"
"conn = net_box.connect('farhost:3301')\n"
"buffer = require('buffer')\n"
"conn.space.T:select({},{buffer=ibuf})\n"
"msgpack = require('msgpack')\n"
"msgpack.ibuf_decode(ibuf.rpos)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/buffer.rst:82
#, fuzzy
msgid "The result of the final request looks like this:"
msgstr "Теперь вывод на экране выглядит следующим образом:"

#: ../doc/1.7/reference/reference_lua/buffer.rst:84
msgid ""
"tarantool> msgpack.ibuf_decode(ibuf.rpos)\n"
"---\n"
"- 'cdata<char *>: 0x7f97ba10c041'\n"
"- {48: [['ABCDE', 12345]]}\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:41
msgid ""
"The ``clock`` module returns time values derived from the Posix / C "
"CLOCK_GETTIME_ function or equivalent. Most functions in the module return a "
"number of seconds; functions whose names end in \"64\" return a 64-bit number of "
"nanoseconds."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:53
msgid ""
"The wall clock time. Derived from C function clock_gettime(CLOCK_REALTIME). This "
"is the best function for knowing what the official time is, as determined by the "
"system administrator."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:57
msgid "seconds or nanoseconds since epoch (1970-01-01 00:00:00), adjusted."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:58
#: ../doc/1.7/reference/reference_lua/clock.rst:81
#: ../doc/1.7/reference/reference_lua/clock.rst:100
#: ../doc/1.7/reference/reference_lua/clock.rst:119
msgid "number or number64"
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:62
msgid ""
"-- This will print an approximate number of years since 1970.\n"
"clock = require('clock')\n"
"print(clock.time() / (365*24*60*60))"
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:68
msgid ""
"See also :ref:`fiber.time64 <fiber-time64>` and the standard Lua function `os."
"clock <http://www.lua.org/manual/5.1/manual.html#pdf-os.clock>`_."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:74
msgid ""
"The monotonic time. Derived from C function clock_gettime(CLOCK_MONOTONIC). "
"Monotonic time is similar to wall clock time but is not affected by changes to "
"or from daylight saving time, or by changes done by a user. This is the best "
"function to use with benchmarks that need to calculate elapsed time."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:80
msgid "seconds or nanoseconds since the last time that the computer was booted."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:85
msgid ""
"-- This will print nanoseconds since the start.\n"
"clock = require('clock')\n"
"print(clock.monotonic64())"
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:94
msgid ""
"The processor time. Derived from C function "
"``clock_gettime(CLOCK_PROCESS_CPUTIME_ID)``. This is the best function to use "
"with benchmarks that need to calculate how much time has been spent within a CPU."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:99
msgid "seconds or nanoseconds since processor start."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:104
msgid ""
"-- This will print nanoseconds in the CPU since the start.\n"
"clock = require('clock')\n"
"print(clock.proc64())"
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:113
msgid ""
"The thread time. Derived from C function "
"``clock_gettime(CLOCK_THREAD_CPUTIME_ID)``. This is the best function to use "
"with benchmarks that need to calculate how much time has been spent within a "
"thread within a CPU."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:118
msgid "seconds or nanoseconds since the transaction processor thread started."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:123
msgid ""
"-- This will print seconds in the thread since the start.\n"
"clock = require('clock')\n"
"print(clock.thread64())"
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:131
msgid ""
"The time that a function takes within a processor. This function uses ``clock."
"proc()``, therefore it calculates elapsed CPU time. Therefore it is not useful "
"for showing actual elapsed time."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:135
#, fuzzy
msgid "function or function reference"
msgstr "Справочник по настройке"

#: ../doc/1.7/reference/reference_lua/clock.rst:136
msgid "whatever values are required by the function."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:138
msgid ""
"**table**. first element - seconds of CPU time, second element - whatever the "
"function returns."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:143
msgid ""
"-- Benchmark a function which sleeps 10 seconds.\n"
"-- NB: bench() will not calculate sleep time.\n"
"-- So the returned value will be {a number less than 10, 88}.\n"
"clock = require('clock')\n"
"fiber = require('fiber')\n"
"function f(param)\n"
"  fiber.sleep(param)\n"
"  return 88\n"
"end\n"
"clock.bench(f, 10)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:39
msgid "Module `console`"
msgstr "Модуль `console`"

#: ../doc/1.7/reference/reference_lua/console.rst:41
msgid ""
"The console module allows one Tarantool instance to access another Tarantool "
"instance, and allows one Tarantool instance to start listening on an :ref:`admin "
"port <admin-security>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:51
msgid ""
"Connect to the instance at :ref:`URI <index-uri>`, change the prompt from "
"'``tarantool>``' to ':samp:`{uri}>`', and act henceforth as a client until the "
"user ends the session or types ``control-D``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:55
msgid ""
"The console.connect function allows one Tarantool instance, in interactive mode, "
"to access another Tarantool instance. Subsequent requests will appear to be "
"handled locally, but in reality the requests are being sent to the remote "
"instance and the local instance is acting as a client. Once connection is "
"successful, the prompt will change and subsequent requests are sent to, and "
"executed on, the remote instance. Results are displayed on the local instance. "
"To return to local mode, enter ``control-D``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:63
msgid ""
"If the Tarantool instance at :samp:`uri` requires authentication, the connection "
"might look something like: ``console.connect('admin:secretpassword@distanthost."
"com:3301')``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:67
msgid ""
"There are no restrictions on the types of requests that can be entered, except "
"those which are due to privilege restrictions -- by default the login to the "
"remote instance is done with user name = 'guest'. The remote instance could "
"allow for this by granting at least one privilege: ``box.schema.user."
"grant('guest','execute','universe')``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:73
msgid "the URI of the remote instance"
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:76
msgid ""
"Possible errors: the connection will fail if the target Tarantool instance was "
"not initiated with ``box.cfg{listen=...}``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:81
msgid ""
"tarantool> console = require('console')\n"
"---\n"
"...\n"
"tarantool> console.connect('198.18.44.44:3301')\n"
"---\n"
"...\n"
"198.18.44.44:3301> -- prompt is telling us that instance is remote"
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:95
msgid ""
"Listen on :ref:`URI <index-uri>`. The primary way of listening for incoming "
"requests is via the connection-information string, or URI, specified in ``box."
"cfg{listen=...}``. The alternative way of listening is via the URI specified in "
"``console.listen(...)``. This alternative way is called \"administrative\" or "
"simply :ref:`\"admin port\" <admin-security>`. The listening is usually over a "
"local host with a Unix domain socket."
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:102
msgid "the URI of the local instance"
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:104
msgid ""
"The \"admin\" address is the URI to listen on. It has no default value, so it "
"must be specified if connections will occur via an admin port. The parameter is "
"expressed with URI = Universal Resource Identifier format, for example \"/tmpdir/"
"unix_domain_socket.sock\", or a numeric TCP port. Connections are often made "
"with telnet. A typical port value is 3313."
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:112
msgid ""
"tarantool> console = require('console')\n"
"---\n"
"...\n"
"tarantool> console.listen('unix/:/tmp/X.sock')\n"
"... main/103/console/unix/:/tmp/X I> started\n"
"---\n"
"- fd: 6\n"
"  name:\n"
"    host: unix/\n"
"    family: AF_UNIX\n"
"    type: SOCK_STREAM\n"
"    protocol: 0\n"
"    port: /tmp/X.sock\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:133
msgid "Start the console on the current interactive terminal."
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:137
msgid ""
"A special use of ``console.start()`` is with :ref:`initialization files <index-"
"init_label>`. Normally, if one starts the Tarantool instance with :samp:"
"`tarantool {initialization file}` there is no console. This can be remedied by "
"adding these lines at the end of the initialization file:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:142
msgid ""
"local console = require('console')\n"
"console.start()"
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:151
msgid ""
"Set the auto-completion flag. If auto-completion is `true`, and the user is "
"using Tarantool as a client or the user is using Tarantool via ``console."
"connect()``, then hitting the TAB key may cause tarantool to complete a word "
"automatically. The default auto-completion value is `true`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:160
msgid "Set a custom end-of-request marker for Tarantool console."
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:162
msgid ""
"The default end-of-request marker is a newline (line feed). Custom markers are "
"not necessary because Tarantool can tell when a multi-line request has not ended "
"(for example, if it sees that a function declaration does not have an end "
"keyword). Nonetheless for special needs, or for entering multi-line requests in "
"older Tarantool versions, you can change the end-of-request marker. As a result, "
"newline alone is not treated as end of request."
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:170
msgid "To go back to normal mode, say: ``console.delimiter('')<marker>``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:172
msgid "a custom end-of-request marker for Tarantool console"
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:176
#, fuzzy
msgid ""
"console = require('console'); console.delimiter('!')\n"
"function f ()\n"
"    statement_1 = 'a'\n"
"    statement_2 = 'b'\n"
"end!\n"
"console.delimiter('')!"
msgstr ""
"console = require('console'); console.delimiter('!')\n"
"function f ()\n"
"  statement_1 = 'a'\n"
"  statement_2 = 'b'\n"
"end!\n"
"console.delimiter('')!"

#: ../doc/1.7/reference/reference_lua/crypto.rst:39
msgid "Module `crypto`"
msgstr "Модуль `crypto`"

#: ../doc/1.7/reference/reference_lua/crypto.rst:43
msgid ""
"\"Crypto\" is short for \"Cryptography\", which generally refers to the "
"production of a digest value from a function (usually a `Cryptographic hash "
"function`_), applied against a string. Tarantool's crypto module supports ten "
"types of cryptographic hash functions (AES_, DES_, DSS_, MD4_, MD5_, MDC2_, "
"RIPEMD_, SHA-0_, SHA-1_, SHA-2_). Some of the crypto functionality is also "
"present in the :ref:`digest` module. The functions in crypto are:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:55
msgid ""
"Pass or return a cipher derived from the string, key, and (optionally, "
"sometimes) initialization vector. The four choices of algorithms:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:58
msgid "aes128 - aes-128 (with 192-bit binary strings using AES)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:59
msgid "aes192 - aes-192 (with 192-bit binary strings using AES)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:60
msgid "aes256 - aes-256 (with 256-bit binary strings using AES)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:61
msgid ""
"des    - des (with 56-bit binary strings using DES, though DES is not "
"recommended)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:64
msgid "Four choices of block cipher modes are also available:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:66
msgid "cbc - Cipher Block Chaining"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:67
msgid "cfb - Cipher Feedback"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:68
msgid "ecb - Electronic Codebook"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:69
msgid "ofb - Output Feedback"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:71
msgid "For more information on, read article about `Encryption Modes`_"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:75
msgid ""
"crypto.cipher.aes192.cbc.encrypt('string', 'key', 'initialization')\n"
"crypto.cipher.aes256.ecb.decrypt('string', 'key', 'initialization')"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:86
msgid ""
"Pass or return a digest derived from the string. The twelve choices of "
"algorithms:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:89
msgid "dss - dss (using DSS)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:90
msgid "dss1 - dss (using DSS-1)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:91
msgid "md4 - md4 (with 128-bit binary strings using MD4)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:92
msgid "md5 - md5 (with 128-bit binary strings using MD5)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:93
msgid "mdc2 - mdc2 (using MDC2)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:94
msgid "ripemd160 -"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:95
msgid "sha - sha (with 160-bit binary strings using SHA-0)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:96
msgid "sha1 - sha-1 (with 160-bit binary strings using SHA-1)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:97
msgid "sha224 - sha-224 (with 224-bit binary strings using SHA-2)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:98
msgid "sha256 - sha-256 (with 256-bit binary strings using SHA-2)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:99
msgid "sha384 - sha-384 (with 384-bit binary strings using SHA-2)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:100
msgid "sha512 - sha-512(with 512-bit binary strings using SHA-2)."
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:104
msgid ""
"crypto.digest.md4('string')\n"
"crypto.digest.sha512('string')"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:111
msgid "Incremental methods in the crypto module"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:113
msgid ""
"Suppose that a digest is done for a string 'A', then a new part 'B' is appended "
"to the string, then a new digest is required. The new digest could be recomputed "
"for the whole string 'AB', but it is faster to take what was computed before for "
"'A' and apply changes based on the new part 'B'. This is called multi-step or "
"\"incremental\" digesting, which Tarantool supports for all crypto functions.."
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:119
msgid ""
"crypto = require('crypto')\n"
"\n"
"-- print aes-192 digest of 'AB', with one step, then incrementally\n"
"print(crypto.cipher.aes192.cbc.encrypt('AB', 'key'))\n"
"c = crypto.cipher.aes192.cbc.encrypt.new()\n"
"c:init()\n"
"c:update('A', 'key')\n"
"c:update('B', 'key')\n"
"print(c:result())\n"
"c:free()\n"
"\n"
"-- print sha-256 digest of 'AB', with one step, then incrementally\n"
"print(crypto.digest.sha256('AB'))\n"
"c = crypto.digest.sha256.new()\n"
"c:init()\n"
"c:update('A')\n"
"c:update('B')\n"
"print(c:result())\n"
"c:free()"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:143
msgid "Getting the same results from digest and crypto modules"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:145
msgid ""
"The following functions are equivalent. For example, the ``digest`` function and "
"the ``crypto`` function will both produce the same result."
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:148
msgid ""
"crypto.cipher.aes256.cbc.encrypt('string', 'key') == digest.aes256cbc."
"encrypt('string', 'key')\n"
"crypto.digest.md4('string') == digest.md4('string')\n"
"crypto.digest.md5('string') == digest.md5('string')\n"
"crypto.digest.sha('string') == digest.sha('string')\n"
"crypto.digest.sha1('string') == digest.sha1('string')\n"
"crypto.digest.sha224('string') == digest.sha224('string')\n"
"crypto.digest.sha256('string') == digest.sha256('string')\n"
"crypto.digest.sha384('string') == digest.sha384('string')\n"
"crypto.digest.sha512('string') == digest.sha512('string')"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:37
msgid "Module `csv`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:41
msgid ""
"The csv module handles records formatted according to Comma-Separated-Values "
"(CSV) rules."
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:44
msgid "The default formatting rules are:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:46
msgid ""
"Lua `escape sequences`_ such as \\\\n or \\\\10 are legal within strings but not "
"within files,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:48
msgid "Commas designate end-of-field,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:49
msgid "Line feeds, or line feeds plus carriage returns, designate end-of-record,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:50
msgid "Leading or trailing spaces are ignored,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:51
msgid "Quote marks may enclose fields or parts of fields,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:52
msgid ""
"When enclosed by quote marks, commas and line feeds and spaces are treated as "
"ordinary characters, and a pair of quote marks \"\" is treated as a single quote "
"mark."
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:58
msgid "The possible options which can be passed to csv functions are:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:60
msgid ""
":samp:`delimiter = {string}` (default: comma) -- single-byte character to "
"designate end-of-field"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:62
msgid ""
":samp:`quote_char = {string}` (default: quote mark) -- single-byte character to "
"designate encloser of string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:64
msgid ""
":samp:`chunk_size = {number}` (default: 4096) -- number of characters to read at "
"once (usually for file-IO efficiency)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:66
msgid ""
":samp:`skip_head_lines = {number}` (default: 0) -- number of lines to skip at "
"the start (usually for a header)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:73
msgid ""
"Get CSV-formatted input from ``readable`` and return a table as output. Usually "
"``readable`` is either a string or a file opened for reading. Usually :samp:"
"`{options}` is not specified."
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:77
msgid ""
"a string, or any object which has a read() method, formatted according to the "
"CSV rules"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:79
#: ../doc/1.7/reference/reference_lua/csv.rst:205
msgid "see :ref:`above <csv-options>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:80
msgid "loaded_value"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:85
msgid ""
"Readable string has 3 fields, field#2 has comma and space so use quote marks:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:88
msgid ""
"tarantool> csv = require('csv')\n"
"---\n"
"...\n"
"tarantool> csv.load('a,\"b,c \",d')\n"
"---\n"
"- - - a\n"
"    - 'b,c '\n"
"    - d\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:100
msgid ""
"Readable string contains 2-byte character = Cyrillic Letter Palochka: (This "
"displays a palochka if and only if character set = UTF-8.)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:103
msgid ""
"tarantool> csv.load('a\\\\211\\\\128b')\n"
"---\n"
"- - - a\\211\\128b\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:110
msgid "Semicolon instead of comma for the delimiter:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:112
msgid ""
"tarantool> csv.load('a,b;c,d', {delimiter = ';'})\n"
"---\n"
"- - - a,b\n"
"    - c,d\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:120
msgid ""
"Readable file :file:`./file.csv` contains two CSV records. Explanation of "
"``fio`` is in section :ref:`fio <fio-section>`. Source CSV file and example "
"respectively:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:124
msgid ""
"tarantool> -- input in file.csv is:\n"
"tarantool> -- a,\"b,c \",d\n"
"tarantool> -- a\\\\211\\\\128b\n"
"tarantool> fio = require('fio')\n"
"---\n"
"...\n"
"tarantool> f = fio.open('./file.csv', {'O_RDONLY'})\n"
"---\n"
"...\n"
"tarantool> csv.load(f, {chunk_size = 4096})\n"
"---\n"
"- - - a\n"
"    - 'b,c '\n"
"    - d\n"
"  - - a\\\\211\\\\128b\n"
"...\n"
"tarantool> f:close()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:151
msgid ""
"Get table input from ``csv-table`` and return a CSV-formatted string as output. "
"Or, get table input from ``csv-table`` and put the output in ``writable``. "
"Usually :samp:`{options}` is not specified. Usually ``writable``, if specified, "
"is a file opened for writing. :ref:`csv.dump() <csv-dump>` is the reverse of :"
"ref:`csv.load() <csv-load>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:157
#: ../doc/1.7/reference/reference_lua/csv.rst:203
msgid "a table which can be formatted according to the CSV rules."
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:159
msgid "optional. see :ref:`above <csv-options>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:160
msgid "any object which has a ``write()`` method"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:162
msgid "dumped_value"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:163
msgid "string, which is written to ``writable`` if specified"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:167
msgid "CSV-table has 3 fields, field#2 has \",\" so result has quote marks"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:169
msgid ""
"tarantool> csv = require('csv')\n"
"---\n"
"...\n"
"tarantool> csv.dump({'a','b,c ','d'})\n"
"---\n"
"- 'a,\"b,c \",d\n"
"\n"
"'\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:181
msgid "Round Trip: from string to table and back to string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:183
msgid ""
"tarantool> csv_table = csv.load('a,b,c')\n"
"---\n"
"...\n"
"tarantool> csv.dump(csv_table)\n"
"---\n"
"- 'a,b,c\n"
"\n"
"'\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:199
msgid ""
"Form a Lua iterator function for going through CSV records one field at a time. "
"Use of an iterator is strongly recommended if the amount of data is large (ten "
"or more megabytes)."
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:207
msgid "Lua iterator function"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:208
msgid "iterator function"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:212
msgid ""
":ref:`csv.iterate() <csv-iterate>` is the low level of :ref:`csv.load() <csv-"
"load>` and :ref:`csv.dump() <csv-dump>`. To illustrate that, here is a function "
"which is the same as the :ref:`csv.load() <csv-load>` function, as seen in `the "
"Tarantool source code`_."
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:217
msgid ""
"tarantool> load = function(readable, opts)\n"
"         >   opts = opts or {}\n"
"         >   local result = {}\n"
"         >   for i, tup in csv.iterate(readable, opts) do\n"
"         >     result[i] = tup\n"
"         >   end\n"
"         >   return result\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> load('a,b,c')\n"
"---\n"
"- - - a\n"
"    - b\n"
"    - c\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:39
msgid "Debug facilities"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:41
msgid ""
"Tarantool users can benefit from built-in debug facilities that are part of:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:43
msgid ""
"Lua (`debug <https://www.lua.org/manual/5.1/manual.html#5.9>`_ library, see "
"details below) and"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:45
msgid "LuaJit (`debug.* <http://luajit.org/extensions.html>`_ functions)."
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:49
msgid ""
"The ``debug`` library provides an interface for debugging Lua programs. All "
"functions in this library reside in the ``debug`` table. Those functions that "
"operate on a thread have an optional first parameter that specifies the thread "
"to operate on. The default is always the current thread."
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:56
msgid ""
"This library should be used only for debugging and profiling and not as a "
"regular programming tool, as the functions provided here can take too long to "
"run. Besides, several of these functions can compromise otherwise secure code."
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:61
msgid "The functions in ``debug`` are:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:67
msgid ""
"Enters an interactive mode and runs each string that the user types in. The user "
"can, among other things, inspect global and local variables, change their values "
"and evaluate expressions."
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:71
msgid ""
"Enter ``cont`` to exit this function, so that the caller can continue its "
"execution."
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:76
msgid ""
"Commands for ``debug.debug()`` are not lexically nested within any function and "
"so have no direct access to local variables."
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:83
msgid "object to get the environment of"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:86
msgid "the environment of the ``object``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:92
msgid "the current hook settings of the ``thread`` as three values:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:94
msgid "the current hook function"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:95
msgid "the current hook mask"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:96
msgid "the current hook count as set by the ``debug.sethook()`` function"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:102
msgid "function to get information on"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:104
msgid "what information on the ``function`` to return"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:106
msgid "a table with information about the ``function``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:108
msgid ""
"You can pass in a ``function`` directly, or you can give a number that specifies "
"a function running at level ``function`` of the call stack of the given "
"``thread``: level 0 is the current function (``getinfo()`` itself), level 1 is "
"the function that called ``getinfo()``, and so on. If ``function`` is a number "
"larger than the number of active functions, ``getinfo()`` returns ``nil``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:115
msgid ""
"The default for ``what`` is to get all information available, except the table "
"of valid lines. If present, the option ``f`` adds a field named ``func`` with "
"the function itself. If present, the option ``L`` adds a field named "
"``activelines`` with the table of valid lines."
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:124
#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:201
msgid "level of the stack"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:125
#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:202
msgid "index of the local variable"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:127
msgid ""
"the name and the value of the local variable with the index ``local`` of the "
"function at level ``level`` of the stack or ``nil`` if there is no local "
"variable with the given index; raises an error if ``level`` is out of range"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:134
#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:212
msgid "You can call ``debug.getinfo()`` to check whether the level is valid."
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:140
msgid "object to get the metatable of"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:143
msgid "a metatable of the ``object`` or ``nil`` if it does not have a metatable"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:150
msgid "the registry table"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:156
msgid "function to get the upvalue of"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:157
#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:232
msgid "index of the function upvalue"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:159
msgid ""
"the name and the value of the upvalue with the index ``up`` of the function "
"``func`` or ``nil`` if there is no upvalue with the given index"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:167
msgid "Sets the environment of the ``object`` to the ``table``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:169
msgid "object to change the environment of"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:171
msgid "table to set the object environment to"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:173
msgid "the ``object``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:179
msgid ""
"Sets the given function as a hook.  When called without arguments, turns the "
"hook off."
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:182
msgid "function to set as a hook"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:183
msgid ""
"describes when the ``hook`` will be called; may have the following values:  * "
"``c`` - the ``hook`` is called every time Lua calls a function * ``r`` - the "
"``hook`` is called every time Lua returns from a function * ``l`` - the ``hook`` "
"is called every time Lua enters a new line of code"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:183
msgid "describes when the ``hook`` will be called; may have the following values:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:186
msgid "``c`` - the ``hook`` is called every time Lua calls a function"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:187
msgid "``r`` - the ``hook`` is called every time Lua returns from a function"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:188
msgid "``l`` - the ``hook`` is called every time Lua enters a new line of code"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:190
msgid ""
"describes when the ``hook`` will be called; when different from zero, the "
"``hook`` is called after every ``count`` instructions."
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:198
msgid ""
"Assigns the value ``value`` to the local variable with the index ``local`` of "
"the function at level ``level`` of the stack."
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:203
msgid "value to assign to the local variable"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:206
msgid ""
"the name of the local variable or ``nil`` if there is no local variable with the "
"given index; raises an error if ``level`` is out of range"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:218
msgid "Sets the metatable of the ``object`` to the ``table``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:220
msgid "object to change the metatable of"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:222
msgid "table to set the object metatable to"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:228
msgid ""
"Assigns the value ``value`` to the upvalue with the index ``up`` of the function "
"``func``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:231
msgid "function to set the upvalue of"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:233
msgid "value to assign to the function upvalue"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:236
msgid ""
"the name of the upvalue or ``nil`` if there is no upvalue with the given index"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:243
msgid "an optional message prepended to the traceback"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:244
msgid "specifies at which level to start the traceback (default is 1)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:247
msgid "a string with a traceback of the call stack"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:39
msgid "Module `digest`"
msgstr "Модуль `digest`"

#: ../doc/1.7/reference/reference_lua/digest.rst:43
msgid ""
"A \"digest\" is a value which is returned by a function (usually a "
"`Cryptographic hash function`_), applied against a string. Tarantool's digest "
"module supports several types of cryptographic hash functions (AES_, MD4_, MD5_, "
"SHA-0_, SHA-1_, SHA-2_) as well as a checksum function (CRC32_), two functions "
"for base64_, and two non-cryptographic hash functions (guava_, murmur_). Some of "
"the digest functionality is also present in the :ref:`crypto <crypto>` module."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:51
msgid "The functions in digest are:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:56
msgid "Returns 256-bit binary string = digest made with AES."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:60
msgid "Returns 128-bit binary string = digest made with MD4."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:64
msgid "Returns 32-byte string = hexadecimal of a digest calculated with md4."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:68
msgid "Returns 128-bit binary string = digest made with MD5."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:72
msgid "Returns 32-byte string = hexadecimal of a digest calculated with md5."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:76
msgid ""
"Returns 160-bit binary string = digest made with SHA-0.|br| Not recommended."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:81
msgid "Returns 40-byte string = hexadecimal of a digest calculated with sha."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:85
msgid "Returns 160-bit binary string = digest made with SHA-1."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:89
msgid "Returns 40-byte string = hexadecimal of a digest calculated with sha1."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:93
msgid "Returns 224-bit binary string = digest made with SHA-2."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:97
msgid "Returns 56-byte string = hexadecimal of a digest calculated with sha224."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:101
msgid "Returns 256-bit binary string =  digest made with SHA-2."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:105
msgid "Returns 64-byte string = hexadecimal of a digest calculated with sha256."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:109
msgid "Returns 384-bit binary string =  digest made with SHA-2."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:113
msgid "Returns 96-byte string = hexadecimal of a digest calculated with sha384."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:117
msgid "Returns 512-bit binary tring = digest made with SHA-2."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:121
msgid "Returns 128-byte string = hexadecimal of a digest calculated with sha512."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:125
msgid "Returns base64 encoding from a regular string."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:129
msgid "Returns a regular string from a base64 encoding."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:133
msgid "Returns array of random bytes with length = integer."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:137
msgid "Returns 32-bit checksum made with CRC32."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:139
msgid ""
"The crc32 and crc32_update functions use the `CRC-32C (Castagnoli)`_ polynomial "
"value: ``0x1EDC6F41`` / ``4812730177``. If it is necessary to be compatible with "
"other checksum functions in other programming languages, ensure that the other "
"functions use the same polynomial value."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:144
msgid "For example, in Python, install the ``crcmod`` package and say:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:151
msgid "In Perl, install the ``Digest::CRC`` module and run the following code:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:153
msgid ""
"use Digest::CRC;\n"
"$d = Digest::CRC->new(width => 32, poly => 0x1EDC6F41, init => 0xFFFFFFFF, refin "
"=> 1, refout => 1);\n"
"$d->add('string');\n"
"print $d->digest;"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:160
msgid "(the expected output is 3304160206)."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:166
msgid ""
"Initiates incremental crc32. See :ref:`incremental methods <digest-"
"incremental_digests>` notes."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:173
msgid "Returns a number made with consistent hash."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:175
msgid ""
"The guava function uses the `Consistent Hashing`_ algorithm of the Google guava "
"library. The first parameter should be a hash code; the second parameter should "
"be the number of buckets; the returned value will be an integer between 0 and "
"the number of buckets. For example,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:180
msgid ""
"tarantool> digest.guava(10863919174838991, 11)\n"
"---\n"
"- 8\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:190
msgid "Returns 32-bit binary string = digest made with MurmurHash."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:195
msgid ""
"Initiates incremental MurmurHash. See :ref:`incremental methods <digest-"
"incremental_digests>` notes."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:202
msgid "Incremental methods in the digest module"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:204
msgid ""
"Suppose that a digest is done for a string 'A', then a new part 'B' is appended "
"to the string, then a new digest is required. The new digest could be recomputed "
"for the whole string 'AB', but it is faster to take what was computed before for "
"'A' and apply changes based on the new part 'B'. This is called multi-step or "
"\"incremental\" digesting, which Tarantool supports with crc32 and with murmur..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:210
msgid ""
"digest = require('digest')\n"
"\n"
"-- print crc32 of 'AB', with one step, then incrementally\n"
"print(digest.crc32('AB'))\n"
"c = digest.crc32.new()\n"
"c:update('A')\n"
"c:update('B')\n"
"print(c:result())\n"
"\n"
"-- print murmur hash of 'AB', with one step, then incrementally\n"
"print(digest.murmur('AB'))\n"
"m = digest.murmur.new()\n"
"m:update('A')\n"
"m:update('B')\n"
"print(m:result())"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:232
msgid ""
"In the following example, the user creates two functions, ``password_insert()`` "
"which inserts a SHA-1_ digest of the word \"**^S^e^c^ret Wordpass**\" into a "
"tuple set, and ``password_check()`` which requires input of a password."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:236
msgid ""
"tarantool> digest = require('digest')\n"
"---\n"
"...\n"
"tarantool> function password_insert()\n"
"         >   box.space.tester:insert{1234, digest.sha1('^S^e^c^ret Wordpass')}\n"
"         >   return 'OK'\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> function password_check(password)\n"
"         >   local t = box.space.tester:select{12345}\n"
"         >   if digest.sha1(password) == t[2] then\n"
"         >     return 'Password is valid'\n"
"         >   else\n"
"         >     return 'Password is not valid'\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> password_insert()\n"
"---\n"
"- 'OK'\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:262
msgid ""
"If a later user calls the ``password_check()`` function and enters the wrong "
"password, the result is an error."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:265
msgid ""
"tarantool> password_check('Secret Password')\n"
"---\n"
"- 'Password is not valid'\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:39
msgid "Database error codes"
msgstr "Коды ошибок от базы данных"

#: ../doc/1.7/reference/reference_lua/errcodes.rst:41
msgid ""
"In the current version of the binary protocol, error messages, which are "
"normally more descriptive than error codes, are not present in server responses. "
"The actual message may contain a file name, a detailed reason or operating "
"system error code. All such messages, however, are logged in the error log. "
"Below are general descriptions of some popular codes. A complete list of errors "
"can be found in file `errcode.h`_ in the source tree."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:52
msgid "**List of error codes**"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:58
msgid "ER_NONMASTER"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:58
msgid ""
"(In replication) A server instance cannot modify data unless it is a master."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:61
msgid "ER_ILLEGAL_PARAMS"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:61
msgid "Illegal parameters. Malformed protocol message."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:64
msgid "ER_MEMORY_ISSUE"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:64
msgid ""
"Out of memory: :ref:`memtx_memory <cfg_storage-memtx_memory>` limit has been "
"reached."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:68
msgid "ER_WAL_IO"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:68
msgid ""
"Failed to write to disk. May mean: failed to record a change in the write-ahead "
"log. Some sort of disk error."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:72
msgid "ER_KEY_PART_COUNT"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:72
msgid "Key part count is not the same as index part count"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:75
msgid "ER_NO_SUCH_SPACE"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:75
msgid "The specified space does not exist."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:78
msgid "ER_NO_SUCH_INDEX"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:78
msgid "The specified index in the specified space does not exist."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:81
msgid "ER_PROC_LUA"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:81
msgid "An error occurred inside a Lua procedure."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:84
msgid "ER_FIBER_STACK"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:84
msgid ""
"The recursion limit was reached when creating a new fiber. This usually "
"indicates that a stored procedure is recursively invoking itself too often."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:89
msgid "ER_UPDATE_FIELD"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:89
msgid "An error occurred during update of a field."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:92
msgid "ER_TUPLE_FOUND"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:92
msgid "A duplicate key exists in a unique index."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:98
msgid "Handling errors"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:100
msgid ""
"Here are some procedures that can make Lua functions more robust when there are "
"errors, particularly database errors."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:103
msgid "Invoke with pcall."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst
msgid ""
"Take advantage of Lua's mechanisms for `\"Error handling and exceptions\" "
"<http://www.lua.org/pil/8.4.html>`_, particularly ``pcall``. That is, instead of "
"simply invoking with"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst
#, fuzzy
msgid ":samp:`box.space.{space-name}:{function-name}()`"
msgstr ":samp:`box.space.{имя-пространства}:create_index('{имя-индекса}')`"

#: ../doc/1.7/reference/reference_lua/errcodes.rst
msgid "say"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst
msgid ""
":samp:`if pcall(box.space.{space-name}.{function-name}, box.space.{space-"
"name}) ...`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst
msgid ""
"For some Tarantool box functions, pcall also returns error details including a "
"file-name and line-number within Tarantool's source code. This can be seen by "
"unpacking. For example:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst
#, fuzzy
msgid "``x, y = pcall(function() box.schema.space.create('') end)``"
msgstr ""
"function f()\n"
"  box.schema.space.create('X')\n"
"end\n"
"box.once('space_creator', f)"

#: ../doc/1.7/reference/reference_lua/errcodes.rst
msgid "``y:unpack()``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:118
msgid ""
"See the tutorial :ref:`Sum a JSON field for all tuples <c_lua_tutorial-"
"sum_a_json_field>` to see how pcall can fit in an application."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:121
msgid "Examine and raise with box.error."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:123
msgid ""
"To make a new error and pass it on, the box.error module provides :ref:`box."
"error(code, errtext [, errtext ...]) <box_error-error>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:126
msgid ""
"To find the last error, the box.error module provides :ref:`box.error.last() "
"<box_error-last>`. (There is also a way to find the text of the last operating-"
"system error for certain functions -- :ref:`errno.strerror([code]) <errno-"
"strerror>`.)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:131
msgid "Log."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:133
msgid "Put messages in a log using the :ref:`log module <log-module>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:135
msgid ""
"And filter messages that are automatically generated, with the :ref:`log "
"<cfg_logging-log>` configuration parameter."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:139
msgid ""
"Generally, for Tarantool built-in functions which are designed to return "
"objects: the result will be an object, or nil, or `a Lua error <https://www.lua."
"org/pil/8.3.html>`_. For example consider the :ref:`fio_read.lua <cookbook-"
"fio_read>` program in our cookbook:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:157
msgid ""
"After a function call that might fail, like fio.open() above, it is common to "
"see syntax like ``if not f then ...`` or ``if f == nil then ...``, which check "
"for common failures. But if there had been a syntax error, for example fio.opex "
"instead of fio.open, then there would have been a Lua error and f would not have "
"been changed. If checking for such an obvious error had been a concern, the "
"programmer would probably have used pcall()."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:167
msgid ""
"All functions in Tarantool modules should work this way, unless the manual "
"explicitly says otherwise."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:39
msgid "Module `errno`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:43
msgid "The ``errno`` module provides:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:45
msgid "a function :ref:`strerror() <errno-strerror>`,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:46
msgid "an operator :ref:`errno() <errno-errno>`, and"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:47
msgid "a `metatable <https://www.lua.org/pil/13.html>`_ with constant error names."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:49
msgid ""
"The ``errno`` module is typically used within a function or within a Lua "
"program, in association with a module whose functions can return operating-"
"system errors, such as :ref:`fio <fio-module>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:57
msgid ""
"Return an error number for the last operating-system-related function, or 0. To "
"invoke it, simply say ``errno()``, without the module name."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:66
msgid ""
"Return a string, given an error number. The string will contain the text of the "
"conventional error message for the current operating system. If ``code`` is not "
"supplied, the error message will be for the last operating-system-related "
"function, or 0."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:71
msgid "number of an operating-system error"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:77
msgid ""
"This function displays the result of a call to :ref:`fio.open() <fio-open>` "
"which causes error 2 (``errno.ENOENT``). The display includes the error number, "
"the associated error string, and the error name."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:81
msgid ""
"tarantool> function f()\n"
"         >   local fio = require('fio')\n"
"         >   local errno = require('errno')\n"
"         >   fio.open('no_such_file')\n"
"         >   print('errno() = ' .. errno())\n"
"         >   print('errno.strerror() = ' .. errno.strerror())\n"
"         >   local t = getmetatable(errno).__index\n"
"         >   for k, v in pairs(t) do\n"
"         >     if v == errno() then\n"
"         >       print('errno() constant = ' .. k)\n"
"         >     end\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"\n"
"tarantool> f()\n"
"errno() = 2\n"
"errno.strerror() = No such file or directory\n"
"errno() constant = ENOENT\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:106
msgid ""
"To see all possible error names stored in the ``errno`` metatable, say "
"``getmetatable(errno)`` (output abridged):"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:109
msgid ""
"tarantool> getmetatable(errno)\n"
"---\n"
"- __newindex: 'function: 0x41666a38'\n"
"  __call: 'function: 0x41666890'\n"
"  __index:\n"
"  ENOLINK: 67\n"
"  EMSGSIZE: 90\n"
"  EOVERFLOW: 75\n"
"  ENOTCONN: 107\n"
"  EFAULT: 14\n"
"  EOPNOTSUPP: 95\n"
"  EEXIST: 17\n"
"  ENOSR: 63\n"
"  ENOTSOCK: 88\n"
"  EDESTADDRREQ: 89\n"
"  ...\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:41
msgid "With the ``fiber`` module, you can:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:43
msgid "create, run and manage :ref:`fibers <fiber-fibers>`,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:44
msgid ""
"send and receive messages between different processes (i.e. different "
"connections, sessions, or fibers) via :ref:`channels <fiber_ipc-channel>`, and"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:46
msgid ""
"use a :ref:`synchronization mechanism <fiber_ipc-cond_var>` for fibers, similar "
"to \"condition variables\" and similar to operating-system functions such as "
"``pthread_cond_wait()`` plus ``pthread_cond_signal()``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:56
msgid ""
"A **fiber** is a set of instructions which are executed with cooperative "
"multitasking. Fibers managed by the fiber module are associated with a user-"
"supplied function called the *fiber function*."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:60
msgid ""
"A fiber has three possible states: **running**, **suspended** or **dead**. When "
"a fiber is created with :ref:`fiber.create() <fiber-create>`, it is running. "
"When a fiber yields control with :ref:`fiber.sleep() <fiber-sleep>`, it is "
"suspended. When a fiber ends (because the fiber function ends), it is dead."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:65
msgid ""
"All fibers are part of the fiber registry. This registry can be searched with :"
"ref:`fiber.find() <fiber-find>` - via fiber id (fid), which is a numeric "
"identifier."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:69
msgid ""
"A runaway fiber can be stopped with :ref:`fiber_object.cancel <fiber_object-"
"cancel>`. However, :ref:`fiber_object.cancel <fiber_object-cancel>` is advisory "
"— it works only if the runaway fiber calls :ref:`fiber.testcancel() <fiber-"
"testcancel>` occasionally. Most ``box.*`` functions, such as :ref:`box.space..."
"delete() <box_space-delete>` or :ref:`box.space...update() <box_space-update>`, "
"do call :ref:`fiber.testcancel() <fiber-testcancel>` but :ref:`box.space..."
"select{} <box_space-select>` does not. In practice, a runaway fiber can only "
"become unresponsive if it does many computations and does not check whether it "
"has been cancelled."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:80
msgid ""
"The other potential problem comes from fibers which never get scheduled, because "
"they are not subscribed to any events, or because no relevant events occur. Such "
"morphing fibers can be killed with :ref:`fiber.kill() <fiber-kill>` at any time, "
"since :ref:`fiber.kill() <fiber-kill>` sends an asynchronous wakeup event to the "
"fiber, and :ref:`fiber.testcancel() <fiber-testcancel>` is checked whenever such "
"a wakeup event occurs."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:87
msgid ""
"Like all Lua objects, dead fibers are garbage collected. The garbage collector "
"frees pool allocator memory owned by the fiber, resets all fiber data, and "
"returns the fiber (now called a fiber carcass) to the fiber pool. The carcass "
"can be reused when another fiber is created."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:92
msgid ""
"A fiber has all the features of a Lua coroutine_ and all the programming "
"concepts that apply for Lua coroutines will apply for fibers as well. However, "
"Tarantool has made some enhancements for fibers and has used fibers internally. "
"So, although use of coroutines is possible and supported, use of fibers is "
"recommended."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:104
msgid ""
"Create and start a fiber. The fiber is created and begins to run immediately."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:106
msgid "the function to be associated with the fiber"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst
#: ../doc/1.7/reference/reference_lua/string.rst
msgid "Return"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:109
msgid "created fiber object"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst
#: ../doc/1.7/reference/reference_lua/string.rst
msgid "Rtype"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:114
msgid ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function function_name()\n"
"         >   fiber.sleep(1000)\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> fiber_object = fiber.create(function_name)\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:133
msgid "fiber object for the currently scheduled fiber."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:138
msgid ""
"tarantool> fiber.self()\n"
"---\n"
"- status: running\n"
"  name: interactive\n"
"  id: 101\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:151
msgid "numeric identifier of the fiber."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:153
msgid "fiber object for the specified fiber."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:158
msgid ""
"tarantool> fiber.find(101)\n"
"---\n"
"- status: running\n"
"  name: interactive\n"
"  id: 101\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:171
msgid ""
"Yield control to the scheduler and sleep for the specified number of seconds. "
"Only the current fiber can be made to sleep."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:174
msgid "number of seconds to sleep."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:178
msgid ""
"tarantool> fiber.sleep(1.5)\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:188
msgid ""
"Yield control to the scheduler. Equivalent to :ref:`fiber.sleep(0) <fiber-"
"sleep>`, except that `fiber.sleep(0)` depends on a timer, `fiber.yield()` does "
"not."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:193
msgid ""
"tarantool> fiber.yield()\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:203
msgid "Return the status of the current fiber."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:205
msgid "the status of ``fiber``. One of: “dead”, “suspended”, or “running”."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:210
msgid ""
"tarantool> fiber.status()\n"
"---\n"
"- running\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:221
msgid "Return information about all fibers."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:223
msgid ""
"number of context switches, backtrace, id, total memory, used memory, name for "
"each fiber."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:229
msgid ""
"tarantool> fiber.info()\n"
"---\n"
"- 101:\n"
"    csw: 7\n"
"    backtrace: []\n"
"    fid: 101\n"
"    memory:\n"
"      total: 65776\n"
"      used: 0\n"
"    name: interactive\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:247
msgid ""
"Locate a fiber by its numeric id and cancel it. In other words, :ref:`fiber."
"kill() <fiber-kill>` combines :ref:`fiber.find() <fiber-find>` and :ref:"
"`fiber_object:cancel() <fiber_object-cancel>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:251
msgid "the id of the fiber to be cancelled."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst
#, fuzzy
msgid "Exception"
msgstr "Репликация"

#: ../doc/1.7/reference/reference_lua/fiber.rst:252
msgid "the specified fiber does not exist or cancel is not permitted."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:256
msgid ""
"tarantool> fiber.kill(fiber.id()) -- kill self, may make program end\n"
"---\n"
"- error: fiber is cancelled\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:268
msgid ""
"Check if the current fiber has been cancelled and throw an exception if this is "
"the case."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:273
msgid ""
"tarantool> fiber.testcancel()\n"
"---\n"
"- error: fiber is cancelled\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:286
#: ../doc/1.7/reference/reference_lua/fiber.rst:307
#: ../doc/1.7/reference/reference_lua/fiber.rst:331
#: ../doc/1.7/reference/reference_lua/fiber.rst:351
#: ../doc/1.7/reference/reference_lua/fiber.rst:375
msgid ""
"fiber object, for example the fiber object returned by :ref:`fiber.create <fiber-"
"create>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:288
msgid "id of the fiber."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:293
msgid ""
"tarantool> fiber_object = fiber.self()\n"
"---\n"
"...\n"
"tarantool> fiber_object:id()\n"
"---\n"
"- 101\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:309
msgid "name of the fiber."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:314
msgid ""
"tarantool> fiber.self():name()\n"
"---\n"
"- interactive\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:325
msgid ""
"Change the fiber name. By default a Tarantool server's interactive-mode fiber is "
"named 'interactive' and new fibers created due to :ref:`fiber.create <fiber-"
"create>` are named 'lua'. Giving fibers distinct names makes it easier to "
"distinguish them when using :ref:`fiber.info <fiber-info>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:333
msgid "the new name of the fiber."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:339
msgid ""
"tarantool> fiber.self():name('non-interactive')\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:349
msgid "Return the status of the specified fiber."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:354
msgid "the status of fiber. One of: “dead”, “suspended”, or “running”."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:359
msgid ""
"tarantool> fiber.self():status()\n"
"---\n"
"- running\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:370
msgid ""
"Cancel a fiber. Running and suspended fibers can be cancelled. After a fiber has "
"been cancelled, attempts to operate on it will cause errors, for example :ref:"
"`fiber_object:id() <fiber_object-id>` will cause ``error: the fiber is dead``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:380
msgid "Possible errors: cancel is not permitted for the specified fiber object."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:384
msgid ""
"tarantool> fiber.self():cancel() -- kill self, may make program send\n"
"---\n"
"- error: fiber is cancelled\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:395
msgid ""
"Local storage within the fiber. The storage can contain any number of named "
"values, subject to memory limitations. Naming may be done with :samp:"
"`{fiber_object}.storage.{name}` or :samp:`{fiber_object}.storage['{name}'].` or "
"with a number :samp:`{fiber_object}.storage[{number}]`. Values may be either "
"numbers or strings. The storage is garbage-collected when :samp:`{fiber_object}:"
"cancel()` happens."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:404
msgid ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function f () fiber.sleep(1000); end\n"
"---\n"
"...\n"
"tarantool> fiber_function = fiber:create(f)\n"
"---\n"
"- error: '[string \"fiber_function = fiber:create(f)\"]:1: fiber."
"create(function, ...):\n"
"    bad arguments'\n"
"...\n"
"tarantool> fiber_function = fiber.create(f)\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage.str1 = 'string'\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage['str1']\n"
"---\n"
"- string\n"
"...\n"
"tarantool> fiber_function:cancel()\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage['str1']\n"
"---\n"
"- error: '[string \"return fiber_function.storage[''str1'']\"]:1: the fiber is "
"dead'\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:435
msgid "See also :ref:`box.session.storage <box_session-storage>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:441
msgid ""
"current system time (in seconds since the epoch) as a Lua number. The time is "
"taken from the event loop clock, which makes this call very cheap, but still "
"useful for constructing artificial tuple keys."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:445
#: ../doc/1.7/reference/reference_lua/fiber.rst:464
msgid "num"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:449
msgid ""
"tarantool> fiber.time(), fiber.time()\n"
"---\n"
"- 1448466279.2415\n"
"- 1448466279.2415\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:461
msgid ""
"current system time (in microseconds since the epoch) as a 64-bit integer. The "
"time is taken from the event loop clock."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:468
msgid ""
"tarantool> fiber.time(), fiber.time64()\n"
"---\n"
"- 1448466351.2708\n"
"- 1448466351270762\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:480
msgid ""
"Make the function which will be associated with the fiber. This function "
"contains an infinite loop (``while 0 == 0`` is always true). Each iteration of "
"the loop adds 1 to a global variable named gvar, then goes to sleep for 2 "
"seconds. The sleep causes an implicit :ref:`fiber.yield() <fiber-yield>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:485
msgid ""
"tarantool> fiber = require('fiber')\n"
"tarantool> function function_x()\n"
"         >   gvar = 0\n"
"         >   while 0 == 0 do\n"
"         >     gvar = gvar + 1\n"
"         >     fiber.sleep(2)\n"
"         >   end\n"
"         > end\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:498
msgid ""
"Make a fiber, associate function_x with the fiber, and start function_x. It will "
"immediately \"detach\" so it will be running independently of the caller."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:501
msgid ""
"tarantool> gvar = 0\n"
"\n"
"tarantool> fiber_of_x = fiber.create(function_x)\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:509
msgid "Get the id of the fiber (fid), to be used in later displays."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:511
msgid ""
"tarantool> fid = fiber_of_x:id()\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:517
msgid ""
"Pause for a while, while the detached function runs. Then ... Display the fiber "
"id, the fiber status, and gvar (gvar will have gone up a bit depending how long "
"the pause lasted). The status is suspended because the fiber spends almost all "
"its time sleeping or yielding."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:522
msgid ""
"tarantool> print('#', fid, '. ', fiber_of_x:status(), '. gvar=', gvar)\n"
"# 102 .  suspended . gvar= 399\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:529
msgid ""
"Pause for a while, while the detached function runs. Then ... Cancel the fiber. "
"Then, once again ... Display the fiber id, the fiber status, and gvar (gvar will "
"have gone up a bit more depending how long the pause lasted). This time the "
"status is dead because the cancel worked."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:534
msgid ""
"tarantool> fiber_of_x:cancel()\n"
"---\n"
"...\n"
"tarantool> print('#', fid, '. ', fiber_of_x:status(), '. gvar=', gvar)\n"
"# 102 .  dead . gvar= 421\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:550
msgid "Channels"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:552
msgid ""
"Call ``fiber.channel()`` to allocate space and get a channel object, which will "
"be called channel for examples in this section."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:555
msgid ""
"Call the other routines, via channel, to send messages, receive messages, or "
"check channel status."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:558
msgid ""
"Message exchange is synchronous. The channel is garbage collected when no one is "
"using it, as with any other Lua object. Use object-oriented syntax, for example "
"``channel:put(message)`` rather than ``fiber.channel.put(message)``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:564
msgid "Create a new communication channel."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:566
msgid ""
"the maximum number of slots (spaces for ``channel:put`` messages) that can be in "
"use at once. The default is 0."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:570
msgid "new channel."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:571
msgid "userdata, possibly including the string \"channel ...\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:577
msgid ""
"Send a message using a channel. If the channel is full, ``channel:put()`` waits "
"until there is a free slot in the channel."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:580
msgid "what will be sent, usually a string or number or table"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:581
msgid "maximum number of seconds to wait for a slot to become free"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:582
msgid ""
"If timeout is specified, and there is no free slot in the channel for the "
"duration of the timeout, then the return value is ``false``. If the channel is "
"closed, then the return value is ``false``. Otherwise, the return value is "
"``true``, indicating success."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:590
msgid ""
"Close the channel. All waiters in the channel will stop waiting. All following "
"``channel:get()`` operations will return ``nil``, and all following ``channel:"
"put()`` operations will return ``false``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:596
msgid ""
"Fetch and remove a message from a channel. If the channel is empty, ``channel:"
"get()`` waits for a message."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:599
msgid "maximum number of seconds to wait for a message"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:600
msgid ""
"If timeout is specified, and there is no message in the channel for the duration "
"of the timeout, then the return value is ``nil``. If the channel is closed, then "
"the return value is ``nil``. Otherwise, the return value is the message placed "
"on the channel by ``channel:put()``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:605
msgid "usually string or number or table, as determined by ``channel:put``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:609
msgid "Check whether the channel is empty (has no messages)."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:611
msgid "``true`` if the channel is empty. Otherwise ``false``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:616
msgid "Find out how many messages are in the channel."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:618
msgid "the number of messages."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:623
msgid "Check whether the channel is full."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:625
msgid ""
"``true`` if the channel is full (the number of messages in the channel equals "
"the number of slots so there is no room for a new message). Otherwise ``false``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:632
msgid ""
"Check whether readers are waiting for a message because they have issued "
"``channel:get()`` and the channel is empty."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:635
msgid "``true`` if readers are waiting. Otherwise ``false``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:640
msgid ""
"Check whether writers are waiting because they have issued ``channel:put()`` and "
"the channel is full."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:643
msgid "``true`` if writers are waiting. Otherwise ``false``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:648
msgid "``true`` if the channel is already closed. Otherwise ``false``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:656
msgid ""
"This example should give a rough idea of what some functions for fibers should "
"look like. It's assumed that the functions would be referenced in :ref:`fiber."
"create() <fiber-create>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:660
msgid ""
"fiber = require('fiber')\n"
"channel = fiber.channel(10)\n"
"function consumer_fiber()\n"
"    while true do\n"
"        local task = channel:get()\n"
"        ...\n"
"    end\n"
"end\n"
"\n"
"function consumer2_fiber()\n"
"    while true do\n"
"        -- 10 seconds\n"
"        local task = channel:get(10)\n"
"        if task ~= nil then\n"
"            ...\n"
"        else\n"
"            -- timeout\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"function producer_fiber()\n"
"    while true do\n"
"        task = box.space...:select{...}\n"
"        ...\n"
"        if channel:is_empty() then\n"
"            -- channel is empty\n"
"        end\n"
"\n"
"        if channel:is_full() then\n"
"            -- channel is full\n"
"        end\n"
"\n"
"        ...\n"
"        if channel:has_readers() then\n"
"            -- there are some fibers\n"
"            -- that are waiting for data\n"
"        end\n"
"        ...\n"
"\n"
"        if channel:has_writers() then\n"
"            -- there are some fibers\n"
"            -- that are waiting for readers\n"
"        end\n"
"        channel:put(task)\n"
"    end\n"
"end\n"
"\n"
"function producer2_fiber()\n"
"    while true do\n"
"        task = box.space...select{...}\n"
"        -- 10 seconds\n"
"        if channel:put(task, 10) then\n"
"            ...\n"
"        else\n"
"            -- timeout\n"
"        end\n"
"    end\n"
"end"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:726
#, fuzzy
msgid "Condition variables"
msgstr "Параметры конфигурации"

#: ../doc/1.7/reference/reference_lua/fiber.rst:728
msgid ""
"Call ``fiber.cond()`` to create a named condition variable, which will be called "
"'cond' for examples in this section."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:731
msgid ""
"Call ``cond:wait()`` to make a fiber wait for a signal via a condition variable."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:733
msgid ""
"Call ``cond:signal()`` to send a signal to wake up a single fiber that has "
"executed ``cond:wait()``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:736
msgid ""
"Call ``cond:broadcast()`` to send a signal to all fibers that have executed "
"``cond:wait()``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:741
msgid "Create a new condition variable."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:743
msgid "new condition variable."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:744
msgid "Lua object"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:750
msgid ""
"Make the current fiber go to sleep, waiting until until another fiber invokes "
"the ``signal()`` or ``broadcast()`` method on the cond object. The sleep causes "
"an implicit :ref:`fiber.yield() <fiber-yield>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:754
msgid "number of seconds to wait, default = forever."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:755
msgid ""
"If timeout is provided, and a signal doesn't happen for the duration of the "
"timeout, ``wait()`` returns false. If a signal or broadcast happens, ``wait()`` "
"returns true."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:762
msgid "Wake up a single fiber that has executed ``wait()`` for the same variable."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:769
msgid "Wake up all fibers that have executed ``wait()`` for the same variable."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:777
msgid ""
"Assume that a tarantool instance is running and listening for connections on "
"localhost port 3301. Assume that guest users have privileges to connect. We will "
"use the tarantoolctl utility to start two clients."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:781
msgid "On terminal #1, say"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:783
msgid ""
"$ tarantoolctl connect '3301'\n"
"tarantool> fiber = require('fiber')\n"
"tarantool> cond = fiber.cond()\n"
"tarantool> cond:wait()"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:790
msgid ""
"The job will hang because ``cond:wait()`` -- without an optional timeout "
"argument -- will go to sleep until the condition variable changes."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:793
msgid "On terminal #2, say"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:795
msgid ""
"$ tarantoolctl connect '3301'\n"
"tarantool> cond:signal()"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:800
msgid ""
"Now look again at terminal #1. It will show that the waiting stopped, and the "
"``cond:wait()`` function returned ``true``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:803
msgid ""
"This example depended on the use of a global conditional variable with the "
"arbitrary name ``cond``. In real life, programmers would make sure to use "
"different conditional variable names for different applications."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:39
msgid "Module `fio`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:43
msgid ""
"Tarantool supports file input/output with an API that is similar to POSIX "
"syscalls. All operations are performed asynchronously. Multiple fibers can "
"access the same file simultaneously."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:47
msgid "The ``fio`` module contains:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:49
msgid "functions for :ref:`common pathname manipulations <fio-pathname>`,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:50
msgid "functions for :ref:`common file manipulations <fio-file>`, and"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:51
msgid ""
":ref:`constants <fio-c>` which are the same as POSIX flag values (for example "
"``fio.c.flag.O_RDONLY`` = POSIX O_RDONLY)."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:60
msgid "Common pathname manipulations"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:64
msgid "Concatenate partial string, separated by '/' to form a path name."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:66
msgid "one or more strings to be concatenated."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:67
#: ../doc/1.7/reference/reference_lua/fio.rst:84
#: ../doc/1.7/reference/reference_lua/fio.rst:103
msgid "path name"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:72
msgid ""
"tarantool> fio.pathjoin('/etc', 'default', 'myfile')\n"
"---\n"
"- /etc/default/myfile\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:81
msgid ""
"Given a full path name, remove all but the final part (the file name). Also "
"remove the suffix, if it is passed."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:85
msgid "suffix"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:87
msgid "file name"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:92
msgid ""
"tarantool> fio.basename('/path/to/my.lua', '.lua')\n"
"---\n"
"- my\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:101
msgid "Given a full path name, remove the final part (the file name)."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:105
msgid "directory name, that is, path name except for file name."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:110
msgid ""
"tarantool> fio.dirname('path/to/my.lua')\n"
"---\n"
"- 'path/to/'\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:121
msgid "Common file manipulations"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:125
msgid ""
"Set the mask bits used when creating files or directories. For a detailed "
"description type \"man 2 umask\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:128
msgid "mask bits."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:129
msgid "previous mask bits."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:134
msgid ""
"tarantool> fio.umask(tonumber('755', 8))\n"
"---\n"
"- 493\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:144
msgid ""
"Returns information about a file object. For details type \"man 2 lstat\" or "
"\"man 2 stat\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:147
msgid "path name of file."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:148
msgid ""
"fields which describe the file's block size, creation time, size, and other "
"attributes."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:152
msgid ""
"Additionally, the result of ``fio.stat('file-name')`` will include methods "
"equivalent to POSIX macros:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:155
msgid "``is_blk()`` = POSIX macro S_ISBLK,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:156
msgid "``is_chr()`` = POSIX macro S_ISCHR,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:157
msgid "``is_dir()`` = POSIX macro S_ISDIR,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:158
msgid "``is_fifo()`` = POSIX macro S_ISFIFO,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:159
msgid "``is_link()`` = POSIX macro S_ISLINK,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:160
msgid "``is_reg()`` = POSIX macro S_ISREG,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:161
msgid "``is_sock()`` = POSIX macro S_ISSOCK."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:163
msgid "For example, ``fio.stat('/'):is_dir()`` will return true."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:167
msgid ""
"tarantool> fio.lstat('/etc')\n"
"---\n"
"- inode: 1048577\n"
"  rdev: 0\n"
"  size: 12288\n"
"  atime: 1421340698\n"
"  mode: 16877\n"
"  mtime: 1424615337\n"
"  nlink: 160\n"
"  uid: 0\n"
"  blksize: 4096\n"
"  gid: 0\n"
"  ctime: 1424615337\n"
"  dev: 2049\n"
"  blocks: 24\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:193
msgid ""
"Create or delete a directory. For details type \"man 2 mkdir\" or \"man 2 rmdir"
"\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:196
msgid "path of directory."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:197
msgid ""
"Mode bits can be passed as a number or as string constants, for example "
"''`S_IWUSR`\". Mode bits can be combined by enclosing them in braces."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:200
#: ../doc/1.7/reference/reference_lua/fio.rst:296
#: ../doc/1.7/reference/reference_lua/fio.rst:338
#: ../doc/1.7/reference/reference_lua/fio.rst:354
#: ../doc/1.7/reference/reference_lua/fio.rst:482
#: ../doc/1.7/reference/reference_lua/fio.rst:556
msgid "true if success, false if failure."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:205
msgid ""
"tarantool> fio.mkdir('/etc')\n"
"---\n"
"- false\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:214
msgid ""
"Return a list of files that match an input string. The list is constructed with "
"a single flag that controls the behavior of the function: GLOB_NOESCAPE. For "
"details type \"man 3 glob\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:218
msgid "path-name, which may contain wildcard characters."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:219
msgid "list of files whose names match the input string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:222
#: ../doc/1.7/reference/reference_lua/fio.rst:390
#: ../doc/1.7/reference/reference_lua/fio.rst:506
#: ../doc/1.7/reference/reference_lua/socket.rst:383
msgid "Possible errors: nil."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:226
msgid ""
"tarantool> fio.glob('/etc/x*')\n"
"---\n"
"- - /etc/xdg\n"
"  - /etc/xml\n"
"  - /etc/xul-ext\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:237
msgid "Return the name of a directory that can be used to store temporary files."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:241
msgid ""
"tarantool> fio.tempdir()\n"
"---\n"
"- /tmp/lG31e7\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:250
msgid "Return the name of the current working directory."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:254
msgid ""
"tarantool> fio.cwd()\n"
"---\n"
"- /home/username/tarantool_sandbox\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:266
msgid ""
"Functions to create and delete links. For details type \"man readlink\", \"man 2 "
"link\", \"man 2 symlink\", \"man 2 unlink\".."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:269
msgid "existing file name."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:270
msgid "linked name."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:272
msgid ""
"``fio.link`` and ``fio.symlink`` and ``fio.unlink`` return true if success, "
"false if failure. ``fio.readlink`` returns the link value if success, nil if "
"failure."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:278
msgid ""
"tarantool> fio.link('/home/username/tmp.txt', '/home/username/tmp.txt2')\n"
"---\n"
"- true\n"
"...\n"
"tarantool> fio.unlink('/home/username/tmp.txt2')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:291
msgid "Rename a file or directory. For details type \"man 2 rename\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:293
msgid "original name."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:294
msgid "new name."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:301
msgid ""
"tarantool> fio.rename('/home/username/tmp.txt', '/home/username/tmp.txt2')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:311
msgid ""
"Manage the rights to file objects, or ownership of file objects. For details "
"type \"man 2 chown\" or \"man 2 chmod\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:314
msgid "new user uid."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:315
msgid "new group uid."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:316
msgid "new permissions"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:320
msgid ""
"tarantool> fio.chmod('/home/username/tmp.txt', tonumber('0755', 8))\n"
"---\n"
"- true\n"
"...\n"
"tarantool> fio.chown('/home/username/tmp.txt', 'username', 'username')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:333
msgid "Reduce file size to a specified value. For details type \"man 2 truncate\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:343
msgid ""
"tarantool> fio.truncate('/home/username/tmp.txt', 99999)\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:352
msgid "Ensure that changes are written to disk. For details type \"man 2 sync\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:359
msgid ""
"tarantool> fio.sync()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:375
msgid "Open a file in preparation for reading or writing or seeking."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:378
msgid ""
"Flags can be passed as a number or as string constants, for example "
"'``O_RDONLY``', '``O_WRONLY``', '``O_RDWR``'. Flags can be combined by enclosing "
"them in braces."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:382
msgid ""
"Mode bits can be passed as a number or as string constants, for example "
"''`S_IWUSR`\". Mode bits are significant if flags include `O_CREAT` or "
"`O_TMPFILE`. Mode bits can be combined by enclosing them in braces."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:387
msgid "file handle (later - fh)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:394
msgid ""
"tarantool> fh = fio.open('/home/username/tmp.txt', {'O_RDWR', 'O_APPEND'})\n"
"---\n"
"...\n"
"tarantool> fh -- display file handle returned by fio.open\n"
"---\n"
"- fh: 11\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:408
msgid ""
"Close a file that was opened with ``fio.open``. For details type \"man 2 close\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:410
#: ../doc/1.7/reference/reference_lua/fio.rst:430
#: ../doc/1.7/reference/reference_lua/fio.rst:461
#: ../doc/1.7/reference/reference_lua/fio.rst:481
#: ../doc/1.7/reference/reference_lua/fio.rst:499
#: ../doc/1.7/reference/reference_lua/fio.rst:522
#: ../doc/1.7/reference/reference_lua/fio.rst:555
msgid "file-handle as returned by ``fio.open()``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:411
msgid "true if success, false on failure."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:416
msgid ""
"tarantool> fh:close() -- where fh = file-handle\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:426
msgid ""
"Perform read/write random-access operation on a file, without affecting the "
"current seek position of the file. For details type \"man 2 pread\" or \"man 2 "
"pwrite\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:431
#: ../doc/1.7/reference/reference_lua/fio.rst:462
msgid "number of bytes to read"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:432
#: ../doc/1.7/reference/reference_lua/fio.rst:463
msgid "value to write"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:433
msgid "offset within file where reading or writing begins"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:434
msgid ""
"``fh:pwrite`` returns true if success, false if failure. ``fh:pread`` returns "
"the data that was read, or nil if failure."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:439
msgid ""
"tarantool> fh:pread(25, 25)\n"
"---\n"
"- |\n"
"  elete from t8//\n"
"  insert in\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:451
msgid ""
"Perform non-random-access read or write on a file. For details type \"man 2 read"
"\" or \"man 2 write\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:456
msgid ""
"``fh:read`` and ``fh:write`` affect the seek position within the file, and this "
"must be taken into account when working on the same file from multiple fibers. "
"It is possible to limit or prevent file access from other fibers with ``fiber."
"ipc``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:464
msgid ""
"``fh:write`` returns true if success, false if failure. ``fh:read`` returns the "
"data that was read, or nil if failure."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:469
msgid ""
"tarantool> fh:write('new data')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:478
msgid ""
"Change the size of an open file. Differs from ``fio.truncate``, which changes "
"the size of a closed file."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:487
msgid ""
"tarantool> fh:truncate(0)\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:496
msgid ""
"Shift position in the file to the specified position. For details type \"man 2 "
"seek\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:500
msgid "position to seek to"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:501
msgid ""
"'``SEEK_END``' = end of file, '``SEEK_CUR``' = current position, '``SEEK_SET``' "
"= start of file."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:503
msgid "the new position if success"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:510
msgid ""
"tarantool> fh:seek(20, 'SEEK_SET')\n"
"---\n"
"- 20\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:519
msgid ""
"Return statistics about an open file. This differs from ``fio.stat`` which "
"return statistics about a closed file. For details type \"man 2 stat\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:523
msgid "details about the file."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:528
msgid ""
"tarantool> fh:stat()\n"
"---\n"
"- inode: 729866\n"
"  rdev: 0\n"
"  size: 100\n"
"  atime: 140942855\n"
"  mode: 33261\n"
"  mtime: 1409430660\n"
"  nlink: 1\n"
"  uid: 1000\n"
"  blksize: 4096\n"
"  gid: 1000\n"
"  ctime: 1409430660\n"
"  dev: 2049\n"
"  blocks: 8\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:551
msgid ""
"Ensure that file changes are written to disk, for an open file. Compare ``fio."
"sync``, which is for all files. For details type \"man 2 fsync\" or \"man 2 "
"fdatasync\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:560
msgid ""
"tarantool> fh:fsync()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:571
msgid "FIO constants"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:575
msgid ""
"Table with constants which are the same as POSIX flag values on the target "
"platform (see ``man 2 stat``)."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:580
msgid ""
"tarantool> fio.c\n"
"---\n"
"- seek:\n"
"    SEEK_SET: 0\n"
"    SEEK_END: 2\n"
"    SEEK_CUR: 1\n"
"  mode:\n"
"    S_IWGRP: 16\n"
"    S_IXGRP: 8\n"
"    S_IROTH: 4\n"
"    S_IXOTH: 1\n"
"    S_IRUSR: 256\n"
"    S_IXUSR: 64\n"
"    S_IRWXU: 448\n"
"    S_IRWXG: 56\n"
"    S_IWOTH: 2\n"
"    S_IRWXO: 7\n"
"    S_IWUSR: 128\n"
"    S_IRGRP: 32\n"
"  flag:\n"
"    O_EXCL: 2048\n"
"    O_NONBLOCK: 4\n"
"    O_RDONLY: 0\n"
"    <...>\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fun.rst:39
msgid "Module `fun`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fun.rst:41
msgid ""
"Luafun, also known as the Lua Functional Library, takes advantage of the "
"features of LuaJIT to help users create complex functions. Inside the module are "
"\"sequence processors\" such as ``map``, ``filter``, ``reduce``, ``zip`` -- they "
"take a user-written function as an argument and run it against every element in "
"a sequence, which can be faster or more convenient than a user-written loop. "
"Inside the module are \"generators\" such as ``range``, ``tabulate``, and "
"``rands`` -- they return a bounded or boundless series of values. Within the "
"module are \"reducers\", \"filters\", \"composers\" ... or, in short, all the "
"important features found in languages like Standard ML, Haskell, or Erlang."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fun.rst:51
msgid ""
"The full documentation is `On the luafun section of github`_. However, the first "
"chapter can be skipped because installation is already done, it's inside "
"Tarantool. All that is needed is the usual ``require`` request. After that, all "
"the operations described in the Lua fun manual will work, provided they are "
"preceded by the name returned by the ``require`` request. For example:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fun.rst:57
msgid ""
"tarantool> fun = require('fun')\n"
"---\n"
"...\n"
"tarantool> for _k, a in fun.range(3) do\n"
"         >   print(a)\n"
"         > end\n"
"1\n"
"2\n"
"3\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:39
#, fuzzy
msgid "Module `http`"
msgstr "Модуль `tuple`"

#: ../doc/1.7/reference/reference_lua/http.rst:43
msgid ""
"The ``http`` module, specifically the ``http.client`` submodule, provides the "
"functionality of an HTTP client with support for HTTPS and keepalive. It uses "
"routines in the `libcurl <https://curl.haxx.se/libcurl/>`_ library."
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:51
msgid "Construct a new HTTP client instance."
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:53
msgid "the maximum number of entries in the connection cache."
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:55
#, fuzzy
msgid "a new HTTP client instance"
msgstr "Подсоединение к экземплярам"

#: ../doc/1.7/reference/reference_lua/http.rst:60
msgid ""
"tarantool> http_client = require('http.client').new({5})\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:70
msgid ""
"If ``http_client`` is an HTTP client instance, ``http_client:request()`` will "
"perform an HTTP request and, if there is a successful connection, will return a "
"table with connection information."
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:74
msgid "HTTP method, for example 'GET' or 'POST' or 'PUT'"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:75
msgid "location, for example 'https://tarantool.org/doc'"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:76
msgid "optional initial message, for example 'My text string!'"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:77
msgid ""
"table of connection options, with any of these components:   * ``timeout`` - "
"number of seconds to wait for a curl API read request    before timing out  * "
"``ca_path`` - path to a directory holding one or more certificates to    verify "
"the peer with  * ``ca_file`` - path to an SSL certificate file to verify the "
"peer with  * ``verify_host`` - set on/off verification of the certificate's "
"name    (CN) against host. See also    `CURLOPT_SSL_VERIFYHOST <https://curl."
"haxx.se/libcurl/c/CURLOPT_SSL_VERIFYHOST.html>`_  * ``verify_peer`` - set on/off "
"verification of the peer's SSL    certificate. See also    "
"`CURLOPT_SSL_VERIFYPEER <https://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYPEER."
"html>`_  * ``ssl_key`` - path to a private key file for a TLS and SSL client    "
"certificate. See also    `CURLOPT_SSLKEY <https://curl.haxx.se/libcurl/c/"
"CURLOPT_SSLKEY.html>`_  * ``ssl_cert`` - path to a SSL client certificate file. "
"See also    `CURLOPT_SSLCERT <https://curl.haxx.se/libcurl/c/CURLOPT_SSLCERT."
"html>`_  * ``headers`` - table of HTTP headers  * ``keepalive_idle`` - delay, in "
"seconds, that the operating system    will wait while the connection is idle "
"before sending keepalive    probes. See also    `CURLOPT_TCP_KEEPALIVE <https://"
"curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPALIVE.html>`_  * ``keepalive_interval`` - "
"the interval, in seconds, that the operating    system will wait between sending "
"keepalive probes. See also    `CURLOPT_TCP_KEEPALIVE <https://curl.haxx.se/"
"libcurl/c/CURLOPT_TCP_KEEPALIVE.html>`_  * ``low_speed_time`` - set the \"low "
"speed time\" -- the time that the    transfer speed should be below the \"low "
"speed limit\" for the library    to consider it too slow and abort. See also    "
"`CURLOPT_LOW_SPEED_TIME <https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_TIME."
"html>`_  * ``low_speed_limit`` - set the \"low speed limit\" -- the average    "
"transfer speed in bytes per second that the transfer should be below    during "
"\"low speed time\" seconds for the library to consider it to be    too slow and "
"abort. See also    `CURLOPT_LOW_SPEED_LIMIT <https://curl.haxx.se/libcurl/c/"
"CURLOPT_LOW_SPEED_LIMIT.html>`_  * ``verbose`` - set on/off verbose mode"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:77
msgid "table of connection options, with any of these components:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:80
msgid ""
"``timeout`` - number of seconds to wait for a curl API read request before "
"timing out"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:82
msgid ""
"``ca_path`` - path to a directory holding one or more certificates to verify the "
"peer with"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:84
msgid "``ca_file`` - path to an SSL certificate file to verify the peer with"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:85
msgid ""
"``verify_host`` - set on/off verification of the certificate's name (CN) against "
"host. See also `CURLOPT_SSL_VERIFYHOST <https://curl.haxx.se/libcurl/c/"
"CURLOPT_SSL_VERIFYHOST.html>`_"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:88
msgid ""
"``verify_peer`` - set on/off verification of the peer's SSL certificate. See "
"also `CURLOPT_SSL_VERIFYPEER <https://curl.haxx.se/libcurl/c/"
"CURLOPT_SSL_VERIFYPEER.html>`_"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:91
msgid ""
"``ssl_key`` - path to a private key file for a TLS and SSL client certificate. "
"See also `CURLOPT_SSLKEY <https://curl.haxx.se/libcurl/c/CURLOPT_SSLKEY.html>`_"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:94
msgid ""
"``ssl_cert`` - path to a SSL client certificate file. See also `CURLOPT_SSLCERT "
"<https://curl.haxx.se/libcurl/c/CURLOPT_SSLCERT.html>`_"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:96
msgid "``headers`` - table of HTTP headers"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:97
msgid ""
"``keepalive_idle`` - delay, in seconds, that the operating system will wait "
"while the connection is idle before sending keepalive probes. See also "
"`CURLOPT_TCP_KEEPALIVE <https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPALIVE."
"html>`_"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:101
msgid ""
"``keepalive_interval`` - the interval, in seconds, that the operating system "
"will wait between sending keepalive probes. See also `CURLOPT_TCP_KEEPALIVE "
"<https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPALIVE.html>`_"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:104
msgid ""
"``low_speed_time`` - set the \"low speed time\" -- the time that the transfer "
"speed should be below the \"low speed limit\" for the library to consider it too "
"slow and abort. See also `CURLOPT_LOW_SPEED_TIME <https://curl.haxx.se/libcurl/c/"
"CURLOPT_LOW_SPEED_TIME.html>`_"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:108
msgid ""
"``low_speed_limit`` - set the \"low speed limit\" -- the average transfer speed "
"in bytes per second that the transfer should be below during \"low speed time\" "
"seconds for the library to consider it to be too slow and abort. See also "
"`CURLOPT_LOW_SPEED_LIMIT <https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_LIMIT."
"html>`_"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:113
msgid "``verbose`` - set on/off verbose mode"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:115
msgid "connection information, with all of these components:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:117
msgid "``status`` - HTTP response status"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:118
msgid "``reason`` - HTTP response status text"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:119
msgid "``headers`` - a Lua table with normalized HTTP headers"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:120
msgid "``body`` - response body"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:121
msgid "``proto`` - protocol version"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:125
msgid "The following \"shortcuts\" exist for requests:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:127
msgid ""
"``http_client:get(url, options)`` - shortcut for ``http_client:request(\"GET\", "
"url, nil, opts)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:129
msgid ""
"``http_client:post (url, body, options)`` - shortcut for ``http_client:"
"request(\"POST\", url, body, opts)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:131
msgid ""
"``http_client:put(url, body, options)`` - shortcut for ``http_client:"
"request(\"POST\", url, body, opts)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:133
msgid ""
"``http_client:patch(url, body, options)`` - shortcut for ``http_client:"
"request(\"PATCH\", url, body, opts)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:135
msgid ""
"``http_client:options(url, options)`` - shortcut for ``http_client:"
"request(\"OPTIONS\", url, nil, opts)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:137
msgid ""
"``http_client:head(url, options)`` - shortcut for ``http_client:request(\"HEAD"
"\", url, nil, opts)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:139
msgid ""
"``http_client:delete(url, options)`` - shortcut for ``http_client:"
"request(\"DELETE\", url, nil, opts)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:141
msgid ""
"``http_client:trace(url, options)`` - shortcut for ``http_client:request(\"TRACE"
"\", url, nil, opts)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:143
msgid ""
"``http_client:connect:(url, options)`` - shortcut for ``http_client:"
"request(\"CONNECT\", url, nil, opts)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:148
msgid "The ``http_client:stat()`` function returns a table with statistics:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:150
msgid "``active_requests`` - number of currently executing requests"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:151
msgid "``sockets_added`` - total number of sockets added into an event loop"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:152
msgid "``sockets_deleted`` - total number of sockets sockets from an event loop"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:153
msgid "``total_requests`` - total number of requests"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:154
msgid ""
"``http_200_responses`` - total number of requests which have returned code HTTP "
"200"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:156
msgid ""
"``http_other_responses`` - total number of requests which have not returned code "
"HTTP 200"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:158
msgid ""
"``failed_requests`` - total number of requests which have failed including "
"system errors, curl errors, and HTTP errors"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:163
msgid ""
"Connect to an HTTP server, look at the size of the response for a 'GET' request, "
"and look at the statistics for the session."
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:166
msgid ""
"tarantool> http_client = require('http.client').new()\n"
"---\n"
"...\n"
"tarantool> r = http_client:request('GET','http://tarantool.org')\n"
"---\n"
"...\n"
"tarantool> string.len(r.body)\n"
"---\n"
"- 21725\n"
"...\n"
"tarantool> http_client:stat()\n"
"---\n"
"- total_requests: 1\n"
"  sockets_deleted: 2\n"
"  failed_requests: 0\n"
"  active_requests: 0\n"
"  http_other_responses: 0\n"
"  http_200_responses: 1\n"
"  sockets_added: 2"
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:39
#, fuzzy
msgid "Module `iconv`"
msgstr "Модуль `coio`"

#: ../doc/1.7/reference/reference_lua/iconv.rst:43
msgid ""
"The ``iconv`` module provides a way to convert a string with one encoding to a "
"string with another encoding, for example from ASCII to UTF-8. It is based on "
"the POSIX iconv routines."
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:47
msgid ""
"An exact list of the available encodings may depend on environment. Typically "
"the list includes ASCII, BIG5, KOI8R, LATIN8, MS-GREEK, SJIS, and about 100 "
"others. For a complete list, type ``iconv --list`` on a terminal."
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:56
msgid "Construct a new iconv instance."
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:58
msgid "the name of the encoding that we will convert to."
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:59
msgid "the name of the encoding that we will convert from."
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:61
msgid "a new iconv instance -- in effect, a callable function"
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:64
msgid "If either parameter is not a valid name, there will be an error message."
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:68
msgid ""
"tarantool> converter = require('iconv').new('UTF8', 'ASCII')\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:76
msgid "Convert."
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:78
msgid "the string to be converted (the \"from\" string)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:80
msgid "the string that results from the conversion (the \"to\" string)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:82
msgid ""
"If anything in input-string cannot be converted, there will be an error message "
"and the result string will be unchanged."
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:87
msgid ""
"We know that the Unicode code point for \"Д\" (CYRILLIC CAPITAL LETTER DE) is "
"hexadecimal 0414 according to the character database of Unicode_. Therefore that "
"is what it will look like in UTF-16. We know that Tarantool typically uses the "
"UTF-8 character set. So make a from-UTF-8-to-UTF-16 converter, use string."
"hex('Д') to show what Д's encoding looks like in the UTF-8 source, and use "
"string.hex('Д'-after-conversion) to show what it looks like in the UTF-16 "
"target. Since the result is 0414, we see that iconv conversion works."
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:96
msgid ""
"tarantool> string.hex('Д')\n"
"---\n"
"- d094\n"
"...\n"
"\n"
"tarantool> converter = require('iconv').new('UTF16BE', 'UTF8')\n"
"---\n"
"...\n"
"\n"
"tarantool> utf16_string = converter('Д')\n"
"---\n"
"...\n"
"\n"
"tarantool> string.hex(utf16_string)\n"
"---\n"
"- '0414'\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/index.rst:39
#, fuzzy
msgid "Built-in modules reference"
msgstr "Справочник по встроенной библиотеке"

#: ../doc/1.7/reference/reference_lua/index.rst:41
msgid "This reference covers Tarantool's built-in Lua modules."
msgstr ""

#: ../doc/1.7/reference/reference_lua/index.rst:45
msgid ""
"Some functions in these modules are analogs to functions from `standard Lua "
"libraries <http://www.lua.org/manual/>`_. For better results, we recommend using "
"functions from Tarantool's built-in modules."
msgstr ""

#: ../doc/1.7/reference/reference_lua/index.rst:49
msgid "List of Lua modules"
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:39
msgid "Module `json`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:41
msgid ""
"The ``json`` module provides JSON manipulation routines. It is based on the `Lua-"
"CJSON module by Mark Pulford`_. For a complete manual on Lua-CJSON please read "
"`the official documentation`_."
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:51
msgid "Convert a Lua object to a JSON string."
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:53
#: ../doc/1.7/reference/reference_lua/msgpack.rst:52
#: ../doc/1.7/reference/reference_lua/yaml.rst:50
msgid "either a scalar value or a Lua table value."
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:54
msgid "the original value reformatted as a JSON string."
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:59
msgid ""
"tarantool> json=require('json')\n"
"---\n"
"...\n"
"tarantool> json.encode(123)\n"
"---\n"
"- '123'\n"
"...\n"
"tarantool> json.encode({123})\n"
"---\n"
"- '[123]'\n"
"...\n"
"tarantool> json.encode({123, 234, 345})\n"
"---\n"
"- '[123,234,345]'\n"
"...\n"
"tarantool> json.encode({abc = 234, cde = 345})\n"
"---\n"
"- '{\"cde\":345,\"abc\":234}'\n"
"...\n"
"tarantool> json.encode({hello = {'world'}})\n"
"---\n"
"- '{\"hello\":[\"world\"]}'\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:89
msgid "Convert a JSON string to a Lua object."
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:91
msgid "a string formatted as JSON."
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:92
#: ../doc/1.7/reference/reference_lua/yaml.rst:59
msgid "the original contents formatted as a Lua table."
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:97
msgid ""
"tarantool> json = require('json')\n"
"---\n"
"...\n"
"tarantool> json.decode('123')\n"
"---\n"
"- 123\n"
"...\n"
"tarantool> json.decode('[123, \"hello\"]')\n"
"---\n"
"- [123, 'hello']\n"
"...\n"
"tarantool> json.decode('{\"hello\": \"world\"}').hello\n"
"---\n"
"- world\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:115
msgid ""
"See the tutorial :ref:`Sum a JSON field for all tuples <c_lua_tutorial-"
"sum_a_json_field>` to see how ``json.decode()`` can fit in an application."
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:123
#: ../doc/1.7/reference/reference_lua/msgpack.rst:71
#: ../doc/1.7/reference/reference_lua/yaml.rst:66
msgid ""
"A value comparable to Lua \"nil\" which may be useful as a placeholder in a "
"tuple."
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:128
msgid ""
"-- When nil is assigned to a Lua-table field, the field is null\n"
"tarantool> {nil, 'a', 'b'}\n"
"---\n"
"- - null\n"
"  - a\n"
"  - b\n"
"...\n"
"-- When json.NULL is assigned to a Lua-table field, the field is json.NULL\n"
"tarantool> {json.NULL, 'a', 'b'}\n"
"---\n"
"- - null\n"
"  - a\n"
"  - b\n"
"...\n"
"-- When json.NULL is assigned to a JSON field, the field is null\n"
"tarantool> json.encode({field2 = json.NULL, field1 = 'a', field3 = 'c'})\n"
"---\n"
"- '{\"field2\":null,\"field1\":\"a\",\"field3\":\"c\"}'\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:150
msgid "The JSON output structure can be specified with ``__serialize``:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:152
msgid "``__serialize=\"seq\"`` for an array"
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:153
msgid "``__serialize=\"map\"`` for a map"
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:155
#: ../doc/1.7/reference/reference_lua/yaml.rst:103
msgid ""
"Serializing 'A' and 'B' with different ``__serialize`` values causes different "
"results:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:158
msgid ""
"tarantool> json.encode(setmetatable({'A', 'B'}, { __serialize=\"seq\"}))\n"
"---\n"
"- '[\"A\",\"B\"]'\n"
"...\n"
"tarantool> json.encode(setmetatable({'A', 'B'}, { __serialize=\"map\"}))\n"
"---\n"
"- '{\"1\":\"A\",\"2\":\"B\"}'\n"
"...\n"
"tarantool> json.encode({setmetatable({f1 = 'A', f2 = 'B'}, { __serialize=\"map"
"\"})})\n"
"---\n"
"- '[{\"f2\":\"B\",\"f1\":\"A\"}]'\n"
"...\n"
"tarantool> json.encode({setmetatable({f1 = 'A', f2 = 'B'}, { __serialize=\"seq"
"\"})})\n"
"---\n"
"- '[[]]'\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:182
msgid "Configuration settings"
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:184
msgid ""
"There are configuration settings which affect the way that Tarantool encodes "
"invalid numbers or types. They are all boolean ``true``/``false`` values"
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:187
msgid "``cfg.encode_invalid_numbers`` (default is true) -- allow nan and inf"
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:188
msgid ""
"``cfg.encode_use_tostring`` (default is false) -- use tostring for "
"unrecognizable types"
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:190
msgid ""
"``cfg.encode_invalid_as_nil`` (default is false) -- use null for all "
"unrecognizable types"
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:192
msgid "``cfg.encode_load_metatables`` (default is false) -- load metatables"
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:194
msgid ""
"For example, the following code will interpret 0/0 (which is \"not a number\") "
"and 1/0 (which is \"infinity\") as special values rather than nulls or errors:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:197
msgid ""
"json = require('json')\n"
"json.cfg{encode_invalid_numbers = true}\n"
"x = 0/0\n"
"y = 1/0\n"
"json.encode({1, x, y, 2})"
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:205
msgid "The result of the ``json.encode()`` request will look like this:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:207
msgid ""
"tarantool> json.encode({1, x, y, 2})\n"
"---\n"
"- '[1,nan,inf,2]\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:214
msgid ""
"The same configuration settings exist for json, for :ref:`MsgPack <msgpack-"
"module>`, and for :ref:`YAML <yaml-module>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:39
msgid "Module `log`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:43
msgid ""
"The Tarantool server puts all diagnostic messages in a log file specified by "
"the :ref:`log <cfg_logging-log>` configuration parameter. Diagnostic messages "
"may be either system-generated by the server's internal code, or user-generated "
"with the :samp:`log.{log_level_function_name}` function."
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:54
msgid ""
"Output a user-generated message to the :ref:`log file <cfg_logging-log>`, given "
"log_level_function_name = ``error`` or ``warn`` or ``info`` or ``verbose`` or "
"``debug``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:58
msgid ""
"As explained in the description of the configuration setting for :ref:`log_level "
"<cfg_logging-log_level>`, there are seven levels of detail:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:62
msgid "2 – ``ERROR`` -- this corresponds to ``log.error(...)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:64
msgid "4 – ``WARNING``  -- this corresponds to ``log.warn(...)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:65
msgid "5 – ``INFO`` -- this corresponds to ``log.info(...)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:66
msgid "6 – ``VERBOSE``  -- this corresponds to ``log.verbose(...)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:67
msgid "7 – ``DEBUG`` -- this corresponds to ``log.debug(...)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:69
msgid ""
"For example, if ``box.cfg.log_level`` is currently 5 (the default value), then "
"``log.error(...)``, ``log.warn(...)`` and ``log.info(...)`` messages will go to "
"the log file. However, ``log.verbose(...)`` and ``log.debug(...)`` messages will "
"not go to the log file, because they correspond to higher levels of detail."
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:75
#, python-format
msgid ""
"The actual output will be a line containing:  * the current timestamp, * a "
"module name, * 'E', 'W', 'I', 'V' or 'D' depending on "
"``log_level_function_name``, and * ``message``.  Output will not occur if "
"``log_level_function_name`` is for a type greater than :ref:`log_level "
"<cfg_logging-log_level>`.  Messages may contain C-style format specifiers %d or "
"%s, so :samp:`log.error('...%d...%s', {x}, {y})` will work if ``x`` is a number "
"and ``y`` is a string."
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:75
msgid "The actual output will be a line containing:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:77
msgid "the current timestamp,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:78
msgid "a module name,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:79
msgid "'E', 'W', 'I', 'V' or 'D' depending on ``log_level_function_name``, and"
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:80
msgid "``message``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:82
msgid ""
"Output will not occur if ``log_level_function_name`` is for a type greater than :"
"ref:`log_level <cfg_logging-log_level>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:86
#, python-format
msgid ""
"Messages may contain C-style format specifiers %d or %s, so :samp:`log.error('..."
"%d...%s', {x}, {y})` will work if ``x`` is a number and ``y`` is a string."
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:102
#, python-format
msgid ""
"$ tarantool\n"
"tarantool> box.cfg{log_level=3, log='tarantool.txt'}\n"
"tarantool> log = require('log')\n"
"tarantool> log.error('Error')\n"
"tarantool> log.info('Info %s', box.info.version)\n"
"tarantool> os.exit()"
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:111
msgid ""
"$ less tarantool.txt\n"
"2017-09-20 ... [68617] main/101/interactive C> version 1.7.5-31-ge939c6ea6\n"
"2017-09-20 ... [68617] main/101/interactive C> log level 3\n"
"2017-09-20 ... [68617] main/101/interactive [C]:-1 E> Error"
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:118
msgid "The 'Error' line is visible in ``tarantool.txt`` preceded by the letter E."
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:120
msgid "The 'Info' line is not present because the ``log_level`` is 3."
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:39
msgid "Module `msgpack`"
msgstr "Модуль `msgpack`"

#: ../doc/1.7/reference/reference_lua/msgpack.rst:41
msgid ""
"The ``msgpack`` module takes strings in MsgPack_ format and decodes them, or "
"takes a series of non-MsgPack values and encodes them. Tarantool makes heavy "
"internal use of MsgPack because tuples in Tarantool are :ref:`stored <index-"
"box_lua-vs-msgpack>` as MsgPack arrays."
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:50
msgid "Convert a Lua object to a MsgPack string."
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:53
msgid "the original value reformatted as a MsgPack string."
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:58
msgid "Convert a MsgPack string to a Lua object."
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:60
msgid "a string formatted as MsgPack."
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:62
msgid "the original contents formatted as a Lua table;"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:63
msgid "the number of bytes that were decoded."
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:65
msgid "lua object"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:78
msgid ""
"tarantool> msgpack = require('msgpack')\n"
"---\n"
"...\n"
"tarantool> y = msgpack.encode({'a',1,'b',2})\n"
"---\n"
"...\n"
"tarantool> z = msgpack.decode(y)\n"
"---\n"
"...\n"
"tarantool> z[1], z[2], z[3], z[4]\n"
"---\n"
"- a\n"
"- 1\n"
"- b\n"
"- 2\n"
"...\n"
"tarantool> box.space.tester:insert{20, msgpack.NULL, 20}\n"
"---\n"
"- [20, null, 20]\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:103
msgid "The MsgPack output structure can be specified with ``__serialize``:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:105
msgid "``__serialize = \"seq\" or \"sequence\"`` for an array"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:106
msgid "``__serialize = \"map\" or \"mapping\"`` for a map"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:108
msgid ""
"Serializing 'A' and 'B' with different ``__serialize`` values causes different "
"results. To show this, here is a routine which encodes `{'A','B'}` both as an "
"array and as a map, then displays each result in hexadecimal."
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:112
#, python-format
msgid ""
"function hexdump(bytes)\n"
"    local result = ''\n"
"    for i = 1, #bytes do\n"
"        result = result .. string.format(\"%x\", string.byte(bytes, i)) .. ' '\n"
"    end\n"
"    return result\n"
"end\n"
"\n"
"msgpack = require('msgpack')\n"
"m1 = msgpack.encode(setmetatable({'A', 'B'}, {\n"
"                             __serialize = \"seq\"\n"
"                          }))\n"
"m2 = msgpack.encode(setmetatable({'A', 'B'}, {\n"
"                             __serialize = \"map\"\n"
"                          }))\n"
"print('array encoding: ', hexdump(m1))\n"
"print('map encoding: ', hexdump(m2))"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:132
msgid "**Result:**"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:137
msgid ""
"**array** encoding: 92 a1 41 a1 42\n"
"**map** encoding:   82 01 a1 41 02 a1 42"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:140
msgid "The MsgPack Specification_ page explains that the first encoding means:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:145
msgid "fixarray(2), fixstr(1), \"A\", fixstr(1), \"B\""
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:147
msgid "and the second encoding means:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:152
msgid "fixmap(2), key(1), fixstr(1), \"A\", key(2), fixstr(2), \"B\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:154
msgid ""
"Here are examples for all the common types, with the Lua-table representation on "
"the left, with the MsgPack format name and encoding on the right."
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:162
msgid "**Common Types and MsgPack Encodings**"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:168
msgid "{}"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:168
msgid "'fixmap' if metatable is 'map' = 80 otherwise 'fixarray' = 90"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:171
msgid "'a'"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:171
msgid "'fixstr' = a1 61"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:173
msgid "'false' = c2"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:175
msgid "'true' = c3"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:177
msgid "127"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:177
msgid "'positive fixint' = 7f"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:179
msgid "65535"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:179
msgid "'uint 16' = cd ff ff"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:181
msgid "4294967295"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:181
msgid "'uint 32' = ce ff ff ff ff"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:183
msgid "'nil' = c0"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:185
msgid "same as nil"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:187
msgid "[0] = 5"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:187
msgid ""
"'fixmap(1)' + 'positive fixint' (for the key) + 'positive fixint' (for the "
"value) = 81 00 05"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:190
msgid "[0] = nil"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:190
msgid "'fixmap(0)' = 80 -- nil is not stored when it is a missing map value"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:193
msgid "1.5"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:193
msgid "'float 64' = cb 3f f8 00 00 00 00 00 00"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:196
msgid ""
"Also, some MsgPack configuration settings for encoding can be changed, in the "
"same way that they can be changed for :ref:`JSON <json-module_cfg>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:39
msgid "Module `net.box`"
msgstr "Модуль `net.box`"

#: ../doc/1.7/reference/reference_lua/net_box.rst:41
msgid ""
"The ``net.box`` module contains connectors to remote database systems. One "
"variant, to be discussed later, is connecting to MySQL or MariaDB or PostgreSQL "
"(see :ref:`SQL DBMS modules <dbms_modules>` reference). The other variant, which "
"is discussed in this section, is connecting to Tarantool server instances via a "
"network using the built-in ``net.box`` module."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:47
msgid "You can call the following methods:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:49
msgid ""
"``require('net.box')`` to get a ``net.box`` object (named ``net_box`` for "
"examples in this section),"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:51
msgid ""
"``net_box.connect()`` to connect and get a connection object (named ``conn`` for "
"examples in this section),"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:53
msgid ""
"other ``net.box()`` routines, passing ``conn:``, to execute requests on a remote "
"box,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:55
msgid "``conn:close`` to disconnect."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:57
msgid ""
"All ``net.box`` methods are fiber-safe, that is, it is safe to share and use the "
"same connection object across multiple concurrent fibers. In fact, it's perhaps "
"the best programming practice with Tarantool. When multiple fibers use the same "
"connection, all requests are pipelined through the same network socket, but each "
"fiber gets back a correct response. Reducing the number of active sockets lowers "
"the overhead of system calls and increases the overall server performance. There "
"are, however, cases when a single connection is not enough — for example, when "
"it's necessary to prioritize requests or to use different authentication IDs."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:66
msgid ""
"Most ``net.box`` methods allow a final ``{options}`` argument, which can be:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:68
msgid ""
"``{timeout=...}``. For example, a method whose final argument is ``{timeout=1.5}"
"`` will stop after 1.5 seconds on the local node, although this does not "
"guarantee that execution will stop on the remote server node."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:71
msgid "``{buffer=...}``. For an example see :ref:`buffer module <buffer-module>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:73
msgid "The diagram below shows possible connection states and transitions:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:81
msgid "On this diagram:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:83
msgid "The state machine starts in the 'initial' state."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:85
msgid ""
"``net_box.connect()`` method changes the state to 'connecting' and spawns a "
"worker fiber."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:87
msgid ""
"If authentication and schema upload are required, it's possible later on to re-"
"enter the 'fetch_schema' state from 'active' if a request fails due to a schema "
"version mismatch error, so schema reload is triggered."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:91
msgid ""
"``conn.close()`` method sets the state to 'closed' and kills the worker. If the "
"transport is already in the 'error' state, ``close()`` does nothing."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:101
msgid ""
"The names ``connect()`` and ``new()`` are synonymous with the only difference "
"that ``connect()`` is the preferred name, while ``new()`` is retained for "
"backward compatibility."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:105
msgid ""
"Create a new connection. The connection is established on demand, at the time of "
"the first request. It can be re-established automatically after a disconnect "
"(see ``reconnect_after`` option below). The returned ``conn`` object supports "
"methods for making remote requests, such as select, update or delete."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:111
msgid ""
"For a local Tarantool server, there is a pre-created always-established "
"connection object named :samp:`{net_box}.self`. Its purpose is to make "
"polymorphic use of the ``net_box`` API easier. Therefore :samp:`conn = {net_box}."
"connect('localhost:3301')` can be replaced by :samp:`conn = {net_box}.self`. "
"However, there is an important difference between the embedded connection and a "
"remote one. With the embedded connection, requests which do not modify data do "
"not yield. When using a remote connection, due to :ref:`the implicit rules "
"<atomic-implicit-yields>` any request can yield, and database state may have "
"changed by the time it regains control."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:123
msgid "Possible options:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:125
msgid ""
"`wait_connected`: by default, connection creation is blocked until the "
"connection is established, but passing ``wait_connected=false`` makes it return "
"immediately. Also, passing a timeout makes it wait before returning (e.g. "
"``wait_connected=1.5`` makes it wait at most 1.5 seconds)."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:131
msgid ""
"In the presence of ``reconnect_after``, ``wait_connected`` ignores transient "
"failures. The wait completes once the connection is established or is closed "
"explicitly."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:134
msgid ""
"`reconnect_after`: a ``net.box`` instance automatically reconnects any time the "
"connection is broken or if a connection attempt fails. This makes transient "
"network failures become transparent to the application. Reconnect happens "
"automatically in the background, so queries/requests that suffered due to "
"connectivity loss are transparently retried. The number of retries is unlimited, "
"connection attempts are done over the specified timeout (e.g. "
"``reconnect_after=5`` for 5 secs). Once a connection is explicitly closed (or "
"garbage-collected), reconnects stop."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:143
msgid ""
"`call_16`: [since 1.7.2] by default, ``net.box`` connections comply with a new "
"binary protocol command for CALL, which is not backward compatible with previous "
"versions. The new CALL no longer restricts a function to returning an array of "
"tuples and allows returning an arbitrary MsgPack/JSON result, including scalars, "
"nil and void (nothing). The old CALL is left intact for backward compatibility. "
"It will be removed in the next major release. All programming language drivers "
"will be gradually changed to use the new CALL. To connect to a Tarantool "
"instance that uses the old CALL, specify ``call_16=true``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:152
msgid ""
"`console`: depending on the option's value, the connection supports different "
"methods (as if instances of different classes were returned). With ``console = "
"true``, you can use ``conn`` methods ``close()``, ``is_connected()``, "
"``wait_state()``, ``eval()`` (in this case, both binary and Lua console network "
"protocols are supported). With ``console = false`` (default), you can also use "
"``conn`` database methods (in this case, only the binary protocol is supported)."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:158
msgid ""
"`connect_timeout`: number of seconds to wait before returning \"error: "
"Connection timed out\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:160
msgid "the :ref:`URI <index-uri>` of the target for the connection"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:161
msgid ""
"possible options are `wait_connected`, `reconnect_after`, `call_16` and `console`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:162
msgid "conn object"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:167
msgid ""
"conn = net_box.connect('localhost:3301')\n"
"conn = net_box.connect('127.0.0.1:3302', {wait_connected = false})\n"
"conn = net_box.connect('127.0.0.1:3303', {reconnect_after = 5, call_16 = true})"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:177
msgid "Execute a PING command."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:179
msgid "true on success, false on error"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:184
msgid "net_box.self:ping()"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:190
msgid "Wait for connection to be active or closed."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:192
#: ../doc/1.7/reference/reference_lua/net_box.rst:220
msgid "in seconds"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:193
msgid "true when connected, false on failure."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:198
msgid "net_box.self:wait_connected()"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:204
msgid "Show whether connection is active or closed."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:206
msgid "true if connected, false on failure."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:211
msgid "net_box.self:is_connected()"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:217
msgid "[since 1.7.2] Wait for a target state."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:219
msgid "target states"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:221
msgid "true when a target state is reached, false on timeout or connection closure"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:226
msgid ""
"-- wait infinitely for 'active' state:\n"
"conn:wait_state('active')\n"
"\n"
"-- wait for 1.5 secs at most:\n"
"conn:wait_state('active', 1.5)\n"
"\n"
"-- wait infinitely for either `active` or `fetch_schema` state:\n"
"conn:wait_state({active=true, fetch_schema=true})"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:239
msgid "Close a connection."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:241
msgid ""
"Connection objects are garbage collected just like any other objects in Lua, so "
"an explicit destruction is not mandatory. However, since close() is a system "
"call, it is good programming practice to close a connection explicitly when it "
"is no longer needed, to avoid lengthy stalls of the garbage collector."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:248
msgid "conn:close()"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:254
msgid ""
":samp:`conn.space.{space-name}:select`:code:`({...})` is the remote-call "
"equivalent of the local call :samp:`box.space.{space-name}:select`:code:`{...}`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:259
msgid "conn.space.testspace:select({1,'B'}, {timeout=1})"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:265
msgid ""
"Due to :ref:`the implicit yield rules <atomic-implicit-yields>` a local :samp:"
"`box.space.{space-name}:select`:code:`{...}` does not yield, but a remote :samp:"
"`conn.space.{space-name}:select`:code:`{...}` call does yield, so global "
"variables or database tuples data may change when a remote :samp:`conn.space."
"{space-name}:select`:code:`{...}` occurs."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:274
msgid ""
":samp:`conn.space.{space-name}:get(...)` is the remote-call equivalent of the "
"local call :samp:`box.space.{space-name}:get(...)`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:279
msgid "conn.space.testspace:get({1})"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:285
msgid ""
":samp:`conn.space.{space-name}:insert(...)` is the remote-call equivalent of the "
"local call :samp:`box.space.{space-name}:insert(...)`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:290
msgid "conn.space.testspace:insert({2,3,4,5}, {timeout=1.1})"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:296
msgid ""
":samp:`conn.space.{space-name}:replace(...)` is the remote-call equivalent of "
"the local call :samp:`box.space.{space-name}:replace(...)`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:301
msgid "conn.space.testspace:replace({5,6,7,8})"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:307
msgid ""
":samp:`conn.space.{space-name}:update(...)` is the remote-call equivalent of the "
"local call :samp:`box.space.{space-name}:update(...)`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:312
msgid "conn.space.Q:update({1},{{'=',2,5}}, {timeout=0})"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:318
msgid ""
":samp:`conn.space.{space-name}:upsert(...)` is the remote-call equivalent of the "
"local call :samp:`box.space.{space-name}:upsert(...)`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:323
msgid ""
":samp:`conn.space.{space-name}:delete(...)` is the remote-call equivalent of the "
"local call :samp:`box.space.{space-name}:delete(...)`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:330
msgid ""
"``conn:call('func', {'1', '2', '3'})`` is the remote-call equivalent of "
"``func('1', '2', '3')``. That is, ``conn:call`` is a remote stored-procedure "
"call."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:336
msgid ""
"conn:call('function5')\n"
"conn:call('fx',{1,'B'},{timeout=99})"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:345
msgid ""
":samp:`conn:eval({Lua-string})` evaluates and executes the expression in Lua-"
"string, which may be any statement or series of statements. An :ref:`execute "
"privilege <authentication-owners_privileges>` is required; if the user does not "
"have it, an administrator may grant it with :samp:`box.schema.user."
"grant({username}, 'execute', 'universe')`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:353
msgid ""
"conn:eval('return 5+5')\n"
"conn:eval('return ...', {1,2,3})\n"
"conn:eval('return 5+5, {}, {timeout=0.1})"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:361
msgid ""
"``timeout(...)`` is a wrapper which sets a timeout for the request that follows "
"it. Since version 1.7.4 this method is deprecated -- it is better to pass a "
"timeout value for a method's ``{options}`` parameter."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:367
msgid "conn:timeout(0.5).space.tester:update({1}, {{'=', 2, 15}})"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:371
msgid ""
"Although ``timeout(...)`` is deprecated, all remote calls support its use. Using "
"a wrapper object makes the remote connection API compatible with the local one, "
"removing the need for a separate ``timeout`` argument, which the local version "
"would ignore. Once a request is sent, it cannot be revoked from the remote "
"server even if a timeout expires: the timeout expiration only aborts the wait "
"for the remote server response, not the request itself."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:383
msgid "This example shows the use of most of the ``net.box`` methods."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:385
msgid "The sandbox configuration for this example assumes that:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:387
msgid "the Tarantool instance is running on ``localhost 127.0.0.1:3301``,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:388
msgid ""
"there is a space named ``tester`` with a numeric primary key and with a tuple "
"that contains a key value = 800,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:390
msgid "the current user has read, write and execute privileges."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:392
msgid "Here are commands for a quick sandbox setup:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:394
msgid ""
"box.cfg{listen = 3301}\n"
"s = box.schema.space.create('tester')\n"
"s:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
"t = s:insert({800, 'TEST'})\n"
"box.schema.user.grant('guest', 'read,write,execute', 'universe')"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:402
msgid "And here starts the example:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:404
msgid ""
"tarantool> net_box = require('net.box')\n"
"---\n"
"...\n"
"tarantool> function example()\n"
"         >   local conn, wtuple\n"
"         >   if net_box.self:ping() then\n"
"         >     table.insert(ta, 'self:ping() succeeded')\n"
"         >     table.insert(ta, '  (no surprise -- self connection is pre-"
"established)')\n"
"         >   end\n"
"         >   if box.cfg.listen == '3301' then\n"
"         >     table.insert(ta,'The local server listen address = 3301')\n"
"         >   else\n"
"         >     table.insert(ta, 'The local server listen address is not 3301')\n"
"         >     table.insert(ta, '(  (maybe box.cfg{...listen=\"3301\"...} was "
"not stated)')\n"
"         >     table.insert(ta, '(  (so connect will fail)')\n"
"         >   end\n"
"         >   conn = net_box.connect('127.0.0.1:3301')\n"
"         >   conn.space.tester:delete({800})\n"
"         >   table.insert(ta, 'conn delete done on tester.')\n"
"         >   conn.space.tester:insert({800, 'data'})\n"
"         >   table.insert(ta, 'conn insert done on tester, index 0')\n"
"         >   table.insert(ta, '  primary key value = 800.')\n"
"         >   wtuple = conn.space.tester:select({800})\n"
"         >   table.insert(ta, 'conn select done on tester, index 0')\n"
"         >   table.insert(ta, '  number of fields = ' .. #wtuple)\n"
"         >   conn.space.tester:delete({800})\n"
"         >   table.insert(ta, 'conn delete done on tester')\n"
"         >   conn.space.tester:replace({800, 'New data', 'Extra data'})\n"
"         >   table.insert(ta, 'conn:replace done on tester')\n"
"         >   conn.space.tester:update({800}, {{'=', 2, 'Fld#1'}})\n"
"         >   table.insert(ta, 'conn update done on tester')\n"
"         >   conn:close()\n"
"         >   table.insert(ta, 'conn close done')\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> ta = {}\n"
"---\n"
"...\n"
"tarantool> example()\n"
"---\n"
"...\n"
"tarantool> ta\n"
"---\n"
"- - self:ping() succeeded\n"
"  - '  (no surprise -- self connection is pre-established)'\n"
"  - The local server listen address = 3301\n"
"  - conn delete done on tester.\n"
"  - conn insert done on tester, index 0\n"
"  - '  primary key value = 800.'\n"
"  - conn select done on tester, index 0\n"
"  - '  number of fields = 1'\n"
"  - conn delete done on tester\n"
"  - conn:replace done on tester\n"
"  - conn update done on tester\n"
"  - conn close done\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:39
msgid "Module `os`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:43
msgid ""
"The ``os`` module contains the functions :ref:`execute() <os-execute>`, :ref:"
"`rename() <os-rename>`, :ref:`getenv() <os-getenv>`, :ref:`remove() <os-"
"remove>`, :ref:`date() <os-date>`, :ref:`exit() <os-exit>`, :ref:`time() <os-"
"time>`, :ref:`clock() <os-clock>`, :ref:`tmpname() <os-tmpname>`, :ref:"
"`environ() <os-environ>`, :ref:`setenv() <os-setenv>`, :ref:`setlocale() <os-"
"setlocale>`, :ref:`difftime() <os-difftime>`. Most of these functions are "
"described in the Lua manual Chapter 22 `The Operating System Library <https://"
"www.lua.org/pil/contents.html#22>`_."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:60
msgid "Execute by passing to the shell."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:62
msgid "what to execute."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:66
msgid ""
"tarantool> os.execute('ls -l /usr')\n"
"total 200\n"
"drwxr-xr-x   2 root root 65536 Apr 22 15:49 bin\n"
"drwxr-xr-x  59 root root 20480 Apr 18 07:58 include\n"
"drwxr-xr-x 210 root root 65536 Apr 18 07:59 lib\n"
"drwxr-xr-x  12 root root  4096 Apr 22 15:49 local\n"
"drwxr-xr-x   2 root root 12288 Jan 31 09:50 sbin\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:82
msgid "Rename a file or directory."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:84
msgid "name of existing file or directory,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:85
msgid "changed name of file or directory."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:89
msgid ""
"tarantool> os.rename('local','foreign')\n"
"---\n"
"- null\n"
"- 'local: No such file or directory'\n"
"- 2\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:102
msgid "Get environment variable."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:104
msgid "Parameters: (string) variable-name = environment variable name."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:108
msgid ""
"tarantool> os.getenv('PATH')\n"
"---\n"
"- /usr/local/sbin:/usr/local/bin:/usr/sbin\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:119
msgid "Remove file or directory."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:121
msgid ""
"Parameters: (string) name = name of file or directory which will be removed."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:125
msgid ""
"tarantool> os.remove('file')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:136
msgid "Return a formatted date."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:138
msgid ""
"Parameters: (string) format-string = instructions; (string) time-since-epoch = "
"number of seconds since 1970-01-01. If time-since-epoch is omitted, it is "
"assumed to be the current time."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:143
#, python-format
msgid ""
"tarantool> os.date(\"%A %B %d\")\n"
"---\n"
"- Sunday April 24\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:154
msgid ""
"Exit the program. If this is done on a server instance, then the instance stops."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:158
msgid ""
"tarantool> os.exit()\n"
"user@user-shell:~/tarantool_sandbox$"
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:167
msgid "Return the number of seconds since the epoch."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:171
msgid ""
"tarantool> os.time()\n"
"---\n"
"- 1461516945\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:182
msgid "Return the number of CPU seconds since the program start."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:186
msgid ""
"tarantool> os.clock()\n"
"---\n"
"- 0.05\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:197
msgid "Return a name for a temporary file."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:201
msgid ""
"tarantool> os.tmpname()\n"
"---\n"
"- /tmp/lua_7SW1m2\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:212
msgid "Return a table containing all environment variables."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:216
msgid ""
"tarantool> os.environ()['TERM']..os.environ()['SHELL']\n"
"---\n"
"- xterm/bin/bash\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:227
msgid "Set an environment variable."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:231
msgid ""
"tarantool> os.setenv('VERSION','99')\n"
"---\n"
"-\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:242
msgid ""
"Change the locale. If new-locale-string is not specified, return the current "
"locale."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:247
msgid ""
"tarantool> require('string').sub(os.setlocale(),1,20)\n"
"---\n"
"- LC_CTYPE=en_US.UTF-8\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:258
msgid "Return the number of seconds between two times."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:262
msgid ""
"tarantool> os.difftime(os.time() - 0)\n"
"---\n"
"- 1486594859\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/other.rst:37
msgid "Miscellaneous"
msgstr "Разное"

#: ../doc/1.7/reference/reference_lua/other.rst:43
msgid ""
"Convert a string or a Lua number to a 64-bit integer. The input value can be "
"expressed in decimal, binary (for example 0b1010), or hexadecimal (for example "
"-0xffff). The result can be used in arithmetic, and the arithmetic will be 64-"
"bit integer arithmetic rather than floating-point arithmetic. (Operations on an "
"unconverted Lua number use floating-point arithmetic.) The ``tonumber64()`` "
"function is added by Tarantool; the name is global."
msgstr ""

#: ../doc/1.7/reference/reference_lua/other.rst:53
msgid ""
"tarantool> type(123456789012345), type(tonumber64(123456789012345))\n"
"---\n"
"- number\n"
"- number\n"
"...\n"
"tarantool> i = tonumber64('1000000000')\n"
"---\n"
"...\n"
"tarantool> type(i), i / 2, i - 2, i * 2, i + 2, i % 2, i ^ 2\n"
"---\n"
"- number\n"
"- 500000000\n"
"- 999999998\n"
"- 2000000000\n"
"- 1000000002\n"
"- 0\n"
"- 1000000000000000000\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/other.rst:76
msgid ""
"Parse and execute an arbitrary chunk of Lua code. This function is mainly useful "
"to define and run Lua code without having to introduce changes to the global Lua "
"environment."
msgstr ""

#: ../doc/1.7/reference/reference_lua/other.rst:80
msgid "Lua code"
msgstr ""

#: ../doc/1.7/reference/reference_lua/other.rst:81
msgid ""
"zero or more scalar values which will be appended to, or substitute for, items "
"in the Lua chunk."
msgstr ""

#: ../doc/1.7/reference/reference_lua/other.rst:84
msgid "whatever is returned by the Lua code chunk."
msgstr ""

#: ../doc/1.7/reference/reference_lua/other.rst:86
msgid ""
"Possible errors: If there is a compilation error, it is raised as a Lua error."
msgstr ""

#: ../doc/1.7/reference/reference_lua/other.rst:91
msgid ""
"tarantool> dostring('abc')\n"
"---\n"
"error: '[string \"abc\"]:1: ''='' expected near ''<eof>'''\n"
"...\n"
"tarantool> dostring('return 1')\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> dostring('return ...', 'hello', 'world')\n"
"---\n"
"- hello\n"
"- world\n"
"...\n"
"tarantool> dostring([[\n"
"         >   local f = function(key)\n"
"         >     local t = box.space.tester:select{key}\n"
"         >     if t ~= nil then\n"
"         >       return t[1]\n"
"         >     else\n"
"         >       return nil\n"
"         >     end\n"
"         >   end\n"
"         >   return f(...)]], 1)\n"
"---\n"
"- null\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:37
msgid "Module `pickle`"
msgstr "Модуль `pickle`"

#: ../doc/1.7/reference/reference_lua/pickle.rst:43
msgid ""
"To use Tarantool binary protocol primitives from Lua, it's necessary to convert "
"Lua variables to binary format. The ``pickle.pack()`` helper function is "
"prototyped after Perl 'pack_'."
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:49
msgid "**Format specifiers**"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:54
msgid "b, B"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:54
msgid ""
"converts Lua variable to a 1-byte integer, and stores the integer in the "
"resulting string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:57
msgid "s, S"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:57
msgid ""
"converts Lua variable to a 2-byte integer, and stores the integer in the "
"resulting string, low byte first"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:61
msgid "i, I"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:61
msgid ""
"converts Lua variable to a 4-byte integer, and stores the integer in the "
"resulting string, low byte first"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:65
msgid "l, L"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:65
msgid ""
"converts Lua variable to an 8-byte integer, and stores the integer in the "
"resulting string, low byte first"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:69
msgid "n"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:69
msgid ""
"converts Lua variable to a 2-byte integer, and stores the integer in the "
"resulting string, big endian,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:73
msgid "N"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:73
msgid ""
"converts Lua variable to a 4-byte integer, and stores the integer in the "
"resulting string, big"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:76
msgid "q, Q"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:76
msgid ""
"converts Lua variable to an 8-byte integer, and stores the integer in the "
"resulting string, big endian,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:80
msgid "f"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:80
msgid ""
"converts Lua variable to a 4-byte float, and stores the float in the resulting "
"string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:83
msgid "d"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:83
msgid ""
"converts Lua variable to a 8-byte double, and stores the double in the resulting "
"string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:86
msgid "a, A"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:86
msgid ""
"converts Lua variable to a sequence of bytes, and stores the sequence in the "
"resulting string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:90
msgid "string containing format specifiers"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:91
msgid "scalar values to be formatted"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:92
msgid ""
"a binary string containing all arguments, packed according to the format "
"specifiers."
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:96
msgid "Possible errors: unknown format specifier."
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:100
msgid ""
"tarantool> pickle = require('pickle')\n"
"---\n"
"...\n"
"tarantool> box.space.tester:insert{0, 'hello world'}\n"
"---\n"
"- [0, 'hello world']\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'=', 2, 'bye world'}})\n"
"---\n"
"- [0, 'bye world']\n"
"...\n"
"tarantool> box.space.tester:update({0}, {\n"
"         >   {'=', 2, pickle.pack('iiA', 0, 3, 'hello')}\n"
"         > })\n"
"---\n"
"- [0, \"\\0\\0\\0\\0\\x03\\0\\0\\0hello\"]\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'=', 2, 4}})\n"
"---\n"
"- [0, 4]\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'+', 2, 4}})\n"
"---\n"
"- [0, 8]\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'^', 2, 4}})\n"
"---\n"
"- [0, 12]\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:134
msgid ""
"Counterpart to ``pickle.pack()``. Warning: if format specifier 'A' is used, it "
"must be the last item."
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:140
msgid "A list of strings or numbers."
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:145
msgid ""
"tarantool> pickle = require('pickle')\n"
"---\n"
"...\n"
"tarantool> tuple = box.space.tester:replace{0}\n"
"---\n"
"...\n"
"tarantool> string.len(tuple[1])\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> pickle.unpack('b', tuple[1])\n"
"---\n"
"- 48\n"
"...\n"
"tarantool> pickle.unpack('bsi', pickle.pack('bsi', 255, 65535, 4294967295))\n"
"---\n"
"- 255\n"
"- 65535\n"
"- 4294967295\n"
"...\n"
"tarantool> pickle.unpack('ls', pickle.pack('ls', "
"tonumber64('18446744073709551615'), 65535))\n"
"---\n"
"...\n"
"tarantool> num, num64, str = pickle.unpack('slA', pickle.pack('slA', 666,\n"
"         > tonumber64('666666666666666'), 'string'))\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:39
msgid "Module `socket`"
msgstr "Модуль `socket`"

#: ../doc/1.7/reference/reference_lua/socket.rst:41
msgid ""
"The ``socket`` module allows exchanging data via BSD sockets with a local or "
"remote host in connection-oriented (TCP) or datagram-oriented (UDP) mode. "
"Semantics of the calls in the ``socket`` API closely follow semantics of the "
"corresponding POSIX calls. Function names and signatures are mostly compatible "
"with `luasocket`_."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:47
msgid ""
"The functions for setting up and connecting are ``socket``, ``sysconnect``, "
"``tcp_connect``. The functions for sending data are ``send``, ``sendto``, "
"``write``, ``syswrite``. The functions for receiving data are ``recv``, "
"``recvfrom``, ``read``. The functions for waiting before sending/receiving data "
"are ``wait``, ``readable``, ``writable``. The functions for setting flags are "
"``nonblock``, ``setsockopt``. The functions for stopping and disconnecting are "
"``shutdown``, ``close``. The functions for error checking are ``errno``, "
"``error``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:58
msgid "**Socket functions**"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:63
msgid "Purposes"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:63
msgid "Names"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:65
msgid "setup"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:65
msgid ":ref:`socket() <socket-socket>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:67
#: ../doc/1.7/reference/reference_lua/socket.rst:69
#: ../doc/1.7/reference/reference_lua/socket.rst:71
#: ../doc/1.7/reference/reference_lua/socket.rst:73
#: ../doc/1.7/reference/reference_lua/socket.rst:77
#: ../doc/1.7/reference/reference_lua/socket.rst:79
#: ../doc/1.7/reference/reference_lua/socket.rst:83
#: ../doc/1.7/reference/reference_lua/socket.rst:85
#: ../doc/1.7/reference/reference_lua/socket.rst:89
#: ../doc/1.7/reference/reference_lua/socket.rst:91
#: ../doc/1.7/reference/reference_lua/socket.rst:95
#: ../doc/1.7/reference/reference_lua/socket.rst:99
#: ../doc/1.7/reference/reference_lua/socket.rst:103
#: ../doc/1.7/reference/reference_lua/socket.rst:107
#: ../doc/1.7/reference/reference_lua/socket.rst:109
#: ../doc/1.7/reference/reference_lua/socket.rst:111
#: ../doc/1.7/reference/reference_lua/socket.rst:115
#: ../doc/1.7/reference/reference_lua/socket.rst:117
#: ../doc/1.7/reference/reference_lua/socket.rst:119
msgid "\"\""
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:67
msgid ":ref:`socket.tcp_connect() <socket-tcp_connect>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:69
msgid ":ref:`socket.tcp_server() <socket-tcp_server>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:71
msgid ":ref:`socket_object:sysconnect() <socket-sysconnect>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:73
msgid ":ref:`socket_object:send() <socket-send>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:75
msgid "sending"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:75
msgid ":ref:`socket_object:sendto() <socket-sendto>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:77
msgid ":ref:`socket_object:write() <socket-send>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:79
msgid ":ref:`socket_object:syswrite() <socket-syswrite>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:81
msgid "receiving"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:81
msgid ":ref:`socket_object:recv() <socket-recv>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:83
msgid ":ref:`socket_object:recvfrom() <socket-recvfrom>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:85
msgid ":ref:`socket_object:read() <socket-read>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:87
msgid "flag setting"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:87
msgid ":ref:`socket_object:nonblock() <socket-nonblock>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:89
msgid ":ref:`socket_object:setsockopt() <socket-setsockopt>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:91
msgid ":ref:`socket_object:linger() <socket-linger>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:93
msgid "client/server"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:93
msgid ":ref:`socket_object:listen() <socket-listen>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:95
msgid ":ref:`socket_object:accept() <socket-accept>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:97
msgid "teardown"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:97
msgid ":ref:`socket_object:shutdown() <socket-shutdown>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:99
msgid ":ref:`socket_object:close() <socket-close>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:101
msgid "error checking"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:101
msgid ":ref:`socket_object:error() <socket-error>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:103
msgid ":ref:`socket_object:errno() <socket-error>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:105
msgid "information"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:105
msgid ":ref:`socket.getaddrinfo() <socket-getaddrinfo>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:107
msgid ":ref:`socket_object:getsockopt() <socket-getsockopt>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:109
msgid ":ref:`socket_object:peer() <socket-peer>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:111
msgid ":ref:`socket_object:name() <socket-name>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:113
msgid "state checking"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:113
msgid ":ref:`socket_object:readable() <socket-readable>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:115
msgid ":ref:`socket_object:writable() <socket-writable>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:117
msgid ":ref:`socket_object:wait() <socket-wait>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:119
msgid ":ref:`socket.iowait() <socket-iowait>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:123
msgid ""
"Typically a socket session will begin with the setup functions, will set one or "
"more flags, will have a loop with sending and receiving functions, will end with "
"the teardown functions -- as an example at the end of this section will show. "
"Throughout, there may be error-checking and waiting functions for "
"synchronization. To prevent a fiber containing socket functions from \"blocking"
"\" other fibers, the :ref:`implicit yield rules <atomic-implicit-yields>` will "
"cause a yield so that other processes may take over, as is the norm for :ref:"
"`cooperative multitasking <atomic-cooperative_multitasking>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:132
msgid ""
"For all examples in this section the socket name will be sock and the function "
"invocations will look like ``sock:function_name(...)``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:141
msgid ""
"Create a new TCP or UDP socket. The argument values are the same as in the "
"`Linux socket(2) man page <http://man7.org/linux/man-pages/man2/socket.2.html>`_."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:144
msgid "an unconnected socket, or nil."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:149
msgid "socket('AF_INET', 'SOCK_STREAM', 'tcp')"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:157
msgid "Connect a socket to a remote host."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:159
msgid "URL or IP address"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:160
msgid "port number"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:161
msgid "timeout"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:162
msgid "a connected socket, if no error."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:167
msgid "socket.tcp_connect('127.0.0.1', 3301)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:175
msgid ""
"The ``socket.getaddrinfo()`` function is useful for finding information about a "
"remote site so that the correct arguments for ``sock:sysconnect()`` can be "
"passed. This function may use the :ref:`worker_pool_threads <cfg_basic-"
"worker_pool_threads>` configuration parameter."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:181
#: ../doc/1.7/reference/reference_lua/socket.rst:555
#: ../doc/1.7/reference/reference_lua/socket.rst:567
msgid ""
"A table containing these fields: \"host\", \"family\", \"type\", \"protocol\", "
"\"port\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:186
msgid ""
"``socket.getaddrinfo('tarantool.org', 'http')`` will return variable information "
"such as"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:189
msgid ""
"---\n"
"- - host: 188.93.56.70\n"
"    family: AF_INET\n"
"    type: SOCK_STREAM\n"
"    protocol: tcp\n"
"    port: 80\n"
"  - host: 188.93.56.70\n"
"    family: AF_INET\n"
"    type: SOCK_DGRAM\n"
"    protocol: udp\n"
"    port: 80\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:208
msgid ""
"The ``socket.tcp_server()`` function makes Tarantool act as a server that can "
"accept connections. Usually the same objective is accomplished with :ref:`box."
"cfg{listen=...} <cfg_basic-listen>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:212
msgid "host name or IP"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:213
msgid "host port, may be 0"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:214
msgid "what to execute when a connection occurs"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:216
msgid "number of seconds to wait before timing out"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:219
msgid ""
"The handler-function parameter may be a function name (for example "
"``function_55``), a function declaration (for example ``function () print('!') "
"end``), or a table including handler = function (for example "
"``{handler=function_55, name='A'}``)."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:224
msgid "Example:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:226
msgid "``socket.tcp_server('localhost', 3302, function () end)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:234
msgid ""
"Connect an existing socket to a remote host. The argument values are the same as "
"in :ref:`tcp_connect() <socket-tcp_connect>`. The host must be an IP address."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:251
msgid "Parameters:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:241
msgid "Either:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:240
msgid "host - a string representation of an IPv4 address or an IPv6 address;"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:242
msgid "port - a number."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:244
#: ../doc/1.7/reference/reference_lua/socket.rst:251
msgid "Or:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:244
msgid "host - a string containing \"unix/\";"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:245
msgid "port - a string containing a path to a unix socket."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:247
msgid "host - a number, 0 (zero), meaning \"all local interfaces\";"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:249
msgid ""
"port - a number. If a port number is 0 (zero), the socket will be bound to a "
"random local port."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:253
msgid "the socket object value may change if sysconnect() succeeds."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:258
msgid ""
"socket = require('socket')\n"
"sock = socket('AF_INET', 'SOCK_STREAM', 'tcp')\n"
"sock:sysconnect(0, 3301)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:269
msgid "Send data over a connected socket."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:272
#: ../doc/1.7/reference/reference_lua/socket.rst:395
msgid "the number of bytes sent."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:275
msgid "Possible errors: nil on error."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:281
msgid ""
"Write as much data as possible to the socket buffer if non-blocking. Rarely "
"used. For details see `this description`_."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:288
msgid ""
"Read ``size`` bytes from a connected socket. An internal read-ahead buffer is "
"used to reduce the cost of this call."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:292
msgid "a string of the requested length on success."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:295
msgid ""
"Possible errors: On error, returns an empty string, followed by status, errno, "
"errstr. In case the writing side has closed its end, returns the remainder read "
"from the socket (possibly an empty string), followed by \"eof\" status."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:308
msgid ""
"Read from a connected socket until some condition is true, and return the bytes "
"that were read. Reading goes on until ``limit`` bytes have been read, or a "
"delimiter has been read, or a timeout has expired."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:313
#: ../doc/1.7/reference/reference_lua/socket.rst:335
msgid ""
"maximum number of bytes to read, for example 50 means \"stop after 50 bytes\""
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:315
msgid "separator for example '?' means \"stop after a question mark\""
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:317
msgid ""
"maximum number of seconds to wait for example 50 means \"stop after 50 seconds\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:320
msgid ""
"an empty string if there is nothing more to read, or a nil value if error, or a "
"string up to ``limit`` bytes long, which may include the bytes that matched the "
"``delimiter`` expression."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:330
msgid ""
"Return data from the socket buffer if non-blocking. In case the socket is "
"blocking, ``sysread()`` can block the calling process. Rarely used. For details, "
"see also `this description <https://github.com/tarantool/tarantool/wiki/sockets"
"%201.6>`_."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:338
msgid ""
"an empty string if there is nothing more to read, or a nil value if error, or a "
"string up to ``size`` bytes long."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:346
msgid ""
"Bind a socket to the given host/port. A UDP socket after binding can be used to "
"receive data (see :ref:`socket_object.recvfrom <socket-recvfrom>`). A TCP socket "
"can be used to accept new connections, after it has been put in listen mode."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:354
msgid "a socket object on success"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:357
msgid "Possible errors: Returns nil, status, errno, errstr on error."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:363
msgid "Start listening for incoming connections."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:365
msgid ""
"On Linux the listen ``backlog`` backlog may be from /proc/sys/net/core/"
"somaxconn, on BSD the backlog may be ``SOMAXCONN``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:369
msgid "true for success, false for error."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:370
msgid "boolean."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:376
msgid ""
"Accept a new client connection and create a new connected socket. It is good "
"practice to set the socket's blocking mode explicitly after accepting."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:380
msgid "new socket if success."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:389
msgid "Send a message on a UDP socket to a specified host."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:398
#: ../doc/1.7/reference/reference_lua/socket.rst:410
msgid "Possible errors: on error, returns status, errno, errstr."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:404
msgid "Receive a message on a UDP socket."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:407
msgid "message, a table containing \"host\", \"family\" and \"port\" fields."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:408
msgid "string, table"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:414
msgid ""
"After ``message_content, message_sender = recvfrom(1)`` the value of "
"``message_content`` might be a string containing 'X' and the value of "
"``message_sender`` might be a table containing"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:418
msgid ""
"message_sender.host = '18.44.0.1'\n"
"message_sender.family = 'AF_INET'\n"
"message_sender.port = 43065"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:428
msgid "Shutdown a reading end, a writing end, or both ends of a socket."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:430
msgid "socket.SHUT_RD, socket.SHUT_WR, or socket.SHUT_RDWR."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:432
#: ../doc/1.7/reference/reference_lua/tap.rst:100
#: ../doc/1.7/reference/reference_lua/tap.rst:132
#: ../doc/1.7/reference/reference_lua/tap.rst:163
#: ../doc/1.7/reference/reference_lua/tap.rst:174
#: ../doc/1.7/reference/reference_lua/tap.rst:191
#: ../doc/1.7/reference/reference_lua/tap.rst:199
msgid "true or false."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:439
msgid ""
"Close (destroy) a socket. A closed socket should not be used any more. A socket "
"is closed automatically when its userdata is garbage collected by Lua."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:442
msgid ""
"true on success, false on error. For example, if sock is already closed, sock:"
"close() returns false."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:451
msgid ""
"Retrieve information about the last error that occurred on a socket, if any. "
"Errors do not cause throwing of exceptions so these functions are usually "
"necessary."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:454
msgid ""
"result for ``sock:errno()``, result for ``sock:error()``. If there is no error, "
"then ``sock:errno()`` will return 0 and ``sock:error()``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:456
msgid "number, string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:462
msgid ""
"Set socket flags. The argument values are the same as in the `Linux "
"getsockopt(2) man page <http://man7.org/linux/man-pages/man2/setsockopt.2."
"html>`_. The ones that Tarantool accepts are:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:466
msgid "SO_ACCEPTCONN"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:467
msgid "SO_BINDTODEVICE"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:468
msgid "SO_BROADCAST"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:469
msgid "SO_DEBUG"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:470
msgid "SO_DOMAIN"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:471
msgid "SO_ERROR"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:472
msgid "SO_DONTROUTE"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:473
msgid "SO_KEEPALIVE"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:474
msgid "SO_MARK"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:475
msgid "SO_OOBINLINE"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:476
msgid "SO_PASSCRED"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:477
msgid "SO_PEERCRED"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:478
msgid "SO_PRIORITY"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:479
msgid "SO_PROTOCOL"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:480
msgid "SO_RCVBUF"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:481
msgid "SO_RCVBUFFORCE"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:482
msgid "SO_RCVLOWAT"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:483
msgid "SO_SNDLOWAT"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:484
msgid "SO_RCVTIMEO"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:485
msgid "SO_SNDTIMEO"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:486
msgid "SO_REUSEADDR"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:487
msgid "SO_SNDBUF"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:488
msgid "SO_SNDBUFFORCE"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:489
msgid "SO_TIMESTAMP"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:490
msgid "SO_TYPE"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:492
msgid "Setting SO_LINGER is done with ``sock:linger(active)``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:498
msgid "Get socket flags. For a list of possible flags see ``sock:setsockopt()``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:504
msgid ""
"Set or clear the SO_LINGER flag. For a description of the flag, see the `Linux "
"man page <http://man7.org/linux/man-pages/man1/loginctl.1.html>`_."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:509
msgid "new active and timeout values."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:515
msgid "``sock:nonblock()`` returns the current flag value."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:516
msgid "``sock:nonblock(false)`` sets the flag to false and returns false."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:517
msgid "``sock:nonblock(true)`` sets the flag to true and returns true."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:519
msgid ""
"This function may be useful before invoking a function which might otherwise "
"block indefinitely."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:526
msgid "Wait until something is readable, or until a timeout value expires."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:528
msgid "true if the socket is now readable, false if timeout expired;"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:534
msgid "Wait until something is writable, or until a timeout value expires."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:536
msgid "true if the socket is now writable, false if timeout expired;"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:542
msgid ""
"Wait until something is either readable or writable, or until a timeout value "
"expires."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:544
msgid ""
"'R' if the socket is now readable, 'W' if the socket is now writable, 'RW' if "
"the socket is now both readable and writable, '' (empty string) if timeout "
"expired;"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:550
msgid ""
"The ``sock:name()`` function is used to get information about the near side of "
"the connection. If a socket was bound to ``xyz.com:45``, then ``sock:name`` will "
"return information about ``[host:xyz.com, port:45]``. The equivalent POSIX "
"function is ``getsockname()``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:562
msgid ""
"The ``sock:peer()`` function is used to get information about the far side of a "
"connection. If a TCP connection has been made to a distant host ``tarantool."
"org:80``, ``sock:peer()`` will return information about ``[host:tarantool.org, "
"port:80]``. The equivalent POSIX function is ``getpeername()``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:574
msgid ""
"The ``socket.iowait()`` function is used to wait until read-or-write activity "
"occurs for a file descriptor."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:577
msgid "file descriptor"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:578
msgid "'R' or 1 = read, 'W' or 2 = write, 'RW' or 3 = read|write."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:579
msgid "number of seconds to wait"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:581
msgid ""
"If the fd parameter is nil, then there will be a sleep until the timeout. If the "
"timeout parameter is nil or unspecified, then timeout is infinite."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:584
msgid ""
"Ordinarily the return value is the activity that occurred ('R' or 'W' or 'RW' or "
"1 or 2 or 3). If the timeout period goes by without any reading or writing, the "
"return is an error = ETIMEDOUT."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:588
msgid "Example: ``socket.iowait(sock:fd(), 'r', 1.11)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:596
msgid "Use of a TCP socket over the Internet"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:598
msgid ""
"In this example a connection is made over the internet between a Tarantool "
"instance and tarantool.org, then an HTTP \"head\" message is sent, and a "
"response is received: \"``HTTP/1.1 200 OK``\" or something else if the site has "
"moved. This is not a useful way to communicate with this particular site, but "
"shows that the system works."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:604
msgid ""
"tarantool> socket = require('socket')\n"
"---\n"
"...\n"
"tarantool> sock = socket.tcp_connect('tarantool.org', 80)\n"
"---\n"
"...\n"
"tarantool> type(sock)\n"
"---\n"
"- table\n"
"...\n"
"tarantool> sock:error()\n"
"---\n"
"- null\n"
"...\n"
"tarantool> sock:send(\"HEAD / HTTP/1.0\\r\\nHost: tarantool.org\\r\\n\\r\\n\")\n"
"---\n"
"- 40\n"
"...\n"
"tarantool> sock:read(17)\n"
"---\n"
"- HTTP/1.1 302 Move\n"
"...\n"
"tarantool> sock:close()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:635
msgid "Use of a UDP socket on localhost"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:637
msgid ""
"Here is an example with datagrams. Set up two connections on 127.0.0.1 "
"(localhost): ``sock_1`` and ``sock_2``. Using ``sock_2``, send a message to "
"``sock_1``. Using ``sock_1``, receive a message. Display the received message. "
"Close both connections. |br| This is not a useful way for a computer to "
"communicate with itself, but shows that the system works."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:643
msgid ""
"tarantool> socket = require('socket')\n"
"---\n"
"...\n"
"tarantool> sock_1 = socket('AF_INET', 'SOCK_DGRAM', 'udp')\n"
"---\n"
"...\n"
"tarantool> sock_1:bind('127.0.0.1')\n"
"---\n"
"- true\n"
"...\n"
"tarantool> sock_2 = socket('AF_INET', 'SOCK_DGRAM', 'udp')\n"
"---\n"
"...\n"
"tarantool> sock_2:sendto('127.0.0.1', sock_1:name().port,'X')\n"
"---\n"
"- true\n"
"...\n"
"tarantool> message = sock_1:recvfrom()\n"
"---\n"
"...\n"
"tarantool> message\n"
"---\n"
"- X\n"
"...\n"
"tarantool> sock_1:close()\n"
"---\n"
"- true\n"
"...\n"
"tarantool> sock_2:close()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:680
msgid "Use tcp_server to accept file contents sent with socat"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:682
msgid ""
"Here is an example of the tcp_server function, reading strings from the client "
"and printing them. On the client side, the Linux socat utility will be used to "
"ship a whole file for the tcp_server function to read."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:687
msgid ""
"Start two shells. The first shell will be a server instance. The second shell "
"will be the client."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:690
msgid "On the first shell, start Tarantool and say:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:692
msgid ""
"box.cfg{}\n"
"socket = require('socket')\n"
"socket.tcp_server('0.0.0.0', 3302, function(s)\n"
"    while true do\n"
"      local request\n"
"      request = s:read(\"\\n\");\n"
"      if request == \"\" or request == nil then\n"
"        break\n"
"      end\n"
"      print(request)\n"
"    end\n"
"  end)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:707
msgid ""
"The above code means: use `tcp_server()` to wait for a connection from any host "
"on port 3302. When it happens, enter a loop that reads on the socket and prints "
"what it reads. The \"delimiter\" for the read function is \"\\\\n\" so each "
"`read()` will read a string as far as the next line feed, including the line "
"feed."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:714
msgid ""
"On the second shell, create a file that contains a few lines. The contents don't "
"matter. Suppose the first line contains A, the second line contains B, the third "
"line contains C. Call this file \"tmp.txt\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:719
msgid ""
"On the second shell, use the socat utility to ship the tmp.txt file to the "
"server instance's host and port:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:722
msgid "$ socat TCP:localhost:3302 ./tmp.txt"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:726
msgid ""
"Now watch what happens on the first shell. The strings \"A\", \"B\", \"C\" are "
"printed."
msgstr ""

#: ../doc/1.7/reference/reference_lua/strict.rst:39
msgid "Module `strict`"
msgstr "Модуль `strict`"

#: ../doc/1.7/reference/reference_lua/strict.rst:43
msgid ""
"The :code:`strict` module has functions for turning \"strict mode\" on or off. "
"When strict mode is on, an attempt to use an undeclared global variable will "
"cause an error. A global variable is considered \"undeclared\" if it has never "
"had a value assigned to it. Often this is an indication of a programming error."
msgstr ""

#: ../doc/1.7/reference/reference_lua/strict.rst:48
msgid ""
"By default strict mode is off, unless tarantool was built with the ``-"
"DCMAKE_BUILD_TYPE=Debug`` option -- see the description of build options in "
"section :ref:`building-from-source <building_from_source>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/strict.rst:54
msgid ""
"tarantool> strict = require('strict')\n"
"---\n"
"...\n"
"tarantool> strict.on()\n"
"---\n"
"...\n"
"tarantool> a = b -- strict mode is on so this will cause an error\n"
"---\n"
"- error: ... variable ''b'' is not declared'\n"
"...\n"
"tarantool> strict.off()\n"
"---\n"
"...\n"
"tarantool> a = b -- strict mode is off so this will not cause an error\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:39
#, fuzzy
msgid "Module `string`"
msgstr "Модуль `strict`"

#: ../doc/1.7/reference/reference_lua/string.rst:43
msgid ""
"The :code:`string` module has everything in the `standard Lua string library "
"<https://www.lua.org/pil/20.html>`_, and some Tarantool extensions."
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:47
msgid ""
"In this section we only discuss the additional functions that the Tarantool "
"developers have added:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:50
msgid "``ljust``, ``rjust`` and ``center`` for left/right/center-justifying,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:51
msgid "``hex`` for hexadecimal,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:52
msgid "``startswidth`` and ``endswith`` for checking start/end values,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:53
msgid "``split`` for splitting."
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:59
msgid "Return the string left-justified in a string of length ``width``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:61
msgid "(string) the string to left-justify"
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:62
msgid "(integer) the width of the string after left-justifying"
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:63
#: ../doc/1.7/reference/reference_lua/string.rst:88
msgid "(string) a single character, default = 1 space"
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:65
msgid "left-justified string (unchanged if width <= string length)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:70
msgid ""
"tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.ljust(' A', 5)\n"
"---\n"
"- ' A   '\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:84
msgid "Return the string right-justified in a string of length ``width``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:86
msgid "(string) the string to right-justify"
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:87
msgid "(integer) the width of the string after right-justifying"
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:90
msgid "right-justified string (unchanged if width <= string length)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:95
msgid ""
"tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.rjust('', 5, 'X')\n"
"---\n"
"- 'XXXXX'\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:109
msgid "Return the hexadecimal value of the input string."
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:111
msgid "(string) the string to process"
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:113
msgid "hexadecimal, 2 hex-digit characters for each input character"
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:118
msgid ""
"tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.hex('ABC ')\n"
"---\n"
"- '41424320'\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:132
msgid ""
"Return True if ``input-string`` starts with ``start-string``, otherwise return "
"False."
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:135
msgid "(string) the string where ``start-string`` should be looked for"
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:136
#: ../doc/1.7/reference/reference_lua/string.rst:166
msgid "(string) the string to look for"
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:137
#: ../doc/1.7/reference/reference_lua/string.rst:167
msgid "(integer) position: where to start looking within ``input-string``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:138
#: ../doc/1.7/reference/reference_lua/string.rst:168
msgid "(integer) position: where to end looking within ``input-string``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:143
#: ../doc/1.7/reference/reference_lua/string.rst:173
msgid ""
"``start-pos`` and ``end-pos`` may be negative, meaning the position should be "
"calculated from the end of the string."
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:148
msgid ""
"tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.startswith(' A', 'A', 2, 5)\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:162
msgid ""
"Return True if ``input-string`` ends with ``end-string``, otherwise return False."
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:165
msgid "(string) the string where ``end-string`` should be looked for"
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:178
msgid ""
"tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.endswith('Baa', 'aa')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:192
msgid ""
"Split ``input-string`` into one or more output strings in a table. The places to "
"split are the places where ``split-string`` occurs."
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:196
msgid "(string) the string to split"
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:197
msgid "(string) the string to find within ``input-string``. Default = space."
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:200
msgid "table of strings that were split from ``input-string``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:205
msgid ""
"tarantool> fiber = require('string')\n"
"---\n"
"...\n"
"tarantool> string.split(\"A*BXX C\", \"XX\")\n"
"---\n"
"- - A*B\n"
"  - ' C'\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:37
msgid "Module `tap`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:39
msgid ""
"The tap module streamlines the testing of other modules. It allows writing of "
"tests in the `TAP protocol`_. The results from the tests can be parsed by "
"standard TAP-analyzers so they can be passed to utilities such as `prove`_. Thus "
"one can run tests and then use the results for statistics, decision-making, and "
"so on."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:49
msgid "Initialize."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:51
msgid ""
"The result of ``tap.test`` is an object, which will be called taptest in the "
"rest of this discussion, which is necessary for ``taptest:plan()`` and all the "
"other methods."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:55
msgid "an arbitrary name to give for the test outputs."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:56
msgid "taptest"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:59
msgid ""
"tap = require('tap')\n"
"taptest = tap.test('test-name')"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:68
msgid "Indicate how many tests will be performed."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:75
msgid ""
"Checks the number of tests performed. This check should only be done after all "
"planned tests are complete, so ordinarily ``taptest:check()`` will only appear "
"at the end of a script."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:79
msgid ""
"Will display ``# bad plan: ...`` if the number of completed tests is not equal "
"to the number of tests specified by ``taptest:plan(...)``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:86
msgid "Display a diagnostic message."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:88
msgid "the message to be displayed."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:93
msgid ""
"This is a basic function which is used by other functions. Depending on the "
"value of ``condition``, print 'ok' or 'not ok' along with debugging information. "
"Displays the message."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:97
msgid "an expression which is true or false"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:98
#: ../doc/1.7/reference/reference_lua/tap.rst:130
#: ../doc/1.7/reference/reference_lua/tap.rst:141
#: ../doc/1.7/reference/reference_lua/tap.rst:162
#: ../doc/1.7/reference/reference_lua/tap.rst:172
#: ../doc/1.7/reference/reference_lua/tap.rst:189
#: ../doc/1.7/reference/reference_lua/tap.rst:204
msgid "name of test"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:105
msgid ""
"tarantool> taptest:ok(true, 'x')\n"
"ok - x\n"
"---\n"
"- true\n"
"...\n"
"tarantool> tap = require('tap')\n"
"---\n"
"...\n"
"tarantool> taptest = tap.test('test-name')\n"
"TAP version 13\n"
"---\n"
"...\n"
"tarantool> taptest:ok(1 + 1 == 2, 'X')\n"
"ok - X\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:127
msgid ""
"``taptest:fail('x')`` is equivalent to ``taptest:ok(false, 'x')``. Displays the "
"message."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:137
msgid ""
"``taptest:skip('x')`` is equivalent to ``taptest:ok(true, 'x' .. '# skip')``. "
"Displays the message."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:147
msgid ""
"tarantool> taptest:skip('message')\n"
"ok - message # skip\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:157
msgid ""
"Check whether the first argument equals the second argument. Displays extensive "
"message if the result is false."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:160
#: ../doc/1.7/reference/reference_lua/tap.rst:170
#: ../doc/1.7/reference/reference_lua/tap.rst:202
msgid "actual result"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:161
#: ../doc/1.7/reference/reference_lua/tap.rst:171
#: ../doc/1.7/reference/reference_lua/tap.rst:203
msgid "expected result"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:168
msgid "This is the negation of ``taptest:is(...)``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:185
msgid ""
"Test whether a value has a particular type. Displays a long message if the value "
"is not of the specified type."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:196
msgid ""
"Recursive version of ``taptest:is(...)``, which can be be used to compare tables "
"as well as scalar values."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:214
msgid ""
"To run this example: put the script in a file named ./tap.lua, then make tap.lua "
"executable by saying ``chmod a+x ./tap.lua``, then execute using Tarantool as a "
"script processor by saying ./tap.lua."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:218
msgid ""
"#!/usr/bin/tarantool\n"
"local tap = require('tap')\n"
"test = tap.test(\"my test name\")\n"
"test:plan(2)\n"
"test:ok(2 * 2 == 4, \"2 * 2 is 4\")\n"
"test:test(\"some subtests for test2\", function(test)\n"
"    test:plan(2)\n"
"    test:is(2 + 2, 4, \"2 + 2 is 4\")\n"
"    test:isnt(2 + 3, 4, \"2 + 3 is not 4\")\n"
"end)\n"
"test:check()"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:232
msgid "The output from the above script will look approximately like this:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:234
msgid ""
"TAP version 13\n"
"1..2\n"
"ok - 2 * 2 is 4\n"
"    # Some subtests for test2\n"
"    1..2\n"
"    ok - 2 + 2 is 4,\n"
"    ok - 2 + 3 is not 4\n"
"    # Some subtests for test2: end\n"
"ok - some subtests for test2"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tarantool.rst:39
msgid "Module `tarantool`"
msgstr "Модуль `tarantool`"

#: ../doc/1.7/reference/reference_lua/tarantool.rst:43
msgid ""
"By saying ``require('tarantool')``, one can answer some questions about how the "
"tarantool server was built, such as \"what flags were used\", or \"what was the "
"version of the compiler\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tarantool.rst:49
msgid ""
"Additionally one can see the uptime and the server version and the process id. "
"Those information items can also be accessed with :ref:`box.info() "
"<box_introspection-box_info>` but use of the tarantool module is recommended."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tarantool.rst:56
msgid ""
"tarantool> tarantool = require('tarantool')\n"
"---\n"
"...\n"
"tarantool> tarantool\n"
"---\n"
"- build:\n"
"    target: Linux-x86_64-RelWithDebInfo\n"
"    options: cmake . -DCMAKE_INSTALL_PREFIX=/usr -DENABLE_BACKTRACE=ON\n"
"    mod_format: so\n"
"    flags: ' -fno-common -fno-omit-frame-pointer -fno-stack-protector -"
"fexceptions\n"
"      -funwind-tables -fopenmp -msse2 -std=c11 -Wall -Wextra -Wno-sign-compare -"
"Wno-strict-aliasing\n"
"      -fno-gnu89-inline'\n"
"    compiler: /usr/bin/x86_64-linux-gnu-gcc /usr/bin/x86_64-linux-gnu-g++\n"
"  uptime: 'function: 0x408668e0'\n"
"  version: 1.7.0-66-g9093daa\n"
"  pid: 'function: 0x40866900'\n"
"...\n"
"tarantool> tarantool.pid()\n"
"---\n"
"- 30155\n"
"...\n"
"tarantool> tarantool.uptime()\n"
"---\n"
"- 108.64641499519\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/uri.rst:37
#, fuzzy
msgid "Module `uri`"
msgstr "Модуль `strict`"

#: ../doc/1.7/reference/reference_lua/uri.rst:39
msgid ""
"A \"URI\" is a \"Uniform Resource Identifier\". The `IETF standard <https://www."
"ietf.org/rfc/rfc2396.txt>`_ says a URI string looks like this: |br| "
"[scheme:]scheme-specific-part[#fragment] |br| A common type, a hierarchical URI, "
"looks like this: |br| [scheme:][//authority][path][?query][#fragment] |br| For "
"example the string `'https://tarantool.org/x.html#y'` has three components: "
"https is the scheme, tarantool.org/x.html is the path, and y is the fragment. "
"Tarantool's URI module provides routines which convert URI strings into their "
"components, or turn components into URI strings."
msgstr ""

#: ../doc/1.7/reference/reference_lua/uri.rst:57
msgid "a Uniform Resource Identifier"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uri.rst
#: ../doc/1.7/reference/reference_lua/xlog.rst
msgid "returns"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uri.rst:58
msgid ""
"URI-components-table. Possible components are fragment, host, login, password, "
"path, query, scheme, service."
msgstr ""

#: ../doc/1.7/reference/reference_lua/uri.rst:59
#, fuzzy
msgid "Table"
msgstr "Lua table"

#: ../doc/1.7/reference/reference_lua/uri.rst:63
msgid ""
"tarantool> uri = require('uri')\n"
"---\n"
"...\n"
"\n"
"tarantool> uri.parse('http://x.html#y')\n"
"---\n"
"- host: x.html\n"
"  scheme: http\n"
"  fragment: y\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/uri.rst:80
msgid "a series of name:value pairs, one for each component"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uri.rst:81
msgid "URI-string. Thus uri.format() is the reverse of uri.parse()."
msgstr ""

#: ../doc/1.7/reference/reference_lua/uri.rst:86
msgid ""
"tarantool> uri.format({host = 'x.html', scheme = 'http', fragment = 'y'})\n"
"---\n"
"- http://x.html#y\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:37
msgid "Module `uuid`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:39
msgid ""
"A \"UUID\" is a `Universally unique identifier`_. If an application requires "
"that a value be unique only within a single computer or on a single database, "
"then a simple counter is better than a UUID, because getting a UUID is time-"
"consuming (it requires a syscall_). For clusters of computers, or widely "
"distributed applications, UUIDs are better."
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:45
msgid "The functions that can return a UUID are:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:47
msgid ":ref:`uuid() <uuid-__call>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:48
msgid ":ref:`uuid.bin() <uuid-bin>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:49
msgid ":ref:`uuid.str() <uuid-str>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:51
msgid "The functions that can convert between different types of UUID are:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:53
msgid ":ref:`uuid_object:bin() <uuid-object_bin>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:54
msgid ":ref:`uuid_object:str() <uuid-object_str>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:55
msgid ":ref:`uuid.fromstr() <uuid-fromstr>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:56
msgid ":ref:`uuid.frombin() <uuid-frombin>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:58
msgid "The function that can determine whether a UUID is an all-zero value is:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:60
msgid ":ref:`uuid_object:isnil() <uuid-isnil>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:66
msgid "A nil object"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:72
#: ../doc/1.7/reference/reference_lua/uuid.rst:79
#: ../doc/1.7/reference/reference_lua/uuid.rst:86
msgid "a UUID"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:80
msgid "16-byte string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:87
msgid "36-byte binary string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:93
msgid "UUID in 36-byte hexadecimal string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:94
#: ../doc/1.7/reference/reference_lua/uuid.rst:102
msgid "converted UUID"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:101
msgid "UUID in 16-byte binary string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:111
msgid "``byte-order`` can be one of next flags:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:113
msgid "'l' - little-endian,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:114
msgid "'b' - big-endian,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:115
msgid "'h' - endianness depends on host (default),"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:116
msgid "'n' - endianness depends on network"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:118
msgid "one of ``'l'``, ``'b'``, ``'h'`` or ``'n'``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:120
#: ../doc/1.7/reference/reference_lua/uuid.rst:127
msgid "UUID converted from cdata input value."
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:121
msgid "16-byte binary string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:128
msgid "36-byte hexadecimal string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:134
msgid ""
"The all-zero UUID value can be expressed as uuid.NULL, or as ``uuid."
"fromstr('00000000-0000-0000-0000-000000000000')``. The comparison with an all-"
"zero value can also be expressed as ``uuid_with_type_cdata == uuid.NULL``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:139
msgid "true if the value is all zero, otherwise false."
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:146
msgid ""
"tarantool> uuid = require('uuid')\n"
"---\n"
"...\n"
"tarantool> uuid(), uuid.bin(), uuid.str()\n"
"---\n"
"- 16ffedc8-cbae-4f93-a05e-349f3ab70baa\n"
"- !!binary FvG+Vy1MfUC6kIyeM81DYw==\n"
"- 67c999d2-5dce-4e58-be16-ac1bcb93160f\n"
"...\n"
"tarantool> uu = uuid()\n"
"---\n"
"...\n"
"tarantool> #uu:bin(), #uu:str(), type(uu), uu:isnil()\n"
"---\n"
"- 16\n"
"- 36\n"
"- cdata\n"
"- false\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/xlog.rst:39
msgid "Module `xlog`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/xlog.rst:41
msgid ""
"The xlog module contains one function: ``pairs()``. It can be used to read "
"Tarantool's :ref:`snapshot files<index-box_persistence>` or :ref:`write-ahead-"
"log (WAL) <internals-wal>` files. A description of the file format is in "
"section :ref:`Data persistence and the WAL file format <internals-"
"data_persistence>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/xlog.rst:53
msgid "Open a file, and allow iterating over one file entry at a time."
msgstr ""

#: ../doc/1.7/reference/reference_lua/xlog.rst:55
msgid "iterator  which can be used in a for/end loop."
msgstr ""

#: ../doc/1.7/reference/reference_lua/xlog.rst:56
msgid "`iterator <https://www.lua.org/pil/7.1.html>`_"
msgstr ""

#: ../doc/1.7/reference/reference_lua/xlog.rst:58
msgid ""
"Possible errors: File does not contain properly formatted snapshot or write-"
"ahead-log information."
msgstr ""

#: ../doc/1.7/reference/reference_lua/xlog.rst:63
msgid ""
"This will read the first write-ahead-log (WAL) file that was created in the :ref:"
"`wal_dir <cfg_basic-wal_dir>` directory in our :ref:`\"Getting started\" "
"exercises <getting_started>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/xlog.rst:67
msgid ""
"Each result from ``pairs()`` is formatted with MsgPack so its structure can be "
"specified with :ref:`__serialize <msgpack-serialize>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/xlog.rst:70
msgid ""
"xlog = require('xlog')\n"
"t = {}\n"
"for k, v in xlog.pairs('00000000000000000000.xlog') do\n"
"  table.insert(t, setmetatable(v, { __serialize = \"map\"}))\n"
"end\n"
"return t"
msgstr ""

#: ../doc/1.7/reference/reference_lua/xlog.rst:79
msgid "The first lines of the result will look like:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/xlog.rst:81
msgid ""
"(...)\n"
"---\n"
"- - {'BODY':   {'space_id': 272, 'index_base': 1, 'key': ['max_id'],\n"
"                'tuple': [['+', 2, 1]]},\n"
"     'HEADER': {'type': 'UPDATE', 'timestamp': 1477846870.8541,\n"
"                'lsn': 1, 'server_id': 1}}\n"
"  - {'BODY':   {'space_id': 280,\n"
"                 'tuple': [512, 1, 'tester', 'memtx', 0, {}, []]},\n"
"     'HEADER': {'type': 'INSERT', 'timestamp': 1477846870.8597,\n"
"                'lsn': 2, 'server_id': 1}}"
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:39
msgid "Module `yaml`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:41
msgid ""
"The ``yaml`` module takes strings in YAML_ format and decodes them, or takes a "
"series of non-YAML values and encodes them."
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:48
msgid "Convert a Lua object to a YAML string."
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:51
msgid "the original value reformatted as a YAML string."
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:56
msgid "Convert a YAML string to a Lua object."
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:58
msgid "a string formatted as YAML."
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:72
msgid ""
"tarantool> yaml = require('yaml')\n"
"---\n"
"...\n"
"tarantool> y = yaml.encode({'a', 1, 'b', 2})\n"
"---\n"
"...\n"
"tarantool> z = yaml.decode(y)\n"
"---\n"
"...\n"
"tarantool> z[1], z[2], z[3], z[4]\n"
"---\n"
"- a\n"
"- 1\n"
"- b\n"
"- 2\n"
"...\n"
"tarantool> if yaml.NULL == nil then print('hi') end\n"
"hi\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:95
msgid ""
"The `YAML collection style <http://yaml.org/spec/1.1/#id930798>`_ can be "
"specified with ``__serialize``:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:98
msgid "``__serialize=\"sequence\"`` for a Block Sequence array,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:99
msgid "``__serialize=\"seq\"`` for a Flow Sequence array,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:100
msgid "``__serialize=\"mapping\"`` for a Block Mapping map,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:101
msgid "``__serialize=\"map\"`` for a Flow Mapping map."
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:106
msgid ""
"tarantool> yaml = require('yaml')\n"
"---\n"
"...\n"
"tarantool> yaml.encode(setmetatable({'A', 'B'}, { __serialize=\"sequence\"}))\n"
"---\n"
"- |\n"
"  ---\n"
"  - A\n"
"  - B\n"
"  ...\n"
"...\n"
"tarantool> yaml.encode(setmetatable({'A', 'B'}, { __serialize=\"seq\"}))\n"
"---\n"
"- |\n"
"  ---\n"
"  ['A', 'B']\n"
"  ...\n"
"...\n"
"tarantool> yaml.encode({setmetatable({f1 = 'A', f2 = 'B'}, { __serialize=\"map"
"\"})})\n"
"---\n"
"- |\n"
"  ---\n"
"  - {'f2': 'B', 'f1': 'A'}\n"
"  ...\n"
"...\n"
"tarantool> yaml.encode({setmetatable({f1 = 'A', f2 = 'B'}, { __serialize="
"\"mapping\"})})\n"
"---\n"
"- |\n"
"  ---\n"
"  - f2: B\n"
"    f1: A\n"
"  ...\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:142
msgid ""
"Also, some YAML configuration settings for encoding can be changed, in the same "
"way that they can be changed for :ref:`JSON <json-module_cfg>`."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:39
#, fuzzy
msgid "SQL DBMS Modules"
msgstr ""
"#-#-#-#-#  reference.po (Tarantool 1.7)  #-#-#-#-#\n"
"Модули SQL DBMS\n"
"#-#-#-#-#  reference_rock.po (Tarantool 1.7)  #-#-#-#-#\n"
"Модули SQL СУБД"

#: ../doc/1.7/reference/reference_rock/dbms.rst:41
msgid ""
"The discussion here in the reference is about incorporating and using two "
"modules that have already been created: the \"SQL DBMS rocks\" for MySQL and "
"PostgreSQL."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:45
msgid ""
"To call another DBMS from Tarantool, the essential requirements are: another "
"DBMS, and Tarantool. The module which connects Tarantool to another DBMS may be "
"called a \"connector\". Within the module there is a shared library which may be "
"called a \"driver\"."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:50
msgid ""
"Tarantool supplies DBMS connector modules with the module manager for Lua, "
"LuaRocks. So the connector modules may be called \"rocks\"."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:53
msgid ""
"The Tarantool rocks allow for connecting to SQL servers and executing SQL "
"statements the same way that a MySQL or PostgreSQL client does. The SQL "
"statements are visible as Lua methods. Thus Tarantool can serve as a \"MySQL Lua "
"Connector\" or \"PostgreSQL Lua Connector\", which would be useful even if that "
"was all Tarantool could do. But of course Tarantool is also a DBMS, so the "
"module also is useful for any operations, such as database copying and "
"accelerating, which work best when the application can work on both SQL and "
"Tarantool inside the same Lua routine. The methods for connect/select/insert/"
"etc. are similar to the ones in the :ref:`net.box <net_box-module>` module."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:64
msgid ""
"From a user's point of view the MySQL and PostgreSQL rocks are very similar, so "
"the following sections -- \"MySQL Example\" and \"PostgreSQL Example\" -- "
"contain some redundancy."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:72
msgid "MySQL Example"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:74
msgid ""
"This example assumes that MySQL 5.5 or MySQL 5.6 or MySQL 5.7 has been "
"installed. Recent MariaDB versions will also work, the MariaDB C connector is "
"used. The package that matters most is the MySQL client developer package, "
"typically named something like libmysqlclient-dev. The file that matters most "
"from this package is libmysqlclient.so or a similar name. One can use ``find`` "
"or ``whereis`` to see what directories these files are installed in."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:81
msgid ""
"It will be necessary to install Tarantool's MySQL driver shared library, load "
"it, and use it to connect to a MySQL server instance. After that, one can pass "
"any MySQL statement to the server instance and receive results, including "
"multiple result sets."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:87
#: ../doc/1.7/reference/reference_rock/dbms.rst:440
msgid "Installation"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:89
#: ../doc/1.7/reference/reference_rock/dbms.rst:442
msgid ""
"Check the instructions for `downloading and installing a binary package <http://"
"tarantool.org/download.html>`_ that apply for the environment where Tarantool "
"was installed. In addition to installing ``tarantool``, install ``tarantool-"
"dev``. For example, on Ubuntu, add the line:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:95
#: ../doc/1.7/reference/reference_rock/dbms.rst:448
msgid "sudo apt-get install tarantool-dev"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:99
msgid "Now, for the MySQL driver shared library, there are two ways to install:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:103
#: ../doc/1.7/reference/reference_rock/dbms.rst:456
msgid "With LuaRocks"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:105
#: ../doc/1.7/reference/reference_rock/dbms.rst:458
msgid ""
"Begin by installing luarocks and making sure that tarantool is among the "
"upstream servers, as in the instructions on `rocks.tarantool.org`_, the "
"Tarantool luarocks page. Now execute this:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:112
msgid ""
"luarocks install mysql [MYSQL_LIBDIR = *path*]\n"
"                       [MYSQL_INCDIR = *path*]\n"
"                       [--local]"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:118
msgid "luarocks install mysql MYSQL_LIBDIR=/usr/local/mysql/lib"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:124
#: ../doc/1.7/reference/reference_rock/dbms.rst:477
msgid "With GitHub"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:126
msgid ""
"Go the site `github.com/tarantool/mysql`_. Follow the instructions there, saying:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:128
msgid ""
"git clone https://github.com/tarantool/mysql.git\n"
"cd mysql && cmake . -DCMAKE_BUILD_TYPE=RelWithDebInfo\n"
"make\n"
"make install"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:135
#: ../doc/1.7/reference/reference_rock/dbms.rst:488
msgid ""
"At this point it is a good idea to check that the installation produced a file "
"named ``driver.so``, and to check that this file is on a directory that is "
"searched by the ``require`` request."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:141
#: ../doc/1.7/reference/reference_rock/dbms.rst:494
msgid "Connecting"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:143
msgid ""
"Begin by making a ``require`` request for the mysql driver. We will assume that "
"the name is ``mysql`` in further examples."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:146
msgid "mysql = require('mysql')"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:150
#: ../doc/1.7/reference/reference_rock/dbms.rst:503
msgid "Now, say:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:155
msgid "*connection_name* = mysql.connect(*connection options*)"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:157
#: ../doc/1.7/reference/reference_rock/dbms.rst:510
msgid "The connection-options parameter is a table. Possible options are:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:159
#: ../doc/1.7/reference/reference_rock/dbms.rst:512
msgid ":samp:`host = {host-name}` - string, default value = 'localhost'"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:160
msgid ":samp:`port = {port-number}` - number, default value = 3306"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:161
#: ../doc/1.7/reference/reference_rock/dbms.rst:514
msgid ""
":samp:`user = {user-name}` - string, default value is operating-system user name"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:162
msgid ":samp:`password = {password}` - string, default value is blank"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:163
#: ../doc/1.7/reference/reference_rock/dbms.rst:516
msgid ":samp:`db = {database-name}` - string, default value is blank"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:164
msgid ":samp:`raise = {true|false}` - boolean, default value is false"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:166
msgid ""
"The option names, except for `raise`, are similar to the names that MySQL's "
"mysql client uses, for details see the MySQL manual at `dev.mysql.com/doc/"
"refman/5.6/en/connecting.html`_. The `raise` option should be set to :codenormal:"
"`true` if errors should be raised when encountered. To connect with a Unix "
"socket rather than with TCP, specify ``host = 'unix/'`` and :samp:`port = "
"{socket-name}`."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:173
#: ../doc/1.7/reference/reference_rock/dbms.rst:520
msgid "Example, using a table literal enclosed in {braces}:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:175
msgid ""
"conn = mysql.connect({\n"
"    host = '127.0.0.1',\n"
"    port = 3306,\n"
"    user = 'p',\n"
"    password = 'p',\n"
"    db = 'test',\n"
"    raise = true\n"
"})\n"
"-- OR\n"
"conn = mysql.connect({\n"
"    host = 'unix/',\n"
"    port = '/var/run/mysqld/mysqld.sock'\n"
"})"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:191
#: ../doc/1.7/reference/reference_rock/dbms.rst:532
msgid "Example, creating a function which sets each option in a separate line:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:193
msgid ""
"tarantool> -- Connection function. Usage: conn = mysql_connect()\n"
"tarantool> function mysql_connection()\n"
"         >   local p = {}\n"
"         >   p.host = 'widgets.com'\n"
"         >   p.db = 'test'\n"
"         >   conn = mysql.connect(p)\n"
"         >   return conn\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> conn = mysql_connect()\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:209
#: ../doc/1.7/reference/reference_rock/dbms.rst:551
msgid "We will assume that the name is 'conn' in further examples."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:213
#: ../doc/1.7/reference/reference_rock/dbms.rst:555
msgid "How to ping"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:215
#: ../doc/1.7/reference/reference_rock/dbms.rst:557
msgid "To ensure that a connection is working, the request is:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:220
#: ../doc/1.7/reference/reference_rock/dbms.rst:562
msgid "*connection-name*:ping()"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:224
#: ../doc/1.7/reference/reference_rock/dbms.rst:567
msgid ""
"tarantool> conn:ping()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:233
#: ../doc/1.7/reference/reference_rock/dbms.rst:576
msgid "Executing a statement"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:235
msgid "For all MySQL statements, the request is:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:240
#: ../doc/1.7/reference/reference_rock/dbms.rst:583
msgid "*connection-name*:execute(*sql-statement* [, *parameters*])"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:242
#: ../doc/1.7/reference/reference_rock/dbms.rst:585
msgid ""
"where ``sql-statement`` is a string, and the optional ``parameters`` are extra "
"values that can be plugged in to replace any question marks (\"?\"s) in the SQL "
"statement."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:248
msgid ""
"tarantool> conn:execute('select table_name from information_schema.tables')\n"
"---\n"
"- - table_name: ALL_PLUGINS\n"
"  - table_name: APPLICABLE_ROLES\n"
"  - table_name: CHARACTER_SETS\n"
"  <...>\n"
"- 78\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:261
#: ../doc/1.7/reference/reference_rock/dbms.rst:603
msgid "Closing connection"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:263
msgid "To end a session that began with ``mysql.connect``, the request is:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:268
#: ../doc/1.7/reference/reference_rock/dbms.rst:610
msgid "*connection-name*:close()"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:272
#: ../doc/1.7/reference/reference_rock/dbms.rst:614
msgid ""
"tarantool> conn:close()\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:278
msgid ""
"For further information, including examples of rarely-used requests, see the "
"README.md file at `github.com/tarantool/mysql`_."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:285
msgid ""
"The example was run on an Ubuntu 12.04 (\"precise\") machine where tarantool had "
"been installed in a /usr subdirectory, and a copy of MySQL had been installed on "
"~/mysql-5.5. The mysqld server instance is already running on the local host "
"127.0.0.1."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:289
msgid ""
"$ export TMDIR=~/mysql-5.5\n"
"$ # Check that the include subdirectory exists by looking\n"
"$ # for .../include/mysql.h. (If this fails, there's a chance\n"
"$ # that it's in .../include/mysql/mysql.h instead.)\n"
"$ [ -f $TMDIR/include/mysql.h ] && echo \"OK\" || echo \"Error\"\n"
"OK\n"
"\n"
"$ # Check that the library subdirectory exists and has the\n"
"$ # necessary .so file.\n"
"$ [ -f $TMDIR/lib/libmysqlclient.so ] && echo \"OK\" || echo \"Error\"\n"
"OK\n"
"\n"
"$ # Check that the mysql client can connect using some factory\n"
"$ # defaults: port = 3306, user = 'root', user password = '',\n"
"$ # database = 'test'. These can be changed, provided one uses\n"
"$ # the changed values in all places.\n"
"$ $TMDIR/bin/mysql --port=3306 -h 127.0.0.1 --user=root \\\n"
"    --password= --database=test\n"
"Welcome to the MySQL monitor.  Commands end with ; or \\g.\n"
"Your MySQL connection id is 25\n"
"Server version: 5.5.35 MySQL Community Server (GPL)\n"
"...\n"
"Type 'help;' or '\\h' for help. Type '\\c' to clear ...\n"
"\n"
"$ # Insert a row in database test, and quit.\n"
"mysql> CREATE TABLE IF NOT EXISTS test (s1 INT, s2 VARCHAR(50));\n"
"Query OK, 0 rows affected (0.13 sec)\n"
"mysql> INSERT INTO test.test VALUES (1,'MySQL row');\n"
"Query OK, 1 row affected (0.02 sec)\n"
"mysql> QUIT\n"
"Bye\n"
"\n"
"$ # Install luarocks\n"
"$ sudo apt-get -y install luarocks | grep -E \"Setting up|already\"\n"
"Setting up luarocks (2.0.8-2) ...\n"
"\n"
"$ # Set up the Tarantool rock list in ~/.luarocks,\n"
"$ # following instructions at rocks.tarantool.org\n"
"$ mkdir ~/.luarocks\n"
"$ echo \"rocks_servers = {[[http://rocks.tarantool.org/]]}\" >> \\\n"
"    ~/.luarocks/config.lua\n"
"\n"
"$ # Ensure that the next \"install\" will get files from Tarantool\n"
"$ # master repository. The resultant display is normal for Ubuntu\n"
"$ # 12.04 precise\n"
"$ cat /etc/apt/sources.list.d/tarantool.list\n"
"deb http://tarantool.org/dist/1.7/ubuntu/ precise main\n"
"deb-src http://tarantool.org/dist/1.7/ubuntu/ precise main\n"
"\n"
"$ # Install tarantool-dev. The displayed line should show version = 1.6\n"
"$ sudo apt-get -y install tarantool-dev | grep -E \"Setting up|already\"\n"
"Setting up tarantool-dev (1.6.6.222.g48b98bb~precise-1) ...\n"
"$\n"
"\n"
"$ # Use luarocks to install locally, that is, relative to $HOME\n"
"$ luarocks install mysql MYSQL_LIBDIR=/usr/local/mysql/lib --local\n"
"Installing http://rocks.tarantool.org/mysql-scm-1.rockspec...\n"
"... (more info about building the Tarantool/MySQL driver appears here)\n"
"mysql scm-1 is now built and installed in ~/.luarocks/\n"
"\n"
"$ # Ensure driver.so now has been created in a place\n"
"$ # tarantool will look at\n"
"$ find ~/.luarocks -name \"driver.so\"\n"
"~/.luarocks/lib/lua/5.1/mysql/driver.so\n"
"\n"
"$ # Change directory to a directory which can be used for\n"
"$ # temporary tests. For this example we assume that the name\n"
"$ # of this directory is /home/pgulutzan/tarantool_sandbox.\n"
"$ # (Change \"/home/pgulutzan\" to whatever is the user's actual\n"
"$ # home directory for the machine that's used for this test.)\n"
"$ cd /home/pgulutzan/tarantool_sandbox\n"
"\n"
"$ # Start the Tarantool server instance. Do not use a Lua initialization file.\n"
"\n"
"$ tarantool\n"
"tarantool: version 1.7.0-222-g48b98bb\n"
"type 'help' for interactive help\n"
"tarantool>"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:370
msgid ""
"Configure tarantool and load mysql module. Make sure that tarantool doesn't "
"reply \"error\" for the call to \"require()\"."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:373
msgid ""
"tarantool> box.cfg{}\n"
"...\n"
"tarantool> mysql = require('mysql')\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:381
msgid ""
"Create a Lua function that will connect to the MySQL server instance, (using "
"some factory default values for the port and user and password), retrieve one "
"row, and display the row. For explanations of the statement types used here, "
"read the Lua tutorial earlier in the Tarantool user manual."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:386
msgid ""
"tarantool> function mysql_select ()\n"
"         >   local conn = mysql.connect({\n"
"         >     host = '127.0.0.1',\n"
"         >     port = 3306,\n"
"         >     user = 'root',\n"
"         >     db = 'test'\n"
"         >   })\n"
"         >   local test = conn:execute('SELECT * FROM test WHERE s1 = 1')\n"
"         >   local row = ''\n"
"         >   for i, card in pairs(test) do\n"
"         >       row = row .. card.s2 .. ' '\n"
"         >       end\n"
"         >   conn:close()\n"
"         >   return row\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> mysql_select()\n"
"---\n"
"- 'MySQL row '\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:410
msgid ""
"Observe the result. It contains \"MySQL row\". So this is the row that was "
"inserted into the MySQL database. And now it's been selected with the Tarantool "
"client."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:417
msgid "PostgreSQL Example"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:419
msgid ""
"This example assumes that PostgreSQL 8 or PostgreSQL 9 has been installed. More "
"recent versions should also work. The package that matters most is the "
"PostgreSQL developer package, typically named something like libpq-dev. On "
"Ubuntu this can be installed with:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:424
msgid "sudo apt-get install libpq-dev"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:428
msgid ""
"However, because not all platforms are alike, for this example the assumption is "
"that the user must check that the appropriate PostgreSQL files are present and "
"must explicitly state where they are when building the Tarantool/PostgreSQL "
"driver. One can use ``find`` or ``whereis`` to see what directories PostgreSQL "
"files are installed in."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:434
msgid ""
"It will be necessary to install Tarantool's PostgreSQL driver shared library, "
"load it, and use it to connect to a PostgreSQL server instance. After that, one "
"can pass any PostgreSQL statement to the server instance and receive results."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:452
msgid ""
"Now, for the PostgreSQL driver shared library, there are two ways to install:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:465
msgid ""
"luarocks install pg [POSTGRESQL_LIBDIR = *path*]\n"
"                    [POSTGRESQL_INCDIR = *path*]\n"
"                    [--local]"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:471
msgid "luarocks install pg POSTGRESQL_LIBDIR=/usr/local/postgresql/lib"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:479
msgid ""
"Go the site `github.com/tarantool/pg`_. Follow the instructions there, saying:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:481
msgid ""
"git clone https://github.com/tarantool/pg.git\n"
"cd pg && cmake . -DCMAKE_BUILD_TYPE=RelWithDebInfo\n"
"make\n"
"make install"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:496
msgid ""
"Begin by making a ``require`` request for the pg driver. We will assume that the "
"name is ``pg`` in further examples."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:499
msgid "pg = require('pg')"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:508
msgid "*connection_name* = pg.connect(*connection options*)"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:513
msgid ":samp:`port = {port-number}` - number, default value = 5432"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:515
msgid ""
":samp:`pass = {password}` or :samp:`password = {password}` - string, default "
"value is blank"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:518
msgid "The names are similar to the names that PostgreSQL itself uses."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:522
msgid ""
"conn = pg.connect({\n"
"    host = '127.0.0.1',\n"
"    port = 5432,\n"
"    user = 'p',\n"
"    password = 'p',\n"
"    db = 'test'\n"
"})"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:534
msgid ""
"tarantool> function pg_connect()\n"
"         >   local p = {}\n"
"         >   p.host = 'widgets.com'\n"
"         >   p.db = 'test'\n"
"         >   p.user = 'postgres'\n"
"         >   p.password = 'postgres'\n"
"         >   local conn = pg.connect(p)\n"
"         >   return conn\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> conn = pg_connect()\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:578
msgid "For all PostgreSQL statements, the request is:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:591
msgid ""
"tarantool> conn:execute('select tablename from pg_tables')\n"
"---\n"
"- - tablename: pg_statistic\n"
"  - tablename: pg_type\n"
"  - tablename: pg_authid\n"
"  <...>\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:605
msgid "To end a session that began with ``pg.connect``, the request is:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:620
msgid ""
"For further information, including examples of rarely-used requests, see the "
"README.md file at `github.com/tarantool/pg`_."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:627
msgid ""
"The example was run on an Ubuntu 12.04 (\"precise\") machine where tarantool had "
"been installed in a /usr subdirectory, and a copy of PostgreSQL had been "
"installed on /usr. The PostgreSQL server instance is already running on the "
"local host 127.0.0.1."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:631
msgid ""
"$ # Check that the include subdirectory exists\n"
"$ # by looking for /usr/include/postgresql/libpq-fe-h.\n"
"$ [ -f /usr/include/postgresql/libpq-fe.h ] && echo \"OK\" || echo \"Error\"\n"
"OK\n"
"\n"
"$ # Check that the library subdirectory exists and has the necessary .so file.\n"
"$ [ -f /usr/lib/x86_64-linux-gnu/libpq.so ] && echo \"OK\" || echo \"Error\"\n"
"OK\n"
"\n"
"$ # Check that the psql client can connect using some factory defaults:\n"
"$ # port = 5432, user = 'postgres', user password = 'postgres',\n"
"$ # database = 'postgres'. These can be changed, provided one changes\n"
"$ # them in all places. Insert a row in database postgres, and quit.\n"
"$ psql -h 127.0.0.1 -p 5432 -U postgres -d postgres\n"
"Password for user postgres:\n"
"psql (9.3.10)\n"
"SSL connection (cipher: DHE-RSA-AES256-SHA, bits: 256)\n"
"Type \"help\" for help.\n"
"\n"
"postgres=# CREATE TABLE test (s1 INT, s2 VARCHAR(50));\n"
"CREATE TABLE\n"
"postgres=# INSERT INTO test VALUES (1,'PostgreSQL row');\n"
"INSERT 0 1\n"
"postgres=# \\q\n"
"$\n"
"\n"
"$ # Install luarocks\n"
"$ sudo apt-get -y install luarocks | grep -E \"Setting up|already\"\n"
"Setting up luarocks (2.0.8-2) ...\n"
"\n"
"$ # Set up the Tarantool rock list in ~/.luarocks,\n"
"$ # following instructions at rocks.tarantool.org\n"
"$ mkdir ~/.luarocks\n"
"$ echo \"rocks_servers = {[[http://rocks.tarantool.org/]]}\" >> \\\n"
"        ~/.luarocks/config.lua\n"
"\n"
"$ # Ensure that the next \"install\" will get files from Tarantool master\n"
"$ # repository. The resultant display is normal for Ubuntu 12.04 precise\n"
"$ cat /etc/apt/sources.list.d/tarantool.list\n"
"deb http://tarantool.org/dist/1.7/ubuntu/ precise main\n"
"deb-src http://tarantool.org/dist/1.7/ubuntu/ precise main\n"
"\n"
"$ # Install tarantool-dev. The displayed line should show version = 1.7\n"
"$ sudo apt-get -y install tarantool-dev | grep -E \"Setting up|already\"\n"
"Setting up tarantool-dev (1.7.0.222.g48b98bb~precise-1) ...\n"
"$\n"
"\n"
"$ # Use luarocks to install locally, that is, relative to $HOME\n"
"$ luarocks install pg POSTGRESQL_LIBDIR=/usr/lib/x86_64-linux-gnu --local\n"
"Installing http://rocks.tarantool.org/pg-scm-1.rockspec...\n"
"... (more info about building the Tarantool/PostgreSQL driver appears here)\n"
"pg scm-1 is now built and installed in ~/.luarocks/\n"
"\n"
"$ # Ensure driver.so now has been created in a place\n"
"$ # tarantool will look at\n"
"$ find ~/.luarocks -name \"driver.so\"\n"
"~/.luarocks/lib/lua/5.1/pg/driver.so\n"
"\n"
"$ # Change directory to a directory which can be used for\n"
"$ # temporary tests. For this example we assume that the\n"
"$ # name of this directory is $HOME/tarantool_sandbox.\n"
"$ # (Change \"$HOME\" to whatever is the user's actual\n"
"$ # home directory for the machine that's used for this test.)\n"
"cd $HOME/tarantool_sandbox\n"
"\n"
"$ # Start the Tarantool server instance. Do not use a Lua initialization file.\n"
"\n"
"$ tarantool\n"
"tarantool: version 1.7.0-412-g803b15c\n"
"type 'help' for interactive help\n"
"tarantool>"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:705
msgid ""
"Configure tarantool and load pg module. Make sure that tarantool doesn't reply "
"\"error\" for the call to \"require()\"."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:708
msgid ""
"tarantool> box.cfg{}\n"
"...\n"
"tarantool> pg = require('pg')\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:716
msgid ""
"Create a Lua function that will connect to a PostgreSQL server, (using some "
"factory default values for the port and user and password), retrieve one row, "
"and display the row. For explanations of the statement types used here, read the "
"Lua tutorial earlier in the Tarantool user manual."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:721
msgid ""
"tarantool> function pg_select ()\n"
"         >   local conn = pg.connect({\n"
"         >     host = '127.0.0.1',\n"
"         >     port = 5432,\n"
"         >     user = 'postgres',\n"
"         >     password = 'postgres',\n"
"         >     db = 'postgres'\n"
"         >   })\n"
"         >   local test = conn:execute('SELECT * FROM test WHERE s1 = 1')\n"
"         >   local row = ''\n"
"         >   for i, card in pairs(test) do\n"
"         >       row = row .. card.s2 .. ' '\n"
"         >       end\n"
"         >   conn:close()\n"
"         >   return row\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> pg_select()\n"
"---\n"
"- 'PostgreSQL row '\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:746
msgid ""
"Observe the result. It contains \"PostgreSQL row\". So this is the row that was "
"inserted into the PostgreSQL database. And now it's been selected with the "
"Tarantool client."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:39
msgid "Module `expirationd`"
msgstr "Модуль `expirationd`"

#: ../doc/1.7/reference/reference_rock/expirationd.rst:41
msgid ""
"For a commercial-grade example of a Lua rock that works with Tarantool, let us "
"look at expirationd, which Tarantool supplies on GitHub_ with an Artistic "
"license. The expirationd.lua program is lengthy (about 500 lines), so here we "
"will only highlight the matters that will be enhanced by studying the full "
"source later."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:46
msgid ""
"task.worker_fiber = fiber.create(worker_loop, task)\n"
"log.info(\"expiration: task %q restarted\", task.name)\n"
"...\n"
"fiber.sleep(expirationd.constants.check_interval)\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:54
msgid ""
"Whenever one hears \"daemon\" in Tarantool, one should suspect it's being done "
"with a :doc:`fiber<../reference_lua/fiber>`. The program is making a fiber and "
"turning control over to it so it runs occasionally, goes to sleep, then comes "
"back for more."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:59
msgid ""
"for _, tuple in scan_space.index[0]:pairs(nil, {iterator = box.index.ALL}) do\n"
"...\n"
"        if task.is_tuple_expired(task.args, tuple) then\n"
"        task.expired_tuples_count = task.expired_tuples_count + 1\n"
"        task.process_expired_tuple(task.space_id, task.args, tuple)\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:68
msgid ""
"The \"for\" instruction can be translated as \"iterate through the index of the "
"space that is being scanned\", and within it, if the tuple is \"expired\" (for "
"example, if the tuple has a timestamp field which is less than the current "
"time), process the tuple as an expired tuple."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:73
msgid ""
"-- default process_expired_tuple function\n"
"local function default_tuple_drop(space_id, args, tuple)\n"
"    local key = fun.map(\n"
"        function(x) return tuple[x.fieldno] end,\n"
"        box.space[space_id].index[0].parts\n"
"    ):totable()\n"
"    box.space[space_id]:delete(key)\n"
"end"
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:84
msgid ""
"Ultimately the tuple-expiry process leads to ``default_tuple_drop()`` which does "
"a \"delete\" of a tuple from its original space. First the fun :ref:`fun <fun-"
"module>` module is used, specifically fun.map_. Remembering that :codenormal:"
"`index[0]` is always the space's primary key, and :codenormal:`index[0].parts[`:"
"codeitalic:`N`:codenormal:`].fieldno` is always the field number for key part :"
"codeitalic:`N`, fun.map() is creating a table from the primary-key values of the "
"tuple. The result of fun.map() is passed to :ref:`space_object:delete() "
"<box_space-delete>`."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:94
msgid ""
"local function expirationd_run_task(name, space_id, is_tuple_expired, options)\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:99
msgid ""
"At this point, if the above explanation is worthwhile, it's clear that "
"``expirationd.lua`` starts a background routine (fiber) which iterates through "
"all the tuples in a space, sleeps cooperatively so that other fibers can operate "
"at the same time, and - whenever it finds a tuple that has expired - deletes it "
"from this space. Now the \"``expirationd_run_task()``\" function can be used in "
"a test which creates sample data, lets the daemon run for a while, and prints "
"results."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:108
msgid ""
"For those who like to see things run, here are the exact steps to get "
"expirationd through the test."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:111
msgid ""
"Get ``expirationd.lua``. There are standard ways - it is after all part of a "
"`standard rock <https://luarocks.org/modules/rtsisyk/expirationd>`_  - but for "
"this purpose just copy the contents of expirationd.lua_ to a default directory."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:114
msgid "Start the Tarantool server as described before."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:115
msgid "Execute these requests:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:117
msgid ""
"fiber = require('fiber')\n"
"expd = require('expirationd')\n"
"box.cfg{}\n"
"e = box.schema.space.create('expirationd_test')\n"
"e:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
"e:replace{1, fiber.time() + 3}\n"
"e:replace{2, fiber.time() + 30}\n"
"function is_tuple_expired(args, tuple)\n"
"  if (tuple[2] < fiber.time()) then return true end\n"
"  return false\n"
"  end\n"
"expd.run_task('expirationd_test', e.id, is_tuple_expired)\n"
"retval = {}\n"
"fiber.sleep(2)\n"
"expd.task_stats()\n"
"fiber.sleep(2)\n"
"expd.task_stats()\n"
"expd.kill_task('expirationd_test')\n"
"e:drop()\n"
"os.exit()"
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:140
msgid ""
"The database-specific requests (``cfg``, :ref:`space.create <box_schema-"
"space_create>`, :ref:`create_index <box_space-create_index>`) should already be "
"familiar."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:145
msgid ""
"The function which will be supplied to expirationd is :codenormal:"
"`is_tuple_expired`, which is saying \"if the second field of the tuple is less "
"than the :ref:`current time <fiber-time>`  , then return true, otherwise return "
"false\"."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:150
msgid ""
"The key for getting the rock rolling is ``expd = require('expirationd')``. The "
"\"``require``\" function is what reads in the program; it will appear in many "
"later examples in this manual, when it's necessary to get a module that's not "
"part of the Tarantool kernel. After the Lua variable expd has been assigned the "
"value of the expirationd module, it's possible to invoke the module's "
"``run_task()`` function."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:157
msgid ""
"After :ref:`sleeping <fiber-sleep>` for two seconds, when the task has had time "
"to do its iterations through the spaces, ``expd.task_stats()`` will print out a "
"report showing how many tuples have expired -- \"expired_count: 0\". After "
"sleeping for two more seconds, ``expd.task_stats()`` will print out a report "
"showing how many tuples have expired -- \"expired_count: 1\". This shows that "
"the is_tuple_expired() function eventually returned \"true\" for one of the "
"tuples, because its timestamp field was more than three seconds old."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:167
msgid ""
"Of course, expirationd can be customized to do different things by passing "
"different parameters, which will be evident after looking in more detail at the "
"source code."
msgstr ""

#: ../doc/1.7/reference/reference_rock/index.rst:37
msgid "Rocks reference"
msgstr "Справочник по сторонним библиотекам"

#: ../doc/1.7/reference/reference_rock/index.rst:39
msgid "This reference covers third-party Lua modules for Tarantool."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:39
msgid "Module `shard`"
msgstr "Модуль `shard`"

#: ../doc/1.7/reference/reference_rock/shard.rst:43
msgid ""
"With sharding, the tuples of a tuple set are distributed to multiple nodes, with "
"a Tarantool database server instance on each node. With this arrangement, each "
"instance is handling only a subset of the total data, so larger loads can be "
"handled by simply adding more computers to a network."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:48
msgid ""
"The Tarantool `shard` module has facilities for creating shards, as well as "
"analogues for the data-manipulation functions of the box library (select, "
"insert, replace, update, delete)."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:52
msgid "First some terminology:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:55
msgid "**Consistent hash**"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:57
msgid ""
"The `shard` module distributes according to a hash algorithm, that is, it "
"applies a hash function to a tuple's primary-key value in order to decide which "
"shard the tuple belongs to. The hash function is `consistent <https://en."
"wikipedia.org/wiki/Consistent_hashing>`_ so that changing the number of servers "
"will not affect results for many keys. The specific hash function that the "
"`shard` module uses is :ref:`digest.guava <digest-guava>` in the :codeitalic:"
"`digest` module."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:64
msgid "**Instance**"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:66
msgid ""
"A currently-running in-memory copy of the Tarantool server, sometimes called a "
"\"server instance\". Usually each shard is associated with one instance, or, if "
"both sharding and replicating are going on, each shard is associated with one "
"replica set."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:70
msgid "**Queue**"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:72
msgid ""
"A temporary list of recent update requests. Sometimes called \"batching\". Since "
"updates to a sharded database can be slow, it may speed up throughput to send "
"requests to a queue rather than wait for the update to finish on every node. The "
"`shard` module has functions for adding requests to the queue, which it will "
"process without further intervention. Queuing is optional."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:78
msgid "**Redundancy**"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:80
msgid "The number of replicated data copies in each shard."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:81
msgid "**Replica**"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:83
msgid "An instance which is part of a replica set."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:84
msgid "**Replica set**"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:86
msgid ""
"Often a single shard is associated with a single instance; however, often the "
"shard is replicated. When a shard is replicated, the multiple instances "
"(\"replicas\"), which handle the shard's replicated data, are a \"replica set\"."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:90
msgid "**Replicated data**"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:92
msgid ""
"A complete copy of the data. The `shard` module handles both sharding and "
"replication. One shard can contain one or more replicated data copies. When a "
"write occurs, the write is attempted on every replicated data copy in turn. The "
"`shard` module does not use the built-in replication feature."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:96
msgid "**Shard**"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:98
msgid ""
"A subset of the tuples in the database partitioned according to the value "
"returned by the consistent hash function. Usually each shard is on a separate "
"node, or a separate set of nodes (for example if redundancy = 3 then the shard "
"will be on three nodes)."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:102
msgid "**Zone**"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:104
msgid ""
"A physical location where the nodes are closely connected, with the same "
"security and backup and access points. The simplest example of a zone is a "
"single computer with a single Tarantool-server instance. A shard's replicated "
"data copies should be in different zones."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:109
msgid ""
"The `shard` package is distributed separately from the main `tarantool` package. "
"To acquire it, do a separate installation:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:112
msgid "with Tarantool 1.7.4+, say:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:114
msgid "$ tarantoolctl rocks install shard"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:118
msgid "install with `yum` or `apt`, for example on Ubuntu say:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:124
msgid ""
"or download from GitHub `tarantool/shard` and use the Lua files as described in "
"the `README <https://github.com/tarantool/shard>`_."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:127
msgid "Then, before using the module, say ``shard = require('shard')``."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:129
msgid "The most important function is:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:134
msgid "shard.init(*shard-configuration*)"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:136
msgid "This must be called for every shard."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:138
msgid "The shard configuration is a table with these fields:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:140
msgid "`servers` (a list of URIs of nodes and the zones the nodes are in)"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:141
msgid "`login` (the user name which applies for accessing via the `shard` module)"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:142
msgid "`password` (the password for the login)"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:143
msgid "`redundancy` (a number, minimum 1)"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:144
msgid ""
"`binary` (a port number that this host is listening on, on the current host, "
"(distinguishable from the 'listen' port specified by `box.cfg`)"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:147
#, fuzzy
msgid "Possible errors:"
msgstr "Модуль `error`"

#: ../doc/1.7/reference/reference_rock/shard.rst:149
msgid "redundancy should not be greater than the number of servers;"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:150
msgid "the servers must be alive;"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:151
msgid ""
"two replicated data copies of the same shard should not be in the same zone."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:155
msgid "Example: `shard.init` syntax for one shard"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:157
msgid "The number of replicated data copies per shard (redundancy) is 3."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:158
msgid "The number of instances is 3."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:159
msgid "The `shard` module will conclude that there is only one shard."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:161
msgid ""
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'localhost:33131', zone = '1' },\n"
"         >     { uri = 'localhost:33132', zone = '2' },\n"
"         >     { uri = 'localhost:33133', zone = '3' }\n"
"         >   },\n"
"         >   login = 'test_user',\n"
"         >   password = 'pass',\n"
"         >   redundancy = '3',\n"
"         >   binary = 33131,\n"
"         > }\n"
"---\n"
"...\n"
"tarantool> shard.init(cfg)\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:182
msgid "Example: `shard.init` syntax for three shards"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:184
msgid ""
"This describes three shards. Each shard has two replicated data copies. Since "
"the number of servers is 7, and the number of replicated data copies per shard "
"is 2, and dividing 7 / 2 leaves a remainder of 1, one of the servers will not be "
"used. This is not necessarily an error, because perhaps one of the servers in "
"the list is not alive."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:189
msgid ""
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'host1:33131', zone = '1' },\n"
"         >     { uri = 'host2:33131', zone = '2' },\n"
"         >     { uri = 'host3:33131', zone = '3' },\n"
"         >     { uri = 'host4:33131', zone = '4' },\n"
"         >     { uri = 'host5:33131', zone = '5' },\n"
"         >     { uri = 'host6:33131', zone = '6' },\n"
"         >     { uri = 'host7:33131', zone = '7' }\n"
"         >   },\n"
"         >   login = 'test_user',\n"
"         >   password = 'pass',\n"
"         >   redundancy = '2',\n"
"         >   binary = 33131,\n"
"         > }\n"
"---\n"
"...\n"
"tarantool> shard.init(cfg)\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:212
msgid ""
"Every data-access function in the `box` module has an analogue in the `shard` "
"module:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:218
msgid ""
"shard[*space-name*].insert{...}\n"
"shard[*space-name*].replace{...}\n"
"shard[*space-name*].delete{...}\n"
"shard[*space-name*].select{...}\n"
"shard[*space-name*].update{...}\n"
"shard[*space-name*].auto_increment{...}"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:225
msgid ""
"For example, to insert in table T in a sharded database you simply say ``shard.T:"
"insert{...}`` instead of ``box.space.T:insert{...}``."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:228
msgid ""
"A ``shard.T:select{}`` request without a primary key will search all shards."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:230
msgid "Every queued data-access function has an analogue in the `shard` module:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:235
msgid ""
"shard[*space-name*].q_insert{...}\n"
"shard[*space-name*].q_replace{...}\n"
"shard[*space-name*].q_delete{...}\n"
"shard[*space-name*].q_select{...}\n"
"shard[*space-name*].q_update{...}\n"
"shard[*space-name*].q_auto_increment{...}"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:242
msgid ""
"The user must add an `operation_id`. For details of queued data-access "
"functions, and of maintenance-related functions, see the `README <https://github."
"com/tarantool/shard>`_."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:248
msgid "Example: shard, minimal configuration"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:250
msgid ""
"There is only one shard, and that shard contains only one replicated data copy. "
"So this isn't illustrating the features of either replication or sharding, it's "
"only illustrating what the syntax is, and what the messages look like, that "
"anyone could duplicate in a minute or two with the magic of cut-and-paste."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:256
msgid ""
"$ mkdir ~/tarantool_sandbox_1\n"
"$ cd ~/tarantool_sandbox_1\n"
"$ rm -r *.snap\n"
"$ rm -r *.xlog\n"
"$ ~/tarantool-1.7/src/tarantool\n"
"\n"
"tarantool> box.cfg{listen = 3301}\n"
"tarantool> box.schema.space.create('tester')\n"
"tarantool> box.space.tester:create_index('primary', {})\n"
"tarantool> box.schema.user.create('test_user', {password = 'pass'})\n"
"tarantool> box.schema.user.grant('test_user', 'read,write,execute', 'universe')\n"
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >       { uri = 'localhost:3301', zone = '1' },\n"
"         >   },\n"
"         >   login = 'test_user';\n"
"         >   password = 'pass';\n"
"         >   redundancy = 1;\n"
"         >   binary = 3301;\n"
"         > }\n"
"tarantool> shard = require('shard')\n"
"tarantool> shard.init(cfg)\n"
"tarantool> -- Now put something in ...\n"
"tarantool> shard.tester:insert{1,'Tuple #1'}"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:283
msgid ""
"If you cut and paste the above, then the result, showing only the requests and "
"responses for `shard.init` and `shard.tester`, should look approximately like "
"this:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:287
msgid ""
"<...>\n"
"tarantool> shard.init(cfg)\n"
"2017-09-06 ... I> Sharding initialization started...\n"
"2017-09-06 ... I> establishing connection to cluster servers...\n"
"2017-09-06 ... I> connected to all servers\n"
"2017-09-06 ... I> started\n"
"2017-09-06 ... I> redundancy = 1\n"
"2017-09-06 ... I> Adding localhost:3301 to shard 1\n"
"2017-09-06 ... I> shards = 1\n"
"2017-09-06 ... I> Done\n"
"---\n"
"- true\n"
"...\n"
"tarantool> -- Now put something in ...\n"
"---\n"
"...\n"
"tarantool> shard.tester:insert{1,'Tuple #1'}\n"
"---\n"
"- - [1, 'Tuple #1']\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:312
msgid "Example: shard, scaling out"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:314
msgid ""
"There are two shards, and each shard contains one replicated data copy. This "
"requires two nodes. In real life the two nodes would be two computers, but for "
"this illustration the requirement is merely: start two shells, which we'll call "
"Terminal#1 and Terminal #2."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:319
msgid "On Terminal #1, say:"
msgstr "В первом терминале (Terminal #1) введите:"

#: ../doc/1.7/reference/reference_rock/shard.rst:321
msgid ""
"$ mkdir ~/tarantool_sandbox_1\n"
"$ cd ~/tarantool_sandbox_1\n"
"$ rm -r *.snap\n"
"$ rm -r *.xlog\n"
"$ ~/tarantool-1.7/src/tarantool\n"
"\n"
"tarantool> box.cfg{listen = 3301}\n"
"tarantool> box.schema.space.create('tester')\n"
"tarantool> box.space.tester:create_index('primary', {})\n"
"tarantool> box.schema.user.create('test_user', {password = 'pass'})\n"
"tarantool> box.schema.user.grant('test_user', 'read,write,execute', 'universe')\n"
"tarantool> console = require('console')\n"
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'localhost:3301', zone = '1' },\n"
"         >     { uri = 'localhost:3302', zone = '2' },\n"
"         >   },\n"
"         >   login = 'test_user',\n"
"         >   password = 'pass',\n"
"         >   redundancy = 1,\n"
"         >   binary = 3301,\n"
"         > }\n"
"tarantool> shard = require('shard')\n"
"tarantool> shard.init(cfg)\n"
"tarantool> -- Now put something in ...\n"
"tarantool> shard.tester:insert{1,'Tuple #1'}"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:350
msgid "On Terminal #2, say:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:352
msgid ""
"$ mkdir ~/tarantool_sandbox_2\n"
"$ cd ~/tarantool_sandbox_2\n"
"$ rm -r *.snap\n"
"$ rm -r *.xlog\n"
"$ ~/tarantool-1.7/src/tarantool\n"
"\n"
"tarantool> box.cfg{listen = 3302}\n"
"tarantool> box.schema.space.create('tester')\n"
"tarantool> box.space.tester:create_index('primary', {})\n"
"tarantool> box.schema.user.create('test_user', {password = 'pass'})\n"
"tarantool> box.schema.user.grant('test_user', 'read,write,execute', 'universe')\n"
"tarantool> console = require('console')\n"
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'localhost:3301', zone = '1' };\n"
"         >     { uri = 'localhost:3302', zone = '2' };\n"
"         >   };\n"
"         >   login = 'test_user';\n"
"         >   password = 'pass';\n"
"         >   redundancy = 1;\n"
"         >   binary = 3302;\n"
"         > }\n"
"tarantool> shard = require('shard')\n"
"tarantool> shard.init(cfg)\n"
"tarantool> -- Now get something out ...\n"
"tarantool> shard.tester:select{1}"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:381
msgid ""
"What will appear on Terminal #1 is: a loop of error messages saying \"Connection "
"refused\" and \"server check failure\". This is normal. It will go on until "
"Terminal #2 process starts."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:385
msgid "What will appear on Terminal #2, at the end, should look like this:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:387
msgid ""
"tarantool> shard.tester:select{1}\n"
"---\n"
"- - - [1, 'Tuple #1']\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:394
msgid ""
"This shows that what was inserted by Terminal #1 can be selected by Terminal #2, "
"via the `shard` module."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:397
#, fuzzy
msgid "For details, see the `README <https://github.com/tarantool/shard>`_."
msgstr "См. https://github.com/thekvs/tarantoolr."

#: ../doc/1.7/reference/reference_rock/tdb.rst:37
msgid "Module `tdb`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:39
msgid ""
"The Tarantool Debugger (abbreviation = tdb) can be used with any Lua program. "
"The operational features include: setting breakpoints, examining variables, "
"going forward one line at a time, backtracing, and showing information about "
"fibers. The display features include: using different colors for different "
"situations, including line numbers, and adding hints."
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:45
msgid ""
"It is not supplied as part of the Tarantool repository; it must be installed "
"separately. Here is the usual way:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:48
msgid ""
"git clone --recursive https://github.com/Sulverus/tdb\n"
"cd tdb\n"
"make\n"
"sudo make install prefix=/usr/share/tarantool/"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:55
msgid ""
"To initiate tdb within a Lua program and set a breakpoint, edit the program to "
"include these lines:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:58
msgid ""
"tdb = require('tdb')\n"
"tdb.start()"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:63
msgid ""
"To start the debugging session, execute the Lua program. Execution will stop at "
"the breakpoint, and it will be possible to enter debugging commands."
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:68
msgid "Debugger Commands"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:72
msgid ":codebold:`bt`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:71
msgid ""
"Backtrace -- show the stack (in red), with program/function names and line "
"numbers of whatever has been invoked to reach the current line."
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:75
msgid ":codebold:`c`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:75
msgid "Continue till next breakpoint or till program ends."
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:82
msgid ":codebold:`e`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:78
msgid ""
"Enter evaluation mode. When the program is in evaluation mode, one can execute "
"certain Lua statements that would be valid in the context. This is particularly "
"useful for displaying the values of the program's variables. Other debugger "
"commands will not work until one exits evaluation mode by typing :codebold:`-e`."
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:85
msgid ":codebold:`-e`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:85
msgid "Exit evaluation mode."
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:89
msgid ":codebold:`f`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:88
msgid ""
"Display the fiber id, the program name, and the percentage of memory used, as a "
"table."
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:92
msgid ":codebold:`n`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:92
msgid "Go to the next line, skipping over any function calls."
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:95
msgid ":codebold:`globals`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:95
msgid "Display names of variables or functions which are defined as global."
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:98
msgid ":codebold:`h`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:98
msgid "Display a list of debugger commands."
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:102
msgid ":codebold:`locals`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:101
msgid ""
"Display names and values of variables, for example the control variables of a "
"Lua \"for\" statement."
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:105
msgid ":codebold:`q`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:105
msgid "Quit immediately."
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:109
msgid "Example Session"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:111
msgid ""
"Put the following program in a default directory and call it \"example.lua\":"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:113
msgid ""
"tdb = require('tdb')\n"
"tdb.start()\n"
"i = 1\n"
"j = 'a' .. i\n"
"print('end of program')"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:121
msgid "Now start Tarantool, using example.lua as the initialization file"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:126
msgid "$ :codebold:`tarantool example.lua`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:128
#: ../doc/1.7/reference/reference_rock/tdb.rst:153
msgid "The screen should now look like this:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:133
msgid ""
"$ :codebold:`tarantool example.lua`\n"
":codeblue:`(TDB)`  :codegreen:`Tarantool debugger v.0.0.3. Type h for help`\n"
"example.lua\n"
":codeblue:`(TDB)`  :codegreen:`[example.lua]`\n"
":codeblue:`(TDB)`  :codenormal:`3: i = 1`\n"
":codeblue:`(TDB)>`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:140
msgid ""
"Debugger prompts are blue, debugger hints and information are green, and the "
"current line -- line 3 of example.lua -- is the default color. Now enter six "
"debugger commands:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:144
msgid ""
"n  -- go to next line\n"
"n  -- go to next line\n"
"e  -- enter evaluation mode\n"
"j  -- display j\n"
"-e -- exit evaluation mode\n"
"q  -- quit"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:158
msgid ""
"$ :codebold:`tarantool example.lua`\n"
":codeblue:`(TDB)`  :codegreen:`Tarantool debugger v.0.0.3. Type h for help`\n"
"example.lua\n"
":codeblue:`(TDB)`  :codegreen:`[example.lua]`\n"
":codeblue:`(TDB)`  :codenormal:`3: i = 1`\n"
":codeblue:`(TDB)>` n\n"
":codeblue:`(TDB)`  :codenormal:`4: j = 'a' .. i`\n"
":codeblue:`(TDB)>` n\n"
":codeblue:`(TDB)`  :codenormal:`5: print('end of program')`\n"
":codeblue:`(TDB)>` e\n"
":codeblue:`(TDB)`  :codegreen:`Eval mode ON`\n"
":codeblue:`(TDB)>` j\n"
"j       a1\n"
":codeblue:`(TDB)>` -e\n"
":codeblue:`(TDB)`  :codegreen:`Eval mode OFF`\n"
":codeblue:`(TDB)>` q"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:175
msgid "Another debugger example can be found here_."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:39
#, fuzzy
msgid "Utility `tarantoolctl`"
msgstr "Утилита tarantoolctl"

#: ../doc/1.7/reference/tarantoolctl.rst:41
msgid ""
"``tarantoolctl`` is a utility for administering Tarantool :ref:`instances "
"<tarantoolctl-instance_management>`, :ref:`checkpoint files <tarantoolctl-"
"checkpoint_management>` and :ref:`modules <tarantoolctl-module_management>`. It "
"is shipped and installed as part of Tarantool distribution."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:47
msgid ""
"See also ``tarantoolctl`` usage examples in :ref:`Server administration <admin>` "
"section."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:54
#, fuzzy
msgid "Command format"
msgstr "Опции комнандной строки"

#: ../doc/1.7/reference/tarantoolctl.rst:56
msgid "``tarantoolctl COMMAND NAME [URI] [FILE] [OPTIONS..]``"
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:60
msgid ""
"``COMMAND`` is one of the following: ``start``, ``stop``, ``status``, "
"``restart``, ``logrotate``, ``check``, ``enter``, ``eval``, ``connect``, "
"``cat``, ``play``, ``rocks``."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:64
msgid ""
"``NAME`` is the name of an :ref:`instance file <admin-instance_file>` or a :ref:"
"`module <app_server-modules>`."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:67
msgid "``FILE`` is the path to some file (.lua, .xlog or .snap)."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:69
msgid "``URI`` is the URI of some Tarantool instance."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:71
msgid "``OPTIONS`` are options taken by some ``tarantoolctl`` commands."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:77
#, fuzzy
msgid "Commands for managing Tarantool instances"
msgstr "Команды для tarantoolctl"

#: ../doc/1.7/reference/tarantoolctl.rst:80
#, fuzzy
msgid "``tarantoolctl start NAME``"
msgstr "``tarantoolctl connect``."

#: ../doc/1.7/reference/tarantoolctl.rst:80
msgid "Start a Tarantool instance (if not started; fail otherwise)."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:83
#, fuzzy
msgid "``tarantoolctl stop NAME``"
msgstr "``tarantoolctl connect``."

#: ../doc/1.7/reference/tarantoolctl.rst:83
msgid "Stop a Tarantool instance (if not stopped; fail otherwise)."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:91
#, fuzzy
msgid "``tarantoolctl status NAME``"
msgstr "``tarantoolctl connect``."

#: ../doc/1.7/reference/tarantoolctl.rst:86
msgid ""
"Show an instance's status (started/stopped). If pid file exists and an alive "
"control socket exists, the return code is ``0``. Otherwise, the return code is "
"not ``0``."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:90
msgid ""
"Reports typical problems to stderr (e.g. pid file exists and control socket "
"doesn't)."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:95
#, fuzzy
msgid "``tarantoolctl restart NAME``"
msgstr "``tarantoolctl connect``."

#: ../doc/1.7/reference/tarantoolctl.rst:94
msgid "Stop and start a Tarantool instance (if started; fail otherwise)."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:100
#, fuzzy
msgid "``tarantoolctl logrotate NAME``"
msgstr "``tarantoolctl connect``."

#: ../doc/1.7/reference/tarantoolctl.rst:98
msgid ""
"Rotate logs of a started Tarantool instance. Works only if logging-into-file is "
"enabled in the instance file. Pipe/syslog make no effect."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:103
#, fuzzy
msgid "``tarantoolctl check NAME``"
msgstr "``tarantoolctl connect``."

#: ../doc/1.7/reference/tarantoolctl.rst:103
msgid "Check an instance file for syntax errors."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:106
#, fuzzy
msgid "``tarantoolctl enter NAME``"
msgstr "``tarantoolctl connect``."

#: ../doc/1.7/reference/tarantoolctl.rst:106
msgid "Enter an instance's interactive Lua console."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:110
#, fuzzy
msgid "``tarantoolctl eval NAME FILE``"
msgstr "``tarantoolctl connect``."

#: ../doc/1.7/reference/tarantoolctl.rst:109
msgid ""
"Evaluate a local Lua file on a Tarantool instance (if started; fail otherwise)."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:114
#, fuzzy
msgid "``tarantoolctl connect URI``"
msgstr "``tarantoolctl connect``."

#: ../doc/1.7/reference/tarantoolctl.rst:113
msgid ""
"Connect to a Tarantool instance on an admin-console port. Supports both TCP/Unix "
"sockets."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:120
msgid "Commands for managing checkpoint files"
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:123
msgid ""
"``tarantoolctl cat FILE.. [--space=space_no ..] [--show-system] [--"
"from=from_lsn] [--to=to_lsn] [--replica=replica_id ..]``"
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:123
msgid "Print into stdout the contents of .snap/.xlog files."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:126
msgid ""
"``tarantoolctl play URI FILE.. [--space=space_no ..] [--show-system] [--"
"from=from_lsn] [--to=to_lsn] [--replica=replica_id ..]``"
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:126
msgid "Play the contents of .snap/.xlog files to another Tarantool instance."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:128
#, fuzzy
msgid "Supported options:"
msgstr "Опции комнандной строки"

#: ../doc/1.7/reference/tarantoolctl.rst:130
msgid ""
"``--space=space_no`` to filter the output by space number. May be passed more "
"than once."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:132
msgid "``--show-system`` to show the contents of system spaces."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:133
msgid "``--from=from_lsn`` to show operations starting from the given lsn."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:134
msgid "``--to=to_lsn`` to show operations ending with the given lsn."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:135
msgid ""
"``--replica=replica_id`` to filter the output by replica id. May be passed more "
"than once."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:142
#, fuzzy
msgid "Commands for managing Tarantool modules"
msgstr "Команды для tarantoolctl"

#: ../doc/1.7/reference/tarantoolctl.rst:145
#, fuzzy
msgid "``tarantoolctl rocks install NAME``"
msgstr "``tarantoolctl connect``."

#: ../doc/1.7/reference/tarantoolctl.rst:145
msgid "Install a module in the current directory."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:148
#, fuzzy
msgid "``tarantoolctl rocks remove NAME``"
msgstr "``tarantoolctl connect``."

#: ../doc/1.7/reference/tarantoolctl.rst:148
msgid "Remove a module."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:151
#, fuzzy
msgid "``tarantoolctl rocks show NAME``"
msgstr "``tarantoolctl connect``."

#: ../doc/1.7/reference/tarantoolctl.rst:151
msgid "Show information about an installed module."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:154
#, fuzzy
msgid "``tarantoolctl rocks search NAME``"
msgstr "``tarantoolctl connect``."

#: ../doc/1.7/reference/tarantoolctl.rst:154
#, fuzzy
msgid "Search the repository for modules."
msgstr "искать существующие модули в общем репозитории"

#: ../doc/1.7/reference/tarantoolctl.rst:156
#, fuzzy
msgid "``tarantoolctl rocks list``"
msgstr "``tarantoolctl connect``."

#: ../doc/1.7/reference/tarantoolctl.rst:157
msgid "List all installed modules."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:37
msgid "C tutorial"
msgstr "Практическое задание на C"

#: ../doc/1.7/tutorials/c_tutorial.rst:39
msgid ""
"Here is one C tutorial: :ref:`C stored procedures <f_c_tutorial-"
"c_stored_procedures>`."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:46
msgid "C stored procedures"
msgstr "Хранимые процедуры на языке C"

#: ../doc/1.7/tutorials/c_tutorial.rst:48
msgid ""
"Tarantool can call C code with :ref:`modules <app_server-modules>`, or with :ref:"
"`ffi <cookbook-ffi_printf>`, or with C stored procedures. This tutorial only is "
"about the third option, C stored procedures. In fact the routines are always \"C "
"functions\" but the phrase \"stored procedure\" is commonly used for historical "
"reasons."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:55
msgid ""
"In this tutorial, which can be followed by anyone with a Tarantool development "
"package and a C compiler, there are four tasks. The first -- :code:`easy.c` -- "
"prints \"hello world\". The second -- :code:`harder.c` -- decodes a passed "
"parameter value. The third -- :code:`hardest.c` -- uses the C API to do a DBMS "
"insert. The fourth -- :code:`read.c` -- uses the C API to do a DBMS select."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:62
msgid ""
"After following the instructions, and seeing that the results are what is "
"described here, users should feel confident about writing their own stored "
"procedures."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:66
msgid "**Preparation**"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:68
msgid ""
"Check that these items exist on the computer: |br| * Tarantool 1.7 |br| * A gcc "
"compiler, any modern version should work |br| * \"module.h\" and files #included "
"in it |br| * \"msgpuck.h\" |br| * \"libmsgpuck.a\" (only for some recent msgpuck "
"versions) |br|"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:75
msgid ""
"The \"module.h\" file will exist if Tarantool 1.7 was installed from source. "
"Otherwise Tarantool's \"developer\" package must be installed. For example on "
"Ubuntu say |br| :code:`sudo apt-get install tarantool-dev` |br| or on Fedora say "
"|br| :code:`dnf -y install tarantool-devel`"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:82
msgid ""
"The \"msgpuck.h\" file will exist if Tarantool 1.7 was installed from source. "
"Otherwise the \"msgpuck\" package must be installed from `https://github.com/"
"rtsisyk/msgpuck <https://github.com/rtsisyk/msgpuck>`_."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:86
msgid ""
"Both module.h and msgpuck.h must be on the include path for the C compiler to "
"see them. For example, if module.h address is /usr/local/include/tarantool/"
"module.h, and msgpuck.h address is /usr/local/include/msgpuck/msgpuck.h, and "
"they are not currently on the include path, say |br| :code:`export CPATH=/usr/"
"local/include/tarantool:/usr/local/include/msgpuck`"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:92
msgid ""
"The libmsgpuck.a static library is necessary with msgpuck versions produced "
"after February 2017. If and only if you encounter linking problems when using "
"the gcc statements in the examples for this tutorial, you should put libmsgpuck."
"a on the path (libmsgpuck.a is produced from both msgpuck and Tarantool source "
"downloads so it should be easy to find). For example, instead of \":code:`gcc -"
"shared -o harder.so -fPIC harder.c`\" for the second example below, you will "
"need to say \":code:`gcc -shared -o harder.so -fPIC harder.c libmsgpuck.a`\"."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:101
msgid ""
"Requests will be done using Tarantool as a :ref:`client <admin-"
"using_tarantool_as_a_client>`. Start Tarantool, and enter these requests."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:105
msgid ""
"box.cfg{listen=3306}\n"
"box.schema.space.create('capi_test')\n"
"box.space.capi_test:create_index('primary')\n"
"net_box = require('net.box')\n"
"capi_connection = net_box:new(3306)"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:113
msgid ""
"In plainer language: create a space named capi_test, and make a connection to "
"self named capi_connection."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:116
msgid ""
"Leave the client running. It will be necessary to enter more requests later."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:118
msgid "**easy.c**"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:120
msgid ""
"Start another shell. Change directory (cd) so that it is the same as the "
"directory that the client is running on."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:123
msgid "Create a file. Name it easy.c. Put these six lines in it."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:125
msgid ""
"#include \"module.h\"\n"
"int easy(box_function_ctx_t *ctx, const char *args, const char *args_end)\n"
"{\n"
"  printf(\"hello world\\n\");\n"
"  return 0;\n"
"}"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:134
msgid ""
"Compile the program, producing a library file named easy.so: |br| :code:`gcc -"
"shared -o easy.so -fPIC easy.c`"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:137 ../doc/1.7/tutorials/c_tutorial.rst:206
#: ../doc/1.7/tutorials/c_tutorial.rst:289 ../doc/1.7/tutorials/c_tutorial.rst:380
msgid "Now go back to the client and execute these requests:"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:139
msgid ""
"box.schema.func.create('easy', {language = 'C'})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'easy')\n"
"capi_connection:call('easy')"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:145
msgid ""
"If these requests appear unfamiliar, re-read the descriptions of :ref:`box."
"schema.func.create <box_schema-func_create>` and :ref:`box.schema.user.grant "
"<box_schema-user_grant>` and :ref:`conn:call <net_box-call>`."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:151
msgid "The function that matters is capi_connection:call('easy')."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:153
msgid ""
"Its first job is to find the 'easy' function, which should be easy because by "
"default Tarantool looks on the current directory for a file named easy.so."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:157
msgid ""
"Its second job is to call the 'easy' function. Since the easy() function in easy."
"c begins with :code:`printf(\"hello world\\n\")`, the words \"hello world\" will "
"appear on the screen."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:161
msgid ""
"Its third job is to check that the call was successful. Since the easy() "
"function in easy.c ends with :code:`return 0`, there is no error message to "
"display and the request is over."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:165 ../doc/1.7/tutorials/c_tutorial.rst:307
msgid "The result should look like this:"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:167
msgid ""
"tarantool> capi_connection:call('easy')\n"
"hello world\n"
"---\n"
"- []\n"
"..."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:175
msgid "Conclusion: calling a C function is easy."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:177
msgid "**harder.c**"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:179
msgid "Go back to the shell where the easy.c program was created."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:181
msgid "Create a file. Name it harder.c. Put these 17 lines in it:"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:183
#, python-format
msgid ""
"#include \"module.h\"\n"
"#include \"msgpuck.h\"\n"
"int harder(box_function_ctx_t *ctx, const char *args, const char *args_end)\n"
"{\n"
"  uint32_t arg_count = mp_decode_array(&args);\n"
"  printf(\"arg_count = %d\\n\", arg_count);\n"
"  uint32_t field_count = mp_decode_array(&args);\n"
"  printf(\"field_count = %d\\n\", field_count);\n"
"  uint32_t val;\n"
"  int i;\n"
"  for (i = 0; i < field_count; ++i)\n"
"  {\n"
"    val = mp_decode_uint(&args);\n"
"    printf(\"val=%d.\\n\", val);\n"
"  }\n"
"  return 0;\n"
"}"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:203
msgid ""
"Compile the program, producing a library file named harder.so: |br| :code:`gcc -"
"shared -o harder.so -fPIC harder.c`"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:208
msgid ""
"box.schema.func.create('harder', {language = 'C'})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'harder')\n"
"passable_table = {}\n"
"table.insert(passable_table, 1)\n"
"table.insert(passable_table, 2)\n"
"table.insert(passable_table, 3)\n"
"capi_connection:call('harder', passable_table)"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:218
msgid ""
"This time the call is passing a Lua table (passable_table) to the harder() "
"function. The harder() function will see it, it's in the :code:`char *args` "
"parameter."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:222
msgid ""
"At this point the harder() function will start using functions defined in "
"msgpuck.h, which are documented in `http://rtsisyk.github.io/msgpuck <http://"
"rtsisyk.github.io/msgpuck>`_. The routines that begin with \"mp\" are msgpuck "
"functions that handle data formatted according to the MsgPack_ specification. "
"Passes and returns are always done with this format so one must become "
"acquainted with msgpuck to become proficient with the C API."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:231
msgid ""
"For now, though, it's enough to know that mp_decode_array() returns the number "
"of elements in an array, and mp_decode_uint returns an unsigned integer, from :"
"code:`args`. And there's a side effect: when the decoding finishes, :code:`args` "
"has changed and is now pointing to the next element."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:237
msgid ""
"Therefore the first displayed line will be \"arg_count = 1\" because there was "
"only one item passed: passable_table. |br| The second displayed line will be "
"\"field_count = 3\" because there are three items in the table. |br| The next "
"three lines will be \"1\" and \"2\" and \"3\" because those are the values in "
"the items in the table."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:244
msgid "And now the screen looks like this:"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:246
msgid ""
"tarantool> capi_connection:call('harder', passable_table)\n"
"arg_count = 1\n"
"field_count = 3\n"
"val=1.\n"
"val=2.\n"
"val=3.\n"
"---\n"
"- []\n"
"..."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:258
msgid ""
"Conclusion: decoding parameter values passed to a C function is not easy at "
"first, but there are routines to do the job, and they're documented, and there "
"aren't very many of them."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:263
msgid "**hardest.c**"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:265
msgid ""
"Go back to the shell where the easy.c and the harder.c programs were created."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:268
msgid "Create a file. Name it hardest.c. Put these 13 lines in it:"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:270
msgid ""
"#include \"module.h\"\n"
"#include \"msgpuck.h\"\n"
"int hardest(box_function_ctx_t *ctx, const char *args, const char *args_end)\n"
"{\n"
"  uint32_t space_id = box_space_id_by_name(\"capi_test\", strlen(\"capi_test"
"\"));\n"
"  char tuple[1024];\n"
"  char *tuple_pointer = tuple;\n"
"  tuple_pointer = mp_encode_array(tuple_pointer, 2);\n"
"  tuple_pointer = mp_encode_uint(tuple_pointer, 10000);\n"
"  tuple_pointer = mp_encode_str(tuple_pointer, \"String 2\", 8);\n"
"  int n = box_insert(space_id, tuple, tuple_pointer, NULL);\n"
"  return n;\n"
"}"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:286
msgid ""
"Compile the program, producing a library file named hardest.so: |br| :code:`gcc -"
"shared -o hardest.so -fPIC hardest.c`"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:291
msgid ""
"box.schema.func.create('hardest', {language = \"C\"})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'hardest')\n"
"box.schema.user.grant('guest', 'read,write', 'space', 'capi_test')\n"
"capi_connection:call('hardest')"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:298
msgid ""
"This time the C function is doing three things: |br| (1) finding the numeric "
"identifier of the \"capi_test\" space by calling box_space_id_by_name(); |br| "
"(2) formatting a tuple using more msgpuck.h functions; |br| (3) inserting a "
"tuple using box_insert."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:304
msgid ""
"Now, still on the client, execute this request: |br| :code:`box.space.capi_test:"
"select()`"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:309
msgid ""
"tarantool> box.space.capi_test:select()\n"
"---\n"
"- - [10000, 'String 2']\n"
"..."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:316
msgid ""
"This proves that the hardest() function succeeded, but where did "
"box_space_id_by_name() and box_insert() come from? Answer: the C API. The whole "
"C API is documented :ref:`here <index-c_api_reference>`. The function "
"box_space_id_by_name() is documented :ref:`here <box-box_space_id_by_name>`. The "
"function box_insert() is documented :ref:`here <box-box_insert>`."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:324
msgid "**read.c**"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:326
msgid ""
"Go back to the shell where the easy.c and the harder.c and the hardest.c "
"programs were created."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:329
msgid "Create a file. Name it read.c. Put these 43 lines in it:"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:331
#, python-format
msgid ""
"#include \"module.h\"\n"
"#include <msgpuck.h>\n"
"int read(box_function_ctx_t *ctx, const char *args, const char *args_end)\n"
"{\n"
"  char tuple_buf[1024];      /* where the raw MsgPack tuple will be stored */\n"
"  uint32_t space_id = box_space_id_by_name(\"capi_test\", strlen(\"capi_test"
"\"));\n"
"  uint32_t index_id = 0;     /* The number of the space's first index */\n"
"  uint32_t key = 10000;      /* The key value that box_insert() used */\n"
"  mp_encode_array(tuple_buf, 0); /* clear */\n"
"  box_tuple_format_t *fmt = box_tuple_format_default();\n"
"  box_tuple_t *tuple = box_tuple_new(fmt, tuple_buf, tuple_buf+512);\n"
"  assert(tuple != NULL);\n"
"  char key_buf[16];          /* Pass key_buf = encoded key = 1000 */\n"
"  char *key_end = key_buf;\n"
"  key_end = mp_encode_array(key_end, 1);\n"
"  key_end = mp_encode_uint(key_end, key);\n"
"  assert(key_end < key_buf + sizeof(key_buf));\n"
"  /* Get the tuple. There's no box_select() but there's this. */\n"
"  int r = box_index_get(space_id, index_id, key_buf, key_end, &tuple);\n"
"  assert(r == 0);\n"
"  assert(tuple != NULL);\n"
"  /* Get each field of the tuple + display what you get. */\n"
"  int field_no;             /* The first field number is 0. */\n"
"  for (field_no = 0; field_no < 2; ++field_no)\n"
"  {\n"
"    const char *field = box_tuple_field(tuple, field_no);\n"
"    assert(field != NULL);\n"
"    assert(mp_typeof(*field) == MP_STR || mp_typeof(*field) == MP_UINT);\n"
"    if (mp_typeof(*field) == MP_UINT)\n"
"    {\n"
"      uint32_t uint_value = mp_decode_uint(&field);\n"
"      printf(\"uint value=%u.\\n\", uint_value);\n"
"    }\n"
"    else /* if (mp_typeof(*field) == MP_STR) */\n"
"    {\n"
"      const char *str_value;\n"
"      uint32_t str_value_length;\n"
"      str_value = mp_decode_str(&field, &str_value_length);\n"
"      printf(\"string value=%.*s.\\n\", str_value_length, str_value);\n"
"    }\n"
"  }\n"
"  return 0;\n"
"}"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:377
msgid ""
"Compile the program, producing a library file named read.so: |br| :code:`gcc -"
"shared -o read.so -fPIC read.c`"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:382
msgid ""
"box.schema.func.create('read', {language = \"C\"})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'read')\n"
"box.schema.user.grant('guest', 'read,write', 'space', 'capi_test')\n"
"capi_connection:call('read')"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:389
msgid ""
"This time the C function is doing four things: |br| (1) once again, finding the "
"numeric identifier of the \"capi_test\" space by calling box_space_id_by_name(); "
"|br| (2) formatting a search key = 10000 using more msgpuck.h functions; |br| "
"(3) getting a tuple using box_index_get' |br| (4) going through the tuple's "
"fields with box_tuple_get() and then decoding each field depending  on its type. "
"In this case, since what we are getting is the tuple that we inserted with "
"hardest.c, we know in advance that the type is either MP_UINT or MP_STR; "
"however, it's very common to have a case statement here with one option for each "
"possible type."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:401
#, fuzzy
msgid "The result of capi_connection:call('read') should look like this:"
msgstr "C-файл в нашем примере будет таким:"

#: ../doc/1.7/tutorials/c_tutorial.rst:403
msgid ""
"tarantool> capi_connection:call('read')\n"
"uint value=10000.\n"
"string value=String 2.\n"
"---\n"
"- []\n"
"..."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:412
msgid ""
"This proves that the read() function succeeded. Once again the important "
"functions that start with `box` came from the C API. The function "
"box_index_get() is documented :ref:`here <c_api-box_index-box_index_get>`. The "
"function box_tuple_field() is documented :ref:`here <c_api-tuple-"
"box_tuple_field>`."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:417
msgid ""
"Conclusion: the long description of the whole C API is there for a good reason. "
"All of the functions in it can be called from C functions which are called from "
"Lua. So C \"stored procedures\" have full access to the database."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:424
msgid "**Cleaning up**"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:426
msgid ""
"Get rid of each of the function tuples with :ref:`box.schema.func.drop "
"<box_schema-func_drop>`, and get rid of the capi_test space with :ref:`box."
"schema.capi_test:drop() <box_space-drop>`, and remove the .c and .so files that "
"were created for this tutorial."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:431
msgid "**An example in the test suite**"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:433
msgid ""
"Download the source code of Tarantool. Look in a subdirectory :code:`test/box`. "
"Notice that there is a file named :code:`tuple_bench.test.lua` and another file "
"named :code:`tuple_bench.c`. Examine the Lua file and observe that it is calling "
"a function in the C file, using the same techniques that this tutorial has shown."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:440
msgid ""
"Conclusion: parts of the standard test suite use C stored procedures, and they "
"must work, because releases don't happen if Tarantool doesn't pass the tests."
msgstr ""

#: ../doc/1.7/tutorials/index.rst:39
msgid "Tutorials"
msgstr "Практикум"

#: ../doc/1.7/tutorials/libslave.rst:39
#, fuzzy
msgid "`libslave` tutorial"
msgstr "Практические задания на Lua"

#: ../doc/1.7/tutorials/libslave.rst:41
msgid ""
"``libslave`` is a C++ library for reading data changes done by MysQL and, "
"optionally, writing them to a Tarantool database. It works by acting as a "
"replication slave. The MySQL server writes data-change information to a \"binary "
"log\", and transfers the information to any client that says \"I want to see the "
"information starting with this file and this record, continuously\". So, "
"``libslave`` is primarily good for making a Tarantool database replica (much "
"faster than using a conventional MySQL slave server), and for keeping track of "
"data changes so they can be searched."
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:52
msgid ""
"We will not go into the many details here -- the `API documentation <https://"
"github.com/vozbu/libslave/wiki/API>`_ has them. We will only show an exercise: a "
"minimal program that uses the library."
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:58
msgid "Use a test machine. Do not use a production machine."
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:60
msgid "STEP 1: Make sure you have:"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:62
msgid "a recent version of Linux (versions such as Ubuntu 14.04 will not do),"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:63
msgid "a recent version of MySQL 5.6 or MySQL 5.7 server (MariaDB will not do),"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:64
msgid ""
"MySQL client development package. For example, on Ubuntu you can download it "
"with this command:"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:67
#, fuzzy
msgid "sudo apt-get install mysql-client-core-5.7"
msgstr "$ sudo apt-get install luarocks"

#: ../doc/1.7/tutorials/libslave.rst:71
msgid "STEP 2: Download ``libslave``."
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:73
msgid ""
"The recommended source is https://github.com/tarantool/libslave/. Downloads "
"include the source code only."
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:76
#, fuzzy
msgid ""
"sudo apt-get install libboost-all-dev\n"
"cd ~\n"
"git clone https://github.com/tarantool/libslave.git tarantool-libslave\n"
"cd tarantool-libslave\n"
"git submodule init\n"
"git submodule update\n"
"cmake .\n"
"make"
msgstr ""
"$ git clone git://github.com/tarantool/tarantool-c.git ~/tarantool-c\n"
"$ cd ~/tarantool-c\n"
"$ git submodule init\n"
"$ git submodule update\n"
"$ cmake .\n"
"$ make\n"
"$ make install"

#: ../doc/1.7/tutorials/libslave.rst:87
msgid ""
"If you see an error message mentioning the word \"vector\", edit ``field.h`` and "
"add this line:"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:90
msgid "#include <vector>"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:94
msgid ""
"STEP 3: Start the MySQL server. On the command line, add appropriate switches "
"for doing replication. For example:"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:97
msgid "mysqld --log-bin=mysql-bin --server-id=1"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:101
msgid "STEP 4: For purposes of this exercise, we are assuming you have:"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:103
msgid "a \"root\" user with password \"root\" with privileges,"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:104
msgid "a \"test\" database with a table named \"test\","
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:105
msgid "a binary log named \"mysql-bin\","
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:106
msgid "a server with server id = 1."
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:108
msgid ""
"The values are hard-coded in the program, though of course you can change the "
"program -- it's easy to see their settings."
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:111
msgid "STEP 5: Look at the program:"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:113
msgid ""
"#include <unistd.h>\n"
"#include <iostream>\n"
"#include <sstream>\n"
"#include \"Slave.h\"\n"
"#include \"DefaultExtState.h\"\n"
"\n"
"slave::Slave* sl = NULL;\n"
"\n"
"void callback(const slave::RecordSet& event) {\n"
"    slave::Slave::binlog_pos_t sBinlogPos = sl->getLastBinlog();\n"
"    switch (event.type_event) {\n"
"    case slave::RecordSet::Update: std::cout << \"UPDATE\" << \"\\n\"; break;\n"
"    case slave::RecordSet::Delete: std::cout << \"DELETE\" << \"\\n\"; break;\n"
"    case slave::RecordSet::Write:  std::cout << \"INSERT\" << \"\\n\"; break;\n"
"    default: break;\n"
"    }\n"
"}\n"
"\n"
"bool isStopping()\n"
"{\n"
"    return 0;\n"
"}\n"
"\n"
"int main(int argc, char** argv)\n"
"{\n"
"    slave::MasterInfo masterinfo;\n"
"    masterinfo.conn_options.mysql_host = \"127.0.0.1\";\n"
"    masterinfo.conn_options.mysql_port = 3306;\n"
"    masterinfo.conn_options.mysql_user = \"root\";\n"
"    masterinfo.conn_options.mysql_pass = \"root\";\n"
"    bool error = false;\n"
"    try {\n"
"        slave::DefaultExtState sDefExtState;\n"
"        slave::Slave slave(masterinfo, sDefExtState);\n"
"        sl = &slave;\n"
"        sDefExtState.setMasterLogNamePos(\"mysql-bin\", 0);\n"
"        slave.setCallback(\"test\", \"test\", callback);\n"
"        slave.init();\n"
"        slave.createDatabaseStructure();\n"
"        try {\n"
"            slave.get_remote_binlog(isStopping);\n"
"        } catch (std::exception& ex) {\n"
"            std::cout << \"Error reading: \" << ex.what() << std::endl;\n"
"            error = true;\n"
"        }\n"
"    } catch (std::exception& ex) {\n"
"        std::cout << \"Error initializing: \" << ex.what() << std::endl;\n"
"        error = true;\n"
"    }\n"
"    return 0;\n"
"}"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:167
msgid ""
"Everything unnecessary has been stripped so that you can see quickly how it "
"works. At the start of ``main()``, there are some settings used for connecting "
"-- host, port, user, password. Then there is an initialization call with the "
"binary log file name = \"mysql-bin\". Pay particular attention to the "
"``setCallback`` statement, which passes database name = \"test\", table name = "
"\"test\", and callback function address = callback. The program will be looping "
"and invoking this callback function. See how, earlier in the program, the "
"callback function prints \"UPDATE\" or \"DELETE\" or \"INSERT\" depending on "
"what is passed to it."
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:178
msgid ""
"STEP 5: Put the program in the ``tarantool-libslave`` directory and name it "
"``example.cpp``."
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:181
msgid "Step 6: Compile and build:"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:183
msgid ""
"g++ -I/tarantool-libslave/include example.cpp -o example libslave_a.a -ldl -"
"lpthread"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:189
msgid "Replace ``tarantool-libslave/include`` with the full directory name."
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:191
msgid ""
"Notice that the name of the static library is ``libslave_a.a``, not ``libslave."
"a``."
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:194
msgid "Step 7: Run:"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:196
#, fuzzy
msgid "./example"
msgstr "Пример"

#: ../doc/1.7/tutorials/libslave.rst:200
msgid ""
"The result will be nothing -- the program is looping, waiting for the MySQL "
"server to write to the replication binary log."
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:203
msgid ""
"Step 8: Start a MySQL client program -- any client program will do. Enter these "
"statements:"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:206
msgid ""
"USE test\n"
"INSERT INTO test VALUES ('A');\n"
"INSERT INTO test VALUES ('B');\n"
"DELETE FROM test;"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:213
msgid "Watch what happens in ``example.cpp`` output -- it displays:"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:215
msgid ""
"INSERT\n"
"INSERT\n"
"DELETE\n"
"DELETE"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:222
msgid ""
"This is row-based replication, so you see two DELETEs, because there are two "
"rows."
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:225
msgid "What the exercise has shown is:"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:227
msgid "the library can be built, and"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:228
msgid ""
"programs that use the library can access everything that the MySQL server dumps."
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:231
msgid "For the many details and examples of usage in the field, see:"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst
msgid "Our downloadable ``libslave`` version:"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst
#, fuzzy
msgid "https://github.com/tarantool/libslave"
msgstr "См. http://github.com/tarantool/tarantool-java/."

#: ../doc/1.7/tutorials/libslave.rst
msgid "The version it was forked from (with a different README):"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst
msgid "https://github.com/vozbu/libslave/wiki/API"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:239
msgid ""
"`How to speed up your MySQL with replication to in-memory database <http://"
"highscalability.com/blog/2017/3/29/how-to-speed-up-your-mysql-with-replication-"
"to-in-memory-dat.html>`_ article"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:241
msgid ""
"`Replicating data from MySQL to Tarantool <https://habrahabr.ru/company/mailru/"
"blog/323870/>`_ article (in Russian)"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:243
msgid ""
"`Asynchronous replication uncensored <https://habrahabr.ru/company/oleg-bunin/"
"blog/313594/>`_ article (in Russian)"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:39
msgid "Lua tutorials"
msgstr "Практические задания на Lua"

#: ../doc/1.7/tutorials/lua_tutorials.rst:41
msgid "Here are three tutorials on using Lua stored procedures with Tarantool:"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:43
msgid ""
":ref:`Insert one million tuples with a Lua stored procedure <c_lua_tutorial-"
"insert_one_million_tuples>`,"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:44
msgid ":ref:`Sum a JSON field for all tuples <c_lua_tutorial-sum_a_json_field>`,"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:45
msgid ":ref:`Indexed pattern search <c_lua_tutorial-indexed_pattern_search>`."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:51
msgid "Insert one million tuples with a Lua stored procedure"
msgstr "Вставка 1 млн кортежей с помощью хранимой процедуры на языке Lua"

#: ../doc/1.7/tutorials/lua_tutorials.rst:53
msgid ""
"This is an exercise assignment: “Insert one million tuples. Each tuple should "
"have a constantly-increasing numeric primary-key field and a random alphabetic "
"10-character string field.”"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:57
msgid ""
"The purpose of the exercise is to show what Lua functions look like inside "
"Tarantool. It will be necessary to employ the Lua math library, the Lua string "
"library, the Tarantool box library, the Tarantool box.tuple library, loops, and "
"concatenations. It should be easy to follow even for a person who has not used "
"either Lua or Tarantool before. The only requirement is a knowledge of how other "
"programming languages work and a memory of the first two chapters of this "
"manual. But for better understanding, follow the comments and the links, which "
"point to the Lua manual or to elsewhere in this Tarantool manual. To further "
"enhance learning, type the statements in with the tarantool client while reading "
"along."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:69
msgid "Configure"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:71
msgid ""
"We are going to use the Tarantool sandbox that was created for our :ref:`"
"\"Getting started\" exercises <getting_started>`. So there is a single space, "
"and a numeric primary key, and a running Tarantool server instance which also "
"serves as a client."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:78
msgid "Delimiter"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:80
msgid ""
"In earlier versions of Tarantool, multi-line functions had to be enclosed within "
"\"delimiters\". They are no longer necessary, and so they will not be used in "
"this tutorial. However, they are still supported. Users who wish to use "
"delimiters, or users of older versions of Tarantool, should check the syntax "
"description for :ref:`declaring a delimiter <console-delimiter>` before "
"proceeding."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:89
msgid "Create a function that returns a string"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:91
msgid ""
"We will start by making a function that returns a fixed string, “Hello world”."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:93
msgid ""
"function string_function()\n"
"  return \"hello world\"\n"
"end"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:99
msgid ""
"The word \"``function``\" is a Lua keyword -- we're about to go into Lua. The "
"function name is string_function. The function has one executable statement, "
"``return \"hello world\"``. The string \"hello world\" is enclosed in double "
"quotes here, although Lua doesn't care -- one could use single quotes instead. "
"The word \"``end``\" means “this is the end of the Lua function declaration.” To "
"confirm that the function works, we can say"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:106
msgid "string_function()"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:110
msgid ""
"Sending ``function-name()`` means “invoke the Lua function.” The effect is that "
"the string which the function returns will end up on the screen."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:113
msgid ""
"For more about Lua strings see Lua manual `chapter 2.4 \"Strings\"`_ . For more "
"about functions see Lua manual `chapter 5 \"Functions\"`_."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:119
#: ../doc/1.7/tutorials/lua_tutorials.rst:163
#: ../doc/1.7/tutorials/lua_tutorials.rst:215
#: ../doc/1.7/tutorials/lua_tutorials.rst:271
#: ../doc/1.7/tutorials/lua_tutorials.rst:317
#: ../doc/1.7/tutorials/lua_tutorials.rst:377
#: ../doc/1.7/tutorials/lua_tutorials.rst:470
msgid "The screen now looks like this:"
msgstr "Теперь вывод на экране выглядит следующим образом:"

#: ../doc/1.7/tutorials/lua_tutorials.rst:121
msgid ""
"tarantool> function string_funciton()\n"
"         >   return \"hello world\"\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> string_function()\n"
"---\n"
"- hello world\n"
"...\n"
"tarantool>"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:136
msgid "Create a function that calls another function and sets a variable"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:138
msgid ""
"Now that ``string_function`` exists, we can invoke it from another function."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:141
msgid ""
"function main_function()\n"
"  local string_value\n"
"  string_value = string_function()\n"
"  return string_value\n"
"end"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:149
msgid ""
"We begin by declaring a variable \"``string_value``\". The word \"``local``\" "
"means that string_value appears only in ``main_function``. If we didn't use "
"\"``local``\" then ``string_value`` would be visible everywhere - even by other "
"users using other clients connected to this server instance! Sometimes that's a "
"very desirable feature for inter-client communication, but not this time."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:155
msgid ""
"Then we assign a value to ``string_value``, namely, the result of "
"``string_function()``. Soon we will invoke ``main_function()`` to check that it "
"got the value."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:159
msgid ""
"For more about Lua variables see Lua manual `chapter 4.2 \"Local Variables and "
"Blocks\"`_ ."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:165
msgid ""
"tarantool> function main_function()\n"
"         >   local string_value\n"
"         >   string_value = string_function()\n"
"         >   return string_value\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- hello world\n"
"...\n"
"tarantool>"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:182
msgid "Modify the function so it returns a one-letter random string"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:184
msgid ""
"Now that it's a bit clearer how to make a variable, we can change "
"``string_function()`` so that, instead of returning a fixed literal \"Hello world"
"\", it returns a random letter between 'A' and 'Z'."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:188
msgid ""
"function string_function()\n"
"  local random_number\n"
"  local random_string\n"
"  random_number = math.random(65, 90)\n"
"  random_string = string.char(random_number)\n"
"  return random_string\n"
"end"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:198
msgid ""
"It is not necessary to destroy the old ``string_function()`` contents, they're "
"simply overwritten. The first assignment invokes a random-number function in "
"Lua's math library; the parameters mean “the number must be an integer between "
"65 and 90.” The second assignment invokes an integer-to-character function in "
"Lua's string library; the parameter is the code point of the character. Luckily "
"the ASCII value of 'A' is 65 and the ASCII value of 'Z' is 90 so the result will "
"always be a letter between A and Z."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:206
msgid ""
"For more about Lua math-library functions see Lua users \"`Math Library "
"Tutorial`_\". For more about Lua string-library functions see Lua users "
"\"`String Library Tutorial`_\" ."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:212
msgid ""
"Once again the ``string_function()`` can be invoked from main_function() which "
"can be invoked with ``main_function()``."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:217
msgid ""
"tarantool> function string_function()\n"
"         >   local random_number\n"
"         >   local random_string\n"
"         >   random_number = math.random(65, 90)\n"
"         >   random_string = string.char(random_number)\n"
"         >   return random_string\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- C\n"
"...\n"
"tarantool>"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:234
msgid ""
"... Well, actually it won't always look like this because ``math.random()`` "
"produces random numbers. But for the illustration purposes it won't matter what "
"the random string values are."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:240
msgid "Modify the function so it returns a ten-letter random string"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:242
msgid ""
"Now that it's clear how to produce one-letter random strings, we can reach our "
"goal of producing a ten-letter string by concatenating ten one-letter strings, "
"in a loop."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:246
msgid ""
"function string_function()\n"
"  local random_number\n"
"  local random_string\n"
"  random_string = \"\"\n"
"  for x = 1,10,1 do\n"
"    random_number = math.random(65, 90)\n"
"    random_string = random_string .. string.char(random_number)\n"
"  end\n"
"  return random_string\n"
"end"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:259
msgid ""
"The words \"for x = 1,10,1\" mean “start with x equals 1, loop until x equals "
"10, increment x by 1 for each iteration.” The symbol \"..\" means \"concatenate"
"\", that is, add the string on the right of the \"..\" sign to the string on the "
"left of the \"..\" sign. Since we start by saying that random_string is \"\" (a "
"blank string), the end result is that random_string has 10 random letters. Once "
"again the ``string_function()`` can be invoked from ``main_function()`` which "
"can be invoked with ``main_function()``."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:267
msgid "For more about Lua loops see Lua manual `chapter 4.3.4 \"Numeric for\"`_."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:273
msgid ""
"tarantool> function string_function()\n"
"         >   local random_number\n"
"         >   local random_string\n"
"         >   random_string = \"\"\n"
"         >   for x = 1,10,1 do\n"
"         >     random_number = math.random(65, 90)\n"
"         >     random_string = random_string .. string.char(random_number)\n"
"         >   end\n"
"         >   return random_string\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- 'ZUDJBHKEFM'\n"
"...\n"
"tarantool>"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:295
msgid "Make a tuple out of a number and a string"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:297
msgid ""
"Now that it's clear how to make a 10-letter random string, it's possible to make "
"a tuple that contains a number and a 10-letter random string, by invoking a "
"function in Tarantool's library of Lua functions."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:301
msgid ""
"function main_function()\n"
"  local string_value, t\n"
"  string_value = string_function()\n"
"  t = box.tuple.new({1, string_value})\n"
"  return t\n"
"end"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:310
msgid ""
"Once this is done, t will be the value of a new tuple which has two fields. The "
"first field is numeric: 1. The second field is a random string. Once again the "
"``string_function()`` can be invoked from ``main_function()`` which can be "
"invoked with  ``main_function()``."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:315
msgid ""
"For more about Tarantool tuples see Tarantool manual section :ref:`Submodule box."
"tuple <box_tuple>`."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:319
msgid ""
"tarantool> function main_function()\n"
"         > local string_value, t\n"
"         > string_value = string_function()\n"
"         > t = box.tuple.new({1, string_value})\n"
"         > return t\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- [1, 'PNPZPCOOKA']\n"
"...\n"
"tarantool>"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:337
msgid "Modify main_function to insert a tuple into the database"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:339
msgid ""
"Now that it's clear how to make a tuple that contains a number and a 10-letter "
"random string, the only trick remaining is putting that tuple into tester. "
"Remember that tester is the first space that was defined in the sandbox, so it's "
"like a database table."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:344
msgid ""
"function main_function()\n"
"  local string_value, t\n"
"  string_value = string_function()\n"
"  t = box.tuple.new({1,string_value})\n"
"  box.space.tester:replace(t)\n"
"end"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:353
msgid ""
"The new line here is ``box.space.tester:replace(t)``. The name contains 'tester' "
"because the insertion is going to be to tester. The second parameter is the "
"tuple value. To be perfectly correct we could have said ``box.space.tester:"
"insert(t)`` here, rather than ``box.space.tester:replace(t)``, but \"replace\" "
"means “insert even if there is already a tuple whose primary-key value is a "
"duplicate”, and that makes it easier to re-run the exercise even if the sandbox "
"database isn't empty. Once this is done, tester will contain a tuple with two "
"fields. The first field will be 1. The second field will be a random 10-letter "
"string. Once again the ``string_function(``) can be invoked from "
"``main_function()`` which can be invoked with ``main_function()``. But "
"``main_function()`` won't tell the whole story, because it does not return t, it "
"only puts t into the database. To confirm that something got inserted, we'll use "
"a SELECT request."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:367
msgid ""
"main_function()\n"
"box.space.tester:select{1}"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:372
msgid ""
"For more about Tarantool insert and replace calls, see Tarantool manual section :"
"ref:`Submodule box.space <box_space>`, :ref:`space_object:insert() <box_space-"
"insert>`, and :ref:`space_object:replace() <box_space-replace>`."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:379
msgid ""
"tarantool> function main_function()\n"
"         >   local string_value, t\n"
"         >   string_value = string_function()\n"
"         >   t = box.tuple.new({1,string_value})\n"
"         >   box.space.tester:replace(t)\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"...\n"
"tarantool> box.space.tester:select{1}\n"
"---\n"
"- - [1, 'EUJYVEECIL']\n"
"...\n"
"tarantool>"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:400
msgid "Modify main_function to insert a million tuples into the database"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:402
msgid ""
"Now that it's clear how to insert one tuple into the database, it's no big deal "
"to figure out how to scale up: instead of inserting with a literal value = 1 for "
"the primary key, insert with a variable value = between 1 and 1 million, in a "
"loop. Since we already saw how to loop, that's a simple thing. The only extra "
"wrinkle that we add here is a timing function."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:408
msgid ""
"function main_function()\n"
"  local string_value, t\n"
"  for i = 1,1000000,1 do\n"
"    string_value = string_function()\n"
"    t = box.tuple.new({i,string_value})\n"
"    box.space.tester:replace(t)\n"
"  end\n"
"end\n"
"start_time = os.clock()\n"
"main_function()\n"
"end_time = os.clock()\n"
"'insert done in ' .. end_time - start_time .. ' seconds'"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:423
msgid ""
"The standard Lua function `os.clock() <http://www.lua.org/manual/5.1/manual."
"html#pdf-os.clock>`_ will return the number of CPU seconds since the start. "
"Therefore, by getting start_time = number of seconds just before the inserting, "
"and then getting end_time = number of seconds just after the inserting, we can "
"calculate (end_time - start_time) = elapsed time in seconds. We will display "
"that value by putting it in a request without any assignments, which causes "
"Tarantool to send the value to the client, which prints it. (Lua's answer to the "
"C ``printf()`` function, which is ``print()``, will also work.)"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:433
msgid ""
"For more on Lua ``os.clock()`` see Lua manual `chapter 22.1 \"Date and Time\"`_. "
"For more on Lua print() see Lua manual `chapter 5 \"Functions\"`_."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:439
msgid ""
"Since this is the grand finale, we will redo the final versions of all the "
"necessary requests: the request that created ``string_function()``, the request "
"that created ``main_function()``, and the request that invokes "
"``main_function()``."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:444
msgid ""
"function string_function()\n"
"  local random_number\n"
"  local random_string\n"
"  random_string = \"\"\n"
"  for x = 1,10,1 do\n"
"    random_number = math.random(65, 90)\n"
"    random_string = random_string .. string.char(random_number)\n"
"  end\n"
"  return random_string\n"
"end\n"
"\n"
"function main_function()\n"
"  local string_value, t\n"
"  for i = 1,1000000,1 do\n"
"    string_value = string_function()\n"
"    t = box.tuple.new({i,string_value})\n"
"    box.space.tester:replace(t)\n"
"  end\n"
"end\n"
"start_time = os.clock()\n"
"main_function()\n"
"end_time = os.clock()\n"
"'insert done in ' .. end_time - start_time .. ' seconds'"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:472
msgid ""
"tarantool> function string_function()\n"
"         >   local random_number\n"
"         >   local random_string\n"
"         >   random_string = \"\"\n"
"         >   for x = 1,10,1 do\n"
"         >     random_number = math.random(65, 90)\n"
"         >     random_string = random_string .. string.char(random_number)\n"
"         >   end\n"
"         >   return random_string\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> function main_function()\n"
"         >   local string_value, t\n"
"         >   for i = 1,1000000,1 do\n"
"         >     string_value = string_function()\n"
"         >     t = box.tuple.new({i,string_value})\n"
"         >     box.space.tester:replace(t)\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> start_time = os.clock()\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"...\n"
"tarantool> end_time = os.clock()\n"
"---\n"
"...\n"
"tarantool> 'insert done in ' .. end_time - start_time .. ' seconds'\n"
"---\n"
"- insert done in 37.62 seconds\n"
"...\n"
"tarantool>"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:511
msgid ""
"What has been shown is that Lua functions are quite expressive (in fact one can "
"do more with Tarantool's Lua stored procedures than one can do with stored "
"procedures in some SQL DBMSs), and that it's straightforward to combine Lua-"
"library functions and Tarantool-library functions."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:516
msgid ""
"What has also been shown is that inserting a million tuples took 37 seconds. The "
"host computer was a Linux laptop. By changing :ref:`wal_mode "
"<cfg_binary_logging_snapshots-wal_mode>` to 'none' before running the test, one "
"can reduce the elapsed time to 4 seconds."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:524
msgid "Sum a JSON field for all tuples"
msgstr "Подсчет суммы по JSON-полям во всех кортежах"

#: ../doc/1.7/tutorials/lua_tutorials.rst:526
msgid ""
"This is an exercise assignment: “Assume that inside every tuple there is a "
"string formatted as JSON. Inside that string there is a JSON numeric field. For "
"each tuple, find the numeric field's value and add it to a 'sum' variable. At "
"end, return the 'sum' variable.” The purpose of the exercise is to get "
"experience in one way to read and process tuples."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:532
msgid ""
"json = require('json')\n"
"function sum_json_field(field_name)\n"
"  local v, t, sum, field_value, is_valid_json, lua_table\n"
"  sum = 0\n"
"  for v, t in box.space.tester:pairs() do\n"
"    is_valid_json, lua_table = pcall(json.decode, t[2])\n"
"    if is_valid_json then\n"
"      field_value = lua_table[field_name]\n"
"      if type(field_value) == \"number\" then sum = sum + field_value end\n"
"    end\n"
"  end\n"
"  return sum\n"
"end"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:549
msgid ""
"**LINE 3: WHY \"LOCAL\".** This line declares all the variables that will be "
"used in the function. Actually it's not necessary to declare all variables at "
"the start, and in a long function it would be better to declare variables just "
"before using them. In fact it's not even necessary to declare variables at all, "
"but an undeclared variable is \"global\". That's not desirable for any of the "
"variables that are declared in line 1, because all of them are for use only "
"within the function."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:556
msgid ""
"**LINE 5: WHY \"PAIRS()\".** Our job is to go through all the rows and there are "
"two ways to do it: with :ref:`box.space.space_object:pairs() <box_space-pairs>` "
"or with ``variable = select(...)`` followed by :samp:`for i, {n}, 1 do {some-"
"function}(variable[i]) end`. We preferred ``pairs()`` for this example."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:561
msgid ""
"**LINE 5: START THE MAIN LOOP.** Everything inside this \"``for``\" loop will be "
"repeated as long as there is another index key. A tuple is fetched and can be "
"referenced with variable :code:`t`."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:565
msgid ""
"**LINE 6: WHY \"PCALL\".** If we simply said ``lua_table = json.decode(t[2]))``, "
"then the function would abort with an error if it encountered something wrong "
"with the JSON string - a missing colon, for example. By putting the function "
"inside \"``pcall``\" (`protected call`_), we're saying: we want to intercept "
"that sort of error, so if there's a problem just set ``is_valid_json = false`` "
"and we will know what to do about it later."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:572
msgid ""
"**LINE 6: MEANING.** The function is :ref:`json.decode <json-decode>` which "
"means decode a JSON string, and the parameter is t[2] which is a reference to a "
"JSON string. There's a bit of hard coding here, we're assuming that the second "
"field in the tuple is where the JSON string was inserted. For example, we're "
"assuming a tuple looks like"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:582
msgid ""
"field[1]: 444\n"
"field[2]: '{\"Hello\": \"world\", \"Quantity\": 15}'"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:585
msgid ""
"meaning that the tuple's first field, the primary key field, is a number while "
"the tuple's second field, the JSON string, is a string. Thus the entire "
"statement means \"decode ``t[2]`` (the tuple's second field) as a JSON string; "
"if there's an error set ``is_valid_json = false``; if there's no error set "
"``is_valid_json = true`` and set ``lua_table =`` a Lua table which has the "
"decoded string\"."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:591
msgid ""
"**LINE 8.** At last we are ready to get the JSON field value from the Lua table "
"that came from the JSON string. The value in field_name, which is the parameter "
"for the whole function, must be a name of a JSON field. For example, inside the "
"JSON string ``'{\"Hello\": \"world\", \"Quantity\": 15}'``, there are two JSON "
"fields: \"Hello\" and \"Quantity\". If the whole function is invoked with "
"``sum_json_field(\"Quantity\")``, then ``field_value = lua_table[field_name]`` "
"is effectively the same as ``field_value = lua_table[\"Quantity\"]`` or even "
"``field_value = lua_table.Quantity``. Those are just three different ways of "
"saying: for the Quantity field in the Lua table, get the value and put it in "
"variable :code:`field_value`."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:601
msgid ""
"**LINE 9: WHY \"IF\".** Suppose that the JSON string is well formed but the JSON "
"field is not a number, or is missing. In that case, the function would be "
"aborted when there was an attempt to add it to the sum. By first checking "
"``type(field_value) == \"number\"``, we avoid that abortion. Anyone who knows "
"that the database is in perfect shape can skip this kind of thing."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:607
msgid ""
"And the function is complete. Time to test it. Starting with an empty database, "
"defined the same way as the sandbox database in our :ref:`\"Getting started\" "
"exercises <getting_started>`,"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:611
msgid ""
"-- if tester is left over from some previous test, destroy it\n"
"box.space.tester:drop()\n"
"box.schema.space.create('tester')\n"
"box.space.tester:create_index('primary', {parts = {1, 'unsigned'}})"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:618
msgid ""
"then add some tuples where the first field is a number and the second field is a "
"string."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:621
msgid ""
"box.space.tester:insert{444, '{\"Item\": \"widget\", \"Quantity\": 15}'}\n"
"box.space.tester:insert{445, '{\"Item\": \"widget\", \"Quantity\": 7}'}\n"
"box.space.tester:insert{446, '{\"Item\": \"golf club\", \"Quantity\": \"sunshine"
"\"}'}\n"
"box.space.tester:insert{447, '{\"Item\": \"waffle iron\", \"Quantit\": 3}'}"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:628
msgid ""
"Since this is a test, there are deliberate errors. The \"golf club\" and the "
"\"waffle iron\" do not have numeric Quantity fields, so must be ignored. "
"Therefore the real sum of the Quantity field in the JSON strings should be: 15 + "
"7 = 22."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:633
msgid "Invoke the function with ``sum_json_field(\"Quantity\")``."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:635
msgid ""
"tarantool> sum_json_field(\"Quantity\")\n"
"---\n"
"- 22\n"
"..."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:642
msgid ""
"It works. We'll just leave, as exercises for future improvement, the possibility "
"that the \"hard coding\" assumptions could be removed, that there might have to "
"be an overflow check if some field values are huge, and that the function should "
"contain a :ref:`yield <atomic-threads_fibers_yields>` instruction if the count "
"of tuples is huge."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:651
msgid "Indexed pattern search"
msgstr "Индексированный поиск по шаблонам"

#: ../doc/1.7/tutorials/lua_tutorials.rst:653
msgid ""
"Here is a generic function which takes a field identifier and a search pattern, "
"and returns all tuples that match. |br| * The field must be the first field of a "
"TREE index. |br| * The function will use `Lua pattern matching <http://www.lua."
"org/manual/5.2/manual.html#6.4.1>`_, which allows \"magic characters\" in "
"regular expressions. |br| * The initial characters in the pattern, as far as the "
"first magic character, will be used as an index search key. For each tuple that "
"is found via the index, there will be a match of the whole pattern. |br| * To "
"be :ref:`cooperative <atomic-cooperative_multitasking>`, the function should "
"yield after every 10 tuples, unless there is a reason to delay yielding. |br| "
"With this function, we can take advantage of Tarantool's indexes for speed, and "
"take advantage of Lua's pattern matching for flexibility. It does everything "
"that an SQL \"LIKE\" search can do, and far more."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:670
msgid ""
"Read the following Lua code to see how it works. The comments that begin with "
"\"SEE NOTE ...\" refer to long explanations that follow the code."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:674
msgid ""
"function indexed_pattern_search(space_name, field_no, pattern)\n"
"  -- SEE NOTE #1 \"FIND AN APPROPRIATE INDEX\"\n"
"  if (box.space[space_name] == nil) then\n"
"    print(\"Error: Failed to find the specified space\")\n"
"    return nil\n"
"  end\n"
"  local index_no = -1\n"
"  for i=0,box.schema.INDEX_MAX,1 do\n"
"    if (box.space[space_name].index[i] == nil) then break end\n"
"    if (box.space[space_name].index[i].type == \"TREE\"\n"
"        and box.space[space_name].index[i].parts[1].fieldno == field_no\n"
"        and (box.space[space_name].index[i].parts[1].type == \"scalar\"\n"
"        or box.space[space_name].index[i].parts[1].type == \"string\")) then\n"
"      index_no = i\n"
"      break\n"
"    end\n"
"  end\n"
"  if (index_no == -1) then\n"
"    print(\"Error: Failed to find an appropriate index\")\n"
"    return nil\n"
"  end\n"
"  -- SEE NOTE #2 \"DERIVE INDEX SEARCH KEY FROM PATTERN\"\n"
"  local index_search_key = \"\"\n"
"  local index_search_key_length = 0\n"
"  local last_character = \"\"\n"
"  local c = \"\"\n"
"  local c2 = \"\"\n"
"  for i=1,string.len(pattern),1 do\n"
"    c = string.sub(pattern, i, i)\n"
"    if (last_character ~= \"%\") then\n"
"      if (c == '^' or c == \"$\" or c == \"(\" or c == \")\" or c == \".\"\n"
"                   or c == \"[\" or c == \"]\" or c == \"*\" or c == \"+\"\n"
"                   or c == \"-\" or c == \"?\") then\n"
"        break\n"
"      end\n"
"      if (c == \"%\") then\n"
"        c2 = string.sub(pattern, i + 1, i + 1)\n"
"        if (string.match(c2, \"%p\") == nil) then break end\n"
"        index_search_key = index_search_key .. c2\n"
"      else\n"
"        index_search_key = index_search_key .. c\n"
"      end\n"
"    end\n"
"    last_character = c\n"
"  end\n"
"  index_search_key_length = string.len(index_search_key)\n"
"  if (index_search_key_length < 3) then\n"
"    print(\"Error: index search key \" .. index_search_key .. \" is too short"
"\")\n"
"    return nil\n"
"  end\n"
"  -- SEE NOTE #3 \"OUTER LOOP: INITIATE\"\n"
"  local result_set = {}\n"
"  local number_of_tuples_in_result_set = 0\n"
"  local previous_tuple_field = \"\"\n"
"  while true do\n"
"    local number_of_tuples_since_last_yield = 0\n"
"    local is_time_for_a_yield = false\n"
"    -- SEE NOTE #4 \"INNER LOOP: ITERATOR\"\n"
"    for _,tuple in box.space[space_name].index[index_no]:\n"
"    pairs(index_search_key,{iterator = box.index.GE}) do\n"
"      -- SEE NOTE #5 \"INNER LOOP: BREAK IF INDEX KEY IS TOO GREAT\"\n"
"      if (string.sub(tuple[field_no], 1, index_search_key_length)\n"
"      > index_search_key) then\n"
"        break\n"
"      end\n"
"      -- SEE NOTE #6 \"INNER LOOP: BREAK AFTER EVERY 10 TUPLES -- MAYBE\"\n"
"      number_of_tuples_since_last_yield = number_of_tuples_since_last_yield + 1\n"
"      if (number_of_tuples_since_last_yield >= 10\n"
"          and tuple[field_no] ~= previous_tuple_field) then\n"
"        index_search_key = tuple[field_no]\n"
"        is_time_for_a_yield = true\n"
"        break\n"
"        end\n"
"      previous_tuple_field = tuple[field_no]\n"
"      -- SEE NOTE #7 \"INNER LOOP: ADD TO RESULT SET IF PATTERN MATCHES\"\n"
"      if (string.match(tuple[field_no], pattern) ~= nil) then\n"
"        number_of_tuples_in_result_set = number_of_tuples_in_result_set + 1\n"
"        result_set[number_of_tuples_in_result_set] = tuple\n"
"      end\n"
"    end\n"
"    -- SEE NOTE #8 \"OUTER LOOP: BREAK, OR YIELD AND CONTINUE\"\n"
"    if (is_time_for_a_yield ~= true) then\n"
"      break\n"
"    end\n"
"    require('fiber').yield()\n"
"  end\n"
"  return result_set\n"
"end"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:765
msgid ""
"NOTE #1 \"FIND AN APPROPRIATE INDEX\" |br| The caller has passed space_name (a "
"string) and field_no (a number). The requirements are: |br| (a) index type must "
"be \"TREE\" because for other index types (HASH, BITSET, RTREE) a search with "
"`iterator=GE <box_index-iterator-types>` will not return strings in order by "
"string value; |br| (b) field_no must be the first index part; |br| (c) the field "
"must contain strings, because for other data types (such as \"unsigned\") "
"pattern searches are not possible; |br| If these requirements are not met by any "
"index, then print an error message and return nil."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:777
msgid ""
"NOTE #2 \"DERIVE INDEX SEARCH KEY FROM PATTERN\" |br| The caller has passed "
"pattern (a string). The index search key will be the characters in the pattern "
"as far as the first magic character. Lua's magic characters are % ^ $ ( ) . [ ] "
"* + - ?. For example, if the pattern is \"ABC.E\", the period is a magic "
"character and therefore the index search key will be \"ABC\". But there is a "
"complication ... If we see \"%\" followed by a punctuation character, that "
"punctuation character is \"escaped\" so remove the \"%\" when making the index "
"search key. For example, if the pattern is \"AB%$E\", the dollar sign is escaped "
"and therefore the index search key will be \"AB$E\". Finally there is a check "
"that the index search key length must be at least three -- this is an arbitrary "
"number, and in fact zero would be okay, but short index search keys will cause "
"long search times."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:794
msgid ""
"NOTE #3 -- \"OUTER LOOP: INITIATE\" |br| The function's job is to return a "
"result set, just as `box.space...select <box_space-select>` would. We will fill "
"it within an outer loop that contains an inner loop. The outer loop's job is to "
"execute the inner loop, and possibly :ref:`yield <atomic-"
"threads_fibers_yields>`, until the search ends. The inner loop's job is to find "
"tuples via the index, and put them in the result set if they match the pattern."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:803
msgid ""
"NOTE #4 \"INNER LOOP: ITERATOR\" |br| The for loop here is using pairs(), see "
"the :ref:`explanation of what index iterators are <box_index-index_pairs>`. "
"Within the inner loop, there will be a local variable named \"tuple\" which "
"contains the latest tuple found via the index search key."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:810
msgid ""
"NOTE #5 \"INNER LOOP: BREAK IF INDEX KEY IS TOO GREAT\" |br| The iterator is GE "
"(Greater or Equal), and we must be more specific: if the search index key has N "
"characters, then the leftmost N characters of the result's index field must not "
"be greater than the search index key. For example, if the search index key is "
"'ABC', then 'ABCDE' is a potential match, but 'ABD' is a signal that no more "
"matches are possible."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:819
msgid ""
"NOTE #6 \"INNER LOOP: BREAK AFTER EVERY 10 TUPLES -- MAYBE\" |br| This chunk of "
"code is for cooperative multitasking. The number 10 is arbitrary, and usually a "
"larger number would be okay. The simple rule would be \"after checking 10 "
"tuples, yield, and then resume the search (that is, do the inner loop again) "
"starting after the last value that was found\". However, if the index is non-"
"unique or if there is more than one field in the index, then we might have "
"duplicates -- for example {\"ABC\",1}, {\"ABC\", 2}, {\"ABC\", 3}\" -- and it "
"would be difficult to decide which \"ABC\" tuple to resume with. Therefore, if "
"the result's index field is the same as the previous result's index field, there "
"is no break."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:832
msgid ""
"NOTE #7 \"INNER LOOP: ADD TO RESULT SET IF PATTERN MATCHES\" |br| Compare the "
"result's index field to the entire pattern. For example, suppose that the caller "
"passed pattern \"ABC.E\" and there is an indexed field containing \"ABCDE\". "
"Therefore the initial index search key is \"ABC\". Therefore a tuple containing "
"an indexed field with \"ABCDE\" will be found by the iterator, because \"ABCDE\" "
"> \"ABC\". In that case string.match will return a value which is not nil. "
"Therefore this tuple can be added to the result set."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:842
msgid ""
"NOTE #8 \"OUTER LOOP: BREAK, OR YIELD AND CONTINUE\" |br| There are three "
"conditions which will cause a break from the inner loop: (1) the for loop ends "
"naturally because there are no more index keys which are greater than or equal "
"to the index search key, (2) the index key is too great as described in NOTE #5, "
"(3) it is time for a yield as described in NOTE #6. If condition (1) or "
"condition (2) is true, then there is nothing more to do, the outer loop ends "
"too. If and only if condition (3) is true, the outer loop must yield and then "
"continue. If it does continue, then the inner loop -- the iterator search -- "
"will happen again with a new value for the index search key."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:855
msgid "EXAMPLE:"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:857
msgid ""
"Start Tarantool, cut and paste the code for function ``indexed_pattern_search``, "
"and try the following:"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:863
msgid ""
"box.space.t:drop()\n"
"box.schema.space.create('t')\n"
"box.space.t:create_index('primary',{})\n"
"box.space.t:create_index('secondary',{unique=false,"
"parts={2,'string',3,'string'}})\n"
"box.space.t:insert{1,'A','a'}\n"
"box.space.t:insert{2,'AB',''}\n"
"box.space.t:insert{3,'ABC','a'}\n"
"box.space.t:insert{4,'ABCD',''}\n"
"box.space.t:insert{5,'ABCDE','a'}\n"
"box.space.t:insert{6,'ABCDE',''}\n"
"box.space.t:insert{7,'ABCDEF','a'}\n"
"box.space.t:insert{8,'ABCDF',''}\n"
"indexed_pattern_search(\"t\", 2, \"ABC.E.\")"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:882
msgid ""
"tarantool> **indexed_pattern_search(\"t\", 2, \"ABC.E.\")**\n"
"---\n"
"- - [7, 'ABCDEF', 'a']\n"
"..."
msgstr ""

#: ../doc/1.7/whats_new.rst:39
msgid "What's new?"
msgstr "Что нового?"

#: ../doc/1.7/whats_new.rst:41
msgid ""
"Here is a summary of significant changes introduced in specific versions of "
"Tarantool."
msgstr ""
"Здесь собрана информация о существенных изменениях, которые произошли в "
"конкретных версиях Tarantool'а."

#: ../doc/1.7/whats_new.rst:44
msgid ""
"For smaller feature changes and bug fixes, see closed `milestones <https://"
"github.com/tarantool/tarantool/milestones?state=closed>`_ at GitHub."
msgstr ""
"Более мелкие изменения и исправления дефектов указаны в отчетах о `выпущенных "
"стабильных релизах (milestone = closed) <https://github.com/tarantool/tarantool/"
"milestones?state=closed>`_ на GitHub."

#: ../doc/1.7/whats_new.rst:52
msgid "What's new in Tarantool 1.7?"
msgstr "Что нового в Tarantool 1.7?"

#: ../doc/1.7/whats_new.rst:54
#, fuzzy
msgid ""
"The disk-based storage engine, which was called `sophia` or `phia` in earlier "
"versions, is superseded by the `vinyl` storage engine."
msgstr ""
"Дисковый движок, который в более ранних версиях Tarantool'а назывался `sophia` и "
"`phia`, заменен новым движком под названием `vinyl`."

#: ../doc/1.7/whats_new.rst:57
msgid "There are new types for indexed fields."
msgstr "Добавлены новые типы индексируемых полей."

#: ../doc/1.7/whats_new.rst:59
msgid "The LuaJIT version is updated."
msgstr "Обновлена версия LuaJIT."

#: ../doc/1.7/whats_new.rst:61
#, fuzzy
msgid ""
"Automatic replica set bootstrap (for easier configuration of a new replica set) "
"is supported."
msgstr ""
"У кластера репликации появилась возможность самонастройки, что существенно "
"упрощает настройку нового кластера."

#: ../doc/1.7/whats_new.rst:64
msgid "The ``space_object:inc()`` function is removed."
msgstr "Функция ``space_object:inc()`` объявлена устаревшей."

#: ../doc/1.7/whats_new.rst:66
msgid "The ``space_object:dec()`` function is removed."
msgstr "Функция ``space_object:dec()`` объявлена устаревшей."

#: ../doc/1.7/whats_new.rst:68
#, fuzzy
msgid "The ``space_object:bsize()`` function is added."
msgstr "Функция ``space_object:inc()`` объявлена устаревшей."

#: ../doc/1.7/whats_new.rst:70
msgid ""
"The ``box.coredump()`` function is removed, for an alternative see :ref:`Core "
"dumps <admin-core_dumps>`."
msgstr ""

#: ../doc/1.7/whats_new.rst:73
msgid "The ``hot_standby`` configuration option is added."
msgstr ""

#: ../doc/1.7/whats_new.rst:75
#, fuzzy
msgid "Configuration parameters revised:"
msgstr "Параметры конфигурации"

#: ../doc/1.7/whats_new.rst:77
msgid "Parameters renamed:"
msgstr ""

#: ../doc/1.7/whats_new.rst:79
msgid "``slab_alloc_arena`` (in gigabytes) to ``memtx_memory`` (in bytes),"
msgstr ""

#: ../doc/1.7/whats_new.rst:80
msgid "``slab_alloc_minimal`` to ``memtx_min_tuple_size``,"
msgstr ""

#: ../doc/1.7/whats_new.rst:81
msgid "``slab_alloc_maximal`` to ``memtx_max_tuple_size``,"
msgstr ""

#: ../doc/1.7/whats_new.rst:82
msgid "``replication_source`` to ``replication``,"
msgstr ""

#: ../doc/1.7/whats_new.rst:83
msgid "``snap_dir`` to ``memtx_dir``,"
msgstr ""

#: ../doc/1.7/whats_new.rst:84
#, fuzzy
msgid "``logger`` to ``log``,"
msgstr "``logger``"

#: ../doc/1.7/whats_new.rst:85
msgid "``logger_nonblock`` to ``log_nonblock``,"
msgstr ""

#: ../doc/1.7/whats_new.rst:86
msgid "``snapshot_count`` to ``checkpoint_count``,"
msgstr ""

#: ../doc/1.7/whats_new.rst:87
msgid "``snapshot_period`` to ``checkpoint_interval``,"
msgstr ""

#: ../doc/1.7/whats_new.rst:88
msgid ""
"``panic_on_wal_error`` and ``panic_on_snap_error`` united under "
"``force_recovery``."
msgstr ""

#: ../doc/1.7/whats_new.rst:91
msgid ""
"Until Tarantool 1.8, you can use :ref:`deprecated parameters <cfg_deprecated>` "
"for both initial and runtime configuration, but Tarantool will display a "
"warning. Also, you can specify both deprecated and up-to-date parameters, "
"provided that their values are harmonized. If not, Tarantool will display an "
"error."
msgstr ""

#: ../doc/1.7/whats_new.rst:100
#, fuzzy
msgid "What's new in Tarantool 1.6.9 after February 15, 2017?"
msgstr "Что нового в Tarantool 1.7?"

#: ../doc/1.7/whats_new.rst:102
msgid ""
"Due to Tarantool issue#2040 `Remove sophia engine from 1.6 <https://github.com/"
"tarantool/tarantool/issues/2040>`_ there no longer is a storage engine named "
"`sophia`. It will be superseded in version 1.7 by the `vinyl` storage engine."
msgstr ""

#: ../doc/1.7/whats_new.rst:111
#, fuzzy
msgid "What's new in Tarantool 1.6?"
msgstr "Что нового в Tarantool 1.7?"

#: ../doc/1.7/whats_new.rst:113
msgid ""
"Tarantool 1.6 is no longer getting major new features, although it will be "
"maintained. The developers are concentrating on Tarantool version 1.7."
msgstr ""

#~ msgid ""
#~ "**Tarantool's disk-based storage engine** is a fusion of ideas from modern "
#~ "filesystems, log-structured merge trees and classical B-trees. All data is "
#~ "organized into **runs**. Each run is represented by a file on disk. Run size "
#~ "is a configuration option and normally is around 64MB. Each run is a "
#~ "collection of pages, serving different purposes. Pages in a fully merged run "
#~ "contain non-overlapping ranges of keys. A run can be partially merged if "
#~ "there were a lot of changes in its key range recently. In that case some "
#~ "pages represent new keys and values in the run. The disk-based storage engine "
#~ "is append only: new data never overwrites old data. The disk-based storage "
#~ "engine is named :ref:`vinyl <index-vinyl>`."
#~ msgstr ""
#~ "**Дисковый движок** (:ref:`vinyl <index-vinyl>`) совмещает в себе подходы, "
#~ "заимствованные из современных файловых систем, журналируемых merge-деверьев "
#~ "(log-structured merge trees) и классических B-деревьев. Все данные в этом "
#~ "движке разбиты по забегам (runs), где каждый забег представляет собой файл на "
#~ "диске. Максимальный размер забега обычно равен 64МБ, и его можно настраивать. "
#~ "Каждый забег — это набор страниц, которые нужны для каких-то целей. Если "
#~ "забег полностью смержен, то диапазоны ключей на его страницах не "
#~ "пересекаются. Если же диапазоны ключей в забеге в какой-то момент сильно "
#~ "изменялись, то мы имеем дело с частично смерженным забегом. В этом случае на "
#~ "некоторых страницах появились новые ключи и значения, которых ранее не было в "
#~ "данном забеге. Дисковый движок обновляет данные по принципу дописывания в "
#~ "конец: новые данные никогда не затирают старые."

#~ msgid ""
#~ "The two ordinary index types are 'tree' which is the default, and 'hash' "
#~ "which must be unique and which may be faster or smaller. The third type is "
#~ "'bitset' which is not unique and which works best for combinations of binary "
#~ "values. The fourth type is 'rtree' which is not unique and which works with "
#~ "arrays, instead of 'string' or 'unsigned' values."
#~ msgstr ""
#~ "Чаще всего индекс — это дерево (по умолчанию) или хеш (в этом случае индекс "
#~ "должен быть уникальным; в определенных случаях такой индекс занимает меньше "
#~ "места и поиск по нему работает быстрее). Третий тип индекса — это набор битов "
#~ "(bitset); это неуникальный индекс, предназначенный для работы с различными "
#~ "бинарными значениями. Четвертый тип индекса — это R-дерево; это тоже "
#~ "неуникальный индекс, предназначенный для работы с массивами, а не со строками "
#~ "или беззнаковыми числами."

#~ msgid ""
#~ "**To review...** If you followed all the instructions in this chapter, then "
#~ "so far you have: installed Tarantool from either a binary or a source "
#~ "repository, started up the Tarantool server, inserted and selected tuples."
#~ msgstr ""
#~ "Если вы выполнили все инструкции из этой главы, то к данному моменту вы уже "
#~ "установили Tarantool (из бинарного пакета, либо из исходных файлов), "
#~ "запустили Tarantool-сервер, а также выполнили вставку и выборку кортежей."

#~ msgid ""
#~ "Typical server administration tasks include starting and stopping the server, "
#~ "reloading configuration, taking snapshots, log rotation."
#~ msgstr ""
#~ "Типичные задачи администрирования серверной части включают в себя запуск и "
#~ "остановку сервера, перезагрузку настроек, создание снимков, ротацию логов."

#~ msgid ""
#~ "If :program:`tarantool` is started without an :ref:`initialization file "
#~ "<index-init_label>`, or if the initialization file contains :ref:`console."
#~ "start() <console-start>`, then :program:`tarantool` enters interactive mode. "
#~ "There will be a prompt (\"``tarantool>``\") and it will be possible to enter "
#~ "requests. When used this way, :program:`tarantool` can be a client for a "
#~ "remote server."
#~ msgstr ""
#~ "Если :program:`tarantool` запущен без :ref:`файла инициализации <index-"
#~ "init_label>`, или же в файле инициализации указана функция :ref:`console."
#~ "start() <console-start>`, то :program:`tarantool` стартует в интерактивном "
#~ "режиме: он выводит приглашение командной строки (\"``tarantool>``\"), и "
#~ "запросы можно вводить прямо в консоли. В таком режиме :program:`tarantool` "
#~ "можно использовать в качестве клиента для удаленного сервера."

#~ msgid ""
#~ "This section shows all legal syntax for the :program:`tarantool` program, "
#~ "with short notes and examples. Other client programs may have similar options "
#~ "and request syntaxes. Some of the information in this section is duplicated "
#~ "in the chapter :ref:`Configuration reference <index-book_cfg>`."
#~ msgstr ""
#~ "В этом разделе описаны синтаксические правила для ввода запросов в консоли "
#~ "Tarantool'а, с примечаниями и примерами. Другие клиентские программы могут "
#~ "иметь схожие параметры и синтаксис запросов. Некоторые сведения из этого "
#~ "раздела дублируются в главе :ref:`Справочник по конфигурированию <index-"
#~ "book_cfg>`."

#~ msgid ""
#~ "Tokens are character sequences which are treated as syntactic units within "
#~ "requests. Square brackets [ and ] enclose optional syntax. Three dots in a "
#~ "row ... mean the preceding tokens may be repeated. A vertical bar | means the "
#~ "preceding and following tokens are mutually exclusive alternatives."
#~ msgstr ""
#~ "Токены — это последовательности символов, которые рассматриваются как "
#~ "синтаксические единицы в рамках запроса. Квадратные скобки [ и ] используются "
#~ "для обозначения необязательных токенов. Три точки в строке ... означают, что "
#~ "предыдущие токены могут повторяться. Вертикальная черта | означает, что "
#~ "предыдущие и последующие токены являются взаимоисключающими альтернативами."

#~ msgid "Options when starting client from the command line"
#~ msgstr "Параметры запуска клиента из командной строки"

#~ msgid "General form:"
#~ msgstr "Общий вид:"

#~ msgid ""
#~ "$ **tarantool**\n"
#~ "OR\n"
#~ "$ **tarantool** *options*\n"
#~ "OR\n"
#~ "$ **tarantool** *lua-initialization-file* **[** *arguments* **]**"
#~ msgstr ""
#~ "$ tarantool\n"
#~ "ИЛИ\n"
#~ "$ tarantool опции\n"
#~ "ИЛИ\n"
#~ "$ tarantool файл-инициализации-на-lua [ аргументы ]"

#~ msgid ""
#~ "Here *lua-initialization-file* can be any script containing code for "
#~ "initializing. Effect: The code in the file is executed during startup. "
#~ "Example: :samp:`init.lua`. |br| Notes: If a script is used, there will be no "
#~ "prompt. The script should contain configuration information including :samp:"
#~ "`box.cfg{...listen=...}` or :samp:`box.listen(...)` so that a separate "
#~ "program can connect to the server via one of the ports."
#~ msgstr ""
#~ "*файл-инициализации-на-lua* — это любой скрипт, содержащий логику "
#~ "инициализации. Код из этого файла выполняется при запуске Tarantool'а.  "
#~ "Например: :samp:`init.lua`. |br| Примечания: При использовании скрипта, "
#~ "Tarantool не выводит приглашение командной строки. Скрипт должен содержать "
#~ "конфигурационные настройки, в т.ч. :samp:`box.cfg{...listen=...}` или :samp:"
#~ "`box.listen(...)`, чтобы внешние программы могли установить соединение с "
#~ "Tarantool-сервером на одном из указанных портов."

#~ msgid ""
#~ "*Option* is one of the following (in alphabetical order by the long form of "
#~ "the option):"
#~ msgstr ""
#~ "*Опция* — это одно из следующих значений (указаны в алфавитном порядке, по "
#~ "полному имени опции):"

#~ msgid ""
#~ "Client displays a help message including a list of options. Example: :samp:"
#~ "`tarantool --help` The program stops after displaying the help."
#~ msgstr ""
#~ "Tarantool-клиент выводит краткую справку, включая список всех параметров. "
#~ "Например: :samp:`tarantool --help`. Вывод останавливается после показа "
#~ "справки."

#~ msgid ""
#~ "Client displays version information. Example: :samp:`tarantool --version`. "
#~ "The program stops after displaying the version."
#~ msgstr ""
#~ "Tarantool-клиент выводит свой номер версии. Например: :samp:`tarantool --"
#~ "version`. Вывод останавливается после показа номера версии."

#~ msgid "Tokens, requests, and special key combinations"
#~ msgstr "Токены, запросы и специальные комбинации клавиш"

#~ msgid ""
#~ "Procedure identifiers are: Any sequence of letters, digits, or underscores "
#~ "which is legal according to the rules for Lua identifiers. Procedure "
#~ "identifiers are also called function names. |br| Note: function names are "
#~ "case sensitive so ``insert`` and ``Insert`` are not the same thing."
#~ msgstr ""
#~ "Идентификатором процедуры может быть любая последовательность букв, цифр и/"
#~ "или подчеркиваний, которая отвечает правилам именования идентификаторов в "
#~ "Lua. Термин \"идентификаторы процедур\" также применяют к именам функций. |"
#~ "br| Примечание: в случае с именами функций регистр имеет значение, поэтому "
#~ "``insert`` и ``Insert`` — это не одно и то же."

#~ msgid ""
#~ "String literals are: Any sequence of zero or more characters enclosed in "
#~ "single quotes. Double quotes are legal but single quotes are preferred. "
#~ "Enclosing in double square brackets is good for multi-line strings as "
#~ "described in `Lua documentation <http://www.lua.org/pil/2.4.html>`_. |br| "
#~ "Examples: 'Hello, world', 'A', [[A\\\\B!]]."
#~ msgstr ""
#~ "Строковым литералом может быть любая последовательность из нуля и более "
#~ "символов, которая заключена в *одинарные кавычки*. *Двойные кавычки* также "
#~ "допустимы, но предпочтительным вариантом являются одинарные кавычки. А "
#~ "*двойные квадратные скобки* нужны для многострочных литералов (см. "
#~ "`документацию по языку Lua <http://www.lua.org/pil/2.4.html>`_). |br| "
#~ "Например: 'Hello, world', 'A', [[A\\\\B!]]."

#~ msgid ""
#~ "Numeric literals are: Any sequence of one or more digits, not enclosed in "
#~ "quotes, optionally preceded by - (minus sign). Large or floating-point "
#~ "numeric literals may include decimal points, exponential notation, or "
#~ "suffixes.|br| Examples: 500, -500, 5e2, 500.1, 5LL, 5ULL."
#~ msgstr ""
#~ "Числовым литералом может быть любая последовательность символов, состоящая из "
#~ "одной и более цифр с необязательным знаком + или - в начале. В состав больших "
#~ "числовых литералов, а также числовых литералов с плавающей точкой может "
#~ "входить десятичный разделитель (запятая или точка), символы для "
#~ "экспоненциального представления и суффиксы. |br| Например: 500, -500, 5e2, "
#~ "500.1, 5LL, 5ULL."

#~ msgid ""
#~ "Single-byte tokens are: , or ( or ) or arithmetic operators. |br| Examples: "
#~ "* , ( )."
#~ msgstr ""
#~ "Однобайтовым символом может быть запятая, открывающая или закрывающая круглая "
#~ "скобка, а также арифметический оператор. |br| Например: * , ( )."

#~ msgid ""
#~ "Tokens must be separated from each other by one or more spaces, except that "
#~ "spaces are not necessary around single-byte tokens or string literals."
#~ msgstr ""
#~ "Токены должны разделяться одним или бОльшим количеством пробелов. Исключением "
#~ "являются однобайтовые токены и строковые литералы — вокруг них пробелы не "
#~ "нужны."

#~ msgid ""
#~ "Generally requests are entered following the prompt in interactive mode "
#~ "while :program:`tarantool` is running. (A prompt will be the word 'tarantool' "
#~ "and a greater-than sign, for example :samp:`tarantool>`). The end-of-request "
#~ "marker is by default a newline (line feed)."
#~ msgstr ""
#~ "Запросы вводятся после приглашения командной строки, когда Tarantool работает "
#~ "в интерактивном режиме. (Приглашение — это слово tarantool и знак \"больше\", "
#~ "вот так: :samp:`tarantool>`). Маркером конца запроса по умолчанию является "
#~ "перевод строки."

#~ msgid ""
#~ "For multi-line requests, it is possible to change the end-of-request marker. "
#~ "Syntax: :samp:`console = require('console'); console.delimiter({string-"
#~ "literal})`. The string-literal must be a value in single quotes. Effect: "
#~ "string becomes end-of-request delimiter, so newline alone is not treated as "
#~ "end of request. To go back to normal mode: :samp:`console.delimiter('')"
#~ "{string-literal}`. Delimiters are usually not necessary because Tarantool can "
#~ "tell when a multi-line request has not ended (for example, if it sees that a "
#~ "function declaration does not have an :samp:`end` keyword). Example:"
#~ msgstr ""
#~ "Для ввода многострочных запросов можно задать другой маркер конца запроса. "
#~ "Для этого введите команду следующего вида: :samp:`console = "
#~ "require('console'); console.delimiter({новый-маркер})`. В качестве нового "
#~ "маркера укажите строковый литерал в одинарных кавычках. После этого вам нужно "
#~ "будет вводить указанный маркер в конце каждого запроса, потому что Tarantool "
#~ "перестанет интерпретировать перевод строки как конец запроса. Чтобы вернуться "
#~ "к обычному режиму, введите: :samp:`console.delimiter(''){string-literal}`. "
#~ "Как правило, задавать свой маркер нет необходимости, поскольку Tarantool сам "
#~ "распознает, что запрос введен не полностью (скажем, когда Tarantool не "
#~ "встречает слова :samp:`end` в объявлении функции). Например:"

#~ msgid ""
#~ "See :ref:`here <box_protocol-iproto_protocol>` a condensed Backus-Naur Form "
#~ "[BNF] description of the suggested form of client requests."
#~ msgstr ""
#~ "См. также :ref:`описание формата клиентских запросов <box_protocol-"
#~ "iproto_protocol>` в виде аннотированных BNF-диаграмм (Backus-Naur Form)."

#~ msgid ""
#~ "In *interactive* mode, one types requests and gets results. Typically the "
#~ "requests are typed in by the user following prompts. Here is an example of an "
#~ "interactive-mode Tarantool client session:"
#~ msgstr ""
#~ "Работая в  *интерактивном* режиме, Tarantool-сервер принимает введенные "
#~ "запросы и выводит результаты. Запросы, как правило, вводит пользователь. Вот "
#~ "пример интерактивной пользовательской сессии:"

#~ msgid ""
#~ "$ tarantool\n"
#~ "[ tarantool will display an introductory message\n"
#~ "  including version number here ]\n"
#~ "tarantool> box.cfg{listen = 3301}\n"
#~ "[ tarantool will display configuration information here ]\n"
#~ "tarantool> s = box.schema.space.create('tester')\n"
#~ "[ tarantool may display an in-progress message here ]\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> s:create_index('primary', {type = 'hash', parts = {1, "
#~ "'unsigned'}})\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> box.space.tester:insert{1,'My first tuple'}\n"
#~ "---\n"
#~ "- [1, 'My first tuple']\n"
#~ "...\n"
#~ "tarantool> box.space.tester:select(1)\n"
#~ "---\n"
#~ "- - [1, 'My first tuple']\n"
#~ "...\n"
#~ "tarantool> box.space.tester:drop()\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> os.exit()\n"
#~ "2014-04-30 10:28:00.886 [20436] main/101/spawner I> Exiting: master shutdown\n"
#~ "$"
#~ msgstr ""
#~ "$ tarantool\n"
#~ "[ здесь tarantool выводит приветствие и номер версии ]\n"
#~ "tarantool> box.cfg{listen = 3301}\n"
#~ "[ здесь tarantool выводит свои текущие настройки ]\n"
#~ "tarantool> s = box.schema.space.create('tester')\n"
#~ "[ здесь tarantool может вывести сообщение о том,\n"
#~ "  что идет обработка запроса ]\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> s:create_index('primary', {type = 'hash', parts = {1, "
#~ "'unsigned'}})\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> box.space.tester:insert{1,'My first tuple'}\n"
#~ "---\n"
#~ "- [1, 'My first tuple']\n"
#~ "...\n"
#~ "tarantool> box.space.tester:select(1)\n"
#~ "---\n"
#~ "- - [1, 'My first tuple']\n"
#~ "...\n"
#~ "tarantool> box.space.tester:drop()\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> os.exit()\n"
#~ "2014-04-30 10:28:00.886 [20436] main/101/spawner I> Exiting: master shutdown\n"
#~ "$"

#~ msgid "Explanatory notes about what Tarantool displayed in the above example:"
#~ msgstr "Пояснения к приведенному выше примеру:"

#~ msgid ""
#~ "Many requests return typed objects. In the case of :samp:`box.cfg{listen=3301}"
#~ "`, this result is displayed on the screen. If the request had assigned the "
#~ "result to a variable, for example :samp:`c = box.cfg{listen=3301}`, then the "
#~ "result would not have been displayed on the screen."
#~ msgstr ""
#~ "На многие запросы Tarantool возвращает типизированные объекты. В ответ на "
#~ "запрос :samp:`box.cfg{listen=3301}` Tarantool выведет результат на экран. "
#~ "Если в запросе задано, что его результат должен быть записан в некоторую "
#~ "переменную, например :samp:`c = box.cfg{listen=3301}`, то в таком случае "
#~ "вывода результата на экран не происходит."

#~ msgid ""
#~ "A display of an object always begins with \"``---``\" and ends with \"``...``"
#~ "\"."
#~ msgstr ""
#~ "Вывод объекта в Tarantool'е всегда начинается со строки \"``---``\" и "
#~ "заканчивается строкой \"``...``\"."

#~ msgid ""
#~ "The insert request returns an object of type = tuple, so the object display "
#~ "line begins with a single dash ('``-``'). However, the select request returns "
#~ "an object of type = table of tuples, so the object display line begins with "
#~ "two dashes ('``- -``')."
#~ msgstr ""
#~ "По запросу на вставку данных возвращается объект типа кортеж (tuple), и в "
#~ "этом случае перед выводом будет стоять одиночное тире ('``-``'). А по запросу "
#~ "на выборку данных возвращается объект типа таблица кортежей (table of "
#~ "tuples), и в этом случае перед выводом будут стоять два тире ('``- -``')."

#~ msgid ""
#~ "Also, you can use :program:`tarantoolctl` :ref:`as a client <administration-"
#~ "tarantoolctl_connect>` to connect to another instance of Tarantool server and "
#~ "pass requests."
#~ msgstr ""
#~ "#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "Данная команда означает \"использовать утилиту :ref:`tarantoolctl "
#~ "<administration-tarantoolctl_connect>` для соединения с Tarantool-сервером, "
#~ "который слушает на ``localhost:3301``.\""

#~ msgid "Configuration for tarantoolctl"
#~ msgstr "Конфигурирование tarantoolctl"

#~ msgid ""
#~ "The :program:`tarantoolctl` script will look for a configuration file in the "
#~ "current directory (:file:`$PWD/.tarantoolctl`). If that fails, it looks in "
#~ "the current user's home directory (:file:`$HOME/.config/tarantool/"
#~ "tarantool`). If that fails, it looks in the SYSCONFDIR directory (usually :"
#~ "file:`/etc/sysconfig/tarantool`, but it may be different on some platforms). "
#~ "Most of the settings are similar to the settings used by :samp:`box.cfg{...}"
#~ "`; however, :program:`tarantoolctl` adjusts some of them by adding an "
#~ "application name. A copy of :file:`usr/local/etc/default/tarantool`, with "
#~ "defaults for all settings, would look like this:"
#~ msgstr ""
#~ "Скрипт :program:`tarantoolctl` сначала проверяет наличие файла конфигурации в "
#~ "текущей директории (:file:`$PWD/.tarantoolctl`). Если не находит, то "
#~ "проверяет домашнюю директорию текущего пользователя (:file:`$HOME/.config/"
#~ "tarantool/tarantool`). Если опять не находит, то проверяет директорию, "
#~ "указанную в переменной SYSCONFDIR (обычно это :file:`/etc/sysconfig/"
#~ "tarantool`, но на разных платформах этот путь может различаться). Большинство "
#~ "параметров :program:`tarantoolctl` аналогичны тем, что задаются в запросе :"
#~ "samp:`box.cfg{...}`; однако :program:`tarantoolctl` меняет значение некоторых "
#~ "параметров, дописывая к ним имя приложения. Далее приводится копия файла :"
#~ "file:`usr/local/etc/default/tarantool`, где для всех параметров указаны их "
#~ "значения по умолчанию:"

#~ msgid "The settings in the above script are:"
#~ msgstr "Комментарии к параметрам в приведенном выше скрипте:"

#~ msgid "``snap_dir``"
#~ msgstr "``snap_dir``"

#~ msgid ""
#~ "The directory for the vinyl-storage-engine files. The script will add \":samp:"
#~ "`/vinyl/{instance-name}`\" to the directory-name."
#~ msgstr ""
#~ "Директория, где хранятся файлы движка vinyl. Скрипт :program:`tarantoolctl` "
#~ "добавляет \":samp:`/{instance-name}`\" к имени директории."

#~ msgid ""
#~ "The user that runs the Tarantool server. This is the operating-system user "
#~ "name rather than the Tarantool-client user name."
#~ msgstr ""
#~ "Имя пользователя, из-под которого запущен Tarantool-сервер. Это имя "
#~ "пользователя в операционной системе, а не в Tarantool-клиенте."

#~ msgid ""
#~ "The directory where all applications for this host are stored. The user who "
#~ "writes an application for :program:`tarantoolctl` must put the application's "
#~ "source code in this directory, or a symbolic link. For examples in this "
#~ "section the application name ``my_app`` will be used, and its source will "
#~ "have to be in :samp:`{instance_dir}/my_app.lua`."
#~ msgstr ""
#~ "Имя директории, где хранятся исходные файлы всех Tarantool-приложений для "
#~ "данного хоста. Пользователю, который пишет приложение для :program:"
#~ "`tarantoolctl`, нужно положить исходный код своего приложения в эту "
#~ "директорию или настроить симлинк. Далее для примеров в этом разделе мы "
#~ "используем Tarantool-приложение с именем ``my_app``, и его исходный код "
#~ "должен лежать в файле :samp:`{instance_dir}/my_app.lua`."

#~ msgid ""
#~ "The command format is :samp:`tarantoolctl {operation} {application_name}`, "
#~ "where operation is one of: start, stop, enter, logrotate, status, eval. "
#~ "Thus ..."
#~ msgstr ""
#~ "Команды для :program:`tarantoolctl` имеют вид :samp:`tarantoolctl {операция} "
#~ "{имя_приложения}`. В качестве *операции* можно указать одно из следующих "
#~ "значений: start, stop, enter, logrotate, status, eval."

#~ msgid "Start application *<application>*"
#~ msgstr "Запустить приложение с именем *<application>*"

#~ msgid "Show application's admin console"
#~ msgstr "Вывести консоль для управления приложением"

#~ msgid "Check application's status"
#~ msgstr "Проверить статус приложения"

#~ msgid "Execute code from *<scriptname>* on an instance of application"
#~ msgstr ""
#~ "Выполнить код из файла *<scriptname>* от имени запущенного экземпляра "
#~ "приложения *<application>*"

#~ msgid "Typical code snippets for tarantoolctl"
#~ msgstr "Примеры кода для tarantoolctl"

#~ msgid "A user can check whether ``my_app`` is running with these lines:"
#~ msgstr "Проверить, запущено ли приложение ``my_app``:"

#~ msgid ""
#~ "if tarantoolctl status my_app; then\n"
#~ "...\n"
#~ "fi"
#~ msgstr ""
#~ "if tarantoolctl status my_app; then\n"
#~ "...\n"
#~ "fi"

#~ msgid ""
#~ "A user can initiate, for boot time, an :file:`init.d` set of instructions:"
#~ msgstr ""
#~ "Выполнить инструкции из файла :file:`init.d` во время запуска приложения:"

#~ msgid ""
#~ "for (each file mentioned in the instance_dir directory):\n"
#~ "    tarantoolctl start `basename $ file .lua`"
#~ msgstr ""
#~ "for (каждый файл в директории instance_dir):\n"
#~ "    tarantoolctl start `basename $ file .lua`"

#~ msgid ""
#~ "A user can set up a further configuration file for log rotation, like this:"
#~ msgstr "Указать файл конфигурации для ротации журнала, например:"

#~ msgid "A detailed example for tarantoolctl"
#~ msgstr "Подробный пример для tarantoolctl"

#~ msgid ""
#~ "The example's objective is to make a temporary directory where :program:"
#~ "`tarantoolctl` can start a long-running application and monitor it."
#~ msgstr ""
#~ "#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "В этом примере мы создадим временную директорию, в которой :program:"
#~ "`tarantoolctl` сможет запускать и мониторить некое долго работающее "
#~ "приложение."

#~ msgid ""
#~ "The assumptions are: the root password is known, the computer is only being "
#~ "used for tests, the Tarantool server is ready to run but is not currently "
#~ "running, tarantoolctl is installed along the user's path, and there currently "
#~ "is no directory named :file:`tarantool_test`."
#~ msgstr ""
#~ "Итак, наши исходные условия: нам известен пароль root-пользователя; компьютер "
#~ "используется только для тестирования; Tarantool-сервер настроен и готов к "
#~ "запуску, но пока еще не запущен ;программа :program:`tarantoolctl` "
#~ "установлена в пользовательском окружении; пока не существует директории с "
#~ "именем :file:`tarantool_test`."

#~ msgid "Create a directory named :file:`/tarantool_test`:"
#~ msgstr "Создадим директорию с именем :file:`/tarantool_test`:"

#~ msgid ""
#~ "Edit :file:`/usr/local/etc/default/tarantool`. It might be necessary to say :"
#~ "samp:`sudo mkdir /usr/local/etc/default` first. Let the new file contents be:"
#~ msgstr ""
#~ "Отредактируем файл :file:`/usr/local/etc/default/tarantool`. Для этого нам "
#~ "сначала может понадобиться выполнить команду :samp:`sudo mkdir /usr/local/etc/"
#~ "default`. Указанный файл будет содержать следующие настройки:"

#~ msgid ""
#~ "default_cfg = {\n"
#~ "    pid_file = \"/tarantool_test/my_app.pid\",\n"
#~ "    wal_dir = \"/tarantool_test\",\n"
#~ "    snap_dir = \"/tarantool_test\",\n"
#~ "    vinyl_dir = \"/tarantool_test\",\n"
#~ "    logger = \"/tarantool_test/log\",\n"
#~ "    username = \"tarantool\",\n"
#~ "}\n"
#~ "instance_dir = \"/tarantool_test\""
#~ msgstr ""
#~ "default_cfg = {\n"
#~ "    pid_file = \"/tarantool_test/my_app.pid\",\n"
#~ "    wal_dir = \"/tarantool_test\",\n"
#~ "    snap_dir = \"/tarantool_test\",\n"
#~ "    vinyl_dir = \"/tarantool_test\",\n"
#~ "    logger = \"/tarantool_test/log\",\n"
#~ "    username = \"tarantool\",\n"
#~ "}\n"
#~ "instance_dir = \"/tarantool_test\""

#~ msgid ""
#~ "Clean up. Restore the original contents of :file:`/usr/local/etc/default/"
#~ "tarantool`, and ..."
#~ msgstr ""
#~ "Почистим систему после тестирования. Приведем содержимое файла :file:`/usr/"
#~ "local/etc/default/tarantool` к исходному виду и удалим нашу тестовую "
#~ "директорию:"

#~ msgid ""
#~ "$ cd /\n"
#~ "$ sudo rm -R tarantool_test"
#~ msgstr ""
#~ "$ cd /\n"
#~ "$ sudo rm -R tarantool_test"

#~ msgid "$ tarantoolctl connect username:password@127.0.0.1:3306"
#~ msgstr "$ tarantoolctl connect username:password@127.0.0.1:3306"

#~ msgid ""
#~ "There are alternatives to :program:`tarantoolctl connect` -- you can use the :"
#~ "ref:`console module <console-module>` or the :ref:`net.box module <net_box-"
#~ "module>` from a Tarantool server. Also, you can write your client programs "
#~ "with any of the Connectors. However, most of the examples in this manual "
#~ "illustrate usage with either :program:`tarantoolctl connect` or with :ref:"
#~ "`using the Tarantool server as a client <administration-"
#~ "using_tarantool_as_a_client>`."
#~ msgstr ""
#~ "#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "Вместо :program:`tarantoolctl connect` вы можете использовать модули :ref:"
#~ "`console <console-module>` или :ref:`net.box <net_box-module>` из библиотеки "
#~ "Tarantool'а. Еще одна альтернатива — это написать клиентскую программу под "
#~ "любой из существующих Tarantool-коннекторов. Но для большинства примеров в "
#~ "текущей документации мы используем :program:`tarantoolctl connect` или :ref:"
#~ "`Tarantool-сервер в качестве клиента <administration-"
#~ "using_tarantool_as_a_client>`."

#~ msgid "Administrative ports"
#~ msgstr "Служебные порты"

#~ msgid ""
#~ "\"Admin port\", \"admin console\", and \"text protocol\" all refer to the "
#~ "same thing: a connection which is set up with :ref:`console.listen(...) "
#~ "<console-listen>` for entry of requests by administrators."
#~ msgstr ""
#~ "Термины \"порт для администрирования\", \"консоль для администрирования\", "
#~ "\"текстовый протокол\" относятся к установке соединения с помощью :ref:"
#~ "`console.listen(...) <console-listen>` для ввода запросов от администраторов."

#~ msgid ""
#~ "\"Binary port\", \"binary protocol\", and \"primary port\" all refer to a "
#~ "different thing: a connection which is set up with :ref:`box.cfg{listen=...} "
#~ "<cfg_basic-listen>` for entry of requests by anyone."
#~ msgstr ""
#~ "Термины \"бинарный порт\", \"бинарный протокол\", \"первичный порт\" "
#~ "относятся к другому виду соединения — тому, что устанавливается с помощью "
#~ "параметра :ref:`box.cfg{listen=...} <cfg_basic-listen>` и предназначено для "
#~ "ввода запросов от любых пользователей."

#~ msgid ""
#~ "Ordinary connections to the Tarantool server should go via a binary port. But "
#~ "admin ports are useful for special cases involving security."
#~ msgstr ""
#~ "Для обычных соединений с Tarantool-сервером должен использоваться бинарный "
#~ "протокол. А порты для администрирования нужны для особых случаев, когда "
#~ "повышены требования к безопасности."

#~ msgid ""
#~ "if the listener has the privilege to write on :file:`/var/lib/tarantool` and "
#~ "the connector has the privilege to read on :file:`/var/lib/tarantool`. "
#~ "Alternatively both setup and connection can be done with :ref:`tarantoolctl "
#~ "<administration-tarantoolctl>`."
#~ msgstr ""
#~ "Это в том случае, если у сервера (listener'а) есть привилегии на запись в "
#~ "файл :file:`/var/lib/tarantool`, а на стороне клиента (connector'а) есть "
#~ "привилегии на чтение из того же файла. Аналогично можно установить соединение "
#~ "и задать настройки с помощью :ref:`tarantoolctl <administration-"
#~ "tarantoolctl>`."

#~ msgid ""
#~ "If no administrator password exists which could be given out to users, and "
#~ "admin ports are restricted or are sockets, then requests which require "
#~ "'admin' privileges can only occur locally, and are subject to Unix security "
#~ "and monitoring."
#~ msgstr ""
#~ "Если не задан пароль администратора, который можно сообщить пользователям, а "
#~ "порты для администрирования настроены с ограничением доступа по IP либо через "
#~ "сокеты, то запросы, требующие привилегий администратора, можно делать только "
#~ "локально, где вопросы безопасности и мониторинга регулируются с помощью "
#~ "средств Unix-системы."

#~ msgid ""
#~ "For additional security, some requests are illegal. For example, :ref:`\"conn:"
#~ "eval\" <net_box-eval>`  will result in the error message \"- error: console "
#~ "does not support this request type\" because ``conn:eval`` requires the "
#~ "binary protocol."
#~ msgstr ""
#~ "В целях дополнительной безопасности некоторые запросы на портах для "
#~ "администрирования запрещены. Например, :ref:`conn:eval <net_box-eval>` вернет "
#~ "сообщение об ошибке ``- error: console does not support this request type``, "
#~ "поскольку запрос ``conn:eval`` должен осуществляться в рамках бинарного "
#~ "протокола."

#~ msgid ""
#~ "If security via admin ports is not necessary, it is still possible to be an "
#~ "admin user by :ref:`using the tarantool server as a client <administration-"
#~ "using_tarantool_as_a_client>`, or by connecting to a binary port with a valid "
#~ "password."
#~ msgstr ""
#~ "Если вопросы безопасности на портах для администрирования неактуальны, то "
#~ "стать пользователем с правами администратора можно, :ref:`используя Tarantool-"
#~ "сервер в качестве клиента <administration-using_tarantool_as_a_client>` или "
#~ "указав администраторский пароль при установке соединения по бинарному "
#~ "протоколу."

#~ msgid "Administrative requests"
#~ msgstr "Служебные запросы"

#~ msgid ""
#~ "To set up replication, it's necessary to set up the master servers which make "
#~ "the original data-change requests, set up the replica servers which copy data-"
#~ "change requests from masters, and establish procedures for recovery from a "
#~ "degraded state."
#~ msgstr ""
#~ "Чтобы настроить репликацию, необходимо настроить главные сервера (master), "
#~ "которые первыми обрабатывают запросы на изменение данных, затем настроить "
#~ "сервера-реплики (replica), которые копируют к себе запросы на изменение "
#~ "данных с главных серверов, и прописать процедуры для восстановления после "
#~ "сбоя."

#~ msgid ""
#~ "A replica gets all updates from the master by continuously fetching and "
#~ "applying its write-ahead log (WAL). Each record in the WAL represents a "
#~ "single Tarantool data-change request such as INSERT or UPDATE or DELETE, and "
#~ "is assigned a monotonically growing log sequence number (LSN). In essence, "
#~ "Tarantool replication is row-based: each data change command is fully "
#~ "deterministic and operates on a single tuple."
#~ msgstr ""
#~ "Чтобы знать о всех изменениях на стороне главного сервера, каждая реплика "
#~ "непрерывно опрашивает главный сервер на предмет обновлений в его WAL-файле "
#~ "(write ahead log) и применяет эти обновления на своей стороне. Каждая запись "
#~ "в WAL-файле представляет собой один запрос на изменение данных (например, "
#~ "INSERT, UPDATE или DELETE) и присвоенный данной записи номер (LSN = log "
#~ "sequence number). Номера присваиваются в порядке возрастания. По сути, "
#~ "репликация в Tarantool'е является построчной: все команды на изменение данных "
#~ "полностью детерминированы, и каждая такая команда относится только к одному "
#~ "кортежу."

#~ msgid ""
#~ "A stored program invocation is not written to the write-ahead log. Instead, "
#~ "log events for actual data-change requests, performed by the Lua code, are "
#~ "written to the log. This ensures that possible non-determinism of Lua does "
#~ "not cause replication to go out of sync."
#~ msgstr ""
#~ "Вызовы хранимых Lua-процедур фиксируются не в WAL-файле, а в журнале событий "
#~ "(event log). Таким образом гарантируется, что не детерминированное поведение "
#~ "логики на Lua не приведет к рассинхронизации реплицированных данных."

#~ msgid ""
#~ "To prepare the master for connections from the replica, it's only necessary "
#~ "to include \":ref:`listen <cfg_basic-listen>`\" in the initial ``box.cfg`` "
#~ "request, for example ``box.cfg{listen=3301}``. A master with enabled \"listen"
#~ "\" URI can accept connections from as many replicas as necessary on that URI. "
#~ "Each replica has its own :ref:`replication state <index-"
#~ "monitoring_replica_actions>`."
#~ msgstr ""
#~ "Чтобы настроить возможность установки соединения для реплик, на стороне "
#~ "главного сервера требуется лишь указать значение для параметра \":ref:`listen "
#~ "<cfg_basic-listen>`\" в init-запросе ``box.cfg``. Например, ``box."
#~ "cfg{listen=3301}``. Когда URI для прослушивания задан, главный сервер готов "
#~ "принимать запросы на соединение от любого количества реплик. Каждая реплика "
#~ "при этом находится в некотором :ref:`статусе репликации <index-"
#~ "monitoring_replica_actions>`."

#~ msgid ""
#~ "A server requires a valid snapshot (.snap) file. A snapshot file is created "
#~ "for a server the first time that ``box.cfg`` occurs for it. If this first "
#~ "``box.cfg`` request occurs without a \"replication source\" clause, then the "
#~ "server is a master and starts its own new cluster with a new unique UUID. If "
#~ "this first ``box.cfg`` request occurs with a \"replication source\" clause, "
#~ "then the server is a replica and its snapshot file, along with the cluster "
#~ "information, is constructed from the write-ahead logs of the master. "
#~ "Therefore, to start replication, specify :ref:`replication_source "
#~ "<cfg_replication-replication_source>` in a ``box.cfg`` request. When a "
#~ "replica contacts a master for the first time, it becomes part of a cluster. "
#~ "On subsequent occasions, it should always contact a master in the same "
#~ "cluster."
#~ msgstr ""
#~ "Каждому Tarantool-серверу необходим корректный файл со статическим снимком "
#~ "данных (.snap-файл). Файл-снимок создается на сервере при первом запросе "
#~ "``box.cfg``. Если при первом таком запросе на сервере не определен источник "
#~ "репликации (replication source), то сервер стартует в режиме главного сервера "
#~ "и создает для себя новый кластер с новым уникальными UUID. Если же источник "
#~ "репликации при первом ``box.cfg``-запросе определен, то сервер стартует в "
#~ "режиме реплики, а файл-снимок и информация о кластере берутся из WAL-файлов "
#~ "на главном сервере. Поэтому при настройке репликации нужно указать параметр :"
#~ "ref:`replication_source <cfg_replication-replication_source>` в запросе ``box."
#~ "cfg``. При первом соединении с главным сервером сервер-реплика включается в "
#~ "состав кластера. В дальнейшем такая реплика общается только с главным "
#~ "сервером из данного кластера."

#~ msgid ""
#~ "Once connected to the master, the replica requests all changes that happened "
#~ "after the latest local LSN. It is therefore necessary to keep WAL files on "
#~ "the master host as long as there are replicas that haven't applied them yet. "
#~ "A replica can be \"re-seeded\" by deleting all its files (the snapshot .snap "
#~ "file and the WAL .xlog files), then starting replication again - the replica "
#~ "will then catch up with the master by retrieving all the master's tuples. "
#~ "Again, this procedure works only if the master's WAL files are present."
#~ msgstr ""
#~ "После установки соединения с главным сервером реплика запрашивает у него все "
#~ "изменения, чьи LSN-номера в WAL-файле больше номера последнего локального "
#~ "изменения на реплике. Поэтому WAL-файлы на главном сервере нужно хранить до "
#~ "тех пор, пока все реплики не применят изменения из этих WAL-файлов на своей "
#~ "стороне. Состояние реплики можно \"обнулить\", удалив все файлы репликации (."
#~ "snap-файл со снимком и .xlog-файлы с записями WAL) и запустив сервер снова. "
#~ "Реплика при этом возьмет все кортежи с главного сервера и придет в "
#~ "синхронизированное состояние. Обратите внимание, что такая процедура "
#~ "\"обнуления\" сработает, только если на главном сервере будут доступны все "
#~ "нужные WAL-файлы."

#~ msgid "Quick startup of a new simple two-server cluster"
#~ msgstr ""
#~ "#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "Инструкции по быстрому запуску простого кластера из двух серверов с нуля"

#~ msgid "Step 1. Start the first server thus:"
#~ msgstr "Шаг 1. Запустите первый сервер со следующими настройками:"

#~ msgid ""
#~ "box.cfg{listen = *uri#1*}\n"
#~ "-- replace with more restrictive request\n"
#~ "box.schema.user.grant('guest', 'read,write,execute', 'universe')\n"
#~ "box.snapshot()"
#~ msgstr ""
#~ "box.cfg{listen = *uri#1*}\n"
#~ "-- в этом запросе можно задать больше ограничений\n"
#~ "box.schema.user.grant('guest', 'read,write,execute', 'universe')\n"
#~ "box.snapshot()"

#~ msgid "... Now a new cluster exists."
#~ msgstr "... Итак, создался новый кластер."

#~ msgid ""
#~ "Step 2. Check where the second server's files will go by looking at its "
#~ "directories (:ref:`snap_dir <cfg_basic-snap_dir>` for snapshot files, :ref:"
#~ "`wal_dir <cfg_basic-wal_dir>` for .xlog files). They must be empty - when the "
#~ "second server joins for the first time, it has to be working with a clean "
#~ "state so that the initial copy of the first server's databases can happen "
#~ "without conflicts."
#~ msgstr ""
#~ "Шаг 2. На втором сервере проверьте пути, по которым будут храниться файлы "
#~ "репликации. Эти пути задаются в параметрах :ref:`snap_dir <cfg_basic-"
#~ "snap_dir>` (для .snap-файлов) и :ref:`wal_dir <cfg_basic-wal_dir>` (для .xlog-"
#~ "файлов). В указанных директориях должно быть пусто, чтобы не случилось "
#~ "конфликта с теми начальными данными, что придут с первого сервера, когда "
#~ "второй сервер присоединится к кластеру."

#~ msgid "Step 3. Start the second server thus:"
#~ msgstr "Step 3. Запустите второй сервер со следующими настройками:"

#~ msgid ""
#~ "box.cfg{\n"
#~ "  listen = *uri#2*,\n"
#~ "  replication_source = *uri#1*\n"
#~ "}"
#~ msgstr ""
#~ "box.cfg{\n"
#~ "  listen = *uri#2*,\n"
#~ "  replication_source = *uri#1*\n"
#~ "}"

#~ msgid ""
#~ "... where ``uri#1`` = the :ref:`URI <index-uri>` that the first server is "
#~ "listening on."
#~ msgstr ""
#~ "... где ``uri#1`` = :ref:`URI <index-uri>`, на котором включено прослушивание "
#~ "у первого сервера."

#~ msgid "That's all."
#~ msgstr "Вот и всё."

#~ msgid ""
#~ "In this configuration, the first server is the \"master\" and the second "
#~ "server is the \"replica\". Henceforth every change that happens on the master "
#~ "will be visible on the replica. A simple two-server cluster with the master "
#~ "on one computer and the replica on a different computer is very common and "
#~ "provides two benefits: FAILOVER (because if the master goes down then the "
#~ "replica can take over), or LOAD BALANCING (because clients can connect to "
#~ "either the master or the replica for select requests). Sometimes the replica "
#~ "may be configured with the additional parameter :ref:`read_only = true "
#~ "<cfg_basic-read_only>`."
#~ msgstr ""
#~ "В описанной выше конфигурации первый сервер выполняет роль \"главного\", а "
#~ "второй служит \"репликой\". Далее все изменения, происходящие на стороне "
#~ "главного сервера, будут доступны с реплики. Простой кластер из двух серверов, "
#~ "где главный сервер запущен на одном компьютере, а сервер-реплика — на другом, "
#~ "встречается очень часто и обладает двумя важными преимуществами: FAILOVER (т."
#~ "е. отказоустойчивость, поскольку в случае отключения главного сервера его "
#~ "место может занять сервер-реплика) и LOAD BALANCING (т.е. балансировка "
#~ "нагрузки, поскольку клиенты могут обращаться с SELECT-запросами как к "
#~ "главному серверу, так и к реплике). При необходимости в настройках реплики "
#~ "можно задать параметр :ref:`read_only = true <cfg_basic-read_only>`."

#~ msgid ""
#~ "In the :ref:`log <log>` there is a record of replication activity. If a "
#~ "primary server is started with:"
#~ msgstr ""
#~ "В :ref:`журнале <log>` ведется запись о действиях, связанных с репликацией. "
#~ "Если главный сервер запущен со следующими настройками:"

#~ msgid ""
#~ "box.cfg{\n"
#~ "  <...>,\n"
#~ "  logger = *log file name*,\n"
#~ "  <...>\n"
#~ "}"
#~ msgstr ""
#~ "box.cfg{\n"
#~ "  <...>,\n"
#~ "  logger = *имя_файла_для_ведения_журнала*,\n"
#~ "  <...>\n"
#~ "}"

#~ msgid ""
#~ "then there will be lines in the log file, containing the word \"relay\", when "
#~ "a replica connects or disconnects."
#~ msgstr ""
#~ "то на каждую установку/потерю соединения реплики с главным сервером в журнале "
#~ "будут появляться строчки со словом \"relay\"."

#~ msgid ""
#~ "Suppose that the replica tries to do something that the master has already "
#~ "done. For example: |br| ``box.schema.space.create('X')`` |br| This would "
#~ "cause an error, \"Space X exists\". For this particular situation, the code "
#~ "could be changed to: |br| ``box.schema.space.create('X', "
#~ "{if_not_exists=true})`` |br| But there is a more general solution: the :samp:"
#~ "`box.once({key}, {function})` method. If ``box.once()`` has been called "
#~ "before with the same :samp:`{key}` value, then :samp:`{function}` is ignored; "
#~ "otherwise :samp:`{function}` is executed. Therefore, actions which should "
#~ "only occur once during the life of a replicated session should be placed in a "
#~ "function which is executed via ``box.once()``. For example:"
#~ msgstr ""
#~ "Предположим, что реплика пытается сделать нечто, что уже было сделано на "
#~ "главном сервере. Например: |br| :code:`box.schema.space.create('X')` |br| Это "
#~ "приведет к ошибке \"Space X exists\" (\"Пространство X уже существует\"). В "
#~ "данном частном случае можно скорректировать инструкцию следующим образом: |"
#~ "br| :code:`box.schema.space.create('X', {if_not_exists=true})` |br| Но "
#~ "существует и более общее решение: использовать метод :samp:`box.once({key}, "
#~ "{function})`. Если :code:`box.once()` был вызван ранее с тем же значением "
#~ "параметра :samp:`{key}`, то функция :samp:`{function}` игнорируется; в "
#~ "противном случае функция :samp:`{function}` будет выполнена. Поэтому "
#~ "действия, которые должны совершаться только один раз за время текущей сессии "
#~ "репликации, нужно помещать в функцию и вызывать ее с помощью метода :code:"
#~ "`box.once()`. Например:"

#~ msgid ""
#~ "In the simple master-replica configuration, the master's changes are seen by "
#~ "the replica, but not vice versa, because the master was specified as the sole "
#~ "replication source. In the master-master configuration, also sometimes called "
#~ "multi-master configuration, it's possible to go both ways. Starting with the "
#~ "simple configuration, the first server has to say:"
#~ msgstr ""
#~ "В случае настройки репликации по схеме master-replica изменения на главном "
#~ "сервере доступны для просмотра с реплики, но не наоборот, потому как главный "
#~ "сервер в такой схеме указан в качестве единственного источника репликации. В "
#~ "случае схемы master-master (иногда ее также называет multi-master) просмотр "
#~ "изменений возможен в любом направлении. В простом случае (master-master с "
#~ "двумя серверами) на первом сервере нужно задать следующие настройки:"

#~ msgid ""
#~ "In this configuration, both servers are \"masters\" and both servers are "
#~ "\"replicas\". Henceforth every change that happens on either server will be "
#~ "visible on the other. The failover benefit is still present, and the load-"
#~ "balancing benefit is enhanced (because clients can connect to either server "
#~ "for data-change requests as well as select requests)."
#~ msgstr ""
#~ "В данном примере оба сервера являются одновременно и \"главными\", и "
#~ "\"репликами\". Поэтому каждое изменение, которое случается на одном сервере, "
#~ "становится доступно для просмотра с другого сервера. Отказоустойчивость в "
#~ "такой конфигурации сохраняется, а возможности по балансировке нагрузки "
#~ "становятся еще шире (теперь клиенты могут обращаться к обоим серверам со "
#~ "всеми типами запросов — как на чтение данных, так и на изменение)."

#~ msgid ""
#~ "If two operations for the same tuple take place \"concurrently\" (which can "
#~ "involve a long interval because replication is asynchronous), and one of the "
#~ "operations is ``delete`` or ``replace``, there is a possibility that servers "
#~ "will end up with different contents."
#~ msgstr ""
#~ "Если две операции над одним и тем же кортежем производятся \"параллельно\" (а "
#~ "это может потребовать много времени, поскольку репликация — это асинхронный "
#~ "процесс), причем одна из операций — это ``delete``, а вторая — ``replace``, "
#~ "то существует вероятность, что данные на серверах станут различаться."

#~ msgid "All the \"What If?\" questions"
#~ msgstr "Ответы на вопросы \"Что если?\""

#~ msgid ""
#~ "Q: What if there are more than two servers with master-master? |br| A: On "
#~ "each server, specify the :ref:`replication_source <cfg_replication-"
#~ "replication_source>` for all the others. For example, server #3 would have a "
#~ "request: |br| :codenormal:`box.cfg{` |br| |nbsp| |nbsp| |nbsp| :codenormal:"
#~ "`replication_source = {`:codeitalic:`uri#1, uri#2`:codenormal:`}` |br| :"
#~ "codenormal:`}`"
#~ msgstr ""
#~ "Вопрос: Что если в кластере вида master-master более двух серверов? |br| "
#~ "Ответ: На каждом сервере нужно задать параметр :ref:`replication_source "
#~ "<cfg_replication-replication_source>` и указать в нем все остальные сервера. "
#~ "Например, для сервера #3 настройки будут следующими: |br| :codenormal:`box."
#~ "cfg{` |br| |nbsp| |nbsp| |nbsp| :codenormal:`replication_source = {`:"
#~ "codeitalic:`uri#1, uri#2`:codenormal:`}` |br| :codenormal:`}`"

#~ msgid ""
#~ "Q: What if a server should be taken out of the cluster? |br| A: For a "
#~ "replica, run ``box.cfg{}`` again specifying a blank replication source: |br| "
#~ "``box.cfg{replication_source=''}``"
#~ msgstr ""
#~ "Вопрос: Что если какой-то сервер нужно убрать из кластера? |br| Ответ: Для "
#~ "реплики — выполните запрос ``box.cfg{}``, указав пустой источник репликации: |"
#~ "br| ``box.cfg{replication_source=''}``"

#~ msgid ""
#~ "Q: What if two servers both change the same tuple? |br| A: The last changer "
#~ "wins. For example, suppose that server#1 changes the tuple, then server#2 "
#~ "changes the tuple. In that case server#2's change overrides whatever server#1 "
#~ "did. In order to keep track of who came last, Tarantool implements a `vector "
#~ "clock <https://en.wikipedia.org/wiki/Vector_clock>`_."
#~ msgstr ""
#~ "Вопрос: Что если два сервера совершают изменения, связанные с одним и тем же "
#~ "кортежем? |br| Ответ: Применятся последние из совершенных изменений. Для "
#~ "примера предположим, что сервер #1 меняет некоторый кортеж, а затем сервер #2 "
#~ "меняет тот же кортеж. В данном случае изменения сервера #2 затрут изменения "
#~ "сервера #1. Чтобы отслеживать, кто был последним, в Tarantool'е используются "
#~ "`векторные часы <https://en.wikipedia.org/wiki/Vector_clock>`_."

#~ msgid ""
#~ "Q: What if two servers both insert the same tuple? |br| A: If a master tries "
#~ "to insert a tuple which a replica has inserted already, this is an example of "
#~ "a severe error. Replication stops. It will have to be restarted manually."
#~ msgstr ""
#~ "Вопрос: Что если оба сервера выполняют вставку одного и того же кортежа? |br| "
#~ "Ответ: Если главный сервер попытается вставить кортеж, который уже был "
#~ "вставлен на реплике, то это будет пример серьезной ошибки. Репликация "
#~ "остановится, и ее придется перезапускать в ручную."

#~ msgid ""
#~ "Q: What if a master disappears and the replica must take over? |br| A: A "
#~ "message will appear on the replica stating that the connection is lost. The "
#~ "replica must now become independent, which can be done by saying ``box."
#~ "cfg{replication_source=''}``."
#~ msgstr ""
#~ "Вопрос: Что если главный сервер становится недоступен и пользователям "
#~ "приходится переключаться реплику? |br| Ответ: Реплика получает сообщение, что "
#~ "связь потеряна. Теперь реплика должна начать работать независимо. Для этого "
#~ "ей нужно задать пустой источник репликации, выполнив на стороне реплики "
#~ "запрос ``box.cfg{replication_source=''}``."

#~ msgid ""
#~ "Q: What if it's necessary to know what cluster a server is in? |br| A: The "
#~ "identification of the cluster is a UUID which is generated when the first "
#~ "master starts for the first time. This UUID is stored in a tuple of the :ref:"
#~ "`box.space._schema <box_space-schema>` system space. So to see it, say: ``box."
#~ "space._schema:select{'cluster'}``"
#~ msgstr ""
#~ "Вопрос: Что если нужно посмотреть, к какому кластеру принадлежит данный "
#~ "сервер? |br| Ответ: Идентификатором кластера является UUID, который "
#~ "генерируется при первом запуске главного сервера. Данный UUID хранится в "
#~ "системном пространстве :ref:`box.space._schema <box_space-schema>`. Чтобы "
#~ "посмотреть UUID кластера, введите запрос ``box.space._schema:select{'cluster'}"
#~ "``"

#~ msgid ""
#~ "Q: What if it's necessary to know what other servers belong in the cluster? |"
#~ "br| A: The universal identification of a server is a UUID in ``box.info."
#~ "server.uuid``. The ordinal identification of a server within a cluster is a "
#~ "number in ``box.info.server.id``. To see all the servers in the cluster, say: "
#~ "``box.space._cluster:select{}``. This will return a table with all {server."
#~ "id, server.uuid} tuples for every server that has ever joined the cluster."
#~ msgstr ""
#~ "Вопрос: Что если нужно посмотреть, какие сервера входят в кластер? |br| "
#~ "Ответ: У каждого сервера есть универсальный идентификатор — это его UUID в "
#~ "поле ``box.info.server.uuid``. Также у сервера есть его порядковый "
#~ "идентификатор в кластере — это номер в поле ``box.info.server.id``. Чтобы "
#~ "увидеть номера всех серверов в кластере, введите запрос: ``box.space._cluster:"
#~ "select{}``. Данный запрос возвращает таблицу со всеми кортежами вида {server."
#~ "id, server.uuid} для всех серверов, что когда-либо входили в данный кластер."

#~ msgid ""
#~ "Q: What if one of the server's files is corrupted or deleted? |br| A: Stop "
#~ "the server, destroy all the database files (the ones with extension \"snap\" "
#~ "or \"xlog\" or \".inprogress\"), restart the server, and catch up with the "
#~ "master by contacting it again (just say ``box.cfg{...replication_source=...}"
#~ "``)."
#~ msgstr ""
#~ "Вопрос: Что если какой-то из файлов репликации на реплике поврежден или "
#~ "удален? |br| Ответ: Нужно остановить сервер, удалить все файлы, относящиеся к "
#~ "базе данных (это файлы с расширениями \"snap\", \"xlog\" и \".inprogress\"), "
#~ "снова запустить сервер и ввести запрос ``box.cfg{...replication_source=...}"
#~ "``, чтобы восстановить соединение с главным сервером и загрузить данные с "
#~ "него."

#~ msgid ""
#~ "Q: What if replication causes security concerns? |br| A: Prevent unauthorized "
#~ "replication sources by associating a password with every user that has access "
#~ "privileges for the relevant spaces, and every user that has a replication :"
#~ "ref:`role <authentication-rep_role>`. That way, the :ref:`URI <index-uri>` "
#~ "for the :ref:`replication_source <cfg_replication-replication_source>` "
#~ "parameter will always have to have the long form |br| "
#~ "``replication_source='username:password@host:port'``"
#~ msgstr ""
#~ "Вопрос: Что если при репликации возникают вопросы, связанные с безопасностью? "
#~ "|br| Ответ: Чтобы предотвратить появление несанкционированных источников "
#~ "репликации, нужно задать пароль для каждого пользователя, у которого есть "
#~ "привилегии доступа к соответствующим пространствам, а также для каждого "
#~ "пользователя, у которого настроена :ref:`репликационная роль <authentication-"
#~ "rep_role>`. Заметьте, что :ref:`URI <index-uri>` для параметра :ref:"
#~ "`replication_source <cfg_replication-replication_source>` теперь нужно всегда "
#~ "указывать в полном виде: |br| ``replication_source='username:password@host:"
#~ "port'``"

#~ msgid "Hands-on replication tutorial"
#~ msgstr "Практическое руководство по репликации"

#~ msgid ""
#~ "After following the steps here, an administrator will have experience "
#~ "creating a cluster and adding a replica."
#~ msgstr ""
#~ "Ниже приводятся пошаговые инструкции, которые помогут вам получить "
#~ "практический опыт администрирования кластера, а именно опыт создания кластера "
#~ "и добавления реплики."

#~ msgid ""
#~ "Start two shells. Put them side by side on the screen. (This manual has a "
#~ "tabbed display showing \"Terminal #1\". Click the \"Terminal #2\" tab to "
#~ "switch to the display of the other shell.)"
#~ msgstr ""
#~ "Запустите два терминала, каждый в своем окне, и расположите их рядом на "
#~ "экране. (Далее в примерах оба терминала показаны в виде закладок. Щелкните на "
#~ "заголовок закладки — \"Terminal #1\" или \"Terminal #2\", — чтобы увидеть "
#~ "вывод на соответствующем терминале.)"

#~ msgid "$"
#~ msgstr "$"

#~ msgid ""
#~ "On the first shell, which we'll call Terminal #1, execute these commands:"
#~ msgstr "В первом терминале (Terminal #1) выполните следующие команды:"

#~ msgid ""
#~ "$ # Terminal 1\n"
#~ "$ mkdir -p ~/tarantool_test_node_1\n"
#~ "$ cd ~/tarantool_test_node_1\n"
#~ "$ rm -R ~/tarantool_test_node_1/*\n"
#~ "$ ~/tarantool/src/tarantool\n"
#~ "tarantool> box.cfg{listen = 3301}\n"
#~ "tarantool> box.schema.user.create('replicator', {password = 'password'})\n"
#~ "tarantool> box.schema.user."
#~ "grant('replicator','execute','role','replication')\n"
#~ "tarantool> box.space._cluster:select({0}, {iterator = 'GE'})"
#~ msgstr ""
#~ "$ # Terminal 1\n"
#~ "$ mkdir -p ~/tarantool_test_node_1\n"
#~ "$ cd ~/tarantool_test_node_1\n"
#~ "$ rm -R ~/tarantool_test_node_1/*\n"
#~ "$ ~/tarantool/src/tarantool\n"
#~ "tarantool> box.cfg{listen = 3301}\n"
#~ "tarantool> box.schema.user.create('replicator', {password = 'password'})\n"
#~ "tarantool> box.schema.user."
#~ "grant('replicator','execute','role','replication')\n"
#~ "tarantool> box.space._cluster:select({0}, {iterator = 'GE'})"

#~ msgid ""
#~ "The result is that a new cluster is set up, and the server's UUID is "
#~ "displayed. Now the screen looks like this: (except that UUID values are "
#~ "always different):"
#~ msgstr ""
#~ "В результате были заданы настройки нового кластера, а на экране был выведен "
#~ "UUID текущего сервера. Теперь вывод на экране выглядит следующим образом (за "
#~ "тем исключением, что UUID у вас будут другие):"

#~ msgid ""
#~ "$ # Terminal 1\n"
#~ "$ mkdir -p ~/tarantool_test_node_1\n"
#~ "$ cd ~/tarantool_test_node_1\n"
#~ "$ rm -R ./*\n"
#~ "$ ~/tarantool/src/tarantool\n"
#~ "$ ~/tarantool/src/tarantool: version 1.7.0-1724-g033ed69\n"
#~ "type 'help' for interactive help\n"
#~ "tarantool> box.cfg{listen = 3301}\n"
#~ "<... ...>\n"
#~ "tarantool> box.schema.user.create('replicator', {password = 'password'})\n"
#~ "<...> I> creating ./00000000000000000000.xlog.inprogress'\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> box.schema.user."
#~ "grant('replicator','execute','role','replication')\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
#~ "---\n"
#~ "- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
#~ "..."
#~ msgstr ""
#~ "$ # Terminal 1\n"
#~ "$ mkdir -p ~/tarantool_test_node_1\n"
#~ "$ cd ~/tarantool_test_node_1\n"
#~ "$ rm -R ./*\n"
#~ "$ ~/tarantool/src/tarantool\n"
#~ "$ ~/tarantool/src/tarantool: version 1.7.0-1724-g033ed69\n"
#~ "type 'help' for interactive help\n"
#~ "tarantool> box.cfg{listen = 3301}\n"
#~ "<... ...>\n"
#~ "tarantool> box.schema.user.create('replicator', {password = 'password'})\n"
#~ "<...> I> creating ./00000000000000000000.xlog.inprogress'\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> box.schema.user."
#~ "grant('replicator','execute','role','replication')\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
#~ "---\n"
#~ "- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
#~ "..."

#~ msgid ""
#~ "On the second shell, which we'll call Terminal #2, execute these commands:"
#~ msgstr "Во втором терминале (Terminal #2) выполните следующие команды:"

#~ msgid ""
#~ "$ # Terminal 2\n"
#~ "$ mkdir -p ~/tarantool_test_node_2\n"
#~ "$ cd ~/tarantool_test_node_2\n"
#~ "$ rm -R ~/tarantool_test_node_2/*\n"
#~ "$ ~/tarantool/src/tarantool\n"
#~ "tarantool> box.cfg{\n"
#~ "         >   listen = 3302,\n"
#~ "         >   replication_source = 'replicator:password@localhost:3301'\n"
#~ "         > }\n"
#~ "tarantool> box.space._cluster:select({0}, {iterator = 'GE'})"
#~ msgstr ""
#~ "$ # Terminal 2\n"
#~ "$ mkdir -p ~/tarantool_test_node_2\n"
#~ "$ cd ~/tarantool_test_node_2\n"
#~ "$ rm -R ~/tarantool_test_node_2/*\n"
#~ "$ ~/tarantool/src/tarantool\n"
#~ "tarantool> box.cfg{\n"
#~ "         >   listen = 3302,\n"
#~ "         >   replication_source = 'replicator:password@localhost:3301'\n"
#~ "         > }\n"
#~ "tarantool> box.space._cluster:select({0}, {iterator = 'GE'})"

#~ msgid ""
#~ "The result is that a replica is set up. Messages appear on Terminal #1 "
#~ "confirming that the replica has connected and that the WAL contents have been "
#~ "shipped to the replica. Messages appear on Terminal #2 showing that "
#~ "replication is starting. Also on Terminal#2 the _cluster UUID values are "
#~ "displayed, and one of them is the same as the _cluster UUID value that was "
#~ "displayed on Terminal #1, because both servers are in the same cluster."
#~ msgstr ""
#~ "В результате были заданы настройки сервера-реплики. На экране первого "
#~ "терминала (Terminal #1) появились сообщения с подтверждениями, что реплика "
#~ "установила соединение с главным сервером и что содержимое WAL-файла было "
#~ "отправлено на реплику. На экране второго терминала (Terminal #2) появились "
#~ "сообщения о том, что репликация начинается, а также там были выведены UUID из "
#~ "системного пространства _cluster (один из них совпадает с UUID в первом "
#~ "терминале, поскольку оба сервера входят в общий кластер)."

#~ msgid ""
#~ "$ # Terminal 1\n"
#~ "$ mkdir -p ~/tarantool_test_node_1\n"
#~ "<... ...>\n"
#~ "tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
#~ "---\n"
#~ "- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
#~ "...\n"
#~ "tarantool>\n"
#~ "<...> [11031] relay/127.0.0.1:58734/101/main I> recovery start\n"
#~ "<...> [11031] relay/127.0.0.1:58734/101/main I> recovering from "
#~ "`./00000000000000000000.snap'\n"
#~ "<...> [11031] relay/127.0.0.1:58734/101/main I> snapshot sent\n"
#~ "<...> [11031] relay/127.0.0.1:58734/101/main I> recover from "
#~ "`./00000000000000000000.xlog'\n"
#~ "<...> [11031] relay/127.0.0.1:58734/101/main recovery.cc:211 W> file\n"
#~ "      `./00000000000000000000.xlog` wasn't correctly closed\n"
#~ "<...> [11031] relay/127.0.0.1:58734/102/main I> recover from "
#~ "`./00000000000000000000.xlog'"
#~ msgstr ""
#~ "$ # Terminal 1\n"
#~ "$ mkdir -p ~/tarantool_test_node_1\n"
#~ "<... ...>\n"
#~ "tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
#~ "---\n"
#~ "- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
#~ "...\n"
#~ "tarantool>\n"
#~ "<...> [11031] relay/127.0.0.1:58734/101/main I> recovery start\n"
#~ "<...> [11031] relay/127.0.0.1:58734/101/main I> recovering from "
#~ "`./00000000000000000000.snap'\n"
#~ "<...> [11031] relay/127.0.0.1:58734/101/main I> snapshot sent\n"
#~ "<...> [11031] relay/127.0.0.1:58734/101/main I> recover from "
#~ "`./00000000000000000000.xlog'\n"
#~ "<...> [11031] relay/127.0.0.1:58734/101/main recovery.cc:211 W> file\n"
#~ "      `./00000000000000000000.xlog` wasn't correctly closed\n"
#~ "<...> [11031] relay/127.0.0.1:58734/102/main I> recover from "
#~ "`./00000000000000000000.xlog'"

#~ msgid ""
#~ "$ # Terminal 2\n"
#~ "$ mkdir -p ~/tarantool_test_node_2\n"
#~ "$ cd ~/tarantool_test_node_2\n"
#~ "$ rm -R ./*\n"
#~ "$ ~/tarantool/src/tarantool\n"
#~ "/home/username/tarantool/src/tarantool: version 1.7.0-1724-g033ed69\n"
#~ "type 'help' for interactive help\n"
#~ "tarantool> box.cfg{\n"
#~ "         >   listen = 3302,\n"
#~ "         >   replication_source = 'replicator:password@localhost:3301'\n"
#~ "         > }\n"
#~ "<...>\n"
#~ "<...> [11243] main/101/interactive I> mapping 1073741824 bytes for tuple "
#~ "arena...\n"
#~ "<...> [11243] main/101/interactive C> starting replication from "
#~ "localhost:3301\n"
#~ "<...> [11243] main/102/applier/localhost:3301 I> connected to 1.7.0 at "
#~ "127.0.0.1:3301\n"
#~ "<...> [11243] main/102/applier/localhost:3301 I> authenticated\n"
#~ "<...> [11243] main/102/applier/localhost:3301 I> downloading a snapshot from "
#~ "127.0.0.1:3301\n"
#~ "<...> [11243] main/102/applier/localhost:3301 I> done\n"
#~ "<...> [11243] snapshot/101/main I> creating `./00000000000000000000.snap."
#~ "inprogress'\n"
#~ "<...> [11243] snapshot/101/main I> saving snapshot `./00000000000000000000."
#~ "snap.inprogress'\n"
#~ "<...> [11243] snapshot/101/main I> done\n"
#~ "<...> [11243] iproto I> binary: started\n"
#~ "<...> [11243] iproto I> binary: bound to 0.0.0.0:3302\n"
#~ "<...> [11243] wal/101/main I> creating `./00000000000000000000.xlog."
#~ "inprogress'\n"
#~ "<...> [11243] main/101/interactive I> ready to accept requests\n"
#~ "tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
#~ "- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
#~ "  - [2, '236230b8-af3e-406b-b709-15a60b44c20c']\n"
#~ "..."
#~ msgstr ""
#~ "$ # Terminal 2\n"
#~ "$ mkdir -p ~/tarantool_test_node_2\n"
#~ "$ cd ~/tarantool_test_node_2\n"
#~ "$ rm -R ./*\n"
#~ "$ ~/tarantool/src/tarantool\n"
#~ "/home/username/tarantool/src/tarantool: version 1.7.0-1724-g033ed69\n"
#~ "type 'help' for interactive help\n"
#~ "tarantool> box.cfg{\n"
#~ "         >   listen = 3302,\n"
#~ "         >   replication_source = 'replicator:password@localhost:3301'\n"
#~ "         > }\n"
#~ "<...>\n"
#~ "<...> [11243] main/101/interactive I> mapping 1073741824 bytes for tuple "
#~ "arena...\n"
#~ "<...> [11243] main/101/interactive C> starting replication from "
#~ "localhost:3301\n"
#~ "<...> [11243] main/102/applier/localhost:3301 I> connected to 1.7.0 at "
#~ "127.0.0.1:3301\n"
#~ "<...> [11243] main/102/applier/localhost:3301 I> authenticated\n"
#~ "<...> [11243] main/102/applier/localhost:3301 I> downloading a snapshot from "
#~ "127.0.0.1:3301\n"
#~ "<...> [11243] main/102/applier/localhost:3301 I> done\n"
#~ "<...> [11243] snapshot/101/main I> creating `./00000000000000000000.snap."
#~ "inprogress'\n"
#~ "<...> [11243] snapshot/101/main I> saving snapshot `./00000000000000000000."
#~ "snap.inprogress'\n"
#~ "<...> [11243] snapshot/101/main I> done\n"
#~ "<...> [11243] iproto I> binary: started\n"
#~ "<...> [11243] iproto I> binary: bound to 0.0.0.0:3302\n"
#~ "<...> [11243] wal/101/main I> creating `./00000000000000000000.xlog."
#~ "inprogress'\n"
#~ "<...> [11243] main/101/interactive I> ready to accept requests\n"
#~ "tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
#~ "- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
#~ "  - [2, '236230b8-af3e-406b-b709-15a60b44c20c']\n"
#~ "..."

#~ msgid "On Terminal #1, execute these requests:"
#~ msgstr "В первом терминале (Terminal #1) выполните следующие запросы:"

#~ msgid ""
#~ "tarantool> s = box.schema.space.create('tester')\n"
#~ "tarantool> i = s:create_index('primary', {})\n"
#~ "tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}"
#~ msgstr ""
#~ "tarantool> s = box.schema.space.create('tester')\n"
#~ "tarantool> i = s:create_index('primary', {})\n"
#~ "tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}"

#~ msgid ""
#~ "<... ...>\n"
#~ "tarantool>\n"
#~ "tarantool>\n"
#~ "<...> [11031] relay/127.0.0.1:58734/101/main I> recovery start\n"
#~ "<...> [11031] relay/127.0.0.1:58734/101/main I> recovering from "
#~ "`./00000000000000000000.snap'\n"
#~ "<...> [11031] relay/127.0.0.1:58734/101/main I> snapshot sent\n"
#~ "<...> [11031] relay/127.0.0.1:58734/101/main I> recover from "
#~ "`./00000000000000000000.xlog'\n"
#~ "<...> [11031] relay/127.0.0.1:58734/101/main recovery.cc:211 W> file\n"
#~ "      `./00000000000000000000.xlog` wasn't correctly closed\n"
#~ "<...> [11031] relay/127.0.0.1:58734/102/main I> recover from "
#~ "`./00000000000000000000.xlog'\n"
#~ "tarantool> s = box.schema.space.create('tester')\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> i = s:create_index('primary', {})\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}\n"
#~ "---\n"
#~ "- [1, 'Tuple inserted on Terminal #1']\n"
#~ "..."
#~ msgstr ""
#~ "<... ...>\n"
#~ "tarantool>\n"
#~ "tarantool>\n"
#~ "<...> [11031] relay/127.0.0.1:58734/101/main I> recovery start\n"
#~ "<...> [11031] relay/127.0.0.1:58734/101/main I> recovering from "
#~ "`./00000000000000000000.snap'\n"
#~ "<...> [11031] relay/127.0.0.1:58734/101/main I> snapshot sent\n"
#~ "<...> [11031] relay/127.0.0.1:58734/101/main I> recover from "
#~ "`./00000000000000000000.xlog'\n"
#~ "<...> [11031] relay/127.0.0.1:58734/101/main recovery.cc:211 W> file\n"
#~ "      `./00000000000000000000.xlog` wasn't correctly closed\n"
#~ "<...> [11031] relay/127.0.0.1:58734/102/main I> recover from "
#~ "`./00000000000000000000.xlog'\n"
#~ "tarantool> s = box.schema.space.create('tester')\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> i = s:create_index('primary', {})\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}\n"
#~ "---\n"
#~ "- [1, 'Tuple inserted on Terminal #1']\n"
#~ "..."

#~ msgid ""
#~ "The creation and insertion were successful on Terminal #1. Nothing has "
#~ "happened on Terminal #2."
#~ msgstr ""
#~ "В первом терминале успешно отработали операции CREATE и INSERT. Но во втором "
#~ "терминале ничего не произошло."

#~ msgid "On Terminal #2, execute these requests:"
#~ msgstr "Во втором терминале (Terminal #2) выполните следующие запросы:"

#~ msgid ""
#~ "tarantool> s = box.space.tester\n"
#~ "tarantool> s:select({1}, {iterator = 'GE'})\n"
#~ "tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}"
#~ msgstr ""
#~ "tarantool> s = box.space.tester\n"
#~ "tarantool> s:select({1}, {iterator = 'GE'})\n"
#~ "tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}"

#~ msgid ""
#~ "Now the screen looks like this (remember to click on the \"Terminal #2\" tab "
#~ "when looking at Terminal #2 results):"
#~ msgstr "Теперь вывод на экране выглядит следующим образом:"

#~ msgid ""
#~ "<... ...>\n"
#~ "tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
#~ "- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
#~ "  - [2, '236230b8-af3e-406b-b709-15a60b44c20c']\n"
#~ "...\n"
#~ "tarantool> s = box.space.tester\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> s:select({1}, {iterator = 'GE'})\n"
#~ "---\n"
#~ "- - [1, 'Tuple inserted on Terminal #1']\n"
#~ "...\n"
#~ "tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
#~ "---\n"
#~ "- [2, 'Tuple inserted on Terminal #2']\n"
#~ "..."
#~ msgstr ""
#~ "<... ...>\n"
#~ "tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
#~ "- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
#~ "  - [2, '236230b8-af3e-406b-b709-15a60b44c20c']\n"
#~ "...\n"
#~ "tarantool> s = box.space.tester\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> s:select({1}, {iterator = 'GE'})\n"
#~ "---\n"
#~ "- - [1, 'Tuple inserted on Terminal #1']\n"
#~ "...\n"
#~ "tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
#~ "---\n"
#~ "- [2, 'Tuple inserted on Terminal #2']\n"
#~ "..."

#~ msgid ""
#~ "The selection and insertion were successful on Terminal #2. Nothing has "
#~ "happened on Terminal #1."
#~ msgstr ""
#~ "Во втором терминале успешно отработали операции SELECT и INSERT. Но в первом "
#~ "терминале ничего не произошло."

#~ msgid "On Terminal #1, execute these Tarantool requests and shell commands:"
#~ msgstr "В первом терминале (Terminal #1) выполните следующие запросы и команды:"

#~ msgid ""
#~ "$ os.exit()\n"
#~ "$ ls -l ~/tarantool_test_node_1\n"
#~ "$ ls -l ~/tarantool_test_node_2"
#~ msgstr ""
#~ "$ os.exit()\n"
#~ "$ ls -l ~/tarantool_test_node_1\n"
#~ "$ ls -l ~/tarantool_test_node_2"

#~ msgid ""
#~ "Now Tarantool #1 is stopped. Messages appear on Terminal #2 announcing that "
#~ "fact. The ``ls -l`` commands show that both servers have made snapshots, "
#~ "which have similar sizes because they both contain the same tuples."
#~ msgstr ""
#~ "Теперь Tarantool-сервер в первом терминале остановлен. В окне второго "
#~ "терминала появились сообщения об этом событии. С помощью команд ``ls -l`` мы "
#~ "убедились, что на обоих серверах создались файлы-снимки с одинаковыми "
#~ "размерами, поскольку там содержатся одни и те же кортежи."

#~ msgid ""
#~ "<... ...>\n"
#~ "tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}\n"
#~ "---\n"
#~ "- [1, 'Tuple inserted on Terminal #1']\n"
#~ "...\n"
#~ "tarantool> os.exit()\n"
#~ "$ ls -l ~/tarantool_test_node_1\n"
#~ "total 8\n"
#~ "-rw-rw-r-- 1  4925 May  5 11:12 00000000000000000000.snap\n"
#~ "-rw-rw-r-- 1   634 May  5 11:45 00000000000000000000.xlog\n"
#~ "$ ls -l ~/tarantool_test_node_2/\n"
#~ "total 8\n"
#~ "-rw-rw-r-- 1  4925 May  5 11:20 00000000000000000000.snap\n"
#~ "-rw-rw-r-- 1   704 May  5 11:38 00000000000000000000.xlog\n"
#~ "$"
#~ msgstr ""
#~ "<... ...>\n"
#~ "tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}\n"
#~ "---\n"
#~ "- [1, 'Tuple inserted on Terminal #1']\n"
#~ "...\n"
#~ "tarantool> os.exit()\n"
#~ "$ ls -l ~/tarantool_test_node_1\n"
#~ "total 8\n"
#~ "-rw-rw-r-- 1  4925 May  5 11:12 00000000000000000000.snap\n"
#~ "-rw-rw-r-- 1   634 May  5 11:45 00000000000000000000.xlog\n"
#~ "$ ls -l ~/tarantool_test_node_2/\n"
#~ "total 8\n"
#~ "-rw-rw-r-- 1  4925 May  5 11:20 00000000000000000000.snap\n"
#~ "-rw-rw-r-- 1   704 May  5 11:38 00000000000000000000.xlog\n"
#~ "$"

#~ msgid ""
#~ "<... ...>\n"
#~ "tarantool> s:select({1}, {iterator = 'GE'})\n"
#~ "---\n"
#~ "- - [1, 'Tuple inserted on Terminal #1']\n"
#~ "...\n"
#~ "tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
#~ "---\n"
#~ "- [2, 'Tuple inserted on Terminal #2']\n"
#~ "...\n"
#~ "tarantool>\n"
#~ "<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
#~ "<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
#~ "  unexpected EOF when reading from socket,\n"
#~ "  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken pipe\n"
#~ "<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 second"
#~ msgstr ""
#~ "<... ...>\n"
#~ "tarantool> s:select({1}, {iterator = 'GE'})\n"
#~ "---\n"
#~ "- - [1, 'Tuple inserted on Terminal #1']\n"
#~ "...\n"
#~ "tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
#~ "---\n"
#~ "- [2, 'Tuple inserted on Terminal #2']\n"
#~ "...\n"
#~ "tarantool>\n"
#~ "<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
#~ "<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
#~ "  unexpected EOF when reading from socket,\n"
#~ "  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken pipe\n"
#~ "<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 second"

#~ msgid "On Terminal #2, ignore the error messages, and execute these requests:"
#~ msgstr ""
#~ "Во втором терминале (Terminal #2) проигнорируйте сообщения об ошибках и "
#~ "выполните следующие запросы:"

#~ msgid ""
#~ "tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
#~ "tarantool> box.space.tester:insert{3, 'Another'}"
#~ msgstr ""
#~ "tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
#~ "tarantool> box.space.tester:insert{3, 'Another'}"

#~ msgid "Now the screen looks like this (ignoring the error messages):"
#~ msgstr ""
#~ "Теперь вывод на экране выглядит следующим образом (сообщения об ошибках мы не "
#~ "приводим):"

#~ msgid ""
#~ "<... ...>\n"
#~ "tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
#~ "---\n"
#~ "- [2, 'Tuple inserted on Terminal #2']\n"
#~ "...\n"
#~ "tarantool>\n"
#~ "<...> [11243] main/105/applier/localhost:3301 I> can't read row\n"
#~ "<...> [11243] main/105/applier/localhost:3301 coio.cc:352 !> SystemError\n"
#~ "  unexpected EOF when reading from socket,\n"
#~ "  called on fd 6, aka 127.0.0.1:58734, peer of 127.0.0.1:3301: Broken pipe\n"
#~ "<...> [11243] main/105/applier/localhost:3301 I> will retry every 1 second\n"
#~ "tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
#~ "---\n"
#~ "- - [1, 'Tuple inserted on Terminal #1']\n"
#~ "  - [2, 'Tuple inserted on Terminal #2']\n"
#~ "...\n"
#~ "tarantool> box.space.tester:insert{3, 'Another'}\n"
#~ "---\n"
#~ "- [3, 'Another']\n"
#~ "..."
#~ msgstr ""
#~ "<... ...>\n"
#~ "tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
#~ "---\n"
#~ "- [2, 'Tuple inserted on Terminal #2']\n"
#~ "...\n"
#~ "tarantool>\n"
#~ "<...> [11243] main/105/applier/localhost:3301 I> can't read row\n"
#~ "<...> [11243] main/105/applier/localhost:3301 coio.cc:352 !> SystemError\n"
#~ "  unexpected EOF when reading from socket,\n"
#~ "  called on fd 6, aka 127.0.0.1:58734, peer of 127.0.0.1:3301: Broken pipe\n"
#~ "<...> [11243] main/105/applier/localhost:3301 I> will retry every 1 second\n"
#~ "tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
#~ "---\n"
#~ "- - [1, 'Tuple inserted on Terminal #1']\n"
#~ "  - [2, 'Tuple inserted on Terminal #2']\n"
#~ "...\n"
#~ "tarantool> box.space.tester:insert{3, 'Another'}\n"
#~ "---\n"
#~ "- [3, 'Another']\n"
#~ "..."

#~ msgid ""
#~ "Terminal #2 has done a select and an insert, even though Terminal #1 is down."
#~ msgstr ""
#~ "Запросы SELECT и INSERT во втором терминале отработали несмотря на то, что "
#~ "сервер в первом терминале остановлен."

#~ msgid "On Terminal #1 execute these commands:"
#~ msgstr "В первом терминале (Terminal #1) выполните следующие запросы:"

#~ msgid ""
#~ "$ ~/tarantool/src/tarantool\n"
#~ "tarantool> box.cfg{listen = 3301}\n"
#~ "tarantool> box.space.tester:select({0}, {iterator = 'GE'})"
#~ msgstr ""
#~ "$ ~/tarantool/src/tarantool\n"
#~ "tarantool> box.cfg{listen = 3301}\n"
#~ "tarantool> box.space.tester:select({0}, {iterator = 'GE'})"

#~ msgid ""
#~ "<... ...>\n"
#~ "tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}\n"
#~ "---\n"
#~ "- [1, 'Tuple inserted on Terminal #1']\n"
#~ "...\n"
#~ "tarantool> os.exit()\n"
#~ "$ ls -l ~/tarantool_test_node_1\n"
#~ "total 8\n"
#~ "-rw-rw-r-- 1  4925 May  5 11:12 00000000000000000000.snap\n"
#~ "-rw-rw-r-- 1   634 May  5 11:45 00000000000000000000.xlog\n"
#~ "$ ls -l ~/tarantool_test_node_2/\n"
#~ "total 8\n"
#~ "-rw-rw-r-- 1  4925 May  5 11:20 00000000000000000000.snap\n"
#~ "-rw-rw-r-- 1   704 May  5 11:38 00000000000000000000.xlog\n"
#~ "$ ~/tarantool/src/tarantool\n"
#~ "<...>\n"
#~ "tarantool> box.cfg{listen = 3301}\n"
#~ "<...> [22612] main/101/interactive I> ready to accept requests\n"
#~ "<... ...>\n"
#~ "tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
#~ "- - [1, 'Tuple inserted on Terminal #1']\n"
#~ "..."
#~ msgstr ""
#~ "<... ...>\n"
#~ "tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}\n"
#~ "---\n"
#~ "- [1, 'Tuple inserted on Terminal #1']\n"
#~ "...\n"
#~ "tarantool> os.exit()\n"
#~ "$ ls -l ~/tarantool_test_node_1\n"
#~ "total 8\n"
#~ "-rw-rw-r-- 1  4925 May  5 11:12 00000000000000000000.snap\n"
#~ "-rw-rw-r-- 1   634 May  5 11:45 00000000000000000000.xlog\n"
#~ "$ ls -l ~/tarantool_test_node_2/\n"
#~ "total 8\n"
#~ "-rw-rw-r-- 1  4925 May  5 11:20 00000000000000000000.snap\n"
#~ "-rw-rw-r-- 1   704 May  5 11:38 00000000000000000000.xlog\n"
#~ "$ ~/tarantool/src/tarantool\n"
#~ "<...>\n"
#~ "tarantool> box.cfg{listen = 3301}\n"
#~ "<...> [22612] main/101/interactive I> ready to accept requests\n"
#~ "<... ...>\n"
#~ "tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
#~ "- - [1, 'Tuple inserted on Terminal #1']\n"
#~ "..."

#~ msgid ""
#~ "<... ...>\n"
#~ "tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
#~ "---\n"
#~ "- [2, 'Tuple inserted on Terminal #2']\n"
#~ "...\n"
#~ "tarantool>\n"
#~ "<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
#~ "<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
#~ "  unexpected EOF when reading from socket,\n"
#~ "  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken pipe\n"
#~ "<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 second\n"
#~ "tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
#~ "---\n"
#~ "- - [1, 'Tuple inserted on Terminal #1']\n"
#~ "  - [2, 'Tuple inserted on Terminal #2']\n"
#~ "...\n"
#~ "tarantool> box.space.tester:insert{3, 'Another'}\n"
#~ "---\n"
#~ "- [3, 'Another']\n"
#~ "...\n"
#~ "<...> [11243] main/105/applier/localhost:3301 I> connected to 1.7.0 at "
#~ "127.0.0.1:3301\n"
#~ "<...> [11243] main/105/applier/localhost:3301 I> authenticated"
#~ msgstr ""
#~ "<... ...>\n"
#~ "tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
#~ "---\n"
#~ "- [2, 'Tuple inserted on Terminal #2']\n"
#~ "...\n"
#~ "tarantool>\n"
#~ "<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
#~ "<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
#~ "  unexpected EOF when reading from socket,\n"
#~ "  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken pipe\n"
#~ "<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 second\n"
#~ "tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
#~ "---\n"
#~ "- - [1, 'Tuple inserted on Terminal #1']\n"
#~ "  - [2, 'Tuple inserted on Terminal #2']\n"
#~ "...\n"
#~ "tarantool> box.space.tester:insert{3, 'Another'}\n"
#~ "---\n"
#~ "- [3, 'Another']\n"
#~ "...\n"
#~ "<...> [11243] main/105/applier/localhost:3301 I> connected to 1.7.0 at "
#~ "127.0.0.1:3301\n"
#~ "<...> [11243] main/105/applier/localhost:3301 I> authenticated"

#~ msgid ""
#~ "The master has reconnected to the cluster, and has NOT found what the replica "
#~ "wrote while the master was away. That is not a surprise -- the replica has "
#~ "not been asked to act as a replication source."
#~ msgstr ""
#~ "Главный сервер снова установил соединение с кластером и НЕ обнаружил "
#~ "изменения, сделанные репликой за время его недоступности. Это и не "
#~ "удивительно: мы же не просили реплику выступать в качестве источника "
#~ "репликации."

#~ msgid ""
#~ "tarantool> box.cfg{\n"
#~ "         >   replication_source = 'replicator:password@localhost:3302'\n"
#~ "         > }\n"
#~ "tarantool> box.space.tester:select({0}, {iterator = 'GE'})"
#~ msgstr ""
#~ "tarantool> box.cfg{\n"
#~ "         >   replication_source = 'replicator:password@localhost:3302'\n"
#~ "         > }\n"
#~ "tarantool> box.space.tester:select({0}, {iterator = 'GE'})"

#~ msgid ""
#~ "<... ...>\n"
#~ "$ ~/tarantool/src/tarantool\n"
#~ "<...>\n"
#~ "tarantool> box.cfg{listen = 3301}\n"
#~ "<...> [22612] main/101/interactive I> ready to accept requests\n"
#~ "<... ...>\n"
#~ "tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
#~ "---\n"
#~ "- - [1, 'Tuple inserted on Terminal #1']\n"
#~ "...\n"
#~ "tarantool> box.cfg{\n"
#~ "         >   replication_source='replicator:password@localhost:3302'\n"
#~ "         > }\n"
#~ "[28987] main/101/interactive C> starting replication from localhost:3302\n"
#~ "---\n"
#~ "...\n"
#~ "[22612] main/101/interactive C> starting replication from localhost:3302\n"
#~ "[22612] main/101/interactive I> set 'replication_source' configuration\n"
#~ "        option to \"replicator:password@localhost:3302\"\n"
#~ "[22612] main/104/applier/localhost:3302 I> connected to 1.7.0 at "
#~ "127.0.0.1:3302\n"
#~ "[22612] main/104/applier/localhost:3302 I> authenticated\n"
#~ "[22612] wal/101/main I> creating `./00000000000000000008.xlog.inprogress'\n"
#~ "[22612] relay/127.0.0.1:33510/102/main I> done `./00000000000000000000.xlog'\n"
#~ "[22612] relay/127.0.0.1:33510/102/main I> recover from "
#~ "`./00000000000000000008.xlog'\n"
#~ "tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
#~ "---\n"
#~ "- - [1, 'Tuple inserted on Terminal #1']\n"
#~ "  - [2, 'Tuple inserted on Terminal #2']\n"
#~ "  - [3, 'Another']\n"
#~ "..."
#~ msgstr ""
#~ "<... ...>\n"
#~ "$ ~/tarantool/src/tarantool\n"
#~ "<...>\n"
#~ "tarantool> box.cfg{listen = 3301}\n"
#~ "<...> [22612] main/101/interactive I> ready to accept requests\n"
#~ "<... ...>\n"
#~ "tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
#~ "---\n"
#~ "- - [1, 'Tuple inserted on Terminal #1']\n"
#~ "...\n"
#~ "tarantool> box.cfg{\n"
#~ "         >   replication_source='replicator:password@localhost:3302'\n"
#~ "         > }\n"
#~ "[28987] main/101/interactive C> starting replication from localhost:3302\n"
#~ "---\n"
#~ "...\n"
#~ "[22612] main/101/interactive C> starting replication from localhost:3302\n"
#~ "[22612] main/101/interactive I> set 'replication_source' configuration\n"
#~ "        option to \"replicator:password@localhost:3302\"\n"
#~ "[22612] main/104/applier/localhost:3302 I> connected to 1.7.0 at "
#~ "127.0.0.1:3302\n"
#~ "[22612] main/104/applier/localhost:3302 I> authenticated\n"
#~ "[22612] wal/101/main I> creating `./00000000000000000008.xlog.inprogress'\n"
#~ "[22612] relay/127.0.0.1:33510/102/main I> done `./00000000000000000000.xlog'\n"
#~ "[22612] relay/127.0.0.1:33510/102/main I> recover from "
#~ "`./00000000000000000008.xlog'\n"
#~ "tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
#~ "---\n"
#~ "- - [1, 'Tuple inserted on Terminal #1']\n"
#~ "  - [2, 'Tuple inserted on Terminal #2']\n"
#~ "  - [3, 'Another']\n"
#~ "..."

#~ msgid ""
#~ "<... ...>\n"
#~ "tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
#~ "---\n"
#~ "- [2, 'Tuple inserted on Terminal #2']\n"
#~ "...\n"
#~ "tarantool>\n"
#~ "<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
#~ "<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
#~ "  unexpected EOF when reading from socket,\n"
#~ "  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken pipe\n"
#~ "<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 second\n"
#~ "tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
#~ "---\n"
#~ "- - [1, 'Tuple inserted on Terminal #1']\n"
#~ "  - [2, 'Tuple inserted on Terminal #2']\n"
#~ "...\n"
#~ "tarantool> box.space.tester:insert{3, 'Another'}\n"
#~ "---\n"
#~ "- [3, 'Another']\n"
#~ "...\n"
#~ "<...> [11243] main/105/applier/localhost:3301 I> connected to 1.7.0 at "
#~ "127.0.0.1:3301\n"
#~ "<...> [11243] main/105/applier/localhost:3301 I> authenticated\n"
#~ "tarantool>\n"
#~ "<...> [11243] relay/127.0.0.1:36150/101/main I> recover from "
#~ "`./00000000000000000000.xlog'\n"
#~ "<...> [11243] relay/127.0.0.1:36150/101/main recovery.cc:211 W> file\n"
#~ "     `./00000000000000000000.xlog` wasn't correctly closed\n"
#~ "<...> [11243] relay/127.0.0.1:36150/102/main I> recover from "
#~ "`./00000000000000000000.xlog'"
#~ msgstr ""
#~ "<... ...>\n"
#~ "tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
#~ "---\n"
#~ "- [2, 'Tuple inserted on Terminal #2']\n"
#~ "...\n"
#~ "tarantool>\n"
#~ "<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
#~ "<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
#~ "  unexpected EOF when reading from socket,\n"
#~ "  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken pipe\n"
#~ "<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 second\n"
#~ "tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
#~ "---\n"
#~ "- - [1, 'Tuple inserted on Terminal #1']\n"
#~ "  - [2, 'Tuple inserted on Terminal #2']\n"
#~ "...\n"
#~ "tarantool> box.space.tester:insert{3, 'Another'}\n"
#~ "---\n"
#~ "- [3, 'Another']\n"
#~ "...\n"
#~ "<...> [11243] main/105/applier/localhost:3301 I> connected to 1.7.0 at "
#~ "127.0.0.1:3301\n"
#~ "<...> [11243] main/105/applier/localhost:3301 I> authenticated\n"
#~ "tarantool>\n"
#~ "<...> [11243] relay/127.0.0.1:36150/101/main I> recover from "
#~ "`./00000000000000000000.xlog'\n"
#~ "<...> [11243] relay/127.0.0.1:36150/101/main recovery.cc:211 W> file\n"
#~ "     `./00000000000000000000.xlog` wasn't correctly closed\n"
#~ "<...> [11243] relay/127.0.0.1:36150/102/main I> recover from "
#~ "`./00000000000000000000.xlog'"

#~ msgid ""
#~ "This shows that the two servers are once again in synch, and that each server "
#~ "sees what the other server wrote."
#~ msgstr ""
#~ "Тут мы видим, что оба сервера снова синхронизовались и что каждый из них "
#~ "видит те записи, которые сделал другой."

#~ msgid ""
#~ "To clean up, say \"``os.exit()``\" on both Terminal #1 and Terminal #2, and "
#~ "then on either terminal say:"
#~ msgstr ""
#~ "Чтобы удалить все тестовые данные, выполните \"``os.exit()``\" на обоих "
#~ "терминалах, а затем на каждом из них выполните следующие команды:"

#~ msgid ""
#~ "$ cd ~\n"
#~ "$ rm -R ~/tarantool_test_node_1\n"
#~ "$ rm -R ~/tarantool_test_node_2"
#~ msgstr ""
#~ "$ cd ~\n"
#~ "$ rm -R ~/tarantool_test_node_1\n"
#~ "$ rm -R ~/tarantool_test_node_2"

#~ msgid ""
#~ "The exact procedure for backing up a database depends on: how up-to-date the "
#~ "database must be, how frequently backups must be taken, whether it is okay to "
#~ "disrupt other users, and whether the procedure should be optimized for size "
#~ "(saving disk space) or for speed (saving time). So there is a spectrum of "
#~ "possible policies, ranging from cold-and-simple to hot-and-difficult."
#~ msgstr ""
#~ "При выборе конкретной процедуры для резервного копирования базы данных нужно "
#~ "учитывать следующие требования: насколько актуальной должна быть копия, можно "
#~ "ли временно отключать других пользователей, а также нужна ли оптимизация "
#~ "размера копии (чтобы копия занимала меньше места на диске) или скорости самой "
#~ "процедуры (чтобы процедура занимала меньше времени). Выбирать можно из "
#~ "нескольких вариантов в диапазоне от \"простого и холодного\" до \"трудного и "
#~ "горячего\"."

#~ msgid "Cold backup"
#~ msgstr ""
#~ "#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "**\"Холодное\" резервирование**"

#~ msgid ""
#~ "Prevent all users from writing to the database. This can be done by shutting "
#~ "down the server, or by saying ``box.cfg{read_only=true}`` and then ensuring "
#~ "that all earlier writes are complete (:program:`fsync` can be used for this "
#~ "purpose)."
#~ msgstr ""
#~ "Временно запретите всем пользователям делать записи в базе. Для этого можно "
#~ "остановить Tarantool-сервер, либо ввести запрос ``box.cfg{read_only=true}`` и "
#~ "убедиться, что все обращения на запись завершились (для этого можно "
#~ "использовать :program:`fsync`)."

#~ msgid "If this is a backup of the whole database, say :samp:`box.snapshot()`."
#~ msgstr ""
#~ "Если вы хотите создать резеврную копию для всей базы целиком, введите запрос :"
#~ "samp:`box.snapshot()`."

#~ msgid ""
#~ "In essence: :ref:`replication <index-box_replication>` is useful for backup "
#~ "as well as for load balancing. Therefore taking a backup is a matter of "
#~ "ensuring that any given replica is up to date, and doing a cold backup on it. "
#~ "Since all the other replicas continue to operate, this is not a cold backup "
#~ "from the end user's point of view. This could be done on a regular basis, "
#~ "with a cron job or with a Tarantool fiber."
#~ msgstr ""
#~ "Суть процедуры: для резервирования (а также для балансирования нагрузки) "
#~ "можно использовать :ref:`репликацию <index-box_replication>`. Процедура "
#~ "резервирования в рамках репликационного кластера сводится к тому, чтобы "
#~ "держать все реплики в актуальном состоянии и периодически делать с них "
#~ "\"холодные\" копии. Поскольку во время снятия копии с какой-либо одной "
#~ "реплики все остальные реплики продолжают синхронизироваться с главным "
#~ "сервером, то эта процедура несколько отличается от описанной выше процедуры "
#~ "\"холодного\" резервирования. Регулярное резервирование в кластере можно "
#~ "настроить с помощью планировщика :program:`cron` или Tarantool-файбера."

#~ msgid ""
#~ "First, put your application's business logic in a Tarantool-Lua module that "
#~ "exports its functions for CALL."
#~ msgstr ""
#~ "Во-первых, вынесите всю бизнес-логику своего приложения в отдельный Tarantool-"
#~ "модуль на языке Lua так, чтобы все нужные функции были доступны для вызова "
#~ "извне (CALL)."

#~ msgid ""
#~ "This file is maintained by the application's developers. On its side, "
#~ "Tarantool Team provides templates for you to `assemble deb/rpm packages "
#~ "<https://github.com/tarantool/modulekit>`_ and utilities to quickly `assemble "
#~ "packages for specific platforms <https://github.com/tarantool/build>`_. If "
#~ "needed, you can split applications into standalone files and/or modules."
#~ msgstr ""
#~ "Поддержка этого файла лежит на стороне разработчиков приложения. А команда "
#~ "разработки Tarantool'а со своей стороны предлагает шаблоны, для того чтобы вы "
#~ "могли `создать у себя deb/rpm-сборку <https://github.com/tarantool/"
#~ "modulekit>`_, а также утилиты для быстрого `создания сборок под разные "
#~ "платформы <https://github.com/tarantool/build>`_. Если понадобится, вы можете "
#~ "разбить приложения на отдельные файлы и/или модули."

#~ msgid ""
#~ "Second, put an initialization script to the :file:`/etc/tarantool/instances."
#~ "available` directory."
#~ msgstr ""
#~ "Во вторых, положите скрипт инициализации в директорию :file:`/etc/tarantool/"
#~ "instances.available`."

#~ msgid ""
#~ "#!/usr/bin/env tarantool\n"
#~ "\n"
#~ "box.cfg {\n"
#~ "  listen = 3301;\n"
#~ "}\n"
#~ "\n"
#~ "if myapp ~= nil then\n"
#~ "  -- hot code reload using tarantoolctl or dofile()\n"
#~ "\n"
#~ "  -- unload old application\n"
#~ "  myapp.stop()\n"
#~ "  -- clear cache for loaded modules and dependencies\n"
#~ "  package.loaded['myapp'] = nil\n"
#~ "  package.loaded['somedep'] = nil; -- dependency of 'myapp'\n"
#~ "end\n"
#~ "\n"
#~ "-- load a new version of app and all dependencies\n"
#~ "myapp = require('myapp').start({some app options controlled by sysadmins})"
#~ msgstr ""
#~ "#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "#!/usr/bin/env tarantool\n"
#~ "\n"
#~ "box.cfg {\n"
#~ "listen = 3301;\n"
#~ "}\n"
#~ "\n"
#~ "if myapp ~= nil then\n"
#~ "-- \"Горячая\" загрузка кода с помощью tarantoolctl или dofile()\n"
#~ "\n"
#~ "-- Выгрузка старого приложения\n"
#~ "myapp.stop()\n"
#~ "-- Очистка кеша от загруженных модулей и зависимостей\n"
#~ "package.loaded['myapp'] = nil\n"
#~ "package.loaded['somedep'] = nil; -- dependency of 'myapp'\n"
#~ "end\n"
#~ "\n"
#~ "-- Загрузка новой версии приложения и всех зависимостей\n"
#~ "myapp = require('myapp').start({some app options controlled by sysadmins})"

#~ msgid ""
#~ "As a more detailed example, you can take the :file:`example.lua` script that "
#~ "ships with Tarantool and defines all configuration options."
#~ msgstr ""
#~ "Более детальный пример (со всеми настройками) содержится в файле :file:"
#~ "`example.lua`, который входит в состав дистрибутива Tarantool'а."

#~ msgid ""
#~ "This initialization script is actually a configuration file and should be "
#~ "maintained by system administrators, while developers only provide a template."
#~ msgstr ""
#~ "Этот скрипт инициализации по сути является конфигурационным файлом. Его "
#~ "поддержкой должны заниматься системные администраторы, в то время как "
#~ "разработчики только предоставляют им шаблон."

#~ msgid ""
#~ "Now update your app file in :file:`/usr/share/tarantool`. Replace your "
#~ "application file (for example, :file:`/usr/share/tarantool/myapp.lua`) and "
#~ "manually reload the :file:`myappcfg.lua` initialization script using :program:"
#~ "`tarantoolctl`:"
#~ msgstr ""
#~ "Теперь обновите файл с вашим приложением в директории :file:`/usr/share/"
#~ "tarantool`. Замените старую версию файла (например, :file:`/usr/share/"
#~ "tarantool/myapp.lua`) и вручную загрузите скрипт инициализации :file:"
#~ "`myappcfg.lua` с помощью утилиты :program:`tarantoolctl`:"

#~ msgid ""
#~ "After that, you need to manually flush the cache of ``package.loaded`` "
#~ "modules."
#~ msgstr "После этого вам нужно вручную очистить кеш модулей ``package.loaded``."

#~ msgid ""
#~ "For deb/rpm packages, you can add the ``tarantoolctl eval`` instruction "
#~ "directly into Tarantool's specification in :file:`RPM.spec` and the :file:`/"
#~ "debian` directory."
#~ msgstr ""
#~ "Чтобы создать deb/rpm-сборку, вы можете добавить инструкцию ``tarantoolctl "
#~ "eval`` прямо в спецификацию Tarantool'а в файле :file:`RPM.spec` и в "
#~ "директории :file:`/debian`."

#~ msgid ""
#~ "Finally, clients make a CALL to ``myapp.api_for_call`` and other API "
#~ "functions."
#~ msgstr ""
#~ "В итоге клиенты делают вызов (CALL) функции ``myapp.api_for_call`` и других "
#~ "функций из API."

#~ msgid ""
#~ "In the case of ``tarantool-http``, there is no need to start the binary "
#~ "protocol at all."
#~ msgstr ""
#~ "Если вы используете ``tarantool-http``, то запускать бинарный протокол не "
#~ "нужно."

#~ msgid ""
#~ "This information applies for users who created databases with older versions "
#~ "of the Tarantool server, and have now installed a newer version. The request "
#~ "to make in this case is: :samp:`box.schema.upgrade()`."
#~ msgstr ""
#~ "Эта информация полезна в том случае, если у вас есть база данных, работающая "
#~ "на какой-либо старой версии Tarantool'а, а теперь вы установили Tarantool "
#~ "новой версии. В этом случае выполните запрос :samp:`box.schema.upgrade()`."

#~ msgid "The server processes these signals during the main thread event loop:"
#~ msgstr ""
#~ "Во время основного цикла Tarantool-сервер обрабатывает следующие сигналы:"

#~ msgid "SIGINT"
#~ msgstr "SIGINT"

#~ msgid ""
#~ "Other signals will result in behavior defined by the operating system. "
#~ "Signals other than SIGKILL may be ignored, especially if the server is "
#~ "executing a long-running procedure which prevents return to the main thread "
#~ "event loop."
#~ msgstr ""
#~ "Действие других сигналов определяется операционной системой. Все сигналы, "
#~ "кроме SIGKILL, могут быть проигнорированы, особенно если Tarantool-сервер "
#~ "выполняет длительную процедуру, которая позволяет вернуться к главному циклу."

#~ msgid "Process title"
#~ msgstr "Название процесса"

#~ msgid ""
#~ "Linux and FreeBSD operating systems allow a running process to modify its "
#~ "title, which otherwise contains the program name. Tarantool uses this feature "
#~ "to help meet the needs of system administration, such as figuring out what "
#~ "services are running on a host, their status, and so on."
#~ msgstr ""
#~ "Операционные системы Linux и FreeBSD позволяют запущенному процессу менять "
#~ "его название (title), в котором изначально содержится имя программы (name). "
#~ "Tarantool использует эту возможность, чтобы упростить работу системного "
#~ "администратора, например посмотреть, какие службы запущены на хосте, их "
#~ "статус и т.д."

#~ msgid "A Tarantool server's process title has these components:"
#~ msgstr "Название процесса Tarantool-сервера состоит из следующих частей:"

#~ msgid ""
#~ ":extsamp:`{**{program_name}**} [{**{initialization_file_name}**}] "
#~ "{**{<role_name>}**} [{**{custom_proc_title}**}]`"
#~ msgstr ""
#~ ":extsamp:`{**{имя_программы}**} [{**{имя_файла_инициализации}**}] "
#~ "{**{<имя_роли>}**} [{**{название_процесса}**}]`"

#~ msgid "**program_name** is typically \"tarantool\"."
#~ msgstr "**имя_программы** — это, как правило, \"tarantool\"."

#~ msgid ""
#~ "**initialization_file_name** is the name of an :ref:`initialization file "
#~ "<index-init_label>`, if one was specified."
#~ msgstr ""
#~ "**имя_файла_инициализации** — это имя  :ref:`файла инициализации на Lua "
#~ "<index-init_label>`, если этот файл был указан при запуске."

#~ msgid "**role_name** is:"
#~ msgstr "**имя_роли** — это может быть один из следующих вариантов:"

#~ msgid "\"running\" (ordinary node \"ready to accept requests\"),"
#~ msgstr "\"running\" (узел находится в режиме \"готов к принятию запросов\"),"

#~ msgid "\"loading\" (ordinary node recovering from old snap and wal files),"
#~ msgstr ""
#~ "\"loading\" (узел, который загружает данные из ранее сохраненного снимка и "
#~ "WAL-файла),"

#~ msgid "\"orphan\" (not in a cluster),"
#~ msgstr "\"orphan\" (узел не входит в состав кластера),"

#~ msgid "\"dumper\" + process-id (saving a snapshot)."
#~ msgstr "\"dumper\" + process-id (идет сохранение снимка)."

#~ msgid ""
#~ "**custom_proc_title** is taken from the :ref:`custom_proc_title <cfg_basic-"
#~ "custom_proc_title>` configuration parameter, if one was specified."
#~ msgstr ""
#~ "**название_процесса** — это необязательное название Tarantool-процесса в "
#~ "системе, которое берется из конфигурационного параметра :ref:"
#~ "`custom_proc_title <cfg_basic-custom_proc_title>`, если он указан."

#~ msgid ""
#~ "$ ps -AF | grep tarantool\n"
#~ "1000     17337 16716  1 91362  6916   0 11:07 pts/5    00:00:13 tarantool "
#~ "script.lua <running>"
#~ msgstr ""
#~ "$ ps -AF | grep tarantool\n"
#~ "1000     17337 16716  1 91362  6916   0 11:07 pts/5    00:00:13 tarantool "
#~ "script.lua <running>"

#~ msgid "System-specific administration notes"
#~ msgstr "Заметки по администрированию для разных платформ"

#~ msgid ""
#~ "This section will contain information about issues or features which exist on "
#~ "some platforms but not others - for example, on certain versions of a "
#~ "particular Linux distribution."
#~ msgstr ""
#~ "#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "В этом разделе приводится информация по проблемам и особенностям, которые "
#~ "относятся только к конкретным платформам. Например, к определенным версиям "
#~ "Linux-систем."

#~ msgid "Debian GNU/Linux and Ubuntu"
#~ msgstr "Debian GNU/Linux and Ubuntu"

#~ msgid ""
#~ "$ ln -s /etc/tarantool/instances.available/*instance-name.cfg* /etc/tarantool/"
#~ "instances.enabled/"
#~ msgstr ""
#~ "$ ln -s /etc/tarantool/instances.available/*instance-name.cfg* /etc/tarantool/"
#~ "instances.enabled/"

#~ msgid "Starting all instances:"
#~ msgstr "Запуск всех экземпляров:"

#~ msgid "$ service tarantool start"
#~ msgstr "$ service tarantool start"

#~ msgid "$ service tarantool stop"
#~ msgstr "$ service tarantool stop"

#~ msgid "Fedora, RHEL, CentOS"
#~ msgstr "Fedora, RHEL, CentOS"

#~ msgid ""
#~ "There are no known permanent issues. For transient issues, go to http://"
#~ "github.com/tarantool/tarantool/issues and enter \"RHEL\" or \"CentOS\" or "
#~ "\"Fedora\" or \"Red Hat\" in the search box."
#~ msgstr ""
#~ "Известных воспроизводящихся дефектов для данных платформ нет. Если вы "
#~ "столкнулись с плавающим дефектом, посмотрите описания проблем на странице "
#~ "http://github.com/tarantool/tarantool/issues, введя в строке поиска слово "
#~ "\"RHEL\", \"CentOS\", \"Fedora\" или \"Red Hat\"."

#~ msgid ""
#~ "There are no known permanent issues. For transient issues, go to http://"
#~ "github.com/tarantool/tarantool/issues and enter \"FreeBSD\" in the search box."
#~ msgstr ""
#~ "Известных воспроизводящихся дефектов для данной платформы нет. Если вы "
#~ "столкнулись с плавающим дефектом, посмотрите описания проблем на странице "
#~ "http://github.com/tarantool/tarantool/issues, введя в строке поиска слово "
#~ "\"FreeBSD\"."

#~ msgid "Mac OS X"
#~ msgstr "Mac OS X"

#~ msgid ""
#~ "There are no known permanent issues. For transient issues, go to http://"
#~ "github.com/tarantool/tarantool/issues and enter \"OS X\" in the search box."
#~ msgstr ""
#~ "Известных воспроизводящихся дефектов для данных платформ нет. Если вы "
#~ "столкнулись с плавающим дефектом, посмотрите описания проблем на странице "
#~ "http://github.com/tarantool/tarantool/issues, введя в строке поиска слово "
#~ "\"OS X\"."

#~ msgid ""
#~ "Tarantool fully supports :program:`systemd` for managing instances and "
#~ "supervising database daemons."
#~ msgstr ""
#~ "Tarantool полностью поддерживает работу с :program:`systemd` как со средством "
#~ "для управления экземплярами и контроля за фоновыми программами базы данных."

#~ msgid ""
#~ "Tarantool was designed to have multiple running instances of Tarantool on the "
#~ "same machine. Use :samp:`systemctl {start|stop|restart|status} tarantool@"
#~ "${MYAPP}` to manage your databases and Lua applications."
#~ msgstr ""
#~ "В архитектуре Tarantool'а заложена возможность запуска сразу многих "
#~ "экземпляров Tarantool-сервера на одной машине. С помощью :samp:`systemctl "
#~ "{start|stop|restart|status} tarantool@${MYAPP}` можно управлять базами данных "
#~ "и Lua-приложениями."

#~ msgid ""
#~ "Simply put your Lua configuration to :file:`/etc/tarantool/instances."
#~ "available/${MYAPP}.lua`:"
#~ msgstr ""
#~ "Задайте все настройки в виде Lua-скрипта и поместите их в файл :file:`/etc/"
#~ "tarantool/instances.available/${MYAPP}.lua`:"

#~ msgid ""
#~ "box.cfg{listen = 3313}\n"
#~ "require('myappcode').start()"
#~ msgstr ""
#~ "box.cfg{listen = 3313}\n"
#~ "require('myappcode').start()"

#~ msgid "(this minimal example is sufficient)."
#~ msgstr "(это пример минимально достаточной конфигурации)."

#~ msgid ""
#~ "Another starting point could be the :file:`example.lua` script that ships "
#~ "with Tarantool and defines all options."
#~ msgstr ""
#~ "Также вы можете посмотреть пример Lua-скрипт в файле :file:`example.lua`, "
#~ "который входит в состав дистрибутива Tarantool'а и содержит значения всех "
#~ "опций."

#~ msgid ""
#~ "Use :samp:`systemctl start tarantool@${MYAPP}` to start ``${MYAPP}`` instance:"
#~ msgstr ""
#~ "Для запуска экземпляра ``${MYAPP}`` выполните команду :samp:`systemctl start "
#~ "tarantool@${MYAPP}`:"

#~ msgid "Monitoring instances"
#~ msgstr "Мониторинг экземпляров"

#~ msgid ""
#~ "Use :samp:`systemctl status tarantool@${MYAPP}` to check information about ``"
#~ "${MYAPP}`` instance:"
#~ msgstr ""
#~ "Для проверки информации об экземпляре ``${MYAPP}`` выполните команду :samp:"
#~ "`systemctl status tarantool@${MYAPP}`:"

#~ msgid "Use :samp:`journalctl -u tarantool@${MYAPP}` to check the boot log:"
#~ msgstr ""
#~ "Для проверки журнала загрузки выполните команду :samp:`journalctl -u "
#~ "tarantool@${MYAPP}`:"

#~ msgid ""
#~ "$ tarantoolctl enter example\n"
#~ "/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
#~ "/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
#~ "/bin/tarantoolctl: connected to unix/:/var/run/tarantool/example.control\n"
#~ "unix/:/var/run/tarantool/example.control> 1 + 1\n"
#~ "---\n"
#~ "- 2\n"
#~ "...\n"
#~ "unix/:/var/run/tarantool/example.control>"
#~ msgstr ""
#~ "$ tarantoolctl enter example\n"
#~ "/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
#~ "/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
#~ "/bin/tarantoolctl: connected to unix/:/var/run/tarantool/example.control\n"
#~ "unix/:/var/run/tarantool/example.control> 1 + 1\n"
#~ "---\n"
#~ "- 2\n"
#~ "...\n"
#~ "unix/:/var/run/tarantool/example.control>"

#~ msgid "Checking logs"
#~ msgstr "Проверка журнала"

#~ msgid ""
#~ "Tarantool logs important events to :file:`/var/log/tarantool/${MYAPP}.log`."
#~ msgstr ""
#~ "Tarantool ведет записи о важных событиях в файле :file:`/var/log/tarantool/"
#~ "${MYAPP}.log`."

#~ msgid ""
#~ "$ tarantoolctl enter example\n"
#~ "/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
#~ "/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
#~ "/bin/tarantoolctl: connected to unix/:/var/run/tarantool/example.control\n"
#~ "unix/:/var/run/tarantool/example.control> require('log').info(\"Hello for "
#~ "README.systemd readers\")\n"
#~ "---\n"
#~ "..."
#~ msgstr ""
#~ "$ tarantoolctl enter example\n"
#~ "/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
#~ "/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
#~ "/bin/tarantoolctl: connected to unix/:/var/run/tarantool/example.control\n"
#~ "unix/:/var/run/tarantool/example.control> require('log').info(\"Hello for "
#~ "README.systemd readers\")\n"
#~ "---\n"
#~ "..."

#~ msgid ""
#~ "$ tail /var/log/tarantool/example.log\n"
#~ "2016-01-21 21:09:45.982 [5914] iproto I> binary: started\n"
#~ "2016-01-21 21:09:45.982 [5914] iproto I> binary: bound to 0.0.0.0:3301\n"
#~ "2016-01-21 21:09:45.983 [5914] main/101/tarantoolctl I> ready to accept "
#~ "requests\n"
#~ "2016-01-21 21:09:45.983 [5914] main/101/example I> Run console at /var/run/"
#~ "tarantool/example.control\n"
#~ "2016-01-21 21:09:45.984 [5914] main/101/example I> tcp_server: remove dead "
#~ "UNIX socket: /var/run/tarantool/example.control\n"
#~ "2016-01-21 21:09:45.984 [5914] main/104/console/unix/:/var/run/tarant I> "
#~ "started\n"
#~ "2016-01-21 21:09:45.985 [5914] main C> entering the event loop\n"
#~ "2016-01-21 21:14:43.320 [5914] main/105/console/unix/: I> client unix/: "
#~ "connected\n"
#~ "2016-01-21 21:15:07.115 [5914] main/105/console/unix/: I> Hello for README."
#~ "systemd readers\n"
#~ "2016-01-21 21:15:09.250 [5914] main/105/console/unix/: I> client unix/: "
#~ "disconnected"
#~ msgstr ""
#~ "$ tail /var/log/tarantool/example.log\n"
#~ "2016-01-21 21:09:45.982 [5914] iproto I> binary: started\n"
#~ "2016-01-21 21:09:45.982 [5914] iproto I> binary: bound to 0.0.0.0:3301\n"
#~ "2016-01-21 21:09:45.983 [5914] main/101/tarantoolctl I> ready to accept "
#~ "requests\n"
#~ "2016-01-21 21:09:45.983 [5914] main/101/example I> Run console at /var/run/"
#~ "tarantool/example.control\n"
#~ "2016-01-21 21:09:45.984 [5914] main/101/example I> tcp_server: remove dead "
#~ "UNIX socket: /var/run/tarantool/example.control\n"
#~ "2016-01-21 21:09:45.984 [5914] main/104/console/unix/:/var/run/tarant I> "
#~ "started\n"
#~ "2016-01-21 21:09:45.985 [5914] main C> entering the event loop\n"
#~ "2016-01-21 21:14:43.320 [5914] main/105/console/unix/: I> client unix/: "
#~ "connected\n"
#~ "2016-01-21 21:15:07.115 [5914] main/105/console/unix/: I> Hello for README."
#~ "systemd readers\n"
#~ "2016-01-21 21:15:09.250 [5914] main/105/console/unix/: I> client unix/: "
#~ "disconnected"

#~ msgid ""
#~ "Log rotation is enabled by default if you have :program:`logrotate` "
#~ "installed. Please configure :file:`/etc/logrotate.d/tarantool` to change the "
#~ "default behavior."
#~ msgstr ""
#~ "Для ротации журнала нужно установить программу :program:`logrotate`. "
#~ "Настройки для ротации можно задать в файле :file:`/etc/logrotate.d/tarantool`."

#~ msgid "Stopping instances"
#~ msgstr "Остановка экземпляров"

#~ msgid ""
#~ "Use :samp:`systemctl stop tarantool@${MYAPP}` to see information about the "
#~ "running ``${MYAPP}`` instance."
#~ msgstr ""
#~ "Для просмотра информации о запущенном экземпляре ``${MYAPP}`` выполните "
#~ "команду :samp:`systemctl stop tarantool@${MYAPP}`."

#~ msgid ""
#~ "All instances are automatically restarted by :program:`systemd` in case of "
#~ "failure."
#~ msgstr ""
#~ "Если какой-либо экземпляр Tarantool-сервера выходит из строя, :program:"
#~ "`systemd` автоматически перезапускает его."

#~ msgid "Let's try to destroy an instance:"
#~ msgstr "Давайте попробуем вывести из строя один экземпляр:"

#~ msgid ""
#~ "$ systemctl status tarantool@example|grep PID\n"
#~ "Main PID: 5885 (tarantool)\n"
#~ "$ tarantoolctl enter example\n"
#~ "/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
#~ "/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
#~ "/bin/tarantoolctl: connected to unix/:/var/run/tarantool/example.control\n"
#~ "unix/:/var/run/tarantool/example.control> os.exit(-1)\n"
#~ "/bin/tarantoolctl: unix/:/var/run/tarantool/example.control: Remote host "
#~ "closed connection"
#~ msgstr ""
#~ "$ systemctl status tarantool@example|grep PID\n"
#~ "Main PID: 5885 (tarantool)\n"
#~ "$ tarantoolctl enter example\n"
#~ "/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
#~ "/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
#~ "/bin/tarantoolctl: connected to unix/:/var/run/tarantool/example.control\n"
#~ "unix/:/var/run/tarantool/example.control> os.exit(-1)\n"
#~ "/bin/tarantoolctl: unix/:/var/run/tarantool/example.control: Remote host "
#~ "closed connection"

#~ msgid "Customizing the service file"
#~ msgstr "Правка настроек сервисного файла"

#~ msgid ""
#~ "Please don't modify the :file:`tarantool@.service` file in-place, because it "
#~ "will be overwritten during package upgrades. It is recommended to copy this "
#~ "file to :file:`/etc/systemd/system` and then modify the required settings. "
#~ "Alternatively, you can create a directory named :file:`unit.d/` within :file:"
#~ "`/etc/systemd/system` and put there a drop-in file :file:`name.conf` that "
#~ "only changes the required settings. Please see ``systemd.unit(5)`` manual "
#~ "page for additional information."
#~ msgstr ""
#~ "Пожалуйста, не редактируйте файл :file:`tarantool@.service` по месту, "
#~ "поскольку все ваши изменения будут перезаписаны при последующих обновлениях "
#~ "Tarantool'а. Мы рекомендуем скопировать этот файл в :file:`/etc/systemd/"
#~ "system` и править настройки уже в копии. Либо вы можете создать поддиректорию "
#~ "с именем :file:`unit.d/` в директории :file:`/etc/systemd/system` и положить "
#~ "туда drop-in файл с именем :file:`name.conf`, в котором будут указаны только "
#~ "те настройки, которые нужно поменять. См. подробности в ``systemd.unit(5)``."

#~ msgid "Debugging"
#~ msgstr "Отладка"

#~ msgid ""
#~ "$ # !!! please never do this on the production system !!!\n"
#~ "$ tarantoolctl enter example\n"
#~ "/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
#~ "/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
#~ "/bin/tarantoolctl: connected to unix/:/var/run/tarantool/example.control\n"
#~ "unix/:/var/run/tarantool/example.control> require('ffi').cast('char *', 0)[0] "
#~ "= 48\n"
#~ "/bin/tarantoolctl: unix/:/var/run/tarantool/example.control: Remote host "
#~ "closed connection"
#~ msgstr ""
#~ "$ # !!! ВНИМАНИЕ: никогда не делайте этого\n"
#~ "  # в условиях промышленной эксплуатации !!!\n"
#~ "$ tarantoolctl enter example\n"
#~ "/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
#~ "/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
#~ "/bin/tarantoolctl: connected to unix/:/var/run/tarantool/example.control\n"
#~ "unix/:/var/run/tarantool/example.control> require('ffi').cast('char *', 0)[0] "
#~ "= 48\n"
#~ "/bin/tarantoolctl: unix/:/var/run/tarantool/example.control: Remote host "
#~ "closed connection"

#~ msgid ""
#~ ":samp:`coredumpctl list /usr/bin/tarantool` displays the latest crashes of "
#~ "the Tarantool daemon:"
#~ msgstr ""
#~ "Введем :samp:`coredumpctl list /usr/bin/tarantool`, чтобы получить отчет о "
#~ "последних аварийных завершениях Tarantool-демона:"

#~ msgid ":samp:`coredumpctl gdb <pid>` starts :program:`gdb` on the core dump."
#~ msgstr ""
#~ "Далее с помощью команды :samp:`coredumpctl gdb <pid>` запустим отладчик :"
#~ "program:`gdb` и подадим сохраненный дамп памяти ему на вход."

#~ msgid ""
#~ "For additional information, please refer to the documentation provided with "
#~ "your Linux distribution."
#~ msgstr "Дополнительно см. документацию по вашей Linux-системе."

#~ msgid "Precautions"
#~ msgstr "Особые указания"

#~ msgid ""
#~ "Please don't use ``tarantoolctl {start,stop,restart}`` to control instances "
#~ "started by :program:`systemd`. It is still possible to use :program:"
#~ "`tarantoolctl` to start and stop instances from your local directories (e.g. :"
#~ "file:`${HOME}`) without obtaining ``ROOT`` access."
#~ msgstr ""
#~ "Пожалуйста, не используйте ``tarantoolctl {start,stop,restart}`` для "
#~ "управления экземплярами, которые были запущены с помощью :program:`systemd`. "
#~ "Но вы можете использовать :program:`tarantoolctl` для запуска/остановки "
#~ "экземпляров в ваших локальных директориях (например, :file:`${HOME}`), что не "
#~ "требует пользовательских прав уровня ``ROOT``."

#~ msgid ""
#~ ":program:`tarantoolctl` is configured to work properly with :program:"
#~ "`systemd`. Please don't modify system-wide settings of :program:"
#~ "`tarantoolctl`, such as paths, directory permissions and usernames. "
#~ "Otherwise, you have a chance to shoot yourself in the foot."
#~ msgstr ""
#~ "Утилита :program:`tarantoolctl` уже настроена так, чтобы корректно работать "
#~ "с :program:`systemd`. Пожалуйста, не меняйте общесистемные настройки для :"
#~ "program:`tarantoolctl`, такие как пути, настройки прав для директорий и имена "
#~ "пользователей, т.к. это может привести к неожиданным проблемам."

#~ msgid ""
#~ ":program:`systemd` scripts are maintained by the Tarantool Team (http://"
#~ "tarantool.org). Please file tickets directly to the upstream's bug tracker "
#~ "(https://github.com/tarantool/tarantool/issues/) rather than to your Linux "
#~ "distribution."
#~ msgstr ""
#~ "Поддержкой скриптов для :program:`systemd` занимается команда разработки "
#~ "Tarantool'а (http://tarantool.org). Если у вас возникли проблемы при работе "
#~ "Tarantool'а с :program:`systemd`, то мы просим сообщать об этом нашей команде "
#~ "(https://github.com/tarantool/tarantool/issues/), а не разработчикам вашего "
#~ "Linux-дистрибутива."

#~ msgid "About modules/rocks"
#~ msgstr "Про модули/rocks"

#~ msgid ""
#~ "Modules that come from Tarantool developers and community contributors are "
#~ "available at `rocks.tarantool.org <http://rocks.tarantool.org>`_. Some of "
#~ "them -- :ref:`expirationd <expirationd-module>`, :ref:`mysql <dbms_modules-"
#~ "mysql-example>`, :ref:`postgresql <dbms_modules-postgresql-example>`, :ref:"
#~ "`shard <shard-module>` -- are discussed elsewhere in this manual."
#~ msgstr ""
#~ "Модули, созданные командой Tarantool'а и членами сообщества разработчиков, "
#~ "выложены на `rocks.tarantool.org <http://rocks.tarantool.org>`_. Про "
#~ "некоторые из этих модулей — :ref:`expirationd <expirationd-module>`, :ref:"
#~ "`mysql <dbms_modules-mysql-example>`, :ref:`postgresql <dbms_modules-"
#~ "postgresql-example>`, :ref:`shard <shard-module>` -- подробнее говорится в "
#~ "других разделах текущей документации."

#~ msgid ""
#~ "**Step 1:** Install LuaRocks. A general description of installing LuaRocks on "
#~ "a Unix system is given in the `LuaRocks Quick Start Guide <http://luarocks."
#~ "org/#quick-start>`_. For example, on Ubuntu you could say:"
#~ msgstr ""
#~ "**Шаг 1:** Установите LuaRocks. Общее описание того, как установить LuaRocks "
#~ "в Unix-системе, приводится в `кратком руководстве по LuaRocks <http://"
#~ "luarocks.org/#quick-start>`_. Например, установить LuaRocks в Ubuntu можно "
#~ "следующей командой:"

#~ msgid ""
#~ "**Step 2:** Add the Tarantool repository to the list of rocks servers. This "
#~ "is done by putting `rocks.tarantool.org <http://rocks.tarantool.org>`_ in "
#~ "the :file:`.luarocks/config.lua` file:"
#~ msgstr ""
#~ "**Шаг 2:** Добавьте репозиторий Tarantool'а в список rocks-серверов. Для "
#~ "этого добавьте `rocks.tarantool.org <http://rocks.tarantool.org>`_ в файл :"
#~ "file:`.luarocks/config.lua`:"

#~ msgid ""
#~ "$ mkdir ~/.luarocks\n"
#~ "$ echo \"rocks_servers = {[[http://rocks.tarantool.org/]]}\" >> ~/.luarocks/"
#~ "config.lua"
#~ msgstr ""
#~ "$ mkdir ~/.luarocks\n"
#~ "$ echo \"rocks_servers = {[[http://rocks.tarantool.org/]]}\" >> ~/.luarocks/"
#~ "config.lua"

#~ msgid "add new modules to the local repository with"
#~ msgstr "добавлять новые модули в свой локальный репозиторий"

#~ msgid ""
#~ "... and that is why examples in this manual often begin with ``require`` "
#~ "requests."
#~ msgstr ""
#~ "(вот почему многие примеры в этой документации начинаются с вызова "
#~ "``require``.)"

#~ msgid "Creating a new Lua module locally"
#~ msgstr "Создание нового модуля на языке Lua"

#~ msgid ""
#~ "As an example, let's create a new Lua file named :file:`mymodule.lua`, "
#~ "containing a named function which will be exported. Then, in Tarantool: load, "
#~ "examine, and call."
#~ msgstr ""
#~ "Для примера создадим новый Lua-файл с именем :file:`mymodule.lua`, в котором "
#~ "опишем экспортируемую функцию с некоторым именем, а затем с помощью "
#~ "Tarantool'а загрузим и просмотрим наш новый модуль и вызовем описанную в нем "
#~ "функцию."

#~ msgid "The Lua file should look like this:"
#~ msgstr "Lua-файл в нашем примере будет таким:"

#~ msgid "The requests to load, examine and call look like this:"
#~ msgstr ""
#~ "Для загрузки и просмотра модуля, а также вызова описанной в нем функции, "
#~ "выполним следующие команды:"

#~ msgid ""
#~ "tarantool> **mymodule = require('mymodule')**\n"
#~ "---\n"
#~ "...\n"
#~ "\n"
#~ "tarantool> **mymodule**\n"
#~ "---\n"
#~ "- myfun: 'function: 0x405edf20'\n"
#~ "...\n"
#~ "\n"
#~ "tarantool> **mymodule.myfun(os.getenv('USER'))**\n"
#~ "Hello world\n"
#~ "---\n"
#~ "..."
#~ msgstr ""
#~ "tarantool> **mymodule = require('mymodule')**\n"
#~ "---\n"
#~ "...\n"
#~ "\n"
#~ "tarantool> **mymodule**\n"
#~ "---\n"
#~ "- myfun: 'function: 0x405edf20'\n"
#~ "...\n"
#~ "\n"
#~ "tarantool> **mymodule.myfun(os.getenv('USER'))**\n"
#~ "Hello world\n"
#~ "---\n"
#~ "..."

#~ msgid "Creating a new C/C++ module locally"
#~ msgstr "Создание нового модуля на языке C/C++"

#~ msgid ""
#~ "As an example, let's create a new C file named :file:`mycmodule.c`, "
#~ "containing a named function which will be exported. Then, in Tarantool: load, "
#~ "examine, and call."
#~ msgstr ""
#~ "Для примера создадим новый C-файл с именем :file:`mymodule.c`, в котором "
#~ "опишем экспортируемую функцию с некоторым именем, а затем с помощью "
#~ "Tarantool'а загрузим и просмотрим наш новый модуль и вызовем описанную в нем "
#~ "функцию."

#~ msgid ""
#~ "/* mycmodule - a simple Tarantool module */\n"
#~ "#include <lua.h>\n"
#~ "#include <lauxlib.h>\n"
#~ "#include <lualib.h>\n"
#~ "#include <tarantool.h>\n"
#~ "static int\n"
#~ "myfun(lua_State *L)\n"
#~ "{\n"
#~ "    if (lua_gettop(L) < 1)\n"
#~ "        return luaL_error(L, \"Usage: myfun(name)\");\n"
#~ "\n"
#~ "    /* Get first argument */\n"
#~ "    const char *name = lua_tostring(L, 1);\n"
#~ "\n"
#~ "    /* Push one result to Lua stack */\n"
#~ "    lua_pushfstring(L, \"Hello, %s\", name);\n"
#~ "    return 1; /* the function returns one result */\n"
#~ "}\n"
#~ "\n"
#~ "LUA_API int\n"
#~ "luaopen_mycmodule(lua_State *L)\n"
#~ "{\n"
#~ "    static const struct luaL_reg reg[] = {\n"
#~ "        { \"myfun\", myfun },\n"
#~ "        { NULL, NULL }\n"
#~ "    };\n"
#~ "    luaL_register(L, \"mycmodule\", reg);\n"
#~ "    return 1;\n"
#~ "}"
#~ msgstr ""
#~ "/* mycmodule - простейший C-модуль для Tarantool'а */\n"
#~ "#include <lua.h>\n"
#~ "#include <lauxlib.h>\n"
#~ "#include <lualib.h>\n"
#~ "#include <tarantool.h>\n"
#~ "static int\n"
#~ "myfun(lua_State *L)\n"
#~ "{\n"
#~ "    if (lua_gettop(L) < 1)\n"
#~ "        return luaL_error(L, \"Usage: myfun(name)\");\n"
#~ "\n"
#~ "    /* Get first argument */\n"
#~ "    const char *name = lua_tostring(L, 1);\n"
#~ "\n"
#~ "    /* Push one result to Lua stack */\n"
#~ "    lua_pushfstring(L, \"Hello, %s\", name);\n"
#~ "    return 1; /* the function returns one result */\n"
#~ "}\n"
#~ "\n"
#~ "LUA_API int\n"
#~ "luaopen_mycmodule(lua_State *L)\n"
#~ "{\n"
#~ "    static const struct luaL_reg reg[] = {\n"
#~ "        { \"myfun\", myfun },\n"
#~ "        { NULL, NULL }\n"
#~ "    };\n"
#~ "    luaL_register(L, \"mycmodule\", reg);\n"
#~ "    return 1;\n"
#~ "}"

#~ msgid ""
#~ "Use :program:`gcc` to compile the code for a shared library (without a \"lib"
#~ "\" prefix), then use :program:`ls` to examine it:"
#~ msgstr ""
#~ "С помощью :program:`gcc` скомпилируем наш код в виде shared-библиотеки (без "
#~ "префикса \"lib\"), а затем просмотрим ее содержимое с помощью :program:`ls`:"

#~ msgid ""
#~ "$ **gcc mycmodule.c -shared -fPIC -I/usr/include/tarantool -o mycmodule.so**\n"
#~ "$ **ls mycmodule.so -l**\n"
#~ "-rwxr-xr-x 1 roman roman 7272 Jun  3 16:51 mycmodule.so"
#~ msgstr ""
#~ "$ **gcc mycmodule.c -shared -fPIC -I/usr/include/tarantool -o mycmodule.so**\n"
#~ "$ **ls mycmodule.so -l**\n"
#~ "-rwxr-xr-x 1 roman roman 7272 Jun  3 16:51 mycmodule.so"

#~ msgid ""
#~ "Tarantool's developers recommend using Tarantool's `CMake scripts <https://"
#~ "github.com/tarantool/modulekit>`_ which will handle some of the build steps "
#~ "automatically."
#~ msgstr ""
#~ "Для автоматизации сборки рекомендуется использовать `CMake-скрипты для "
#~ "Tarantool'а <https://github.com/tarantool/modulekit>`_."

#~ msgid ""
#~ "tarantool> **myсmodule = require('myсmodule')**\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> **myсmodule**\n"
#~ "---\n"
#~ "- myfun: 'function: 0x4100ec98'\n"
#~ "...\n"
#~ "tarantool> **mycmodule.myfun(os.getenv('USER'))**\n"
#~ "---\n"
#~ "- Hello, world\n"
#~ "..."
#~ msgstr ""
#~ "tarantool> **myсmodule = require('myсmodule')**\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> **myсmodule**\n"
#~ "---\n"
#~ "- myfun: 'function: 0x4100ec98'\n"
#~ "...\n"
#~ "tarantool> **mycmodule.myfun(os.getenv('USER'))**\n"
#~ "---\n"
#~ "- Hello, world\n"
#~ "..."

#~ msgid "Creating a mixed Lua/C module locally"
#~ msgstr "Создание нового модуля на смеси языков Lua/C"

#~ msgid "Create a Lua module and name it as you like, say ``myfunmodule``."
#~ msgstr "Создайте новый Lua-модуль и назовите его, например, ``myfunmodule``."

#~ msgid ""
#~ "Create a C module (submodule) and name it ``myfunmodule.internal`` or "
#~ "something like that."
#~ msgstr ""
#~ "Создайте (вложенный) модуль на C и назовите его, например, ``myfunmodule."
#~ "internal``."

#~ msgid ""
#~ "Load the C module from your Lua code using :samp:`require('myfunmodule."
#~ "internal')` and then wrap or use it."
#~ msgstr ""
#~ "Загрузите новый C-модуль из Lua-кода с помощью :samp:`require('myfunmodule."
#~ "internal')`, а затем сделайте для него обертку или вызывайте его функции "
#~ "напрямую."

#~ msgid ""
#~ "For a sample of a mixed Lua/C module, see `\"tarantool/http\" repository at "
#~ "GitHub <https://github.com/tarantool/http>`_."
#~ msgstr ""
#~ "Примеры модулей на смеси языков Lua/C можно посмотреть в `репозитории "
#~ "\"tarantool/http\" на GitHub <https://github.com/tarantool/http>`_."

#~ msgid "Tips for special situations"
#~ msgstr "Примечания для особых случаев"

#~ msgid ""
#~ "Lua caches all loaded modules in the ``package.loaded`` table. To reload a "
#~ "module from disk, set its key to `nil`:"
#~ msgstr ""
#~ "В среде Lua все загруженные модули кешируются в таблице ``package.loaded``. "
#~ "Чтобы перегрузить какой-либо модуль с диска, укажите для его ключа значение "
#~ "`nil`:"

#~ msgid ""
#~ "Use ``package.path`` to search for :file:`.lua` modules, and use ``package."
#~ "cpath`` to search for C binary modules."
#~ msgstr ""
#~ "Для поиска :file:`.lua`-модулей используйте команду ``package.path``, а для "
#~ "поиска бинарных модулей на C используйте команду ``package.cpath``."

#~ msgid ""
#~ "To see the internal state from within a Lua module, use :samp:`state` and "
#~ "create a local variable inside the scope of the file:"
#~ msgstr ""
#~ "Для просмотра внутреннего состояния прямо изнутри Lua-модуля используйте :"
#~ "samp:`state` и соответствующую локальную переменную в рамках модуля:"

#~ msgid ""
#~ "-- mymodule\n"
#~ "local exports = {}\n"
#~ "local state = {}\n"
#~ "exports.myfun = function()\n"
#~ "    state.x = 42 -- use state\n"
#~ "end\n"
#~ "return exports"
#~ msgstr ""
#~ "-- mymodule\n"
#~ "local exports = {}\n"
#~ "local state = {}\n"
#~ "exports.myfun = function()\n"
#~ "    state.x = 42 -- используем state\n"
#~ "end\n"
#~ "return exports"

#~ msgid ""
#~ "If you tried out the :ref:`Starting Tarantool and making your first database "
#~ "<user_guide_getting_started-first_database>` exercise from the last chapter, "
#~ "then your database looks like this:"
#~ msgstr ""
#~ "Если вы уже выполнили тестовое задание из раздела :ref:`Первичный запуск "
#~ "Tarantool'а и создание базы данных <user_guide_getting_started-"
#~ "first_database>` в предыдущей главе, то ваша база данных имеет следующий вид:"

#~ msgid ""
#~ "When Tarantool is being used to store data, there is always at least one "
#~ "space. There can be many spaces. Each space has a unique name specified by "
#~ "the user. Each space has a unique numeric identifier which can be specified "
#~ "by the user but usually is assigned automatically by Tarantool. Spaces always "
#~ "contain one tuple set and one or more indexes."
#~ msgstr ""
#~ "Когда Tarantool используется для хранения данных, то он создает по меньшей "
#~ "мере одно пространство (space). В общем же случае пространств может быть "
#~ "много. Каждое пространство имеет уникальное имя, заданное пользователем, а "
#~ "также уникальный числовой идентификатор, который тоже может быть задан "
#~ "пользователем, но обычно назначается автоматически самим Tarantool'ом. "
#~ "Пространство всегда содержит один набор кортежей и один или более индексов."

#~ msgid "Tuple set"
#~ msgstr "Набор кортежей"

#~ msgid "A *tuple set* -- 'tester' in the example -- is a group of tuples."
#~ msgstr ""
#~ "*Набор кортежей* — в нашем примере он назван 'tester' — это группа кортежей."

#~ msgid ""
#~ "There is always one tuple set in a space. The identifier of a tuple set is "
#~ "the same as the space name -- 'tester' in the example."
#~ msgstr ""
#~ "Каждое пространство всегда содержит один набор кортежей. Идентификатор набора "
#~ "кортежей совпадает с именем самого пространства, в нашем примере — `tester`."

#~ msgid ""
#~ "A tuple fills the same role as a “row” or a “record”, and the components of a "
#~ "tuple (which we call “fields”) fill the same role as a “row column” or "
#~ "“record field”, except that: the fields of a tuple can be composite "
#~ "structures, such as arrays or maps and don't need to have names. That's why "
#~ "there was no need to pre-define the tuple set when creating the space, and "
#~ "that's why each tuple can have a different number of elements. Tuples are "
#~ "stored as `MsgPack`_ arrays."
#~ msgstr ""
#~ "Кортеж (tuple) выполняет ту же роль, что \"строка\" или \"запись\", а "
#~ "компоненты кортежа (его \"полЯ\") выполняют ту же роль, что \"поле столбца, "
#~ "соответствующее данной строке\" или \"поле в записи\" за тем исключением, что "
#~ "поля кортежа могут быть составными (например, они могут быть массивами или "
#~ "отображениями) и им не нужны имена. Поэтому нет необходимости предварительно "
#~ "определять набор кортежей при создании пространства, а каждый кортеж может "
#~ "иметь различное количество элементов. Кортежи хранятся в виде `MsgPack`_-"
#~ "массивов."

#~ msgid ""
#~ "When Tarantool returns a tuple value, it surrounds strings with single "
#~ "quotes, separates fields with commas, and encloses the tuple inside square "
#~ "brackets. For example: ``[3, 'length', 93]``."
#~ msgstr ""
#~ "Когда Tarantool возвращает значение кортежа, он берет строки в одинарные "
#~ "кавычки, отделяет поля с запятыми и заключает кортеж в квадратные скобки. "
#~ "Например, ``[ 3, 'length', 93 ]``."

#~ msgid ""
#~ "In order for a tuple set to be useful, there must always be at least one "
#~ "index in a space. There can be many indexes. As with spaces, the user can and "
#~ "should specify the index name, and let Tarantool come up with a unique "
#~ "numeric identifier (the \"index id\"). In our example there is one index and "
#~ "its name is “primary”."
#~ msgstr ""
#~ "Чтобы набором кортежей было можно пользоваться, в пространстве необходим по "
#~ "крайней мере один индекс. Вообще же индексов в пространстве может быть много. "
#~ "Как и в случае с пространствами, пользователь может — и должен — указать имя "
#~ "индекса, а Tarantool подставляет уникальный числовой идентификатор "
#~ "(\"идентификатор индекса\"). В нашем примере всего один индекс с именем "
#~ "“primary”."

#~ msgid ""
#~ "An index may be *multi-part*, that is, the user can declare that an index key "
#~ "value is taken from two or more fields in the tuple, in any order. An index "
#~ "may be *unique*, that is, the user can declare that it would be illegal to "
#~ "have the same key value twice. An index may have *one of four types*: HASH "
#~ "which is fast and is best for exact-equality searches with unique keys, TREE "
#~ "which allows partial-key searching and ordered results, BITSET which can be "
#~ "good for searches that contain '=' and multiple ANDed conditions, and RTREE "
#~ "for spatial coordinates. The first index is called the “*primary key*” index "
#~ "and it must be unique; all other indexes are called “secondary” indexes."
#~ msgstr ""
#~ "#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "Индекс может быть *составным*. Значение ключа в таком индексе составляется из "
#~ "значений двух или более полей кортежа, причем они могут браться в любом "
#~ "порядке. Индекс может быть *уникальным*. В этом случае один и тот же ключ не "
#~ "может встречаться в индексе более одного раза. Также индекс может быть одного "
#~ "из следующих *четырех типов*: HASH (он самый быстрый и самый экономный в "
#~ "плане использования памяти, но он должен быть уникальным), TREE (он позволяет "
#~ "делать поиск по части ключа и получать отсортированные результаты), BITSET "
#~ "(он хорош для поиска с '=' и больших количеством AND-условий) или RTREE (для "
#~ "пространственных координат). Первый индекс называется “*первичным*” (primary) "
#~ "и должен быть уникальным. Все остальные индексы называются "
#~ "“вторичными” (secondary)."

#~ msgid "``number`` (unsigned integer or signed integer or floating-point value)"
#~ msgstr ""
#~ "``number`` (беззнаковое целое число, либо знаковое целое число, либо число с "
#~ "плавающей точкой)"

#~ msgid "``scalar`` (boolean or number or string)"
#~ msgstr "``scalar`` (логическое значение, либо число, либо строковое значение)"

#~ msgid "Take our example, which has the request:"
#~ msgstr "В рамках нашего примера рассмотрим следующий запрос:"

#~ msgid ""
#~ "The effect is that, for all tuples in tester, field number 1 must exist and "
#~ "must contain an unsigned integer."
#~ msgstr ""
#~ "В результате у всех кортежей в пространстве `tester` должно быть поле с "
#~ "номером 1, содержащее беззнаковое целое число."

#~ msgid ""
#~ "Space definitions and index definitions are stored permanently in system "
#~ "spaces. It is possible to add, drop, or alter the definitions at runtime, "
#~ "with some restrictions. See syntax details for defining spaces and indexes "
#~ "in :ref:`reference on Tarantool's \"box\" module <index-box_library>`."
#~ msgstr ""
#~ "#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "Определения пространств и индексов хранятся в системных пространствах. Можно "
#~ "(с некоторыми ограничениями) на ходу добавлять, удалять и менять эти "
#~ "определения. Правила синтаксиса в определениях пространств и индексов даны в "
#~ "разделе :ref:`Библиотека \"box\" <index-box_library>`."

#~ msgid ""
#~ "Tarantool can work with numbers, strings, booleans, tables, and userdata."
#~ msgstr ""
#~ "Tarantool работает с числами (numbers), строками (strings), логическими "
#~ "значениями (booleans), таблицами (tables) и пользовательскими типами данных "
#~ "(userdata)."

#~ msgid "Specific type"
#~ msgstr "Особый тип"

#~ msgid "What Lua ``type()`` would return"
#~ msgstr "Результат Lua type()"

#~ msgid "\"`table`_\""
#~ msgstr "\"`table`_\""

#~ msgid "table: 0x410f8b10"
#~ msgstr "table: 0x410f8b10"

#~ msgid "\"`Userdata`_\""
#~ msgstr "\"`Userdata`_\""

#~ msgid ""
#~ "For database storage, Tarantool uses MsgPack rules. Storage is variable-"
#~ "length, so the smallest number requires only one byte but the largest number "
#~ "requires nine bytes. When a field has an 'unsigned' index, all values must be "
#~ "unsigned integers between 0 and 18,446,744,073,709,551,615."
#~ msgstr ""
#~ "#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "Для хранения данных в базе Tarantool использует формат MsgPack. Данные при "
#~ "хранении имеют переменную длину, поэтому для самого маленького числа "
#~ "потребуется только один байт, а самое большее число потребует девять байтов. "
#~ "Если поле имеет индекс 'unsigned', то оно может содержать только целые "
#~ "беззнаковые числа со значениями в диапазоне от 0 до "
#~ "18,446,744,073,709,551,615."

#~ msgid ""
#~ "A *string* is a variable-length sequence of bytes, usually represented with "
#~ "alphanumeric characters inside single quotes."
#~ msgstr ""
#~ "Тип *string* (строка) — это последовательность байтов, имеющая переменную "
#~ "длину. Как правило, строки представлены в виде алфавитно-числовых символы, "
#~ "заключенных в одинарные кавычки."

#~ msgid ""
#~ "A *tuple* is returned in YAML format like ``- [120, 'a', 'b', 'c']``. A few "
#~ "functions may return tables with multiple tuples. A scalar may be converted "
#~ "to a tuple with only one field. A Lua table may contain all of a tuple's "
#~ "fields, but not nil."
#~ msgstr ""
#~ "Тип *tuple* возвращается в формате YAML, например ``- [120, 'a', 'b', 'c']``. "
#~ "Некоторые функции могут возвращать таблицы с несколькими кортежами. Скалярная "
#~ "величина может быть конвертирована в кортеж с 1 полем. Lua-таблица может "
#~ "содержать все типы полей, допустимые для кортежей, кроме нулевого типа (nil)."

#~ msgid ""
#~ "Some of the data types may be used in :ref:`indexed fields "
#~ "<details_about_index_field_types>`."
#~ msgstr ""
#~ "Некоторые из этих типов данных подходят для :ref:`индексируемых полей "
#~ "<details_about_index_field_types>`."

#~ msgid "For more tuple examples see :ref:`box.tuple <box_tuple>`."
#~ msgstr ""
#~ "См. также примеры кортежей в разделе про модуль :ref:`box.tuple <box_tuple>`."

#~ msgid ""
#~ "The basic operations are: the five data-change operations (``insert``, "
#~ "``update``, ``upsert``, ``delete``, ``replace``), and the data-retrieval "
#~ "operation (``select``). There are also minor operations like “ping” which can "
#~ "only be used with the binary protocol. Also, there are :ref:`index iterator "
#~ "<box_index-index_pairs>` operations, which can only be used with Lua code. "
#~ "(Index iterators are for traversing indexes one key at a time, taking "
#~ "advantage of features that are specific to an index type, for example "
#~ "evaluating Boolean expressions when traversing BITSET indexes, or going in "
#~ "descending order when traversing TREE indexes.)"
#~ msgstr ""
#~ "Основные операции — это пять операций для изменения данных (INSERT, UPDATE, "
#~ "UPSERT, DELETE, REPLACE) и одна операция для возвращения данных (SELECT). "
#~ "Также в Tarantool'е поддерживаются второстепенные операции типа PING, которые "
#~ "можно использовать только в рамках бинарного протокола. Кроме того, в "
#~ "Tarantool'е есть операции для :ref:`индекс-итераторов <box_index-"
#~ "index_pairs>`, которые можно использовать только в коде на языке Lua. (Индекс-"
#~ "итераторы нужны для обхода индексов от одного ключа к другому и дают "
#~ "возможность пользоваться преимуществами разных типов индексов, например "
#~ "вычислять значение выражений логического типа при обходе BITSET-индексов или "
#~ "двигаться в порядке убывания значений при обходе TREE-индексов.)"

#~ msgid "Six examples of basic operations:"
#~ msgstr "Шесть примеров основных операций:"

#~ msgid ""
#~ "-- Add a new tuple to tuple set tester.\n"
#~ "-- The first field, field[1], will be 999 (type is unsigned).\n"
#~ "-- The second field, field[2], will be 'Taranto' (type is string).\n"
#~ "tarantool> box.space.tester:insert{999, 'Taranto'}\n"
#~ "\n"
#~ "-- Update the tuple, changing field field[2].\n"
#~ "-- The clause \"{999}\", which has the value to look up in\n"
#~ "-- the index of the tuple's primary-key field, is mandatory\n"
#~ "-- because update() requests must always have a clause that\n"
#~ "-- specifies the primary key, which in this case is field[1].\n"
#~ "-- The clause \"{{'=', 2, 'Tarantino'}}\" specifies that assignment\n"
#~ "-- will happen to field[2] with the new value.\n"
#~ "tarantool> box.space.tester:update({999}, {{'=', 2, 'Tarantino'}})\n"
#~ "\n"
#~ "-- Upsert the tuple, changing field field[2] again.\n"
#~ "-- The syntax of upsert is similar to the syntax of update,\n"
#~ "-- but the return value will be different.\n"
#~ "tarantool> box.space.tester:upsert({999}, {{'=', 2, 'Tarantism'}})\n"
#~ "\n"
#~ "-- Replace the tuple, adding a new field.\n"
#~ "-- This is also possible with the update() request but\n"
#~ "-- the update() request is usually more complicated.\n"
#~ "tarantool> box.space.tester:replace{999, 'Tarantella', 'Tarantula'}\n"
#~ "\n"
#~ "-- Retrieve the tuple.\n"
#~ "-- The clause \"{999}\" is still mandatory, although it does not have to\n"
#~ "-- mention the primary key.\n"
#~ "tarantool> box.space.tester:select{999}\n"
#~ "\n"
#~ "-- Delete the tuple.\n"
#~ "-- Once again the clause to identify the primary-key field is mandatory.\n"
#~ "tarantool> box.space.tester:delete{999}"
#~ msgstr ""
#~ "-- Добавляем новый кортеж в набор кортежей с именем tester.\n"
#~ "-- Первое поле, field[1], будет равно 999 (тип = unsigned).\n"
#~ "-- Второе поле, field[2], будет равно 'Taranto' (тип = string).\n"
#~ "tarantool> box.space.tester:insert{999, 'Taranto'}\n"
#~ "\n"
#~ "-- Обновляем кортеж, меняем значение поля field[2].\n"
#~ "-- Условие \"{999}\", содержащее значение ключа, которое нужно\n"
#~ "-- искать в первичном индексе, построенном по первому полю\n"
#~ "-- кортежа, является обязательным, поскольку запросам update()\n"
#~ "-- всегда требуется условие, определяющее значение первичного\n"
#~ "-- ключа, в данном случае field[1].\n"
#~ "-- Условие \"{{'=', 2, 'Tarantino'}}\" определяет, что полю field[2] нужно \n"
#~ "-- присвоить новое значение.\n"
#~ "tarantool> box.space.tester:update({999}, {{'=', 2, 'Tarantino'}})\n"
#~ "\n"
#~ "-- Выполняем операцию upsert() для кортежа и снова меняем\n"
#~ "-- значение поля field[2].\n"
#~ "-- Синтаксис запроса upsert() аналогичен синтаксису update(),\n"
#~ "-- но возвращаемые значения у этих запросов разные.\n"
#~ "tarantool> box.space.tester:upsert({999}, {{'=', 2, 'Tarantism'}})\n"
#~ "\n"
#~ "-- Производим замену кортежа с помощью replace(), добавляем новое поле.\n"
#~ "-- Это можно сделать и с помощью запроса update(),\n"
#~ "-- но такой вариант часто оказывается более сложным.\n"
#~ "tarantool> box.space.tester:replace{999, 'Tarantella', 'Tarantula'}\n"
#~ "\n"
#~ "-- Возвращаем значение кортежа.\n"
#~ "-- Условие \"{999}\" все еще обязательно, хотя оно и не должно\n"
#~ "-- содержать значение первичного ключа.\n"
#~ "tarantool> box.space.tester:select{999}\n"
#~ "\n"
#~ "-- Удаляем кортеж.\n"
#~ "-- Условие, определяющее значение первичного ключа,\n"
#~ "-- снова является обязательным.\n"
#~ "tarantool> box.space.tester:delete{999}"

#~ msgid ""
#~ "If this is happening on a remote client, then the client parses the statement "
#~ "and changes it to a binary-protocol instruction which has already been "
#~ "checked, and which the server can understand without needing to parse "
#~ "everything again. The client ships a packet to the server."
#~ msgstr ""
#~ "Если запрос делается с удаленного клиента, то клиент разбирает введенное "
#~ "выражение, проверяет на корректность и переводит его в формат инструкций "
#~ "бинарного протокола, которые Tarantool-сервер сможет понять без повторного "
#~ "разбора. Затем клиент отправляет всё в виде пакета на сторону сервера."

#~ msgid ""
#~ "The transaction processor thread sends a message to the write-ahead logging "
#~ "(WAL) thread."
#~ msgstr ""
#~ "Поток обработки транзакций посылает сообщение другому потоку, который "
#~ "занимается записью в WAL."

#~ msgid ""
#~ "At this point, a *yield* takes place. To know the significance of that -- and "
#~ "it's quite significant -- you have to know a few facts and a few new words."
#~ msgstr ""
#~ "В этот момент происходит *передача управления* (yield). Чтобы понять важность "
#~ "этого события — а оно действительно важно, — нужно пояснить несколько фактов "
#~ "и ввести ряд новых терминов."

#~ msgid "FACT 1:"
#~ msgstr "ФАКТ #1:"

#~ msgid "FACT 2:"
#~ msgstr "ФАКТ #2:"

#~ msgid "FACT 3:"
#~ msgstr "ФАКТ #3:"

#~ msgid ""
#~ "Yields must happen, otherwise the transaction processor thread would stick "
#~ "permanently on the same fiber. There are :ref:`implicit yields <atomic-"
#~ "the_implicit_yield_rules>`: every data-change operation or network-access "
#~ "causes an implicit yield, and every statement that goes through the tarantool "
#~ "client causes an implicit yield. And there are explicit yields: in a Lua "
#~ "function one can and should add “yield” statements to prevent hogging. This "
#~ "is called *cooperative multitasking*."
#~ msgstr ""
#~ "#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "Без передачи управления не обойтись, т.к. иначе поток обработки транзакций "
#~ "сможет выполнять инструкции только для одного файбера. Передача управления "
#~ "может осуществляться один их двух способов. Первый — это :ref:`неявная "
#~ "передача <atomic-the_implicit_yield_rules>`. Она делается при каждой "
#~ "операции, связанной с изменением данных, при каждом обращении к сетевому "
#~ "соединению, а также при каждом запросе, который передается через Tarantool-"
#~ "клиент. Второй способ передачи управления — это явная передача. Ее можно — и "
#~ "нужно — вызывать внутри Lua-функций с помощью инструкции “yield”, чтобы не "
#~ "допустить захвата процессора одним файбером. Это называется *взаимная "
#~ "многозадачность*."

#~ msgid ""
#~ "Since all data-change operations end with an implicit yield and an implicit "
#~ "commit, and since no data-change operation can change more than one tuple, "
#~ "there is no need for any locking. Consider, for example, a Lua function that "
#~ "does three Tarantool operations:"
#~ msgstr ""
#~ "Поскольку все операции, связанные с изменением данных, заканчиваются неявной "
#~ "передачей управления и неявным коммитом, и поскольку каждая такая операция "
#~ "может затрагивать не более одного кортежа, то не возникает нужды в "
#~ "блокировках. Для примера рассмотрим следующую Lua-функцию, которая "
#~ "осуществляет три операции в Tarantool'е:"

#~ msgid ""
#~ "s:select{999}             -- this does not yield and does not commit\n"
#~ "s:update({...},{{...}})   -- this yields and commits\n"
#~ "s:select{999}             -- this does not yield and does not commit"
#~ msgstr ""
#~ "s:select{999}             -- не происходит ни передачи управления, ни "
#~ "коммита\n"
#~ "s:update({...},{{...}})   -- происходит и передача управления, и коммит\n"
#~ "s:select{999}             -- не происходит ни передачи управления, ни коммита"

#~ msgid ""
#~ "The combination “SELECT plus UPDATE” is an atomic transaction: the function "
#~ "holds a consistent view of the database until the UPDATE ends. For the "
#~ "combination “UPDATE plus SELECT” the view is not consistent, because after "
#~ "the UPDATE the transaction processor thread can switch to another fiber, and "
#~ "delete the tuple that was just updated."
#~ msgstr ""
#~ "Последовательность операций “SELECT + UPDATE” является атомарной транзакцией: "
#~ "функция сохраняет базу данных в согласованном виде, пока не отработает "
#~ "UPDATE. А в случае “UPDATE + SELECT” согласованности нет, поскольку после "
#~ "операции UPDATE поток обработки транзакций может переключится на другой "
#~ "файбер и удалить тот кортеж, что был обновлен в рамках предыдущей операции "
#~ "UPDATE."

#~ msgid ""
#~ "Note re storage engine: vinyl handles yields differently, see :ref:"
#~ "`differences between memtx and vinyl <vinyl_diff>`."
#~ msgstr ""
#~ "Примечание про движок: в движке vinyl передача управления происходит по-"
#~ "другому, см. раздел про :ref:`различия между движками memtx и vinyl "
#~ "<vinyl_diff>`."

#~ msgid "Note re multi-request transactions"
#~ msgstr "Примечание про составные транзакции:"

#~ msgid ""
#~ "Since locks don't exist, and disk writes only involve the write-ahead log, "
#~ "transactions are usually fast. Also the Tarantool server may not be using up "
#~ "all the threads of a powerful multi-core processor, so advanced users may be "
#~ "able to start a second Tarantool server on the same processor without ill "
#~ "effects."
#~ msgstr ""
#~ "Посколько блокировки не используются, а запись на диск производится только "
#~ "при работе с WAL-файлом, то транзакции в Tarantool'е обычно совершаются "
#~ "быстро. Кроме того, если мы имеем дело с мощным многоядерным процессором, то "
#~ "Tarantool-сервер может задействовать для работы не все потоки такого "
#~ "процессора, и продвинутые пользователи могут безболезненно запускать второй "
#~ "Tarantool-сервер на том же процессоре."

#~ msgid ""
#~ "Additional examples of requests can be found in the Tarantool regression test "
#~ "suite (https://github.com/tarantool/tarantool/tree/1.7/test/box). A complete "
#~ "grammar of supported data-manipulation functions will come later in this "
#~ "chapter."
#~ msgstr ""
#~ "См. также примеры с запросами в регрессионных тестах для Tarantool'а (https://"
#~ "github.com/tarantool/tarantool/tree/1.7/test/box). Полное описание грамматики "
#~ "поддерживаемых в Tarantool'е функций для манипулирования данными см. далее в "
#~ "этой главе."

#~ msgid ""
#~ "Since not all Tarantool operations can be expressed with the data-"
#~ "manipulation functions, or with Lua, to gain complete access to data "
#~ "manipulation functionality one must use a :ref:`Perl, PHP, Python or other "
#~ "programming language connector <index-box_connectors>`. The client/server "
#~ "protocol is open and documented. See this :ref:`annotated BNF <box_protocol-"
#~ "iproto_protocol>`."
#~ msgstr ""
#~ "Не все операции в Tarantool'е можно выразить с помощью функций по "
#~ "манипулированию данными или с помощью языка Lua. Чтобы получить доступ ко "
#~ "всем возможностями манипулирования данными, вам понадобится :ref:`коннектор "
#~ "для Perl, PHP, Python или другого языка программирования <index-"
#~ "box_connectors>`. Бинарный клиент-серверный протокол для коннекторов является "
#~ "открытым. Документация по нему доступна в виде аннотированных :ref:`BNF-"
#~ "диаграмм <box_protocol-iproto_protocol>`."

#~ msgid ""
#~ "Tarantool maintains a set of write-ahead log (WAL) files. There is a separate "
#~ "thread -- the WAL writer -- which catches all requests that can change a "
#~ "database, such as ``box.schema.create`` or ``box.space.insert``. Ordinarily "
#~ "the WAL writer writes the request, along with administrative fields and "
#~ "flags, to a WAL file immediately. This ensures data persistence, because, "
#~ "even if an in-memory database is lost when the power goes off, Tarantool "
#~ "recovers it automatically when it starts up again, by reading the WAL files "
#~ "and redoing the requests (this is called the \"recovery process\"). Users can "
#~ "change the timing of the WAL writer, or turn it off, by setting :ref:"
#~ "`wal_mode <cfg_binary_logging_snapshots-wal_mode>`."
#~ msgstr ""
#~ "Tarantool сохраняет данные и информацию об изменениях в нескольких WAL-файлах "
#~ "(write-ahead log). Записью в WAL занимается отдельный поток. Он ловит все "
#~ "запросы, которые могут привести к изменению данных в базе, например ``box."
#~ "schema.create`` или ``box.space.insert``. Как правило, запись о запросе, "
#~ "включая служебные поля и флаги, делается в WAL-файл немедленно. Это "
#~ "обеспечивает сохранность данных, поскольку, даже если данные из памяти "
#~ "утеряны вследствие перебоя в электроснабжении, Tarantool восстановит их "
#~ "автоматически при следующем старте: он загрузит данные из WAL-файлов, а затем "
#~ "применит все записанные в WAL-файлах запросы (это называется \"процесс "
#~ "восстановления\"). Пользователи могут менять частоту записи или вовсе "
#~ "отключать запись в WAL с помощью параметра :ref:`wal_mode "
#~ "<cfg_binary_logging_snapshots-wal_mode>`."

#~ msgid ""
#~ "Tarantool also maintains a set of snapshot files. A snapshot file is an on-"
#~ "disk copy of the entire data set for a given moment. Instead of reading every "
#~ "WAL file since the databases were created, the recovery process can load the "
#~ "latest snapshot and then read only the WAL files that were produced after the "
#~ "snapshot was made. A snapshot can be made even if there is no WAL file. Some "
#~ "snapshots are automatic, or users can make them at any time with the :ref:"
#~ "`box.snapshot() <admin-snapshot>` request."
#~ msgstr ""
#~ "Tarantool также сохраняет ряд файлов со статическими снимками данных "
#~ "(snapshots). Файл со снимком — это дисковая копия всех данных в базе на какой-"
#~ "то момент. Вместо того, чтобы зачитывать все WAL-файлы, появившиеся с момента "
#~ "создания базы, Tarantool в процессе восстановления может загрузить самый "
#~ "свежий снимок и затем зачитать только те WAL-файлы, которые были сделаны с "
#~ "момента сохранения снимка. Снимки могут делаться автоматически, или же "
#~ "пользователи могут создавать их сами в любой момент с помощью запроса :ref:"
#~ "`box.snapshot() <admin-snapshot>`."

#~ msgid "Data manipulation"
#~ msgstr "Манипулирование данными"

#~ msgid ""
#~ "The basic *data-manipulation* requests are: ``insert``, ``replace``, "
#~ "``update``, ``upsert``, ``delete``, ``select``. All of them are part of the "
#~ "``box`` library. Most of them may return data. Usually both inputs and "
#~ "outputs are Lua tables."
#~ msgstr ""
#~ "Основные запросы для *манипулирования данными* — это ``insert``, ``replace``, "
#~ "``update``, ``upsert``, ``delete``, ``select``. Все они реализованы в "
#~ "библиотеке ``box``. Многие из этих запросов могут возвращать данные. Как "
#~ "правило, и вводимые, и возвращаемые значения являются Lua-таблицами."

#~ msgid ""
#~ "-- #1 module . submodule . name\n"
#~ "tarantool> box.space.tester:select{1}\n"
#~ "-- #2 replace name with a literal in square brackets\n"
#~ "tarantool> box.space['tester']:select{1}\n"
#~ "-- #3 replace name with a numeric id in square brackets\n"
#~ "tarantool> box.space[512]:select{1}\n"
#~ "-- #4 use a variable instead of a literal for the name\n"
#~ "tarantool> variable = 'tester'\n"
#~ "tarantool> box.space[variable]:select{1}\n"
#~ "-- #5 use a variable for the entire object reference\n"
#~ "tarantool> s = box.space.tester\n"
#~ "tarantool> s:select{1}"
#~ msgstr ""
#~ "-- #1 имя_модуля . имя_вложенного_модуля . имя_объекта\n"
#~ "tarantool> box.space.tester:select{1}\n"
#~ "-- #2 вместо имени объекта указываем литерал в квадратных скобках\n"
#~ "tarantool> box.space['tester']:select{1}\n"
#~ "-- #3 вместо имени объекта указываем числовой идентификатор в квадратных "
#~ "скобках\n"
#~ "tarantool> box.space[512]:select{1}\n"
#~ "-- #4 вместо литерала, обозначающего имя объекта, указываем переменную\n"
#~ "tarantool> variable = 'tester'\n"
#~ "tarantool> box.space[variable]:select{1}\n"
#~ "-- #5 указываем переменную вместо ссылки на весь объект\n"
#~ "tarantool> s = box.space.tester\n"
#~ "tarantool> s:select{1}"

#~ msgid ""
#~ "The primary-key value is enclosed in braces, and if it was a multi-part "
#~ "primary key then the value would be multi-part, for example ``...select{1,2,3}"
#~ "``. The braces can be enclosed inside parentheses — ``...select({...})`` — "
#~ "which are optional unless it is necessary to pass something besides the "
#~ "primary-key value, as in example #5. Literal values such as 1 (a scalar "
#~ "value) or {1} (a Lua table value) may be replaced by variable names, as in "
#~ "examples #6 and #7. Although there are special cases where braces can be "
#~ "omitted, they are preferable because they signal \"Lua table\". Examples and "
#~ "descriptions in this manual have the \"{1}\" form; however, this too is a "
#~ "matter of user preference and all the variations exist in the wild."
#~ msgstr ""
#~ "Значение первичного ключа заключается в фигурные скобки. Если же этот "
#~ "первичный ключ является составным, то и значение будет составным, например "
#~ "``...select{1,2,3}``. Фигурные скобки в свою очередь могут заключаться в "
#~ "круглые скобки — например, ``...select({...})``. Это опциональный вариант "
#~ "синтаксиса, и он необходим только в том случае, если нужно передать что-то "
#~ "помимо первичного ключа, как в примере #5. Вместо значений-литералов — "
#~ "например, 1 (скалярное значение) или {1} (Lua-таблица) — можно использовать "
#~ "имена переменных, как в примерах #6 и #7. Хотя в некоторых случаях фигурные "
#~ "скобки можно опускать, мы рекомендуем всегда их использовать. Так вы явно "
#~ "обозначите, что значение имеет тип \"Lua-таблица\". В примерах и описаниях в "
#~ "документации мы везде используем фигурные скобки, например \"{1}\".  Но как и "
#~ "в случае со ссылками на объект, вы можете пользоваться любым допустимым "
#~ "вариантом синтаксиса."

#~ msgid ""
#~ "All the data-manipulation functions operate on tuple sets but, since primary "
#~ "keys are unique, the number of tuples in the tuple set is always 0 or 1. The "
#~ "only exception is ``box.space...select``, which may accept either a primary-"
#~ "key value or a secondary-key value."
#~ msgstr ""
#~ "Все функции для манипулирования данными оперируют наборами кортежей. Однако, "
#~ "поскольку первичные ключи всегда уникальны, количество кортежей в таком "
#~ "наборе всегда равно 0 или 1. Единственным исключением является функция ``box."
#~ "space...select``, которая может брать на вход как первичный, так и вторичный "
#~ "ключ."

#~ msgid "**Complexity factors that may affect data-manipulation functions**"
#~ msgstr ""
#~ "#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "**Факторы, которые могут влиять на быстродействие функций для манипулирования "
#~ "данными из библиотеки box**"

#~ msgid ""
#~ "In the discussion of each data-manipulation function, there will be a note "
#~ "about which complexity factors might affect the function's resource usage."
#~ msgstr ""
#~ "#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "Далее в описании каждой функции для манипулирования данными будет дано "
#~ "примечание, какие из перечисленных выше факторов могут влиять на ее "
#~ "быстродействие."

#~ msgid "An indexed field may be a string rather than a number."
#~ msgstr "Индексируемое поле может быть строкой, а не числом."

#~ msgid ""
#~ "For an ordinary index, the most common data types are 'unsigned' = any non-"
#~ "negative integer, or 'string' = any series of bytes. Numbers are ordered "
#~ "according to their point on the number line -- so 2345 is greater than 500 -- "
#~ "while strings are ordered according to the encoding of the first byte then "
#~ "the encoding of the second byte then the encoding of the third byte and so on "
#~ "-- so '2345' is less than '500'."
#~ msgstr ""
#~ "Обычный индекс, как правило, строится по полям одного из двух типов: 'NUM' = "
#~ "числовой (numeric) = любое неотрицательное целое число, либо 'STR' = строка "
#~ "(string) = любая последовательность байтов. Числа в индексе упорядочены по "
#~ "числовой прямой (например, число 2345 больше, чем число 500), а строки — по "
#~ "коду первого байта, затем по коду второго, третьего и т.д. (и теперь строка "
#~ "'2345' будет меньше, чем строка '500')."

#~ msgid "There may be more than one field."
#~ msgstr "Индекс может строиться по нескольким полям."

#~ msgid ""
#~ "For an ordinary index, the maximum number of parts is 255. The specification "
#~ "of each part consists of a field number and a type."
#~ msgstr ""
#~ "В обычном индексе может быть максимум 255 частей. Каждая часть "
#~ "характеризуется номером поля и его типом."

#~ msgid "The index does not have to be unique."
#~ msgstr "Индекс может быть неуникальным."

#~ msgid "The index does not have to be a tree."
#~ msgstr "Индекс может представлять собой не только дерево."

#~ msgid ""
#~ "The existence of indexes does not affect the syntax of data-change requests, "
#~ "but does cause select requests to have more variety."
#~ msgstr ""
#~ "Наличие индексов никак не влияет на синтаксис запросов на изменение данных. А "
#~ "вот SELECT-запросы, благодаря индексам, становятся более разнообразными."

#~ msgid ""
#~ "Searches on BITSET indexes can be for BITS_ANY_SET, BITS_ALL_SET, "
#~ "BITS_ALL_NOT_SET, EQ, or ALL."
#~ msgstr ""
#~ "При поиске по BITSET-индексам можно использовать операторы BITS_ANY_SET, "
#~ "BITS_ALL_SET, BITS_ALL_NOT_SET, EQ и ALL."

#~ msgid ""
#~ "Searches on RTREE indexes can be for GT, GE, LT, LE, OVERLAPS, or NEIGHBOR."
#~ msgstr ""
#~ "При поиске по RTREE-индексам можно использовать операторы GT, GE, LT, LE, "
#~ "OVERLAPS и NEIGHBOR."

#~ msgid "Another example"
#~ msgstr ""
#~ "#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "Например:"

#~ msgid "Differences between memtx and vinyl storage engines"
#~ msgstr "Различия между движками memtx и vinyl"

#~ msgid "Under the hood"
#~ msgstr "А что там \"под капотом\"?"

#~ msgid ""
#~ "The most commonly used Perl driver is `DR::Tarantool <http://search.cpan.org/"
#~ "~unera/DR-Tarantool/>`_. It is not supplied as part of the Tarantool "
#~ "repository; it must be installed separately. The most common way to install "
#~ "it is with `CPAN, the Comprehensive Perl Archive Network <https://en."
#~ "wikipedia.org/wiki/Cpan>`_. ``DR::Tarantool`` requires other modules which "
#~ "should be installed first. For example, on Ubuntu, the installation could "
#~ "look like this:"
#~ msgstr ""
#~ "Наиболее популярным Tarantool-коннектором для языка Perl является `DR::"
#~ "Tarantool <http://search.cpan.org/~unera/DR-Tarantool/>`_. Он устанавливается "
#~ "отдельно от Tarantool'а, например с помощью :program:`cpan` (см. `CPAN, the "
#~ "Comprehensive Perl Archive Network <https://en.wikipedia.org/wiki/Cpan>`_), и "
#~ "требует предварительной установки еще несколько зависимых модулей. Вот пример "
#~ "установки этого коннектора под Ubuntu:"

#~ msgid ""
#~ "$ sudo cpan install AnyEvent\n"
#~ "$ sudo cpan install Devel::GlobalDestruction\n"
#~ "$ sudo cpan install Coro\n"
#~ "$ sudo cpan install Test::Pod\n"
#~ "$ sudo cpan install Test::Spelling\n"
#~ "$ sudo cpan install PAR::Dist\n"
#~ "$ sudo cpan install List::MoreUtils\n"
#~ "$ sudo cpan install DR::Tarantool"
#~ msgstr ""
#~ "$ sudo cpan install AnyEvent\n"
#~ "$ sudo cpan install Devel::GlobalDestruction\n"
#~ "$ sudo cpan install Coro\n"
#~ "$ sudo cpan install Test::Pod\n"
#~ "$ sudo cpan install Test::Spelling\n"
#~ "$ sudo cpan install PAR::Dist\n"
#~ "$ sudo cpan install List::MoreUtils\n"
#~ "$ sudo cpan install DR::Tarantool"

#~ msgid ""
#~ "The example program only shows one request and does not show all that's "
#~ "necessary for good practice. For that, please see `DR::Tarantool CPAN "
#~ "repository <http://search.cpan.org/~unera/DR-Tarantool/>`_."
#~ msgstr ""
#~ "В этой программе мы привели пример использования лишь одного запроса. Для "
#~ "полноценной работы с Tarantool'ом с помощью Perl API, пожалуйста, обратитесь "
#~ "к документации из `CPAN-репозитория DR::Tarantool <http://search.cpan.org/"
#~ "~unera/DR-Tarantool/>`_."

#~ msgid "Q: |br| A: |br|"
#~ msgstr "Вопрос: |br| Ответ: |br|"

#~ msgid ""
#~ "Why Tarantool? |br| Tarantool is the latest generation of a family of in-"
#~ "memory data servers developed for web applications. It is the result of "
#~ "practical experience and trials within Mail.Ru since development began in "
#~ "2008."
#~ msgstr ""
#~ "Почему Tarantool? |br| Tarantool — это in-memory сервер баз данных последнего "
#~ "поколения, предназначенный для работы с веб-приложениями. Разработка ведется "
#~ "с учетом многолетнего опыта использования Tarantool'а в стенах Mail.Ru. "
#~ "Первый релиз состоялся в 2008 году."

#~ msgid ""
#~ "What's the key advantage of Tarantool? |br| Tarantool provides a rich "
#~ "database feature set (HASH, TREE, RTREE, BITSET indexes, secondary indexes, "
#~ "composite indexes, transactions, triggers, asynchronous replication) in a "
#~ "flexible environment of a Lua interpreter. |br| These two properties make it "
#~ "possible to be a fast, atomic and reliable in-memory data server which "
#~ "handles non-trivial application-specific logic. The advantage over "
#~ "traditional SQL servers is in performance: low-overhead, lock-free "
#~ "architecture means Tarantool can serve an order of magnitude more requests "
#~ "per second, on comparable hardware. The advantage over NoSQL alternatives is "
#~ "in flexibility: Lua allows flexible processing of data stored in a compact, "
#~ "denormalized format."
#~ msgstr ""
#~ "В чем состоит главное преимущество Tarantool'а? |br| Tarantool предоставляет "
#~ "богатый набор функций по работе с базами данных (HASH, TREE, RTREE, BitSet-"
#~ "индексы, вторичные индексы, составные индексы, транзакции, триггеры, "
#~ "асинхронная репликация), и всё это — в гибкой среде Lua-интерпретатора. |br| "
#~ "Эти два обстоятельства делают Tarantool быстрым и надежным in-memory сервером "
#~ "баз данных с атомарными операциями и сложной логикой на стороне сервера. "
#~ "Преимуществом Tarantool'а по сравнению с традиционными SQL СУБД является его "
#~ "высокая производительность: низкие накладные расходы и безблокировочная "
#~ "архитектура позволяют Tarantool'у обрабатывать на порядок больше запросов в "
#~ "секунду на аналогичном оборудовании. Преимущество же перед другими NoSQL СУБД "
#~ "заключается в большей гибкости Tarantool'а: язык Lua позволяет гибко "
#~ "обрабатывать данные, хранящиеся в компактном, ненормализованном формате."

#~ msgid ""
#~ "What are your development plans? |br| We continuously improve server "
#~ "performance. On the feature front, automatic sharding and synchronous "
#~ "replication, and a subset of SQL are the major goals for 2016-2018. We have "
#~ "an open roadmap to which we encourage anyone to add feature requests."
#~ msgstr ""
#~ "Каковы ваши планы по развитию? |br| Мы постоянно улучшаем производительность "
#~ "серверной части. Наши главные цели на 2016-2018 год — это автоматический "
#~ "шардинг и синхронная репликация, а также частичная поддержка SQL. План работ "
#~ "находится в открытом доступе, и все желающие могут оставлять запросы на "
#~ "добавление функционала."

#~ msgid ""
#~ "How serious is Mail.Ru about Tarantool? |br| Tarantool is an open source "
#~ "project, distributed under a BSD license, so it does not depend on any one "
#~ "sponsor. However, it is an integral part of the Mail.Ru backbone, so it gets "
#~ "a lot of support from Mail.Ru."
#~ msgstr ""
#~ "Насколько серьезны планы Mail.Ru в отношении Tarantool'а? |br| Tarantool — "
#~ "это проект с открытым кодом, распространяемый под лицензией BSD, поэтому он "
#~ "не зависит от внешних спонсоров. В то же время, Tarantool — это часть "
#~ "технологического \"костяка\" Mail.Ru, и поэтому он пользуется сильной "
#~ "поддержкой со стороны Mail.Ru."

#~ msgid ""
#~ "Are there problems associated with being an in-memory server? |br| The "
#~ "principal storage engine is designed for RAM plus persistent storage. It is "
#~ "immune to data loss because there is a write-ahead log. Its memory-allocation "
#~ "and compression techniques ensure there is no waste. And if Tarantool runs "
#~ "out of memory, then it will stop accepting updates until more memory is "
#~ "available, but will continue to handle read and delete requests without "
#~ "difficulty. However, for databases which are much larger than the available "
#~ "RAM space, Tarantool has a second storage engine which is only limited by the "
#~ "available disk space."
#~ msgstr ""
#~ "Возникают ли проблемы из-за того, что Tarantool является in-memory решением? |"
#~ "br| Основной движок баз данных в Tarantool'е работает с оперативной памятью, "
#~ "но при этом он гарантирует сохранность данных благодаря механизму WAL (write "
#~ "ahead log), т.е. журналу упреждающей записи. Также в Tarantool'е используются "
#~ "технологии сжатия и распределения данных, которые позволяют использовать все "
#~ "виды памяти наиболее эффективно. Если Tarantool сталкивается с нехваткой "
#~ "оперативной памяти, то он приостанавливает прием запросов на изменение данных "
#~ "до тех пор, пока не появится свободная память, но при этом с успехом "
#~ "продолжает обработку запросов на чтение и удаление данных. А для больших баз, "
#~ "где объем данных значительно превосходит имеющийся объем оперативной памяти, "
#~ "у Tarantool'а есть второй движок, чьи возможности ограничены лишь размером "
#~ "жесткого диска."

#~ msgid ""
#~ "To get started, you can either *download the whole Tarantool package* as "
#~ "described in the first part of :ref:`Chapter 2 \"Getting Started\" "
#~ "<user_guide_getting_started>`, or you can skip the download and *connect to "
#~ "the online Tarantool server* running on the web at http://try.tarantool.org. "
#~ "Either way, as the first tryout, you can follow the introductory example "
#~ "\"Starting Tarantool and making your first database\" from :ref:`the second "
#~ "part of Chapter 2 <user_guide_getting_started-first_database>`. If you want "
#~ "more hands-on experience, proceed to the :ref:`\"Tutorials\" <tutorials>` "
#~ "part after you are through with Chapter 2."
#~ msgstr ""
#~ "Знакомство с Tarantool'ом вы можете начать с того, что скачаете готовый "
#~ "установочный пакет (как описано в начале :ref:`главы 2 \"Начало работы\" "
#~ "<user_guide_getting_started>`) или воспользуетесь нашим онлайн-стендом на "
#~ "http://try.tarantool.org. В любом случае для первого знакомства вы можете "
#~ "выполнить тренировочный пример \"Первичный запуск Tarantool'а и создание базы "
#~ "данных\" из второй части главы 2. После этого вы можете заглянуть в наш :ref:`"
#~ "\"Практикум\" <tutorials>`, где содержится еще больше практических заданий."

#~ msgid ""
#~ "This chapter shows how to download, how to install, and how to start "
#~ "Tarantool for the first time."
#~ msgstr ""
#~ "В этой главе рассказывается, как скачать, установить и начать работать с "
#~ "Tarantool'ом с нуля."

#~ msgid ""
#~ "For production, if possible, you should download a binary (executable) "
#~ "package. This will ensure that you have the same build of the same version "
#~ "that the developers have. That makes analysis easier if later you need to "
#~ "report a problem, and avoids subtle problems that might happen if you used "
#~ "different tools or different parameters when building from source. The "
#~ "section about binaries is \":ref:`user_guide_getting_started-"
#~ "downloading_and_installing_a_binary_package`\"."
#~ msgstr ""
#~ "Для промышленной эксплуатации рекомендуется скачать бинарный (исполняемый) "
#~ "пакет. Тогда вы гарантированно получите сборку той же версии, что и у "
#~ "разработчиков. Это существенно упростит поиск ошибок, если вам в будущем "
#~ "понадобится помощь, а также позволит избежать проблем из-за того, что вы "
#~ "использовали инструменты или параметры отличные от тех, что использовали при "
#~ "сборке сами разработчики. См. раздел “:ref:`user_guide_getting_started-"
#~ "downloading_and_installing_a_binary_package`”."

#~ msgid ""
#~ "For development, you will want to download a source package and make the "
#~ "binary by yourself using a C/C++ compiler and common tools. Although this is "
#~ "a bit harder, it gives more control. And the source packages include "
#~ "additional files, for example the Tarantool test suite. The section about "
#~ "source is \":ref:`Building from source <building_from_source>`\" in :ref:"
#~ "`Contributor's Guide <contrib_guide>`."
#~ msgstr ""
#~ "Для разработческих целей вы можете скачать исходные файлы и собрать бинарный "
#~ "пакет самостоятельно с помощью компилятора C/C++ и обычных инструментов для "
#~ "сборки. Хотя это и более трудный способ получить бинарный пакет, но он дает "
#~ "вам больший контроль над результатом. Также в состав исходных файлов входят "
#~ "дополнительные пакеты, например набор тестов для Tarantool'а. См. раздел \":"
#~ "ref:`Сборка из исходных файлов <building_from_source>`\" в \":ref:"
#~ "`Руководстве участника проекта <contrib_guide>`\"."

#~ msgid ""
#~ "If the installation has already been done, then you should try it out. So "
#~ "we've provided some instructions that you can use to make a temporary "
#~ "“sandbox”. In a few minutes you can start the server and type in some "
#~ "database-manipulation statements. The section about the sandbox is \":ref:"
#~ "`user_guide_getting_started-first_database`\"."
#~ msgstr ""
#~ "После установки вы можете сразу опробовать Tarantool в действии. Ниже вы "
#~ "найдете инструкции по созданию безопасной тестовой среды. Всего за несколько "
#~ "минут вы сможете запустить Tarantool-сервер и задать несколько инструкций по "
#~ "манипулированию данными. См. раздел \":ref:`user_guide_getting_started-"
#~ "first_database`”."

#~ msgid ""
#~ "Binary packages for two Tarantool versions -- for the stable 1.6 and the "
#~ "latest 1.7 -- are provided at http://tarantool.org/download.html. An "
#~ "automatic build system creates, tests and publishes packages for every push "
#~ "into the 1.7 branch."
#~ msgstr ""
#~ "Бинарные пакеты для двух версий Tarantool'а — стабильной 1.6 и самой свежей "
#~ "1.7 — выложены на странице http://tarantool.org/download.html. При каждом "
#~ "изменении исходного кода на GitHub (репозиторий http://github.com/tarantool/"
#~ "tarantool, ветка \"1.7\") происходит сборка, автоматическое тестирование и "
#~ "выкладка бинарных пакетов на вышеуказанную страницу."

#~ msgid "Starting Tarantool and making your first database"
#~ msgstr "Первичный запуск Tarantool'а и создание базы данных"

#~ msgid "Start the server. The server name is tarantool."
#~ msgstr "Запустите Tarantool-сервер. Имя программы — :program:`tarantool`."

#~ msgid ""
#~ "The server starts in interactive mode and outputs a command prompt. To turn "
#~ "on the database, :ref:`configure <box_introspection-box_cfg>` it. This "
#~ "minimal example is sufficient:"
#~ msgstr ""
#~ "Tarantool-сервер запускается в интерактивном режиме и выводит приглашение "
#~ "командной строки. Чтобы создать базу данных, задайте ее настройки с помощью "
#~ "вызова :ref:`box.cfg <box_introspection-box_cfg>`. Вот пример минимальной "
#~ "конфигурации:"

#~ msgid ""
#~ "If all goes well, you will see the server displaying progress as it "
#~ "initializes, something like this:"
#~ msgstr ""
#~ "Если все в порядке, то Tarantool-сервер начнет в прогрессе отображать процесс "
#~ "инициализации, например:"

#~ msgid ""
#~ "tarantool> box.cfg{listen = 3301}\n"
#~ "2015-08-07 09:41:41.077 ... version 1.7.0-1216-g73f7154\n"
#~ "2015-08-07 09:41:41.077 ... log level 5\n"
#~ "2015-08-07 09:41:41.078 ... mapping 1073741824 bytes for a shared arena...\n"
#~ "2015-08-07 09:41:41.079 ... initialized\n"
#~ "2015-08-07 09:41:41.081 ... initializing an empty data directory\n"
#~ "2015-08-07 09:41:41.095 ... creating './00000000000000000000.snap."
#~ "inprogress'\n"
#~ "2015-08-07 09:41:41.095 ... saving snapshot './00000000000000000000.snap."
#~ "inprogress'\n"
#~ "2015-08-07 09:41:41.127 ... done\n"
#~ "2015-08-07 09:41:41.128 ... primary: bound to 0.0.0.0:3301\n"
#~ "2015-08-07 09:41:41.128 ... ready to accept requests"
#~ msgstr ""
#~ "tarantool> box.cfg{listen = 3301}\n"
#~ "2015-08-07 09:41:41.077 ... version 1.7.0-1216-g73f7154\n"
#~ "2015-08-07 09:41:41.077 ... log level 5\n"
#~ "2015-08-07 09:41:41.078 ... mapping 1073741824 bytes for a shared arena...\n"
#~ "2015-08-07 09:41:41.079 ... initialized\n"
#~ "2015-08-07 09:41:41.081 ... initializing an empty data directory\n"
#~ "2015-08-07 09:41:41.095 ... creating './00000000000000000000.snap."
#~ "inprogress'\n"
#~ "2015-08-07 09:41:41.095 ... saving snapshot './00000000000000000000.snap."
#~ "inprogress'\n"
#~ "2015-08-07 09:41:41.127 ... done\n"
#~ "2015-08-07 09:41:41.128 ... primary: bound to 0.0.0.0:3301\n"
#~ "2015-08-07 09:41:41.128 ... ready to accept requests"

#~ msgid ""
#~ "Now that the server is up, you could start up a different shell and connect "
#~ "to its primary port with:"
#~ msgstr ""
#~ "Поскольку Tarantool-сервер уже запущен, вы можете запустить новый терминал и "
#~ "присоединиться к основному порту Tarantool-сервера, введя следующую команду:"

#~ msgid "$ telnet 0 3301"
#~ msgstr "$ telnet 0 3301"

#~ msgid ""
#~ "but for example purposes it is simpler to just leave the server running in "
#~ "\"interactive mode\". On production machines the :ref:`interactive mode "
#~ "<administration-using_tarantool_as_a_client>` is just for administrators, but "
#~ "because it's convenient for learning it will be used for most examples in "
#~ "this manual. Tarantool is waiting for the user to type instructions."
#~ msgstr ""
#~ "но пока что будет лучше оставить Tarantool-сервер работать в интерактивном "
#~ "режиме. На промышленных серверах :ref:`интерактивный режим <administration-"
#~ "using_tarantool_as_a_client>` нужен лишь для администрирования, однако для "
#~ "наглядности большинство примеров в данном руководстве даны именно в "
#~ "интерактивном режиме. Итак, Tarantool ждет от вас ввода инструкций."

#~ msgid "Your terminal screen should now look like this:"
#~ msgstr "Вот что должно отображаться на вашем терминале к этому моменту:"

#~ msgid "Now, to prepare for the example in the next section, try this:"
#~ msgstr ""
#~ "Далее, чтобы подготовиться к тестовому примеру в следующем разделе, введите:"

#~ msgid ""
#~ "In the previous section the first request was with ``box.cfg{listen = 3301}"
#~ "``. The ``listen`` value can be any form of URI (uniform resource "
#~ "identifier); in this case it's just a local port: port 3301. It's possible to "
#~ "send requests to the listen URI via:"
#~ msgstr ""
#~ "В предыдущем разделе ваш первый запрос был :samp:`box.cfg{listen = 3301}`. "
#~ "Значением ``listen`` может быть любой URI (универсальный код ресурса), в "
#~ "данном случае — просто номер локального порта (3301). Вы можете отправлять "
#~ "запросы на URI для прослушивания с помощью:"

#~ msgid ""
#~ "a connector (which will be the subject of the \":ref:`index-box_connectors`\" "
#~ "chapter),"
#~ msgstr "коннектора (см. главу \":ref:`index-box_connectors`\"),"

#~ msgid "Submodule `fiber-ipc`"
#~ msgstr "Модуль `fiber-ipc`"

#~ msgid "Lua reference"
#~ msgstr "Справочник по Lua API"

#~ msgid "Lua rocks reference"
#~ msgstr "Справочник по Lua rocks"

#~ msgid ""
#~ "Who is developing Tarantool? |br| There is an engineering team employed by "
#~ "Mail.Ru -- check out our commit logs on github.com/tarantool. The development "
#~ "is fully open. Most of the connectors' authors, and the maintainers for "
#~ "different distributions, come from the wider community."
#~ msgstr ""
#~ "Кто разрабатывает Tarantool? |br| Во-первых, этим занимается команда "
#~ "разработки в Mail.Ru — см. историю коммитов на github.com/tarantool. Вся "
#~ "разработка ведется открытым образом. Кроме того, активную роль играют члены "
#~ "сообщества разработчиков Tarantool'а. Их силами было создано большинство "
#~ "коннекторов и ведутся доработки под разные дистрибутивы."

#~ msgid ""
#~ "However, once a master failure is detected, the recovery is simple: declare "
#~ "that the replica is now the new master, by saying :codenormal:`box.cfg{... "
#~ "listen=`:codeitalic:`URI <index-uri>`:codenormal:`}`. Then, if there are "
#~ "updates on the old master that were not propagated before the old master went "
#~ "down, they would have to be re-applied manually."
#~ msgstr ""
#~ "Но когда сбой уже обнаружен, процедура восстановления проста. Сначала нужно "
#~ "назначить одну из реплик на роль нового главного сервера, задав параметр :"
#~ "codenormal:`box.cfg{... listen=`:codeitalic:`URI <index-uri>`:codenormal:`}`. "
#~ "Затем, если на прежнем главном сервере остались изменения, которые не успели "
#~ "примениться на выбранной реплике перед сбоем, нужно применить эти изменения "
#~ "вручную."

#~ msgid ""
#~ "In :ref:`box.info <box_introspection-box_info>` there is a ``box.info."
#~ "replication.status`` field: \"off\", \"stopped\", \"connecting\", \"auth\", "
#~ "\"follow\", or \"disconnected\". |br| If a replica's status is \"follow\", "
#~ "then there will be two more fields: |br| ``box.info.replication.idle`` = the "
#~ "number of seconds the replica has been idle, |br| ``box.info.replication."
#~ "lag`` = the number of seconds the replica is behind the master."
#~ msgstr ""
#~ "В пакете :ref:`box.info <box_introspection-box_info>` есть поле :code:`box."
#~ "info.replication.status`, которое отражает статус репликации для данной "
#~ "реплики: \"off\", \"stopped\", \"connecting\", \"auth\", \"follow\" или "
#~ "\"disconnected\". |br| Если реплика имеет статус \"follow\", то можно "
#~ "получить уточняющую информацию из еще двух полей: |br| :code:`box.info."
#~ "replication.idle` = время (в секундах), которое реплика провела в состоянии "
#~ "бездействия, |br| :code:`box.info.replication.lag` = время (в секундах), на "
#~ "которое реплика отстает от главного сервера."

#~ msgid ""
#~ "Q: What if advanced users want to understand better how it all works? |br| A: "
#~ "See the description of server startup with replication in the :ref:`Internals "
#~ "<b_internals-replication>` appendix."
#~ msgstr ""
#~ "Вопрос: Что если продвинутые пользователи хотят глубже разобраться с тем, как "
#~ "работает репликация? |br| Ответ: См. информацию о запуске сервера с "
#~ "репликацией в Приложении B. :ref:`Детали реализации <b_internals-"
#~ "replication>`."

#~ msgid ""
#~ "+--------------------------------------------+\n"
#~ "|                                            |\n"
#~ "| SPACE 'tester'                             |\n"
#~ "| +----------------------------------------+ |\n"
#~ "| |                                        | |\n"
#~ "| | TUPLE SET 'tester'                     | |\n"
#~ "| | +-----------------------------------+  | |\n"
#~ "| | | Tuple: [ 1 ]                      |  | |\n"
#~ "| | | Tuple: [ 2, 'Music' ]             |  | |\n"
#~ "| | | Tuple: [ 3, 'length', 93 ]        |  | |\n"
#~ "| | +-----------------------------------+  | |\n"
#~ "| |                                        | |\n"
#~ "| | INDEX 'primary'                        | |\n"
#~ "| | +-----------------------------------+  | |\n"
#~ "| | | Key: 1                            |  | |\n"
#~ "| | | Key: 2                            |  | |\n"
#~ "| | | Key: 3                            |  | |\n"
#~ "| | +-----------------------------------+  | |\n"
#~ "| |                                        | |\n"
#~ "| +----------------------------------------+ |\n"
#~ "+--------------------------------------------+"
#~ msgstr ""
#~ "+--------------------------------------------+\n"
#~ "|                                            |\n"
#~ "| ПРОСТРАНСТВО 'tester'                      |\n"
#~ "| +----------------------------------------+ |\n"
#~ "| |                                        | |\n"
#~ "| | НАБОР КОРТЕЖЕЙ 'tester'                | |\n"
#~ "| | +-----------------------------------+  | |\n"
#~ "| | | Кортеж: [ 1 ]                     |  | |\n"
#~ "| | | Кортеж: [ 2, 'Music' ]            |  | |\n"
#~ "| | | Кортеж: [ 3, 'length', 93 ]       |  | |\n"
#~ "| | +-----------------------------------+  | |\n"
#~ "| |                                        | |\n"
#~ "| | ИНДЕКС 'primary'                       | |\n"
#~ "| | +-----------------------------------+  | |\n"
#~ "| | | Ключ: 1                           |  | |\n"
#~ "| | | Ключ: 2                           |  | |\n"
#~ "| | | Ключ: 3                           |  | |\n"
#~ "| | +-----------------------------------+  | |\n"
#~ "| |                                        | |\n"
#~ "| +----------------------------------------+ |\n"
#~ "+--------------------------------------------+"

#~ msgid ""
#~ "The PHP driver is `tarantool-php <https://github.com/tarantool/tarantool-"
#~ "php>`_. It is not supplied as part of the Tarantool repository; it must be "
#~ "installed separately. It can be installed with :program:`git`. It requires "
#~ "other modules which should be installed first. For example, on Ubuntu, the "
#~ "installation could look like this:"
#~ msgstr ""
#~ "Tarantool-коннектор для языка PHP называется `tarantool-php <https://github."
#~ "com/tarantool/tarantool-php>`_. Он устанавливается отдельно от Tarantool'а с "
#~ "помощью :program:`git` и требует предварительной установки еще несколько "
#~ "зависимых модулей. Вот пример установки этого коннектора под Ubuntu:"

#~ msgid ""
#~ "$ sudo apt-get install php5-cli\n"
#~ "$ sudo apt-get install php5-dev\n"
#~ "$ sudo apt-get install php-pear\n"
#~ "$ cd ~\n"
#~ "$ git clone https://github.com/tarantool/tarantool-php.git\n"
#~ "$ cd tarantool-php\n"
#~ "$ phpize\n"
#~ "$ ./configure\n"
#~ "$ make\n"
#~ "$ # make install is optional"
#~ msgstr ""
#~ "$ sudo apt-get install php5-cli\n"
#~ "$ sudo apt-get install php5-dev\n"
#~ "$ sudo apt-get install php-pear\n"
#~ "$ cd ~\n"
#~ "$ git clone https://github.com/tarantool/tarantool-php.git\n"
#~ "$ cd tarantool-php\n"
#~ "$ phpize\n"
#~ "$ ./configure\n"
#~ "$ make\n"
#~ "$ # make install is optional"

#~ msgid ""
#~ "At this point there is a file named :file:`~/tarantool-php/modules/tarantool."
#~ "so`. PHP will only find it if the PHP initialization file :file:`php.ini` "
#~ "contains a line like :samp:`extension=./tarantool.so`, or if PHP is started "
#~ "with the option :samp:`-d extension=~/tarantool-php/modules/tarantool.so`."
#~ msgstr ""
#~ "После отработки всех команд будет создан файл с именем :file:`~/tarantool-php/"
#~ "modules/tarantool.so`. PHP увидит его, только если в файле инициализации :"
#~ "file:`php.ini` есть строка вида :samp:`extension=./tarantool.so`, либо если "
#~ "при запуске PHP вы укажете опцию :samp:`-d extension=~/tarantool-php/modules/"
#~ "tarantool.so`."

#~ msgid ""
#~ "The example program only shows one request and does not show all that's "
#~ "necessary for good practice. For that, please see `tarantool-python project "
#~ "at GitHub <http://github.com/tarantool/tarantool-python>`_. For an example of "
#~ "using Python API with `queue managers for Tarantool <https://github.com/"
#~ "tarantool/queue>`_, see `queue-python project at GitHub <https://github.com/"
#~ "tarantool/queue-python>`_."
#~ msgstr ""
#~ "В этой программе мы привели пример использования лишь одного запроса. Для "
#~ "полноценной работы с Tarantool'ом с помощью Python API, пожалуйста, "
#~ "обратитесь к документации из `проекта tarantool-python на GitHub <http://"
#~ "github.com/tarantool/tarantool-python>`_. А на странице `проекта queue-python "
#~ "на GitHub <https://github.com/tarantool/queue-python>`_ вы сможете найти "
#~ "примеры использования Python API для работы с `очередями сообщений в "
#~ "Tarantool'е <https://github.com/tarantool/queue>`_."

#~ msgid "Start the tarantoolctl utility:"
#~ msgstr "Запустите утилиту ``tarantoolctl``:"

#~ msgid ""
#~ "You can repeat ``box.space...:insert{}`` and ``box.space...:select{}`` "
#~ "indefinitely, on either Tarantool instance. When the testing is over: To drop "
#~ "the space: ``s:drop()``. To stop tarantoolctl: Ctrl+C or Ctrl+D. To stop "
#~ "tarantool (an alternative): :ref:`os.exit() <os-exit>`. To stop tarantool "
#~ "(from another terminal): ``sudo pkill -f tarantool``. To destroy the test: "
#~ "``rm -r ~/tarantool_sandbox``."
#~ msgstr ""
#~ "Вы можете повторно вводить команды :code:`box.space...:insert{}` и :code:`box."
#~ "space...:select{}` сколько угодно раз, на любом экземпляре Tarantool'а. В "
#~ "конце тестирования воспользуйтесь следующими командами. Чтобы удалить "
#~ "пространство: :code:`s:drop()`. Чтобы остановить  ``tarantoolctl``: Ctrl+C "
#~ "или Ctrl+D. Чтобы остановить Tarantool (альтернативный вариант): :ref:`os."
#~ "exit() <os-exit>`. Чтобы остановить Tarantool (с другого терминала): :code:"
#~ "`sudo pkill -f tarantool`. Чтобы удалить тестовую базу: :code:`rm -r ~/"
#~ "tarantool_sandbox`."

#~ msgid ""
#~ "**array**: array of integers between -9223372036854775808 and "
#~ "9223372036854775807. Legal in memtx RTREE indexes."
#~ msgstr ""
#~ "``integer`` (знаковое целое число в диапазоне от -9,223,372,036,854,775,808 "
#~ "до 9,223,372,036,854,775,807)"

#~ msgid "1,2345"
#~ msgstr "12345"

#~ msgid ""
#~ "**array** (arrays of integers between -9223372036854775808 and "
#~ "9223372036854775807)"
#~ msgstr ""
#~ "``integer`` (знаковое целое число в диапазоне от -9,223,372,036,854,775,808 "
#~ "до 9,223,372,036,854,775,807)"

#~ msgid "**Slab size**"
#~ msgstr "**scalar**"

#~ msgid ""
#~ "With memtx, :ref:`create_index <box_space-create_index>` can be done at any "
#~ "time."
#~ msgstr ""
#~ "Подробнее о других типах индексов см. в описании функции :ref:`create_index "
#~ "<box_space-create_index>`."

#~ msgid ""
#~ "$ # Terminal 2\n"
#~ "$ mkdir -p ~/tarantool_test_node_2\n"
#~ "$ cd ~/tarantool_test_node_2\n"
#~ "$ rm -R ./*\n"
#~ "$ ~/tarantool/src/tarantool\n"
#~ "/home/username/tarantool/src/tarantool: version 1.7.0-1724-g033ed69\n"
#~ "type 'help' for interactive help\n"
#~ "tarantool> box.cfg{\n"
#~ "         >   listen = 3302,\n"
#~ "         >   replication = 'replicator:password@localhost:3301'\n"
#~ "         > }\n"
#~ "<...>\n"
#~ "<...> [11243] main/101/interactive I> mapping 1073741824 bytes for tuple "
#~ "arena...\n"
#~ "<...> [11243] main/101/interactive C> starting replication from "
#~ "localhost:3301\n"
#~ "<...> [11243] main/102/applier/localhost:3301 I> connected to 1.7.0 at "
#~ "127.0.0.1:3301\n"
#~ "<...> [11243] main/102/applier/localhost:3301 I> authenticated\n"
#~ "<...> [11243] main/102/applier/localhost:3301 I> downloading a snapshot from "
#~ "127.0.0.1:3301\n"
#~ "<...> [11243] main/102/applier/localhost:3301 I> done\n"
#~ "<...> [11243] snapshot/101/main I> creating `./00000000000000000000.snap."
#~ "inprogress'\n"
#~ "<...> [11243] snapshot/101/main I> saving snapshot `./00000000000000000000."
#~ "snap.inprogress'\n"
#~ "<...> [11243] snapshot/101/main I> done\n"
#~ "<...> [11243] iproto I> binary: started\n"
#~ "<...> [11243] iproto I> binary: bound to 0.0.0.0:3302\n"
#~ "<...> [11243] wal/101/main I> creating `./00000000000000000000.xlog."
#~ "inprogress'\n"
#~ "<...> [11243] main/101/interactive I> ready to accept requests\n"
#~ "tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
#~ "- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
#~ "  - [2, '236230b8-af3e-406b-b709-15a60b44c20c']\n"
#~ "..."
#~ msgstr ""
#~ "$ # Terminal 2\n"
#~ "$ mkdir -p ~/tarantool_test_node_2\n"
#~ "$ cd ~/tarantool_test_node_2\n"
#~ "$ rm -R ./*\n"
#~ "$ ~/tarantool/src/tarantool\n"
#~ "/home/username/tarantool/src/tarantool: version 1.7.0-1724-g033ed69\n"
#~ "type 'help' for interactive help\n"
#~ "tarantool> box.cfg{\n"
#~ "         >   listen = 3302,\n"
#~ "         >   replication_source = 'replicator:password@localhost:3301'\n"
#~ "         > }\n"
#~ "<...>\n"
#~ "<...> [11243] main/101/interactive I> mapping 1073741824 bytes for tuple "
#~ "arena...\n"
#~ "<...> [11243] main/101/interactive C> starting replication from "
#~ "localhost:3301\n"
#~ "<...> [11243] main/102/applier/localhost:3301 I> connected to 1.7.0 at "
#~ "127.0.0.1:3301\n"
#~ "<...> [11243] main/102/applier/localhost:3301 I> authenticated\n"
#~ "<...> [11243] main/102/applier/localhost:3301 I> downloading a snapshot from "
#~ "127.0.0.1:3301\n"
#~ "<...> [11243] main/102/applier/localhost:3301 I> done\n"
#~ "<...> [11243] snapshot/101/main I> creating `./00000000000000000000.snap."
#~ "inprogress'\n"
#~ "<...> [11243] snapshot/101/main I> saving snapshot `./00000000000000000000."
#~ "snap.inprogress'\n"
#~ "<...> [11243] snapshot/101/main I> done\n"
#~ "<...> [11243] iproto I> binary: started\n"
#~ "<...> [11243] iproto I> binary: bound to 0.0.0.0:3302\n"
#~ "<...> [11243] wal/101/main I> creating `./00000000000000000000.xlog."
#~ "inprogress'\n"
#~ "<...> [11243] main/101/interactive I> ready to accept requests\n"
#~ "tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
#~ "- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
#~ "  - [2, '236230b8-af3e-406b-b709-15a60b44c20c']\n"
#~ "..."

#~ msgid ""
#~ "<... ...>\n"
#~ "$ ~/tarantool/src/tarantool\n"
#~ "<...>\n"
#~ "tarantool> box.cfg{listen = 3301}\n"
#~ "<...> [22612] main/101/interactive I> ready to accept requests\n"
#~ "<... ...>\n"
#~ "tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
#~ "---\n"
#~ "- - [1, 'Tuple inserted on Terminal #1']\n"
#~ "...\n"
#~ "tarantool> box.cfg{\n"
#~ "         >   replication = 'replicator:password@localhost:3302'\n"
#~ "         > }\n"
#~ "[28987] main/101/interactive C> starting replication from localhost:3302\n"
#~ "---\n"
#~ "...\n"
#~ "[22612] main/101/interactive C> starting replication from localhost:3302\n"
#~ "[22612] main/101/interactive I> set 'replication' configuration\n"
#~ "        option to \"replicator:password@localhost:3302\"\n"
#~ "[22612] main/104/applier/localhost:3302 I> connected to 1.7.0 at "
#~ "127.0.0.1:3302\n"
#~ "[22612] main/104/applier/localhost:3302 I> authenticated\n"
#~ "[22612] wal/101/main I> creating `./00000000000000000008.xlog.inprogress'\n"
#~ "[22612] relay/127.0.0.1:33510/102/main I> done `./00000000000000000000.xlog'\n"
#~ "[22612] relay/127.0.0.1:33510/102/main I> recover from "
#~ "`./00000000000000000008.xlog'\n"
#~ "tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
#~ "---\n"
#~ "- - [1, 'Tuple inserted on Terminal #1']\n"
#~ "  - [2, 'Tuple inserted on Terminal #2']\n"
#~ "  - [3, 'Another']\n"
#~ "..."
#~ msgstr ""
#~ "<... ...>\n"
#~ "$ ~/tarantool/src/tarantool\n"
#~ "<...>\n"
#~ "tarantool> box.cfg{listen = 3301}\n"
#~ "<...> [22612] main/101/interactive I> ready to accept requests\n"
#~ "<... ...>\n"
#~ "tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
#~ "---\n"
#~ "- - [1, 'Tuple inserted on Terminal #1']\n"
#~ "...\n"
#~ "tarantool> box.cfg{\n"
#~ "         >   replication_source='replicator:password@localhost:3302'\n"
#~ "         > }\n"
#~ "[28987] main/101/interactive C> starting replication from localhost:3302\n"
#~ "---\n"
#~ "...\n"
#~ "[22612] main/101/interactive C> starting replication from localhost:3302\n"
#~ "[22612] main/101/interactive I> set 'replication_source' configuration\n"
#~ "        option to \"replicator:password@localhost:3302\"\n"
#~ "[22612] main/104/applier/localhost:3302 I> connected to 1.7.0 at "
#~ "127.0.0.1:3302\n"
#~ "[22612] main/104/applier/localhost:3302 I> authenticated\n"
#~ "[22612] wal/101/main I> creating `./00000000000000000008.xlog.inprogress'\n"
#~ "[22612] relay/127.0.0.1:33510/102/main I> done `./00000000000000000000.xlog'\n"
#~ "[22612] relay/127.0.0.1:33510/102/main I> recover from "
#~ "`./00000000000000000008.xlog'\n"
#~ "tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
#~ "---\n"
#~ "- - [1, 'Tuple inserted on Terminal #1']\n"
#~ "  - [2, 'Tuple inserted on Terminal #2']\n"
#~ "  - [3, 'Another']\n"
#~ "..."
