# #-#-#-#-#  doc.empty.po (Tarantool 1.10)  #-#-#-#-#
# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the Tarantool package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
# #-#-#-#-#  doc.1.7.po (PROJECT VERSION)  #-#-#-#-#
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
msgid ""
msgstr ""
"Project-Id-Version: PROJECT VERSION\n"
"Report-Msgid-Bugs-To: EMAIL@ADDRESS\n"
"POT-Creation-Date: 2019-09-03 10:46+0300\n"
"PO-Revision-Date: 2019-09-03 10:44+0300\n"
"Last-Translator: \n"
"Language: ru\n"
"Language-Team: \n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../doc/1.10/book/admin/backups.rst:39
msgid "Backups"
msgstr "Резервное копирование"

#: ../doc/1.10/book/admin/backups.rst:41
msgid ""
"Tarantool has an append-only storage architecture: it appends data to "
"files but it never overwrites earlier data. The :ref:`Tarantool garbage "
"collector <cfg_checkpoint_daemon-garbage-collector>` removes old files "
"after a checkpoint. You can prevent or delay the garbage collector's "
"action by configuring the :ref:`checkpoint daemon "
"<book_cfg_checkpoint_daemon>`. Backups can be taken at any time, with "
"minimal overhead on database performance."
msgstr ""
"Архитектура Tarantool-хранилища позволяет производить обновление только "
"путем присоединения новых записей: сами файлы никогда не "
"перезаписываются. :ref:`Сборщик мусора Tarantool'а "
"<cfg_checkpoint_daemon-garbage-collector>` удаляет старые файлы после "
"определенной контрольной точки. В настройках :ref:`демона создания "
"контрольных точек <book_cfg_checkpoint_daemon>` можно отложить или "
"запретить работу сборщика мусора. Резервное копирование может проводиться"
" в любое время с минимальной затратой ресурсов."

#: ../doc/1.10/book/admin/backups.rst:54
msgid "backup.start() and backup.stop()"
msgstr "Функции backup.start() и backup.stop()"

#: ../doc/1.10/book/admin/backups.rst:56
msgid "Two functions are helpful for backups in certain situations."
msgstr ""
"Данные функции используются для резервного копирования в определенных "
"ситуациях."

#: ../doc/1.10/book/admin/backups.rst:58
#, fuzzy
msgid ""
"``box.backup.start()`` informs the server that activities related to the "
"removal of outdated backups must be suspended and returns a table with "
"the names of snapshot and vinyl files that should be copied. Example:"
msgstr ""
"``box.backup.start()`` возвращает таблицу с именами снимка и файлов "
"vinyl'а, которые следует копировать. Например:"

#: ../doc/1.10/book/admin/backups.rst:62
msgid ""
"tarantool> box.backup.start()\n"
"---\n"
"- - ./00000000000000000015.snap\n"
"  - ./00000000000000000000.vylog\n"
"  - ./513/0/00000000000000000002.index\n"
"  - ./513/0/00000000000000000002.run\n"
"..."
msgstr ""
"tarantool> box.backup.start()\n"
"---\n"
"- - ./00000000000000000015.snap\n"
"  - ./00000000000000000000.vylog\n"
"  - ./513/0/00000000000000000002.index\n"
"  - ./513/0/00000000000000000002.run\n"
"..."

#: ../doc/1.10/book/admin/backups.rst:74
msgid ""
"To guarantee an opportunity to copy these files Tarantool will not delete"
" them. But there will be no read-only mode and checkpoints will continue "
"by schedule as usual."
msgstr ""

#: ../doc/1.10/book/admin/backups.rst:78
msgid ""
"Later ``box.backup.stop()`` informs the server that normal operations may"
" resume. Starting with Tarantool 1.10.1 there is a new optional argument,"
" ``box.backup.start(n)``, where ``n`` indicates the checkpoint to use "
"relative to the latest checkpoint -- for example ``n = 0`` means \"backup"
" will be based on the latest checkpoint\", ``n = 1`` means \"backup will "
"be based on the first checkpoint before the latest checkpoint (counting "
"backwards)\", and so on, and the default value for ``n`` is zero."
msgstr ""
"Затем ``box.backup.stop()`` сообщает серверу, что можно возобновить "
"нормальную работу. Начиная с версии Tarantool'а 1.10.1, добавлен "
"необязательный аргумент ``box.backup.start(n)``, где ``n`` обозначает "
"используемую контрольную точку относительно последней контрольной точки "
"--  например, ``n = 0`` означает, что резервное копирование будет "
"выполняться по последней контрольной точке, ``n = 1`` означает, что "
"резервное копирование будет выполняться по первой контрольной точке от "
"последней контрольной точки (счет в обратном порядке)\" и так далее, а по"
" умолчанию для ``n`` используется ноль."

#: ../doc/1.10/book/admin/backups.rst:91
msgid "Hot backup (memtx)"
msgstr "Горячее резервирование (memtx)"

#: ../doc/1.10/book/admin/backups.rst:93
msgid "This is a special case when there are only in-memory tables."
msgstr "Это особый случай, когда все таблицы хранятся в памяти."

#: ../doc/1.10/book/admin/backups.rst:95
msgid ""
"The last :ref:`snapshot file <index-box_persistence>` is a backup of the "
"entire database; and the :ref:`WAL <internals-wal>` files that are made "
"after the last snapshot are incremental backups. Therefore taking a "
"backup is a matter of copying the snapshot and WAL files."
msgstr ""
"Последний созданный Tarantool'ом :ref:`файл-снимок <index-"
"box_persistence>` является резервной копией всей базы данных; а "
":ref:`WAL-файлы <internals-wal>`, созданные следом за последним "
"файлом-снимком, являются инкрементными копиями. Поэтому процедура "
"резервирования сводится к копированию последнего файла-снимка и следующих"
" за ним WAL-файлов."

#: ../doc/1.10/book/admin/backups.rst:100
msgid ""
"Use ``tar`` to make a (possibly compressed) copy of the latest .snap and "
".xlog files on the :ref:`memtx_dir <cfg_basic-memtx_dir>` and "
":ref:`wal_dir <cfg_basic-wal_dir>` directories."
msgstr ""
"С помощью ``tar`` создайте (зачастую сжатую) копию последнего .snap-файла"
" и следующих за ним .xlog-файлов из директорий :ref:`memtx_dir "
"<cfg_basic-memtx_dir>` и :ref:`wal_dir <cfg_basic-wal_dir>`."

#: ../doc/1.10/book/admin/backups.rst:104
msgid "If there is a security policy, encrypt the .tar file."
msgstr "Если того требуют правила безопасности, зашифруйте получившийся .tar-файл."

#: ../doc/1.10/book/admin/backups.rst:106
msgid "Copy the .tar file to a safe place."
msgstr "Скопируйте .tar-файл в надежное место."

#: ../doc/1.10/book/admin/backups.rst:108
msgid ""
"Later, restoring the database is a matter of taking the .tar file and "
"putting its contents back in the ``memtx_dir`` and ``wal_dir`` "
"directories."
msgstr ""
"В дальнейшем базу данных можно восстановить, разархивировав содержимое "
".tar-файла в директории ``memtx_dir`` и ``wal_dir``."

#: ../doc/1.10/book/admin/backups.rst:115
msgid "Hot backup (vinyl/memtx)"
msgstr "Горячее резервирование (vinyl/memtx)"

#: ../doc/1.10/book/admin/backups.rst:117
msgid ""
"Vinyl stores its files in :ref:`vinyl_dir <cfg_basic-vinyl_dir>`, and "
"creates a folder for each database space. Dump and compaction processes "
"are append-only and create new files. The Tarantool garbage collector may"
" remove old files after each checkpoint."
msgstr ""
"Vinyl хранит свои файлы в :ref:`vinyl_dir <cfg_basic-vinyl_dir>` и "
"создает для каждого спейса в базе данных отдельную поддиректорию. "
"Создание дампов и слияние -- это процессы, которые могут лишь добавлять "
"записи, поэтому в результате создаются новые файлы. Сборщик мусора "
"Tarantool'а может удалять старые файлы после каждой контрольной точки."

#: ../doc/1.10/book/admin/backups.rst:122
msgid "To take a mixed backup:"
msgstr "Для создания смешанной резервной копии:"

#: ../doc/1.10/book/admin/backups.rst:124
msgid ""
"Issue :ref:`box.backup.start() <admin-backups-backup_start>` on the "
":ref:`administrative console <admin-security>`. This will suspend garbage"
" collection till the next ``box.backup.stop()`` and will return a list of"
" files to back up."
msgstr ""
"Выполните команду :ref:`box.backup.start() <admin-backups-backup_start>` "
"в :ref:`административной консоли <admin-security>`. Эта команда "
"приостановит сборку мусора до вызова ``box.backup.stop()`` и покажет "
"список файлов для резервирования."

#: ../doc/1.10/book/admin/backups.rst:129
msgid ""
"Copy the files from the list to a safe location. This will include memtx "
"snapshot files, vinyl run and index files, at a state consistent with the"
" last checkpoint."
msgstr ""
"Скопируйте файлы из списка в надежное место. Это касается файлов-снимков "
"memtx, выполняемых vinyl-файлов и индексных файлов, соответствующих "
"последней контрольной точке."

#: ../doc/1.10/book/admin/backups.rst:133
msgid "Issue ``box.backup.stop()`` so the garbage collector can continue."
msgstr ""
"Выполните команду ``box.backup.stop()``, чтобы сборщик мусора мог "
"продолжить работу."

#: ../doc/1.10/book/admin/backups.rst:139
msgid "Continuous remote backup (memtx)"
msgstr "Непрерывное удаленное резервирование"

#: ../doc/1.10/book/admin/backups.rst:141
msgid ""
"The :ref:`replication <replication>` feature is useful for backup as well"
" as for load balancing."
msgstr ""
":ref:`Репликация <replication>` используется не только для "
"резервирования, но и для выравнивания нагрузки."

#: ../doc/1.10/book/admin/backups.rst:144
msgid ""
"Therefore taking a backup is a matter of ensuring that any given replica "
"is up to date, and doing a cold backup on it. Since all the other "
"replicas continue to operate, this is not a cold backup from the end "
"user’s point of view. This could be done on a regular basis, with a "
"``cron`` job or with a Tarantool fiber."
msgstr ""
"Поэтому процесс создания резервной копии сводится к обновлению (при "
"необходимости) одной из реплик с последующим холодным резервированием. "
"Так как все остальные реплики продолжают функционировать, с точки зрения "
"конечного пользователя, этот процесс не является холодным "
"резервированием. Такое резервирование можно выполнять регулярно с помощью"
"  планировщика ``cron`` или файбера Tarantool'а."

#: ../doc/1.10/book/admin/backups.rst:153
msgid "Continuous backup (memtx)"
msgstr "Непрерывное резервирование"

#: ../doc/1.10/book/admin/backups.rst:155
msgid ""
"The logged changes done since the last cold backup must be secured, while"
" the system is running."
msgstr ""
"По ходу работы системы необходимо сохранять записи об изменениях, "
"внесенных со времени последнего холодного резервирования."

#: ../doc/1.10/book/admin/backups.rst:158
msgid ""
"For this purpose, you need a file copy utility that will do the copying "
"remotely and continuously, copying only the parts of a write ahead log "
"file that are changing. One such utility is `rsync "
"<https://en.wikipedia.org/wiki/Rsync>`_."
msgstr ""
"Для этого нужна специальная утилита для копирования файлов (например, "
"`rsync <https://en.wikipedia.org/wiki/rsync>`_), которая позволит "
"удаленно и на постоянной основе копировать только изменившиеся части "
"WAL-файла, а не весь файл целиком."

#: ../doc/1.10/book/admin/backups.rst:163
msgid ""
"Alternatively, you need an ordinary file copy utility, but there should "
"be frequent production of new snapshot files or new WAL files as changes "
"occur, so that only the new files need to be copied."
msgstr ""
"Можно взять и обычную утилиту для копирования целых файлов, но тогда "
"придется создавать файлы-снимки и WAL-файлы на каждое изменение, чтобы "
"нужно было копировать только новые файлы."

#: ../doc/1.10/book/admin/bug_reports.rst:39
msgid "Bug reports"
msgstr "Сообщения об ошибках"

#: ../doc/1.10/book/admin/bug_reports.rst:41
msgid ""
"If you found a bug in Tarantool, you’re doing us a favor by taking the "
"time to tell us about it."
msgstr "Если вы нашли ошибку в Tarantool, вы окажете нам услугу, сообщив о ней."

#: ../doc/1.10/book/admin/bug_reports.rst:44
msgid ""
"Please create an issue at Tarantool repository at GitHub. We encourage "
"you to include the following information:"
msgstr ""
"Пожалуйста, откройте тикет в репозитории Tarantool на GitHub. Рекомендуем"
"  включить следующую информацию:"

#: ../doc/1.10/book/admin/bug_reports.rst:47
msgid ""
"Steps needed to reproduce the bug, and an explanation why this differs "
"from the expected behavior according to our manual. Please provide "
"specific unique information. For example, instead of \"I can’t get "
"certain information\", say \"box.space.x:delete() didn’t report what was "
"deleted\"."
msgstr ""
"Шаги для воспроизведения ошибки с объяснением того, как ошибочное "
"поведение отличается от описанного в документации ожидаемого поведения. "
"Пожалуйста, указывайте как можно более конкретную информацию. Например, "
"вместо \"Я не могу получить определенную информацию\" лучше написать "
"\"box.space.x:delete() не указывает, что именно было удалено\"."

#: ../doc/1.10/book/admin/bug_reports.rst:52
msgid ""
"Your operating system name and version, the Tarantool name and version, "
"and any unusual details about your machine and its configuration."
msgstr ""
"Название и версию вашей операционной системы, название и версию Tarantool"
"  и любую информацию об особенностях вашей машины и ее конфигурации."

#: ../doc/1.10/book/admin/bug_reports.rst:55
msgid ""
"Related files like a :ref:`stack trace <admin-stack_traces>` or a "
"Tarantool :ref:`log file <admin-logs>`."
msgstr ""
"Сопутствующие файлы -- такие как :ref:`трассировка стека <admin-"
"stack_traces>` или :ref:`файл журнала <admin-logs>` Tarantool'а."

#: ../doc/1.10/book/admin/bug_reports.rst:58
msgid ""
"If this is a feature request or if it affects a special category of "
"users, be sure to mention that."
msgstr ""
"Если это запрос новой функции или это затрагивает определенную группу "
"пользователей, не забудьте это указать."

#: ../doc/1.10/book/admin/bug_reports.rst:61
msgid ""
"Usually within one or two workdays a Tarantool team member will write an "
"acknowledgment, or some questions, or suggestions for a workaround."
msgstr ""
"Обычно член команды Tarantool отвечает в течение одного-двух рабочих "
"дней, чтобы подтвердить, что тикет взят в работу, задать уточняющие "
"вопросы или предложить альтернативное решение описанной проблемы."

#: ../doc/1.10/book/admin/daemon_supervision.rst:39
msgid "Daemon supervision"
msgstr "Контроль за фоновыми программами"

#: ../doc/1.10/book/admin/daemon_supervision.rst:45
msgid "Server signals"
msgstr "Сигналы от сервера"

#: ../doc/1.10/book/admin/daemon_supervision.rst:47
msgid ""
"Tarantool processes these signals during the event loop in the "
"transaction processor thread:"
msgstr ""
"Во время событийного цикла в потоке обработки транзакций Tarantool "
"обрабатывает следующие сигналы:"

#: ../doc/1.10/book/admin/daemon_supervision.rst:56
msgid "Signal"
msgstr "Сигнал"

#: ../doc/1.10/book/admin/daemon_supervision.rst:56
#: ../doc/1.10/book/box/box_schema.rst:165
#: ../doc/1.10/book/box/box_space.rst:316
#: ../doc/1.10/book/box/data_model.rst:897
msgid "Effect"
msgstr "Эффект"

#: ../doc/1.10/book/admin/daemon_supervision.rst:58
msgid "SIGHUP"
msgstr "SIGHUP"

#: ../doc/1.10/book/admin/daemon_supervision.rst:58
msgid ""
"May cause log file rotation. See the :ref:`example <cfg_logging-"
"logging_example>` in reference on Tarantool logging parameters."
msgstr ""
"Может привести к ротации журналов, см. :ref:`пример <cfg_logging-"
"logging_example>` в справочнике по параметрам журналирования Tarantool'а."

#: ../doc/1.10/book/admin/daemon_supervision.rst:62
msgid "SIGUSR1"
msgstr "SIGUSR1"

#: ../doc/1.10/book/admin/daemon_supervision.rst:62
msgid "May cause a database checkpoint. See :ref:`box.snapshot <box-snapshot>`."
msgstr ""
"Может привести к созданию снимка состояния базы данных, см. описание "
"функции :ref:`box.snapshot <box-snapshot>`."

#: ../doc/1.10/book/admin/daemon_supervision.rst:65
msgid "SIGTERM"
msgstr "SIGTERM"

#: ../doc/1.10/book/admin/daemon_supervision.rst:65
msgid "May cause graceful shutdown (information will be saved first)."
msgstr ""
"Может привести к корректному завершению работы (с предварительным "
"сохранением всех данных)."

#: ../doc/1.10/book/admin/daemon_supervision.rst:68
msgid "SIGINT (also known as keyboard interrupt)"
msgstr "SIGINT (или \"прерывание от клавиатуры\")"

#: ../doc/1.10/book/admin/daemon_supervision.rst:68
msgid "May cause graceful shutdown."
msgstr "Может привести к корректному завершению работы."

#: ../doc/1.10/book/admin/daemon_supervision.rst:72
msgid "SIGKILL"
msgstr "SIGKILL"

#: ../doc/1.10/book/admin/daemon_supervision.rst:72
msgid "Causes an immediate shutdown."
msgstr "Приводит к аварийному завершению работы."

#: ../doc/1.10/book/admin/daemon_supervision.rst:75
msgid ""
"Other signals will result in behavior defined by the operating system. "
"Signals other than SIGKILL may be ignored, especially if Tarantool is "
"executing a long-running procedure which prevents return to the event "
"loop in the transaction processor thread."
msgstr ""
"Остальные сигналы приводят к заданному операционной системой поведению. "
"Все сигналы, за исключением SIGKILL, можно игнорировать, особенно если "
"Tarantool выполняет длительную процедуру и не может вернуться в "
"событийный цикл в потоке обработки транзакций."

#: ../doc/1.10/book/admin/daemon_supervision.rst:84
msgid "Automatic instance restart"
msgstr "Автоматическая перезагрузка экземпляра"

#: ../doc/1.10/book/admin/daemon_supervision.rst:86
msgid ""
"On ``systemd``-enabled platforms, ``systemd`` automatically restarts all "
"Tarantool instances in case of failure. To demonstrate it, let’s try to "
"destroy an instance:"
msgstr ""
"На платформах, где доступна утилита ``systemd``, ``systemd`` "
"автоматически перезагружает все экземпляры Tarantool'а при сбое. Чтобы "
"продемонстрировать это, отключим один из экземпляров:"

#: ../doc/1.10/book/admin/daemon_supervision.rst:90
msgid ""
"$ systemctl status tarantool@my_app|grep PID\n"
"Main PID: 5885 (tarantool)\n"
"$ tarantoolctl enter my_app\n"
"/bin/tarantoolctl: Found my_app.lua in /etc/tarantool/instances.available"
"\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/my_app.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/my_app.control\n"
"unix/:/var/run/tarantool/my_app.control> os.exit(-1)\n"
"/bin/tarantoolctl: unix/:/var/run/tarantool/my_app.control: Remote host "
"closed connection"
msgstr ""
"$ systemctl status tarantool@my_app|grep PID\n"
"Main PID: 5885 (tarantool)\n"
"$ tarantoolctl enter my_app\n"
"/bin/tarantoolctl: Found my_app.lua in /etc/tarantool/instances.available"
"\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/my_app.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/my_app.control\n"
"unix/:/var/run/tarantool/my_app.control> os.exit(-1)\n"
"/bin/tarantoolctl: unix/:/var/run/tarantool/my_app.control: Remote host "
"closed connection"

#: ../doc/1.10/book/admin/daemon_supervision.rst:101
msgid "Now let’s make sure that ``systemd`` has restarted the instance:"
msgstr "А теперь убедимся, что ``systemd`` перезапустила его:"

#: ../doc/1.10/book/admin/daemon_supervision.rst:103
msgid ""
"$ systemctl status tarantool@my_app|grep PID\n"
"Main PID: 5914 (tarantool)"
msgstr ""
"$ systemctl status tarantool@my_app|grep PID\n"
"Main PID: 5914 (tarantool)"

#: ../doc/1.10/book/admin/daemon_supervision.rst:108
msgid "Finally, let’s check the boot logs:"
msgstr "И под конец проверим содержимое журнала загрузки:"

#: ../doc/1.10/book/admin/daemon_supervision.rst:110
msgid ""
"$ journalctl -u tarantool@my_app -n 8\n"
"-- Logs begin at Fri 2016-01-08 12:21:53 MSK, end at Thu 2016-01-21 "
"21:09:45 MSK. --\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: "
"tarantool@my_app.service: Unit entered failed state.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: "
"tarantool@my_app.service: Failed with result 'exit-code'.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: "
"tarantool@my_app.service: Service hold-off time over, scheduling restart."
"\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Stopped Tarantool "
"Database Server.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Starting Tarantool "
"Database Server...\n"
"Jan 21 21:09:45 localhost.localdomain tarantoolctl[5910]: "
"/usr/bin/tarantoolctl: Found my_app.lua in "
"/etc/tarantool/instances.available\n"
"Jan 21 21:09:45 localhost.localdomain tarantoolctl[5910]: "
"/usr/bin/tarantoolctl: Starting instance...\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Started Tarantool "
"Database Server."
msgstr ""
"$ journalctl -u tarantool@my_app -n 8\n"
"-- Записи начинаются в пятницу 08.01.2016 12:21:53 MSK, заканчиваются в "
"четверг 21.01.2016 2016-01-21 21:09:45 MSK. --\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: "
"tarantool@my_app.service: Unit entered failed state.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: "
"tarantool@my_app.service: Failed with result 'exit-code'.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: "
"tarantool@my_app.service: Service hold-off time over, scheduling restart."
"\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Stopped Tarantool "
"Database Server.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Starting Tarantool "
"Database Server...\n"
"Jan 21 21:09:45 localhost.localdomain tarantoolctl[5910]: "
"/usr/bin/tarantoolctl: Found my_app.lua in "
"/etc/tarantool/instances.available\n"
"Jan 21 21:09:45 localhost.localdomain tarantoolctl[5910]: "
"/usr/bin/tarantoolctl: Starting instance...\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Started Tarantool "
"Database Server."

#: ../doc/1.10/book/admin/daemon_supervision.rst:127
msgid "Core dumps"
msgstr "Создание дампов памяти"

#: ../doc/1.10/book/admin/daemon_supervision.rst:129
msgid ""
"Tarantool makes a core dump if it receives any of the following signals: "
"SIGSEGV, SIGFPE, SIGABRT or SIGQUIT. This is automatic if Tarantool "
"crashes."
msgstr ""
"Tarantool создает дамп памяти при получении одного из следующих сигналов:"
" SIGSEGV, SIGFPE, SIGABRT или SIGQUIT. При сбое Tarantool'а дамп "
"создается автоматически."

#: ../doc/1.10/book/admin/daemon_supervision.rst:132
msgid ""
"On ``systemd``-enabled platforms, ``coredumpctl`` automatically saves "
"core dumps and stack traces in case of a crash. Here is a general \"how "
"to\" for how to enable core dumps on a Unix system:"
msgstr ""
"На платформах, где доступна утилита ``systemd``, ``coredumpctl`` "
"автоматически сохраняет дампы памяти и трассировку стека при аварийном "
"завершении Tarantool-сервера. Вот как включить создание дампов памяти в "
"Unix-системе:"

#: ../doc/1.10/book/admin/daemon_supervision.rst:136
msgid ""
"Ensure session limits are configured to enable core dumps, i.e. say "
"``ulimit -c unlimited``. Check  \"man 5 core\" for other reasons why a "
"core dump may not be produced."
msgstr ""
"Убедитесь, что лимиты для сессии установлены таким образом, чтобы можно "
"было создавать дампы памяти, -- выполните команду ``ulimit -c "
"unlimited``.  Также проверьте \"man 5 core\" на другие причины, по "
"которым дамп памяти  может не создаваться."

#: ../doc/1.10/book/admin/daemon_supervision.rst:140
msgid ""
"Set a directory for writing core dumps to, and make sure that the "
"directory is writable. On Linux, the directory path is set in a kernel "
"parameter configurable via ``/proc/sys/kernel/core_pattern``."
msgstr ""
"Создайте директорию для записи дампов памяти и убедитесь, что в эту "
"директорию действительно можно производить запись. На Linux путь до "
"директории задается в параметре ядра, который настраивается через "
"``/proc/sys/kernel/core_pattern``."

#: ../doc/1.10/book/admin/daemon_supervision.rst:144
msgid ""
"Make sure that core dumps include stack trace information. If you use a "
"binary Tarantool distribution, this is automatic. If you build Tarantool "
"from source, you will not get detailed information if you pass "
"``-DCMAKE_BUILD_TYPE=Release`` to CMake."
msgstr ""
"Убедитесь, что дампы памяти включают трассировку стека. При использовании"
"  бинарного дистрибутива Tarantool'а эта информация включается "
"автоматически. При сборке Tarantool'а из исходников, если передать CMake "
"флаг ``-DCMAKE_BUILD_TYPE=Release``, вы не получите подробной информации."

#: ../doc/1.10/book/admin/daemon_supervision.rst:149
msgid ""
"To simulate a crash, you can execute an illegal command against a "
"Tarantool instance:"
msgstr ""
"Для симуляции сбоя можно попытаться выполнить нелегальную команду на "
"работающем экземпляре Tarantool'а:"

#: ../doc/1.10/book/admin/daemon_supervision.rst:152
msgid ""
"$ # !!! please never do this on a production system !!!\n"
"$ tarantoolctl enter my_app\n"
"unix/:/var/run/tarantool/my_app.control> require('ffi').cast('char *', "
"0)[0] = 48\n"
"/bin/tarantoolctl: unix/:/var/run/tarantool/my_app.control: Remote host "
"closed connection"
msgstr ""
"$ # !!! пожалуйста, никогда не делайте этого на боевом сервере !!!\n"
"$ tarantoolctl enter my_app\n"
"unix/:/var/run/tarantool/my_app.control> require('ffi').cast('char *', "
"0)[0] = 48\n"
"/bin/tarantoolctl: unix/:/var/run/tarantool/my_app.control: Remote host "
"closed connection"

#: ../doc/1.10/book/admin/daemon_supervision.rst:159
msgid ""
"Alternatively, if you know the process ID of the instance (here we refer "
"to it as $PID), you can abort a Tarantool instance by running ``gdb`` "
"debugger:"
msgstr ""
"Есть другой способ: если вы знаете PID экземпляра ($PID в нашем примере),"
"  можно остановить этот экземпляр, запустив отладчик ``gdb``:"

#: ../doc/1.10/book/admin/daemon_supervision.rst:162
msgid "$ gdb -batch -ex \"generate-core-file\" -p $PID"
msgstr "$ gdb -batch -ex \"generate-core-file\" -p $PID"

#: ../doc/1.10/book/admin/daemon_supervision.rst:166
msgid "or manually sending a SIGABRT signal:"
msgstr "или послав вручную сигнал SIGABRT:"

#: ../doc/1.10/book/admin/daemon_supervision.rst:168
msgid "$ kill -SIGABRT $PID"
msgstr "$ kill -SIGABRT $PID"

#: ../doc/1.10/book/admin/daemon_supervision.rst:174
msgid "To find out the process id of the instance ($PID), you can:"
msgstr "Чтобы узнать PID экземпляра, можно:"

#: ../doc/1.10/book/admin/daemon_supervision.rst:176
msgid ""
"look it up in the instance's :ref:`box.info.pid <box_introspection-"
"box_info>`,"
msgstr "посмотреть его с помощью :ref:`box.info.pid <box_introspection-box_info>`,"

#: ../doc/1.10/book/admin/daemon_supervision.rst:178
msgid "find it with ``ps -A | grep tarantool``, or"
msgstr "использовать команду ``ps -A | grep tarantool``, или"

#: ../doc/1.10/book/admin/daemon_supervision.rst:180
msgid "say ``systemctl status tarantool@my_app|grep PID``."
msgstr "выполнить ``systemctl status tarantool@my_app|grep PID``."

#: ../doc/1.10/book/admin/daemon_supervision.rst:182
msgid ""
"On a ``systemd-enabled`` system, to see the latest crashes of the "
"Tarantool daemon, say:"
msgstr ""
"Чтобы посмотреть на последние сбои Tarantool-демона на платформах, где "
"доступна утилита ``systemd``, выполните команду:"

#: ../doc/1.10/book/admin/daemon_supervision.rst:185
msgid ""
"$ coredumpctl list /usr/bin/tarantool\n"
"MTIME                            PID   UID   GID SIG PRESENT EXE\n"
"Sat 2016-01-23 15:21:24 MSK   20681  1000  1000   6   /usr/bin/tarantool\n"
"Sat 2016-01-23 15:51:56 MSK   21035   995   992   6   /usr/bin/tarantool"
msgstr ""
"$ coredumpctl list /usr/bin/tarantool\n"
"MTIME                            PID   UID   GID SIG PRESENT EXE\n"
"Sat 2016-01-23 15:21:24 MSK   20681  1000  1000   6   /usr/bin/tarantool\n"
"Sat 2016-01-23 15:51:56 MSK   21035   995   992   6   /usr/bin/tarantool"

#: ../doc/1.10/book/admin/daemon_supervision.rst:192
msgid "To save a core dump into a file, say:"
msgstr "Чтобы сохранить дамп памяти в файл, выполните команду:"

#: ../doc/1.10/book/admin/daemon_supervision.rst:194
msgid "$ coredumpctl -o filename.core info <pid>"
msgstr "$ coredumpctl -o filename.core info <pid>"

#: ../doc/1.10/book/admin/daemon_supervision.rst:202
msgid "Stack traces"
msgstr "Трассировка стека"

#: ../doc/1.10/book/admin/daemon_supervision.rst:204
msgid ""
"Since Tarantool stores tuples in memory, core files may be large. For "
"investigation, you normally don't need the whole file, but only a \"stack"
" trace\" or \"backtrace\"."
msgstr ""
"Так как Tarantool хранит кортежи в памяти, файлы с дампами памяти могут "
"быть довольно большими. Чтобы найти проблему, обычно целый файл не нужен "
"-- достаточно только \"трассировки стека\" или \"обратной трассировки\"."

#: ../doc/1.10/book/admin/daemon_supervision.rst:208
msgid "To save a stack trace into a file, say:"
msgstr "Чтобы сохранить трассировку стека в файл, выполните команду:"

#: ../doc/1.10/book/admin/daemon_supervision.rst:210
msgid ""
"$ gdb -se \"tarantool\" -ex \"bt full\" -ex \"thread apply all bt\" "
"--batch -c core> /tmp/tarantool_trace.txt"
msgstr ""
"$ gdb -se \"tarantool\" -ex \"bt full\" -ex \"thread apply all bt\" "
"--batch -c core> /tmp/tarantool_trace.txt"

#: ../doc/1.10/book/admin/daemon_supervision.rst:214
#: ../doc/1.10/book/admin/instance_config.rst:153
#: ../doc/1.10/book/replication/repl_bootstrap.rst:73
#: ../doc/1.10/dev_guide/developer_guidelines.rst:194
#: ../doc/1.10/reference/tarantoolctl.rst:58
msgid "where:"
msgstr "где:"

#: ../doc/1.10/book/admin/daemon_supervision.rst:216
msgid "\"tarantool\" is the path to the Tarantool executable,"
msgstr "\"tarantool\" -- это путь до исполняемого файла Tarantool'а,"

#: ../doc/1.10/book/admin/daemon_supervision.rst:217
msgid "\"core\" is the path to the core file, and"
msgstr "\"core\" -- это путь до файла с дампом памяти, и"

#: ../doc/1.10/book/admin/daemon_supervision.rst:218
msgid ""
"\"/tmp/tarantool_trace.txt\" is a sample path to a file for saving the "
"stack trace."
msgstr ""
"\"/tmp/tarantool_trace.txt\" -- это пример пути до файла, в который "
"сохраняется трассировка стека."

#: ../doc/1.10/book/admin/daemon_supervision.rst:222
msgid ""
"Occasionally, you may find that the trace file contains output without "
"debug symbols – the lines will contain ”??” instead of names. If this "
"happens, check the instructions on these Tarantool wiki pages: `How to "
"debug core dump of stripped tarantool "
"<https://github.com/tarantool/tarantool/wiki/How-to-debug-core-dump-of-"
"stripped-tarantool>`_ and `How to debug core from different OS "
"<https://github.com/tarantool/tarantool/wiki/How-to-debug-core-from-"
"different-OS>`_."
msgstr ""
"Иногда может оказаться, что файл с трассировкой стека не содержит "
"отладочных символов -- в таких строках вместо имени будет стоять ”??”. "
"Если это произошло, ознакомьтесь с инструкциями на этих двух "
"wiki-страницах Tarantool'а: `How to debug core dump of stripped tarantool"
"  <https://github.com/tarantool/tarantool/wiki/How-to-debug-core-dump-of-"
" stripped-tarantool>`_ и `How to debug core from different OS "
"<https://github.com/tarantool/tarantool/wiki/How-to-debug-core-from- "
"different-OS>`_."

#: ../doc/1.10/book/admin/daemon_supervision.rst:229
msgid "To see the stack trace and other useful information in console, say:"
msgstr ""
"Чтобы получить трассировку стека и прочую полезную информацию в консоли, "
"выполните команду:"

#: ../doc/1.10/book/admin/daemon_supervision.rst:231
msgid ""
"$ coredumpctl info 21035\n"
"          PID: 21035 (tarantool)\n"
"          UID: 995 (tarantool)\n"
"          GID: 992 (tarantool)\n"
"       Signal: 6 (ABRT)\n"
"    Timestamp: Sat 2016-01-23 15:51:42 MSK (4h 36min ago)\n"
" Command Line: tarantool my_app.lua <running>\n"
"   Executable: /usr/bin/tarantool\n"
"Control Group: /system.slice/system-"
"tarantool.slice/tarantool@my_app.service\n"
"         Unit: tarantool@my_app.service\n"
"        Slice: system-tarantool.slice\n"
"      Boot ID: 7c686e2ef4dc4e3ea59122757e3067e2\n"
"   Machine ID: a4a878729c654c7093dc6693f6a8e5ee\n"
"     Hostname: localhost.localdomain\n"
"      Message: Process 21035 (tarantool) of user 995 dumped core.\n"
"\n"
"               Stack trace of thread 21035:\n"
"               #0  0x00007f84993aa618 raise (libc.so.6)\n"
"               #1  0x00007f84993ac21a abort (libc.so.6)\n"
"               #2  0x0000560d0a9e9233 _ZL12sig_fatal_cbi (tarantool)\n"
"               #3  0x00007f849a211220 __restore_rt (libpthread.so.0)\n"
"               #4  0x0000560d0aaa5d9d lj_cconv_ct_ct (tarantool)\n"
"               #5  0x0000560d0aaa687f lj_cconv_ct_tv (tarantool)\n"
"               #6  0x0000560d0aaabe33 lj_cf_ffi_meta___newindex "
"(tarantool)\n"
"               #7  0x0000560d0aaae2f7 lj_BC_FUNCC (tarantool)\n"
"               #8  0x0000560d0aa9aabd lua_pcall (tarantool)\n"
"               #9  0x0000560d0aa71400 lbox_call (tarantool)\n"
"               #10 0x0000560d0aa6ce36 lua_fiber_run_f (tarantool)\n"
"               #11 0x0000560d0a9e8d0c "
"_ZL16fiber_cxx_invokePFiP13__va_list_tagES0_ (tarantool)\n"
"               #12 0x0000560d0aa7b255 fiber_loop (tarantool)\n"
"               #13 0x0000560d0ab38ed1 coro_init (tarantool)\n"
"               ..."
msgstr ""
"$ coredumpctl info 21035\n"
"          PID: 21035 (tarantool)\n"
"          UID: 995 (tarantool)\n"
"          GID: 992 (tarantool)\n"
"       Signal: 6 (ABRT)\n"
"    Timestamp: Sat 2016-01-23 15:51:42 MSK (4h 36min ago)\n"
" Command Line: tarantool my_app.lua <running>\n"
"   Executable: /usr/bin/tarantool\n"
"Control Group: /system.slice/system-"
"tarantool.slice/tarantool@my_app.service\n"
"         Unit: tarantool@my_app.service\n"
"        Slice: system-tarantool.slice\n"
"      Boot ID: 7c686e2ef4dc4e3ea59122757e3067e2\n"
"   Machine ID: a4a878729c654c7093dc6693f6a8e5ee\n"
"     Hostname: localhost.localdomain\n"
"      Message: Process 21035 (tarantool) of user 995 dumped core.\n"
"\n"
"               Stack trace of thread 21035:\n"
"               #0  0x00007f84993aa618 raise (libc.so.6)\n"
"               #1  0x00007f84993ac21a abort (libc.so.6)\n"
"               #2  0x0000560d0a9e9233 _ZL12sig_fatal_cbi (tarantool)\n"
"               #3  0x00007f849a211220 __restore_rt (libpthread.so.0)\n"
"               #4  0x0000560d0aaa5d9d lj_cconv_ct_ct (tarantool)\n"
"               #5  0x0000560d0aaa687f lj_cconv_ct_tv (tarantool)\n"
"               #6  0x0000560d0aaabe33 lj_cf_ffi_meta___newindex "
"(tarantool)\n"
"               #7  0x0000560d0aaae2f7 lj_BC_FUNCC (tarantool)\n"
"               #8  0x0000560d0aa9aabd lua_pcall (tarantool)\n"
"               #9  0x0000560d0aa71400 lbox_call (tarantool)\n"
"               #10 0x0000560d0aa6ce36 lua_fiber_run_f (tarantool)\n"
"               #11 0x0000560d0a9e8d0c "
"_ZL16fiber_cxx_invokePFiP13__va_list_tagES0_ (tarantool)\n"
"               #12 0x0000560d0aa7b255 fiber_loop (tarantool)\n"
"               #13 0x0000560d0ab38ed1 coro_init (tarantool)\n"
"               ..."

#: ../doc/1.10/book/admin/daemon_supervision.rst:270
msgid "Debugger"
msgstr "Отладчик"

#: ../doc/1.10/book/admin/daemon_supervision.rst:272
msgid "To start ``gdb`` debugger on the core dump, say:"
msgstr "Для запуска отладчика ``gdb``, выполните команду:"

#: ../doc/1.10/book/admin/daemon_supervision.rst:274
msgid "$ coredumpctl gdb <pid>"
msgstr "$ coredumpctl gdb <pid>"

#: ../doc/1.10/book/admin/daemon_supervision.rst:278
msgid ""
"It is highly recommended to install ``tarantool-debuginfo`` package to "
"improve ``gdb`` experience, for example:"
msgstr ""
"Мы очень рекомендуем установить пакет ``tarantool-debuginfo``, чтобы "
"сделать отладку средствами ``gdb`` более эффективной. Например:"

#: ../doc/1.10/book/admin/daemon_supervision.rst:281
msgid "$ dnf debuginfo-install tarantool"
msgstr "$ dnf debuginfo-install tarantool"

#: ../doc/1.10/book/admin/daemon_supervision.rst:285
msgid ""
"``gdb`` also provides information about the debuginfo packages you need "
"to install:"
msgstr ""
"С помощью ``gdb`` можно узнать, какие еще ``debuginfo``-пакеты нужно "
"установить:"

#: ../doc/1.10/book/admin/daemon_supervision.rst:288
msgid ""
"$ gdb -p <pid>\n"
"...\n"
"Missing separate debuginfos, use: dnf debuginfo-install\n"
"glibc-2.22.90-26.fc24.x86_64 krb5-libs-1.14-12.fc24.x86_64\n"
"libgcc-5.3.1-3.fc24.x86_64 libgomp-5.3.1-3.fc24.x86_64\n"
"libselinux-2.4-6.fc24.x86_64 libstdc++-5.3.1-3.fc24.x86_64\n"
"libyaml-0.1.6-7.fc23.x86_64 ncurses-libs-6.0-1.20150810.fc24.x86_64\n"
"openssl-libs-1.0.2e-3.fc24.x86_64"
msgstr ""
"$ gdb -p <pid>\n"
"...\n"
"Missing separate debuginfos, use: dnf debuginfo-install\n"
"glibc-2.22.90-26.fc24.x86_64 krb5-libs-1.14-12.fc24.x86_64\n"
"libgcc-5.3.1-3.fc24.x86_64 libgomp-5.3.1-3.fc24.x86_64\n"
"libselinux-2.4-6.fc24.x86_64 libstdc++-5.3.1-3.fc24.x86_64\n"
"libyaml-0.1.6-7.fc23.x86_64 ncurses-libs-6.0-1.20150810.fc24.x86_64\n"
"openssl-libs-1.0.2e-3.fc24.x86_64"

#: ../doc/1.10/book/admin/daemon_supervision.rst:299
msgid ""
"Symbolic names are present in stack traces even if you don’t have "
"``tarantool-debuginfo`` package installed."
msgstr ""
"В трассировке стека присутствуют символические имена, даже если у вас не "
"установлен пакет ``tarantool-debuginfo``."

#: ../doc/1.10/book/admin/disaster_recovery.rst:39
msgid "Disaster recovery"
msgstr "Аварийное восстановление"

#: ../doc/1.10/book/admin/disaster_recovery.rst:41
msgid ""
"The minimal fault-tolerant Tarantool configuration would be a "
":ref:`replication cluster<replication-topologies>` that includes a master"
" and a replica, or two masters."
msgstr ""
"Минимальная отказоустойчивая конфигурация Tarantool'а -- это "
":ref:`репликационный кластер <replication-topologies>`, содержащий мастер"
" и реплику или два мастера."

#: ../doc/1.10/book/admin/disaster_recovery.rst:45
msgid ""
"The basic recommendation is to configure all Tarantool instances in a "
"cluster to create :ref:`snapshot files <index-box_persistence>` at a "
"regular basis."
msgstr ""
"Основная рекомендация -- настраивать все экземпляры Tarantool'а в "
"кластере  таким образом, чтобы они регулярно создавали :ref:`файлы-снимки"
" <index-box_persistence>`."

#: ../doc/1.10/book/admin/disaster_recovery.rst:48
msgid "Here follow action plans for typical crash scenarios."
msgstr "Ниже дано несколько инструкций для типовых аварийных сценариев."

#: ../doc/1.10/book/admin/disaster_recovery.rst:54
msgid "Master-replica"
msgstr "Мастер-реплика"

#: ../doc/1.10/book/admin/disaster_recovery.rst:56
msgid "Configuration: One master and one replica."
msgstr "Конфигурация: один мастер и одна реплика."

#: ../doc/1.10/book/admin/disaster_recovery.rst:58
msgid "Problem: The master has crashed."
msgstr "Проблема: мастер вышел из строя."

#: ../doc/1.10/book/admin/disaster_recovery.rst:60
#: ../doc/1.10/book/admin/disaster_recovery.rst:127
msgid "Your actions:"
msgstr "План действий:"

#: ../doc/1.10/book/admin/disaster_recovery.rst:62
msgid ""
"Ensure the master is stopped for good. For example, log in to the master "
"machine and use ``systemctl stop tarantool@<instance_name>``."
msgstr ""
"Убедитесь, что мастер полностью остановлен. Например, подключитесь к "
"мастеру и используйте команду ``systemctl stop "
"tarantool@<имя_экземпляра>``."

#: ../doc/1.10/book/admin/disaster_recovery.rst:65
msgid ""
"Switch the replica to master mode by setting :ref:`box.cfg.read_only "
"<cfg_basic-read_only>` parameter to *false* and let the load be handled "
"by the replica (effective master)."
msgstr ""
"Переключите реплику в режим мастера, установив параметру "
":ref:`box.cfg.read_only <cfg_basic-read_only>` значение *false*. Теперь "
"вся нагрузка пойдет только на реплику (по сути ставшую мастером)."

#: ../doc/1.10/book/admin/disaster_recovery.rst:69
msgid ""
"Set up a replacement for the crashed master on a spare host, with "
":ref:`replication <cfg_replication-replication>` parameter set to replica"
" (effective master), so it begins to catch up with the new master’s "
"state. The new instance should have :ref:`box.cfg.read_only <cfg_basic-"
"read_only>` parameter set to *true*."
msgstr ""
"Настройте на свободной машине замену вышедшему из строя мастеру, "
"установив параметру :ref:`replication <cfg_replication-replication>` в "
"качестве значения URI реплики (которая в данный момент выполняет роль "
"мастера), чтобы новая реплика начала синхронизироваться с текущим "
"мастером. Значение параметра :ref:`box.cfg.read_only <cfg_basic-"
"read_only>` в новом экземпляре должно быть установлено на *true*."

#: ../doc/1.10/book/admin/disaster_recovery.rst:75
msgid ""
"You lose the few transactions in the master :ref:`write ahead log file "
"<index-box_persistence>`, which it may have not transferred to the "
"replica before crash. If you were able to salvage the master .xlog file, "
"you may be able to recover these. In order to do it:"
msgstr ""
"Все немногочисленные транзакции в :ref:`WAL-файле <index-"
"box_persistence>` мастера, которые он не успел передать реплике до выхода"
"  из строя, будут потеряны. Однако если удастся получить .xlog-файл "
"мастера, их можно будет восстановить. Для этого:"

#: ../doc/1.10/book/admin/disaster_recovery.rst:80
msgid ""
"Find out the position of the crashed master, as reflected on the new "
"master."
msgstr ""
"Узнайте позицию вышедшего из строя мастера -- эта информация доступна из "
"нового мастера."

#: ../doc/1.10/book/admin/disaster_recovery.rst:82
msgid ""
"Find out instance UUID from the crashed master :ref:`xlog <internals-"
"wal>`:"
msgstr ""
"Посмотрите UUID экземпляра в :ref:`xlog-файле <internals-wal>` вышедшего "
"из строя мастера:"

#: ../doc/1.10/book/admin/disaster_recovery.rst:84
msgid ""
"$ head -5 *.xlog | grep Instance\n"
"Instance: ed607cad-8b6d-48d8-ba0b-dae371b79155"
msgstr ""
"$ head -5 *.xlog | grep Instance\n"
"Instance: ed607cad-8b6d-48d8-ba0b-dae371b79155"

#: ../doc/1.10/book/admin/disaster_recovery.rst:89
msgid "On the new master, use the UUID to find the position:"
msgstr "Используйте этот UUID на новом мастере для поиска позиции:"

#: ../doc/1.10/book/admin/disaster_recovery.rst:91
msgid ""
"tarantool> box.info.vclock[box.space._cluster.index.uuid:select"
"{'ed607cad-8b6d-48d8-ba0b-dae371b79155'}[1][1]]\n"
"---\n"
"- 23425\n"
"<...>"
msgstr ""
"tarantool> box.info.vclock[box.space._cluster.index.uuid:select"
"{'ed607cad-8b6d-48d8-ba0b-dae371b79155'}[1][1]]\n"
"---\n"
"- 23425\n"
"<...>"

#: ../doc/1.10/book/admin/disaster_recovery.rst:98
msgid ""
"Play the records from the crashed .xlog to the new master, starting from "
"the new master position:"
msgstr ""
"Запишите транзакции из .xlog-файла вышедшего из строя мастера в новый "
"мастер, начиная с позиции нового мастера:"

#: ../doc/1.10/book/admin/disaster_recovery.rst:101
msgid ""
"Issue this request locally at the new master's machine to find out "
"instance ID of the new master:"
msgstr ""
"Локально выполните эту команду на новом мастере, чтобы узнать его ID "
"экземпляра:"

#: ../doc/1.10/book/admin/disaster_recovery.rst:104
#: ../doc/1.10/book/replication/repl_architecture.rst:126
msgid ""
"tarantool> box.space._cluster:select{}\n"
"---\n"
"- - [1, '88580b5c-4474-43ab-bd2b-2409a9af80d2']\n"
"..."
msgstr ""
"tarantool> box.space._cluster:select{}\n"
"---\n"
"- - [1, '88580b5c-4474-43ab-bd2b-2409a9af80d2']\n"
"..."

#: ../doc/1.10/book/admin/disaster_recovery.rst:111
msgid "Play the records to the new master:"
msgstr "Запишите транзакции в новый мастер:"

#: ../doc/1.10/book/admin/disaster_recovery.rst:113
msgid "$ tarantoolctl <new_master_uri> <xlog_file> play --from 23425 --replica 1"
msgstr ""
"$ tarantoolctl <uri_нового_мастера> <xlog_файл> play --from 23425 "
"--replica 1"

#: ../doc/1.10/book/admin/disaster_recovery.rst:121
msgid "Master-master"
msgstr "Мастер-мастер"

#: ../doc/1.10/book/admin/disaster_recovery.rst:123
msgid "Configuration: Two masters."
msgstr "Конфигурация: два мастера."

#: ../doc/1.10/book/admin/disaster_recovery.rst:125
msgid "Problem: Master#1 has crashed."
msgstr "Проблема: мастер #1 вышел из строя."

#: ../doc/1.10/book/admin/disaster_recovery.rst:129
msgid "Let the load be handled by master#2 (effective master) alone."
msgstr "Пусть вся нагрузка идет только на мастер #2 (действующий мастер)."

#: ../doc/1.10/book/admin/disaster_recovery.rst:131
msgid ""
"2. Follow the same steps as in the :ref:`master-replica <admin-"
"disaster_recovery-master_replica>` recovery scenario to create a new "
"master and salvage lost data."
msgstr ""
"2. Создайте новый мастер и восстановите данные, проделав те же шаги, что "
"и в сценарии для конфигурации :ref:`мастер-реплика <admin-"
"disaster_recovery-master_replica>`."

#: ../doc/1.10/book/admin/disaster_recovery.rst:139
msgid "Data loss"
msgstr "Потеря данных"

#: ../doc/1.10/book/admin/disaster_recovery.rst:141
msgid "Configuration: Master-master or master-replica."
msgstr "Конфигурация: мастер-мастер или мастер-реплика."

#: ../doc/1.10/book/admin/disaster_recovery.rst:143
msgid ""
"Problem: Data was deleted at one master and this data loss was propagated"
" to the other node (master or replica)."
msgstr ""
"Проблема: данные были удалены на одном мастере, а затем эти изменения "
"реплицировались на другом узле (мастере или реплике)."

#: ../doc/1.10/book/admin/disaster_recovery.rst:146
msgid ""
"The following steps are applicable only to data in memtx storage engine. "
"Your actions:"
msgstr ""
"Эта инструкция применима только для данных, хранящихся на движке memtx. "
"План действий:"

#: ../doc/1.10/book/admin/disaster_recovery.rst:149
msgid ""
"Put all nodes in :ref:`read-only mode <cfg_basic-read_only>` and disable "
"checkpointing with :ref:`box.backup.start() <admin-backups-"
"backup_start>`. Disabling the checkpointing is necessary to prevent the "
"Tarantool garbage collector from removing files made with older "
"checkpoints."
msgstr ""
"Переключите все узлы в :ref:`режим только для чтения <cfg_basic-"
"read_only>` и отключите командой :ref:`box.backup.start() <admin-backups-"
"backup_start>` создание контрольных точек. Последнее действие необходимо,"
" чтобы сборщик мусора автоматически не удалил более старые контрольные "
"точки."

#: ../doc/1.10/book/admin/disaster_recovery.rst:155
msgid ""
"Get the latest valid :ref:`.snap file <internals-snapshot>` and use "
"``tarantoolctl cat`` command to calculate at which lsn the data loss "
"occurred."
msgstr ""
"Возьмите последний корректный :ref:`.snap-файл <internals-snapshot>` и, "
"используя команду ``tarantoolctl cat``, выясните, на каком именно lsn "
"произошла потеря данных."

#: ../doc/1.10/book/admin/disaster_recovery.rst:158
msgid ""
"Start a new instance (instance#1) and use ``tarantoolctl play`` command "
"to play to it the contents of .snap/.xlog files up to the calculated lsn."
msgstr ""
"Запустите новый экземпляр (экземпляр #1) и с помощью команды "
"``tarantoolctl play`` скопируйте в него содержимое .snap/.xlog-файлов "
"вплоть до вычисленного lsn."

#: ../doc/1.10/book/admin/disaster_recovery.rst:161
msgid "Bootstrap a new replica from the recovered master (instance#1)."
msgstr ""
"Настройте новую реплику с помощью восстановленного мастера (экземпляра "
"#1)."

#: ../doc/1.10/book/admin/index.rst:39
msgid "Server administration"
msgstr "Администрирование серверной части"

#: ../doc/1.10/book/admin/index.rst:41
msgid "Tarantool is designed to have multiple running instances on the same host."
msgstr ""
"Tarantool устроен таким образом, что возможно запустить несколько "
"экземпляров программы на одном компьютере."

#: ../doc/1.10/book/admin/index.rst:43
msgid ""
"Here we show how to administer Tarantool instances using any of the "
"following utilities:"
msgstr ""
"Здесь мы показываем, как администрировать экземпляры Tarantool’а с "
"помощью любой из следующих утилит:"

#: ../doc/1.10/book/admin/index.rst:46
msgid "``systemd`` native utilities, or"
msgstr "встроенные утилиты ``systemd`` или"

#: ../doc/1.10/book/admin/index.rst:47
msgid ""
":ref:`tarantoolctl <tarantoolctl>`, a utility shipped and installed as "
"part of Tarantool distribution."
msgstr ""
":ref:`tarantoolctl <tarantoolctl>`, утилита, поставляемая и "
"устанавливаемая вместе с дистрибутивом Tarantool’а."

#: ../doc/1.10/book/admin/index.rst:52
msgid "Unlike the rest of this manual, here we use system-wide paths."
msgstr ""
"В отличие от остальной части руководства, в этой главе мы используем "
"общесистемные пути."

#: ../doc/1.10/book/admin/index.rst:53
msgid "Console examples here are for Fedora."
msgstr "Здесь мы приводим примеры консольного вывода для Fedora."

#: ../doc/1.10/book/admin/index.rst:55
#: ../doc/1.10/book/replication/index.rst:45
msgid "This chapter includes the following sections:"
msgstr "Эта глава включает в себя следующие разделы:"

#: ../doc/1.10/book/admin/instance_config.rst:39
msgid "Instance configuration"
msgstr "Настройка экземпляров Tarantool’а"

#: ../doc/1.10/book/admin/instance_config.rst:41
msgid "For each Tarantool instance, you need two files:"
msgstr "Для каждого экземпляра Tarantool’а понадобится два файла:"

#: ../doc/1.10/book/admin/instance_config.rst:43
msgid ""
"[Optional] An :ref:`application file <app_server-launching_app>` with "
"instance-specific logic. Put this file into the ``/usr/share/tarantool/``"
" directory."
msgstr ""
"[Необязательный] :ref:`Файл приложения <app_server-launching_app>`, "
"содержащий логику данного экземпляра. Поместите его в папку "
"``/usr/share/tarantool/``."

#: ../doc/1.10/book/admin/instance_config.rst:47
msgid ""
"For example, ``/usr/share/tarantool/my_app.lua`` (here we implement it as"
" a :ref:`Lua module <app_server-modules>` that bootstraps the database "
"and exports ``start()`` function for API calls):"
msgstr ""
"Например, ``/usr/share/tarantool/my_app.lua`` (здесь мы реализуем его как"
"  :ref:`Lua-модуль <app_server-modules>`, который запускает базу данных и"
" экспортирует функцию ``start()`` для API -вызовов):"

#: ../doc/1.10/book/admin/instance_config.rst:51
msgid ""
"local function start()\n"
"    box.schema.space.create(\"somedata\")\n"
"    box.space.somedata:create_index(\"primary\")\n"
"    <...>\n"
"end\n"
"\n"
"return {\n"
"  start = start;\n"
"}"
msgstr ""
"local function start()\n"
"    box.schema.space.create(\"somedata\")\n"
"    box.space.somedata:create_index(\"primary\")\n"
"    <...>\n"
"end\n"
"\n"
"return {\n"
"  start = start;\n"
"}"

#: ../doc/1.10/book/admin/instance_config.rst:63
msgid ""
"An :ref:`instance file <admin-instance_file>` with instance-specific "
"initialization logic and parameters. Put this file, or a symlink to it, "
"into the **instance directory** (see :ref:`instance_dir <admin-"
"instance_dir>` parameter in ``tarantoolctl`` configuration file)."
msgstr ""
":ref:`Файл экземпляра <admin-instance_file>`, содержащий логику и "
"параметры инициализации данного экземпляра. Поместите этот файл или "
"символьную ссылку на него в **директорию экземпляра** (см. параметр "
":ref:`instance_dir <admin-instance_dir>` в конфигурационном файле "
"``tarantoolctl``)."

#: ../doc/1.10/book/admin/instance_config.rst:69
msgid ""
"For example, ``/etc/tarantool/instances.enabled/my_app.lua`` (here we "
"load ``my_app.lua`` module and make a call to ``start()`` function from "
"that module):"
msgstr ""
"Например, ``/etc/tarantool/instances.enabled/my_app.lua`` (здесь мы "
"загружаем модуль ``my_app.lua`` и вызываем из него функцию ``start()``):"

#: ../doc/1.10/book/admin/instance_config.rst:73
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"box.cfg {\n"
"    listen = 3301;\n"
"}\n"
"\n"
"-- load my_app module and call start() function\n"
"-- with some app options controlled by sysadmins\n"
"local m = require('my_app').start({...})"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"box.cfg {\n"
"    listen = 3301;\n"
"}\n"
"\n"
"-- загрузить модуль my_app и вызвать функцию start()\n"
"-- некоторые опции приложения под контролем сисадминов\n"
"local m = require('my_app').start({...})"

#: ../doc/1.10/book/admin/instance_config.rst:89
msgid "Instance file"
msgstr "Файл экземпляра"

#: ../doc/1.10/book/admin/instance_config.rst:91
msgid ""
"After this short introduction, you may wonder what an instance file is, "
"what it is for, and how ``tarantoolctl`` uses it. After all, Tarantool is"
" an application server, so why not start the application stored in "
"``/usr/share/tarantool`` directly?"
msgstr ""
"После столь краткого предисловия может возникнуть вопрос: что из себя "
"представляет файл экземпляра, для чего он нужен и как ``tarantoolctl`` "
"использует его? Если Tarantool -- это сервер приложений, так почему бы не"
" запускать хранящееся в ``/usr/share/tarantool`` приложение напрямую?"

#: ../doc/1.10/book/admin/instance_config.rst:96
msgid ""
"A typical Tarantool application is not a script, but a daemon running in "
"background mode and processing requests, usually sent to it over a TCP/IP"
" socket. This daemon needs to be started automatically when the operating"
" system starts, and managed with the operating system standard tools for "
"service management -- such as ``systemd`` or ``init.d``. To serve this "
"very purpose, we created **instance files**."
msgstr ""
"Типичное приложение для Tarantool -- это не скрипт, а демон, запущенный в"
" фоновом режиме и обрабатывающий запросы, которые, как правило, "
"посылаются  через TCP/IP-сокет. Необходимо запускать этот демон со "
"стартом операционной системы и управлять им с помощью стандартных средств"
" операционной системы для управления сервисами -- таких как ``systemd`` "
"или ``init.d``. С этой целью и были созданы **файлы экземпляра**."

#: ../doc/1.10/book/admin/instance_config.rst:103
msgid ""
"You can have more than one instance file. For example, a single "
"application in ``/usr/share/tarantool`` can run in multiple instances, "
"each of them having its own instance file. Or you can have multiple "
"applications in ``/usr/share/tarantool`` -- again, each of them having "
"its own instance file."
msgstr ""
"Файлов экземпляра может быть больше одного. Например, одно и то же "
"приложение в ``/usr/share/tarantool`` может быть запущено на нескольких "
"экземплярах Tarantool'а, у каждого из которых есть свой файл экземпляра. "
"Или в ``/usr/share/tarantool`` может быть несколько приложений, и на "
"каждое из них будет опять же приходиться свой файл экземпляра."

#: ../doc/1.10/book/admin/instance_config.rst:108
msgid ""
"An instance file is typically created by a system administrator. An "
"application file is often provided by a developer, in a Lua rock or an "
"rpm/deb package."
msgstr ""
"Обычно файл экземпляра создает системный администратор, а файл приложения"
"  предоставляет разработчик в Lua-модуле или rpm/deb-пакете."

#: ../doc/1.10/book/admin/instance_config.rst:111
msgid ""
"An instance file is designed to not differ in any way from a Lua "
"application. It must, however, configure the database, i.e. contain a "
"call to :ref:`box.cfg{} <box_introspection-box_cfg>` somewhere in it, "
"because it’s the only way to turn a Tarantool script into a background "
"process, and ``tarantoolctl`` is a tool to manage background processes. "
"Other than that, an instance file may contain arbitrary Lua code, and, in"
" theory, even include the entire application business logic in it. We, "
"however, do not recommend this, since it clutters the instance file and "
"leads to unnecessary copy-paste when you need to run multiple instances "
"of an application."
msgstr ""
"По своему устройству файл экземпляра ничем не отличается от "
"Lua-приложения. Однако с его помощью должна настраиваться база данных, "
"поэтому в нем должен содержаться вызов :ref:`box.cfg{} "
"<box_introspection-box_cfg>`, потому что это единственный способ "
"превратить Tarantool-скрипт в фоновый процесс, а ``tarantoolctl`` -- это "
"инструмент для управления фоновыми процессами. За исключением этого "
"вызова, файл экземпляра может содержать произвольный код на Lua и, "
"теоретически, даже всю бизнес-логику приложения. Однако мы не рекомендуем"
"  хранить весь код в файле экземпляра, потому что это приводит как к "
"замусориванию самого файла, так и к ненужному копированию кода при "
"необходимости запустить несколько экземпляров приложения."

#: ../doc/1.10/book/admin/instance_config.rst:125
msgid "`tarantoolctl` configuration file"
msgstr "Конфигурационный файл `tarantoolctl`"

#: ../doc/1.10/book/admin/instance_config.rst:127
msgid ""
"While instance files contain instance configuration, the ``tarantoolctl``"
" configuration file contains the configuration that ``tarantoolctl`` uses"
" to override instance configuration. In other words, it contains system-"
"wide configuration defaults. If ``tarantoolctl`` fails to find this file "
"with the method described in section :ref:`Starting/stopping an instance "
"<admin-start_stop_instance>`, it uses default settings."
msgstr ""
"Файлы экземпляра содержат конфигурацию экземпляра, тогда как "
"конфигурационный файл ``tarantoolctl`` содержит конфигурацию, которую "
"``tarantoolctl`` использует, чтобы переопределять конфигурацию "
"экземпляров. Другими словами, он содержит общесистемную конфигурацию по "
"умолчанию. Если ``tarantoolctl`` не сможет обнаружить этот файл, "
"используя метод, описанный в разделе :ref:`Запуск/остановка экземпляра "
"<admin-start_stop_instance>`, будут использованы настройки по умолчанию."

#: ../doc/1.10/book/admin/instance_config.rst:135
msgid ""
"Most of the parameters are similar to those used by :ref:`box.cfg{} "
"<box_introspection-box_cfg>`. Here are the default settings (possibly "
"installed in ``/etc/default/tarantool`` or ``/etc/sysconfig/tarantool`` "
"as part of Tarantool distribution -- see OS-specific default paths in "
":ref:`Notes for operating systems <admin-os_notes>`):"
msgstr ""
"Большинство параметров схожи с теми, которые используются в "
":ref:`box.cfg{} <box_introspection-box_cfg>`. Ниже даны настройки по "
"умолчанию (могут быть установлены в ``/etc/default/tarantool`` или "
"``/etc/sysconfig/tarantool`` как часть дистрибутива Tarantool'а -- см. "
"пути по умолчанию для разных ОС в :ref:`Замечаниях по поводу некоторых "
"операционных систем <admin-os_notes>`):"

#: ../doc/1.10/book/admin/instance_config.rst:141
msgid ""
"default_cfg = {\n"
"    pid_file  = \"/var/run/tarantool\",\n"
"    wal_dir   = \"/var/lib/tarantool\",\n"
"    memtx_dir = \"/var/lib/tarantool\",\n"
"    vinyl_dir = \"/var/lib/tarantool\",\n"
"    log       = \"/var/log/tarantool\",\n"
"    username  = \"tarantool\",\n"
"}\n"
"instance_dir = \"/etc/tarantool/instances.enabled\""
msgstr ""
"default_cfg = {\n"
"    pid_file  = \"/var/run/tarantool\",\n"
"    wal_dir   = \"/var/lib/tarantool\",\n"
"    memtx_dir = \"/var/lib/tarantool\",\n"
"    vinyl_dir = \"/var/lib/tarantool\",\n"
"    log       = \"/var/log/tarantool\",\n"
"    username  = \"tarantool\",\n"
"}\n"
"instance_dir = \"/etc/tarantool/instances.enabled\""

#: ../doc/1.10/book/admin/instance_config.rst
msgid "``pid_file``"
msgstr "``pid_file``"

#: ../doc/1.10/book/admin/instance_config.rst
msgid ""
"Directory for the pid file and control-socket file; ``tarantoolctl`` will"
" add “/instance_name” to the directory name."
msgstr ""
"Директория, где хранятся pid-файл и socket-файл; ``tarantoolctl`` "
"добавляет “/имя_экземпляра” к имени директории."

#: ../doc/1.10/book/admin/instance_config.rst
msgid "``wal_dir``"
msgstr "``wal_dir``"

#: ../doc/1.10/book/admin/instance_config.rst
msgid ""
"Directory for write-ahead .xlog files; ``tarantoolctl`` will add "
"\"/instance_name\" to the directory name."
msgstr ""
"Директория, где хранятся .xlog-файлы; ``tarantoolctl`` добавляет "
"“/имя_экземпляра” к имени директории."

#: ../doc/1.10/book/admin/instance_config.rst
msgid "``memtx_dir``"
msgstr "``memtx_dir``"

#: ../doc/1.10/book/admin/instance_config.rst
msgid ""
"Directory for snapshot .snap files; ``tarantoolctl`` will add "
"\"/instance_name\" to the directory name."
msgstr ""
"Директория, где хранятся .snap-файлы; ``tarantoolctl`` добавляет "
"“/имя_экземпляра” к имени директории."

#: ../doc/1.10/book/admin/instance_config.rst
msgid "``vinyl_dir``"
msgstr "``vinyl_dir``"

#: ../doc/1.10/book/admin/instance_config.rst
msgid ""
"Directory for vinyl files; ``tarantoolctl`` will add \"/instance_name\" "
"to the directory name."
msgstr ""
"Директория, где хранятся vinyl-файлы; ``tarantoolctl`` добавляет "
"“/имя_экземпляра” к имени директории."

#: ../doc/1.10/book/admin/instance_config.rst
msgid "``log``"
msgstr "``log``"

#: ../doc/1.10/book/admin/instance_config.rst
msgid ""
"The place where the application log will go; ``tarantoolctl`` will add "
"\"/instance_name.log\" to the name."
msgstr ""
"Директория, где хранятся файлы журнала с сообщениями от "
"Tarantool-приложения; ``tarantoolctl`` добавляет “/имя_экземпляра” к "
"имени директории."

#: ../doc/1.10/book/admin/instance_config.rst
msgid "``username``"
msgstr "``username``"

#: ../doc/1.10/book/admin/instance_config.rst
msgid ""
"The user that runs the Tarantool instance. This is the operating-system "
"user name rather than the Tarantool-client user name. Tarantool will "
"change its effective user to this user after becoming a daemon."
msgstr ""
"Пользователь, запускающий экземпляр Tarantool'а. Это пользователь "
"операционной системы, а не Tarantool-клиента. Став демоном, Tarantool "
"сменит своего пользователя на указанного."

#: ../doc/1.10/book/admin/instance_config.rst
msgid "``instance_dir``"
msgstr "``instance_dir``"

#: ../doc/1.10/book/admin/instance_config.rst
msgid ""
"The directory where all instance files for this host are stored. Put "
"instance files in this directory, or create symbolic links."
msgstr ""
"Директория, где хранятся все файлы экземпляра для данного компьютера. "
"Поместите сюда файлы экземпляра или создайте символьные ссылки на них."

#: ../doc/1.10/book/admin/instance_config.rst:186
msgid ""
"The default instance directory depends on Tarantool's ``WITH_SYSVINIT`` "
"build option: when ON, it is ``/etc/tarantool/instances.enabled``, "
"otherwise (OFF or not set) it is ``/etc/tarantool/instances.available``. "
"The latter case is typical for Tarantool builds for Linux distros with "
"``systemd``."
msgstr ""
"Директория с экземплярами, которая используется по умолчанию, зависит от "
"параметра ``WITH_SYSVINIT`` сборки Tarantool'а: когда его значение "
"\"ON\", то ``/etc/tarantool/instances.enabled``, в противном случае "
"(\"OFF\" или значение не установлено), то "
"``/etc/tarantool/instances.available``. Последний случай характерен для "
"сборок Tarantool'а для дистрибутивов Linux с ``systemd``."

#: ../doc/1.10/book/admin/instance_config.rst:192
msgid "To check the build options, say ``tarantool --version``."
msgstr "Для проверки параметров сборки выполните команду ``tarantool --version``."

#: ../doc/1.10/book/admin/instance_config.rst:194
msgid ""
"As a full-featured example, you can take `example.lua "
"<https://github.com/tarantool/tarantool/blob/1.10/extra/dist/example.lua>`_"
" script that ships with Tarantool and defines all configuration options."
msgstr ""
"В качестве полноценного примера можно использовать скрипт `example.lua "
"<https://github.com/tarantool/tarantool/blob/1.10/extra/dist/example.lua>`_,"
"  который поставляется вместе с Tarantool и задает все конфигурационные "
"параметры."

#: ../doc/1.10/book/admin/logs.rst:39
msgid "Logs"
msgstr "Журналирование"

#: ../doc/1.10/book/admin/logs.rst:41
msgid ""
"Tarantool logs important events to a file, e.g. "
"``/var/log/tarantool/my_app.log``. To build the log file path, "
"``tarantoolctl`` takes the instance name, prepends the instance directory"
" and appends “.log” extension."
msgstr ""
"Все важные события Tarantool записывает в файл журнала -- например, в "
"``/var/log/tarantool/my_app.log``.  ``tarantoolctl`` строит путь до файла"
"  журнала следующим образом: \"путь до директории с экземплярами\" + "
"\"имя  экземпляра\" + \".lua\"."

#: ../doc/1.10/book/admin/logs.rst:45
msgid "Let’s write something to the log file:"
msgstr "Запишем что-нибудь в файл журнала:"

#: ../doc/1.10/book/admin/logs.rst:47
msgid ""
"$ tarantoolctl enter my_app\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/my_app.control\n"
"unix/:/var/run/tarantool/my_app.control> require('log').info(\"Hello for "
"the manual readers\")\n"
"---\n"
"..."
msgstr ""
"$ tarantoolctl enter my_app\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/my_app.control\n"
"unix/:/var/run/tarantool/my_app.control> require('log').info(\"Hello for "
"the manual readers\")\n"
"---\n"
"..."

#: ../doc/1.10/book/admin/logs.rst:55
msgid "Then check the logs:"
msgstr "Затем проверим содержимое журнала:"

#: ../doc/1.10/book/admin/logs.rst:57
msgid ""
"$ tail /var/log/tarantool/my_app.log\n"
"2017-04-04 15:54:04.977 [29255] main/101/tarantoolctl C> version "
"1.7.3-382-g68ef3f6a9\n"
"2017-04-04 15:54:04.977 [29255] main/101/tarantoolctl C> log level 5\n"
"2017-04-04 15:54:04.978 [29255] main/101/tarantoolctl I> mapping "
"134217728 bytes for tuple arena...\n"
"2017-04-04 15:54:04.985 [29255] iproto/101/main I> binary: bound to "
"[::1]:3301\n"
"2017-04-04 15:54:04.986 [29255] main/101/tarantoolctl I> recovery start\n"
"2017-04-04 15:54:04.986 [29255] main/101/tarantoolctl I> recovering from "
"`/var/lib/tarantool/my_app/00000000000000000000.snap'\n"
"2017-04-04 15:54:04.988 [29255] main/101/tarantoolctl I> ready to accept "
"requests\n"
"2017-04-04 15:54:04.988 [29255] main/101/tarantoolctl I> set "
"'checkpoint_interval' configuration option to 3600\n"
"2017-04-04 15:54:04.988 [29255] main/101/my_app I> Run console at "
"unix/:/var/run/tarantool/my_app.control\n"
"2017-04-04 15:54:04.989 [29255] main/106/console/unix/:/var/ I> started\n"
"2017-04-04 15:54:04.989 [29255] main C> entering the event loop\n"
"2017-04-04 15:54:47.147 [29255] main/107/console/unix/: I> Hello for the "
"manual readers"
msgstr ""
"$ tail /var/log/tarantool/my_app.log\n"
"2017-04-04 15:54:04.977 [29255] main/101/tarantoolctl C> version "
"1.7.3-382-g68ef3f6a9\n"
"2017-04-04 15:54:04.977 [29255] main/101/tarantoolctl C> log level 5\n"
"2017-04-04 15:54:04.978 [29255] main/101/tarantoolctl I> mapping "
"134217728 bytes for tuple arena...\n"
"2017-04-04 15:54:04.985 [29255] iproto/101/main I> binary: bound to "
"[::1]:3301\n"
"2017-04-04 15:54:04.986 [29255] main/101/tarantoolctl I> recovery start\n"
"2017-04-04 15:54:04.986 [29255] main/101/tarantoolctl I> recovering from "
"`/var/lib/tarantool/my_app/00000000000000000000.snap'\n"
"2017-04-04 15:54:04.988 [29255] main/101/tarantoolctl I> ready to accept "
"requests\n"
"2017-04-04 15:54:04.988 [29255] main/101/tarantoolctl I> set "
"'checkpoint_interval' configuration option to 3600\n"
"2017-04-04 15:54:04.988 [29255] main/101/my_app I> Run console at "
"unix/:/var/run/tarantool/my_app.control\n"
"2017-04-04 15:54:04.989 [29255] main/106/console/unix/:/var/ I> started\n"
"2017-04-04 15:54:04.989 [29255] main C> entering the event loop\n"
"2017-04-04 15:54:47.147 [29255] main/107/console/unix/: I> Hello for the "
"manual readers"

#: ../doc/1.10/book/admin/logs.rst:73
msgid ""
"When logging to a file, the system administrator must ensure logs are "
"rotated timely and do not take up all the available disk space. With "
"``tarantoolctl``, log rotation is pre-configured to use ``logrotate`` "
"program, which you must have installed."
msgstr ""
"При включенном журналировании системный администратор должен обеспечивать"
"  своевременную ротацию журналов, чтобы избежать переполнения дискового "
"пространства. Ротация журналов в ``tarantoolctl`` производится с помощью "
"программы ``logrotate``, которую необходимо установить заранее."

#: ../doc/1.10/book/admin/logs.rst:78
msgid ""
"File ``/etc/logrotate.d/tarantool`` is part of the standard Tarantool "
"distribution, and you can modify it to change the default behavior. This "
"is what this file is usually like:"
msgstr ""
"Файл ``/etc/logrotate.d/tarantool`` поставляется со стандартным "
"дистрибутивом Tarantool. Его можно редактировать для изменения поведения "
"по умолчанию. Содержимое файла обычно выглядит так:"

#: ../doc/1.10/book/admin/logs.rst:82
#, python-format
msgid ""
"/var/log/tarantool/*.log {\n"
"    daily\n"
"    size 512k\n"
"    missingok\n"
"    rotate 10\n"
"    compress\n"
"    delaycompress\n"
"    create 0640 tarantool adm\n"
"    postrotate\n"
"        /usr/bin/tarantoolctl logrotate `basename ${1%%.*}`\n"
"    endscript\n"
"}"
msgstr ""
"/var/log/tarantool/*.log {\n"
"    daily\n"
"    size 512k\n"
"    missingok\n"
"    rotate 10\n"
"    compress\n"
"    delaycompress\n"
"    create 0640 tarantool adm\n"
"    postrotate\n"
"        /usr/bin/tarantoolctl logrotate `basename ${1%%.*}`\n"
"    endscript\n"
"}"

#: ../doc/1.10/book/admin/logs.rst:97
msgid ""
"If you use a different log rotation program, you can invoke "
"``tarantoolctl logrotate`` command to request instances to reopen their "
"log files after they were moved by the program of your choice."
msgstr ""
"Если вы используете другую программу для ротации журналов, можно вызвать "
"команду ``tarantoolctl logrotate``, чтобы экземпляры переоткрыли свои "
"файлы журнала после того, как выбранная вами программа переместила их."

#: ../doc/1.10/book/admin/logs.rst:101
msgid ""
"Tarantool can write its logs to a log file, ``syslog`` or a program "
"specified in the configuration file (see :ref:`log <cfg_logging-log>` "
"parameter)."
msgstr ""
"Tarantool может писать события в файл журнала, ``syslog`` или программу, "
"указанную в конфигурационном файле (см. параметр :ref:`log <cfg_logging-"
"log>`)."

#: ../doc/1.10/book/admin/logs.rst:104
msgid ""
"By default, logs are written to a file as defined in ``tarantoolctl`` "
"defaults. ``tarantoolctl`` automatically detects if an instance is using "
"``syslog`` or an external program for logging, and does not override the "
"log destination in this case. In such configurations, log rotation is "
"usually handled by the external program used for logging. So, "
"``tarantoolctl logrotate`` command works only if logging-into-file is "
"enabled in the instance file."
msgstr ""
"По умолчанию запись производится в файл журнала, как указано в исходных "
"настройках ``tarantoolctl``. Скрипт ``tarantoolctl`` автоматически "
"определяет, когда экземпляр использует для журналирования ``syslog`` или "
"внешнюю программу, и не изменяет то, куда ведется запись. В таких случаях"
"  ротацию журналов обычно выполняет та же программа, которая используется"
" для журналирования. Именно поэтому команда ``tarantoolctl logrotate`` "
"сработает только в том случае, если в файле экземпляра включена "
"возможность вести запись в файл."

#: ../doc/1.10/book/admin/os_notes.rst:39
msgid "Notes for operating systems"
msgstr "Замечания по поводу некоторых операционных систем"

#: ../doc/1.10/book/admin/os_notes.rst:45
msgid "Mac OS"
msgstr "Mac OS"

#: ../doc/1.10/book/admin/os_notes.rst:47
msgid ""
"On Mac OS, you can administer Tarantool instances only with "
"``tarantoolctl``. No native system tools are supported."
msgstr ""
"Администрирование экземпляров Tarantool'а на Mac OS возможно только с "
"помощью ``tarantoolctl``. Встроенные системные инструменты не "
"поддерживаются."

#: ../doc/1.10/book/admin/os_notes.rst:54
msgid "FreeBSD"
msgstr "FreeBSD"

#: ../doc/1.10/book/admin/os_notes.rst:56
msgid ""
"To make ``tarantoolctl`` work along with ``init.d`` utilities on FreeBSD,"
" use paths other than those suggested in :ref:`Instance configuration "
"<admin-instance_config>`. Instead of ``/usr/share/tarantool/`` directory,"
" use ``/usr/local/etc/tarantool/`` and create the following "
"subdirectories:"
msgstr ""
"Чтобы ``tarantoolctl`` и утилиты ``init.d`` работали на FreeBSD, "
"используйте пути, отличные от предложенных в разделе :ref:`Настройка "
"экземпляров Tarantool’а <admin-instance_config>`. Используйте "
"``/usr/local/etc/tarantool/`` вместо ``/usr/share/tarantool/`` и создайте"
"  следующие поддиректории:"

#: ../doc/1.10/book/admin/os_notes.rst:62
msgid "``default`` for ``tarantoolctl`` defaults (see example below),"
msgstr ""
"``default`` для хранения настроек ``tarantoolctl`` по умолчанию (см. "
"пример ниже),"

#: ../doc/1.10/book/admin/os_notes.rst:63
msgid "``instances.available`` for all available instance files, and"
msgstr "``instances.available`` для хранения всех доступных файлов экземпляра, и"

#: ../doc/1.10/book/admin/os_notes.rst:64
msgid "``instances.enabled`` for instance files to be auto-started by sysvinit."
msgstr ""
"``instances.enabled`` для хранения файлов экземпляра, которые необходимо "
"запускать автоматически с помощью sysvinit."

#: ../doc/1.10/book/admin/os_notes.rst:66
msgid "Here is an example of ``tarantoolctl`` defaults on FreeBSD:"
msgstr "Так выглядят настройки ``tarantoolctl`` по умолчанию на FreeBSD:"

#: ../doc/1.10/book/admin/os_notes.rst:68
msgid ""
"default_cfg = {\n"
"    pid_file   = \"/var/run/tarantool\", -- "
"/var/run/tarantool/${INSTANCE}.pid\n"
"    wal_dir    = \"/var/db/tarantool\", -- /var/db/tarantool/${INSTANCE}/"
"\n"
"    snap_dir   = \"/var/db/tarantool\", -- /var/db/tarantool/${INSTANCE}\n"
"    vinyl_dir = \"/var/db/tarantool\", -- /var/db/tarantool/${INSTANCE}\n"
"    logger     = \"/var/log/tarantool\", -- "
"/var/log/tarantool/${INSTANCE}.log\n"
"    username   = \"tarantool\",\n"
"}\n"
"\n"
"-- instances.available - all available instances\n"
"-- instances.enabled - instances to autostart by sysvinit\n"
"instance_dir = \"/usr/local/etc/tarantool/instances.available\""
msgstr ""
"default_cfg = {\n"
"    pid_file   = \"/var/run/tarantool\", -- "
"/var/run/tarantool/${INSTANCE}.pid\n"
"    wal_dir    = \"/var/db/tarantool\", -- /var/db/tarantool/${INSTANCE}/"
"\n"
"    snap_dir   = \"/var/db/tarantool\", -- /var/db/tarantool/${INSTANCE}\n"
"    vinyl_dir = \"/var/db/tarantool\", -- /var/db/tarantool/${INSTANCE}\n"
"    logger     = \"/var/log/tarantool\", -- "
"/var/log/tarantool/${INSTANCE}.log\n"
"    username   = \"tarantool\",\n"
"}\n"
"\n"
"-- instances.available - все доступные экземпляры\n"
"-- instances.enabled - экземпляры для автоматического запуска через "
"sysvinit\n"
"instance_dir = \"/usr/local/etc/tarantool/instances.available\""

#: ../doc/1.10/book/admin/os_notes.rst:87
msgid "Gentoo Linux"
msgstr "Gentoo Linux"

#: ../doc/1.10/book/admin/os_notes.rst:89
msgid ""
"The section below is about a dev-db/tarantool package installed from the "
"official layman overlay (named ``tarantool``)."
msgstr ""
"В разделе ниже описывается пакет \"dev-db/tarantool\", установленный из "
"официального оверлея layman (под названием ``tarantool``)."

#: ../doc/1.10/book/admin/os_notes.rst:92
msgid ""
"The default instance directory is ``/etc/tarantool/instances.available``,"
" can be redefined in ``/etc/default/tarantool``."
msgstr ""
"По умолчанию с экземплярами используется директория "
"``/etc/tarantool/instances.available``,  ее можно переопределить в "
"``/etc/default/tarantool``."

#: ../doc/1.10/book/admin/os_notes.rst:95
msgid ""
"Tarantool instances can be managed (start/stop/reload/status/...) using "
"OpenRC. Consider the example how to create an OpenRC-managed instance:"
msgstr ""
"Управление экземплярами Tarantool'а "
"(запуск/остановка/перезагрузка/проверка статуса и т.д.) можно "
"осуществлять с помощью OpenRC. Рассмотрим пример, как создать экземпляр с"
" управлением OpenRC:"

#: ../doc/1.10/book/admin/os_notes.rst:98
msgid ""
"$ cd /etc/init.d\n"
"$ ln -s tarantool your_service_name\n"
"$ ln -s /usr/share/tarantool/your_service_name.lua "
"/etc/tarantool/instances.available/your_service_name.lua"
msgstr ""
"$ cd /etc/init.d\n"
"$ ln -s tarantool your_service_name\n"
"$ ln -s /usr/share/tarantool/your_service_name.lua "
"/etc/tarantool/instances.available/your_service_name.lua"

#: ../doc/1.10/book/admin/os_notes.rst:104
msgid "Checking that it works:"
msgstr "Проверяем, что работает:"

#: ../doc/1.10/book/admin/os_notes.rst:106
msgid ""
"$ /etc/init.d/your_service_name start\n"
"$ tail -f -n 100 /var/log/tarantool/your_service_name.log"
msgstr ""
"$ /etc/init.d/your_service_name start\n"
"$ tail -f -n 100 /var/log/tarantool/your_service_name.log"

#: ../doc/1.10/book/admin/security.rst:39
msgid "Security"
msgstr "Безопасность"

#: ../doc/1.10/book/admin/security.rst:41
msgid "Tarantool allows for two types of connections:"
msgstr "Tarantool разрешает два типа подключений:"

#: ../doc/1.10/book/admin/security.rst:43
msgid ""
"With :ref:`console.listen() <console-listen>` function from ``console`` "
"module, you can set up a port which can be used to open an administrative"
" console to the server. This is for administrators to connect to a "
"running instance and make requests. ``tarantoolctl`` invokes "
"``console.listen()`` to create a control socket for each started "
"instance."
msgstr ""
"Используя функцию :ref:`console.listen() <console-listen>` из модуля "
"``console``, можно настроить порт для подключения к серверной "
"административной консоли. Этот вариант для администраторов, которым "
"необходимо подключиться к работающему экземпляру и послать некоторые "
"запросы. ``tarantoolctl`` вызывает ``console.listen()``, чтобы создать "
"управляющий сокет для каждого запущенного экземпляра."

#: ../doc/1.10/book/admin/security.rst:49
msgid ""
"With :ref:`box.cfg{listen=...} <cfg_basic-listen>` parameter from ``box``"
" module, you can set up a binary port for connections which read and "
"write to the database or invoke stored procedures."
msgstr ""
"Используя параметр :ref:`box.cfg{listen=...} <cfg_basic-listen>` из "
"модуля ``box``, можно настроить бинарный порт для соединений, которые "
"читают и пишут в базу данных или вызывают хранимые процедуры."

#: ../doc/1.10/book/admin/security.rst:53
msgid "When you connect to an admin console:"
msgstr "Если вы подключены к административной консоли:"

#: ../doc/1.10/book/admin/security.rst:55
msgid "The client-server protocol is plain text."
msgstr "Клиент-серверный протокол -- это простой текст."

#: ../doc/1.10/book/admin/security.rst:56
msgid "No password is necessary."
msgstr "Пароль не требуется."

#: ../doc/1.10/book/admin/security.rst:57
msgid "The user is automatically 'admin'."
msgstr "Пользователь автоматически получает права администратора."

#: ../doc/1.10/book/admin/security.rst:58
msgid "Each command is fed directly to the built-in Lua interpreter."
msgstr "Каждая команда напрямую обрабатывается встроенным интерпретатором Lua."

#: ../doc/1.10/book/admin/security.rst:60
msgid ""
"Therefore you must set up ports for the admin console very cautiously. If"
" it is a TCP port, it should only be opened for a specific IP. Ideally, "
"it should not be a TCP port at all, it should be a Unix domain socket, so"
" that access to the server machine is required. Thus a typical port setup"
" for admin console is:"
msgstr ""
"Поэтому порты для административной консоли следует настраивать очень "
"осторожно. Если это TCP-порт, он должен быть открыть только для "
"определенного IP-адреса. В идеале вместо TCP-порта лучше настроить "
"доменный Unix-сокет, который требует наличие прав доступа к серверной "
"машине. Тогда типичная настройка порта для административной консоли будет"
"  выглядеть следующим образом:"

#: ../doc/1.10/book/admin/security.rst:65
msgid "console.listen('/var/lib/tarantool/socket_name.sock')"
msgstr "console.listen('/var/lib/tarantool/socket_name.sock')"

#: ../doc/1.10/book/admin/security.rst:69
msgid "and a typical connection :ref:`URI <index-uri>` is:"
msgstr "а типичный :ref:`URI <index-uri>` для соединения будет таким:"

#: ../doc/1.10/book/admin/security.rst:71
msgid "/var/lib/tarantool/socket_name.sock"
msgstr "/var/lib/tarantool/socket_name.sock"

#: ../doc/1.10/book/admin/security.rst:75
msgid ""
"if the listener has the privilege to write on ``/var/lib/tarantool`` and "
"the connector has the privilege to read on ``/var/lib/tarantool``. "
"Alternatively, to connect to an admin console of an instance started with"
" ``tarantoolctl``, use :ref:`tarantoolctl enter <admin-"
"executing_code_on_an_instance>`."
msgstr ""
"если у приемника событий есть права на запись в ``/var/lib/tarantool`` и "
"у коннектора есть права на чтение из ``/var/lib/tarantool``. Еще один "
"способ подключиться к административной консоли экземпляра, запущенного с "
"помощью ``tarantoolctl``, -- использовать  :ref:`tarantoolctl enter "
"<admin-executing_code_on_an_instance>`."

#: ../doc/1.10/book/admin/security.rst:80
msgid ""
"To find out whether a TCP port is a port for admin console, use "
"``telnet``. For example:"
msgstr ""
"Выяснить, является ли некоторый TCP-порт портом для административной "
"консоли, можно с помощью ``telnet``. Например:"

#: ../doc/1.10/book/admin/security.rst:83
msgid ""
"$ telnet 0 3303\n"
"Trying 0.0.0.0...\n"
"Connected to 0.\n"
"Escape character is '^]'.\n"
"Tarantool 1.10.0 (Lua console)\n"
"type 'help' for interactive help"
msgstr ""
"$ telnet 0 3303\n"
"Trying 0.0.0.0...\n"
"Connected to 0.\n"
"Escape character is '^]'.\n"
"Tarantool 1.10.0 (Lua console)\n"
"type 'help' for interactive help"

#: ../doc/1.10/book/admin/security.rst:92
msgid ""
"In this example, the response does not include the word \"binary\" and "
"does include the words \"Lua console\". Therefore it is clear that this "
"is a successful connection to a port for admin console, and you can now "
"enter admin requests on this terminal."
msgstr ""
"В этом примере в ответе от сервера нет слова \"binary\" и есть слова "
"\"Lua console\". Это значит, что мы успешно подключились к порту для "
"административной консоли и можем вводить администраторские запросы на "
"этом терминале."

#: ../doc/1.10/book/admin/security.rst:97
msgid "When you connect to a binary port:"
msgstr "Если вы подключены к бинарному порту:"

#: ../doc/1.10/book/admin/security.rst:99
msgid ""
"The client-server protocol is :ref:`binary <box_protocol-"
"iproto_protocol>`."
msgstr ""
"Клиент-серверный протокол -- :ref:`бинарный <box_protocol-"
"iproto_protocol>`."

#: ../doc/1.10/book/admin/security.rst:100
msgid "The user is automatically ':ref:`guest <authentication-users>`'."
msgstr ""
"Автоматически выбирается пользователь ':ref:`guest <authentication-"
"users>`'."

#: ../doc/1.10/book/admin/security.rst:101
msgid "To change the user, it’s necessary to authenticate."
msgstr "Для смены пользователя необходимо пройти аутентификацию."

#: ../doc/1.10/book/admin/security.rst:103
msgid ""
"For ease of use, ``tarantoolctl connect`` command automatically detects "
"the type of connection during handshake and uses :ref:`EVAL "
"<box_protocol-eval>` binary protocol command when it’s necessary to "
"execute Lua commands over a binary connection. To execute EVAL, the "
"authenticated user must have global \"EXECUTE\" privilege."
msgstr ""
"Для удобства использования команда ``tarantoolctl connect`` автоматически"
"  определяет тип подключения при установке соединения и использует "
"команду  бинарного протокола :ref:`EVAL <box_protocol-eval>` для "
"выполнения Lua-команд по бинарному подключению. Чтобы выполнить команду "
"EVAL, аутентифицированный пользователь должен иметь глобальные "
"\"EXECUTE\"-права."

#: ../doc/1.10/book/admin/security.rst:109
msgid ""
"Therefore, when ``ssh`` access to the machine is not available, creating "
"a Tarantool user with global \"EXECUTE\" privilege and non-empty password"
" can be used to provide a system administrator **remote** access to an "
"instance."
msgstr ""
"Поэтому при невозможности подключиться к машине по ``ssh`` системный "
"администратор может получить **удаленный** доступ к экземпляру, создав "
"пользователя Tarantool с глобальными \"EXECUTE\"-правами и непустым "
"паролем."

#: ../doc/1.10/book/admin/server_introspection.rst:39
msgid "Server introspection"
msgstr "Просмотр состояния сервера"

#: ../doc/1.10/book/admin/server_introspection.rst:45
msgid "Using Tarantool as a client"
msgstr "Использование Tarantool'а в качестве клиента"

#: ../doc/1.10/book/admin/server_introspection.rst:47
msgid "Tarantool enters the interactive mode if:"
msgstr "Tarantool входит в интерактивный режим, если:"

#: ../doc/1.10/book/admin/server_introspection.rst:49
msgid ""
"you start Tarantool without an :ref:`instance file <admin-"
"instance_file>`, or"
msgstr "вы запускаете его без :ref:`файла экземпляра <admin-instance_file>`, либо"

#: ../doc/1.10/book/admin/server_introspection.rst:52
msgid "the instance file contains :ref:`console.start() <console-start>`."
msgstr ""
"в файле экземпляра содержится команда :ref:`console.start() <console-"
"start>`."

#: ../doc/1.10/book/admin/server_introspection.rst:54
msgid ""
"Tarantool displays a prompt (e.g. \"tarantool>\") and you can enter "
"requests. When used this way, Tarantool can be a client for a remote "
"server. See basic examples in :ref:`Getting started <getting_started>`."
msgstr ""
"Tarantool выводит приглашение командной строки (например, \"tarantool>\")"
" -- и вы можете посылать запросы. Если использовать Tarantool таким "
"образом, он может выступать клиентом для удаленного сервера, см. простые "
"примеры в :ref:`Руководстве для начинающих <getting_started>`."

#: ../doc/1.10/book/admin/server_introspection.rst:58
msgid ""
"The interactive mode is used by ``tarantoolctl`` to implement \"enter\" "
"and \"connect\" commands."
msgstr ""
"Скрипт ``tarantoolctl`` использует интерактивный режим для реализации "
"команд  \"enter\" и \"connect\"."

#: ../doc/1.10/book/admin/server_introspection.rst:65
msgid "Executing code on an instance"
msgstr "Выполнение кода на экземпляре Tarantool'а"

#: ../doc/1.10/book/admin/server_introspection.rst:67
msgid ""
"You can attach to an instance's :ref:`admin console <admin-security>` and"
" execute some Lua code using ``tarantoolctl``:"
msgstr ""
"Можно подключиться к :ref:`административной консоли <admin-security>` "
"экземпляра и выполнить некий Lua-код с помощью утилиты ``tarantoolctl``:"

#: ../doc/1.10/book/admin/server_introspection.rst:70
msgid ""
"$ # for local instances:\n"
"$ tarantoolctl enter my_app\n"
"/bin/tarantoolctl: Found my_app.lua in /etc/tarantool/instances.available"
"\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/my_app.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/my_app.control\n"
"unix/:/var/run/tarantool/my_app.control> 1 + 1\n"
"---\n"
"- 2\n"
"...\n"
"unix/:/var/run/tarantool/my_app.control>\n"
"\n"
"$ # for local and remote instances:\n"
"$ tarantoolctl connect username:password@127.0.0.1:3306"
msgstr ""
"$ # для локальных экземпляров:\n"
"$ tarantoolctl enter my_app\n"
"/bin/tarantoolctl: Found my_app.lua in /etc/tarantool/instances.available"
"\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/my_app.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/my_app.control\n"
"unix/:/var/run/tarantool/my_app.control> 1 + 1\n"
"---\n"
"- 2\n"
"...\n"
"unix/:/var/run/tarantool/my_app.control>\n"
"\n"
"$ # для локальных и удаленных экземпляров:\n"
"$ tarantoolctl connect username:password@127.0.0.1:3306"

#: ../doc/1.10/book/admin/server_introspection.rst:86
msgid ""
"You can also use ``tarantoolctl`` to execute Lua code on an instance "
"without attaching to its admin console. For example:"
msgstr ""
"Можно также использовать ``tarantoolctl`` для выполнения Lua-кода на "
"запущенном экземпляре Tarantool-сервера, не подключаясь к его "
"административной консоли. Например:"

#: ../doc/1.10/book/admin/server_introspection.rst:89
msgid ""
"$ # executing commands directly from the command line\n"
"$ <command> | tarantoolctl eval my_app\n"
"<...>\n"
"\n"
"$ # - OR -\n"
"\n"
"$ # executing commands from a script file\n"
"$ tarantoolctl eval my_app script.lua\n"
"<...>"
msgstr ""
"$ # выполнение команд напрямую из командной строки\n"
"$ <command> | tarantoolctl eval my_app\n"
"<...>\n"
"\n"
"$ # - ИЛИ -\n"
"\n"
"$ # выполнение команд из скрипта\n"
"$ tarantoolctl eval my_app script.lua\n"
"<...>"

#: ../doc/1.10/book/admin/server_introspection.rst:103
msgid ""
"Alternatively, you can use the :ref:`console <console-module>` module or "
"the :ref:`net.box <net_box-module>` module from a Tarantool server. Also,"
" you can write your client programs with any of the :ref:`connectors "
"<index-box_connectors>`. However, most of the examples in this manual "
"illustrate usage with either ``tarantoolctl connect`` or :ref:`using the "
"Tarantool server as a client <admin-using_tarantool_as_a_client>`."
msgstr ""
"Еще можно использовать модули :ref:`console <console-module>` и "
":ref:`net.box <net_box-module>` из Tarantool-сервера. Также вы можете "
"писать свои клиентские программы с использованием любого из доступных "
":ref:`коннекторов <index-box_connectors>`. Однако большинство примеров в "
"данном документе использует или ``tarantoolctl connect``, или "
":ref:`Tarantool-сервер как клиент <admin-using_tarantool_as_a_client>`."

#: ../doc/1.10/book/admin/server_introspection.rst:114
msgid "Health checks"
msgstr "Проверка состояния экземпляра"

#: ../doc/1.10/book/admin/server_introspection.rst:116
msgid "To check the instance status, say:"
msgstr "Чтобы проверить статус экземпляра Tarantool-сервера, выполните команду:"

#: ../doc/1.10/book/admin/server_introspection.rst:118
msgid ""
"$ tarantoolctl status my_app\n"
"my_app is running (pid: /var/run/tarantool/my_app.pid)\n"
"\n"
"$ # - OR -\n"
"\n"
"$ systemctl status tarantool@my_app\n"
"tarantool@my_app.service - Tarantool Database Server\n"
"Loaded: loaded (/etc/systemd/system/tarantool@.service; disabled; vendor "
"preset: disabled)\n"
"Active: active (running)\n"
"Docs: man:tarantool(1)\n"
"Process: 5346 ExecStart=/usr/bin/tarantoolctl start %I (code=exited, "
"status=0/SUCCESS)\n"
"Main PID: 5350 (tarantool)\n"
"Tasks: 11 (limit: 512)\n"
"CGroup: /system.slice/system-tarantool.slice/tarantool@my_app.service\n"
"+ 5350 tarantool my_app.lua <running>"
msgstr ""
"$ tarantoolctl status my_app\n"
"my_app is running (pid: /var/run/tarantool/my_app.pid)\n"
"\n"
"$ # - ИЛИ -\n"
"\n"
"$ systemctl status tarantool@my_app\n"
"tarantool@my_app.service - Tarantool Database Server\n"
"Loaded: loaded (/etc/systemd/system/tarantool@.service; disabled; vendor "
"preset: disabled)\n"
"Active: active (running)\n"
"Docs: man:tarantool(1)\n"
"Process: 5346 ExecStart=/usr/bin/tarantoolctl start %I (code=exited, "
"status=0/SUCCESS)\n"
"Main PID: 5350 (tarantool)\n"
"Tasks: 11 (limit: 512)\n"
"CGroup: /system.slice/system-tarantool.slice/tarantool@my_app.service\n"
"+ 5350 tarantool my_app.lua <running>"

#: ../doc/1.10/book/admin/server_introspection.rst:136
msgid "To check the boot log, on systems with ``systemd``, say:"
msgstr ""
"Если вы используете систему, на которой доступна утилита ``systemd``, "
"выполните следующую команду для проверки содержимого журнала загрузки:"

#: ../doc/1.10/book/admin/server_introspection.rst:138
msgid ""
"$ journalctl -u tarantool@my_app -n 5\n"
"-- Logs begin at Fri 2016-01-08 12:21:53 MSK, end at Thu 2016-01-21 "
"21:17:47 MSK. --\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Stopped Tarantool "
"Database Server.\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Starting Tarantool "
"Database Server...\n"
"Jan 21 21:17:47 localhost.localdomain tarantoolctl[5969]: "
"/usr/bin/tarantoolctl: Found my_app.lua in "
"/etc/tarantool/instances.available\n"
"Jan 21 21:17:47 localhost.localdomain tarantoolctl[5969]: "
"/usr/bin/tarantoolctl: Starting instance...\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Started Tarantool "
"Database Server"
msgstr ""
"$ journalctl -u tarantool@my_app -n 5\n"
"-- Logs begin at Fri 2016-01-08 12:21:53 MSK, end at Thu 2016-01-21 "
"21:17:47 MSK. --\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Stopped Tarantool "
"Database Server.\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Starting Tarantool "
"Database Server...\n"
"Jan 21 21:17:47 localhost.localdomain tarantoolctl[5969]: "
"/usr/bin/tarantoolctl: Found my_app.lua in "
"/etc/tarantool/instances.available\n"
"Jan 21 21:17:47 localhost.localdomain tarantoolctl[5969]: "
"/usr/bin/tarantoolctl: Starting instance...\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Started Tarantool "
"Database Server"

#: ../doc/1.10/book/admin/server_introspection.rst:148
msgid ""
"For more details, use the reports provided by functions in the following "
"submodules:"
msgstr ""
"Более подробная информация содержится в отчетах, которые можно получить с"
" помощью функций из следующих подмодулей:"

#: ../doc/1.10/book/admin/server_introspection.rst:150
msgid ""
":ref:`box.cfg <box_introspection-box_cfg>` submodule (check and specify "
"all configuration parameters for the Tarantool server)"
msgstr ""
":ref:`box.cfg <box_introspection-box_cfg>` -- проверка и указание всех "
"конфигурационных параметров Tarantool-сервера,"

#: ../doc/1.10/book/admin/server_introspection.rst:153
msgid ""
":ref:`box.slab <box_introspection-box_slab>` submodule (monitor the total"
" use and fragmentation of memory allocated for storing data in Tarantool)"
msgstr ""
":ref:`box.slab <box_introspection-box_slab>` -- мониторинг использования "
"и фрагментированности памяти, выделенной для хранения данных в "
"Tarantool'е,"

#: ../doc/1.10/book/admin/server_introspection.rst:156
msgid ""
":ref:`box.info <box_introspection-box_info>` submodule (introspect "
"Tarantool server variables, primarily those related to replication)"
msgstr ""
":ref:`box.info <box_introspection-box_info>` -- просмотр переменных "
"Tarantool-сервера -- в первую очередь тех, что относятся к репликации,"

#: ../doc/1.10/book/admin/server_introspection.rst:159
msgid ""
":ref:`box.stat <box_introspection-box_stat>` submodule (introspect "
"Tarantool request and network statistics)"
msgstr ""
":ref:`box.stat <box_introspection-box_stat>` -- просмотр статистики "
"Tarantool'а по запросам и использованию сети,"

#: ../doc/1.10/book/admin/server_introspection.rst:162
msgid ""
"You can also try `tarantool/prometheus "
"<https://github.com/tarantool/prometheus>`_, a Lua module that makes it "
"easy to collect metrics (e.g. memory usage or number of requests) from "
"Tarantool applications and databases and expose them via the Prometheus "
"protocol."
msgstr ""
"Можно также попробовать воспользоваться Lua-модулем `tarantool/prometheus"
" <https://github.com/tarantool/prometheus>`_, который облегчает сбор "
"метрик (например, использование памяти или количество запросов) с "
"Tarantool-приложений и баз данных и их публикацию через протокол "
"Prometheus."

#: ../doc/1.10/book/admin/server_introspection.rst:167
#: ../doc/1.10/book/admin/server_introspection.rst:677
#: ../doc/1.10/book/box/authentication.rst:334
#: ../doc/1.10/book/box/box_schema.rst:220
#: ../doc/1.10/book/box/box_session.rst:213
#: ../doc/1.10/book/box/box_session.rst:271
#: ../doc/1.10/book/box/box_session.rst:301
#: ../doc/1.10/book/box/box_session.rst:347
#: ../doc/1.10/book/box/box_session.rst:588
#: ../doc/1.10/book/box/triggers.rst:113
msgid "**Example**"
msgstr "**Пример**"

#: ../doc/1.10/book/admin/server_introspection.rst:169
msgid ""
"A very popular administrator request is :ref:`box.slab.info() "
"<box_slab_info>`, which displays detailed memory usage statistics for a "
"Tarantool instance."
msgstr ""
"Очень часто администраторам приходится вызывать функцию "
":ref:`box.slab.info() <box_slab_info>`, которая показывает подробную "
"статистику по использованию памяти для конкретного экземпляра "
"Tarantool'а."

#: ../doc/1.10/book/admin/server_introspection.rst:172
msgid ""
"tarantool> box.slab.info()\n"
"---\n"
"- items_size: 228128\n"
"  items_used_ratio: 1.8%\n"
"  quota_size: 1073741824\n"
"  quota_used_ratio: 0.8%\n"
"  arena_used_ratio: 43.2%\n"
"  items_used: 4208\n"
"  quota_used: 8388608\n"
"  arena_size: 2325176\n"
"  arena_used: 1003632\n"
"..."
msgstr ""
"tarantool> box.slab.info()\n"
"---\n"
"- items_size: 228128\n"
"  items_used_ratio: 1.8%\n"
"  quota_size: 1073741824\n"
"  quota_used_ratio: 0.8%\n"
"  arena_used_ratio: 43.2%\n"
"  items_used: 4208\n"
"  quota_used: 8388608\n"
"  arena_size: 2325176\n"
"  arena_used: 1003632\n"
"..."

#: ../doc/1.10/book/admin/server_introspection.rst:187
msgid ""
"Tarantool takes memory from the operating system, for example when a user"
" does many insertions. You can see how much it has taken by saying (on "
"Linux):"
msgstr ""
"Tarantool занимает память операционной системы, например, когда "
"пользователь вставляет много данных. Можно проверить, сколько памяти "
"занято, выполнив команду (в Linux):"

#: ../doc/1.10/book/admin/server_introspection.rst:191
msgid "ps -eo args,%mem | grep \"tarantool\""
msgstr "ps -eo args,%mem | grep \"tarantool\""

#: ../doc/1.10/book/admin/server_introspection.rst:195
msgid ""
"Tarantool almost never releases this memory, even if the user deletes "
"everything that was inserted, or reduces fragmentation by calling the Lua"
" garbage collector via the `collectgarbage function "
"<https://www.lua.org/manual/5.1/manual.html#pdf-collectgarbage>`_."
msgstr ""
"Tarantool почти никогда не освобождает эту память, даже если пользователь"
" удалит все, что было вставлено, или уменьшит фрагментацию, вызвав "
"сборщик мусора в Lua с помощью `функции collectgarbage "
"<https://www.lua.org/manual/5.1/manual.html #pdf-collectgarbage>`_."

#: ../doc/1.10/book/admin/server_introspection.rst:200
msgid ""
"Ordinarily this does not affect performance. But, to force Tarantool to "
"release memory, you can call :ref:`box.snapshot <box-snapshot>`, stop the"
" server instance, and restart it."
msgstr ""
"Как правило, это не влияет на производительность. Однако, чтобы заставить"
" Tarantool высвободить память, можно вызвать :ref:`box.snapshot <box-"
"snapshot>`, остановить экземпляр и перезапустить его."

#: ../doc/1.10/book/admin/server_introspection.rst:209
msgid "Profiling performance issues"
msgstr "Профилирование производительности"

#: ../doc/1.10/book/admin/server_introspection.rst:211
msgid ""
"Tarantool can at times work slower than usual. There can be multiple "
"reasons, such as disk issues, CPU-intensive Lua scripts or "
"misconfiguration. Tarantool’s log may lack details in such cases, so the "
"only indications that something goes wrong are log entries like this: "
"``W> too long DELETE: 8.546 sec``. Here are tools and techniques that can"
" help you collect Tarantool’s performance profile, which is helpful in "
"troubleshooting slowdowns."
msgstr ""
"Иногда Tarantool может работать медленнее, чем обычно. Причин такого "
"поведения может быть несколько: проблемы с диском, Lua-скрипты, активно "
"использующие процессор, или неправильная настройка. В таких случаях в "
"журнале Tarantool’а могут отсутствовать необходимые подробности, поэтому "
"единственным признаком неправильного поведения является наличие в журнале"
"  записей вида ``W> too long DELETE: 8.546 sec``. Ниже приведены "
"инструменты и приемы, которые облегчают снятие профиля производительности"
"  Tarantool’а. Эта процедура может помочь при решении проблем с "
"замедлением."

#: ../doc/1.10/book/admin/server_introspection.rst:220
msgid ""
"Most of these tools -- except ``fiber.info()`` -- are intended for "
"generic GNU/Linux distributions, but not FreeBSD or Mac OS."
msgstr ""
"Большинство инструментов, за исключением ``fiber.info()``, предназначено "
"для дистрибутивов GNU/Linux, но не для FreeBSD или Mac OS."

#: ../doc/1.10/book/admin/server_introspection.rst:225
msgid "fiber.info()"
msgstr "fiber.info()"

#: ../doc/1.10/book/admin/server_introspection.rst:227
msgid ""
"The simplest profiling method is to take advantage of Tarantool’s built-"
"in functionality. :ref:`fiber.info() <fiber-info>` returns information "
"about all running fibers with their corresponding C stack traces. You can"
" use this data to see how many fibers are running and which C functions "
"are executed more often than others."
msgstr ""
"Самый простой способ профилирования -- это использование встроенных "
"функций Tarantool’а. :ref:`fiber.info() <fiber-info>` возвращает "
"информацию обо всех работающих файберах с соответствующей трассировкой "
"стека для языка C. Эти данные показывают, сколько файберов запущенно на "
"данный момент и какие функции, написанные на C, вызываются чаще "
"остальных."

#: ../doc/1.10/book/admin/server_introspection.rst:233
msgid "First, enter your instance’s interactive administrator console:"
msgstr ""
"Сначала войдите в интерактивную административную консоль вашего "
"экземпляра Tarantool’а:"

#: ../doc/1.10/book/admin/server_introspection.rst:235
#: ../doc/1.10/book/admin/server_introspection.rst:513
msgid "$ tarantoolctl enter NAME"
msgstr "$ tarantoolctl enter NAME"

#: ../doc/1.10/book/admin/server_introspection.rst:239
msgid "Once there, load the ``fiber`` module:"
msgstr "После этого загрузите модуль ``fiber``:"

#: ../doc/1.10/book/admin/server_introspection.rst:241
msgid "tarantool> fiber = require('fiber')"
msgstr "tarantool> fiber = require('fiber')"

#: ../doc/1.10/book/admin/server_introspection.rst:245
msgid "After that you can get the required information with ``fiber.info()``."
msgstr "Теперь можно получить необходимую информацию с помощью `fiber.info()`."

#: ../doc/1.10/book/admin/server_introspection.rst:247
msgid "At this point, you console output should look something like this:"
msgstr "На этом шаге в вашей консоли должно выводиться следующее:"

#: ../doc/1.10/book/admin/server_introspection.rst:249
msgid ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> fiber.info()\n"
"---\n"
"- 360:\n"
"    csw: 2098165\n"
"    backtrace:\n"
"    - '#0 0x4d1b77 in wal_write(journal*, journal_entry*)+487'\n"
"    - '#1 0x4bbf68 in txn_commit(txn*)+152'\n"
"    - '#2 0x4bd5d8 in process_rw(request*, space*, tuple**)+136'\n"
"    - '#3 0x4bed48 in box_process1+104'\n"
"    - '#4 0x4d72f8 in lbox_replace+120'\n"
"    - '#5 0x50f317 in lj_BC_FUNCC+52'\n"
"    fid: 360\n"
"    memory:\n"
"      total: 61744\n"
"      used: 480\n"
"    name: main\n"
"  129:\n"
"    csw: 113\n"
"    backtrace: []\n"
"    fid: 129\n"
"    memory:\n"
"      total: 57648\n"
"      used: 0\n"
"    name: 'console/unix/:'\n"
"..."
msgstr ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> fiber.info()\n"
"---\n"
"- 360:\n"
"    csw: 2098165\n"
"    backtrace:\n"
"    - '#0 0x4d1b77 in wal_write(journal*, journal_entry*)+487'\n"
"    - '#1 0x4bbf68 in txn_commit(txn*)+152'\n"
"    - '#2 0x4bd5d8 in process_rw(request*, space*, tuple**)+136'\n"
"    - '#3 0x4bed48 in box_process1+104'\n"
"    - '#4 0x4d72f8 in lbox_replace+120'\n"
"    - '#5 0x50f317 in lj_BC_FUNCC+52'\n"
"    fid: 360\n"
"    memory:\n"
"      total: 61744\n"
"      used: 480\n"
"    name: main\n"
"  129:\n"
"    csw: 113\n"
"    backtrace: []\n"
"    fid: 129\n"
"    memory:\n"
"      total: 57648\n"
"      used: 0\n"
"    name: 'console/unix/:'\n"
"..."

#: ../doc/1.10/book/admin/server_introspection.rst:280
msgid ""
"We highly recommend to assign meaningful names to fibers you create so "
"that you can find them in the ``fiber.info()`` list. In the example "
"below, we create a fiber named ``myworker``:"
msgstr ""
"Мы рекомендуем присваивать создаваемым файберам понятные имена, чтобы их "
"можно было легко найти в списке, выводимом ``fiber.info()``. В примере "
"ниже создается файбер с именем ``myworker``:"

#: ../doc/1.10/book/admin/server_introspection.rst:284
msgid ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> f = fiber.create(function() while true do fiber.sleep(0.5) end"
" end)\n"
"---\n"
"...\n"
"tarantool> f:name('myworker') <!-- assigning the name to a fiber\n"
"---\n"
"...\n"
"tarantool> fiber.info()\n"
"---\n"
"- 102:\n"
"    csw: 14\n"
"    backtrace:\n"
"    - '#0 0x501a1a in fiber_yield_timeout+90'\n"
"    - '#1 0x4f2008 in lbox_fiber_sleep+72'\n"
"    - '#2 0x5112a7 in lj_BC_FUNCC+52'\n"
"    fid: 102\n"
"    memory:\n"
"      total: 57656\n"
"      used: 0\n"
"    name: myworker <!-- newly created background fiber\n"
"  101:\n"
"    csw: 284\n"
"    backtrace: []\n"
"    fid: 101\n"
"    memory:\n"
"      total: 57656\n"
"      used: 0\n"
"    name: interactive\n"
"..."
msgstr ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> f = fiber.create(function() while true do fiber.sleep(0.5) end"
" end)\n"
"---\n"
"...\n"
"tarantool> f:name('myworker') <!-- присваивание имени файберу\n"
"---\n"
"...\n"
"tarantool> fiber.info()\n"
"---\n"
"- 102:\n"
"    csw: 14\n"
"    backtrace:\n"
"    - '#0 0x501a1a in fiber_yield_timeout+90'\n"
"    - '#1 0x4f2008 in lbox_fiber_sleep+72'\n"
"    - '#2 0x5112a7 in lj_BC_FUNCC+52'\n"
"    fid: 102\n"
"    memory:\n"
"      total: 57656\n"
"      used: 0\n"
"    name: myworker <!-- новый созданный фоновый файбер\n"
"  101:\n"
"    csw: 284\n"
"    backtrace: []\n"
"    fid: 101\n"
"    memory:\n"
"      total: 57656\n"
"      used: 0\n"
"    name: interactive\n"
"..."

#: ../doc/1.10/book/admin/server_introspection.rst:318
msgid "You can kill any fiber with :ref:`fiber.kill(fid) <fiber-kill>`:"
msgstr ""
"Для принудительного завершения файбера используется команда "
":ref:`fiber.kill(fid) <fiber-kill>`:"

#: ../doc/1.10/book/admin/server_introspection.rst:320
msgid ""
"tarantool> fiber.kill(102)\n"
"---\n"
"...\n"
"tarantool> fiber.info()\n"
"---\n"
"- 101:\n"
"    csw: 324\n"
"    backtrace: []\n"
"    fid: 101\n"
"    memory:\n"
"      total: 57656\n"
"      used: 0\n"
"    name: interactive\n"
"..."
msgstr ""
"tarantool> fiber.kill(102)\n"
"---\n"
"...\n"
"tarantool> fiber.info()\n"
"---\n"
"- 101:\n"
"    csw: 324\n"
"    backtrace: []\n"
"    fid: 101\n"
"    memory:\n"
"      total: 57656\n"
"      used: 0\n"
"    name: interactive\n"
"..."

#: ../doc/1.10/book/admin/server_introspection.rst:337
msgid ""
"If you want to dynamically obtain information with ``fiber.info()``, the "
"shell script below may come in handy. It connects to a Tarantool instance"
" specified by ``NAME`` every 0.5 seconds, grabs the ``fiber.info()`` "
"output and writes it to the ``fiber-info.txt`` file:"
msgstr ""
"Если вам необходимо динамически получать информацию с помощью "
"``fiber.info()``, вам может пригодиться приведенный ниже скрипт. Он "
"каждые полсекунды подключается к экземпляру Tarantool’а, указанному в "
"переменной ``NAME``, выполняет команду ``fiber.info()`` и записывает ее "
"выход в файл ``fiber-info.txt``:"

#: ../doc/1.10/book/admin/server_introspection.rst:342
msgid ""
"$ rm -f fiber.info.txt\n"
"$ watch -n 0.5 \"echo 'require(\\\"fiber\\\").info()' | tarantoolctl "
"enter NAME | tee -a fiber-info.txt\""
msgstr ""
"$ rm -f fiber.info.txt\n"
"$ watch -n 0.5 \"echo 'require(\\\"fiber\\\").info()' | tarantoolctl "
"enter NAME | tee -a fiber-info.txt\""

#: ../doc/1.10/book/admin/server_introspection.rst:347
msgid ""
"If you can't understand which fiber causes performance issues, collect "
"the metrics of the ``fiber.info()`` output for 10-15 seconds using the "
"script above and contact the Tarantool team at support@tarantool.org."
msgstr ""
"Если вы не можете самостоятельно разобраться, какой именно файбер "
"вызывает проблемы с производительностью, запустите данный скрипт на 10-15"
" секунд и пришлите получившийся файл команде Tarantool’а на адрес "
"support@tarantool.org."

#: ../doc/1.10/book/admin/server_introspection.rst:353
msgid "Poor man’s profilers"
msgstr "Простейшие профилировщики"

#: ../doc/1.10/book/admin/server_introspection.rst:355
msgid "**pstack <pid>**"
msgstr "**pstack <pid>**"

#: ../doc/1.10/book/admin/server_introspection.rst:357
msgid ""
"To use this tool, first install it with a package manager that comes with"
" your Linux distribution. This command prints an execution stack trace of"
" a running process specified by the PID. You might want to run this "
"command several times in a row to pinpoint the bottleneck that causes the"
" slowdown."
msgstr ""
"Чтобы использовать этот инструмент, его необходимо установить с помощью "
"пакетного менеджера, поставляемого с вашим дистрибутивом Linux. Данная "
"команда выводит трассировку стека выполнения для работающего процесса с "
"соответствующим PID. При необходимости команду можно запустить несколько "
"раз, чтобы выявить узкое место, которое вызывает падение "
"производительности."

#: ../doc/1.10/book/admin/server_introspection.rst:362
msgid "Once installed, say:"
msgstr "После установки воспользуйтесь следующей командой:"

#: ../doc/1.10/book/admin/server_introspection.rst:364
msgid "$ pstack $(pidof tarantool INSTANCENAME.lua)"
msgstr "$ pstack $(pidof tarantool INSTANCENAME.lua)"

#: ../doc/1.10/book/admin/server_introspection.rst:368
#: ../doc/1.10/book/admin/server_introspection.rst:415
msgid "Next, say:"
msgstr "Затем выполните:"

#: ../doc/1.10/book/admin/server_introspection.rst:370
#: ../doc/1.10/book/admin/server_introspection.rst:417
msgid "$ echo $(pidof tarantool INSTANCENAME.lua)"
msgstr "$ echo $(pidof tarantool INSTANCENAME.lua)"

#: ../doc/1.10/book/admin/server_introspection.rst:374
#: ../doc/1.10/book/admin/server_introspection.rst:421
msgid ""
"to show the PID of the Tarantool instance that runs the "
"``INSTANCENAME.lua`` file."
msgstr ""
"чтобы вывести на экран PID экземпляра Tarantool’а, использующего файл "
"``INSTANCENAME.lua``."

#: ../doc/1.10/book/admin/server_introspection.rst:376
msgid "You should get similar output:"
msgstr "В вашей консоли должно отображаться приблизительно следующее:"

#: ../doc/1.10/book/admin/server_introspection.rst:378
msgid ""
"Thread 19 (Thread 0x7f09d1bff700 (LWP 24173)):\n"
"#0 0x00007f0a1a5423f2 in ?? () from /lib64/libgomp.so.1\n"
"#1 0x00007f0a1a53fdc0 in ?? () from /lib64/libgomp.so.1\n"
"#2 0x00007f0a1ad5adc5 in start_thread () from /lib64/libpthread.so.0\n"
"#3 0x00007f0a1a050ced in clone () from /lib64/libc.so.6\n"
"Thread 18 (Thread 0x7f09d13fe700 (LWP 24174)):\n"
"#0 0x00007f0a1a5423f2 in ?? () from /lib64/libgomp.so.1\n"
"#1 0x00007f0a1a53fdc0 in ?? () from /lib64/libgomp.so.1\n"
"#2 0x00007f0a1ad5adc5 in start_thread () from /lib64/libpthread.so.0\n"
"#3 0x00007f0a1a050ced in clone () from /lib64/libc.so.6\n"
"<...>\n"
"Thread 2 (Thread 0x7f09c8bfe700 (LWP 24191)):\n"
"#0 0x00007f0a1ad5e6d5 in pthread_cond_wait@@GLIBC_2.3.2 () from "
"/lib64/libpthread.so.0\n"
"#1 0x000000000045d901 in wal_writer_pop(wal_writer*) ()\n"
"#2 0x000000000045db01 in wal_writer_f(__va_list_tag*) ()\n"
"#3 0x0000000000429abc in fiber_cxx_invoke(int (*)(__va_list_tag*), "
"__va_list_tag*) ()\n"
"#4 0x00000000004b52a0 in fiber_loop ()\n"
"#5 0x00000000006099cf in coro_init ()\n"
"Thread 1 (Thread 0x7f0a1c47fd80 (LWP 24172)):\n"
"#0 0x00007f0a1a0512c3 in epoll_wait () from /lib64/libc.so.6\n"
"#1 0x00000000006051c8 in epoll_poll ()\n"
"#2 0x0000000000607533 in ev_run ()\n"
"#3 0x0000000000428e13 in main ()"
msgstr ""
"Thread 19 (Thread 0x7f09d1bff700 (LWP 24173)):\n"
"#0 0x00007f0a1a5423f2 in ?? () from /lib64/libgomp.so.1\n"
"#1 0x00007f0a1a53fdc0 in ?? () from /lib64/libgomp.so.1\n"
"#2 0x00007f0a1ad5adc5 in start_thread () from /lib64/libpthread.so.0\n"
"#3 0x00007f0a1a050ced in clone () from /lib64/libc.so.6\n"
"Thread 18 (Thread 0x7f09d13fe700 (LWP 24174)):\n"
"#0 0x00007f0a1a5423f2 in ?? () from /lib64/libgomp.so.1\n"
"#1 0x00007f0a1a53fdc0 in ?? () from /lib64/libgomp.so.1\n"
"#2 0x00007f0a1ad5adc5 in start_thread () from /lib64/libpthread.so.0\n"
"#3 0x00007f0a1a050ced in clone () from /lib64/libc.so.6\n"
"<...>\n"
"Thread 2 (Thread 0x7f09c8bfe700 (LWP 24191)):\n"
"#0 0x00007f0a1ad5e6d5 in pthread_cond_wait@@GLIBC_2.3.2 () from "
"/lib64/libpthread.so.0\n"
"#1 0x000000000045d901 in wal_writer_pop(wal_writer*) ()\n"
"#2 0x000000000045db01 in wal_writer_f(__va_list_tag*) ()\n"
"#3 0x0000000000429abc in fiber_cxx_invoke(int (*)(__va_list_tag*), "
"__va_list_tag*) ()\n"
"#4 0x00000000004b52a0 in fiber_loop ()\n"
"#5 0x00000000006099cf in coro_init ()\n"
"Thread 1 (Thread 0x7f0a1c47fd80 (LWP 24172)):\n"
"#0 0x00007f0a1a0512c3 in epoll_wait () from /lib64/libc.so.6\n"
"#1 0x00000000006051c8 in epoll_poll ()\n"
"#2 0x0000000000607533 in ev_run ()\n"
"#3 0x0000000000428e13 in main ()"

#: ../doc/1.10/book/admin/server_introspection.rst:404
msgid "**gdb -ex \"bt\" -p <pid>**"
msgstr "**gdb -ex \"bt\" -p <pid>**"

#: ../doc/1.10/book/admin/server_introspection.rst:406
msgid ""
"As with ``pstack``, the GNU debugger (also known as ``gdb``) needs to be "
"installed before you can start using it. Your Linux package manager can "
"help you with that."
msgstr ""
"Как и в случае с ``pstack``,  перед использованием GNU-отладчик (также "
"известный как ``gdb``) необходимо сначала установить через пакетный "
"менеджер, встроенный в ваш дистрибутив Linux."

#: ../doc/1.10/book/admin/server_introspection.rst:409
msgid "Once the debugger is installed, say:"
msgstr "После установки воспользуйтесь следующей командой:"

#: ../doc/1.10/book/admin/server_introspection.rst:411
msgid ""
"$ gdb -ex \"set pagination 0\" -ex \"thread apply all bt\" --batch -p "
"$(pidof tarantool INSTANCENAME.lua)"
msgstr ""
"$ gdb -ex \"set pagination 0\" -ex \"thread apply all bt\" --batch -p "
"$(pidof tarantool INSTANCENAME.lua)"

#: ../doc/1.10/book/admin/server_introspection.rst:423
msgid "After using the debugger, your console output should look like this:"
msgstr ""
"После использования отладчика в консоль должна выводиться следующая "
"информация:"

#: ../doc/1.10/book/admin/server_introspection.rst:425
msgid ""
"[Thread debugging using libthread_db enabled]\n"
"Using host libthread_db library \"/lib/x86_64-linux-"
"gnu/libthread_db.so.1\".\n"
"\n"
"[CUT]\n"
"\n"
"Thread 1 (Thread 0x7f72289ba940 (LWP 20535)):\n"
"#0 _int_malloc (av=av@entry=0x7f7226e0eb20 <main_arena>, "
"bytes=bytes@entry=504) at malloc.c:3697\n"
"#1 0x00007f7226acf21a in __libc_calloc (n=<optimized out>, "
"elem_size=<optimized out>) at malloc.c:3234\n"
"#2 0x00000000004631f8 in vy_merge_iterator_reserve (capacity=3, "
"itr=0x7f72264af9e0) at /usr/src/tarantool/src/box/vinyl.c:7629\n"
"#3 vy_merge_iterator_add (itr=itr@entry=0x7f72264af9e0, "
"is_mutable=is_mutable@entry=true, belong_range=belong_range@entry=false) "
"at /usr/src/tarantool/src/box/vinyl.c:7660\n"
"#4 0x00000000004703df in vy_read_iterator_add_mem (itr=0x7f72264af990) at"
" /usr/src/tarantool/src/box/vinyl.c:8387\n"
"#5 vy_read_iterator_use_range (itr=0x7f72264af990) at "
"/usr/src/tarantool/src/box/vinyl.c:8453\n"
"#6 0x000000000047657d in vy_read_iterator_start (itr=<optimized out>) at "
"/usr/src/tarantool/src/box/vinyl.c:8501\n"
"#7 0x00000000004766b5 in vy_read_iterator_next "
"(itr=itr@entry=0x7f72264af990, result=result@entry=0x7f72264afad8) at "
"/usr/src/tarantool/src/box/vinyl.c:8592\n"
"#8 0x000000000047689d in vy_index_get (tx=tx@entry=0x7f7226468158, "
"index=index@entry=0x2563860, key=<optimized out>, part_count=<optimized "
"out>, result=result@entry=0x7f72264afad8) at "
"/usr/src/tarantool/src/box/vinyl.c:5705\n"
"#9 0x0000000000477601 in vy_replace_impl (request=<optimized out>, "
"request=<optimized out>, stmt=0x7f72265a7150, space=0x2567ea0, "
"tx=0x7f7226468158) at /usr/src/tarantool/src/box/vinyl.c:5920\n"
"#10 vy_replace (tx=0x7f7226468158, stmt=stmt@entry=0x7f72265a7150, "
"space=0x2567ea0, request=<optimized out>) at "
"/usr/src/tarantool/src/box/vinyl.c:6608\n"
"#11 0x00000000004615a9 in VinylSpace::executeReplace (this=<optimized "
"out>, txn=<optimized out>, space=<optimized out>, request=<optimized "
"out>) at /usr/src/tarantool/src/box/vinyl_space.cc:108\n"
"#12 0x00000000004bd723 in process_rw "
"(request=request@entry=0x7f72265a70f8, space=space@entry=0x2567ea0, "
"result=result@entry=0x7f72264afbc8) at "
"/usr/src/tarantool/src/box/box.cc:182\n"
"#13 0x00000000004bed48 in box_process1 (request=0x7f72265a70f8, "
"result=result@entry=0x7f72264afbc8) at "
"/usr/src/tarantool/src/box/box.cc:700\n"
"#14 0x00000000004bf389 in box_replace (space_id=space_id@entry=513, "
"tuple=<optimized out>, tuple_end=<optimized out>, "
"result=result@entry=0x7f72264afbc8) at "
"/usr/src/tarantool/src/box/box.cc:754\n"
"#15 0x00000000004d72f8 in lbox_replace (L=0x413c5780) at "
"/usr/src/tarantool/src/box/lua/index.c:72\n"
"#16 0x000000000050f317 in lj_BC_FUNCC ()\n"
"#17 0x00000000004d37c7 in execute_lua_call (L=0x413c5780) at "
"/usr/src/tarantool/src/box/lua/call.c:282\n"
"#18 0x000000000050f317 in lj_BC_FUNCC ()\n"
"#19 0x0000000000529c7b in lua_cpcall ()\n"
"#20 0x00000000004f6aa3 in luaT_cpcall (L=L@entry=0x413c5780, "
"func=func@entry=0x4d36d0 <execute_lua_call>, ud=ud@entry=0x7f72264afde0) "
"at /usr/src/tarantool/src/lua/utils.c:962\n"
"#21 0x00000000004d3fe7 in box_process_lua (handler=0x4d36d0 "
"<execute_lua_call>, out=out@entry=0x7f7213020600, "
"request=request@entry=0x413c5780) at "
"/usr/src/tarantool/src/box/lua/call.c:382\n"
"#22 box_lua_call (request=request@entry=0x7f72130401d8, "
"out=out@entry=0x7f7213020600) at "
"/usr/src/tarantool/src/box/lua/call.c:405\n"
"#23 0x00000000004c0f27 in box_process_call "
"(request=request@entry=0x7f72130401d8, out=out@entry=0x7f7213020600) at "
"/usr/src/tarantool/src/box/box.cc:1074\n"
"#24 0x000000000041326c in tx_process_misc (m=0x7f7213040170) at "
"/usr/src/tarantool/src/box/iproto.cc:942\n"
"#25 0x0000000000504554 in cmsg_deliver (msg=0x7f7213040170) at "
"/usr/src/tarantool/src/cbus.c:302\n"
"#26 0x0000000000504c2e in fiber_pool_f (ap=<error reading variable: value"
" has been optimized out>) at /usr/src/tarantool/src/fiber_pool.c:64\n"
"#27 0x000000000041122c in fiber_cxx_invoke(fiber_func, typedef "
"__va_list_tag __va_list_tag *) (f=<optimized out>, ap=<optimized out>) at"
" /usr/src/tarantool/src/fiber.h:645\n"
"#28 0x00000000005011a0 in fiber_loop (data=<optimized out>) at "
"/usr/src/tarantool/src/fiber.c:641\n"
"#29 0x0000000000688fbf in coro_init () at "
"/usr/src/tarantool/third_party/coro/coro.c:110"
msgstr ""
"[Thread debugging using libthread_db enabled]\n"
"Using host libthread_db library \"/lib/x86_64-linux-"
"gnu/libthread_db.so.1\".\n"
"\n"
"[CUT]\n"
"\n"
"Thread 1 (Thread 0x7f72289ba940 (LWP 20535)):\n"
"#0 _int_malloc (av=av@entry=0x7f7226e0eb20 <main_arena>, "
"bytes=bytes@entry=504) at malloc.c:3697\n"
"#1 0x00007f7226acf21a in __libc_calloc (n=<optimized out>, "
"elem_size=<optimized out>) at malloc.c:3234\n"
"#2 0x00000000004631f8 in vy_merge_iterator_reserve (capacity=3, "
"itr=0x7f72264af9e0) at /usr/src/tarantool/src/box/vinyl.c:7629\n"
"#3 vy_merge_iterator_add (itr=itr@entry=0x7f72264af9e0, "
"is_mutable=is_mutable@entry=true, belong_range=belong_range@entry=false) "
"at /usr/src/tarantool/src/box/vinyl.c:7660\n"
"#4 0x00000000004703df in vy_read_iterator_add_mem (itr=0x7f72264af990) at"
" /usr/src/tarantool/src/box/vinyl.c:8387\n"
"#5 vy_read_iterator_use_range (itr=0x7f72264af990) at "
"/usr/src/tarantool/src/box/vinyl.c:8453\n"
"#6 0x000000000047657d in vy_read_iterator_start (itr=<optimized out>) at "
"/usr/src/tarantool/src/box/vinyl.c:8501\n"
"#7 0x00000000004766b5 in vy_read_iterator_next "
"(itr=itr@entry=0x7f72264af990, result=result@entry=0x7f72264afad8) at "
"/usr/src/tarantool/src/box/vinyl.c:8592\n"
"#8 0x000000000047689d in vy_index_get (tx=tx@entry=0x7f7226468158, "
"index=index@entry=0x2563860, key=<optimized out>, part_count=<optimized "
"out>, result=result@entry=0x7f72264afad8) at "
"/usr/src/tarantool/src/box/vinyl.c:5705\n"
"#9 0x0000000000477601 in vy_replace_impl (request=<optimized out>, "
"request=<optimized out>, stmt=0x7f72265a7150, space=0x2567ea0, "
"tx=0x7f7226468158) at /usr/src/tarantool/src/box/vinyl.c:5920\n"
"#10 vy_replace (tx=0x7f7226468158, stmt=stmt@entry=0x7f72265a7150, "
"space=0x2567ea0, request=<optimized out>) at "
"/usr/src/tarantool/src/box/vinyl.c:6608\n"
"#11 0x00000000004615a9 in VinylSpace::executeReplace (this=<optimized "
"out>, txn=<optimized out>, space=<optimized out>, request=<optimized "
"out>) at /usr/src/tarantool/src/box/vinyl_space.cc:108\n"
"#12 0x00000000004bd723 in process_rw "
"(request=request@entry=0x7f72265a70f8, space=space@entry=0x2567ea0, "
"result=result@entry=0x7f72264afbc8) at "
"/usr/src/tarantool/src/box/box.cc:182\n"
"#13 0x00000000004bed48 in box_process1 (request=0x7f72265a70f8, "
"result=result@entry=0x7f72264afbc8) at "
"/usr/src/tarantool/src/box/box.cc:700\n"
"#14 0x00000000004bf389 in box_replace (space_id=space_id@entry=513, "
"tuple=<optimized out>, tuple_end=<optimized out>, "
"result=result@entry=0x7f72264afbc8) at "
"/usr/src/tarantool/src/box/box.cc:754\n"
"#15 0x00000000004d72f8 in lbox_replace (L=0x413c5780) at "
"/usr/src/tarantool/src/box/lua/index.c:72\n"
"#16 0x000000000050f317 in lj_BC_FUNCC ()\n"
"#17 0x00000000004d37c7 in execute_lua_call (L=0x413c5780) at "
"/usr/src/tarantool/src/box/lua/call.c:282\n"
"#18 0x000000000050f317 in lj_BC_FUNCC ()\n"
"#19 0x0000000000529c7b in lua_cpcall ()\n"
"#20 0x00000000004f6aa3 in luaT_cpcall (L=L@entry=0x413c5780, "
"func=func@entry=0x4d36d0 <execute_lua_call>, ud=ud@entry=0x7f72264afde0) "
"at /usr/src/tarantool/src/lua/utils.c:962\n"
"#21 0x00000000004d3fe7 in box_process_lua (handler=0x4d36d0 "
"<execute_lua_call>, out=out@entry=0x7f7213020600, "
"request=request@entry=0x413c5780) at "
"/usr/src/tarantool/src/box/lua/call.c:382\n"
"#22 box_lua_call (request=request@entry=0x7f72130401d8, "
"out=out@entry=0x7f7213020600) at "
"/usr/src/tarantool/src/box/lua/call.c:405\n"
"#23 0x00000000004c0f27 in box_process_call "
"(request=request@entry=0x7f72130401d8, out=out@entry=0x7f7213020600) at "
"/usr/src/tarantool/src/box/box.cc:1074\n"
"#24 0x000000000041326c in tx_process_misc (m=0x7f7213040170) at "
"/usr/src/tarantool/src/box/iproto.cc:942\n"
"#25 0x0000000000504554 in cmsg_deliver (msg=0x7f7213040170) at "
"/usr/src/tarantool/src/cbus.c:302\n"
"#26 0x0000000000504c2e in fiber_pool_f (ap=<error reading variable: value"
" has been optimized out>) at /usr/src/tarantool/src/fiber_pool.c:64\n"
"#27 0x000000000041122c in fiber_cxx_invoke(fiber_func, typedef "
"__va_list_tag __va_list_tag *) (f=<optimized out>, ap=<optimized out>) at"
" /usr/src/tarantool/src/fiber.h:645\n"
"#28 0x00000000005011a0 in fiber_loop (data=<optimized out>) at "
"/usr/src/tarantool/src/fiber.c:641\n"
"#29 0x0000000000688fbf in coro_init () at "
"/usr/src/tarantool/third_party/coro/coro.c:110"

#: ../doc/1.10/book/admin/server_introspection.rst:464
msgid ""
"Run the debugger in a loop a few times to collect enough samples for "
"making conclusions about why Tarantool demonstrates suboptimal "
"performance. Use the following script:"
msgstr ""
"Запустите отладчик в цикле, чтобы собрать достаточно информации, которая "
"поможет установить причину спада производительности Tarantool’а. Можно "
"воспользоваться следующим скриптом:"

#: ../doc/1.10/book/admin/server_introspection.rst:468
msgid ""
"$ rm -f stack-trace.txt\n"
"$ watch -n 0.5 \"gdb -ex 'set pagination 0' -ex 'thread apply all bt' "
"--batch -p $(pidof tarantool INSTANCENAME.lua) | tee -a stack-trace.txt\""
msgstr ""
"$ rm -f stack-trace.txt\n"
"$ watch -n 0.5 \"gdb -ex 'set pagination 0' -ex 'thread apply all bt' "
"--batch -p $(pidof tarantool INSTANCENAME.lua) | tee -a stack-trace.txt\""

#: ../doc/1.10/book/admin/server_introspection.rst:473
msgid ""
"Structurally and functionally, this script is very similar to the one "
"used with ``fiber.info()`` above."
msgstr ""
"С точки зрения структуры и функциональности, этот скрипт идентичен тому, "
"что используется выше с ``fiber.info()``."

#: ../doc/1.10/book/admin/server_introspection.rst:476
msgid ""
"If you have any difficulties troubleshooting, let the script run for "
"10-15 seconds and then send the resulting ``stack-trace.txt`` file to the"
" Tarantool team at support@tarantool.org."
msgstr ""
"Если вам не удается отыскать причину пониженной производительности, "
"запустите данный скрипт на 10-15 секунд и пришлите получившийся файл "
"``stack-trace.txt`` команде Tarantool’а на адрес support@tarantool.org."

#: ../doc/1.10/book/admin/server_introspection.rst:482
msgid ""
"Use the poor man’s profilers with caution: each time they attach to a "
"running process, this stops the process execution for about a second, "
"which may leave a serious footprint in high-load services."
msgstr ""
"Следует использовать ``pstack`` и ``gdb`` с осторожностью: каждый раз, "
"подключаясь с работающему процессу, они приостанавливают выполнение этого"
"  процесса приблизительно на одну секунду, что может иметь серьезные "
"последствия для высоконагруженных сервисов."

#: ../doc/1.10/book/admin/server_introspection.rst:488
msgid "gperftools"
msgstr "gperftools"

#: ../doc/1.10/book/admin/server_introspection.rst:490
msgid ""
"To use the CPU profiler from the Google Performance Tools suite with "
"Tarantool, first take care of the prerequisites:"
msgstr ""
"Чтобы использовать профилировщик процессора из набора Google Performance "
"Tools с Tarantool’ом, необходимо сначала установить зависимости:"

#: ../doc/1.10/book/admin/server_introspection.rst:493
msgid "For Debian/Ubuntu, run:"
msgstr "Если вы используете Debian/Ubuntu, запустите эту команду:"

#: ../doc/1.10/book/admin/server_introspection.rst:495
msgid "$ apt-get install libgoogle-perftools4"
msgstr "$ apt-get install libgoogle-perftools4"

#: ../doc/1.10/book/admin/server_introspection.rst:499
msgid "For RHEL/CentOS/Fedora, run:"
msgstr "Если вы используете RHEL/CentOS/Fedora, запустите эту команду:"

#: ../doc/1.10/book/admin/server_introspection.rst:501
msgid "$ yum install gperftools-libs"
msgstr "$ yum install gperftools-libs"

#: ../doc/1.10/book/admin/server_introspection.rst:505
msgid "Once you do this, install Lua bindings:"
msgstr "После этого установите привязки для Lua:"

#: ../doc/1.10/book/admin/server_introspection.rst:507
msgid "$ tarantoolctl rocks install gperftools"
msgstr "$ tarantoolctl rocks install gperftools"

#: ../doc/1.10/book/admin/server_introspection.rst:511
msgid ""
"Now you're ready to go. Enter your instance’s interactive administrator "
"console:"
msgstr ""
"После окончания установки войдите в интерактивную административную "
"консоль вашего экземпляра Tarantool’а:"

#: ../doc/1.10/book/admin/server_introspection.rst:517
msgid "To start profiling, say:"
msgstr "Для запуска профилировщика выполните следующий код:"

#: ../doc/1.10/book/admin/server_introspection.rst:519
msgid ""
"tarantool> cpuprof = require('gperftools.cpu')\n"
"tarantool> cpuprof.start('/home/<username>/tarantool-on-production.prof')"
msgstr ""
"tarantool> cpuprof = require('gperftools.cpu')\n"
"tarantool> cpuprof.start('/home/<имя_пользователя>/tarantool-on-"
"production.prof')"

#: ../doc/1.10/book/admin/server_introspection.rst:524
msgid ""
"It takes at least a couple of minutes for the profiler to gather "
"performance metrics. After that, save the results to disk (you can do "
"that as many times as you need):"
msgstr ""
"На сбор метрик производительности у профилировщика уходит по крайней мере"
"  пара минут. По истечении этого времени можно сохранять информацию на "
"диск (неограниченное количество раз):"

#: ../doc/1.10/book/admin/server_introspection.rst:528
msgid "tarantool> cpuprof.flush()"
msgstr "tarantool> cpuprof.flush()"

#: ../doc/1.10/book/admin/server_introspection.rst:532
msgid "To stop profiling, say:"
msgstr "Для остановки профилировщика выполните следующую команду:"

#: ../doc/1.10/book/admin/server_introspection.rst:534
msgid "tarantool> cpuprof.stop()"
msgstr "tarantool> cpuprof.stop()"

#: ../doc/1.10/book/admin/server_introspection.rst:538
msgid ""
"You can now analyze the output with the ``pprof`` utility that comes with"
" the ``gperftools`` package:"
msgstr ""
"Теперь можно проанализировать собранные данные с помощью утилиты "
"``pprof``, которая входит в пакет ``gperftools``:"

#: ../doc/1.10/book/admin/server_introspection.rst:541
msgid ""
"$ pprof --text /usr/bin/tarantool /home/<username>/tarantool-on-"
"production.prof"
msgstr ""
"$ pprof --text /usr/bin/tarantool /home/<имя_пользователя>/tarantool-on-"
"production.prof"

#: ../doc/1.10/book/admin/server_introspection.rst:547
msgid "On Debian/Ubuntu, the ``pprof`` utility is called ``google-pprof``."
msgstr ""
"В дистрибутивах Debian/Ubuntu утилита ``pprof`` называется ``google-"
"pprof``."

#: ../doc/1.10/book/admin/server_introspection.rst:549
msgid "Your output should look similar to this:"
msgstr "В консоль должно выводиться приблизительно следующее:"

#: ../doc/1.10/book/admin/server_introspection.rst:551
#, python-format
msgid ""
"Total: 598 samples\n"
"      83 13.9% 13.9% 83 13.9% epoll_wait\n"
"      54 9.0% 22.9% 102 17.1%\n"
"vy_mem_tree_insert.constprop.35\n"
"      32 5.4% 28.3% 34 5.7% __write_nocancel\n"
"      28 4.7% 32.9% 42 7.0% vy_mem_iterator_start_from\n"
"      26 4.3% 37.3% 26 4.3% _IO_str_seekoff\n"
"      21 3.5% 40.8% 21 3.5% tuple_compare_field\n"
"      19 3.2% 44.0% 19 3.2%\n"
"::TupleCompareWithKey::compare\n"
"      19 3.2% 47.2% 38 6.4% tuple_compare_slowpath\n"
"      12 2.0% 49.2% 23 3.8% __libc_calloc\n"
"       9 1.5% 50.7% 9 1.5%\n"
"::TupleCompare::compare@42efc0\n"
"       9 1.5% 52.2% 9 1.5% vy_cache_on_write\n"
"       9 1.5% 53.7% 57 9.5% vy_merge_iterator_next_key\n"
"       8 1.3% 55.0% 8 1.3% __nss_passwd_lookup\n"
"       6 1.0% 56.0% 25 4.2% gc_onestep\n"
"       6 1.0% 57.0% 6 1.0% lj_tab_next\n"
"       5 0.8% 57.9% 5 0.8% lj_alloc_malloc\n"
"       5 0.8% 58.7% 131 21.9% vy_prepare"
msgstr ""
"Total: 598 samples\n"
"      83 13.9% 13.9% 83 13.9% epoll_wait\n"
"      54 9.0% 22.9% 102 17.1%\n"
"vy_mem_tree_insert.constprop.35\n"
"      32 5.4% 28.3% 34 5.7% __write_nocancel\n"
"      28 4.7% 32.9% 42 7.0% vy_mem_iterator_start_from\n"
"      26 4.3% 37.3% 26 4.3% _IO_str_seekoff\n"
"      21 3.5% 40.8% 21 3.5% tuple_compare_field\n"
"      19 3.2% 44.0% 19 3.2%\n"
"::TupleCompareWithKey::compare\n"
"      19 3.2% 47.2% 38 6.4% tuple_compare_slowpath\n"
"      12 2.0% 49.2% 23 3.8% __libc_calloc\n"
"       9 1.5% 50.7% 9 1.5%\n"
"::TupleCompare::compare@42efc0\n"
"       9 1.5% 52.2% 9 1.5% vy_cache_on_write\n"
"       9 1.5% 53.7% 57 9.5% vy_merge_iterator_next_key\n"
"       8 1.3% 55.0% 8 1.3% __nss_passwd_lookup\n"
"       6 1.0% 56.0% 25 4.2% gc_onestep\n"
"       6 1.0% 57.0% 6 1.0% lj_tab_next\n"
"       5 0.8% 57.9% 5 0.8% lj_alloc_malloc\n"
"       5 0.8% 58.7% 131 21.9% vy_prepare"

#: ../doc/1.10/book/admin/server_introspection.rst:577
msgid "perf"
msgstr "perf"

#: ../doc/1.10/book/admin/server_introspection.rst:579
msgid ""
"This tool for performance monitoring and analysis is installed separately"
" via your package manager. Try running the ``perf`` command in the "
"terminal and follow the prompts to install the necessary package(s)."
msgstr ""
"Этот инструмент для мониторинга и анализа производительности "
"устанавливается отдельно с помощью пакетного менеджера. Попробуйте ввести"
" в окне консоли команду ``perf`` и следуйте подсказкам, чтобы установить "
"необходимые пакеты."

#: ../doc/1.10/book/admin/server_introspection.rst:585
msgid ""
"By default, some ``perf`` commands are restricted to **root**, so, to be "
"on the safe side, either run all commands as **root** or prepend them "
"with ``sudo``."
msgstr ""
"По умолчанию некоторые команды из пакета ``perf`` можно выполнять только "
"с **root**-правами, поэтому необходимо либо зайти в систему из-под "
"пользователя **root**, либо добавлять перед каждой командой ``sudo``."

#: ../doc/1.10/book/admin/server_introspection.rst:589
msgid "To start gathering performance statistics, say:"
msgstr ""
"Чтобы начать сбор показателей производительности, выполните следующую "
"команду:"

#: ../doc/1.10/book/admin/server_introspection.rst:591
msgid "$ perf record -g -p $(pidof tarantool INSTANCENAME.lua)"
msgstr "$ perf record -g -p $(pidof tarantool INSTANCENAME.lua)"

#: ../doc/1.10/book/admin/server_introspection.rst:595
msgid ""
"This command saves the gathered data to a file named ``perf.data`` inside"
" the current working directory. To stop this process (usually, after "
"10-15 seconds), press **ctrl+C**. In your console, you’ll see:"
msgstr ""
"Эта команда сохраняет собранные данные в файл ``perf.data``, который "
"находится в текущей рабочей папке. Для остановки процесса (обычно через "
"10-15 секунд) нажмите **ctrl+C**. В консоли должно появиться следующее:"

#: ../doc/1.10/book/admin/server_introspection.rst:599
msgid ""
"^C[ perf record: Woken up 1 times to write data ]\n"
"[ perf record: Captured and wrote 0.225 MB perf.data (1573 samples) ]"
msgstr ""
"^C[ perf record: Woken up 1 times to write data ]\n"
"[ perf record: Captured and wrote 0.225 MB perf.data (1573 samples) ]"

#: ../doc/1.10/book/admin/server_introspection.rst:604
msgid "Now run the following command:"
msgstr "Затем выполните эту команду:"

#: ../doc/1.10/book/admin/server_introspection.rst:606
msgid "$ perf report -n -g --stdio | tee perf-report.txt"
msgstr "$ perf report -n -g --stdio | tee perf-report.txt"

#: ../doc/1.10/book/admin/server_introspection.rst:610
msgid ""
"It formats the statistical data in the ``perf.data`` file into a "
"performance report and writes it to the ``perf-report.txt`` file."
msgstr ""
"Она превращает содержащиеся в ``perf.data`` статистические данные в отчет"
"  о производительности, который сохраняется в файл ``perf-report.txt``."

#: ../doc/1.10/book/admin/server_introspection.rst:613
msgid "The resulting output should look similar to this:"
msgstr "Получившийся отчет выглядит следующим образом:"

#: ../doc/1.10/book/admin/server_introspection.rst:615
#, python-format
msgid ""
"# Samples: 14K of event 'cycles'\n"
"# Event count (approx.): 9927346847\n"
"#\n"
"# Children Self Samples Command Shared Object Symbol\n"
"# ........ ........ ............ ......... .................. "
".......................................\n"
"#\n"
"    35.50% 0.55% 79 tarantool tarantool [.] lj_gc_step\n"
"            |\n"
"             --34.95%--lj_gc_step\n"
"                       |\n"
"                       |--29.26%--gc_onestep\n"
"                       | |\n"
"                       | |--13.85%--gc_sweep\n"
"                       | | |\n"
"                       | | |--5.59%--lj_alloc_free\n"
"                       | | |\n"
"                       | | |--1.33%--lj_tab_free\n"
"                       | | | |\n"
"                       | | | --1.01%--lj_alloc_free\n"
"                       | | |\n"
"                       | | --1.17%--lj_cdata_free\n"
"                       | |\n"
"                       | |--5.41%--gc_finalize\n"
"                       | | |\n"
"                       | | |--1.06%--lj_obj_equal\n"
"                       | | |\n"
"                       | | --0.95%--lj_tab_set\n"
"                       | |\n"
"                       | |--4.97%--rehashtab\n"
"                       | | |\n"
"                       | | --3.65%--lj_tab_resize\n"
"                       | | |\n"
"                       | | |--0.74%--lj_tab_set\n"
"                       | | |\n"
"                       | | --0.72%--lj_tab_newkey\n"
"                       | |\n"
"                       | |--0.91%--propagatemark\n"
"                       | |\n"
"                       | --0.67%--lj_cdata_free\n"
"                       |\n"
"                        --5.43%--propagatemark\n"
"                                  |\n"
"                                   --0.73%--gc_mark"
msgstr ""
"# Samples: 14K of event 'cycles'\n"
"# Event count (approx.): 9927346847\n"
"#\n"
"# Children Self Samples Command Shared Object Symbol\n"
"# ........ ........ ............ ......... .................. "
".......................................\n"
"#\n"
"    35.50% 0.55% 79 tarantool tarantool [.] lj_gc_step\n"
"            |\n"
"             --34.95%--lj_gc_step\n"
"                       |\n"
"                       |--29.26%--gc_onestep\n"
"                       | |\n"
"                       | |--13.85%--gc_sweep\n"
"                       | | |\n"
"                       | | |--5.59%--lj_alloc_free\n"
"                       | | |\n"
"                       | | |--1.33%--lj_tab_free\n"
"                       | | | |\n"
"                       | | | --1.01%--lj_alloc_free\n"
"                       | | |\n"
"                       | | --1.17%--lj_cdata_free\n"
"                       | |\n"
"                       | |--5.41%--gc_finalize\n"
"                       | | |\n"
"                       | | |--1.06%--lj_obj_equal\n"
"                       | | |\n"
"                       | | --0.95%--lj_tab_set\n"
"                       | |\n"
"                       | |--4.97%--rehashtab\n"
"                       | | |\n"
"                       | | --3.65%--lj_tab_resize\n"
"                       | | |\n"
"                       | | |--0.74%--lj_tab_set\n"
"                       | | |\n"
"                       | | --0.72%--lj_tab_newkey\n"
"                       | |\n"
"                       | |--0.91%--propagatemark\n"
"                       | |\n"
"                       | --0.67%--lj_cdata_free\n"
"                       |\n"
"                        --5.43%--propagatemark\n"
"                                  |\n"
"                                   --0.73%--gc_mark"

#: ../doc/1.10/book/admin/server_introspection.rst:661
msgid ""
"Unlike the poor man’s profilers, ``gperftools`` and ``perf`` have low "
"overhead (almost negligible as compared with ``pstack`` and ``gdb``): "
"they don’t result in long delays when attaching to a process and "
"therefore can be used without serious consequences."
msgstr ""
"Инструменты ``gperftools`` и ``perf`` отличаются от ``pstack`` и ``gdb`` "
"низкой затратой ресурсов (пренебрежимо малой по сравнению с ``pstack`` и "
"``gdb``): они подключаются к работающим процессам без больших задержек, а"
" потому могут использоваться без серьезных последствий."

#: ../doc/1.10/book/admin/server_introspection.rst:668
msgid "jit.p"
msgstr "jit.p"

#: ../doc/1.10/book/admin/server_introspection.rst:671
msgid ""
"The jit.p profiler comes with the Tarantool application server, to load "
"it one only needs to say ``require('jit.p')`` or "
"``require('jit.profile')``. There are many options for sampling and "
"display, they are described in the documentation for `The LuaJIT Profiler"
" <http://www.luatex.org/svn/trunk/source/libs/luajit/LuaJIT-"
"src/doc/ext_profiler.html>`_."
msgstr ""
"Профилировщик \"jit.p\" входит в комплект сервера приложений Tarantool'а."
" Чтобы загрузить его, выполните команду ``require('jit.p')`` или "
"``require('jit.profile')``. Есть много параметров для настройки выборки и"
" вывода, они описаны в документации по `Профилировщику LuaJIT "
"<http://www.luatex.org/svn/trunk/source/libs/luajit/LuaJIT-"
"src/doc/ext_profiler.html>`_."

#: ../doc/1.10/book/admin/server_introspection.rst:679
msgid ""
"Make a function that calls a function named f1 that does 500,000 inserts "
"and deletes in a Tarantool space. Start the profiler, execute the "
"function, stop the profiler, and show what the profiler sampled."
msgstr ""
"Создайте функцию для вызова функции под названием f1, которая "
"осуществляет 500 000 вставок и удалений в спейсе Tarantool'а. Запустите "
"профилировщик, выполните функцию, завершите работу профилировщика. "
"Получите результат выборки профилировщика."

#: ../doc/1.10/book/admin/server_introspection.rst:684
msgid ""
"box.space.t:drop()\n"
"box.schema.space.create('t')\n"
"box.space.t:create_index('i')\n"
"function f1() for i = 1,500000 do\n"
"  box.space.t:insert{i}\n"
"  box.space.t:delete{i}\n"
"  end\n"
"return 1\n"
"end\n"
"function f3() f1() end\n"
"jit_p = require(\"jit.profile\")\n"
"sampletable = {}\n"
"jit_p.start(\"f\", function(thread, samples, vmstate)\n"
"  local dump=jit_p.dumpstack(thread, \"f\", 1)\n"
"  sampletable[dump] = (sampletable[dump] or 0) + samples\n"
"end)\n"
"f3()\n"
"jit_p.stop()\n"
"for d,v in pairs(sampletable) do print(v, d) end"
msgstr ""
"box.space.t:drop()\n"
"box.schema.space.create('t')\n"
"box.space.t:create_index('i')\n"
"function f1() for i = 1,500000 do\n"
"  box.space.t:insert{i}\n"
"  box.space.t:delete{i}\n"
"  end\n"
"return 1\n"
"end\n"
"function f3() f1() end\n"
"jit_p = require(\"jit.profile\")\n"
"sampletable = {}\n"
"jit_p.start(\"f\", function(thread, samples, vmstate)\n"
"  local dump=jit_p.dumpstack(thread, \"f\", 1)\n"
"  sampletable[dump] = (sampletable[dump] or 0) + samples\n"
"end)\n"
"f3()\n"
"jit_p.stop()\n"
"for d,v in pairs(sampletable) do print(v, d) end"

#: ../doc/1.10/book/admin/server_introspection.rst:706
msgid ""
"Typically the result will show that the sampling happened within f1() "
"many times, but also within internal Tarantool functions, whose names may"
" change with each new version."
msgstr ""
"Как правило, результат покажет, что выборка многократно осуществлялась в "
"рамках f1(), а также в рамках внутренних функций Tarantool'а, имена "
"которых могут изменяться с каждой новой версией."

#: ../doc/1.10/book/admin/start_stop_instance.rst:39
msgid "Starting/stopping an instance"
msgstr "Запуск/остановка экземпляра"

#: ../doc/1.10/book/admin/start_stop_instance.rst:41
msgid ""
"While a Lua application is executed by Tarantool, an instance file is "
"executed by ``tarantoolctl`` which is a Tarantool script."
msgstr ""
"Lua-приложение выполняется Tarantool'ом, тогда как файл экземпляра "
"выполняется Tarantool-скриптом ``tarantoolctl``."

#: ../doc/1.10/book/admin/start_stop_instance.rst:44
msgid "Here is what ``tarantoolctl`` does when you issue the command:"
msgstr "Вот что делает ``tarantoolctl`` при вводе следующей команды:"

#: ../doc/1.10/book/admin/start_stop_instance.rst:46
msgid "$ tarantoolctl start <instance_name>"
msgstr "$ tarantoolctl start <имя_экземпляра>"

#: ../doc/1.10/book/admin/start_stop_instance.rst:50
msgid ""
"Read and parse the command line arguments. The last argument, in our "
"case, contains an instance name."
msgstr ""
"Считывает и разбирает аргументы командной строки. В нашем случае "
"последний аргумент содержит имя экземпляра."

#: ../doc/1.10/book/admin/start_stop_instance.rst:53
msgid ""
"Read and parse its own configuration file. This file contains "
"``tarantoolctl`` defaults, like the path to the directory where instances"
" should be searched for."
msgstr ""
"Считывает и разбирает собственный конфигурационный файл. Этот файл "
"содержит параметры ``tarantoolctl`` по умолчанию -- такие как путь до "
"директории, в которой располагаются экземпляры."

#: ../doc/1.10/book/admin/start_stop_instance.rst:57
msgid ""
"When ``tarantool`` is invoked by root, it looks for a configuration file "
"in ``/etc/default/tarantool``. When ``tarantool`` is invoked by a local "
"(non-root) user, it looks for a configuration file first in the current "
"directory (``$PWD/.tarantoolctl``), and then in the current user's home "
"directory (``$HOME/.config/tarantool/tarantool``). If no configuration "
"file is found there, or in the ``/usr/local/etc/default/tarantool`` file,"
" then ``tarantoolctl`` falls back to :ref:`built-in defaults <admin-"
"tarantoolctl_config_file>`."
msgstr ""
"Когда ``tarantoolctl`` вызывается с root-правами, он ищет "
"конфигурационный файл в ``/etc/default/tarantool``. Если вызов "
"``tarantool`` производит локальный пользователь, сначала он ищет "
"конфигурационный файл в текущей директории (``$PWD/.tarantoolctl``), а "
"затем в домашней директории текущего пользователя "
"(``$HOME/.config/tarantool/tarantool``). Если конфигурационный файл не "
"найден, ``tarantoolctl`` принимает :ref:`встроенные параметры по "
"умолчанию <admin-tarantoolctl_config_file>`."

#: ../doc/1.10/book/admin/start_stop_instance.rst:66
msgid ""
"Look up the instance file in the instance directory, for example "
"``/etc/tarantool/instances.enabled``. To build the instance file path, "
"``tarantoolctl`` takes the instance name, prepends the instance directory"
" and appends \".lua\" extension to the instance file."
msgstr ""
"Ищет файл экземпляра в директории, где располагаются экземпляры, "
"например, в ``/etc/tarantool/instances.enabled``. ``tarantoolctl`` строит"
" путь до файла экземпляра следующим образом: \"путь до директории с "
"экземплярами\" + \"имя экземпляра\" + \".lua\"."

#: ../doc/1.10/book/admin/start_stop_instance.rst:71
msgid ""
"Override :ref:`box.cfg{} <box_introspection-box_cfg>` function to pre-"
"process its parameters and ensure that instance paths are pointing to the"
" paths defined in the ``tarantoolctl`` configuration file. For example, "
"if the configuration file specifies that instance work directory must be "
"in ``/var/tarantool``, then the new implementation of ``box.cfg{}`` "
"ensures that :ref:`work_dir <cfg_basic-work_dir>` parameter in "
"``box.cfg{}`` is set to ``/var/tarantool/<instance_name>``, regardless of"
" what the path is set to in the instance file itself."
msgstr ""
"Переопределяет функцию :ref:`box.cfg{} <box_introspection-box_cfg>`, "
"чтобы предобработать ее параметры и сделать так, чтобы пути к экземплярам"
"  указывали на пути, прописанные в конфигурационном файле "
"``tarantoolctl``. Например, если в конфигурационном файле указано, что "
"рабочей директорией экземпляра является ``/var/tarantool``, то новая "
"реализация ``box.cfg{}`` сделает так, чтобы параметр :ref:`work_dir "
"<cfg_basic-work_dir>` в ``box.cfg{}`` имел значение "
"``/var/tarantool/<имя_экземпляра>``, независимо от того, какой путь "
"указан в самом файле экземпляра."

#: ../doc/1.10/book/admin/start_stop_instance.rst:80
msgid ""
"Create a so-called \"instance control file\". This is a Unix socket with "
"Lua console attached to it. This file is used later by ``tarantoolctl`` "
"to query the instance state, send commands to the instance and so on."
msgstr ""
"Создает так называемый \"файл для управления экземпляром\". Это "
"Unix-сокет с прикрепленной к нему Lua-консолью. В дальнейшем "
"``tarantoolctl`` использует этот файл для получения состояния экземпляра,"
"  отправки команд и т.д."

#: ../doc/1.10/book/admin/start_stop_instance.rst:84
msgid ""
"Set the TARANTOOLCTL environment variable to 'true'. This allows the user"
" to know that the instance was started by ``tarantoolctl``."
msgstr ""
"Задает значение переменной окружения TARANTOOLCTL = 'true'. Это позволит "
"пользователю понять, что экземпляр был запущен ``tarantoolctl``."

#: ../doc/1.10/book/admin/start_stop_instance.rst:87
msgid "Finally, use Lua ``dofile`` command to execute the instance file."
msgstr ""
"Наконец, использует Lua-команду ``dofile`` для выполнения файла "
"экземпляра."

#: ../doc/1.10/book/admin/start_stop_instance.rst:89
msgid ""
"If you start an instance using ``systemd`` tools, like this (the instance"
" name is ``my_app``):"
msgstr ""
"При запуске экземпляра с помощью инструментария ``systemd`` указанным "
"ниже способом (имя экземпляра -- ``my_app``):"

#: ../doc/1.10/book/admin/start_stop_instance.rst:92
msgid ""
"$ systemctl start tarantool@my_app\n"
"$ ps axuf|grep exampl[e]\n"
"taranto+  5350  1.3  0.3 1448872 7736 ?        Ssl  20:05   0:28 "
"tarantool my_app.lua <running>"
msgstr ""
"$ systemctl start tarantool@my_app\n"
"$ ps axuf|grep exampl[e]\n"
"taranto+  5350  1.3  0.3 1448872 7736 ?        Ssl  20:05   0:28 "
"tarantool my_app.lua <running>"

#: ../doc/1.10/book/admin/start_stop_instance.rst:98
msgid ""
"... this actually calls ``tarantoolctl`` like in case of ``tarantoolctl "
"start my_app``."
msgstr ""
"...на самом деле вызывается ``tarantoolctl`` -- так же, как и в случае "
"``tarantoolctl start my_app``."

#: ../doc/1.10/book/admin/start_stop_instance.rst:101
msgid ""
"To check the instance file for syntax errors prior to starting ``my_app``"
" instance, say:"
msgstr ""
"Для проверки файла экземпляра на наличие синтаксических ошибок перед "
"запуском экземпляра ``my_app`` используйте команду:"

#: ../doc/1.10/book/admin/start_stop_instance.rst:104
msgid "$ tarantoolctl check my_app"
msgstr "$ tarantoolctl check my_app"

#: ../doc/1.10/book/admin/start_stop_instance.rst:108
msgid "To enable ``my_app`` instance for auto-load during system startup, say:"
msgstr ""
"Для включения автоматической загрузки экземпляра ``my_app`` при запуске "
"всей системы используйте команду:"

#: ../doc/1.10/book/admin/start_stop_instance.rst:110
msgid "$ systemctl enable tarantool@my_app"
msgstr "$ systemctl enable tarantool@my_app"

#: ../doc/1.10/book/admin/start_stop_instance.rst:114
msgid "To stop a running ``my_app`` instance, say:"
msgstr "Для остановки работающего экземпляра ``my_app`` используйте команду:"

#: ../doc/1.10/book/admin/start_stop_instance.rst:116
msgid ""
"$ tarantoolctl stop my_app\n"
"$ # - OR -\n"
"$ systemctl stop tarantool@my_app"
msgstr ""
"$ tarantoolctl stop my_app\n"
"$ # - ИЛИ -\n"
"$ systemctl stop tarantool@my_app"

#: ../doc/1.10/book/admin/start_stop_instance.rst:122
msgid "To restart (i.e. stop and start) a running ``my_app`` instance, say:"
msgstr ""
"Для перезапуска (т.е. остановки и запуска) работающего экземпляра "
"``my_app`` используйте команду:"

#: ../doc/1.10/book/admin/start_stop_instance.rst:124
msgid ""
"$ tarantoolctl restart my_app\n"
"$ # - OR -\n"
"$ systemctl restart tarantool@my_app"
msgstr ""
"$ tarantoolctl restart my_app\n"
"$ # - ИЛИ -\n"
"$ systemctl restart tarantool@my_app"

#: ../doc/1.10/book/admin/start_stop_instance.rst:134
msgid "Running Tarantool locally"
msgstr "Локальный запуск Tarantool'а"

#: ../doc/1.10/book/admin/start_stop_instance.rst:136
msgid ""
"Sometimes you may need to run a Tarantool instance locally, e.g. for test"
" purposes. Let's configure a local instance, then start and monitor it "
"with ``tarantoolctl``."
msgstr ""
"Иногда бывает необходимо запустить Tarantool локально -- например, для "
"тестирования. Давайте настроим локальный экземпляр, запустим его и будем "
"мониторить с помощью ``tarantoolctl``."

#: ../doc/1.10/book/admin/start_stop_instance.rst:140
msgid "First, we create a sandbox directory on the user's path:"
msgstr "Сперва создадим директорию-песочницу по следующему пути:"

#: ../doc/1.10/book/admin/start_stop_instance.rst:142
msgid "$ mkdir ~/tarantool_test"
msgstr "$ mkdir ~/tarantool_test"

#: ../doc/1.10/book/admin/start_stop_instance.rst:146
msgid ""
"... and set default ``tarantoolctl`` configuration in "
"``$HOME/.config/tarantool/tarantool``. Let the file contents be:"
msgstr ""
"...и поместим конфигурационный файл с параметрами ``tarantoolctl`` по "
"умолчанию в ``$HOME/.config/tarantool/tarantool``. Содержимое файла будет"
" таким:"

#: ../doc/1.10/book/admin/start_stop_instance.rst:149
msgid ""
"default_cfg = {\n"
"    pid_file  = \"/home/user/tarantool_test/my_app.pid\",\n"
"    wal_dir   = \"/home/user/tarantool_test\",\n"
"    snap_dir  = \"/home/user/tarantool_test\",\n"
"    vinyl_dir = \"/home/user/tarantool_test\",\n"
"    log       = \"/home/user/tarantool_test/log\",\n"
"}\n"
"instance_dir = \"/home/user/tarantool_test\""
msgstr ""
"default_cfg = {\n"
"    pid_file  = \"/home/user/tarantool_test/my_app.pid\",\n"
"    wal_dir   = \"/home/user/tarantool_test\",\n"
"    snap_dir  = \"/home/user/tarantool_test\",\n"
"    vinyl_dir = \"/home/user/tarantool_test\",\n"
"    log       = \"/home/user/tarantool_test/log\",\n"
"}\n"
"instance_dir = \"/home/user/tarantool_test\""

#: ../doc/1.10/book/admin/start_stop_instance.rst:162
msgid "Specify a full path to the user's home directory instead of \"~/\"."
msgstr "Указывайте полный путь к домашней директории пользователя вместо \"~/\"."

#: ../doc/1.10/book/admin/start_stop_instance.rst:164
msgid ""
"Omit ``username`` parameter. ``tarantoolctl`` normally doesn't have "
"permissions to switch current user when invoked by a local user. The "
"instance will be running under 'admin'."
msgstr ""
"Опустите параметр ``username``. Обычно, когда запуск производит локальный"
"  пользователь, у ``tarantoolctl`` нет разрешения на смену текущего "
"пользователя. Экземпляр будет работать с пользователем 'admin'."

#: ../doc/1.10/book/admin/start_stop_instance.rst:168
msgid ""
"Next, we create the instance file ``~/tarantool_test/my_app.lua``. Let "
"the file contents be:"
msgstr ""
"Далее создадим файл экземпляра ``~/tarantool_test/my_app.lua``. "
"Содержимое файла будет таким:"

#: ../doc/1.10/book/admin/start_stop_instance.rst:171
msgid ""
"box.cfg{listen = 3301}\n"
"box.schema.user.passwd('Gx5!')\n"
"box.schema.user.grant('guest','read,write,execute','universe')\n"
"fiber = require('fiber')\n"
"box.schema.space.create('tester')\n"
"box.space.tester:create_index('primary',{})\n"
"i = 0\n"
"while 0 == 0 do\n"
"    fiber.sleep(5)\n"
"    i = i + 1\n"
"    print('insert ' .. i)\n"
"    box.space.tester:insert{i, 'my_app tuple'}\n"
"end"
msgstr ""
"box.cfg{listen = 3301}\n"
"box.schema.user.passwd('Gx5!')\n"
"box.schema.user.grant('guest','read,write,execute','universe')\n"
"fiber = require('fiber')\n"
"box.schema.space.create('tester')\n"
"box.space.tester:create_index('primary',{})\n"
"i = 0\n"
"while 0 == 0 do\n"
"    fiber.sleep(5)\n"
"    i = i + 1\n"
"    print('insert ' .. i)\n"
"    box.space.tester:insert{i, 'my_app tuple'}\n"
"end"

#: ../doc/1.10/book/admin/start_stop_instance.rst:187
msgid ""
"Let’s verify our instance file by starting it without ``tarantoolctl`` "
"first:"
msgstr "Проверим наш файл экземпляра, сперва запустив его без ``tarantoolctl``:"

#: ../doc/1.10/book/admin/start_stop_instance.rst:189
msgid ""
"$ cd ~/tarantool_test\n"
"$ tarantool my_app.lua\n"
"2017-04-06 10:42:15.762 [54085] main/101/my_app.lua C> version "
"1.7.3-489-gd86e36d5b\n"
"2017-04-06 10:42:15.763 [54085] main/101/my_app.lua C> log level 5\n"
"2017-04-06 10:42:15.764 [54085] main/101/my_app.lua I> mapping 268435456 "
"bytes for tuple arena...\n"
"2017-04-06 10:42:15.774 [54085] iproto/101/main I> binary: bound to "
"[::]:3301\n"
"2017-04-06 10:42:15.774 [54085] main/101/my_app.lua I> initializing an "
"empty data directory\n"
"2017-04-06 10:42:15.789 [54085] snapshot/101/main I> saving snapshot "
"`./00000000000000000000.snap.inprogress'\n"
"2017-04-06 10:42:15.790 [54085] snapshot/101/main I> done\n"
"2017-04-06 10:42:15.791 [54085] main/101/my_app.lua I> vinyl checkpoint "
"done\n"
"2017-04-06 10:42:15.791 [54085] main/101/my_app.lua I> ready to accept "
"requests\n"
"insert 1\n"
"insert 2\n"
"insert 3\n"
"<...>"
msgstr ""
"$ cd ~/tarantool_test\n"
"$ tarantool my_app.lua\n"
"2017-04-06 10:42:15.762 [54085] main/101/my_app.lua C> version "
"1.7.3-489-gd86e36d5b\n"
"2017-04-06 10:42:15.763 [54085] main/101/my_app.lua C> log level 5\n"
"2017-04-06 10:42:15.764 [54085] main/101/my_app.lua I> mapping 268435456 "
"bytes for tuple arena...\n"
"2017-04-06 10:42:15.774 [54085] iproto/101/main I> binary: bound to "
"[::]:3301\n"
"2017-04-06 10:42:15.774 [54085] main/101/my_app.lua I> initializing an "
"empty data directory\n"
"2017-04-06 10:42:15.789 [54085] snapshot/101/main I> saving snapshot "
"`./00000000000000000000.snap.inprogress'\n"
"2017-04-06 10:42:15.790 [54085] snapshot/101/main I> done\n"
"2017-04-06 10:42:15.791 [54085] main/101/my_app.lua I> vinyl checkpoint "
"done\n"
"2017-04-06 10:42:15.791 [54085] main/101/my_app.lua I> ready to accept "
"requests\n"
"insert 1\n"
"insert 2\n"
"insert 3\n"
"<...>"

#: ../doc/1.10/book/admin/start_stop_instance.rst:207
msgid "Now we tell ``tarantoolctl`` to start the Tarantool instance:"
msgstr "Запустим экземпляр Tarantool'а с помощью ``tarantoolctl``:"

#: ../doc/1.10/book/admin/start_stop_instance.rst:209
msgid "$ tarantoolctl start my_app"
msgstr "$ tarantoolctl start my_app"

#: ../doc/1.10/book/admin/start_stop_instance.rst:213
msgid "Expect to see messages indicating that the instance has started. Then:"
msgstr ""
"В консоли должны появиться сообщения о том, что экземпляр запущен. Затем "
"выполним следующую команду:"

#: ../doc/1.10/book/admin/start_stop_instance.rst:215
msgid "$ ls -l ~/tarantool_test/my_app"
msgstr "$ ls -l ~/tarantool_test/my_app"

#: ../doc/1.10/book/admin/start_stop_instance.rst:219
msgid "Expect to see the .snap file and the .xlog file. Then:"
msgstr ""
"В консоли должны появиться .snap-файл и .xlog-файл. Затем выполним "
"следующую команду:"

#: ../doc/1.10/book/admin/start_stop_instance.rst:221
msgid "$ less ~/tarantool_test/log/my_app.log"
msgstr "$ less ~/tarantool_test/log/my_app.log"

#: ../doc/1.10/book/admin/start_stop_instance.rst:225
msgid ""
"Expect to see the contents of ``my_app``‘s log, including error messages,"
" if any. Then:"
msgstr ""
"В консоли должно отобразиться содержимое файла журнала для приложения "
"``my_app``, в том числе сообщения об ошибках, если они были. Затем "
"выполним серию команд:"

#: ../doc/1.10/book/admin/start_stop_instance.rst:228
msgid ""
"$ tarantoolctl enter my_app\n"
"tarantool> box.cfg{}\n"
"tarantool> console = require('console')\n"
"tarantool> console.connect('localhost:3301')\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})"
msgstr ""
"$ tarantoolctl enter my_app\n"
"tarantool> box.cfg{}\n"
"tarantool> console = require('console')\n"
"tarantool> console.connect('localhost:3301')\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})"

#: ../doc/1.10/book/admin/start_stop_instance.rst:236
msgid "Expect to see several tuples that ``my_app`` has created."
msgstr ""
"В консоли должны появиться несколько кортежей, которые создало приложение"
" ``my_app``."

#: ../doc/1.10/book/admin/start_stop_instance.rst:238
msgid ""
"Stop now. A polite way to stop ``my_app`` is with ``tarantoolctl``, thus "
"we say:"
msgstr ""
"Теперь остановим приложение ``my_app``. Корректный способ остановки -- "
"это использовать``tarantoolctl``:"

#: ../doc/1.10/book/admin/start_stop_instance.rst:240
msgid "$ tarantoolctl stop my_app"
msgstr "$ tarantoolctl stop my_app"

#: ../doc/1.10/book/admin/start_stop_instance.rst:244
msgid "Finally, we make a cleanup."
msgstr "Последний шаг -- удаление тестовых данных."

#: ../doc/1.10/book/admin/start_stop_instance.rst:246
msgid "$ rm -R tarantool_test"
msgstr "$ rm -R tarantool_test"

#: ../doc/1.10/book/admin/troubleshoot.rst:39
msgid "Troubleshooting guide"
msgstr "Руководство по разрешению проблем"

#: ../doc/1.10/book/admin/troubleshoot.rst:41
msgid ""
"For this guide, you need to install Tarantool `stat "
"<https://github.com/tarantool/stat>`_ module:"
msgstr ""
"В данном руководстве используется сторонний модуль `stat "
"<https://github.com/tarantool/stat>`_. Для его установки выполните "
"команду:"

#: ../doc/1.10/book/admin/troubleshoot.rst:44
msgid ""
"$ sudo yum install tarantool-stat\n"
"$ # -- OR --\n"
"$ sudo apt-get install tarantool-stat"
msgstr ""
"$ sudo yum install tarantool-stat\n"
"$ # -- ИЛИ --\n"
"$ sudo apt-get install tarantool-stat"

#: ../doc/1.10/book/admin/troubleshoot.rst:54
msgid "Problem: INSERT/UPDATE-requests result in ER_MEMORY_ISSUE error"
msgstr ""
"Проблема: при выполнении INSERT/UPDATE-запросов возникает ошибка "
"ER_MEMORY_ISSUE"

#: ../doc/1.10/book/admin/troubleshoot.rst:56
#: ../doc/1.10/book/admin/troubleshoot.rst:114
#: ../doc/1.10/book/admin/troubleshoot.rst:160
#: ../doc/1.10/book/admin/troubleshoot.rst:222
#: ../doc/1.10/book/admin/troubleshoot.rst:245
#: ../doc/1.10/book/admin/troubleshoot.rst:270
#: ../doc/1.10/book/admin/troubleshoot.rst:287
#: ../doc/1.10/book/admin/troubleshoot.rst:322
msgid "**Possible reasons**"
msgstr "**Возможные причины**"

#: ../doc/1.10/book/admin/troubleshoot.rst:58
msgid ""
"Lack of RAM (parameters ``arena_used_ratio`` and ``quota_used_ratio`` in "
":ref:`box.slab.info() <box_slab_info>` report are getting close to 100%)."
msgstr ""
"Нехватка памяти (значения параметров ``arena_used_ratio`` и "
"``quota_used_ratio`` из  :ref:`box.slab.info() <box_slab_info>` "
"приближаются к 100%)."

#: ../doc/1.10/book/admin/troubleshoot.rst:61
msgid "To check these parameters, say:"
msgstr ""
"Чтобы проверить значения данных параметров, выполните соответствующие "
"команды:"

#: ../doc/1.10/book/admin/troubleshoot.rst:63
#: ../doc/1.10/book/admin/troubleshoot.rst:125
#: ../doc/1.10/book/admin/troubleshoot.rst:182
#: ../doc/1.10/book/admin/troubleshoot.rst:299
#: ../doc/1.10/book/admin/troubleshoot.rst:335
msgid ""
"$ # attaching to a Tarantool instance\n"
"$ tarantoolctl enter <instance_name>\n"
"$ # -- OR --\n"
"$ tarantoolctl connect <URI>"
msgstr ""
"$ # подключаемся к админ-консоли нужного экземпляра\n"
"$ tarantoolctl enter <instance_name>\n"
"$ # -- ИЛИ --\n"
"$ tarantoolctl connect <URI>"

#: ../doc/1.10/book/admin/troubleshoot.rst:70
msgid ""
"-- requesting arena_used_ratio value\n"
"tarantool> require('stat').stat()['slab.arena_used_ratio']\n"
"\n"
"-- requesting quota_used_ratio value\n"
"tarantool> require('stat').stat()['slab.quota_used_ratio']"
msgstr ""
"-- запрашиваем значение arena_used_ratio\n"
"tarantool> require('stat').stat()['slab.arena_used_ratio']\n"
"\n"
"-- запрашиваем значение quota_used_ratio\n"
"tarantool> require('stat').stat()['slab.quota_used_ratio']"

#: ../doc/1.10/book/admin/troubleshoot.rst:78
#: ../doc/1.10/book/admin/troubleshoot.rst:119
#: ../doc/1.10/book/admin/troubleshoot.rst:170
#: ../doc/1.10/book/admin/troubleshoot.rst:203
#: ../doc/1.10/book/admin/troubleshoot.rst:227
#: ../doc/1.10/book/admin/troubleshoot.rst:250
#: ../doc/1.10/book/admin/troubleshoot.rst:274
#: ../doc/1.10/book/admin/troubleshoot.rst:295
#: ../doc/1.10/book/admin/troubleshoot.rst:326
msgid "**Solution**"
msgstr "**Решение**"

#: ../doc/1.10/book/admin/troubleshoot.rst:80
#: ../doc/1.10/book/admin/troubleshoot.rst:172
msgid "Try either of the following measures:"
msgstr "У вас есть несколько вариантов действий:"

#: ../doc/1.10/book/admin/troubleshoot.rst:82
msgid ""
"In Tarantool's :ref:`instance file <admin-instance_config>`, increase the"
" value of :ref:`box.cfg{memtx_memory} <cfg_storage-memtx_memory>` (if "
"memory resources are available)."
msgstr ""
"Зайти в :ref:`конфигурационный файл <admin-instance_config>` Tarantool и "
"увеличить значение параметра :ref:`box.cfg{memtx_memory} <cfg_storage-"
"memtx_memory>` (при наличии свободных ресурсов)."

#: ../doc/1.10/book/admin/troubleshoot.rst:86
#, python-format
msgid ""
"In versions of Tarantool before 1.10, the server needs to be restarted to"
" change this parameter. The Tarantool server will be unavailable while "
"restarting from .xlog files, unless you restart it using :ref:`hot "
"standby <index-hot_standby>` mode. In the latter case, nearly 100% server"
" availability is guaranteed."
msgstr ""
"В версиях Tarantool'а до 1.10 для изменения данного параметра требуется "
"перезагрузить сервер. При обычной перезагрузке сервер будет недоступен на"
" время старта Tarantool из .xlog-файлов. При перезагрузке в режиме "
"горячего резервирования :ref:`hot standby <index-hot_standby>` "
"гарантирована практически 100%-ная доступность."

#: ../doc/1.10/book/admin/troubleshoot.rst:92
msgid "Clean up the database."
msgstr "Провести очистку базы данных."

#: ../doc/1.10/book/admin/troubleshoot.rst:94
msgid "Check the indicators of memory fragmentation:"
msgstr "Проверьте, нет ли проблем с фрагментацией памяти:"

#: ../doc/1.10/book/admin/troubleshoot.rst:96
msgid ""
"-- requesting quota_used_ratio value\n"
"tarantool> require('stat').stat()['slab.quota_used_ratio']\n"
"\n"
"-- requesting items_used_ratio value\n"
"tarantool> require('stat').stat()['slab.items_used_ratio']"
msgstr ""
"-- запрашиваем значение quota_used_ratio\n"
"tarantool> require('stat').stat()['slab.quota_used_ratio']\n"
"\n"
"-- запрашиваем значение items_used_ratio\n"
"tarantool> require('stat').stat()['slab.items_used_ratio']"

#: ../doc/1.10/book/admin/troubleshoot.rst:104
msgid ""
"In case of heavy memory fragmentation (``quota_used_ratio`` is getting "
"close to 100%, ``items_used_ratio`` is about 50%), we recommend "
"restarting Tarantool in the :ref:`hot standby <index-hot_standby>` mode."
msgstr ""
"При высокой степени фрагментации памяти (значение параметра "
"``quota_used_ratio`` приближается к 100%, ``items_used_ratio`` около 50%)"
"  рекомендуется перезапустить Tarantool в режиме горячего резервирования "
":ref:`hot standby <index-hot_standby>`."

#: ../doc/1.10/book/admin/troubleshoot.rst:112
msgid "Problem: Tarantool generates too heavy CPU load"
msgstr "Проблема: Tarantool создает большую нагрузку на CPU"

#: ../doc/1.10/book/admin/troubleshoot.rst:116
msgid ""
"The :ref:`transaction processor thread <atomic-threads_fibers_yields>` "
"consumes over 60% CPU."
msgstr ""
":ref:`Поток обработки транзакций <atomic-threads_fibers_yields>` "
"нагружает ЦП более чем на 60%."

#: ../doc/1.10/book/admin/troubleshoot.rst:121
msgid ""
"Attach to the Tarantool instance with :ref:`tarantoolctl <tarantoolctl>` "
"utility, analyze the query statistics with :ref:`box.stat() "
"<box_introspection-box_stat>` and spot the CPU consumption leader. The "
"following commands can help:"
msgstr ""
"Подключиться к Tarantool с помощью утилиты :ref:`tarantoolctl "
"<tarantoolctl>`, внимательно изучить статистику запросов с помощью "
":ref:`box.stat() <box_introspection-box_stat>` и выявить источник "
"потребления. Для этой цели могут оказаться полезными следующие команды:"

#: ../doc/1.10/book/admin/troubleshoot.rst:132
msgid ""
"-- checking the RPS of calling stored procedures\n"
"tarantool> require('stat').stat()['stat.op.call.rps']"
msgstr ""
"-- запрашиваем RPS для вызовов хранимых процедур\n"
"tarantool> require('stat').stat()['stat.op.call.rps']"

#: ../doc/1.10/book/admin/troubleshoot.rst:137
msgid ""
"The critical RPS value is 75 000, boiling down to 10 000 - 20 000 for a "
"rich Lua application (a Lua module of 200+ lines)."
msgstr ""
"Критическое значение RPS -- 75 000, в случае большого Lua-приложения "
"(модульного приложения, содержащего более 200 строк кода) -- 10 000 - 20 "
"000."

#: ../doc/1.10/book/admin/troubleshoot.rst:140
msgid ""
"-- checking RPS per query type\n"
"tarantool> require('stat').stat()['stat.op.<query_type>.rps']"
msgstr ""
"-- запрашиваем RPS для запросов указанного типа\n"
"tarantool> require('stat').stat()['stat.op.<query_type>.rps']"

#: ../doc/1.10/book/admin/troubleshoot.rst:145
msgid ""
"The critical RPS value for SELECT/INSERT/UPDATE/DELETE requests is 100 "
"000."
msgstr ""
"Критическое значение RPS для запросов типа SELECT/INSERT/UPDATE/DELETE --"
" 100 000."

#: ../doc/1.10/book/admin/troubleshoot.rst:147
msgid ""
"If the load is mostly generated by SELECT requests, we recommend adding a"
" :ref:`slave server <replication-bootstrap>` and let it process part of "
"the queries."
msgstr ""
"Если основная нагрузка генерируется SELECT-запросами, следует добавить "
":ref:`slave-сервер <replication-bootstrap>` и часть запросов обрабатывать"
"  на нем."

#: ../doc/1.10/book/admin/troubleshoot.rst:151
msgid ""
"If the load is mostly generated by INSERT/UPDATE/DELETE requests, we "
"recommend :ref:`sharding the database <shard-module>`."
msgstr ""
"Если же нагрузка по большей части приходится на "
"INSERT/UPDATE/DELETE-запросы, рекомендуется провести :ref:`шардинг базы "
"данных <shard-module>`."

#: ../doc/1.10/book/admin/troubleshoot.rst:158
msgid "Problem: Query processing times out"
msgstr "Проблема: обработка запросов прекращается по таймауту"

#: ../doc/1.10/book/admin/troubleshoot.rst:164
msgid ""
"All reasons that we discuss here can be identified by messages in "
"Tarantool's log file, all starting with the words ``'Too long...'``."
msgstr ""
"Все описанные ниже ситуации можно распознать по записям в журнале "
"Tarantool, начинающимся со слов ``'Too long...'``."

#: ../doc/1.10/book/admin/troubleshoot.rst:167
msgid ""
"Both fast and slow queries are processed within a single connection, so "
"the readahead buffer is cluttered with slow queries."
msgstr ""
"Быстрые и медленные запросы обрабатываются в одном подключении, что "
"приводит к забиванию readahead-буфера медленными запросами."

#: ../doc/1.10/book/admin/troubleshoot.rst:174
msgid ""
"Increase the readahead buffer size (:ref:`box.cfg{readahead} "
"<cfg_networking-readahead>` parameter)."
msgstr ""
"Увеличить размер readahead-буфера (:ref:`box.cfg{readahead} "
"<cfg_networking-readahead>`)."

#: ../doc/1.10/book/admin/troubleshoot.rst:177
msgid ""
"This parameter can be changed on the fly, so you don't need to restart "
"Tarantool. Attach to the Tarantool instance with :ref:`tarantoolctl "
"<tarantoolctl>` utility and call ``box.cfg{}`` with a new ``readahead`` "
"value:"
msgstr ""
"Перезапускать Tarantool при этом не требуется. Для обновления "
"конфигурации необходимо подключиться к Tarantool с помощью утилиты "
":ref:`tarantoolctl <tarantoolctl>` и передать в ``box.cfg{}`` новое "
"значение параметра ``readahead``:"

#: ../doc/1.10/book/admin/troubleshoot.rst:189
msgid ""
"-- changing the readahead value\n"
"tarantool> box.cfg{readahead = 10 * 1024 * 1024}"
msgstr ""
"-- задаем новое значение readahead\n"
"tarantool> box.cfg{readahead = 10 * 1024 * 1024}"

#: ../doc/1.10/book/admin/troubleshoot.rst:194
msgid ""
"**Example:** Given 1000 RPS, 1 Кbyte of query size, and 10 seconds of "
"maximal query processing time, the minimal readahead buffer size must be "
"10 Mbytes."
msgstr ""
"**Пример расчета:** при 1000 RPS, размере одного запроса в 1 Кбайт и "
"максимальном времени обработки одного запроса в 10 секунд минимальный "
"размер readahead-буфера должен равняться 10 Мбайт."

#: ../doc/1.10/book/admin/troubleshoot.rst:198
msgid ""
"On the business logic level, split fast and slow queries processing by "
"different connections."
msgstr ""
"Обрабатывать быстрые и медленные запросы в отдельных подключениях "
"(решается на уровне бизнес-логики)."

#: ../doc/1.10/book/admin/troubleshoot.rst:201
msgid "Slow disks."
msgstr "Медленная работа дисков."

#: ../doc/1.10/book/admin/troubleshoot.rst:205
msgid ""
"Check disk performance (use `iostat "
"<https://linux.die.net/man/1/iostat>`_, `iotop "
"<https://linux.die.net/man/1/iotop>`_ or `strace "
"<https://linux.die.net/man/1/strace>`_ utility to check ``iowait`` "
"parameter) and try to put .xlog files and snapshot files on different "
"physical disks (i.e. use different locations for :ref:`wal_dir "
"<cfg_basic-wal_dir>` and :ref:`memtx_dir <cfg_basic-memtx_dir>`)."
msgstr ""
"Проверить занятость дисков (с помощью утилиты `iostat "
"<https://linux.die.net/man/1/iostat>`_, `iotop "
"<https://linux.die.net/man/1/iotop>`_ или `strace "
"<https://linux.die.net/man/1/strace>`_ посмотреть на параметр ``iowait``)"
"  и попробовать разнести .xlog-файлы и снимки состояния базы данных по "
"разным дискам (т.е. указать разные значения для параметров  :ref:`wal_dir"
"  <cfg_basic-wal_dir>` и :ref:`memtx_dir <cfg_basic-memtx_dir>`)."

#: ../doc/1.10/book/admin/troubleshoot.rst:216
msgid "Problem: Replication \"lag\" and \"idle\" contain negative values"
msgstr "Проблема: параметры репликации lag и idle принимают отрицательные значения"

#: ../doc/1.10/book/admin/troubleshoot.rst:218
msgid ""
"This is about ``box.info.replication.(upstream.)lag`` and "
"``box.info.replication.(upstream.)idle`` values in "
":ref:`box.info.replication <box_info_replication>` section."
msgstr ""
"Речь идет о параметрах ``box.info.replication.(upstream.)lag`` и "
"``box.info.replication.(upstream.)idle`` из сводной таблицы "
":ref:`box.info.replication <box_info_replication>`."

#: ../doc/1.10/book/admin/troubleshoot.rst:224
msgid ""
"Operating system clock on the hosts is not synchronized, or the NTP "
"server is faulty."
msgstr "Не синхронизированы часы на машинах или  неправильно работает NTP-сервер."

#: ../doc/1.10/book/admin/troubleshoot.rst:229
msgid "Check NTP server settings."
msgstr "Проверить настройки NTP-сервера."

#: ../doc/1.10/book/admin/troubleshoot.rst:231
msgid ""
"If you found no problems with the NTP server, just do nothing then. Lag "
"calculation uses operating system clock from two different machines. If "
"they get out of sync, the remote master clock can get consistently behind"
" the local instance’s clock."
msgstr ""
"Если проблем с NTP-сервером не обнаружено, то не следует ничего "
"предпринимать, потому что при вычислении лага репликации используются "
"показания системных часов на двух разных машинах, и в случае "
"рассинхронизации может случиться так, что часы удаленного мастер-сервера "
"всегда будут отставать от часов локального экземпляра Tarantool."

#: ../doc/1.10/book/admin/troubleshoot.rst:240
msgid ""
"Problem: Replication \"idle\" keeps growing, but no related log messages "
"appear"
msgstr ""
"Проблема: значение параметра idle растет, но журнал не содержит связанных"
"  с этим сообщений"

#: ../doc/1.10/book/admin/troubleshoot.rst:242
msgid ""
"This is about ``box.info.replication.(upstream.)idle`` value in "
":ref:`box.info.replication <box_info_replication>` section."
msgstr ""
"Речь идет о параметре ``box.info.replication.(upstream.)idle`` из сводной"
"  таблицы :ref:`box.info.replication <box_info_replication>`."

#: ../doc/1.10/book/admin/troubleshoot.rst:247
msgid ""
"Some server was assigned different IP addresses, or some server was "
"specified twice in ``box.cfg{}``, so duplicate connections were "
"established."
msgstr ""
"Одному серверу были назначены различные IP-адреса или один и тот же "
"сервер был указан в ``box.cfg{}`` дважды, что привело к установлению "
"дублирующего подключения."

#: ../doc/1.10/book/admin/troubleshoot.rst:252
msgid ""
":ref:`Upgrade Tarantool 1.6 to 1.9+ <admin-upgrades_instance>`, where "
"this error is fixed: in case of duplicate connections, replication is "
"stopped and the following message is added to the log: ``'Incorrect value"
" for option ''replication_source'': duplicate connection with the same "
"replica UUID'``."
msgstr ""
":ref:`Обновить Tarantool 1.6 до 1.9+ <admin-upgrades_instance>`, где эта "
"ошибка была исправлена: в описанной ситуации репликация будет "
"остановлена, а в журнал будет записана следующая ошибка: ``'Incorrect "
"value for option ''replication_source'': duplicate connection with the "
"same replica UUID'``."

#: ../doc/1.10/book/admin/troubleshoot.rst:262
msgid "Problem: Replication statistics differ on replicas within a replica set"
msgstr ""
"Проблема: общие параметры репликации не совпадают на репликах в рамках "
"одного кластера"

#: ../doc/1.10/book/admin/troubleshoot.rst:264
msgid ""
"This is about a replica set that consists of one master and several "
"replicas. In a replica set of this type, values in "
":ref:`box.info.replication <box_info_replication>` section, like "
"``box.info.replication.lsn``, come from the master and must be the same "
"on all replicas within the replica set. The problem is that they get "
"different."
msgstr ""
"Речь идет о кластере, состоящем из одного мастера и нескольких реплик. В "
"таком случае значения общих параметров из сводной таблицы "
":ref:`box.info.replication <box_info_replication>`, например "
"``box.info.replication.lsn``, должны приходить с мастера и должны быть "
"одинаковыми на всех репликах. Если такие параметры не совпадают, это "
"свидетельствует о наличии проблем."

#: ../doc/1.10/book/admin/troubleshoot.rst:272
msgid "Replication is broken."
msgstr "Сбой репликации."

#: ../doc/1.10/book/admin/troubleshoot.rst:276
msgid ":ref:`Restart replication <replication-recover>`."
msgstr ":ref:`Перезапустить репликацию <replication-recover>`."

#: ../doc/1.10/book/admin/troubleshoot.rst:282
msgid "Problem: Master-master replication is stopped"
msgstr "Проблема: репликация мастер-мастер остановлена"

#: ../doc/1.10/book/admin/troubleshoot.rst:284
msgid ""
"This is about :ref:`box.info.replication(.upstream).status "
"<box_info_replication>` = stopped."
msgstr ""
"Речь идет о том, что параметр "
":ref:`box.info.replication(.upstream).status <box_info_replication>` "
"имеет значение stopped."

#: ../doc/1.10/book/admin/troubleshoot.rst:289
msgid ""
"In a master-master replica set of two Tarantool instances, one of the "
"masters has tried to perform an action already performed by the other "
"server, for example re-insert a tuple with the same unique key. This "
"would cause an error message like ``'Duplicate key exists in unique index"
" 'primary' in space <space_name>'``."
msgstr ""
"В репликационном кластере, состоящем из двух мастер-серверов, один из "
"серверов попытался выполнить действие, уже выполненное другим сервером, "
"-- например, повторно вставить кортеж с таким же уникальным ключом "
"(распознается по ошибке вида ``'Duplicate key exists in unique index "
"'primary' in space <space_name>'``)."

#: ../doc/1.10/book/admin/troubleshoot.rst:297
msgid "Restart replication with the following commands (at each master instance):"
msgstr ""
"Возобновить репликацию с помощью следующих команд (должны быть выполнены "
"на всех мастер-серверах):"

#: ../doc/1.10/book/admin/troubleshoot.rst:306
msgid ""
"-- restarting replication\n"
"tarantool> original_value = box.cfg.replication\n"
"tarantool> box.cfg{replication={}}\n"
"tarantool> box.cfg{replication=original_value}"
msgstr ""
"-- перезапускаем репликацию\n"
"tarantool> original_value = box.cfg.replication\n"
"tarantool> box.cfg{replication={}}\n"
"tarantool> box.cfg{replication=original_value}"

#: ../doc/1.10/book/admin/troubleshoot.rst:313
msgid ""
"We also recommend using text primary keys or setting up :ref:`master-"
"slave replication <replication-master_replica_bootstrap>`."
msgstr ""
"Также рекомендуется перейти на текстовые первичные ключи или настроить "
":ref:`репликацию мастер-реплика <replication-master_replica_bootstrap>`."

#: ../doc/1.10/book/admin/troubleshoot.rst:320
msgid "Problem: Tarantool works much slower than before"
msgstr "Проблема: Tarantool работает заметно медленнее, чем раньше"

#: ../doc/1.10/book/admin/troubleshoot.rst:324
msgid ""
"Inefficient memory usage (RAM is cluttered with a huge amount of unused "
"objects)."
msgstr ""
"Неэффективное использование памяти (память занята большим количеством "
"неиспользуемых объектов)."

#: ../doc/1.10/book/admin/troubleshoot.rst:328
msgid ""
"Call the Lua garbage collector with the `collectgarbage('count') function"
" <https://www.lua.org/manual/5.1/manual.html#pdf-collectgarbage>`_ and "
"measure its execution time with the Tarantool functions "
":ref:`clock.bench() <clock-bench>` or :ref:`clock.proc() <clock-proc>`."
msgstr ""
"Запустить сборщик мусора в Lua с помощью `функции collectgarbage(count) "
"<https://www.lua.org/manual/5.1/manual.html#pdf-collectgarbage>`_ и "
"измерить время ее выполнения с помощью :ref:`clock.bench() <clock-bench>`"
"  или :ref:`clock.proc() <clock-proc>`."

#: ../doc/1.10/book/admin/troubleshoot.rst:333
msgid "Example of calculating memory usage statistics:"
msgstr "Пример кода для подсчета потребляемой памяти:"

#: ../doc/1.10/book/admin/troubleshoot.rst:342
msgid ""
"-- loading Tarantool's \"clock\" module with time-related routines\n"
"tarantool> local clock = require 'clock'\n"
"-- starting the timer\n"
"tarantool> local b = clock.proc()\n"
"-- launching garbage collection\n"
"tarantool> local c = collectgarbage('count')\n"
"-- stopping the timer after garbage collection is completed\n"
"tarantool> return c, clock.proc() - b"
msgstr ""
"-- загрузка модуля clock для работы со временем\n"
"tarantool> local clock = require 'clock'\n"
"-- запускаем таймер\n"
"tarantool> local b = clock.proc()\n"
"-- запускаем сборку мусора\n"
"tarantool> local c = collectgarbage('count')\n"
"-- останавливаем таймер по завершении сборки мусора\n"
"tarantool> return c, clock.proc() - b"

#: ../doc/1.10/book/admin/troubleshoot.rst:353
msgid ""
"If the returned ``clock.proc()`` value is greater than 0.001, this may be"
" an indicator of inefficient memory usage (no active measures are "
"required, but we recommend to optimize your Tarantool application code)."
msgstr ""
"Если возвращаемое ``clock.proc()`` значение больше 0.001, это может "
"являться признаком неэффективного использования памяти (активного "
"вмешательства не требуется, но рекомендуется оптимизация кода). Если "
"значение превышает 0.01, необходимо провести подробный анализ кода и "
"оптимизировать потребление памяти."

#: ../doc/1.10/book/admin/troubleshoot.rst:357
msgid ""
"If the value is greater than 0.01, your application definitely needs "
"thorough code analysis aimed at optimizing memory usage."
msgstr ""
"Если значение больше 0,01, код приложения однозначно необходимо "
"проанализировать на предмет оптимизации использования памяти."

#: ../doc/1.10/book/admin/upgrades.rst:39
msgid "Upgrades"
msgstr "Обновление"

#: ../doc/1.10/book/admin/upgrades.rst:45
msgid "Upgrading a Tarantool database"
msgstr "Обновление базы данных Tarantool"

#: ../doc/1.10/book/admin/upgrades.rst:47
msgid ""
"If you created a database with an older Tarantool version and have now "
"installed a newer version, make the request ``box.schema.upgrade()``. "
"This updates Tarantool system spaces to match the currently installed "
"version of Tarantool."
msgstr ""
"Если вы создали базу данных в старой версии Tarantool'а, а потом обновили"
"  Tarantool до более свежей версии, вызовите команду "
"``box.schema.upgrade()``. Она обновляет системные спейсы Tarantool'а так,"
"  чтобы они совпадали с текущей установленной версией Tarantool'а."

#: ../doc/1.10/book/admin/upgrades.rst:51
msgid ""
"For example, here is what happens when you run ``box.schema.upgrade()`` "
"with a database created with Tarantool version 1.6.4 to version 1.7.2 "
"(only a small part of the output is shown):"
msgstr ""
"Например, вот что происходит, если выполнить команду "
"``box.schema.upgrade()`` для базы данных, созданной в Tarantool версии "
"1.6.4 (показана лишь малая часть выводимых сообщений):"

#: ../doc/1.10/book/admin/upgrades.rst:55
msgid ""
"tarantool> box.schema.upgrade()\n"
"alter index primary on _space set options to {\"unique\":true}, parts to "
"[[0,\"unsigned\"]]\n"
"alter space _schema set options to {}\n"
"create view _vindex...\n"
"grant read access to 'public' role for _vindex view\n"
"set schema version to 1.7.0\n"
"---\n"
"..."
msgstr ""
"tarantool> box.schema.upgrade()\n"
"alter index primary on _space set options to {\"unique\":true}, parts to "
"[[0,\"unsigned\"]]\n"
"alter space _schema set options to {}\n"
"create view _vindex...\n"
"grant read access to 'public' role for _vindex view\n"
"set schema version to 1.7.0\n"
"---\n"
"..."

#: ../doc/1.10/book/admin/upgrades.rst:70
msgid "Upgrading a Tarantool instance"
msgstr "Обновление экземпляра Tarantool'а"

#: ../doc/1.10/book/admin/upgrades.rst:72
msgid ""
"Tarantool is backward compatible between two adjacent versions. For "
"example, you should have no or little trouble when upgrading from "
"Tarantool 1.6 to 1.7, or from Tarantool 1.7 to 1.8. Meanwhile Tarantool "
"1.8 may have incompatible changes when migrating from Tarantool 1.6. to "
"1.8 directly."
msgstr ""
"Tarantool поддерживает обратную совместимость между двумя "
"последовательными версиями. Например, обновление Tarantool 1.6 до 1.7 или"
"  Tarantool 1.7 до 1.8 не должно вызвать затруднений, тогда как миграции "
"с  Tarantool 1.6 прямиком на 1.8 могут препятствовать несовместимые "
"изменения."

#: ../doc/1.10/book/admin/upgrades.rst:79
msgid "How to upgrade from Tarantool 1.6 to 1.7 / 1.10"
msgstr "Как обновить Tarantool 1.6 до 1.7 / 1.10"

#: ../doc/1.10/book/admin/upgrades.rst:81
msgid ""
"This procedure is for upgrading a standalone Tarantool instance in "
"production from 1.6.x to 1.7.x (or to 1.10.x). Notice that this will "
"**always imply a downtime**. To upgrade **without downtime**, you need "
"several Tarantool servers running in a replication cluster (see "
":ref:`below <admin-upgrades_replication_cluster>`)."
msgstr ""
"Этот процесс предназначен для обновления индивидуальных экземпляров "
"Tarantool'а с 1.6.х до 1.7.х (или до 1.10.x) на боевом сервере. Обратите "
"внимание, что это **всегда приводит к некоторому простою**. Для "
"обновления **без простоев** необходимо, чтобы несколько работающих "
"Tarantool-серверов были объединены в репликационный кластер (см. "
":ref:`ниже <admin-upgrades_replication_cluster>`)."

#: ../doc/1.10/book/admin/upgrades.rst:87
msgid ""
"Tarantool 1.7 has an incompatible :ref:`.snap <internals-snapshot>` and "
":ref:`.xlog <internals-wal>` file format: 1.6 files are supported during "
"upgrade, but you won’t be able to return to 1.6 after running under 1.7 "
"for a while. It also renames a few configuration parameters, but old "
"parameters are supported. The full list of breaking changes is available "
"in `release notes for Tarantool 1.7 / 1.9 / 1.10 "
"<https://github.com/tarantool/tarantool/releases>`_."
msgstr ""
"Tarantool 1.7 работает с несовместимыми форматами файлов -- :ref:`.snap "
"<internals-snapshot>` и :ref:`.xlog <internals-wal>`. Файлы Tarantool'а "
"1.6 поддерживаются при обновлении, но после непродолжительного "
"использования Tarantool'а 1.7 вернуться к 1.6 уже нельзя. Также были "
"переименованы некоторые конфигурационные параметры, но старые параметры "
"еще поддерживаются. Список критических изменений доступен в `Примечаниях "
"к версиям Tarantool'а 1.7 / 1.9 / 1.10 "
"<https://github.com/tarantool/tarantool/releases>`_."

#: ../doc/1.10/book/admin/upgrades.rst:94
msgid "To upgrade from Tarantool 1.6 to 1.7 (or to 1.10.x):"
msgstr "Чтобы обновить Tarantool 1.6 до 1.7 (или до 1.10.x):"

#: ../doc/1.10/book/admin/upgrades.rst:96
msgid ""
"Check with application developers whether application files need to be "
"updated due to incompatible changes (see `1.7 / 1.9 / 1.10 release notes "
"<https://github.com/tarantool/tarantool/releases>`_). If yes, back up the"
" old application files."
msgstr ""
"Уточните у разработчиков, необходимо ли обновлять файлы приложения из-за "
"наличия несовместимых изменений (см. `Примечания к версиям Tarantool'а "
"1.7 / 1.9 / 1.10 <https://github.com/tarantool/tarantool/releases>`_). "
"Если да, то создайте резервные копии старых файлов приложения."

#: ../doc/1.10/book/admin/upgrades.rst:101
msgid "Stop the Tarantool server."
msgstr "Остановите Tarantool-сервер."

#: ../doc/1.10/book/admin/upgrades.rst:103
msgid ""
"Make a copy of all data (see an appropriate hot backup procedure in "
":ref:`Backups <admin-backups>`) and the package from which the current "
"(old) version was installed (for rollback purposes)."
msgstr ""
"Создайте копию всех данных (см. подразделы про горячее резервное "
"копирование в разделе :ref:`Резервное копирование <admin-backups>`) и "
"пакета, из которого была установлена текущая (старая) версия (на случай "
"отката)."

#: ../doc/1.10/book/admin/upgrades.rst:107
msgid ""
"Update the Tarantool server. See installation instructions at Tarantool "
"`download page <http://tarantool.org/download.html>`_."
msgstr ""
"Обновите Tarantool-сервер. Инструкции по установке доступны на `странице "
"загрузок Tarantool'а <http://tarantool.org/download.html>`_."

#: ../doc/1.10/book/admin/upgrades.rst:110
msgid ""
"Update the Tarantool database. Put the request ``box.schema.upgrade()`` "
"inside a :ref:`box.once() <box-once>` function in your Tarantool "
":ref:`initialization file <index-init_label>`. On startup, this will "
"create new system spaces, update data type names (e.g. num -> unsigned, "
"str -> string) and options in Tarantool system spaces."
msgstr ""
"Обновите базу данных Tarantool. Выполните команду "
"``box.schema.upgrade()``, поместив ее внутрь функции :ref:`box.once() "
"<box-once>` в :ref:`файле инициализации <index-init_label>` Tarantool'а. "
"В результате на этапе запуска Tarantool создаст новые системные спейсы, "
"обновит названия типов данных (например, num -> unsigned, str -> string) "
"и список доступных типов данных в системных спейсах."

#: ../doc/1.10/book/admin/upgrades.rst:116
msgid "Update application files, if needed."
msgstr "При необходимости обновите файлы приложения."

#: ../doc/1.10/book/admin/upgrades.rst:118
msgid ""
"Launch the updated Tarantool server using ``tarantoolctl`` or "
"``systemctl``."
msgstr ""
"Запустите обновленный Tarantool-сервер с помощью ``tarantoolctl`` или "
"``systemctl``."

#: ../doc/1.10/book/admin/upgrades.rst:124
msgid "Upgrading Tarantool in a replication cluster"
msgstr "Обновление Tarantool'а в репликационном кластере"

#: ../doc/1.10/book/admin/upgrades.rst:126
msgid ""
"Tarantool 1.7 (as well as Tarantool 1.9 and 1.10) can work as a "
":ref:`replica <replication-architecture>` for Tarantool 1.6 and vice "
"versa. Replicas perform capability negotiation on handshake, and new 1.7 "
"replication features are not used with 1.6 replicas. This allows "
"upgrading clustered configurations."
msgstr ""
"Tarantool 1.7 (а также Tarantool 1.9 и 1.10) может служить :ref:`репликой"
" <replication-architecture>` для Tarantool'а 1.6 -- и наоборот. При "
"установке соединения происходит обсуждение возможностей, и новые для 1.7 "
"репликационные функции не используются при работе с репликами версии 1.6."
" Такой подход позволяет обновлять кластерные конфигурации."

#: ../doc/1.10/book/admin/upgrades.rst:131
msgid ""
"This procedure allows for a rolling upgrade **without downtime** and "
"works for any cluster configuration: master-master or master-replica."
msgstr ""
"Этот процесс позволяет осуществить последовательное обновление **без "
"простоев** и подходит для любой конфигурации кластера: master-master или "
"мастер-реплика."

#: ../doc/1.10/book/admin/upgrades.rst:134
msgid ""
"Upgrade Tarantool at all replicas (or at any master in a master-master "
"cluster). See details in :ref:`Upgrading a Tarantool instance <admin-"
"upgrades_instance>`."
msgstr ""
"Обновите Tarantool на всех репликах (или на любом мастере в кластере "
"мастер-мастер). Подробные инструкции доступны в подразделе "
":ref:`Обновление экземпляра Tarantool'а <admin-upgrades_instance>`."

#: ../doc/1.10/book/admin/upgrades.rst:138
msgid "Verify installation on the replicas:"
msgstr "Проверьте работу реплик:"

#: ../doc/1.10/book/admin/upgrades.rst:140
msgid "Start Tarantool."
msgstr "Запустите Tarantool."

#: ../doc/1.10/book/admin/upgrades.rst:142
msgid "Attach to the master and start working as before."
msgstr "Присоединитесь к мастеру и начните работать, как раньше."

#: ../doc/1.10/book/admin/upgrades.rst:144
msgid ""
"The master runs the old Tarantool version, which is always compatible "
"with the next major version."
msgstr ""
"На мастере установлена старая версия Tarantool'а, которая всегда "
"совместима со следующей мажорной версией."

#: ../doc/1.10/book/admin/upgrades.rst:147
msgid "Upgrade the master. The procedure is similar to upgrading a replica."
msgstr "Обновите мастер. Процесс такой же, как и при обновлении реплики."

#: ../doc/1.10/book/admin/upgrades.rst:149
msgid "Verify master installation:"
msgstr "Проверьте работу мастера:"

#: ../doc/1.10/book/admin/upgrades.rst:151
msgid "Start Tarantool with replica configuration to catch up."
msgstr ""
"Запустите Tarantool в режиме реплики для получения последней версии "
"данных."

#: ../doc/1.10/book/admin/upgrades.rst:153
msgid "Switch to master mode."
msgstr "Переключитесь в режим мастера."

#: ../doc/1.10/book/admin/upgrades.rst:155
msgid ""
"Upgrade the database on any master node in the cluster. Make the request "
"``box.schema.upgrade()``. This updates Tarantool system spaces to match "
"the currently installed version of Tarantool. Changes are propagated to "
"other nodes via the regular replication mechanism."
msgstr ""
"Обновите базу данных на любом мастере в кластере. Выполните команду "
"``box.schema.upgrade()``. Это обновит системные спейсы Tarantool'а так, "
"чтобы они совпадали с текущей установленной версией Tarantool'а. "
"Изменения распространятся на другие узлы кластера через обычный механизм "
"репликации."

#: ../doc/1.10/book/app_server/contributing_module.rst:39
msgid "Contributing a module"
msgstr "Добавление собственного модуля"

#: ../doc/1.10/book/app_server/contributing_module.rst:41
msgid ""
"We have already discussed :ref:`how to create a simple module in Lua for "
"local usage <app_server-modules>`. Now let's discuss how to create a more"
" advanced Tarantool module and then get it published on `Tarantool rocks "
"page <http://tarantool.org/rocks.html>`_ and included in `official "
"Tarantool images <http://github.com/tarantool/docker>`_ for Docker."
msgstr ""
"Мы уже обсуждали, :ref:`как создать простой модуль на языке Lua для "
"локального использования <app_server-modules>`.Теперь давайте обсудим, "
"как создать модуль более продвинутого уровня для Tarantool'а, а затем "
"разместить его на странице модулей Tarantool'а "
"<http://tarantool.org/rocks.html>`_ и включить его в `официальные образы "
"Tarantool'а <http://github.com/tarantool/docker>`_ для Docker."

#: ../doc/1.10/book/app_server/contributing_module.rst:48
msgid ""
"To help our contributors, we have created `modulekit "
"<http://github.com/tarantool/modulekit>`_, a set of templates for "
"creating Tarantool modules in Lua and C."
msgstr ""
"Чтобы помочь разработчикам, мы создали `modulekit "
"<http://github.com/tarantool/modulekit>`_, набор шаблонов для создания "
"Tarantool-модулей на Lua и C."

#: ../doc/1.10/book/app_server/contributing_module.rst:54
msgid ""
"As a prerequisite for using ``modulekit``, install ``tarantool-dev`` "
"package first. For example, in Ubuntu say:"
msgstr ""
"Чтобы использовать ``modulekit``, необходимо предварительно установить "
"пакет ``tarantool-dev``. Например, в Ubuntu выполните команду:"

#: ../doc/1.10/book/app_server/contributing_module.rst:57
#: ../doc/1.10/reference/reference_rock/dbms.rst:95
#: ../doc/1.10/reference/reference_rock/dbms.rst:448
#: ../doc/1.10/tutorials/c_tutorial.rst:82
msgid "$ sudo apt-get install tarantool-dev"
msgstr "$ sudo apt-get install tarantool-dev"

#: ../doc/1.10/book/app_server/contributing_module.rst:65
msgid "Contributing a module in Lua"
msgstr "Добавление собственного модуля на Lua"

#: ../doc/1.10/book/app_server/contributing_module.rst:67
msgid ""
"See `README in \"luakit\" branch of tarantool/modulekit repository "
"<http://github.com/tarantool/modulekit/blob/luakit/README.md>`_ for "
"detailed instructions and examples."
msgstr ""
"Подробную информацию и примеры см. в `README в ветке \"luakit\" "
"репозитория tarantool/modulekit "
"<http://github.com/tarantool/modulekit/blob/luakit/README.md>`_."

#: ../doc/1.10/book/app_server/contributing_module.rst:75
msgid "Contributing a module in C"
msgstr "Добавление собственного модуля на C"

#: ../doc/1.10/book/app_server/contributing_module.rst:77
msgid ""
"In some cases, you may want to create a Tarantool module in C rather than"
" in Lua. For example, to work with specific hardware or low-level system "
"interfaces."
msgstr ""
"В некоторых случаях может потребоваться создание Tarantool-модуля на C, а"
" не на Lua, например, для работы со специальным оборудованием или "
"низкоуровневыми системными интерфейсами."

#: ../doc/1.10/book/app_server/contributing_module.rst:80
msgid ""
"See `README in \"ckit\" branch of tarantool/modulekit repository "
"<http://github.com/tarantool/modulekit/blob/ckit/README.md>`_ for "
"detailed instructions and examples."
msgstr ""
"Подробную информацию и примеры см. в `README в ветке \"ckit\" репозитория"
" tarantool/modulekit "
"<http://github.com/tarantool/modulekit/blob/ckit/README.md>`_."

#: ../doc/1.10/book/app_server/contributing_module.rst:86
msgid ""
"You can also create modules with C++, provided that the code does not "
"throw exceptions."
msgstr ""
"Вы можете аналогичным образом создавать модули на C++ при условии, что в "
"их коде не будут выбрасываться исключения."

#: ../doc/1.10/book/app_server/cookbook.rst:39
msgid "Cookbook recipes"
msgstr "Примеры и рекомендации по разработке"

#: ../doc/1.10/book/app_server/cookbook.rst:41
msgid ""
"Here are contributions of Lua programs for some frequent or tricky "
"situations."
msgstr ""
"Ниже представлены дополнения в виде Lua-программ для часто встречающихся "
"или сложных случаев."

#: ../doc/1.10/book/app_server/cookbook.rst:43
msgid ""
"You can execute any of these programs by copying the code into a ``.lua``"
" file, and then entering :samp:`chmod +x ./{program-name}.lua` and :samp"
":`./{program-name}.lua` on the terminal."
msgstr ""
"Любую из этих программ можно выполнить, скопировав код в ``.lua-файл``, а"
" затем выполнив в командной строке :samp:`chmod +x ./{имя-программы}.lua`"
" и :samp :`./{имя-программы}.lua`."

#: ../doc/1.10/book/app_server/cookbook.rst:47
msgid "The first line is a \"hashbang\":"
msgstr "Первая строка -- это шебанг:"

#: ../doc/1.10/book/app_server/cookbook.rst:49
msgid "#!/usr/bin/env tarantool"
msgstr "#!/usr/bin/env tarantool"

#: ../doc/1.10/book/app_server/cookbook.rst:53
msgid ""
"This runs  Tarantool Lua application server, which should be on the "
"execution path."
msgstr ""
"Он запускает сервер приложений Tarantool'а на языке Lua, который должен "
"быть в пути выполнения."

#: ../doc/1.10/book/app_server/cookbook.rst:56
msgid "This section contains the following recipes:"
msgstr "В этом разделе собраны следующие рецепты:"

#: ../doc/1.10/book/app_server/cookbook.rst:61
msgid "Use freely."
msgstr "Можно использовать свободно."

#: ../doc/1.10/book/app_server/cookbook.rst:67
msgid "hello_world.lua"
msgstr "hello_world.lua"

#: ../doc/1.10/book/app_server/cookbook.rst:69
msgid "The standard example of a simple program."
msgstr "Стандартный пример простой программы."

#: ../doc/1.10/book/app_server/cookbook.rst:71
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"print('Hello, World!')"
msgstr ""
"#!/usr/bin/env tarantool\n"
" \n"
" print('Hello, World!')"

#: ../doc/1.10/book/app_server/cookbook.rst:81
msgid "console_start.lua"
msgstr "console_start.lua"

#: ../doc/1.10/book/app_server/cookbook.rst:83
msgid ""
"Use :ref:`box.once() <box-once>` to initialize a database (creating "
"spaces) if this is the first time the server has been run. Then use "
":ref:`console.start() <console-start>` to start interactive mode."
msgstr ""
"Для инициализации базы данных (создания спейсов) используйте "
":ref:`box.once() <box-once>`, если сервер запускается впервые. Затем "
"используйте :ref:`console.start() <console-start>`, чтобы запустить "
"интерактивный режим."

#: ../doc/1.10/book/app_server/cookbook.rst:87
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"-- Configure database\n"
"box.cfg {\n"
"    listen = 3313\n"
"}\n"
"\n"
"box.once(\"bootstrap\", function()\n"
"    box.schema.space.create('tweedledum')\n"
"    box.space.tweedledum:create_index('primary',\n"
"        { type = 'TREE', parts = {1, 'unsigned'}})\n"
"end)\n"
"\n"
"require('console').start()"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"-- Настроить базу данных\n"
"box.cfg {\n"
"    listen = 3313\n"
"}\n"
"\n"
"box.once(\"bootstrap\", function()\n"
"    box.schema.space.create('tweedledum')\n"
"    box.space.tweedledum:create_index('primary',\n"
"        { type = 'TREE', parts = {1, 'unsigned'}})\n"
"end)\n"
"\n"
"require('console').start()"

#: ../doc/1.10/book/app_server/cookbook.rst:108
msgid "fio_read.lua"
msgstr "fio_read.lua"

#: ../doc/1.10/book/app_server/cookbook.rst:110
msgid "Use the :ref:`fio module <fio-module>` to open, read, and close a file."
msgstr ""
"Используйте :ref:`Модуль fio <fio-module>`, чтобы открыть, прочитать и "
"закрыть файл."

#: ../doc/1.10/book/app_server/cookbook.rst:112
#: ../doc/1.10/reference/reference_lua/errcodes.rst:147
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local fio = require('fio')\n"
"local errno = require('errno')\n"
"local f = fio.open('/tmp/xxxx.txt', {'O_RDONLY' })\n"
"if not f then\n"
"    error(\"Failed to open file: \"..errno.strerror())\n"
"end\n"
"local data = f:read(4096)\n"
"f:close()\n"
"print(data)"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local fio = require('fio')\n"
"local errno = require('errno')\n"
"local f = fio.open('/tmp/xxxx.txt', {'O_RDONLY' })\n"
"if not f then\n"
"    error(\"Failed to open file: \"..errno.strerror())\n"
"end\n"
"local data = f:read(4096)\n"
"f:close()\n"
"print(data)"

#: ../doc/1.10/book/app_server/cookbook.rst:130
msgid "fio_write.lua"
msgstr "fio_write.lua"

#: ../doc/1.10/book/app_server/cookbook.rst:132
msgid "Use the :ref:`fio module <fio-module>` to open, write, and close a file."
msgstr ""
"Используйте :ref:`Модуль fio <fio-module>`, чтобы открыть, записать "
"данные и закрыть файл."

#: ../doc/1.10/book/app_server/cookbook.rst:134
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local fio = require('fio')\n"
"local errno = require('errno')\n"
"local f = fio.open('/tmp/xxxx.txt', {'O_CREAT', 'O_WRONLY', 'O_APPEND'},\n"
"    tonumber('0666', 8))\n"
"if not f then\n"
"    error(\"Failed to open file: \"..errno.strerror())\n"
"end\n"
"f:write(\"Hello\\n\");\n"
"f:close()"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local fio = require('fio')\n"
"local errno = require('errno')\n"
"local f = fio.open('/tmp/xxxx.txt', {'O_CREAT', 'O_WRONLY', 'O_APPEND'},\n"
"    tonumber('0666', 8))\n"
"if not f then\n"
"    error(\"Failed to open file: \"..errno.strerror())\n"
"end\n"
"f:write(\"Hello\\n\");\n"
"f:close()"

#: ../doc/1.10/book/app_server/cookbook.rst:152
msgid "ffi_printf.lua"
msgstr "ffi_printf.lua"

#: ../doc/1.10/book/app_server/cookbook.rst:154
msgid ""
"Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to call a "
"C built-in function: printf(). (For help understanding ffi, see the `FFI "
"tutorial <http://luajit.org/ext_ffi_tutorial.html>`_.)"
msgstr ""
"Используйте `Библиотеку LuaJIT FFI <http://luajit.org/ext_ffi.html>`_, "
"чтобы вызвать встроенную в C функцию: printf(). (Чтобы лучше понимать "
"FFI, см. `Учебное пособие по FFI "
"<http://luajit.org/ext_ffi_tutorial.html>`_.)"

#: ../doc/1.10/book/app_server/cookbook.rst:157
#, python-format
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require('ffi')\n"
"ffi.cdef[[\n"
"    int printf(const char *format, ...);\n"
"]]\n"
"\n"
"ffi.C.printf(\"Hello, %s\\n\", os.getenv(\"USER\"));"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require('ffi')\n"
"ffi.cdef[[\n"
"    int printf(const char *format, ...);\n"
"]]\n"
"\n"
"ffi.C.printf(\"Hello, %s\\n\", os.getenv(\"USER\"));"

#: ../doc/1.10/book/app_server/cookbook.rst:172
msgid "ffi_gettimeofday.lua"
msgstr "ffi_gettimeofday.lua"

#: ../doc/1.10/book/app_server/cookbook.rst:174
msgid ""
"Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to call a "
"C function: gettimeofday(). This delivers time with millisecond "
"precision, unlike the time function in Tarantool's :ref:`clock module "
"<clock-module>`."
msgstr ""
"Используйте `Библиотеку LuaJIT FFI <http://luajit.org/ext_ffi.html>`_, "
"чтобы вызвать встроенную в C функцию: gettimeofday(). Она позволяет "
"получить значение времени с точностью в миллисекундах, в отличие от "
"функции времени в Tarantool'е :ref:`Модуль clock <clock-module>`."

#: ../doc/1.10/book/app_server/cookbook.rst:178
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require('ffi')\n"
"ffi.cdef[[\n"
"    typedef long time_t;\n"
"    typedef struct timeval {\n"
"    time_t tv_sec;\n"
"    time_t tv_usec;\n"
"} timeval;\n"
"    int gettimeofday(struct timeval *t, void *tzp);\n"
"]]\n"
"\n"
"local timeval_buf = ffi.new(\"timeval\")\n"
"local now = function()\n"
"    ffi.C.gettimeofday(timeval_buf, nil)\n"
"    return tonumber(timeval_buf.tv_sec * 1000 + (timeval_buf.tv_usec / "
"1000))\n"
"end"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require('ffi')\n"
"ffi.cdef[[\n"
"    typedef long time_t;\n"
"    typedef struct timeval {\n"
"    time_t tv_sec;\n"
"    time_t tv_usec;\n"
"} timeval;\n"
"    int gettimeofday(struct timeval *t, void *tzp);\n"
"]]\n"
"\n"
"local timeval_buf = ffi.new(\"timeval\")\n"
"local now = function()\n"
"    ffi.C.gettimeofday(timeval_buf, nil)\n"
"    return tonumber(timeval_buf.tv_sec * 1000 + (timeval_buf.tv_usec / "
"1000))\n"
"end"

#: ../doc/1.10/book/app_server/cookbook.rst:202
msgid "ffi_zlib.lua"
msgstr "ffi_zlib.lua"

#: ../doc/1.10/book/app_server/cookbook.rst:204
msgid ""
"Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to call a "
"C library function. (For help understanding ffi, see the `FFI tutorial "
"<http://luajit.org/ext_ffi_tutorial.html>`_.)"
msgstr ""
"Используйте `Библиотеку LuaJIT FFI  <http://luajit.org/ext_ffi.html>`_, "
"чтобы вызвать библиотечную функцию в C. (Чтобы лучше понимать FFI, см. "
"`Учебное пособие по FFI <http://luajit.org/ext_ffi_tutorial.html>`_.)"

#: ../doc/1.10/book/app_server/cookbook.rst:207
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require(\"ffi\")\n"
"ffi.cdef[[\n"
"    unsigned long compressBound(unsigned long sourceLen);\n"
"    int compress2(uint8_t *dest, unsigned long *destLen,\n"
"    const uint8_t *source, unsigned long sourceLen, int level);\n"
"    int uncompress(uint8_t *dest, unsigned long *destLen,\n"
"    const uint8_t *source, unsigned long sourceLen);\n"
"]]\n"
"local zlib = ffi.load(ffi.os == \"Windows\" and \"zlib1\" or \"z\")\n"
"\n"
"-- Lua wrapper for compress2()\n"
"local function compress(txt)\n"
"    local n = zlib.compressBound(#txt)\n"
"    local buf = ffi.new(\"uint8_t[?]\", n)\n"
"    local buflen = ffi.new(\"unsigned long[1]\", n)\n"
"    local res = zlib.compress2(buf, buflen, txt, #txt, 9)\n"
"    assert(res == 0)\n"
"    return ffi.string(buf, buflen[0])\n"
"end\n"
"\n"
"-- Lua wrapper for uncompress\n"
"local function uncompress(comp, n)\n"
"    local buf = ffi.new(\"uint8_t[?]\", n)\n"
"    local buflen = ffi.new(\"unsigned long[1]\", n)\n"
"    local res = zlib.uncompress(buf, buflen, comp, #comp)\n"
"    assert(res == 0)\n"
"    return ffi.string(buf, buflen[0])\n"
"end\n"
"\n"
"-- Simple test code.\n"
"local txt = string.rep(\"abcd\", 1000)\n"
"print(\"Uncompressed size: \", #txt)\n"
"local c = compress(txt)\n"
"print(\"Compressed size: \", #c)\n"
"local txt2 = uncompress(c, #txt)\n"
"assert(txt2 == txt)"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require(\"ffi\")\n"
"ffi.cdef[[\n"
"    unsigned long compressBound(unsigned long sourceLen);\n"
"    int compress2(uint8_t *dest, unsigned long *destLen,\n"
"    const uint8_t *source, unsigned long sourceLen, int level);\n"
"    int uncompress(uint8_t *dest, unsigned long *destLen,\n"
"    const uint8_t *source, unsigned long sourceLen);\n"
"]]\n"
"local zlib = ffi.load(ffi.os == \"Windows\" and \"zlib1\" or \"z\")\n"
"\n"
"-- Надстройка Lua для функции compress2()\n"
"local function compress(txt)\n"
"    local n = zlib.compressBound(#txt)\n"
"    local buf = ffi.new(\"uint8_t[?]\", n)\n"
"    local buflen = ffi.new(\"unsigned long[1]\", n)\n"
"    local res = zlib.compress2(buf, buflen, txt, #txt, 9)\n"
"    assert(res == 0)\n"
"    return ffi.string(buf, buflen[0])\n"
"end\n"
"\n"
"-- Надстройка Lua для функции uncompress\n"
"local function uncompress(comp, n)\n"
"    local buf = ffi.new(\"uint8_t[?]\", n)\n"
"    local buflen = ffi.new(\"unsigned long[1]\", n)\n"
"    local res = zlib.uncompress(buf, buflen, comp, #comp)\n"
"    assert(res == 0)\n"
"    return ffi.string(buf, buflen[0])\n"
"end\n"
"\n"
"-- Простой код теста\n"
"local txt = string.rep(\"abcd\", 1000)\n"
"print(\"Uncompressed size: \", #txt)\n"
"local c = compress(txt)\n"
"print(\"Compressed size: \", #c)\n"
"local txt2 = uncompress(c, #txt)\n"
"assert(txt2 == txt)"

#: ../doc/1.10/book/app_server/cookbook.rst:252
msgid "ffi_meta.lua"
msgstr "ffi_meta.lua"

#: ../doc/1.10/book/app_server/cookbook.rst:254
msgid ""
"Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to access "
"a C object via a metamethod (a method which is defined with a metatable)."
msgstr ""
"Используйте `Библиотеку LuaJIT FFI <http://luajit.org/ext_ffi.html>`_, "
"чтобы получить доступ к объекту в C с помощью метаметода (метод, который "
"определен метатаблицей)."

#: ../doc/1.10/book/app_server/cookbook.rst:258
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require(\"ffi\")\n"
"ffi.cdef[[\n"
"typedef struct { double x, y; } point_t;\n"
"]]\n"
"\n"
"local point\n"
"local mt = {\n"
"  __add = function(a, b) return point(a.x+b.x, a.y+b.y) end,\n"
"  __len = function(a) return math.sqrt(a.x*a.x + a.y*a.y) end,\n"
"  __index = {\n"
"    area = function(a) return a.x*a.x + a.y*a.y end,\n"
"  },\n"
"}\n"
"point = ffi.metatype(\"point_t\", mt)\n"
"\n"
"local a = point(3, 4)\n"
"print(a.x, a.y)  --> 3  4\n"
"print(#a)        --> 5\n"
"print(a:area())  --> 25\n"
"local b = a + point(0.5, 8)\n"
"print(#b)        --> 12.5"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require(\"ffi\")\n"
"ffi.cdef[[\n"
"typedef struct { double x, y; } point_t;\n"
"]]\n"
"\n"
"local point\n"
"local mt = {\n"
"  __add = function(a, b) return point(a.x+b.x, a.y+b.y) end,\n"
"  __len = function(a) return math.sqrt(a.x*a.x + a.y*a.y) end,\n"
"  __index = {\n"
"    area = function(a) return a.x*a.x + a.y*a.y end,\n"
"  },\n"
"}\n"
"point = ffi.metatype(\"point_t\", mt)\n"
"\n"
"local a = point(3, 4)\n"
"print(a.x, a.y)  --> 3  4\n"
"print(#a)        --> 5\n"
"print(a:area())  --> 25\n"
"local b = a + point(0.5, 8)\n"
"print(#b)        --> 12.5"

#: ../doc/1.10/book/app_server/cookbook.rst:288
msgid "print_arrays.lua"
msgstr "print_arrays.lua"

#: ../doc/1.10/book/app_server/cookbook.rst:290
msgid ""
"Create Lua tables, and print them. Notice that for the 'array' table the "
"iterator function is ipairs(), while for the 'map' table the iterator "
"function is pairs(). (`ipairs()` is faster than `pairs()`, but pairs() is"
" recommended for map-like tables or mixed tables.) The display will look "
"like: \"1 Apple | 2 Orange | 3 Grapefruit | 4 Banana | k3 v3 | k1 v1 | k2"
" v2\"."
msgstr ""
"Используйте, чтобы создать Lua-таблицы и вывести их. Следует отметить, "
"что для таблицы типа массива (array) функция-итератор будет ipairs(), а "
"для таблицы типа ассоциативного массива (map) функция-итератор -- "
"pairs(). (`ipairs()` быстрее, чем `pairs()`, но pairs() рекомендуется для"
" ассоциативных массивов или смешанных таблиц.) Результат будет выглядеть "
"следующим образом: \"1 Apple | 2 Orange | 3 Grapefruit | 4 Banana | k3 v3"
" | k1 v1 | k2  v2\"."

#: ../doc/1.10/book/app_server/cookbook.rst:298
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"array = { 'Apple', 'Orange', 'Grapefruit', 'Banana'}\n"
"for k, v in ipairs(array) do print(k, v) end\n"
"\n"
"map = { k1 = 'v1', k2 = 'v2', k3 = 'v3' }\n"
"for k, v in pairs(map) do print(k, v) end"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"array = { 'Apple', 'Orange', 'Grapefruit', 'Banana'}\n"
"for k, v in ipairs(array) do print(k, v) end\n"
"\n"
"map = { k1 = 'v1', k2 = 'v2', k3 = 'v3' }\n"
"for k, v in pairs(map) do print(k, v) end"

#: ../doc/1.10/book/app_server/cookbook.rst:312
msgid "count_array.lua"
msgstr "count_array.lua"

#: ../doc/1.10/book/app_server/cookbook.rst:314
msgid ""
"Use the '#' operator to get the number of items in an array-like Lua "
"table. This operation has O(log(N)) complexity."
msgstr ""
"Используйте оператор '#', чтобы получить количество элементов в "
"Lua-таблице типа массива. У этой операции сложность O(log(N))."

#: ../doc/1.10/book/app_server/cookbook.rst:317
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"array = { 1, 2, 3}\n"
"print(#array)"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"array = { 1, 2, 3}\n"
"print(#array)"

#: ../doc/1.10/book/app_server/cookbook.rst:328
msgid "count_array_with_nils.lua"
msgstr "count_array_with_nils.lua"

#: ../doc/1.10/book/app_server/cookbook.rst:330
msgid ""
"Missing elements in arrays, which Lua treats as \"nil\"s, cause the "
"simple \"#\" operator to deliver improper results. The \"print(#t)\" "
"instruction will print \"4\"; the \"print(counter)\" instruction will "
"print \"3\"; the \"print(max)\" instruction will print \"10\". Other "
"table functions, such as table.sort(), will also misbehave when \"nils\" "
"are present."
msgstr ""
"Отсутствующие элементы в массивах, которые Lua рассматривает как nil, "
"заставляют простой оператор '#' выдавать неправильные результаты. Команда"
" \"print(#t)\" выведет \"4\", команда \"print(counter)\" выведет \"3\", а"
" команда \"print(max)\" -- \"10\". Другие табличные функции, такие как "
"table.sort(), также сработают неправильно при наличии значений nils."

#: ../doc/1.10/book/app_server/cookbook.rst:338
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local t = {}\n"
"t[1] = 1\n"
"t[4] = 4\n"
"t[10] = 10\n"
"print(#t)\n"
"local counter = 0\n"
"for k,v in pairs(t) do counter = counter + 1 end\n"
"print(counter)\n"
"local max = 0\n"
"for k,v in pairs(t) do if k > max then max = k end end\n"
"print(max)"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local t = {}\n"
"t[1] = 1\n"
"t[4] = 4\n"
"t[10] = 10\n"
"print(#t)\n"
"local counter = 0\n"
"for k,v in pairs(t) do counter = counter + 1 end\n"
"print(counter)\n"
"local max = 0\n"
"for k,v in pairs(t) do if k > max then max = k end end\n"
"print(max)"

#: ../doc/1.10/book/app_server/cookbook.rst:358
msgid "count_array_with_nulls.lua"
msgstr "count_array_with_nulls.lua"

#: ../doc/1.10/book/app_server/cookbook.rst:360
msgid ""
"Use explicit ``NULL`` values to avoid the problems caused by Lua's nil =="
" missing value behavior. Although :code:`json.NULL == nil` is "
":code:`true`, all the print instructions in this program will print the "
"correct value: 10."
msgstr ""
"Используйте явные значения``NULL``, чтобы избежать проблем, вызванных  "
"nil в Lua == поведение с пропущенными значениями. Хотя :code:`json.NULL "
"== nil` является :code:`true`, все команды вывода в данной программе "
"выведут правильное значение: 10."

#: ../doc/1.10/book/app_server/cookbook.rst:365
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local json = require('json')\n"
"local t = {}\n"
"t[1] = 1; t[2] = json.NULL; t[3]= json.NULL;\n"
"t[4] = 4; t[5] = json.NULL; t[6]= json.NULL;\n"
"t[6] = 4; t[7] = json.NULL; t[8]= json.NULL;\n"
"t[9] = json.NULL\n"
"t[10] = 10\n"
"print(#t)\n"
"local counter = 0\n"
"for k,v in pairs(t) do counter = counter + 1 end\n"
"print(counter)\n"
"local max = 0\n"
"for k,v in pairs(t) do if k > max then max = k end end\n"
"print(max)"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local json = require('json')\n"
"local t = {}\n"
"t[1] = 1; t[2] = json.NULL; t[3]= json.NULL;\n"
"t[4] = 4; t[5] = json.NULL; t[6]= json.NULL;\n"
"t[6] = 4; t[7] = json.NULL; t[8]= json.NULL;\n"
"t[9] = json.NULL\n"
"t[10] = 10\n"
"print(#t)\n"
"local counter = 0\n"
"for k,v in pairs(t) do counter = counter + 1 end\n"
"print(counter)\n"
"local max = 0\n"
"for k,v in pairs(t) do if k > max then max = k end end\n"
"print(max)"

#: ../doc/1.10/book/app_server/cookbook.rst:388
msgid "count_map.lua"
msgstr "count_map.lua"

#: ../doc/1.10/book/app_server/cookbook.rst:390
msgid "Get the number of elements in a map-like table."
msgstr ""
"Программа используется для получения количества элементов в таблице типа "
"ассоциативного массива."

#: ../doc/1.10/book/app_server/cookbook.rst:392
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local map = { a = 10, b = 15, c = 20 }\n"
"local size = 0\n"
"for _ in pairs(map) do size = size + 1; end\n"
"print(size)"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local map = { a = 10, b = 15, c = 20 }\n"
"local size = 0\n"
"for _ in pairs(map) do size = size + 1; end\n"
"print(size)"

#: ../doc/1.10/book/app_server/cookbook.rst:405
msgid "swap.lua"
msgstr "swap.lua"

#: ../doc/1.10/book/app_server/cookbook.rst:407
msgid ""
"Use a Lua peculiarity to swap two variables without needing a third "
"variable."
msgstr ""
"Программа использует особенность Lua менять местами две переменные без "
"необходимости использования третьей переменной."

#: ../doc/1.10/book/app_server/cookbook.rst:409
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local x = 1\n"
"local y = 2\n"
"x, y = y, x\n"
"print(x, y)"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local x = 1\n"
"local y = 2\n"
"x, y = y, x\n"
"print(x, y)"

#: ../doc/1.10/book/app_server/cookbook.rst:422
msgid "class.lua"
msgstr "class.lua"

#: ../doc/1.10/book/app_server/cookbook.rst:424
msgid ""
"Create a class, create a metatable for the class, create an instance of "
"the class. Another illustration is at `http://lua-"
"users.org/wiki/LuaClassesWithMetatable <http://lua-"
"users.org/wiki/LuaClassesWithMetatable>`_."
msgstr ""
"Используется для создания класса, метатаблицы для класса, экземпляра "
"класса. Другой пример можно найти в `http://lua-"
"users.org/wiki/LuaClassesWithMetatable <http://lua-"
"users.org/wiki/LuaClassesWithMetatable>`_."

#: ../doc/1.10/book/app_server/cookbook.rst:428
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"-- define class objects\n"
"local myclass_somemethod = function(self)\n"
"    print('test 1', self.data)\n"
"end\n"
"\n"
"local myclass_someothermethod = function(self)\n"
"    print('test 2', self.data)\n"
"end\n"
"\n"
"local myclass_tostring = function(self)\n"
"    return 'MyClass <'..self.data..'>'\n"
"end\n"
"\n"
"local myclass_mt = {\n"
"    __tostring = myclass_tostring;\n"
"    __index = {\n"
"        somemethod = myclass_somemethod;\n"
"        someothermethod = myclass_someothermethod;\n"
"    }\n"
"}\n"
"\n"
"-- create a new object of myclass\n"
"local object = setmetatable({ data = 'data'}, myclass_mt)\n"
"print(object:somemethod())\n"
"print(object.data)"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"-- определить объекты класса\n"
"local myclass_somemethod = function(self)\n"
"    print('test 1', self.data)\n"
"end\n"
"\n"
"local myclass_someothermethod = function(self)\n"
"    print('test 2', self.data)\n"
"end\n"
"\n"
"local myclass_tostring = function(self)\n"
"    return 'MyClass <'..self.data..'>'\n"
"end\n"
"\n"
"local myclass_mt = {\n"
"    __tostring = myclass_tostring;\n"
"    __index = {\n"
"        somemethod = myclass_somemethod;\n"
"        someothermethod = myclass_someothermethod;\n"
"    }\n"
"}\n"
"\n"
"-- создать новый объект своего класса myclass\n"
"local object = setmetatable({ data = 'data'}, myclass_mt)\n"
"print(object:somemethod())\n"
"print(object.data)"

#: ../doc/1.10/book/app_server/cookbook.rst:462
msgid "garbage.lua"
msgstr "garbage.lua"

#: ../doc/1.10/book/app_server/cookbook.rst:464
msgid ""
"Activate the `Lua garbage collector "
"<https://www.lua.org/manual/5.1/manual.html#2.10>`_ with the "
"`collectgarbage function <https://www.lua.org/manual/5.1/manual.html#pdf-"
"collectgarbage>`_."
msgstr ""
"Запустите `сборщик мусора в Lua "
"<https://www.lua.org/manual/5.1/manual.html#2.10>`_ с помощью `функции "
"collectgarbage <https://www.lua.org/manual/5.1/manual.html#pdf- "
"collectgarbage>`_."

#: ../doc/1.10/book/app_server/cookbook.rst:467
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"collectgarbage('collect')"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"collectgarbage('collect')"

#: ../doc/1.10/book/app_server/cookbook.rst:477
msgid "fiber_producer_and_consumer.lua"
msgstr "fiber_producer_and_consumer.lua"

#: ../doc/1.10/book/app_server/cookbook.rst:479
msgid ""
"Start one fiber for producer and one fiber for consumer. Use "
":ref:`fiber.channel() <fiber_ipc-channel>` to exchange data and "
"synchronize. One can tweak the channel size (:code:`ch_size` in the "
"program code) to control the number of simultaneous tasks waiting for "
"processing."
msgstr ""
"Запустите один файбер для производителя и один файбер для потребителя. "
"Используйте :ref:`fiber.channel() <fiber_ipc-channel>` для обмена данных "
"и синхронизации. Можно настроить ширину канала (:code:`ch_size` в "
"программном коде) для управления количеством одновременных задач к "
"обработке."

#: ../doc/1.10/book/app_server/cookbook.rst:484
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local fiber = require('fiber')\n"
"local function consumer_loop(ch, i)\n"
"    -- initialize consumer synchronously or raise an error()\n"
"    fiber.sleep(0) -- allow fiber.create() to continue\n"
"    while true do\n"
"        local data = ch:get()\n"
"        if data == nil then\n"
"            break\n"
"        end\n"
"        print('consumed', i, data)\n"
"        fiber.sleep(math.random()) -- simulate some work\n"
"    end\n"
"end\n"
"\n"
"local function producer_loop(ch, i)\n"
"    -- initialize consumer synchronously or raise an error()\n"
"    fiber.sleep(0) -- allow fiber.create() to continue\n"
"    while true do\n"
"        local data = math.random()\n"
"        ch:put(data)\n"
"        print('produced', i, data)\n"
"    end\n"
"end\n"
"\n"
"local function start()\n"
"    local consumer_n = 5\n"
"    local producer_n = 3\n"
"\n"
"    -- Create a channel\n"
"    local ch_size = math.max(consumer_n, producer_n)\n"
"    local ch = fiber.channel(ch_size)\n"
"\n"
"    -- Start consumers\n"
"    for i=1, consumer_n,1 do\n"
"        fiber.create(consumer_loop, ch, i)\n"
"    end\n"
"\n"
"    -- Start producers\n"
"    for i=1, producer_n,1 do\n"
"        fiber.create(producer_loop, ch, i)\n"
"    end\n"
"end\n"
"\n"
"start()\n"
"print('started')"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local fiber = require('fiber')\n"
"local function consumer_loop(ch, i)\n"
"    -- инициализировать потребитель синхронно или выдать ошибку()\n"
"    fiber.sleep(0) -- позволить fiber.create() продолжать\n"
"    while true do\n"
"        local data = ch:get()\n"
"        if data == nil then\n"
"            break\n"
"        end\n"
"        print('consumed', i, data)\n"
"        fiber.sleep(math.random()) -- моделировать работу\n"
"    end\n"
"end\n"
"\n"
"local function producer_loop(ch, i)\n"
"    -- инициализировать потребитель синхронно или выдать ошибку()\n"
"    fiber.sleep(0) -- allow fiber.create() to continue\n"
"    while true do\n"
"        local data = math.random()\n"
"        ch:put(data)\n"
"        print('produced', i, data)\n"
"    end\n"
"end\n"
"\n"
"local function start()\n"
"    local consumer_n = 5\n"
"    local producer_n = 3\n"
"\n"
"    -- создать канал\n"
"    local ch_size = math.max(consumer_n, producer_n)\n"
"    local ch = fiber.channel(ch_size)\n"
"\n"
"    -- запустить потребители\n"
"    for i=1, consumer_n,1 do\n"
"        fiber.create(consumer_loop, ch, i)\n"
"    end\n"
"\n"
"    -- запустить производители\n"
"    for i=1, producer_n,1 do\n"
"        fiber.create(producer_loop, ch, i)\n"
"    end\n"
"end\n"
"\n"
"start()\n"
"print('started')"

#: ../doc/1.10/book/app_server/cookbook.rst:538
msgid "socket_tcpconnect.lua"
msgstr "socket_tcpconnect.lua"

#: ../doc/1.10/book/app_server/cookbook.rst:540
msgid ""
"Use :ref:`socket.tcp_connect() <socket-tcp_connect>` to connect to a "
"remote host via TCP. Display the connection details and the result of a "
"GET request."
msgstr ""
"Используйте :ref:`socket.tcp_connect() <socket-tcp_connect>` для "
"подключения к удаленному серверу по TCP. Можно отобразить информацию о "
"подключении и результат запроса GET."

#: ../doc/1.10/book/app_server/cookbook.rst:544
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local s = require('socket').tcp_connect('google.com', 80)\n"
"print(s:peer().host)\n"
"print(s:peer().family)\n"
"print(s:peer().type)\n"
"print(s:peer().protocol)\n"
"print(s:peer().port)\n"
"print(s:write(\"GET / HTTP/1.0\\r\\n\\r\\n\"))\n"
"print(s:read('\\r\\n'))\n"
"print(s:read('\\r\\n'))"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local s = require('socket').tcp_connect('google.com', 80)\n"
"print(s:peer().host)\n"
"print(s:peer().family)\n"
"print(s:peer().type)\n"
"print(s:peer().protocol)\n"
"print(s:peer().port)\n"
"print(s:write(\"GET / HTTP/1.0\\r\\n\\r\\n\"))\n"
"print(s:read('\\r\\n'))\n"
"print(s:read('\\r\\n'))"

#: ../doc/1.10/book/app_server/cookbook.rst:562
msgid "socket_tcp_echo.lua"
msgstr "socket_tcp_echo.lua"

#: ../doc/1.10/book/app_server/cookbook.rst:564
msgid ""
"Use :ref:`socket.tcp_connect() <socket-tcp_connect>` to set up a simple "
"TCP server, by creating a function that handles requests and echos them, "
"and passing the function to :ref:`socket.tcp_server() <socket-"
"tcp_server>`. This program has been used to test with 100,000 clients, "
"with each client getting a separate fiber."
msgstr ""
"Используйте :ref:`socket.tcp_connect() <socket-tcp_connect>` для "
"настройки простого TCP-сервера путем создания функции, которая "
"обрабатывает запросы и отражает их, а затем передачи функции на "
":ref:`socket.tcp_server() <socket-tcp_server>`. Данная программа была "
"протестирована на 100 000 клиентов, каждый из которых получил отдельный "
"файбер."

#: ../doc/1.10/book/app_server/cookbook.rst:572
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local function handler(s, peer)\n"
"    s:write(\"Welcome to test server, \" .. peer.host ..\"\\n\")\n"
"    while true do\n"
"        local line = s:read('\\n')\n"
"        if line == nil then\n"
"            break -- error or eof\n"
"        end\n"
"        if not s:write(\"pong: \"..line) then\n"
"            break -- error or eof\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"local server, addr = require('socket').tcp_server('localhost', 3311, "
"handler)"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local function handler(s, peer)\n"
"    s:write(\"Welcome to test server, \" .. peer.host ..\"\\n\")\n"
"    while true do\n"
"        local line = s:read('\\n')\n"
"        if line == nil then\n"
"            break -- ошибка или конец файла\n"
"        end\n"
"        if not s:write(\"pong: \"..line) then\n"
"            break -- ошибка или конец файла\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"local server, addr = require('socket').tcp_server('localhost', 3311, "
"handler)"

#: ../doc/1.10/book/app_server/cookbook.rst:595
msgid "getaddrinfo.lua"
msgstr "getaddrinfo.lua"

#: ../doc/1.10/book/app_server/cookbook.rst:597
msgid ""
"Use :ref:`socket.getaddrinfo() <socket-getaddrinfo>` to perform non-"
"blocking DNS resolution, getting both the AF_INET6 and AF_INET "
"information for 'google.com'. This technique is not always necessary for "
"tcp connections because :ref:`socket.tcp_connect() <socket-tcp_connect>` "
"performs `socket.getaddrinfo` under the hood, before trying to connect to"
" the first available address."
msgstr ""
"Используйте :ref:`socket.getaddrinfo() <socket-getaddrinfo>`, чтобы "
"провести неблокирующее разрешение имен DNS, получая как AF_INET6, так и "
"AF_INET информацию для 'google.com'. Данная техника не всегда необходима "
"для TCP-соединений, поскольку :ref:`socket.tcp_connect() <socket-"
"tcp_connect>` выполняет `socket.getaddrinfo` с точки зрения внутреннего "
"устройства до попытки соединения с первым доступным адресом."

#: ../doc/1.10/book/app_server/cookbook.rst:605
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local s = require('socket').getaddrinfo('google.com', 'http', { type = "
"'SOCK_STREAM' })\n"
"print('host=',s[1].host)\n"
"print('family=',s[1].family)\n"
"print('type=',s[1].type)\n"
"print('protocol=',s[1].protocol)\n"
"print('port=',s[1].port)\n"
"print('host=',s[2].host)\n"
"print('family=',s[2].family)\n"
"print('type=',s[2].type)\n"
"print('protocol=',s[2].protocol)\n"
"print('port=',s[2].port)"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local s = require('socket').getaddrinfo('google.com', 'http', { type = "
"'SOCK_STREAM' })\n"
"print('host=',s[1].host)\n"
"print('family=',s[1].family)\n"
"print('type=',s[1].type)\n"
"print('protocol=',s[1].protocol)\n"
"print('port=',s[1].port)\n"
"print('host=',s[2].host)\n"
"print('family=',s[2].family)\n"
"print('type=',s[2].type)\n"
"print('protocol=',s[2].protocol)\n"
"print('port=',s[2].port)"

#: ../doc/1.10/book/app_server/cookbook.rst:625
msgid "socket_udp_echo.lua"
msgstr "socket_udp_echo.lua"

#: ../doc/1.10/book/app_server/cookbook.rst:627
msgid ""
"Tarantool does not currently have a `udp_server` function, therefore "
"socket_udp_echo.lua is more complicated than socket_tcp_echo.lua. It can "
"be implemented with sockets and fibers."
msgstr ""
"В данный момент в Tarantool нет функции `udp_server`, поэтому "
"socket_udp_echo.lua -- более сложная программа, чем socket_tcp_echo.lua. "
"Ее можно реализовать с помощью сокетов и файберов."

#: ../doc/1.10/book/app_server/cookbook.rst:632
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local socket = require('socket')\n"
"local errno = require('errno')\n"
"local fiber = require('fiber')\n"
"\n"
"local function udp_server_loop(s, handler)\n"
"    fiber.name(\"udp_server\")\n"
"    while true do\n"
"        -- try to read a datagram first\n"
"        local msg, peer = s:recvfrom()\n"
"        if msg == \"\" then\n"
"            -- socket was closed via s:close()\n"
"            break\n"
"        elseif msg ~= nil then\n"
"            -- got a new datagram\n"
"            handler(s, peer, msg)\n"
"        else\n"
"            if s:errno() == errno.EAGAIN or s:errno() == errno.EINTR then"
"\n"
"                -- socket is not ready\n"
"                s:readable() -- yield, epoll will wake us when new data "
"arrives\n"
"            else\n"
"                -- socket error\n"
"                local msg = s:error()\n"
"                s:close() -- save resources and don't wait GC\n"
"                error(\"Socket error: \" .. msg)\n"
"            end\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"local function udp_server(host, port, handler)\n"
"    local s = socket('AF_INET', 'SOCK_DGRAM', 0)\n"
"    if not s then\n"
"        return nil -- check errno:strerror()\n"
"    end\n"
"    if not s:bind(host, port) then\n"
"        local e = s:errno() -- save errno\n"
"        s:close()\n"
"        errno(e) -- restore errno\n"
"        return nil -- check errno:strerror()\n"
"    end\n"
"\n"
"    fiber.create(udp_server_loop, s, handler) -- start a new background "
"fiber\n"
"    return s\n"
"end"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local socket = require('socket')\n"
"local errno = require('errno')\n"
"local fiber = require('fiber')\n"
"\n"
"local function udp_server_loop(s, handler)\n"
"    fiber.name(\"udp_server\")\n"
"    while true do\n"
"        -- попытка прочитать сначала датаграмму\n"
"        local msg, peer = s:recvfrom()\n"
"        if msg == \"\" then\n"
"            -- сокет был закрыт с помощью s:close()\n"
"            break\n"
"        elseif msg ~= nil then\n"
"            -- получена новая датаграмма\n"
"            handler(s, peer, msg)\n"
"        else\n"
"            if s:errno() == errno.EAGAIN or s:errno() == errno.EINTR then"
"\n"
"                -- сокет не готов\n"
"                s:readable() -- передача управления, epoll сообщит, когда"
" будут новые данные\n"
"            else\n"
"                -- ошибка сокета\n"
"                local msg = s:error()\n"
"                s:close() -- сохранить ресурсы и не ждать сборку мусора\n"
"                error(\"Socket error: \" .. msg)\n"
"            end\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"local function udp_server(host, port, handler)\n"
"    local s = socket('AF_INET', 'SOCK_DGRAM', 0)\n"
"    if not s then\n"
"        return nil -- проверить номер ошибки errno:strerror()\n"
"   end\n"
"    if not s:bind(host, port) then\n"
"        local e = s:errno() -- сохранить номер ошибки errno\n"
"        s:close()\n"
"        errno(e) -- восстановить номер ошибки errno\n"
"        return nil -- проверить номер ошибки errno:strerror()\n"
"    end\n"
"\n"
"    fiber.create(udp_server_loop, s, handler) -- запустить новый файбер в"
" фоновом режиме\n"
"    return s\n"
"end"

#: ../doc/1.10/book/app_server/cookbook.rst:681
msgid ""
"A function for a client that connects to this server could look something"
" like this ..."
msgstr ""
"Функция для клиента, который подключается к этому серверу, может "
"выглядеть следующим образом:"

#: ../doc/1.10/book/app_server/cookbook.rst:684
msgid ""
"local function handler(s, peer, msg)\n"
"    -- You don't have to wait until socket is ready to send UDP\n"
"    -- s:writable()\n"
"    s:sendto(peer.host, peer.port, \"Pong: \" .. msg)\n"
"end\n"
"\n"
"local server = udp_server('127.0.0.1', 3548, handler)\n"
"if not server then\n"
"    error('Failed to bind: ' .. errno.strerror())\n"
"end\n"
"\n"
"print('Started')\n"
"\n"
"require('console').start()"
msgstr ""
"local function handler(s, peer, msg)\n"
"    -- Необязательно ждать, пока сокет будет готов отправлять UDP\n"
"    -- s:writable()\n"
"    s:sendto(peer.host, peer.port, \"Pong: \" .. msg)\n"
"end\n"
"\n"
"local server = udp_server('127.0.0.1', 3548, handler)\n"
"if not server then\n"
"    error('Failed to bind: ' .. errno.strerror())\n"
"end\n"
"\n"
"print('Started')\n"
"\n"
"require('console').start()"

#: ../doc/1.10/book/app_server/cookbook.rst:705
msgid "http_get.lua"
msgstr "http_get.lua"

#: ../doc/1.10/book/app_server/cookbook.rst:707
msgid "Use the :ref:`http module <http-module>` to get data via HTTP."
msgstr "Используйте :ref:`Модуль HTTP <http-module>` для получения данных по HTTP."

#: ../doc/1.10/book/app_server/cookbook.rst:710
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local http_client = require('http.client')\n"
"local json = require('json')\n"
"local r = "
"http_client.get('http://api.openweathermap.org/data/2.5/weather?q=Oakland,us')"
"\n"
"if r.status ~= 200 then\n"
"    print('Failed to get weather forecast ', r.reason)\n"
"    return\n"
"end\n"
"local data = json.decode(r.body)\n"
"print('Oakland wind speed: ', data.wind.speed)"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local http_client = require('http.client')\n"
"local json = require('json')\n"
"local r = "
"http_client.get('http://api.openweathermap.org/data/2.5/weather?q=Oakland,us')"
"\n"
"if r.status ~= 200 then\n"
"    print('Failed to get weather forecast ', r.reason)\n"
"    return\n"
"end\n"
"local data = json.decode(r.body)\n"
"print('Oakland wind speed: ', data.wind.speed)"

#: ../doc/1.10/book/app_server/cookbook.rst:728
msgid "http_send.lua"
msgstr "http_send.lua"

#: ../doc/1.10/book/app_server/cookbook.rst:730
msgid "Use the :ref:`http module <http-module>` to send data via HTTP."
msgstr "Используйте :ref:`Модуль HTTP <http-module>` для отправки данных по HTTP."

#: ../doc/1.10/book/app_server/cookbook.rst:733
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local http_client = require('http.client')\n"
"local json = require('json')\n"
"local data = json.encode({ Key = 'Value'})\n"
"local headers = { Token = 'xxxx', ['X-Secret-Value'] = 42 }\n"
"local r = http_client.post('http://localhost:8081', data, { headers = "
"headers})\n"
"if r.status == 200 then\n"
"    print 'Success'\n"
"end"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local http_client = require('http.client')\n"
"local json = require('json')\n"
"local data = json.encode({ Key = 'Value'})\n"
"local headers = { Token = 'xxxx', ['X-Secret-Value'] = 42 }\n"
"local r = http_client.post('http://localhost:8081', data, { headers = "
"headers})\n"
"if r.status == 200 then\n"
"    print 'Success'\n"
"end"

#: ../doc/1.10/book/app_server/cookbook.rst:750
msgid "http_server.lua"
msgstr "http_server.lua"

#: ../doc/1.10/book/app_server/cookbook.rst:752
msgid ""
"Use the `http`_ `rock`_ (which must first be installed) to turn Tarantool"
" into a web server."
msgstr ""
"Используйте `сторонний модуль`_ `http`_  (который необходимо "
"предварительно установить), чтобы превратить Tarantool в веб-сервер."

#: ../doc/1.10/book/app_server/cookbook.rst:755
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local function handler(self)\n"
"    return self:render{ json = { ['Your-IP-Is'] = self.peer.host } }\n"
"end\n"
"\n"
"local server = require('http.server').new(nil, 8080) -- listen *:8080\n"
"server:route({ path = '/' }, handler)\n"
"server:start()\n"
"-- connect to localhost:8080 and see json"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local function handler(self)\n"
"    return self:render{ json = { ['Your-IP-Is'] = self.peer.host } }\n"
"end\n"
"\n"
"local server = require('http.server').new(nil, 8080) -- анализировать "
"связь с *:8080\n"
"server:route({ path = '/' }, handler)\n"
"server:start()\n"
"-- подключиться к localhost:8080 и читать JSON"

#: ../doc/1.10/book/app_server/cookbook.rst:772
msgid "http_generate_html.lua"
msgstr "http_generate_html.lua"

#: ../doc/1.10/book/app_server/cookbook.rst:774
msgid ""
"Use the `http`_ `rock` (which must first be installed) to generate HTML "
"pages from templates. The `http`_ `rock`_ has a fairly simple template "
"engine which allows execution of regular Lua code inside text blocks "
"(like PHP). Therefore there is no need to learn new languages in order to"
" write templates."
msgstr ""
"Используйте сторонний модуль `http`_ (который необходимо предварительно "
"установить) для создания HTML-страниц из шаблонов. В `модуле "
"<https://tarantool.io/ru/download/rocks>`_ `http`_ достаточно простой "
"движок шаблонов, который позволяет выполнять регулярный код на Lua в "
"текстовых блоках (как в PHP). Таким образом, нет необходимости в изучении"
" новых языков, чтобы написать шаблоны."

#: ../doc/1.10/book/app_server/cookbook.rst:780
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local function handler(self)\n"
"local fruits = { 'Apple', 'Orange', 'Grapefruit', 'Banana'}\n"
"    return self:render{ fruits = fruits }\n"
"end\n"
"\n"
"local server = require('http.server').new(nil, 8080) -- nil means '*'\n"
"server:route({ path = '/', file = 'index.html.lua' }, handler)\n"
"server:start()"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local function handler(self)\n"
"local fruits = { 'Apple', 'Orange', 'Grapefruit', 'Banana'}\n"
"    return self:render{ fruits = fruits }\n"
"end\n"
"\n"
"local server = require('http.server').new(nil, 8080) -- nil означает '*'\n"
"server:route({ path = '/', file = 'index.html.lua' }, handler)\n"
"server:start()"

#: ../doc/1.10/book/app_server/cookbook.rst:793
msgid ""
"An \"HTML\" file for this server, including Lua, could look like this (it"
" would produce \"1 Apple | 2 Orange | 3 Grapefruit | 4 Banana\")."
msgstr ""
"HTML-файл для этого сервера, включая Lua, может выглядеть следующим "
"образом (он выведет \"1 Apple | 2 Orange | 3 Grapefruit | 4 Banana\")."

#: ../doc/1.10/book/app_server/cookbook.rst:796
#, python-format
msgid ""
"<html>\n"
"<body>\n"
"    <table border=\"1\">\n"
"        % for i,v in pairs(fruits) do\n"
"        <tr>\n"
"            <td><%= i %></td>\n"
"            <td><%= v %></td>\n"
"        </tr>\n"
"        % end\n"
"    </table>\n"
"</body>\n"
"</html>"
msgstr ""
"<html>\n"
"<body>\n"
"    <table border=\"1\">\n"
"        % for i,v in pairs(fruits) do\n"
"        <tr>\n"
"            <td><%= i %></td>\n"
"            <td><%= v %></td>\n"
"        </tr>\n"
"        % end\n"
"    </table>\n"
"</body>\n"
"</html>"

#: ../doc/1.10/book/app_server/creating_app.rst:39
msgid "Creating an application"
msgstr "Создание приложения"

#: ../doc/1.10/book/app_server/creating_app.rst:41
msgid ""
"Further we walk you through key programming practices that will give you "
"a good start in writing Lua applications for Tarantool. For an adventure,"
" this is a story of implementing... a real microservice based on "
"Tarantool! We implement a backend for a simplified version of `Pokémon Go"
" <https://en.wikipedia.org/wiki/Pokémon_Go>`_, a location-based augmented"
" reality game released in mid-2016. In this game, players use a mobile "
"device's GPS capability to locate, capture, battle and train virtual "
"monsters called \"pokémon\", who appear on the screen as if they were in "
"the same real-world location as the player."
msgstr ""
"Далее мы пошагово разберем ключевые методики программирования, что "
"послужит хорошим началом для написания Lua-приложений для Tarantool'а. "
"Для интереса возьмем историю реализации... настоящего микросервиса на "
"основе Tarantool'а! Мы реализуем бэкенд для упрощенной версии `Pokémon Go"
"  <https://ru.wikipedia.org/wiki/Pok%C3%A9mon_Go>`_, игры на основе "
"определения местоположения дополненной реальности, выпущенной в середине "
"2016 года. В этой игре игроки используют GPS-возможности мобильных "
"устройств, чтобы находить, захватывать, сражаться и тренировать "
"виртуальных существ, или покемонов, которые появляются на экране, как "
"если бы они находились в том же реальном месте, как и игрок."

#: ../doc/1.10/book/app_server/creating_app.rst:51
msgid ""
"To stay within the walk-through format, let's narrow the original "
"gameplay as follows. We have a map with pokémon spawn locations. Next, we"
" have multiple players who can send catch-a-pokémon requests to the "
"server (which runs our Tarantool microservice). The server replies "
"whether the pokémon is caught or not, increases the player's pokémon "
"counter if yes, and triggers the respawn-a-pokémon method that spawns a "
"new pokémon at the same location in a while."
msgstr ""
"Чтобы не выходить за рамки пошагового примера, ограничим оригинальный "
"сюжет игры. У нас есть карта с местами появления покемонов. Далее у нас "
"есть несколько игроков, которые могут отправлять запросы на поимку "
"покемона на сервер (где работает микросервис Tarantool'а). Сервер "
"отвечает, пойман ли покемон, увеличивает счетчик покемонов, если пойман, "
"и вызывает метод респауна покемона, который через некоторое время создает"
" нового покемона на том же самом месте."

#: ../doc/1.10/book/app_server/creating_app.rst:59
msgid ""
"We leave client-side applications outside the scope of this story. Yet we"
" promise a mini-demo in the end to simulate real users and give us some "
"fun. :-)"
msgstr ""
"Мы вынесем клиентские приложения за рамки рассказа. Но в конце обещаем "
"небольшую демонстрацию с моделированием настоящих пользователей, чтобы "
"немного поразвлечься. :-)"

#: ../doc/1.10/book/app_server/creating_app.rst:65
msgid "First, what would be the best way to deliver our microservice?"
msgstr "Для начала как лучше всего предоставить микросервис?"

#: ../doc/1.10/book/app_server/creating_app.rst:71
msgid "Modules, rocks and applications"
msgstr "Модули и приложения"

#: ../doc/1.10/book/app_server/creating_app.rst:73
msgid ""
"To make our game logic available to other developers and Lua "
"applications, let's put it into a Lua module."
msgstr ""
"Чтобы наша логическая схема игры была доступна другим разработчикам и "
"Lua-приложениям, поместим ее в Lua-модуль."

#: ../doc/1.10/book/app_server/creating_app.rst:76
msgid ""
"A **module** (called \"rock\" in Lua) is an optional library which "
"enhances Tarantool functionality. So, we can install our logic as a "
"module in Tarantool and use it from any Tarantool application or module. "
"Like applications, modules in Tarantool can be written in Lua (rocks), C "
"or C++."
msgstr ""
"**Модуль** (который называется \"rock\" в Lua) -- это дополнительная "
"библиотека, которая расширяет функции Tarantool'а. Поэтому можно "
"установить нашу логическую схему в виде модуля в Tarantool и использовать"
" ее из любого Tarantool-приложения или модуля. Как и приложения, модули в"
" Tarantool'е могут быть написаны на Lua (rocks), C или C++."

#: ../doc/1.10/book/app_server/creating_app.rst:81
msgid "Modules are good for two things:"
msgstr "Модули хороши для двух целей:"

#: ../doc/1.10/book/app_server/creating_app.rst:83
msgid "easier **code management** (reuse, packaging, versioning), and"
msgstr ""
"облегченное **управление кодом** (переиспользование, подготовка к "
"развертыванию, версионирование) и"

#: ../doc/1.10/book/app_server/creating_app.rst:84
msgid "hot **code reload** without restarting the Tarantool instance."
msgstr "горячая **перезагрузка кода** без перезапуска экземпляра Tarantool'а."

#: ../doc/1.10/book/app_server/creating_app.rst:86
msgid ""
"Technically, a module is a file with source code that exports its "
"functions in an API. For example, here is a Lua module named "
"``mymodule.lua`` that exports one function named ``myfun``:"
msgstr ""
"В техническом смысле, модуль - это файл с исходным кодом, который "
"экспортирует свои функции в API. Например, вот Lua-модуль под названием "
"``mymodule.lua``, который экспортирует одну функцию под названием "
"``myfun``:"

#: ../doc/1.10/book/app_server/creating_app.rst:90
msgid ""
"local exports = {}\n"
"exports.myfun = function(input_string)\n"
"   print('Hello', input_string)\n"
"end\n"
"return exports"
msgstr ""
"local exports = {}\n"
"exports.myfun = function(input_string)\n"
"   print('Hello', input_string)\n"
"end\n"
"return exports"

#: ../doc/1.10/book/app_server/creating_app.rst:98
msgid ""
"To launch the function ``myfun()`` -- from another module, from a Lua "
"application, or from Tarantool itself, -- we need to save this module as "
"a file, then load this module with the ``require()`` directive and call "
"the exported function."
msgstr ""
"Чтобы запустить функцию ``myfun()`` -- из другого модуля, из "
"Lua-приложения или из самого Tarantool'а -- необходимо сохранить этот "
"модуль в виде файла, а затем загрузить этот модуль с директивой "
"``require()`` и вызвать экспортированную функцию."

#: ../doc/1.10/book/app_server/creating_app.rst:102
msgid ""
"For example, here's a Lua application that uses ``myfun()`` function from"
" ``mymodule.lua`` module:"
msgstr ""
"Например, вот Lua-приложение, которое использует функцию ``myfun()`` из "
"модуля ``mymodule.lua``:"

#: ../doc/1.10/book/app_server/creating_app.rst:105
msgid ""
"-- loading the module\n"
"local mymodule = require('mymodule')\n"
"\n"
"-- calling myfun() from within test() function\n"
"local test = function()\n"
"  mymodule.myfun()\n"
"end"
msgstr ""
"-- загрузка модуля\n"
"local mymodule = require('mymodule')\n"
"\n"
"-- вызов myfun() из функции test\n"
"local test = function()\n"
"  mymodule.myfun()\n"
"end"

#: ../doc/1.10/book/app_server/creating_app.rst:115
msgid ""
"A thing to remember here is that the ``require()`` directive takes load "
"paths to Lua modules from the ``package.path`` variable. This is a "
"semicolon-separated string, where a question mark is used to interpolate "
"the module name. By default, this variable contains system-wide Lua paths"
" and the working directory. But if we put our modules inside a specific "
"folder (e.g. ``scripts/``), we need to add this folder to "
"``package.path`` before any calls to ``require()``:"
msgstr ""
"Здесь важно запомнить, что директива ``require()`` берет пути загрузки к "
"Lua-модулям из переменной ``package.path``. Она представляет собой строку"
" с разделителями в виде точки с запятой, где знак вопроса используется "
"для вставки имени модуля. По умолчанию, эта переменная содержит пути в "
"системе и рабочую директорию. Но если мы поместим наши модули в особую "
"папку (например, ``scripts/``), необходимо будет добавить эту папку в "
"``package.path`` до вызова ``require()``:"

#: ../doc/1.10/book/app_server/creating_app.rst:122
msgid "package.path = 'scripts/?.lua;' .. package.path"
msgstr "package.path = 'scripts/?.lua;' .. package.path"

#: ../doc/1.10/book/app_server/creating_app.rst:126
msgid ""
"For our microservice, a simple and convenient solution would be to put "
"all methods in a Lua module (say ``pokemon.lua``) and to write a Lua "
"application (say ``game.lua``) that initializes the gaming environment "
"and starts the game loop."
msgstr ""
"Для нашего микросервиса простым и удобным решением будет разместить все "
"методы в Lua-модуле (скажем, ``pokemon.lua``) и написать Lua-приложение "
"(скажем, ``game.lua``), которое запустит игровое окружение и цикл игры."

#: ../doc/1.10/book/app_server/creating_app.rst:134
msgid ""
"Now let's get down to implementation details. In our game, we need three "
"entities:"
msgstr "Теперь приступим к деталям реализации. В игре нам необходимы три сущности:"

#: ../doc/1.10/book/app_server/creating_app.rst:136
msgid ""
"**map**, which is an array of pokémons with coordinates of respawn "
"locations; in this version of the game, let a location be a rectangle "
"identified with two points, upper-left and lower-right;"
msgstr ""
"**карта**, которая представляет собой массив покемонов с координатами "
"мест респауна; в данной версии игры пусть местом будет прямоугольник, "
"установленный по двум точкам, верхней левой и нижней правой;"

#: ../doc/1.10/book/app_server/creating_app.rst:139
msgid ""
"**player**, which has an ID, a name, and coordinates of the player's "
"location point;"
msgstr "**игрок**, у которого есть ID, имя и координаты местонахождения игрока;"

#: ../doc/1.10/book/app_server/creating_app.rst:141
msgid ""
"**pokémon**, which has the same fields as the player, plus a status "
"(active/inactive, that is present on the map or not) and a catch "
"probability (well, let's give our pokémons a chance to escape :-) )"
msgstr ""
"**покемон**, у которого такие же поля, как и у игрока, плюс статус "
"(активный/неактивный, то есть находится ли на карте) и возможность поимки"
" (давайте уж дадим нашим покемонам шанс сбежать :-) )"

#: ../doc/1.10/book/app_server/creating_app.rst:145
msgid ""
"We'll store these entities as tuples in Tarantool spaces. But to deliver "
"our backend application as a microservice, the good practice would be to "
"send/receive our data in the universal JSON format, thus using Tarantool "
"as a document storage."
msgstr ""
"Эти данные будем хранить как кортежи в спейсах Tarantool'а. Но чтобы "
"бэкенд-приложение работало как микросервис, правильно будет "
"отправлять/получать данные в универсальном формате JSON, используя "
"Tarantool в качестве системы хранения документов."

#: ../doc/1.10/book/app_server/creating_app.rst:153
msgid "Avro schemas"
msgstr "Avro-схемы"

#: ../doc/1.10/book/app_server/creating_app.rst:155
msgid ""
"To store JSON data as tuples, we will apply a savvy practice which "
"reduces data footprint and ensures all stored documents are valid. We "
"will use Tarantool module `avro-schema <https://github.com/tarantool"
"/avro-schema>`_ which checks the schema of a JSON document and converts "
"it to a Tarantool tuple. The tuple will contain only field values, and "
"thus take a lot less space than the original document. In avro-schema "
"terms, converting JSON documents to tuples is \"flattening\", and "
"restoring the original documents is \"unflattening\". The usage is quite "
"straightforward:"
msgstr ""
"Чтобы хранить JSON-данные в виде кортежей, используем продвинутую "
"методику, которая уменьшит отпечаток данных и обеспечит пригодность всех "
"сохраняемых документов. Будем использовать Tarantool-модуль `avro-schema "
"<https://github.com/tarantool/avro-schema>`_, который проверяет схему "
"JSON-документа и конвертирует его в кортеж Tarantool'а. Кортеж будет "
"содержать только значения полей, таким образом, занимая меньше места, чем"
" оригинальный документ. С точки зрения avro-схемы, конвертация "
"JSON-документов в кортежи -- \"flattening\" (конвертация в плоские "
"файлы), а восстановление оригинальных документов -- \"unflattening\" "
"(конвертация из плоских файлов). Использовать модуль достаточно просто:"

#: ../doc/1.10/book/app_server/creating_app.rst:164
msgid ""
"For each entity, we need to define a schema in `Apache Avro schema "
"<https://en.wikipedia.org/wiki/Apache_Avro>`_ syntax, where we list the "
"entity's fields with their names and `Avro data types "
"<http://avro.apache.org/docs/current/spec.html#schema_primitive>`_."
msgstr ""
"Для каждой сущности необходимо определить схему в синтаксисе `схемы "
"Apache Avro <https://en.wikipedia.org/wiki/Apache_Avro>`_, где мы "
"перечисляем поля сущности с их наименованиями и `типами данных по Avro "
"<http://avro.apache.org/docs/current/spec.html#schema_primitive>`_."

#: ../doc/1.10/book/app_server/creating_app.rst:168
msgid ""
"At initialization, we call ``avro-schema.create()`` that creates objects "
"in memory for all schema entities, and ``compile()`` that generates "
"flatten/unflatten methods for each entity."
msgstr ""
"При инициализации мы вызываем функцию ``avro-schema.create()``, которая "
"создает объекты в памяти для всех сущностей схемы, а также функцию "
"``compile()``, которая создает методы flatten/unflatten (конвертация в "
"плоские файлы и обратно) для каждой сущности."

#: ../doc/1.10/book/app_server/creating_app.rst:171
msgid ""
"Further on, we just call flatten/unflatten methods for a respective "
"entity on receiving/sending the entity's data."
msgstr ""
"Далее мы просто вызываем методы flatten/unflatten для соответствующей "
"сущности при получении/отправке данных об этой сущности."

#: ../doc/1.10/book/app_server/creating_app.rst:174
msgid ""
"Here's what our schema definitions for the player and pokémon entities "
"look like:"
msgstr "Вот как будут выглядеть определения схемы для сущностей игрока и покемона:"

#: ../doc/1.10/book/app_server/creating_app.rst:176
msgid ""
"local schema = {\n"
"    player = {\n"
"        type=\"record\",\n"
"        name=\"player_schema\",\n"
"        fields={\n"
"            {name=\"id\", type=\"long\"},\n"
"            {name=\"name\", type=\"string\"},\n"
"            {\n"
"                name=\"location\",\n"
"                type= {\n"
"                    type=\"record\",\n"
"                    name=\"player_location\",\n"
"                    fields={\n"
"                        {name=\"x\", type=\"double\"},\n"
"                        {name=\"y\", type=\"double\"}\n"
"                    }\n"
"                }\n"
"            }\n"
"        }\n"
"    },\n"
"    pokemon = {\n"
"        type=\"record\",\n"
"        name=\"pokemon_schema\",\n"
"        fields={\n"
"            {name=\"id\", type=\"long\"},\n"
"            {name=\"status\", type=\"string\"},\n"
"            {name=\"name\", type=\"string\"},\n"
"            {name=\"chance\", type=\"double\"},\n"
"            {\n"
"                name=\"location\",\n"
"                type= {\n"
"                    type=\"record\",\n"
"                    name=\"pokemon_location\",\n"
"                    fields={\n"
"                        {name=\"x\", type=\"double\"},\n"
"                        {name=\"y\", type=\"double\"}\n"
"                    }\n"
"                }\n"
"            }\n"
"        }\n"
"    }\n"
"}"
msgstr ""
"local schema = {\n"
"    player = {\n"
"        type=\"record\",\n"
"        name=\"player_schema\",\n"
"        fields={\n"
"            {name=\"id\", type=\"long\"},\n"
"            {name=\"name\", type=\"string\"},\n"
"            {\n"
"                name=\"location\",\n"
"                type= {\n"
"                    type=\"record\",\n"
"                    name=\"player_location\",\n"
"                    fields={\n"
"                        {name=\"x\", type=\"double\"},\n"
"                        {name=\"y\", type=\"double\"}\n"
"                    }\n"
"                }\n"
"            }\n"
"        }\n"
"    },\n"
"    pokemon = {\n"
"        type=\"record\",\n"
"        name=\"pokemon_schema\",\n"
"        fields={\n"
"            {name=\"id\", type=\"long\"},\n"
"            {name=\"status\", type=\"string\"},\n"
"            {name=\"name\", type=\"string\"},\n"
"            {name=\"chance\", type=\"double\"},\n"
"            {\n"
"                name=\"location\",\n"
"                type= {\n"
"                    type=\"record\",\n"
"                    name=\"pokemon_location\",\n"
"                    fields={\n"
"                        {name=\"x\", type=\"double\"},\n"
"                        {name=\"y\", type=\"double\"}\n"
"                    }\n"
"                }\n"
"            }\n"
"        }\n"
"    }\n"
"}"

#: ../doc/1.10/book/app_server/creating_app.rst:221
msgid "And here's how we create and compile our entities at initialization:"
msgstr "А вот как мы создадим и скомпилируем наши сущности при инициализации:"

#: ../doc/1.10/book/app_server/creating_app.rst:223
msgid ""
"-- load avro-schema module with require()\n"
"local avro = require('avro_schema')\n"
"\n"
"-- create models\n"
"local ok_m, pokemon = avro.create(schema.pokemon)\n"
"local ok_p, player = avro.create(schema.player)\n"
"if ok_m and ok_p then\n"
"    -- compile models\n"
"    local ok_cm, compiled_pokemon = avro.compile(pokemon)\n"
"    local ok_cp, compiled_player = avro.compile(player)\n"
"    if ok_cm and ok_cp then\n"
"        -- start the game\n"
"        <...>\n"
"    else\n"
"        log.error('Schema compilation failed')\n"
"    end\n"
"else\n"
"    log.info('Schema creation failed')\n"
"end\n"
"return false"
msgstr ""
"-- загрузить модуль avro-schema с директивой require()\n"
"local avro = require('avro_schema')\n"
"\n"
"-- создать модели\n"
"local ok_m, pokemon = avro.create(schema.pokemon)\n"
"local ok_p, player = avro.create(schema.player)\n"
"if ok_m and ok_p then\n"
"    -- скомпилировать модели\n"
"    local ok_cm, compiled_pokemon = avro.compile(pokemon)\n"
"    local ok_cp, compiled_player = avro.compile(player)\n"
"    if ok_cm and ok_cp then\n"
"        -- начать игру\n"
"        <...>\n"
"    else\n"
"        log.error('Schema compilation failed')\n"
"    end\n"
"else\n"
"    log.info('Schema creation failed')\n"
"end\n"
"return false"

#: ../doc/1.10/book/app_server/creating_app.rst:246
msgid ""
"As for the map entity, it would be an overkill to introduce a schema for "
"it, because we have only one map in the game, it has very few fields, and"
" -- which is most important -- we use the map only inside our logic, "
"never exposing it to external users."
msgstr ""
"Что касается сущности карты, вводить для нее схему будет перебор, потому "
"что в игре всего одна карта, у нее мало полей, и -- что самое главное -- "
"мы используем карту только внутри нашей логики, не показывая ее внешним "
"пользователям."

#: ../doc/1.10/book/app_server/creating_app.rst:254
msgid ""
"Next, we need methods to implement the game logic. To simulate object-"
"oriented programming in our Lua code, let's store all Lua functions and "
"shared variables in a single local variable (let's name it as ``game``). "
"This will allow us to address functions or variables from within our "
"module as ``self.func_name`` or ``self.var_name``. Like this:"
msgstr ""
"Далее нам нужны методы для реализации игровой логики. Чтобы смоделировать"
" объектно-ориентированное программирование в нашем Lua-коде, будем "
"хранить все Lua-функции и общие переменные в одной внутренней переменной "
"(назовем ее ``game``). Это позволит нам обращаться к функциям или "
"переменным из нашего модуля с помощью ``self.func_name`` или "
"``self.var_name`` следующим образом:"

#: ../doc/1.10/book/app_server/creating_app.rst:260
msgid ""
"local game = {\n"
"    -- a local variable\n"
"    num_players = 0,\n"
"\n"
"    -- a method that prints a local variable\n"
"    hello = function(self)\n"
"      print('Hello! Your player number is ' .. self.num_players .. '.')\n"
"    end,\n"
"\n"
"    -- a method that calls another method and returns a local variable\n"
"    sign_in = function(self)\n"
"      self.num_players = self.num_players + 1\n"
"      self:hello()\n"
"      return self.num_players\n"
"    end\n"
"}"
msgstr ""
"local game = {\n"
"    -- локальная переменная\n"
"    num_players = 0,\n"
"\n"
"    -- метод, который выводит локальную переменную\n"
"    hello = function(self)\n"
"      print('Hello! Your player number is ' .. self.num_players .. '.')\n"
"    end,\n"
"\n"
"    -- метод, который вызывает другой метод и возвращает локальную "
"переменную\n"
"    sign_in = function(self)\n"
"      self.num_players = self.num_players + 1\n"
"      self:hello()\n"
"      return self.num_players\n"
"    end\n"
"}"

#: ../doc/1.10/book/app_server/creating_app.rst:279
msgid ""
"In OOP terms, we can now regard local variables inside ``game`` as object"
" fields, and local functions as object methods."
msgstr ""
"В терминах ООП сейчас мы можем рассматривать внутренние переменные внутри"
" переменной ``game`` как поля объекта, а внутренние функции -- как методы"
" объекта."

#: ../doc/1.10/book/app_server/creating_app.rst:284
msgid ""
"In this manual, Lua examples use **local** variables. Use **global** "
"variables with caution, since the module’s users may be unaware of them."
msgstr ""
"Обратите внимание, что в текущей документации в примерах Lua-кода "
"используются *локальные* переменные. Используйте *глобальные* переменные "
"аккуратно, поскольку пользователи ваших модулей могут не знать об этих "
"переменных."

#: ../doc/1.10/book/app_server/creating_app.rst:287
msgid ""
"To enable/disable the use of undeclared global variables in your Lua "
"code, use Tarantool's :ref:`strict <strict-module>` module."
msgstr ""
"Чтобы включить/отключить использование необъявленных глобальных "
"переменных в вашем коде на языке Lua, используйте модуль Tarantool'а "
":ref:`strict <strict-module>`."

#: ../doc/1.10/book/app_server/creating_app.rst:290
msgid "So, our game module will have the following methods:"
msgstr "Таким образом, в модуле игры будут следующие методы:"

#: ../doc/1.10/book/app_server/creating_app.rst:292
msgid ""
"``catch()`` to calculate whether the pokémon was caught (besides the "
"coordinates of both the player and pokémon, this method will apply a "
"probability factor, so not every pokémon within the player's reach will "
"be caught);"
msgstr ""
"``catch()`` (поймать) для расчета, когда был пойман покемон (помимо "
"координат как игрока, так и покемона, этот метод будет использовать "
"коэффициент вероятности, чтобы в пределах досягаемости игрока можно было "
"поймать не каждого покемона);"

#: ../doc/1.10/book/app_server/creating_app.rst:296
msgid ""
"``respawn()`` to add missing pokémons to the map, say, every 60 seconds "
"(we assume that a frightened pokémon runs away, so we remove a pokémon "
"from the map on any catch attempt and add it back to the map in a while);"
msgstr ""
"``respawn()`` (респаун) для добавления отсутствующих покемонов на карту, "
"скажем, каждые 60 секунд (предположим, что испуганный покемон убегает, "
"поэтому мы убираем покемона с карты при любой попытке поймать его и через"
" некоторое время добавляем обратно на карту);"

#: ../doc/1.10/book/app_server/creating_app.rst:299
msgid ""
"``notify()`` to log information about caught pokémons (like \"Player 1 "
"caught pokémon A\");"
msgstr ""
"``notify()`` (уведомить) для записи информации о пойманных покемонах "
"(например, \"Игрок 1 поймал покемона A\");"

#: ../doc/1.10/book/app_server/creating_app.rst:301
msgid ""
"``start()`` to initialize the game (it will create database spaces, "
"create and compile avro schemas, and launch ``respawn()``)."
msgstr ""
"``start()`` (начать) для инициализации игры (метод создаст спейсы в базе "
"данных, создаст и скомпилирует avro-схемы, а также запустит метод "
"``respawn()``)."

#: ../doc/1.10/book/app_server/creating_app.rst:304
msgid ""
"Besides, it would be convenient to have methods for working with "
"Tarantool storage. For example:"
msgstr ""
"Кроме того, было бы удобно завести методы для работы с хранилищем "
"Tarantool'а. Например:"

#: ../doc/1.10/book/app_server/creating_app.rst:307
msgid "``add_pokemon()`` to add a pokémon to the database, and"
msgstr ""
"``add_pokemon()`` (добавить покемона) для добавления покемона в базу "
"данных и"

#: ../doc/1.10/book/app_server/creating_app.rst:308
msgid "``map()`` to populate the map with all pokémons stored in Tarantool."
msgstr ""
"``map()`` (карта) для заполнения карты всеми покемонами, которые хранятся"
" в Tarantool'е."

#: ../doc/1.10/book/app_server/creating_app.rst:310
msgid ""
"We'll need these two methods primarily when initializing our game, but we"
" can also call them later, for example to test our code."
msgstr ""
"Эти два метода будут главным образом использоваться во время "
"инициализации нашей игры, но их также можно вызывать позднее, например "
"для тестирования кода."

#: ../doc/1.10/book/app_server/creating_app.rst:317
msgid "Bootstrapping a database"
msgstr "Настройка базы данных"

#: ../doc/1.10/book/app_server/creating_app.rst:319
msgid ""
"Let's discuss game initialization. In ``start()`` method, we need to "
"populate Tarantool spaces with pokémon data. Why not keep all game data "
"in memory? Why use a database? The answer is: :ref:`persistence <index-"
"box_persistence>`. Without a database, we risk losing data on power "
"outage, for example. But if we store our data in an in-memory database, "
"Tarantool takes care to persist it on disk whenever it's changed. This "
"gives us one more benefit: quick startup in case of failure. Tarantool "
"has a :ref:`smart algorithm <internals-recovery_process>` that quickly "
"loads all data from disk into memory on startup, so the warm-up takes "
"little time."
msgstr ""
"Обсудим инициализацию игры. В методе ``start()`` нам нужно заполнить "
"спейсы Tarantool'а данными о покемонах. Почему бы не хранить все игровые "
"данные в памяти? Зачем нужна база данных? Ответ на это: "
":ref:`персистентность <index-box_persistence>`. Без базы данных мы "
"рискуем потерять данные при отключении электроэнергии, например. Но если "
"мы храним данные в in-memory базе данных, Tarantool позаботится о том, "
"чтобы обеспечить постоянное хранение данных при их изменении. Это дает "
"дополнительное преимущество: быстрая загрузка в случае отказа. "
":ref:`Умный алгоритм <internals-recovery_process>` Tarantool'а быстро "
"загружает все данные с диска в память при начале работы, так что "
"подготовка к работе не займет много времени."

#: ../doc/1.10/book/app_server/creating_app.rst:329
msgid ""
"We'll be using functions from Tarantool built-in :ref:`box <box-module>` "
"module:"
msgstr ""
"Мы будем использовать функции из встроенного модуля Tarantool'а :ref:`box"
" <box-module>`:"

#: ../doc/1.10/book/app_server/creating_app.rst:331
msgid ""
"``box.schema.create_space('pokemons')`` to create a space named "
"``pokemon`` for storing information about pokémons (we don't create a "
"similar space for players, because we intend to only send/receive player "
"information via API calls, so we needn't store it);"
msgstr ""
"``box.schema.create_space('pokemons')`` для создания спейса под названием"
" ``pokemon`` (покемон), чтобы хранить информацию о покемонах (мы не "
"создаем аналогичный спейс по игрокам, потому что планируем только "
"отправлять и получать информацию об игроках с помощью вызовов API, так "
"что нет необходимости хранить ее);"

#: ../doc/1.10/book/app_server/creating_app.rst:335
msgid ""
"``box.space.pokemons:create_index('primary', {type = 'hash', parts = {1, "
"'unsigned'}})`` to create a primary HASH index by pokémon ID;"
msgstr ""
"``box.space.pokemons:create_index('primary', {type = 'hash', parts = {1, "
"'unsigned'}})`` для создания первичного HASH-индекса по ID покемона;"

#: ../doc/1.10/book/app_server/creating_app.rst:337
msgid ""
"``box.space.pokemons:create_index('status', {type = 'tree', parts = {2, "
"'str'}})`` to create a secondary TREE index by pokémon status."
msgstr ""
"``box.space.pokemons:create_index('status', {type = 'tree', parts = {2, "
"'str'}})`` для создания вторичного TREE-индекса по статусу покемона."

#: ../doc/1.10/book/app_server/creating_app.rst:340
msgid ""
"Notice the ``parts =`` argument in the index specification. The pokémon "
"ID is the first field in a Tarantool tuple since it’s the first member of"
" the respective Avro type. So does the pokémon status. The actual JSON "
"document may have ID or status fields at any position of the JSON map."
msgstr ""
"Обратите внимание на аргумент ``parts =`` в спецификации индекса. ID "
"покемона -- это первое поле в кортеже Tarantool'а, потому что это первый "
"элемент соответствующего типа Avro. То же относится к статусу покемона. В"
" самом JSON-файле поля ID или статуса могут быть в любом положении на "
"JSON-карте."

#: ../doc/1.10/book/app_server/creating_app.rst:345
msgid "The implementation of ``start()`` method looks like this:"
msgstr "Реализация метода ``start()`` выглядит следующим образом:"

#: ../doc/1.10/book/app_server/creating_app.rst:347
msgid ""
"-- create game object\n"
"start = function(self)\n"
"    -- create spaces and indexes\n"
"    box.once('init', function()\n"
"        box.schema.create_space('pokemons')\n"
"        box.space.pokemons:create_index(\n"
"            \"primary\", {type = 'hash', parts = {1, 'unsigned'}}\n"
"        )\n"
"        box.space.pokemons:create_index(\n"
"            \"status\", {type = \"tree\", parts = {2, 'str'}}\n"
"        )\n"
"    end)\n"
"\n"
"    -- create models\n"
"    local ok_m, pokemon = avro.create(schema.pokemon)\n"
"    local ok_p, player = avro.create(schema.player)\n"
"    if ok_m and ok_p then\n"
"        -- compile models\n"
"        local ok_cm, compiled_pokemon = avro.compile(pokemon)\n"
"        local ok_cp, compiled_player = avro.compile(player)\n"
"        if ok_cm and ok_cp then\n"
"            -- start the game\n"
"            <...>\n"
"        else\n"
"            log.error('Schema compilation failed')\n"
"        end\n"
"    else\n"
"        log.info('Schema creation failed')\n"
"    end\n"
"    return false\n"
"end"
msgstr ""
"-- создать игровой объект\n"
"start = function(self)\n"
"    -- создать спейсы и индексы\n"
"    box.once('init', function()\n"
"        box.schema.create_space('pokemons')\n"
"        box.space.pokemons:create_index(\n"
"            \"primary\", {type = 'hash', parts = {1, 'unsigned'}}\n"
"        )\n"
"        box.space.pokemons:create_index(\n"
"            \"status\", {type = \"tree\", parts = {2, 'str'}}\n"
"        )\n"
"    end)\n"
"\n"
"    -- создать модели\n"
"    local ok_m, pokemon = avro.create(schema.pokemon)\n"
"    local ok_p, player = avro.create(schema.player)\n"
"    if ok_m and ok_p then\n"
"        -- скомпилировать модели\n"
"        local ok_cm, compiled_pokemon = avro.compile(pokemon)\n"
"        local ok_cp, compiled_player = avro.compile(player)\n"
"        if ok_cm and ok_cp then\n"
"            -- начать игру\n"
"            <...>\n"
"        else\n"
"            log.error('Schema compilation failed')\n"
"        end\n"
"    else\n"
"        log.info('Schema creation failed')\n"
"    end\n"
"    return false\n"
"end"

#: ../doc/1.10/book/app_server/creating_app.rst:385
msgid "GIS"
msgstr "ГИС"

#: ../doc/1.10/book/app_server/creating_app.rst:387
msgid ""
"Now let's discuss ``catch()``, which is the main method in our gaming "
"logic."
msgstr ""
"Теперь обсудим метод ``catch()``, который является основным в логике "
"нашей игры."

#: ../doc/1.10/book/app_server/creating_app.rst:389
msgid ""
"Here we receive the player's coordinates and the target pokémon's ID "
"number, and we need to answer whether the player has actually caught the "
"pokémon or not (remember that each pokémon has a chance to escape)."
msgstr ""
"Здесь мы получаем координаты игрока и номер ID искомого покемона, а нужен"
" нам ответ на вопрос, поймали ли игрок покемона (помните, что у каждого "
"покемона есть шанс убежать)."

#: ../doc/1.10/book/app_server/creating_app.rst:393
msgid ""
"First thing, we validate the received player data against its :ref:`Avro "
"schema <app_server-avro_schemas>`. And we check whether such a pokémon "
"exists in our database and is displayed on the map (the pokémon must have"
" the active status):"
msgstr ""
"Для начала проверим полученные данные об игроке по :ref:`Avro-схеме "
"<app_server-avro_schemas>`. Также проверим, есть ли такой покемон в базе "
"данных, и отображается ли он на карте (у покемона должен быть активный "
"статус):"

#: ../doc/1.10/book/app_server/creating_app.rst:398
msgid ""
"catch = function(self, pokemon_id, player)\n"
"    -- check player data\n"
"    local ok, tuple = self.player_model.flatten(player)\n"
"    if not ok then\n"
"        return false\n"
"    end\n"
"    -- get pokemon data\n"
"    local p_tuple = box.space.pokemons:get(pokemon_id)\n"
"    if p_tuple == nil then\n"
"        return false\n"
"    end\n"
"    local ok, pokemon = self.pokemon_model.unflatten(p_tuple)\n"
"    if not ok then\n"
"        return false\n"
"    end\n"
"    if pokemon.status ~= self.state.ACTIVE then\n"
"        return false\n"
"    end\n"
"    -- more catch logic to follow\n"
"    <...>\n"
"end"
msgstr ""
"catch = function(self, pokemon_id, player)\n"
"    -- проверить данные игрока\n"
"    local ok, tuple = self.player_model.flatten(player)\n"
"    if not ok then\n"
"        return false\n"
"    end\n"
"    -- получить данные покемона\n"
"    local p_tuple = box.space.pokemons:get(pokemon_id)\n"
"    if p_tuple == nil then\n"
"        return false\n"
"    end\n"
"    local ok, pokemon = self.pokemon_model.unflatten(p_tuple)\n"
"    if not ok then\n"
"        return false\n"
"    end\n"
"    if pokemon.status ~= self.state.ACTIVE then\n"
"        return false\n"
"    end\n"
"    -- логика поимки будет дополняться\n"
"    <...>\n"
"end"

#: ../doc/1.10/book/app_server/creating_app.rst:422
msgid "Next, we calculate the answer: caught or not."
msgstr "Далее вычисляем ответ: пойман или нет."

#: ../doc/1.10/book/app_server/creating_app.rst:424
msgid ""
"To work with geographical coordinates, we use Tarantool `gis "
"<https://github.com/tarantool/gis>`_ module."
msgstr ""
"Чтобы работать с географическими координатами, используем модуль "
"Tarantool'а `gis <https://github.com/tarantool/gis>`_."

#: ../doc/1.10/book/app_server/creating_app.rst:427
msgid ""
"To keep things simple, we don't load any specific map, assuming that we "
"deal with a world map. And we do not validate incoming coordinates, "
"assuming again that all received locations are within the planet Earth."
msgstr ""
"Чтобы не усложнять, не будем загружать какую-то особую карту, допуская, "
"что рассматриваем карту мира. Также не будет проверять поступающие "
"координаты, снова допуская, что все места находятся на планете Земля."

#: ../doc/1.10/book/app_server/creating_app.rst:431
msgid "We use two geo-specific variables:"
msgstr "Используем две географические переменные:"

#: ../doc/1.10/book/app_server/creating_app.rst:433
msgid ""
"``wgs84``, which stands for the latest revision of the World Geodetic "
"System standard, `WGS84 "
"<https://en.wikipedia.org/wiki/World_Geodetic_System#WGS84>`_. Basically,"
" it comprises a standard coordinate system for the Earth and represents "
"the Earth as an ellipsoid."
msgstr ""
"``wgs84``, что означает последнюю редакцию стандарта Мировой "
"геодезической системы координат, `WGS84 "
"<https://en.wikipedia.org/wiki/World_Geodetic_System#WGS84>`_. В целом, "
"она представляет собой стандартную систему координат Земли и изображает "
"Землю как эллипсоид."

#: ../doc/1.10/book/app_server/creating_app.rst:437
msgid ""
"``nationalmap``, which stands for the `US National Atlas Equal Area "
"<https://epsg.io/2163>`_. This is a projected coordinates system based on"
" WGS84. It gives us a zero base for location projection and allows "
"positioning our players and pokémons in meters."
msgstr ""
"``nationalmap``, что означает `Государственный атлас США в равновеликой "
"проекции (US National Atlas Equal Area) <https://epsg.io/2163>`_. Это "
"система спроецированных координат на основании WGS84. Она дает основу для"
" проецирования мест и позволяет определить местоположение наших игроков и"
" покемонов в метрах."

#: ../doc/1.10/book/app_server/creating_app.rst:442
msgid ""
"Both these systems are listed in the EPSG Geodetic Parameter Registry, "
"where each system has a unique number. In our code, we assign these "
"listing numbers to respective variables:"
msgstr ""
"Обе системы указаны в Реестре геодезических параметров EPSG, где каждой "
"системе присвоен уникальный номер. Мы назначим эти числа соответствующим "
"переменным в нашем коде:"

#: ../doc/1.10/book/app_server/creating_app.rst:446
msgid ""
"wgs84 = 4326,\n"
"nationalmap = 2163,"
msgstr ""
"wgs84 = 4326,\n"
"nationalmap = 2163,"

#: ../doc/1.10/book/app_server/creating_app.rst:451
msgid ""
"For our game logic, we need one more variable, ``catch_distance``, which "
"defines how close a player must get to a pokémon before trying to catch "
"it. Let's set the distance to 100 meters."
msgstr ""
"Для игровой логики необходима еще одна переменная ``catch_distance``, "
"которая определяет, насколько близко игрок должен подойти к покемону, "
"чтобы попытаться поймать его. Определим это расстояние в 100 метров."

#: ../doc/1.10/book/app_server/creating_app.rst:455
msgid "catch_distance = 100,"
msgstr "catch_distance = 100,"

#: ../doc/1.10/book/app_server/creating_app.rst:459
msgid ""
"Now we're ready to calculate the answer. We need to project the current "
"location of both player (``p_pos``) and pokémon (``m_pos``) on the map, "
"check whether the player is close enough to the pokémon (using "
"``catch_distance``), and calculate whether the player has caught the "
"pokémon (here we generate some random value and let the pokémon escape if"
" the random value happens to be less than 100 minus pokémon's chance "
"value):"
msgstr ""
"Теперь можно рассчитать ответ. Необходимо спроецировать текущее "
"местоположение как игрока (``p_pos``), так и покемона (``m_pos``) на "
"карте, проверить, достаточно ли близко к покемону находится игрок (с "
"помощью ``catch_distance``), и рассчитать, поймал ли игрок покемона "
"(здесь мы генерируем случайное значение, и покемон убегает, если "
"случайное значение оказывается меньше, чем 100 минус случайная величина "
"покемона):"

#: ../doc/1.10/book/app_server/creating_app.rst:466
msgid ""
"-- project locations\n"
"local m_pos = gis.Point(\n"
"    {pokemon.location.x, pokemon.location.y}, self.wgs84\n"
"):transform(self.nationalmap)\n"
"local p_pos = gis.Point(\n"
"    {player.location.x, player.location.y}, self.wgs84\n"
"):transform(self.nationalmap)\n"
"\n"
"-- check catch distance condition\n"
"if p_pos:distance(m_pos) > self.catch_distance then\n"
"    return false\n"
"end\n"
"-- try to catch pokemon\n"
"local caught = math.random(100) >= 100 - pokemon.chance\n"
"if caught then\n"
"    -- update and notify on success\n"
"    box.space.pokemons:update(\n"
"        pokemon_id, {{'=', self.STATUS, self.state.CAUGHT}}\n"
"    )\n"
"    self:notify(player, pokemon)\n"
"end\n"
"return caught"
msgstr ""
"-- спроецировать местоположение\n"
" local m_pos = gis.Point(\n"
"     {pokemon.location.x, pokemon.location.y}, self.wgs84\n"
" ):transform(self.nationalmap)\n"
" local p_pos = gis.Point(\n"
"     {player.location.x, player.location.y}, self.wgs84\n"
" ):transform(self.nationalmap)\n"
" \n"
" -- проверить условие близости игрока\n"
" if p_pos:distance(m_pos) > self.catch_distance then\n"
"     return false\n"
" end\n"
" -- попытаться поймать покемона\n"
" local caught = math.random(100) >= 100 - pokemon.chance\n"
" if caught then\n"
"     -- обновить и сообщить об успехе\n"
"     box.space.pokemons:update(\n"
"         pokemon_id, {{'=', self.STATUS, self.state.CAUGHT}}\n"
"     )\n"
"     self:notify(player, pokemon)\n"
" end\n"
" return caught"

#: ../doc/1.10/book/app_server/creating_app.rst:495
msgid "Index iterators"
msgstr "Итератор с индексом"

#: ../doc/1.10/book/app_server/creating_app.rst:497
msgid ""
"By our gameplay, all caught pokémons are returned back to the map. We do "
"this for all pokémons on the map every 60 seconds using ``respawn()`` "
"method. We iterate through pokémons by status using Tarantool index "
"iterator function :ref:`index:pairs <box_index-index_pairs>` and reset "
"the statuses of all \"caught\" pokémons back to \"active\" using "
"``box.space.pokemons:update()``."
msgstr ""
"По сюжету игры все пойманные покемоны возвращаются на карту. Метод "
"``respawn()`` обеспечивает это для всех покемонов на карте каждые 60 "
"секунд. Мы выполняем перебор покемонов по статусу с помощью функции "
"Tarantool'а итератора с индексом :ref:`index:pairs <box_index-"
"index_pairs>` и сбрасываем статусы всех \"пойманных\" покемонов обратно "
"на \"активный\" с помощью ``box.space.pokemons:update()``."

#: ../doc/1.10/book/app_server/creating_app.rst:503
msgid ""
"respawn = function(self)\n"
"    fiber.name('Respawn fiber')\n"
"    for _, tuple in box.space.pokemons.index.status:pairs(\n"
"           self.state.CAUGHT) do\n"
"        box.space.pokemons:update(\n"
"            tuple[self.ID],\n"
"            {{'=', self.STATUS, self.state.ACTIVE}}\n"
"        )\n"
"    end\n"
" end"
msgstr ""
"respawn = function(self)\n"
"    fiber.name('Respawn fiber')\n"
"    for _, tuple in box.space.pokemons.index.status:pairs(\n"
"           self.state.CAUGHT) do\n"
"        box.space.pokemons:update(\n"
"            tuple[self.ID],\n"
"            {{'=', self.STATUS, self.state.ACTIVE}}\n"
"        )\n"
"    end\n"
" end"

#: ../doc/1.10/book/app_server/creating_app.rst:516
msgid "For readability, we introduce named fields:"
msgstr "Для удобства введем именованные поля:"

#: ../doc/1.10/book/app_server/creating_app.rst:518
msgid "ID = 1, STATUS = 2,"
msgstr "ID = 1, STATUS = 2,"

#: ../doc/1.10/book/app_server/creating_app.rst:521
msgid "The complete implementation of ``start()`` now looks like this:"
msgstr "Реализация метода ``start()`` полностью теперь выглядит так:"

#: ../doc/1.10/book/app_server/creating_app.rst:523
msgid ""
"-- create game object\n"
"start = function(self)\n"
"    -- create spaces and indexes\n"
"    box.once('init', function()\n"
"       box.schema.create_space('pokemons')\n"
"       box.space.pokemons:create_index(\n"
"           \"primary\", {type = 'hash', parts = {1, 'unsigned'}}\n"
"       )\n"
"       box.space.pokemons:create_index(\n"
"           \"status\", {type = \"tree\", parts = {2, 'str'}}\n"
"       )\n"
"    end)\n"
"\n"
"    -- create models\n"
"    local ok_m, pokemon = avro.create(schema.pokemon)\n"
"    local ok_p, player = avro.create(schema.player)\n"
"    if ok_m and ok_p then\n"
"        -- compile models\n"
"        local ok_cm, compiled_pokemon = avro.compile(pokemon)\n"
"        local ok_cp, compiled_player = avro.compile(player)\n"
"        if ok_cm and ok_cp then\n"
"            -- start the game\n"
"            self.pokemon_model = compiled_pokemon\n"
"            self.player_model = compiled_player\n"
"            self.respawn()\n"
"            log.info('Started')\n"
"            return true\n"
"         else\n"
"            log.error('Schema compilation failed')\n"
"         end\n"
"    else\n"
"        log.info('Schema creation failed')\n"
"    end\n"
"    return false\n"
"end"
msgstr ""
"-- создать игровой объект\n"
"start = function(self)\n"
"    -- создать спейсы и индексы\n"
"    box.once('init', function()\n"
"       box.schema.create_space('pokemons')\n"
"       box.space.pokemons:create_index(\n"
"           \"primary\", {type = 'hash', parts = {1, 'unsigned'}}\n"
"       )\n"
"       box.space.pokemons:create_index(\n"
"           \"status\", {type = \"tree\", parts = {2, 'str'}}\n"
"       )\n"
"    end)\n"
"\n"
"    -- создать модели\n"
"    local ok_m, pokemon = avro.create(schema.pokemon)\n"
"    local ok_p, player = avro.create(schema.player)\n"
"    if ok_m and ok_p then\n"
"        -- скомпилировать модели\n"
"        local ok_cm, compiled_pokemon = avro.compile(pokemon)\n"
"        local ok_cp, compiled_player = avro.compile(player)\n"
"        if ok_cm and ok_cp then\n"
"            -- начать игру\n"
"            self.pokemon_model = compiled_pokemon\n"
"            self.player_model = compiled_player\n"
"            self.respawn()\n"
"            log.info('Started')\n"
"            return true\n"
"         else\n"
"            log.error('Schema compilation failed')\n"
"         end\n"
"    else\n"
"        log.info('Schema creation failed')\n"
"    end\n"
"    return false\n"
"end"

#: ../doc/1.10/book/app_server/creating_app.rst:563
#: ../doc/1.10/reference/reference_lua/fiber.rst:176
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:969
msgid "Fibers"
msgstr "Файберы"

#: ../doc/1.10/book/app_server/creating_app.rst:565
msgid ""
"But wait! If we launch it as shown above -- ``self.respawn()`` -- the "
"function will be executed only once, just like all the other methods. But"
" we need to execute ``respawn()`` every 60 seconds. Creating a "
":ref:`fiber <fiber-module>` is the Tarantool way of making application "
"logic work in the background at all times."
msgstr ""
"Но подождите! Если мы запустим функцию ``self.respawn()``, как показано "
"выше, то она запустится только один раз, как и остальные методы. А нам "
"необходимо запускать ``respawn()`` каждые 60 секунд. Tarantool заставляет"
" логику приложения непрерывно работать в фоновом режиме с помощью "
":ref:`файбера <fiber-module>`."

#: ../doc/1.10/book/app_server/creating_app.rst:571
msgid ""
"A **fiber** exists for executing instruction sequences but it is not a "
"thread. The key difference is that threads use preemptive multitasking, "
"while fibers use cooperative multitasking. This gives fibers the "
"following two advantages over threads:"
msgstr ""
"**Файбер** предназначен для выполнения последовательностей команд, но это"
" не поток. Ключевое отличие в том, что потоки используют многозадачность "
"с реализацией приоритетов, тогда как файберы используют кооперативную "
"многозадачность. Это дает файберам два преимущества над потоками:"

#: ../doc/1.10/book/app_server/creating_app.rst:576
msgid ""
"Better controllability. Threads often depend on the kernel's thread "
"scheduler to preempt a busy thread and resume another thread, so "
"preemption may occur unpredictably. Fibers yield themselves to run "
"another fiber while executing, so yields are controlled by application "
"logic."
msgstr ""
"Улучшенная управляемость. Потоки часто зависят от планировщика потока "
"ядра в вопросе вытеснения занятого потока и возобновления другого потока,"
" поэтому вытеснение может быть непредвиденным. Файберы передают "
"управление самостоятельно другому файберу во время работы, поэтому "
"управление файберами осуществляется логикой приложения."

#: ../doc/1.10/book/app_server/creating_app.rst:580
msgid ""
"Higher performance. Threads require more resources to preempt as they "
"need to address the system kernel. Fibers are lighter and faster as they "
"don't need to address the kernel to yield."
msgstr ""
"Повышенная производительность. Потокам необходимо больше ресурсов для "
"вытеснения, поскольку они обращаются к ядру системы. Файберы легче и "
"быстрее, поскольку для передачи управления им не нужно обращаться к ядру."

#: ../doc/1.10/book/app_server/creating_app.rst:584
msgid ""
"Yet fibers have some limitations as compared with threads, the main "
"limitation being no multi-core mode. All fibers in an application belong "
"to a single thread, so they all use the same CPU core as the parent "
"thread. Meanwhile, this limitation is not really serious for Tarantool "
"applications, because a typical bottleneck for Tarantool is the HDD, not "
"the CPU."
msgstr ""
"Однако у файберов есть определенные ограничения, по сравнению с потоками,"
" основное из которых -- отсутствие режима работы с многоядерной системой."
" Все файберы в приложении относятся к одному потоку, поэтому они "
"используют то же ядро процессора, что и родительский поток. В то же "
"время, это ограничение незначительно для приложений Tarantool'а, "
"поскольку узкое место Tarantool'а -- жесткий диск, а не ЦП."

#: ../doc/1.10/book/app_server/creating_app.rst:590
msgid ""
"A fiber has all the features of a Lua `coroutine "
"<http://www.lua.org/pil/contents.html#9>`_ and all programming concepts "
"that apply for Lua coroutines will apply for fibers as well. However, "
"Tarantool has made some enhancements for fibers and has used fibers "
"internally. So, although use of coroutines is possible and supported, use"
" of fibers is recommended."
msgstr ""
"У файбера есть все возможности `сопрограммы "
"<http://www.lua.org/pil/contents.html#9>`_ на языке Lua, и все принципы "
"программирования, которые применяются к сопрограммам на Lua, применимы и "
"к файберам. Однако Tarantool расширил возможности файберов для "
"внутреннего использования. Поэтому, несмотря на возможность и поддержку "
"использования сопрограмм, рекомендуется использовать файберы."

#: ../doc/1.10/book/app_server/creating_app.rst:597
msgid ""
"Well, performance or controllability are of little importance in our "
"case. We'll launch ``respawn()`` in a fiber to make it work in the "
"background all the time. To do so, we'll need to amend ``respawn()``:"
msgstr ""
"Производительность или управляемость не слишком важны в нашем случае. "
"Запустим ``respawn()`` в файбере для непрерывной работы в фоновом режиме."
" Для этого необходимо изменить ``respawn()``:"

#: ../doc/1.10/book/app_server/creating_app.rst:601
msgid ""
"respawn = function(self)\n"
"    -- let's give our fiber a name;\n"
"    -- this will produce neat output in fiber.info()\n"
"    fiber.name('Respawn fiber')\n"
"    while true do\n"
"        for _, tuple in box.space.pokemons.index.status:pairs(\n"
"                self.state.CAUGHT) do\n"
"            box.space.pokemons:update(\n"
"                tuple[self.ID],\n"
"                {{'=', self.STATUS, self.state.ACTIVE}}\n"
"            )\n"
"        end\n"
"        fiber.sleep(self.respawn_time)\n"
"    end\n"
"end"
msgstr ""
"respawn = function(self)\n"
"    -- назовем наш файбер;\n"
"    -- это выполнит чистый вывод в fiber.info()\n"
"    fiber.name('Respawn fiber')\n"
"    while true do\n"
"        for _, tuple in box.space.pokemons.index.status:pairs(\n"
"                self.state.CAUGHT) do\n"
"            box.space.pokemons:update(\n"
"                tuple[self.ID],\n"
"                {{'=', self.STATUS, self.state.ACTIVE}}\n"
"            )\n"
"        end\n"
"        fiber.sleep(self.respawn_time)\n"
"    end\n"
"end"

#: ../doc/1.10/book/app_server/creating_app.rst:619
msgid "and call it as a fiber in ``start()``:"
msgstr "и назвать его файбером в ``start()``:"

#: ../doc/1.10/book/app_server/creating_app.rst:621
msgid ""
"start = function(self)\n"
"    -- create spaces and indexes\n"
"        <...>\n"
"    -- create models\n"
"        <...>\n"
"    -- compile models\n"
"        <...>\n"
"    -- start the game\n"
"       self.pokemon_model = compiled_pokemon\n"
"       self.player_model = compiled_player\n"
"       fiber.create(self.respawn, self)\n"
"       log.info('Started')\n"
"    -- errors if schema creation or compilation fails\n"
"       <...>\n"
"end"
msgstr ""
"start = function(self)\n"
"    -- создать спейсы и индексы\n"
"        <...>\n"
"    -- создать модели\n"
"        <...>\n"
"    -- скомпилировать модели\n"
"        <...>\n"
"    -- начать игру\n"
"       self.pokemon_model = compiled_pokemon\n"
"       self.player_model = compiled_player\n"
"       fiber.create(self.respawn, self)\n"
"       log.info('Started')\n"
"    -- ошибки, если создание схемы или компиляция не работает\n"
"       <...>\n"
"end"

#: ../doc/1.10/book/app_server/creating_app.rst:641
#: ../doc/1.10/reference/configuration/index.rst:270
msgid "Logging"
msgstr "Запись в журнал"

#: ../doc/1.10/book/app_server/creating_app.rst:643
msgid ""
"One more helpful function that we used in ``start()`` was ``log.infо()`` "
"from Tarantool :ref:`log <log-module>` module. We also need this function"
" in ``notify()`` to add a record to the log file on every successful "
"catch:"
msgstr ""
"В  ``start()`` мы использовали еще одну полезную функцию -- "
"``log.infо()`` из :ref:`модуля log <log-module>` Tarantool'а . Эта "
"функция также понадобится в ``notify()`` для добавления записи в файл "
"журнала при каждой успешной поимке:"

#: ../doc/1.10/book/app_server/creating_app.rst:647
#, python-format
msgid ""
"-- event notification\n"
"notify = function(self, player, pokemon)\n"
"    log.info(\"Player '%s' caught '%s'\", player.name, pokemon.name)\n"
"end"
msgstr ""
"-- уведомление о событии\n"
"notify = function(self, player, pokemon)\n"
"    log.info(\"Player '%s' caught '%s'\", player.name, pokemon.name)\n"
"end"

#: ../doc/1.10/book/app_server/creating_app.rst:654
msgid ""
"We use default Tarantool :ref:`log settings <cfg_logging>`, so we'll see "
"the log output in console when we launch our application in script mode."
msgstr ""
"Мы используем стандартные :ref:`настройки журнала <cfg_logging>` "
"Tarantool'а, поэтому увидим вывод записей журнала в консоли, когда "
"запустим приложение в режиме скрипта."

#: ../doc/1.10/book/app_server/creating_app.rst:660
msgid ""
"Great! We've discussed all programming practices used in our Lua module "
"(see `pokemon.lua "
"<https://github.com/tarantool/pokemon/blob/1.9/src/pokemon.lua>`_)."
msgstr ""
"Отлично! Мы обсудили все методики программирования, используемые в нашем"
"  Lua-модуле (см. `pokemon.lua "
"<https://github.com/tarantool/pokemon/blob/1.9/src/pokemon.lua>`_)."

#: ../doc/1.10/book/app_server/creating_app.rst:663
msgid ""
"Now let's prepare the test environment. As planned, we write a Lua "
"application (see `game.lua "
"<https://github.com/tarantool/pokemon/blob/1.9/game.lua>`_) to initialize"
" Tarantool's database module, initialize our game, call the game loop and"
" simulate a couple of player requests."
msgstr ""
"Теперь подготовим среду тестирования. Как и планировалось, напишем "
"приложение на языке Lua (см. `game.lua "
"<https://github.com/tarantool/pokemon/blob/1.9/game.lua>`_), чтобы "
"инициализировать модуль базы данных Tarantool'а, инициализировать нашу "
"игру, вызвать цикл игры и смоделировать пару запросов от игроков."

#: ../doc/1.10/book/app_server/creating_app.rst:668
msgid ""
"To launch our microservice, we put both ``pokemon.lua`` module and "
"``game.lua`` application in the current directory, install all external "
"modules, and launch the Tarantool instance running our ``game.lua`` "
"application (this example is for Ubuntu):"
msgstr ""
"Чтобы запустить микросервис, поместим модуль ``pokemon.lua`` и приложение"
"  ``game.lua`` в текущую директорию, установим все внешние модули и "
"запустим экземпляр Tarantool'а с работают приложением ``game.lua`` (это "
"пример для Ubuntu):"

#: ../doc/1.10/book/app_server/creating_app.rst:673
msgid ""
"$ ls\n"
"game.lua  pokemon.lua\n"
"$ sudo apt-get install tarantool-gis\n"
"$ sudo apt-get install tarantool-avro-schema\n"
"$ tarantool game.lua"
msgstr ""
"$ ls\n"
"game.lua  pokemon.lua\n"
"$ sudo apt-get install tarantool-gis\n"
"$ sudo apt-get install tarantool-avro-schema\n"
"$ tarantool game.lua"

#: ../doc/1.10/book/app_server/creating_app.rst:681
msgid ""
"Tarantool starts and initializes the database. Then Tarantool executes "
"the demo logic from ``game.lua``: adds a pokémon named Pikachu (its "
"chance to be caught is very high, 99.1), displays the current map (it "
"contains one active pokémon, Pikachu) and processes catch requests from "
"two players. Player1 is located just near the lonely Pikachu pokémon and "
"Player2 is located far away from it. As expected, the catch results in "
"this output are \"true\" for Player1 and \"false\" for Player2. Finally, "
"Tarantool displays the current map which is empty, because Pikachu is "
"caught and temporarily inactive:"
msgstr ""
"Tarantool запускает и инициализирует базу данных. Затем Tarantool "
"выполняет демо-логику из ``game.lua``: добавляет покемона под названием "
"Пикачу (Pikachu) (шанс его поимки очень высок -- 99,1), отображает "
"текущую карту (на ней расположен один активный покемон, Пикачу) и "
"обрабатывает запросы поимки от двух игроков. Player1 (Игрок 1) находится "
"очень близко к одинокому покемону Пикачу, а Player2 (Игрок 2) находится "
"очень далеко от него. Как предполагается, результаты поимки в таком "
"выводе будут \"true\" для Player1 и \"false\" для Player2. Наконец, "
"Tarantool отображает текущую карту, которая пуста, потому что Пикачу "
"пойман и временно неактивен:"

#: ../doc/1.10/book/app_server/creating_app.rst:690
msgid ""
"$ tarantool game.lua\n"
"2017-01-09 20:19:24.605 [6282] main/101/game.lua C> version "
"1.7.3-43-gf5fa1e1\n"
"2017-01-09 20:19:24.605 [6282] main/101/game.lua C> log level 5\n"
"2017-01-09 20:19:24.605 [6282] main/101/game.lua I> mapping 1073741824 "
"bytes for tuple arena...\n"
"2017-01-09 20:19:24.609 [6282] main/101/game.lua I> initializing an empty"
" data directory\n"
"2017-01-09 20:19:24.634 [6282] snapshot/101/main I> saving snapshot "
"`./00000000000000000000.snap.inprogress'\n"
"2017-01-09 20:19:24.635 [6282] snapshot/101/main I> done\n"
"2017-01-09 20:19:24.641 [6282] main/101/game.lua I> ready to accept "
"requests\n"
"2017-01-09 20:19:24.786 [6282] main/101/game.lua I> Started\n"
"---\n"
"- {'id': 1, 'status': 'active', 'location': {'y': 2, 'x': 1}, 'name': "
"'Pikachu', 'chance': 99.1}\n"
"...\n"
"\n"
"2017-01-09 20:19:24.789 [6282] main/101/game.lua I> Player 'Player1' "
"caught 'Pikachu'\n"
"true\n"
"false\n"
"--- []\n"
"...\n"
"\n"
"2017-01-09 20:19:24.789 [6282] main C> entering the event loop"
msgstr ""
"$ tarantool game.lua\n"
"2017-01-09 20:19:24.605 [6282] main/101/game.lua C> version "
"1.7.3-43-gf5fa1e1\n"
"2017-01-09 20:19:24.605 [6282] main/101/game.lua C> log level 5\n"
"2017-01-09 20:19:24.605 [6282] main/101/game.lua I> mapping 1073741824 "
"bytes for tuple arena...\n"
"2017-01-09 20:19:24.609 [6282] main/101/game.lua I> initializing an empty"
" data directory\n"
"2017-01-09 20:19:24.634 [6282] snapshot/101/main I> saving snapshot "
"`./00000000000000000000.snap.inprogress'\n"
"2017-01-09 20:19:24.635 [6282] snapshot/101/main I> done\n"
"2017-01-09 20:19:24.641 [6282] main/101/game.lua I> ready to accept "
"requests\n"
"2017-01-09 20:19:24.786 [6282] main/101/game.lua I> Started\n"
"---\n"
"- {'id': 1, 'status': 'active', 'location': {'y': 2, 'x': 1}, 'name': "
"'Pikachu', 'chance': 99.1}\n"
"...\n"
"\n"
"2017-01-09 20:19:24.789 [6282] main/101/game.lua I> Player 'Player1' "
"caught 'Pikachu'\n"
"true\n"
"false\n"
"--- []\n"
"...\n"
"\n"
"2017-01-09 20:19:24.789 [6282] main C> entering the event loop"

#: ../doc/1.10/book/app_server/creating_app.rst:715
msgid "nginx"
msgstr "nginx"

#: ../doc/1.10/book/app_server/creating_app.rst:717
msgid ""
"In the real life, this microservice would work over HTTP. Let's add "
"`nginx <https://nginx.org/en/>`_ web server to our environment and make a"
" similar demo. But how do we make Tarantool methods callable via REST "
"API? We use nginx with `Tarantool nginx upstream "
"<https://github.com/tarantool/nginx_upstream_module>`_ module and create "
"one more Lua script (`app.lua "
"<https://github.com/tarantool/pokemon/blob/1.9/src/app.lua>`_) that "
"exports three of our game methods -- ``add_pokemon()``, ``map()`` and "
"``catch()`` -- as REST endpoints of the nginx upstream module:"
msgstr ""
"В реальной жизни такой микросервис работал бы по HTTP. Добавим веб-сервер"
" `nginx <https://nginx.org/en/>`_ в нашу среду и сделаем аналогичный "
"пример. Но как вызывать методы Tarantool'а с помощью REST API? Мы "
"используем nginx с модулем `Tarantool nginx upstream "
"<https://github.com/tarantool/nginx_upstream_module>`_ и создадим еще "
"один скрипт на Lua (`app.lua "
"<https://github.com/tarantool/pokemon/blob/1.9/src/app.lua>`_), который "
"экспортирует три наших игровых метода -- ``add_pokemon()``, ``map()`` и "
"``catch()`` -- в качестве конечных точек обработки запросов REST модуля "
"nginx upstream:"

#: ../doc/1.10/book/app_server/creating_app.rst:726
msgid ""
"local game = require('pokemon')\n"
"box.cfg{listen=3301}\n"
"game:start()\n"
"\n"
"-- add, map and catch functions exposed to REST API\n"
"function add(request, pokemon)\n"
"    return {\n"
"        result=game:add_pokemon(pokemon)\n"
"    }\n"
"end\n"
"\n"
"function map(request)\n"
"    return {\n"
"        map=game:map()\n"
"    }\n"
"end\n"
"\n"
"function catch(request, pid, player)\n"
"    local id = tonumber(pid)\n"
"    if id == nil then\n"
"        return {result=false}\n"
"    end\n"
"    return {\n"
"        result=game:catch(id, player)\n"
"    }\n"
"end"
msgstr ""
"local game = require('pokemon')\n"
"box.cfg{listen=3301}\n"
"game:start()\n"
"\n"
"-- функции add, map и catch по REST API\n"
"function add(request, pokemon)\n"
"    return {\n"
"        result=game:add_pokemon(pokemon)\n"
"    }\n"
"end\n"
"\n"
"function map(request)\n"
"    return {\n"
"        map=game:map()\n"
"    }\n"
"end\n"
"\n"
"function catch(request, pid, player)\n"
"    local id = tonumber(pid)\n"
"    if id == nil then\n"
"        return {result=false}\n"
"    end\n"
"    return {\n"
"        result=game:catch(id, player)\n"
"    }\n"
"end"

#: ../doc/1.10/book/app_server/creating_app.rst:755
msgid ""
"An easy way to configure and launch nginx would be to create a Docker "
"container based on a `Docker image <https://hub.docker.com/r/tarantool"
"/tarantool-nginx/>`_ with nginx and the upstream module already installed"
" (see `http/Dockerfile "
"<https://github.com/tarantool/pokemon/blob/1.9/http/Dockerfile>`_). We "
"take a standard `nginx.conf "
"<https://github.com/tarantool/pokemon/blob/1.9/http/nginx.conf>`_, where "
"we define an upstream with our Tarantool backend running (this is another"
" Docker container, see details below):"
msgstr ""
"Чтобы с легкостью настроить и запустить nginx, необходимо создать "
"Docker-контейнер на основе `Docker-образа "
"<https://hub.docker.com/r/tarantool /tarantool-nginx/>`_ с уже "
"установленными nginx и модулем upstream (см. `http/Dockerfile "
"<https://github.com/tarantool/pokemon/blob/1.9/http/Dockerfile>`_). Берем"
" стандартный `nginx.conf "
"<https://github.com/tarantool/pokemon/blob/1.9/http/nginx.conf>`_, где "
"определяем upstream с работающим бэкендом Tarantool'а (это еще один "
"Docker-контейнер, см. нижеприведенную информацию):"

#: ../doc/1.10/book/app_server/creating_app.rst:764
msgid ""
"upstream tnt {\n"
"      server pserver:3301 max_fails=1 fail_timeout=60s;\n"
"      keepalive 250000;\n"
"}"
msgstr ""
"upstream tnt {\n"
"      server pserver:3301 max_fails=1 fail_timeout=60s;\n"
"      keepalive 250000;\n"
"}"

#: ../doc/1.10/book/app_server/creating_app.rst:771
msgid ""
"and add some Tarantool-specific parameters (see descriptions in the "
"upstream module's `README "
"<https://github.com/tarantool/nginx_upstream_module#directives>`_ file):"
msgstr ""
"и добавляем специальные параметры для Tarantool'а (см. описание в файле "
"`README <https://github.com/tarantool/nginx_upstream_module#directives>`_"
" модуля upstream):"

#: ../doc/1.10/book/app_server/creating_app.rst:775
msgid ""
"server {\n"
"  server_name tnt_test;\n"
"\n"
"  listen 80 default deferred reuseport so_keepalive=on backlog=65535;\n"
"\n"
"  location = / {\n"
"      root /usr/local/nginx/html;\n"
"  }\n"
"\n"
"  location /api {\n"
"    # answers check infinity timeout\n"
"    tnt_read_timeout 60m;\n"
"    if ( $request_method = GET ) {\n"
"       tnt_method \"map\";\n"
"    }\n"
"    tnt_http_rest_methods get;\n"
"    tnt_http_methods all;\n"
"    tnt_multireturn_skip_count 2;\n"
"    tnt_pure_result on;\n"
"    tnt_pass_http_request on parse_args;\n"
"    tnt_pass tnt;\n"
"  }\n"
"}"
msgstr ""
"server {\n"
"  server_name tnt_test;\n"
"\n"
"  listen 80 default deferred reuseport so_keepalive=on backlog=65535;\n"
"\n"
"  location = / {\n"
"      root /usr/local/nginx/html;\n"
"  }\n"
"\n"
"  location /api {\n"
"    # ответы проверяют бесконечное время ожидания\n"
"    tnt_read_timeout 60m;\n"
"    if ( $request_method = GET ) {\n"
"       tnt_method \"map\";\n"
"    }\n"
"    tnt_http_rest_methods get;\n"
"    tnt_http_methods all;\n"
"    tnt_multireturn_skip_count 2;\n"
"    tnt_pure_result on;\n"
"    tnt_pass_http_request on parse_args;\n"
"    tnt_pass tnt;\n"
"  }\n"
"}"

#: ../doc/1.10/book/app_server/creating_app.rst:801
msgid ""
"Likewise, we put Tarantool server and all our game logic in a second "
"Docker container based on the `official Tarantool 1.9 image "
"<https://github.com/tarantool/docker>`_ (see `src/Dockerfile "
"<https://github.com/tarantool/pokemon/blob/1.9/src/Dockerfile>`_) and set"
" the container's default command to ``tarantool app.lua``. This is the "
"backend."
msgstr ""
"Аналогичным образом, поместим Tarantool-сервер и всю игровую логику в "
"другой Docker-контейнер на основе `официального образа Tarantool'а 1.9 "
"<https://github.com/tarantool/docker>`_ (см. `src/Dockerfile "
"<https://github.com/tarantool/pokemon/blob/1.9/src/Dockerfile>`_) и "
"установим ``tarantool app.lua`` в качестве стандартной команды для "
"контейнера. Это бэкенд."

#: ../doc/1.10/book/app_server/creating_app.rst:810
msgid "Non-blocking IO"
msgstr "Неблокирующий ввод-вывод"

#: ../doc/1.10/book/app_server/creating_app.rst:812
msgid ""
"To test the REST API, we create a new script (`client.lua "
"<https://github.com/tarantool/pokemon/blob/1.9/client/client.lua>`_), "
"which is similar to our ``game.lua`` application, but makes HTTP POST and"
" GET requests rather than calling Lua functions:"
msgstr ""
"Чтобы протестировать REST API, создадим новый скрипт (`client.lua "
"<https://github.com/tarantool/pokemon/blob/1.9/client/client.lua>`_), "
"который похож на наше приложение ``game.lua``, но отправляет запросы HTTP"
" POST и GET, а не вызывает Lua-функции:"

#: ../doc/1.10/book/app_server/creating_app.rst:817
#, python-format
msgid ""
"local http = require('curl').http()\n"
"local json = require('json')\n"
"local URI = os.getenv('SERVER_URI')\n"
"local fiber = require('fiber')\n"
"\n"
"local player1 = {\n"
"    name=\"Player1\",\n"
"    id=1,\n"
"    location = {\n"
"        x=1.0001,\n"
"        y=2.0003\n"
"    }\n"
"}\n"
"local player2 = {\n"
"    name=\"Player2\",\n"
"    id=2,\n"
"    location = {\n"
"        x=30.123,\n"
"        y=40.456\n"
"    }\n"
"}\n"
"\n"
"local pokemon = {\n"
"    name=\"Pikachu\",\n"
"    chance=99.1,\n"
"    id=1,\n"
"    status=\"active\",\n"
"    location = {\n"
"        x=1,\n"
"        y=2\n"
"    }\n"
"}\n"
"\n"
"function request(method, body, id)\n"
"    local resp = http:request(\n"
"        method, URI, body\n"
"    )\n"
"    if id ~= nil then\n"
"        print(string.format('Player %d result: %s',\n"
"            id, resp.body))\n"
"    else\n"
"        print(resp.body)\n"
"    end\n"
"end\n"
"\n"
"local players = {}\n"
"function catch(player)\n"
"    fiber.sleep(math.random(5))\n"
"    print('Catch pokemon by player ' .. tostring(player.id))\n"
"    request(\n"
"        'POST', '{\"method\": \"catch\",\n"
"        \"params\": [1, '..json.encode(player)..']}',\n"
"        tostring(player.id)\n"
"    )\n"
"    table.insert(players, player.id)\n"
"end\n"
"\n"
"print('Create pokemon')\n"
"request('POST', '{\"method\": \"add\",\n"
"    \"params\": ['..json.encode(pokemon)..']}')\n"
"request('GET', '')\n"
"\n"
"fiber.create(catch, player1)\n"
"fiber.create(catch, player2)\n"
"\n"
"-- wait for players\n"
"while #players ~= 2 do\n"
"    fiber.sleep(0.001)\n"
"end\n"
"\n"
"request('GET', '')\n"
"os.exit()"
msgstr ""
"local http = require('curl').http()\n"
"local json = require('json')\n"
"local URI = os.getenv('SERVER_URI')\n"
"local fiber = require('fiber')\n"
"\n"
"local player1 = {\n"
"    name=\"Player1\",\n"
"    id=1,\n"
"    location = {\n"
"        x=1.0001,\n"
"        y=2.0003\n"
"    }\n"
"}\n"
"local player2 = {\n"
"    name=\"Player2\",\n"
"    id=2,\n"
"    location = {\n"
"        x=30.123,\n"
"        y=40.456\n"
"    }\n"
"}\n"
"\n"
"local pokemon = {\n"
"    name=\"Pikachu\",\n"
"    chance=99.1,\n"
"    id=1,\n"
"    status=\"active\",\n"
"    location = {\n"
"        x=1,\n"
"        y=2\n"
"    }\n"
"}\n"
"\n"
"function request(method, body, id)\n"
"    local resp = http:request(\n"
"        method, URI, body\n"
"    )\n"
"    if id ~= nil then\n"
"        print(string.format('Player %d result: %s',\n"
"            id, resp.body))\n"
"    else\n"
"        print(resp.body)\n"
"    end\n"
"end\n"
"\n"
"local players = {}\n"
"function catch(player)\n"
"    fiber.sleep(math.random(5))\n"
"    print('Catch pokemon by player ' .. tostring(player.id))\n"
"    request(\n"
"        'POST', '{\"method\": \"catch\",\n"
"        \"params\": [1, '..json.encode(player)..']}',\n"
"        tostring(player.id)\n"
"    )\n"
"    table.insert(players, player.id)\n"
"end\n"
"\n"
"print('Create pokemon')\n"
"request('POST', '{\"method\": \"add\",\n"
"    \"params\": ['..json.encode(pokemon)..']}')\n"
"request('GET', '')\n"
"\n"
"fiber.create(catch, player1)\n"
"fiber.create(catch, player2)\n"
"\n"
"-- подождать игроков\n"
"while #players ~= 2 do\n"
"    fiber.sleep(0.001)\n"
"end\n"
"\n"
"request('GET', '')\n"
"os.exit()"

#: ../doc/1.10/book/app_server/creating_app.rst:892
msgid ""
"When you run this script, you’ll notice that both players have equal "
"chances to make the first attempt at catching the pokémon. In a classical"
" Lua script, a networked call blocks the script until it’s finished, so "
"the first catch attempt can only be done by the player who entered the "
"game first. In Tarantool, both players play concurrently, since all "
"modules are integrated with Tarantool :ref:`cooperative multitasking "
"<atomic-cooperative_multitasking>` and use non-blocking I/O."
msgstr ""
"При запуска этого скрипта вы заметите, что у обоих игроков одинаковые "
"шансы сделать первую попытку поимки покемона. В классическом Lua-скрипте "
"сетевой вызов блокирует скрипт, пока он не будет выполнен, поэтому первым"
" попытаться поймать может тот игрок, который раньше зашел в игру. В "
"Tarantool'е оба игрока играют одновременно, поскольку все модули "
"объединены в :ref:`кооперативной многозадачности <atomic-"
"cooperative_multitasking>` и используют неблокирующий ввод-вывод."

#: ../doc/1.10/book/app_server/creating_app.rst:900
msgid ""
"Indeed, when Player1 makes its first REST call, the script doesn’t block."
" The fiber running ``catch()`` function on behalf of Player1 issues a "
"non-blocking call to the operating system and yields control to the next "
"fiber, which happens to be the fiber of Player2. Player2’s fiber does the"
" same. When the network response is received, Player1's fiber is "
"activated by Tarantool cooperative scheduler, and resumes its work. All "
"Tarantool :ref:`modules <built_in_modules>` use non-blocking I/O and are "
"integrated with Tarantool cooperative scheduler. For module developers, "
"Tarantool provides an :ref:`API <index-c_api_reference>`."
msgstr ""
"Действительно, когда Player1 посылает первый REST-вызов, скрипт не "
"блокируется. Файбер, выполняющий функцию ``catch()`` от Player1, посылает"
" неблокирующий вызов в операционную систему и передает управление на "
"следующий файбер, которым оказывается файбер от Player2. Файбер от "
"Player2 делает то же самое. Когда получен сетевой ответ, файбер от "
"Player1 активируется  с помощью кооперативного планировщика Tarantool'а и"
" возобновляет работу. Все :ref:`модули <built_in_modules>` Tarantool'а "
"используют неблокирующий ввод-вывод и интегрированы с кооперативным "
"планировщиком Tarantool'а. Разработчикам модулей Tarantool предоставляет "
":ref:`API <index-c_api_reference>`."

#: ../doc/1.10/book/app_server/creating_app.rst:909
msgid ""
"For our HTTP test, we create a third container based on the `official "
"Tarantool 1.9 image <https://github.com/tarantool/docker>`_ (see "
"`client/Dockerfile "
"<https://github.com/tarantool/pokemon/blob/1.9/client/Dockerfile>`_) and "
"set the container's default command to ``tarantool client.lua``."
msgstr ""
"Для HTTP-теста создадим третий контейнер на основе `официального образа "
"Tarantool'а 1.9 <https://github.com/tarantool/docker>`_ (см. "
"`client/Dockerfile "
"<https://github.com/tarantool/pokemon/blob/1.9/client/Dockerfile>`_)  "
"установим ``tarantool client.lua`` в качестве стандартной команды для "
"контейнера."

#: ../doc/1.10/book/app_server/creating_app.rst:917
msgid ""
"To run this test locally, download our `pokemon "
"<https://github.com/tarantool/pokemon>`_ project from GitHub and say:"
msgstr ""
"Чтобы запустить тест локально, скачайте наш проект `покемон "
"<https://github.com/tarantool/pokemon>`_ из GitHub и вызовите:"

#: ../doc/1.10/book/app_server/creating_app.rst:920
msgid ""
"$ docker-compose build\n"
"$ docker-compose up"
msgstr ""
"$ docker-compose build\n"
"$ docker-compose up"

#: ../doc/1.10/book/app_server/creating_app.rst:925
msgid ""
"Docker Compose builds and runs all the three containers: ``pserver`` "
"(Tarantool backend), ``phttp`` (nginx) and ``pclient`` (demo client). You"
" can see log messages from all these containers in the console, pclient "
"saying that it made an HTTP request to create a pokémon, made two catch "
"requests, requested the map (empty since the pokémon is caught and "
"temporarily inactive) and exited:"
msgstr ""
"Docker Compose собирает и запускает все три контейнера: ``pserver`` "
"(бэкенд Tarantool'а), ``phttp`` (nginx) и``pclient`` (демо-клиент). ВЫ "
"можете увидеть все сообщения журнала из всех этих контейнеров в консоли. "
"pclient выведет, что сделал HTTP-запрос на создание покемона, два запроса"
" на поимку покемона, запросил карту (пустая, поскольку покемон пойман и "
"временно неактивен) и завершил работу:"

#: ../doc/1.10/book/app_server/creating_app.rst:931
msgid ""
"pclient_1  | Create pokemon\n"
"<...>\n"
"pclient_1  | {\"result\":true}\n"
"pclient_1  | "
"{\"map\":[{\"id\":1,\"status\":\"active\",\"location\":{\"y\":2,\"x\":1},\"name\":\"Pikachu\",\"chance\":99.100000}]}"
"\n"
"pclient_1  | Catch pokemon by player 2\n"
"pclient_1  | Catch pokemon by player 1\n"
"pclient_1  | Player 1 result: {\"result\":true}\n"
"pclient_1  | Player 2 result: {\"result\":false}\n"
"pclient_1  | {\"map\":[]}\n"
"pokemon_pclient_1 exited with code 0"
msgstr ""
"pclient_1  | Create pokemon\n"
"<...>\n"
"pclient_1  | {\"result\":true}\n"
"pclient_1  | "
"{\"map\":[{\"id\":1,\"status\":\"active\",\"location\":{\"y\":2,\"x\":1},\"name\":\"Pikachu\",\"chance\":99.100000}]}"
"\n"
"pclient_1  | Catch pokemon by player 2\n"
"pclient_1  | Catch pokemon by player 1\n"
"pclient_1  | Player 1 result: {\"result\":true}\n"
"pclient_1  | Player 2 result: {\"result\":false}\n"
"pclient_1  | {\"map\":[]}\n"
"pokemon_pclient_1 exited with code 0"

#: ../doc/1.10/book/app_server/creating_app.rst:944
msgid ""
"Congratulations! Here's the end point of our walk-through. As further "
"reading, see more about :ref:`installing <app_server-installing_module>` "
"and :ref:`contributing <app_server-contributing_module>` a module."
msgstr ""
"Поздравляем! Вот мы и закончили наш пошаговый пример. Для дальнейшего "
"изучения рекомендуем :ref:`установку <app_server-installing_module>` и "
":ref:`добавление <app_server-contributing_module>` модуля."

#: ../doc/1.10/book/app_server/creating_app.rst:948
msgid ""
"See also reference on :ref:`Tarantool modules <built_in_modules>` and "
":ref:`C API <index-c_api_reference>`, and don't miss our :ref:`Lua "
"cookbook recipes <cookbook>`."
msgstr ""
"См. также справочник по :ref:`модулям Tarantool'а <built_in_modules>` и "
":ref:`C API <index-c_api_reference>` и не пропустите наши "
":ref:`рекомендации по разработке на Lua <cookbook>`."

#: ../doc/1.10/book/app_server/index.rst:39
msgid "Application server"
msgstr "Сервер приложений"

#: ../doc/1.10/book/app_server/index.rst:41
msgid ""
"In this chapter, we introduce the basics of working with Tarantool as a "
"Lua application server."
msgstr ""
"В данной главе мы рассмотрим основы работы с Tarantool'ом в качестве "
"сервера приложений на языке Lua."

#: ../doc/1.10/book/app_server/index.rst:44 ../doc/1.10/book/box/index.rst:44
#: ../doc/1.10/book/getting_started/index.rst:44
msgid "This chapter contains the following sections:"
msgstr "Эта глава состоит из следующих разделов:"

#: ../doc/1.10/book/app_server/installing_module.rst:39
msgid "Installing a module"
msgstr "Установка модуля"

#: ../doc/1.10/book/app_server/installing_module.rst:41
msgid ""
"Modules in Lua and C that come from Tarantool developers and community "
"contributors are available in the following locations:"
msgstr ""
"Модули на Lua и C от разработчиков Tarantool'а и сторонних разработчиков "
"доступны здесь:"

#: ../doc/1.10/book/app_server/installing_module.rst:44
msgid "Tarantool modules repository, and"
msgstr "Репозиторий модулей Tarantool'а и"

#: ../doc/1.10/book/app_server/installing_module.rst:45
msgid "Tarantool deb/rpm repositories."
msgstr "Репозитории deb/rpm Tarantool'а."

#: ../doc/1.10/book/app_server/installing_module.rst:51
msgid "Installing a module from a repository"
msgstr "Установка модуля из репозитория"

#: ../doc/1.10/book/app_server/installing_module.rst:53
msgid ""
"See `README in tarantool/rocks repository "
"<https://github.com/tarantool/rocks#managing-modules-with-"
"tarantool-174>`_ for detailed instructions."
msgstr ""
"Для получения подробной информации см. `README в репозитории "
"tarantool/rocks <https://github.com/tarantool/rocks#managing-modules-"
"with-tarantool-174>`_."

#: ../doc/1.10/book/app_server/installing_module.rst:61
msgid "Installing a module from deb/rpm"
msgstr "Установка модуля из deb/rpm"

#: ../doc/1.10/book/app_server/installing_module.rst:63
msgid "Follow these steps:"
msgstr "Выполните следующие действия:"

#: ../doc/1.10/book/app_server/installing_module.rst:65
msgid ""
"Install Tarantool as recommended on the `download page "
"<http://tarantool.org/download.html>`_."
msgstr ""
"Установите Tarantool в соответствии с рекомендациями на `странице "
"загрузки <http://tarantool.org/download.html>`_."

#: ../doc/1.10/book/app_server/installing_module.rst:68
msgid ""
"Install the module you need. Look up the module's name on `Tarantool "
"rocks page <http://tarantool.org/rocks.html>`_ and put the prefix "
"\"tarantool-\" before the module name to avoid ambiguity:"
msgstr ""
"Установите необходимый модуль. Найдите имя модуля на `странице со "
"сторонними библиотеками Tarantool'а <http://tarantool.org/rocks.html>`_  "
"и введите префикс \"tarantool-\" перед названием модуля во избежание "
"неоднозначности:"

#: ../doc/1.10/book/app_server/installing_module.rst:72
msgid ""
"$ # for Ubuntu/Debian:\n"
"$ sudo apt-get install tarantool-<module-name>\n"
"\n"
"$ # for RHEL/CentOS/Amazon:\n"
"$ sudo yum install tarantool-<module-name>"
msgstr ""
"$ # для Ubuntu/Debian:\n"
"$ sudo apt-get install tarantool-<module-name>\n"
"\n"
"$ # для RHEL/CentOS/Amazon:\n"
"$ sudo yum install tarantool-<module-name>"

#: ../doc/1.10/book/app_server/installing_module.rst:80
msgid ""
"For example, to install the module `shard "
"<http://github.com/tarantool/shard>`_ on Ubuntu, say:"
msgstr ""
"Например, чтобы установить модуль `shard "
"<http://github.com/tarantool/shard>`_ на Ubuntu, введите:"

#: ../doc/1.10/book/app_server/installing_module.rst:83
#: ../doc/1.10/reference/reference_rock/shard.rst:120
msgid "$ sudo apt-get install tarantool-shard"
msgstr "$ sudo apt-get install tarantool-shard"

#: ../doc/1.10/book/app_server/installing_module.rst:87
msgid "Once these steps are complete, you can:"
msgstr "Теперь можно:"

#: ../doc/1.10/book/app_server/installing_module.rst:89
msgid "load any module with"
msgstr "загружать любой модуль с помощью"

#: ../doc/1.10/book/app_server/installing_module.rst:91
msgid "tarantool> name = require('module-name')"
msgstr "tarantool> name = require('module-name')"

#: ../doc/1.10/book/app_server/installing_module.rst:95
msgid "for example:"
msgstr "например:"

#: ../doc/1.10/book/app_server/installing_module.rst:97
msgid "tarantool> shard = require('shard')"
msgstr "tarantool> shard = require('shard')"

#: ../doc/1.10/book/app_server/installing_module.rst:101
msgid ""
"search locally for installed modules using ``package.path`` (Lua) or "
"``package.cpath`` (C):"
msgstr ""
"локально находить установленные модули с помощью ``package.path`` (Lua) "
"или ``package.cpath`` (C):"

#: ../doc/1.10/book/app_server/installing_module.rst:104
msgid ""
"tarantool> package.path\n"
"---\n"
"- ./?.lua;./?/init.lua; "
"/usr/local/share/tarantool/?.lua;/usr/local/share/\n"
"tarantool/?/init.lua;/usr/share/tarantool/?.lua;/usr/share/tarantool/?/ini"
"\n"
"t.lua;/usr/local/share/lua/5.1/?.lua;/usr/local/share/lua/5.1/?/init.lua;/"
"\n"
"usr/share/lua/5.1/?.lua;/usr/share/lua/5.1/?/init.lua;\n"
"...\n"
"\n"
"tarantool> package.cpath\n"
"---\n"
"- ./?.so;/usr/local/lib/x86_64-linux-"
"gnu/tarantool/?.so;/usr/lib/x86_64-li\n"
"nux-"
"gnu/tarantool/?.so;/usr/local/lib/tarantool/?.so;/usr/local/lib/x86_64\n"
"-linux-gnu/lua/5.1/?.so;/usr/lib/x86_64-linux-"
"gnu/lua/5.1/?.so;/usr/local/\n"
"lib/lua/5.1/?.so;\n"
"..."
msgstr ""
"tarantool> package.path\n"
"---\n"
"- ./?.lua;./?/init.lua; "
"/usr/local/share/tarantool/?.lua;/usr/local/share/\n"
"tarantool/?/init.lua;/usr/share/tarantool/?.lua;/usr/share/tarantool/?/ini"
"\n"
"t.lua;/usr/local/share/lua/5.1/?.lua;/usr/local/share/lua/5.1/?/init.lua;/"
"\n"
"usr/share/lua/5.1/?.lua;/usr/share/lua/5.1/?/init.lua;\n"
"...\n"
"\n"
"tarantool> package.cpath\n"
"---\n"
"- ./?.so;/usr/local/lib/x86_64-linux-"
"gnu/tarantool/?.so;/usr/lib/x86_64-li\n"
"nux-"
"gnu/tarantool/?.so;/usr/local/lib/tarantool/?.so;/usr/local/lib/x86_64\n"
"-linux-gnu/lua/5.1/?.so;/usr/lib/x86_64-linux-"
"gnu/lua/5.1/?.so;/usr/local/\n"
"lib/lua/5.1/?.so;\n"
"..."

#: ../doc/1.10/book/app_server/installing_module.rst:124
msgid ""
"Question-marks stand for the module name that was specified earlier when "
"saying ``require('module-name')``."
msgstr ""
"Знаки вопроса стоят вместо имени модуля, которое было указано ранее при "
"вызове ``require('module-name')``."

#: ../doc/1.10/book/app_server/launching_app.rst:39
msgid "Launching an application"
msgstr "Запуск приложения"

#: ../doc/1.10/book/app_server/launching_app.rst:41
msgid ""
"Using Tarantool as an application server, you can write your own "
"applications. Tarantool’s native language for writing applications is "
"`Lua <http://www.lua.org/about.html>`_, so a typical application would be"
" a file that contains your Lua script. But you can also write "
"applications in C or C++."
msgstr ""
"Используя Tarantool в качестве сервера приложений, вы можете написать "
"собственные приложения. Собственный язык Tarantool’а для приложений -- "
"`Lua <http://www.lua.org/about.html>`_, поэтому типовое приложение "
"представляет собой файл, который содержит Lua-скрипт. Однако вы также "
"можете писать приложения на C или C++."

#: ../doc/1.10/book/app_server/launching_app.rst:49
msgid ""
"If you're new to Lua, we recommend going over the interactive Tarantool "
"tutorial before proceeding with this chapter. To launch the tutorial, say"
" ``tutorial()`` in Tarantool console:"
msgstr ""
"Если вы только осваиваете Lua, рекомендуем выполнить практическое задание"
" по Tarantool'у до работы с данной главой. Для запуска практического "
"задания, выполните команду ``tutorial()`` в консоли Tarantool'а:"

#: ../doc/1.10/book/app_server/launching_app.rst:53
msgid ""
"tarantool> tutorial()\n"
"---\n"
"- |\n"
" Tutorial -- Screen #1 -- Hello, Moon\n"
" ====================================\n"
"\n"
" Welcome to the Tarantool tutorial.\n"
" It will introduce you to Tarantool’s Lua application server\n"
" and database server, which is what’s running what you’re seeing.\n"
" This is INTERACTIVE -- you’re expected to enter requests\n"
" based on the suggestions or examples in the screen’s text.\n"
" <...>"
msgstr ""
"tarantool> tutorial()\n"
"---\n"
"- |\n"
" Tutorial -- Screen #1 -- Hello, Moon\n"
" ====================================\n"
"\n"
" Welcome to the Tarantool tutorial.\n"
" It will introduce you to Tarantool’s Lua application server\n"
" and database server, which is what’s running what you’re seeing.\n"
" This is INTERACTIVE -- you’re expected to enter requests\n"
" based on the suggestions or examples in the screen’s text.\n"
" <...>"

#: ../doc/1.10/book/app_server/launching_app.rst:68
msgid ""
"Let's create and launch our first Lua application for Tarantool. Here's a"
" simplest Lua application, the good old \"Hello, world!\":"
msgstr ""
"Создадим и запустим первое приложение на языке Lua для Tarantool'а -- "
"самое простое приложение, старую добрую программу \"Hello, world!\":"

#: ../doc/1.10/book/app_server/launching_app.rst:71
msgid ""
"#!/usr/bin/env tarantool\n"
"print('Hello, world!')"
msgstr ""
"#!/usr/bin/env tarantool\n"
"print('Hello, world!')"

#: ../doc/1.10/book/app_server/launching_app.rst:76
msgid "We save it in a file. Let it be ``myapp.lua`` in the current directory."
msgstr ""
"Сохраним приложение в файле. Пусть это будет ``myapp.lua`` в текущей "
"директории."

#: ../doc/1.10/book/app_server/launching_app.rst:78
msgid "Now let's discuss how we can launch our application with Tarantool."
msgstr "Теперь рассмотрим, как можно запустить наше приложение с Tarantool'ом."

#: ../doc/1.10/book/app_server/launching_app.rst:84
msgid "Launching in Docker"
msgstr "Запуск в Docker"

#: ../doc/1.10/book/app_server/launching_app.rst:86
msgid ""
"If we run Tarantool in a :ref:`Docker container <getting_started-"
"using_docker>`, the following command will start Tarantool 1.9 without "
"any application:"
msgstr ""
"Если мы запустим Tarantool в :ref:`Docker-контейнере <getting_started-"
"using_docker>`, Tarantool 1.9 начнет работу без какого-либо приложения "
"после следующей команды:"

#: ../doc/1.10/book/app_server/launching_app.rst:89
msgid ""
"$ # create a temporary container and run it in interactive mode\n"
"$ docker run --rm -t -i tarantool/tarantool:1"
msgstr ""
"$ # создать временный контейнер и запустить его в интерактивном режиме\n"
"$ docker run --rm -t -i tarantool/tarantool:1"

#: ../doc/1.10/book/app_server/launching_app.rst:94
msgid "To run Tarantool with our application, we can say:"
msgstr "Чтобы запустить Tarantool с нашим приложением, можно выполнить команду:"

#: ../doc/1.10/book/app_server/launching_app.rst:96
msgid ""
"$ # create a temporary container and\n"
"$ # launch Tarantool with our application\n"
"$ docker run --rm -t -i \\\n"
"             -v `pwd`/myapp.lua:/opt/tarantool/myapp.lua \\\n"
"             -v /data/dir/on/host:/var/lib/tarantool \\\n"
"             tarantool/tarantool:1 tarantool /opt/tarantool/myapp.lua"
msgstr ""
"$ # создать временный контейнер и\n"
"$ # запустить Tarantool с нашим приложением\n"
"$ docker run --rm -t -i \\\n"
"             -v `pwd`/myapp.lua:/opt/tarantool/myapp.lua \\\n"
"             -v /data/dir/on/host:/var/lib/tarantool \\\n"
"             tarantool/tarantool:1 tarantool /opt/tarantool/myapp.lua"

#: ../doc/1.10/book/app_server/launching_app.rst:105
msgid "Here two resources on the host get mounted in the container:"
msgstr "Здесь два ресурса подключаются к серверу в контейнере:"

#: ../doc/1.10/book/app_server/launching_app.rst:107
msgid "our application file (myapp.lua) and"
msgstr "наш файл с приложением (myapp.lua) и"

#: ../doc/1.10/book/app_server/launching_app.rst:108
msgid "Tarantool data directory (``/data/dir/on/host``)."
msgstr "каталог данных  Tarantool'а (``/data/dir/on/host``)."

#: ../doc/1.10/book/app_server/launching_app.rst:110
msgid ""
"By convention, the directory for Tarantool application code inside a "
"container is ``/opt/tarantool``, and the directory for data is "
"``/var/lib/tarantool``."
msgstr ""
"Традиционно в контейнере директория ``/opt/tarantool`` используется для "
"кода приложения  Tarantool'а, а директория ``/var/lib/tarantool`` "
"используется для данных."

#: ../doc/1.10/book/app_server/launching_app.rst:117
msgid "Launching a binary program"
msgstr "Запуск бинарной программы"

#: ../doc/1.10/book/app_server/launching_app.rst:119
msgid ""
"If we run Tarantool from a :ref:`binary package <getting_started-"
"using_binary>` or from a :ref:`source build <building_from_source>`, we "
"can launch our application:"
msgstr ""
"При запуске Tarantool'а из :ref:`бинарного пакета <getting_started-"
"using_binary>` или :ref:`сборке из исходников <building_from_source>`, "
"можно запустить наше приложение:"

#: ../doc/1.10/book/app_server/launching_app.rst:123
msgid "in the script mode,"
msgstr "в режиме скрипта,"

#: ../doc/1.10/book/app_server/launching_app.rst:124
msgid "as a server application, or"
msgstr "как серверное приложение или"

#: ../doc/1.10/book/app_server/launching_app.rst:125
msgid "as a daemon service."
msgstr "как демон службы."

#: ../doc/1.10/book/app_server/launching_app.rst:127
msgid "The simplest way is to pass the filename to Tarantool at start:"
msgstr "Самый простой способ -- передать имя файла в Tarantool при запуске:"

#: ../doc/1.10/book/app_server/launching_app.rst:129
#: ../doc/1.10/book/app_server/launching_app.rst:220
msgid ""
"$ tarantool myapp.lua\n"
"Hello, world!\n"
"$"
msgstr ""
"$ tarantool myapp.lua\n"
"Hello, world!\n"
"$"

#: ../doc/1.10/book/app_server/launching_app.rst:135
msgid "Tarantool starts, executes our script in the **script mode** and exits."
msgstr ""
"Tarantool запускается, выполняет наш скрипт в **режиме скрипта** и "
"завершает работу."

#: ../doc/1.10/book/app_server/launching_app.rst:137
msgid ""
"Now let’s turn this script into a **server application**. We use "
":ref:`box.cfg <box_introspection-box_cfg>` from Tarantool’s built-in Lua "
"module to:"
msgstr ""
"Теперь превратим этот скрипт в **серверное приложение**. Используем "
":ref:`box.cfg <box_introspection-box_cfg>` из встроенного в Tarantool "
"Lua-модуля, чтобы:"

#: ../doc/1.10/book/app_server/launching_app.rst:141
msgid ""
"launch the database (a database has a persistent on-disk state, which "
"needs to be restored after we start an application) and"
msgstr ""
"запустить базу данных (данные в базе находятся в персистентном состоянии "
"на диске, которое следует восстановить после запуска приложения) и"

#: ../doc/1.10/book/app_server/launching_app.rst:143
msgid "configure Tarantool as a server that accepts requests over a TCP port."
msgstr "настроить Tarantool как сервер, который принимает запросы по TCP-порту."

#: ../doc/1.10/book/app_server/launching_app.rst:145
msgid ""
"We also add some simple database logic, using :ref:`space.create() "
"<box_schema-space_create>` and :ref:`create_index() <box_space-"
"create_index>` to create a space with a primary index. We use the "
"function :ref:`box.once() <box-once>` to make sure that our logic will be"
" executed only once when the database is initialized for the first time, "
"so we don't try to create an existing space or index on each invocation "
"of the script:"
msgstr ""
"Также добавим простую логику для базы данных, используя "
":ref:`space.create() <box_schema-space_create>` и :ref:`create_index() "
"<box_space-create_index>` для создания спейса с первичным индексом. "
"Используем функцию :ref:`box.once() <box-once>`, чтобы обеспечить "
"единовременное выполнение логики после первоначальной инициализации базы "
"данных, поскольку мы не хотим создавать уже существующий спейс или индекс"
" при каждом обращении к скрипту:"

#: ../doc/1.10/book/app_server/launching_app.rst:153
msgid ""
"#!/usr/bin/env tarantool\n"
"-- Configure database\n"
"box.cfg {\n"
"   listen = 3301\n"
"}\n"
"box.once(\"bootstrap\", function()\n"
"   box.schema.space.create('tweedledum')\n"
"   box.space.tweedledum:create_index('primary',\n"
"       { type = 'TREE', parts = {1, 'unsigned'}})\n"
"end)"
msgstr ""
"#!/usr/bin/env tarantool\n"
"-- настроить базу данных\n"
"box.cfg {\n"
"   listen = 3301\n"
"}\n"
"box.once(\"bootstrap\", function()\n"
"   box.schema.space.create('tweedledum')\n"
"   box.space.tweedledum:create_index('primary',\n"
"       { type = 'TREE', parts = {1, 'unsigned'}})\n"
"end)"

#: ../doc/1.10/book/app_server/launching_app.rst:166
msgid "Now we launch our application in the same manner as before:"
msgstr "Далее запустим наше приложение, как делали ранее:"

#: ../doc/1.10/book/app_server/launching_app.rst:168
msgid ""
"$ tarantool myapp.lua\n"
"Hello, world!\n"
"2016-12-19 16:07:14.250 [41436] main/101/myapp.lua C> version "
"1.7.2-146-g021d36b\n"
"2016-12-19 16:07:14.250 [41436] main/101/myapp.lua C> log level 5\n"
"2016-12-19 16:07:14.251 [41436] main/101/myapp.lua I> mapping 1073741824 "
"bytes for tuple arena...\n"
"2016-12-19 16:07:14.255 [41436] main/101/myapp.lua I> recovery start\n"
"2016-12-19 16:07:14.255 [41436] main/101/myapp.lua I> recovering from "
"`./00000000000000000000.snap'\n"
"2016-12-19 16:07:14.271 [41436] main/101/myapp.lua I> recover from "
"`./00000000000000000000.xlog'\n"
"2016-12-19 16:07:14.271 [41436] main/101/myapp.lua I> done "
"`./00000000000000000000.xlog'\n"
"2016-12-19 16:07:14.272 [41436] main/102/hot_standby I> recover from "
"`./00000000000000000000.xlog'\n"
"2016-12-19 16:07:14.274 [41436] iproto/102/iproto I> binary: started\n"
"2016-12-19 16:07:14.275 [41436] iproto/102/iproto I> binary: bound to "
"[::]:3301\n"
"2016-12-19 16:07:14.275 [41436] main/101/myapp.lua I> done "
"`./00000000000000000000.xlog'\n"
"2016-12-19 16:07:14.278 [41436] main/101/myapp.lua I> ready to accept "
"requests"
msgstr ""
"$ tarantool myapp.lua\n"
"Hello, world!\n"
"2016-12-19 16:07:14.250 [41436] main/101/myapp.lua C> version "
"1.7.2-146-g021d36b\n"
"2016-12-19 16:07:14.250 [41436] main/101/myapp.lua C> log level 5\n"
"2016-12-19 16:07:14.251 [41436] main/101/myapp.lua I> mapping 1073741824 "
"bytes for tuple arena...\n"
"2016-12-19 16:07:14.255 [41436] main/101/myapp.lua I> recovery start\n"
"2016-12-19 16:07:14.255 [41436] main/101/myapp.lua I> recovering from "
"`./00000000000000000000.snap'\n"
"2016-12-19 16:07:14.271 [41436] main/101/myapp.lua I> recover from "
"`./00000000000000000000.xlog'\n"
"2016-12-19 16:07:14.271 [41436] main/101/myapp.lua I> done "
"`./00000000000000000000.xlog'\n"
"2016-12-19 16:07:14.272 [41436] main/102/hot_standby I> recover from "
"`./00000000000000000000.xlog'\n"
"2016-12-19 16:07:14.274 [41436] iproto/102/iproto I> binary: started\n"
"2016-12-19 16:07:14.275 [41436] iproto/102/iproto I> binary: bound to "
"[::]:3301\n"
"2016-12-19 16:07:14.275 [41436] main/101/myapp.lua I> done "
"`./00000000000000000000.xlog'\n"
"2016-12-19 16:07:14.278 [41436] main/101/myapp.lua I> ready to accept "
"requests"

#: ../doc/1.10/book/app_server/launching_app.rst:185
msgid ""
"This time, Tarantool executes our script and keeps working as a server, "
"accepting TCP requests on port 3301. We can see Tarantool in the current "
"session’s process list:"
msgstr ""
"На этот раз Tarantool выполняет скрипт и продолжает работать в качестве "
"сервера, принимая TCP-запросы на порт 3301. Можно увидеть Tarantool в "
"списке процессов текущей сессии:"

#: ../doc/1.10/book/app_server/launching_app.rst:189
msgid ""
"$ ps | grep \"tarantool\"\n"
"  PID TTY           TIME CMD\n"
"41608 ttys001       0:00.47 tarantool myapp.lua <running>"
msgstr ""
"$ ps | grep \"tarantool\"\n"
"  PID TTY           TIME CMD\n"
"41608 ttys001       0:00.47 tarantool myapp.lua <running>"

#: ../doc/1.10/book/app_server/launching_app.rst:195
msgid ""
"But the Tarantool instance will stop if we close the current terminal "
"window. To detach Tarantool and our application from the terminal window,"
" we can launch it in the **daemon mode**. To do so, we add some "
"parameters to ``box.cfg{}``:"
msgstr ""
"Однако экземпляр Tarantool'а завершит работу, если мы закроем окно "
"командной строки. Чтобы отделить Tarantool и приложение от окна командной"
" строки, можно запустить **режим демона**. Для этого добавим некоторые "
"параметры в ``box.cfg{}``:"

#: ../doc/1.10/book/app_server/launching_app.rst:199
msgid ""
":ref:`background <cfg_basic-background>` = ``true`` that actually tells "
"Tarantool to work as a daemon service,"
msgstr ""
":ref:`background <cfg_basic-background>` = ``true``, который собственно "
"заставит Tarantool работать в качестве демона,"

#: ../doc/1.10/book/app_server/launching_app.rst:201
msgid ""
":ref:`log <cfg_logging-log>` = ``'dir-name'`` that tells the Tarantool "
"daemon where to store its log file (other log settings are available in "
"Tarantool :ref:`log <log-module>` module), and"
msgstr ""
":ref:`log <cfg_logging-log>` = ``'dir-name'``, который укажет, где демон "
"Tarantool'а будет сохранять файл журнала (другие настройки журнала "
"находятся в модуле Tarantool'а :ref:`log <log-module>` module), а также"

#: ../doc/1.10/book/app_server/launching_app.rst:204
msgid ""
":ref:`pid_file <cfg_basic-pid_file>` = ``'file-name'`` that tells the "
"Tarantool daemon where to store its pid file."
msgstr ""
":ref:`pid_file <cfg_basic-pid_file>` = ``'file-name'``, который укажет, "
"где демон Tarantool'а будет сохранять файл журнала pid-файл."

#: ../doc/1.10/book/app_server/launching_app.rst:207
#: ../doc/1.10/book/box/engines/vinyl.rst:548
#: ../doc/1.10/reference/configuration/cfg_snapshot_daemon.rst:59
#: ../doc/1.10/reference/reference_lua/box_error.rst:104
#: ../doc/1.10/reference/reference_lua/digest.rst:261
#: ../doc/1.10/reference/reference_rock/dbms.rst:116
#: ../doc/1.10/reference/reference_rock/dbms.rst:469
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:877
msgid "For example:"
msgstr "Например:"

#: ../doc/1.10/book/app_server/launching_app.rst:209
msgid ""
"box.cfg {\n"
"   listen = 3301,\n"
"   background = true,\n"
"   log = '1.log',\n"
"   pid_file = '1.pid'\n"
"}"
msgstr ""
"box.cfg {\n"
"   listen = 3301,\n"
"   background = true,\n"
"   log = '1.log',\n"
"   pid_file = '1.pid'\n"
"}"

#: ../doc/1.10/book/app_server/launching_app.rst:218
msgid "We launch our application in the same manner as before:"
msgstr "Запустим наше приложение, как делали ранее:"

#: ../doc/1.10/book/app_server/launching_app.rst:226
msgid ""
"Tarantool executes our script, gets detached from the current shell "
"session (you won't see it with ``ps | grep \"tarantool\"``) and continues"
" working in the background as a daemon attached to the global session "
"(with SID = 0):"
msgstr ""
"Tarantool выполняет наш скрипт, отделяется от текущей сессии (он не "
"отображается при вводе ``ps | grep \"tarantool\"``) и продолжает работать"
" в фоновом режиме в качестве демона, прикрепленного к общей сессии (с SID"
" = 0):"

#: ../doc/1.10/book/app_server/launching_app.rst:230
msgid ""
"$ ps -ef | grep \"tarantool\"\n"
"  PID SID     TIME  CMD\n"
"42178   0  0:00.72 tarantool myapp.lua <running>"
msgstr ""
"$ ps -ef | grep \"tarantool\"\n"
"  PID SID     TIME  CMD\n"
"42178   0  0:00.72 tarantool myapp.lua <running>"

#: ../doc/1.10/book/app_server/launching_app.rst:236
msgid ""
"Now that we have discussed how to create and launch a Lua application for"
" Tarantool, let's dive deeper into programming practices."
msgstr ""
"Рассмотрев создание и запуск Lua-приложения для Tarantool'а, перейдем к "
"углубленному изложению методик программирования."

#: ../doc/1.10/book/app_server/reloading_module.rst:39
msgid "Reloading a module"
msgstr "Перезагрузка модуля"

#: ../doc/1.10/book/app_server/reloading_module.rst:41
msgid "You can reload any Tarantool application or module with zero downtime."
msgstr ""
"Любое приложение или модуль Tarantool'а можно перезагрузить с нулевым "
"временем простоя."

#: ../doc/1.10/book/app_server/reloading_module.rst:47
msgid "Reloading a module in Lua"
msgstr "Перезагрузка модуля на Lua"

#: ../doc/1.10/book/app_server/reloading_module.rst:49
msgid ""
"Here's an example that illustrates the most typical case -- \"update and "
"reload\"."
msgstr ""
"Ниже представлен пример, который иллюстрирует наиболее типичный случай --"
" \"обновление и перезагрузка\"."

#: ../doc/1.10/book/app_server/reloading_module.rst:53
msgid ""
"In this example, we use recommended :ref:`administration practices "
"<admin>` based on :ref:`instance files <admin-instance_file>` and "
":ref:`tarantoolctl <tarantoolctl>` utility."
msgstr ""
"В этом примере используются рекомендованные :ref:`методики "
"администрирования <admin>` на основании :ref:`файлов экземпляров <admin-"
"instance_file>` и утилиты :ref:`tarantoolctl <tarantoolctl>`."

#: ../doc/1.10/book/app_server/reloading_module.rst:57
msgid "Update the application file."
msgstr "Обновите файлы приложения."

#: ../doc/1.10/book/app_server/reloading_module.rst:59
msgid "For example, a module in ``/usr/share/tarantool/app.lua``:"
msgstr "Например, модуль в ``/usr/share/tarantool/app.lua``:"

#: ../doc/1.10/book/app_server/reloading_module.rst:61
msgid ""
"local function start()\n"
"  -- initial version\n"
"  box.once(\"myapp:v1.0\", function()\n"
"    box.schema.space.create(\"somedata\")\n"
"    box.space.somedata:create_index(\"primary\")\n"
"    ...\n"
"  end)\n"
"\n"
"  -- migration code from 1.0 to 1.1\n"
"  box.once(\"myapp:v1.1\", function()\n"
"    box.space.somedata.index.primary:alter(...)\n"
"    ...\n"
"  end)\n"
"\n"
"  -- migration code from 1.1 to 1.2\n"
"  box.once(\"myapp:v1.2\", function()\n"
"    box.space.somedata.index.primary:alter(...)\n"
"    box.space.somedata:insert(...)\n"
"    ...\n"
"  end)\n"
"end\n"
"\n"
"-- start some background fibers if you need\n"
"\n"
"local function stop()\n"
"  -- stop all background fibers and clean up resources\n"
"end\n"
"\n"
"local function api_for_call(xxx)\n"
"  -- do some business\n"
"end\n"
"\n"
"return {\n"
"  start = start,\n"
"  stop = stop,\n"
"  api_for_call = api_for_call\n"
"}"
msgstr ""
"local function start()\n"
"  -- начальная версия\n"
"  box.once(\"myapp:v1.0\", function()\n"
"    box.schema.space.create(\"somedata\")\n"
"    box.space.somedata:create_index(\"primary\")\n"
"    ...\n"
"  end)\n"
"\n"
"  -- код миграции с 1.0 на 1.1\n"
"  box.once(\"myapp:v1.1\", function()\n"
"    box.space.somedata.index.primary:alter(...)\n"
"    ...\n"
"  end)\n"
"\n"
"  -- код миграции с 1.1 на 1.2\n"
"  box.once(\"myapp:v1.2\", function()\n"
"    box.space.somedata.index.primary:alter(...)\n"
"    box.space.somedata:insert(...)\n"
"    ...\n"
"  end)\n"
"end\n"
"\n"
"-- запустить файберы в фоновом режиме, если необходимо\n"
"\n"
"local function stop()\n"
"  -- остановить все файберы, работающие в фоновом режиме, и очистить "
"ресурсы\n"
"end\n"
"\n"
"local function api_for_call(xxx)\n"
"  -- сделать что-то\n"
"end\n"
"\n"
"return {\n"
"  start = start,\n"
"  stop = stop,\n"
"  api_for_call = api_for_call\n"
"}"

#: ../doc/1.10/book/app_server/reloading_module.rst:101
msgid "Update the :ref:`instance file <admin-instance_file>`."
msgstr "Обновить :ref:`файл экземпляра <admin-instance_file>`."

#: ../doc/1.10/book/app_server/reloading_module.rst:103
msgid "For example, ``/etc/tarantool/instances.enabled/my_app.lua``:"
msgstr "Например, ``/etc/tarantool/instances.enabled/my_app.lua``:"

#: ../doc/1.10/book/app_server/reloading_module.rst:105
msgid ""
"#!/usr/bin/env tarantool\n"
"--\n"
"-- hot code reload example\n"
"--\n"
"\n"
"box.cfg({listen = 3302})\n"
"\n"
"-- ATTENTION: unload it all properly!\n"
"local app = package.loaded['app']\n"
"if app ~= nil then\n"
"  -- stop the old application version\n"
"  app.stop()\n"
"  -- unload the application\n"
"  package.loaded['app'] = nil\n"
"  -- unload all dependencies\n"
"  package.loaded['somedep'] = nil\n"
"end\n"
"\n"
"-- load the application\n"
"log.info('require app')\n"
"app = require('app')\n"
"\n"
"-- start the application\n"
"app.start({some app options controlled by sysadmins})"
msgstr ""
"#!/usr/bin/env tarantool\n"
"--\n"
"-- пример горячей перезагрузки кода\n"
"--\n"
"\n"
"box.cfg({listen = 3302})\n"
"\n"
"-- ВНИМАНИЕ: правильно выполните разгрузку!\n"
"local app = package.loaded['app']\n"
"if app ~= nil then\n"
"  -- остановите старую версию приложения\n"
"  app.stop()\n"
"  -- разгрузите приложение\n"
"  package.loaded['app'] = nil\n"
"  -- разгрузите все зависимости\n"
"  package.loaded['somedep'] = nil\n"
"end\n"
"\n"
"-- загрузите приложение\n"
"log.info('require app')\n"
"app = require('app')\n"
"\n"
"-- запустите приложение\n"
"app.start({some app options controlled by sysadmins})"

#: ../doc/1.10/book/app_server/reloading_module.rst:132
msgid ""
"The important thing here is to properly unload the application and its "
"dependencies."
msgstr "Самое главное -- правильно разгрузить приложение и его зависимости."

#: ../doc/1.10/book/app_server/reloading_module.rst:135
msgid "Manually reload the application file."
msgstr "Вручную перезагрузите файл приложения."

#: ../doc/1.10/book/app_server/reloading_module.rst:137
msgid "For example, using ``tarantoolctl``:"
msgstr "Например, используя ``tarantoolctl``:"

#: ../doc/1.10/book/app_server/reloading_module.rst:139
msgid "$ tarantoolctl eval my_app /etc/tarantool/instances.enabled/my_app.lua"
msgstr "$ tarantoolctl eval my_app /etc/tarantool/instances.enabled/my_app.lua"

#: ../doc/1.10/book/app_server/reloading_module.rst:147
msgid "Reloading a module in C"
msgstr "Перезагрузка модуля на С"

#: ../doc/1.10/book/app_server/reloading_module.rst:149
msgid ""
"After you compiled a new version of a C module (``*.so`` shared library),"
" call :ref:`box.schema.func.reload('module-name') <box_schema-"
"func_reload>` from your Lua script to reload the module."
msgstr ""
"После компиляции новой версии модуля на C (библиотека общего пользования "
"``*.so``),  вызовите функцию :ref:`box.schema.func.reload('module-name') "
"<box_schema-func_reload>` из Lua-скрипта для перезагрузки модуля."

#: ../doc/1.10/book/app_server/using_ide.rst:39
msgid "Developing with an IDE"
msgstr "Разработка с IDE"

#: ../doc/1.10/book/app_server/using_ide.rst:41
msgid ""
"You can use IntelliJ IDEA as an IDE to develop and debug Lua applications"
" for Tarantool."
msgstr ""
"Для разработки и отладки Lua-приложений для Tarantool'а можно "
"использовать IntelliJ IDEA в качестве интегрированной среды разработки "
"(IDE)."

#: ../doc/1.10/book/app_server/using_ide.rst:44
msgid ""
"Download and install the IDE from the `official web-site "
"<https://www.jetbrains.com/idea/>`_."
msgstr ""
"Загрузите и установите IDE с `официального сайта "
"<https://www.jetbrains.com/idea/>`_."

#: ../doc/1.10/book/app_server/using_ide.rst:47
msgid ""
"JetBrains provides specialized editions for particular languages: "
"IntelliJ IDEA (Java), PHPStorm (PHP), PyCharm (Python), RubyMine (Ruby), "
"CLion (C/C++), WebStorm (Web) and others. So, download a version that "
"suits your primary programming language."
msgstr ""
"JetBrains предоставляет специализированные версии для разных языков "
"программирования: IntelliJ IDEA (Java), PHPStorm (PHP), PyCharm (Python),"
" RubyMine (Ruby), CLion (C/C++), WebStorm (Web) и другие. Поэтому "
"загрузите версию, которая подходит предпочитаемому языку."

#: ../doc/1.10/book/app_server/using_ide.rst:52
msgid "Tarantool integration is supported for all editions."
msgstr "Для всех версий поддерживается интеграция с Tarantool'ом."

#: ../doc/1.10/book/app_server/using_ide.rst:54
msgid "Configure the IDE:"
msgstr "Настройте IDE:"

#: ../doc/1.10/book/app_server/using_ide.rst:56
msgid "Start IntelliJ IDEA."
msgstr "Запустите IntelliJ IDEA."

#: ../doc/1.10/book/app_server/using_ide.rst:57
msgid "Click ``Configure`` button and select ``Plugins``."
msgstr "Нажмите кнопку ``Configure`` и выберите ``Plugins``."

#: ../doc/1.10/book/app_server/using_ide.rst:64
msgid "Click ``Browse repositories``."
msgstr "Нажмите ``Browse repositories``."

#: ../doc/1.10/book/app_server/using_ide.rst:71
msgid "Install ``EmmyLua`` plugin."
msgstr "Установите плагин ``EmmyLua``."

#: ../doc/1.10/book/app_server/using_ide.rst:75
msgid ""
"Please don’t be confused with ``Lua`` plugin, which is less powerful than"
" ``EmmyLua``."
msgstr ""
"Не путайте с плагином ``Lua``, у которого меньше возможностей, чем у "
"``EmmyLua``."

#: ../doc/1.10/book/app_server/using_ide.rst:83
msgid "Restart IntelliJ IDEA."
msgstr "Перезапустите IntelliJ IDEA."

#: ../doc/1.10/book/app_server/using_ide.rst:84
msgid ""
"Click ``Configure``, select ``Project Defaults`` and then ``Run "
"Configurations``."
msgstr ""
"Нажмите ``Configure``, выберите ``Project Defaults``, а затем ``Run "
"Configurations``."

#: ../doc/1.10/book/app_server/using_ide.rst:92
msgid "Find ``Lua Application`` in the sidebar at the left."
msgstr "Найдите ``Lua Application`` в боковой панели слева."

#: ../doc/1.10/book/app_server/using_ide.rst:94
msgid "In ``Program``, type a path to an installed ``tarantool`` binary."
msgstr "В ``Program`` введите путь к установленному бинарному файлу ``tarantool``."

#: ../doc/1.10/book/app_server/using_ide.rst:96
msgid ""
"By default, this is ``tarantool`` or ``/usr/bin/tarantool`` on most "
"platforms."
msgstr ""
"По умолчанию, это ``tarantool`` или ``/usr/bin/tarantool`` на большинстве"
" платформ."

#: ../doc/1.10/book/app_server/using_ide.rst:99
msgid ""
"If you installed ``tarantool`` from sources to a custom directory, please"
" specify the proper path here."
msgstr ""
"Если вы установили ``tarantool`` из источников в другую директорию, "
"укажите здесь правильный путь."

#: ../doc/1.10/book/app_server/using_ide.rst:107
msgid "Now IntelliJ IDEA is ready to use with Tarantool."
msgstr "Теперь IntelliJ IDEA можно использовать с Tarantool'ом."

#: ../doc/1.10/book/app_server/using_ide.rst:109
msgid "Create a new Lua project."
msgstr "Создайте новый проект на Lua."

#: ../doc/1.10/book/app_server/using_ide.rst:116
msgid "Add a new Lua file, for example ``init.lua``."
msgstr "Добавьте новый Lua-файл, например, ``init.lua``."

#: ../doc/1.10/book/app_server/using_ide.rst:123
msgid "Write your code, save the file."
msgstr "Разработайте код, сохраните файл."

#: ../doc/1.10/book/app_server/using_ide.rst:125
msgid ""
"To run you application, click ``Run -> Run`` in the main menu and select "
"your source file in the list."
msgstr ""
"Чтобы запустить приложение, нажмите ``Run -> Run`` в основном меню и "
"выберите исходный файл из списка."

#: ../doc/1.10/book/app_server/using_ide.rst:133
msgid "Or click ``Run -> Debug`` to start debugging."
msgstr "Или нажмите ``Run -> Debug`` для начала отладки."

#: ../doc/1.10/book/app_server/using_ide.rst:137
msgid ""
"To use Lua debugger, please upgrade Tarantool to version "
"1.7.5-29-gbb6170e4b or later."
msgstr ""
"Чтобы использовать Lua-отладчик, обновите Tarantool до версии "
"1.7.5-29-gbb6170e4b или более поздней версии."

#: ../doc/1.10/book/box/atomic.rst:39
msgid "Transaction control"
msgstr "Контроль транзакций"

#: ../doc/1.10/book/box/atomic.rst:41
msgid ""
"Transactions in Tarantool occur in **fibers** on a single **thread**. "
"That is why Tarantool has a guarantee of execution atomicity. That "
"requires emphasis."
msgstr ""
"Транзакции в Tarantool'е происходят в **файберах** в одном **потоке**. "
"Вот почему Tarantool дает гарантию атомарности выполнения. На этом "
"следует сделать акцент."

#: ../doc/1.10/book/box/atomic.rst:49
msgid "Threads, fibers and yields"
msgstr "Потоки, файберы и передача управления"

#: ../doc/1.10/book/box/atomic.rst:51
msgid ""
"How does Tarantool process a basic operation? As an example, let's take "
"this query:"
msgstr ""
"Как Tarantool выполняет основные операции? Для примера возьмем такой "
"запрос:"

#: ../doc/1.10/book/box/atomic.rst:54
msgid "tarantool> box.space.tester:update({3}, {{'=', 2, 'size'}, {'=', 3, 0}})"
msgstr "tarantool> box.space.tester:update({3}, {{'=', 2, 'size'}, {'=', 3, 0}})"

#: ../doc/1.10/book/box/atomic.rst:58
msgid ""
"This is equivalent to the following SQL statement for a table that stores"
" primary keys in ``field[1]``:"
msgstr ""
"Это эквивалентно следующему SQL-выражению (оно работает с таблицей, где "
"первичные ключи в ``field[1]``):"

#: ../doc/1.10/book/box/atomic.rst:61
msgid ""
"UPDATE tester SET \"field[2]\" = 'size', \"field[3]\" = 0 WHERE "
"\"field[1]\" = 3"
msgstr ""
"UPDATE tester SET \"field[2]\" = 'size', \"field[3]\" = 0 WHERE "
"\"field[1]\" = 3"

#: ../doc/1.10/book/box/atomic.rst:65
msgid "This query will be processed with three operating system **threads**:"
msgstr "Этот запрос будет обработан тремя **потоками** операционной системы:"

#: ../doc/1.10/book/box/atomic.rst:67
msgid ""
"If we issue the query on a remote client, then the **network thread** on "
"the server side receives the query, parses the statement and changes it "
"to a server executable message which has already been checked, and which "
"the server instance can understand without parsing everything again."
msgstr ""
"Если мы передадим запрос на удаленный клиент, **сетевой поток** на "
"стороне сервера получит запрос, разберет выражение и преобразует его в "
"выполняемое сообщение сервера, которое уже проверено. Такое сообщение "
"экземпляр сервера может понимать без повторного разбора."

#: ../doc/1.10/book/box/atomic.rst:72
msgid ""
"The network thread ships this message to the instance's **transaction "
"processor thread** using a lock-free message bus. Lua programs execute "
"directly in the transaction processor thread, and do not require parsing "
"and preparation."
msgstr ""
"Сетевой поток отправляет это сообщение в **поток обработки транзакций** с"
" помощью шины передачи сообщений без блокировок. Lua-программы "
"выполняются непосредственно в потоке обработки транзакций и не требуют "
"разбора и подготовки."

#: ../doc/1.10/book/box/atomic.rst:77
msgid ""
"The instance's transaction processor thread uses the primary-key index on"
" field[1] to find the location of the tuple. It determines that the tuple"
" can be updated (not much can go wrong when you're merely changing an "
"unindexed field value to something shorter)."
msgstr ""
"Поток обработки транзакций экземпляра использует индекс на поле "
"первичного ключа field[1], чтобы найти нужный кортеж. Он проверяет, что "
"данный кортеж можно обновить (мы хотим лишь изменить значение не "
"индексированного поля на более короткое, и вряд ли что-то пойдет не так)."

#: ../doc/1.10/book/box/atomic.rst:82
msgid ""
"The transaction processor thread sends a message to the :ref:`write-ahead"
" logging (WAL) thread <internals-wal>` to commit the transaction. When "
"done, the WAL thread replies with a COMMIT or ROLLBACK result, which is "
"returned to the client."
msgstr ""
"Поток обработки транзакций отправляет сообщение в :ref:`поток упреждающей"
" записи в журнал (WAL) <internals-wal>` для коммита транзакции. По "
"завершении поток WAL отправляет ответ с результатом COMMIT (коммит) или "
"ROLLBACK (откат) на клиент."

#: ../doc/1.10/book/box/atomic.rst:87
msgid ""
"Notice that there is only one transaction processor thread in Tarantool. "
"Some people are used to the idea that there can be multiple threads "
"operating on the database, with (say) thread #1 reading row #x, while "
"thread #2 writes row #y. With Tarantool, no such thing ever happens. Only"
" the transaction processor thread can access the database, and there is "
"only one transaction processor thread for each Tarantool instance."
msgstr ""
"Обратите внимание, что в Tarantool'е есть только один поток обработки "
"транзакций. Некоторые уже привыкли к мысли, что потоков для обработки "
"данных в базе данных может быть много (например, поток №1 читает данные "
"из строки №x, в то время как поток №2 записывает данные в столбец №y). В "
"случае с Tarantool'ом такого не происходит. Доступ к базе есть только у "
"потока обработки транзакций, и на  каждый экземпляр Tarantool'а есть "
"только один такой поток."

#: ../doc/1.10/book/box/atomic.rst:94
msgid ""
"Like any other Tarantool thread, the transaction processor thread can "
"handle many :ref:`fibers <fiber-fibers>`. A fiber is a set of computer "
"instructions that may contain \"**yield**\" signals. The transaction "
"processor thread will execute all computer instructions until a yield, "
"then switch to execute the instructions of a different fiber. Thus (say) "
"the thread reads row #x for the sake of fiber #1, then writes row #y for "
"the sake of fiber #2."
msgstr ""
"Как и любой другой поток Tarantool'а, поток обработки транзакций может "
"управлять множеством :ref:`файберов <fiber-fibers>`. Файбер -- это набор "
"команд, среди которых могут быть и сигналы \"**передачи управления**\". "
"Поток обработки транзакций выполняет все команды, пока не увидит такой "
"сигнал, и тогда он переключается на выполнение команд из другого файбера."
" Например, таким образом поток обработки транзакций сначала выполняет "
"чтение данных из строки №x для файбера №1, а затем выполняет запись в "
"строку №y для файбера №2."

#: ../doc/1.10/book/box/atomic.rst:101
msgid ""
"Yields must happen, otherwise the transaction processor thread would "
"stick permanently on the same fiber. There are two types of yields:"
msgstr ""
"Передача управления необходима, в противном случае, поток обработки "
"транзакции заклинит на одном файбере. Есть два типа передачи управления:"

#: ../doc/1.10/book/box/atomic.rst:104
msgid ""
":ref:`implicit yields <atomic-implicit-yields>`: every data-change "
"operation or network-access causes an implicit yield, and every statement"
" that goes through the Tarantool client causes an implicit yield."
msgstr ""
":ref:`неявная передача управления <atomic-implicit-yields>`: каждая "
"операция по изменению данных или доступ к сети вызывают неявную передачу "
"управления, а также каждое выражение, которое проходит через клиент "
"Tarantool'а, вызывает неявную передачу управления."

#: ../doc/1.10/book/box/atomic.rst:108
msgid ""
"explicit yields: in a Lua function, you can (and should) add "
":ref:`\"yield\" <fiber-yield>` statements to prevent hogging. This is "
"called **cooperative multitasking**."
msgstr ""
"явная передача управления: в Lua-функции можно (и нужно) добавить "
"выражения :ref:`\"передачи управления\" <fiber-yield>` для предотвращения"
" захвата ЦП. Это называется **кооперативной многозадачностью**."

#: ../doc/1.10/book/box/atomic.rst:116
msgid "Cooperative multitasking"
msgstr "Кооперативная многозадачность"

#: ../doc/1.10/book/box/atomic.rst:118
msgid ""
"Cooperative multitasking means: unless a running fiber deliberately "
"yields control, it is not preempted by some other fiber. But a running "
"fiber will deliberately yield when it encounters a “yield point”: a "
"transaction commit, an operating system call, or an explicit "
":ref:`\"yield\" <fiber-yield>` request. Any system call which can block "
"will be performed asynchronously, and any running fiber which must wait "
"for a system call will be preempted, so that another ready-to-run fiber "
"takes its place and becomes the new running fiber."
msgstr ""
"Кооперативная многозадачность означает, что если запущенный файбер "
"намеренно не передаст управление, он не вытесняется каким-либо другим "
"файбером. Но запущенный файбер намеренно передает управление, когда "
"обнаруживает “точку передачи управления”: коммит транзакции, вызов "
"операционной системы или запрос явной :ref:`\"передачи управления\" "
"<fiber-yield>`. Любой вызов системы, который может блокировать файбер, "
"будет производиться асинхронно, а запущенный файбер, который должен "
"ожидать системного вызова, будет вытеснен так, что другой готовый к "
"работе файбер занимает его место и становится запущенным файбером."

#: ../doc/1.10/book/box/atomic.rst:126
msgid ""
"This model makes all programmatic locks unnecessary: cooperative "
"multitasking ensures that there will be no concurrency around a resource,"
" no race conditions, and no memory consistency issues."
msgstr ""
"Эта модель исключает необходимость любых программных блокировок -- "
"кооперативная многозадачность обеспечивает отсутствие многопоточности "
"вокруг ресурса, состояния гонки и проблем с согласованностью данных."

#: ../doc/1.10/book/box/atomic.rst:130
msgid ""
"When requests are small, for example simple UPDATE or INSERT or DELETE or"
" SELECT, fiber scheduling is fair: it takes only a little time to process"
" the request, schedule a disk write, and yield to a fiber serving the "
"next client."
msgstr ""
"При небольших запросах, таких как простые UPDATE, INSERT, DELETE или "
"SELECT, происходит справедливое планирование файберов: немного времени "
"требуется на обработку запроса, планирование записи на диск и передачу "
"управления на файбер, обслуживающий следующего клиента."

#: ../doc/1.10/book/box/atomic.rst:134
msgid ""
"However, a function might perform complex computations or might be "
"written in such a way that yields do not occur for a long time. This can "
"lead to unfair scheduling, when a single client throttles the rest of the"
" system, or to apparent stalls in request processing. Avoiding this "
"situation is the responsibility of the function’s author."
msgstr ""
"Однако функция может выполнять сложные расчеты  или может быть написана "
"так, что управление не передается в течение длительного времени. Это "
"может привести к несправедливому планированию, когда отдельный клиент "
"перекрывает работу остальной системы, или к явным задержкам в обработке "
"запросов. Автору функции следует не допускать таких ситуаций."

#: ../doc/1.10/book/box/atomic.rst:144
msgid "Transactions"
msgstr "Транзакции"

#: ../doc/1.10/book/box/atomic.rst:146
msgid ""
"In the absence of transactions, any function that contains yield points "
"may see changes in the database state caused by fibers that preempt. "
"Multi-statement transactions exist to provide **isolation**: each "
"transaction sees a consistent database state and commits all its changes "
"atomically. At :ref:`commit <box-commit>` time, a yield happens and all "
"transaction changes are written to the :ref:`write ahead log <internals-"
"wal>` in a single batch. Or, if needed, transaction changes can be rolled"
" back -- :ref:`completely <box-rollback>` or to a specific "
":ref:`savepoint <box-rollback_to_savepoint>`."
msgstr ""
"В отсутствие транзакций любая функция, в которой есть точки передачи "
"управления, может видеть изменения в состоянии базы данных, вызванные "
"вытесняющими файберами. Составные транзакции предназначены для "
"**изоляции**: каждая транзакция видит постоянное состояние базы данных и "
"делает атомарные коммиты изменений. Во время :ref:`коммита <box-commit>` "
"происходит передача управления, а все транзакционные изменения "
"записываются в :ref:`журнал упреждающей записи <internals-wal>` в "
"отдельный пакет. Или, при необходимости, можно откатить изменения -- "
":ref:`полностью <box-rollback>` или на определенную :ref:`точку "
"сохранения <box-rollback_to_savepoint>`."

#: ../doc/1.10/book/box/atomic.rst:156
msgid ""
"To implement isolation, Tarantool uses a simple optimistic scheduler: the"
" first transaction to commit wins. If a concurrent active transaction has"
" read a value modified by a committed transaction, it is aborted."
msgstr ""
"Чтобы осуществить изоляцию, Tarantool использует простой планировщик с "
"оптимистичным управлением: транзакция подтверждена первой -- выигрывает. "
"Если параллельная активная транзакция читает значение, измененное "
"подтвержденной транзакцией, она прерывается."

#: ../doc/1.10/book/box/atomic.rst:160
msgid ""
"The cooperative scheduler ensures that, in absence of yields, a multi-"
"statement transaction is not preempted and hence is never aborted. "
"Therefore, understanding yields is essential to writing abort-free code."
msgstr ""
"Кооперативный планировщик обеспечивает, что в отсутствие передачи "
"управления составная транзакция не вытесняется, поэтому никогда не "
"прерывается. Таким образом, понимание передачи управления необходимо для "
"написания кода без прерываний."

#: ../doc/1.10/book/box/atomic.rst:166
msgid "You can’t mix storage engines in a transaction today."
msgstr "На сегодняшний день нельзя смешивать движки базы данных в транзакции."

#: ../doc/1.10/book/box/atomic.rst:172
msgid "Implicit yields"
msgstr "Правила неявной передачи управления"

#: ../doc/1.10/book/box/atomic.rst:174
msgid ""
"The only explicit yield requests in Tarantool are :ref:`fiber.sleep() "
"<fiber-sleep>` and :ref:`fiber.yield() <fiber-yield>`, but many other "
"requests \"imply\" yields because Tarantool is designed to avoid "
"blocking."
msgstr ""
"Единственные запросы явной передачи данных в Tarantool'е отправляют "
":ref:`fiber.sleep() <fiber-sleep>` и :ref:`fiber.yield() <fiber-yield>`, "
"но многие другие запросы \"неявно\" подразумевают передачу управления, "
"поскольку цель Tarantool'а -- избежать блокировок."

#: ../doc/1.10/book/box/atomic.rst:178
msgid ""
"Database requests imply yields if and only if there is disk I/O. For "
"memtx, since all data is in memory, there is no disk I/O during the "
"request. For vinyl, since some data may not be in memory, there may be "
"disk I/O for a read (to fetch data from disk) or for a write (because a "
"stall may occur while waiting for memory to be free). For both memtx and "
"vinyl, since data-change requests must be recorded in the WAL, there is "
"normally a commit. A commit happens automatically after every request in "
"default \"autocommit\" mode, or a commit happens at the end of a "
"transaction in \"transaction\" mode, when a user deliberately commits by "
"calling :ref:`box.commit() <box-commit>`. Therefore for both memtx and "
"vinyl, because there can be disk I/O, some database operations may imply "
"yields."
msgstr ""
"Запросы к базе данных подразумевают передачу управления исключительно при"
" вводе-выводе с диска. В memtx'е нет дискового ввода-вывода во время "
"запроса, поскольку все данные находятся в памяти. Что же касается "
"vinyl'а, то некоторых данных может не быть в памяти, поэтому для чтения "
"дисковый ввод-вывод может использоваться для чтения (для извлечения "
"данных с диска) или для записи (потому что в ожидании освобождения памяти"
" может произойти задержка). Как для memtx'а, так и для vinyl'а обычно "
"используются коммиты, поскольку запросы на изменение данных должны быть "
"записаны в WAL. В режиме автокоммита по умолчанию коммиты производятся "
"автоматически после каждого запроса. В режиме транзакций коммит "
"производится в конце транзакции, когда пользователь специально совершает "
"коммит, вызывая :ref:`box.commit() <box-commit>`. Поэтому как для "
"memtx'а, так и для vinyl'а некоторые операции с базой данных могут "
"вызывать передачу управления, поскольку может производиться дисковый "
"ввод-вывод."

#: ../doc/1.10/book/box/atomic.rst:191
msgid ""
"Many functions in modules :ref:`fio <fio-section>`, :ref:`net_box "
"<net_box-module>`, :ref:`console <console-module>` and :ref:`socket "
"<socket-module>` (the \"os\" and \"network\" requests) yield."
msgstr ""
"Многие функции в модулях :ref:`fio <fio-section>`, :ref:`net_box "
"<net_box-module>`, :ref:`console <console-module>` и :ref:`socket "
"<socket-module>` (запросы \"ОС\" и \"сети\") передают управление."

#: ../doc/1.10/book/box/atomic.rst:195 ../doc/1.10/book/box/box_session.rst:383
msgid "**Example #1**"
msgstr "**Пример №1**"

#: ../doc/1.10/book/box/atomic.rst:197
msgid ""
"*Engine = memtx* |br| ``select() insert()`` has one yield, at the end of "
"insertion, caused by implicit commit; ``select()`` has nothing to write "
"to the WAL and so does not yield."
msgstr ""
"*Движок = memtx* |br| В ``select() insert()`` управление передается один "
"раз в конце вставки, что вызвано неявным коммитом; ``select()`` ничего не"
" записывает в WAL-файл, поэтому не передает управление."

#: ../doc/1.10/book/box/atomic.rst:202
msgid ""
"*Engine = vinyl* |br| ``select() insert()`` has between one and three "
"yields, since ``select()`` may yield if the data is not in cache, "
"``insert()`` may yield waiting for available memory, and there is an "
"implicit yield at commit."
msgstr ""
"*Движок = vinyl* |br| В ``select() insert()`` управление передается от "
"одного до трех раз, поскольку ``select()`` может передавать управление, "
"если данные не находятся в кэше, ``insert()`` может передавать управление"
" в ожидании свободной памяти, а при коммите управление передается неявно."

#: ../doc/1.10/book/box/atomic.rst:207
msgid ""
"The sequence ``begin() insert() insert() commit()`` yields only at commit"
" if the engine is memtx, and can yield up to 3 times if the engine is "
"vinyl."
msgstr ""
"Последовательность ``begin() insert() insert() commit()`` передает "
"управление только при коммите, если движок -- memtx, и может передавать "
"управление до 3 раз, если движок -- vinyl."

#: ../doc/1.10/book/box/atomic.rst:210 ../doc/1.10/book/box/box_session.rst:392
msgid "**Example #2**"
msgstr "**Пример №2**"

#: ../doc/1.10/book/box/atomic.rst:212
msgid ""
"Assume that in space ‘tester’ there are tuples in which the third field "
"represents a positive dollar amount. Let's start a transaction, withdraw "
"from tuple#1, deposit in tuple#2, and end the transaction, making its "
"effects permanent."
msgstr ""
"Предположим, что в спейсе ‘tester’ существуют кортежи, третье поле "
"которых представляет собой положительную сумму в долларах. Начнем "
"транзакцию, снимем сумму из кортежа №1, внесем ее в кортеж №2 и завершим "
"транзакцию, подтверждая изменения."

#: ../doc/1.10/book/box/atomic.rst:217
msgid ""
"tarantool> function txn_example(from, to, amount_of_money)\n"
"         >   box.begin()\n"
"         >   box.space.tester:update(from, {{'-', 3, amount_of_money}})\n"
"         >   box.space.tester:update(to,   {{'+', 3, amount_of_money}})\n"
"         >   box.commit()\n"
"         >   return \"ok\"\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> txn_example({999}, {1000}, 1.00)\n"
"---\n"
"- \"ok\"\n"
"..."
msgstr ""
"tarantool> function txn_example(from, to, amount_of_money)\n"
"         >   box.begin()\n"
"         >   box.space.tester:update(from, {{'-', 3, amount_of_money}})\n"
"         >   box.space.tester:update(to,   {{'+', 3, amount_of_money}})\n"
"         >   box.commit()\n"
"         >   return \"ok\"\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> txn_example({999}, {1000}, 1.00)\n"
"---\n"
"- \"ok\"\n"
"..."

#: ../doc/1.10/book/box/atomic.rst:233
msgid ""
"If :ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>` = ‘none’, then"
" implicit yielding at commit time does not take place, because there are "
"no writes to the WAL."
msgstr ""
"Если :ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>` = ‘none’, то"
" при коммите управление не передается неявно, потому что не идет запись в"
" WAL-файл."

#: ../doc/1.10/book/box/atomic.rst:237
msgid ""
"If a task is interactive -- sending requests to the server and receiving "
"responses -- then it involves network IO, and therefore there is an "
"implicit yield, even if the request that is sent to the server is not "
"itself an implicit yield request. Therefore, the sequence:"
msgstr ""
"Если задача интерактивная -- отправка запроса на сервер и получение "
"ответа -- то она включает в себя сетевой ввод-вывод, поэтому наблюдается "
"неявная передача управления, даже если отправляемый на сервер запрос не "
"представляет собой запрос с неявной передачей управления. Таким образом, "
"последовательность:"

#: ../doc/1.10/book/box/atomic.rst:245
msgid ""
"select\n"
"select\n"
"select"
msgstr ""
"select\n"
"select\n"
"select"

#: ../doc/1.10/book/box/atomic.rst:249
msgid ""
"causes blocking (in memtx), if it is inside a function or Lua program "
"being executed on the server instance, but causes yielding (in both memtx"
" and vinyl) if it is done as a series of transmissions from a client, "
"including a client which operates via telnet, via one of the connectors, "
"or via the :ref:`MySQL and PostgreSQL rocks <dbms_modules>`, or via the "
"interactive mode when :ref:`using Tarantool as a client <admin-"
"using_tarantool_as_a_client>`."
msgstr ""
"приводит к блокировке (в memtx'е), если находится внутри функции или "
"Lua-программы, которая выполняется на экземпляре сервера. Однако она "
"вызывает передачу управления (и в memtx'е, и в vinyl'е), если выполняется"
" как серия передач от клиента, включая клиентов, работающих по telnet, по"
" одному из коннекторов или :ref:`модулей MySQL и PostgreSQL "
"<dbms_modules>` или в интерактивном режиме при :ref:`использовании "
"Tarantool'а как клиента <admin-using_tarantool_as_a_client>`."

#: ../doc/1.10/book/box/atomic.rst:256
msgid ""
"After a fiber has yielded and then has regained control, it immediately "
"issues :ref:`testcancel <fiber-testcancel>`."
msgstr ""
"После того, как файбер передал управление, а затем вернул его, он "
"незамедлительно вызывает :ref:`testcancel <fiber-testcancel>`."

#: ../doc/1.10/book/box/authentication.rst:39
msgid "Access control"
msgstr "Управление доступом"

#: ../doc/1.10/book/box/authentication.rst:41
msgid ""
"Understanding security details is primarily an issue for administrators. "
"However, ordinary users should at least skim this section to get an idea "
"of how Tarantool makes it possible for administrators to prevent "
"unauthorized access to the database and to certain functions."
msgstr ""
"В основном администраторы занимаются вопросами настроек безопасности. "
"Однако обычные пользователи должны хотя бы бегло прочитать этот раздел, "
"чтобы понять, как Tarantool позволяет администраторам не допустить "
"неавторизованный доступ к базе данных и некоторым функциям."

#: ../doc/1.10/book/box/authentication.rst:46
msgid "Briefly:"
msgstr "Вкратце:"

#: ../doc/1.10/book/box/authentication.rst:48
msgid ""
"There is a method to guarantee with password checks that users really are"
" who they say they are (“authentication”)."
msgstr ""
"Существует метод, который с помощью паролей проверяет, что пользователи "
"являются теми, за кого себя выдают (“аутентификация”)."

#: ../doc/1.10/book/box/authentication.rst:51
msgid ""
"There is a :ref:`_user <box_space-user>` system space, where usernames "
"and password-hashes are stored."
msgstr ""
"Существует системный спейс :ref:`_user <box_space-user>`, где хранятся "
"имена пользователей и хеши паролей."

#: ../doc/1.10/book/box/authentication.rst:54
msgid ""
"There are functions for saying that certain users are allowed to do "
"certain things (“privileges”)."
msgstr ""
"Существуют функции, чтобы дать определенным пользователям право совершать"
" определенные действия (“права”)."

#: ../doc/1.10/book/box/authentication.rst:57
msgid ""
"There is a :ref:`_priv <box_space-priv>` system space, where privileges "
"are stored. Whenever a user tries to do an operation, there is a check "
"whether the user has the privilege to do the operation (“access "
"control”)."
msgstr ""
"Существует системный спейс :ref:`_priv <box_space-priv>`, где хранятся "
"права. Когда пользователь пытается выполнить операцию, проводится "
"проверка на наличие у него прав на выполнение такой операции (“управление"
" доступом”)."

#: ../doc/1.10/book/box/authentication.rst:61
msgid "Details follow."
msgstr "Подробная информация приводится ниже."

#: ../doc/1.10/book/box/authentication.rst:67
msgid "Users"
msgstr "Пользователи"

#: ../doc/1.10/book/box/authentication.rst:69
#, fuzzy
msgid ""
"There is a **current user** for any program working with Tarantool, local"
" or remote. If a remote connection is using a :ref:`binary port <admin-"
"security>`, the current user, by default, is '**guest**'. If the "
"connection is using an :ref:`admin-console port <admin-security>`, the "
"current user is '**admin**'. When executing a :ref:`Lua initialization "
"script <index-init_label>`, the current user is also ‘**admin**’."
msgstr ""
"Для любой локальной или удаленной программы, работающей с Tarantool'ом, "
"есть **текущий пользователь**. Если удаленное соединение использует "
":ref:`бинарный порт <admin-security>`, то текущим пользователем, по "
"умолчанию, будет '**guest**' (гость). Если соединение использует "
":ref:`порт для административной консоли <admin-security>`, текущим "
"пользователем будет '**admin**' (администратор). При выполнении "
":ref:`скрипта инициализации на Lua <index-init_label>`, текущим "
"пользователем также будет ‘admin’."

#: ../doc/1.10/book/box/authentication.rst:78
msgid ""
"The current user name can be found with :ref:`box.session.user() "
"<box_session-user>`."
msgstr ""
"Имя текущего пользователя можно узнать с помощью :ref:`box.session.user()"
" <box_session-user>`."

#: ../doc/1.10/book/box/authentication.rst:80
msgid "The current user can be changed:"
msgstr "Текущего пользователя можно изменить:"

#: ../doc/1.10/book/box/authentication.rst:82
msgid ""
"For a binary port connection -- with the :ref:`AUTH protocol command "
"<box_protocol-iproto_protocol>`, supported by most clients;"
msgstr ""
"Для соединения по бинарному порту -- с помощью :ref:`команды протокола "
"AUTH <box_protocol-iproto_protocol>`, которая поддерживается большинством"
" клиентов;"

#: ../doc/1.10/book/box/authentication.rst:86
msgid ""
"For an admin-console connection and in a Lua initialization script -- "
"with :ref:`box.session.su <box_session-su>`;"
msgstr ""
"Для соединения по порту для административной консоли и при выполнении "
"скрипта инициализации на Lua -- с помощью :ref:`box.session.su "
"<box_session-su>`;"

#: ../doc/1.10/book/box/authentication.rst:89
msgid ""
"For a binary-port connection invoking a stored function with the CALL "
"command -- if the :ref:`SETUID <box_schema-func_create>` property is "
"enabled for the function, Tarantool temporarily replaces the current user"
" with the function’s creator, with all the creator's privileges, during "
"function execution."
msgstr ""
"Для соединения по бинарному порту, которое вызывает хранимую функцию с "
"помощью команды CALL -- если для функции включена настройка :ref:`SETUID "
"<box_schema-func_create>`, Tarantool временно заменит текущего "
"пользователя на создателя функции со всеми правами создателя во время "
"выполнения функции."

#: ../doc/1.10/book/box/authentication.rst:98
msgid "Passwords"
msgstr "Пароли"

#: ../doc/1.10/book/box/authentication.rst:100
msgid ""
"Each user (except 'guest') may have a **password**. The password is any "
"alphanumeric string."
msgstr ""
"У каждого пользователя (за исключением гостя 'guest') может быть "
"**пароль**. Паролем является любая буквенно-цифровая строка."

#: ../doc/1.10/book/box/authentication.rst:103
#, python-format
msgid ""
"Tarantool passwords are stored in the :ref:`_user <box_space-user>` "
"system space with a `cryptographic hash function "
"<https://en.wikipedia.org/wiki/Cryptographic_hash_function>`_ so that, if"
" the password is ‘x’, the stored hash-password is a long string like "
"‘lL3OvhkIPOKh+Vn9Avlkx69M/Ck=‘. When a client connects to a Tarantool "
"instance, the instance sends a random `salt value "
"<https://en.wikipedia.org/wiki/Salt_%28cryptography%29>`_ which the "
"client must mix with the hashed-password before sending to the instance. "
"Thus the original value ‘x’ is never stored anywhere except in the user’s"
" head, and the hashed value is never passed down a network wire except "
"when mixed with a random salt."
msgstr ""
"Пароли Tarantool'а хранятся в системном спейсе :ref:`_user <box_space-"
"user>` с `криптографической хеш-функцией "
"<https://ru.wikipedia.org/wiki/%D0%9A%D1%80%D0%B8%D0%BF%D1%82%D0%BE%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D1%85%D0%B5%D1%88-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F>`_,"
" так что если паролем является ‘x’, хранится хеш-пароль в виде длинной "
"строки, например ‘lL3OvhkIPOKh+Vn9Avlkx69M/Ck=‘. Когда клиент "
"подключается к экземпляру Tarantool'а, экземпляр отправляет случайное "
"`значение соль "
"<https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D0%BB%D1%8C_(%D0%BA%D1%80%D0%B8%D0%BF%D1%82%D0%BE%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D1%8F)>`_,"
" которое клиент должен сложить вместе с хеш-паролем перед отправкой на "
"экземпляр. Таким образом, изначальное значение ‘x’ никогда не хранится "
"нигде, кроме как в голове самого пользователя, а хешированное значение "
"никогда не передается по сети, кроме как в смешанном с солью виде."

#: ../doc/1.10/book/box/authentication.rst:117
msgid ""
"For more details of the password hashing algorithm (e.g. for the purpose "
"of writing a new client application), read the `scramble.h "
"<https://github.com/tarantool/tarantool/blob/1.9/src/scramble.h>`_ header"
" file."
msgstr ""
"Для получения дополнительной информации об алгоритме хеширования паролей "
"(например, для написания нового клиентского приложения), прочтите файл "
"заголовка `scramble.h <https://github.com/tarantool/tarantool/blob/1.9/ "
"src/scramble.h>`_."

#: ../doc/1.10/book/box/authentication.rst:122
msgid ""
"This system prevents malicious onlookers from finding passwords by "
"snooping in the log files or snooping on the wire. It is the same system "
"that `MySQL introduced several years ago "
"<http://dev.mysql.com/doc/refman/5.7/en/password-hashing.html>`_, which "
"has proved adequate for medium-security installations. Nevertheless, "
"administrators should warn users that no system is foolproof against "
"determined long-term attacks, so passwords should be guarded and changed "
"occasionally. Administrators should also advise users to choose long "
"unobvious passwords, but it is ultimately up to the users to choose or "
"change their own passwords."
msgstr ""
"Система не дает злоумышленнику определить пароли путем просмотра файлов "
"журнала или слежения за активностью. Это та же система, `несколько лет "
"назад внедренная в MySQL <http://dev.mysql.com/doc/refman/5.7/en"
"/password-hashing.html>`_, которой оказалось достаточно для объектов со "
"средней степенью безопасности. Тем не менее, администраторы должны "
"предупреждать пользователей, что никакая система не защищена полностью от"
" постоянных длительных атак, поэтому пароли следует охранять и "
"периодически изменять. Администраторы также должны рекомендовать "
"пользователям выбирать длинные неочевидные пароли, но сами пользователи "
"выбирают свои пароли и изменяют их."

#: ../doc/1.10/book/box/authentication.rst:132
#, fuzzy
msgid ""
"There are two functions for managing passwords in Tarantool: "
":ref:`box.schema.user.passwd() <box_schema-user_passwd>` for changing a "
"user's password and :ref:`box.schema.user.password() <box_schema-"
"user_password>` for getting a hash of a user's password."
msgstr ""
"Для управления паролями в Tarantool'е есть две функции: "
":ref:`box.schema.user.password() <box_schema-user_password>` для "
"изменения пароля пользователя и :ref:`box.schema.user.passwd() "
"<box_schema-user_passwd>` для получения хеш-пароля."

#: ../doc/1.10/book/box/authentication.rst:141
msgid "Owners and privileges"
msgstr "Владельцы и права"

#: ../doc/1.10/book/box/authentication.rst:143
msgid ""
"Tarantool has one database. It may be called \"box.schema\" or "
"\"universe\". The database contains database objects, including spaces, "
"indexes, users, roles, sequences, and functions."
msgstr ""
"В Tarantool'е одна база данных. Она может называться \"box.schema\" или "
"\"universe\". База данных содержит объекты базы данных, включая спейсы, "
"индексы, пользователей, роли, последовательности и функции."

#: ../doc/1.10/book/box/authentication.rst:147
#, fuzzy
msgid ""
"The **owner** of a database object is the user who created it. The owner "
"of the database itself, and the owner of objects that are created "
"initially (the system spaces and the default users) is '**admin**'."
msgstr ""
"**Владелец** объекта базы данных -- это пользователь, который создал его."
" Владельцем самой базы данных и объектов, которые изначально были "
"созданы, -- системные спейсы и пользователи по умолчанию -- является "
"'admin'."

#: ../doc/1.10/book/box/authentication.rst:152
msgid ""
"Owners automatically have **privileges** for what they create. They can "
"share these privileges with other users or with roles, using "
"**box.schema.user.grant** requests. The following privileges can be "
"granted:"
msgstr ""
"У владельцев автоматически есть **права** на то, что они создают. "
"Владельцы могут поделиться этими правами с другими пользователями или "
"ролями с помощью запросов **box.schema.user.grant**. Можно предоставить "
"следующие права:"

#: ../doc/1.10/book/box/authentication.rst:157
msgid "'read', e.g. allow select from a space"
msgstr "'read' (чтение), например, разрешить выборку из спейса"

#: ../doc/1.10/book/box/authentication.rst:158
msgid "'write', e.g. allow update on a space"
msgstr "'write' (запись), например, разрешить обновление спейса"

#: ../doc/1.10/book/box/authentication.rst:159
msgid ""
"'execute', e.g. allow call of a function, or (less commonly) allow use of"
" a role"
msgstr ""
"'execute' (выполнение), например, разрешить вызов функции, или (реже) "
"разрешить использование роли"

#: ../doc/1.10/book/box/authentication.rst:160
msgid ""
"'create', e.g. allow :ref:`box.schema.space.create <box_schema-"
"space_create>` (access to certain system spaces is also necessary)"
msgstr ""
"'create' (создание), например, разрешить выполнение "
":ref:`box.schema.space.create <box_schema-space_create>` (также необходим"
" доступ к определенным системным спейсам)"

#: ../doc/1.10/book/box/authentication.rst:163
msgid ""
"'alter', e.g. allow :ref:`box.space.x.index.y:alter <box_index-alter>` "
"(access to certain system spaces is also necessary)"
msgstr ""
"'alter' (изменение), например, разрешить выполнение "
":ref:`box.space.x.index.y:alter <box_index-alter>` (также необходим "
"доступ к определенным системным спейсам"

#: ../doc/1.10/book/box/authentication.rst:166
msgid ""
"'drop', e.g. allow :ref:`box.sequence.x:drop <box_schema-sequence_drop>` "
"(currently this can be granted but has no effect)"
msgstr ""
"'drop' (удаление), например, разрешить выполнение "
":ref:`box.sequence.x:drop <box_schema-sequence_drop>` (сейчас можно "
"настроить такие права, но они не действуют)"

#: ../doc/1.10/book/box/authentication.rst:169
msgid ""
"'usage', e.g. whether any action is allowable regardless of other "
"privileges (sometimes revoking 'usage' is a convenient way to block a "
"user temporarily without dropping the user)"
msgstr ""
"'usage' (использование), например, допустимо ли любое действие, несмотря "
"на другие права (иногда удобно отменить право на использование, чтобы "
"временно заблокировать пользователя, не удаляя ег"

#: ../doc/1.10/book/box/authentication.rst:172
msgid "'session', e.g. whether the user can 'connect'."
msgstr ""
"'session' (сессия), например, может ли пользователь выполнить подключение"
" 'connect'."

#: ../doc/1.10/book/box/authentication.rst:174
msgid ""
"To **create** objects, users need the 'create' privilege and at least "
"'read' and 'write' privileges on the system space with a similar name "
"(for example, on the :ref:`_space <box_space-space>` if the user needs to"
" create spaces)."
msgstr ""
"Чтобы **создавать** объекты, у пользователей должны быть права на "
"создание 'create' и хотя бы права на чтение 'read' и запись 'write' в "
"системный спейс с похожим именем (например, на спейс :ref:`_space "
"<box_space-space>`, если пользователю необходимо создавать спейсы."

#: ../doc/1.10/book/box/authentication.rst:179
msgid ""
"To **access** objects, users need an appropriate privilege on the object "
"(for example, the 'execute' privilege on function F if the users need to "
"execute function F). See below some :ref:`examples for granting specific "
"privileges <authentication-owners_privileges-examples-specific>` that a "
"grantor -- that is, 'admin' or the object creator -- can make."
msgstr ""
"Чтобы **получать доступ** к объектам, у пользователей должны быть "
"соответствующие права на объект (например, права на выполнение 'execute' "
"на функцию F, если пользователям необходимо выполнить функцию F). См. "
"ниже некоторые :ref:`примеры предоставления определенных прав "
"<authentication-owners_privileges-examples-specific>`, которые может "
"выдать 'admin' или создатель объекта."

#: ../doc/1.10/book/box/authentication.rst:185
msgid ""
"To **drop** an object, users must be the object's creator or be 'admin'. "
"As the owner of the entire database, 'admin' can drop any object "
"including other users."
msgstr ""
"Чтобы **удалить** объект, пользователь должен быть создателем объекта или"
" 'admin'. Как владелец всей базы данных, 'admin' может удалить любой "
"объект, в том числе других пользователей."

#: ../doc/1.10/book/box/authentication.rst:189
msgid ""
"To grant privileges to a user, the object owner says :ref:`grant() "
"<box_schema-user_grant>`. To revoke privileges from a user, the object "
"owner says :ref:`revoke() <box_schema-user_revoke>`. In either case, "
"there are up to five parameters:"
msgstr ""
"Чтобы предоставить права пользователю, владелец объекта выполняет команду"
" :ref:`grant() <box_schema-user_grant>`. Чтобы отменить права "
"пользователя, владелец объекта выполняет команду :ref:`revoke() "
"<box_schema-user_revoke>`. В любом случае можно использовать до пяти "
"параметров:"

#: ../doc/1.10/book/box/authentication.rst:193
msgid "(user-name, privilege, object-type [, object-name [, options]])"
msgstr "(user-name, privilege, object-type [, object-name [, options]])"

#: ../doc/1.10/book/box/authentication.rst:197
msgid ""
"``user-name`` is the user (or role) that will receive or lose the "
"privilege;"
msgstr ""
"``user-name`` -- это пользователь (или роль), который получит или "
"потеряет права;"

#: ../doc/1.10/book/box/authentication.rst:198
msgid ""
"``privilege`` is any of 'read', 'write', 'execute', 'create', 'alter', "
"'drop', 'usage', or 'session' (or a comma-separated list);"
msgstr ""
"``privilege`` -- это тип прав: 'read', 'write', 'execute', 'create', "
"'alter', 'drop', 'usage' или 'session' (или список прав, разделенных "
"запятыми);"

#: ../doc/1.10/book/box/authentication.rst:200
msgid ""
"``object-type`` is any of 'space', 'index', 'sequence', 'function', role-"
"name, or 'universe';"
msgstr ""
"``object-type`` -- это любой тип объекта: 'space' (спейс), 'index' "
"(индекс), 'sequence' (последовательность), 'function' (функция), имя роли"
" или 'universe';"

#: ../doc/1.10/book/box/authentication.rst:202
msgid ""
"``object-name`` is what the privilege is for (omitted if ``object-type`` "
"is 'universe');"
msgstr ""
"``object-name`` -- это то, на что распространяются права (не указывается,"
" если ``object-type`` = 'universe');"

#: ../doc/1.10/book/box/authentication.rst:204
msgid ""
"``options`` is a list inside braces for example "
"``{if_not_exists=true|false}`` (usually omitted because the default is "
"acceptable)."
msgstr ""
"``options`` -- это список параметров, приведенный в скобках, например, "
"``{if_not_exists=true|false}`` (как правило, не указывается, поскольку "
"допускаются значения по умолчанию)."

#: ../doc/1.10/book/box/authentication.rst:207
msgid "**Example for granting many privileges at once**"
msgstr "**Пример предоставления нескольких типов прав одновременно**"

#: ../doc/1.10/book/box/authentication.rst:209
msgid ""
"In this example user 'admin' grants many privileges on many objects to "
"user 'U', with a single request."
msgstr ""
"В данном примере пользователь 'admin' выдает много типов прав на "
"множество объектов пользователю 'U' в едином запросе."

#: ../doc/1.10/book/box/authentication.rst:212
msgid "box.schema.user.grant('U','read,write,execute,create,drop','universe')"
msgstr "box.schema.user.grant('U','read,write,execute,create,drop','universe')"

#: ../doc/1.10/book/box/authentication.rst:218
msgid "**Examples for granting privileges for specific operations**"
msgstr "**Примеры предоставления прав на определенные действия**"

#: ../doc/1.10/book/box/authentication.rst:220
msgid ""
"In these examples the object's creator grants precisely the minimal "
"privileges necessary for particular operations, to user 'U'."
msgstr ""
"В данных примерах создатель объекта выдает пользователю 'U' минимально "
"необходимые права на определенные действия."

#: ../doc/1.10/book/box/authentication.rst:224
msgid ""
"-- So that 'U' can create spaces:\n"
"  box.schema.user.grant('U','create','universe')\n"
"  box.schema.user.grant('U','write', 'space', '_schema')\n"
"  box.schema.user.grant('U','write', 'space', '_space')\n"
"-- So that 'U' can  create indexes (assuming 'U' created the space)\n"
"  box.schema.user.grant('U','read', 'space', '_space')\n"
"  box.schema.user.grant('U','read,write', 'space', '_index')\n"
"-- So that 'U' can  create indexes on space T (assuming 'U' did not "
"create space T)\n"
"  box.schema.user.grant('U','create','space','T')\n"
"  box.schema.user.grant('U','read', 'space', '_space')\n"
"  box.schema.user.grant('U','write', 'space', '_index')\n"
"-- So that 'U' can  alter indexes on space T (assuming 'U' did not create"
" the index)\n"
"  box.schema.user.grant('U','alter','space','T')\n"
"  box.schema.user.grant('U','read','space','_space')\n"
"  box.schema.user.grant('U','read','space','_index')\n"
"  box.schema.user.grant('U','read','space','_space_sequence')\n"
"  box.schema.user.grant('U','write','space','_index')\n"
"-- So that 'U' can create users or roles:\n"
"  box.schema.user.grant('U','create','universe')\n"
"  box.schema.user.grant('U','read,write', 'space', '_user')\n"
"  box.schema.user.grant('U','write','space', '_priv')\n"
"-- So that 'U' can create sequences:\n"
"  box.schema.user.grant('U','create','universe')\n"
"  box.schema.user.grant('U','read,write','space','_sequence')\n"
"-- So that 'U' can create functions:\n"
"  box.schema.user.grant('U','create','universe')\n"
"  box.schema.user.grant('U','read,write','space','_func')\n"
"-- So that 'U' can grant access on objects that 'U' created\n"
"  box.schema.user.grant('U','read','space','_user')\n"
"-- So that 'U' can select or get from a space named 'T'\n"
"  box.schema.user.grant('U','read','space','T')\n"
"-- So that 'U' can update or insert or delete or truncate a space named "
"'T'\n"
"  box.schema.user.grant('U','write','space','T')\n"
"-- So that 'U' can execute a function named 'F'\n"
"  box.schema.user.grant('U','execute','function','F')\n"
"-- So that 'U' can use the \"S:next()\" function with a sequence named S\n"
"  box.schema.user.grant('U','read,write','sequence','S')\n"
"-- So that 'U' can use the \"S:set()\" or \"S:reset() function with a "
"sequence named S\n"
"  box.schema.user.grant('U','write','sequence','S')"
msgstr ""
"-- Чтобы 'U' мог создавать спейсы:\n"
"   box.schema.user.grant('U','create','universe')\n"
"   box.schema.user.grant('U','write', 'space', '_schema')\n"
"   box.schema.user.grant('U','write', 'space', '_space')\n"
"-- Чтобы 'U' мог создавать индексы (подразумевая, что 'U' создал спейс)\n"
"   box.schema.user.grant('U','read', 'space', '_space')\n"
"   box.schema.user.grant('U','read,write', 'space', '_index')\n"
"-- Чтобы 'U' мог создавать индексы в спейсы T (подразумевая, что 'U' не "
"создал спейс T)\n"
"   box.schema.user.grant('U','create','space','T')\n"
"   box.schema.user.grant('U','read', 'space', '_space')\n"
"   box.schema.user.grant('U','write', 'space', '_index')\n"
"-- Чтобы 'U' мог изменять индексы в спейсе T (подразумевая, что 'U' не "
"создал индекс)\n"
"   box.schema.user.grant('U','alter','space','T')\n"
"   box.schema.user.grant('U','read','space','_space')\n"
"   box.schema.user.grant('U','read','space','_index')\n"
"   box.schema.user.grant('U','read','space','_space_sequence')\n"
"   box.schema.user.grant('U','write','space','_index')\n"
"-- Чтобы 'U' мог создавать пользователей или роли:\n"
"   box.schema.user.grant('U','create','universe')\n"
"   box.schema.user.grant('U','read,write', 'space', '_user')\n"
"   box.schema.user.grant('U','write','space', '_priv')\n"
"-- Чтобы 'U' мог создавать последовательности:\n"
"   box.schema.user.grant('U','create','universe')\n"
"   box.schema.user.grant('U','read,write','space','_sequence')\n"
"-- Чтобы 'U' мог создавать функции:\n"
"   box.schema.user.grant('U','create','universe')\n"
"   box.schema.user.grant('U','read,write','space','_func')\n"
"-- Чтобы 'U' мог выдавать права на созданные им объекты:\n"
"   box.schema.user.grant('U','read','space','_user')\n"
"-- Чтобы 'U' мог производить выборку или получать данные из спейса под "
"названием 'T'\n"
"   box.schema.user.grant('U','read','space','T')\n"
"-- Чтобы 'U' мог производить обновление, вставку, удаление или очистку "
"спейса под названием 'T'\n"
"   box.schema.user.grant('U','write','space','T')\n"
"-- Чтобы 'U' мог выполнять функцию под названием 'F'\n"
"   box.schema.user.grant('U','execute','function','F')\n"
"-- Чтобы 'U' мог использовать функцию \"S:next()\" для последовательности"
" под названием S\n"
"   box.schema.user.grant('U','read,write','sequence','S')\n"
"-- Чтобы 'U' мог использовать функцию \"S:set()\" или \"S:reset()\" для "
"последовательности под названием S\n"
"  box.schema.user.grant('U','write','sequence','S')"

#: ../doc/1.10/book/box/authentication.rst:266
msgid "**Example for creating users and objects then granting privileges**"
msgstr "**Пример создания пользователей и объектов и последующей выдачи прав**"

#: ../doc/1.10/book/box/authentication.rst:268
msgid ""
"Here we create a Lua function that will be executed under the user id of "
"its creator, even if called by another user."
msgstr ""
"Здесь создадим Lua-функциб, которая будет выполняться от ID пользователя,"
" который является ее создателем, даже если она вызывается другим "
"пользователем."

#: ../doc/1.10/book/box/authentication.rst:271
msgid ""
"First, we create two spaces ('u' and 'i') and grant a no-password user "
"('internal') full access to them. Then we define a function "
"('read_and_modify') and the no-password user becomes this function's "
"creator. Finally, we grant another user ('public_user') access to execute"
" Lua functions created by the no-password user."
msgstr ""
"Для начала создадим два спейса ('u' и 'i') и дадим полный доступ к ним "
"пользователю без пароля ('internal'). Затем определим функцию "
"('read_and_modify'), и пользователь без пароля становится создателем "
"функции. Наконец, дадим другому пользователю ('public_user') доступ на "
"выполнение Lua-функций, созданных пользователем без пароля."

#: ../doc/1.10/book/box/authentication.rst:276
msgid ""
"box.schema.space.create('u')\n"
"box.schema.space.create('i')\n"
"box.space.u:create_index('pk')\n"
"box.space.i:create_index('pk')\n"
"\n"
"box.schema.user.create('internal')\n"
"\n"
"box.schema.user.grant('internal', 'read,write', 'space', 'u')\n"
"box.schema.user.grant('internal', 'read,write', 'space', 'i')\n"
"box.schema.user.grant('internal', 'create', 'universe')\n"
"box.schema.user.grant('internal', 'read,write', 'space', '_func')\n"
"\n"
"function read_and_modify(key)\n"
"  local u = box.space.u\n"
"  local i = box.space.i\n"
"  local fiber = require('fiber')\n"
"  local t = u:get{key}\n"
"  if t ~= nil then\n"
"    u:put{key, box.session.uid()}\n"
"    i:put{key, fiber.time()}\n"
"  end\n"
"end\n"
"\n"
"box.session.su('internal')\n"
"box.schema.func.create('read_and_modify', {setuid= true})\n"
"box.session.su('admin')\n"
"box.schema.user.create('public_user', {password = 'secret'})\n"
"box.schema.user.grant('public_user', 'execute', 'function', "
"'read_and_modify')"
msgstr ""
"box.schema.space.create('u')\n"
"box.schema.space.create('i')\n"
"box.space.u:create_index('pk')\n"
"box.space.i:create_index('pk')\n"
"\n"
"box.schema.user.create('internal')\n"
"\n"
"box.schema.user.grant('internal', 'read,write', 'space', 'u')\n"
"box.schema.user.grant('internal', 'read,write', 'space', 'i')\n"
"box.schema.user.grant('internal', 'create', 'universe')\n"
"box.schema.user.grant('internal', 'read,write', 'space', '_func')\n"
"\n"
"function read_and_modify(key)\n"
"  local u = box.space.u\n"
"  local i = box.space.i\n"
"  local fiber = require('fiber')\n"
"  local t = u:get{key}\n"
"  if t ~= nil then\n"
"    u:put{key, box.session.uid()}\n"
"    i:put{key, fiber.time()}\n"
"  end\n"
"end\n"
"\n"
"box.session.su('internal')\n"
"box.schema.func.create('read_and_modify', {setuid= true})\n"
"box.session.su('admin')\n"
"box.schema.user.create('public_user', {password = 'secret'})\n"
"box.schema.user.grant('public_user', 'execute', 'function', "
"'read_and_modify')"

#: ../doc/1.10/book/box/authentication.rst:311
msgid "Roles"
msgstr "Роли"

#: ../doc/1.10/book/box/authentication.rst:313
msgid ""
"A **role** is a container for privileges which can be granted to regular "
"users. Instead of granting or revoking individual privileges, you can put"
" all the privileges in a role and then grant or revoke the role."
msgstr ""
"**Роль** представляет собой контейнер для прав, которые можно "
"предоставить обычным пользователям. Вместо того, чтобы предоставлять или "
"отменять индивидуальные права, можно поместить все права в роль, а затем "
"назначить или отменить роль."

#: ../doc/1.10/book/box/authentication.rst:317
msgid ""
"Role information is stored in the :ref:`_user <box_space-user>` space, "
"but the third field in the tuple -- the type field -- is ‘role’ rather "
"than ‘user’."
msgstr ""
"Информация о роли хранится в спейсе :ref:`_user <box_space-user>`, но "
"третье поле кортежа -- поле типа -- это ‘роль’, а не ‘пользователь’."

#: ../doc/1.10/book/box/authentication.rst:320
msgid ""
"An important feature in role management is that roles can be **nested**. "
"For example, role R1 can be granted a privilege \"role R2\", so users "
"with the role R1 will subsequently get all privileges from both roles R1 "
"and R2. In other words, a user gets all the privileges that are granted "
"to a user’s roles, directly or indirectly."
msgstr ""
"В управлении доступом на основе ролей один из главных моментов -- это то,"
" что роли могут быть **вложенными**. Например, роли R1 можно предоставить"
" право типа \"роль R2\", то есть пользователи с ролью R1 тогда получат "
"все права роли R1 и роли R2. Другими словами, пользователь получает все "
"права, которые предоставляются ролям пользователя напрямую и "
"опосредованно."

#: ../doc/1.10/book/box/authentication.rst:326
msgid ""
"There are actually two ways to grant or revoke a role: "
":samp:`box.schema.user.grant-or-revoke({user-name-or-role-"
"name},'execute', 'role',{role-name}...)` or :samp:`box.schema.user.grant-"
"or-revoke({user-name-or-role-name},{role-name}...)`. The second way is "
"preferable."
msgstr ""
"Фактически есть два способа предоставить или отменить роль: "
":samp:`box.schema.user.grant-or-"
"revoke({имя-пользователя-или-имя-роли},'execute', 'role',{имя-роли}...)` "
"или :samp:`box.schema.user.grant-or-"
"revoke({имя-пользователя-или-имя-роли},{имя-роли}...)`. Рекомендуется "
"использовать второй способ."

#: ../doc/1.10/book/box/authentication.rst:332
msgid "The 'usage' and 'session' privileges cannot be granted to roles."
msgstr "Права типов 'usage' и 'session' нельзя предоставить для роли."

#: ../doc/1.10/book/box/authentication.rst:336
msgid ""
"-- This example will work for a user with many privileges, such as "
"'admin'\n"
"-- or a user with the pre-defined 'super' role\n"
"-- Create space T with a primary index\n"
"box.schema.space.create('T')\n"
"box.space.T:create_index('primary', {})\n"
"-- Create user U1 so that later we can change the current user to U1\n"
"box.schema.user.create('U1')\n"
"-- Create two roles, R1 and R2\n"
"box.schema.role.create('R1')\n"
"box.schema.role.create('R2')\n"
"-- Grant role R2 to role R1 and role R1 to user U1 (order doesn't matter)"
"\n"
"-- There are two ways to grant a role; here we use the shorter way\n"
"box.schema.role.grant('R1', 'R2')\n"
"box.schema.user.grant('U1', 'R1')\n"
"-- Grant read/write privileges for space T to role R2\n"
"-- (but not to role R1 and not to user U1)\n"
"box.schema.role.grant('R2', 'read,write', 'space', 'T')\n"
"-- Change the current user to user U1\n"
"box.session.su('U1')\n"
"-- An insertion to space T will now succeed because, due to nested roles,"
"\n"
"-- user U1 has write privilege on space T\n"
"box.space.T:insert{1}"
msgstr ""
"-- Этот пример сработает для пользователя со множеством прав, например, "
"'admin'\n"
"-- или для пользователя с заданной ролью 'super'\n"
"-- Создать спейс T с первичным индексом\n"
"box.schema.space.create('T')\n"
"box.space.T:create_index('primary', {})\n"
"-- Создать пользователя U1, чтобы затем можно было заменить текущего "
"пользователя на U1\n"
"box.schema.user.create('U1')\n"
"-- Создать две роли, R1 и R2\n"
"box.schema.role.create('R1')\n"
"box.schema.role.create('R2')\n"
"-- Предоставить роль R2 для роли R1, а роль R1 пользователю U1 (порядок "
"не имеет значения)\n"
"-- Есть два способа предоставить роль, здесь используется более короткий "
"способ\n"
"box.schema.role.grant('R1', 'R2')\n"
"box.schema.user.grant('U1', 'R1')\n"
"-- Предоставить права на чтение/запись на спейс T для роли R2\n"
"-- (но не для роли R1 и не пользователю U1)\n"
"box.schema.role.grant('R2', 'read,write', 'space', 'T')\n"
"-- Изменить текущего пользователя на пользователя U1\n"
"box.session.su('U1')\n"
"-- Теперь вставка в спейс T сработает, потому что благодаря вложенным "
"ролям,\n"
"-- у пользователя U1 есть права на запись в спейс T\n"
"box.space.T:insert{1}"

#: ../doc/1.10/book/box/authentication.rst:361
msgid ""
"For more detail see :ref:`box.schema.user.grant() <box_schema-"
"user_grant>` and :ref:`box.schema.role.grant() <box_schema-role_grant>` "
"in the built-in modules reference."
msgstr ""
"Более подробную информацию см. в справочнике по встроенным модулям: "
":ref:`box.schema.user.grant() <box_schema-user_grant>` и "
":ref:`box.schema.role.grant() <box_schema-role_grant>`."

#: ../doc/1.10/book/box/authentication.rst:370
msgid "Sessions and security"
msgstr "Сессии и безопасность"

#: ../doc/1.10/book/box/authentication.rst:372
msgid "A **session** is the state of a connection to Tarantool. It contains:"
msgstr "**Сессия** -- это состояние подключения к Tarantool'у. Она содержит:"

#: ../doc/1.10/book/box/authentication.rst:374
msgid "an integer id identifying the connection,"
msgstr "идентификатор в виде целого числа, определяющий соединение,"

#: ../doc/1.10/book/box/authentication.rst:375
msgid ""
"the :ref:`current user <authentication-users>` associated with the "
"connection,"
msgstr ""
":ref:`текущий пользователь <authentication-users>`, использующий "
"соединение,"

#: ../doc/1.10/book/box/authentication.rst:376
msgid "text description of the connected peer, and"
msgstr "текстовое описание подключенного узла и"

#: ../doc/1.10/book/box/authentication.rst:377
msgid "session local state, such as Lua variables and functions."
msgstr "локальное состояние сессии, например, переменные и функции на Lua."

#: ../doc/1.10/book/box/authentication.rst:379
msgid ""
"In Tarantool, a single session can execute multiple concurrent "
"transactions. Each transaction is identified by a unique integer id, "
"which can be queried at start of the transaction using "
":ref:`box.session.sync() <box_session-sync>`."
msgstr ""
"В Tarantool'е отдельная сессия может выполнять несколько транзакций "
"одновременно. Каждая транзакция определяется по уникальному "
"идентификатору в виде целого числа, который можно запросить в начале "
"транзакции с помощью :ref:`box.session.sync() <box_session-sync>`."

#: ../doc/1.10/book/box/authentication.rst:385
msgid ""
"To track all connects and disconnects, you can use :ref:`connection and "
"authentication triggers <triggers>`."
msgstr ""
"Чтобы отследить все подключения и отключения, можно использовать "
":ref:`триггеры соединений и аутентификации <triggers>`."

#: ../doc/1.10/book/box/box_cfg.rst:39
msgid "Submodule `box.cfg`"
msgstr "Вложенный модуль `box.cfg`"

#: ../doc/1.10/book/box/box_cfg.rst:43
msgid ""
"The ``box.cfg`` submodule is for administrators to specify all the "
":ref:`server configuration parameters <box_cfg_params>`."
msgstr ""
"Вложенный модуль ``box.cfg`` предназначен для системных администраторов, "
"чтобы указать все :ref:`параметры конфигурации сервера <box_cfg_params>`."

#: ../doc/1.10/book/box/box_cfg.rst:46
msgid ""
"Say ``box.cfg`` without braces to view the current configuration, for "
"example:"
msgstr ""
"Введите команду ``box.cfg`` без фигурных скобок для просмотра текущей "
"конфигурации, например:"

#: ../doc/1.10/book/box/box_cfg.rst:48
msgid ""
"tarantool> box.cfg\n"
"---\n"
"- checkpoint_count: 2\n"
"  too_long_threshold: 0.5\n"
"  slab_alloc_factor: 1.1\n"
"  memtx_max_tuple_size: 1048576\n"
"  background: false\n"
"  <...>\n"
"..."
msgstr ""
"tarantool> box.cfg\n"
" ---\n"
" - checkpoint_count: 2\n"
"   too_long_threshold: 0.5\n"
"   slab_alloc_factor: 1.1\n"
"   memtx_max_tuple_size: 1048576\n"
"   background: false\n"
"   <...>\n"
" ..."

#: ../doc/1.10/book/box/box_cfg.rst:60
msgid "To set the parameters, say ``box.cfg{...}``, for example:"
msgstr "Чтобы установить параметры, введите команду ``box.cfg{...}``, например:"

#: ../doc/1.10/book/box/box_cfg.rst:62
#: ../doc/1.10/book/getting_started/using_binary.rst:125
msgid "tarantool> box.cfg{listen = 3301}"
msgstr "tarantool> box.cfg{listen = 3301}"

#: ../doc/1.10/book/box/box_cfg.rst:66
msgid ""
"If you say ``box.cfg{}`` with no parameters, Tarantool applies default "
"settings:"
msgstr ""
"Если ввести ``box.cfg{}`` без параметров, Tarantool применит настройки по"
" умолчанию:"

#: ../doc/1.10/book/box/box_cfg.rst:68
msgid ""
"tarantool> box.cfg{}\n"
"tarantool> box.cfg -- sorted in the alphabetic order\n"
"---\n"
"- background                   = false\n"
"  checkpoint_count             = 2\n"
"  checkpoint_interval          = 3600\n"
"  coredump                     = false\n"
"  custom_proc_title            = nil\n"
"  feedback_enabled             = true\n"
"  feedback_host                = 'https://feedback.tarantool.io'\n"
"  feedback_interval            = 3600\n"
"  force_recovery               = false\n"
"  hot_standby                  = false\n"
"  io_collect_interval          = nil\n"
"  listen                       = nil\n"
"  log                          = nil\n"
"  log_format                   = plain\n"
"  log_level                    = 5\n"
"  log_nonblock                 = true\n"
"  memtx_dir                    = '.'\n"
"  memtx_max_tuple_size         = 1024 * 1024\n"
"  memtx_memory                 = 256 * 1024 *1024\n"
"  memtx_min_tuple_size         = 16\n"
"  net_msg_max                  = 768\n"
"  pid_file                     = nil\n"
"  readahead                    = 16320\n"
"  read_only                    = false\n"
"  replication                  = nil\n"
"  replication_connect_timeout  = 4\n"
"  replication_skip_conflict    = false\n"
"  replication_sync_lag         = 10\n"
"  replication_sync_timeout     = 300\n"
"  replication_timeout          = 1\n"
"  rows_per_wal                 = 500000\n"
"  slab_alloc_factor            = 1.05\n"
"  snap_io_rate_limit           = nil\n"
"  too_long_threshold           = 0.5\n"
"  username                     = nil\n"
"  vinyl_bloom_fpr              = 0.05\n"
"  vinyl_cache                  = 128\n"
"  vinyl_dir                    = '.'\n"
"  vinyl_max_tuple_size         = 1024 * 1024* 1024 * 1024\n"
"  vinyl_memory                 = 128 * 1024 * 1024\n"
"  vinyl_page_size              = 8 * 1024\n"
"  vinyl_range_size             = nil\n"
"  vinyl_read_threads           = 1\n"
"  vinyl_run_count_per_level    = 2\n"
"  vinyl_run_size_ratio         = 3.5\n"
"  vinyl_timeout                = 60\n"
"  vinyl_write_threads          = 2\n"
"  wal_dir                      = '.'\n"
"  wal_dir_rescan_delay         = 2\n"
"  wal_max_size                 = 256 * 1024 * 1024\n"
"  wal_mode                     = 'write'\n"
"  worker_pool_threads          = 4\n"
"  work_dir                     = nil"
msgstr ""
"tarantool> box.cfg{}\n"
"tarantool> box.cfg -- сортировка в алфавитном порядке\n"
"---\n"
"- background                   = false\n"
"  checkpoint_count             = 2\n"
"  checkpoint_interval          = 3600\n"
"  coredump                     = false\n"
"  custom_proc_title            = nil\n"
"  feedback_enabled             = true\n"
"  feedback_host                = 'https://feedback.tarantool.io'\n"
"  feedback_interval            = 3600\n"
"  force_recovery               = false\n"
"  hot_standby                  = false\n"
"  io_collect_interval          = nil\n"
"  listen                       = nil\n"
"  log                          = nil\n"
"  log_format                   = plain\n"
"  log_level                    = 5\n"
"  log_nonblock                 = true\n"
"  memtx_dir                    = '.'\n"
"  memtx_max_tuple_size         = 1024 * 1024\n"
"  memtx_memory                 = 256 * 1024 *1024\n"
"  memtx_min_tuple_size         = 16\n"
"  net_msg_max                  = 768\n"
"  pid_file                     = nil\n"
"  readahead                    = 16320\n"
"  read_only                    = false\n"
"  replication                  = nil\n"
"  replication_connect_timeout  = 4\n"
"  replication_skip_conflict    = false\n"
"  replication_sync_lag         = 10\n"
"  replication_sync_timeout     = 300\n"
"  replication_timeout          = 1\n"
"  rows_per_wal                 = 500000\n"
"  slab_alloc_factor            = 1.05\n"
"  snap_io_rate_limit           = nil\n"
"  too_long_threshold           = 0.5\n"
"  username                     = nil\n"
"  vinyl_bloom_fpr              = 0.05\n"
"  vinyl_cache                  = 128\n"
"  vinyl_dir                    = '.'\n"
"  vinyl_max_tuple_size         = 1024 * 1024* 1024 * 1024\n"
"  vinyl_memory                 = 128 * 1024 * 1024\n"
"  vinyl_page_size              = 8 * 1024\n"
"  vinyl_range_size             = nil\n"
"  vinyl_read_threads           = 1\n"
"  vinyl_run_count_per_level    = 2\n"
"  vinyl_run_size_ratio         = 3.5\n"
"  vinyl_timeout                = 60\n"
"  vinyl_write_threads          = 2\n"
"  wal_dir                      = '.'\n"
"  wal_dir_rescan_delay         = 2\n"
"  wal_max_size                 = 256 * 1024 * 1024\n"
"  wal_mode                     = 'write'\n"
"  worker_pool_threads          = 4\n"
"  work_dir                     = nil"

#: ../doc/1.10/book/box/box_cfg.rst:127
msgid ""
"The first call to ``box.cfg{...}`` (with or without parameters) initiates"
" Tarantool's database module :ref:`box <box-module>`. To perform any "
"database operations, you must call ``box.cfg{...}`` first."
msgstr ""
"Первый вызов ``box.cfg{...}`` (с параметрами или без них) запускает "
"модуль базы данных Tarantool'а под названием :ref:`box <box-module>`. "
"Чтобы выполнить любые операции с базой данных, необходимо сначала вызвать"
" ``box.cfg{...}``."

#: ../doc/1.10/book/box/box_cfg.rst:131
msgid ""
"``box.cfg{...}`` is also the command that reloads :ref:`persistent data "
"files <index-box_persistence>` into RAM upon restart once we have data."
msgstr ""
"Команда ``box.cfg{...}`` также перезагружает :ref:`файлы с данными "
"длительного хранения <index-box_persistence>` в оперативную память при "
"перезапуске после получения данных."

#: ../doc/1.10/book/box/box_ctl.rst:39
msgid "Submodule `box.ctl`"
msgstr "Вложенный модуль `box.ctl`"

#: ../doc/1.10/book/box/box_ctl.rst:43
msgid ""
"The ``box.ctl`` submodule contains two functions: ``wait_ro`` (wait until"
" read-only) and ``wait_rw`` (wait until read-write). The functions are "
"useful during initialization of a server."
msgstr ""
"Вложенный модуль ``box.ctl`` включает в себя две функции: ``wait_ro`` "
"(дождаться режима только для чтения) и ``wait_rw`` (дождаться режима "
"чтения и записи). Эти функции используются во время инициализации "
"сервера."

#: ../doc/1.10/book/box/box_ctl.rst:48
msgid ""
"A particular use is for :ref:`box_once() <box-once>`. For example, when a"
" replica is initializing, it may call a ``box.once()`` function while the"
" server is still in read-only mode, and fail to make changes that are "
"necessary only once before the replica is fully initialized. This could "
"cause conflicts between a master and a replica if the master is in read-"
"write mode and the replica is in read-only mode. Waiting until \"read "
"only mode = false\" solves this problem."
msgstr ""
"Для :ref:`box_once() <box-once>` есть особое предназначение. Например, "
"при инициализации реплика может вызвать функцию ``box.once()``, пока "
"сервер все еще находится в режиме только для чтения, и не сможет "
"применить изменения однократно до окончательной инициализации реплики. "
"Это может привести к конфликту между мастером и репликой, если мастер "
"находится в режиме чтения и записи, а реплика доступна только для чтения."
" Ожидание условия \"read only mode = false\" (режим только для чтения "
"отключен) решает эту проблему."

#: ../doc/1.10/book/box/box_ctl.rst:58
msgid ""
"To see whether a function is already in read-only or read-write mode, "
"check :ref:`box.info.ro <box_introspection-box_info>`."
msgstr ""
"Чтобы проверить режим функции -- только для чтения или чтение и запись, "
"используйте :ref:`box.info.ro <box_introspection-box_info>`."

#: ../doc/1.10/book/box/box_ctl.rst:65
msgid "Wait until ``box.info.ro`` is true."
msgstr "Дождаться, пока не будет выполнено ``box.info.ro``."

#: ../doc/1.10/book/box/box_ctl.rst ../doc/1.10/book/box/box_index.rst
#: ../doc/1.10/book/box/box_schema.rst ../doc/1.10/book/box/box_session.rst
#: ../doc/1.10/book/box/box_space.rst ../doc/1.10/book/box/box_tuple.rst
#: ../doc/1.10/book/box/box_txn_management.rst
#: ../doc/1.10/dev_guide/documentation_guidelines.rst
#: ../doc/1.10/dev_guide/reference_capi/box.rst
#: ../doc/1.10/dev_guide/reference_capi/box_index.rst
#: ../doc/1.10/dev_guide/reference_capi/coio.rst
#: ../doc/1.10/dev_guide/reference_capi/error.rst
#: ../doc/1.10/dev_guide/reference_capi/fiber.rst
#: ../doc/1.10/dev_guide/reference_capi/latch.rst
#: ../doc/1.10/dev_guide/reference_capi/say.rst
#: ../doc/1.10/dev_guide/reference_capi/tuple.rst
#: ../doc/1.10/dev_guide/reference_capi/utils.rst
#: ../doc/1.10/reference/reference_lua/box_error.rst
#: ../doc/1.10/reference/reference_lua/box_once.rst
#: ../doc/1.10/reference/reference_lua/clock.rst
#: ../doc/1.10/reference/reference_lua/console.rst
#: ../doc/1.10/reference/reference_lua/csv.rst
#: ../doc/1.10/reference/reference_lua/debug_facilities.rst
#: ../doc/1.10/reference/reference_lua/errno.rst
#: ../doc/1.10/reference/reference_lua/fiber.rst
#: ../doc/1.10/reference/reference_lua/fio.rst
#: ../doc/1.10/reference/reference_lua/http.rst
#: ../doc/1.10/reference/reference_lua/iconv.rst
#: ../doc/1.10/reference/reference_lua/json.rst
#: ../doc/1.10/reference/reference_lua/log.rst
#: ../doc/1.10/reference/reference_lua/msgpack.rst
#: ../doc/1.10/reference/reference_lua/net_box.rst
#: ../doc/1.10/reference/reference_lua/osmodule.rst
#: ../doc/1.10/reference/reference_lua/other.rst
#: ../doc/1.10/reference/reference_lua/pickle.rst
#: ../doc/1.10/reference/reference_lua/socket.rst
#: ../doc/1.10/reference/reference_lua/string.rst
#: ../doc/1.10/reference/reference_lua/table.rst
#: ../doc/1.10/reference/reference_lua/tap.rst
#: ../doc/1.10/reference/reference_lua/uri.rst
#: ../doc/1.10/reference/reference_lua/utf8.rst
#: ../doc/1.10/reference/reference_lua/uuid.rst
#: ../doc/1.10/reference/reference_lua/yaml.rst
#: ../doc/1.10/reference/reference_rock/vshard/index.rst
msgid "Parameters"
msgstr "Параметры"

#: ../doc/1.10/book/box/box_ctl.rst:67 ../doc/1.10/book/box/box_ctl.rst:90
msgid "maximum number of seconds to wait"
msgstr "максимальное количество секунд ожидания"

#: ../doc/1.10/book/box/box_ctl.rst ../doc/1.10/book/box/box_index.rst
#: ../doc/1.10/book/box/box_info.rst ../doc/1.10/book/box/box_schema.rst
#: ../doc/1.10/book/box/box_session.rst ../doc/1.10/book/box/box_slab.rst
#: ../doc/1.10/book/box/box_space.rst ../doc/1.10/book/box/box_tuple.rst
#: ../doc/1.10/book/box/box_txn_management.rst
#: ../doc/1.10/dev_guide/documentation_guidelines.rst
#: ../doc/1.10/reference/reference_lua/buffer.rst
#: ../doc/1.10/reference/reference_lua/clock.rst
#: ../doc/1.10/reference/reference_lua/console.rst
#: ../doc/1.10/reference/reference_lua/csv.rst
#: ../doc/1.10/reference/reference_lua/debug_facilities.rst
#: ../doc/1.10/reference/reference_lua/fiber.rst
#: ../doc/1.10/reference/reference_lua/fio.rst
#: ../doc/1.10/reference/reference_lua/http.rst
#: ../doc/1.10/reference/reference_lua/iconv.rst
#: ../doc/1.10/reference/reference_lua/json.rst
#: ../doc/1.10/reference/reference_lua/log.rst
#: ../doc/1.10/reference/reference_lua/msgpack.rst
#: ../doc/1.10/reference/reference_lua/net_box.rst
#: ../doc/1.10/reference/reference_lua/other.rst
#: ../doc/1.10/reference/reference_lua/pickle.rst
#: ../doc/1.10/reference/reference_lua/socket.rst
#: ../doc/1.10/reference/reference_lua/tap.rst
#: ../doc/1.10/reference/reference_lua/uri.rst
#: ../doc/1.10/reference/reference_lua/utf8.rst
#: ../doc/1.10/reference/reference_lua/uuid.rst
#: ../doc/1.10/reference/reference_lua/yaml.rst
#: ../doc/1.10/reference/reference_rock/vshard/index.rst
msgid "return"
msgstr "возвращается"

#: ../doc/1.10/book/box/box_ctl.rst:68 ../doc/1.10/book/box/box_ctl.rst:91
msgid "nil, or error may be thrown due to timeout or fiber cancellation"
msgstr ""
"нулевое значение nil или ошибка, которая может возникнуть из-за "
"превышения времени ожидания или прерывания работы файбера"

#: ../doc/1.10/book/box/box_ctl.rst:70 ../doc/1.10/book/box/box_ctl.rst:94
#: ../doc/1.10/book/box/box_index.rst:151
#: ../doc/1.10/book/box/box_index.rst:537
#: ../doc/1.10/book/box/box_index.rst:677
#: ../doc/1.10/book/box/box_index.rst:707
#: ../doc/1.10/book/box/box_index.rst:737
#: ../doc/1.10/book/box/box_index.rst:766
#: ../doc/1.10/book/box/box_index.rst:790
#: ../doc/1.10/book/box/box_index.rst:873
#: ../doc/1.10/book/box/box_index.rst:903
#: ../doc/1.10/book/box/box_index.rst:925
#: ../doc/1.10/book/box/box_index.rst:1023
#: ../doc/1.10/book/box/box_index.rst:1036
#: ../doc/1.10/book/box/box_info.rst:233
#: ../doc/1.10/book/box/box_schema.rst:314
#: ../doc/1.10/book/box/box_schema.rst:352
#: ../doc/1.10/book/box/box_schema.rst:386
#: ../doc/1.10/book/box/box_schema.rst:425
#: ../doc/1.10/book/box/box_schema.rst:447
#: ../doc/1.10/book/box/box_schema.rst:469
#: ../doc/1.10/book/box/box_schema.rst:492
#: ../doc/1.10/book/box/box_schema.rst:511
#: ../doc/1.10/book/box/box_schema.rst:526
#: ../doc/1.10/book/box/box_schema.rst:557
#: ../doc/1.10/book/box/box_schema.rst:588
#: ../doc/1.10/book/box/box_schema.rst:605
#: ../doc/1.10/book/box/box_schema.rst:642
#: ../doc/1.10/book/box/box_schema.rst:663
#: ../doc/1.10/book/box/box_schema.rst:679
#: ../doc/1.10/book/box/box_schema.rst:704
#: ../doc/1.10/book/box/box_schema.rst:849 ../doc/1.10/book/box/box_slab.rst:89
#: ../doc/1.10/book/box/box_slab.rst:148 ../doc/1.10/book/box/box_slab.rst:190
#: ../doc/1.10/book/box/box_space.rst:221
#: ../doc/1.10/book/box/box_space.rst:247
#: ../doc/1.10/book/box/box_space.rst:273
#: ../doc/1.10/book/box/box_space.rst:544
#: ../doc/1.10/book/box/box_space.rst:581
#: ../doc/1.10/book/box/box_space.rst:656
#: ../doc/1.10/book/box/box_space.rst:755
#: ../doc/1.10/book/box/box_space.rst:804
#: ../doc/1.10/book/box/box_space.rst:846
#: ../doc/1.10/book/box/box_space.rst:873
#: ../doc/1.10/book/box/box_space.rst:1034
#: ../doc/1.10/book/box/box_space.rst:1082
#: ../doc/1.10/book/box/box_space.rst:1125
#: ../doc/1.10/book/box/box_space.rst:1161
#: ../doc/1.10/book/box/box_space.rst:1182
#: ../doc/1.10/book/box/box_space.rst:1232
#: ../doc/1.10/book/box/box_space.rst:1320
#: ../doc/1.10/book/box/box_space.rst:1397
#: ../doc/1.10/book/box/box_space.rst:1509
#: ../doc/1.10/book/box/box_space.rst:1545
#: ../doc/1.10/book/box/box_space.rst:1583
#: ../doc/1.10/book/box/box_space.rst:1601
#: ../doc/1.10/book/box/box_space.rst:1622
#: ../doc/1.10/book/box/box_space.rst:1677
#: ../doc/1.10/book/box/box_space.rst:1837
#: ../doc/1.10/book/box/box_space.rst:2112
#: ../doc/1.10/book/box/box_tuple.rst:129
#: ../doc/1.10/book/box/box_txn_management.rst:182
#: ../doc/1.10/dev_guide/documentation_guidelines.rst:245
#: ../doc/1.10/dev_guide/documentation_guidelines.rst:283
#: ../doc/1.10/dev_guide/reference_capi/coio.rst:80
#: ../doc/1.10/dev_guide/reference_capi/say.rst:86
#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:275
#: ../doc/1.10/reference/reference_lua/box_error.rst:114
#: ../doc/1.10/reference/reference_lua/box_error.rst:154
#: ../doc/1.10/reference/reference_lua/box_error.rst:194
#: ../doc/1.10/reference/reference_lua/box_snapshot.rst:83
#: ../doc/1.10/reference/reference_lua/buffer.rst:57
#: ../doc/1.10/reference/reference_lua/clock.rst:112
#: ../doc/1.10/reference/reference_lua/clock.rst:137
#: ../doc/1.10/reference/reference_lua/clock.rst:158
#: ../doc/1.10/reference/reference_lua/clock.rst:179
#: ../doc/1.10/reference/reference_lua/clock.rst:201
#: ../doc/1.10/reference/reference_lua/console.rst:113
#: ../doc/1.10/reference/reference_lua/console.rst:144
#: ../doc/1.10/reference/reference_lua/console.rst:169
#: ../doc/1.10/reference/reference_lua/console.rst:208
#: ../doc/1.10/reference/reference_lua/crypto.rst:102
#: ../doc/1.10/reference/reference_lua/crypto.rst:134
#: ../doc/1.10/reference/reference_lua/csv.rst:111
#: ../doc/1.10/reference/reference_lua/csv.rst:193
#: ../doc/1.10/reference/reference_lua/csv.rst:238
#: ../doc/1.10/reference/reference_lua/errno.rst:94
#: ../doc/1.10/reference/reference_lua/fiber.rst:235
#: ../doc/1.10/reference/reference_lua/fiber.rst:274
#: ../doc/1.10/reference/reference_lua/fiber.rst:297
#: ../doc/1.10/reference/reference_lua/fiber.rst:317
#: ../doc/1.10/reference/reference_lua/fiber.rst:337
#: ../doc/1.10/reference/reference_lua/fiber.rst:352
#: ../doc/1.10/reference/reference_lua/fiber.rst:371
#: ../doc/1.10/reference/reference_lua/fiber.rst:390
#: ../doc/1.10/reference/reference_lua/fiber.rst:417
#: ../doc/1.10/reference/reference_lua/fiber.rst:443
#: ../doc/1.10/reference/reference_lua/fiber.rst:467
#: ../doc/1.10/reference/reference_lua/fiber.rst:492
#: ../doc/1.10/reference/reference_lua/fiber.rst:519
#: ../doc/1.10/reference/reference_lua/fiber.rst:542
#: ../doc/1.10/reference/reference_lua/fiber.rst:568
#: ../doc/1.10/reference/reference_lua/fiber.rst:588
#: ../doc/1.10/reference/reference_lua/fiber.rst:656
#: ../doc/1.10/reference/reference_lua/fiber.rst:706
#: ../doc/1.10/reference/reference_lua/fiber.rst:739
#: ../doc/1.10/reference/reference_lua/fiber.rst:758
#: ../doc/1.10/reference/reference_lua/fio.rst:215
#: ../doc/1.10/reference/reference_lua/fio.rst:237
#: ../doc/1.10/reference/reference_lua/fio.rst:257
#: ../doc/1.10/reference/reference_lua/fio.rst:276
#: ../doc/1.10/reference/reference_lua/fio.rst:352
#: ../doc/1.10/reference/reference_lua/fio.rst:388
#: ../doc/1.10/reference/reference_lua/fio.rst:427
#: ../doc/1.10/reference/reference_lua/fio.rst:447
#: ../doc/1.10/reference/reference_lua/fio.rst:468
#: ../doc/1.10/reference/reference_lua/fio.rst:491
#: ../doc/1.10/reference/reference_lua/fio.rst:508
#: ../doc/1.10/reference/reference_lua/fio.rst:523
#: ../doc/1.10/reference/reference_lua/fio.rst:547
#: ../doc/1.10/reference/reference_lua/fio.rst:569
#: ../doc/1.10/reference/reference_lua/fio.rst:592
#: ../doc/1.10/reference/reference_lua/fio.rst:618
#: ../doc/1.10/reference/reference_lua/fio.rst:644
#: ../doc/1.10/reference/reference_lua/fio.rst:667
#: ../doc/1.10/reference/reference_lua/fio.rst:689
#: ../doc/1.10/reference/reference_lua/fio.rst:715
#: ../doc/1.10/reference/reference_lua/fio.rst:733
#: ../doc/1.10/reference/reference_lua/fio.rst:834
#: ../doc/1.10/reference/reference_lua/fio.rst:865
#: ../doc/1.10/reference/reference_lua/fio.rst:985
#: ../doc/1.10/reference/reference_lua/fio.rst:1005
#: ../doc/1.10/reference/reference_lua/fio.rst:1030
#: ../doc/1.10/reference/reference_lua/fio.rst:1051
#: ../doc/1.10/reference/reference_lua/fio.rst:1084
#: ../doc/1.10/reference/reference_lua/fio.rst:1106
#: ../doc/1.10/reference/reference_lua/http.rst:86
#: ../doc/1.10/reference/reference_lua/iconv.rst:91
#: ../doc/1.10/reference/reference_lua/iconv.rst:112
#: ../doc/1.10/reference/reference_lua/json.rst:85
#: ../doc/1.10/reference/reference_lua/json.rst:123
#: ../doc/1.10/reference/reference_lua/json.rst:154
#: ../doc/1.10/reference/reference_lua/net_box.rst:265
#: ../doc/1.10/reference/reference_lua/net_box.rst:281
#: ../doc/1.10/reference/reference_lua/net_box.rst:296
#: ../doc/1.10/reference/reference_lua/net_box.rst:337
#: ../doc/1.10/reference/reference_lua/net_box.rst:350
#: ../doc/1.10/reference/reference_lua/net_box.rst:372
#: ../doc/1.10/reference/reference_lua/net_box.rst:385
#: ../doc/1.10/reference/reference_lua/net_box.rst:398
#: ../doc/1.10/reference/reference_lua/net_box.rst:411
#: ../doc/1.10/reference/reference_lua/net_box.rst:507
#: ../doc/1.10/reference/reference_lua/net_box.rst:559
#: ../doc/1.10/reference/reference_lua/osmodule.rst:122
#: ../doc/1.10/reference/reference_lua/osmodule.rst:145
#: ../doc/1.10/reference/reference_lua/osmodule.rst:164
#: ../doc/1.10/reference/reference_lua/osmodule.rst:181
#: ../doc/1.10/reference/reference_lua/osmodule.rst:199
#: ../doc/1.10/reference/reference_lua/osmodule.rst:214
#: ../doc/1.10/reference/reference_lua/osmodule.rst:227
#: ../doc/1.10/reference/reference_lua/osmodule.rst:242
#: ../doc/1.10/reference/reference_lua/osmodule.rst:257
#: ../doc/1.10/reference/reference_lua/osmodule.rst:272
#: ../doc/1.10/reference/reference_lua/osmodule.rst:287
#: ../doc/1.10/reference/reference_lua/osmodule.rst:303
#: ../doc/1.10/reference/reference_lua/osmodule.rst:318
#: ../doc/1.10/reference/reference_lua/other.rst:72
#: ../doc/1.10/reference/reference_lua/other.rst:112
#: ../doc/1.10/reference/reference_lua/pickle.rst:125
#: ../doc/1.10/reference/reference_lua/pickle.rst:172
#: ../doc/1.10/reference/reference_lua/socket.rst:172
#: ../doc/1.10/reference/reference_lua/socket.rst:190
#: ../doc/1.10/reference/reference_lua/socket.rst:209
#: ../doc/1.10/reference/reference_lua/socket.rst:291
#: ../doc/1.10/reference/reference_lua/socket.rst:450
#: ../doc/1.10/reference/reference_lua/strict.rst:52
#: ../doc/1.10/reference/reference_lua/string.rst:106
#: ../doc/1.10/reference/reference_lua/string.rst:131
#: ../doc/1.10/reference/reference_lua/string.rst:154
#: ../doc/1.10/reference/reference_lua/string.rst:184
#: ../doc/1.10/reference/reference_lua/string.rst:214
#: ../doc/1.10/reference/reference_lua/string.rst:238
#: ../doc/1.10/reference/reference_lua/string.rst:261
#: ../doc/1.10/reference/reference_lua/string.rst:288
#: ../doc/1.10/reference/reference_lua/string.rst:312
#: ../doc/1.10/reference/reference_lua/table.rst:78
#: ../doc/1.10/reference/reference_lua/tap.rst:213
#: ../doc/1.10/reference/reference_lua/tap.rst:259
#: ../doc/1.10/reference/reference_lua/tarantool.rst:54
#: ../doc/1.10/reference/reference_lua/uri.rst:99
#: ../doc/1.10/reference/reference_lua/uri.rst:126
#: ../doc/1.10/reference/reference_lua/utf8.rst:108
#: ../doc/1.10/reference/reference_lua/utf8.rst:137
#: ../doc/1.10/reference/reference_lua/utf8.rst:166
#: ../doc/1.10/reference/reference_lua/utf8.rst:190
#: ../doc/1.10/reference/reference_lua/utf8.rst:212
#: ../doc/1.10/reference/reference_lua/utf8.rst:234
#: ../doc/1.10/reference/reference_lua/utf8.rst:256
#: ../doc/1.10/reference/reference_lua/utf8.rst:288
#: ../doc/1.10/reference/reference_lua/utf8.rst:312
#: ../doc/1.10/reference/reference_lua/utf8.rst:333
#: ../doc/1.10/reference/reference_lua/utf8.rst:371
#: ../doc/1.10/reference/reference_lua/utf8.rst:393
#: ../doc/1.10/reference/reference_lua/xlog.rst:61
#: ../doc/1.10/reference/reference_rock/dbms.rst:222
#: ../doc/1.10/reference/reference_rock/dbms.rst:246
#: ../doc/1.10/reference/reference_rock/dbms.rst:270
#: ../doc/1.10/reference/reference_rock/dbms.rst:564
#: ../doc/1.10/reference/reference_rock/dbms.rst:588
#: ../doc/1.10/reference/reference_rock/dbms.rst:611
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1090
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1161
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1459
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1474
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1491
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1552
msgid "**Example:**"
msgstr "**Пример:**"

#: ../doc/1.10/book/box/box_ctl.rst:72
msgid ""
"tarantool> box.info().ro\n"
"---\n"
"- false\n"
"...\n"
"\n"
"tarantool> n = box.ctl.wait_ro(0.1)\n"
"---\n"
"- error: timed out\n"
"..."
msgstr ""
"tarantool> box.info().ro\n"
"---\n"
"- false\n"
"...\n"
"\n"
"tarantool> n = box.ctl.wait_ro(0.1)\n"
"---\n"
"- error: timed out\n"
"..."

#: ../doc/1.10/book/box/box_ctl.rst:88
msgid "Wait until box.info.ro is false."
msgstr "Дождаться, пока не перестанет соблюдаться box.info.ro."

#: ../doc/1.10/book/box/box_ctl.rst:96
msgid ""
"tarantool> box.ctl.wait_rw(0.1)\n"
"---\n"
"..."
msgstr ""
"tarantool> box.ctl.wait_rw(0.1)\n"
"---\n"
"..."

#: ../doc/1.10/book/box/box_index.rst:39
msgid "Submodule `box.index`"
msgstr "Вложенный модуль `box.index`"

#: ../doc/1.10/book/box/box_index.rst:43 ../doc/1.10/book/box/box_schema.rst:45
#: ../doc/1.10/book/box/box_session.rst:43 ../doc/1.10/book/box/box_slab.rst:45
#: ../doc/1.10/book/box/box_space.rst:43 ../doc/1.10/book/box/box_tuple.rst:45
#: ../doc/1.10/book/box/box_txn_management.rst:43 ../doc/1.10/intro.rst:37
#: ../doc/1.10/reference/reference_lua/box_error.rst:43
#: ../doc/1.10/reference/reference_lua/clock.rst:43
#: ../doc/1.10/reference/reference_lua/console.rst:43
#: ../doc/1.10/reference/reference_lua/crypto.rst:45
#: ../doc/1.10/reference/reference_lua/csv.rst:43
#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:43
#: ../doc/1.10/reference/reference_lua/digest.rst:45
#: ../doc/1.10/reference/reference_lua/errno.rst:45
#: ../doc/1.10/reference/reference_lua/fiber.rst:43
#: ../doc/1.10/reference/reference_lua/fio.rst:45
#: ../doc/1.10/reference/reference_lua/http.rst:45
#: ../doc/1.10/reference/reference_lua/iconv.rst:45
#: ../doc/1.10/reference/reference_lua/json.rst:43
#: ../doc/1.10/reference/reference_lua/log.rst:45
#: ../doc/1.10/reference/reference_lua/msgpack.rst:43
#: ../doc/1.10/reference/reference_lua/net_box.rst:43
#: ../doc/1.10/reference/reference_lua/osmodule.rst:45
#: ../doc/1.10/reference/reference_lua/socket.rst:43
#: ../doc/1.10/reference/reference_lua/string.rst:43
#: ../doc/1.10/reference/reference_lua/tap.rst:41
#: ../doc/1.10/reference/reference_lua/uri.rst:41
#: ../doc/1.10/reference/reference_lua/utf8.rst:43
#: ../doc/1.10/reference/reference_lua/uuid.rst:41
#: ../doc/1.10/reference/reference_lua/yaml.rst:43 ../doc/1.10/whats_new.rst:73
msgid "Overview"
msgstr "Общие сведения"

#: ../doc/1.10/book/box/box_index.rst:45
msgid ""
"The ``box.index`` submodule provides read-only access for index "
"definitions and index keys. Indexes are contained in :samp:`box.space"
".{space-name}.index` array within each space object. They provide an API "
"for ordered iteration over tuples. This API is a direct binding to "
"corresponding methods of index objects of type ``box.index`` in the "
"storage engine."
msgstr ""
"Вложенный модуль ``box.index`` обеспечивает доступ к схемам индекса и "
"ключам индекса в режиме только для чтения. Индексы хранятся в массиве "
":samp:`box.space.{имя-спейса}.index` в каждом спейсе. Они предоставляют "
"API для упорядоченной итерации по кортежам. Этот API представляет собой "
"прямую привязку к соответствующим методам объектов типа``box.index`` в "
"движке базы данных."

#: ../doc/1.10/book/box/box_index.rst:53 ../doc/1.10/book/box/box_schema.rst:52
#: ../doc/1.10/book/box/box_session.rst:53 ../doc/1.10/book/box/box_slab.rst:53
#: ../doc/1.10/book/box/box_space.rst:53 ../doc/1.10/book/box/box_tuple.rst:54
#: ../doc/1.10/book/box/box_txn_management.rst:75
#: ../doc/1.10/book/box/data_model.rst:100
#: ../doc/1.10/reference/reference_lua/box_error.rst:53
#: ../doc/1.10/reference/reference_lua/clock.rst:52
#: ../doc/1.10/reference/reference_lua/console.rst:51
#: ../doc/1.10/reference/reference_lua/crypto.rst:56
#: ../doc/1.10/reference/reference_lua/csv.rst:75
#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:67
#: ../doc/1.10/reference/reference_lua/digest.rst:56
#: ../doc/1.10/reference/reference_lua/errno.rst:53
#: ../doc/1.10/reference/reference_lua/fiber.rst:56
#: ../doc/1.10/reference/reference_lua/fio.rst:61
#: ../doc/1.10/reference/reference_lua/http.rst:53
#: ../doc/1.10/reference/reference_lua/iconv.rst:58
#: ../doc/1.10/reference/reference_lua/json.rst:51
#: ../doc/1.10/reference/reference_lua/log.rst:80
#: ../doc/1.10/reference/reference_lua/msgpack.rst:52
#: ../doc/1.10/reference/reference_lua/net_box.rst:105
#: ../doc/1.10/reference/reference_lua/osmodule.rst:62
#: ../doc/1.10/reference/reference_lua/other.rst:41
#: ../doc/1.10/reference/reference_lua/pickle.rst:41
#: ../doc/1.10/reference/reference_lua/socket.rst:62
#: ../doc/1.10/reference/reference_lua/tap.rst:51
#: ../doc/1.10/reference/reference_lua/uri.rst:69
#: ../doc/1.10/reference/reference_lua/uuid.rst:51
#: ../doc/1.10/reference/reference_lua/yaml.rst:50
msgid "Index"
msgstr "Индекс"

#: ../doc/1.10/book/box/box_index.rst:55
msgid "Below is a list of all ``box.index`` functions and members."
msgstr "Ниже приведен перечень всех функций и элементов модуля ``box.index``."

#: ../doc/1.10/book/box/box_index.rst:63 ../doc/1.10/book/box/box_schema.rst:62
#: ../doc/1.10/book/box/box_schema.rst:165
#: ../doc/1.10/book/box/box_session.rst:63 ../doc/1.10/book/box/box_slab.rst:63
#: ../doc/1.10/book/box/box_space.rst:63 ../doc/1.10/book/box/box_space.rst:316
#: ../doc/1.10/book/box/box_space.rst:2018
#: ../doc/1.10/book/box/box_tuple.rst:64
#: ../doc/1.10/book/box/box_txn_management.rst:87
#: ../doc/1.10/reference/reference_lua/box_error.rst:63
#: ../doc/1.10/reference/reference_lua/clock.rst:62
#: ../doc/1.10/reference/reference_lua/console.rst:61
#: ../doc/1.10/reference/reference_lua/crypto.rst:66
#: ../doc/1.10/reference/reference_lua/csv.rst:85
#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:77
#: ../doc/1.10/reference/reference_lua/digest.rst:66
#: ../doc/1.10/reference/reference_lua/errno.rst:63
#: ../doc/1.10/reference/reference_lua/fiber.rst:66
#: ../doc/1.10/reference/reference_lua/fio.rst:73
#: ../doc/1.10/reference/reference_lua/http.rst:63
#: ../doc/1.10/reference/reference_lua/iconv.rst:68
#: ../doc/1.10/reference/reference_lua/json.rst:61
#: ../doc/1.10/reference/reference_lua/log.rst:90
#: ../doc/1.10/reference/reference_lua/msgpack.rst:62
#: ../doc/1.10/reference/reference_lua/net_box.rst:115
#: ../doc/1.10/reference/reference_lua/osmodule.rst:72
#: ../doc/1.10/reference/reference_lua/other.rst:51
#: ../doc/1.10/reference/reference_lua/pickle.rst:51
#: ../doc/1.10/reference/reference_lua/socket.rst:72
#: ../doc/1.10/reference/reference_lua/string.rst:62
#: ../doc/1.10/reference/reference_lua/tap.rst:61
#: ../doc/1.10/reference/reference_lua/uri.rst:79
#: ../doc/1.10/reference/reference_lua/utf8.rst:63
#: ../doc/1.10/reference/reference_lua/uuid.rst:61
#: ../doc/1.10/reference/reference_lua/yaml.rst:60
msgid "Name"
msgstr "Имя"

#: ../doc/1.10/book/box/box_index.rst:63 ../doc/1.10/book/box/box_schema.rst:62
#: ../doc/1.10/book/box/box_session.rst:63 ../doc/1.10/book/box/box_slab.rst:63
#: ../doc/1.10/book/box/box_space.rst:63 ../doc/1.10/book/box/box_tuple.rst:64
#: ../doc/1.10/book/box/box_txn_management.rst:87
#: ../doc/1.10/reference/reference_lua/box_error.rst:63
#: ../doc/1.10/reference/reference_lua/clock.rst:62
#: ../doc/1.10/reference/reference_lua/console.rst:61
#: ../doc/1.10/reference/reference_lua/crypto.rst:66
#: ../doc/1.10/reference/reference_lua/csv.rst:85
#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:77
#: ../doc/1.10/reference/reference_lua/digest.rst:66
#: ../doc/1.10/reference/reference_lua/errno.rst:63
#: ../doc/1.10/reference/reference_lua/fiber.rst:66
#: ../doc/1.10/reference/reference_lua/fio.rst:73
#: ../doc/1.10/reference/reference_lua/http.rst:63
#: ../doc/1.10/reference/reference_lua/iconv.rst:68
#: ../doc/1.10/reference/reference_lua/json.rst:61
#: ../doc/1.10/reference/reference_lua/log.rst:90
#: ../doc/1.10/reference/reference_lua/msgpack.rst:62
#: ../doc/1.10/reference/reference_lua/net_box.rst:115
#: ../doc/1.10/reference/reference_lua/osmodule.rst:72
#: ../doc/1.10/reference/reference_lua/other.rst:51
#: ../doc/1.10/reference/reference_lua/pickle.rst:51
#: ../doc/1.10/reference/reference_lua/socket.rst:72
#: ../doc/1.10/reference/reference_lua/string.rst:62
#: ../doc/1.10/reference/reference_lua/tap.rst:61
#: ../doc/1.10/reference/reference_lua/uri.rst:79
#: ../doc/1.10/reference/reference_lua/utf8.rst:63
#: ../doc/1.10/reference/reference_lua/uuid.rst:61
#: ../doc/1.10/reference/reference_lua/yaml.rst:60
msgid "Use"
msgstr "Использование"

#: ../doc/1.10/book/box/box_index.rst:65
msgid ":ref:`index_object.unique <box_index-unique>`"
msgstr ":ref:`index_object.unique <box_index-unique>`"

#: ../doc/1.10/book/box/box_index.rst:65
msgid "Flag, true if an index is unique"
msgstr "Флаг, если индекс уникальный -- true"

#: ../doc/1.10/book/box/box_index.rst:68
msgid ":ref:`index_object.type <box_index-type>`"
msgstr ":ref:`index_object.type <box_index-type>`"

#: ../doc/1.10/book/box/box_index.rst:68
#: ../doc/1.10/book/box/data_model.rst:305
#: ../doc/1.10/book/box/data_model.rst:908
msgid "Index type"
msgstr "Тип индекса"

#: ../doc/1.10/book/box/box_index.rst:71
msgid ":ref:`index_object.parts <box_index-parts>`"
msgstr ":ref:`index_object.parts <box_index-parts>`"

#: ../doc/1.10/book/box/box_index.rst:71
msgid "Array of index key fields"
msgstr "Массив полей с ключами индекса"

#: ../doc/1.10/book/box/box_index.rst:74
msgid ":ref:`index_object:pairs() <box_index-index_pairs>`"
msgstr ":ref:`index_object:pairs() <box_index-index_pairs>`"

#: ../doc/1.10/book/box/box_index.rst:74 ../doc/1.10/book/box/box_space.rst:106
#: ../doc/1.10/book/box/box_tuple.rst:102
msgid "Prepare for iterating"
msgstr "Подготовка к итерации"

#: ../doc/1.10/book/box/box_index.rst:77
msgid ":ref:`index_object:select() <box_index-select>`"
msgstr ":ref:`index_object:select() <box_index-select>`"

#: ../doc/1.10/book/box/box_index.rst:77
msgid "Select one or more tuples via index"
msgstr "Выбор одного или более кортежей по индексу"

#: ../doc/1.10/book/box/box_index.rst:80
msgid ":ref:`index_object:get() <box_index-get>`"
msgstr ":ref:`index_object:get() <box_index-get>`"

#: ../doc/1.10/book/box/box_index.rst:80
msgid "Select a tuple via index"
msgstr "Выбор кортежа по индексу"

#: ../doc/1.10/book/box/box_index.rst:83
msgid ":ref:`index_object:min() <box_index-min>`"
msgstr ":ref:`index_object:min() <box_index-min>`"

#: ../doc/1.10/book/box/box_index.rst:83
msgid "Find the minimum value in index"
msgstr "Поиск минимального значения в индексе"

#: ../doc/1.10/book/box/box_index.rst:86
msgid ":ref:`index_object:max() <box_index-max>`"
msgstr ":ref:`index_object:max() <box_index-max>`"

#: ../doc/1.10/book/box/box_index.rst:86
msgid "Find the maximum value in index"
msgstr "Поиск максимального значения в индексе"

#: ../doc/1.10/book/box/box_index.rst:89
msgid ":ref:`index_object:random() <box_index-random>`"
msgstr ":ref:`index_object:random() <box_index-random>`"

#: ../doc/1.10/book/box/box_index.rst:89
msgid "Find a random value in index"
msgstr "Поиск случайного значения в индексе"

#: ../doc/1.10/book/box/box_index.rst:92
msgid ":ref:`index_object:count() <box_index-count>`"
msgstr ":ref:`index_object:count() <box_index-count>`"

#: ../doc/1.10/book/box/box_index.rst:92
msgid "Count tuples matching key value"
msgstr "Подсчет кортежей с совпадающим значением ключа"

#: ../doc/1.10/book/box/box_index.rst:95
msgid ":ref:`index_object:update() <box_index-update>`"
msgstr ":ref:`index_object:update() <box_index-update>`"

#: ../doc/1.10/book/box/box_index.rst:95 ../doc/1.10/book/box/box_space.rst:127
#: ../doc/1.10/book/box/box_space.rst:130
#: ../doc/1.10/book/box/box_tuple.rst:105
#: ../doc/1.10/reference/reference_lua/net_box.rst:149
#: ../doc/1.10/reference/reference_lua/net_box.rst:152
msgid "Update a tuple"
msgstr "Обновление кортежа"

#: ../doc/1.10/book/box/box_index.rst:98
msgid ":ref:`index_object:delete() <box_index-delete>`"
msgstr ":ref:`index_object:delete() <box_index-delete>`"

#: ../doc/1.10/book/box/box_index.rst:98
msgid "Delete a tuple by key"
msgstr "Удаление кортежа по ключу"

#: ../doc/1.10/book/box/box_index.rst:101
msgid ":ref:`index_object:alter() <box_index-alter>`"
msgstr ":ref:`index_object:alter() <box_index-alter>`"

#: ../doc/1.10/book/box/box_index.rst:101
msgid "Alter an index"
msgstr "Изменение индекса"

#: ../doc/1.10/book/box/box_index.rst:104
msgid ":ref:`index_object:drop() <box_index-drop>`"
msgstr ":ref:`index_object:drop() <box_index-drop>`"

#: ../doc/1.10/book/box/box_index.rst:104
msgid "Drop an index"
msgstr "Удаление индекса"

#: ../doc/1.10/book/box/box_index.rst:107
msgid ":ref:`index_object:rename() <box_index-rename>`"
msgstr ":ref:`index_object:rename() <box_index-rename>`"

#: ../doc/1.10/book/box/box_index.rst:107
msgid "Rename an index"
msgstr "Переименование индекса"

#: ../doc/1.10/book/box/box_index.rst:110
msgid ":ref:`index_object:bsize() <box_index-bsize>`"
msgstr ":ref:`index_object:bsize() <box_index-bsize>`"

#: ../doc/1.10/book/box/box_index.rst:110
msgid "Get count of bytes for an index"
msgstr "Подсчет байтов для индекса"

#: ../doc/1.10/book/box/box_index.rst:113
msgid ":ref:`index_object:stat() <box_index-stat>`"
msgstr ":ref:`index_object:stat() <box_index-stat>`"

#: ../doc/1.10/book/box/box_index.rst:113
msgid "Get statistics for an index"
msgstr "Получение статистических данных по индексу"

#: ../doc/1.10/book/box/box_index.rst:116
msgid ":ref:`index_object:compact() <box_index-compact>`"
msgstr ":ref:`index_object:compact() <box_index-compact>`"

#: ../doc/1.10/book/box/box_index.rst:116
msgid "Remove unused index space"
msgstr "Удаление неиспользуемого пространства индекса"

#: ../doc/1.10/book/box/box_index.rst:119
msgid ":ref:`index_object:user_defined() <box_index-user_defined>`"
msgstr ":ref:`index_object:user_defined() <box_index-user_defined>`"

#: ../doc/1.10/book/box/box_index.rst:119
#: ../doc/1.10/book/box/box_space.rst:133
msgid "Any function / method that any user wants to add"
msgstr "Любая функция / метод, которые хочет добавить любой пользователь"

#: ../doc/1.10/book/box/box_index.rst:132
msgid "True if the index is unique, false if the index is not unique."
msgstr "Если индекс уникальный -- true, если индекс не уникален -- false."

#: ../doc/1.10/book/box/box_index.rst ../doc/1.10/book/box/box_info.rst
#: ../doc/1.10/book/box/box_schema.rst ../doc/1.10/book/box/box_session.rst
#: ../doc/1.10/book/box/box_slab.rst ../doc/1.10/book/box/box_space.rst
#: ../doc/1.10/book/box/box_tuple.rst
#: ../doc/1.10/book/box/box_txn_management.rst
#: ../doc/1.10/dev_guide/documentation_guidelines.rst
#: ../doc/1.10/reference/reference_lua/buffer.rst
#: ../doc/1.10/reference/reference_lua/clock.rst
#: ../doc/1.10/reference/reference_lua/csv.rst
#: ../doc/1.10/reference/reference_lua/errno.rst
#: ../doc/1.10/reference/reference_lua/fiber.rst
#: ../doc/1.10/reference/reference_lua/fio.rst
#: ../doc/1.10/reference/reference_lua/http.rst
#: ../doc/1.10/reference/reference_lua/iconv.rst
#: ../doc/1.10/reference/reference_lua/json.rst
#: ../doc/1.10/reference/reference_lua/msgpack.rst
#: ../doc/1.10/reference/reference_lua/net_box.rst
#: ../doc/1.10/reference/reference_lua/pickle.rst
#: ../doc/1.10/reference/reference_lua/socket.rst
#: ../doc/1.10/reference/reference_lua/tap.rst
#: ../doc/1.10/reference/reference_lua/uri.rst
#: ../doc/1.10/reference/reference_lua/utf8.rst
#: ../doc/1.10/reference/reference_lua/uuid.rst
#: ../doc/1.10/reference/reference_lua/xlog.rst
#: ../doc/1.10/reference/reference_lua/yaml.rst
msgid "rtype"
msgstr "тип возвращаемого значения"

#: ../doc/1.10/book/box/box_index.rst:134
#: ../doc/1.10/book/box/box_schema.rst:186
#: ../doc/1.10/book/box/box_schema.rst:192
#: ../doc/1.10/book/box/box_schema.rst:199
#: ../doc/1.10/book/box/box_space.rst:326
#: ../doc/1.10/book/box/box_space.rst:328
#: ../doc/1.10/book/box/data_model.rst:189
#: ../doc/1.10/reference/reference_lua/fiber.rst:883
#: ../doc/1.10/reference/reference_lua/fiber.rst:915
#: ../doc/1.10/reference/reference_lua/fiber.rst:935
#: ../doc/1.10/reference/reference_lua/fiber.rst:945
#: ../doc/1.10/reference/reference_lua/fiber.rst:955
#: ../doc/1.10/reference/reference_lua/fiber.rst:963
#: ../doc/1.10/reference/reference_lua/fiber.rst:1075
#: ../doc/1.10/reference/reference_lua/fio.rst:301
#: ../doc/1.10/reference/reference_lua/fio.rst:309
#: ../doc/1.10/reference/reference_lua/fio.rst:317
#: ../doc/1.10/reference/reference_lua/fio.rst:325
#: ../doc/1.10/reference/reference_lua/fio.rst:333
#: ../doc/1.10/reference/reference_lua/fio.rst:425
#: ../doc/1.10/reference/reference_lua/fio.rst:445
#: ../doc/1.10/reference/reference_lua/fio.rst:545
#: ../doc/1.10/reference/reference_lua/fio.rst:567
#: ../doc/1.10/reference/reference_lua/fio.rst:590
#: ../doc/1.10/reference/reference_lua/fio.rst:642
#: ../doc/1.10/reference/reference_lua/fio.rst:665
#: ../doc/1.10/reference/reference_lua/fio.rst:713
#: ../doc/1.10/reference/reference_lua/fio.rst:731
#: ../doc/1.10/reference/reference_lua/fio.rst:832
#: ../doc/1.10/reference/reference_lua/fio.rst:891
#: ../doc/1.10/reference/reference_lua/fio.rst:976
#: ../doc/1.10/reference/reference_lua/fio.rst:1003
#: ../doc/1.10/reference/reference_lua/net_box.rst:263
#: ../doc/1.10/reference/reference_lua/net_box.rst:279
#: ../doc/1.10/reference/reference_lua/net_box.rst:294
#: ../doc/1.10/reference/reference_lua/net_box.rst:311
#: ../doc/1.10/reference/reference_lua/socket.rst:289
#: ../doc/1.10/reference/reference_lua/socket.rst:395
#: ../doc/1.10/reference/reference_lua/socket.rst:471
#: ../doc/1.10/reference/reference_lua/socket.rst:483
#: ../doc/1.10/reference/reference_lua/string.rst:179
#: ../doc/1.10/reference/reference_lua/string.rst:209
#: ../doc/1.10/reference/reference_lua/tap.rst:188
#: ../doc/1.10/reference/reference_lua/tap.rst:211
#: ../doc/1.10/reference/reference_lua/tap.rst:245
#: ../doc/1.10/reference/reference_lua/tap.rst:280
#: ../doc/1.10/reference/reference_lua/tap.rst:293
#: ../doc/1.10/reference/reference_lua/tap.rst:303
#: ../doc/1.10/reference/reference_lua/tap.rst:318
#: ../doc/1.10/reference/reference_lua/tap.rst:339
#: ../doc/1.10/reference/reference_lua/tap.rst:358
#: ../doc/1.10/reference/reference_lua/utf8.rst:183
#: ../doc/1.10/reference/reference_lua/utf8.rst:208
#: ../doc/1.10/reference/reference_lua/utf8.rst:230
#: ../doc/1.10/reference/reference_lua/utf8.rst:252
msgid "boolean"
msgstr "boolean (логический)"

#: ../doc/1.10/book/box/box_index.rst:140
msgid "Index type, 'TREE' or 'HASH' or 'BITSET' or 'RTREE'."
msgstr "Тип индекса: 'TREE' или 'HASH' или 'BITSET' или 'RTREE'."

#: ../doc/1.10/book/box/box_index.rst:146
msgid ""
"An array describing the index fields. To learn more about the index field"
" types, refer to :ref:`this table <box_space-index_field_types>`."
msgstr ""
"Массив, описывающий поля индекса. Чтобы узнать больше о типах полей "
"индекса, обращайтесь к :ref:`этой таблице <box_space-index_field_types>`."

#: ../doc/1.10/book/box/box_index.rst:149
#: ../doc/1.10/book/box/box_index.rst:977 ../doc/1.10/book/box/box_info.rst:231
#: ../doc/1.10/book/box/box_schema.rst:175 ../doc/1.10/book/box/box_slab.rst:87
#: ../doc/1.10/book/box/box_slab.rst:146 ../doc/1.10/book/box/box_slab.rst:188
#: ../doc/1.10/book/box/box_space.rst:1620
#: ../doc/1.10/reference/reference_lua/csv.rst:109
#: ../doc/1.10/reference/reference_lua/fiber.rst:388
#: ../doc/1.10/reference/reference_lua/fio.rst:466
#: ../doc/1.10/reference/reference_lua/fio.rst:487
#: ../doc/1.10/reference/reference_lua/fio.rst:1049
#: ../doc/1.10/reference/reference_lua/http.rst:165
#: ../doc/1.10/reference/reference_lua/json.rst:121
#: ../doc/1.10/reference/reference_lua/pickle.rst:170
#: ../doc/1.10/reference/reference_lua/socket.rst:207
#: ../doc/1.10/reference/reference_lua/socket.rst:595
#: ../doc/1.10/reference/reference_lua/socket.rst:607
#: ../doc/1.10/reference/reference_lua/string.rst:286
#: ../doc/1.10/reference/reference_lua/table.rst:76
#: ../doc/1.10/reference/reference_lua/utf8.rst:328
#: ../doc/1.10/reference/reference_lua/yaml.rst:92
msgid "table"
msgstr "таблица"

#: ../doc/1.10/book/box/box_index.rst:153
msgid ""
"tarantool> box.space.tester.index.primary\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: unsigned\n"
"    is_nullable: false\n"
"    fieldno: 1\n"
"  id: 0\n"
"  space_id: 513\n"
"  name: primary\n"
"  type: TREE\n"
"..."
msgstr ""
"tarantool> box.space.tester.index.primary\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: unsigned\n"
"    is_nullable: false\n"
"    fieldno: 1\n"
"  id: 0\n"
"  space_id: 513\n"
"  name: primary\n"
"  type: TREE\n"
"..."

#: ../doc/1.10/book/box/box_index.rst:172
msgid ""
"Search for a tuple or a set of tuples via the given index, and allow "
"iterating over one tuple at a time."
msgstr ""
"Поиск кортежа или набора кортежей по заданному индексу и итерация по "
"одному кортежу за раз."

#: ../doc/1.10/book/box/box_index.rst:175
msgid "The :samp:`{key}` parameter specifies what must match within the index."
msgstr ""
"Параметр :samp:`{key}` (ключ) задает, что именно должно совпадать в "
"индексе."

#: ../doc/1.10/book/box/box_index.rst:179
msgid ""
":samp:`{key}` is only used to find the first match. Do not assume all "
"matched tuples will contain the key."
msgstr ""
":samp:`{key}` используется в поиске только первого совпадения. Не стоит "
"ожидать, что все подобранные кортежи будут содержать этот ключ."

#: ../doc/1.10/book/box/box_index.rst:182
msgid ""
"The :samp:`{iterator}` parameter specifies the rule for matching and "
"ordering. Different index types support different iterators. For example,"
" a TREE index maintains a strict order of keys and can return all tuples "
"in ascending or descending order, starting from the specified key. Other "
"index types, however, do not support ordering."
msgstr ""
"Параметр :samp:`{iterator}` (итератор) задает правило для совпадений и "
"упорядочивания. Различные типы индексов поддерживают различные итераторы."
" Например, TREE-индекс поддерживает строгий порядок ключей и может "
"вернуть все кортежи в порядке по возрастанию или по убыванию, начиная с "
"указанного ключа. Однако другие типы индексов не поддерживают "
"упорядочивание."

#: ../doc/1.10/book/box/box_index.rst:188
msgid ""
"To understand consistency of tuples returned by an iterator, it's "
"essential to know the principles of the Tarantool transaction processing "
"subsystem. An iterator in Tarantool does not own a consistent read view. "
"Instead, each procedure is granted exclusive access to all tuples and "
"spaces until there is a \"context switch\": which may happen due to "
":ref:`the implicit yield rules <atomic-implicit-yields>`, or by an "
"explicit call to :ref:`fiber.yield <fiber-yield>`. When the execution "
"flow returns to the yielded procedure, the data set could have changed "
"significantly. Iteration, resumed after a yield point, does not preserve "
"the read view, but continues with the new content of the database. The "
"tutorial :ref:`Indexed pattern search <c_lua_tutorial-"
"indexed_pattern_search>` shows one way that iterators and yields can be "
"used together."
msgstr ""
"Чтобы понять логику возврата кортежей с помощью итератора, важно знать "
"принципы работы подсистемы обработки транзакций в Tarantool'е. В "
"итераторе Tarantool'а нет собственного постоянного вида просмотра. "
"Наоборот, каждая процедура получает эксклюзивный доступ ко всем кортежам "
"и спейсам до тех пор, пока не \"переключится контекст\", что может "
"произойти по причине :ref:`неявной передачи управления <atomic-implicit-"
"yields>` или в результате явного вызова функции :ref:`fiber.yield <fiber-"
"yield>`. Когда поток выполнения возвращается к процедуре, передавшей "
"управление, набор данных может уже значительно измениться. Итерация "
"возобновляется после стадии передачи управления и не сохраняет вид "
"просмотра, а продолжает работу с новым содержимым базы данных. В "
"практическом задании :ref:`\"Индексированный поиск по шаблонам\" "
"<c_lua_tutorial-indexed_pattern_search>` демонстрируется один из способов"
" одновременного использования итераторов и передачи управления."

#: ../doc/1.10/book/box/box_index.rst:202
#: ../doc/1.10/book/box/box_space.rst:1078
msgid ""
"For information about iterators' internal structures see the `\"Lua "
"Functional library\" <https://luafun.github.io/index.html>`_ "
"documentation."
msgstr ""
"Для получения информации о внутренней структуре итераторов см. "
"документацию по библиотеке для функционального программирования в Lua "
"`\"Lua Functional library\" <https://luafun.github.io/index.html>`_."

#: ../doc/1.10/book/box/box_index.rst:206
#: ../doc/1.10/book/box/box_index.rst:526
#: ../doc/1.10/book/box/box_index.rst:661
#: ../doc/1.10/book/box/box_index.rst:692
#: ../doc/1.10/book/box/box_index.rst:722
#: ../doc/1.10/book/box/box_index.rst:755
#: ../doc/1.10/book/box/box_index.rst:782
#: ../doc/1.10/book/box/box_index.rst:813
#: ../doc/1.10/book/box/box_index.rst:836
#: ../doc/1.10/book/box/box_index.rst:857
#: ../doc/1.10/book/box/box_index.rst:892
#: ../doc/1.10/book/box/box_index.rst:917
#: ../doc/1.10/book/box/box_index.rst:941
#: ../doc/1.10/book/box/box_index.rst:973
#: ../doc/1.10/book/box/box_index.rst:1019
#: ../doc/1.10/book/box/box_space.rst:1541
msgid "an :ref:`object reference <app_server-object_reference>`."
msgstr ":ref:`ссылка на объект <app_server-object_reference>`."

#: ../doc/1.10/book/box/box_index.rst:208
#: ../doc/1.10/book/box/box_space.rst:1057
msgid "value to be matched against the index key, which may be multi-part"
msgstr "значение должно совпасть с индексным ключом, который может быть составным"

#: ../doc/1.10/book/box/box_index.rst:210
msgid "as defined in tables below. The default iterator type is 'EQ'"
msgstr "как определено в таблицах ниже. По умолчанию используется итератор 'EQ'"

#: ../doc/1.10/book/box/box_index.rst:214
#: ../doc/1.10/book/box/box_space.rst:1062
msgid ""
"`iterator <https://www.lua.org/pil/7.1.html>`_ which can be used in a "
"for/end loop or with `totable() "
"<https://rtsisyk.github.io/luafun/reducing.html#fun.totable>`_"
msgstr ""
"`итератор <https://www.lua.org/pil/7.1.html>`_, который может "
"использовать в цикле for/end или с функцией `totable() "
"<https://rtsisyk.github.io/luafun/reducing.html#fun.totable>`_"

#: ../doc/1.10/book/box/box_index.rst:218
#: ../doc/1.10/book/box/box_index.rst:668
#: ../doc/1.10/book/box/box_index.rst:865
#: ../doc/1.10/book/box/box_index.rst:897
#: ../doc/1.10/book/box/box_space.rst:216
#: ../doc/1.10/book/box/box_space.rst:370
#: ../doc/1.10/book/box/box_space.rst:599
#: ../doc/1.10/book/box/box_space.rst:1066
#: ../doc/1.10/book/box/box_space.rst:1225
#: ../doc/1.10/book/box/box_space.rst:1500
msgid "**Possible errors:**"
msgstr "**Возможные ошибки:**"

#: ../doc/1.10/book/box/box_index.rst:220
msgid "no such space; wrong type;"
msgstr "спейс отсутствует; неправильный тип;"

#: ../doc/1.10/book/box/box_index.rst:221
msgid "selected iteration type is not supported for the index type;"
msgstr "выбранный тип итерации не поддерживается для данного типа индекса;"

#: ../doc/1.10/book/box/box_index.rst:222
msgid "key is not supported for the iteration type."
msgstr "ключ не поддерживается для данного типа итерации."

#: ../doc/1.10/book/box/box_index.rst:224
msgid "**Complexity factors:** Index size, Index type; Number of tuples accessed."
msgstr ""
"**Факторы сложности** Размер индекса, тип индекса; количество кортежей, к"
" которым получен доступ."

#: ../doc/1.10/book/box/box_index.rst:227
msgid ""
"A search-key-value can be a number (for example ``1234``), a string (for "
"example ``'abcd'``), or a table of numbers and strings (for example "
"``{1234, 'abcd'}``). Each part of a key will be compared to each part of "
"an index key."
msgstr ""
"Значение искомого ключа может представлять собой число (например, "
"``1234``), строку (например, ``'abcd'``) или таблицу из чисел и строк "
"(например, ``{1234, 'abcd'}``). Каждая часть ключа будет сопоставляться с"
" каждой частью ключа в индексе."

#: ../doc/1.10/book/box/box_index.rst:232
msgid ""
"The returned tuples will be in order by index key value, or by the hash "
"of the index key value if index type = 'hash'. If the index is non-"
"unique, then duplicates will be secondarily in order by primary key "
"value. The order will be reversed if the iterator type is 'LT' or 'LE' or"
" 'REQ'."
msgstr ""
"Найденные кортежи будут упорядочены по значению ключа в индексе или по "
"хешу значения ключа, если тип индекса -- 'hash'. Если индекс не уникален,"
" то дубликаты будут упорядочены во вторую очередь по первичному значению "
"ключа. Порядок будет обратным, если тип итератора -- 'LT', 'LE' или "
"'REQ'."

#: ../doc/1.10/book/box/box_index.rst:239
msgid "**Iterator types for TREE indexes**"
msgstr "**Типы итераторов для TREE-индексов**"

#: ../doc/1.10/book/box/box_index.rst:250
#: ../doc/1.10/book/box/box_index.rst:349
#: ../doc/1.10/book/box/box_index.rst:385
#: ../doc/1.10/book/box/box_index_rtree.csv:1
#: ../doc/1.10/book/box/box_schema.rst:165
#: ../doc/1.10/book/box/box_space.rst:316
#: ../doc/1.10/book/box/box_space.rst:2018
msgid "Type"
msgstr "Type"

#: ../doc/1.10/book/box/box_index.rst:250
#: ../doc/1.10/book/box/box_index.rst:349
#: ../doc/1.10/book/box/box_index.rst:385
#: ../doc/1.10/book/box/box_index_rtree.csv:1
msgid "Arguments"
msgstr "Аргументы"

#: ../doc/1.10/book/box/box_index.rst:250
#: ../doc/1.10/book/box/box_index.rst:349
#: ../doc/1.10/book/box/box_index.rst:385
#: ../doc/1.10/book/box/box_index_rtree.csv:1
#: ../doc/1.10/book/box/box_space.rst:2018
msgid "Description"
msgstr "Описание"

#: ../doc/1.10/book/box/box_index.rst:252
#: ../doc/1.10/book/box/box_index.rst:356
#: ../doc/1.10/book/box/box_index.rst:391
#: ../doc/1.10/book/box/box_index_rtree.csv:1
msgid "box.index.EQ or 'EQ'"
msgstr "box.index.EQ или 'EQ'"

#: ../doc/1.10/book/box/box_index.rst:252
#: ../doc/1.10/book/box/box_index.rst:258
#: ../doc/1.10/book/box/box_index.rst:263
#: ../doc/1.10/book/box/box_index.rst:270
#: ../doc/1.10/book/box/box_index.rst:277
#: ../doc/1.10/book/box/box_index.rst:281
#: ../doc/1.10/book/box/box_index.rst:287
#: ../doc/1.10/book/box/box_index.rst:356
#: ../doc/1.10/book/box/box_index.rst:362
#: ../doc/1.10/book/box/box_index_rtree.csv:1
msgid "search value"
msgstr "искомое значение"

#: ../doc/1.10/book/box/box_index.rst:252
msgid ""
"The comparison operator is '==' (equal to). If an index key is equal to a"
" search value, it matches. Tuples are returned in ascending order by "
"index key. This is the default."
msgstr ""
"Оператором сравнения будет '==' (равно). Если ключ индекса равен искомому"
" значению, получим совпадение. Найденные кортежи упорядочены по "
"возрастанию по ключу индекса. Этот тип используется по умолчанию."

#: ../doc/1.10/book/box/box_index.rst:258
msgid "box.index.REQ or 'REQ'"
msgstr "box.index.REQ или 'REQ'"

#: ../doc/1.10/book/box/box_index.rst:258
msgid ""
"Matching is the same as for ``box.index.EQ``. Tuples are returned in "
"descending order by index key."
msgstr ""
"Совпадения находятся таким же образом, что и для ``box.index.EQ``. "
"Разница только в том, что найденные кортежи упорядочены по ключу индекса "
"по убыванию, а не по возрастанию."

#: ../doc/1.10/book/box/box_index.rst:263
#: ../doc/1.10/book/box/box_index.rst:362
#: ../doc/1.10/book/box/box_index_rtree.csv:1
msgid "box.index.GT or 'GT'"
msgstr "box.index.GT или 'GT'"

#: ../doc/1.10/book/box/box_index.rst:263
msgid ""
"The comparison operator is '>' (greater than). If an index key is greater"
" than a search value, it matches. Tuples are returned in ascending order "
"by index key."
msgstr ""
"Оператором сравнения будет '>' (больше чем). Если ключ индекса больше, "
"чем искомое значение, получим совпадение. Найденные кортежи упорядочены "
"по возрастанию по ключу индекса."

#: ../doc/1.10/book/box/box_index.rst:270
#: ../doc/1.10/book/box/box_index_rtree.csv:1
msgid "box.index.GE or 'GE'"
msgstr "box.index.GE или 'GE'"

#: ../doc/1.10/book/box/box_index.rst:270
msgid ""
"The comparison operator is '>=' (greater than or equal to). If an index "
"key is greater than or equal to a search value, it matches. Tuples are "
"returned in ascending order by index key."
msgstr ""
"Оператором сравнения будет '>=' (больше или равен). Если ключ индекса "
"больше искомого значения или равен ему, получим совпадение. Найденные "
"кортежи упорядочены по возрастанию по ключу индекса."

#: ../doc/1.10/book/box/box_index.rst:277
#: ../doc/1.10/book/box/box_index.rst:387
#: ../doc/1.10/book/box/box_index_rtree.csv:1
msgid "box.index.ALL or 'ALL'"
msgstr "box.index.ALL или 'ALL'"

#: ../doc/1.10/book/box/box_index.rst:277
msgid "Same as box.index.GE."
msgstr "Как для box.index.GE."

#: ../doc/1.10/book/box/box_index.rst:281
#: ../doc/1.10/book/box/box_index_rtree.csv:1
msgid "box.index.LT or 'LT'"
msgstr "box.index.LT или 'LT'"

#: ../doc/1.10/book/box/box_index.rst:281
msgid ""
"The comparison operator is '<' (less than). If an index key is less than "
"a search value, it matches. Tuples are returned in descending order by "
"index key."
msgstr ""
"Оператором сравнения будет  '<' (меньше чем). Если ключ индекса меньше "
"искомого значения, получим совпадение. Найденные кортежи упорядочены по "
"убыванию по ключу индекса."

#: ../doc/1.10/book/box/box_index.rst:287
#: ../doc/1.10/book/box/box_index_rtree.csv:1
msgid "box.index.LE or 'LE'"
msgstr "box.index.LE или 'LE'"

#: ../doc/1.10/book/box/box_index.rst:287
msgid ""
"The comparison operator is '<=' (less than or equal to). If an index key "
"is less than or equal to a search value, it matches. Tuples are returned "
"in descending order by index key."
msgstr ""
"Оператором сравнения будет '<=' (меньше или равен). Если ключ индекса "
"меньше искомого значения или равен ему, получим совпадение. Найденные "
"кортежи упорядочены по убыванию по ключу индекса."

#: ../doc/1.10/book/box/box_index.rst:295
msgid ""
"Informally, we can state that searches with TREE indexes are generally "
"what users will find is intuitive, provided that there are no nils and no"
" missing parts. Formally, the logic is as follows. A search key has zero "
"or more parts, for example {}, {1,2,3},{1,nil,3}. An index key has one or"
" more parts, for example {1}, {1,2,3},{1,2,3}. A search key may contain "
"nil (but not msgpack.NULL, which is the wrong type). An index key may not"
" contain nil or msgpack.NULL, although a later version of Tarantool will "
"have different rules --  the behavior of searches with nil is subject to "
"change. Possible iterators are LT, LE, EQ, REQ, GE, GT. A search key is "
"said to \"match\" an index key if the following statements, which are "
"pseudocode for the comparison operation, return TRUE."
msgstr ""
"Неофициально можно сказать, что поиск с помощью TREE-индексов "
"пользователи обычно считают интуитивно понятным при условии, что нет "
"нулевых значений и отсутствующих частей. Формально же логика заключается "
"в следующем. Ключ поиска состоит из нуля или более частей, например, {}, "
"{1,2,3},{1,nil,3}. Ключ индекса состоит из одной или более частей, "
"например, {1}, {1,2,3},{1,2,3}. Ключ поиска может содержать нулевое "
"значение nil (но не msgpack.NULL, этот тип не будет правильным). Ключ "
"индекса не может содержать nil или msgpack.NULL, хотя в последующих "
"версиях правила работы Tarantool'а будут другие -- поведение поиска с nil"
" может измениться. Возможные итераторы: LT, LE, EQ, REQ, GE, GT. "
"Считается, что ключ поиска соответствует ключу индекса, если следующие "
"операторы, которые представляют собой псевдокод для операции "
"сопоставления, возвращают TRUE."

#: ../doc/1.10/book/box/box_index.rst:340
msgid "**Iterator types for HASH indexes**"
msgstr "**Типы итераторов для HASH-индексов**"

#: ../doc/1.10/book/box/box_index.rst:351
msgid "box.index.ALL"
msgstr "box.index.ALL"

#: ../doc/1.10/book/box/box_index.rst:351
#: ../doc/1.10/book/box/box_index.rst:387
#: ../doc/1.10/book/box/box_index_rtree.csv:1
msgid "none"
msgstr "нет"

#: ../doc/1.10/book/box/box_index.rst:351
msgid ""
"All index keys match. Tuples are returned in ascending order by hash of "
"index key, which will appear to be random."
msgstr ""
"Все ключи индекса являются совпадениями. Найденные кортежи упорядочены по"
" возрастанию по хешу ключа индекса, который будет выглядеть случайным."

#: ../doc/1.10/book/box/box_index.rst:356
msgid ""
"The comparison operator is '==' (equal to). If an index key is equal to a"
" search value, it matches. The number of returned tuples will be 0 or 1. "
"This is the default."
msgstr ""
"Оператором сравнения будет '==' (равный). Если ключ индекса равен "
"искомому значению, получим совпадение. Количество найденных кортежей "
"будет 0 или 1. Этот тип используется по умолчанию."

#: ../doc/1.10/book/box/box_index.rst:362
msgid ""
"The comparison operator is '>' (greater than). If a hash of an index key "
"is greater than a hash of a search value, it matches. Tuples are returned"
" in ascending order by hash of index key, which will appear to be random."
" Provided that the space is not being updated, one can retrieve all the "
"tuples in a space, N tuples at a time, by using {iterator='GT', limit=N} "
"in each search, and using the last returned value from the previous "
"result as the start search value for the next search."
msgstr ""
"Оператором сравнения будет '>' (больше чем). Если хеш ключа индекса "
"больше, чем хеш искомого значения, получим совпадение. Найденные кортежи "
"упорядочены по возрастанию по хешу ключа индекса, который будет выглядеть"
" случайным. При условии, что спейс не обновляется, можно получить все "
"кортежи в спейсе, N кортежей за раз, используя  {iterator='GT', limit=N} "
"в каждом поиске и последнее найденное значение из предыдущего результата "
"поиска в качестве начального значения для следующего поиска."

#: ../doc/1.10/book/box/box_index.rst:376
msgid "**Iterator types for BITSET indexes**"
msgstr "**Типы итераторов для BITSET-индексов**"

#: ../doc/1.10/book/box/box_index.rst:387
msgid "All index keys match. Tuples are returned in their order within the space."
msgstr ""
"Все ключи индекса являются совпадениями. Найденные кортежи упорядочены по"
" положению в спейсе."

#: ../doc/1.10/book/box/box_index.rst:391
#: ../doc/1.10/book/box/box_index.rst:396
#: ../doc/1.10/book/box/box_index.rst:401
#: ../doc/1.10/book/box/box_index.rst:406
msgid "bitset value"
msgstr "значение bitset (битовое множество)"

#: ../doc/1.10/book/box/box_index.rst:391
msgid ""
"If an index key is equal to a bitset value, it matches. Tuples are "
"returned in their order within the space. This is the default."
msgstr ""
"Если ключ индекса равен искомому значению, получим совпадение. Найденные "
"кортежи упорядочены по положению в спейсе. Этот тип используется по "
"умолчанию."

#: ../doc/1.10/book/box/box_index.rst:396
msgid "box.index.BITS_ALL_SET"
msgstr "box.index.BITS_ALL_SET"

#: ../doc/1.10/book/box/box_index.rst:396
msgid ""
"If all of the bits which are 1 in the bitset value are 1 in the index "
"key, it matches. Tuples are returned in their order within the space."
msgstr ""
"Если все биты, которые равны 1 в битовом множестве, также равны 1 в ключе"
" индекса, получим совпадение. Найденные кортежи упорядочены по положению "
"в спейсе."

#: ../doc/1.10/book/box/box_index.rst:401
msgid "box.index.BITS_ANY_SET"
msgstr "box.index.BITS_ANY_SET"

#: ../doc/1.10/book/box/box_index.rst:401
msgid ""
"If any of the bits which are 1 in the bitset value are 1 in the index "
"key, it matches. Tuples are returned in their order within the space."
msgstr ""
"Если один из битов, которые равны 1 в битовом множестве, также равен 1 в "
"ключе индекса, получим совпадение. Найденные кортежи упорядочены по "
"положению в спейсе."

#: ../doc/1.10/book/box/box_index.rst:406
msgid "box.index.BITS_ALL_NOT_SET"
msgstr "box.index.BITS_ALL_NOT_SET"

#: ../doc/1.10/book/box/box_index.rst:406
msgid ""
"If all of the bits which are 1 in the bitset value are 0 in the index "
"key, it matches. Tuples are returned in their order within the space."
msgstr ""
"Если все биты, которые равны 1 в битовом множестве, равны 0 в ключе "
"индекса, получим совпадение. Найденные кортежи упорядочены по положению в"
" спейсе."

#: ../doc/1.10/book/box/box_index.rst:414
msgid "**Iterator types for RTREE indexes**"
msgstr "**Типы итераторов для RTREE-индексов**"

#: ../doc/1.10/book/box/box_index_rtree.csv:1
msgid "All keys match. Tuples are returned in their order within the space."
msgstr ""
"Все ключи являются совпадениями. Найденные кортежи упорядочены по "
"положению в спейсе."

#: ../doc/1.10/book/box/box_index_rtree.csv:1
msgid ""
"If all points of the rectangle-or-box defined by the search value are the"
" same as the rectangle-or-box defined by the index key, it matches. "
"Tuples are returned in their order within the space. \"Rectangle-or-box\""
" means \"rectangle-or-box as explained in section about :ref:`RTREE "
"<box_index-rtree>`\". This is the default."
msgstr ""
"Если все точки прямоугольника-или-параллелепипеда, определенные искомым "
"значением, совпадают с точками прямоугольника-или-параллелепипеда, "
"определенного ключом индекса, получим совпадение. Найденные кортежи "
"упорядочены по положению в спейсе. \"Прямоугольник-или-параллелепипед\" "
"означает \"прямоугольник-или-параллелепипед, как описано в разделе о "
":ref:`RTREE <box_index-rtree>`\". Этот тип используется по умолчанию."

#: ../doc/1.10/book/box/box_index_rtree.csv:1
msgid ""
"If all points of the rectangle-or-box defined by the search value are "
"within the rectangle-or-box defined by the index key, it matches. Tuples "
"are returned in their order within the space."
msgstr ""
"Если все точки прямоугольника-или-параллелепипеда, определенные искомым "
"значением, находятся в пределах прямоугольника-или-параллелепипеда, "
"определенного ключом индекса, получим совпадение. Найденные кортежи "
"упорядочены по положению в спейсе."

#: ../doc/1.10/book/box/box_index_rtree.csv:1
msgid ""
"If all points of the rectangle-or-box defined by the search value are "
"within, or at the side of, the rectangle-or-box defined by the index key,"
" it matches. Tuples are returned in their order within the space."
msgstr ""
"Если все точки прямоугольника-или-параллелепипеда, определенные искомым "
"значением, находятся в пределах прямоугольника-или-параллелепипеда, "
"определенного ключом индекса, или рядом с ним, получим совпадение. "
"Найденные кортежи упорядочены по положению в спейсе."

#: ../doc/1.10/book/box/box_index_rtree.csv:1
msgid ""
"If all points of the rectangle-or-box defined by the index key are within"
" the rectangle-or-box defined by the search key, it matches. Tuples are "
"returned in their order within the space."
msgstr ""
"Если все точки прямоугольника-или-параллелепипеда, определенные ключом "
"индекса, находятся в пределах прямоугольника-или-параллелепипеда, "
"определенного искомым значением, получим совпадение. Найденные кортежи "
"упорядочены по положению в спейсе."

#: ../doc/1.10/book/box/box_index_rtree.csv:1
msgid ""
"If all points of the rectangle-or-box defined by the index key are "
"within, or at the side of, the rectangle-or-box defined by the search "
"key, it matches. Tuples are returned in their order within the space."
msgstr ""
"Если все точки прямоугольника-или-параллелепипеда, определенные ключом "
"индекса, находятся в пределах прямоугольника-или-параллелепипеда, "
"определенного искомым значением, или рядом с ним, получим совпадение. "
"Найденные кортежи упорядочены по положению в спейсе."

#: ../doc/1.10/book/box/box_index_rtree.csv:1
msgid "box.index.OVERLAPS or 'OVERLAPS'"
msgstr "box.index.OVERLAPS или 'OVERLAPS'"

#: ../doc/1.10/book/box/box_index_rtree.csv:1
msgid ""
"If some points of the rectangle-or-box defined by the search value are "
"within the rectangle-or-box defined by the index key, it matches. Tuples "
"are returned in their order within the space."
msgstr ""
"Если некоторые точки прямоугольника-или-параллелепипеда, определенные "
"искомым значением, находятся в пределах "
"прямоугольника-или-параллелепипеда, определенного ключом индекса, получим"
" совпадение. Найденные кортежи упорядочены по положению в спейсе."

#: ../doc/1.10/book/box/box_index_rtree.csv:1
msgid "box.index.NEIGHBOR or 'NEIGHBOR'"
msgstr "box.index.NEIGHBOR или 'NEIGHBOR'"

#: ../doc/1.10/book/box/box_index_rtree.csv:1
msgid ""
"If some points of the rectangle-or-box defined by the defined by the key "
"are within, or at the side of, defined by the index key, it matches. "
"Tuples are returned in order: nearest neighbor first."
msgstr ""
"Если некоторые точки прямоугольника-или-параллелепипеда, определенные "
"ключом, находятся в пределах, определенных ключом индекса, или рядом с "
"ним, получим совпадение. Найденные кортежи упорядочены следующим образом:"
" сначала ближайший сосед."

#: ../doc/1.10/book/box/box_index.rst:428
msgid "**First example of index pairs():**"
msgstr "**Первый пример pairs():**"

#: ../doc/1.10/book/box/box_index.rst:430
msgid "Default 'TREE' Index and ``pairs()`` function:"
msgstr "'TREE'-индекс, используемый по умолчанию, и функция ``pairs()``:"

#: ../doc/1.10/book/box/box_index.rst:432
msgid ""
"tarantool> s = box.schema.space.create('space17')\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {\n"
"         >   parts = {1, 'string', 2, 'string'}\n"
"         > })\n"
"---\n"
"...\n"
"tarantool> s:insert{'C', 'C'}\n"
"---\n"
"- ['C', 'C']\n"
"...\n"
"tarantool> s:insert{'B', 'A'}\n"
"---\n"
"- ['B', 'A']\n"
"...\n"
"tarantool> s:insert{'C', '!'}\n"
"---\n"
"- ['C', '!']\n"
"...\n"
"tarantool> s:insert{'A', 'C'}\n"
"---\n"
"- ['A', 'C']\n"
"...\n"
"tarantool> function example()\n"
"         >   for _, tuple in\n"
"         >     s.index.primary:pairs(nil, {\n"
"         >         iterator = box.index.ALL}) do\n"
"         >       print(tuple)\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> example()\n"
"['A', 'C']\n"
"['B', 'A']\n"
"['C', '!']\n"
"['C', 'C']\n"
"---\n"
"...\n"
"tarantool> s:drop()\n"
"---\n"
"..."
msgstr ""
"tarantool> s = box.schema.space.create('space17')\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {\n"
"         >   parts = {1, 'string', 2, 'string'}\n"
"         > })\n"
"---\n"
"...\n"
"tarantool> s:insert{'C', 'C'}\n"
"---\n"
"- ['C', 'C']\n"
"...\n"
"tarantool> s:insert{'B', 'A'}\n"
"---\n"
"- ['B', 'A']\n"
"...\n"
"tarantool> s:insert{'C', '!'}\n"
"---\n"
"- ['C', '!']\n"
"...\n"
"tarantool> s:insert{'A', 'C'}\n"
"---\n"
"- ['A', 'C']\n"
"...\n"
"tarantool> function example()\n"
"         >   for _, tuple in\n"
"         >     s.index.primary:pairs(nil, {\n"
"         >         iterator = box.index.ALL}) do\n"
"         >       print(tuple)\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> example()\n"
"['A', 'C']\n"
"['B', 'A']\n"
"['C', '!']\n"
"['C', 'C']\n"
"---\n"
"...\n"
"tarantool> s:drop()\n"
"---\n"
"..."

#: ../doc/1.10/book/box/box_index.rst:478
msgid "**Second example of index pairs():**"
msgstr "**Второй пример pairs():**"

#: ../doc/1.10/book/box/box_index.rst:480
msgid ""
"This Lua code finds all the tuples whose primary key values begin with "
"'XY'. The assumptions include that there is a one-part primary-key TREE "
"index on the first field, which must be a string. The iterator loop "
"ensures that the search will return tuples where the first value is "
"greater than or equal to 'XY'. The conditional statement within the loop "
"ensures that the looping will stop when the first two letters are not "
"'XY'."
msgstr ""
"Данный код на Lua найдет все кортежи, значения первичного ключа в которых"
" начинаются с 'XY'. Рабочие предположения заключаются в следующем: есть "
"однокомпонентный первичный TREE-индекс по первому полю, которое должно "
"представлять собой строку. Цикл с итератором обеспечивает поиск кортежей,"
" в которых первое значение больше или равно 'XY'. Условный оператор в "
"цикле служит для того, чтобы цикл останавливался, если первые две буквы "
"не 'XY'."

#: ../doc/1.10/book/box/box_index.rst:488
msgid ""
"for _, tuple in\n"
"box.space.t.index.primary:pairs(\"XY\",{iterator = \"GE\"}) do\n"
"  if (string.sub(tuple[1], 1, 2) ~= \"XY\") then break end\n"
"  print(tuple)\n"
"end"
msgstr ""
"for _, tuple in\n"
"box.space.t.index.primary:pairs(\"XY\",{iterator = \"GE\"}) do\n"
"  if (string.sub(tuple[1], 1, 2) ~= \"XY\") then break end\n"
"  print(tuple)\n"
"end"

#: ../doc/1.10/book/box/box_index.rst:496
msgid "**Third example of index pairs():**"
msgstr "**Третий пример pairs():**"

#: ../doc/1.10/book/box/box_index.rst:498
msgid ""
"This Lua code finds all the tuples whose primary key values are greater "
"than or equal to 1000, and less than or equal to 1999 (this type of "
"request is sometimes called a \"range search\" or a \"between search\"). "
"The assumptions include that there is a one-part primary-key TREE index "
"on the first field, which must be a :ref:`number <index-box_number>`. The"
" iterator loop ensures that the search will return tuples where the first"
" value is greater than or equal to 1000. The conditional statement within"
" the loop ensures that the looping will stop when the first value is "
"greater than 1999."
msgstr ""
"Данный код на Lua найдет все кортежи, значения первичного ключа которых "
"равны или больше 1000 и меньше или равны 1999 (такой тип запроса иногда "
"называют поиском по диапазону или поиском в заданных пределах). Рабочие "
"предположения заключаются в следующем: есть однокомпонентный первичный "
"TREE-индекс по первому полю, которое должно представлять собой "
":ref:`число <index-box_number>`. Цикл с итератором обеспечивает поиск "
"кортежей, в которых первое значение больше или равно 1000. Условный "
"оператор в цикле служит для того, чтобы цикл останавливался, если первое "
"значение больше 1999."

#: ../doc/1.10/book/box/box_index.rst:508
msgid ""
"for _, tuple in\n"
"box.space.t2.index.primary:pairs(1000,{iterator = \"GE\"}) do\n"
"  if (tuple[1] > 1999) then break end\n"
"  print(tuple)\n"
"end"
msgstr ""
"for _, tuple in\n"
"box.space.t2.index.primary:pairs(1000,{iterator = \"GE\"}) do\n"
"  if (tuple[1] > 1999) then break end\n"
"  print(tuple)\n"
"end"

#: ../doc/1.10/book/box/box_index.rst:520
msgid ""
"This is an alternative to :ref:`box.space...select() <box_space-select>` "
"which goes via a particular index and can make use of additional "
"parameters that specify the iterator type, and the limit (that is, the "
"maximum number of tuples to return) and the offset (that is, which tuple "
"to start with in the list)."
msgstr ""
"Это может быть альтернативой для функции :ref:`box.space...select() "
"<box_space-select>`, которая проходит по определенному индексу и может "
"использовать дополнительные параметры, которые определяют тип итератора и"
" пределы (то есть максимальное количество возвращаемых кортежей) и "
"смещение (то есть с какого кортежа в списке начинать)."

#: ../doc/1.10/book/box/box_index.rst:528
#: ../doc/1.10/book/box/box_index.rst:663
#: ../doc/1.10/book/box/box_index.rst:694
#: ../doc/1.10/book/box/box_index.rst:724
#: ../doc/1.10/book/box/box_index.rst:784
#: ../doc/1.10/book/box/box_index.rst:815
#: ../doc/1.10/book/box/box_index.rst:838
msgid "values to be matched against the index key"
msgstr "значения для сопоставления с ключом индекса"

#: ../doc/1.10/book/box/box_index.rst:529
msgid "none, any or all of next parameters"
msgstr "ни один, любой или все следующие параметры"

#: ../doc/1.10/book/box/box_index.rst:530
msgid "type of iterator"
msgstr "тип итератора"

#: ../doc/1.10/book/box/box_index.rst:531
msgid "maximum number of tuples"
msgstr "максимальное количество кортежей"

#: ../doc/1.10/book/box/box_index.rst:532
msgid "start tuple number"
msgstr "номер начального кортежа"

#: ../doc/1.10/book/box/box_index.rst:534
msgid "the tuple or tuples that match the field values."
msgstr "кортеж или кортежи, которые совпадают со значениями поля."

#: ../doc/1.10/book/box/box_index.rst:535
#: ../doc/1.10/book/box/box_space.rst:1220
msgid "array of tuples"
msgstr "массив кортежей"

#: ../doc/1.10/book/box/box_index.rst:539
msgid ""
"-- Create a space named tester.\n"
"tarantool> sp = box.schema.space.create('tester')\n"
"-- Create a unique index 'primary'\n"
"-- which won't be needed for this example.\n"
"tarantool> sp:create_index('primary', {parts = {1, 'unsigned' }})\n"
"-- Create a non-unique index 'secondary'\n"
"-- with an index on the second field.\n"
"tarantool> sp:create_index('secondary', {\n"
"         >   type = 'tree',\n"
"         >   unique = false,\n"
"         >   parts = {2, 'string'}\n"
"         > })\n"
"-- Insert three tuples, values in field[2]\n"
"-- equal to 'X', 'Y', and 'Z'.\n"
"tarantool> sp:insert{1, 'X', 'Row with field[2]=X'}\n"
"tarantool> sp:insert{2, 'Y', 'Row with field[2]=Y'}\n"
"tarantool> sp:insert{3, 'Z', 'Row with field[2]=Z'}\n"
"-- Select all tuples where the secondary index\n"
"-- keys are greater than 'X'.`\n"
"tarantool> sp.index.secondary:select({'X'}, {\n"
"         >   iterator = 'GT',\n"
"         >   limit = 1000\n"
"         > })"
msgstr ""
"-- Создать спейс под названием tester.\n"
"tarantool> sp = box.schema.space.create('tester')\n"
"-- Создать уникальный индекс 'primary'\n"
"-- который не будет нужен для данного примера..\n"
"tarantool> sp:create_index('primary', {parts = {1, 'unsigned' }})\n"
"-- Создать неуникальный индекс 'secondary'\n"
"-- по второму полю.\n"
"tarantool> sp:create_index('secondary', {\n"
"         >   type = 'tree',\n"
"         >   unique = false,\n"
"         >   parts = {2, 'string'}\n"
"         > })\n"
"-- Вставить три кортежа, значения в поле2 field[2]\n"
"-- равны 'X', 'Y' и 'Z'.\n"
"tarantool> sp:insert{1, 'X', 'Row with field[2]=X'}\n"
"tarantool> sp:insert{2, 'Y', 'Row with field[2]=Y'}\n"
"tarantool> sp:insert{3, 'Z', 'Row with field[2]=Z'}\n"
"-- Выбрать все кортежи, где вторичные ключи\n"
"-- больше, чем 'X'.`\n"
"tarantool> sp.index.secondary:select({'X'}, {\n"
"         >   iterator = 'GT',\n"
"         >   limit = 1000\n"
"         > })"

#: ../doc/1.10/book/box/box_index.rst:565
msgid "The result will be a table of tuple and will look like this:"
msgstr "Результатом будет следующая таблица кортежа:"

#: ../doc/1.10/book/box/box_index.rst:567
msgid ""
"---\n"
"- - [2, 'Y', 'Row with field[2]=Y']\n"
"  - [3, 'Z', 'Row with field[2]=Z']\n"
"..."
msgstr ""
"---\n"
"- - [2, 'Y', 'Row with field[2]=Y']\n"
"  - [3, 'Z', 'Row with field[2]=Z']\n"
"..."

#: ../doc/1.10/book/box/box_index.rst:576
msgid ""
":samp:`index.{index-name}` is optional. If it is omitted, then the "
"assumed index is the first (primary-key) index. Therefore, for the "
"example above, ``box.space.tester:select({1}, {iterator = 'GT'})`` would "
"have returned the same two rows, via the 'primary' index."
msgstr ""
"Параметр :samp:`index.{имя-индекса}` необязателен. Если он пропущен, то "
"подразумевается первый индекс (первичный ключ). Таким образом, для "
"примера выше, ``box.space.tester:select({1}, {iterator = 'GT'})`` вернет "
"две одинаковых строки по первичному индексу 'primary'."

#: ../doc/1.10/book/box/box_index.rst:583
msgid ""
":samp:`iterator = {iterator-type}` is optional. If it is omitted, then "
"``iterator = 'EQ'`` is assumed."
msgstr ""
"Параметр типа итератора :samp:`iterator = {тип-итератора}` необязателен. "
"Если он пропущен, то подразумевается, что ``iterator = 'EQ'``."

#: ../doc/1.10/book/box/box_index.rst:588
msgid ""
":samp:`{field-value} [, {field-value ...}]` is optional. If it is "
"omitted, then every key in the index is considered to be a match, "
"regardless of iterator type. Therefore, for the example above, "
"``box.space.tester:select{}`` will select every tuple in the tester space"
" via the first (primary-key) index."
msgstr ""
"Параметр :samp:`{field-value} [, {значение поля ...}]` необязателен. Если"
" он пропущен, то каждый ключ в индексе будет считаться совпадением "
"независимо от типа итератора. Таким образом, для примера выше, "
"``box.space.tester:select{}`` выберет каждый кортеж в спейсе tester по "
"первому индексу (первичный ключ)."

#: ../doc/1.10/book/box/box_index.rst:598
msgid ""
":samp:`box.space.{space-name}.index.{index-name}:select(...)[1]``. can be"
" replaced by :samp:`box.space.{space-name}.index.{index-name}:get(...)`. "
"That is, ``get`` can be used as a convenient shorthand to get the first "
"tuple in the tuple set that would be returned by ``select``. However, if "
"there is more than one tuple in the tuple set, then ``get`` throws an "
"error."
msgstr ""
":samp:`box.space.{имя-спейса}.index.{имя-индекса}:select(...)[1]`` можно "
"заменить :samp:`box.space.{имя-спейса}.index.{имя-индекса}:get(...)`. А "
"именно, ``get`` можно использовать в качестве удобного сокращения для "
"получения первого кортежа в наборе кортежей, который был бы выведен по "
"запросу ``select``. Однако, если в наборе кортежей больше одного кортежа,"
" ``get`` завершится с ошибкой."

#: ../doc/1.10/book/box/box_index.rst:606
msgid "**Example with BITSET index:**"
msgstr "**Пример с индексом BITSET:**"

#: ../doc/1.10/book/box/box_index.rst:608
msgid ""
"The following script shows creation and search with a BITSET index. "
"Notice: BITSET cannot be unique, so first a primary-key index is created."
" Notice: bit values are entered as hexadecimal literals for easier "
"reading."
msgstr ""
"Следующий скрипт показывает создание BITSET-индекса и поиск по нему. "
"Обратите внимание, что битовое множество BITSET не может быть уникальным,"
" поэтому сначала создается первичный индекс. Обратите внимание, что "
"битовые значения вводятся как шестнадцатеричные литералы для удобства "
"чтения."

#: ../doc/1.10/book/box/box_index.rst:612
msgid ""
"tarantool> s = box.schema.space.create('space_with_bitset')\n"
"tarantool> s:create_index('primary_index', {\n"
"         >   parts = {1, 'string'},\n"
"         >   unique = true,\n"
"         >   type = 'TREE'\n"
"         > })\n"
"tarantool> s:create_index('bitset_index', {\n"
"         >   parts = {2, 'unsigned'},\n"
"         >   unique = false,\n"
"         >   type = 'BITSET'\n"
"         > })\n"
"tarantool> s:insert{'Tuple with bit value = 01', 0x01}\n"
"tarantool> s:insert{'Tuple with bit value = 10', 0x02}\n"
"tarantool> s:insert{'Tuple with bit value = 11', 0x03}\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.EQ\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ANY_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_NOT_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 01', 1]\n"
"..."
msgstr ""
"tarantool> s = box.schema.space.create('space_with_bitset')\n"
"tarantool> s:create_index('primary_index', {\n"
"         >   parts = {1, 'string'},\n"
"         >   unique = true,\n"
"         >   type = 'TREE'\n"
"         > })\n"
"tarantool> s:create_index('bitset_index', {\n"
"         >   parts = {2, 'unsigned'},\n"
"         >   unique = false,\n"
"         >   type = 'BITSET'\n"
"         > })\n"
"tarantool> s:insert{'Tuple with bit value = 01', 0x01}\n"
"tarantool> s:insert{'Tuple with bit value = 10', 0x02}\n"
"tarantool> s:insert{'Tuple with bit value = 11', 0x03}\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.EQ\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ANY_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_NOT_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 01', 1]\n"
"..."

#: ../doc/1.10/book/box/box_index.rst:659
msgid ""
"Search for a tuple via the given index, as described :ref:`earlier "
"<box_index-note>`."
msgstr ""
"Поиск кортежа по заданному индексу, как описано :ref:`выше <box_index-"
"note>`."

#: ../doc/1.10/book/box/box_index.rst:665
msgid "the tuple whose index-key fields are equal to the passed key values."
msgstr "кортеж, в котором поля ключа в индексе равны переданным значениям ключа."

#: ../doc/1.10/book/box/box_index.rst:666
#: ../doc/1.10/book/box/box_index.rst:701
#: ../doc/1.10/book/box/box_index.rst:731
#: ../doc/1.10/book/box/box_index.rst:760
#: ../doc/1.10/book/box/box_index.rst:824
#: ../doc/1.10/book/box/box_index.rst:841
#: ../doc/1.10/book/box/box_space.rst:211
#: ../doc/1.10/book/box/box_space.rst:537
#: ../doc/1.10/book/box/box_space.rst:791
#: ../doc/1.10/book/box/box_space.rst:841
#: ../doc/1.10/book/box/box_space.rst:1152
#: ../doc/1.10/book/box/box_space.rst:1378
#: ../doc/1.10/book/box/box_tuple.rst:123
#: ../doc/1.10/book/box/box_tuple.rst:391
#: ../doc/1.10/book/box/box_tuple.rst:392
#: ../doc/1.10/book/box/box_tuple.rst:576
#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:256
msgid "tuple"
msgstr "кортеж"

#: ../doc/1.10/book/box/box_index.rst:670
msgid "no such index;"
msgstr "отсутствие такого индекса;"

#: ../doc/1.10/book/box/box_index.rst:671
msgid "wrong type;"
msgstr "неправильный тип;"

#: ../doc/1.10/book/box/box_index.rst:672
msgid "more than one tuple matches."
msgstr "больше одного кортежа подходят."

#: ../doc/1.10/book/box/box_index.rst:674
msgid ""
"**Complexity factors:** Index size, Index type. See also "
":ref:`space_object:get() <box_space-get>`."
msgstr ""
"**Факторы сложности:** Размер индекса, тип индекса. См. также "
":ref:`space_object:get() <box_space-get>`."

#: ../doc/1.10/book/box/box_index.rst:679
msgid ""
"tarantool> box.space.tester.index.primary:get(2)\n"
"---\n"
"- [2, 'Music']\n"
"..."
msgstr ""
"tarantool> box.space.tester.index.primary:get(2)\n"
"---\n"
"- [2, 'Music']\n"
"..."

#: ../doc/1.10/book/box/box_index.rst:690
msgid "Find the minimum value in the specified index."
msgstr "Поиск минимального значения в указанном индексе."

#: ../doc/1.10/book/box/box_index.rst:696
msgid ""
"the tuple for the first key in the index. If optional ``key`` value is "
"supplied, returns the first key which is greater than or equal to ``key``"
" value. In a future version of Tarantool, index:min(``key`` value) will "
"return nothing if ``key`` value is not equal to a value in the index."
msgstr ""
"кортеж для первого ключа в индексе. Если указано необязательное значение "
"ключа ``key``, будет выведен первый ключ, который больше или равен "
"значению ключа ``key``. В будущей версии Tarantool'а index:min(значение "
"``key``) не вернет ничего, если значение ``key`` не равно значению в "
"индексе."

#: ../doc/1.10/book/box/box_index.rst:703
#: ../doc/1.10/book/box/box_index.rst:733
msgid "**Possible errors:** index is not of type 'TREE'."
msgstr "**Возможные ошибки:** тип индекса не 'TREE'."

#: ../doc/1.10/book/box/box_index.rst:705
#: ../doc/1.10/book/box/box_index.rst:735
#: ../doc/1.10/book/box/box_index.rst:762
#: ../doc/1.10/book/box/box_space.rst:1071
#: ../doc/1.10/book/box/box_space.rst:1230
msgid "**Complexity factors:** Index size, Index type."
msgstr "**Факторы сложности:** Размер индекса, тип индекса."

#: ../doc/1.10/book/box/box_index.rst:709
msgid ""
"tarantool> box.space.tester.index.primary:min()\n"
"---\n"
"- ['Alpha!', 55, 'This is the first tuple!']\n"
"..."
msgstr ""
"tarantool> box.space.tester.index.primary:min()\n"
"---\n"
"- ['Alpha!', 55, 'This is the first tuple!']\n"
"..."

#: ../doc/1.10/book/box/box_index.rst:720
msgid "Find the maximum value in the specified index."
msgstr "Поиск максимального значения в указанном индексе."

#: ../doc/1.10/book/box/box_index.rst:726
msgid ""
"the tuple for the last key in the index. If optional ``key`` value is "
"supplied, returns the last key which is less than or equal to ``key`` "
"value. In a future version of Tarantool, index:max(``key`` value) will "
"return nothing if ``key`` value is not equal to a value in the index."
msgstr ""
"кортеж для последнего ключа в индексе. Если указано необязательное "
"значение ключа ``key``, будет выведен последний ключ, который меньше или "
"равен значению ключа ``key``. В будущей версии Tarantool'а "
"index:max(значение ``key``) не вернет ничего, если значение ``key`` не "
"равно значению в индексе."

#: ../doc/1.10/book/box/box_index.rst:739
msgid ""
"tarantool> box.space.tester.index.primary:max()\n"
"---\n"
"- ['Gamma!', 55, 'This is the third tuple!']\n"
"..."
msgstr ""
"tarantool> box.space.tester.index.primary:max()\n"
"---\n"
"- ['Gamma!', 55, 'This is the third tuple!']\n"
"..."

#: ../doc/1.10/book/box/box_index.rst:750
msgid ""
"Find a random value in the specified index. This method is useful when "
"it's important to get insight into data distribution in an index without "
"having to iterate over the entire data set."
msgstr ""
"Поиск случайного значения в заданном индексе. Данный метод используется, "
"когда важно получить представление о распределении данных в индексе без "
"необходимости проходить по всему набору данных."

#: ../doc/1.10/book/box/box_index.rst:757
msgid "an arbitrary non-negative integer"
msgstr "произвольное неотрицательное целое число"

#: ../doc/1.10/book/box/box_index.rst:759
msgid "the tuple for the random key in the index."
msgstr "кортеж для случайного ключа в индексе."

#: ../doc/1.10/book/box/box_index.rst:764
msgid "**Note re storage engine:** vinyl does not support ``random()``."
msgstr "**Примечание про движок базы данных:** vinyl не поддерживает ``random()``."

#: ../doc/1.10/book/box/box_index.rst:768
msgid ""
"tarantool> box.space.tester.index.secondary:random(1)\n"
"---\n"
"- ['Beta!', 66, 'This is the second tuple!']\n"
"..."
msgstr ""
"tarantool> box.space.tester.index.secondary:random(1)\n"
"---\n"
"- ['Beta!', 66, 'This is the second tuple!']\n"
"..."

#: ../doc/1.10/book/box/box_index.rst:779
msgid ""
"Iterate over an index, counting the number of tuples which match the key-"
"value."
msgstr ""
"Итерация по индексу с подсчетом количества кортежей, которые "
"соответствуют паре ключ-значение."

#: ../doc/1.10/book/box/box_index.rst:785
#: ../doc/1.10/book/box/box_space.rst:269
msgid "comparison method"
msgstr "метод сопоставления"

#: ../doc/1.10/book/box/box_index.rst:787
#, fuzzy
msgid "the number of matching tuples."
msgstr "количество совпадающих ключей индекса."

#: ../doc/1.10/book/box/box_index.rst:788
#: ../doc/1.10/book/box/box_index.rst:945
#: ../doc/1.10/book/box/box_schema.rst:169
#: ../doc/1.10/book/box/box_schema.rst:182
#: ../doc/1.10/book/box/box_session.rst:117
#: ../doc/1.10/book/box/box_session.rst:124
#: ../doc/1.10/book/box/box_session.rst:153
#: ../doc/1.10/book/box/box_session.rst:238
#: ../doc/1.10/book/box/box_session.rst:269
#: ../doc/1.10/book/box/box_space.rst:324
#: ../doc/1.10/book/box/box_space.rst:337
#: ../doc/1.10/book/box/box_space.rst:342
#: ../doc/1.10/book/box/box_space.rst:344
#: ../doc/1.10/book/box/box_space.rst:346
#: ../doc/1.10/book/box/box_space.rst:348
#: ../doc/1.10/book/box/box_space.rst:350
#: ../doc/1.10/book/box/box_tuple.rst:157
#: ../doc/1.10/book/box/box_tuple.rst:191
#: ../doc/1.10/book/box/box_tuple.rst:347
#: ../doc/1.10/reference/reference_lua/fiber.rst:463
#: ../doc/1.10/reference/reference_lua/fiber.rst:924
#: ../doc/1.10/reference/reference_lua/fio.rst:350
#: ../doc/1.10/reference/reference_lua/fio.rst:1026
#: ../doc/1.10/reference/reference_lua/socket.rst:308
#: ../doc/1.10/reference/reference_lua/socket.rst:434
#: ../doc/1.10/reference/reference_lua/utf8.rst:91
#: ../doc/1.10/reference/reference_lua/utf8.rst:152
#: ../doc/1.10/reference/reference_lua/utf8.rst:275
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1489
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1504
msgid "number"
msgstr "число"

#: ../doc/1.10/book/box/box_index.rst:792
msgid ""
"tarantool> box.space.tester.index.primary:count(999)\n"
"---\n"
"- 0\n"
"...\n"
"tarantool> box.space.tester.index.primary:count('Alpha!', { iterator = "
"'LE' })\n"
"---\n"
"- 1\n"
"..."
msgstr ""
"tarantool> box.space.tester.index.primary:count(999)\n"
"---\n"
"- 0\n"
"...\n"
"tarantool> box.space.tester.index.primary:count('Alpha!', { iterator = "
"'LE' })\n"
"---\n"
"- 1\n"
"..."

#: ../doc/1.10/book/box/box_index.rst:807
#: ../doc/1.10/book/box/box_space.rst:1336
#: ../doc/1.10/book/box/box_tuple.rst:553
msgid "Update a tuple."
msgstr "Обновление кортежа."

#: ../doc/1.10/book/box/box_index.rst:809
msgid ""
"Same as :ref:`box.space...update() <box_space-update>`, but key is "
"searched in this index instead of primary key. This index ought to be "
"unique."
msgstr ""
"То же, что и :ref:`box.space...update() <box_space-update>`, но поиск "
"ключа происходит в этом индексе, вместо первичного. Данный индекс должен "
"быть уникальным."

#: ../doc/1.10/book/box/box_index.rst:816
#: ../doc/1.10/book/box/box_space.rst:1370
#: ../doc/1.10/book/box/box_space.rst:1491
msgid "operation type represented in string"
msgstr "тип операции, представленный строкой"

#: ../doc/1.10/book/box/box_index.rst:817
#: ../doc/1.10/book/box/box_space.rst:1371
#: ../doc/1.10/book/box/box_space.rst:1492
#: ../doc/1.10/book/box/box_tuple.rst:569
msgid ""
"what field the operation will apply to. The field number can be negative,"
" meaning the position from the end of tuple. (#tuple + negative field "
"number + 1)"
msgstr ""
"к какому полю применяется операция. Номер поля может быть отрицательным, "
"что означает, что позиция рассчитывается с конца кортежа. (#кортеж + "
"отрицательный номер поля + 1)"

#: ../doc/1.10/book/box/box_index.rst:821
#: ../doc/1.10/book/box/box_space.rst:1375
#: ../doc/1.10/book/box/box_space.rst:1496
#: ../doc/1.10/book/box/box_tuple.rst:573
msgid "what value will be applied"
msgstr "какое значение применяется"

#: ../doc/1.10/book/box/box_index.rst:823
#: ../doc/1.10/book/box/box_space.rst:1377
msgid "the updated tuple."
msgstr "обновленный кортеж."

#: ../doc/1.10/book/box/box_index.rst:830
msgid "Delete a tuple identified by a key."
msgstr "Удаление кортежа по ключу."

#: ../doc/1.10/book/box/box_index.rst:832
msgid ""
"Same as :ref:`box.space...delete() <box_space-delete>`, but key is "
"searched in this index instead of in the primary-key index. This index "
"ought to be unique."
msgstr ""
"То же, что и :ref:`box.space...delete() <box_space-delete>`, но поиск "
"ключа происходит в этом индексе, вместо первичного. Данный индекс должен "
"быть уникальным."

#: ../doc/1.10/book/box/box_index.rst:840
msgid "the deleted tuple."
msgstr "удаленный кортеж."

#: ../doc/1.10/book/box/box_index.rst:843
msgid ""
"**Note re storage engine:** vinyl will return `nil`, rather than the "
"deleted tuple."
msgstr ""
"**Примечание про движок базы данных:** vinyl вернет `nil`, а не удаленный"
" кортеж."

#: ../doc/1.10/book/box/box_index.rst:850
msgid ""
"Alter an index. It is legal in some circumstances to change one or more "
"of the index characteristics, for example its type, its sequence options,"
" its parts, and whether it is unique, Usually this causes rebuilding of "
"the space,  except for the simple case where a part's ``is_nullable`` "
"flag is changed from ``false`` to ``true``."
msgstr ""
"Изменение индекса. В определенных обстоятельствах можно изменять "
"некоторые характеристики индекса, например тип, параметры "
"последовательности и определение его уникальности. Тем не менее, это "
"обычно приводит к перестроению спейса за исключением простого случая, "
"когда значение флага ``is_nullable`` меняется с ``false`` на ``true``."

#: ../doc/1.10/book/box/box_index.rst:859
msgid ""
"options list, same as the options list for ``create_index``, see the "
"chart named :ref:`Options for space_object:create_index() <box_space-"
"create_index>`."
msgstr ""
"список параметров, аналогичный списку параметров для ``create_index``, "
"см. таблицу под названием :ref:`Параметры для space_object:create_index()"
" <box_space-create_index>`."

#: ../doc/1.10/book/box/box_index.rst:863
#: ../doc/1.10/book/box/box_index.rst:921
#: ../doc/1.10/book/box/box_schema.rst:272
#: ../doc/1.10/book/box/box_schema.rst:490
#: ../doc/1.10/book/box/box_schema.rst:640
#: ../doc/1.10/book/box/box_space.rst:574
#: ../doc/1.10/book/box/box_space.rst:1121
#: ../doc/1.10/book/box/box_space.rst:1180
#: ../doc/1.10/book/box/box_space.rst:1310
#: ../doc/1.10/book/box/data_model.rst:187
#: ../doc/1.10/dev_guide/documentation_guidelines.rst:279
#: ../doc/1.10/reference/reference_lua/console.rst:108
#: ../doc/1.10/reference/reference_lua/fiber.rst:517
#: ../doc/1.10/reference/reference_lua/fiber.rst:564
#: ../doc/1.10/reference/reference_lua/fiber.rst:654
#: ../doc/1.10/reference/reference_lua/fiber.rst:1084
#: ../doc/1.10/reference/reference_lua/fiber.rst:1092
#: ../doc/1.10/reference/reference_lua/log.rst:154
#: ../doc/1.10/reference/reference_lua/log.rst:168
#: ../doc/1.10/reference/reference_lua/msgpack.rst:254
#: ../doc/1.10/reference/reference_lua/tap.rst:163
#: ../doc/1.10/reference/reference_lua/tap.rst:197
#: ../doc/1.10/reference/reference_lua/tap.rst:257
msgid "nil"
msgstr "nil"

#: ../doc/1.10/book/box/box_index.rst:867
#: ../doc/1.10/book/box/box_index.rst:899
msgid "index does not exist,"
msgstr "индекс не существует,"

#: ../doc/1.10/book/box/box_index.rst:868
msgid "the primary-key index cannot be changed to ``{unique = false}``."
msgstr ""
"индекс по первичному ключу не может быть неуникальным, то есть нельзя "
"задать ``{unique = false}``."

#: ../doc/1.10/book/box/box_index.rst:870
msgid ""
"**Note re storage engine:** vinyl does not support ``alter()`` of a "
"primary-key index unless the space is empty."
msgstr ""
"**Примечание про движок базы данных:** vinyl не поддерживает ``alter()`` "
"для первичного индекса, если спейс содержит данные."

#: ../doc/1.10/book/box/box_index.rst:875
msgid ""
"tarantool> box.space.space55.index.primary:alter({type = 'HASH'})\n"
"---\n"
"...\n"
"\n"
"tarantool> box.space.vinyl_space.index.i:alter({page_size=4096})\n"
"---\n"
"..."
msgstr ""
"tarantool> box.space.space55.index.primary:alter({type = 'HASH'})\n"
"---\n"
"...\n"
"\n"
"tarantool> box.space.vinyl_space.index.i:alter({page_size=4096})\n"
"---\n"
"..."

#: ../doc/1.10/book/box/box_index.rst:889
msgid ""
"Drop an index. Dropping a primary-key index has a side effect: all tuples"
" are deleted."
msgstr ""
"Удаление индекса. Побочный эффект удаления первичного индекса -- все "
"кортежи удалятся."

#: ../doc/1.10/book/box/box_index.rst:895
msgid "nil."
msgstr "nil."

#: ../doc/1.10/book/box/box_index.rst:900
msgid "a primary-key index cannot be dropped while a secondary-key index exists."
msgstr "первичный индекс невозможно удалить, если существует вторичный индекс."

#: ../doc/1.10/book/box/box_index.rst:905
msgid ""
"tarantool> box.space.space55.index.primary:drop()\n"
"---\n"
"..."
msgstr ""
"tarantool> box.space.space55.index.primary:drop()\n"
"---\n"
"..."

#: ../doc/1.10/book/box/box_index.rst:915
#: ../doc/1.10/dev_guide/documentation_guidelines.rst:274
msgid "Rename an index."
msgstr "Переименование индекса."

#: ../doc/1.10/book/box/box_index.rst:919
msgid "new name for index"
msgstr "новое имя индекса"

#: ../doc/1.10/book/box/box_index.rst:923
msgid "**Possible errors:** index_object does not exist."
msgstr "**Возможные ошибки:** index_object не существует."

#: ../doc/1.10/book/box/box_index.rst:927
#: ../doc/1.10/dev_guide/documentation_guidelines.rst:285
msgid ""
"tarantool> box.space.space55.index.primary:rename('secondary')\n"
"---\n"
"..."
msgstr ""
"tarantool> box.space.space55.index.primary:rename('secondary')\n"
"---\n"
"..."

#: ../doc/1.10/book/box/box_index.rst:933
#: ../doc/1.10/book/box/box_space.rst:1308
msgid "**Complexity factors:** Index size, Index type, Number of tuples accessed."
msgstr ""
"**Факторы сложности:** Размер индекса, тип индекса, количество кортежей, "
"к которым получен доступ."

#: ../doc/1.10/book/box/box_index.rst:939
msgid "Return the total number of bytes taken by the index."
msgstr "Возврат общего количества байтов, занятых индексом."

#: ../doc/1.10/book/box/box_index.rst:944
#: ../doc/1.10/book/box/box_tuple.rst:190
msgid "number of bytes"
msgstr "количество байтов"

#: ../doc/1.10/book/box/box_index.rst:951
msgid "Return statistics about actions taken that affect the index."
msgstr "Получение статистики о предпринятых действиях, которые влияют на индекс."

#: ../doc/1.10/book/box/box_index.rst:953
msgid "This is for use with the vinyl engine."
msgstr "Используется с движком базы данных vinyl."

#: ../doc/1.10/book/box/box_index.rst:955
msgid "Some detail items in the output from ``index_object:stat()`` are:"
msgstr "Подробные данные в выводе ``index_object:stat()``:"

#: ../doc/1.10/book/box/box_index.rst:957
msgid "``index_object:stat().latency`` -- timings subdivided by percentages;"
msgstr "``index_object:stat().latency`` содержит отметки времени в процентах;"

#: ../doc/1.10/book/box/box_index.rst:958
msgid "``index_object:stat().bytes`` -- the number of bytes total;"
msgstr "``index_object:stat().bytes`` содержит общее количество байтов;"

#: ../doc/1.10/book/box/box_index.rst:959
msgid ""
"``index_object:stat().disk.rows`` -- the approximate number of tuples in "
"each range;"
msgstr ""
"``index_object:stat().disk.rows`` содержит примерное количество кортежей "
"в каждом диапазоне;"

#: ../doc/1.10/book/box/box_index.rst:960
msgid ""
"``index_object:stat().disk.statement`` -- counts of "
"inserts|updates|upserts|deletes;"
msgstr ""
"``index_object:stat().disk.statement`` содержит количество вставок, "
"обновлений, обновлений и вставок, удалений "
"(inserts|updates|upserts|deletes);"

#: ../doc/1.10/book/box/box_index.rst:961
msgid ""
"``index_object:stat().disk.compaction`` -- counts of compactions and "
"their amounts;"
msgstr ""
"``index_object:stat().disk.compaction`` содержит количество слияний и их "
"объем;"

#: ../doc/1.10/book/box/box_index.rst:962
msgid "``index_object:stat().disk.dump`` -- counts of dumps and their amounts;"
msgstr "``index_object:stat().disk.dump`` содержит количество дампов и их объем;"

#: ../doc/1.10/book/box/box_index.rst:963
msgid ""
"``index_object:stat().disk.iterator.bloom`` -- counts of bloom filter "
"hits|misses;"
msgstr ""
"``index_object:stat().disk.iterator.bloom`` содержит количество "
"совпадений и несовпадений по фильтрами Блума;"

#: ../doc/1.10/book/box/box_index.rst:964
msgid "``index_object:stat().disk.pages`` -- the size in pages;"
msgstr "``index_object:stat().disk.pages`` содержит размер в страницах;"

#: ../doc/1.10/book/box/box_index.rst:965
msgid ""
"``index_object:stat().disk.last_level`` -- size of data in the last LSM "
"tree level;"
msgstr ""
"``index_object:stat().disk.last_level`` содержит объем данных на "
"последнем уровне LSM-дерева;"

#: ../doc/1.10/book/box/box_index.rst:966
msgid "``index_object:stat().cache.evict`` -- number of evictions from the cache;"
msgstr "``index_object:stat().cache.evict`` содержит количество освобождений кэша;"

#: ../doc/1.10/book/box/box_index.rst:967
msgid "``index_object:stat().range_size`` -- maximum number of bytes in a range;"
msgstr ""
"``index_object:stat().range_size`` содержит максимальное количество "
"байтов в диапазоне;"

#: ../doc/1.10/book/box/box_index.rst:968
msgid ""
"``index_object:stat().dumps_per_compaction`` -- average number of dumps "
"required to trigger major compaction in any range of the LSM tree."
msgstr ""
"``index_object:stat().dumps_per_compaction`` содержит среднее число "
"дампов, которое необходимо для запуска значительного слияния в любом "
"диапазоне LSM-дерева."

#: ../doc/1.10/book/box/box_index.rst:970
msgid ""
"Summary index statistics are also available via :ref:`box.stat.vinyl() "
"<box_introspection-box_stat_vinyl_details>`."
msgstr ""
"С помощью :ref:`box.stat.vinyl() <box_introspection-"
"box_stat_vinyl_details>` можно получить сводную статистику по индексу."

#: ../doc/1.10/book/box/box_index.rst:976
msgid "statistics"
msgstr "статистические данные"

#: ../doc/1.10/book/box/box_index.rst:983
msgid ""
"Remove unused index space. For the memtx storage engine this method does "
"nothing; ``index_object:compact()`` is only for the vinyl storage engine."
" For example, with vinyl, if a tuple is deleted, the space is not "
"immediately reclaimed. There is a scheduler for reclaiming space "
"automatically based on factors such as lsm shape and amplification as "
"discussed in the section :ref:`Storing data with vinyl <engines-vinyl>`, "
"so calling ``index_object:compact()`` manually is not always necessary."
msgstr ""
"Удаление неиспользуемого пространства индекса. Для движка базы данных "
"memtx метод бесполезен; ``index_object:compact()`` используется только "
"для движка vinyl. Например, на движке vinyl при удалении кортежа память "
"не возвращается незамедлительно. Существует планировщик автоматического "
"восстановления ресурсов на основании таких факторов, как форма LSM-дерева"
" и усложнение, как описано в разделе :ref:`Хранение данных с помощью "
"vinyl <engines-vinyl>`, поэтому выполнять ``index_object:compact()`` "
"вручную необходимости нет."

#: ../doc/1.10/book/box/box_index.rst:992
msgid "nil (Tarantool returns without waiting for compaction to complete)"
msgstr ""
"nil (Tarantool возвращает нулевое значение сразу же, не ожидая завершения"
" слияния)"

#: ../doc/1.10/book/box/box_index.rst:999
msgid ""
"Users can define any functions they want, and associate them with "
"indexes: in effect they can make their own index methods. They do this "
"by:"
msgstr ""
"Пользователи могут сами определять любые желаемые функции и связывать их "
"с индексами: фактически они могут создавать собственные методы для работы"
" с индексом. Это можно сделать так:"

#: ../doc/1.10/book/box/box_index.rst:1003
#: ../doc/1.10/book/box/box_space.rst:1527
msgid "creating a Lua function,"
msgstr "создать Lua-функцию,"

#: ../doc/1.10/book/box/box_index.rst:1004
#: ../doc/1.10/book/box/box_space.rst:1528
msgid ""
"adding the function name to a predefined global variable which has type ="
" table, and"
msgstr ""
"добавить имя функции в заданную глобальную переменную с типом \"таблица\""
" (table),"

#: ../doc/1.10/book/box/box_index.rst:1006
msgid ""
"invoking the function any time thereafter, as long as the server is up, "
"by saying ``index_object:function-name([parameters])``."
msgstr ""
"впоследствии в любое время, пока работает сервер, вызвать функцию с "
"помощью ``объект_индекса:имя-функции([параметры])``."

#: ../doc/1.10/book/box/box_index.rst:1009
msgid "There are three predefined global variables:"
msgstr "Есть три заданные глобальные переменные:"

#: ../doc/1.10/book/box/box_index.rst:1011
msgid ""
"Adding to ``box_schema.index_mt`` makes the method available for all "
"indexes."
msgstr ""
"Метод, добавленный в ``box_schema.index_mt``, будет доступен для всех "
"индексов."

#: ../doc/1.10/book/box/box_index.rst:1012
msgid ""
"Adding to ``box_schema.memtx_index_mt`` makes the method available for "
"all memtx indexes."
msgstr ""
"Метод, добавленный в ``box_schema.memtx_index_mt``, будет доступен для "
"всех индексов в memtx'е."

#: ../doc/1.10/book/box/box_index.rst:1013
msgid ""
"Adding to ``box_schema.vinyl_index_mt`` makes the method available for "
"all vinyl indexes."
msgstr ""
"Метод, добавленный в ``box_schema.vinyl_index_mt``, будет доступен для "
"всех индексов в vinyl'е."

#: ../doc/1.10/book/box/box_index.rst:1015
msgid ""
"Alternatively, user-defined methods can be made available for only one "
"index, by calling ``getmetatable(index_object)`` and then adding the "
"function name to the meta table."
msgstr ""
"Можно также сделать задаваемый пользователем метод доступным только для "
"одного индекса путем вызова ``getmetatable(объект_индекса)`` и "
"последующего добавления имени функции в метатаблицу."

#: ../doc/1.10/book/box/box_index.rst:1021
#: ../doc/1.10/book/box/box_space.rst:1543
msgid "whatever the user defines"
msgstr "то, что определяет пользователь"

#: ../doc/1.10/book/box/box_index.rst:1025
msgid ""
"-- Visible to any index of a memtx space, no parameters.\n"
"-- After these requests, the value of global_variable will be 6.\n"
"box.schema.space.create('t', {engine='memtx'})\n"
"box.space.t:create_index('i')\n"
"global_variable = 5\n"
"function f() global_variable = global_variable + 1 end\n"
"box.schema.memtx_index_mt.counter = f\n"
"box.space.t.index.i:counter()"
msgstr ""
"-- Доступный для любого индекса спейса memtx, без параметров.\n"
"-- После таких запросов значение глобальной переменной global_variable "
"будет 6.\n"
"box.schema.space.create('t', {engine='memtx'})\n"
"box.space.t:create_index('i')\n"
"global_variable = 5\n"
"function f() global_variable = global_variable + 1 end\n"
"box.schema.memtx_index_mt.counter = f\n"
"box.space.t.index.i:counter()"

#: ../doc/1.10/book/box/box_index.rst:1038
msgid ""
"-- Visible to index box.space.t.index.i only, 1 parameter.\n"
"-- After these requests, the value of X will be 1005.\n"
"box.schema.space.create('t', {engine='memtx', id = 1000})\n"
"box.space.t:create_index('i')\n"
"X = 0\n"
"i = box.space.t.index.i\n"
"function f(i_arg, param) X = X + param + i_arg.space_id end\n"
"box.schema.memtx_index_mt.counter = f\n"
"meta = getmetatable(i)\n"
"meta.counter = f\n"
"i:counter(5)"
msgstr ""
"-- Доступный только для индекса box.space.t.index.i, 1 параметр.\n"
"-- После таких запросов значение X будет 1005.\n"
"box.schema.space.create('t', {engine='memtx', id = 1000})\n"
"box.space.t:create_index('i')\n"
"X = 0\n"
"i = box.space.t.index.i\n"
"function f(i_arg, param) X = X + param + i_arg.space_id end\n"
"box.schema.memtx_index_mt.counter = f\n"
"meta = getmetatable(i)\n"
"meta.counter = f\n"
"i:counter(5)"

#: ../doc/1.10/book/box/box_index.rst:1054
msgid "Example showing use of the box functions"
msgstr "Пример использования функций box"

#: ../doc/1.10/book/box/box_index.rst:1056
msgid ""
"This example will work with the sandbox configuration described in the "
"preface. That is, there is a space named tester with a numeric primary "
"key. The example function will:"
msgstr ""
"Данный пример сработает на конфигурации из песочницы, описанной в "
"предисловии, то есть создан спейс под названием tester с первичным "
"числовым ключом. Функция в примере выполнит следующие действия:"

#: ../doc/1.10/book/box/box_index.rst:1060
msgid "select a tuple whose key value is 1000;"
msgstr "выбрать кортеж, значение ключа в котором равно 1000;"

#: ../doc/1.10/book/box/box_index.rst:1061
msgid "raise an error if the tuple already exists and already has 3 fields;"
msgstr ""
"выдать сообщение об ошибке, если такой кортеж уже существует и содержит 3"
" поля;"

#: ../doc/1.10/book/box/box_index.rst:1064
msgid "Insert or replace the tuple with:"
msgstr "вставить или заменить кортеж следующими данными:"

#: ../doc/1.10/book/box/box_index.rst:1063
msgid "field[1] = 1000"
msgstr "поле [1] = 1000"

#: ../doc/1.10/book/box/box_index.rst:1064
msgid "field[2] = a uuid"
msgstr "поле [2] = UUID"

#: ../doc/1.10/book/box/box_index.rst:1065
msgid "field[3] = number of seconds since 1970-01-01;"
msgstr "поле [3] = количество секунд с 01.01.1970;"

#: ../doc/1.10/book/box/box_index.rst:1066
msgid "Get field[3] from what was replaced;"
msgstr "получить поле [3] из того, что заменили;"

#: ../doc/1.10/book/box/box_index.rst:1067
msgid "Format the value from field[3] as yyyy-mm-dd hh:mm:ss.ffff;"
msgstr ""
"преобразовать значение из поля [3] в формат yyyy-mm-dd hh:mm:ss.ffff "
"(год-месяц-день час:минута:секунда.десятитысячные доли секунды);"

#: ../doc/1.10/book/box/box_index.rst:1068
msgid "Return the formatted value."
msgstr "вернуть преобразованное значение."

#: ../doc/1.10/book/box/box_index.rst:1070
msgid ""
"The function uses Tarantool box functions :ref:`box.space...select "
"<box_space-select>`, :ref:`box.space...replace <box_space-replace>`, "
":ref:`fiber.time <fiber-time>`, :ref:`uuid.str <uuid-str>`. The function "
"uses Lua functions `os.date()`_ and `string.sub()`_."
msgstr ""
"Данная функция использует функции box в Tarantool'е: "
":ref:`box.space...select <box_space-select>`, :ref:`box.space...replace "
"<box_space-replace>`, :ref:`fiber.time <fiber-time>`, :ref:`uuid.str "
"<uuid-str>`. Данная функция использует Lua-функции `os.date()`_ и "
"`string.sub()`_."

#: ../doc/1.10/book/box/box_index.rst:1079
#, python-format
msgid ""
"function example()\n"
"  local a, b, c, table_of_selected_tuples, d\n"
"  local replaced_tuple, time_field\n"
"  local formatted_time_field\n"
"  local fiber = require('fiber')\n"
"  table_of_selected_tuples = box.space.tester:select{1000}\n"
"  if table_of_selected_tuples ~= nil then\n"
"    if table_of_selected_tuples[1] ~= nil then\n"
"      if #table_of_selected_tuples[1] == 3 then\n"
"        box.error({code=1, reason='This tuple already has 3 fields'})\n"
"      end\n"
"    end\n"
"  end\n"
"  replaced_tuple = box.space.tester:replace\n"
"    {1000,  require('uuid').str(), tostring(fiber.time())}\n"
"  time_field = tonumber(replaced_tuple[3])\n"
"  formatted_time_field = os.date(\"%Y-%m-%d %H:%M:%S\", time_field)\n"
"  c = time_field % 1\n"
"  d = string.sub(c, 3, 6)\n"
"  formatted_time_field = formatted_time_field .. '.' .. d\n"
"  return formatted_time_field\n"
"end"
msgstr ""
"function example()\n"
"  local a, b, c, table_of_selected_tuples, d\n"
"  local replaced_tuple, time_field\n"
"  local formatted_time_field\n"
"  local fiber = require('fiber')\n"
"  table_of_selected_tuples = box.space.tester:select{1000}\n"
"  if table_of_selected_tuples ~= nil then\n"
"    if table_of_selected_tuples[1] ~= nil then\n"
"      if #table_of_selected_tuples[1] == 3 then\n"
"        box.error({code=1, reason='This tuple already has 3 fields'})\n"
"      end\n"
"    end\n"
"  end\n"
"  replaced_tuple = box.space.tester:replace\n"
"    {1000,  require('uuid').str(), tostring(fiber.time())}\n"
"  time_field = tonumber(replaced_tuple[3])\n"
"  formatted_time_field = os.date(\"%Y-%m-%d %H:%M:%S\", time_field)\n"
"  c = time_field % 1\n"
"  d = string.sub(c, 3, 6)\n"
"  formatted_time_field = formatted_time_field .. '.' .. d\n"
"  return formatted_time_field\n"
"end"

#: ../doc/1.10/book/box/box_index.rst:1104
#: ../doc/1.10/book/box/box_tuple.rst:625
msgid "... And here is what happens when one invokes the function:"
msgstr "... А вот что происходит, когда вызывается функция:"

#: ../doc/1.10/book/box/box_index.rst:1106
msgid ""
"tarantool> box.space.tester:delete(1000)\n"
"---\n"
"- [1000, '264ee2da03634f24972be76c43808254', '1391037015.6809']\n"
"...\n"
"tarantool> example(1000)\n"
"---\n"
"- 2014-01-29 16:11:51.1582\n"
"...\n"
"tarantool> example(1000)\n"
"---\n"
"- error: 'This tuple already has 3 fields'\n"
"..."
msgstr ""
"tarantool> box.space.tester:delete(1000)\n"
"---\n"
"- [1000, '264ee2da03634f24972be76c43808254', '1391037015.6809']\n"
"...\n"
"tarantool> example(1000)\n"
"---\n"
"- 2014-01-29 16:11:51.1582\n"
"...\n"
"tarantool> example(1000)\n"
"---\n"
"- error: 'This tuple already has 3 fields'\n"
"..."

#: ../doc/1.10/book/box/box_index.rst:1123
msgid "Example showing a user-defined iterator"
msgstr "Пример с заданным пользователем итератором"

#: ../doc/1.10/book/box/box_index.rst:1125
msgid ""
"Here is an example that shows how to build one's own iterator. The "
"``paged_iter`` function is an \"iterator function\", which will only be "
"understood by programmers who have read the Lua manual section `Iterators"
" and Closures <https://www.lua.org/pil/7.1.html>`_. It does paginated "
"retrievals, that is, it returns 10 tuples at a time from a table named "
"\"t\", whose primary key was defined with "
"``create_index('primary',{parts={1,'string'}})``."
msgstr ""
"Здесь приведен пример того, как создать свой собственный итератор. "
"Функция ``paged_iter`` представляет собой \"функцию с итератором\", что "
"поймут только разработчики, которые ознакомились с разделом руководства "
"по Lua `Итераторы и замыкания <https://www.lua.org/pil/7.1.html>`_. Она "
"делает постраничную выборку, то есть возвращает 10 кортежей одновременно "
"из таблицы под названием \"t\", первичный ключ которой определен с "
"помощью ``create_index('primary',{parts={1,'string'}})``."

#: ../doc/1.10/book/box/box_index.rst:1132
msgid ""
"function paged_iter(search_key, tuples_per_page)\n"
"  local iterator_string = \"GE\"\n"
"  return function ()\n"
"  local page = box.space.t.index[0]:select(search_key,\n"
"    {iterator = iterator_string, limit=tuples_per_page})\n"
"  if #page == 0 then return nil end\n"
"  search_key = page[#page][1]\n"
"  iterator_string = \"GT\"\n"
"  return page\n"
"  end\n"
"end"
msgstr ""
"function paged_iter(search_key, tuples_per_page)\n"
"  local iterator_string = \"GE\"\n"
"  return function ()\n"
"  local page = box.space.t.index[0]:select(search_key,\n"
"    {iterator = iterator_string, limit=tuples_per_page})\n"
"  if #page == 0 then return nil end\n"
"  search_key = page[#page][1]\n"
"  iterator_string = \"GT\"\n"
"  return page\n"
"  end\n"
"end"

#: ../doc/1.10/book/box/box_index.rst:1146
msgid ""
"Programmers who use ``paged_iter`` do not need to know why it works, they"
" only need to know that, if they call it within a loop, they will get 10 "
"tuples at a time until there are no more tuples."
msgstr ""
"Разработчикам, использующим ``paged_iter``, необязательно знать, почему "
"она работает, следует лишь понимать, что вызвав функцию в цикле, можно "
"получать 10 кортежей за раз до тех пор, пока кортежи не кончатся."

#: ../doc/1.10/book/box/box_index.rst:1150
msgid ""
"In this example the tuples are merely printed, a page at a time. But it "
"should be simple to change the functionality, for example by yielding "
"after each retrieval, or by breaking when the tuples fail to match some "
"additional criteria."
msgstr ""
"В данном примере кортежи лишь выводятся по странице за раз. Но легко "
"изменить функцию, например, путем передачи управления после каждой "
"выборки или с помощью прерывания, если кортежи не будут соответствовать "
"дополнительным критериям."

#: ../doc/1.10/book/box/box_index.rst:1155
msgid ""
"for page in paged_iter(\"X\", 10) do\n"
"  print(\"New Page. Number Of Tuples = \" .. #page)\n"
"  for i = 1, #page, 1 do\n"
"    print(page[i])\n"
"  end\n"
"end"
msgstr ""
"for page in paged_iter(\"X\", 10) do\n"
"  print(\"New Page. Number Of Tuples = \" .. #page)\n"
"  for i = 1, #page, 1 do\n"
"    print(page[i])\n"
"  end\n"
"end"

#: ../doc/1.10/book/box/box_index.rst:1168
msgid "Submodule `box.index` with index type = RTREE for spatial searches"
msgstr ""
"Вложенный модуль `box.index` с типом индекса RTREE для поиска в "
"пространственных данных"

#: ../doc/1.10/book/box/box_index.rst:1170
msgid ""
"The :ref:`box.index <box_index>` submodule may be used for spatial "
"searches if the index type is RTREE. There are operations for searching "
"*rectangles* (geometric objects with 4 corners and 4 sides) and *boxes* "
"(geometric objects with more than 4 corners and more than 4 sides, "
"sometimes called hyperrectangles). This manual uses the term *rectangle-"
"or-box* for the whole class of objects that includes both rectangles and "
"boxes. Only rectangles will be illustrated."
msgstr ""
"Вложенный модуль :ref:`box.index <box_index>` может использоваться для "
"поиска в пространственных данных, если тип индекса -- RTREE. Существуют "
"операции для поиска *прямоугольников* (геометрические фигуры с 4 углами и"
" 4 сторонами) и *параллелепипедов* (геометрические фигуры с количеством "
"углов более 4 и количеством сторон более 4, которые иногда называются "
"гиперпрямоугольниками). В данном руководстве используется термин "
"*прямоугольник-или-параллелепипед* для всего класса объектов, который "
"включает в себя прямоугольники и параллелепипеды. Примерами "
"иллюстрируются только прямоугольники."

#: ../doc/1.10/book/box/box_index.rst:1178
msgid ""
"Rectangles are described according to their X-axis (horizontal axis) and "
"Y-axis (vertical axis) coordinates in a grid of arbitrary size. Here is a"
" picture of four rectangles on a grid with 11 horizontal points and 11 "
"vertical points:"
msgstr ""
"Прямоугольники описаны в соответствии с координатами по оси X "
"(горизонтальной оси) и оси Y (вертикальной оси) на сетке произвольного "
"размера. Ниже представлен рисунок четырех прямоугольников на сетке с 11 "
"горизонтальными точками и 11 вертикальными точками:"

#: ../doc/1.10/book/box/box_index.rst:1182
msgid ""
"           X AXIS\n"
"           1   2   3   4   5   6   7   8   9   10  11\n"
"        1\n"
"        2  #-------+                                           "
"<-Rectangle#1\n"
"Y AXIS  3  |       |\n"
"        4  +-------#\n"
"        5          #-----------------------+                   "
"<-Rectangle#2\n"
"        6          |                       |\n"
"        7          |   #---+               |                   "
"<-Rectangle#3\n"
"        8          |   |   |               |\n"
"        9          |   +---#               |\n"
"        10         +-----------------------#\n"
"        11                                     #               "
"<-Rectangle#4"
msgstr ""
"           X AXIS\n"
"                1   2   3   4   5   6   7   8   9   10  11\n"
"             1\n"
"             2  #-------+                                           "
"<-Прямоугольник №1\n"
"     Y AXIS  3  |       |\n"
"             4  +-------#\n"
"             5          #-----------------------+                   "
"<-Прямоугольник №2\n"
"             6          |                       |\n"
"             7          |   #---+               |                   "
"<-Прямоугольник №3\n"
"             8          |   |   |               |\n"
"             9          |   +---#               |\n"
"             10         +-----------------------#\n"
"             11                                     #               "
"<-Прямоугольник №4"

#: ../doc/1.10/book/box/box_index.rst:1198
msgid ""
"The rectangles are defined according to this scheme: {X-axis coordinate "
"of top left, Y-axis coordinate of top left, X-axis coordinate of bottom "
"right, Y-axis coordinate of bottom right} -- or more succinctly: "
"{x1,y1,x2,y2}. So in the picture ... Rectangle#1 starts at position 1 on "
"the X axis and position 2 on the Y axis, and ends at position 3 on the X "
"axis and position 4 on the Y axis, so its coordinates are {1,2,3,4}. "
"Rectangle#2's coordinates are {3,5,9,10}. Rectangle#3's coordinates are "
"{4,7,5,9}. And finally Rectangle#4's coordinates are {10,11,10,11}. "
"Rectangle#4 is actually a \"point\" since it has zero width and zero "
"height, so it could have been described with only two digits: {10,11}."
msgstr ""
"Прямоугольники определяются в соответствии со следующей схемой: {верхняя "
"левая координата по оси X, верхняя левая координата по оси Y, нижняя "
"правая координата по оси X, нижняя правая координата по оси Y} -- или "
"коротко: {x1,y1,x2,y2}. Таким образом, на рисунке ... Прямоугольник № 1 "
"начинается в точке 1 по оси X и точке 2 по оси Y, а заканчивается в точке"
" 3 по оси X и точке 4 по оси Y, поэтому его координаты будут следующие: "
"{1,2,3,4}. Координаты Прямоугольника № 2: {3,5,9,10}. Координаты "
"Прямоугольника № 3: {4,7,5,9}. И наконец, координаты Прямоугольника № 4: "
"{10,11,10,11}. Прямоугольник № 4, на самом деле, является точкой, "
"поскольку у него нулевая ширина и нулевая высота, так что его можно "
"описать всего двумя числами: {10,11}."

#: ../doc/1.10/book/box/box_index.rst:1208
msgid ""
"Some relationships between the rectangles are: \"Rectangle#1's nearest "
"neighbor is Rectangle#2\", and \"Rectangle#3 is entirely inside "
"Rectangle#2\"."
msgstr ""
"Некоторые отношения между прямоугольниками могут быть описаны так: "
"\"Прямоугольник №1 является ближайшим соседом Прямоугольника №2\", а "
"\"Прямоугольник №3 полностью находится внутри Прямоугольника №2\"."

#: ../doc/1.10/book/box/box_index.rst:1211
msgid "Now let us create a space and add an RTREE index."
msgstr "Сейчас создадим спейс и добавим RTREE-индекс."

#: ../doc/1.10/book/box/box_index.rst:1213
msgid ""
"tarantool> s = box.schema.space.create('rectangles')\n"
"tarantool> i = s:create_index('primary', {\n"
"         >   type = 'HASH',\n"
"         >   parts = {1, 'unsigned'}\n"
"         > })\n"
"tarantool> r = s:create_index('rtree', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"
msgstr ""
"tarantool> s = box.schema.space.create('rectangles')\n"
"tarantool> i = s:create_index('primary', {\n"
"         >   type = 'HASH',\n"
"         >   parts = {1, 'unsigned'}\n"
"         > })\n"
"tarantool> r = s:create_index('rtree', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"

#: ../doc/1.10/book/box/box_index.rst:1226
msgid ""
"Field#1 doesn't matter, we just make it because we need a primary-key "
"index. (RTREE indexes cannot be unique and therefore cannot be primary-"
"key indexes.) The second field must be an \"array\", which means its "
"values must represent {x,y} points or {x1,y1,x2,y2} rectangles. Now let "
"us populate the table by inserting two tuples, containing the coordinates"
" of Rectangle#2 and Rectangle#4."
msgstr ""
"Поле №1 не имеет значения, мы создаем его лишь потому, что необходим "
"первичный индекс. (RTREE-индексы не могут быть уникальными, поэтому не "
"могут быть первичными индексами.) Второе поле должно быть массивом "
"(\"array\"), что означает, что его значения должны представлять собой "
"точки {x,y} или прямоугольники {x1,y1,x2,y2}. Заполним таблицу, вставив "
"два кортежа с координатами Прямоугольника №2 и Прямоугольника №4."

#: ../doc/1.10/book/box/box_index.rst:1232
msgid ""
"tarantool> s:insert{1, {3, 5, 9, 10}}\n"
"tarantool> s:insert{2, {10, 11}}"
msgstr ""
"tarantool> s:insert{1, {3, 5, 9, 10}}\n"
"tarantool> s:insert{2, {10, 11}}"

#: ../doc/1.10/book/box/box_index.rst:1237
msgid ""
"And now, following the description of `RTREE iterator types`_, we can "
"search the rectangles with these requests:"
msgstr ""
"Затем, после описания типов RTREE-итераторов (`RTREE iterator types`_), "
"можно произвести поиск прямоугольников с помощью данных запросов:"

#: ../doc/1.10/book/box/box_index.rst:1242
msgid ""
"tarantool> r:select({10, 11, 10, 11}, {iterator = 'EQ'})\n"
"---\n"
"- - [2, [10, 11]]\n"
"...\n"
"tarantool> r:select({4, 7, 5, 9}, {iterator = 'GT'})\n"
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"...\n"
"tarantool> r:select({1, 2, 3, 4}, {iterator = 'NEIGHBOR'})\n"
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"  - [2, [10, 11]]\n"
"..."
msgstr ""
"tarantool> r:select({10, 11, 10, 11}, {iterator = 'EQ'})\n"
"---\n"
"- - [2, [10, 11]]\n"
"...\n"
"tarantool> r:select({4, 7, 5, 9}, {iterator = 'GT'})\n"
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"...\n"
"tarantool> r:select({1, 2, 3, 4}, {iterator = 'NEIGHBOR'})\n"
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"  - [2, [10, 11]]\n"
"..."

#: ../doc/1.10/book/box/box_index.rst:1258
msgid ""
"Request#1 returns 1 tuple because the point {10,11} is the same as the "
"rectangle {10,11,10,11} (\"Rectangle#4\" in the picture). Request#2 "
"returns 1 tuple because the rectangle {4,7,5,9}, which was "
"\"Rectangle#3\" in the picture, is entirely within{3,5,9,10} which was "
"Rectangle#2. Request#3 returns 2 tuples, because the NEIGHBOR iterator "
"always returns all tuples, and the first returned tuple will be "
"{3,5,9,10} (\"Rectangle#2\" in the picture) because it is the closest "
"neighbor of {1,2,3,4} (\"Rectangle#1\" in the picture)."
msgstr ""
"Запрос №1 возвращает 1 кортеж, потому что точка {10,11} представляет "
"собой то же, что и прямоугольник {10,11,10,11} (\"Прямоугольник №4\" на "
"рисунке). Запрос № 2 возвращает 1 кортеж, потому что прямоугольник "
"{4,7,5,9}, который был \"Прямоугольником №3\" на рисунке находится "
"полностью внутри {3,5,9,10}, что представляет собой Прямоугольник № 2. "
"Запрос № 3 возвращает 2 кортежа, потому что итератор NEIGHBOR (сосед) "
"всегда возвращает все кортежи, а первым найденным кортежем будет "
"{3,5,9,10} (\"Прямоугольник №2\" на рисунке), потому что он является "
"ближайшим соседом {1,2,3,4} (\"Прямоугольник №1\" на рисунке)."

#: ../doc/1.10/book/box/box_index.rst:1266
msgid ""
"Now let us create a space and index for cuboids, which are rectangle-or-"
"boxes that have 6 corners and 6 sides."
msgstr ""
"Теперь создадим спейс и индекс для кубоидов, которые представляют собой "
"прямоугольники-или-параллелепипеды, у которых 6 углов и 6 сторон."

#: ../doc/1.10/book/box/box_index.rst:1269
msgid ""
"tarantool> s = box.schema.space.create('R')\n"
"tarantool> i = s:create_index('primary', {parts = {1, 'unsigned'}})\n"
"tarantool> r = s:create_index('S', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   dimension = 3,\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"
msgstr ""
"tarantool> s = box.schema.space.create('R')\n"
"tarantool> i = s:create_index('primary', {parts = {1, 'unsigned'}})\n"
"tarantool> r = s:create_index('S', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   dimension = 3,\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"

#: ../doc/1.10/book/box/box_index.rst:1280
msgid ""
"The additional option here is ``dimension=3``. The default dimension is "
"2, which is why it didn't need to be specified for the examples of "
"rectangle. The maximum dimension is 20. Now for insertions and selections"
" there will usually be 6 coordinates. For example:"
msgstr ""
"Здесь задается дополнительный параметр``dimension=3``. По умолчанию, "
"измерений 2, поэтому не было необходимости указывать данный параметр в "
"примерах для прямоугольника. Максимальное количество измерений -- 20. Что"
" касается вставки и выборки, здесь будет 6 координат. Например:"

#: ../doc/1.10/book/box/box_index.rst:1285
msgid ""
"tarantool> s:insert{1, {0, 3, 0, 3, 0, 3}}\n"
"tarantool> r:select({1, 2, 1, 2, 1, 2}, {iterator = box.index.GT})"
msgstr ""
"tarantool> s:insert{1, {0, 3, 0, 3, 0, 3}}\n"
"tarantool> r:select({1, 2, 1, 2, 1, 2}, {iterator = box.index.GT})"

#: ../doc/1.10/book/box/box_index.rst:1290
msgid ""
"Now let us create a space and index for Manhattan-style spatial objects, "
"which are rectangle-or-boxes that have a different way to calculate "
"neighbors."
msgstr ""
"Теперь создадим спейс и индекс для пространственных объектов с метрикой "
"расстояния городских кварталов (метрика Манхэттена), которые представляют"
" собой прямоугольники-или-параллелепипеды; соседи для них рассчитываются "
"иным образом."

#: ../doc/1.10/book/box/box_index.rst:1293
msgid ""
"tarantool> s = box.schema.space.create('R')\n"
"tarantool> i = s:create_index('primary', {parts = {1, 'unsigned'}})\n"
"tarantool> r = s:create_index('S', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   distance = 'manhattan',\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"
msgstr ""
"tarantool> s = box.schema.space.create('R')\n"
"tarantool> i = s:create_index('primary', {parts = {1, 'unsigned'}})\n"
"tarantool> r = s:create_index('S', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   distance = 'manhattan',\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"

#: ../doc/1.10/book/box/box_index.rst:1304
msgid ""
"The additional option here is ``distance='manhattan'``. The default "
"distance calculator is 'euclid', which is the straightforward as-the-"
"crow-flies method. The optional distance calculator is 'manhattan', which"
" can be a more appropriate method if one is following the lines of a grid"
" rather than traveling in a straight line."
msgstr ""
"Здесь задается дополнительный параметр ``distance='manhattan'``. По "
"умолчанию, расстояние измеряется по Евклидовой метрике, что лучше всего "
"подходит для измерений по прямой линии. Другой способ расчета расстояния "
"по метрике Манхэттена ('manhattan'), который больше подходит, если "
"необходимо следовать линиям сетки, а не по прямой."

#: ../doc/1.10/book/box/box_index.rst:1310
msgid ""
"tarantool> s:insert{1, {0, 3, 0, 3}}\n"
"tarantool> r:select({1, 2, 1, 2}, {iterator = box.index.NEIGHBOR})"
msgstr ""
"tarantool> s:insert{1, {0, 3, 0, 3}}\n"
"tarantool> r:select({1, 2, 1, 2}, {iterator = box.index.NEIGHBOR})"

#: ../doc/1.10/book/box/box_index.rst:1316
msgid ""
"More examples of spatial searching are online in the file `R tree index "
"quick start and usage`_."
msgstr ""
"Другие примеры поиска в пространственных данных см. по ссылке `R tree "
"index quick start and usage`_."

#: ../doc/1.10/book/box/box_info.rst:39
msgid "Submodule `box.info`"
msgstr "Вложенный модуль `box.info`"

#: ../doc/1.10/book/box/box_info.rst:43
msgid ""
"The ``box.info`` submodule provides access to information about server "
"instance variables."
msgstr ""
"Вложенный модуль ``box.info`` предоставляет доступ к информации о "
"переменных экземпляра сервера."

#: ../doc/1.10/book/box/box_info.rst:46
msgid ""
"**cluster.uuid** is the UUID of the replica set. Every instance in a "
"replica set will have the same ``cluster.uuid`` value. This value is also"
" stored in :ref:`box.space._schema <box_space-schema>` system space."
msgstr ""
"**cluster.uuid** -- это уникальный идентификатор набора реплик (UUID). У "
"каждого экземпляра в наборе реплик будет одно и то же значение "
"``cluster.uuid``. Данное значение также хранится в системном спейсе "
":ref:`box.space._schema <box_space-schema>`."

#: ../doc/1.10/book/box/box_info.rst:50
msgid ""
"**gc()** returns the state of the :ref:`Tarantool garbage collector "
"<cfg_checkpoint_daemon-garbage-collector>` including the checkpoints and "
"their consumers (users); see details :ref:`below <box_info_gc>`."
msgstr ""
"**gc()** возвращает состояние :ref:`сборщика мусора в Tarantool'е "
"<cfg_checkpoint_daemon-garbage-collector>`, в том числе контрольные точки"
" и их потребителей (пользователи); более подробную информацию см. :ref: "
"`ниже <box_info_gc>`."

#: ../doc/1.10/book/box/box_info.rst:54
msgid ""
"**id** corresponds to **replication.id** (see :ref:`below "
"<box_info_replication>`)."
msgstr ""
"**id** соответствует идентификатору **replication.id** (см. :ref:`ниже "
"<box_info_replication>`)."

#: ../doc/1.10/book/box/box_info.rst:56
msgid ""
"**lsn** corresponds to **replication.lsn** (see :ref:`below "
"<box_info_replication>`)."
msgstr ""
"**lsn** соответствует регистрационному номеру **replication.lsn** (см. "
":ref:`ниже <box_info_replication>`)."

#: ../doc/1.10/book/box/box_info.rst:58
msgid ""
"**memory()** returns the statistics about memory (see :ref:`below "
"<box_info_memory>`)."
msgstr ""
"**memory()** возвращает статистику об использовании памяти (см. "
":ref:`ниже <box_info_memory>`)."

#: ../doc/1.10/book/box/box_info.rst:60
msgid ""
"**pid** is the process ID. This value is also shown by :ref:`tarantool "
"<tarantool-build>` module and by the Linux command ``ps -A``."
msgstr ""
"**pid** – идентификатор процесса. Это значение также отображается с "
"помощью модуля :ref:`tarantool <tarantool-build>`  и по команде  ``ps "
"-A`` в Linux."

#: ../doc/1.10/book/box/box_info.rst:63
msgid ""
"**ro** is ``true`` if the instance is in \"read-only\" mode (same as "
":ref:`read_only <cfg_basic-read_only>` in ``box.cfg{}``), or if status is"
" 'orphan'."
msgstr ""
"**ro** принимает значение ``true``, если экземпляр находится в режиме "
"только для чтения \"read-only\" (как :ref:`read_only <cfg_basic-"
"read_only>` в ``box.cfg{}``), или в статусе 'orphan' (одиночный)."

#: ../doc/1.10/book/box/box_info.rst:66
msgid ""
"**signature** is the sum of all **lsn** values from the vector clocks "
"(**vclock**) of all instances in the replica set."
msgstr ""
"**signature** представляет собой сумму всех значений **lsn** из векторных"
" часов (**vclock**) всех экземпляров в наборе реплик."

#: ../doc/1.10/book/box/box_info.rst:68
msgid "**status** corresponds to **replication.upstream.status** (see below)."
msgstr ""
"**status** соответствует статусу **replication.upstream.status** (см. "
"ниже)."

#: ../doc/1.10/book/box/box_info.rst:69
msgid ""
"**uptime** is the number of seconds since the instance started. This "
"value can also be retrieved with :ref:`tarantool.uptime() <tarantool-"
"build>`."
msgstr ""
"**uptime** -- это количество секунд с момента запуска экземпляра. Данное "
"значение также можно получить с помощью :ref:`tarantool.uptime() "
"<tarantool-build>`."

#: ../doc/1.10/book/box/box_info.rst:72
msgid ""
"**uuid** corresponds to **replication.uuid** (see :ref:`below "
"<box_info_replication>`)."
msgstr ""
"**uuid** соответствует идентификатору **replication.uuid** (см. "
":ref:`ниже <box_info_replication>`)."

#: ../doc/1.10/book/box/box_info.rst:74
msgid ""
"**vclock** corresponds to **replication.downstream.vclock** (see "
":ref:`below <box_info_replication>`)."
msgstr ""
"**vclock** соответствует часам **replication.downstream.vclock** (см. "
":ref:`ниже <box_info_replication>`)."

#: ../doc/1.10/book/box/box_info.rst:76
msgid ""
"**version** is the Tarantool version. This value is also shown by "
":ref:`tarantool -V <index-tarantool_version>`."
msgstr ""
"**version** -- это версия Tarantool'а. Данное значение также можно "
"отобразить с помощью команды :ref:`tarantool -V <index-"
"tarantool_version>`."

#: ../doc/1.10/book/box/box_info.rst:78
msgid ""
"**vinyl()** returns runtime statistics for the vinyl storage engine. This"
" function is deprecated, use :ref:`box.stat.vinyl() <box_introspection-"
"box_stat_vinyl>` instead."
msgstr ""
"**vinyl** возвращает статистику времени работы для движка базы данных "
"vinyl. Данная функция объявлена устаревшей, используйте "
":ref:`box.stat.vinyl() <box_introspection-box_stat_vinyl>`."

#: ../doc/1.10/book/box/box_info.rst:86
msgid ""
"The **memory** function of ``box.info`` gives the ``admin`` user a "
"picture of the whole Tarantool instance."
msgstr ""
"Функция **memory** в ``box.info`` дает пользователю ``admin`` полное "
"представление об экземпляре Tarantool'а."

#: ../doc/1.10/book/box/box_info.rst:91
msgid ""
"To get a picture of the vinyl subsystem, use :ref:`box.stat.vinyl() "
"<box_introspection-box_stat_vinyl>` instead."
msgstr ""
"Чтобы получить представление о подсистеме vinyl'а, используйте "
":ref:`box.stat.vinyl() <box_introspection-box_stat_vinyl>`."

#: ../doc/1.10/book/box/box_info.rst:94
msgid ""
"**memory().cache** -- number of bytes used for caching user data. The "
"memtx storage engine does not require a cache, so in fact this is the "
"number of bytes in the cache for the tuples stored for the vinyl storage "
"engine."
msgstr ""
"**memory().cache** --это количество байтов, используемых для кэширования "
"данных пользователей. Движок базы данных memtx не нуждается в кэше, то "
"есть на самом деле это количество байтов в кэше для кортежей движка базы "
"данных vinyl."

#: ../doc/1.10/book/box/box_info.rst:98
msgid ""
"**memory().data** -- number of bytes used for storing user data (the "
"tuples) with the memtx engine and with level 0 of the vinyl engine, "
"without taking memory fragmentation into account."
msgstr ""
"**memory().data** -- количество байтов, используемых для хранения данных "
"пользователей (кортежи) в движке memtx и на уровне 0 движка vinyl, не "
"принимая во внимание фрагментацию памяти."

#: ../doc/1.10/book/box/box_info.rst:101
msgid ""
"**memory().index** -- number of bytes used for indexing user data, "
"including memtx and vinyl memory tree extents, the vinyl page index, and "
"the vinyl bloom filters."
msgstr ""
"**memory().index** -- количество байтов, используемых для индексирования "
"данных пользователей, включая экстенты для деревьев в memtx'е и vinyl'е, "
"индекс страниц и фильтры Блума в vinyl'е."

#: ../doc/1.10/book/box/box_info.rst:104
msgid "**memory().lua** -- number of bytes used for Lua runtime."
msgstr ""
"**memory().lua** -- количество байтов, используемых для времени "
"исполнения Lua-кода."

#: ../doc/1.10/book/box/box_info.rst:105
msgid "**memory().net** -- number of bytes used for network input/output buffers."
msgstr ""
"**memory().net** -- количество байтов, используемых буферами для сетевого"
" ввода-вывода."

#: ../doc/1.10/book/box/box_info.rst:106
msgid ""
"**memory().tx** -- number of bytes in use by active transactions. For the"
" vinyl storage engine, this is the total size of all allocated objects "
"(struct ``txv``, struct ``vy_tx``, struct ``vy_read_interval``) and "
"tuples pinned for those objects."
msgstr ""
"**memory().tx** -- количество байтов, используемых активными "
"транзакциями. Для движка базы данных vinyl это общий размер всех "
"размещаемых объектов (структура ``txv``, структура ``vy_tx``, структура "
"``vy_read_interval``) и кортежей, прикрепленных к этим объектам."

#: ../doc/1.10/book/box/box_info.rst:111
msgid ""
"An example with a minimum allocation while only the memtx storage engine "
"is in use:"
msgstr ""
"Пример с минимальным распределением, когда используется только движок "
"базы данных memtx:"

#: ../doc/1.10/book/box/box_info.rst:114
msgid ""
"tarantool> box.info.memory()\n"
"---\n"
"- cache: 0\n"
"  data: 6552\n"
"  tx: 0\n"
"  lua: 1315567\n"
"  net: 98304\n"
"  index: 1196032\n"
"..."
msgstr ""
"tarantool> box.info.memory()\n"
"---\n"
"- cache: 0\n"
"  data: 6552\n"
"  tx: 0\n"
"  lua: 1315567\n"
"  net: 98304\n"
"  index: 1196032\n"
"..."

#: ../doc/1.10/book/box/box_info.rst:130
msgid ""
"The **gc** function of ``box.info`` gives the ``admin`` user a picture of"
" the factors that affect the :ref:`Tarantool garbage collector "
"<cfg_checkpoint_daemon-garbage-collector>`. The garbage collector "
"compares vclock (:ref:`vector clock <replication-vector>`) values of "
"users and checkpoints, so a look at ``box.info.gc()`` may show why the "
"garbage collector has not removed old WAL files, or show what it may soon"
" remove."
msgstr ""
"Функция **gc** в ``box.info`` дает пользователю ``admin`` полное "
"представление о факторах, которые влияют на :ref:`сборщик мусора "
"Tarantool'а <cfg_checkpoint_daemon-garbage-collector>`. Сборщик мусора "
"сопоставляет значения vclock (:ref:`векторные часы <replication-vector>`)"
" пользователей и контрольных точек, поэтому взглянув на "
"``box.info.gc()``, можно понять, почему сборщик мусора не удалил старые "
"WAL-файлы или что он может вскоре удалить."

#: ../doc/1.10/book/box/box_info.rst:137
msgid ""
"**gc().consumers** -- a list of users whose requests might affect the "
"garbage collector."
msgstr ""
"**gc().consumers** -- список пользователей, запросы которых могут  "
"затронуть сборку мусора."

#: ../doc/1.10/book/box/box_info.rst:138
msgid "**gc().checkpoints** -- a list of preserved checkpoints."
msgstr "**gc().checkpoints** -- список сохраненных контрольных точек."

#: ../doc/1.10/book/box/box_info.rst:139
msgid ""
"**gc().checkpoints[n].references** -- a list of references to a "
"checkpoint."
msgstr "**gc().checkpoints[n].references** -- список ссылок на контрольную точку."

#: ../doc/1.10/book/box/box_info.rst:140
msgid "**gc().checkpoints[n].vclock** -- a checkpoint's vclock value."
msgstr "**gc().checkpoints[n].vclock** -- значение vclock контрольной точки."

#: ../doc/1.10/book/box/box_info.rst:141
msgid ""
"**gc().checkpoints[n].signature** -- a sum of a checkpoint's vclock's "
"components."
msgstr ""
"**gc().checkpoints[n].signature** -- сумма компонентов vclock контрольной"
" точки."

#: ../doc/1.10/book/box/box_info.rst:142
msgid ""
"**gc().checkpoint_is_in_progress** -- true if a checkpoint is in "
"progress, otherwise false"
msgstr ""
"**gc().checkpoint_is_in_progress** -- true если идет создание контрольной"
" точки, в противном случае false."

#: ../doc/1.10/book/box/box_info.rst:143
msgid "**gc().vclock** -- the garbage collector's vclock."
msgstr "**gc().vclock** -- vclock сборщика мусора."

#: ../doc/1.10/book/box/box_info.rst:144
msgid ""
"**gc().signature** -- the sum of the garbage collector's checkpoint's "
"components."
msgstr "**gc().signature** -- сумма компонентов контрольной точки сборщика мусора."

#: ../doc/1.10/book/box/box_info.rst:150
msgid ""
"The **replication** section of ``box.info()`` contains statistics for all"
" instances in the replica set in regard to the current instance (see also"
" :ref:`\"Monitoring a replica set\" <replication-monitoring>`):"
msgstr ""
"Раздел **replication** (репликация) во вложенном модуле ``box.info()`` "
"содержит статистику по всем экземплярам в наборе реплик относительно "
"текущего экземпляра (см. также :ref:`\"Мониторинг набора реплик\" "
"<replication-monitoring>`):"

#: ../doc/1.10/book/box/box_info.rst:154
msgid ""
"**replication.id** is a short numeric identifier of the instance within "
"the replica set."
msgstr ""
"**replication.id** -- это короткий числовой идентификатор экземпляра в "
"рамках набора реплик."

#: ../doc/1.10/book/box/box_info.rst:156
msgid ""
"**replication.uuid** is a globally unique identifier of the instance. "
"This value is also stored in :ref:`box.space._cluster <box_space-"
"cluster>` system space."
msgstr ""
"**replication.uuid** -- это глобально-уникальный идентификатор "
"экземпляра. Данное значение также хранится в системном спейсе "
":ref:`box.space._cluster <box_space-cluster>`."

#: ../doc/1.10/book/box/box_info.rst:159
msgid ""
"**replication.lsn** is the :ref:`log sequence number <replication-"
"mechanism>` (LSN) for the latest entry in the instance's :ref:`write "
"ahead log <index-box_persistence>` (WAL)."
msgstr ""
"**replication.lsn** -- это :ref:`номер в журнале <replication-mechanism>`"
" (LSN) для последней записи в :ref:`журнале упреждающей записи <index-"
"box_persistence>` (WAL) экземпляра."

#: ../doc/1.10/book/box/box_info.rst:163
msgid ""
"**replication.upstream** contains statistics for the replication data "
"uploaded by the instance."
msgstr ""
"**replication.upstream** содержит статистику по реплицируемым данным, "
"которые переданы экземпляром."

#: ../doc/1.10/book/box/box_info.rst:165
msgid "**replication.upstream.status** is the replication status of the instance:"
msgstr "**replication.upstream.status** -- это репликационный статус экземпляра:"

#: ../doc/1.10/book/box/box_info.rst:167
msgid ""
"``auth`` means that the instance is getting :ref:`authenticated "
"<authentication>` to connect to a replication source."
msgstr ""
"``auth`` означает, что экземпляр проходит :ref:`аутентификацию "
"<authentication>` для установки соединения с источником репликации."

#: ../doc/1.10/book/box/box_info.rst:170
msgid ""
"``connecting`` means that the instance is trying to connect to the "
"replications source(s) listed in its :ref:`replication <cfg_replication-"
"replication>` parameter."
msgstr ""
"``connecting`` означает, что экземпляр пытается установить соединение с "
"источниками репликации, перечисленными в параметре :ref:`replication "
"<cfg_replication-replication>`."

#: ../doc/1.10/book/box/box_info.rst:173
msgid ""
"``disconnected`` means that the instance is not connected to the replica "
"set (due to network problems, not replication errors)."
msgstr ""
"``disconnected`` означает, что экземпляр не подключен к набору реплик (по"
" причине проблем в сети, а не ошибок репликации)."

#: ../doc/1.10/book/box/box_info.rst:175
msgid "``follow`` means that replication is in progress."
msgstr "``follow`` означает, что идет репликация."

#: ../doc/1.10/book/box/box_info.rst:176
msgid ""
"``running`` means the instance's role is \"master\" (non read-only) and "
"replication is in progress."
msgstr ""
"``running`` означает, что роль экземпляра -- \"мастер\" (не только для "
"чтения), и идет репликация."

#: ../doc/1.10/book/box/box_info.rst:178
msgid ""
"``stopped`` means that replication was stopped due to a replication error"
" (e.g. :ref:`duplicate key <error_codes>`)."
msgstr ""
"``stopped`` означает, что репликация остановилась по причине ошибки "
"репликации (например, :ref:`повторяющийся ключ <error_codes>`)."

#: ../doc/1.10/book/box/box_info.rst:180
msgid ""
"``orphan`` means that the instance has not (yet) succeeded in joining the"
" required number of masters (see :ref:`orphan status <replication-"
"orphan_status>`)."
msgstr ""
"``orphan`` означает, что экземпляр (еще) не подключился к необходимому "
"количеству мастеров (см. :ref:`статус orphan <replication-"
"orphan_status>`)."

#: ../doc/1.10/book/box/box_info.rst:182
msgid ""
"``synch`` means that the master and replica are synchronizing to have the"
" same data."
msgstr ""
"``synch`` означает, что мастер и реплика в данный момент синхронизируются"
" для получения одинакового набора данных."

#: ../doc/1.10/book/box/box_info.rst:187
msgid ""
"**replication.upstream.idle** is the time (in seconds) since the instance"
" received the last event from a master. This is the primary indicator of "
"replication health. See more in :ref:`Monitoring a replica set "
"<replication-monitoring>`."
msgstr ""
"**replication.upstream.idle** -- это время (в секундах) с момента "
"получения экземпляром последнего события от мастера. Это основной "
"индикатор работоспособности репликации. Более подробную информацию см. в "
"разделе :ref:`Мониторинг набора реплик <replication-monitoring>`."

#: ../doc/1.10/book/box/box_info.rst:194
msgid ""
"**replication.upstream.peer** contains the replication user name, host IP"
" adress and port number used for the instance. See more in "
":ref:`Monitoring a replica set <replication-monitoring>`."
msgstr ""
"**replication.upstream.peer** содержит имя пользователя, запустившего "
"репликацию, IP-адрес хоста и номер порта, используемый для экземпляра. "
"Более подробную информацию см. в разделе :ref:`Мониторинг набора реплик "
"<replication-monitoring>`."

#: ../doc/1.10/book/box/box_info.rst:200
msgid ""
"**replication.upstream.lag** is the time difference between the local "
"time at the instance, recorded when the event was received, and the local"
" time at another master recorded when the event was written to the "
":ref:`write ahead log <internals-wal>` on that master. See more in "
":ref:`Monitoring a replica set <replication-monitoring>`."
msgstr ""
"**replication.upstream.lag** -- это разница во времени между локальным "
"временем на экземпляре, зарегистрированным при получении события, и "
"локальное время на другом мастере, зарегистрированное при записи события "
"в :ref:`журнал упреждающей записи <internals-wal>` на этом мастере. Более"
" подробную информацию см. в разделе :ref:`Мониторинг набора реплик "
"<replication-monitoring>`."

#: ../doc/1.10/book/box/box_info.rst:206
msgid ""
"**replication.upstream.message** contains an error message in case of a "
":ref:`degraded state <replication-recover>`, empty otherwise."
msgstr ""
"**replication.upstream.message** содержит сообщение об ошибке в случае "
":ref:`системного сбоя <replication-recover>`, в противном случае не "
"заполнен."

#: ../doc/1.10/book/box/box_info.rst:209
msgid ""
"**replication.downstream** contains statistics for the replication data "
"requested and downloaded from the instance."
msgstr ""
"**replication.downstream** содержит статистику по реплицируемым данным, "
"которые запрошены и загружены с экземпляра."

#: ../doc/1.10/book/box/box_info.rst:212
msgid ""
"**replication.downstream.vclock** contains the :ref:`vector clock "
"<replication-vector>`, which is a table of '**id**, **lsn**' pairs, for "
"example :code:`vclock: {1: 3054773, 4: 8938827, 3: 285902018}`. Even if "
"an instance is :ref:`removed <replication-remove_instances>`, its values "
"will still appear here."
msgstr ""
"**replication.downstream.vclock** содержит :ref:`векторные часы "
"<replication-vector>`, что представляет собой таблицу из пар '**id**, "
"**lsn**', например :code:`vclock: {1: 3054773, 4: 8938827, 3: "
"285902018}`. Даже если экземпляр :ref:`удален <replication-"
"remove_instances>`, тем не менее, значения с него появятся здесь."

#: ../doc/1.10/book/box/box_info.rst:219
msgid ""
"**replication.downstream.status** ``= disconnected`` is displayed if the "
"downstream instance disconnects from the upstream instance. Otherwise the"
" status is not reported."
msgstr ""
"**replication.downstream.status** ``= disconnected`` отображается, если "
"последующий экземпляр отключается от предыдущего. В остальных случаях "
"такой статус не отображается."

#: ../doc/1.10/book/box/box_info.rst:225
msgid ""
"Since ``box.info`` contents are dynamic, it's not possible to iterate "
"over keys with the Lua ``pairs()`` function. For this purpose, "
"``box.info()`` builds and returns a Lua table with all keys and values "
"provided in the submodule."
msgstr ""
"Поскольку содержимое вложенного модуля ``box.info`` является "
"динамическим, невозможно провести итерацию по ключам с помощью "
"Lua-функции ``pairs()``. Для этой цели модуль ``box.info()`` создает и "
"возвращает Lua-таблицу со всеми ключами и значениями во вложенном модуле."

#: ../doc/1.10/book/box/box_info.rst:230
msgid "keys and values in the submodule"
msgstr "ключи и значения во вложенном модуле"

#: ../doc/1.10/book/box/box_info.rst:235
msgid ""
"This example is for a master-replica set that contains one master "
"instance and one replica instance. The request was issued at the replica "
"instance."
msgstr ""
"Данный пример приводится для набора со схемой мастер-реплика, который "
"включает в себя один мастер-экземпляр и один реплика-экземпляр. Запрос "
"был отправлен с реплики-экземпляра."

#: ../doc/1.10/book/box/box_info.rst:238
msgid ""
"tarantool> box.info()\n"
"---\n"
"- version: 1.7.6-68-g51fcffb77\n"
"  id: 2\n"
"  ro: true\n"
"  vclock: {1: 5}\n"
"  uptime: 917\n"
"  lsn: 0\n"
"  vinyl: []\n"
"  cluster:\n"
"    uuid: 783e2285-55b1-42d4-b93c-68dcbb7a8c18\n"
"  pid: 35341\n"
"  status: running\n"
"  signature: 5\n"
"  replication:\n"
"    1:\n"
"      id: 1\n"
"      uuid: 471cd36e-cb2e-4447-ac66-2d28e9dd3b67\n"
"      lsn: 5\n"
"      upstream:\n"
"        status: follow\n"
"        idle: 124.98795700073\n"
"        peer: replicator@192.168.0.101:3301\n"
"        lag: 0\n"
"      downstream:\n"
"        vclock: {1: 5}\n"
"    2:\n"
"      id: 2\n"
"      uuid: ac45d5d2-8a16-4520-ad5e-1abba6baba0a\n"
"      lsn: 0\n"
"  uuid: ac45d5d2-8a16-4520-ad5e-1abba6baba0a\n"
"..."
msgstr ""
"tarantool> box.info()\n"
"---\n"
"- version: 1.7.6-68-g51fcffb77\n"
"  id: 2\n"
"  ro: true\n"
"  vclock: {1: 5}\n"
"  uptime: 917\n"
"  lsn: 0\n"
"  vinyl: []\n"
"  cluster:\n"
"    uuid: 783e2285-55b1-42d4-b93c-68dcbb7a8c18\n"
"  pid: 35341\n"
"  status: running\n"
"  signature: 5\n"
"  replication:\n"
"    1:\n"
"      id: 1\n"
"      uuid: 471cd36e-cb2e-4447-ac66-2d28e9dd3b67\n"
"      lsn: 5\n"
"      upstream:\n"
"        status: follow\n"
"        idle: 124.98795700073\n"
"        peer: replicator@192.168.0.101:3301\n"
"        lag: 0\n"
"      downstream:\n"
"        vclock: {1: 5}\n"
"    2:\n"
"      id: 2\n"
"      uuid: ac45d5d2-8a16-4520-ad5e-1abba6baba0a\n"
"      lsn: 0\n"
"  uuid: ac45d5d2-8a16-4520-ad5e-1abba6baba0a\n"
"..."

#: ../doc/1.10/book/box/box_schema.rst:39
msgid "Submodule `box.schema`"
msgstr "Вложенный модуль `box.schema`"

#: ../doc/1.10/book/box/box_schema.rst:47
msgid ""
"The ``box.schema`` submodule has data-definition functions for spaces, "
"users, roles, function tuples, and sequences."
msgstr ""
"Вложенный модуль ``box.schema`` содержит функции для определения данных "
"для спейсов, пользователей, ролей, кортежей и последовательностей."

#: ../doc/1.10/book/box/box_schema.rst:54
msgid "Below is a list of all ``box.schema`` functions."
msgstr "Ниже приведен перечень всех функций модуля ``box.schema``."

#: ../doc/1.10/book/box/box_schema.rst:64
msgid ":ref:`box.schema.space.create() <box_schema-space_create>`"
msgstr ":ref:`box.schema.space.create() <box_schema-space_create>`"

#: ../doc/1.10/book/box/box_schema.rst:64
msgid "Create a space"
msgstr "Создание спейса"

#: ../doc/1.10/book/box/box_schema.rst:67
msgid ":ref:`box.schema.user.create() <box_schema-user_create>`"
msgstr ":ref:`box.schema.user.create() <box_schema-user_create>`"

#: ../doc/1.10/book/box/box_schema.rst:67
msgid "Create a user"
msgstr "Создание пользователя"

#: ../doc/1.10/book/box/box_schema.rst:70
msgid ":ref:`box.schema.user.drop() <box_schema-user_drop>`"
msgstr ":ref:`box.schema.user.drop() <box_schema-user_drop>`"

#: ../doc/1.10/book/box/box_schema.rst:70
msgid "Drop a user"
msgstr "Удаление пользователя"

#: ../doc/1.10/book/box/box_schema.rst:73
msgid ":ref:`box.schema.user.exists() <box_schema-user_exists>`"
msgstr ":ref:`box.schema.user.exists() <box_schema-user_exists>`"

#: ../doc/1.10/book/box/box_schema.rst:73
msgid "Check if a user exists"
msgstr "Проверка существования пользователя"

#: ../doc/1.10/book/box/box_schema.rst:76
msgid ":ref:`box.schema.user.grant() <box_schema-user_grant>`"
msgstr ":ref:`box.schema.user.grant() <box_schema-user_grant>`"

#: ../doc/1.10/book/box/box_schema.rst:76
msgid "Grant privileges to a user or a role"
msgstr "Выдача прав пользователю или роли"

#: ../doc/1.10/book/box/box_schema.rst:79
msgid ":ref:`box.schema.user.revoke() <box_schema-user_revoke>`"
msgstr ":ref:`box.schema.user.revoke() <box_schema-user_revoke>`"

#: ../doc/1.10/book/box/box_schema.rst:79
msgid "Revoke privileges from a user or a role"
msgstr "Отмена прав пользователя или роли"

#: ../doc/1.10/book/box/box_schema.rst:82
msgid ":ref:`box.schema.user.password() <box_schema-user_password>`"
msgstr ":ref:`box.schema.user.password() <box_schema-user_password>`"

#: ../doc/1.10/book/box/box_schema.rst:82
msgid "Get a hash of a user's password"
msgstr "Получение хеша пароля пользователя"

#: ../doc/1.10/book/box/box_schema.rst:85
msgid ":ref:`box.schema.user.passwd() <box_schema-user_passwd>`"
msgstr ":ref:`box.schema.user.passwd() <box_schema-user_passwd>`"

#: ../doc/1.10/book/box/box_schema.rst:85
msgid "Associate a password with a user"
msgstr "Ассоциация пароля с пользователем"

#: ../doc/1.10/book/box/box_schema.rst:88
msgid ":ref:`box.schema.user.info() <box_schema-user_info>`"
msgstr ":ref:`box.schema.user.info() <box_schema-user_info>`"

#: ../doc/1.10/book/box/box_schema.rst:88
msgid "Get a description of a user's privileges"
msgstr "Получение описания прав пользователя"

#: ../doc/1.10/book/box/box_schema.rst:91
msgid ":ref:`box.schema.role.create() <box_schema-role_create>`"
msgstr ":ref:`box.schema.role.create() <box_schema-role_create>`"

#: ../doc/1.10/book/box/box_schema.rst:91
msgid "Create a role"
msgstr "Создание роли"

#: ../doc/1.10/book/box/box_schema.rst:94
msgid ":ref:`box.schema.role.drop() <box_schema-role_drop>`"
msgstr ":ref:`box.schema.role.drop() <box_schema-role_drop>`"

#: ../doc/1.10/book/box/box_schema.rst:94
msgid "Drop a role"
msgstr "Удаление роли"

#: ../doc/1.10/book/box/box_schema.rst:97
msgid ":ref:`box.schema.role.exists() <box_schema-role_exists>`"
msgstr ":ref:`box.schema.role.exists() <box_schema-role_exists>`"

#: ../doc/1.10/book/box/box_schema.rst:97
msgid "Check if a role exists"
msgstr "Проверка наличия роли"

#: ../doc/1.10/book/box/box_schema.rst:100
msgid ":ref:`box.schema.role.grant() <box_schema-role_grant>`"
msgstr ":ref:`box.schema.role.grant() <box_schema-role_grant>`"

#: ../doc/1.10/book/box/box_schema.rst:100
msgid "Grant privileges to a role"
msgstr "Выдача прав роли"

#: ../doc/1.10/book/box/box_schema.rst:103
msgid ":ref:`box.schema.role.revoke() <box_schema-role_revoke>`"
msgstr ":ref:`box.schema.role.revoke() <box_schema-role_revoke>`"

#: ../doc/1.10/book/box/box_schema.rst:103
msgid "Revoke privileges from a role"
msgstr "Отмена прав роли"

#: ../doc/1.10/book/box/box_schema.rst:106
msgid ":ref:`box.schema.role.info() <box_schema-role_info>`"
msgstr ":ref:`box.schema.role.info() <box_schema-role_info>`"

#: ../doc/1.10/book/box/box_schema.rst:106
msgid "Get a description of a role's privileges"
msgstr "Получение описания прав роли"

#: ../doc/1.10/book/box/box_schema.rst:109
msgid ":ref:`box.schema.func.create() <box_schema-func_create>`"
msgstr ":ref:`box.schema.func.create() <box_schema-func_create>`"

#: ../doc/1.10/book/box/box_schema.rst:109
msgid "Create a function tuple"
msgstr "Создание кортежа с функцией"

#: ../doc/1.10/book/box/box_schema.rst:112
msgid ":ref:`box.schema.func.drop() <box_schema-func_drop>`"
msgstr ":ref:`box.schema.func.drop() <box_schema-func_drop>`"

#: ../doc/1.10/book/box/box_schema.rst:112
msgid "Drop a function tuple"
msgstr "Удаление кортежа с функцией"

#: ../doc/1.10/book/box/box_schema.rst:115
msgid ":ref:`box.schema.func.exists() <box_schema-func_exists>`"
msgstr ":ref:`box.schema.func.exists() <box_schema-func_exists>`"

#: ../doc/1.10/book/box/box_schema.rst:115
msgid "Check if a function tuple exists"
msgstr "Проверка наличия кортежа с функцией"

#: ../doc/1.10/book/box/box_schema.rst:118
msgid ":ref:`box.schema.sequence.create() <box_schema-sequence_create>`"
msgstr ":ref:`box.schema.sequence.create() <box_schema-sequence_create>`"

#: ../doc/1.10/book/box/box_schema.rst:118
msgid "Create a new sequence generator"
msgstr "Создание нового генератора последовательностей"

#: ../doc/1.10/book/box/box_schema.rst:121
msgid ":ref:`sequence_object:next() <box_schema-sequence_next>`"
msgstr ":ref:`sequence_object:next() <box_schema-sequence_next>`"

#: ../doc/1.10/book/box/box_schema.rst:121
msgid "Generate and return the next value"
msgstr "Генерация и возврат следующего значения"

#: ../doc/1.10/book/box/box_schema.rst:124
msgid ":ref:`sequence_object:alter() <box_schema-sequence_alter>`"
msgstr ":ref:`sequence_object:alter() <box_schema-sequence_alter>`"

#: ../doc/1.10/book/box/box_schema.rst:124
msgid "Change sequence options"
msgstr "Изменение параметров последовательности"

#: ../doc/1.10/book/box/box_schema.rst:127
msgid ":ref:`sequence_object:reset() <box_schema-sequence_reset>`"
msgstr ":ref:`sequence_object:reset() <box_schema-sequence_reset>`"

#: ../doc/1.10/book/box/box_schema.rst:127
msgid "Reset sequence state"
msgstr "Сброс состояния последовательности"

#: ../doc/1.10/book/box/box_schema.rst:130
msgid ":ref:`sequence_object:set() <box_schema-sequence_set>`"
msgstr ":ref:`sequence_object:set() <box_schema-sequence_set>`"

#: ../doc/1.10/book/box/box_schema.rst:130
msgid "Set the new value"
msgstr "Установка нового значения"

#: ../doc/1.10/book/box/box_schema.rst:133
msgid ":ref:`sequence_object:drop() <box_schema-sequence_drop>`"
msgstr ":ref:`sequence_object:drop() <box_schema-sequence_drop>`"

#: ../doc/1.10/book/box/box_schema.rst:133
msgid "Drop the sequence"
msgstr "Удаление последовательности"

#: ../doc/1.10/book/box/box_schema.rst:136
msgid ":ref:`space_object:create_index() <box_schema-sequence_create_index>`"
msgstr ":ref:`space_object:create_index() <box_schema-sequence_create_index>`"

#: ../doc/1.10/book/box/box_schema.rst:136
#: ../doc/1.10/book/box/box_space.rst:74
msgid "Create an index"
msgstr "Создание индекса"

#: ../doc/1.10/book/box/box_schema.rst:144
msgid "Create a :ref:`space <index-box_space>`."
msgstr "Создание :ref:`спейса <index-box_space>`."

#: ../doc/1.10/book/box/box_schema.rst:146
msgid ""
"name of space, which should conform to the :ref:`rules for object names "
"<app_server-names>`"
msgstr ""
"имя спейса, которое должно соответствовать :ref:`правилам именования "
"объектов <app_server-names>`"

#: ../doc/1.10/book/box/box_schema.rst:148
msgid "see \"Options for box.schema.space.create\" chart, below"
msgstr "см. таблицу \"Параметры для box.schema.space.create\" ниже"

#: ../doc/1.10/book/box/box_schema.rst:150
msgid "space object"
msgstr "объект спейса"

#: ../doc/1.10/book/box/box_schema.rst:151
#: ../doc/1.10/dev_guide/documentation_guidelines.rst:243
#: ../doc/1.10/reference/reference_lua/fiber.rst:233
#: ../doc/1.10/reference/reference_lua/fiber.rst:272
#: ../doc/1.10/reference/reference_lua/fiber.rst:295
#: ../doc/1.10/reference/reference_lua/fiber.rst:315
#: ../doc/1.10/reference/reference_lua/fio.rst:793
#: ../doc/1.10/reference/reference_lua/http.rst:84
#: ../doc/1.10/reference/reference_lua/iconv.rst:87
#: ../doc/1.10/reference/reference_lua/net_box.rst:244
#: ../doc/1.10/reference/reference_lua/socket.rst:170
#: ../doc/1.10/reference/reference_lua/socket.rst:188
#: ../doc/1.10/reference/reference_lua/socket.rst:419
#: ../doc/1.10/reference/reference_lua/tap.rst:132
msgid "userdata"
msgstr "пользовательские данные"

#: ../doc/1.10/book/box/box_schema.rst:155
msgid "**Options for box.schema.space.create**"
msgstr "**Параметры для box.schema.space.create**"

#: ../doc/1.10/book/box/box_schema.rst:165
#: ../doc/1.10/book/box/box_space.rst:316
#: ../doc/1.10/book/box/data_model.rst:488
msgid "Default"
msgstr "Значение по умолчанию"

#: ../doc/1.10/book/box/box_schema.rst:167
msgid "engine"
msgstr "engine (движок)"

#: ../doc/1.10/book/box/box_schema.rst:167
msgid "'memtx' or 'vinyl'"
msgstr "'memtx' или 'vinyl'"

#: ../doc/1.10/book/box/box_schema.rst:167
#: ../doc/1.10/book/box/box_schema.rst:207
#: ../doc/1.10/book/box/box_schema.rst:423
#: ../doc/1.10/book/box/box_session.rst:141
#: ../doc/1.10/book/box/box_session.rst:161
#: ../doc/1.10/book/box/box_session.rst:169
#: ../doc/1.10/book/box/data_model.rst:191
#: ../doc/1.10/reference/reference_lua/errno.rst:92
#: ../doc/1.10/reference/reference_lua/fiber.rst:369
#: ../doc/1.10/reference/reference_lua/fiber.rst:488
#: ../doc/1.10/reference/reference_lua/fiber.rst:538
#: ../doc/1.10/reference/reference_lua/fio.rst:213
#: ../doc/1.10/reference/reference_lua/fio.rst:235
#: ../doc/1.10/reference/reference_lua/fio.rst:255
#: ../doc/1.10/reference/reference_lua/fio.rst:274
#: ../doc/1.10/reference/reference_lua/json.rst:83
#: ../doc/1.10/reference/reference_lua/msgpack.rst:91
#: ../doc/1.10/reference/reference_lua/pickle.rst:117
#: ../doc/1.10/reference/reference_lua/socket.rst:328
#: ../doc/1.10/reference/reference_lua/socket.rst:362
#: ../doc/1.10/reference/reference_lua/socket.rst:378
#: ../doc/1.10/reference/reference_lua/string.rst:104
#: ../doc/1.10/reference/reference_lua/string.rst:129
#: ../doc/1.10/reference/reference_lua/string.rst:152
#: ../doc/1.10/reference/reference_lua/string.rst:236
#: ../doc/1.10/reference/reference_lua/string.rst:259
#: ../doc/1.10/reference/reference_lua/string.rst:310
#: ../doc/1.10/reference/reference_lua/uri.rst:124
#: ../doc/1.10/reference/reference_lua/utf8.rst:124
#: ../doc/1.10/reference/reference_lua/utf8.rst:310
#: ../doc/1.10/reference/reference_lua/utf8.rst:362
#: ../doc/1.10/reference/reference_lua/utf8.rst:386
#: ../doc/1.10/reference/reference_lua/yaml.rst:82
msgid "string"
msgstr "string (строка)"

#: ../doc/1.10/book/box/box_schema.rst:167
msgid "'memtx'"
msgstr "'memtx'"

#: ../doc/1.10/book/box/box_schema.rst:169
msgid "field_count"
msgstr "field_count (количество полей)"

#: ../doc/1.10/book/box/box_schema.rst:169
msgid ""
"fixed count of :ref:`fields <index-box_tuple>`: for example if "
"field_count=5, it is illegal to insert a tuple with fewer than or more "
"than 5 fields"
msgstr ""
"заданное количество :ref:`полей <index-box_tuple>`: например, если "
"field_count=5, нельзя вставить кортеж с количеством полей, большим или "
"меньшим, чем 5"

#: ../doc/1.10/book/box/box_schema.rst:169
msgid "0 i.e. not fixed"
msgstr "0, то есть не задано"

#: ../doc/1.10/book/box/box_schema.rst:175
msgid "format"
msgstr "format (формат)"

#: ../doc/1.10/book/box/box_schema.rst:175
msgid ""
"field names and types: See the illustrations of format clauses in the "
":ref:`space_object:format() <box_space-format>` description and in the "
":ref:`box.space._space <box_space-space>` example. Optional and usually "
"not specified."
msgstr ""
"имена и типы полей: см. наглядные примеры операторов в описании "
":ref:`space_object:format() <box_space-format>` и в "
":ref:`box.space._space <box_space-space>`. Необязательный параметр, "
"обычно значение не указывается."

#: ../doc/1.10/book/box/box_schema.rst:175
msgid "(blank)"
msgstr "(пустое)"

#: ../doc/1.10/book/box/box_schema.rst:182
#: ../doc/1.10/book/box/box_space.rst:324
msgid "id"
msgstr "id"

#: ../doc/1.10/book/box/box_schema.rst:182
msgid ""
"unique identifier: users can refer to spaces with the id instead of the "
"name"
msgstr ""
"уникальный идентификатор: пользователи могут ссылаться на спейсы "
"посредством идентификатора вместо имени"

#: ../doc/1.10/book/box/box_schema.rst:182
msgid "last space's id, +1"
msgstr "идентификатор последнего спейса +1"

#: ../doc/1.10/book/box/box_schema.rst:186
#: ../doc/1.10/book/box/box_space.rst:328
msgid "if_not_exists"
msgstr "if_not_exists (если отсутствует)"

#: ../doc/1.10/book/box/box_schema.rst:186
msgid ""
"create space only if a space with the same name does not exist already, "
"otherwise do nothing but do not cause an error"
msgstr ""
"спейс создается, только если спейса с таким же именем нет в базе данных, "
"в противном случае эффект отсутствует, но ошибка не выдается"

#: ../doc/1.10/book/box/box_schema.rst:186
#: ../doc/1.10/book/box/box_schema.rst:192
#: ../doc/1.10/book/box/box_schema.rst:199
#: ../doc/1.10/book/box/data_model.rst:500
#: ../doc/1.10/book/box/data_model.rst:510
#: ../doc/1.10/reference/reference_lua/msgpack.rst:244
msgid "false"
msgstr "false (ложь)"

#: ../doc/1.10/book/box/box_schema.rst:192
#: ../doc/1.10/reference/configuration/cfg_basic.rst:128
msgid "is_local"
msgstr "is_local"

#: ../doc/1.10/book/box/box_schema.rst:192
msgid ""
"space contents are :ref:`replication-local <replication-local>`: changes "
"are stored in the :ref:`write-ahead log <internals-wal>` of the local "
"node but there is no :ref:`replication <replication>`."
msgstr ""
"содержимое спейса :ref:`реплицируется локально <replication-local>`: "
"изменения сохраняются в :ref:`журнале упреждающей записи <internals-wal>`"
" локального узла, но не происходит :ref:`репликация <replication>`."

#: ../doc/1.10/book/box/box_schema.rst:199
#: ../doc/1.10/reference/configuration/cfg_basic.rst:126
msgid "temporary"
msgstr "temporary (временный)"

#: ../doc/1.10/book/box/box_schema.rst:199
msgid ""
"space contents are temporary: changes are not stored in the :ref:`write-"
"ahead log <internals-wal>` and there is no :ref:`replication "
"<replication>`. Note re storage engine: vinyl does not support temporary "
"spaces."
msgstr ""
"содержимое спейса хранится временно: изменения не хранятся в "
":ref:`журнале упреждающей записи <internals-wal>`, и не проводится "
":ref:`репликация <replication>`. Примечание по движку базы данных: vinyl "
"не поддерживает временные спейсы."

#: ../doc/1.10/book/box/box_schema.rst:207
#: ../doc/1.10/book/box/box_space.rst:2020
#: ../doc/1.10/book/box/box_space.rst:2023
msgid "user"
msgstr "user (пользователь)"

#: ../doc/1.10/book/box/box_schema.rst:207
msgid ""
"name of the user who is considered to be the space's :ref:`owner "
"<authentication-owners_privileges>` for authorization purposes"
msgstr ""
"имя пользователя, который считается :ref:`владельцем <authentication-"
"owners_privileges>` спейса, для целей авторизации"

#: ../doc/1.10/book/box/box_schema.rst:207
msgid "current user's name"
msgstr "имя текущего пользователя"

#: ../doc/1.10/book/box/box_schema.rst:213
msgid ""
"There are three :ref:`syntax variations <app_server-object_reference>` "
"for object references targeting space objects, for example "
":samp:`box.schema.space.drop({space-id})` will drop a space. However, the"
" common approach is to use functions attached to the space objects, for "
"example :ref:`space_object:drop() <box_space-drop>`."
msgstr ""
"Существуют три :ref:`варианта синтаксиса <app_server-object_reference>` "
"для ссылок на объекты спейса, например, "
":samp:`box.schema.space.drop({id-спейса})` удалит спейс. Однако общий "
"подход заключается в использовании функций, прикрепленных к объектам "
"спейса, например :ref:`space_object:drop() <box_space-drop>`."

#: ../doc/1.10/book/box/box_schema.rst:222
msgid ""
"tarantool> s = box.schema.space.create('space55')\n"
"---\n"
"...\n"
"tarantool> s = box.schema.space.create('space55', {\n"
"         >   id = 555,\n"
"         >   temporary = false\n"
"         > })\n"
"---\n"
"- error: Space 'space55' already exists\n"
"...\n"
"tarantool> s = box.schema.space.create('space55', {\n"
"         >   if_not_exists = true\n"
"         > })\n"
"---\n"
"..."
msgstr ""
"tarantool> s = box.schema.space.create('space55')\n"
"---\n"
"...\n"
"tarantool> s = box.schema.space.create('space55', {\n"
"         >   id = 555,\n"
"         >   temporary = false\n"
"         > })\n"
"---\n"
"- error: Space 'space55' already exists\n"
"...\n"
"tarantool> s = box.schema.space.create('space55', {\n"
"         >   if_not_exists = true\n"
"         > })\n"
"---\n"
"..."

#: ../doc/1.10/book/box/box_schema.rst:240
msgid ""
"After a space is created, usually the next step is to :ref:`create an "
"index <box_space-create_index>` for it, and then it is available for "
"insert, select, and all the other :ref:`box.space <box_space>` functions."
msgstr ""
"Следующим шагом после создания спейса будет :ref:`создание индекса "
"<box_space-create_index>` для него, после чего можно будет выполнять "
"вставку, выборку и другие функции :ref:`box.space <box_space>`."

#: ../doc/1.10/book/box/box_schema.rst:249
msgid ""
"Create a user. For explanation of how Tarantool maintains user data, see "
"section :ref:`Users<authentication-users>` and reference on :ref:`_user "
"<box_space-user>` space."
msgstr ""
"Создание пользователя. Чтобы получить информацию о том, как происходит "
"управление данными пользователя в Tarantool'е, см. раздел "
":ref:`Пользователи <authentication-users>` и справочник по спейсу "
":ref:`_user <box_space-user>`."

#: ../doc/1.10/book/box/box_schema.rst:254
#: ../doc/1.10/book/box/box_schema.rst:346
#: ../doc/1.10/book/box/box_schema.rst:622
#: ../doc/1.10/reference/reference_lua/digest.rst:250
msgid "The possible options are:"
msgstr "Возможные параметры:"

#: ../doc/1.10/book/box/box_schema.rst:256
msgid ""
"``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; "
"``true`` means there should be no error if the user already exists,"
msgstr ""
"``if_not_exists`` (если отсутствует) = ``true|false`` (правда/ложь, по "
"умолчанию ложь) - логическое значение boolean; ``true`` (правда) "
"означает, что ошибка не выпадет, если пользователь уже существует,"

#: ../doc/1.10/book/box/box_schema.rst:259
msgid ""
"``password`` (default = '') - string; the ``password`` = *password* "
"specification is good because in a :ref:`URI <index-uri>` (Uniform "
"Resource Identifier) it is usually illegal to include a user-name without"
" a password."
msgstr ""
"``password`` (пароль) -- строка; указать ``password`` = *password* "
"неплохо, поскольку в :ref:`URI <index-uri>` (унифицированный "
"идентификатор ресурса) обычно нельзя включать имя пользователя без "
"пароля."

#: ../doc/1.10/book/box/box_schema.rst:266
#: ../doc/1.10/book/box/box_space.rst:2110
msgid "The maximum number of users is 32."
msgstr "Максимальное количество пользователей -- 32."

#: ../doc/1.10/book/box/box_schema.rst:268
msgid ""
"name of user, which should conform to the :ref:`rules for object names "
"<app_server-names>`"
msgstr ""
"имя пользователя, которое должно соответствовать :ref:`правилам "
"именования объектов <app_server-names>`"

#: ../doc/1.10/book/box/box_schema.rst:270
msgid "``if_not_exists``, ``password``"
msgstr "``if_not_exists``, ``password``"

#: ../doc/1.10/book/box/box_schema.rst:274
#: ../doc/1.10/book/box/box_schema.rst:295
#: ../doc/1.10/book/box/data_model.rst:639
#: ../doc/1.10/reference/reference_lua/net_box.rst:246
#: ../doc/1.10/reference/reference_lua/net_box.rst:313
#: ../doc/1.10/reference/reference_lua/net_box.rst:444
#: ../doc/1.10/reference/reference_lua/net_box.rst:478
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1327
msgid "**Examples:**"
msgstr "**Примеры:**"

#: ../doc/1.10/book/box/box_schema.rst:276
msgid ""
"box.schema.user.create('Lena')\n"
"box.schema.user.create('Lena', {password = 'X'})\n"
"box.schema.user.create('Lena', {if_not_exists = false})"
msgstr ""
"box.schema.user.create('Lena')\n"
"box.schema.user.create('Lena', {password = 'X'})\n"
"box.schema.user.create('Lena', {if_not_exists = false})"

#: ../doc/1.10/book/box/box_schema.rst:286
msgid ""
"Drop a user. For explanation of how Tarantool maintains user data, see "
"section :ref:`Users <authentication-users>` and reference on :ref:`_user "
"<box_space-user>` space."
msgstr ""
"Удаление пользователя. Чтобы получить информацию о том, как происходит "
"управление данными пользователя в Tarantool'е, см. раздел "
":ref:`Пользователи <authentication-users>` и справочник по спейсу "
":ref:`_user <box_space-user>`."

#: ../doc/1.10/book/box/box_schema.rst:291
#: ../doc/1.10/book/box/box_schema.rst:311
msgid "the name of the user"
msgstr "имя пользователя"

#: ../doc/1.10/book/box/box_schema.rst:292
msgid ""
"``if_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` "
"means there should be no error if the user does not exist."
msgstr ""
"``if_exists`` (если существует) = ``true|false`` (правда/ложь, по "
"умолчанию ложь) - логическое значение boolean; ``true`` (правда) "
"означает, что ошибка не выпадет, если такой пользователь не существует."

#: ../doc/1.10/book/box/box_schema.rst:297
msgid ""
"box.schema.user.drop('Lena')\n"
"box.schema.user.drop('Lena',{if_exists=false})"
msgstr ""
"box.schema.user.drop('Lena')\n"
"box.schema.user.drop('Lena',{if_exists=false})"

#: ../doc/1.10/book/box/box_schema.rst:306
msgid ""
"Return ``true`` if a user exists; return ``false`` if a user does not "
"exist. For explanation of how Tarantool maintains user data, see section "
":ref:`Users <authentication-users>` and reference on :ref:`_user "
"<box_space-user>` space."
msgstr ""
"Возврат ``true`` (правда), если пользователь существует; возврат "
"``false`` (ложь), если пользователь отсутствует. Чтобы получить "
"информацию о том, как происходит управление данными пользователя в "
"Tarantool'е, см. раздел :ref:`Пользователи <authentication-users>` и "
"справочник по спейсу :ref:`_user <box_space-user>`."

#: ../doc/1.10/book/box/box_schema.rst:312
#: ../doc/1.10/book/box/box_schema.rst:524
#: ../doc/1.10/book/box/box_schema.rst:677
#: ../doc/1.10/reference/reference_lua/uuid.rst:162
msgid "bool"
msgstr "логическое значение bool"

#: ../doc/1.10/book/box/box_schema.rst:316
msgid "box.schema.user.exists('Lena')"
msgstr "box.schema.user.exists('Lena')"

#: ../doc/1.10/book/box/box_schema.rst:326
msgid ""
"Grant :ref:`privileges <authentication-owners_privileges>` to a user or "
"to another role."
msgstr ""
"Выдача :ref:`прав <authentication-owners_privileges>` пользователю или "
"другой роли."

#: ../doc/1.10/book/box/box_schema.rst:329
#: ../doc/1.10/book/box/box_schema.rst:371
msgid "the name of the user."
msgstr "имя пользователя."

#: ../doc/1.10/book/box/box_schema.rst:330
#: ../doc/1.10/book/box/box_schema.rst:372
#: ../doc/1.10/book/box/box_schema.rst:541
#: ../doc/1.10/book/box/box_schema.rst:574
msgid ""
"'read' or 'write' or 'execute' or 'create' or 'alter' or 'drop' or a "
"combination."
msgstr ""
"'read' (чтение) или 'write' (запись), или 'execute' (выполнение), или "
"'create' (создание), или 'alter' (изменение), или 'drop' (удаление) или "
"их сочетание."

#: ../doc/1.10/book/box/box_schema.rst:332
#: ../doc/1.10/book/box/box_schema.rst:543
#: ../doc/1.10/book/box/box_schema.rst:576
msgid "'space' or 'function' or 'sequence' or 'role'."
msgstr ""
"'space' (спейс) или 'function' (функция), или 'sequence' "
"(последовательность), или 'role' (роль)."

#: ../doc/1.10/book/box/box_schema.rst:333
msgid "name of object to grant permissions for."
msgstr "имя объекта, на который выдаются права."

#: ../doc/1.10/book/box/box_schema.rst:334
msgid "name of role to grant to user."
msgstr "имя роли, которая назначается пользователю."

#: ../doc/1.10/book/box/box_schema.rst:335
msgid "``grantor``, ``if_not_exists``."
msgstr "``grantor``, ``if_not_exists``."

#: ../doc/1.10/book/box/box_schema.rst:337
msgid ""
"If :samp:`'function','{object-name}'` is specified, then a _func tuple "
"with that object-name must exist."
msgstr ""
"Если есть :samp:`'function','{имя-объекта}'`, то должен существовать "
"кортеж в _func с таким именем объекта."

#: ../doc/1.10/book/box/box_schema.rst:340
#: ../doc/1.10/book/box/box_schema.rst:551
msgid ""
"**Variation:** instead of ``object-type, object-name`` say 'universe' "
"which means 'all object-types and all objects'. In this case, object name"
" is omitted."
msgstr ""
"**Вариант:** вместо ``object-type, object-name`` введите 'universe', что "
"означает 'все типы объектов и все объекты'. В таком случае имя объекта "
"опускается."

#: ../doc/1.10/book/box/box_schema.rst:343
#: ../doc/1.10/book/box/box_schema.rst:383
msgid ""
"**Variation:** instead of ``privilege, object-type, object-name`` say "
"``role-name`` (see section :ref:`Roles <authentication-roles>`)."
msgstr ""
"**Вариант:** вместо ``privilege, object-type, object-name`` введите "
"``role-name`` (имя роли) (см. раздел :ref:`Роли <authentication-roles>`)."

#: ../doc/1.10/book/box/box_schema.rst:348
msgid ""
"``grantor`` = *grantor_name_or_id* -- string or number, for custom "
"grantor,"
msgstr ""
"``grantor`` = *grantor_name_or_id* -- строка или номер для заданного "
"пользователя, выдающего права,"

#: ../doc/1.10/book/box/box_schema.rst:349
msgid ""
"``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; "
"``true`` means there should be no error if the user already has the "
"privilege."
msgstr ""
"``if_not_exists`` (если отсутствует) = ``true|false`` (правда/ложь, по "
"умолчанию ложь) - логическое значение boolean; ``true`` (правда) "
"означает, что ошибка не выпадет, если у пользователя уже есть права."

#: ../doc/1.10/book/box/box_schema.rst:354
msgid ""
"box.schema.user.grant('Lena', 'read', 'space', 'tester')\n"
"box.schema.user.grant('Lena', 'execute', 'function', 'f')\n"
"box.schema.user.grant('Lena', 'read,write', 'universe')\n"
"box.schema.user.grant('Lena', 'Accountant')\n"
"box.schema.user.grant('Lena', 'read,write,execute', 'universe')\n"
"box.schema.user.grant('X', 'read', 'universe', nil, {if_not_exists=true}))"
msgstr ""
"box.schema.user.grant('Lena', 'read', 'space', 'tester')\n"
"box.schema.user.grant('Lena', 'execute', 'function', 'f')\n"
"box.schema.user.grant('Lena', 'read,write', 'universe')\n"
"box.schema.user.grant('Lena', 'Accountant')\n"
"box.schema.user.grant('Lena', 'read,write,execute', 'universe')\n"
"box.schema.user.grant('X', 'read', 'universe', nil, {if_not_exists=true}))"

#: ../doc/1.10/book/box/box_schema.rst:368
msgid ""
"Revoke :ref:`privileges <authentication-owners_privileges>` from a user "
"or from another role."
msgstr ""
"Отмена :ref:`прав <authentication-owners_privileges>` пользователя или "
"другой роли."

#: ../doc/1.10/book/box/box_schema.rst:374
msgid "'space' or 'function' or 'sequence'."
msgstr ""
"'space' (спейс) или 'function' (функция), или 'sequence' "
"(последовательность)."

#: ../doc/1.10/book/box/box_schema.rst:375
msgid "the name of a function or space or sequence."
msgstr "имя функции, спейса или последовательности."

#: ../doc/1.10/book/box/box_schema.rst:377
msgid ""
"The user must exist, and the object must exist, but it is not an error if"
" the user does not have the privilege."
msgstr ""
"Должен существовать пользователь, должен существовать объект, но ошибка "
"не выпадет, если у пользователя нет прав."

#: ../doc/1.10/book/box/box_schema.rst:380
#: ../doc/1.10/book/box/box_schema.rst:582
msgid ""
"**Variation:** instead of ``object-type, object-name`` say 'universe' "
"which means 'all object-types and all objects'."
msgstr ""
"**Вариант:** вместо ``object-type, object-name`` введите 'universe', что "
"означает 'все типы объектов и все объекты'."

#: ../doc/1.10/book/box/box_schema.rst:388
msgid ""
"box.schema.user.revoke('Lena', 'read', 'space', 'tester')\n"
"box.schema.user.revoke('Lena', 'execute', 'function', 'f')\n"
"box.schema.user.revoke('Lena', 'read,write', 'universe')\n"
"box.schema.user.revoke('Lena', 'Accountant')"
msgstr ""
"box.schema.user.revoke('Lena', 'read', 'space', 'tester')\n"
"box.schema.user.revoke('Lena', 'execute', 'function', 'f')\n"
"box.schema.user.revoke('Lena', 'read,write', 'universe')\n"
"box.schema.user.revoke('Lena', 'Accountant')"

#: ../doc/1.10/book/box/box_schema.rst:399
msgid ""
"Return a hash of a user's password. For explanation of how Tarantool "
"maintains passwords, see section :ref:`Passwords <authentication-"
"passwords>` and reference on :ref:`_user <box_space-user>` space."
msgstr ""
"Возврат хеша пароля пользователя. Чтобы получить информацию о том, как "
"происходит управление паролями в Tarantool'е, см. раздел :ref:`Пароли "
"<authentication-passwords>` и справочник по спейсу :ref:`_user "
"<box_space-user>`."

#: ../doc/1.10/book/box/box_schema.rst:405
msgid ""
"If a non-'guest' user has no password, it’s **impossible** to connect to "
"Tarantool using this user. The user is regarded as “internal” only, not "
"usable from a remote connection. Such users can be useful if they have "
"defined some procedures with the :ref:`SETUID <box_schema-func_create>` "
"option, on which privileges are granted to externally-connectable users. "
"This way, external users cannot create/drop objects, they can only invoke"
" procedures."
msgstr ""
"Если у пользователя, который не является пользователем 'guest' нет "
"пароля, **невозможно** подключиться к Tarantool'у через этого "
"пользователя. Пользователь считается только “внутренним”, его нельзя "
"использовать для удаленного подключения. Такие пользователи могут "
"работать, если они определили какие-либо процедуры с помощью :ref:`SETUID"
" <box_schema-func_create>`, на которые есть доступ у пользователей с "
"внешним подключением. Таким образом, внешние пользователи могут не "
"создавать/удалять объекты, а только вызывать процедуры."

#: ../doc/1.10/book/box/box_schema.rst:412
msgid ""
"For the 'guest' user, it’s impossible to set a password: that would be "
"misleading, since 'guest' is the default user on a newly-established "
"connection over a :ref:`binary port <admin-security>`, and Tarantool does"
" not require a password to establish a :ref:`binary connection "
"<box_protocol-iproto_protocol>`. It is, however, possible to change the "
"current user to ‘guest’ by providing the :ref:`AUTH packet <box_protocol-"
"authentication>` with no password at all or an empty password. This "
"feature is useful for connection pools, which want to reuse a connection "
"for a different user without re-establishing it."
msgstr ""
"Для пользователя 'guest' невозможно установить пароль: это бы привело к "
"путанице, поскольку 'guest' является пользователем по умолчанию для "
"любого установленного подключения по :ref:`бинарному порту <admin-"
"security>`, а Tarantool не требует пароль при установке :ref:`бинарного "
"подключения <box_protocol-iproto_protocol>`. Тем не менее, можно сменить "
"текущего пользователя на пользователя ‘guest’, предоставив "
":ref:`AUTH-пакет <box_protocol-authentication>` (пакет авторизации) без "
"пароля или с пустым паролем. Данная функция полезна для пулов соединений,"
" которые хотят повторно использовать соединение для другого пользователя "
"без повторного подключения."

#: ../doc/1.10/book/box/box_schema.rst:422
msgid "password to be hashed"
msgstr "пароль для хеширования"

#: ../doc/1.10/book/box/box_schema.rst:427
msgid "box.schema.user.password('ЛЕНА')"
msgstr "box.schema.user.password('ЛЕНА')"

#: ../doc/1.10/book/box/box_schema.rst:435
msgid ""
"Associate a password with the user who is currently logged in, or with "
"the user specified by user-name. The user must exist and must not be "
"'guest'."
msgstr ""
"Ассоциация пароля с авторизованным пользователем или с указанным именем "
"пользователя. Такой пользователь должен существовать и не быть "
"пользователем 'guest'."

#: ../doc/1.10/book/box/box_schema.rst:438
msgid ""
"Users who wish to change their own passwords should use "
"``box.schema.user.passwd(password)`` syntax."
msgstr ""
"Если пользователь хочет поменять свой пароль, ему следует использовать "
"синтаксис ``box.schema.user.passwd(password)``."

#: ../doc/1.10/book/box/box_schema.rst:441
msgid ""
"Administrators who wish to change passwords of other users should use "
"``box.schema.user.passwd(user-name, password)`` syntax."
msgstr ""
"Если администратор хочет поменять пароль других пользователей, ему "
"следует использовать синтаксис ``box.schema.user.passwd(user-name, "
"password)``."

#: ../doc/1.10/book/box/box_schema.rst:444
msgid "user-name"
msgstr "имя пользователя"

#: ../doc/1.10/book/box/box_schema.rst:445
msgid "password"
msgstr "пароль"

#: ../doc/1.10/book/box/box_schema.rst:449
msgid ""
"box.schema.user.passwd('ЛЕНА')\n"
"box.schema.user.passwd('Lena', 'ЛЕНА')"
msgstr ""
"box.schema.user.passwd('ЛЕНА')\n"
"box.schema.user.passwd('Lena', 'ЛЕНА')"

#: ../doc/1.10/book/box/box_schema.rst:458
msgid ""
"Return a description of a user's :ref:`privileges <authentication-"
"owners_privileges>`. For explanation of how Tarantool maintains user "
"data, see section :ref:`Users <authentication-users>` and reference on "
":ref:`_user <box_space-user>` space."
msgstr ""
"Возврат описания :ref:`прав <authentication-owners_privileges>` "
"пользователя. Чтобы получить информацию о том, как происходит управление "
"данными пользователя в Tarantool'е, см. раздел :ref:`Пользователи "
"<authentication-users>` и справочник по спейсу :ref:`_user <box_space-"
"user>`."

#: ../doc/1.10/book/box/box_schema.rst:463
msgid ""
"the name of the user. This is optional; if it is not supplied, then the "
"information will be for the user who is currently logged in."
msgstr ""
"имя пользователя. Необязательный параметр; если не указать, информация "
"будет для авторизованного пользователя."

#: ../doc/1.10/book/box/box_schema.rst:471
msgid ""
"box.schema.user.info()\n"
"box.schema.user.info('Lena')"
msgstr ""
"box.schema.user.info()\n"
"box.schema.user.info('Lena')"

#: ../doc/1.10/book/box/box_schema.rst:480
msgid ""
"Create a role. For explanation of how Tarantool maintains role data, see "
"section :ref:`Roles <authentication-roles>`."
msgstr ""
"Создание роли. Чтобы получить информацию о том, как происходит управление"
" данными о ролях в Tarantool'е, см. раздел :ref:`Роли <authentication-"
"roles>`."

#: ../doc/1.10/book/box/box_schema.rst:484
msgid ""
"name of role, which should conform to the :ref:`rules for object names "
"<app_server-names>`"
msgstr ""
"имя роли, которое должно соответствовать :ref:`правилам именования "
"объектов <app_server-names>`"

#: ../doc/1.10/book/box/box_schema.rst:486
msgid ""
"``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; "
"``true`` means there should be no error if the role already exists"
msgstr ""
"``if_not_exists`` (если отсутствует) = ``true|false`` (правда/ложь, по "
"умолчанию ложь) - логическое значение boolean; ``true`` (правда) "
"означает, что ошибка не выпадет, если роль уже существует."

#: ../doc/1.10/book/box/box_schema.rst:494
msgid ""
"box.schema.role.create('Accountant')\n"
"box.schema.role.create('Accountant', {if_not_exists = false})"
msgstr ""
"box.schema.role.create('Accountant')\n"
"box.schema.role.create('Accountant', {if_not_exists = false})"

#: ../doc/1.10/book/box/box_schema.rst:503
msgid ""
"Drop a role. For explanation of how Tarantool maintains role data, see "
"section :ref:`Roles <authentication-roles>`."
msgstr ""
"Удаление роли. Чтобы получить информацию о том, как происходит управление"
" данными о ролях в Tarantool'е, см. раздел :ref:`Роли <authentication-"
"roles>`."

#: ../doc/1.10/book/box/box_schema.rst:507
#: ../doc/1.10/book/box/box_schema.rst:523
msgid "the name of the role"
msgstr "имя роли"

#: ../doc/1.10/book/box/box_schema.rst:508
msgid ""
"``if_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` "
"means there should be no error if the role does not exist."
msgstr ""
"``if_exists`` (если существует) = ``true|false`` (правда/ложь, по "
"умолчанию ложь) - логическое значение boolean; ``true`` (правда) "
"означает, что ошибка не выпадет, если такая роль не существует."

#: ../doc/1.10/book/box/box_schema.rst:513
msgid "box.schema.role.drop('Accountant')"
msgstr "box.schema.role.drop('Accountant')"

#: ../doc/1.10/book/box/box_schema.rst:521
msgid ""
"Return ``true`` if a role exists; return ``false`` if a role does not "
"exist."
msgstr ""
"Возврат ``true`` (правда), если роль существует; возврат ``false`` "
"(ложь), если роль отсутствует."

#: ../doc/1.10/book/box/box_schema.rst:528
msgid "box.schema.role.exists('Accountant')"
msgstr "box.schema.role.exists('Accountant')"

#: ../doc/1.10/book/box/box_schema.rst:538
msgid "Grant :ref:`privileges <authentication-owners_privileges>` to a role."
msgstr "Выдача :ref:`прав <authentication-owners_privileges>` роли."

#: ../doc/1.10/book/box/box_schema.rst:540
#: ../doc/1.10/book/box/box_schema.rst:573
#: ../doc/1.10/book/box/box_schema.rst:603
msgid "the name of the role."
msgstr "имя роли."

#: ../doc/1.10/book/box/box_schema.rst:544
#: ../doc/1.10/book/box/box_schema.rst:577
msgid "the name of a function or space or sequence or role."
msgstr "имя функции, спейса, последовательности или роли."

#: ../doc/1.10/book/box/box_schema.rst:545
msgid ""
"``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; "
"``true`` means there should be no error if the role already has the "
"privilege."
msgstr ""
"``if_not_exists`` (если отсутствует) = ``true|false`` (правда/ложь, по "
"умолчанию ложь) - логическое значение boolean; ``true`` (правда) "
"означает, что ошибка не выпадет, если у роли уже есть права."

#: ../doc/1.10/book/box/box_schema.rst:549
msgid "The role must exist, and the object must exist."
msgstr "Должна существовать роль, должен существовать объект."

#: ../doc/1.10/book/box/box_schema.rst:554
msgid ""
"**Variation:** instead of ``privilege, object-type, object-name`` say "
"``role-name`` -- to grant a role to a role."
msgstr ""
"**Вариант:** вместо ``privilege, object-type, object-name`` введите "
"``role-name``, чтобы назначить роль для роли."

#: ../doc/1.10/book/box/box_schema.rst:559
msgid ""
"box.schema.role.grant('Accountant', 'read', 'space', 'tester')\n"
"box.schema.role.grant('Accountant', 'execute', 'function', 'f')\n"
"box.schema.role.grant('Accountant', 'read,write', 'universe')\n"
"box.schema.role.grant('public', 'Accountant')\n"
"box.schema.role.grant('role1', 'role2', nil, nil, {if_not_exists=false})"
msgstr ""
"box.schema.role.grant('Accountant', 'read', 'space', 'tester')\n"
"box.schema.role.grant('Accountant', 'execute', 'function', 'f')\n"
"box.schema.role.grant('Accountant', 'read,write', 'universe')\n"
"box.schema.role.grant('public', 'Accountant')\n"
"box.schema.role.grant('role1', 'role2', nil, nil, {if_not_exists=false})"

#: ../doc/1.10/book/box/box_schema.rst:571
msgid "Revoke :ref:`privileges <authentication-owners_privileges>` from a role."
msgstr "Отмена :ref:`прав <authentication-owners_privileges>` роли."

#: ../doc/1.10/book/box/box_schema.rst:579
msgid ""
"The role must exist, and the object must exist, but it is not an error if"
" the role does not have the privilege."
msgstr ""
"Должна существовать роль, должен существовать объект, но ошибка не "
"выпадет, если у роли нет прав."

#: ../doc/1.10/book/box/box_schema.rst:585
msgid ""
"**Variation:** instead of ``privilege, object-type, object-name`` say "
"``role-name``."
msgstr ""
"**Вариант:** вместо ``privilege, object-type, object-name`` введите "
"``role-name``."

#: ../doc/1.10/book/box/box_schema.rst:590
msgid ""
"box.schema.role.revoke('Accountant', 'read', 'space', 'tester')\n"
"box.schema.role.revoke('Accountant', 'execute', 'function', 'f')\n"
"box.schema.role.revoke('Accountant', 'read,write', 'universe')\n"
"box.schema.role.revoke('public', 'Accountant')"
msgstr ""
"box.schema.role.revoke('Accountant', 'read', 'space', 'tester')\n"
"box.schema.role.revoke('Accountant', 'execute', 'function', 'f')\n"
"box.schema.role.revoke('Accountant', 'read,write', 'universe')\n"
"box.schema.role.revoke('public', 'Accountant')"

#: ../doc/1.10/book/box/box_schema.rst:601
msgid "Return a description of a role's privileges."
msgstr "Возврат описания прав роли."

#: ../doc/1.10/book/box/box_schema.rst:607
msgid "box.schema.role.info('Accountant')"
msgstr "box.schema.role.info('Accountant')"

#: ../doc/1.10/book/box/box_schema.rst:615
msgid ""
"Create a function :ref:`tuple <index-box_tuple>`. This does not create "
"the function itself -- that is done with Lua -- but if it is necessary to"
" grant privileges for a function, box.schema.func.create must be done "
"first. For explanation of how Tarantool maintains function data, see "
"reference on :ref:`_func <box_space-func>` space."
msgstr ""
"Создание :ref:`кортежа <index-box_tuple>` с функцией. Сама функция не "
"создается -- это делается с помощью Lua -- но если необходимо выдать "
"права функции, следует сначала выполнить box.schema.func.create. Чтобы "
"получить информацию о том, как происходит управление данными функций в "
"Tarantool'е, см. справочник по спейсу :ref:`_func <box_space-func>`."

#: ../doc/1.10/book/box/box_schema.rst:624
msgid ""
"``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; "
"``true`` means there should be no error if the ``_func`` tuple already "
"exists."
msgstr ""
"``if_not_exists`` (если отсутствует) = ``true|false`` (правда/ложь, по "
"умолчанию ложь) - логическое значение boolean; ``true`` (правда) "
"означает, что ошибка не выпадет, если кортеж в ``_func`` уже существует."

#: ../doc/1.10/book/box/box_schema.rst:627
msgid ""
"``setuid`` = ``true|false`` (default = false) - with ``true`` to make "
"Tarantool treat the function’s caller as the function’s creator, with "
"full privileges. Remember that SETUID works only over :ref:`binary ports "
"<admin-security>`. SETUID doesn't work if you invoke a function via an "
":ref:`admin console <admin-security>` or inside a Lua script."
msgstr ""
"``setuid`` = ``true|false`` (по умолчанию, false) -- значение ``true`` "
"(правда) заставит Tarantool рассматривать пользователя, вызвавшего "
"функцию, в качестве владельца функции с полными правами. Следует помнить,"
" что SETUID работает только по :ref:`бинарным портам <admin-security>`. "
"SETUID не сработает, если вызвать функцию через :ref:`административную "
"консоль <admin-security>` или в Lua-скрипте."

#: ../doc/1.10/book/box/box_schema.rst:634
msgid "``language`` = 'LUA'|'C' (default = ‘LUA’)."
msgstr "``language`` = 'LUA'|'C' (выбор языка из Lua и C; по умолчанию, ‘LUA’)."

#: ../doc/1.10/book/box/box_schema.rst:636
msgid ""
"name of function, which should conform to the :ref:`rules for object "
"names <app_server-names>`"
msgstr ""
"имя функции, которое должно соответствовать :ref:`правилам именования "
"объектов <app_server-names>`"

#: ../doc/1.10/book/box/box_schema.rst:638
msgid "``if_not_exists``, ``setuid``, ``language``."
msgstr "``if_not_exists``, ``setuid``, ``language``."

#: ../doc/1.10/book/box/box_schema.rst:644
msgid ""
"box.schema.func.create('calculate')\n"
"box.schema.func.create('calculate', {if_not_exists = false})\n"
"box.schema.func.create('calculate', {setuid = false})\n"
"box.schema.func.create('calculate', {language = 'LUA'})"
msgstr ""
"box.schema.func.create('calculate')\n"
"box.schema.func.create('calculate', {if_not_exists = false})\n"
"box.schema.func.create('calculate', {setuid = false})\n"
"box.schema.func.create('calculate', {language = 'LUA'})"

#: ../doc/1.10/book/box/box_schema.rst:655
msgid ""
"Drop a function tuple. For explanation of how Tarantool maintains "
"function data, see reference on :ref:`_func space <box_space-func>`."
msgstr ""
"Удаление кортежа с функцией. Чтобы получить информацию о том, как "
"происходит управление данными функций в Tarantool'е, см. справочник по "
"спейсу :ref:`_func <box_space-func>`."

#: ../doc/1.10/book/box/box_schema.rst:659
#: ../doc/1.10/book/box/box_schema.rst:676
msgid "the name of the function"
msgstr "имя функции"

#: ../doc/1.10/book/box/box_schema.rst:660
msgid ""
"``if_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` "
"means there should be no error if the _func tuple does not exist."
msgstr ""
"``if_exists`` (если существует) = ``true|false`` (правда/ложь, по "
"умолчанию ложь) - логическое значение boolean; ``true`` (правда) "
"означает, что ошибка не выпадет, если кортеж в _func не существует."

#: ../doc/1.10/book/box/box_schema.rst:665
msgid "box.schema.func.drop('calculate')"
msgstr "box.schema.func.drop('calculate')"

#: ../doc/1.10/book/box/box_schema.rst:673
msgid ""
"Return true if a function tuple exists; return false if a function tuple "
"does not exist."
msgstr ""
"Возврат true (правда), если кортеж с функцией существует; возврат false "
"(ложь), если кортеж с функцией отсутствует."

#: ../doc/1.10/book/box/box_schema.rst:681
msgid "box.schema.func.exists('calculate')"
msgstr "box.schema.func.exists('calculate')"

#: ../doc/1.10/book/box/box_schema.rst:689
msgid "Reload a C module with all its functions without restarting the server."
msgstr "Перезагрузка модуля на C (со всеми его функциями) без перезапуска сервера."

#: ../doc/1.10/book/box/box_schema.rst:691
msgid ""
"Under the hood, Tarantool loads a new copy of the module (``*.so`` shared"
" library) and starts routing all new request to the new version. The "
"previous version remains active until all started calls are finished. All"
" shared libraries are loaded with ``RTLD_LOCAL`` (see \"man 3 dlopen\"), "
"therefore multiple copies can co-exist without any problems."
msgstr ""
"С точки зрения внутреннего устройства, Tarantool загружает новую копию "
"модуля (библиотека общего пользования ``*.so``) и запускает маршрутизацию"
" всех новых запросов на новую версию. Предыдущая версия остается активной"
" до тех пор, пока не завершатся все начатые вызовы. Все библиотеки общего"
" пользования загружены с ``RTLD_LOCAL`` (см. \"man 3 dlopen\"), таким "
"образом, множество копий могут работать одновременно без каких-либо "
"проблем."

#: ../doc/1.10/book/box/box_schema.rst:699
msgid ""
"Reload will fail if a module was loaded from Lua script with `ffi.load() "
"<http://luajit.org/ext_ffi_api.html#ffi_load>`_."
msgstr ""
"Перезагрузка не сработает, если модуль был загружен из Lua-скрипта с "
"`ffi.load() <http://luajit.org/ext_ffi_api.html#ffi_load>`_."

#: ../doc/1.10/book/box/box_schema.rst:702
msgid "the name of the module to reload"
msgstr "имя модуля для перезагрузки"

#: ../doc/1.10/book/box/box_schema.rst:706
msgid ""
"-- reload the entire module contents\n"
"box.schema.func.reload('module')"
msgstr ""
"-- перегрузить целиком всё содержимое модуля\n"
"box.schema.func.reload('module')"

#: ../doc/1.10/book/box/box_schema.rst:715
#: ../doc/1.10/book/box/data_model.rst:461
msgid "Sequences"
msgstr "Последовательности"

#: ../doc/1.10/book/box/box_schema.rst:717
msgid ""
"An introduction to sequences is in the :ref:`Sequences <index-"
"box_sequence>` section of the \"Data model\" chapter. Here are the "
"details for each function and option."
msgstr ""
"Вводная информация о последовательностях дается в разделе "
":ref:`Последовательности <index-box_sequence>` главы \"Модель данных\". "
"Здесь же приведена подробная информация о каждой функции и каждом "
"параметре."

#: ../doc/1.10/book/box/box_schema.rst:721
msgid ""
"All functions related to sequences require appropriate :ref:`privileges "
"<authentication-owners_privileges>`."
msgstr ""
"Все функции, связанные с последовательностями, требуют наличия "
"соответствующих :ref:`прав <authentication-owners_privileges>`."

#: ../doc/1.10/book/box/box_schema.rst:728
msgid "Create a new sequence generator."
msgstr "Создание нового генератора последовательностей."

#: ../doc/1.10/book/box/box_schema.rst:730
msgid "the name of the sequence"
msgstr "имя последовательности"

#: ../doc/1.10/book/box/box_schema.rst:732
msgid ""
"see a quick overview in the \"Options for "
"``box.schema.sequence.create()``\" :ref:`chart <index-box_sequence-"
"options>` (in the :ref:`Sequences <index-box_sequence>` section of the "
"\"Data model\" chapter), and see more details below."
msgstr ""
"см. краткий обзор в :ref:`таблице <index-box_sequence-options>` "
"\"Параметры для ``box.schema.sequence.create()``\"  (в разделе "
":ref:`Последовательности <index-box_sequence>` главы \"Модель данных\"), "
"а более подробную информацию ниже."

#: ../doc/1.10/book/box/box_schema.rst:739
msgid "a reference to a new sequence object."
msgstr "ссылка на новый объект последовательности."

#: ../doc/1.10/book/box/box_schema.rst:741
msgid "Options:"
msgstr "Параметры:"

#: ../doc/1.10/book/box/box_schema.rst:743
msgid "``start`` -- the STARTS WITH value. Type = integer, Default = 1."
msgstr "``start`` -- НАЧАЛЬНОЕ значение. Тип = целое число, по умолчанию = 1."

#: ../doc/1.10/book/box/box_schema.rst:745
msgid "``min`` -- the MINIMUM value. Type = integer, Default = 1."
msgstr "``min`` -- МИНИМАЛЬНОЕ значение. Тип = целое число, по умолчанию = 1."

#: ../doc/1.10/book/box/box_schema.rst:747
msgid ""
"``max`` - the MAXIMUM value. Type = integer, Default = "
"9223372036854775807."
msgstr ""
"``max`` --МАКСИМАЛЬНОЕ значение. Тип = целое число, по умолчанию = "
"9223372036854775807."

#: ../doc/1.10/book/box/box_schema.rst:749
msgid ""
"There is a rule: ``min`` <= ``start`` <= ``max``. For example it is "
"illegal to say ``{start=0}`` because then the specified start value (0) "
"would be less than the default min value (1)."
msgstr ""
"Есть следующее правило: ``min`` <= ``start`` <= ``max``. Например, нельзя"
" указать ``{start=0}``, поскольку указанное начальное значение (0) будет "
"меньше, чем минимальное значение, используемое по умолчанию (1)."

#: ../doc/1.10/book/box/box_schema.rst:753
msgid ""
"There is a rule: ``min`` <= next-value <= ``max``. For example, if the "
"next generated value would be 1000, but the maximum value is 999, then "
"that would be considered \"overflow\"."
msgstr ""
"Есть следующее правило: ``min`` <= следующее-значение <= ``max``. "
"Например, если сгенерированное значение будет 1000, но максимальное "
"значение -- 999, это будет считаться переполнением."

#: ../doc/1.10/book/box/box_schema.rst:758
msgid "``cycle`` -- the CYCLE value. Type = bool. Default = false."
msgstr ""
"``cycle`` -- значение ЦИКЛА. Тип = bool (логический), по умолчанию = "
"false (ложь)."

#: ../doc/1.10/book/box/box_schema.rst:760
msgid ""
"If the sequence generator's next value is an overflow number, it causes "
"an error return -- unless ``cycle == true``."
msgstr ""
"Если следующее значение в генераторе последовательности будет "
"переполнением, это вызовет ошибку -- не считая случаев, когда задан цикл "
"(``cycle == true``)."

#: ../doc/1.10/book/box/box_schema.rst:763
msgid ""
"But if ``cycle == true``, the count is started again, at the MINIMUM "
"value or at the MAXIMUM value (not the STARTS WITH value)."
msgstr ""
"Если же ``cycle == true``, отсчет начинается заново с МИНИМАЛЬНОГО "
"значения или с МАКСИМАЛЬНОГО значения (не с НАЧАЛЬНОГО значения)."

#: ../doc/1.10/book/box/box_schema.rst:766
msgid "``cache`` -- the CACHE value. Type = unsigned integer. Default = 0."
msgstr ""
"``cache`` -- значение КЭША. Тип = беззнаковое целое число, по умолчанию ="
" 0."

#: ../doc/1.10/book/box/box_schema.rst:768
msgid "Currently Tarantool ignores this value, it is reserved for future use."
msgstr ""
"В данный момент Tarantool игнорирует это значение, оно зарезервировано "
"для последующего использования."

#: ../doc/1.10/book/box/box_schema.rst:770
msgid "``step`` -- the INCREMENT BY value. Type = integer. Default = 1."
msgstr "``step`` -- значение УВЕЛИЧЕНИЯ. Тип = целое число, по умолчанию = 1."

#: ../doc/1.10/book/box/box_schema.rst:772
msgid "Ordinarily this is what is added to the previous value."
msgstr "Это значение прибавляется к предыдущему."

#: ../doc/1.10/book/box/box_schema.rst:778
msgid "Generate the next value and return it."
msgstr "Генерация и возврат следующего значения."

#: ../doc/1.10/book/box/box_schema.rst:780
msgid "The generation algorithm is simple:"
msgstr "Простой алгоритм для генерации:"

#: ../doc/1.10/book/box/box_schema.rst:782
msgid "If this is the first time, then return the STARTS WITH value."
msgstr "В первый раз вернуть НАЧАЛЬНОЕ значение."

#: ../doc/1.10/book/box/box_schema.rst:783
msgid ""
"If the previous value plus the INCREMENT value is less than the MINIMUM "
"value or greater than the MAXIMUM value, that is \"overflow\", so either "
"raise an error (if ``cycle`` = ``false``) or return the MAXIMUM value (if"
" ``cycle`` = ``true`` and ``step`` < 0) or return the MINIMUM value (if "
"``cycle`` = ``true`` and ``step`` > 0)."
msgstr ""
"Если предыдущее значение плюс значение УВЕЛИЧЕНИЯ меньше, чем МИНИМАЛЬНОЕ"
" значение, или больше, чем МАКСИМАЛЬНОЕ значение, будет переполнение, "
"поэтому либо выдать сообщение об ошибке (если цикл не задан -- ``cycle`` "
"= ``false``) или вернуть МАКСИМАЛЬНОЕ значение (если цикл задан -- "
"``cycle`` = ``true`` -- и ``step`` < 0), или вернуть МИНИМАЛЬНОЕ значение"
" (если цикл задан -- ``cycle`` = ``true`` -- и ``step`` > 0)."

#: ../doc/1.10/book/box/box_schema.rst:789
msgid ""
"If there was no error, then save the returned result, it is now the "
"\"previous value\"."
msgstr ""
"Если ошибки нет, сохранить результат, который становится \"предыдущим "
"значением\"."

#: ../doc/1.10/book/box/box_schema.rst:792
msgid "For example, suppose sequence 'S' has:"
msgstr "Например, предположим, что для последовательности 'S':"

#: ../doc/1.10/book/box/box_schema.rst:794
msgid "``min`` == -6,"
msgstr "``min`` == -6,"

#: ../doc/1.10/book/box/box_schema.rst:795
msgid "``max`` == -1,"
msgstr "``max`` == -1,"

#: ../doc/1.10/book/box/box_schema.rst:796
msgid "``step`` == -3,"
msgstr "``step`` == -3,"

#: ../doc/1.10/book/box/box_schema.rst:797
msgid "``start`` = -2,"
msgstr "``start`` = -2,"

#: ../doc/1.10/book/box/box_schema.rst:798
msgid "``cycle`` = true,"
msgstr "``cycle`` = true,"

#: ../doc/1.10/book/box/box_schema.rst:799
msgid "previous value = -2."
msgstr "предыдущее значение = -2."

#: ../doc/1.10/book/box/box_schema.rst:801
msgid "Then ``box.sequence.S:next()`` returns -5 because -2 + (-3) == -5."
msgstr "Тогда ``box.sequence.S:next()`` вернет -5, потому что -2 + (-3) == -5."

#: ../doc/1.10/book/box/box_schema.rst:803
msgid ""
"Then ``box.sequence.S:next()`` again returns -1 because -5 + (-3) < -6, "
"which is overflow, causing cycle, and ``max`` == -1."
msgstr ""
"Затем ``box.sequence.S:next()`` снова вернет -1, потому что -5 + (-3) < "
"-6, что будет переполнением, которое вызовет цикл, а ``max`` == -1."

#: ../doc/1.10/book/box/box_schema.rst:806
msgid ""
"This function requires a :ref:`'write' privilege <box_schema-user_grant>`"
" on the sequence."
msgstr ""
"Для данной функции необходимы права на :ref:`запись ('write') "
"<box_schema-user_grant>` на последовательность."

#: ../doc/1.10/book/box/box_schema.rst:811
msgid ""
"This function should not be used in \"cross-engine\" transactions "
"(transactions which use both the memtx and the vinyl storage engines)."
msgstr ""
"Данную функцию не следует использовать в транзакциях между движками "
"(транзакции, в которых используется и движок memtx, и движок vinyl)."

#: ../doc/1.10/book/box/box_schema.rst:814
msgid ""
"To see what the previous value was, without changing it, you can select "
"from the :ref:`_sequence_data <box_space-sequence_data>` system space."
msgstr ""
"Чтобы увидеть предыдущее значение, не изменяя его, сделайте выборку из "
"системного спейса :ref:`_sequence_data <box_space-sequence_data>`."

#: ../doc/1.10/book/box/box_schema.rst:822
msgid ""
"The ``alter()`` function can be used to change any of the sequence's "
"options. Requirements and restrictions are the same as for "
":ref:`box.schema.sequence.create() <box_schema-sequence_create>`."
msgstr ""
"Функцию ``alter()`` можно использовать для изменения любых параметров "
"последовательности. Требования и ограничения в данном случае такие же, "
"как для :ref:`box.schema.sequence.create() <box_schema-sequence_create>`."

#: ../doc/1.10/book/box/box_schema.rst:830
msgid ""
"Set the sequence back to its original state. The effect is that a "
"subsequent ``next()`` will return the ``start`` value. This function "
"requires a :ref:`'write' privilege <box_schema-user_grant>` on the "
"sequence."
msgstr ""
"Возврат последовательности в оригинальное состояние. Смысл в том, что "
"последующий вызов ``next()`` вернет начальное значение ``start``. Для "
"данной функции необходимы права на :ref:`запись ('write') <box_schema-"
"user_grant>` на последовательность."

#: ../doc/1.10/book/box/box_schema.rst:839
msgid ""
"Set the \"previous value\" to ``new-previous-value``. This function "
"requires a :ref:`'write' privilege <box_schema-user_grant>` on the "
"sequence."
msgstr ""
"Установите \"предыдущее значение\" на ``new-previous-value`` (новое "
"предыдущее значение). Для данной функции необходимы права на :ref:`запись"
" ('write') <box_schema-user_grant>` на последовательность."

#: ../doc/1.10/book/box/box_schema.rst:847
msgid "Drop an existing sequence."
msgstr "Удаление существующей последовательности."

#: ../doc/1.10/book/box/box_schema.rst:851
msgid "Here is an example showing all sequence options and operations:"
msgstr ""
"Ниже представлен пример, иллюстрирующий все параметры и операции для "
"последовательностей:"

#: ../doc/1.10/book/box/box_schema.rst:853
msgid ""
"s = box.schema.sequence.create(\n"
"               'S2',\n"
"               {start=100,\n"
"               min=100,\n"
"               max=200,\n"
"               cache=100000,\n"
"               cycle=false,\n"
"               step=100\n"
"               })\n"
"s:alter({step=6})\n"
"s:next()\n"
"s:reset()\n"
"s:set(150)\n"
"s:drop()"
msgstr ""
"s = box.schema.sequence.create(\n"
"               'S2',\n"
"               {start=100,\n"
"               min=100,\n"
"               max=200,\n"
"               cache=100000,\n"
"               cycle=false,\n"
"               step=100\n"
"               })\n"
"s:alter({step=6})\n"
"s:next()\n"
"s:reset()\n"
"s:set(150)\n"
"s:drop()"

#: ../doc/1.10/book/box/box_schema.rst:874
msgid ""
"You can use the :samp:`sequence={sequence-name}` (or :samp:`sequence"
"={sequence-id}` or :samp:`sequence=true`) option when :ref:`creating "
"<box_space-create_index>` or :ref:`altering <box_index-alter>` a primary-"
"key index. The sequence becomes associated with the index, so that the "
"next ``insert()`` will put the next generated number into the primary-key"
" field, if the field would otherwise be nil."
msgstr ""
"Можно использовать опцию :samp:`sequence={имя-последовательности}` (или "
":samp:`sequence={id-последовательности}`, или :samp:`sequence=true`) при "
":ref:`создании <box_space-create_index>` или :ref:`изменении <box_index-"
"alter>` первичного индекса. Происходит ассоциация последовательности с "
"индексом, так что следующий вызов ``insert()`` поместит следующее "
"сгенерированное число в поле первичного ключа, если в противном случае "
"поле было бы nil."

#: ../doc/1.10/book/box/box_schema.rst:882
msgid ""
"For example, if 'Q' is a sequence and 'T' is a new space, then this will "
"work:"
msgstr ""
"Например, если 'Q' -- это последовательность, а 'T' -- это новый спейс, "
"то сработает:"

#: ../doc/1.10/book/box/box_schema.rst:885
msgid ""
"tarantool> box.space.T:create_index('Q',{sequence='Q'})\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: unsigned\n"
"    is_nullable: false\n"
"    fieldno: 1\n"
"  sequence_id: 8\n"
"  id: 0\n"
"  space_id: 514\n"
"  name: Q\n"
"  type: TREE\n"
"..."
msgstr ""
"tarantool> box.space.T:create_index('Q',{sequence='Q'})\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: unsigned\n"
"    is_nullable: false\n"
"    fieldno: 1\n"
"  sequence_id: 8\n"
"  id: 0\n"
"  space_id: 514\n"
"  name: Q\n"
"  type: TREE\n"
"..."

#: ../doc/1.10/book/box/box_schema.rst:901
msgid "(Notice that the index now has a ``sequence_id`` field.)"
msgstr ""
"(Обратите внимание, что теперь в индексе есть поле идентификатора "
"последовательности ``sequence_id``.)"

#: ../doc/1.10/book/box/box_schema.rst:903
msgid "And this will work:"
msgstr "И сработает:"

#: ../doc/1.10/book/box/box_schema.rst:905
msgid ""
"tarantool> box.space.T:insert{nil,0}\n"
"---\n"
"- [1, 0]\n"
"..."
msgstr ""
"tarantool> box.space.T:insert{nil,0}\n"
"---\n"
"- [1, 0]\n"
"..."

#: ../doc/1.10/book/box/box_schema.rst:914
msgid ""
"If you are using negative numbers for the sequence options, make sure "
"that the index key type is 'integer'. Otherwise the index key type may be"
" either 'integer' or 'unsigned'."
msgstr ""
"Если вы используете отрицательные числа в параметрах последовательности, "
"убедитесь, что тип ключа индекса будет целое число 'integer'. В противном"
" случае, тип ключа может быть либо 'integer', либо 'unsigned' (без "
"знака)."

#: ../doc/1.10/book/box/box_schema.rst:918
msgid ""
"A sequence cannot be dropped if it is associated with an index. However, "
":ref:`index_object:alter() <box_index-alter>` can be used to say that a "
"sequence is not associated with an index, for example "
"``box.space.T.index.I:alter({sequence=false})``."
msgstr ""
"Последовательность нельзя удалить, если она связана с индексом. Тем не "
"менее, можно использовать :ref:`index_object:alter() <box_index-alter>`, "
"чтобы показать, что последовательность не связана с индексом, например "
"так ``box.space.T.index.I:alter({sequence=false})``."

#: ../doc/1.10/book/box/box_session.rst:39
msgid "Submodule `box.session`"
msgstr "Вложенный модуль `box.session`"

#: ../doc/1.10/book/box/box_session.rst:45
msgid ""
"The ``box.session`` submodule allows querying the session state, writing "
"to a session-specific temporary Lua table, or sending out-of-band "
"messages, or setting up triggers which will fire when a session starts or"
" ends."
msgstr ""
"Вложенный модуль ``box.session`` позволяет делать запросы состояния "
"сессии, вносить записи во временную Lua-таблицу по отдельной сессии, "
"отправлять экстренные сообщения и настраивать триггеры, которые сработают"
" в начале или окончании сессии."

#: ../doc/1.10/book/box/box_session.rst:49
msgid "A *session* is an object associated with each client connection."
msgstr "*Сессия* -- это объект, связанный с каждым подключением клиента."

#: ../doc/1.10/book/box/box_session.rst:55
msgid "Below is a list of all ``box.session`` functions and members."
msgstr "Ниже приведен перечень всех функций и элементов модуля ``box.session``."

#: ../doc/1.10/book/box/box_session.rst:65
msgid ":ref:`box.session.id() <box_session-id>`"
msgstr ":ref:`box.session.id() <box_session-id>`"

#: ../doc/1.10/book/box/box_session.rst:65
msgid "Get the current session's ID"
msgstr "Получение идентификатора текущей сессии"

#: ../doc/1.10/book/box/box_session.rst:68
msgid ":ref:`box.session.exists() <box_session-exists>`"
msgstr ":ref:`box.session.exists() <box_session-exists>`"

#: ../doc/1.10/book/box/box_session.rst:68
msgid "Check if a session exists"
msgstr "Проверка наличия сессии"

#: ../doc/1.10/book/box/box_session.rst:71
msgid ":ref:`box.session.peer() <box_session-peer>`"
msgstr ":ref:`box.session.peer() <box_session-peer>`"

#: ../doc/1.10/book/box/box_session.rst:71
msgid "Get the session peer's host address and port"
msgstr "Получение адреса хоста и порта подключенного узла"

#: ../doc/1.10/book/box/box_session.rst:74
msgid ":ref:`box.session.sync() <box_session-sync>`"
msgstr ":ref:`box.session.sync() <box_session-sync>`"

#: ../doc/1.10/book/box/box_session.rst:74
msgid "Get the sync integer constant"
msgstr "Получение целочисленной константы sync"

#: ../doc/1.10/book/box/box_session.rst:77
msgid ":ref:`box.session.user() <box_session-user>`"
msgstr ":ref:`box.session.user() <box_session-user>`"

#: ../doc/1.10/book/box/box_session.rst:77
msgid "Get the current user's name"
msgstr "Получение имени текущего пользователя"

#: ../doc/1.10/book/box/box_session.rst:80
msgid ":ref:`box.session.type() <box_session-type>`"
msgstr ":ref:`box.session.type() <box_session-type>`"

#: ../doc/1.10/book/box/box_session.rst:80
msgid "Get the connection type or cause of action"
msgstr "Получение типа соединения или повода к действию"

#: ../doc/1.10/book/box/box_session.rst:83
msgid ":ref:`box.session.su() <box_session-su>`"
msgstr ":ref:`box.session.su() <box_session-su>`"

#: ../doc/1.10/book/box/box_session.rst:83
msgid "Change the current user"
msgstr "Изменение текущего пользователя"

#: ../doc/1.10/book/box/box_session.rst:86
msgid ":ref:`box.session.uid() <box_session-uid>`"
msgstr ":ref:`box.session.uid() <box_session-uid>`"

#: ../doc/1.10/book/box/box_session.rst:86
msgid "Get the current user's ID"
msgstr "Получение идентификатора текущего пользователя"

#: ../doc/1.10/book/box/box_session.rst:89
msgid ":ref:`box.session.euid() <box_session-euid>`"
msgstr ":ref:`box.session.euid() <box_session-euid>`"

#: ../doc/1.10/book/box/box_session.rst:89
msgid "Get the current effective user's ID"
msgstr "Получение идентификатора текущего действующего пользователя"

#: ../doc/1.10/book/box/box_session.rst:92
msgid ":ref:`box.session.storage <box_session-storage>`"
msgstr ":ref:`box.session.storage <box_session-storage>`"

#: ../doc/1.10/book/box/box_session.rst:92
msgid "Table with session-specific names and values"
msgstr "Таблица с именами и значениями по сессии"

#: ../doc/1.10/book/box/box_session.rst:95
msgid ":ref:`box.session.on_connect() <box_session-on_connect>`"
msgstr ":ref:`box.session.on_connect() <box_session-on_connect>`"

#: ../doc/1.10/book/box/box_session.rst:95
msgid "Define a connect trigger"
msgstr "Определение триггера для подключения"

#: ../doc/1.10/book/box/box_session.rst:98
msgid ":ref:`box.session.on_disconnect() <box_session-on_disconnect>`"
msgstr ":ref:`box.session.on_disconnect() <box_session-on_disconnect>`"

#: ../doc/1.10/book/box/box_session.rst:98
msgid "Define a disconnect trigger"
msgstr "Определение триггера для отключения"

#: ../doc/1.10/book/box/box_session.rst:101
msgid ":ref:`box.session.on_auth() <box_session-on_auth>`"
msgstr ":ref:`box.session.on_auth() <box_session-on_auth>`"

#: ../doc/1.10/book/box/box_session.rst:101
msgid "Define an authentication trigger"
msgstr "Определение триггера для аутентификации"

#: ../doc/1.10/book/box/box_session.rst:104
msgid ":ref:`box.session.push() <box_session-push>`"
msgstr ":ref:`box.session.push() <box_session-push>`"

#: ../doc/1.10/book/box/box_session.rst:104
msgid "Send an out-of-band message"
msgstr "Отправка внеполосного сообщения"

#: ../doc/1.10/book/box/box_session.rst:115
msgid ""
"the unique identifier (ID) for the current session. The result can be 0 "
"or -1 meaning there is no session."
msgstr ""
"уникальный идентификатор (ID) для текущей сессии. Результатом может быть "
"0 или -1, что означает, что сессии нет."

#: ../doc/1.10/book/box/box_session.rst:123
msgid "1 if the session exists, 0 if the session does not exist."
msgstr "1, если сессия есть; 0, если сессии нет."

#: ../doc/1.10/book/box/box_session.rst:130
msgid ""
"This function works only if there is a peer, that is, if a connection has"
" been made to a separate Tarantool instance."
msgstr ""
"Данная функция сработает только в том случае, если есть подключенная "
"программа, то есть если было выполнено подключение к отдельному "
"экземпляру Tarantool'а."

#: ../doc/1.10/book/box/box_session.rst:133
msgid ""
"The host address and port of the session peer, for example "
"\"127.0.0.1:55457\". If the session exists but there is no connection to "
"a separate instance, the return is null. The command is executed on the "
"server instance, so the \"local name\" is the server instance's host and "
"port, and the \"peer name\" is the client's host and port."
msgstr ""
"Адрес хоста и порт подключенного узла, например \"127.0.0.1:55457\". Если"
" существует сессия, но отсутствует подключение к отдельному экземпляру, "
"вернется null. Команда выполняется на экземпляре сервера,  поэтому "
"\"локальное имя\" -- это хост и порт экземпляра сервера, а \"имя узла\" "
"-- это хост и порт клиента."

#: ../doc/1.10/book/box/box_session.rst:143
msgid "Possible errors: 'session.peer(): session does not exist'"
msgstr "Возможные ошибки: 'session.peer(): сессия отсутствует'"

#: ../doc/1.10/book/box/box_session.rst:149
msgid ""
"the value of the :code:`sync` integer constant used in the `binary "
"protocol "
"<https://github.com/tarantool/tarantool/blob/1.10/src/box/iproto_constants.h>`_."
" This value becomes invalid when the session is disconnected."
msgstr ""
"значение целочисленной константы :code:`sync`, используемой в `бинарном "
"протоколе "
"<https://github.com/tarantool/tarantool/blob/1.10/src/box/iproto_constants.h>`_."
" Это значение будет недействительным после отключения сессии."

#: ../doc/1.10/book/box/box_session.rst:159
msgid "the name of the :ref:`current user <authentication-users>`"
msgstr "имя :ref:`текущего пользователя <authentication-users>`"

#: ../doc/1.10/book/box/box_session.rst:167
msgid "the type of connection or cause of action."
msgstr "тип соединения или повод к действию."

#: ../doc/1.10/book/box/box_session.rst:171
msgid "Possible return values are:"
msgstr "Возможные возвращаемые значения:"

#: ../doc/1.10/book/box/box_session.rst:173
msgid ""
"'binary' if the connection was done via the binary protocol, for example "
"to a target made with :ref:`box.cfg{listen=...} <cfg_basic-listen>`;"
msgstr ""
"'binary' (бинарное), если подключение было выполнено по бинарному "
"протоколу, например, к объекту с помощью :ref:`box.cfg{listen=...} "
"<cfg_basic-listen>`;"

#: ../doc/1.10/book/box/box_session.rst:176
msgid ""
"'console' if the connection was done via the administrative console, for "
"example to a target made with :ref:`console.listen <console-listen>`;"
msgstr ""
"'console' (консоль), если подключение было выполнено по административной "
"консоли, например, к объекту с помощью :ref:`console.listen <console-"
"listen>`;"

#: ../doc/1.10/book/box/box_session.rst:179
msgid ""
"'repl' if the connection was done directly, for example when :ref:`using "
"Tarantool as a client <admin-using_tarantool_as_a_client>`;"
msgstr ""
"'repl' (репликация), если подключение было выполнено напрямую, например, "
"при :ref:`использовании Tarantool'а в качестве клиента <admin-"
"using_tarantool_as_a_client>`;"

#: ../doc/1.10/book/box/box_session.rst:181
msgid ""
"'applier' if the action is due to :ref:`replication <replication>`, "
"regardless of how the connection was done;"
msgstr ""
"'applier' (наложение), если действие происходит по причине "
":ref:`репликации <replication>`, независимо от типа подключения;"

#: ../doc/1.10/book/box/box_session.rst:184
msgid ""
"'background' if the action is in a :ref:`background fiber <fiber-"
"module>`, regardless of whether the Tarantool server was :ref:`started in"
" the background <cfg_basic-background>`."
msgstr ""
"'background' (в фоне), если действие происходит в :ref:`фоновом файбере "
"<fiber-module>`, независимо от того, был ли Tarantool :ref:`запущен в "
"фоновом режиме <cfg_basic-background>`."

#: ../doc/1.10/book/box/box_session.rst:189
msgid ""
"``box.session.type()`` is useful for an :ref:`on_replace() <box_space-"
"on_replace>` trigger on a replica -- the value will be 'applier' if and "
"only if the trigger was activated because of a request that was done on "
"the master."
msgstr ""
"``box.session.type()`` используется для триггера при замене "
":ref:`on_replace() <box_space-on_replace>` на реплике -- значение будет "
"'applier' только в том случае, если триггер был активирован по причине "
"запроса, выполненного на мастере."

#: ../doc/1.10/book/box/box_session.rst:199
msgid ""
"Change Tarantool's :ref:`current user <authentication-users>` -- this is "
"analogous to the Unix command ``su``."
msgstr ""
"Изменение :ref:`текущего пользователя <authentication-users>` Tarantool'а"
" -- аналогично Unix-команде ``su``."

#: ../doc/1.10/book/box/box_session.rst:202
msgid ""
"Or, if function-to-execute is specified, change Tarantool's :ref:`current"
" user <authentication-users>` temporarily while executing the function --"
" this is analogous to the Unix command ``sudo``."
msgstr ""
"Или, если указана выполняемая функция (function-to-execute), временное "
"изменение :ref:`текущего пользователя <authentication-users>` Tarantool'а"
" во время выполнения функции – аналогично Unix-команде ``sudo``."

#: ../doc/1.10/book/box/box_session.rst:207
msgid "name of a target user"
msgstr "целевое имя пользователя"

#: ../doc/1.10/book/box/box_session.rst:208
msgid ""
"name of a function, or definition of a function. Additional parameters "
"may be passed to ``box.session.su``, they will be interpreted as "
"parameters of function-to-execute."
msgstr ""
"имя функции или определение функции. Дополнительные параметры могут "
"передаваться в ``box.session.su``, они будут интерпретироваться как "
"параметры выполняемой функции."

#: ../doc/1.10/book/box/box_session.rst:215
msgid ""
"tarantool> function f(a) return box.session.user() .. a end\n"
"---\n"
"...\n"
"\n"
"tarantool> box.session.su('guest', f, '-xxx')\n"
"---\n"
"- guest-xxx\n"
"...\n"
"\n"
"tarantool> box.session.su('guest',function(...) return ... end,1,2)\n"
"---\n"
"- 1\n"
"- 2\n"
"..."
msgstr ""
"tarantool> function f(a) return box.session.user() .. a end\n"
"---\n"
"...\n"
"\n"
"tarantool> box.session.su('guest', f, '-xxx')\n"
"---\n"
"- guest-xxx\n"
"...\n"
"\n"
"tarantool> box.session.su('guest',function(...) return ... end,1,2)\n"
"---\n"
"- 1\n"
"- 2\n"
"..."

#: ../doc/1.10/book/box/box_session.rst:236
msgid "the user ID of the :ref:`current user <authentication-users>`."
msgstr "ID :ref:`текущего пользователя <authentication-users>`."

#: ../doc/1.10/book/box/box_session.rst:240
msgid ""
"Every user has a unique name (seen with :ref:`box.session.user() "
"<box_session-user>`) and a unique ID (seen with ``box.session.uid()``). "
"The values are stored together in the ``_user`` space."
msgstr ""
"У каждого пользователя есть уникальное имя (узнать с помощью "
":ref:`box.session.user() <box_session-user>`) и уникальный идентификатор "
"(узнать с помощью ``box.session.uid()``). Значения хранятся вместе в "
"спейсе ``_user``."

#: ../doc/1.10/book/box/box_session.rst:248
msgid "the effective user ID of the :ref:`current user <authentication-users>`."
msgstr "рабочий ID :ref:`текущего пользователя <authentication-users>`."

#: ../doc/1.10/book/box/box_session.rst:250
msgid ""
"This is the same as :ref:`box.session.uid() <box_session-uid>`, except in"
" two cases:"
msgstr ""
"Аналогично :ref:`box.session.uid() <box_session-uid>`, за исключением "
"двух случаев:"

#: ../doc/1.10/book/box/box_session.rst:253
msgid ""
"The first case: if the call to ``box.session.euid()`` is within a "
"function invoked by :ref:`box.session.su(user-name, function-to-execute) "
"<box_session-su>` -- in that case, ``box.session.euid()`` returns the ID "
"of the changed user (the user who is specified by the ``user-name`` "
"parameter of the ``su`` function)  but ``box.session.uid()`` returns the "
"ID of the original user (the user who is calling the ``su`` function)."
msgstr ""
"Первый случай: если вызов ``box.session.euid()`` выполняется в рамках "
"функции, вызываемой по :ref:`box.session.su(user-name, function-to-"
"execute) <box_session-su>` -- в таком случае ``box.session.euid()`` "
"вернет измененный идентификатор пользователя (пользователь, который "
"указан в параметре ``user-name`` функции ``su``), но "
"``box.session.uid()`` вернет идентификатор оригинального пользователя "
"(пользователя, который вызывает функцию ``su``)."

#: ../doc/1.10/book/box/box_session.rst:261
msgid ""
"The second case: if the call to ``box.session.euid()`` is within a "
"function specified with :ref:`box.schema.func.create(function-name, "
"{setuid= true}) <box_schema-func_create>` and the binary protocol is in "
"use -- in that case, ``box.session.euid()`` returns the ID of the user "
"who created \"function-name\" but ``box.session.uid()`` returns the ID of"
" the the user who is calling \"function-name\"."
msgstr ""
"Второй случай: если вызов ``box.session.euid()`` выполняется в рамках "
"функции по :ref:`box.schema.func.create(function-name, {setuid= true}) "
"<box_schema-func_create>`, и используется бинарный протокол -- в таком "
"случае ``box.session.euid()`` вернет идентификатор пользователя, который "
"создал функцию \"function-name\", а ``box.session.uid()`` вернет "
"идентификатор пользователя, который вызывает эту функцию \"function-"
"name\"."

#: ../doc/1.10/book/box/box_session.rst:273
msgid ""
"tarantool> box.session.su('admin')\n"
"---\n"
"...\n"
"tarantool> box.session.uid(), box.session.euid()\n"
"---\n"
"- 1\n"
"- 1\n"
"...\n"
"tarantool> function f() return {box.session.uid(),box.session.euid()} end"
"\n"
"---\n"
"...\n"
"tarantool> box.session.su('guest', f)\n"
"---\n"
"- - 1\n"
"  - 0\n"
"..."
msgstr ""
"tarantool> box.session.su('admin')\n"
"---\n"
"...\n"
"tarantool> box.session.uid(), box.session.euid()\n"
"---\n"
"- 1\n"
"- 1\n"
"...\n"
"tarantool> function f() return {box.session.uid(),box.session.euid()} end"
"\n"
"---\n"
"...\n"
"tarantool> box.session.su('guest', f)\n"
"---\n"
"- - 1\n"
"  - 0\n"
"..."

#: ../doc/1.10/book/box/box_session.rst:296
msgid ""
"A Lua table that can hold arbitrary unordered session-specific names and "
"values, which will last until the session ends. For example, this table "
"could be useful to store current tasks when working with a `Tarantool "
"queue manager <https://github.com/tarantool/queue>`_."
msgstr ""
"Lua-таблица с произвольными неупорядоченными именами и значениями по "
"сессии, которая хранится до конца сессии. Например, эту таблицу можно "
"использовать для хранения текущих задач при работе с `очередями сообщений"
" в Tarantool'е <https://github.com/tarantool/queue>`_."

#: ../doc/1.10/book/box/box_session.rst:303
msgid ""
"tarantool> box.session.peer(box.session.id())\n"
"---\n"
"- 127.0.0.1:45129\n"
"...\n"
"tarantool> box.session.storage.random_memorandum = \"Don't forget the "
"eggs\"\n"
"---\n"
"...\n"
"tarantool> box.session.storage.radius_of_mars = 3396\n"
"---\n"
"...\n"
"tarantool> m = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in pairs(box.session.storage) do\n"
"         >   m = m .. k .. '='.. v .. ' '\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> m\n"
"---\n"
"- 'radius_of_mars=3396 random_memorandum=Don''t forget the eggs. '\n"
"..."
msgstr ""
"tarantool> box.session.peer(box.session.id())\n"
"---\n"
"- 127.0.0.1:45129\n"
"...\n"
"tarantool> box.session.storage.random_memorandum = \"Don't forget the "
"eggs\"\n"
"---\n"
"...\n"
"tarantool> box.session.storage.radius_of_mars = 3396\n"
"---\n"
"...\n"
"tarantool> m = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in pairs(box.session.storage) do\n"
"         >   m = m .. k .. '='.. v .. ' '\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> m\n"
"---\n"
"- 'radius_of_mars=3396 random_memorandum=Don''t forget the eggs. '\n"
"..."

#: ../doc/1.10/book/box/box_session.rst:332
msgid ""
"Define a trigger for execution when a new session is created due to an "
"event such as :ref:`console.connect <console-connect>`. The trigger "
"function will be the first thing executed after a new session is created."
" If the trigger execution fails and raises an error, the error is sent to"
" the client and the connection is closed."
msgstr ""
"Определение исполняемого триггера во время создания новой сессии при "
"подключению по консоли :ref:`console.connect <console-connect>`. Функция "
"с триггером будет первой исполняемой функцией после создания сессии. Если"
" триггер не выполняется и выдает ошибку, эта ошибка отправляется на "
"клиент, и подключение разрывается."

#: ../doc/1.10/book/box/box_session.rst:337
#: ../doc/1.10/book/box/box_session.rst:373
#: ../doc/1.10/book/box/box_session.rst:448
#: ../doc/1.10/book/box/box_space.rst:895
#: ../doc/1.10/book/box/box_space.rst:968
#: ../doc/1.10/book/box/box_txn_management.rst:228
msgid "function which will become the trigger function"
msgstr "функция, в которой будет триггер"

#: ../doc/1.10/book/box/box_session.rst:338
#: ../doc/1.10/book/box/box_session.rst:374
#: ../doc/1.10/book/box/box_session.rst:449
#: ../doc/1.10/book/box/box_space.rst:897
#: ../doc/1.10/book/box/box_txn_management.rst:230
msgid "existing trigger function which will be replaced by trigger-function"
msgstr "существующая функция с триггером, которую заменит новая"

#: ../doc/1.10/book/box/box_session.rst:339
#: ../doc/1.10/book/box/box_session.rst:375
#: ../doc/1.10/book/box/box_session.rst:450
#: ../doc/1.10/book/box/box_space.rst:900
#: ../doc/1.10/book/box/box_space.rst:973
#: ../doc/1.10/book/box/box_txn_management.rst:232
msgid "nil or function pointer"
msgstr "nil или указатель функции"

#: ../doc/1.10/book/box/box_session.rst:341
#: ../doc/1.10/book/box/box_session.rst:377
#: ../doc/1.10/book/box/box_session.rst:452
#: ../doc/1.10/book/box/box_space.rst:902
msgid ""
"If the parameters are (nil, old-trigger-function), then the old trigger "
"is deleted."
msgstr ""
"Если указаны параметры (nil, old-trigger-function), старый триггер будет "
"удален."

#: ../doc/1.10/book/box/box_session.rst:343
#: ../doc/1.10/book/box/box_session.rst:379
#: ../doc/1.10/book/box/box_session.rst:454
#: ../doc/1.10/book/box/box_space.rst:905
#: ../doc/1.10/book/box/box_space.rst:978
msgid ""
"If both parameters are omitted, then the response is a list of existing "
"trigger functions."
msgstr ""
"Если не указан ни один параметр, ответом будет список существующих "
"функций с триггером."

#: ../doc/1.10/book/box/box_session.rst:345
#: ../doc/1.10/book/box/box_session.rst:381
#: ../doc/1.10/book/box/box_session.rst:456
#: ../doc/1.10/book/box/box_space.rst:911
#: ../doc/1.10/book/box/box_space.rst:984
#: ../doc/1.10/book/box/box_txn_management.rst:237
msgid ""
"Details about trigger characteristics are in the :ref:`triggers "
"<triggers-box_triggers>` section."
msgstr ""
"Подробная информация о характеристиках триггера находится в разделе "
":ref:`Триггеры <triggers-box_triggers>`."

#: ../doc/1.10/book/box/box_session.rst:349
msgid ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_connect(f)"
msgstr ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_connect(f)"

#: ../doc/1.10/book/box/box_session.rst:358
msgid ""
"If a trigger always results in an error, it may become impossible to "
"connect to a server to reset it."
msgstr ""
"Если триггер всегда приводит к ошибке, подключение к серверу для его "
"переустановки может стать невозможным."

#: ../doc/1.10/book/box/box_session.rst:365
msgid ""
"Define a trigger for execution after a client has disconnected. If the "
"trigger function causes an error, the error is logged but otherwise is "
"ignored. The trigger is invoked while the session associated with the "
"client still exists and can access session properties, such as "
":ref:`box.session.id() <box_session-id>`."
msgstr ""
"Определение исполняемого триггера после отключения клиента. Если функция "
"с триггером вызывает ошибку, то ошибка записывается в журнал, в противном"
" случае записей не будет. Триггер вызывается во время сессии клиента и "
"может получить доступ к свойствам сессии, как :ref:`box.session.id() "
"<box_session-id>`."

#: ../doc/1.10/book/box/box_session.rst:370
msgid ""
"Since version 1.10, the trigger function is invoked immediately after the"
" disconnect, even if requests that were made during the session have not "
"finished."
msgstr ""
"Начиная с версии 1.10, функция с триггером вызывается сразу же после "
"прерывания сессии, даже если сделанные запросы не были выполнены."

#: ../doc/1.10/book/box/box_session.rst:385
msgid ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_disconnect(f)"
msgstr ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_disconnect(f)"

#: ../doc/1.10/book/box/box_session.rst:394
msgid ""
"After the following series of requests, a Tarantool instance will write a"
" message using the :ref:`log <log-module>` module whenever any user "
"connects or disconnects."
msgstr ""
"После следующей серии запросов экземпляр Tarantool'а запишет сообщение с "
"помощью модуля :ref:`log <log-module>` при подключении или отключении "
"любого пользователя."

#: ../doc/1.10/book/box/box_session.rst:397
msgid ""
"function log_connect ()\n"
"  local log = require('log')\n"
"  local m = 'Connection. user=' .. box.session.user() .. ' id=' .. "
"box.session.id()\n"
"  log.info(m)\n"
"end\n"
"\n"
"function log_disconnect ()\n"
"  local log = require('log')\n"
"  local m = 'Disconnection. user=' .. box.session.user() .. ' id=' .. "
"box.session.id()\n"
"  log.info(m)\n"
"end\n"
"\n"
"box.session.on_connect(log_connect)\n"
"box.session.on_disconnect(log_disconnect)"
msgstr ""
"function log_connect ()\n"
"  local log = require('log')\n"
"  local m = 'Connection. user=' .. box.session.user() .. ' id=' .. "
"box.session.id()\n"
"  log.info(m)\n"
"end\n"
"\n"
"function log_disconnect ()\n"
"  local log = require('log')\n"
"  local m = 'Disconnection. user=' .. box.session.user() .. ' id=' .. "
"box.session.id()\n"
"  log.info(m)\n"
"end\n"
"\n"
"box.session.on_connect(log_connect)\n"
"box.session.on_disconnect(log_disconnect)"

#: ../doc/1.10/book/box/box_session.rst:414
msgid "Here is what might appear in the log file in a typical installation:"
msgstr "Вот что может быть записано в файл журнала при обычной установке:"

#: ../doc/1.10/book/box/box_session.rst:416
msgid ""
"2014-12-15 13:21:34.444 [11360] main/103/iproto I>\n"
"    Connection. user=guest id=3\n"
"2014-12-15 13:22:19.289 [11360] main/103/iproto I>\n"
"    Disconnection. user=guest id=3"
msgstr ""
"2014-12-15 13:21:34.444 [11360] main/103/iproto I>\n"
"    Connection. user=guest id=3\n"
"2014-12-15 13:22:19.289 [11360] main/103/iproto I>\n"
"    Disconnection. user=guest id=3"

#: ../doc/1.10/book/box/box_session.rst:427
msgid ""
"Define a trigger for execution during :ref:`authentication "
"<authentication-users>`."
msgstr ""
"Определение триггера, используемого во время :ref:`аутентификации "
"<authentication-users>`."

#: ../doc/1.10/book/box/box_session.rst:429
msgid "The ``on_auth`` trigger function is invoked in these circumstances:"
msgstr ""
"Вызов функции ``on_auth`` с триггером происходит в следующих "
"обстоятельствах:"

#: ../doc/1.10/book/box/box_session.rst:431
msgid ""
"The :ref:`console.connect <console-connect>` function includes an "
"authentication check for all users except 'guest'. For this case, the "
"``on_auth`` trigger function is invoked after the ``on_connect`` trigger "
"function, if and only if the connection has succeeded so far."
msgstr ""
"Функция :ref:`console.connect <console-connect>` включает в себя проверку"
" аутентификации всех пользователей, кроме 'guest'. Вызов функции "
"``on_auth`` с триггером происходит после триггера ``on_connect`` только в"
" том случае, если подключение было успешным."

#: ../doc/1.10/book/box/box_session.rst:436
msgid ""
"The :ref:`binary protocol <admin-security>` has a separate "
":ref:`authentication packet <box_protocol-authentication>`. For this "
"case, connection and authentication are considered to be separate steps."
msgstr ""
"В :ref:`бинарном протоколе <admin-security>` есть отдельный :ref:`пакет "
"для аутентификации <box_protocol-authentication>`. В этом случае "
"подключение и аутентификация считаются отдельными действиям."

#: ../doc/1.10/book/box/box_session.rst:440
msgid ""
"Unlike other trigger types, ``on_auth`` trigger functions are invoked "
"**before** the event. Therefore a trigger function like :code:`function "
"auth_function () v = box.session.user(); end` will set :code:`v` to "
"\"guest\", the user name before the authentication is done. To get the "
"user name **after** the authentication is done, use the special syntax: "
":code:`function auth_function (user_name) v = user_name; end`"
msgstr ""
"В отличие от других типов триггеров, вызов функций с триггером "
"``on_auth`` происходит **до** события. Таким образом, функция с таким "
"триггером, как :code:`function auth_function () v = box.session.user(); "
"end`, определит :code:`v` как \"guest\", то есть имя пользователя до "
"проведения аутентификации. Чтобы получить имя пользователя **после** "
"проведения аутентификации, используйте специальный синтаксис: "
":code:`function auth_function (user_name) v = user_name; end`"

#: ../doc/1.10/book/box/box_session.rst:446
msgid ""
"If the trigger fails by raising an error, the error is sent to the client"
" and the connection is closed."
msgstr ""
"Если триггер не выполняется и выдает ошибку, эта ошибка отправляется на "
"клиент, и подключение разрывается."

#: ../doc/1.10/book/box/box_session.rst:458
msgid "**Example 1**"
msgstr "**Пример 1**"

#: ../doc/1.10/book/box/box_session.rst:460
msgid ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_auth(f)"
msgstr ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_auth(f)"

#: ../doc/1.10/book/box/box_session.rst:467
msgid "**Example 2**"
msgstr "**Пример 2**"

#: ../doc/1.10/book/box/box_session.rst:469
msgid "This is a more complex example, with two server instances."
msgstr "Более сложный пример с двумя экземплярами сервера."

#: ../doc/1.10/book/box/box_session.rst:471
msgid ""
"The first server instance listens on port 3301; its default user name is "
"'admin'. There are three ``on_auth`` triggers:"
msgstr ""
"Первый экземпляр сервера настроен на прослушивание по порту 3301; имя "
"пользователя по умолчанию -- 'admin'. Есть три триггера ``on_auth``:"

#: ../doc/1.10/book/box/box_session.rst:475
msgid ""
"The first trigger has a function with no arguments, it can only look at "
"``box.session.user()``."
msgstr ""
"В первом триггере есть функция без аргументов, которая только смотрит на "
"``box.session.user()``."

#: ../doc/1.10/book/box/box_session.rst:477
msgid ""
"The second trigger has a function with a ``user_name`` argument, it can "
"look at both of: ``box.session.user()`` and ``user_name``."
msgstr ""
"Во втором триггере есть функция с аргументом ``user_name``, которая может"
" смотреть на ``box.session.user()`` и ``user_name``."

#: ../doc/1.10/book/box/box_session.rst:479
msgid ""
"The third trigger has a function with a ``user_name`` argument and a "
"``status`` argument, it can look at all three of: ``box.session.user()`` "
"and ``user_name`` and ``status``."
msgstr ""
"В третьем триггере есть функция с аргументом ``user_name`` и аргументом "
"``status``, которая может смотреть на ``box.session.user()`` и "
"``user_name``, и``status``."

#: ../doc/1.10/book/box/box_session.rst:484
msgid ""
"The second server instance will connect with :ref:`console.connect "
"<console-connect>`, and then will cause a display of the variables that "
"were set by the trigger functions."
msgstr ""
"Второй экземпляр сервера подключится по :ref:`console.connect <console-"
"connect>`, а затем отобразит переменные, определенные функциями с "
"триггером."

#: ../doc/1.10/book/box/box_session.rst:489
msgid ""
"-- On the first server instance, which listens on port 3301\n"
"box.cfg{listen=3301}\n"
"function function1()\n"
"  print('function 1, box.session.user()='..box.session.user())\n"
"  end\n"
"function function2(user_name)\n"
"  print('function 2, box.session.user()='..box.session.user())\n"
"  print('function 2, user_name='..user_name)\n"
"  end\n"
"function function3(user_name, status)\n"
"  print('function 3, box.session.user()='..box.session.user())\n"
"  print('function 3, user_name='..user_name)\n"
"  if status == true then\n"
"    print('function 3, status = true, authorization succeeded')\n"
"    end\n"
"  end\n"
"box.session.on_auth(function1)\n"
"box.session.on_auth(function2)\n"
"box.session.on_auth(function3)\n"
"box.schema.user.passwd('admin')"
msgstr ""
"-- На первом экземпляре сервера, прослушивание на котором настроено на "
"порт 3301\n"
"box.cfg{listen=3301}\n"
"function function1()\n"
"  print('function 1, box.session.user()='..box.session.user())\n"
"  end\n"
"function function2(user_name)\n"
"  print('function 2, box.session.user()='..box.session.user())\n"
"  print('function 2, user_name='..user_name)\n"
"  end\n"
"function function3(user_name, status)\n"
"  print('function 3, box.session.user()='..box.session.user())\n"
"  print('function 3, user_name='..user_name)\n"
"  if status == true then\n"
"    print('function 3, status = true, authorization succeeded')\n"
"    end\n"
"  end\n"
"box.session.on_auth(function1)\n"
"box.session.on_auth(function2)\n"
"box.session.on_auth(function3)\n"
"box.schema.user.passwd('admin')"

#: ../doc/1.10/book/box/box_session.rst:512
msgid ""
"-- On the second server instance, that connects to port 3301\n"
"console = require('console')\n"
"console.connect('admin:admin@localhost:3301')"
msgstr ""
"-- На втором экземпляре сервера, который подключается по порту 3301\n"
"console = require('console')\n"
"console.connect('admin:admin@localhost:3301')"

#: ../doc/1.10/book/box/box_session.rst:518
msgid "The result looks like this:"
msgstr "Теперь результат выглядит следующим образом:"

#: ../doc/1.10/book/box/box_session.rst:520
msgid ""
"function 3, box.session.user()=guest\n"
"function 3, user_name=admin\n"
"function 3, status = true, authorization succeeded\n"
"function 2, box.session.user()=guest\n"
"function 2, user_name=admin\n"
"function 1, box.session.user()=guest"
msgstr ""
"function 3, box.session.user()=guest\n"
"function 3, user_name=admin\n"
"function 3, status = true, authorization succeeded\n"
"function 2, box.session.user()=guest\n"
"function 2, user_name=admin\n"
"function 1, box.session.user()=guest"

#: ../doc/1.10/book/box/box_session.rst:533
msgid ""
"Generate an out-of-band message. By \"out-of-band\" we mean an extra "
"message which supplements what is passed in a network via the usual "
"channels. Although ``box.session.push()`` can be called at any time, in "
"practice it is used with networks that are set up with :ref:`module "
"net.box <net_box-module>`, and it is invoked by the server (on the "
"\"remote database system\" to use our terminology for net.box), and the "
"client has options for getting such messages."
msgstr ""
"Создание внеполосного сообщения. Под внеполосным мы понимаем "
"дополнительное сообщение, которое дополняет то, что отправляется в сети "
"по обычным каналам. Хотя ``box.session. push()`` можно вызвать в любое "
"время, на практике эта функция используется в сетях, настроенных с "
"помощью :ref:`модуля net.box <net_box-module>`, и вызывается сервером (на"
" \"удаленной системе с базой данных\", если использовать нашу "
"терминологию для net.box), а у клиента есть возможность принимать такие "
"сообщения."

#: ../doc/1.10/book/box/box_session.rst:542
msgid "This function returns an error if the session is disconnected."
msgstr "Функция возвращает ошибку, если сессия была прервана."

#: ../doc/1.10/book/box/box_session.rst:544
msgid "what to send"
msgstr "что отправляется"

#: ../doc/1.10/book/box/box_session.rst:545
msgid ""
"an optional argument to indicate what the session is, as taken from an "
"earlier call to :ref:`box_session:sync() <box_session-sync>`. If it is "
"omitted, the default is the current ``box.session.sync()`` value."
msgstr ""
"необязательный аргумент, который показывает информацию о сессии, "
"полученную из предшествующего вызова :ref:`box_session:sync() "
"<box_session-sync>`. Если не указать, по умолчанию используется текущее "
"значение ``box.session.sync()``."

#: ../doc/1.10/book/box/box_session.rst:548
msgid "{nil, error} or true:"
msgstr "{nil, ошибка} или true:"

#: ../doc/1.10/book/box/box_session.rst:550
msgid ""
"If the result is an error, then the first part of the return is ``nil`` "
"and the second part is the error object."
msgstr ""
"Если результатом будет ошибка, то вернется ``nil`` вместе с объектом "
"ошибки."

#: ../doc/1.10/book/box/box_session.rst:552
msgid ""
"If the result is not an error, then the return is the boolean value "
"``true``."
msgstr ""
"Если результатом будет не ошибка, то вернется логическое значение "
"``true`` (правда)."

#: ../doc/1.10/book/box/box_session.rst:553
msgid ""
"When the return is ``true``, the message has gone to the network buffer "
"as a :ref:`packet <box_protocol-iproto_protocol>` with the code "
"IPROTO_CHUNK (0x80)."
msgstr ""
"Если возвращается ``true``, сообщение отправлено в буфер сети в виде "
":ref:`пакета <box_protocol-iproto_protocol>` с кодом IPROTO_CHUNK (0x80)."

#: ../doc/1.10/book/box/box_session.rst:557
msgid ""
"The server's sole job is to call ``box.session.push()``, there is no "
"automatic mechanism for showing that the message was received."
msgstr ""
"Единственная задача сервера -- вызвать ``box.session.push()``, поскольку "
"нет автоматического механизма, который показал бы, что сообщение "
"получено."

#: ../doc/1.10/book/box/box_session.rst:560
msgid ""
"The client's job is to check for such messages after it sends something "
"to the server. The major client methods -- :ref:`conn:call <net_box-"
"call>`, :ref:`conn:eval <net_box-eval>`, :ref:`conn:select <conn-"
"select>`, :ref:`conn:insert <conn-insert>`, :ref:`conn:replace <conn-"
"replace>`, :ref:`conn:update <conn-update>`, :ref:`conn:upsert <conn-"
"upsert>`, :ref:`delete <conn-delete>` -- may cause the server to send a "
"message."
msgstr ""
"Задача клиента заключается в том, чтобы проверять наличие таких сообщений"
" после отправки чего-либо на сервер. Основные клиентские методы -- "
":ref:`conn:call <net_box-call>`, :ref:`conn:eval <net_box-eval>`, "
":ref:`conn:select <conn-select>`, :ref:`conn:insert <conn-insert>`, "
":ref:`conn:replace <conn-replace>`, :ref:`conn:update <conn-update>`, "
":ref:`conn:upsert <conn-upsert>`, :ref:`delete <conn-delete>` -- могут "
"привести к отправке такого сообщения сервером."

#: ../doc/1.10/book/box/box_session.rst:568
msgid ""
"Situation 1: when the client calls synchronously with the default "
"``{async=false}`` option. There are two optional additional options: "
":samp:`on_push={function-name}`, and :samp:`on_push_ctx={function-"
"argument}`. When the client receives an out-of-band message for the "
"session, it invokes \"function-name(function-argument)\". For example, "
"with options ``{on_push=table.insert, on_push_ctx=messages}``, the client"
" will insert whatever it receives into a table named 'messages'."
msgstr ""
"Ситуация 1: когда клиент делает синхронный вызов со значением параметра "
"``{async=false}`` по умолчанию. Есть два необязательных дополнительных "
"параметра: :samp:`on_push={function-name}` и :samp:`on_push_ctx"
"={function-argument}`. Когда клиент получает внеполосное сообщение в "
"сессии, он вызывает \"имя-функции(аргумент-функции)\". Например, с такими"
" значениями параметров: ``{on_push=table.insert, on_push_ctx=messages}`` "
"-- клиент произведет вставку полученных данных в таблицу под названием "
"'messages'."

#: ../doc/1.10/book/box/box_session.rst:576
msgid ""
"Situation 2: when the client calls asynchronously with the non-default "
"``{async=true}`` option. Here ``on_push`` and ``on_push_ctx`` are not "
"allowed, but the messages can be seen by calling ``pairs()`` in a loop."
msgstr ""
"Ситуация 2: когда клиент делает асинхронный вызов с измененным значением "
"параметра ``{async=true}``. Здесь не разрешены ``on_push`` и "
"``on_push_ctx``, но сообщения можно увидеть путем вызова ``pairs()`` в "
"цикле."

#: ../doc/1.10/book/box/box_session.rst:580
msgid ""
"Situation 2 complication: ``pairs()`` is subject to timeout. So there is "
"an optional argument = timeout per iteration. If timeout occurs before "
"there is a new message or a final response, there is an error return. To "
"check for an error one can use the first loop parameter (if the loop "
"starts with \"for i, message in future:pairs()\" then the first loop "
"parameter is i). If it is ``box.NULL`` then the second parameter (in our "
"example, \"message\") is the error object."
msgstr ""
"Осложненная ситуация 2: ``pairs()`` зависит от времени ожидания. Таким "
"образом, есть необязательный аргумент -- время ожидания для итерации. "
"Если время ожидания истечет до получения нового сообщения или "
"окончательного ответа, вернется ошибка. Чтобы проверить наличие ошибки, "
"можно использовать первый параметр в цикле (если цикл начинается с \"for "
"i, message in future:pairs()\", то первым параметром в цикле будет i). "
"Если это будет ``box.NULL``, то второй параметр (в нашем примере "
"\"message\") -- это объект ошибки."

#: ../doc/1.10/book/box/box_session.rst:590
msgid ""
"-- Make two shells. On Shell#1 set up a \"server\", and\n"
"-- in it have a function that includes box.session.push:\n"
"box.cfg{listen=3301}\n"
"box.schema.user.grant('guest','read,write,execute','universe')\n"
"x = 0\n"
"fiber = require('fiber')\n"
"function server_function() x=x+1; fiber.sleep(1); box.session.push(x); "
"end\n"
"\n"
"-- On Shell#2 connect to this server as a \"client\" that\n"
"-- can handle Lua (such as another Tarantool server operating\n"
"-- as a client), and initialize a table where we'll get messages:\n"
"net_box = require('net.box')\n"
"conn = net_box.connect(3301)\n"
"messages_from_server = {}\n"
"\n"
"-- On Shell#2 remotely call the server function and receive\n"
"-- a SYNCHRONOUS out-of-band message:\n"
"conn:call('server_function', {},\n"
"          {is_async = false,\n"
"           on_push = table.insert,\n"
"           on_push_ctx = messages_from_server})\n"
"messages_from_server\n"
"-- After a 1-second pause that is caused by the fiber.sleep()\n"
"-- request inside server_function, the result in the\n"
"--  messages_from_server table will be: 1. Like this:\n"
"-- tarantool> messages_from_server\n"
"-- ---\n"
"-- - - 1\n"
"-- ...\n"
"-- Good. That shows that box.session.push(x) worked,\n"
"-- because we know that x was 1.\n"
"\n"
"-- On Shell#2 remotely call the same server function and\n"
"-- get an ASYNCHRONOUS out-of-band message. For this we cannot\n"
"-- use on_push and on_push_ctx options, but we can use pairs():\n"
"future = conn:call('server_function', {}, {is_async = true})\n"
"messages = {}\n"
"keys = {}\n"
"for i, message in future:pairs() do\n"
"    table.insert(messages, message) table.insert(keys, i) end\n"
"messages\n"
"future:wait_result(1000)\n"
"for i, message in future:pairs() do\n"
"    table.insert(messages, message) table.insert(keys, i) end\n"
"messages\n"
"-- There is no pause because conn:call does not wait for\n"
"-- server_function to finish. The first time that we go through\n"
"-- the pairs() loop, we see the messages table is empty. Like this:\n"
"-- tarantool> messages\n"
"-- ---\n"
"-- - - 2\n"
"--   - []\n"
"-- ...\n"
"-- That is okay because the server hasn't yet called\n"
"-- box.session.push(). The second time that we go through\n"
"-- the pairs() loop, we see the value of x at the time of\n"
"-- the second call to box.session.push(). Like this:\n"
"-- tarantool> messages\n"
"-- ---\n"
"-- - - 2\n"
"--   - &0 []\n"
"--   - 2\n"
"--   - *0\n"
"-- ...\n"
"-- Good. That shows that the message was asynchronous, and\n"
"-- that box.session.push() did its job."
msgstr ""
"-- Создайте две оболочки. В оболочке №1 настройте сервер, а\n"
"-- в нем функцию, которая содержит box.session.push:\n"
"box.cfg{listen=3301}\n"
"box.schema.user.grant('guest','read,write,execute','universe')\n"
"x = 0\n"
"fiber = require('fiber')\n"
"function server_function() x=x+1; fiber.sleep(1); box.session.push(x); "
"end\n"
"\n"
"-- В оболочке №2 подключитесь к серверу в качестве клиента, который\n"
"-- поддерживает Lua (как второй Tarantool-сервер, работающий\n"
"-- в качестве клиента), и создайте таблицу, в которую мы будем получать "
"сообщения:\n"
"net_box = require('net.box')\n"
"conn = net_box.connect(3301)\n"
"messages_from_server = {}\n"
"\n"
"-- В оболочке №2 удаленно вызовите функцию и получите\n"
"-- СИНХРОННОЕ внеполосное сообщение:\n"
"conn:call('server_function', {},\n"
"          {is_async = false,\n"
"           on_push = table.insert,\n"
"           on_push_ctx = messages_from_server})\n"
"messages_from_server\n"
"-- Через секунду, во время которой происходит запрос fiber.sleep()\n"
"-- в server_function, результат в таблице\n"
"--  messages_from_server будет следующим: 1. Проверим:\n"
"-- tarantool> messages_from_server\n"
"-- ---\n"
"-- - - 1\n"
"-- ...\n"
"-- Хорошо. Это означает, что box.session.push(x) сработала,\n"
"-- поскольку мы знаем, что x был 1.\n"
"\n"
"-- В оболочке №2 удаленно вызовите ту же самую функцию\n"
"-- для получения АСИНХРОННОГО внеполосного сообщения. При этом мы не "
"можем\n"
"-- использовать параметры on_push и on_push_ctx, но можем использовать "
"pairs():\n"
"future = conn:call('server_function', {}, {is_async = true})\n"
"messages = {}\n"
"keys = {}\n"
"for i, message in future:pairs() do\n"
"    table.insert(messages, message) table.insert(keys, i) end\n"
"messages\n"
"future:wait_result(1000)\n"
"for i, message in future:pairs() do\n"
"    table.insert(messages, message) table.insert(keys, i) end\n"
"messages\n"
"-- Задержки нет, поскольку conn:call не ждет\n"
"-- окончания вызова функции server_function. После первой итерации\n"
"-- цикла pairs(), видим, что таблица пуста. Это выглядит так:\n"
"-- tarantool> messages\n"
"-- ---\n"
"-- - - 2\n"
"--   - []\n"
"-- ...\n"
"-- Это нормально, поскольку сервер еще не вызвал\n"
"-- box.session.push(). При второй итерации\n"
"-- цикла pairs(), видим значение x во время\n"
"-- второго вызова box.session.push(). Так:\n"
"-- tarantool> messages\n"
"-- ---\n"
"-- - - 2\n"
"--   - &0 []\n"
"--   - 2\n"
"--   - *0\n"
"-- ...\n"
"-- Хорошо. Это означает, что сообщение было асинхронным, и\n"
"-- box.session.push() выполнила свою задачу."

#: ../doc/1.10/book/box/box_slab.rst:39
msgid "Submodule `box.slab`"
msgstr "Вложенный модуль `box.slab`"

#: ../doc/1.10/book/box/box_slab.rst:47
msgid ""
"The ``box.slab`` submodule provides access to slab allocator statistics. "
"The slab allocator is the main allocator used to store :ref:`tuples "
"<index-box_tuple>`. This can be used to monitor the total memory usage "
"and memory fragmentation."
msgstr ""
"Вложенный модуль ``box.slab`` предоставляет доступ к статистике "
"распределения slab. Механизм распределения slab представляет собой "
"основной тип распределения для хранения :ref:`кортежей <index-"
"box_tuple>`. Такое распределение можно использовать для отслеживания "
"использования памяти и фрагментации памяти."

#: ../doc/1.10/book/box/box_slab.rst:55
msgid "Below is a list of all ``box.slab`` functions."
msgstr "Ниже приведен перечень всех функций модуля ``box.slab``."

#: ../doc/1.10/book/box/box_slab.rst:65
msgid ":ref:`box.runtime.info() <box_runtime_info>`"
msgstr ":ref:`box.runtime.info() <box_runtime_info>`"

#: ../doc/1.10/book/box/box_slab.rst:65
msgid "Show a memory usage report for Lua runtime"
msgstr "Отображение отчета по использованию памяти во время исполнения Lua-кода"

#: ../doc/1.10/book/box/box_slab.rst:68
msgid ":ref:`box.slab.info() <box_slab_info>`"
msgstr ":ref:`box.slab.info() <box_slab_info>`"

#: ../doc/1.10/book/box/box_slab.rst:68
msgid "Show an aggregated memory usage report for slab allocator"
msgstr ""
"Отображение обобщенного отчета по использованию памяти для распределения "
"slab"

#: ../doc/1.10/book/box/box_slab.rst:71
msgid ":ref:`box.slab.stats() <box_slab_stats>`"
msgstr ":ref:`box.slab.stats() <box_slab_stats>`"

#: ../doc/1.10/book/box/box_slab.rst:71
msgid "Show a detailed memory usage report for slab allocator"
msgstr ""
"Отображение подробного отчета по использованию памяти для распределения "
"slab"

#: ../doc/1.10/book/box/box_slab.rst:79
msgid "Show a memory usage report (in bytes) for the Lua runtime."
msgstr ""
"Отображение отчета по использованию памяти (в байтах) во время исполнения"
" Lua-кода."

#: ../doc/1.10/book/box/box_slab.rst:83
msgid "``lua`` is the heap size of the Lua garbage collector;"
msgstr "``lua`` -- это размер динамической памяти сборщика мусора в Lua;"

#: ../doc/1.10/book/box/box_slab.rst:84
msgid "``maxalloc`` is the maximal memory quota that can be allocated for Lua;"
msgstr ""
"``maxalloc`` -- это максимальная квота памяти, которую можно выделить для"
" Lua;"

#: ../doc/1.10/book/box/box_slab.rst:85
msgid "``used`` is the current memory size used by Lua."
msgstr "``used`` -- объем памяти, используемый Lua в данный момент."

#: ../doc/1.10/book/box/box_slab.rst:91
msgid ""
"tarantool> box.runtime.info()\n"
"---\n"
"- lua: 913710\n"
"  maxalloc: 4398046510080\n"
"  used: 12582912\n"
"...\n"
"tarantool> box.runtime.info().used\n"
"---\n"
"- used: 12582912\n"
"..."
msgstr ""
"tarantool> box.runtime.info()\n"
"---\n"
"- lua: 913710\n"
"  maxalloc: 4398046510080\n"
"  used: 12582912\n"
"...\n"
"tarantool> box.runtime.info().used\n"
"---\n"
"- used: 12582912\n"
"..."

#: ../doc/1.10/book/box/box_slab.rst:108
msgid "Show an aggregated memory usage report (in bytes) for the slab allocator."
msgstr ""
"Отображение обобщенного отчета по использованию памяти (в байтах) для "
"распределения slab."

#: ../doc/1.10/book/box/box_slab.rst:110
msgid ""
"This report is useful for assessing out-of-memory risks: the risks are "
"high if both ``arena_used_ratio`` and ``quota_used_ratio`` are high "
"(90-95%)."
msgstr ""
"Данный отчет используется для оценки риска нехватки памяти: риск высокий,"
" если высоки значения и ``arena_used_ratio``, и ``quota_used_ratio`` "
"(90-95%)."

#: ../doc/1.10/book/box/box_slab.rst:113
msgid ""
"If ``quota_used_ratio`` is low, then high ``arena_used_ratio`` and/or "
"``items_used_ratio`` indicate that the memory fragmentation is low (i.e. "
"the memory is used efficiently)."
msgstr ""
"Если значение ``quota_used_ratio`` низкое, то высокое значение "
"``arena_used_ratio`` и/или ``items_used_ratio`` указывает на низкую "
"фрагментацию памяти (т.е. память используется эффективно)."

#: ../doc/1.10/book/box/box_slab.rst:117
msgid ""
"If ``quota_used_ratio`` is high (approaching 100%), then low "
"``arena_used_ratio`` (50-60%) indicates that the memory is heavily "
"fragmentized. Most probably, there is no immediate out-of-memory risk in "
"this case, but generally this is an issue to consider. For example, "
"probable risks are that the entire memory quota is used for tuples, and "
"there is are no slabs left for a piece of an index. Or that all slabs are"
" allocated for storing tuples, but in fact all the slabs are half-empty."
msgstr ""
"Если значение ``quota_used_ratio`` высокое (достигает 100%), то низкое "
"значение ``arena_used_ratio`` (50-60%) указывает на значительную "
"фрагментацию памяти. Весьма вероятно, что в данном случае "
"непосредственного риска нехватки памяти нет, но такую проблему следует "
"тщательно рассмотреть. Например, есть риск того, что вся квота памяти "
"используется на кортежи, а для части индекса slab'ов нет. Или все slab'ы "
"выделены на хранение кортежей, а в действительности все они наполовину "
"пусты."

#: ../doc/1.10/book/box/box_slab.rst:127
msgid ""
"``items_size`` is the *total* amount of memory (including allocated, but "
"currently free slabs) used only for tuples, no indexes;"
msgstr ""
"``items_size`` -- это *общий* объем памяти (включая выделенные, но в "
"данный момент свободные slab'ы), который используется только для "
"кортежей, а не для индексов;"

#: ../doc/1.10/book/box/box_slab.rst:129
msgid ""
"``items_used_ratio`` = ``items_used`` / ``slab_count`` * ``slab_size`` "
"(these are slabs used only for tuples, no indexes);"
msgstr ""
"``items_used_ratio`` = ``items_used`` / ``slab_count`` * ``slab_size`` "
"(это slab'ы, которые используются только для кортежей, не для индексов);"

#: ../doc/1.10/book/box/box_slab.rst:131
msgid ""
"``quota_size`` is the maximum amount of memory that the slab allocator "
"can use for both tuples and indexes (as configured in the "
":ref:`memtx_memory <cfg_storage-memtx_memory>` parameter, the default is "
"2^28 bytes =  268,435,456 bytes);"
msgstr ""
"``quota_size`` -- максимальный объем памяти, который механизм "
"распределения slab может использовать как для кортежей, так и для "
"индексов (как настроено в параметре :ref:`memtx_memory <cfg_storage-"
"memtx_memory>`, по умолчанию 2^28 байтов =  268 435 456 байтов);"

#: ../doc/1.10/book/box/box_slab.rst:135
msgid "``quota_used_ratio`` = ``quota_used`` / ``quota_size``;"
msgstr "``quota_used_ratio`` = ``quota_used`` / ``quota_size``;"

#: ../doc/1.10/book/box/box_slab.rst:136
msgid "``arena_used_ratio`` = ``arena_used`` / ``arena_size``;"
msgstr "``arena_used_ratio`` = ``arena_used`` / ``arena_size``;"

#: ../doc/1.10/book/box/box_slab.rst:137
msgid ""
"``items_used`` is the *efficient* amount of memory (omitting allocated, "
"but currently free slabs) used only for tuples, no indexes;"
msgstr ""
"``items_used`` -- это *эффективный* объем памяти (не включая выделенные, "
"но в данный момент свободные slab'ы), который используется только для "
"кортежей, а не для индексов;"

#: ../doc/1.10/book/box/box_slab.rst:139
msgid ""
"``quota_used`` is the amount of memory that is already distributed to the"
" slab allocator;"
msgstr "``quota_used`` -- это объем памяти, уже выделенный для распределения slab;"

#: ../doc/1.10/book/box/box_slab.rst:141
msgid ""
"``arena_size`` is the *total* memory used for tuples and indexes together"
" (including allocated, but currently free slabs);"
msgstr ""
"``arena_size`` -- это *общий* объем памяти, используемый для кортежей и "
"индексов (включая выделенные, но в данный момент свободные slab'ы);"

#: ../doc/1.10/book/box/box_slab.rst:143
msgid ""
"``arena_used`` is the *efficient* memory used for storing tuples and "
"indexes together (omitting allocated, but currently free slabs)."
msgstr ""
"``arena_used`` -- это *эффективный* объем памяти, используемый для "
"кортежей и индексов (не включая выделенные, но в данный момент свободные "
"slab'ы)."

#: ../doc/1.10/book/box/box_slab.rst:150
msgid ""
"tarantool> box.slab.info()\n"
"---\n"
"- items_size: 228128\n"
"  items_used_ratio: 1.8%\n"
"  quota_size: 1073741824\n"
"  quota_used_ratio: 0.8%\n"
"  arena_used_ratio: 43.2%\n"
"  items_used: 4208\n"
"  quota_used: 8388608\n"
"  arena_size: 2325176\n"
"  arena_used: 1003632\n"
"...\n"
"\n"
"tarantool> box.slab.info().arena_used\n"
"---\n"
"- 1003632\n"
"..."
msgstr ""
"tarantool> box.slab.info()\n"
"---\n"
"- items_size: 228128\n"
"  items_used_ratio: 1.8%\n"
"  quota_size: 1073741824\n"
"  quota_used_ratio: 0.8%\n"
"  arena_used_ratio: 43.2%\n"
"  items_used: 4208\n"
"  quota_used: 8388608\n"
"  arena_size: 2325176\n"
"  arena_used: 1003632\n"
"...\n"
"\n"
"tarantool> box.slab.info().arena_used\n"
"---\n"
"- 1003632\n"
"..."

#: ../doc/1.10/book/box/box_slab.rst:174
msgid ""
"Show a detailed memory usage report (in bytes) for the slab allocator. "
"The report is broken down into groups by *data item size* as well as by "
"*slab size* (64-byte, 136-byte, etc). The report includes the memory "
"allocated for storing both tuples and indexes."
msgstr ""
"Отображение подробного отчета об использовании памяти (в байтах) для "
"распределения slab. Отчет разбивается на группы по *размеру элементов "
"данных*, а также по *размеру slab'а* (64 байта, 136 байтов и т.д.). Отчет"
" включает в себя информацию о памяти, выделенной на хранение и кортежей, "
"и индексов."

#: ../doc/1.10/book/box/box_slab.rst:181
msgid "``mem_free`` is the allocated, but currently unused memory;"
msgstr "``mem_free`` -- это выделенная, но не используемая в данный момент память;"

#: ../doc/1.10/book/box/box_slab.rst:182
msgid ""
"``mem_used`` is the memory used for storing data items (tuples and "
"indexes);"
msgstr ""
"``mem_used`` -- это память, используемая для хранения элементов данных "
"(кортежей и индексов);"

#: ../doc/1.10/book/box/box_slab.rst:183
msgid "``item_count`` is the number of stored items;"
msgstr "``item_count`` -- это количество хранимых элементов;"

#: ../doc/1.10/book/box/box_slab.rst:184
msgid "``item_size`` is the size of each data item;"
msgstr "``item_size`` -- это размер каждого элемента данных;"

#: ../doc/1.10/book/box/box_slab.rst:185
msgid "``slab_count`` is the number of slabs allocated;"
msgstr "``slab_count`` -- это количество выделенных slab'ов;"

#: ../doc/1.10/book/box/box_slab.rst:186
msgid "``slab_size`` is the size of each allocated slab."
msgstr "``slab_size`` -- это размер каждого выделенного slab'а."

#: ../doc/1.10/book/box/box_slab.rst:192
msgid "Here is a sample report for the first group:"
msgstr "Ниже представлен пример отчета для первой группы:"

#: ../doc/1.10/book/box/box_slab.rst:194
msgid ""
"tarantool> box.slab.stats()[1]\n"
"---\n"
"- mem_free: 16232\n"
"  mem_used: 48\n"
"  item_count: 2\n"
"  item_size: 24\n"
"  slab_count: 1\n"
"  slab_size: 16384\n"
"..."
msgstr ""
"tarantool> box.slab.stats()[1]\n"
"---\n"
"- mem_free: 16232\n"
"  mem_used: 48\n"
"  item_count: 2\n"
"  item_size: 24\n"
"  slab_count: 1\n"
"  slab_size: 16384\n"
"..."

#: ../doc/1.10/book/box/box_slab.rst:206
msgid ""
"This report is saying that there are 2 data items (``item_count`` = 2) "
"stored in one (``slab_count`` = 1) 24-byte slab (``item_size`` = 24), so "
"``mem_used`` = 2 * 24 = 48 bytes. Also, ``slab_size`` is 16384 bytes, of "
"which 16384 - 48 = 16232 bytes are free (``mem_free``)."
msgstr ""
"В отчете показано, что есть два элемента данных (``item_count`` = 2), "
"которые хранятся в одном (``slab_count`` = 1) 24-байтовом slab'е "
"(``item_size`` = 24), поэтому объем используемой памяти ``mem_used`` = 2 "
"* 24 = 48 байтов. Кроме того, размер slab'а ``slab_size`` составляет "
"16384 байта, из которых 16384 - 48 = 16232 байта свободны (``mem_free``)."

#: ../doc/1.10/book/box/box_slab.rst:211
msgid "A complete report would show memory usage statistics for all groups:"
msgstr "В полном отчете будет статистика по использованию памяти во всех группах:"

#: ../doc/1.10/book/box/box_slab.rst:213
msgid ""
"tarantool> box.slab.stats()\n"
"---\n"
"- - mem_free: 16232\n"
"    mem_used: 48\n"
"    item_count: 2\n"
"    item_size: 24\n"
"    slab_count: 1\n"
"    slab_size: 16384\n"
"  - mem_free: 15720\n"
"    mem_used: 560\n"
"    item_count: 14\n"
"    item_size: 40\n"
"    slab_count: 1\n"
"    slab_size: 16384\n"
"  <...>\n"
"  - mem_free: 32472\n"
"    mem_used: 192\n"
"    item_count: 1\n"
"    item_size: 192\n"
"    slab_count: 1\n"
"    slab_size: 32768\n"
"  - mem_free: 1097624\n"
"    mem_used: 999424\n"
"    item_count: 61\n"
"    item_size: 16384\n"
"    slab_count: 1\n"
"    slab_size: 2097152\n"
"  ..."
msgstr ""
"tarantool> box.slab.stats()\n"
"---\n"
"- - mem_free: 16232\n"
"    mem_used: 48\n"
"    item_count: 2\n"
"    item_size: 24\n"
"    slab_count: 1\n"
"    slab_size: 16384\n"
"  - mem_free: 15720\n"
"    mem_used: 560\n"
"    item_count: 14\n"
"    item_size: 40\n"
"    slab_count: 1\n"
"    slab_size: 16384\n"
"  <...>\n"
"  - mem_free: 32472\n"
"    mem_used: 192\n"
"    item_count: 1\n"
"    item_size: 192\n"
"    slab_count: 1\n"
"    slab_size: 32768\n"
"  - mem_free: 1097624\n"
"    mem_used: 999424\n"
"    item_count: 61\n"
"    item_size: 16384\n"
"    slab_count: 1\n"
"    slab_size: 2097152\n"
"  ..."

#: ../doc/1.10/book/box/box_slab.rst:244
msgid ""
"The total ``mem_used`` for all groups in this report equals "
"``arena_used`` in :ref:`box.slab.info() <box_slab_info>` report."
msgstr ""
"Общий объем используемой памяти ``mem_used`` для всех групп в данном "
"отчете равен ``arena_used`` в отчете :ref:`box.slab.info() "
"<box_slab_info>`."

#: ../doc/1.10/book/box/box_space.rst:39
msgid "Submodule `box.space`"
msgstr "Вложенный модуль `box.space`"

#: ../doc/1.10/book/box/box_space.rst:45
msgid ""
"The ``box.space`` submodule has the data-manipulation functions "
"``select``, ``insert``, ``replace``, ``update``, ``upsert``, ``delete``, "
"``get``, ``put``. It also has members, such as id, and whether or not a "
"space is enabled. Submodule source code is available in file "
"`src/box/lua/schema.lua "
"<https://github.com/tarantool/tarantool/blob/1.7/src/box/lua/schema.lua>`_."
msgstr ""
"Вложенный модуль ``box.space`` включает в себя функции по управлению "
"данными ``select`` (выборка), ``insert`` (вставка), ``replace`` (замена),"
" ``update`` (обновление), ``upsert`` (обновление и вставка), ``delete`` "
"(удаление), ``get`` (получение), ``put`` (выдача). Также в модуле есть "
"такие элементы, как id, и указание на активность спейса. Код вложенного "
"модуля находится в файле `src/box/lua/schema.lua "
"<https://github.com/tarantool/tarantool/blob/1.7/src/box/lua/schema.lua>`_."

#: ../doc/1.10/book/box/box_space.rst:55
msgid "Below is a list of all ``box.space`` functions and members."
msgstr "Ниже приведен перечень всех функций и элементов модуля ``box.space``."

#: ../doc/1.10/book/box/box_space.rst:65
msgid ":ref:`space_object:auto_increment() <box_space-auto_increment>`"
msgstr ":ref:`space_object:auto_increment() <box_space-auto_increment>`"

#: ../doc/1.10/book/box/box_space.rst:65
msgid "Generate key + Insert a tuple"
msgstr "Генерация ключа + вставка кортежа"

#: ../doc/1.10/book/box/box_space.rst:68
msgid ":ref:`space_object:bsize() <box_space-bsize>`"
msgstr ":ref:`space_object:bsize() <box_space-bsize>`"

#: ../doc/1.10/book/box/box_space.rst:68
msgid "Get count of bytes"
msgstr "Подсчет байтов"

#: ../doc/1.10/book/box/box_space.rst:71
msgid ":ref:`space_object:count() <box_space-count>`"
msgstr ":ref:`space_object:count() <box_space-count>`"

#: ../doc/1.10/book/box/box_space.rst:71 ../doc/1.10/book/box/box_space.rst:95
msgid "Get count of tuples"
msgstr "Подсчет кортежей"

#: ../doc/1.10/book/box/box_space.rst:74
msgid ":ref:`space_object:create_index() <box_space-create_index>`"
msgstr ":ref:`space_object:create_index() <box_space-create_index>`"

#: ../doc/1.10/book/box/box_space.rst:77
msgid ":ref:`space_object:delete() <box_space-delete>`"
msgstr ":ref:`space_object:delete() <box_space-delete>`"

#: ../doc/1.10/book/box/box_space.rst:77
#: ../doc/1.10/reference/reference_lua/net_box.rst:155
msgid "Delete a tuple"
msgstr "Удаление кортежа"

#: ../doc/1.10/book/box/box_space.rst:80
msgid ":ref:`space_object:drop() <box_space-drop>`"
msgstr ":ref:`space_object:drop() <box_space-drop>`"

#: ../doc/1.10/book/box/box_space.rst:80
msgid "Destroy a space"
msgstr "Удаление спейса"

#: ../doc/1.10/book/box/box_space.rst:83
msgid ":ref:`space_object:format() <box_space-format>`"
msgstr ":ref:`space_object:format() <box_space-format>`"

#: ../doc/1.10/book/box/box_space.rst:83
msgid "Declare field names and types"
msgstr "Объявление имен и типов полей"

#: ../doc/1.10/book/box/box_space.rst:86
msgid ":ref:`space_object:frommap() <box_space-frommap>`"
msgstr ":ref:`space_object:frommap() <box_space-frommap>`"

#: ../doc/1.10/book/box/box_space.rst:86
msgid "Convert from map to tuple or table"
msgstr "Конвертация ассоциативного массива в кортеж или таблицу"

#: ../doc/1.10/book/box/box_space.rst:89
msgid ":ref:`space_object:get() <box_space-get>`"
msgstr ":ref:`space_object:get() <box_space-get>`"

#: ../doc/1.10/book/box/box_space.rst:89
#: ../doc/1.10/reference/reference_lua/net_box.rst:140
msgid "Select a tuple"
msgstr "Выбор кортежа"

#: ../doc/1.10/book/box/box_space.rst:92
msgid ":ref:`space_object:insert() <box_space-insert>`"
msgstr ":ref:`space_object:insert() <box_space-insert>`"

#: ../doc/1.10/book/box/box_space.rst:92
#: ../doc/1.10/reference/reference_lua/net_box.rst:143
msgid "Insert a tuple"
msgstr "Вставка кортежа"

#: ../doc/1.10/book/box/box_space.rst:95
msgid ":ref:`space_object:len() <box_space-len>`"
msgstr ":ref:`space_object:len() <box_space-len>`"

#: ../doc/1.10/book/box/box_space.rst:98
msgid ":ref:`space_object:on_replace() <box_space-on_replace>`"
msgstr ":ref:`space_object:on_replace() <box_space-on_replace>`"

#: ../doc/1.10/book/box/box_space.rst:98
msgid "Create a replace trigger with a function that cannot change the tuple"
msgstr "Создание триггера замены с функцией, которая не может изменять кортеж"

#: ../doc/1.10/book/box/box_space.rst:102
msgid ":ref:`space_object:before_replace() <box_space-before_replace>`"
msgstr ":ref:`space_object:before_replace() <box_space-before_replace>`"

#: ../doc/1.10/book/box/box_space.rst:102
msgid "Create a replace trigger with a function that can change the tuple"
msgstr "Создание триггера замены с функцией, которая может изменять кортеж"

#: ../doc/1.10/book/box/box_space.rst:106
msgid ":ref:`space_object:pairs() <box_space-pairs>`"
msgstr ":ref:`space_object:pairs() <box_space-pairs>`"

#: ../doc/1.10/book/box/box_space.rst:109
msgid ":ref:`space_object:put() <box_space-replace>`"
msgstr ":ref:`space_object:put() <box_space-replace>`"

#: ../doc/1.10/book/box/box_space.rst:109
#: ../doc/1.10/book/box/box_space.rst:115
#: ../doc/1.10/reference/reference_lua/net_box.rst:146
msgid "Insert or replace a tuple"
msgstr "Вставка или замена кортежа"

#: ../doc/1.10/book/box/box_space.rst:112
msgid ":ref:`space_object:rename() <box_space-rename>`"
msgstr ":ref:`space_object:rename() <box_space-rename>`"

#: ../doc/1.10/book/box/box_space.rst:112
msgid "Rename a space"
msgstr "Переименование спейса"

#: ../doc/1.10/book/box/box_space.rst:115
msgid ":ref:`space_object:replace() <box_space-replace>`"
msgstr ":ref:`space_object:replace() <box_space-replace>`"

#: ../doc/1.10/book/box/box_space.rst:118
msgid ":ref:`space_object:run_triggers() <box_space-run_triggers>`"
msgstr ":ref:`space_object:run_triggers() <box_space-run_triggers>`"

#: ../doc/1.10/book/box/box_space.rst:118
msgid "Enable/disable a replace trigger"
msgstr "Включение/отключение триггера замены"

#: ../doc/1.10/book/box/box_space.rst:121
msgid ":ref:`space_object:select() <box_space-select>`"
msgstr ":ref:`space_object:select() <box_space-select>`"

#: ../doc/1.10/book/box/box_space.rst:121
#: ../doc/1.10/reference/reference_lua/net_box.rst:137
msgid "Select one or more tuples"
msgstr "Выбор одного или более кортежей"

#: ../doc/1.10/book/box/box_space.rst:124
msgid ":ref:`space_object:truncate() <box_space-truncate>`"
msgstr ":ref:`space_object:truncate() <box_space-truncate>`"

#: ../doc/1.10/book/box/box_space.rst:124
msgid "Delete all tuples"
msgstr "Удаление всех кортежей"

#: ../doc/1.10/book/box/box_space.rst:127
msgid ":ref:`space_object:update() <box_space-update>`"
msgstr ":ref:`space_object:update() <box_space-update>`"

#: ../doc/1.10/book/box/box_space.rst:130
msgid ":ref:`space_object:upsert() <box_space-upsert>`"
msgstr ":ref:`space_object:upsert() <box_space-upsert>`"

#: ../doc/1.10/book/box/box_space.rst:133
msgid ":ref:`space_object:user_defined() <box_space-user_defined>`"
msgstr ":ref:`space_object:user_defined() <box_space-user_defined>`"

#: ../doc/1.10/book/box/box_space.rst:136
msgid ":ref:`space_object.enabled <box_space-enabled>`"
msgstr ":ref:`space_object.enabled <box_space-enabled>`"

#: ../doc/1.10/book/box/box_space.rst:136
msgid "Flag, true if space is enabled"
msgstr "Флаг, если спейс активен -- true"

#: ../doc/1.10/book/box/box_space.rst:139
msgid ":ref:`space_object.field_count <box_space-field_count>`"
msgstr ":ref:`space_object.field_count <box_space-field_count>`"

#: ../doc/1.10/book/box/box_space.rst:139
msgid "Required number of fields"
msgstr "Необходимое количество полей"

#: ../doc/1.10/book/box/box_space.rst:142
msgid ":ref:`space_object.id <box_space-id>`"
msgstr ":ref:`space_object.id <box_space-id>`"

#: ../doc/1.10/book/box/box_space.rst:142
msgid "Numeric identifier of space"
msgstr "Числовой идентификатор спейса"

#: ../doc/1.10/book/box/box_space.rst:145
msgid ":ref:`space_object.index <box_space-space_index>`"
msgstr ":ref:`space_object.index <box_space-space_index>`"

#: ../doc/1.10/book/box/box_space.rst:145
msgid "Container of space's indexes"
msgstr "Контейнер для индексов спейса"

#: ../doc/1.10/book/box/box_space.rst:148
msgid ":ref:`box.space._cluster <box_space-cluster>`"
msgstr ":ref:`box.space._cluster <box_space-cluster>`"

#: ../doc/1.10/book/box/box_space.rst:148
msgid "(Metadata) List of replica sets"
msgstr "(Метаданные) Список наборов реплик"

#: ../doc/1.10/book/box/box_space.rst:151
msgid ":ref:`box.space._func <box_space-func>`"
msgstr ":ref:`box.space._func <box_space-func>`"

#: ../doc/1.10/book/box/box_space.rst:151
msgid "(Metadata) List of function tuples"
msgstr "(Метаданные) Список кортежей с функциями"

#: ../doc/1.10/book/box/box_space.rst:154
msgid ":ref:`box.space._index <box_space-index>`"
msgstr ":ref:`box.space._index <box_space-index>`"

#: ../doc/1.10/book/box/box_space.rst:154
msgid "(Metadata) List of indexes"
msgstr "(Метаданные) Список индексов"

#: ../doc/1.10/book/box/box_space.rst:157
msgid ":ref:`box.space._vindex <box_space-vindex>`"
msgstr ":ref:`box.space._vindex <box_space-vindex>`"

#: ../doc/1.10/book/box/box_space.rst:157
msgid "(Metadata) List of indexes accessible for the current user"
msgstr "(Метаданные) Список индексов, доступных текущему пользователю"

#: ../doc/1.10/book/box/box_space.rst:160
msgid ":ref:`box.space._priv <box_space-priv>`"
msgstr ":ref:`box.space._priv <box_space-priv>`"

#: ../doc/1.10/book/box/box_space.rst:160
msgid "(Metadata) List of privileges"
msgstr "(Метаданные) Список прав"

#: ../doc/1.10/book/box/box_space.rst:163
msgid ":ref:`box.space._vpriv <box_space-vpriv>`"
msgstr ":ref:`box.space._vpriv <box_space-vpriv>`"

#: ../doc/1.10/book/box/box_space.rst:163
msgid "(Metadata) List of privileges accessible for the current user"
msgstr "(Метаданные) Список прав, доступных текущему пользователю"

#: ../doc/1.10/book/box/box_space.rst:166
msgid ":ref:`box.space._schema <box_space-schema>`"
msgstr ":ref:`box.space._schema <box_space-schema>`"

#: ../doc/1.10/book/box/box_space.rst:166
msgid "(Metadata) List of schemas"
msgstr "(Метаданные) Список схем"

#: ../doc/1.10/book/box/box_space.rst:169
msgid ":ref:`box.space._sequence <box_space-sequence>`"
msgstr ":ref:`box.space._sequence <box_space-sequence>`"

#: ../doc/1.10/book/box/box_space.rst:169
#: ../doc/1.10/book/box/box_space.rst:172
msgid "(Metadata) List of sequences"
msgstr "(Метаданные) Список последовательностей"

#: ../doc/1.10/book/box/box_space.rst:172
msgid ":ref:`box.space._sequence_data <box_space-sequence_data>`"
msgstr ":ref:`box.space._sequence_data <box_space-sequence_data>`"

#: ../doc/1.10/book/box/box_space.rst:175
msgid ":ref:`box.space._space <box_space-space>`"
msgstr ":ref:`box.space._space <box_space-space>`"

#: ../doc/1.10/book/box/box_space.rst:175
msgid "(Metadata) List of spaces"
msgstr "(Метаданные) Список спейсов"

#: ../doc/1.10/book/box/box_space.rst:178
msgid ":ref:`box.space._vspace <box_space-vspace>`"
msgstr ":ref:`box.space._vspace <box_space-vspace>`"

#: ../doc/1.10/book/box/box_space.rst:178
msgid "(Metadata) List of spaces accessible for the current user"
msgstr "(Метаданные) Список спейсов, доступных текущему пользователю"

#: ../doc/1.10/book/box/box_space.rst:181
msgid ":ref:`box.space._user <box_space-user>`"
msgstr ":ref:`box.space._user <box_space-user>`"

#: ../doc/1.10/book/box/box_space.rst:181
msgid "(Metadata) List of users"
msgstr "(Метаданные) Список пользователей"

#: ../doc/1.10/book/box/box_space.rst:184
msgid ":ref:`box.space._vuser <box_space-vuser>`"
msgstr ":ref:`box.space._vuser <box_space-vuser>`"

#: ../doc/1.10/book/box/box_space.rst:184
msgid "(Metadata) List of users accessible for the current user"
msgstr "(Метаданные) Список пользователей, доступных текущему пользователю"

#: ../doc/1.10/book/box/box_space.rst:196
msgid ""
"Insert a new tuple using an auto-increment primary key. The space "
"specified by space_object must have an :ref:`'unsigned' or 'integer' or "
"'number' <index-box_indexed-field-types>` primary key index of type "
"``TREE``. The primary-key field will be incremented before the insert."
msgstr ""
"Вставка нового кортежа, используя первичный ключ с автоматическим "
"увеличением. В спейсе, указанном через space_object должен быть первичный"
" TREE-индекс типа :ref:`'unsigned' или 'integer', или 'number' <index-"
"box_indexed-field-types>`. Поле первичного ключа будет увеличиваться "
"перед вставкой."

#: ../doc/1.10/book/box/box_space.rst:202
msgid ""
"Since version 1.7.5 this method is deprecated – it is better to use a "
":ref:`sequence <index-box_sequence>`."
msgstr ""
"Данный метод объявлен устаревшим с версии 1.7.5 -- лучше использовать "
":ref:`последовательности <index-box_sequence>`."

#: ../doc/1.10/book/box/box_space.rst:205
#: ../doc/1.10/book/box/box_space.rst:238
#: ../doc/1.10/book/box/box_space.rst:265
#: ../doc/1.10/book/box/box_space.rst:292
#: ../doc/1.10/book/box/box_space.rst:531
#: ../doc/1.10/book/box/box_space.rst:571
#: ../doc/1.10/book/box/box_space.rst:593
#: ../doc/1.10/book/box/box_space.rst:742
#: ../doc/1.10/book/box/box_space.rst:785
#: ../doc/1.10/book/box/box_space.rst:836
#: ../doc/1.10/book/box/box_space.rst:868
#: ../doc/1.10/book/box/box_space.rst:1055
#: ../doc/1.10/book/box/box_space.rst:1117
#: ../doc/1.10/book/box/box_space.rst:1147
#: ../doc/1.10/book/box/box_space.rst:1203
#: ../doc/1.10/book/box/box_space.rst:1305
#: ../doc/1.10/book/box/box_space.rst:1366
#: ../doc/1.10/book/box/box_space.rst:1487
msgid "an :ref:`object reference <app_server-object_reference>`"
msgstr ":ref:`ссылка на объект <app_server-object_reference>`"

#: ../doc/1.10/book/box/box_space.rst:207
msgid "tuple's fields, other than the primary-key field"
msgstr "поля кортежа, не включая поле первичного ключа"

#: ../doc/1.10/book/box/box_space.rst:210
#: ../doc/1.10/book/box/box_space.rst:1151
msgid "the inserted tuple."
msgstr "вставленный кортеж."

#: ../doc/1.10/book/box/box_space.rst:213
msgid ""
"**Complexity factors:** Index size, Index type, Number of indexes "
"accessed, :ref:`WAL settings <cfg_binary_logging_snapshots-"
"rows_per_wal>`."
msgstr ""
"**Факторы сложности** Размер индекса, тип индекса, количество кортежей, к"
" которым получен доступ, :ref:`настройки журнала упреждающей записи (WAL)"
" <cfg_binary_logging_snapshots-rows_per_wal>`."

#: ../doc/1.10/book/box/box_space.rst:218
msgid "index has wrong type;"
msgstr "неподходящий тип индекса;"

#: ../doc/1.10/book/box/box_space.rst:219
msgid "primary-key indexed field is not a number."
msgstr "проиндексированное поле первичного ключа не является числовым."

#: ../doc/1.10/book/box/box_space.rst:223
msgid ""
"tarantool> box.space.tester:auto_increment{'Fld#1', 'Fld#2'}\n"
"---\n"
"- [1, 'Fld#1', 'Fld#2']\n"
"...\n"
"tarantool> box.space.tester:auto_increment{'Fld#3'}\n"
"---\n"
"- [2, 'Fld#3']\n"
"..."
msgstr ""
"tarantool> box.space.tester:auto_increment{'Fld#1', 'Fld#2'}\n"
"---\n"
"- [1, 'Fld#1', 'Fld#2']\n"
"...\n"
"tarantool> box.space.tester:auto_increment{'Fld#3'}\n"
"---\n"
"- [2, 'Fld#3']\n"
"..."

#: ../doc/1.10/book/box/box_space.rst:241
msgid ""
"Number of bytes in the space. This number, which is stored in Tarantool's"
" internal memory, represents the total number of bytes in all tuples, not"
" including index keys. For a measure of index size, see "
":ref:`index_object:bsize() <box_index-bsize>`."
msgstr ""
"Количество байтов в спейсе. Это число, которое хранится во внутренней "
"памяти Tarantool'а, представляет собой общее количество байтов во всех "
"кортежах, включая ключи индекса. Для получения информации об измерении "
"размера индекса, см. :ref:`index_object:bsize() <box_index-bsize>`."

#: ../doc/1.10/book/box/box_space.rst:249
msgid ""
"tarantool> box.space.tester:bsize()\n"
"---\n"
"- 22\n"
"..."
msgstr ""
"tarantool> box.space.tester:bsize()\n"
"---\n"
"- 22\n"
"..."

#: ../doc/1.10/book/box/box_space.rst:260
msgid ""
"Return the number of tuples. If compared with :ref:`len() <box_space-"
"len>`, this method works slower because ``count()`` scans the entire "
"space to count the tuples."
msgstr ""
"Возврат количества кортежей. Если сравнивать с :ref:`len() <box_space-"
"len>`, то данный метод работает медленнее, поскольку метод ``count()`` "
"сканирует весь спейс для подсчета кортежей."

#: ../doc/1.10/book/box/box_space.rst:267
#: ../doc/1.10/book/box/box_space.rst:533
#: ../doc/1.10/book/box/box_space.rst:1368
msgid ""
"primary-key field values, must be passed as a Lua table if key is multi-"
"part"
msgstr ""
"значения поля первичного ключа, которые должны возвращаться в виде "
"Lua-таблицы, если ключ составной"

#: ../doc/1.10/book/box/box_space.rst:271
msgid "Number of tuples."
msgstr "Количество кортежей."

#: ../doc/1.10/book/box/box_space.rst:275
msgid ""
"tarantool> box.space.tester:count(2, {iterator='GE'})\n"
"---\n"
"- 1\n"
"..."
msgstr ""
"tarantool> box.space.tester:count(2, {iterator='GE'})\n"
"---\n"
"- 1\n"
"..."

#: ../doc/1.10/book/box/box_space.rst:286
msgid ""
"Create an :ref:`index <index-box_index>`. It is mandatory to create an "
"index for a space before trying to insert tuples into it, or select "
"tuples from it. The first created index, which will be used as the "
"primary-key index, must be unique."
msgstr ""
"Создание :ref:`индекса <index-box_index>`. Индекс обязательно должен "
"создаваться для спейса до вставки в него кортежей или выборки. Первый "
"созданный индекс, который будет использоваться в качестве первичного "
"индекса, должен быть уникальным."

#: ../doc/1.10/book/box/box_space.rst:294
msgid ""
"name of index, which should conform to the :ref:`rules for object names "
"<app_server-names>`"
msgstr ""
"имя индекса, которое должно соответствовать :ref:`правилам именования "
"объектов <app_server-names>`"

#: ../doc/1.10/book/box/box_space.rst:296
msgid "see \"Options for space_object:create_index()\", below"
msgstr "см. \"Параметры для space_object:create_index()\" ниже"

#: ../doc/1.10/book/box/box_space.rst:299
msgid "index object"
msgstr "объект индекса"

#: ../doc/1.10/book/box/box_space.rst:300
msgid "index_object"
msgstr "объект индекса"

#: ../doc/1.10/book/box/box_space.rst:304
msgid "**Options for space_object:create_index()**"
msgstr "**Параметры для space_object:create_index()**"

#: ../doc/1.10/book/box/box_space.rst:318
msgid "type"
msgstr "type"

#: ../doc/1.10/book/box/box_space.rst:318
msgid "type of index"
msgstr "тип индекса"

#: ../doc/1.10/book/box/box_space.rst:318
msgid ""
"string ('HASH' or 'TREE' or 'BITSET' or 'RTREE') Note re storage engine: "
"vinyl only supports 'TREE'"
msgstr ""
"строка ('HASH' или 'TREE', или 'BITSET', или 'RTREE') Примечание про "
"движок базы данных: vinyl поддерживает только 'TREE'"

#: ../doc/1.10/book/box/box_space.rst:318
msgid "'TREE'"
msgstr "'TREE'"

#: ../doc/1.10/book/box/box_space.rst:324
msgid "unique identifier"
msgstr "уникальный идентификатор"

#: ../doc/1.10/book/box/box_space.rst:324
msgid "last index's id, +1"
msgstr "идентификатор последнего индекса +1"

#: ../doc/1.10/book/box/box_space.rst:326
msgid "unique"
msgstr "unique"

#: ../doc/1.10/book/box/box_space.rst:326
msgid "index is unique"
msgstr "индекс уникален"

#: ../doc/1.10/book/box/box_space.rst:326
msgid "``true``"
msgstr "``true`` (правда)"

#: ../doc/1.10/book/box/box_space.rst:328
msgid "no error if duplicate name"
msgstr "ошибки нет, если имя дублируется"

#: ../doc/1.10/book/box/box_space.rst:328
msgid "``false``"
msgstr "``false`` (ложь)"

#: ../doc/1.10/book/box/box_space.rst:330
msgid "parts"
msgstr "parts"

#: ../doc/1.10/book/box/box_space.rst:330
msgid "field-numbers  + types"
msgstr "номера поля + типы"

#: ../doc/1.10/book/box/box_space.rst:330
msgid ""
"{field_no, 'unsigned' or 'string' or 'integer' or 'number' or 'boolean' "
"or 'array' or 'scalar', and optional collation, and optional is_nullable "
"value}"
msgstr ""
"{field_no, 'unsigned' или 'string', или 'integer', или 'number', или "
"'boolean', или 'array', или 'scalar', возможна сортировка, возможно "
"значение is_nullable}"

#: ../doc/1.10/book/box/box_space.rst:330
msgid "``{1, 'unsigned'}``"
msgstr "``{1, 'unsigned'}``"

#: ../doc/1.10/book/box/box_space.rst:337
msgid "dimension"
msgstr "dimension"

#: ../doc/1.10/book/box/box_space.rst:337
msgid "affects :ref:`RTREE <box_index-rtree>` only"
msgstr "только для :ref:`RTREE <box_index-rtree>`"

#: ../doc/1.10/book/box/box_space.rst:337
#: ../doc/1.10/book/box/box_space.rst:2028
msgid "2"
msgstr "2"

#: ../doc/1.10/book/box/box_space.rst:339
msgid "distance"
msgstr "distance"

#: ../doc/1.10/book/box/box_space.rst:339
msgid "affects RTREE only"
msgstr "только для RTREE"

#: ../doc/1.10/book/box/box_space.rst:339
msgid "string ('euclid' or 'manhattan')"
msgstr "строка ('euclid' или 'manhattan')"

#: ../doc/1.10/book/box/box_space.rst:339
msgid "'euclid'"
msgstr "'euclid' (Евклидова)"

#: ../doc/1.10/book/box/box_space.rst:342
msgid "bloom_fpr"
msgstr "bloom_fpr"

#: ../doc/1.10/book/box/box_space.rst:342
#: ../doc/1.10/book/box/box_space.rst:344
#: ../doc/1.10/book/box/box_space.rst:346
#: ../doc/1.10/book/box/box_space.rst:348
#: ../doc/1.10/book/box/box_space.rst:350
msgid "affects vinyl only"
msgstr "только для vinyl"

#: ../doc/1.10/book/box/box_space.rst:342
msgid "``vinyl_bloom_fpr``"
msgstr "``vinyl_bloom_fpr``"

#: ../doc/1.10/book/box/box_space.rst:344
msgid "page_size"
msgstr "page_size"

#: ../doc/1.10/book/box/box_space.rst:344
msgid "``vinyl_page_size``"
msgstr "``vinyl_page_size``"

#: ../doc/1.10/book/box/box_space.rst:346
msgid "range_size"
msgstr "range_size"

#: ../doc/1.10/book/box/box_space.rst:346
msgid "``vinyl_range_size``"
msgstr "``vinyl_range_size``"

#: ../doc/1.10/book/box/box_space.rst:348
msgid "run_count_per_level"
msgstr "run_count_per_level"

#: ../doc/1.10/book/box/box_space.rst:348
msgid "``vinyl_run_count_per_level``"
msgstr "``vinyl_run_count_per_level``"

#: ../doc/1.10/book/box/box_space.rst:350
msgid "run_size_ratio"
msgstr "run_size_ratio"

#: ../doc/1.10/book/box/box_space.rst:350
msgid "``vinyl_run_size_ratio``"
msgstr "``vinyl_run_size_ratio``"

#: ../doc/1.10/book/box/box_space.rst:352
msgid "sequence"
msgstr "sequence"

#: ../doc/1.10/book/box/box_space.rst:352
msgid ""
"see section regarding :ref:`specifying a sequence in create_index() "
"<box_schema-sequence_create_index>`"
msgstr ""
"см. раздел об :ref:`указании последовательности для create_index() "
"<box_schema-sequence_create_index>`"

#: ../doc/1.10/book/box/box_space.rst:352
msgid "string or number"
msgstr "строка или число"

#: ../doc/1.10/book/box/box_space.rst:352
msgid "not present"
msgstr "отсутствует"

#: ../doc/1.10/book/box/box_space.rst:357
msgid ""
"The options in the above chart are also applicable for "
":ref:`index_object:alter() <box_index-alter>`."
msgstr ""
"Параметры в вышеуказанной таблице также применимы к "
":ref:`index_object:alter() <box_index-alter>`."

#: ../doc/1.10/book/box/box_space.rst:359
msgid ""
"**Note re storage engine:** vinyl has extra options which by default are "
"based on configuration parameters :ref:`vinyl_bloom_fpr <cfg_storage-"
"vinyl_bloom_fpr>`, :ref:`vinyl_page_size <cfg_storage-vinyl_page_size>`, "
":ref:`vinyl_range_size <cfg_storage-vinyl_range_size>`, "
":ref:`vinyl_run_count_per_level <cfg_storage-vinyl_run_count_per_level>`,"
" and :ref:`vinyl_run_size_ratio <cfg_storage-vinyl_run_size_ratio>` -- "
"see the description of those parameters. The current values can be seen "
"by selecting from :ref:`box.space._index <box_space-index>`."
msgstr ""
"**Примечание про движок базы данных:** в vinyl'е есть дополнительные "
"параметры, которые по умолчанию основаны на конфигурационных параметрах "
":ref:`vinyl_bloom_fpr <cfg_storage-vinyl_bloom_fpr>`, "
":ref:`vinyl_page_size <cfg_storage-vinyl_page_size>`, "
":ref:`vinyl_range_size <cfg_storage-vinyl_range_size>`, "
":ref:`vinyl_run_count_per_level <cfg_storage-vinyl_run_count_per_level>` "
"и :ref:`vinyl_run_size_ratio <cfg_storage-vinyl_run_size_ratio>` -- см. "
"описание этих параметров. Текущие значения можно увидеть, сделав выборку "
"из :ref:`box.space._index <box_space-index>`."

#: ../doc/1.10/book/box/box_space.rst:372
msgid "too many parts;"
msgstr "слишком много частей;"

#: ../doc/1.10/book/box/box_space.rst:373
msgid "index '...' already exists;"
msgstr "индекс '...' уже существует;"

#: ../doc/1.10/book/box/box_space.rst:374
msgid "primary key must be unique."
msgstr "первичный ключ должен быть уникальным."

#: ../doc/1.10/book/box/box_space.rst:376
msgid ""
"tarantool> s = box.space.tester\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {unique = true, parts = {1, "
"'unsigned', 2, 'string'}})\n"
"---\n"
"..."
msgstr ""
"tarantool> s = box.space.tester\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {unique = true, parts = {1, "
"'unsigned', 2, 'string'}})\n"
"---\n"
"..."

#: ../doc/1.10/book/box/box_space.rst:387
msgid "**Details about index field types:**"
msgstr "**Подробнее о типах полей индекса:**"

#: ../doc/1.10/book/box/box_space.rst:389
msgid ""
"The seven index field types (unsigned | string | integer | number | "
"boolean | array | scalar) differ depending on what values are allowed, "
"and what index types are allowed."
msgstr ""
"Семь типов полей индекса (unsigned | string | integer | number | boolean "
"| array | scalar) отличаются друг от друга возможными значениями и типами"
" индексов, где можно использовать такие поля."

#: ../doc/1.10/book/box/box_space.rst:393
msgid ""
"**unsigned**: unsigned integers between 0 and 18446744073709551615, about"
" 18 quintillion. May also be called 'uint' or 'num', but 'num' is "
"deprecated. Legal in memtx TREE or HASH indexes, and in vinyl TREE "
"indexes."
msgstr ""
"**unsigned**: беззнаковые целые числа от 0 до 18 446 744 073 709 551 615,"
" т.е. около18 квинтиллионов. Также может называться 'uint' или 'num', но "
"'num' объявлен устаревшим. Используется в индексах типа TREE или HASH в "
"memtx'е, и в TREE-индексах в vinyl'е."

#: ../doc/1.10/book/box/box_space.rst:397
msgid ""
"**string**: any set of octets, up to the :ref:`maximum length "
"<limitations_bytes_in_index_key>`. May also be called 'str'. Legal in "
"memtx TREE or HASH or BITSET indexes, and in vinyl TREE indexes. A string"
" may have a :ref:`collation <index-collation>`."
msgstr ""
"**string**: строка, то есть любая последовательность октетов до "
":ref:`максимальной длины <limitations_bytes_in_index_key>`. Также может "
"называться 'str'. Используется в индексах типа TREE, HASH или BITSET в "
"memtx'е и в TREE-индексах в vinyl'е. В строке может быть :ref:`сортировка"
" <index-collation>`."

#: ../doc/1.10/book/box/box_space.rst:401
msgid ""
"**integer**: integers between -9223372036854775808 and "
"18446744073709551615. May also be called 'int'. Legal in memtx TREE or "
"HASH indexes, and in vinyl TREE indexes."
msgstr ""
"**integer**: целые числа от -9 223 372 036 854 775 808 до 18 446 744 073 "
"709 551 615. Также может называться 'int'. Используется в индексах типа "
"TREE или HASH в memtx'е и в TREE-индексах в vinyl'е."

#: ../doc/1.10/book/box/box_space.rst:404
msgid ""
"**number**: integers between -9223372036854775808 and "
"18446744073709551615, single-precision floating point numbers, or double-"
"precision floating point numbers. Legal in memtx TREE or HASH indexes, "
"and in vinyl TREE indexes."
msgstr ""
"**number**: целые числа от -9 223 372 036 854 775 808 до 18 446 744 073 "
"709 551 615, числа с плавающей запятой с одинарной точностью или с "
"двойной точностью. Используется в индексах типа TREE или HASH в memtx'е и"
" в TREE-индексах в vinyl'е."

#: ../doc/1.10/book/box/box_space.rst:408
msgid ""
"**boolean**: true or false. Legal in memtx TREE or HASH indexes, and in "
"vinyl TREE indexes."
msgstr ""
"**boolean**: логическое значение, true (правда) или false (ложь). "
"Используется в индексах типа TREE или HASH в memtx'е и в TREE-индексах в "
"vinyl'е."

#: ../doc/1.10/book/box/box_space.rst:410
msgid ""
"**array**: array of numbers. Legal in memtx :ref:`RTREE <box_index-"
"rtree>` indexes."
msgstr ""
"**array**: массив чисел. Используется в :ref:`RTREE-индексах <box_index-"
"rtree>` в memtx'е."

#: ../doc/1.10/book/box/box_space.rst:411
msgid ""
"**scalar**: booleans (true or false), or integers between "
"-9223372036854775808 and 18446744073709551615, or single-precision "
"floating point numbers, or double-precison floating-point numbers, or "
"strings. When there is a mix of types, the key order is: booleans, then "
"numbers, then strings. Legal in memtx TREE or HASH indexes, and in vinyl "
"TREE indexes."
msgstr ""
"**scalar**: логические значения (true или false), целые числа от integers"
" between -9 223 372 036 854 775 808 до 18 446 744 073 709 551 615, числа "
"с плавающей запятой с одинарной точностью или с двойной точностью или "
"строки. При использовании нескольких типов, порядок ключей должен быть "
"следующим: логические значения, затем числа, затем строки. Используется в"
" индексах типа TREE или HASH в memtx'е и в TREE-индексах в vinyl'е."

#: ../doc/1.10/book/box/box_space.rst:418
msgid ""
"Additionally, `nil` is allowed with any index field type if "
":ref:`is_nullable=true <box_space-is_nullable>` is specified."
msgstr ""
"Кроме того, допускается нулевое значение `nil` для любого типа поля, если"
" указана такая возможность :ref:`is_nullable=true <box_space-"
"is_nullable>`."

#: ../doc/1.10/book/box/box_space.rst:423
msgid "**Index field types to use in space_object:create_index()**"
msgstr "**Типы полей в индексах для использования в space_object:create_index()**"

#: ../doc/1.10/book/box/box_space.rst:436
msgid "Index field type"
msgstr "Тип поля для индексирования"

#: ../doc/1.10/book/box/box_space.rst:436
msgid "What can be in it"
msgstr "Чем может быть"

#: ../doc/1.10/book/box/box_space.rst:436
msgid "Where is it legal"
msgstr "Где может использоваться"

#: ../doc/1.10/book/box/box_space.rst:436
#: ../doc/1.10/book/box/data_model.rst:305
#: ../doc/1.10/book/box/data_model.rst:488
#: ../doc/1.10/reference/reference_lua/socket.rst:656
msgid "Examples"
msgstr "Примеры"

#: ../doc/1.10/book/box/box_space.rst:438
msgid "**unsigned**"
msgstr "**unsigned**"

#: ../doc/1.10/book/box/box_space.rst:438
msgid "integers between 0 and 18446744073709551615"
msgstr "целые числа от 0 до 18 446 744 073 709 551 615"

#: ../doc/1.10/book/box/box_space.rst:438
#: ../doc/1.10/book/box/box_space.rst:445
#: ../doc/1.10/book/box/box_space.rst:449
#: ../doc/1.10/book/box/box_space.rst:457
#: ../doc/1.10/book/box/box_space.rst:464
msgid "memtx TREE or HASH indexes, |br| vinyl TREE indexes"
msgstr "индексы типа TREE или HASH в memtx'е, |br| TREE-индексы в vinyl'е"

#: ../doc/1.10/book/box/box_space.rst:438
msgid "123456 |br|"
msgstr "123456 |br|"

#: ../doc/1.10/book/box/box_space.rst:442
msgid "**string**"
msgstr "**string**"

#: ../doc/1.10/book/box/box_space.rst:442
msgid "strings -- any set of octets"
msgstr "строки -- любой набор октетов"

#: ../doc/1.10/book/box/box_space.rst:442
msgid "memtx TREE or HASH indexes |br| vinyl TREE indexes"
msgstr "индексы типа TREE или HASH в memtx'е |br| TREE-индексы в vinyl'е"

#: ../doc/1.10/book/box/box_space.rst:442
msgid "'A B C' |br| '\\\\65 \\\\66 \\\\67'"
msgstr "'A B C' |br| '\\\\65 \\\\66 \\\\67'"

#: ../doc/1.10/book/box/box_space.rst:445
msgid "**integer**"
msgstr "**integer**"

#: ../doc/1.10/book/box/box_space.rst:445
msgid "integers between -9223372036854775808 and 18446744073709551615"
msgstr "целые числа от -9 223 372 036 854 775 808 до 18 446 744 073 709 551 615"

#: ../doc/1.10/book/box/box_space.rst:445
msgid "-2^63 |br|"
msgstr "-2^63 |br|"

#: ../doc/1.10/book/box/box_space.rst:449
#: ../doc/1.10/book/box/data_model.rst:318
msgid "**number**"
msgstr "**number**"

#: ../doc/1.10/book/box/box_space.rst:449
msgid ""
"integers between -9223372036854775808 and 18446744073709551615, single-"
"precision floating point numbers, double-precision floating point numbers"
msgstr ""
"целые числа от -9 223 372 036 854 775 808 до 18 446 744 073 709 551 615, "
"числа с плавающей запятой с одинарной точностью или с двойной точностью"

#: ../doc/1.10/book/box/box_space.rst:449
msgid "1.234 |br| -44 |br| 1.447e+44"
msgstr "1.234 |br| -44 |br| 1.447e+44"

#: ../doc/1.10/book/box/box_space.rst:457
#: ../doc/1.10/book/box/data_model.rst:332
msgid "**boolean**"
msgstr "**boolean**"

#: ../doc/1.10/book/box/box_space.rst:457
#: ../doc/1.10/reference/reference_lua/string.rst:178
#: ../doc/1.10/reference/reference_lua/string.rst:208
#: ../doc/1.10/reference/reference_lua/utf8.rst:182
#: ../doc/1.10/reference/reference_lua/utf8.rst:207
#: ../doc/1.10/reference/reference_lua/utf8.rst:229
#: ../doc/1.10/reference/reference_lua/utf8.rst:251
msgid "true or false"
msgstr "true или false"

#: ../doc/1.10/book/box/box_space.rst:457
msgid "false |br| true"
msgstr "false |br| true"

#: ../doc/1.10/book/box/box_space.rst:460
#: ../doc/1.10/book/box/data_model.rst:335
msgid "**array**"
msgstr "**array**"

#: ../doc/1.10/book/box/box_space.rst:460
msgid "array of integers between -9223372036854775808 and 9223372036854775807"
msgstr ""
"массив целых чисел от -9 223 372 036 854 775 808 до 9 223 372 036 854 775"
" 807"

#: ../doc/1.10/book/box/box_space.rst:460
msgid "memtx RTREE indexes"
msgstr "RTREE-индексы в memtx'е"

#: ../doc/1.10/book/box/box_space.rst:460
msgid "{10, 11} |br| {3, 5, 9, 10}"
msgstr "{10, 11} |br| {3, 5, 9, 10}"

#: ../doc/1.10/book/box/box_space.rst:464
#: ../doc/1.10/book/box/data_model.rst:340
msgid "**scalar**"
msgstr "**scalar**"

#: ../doc/1.10/book/box/box_space.rst:464
msgid ""
"booleans (true or false), integers between -9223372036854775808 and "
"18446744073709551615, single-precision floating point numbers, double-"
"precision floating point numbers, strings"
msgstr ""
"логические значения (true или false), целые числа от -9 223 372 036 854 "
"775 808 до 18 446 744 073 709 551 615, числа с плавающей запятой с "
"одинарной точностью или с двойной точностью, строки"

#: ../doc/1.10/book/box/box_space.rst:464
msgid "true |br| -1 |br| 1.234 |br| '' |br| 'ру'"
msgstr "true |br| -1 |br| 1.234 |br| '' |br| 'ру'"

#: ../doc/1.10/book/box/box_space.rst:476
msgid ""
"**Allowing null for an indexed key:** If the index type is TREE, and the "
"index is not the primary index, then the ``parts={...}`` clause may "
"include ``is_nullable=true`` or ``is_nullable=false`` (the default). If "
"``is_nullable`` is true, then it is legal to insert ``nil`` or an "
"equivalent such as ``msgpack.NULL`` (or it is legal to insert nothing at "
"all for trailing nullable fields). Within indexes, such \"null values\" "
"are always treated as equal to other null values, and are always treated "
"as less than non-null values. Nulls may appear multiple times even in a "
"unique index. Example:"
msgstr ""
"**Разрешение использования нулевых значений для индексируемого ключа:** "
"/Если тип индекса -- TREE, и индекс не является первичным, то оператор "
"``parts={...}`` может включать в себя ``is_nullable=true`` или "
"``is_nullable=false`` (по умолчанию). Если значение параметра "
"``is_nullable`` -- true, то можно вставлять ``nil`` или аналогичное "
"значение, например ``msgpack.NULL`` (или можно не вставлять вообще ничего"
" в завершающие ненулевые поля). В рамках индекса такие нулевые значения "
"считаются равными другим нулевым значениям и всегда меньше ненулевых "
"значений. Нулевые значения могут встречаться несколько раз даже в "
"уникальном индексе. Например:"

#: ../doc/1.10/book/box/box_space.rst:485
msgid "box.space.tester:create_index('I',{unique=true,parts={{2,'number',is_nullable=true}}})"
msgstr "box.space.tester:create_index('I',{unique=true,parts={{2,'number',is_nullable=true}}})"

#: ../doc/1.10/book/box/box_space.rst:491
msgid ""
"It is legal to create multiple indexes for the same field with different "
"``is_nullable`` values, or to call :ref:`space_object:format() "
"<box_space-format>` with a different ``is_nullable`` value from what is "
"used for an index. When there is a contradiction, the rule is: null is "
"illegal unless ``is_nullable=true`` for every index and for the space "
"format."
msgstr ""
"Можно создать множество индексов для одного и того же поля с различными "
"значениями ``is_nullable`` или вызвать :ref:`space_object:format() "
"<box_space-format>` со значением ``is_nullable``, отличным от "
"используемого для индекса. При наличии несоответствий правило такое: "
"запрещается использовать null кроме случаев, когда ``is_nullable=true`` "
"для всех индексов и формата спейса."

#: ../doc/1.10/book/box/box_space.rst:499
msgid ""
"**Using field names instead of field numbers:** ``create_index()`` can "
"use field names and/or field types described by the optional "
":ref:`space_object:format() <box_space-format>` clause. In the following "
"example, we show ``format()`` for a space that has two columns named 'x' "
"and 'y', and then we show five variations of the ``parts={}`` clause of "
"``create_index()``, first for the 'x' column, second for both the 'x' and"
" 'y' columns. The variations include omitting the type, using numbers, "
"and adding extra braces."
msgstr ""
"**Использование имен полей вместо номеров полей:** в ``create_index()`` "
"можно использовать имена полей и/или типы полей, описанные в "
"необязательном операторе :ref:`space_object:format() <box_space-format>`."
" В следующем примере покажем ``format()`` для спейса с двумя столбцами "
"под названиями 'x' и 'y', а затем покажем пять вариантов оператора "
"``parts={}`` в ``create_index()``, сначала для столбца 'x', затем для "
"столбцов 'x' и 'y'. Варианты включают в себя пропуск типа, использование "
"номеров и добавление дополнительных фигурных скобок."

#: ../doc/1.10/book/box/box_space.rst:508
msgid ""
"box.space.tester:format({{name='x', type='scalar'}, {name='y', "
"type='integer'}})\n"
"box.space.tester:create_index('I2',{parts={{'x','scalar'}}})\n"
"box.space.tester:create_index('I3',{parts={{'x','scalar'},{'y','integer'}}})"
"\n"
"box.space.tester:create_index('I4',{parts={1,'scalar'}})\n"
"box.space.tester:create_index('I5',{parts={1,'scalar',2,'integer'}})\n"
"box.space.tester:create_index('I6',{parts={1}})\n"
"box.space.tester:create_index('I7',{parts={1,2}})\n"
"box.space.tester:create_index('I8',{parts={'x'}})\n"
"box.space.tester:create_index('I9',{parts={'x','y'}})\n"
"box.space.tester:create_index('I10',{parts={{'x'}}})\n"
"box.space.tester:create_index('I11',{parts={{'x'},{'y'}}})"
msgstr ""
"box.space.tester:format({{name='x', type='scalar'}, {name='y', "
"type='integer'}})\n"
"box.space.tester:create_index('I2',{parts={{'x','scalar'}}})\n"
"box.space.tester:create_index('I3',{parts={{'x','scalar'},{'y','integer'}}})"
"\n"
"box.space.tester:create_index('I4',{parts={1,'scalar'}})\n"
"box.space.tester:create_index('I5',{parts={1,'scalar',2,'integer'}})\n"
"box.space.tester:create_index('I6',{parts={1}})\n"
"box.space.tester:create_index('I7',{parts={1,2}})\n"
"box.space.tester:create_index('I8',{parts={'x'}})\n"
"box.space.tester:create_index('I9',{parts={'x','y'}})\n"
"box.space.tester:create_index('I10',{parts={{'x'}}})\n"
"box.space.tester:create_index('I11',{parts={{'x'},{'y'}}})"

#: ../doc/1.10/book/box/box_space.rst:522
msgid ""
"**Note re storage engine:** vinyl supports only the TREE index type, and "
"vinyl secondary indexes must be created before tuples are inserted."
msgstr ""
"**Примечание про движок базы данных:** vinyl поддерживает только "
"TREE-индексы, и следует создать в vinyl'е вторичные индексы до вставки "
"кортежей."

#: ../doc/1.10/book/box/box_space.rst:529
msgid "Delete a tuple identified by a primary key."
msgstr "Удаление кортежа по первичному ключу."

#: ../doc/1.10/book/box/box_space.rst:536
msgid "the deleted tuple"
msgstr "удаленный кортеж."

#: ../doc/1.10/book/box/box_space.rst:539
msgid "**Complexity factors:** Index size, Index type"
msgstr "**Факторы сложности:** Размер индекса, тип индекса"

#: ../doc/1.10/book/box/box_space.rst:541
msgid ""
"**Note re storage engine:** vinyl will return ``nil``, rather than the "
"deleted tuple."
msgstr ""
"**Примечание про движок базы данных:** vinyl вернет ``nil``, а не "
"удаленный кортеж."

#: ../doc/1.10/book/box/box_space.rst:546
msgid ""
"tarantool> box.space.tester:delete(1)\n"
"---\n"
"- [1, 'My first tuple']\n"
"...\n"
"tarantool> box.space.tester:delete(1)\n"
"---\n"
"...\n"
"tarantool> box.space.tester:delete('a')\n"
"---\n"
"- error: 'Supplied key type of part 0 does not match index part type:\n"
"  expected unsigned'\n"
"..."
msgstr ""
"tarantool> box.space.tester:delete(1)\n"
"---\n"
"- [1, 'My first tuple']\n"
"...\n"
"tarantool> box.space.tester:delete(1)\n"
"---\n"
"...\n"
"tarantool> box.space.tester:delete('a')\n"
"---\n"
"- error: 'Supplied key type of part 0 does not match index part type:\n"
"  expected unsigned'\n"
"..."

#: ../doc/1.10/book/box/box_space.rst:561
#: ../doc/1.10/book/box/box_space.rst:855
#: ../doc/1.10/book/box/box_space.rst:1167
#: ../doc/1.10/book/box/box_space.rst:1295
#: ../doc/1.10/book/box/box_space.rst:1467
#: ../doc/1.10/book/box/box_space.rst:1515
msgid ""
"For more usage scenarios and typical errors see :ref:`Example: using data"
" operations <box_space-operations-detailed-examples>` further in this "
"section."
msgstr ""
"Для получения дополнительной информации о сценариях использования и "
"типичных ошибках, см. :ref:`Пример: использование операций с данными "
"<box_space-operations-detailed-examples>` далее в разделе."

#: ../doc/1.10/book/box/box_space.rst:569
msgid "Drop a space."
msgstr "Удаление спейса."

#: ../doc/1.10/book/box/box_space.rst:576
#: ../doc/1.10/book/box/box_space.rst:793
#: ../doc/1.10/book/box/box_space.rst:1123
msgid "**Possible errors:** ``space_object`` does not exist."
msgstr "**Возможные ошибки:** ``space_object`` не существует."

#: ../doc/1.10/book/box/box_space.rst:578
#: ../doc/1.10/book/box/box_space.rst:795
#: ../doc/1.10/book/box/box_space.rst:1158
msgid ""
"**Complexity factors:** Index size, Index type, Number of indexes "
"accessed, WAL settings."
msgstr ""
"**Факторы сложности** Размер индекса, тип индекса, количество кортежей, к"
" которым получен доступ, настройки журнала упреждающей записи (WAL)."

#: ../doc/1.10/book/box/box_space.rst:583
msgid "box.space.space_that_does_not_exist:drop()"
msgstr "box.space.space_that_does_not_exist:drop()"

#: ../doc/1.10/book/box/box_space.rst:591
msgid "Declare field names and :ref:`types <index-box_data-types>`."
msgstr "Объявление имен и :ref:`типов <index-box_data-types>` полей."

#: ../doc/1.10/book/box/box_space.rst:595
msgid "a list of field names and types"
msgstr "список имен и типов полей"

#: ../doc/1.10/book/box/box_space.rst:597
msgid "nil, unless format-clause is omitted"
msgstr "nil, если не указан оператор формата"

#: ../doc/1.10/book/box/box_space.rst:601
msgid "``space_object`` does not exist;"
msgstr "``space_object`` не существует,"

#: ../doc/1.10/book/box/box_space.rst:602
msgid "field names are duplicated;"
msgstr "дублируются имена полей;"

#: ../doc/1.10/book/box/box_space.rst:603
msgid "type is not legal."
msgstr "тип не поддерживается."

#: ../doc/1.10/book/box/box_space.rst:605
msgid ""
"Ordinarily Tarantool allows unnamed untyped fields. But with ``format`` "
"users can, for example, document that the Nth field is the surname field "
"and must contain strings. It is also possible to specify a format clause "
"in :ref:`box.schema.space.create() <box_schema-space_create>`."
msgstr ""
"Как правило, Tarantool допускает поля без имен и без указания типа. Но с "
"помощью ``format`` можно, например, задокументировать, что N-ное поле "
"представляет собой поле для фамилии и должно содержать строковое "
"значение. Также оператор формата можно указать в "
":ref:`box.schema.space.create() <box_schema-space_create>`."

#: ../doc/1.10/book/box/box_space.rst:611
msgid ""
"The format clause contains, for each field, a definition within braces: "
"``{name='...',type='...'[,is_nullable=...]}``, where:"
msgstr ""
"Оператор формата для каждого поля содержит определение в фигурных "
"скобках: ``{name='...',type='...'[,is_nullable=...]}``, где:"

#: ../doc/1.10/book/box/box_space.rst:614
msgid ""
"the ``name`` value may be any string, provided that two fields do not "
"have the same name;"
msgstr ""
"значение ``name`` может представлять собой любую строку при условии, что "
"у двух полей не будет одинаковых имен;"

#: ../doc/1.10/book/box/box_space.rst:616
msgid ""
"the ``type`` value may be any of those allowed for :ref:`indexed fields "
"<index-box_indexed-field-types>`: unsigned | string | integer | number | "
"boolean | array | scalar (the same as the requirement in :ref:`\"Options "
"for space_object:create_index\" <box_space-create_index-options>`);"
msgstr ""
"значением ``type`` может быть любой допустимый тип для "
":ref:`индексируемых полей <index-box_indexed-field-types>`: unsigned | "
"string | integer | number | boolean | array | scalar (такое же "
"требование, как для :ref:`\"Параметров для space_object:create_index\" "
"<box_space-create_index-options>`);"

#: ../doc/1.10/book/box/box_space.rst:621
msgid ""
"the optional ``is_nullable`` value may be either ``true`` or ``false`` "
"(the same as the requirement in :ref:`\"Options for "
"space_object:create_index\" <box_space-create_index-options>`). See also "
"the warning notice in section :ref:`Allowing null for an indexed key "
"<box_space-is_nullable>`."
msgstr ""
"значение необязательного параметра ``is_nullable`` может быть ``true`` "
"или ``false`` (такое же требование, как для :ref:`\"Параметров для "
"space_object:create_index\" <box_space-create_index-options>`). См. также"
" предупреждение в разделе :ref:`Разрешение использования нулевых значений"
" для индексируемого ключа<box_space-is_nullable>`."

#: ../doc/1.10/book/box/box_space.rst:627
msgid ""
"It is not legal for tuples to contain values that have the wrong type; "
"for example after ``box.space.tester:format({{' ',type='number'}})`` the "
"request ``box.space.tester:insert{'string-which-is-not-a-number'}`` will "
"cause an error."
msgstr ""
"В кортежах недопустимы значения неправильного типа; например, после "
"``box.space.tester:format({{' ',type='number'}})`` (тип = число) запрос "
"``box.space.tester:insert{'строка-которая-не-является-числом'}`` вызовет "
"ошибку."

#: ../doc/1.10/book/box/box_space.rst:631
msgid ""
"It is not legal for tuples to contain null values if "
"``is_nullable=false``, which is the default; for example after "
"``box.space.tester:format({{' ',type='number',is_nullable=false}})`` the "
"request ``box.space.tester:insert{nil,2}`` will cause an error."
msgstr ""
"В кортежах недопустимы нулевые значения, если ``is_nullable=false``, что "
"задано по умолчанию; например, после ``box.space.tester:format({{' "
"',type='number',is_nullable=false}})`` запрос "
"``box.space.tester:insert{nil,2}`` вызовет ошибку."

#: ../doc/1.10/book/box/box_space.rst:635
msgid ""
"It is legal for tuples to have more fields than are described by a format"
" clause. The way to constrain the number of fields is to specify a "
"space's :ref:`field_count <box_space-field_count>` member."
msgstr ""
"В кортежах может быть больше полей, чем описано в операторе формата. "
"Чтобы ограничить количество полей, необходимо указать элемент спейса "
":ref:`field_count <box_space-field_count>`."

#: ../doc/1.10/book/box/box_space.rst:639
msgid ""
"It is legal for tuples to have fewer fields than are described by a "
"format clause, if the omitted trailing fields are described with "
"``is_nullable=true``; for example after "
"``box.space.tester:format({{'a',type='number'},{'b',type='number',is_nullable=true}})``"
" the request ``box.space.tester:insert{2}`` will not cause a format-"
"related error."
msgstr ""
"В кортежах может быть меньше полей, чем описано в операторе формата, если"
" пропущенные завершающие поля описаны с помощью ``is_nullable=true``; "
"например после "
"``box.space.tester:format({{'a',type='number'},{'b',type='number',is_nullable=true}})``"
" запрос ``box.space.tester:insert{2}`` не приведет к ошибке формата."

#: ../doc/1.10/book/box/box_space.rst:644
msgid ""
"It is legal to use ``format`` on a space that already has a format, thus "
"replacing any previous definitions, provided that there is no conflict "
"with existing data or index definitions."
msgstr ""
"Можно использовать ``format`` для спейса, в котором уже определен формат,"
" заменяя таким образом предыдущие определения при условии, что нет "
"конфликта с существующими данными или определениями индекса."

#: ../doc/1.10/book/box/box_space.rst:648
msgid ""
"It is legal to use ``format`` to change the ``is_nullable`` flag; for "
"example after ``box.space.tester:format({{' "
"',type='scalar',is_nullable=false}})`` the request "
"``box.space.tester:format({{' ',type='scalar',is_nullable=true}})`` will "
"not cause an error -- and will not cause rebuilding of the space. But "
"going the other way and changing ``is_nullable`` from ``true`` to "
"``false`` might cause rebuilding and might cause an error if there are "
"existing tuples with nulls."
msgstr ""
"Можно использовать ``format`` для того, чтобы изменить значение флага "
"``is_nullable``; например, после ``box.space.tester:format({{' "
"',type='scalar',is_nullable=false}})`` запрос "
"``box.space.tester:format({{' ',type='scalar',is_nullable=true}})`` не "
"вызовет ошибку -- и не приведет к перестроению спейса. Но обратное "
"изменение значения ``is_nullable`` с ``true`` на ``false`` может вызвать "
"перестроение и привести к ошибке, если уже есть кортежи с нулевыми "
"значениями."

#: ../doc/1.10/book/box/box_space.rst:658
msgid ""
"box.space.tester:format({{name='surname',type='string'},{name='IDX',type='array'}})"
"\n"
"box.space.tester:format({{name='surname',type='string',is_nullable=true}})"
msgstr ""
"box.space.tester:format({{name='surname',type='string'},{name='IDX',type='array'}})"
"\n"
"box.space.tester:format({{name='surname',type='string',is_nullable=true}})"

#: ../doc/1.10/book/box/box_space.rst:664
msgid "There are legal variations of the format clause:"
msgstr "Можно использовать следующие варианты оператора:"

#: ../doc/1.10/book/box/box_space.rst:666
msgid "omitting both 'name=' and 'type=',"
msgstr "пропуск и 'name=', и 'type=',"

#: ../doc/1.10/book/box/box_space.rst:667
msgid "omitting 'type=' alone, and"
msgstr "пропуск 'type=' и"

#: ../doc/1.10/book/box/box_space.rst:668
msgid "adding extra braces."
msgstr "добавление дополнительных фигурных скобок."

#: ../doc/1.10/book/box/box_space.rst:670
msgid ""
"The following examples show all the variations, first for one field named"
" 'x', second for two fields named 'x' and 'y'."
msgstr ""
"В следующем примере иллюстрируются все варианты, первый для поля с именем"
" 'x', второй -- для двух полей с именами 'x' и 'y'."

#: ../doc/1.10/book/box/box_space.rst:673
msgid ""
"box.space.tester:format({{'x'}})\n"
"box.space.tester:format({{'x'},{'y'}})\n"
"box.space.tester:format({{name='x',type='scalar'}})\n"
"box.space.tester:format({{name='x',type='scalar'},{name='y',type='unsigned'}})"
"\n"
"box.space.tester:format({{name='x'}})\n"
"box.space.tester:format({{name='x'},{name='y'}})\n"
"box.space.tester:format({{'x',type='scalar'}})\n"
"box.space.tester:format({{'x',type='scalar'},{'y',type='unsigned'}})\n"
"box.space.tester:format({{'x','scalar'}})\n"
"box.space.tester:format({{'x','scalar'},{'y','unsigned'}})"
msgstr ""
"box.space.tester:format({{'x'}})\n"
"box.space.tester:format({{'x'},{'y'}})\n"
"box.space.tester:format({{name='x',type='scalar'}})\n"
"box.space.tester:format({{name='x',type='scalar'},{name='y',type='unsigned'}})"
"\n"
"box.space.tester:format({{name='x'}})\n"
"box.space.tester:format({{name='x'},{name='y'}})\n"
"box.space.tester:format({{'x',type='scalar'}})\n"
"box.space.tester:format({{'x',type='scalar'},{'y',type='unsigned'}})\n"
"box.space.tester:format({{'x','scalar'}})\n"
"box.space.tester:format({{'x','scalar'},{'y','unsigned'}})"

#: ../doc/1.10/book/box/box_space.rst:686
msgid ""
"The following example shows how to create a space, format it with all "
"possible types, and insert into it."
msgstr ""
"В следующем примере показывается создание спейса, определение формата для"
" него со всеми возможными типа и вставка данных."

#: ../doc/1.10/book/box/box_space.rst:689
msgid ""
"tarantool> box.schema.space.create('t')\n"
"--- ...\n"
"tarantool> box.space.t:format({{name='1',type='any'},\n"
"         >                     {name='2',type='unsigned'},\n"
"         >                     {name='3',type='string'},\n"
"         >                     {name='4',type='number'},\n"
"         >                     {name='5',type='integer'},\n"
"         >                     {name='6',type='boolean'},\n"
"         >                     {name='7',type='scalar'},\n"
"         >                     {name='8',type='array'},\n"
"         >                     {name='9',type='map'}})\n"
"--- ...\n"
"tarantool> box.space.t:create_index('i',{parts={2,'unsigned'}})\n"
"--- ...\n"
"tarantool> box.space.t:insert{{'a'},      -- any\n"
"         >                    1,          -- unsigned\n"
"         >                    'W?',       -- string\n"
"         >                    5.5,        -- number\n"
"         >                    -0,         -- integer\n"
"         >                    true,       -- boolean\n"
"         >                    true,       -- scalar\n"
"         >                    {{'a'}},    -- array\n"
"         >                    {val=1}}    -- map\n"
"---\n"
"- [['a'], 1, 'W?', 5.5, 0, true, true, [['a']], {'val': 1}]\n"
"..."
msgstr ""
"tarantool> box.schema.space.create('t')\n"
"--- ...\n"
"tarantool> box.space.t:format({{name='1',type='any'},\n"
"         >                     {name='2',type='unsigned'},\n"
"         >                     {name='3',type='string'},\n"
"         >                     {name='4',type='number'},\n"
"         >                     {name='5',type='integer'},\n"
"         >                     {name='6',type='boolean'},\n"
"         >                     {name='7',type='scalar'},\n"
"         >                     {name='8',type='array'},\n"
"         >                     {name='9',type='map'}})\n"
"--- ...\n"
"tarantool> box.space.t:create_index('i',{parts={2,'unsigned'}})\n"
"--- ...\n"
"tarantool> box.space.t:insert{{'a'},      -- any\n"
"         >                    1,          -- unsigned\n"
"         >                    'W?',       -- string\n"
"         >                    5.5,        -- number\n"
"         >                    -0,         -- integer\n"
"         >                    true,       -- boolean\n"
"         >                    true,       -- scalar\n"
"         >                    {{'a'}},    -- array\n"
"         >                    {val=1}}    -- map\n"
"---\n"
"- [['a'], 1, 'W?', 5.5, 0, true, true, [['a']], {'val': 1}]\n"
"..."

#: ../doc/1.10/book/box/box_space.rst:718
msgid ""
"Names specified with the format clause can be used in "
":ref:`space_object:get() <box_space-get>` and in "
":ref:`space_object:create_index() <box_space-create_index>` and in "
":ref:`tuple_object[field-name] <box_tuple-field_name>` and in "
":ref:`tuple_object[field-path] <box_tuple-field_path>`."
msgstr ""
"Имена, указанные с помощью оператора формата, можно использовать в "
":ref:`space_object:get() <box_space-get>`, в "
":ref:`space_object:create_index() <box_space-create_index>`, в "
":ref:`tuple_object[field-name] <box_tuple-field_name>` и в "
":ref:`tuple_object[field-path] <box_tuple-field_path>`."

#: ../doc/1.10/book/box/box_space.rst:724
msgid ""
"If the format clause is omitted, then the returned value is the table "
"that was used in a previous :samp:`{space_object}:format({format-"
"clause})` invocation. For example, after "
"``box.space.tester:format({{'x','scalar'}})``, "
"``box.space.tester:format()`` will return ``[{'name': 'x', 'type': "
"'scalar'}]``."
msgstr ""
"Если оператор формата не указан, то вернется таблица, которая "
"использовалась при предыдущем вызове "
":samp:`{объект-спейса}:format({оператор-формата})`. Например, после "
"``box.space.tester:format({{'x','scalar'}})``, "
"``box.space.tester:format()`` вернет ``[{'name': 'x', 'type': "
"'scalar'}]``."

#: ../doc/1.10/book/box/box_space.rst:729
msgid ""
"**Note re storage engine:** vinyl supports formatting of non-empty "
"spaces. Primary index definition cannot be formatted."
msgstr ""
"**Примечание про движок базы данных:** vinyl поддерживает форматирование "
"не пустых спейсов. Определение первичного индекса форматировать нельзя."

#: ../doc/1.10/book/box/box_space.rst:736
msgid ""
"Convert a map to a tuple instance or to a table. The map must consist of "
"\"field name = value\" pairs. The field names and the value types must "
"match names and types stated previously for the space, via "
":ref:`space_object:format() <box_space-format>`."
msgstr ""
"Конвертация ассоциативного массива в экземпляр кортежа или в таблицу. "
"Ассоциативный массив должен состоять из пар \"имя поля = значение\". "
"Имена полей и типы значений должны соответствовать именам и типам, ранее "
"заданным для спейса через :ref:`space_object:format() <box_space-"
"format>`."

#: ../doc/1.10/book/box/box_space.rst:744
msgid "a series of \"field = value\" pairs, in any order."
msgstr "ряд пар \"поле = значение\" в любом порядке."

#: ../doc/1.10/book/box/box_space.rst:745
msgid ""
"the only legal option is ``{table = true|false}``; |br| if the option is "
"omitted or if ``{table = false}``, then return type will be 'cdata' (i.e."
" tuple); |br| if ``{table = true}``, then return type will be 'table'."
msgstr ""
"единственный возможный параметр ``{table = true|false}``; |br| если "
"параметр не указан, или же ``{table = false}``, то возвращается 'cdata' "
"(то есть кортеж); |br| если ``{table = true}``, то возвращается таблица."

#: ../doc/1.10/book/box/box_space.rst:750
msgid "a tuple instance or table."
msgstr "кортеж или таблица."

#: ../doc/1.10/book/box/box_space.rst:751
msgid "tuple or table"
msgstr "кортеж или таблица"

#: ../doc/1.10/book/box/box_space.rst:753
msgid ""
"**Possible errors:** ``space_object`` does not exist or has no format; "
"\"unknown field\"."
msgstr ""
"**Возможные ошибки:** отсутствует объект спейса ``space_object``, или в "
"спейсе нет формата; \"unknown field\" (неизвестное поле)."

#: ../doc/1.10/book/box/box_space.rst:757
msgid ""
"-- Create a format with two fields named 'a' and 'b'.\n"
"-- Create a space with that format.\n"
"-- Create a tuple based on a map consistent with that space.\n"
"-- Create a table based on a map consistent with that space.\n"
"tarantool> format1 = "
"{{name='a',type='unsigned'},{name='b',type='scalar'}}\n"
"---\n"
"...\n"
"tarantool> s = box.schema.create_space('test', {format = format1})\n"
"---\n"
"...\n"
"tarantool> s:frommap({b = 'x', a = 123456})\n"
"---\n"
"- [123456, 'x']\n"
"...\n"
"tarantool> s:frommap({b = 'x', a = 123456}, {table = true})\n"
"---\n"
"- - 123456\n"
"  - x\n"
"..."
msgstr ""
"-- Создание формата с двумя полями под названиями 'a' и 'b'.\n"
"-- Создание спейса с таким форматом.\n"
"-- Создание кортежа на основе ассоциативного массива по данному спейсу.\n"
"-- Создание таблицы на основе ассоциативного массива по данному спейсу.\n"
"tarantool> format1 = "
"{{name='a',type='unsigned'},{name='b',type='scalar'}}\n"
"---\n"
"...\n"
"tarantool> s = box.schema.create_space('test', {format = format1})\n"
"---\n"
"...\n"
"tarantool> s:frommap({b = 'x', a = 123456})\n"
"---\n"
"- [123456, 'x']\n"
"...\n"
"tarantool> s:frommap({b = 'x', a = 123456}, {table = true})\n"
"---\n"
"- - 123456\n"
"  - x\n"
"..."

#: ../doc/1.10/book/box/box_space.rst:783
msgid "Search for a tuple in the given space."
msgstr "Поиск кортежа в данном спейсе."

#: ../doc/1.10/book/box/box_space.rst:787
#: ../doc/1.10/book/box/box_space.rst:1205
msgid "value to be matched against the index key, which may be multi-part."
msgstr "значение должно совпасть с индексным ключом, который может быть составным."

#: ../doc/1.10/book/box/box_space.rst:790
msgid "the tuple whose index key matches ``key``, or ``nil``."
msgstr "кортеж, ключ индекса в котором совпадает с ``key`` или ``nil``."

#: ../doc/1.10/book/box/box_space.rst:798
msgid ""
"The ``box.space...select`` function returns a set of tuples as a Lua "
"table; the ``box.space...get`` function returns at most a single tuple. "
"And it is possible to get the first tuple in a space by appending "
"``[1]``. Therefore ``box.space.tester:get{1}`` has the same effect as "
"``box.space.tester:select{1}[1]``, if exactly one tuple is found."
msgstr ""
"Функция ``box.space...select`` вернет набор кортежей в виде Lua-таблицы; "
"функция ``box.space...get`` вернет самое большее один кортеж. Можно "
"получить первый кортеж в спейсе, добавив ``[1]``. Таким образом, "
"``box.space.tester:get{1}`` эквивалентна "
"``box.space.tester:select{1}[1]``, если найден только один кортеж."

#: ../doc/1.10/book/box/box_space.rst:806
msgid "box.space.tester:get{1}"
msgstr "box.space.tester:get{1}"

#: ../doc/1.10/book/box/box_space.rst:810
msgid ""
"**Using field names instead of field numbers:** `get()` can use field "
"names described by the optional :ref:`space_object:format() <box_space-"
"format>` clause. This is similar to a standard Lua feature, where a "
"component can be referenced by its name instead of its number. For "
"example, we can format the `tester` space with a field named `x` and use "
"the name `x` in the index definition:"
msgstr ""
"**Использование имен полей вместо номеров полей:** в `get()` можно "
"использовать имена полей, описанные в необязательном операторе "
":ref:`space_object:format() <box_space-format>`. Это аналогично "
"стандартной Lua-функции, где на компонент можно ссылаться по имени, а не "
"по номеру. Например, может форматировать спейс `tester` с полем под "
"названием `x` и использовать имя `x` в определении индекса:"

#: ../doc/1.10/book/box/box_space.rst:817
msgid ""
"box.space.tester:format({{name='x',type='scalar'}})\n"
"box.space.tester:create_index('I',{parts={'x'}})"
msgstr ""
"box.space.tester:format({{name='x',type='scalar'}})\n"
"box.space.tester:create_index('I',{parts={'x'}})"

#: ../doc/1.10/book/box/box_space.rst:822
msgid ""
"Then, if ``get`` or ``select`` retrieve a single tuple, we can reference "
"the field 'x' in the tuple by its name:"
msgstr ""
"Тогда если ``get`` или ``select`` вернут отдельный кортеж, можно "
"сослаться на поле 'x' в кортеже по имени:"

#: ../doc/1.10/book/box/box_space.rst:825
msgid ""
"box.space.tester:get{1}['x']\n"
"box.space.tester:select{1}[1]['x']"
msgstr ""
"box.space.tester:get{1}['x']\n"
"box.space.tester:select{1}[1]['x']"

#: ../doc/1.10/book/box/box_space.rst:834
msgid "Insert a tuple into a space."
msgstr "Вставка кортежа в спейс."

#: ../doc/1.10/book/box/box_space.rst:838
msgid "tuple to be inserted."
msgstr "вставляемый кортеж."

#: ../doc/1.10/book/box/box_space.rst:840
msgid "the inserted tuple"
msgstr "вставленный кортеж"

#: ../doc/1.10/book/box/box_space.rst:843
msgid ""
"**Possible errors:** :errcode:`ER_TUPLE_FOUND` if a tuple with the same "
"unique-key value already exists."
msgstr ""
"**Возможные ошибки:** ошибка :errcode:`ER_TUPLE_FOUND`, если уже "
"существует кортеж с тем же уникальным значением ключа."

#: ../doc/1.10/book/box/box_space.rst:848
msgid ""
"tarantool> box.space.tester:insert{5000,'tuple number five thousand'}\n"
"---\n"
"- [5000, 'tuple number five thousand']\n"
"..."
msgstr ""
"tarantool> box.space.tester:insert{5000,'tuple number five thousand'}\n"
"---\n"
"- [5000, 'tuple number five thousand']\n"
"..."

#: ../doc/1.10/book/box/box_space.rst:863
msgid ""
"Return the number of tuples in the space. If compared with :ref:`count() "
"<box_space-count>`, this method works faster because ``len()`` does not "
"scan the entire space to count the tuples."
msgstr ""
"Возврат количества кортежей в спейсе. Если сравнивать с :ref:`count() "
"<box_space-count>`, то данный метод работает быстрее, поскольку метод "
"``len()`` не сканирует весь спейс для подсчета кортежей."

#: ../doc/1.10/book/box/box_space.rst:871
msgid "Number of tuples in the space."
msgstr "Количество кортежей в спейсе."

#: ../doc/1.10/book/box/box_space.rst:875
msgid ""
"tarantool> box.space.tester:len()\n"
"---\n"
"- 2\n"
"..."
msgstr ""
"tarantool> box.space.tester:len()\n"
"---\n"
"- 2\n"
"..."

#: ../doc/1.10/book/box/box_space.rst:882
msgid ""
"**Note re storage engine:** vinyl supports ``len()`` but the result may "
"be approximate. If an exact result is necessary then use :ref:`count() "
"<box_space-count>` or :ref:`pairs():length() <box_space-pairs>`."
msgstr ""
"**Примечание про движок базы данных:** vinyl поддерживает ``len()``, но "
"результат может быть неточным. Если необходим точный результат, "
"используйте :ref:`count() <box_space-count>` или :ref:`pairs():length() "
"<box_space-pairs>`."

#: ../doc/1.10/book/box/box_space.rst:890
#: ../doc/1.10/book/box/box_space.rst:963
msgid ""
"Create a \"replace :ref:`trigger <triggers>`\". The ``trigger-function`` "
"will be executed whenever a ``replace()`` or ``insert()`` or ``update()``"
" or ``upsert()`` or ``delete()`` happens to a tuple in ``<space-name>``."
msgstr ""
"Создание \":ref:`триггера <triggers>` замены\". Функция с триггером "
"``trigger-function`` будет выполняться в случае операции ``replace()`` "
"или ``insert()``, или ``update()``, или ``upsert()``, или ``delete()`` "
"над кортежем в спейсе ``<space-name>``."

#: ../doc/1.10/book/box/box_space.rst:907
#: ../doc/1.10/book/box/box_space.rst:980
msgid ""
"If it is necessary to know whether the trigger activation happened due to"
" replication or on a specific connection type, the function can refer to "
":ref:`box.session.type() <box_session-type>`."
msgstr ""
"Следует знать, что если активация триггера произошла в случае репликации "
"или определенного вида подключения, функция может ссылаться на "
":ref:`box.session.type() <box_session-type>`."

#: ../doc/1.10/book/box/box_space.rst:913
msgid "See also :ref:`space_object:before_replace() <box_space-before_replace>`."
msgstr "См. также :ref:`space_object:before_replace() <box_space-before_replace>`."

#: ../doc/1.10/book/box/box_space.rst:915
#: ../doc/1.10/book/box/box_space.rst:1892
msgid "**Example #1:**"
msgstr "**Пример №1:**"

#: ../doc/1.10/book/box/box_space.rst:917
msgid ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.space.X:on_replace(f)"
msgstr ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.space.X:on_replace(f)"

#: ../doc/1.10/book/box/box_space.rst:924
msgid ""
"The ``trigger-function`` can have two parameters: old tuple, new tuple. "
"For example, the following code causes nil to be printed when the insert "
"request is processed, and causes [1, 'Hi'] to be printed when the delete "
"request is processed:"
msgstr ""
"В функции ``trigger-function`` могут быть два параметра: старый кортеж, "
"новый кортеж. Например, следующий код вызывает вывод nil при обработке "
"запроса на вставку и вывод [1, 'Hi'] при обработке запроса на удаление:"

#: ../doc/1.10/book/box/box_space.rst:929
msgid ""
"box.schema.space.create('space_1')\n"
"box.space.space_1:create_index('space_1_index',{})\n"
"function on_replace_function (old, new) print(old) end\n"
"box.space.space_1:on_replace(on_replace_function)\n"
"box.space.space_1:insert{1,'Hi'}\n"
"box.space.space_1:delete{1}"
msgstr ""
"box.schema.space.create('space_1')\n"
"box.space.space_1:create_index('space_1_index',{})\n"
"function on_replace_function (old, new) print(old) end\n"
"box.space.space_1:on_replace(on_replace_function)\n"
"box.space.space_1:insert{1,'Hi'}\n"
"box.space.space_1:delete{1}"

#: ../doc/1.10/book/box/box_space.rst:938
#: ../doc/1.10/book/box/box_space.rst:1937
msgid "**Example #2:**"
msgstr "**Примеры:**"

#: ../doc/1.10/book/box/box_space.rst:940
msgid ""
"The following series of requests will create a space, create an index, "
"create a function which increments a counter, create a trigger, do two "
"inserts, drop the space, and display the counter value - which is 2, "
"because the function is executed once after each insert."
msgstr ""
"Следующая серия запросов создаст спейс, создаст индекс, создаст функцию, "
"которая увеличит содержимое счетчика, создаст триггер, сделает две "
"вставки, удалит спейс и отобразит значение счетчика -- 2, поскольку "
"функция выполняется однократно после каждой вставки."

#: ../doc/1.10/book/box/box_space.rst:945
msgid ""
"tarantool> s = box.schema.space.create('space53')\n"
"tarantool> s:create_index('primary', {parts = {1, 'unsigned'}})\n"
"tarantool> function replace_trigger()\n"
"         >   replace_counter = replace_counter + 1\n"
"         > end\n"
"tarantool> s:on_replace(replace_trigger)\n"
"tarantool> replace_counter = 0\n"
"tarantool> t = s:insert{1, 'First replace'}\n"
"tarantool> t = s:insert{2, 'Second replace'}\n"
"tarantool> s:drop()\n"
"tarantool> replace_counter"
msgstr ""
"tarantool> s = box.schema.space.create('space53')\n"
"tarantool> s:create_index('primary', {parts = {1, 'unsigned'}})\n"
"tarantool> function replace_trigger()\n"
"         >   replace_counter = replace_counter + 1\n"
"         > end\n"
"tarantool> s:on_replace(replace_trigger)\n"
"tarantool> replace_counter = 0\n"
"tarantool> t = s:insert{1, 'First replace'}\n"
"tarantool> t = s:insert{2, 'Second replace'}\n"
"tarantool> s:drop()\n"
"tarantool> replace_counter"

#: ../doc/1.10/book/box/box_space.rst:970
msgid "existing trigger function which will be replaced by ``trigger-function``"
msgstr ""
"существующая функция с триггером, которую заменит новая ``trigger-"
"function``"

#: ../doc/1.10/book/box/box_space.rst:975
#: ../doc/1.10/book/box/box_txn_management.rst:234
msgid ""
"If the parameters are ``(nil, old-trigger-function)``, then the old "
"trigger is deleted."
msgstr ""
"Если указаны параметры ``(nil, old-trigger-function)``, старый триггер "
"будет удален."

#: ../doc/1.10/book/box/box_space.rst:987
msgid "See also :ref:`space_object:on_replace() <box_space-on_replace>`."
msgstr "См. также :ref:`space_object:on_replace() <box_space-on_replace>`."

#: ../doc/1.10/book/box/box_space.rst:989
msgid ""
"Administrators can make replace triggers with ``on_replace()``, or make "
"triggers with ``before_replace()``. If they make both types, then all "
"``before_replace`` triggers are executed before all ``on_replace`` "
"triggers. The functions for both ``on_replace`` and ``before_replace`` "
"triggers can make changes to the database, but only the functions for "
"``before_replace`` triggers can change the tuple that is being replaced."
msgstr ""
"Администраторы могут создавать триггеры замены с условием после замены "
"``on_replace()`` или до замены ``before_replace()``. Если созданы оба "
"типа, то все триггеры до замены ``before_replace`` выполняются до всех "
"триггеров после замены ``on_replace``. Функции для обоих типов триггеров "
"``on_replace`` и ``before_replace`` могут вносить изменения в базу "
"данных, но только функции с триггерами до замены ``before_replace`` могут"
" изменять кортеж, который будет заменен."

#: ../doc/1.10/book/box/box_space.rst:998
msgid ""
"Since a ``before_replace`` trigger function has the extra capability of "
"making a change to the old tuple, it also can have extra overhead, to "
"fetch the old tuple before making the change. Therefore an ``on_replace``"
" trigger is better if there is no need to change the old tuple. However, "
"this only applies for the memtx engine -- for the vinyl engine, the fetch"
" will happen for either kind of trigger. (With memtx the tuple data is "
"stored along with the index key so no extra search is necessary; with "
"vinyl that is not the case so the extra search is necessary.)"
msgstr ""
"Поскольку функция с триггером до замены ``before_replace`` может вносить "
"дополнительные изменения в старый кортеж, для нее также потребуются "
"дополнительные ресурсы для вызова старого кортежа до внесения изменений. "
"Таким образом, лучше использовать триггер после замены ``on_replace``, "
"если нет необходимости изменять старый кортеж. Тем не менее, это "
"применимо только к движку memtx -- что касается движка vinyl, такой вызов"
" произойдет для любого типа триггера. (В memtx'е данные кортежа хранятся "
"вместе с ключом индекса, поэтому нет необходимости в дополнительном "
"поиске; для vinyl'а дело обстоит иначе, поэтому нужен дополнительный "
"поиск.)"

#: ../doc/1.10/book/box/box_space.rst:1010
msgid ""
"Where the extra capability is not needed, ``on_replace`` should be used "
"instead of ``before_replace``. Usually ``before_replace`` is used only "
"for certain replication scenarios -- it is useful for conflict "
"resolution."
msgstr ""
"Если нет необходимости в дополнительных изменениях, следует использовать "
"``on_replace`` вместо ``before_replace``. Как правило, ``before_replace``"
" используется только для определенных сценариев репликации -- в части "
"разрешения конфликтов."

#: ../doc/1.10/book/box/box_space.rst:1015
msgid ""
"The value that a ``before_replace`` trigger function can return affects "
"what will happen after the return. Specifically:"
msgstr ""
"Что случится после возврата значения, которое может вернуть функция с "
"триггером ``before_replace``, зависит от этого значения. А именно:"

#: ../doc/1.10/book/box/box_space.rst:1018
msgid ""
"if there is no return value, then execution proceeds, inserting|replacing"
" the new value;"
msgstr ""
"если нет возвращаемого значения, выполнение продолжается со "
"вставкой|заменой нового значения;"

#: ../doc/1.10/book/box/box_space.rst:1020
msgid "if the value is nil, then the tuple will be deleted;"
msgstr "если значение -- nil, то кортеж будет удален;"

#: ../doc/1.10/book/box/box_space.rst:1021
msgid ""
"if the value is the same as the old parameter, then no `on_replace`` "
"function will be called and the data change will be skipped"
msgstr ""
"если значение совпадает со старым, то вызывается функция ``on_replace``, "
"и изменение данных не происходит"

#: ../doc/1.10/book/box/box_space.rst:1024
msgid ""
"if the value is the same as the new parameter, then it's as if the "
"``before_replace`` function wasn't called;"
msgstr ""
"если значение совпадает с новым, то считаем, что вызова функции "
"``before_replace`` не было;"

#: ../doc/1.10/book/box/box_space.rst:1026
msgid ""
"if the value is something else, then execution proceeds, "
"inserting|replacing the new value."
msgstr ""
"если значение другое, выполнение продолжается со вставкой|заменой нового "
"значения."

#: ../doc/1.10/book/box/box_space.rst:1029
msgid ""
"However, if a trigger function returns an old tuple, or if a trigger "
"function calls :ref:`run_triggers(false) <box_space-run_triggers>`, that "
"will not affect other triggers that are activated for the same "
"insert|update|replace request."
msgstr ""
"Тем не менее, если функция с триггером возвращает старый кортеж или "
"вызывает :ref:`run_triggers(false) <box_space-run_triggers>`, это не "
"повлияет на другие триггеры, активируемые в том же запросе вставки, "
"обновления или замены."

#: ../doc/1.10/book/box/box_space.rst:1036
msgid ""
"The following are ``before_replace`` functions that have no return value,"
" or that return nil, or the same as the old parameter, or the same as the"
" new parameter, or something else."
msgstr ""
"Далее представлены функции ``before_replace``: не возвращает значение, "
"возвращает nil, возвращает совпадающее со старым значение, возвращает "
"совпадающее с новым значение, возвращает другое значение."

#: ../doc/1.10/book/box/box_space.rst:1040
msgid ""
"function f1 (old, new) return end\n"
"function f2 (old, new) return nil end\n"
"function f3 (old, new) return old end\n"
"function f4 (old, new) return new end\n"
"function f5 (old, new) return box.tuple.new({new[1],'b'}) end"
msgstr ""
"function f1 (old, new) return end\n"
"function f2 (old, new) return nil end\n"
"function f3 (old, new) return old end\n"
"function f4 (old, new) return new end\n"
"function f5 (old, new) return box.tuple.new({new[1],'b'}) end"

#: ../doc/1.10/book/box/box_space.rst:1052
msgid ""
"Search for a tuple or a set of tuples in the given space, and allow "
"iterating over one tuple at a time."
msgstr ""
"Поиск кортежа или набора кортежей в заданном спейсе и итерация по одному "
"кортежу за раз."

#: ../doc/1.10/book/box/box_space.rst:1059
msgid "see :ref:`index_object:pairs <box_index-index_pairs>`"
msgstr "см. :ref:`index_object:pairs <box_index-index_pairs>`"

#: ../doc/1.10/book/box/box_space.rst:1068
#: ../doc/1.10/book/box/box_space.rst:1227
msgid "no such space;"
msgstr "отсутствие такого спейса."

#: ../doc/1.10/book/box/box_space.rst:1069
#: ../doc/1.10/book/box/box_space.rst:1228
msgid "wrong type."
msgstr "неправильный тип."

#: ../doc/1.10/book/box/box_space.rst:1073
msgid ""
"For examples of complex ``pairs`` requests, where one can specify which "
"index to search and what condition to use (for example \"greater than\" "
"instead of \"equal to\"), see the later section :ref:`index_object:pairs "
"<box_index-index_pairs>`."
msgstr ""
"Чтобы посмотреть примеры сложных запросов ``pairs``, где можно указать "
"индекс для поиска и используемое условие (например, \"больше чем\" вместо"
" \"равен\"), см. раздел далее по тексту :ref:`index_object:pairs "
"<box_index-index_pairs>`."

#: ../doc/1.10/book/box/box_space.rst:1084
msgid ""
"tarantool> s = box.schema.space.create('space33')\n"
"---\n"
"...\n"
"tarantool> -- index 'X' has default parts {1, 'unsigned'}\n"
"tarantool> s:create_index('X', {})\n"
"---\n"
"...\n"
"tarantool> s:insert{0, 'Hello my '}, s:insert{1, 'Lua world'}\n"
"---\n"
"- [0, 'Hello my ']\n"
"- [1, 'Lua world']\n"
"...\n"
"tarantool> tmp = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in s:pairs() do\n"
"         >   tmp = tmp .. v[2]\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> tmp\n"
"---\n"
"- Hello my Lua world\n"
"..."
msgstr ""
"tarantool> s = box.schema.space.create('space33')\n"
"---\n"
"...\n"
"tarantool> -- в индексе 'X' количество частей по умолчанию {1, "
"'unsigned'}\n"
"tarantool> s:create_index('X', {})\n"
"---\n"
"...\n"
"tarantool> s:insert{0, 'Hello my '}, s:insert{1, 'Lua world'}\n"
"---\n"
"- [0, 'Hello my ']\n"
"- [1, 'Lua world']\n"
"...\n"
"tarantool> tmp = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in s:pairs() do\n"
"         >   tmp = tmp .. v[2]\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> tmp\n"
"---\n"
"- Hello my Lua world\n"
"..."

#: ../doc/1.10/book/box/box_space.rst:1115
msgid "Rename a space."
msgstr "Переименование спейса."

#: ../doc/1.10/book/box/box_space.rst:1119
msgid "new name for space"
msgstr "новое имя спейса"

#: ../doc/1.10/book/box/box_space.rst:1127
msgid ""
"tarantool> box.space.space55:rename('space56')\n"
"---\n"
"...\n"
"tarantool> box.space.space56:rename('space55')\n"
"---\n"
"..."
msgstr ""
"tarantool> box.space.space55:rename('space56')\n"
"---\n"
"...\n"
"tarantool> box.space.space56:rename('space55')\n"
"---\n"
"..."

#: ../doc/1.10/book/box/box_space.rst:1141
msgid ""
"Insert a tuple into a space. If a tuple with the same primary key already"
" exists, ``box.space...:replace()`` replaces the existing tuple with a "
"new one. The syntax variants ``box.space...:replace()`` and "
"``box.space...:put()`` have the same effect; the latter is sometimes used"
" to show that the effect is the converse of ``box.space...:get()``."
msgstr ""
"Вставка кортежа в спейс. Если уже существует кортеж с тем же первичным "
"ключом, ``box.space...:replace()`` заменит существующий кортеж новым. "
"Варианты синтаксиса (``box.space...:replace()`` и ``box.space...:put()``)"
" приведут к одному результату, но последний иногда используется как "
"противоположность ``box.space...:get()``."

#: ../doc/1.10/book/box/box_space.rst:1149
msgid "tuple to be inserted"
msgstr "вставляемый кортеж"

#: ../doc/1.10/book/box/box_space.rst:1154
msgid ""
"**Possible errors:** :errcode:`ER_TUPLE_FOUND` if a different tuple with "
"the same unique-key value already exists. (This will only happen if there"
" is a unique secondary index.)"
msgstr ""
"**Возможные ошибки:** ошибка :errcode:`ER_TUPLE_FOUND`, если уже "
"существует другой кортеж с тем же уникальным значением ключа (это "
"произойдет только в том случае, если есть уникальный вторичный индекс)."

#: ../doc/1.10/book/box/box_space.rst:1163
msgid "box.space.tester:replace{5000, 'tuple number five thousand'}"
msgstr "box.space.tester:replace{5000, 'tuple number five thousand'}"

#: ../doc/1.10/book/box/box_space.rst:1175
msgid ""
"At the time that a :ref:`trigger <triggers>` is defined, it is "
"automatically enabled - that is, it will be executed. :ref:`Replace "
"<box_space-on_replace>` triggers can be disabled with :samp:`box.space"
".{space-name}:run_triggers(false)` and re-enabled with :samp:`box.space"
".{space-name}:run_triggers(true)`."
msgstr ""
"На тот момент, когда :ref:`триггер <triggers>` определен, он "
"автоматически активируется, то есть он будет исполняться. Триггеры "
":ref:`для замены <box_space-on_replace>` можно отключить с помощью "
":samp:`box.space.{имя-спейса}:run_triggers(false)` и повторно "
"активировать с помощью :samp:`box.space.{имя-спейса}:run_triggers(true)`."

#: ../doc/1.10/book/box/box_space.rst:1184
msgid ""
"The following series of requests will associate an existing function "
"named `F` with an existing space named `T`, associate the function a "
"second time with the same space (so it will be called twice), disable all"
" triggers of `T`, and delete each trigger by replacing with ``nil``."
msgstr ""
"Следующая серия запросов ассоциирует существующую функцию с именем `F` с "
"существующим спейсом с именем `T`, ассоциирует функцию во второй раз с "
"тем же спейсом (чтобы вызвать ее дважды), отключит все триггеры на `T` и "
"удалит каждый триггер, заменив его на ``nil``."

#: ../doc/1.10/book/box/box_space.rst:1189
msgid ""
"tarantool> box.space.T:on_replace(F)\n"
"tarantool> box.space.T:on_replace(F)\n"
"tarantool> box.space.T:run_triggers(false)\n"
"tarantool> box.space.T:on_replace(nil, F)\n"
"tarantool> box.space.T:on_replace(nil, F)"
msgstr ""
"tarantool> box.space.T:on_replace(F)\n"
"tarantool> box.space.T:on_replace(F)\n"
"tarantool> box.space.T:run_triggers(false)\n"
"tarantool> box.space.T:on_replace(nil, F)\n"
"tarantool> box.space.T:on_replace(nil, F)"

#: ../doc/1.10/book/box/box_space.rst:1201
msgid "Search for a tuple or a set of tuples in the given space."
msgstr "Поиск кортежа или набора кортежей в заданном спейсе."

#: ../doc/1.10/book/box/box_space.rst:1207
msgid ""
"none, any or all of the same options that :ref:`index_object:select "
"<box_index-select>` allows:  * ``options.iterator`` (:ref:`type of "
"iterator <box_index-iterator-types>`) * ``options.limit`` (maximum number"
" of tuples) * ``options.offset`` (number of tuples to skip)"
msgstr ""
"ни один, любой или все параметры, которые допускает "
":ref:`index_object:select <box_index-select>`:  * ``options.iterator`` "
"(:ref:`тип итератора <box_index-iterator-types>`) * ``options.limit`` "
"(максимальное количество кортежей) * ``options.offset`` (количество "
"пропускаемых кортежей)"

#: ../doc/1.10/book/box/box_space.rst:1207
msgid ""
"none, any or all of the same options that :ref:`index_object:select "
"<box_index-select>` allows:"
msgstr ""
"ни один, любой или все параметры, которые допускает "
":ref:`index_object:select <box_index-select>`:"

#: ../doc/1.10/book/box/box_space.rst:1211
msgid "``options.iterator`` (:ref:`type of iterator <box_index-iterator-types>`)"
msgstr "``options.iterator`` (:ref:`тип итератора <box_index-iterator-types>`)"

#: ../doc/1.10/book/box/box_space.rst:1212
msgid "``options.limit`` (maximum number of tuples)"
msgstr "``options.limit`` (максимальное количество кортежей)"

#: ../doc/1.10/book/box/box_space.rst:1213
msgid "``options.offset`` (number of tuples to skip)"
msgstr "``options.offset`` (количество пропускаемых кортежей)"

#: ../doc/1.10/book/box/box_space.rst:1215
msgid ""
"the tuples whose primary-key fields are equal to the fields of the passed"
" key. If the number of passed fields is less than the number of fields in"
" the primary key, then only the passed fields are compared, so "
"``select{1,2}`` will match a tuple whose primary key is ``{1,2,3}``."
msgstr ""
"кортежи, поля первичного ключа в которых равны полям переданного ключа. "
"Если количество переданных полей меньшей количества полей первичного "
"ключа, сопоставляются только переданные поля, то есть для ``select{1,2}``"
" совпадением будет кортеж с первичным ключом ``{1,2,3}``."

#: ../doc/1.10/book/box/box_space.rst:1222
msgid ""
"A ``select`` request can also be done with a specific index and index "
"options, which are the subject of :ref:`index_object:select <box_index-"
"select>`."
msgstr ""
"Запрос выборки ``select`` также можно выполнить со специальными "
"параметрами индекса, которые указаны в :ref:`index_object:select "
"<box_index-select>`."

#: ../doc/1.10/book/box/box_space.rst:1234
msgid ""
"tarantool> s = box.schema.space.create('tmp', {temporary=true})\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary',{parts = {1,'unsigned', 2, "
"'string'}})\n"
"---\n"
"...\n"
"tarantool> s:insert{1,'A'}\n"
"---\n"
"- [1, 'A']\n"
"...\n"
"tarantool> s:insert{1,'B'}\n"
"---\n"
"- [1, 'B']\n"
"...\n"
"tarantool> s:insert{1,'C'}\n"
"---\n"
"- [1, 'C']\n"
"...\n"
"tarantool> s:insert{2,'D'}\n"
"---\n"
"- [2, 'D']\n"
"...\n"
"tarantool> -- must equal both primary-key fields\n"
"tarantool> s:select{1,'B'}\n"
"---\n"
"- - [1, 'B']\n"
"...\n"
"tarantool> -- must equal only one primary-key field\n"
"tarantool> s:select{1}\n"
"---\n"
"- - [1, 'A']\n"
"  - [1, 'B']\n"
"  - [1, 'C']\n"
"...\n"
"tarantool> -- must equal 0 fields, so returns all tuples\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 'A']\n"
"  - [1, 'B']\n"
"  - [1, 'C']\n"
"  - [2, 'D']\n"
"...\n"
"tarantool> -- the first field must be greater than 0, and\n"
"tarantool> -- skip the first tuple, and return up to\n"
"tarantool> -- 2 tuples. This example's options all\n"
"tarantool> -- depend on index characteristics so see\n"
"tarantool> -- more explanation in index_object:select().\n"
"tarantool> s:select({0},{iterator='GT',offset=1,limit=2})\n"
"---\n"
"- - [1, 'B']\n"
"  - [1, 'C']\n"
"..."
msgstr ""
"tarantool> s = box.schema.space.create('tmp', {temporary=true})\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary',{parts = {1,'unsigned', 2, "
"'string'}})\n"
"---\n"
"...\n"
"tarantool> s:insert{1,'A'}\n"
"---\n"
"- [1, 'A']\n"
"...\n"
"tarantool> s:insert{1,'B'}\n"
"---\n"
"- [1, 'B']\n"
"...\n"
"tarantool> s:insert{1,'C'}\n"
"---\n"
"- [1, 'C']\n"
"...\n"
"tarantool> s:insert{2,'D'}\n"
"---\n"
"- [2, 'D']\n"
"...\n"
"tarantool> -- необходимо совпадение с двумя полями первичного ключа\n"
"tarantool> s:select{1,'B'}\n"
"---\n"
"- - [1, 'B']\n"
"...\n"
"tarantool> -- необходимо совпадение только одного поля первичного ключа\n"
"tarantool> s:select{1}\n"
"---\n"
"- - [1, 'A']\n"
"  - [1, 'B']\n"
"  - [1, 'C']\n"
"...\n"
"tarantool> -- необходимо совпадение с 0 полей, поэтому возвращает все "
"кортежи\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 'A']\n"
"  - [1, 'B']\n"
"  - [1, 'C']\n"
"  - [2, 'D']\n"
"...\n"
"tarantool> -- первое поле должно быть больше 0,\n"
"tarantool> -- пропуск первого кортежа и возврат до\n"
"tarantool> -- 2 кортежей. Все параметры в данном примере\n"
"tarantool> -- зависят от характеристик индекса, поэтому см.\n"
"tarantool> -- более подробное описание в index_object:select().\n"
"tarantool> s:select({0},{iterator='GT',offset=1,limit=2})\n"
"---\n"
"- - [1, 'B']\n"
"  - [1, 'C']\n"
"..."

#: ../doc/1.10/book/box/box_space.rst:1289
msgid ""
"As the last request in the above example shows: to make complex "
"``select`` requests, where you can specify which index to search and what"
" condition to use (for example \"greater than\" instead of \"equal to\") "
"and how many tuples to return, it will be necessary to become familiar "
"with :ref:`index_object:select <box_index-select>`."
msgstr ""
"Как показано в последнем запросе вышеприведенного примера, чтобы "
"выполнять сложные запросы выборки ``select``, где можно указать, в каком "
"индексе производится поиск и с какими условиями (например, \"больше, "
"чем\" вместо \"равный\"), а также необходимое количество возвращаемых "
"кортежей, необходимо ознакомиться с :ref:`index_object:select <box_index-"
"select>`."

#: ../doc/1.10/book/box/box_space.rst:1303
msgid "Deletes all tuples."
msgstr "Удаление всех кортежей."

#: ../doc/1.10/book/box/box_space.rst:1312
msgid ""
"The ``truncate`` method can only be called by the user who created the "
"space, or from within a ``setuid`` function created by the user who "
"created the space. Read more about `setuid` functions in the reference "
"for :ref:`box.schema.func.create() <box_schema-func_create>`."
msgstr ""
"Метод ``truncate`` может вызвать только тот пользователь, который создал "
"спейс, или другой пользователь через функцию ``setuid``, созданную "
"пользователем, который создал спейс. Более подробную информацию о "
"функциях `setuid` можно получить в справочнике по for "
":ref:`box.schema.func.create() <box_schema-func_create>`."

#: ../doc/1.10/book/box/box_space.rst:1318
msgid "The ``truncate`` method cannot be called from within a transaction."
msgstr "Метод ``truncate`` нельзя вызвать из транзакции."

#: ../doc/1.10/book/box/box_space.rst:1322
msgid ""
"tarantool> box.space.tester:truncate()\n"
"---\n"
"...\n"
"tarantool> box.space.tester:len()\n"
"---\n"
"- 0\n"
"..."
msgstr ""
"tarantool> box.space.tester:truncate()\n"
"---\n"
"...\n"
"tarantool> box.space.tester:len()\n"
"---\n"
"- 0\n"
"..."

#: ../doc/1.10/book/box/box_space.rst:1338
msgid ""
"The ``update`` function supports operations on fields — assignment, "
"arithmetic (if the field is numeric), cutting and pasting fragments of a "
"field, deleting or inserting a field. Multiple operations can be combined"
" in a single update request, and in this case they are performed "
"atomically and sequentially. Each operation requires specification of a "
"field number. When multiple operations are present, the field number for "
"each operation is assumed to be relative to the most recent state of the "
"tuple, that is, as if all previous operations in a multi-operation update"
" have already been applied. In other words, it is always safe to merge "
"multiple ``update`` invocations into a single invocation, with no change "
"in semantics."
msgstr ""
"Функция ``update`` поддерживает операции над полями -- присваивание, "
"арифметические операции (если поле числовое), вырезание и вставку "
"фрагментов поля, удаление или вставку поля. Несколько операций можно "
"объединить в отдельный запрос обновления, и в таком случае они будут "
"выполняться атомарно и последовательно. Для каждой операции необходимо "
"указать номер поля. Если выполняются несколько операций, то номер поля "
"для каждой операции считается относительно последнего состояния кортежа, "
"то есть как если бы все предыдущие операции в обновлении с несколькими "
"операциями уже были выполнены. Другими словами, всегда лучше объединить "
"несколько вызовов  ``update`` в один без изменений семантики."

#: ../doc/1.10/book/box/box_space.rst:1350
msgid "Possible operators are:"
msgstr "Возможные операторы:"

#: ../doc/1.10/book/box/box_space.rst:1352
msgid "``+`` for addition (values must be numeric)"
msgstr "``+`` для сложения (значения должны быть числовыми)"

#: ../doc/1.10/book/box/box_space.rst:1353
msgid "``-`` for subtraction (values must be numeric)"
msgstr "``-`` для вычитания (значения должны быть числовыми)"

#: ../doc/1.10/book/box/box_space.rst:1354
msgid "``&`` for bitwise AND (values must be unsigned numeric)"
msgstr ""
"``&`` для поразрядной операции И (значения должны быть беззнаковыми "
"числами)"

#: ../doc/1.10/book/box/box_space.rst:1355
msgid "``|`` for bitwise OR (values must be unsigned numeric)"
msgstr ""
"``|`` для поразрядной операции ИЛИ (значения должны быть беззнаковыми "
"числами)"

#: ../doc/1.10/book/box/box_space.rst:1356
msgid ""
"``^`` for bitwise :abbr:`XOR(exclusive OR)` (values must be unsigned "
"numeric)"
msgstr ""
"``^`` для поразрядной операции Исключающее ИЛИ (значения должны быть "
"беззнаковыми числами)"

#: ../doc/1.10/book/box/box_space.rst:1358
msgid "``:`` for string splice"
msgstr "``:`` для разделения строк"

#: ../doc/1.10/book/box/box_space.rst:1359
msgid "``!`` for insertion"
msgstr "``!`` для вставки"

#: ../doc/1.10/book/box/box_space.rst:1360
msgid "``#`` for deletion"
msgstr "``#`` для удаления"

#: ../doc/1.10/book/box/box_space.rst:1361
msgid "``=`` for assignment"
msgstr "``=`` для присваивания"

#: ../doc/1.10/book/box/box_space.rst:1363
msgid ""
"For ``!`` and ``=`` operations the field number can be ``-1``, meaning "
"the last field in the tuple."
msgstr ""
"Для операций ``!`` и ``=`` номер поля может быть ``-1``, что означает "
"последнее поле в кортеже."

#: ../doc/1.10/book/box/box_space.rst:1380
msgid "**Possible errors:** it is illegal to modify a primary-key field."
msgstr "**Возможные ошибки:** нельзя изменять поле первичного ключа."

#: ../doc/1.10/book/box/box_space.rst:1382
#: ../doc/1.10/book/box/box_space.rst:1506
msgid ""
"**Complexity factors:** Index size, Index type, number of indexes "
"accessed, WAL settings."
msgstr ""
"**Факторы сложности** Размер индекса, тип индекса, количество кортежей, к"
" которым получен доступ, настройки журнала упреждающей записи (WAL)."

#: ../doc/1.10/book/box/box_space.rst:1385
msgid "Thus, in the instruction:"
msgstr "Таким образом, в инструкции:"

#: ../doc/1.10/book/box/box_space.rst:1387
msgid "s:update(44, {{'+', 1, 55 }, {'=', 3, 'x'}})"
msgstr "s:update(44, {{'+', 1, 55 }, {'=', 3, 'x'}})"

#: ../doc/1.10/book/box/box_space.rst:1391
msgid ""
"the primary-key value is ``44``, the operators are ``'+'`` and ``'='`` "
"meaning *add a value to a field and then assign a value to a field*, the "
"first affected field is field ``1`` and the value which will be added to "
"it is ``55``, the second affected field is field ``3`` and the value "
"which will be assigned to it is ``'x'``."
msgstr ""
"значение первичного ключа равно ``44``, заданы операторы ``'+'`` и "
"``'='``, что означает *прибавление значение к полю, а затем присваивание "
"значения полю*, первое затронутое поле -- это поле ``1``, к нему "
"прибавляется значение ``55``, второе затронутое поле -- это поле ``3``, "
"ему присваивается значение ``'x'``."

#: ../doc/1.10/book/box/box_space.rst:1399
msgid ""
"Assume that initially there is a space named ``tester`` with a primary-"
"key index whose type is ``unsigned``. There is one tuple, with "
"``field[1]`` = ``999`` and ``field[2]`` = ``'A'``."
msgstr ""
"Предположим, что изначально есть спейс под названием ``tester`` с "
"первичным индексом, тип которого -- ``unsigned``. Есть один кортеж с "
"полем №1 ``field[1]`` = ``999`` и полем №2 ``field[2]`` = ``'A'``."

#: ../doc/1.10/book/box/box_space.rst:1403
msgid ""
"In the update: |br| ``box.space.tester:update(999, {{'=', 2, 'B'}})`` "
"|br| The first argument is ``tester``, that is, the affected space is "
"``tester``. The second argument is ``999``, that is, the affected tuple "
"is identified by primary key value = 999. The third argument is ``=``, "
"that is, there is one operation — *assignment to a field*. The fourth "
"argument is ``2``, that is, the affected field is ``field[2]``. The fifth"
" argument is ``'B'``, that is, ``field[2]`` contents change to ``'B'``. "
"Therefore, after this update, ``field[1]`` = ``999`` and ``field[2]`` = "
"``'B'``."
msgstr ""
"В обновлении: |br| ``box.space.tester:update(999, {{'=', 2, 'B'}})`` |br|"
" Первый аргумент -- это ``tester``, то есть обновление происходит в "
"спейсе ``tester``. Второй аргумент -- ``999``, то есть затронутый кортеж "
"определяется по значению первичного ключа = 999. Третий аргумент -- "
"``=``, то есть будет одна операция -- *присваивание полю*. Четвертый "
"аргумент -- ``2``, то есть будет затронуто поле №2 ``field[2]``. Пятый "
"аргумент -- ``'B'``, то есть содержимое ``field[2]`` изменится на "
"``'B'``. Таким образом, после данного обновления ``field[1]`` = ``999``, "
"а ``field[2]`` = ``'B'``."

#: ../doc/1.10/book/box/box_space.rst:1414
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'=', 2, 'B'}})`` "
"|br| the arguments are the same, except that the key is passed as a Lua "
"table (inside braces). This is unnecessary when the primary key has only "
"one field, but would be necessary if the primary key had more than one "
"field. Therefore, after this update, ``field[1]`` = ``999`` and "
"``field[2]`` = ``'B'`` (no change)."
msgstr ""
"В обновлении: |br| ``box.space.tester:update({999}, {{'=', 2, 'B'}})`` "
"|br| Аргументы повторяются за исключением того, что ключ передается в "
"виде Lua-таблицы (в фигурных скобках). В этом нет необходимости, если "
"первичный ключ содержит только одно поле, но было бы необходимо, если бы "
"в первичном ключе было больше одного поля. Таким образом, после данного "
"обновления ``field[1]`` = ``999``, а ``field[2]`` = ``'B'`` (без "
"изменений)."

#: ../doc/1.10/book/box/box_space.rst:1421
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'=', 3, 1}})`` "
"|br| the arguments are the same, except that the fourth argument is "
"``3``, that is, the affected field is ``field[3]``. It is okay that, "
"until now, ``field[3]`` has not existed. It gets added. Therefore, after "
"this update, ``field[1]`` = ``999``, ``field[2]`` = ``'B'``, ``field[3]``"
" = ``1``."
msgstr ""
"В обновлении: |br| ``box.space.tester:update({999}, {{'=', 3, 1}})`` |br|"
" Аргументы повторяются за исключением того, что четвертым аргументом "
"будет ``3``, то есть будет затронуто поле №3 ``field[3]``. Ничего "
"страшного, что до этого поле ``field[3]`` не существовало. Оно добавится."
" Таким образом, после данного обновления ``field[1]`` = ``999``, "
"``field[2]`` = ``'B'``, ``field[3]`` = ``1``."

#: ../doc/1.10/book/box/box_space.rst:1428
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'+', 3, 1}})`` "
"|br| the arguments are the same, except that the third argument is "
"``'+'``, that is, the operation is addition rather than assignment. Since"
" ``field[3]`` previously contained ``1``, this means we're adding ``1`` "
"to ``1``. Therefore, after this update, ``field[1]`` = ``999``, "
"``field[2]`` = ``'B'``, ``field[3]`` = ``2``."
msgstr ""
"В обновлении: |br| ``box.space.tester:update({999}, {{'+', 3, 1}})`` |br|"
" Аргументы повторяются за исключением того, что третьим аргументом будет "
"``'+'``, то есть будет операция добавления, а не присваивания. "
"Поскольку``field[3]`` ранее содержало значение ``1``, это означает, что к"
" ``1`` прибавится ``1``. Таким образом, после данного обновления "
"``field[1]`` = ``999``, ``field[2]`` = ``'B'``, ``field[3]`` = ``2``."

#: ../doc/1.10/book/box/box_space.rst:1436
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'|', 3, 1}, {'=', "
"2, 'C'}})`` |br| the idea is to modify two fields at once. The formats "
"are ``'|'`` and ``=``, that is, there are two operations, OR and "
"assignment. The fourth and fifth arguments mean that ``field[3]`` gets "
"OR'ed with ``1``. The seventh and eighth arguments mean that ``field[2]``"
" gets assigned ``'C'``. Therefore, after this update, ``field[1]`` = "
"``999``, ``field[2]`` = ``'C'``, ``field[3]`` = ``3``."
msgstr ""
"В обновлении: |br| ``box.space.tester:update({999}, {{'|', 3, 1}, {'=', "
"2, 'C'}})`` |br| Основная идея состоит в том, чтобы изменить одновременно"
" два поля. Форматами будут ``'|'`` и ``=``, то есть имеем две операции: "
"ИЛИ и присваивание. Четвертый и пятый аргументы означают, что над полем "
"``field[3]`` проводится операция ИЛИ со значением ``1``. Седьмой и "
"восьмой аргументы означают, что полю ``field[2]`` присваивается ``'C'``. "
"Таким образом, после данного обновления ``field[1]`` = ``999``, "
"``field[2]`` = ``'C'``, ``field[3]`` = ``3``."

#: ../doc/1.10/book/box/box_space.rst:1445
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'#', 2, 1}, {'-', "
"2, 3}})`` |br| The idea is to delete ``field[2]``, then subtract ``3`` "
"from ``field[3]``. But after the delete, there is a renumbering, so "
"``field[3]`` becomes ``field[2]`` before we subtract ``3`` from it, and "
"that's why the seventh argument is ``2``, not ``3``. Therefore, after "
"this update, ``field[1]`` = ``999``, ``field[2]`` = ``0``."
msgstr ""
"В обновлении: |br| ``box.space.tester:update({999}, {{'#', 2, 1}, {'-', "
"2, 3}})`` |br| Основная идея состоит в том, чтобы удалить поле "
"``field[2]``, а затем вычесть ``3`` из ``field[3]``. Но после удаления, "
"произойдет перенумерация, поэтому поле ``field[3]`` становится "
"``field[2]`` до того, как мы вычтем из него ``3``, вот почему седьмым "
"аргументом будет ``2``, а не ``3``. Таким образом, после данного "
"обновления ``field[1]`` = ``999``, ``field[2]`` = ``0``."

#: ../doc/1.10/book/box/box_space.rst:1453
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'=', 2, 'XYZ'}})``"
" |br| we're making a long string so that splice will work in the next "
"example. Therefore, after this update, ``field[1]`` = ``999``, "
"``field[2]`` = ``'XYZ'``."
msgstr ""
"В обновлении: |br| ``box.space.tester:update({999}, {{'=', 2, 'XYZ'}})`` "
"|br| Создаем длинную строку, чтобы в следующем примере сработало "
"разделение. Таким образом, после данного обновления ``field[1]`` = "
"``999``, ``field[2]`` = ``'XYZ'``."

#: ../doc/1.10/book/box/box_space.rst:1458
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{':', 2, 2, 1, "
"'!!'}})`` |br| The third argument is ``':'``, that is, this is the "
"example of splice. The fourth argument is ``2`` because the change will "
"occur in ``field[2]``. The fifth argument is 2 because deletion will "
"begin with the second byte. The sixth argument is 1 because the number of"
" bytes to delete is 1. The seventh argument is ``'!!'``, because ``'!!'``"
" is to be added at this position. Therefore, after this update, "
"``field[1]`` = ``999``, ``field[2]`` = ``'X!!Z'``."
msgstr ""
"В обновлении: |br| ``box.space.tester:update({999}, {{':', 2, 2, 1, "
"'!!'}})`` |br| Третьим аргументом будет ``':'``, то есть это пример "
"разделения. Четвертым аргументом будет ``2``, поскольку изменение "
"произойдет в поле ``field[2]``. Пятым аргументом будет 2, поскольку "
"удаление начнется со второго байта. Шестым аргументом будет 1, количество"
" удаляемых байтов -- 1. Седьмым аргументом будет ``'!!'``, поскольку в "
"данном положении будет добавляться ``'!!'``. Таким образом, после данного"
" обновления ``field[1]`` = ``999``, ``field[2]`` = ``'X!!Z'``."

#: ../doc/1.10/book/box/box_space.rst:1475
msgid "Update or insert a tuple."
msgstr "Обновление или вставка кортежа."

#: ../doc/1.10/book/box/box_space.rst:1477
msgid ""
"If there is an existing tuple which matches the key fields of "
"``tuple_value``, then the request has the same effect as "
":ref:`space_object:update() <box_space-update>` and the ``{{operator, "
"field_no, value}, ...}`` parameter is used. If there is no existing tuple"
" which matches the key fields of ``tuple_value``, then the request has "
"the same effect as :ref:`space_object:insert() <box_space-insert>` and "
"the ``{tuple_value}`` parameter is used. However, unlike ``insert`` or "
"``update``, ``upsert`` will not read a tuple and perform error checks "
"before returning -- this is a design feature which enhances throughput "
"but requires more caution on the part of the user."
msgstr ""
"Если существует кортеж, который совпадает с полями ключа ``tuple_value``,"
" запрос приведет к тому же результату, что и :ref:`space_object:update() "
"<box_space-update>`, и используется параметр ``{{operator, field_no, "
"value}, ...}``. Если нет кортежа, который совпадает с полями ключа "
"``tuple_value``, запрос приведет к тому же результату, что и  "
":ref:`space_object:insert() <box_space-insert>`, и используется параметр "
"``{tuple_value}``. Однако, в отличие от ``insert`` или ``update``, "
"``upsert`` не считывает кортеж и не проверяет на ошибки перед возвратом "
"-- это конструктивная особенность, которая увеличивает быстродействие, но"
" требует большей осторожности со стороны пользователя."

#: ../doc/1.10/book/box/box_space.rst:1489
msgid "default tuple to be inserted, if analogue isn't found"
msgstr "вставляемый по умолчанию кортеж, если не найдет аналог"

#: ../doc/1.10/book/box/box_space.rst:1498
#: ../doc/1.10/reference/reference_lua/fio.rst:687
msgid "null"
msgstr "null"

#: ../doc/1.10/book/box/box_space.rst:1502
msgid "It is illegal to modify a primary-key field."
msgstr "Нельзя изменять поле первичного ключа."

#: ../doc/1.10/book/box/box_space.rst:1503
msgid ""
"It is illegal to use upsert with a space that has a unique secondary "
"index."
msgstr ""
"Нельзя проводить операцию upsert в спейсе, в котором есть уникальный "
"вторичный индекс."

#: ../doc/1.10/book/box/box_space.rst:1511
msgid "box.space.tester:upsert({12,'c'}, {{'=', 3, 'a'}, {'=', 4, 'b'}})"
msgstr "box.space.tester:upsert({12,'c'}, {{'=', 3, 'a'}, {'=', 4, 'b'}})"

#: ../doc/1.10/book/box/box_space.rst:1523
msgid ""
"Users can define any functions they want, and associate them with spaces:"
" in effect they can make their own space methods. They do this by:"
msgstr ""
"Пользователи могут сами определять любые желаемые функции и связывать их "
"со спейсами: фактически они могут создавать собственные методы для работы"
" со спейсом. Это можно сделать так:"

#: ../doc/1.10/book/box/box_space.rst:1530
msgid ""
"invoking the function any time thereafter, as long as the server is up, "
"by saying ``space_object:function-name([parameters])``."
msgstr ""
"впоследствии в любое время, пока работает сервер, вызвать функцию с "
"помощью ``объект_спейса:имя-функции([параметры])``."

#: ../doc/1.10/book/box/box_space.rst:1533
msgid ""
"The predefined global variable is ``box.schema.space_mt``. Adding to "
"``box.schema.space_mt`` makes the method available for all spaces."
msgstr ""
"Задана глобальная переменная ``box.schema.space_mt``. Метод, добавленный "
"в ``box.schema.space_mt``, будет доступен для всех спейсов."

#: ../doc/1.10/book/box/box_space.rst:1536
msgid ""
"Alternatively, user-defined methods can be made available for only one "
"space, by calling ``getmetatable(space_object)`` and then adding the "
"function name to the meta table. See also the example for "
":ref:`index_object:user_defined() <box_index-user_defined>`."
msgstr ""
"Можно также сделать задаваемый пользователем метод доступным только для "
"одного индекса путем вызова ``getmetatable(объект_спейса)`` и "
"последующего добавления имени функции в метатаблицу. См. также пример для"
" :ref:`index_object:user_defined() <box_index-user_defined>`."

#: ../doc/1.10/book/box/box_space.rst:1547
msgid ""
"-- Visible to any space, no parameters.\n"
"-- After these requests, the value of global_variable will be 6.\n"
"box.schema.space.create('t')\n"
"box.space.t:create_index('i')\n"
"global_variable = 5\n"
"function f(space_arg) global_variable = global_variable + 1 end\n"
"box.schema.space_mt.counter = f\n"
"box.space.t:counter()"
msgstr ""
"-- Доступный для любого спейса, без параметров.\n"
"-- После таких запросов значение глобальной переменной global_variable "
"будет 6.\n"
"box.schema.space.create('t')\n"
"box.space.t:create_index('i')\n"
"global_variable = 5\n"
"function f(space_arg) global_variable = global_variable + 1 end\n"
"box.schema.space_mt.counter = f\n"
"box.space.t:counter()"

#: ../doc/1.10/book/box/box_space.rst:1562
msgid ""
"Whether or not this space is enabled. The value is ``false`` if the space"
" has no index."
msgstr ""
"Определение активности спейса. Значение ``false`` указывает на отсутствие"
" индекса."

#: ../doc/1.10/book/box/box_space.rst:1569
msgid ""
"The required field count for all tuples in this space. The field_count "
"can be set initially with:"
msgstr ""
"Необходимость подсчета полей всех кортежей в спейсе, который можно "
"изначально задать следующим образом:"

#: ../doc/1.10/book/box/box_space.rst:1575
msgid ""
"box.schema.space.create(..., {\n"
"    ... ,\n"
"    field_count = *field_count_value* ,\n"
"    ...\n"
"})"
msgstr ""
"box.schema.space.create(..., {\n"
"    ... ,\n"
"    field_count = *field_count_value* ,\n"
"    ...\n"
"})"

#: ../doc/1.10/book/box/box_space.rst:1581
msgid "The default value is ``0``, which means there is no required field count."
msgstr ""
"По умолчанию, будет использоваться значение ``0``, что указывает на "
"отсутствие необходимости подсчета полей."

#: ../doc/1.10/book/box/box_space.rst:1585
msgid ""
"tarantool> box.space.tester.field_count\n"
"---\n"
"- 0\n"
"..."
msgstr ""
"tarantool> box.space.tester.field_count\n"
"---\n"
"- 0\n"
"..."

#: ../doc/1.10/book/box/box_space.rst:1596
msgid ""
"Ordinal space number. Spaces can be referenced by either name or number. "
"Thus, if space ``tester`` has ``id = 800``, then "
"``box.space.tester:insert{0}`` and ``box.space[800]:insert{0}`` are "
"equivalent requests."
msgstr ""
"Порядковый номер спейса. На спейс можно ссылаться либо по имени, либо по "
"номеру. Таким образом, если идентификатором спейса ``tester`` будет ``id "
"= 800``, то ``box.space.tester:insert{0}`` и ``box.space[800]:insert{0}``"
" представляют собой равнозначные запросы."

#: ../doc/1.10/book/box/box_space.rst:1603
msgid ""
"tarantool> box.space.tester.id\n"
"---\n"
"- 512\n"
"..."
msgstr ""
"tarantool> box.space.tester.id\n"
"---\n"
"- 512\n"
"..."

#: ../doc/1.10/book/box/box_space.rst:1614
msgid ""
"A container for all defined indexes. There is a Lua object of type "
":ref:`box.index <box_index>` with methods to search tuples and iterate "
"over them in predefined order."
msgstr ""
"Контейнер для всех определенных индексов. Есть Lua-объект типа "
":ref:`box.index <box_index>` с методами поиска кортежей и итерации по ним"
" в заданном порядке."

#: ../doc/1.10/book/box/box_space.rst:1618
msgid "To reset, use :ref:`box.stat.reset() <box_introspection-box_stat_reset>`."
msgstr ""
"Чтобы сбросить, use :ref:`box.stat.reset() <box_introspection-"
"box_stat_reset>`."

#: ../doc/1.10/book/box/box_space.rst:1624
msgid ""
"# checking the number of indexes for space 'tester'\n"
"tarantool> local counter=0; for i=0,#box.space.tester.index do\n"
"  if box.space.tester.index[i]~=nil then counter=counter+1 end\n"
"  end; print(counter)\n"
"1\n"
"---\n"
"...\n"
"# checking the type of index 'primary'\n"
"tarantool> box.space.tester.index.primary.type\n"
"---\n"
"- TREE\n"
"..."
msgstr ""
"# проверка количества индексов для спейса 'tester'\n"
"tarantool> local counter=0; for i=0,#box.space.tester.index do\n"
"  if box.space.tester.index[i]~=nil then counter=counter+1 end\n"
"  end; print(counter)\n"
"1\n"
"---\n"
"...\n"
"# проверка, что тип индекса -- первичный 'primary'\n"
"tarantool> box.space.tester.index.primary.type\n"
"---\n"
"- TREE\n"
"..."

#: ../doc/1.10/book/box/box_space.rst:1643
msgid ""
"``_cluster`` is a system space for support of the :ref:`replication "
"feature <replication>`."
msgstr ""
"``_cluster`` -- это системный спейс для поддержки :ref:`функции "
"репликации <replication>`."

#: ../doc/1.10/book/box/box_space.rst:1650
msgid ""
"``_func`` is a system space with function tuples made by "
":ref:`box.schema.func.create() <box_schema-func_create>`."
msgstr ""
"``_func`` -- это системный спейс, который содержит кортежи с функциями, "
"созданными с помощью :ref:`box.schema.func.create() <box_schema-"
"func_create>`."

#: ../doc/1.10/book/box/box_space.rst:1653
#: ../doc/1.10/book/box/box_space.rst:1706
#: ../doc/1.10/book/box/box_space.rst:1765
#: ../doc/1.10/book/box/box_space.rst:1881
#: ../doc/1.10/book/box/box_space.rst:1997
msgid "Tuples in this space contain the following fields:"
msgstr "Кортежи в данном спейсе включают в себя следующие поля:"

#: ../doc/1.10/book/box/box_space.rst:1655
msgid "the numeric function id, a number,"
msgstr "числовой идентификатор функции, число,"

#: ../doc/1.10/book/box/box_space.rst:1656
msgid "the function name,"
msgstr "имя функции,"

#: ../doc/1.10/book/box/box_space.rst:1657
msgid "flag,"
msgstr "флаг,"

#: ../doc/1.10/book/box/box_space.rst:1658
msgid "a language name (optional): 'LUA' (default) or 'C'."
msgstr "название языка (необязательно): 'LUA' (по умолчанию) or 'C'."

#: ../doc/1.10/book/box/box_space.rst:1660
msgid ""
"The ``_func`` space does not include the function’s body. You continue to"
" create Lua functions in the usual way, by saying ``function "
"function_name () ... end``, without adding anything in the ``_func`` "
"space. The ``_func`` space only exists for storing function tuples so "
"that their names can be used within :ref:`grant/revoke <authentication-"
"owners_privileges>` functions."
msgstr ""
"Спейс ``_func`` не содержит саму функцию. Lua-функции создаются "
"по-прежнему с помощью ``function имя_функции () ... end`` без каких-либо "
"добавлений в спейс ``_func``. Спейс ``_func`` предназначен лишь для "
"хранения кортежей с функциями так, чтобы их имена могли использоваться в "
"функциях :ref:`выдачи/отмены прав <authentication-owners_privileges>`."

#: ../doc/1.10/book/box/box_space.rst:1668
#: ../doc/1.10/book/box/box_space.rst:1775
msgid "You can:"
msgstr "Доступны следующие операции:"

#: ../doc/1.10/book/box/box_space.rst:1670
msgid ""
"Create a ``_func`` tuple with :ref:`box.schema.func.create() <box_schema-"
"func_create>`,"
msgstr ""
"Создание кортежа в ``_func`` с помощью :ref:`box.schema.func.create() "
"<box_schema-func_create>`,"

#: ../doc/1.10/book/box/box_space.rst:1672
msgid ""
"Drop a ``_func`` tuple with :ref:`box.schema.func.drop() <box_schema-"
"func_drop>`,"
msgstr ""
"Удаление кортежа в ``_func`` с помощью :ref:`box.schema.func.drop() "
"<box_schema-func_drop>`,"

#: ../doc/1.10/book/box/box_space.rst:1674
msgid ""
"Check whether a ``_func`` tuple exists with "
":ref:`box.schema.func.exists() <box_schema-func_exists>`."
msgstr ""
"Проверка наличия кортежа в ``_func`` с помощью "
":ref:`box.schema.func.exists() <box_schema-func_exists>`."

#: ../doc/1.10/book/box/box_space.rst:1679
msgid ""
"In the following example, we create a function named ‘f7’, put it into "
"Tarantool's ``_func`` space and grant 'execute' privilege for this "
"function to 'guest' user."
msgstr ""
"В следующем примере создадим функцию с именем ‘f7’, поместим ее в спейс "
"``_func`` в Tarantool'е и выдадим права на 'выполнение' этой функции "
"пользователю 'guest'."

#: ../doc/1.10/book/box/box_space.rst:1683
msgid ""
"tarantool> function f7()\n"
"         >  box.session.uid()\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> box.schema.func.create('f7')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('guest', 'execute', 'function', 'f7')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.revoke('guest', 'execute', 'function', 'f7')\n"
"---\n"
"..."
msgstr ""
"tarantool> function f7()\n"
"         >  box.session.uid()\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> box.schema.func.create('f7')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('guest', 'execute', 'function', 'f7')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.revoke('guest', 'execute', 'function', 'f7')\n"
"---\n"
"..."

#: ../doc/1.10/book/box/box_space.rst:1704
msgid "``_index`` is a system space."
msgstr "``_index`` -- это системный спейс."

#: ../doc/1.10/book/box/box_space.rst:1708
msgid "``id`` (= id of space),"
msgstr "``id`` (= идентификатор спейса),"

#: ../doc/1.10/book/box/box_space.rst:1709
msgid "``iid`` (= index number within space),"
msgstr "``iid`` (= номер индекса в спейсе),"

#: ../doc/1.10/book/box/box_space.rst:1710
msgid "``name``,"
msgstr "``name``,"

#: ../doc/1.10/book/box/box_space.rst:1711
msgid "``type``,"
msgstr "``type``,"

#: ../doc/1.10/book/box/box_space.rst:1712
msgid ""
"``opts`` (e.g. unique option), [``tuple-field-no``, ``tuple-field-type`` "
"...]."
msgstr ""
"``opts`` (например, уникальная опция), [``tuple-field-no``, ``tuple-"
"field-type`` ...]."

#: ../doc/1.10/book/box/box_space.rst:1714
msgid "Here is what ``_index`` contains in a typical installation:"
msgstr "Вот что при обычной установке включает в себя спейс ``_index``:"

#: ../doc/1.10/book/box/box_space.rst:1716
msgid ""
"tarantool> box.space._index:select{}\n"
"---\n"
"- - [272, 0, 'primary', 'tree', {'unique': true}, [[0, 'string']]]\n"
"  - [280, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned']]]\n"
"  - [280, 1, 'owner', 'tree', {'unique': false}, [[1, 'unsigned']]]\n"
"  - [280, 2, 'name', 'tree', {'unique': true}, [[2, 'string']]]\n"
"  - [281, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned']]]\n"
"  - [281, 1, 'owner', 'tree', {'unique': false}, [[1, 'unsigned']]]\n"
"  - [281, 2, 'name', 'tree', {'unique': true}, [[2, 'string']]]\n"
"  - [288, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned'], [1, "
"'unsigned']]]\n"
"  - [288, 2, 'name', 'tree', {'unique': true}, [[0, 'unsigned'], [2, "
"'string']]]\n"
"  - [289, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned'], [1, "
"'unsigned']]]\n"
"  - [289, 2, 'name', 'tree', {'unique': true}, [[0, 'unsigned'], [2, "
"'string']]]\n"
"  - [296, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned']]]\n"
"  - [296, 1, 'owner', 'tree', {'unique': false}, [[1, 'unsigned']]]\n"
"  - [296, 2, 'name', 'tree', {'unique': true}, [[2, 'string']]]\n"
"---\n"
"..."
msgstr ""
"tarantool> box.space._index:select{}\n"
"---\n"
"- - [272, 0, 'primary', 'tree', {'unique': true}, [[0, 'string']]]\n"
"  - [280, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned']]]\n"
"  - [280, 1, 'owner', 'tree', {'unique': false}, [[1, 'unsigned']]]\n"
"  - [280, 2, 'name', 'tree', {'unique': true}, [[2, 'string']]]\n"
"  - [281, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned']]]\n"
"  - [281, 1, 'owner', 'tree', {'unique': false}, [[1, 'unsigned']]]\n"
"  - [281, 2, 'name', 'tree', {'unique': true}, [[2, 'string']]]\n"
"  - [288, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned'], [1, "
"'unsigned']]]\n"
"  - [288, 2, 'name', 'tree', {'unique': true}, [[0, 'unsigned'], [2, "
"'string']]]\n"
"  - [289, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned'], [1, "
"'unsigned']]]\n"
"  - [289, 2, 'name', 'tree', {'unique': true}, [[0, 'unsigned'], [2, "
"'string']]]\n"
"  - [296, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned']]]\n"
"  - [296, 1, 'owner', 'tree', {'unique': false}, [[1, 'unsigned']]]\n"
"  - [296, 2, 'name', 'tree', {'unique': true}, [[2, 'string']]]\n"
"---\n"
"..."

#: ../doc/1.10/book/box/box_space.rst:1741
msgid ""
"``_vindex`` is a system space that represents a virtual view. The "
"structure of its tuples is identical to that of :ref:`_index <box_space-"
"index>`, but permissions for certain tuples are limited in accordance "
"with user privileges. ``_vindex`` contains only those tuples that are "
"accessible to the current user. See :ref:`Access control "
"<authentication>` for details about user privileges."
msgstr ""
"``_vindex`` -- это системный спейс, который реализует виртуальное "
"представление. Структура его кортежей совпадает со структурой кортежей в "
":ref:`_index <box_space-index>`, но права доступа на определенные кортежи"
" ограничены в соответствии с правами пользователя. ``_vindex`` содержит "
"только те кортежи, которые доступны текущему пользователю. Для получения "
"более подробной информации о правах пользователя см. раздел "
":ref:`Управление доступом <authentication>`."

#: ../doc/1.10/book/box/box_space.rst:1747
msgid ""
"If the user has the full set of privileges (like 'admin'), the contents "
"of ``_vindex`` match the contents of ``_index``. If the user has limited "
"access, ``_vindex`` contains only tuples accessible to this user."
msgstr ""
"Если у пользователя есть полный набор прав (как у пользователя 'admin'), "
"содержимое ``_vindex`` совпадает с содержимым ``_index``. Если же у "
"пользователя доступ ограничен, ``_vindex`` содержит только кортежи, "
"которые доступны текущему пользователю."

#: ../doc/1.10/book/box/box_space.rst:1753
msgid "``_vindex`` is a system view, so it allows only read requests."
msgstr ""
"``_vindex`` -- это виртуальное представление системы, поэтому допускаются"
" только запросы на чтение."

#: ../doc/1.10/book/box/box_space.rst:1755
msgid ""
"While the ``_index`` space requires proper access privileges, any user "
"can always read from ``_vindex``."
msgstr ""
"Если спейс ``_index`` требует наличия соответствующих прав доступа, то "
"любой пользователь всегда может выполнить чтение из ``_vindex``."

#: ../doc/1.10/book/box/box_space.rst:1762
msgid ""
"``_priv`` is a system space where :ref:`privileges <authentication-"
"owners_privileges>` are stored."
msgstr ""
"``_priv`` -- это системный спейс, где хранятся :ref:`права "
"<authentication-owners_privileges>`."

#: ../doc/1.10/book/box/box_space.rst:1767
msgid "the numeric id of the user who gave the privilege (\"grantor_id\"),"
msgstr "числовой идентификатор пользователя, который выдал права (\"grantor_id\"),"

#: ../doc/1.10/book/box/box_space.rst:1768
msgid "the numeric id of the user who received the privilege (\"grantee_id\"),"
msgstr ""
"числовой идентификатор пользователя, который получил права "
"(\"grantee_id\"),"

#: ../doc/1.10/book/box/box_space.rst:1769
msgid "the type of object: 'space', 'function', 'sequence' or 'universe',"
msgstr ""
"тип объекта: 'space' (спейс), 'function' (функция), 'sequence' "
"(последовательность) или 'universe' (вселенная),"

#: ../doc/1.10/book/box/box_space.rst:1770
msgid "the numeric id of the object,"
msgstr "числовой идентификатор объекта,"

#: ../doc/1.10/book/box/box_space.rst:1771
msgid ""
"the type of operation: \"read\" = 1, \"write\" = 2, \"execute\" = 4, "
"\"create\" = 32, \"drop\" = 64, \"alter\" = 128, or a combination such as"
" \"read,write,execute\"."
msgstr ""
"тип операции: \"read\" = 1, \"write\" = 2, \"execute\" = 4, \"create\" = "
"32, \"drop\" = 64, \"alter\" = 128, или их комбинация, например "
"\"read,write,execute\"."

#: ../doc/1.10/book/box/box_space.rst:1777
msgid ""
"Grant a privilege with :ref:`box.schema.user.grant() <box_schema-"
"user_grant>`."
msgstr ""
"Выдача прав с помощью :ref:`box.schema.user.grant() <box_schema-"
"user_grant>`."

#: ../doc/1.10/book/box/box_space.rst:1778
msgid ""
"Revoke a privilege with :ref:`box.schema.user.revoke() <box_schema-"
"user_revoke>`."
msgstr ""
"Отмена прав с помощью :ref:`box.schema.user.revoke() <box_schema-"
"user_revoke>`."

#: ../doc/1.10/book/box/box_space.rst:1782
msgid ""
"Generally, privileges are granted or revoked by the owner of the object "
"(the user who created it), or by the 'admin' user."
msgstr ""
"Как правило, права выдаются или отменяются владельцем объекта "
"(пользователем, который создал его) или пользователем 'admin'."

#: ../doc/1.10/book/box/box_space.rst:1785
msgid ""
"Before dropping any objects or users, make sure that all their associated"
" privileges have been revoked."
msgstr ""
"До удаления любых объектов или пользователей, убедитесь, что отменили все"
" связанные с ними права."

#: ../doc/1.10/book/box/box_space.rst:1788
msgid ""
"Only the :ref:`'admin' user <authentication-owners_privileges>` can grant"
" privileges for the 'universe'."
msgstr ""
"Только пользователь :ref:`'admin' <authentication-owners_privileges>` "
"может выдавать права на 'universe'."

#: ../doc/1.10/book/box/box_space.rst:1791
msgid ""
"Only the 'admin' user or the creator of a space can drop, alter, or "
"truncate the space."
msgstr ""
"Только пользователь 'admin' или создатель спейса может удалить, изменить "
"или очистить спейс."

#: ../doc/1.10/book/box/box_space.rst:1794
msgid ""
"Only the 'admin' user or the creator of a user can change a different "
"user’s password."
msgstr ""
"Только пользователь 'admin' или создатель спейса может изменять  change a"
" different user’s password."

#: ../doc/1.10/book/box/box_space.rst:1801
msgid ""
"``_vpriv`` is a system space that represents a virtual view. The "
"structure of its tuples is identical to that of :ref:`_priv <box_space-"
"priv>`, but permissions for certain tuples are limited in accordance with"
" user privileges. ``_vpriv`` contains only those tuples that are "
"accessible to the current user. See :ref:`Access control "
"<authentication>` for details about user privileges."
msgstr ""
"``_vpriv`` -- это системный спейс, который реализует виртуальное "
"представление. Структура его кортежей совпадает со структурой кортежей в "
":ref:`_priv <box_space-priv>`, но права доступа на определенные кортежи "
"ограничены в соответствии с правами пользователя. ``_vpriv`` содержит "
"только те кортежи, которые доступны текущему пользователю. Для получения "
"более подробной информации о правах пользователя см. раздел "
":ref:`Управление доступом <authentication>`."

#: ../doc/1.10/book/box/box_space.rst:1807
msgid ""
"If the user has the full set of privileges (like 'admin'), the contents "
"of ``_vpriv`` match the contents of ``_priv``. If the user has limited "
"access, ``_vpriv`` contains only tuples accessible to this user."
msgstr ""
"Если у пользователя есть полный набор прав (как у пользователя 'admin'), "
"содержимое ``_vpriv`` совпадает с содержимым ``_priv``. Если же у "
"пользователя доступ ограничен, ``_vpriv`` содержит только кортежи, "
"которые доступны текущему пользователю."

#: ../doc/1.10/book/box/box_space.rst:1813
msgid "``_vpriv`` is a system view, so it allows only read requests."
msgstr ""
"``_vpriv`` -- это виртуальное представление системы, поэтому допускаются "
"только запросы на чтение."

#: ../doc/1.10/book/box/box_space.rst:1815
msgid ""
"While the ``_priv`` space requires proper access privileges, any user can"
" always read from ``_vpriv``."
msgstr ""
"Если спейс ``_priv`` требует наличия соответствующих прав доступа, то "
"любой пользователь всегда может выполнить чтение из ``_vpriv``."

#: ../doc/1.10/book/box/box_space.rst:1822
msgid "``_schema`` is a system space."
msgstr "``_schema`` -- это системный спейс."

#: ../doc/1.10/book/box/box_space.rst:1824
msgid "This space contains the following tuples:"
msgstr "Этот спейс включает в себя следующие кортежи:"

#: ../doc/1.10/book/box/box_space.rst:1826
msgid "``version`` tuple with version information for this Tarantool instance,"
msgstr "кортеж ``version`` с информацией о версии данного экземпляра Tarantool'а,"

#: ../doc/1.10/book/box/box_space.rst:1827
msgid "``cluster`` tuple with the instance's replica set ID,"
msgstr "кортеж ``cluster`` с идентификатором набора реплик данного экземпляра,"

#: ../doc/1.10/book/box/box_space.rst:1828
msgid "``max_id`` tuple with the maximal space ID,"
msgstr "кортеж ``max_id`` с максимальным ID спейса,"

#: ../doc/1.10/book/box/box_space.rst:1829
msgid ""
"``once...`` tuples that correspond to specific :ref:`box.once() <box-"
"once>` blocks from the instance's :ref:`initialization file <index-"
"init_label>`. The first field in these tuples contains the ``key`` value "
"from the corresponding ``box.once()`` block prefixed with 'once' (e.g. "
"`oncehello`), so you can easily find a tuple that corresponds to a "
"specific ``box.once()`` block."
msgstr ""
"кортежи ``once...``, которые соответствуют определенным блокам "
":ref:`box.once() <box-once>` из :ref:`файла инициализации <index-"
"init_label>` экземпляра. Первое поле в таких кортежах содержит значение "
"ключа ``key`` из соответствующего блока ``box.once()`` с префиксом 'once'"
" (например, `oncehello`), поэтому можно легко найти кортеж, который "
"соответствует определенному блоку ``box.once()``."

#: ../doc/1.10/book/box/box_space.rst:1839
msgid ""
"Here is what ``_schema`` contains in a typical installation (notice the "
"tuples for two ``box.once()`` blocks, ``'oncebye'`` and ``'oncehello'``):"
msgstr ""
"Вот что при обычной установке включает в себя спейс ``_schema`` (обратите"
" внимание на кортежи для двух блоков ``box.once()``: ``'oncebye'`` и "
"``'oncehello'``):"

#: ../doc/1.10/book/box/box_space.rst:1842
msgid ""
"tarantool> box.space._schema:select{}\n"
"---\n"
"- - ['cluster', 'b4e15788-d962-4442-892e-d6c1dd5d13f2']\n"
"  - ['max_id', 512]\n"
"  - ['oncebye']\n"
"  - ['oncehello']\n"
"  - ['version', 1, 7, 2]"
msgstr ""
"tarantool> box.space._schema:select{}\n"
"---\n"
"- - ['cluster', 'b4e15788-d962-4442-892e-d6c1dd5d13f2']\n"
"  - ['max_id', 512]\n"
"  - ['oncebye']\n"
"  - ['oncehello']\n"
"  - ['version', 1, 7, 2]"

#: ../doc/1.10/book/box/box_space.rst:1856
msgid ""
"``_sequence`` is a system space for support of the :ref:`sequence feature"
" <index-box_sequence>`. It contains persistent information that was "
"established by :ref:`box.schema.sequence.create() <box_schema-"
"sequence_create>` or :ref:`box.schema.sequence.alter() <box_schema-"
"sequence_alter>`."
msgstr ""
"``_sequence`` -- это системный спейс для поддержки "
":ref:`последовательностей <index-box_sequence>`. Он содержит "
"персистентную информацию, определенную с помощью "
":ref:`box.schema.sequence.create() <box_schema-sequence_create>` или "
":ref:`box.schema.sequence.alter() <box_schema-sequence_alter>`."

#: ../doc/1.10/book/box/box_space.rst:1866
msgid ""
"``_sequence_data`` is a system space for support of the :ref:`sequence "
"feature <index-box_sequence>`."
msgstr ""
"``_sequence_data`` -- это системный спейс для поддержки "
":ref:`последовательностей <index-box_sequence>`."

#: ../doc/1.10/book/box/box_space.rst:1869
msgid "Each tuple in ``_sequence_data`` contains two fields:"
msgstr "Каждый кортеж в спейсе ``_sequence_data`` содержит два поля:"

#: ../doc/1.10/book/box/box_space.rst:1871
msgid "the id of the sequence, and"
msgstr "идентификатор последовательности и"

#: ../doc/1.10/book/box/box_space.rst:1872
msgid ""
"the last value that the sequence generator returned (non-persistent "
"information)."
msgstr ""
"последнее значение, возвращенное генератором последовательностей "
"(временная информация)."

#: ../doc/1.10/book/box/box_space.rst:1879
msgid "``_space`` is a system space."
msgstr "``_space`` -- это системный спейс."

#: ../doc/1.10/book/box/box_space.rst:1883
msgid "``id``,"
msgstr "``id``,"

#: ../doc/1.10/book/box/box_space.rst:1884
msgid "``owner`` (= id of user who owns the space),"
msgstr "``owner`` (= идентификатор пользователя, которому принадлежит спейс),"

#: ../doc/1.10/book/box/box_space.rst:1885
msgid "``name``, ``engine``, ``field_count``,"
msgstr "``name``, ``engine``, ``field_count``,"

#: ../doc/1.10/book/box/box_space.rst:1886
msgid "``flags`` (e.g. temporary),"
msgstr "``flags`` (например, временный),"

#: ../doc/1.10/book/box/box_space.rst:1887
msgid "``format`` (as made by a :ref:`format clause <box_space-format>`)."
msgstr "``format`` (как задано через :ref:`оператор формата <box_space-format>`)."

#: ../doc/1.10/book/box/box_space.rst:1889
msgid ""
"These fields are established by :ref:`space.create() <box_schema-"
"space_create>`."
msgstr ""
"Эти поля определены с помощью :ref:`space.create() <box_schema-"
"space_create>`."

#: ../doc/1.10/book/box/box_space.rst:1894
msgid ""
"The following function will display all simple fields in all tuples of "
"``_space``."
msgstr ""
"Следующая функция отобразит все простые поля во всех кортежах спейса "
"``_space``."

#: ../doc/1.10/book/box/box_space.rst:1897
msgid ""
"function example()\n"
"  local ta = {}\n"
"  local i, line\n"
"  for k, v in box.space._space:pairs() do\n"
"    i = 1\n"
"    line = ''\n"
"    while i <= #v do\n"
"      if type(v[i]) ~= 'table' then\n"
"        line = line .. v[i] .. ' '\n"
"      end\n"
"    i = i + 1\n"
"    end\n"
"    table.insert(ta, line)\n"
"  end\n"
"  return ta\n"
"end"
msgstr ""
"function example()\n"
"  local ta = {}\n"
"  local i, line\n"
"  for k, v in box.space._space:pairs() do\n"
"    i = 1\n"
"    line = ''\n"
"    while i <= #v do\n"
"      if type(v[i]) ~= 'table' then\n"
"        line = line .. v[i] .. ' '\n"
"      end\n"
"    i = i + 1\n"
"    end\n"
"    table.insert(ta, line)\n"
"  end\n"
"  return ta\n"
"end"

#: ../doc/1.10/book/box/box_space.rst:1916
msgid "Here is what ``example()`` returns in a typical installation:"
msgstr "Вот что при обычной установке вернет ``example()``:"

#: ../doc/1.10/book/box/box_space.rst:1918
msgid ""
"tarantool> example()\n"
"---\n"
"- - '272 1 _schema memtx 0  '\n"
"  - '280 1 _space memtx 0  '\n"
"  - '281 1 _vspace sysview 0  '\n"
"  - '288 1 _index memtx 0  '\n"
"  - '296 1 _func memtx 0  '\n"
"  - '304 1 _user memtx 0  '\n"
"  - '305 1 _vuser sysview 0  '\n"
"  - '312 1 _priv memtx 0  '\n"
"  - '313 1 _vpriv sysview 0  '\n"
"  - '320 1 _cluster memtx 0  '\n"
"  - '512 1 tester memtx 0  '\n"
"  - '513 1 origin vinyl 0  '\n"
"  - '514 1 archive memtx 0  '\n"
"..."
msgstr ""
"tarantool> example()\n"
"---\n"
"- - '272 1 _schema memtx 0  '\n"
"  - '280 1 _space memtx 0  '\n"
"  - '281 1 _vspace sysview 0  '\n"
"  - '288 1 _index memtx 0  '\n"
"  - '296 1 _func memtx 0  '\n"
"  - '304 1 _user memtx 0  '\n"
"  - '305 1 _vuser sysview 0  '\n"
"  - '312 1 _priv memtx 0  '\n"
"  - '313 1 _vpriv sysview 0  '\n"
"  - '320 1 _cluster memtx 0  '\n"
"  - '512 1 tester memtx 0  '\n"
"  - '513 1 origin vinyl 0  '\n"
"  - '514 1 archive memtx 0  '\n"
"..."

#: ../doc/1.10/book/box/box_space.rst:1939
msgid ""
"The following requests will create a space using "
"``box.schema.space.create()`` with a :ref:`format clause <box_space-"
"format>`, then retrieve the ``_space`` tuple for the new space. This "
"illustrates the typical use of the ``format`` clause, it shows the "
"recommended names and data types for the fields."
msgstr ""
"Следующая серия запросов создаст спейс, используя "
"``box.schema.space.create()`` с :ref:`оператором формата <box_space-"
"format>`, затем выберет кортеж из ``_space`` для нового спейса. Этот "
"пример иллюстрирует стандартное применение оператора ``format``, "
"показывая рекомендованные имена и типы данных для полей."

#: ../doc/1.10/book/box/box_space.rst:1945
msgid ""
"tarantool> box.schema.space.create('TM', {\n"
"         >   id = 12345,\n"
"         >   format = {\n"
"         >     [1] = {[\"name\"] = \"field_1\"},\n"
"         >     [2] = {[\"type\"] = \"unsigned\"}\n"
"         >   }\n"
"         > })\n"
"---\n"
"- index: []\n"
"  on_replace: 'function: 0x41c67338'\n"
"  temporary: false\n"
"  id: 12345\n"
"  engine: memtx\n"
"  enabled: false\n"
"  name: TM\n"
"  field_count: 0\n"
"- created\n"
"...\n"
"tarantool> box.space._space:select(12345)\n"
"---\n"
"- - [12345, 1, 'TM', 'memtx', 0, {}, [{'name': 'field_1'}, {'type': "
"'unsigned'}]]\n"
"..."
msgstr ""
"tarantool> box.schema.space.create('TM', {\n"
"         >   id = 12345,\n"
"         >   format = {\n"
"         >     [1] = {[\"name\"] = \"field_1\"},\n"
"         >     [2] = {[\"type\"] = \"unsigned\"}\n"
"         >   }\n"
"         > })\n"
"---\n"
"- index: []\n"
"  on_replace: 'function: 0x41c67338'\n"
"  temporary: false\n"
"  id: 12345\n"
"  engine: memtx\n"
"  enabled: false\n"
"  name: TM\n"
"  field_count: 0\n"
"- created\n"
"...\n"
"tarantool> box.space._space:select(12345)\n"
"---\n"
"- - [12345, 1, 'TM', 'memtx', 0, {}, [{'name': 'field_1'}, {'type': "
"'unsigned'}]]\n"
"..."

#: ../doc/1.10/book/box/box_space.rst:1974
msgid ""
"``_vspace`` is a system space that represents a virtual view. The "
"structure of its tuples is identical to that of :ref:`_space <box_space-"
"space>`, but permissions for certain tuples are limited in accordance "
"with user privileges. ``_vspace`` contains only those tuples that are "
"accessible to the current user. See :ref:`Access control "
"<authentication>` for details about user privileges."
msgstr ""
"``_vspace`` -- это системный спейс, который реализует виртуальное "
"представление. Структура его кортежей совпадает со структурой кортежей в "
":ref:`_space <box_space-space>`, но права доступа на определенные кортежи"
" ограничены в соответствии с правами пользователя. ``_vspace`` содержит "
"только те кортежи, которые доступны текущему пользователю. Для получения "
"более подробной информации о правах пользователя см. раздел "
":ref:`Управление доступом <authentication>`."

#: ../doc/1.10/book/box/box_space.rst:1980
msgid ""
"If the user has the full set of privileges (like 'admin'), the contents "
"of ``_vspace`` match the contents of ``_space``. If the user has limited "
"access, ``_vspace`` contains only tuples accessible to this user."
msgstr ""
"Если у пользователя есть полный набор прав (как у пользователя 'admin'), "
"содержимое ``_vspace`` совпадает с содержимым ``_space``. Если же у "
"пользователя доступ ограничен, ``_vspace`` содержит только кортежи, "
"которые доступны текущему пользователю."

#: ../doc/1.10/book/box/box_space.rst:1986
msgid "``_vspace`` is a system view, so it allows only read requests."
msgstr ""
"``_vspace`` -- это виртуальное представление системы, поэтому допускаются"
" только запросы на чтение."

#: ../doc/1.10/book/box/box_space.rst:1988
msgid ""
"While the ``_space`` space requires proper access privileges, any user "
"can always read from ``_vspace``."
msgstr ""
"Если спейс ``_space`` требует наличия соответствующих прав доступа, то "
"любой пользователь всегда может выполнить чтение из ``_vspace``."

#: ../doc/1.10/book/box/box_space.rst:1995
msgid ""
"``_user`` is a system space where user-names and password hashes are "
"stored."
msgstr ""
"``_user`` -- это системный спейс, где хранятся имена пользователей и хеши"
" паролей."

#: ../doc/1.10/book/box/box_space.rst:1999
msgid "the numeric id of the tuple (\"id\"),"
msgstr "числовой идентификатор кортежа (\"id\"),"

#: ../doc/1.10/book/box/box_space.rst:2000
msgid "the numeric id of the tuple’s creator,"
msgstr "числовой идентификатор создателя кортежа,"

#: ../doc/1.10/book/box/box_space.rst:2001
msgid "the name,"
msgstr "имя,"

#: ../doc/1.10/book/box/box_space.rst:2002
msgid "the type: 'user' or 'role',"
msgstr "тип: 'user' (пользователь) или 'role' (роль),"

#: ../doc/1.10/book/box/box_space.rst:2003
msgid "optional password."
msgstr "пароль по желанию"

#: ../doc/1.10/book/box/box_space.rst:2005
msgid ""
"There are five special tuples in the ``_user`` space: 'guest', 'admin', "
"'public', 'replication', and 'super'."
msgstr ""
"В спейсе ``_user`` есть пять специальных кортежей: 'guest', 'admin', "
"'public', 'replication' и 'super'."

#: ../doc/1.10/book/box/box_space.rst:2018
msgid "ID"
msgstr "ID"

#: ../doc/1.10/book/box/box_space.rst:2020
msgid "guest"
msgstr "guest"

#: ../doc/1.10/book/box/box_space.rst:2020
#: ../doc/1.10/book/box/data_model.rst:503
msgid "0"
msgstr "0"

#: ../doc/1.10/book/box/box_space.rst:2020
msgid ""
"Default user when connecting remotely. Usually an untrusted user with few"
" privileges."
msgstr ""
"Пользователь, который используется по умолчанию при удаленном "
"подключении. Как правило, это не заслуживающий доверия пользователь с "
"небольшим количеством прав."

#: ../doc/1.10/book/box/box_space.rst:2023
msgid "admin"
msgstr "admin"

#: ../doc/1.10/book/box/box_space.rst:2023
#: ../doc/1.10/book/box/data_model.rst:490
#: ../doc/1.10/book/box/data_model.rst:494
#: ../doc/1.10/book/box/data_model.rst:506
msgid "1"
msgstr "1"

#: ../doc/1.10/book/box/box_space.rst:2023
msgid ""
"Default user when using Tarantool as a console. Usually an "
":ref:`administrative user <authentication-owners_privileges>` with all "
"privileges."
msgstr ""
"Пользователь, который используется по умолчанию при работе с Tarantool'ом"
" как с консолью. Как правило, это :ref:`административный пользователь "
"<authentication-owners_privileges>` со всеми правами."

#: ../doc/1.10/book/box/box_space.rst:2028
msgid "public"
msgstr "public"

#: ../doc/1.10/book/box/box_space.rst:2028
#: ../doc/1.10/book/box/box_space.rst:2036
#: ../doc/1.10/book/box/box_space.rst:2040
msgid "role"
msgstr "роль"

#: ../doc/1.10/book/box/box_space.rst:2028
msgid ""
"Pre-defined :ref:`role <authentication-roles>`, automatically granted to "
"new users when they are created with ``box.schema.user.create(user-"
"name)``. Therefore a convenient way to grant 'read' on space 't' to every"
" user that will ever exist is with "
"``box.schema.role.grant('public','read','space','t')``."
msgstr ""
"Заданная :ref:`роль <authentication-roles>`, которая автоматически "
"выдается новым пользователям при их создании методом "
"``box.schema.user.create(имя-пользователя)``. Таким образом, лучше всего "
"выдать права на чтение 'read' спейса 't' каждому когда-либо созданному "
"пользователю с помощью "
"``box.schema.role.grant('public','read','space','t')``."

#: ../doc/1.10/book/box/box_space.rst:2036
msgid "replication"
msgstr "replication"

#: ../doc/1.10/book/box/box_space.rst:2036
msgid "3"
msgstr "3"

#: ../doc/1.10/book/box/box_space.rst:2036
msgid ""
"Pre-defined :ref:`role <authentication-roles>`, which the 'admin' user "
"can grant to users who need to use :ref:`replication <replication>` "
"features."
msgstr ""
"Заданная :ref:`роль <authentication-roles>`, выдаваемая пользователем "
"'admin' другим пользователям для использования функций :ref:`репликации "
"<replication>`."

#: ../doc/1.10/book/box/box_space.rst:2040
msgid "super"
msgstr "super"

#: ../doc/1.10/book/box/box_space.rst:2040
msgid "31"
msgstr "31"

#: ../doc/1.10/book/box/box_space.rst:2040
msgid ""
"Pre-defined :ref:`role <authentication-roles>`, which the 'admin' user "
"can grant to users who need all privileges on all objects. The 'super' "
"role has these privileges on 'universe': read, write, execute, create, "
"drop, alter."
msgstr ""
"Заданная :ref:`роль <authentication-roles>`, выдаваемая пользователем "
"'admin' другим пользователям для получения всех прав на все объекты. Для "
"роли 'super' такие права выданы на 'universe': чтение, запись, "
"выполнение, создание, удаление, изменение."

#: ../doc/1.10/book/box/box_space.rst:2048
msgid ""
"To select a tuple from the ``_user`` space, use "
"``box.space._user:select()``. For example, here is what happens with a "
"select for user id = 0, which is the 'guest' user, which by default has "
"no password:"
msgstr ""
"Чтобы выбрать кортеж из спейса ``_user``, используйте "
"``box.space._user:select()``. Например, при выборке от пользователя с id "
"= 0, который является пользователем 'guest' без пароля по умолчанию, "
"произойдет следующее:"

#: ../doc/1.10/book/box/box_space.rst:2052
msgid ""
"tarantool> box.space._user:select{0}\n"
"---\n"
"- - [0, 1, 'guest', 'user']\n"
"..."
msgstr ""
"tarantool> box.space._user:select{0}\n"
"---\n"
"- - [0, 1, 'guest', 'user']\n"
"..."

#: ../doc/1.10/book/box/box_space.rst:2061
msgid ""
"To change tuples in the ``_user`` space, do not use ordinary "
"``box.space`` functions for insert or update or delete. The ``_user`` "
"space is special, so there are special functions which have appropriate "
"error checking."
msgstr ""
"Чтобы изменить кортежи в спейсе ``_user``, не пользуйтесь стандартными "
"функциями ``box.space`` для вставки, обновления или удаления. Речь идет "
"об особом спейсе ``_user``, поэтому есть особые функции с соответствующей"
" проверкой на ошибки."

#: ../doc/1.10/book/box/box_space.rst:2065
msgid ""
"To create a new user, use :ref:`box.schema.user.create() <box_schema-"
"user_create>`:"
msgstr ""
"Чтобы создать нового пользователя, используйте "
":ref:`box.schema.user.create() <box_schema-user_create>`:"

#: ../doc/1.10/book/box/box_space.rst:2070
msgid ""
"box.schema.user.create(*user-name*)\n"
"box.schema.user.create(*user-name*, {if_not_exists = true})\n"
"box.schema.user.create(*user-name*, {password = *password*})"
msgstr ""
"box.schema.user.create(*имя-пользователя*)\n"
"box.schema.user.create(*имя-пользователя*, {if_not_exists = true})\n"
"box.schema.user.create(*имя-пользователя*, {password = *пароль*})"

#: ../doc/1.10/book/box/box_space.rst:2074
msgid ""
"To change the user's password, use :ref:`box.schema.user.password() "
"<box_schema-user_password>`:"
msgstr ""
"Чтобы изменить пароль пользователя, воспользуйтесь "
":ref:`box.schema.user.password() <box_schema-user_password>`:"

#: ../doc/1.10/book/box/box_space.rst:2079
msgid ""
"-- To change the current user's password\n"
"box.schema.user.passwd(*password*)\n"
"\n"
"-- To change a different user's password\n"
"-- (usually only 'admin' can do it)\n"
"box.schema.user.passwd(*user-name*, *password*)"
msgstr ""
"-- Чтобы изменить пароль текущего пользователя\n"
"box.schema.user.passwd(*пароль*)\n"
"\n"
"-- Чтобы изменить пароль другого пользователя\n"
"-- (обычно это может делать только 'admin')\n"
"box.schema.user.passwd(*имя-пользователя*, *пароль*)"

#: ../doc/1.10/book/box/box_space.rst:2086
msgid "To drop a user, use :ref:`box.schema.user.drop() <box_schema-user_drop>`:"
msgstr ""
"Чтобы удалить пользователя, используйте :ref:`box.schema.user.drop() "
"<box_schema-user_drop>`:"

#: ../doc/1.10/book/box/box_space.rst:2091
msgid "box.schema.user.drop(*user-name*)"
msgstr "box.schema.user.drop(*имя-пользователя*)"

#: ../doc/1.10/book/box/box_space.rst:2093
msgid ""
"To check whether a user exists, use :ref:`box.schema.user.exists() "
"<box_schema-user_exists>`, which returns ``true`` or ``false``:"
msgstr ""
"Чтобы проверить, существует ли пользователь, воспользуйтесь "
":ref:`box.schema.user.exists() <box_schema-user_exists>`, которая вернет "
"``true`` (правда) или ``false`` (ложь):"

#: ../doc/1.10/book/box/box_space.rst:2099
msgid "box.schema.user.exists(*user-name*)"
msgstr "box.schema.user.exists(*имя-пользователя*)"

#: ../doc/1.10/book/box/box_space.rst:2101
msgid ""
"To find what privileges a user has, use :ref:`box.schema.user.info() "
"<box_schema-user_info>`:"
msgstr ""
"Чтобы узнать, какие права есть у пользователя, используйте "
":ref:`box.schema.user.info() <box_schema-user_info>`:"

#: ../doc/1.10/book/box/box_space.rst:2106
msgid "box.schema.user.info(*user-name*)"
msgstr "box.schema.user.info(*имя-пользователя*)"

#: ../doc/1.10/book/box/box_space.rst:2114
msgid ""
"Here is a session which creates a new user with a strong password, "
"selects a tuple in the ``_user`` space, and then drops the user."
msgstr ""
"Ниже представлена сессия, в рамках которой создается новый пользователь с"
" надежным паролем, выбирается кортеж из спейса ``_user``, а затем "
"пользователь удаляется."

#: ../doc/1.10/book/box/box_space.rst:2117
msgid ""
"tarantool> box.schema.user.create('JeanMartin', {password = "
"'Iwtso_6_os$$'})\n"
"---\n"
"...\n"
"tarantool> box.space._user.index.name:select{'JeanMartin'}\n"
"---\n"
"- - [17, 1, 'JeanMartin', 'user', {'chap-sha1': "
"'t3xjUpQdrt857O+YRvGbMY5py8Q='}]\n"
"...\n"
"tarantool> box.schema.user.drop('JeanMartin')\n"
"---\n"
"..."
msgstr ""
"tarantool> box.schema.user.create('JeanMartin', {password = "
"'Iwtso_6_os$$'})\n"
"---\n"
"...\n"
"tarantool> box.space._user.index.name:select{'JeanMartin'}\n"
"---\n"
"- - [17, 1, 'JeanMartin', 'user', {'chap-sha1': "
"'t3xjUpQdrt857O+YRvGbMY5py8Q='}]\n"
"...\n"
"tarantool> box.schema.user.drop('JeanMartin')\n"
"---\n"
"..."

#: ../doc/1.10/book/box/box_space.rst:2132
msgid "Example: using box.space functions to read _space tuples"
msgstr "Пример: использование функций box.space для чтения кортежей из _space"

#: ../doc/1.10/book/box/box_space.rst:2134
msgid ""
"This function will illustrate how to look at all the spaces, and for each"
" display: approximately how many tuples it contains, and the first field "
"of its first tuple. The function uses Tarantool ``box.space`` functions "
"``len()`` and ``pairs()``. The iteration through the spaces is coded as a"
" scan of the ``_space`` system space, which contains metadata. The third "
"field in ``_space`` contains the space name, so the key instruction "
"``space_name = v[3]`` means ``space_name`` is the ``space_name`` field in"
" the tuple of ``_space`` that we've just fetched with ``pairs()``. The "
"function returns a table:"
msgstr ""
"Функция ниже проиллюстрирует, как обращаться ко всем спейсам, и для "
"каждого отобразит примерное количество кортежей и первое поле первого "
"кортежа. В данной функции используются функции из ``box.space`` в "
"Tarantool'е: ``len()`` и ``pairs()``. Итерация по спейсам закодирована в "
"форме сканирования системного спейса ``_space``, который содержит "
"метаданные. Третье поле в ``_space`` содержит имя спейса, поэтому "
"ключевая команда ``space_name = v[3]`` означает, что ``space_name`` -- "
"это поле ``space_name`` в кортеже ``_space``, который мы только что "
"получили с помощью ``pairs()``. Функция возвращает таблицу:"

#: ../doc/1.10/book/box/box_space.rst:2144
msgid ""
"function example()\n"
"  local tuple_count, space_name, line\n"
"  local ta = {}\n"
"  for k, v in box.space._space:pairs() do\n"
"    space_name = v[3]\n"
"    if box.space[space_name].index[0] ~= nil then\n"
"      tuple_count = '1 or more'\n"
"    else\n"
"      tuple_count = '0'\n"
"    end\n"
"    line = space_name .. ' tuple_count =' .. tuple_count\n"
"    if tuple_count == '1 or more' then\n"
"      for k1, v1 in box.space[space_name]:pairs() do\n"
"        line = line .. '. first field in first tuple = ' .. v1[1]\n"
"        break\n"
"      end\n"
"    end\n"
"    table.insert(ta, line)\n"
"  end\n"
"  return ta\n"
"end"
msgstr ""
"function example()\n"
"  local tuple_count, space_name, line\n"
"  local ta = {}\n"
"  for k, v in box.space._space:pairs() do\n"
"    space_name = v[3]\n"
"    if box.space[space_name].index[0] ~= nil then\n"
"      tuple_count = '1 or more'\n"
"    else\n"
"      tuple_count = '0'\n"
"    end\n"
"    line = space_name .. ' tuple_count =' .. tuple_count\n"
"    if tuple_count == '1 or more' then\n"
"      for k1, v1 in box.space[space_name]:pairs() do\n"
"        line = line .. '. first field in first tuple = ' .. v1[1]\n"
"        break\n"
"      end\n"
"    end\n"
"    table.insert(ta, line)\n"
"  end\n"
"  return ta\n"
"end"

#: ../doc/1.10/book/box/box_space.rst:2168
msgid "And here is what happens when one invokes the function:"
msgstr "А вот что происходит, когда вызывается функция:"

#: ../doc/1.10/book/box/box_space.rst:2170
msgid ""
"tarantool> example()\n"
"---\n"
"- - _schema tuple_count =1 or more. first field in first tuple = cluster\n"
"  - _space tuple_count =1 or more. first field in first tuple = 272\n"
"  - _vspace tuple_count =1 or more. first field in first tuple = 272\n"
"  - _index tuple_count =1 or more. first field in first tuple = 272\n"
"  - _vindex tuple_count =1 or more. first field in first tuple = 272\n"
"  - _func tuple_count =1 or more. first field in first tuple = 1\n"
"  - _vfunc tuple_count =1 or more. first field in first tuple = 1\n"
"  - _user tuple_count =1 or more. first field in first tuple = 0\n"
"  - _vuser tuple_count =1 or more. first field in first tuple = 0\n"
"  - _priv tuple_count =1 or more. first field in first tuple = 1\n"
"  - _vpriv tuple_count =1 or more. first field in first tuple = 1\n"
"  - _cluster tuple_count =1 or more. first field in first tuple = 1\n"
"..."
msgstr ""
"tarantool> example()\n"
"---\n"
"- - _schema tuple_count =1 or more. first field in first tuple = cluster\n"
"  - _space tuple_count =1 or more. first field in first tuple = 272\n"
"  - _vspace tuple_count =1 or more. first field in first tuple = 272\n"
"  - _index tuple_count =1 or more. first field in first tuple = 272\n"
"  - _vindex tuple_count =1 or more. first field in first tuple = 272\n"
"  - _func tuple_count =1 or more. first field in first tuple = 1\n"
"  - _vfunc tuple_count =1 or more. first field in first tuple = 1\n"
"  - _user tuple_count =1 or more. first field in first tuple = 0\n"
"  - _vuser tuple_count =1 or more. first field in first tuple = 0\n"
"  - _priv tuple_count =1 or more. first field in first tuple = 1\n"
"  - _vpriv tuple_count =1 or more. first field in first tuple = 1\n"
"  - _cluster tuple_count =1 or more. first field in first tuple = 1\n"
"..."

#: ../doc/1.10/book/box/box_space.rst:2190
msgid "Example: using box.space functions to organize a _space tuple"
msgstr "Пример: использование функций box.space для организации кортежа из _space"

#: ../doc/1.10/book/box/box_space.rst:2192
msgid ""
"The objective is to display field names and field types of a system space"
" -- using metadata to find metadata."
msgstr ""
"Основная цель -- отобразить имена и типы полей системного спейса, то есть"
" использование метаданных для поиска метаданных."

#: ../doc/1.10/book/box/box_space.rst:2195
msgid ""
"To begin: how can one select the ``_space`` tuple that describes "
"``_space``?"
msgstr ""
"Для начала: как можно сделать выборку кортежа из ``_space``, который "
"описывает ``_space``?"

#: ../doc/1.10/book/box/box_space.rst:2197
msgid ""
"A simple way is to look at the constants in ``box.schema``, which tell us"
" that there is an item named SPACE_ID == 288, so these statements will "
"retrieve the correct tuple:"
msgstr ""
"Проще всего проверить постоянные в ``box.schema``, что укажет на наличие "
"элемента под названием SPACE_ID == 288. Таким образом, следующие запросы "
"вернут нужный кортеж:"

#: ../doc/1.10/book/box/box_space.rst:2201
msgid ""
"box.space._space:select{ 288 }\n"
"-- or --\n"
"box.space._space:select{ box.schema.SPACE_ID }"
msgstr ""
"box.space._space:select{ 288 }\n"
"-- или --\n"
"box.space._space:select{ box.schema.SPACE_ID }"

#: ../doc/1.10/book/box/box_space.rst:2207
msgid ""
"Another way is to look at the tuples in ``box.space._index``, which tell "
"us that there is a secondary index named 'name' for space number 288, so "
"this statement also will retrieve the correct tuple:"
msgstr ""
"Также можно обратиться к спейсам в ``box.space._index``, что укажет на "
"наличие вторичного индекса с именем 'name' для спейса под номером 288. "
"Таким образом, следующий запрос также вернет нужный кортеж:"

#: ../doc/1.10/book/box/box_space.rst:2211
msgid "box.space._space.index.name:select{ '_space' }"
msgstr "box.space._space.index.name:select{ '_space' }"

#: ../doc/1.10/book/box/box_space.rst:2215
msgid "However, the retrieved tuple is not easy to read:"
msgstr "Однако непросто прочитать информацию из полученного кортежа:"

#: ../doc/1.10/book/box/box_space.rst:2217
msgid ""
"tarantool> box.space._space.index.name:select{'_space'}\n"
"---\n"
"- - [280, 1, '_space', 'memtx', 0, {}, [{'name': 'id', 'type': 'num'}, "
"{'name': 'owner',\n"
"        'type': 'num'}, {'name': 'name', 'type': 'str'}, {'name': "
"'engine', 'type': 'str'},\n"
"      {'name': 'field_count', 'type': 'num'}, {'name': 'flags', 'type': "
"'str'}, {\n"
"        'name': 'format', 'type': '*'}]]\n"
"..."
msgstr ""
"tarantool> box.space._space.index.name:select{'_space'}\n"
"---\n"
"- - [280, 1, '_space', 'memtx', 0, {}, [{'name': 'id', 'type': 'num'}, "
"{'name': 'owner',\n"
"        'type': 'num'}, {'name': 'name', 'type': 'str'}, {'name': "
"'engine', 'type': 'str'},\n"
"      {'name': 'field_count', 'type': 'num'}, {'name': 'flags', 'type': "
"'str'}, {\n"
"        'name': 'format', 'type': '*'}]]\n"
"..."

#: ../doc/1.10/book/box/box_space.rst:2227
msgid ""
"It looks disorganized because field number 7 has been formatted with "
"recommended names and data types. How can one get those specific sub-"
"fields? Since it's visible that field number 7 is an array of maps, this "
"`for` loop will do the organizing:"
msgstr ""
"Информация подается бессистемно, поскольку по формату поле №7 содержит "
"рекомендованные имена и типы данных. Как же получить эти данные? "
"Поскольку очевидно, что поле №7 представляет собой ассоциативный массив, "
"цикл `for` проведет организацию данных:"

#: ../doc/1.10/book/box/box_space.rst:2232
msgid ""
"tarantool> do\n"
"         >   local tuple_of_space = "
"box.space._space.index.name:get{'_space'}\n"
"         >   for _, field in ipairs(tuple_of_space[7]) do\n"
"         >     print(field.name .. ', ' .. field.type)\n"
"         >   end\n"
"         > end\n"
"id, num\n"
"owner, num\n"
"name, str\n"
"engine, str\n"
"field_count, num\n"
"flags, str\n"
"format, *\n"
"---\n"
"..."
msgstr ""
"tarantool> do\n"
"         >   local tuple_of_space = "
"box.space._space.index.name:get{'_space'}\n"
"         >   for _, field in ipairs(tuple_of_space[7]) do\n"
"         >     print(field.name .. ', ' .. field.type)\n"
"         >   end\n"
"         > end\n"
"id, num\n"
"owner, num\n"
"name, str\n"
"engine, str\n"
"field_count, num\n"
"flags, str\n"
"format, *\n"
"---\n"
"..."

#: ../doc/1.10/book/box/box_space.rst:2254
msgid ""
"``_vuser`` is a system space that represents a virtual view. The "
"structure of its tuples is identical to that of :ref:`_user <box_space-"
"user>`, but permissions for certain tuples are limited in accordance with"
" user privileges. ``_vuser`` contains only those tuples that are "
"accessible to the current user. See :ref:`Access control "
"<authentication>` for details about user privileges."
msgstr ""
"``_vuser`` -- это системный спейс, который реализует виртуальное "
"представление. Структура его кортежей совпадает со структурой кортежей в "
":ref:`_user <box_space-user>`, но права доступа на определенные кортежи "
"ограничены в соответствии с правами пользователя. ``_vuser`` содержит "
"только те кортежи, которые доступны текущему пользователю. Для получения "
"более подробной информации о правах пользователя см. раздел "
":ref:`Управление доступом <authentication>`."

#: ../doc/1.10/book/box/box_space.rst:2260
msgid ""
"If the user has the full set of privileges (like 'admin'), the contents "
"of ``_vuser`` match the contents of ``_user``. If the user has limited "
"access, ``_vuser`` contains only tuples accessible to this user."
msgstr ""
"Если у пользователя есть полный набор прав (как у пользователя 'admin'), "
"содержимое ``_vuser`` совпадает с содержимым ``_user``. Если же у "
"пользователя доступ ограничен, ``_vuser`` содержит только кортежи, "
"которые доступны текущему пользователю."

#: ../doc/1.10/book/box/box_space.rst:2264
msgid ""
"To see how ``_vuser`` works, :ref:`connect to a Tarantool database "
"remotely <connecting-remotely>` via ``tarantoolctl`` and select all "
"tuples from the ``_user`` space, both when the 'guest' user *is* and *is "
"not* allowed to read from the database."
msgstr ""
"Чтобы посмотреть, как работать с ``_vuser``, :ref:`удаленно подключитесь "
"к базе данных Tarantool'а <connecting-remotely>` с помощью "
"``tarantoolctl`` и сделайте выборку кортежей из спейса ``_user`` в "
"следующих ситуациях: когда пользователь 'guest' *имеет* и когда он *не "
"имеет* права выполнять чтение данных из базы."

#: ../doc/1.10/book/box/box_space.rst:2270
msgid ""
"First, start Tarantool and grant the 'guest' user with read, write and "
"execute privileges:"
msgstr ""
"Для начала запустите Tarantool и выдайте пользователю 'guest' права на "
"чтение, запись и выполнение:"

#: ../doc/1.10/book/box/box_space.rst:2273
msgid ""
"tarantool> box.cfg{listen = 3301}\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('guest', 'read,write,execute', "
"'universe')\n"
"---\n"
"..."
msgstr ""
"tarantool> box.cfg{listen = 3301}\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('guest', 'read,write,execute', "
"'universe')\n"
"---\n"
"..."

#: ../doc/1.10/book/box/box_space.rst:2282
msgid ""
"Switch to the other terminal, connect to the Tarantool instance and "
"select all tuples from the ``_user`` space:"
msgstr ""
"Перейдите на другой терминал, подключитесь к экземпляру Tarantool'а и "
"произведите выборку всех кортежей из спейса ``_user``:"

#: ../doc/1.10/book/box/box_space.rst:2285
msgid ""
"$ tarantoolctl connect 3301\n"
"localhost:3301> box.space._user:select{}\n"
"---\n"
"- - [0, 1, 'guest', 'user', {}]\n"
"  - [1, 1, 'admin', 'user', {}]\n"
"  - [2, 1, 'public', 'role', {}]\n"
"  - [3, 1, 'replication', 'role', {}]\n"
"  - [31, 1, 'super', 'role', {}]\n"
"..."
msgstr ""
"$ tarantoolctl connect 3301\n"
"localhost:3301> box.space._user:select{}\n"
"---\n"
"- - [0, 1, 'guest', 'user', {}]\n"
"  - [1, 1, 'admin', 'user', {}]\n"
"  - [2, 1, 'public', 'role', {}]\n"
"  - [3, 1, 'replication', 'role', {}]\n"
"  - [31, 1, 'super', 'role', {}]\n"
"..."

#: ../doc/1.10/book/box/box_space.rst:2297
msgid ""
"This result contains the same set of users as if you made the request "
"from your Tarantool instance as 'admin'."
msgstr ""
"Результат включает в себя тот же набор пользователей, как если бы вы "
"выполнили запрос от пользователя 'admin' на своем экземпляре Tarantool'а."

#: ../doc/1.10/book/box/box_space.rst:2300
msgid ""
"Switch to the first terminal and revoke the read privileges from the "
"'guest' user:"
msgstr ""
"Вернитесь в первый терминал и отмените права на чтение пользователю "
"'guest':"

#: ../doc/1.10/book/box/box_space.rst:2302
msgid ""
"tarantool> box.schema.user.revoke('guest', 'read', 'universe')\n"
"---\n"
"..."
msgstr ""
"tarantool> box.schema.user.revoke('guest', 'read', 'universe')\n"
"---\n"
"..."

#: ../doc/1.10/book/box/box_space.rst:2308
msgid ""
"Switch to the other terminal, stop the session (to stop ``tarantoolctl``,"
" type Ctrl+C or Ctrl+D) and repeat the ``box.space._user:select{}`` "
"request. The access is denied:"
msgstr ""
"Перейдите на другой терминал, остановите сессию (чтобы остановить "
"``tarantoolctl``, нажмите Ctrl+C или Ctrl+D) и повторите запрос "
"``box.space._user:select{}``. В доступе отказано:"

#: ../doc/1.10/book/box/box_space.rst:2312
msgid ""
"$ tarantoolctl connect 3301\n"
"localhost:3301> box.space._user:select{}\n"
"---\n"
"- error: Read access to space '_user' is denied for user 'guest'\n"
"..."
msgstr ""
"$ tarantoolctl connect 3301\n"
"localhost:3301> box.space._user:select{}\n"
"---\n"
"- error: Read access to space '_user' is denied for user 'guest'\n"
"..."

#: ../doc/1.10/book/box/box_space.rst:2320
msgid ""
"However, if you select from ``_vuser`` instead, the users' data available"
" for the 'guest' user is displayed:"
msgstr ""
"Тем не менее, если вместо этого произвести выборку из ``_vuser``, "
"отображаются данные пользователей, доступные пользователю 'guest':"

#: ../doc/1.10/book/box/box_space.rst:2323
msgid ""
"localhost:3301> box.space._vuser:select{}\n"
"---\n"
"- - [0, 1, 'guest', 'user', {}]\n"
"..."
msgstr ""
"localhost:3301> box.space._vuser:select{}\n"
"---\n"
"- - [0, 1, 'guest', 'user', {}]\n"
"..."

#: ../doc/1.10/book/box/box_space.rst:2332
msgid "``_vuser`` is a system view, so it allows only read requests."
msgstr ""
"``_vuser`` -- это виртуальное представление системы, поэтому допускаются "
"только запросы на чтение."

#: ../doc/1.10/book/box/box_space.rst:2333
msgid ""
"While the ``_user`` space requires proper access privileges, any user can"
" always read from ``_vuser``."
msgstr ""
"Если спейс ``_user`` требует наличия соответствующих прав доступа, то "
"любой пользователь всегда может выполнить чтение из ``_vuser``."

#: ../doc/1.10/book/box/box_space.rst:2340
msgid "Example: using data operations"
msgstr "Пример: использование операций с данными"

#: ../doc/1.10/book/box/box_space.rst:2342
msgid ""
"This example demonstrates all legal scenarios -- as well as typical "
"errors -- for each :ref:`data operation <index-box_data-operations>` in "
"Tarantool: :ref:`INSERT <box_space-operations-insert>`, :ref:`DELETE "
"<box_space-operations-delete>`, :ref:`UPDATE <box_space-operations-"
"update>`, :ref:`UPSERT <box_space-operations-upsert>`, :ref:`REPLACE "
"<box_space-operations-replace>`, and :ref:`SELECT <box_space-operations-"
"select>`."
msgstr ""
"Пример ниже иллюстрирует все возможные сценарии -- а также типичные "
"ошибки -- для всех :ref:`операций с данными <index-box_data-operations>` "
"в Tarantool'е: :ref:`INSERT <box_space-operations-insert>`, :ref:`DELETE "
"<box_space-operations-delete>`, :ref:`UPDATE <box_space-operations-"
"update>`, :ref:`UPSERT <box_space-operations-upsert>`, :ref:`REPLACE "
"<box_space-operations-replace>` и :ref:`SELECT <box_space-operations-"
"select>`."

#: ../doc/1.10/book/box/box_space.rst:2351
msgid ""
"-- Bootstrap the database --\n"
"box.cfg{}\n"
"format = {}\n"
"format[1] = {'field1', 'unsigned'}\n"
"format[2] = {'field2', 'unsigned'}\n"
"format[3] = {'field3', 'unsigned'}\n"
"s = box.schema.create_space('test', {format = format})\n"
"-- Create a primary index --\n"
"pk = s:create_index('pk', {parts = {{'field1'}}})\n"
"-- Create a unique secondary index --\n"
"sk_uniq = s:create_index('sk_uniq', {parts = {{'field2'}}})\n"
"-- Create a non-unique secondary index --\n"
"sk_non_uniq = s:create_index('sk_non_uniq', {parts = {{'field3'}}, unique"
" = false})"
msgstr ""
"-- Настройка базы данных --\n"
"box.cfg{}\n"
"format = {}\n"
"format[1] = {'field1', 'unsigned'}\n"
"format[2] = {'field2', 'unsigned'}\n"
"format[3] = {'field3', 'unsigned'}\n"
"s = box.schema.create_space('test', {format = format})\n"
"-- Создание первичного индекса --\n"
"pk = s:create_index('pk', {parts = {{'field1'}}})\n"
"-- Создание уникального вторичного индекса --\n"
"sk_uniq = s:create_index('sk_uniq', {parts = {{'field2'}}})\n"
"-- Создание неуникального вторичного индекса --\n"
"sk_non_uniq = s:create_index('sk_non_uniq', {parts = {{'field3'}}, unique"
" = false})"

#: ../doc/1.10/book/box/box_space.rst:2371
msgid "INSERT"
msgstr "INSERT"

#: ../doc/1.10/book/box/box_space.rst:2373
msgid ""
"``insert`` accepts a well-formatted tuple and checks all keys for "
"duplicates."
msgstr ""
"Операция ``insert`` (вставка) работает с кортежами с четким форматом и "
"проверяет все ключи на наличие совпадений."

#: ../doc/1.10/book/box/box_space.rst:2375
msgid ""
"tarantool> -- Unique indexes: ok --\n"
"tarantool> s:insert({1, 1, 1})\n"
"---\n"
"- [1, 1, 1]\n"
"...\n"
"tarantool> -- Conflicting primary key: error --\n"
"tarantool> s:insert({1, 1, 1})\n"
"---\n"
"- error: Duplicate key exists in unique index 'pk' in space 'test'\n"
"...\n"
"tarantool> -- Conflicting unique secondary key: error --\n"
"tarantool> s:insert({2, 1, 1})\n"
"---\n"
"- error: Duplicate key exists in unique index 'sk_uniq' in space 'test'\n"
"...\n"
"tarantool> -- Key {1} exists in sk_non_uniq index, but it is not unique: "
"ok --\n"
"tarantool> s:insert({2, 2, 1})\n"
"---\n"
"- [2, 2, 1]\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."
msgstr ""
"tarantool> -- Уникальные индексы: разрешено --\n"
"tarantool> s:insert({1, 1, 1})\n"
"---\n"
"- [1, 1, 1]\n"
"...\n"
"tarantool> -- Конфликт первичного ключа: ошибка --\n"
"tarantool> s:insert({1, 1, 1})\n"
"---\n"
"- error: Duplicate key exists in unique index 'pk' in space 'test'\n"
"...\n"
"tarantool> -- Конфликт уникального вторичного ключа: ошибка --\n"
"tarantool> s:insert({2, 1, 1})\n"
"---\n"
"- error: Duplicate key exists in unique index 'sk_uniq' in space 'test'\n"
"...\n"
"tarantool> -- Ключ {1} присутствует в индексе sk_non_uniq, но он не "
"уникален: разрешено --\n"
"tarantool> s:insert({2, 2, 1})\n"
"---\n"
"- [2, 2, 1]\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."

#: ../doc/1.10/book/box/box_space.rst:2405
#: ../doc/1.10/book/box/engines/vinyl.rst:139
msgid "DELETE"
msgstr "DELETE"

#: ../doc/1.10/book/box/box_space.rst:2407
msgid "``delete`` accepts a full key of any unique index."
msgstr ""
"``delete`` (удаление) работает с полными ключами любого уникального "
"индекса."

#: ../doc/1.10/book/box/box_space.rst:2409
msgid "``space:delete`` is an alias for \"delete by primary key\"."
msgstr ""
"``space:delete`` -- это псевдоним для операции \"удалить по первичному "
"ключу\"."

#: ../doc/1.10/book/box/box_space.rst:2411
msgid ""
"tarantool> -- Insert some test data --\n"
"tarantool> s:insert{3, 4, 5}\n"
"---\n"
"- [3, 4, 5]\n"
"...\n"
"tarantool> s:insert{6, 7, 8}\n"
"---\n"
"- [6, 7, 8]\n"
"...\n"
"tarantool> s:insert{9, 10, 11}\n"
"---\n"
"- [9, 10, 11]\n"
"...\n"
"tarantool> s:insert{12, 13, 14}\n"
"---\n"
"- [12, 13, 14]\n"
"...\n"
"tarantool> -- Nothing done here: no {4} key in pk index --\n"
"tarantool> s:delete{4}\n"
"---\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 4, 5]\n"
"  - [6, 7, 8]\n"
"  - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Delete by a primary key: ok --\n"
"tarantool> s:delete{3}\n"
"---\n"
"- [3, 4, 5]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [6, 7, 8]\n"
"  - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Explicitly delete by a primary key: ok --\n"
"tarantool> s.index.pk:delete{6}\n"
"---\n"
"- [6, 7, 8]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Delete by a unique secondary key: ok --\n"
"s.index.sk_uniq:delete{10}\n"
"---\n"
"- [9, 10, 11]\n"
"...\n"
"s:select{}\n"
"---\n"
"- - [12, 13, 14]\n"
"...\n"
"tarantool> -- Delete by a non-unique secondary index: error --\n"
"tarantool> s.index.sk_non_uniq:delete{14}\n"
"---\n"
"- error: Get() doesn't support partial keys and non-unique indexes\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [12, 13, 14]\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."
msgstr ""
"tarantool> -- Вставить некоторые тестовые данные --\n"
"tarantool> s:insert{3, 4, 5}\n"
"---\n"
"- [3, 4, 5]\n"
"...\n"
"tarantool> s:insert{6, 7, 8}\n"
"---\n"
"- [6, 7, 8]\n"
"...\n"
"tarantool> s:insert{9, 10, 11}\n"
"---\n"
"- [9, 10, 11]\n"
"...\n"
"tarantool> s:insert{12, 13, 14}\n"
"---\n"
"- [12, 13, 14]\n"
"...\n"
"tarantool> -- Здесь ничего не происходит: нет ключа {4} в индексе pk --\n"
"tarantool> s:delete{4}\n"
"---\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 4, 5]\n"
"  - [6, 7, 8]\n"
"  - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Удалить по первичному ключу: разрешено --\n"
"tarantool> s:delete{3}\n"
"---\n"
"- [3, 4, 5]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [6, 7, 8]\n"
"  - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Точно удалить по первичному ключу: разрешено --\n"
"tarantool> s.index.pk:delete{6}\n"
"---\n"
"- [6, 7, 8]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Удалить по уникальному вторичному ключу: разрешено --\n"
"s.index.sk_uniq:delete{10}\n"
"---\n"
"- [9, 10, 11]\n"
"...\n"
"s:select{}\n"
"---\n"
"- - [12, 13, 14]\n"
"...\n"
"tarantool> -- Удалить по неуникальному вторичному индексу: ошибка --\n"
"tarantool> s.index.sk_non_uniq:delete{14}\n"
"---\n"
"- error: Get() doesn't support partial keys and non-unique indexes\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [12, 13, 14]\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."

#: ../doc/1.10/book/box/box_space.rst:2484
msgid "The key must be full: ``delete`` cannot work with partial keys."
msgstr ""
"Ключ должен быть полным: операция ``delete`` не работает с компонентами "
"ключа."

#: ../doc/1.10/book/box/box_space.rst:2486
msgid ""
"tarantool> s2 = box.schema.create_space('test2')\n"
"---\n"
"...\n"
"tarantool> pk2 = s2:create_index('pk2', {parts = {{1, 'unsigned'}, {2, "
"'unsigned'}}})\n"
"---\n"
"...\n"
"tarantool> s2:insert{1, 1}\n"
"---\n"
"- [1, 1]\n"
"...\n"
"tarantool> -- Delete by a partial key: error --\n"
"tarantool> s2:delete{1}\n"
"---\n"
"- error: Invalid key part count in an exact match (expected 2, got 1)\n"
"...\n"
"tarantool> -- Delete by a full key: ok --\n"
"tarantool> s2:delete{1, 1}\n"
"---\n"
"- [1, 1]\n"
"...\n"
"tarantool> s2:select{}\n"
"---\n"
"- []\n"
"...\n"
"tarantool> s2:drop()\n"
"---\n"
"..."
msgstr ""
"tarantool> s2 = box.schema.create_space('test2')\n"
"---\n"
"...\n"
"tarantool> pk2 = s2:create_index('pk2', {parts = {{1, 'unsigned'}, {2, "
"'unsigned'}}})\n"
"---\n"
"...\n"
"tarantool> s2:insert{1, 1}\n"
"---\n"
"- [1, 1]\n"
"...\n"
"tarantool> -- Удалить по компоненту ключа: ошибка --\n"
"tarantool> s2:delete{1}\n"
"---\n"
"- error: Invalid key part count in an exact match (expected 2, got 1)\n"
"...\n"
"tarantool> -- Удалить по ключу целиком: разрешено --\n"
"tarantool> s2:delete{1, 1}\n"
"---\n"
"- [1, 1]\n"
"...\n"
"tarantool> s2:select{}\n"
"---\n"
"- []\n"
"...\n"
"tarantool> s2:drop()\n"
"---\n"
"..."

#: ../doc/1.10/book/box/box_space.rst:2520
msgid "UPDATE"
msgstr "UPDATE"

#: ../doc/1.10/book/box/box_space.rst:2522
msgid ""
"Similarly to ``delete``, ``update`` accepts a full key of any unique "
"index, and also the operations to execute."
msgstr ""
"Как и ``delete``, ``update`` работает с полными ключами любого "
"уникального индекса, а также выполняет операции."

#: ../doc/1.10/book/box/box_space.rst:2525
msgid "``space:update`` is an alias for \"update by primary key\"."
msgstr ""
"``space:update`` -- это псевдоним для операции \"обновить по первичному "
"ключу\"."

#: ../doc/1.10/book/box/box_space.rst:2527
msgid ""
"tarantool> -- Insert some test data --\n"
"tarantool> s:insert{3, 4, 5}\n"
"---\n"
"- [3, 4, 5]\n"
"...\n"
"tarantool> s:insert{6, 7, 8}\n"
"---\n"
"- [6, 7, 8]\n"
"...\n"
"tarantool> s:insert{9, 10, 11}\n"
"---\n"
"- [9, 10, 11]\n"
"...\n"
"tarantool> s:insert{12, 13, 14}\n"
"---\n"
"- [12, 13, 14]\n"
"...\n"
"tarantool> -- Nothing done here: no {4} key in pk index --\n"
"s:update({4}, {{'=', 2, 400}})\n"
"---\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 4, 5]\n"
"  - [6, 7, 8]\n"
"  - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Update by a primary key: ok --\n"
"tarantool> s:update({3}, {{'=', 2, 400}})\n"
"---\n"
"- [3, 400, 5]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 400, 5]\n"
"  - [6, 7, 8]\n"
"  - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Explicitly update by a primary key: ok --\n"
"tarantool> s.index.pk:update({6}, {{'=', 2, 700}})\n"
"---\n"
"- [6, 700, 8]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 400, 5]\n"
"  - [6, 700, 8]\n"
"  - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Update by a unique secondary key: ok --\n"
"tarantool> s.index.sk_uniq:update({10}, {{'=', 2, 1000}})\n"
"---\n"
"- [9, 1000, 11]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 400, 5]\n"
"  - [6, 700, 8]\n"
"  - [9, 1000, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Update by a non-unique secondary key: error --\n"
"tarantool> s.index.sk_non_uniq:update({14}, {{'=', 2, 1300}})\n"
"---\n"
"- error: Get() doesn't support partial keys and non-unique indexes\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 400, 5]\n"
"  - [6, 700, 8]\n"
"  - [9, 1000, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."
msgstr ""
"tarantool> -- Вставить некоторые тестовые данные --\n"
"tarantool> s:insert{3, 4, 5}\n"
"---\n"
"- [3, 4, 5]\n"
"...\n"
"tarantool> s:insert{6, 7, 8}\n"
"---\n"
"- [6, 7, 8]\n"
"...\n"
"tarantool> s:insert{9, 10, 11}\n"
"---\n"
"- [9, 10, 11]\n"
"...\n"
"tarantool> s:insert{12, 13, 14}\n"
"---\n"
"- [12, 13, 14]\n"
"...\n"
"tarantool> -- Здесь ничего не происходит: нет ключа {4} в индексе pk --\n"
"s:update({4}, {{'=', 2, 400}})\n"
"---\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 4, 5]\n"
"  - [6, 7, 8]\n"
"  - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Обновить по первичному ключу: разрешено --\n"
"tarantool> s:update({3}, {{'=', 2, 400}})\n"
"---\n"
"- [3, 400, 5]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 400, 5]\n"
"  - [6, 7, 8]\n"
"  - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Точно обновить по первичному ключу: разрешено --\n"
"tarantool> s.index.pk:update({6}, {{'=', 2, 700}})\n"
"---\n"
"- [6, 700, 8]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 400, 5]\n"
"  - [6, 700, 8]\n"
"  - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Обновить по уникальному вторичному ключу: разрешено --\n"
"tarantool> s.index.sk_uniq:update({10}, {{'=', 2, 1000}})\n"
"---\n"
"- [9, 1000, 11]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 400, 5]\n"
"  - [6, 700, 8]\n"
"  - [9, 1000, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Обновить по неуникальному вторичному ключу: ошибка --\n"
"tarantool> s.index.sk_non_uniq:update({14}, {{'=', 2, 1300}})\n"
"---\n"
"- error: Get() doesn't support partial keys and non-unique indexes\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 400, 5]\n"
"  - [6, 700, 8]\n"
"  - [9, 1000, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."

#: ../doc/1.10/book/box/box_space.rst:2613
#: ../doc/1.10/book/box/engines/vinyl.rst:140
msgid "UPSERT"
msgstr "UPSERT"

#: ../doc/1.10/book/box/box_space.rst:2615
msgid "``upsert`` accepts a well-formatted tuple and update operations."
msgstr ""
"``upsert`` (обновление и вставка) работает с кортежами с четким форматом "
"и выполняет операции обновления."

#: ../doc/1.10/book/box/box_space.rst:2617
msgid ""
"If an old tuple is found by the primary key of the specified tuple, then "
"the update operations are applied to the old tuple, and the new tuple is "
"ignored."
msgstr ""
"Если найден старый кортеж по первичному ключу, то операции обновления "
"применяются к старому кортежу, а новый кортеж игнорируется."

#: ../doc/1.10/book/box/box_space.rst:2621
msgid ""
"If no old tuple is found, then the new tuple is inserted, and the update "
"operations are **ignored**."
msgstr ""
"Если старый кортеж не найден, то происходит вставка нового кортежа, а "
"операции обновления **игнорируются**."

#: ../doc/1.10/book/box/box_space.rst:2624
msgid "Indexes have no ``upsert`` method - this is a method of a space."
msgstr "Для индексов нет метода ``upsert`` -- это метод для спейса."

#: ../doc/1.10/book/box/box_space.rst:2626
msgid ""
"tarantool> s.index.pk.upsert == nil\n"
"---\n"
"- true\n"
"...\n"
"tarantool> s.index.sk_uniq.upsert == nil\n"
"---\n"
"- true\n"
"...\n"
"tarantool> s.upsert ~= nil\n"
"---\n"
"- true\n"
"...\n"
"tarantool> -- As the first argument, upsert accepts --\n"
"tarantool> -- a well-formatted tuple, NOT a key! --\n"
"tarantool> s:insert{1, 2, 3}\n"
"---\n"
"- [1, 2, 3]\n"
"...\n"
"tarantool> s:upsert({1}, {{'=', 2, 200}})\n"
"---\n"
"- error: Tuple field count 1 is less than required by space format or "
"defined indexes\n"
"    (expected at least 3)\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 2, 3]\n"
"...\n"
"tarantool> s:delete{1}\n"
"---\n"
"- [1, 2, 3]\n"
"..."
msgstr ""
"tarantool> s.index.pk.upsert == nil\n"
"---\n"
"- true\n"
"...\n"
"tarantool> s.index.sk_uniq.upsert == nil\n"
"---\n"
"- true\n"
"...\n"
"tarantool> s.upsert ~= nil\n"
"---\n"
"- true\n"
"...\n"
"tarantool> -- В качестве первого аргумента upsert принимает --\n"
"tarantool> -- кортеж с четким форматом, НЕ ключ! --\n"
"tarantool> s:insert{1, 2, 3}\n"
"---\n"
"- [1, 2, 3]\n"
"...\n"
"tarantool> s:upsert({1}, {{'=', 2, 200}})\n"
"---\n"
"- error: Tuple field count 1 is less than required by space format or "
"defined indexes\n"
"    (expected at least 3)\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 2, 3]\n"
"...\n"
"tarantool> s:delete{1}\n"
"---\n"
"- [1, 2, 3]\n"
"..."

#: ../doc/1.10/book/box/box_space.rst:2660
msgid ""
"``upsert`` turns into ``insert`` when no old tuple is found by the "
"primary key."
msgstr ""
"``upsert`` превращается в ``insert``, когда старый кортеж не найден по "
"первичному ключу."

#: ../doc/1.10/book/box/box_space.rst:2662
msgid ""
"tarantool> s:upsert({1, 2, 3}, {{'=', 2, 200}})\n"
"---\n"
"...\n"
"tarantool> -- As you can see, {1, 2, 3} were inserted, --\n"
"tarantool> -- and the update operations were not applied. --\n"
"s:select{}\n"
"---\n"
"- - [1, 2, 3]\n"
"...\n"
"tarantool> -- Performing another upsert with the same primary key, --\n"
"tarantool> -- but different values in the other fields. --\n"
"s:upsert({1, 20, 30}, {{'=', 2, 200}})\n"
"---\n"
"...\n"
"tarantool> -- The old tuple was found by the primary key {1} --\n"
"tarantool> -- and update operations were applied. --\n"
"tarantool> -- The new tuple was ignored. --\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 200, 3]\n"
"..."
msgstr ""
"tarantool> s:upsert({1, 2, 3}, {{'=', 2, 200}})\n"
"---\n"
"...\n"
"tarantool> -- Как можно увидеть, произошла вставка {1, 2, 3}, --\n"
"tarantool> -- а операции обновления не применились. --\n"
"s:select{}\n"
"---\n"
"- - [1, 2, 3]\n"
"...\n"
"tarantool> -- Еще одна операция upsert с тем же первичным ключом, --\n"
"tarantool> -- но другими значениями прочих полей. --\n"
"s:upsert({1, 20, 30}, {{'=', 2, 200}})\n"
"---\n"
"...\n"
"tarantool> -- Старый кортеж был найден по первичному ключу {1}, --\n"
"tarantool> -- и применились операции обновления. --\n"
"tarantool> -- Новый кортеж игнорируется. --\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 200, 3]\n"
"..."

#: ../doc/1.10/book/box/box_space.rst:2686
msgid ""
"``upsert`` searches for an old tuple by the primary index, NOT by a "
"secondary index. This can lead to a duplication error if the new tuple "
"ruins the uniqueness of a secondary index."
msgstr ""
"``upsert`` ищет старый кортеж по первичному индексу, НЕ по вторичному. "
"Это может привести к ошибкам с дубликатами, если новый кортеж нарушает "
"уникальность вторичного индекса."

#: ../doc/1.10/book/box/box_space.rst:2690
msgid ""
"tarantool> s:upsert({2, 200, 3}, {{'=', 3, 300}})\n"
"---\n"
"- error: Duplicate key exists in unique index 'sk_uniq' in space 'test'\n"
"...\n"
"s:select{}\n"
"---\n"
"- - [1, 200, 3]\n"
"...\n"
"tarantool> -- But this works, when uniqueness is preserved. --\n"
"tarantool> s:upsert({2, 0, 0}, {{'=', 3, 300}})\n"
"---\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 200, 3]\n"
"  - [2, 0, 0]\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."
msgstr ""
"tarantool> s:upsert({2, 200, 3}, {{'=', 3, 300}})\n"
"---\n"
"- error: Duplicate key exists in unique index 'sk_uniq' in space 'test'\n"
"...\n"
"s:select{}\n"
"---\n"
"- - [1, 200, 3]\n"
"...\n"
"tarantool> -- Но сработает, если сохраняется уникальность. --\n"
"tarantool> s:upsert({2, 0, 0}, {{'=', 3, 300}})\n"
"---\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 200, 3]\n"
"  - [2, 0, 0]\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."

#: ../doc/1.10/book/box/box_space.rst:2717
#: ../doc/1.10/book/box/engines/vinyl.rst:138
msgid "REPLACE"
msgstr "REPLACE"

#: ../doc/1.10/book/box/box_space.rst:2719
msgid ""
"``replace`` accepts a well-formatted tuple and searches for an old tuple "
"by the primary key of the new tuple."
msgstr ""
"``replace`` (замена) работает с кортежами с четким форматом и ищет старый"
" кортеж по первичному ключу нового кортежа."

#: ../doc/1.10/book/box/box_space.rst:2722
msgid ""
"If the old tuple is found, then it is deleted, and the new tuple is "
"inserted."
msgstr ""
"Если найден старый кортеж, то происходит удаление старого кортежа и "
"вставка нового."

#: ../doc/1.10/book/box/box_space.rst:2724
msgid "If the old tuple was not found, then just the new tuple is inserted."
msgstr "Если старый кортеж не найден, вставляется новый кортеж."

#: ../doc/1.10/book/box/box_space.rst:2726
msgid ""
"tarantool> s:replace{1, 2, 3}\n"
"---\n"
"- [1, 2, 3]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 2, 3]\n"
"...\n"
"tarantool> s:replace{1, 3, 4}\n"
"---\n"
"- [1, 3, 4]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 3, 4]\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."
msgstr ""
"tarantool> s:replace{1, 2, 3}\n"
"---\n"
"- [1, 2, 3]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 2, 3]\n"
"...\n"
"tarantool> s:replace{1, 3, 4}\n"
"---\n"
"- [1, 3, 4]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 3, 4]\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."

#: ../doc/1.10/book/box/box_space.rst:2748
msgid "``replace`` can ruin unique constraints, like ``upsert`` does."
msgstr "Как и ``upsert``, ``replace`` может нарушить требования уникальности."

#: ../doc/1.10/book/box/box_space.rst:2750
msgid ""
"tarantool> s:insert{1, 1, 1}\n"
"---\n"
"- [1, 1, 1]\n"
"...\n"
"tarantool> s:insert{2, 2, 2}\n"
"---\n"
"- [2, 2, 2]\n"
"...\n"
"tarantool> -- This replace fails, because if the new tuple {1, 2, 0} "
"replaces --\n"
"tarantool> -- the old tuple by the primary key from 'pk' index {1, 1, 1},"
" --\n"
"tarantool> -- this results in a duplicate unique secondary key in "
"'sk_uniq' index: --\n"
"tarantool> -- key {2} is used both in the new tuple and in {2, 2, 2}. --\n"
"tarantool> s:replace{1, 2, 0}\n"
"---\n"
"- error: Duplicate key exists in unique index 'sk_uniq' in space 'test'\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."
msgstr ""
"tarantool> s:insert{1, 1, 1}\n"
"---\n"
"- [1, 1, 1]\n"
"...\n"
"tarantool> s:insert{2, 2, 2}\n"
"---\n"
"- [2, 2, 2]\n"
"...\n"
"tarantool> -- Такая замена не сработает, поскольку замена новым кортежем "
"{1, 2, 0} --\n"
"tarantool> -- старого кортежа по первичному ключу из индекса 'pk' {1, 1, "
"1}, --\n"
"tarantool> -- приведет к созданию дубликата уникального вторичного ключа "
"в индексе 'sk_uniq': --\n"
"tarantool> -- ключ {2} используется и в новом кортеже, и в {2, 2, 2}. --\n"
"tarantool> s:replace{1, 2, 0}\n"
"---\n"
"- error: Duplicate key exists in unique index 'sk_uniq' in space 'test'\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."

#: ../doc/1.10/book/box/box_space.rst:2776
msgid "SELECT"
msgstr "SELECT"

#: ../doc/1.10/book/box/box_space.rst:2778
msgid ""
"``select`` works with any indexes (primary/secondary) and with any keys "
"(unique/non-unique, full/partial)."
msgstr ""
"``select`` (выборка) работает с любыми индексами (первичными/вторичными) "
"и с любыми ключами (уникальными/неуникальными, полными/компонентами)."

#: ../doc/1.10/book/box/box_space.rst:2781
msgid ""
"If a key is partial, then ``select`` searches by all keys, where the "
"prefix matches the specified key part."
msgstr ""
"Если задан компонент ключа, ``select`` выполняет поиск всех ключей, "
"префикс которых совпадает с указанным компонентом ключа."

#: ../doc/1.10/book/box/box_space.rst:2784
msgid ""
"tarantool> s:insert{1, 2, 3}\n"
"---\n"
"- [1, 2, 3]\n"
"...\n"
"tarantool> s:insert{4, 5, 6}\n"
"---\n"
"- [4, 5, 6]\n"
"...\n"
"tarantool> s:insert{7, 8, 9}\n"
"---\n"
"- [7, 8, 9]\n"
"...\n"
"tarantool> s:insert{10, 11, 9}\n"
"---\n"
"- [10, 11, 9]\n"
"...\n"
"tarantool> s:select{1}\n"
"---\n"
"- - [1, 2, 3]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 2, 3]\n"
"  - [4, 5, 6]\n"
"  - [7, 8, 9]\n"
"  - [10, 11, 9]\n"
"...\n"
"tarantool> s.index.pk:select{4}\n"
"---\n"
"- - [4, 5, 6]\n"
"...\n"
"tarantool> s.index.sk_uniq:select{8}\n"
"---\n"
"- - [7, 8, 9]\n"
"...\n"
"tarantool> s.index.sk_non_uniq:select{9}\n"
"---\n"
"- - [7, 8, 9]\n"
"  - [10, 11, 9]\n"
"..."
msgstr ""
"tarantool> s:insert{1, 2, 3}\n"
"---\n"
"- [1, 2, 3]\n"
"...\n"
"tarantool> s:insert{4, 5, 6}\n"
"---\n"
"- [4, 5, 6]\n"
"...\n"
"tarantool> s:insert{7, 8, 9}\n"
"---\n"
"- [7, 8, 9]\n"
"...\n"
"tarantool> s:insert{10, 11, 9}\n"
"---\n"
"- [10, 11, 9]\n"
"...\n"
"tarantool> s:select{1}\n"
"---\n"
"- - [1, 2, 3]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 2, 3]\n"
"  - [4, 5, 6]\n"
"  - [7, 8, 9]\n"
"  - [10, 11, 9]\n"
"...\n"
"tarantool> s.index.pk:select{4}\n"
"---\n"
"- - [4, 5, 6]\n"
"...\n"
"tarantool> s.index.sk_uniq:select{8}\n"
"---\n"
"- - [7, 8, 9]\n"
"...\n"
"tarantool> s.index.sk_non_uniq:select{9}\n"
"---\n"
"- - [7, 8, 9]\n"
"  - [10, 11, 9]\n"
"..."

#: ../doc/1.10/book/box/box_stat.rst:39
msgid "Submodule `box.stat`"
msgstr "Вложенный модуль `box.stat`"

#: ../doc/1.10/book/box/box_stat.rst:41
msgid ""
"The ``box.stat`` submodule provides access to request and network "
"statistics."
msgstr ""
"Вложенный модуль ``box.stat`` предоставляет доступ к статистике "
"Tarantool'а по запросам и использованию сети."

#: ../doc/1.10/book/box/box_stat.rst:43
msgid ""
"Use ``box.stat()`` to show the average number of requests per second, and"
" the total number of requests since startup, broken down by request type."
msgstr ""
"Используйте ``box.stat()``, чтобы узнать среднее количество запросов в "
"секунду и общее количество запросов с момента запуска с разбивкой по типу"
" запроса."

#: ../doc/1.10/book/box/box_stat.rst:46
msgid ""
"Use ``box.stat.net()``  to see network activity: the number of packets "
"sent and received, and the average number of requests per second."
msgstr ""
"Используйте ``box.stat()``, чтобы просмотреть статистику сетевой "
"активности: количество отправленных и полученных пакетов, а также общее "
"количество запросов в секунду."

#: ../doc/1.10/book/box/box_stat.rst:51
msgid ""
"Use ``box.stat.vinyl()`` to see vinyl-storage-engine activity, for "
"example ``box.stat.vinyl().tx`` has the number of commits and rollbacks. "
"See details at :ref:`the end of this section <box_introspection-"
"box_stat_vinyl_details>`."
msgstr ""
"Используйте ``box.stat.vinyl()``, чтобы просмотреть данные по работе "
"движка базы данных vinyl, например: ``box.stat.vinyl().tx`` содержит "
"количество коммитов и откатов. Более подробную информацию см. в "
":ref:`конце раздела <box_introspection-box_stat_vinyl_details>`."

#: ../doc/1.10/book/box/box_stat.rst:57
msgid ""
"Use ``box.stat.reset()`` to reset the statistics of ``box.stat()``, "
"``box.stat.net()``, ``box.stat.vinyl()`` and :ref:`box.space.index "
"<box_space-space_index>`."
msgstr ""
"Используйте ``box.stat.reset()``, чтобы сбросить статистику "
"``box.stat()``, ``box.stat.net()``, ``box.stat.vinyl()`` и "
":ref:`box.space.index <box_space-space_index>`."

#: ../doc/1.10/book/box/box_stat.rst:61
#, fuzzy
msgid ""
"In the tables that ``box.stat()`` and ``box.stat.net()`` return: ``rps`` "
"stands for \"[average number of] requests per second [in the last 5 "
"seconds]\", ``total`` stands for \"total [number processed since the "
"server began]\", ``current`` stands for \"[number of] current [requests "
"in progress, which can be limited by :ref:`box.cfg.net_msg_max "
"<cfg_networking-net_msg_max>`]\". \"ERROR\" is the count of requests that"
" resulted in an error."
msgstr ""
"В таблицах, которые возвращают ``box.stat()`` и ``box.stat.net()``: "
"``rps`` означает \"[среднее количество] запросы в секунду [за последние 5"
" секунд]\", ``total`` означает \"всего [количество запросов, обработанных"
" с момента запуска сервера]\", ``current`` означает \"[количество "
"запросов] в ходе выполнения [которое можно ограничить с помощью "
":ref:`box.cfg.net_msg_max <cfg_networking-net_msg_max>`]\"."

#: ../doc/1.10/book/box/box_stat.rst:68
msgid ""
"tarantool> box.stat() -- return 10 tables\n"
"---\n"
"- DELETE:\n"
"    total: 1873949\n"
"    rps: 123\n"
"  SELECT:\n"
"    total: 1237723\n"
"    rps: 4099\n"
"  INSERT:\n"
"    total: 0\n"
"    rps: 0\n"
"  EVAL:\n"
"    total: 0\n"
"    rps: 0\n"
"  CALL:\n"
"    total: 0\n"
"    rps: 0\n"
"  REPLACE:\n"
"    total: 1239123\n"
"    rps: 7849\n"
"  UPSERT:\n"
"    total: 0\n"
"    rps: 0\n"
"  AUTH:\n"
"    total: 0\n"
"    rps: 0\n"
"  ERROR:\n"
"    total: 0\n"
"    rps: 0\n"
"  UPDATE:\n"
"    total: 0\n"
"    rps: 0\n"
"...\n"
"tarantool> box.stat().DELETE -- total + requests per second from one "
"table\n"
"---\n"
"- total: 0\n"
"  rps: 0\n"
"...\n"
"tarantool> box.stat.net() -- 4 tables\n"
"---\n"
"- SENT:\n"
"    total: 0\n"
"    rps: 0\n"
"  CONNECTIONS:\n"
"    current: 0\n"
"    rps: 0\n"
"    total: 0\n"
"  REQUESTS:\n"
"    current: 0\n"
"    rps: 0\n"
"    total: 0\n"
"  RECEIVED:\n"
"    total: 0\n"
"    rps: 0\n"
"...\n"
"tarantool> box.stat.vinyl().tx.commit -- one item of the vinyl table\n"
"---\n"
"- 1047632\n"
"..."
msgstr ""
"tarantool> box.stat() -- вернуть 10 таблиц\n"
"---\n"
"- DELETE:\n"
"    total: 1873949\n"
"    rps: 123\n"
"  SELECT:\n"
"    total: 1237723\n"
"    rps: 4099\n"
"  INSERT:\n"
"    total: 0\n"
"    rps: 0\n"
"  EVAL:\n"
"    total: 0\n"
"    rps: 0\n"
"  CALL:\n"
"    total: 0\n"
"    rps: 0\n"
"  REPLACE:\n"
"    total: 1239123\n"
"    rps: 7849\n"
"  UPSERT:\n"
"    total: 0\n"
"    rps: 0\n"
"  AUTH:\n"
"    total: 0\n"
"    rps: 0\n"
"  ERROR:\n"
"    total: 0\n"
"    rps: 0\n"
"  UPDATE:\n"
"    total: 0\n"
"    rps: 0\n"
"...\n"
"tarantool> box.stat().DELETE -- всего + запросов в секунду из одной "
"таблицы\n"
"---\n"
"- total: 0\n"
"  rps: 0\n"
"...\n"
"tarantool> box.stat.net() -- 4 таблицы\n"
"---\n"
"- SENT:\n"
"    total: 0\n"
"    rps: 0\n"
"  CONNECTIONS:\n"
"    current: 0\n"
"    rps: 0\n"
"    total: 0\n"
"  REQUESTS:\n"
"    current: 0\n"
"    rps: 0\n"
"    total: 0\n"
"  RECEIVED:\n"
"    total: 0\n"
"    rps: 0\n"
"...\n"
"tarantool> box.stat.vinyl().tx.commit -- один пункт из таблицы vinyl\n"
"---\n"
"- 1047632\n"
"..."

#: ../doc/1.10/book/box/box_stat.rst:132
msgid "Here are details about the ``box.stat.vinyl()`` items."
msgstr "Ниже приводится подробная информация о пунктах в ``box.stat.vinyl()``."

#: ../doc/1.10/book/box/box_stat.rst:136
msgid ""
"**Details about box.stat.vinyl().regulator:** The vinyl regulator decides"
" when to take or delay actions for disk IO, grouping activity in batches "
"so that it is consistent and efficient. The regulator is invoked by the "
"vinyl scheduler, once per second, and updates related variables whenever "
"it is invoked."
msgstr ""
"**Подробная информация о box.stat.vinyl().regulator:** Регулятор vinyl'а "
"определяет, когда следует предпринимать или отложить действия по "
"дисковому вводу-выводу, путем группировки действий в пакеты так, чтобы "
"обеспечить согласованность и эффективность. Регулятор вызывается "
"планировщиком vinyl'а раз в секунду и обновляет соответствующие "
"переменные при каждом вызове."

#: ../doc/1.10/book/box/box_stat.rst:143
msgid ""
"``box.stat.vinyl().regulator.dump_bandwidth`` is the estimated average "
"rate at which dumps are done. Initially this will appear as 10485760 (10 "
"megabytes per second). Only significant dumps (larger than one megabyte) "
"are used for estimating."
msgstr ""
"``box.stat.vinyl().regulator.dump_bandwidth`` представляет собой "
"предполагаемую среднюю скорость создания дампов. Изначально она "
"составляет 10 485 760 (10 мегабайтов в секунду). Только значительные "
"дампы (более одного мегабайта) используются при оценке."

#: ../doc/1.10/book/box/box_stat.rst:148
msgid ""
"``box.stat.vinyl().regulator.dump_watermark`` is the point when dumping "
"must occur. The value is slightly smaller than the amount of memory that "
"is allocated for vinyl trees, which is the :ref:`vinyl_memory "
"<cfg_storage-vinyl_memory>` parameter."
msgstr ""
"``box.stat.vinyl().regulator.dump_watermark`` -- это точка, когда должно "
"произойти создание дампа. Это значение несколько меньше объема памяти, "
"выделенного для деревьев в vinyl'е, которое указано в параметре "
":ref:`vinyl_memory <cfg_storage-vinyl_memory>`."

#: ../doc/1.10/book/box/box_stat.rst:154
msgid ""
"``box.stat.vinyl().regulator.write_rate`` is the actual average rate at "
"which recent writes to disk are done. Averaging is done over a 5-second "
"time window, so if there has been no activity for 5 seconds then "
"``regulator.write_rate = 0``. The ``write_rate`` may be slowed when a "
"dump is in progress or when the user has set :ref:`snap_io_rate_limit "
"<cfg_binary_logging_snapshots-snap_io_rate_limit>`."
msgstr ""
"``box.stat.vinyl().regulator.write_rate`` представляет собой "
"действительную среднюю скорость записи последних данных на диск. Средняя "
"скорость вычисляется в течение 5-секундного интервала, поэтому если за "
"последние 5 секунд ничего не происходило, то ``regulator.write_rate = "
"0``. Скорость ``write_rate`` может замедлиться во время создания дампа, "
"или если пользователь задал предел :ref:`snap_io_rate_limit "
"<cfg_binary_logging_snapshots-snap_io_rate_limit>`."

#: ../doc/1.10/book/box/box_stat.rst:162
msgid ""
"``box.stat.vinyl().regulator.rate_limit`` is the write rate limit, in "
"bytes per second, imposed on transactions by the regulator based on the "
"observed dump/compaction performance."
msgstr ""
"``box.stat.vinyl().regulator.rate_limit`` -- это предел скорости записи в"
" байтах в секунду, который налагается регулятором на основании "
"установленной производительности создания дампов / слияния."

#: ../doc/1.10/book/box/box_stat.rst:168
msgid ""
"**Details about box.stat.vinyl().disk:** Since vinyl is an on-disk "
"storage engine (unlike memtx which is an in-memory storage engine), it "
"can handle large databases -- but if a database is larger than the amount"
" of memory that is allocated for vinyl, then there will be more disk "
"activity."
msgstr ""
"**Подробная информация о box.stat.vinyl().disk:** Поскольку vinyl "
"является дисковым движком базы данных (в отличие от memtx'а, который "
"представляет собой in-memory движок), он может обрабатывать большие базы "
"данных -- однако если база данных больше объема памяти, выделенного для "
"vinyl'а, дисковых операций будет больше."

#: ../doc/1.10/book/box/box_stat.rst:175
msgid ""
"``box.stat.vinyl().disk.data`` and ``box.stat.vinyl().disk.index`` are "
"the amount of data that has gone into files in a subdirectory of "
":ref:`vinyl_dir <cfg_basic-vinyl_dir>`, with names like ``{lsn}.run`` and"
" ``{lsn}.index``. The size of the run will be related to the output of "
"``scheduler.dump_*``."
msgstr ""
"``box.stat.vinyl().disk.data`` и ``box.stat.vinyl().disk.index`` содержат"
" объем данных, который поступил в файлы во вложенной директории "
":ref:`vinyl_dir <cfg_basic-vinyl_dir>` с именами вида ``{lsn}.run`` и "
"``{lsn}.index``. Размер файла run зависит от вывода ``scheduler.dump_*``."

#: ../doc/1.10/book/box/box_stat.rst:182
msgid ""
"``box.stat.vinyl().disk.data_compacted`` Sum size of data stored at the "
"last LSM tree level, in bytes, without taking disk compression into "
"account. It can be thought of as the size of disk space that the user "
"data would occupy if there were no compression, indexing, or space "
"increase caused by the LSM tree design."
msgstr ""
"``box.stat.vinyl().disk.data_compacted`` представляет собой общий размер "
"данных, которые хранятся на последнем уровне LSM-дерева, в байтах. При "
"этом не учитывается сжатие диска. Его можно рассматривать как размер "
"места на диске, которое заняли бы пользовательские данные, если бы не "
"было компрессии, индексирования или увеличения спейса, вызванного "
"конструкцией LSM-дерева."

#: ../doc/1.10/book/box/box_stat.rst:190
msgid ""
"**Details about box.stat.vinyl().memory:** Although the vinyl storage "
"engine is not \"in-memory\", Tarantool does need to have memory for write"
" buffers and for caches:"
msgstr ""
"**Подробная информация о box.stat.vinyl().memory:** Хотя движок базы "
"данных vinyl не является \"in-memory\", Tarantool'у всё же требуется "
"память для записи буфера и для кэша:"

#: ../doc/1.10/book/box/box_stat.rst:194
msgid ""
"``box.stat.vinyl().memory.tuple_cache`` is the number of bytes that are "
"being used for tuples (data)."
msgstr ""
"``box.stat.vinyl().memory.tuple_cache`` содержит количество байтов, "
"используемых для кортежей (данные)."

#: ../doc/1.10/book/box/box_stat.rst:196
msgid ""
"``box.stat.vinyl().memory.tx`` is transactional memory. This will usually"
" be 0."
msgstr ""
"``box.stat.vinyl().memory.tx`` -- это транзакционная память, как правило,"
" равная 0."

#: ../doc/1.10/book/box/box_stat.rst:198
msgid ""
"``box.stat.vinyl().memory.level0`` is the \"level0\" memory area, "
"sometimes abbreviated \"L0\", which is the area that vinyl can use for "
"in-memory storage of an LSM tree."
msgstr ""
"``box.stat.vinyl().memory.level0`` -- это объем памяти уровня 0 "
"\"level0\", который иногда сокращается до \"L0\" и представляет собой "
"область, которую vinyl может использовать для хранения данных в "
"оперативной памяти в LSM-дереве."

#: ../doc/1.10/book/box/box_stat.rst:202
msgid ""
"Therefore we can say that \"L0 is becoming full\" when the amount in "
"``memory.level0`` is close to the maximum, which is "
":ref:`regulator.dump_watermark <box_introspection-"
"box_stat_vinyl_regulator>`. We can expect that \"L0 = 0\" immediately "
"after a dump. ``box.stat.vinyl().memory.page_index`` and  "
"``box.stat.vinyl().memory.bloom_filter`` have the current amount being "
"used for index-related structures. The size is a function of the number "
"and size of keys, plus :ref:`page_size <cfg_storage-vinyl_page_size>`, "
"plus :ref:`bloom_fpr <cfg_storage-vinyl_bloom_fpr>`. This is not a count "
"of bloom filter \"hits\" (the number of reads that could be avoided "
"because the bloom filter predicts their presence in a run file) -- that "
"statistic can be found with :ref:`index_object:stat() <box_index-stat>`."
msgstr ""
"Таким образом, можно сказать, что \"L0 заполняется\", когда объем данных "
"в ``memory.level0`` приближается к максимальному, а именно "
":ref:`regulator.dump_watermark <box_introspection-"
"box_stat_vinyl_regulator>`. Можно ожидать, что \"L0 = 0\" сразу после "
"создания дампа. Текущий объем в ``box.stat.vinyl().memory.page_index`` и"
"  ``box.stat.vinyl().memory.bloom_filter`` используется для структур, "
"связанных с индексами. Размер -- это количество и размер ключей плюс "
":ref:`page_size <cfg_storage-vinyl_page_size>` плюс :ref:`bloom_fpr "
"<cfg_storage-vinyl_bloom_fpr>`. Это не счетчик совпадений по фильтру "
"Блума (количество чтений, которых можно избежать, поскольку фильтра Блума"
" предсказывает их наличие в файле типа run) -- эта статистика указана в "
":ref:`index_object:stat() <box_index-stat>`."

#: ../doc/1.10/book/box/box_stat.rst:219
msgid ""
"**Details about box.stat.vinyl().tx:** This is about requests that affect"
" transactional activity (\"tx\" is used here as an abbreviation for "
"\"transaction\"):"
msgstr ""
"**Подробная информация о box.stat.vinyl().tx:** Информация о запросах, "
"которые влияют на операции транзакций (\"tx\" используется в качестве "
"сокращения слова \"транзакция\"):"

#: ../doc/1.10/book/box/box_stat.rst:223
msgid ""
"``box.stat.vinyl().tx.conflict`` counts conflicts that caused a "
"transaction to roll back."
msgstr ""
"``box.stat.vinyl().tx.conflict`` содержит счетчик конфликтов, которые "
"вызвали откат транзакции."

#: ../doc/1.10/book/box/box_stat.rst:225
msgid ""
"``box.stat.vinyl().tx.commit`` is the count of commits (successful "
"transaction ends). It includes implicit commits, for example any insert "
"causes a commit unless it is within a begin-end block."
msgstr ""
"``box.stat.vinyl().tx.commit`` -- это счетчик коммитов (успешно "
"завершенных транзакций). Он включает в себя неявные коммиты, например, "
"любая вставка вызывает коммит, если она не входит в блок begin-end."

#: ../doc/1.10/book/box/box_stat.rst:229
msgid ""
"``box.stat.vinyl().tx.rollback`` is the count of rollbacks (unsuccessful "
"transaction ends). This is not merely a count of explicit "
":ref:`box.rollback <box-rollback>` requests -- it includes requests that "
"ended in errors. For example, after an attempted insert request that "
"causes a \"Duplicate key exists in unique index\" error, ``tx.rollback`` "
"is incremented."
msgstr ""
"``box.stat.vinyl().tx.rollback`` -- это счетчик откатов (невыполненные "
"транзакции). Это не просто счетчик явных запросов :ref:`box.rollback "
"<box-rollback>`, он также включает в себя запросы, которые привели к "
"ошибке. Например, после попытки вставки, в результате которой была "
"выведена ошибка наличия дубликата ключа \"Duplicate key exists in unique "
"index\", значение счетчика ``tx.rollback`` увеличивается."

#: ../doc/1.10/book/box/box_stat.rst:237
msgid "``box.stat.vinyl().tx.statements`` will usually be 0."
msgstr "``box.stat.vinyl().tx.statements``, как правило, будет равен 0."

#: ../doc/1.10/book/box/box_stat.rst:239
msgid ""
"``box.stat.vinyl().tx.transactions`` is the number of transactions that "
"are currently running."
msgstr ""
"``box.stat.vinyl().tx.transactions`` содержит количество текущих "
"транзакций."

#: ../doc/1.10/book/box/box_stat.rst:241
msgid ""
"``box.stat.vinyl().tx.gap_locks`` is the number of gap locks that are "
"outstanding during execution of a request. For a low-level description of"
" Tarantool's implementation of gap locking, see `Gap locks in Vinyl "
"transaction manager "
"<https://github.com/tarantool/tarantool/issues/2671>`_."
msgstr ""
"``box.stat.vinyl().tx.gap_locks`` представляет собой число блокировок "
"разрывов во время выполнения запроса. Чтобы получить низкоуровневое "
"описание имплементации блокировки разрывов в Tarantool'е, см. `Блокировка"
" разрывов в менеджере транзакций Vinyl'а "
"<https://github.com/tarantool/tarantool/issues/2671>`_."

#: ../doc/1.10/book/box/box_stat.rst:245
msgid ""
"``box.stat.vinyl().tx.read_views`` shows whether a transaction has "
"entered a read-only state to avoid conflict temporarily. This will "
"usually be 0."
msgstr ""
"``box.stat.vinyl().tx.read_views`` показывает, получила ли транзакция "
"статус только для чтения, во избежание временного конфликта. Как правило,"
" 0."

#: ../doc/1.10/book/box/box_stat.rst:249
msgid ""
"**Details about box.stat.vinyl().scheduler:** This primarily has counters"
" related to tasks that the scheduler has arranged for dumping or "
"compaction: (most of these items are reset to 0 when the server restarts "
"or when :ref:`box.stat.reset() <box_introspection-box_stat_reset>` "
"occurs):"
msgstr ""
"**Подробная информация о box.stat.vinyl().scheduler:** В основном "
"содержит счетчики, связанные с задачами планировщика по созданию дампов "
"или слиянию: (большинство сбрасываются на 0 при перезапуске сервера или "
"вызове :ref:`box.stat.reset() <box_introspection-box_stat_reset>`):"

#: ../doc/1.10/book/box/box_stat.rst:255
msgid ""
"``box.stat.vinyl().scheduler.compaction_*`` is the amount of data from "
"recent changes that has been :ref:`compacted <box_index-compact>`. This "
"is divided into ``scheduler.compaction_input`` (the amount that is being "
"compacted), ``scheduler.compaction_queue`` (the amount that is waiting to"
" be compacted), ``scheduler.compaction_time`` (total time spent by all "
"worker threads performing compaction, in seconds), and "
"``scheduler.compaction_output`` (the amount that has been compacted, "
"which is presumably smaller than ``scheduler.compaction_input``)."
msgstr ""
"``box.stat.vinyl().scheduler.compaction_*`` содержит объем данных из "
"последних изменений, для которых было произведено :ref:`слияние "
"<box_index-compact>`. Он подразделяется на ``scheduler.compaction_input``"
" (объем данных текущего слияния), ``scheduler.compaction_queue`` (объем "
"данных в ожидании слияния), ``scheduler.compaction_time`` (общее время, "
"затраченное рабочими потоками на слияние, в секундах) и "
"``scheduler.compaction_output`` (объем данных после слияния, который, "
"предположительно, меньше ``scheduler.compaction_input``)."

#: ../doc/1.10/book/box/box_stat.rst:265
msgid ""
"``box.stat.vinyl().scheduler.tasks_*`` is about dump/compaction tasks, in"
" three categories, ``scheduler.tasks_inprogress`` (currently running), "
"``scheduler.tasks_completed`` (successfully completed) "
"``scheduler.tasks_failed`` (aborted due to errors)."
msgstr ""
"``box.stat.vinyl().scheduler.tasks_*`` содержит информацию о задачах по "
"созданию дампов или слиянию, разделенную на три категории: "
"``scheduler.tasks_inprogress`` (текущие), ``scheduler.tasks_completed`` "
"(успешно завершенные) ``scheduler.tasks_failed`` (прерванные из-за "
"ошибки)."

#: ../doc/1.10/book/box/box_stat.rst:271
msgid ""
"``box.stat.vinyl().scheduler_dump_*`` has the amount of data from recent "
"changes that has been dumped, including ``dump_time`` (total time spent "
"by all worker threads performing dumps, in seconds), and ``dump_count`` "
"(the count of completed dumps), ``dump_input`` and ``dump_output``."
msgstr ""
"``box.stat.vinyl().scheduler_dump_*`` содержит объем данных из последних "
"изменений, для которых был создан дамп, включая ``dump_time`` (общее "
"время, затраченное рабочими потоками на создание дампов, в секундах) и "
"``dump_count`` (счетчик созданных дампов), ``dump_input`` и "
"``dump_output``."

#: ../doc/1.10/book/box/box_stat.rst:277
msgid ""
"A \"dump\" is explained in section :ref:`Storing data with vinyl "
"<engines-algorithm_filling_lsm>`:"
msgstr ""
"Понятие \"дамп\" (dump) объясняется в разделе :ref:`Хранение данных с "
"помощью vinyl <engines-algorithm_filling_lsm>`:"

#: ../doc/1.10/book/box/box_stat.rst:279
msgid ""
"Sooner or later the number of elements in an LSM tree exceeds the L0 size"
" and that is when L0 gets written to a file on disk (called a 'run') and "
"then cleared for storing new elements. This operation is called a 'dump'."
msgstr ""
"Рано или поздно количество элементов в дереве превысит размер L0. Тогда "
"L0 записывается в файл на диске (который называется забегом -- 'run') и "
"освобождается под новые элементы. Эта операция называется 'дамп' (dump)."

#: ../doc/1.10/book/box/box_stat.rst:283
msgid ""
"Thus it can be predicted that a dump will occur if the size of L0 (which "
"is :ref:`memory.level0 <box_introspection-box_stat_vinyl_memory>`) is "
"approaching the maximum (which is :ref:`regulator.dump_watermark "
"<box_introspection-box_stat_vinyl_regulator>`) and a dump is not already "
"in progress. In fact Tarantool will try to arrange a dump before this "
"hard limit is reached."
msgstr ""
"Таким образом, можно предсказать создание дампа, если размер L0 (указан в"
" :ref:`memory.level0 <box_introspection-box_stat_vinyl_memory>`) "
"приближается к максимальному (указан в :ref:`regulator.dump_watermark "
"<box_introspection-box_stat_vinyl_regulator>`), и создание дампа еще не "
"началось. На самом деле Tarantool планирует дамп до достижения предела."

#: ../doc/1.10/book/box/box_stat.rst:293
msgid "A dump will also occur during a  :ref:`snapshot <box-snapshot>` operation."
msgstr ""
"Дамп также создается во время операции создания :ref:`снимка <box-"
"snapshot>`."

#: ../doc/1.10/book/box/box_tuple.rst:39
msgid "Submodule `box.tuple`"
msgstr "Вложенный модуль `box.tuple`"

#: ../doc/1.10/book/box/box_tuple.rst:47
msgid ""
"The ``box.tuple`` submodule provides read-only access for the ``tuple`` "
"userdata type. It allows, for a single :ref:`tuple <index-box_tuple>`: "
"selective retrieval of the field contents, retrieval of information about"
" size, iteration over all the fields, and conversion to a `Lua table "
"<https://www.lua.org/pil/2.5.html>`_."
msgstr ""
"Вложенный модуль ``box.tuple`` предоставляет доступ только для чтения к "
"пользовательским данным типа кортеж ``tuple``. С его помощью для "
"отдельного :ref:`кортежа <index-box_tuple>` можно сделать следующее: "
"выборочно искать содержимое поля, получать информацию о размере, "
"проводить итерацию по всем полям и выполнять преобразование в "
"`Lua-таблицу <https://www.lua.org/pil/2.5.html>`_."

#: ../doc/1.10/book/box/box_tuple.rst:56
msgid "Below is a list of all ``box.tuple`` functions."
msgstr "Ниже приведен перечень всех функций модуля ``box.tuple``."

#: ../doc/1.10/book/box/box_tuple.rst:66
msgid ":ref:`box.tuple.new() <box_tuple-new>`"
msgstr ":ref:`box.tuple.new() <box_tuple-new>`"

#: ../doc/1.10/book/box/box_tuple.rst:66
msgid "Create a tuple"
msgstr "Создание кортежа"

#: ../doc/1.10/book/box/box_tuple.rst:69
msgid ":ref:`#tuple_object <box_tuple-count_fields>`"
msgstr ":ref:`#tuple_object <box_tuple-count_fields>`"

#: ../doc/1.10/book/box/box_tuple.rst:69
msgid "Count tuple fields"
msgstr "Подсчет полей кортежа"

#: ../doc/1.10/book/box/box_tuple.rst:72
msgid ":ref:`tuple_object:bsize() <box_tuple-bsize>`"
msgstr ":ref:`tuple_object:bsize() <box_tuple-bsize>`"

#: ../doc/1.10/book/box/box_tuple.rst:72
msgid "Get count of bytes in a tuple"
msgstr "Подсчет байтов в кортеже"

#: ../doc/1.10/book/box/box_tuple.rst:75
msgid ":ref:`tuple_object[field-number] <box_tuple-field_number>`"
msgstr ":ref:`tuple_object[field-number] <box_tuple-field_number>`"

#: ../doc/1.10/book/box/box_tuple.rst:75
msgid "Get a tuple's field by specifying a number"
msgstr "Получение поля кортежа по номеру"

#: ../doc/1.10/book/box/box_tuple.rst:78
msgid ":ref:`tuple_object[field-name] <box_tuple-field_name>`"
msgstr ":ref:`tuple_object[field-name] <box_tuple-field_name>`"

#: ../doc/1.10/book/box/box_tuple.rst:78
msgid "Get a tuple's field by specifying a name"
msgstr "Получение поля кортежа по имени"

#: ../doc/1.10/book/box/box_tuple.rst:81
msgid ":ref:`tuple_object[field-path] <box_tuple-field_path>`"
msgstr ":ref:`tuple_object[field-path] <box_tuple-field_path>`"

#: ../doc/1.10/book/box/box_tuple.rst:81
msgid "Get a tuple's fields or parts by specifying a path"
msgstr "Получение полей кортежа или компонентов по пути"

#: ../doc/1.10/book/box/box_tuple.rst:84
msgid ":ref:`tuple_object:find() <box_tuple-find>`"
msgstr ":ref:`tuple_object:find() <box_tuple-find>`"

#: ../doc/1.10/book/box/box_tuple.rst:84
msgid "Get the number of the first field matching the search value"
msgstr "Получение номера первого поля, совпадающего с искомым значением"

#: ../doc/1.10/book/box/box_tuple.rst:87
msgid ":ref:`tuple_object:findall() <box_tuple-find>`"
msgstr ":ref:`tuple_object:findall() <box_tuple-find>`"

#: ../doc/1.10/book/box/box_tuple.rst:87
msgid "Get the number of all fields matching the search value"
msgstr "Получение номеров всех полей, совпадающих с искомым значением"

#: ../doc/1.10/book/box/box_tuple.rst:90
msgid ":ref:`tuple_object:transform() <box_tuple-transform>`"
msgstr ":ref:`tuple_object:transform() <box_tuple-transform>`"

#: ../doc/1.10/book/box/box_tuple.rst:90
msgid "Remove (and replace) a tuple's fields"
msgstr "Удаление (и замена) полей кортежа"

#: ../doc/1.10/book/box/box_tuple.rst:93
msgid ":ref:`tuple_object:unpack() <box_tuple-unpack>`"
msgstr ":ref:`tuple_object:unpack() <box_tuple-unpack>`"

#: ../doc/1.10/book/box/box_tuple.rst:93
msgid "Get a tuple's fields"
msgstr "Получение полей кортежа"

#: ../doc/1.10/book/box/box_tuple.rst:96
msgid ":ref:`tuple_object:totable() <box_tuple-totable>`"
msgstr ":ref:`tuple_object:totable() <box_tuple-totable>`"

#: ../doc/1.10/book/box/box_tuple.rst:96
msgid "Get a tuple's fields as a table"
msgstr "Получение полей кортежа в виде таблицы"

#: ../doc/1.10/book/box/box_tuple.rst:99
msgid ":ref:`tuple_object:tomap() <box_tuple-tomap>`"
msgstr ":ref:`tuple_object:tomap() <box_tuple-tomap>`"

#: ../doc/1.10/book/box/box_tuple.rst:99
msgid "Get a tuple's fields as a table along with key:value pairs"
msgstr "Получение полей кортежа в виде таблицы, а также пар ключ-значение"

#: ../doc/1.10/book/box/box_tuple.rst:102
msgid ":ref:`tuple_object:pairs() <box_tuple-pairs>`"
msgstr ":ref:`tuple_object:pairs() <box_tuple-pairs>`"

#: ../doc/1.10/book/box/box_tuple.rst:105
msgid ":ref:`tuple_object:update() <box_tuple-update>`"
msgstr ":ref:`tuple_object:update() <box_tuple-update>`"

#: ../doc/1.10/book/box/box_tuple.rst:113
msgid ""
"Construct a new tuple from either a scalar or a Lua table. Alternatively,"
" one can get new tuples from tarantool's :ref:`select <box_space-select>`"
" or :ref:`insert <box_space-insert>` or :ref:`replace <box_space-"
"replace>` or :ref:`update <box_space-update>` requests, which can be "
"regarded as statements that do ``new()`` implicitly."
msgstr ""
"Создание нового кортежа либо из скаляра, либо из Lua-таблицы.  Возможен и"
" вариант получения новых кортежей из запросов :ref:`select <box_space-"
"select>` или :ref:`insert <box_space-insert>`. или :ref:`replace "
"<box_space-replace>`, или :ref:`update <box_space-update>` Tarantool'а, "
"которые можно рассматривать в качестве операторов, косвенно выполняющих "
"операцию создания ``new()``."

#: ../doc/1.10/book/box/box_tuple.rst:120
msgid "the value that will become the tuple contents."
msgstr "значение, которое станет содержимым кортежа."

#: ../doc/1.10/book/box/box_tuple.rst:122
msgid "a new tuple"
msgstr "новый кортеж"

#: ../doc/1.10/book/box/box_tuple.rst:125
msgid ""
"In the following example, ``x`` will be a new table object containing one"
" tuple and ``t`` will be a new tuple object. Saying ``t`` returns the "
"entire tuple ``t``."
msgstr ""
"В следующем примере ``x`` будет представлять собой новый объект таблицы, "
"который содержит один кортеж, а ``t`` будет представлять собой объект "
"кортежа. Если ввести команду ``t``, будет получен весь кортеж ``t``."

#: ../doc/1.10/book/box/box_tuple.rst:131
msgid ""
"tarantool> x = box.space.tester:insert{\n"
"         >   33,\n"
"         >   tonumber('1'),\n"
"         >   tonumber64('2')\n"
"         > }:totable()\n"
"---\n"
"...\n"
"tarantool> t = box.tuple.new{'abc', 'def', 'ghi', 'abc'}\n"
"---\n"
"...\n"
"tarantool> t\n"
"---\n"
"- ['abc', 'def', 'ghi', 'abc']\n"
"..."
msgstr ""
"tarantool> x = box.space.tester:insert{\n"
"         >   33,\n"
"         >   tonumber('1'),\n"
"         >   tonumber64('2')\n"
"         > }:totable()\n"
"---\n"
"...\n"
"tarantool> t = box.tuple.new{'abc', 'def', 'ghi', 'abc'}\n"
"---\n"
"...\n"
"tarantool> t\n"
"---\n"
"- ['abc', 'def', 'ghi', 'abc']\n"
"..."

#: ../doc/1.10/book/box/box_tuple.rst:154
msgid ""
"The ``#`` operator in Lua means \"return count of components\". So, if "
"``t`` is a tuple instance, ``#t`` will return the number of fields."
msgstr ""
"Оператор ``#`` на языке Lua означает \"вернуть количество компонентов\". "
"Таким образом, если ``t`` представляет собой кортеж, то ``#t`` вернет "
"количество полей."

#: ../doc/1.10/book/box/box_tuple.rst:159
msgid ""
"In the following example, a tuple named ``t`` is created and then the "
"number of fields in ``t`` is returned."
msgstr ""
"В следующем примере создается кортеж под названием ``t``, а затем "
"возвращается количество полей в кортеже ``t``."

#: ../doc/1.10/book/box/box_tuple.rst:162
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4'}\n"
"---\n"
"...\n"
"tarantool> #t\n"
"---\n"
"- 4\n"
"..."
msgstr ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4'}\n"
"---\n"
"...\n"
"tarantool> #t\n"
"---\n"
"- 4\n"
"..."

#: ../doc/1.10/book/box/box_tuple.rst:176
msgid ""
"If ``t`` is a tuple instance, ``t:bsize()`` will return the number of "
"bytes in the tuple. With both the memtx storage engine and the vinyl "
"storage engine the default maximum is one megabyte "
"(:ref:`memtx_max_tuple_size <cfg_storage-memtx_max_tuple_size>` or "
":ref:`vinyl_max_tuple_size <cfg_storage-vinyl_max_tuple_size>`). Every "
"field has one or more \"length\" bytes preceding the actual contents, so "
"``bsize()`` returns a value which is slightly greater than the sum of the"
" lengths of the contents."
msgstr ""
"Если ``t`` -- это экземпляр кортежа, то ``t:bsize()`` вернет количество "
"байтов в кортеже. Как для движка базы данных memtx, так и для движка "
"vinyl максимальное количество, используемое по умолчанию, составляет один"
" мегабайт (:ref:`memtx_max_tuple_size <cfg_storage-memtx_max_tuple_size>`"
" или :ref:`vinyl_max_tuple_size <cfg_storage-vinyl_max_tuple_size>`). В "
"каждом поле есть один или более байтов \"длины\", которые предваряют само"
" содержимое поля, поэтому ``bsize()`` вернет значение, которое "
"незначительно больше, чем сумма длин всего содержимого."

#: ../doc/1.10/book/box/box_tuple.rst:185
msgid ""
"The value does not include the size of \"struct tuple\" (for the current "
"size of this structure look in the `tuple.h "
"<https://github.com/tarantool/tarantool/blob/1.10/src/box/tuple.h>`_ file"
" in Tarantool's source code)."
msgstr ""
"Значение не содержит размер кортежа \"struct tuple\" (чтобы узнать "
"текущий размер данной структуры, посмотрите файл `tuple.h "
"<https://github.com/tarantool/tarantool/blob/1.10/src/box/tuple.h>`_ в "
"исходном коде Tarantool'а)."

#: ../doc/1.10/book/box/box_tuple.rst:193
msgid ""
"In the following example, a tuple named ``t`` is created which has three "
"fields, and for each field it takes one byte to store the length and "
"three bytes to store the contents, and then there is one more byte to "
"store a count of the number of fields, so ``bsize()`` returns "
"``3*(1+3)+1``. This is the same as the size of the string that "
":ref:`msgpack.encode({'aaa','bbb','ccc'}) <msgpack-encode>` would return."
msgstr ""
"В следующем примере создается кортеж с именем ``t``, в котором три поля, "
"и для каждого поля один байт занимает хранение длины, и три байта "
"занимает хранение содержимого, кроме того, один бит используется на "
"ресурсы, поэтому ``bsize()`` вернет ``3*(1+3)+1``. Такой же размер строки"
" вернула бы функция :ref:`msgpack.encode({'aaa','bbb','ccc'}) <msgpack-"
"encode>`."

#: ../doc/1.10/book/box/box_tuple.rst:200
msgid ""
"tarantool> t = box.tuple.new{'aaa', 'bbb', 'ccc'}\n"
"---\n"
"...\n"
"tarantool> t:bsize()\n"
"---\n"
"- 13\n"
"..."
msgstr ""
"tarantool> t = box.tuple.new{'aaa', 'bbb', 'ccc'}\n"
"---\n"
"...\n"
"tarantool> t:bsize()\n"
"---\n"
"- 13\n"
"..."

#: ../doc/1.10/book/box/box_tuple.rst:214
msgid ""
"If ``t`` is a tuple instance, ``t[field-number]`` will return the field "
"numbered field-number in the tuple. The first field is ``t[1]``."
msgstr ""
"Если ``t`` -- это экземпляр кортежа, то ``t[номер-поля]`` вернет поле под"
" номером номер-поля в кортеже. Первое поле -- это ``t[1]``."

#: ../doc/1.10/book/box/box_tuple.rst:217
#: ../doc/1.10/book/box/box_tuple.rst:241
msgid "field value."
msgstr "значение поля."

#: ../doc/1.10/book/box/box_tuple.rst:218
#: ../doc/1.10/book/box/box_tuple.rst:242
msgid "lua-value"
msgstr "Lua-значение"

#: ../doc/1.10/book/box/box_tuple.rst:220
msgid ""
"In the following example, a tuple named ``t`` is created and then the "
"second field in ``t`` is returned."
msgstr ""
"В следующем примере создается кортеж под названием ``t``, а затем "
"возвращается второе поле в кортеже ``t``."

#: ../doc/1.10/book/box/box_tuple.rst:223
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4'}\n"
"---\n"
"...\n"
"tarantool> t[2]\n"
"---\n"
"- Fld#2\n"
"..."
msgstr ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4'}\n"
"---\n"
"...\n"
"tarantool> t[2]\n"
"---\n"
"- Fld#2\n"
"..."

#: ../doc/1.10/book/box/box_tuple.rst:237
msgid ""
"If ``t`` is a tuple instance, ``t['field-name']`` will return the field "
"named 'field-name' in the tuple. Fields have names if the tuple has been "
"retrieved from a space that has an associated :ref:`format <box_space-"
"format>`."
msgstr ""
"Если ``t`` -- это экземпляр кортежа, то ``t['field-name']`` вернет поле "
"под названием `field-name` в кортеже. У полей есть имена, если кортеж был"
" получен из спейса с определенным :ref:`форматом <box_space-format>`."

#: ../doc/1.10/book/box/box_tuple.rst:244
msgid ""
"In the following example, a tuple named ``t`` is returned from "
"``replace`` and then the second field in ``t`` named 'field2' is "
"returned."
msgstr ""
"В следующем примере кортеж под названием ``t`` возвращается после "
"операции замены, а затем возвращается второе поле с именем 'field2' в "
"кортеже ``t``."

#: ../doc/1.10/book/box/box_tuple.rst:247
msgid ""
"tarantool> format = {}\n"
"---\n"
"...\n"
"tarantool> format[1] = {name = 'field1', type = 'unsigned'}\n"
"---\n"
"...\n"
"tarantool> format[2] = {name = 'field2', type = 'string'}\n"
"---\n"
"...\n"
"tarantool> s = box.schema.space.create('test', {format = format})\n"
"---\n"
"...\n"
"tarantool> pk = s:create_index('pk')\n"
"---\n"
"...\n"
"tarantool> t = s:replace{1, 'Я'}\n"
"---\n"
"...\n"
"tarantool> t['field2']\n"
"---\n"
"- Я\n"
"..."
msgstr ""
"tarantool> format = {}\n"
"---\n"
"...\n"
"tarantool> format[1] = {name = 'field1', type = 'unsigned'}\n"
"---\n"
"...\n"
"tarantool> format[2] = {name = 'field2', type = 'string'}\n"
"---\n"
"...\n"
"tarantool> s = box.schema.space.create('test', {format = format})\n"
"---\n"
"...\n"
"tarantool> pk = s:create_index('pk')\n"
"---\n"
"...\n"
"tarantool> t = s:replace{1, 'Я'}\n"
"---\n"
"...\n"
"tarantool> t['field2']\n"
"---\n"
"- Я\n"
"..."

#: ../doc/1.10/book/box/box_tuple.rst:276
msgid ""
"If ``t`` is a tuple instance, ``t['path']`` will return the field or "
"subset of fields that are in ``path``. ``path`` must be a well formed "
"JSON specification. ``path`` may contain field names if the tuple has "
"been retrieved from a space that has an associated :ref:`format "
"<box_space-format>`."
msgstr ""
"Если ``t`` -- это экземпляр кортежа, то ``t['path']`` вернет поле или ряд"
" полей, которые находятся в ``path``. Параметр ``path`` должен "
"представлять собой правильную JSON-спецификацию. ``path`` может содержать"
" имена полей, если кортеж был получен из спейса с заданным :ref:`форматом"
" <box_space-format>`."

#: ../doc/1.10/book/box/box_tuple.rst:281
msgid ""
"To prevent ambiguity, Tarantool first tries to interpret the request as "
":ref:`tuple_object[field-number] <box_tuple-field_number>` or "
":ref:`tuple_object[field-name] <box_tuple-field_name>`. If and only if "
"that fails, Tarantool tries to interpret the request as ``tuple_object"
"[field-path]``."
msgstr ""
"Во избежание неоднозначности Tarantool сначала пытается интерпретировать "
"запрос как :ref:`tuple_object[field-number] <box_tuple-field_number>` или"
"  :ref:`tuple_object[field-name] <box_tuple-field_name>`. И только в том "
"случае, если это не удается, Tarantool пытается интерпретировать запрос "
"как ``tuple_object[field-path]``."

#: ../doc/1.10/book/box/box_tuple.rst:287
msgid ""
"The path must be a well formed JSON specification, but it may be preceded"
" by '.'. The '.' is a signal that the path acts as a suffix for the "
"tuple."
msgstr ""
"Путь path должен представлять собой правильную JSON-спецификацию, но в "
"начале может стоять '.'. Символ '.' означает, что путь выступает в "
"качестве суффикса для кортежа."

#: ../doc/1.10/book/box/box_tuple.rst:291
msgid ""
"The advantage of specifying a path is that Tarantool will use it to "
"search through a tuple body and get only the tuple part, or parts, that "
"are actually necessary."
msgstr ""
"При указании пути Tarantool воспользуется им для поиска по телу кортежа и"
" вернет только тот компонент кортежа, который действительно необходим."

#: ../doc/1.10/book/box/box_tuple.rst:295
msgid ""
"In the following example, a tuple named ``t`` is returned from "
"``replace`` and then only the relevant part (in this case, matching a "
"name) of a relevant field is returned. Namely: the second field, the "
"sixth part, the value following 'value='."
msgstr ""
"В следующем примере кортеж под названием ``t`` возвращается после "
"операции замены, а затем возвращается только необходимый компонент (в "
"данном случае совпадение имени) соответствующего поля. В частности: "
"второе поле, шестой компонент, значение после 'value='."

#: ../doc/1.10/book/box/box_tuple.rst:300
msgid ""
"tarantool> format = {}\n"
"---\n"
"...\n"
"tarantool> format[1] = {name = 'field1', type = 'unsigned'}\n"
"---\n"
"...\n"
"tarantool> format[2] = {name = 'field2', type = 'array'}\n"
"---\n"
"...\n"
"tarantool> format[3] = {name = 'field4', type = 'string' }\n"
"---\n"
"...\n"
"tarantool> format[4] = {name = \"[2][6]['пw']['Я']\", type = 'string'}\n"
"---\n"
"...\n"
"tarantool> s = box.schema.space.create('test', {format = format})\n"
"---\n"
"...\n"
"tarantool> pk = s:create_index('pk')\n"
"---\n"
"...\n"
"tarantool> field2 = {1, 2, 3, \"4\", {5,6,7}, {пw={Я=\"п\"}, key=\"V!\", "
"value=\"K!\"}}\n"
"---\n"
"...\n"
"tarantool> t = s:replace{1, field2, \"123456\", \"Not K!\"}\n"
"---\n"
"...\n"
"tarantool> t[\"[2][6]['value']\"]\n"
"---\n"
"- K!\n"
"..."
msgstr ""
"tarantool> format = {}\n"
"---\n"
"...\n"
"tarantool> format[1] = {name = 'field1', type = 'unsigned'}\n"
"---\n"
"...\n"
"tarantool> format[2] = {name = 'field2', type = 'array'}\n"
"---\n"
"...\n"
"tarantool> format[3] = {name = 'field4', type = 'string' }\n"
"---\n"
"...\n"
"tarantool> format[4] = {name = \"[2][6]['пw']['Я']\", type = 'string'}\n"
"---\n"
"...\n"
"tarantool> s = box.schema.space.create('test', {format = format})\n"
"---\n"
"...\n"
"tarantool> pk = s:create_index('pk')\n"
"---\n"
"...\n"
"tarantool> field2 = {1, 2, 3, \"4\", {5,6,7}, {пw={Я=\"п\"}, key=\"V!\", "
"value=\"K!\"}}\n"
"---\n"
"...\n"
"tarantool> t = s:replace{1, field2, \"123456\", \"Not K!\"}\n"
"---\n"
"...\n"
"tarantool> t[\"[2][6]['value']\"]\n"
"---\n"
"- K!\n"
"..."

#: ../doc/1.10/book/box/box_tuple.rst:339
msgid ""
"If ``t`` is a tuple instance, ``t:find(search-value)`` will return the "
"number of the first field in ``t`` that matches the search value, and "
"``t:findall(search-value [, search-value ...])`` will return numbers of "
"all fields in ``t`` that match the search value. Optionally one can put a"
" numeric argument ``field-number`` before the search-value to indicate "
"“start searching at field number ``field-number``.”"
msgstr ""
"Если ``t`` -- это экземпляр кортежа, то ``t:find(search-value)`` вернет "
"номер первого поля в ``t``, которое совпадает с искомым значением, а "
"``t:findall(search-value [, search-value ...])`` вернет номера всех колей"
" в ``t``, которые совпадают с искомым значением. Можно дополнительно "
"добавить числовой аргумент ``field-number`` перед search-value, чтобы "
"задать условие “начинать поиск с номера поля ``field-number``.”"

#: ../doc/1.10/book/box/box_tuple.rst:346
msgid "the number of the field in the tuple."
msgstr "номер поля в кортеже."

#: ../doc/1.10/book/box/box_tuple.rst:349
msgid ""
"In the following example, a tuple named ``t`` is created and then: the "
"number of the first field in ``t`` which matches 'a' is returned, then "
"the numbers of all the fields in ``t`` which match 'a' are returned, then"
" the numbers of all the fields in t which match 'a' and are at or after "
"the second field are returned."
msgstr ""
"В следующем примере создается кортеж с именем ``t``, а затем: "
"возвращается номер первого поля в ``t``, которое совпадает с 'a', затем "
"возвращаются номера всех полей в ``t``, которые совпадают с 'a', затем "
"возвращаются номера всех полей в t, которые совпадают с 'a', и находятся "
"на втором месте или далее."

#: ../doc/1.10/book/box/box_tuple.rst:355
msgid ""
"tarantool> t = box.tuple.new{'a', 'b', 'c', 'a'}\n"
"---\n"
"...\n"
"tarantool> t:find('a')\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> t:findall('a')\n"
"---\n"
"- 1\n"
"- 4\n"
"...\n"
"tarantool> t:findall(2, 'a')\n"
"---\n"
"- 4\n"
"..."
msgstr ""
"tarantool> t = box.tuple.new{'a', 'b', 'c', 'a'}\n"
"---\n"
"...\n"
"tarantool> t:find('a')\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> t:findall('a')\n"
"---\n"
"- 1\n"
"- 4\n"
"...\n"
"tarantool> t:findall(2, 'a')\n"
"---\n"
"- 4\n"
"..."

#: ../doc/1.10/book/box/box_tuple.rst:378
msgid ""
"If ``t`` is a tuple instance, :samp:`t:transform({start-field-number"
"},{fields-to-remove})` will return a tuple where, starting from field "
"``start-field-number``, a number of fields (``fields-to-remove``) are "
"removed. Optionally one can add more arguments after ``fields-to-remove``"
" to indicate new values that will replace what was removed."
msgstr ""
"Если ``t`` -- это экземпляр кортежа, то :samp:`t:transform({start-field-"
"number},{fields-to-remove})` вернет кортеж, где начиная с поля ``start-"
"field-number``, удаляется количество полей (``fields-to-remove``). "
"Дополнительно можно добавить аргументы после ``fields-to-remove``, чтобы "
"указать новые значения на замену удаленных."

#: ../doc/1.10/book/box/box_tuple.rst:384
msgid ""
"If the original tuple comes from a space that has been formatted with a "
":ref:`format clause <box_space-format>`, the formatting will not be "
"preserved for the result tuple."
msgstr ""
"Если первоначальный кортеж приходит из спейса, который был форматирован "
"посредством :ref:`оператора формата <box_space-format>`, форматирование "
"возвращаемого кортежа не сохранится."

#: ../doc/1.10/book/box/box_tuple.rst:388
msgid "base 1, may be negative"
msgstr "начиная с 1, может быть отрицательным"

#: ../doc/1.10/book/box/box_tuple.rst:394
msgid ""
"In the following example, a tuple named ``t`` is created and then, "
"starting from the second field, two fields are removed but one new one is"
" added, then the result is returned."
msgstr ""
"В следующем примере создается кортеж под названием ``t``, а затем начиная"
" со второго поля, удаляются два поля, а одно новое поле добавляется, "
"затем возвращается результат."

#: ../doc/1.10/book/box/box_tuple.rst:398
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}"
"\n"
"---\n"
"...\n"
"tarantool> t:transform(2, 2, 'x')\n"
"---\n"
"- ['Fld#1', 'x', 'Fld#4', 'Fld#5']\n"
"..."
msgstr ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}"
"\n"
"---\n"
"...\n"
"tarantool> t:transform(2, 2, 'x')\n"
"---\n"
"- ['Fld#1', 'x', 'Fld#4', 'Fld#5']\n"
"..."

#: ../doc/1.10/book/box/box_tuple.rst:412
msgid ""
"If ``t`` is a tuple instance, ``t:unpack()`` will return all fields, "
"``t:unpack(1)`` will return all fields starting with field number 1, "
"``t:unpack(1,5)`` will return all fields between field number 1 and field"
" number 5."
msgstr ""
"Если ``t`` -- это экземпляр кортежа, то ``t:unpack()`` вернет все поля, "
"``t:unpack(1)`` вернет все поля, начиная с поля №1, ``t:unpack(1,5)`` "
"вернет все поля между полем №1 и полем №5."

#: ../doc/1.10/book/box/box_tuple.rst:416
msgid "field(s) from the tuple."
msgstr "поле или поля из кортежа."

#: ../doc/1.10/book/box/box_tuple.rst:417
msgid "lua-value(s)"
msgstr "Lua-значение"

#: ../doc/1.10/book/box/box_tuple.rst:419
msgid ""
"In the following example, a tuple named ``t`` is created and then all its"
" fields are selected, then the result is returned."
msgstr ""
"В следующем примере создается кортеж под названием ``t``, а затем "
"делается выборка всех полей, возвращается результат."

#: ../doc/1.10/book/box/box_tuple.rst:422
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}"
"\n"
"---\n"
"...\n"
"tarantool> t:unpack()\n"
"---\n"
"- Fld#1\n"
"- Fld#2\n"
"- Fld#3\n"
"- Fld#4\n"
"- Fld#5\n"
"..."
msgstr ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}"
"\n"
"---\n"
"...\n"
"tarantool> t:unpack()\n"
"---\n"
"- Fld#1\n"
"- Fld#2\n"
"- Fld#3\n"
"- Fld#4\n"
"- Fld#5\n"
"..."

#: ../doc/1.10/book/box/box_tuple.rst:440
msgid ""
"If ``t`` is a tuple instance, ``t:totable()`` will return all fields, "
"``t:totable(1)`` will return all fields starting with field number 1, "
"``t:totable(1,5)`` will return all fields between field number 1 and "
"field number 5."
msgstr ""
"Если ``t`` -- это экземпляр кортежа, то ``t:totable()`` вернет все поля, "
"``t:totable(1)`` вернет все поля, начиная с поля №1, ``t:totable(1,5)`` "
"вернет все поля между полем №1 и полем №5."

#: ../doc/1.10/book/box/box_tuple.rst:444
msgid "It is preferable to use ``t:totable()`` rather than ``t:unpack()``."
msgstr "Рекомендуется использовать ``t:totable()``, а не ``t:unpack()``."

#: ../doc/1.10/book/box/box_tuple.rst:446
msgid "field(s) from the tuple"
msgstr "поле или поля из кортежа"

#: ../doc/1.10/book/box/box_tuple.rst:447
#: ../doc/1.10/book/box/box_tuple.rst:496
msgid "lua-table"
msgstr "Lua-таблица"

#: ../doc/1.10/book/box/box_tuple.rst:449
msgid ""
"In the following example, a tuple named ``t`` is created, then all its "
"fields are selected, then the result is returned."
msgstr ""
"В следующем примере создается кортеж под названием ``t``, а затем "
"делается выборка всех полей, возвращается результат."

#: ../doc/1.10/book/box/box_tuple.rst:452
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}"
"\n"
"---\n"
"...\n"
"tarantool> t:totable()\n"
"---\n"
"- ['Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5']\n"
"..."
msgstr ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}"
"\n"
"---\n"
"...\n"
"tarantool> t:totable()\n"
"---\n"
"- ['Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5']\n"
"..."

#: ../doc/1.10/book/box/box_tuple.rst:466
msgid ""
"A `Lua table <https://www.lua.org/pil/2.5.html>`_ can have indexed "
"values, also called key:value pairs. For example, here:"
msgstr ""
"В `Lua-таблице <https://www.lua.org/pil/2.5.html>`_ могут быть "
"индексированные значения, которые также называются пары ключ-значение. "
"Например, здесь:"

#: ../doc/1.10/book/box/box_tuple.rst:470
msgid "a = {}; a['field1'] = 10; a['field2'] = 20"
msgstr "a = {}; a['field1'] = 10; a['field2'] = 20"

#: ../doc/1.10/book/box/box_tuple.rst:474
msgid "``a`` is a table with \"field1: 10\" and \"field2: 20\"."
msgstr "``a`` -- это таблица с \"field1: 10\" и \"field2: 20\"."

#: ../doc/1.10/book/box/box_tuple.rst:476
msgid ""
"The :ref:`tuple_object:totable() <box_tuple-totable>` function only "
"returns a table containing the values. But the ``tuple_object:tomap()`` "
"function returns a table containing not only the values, but also the "
"key:value pairs."
msgstr ""
"Функция :ref:`tuple_object:totable() <box_tuple-totable>` вернет только "
"таблицу со значениями. А функция ``tuple_object:tomap()`` вернет таблицу "
"не только со значениями, но и с парами ключ-значение."

#: ../doc/1.10/book/box/box_tuple.rst:481
msgid ""
"This only works if the tuple comes from a space that has been formatted "
"with a :ref:`format clause <box_space-format>`."
msgstr ""
"Это сработает только в том случае, если кортеж приходит из спейса, "
"который был форматирован посредством :ref:`оператора формата <box_space-"
"format>`."

#: ../doc/1.10/book/box/box_tuple.rst:484
msgid ""
"the only possible option is ``names_only``.  If ``names_only`` is false "
"or omitted (default), then all the fields will appear twice, first with "
"numeric headings and second with name headings.  If ``names_only`` is "
"true, then all the fields will appear only once, with name headings."
msgstr ""
"единственный доступный параметр -- ``names_only``.  Если ``names_only`` "
"принимает значение false или не указан (по умолчанию), то все поля "
"появятся дважды: сначала с числовыми заголовками, а затем с именными "
"заголовками. Если же ``names_only`` = true, то все поля будут выведены "
"один раз с именными заголовками."

#: ../doc/1.10/book/box/box_tuple.rst:484
msgid "the only possible option is ``names_only``."
msgstr "единственный доступный параметр -- ``names_only``."

#: ../doc/1.10/book/box/box_tuple.rst:486
msgid ""
"If ``names_only`` is false or omitted (default), then all the fields will"
" appear twice, first with numeric headings and second with name headings."
msgstr ""
"Если ``names_only`` принимает значение false или не указан (по "
"умолчанию), то все поля появятся дважды: сначала с числовыми заголовками,"
" а затем с именными заголовками."

#: ../doc/1.10/book/box/box_tuple.rst:491
msgid ""
"If ``names_only`` is true, then all the fields will appear only once, "
"with name headings."
msgstr ""
"Если же ``names_only`` = true, то все поля будут выведены один раз с "
"именными заголовками."

#: ../doc/1.10/book/box/box_tuple.rst:495
msgid "field-number:value pair(s) and key:value pair(s) from the tuple"
msgstr "пары номер-поля:значение и пары ключ:значение из кортежа"

#: ../doc/1.10/book/box/box_tuple.rst:498
msgid ""
"In the following example, a tuple named ``t1`` is returned from a space "
"that has been formatted, then tables named ``t1map1`` and ``t1map2`` are "
"produced from ``t1``."
msgstr ""
"В следующем примере возвращается кортеж с именем ``t1`` из спейса после "
"форматирования, затем таблицы с именами ``t1map`` и ``t1map2`` создаются "
"из ``t1``."

#: ../doc/1.10/book/box/box_tuple.rst:502
msgid ""
"format = {{'field1', 'unsigned'}, {'field2', 'unsigned'}}\n"
"s = box.schema.space.create('test', {format = format})\n"
"s:create_index('pk',{parts={1,'unsigned',2,'unsigned'}})\n"
"t1 = s:insert{10, 20}\n"
"t1map = t1:tomap()\n"
"t1map_names_only = t1:tomap({names_only=true})"
msgstr ""
"format = {{'field1', 'unsigned'}, {'field2', 'unsigned'}}\n"
"s = box.schema.space.create('test', {format = format})\n"
"s:create_index('pk',{parts={1,'unsigned',2,'unsigned'}})\n"
"t1 = s:insert{10, 20}\n"
"t1map = t1:tomap()\n"
"t1map_names_only = t1:tomap({names_only=true})"

#: ../doc/1.10/book/box/box_tuple.rst:511
msgid ""
"``t1map`` will contain \"1: 10\", \"2: 20\", \"field1: 10\", \"field2: "
"20\"."
msgstr ""
"``t1map`` будет содержать \"1: 10\", \"2: 20\", \"field1: 10\", \"field2:"
" 20\"."

#: ../doc/1.10/book/box/box_tuple.rst:513
msgid "``t1map_names_only`` will contain \"field1: 10\", \"field2: 20\"."
msgstr "``t1map_names_only`` будет содержать \"field1: 10\" и \"field2: 20\"."

#: ../doc/1.10/book/box/box_tuple.rst:519
msgid ""
"In Lua, `lua-table-value:pairs() <https://www.lua.org/pil/7.3.html>`_ is "
"a method which returns: ``function``, ``lua-table-value``, ``nil``. "
"Tarantool has extended this so that ``tuple-value:pairs()`` returns: "
"``function``, ``tuple-value``, ``nil``. It is useful for Lua iterators, "
"because Lua iterators traverse a value's components until an end marker "
"is reached."
msgstr ""
"В языке Lua метод `lua-table-value:pairs() "
"<https://www.lua.org/pil/7.3.html>`_ возвращает: ``функция``, "
"``значение-Lua-таблицы``, ``nil``. В Tarantool'е метод расширен так, что "
"``tuple-value:pairs()`` возвращает: ``функция``, ``значение-кортежа``, "
"``nil``, -- что используется для Lua-итераторов, поскольку они обходят "
"компоненты значения до тех пор, пока не достигнут маркера."

#: ../doc/1.10/book/box/box_tuple.rst:525
msgid "function, tuple-value, nil"
msgstr "функция, значение кортежа, nil"

#: ../doc/1.10/book/box/box_tuple.rst:526
msgid "function, lua-value, nil"
msgstr "функция, Lua-значение, nil"

#: ../doc/1.10/book/box/box_tuple.rst:528
msgid ""
"In the following example, a tuple named ``t`` is created and then all its"
" fields are selected using a Lua for-end loop."
msgstr ""
"В следующем примере создается кортеж под названием ``t``, а затем все его"
" поля выбираются с помощью Lua-цикла for."

#: ../doc/1.10/book/box/box_tuple.rst:531
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}"
"\n"
"---\n"
"...\n"
"tarantool> tmp = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in t:pairs() do\n"
"         >   tmp = tmp .. v\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> tmp\n"
"---\n"
"- Fld#1Fld#2Fld#3Fld#4Fld#5\n"
"..."
msgstr ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}"
"\n"
"---\n"
"...\n"
"tarantool> tmp = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in t:pairs() do\n"
"         >   tmp = tmp .. v\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> tmp\n"
"---\n"
"- Fld#1Fld#2Fld#3Fld#4Fld#5\n"
"..."

#: ../doc/1.10/book/box/box_tuple.rst:555
msgid ""
"This function updates a tuple which is not in a space. Compare the "
"function :extsamp:`box.space.{*{space-name}*}:update({*{key}*}, "
"{{{*{format}*}, {*{field_no}*}, {*{value}*}}, ...})` which updates a "
"tuple in a space."
msgstr ""
"Эта функция обновляет кортеж, который находится не в спейсе. Ср. функцию "
":extsamp:`box.space.{*{space-name}*}:update({*{key}*}, {{{*{format}*}, "
"{*{field_no}*}, {*{value}*}}, ...})`, которая обновляет кортеж в спейсе."

#: ../doc/1.10/book/box/box_tuple.rst:559
msgid ""
"For details: see the description for ``operator``, ``field_no``, and "
"``value`` in the section :ref:`box.space.space-name:update{key, format, "
"{field_number, value}...) <box_space-update>`."
msgstr ""
"Более подробную информацию см. в описании ``operator``, ``field_no`` и "
"``value`` в разделе :ref:`box.space.space-name:update{key, format, "
"{field_number, value}...) <box_space-update>`."

#: ../doc/1.10/book/box/box_tuple.rst:563
msgid ""
"If the original tuple comes from a space that has been formatted with a "
":ref:`format clause <box_space-format>`, the formatting will be preserved"
" for the result tuple."
msgstr ""
"Если первоначальный кортеж приходит из спейса, который был форматирован "
"посредством :ref:`оператора формата <box_space-format>`, форматирование "
"возвращаемого кортежа сохранится."

#: ../doc/1.10/book/box/box_tuple.rst:567
msgid "operation type represented in string (e.g. '``=``' for 'assign new value')"
msgstr ""
"тип операции, представленный строкой (например, '``=``' означает "
"'присвоить новое значение')"

#: ../doc/1.10/book/box/box_tuple.rst:575
msgid "new tuple"
msgstr "новый кортеж"

#: ../doc/1.10/book/box/box_tuple.rst:578
msgid ""
"In the following example, a tuple named ``t`` is created and then its "
"second field is updated to equal 'B'."
msgstr ""
"В следующем примере создается кортеж под названием ``t``, а затем второе "
"поле обновляется до равного 'B'."

#: ../doc/1.10/book/box/box_tuple.rst:581
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}"
"\n"
"---\n"
"...\n"
"tarantool> t:update({{'=', 2, 'B'}})\n"
"---\n"
"- ['Fld#1', 'B', 'Fld#3', 'Fld#4', 'Fld#5']\n"
"..."
msgstr ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}"
"\n"
"---\n"
"...\n"
"tarantool> t:update({{'=', 2, 'B'}})\n"
"---\n"
"- ['Fld#1', 'B', 'Fld#3', 'Fld#4', 'Fld#5']\n"
"..."

#: ../doc/1.10/book/box/box_tuple.rst:593
#: ../doc/1.10/reference/configuration/index.rst:125
#: ../doc/1.10/reference/reference_lua/digest.rst:387
#: ../doc/1.10/reference/reference_lua/fiber.rst:770
#: ../doc/1.10/reference/reference_lua/fiber.rst:967
#: ../doc/1.10/reference/reference_lua/fiber.rst:1096
#: ../doc/1.10/reference/reference_lua/log.rst:172
#: ../doc/1.10/reference/reference_lua/msgpack.rst:145
#: ../doc/1.10/reference/reference_lua/net_box.rst:597
#: ../doc/1.10/reference/reference_lua/tap.rst:367
#: ../doc/1.10/reference/reference_lua/uuid.rst:166
#: ../doc/1.10/reference/reference_lua/yaml.rst:102
#: ../doc/1.10/reference/reference_rock/dbms.rst:283
#: ../doc/1.10/reference/reference_rock/dbms.rst:624
msgid "Example"
msgstr "Пример"

#: ../doc/1.10/book/box/box_tuple.rst:595
msgid ""
"This function will illustrate how to convert tuples to/from Lua tables "
"and lists of scalars:"
msgstr ""
"Представленная ниже функция проиллюстрирует, как можно преобразовать "
"кортежи в Lua-таблицы и списки скаляров и обратно:"

#: ../doc/1.10/book/box/box_tuple.rst:598
msgid ""
"tuple = box.tuple.new({scalar1, scalar2, ... scalar_n}) -- scalars to "
"tuple\n"
"lua_table = {tuple:unpack()}                            -- tuple to Lua "
"table\n"
"lua_table = tuple:totable()                             -- tuple to Lua "
"table\n"
"scalar1, scalar2, ... scalar_n = tuple:unpack()         -- tuple to "
"scalars\n"
"tuple = box.tuple.new(lua_table)                        -- Lua table to "
"tuple"
msgstr ""
"tuple = box.tuple.new({scalar1, scalar2, ... scalar_n}) -- скаляры в "
"кортеж\n"
"lua_table = {tuple:unpack()}                            -- кортеж в "
"Lua-таблицу\n"
"lua_table = tuple:totable()                             -- кортеж в "
"Lua-таблицу\n"
"scalar1, scalar2, ... scalar_n = tuple:unpack()         -- кортеж в "
"скаляры\n"
"tuple = box.tuple.new(lua_table)                        -- Lua-таблицу в "
"кортеж"

#: ../doc/1.10/book/box/box_tuple.rst:606
msgid ""
"Then it will find the field that contains 'b', remove that field from the"
" tuple, and display how many bytes remain in the tuple. The function uses"
" Tarantool ``box.tuple`` functions ``new()``, ``unpack()``, ``find()``, "
"``transform()``, ``bsize()``."
msgstr ""
"Затем она найдет поле, которое содержит значение 'b', удалит это поле из "
"кортежа и отобразит количество байтов, оставшихся в кортеже. Данная "
"функция использует следующие функции ``box.tuple`` Tarantool'а: "
"``new()``, ``unpack()``, ``find()``, ``transform()``, ``bsize()``."

#: ../doc/1.10/book/box/box_tuple.rst:611
msgid ""
"function example()\n"
"  local tuple1, tuple2, lua_table_1, scalar1, scalar2, scalar3, "
"field_number\n"
"  local luatable1 = {}\n"
"  tuple1 = box.tuple.new({'a', 'b', 'c'})\n"
"  luatable1 = tuple1:totable()\n"
"  scalar1, scalar2, scalar3 = tuple1:unpack()\n"
"  tuple2 = box.tuple.new(luatable1[1],luatable1[2],luatable1[3])\n"
"  field_number = tuple2:find('b')\n"
"  tuple2 = tuple2:transform(field_number, 1)\n"
"  return 'tuple2 = ' , tuple2 , ' # of bytes = ' , tuple2:bsize()\n"
"end"
msgstr ""
"function example()\n"
"  local tuple1, tuple2, lua_table_1, scalar1, scalar2, scalar3, "
"field_number\n"
"  local luatable1 = {}\n"
"  tuple1 = box.tuple.new({'a', 'b', 'c'})\n"
"  luatable1 = tuple1:totable()\n"
"  scalar1, scalar2, scalar3 = tuple1:unpack()\n"
"  tuple2 = box.tuple.new(luatable1[1],luatable1[2],luatable1[3])\n"
"  field_number = tuple2:find('b')\n"
"  tuple2 = tuple2:transform(field_number, 1)\n"
"  return 'tuple2 = ' , tuple2 , ' # of bytes = ' , tuple2:bsize()\n"
"end"

#: ../doc/1.10/book/box/box_tuple.rst:627
msgid ""
"tarantool> example()\n"
"---\n"
"- tuple2 =\n"
"- ['a', 'c']\n"
"- ' # of bytes = '\n"
"- 5\n"
"..."
msgstr ""
"tarantool> example()\n"
"---\n"
"- tuple2 =\n"
"- ['a', 'c']\n"
"- ' # of bytes = '\n"
"- 5\n"
"..."

#: ../doc/1.10/book/box/box_txn_management.rst:39
msgid "Functions for transaction management"
msgstr "Управление экземплярами"

#: ../doc/1.10/book/box/box_txn_management.rst:45
msgid ""
"For general information and examples, see section :ref:`Transaction "
"control <atomic-atomic_execution>`."
msgstr ""
"Чтобы получить общую информацию и взглянуть на примеры использования, см."
" раздел :ref:`Управление транзакциями <atomic-atomic_execution>`."

#: ../doc/1.10/book/box/box_txn_management.rst:48
msgid "Observe the following rules when working with transactions:"
msgstr "Соблюдайте следующие правила в работе с транзакциями:"

#: ../doc/1.10/book/box/box_txn_management.rst:50
msgid "Rule #1"
msgstr "Правило #1"

#: ../doc/1.10/book/box/box_txn_management.rst:53
msgid ""
"The requests in a transaction must be sent to a server as a single block."
" It is not enough to enclose them between begin and commit or rollback. "
"To ensure they are sent as a single block: put them in a function, or put"
" them all on one line, or use a delimiter so that multi-line requests are"
" handled together."
msgstr ""
"Запросы в транзакции должны отправляться на сервер в виде единого блока. "
"Недостаточно просто размещать их между началом транзакции и коммитом или "
"откатом. Чтобы убедиться, что они отправляются в виде единого блока: "
"поместите их в функцию, поместите их на одну строку или используйте "
"символы-разделители, чтобы многостроковые запросы обрабатывались "
"совместно."

#: ../doc/1.10/book/box/box_txn_management.rst:59
msgid "Rule #2"
msgstr "Правило #2"

#: ../doc/1.10/book/box/box_txn_management.rst:62
msgid ""
"All database operations in a transaction should use the same storage "
"engine. It is not safe to access tuple sets that are defined with "
"``{engine='vinyl'}`` and also access tuple sets that are defined with "
"``{engine='memtx'}``, in the same transaction."
msgstr ""
"Все операции с базой данных в рамках транзакции должны работать с одним "
"движком баз данных. Небезопасно в рамках одной транзакции получать доступ"
" к наборам кортежей, которые определяются по ``{engine='vinyl'}``, а "
"также к наборам кортежей, которые определяются по ``{engine='memtx'}``."

#: ../doc/1.10/book/box/box_txn_management.rst:67
msgid "Rule #3"
msgstr "Правило #3"

#: ../doc/1.10/book/box/box_txn_management.rst:70
msgid ""
"Requests which cause changes to the data definition -- create, alter, "
"drop, truncate -- must not be used."
msgstr ""
"Нельзя использовать запросы, которые могут приводить к изменению "
"определения данных -- создание, изменение, удаление, очистка."

#: ../doc/1.10/book/box/box_txn_management.rst:77
msgid "Below is a list of all functions for transaction management."
msgstr "Ниже приведен перечень всех функций для управления транзакциями."

#: ../doc/1.10/book/box/box_txn_management.rst:89
msgid ":ref:`box.begin() <box-begin>`"
msgstr ":ref:`box.begin() <box-begin>`"

#: ../doc/1.10/book/box/box_txn_management.rst:89
msgid "Begin the transaction"
msgstr "Начало транзакции"

#: ../doc/1.10/book/box/box_txn_management.rst:92
msgid ":ref:`box.commit() <box-commit>`"
msgstr ":ref:`box.commit() <box-commit>`"

#: ../doc/1.10/book/box/box_txn_management.rst:92
msgid "End the transaction and save all changes"
msgstr "Окончание транзакции и сохранение всех изменений"

#: ../doc/1.10/book/box/box_txn_management.rst:95
msgid ":ref:`box.rollback() <box-rollback>`"
msgstr ":ref:`box.rollback() <box-rollback>`"

#: ../doc/1.10/book/box/box_txn_management.rst:95
msgid "End the transaction and discard all changes"
msgstr "Окончание транзакции и отмена всех изменений"

#: ../doc/1.10/book/box/box_txn_management.rst:98
msgid ":ref:`box.savepoint() <box-savepoint>`"
msgstr ":ref:`box.savepoint() <box-savepoint>`"

#: ../doc/1.10/book/box/box_txn_management.rst:98
msgid "Get a savepoint descriptor"
msgstr "Получение дескриптора точки сохранения"

#: ../doc/1.10/book/box/box_txn_management.rst:101
msgid ":ref:`box.rollback_to_savepoint() <box-rollback_to_savepoint>`"
msgstr ":ref:`box.rollback_to_savepoint() <box-rollback_to_savepoint>`"

#: ../doc/1.10/book/box/box_txn_management.rst:101
msgid "Do not end the transaction and discard all changes made after a savepoint"
msgstr ""
"Запрещение окончания транзакции и отмена всех изменений, сделанных после "
"точки сохранения"

#: ../doc/1.10/book/box/box_txn_management.rst:105
msgid ":ref:`box.atomic() <box-atomic>`"
msgstr ":ref:`box.atomic() <box-atomic>`"

#: ../doc/1.10/book/box/box_txn_management.rst:105
msgid "Execute a function, treating it as a transaction"
msgstr "Выполнение функции как транзакции"

#: ../doc/1.10/book/box/box_txn_management.rst:108
msgid ":ref:`box.on_commit() <box-on_commit>`"
msgstr ":ref:`box.on_commit() <box-on_commit>`"

#: ../doc/1.10/book/box/box_txn_management.rst:108
msgid "Define a trigger that will be activated by ``box.commit``"
msgstr "Определение триггера, активируемого по ``box.commit``"

#: ../doc/1.10/book/box/box_txn_management.rst:111
msgid ":ref:`box.on_rollback() <box-on_rollback>`"
msgstr ":ref:`box.on_rollback() <box-on_rollback>`"

#: ../doc/1.10/book/box/box_txn_management.rst:111
msgid "Define a trigger that will be activated by ``box.rollback``"
msgstr "Определение триггера, активируемого по ``box.rollback``"

#: ../doc/1.10/book/box/box_txn_management.rst:114
#, fuzzy
msgid ":ref:`box.is_in_txn() <box-is_in_txn>`"
msgstr ":ref:`is_in_txn() <box-is_in_txn>`"

#: ../doc/1.10/book/box/box_txn_management.rst:114
msgid "State whether a transaction is in progress"
msgstr "Обозначение наличия активной транзакции"

#: ../doc/1.10/book/box/box_txn_management.rst:122
msgid ""
"Begin the transaction. Disable :ref:`implicit yields <atomic-implicit-"
"yields>` until the transaction ends. Signal that writes to the :ref"
":`write-ahead log <internals-wal>` will be deferred until the transaction"
" ends. In effect the fiber which executes ``box.begin()`` is starting an "
"\"active multi-request transaction\", blocking all other fibers."
msgstr ""
"Начало транзакции. Отключение :ref:`неявной передачи управления <atomic-"
"implicit-yields>` до окончания транзакции. Сигнал о записи в :ref "
":`журнал упреждающей записи <internals-wal>` будет задержан до окончания "
"транзакции. Фактически файбер, который выполняет функцию ``box.begin()``,"
" начинает \"активную транзакцию со множеством запросов\" с блокировкой "
"всех остальных файберов."

#: ../doc/1.10/book/box/box_txn_management.rst:130
msgid ""
"**Possible errors:** error if this operation is not permitted because "
"there"
msgstr ""
"**Возможные ошибки:** ошибка, если такая операция не допускается, потому "
"что"

#: ../doc/1.10/book/box/box_txn_management.rst:130
msgid ""
"is already an active transaction. error if for some reason memory cannot "
"be allocated."
msgstr ""
"уже есть активная транзакция. ошибка, если по какой-либо причине нельзя "
"выделить память."

#: ../doc/1.10/book/box/box_txn_management.rst:137
msgid "End the transaction, and make all its data-change operations permanent."
msgstr ""
"Окончание транзакции и применение результатов всех операций по изменению "
"данных."

#: ../doc/1.10/book/box/box_txn_management.rst:140
msgid ""
"**Possible errors:**  error and abort the transaction in case of a "
"conflict."
msgstr "**Возможные ошибки:** ошибка и прерывание транзакции в случае конфликта."

#: ../doc/1.10/book/box/box_txn_management.rst:140
msgid ""
"error if the operation fails to write to disk. error if for some reason "
"memory cannot be allocated."
msgstr ""
"ошибка, если операция не может выполнить запись на диск. ошибка, если по "
"какой-либо причине нельзя выделить память."

#: ../doc/1.10/book/box/box_txn_management.rst:147
msgid ""
"End the transaction, but cancel all its data-change operations. An "
"explicit call to functions outside ``box.space`` that always yield, such "
"as :ref:`fiber.sleep() <fiber-sleep>` or :ref:`fiber.yield() <fiber-"
"yield>`, will have the same effect."
msgstr ""
"Окончание транзакции, но отмена результатов всех операций по изменению "
"данных. Явный вызов функций не из модуля ``box.space``, которые всегда "
"передают управление, например :ref:`fiber.sleep() <fiber-sleep>` или "
":ref:`fiber.yield() <fiber-yield>`, приведет к тому же результату."

#: ../doc/1.10/book/box/box_txn_management.rst:156
msgid ""
"Return a descriptor of a savepoint (type = table), which can be used "
"later by :ref:`box.rollback_to_savepoint(savepoint) <box-"
"rollback_to_savepoint>`. Savepoints can only be created while a "
"transaction is active, and they are destroyed when a transaction ends."
msgstr ""
"Возврат дескриптора точки сохранения (тип = таблица), который может затем"
" использоваться в :ref:`box.rollback_to_savepoint(savepoint) <box-"
"rollback_to_savepoint>`. Точки сохранения могут быть созданы, пока "
"активна транзакция, и удаляются после окончания транзакции."

#: ../doc/1.10/book/box/box_txn_management.rst:161
msgid "savepoint table"
msgstr "таблица точки сохранения"

#: ../doc/1.10/book/box/box_txn_management.rst:162
#: ../doc/1.10/reference/reference_lua/fiber.rst:1059
msgid "Lua object"
msgstr "Lua-объект"

#: ../doc/1.10/book/box/box_txn_management.rst:164
#: ../doc/1.10/book/box/box_txn_management.rst:177
msgid "error if the savepoint cannot be set in absence of active transaction."
msgstr ""
"ошибка, если точку сохранения нельзя указать в отсутствие активной "
"транзакции."

#: ../doc/1.10/book/box/box_txn_management.rst:167
msgid "**Possible errors:** error if for some reason memory cannot be allocated."
msgstr ""
"**Возможные ошибки:** ошибка, если по какой-либо причине нельзя выделить "
"память."

#: ../doc/1.10/book/box/box_txn_management.rst:173
msgid ""
"Do not end the transaction, but cancel all its data-change and "
":ref:`box.savepoint() <box-savepoint>` operations that were done after "
"the specified savepoint."
msgstr ""
"Запрещение окончания транзакции, но отмена всех изменений и операций "
":ref:`box.savepoint() <box-savepoint>`, сделанных после точки сохранения."

#: ../doc/1.10/book/box/box_txn_management.rst:180
msgid "**Possible errors:** error if the savepoint does not exist."
msgstr "**Возможные ошибки:** ошибка, если отсутствует точка сохранения."

#: ../doc/1.10/book/box/box_txn_management.rst:184
msgid ""
"function f()\n"
"  box.begin()           -- start transaction\n"
"  box.space.t:insert{1} -- this will not be rolled back\n"
"  local s = box.savepoint()\n"
"  box.space.t:insert{2} -- this will be rolled back\n"
"  box.rollback_to_savepoint(s)\n"
"  box.commit()          -- end transaction\n"
"end"
msgstr ""
"function f()\n"
"  box.begin()           -- начало транзакции\n"
"  box.space.t:insert{1} -- это не отменится\n"
"  local s = box.savepoint()\n"
"  box.space.t:insert{2} -- это отменится\n"
"  box.rollback_to_savepoint(s)\n"
"  box.commit()          -- конец транзакции\n"
"end"

#: ../doc/1.10/book/box/box_txn_management.rst:199
msgid ""
"Execute a function, acting as if the function starts with an implicit "
":ref:`box.begin() <box-begin>` and ends with an implicit "
":ref:`box.commit() <box-commit>` if successful, or ends with an implicit "
":ref:`box.rollback() <box-rollback>` if there is an error."
msgstr ""
"Выполнение функции так, как будто функция начинается с явного вызова "
":ref:`box.begin() <box-begin>` и заканчивается неявным вызовом "
":ref:`box.commit() <box-commit>` после успешного выполнения или же "
"заканчивается неявным вызовом :ref:`box.rollback() <box-rollback>` в "
"случае ошибки."

#: ../doc/1.10/book/box/box_txn_management.rst:204
msgid "the result of the function passed to ``atomic()`` as an argument."
msgstr "результат функции передается в ``atomic()`` в качестве аргумента."

#: ../doc/1.10/book/box/box_txn_management.rst:206
msgid "**Possible errors:** any error that :ref:`box.begin() <box-begin>` and"
msgstr ""
"**Возможные ошибки:** любая ошибка, которую могут вызвать "
":ref:`box.begin() <box-begin>`"

#: ../doc/1.10/book/box/box_txn_management.rst:207
msgid ":ref:`box.commit() <box-commit>` can return."
msgstr "и :ref:`box.commit() <box-commit>`."

#: ../doc/1.10/book/box/box_txn_management.rst:213
msgid ""
"Define a trigger for execution when a transaction ends due to an event "
"such as :ref:`box.commit <box-commit>`."
msgstr ""
"Определения триггера, выполняемого в случае окончания транзакции в связи "
"с :ref:`box.commit <box-commit>`."

#: ../doc/1.10/book/box/box_txn_management.rst:216
msgid ""
"The trigger function may take an iterator parameter, as described in an "
"example for this section."
msgstr ""
"Функция с триггером может принимать параметр с итератором, как описано в "
"примере к данному разделу."

#: ../doc/1.10/book/box/box_txn_management.rst:219
msgid "The trigger function should not access any database spaces."
msgstr "Функция с триггером не должна получать доступ к любым спейсам базы данных."

#: ../doc/1.10/book/box/box_txn_management.rst:221
msgid ""
"If the trigger execution fails and raises an error, the effect is severe "
"and should be avoided -- use Lua's ``pcall()`` mechanism around code that"
" might fail."
msgstr ""
"Если триггер не сработает и выдаст ошибку, результат будет "
"неблагоприятным, чего следует избегать -- используйте Lua-механизм "
"``pcall()`` вокруг кода, который может не сработать."

#: ../doc/1.10/book/box/box_txn_management.rst:225
msgid ""
"``box.on_commit()`` must be invoked within a transaction, and the trigger"
" ceases to exist when the transaction ends."
msgstr ""
"``box.on_commit()`` следует вызывать в пределах транзакции, и триггер "
"прекращает существование по окончании транзакции."

#: ../doc/1.10/book/box/box_txn_management.rst:240
msgid "**Simple and useless example:** this will display 'commit happened':"
msgstr "**Простой и бесполезный пример:** покажет, что произошел коммит:"

#: ../doc/1.10/book/box/box_txn_management.rst:242
msgid ""
"function f()\n"
"function f() print('commit happened') end\n"
"box.begin() box.on_commit(f) box.commit()"
msgstr ""
"function f()\n"
"function f() print('commit happened') end\n"
"box.begin() box.on_commit(f) box.commit()"

#: ../doc/1.10/book/box/box_txn_management.rst:248
msgid ""
"But of course there is more to it: the function parameter can be an "
"ITERATOR."
msgstr "Но, конечно, это еще не всё: параметр функции может быть ИТЕРАТОРОМ."

#: ../doc/1.10/book/box/box_txn_management.rst:250
msgid ""
"The iterator goes through the effects of every request that changed a "
"space during the transaction."
msgstr ""
"Итератор проходит по результатам каждого запроса изменения спейса в "
"пределах транзакции."

#: ../doc/1.10/book/box/box_txn_management.rst:253
msgid "The iterator will have:"
msgstr "Итератор будет содержать:"

#: ../doc/1.10/book/box/box_txn_management.rst:255
msgid "an ordinal request number,"
msgstr "порядковый номер запроса,"

#: ../doc/1.10/book/box/box_txn_management.rst:256
msgid ""
"the old value of the tuple before the request (this will be nil for an "
"insert request),"
msgstr ""
"старое значение кортежа до запроса (для запросов вставки это будет "
"нулевое значение nil),"

#: ../doc/1.10/book/box/box_txn_management.rst:258
msgid ""
"the new value of the tuple after the request (this will be nil for a "
"delete request),"
msgstr ""
"новое значение кортежа после запроса (для запросов удаления это будет "
"нулевое значение nil),"

#: ../doc/1.10/book/box/box_txn_management.rst:260
msgid "and the id of the space."
msgstr "и идентификатор спейса."

#: ../doc/1.10/book/box/box_txn_management.rst:262
msgid ""
"**Less simple more useful example:** this will display the effects of two"
" replace requests:"
msgstr ""
"**Более сложный и более полезный пример:** покажет результат двух "
"запросов замены:"

#: ../doc/1.10/book/box/box_txn_management.rst:265
msgid ""
"box.space.test:drop()\n"
"s = box.schema.space.create('test')\n"
"i = box.space.test:create_index('i')\n"
"function f(iterator)\n"
"  for request_number, old_tuple, new_tuple, space_id in iterator() do\n"
"    print('request_number ' .. tostring(request_number))\n"
"    print('  old_tuple ' .. tostring(old_tuple[1]) .. ' ' .. "
"old_tuple[2])\n"
"    print('  new_tuple ' .. tostring(new_tuple[1]) .. ' ' .. "
"new_tuple[2])\n"
"    print('  space_id ' .. tostring(space_id))\n"
"  end\n"
"end\n"
"s:insert{1,'-'}\n"
"box.begin() s:replace{1,'x'} s:replace{1,'y'} box.on_commit(f) "
"box.commit()"
msgstr ""
"box.space.test:drop()\n"
"s = box.schema.space.create('test')\n"
"i = box.space.test:create_index('i')\n"
"function f(iterator)\n"
"  for request_number, old_tuple, new_tuple, space_id in iterator() do\n"
"    print('request_number ' .. tostring(request_number))\n"
"    print('  old_tuple ' .. tostring(old_tuple[1]) .. ' ' .. "
"old_tuple[2])\n"
"    print('  new_tuple ' .. tostring(new_tuple[1]) .. ' ' .. "
"new_tuple[2])\n"
"    print('  space_id ' .. tostring(space_id))\n"
"  end\n"
"end\n"
"s:insert{1,'-'}\n"
"box.begin() s:replace{1,'x'} s:replace{1,'y'} box.on_commit(f) "
"box.commit()"

#: ../doc/1.10/book/box/box_txn_management.rst:281
msgid "The result will look like this:"
msgstr "Результат будет выглядеть следующим образом:"

#: ../doc/1.10/book/box/box_txn_management.rst:283
msgid ""
"tarantool> box.begin() s:replace{1,'x'} s:replace{1,'y'} box.on_commit(f)"
" box.commit()\n"
"request_number 1\n"
"  old_tuple 1 -\n"
"  new_tuple 1 x\n"
"  space_id 517\n"
"request_number 2\n"
"  old_tuple 1 x\n"
"  new_tuple 1 y\n"
"  space_id 517"
msgstr ""
"tarantool> box.begin() s:replace{1,'x'} s:replace{1,'y'} box.on_commit(f)"
" box.commit()\n"
"request_number 1\n"
"  old_tuple 1 -\n"
"  new_tuple 1 x\n"
"  space_id 517\n"
"request_number 2\n"
"  old_tuple 1 x\n"
"  new_tuple 1 y\n"
"  space_id 517"

#: ../doc/1.10/book/box/box_txn_management.rst:299
msgid ""
"Define a trigger for execution when a transaction ends due to an event "
"such as :ref:`box.rollback <box-rollback>`."
msgstr ""
"Определение триггера, выполняемого по окончании транзакции в связи с "
":ref:`box.rollback <box-rollback>`."

#: ../doc/1.10/book/box/box_txn_management.rst:302
msgid ""
"The parameters and warnings are exactly the same as for :ref:`box.on-"
"commit <box-on_commit>`."
msgstr ""
"Используются точно такие же параметры и предупреждения, как в :ref:`box"
".on-commit <box-on_commit>`."

#: ../doc/1.10/book/box/box_txn_management.rst:309
msgid ""
"If a transaction is in progress (for example the user has called "
":ref:`box.begin <box-begin>` and has not yet called either "
":ref:`box.commit <box-commit>` or :ref:`box.rollback <box-rollback>`, "
"return ``true``. Otherwise return ``false``."
msgstr ""
"В процессе транзакции (например, пользователь вызвал :ref:`box.begin "
"<box-begin>` и еще не вызвал ни :ref:`box.commit <box-commit>`, ни "
":ref:`box.rollback <box-rollback>`) возвращается ``true``. В остальных "
"случаях возвращается ``false``."

#: ../doc/1.10/book/box/data_model.rst:39
msgid "Data model"
msgstr "Модель данных"

#: ../doc/1.10/book/box/data_model.rst:41
msgid ""
"This section describes how Tarantool stores values and what operations "
"with data it supports."
msgstr ""
"В этом разделе описывается то, как в Tarantool'е организовано хранение "
"данных и какие операции с данным он поддерживает."

#: ../doc/1.10/book/box/data_model.rst:44
msgid ""
"If you tried to create a database as suggested in our :ref:`\"Getting "
"started\" exercises <getting_started>`, then your test database now looks"
" like this:"
msgstr ""
"Если вы пробовали создать базу данных, как предлагается в упражнениях в "
":ref:`\"Руководстве для начинающих\" <getting_started>`, то ваша тестовая"
" база данных выглядит следующим образом:"

#: ../doc/1.10/book/box/data_model.rst:54
msgid "Space"
msgstr "Спейс"

#: ../doc/1.10/book/box/data_model.rst:56
msgid "A **space** -- 'tester' in our example -- is a container."
msgstr "*Спейс* -- с именем 'tester' в нашем примере -- это контейнер."

#: ../doc/1.10/book/box/data_model.rst:58
msgid ""
"When Tarantool is being used to store data, there is always at least one "
"space. Each space has a unique **name** specified by the user. Besides, "
"each space has a unique **numeric identifier** which can be specified by "
"the user, but usually is assigned automatically by Tarantool. Finally, a "
"space always has an **engine**: *memtx* (default) -- in-memory engine, "
"fast but limited in size, or *vinyl* -- on-disk engine for huge data "
"sets."
msgstr ""
"Когда Tarantool используется для хранения данных, всегда существует хотя "
"бы один спейс. У каждого спейса есть уникальное **имя**, указанное "
"пользователем. Кроме того, пользователь может указать уникальный "
"**числовой идентификатор**, но обычно Tarantool назначает его "
"автоматически. Наконец, в спейсе всегда есть **движок**: *memtx* (по "
"умолчанию) -- in-memory движок, быстрый, но ограниченный в размере, или "
"*vinyl* -- дисковый движок для огромного количества данных."

#: ../doc/1.10/book/box/data_model.rst:65
msgid ""
"A space is a container for :ref:`tuples <index-box_tuple>`. To be "
"functional, it needs to have a :ref:`primary index <index-box_index>`. It"
" can also have secondary indexes."
msgstr ""
"Спейс -- это контейнер для :ref:`кортежей <index-box_tuple>`. Для работы "
"ему необходим :ref:`первичный индекс <index-box_index>`. Также возможно "
"использование вторичных индексов."

#: ../doc/1.10/book/box/data_model.rst:73
#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:52
msgid "Tuple"
msgstr "Кортеж"

#: ../doc/1.10/book/box/data_model.rst:75
msgid ""
"A **tuple** plays the same role as a “row” or a “record”, and the "
"components of a tuple (which we call “fields”) play the same role as a "
"“row column” or “record field”, except that:"
msgstr ""
"**Кортеж** играет такую же роль, как “строка” или “запись”, а компоненты "
"кортежа (которые мы называем “полями”) играют такую же роль, что и "
"“столбец” или “поле записи”, не считая того, что:"

#: ../doc/1.10/book/box/data_model.rst:79
msgid "fields can be composite structures, such as arrays or maps, and"
msgstr ""
"поля могут представлять собой композитные структуры, такие как таблицы "
"типа массива или ассоциативного массива, а также"

#: ../doc/1.10/book/box/data_model.rst:80
msgid "fields don't need to have names."
msgstr "полям не нужны имена."

#: ../doc/1.10/book/box/data_model.rst:82
msgid ""
"Any given tuple may have any number of fields, and the fields may be of "
"different :ref:`types <index-box_data-types>`. The identifier of a field "
"is the field's number, base 1 (in Lua and other 1-based languages) or "
"base 0 (in PHP or C/C++). For example, ``1`` or ``0`` can be used in some"
" contexts to refer to the first field of a tuple."
msgstr ""
"В любом кортеже может быть любое количество полей, и это могут быть поля "
"разных :ref:`типов <index-box_data-types>`. Идентификатором поля является"
" его номер, начиная с 1 (в Lua и других языках с индексацией с 1) или с 0"
" (в PHP или C/C++). Например, ``1`` или ``0`` могут использоваться в "
"некоторых контекстах для обозначения первого поля кортежа."

#: ../doc/1.10/book/box/data_model.rst:89
msgid ""
"Tuples in Tarantool are stored as `MsgPack "
"<https://en.wikipedia.org/wiki/MessagePack>`_ arrays."
msgstr ""
"Кортежи в Tarantool'е хранятся в виде массивов `MsgPack "
"<https://en.wikipedia.org/wiki/MessagePack>`_."

#: ../doc/1.10/book/box/data_model.rst:92
msgid ""
"When Tarantool returns a tuple value in console, it uses the `YAML "
"<https://en.wikipedia.org/wiki/YAML>`_ format, for example: ``[3, 'Ace of"
" Base', 1993]``."
msgstr ""
"Когда Tarantool выводит значение в кортеже в консоль, используется формат"
" `YAML <https://ru.wikipedia.org/wiki/YAML>`_, например: ``[3, 'Ace of  "
"Base', 1993]``."

#: ../doc/1.10/book/box/data_model.rst:102
msgid "An **index** is a group of key values and pointers."
msgstr "**Индекс** -- это совокупность значений ключей и указателей."

#: ../doc/1.10/book/box/data_model.rst:104
msgid ""
"As with spaces, you should specify the index **name**, and let Tarantool "
"come up with a unique **numeric identifier** (\"index id\")."
msgstr ""
"Как и для спейсов, индексам следует указать **имена**, а Tarantool "
"определит уникальный **числовой идентификатор** (\"ID индекса\")."

#: ../doc/1.10/book/box/data_model.rst:107
msgid ""
"An index always has a **type**. The default index type is 'TREE'. TREE "
"indexes are provided by all Tarantool engines, can index unique and non-"
"unique values, support partial key searches, comparisons and ordered "
"results. Additionally, memtx engine supports HASH, RTREE and BITSET "
"indexes."
msgstr ""
"У индекса всегда есть определенный **тип**. Тип индекса по умолчанию -- "
"'TREE'. Все движки Tarantool'а предоставляют TREE-индексы, которые могут "
"индексировать уникальные и неуникальные значения, поддерживают поиск по "
"компонентам ключа, сравнение ключей и упорядоченные результаты. Кроме "
"того, движок memtx поддерживает следующие индексы: HASH, RTREE и BITSET."

#: ../doc/1.10/book/box/data_model.rst:112
msgid ""
"An index may be **multi-part**, that is, you can declare that an index "
"key value is composed of two or more fields in the tuple, in any order. "
"For example, for an ordinary TREE index, the maximum number of parts is "
"255."
msgstr ""
"Индекс может быть **многокомпонентным**, то есть можно объявить, что ключ"
" индекса состоит из двух или более полей в кортеже в любом порядке. "
"Например, для обычного TREE-индекса максимальное количество частей равно "
"255."

#: ../doc/1.10/book/box/data_model.rst:116
msgid ""
"An index may be **unique**, that is, you can declare that it would be "
"illegal to have the same key value twice."
msgstr ""
"Индекс может быть **уникальным**, то есть можно объявить, что недопустимо"
" дважды задавать одно значение ключа."

#: ../doc/1.10/book/box/data_model.rst:119
msgid ""
"The first index defined on a space is called the **primary key index**, "
"and it must be unique. All other indexes are called **secondary "
"indexes**, and they may be non-unique."
msgstr ""
"Первый индекс, определенный для спейса, называется **первичный индекс**. "
"Он должен быть уникальным. Все остальные индексы называются **вторичными "
"индексами**, они могут строиться по неуникальным значениям."

#: ../doc/1.10/book/box/data_model.rst:123
msgid ""
"An index definition may include identifiers of tuple fields and their "
"expected **types** (see allowed :ref:`indexed field types <index-"
"box_indexed-field-types>` below)."
msgstr ""
"Индекс может содержать идентификаторы полей кортежа и их предполагаемые "
"**типы** (см. допустимые :ref:`типы индексированных полей <index-"
"box_indexed-field-types>` ниже)."

#: ../doc/1.10/book/box/data_model.rst:127
msgid ""
"In our example, we first defined the primary index (named 'primary') "
"based on field #1 of each tuple:"
msgstr ""
"В нашем примере для начала определяем первичный индекс (под названием "
"'primary') по полю №1 каждого кортежа:"

#: ../doc/1.10/book/box/data_model.rst:130
msgid ""
"tarantool> i = s:create_index('primary', {type = 'hash', parts = {1, "
"'unsigned'}})"
msgstr ""
"tarantool> i = s:create_index('primary', {type = 'hash', parts = {1, "
"'unsigned'}})"

#: ../doc/1.10/book/box/data_model.rst:134
msgid ""
"The effect is that, for all tuples in space 'tester', field #1 must exist"
" and must contain an unsigned integer. The index type is 'hash', so "
"values in field #1 must be unique, because keys in HASH indexes are "
"unique."
msgstr ""
"Смысл в том, что поле №1 должно существовать и содержать целое число без "
"знака для всех кортежей в спейсе 'tester'. Тип индекса -- 'hash', поэтому"
" значения в поле №1 должны быть уникальными, поскольку ключи в "
"HASH-индексах уникальны."

#: ../doc/1.10/book/box/data_model.rst:139
msgid ""
"After that, we defined a secondary index (named 'secondary') based on "
"field #2 of each tuple:"
msgstr ""
"После этого мы определим вторичный индекс (под названием 'secondary') по "
"полю №2 каждого кортежа:"

#: ../doc/1.10/book/box/data_model.rst:142
msgid ""
"tarantool> i = s:create_index('secondary', {type = 'tree', parts = {2, "
"'string'}})"
msgstr ""
"tarantool> i = s:create_index('secondary', {type = 'tree', parts = {2, "
"'string'}})"

#: ../doc/1.10/book/box/data_model.rst:146
msgid ""
"The effect is that, for all tuples in space 'tester', field #2 must exist"
" and must contain a string. The index type is 'tree', so values in field "
"#2 must not be unique, because keys in TREE indexes may be non-unique."
msgstr ""
"Смысл в том, что поле №2 должно существовать и содержать строку для всех "
"кортежей в спейсе 'tester'. Тип индекса -- 'tree', поэтому значения в "
"поле №2 не должны быть уникальными, поскольку ключи в TREE-индексах могут"
" не быть уникальными."

#: ../doc/1.10/book/box/data_model.rst:153
msgid ""
"Space definitions and index definitions are stored permanently in "
"Tarantool's system spaces :ref:`_space <box_space-space>` and "
":ref:`_index <box_space-index>` (for details, see reference on "
":ref:`box.space <box_space>` submodule)."
msgstr ""
"Определения спейса и определения индексов хранятся в системных спейсах "
"Tarantool'а :ref:`_space <box_space-space>` и :ref:`_index <box_space-"
"index>` соответственно (для получения подробной информации см. справочник"
" по вложенному модулю :ref:`box.space <box_space>`)."

#: ../doc/1.10/book/box/data_model.rst:157
msgid ""
"You can add, drop, or alter the definitions at runtime, with some "
"restrictions. See syntax details in reference on :ref:`box <box-module>` "
"module."
msgstr ""
"Можно добавлять, опускать или изменять определения во время исполнения "
"кода с некоторыми ограничениями. Более подробно о синтаксисе см. в "
"справочнике по модулю :ref:`box <box-module>`."

#: ../doc/1.10/book/box/data_model.rst:164
msgid "Data types"
msgstr "Типы данных"

#: ../doc/1.10/book/box/data_model.rst:166
msgid ""
"Tarantool is both a database and an application server. Hence a developer"
" often deals with two type sets: the programming language types (e.g. "
"Lua) and the types of the Tarantool storage format (MsgPack)."
msgstr ""
"Tarantool представляет собой базу данных и сервер приложений "
"одновременно. Следовательно, разработчик часто работает с двумя наборами "
"типов: типы языка программирования (например, Lua) и типы формата "
"хранилища Tarantool (MsgPack)."

#: ../doc/1.10/book/box/data_model.rst:175
msgid "Lua vs MsgPack"
msgstr "Lua в сравнении с MsgPack"

#: ../doc/1.10/book/box/data_model.rst:185
msgid "Scalar / compound"
msgstr "Скалярный / составной"

#: ../doc/1.10/book/box/data_model.rst:185
msgid "MsgPack |nbsp| type"
msgstr "MsgPack-тип |nbsp|"

#: ../doc/1.10/book/box/data_model.rst:185
msgid "Lua type"
msgstr "Lua-тип"

#: ../doc/1.10/book/box/data_model.rst:185
msgid "Example value"
msgstr "Пример значения"

#: ../doc/1.10/book/box/data_model.rst:187
#: ../doc/1.10/book/box/data_model.rst:189
#: ../doc/1.10/book/box/data_model.rst:191
#: ../doc/1.10/book/box/data_model.rst:193
#: ../doc/1.10/book/box/data_model.rst:195
msgid "scalar"
msgstr "скалярный"

#: ../doc/1.10/book/box/data_model.rst:187
msgid "\"`nil`_\""
msgstr "\"`nil`_\" (нулевое значение)"

#: ../doc/1.10/book/box/data_model.rst:187
#: ../doc/1.10/reference/reference_lua/msgpack.rst:256
msgid "msgpack.NULL"
msgstr "msgpack.NULL"

#: ../doc/1.10/book/box/data_model.rst:189
msgid "\"`boolean`_\""
msgstr "\"`boolean`_\" (логическое значение)"

#: ../doc/1.10/book/box/data_model.rst:189
#: ../doc/1.10/book/box/data_model.rst:332
#: ../doc/1.10/book/box/data_model.rst:340
#: ../doc/1.10/reference/reference_lua/msgpack.rst:246
msgid "true"
msgstr "true"

#: ../doc/1.10/book/box/data_model.rst:191
msgid "\"`string`_\""
msgstr "\"`string`_\" (строка)"

#: ../doc/1.10/book/box/data_model.rst:191
msgid "'A B C'"
msgstr "'A B C'"

#: ../doc/1.10/book/box/data_model.rst:193
#: ../doc/1.10/reference/reference_lua/errno.rst:79
msgid "integer"
msgstr "integer (целое число)"

#: ../doc/1.10/book/box/data_model.rst:193
#: ../doc/1.10/book/box/data_model.rst:195
msgid "\"`number`_\""
msgstr "\"`number`_\" (число)"

#: ../doc/1.10/book/box/data_model.rst:193
msgid "12345"
msgstr "12345"

#: ../doc/1.10/book/box/data_model.rst:195
msgid "double"
msgstr "double (числа с двойной точностью)"

#: ../doc/1.10/book/box/data_model.rst:195
msgid "1.2345"
msgstr "1,2345"

#: ../doc/1.10/book/box/data_model.rst:197
#: ../doc/1.10/book/box/data_model.rst:199
#: ../doc/1.10/book/box/data_model.rst:201
msgid "compound"
msgstr "составной"

#: ../doc/1.10/book/box/data_model.rst:197
msgid "map"
msgstr "map (ассоциативный массив)"

#: ../doc/1.10/book/box/data_model.rst:197
msgid "\"`table`_\" (with string keys)"
msgstr "\"`table`_\" (таблица со строковыми ключами)"

#: ../doc/1.10/book/box/data_model.rst:197
msgid "{'a': 5, 'b': 6}"
msgstr "{'a': 5, 'b': 6}"

#: ../doc/1.10/book/box/data_model.rst:199
#: ../doc/1.10/book/box/data_model.rst:201
msgid "array"
msgstr "array (массив)"

#: ../doc/1.10/book/box/data_model.rst:199
msgid "\"`table`_\" (with integer keys)"
msgstr "\"`table`_\" (таблица с целочисленными ключами)"

#: ../doc/1.10/book/box/data_model.rst:199
msgid "[1, 2, 3, 4, 5]"
msgstr "[1, 2, 3, 4, 5]"

#: ../doc/1.10/book/box/data_model.rst:201
msgid "tuple (\"`cdata`_\")"
msgstr "tuple (\"`cdata`_\") (кортеж)"

#: ../doc/1.10/book/box/data_model.rst:201
msgid "[12345, 'A B C']"
msgstr "[12345, 'A B C']"

#: ../doc/1.10/book/box/data_model.rst:211
msgid ""
"In Lua, a **nil** type has only one possible value, also called *nil* "
"(displayed as **null** on Tarantool's command line, since the output is "
"in the YAML format). Nils may be compared to values of any types with == "
"(is-equal) or ~= (is-not-equal), but other operations will not work. Nils"
" may not be used in Lua tables; the workaround is to use "
":ref:`msgpack.NULL <msgpack-null>`"
msgstr ""
"В языке Lua тип *nil* (нулевой) может иметь только одно значение, также "
"называемое *nil* (отображаемое как **null** в командной строке "
"Tarantool'а, поскольку значения выводятся в формате YAML). Нулевое "
"значение можно сравнивать со значениями любых типов с помощью операторов "
"== (равен) или ~= (не равен), но никакие другие операции для нулевых "
"значений не доступны. Нулевые значения также нельзя использовать в "
"Lua-таблицах; вместо нулевого значения в таком случае можно указать "
":ref:`msgpack.NULL <msgpack-null>`"

#: ../doc/1.10/book/box/data_model.rst:219
msgid "A **boolean** is either ``true`` or ``false``."
msgstr ""
"Тип *boolean* (логический) может иметь только значения ``true`` или "
"``false``."

#: ../doc/1.10/book/box/data_model.rst:223
msgid ""
"A **string** is a variable-length sequence of bytes, usually represented "
"with alphanumeric characters inside single quotes. In both Lua and "
"MsgPack, strings are treated as binary data, with no attempts to "
"determine a string's character set or to perform any string conversion --"
" unless there is an optional :ref:`collation <index-collation>`. So, "
"usually, string sorting and comparison are done byte-by-byte, without any"
" special collation rules applied. (Example: numbers are ordered by their "
"point on the number line, so 2345 is greater than 500; meanwhile, strings"
" are ordered by the encoding of the first byte, then the encoding of the "
"second byte, and so on, so '2345' is less than '500'.)"
msgstr ""
"Тип **string**  (строка) представляет собой последовательность байтов "
"переменной длины, обычно представленную буквенно-цифровые символы в "
"одинарных кавычках. Как в Lua, так и в MsgPack строки рассматриваются как"
" бинарные данные без попыток определить набор символов строки или "
"выполнить преобразование строки -- кроме случаев, когда есть опциональное"
" :ref:`сравнение символов <index-collation>`. Таким образом, обычно "
"сортировка и сравнение строк выполняются побайтово, не применяя "
"дополнительных правил сравнения символов. (Пример: числа упорядочены по "
"их положению на числовой прямой, поэтому 2345 больше, чем 500; а строки "
"упорядочены по кодировке первого байта, затем кодировке второго байта и "
"так далее, таким образом, '2345' меньше, чем '500'.)"

#: ../doc/1.10/book/box/data_model.rst:236
msgid ""
"In Lua, a **number** is double-precision floating-point, but Tarantool "
"allows both integer and floating-point values. Tarantool will try to "
"store a Lua number as floating-point if the value contains a decimal "
"point or is very large (greater than 100 trillion = 1e14), otherwise "
"Tarantool will store it as an integer. To ensure that even very large "
"numbers are stored as integers, use the :ref:`tonumber64 <other-"
"tonumber64>` function, or the LL (Long Long) suffix, or the ULL (Unsigned"
" Long Long) suffix. Here are examples of numbers using regular notation, "
"exponential notation, the ULL suffix and the ``tonumber64`` function: "
"``-55``, ``-2.7e+20``, ``100000000000000ULL``, "
"``tonumber64('18446744073709551615')``."
msgstr ""
"В языке Lua тип **number** (число) -- это число с плавающей запятой "
"двойной точности, но в Tarantool'е можно использовать как целые числа, "
"так и числа с плавающей запятой. Tarantool по возможности сохраняет числа"
" языка Lua в виде чисел с плавающей запятой, если числовое значение "
"содержит десятичную запятую или если оно очень велико (более 100 "
"триллионов = 1e14). В противном случае, Tarantool сохраняет такое "
"значение в виде целого числа. Чтобы даже очень большие величины "
"гарантированно обрабатывались как целые числа, используйте функцию "
":ref:`tonumber64 <other-tonumber64>`, либо приписывайте в конце суффикс "
"LL (Long Long) или ULL (Unsigned Long Long). Вот примеры записи чисел в "
"обычном представлении, экспоненциальном, с суффиксом ULL и с "
"использованием функции ``tonumber64``:  ``-55``, ``-2.7e+20``, "
"``100000000000000ULL``, ``tonumber64('18446744073709551615')``."

#: ../doc/1.10/book/box/data_model.rst:247
msgid ""
"Lua **tables** with string keys are stored as MsgPack maps; Lua tables "
"with integer keys starting with 1 -- as MsgPack arrays. Nils may not be "
"used in Lua tables; the workaround is to use :ref:`msgpack.NULL <msgpack-"
"null>`"
msgstr ""
"В Lua **tables** (таблицы) со строковыми ключами хранятся как "
"ассоциативные массивы в MsgPack; Lua-таблицы с целочисленными ключами, "
"начиная с 1, хранятся как массивы в MsgPack. Нулевые значения нельзя "
"использовать в Lua-таблицах; вместо нулевого значения в таком случае "
"можно указать :ref:`msgpack.NULL <msgpack-null>`"

#: ../doc/1.10/book/box/data_model.rst:252
msgid ""
"A **tuple** is a light reference to a MsgPack array stored in the "
"database. It is a special type (cdata) to avoid conversion to a Lua table"
" on retrieval. A few functions may return tables with multiple tuples. "
"For more tuple examples, see :ref:`box.tuple <box_tuple>`."
msgstr ""
"Тип **tuple** (кортеж) представляет собой легкую ссылку на массив "
"MsgPack, который хранится в базе данных. Это особый тип (cdata), чтобы "
"избежать конвертации в Lua-таблицу при выборке данных. Некоторые функции "
"могут возвращать таблицы с множеством кортежей. Примеры с кортежами см. в"
" :ref:`box.tuple <box_tuple>`."

#: ../doc/1.10/book/box/data_model.rst:259
msgid ""
"Tarantool uses the MsgPack format for database storage, which is "
"variable-length. So, for example, the smallest number requires only one "
"byte, but the largest number requires nine bytes."
msgstr ""
"Tarantool использует формат MsgPack для хранения в базе данных переменной"
" длины. Поэтому, например, для наименьшего числа требуется только один "
"байт, но для наибольшего числа требуется девять байтов."

#: ../doc/1.10/book/box/data_model.rst:263
msgid "Examples of insert requests with different data types:"
msgstr "Примеры запроса вставки с разными типами данных:"

#: ../doc/1.10/book/box/data_model.rst:265
msgid ""
"tarantool> box.space.K:insert{1,nil,true,'A B C',12345,1.2345}\n"
"---\n"
"- [1, null, true, 'A B C', 12345, 1.2345]\n"
"...\n"
"tarantool> box.space.K:insert{2,{['a']=5,['b']=6}}\n"
"---\n"
"- [2, {'a': 5, 'b': 6}]\n"
"...\n"
"tarantool> box.space.K:insert{3,{1,2,3,4,5}}\n"
"---\n"
"- [3, [1, 2, 3, 4, 5]]\n"
"..."
msgstr ""
"tarantool> box.space.K:insert{1,nil,true,'A B C',12345,1.2345}\n"
"---\n"
"- [1, null, true, 'A B C', 12345, 1.2345]\n"
"...\n"
"tarantool> box.space.K:insert{2,{['a']=5,['b']=6}}\n"
"---\n"
"- [2, {'a': 5, 'b': 6}]\n"
"...\n"
"tarantool> box.space.K:insert{3,{1,2,3,4,5}}\n"
"---\n"
"- [3, [1, 2, 3, 4, 5]]\n"
"..."

#: ../doc/1.10/book/box/data_model.rst:284
msgid "Indexed field types"
msgstr "Типы индексированных полей"

#: ../doc/1.10/book/box/data_model.rst:286
msgid ""
"Indexes restrict values which Tarantool's MsgPack may contain. This is "
"why, for example, 'unsigned' is a separate **indexed field type**, "
"compared to ‘integer’ data type in MsgPack: they both store ‘integer’ "
"values, but an 'unsigned' index contains only *non-negative* integer "
"values and an ‘integer’ index contains *all* integer values."
msgstr ""
"Индексы ограничивают значения, которые может содержать MsgPack в "
"Tarantool'е. Вот почему, например, тип 'unsigned' (без знака) "
"представляет собой отдельный **тип индексированного поля** в сравнении с "
"типом данных ‘integer’ (целое число) в MsgPack: оба содержат значения с "
"целыми числами, но индекс 'unsigned' содержит только *неотрицательные* "
"целые числовые значения, а индекс ‘integer’ содержит *все* целые числовые"
" значения."

#: ../doc/1.10/book/box/data_model.rst:292
msgid "Here's how Tarantool indexed field types correspond to MsgPack data types."
msgstr ""
"Вот как типы индексированных полей в Tarantool'е соответствуют типам "
"данных MsgPack."

#: ../doc/1.10/book/box/data_model.rst:305
msgid "Indexed field type"
msgstr "Тип индексированного поля"

#: ../doc/1.10/book/box/data_model.rst:305
msgid "MsgPack data type |br| (and possible values)"
msgstr "Тип данных MsgPack |br| (и возможные значения)"

#: ../doc/1.10/book/box/data_model.rst:308
msgid "**unsigned** (may also be called ‘uint’ or ‘num’, but ‘num’ is deprecated)"
msgstr ""
"**unsigned** (без знака -- может также называться ‘uint’ или ‘num’, но "
"‘num’ объявлен устаревшим)"

#: ../doc/1.10/book/box/data_model.rst:308
msgid ""
"**integer** (integer between 0 and 18446744073709551615, i.e. about 18 "
"quintillion)"
msgstr ""
"**integer** (целое число в диапазоне от 0 до 18 446 744 073 709 551 615, "
"т.е. около 18 квинтиллионов)"

#: ../doc/1.10/book/box/data_model.rst:308
#: ../doc/1.10/book/box/data_model.rst:328
msgid "TREE, BITSET or HASH"
msgstr "TREE, BITSET или HASH"

#: ../doc/1.10/book/box/data_model.rst:308
msgid "123456"
msgstr "123456"

#: ../doc/1.10/book/box/data_model.rst:313
msgid "**integer** (may also be called ‘int’)"
msgstr "**integer** (целое число -- может также называться ‘int’)"

#: ../doc/1.10/book/box/data_model.rst:313
#: ../doc/1.10/book/box/data_model.rst:318
#: ../doc/1.10/book/box/data_model.rst:343
msgid ""
"**integer** (integer between -9223372036854775808 and "
"18446744073709551615)"
msgstr ""
"``integer`` (целое число в диапазоне от -9 223 372 036 854 775 808 до 18 "
"446 744 073 709 551 615)"

#: ../doc/1.10/book/box/data_model.rst:313
#: ../doc/1.10/book/box/data_model.rst:318
#: ../doc/1.10/book/box/data_model.rst:332
#: ../doc/1.10/book/box/data_model.rst:340
msgid "TREE or HASH"
msgstr "TREE или HASH"

#: ../doc/1.10/book/box/data_model.rst:313
msgid "-2^63"
msgstr "-2^63"

#: ../doc/1.10/book/box/data_model.rst:323
#: ../doc/1.10/book/box/data_model.rst:348
msgid ""
"**double** (single-precision floating point number or double-precision "
"floating point number)"
msgstr ""
"**double** (число с плавающей запятой с одинарной точностью или с двойной"
" точностью)"

#: ../doc/1.10/book/box/data_model.rst:318
#: ../doc/1.10/book/box/data_model.rst:344
msgid "1.234"
msgstr "1,234"

#: ../doc/1.10/book/box/data_model.rst:320
msgid "-44"
msgstr "-44"

#: ../doc/1.10/book/box/data_model.rst:322
msgid "1.447e+44"
msgstr "1,447e+44"

#: ../doc/1.10/book/box/data_model.rst:328
msgid "**string** (may also be called ‘str’)"
msgstr "**string** (строка -- может также называться ‘str’)"

#: ../doc/1.10/book/box/data_model.rst:328
msgid "**string** (any set of octets, up to the maximum length)"
msgstr ""
"**string** (строка -- любая последовательность октетов до максимальной "
"длины)"

#: ../doc/1.10/book/box/data_model.rst:328
msgid "‘A B C’"
msgstr "‘A B C’"

#: ../doc/1.10/book/box/data_model.rst:330
msgid "‘\\65 \\66 \\67’"
msgstr "‘\\65 \\66 \\67’"

#: ../doc/1.10/book/box/data_model.rst:332
#: ../doc/1.10/book/box/data_model.rst:340
msgid "**bool** (true or false)"
msgstr "**bool** (логический -- true или false)"

#: ../doc/1.10/book/box/data_model.rst:335
msgid "**array** (list of numbers representing points in a geometric figure)"
msgstr ""
"**array** (массив -- список чисел, который представляет собой точки в "
"геометрической фигуре)"

#: ../doc/1.10/book/box/data_model.rst:335
msgid "RTREE"
msgstr "RTREE"

#: ../doc/1.10/book/box/data_model.rst:335
msgid "{10, 11}"
msgstr "{10, 11}"

#: ../doc/1.10/book/box/data_model.rst:337
msgid "{3, 5, 9, 10}"
msgstr "{3, 5, 9, 10}"

#: ../doc/1.10/book/box/data_model.rst:353
msgid "**string** (any set of octets)"
msgstr "**string** (строковое значение, т.е. любая последовательность октетов)"

#: ../doc/1.10/book/box/data_model.rst:355
msgid ""
"Note: When there is a mix of types, the key order is: booleans, then "
"numbers, then strings."
msgstr ""
"Примечание: в сочетании различных типов порядок будет следующим: "
"логические значения, затем числовые, затем строковые."

#: ../doc/1.10/book/box/data_model.rst:342
msgid "-1"
msgstr "-1"

#: ../doc/1.10/book/box/data_model.rst:346
msgid "‘’"
msgstr "‘’"

#: ../doc/1.10/book/box/data_model.rst:348
msgid "‘ру’"
msgstr "‘ру’"

#: ../doc/1.10/book/box/data_model.rst:365
msgid "Collations"
msgstr "Сортировка"

#: ../doc/1.10/book/box/data_model.rst:367
msgid ""
"By default, when Tarantool compares strings, it uses what we call a "
"**\"binary\" collation**. The only consideration here is the numeric "
"value of each byte in the string. Therefore, if the string is encoded "
"with ASCII or UTF-8, then ``'A' < 'B' < 'a'``, because the encoding of "
"'A' (what used to be called the \"ASCII value\") is 65, the encoding of "
"'B' is 66, and the encoding of 'a' is 98. Binary collation is best if you"
" prefer fast deterministic simple maintenance and searching with "
"Tarantool indexes."
msgstr ""
"По умолчанию, когда Tarantool сравнивает строки, он использует то, что мы"
" называем **\"бинарной\" сортировкой**. Единственный фактор, который "
"учитывается, это числовое значение каждого байта в строке. Таким образом,"
" если строка кодируется по ASCII или UTF-8, то ``'A' < 'B' < 'a'``, "
"поскольку в кодировке 'A' (что раньше называлось \"значение ASCII\") "
"соответствует 65, 'B' -- 66, а 'a' -- 98. Бинарная сортировка подходит "
"лучше всего для быстрого детерминированного простого обслуживания и "
"поиска с помощью индексов Tarantool'а."

#: ../doc/1.10/book/box/data_model.rst:376
msgid ""
"But if you want the ordering that you see in phone books and "
"dictionaries, then you need Tarantool's **optional collations** -- "
"``unicode`` and ``unicode_ci`` -- that allow for ``'a' < 'A' < 'B'`` and "
"``'a' = 'A' < 'B'`` respectively."
msgstr ""
"Однако если необходимо распределение, как в телефонных справочниках и "
"словарях, то вам нужна **опциональная сортировка** Tarantool'а -- "
"``unicode`` и ``unicode_ci`` -- которые обеспечивают ``'a' < 'A' < 'B'`` "
"и ``'a' = 'A' < 'B'``  соответственно."

#: ../doc/1.10/book/box/data_model.rst:381
msgid ""
"Optional collations use the ordering according to the `Default Unicode "
"Collation Element Table (DUCET) "
"<http://unicode.org/reports/tr10/#Default_Unicode_Collation_Element_Table>`_"
" and the rules described in `Unicode® Technical Standard #10 Unicode "
"Collation Algorithm (UTS #10 UCA) <http://unicode.org/reports/tr10>`_. "
"The only difference between the two collations is about `weights "
"<https://unicode.org/reports/tr10/#Weight_Level_Defn>`_:"
msgstr ""
"Опциональная сортировка использует распределение в соответствии с "
"`Таблицей сортировки символов Юникода по умолчанию (DUCET) "
"<http://unicode.org/reports/tr10/#Default_Unicode_Collation_Element_Table>`_"
" и правилами, указанными в `Техническом стандарте Юникода №10 -- Алгоритм"
" сортировки по Юникоду (Unicode® Technical Standard #10 Unicode Collation"
" Algorithm (UTS #10 UCA)) <http://unicode.org/reports/tr10>`_. "
"Единственное отличие между двумя сортировками -- `вес "
"<https://unicode.org/reports/tr10/#Weight_Level_Defn>`_:"

#: ../doc/1.10/book/box/data_model.rst:388
msgid ""
"``unicode`` collation observes L1 and L2 and L3 weights (strength = "
"'tertiary'),"
msgstr ""
"сортировка ``unicode`` принимает во внимание уровни веса L1, L2 и L3 "
"(уровень = 'tertiary', третичный),"

#: ../doc/1.10/book/box/data_model.rst:389
msgid ""
"``unicode_ci`` collation observes only L1 weights (strength = 'primary'),"
" so for example 'a' = 'A' = 'á' = 'Á'."
msgstr ""
"сортировка ``unicode_ci`` принимает во внимание только вес L1 (уровень = "
"'primary', первичный), поэтому, например, 'a' = 'A' = 'á' = 'Á'."

#: ../doc/1.10/book/box/data_model.rst:391
msgid "As an example, let's take some Russian words:"
msgstr "Для примера возьмем некоторые русские слова:"

#: ../doc/1.10/book/box/data_model.rst:393
msgid ""
"'ЕЛЕ'\n"
"'елейный'\n"
"'ёлка'\n"
"'еловый'\n"
"'елозить'\n"
"'Ёлочка'\n"
"'ёлочный'\n"
"'ЕЛь'\n"
"'ель'"
msgstr ""
"'ЕЛЕ'\n"
"'елейный'\n"
"'ёлка'\n"
"'еловый'\n"
"'елозить'\n"
"'Ёлочка'\n"
"'ёлочный'\n"
"'ЕЛь'\n"
"'ель'"

#: ../doc/1.10/book/box/data_model.rst:405
msgid "...and show the difference in ordering and selecting by index:"
msgstr "...и покажем разницу в упорядочении и выборке по индексу:"

#: ../doc/1.10/book/box/data_model.rst:407
msgid "with ``unicode`` collation:"
msgstr "с сортировкой по ``unicode``:"

#: ../doc/1.10/book/box/data_model.rst:409
msgid ""
"tarantool> box.space.T:create_index('I', {parts = {{1,'str', "
"collation='unicode'}}})\n"
"...\n"
"tarantool> box.space.T.index.I:select()\n"
"---\n"
"- - ['ЕЛЕ']\n"
"  - ['елейный']\n"
"  - ['ёлка']\n"
"  - ['еловый']\n"
"  - ['елозить']\n"
"  - ['Ёлочка']\n"
"  - ['ёлочный']\n"
"  - ['ель']\n"
"  - ['ЕЛь']\n"
"...\n"
"tarantool> box.space.T.index.I:select{'ЁлКа'}\n"
"---\n"
"- []\n"
"..."
msgstr ""
"tarantool> box.space.T:create_index('I', {parts = {{1,'str', "
"collation='unicode'}}})\n"
"...\n"
"tarantool> box.space.T.index.I:select()\n"
"---\n"
"- - ['ЕЛЕ']\n"
"  - ['елейный']\n"
"  - ['ёлка']\n"
"  - ['еловый']\n"
"  - ['елозить']\n"
"  - ['Ёлочка']\n"
"  - ['ёлочный']\n"
"  - ['ель']\n"
"  - ['ЕЛь']\n"
"...\n"
"tarantool> box.space.T.index.I:select{'ЁлКа'}\n"
"---\n"
"- []\n"
"..."

#: ../doc/1.10/book/box/data_model.rst:430
msgid "with ``unicode_ci`` collation:"
msgstr "с сортировкой по ``unicode_ci``:"

#: ../doc/1.10/book/box/data_model.rst:432
msgid ""
"tarantool> box.space.T:create_index('I', {parts = {{1,'str', "
"collation='unicode_ci'}}})\n"
"...\n"
"tarantool> box.space.S.index.I:select()\n"
"---\n"
"- - ['ЕЛЕ']\n"
"  - ['елейный']\n"
"  - ['ёлка']\n"
"  - ['еловый']\n"
"  - ['елозить']\n"
"  - ['Ёлочка']\n"
"  - ['ёлочный']\n"
"  - ['ЕЛь']\n"
"...\n"
"tarantool> box.space.S.index.I:select{'ЁлКа'}\n"
"---\n"
"- - ['ёлка']\n"
"..."
msgstr ""
"tarantool> box.space.T:create_index('I', {parts = {{1,'str', "
"collation='unicode_ci'}}})\n"
"...\n"
"tarantool> box.space.S.index.I:select()\n"
"---\n"
"- - ['ЕЛЕ']\n"
"  - ['елейный']\n"
"  - ['ёлка']\n"
"  - ['еловый']\n"
"  - ['елозить']\n"
"  - ['Ёлочка']\n"
"  - ['ёлочный']\n"
"  - ['ЕЛь']\n"
"...\n"
"tarantool> box.space.S.index.I:select{'ЁлКа'}\n"
"---\n"
"- - ['ёлка']\n"
"..."

#: ../doc/1.10/book/box/data_model.rst:452
msgid ""
"In fact, though, good collation involves much more than these simple "
"examples of upper case / lower case and accented / unaccented equivalence"
" in alphabets. We also consider variations of the same character, non-"
"alphabetic writing systems, and special rules that apply for combinations"
" of characters."
msgstr ""
"Фактически хорошая сортировка включает в себя гораздо больше, чем простые"
" примеры эквивалентности заглавных и строчных букв, а также наличие или "
"отсутствие диакритических знаков в алфавитах. Учитываются также варианты "
"написания одного и того же символа, системы письменности без алфавита и "
"специальные правила, которые применяются в отношении сочетания символов."

#: ../doc/1.10/book/box/data_model.rst:463
msgid "A **sequence** is a generator of ordered integer values."
msgstr ""
"**Последовательность** -- это генератор упорядоченных значений целых "
"чисел."

#: ../doc/1.10/book/box/data_model.rst:465
msgid ""
"As with spaces and indexes, you should specify the sequence **name**, and"
" let Tarantool come up with a unique **numeric identifier** (\"sequence "
"id\")."
msgstr ""
"Как и для спейсов и индексов, для последовательностей следует указать "
"**имена**, а Tarantool определит уникальный **числовой идентификатор** "
"(\"ID последовательности\")."

#: ../doc/1.10/book/box/data_model.rst:468
msgid ""
"As well, you can specify several options when creating a new sequence. "
"The options determine what value will be generated whenever the sequence "
"is used."
msgstr ""
"Кроме того, можно указать несколько параметров при создании новой "
"последовательности. Параметры определяют, какое значение будет "
"генерироваться при использовании последовательности."

#: ../doc/1.10/book/box/data_model.rst:475
msgid "Options for ``box.schema.sequence.create()``"
msgstr "Параметры для ``box.schema.sequence.create()``"

#: ../doc/1.10/book/box/data_model.rst:488
msgid "Option name"
msgstr "Имя параметра"

#: ../doc/1.10/book/box/data_model.rst:488
msgid "Type and meaning"
msgstr "Тип и значение"

#: ../doc/1.10/book/box/data_model.rst:490
msgid "**start**"
msgstr "**start** (начало)"

#: ../doc/1.10/book/box/data_model.rst:490
msgid "Integer. The value to generate the first time a sequence is used"
msgstr ""
"Целое число. Значение генерируется, когда последовательность используется"
" впервые"

#: ../doc/1.10/book/box/data_model.rst:490
msgid "start=0"
msgstr "start=0"

#: ../doc/1.10/book/box/data_model.rst:494
msgid "**min**"
msgstr "**min** (мин)"

#: ../doc/1.10/book/box/data_model.rst:494
msgid "Integer. Values smaller than this cannot be generated"
msgstr "Целое число. Ниже указанного значения не могут генерироваться"

#: ../doc/1.10/book/box/data_model.rst:494
msgid "min=-1000"
msgstr "min=-1000"

#: ../doc/1.10/book/box/data_model.rst:497
msgid "**max**"
msgstr "**max** (макс)"

#: ../doc/1.10/book/box/data_model.rst:497
msgid "Integer. Values larger than this cannot be generated"
msgstr "Целое число. Выше указанного значения не могут генерироваться"

#: ../doc/1.10/book/box/data_model.rst:497
msgid "9223372036854775807"
msgstr "9 223 372 036 854 775 807"

#: ../doc/1.10/book/box/data_model.rst:497
msgid "max=0"
msgstr "max=0"

#: ../doc/1.10/book/box/data_model.rst:500
msgid "**cycle**"
msgstr "**cycle** (цикл)"

#: ../doc/1.10/book/box/data_model.rst:500
msgid "Boolean. Whether to start again when values cannot be generated"
msgstr ""
"Логическое значение. Если значения не могут быть сгенерированы, начинать "
"ли заново"

#: ../doc/1.10/book/box/data_model.rst:500
msgid "cycle=true"
msgstr "cycle=true"

#: ../doc/1.10/book/box/data_model.rst:503
msgid "**cache**"
msgstr "**cache** (кэш)"

#: ../doc/1.10/book/box/data_model.rst:503
msgid "Integer. The number of values to store in a cache"
msgstr "Целое число. Количество значений для хранения в кэше"

#: ../doc/1.10/book/box/data_model.rst:503
msgid "cache=0"
msgstr "cache=0"

#: ../doc/1.10/book/box/data_model.rst:506
msgid "**step**"
msgstr "**step** (шаг)"

#: ../doc/1.10/book/box/data_model.rst:506
msgid ""
"Integer. What to add to the previous generated value, when generating a "
"new value"
msgstr ""
"Целое число. Что добавить к предыдущему сгенерированному значению, когда "
"генерируется новое значение"

#: ../doc/1.10/book/box/data_model.rst:506
msgid "step=-1"
msgstr "step=-1"

#: ../doc/1.10/book/box/data_model.rst:510
msgid "**if_not_exists**"
msgstr "**if_not_exists** (если отсутствует)"

#: ../doc/1.10/book/box/data_model.rst:510
msgid ""
"Boolean. If this is true and a sequence with this name exists already, "
"ignore other options and use the existing values"
msgstr ""
"Логическое значение. Если выставлено в true (истина) и существует "
"последовательность с таким именем, то игнорировать другие опции и "
"использовать текущие значения"

#: ../doc/1.10/book/box/data_model.rst:510
msgid "if_not_exists=true"
msgstr "if_not_exists=true"

#: ../doc/1.10/book/box/data_model.rst:516
msgid ""
"Once a sequence exists, it can be altered, dropped, reset, forced to "
"generate the next value, or associated with an index."
msgstr ""
"Существующую последовательность можно изменять, опускать, сбрасывать, "
"заставить сгенерировать новое значение или ассоциировать с индексом."

#: ../doc/1.10/book/box/data_model.rst:519
msgid "For an initial example, we generate a sequence named 'S'."
msgstr ""
"Для первоначального примера сгенерируем последовательность под названием "
"'S'."

#: ../doc/1.10/book/box/data_model.rst:521
msgid ""
"tarantool> box.schema.sequence.create('S',{min=5, start=5})\n"
"---\n"
"- step: 1\n"
"  id: 5\n"
"  min: 5\n"
"  cache: 0\n"
"  uid: 1\n"
"  max: 9223372036854775807\n"
"  cycle: false\n"
"  name: S\n"
"  start: 5\n"
"..."
msgstr ""
"tarantool> box.schema.sequence.create('S',{min=5, start=5})\n"
"---\n"
"- step: 1\n"
"  id: 5\n"
"  min: 5\n"
"  cache: 0\n"
"  uid: 1\n"
"  max: 9223372036854775807\n"
"  cycle: false\n"
"  name: S\n"
"  start: 5\n"
"..."

#: ../doc/1.10/book/box/data_model.rst:536
msgid ""
"The result shows that the new sequence has all default values, except for"
" the two that were specified, ``min`` and ``start``."
msgstr ""
"В результате видим, что в новой последовательность есть все значения по "
"умолчанию, за исключением указанных ``min`` и ``start``."

#: ../doc/1.10/book/box/data_model.rst:539
msgid "Then we get the next value, with the ``next()`` function."
msgstr "Затем получаем следующее значение с помощью функции ``next()``."

#: ../doc/1.10/book/box/data_model.rst:541
msgid ""
"tarantool> box.sequence.S:next()\n"
"---\n"
"- 5\n"
"..."
msgstr ""
"tarantool> box.sequence.S:next()\n"
"---\n"
"- 5\n"
"..."

#: ../doc/1.10/book/box/data_model.rst:548
msgid ""
"The result is the same as the start value. If we called ``next()`` again,"
" we would get 6 (because the previous value plus the step value is 6), "
"and so on."
msgstr ""
"Результат точно такой же, как и начальное значение. Если мы снова вызовем"
" ``next()``, то получим 6 (потому что предыдущее значение плюс значение "
"шага составит 6) и так далее."

#: ../doc/1.10/book/box/data_model.rst:552
msgid ""
"Then we create a new table, and say that its primary key may be generated"
" from the sequence."
msgstr ""
"Затем создадим новую таблицу и скажем, что ее первичный ключ можно "
"получить из последовательности."

#: ../doc/1.10/book/box/data_model.rst:555
msgid ""
"tarantool> "
"s=box.schema.space.create('T');s:create_index('I',{sequence='S'})\n"
"---\n"
"..."
msgstr ""
"tarantool> "
"s=box.schema.space.create('T');s:create_index('I',{sequence='S'})\n"
"---\n"
"..."

#: ../doc/1.10/book/box/data_model.rst:561
msgid "Then we insert a tuple, without specifying a value for the primary key."
msgstr "Затем вставим кортеж, не указывая значение первичного ключа."

#: ../doc/1.10/book/box/data_model.rst:563
msgid ""
"tarantool> box.space.T:insert{nil,'other stuff'}\n"
"---\n"
"- [6, 'other stuff']\n"
"..."
msgstr ""
"tarantool> box.space.T:insert{nil,'other stuff'}\n"
"---\n"
"- [6, 'other stuff']\n"
"..."

#: ../doc/1.10/book/box/data_model.rst:570
msgid ""
"The result is a new tuple where the first field has a value of 6. This "
"arrangement, where the system automatically generates the values for a "
"primary key, is sometimes called \"auto-incrementing\" or \"identity\"."
msgstr ""
"В результате имеем новый кортеж со значением 6 в первом поле. Такой "
"способ организации данных, когда система автоматически генерирует "
"значения для первичного ключа, иногда называется \"автоинкрементным\" "
"(т.е. с автоматическим увеличением) или \"по идентификатору\"."

#: ../doc/1.10/book/box/data_model.rst:575
msgid ""
"For syntax and implementation details, see the reference for "
":ref:`box.schema.sequence <box_schema-sequence>`."
msgstr ""
"Для получения подробной информации о синтаксисе и методах реализации см. "
"справочник по :ref:`box.schema.sequence <box_schema-sequence>`."

#: ../doc/1.10/book/box/data_model.rst:582
msgid "Persistence"
msgstr "Персистентность"

#: ../doc/1.10/book/box/data_model.rst:584
msgid ""
"In Tarantool, updates to the database are recorded in the so-called "
":ref:`write ahead log (WAL) <internals-wal>` files. This ensures data "
"persistence. When a power outage occurs or the Tarantool instance is "
"killed incidentally, the in-memory database is lost. In this situation, "
"WAL files are used to restore the data. Namely, Tarantool reads the WAL "
"files and redoes the requests (this is called the \"recovery process\"). "
"You can change the timing of the WAL writer, or turn it off, by setting "
":ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>`."
msgstr ""
"В Tarantool'е обновления базы данных записываются в так называемые "
":ref:`файлы журнала упреждающей записи (WAL-файлы) <internals-wal>`. Это "
"обеспечивает персистентность данных. При отключении электроэнергии или "
"случайном завершении работы экземпляра Tarantool'а данные в оперативной "
"памяти теряются. В такой ситуации WAL-файлы используются для "
"восстановления данных так: Tarantool прочитывает WAL-файлы и повторно "
"выполняет запросы (это называется \"процессом восстановления\"). Можно "
"изменить временные настройки метода записи WAL-файлов или отключить его с"
" помощью :ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>`."

#: ../doc/1.10/book/box/data_model.rst:593
msgid ""
"Tarantool also maintains a set of :ref:`snapshot files <internals-"
"snapshot>`. These files contain an on-disk copy of the entire data set "
"for a given moment. Instead of reading every WAL file since the databases"
" were created, the recovery process can load the latest snapshot file and"
" then read only those WAL files that were produced after the snapshot "
"file was made. After checkpointing, old WAL files can be removed to free "
"up space."
msgstr ""
"Tarantool также сохраняет ряд файлов со статическими снимками данных "
"(:ref:`snapshots <internals-snapshot>`). Файл со снимком -- это дисковая "
"копия всех данных в базе на какой-то момент. Вместо того, чтобы "
"зачитывать все WAL-файлы, появившиеся с момента создания базы, Tarantool "
"в процессе восстановления может загрузить самый свежий снимок и затем "
"зачитать только те WAL-файлы, которые были сделаны с момента сохранения "
"снимка. После создания новых файлов, старые WAL-файлы могут быть удалены "
"в целях экономии места на диске."

#: ../doc/1.10/book/box/data_model.rst:600
msgid ""
"To force immediate creation of a snapshot file, you can use Tarantool's "
":ref:`box.snapshot() <box-snapshot>` request. To enable automatic "
"creation of snapshot files, you can use Tarantool's :ref:`checkpoint "
"daemon <book_cfg_checkpoint_daemon>`. The checkpoint daemon sets "
"intervals for forced checkpoints. It makes sure that the states of both "
"memtx and vinyl storage engines are synchronized and saved to disk, and "
"automatically removes old WAL files."
msgstr ""
"Чтобы принудительно создать файл со снимком, можно использовать запрос "
":ref:`box.snapshot() <box-snapshot>` в Tarantool'е. Чтобы включить "
"автоматическое создание файлов со снимком, можно использовать :ref:`демон"
" создания контрольных точек <book_cfg_checkpoint_daemon>` Tarantool'а. "
"Демон создания контрольных точек определяет интервалы для принудительного"
" создания контрольных точек. Он обеспечивает синхронизацию и сохранение "
"на диск образов движков базы данных (как memtx, так и vinyl), а также "
"автоматически удаляет старые WAL-файлы."

#: ../doc/1.10/book/box/data_model.rst:608
msgid "Snapshot files can be created even if there is no WAL file."
msgstr "Файлы со снимками можно создавать, даже если WAL-файлы отсутствуют."

#: ../doc/1.10/book/box/data_model.rst:612
msgid ""
"The memtx engine makes only regular checkpoints with the interval set in "
":ref:`checkpoint daemon <book_cfg_checkpoint_daemon>` configuration."
msgstr ""
"Движок memtx регулярно создает контрольные точки с интервалом, указанным "
"в настройках :ref:`демона создания контрольных точек "
"<book_cfg_checkpoint_daemon>`."

#: ../doc/1.10/book/box/data_model.rst:615
msgid "The vinyl engine runs checkpointing in the background at all times."
msgstr ""
"Движок vinyl постоянно сохраняет состояние в контрольной точке в фоновом "
"режиме."

#: ../doc/1.10/book/box/data_model.rst:617
msgid ""
"See the :ref:`Internals <internals-data_persistence>` section for more "
"details about the WAL writer and the recovery process."
msgstr ""
"Для получения более подробной информации о методе записи WAL-файлов и "
"процессе восстановления см. раздел :ref:`Внутренняя реализация "
"<internals-data_persistence>`."

#: ../doc/1.10/book/box/data_model.rst:624
msgid "Operations"
msgstr "Операции"

#: ../doc/1.10/book/box/data_model.rst:630
msgid "Data operations"
msgstr "Операции с данными"

#: ../doc/1.10/book/box/data_model.rst:632
msgid "The basic data operations supported in Tarantool are:"
msgstr "Tarantool поддерживает следующие основные операции с данными:"

#: ../doc/1.10/book/box/data_model.rst:634
msgid ""
"five data-manipulation operations (INSERT, UPDATE, UPSERT, DELETE, "
"REPLACE), and"
msgstr ""
"пять операций по изменению данных (INSERT, UPDATE, UPSERT, DELETE, "
"REPLACE) и"

#: ../doc/1.10/book/box/data_model.rst:635
msgid "one data-retrieval operation (SELECT)."
msgstr "одну операция по выборке данных (SELECT)."

#: ../doc/1.10/book/box/data_model.rst:637
msgid ""
"All of them are implemented as functions in :ref:`box.space <box_space>` "
"submodule."
msgstr ""
"Все они реализованы в виде функций во вложенном модуле  :ref:`box.space "
"<box_space>`."

#: ../doc/1.10/book/box/data_model.rst:641
msgid ":ref:`INSERT <box_space-insert>`: Add a new tuple to space 'tester'."
msgstr ":ref:`INSERT <box_space-insert>`: добавить новый кортеж к спейсу 'tester'."

#: ../doc/1.10/book/box/data_model.rst:643
msgid "The first field, field[1], will be 999 (MsgPack type is `integer`)."
msgstr "Первое поле, field[1], будет 999 (тип MsgPack -- `integer`, целое число)."

#: ../doc/1.10/book/box/data_model.rst:645
msgid "The second field, field[2], will be 'Taranto' (MsgPack type is `string`)."
msgstr "Второе поле, field[2], будет 'Taranto' (тип MsgPack -- `string`, строка)."

#: ../doc/1.10/book/box/data_model.rst:647
msgid "tarantool> box.space.tester:insert{999, 'Taranto'}"
msgstr "tarantool> box.space.tester:insert{999, 'Taranto'}"

#: ../doc/1.10/book/box/data_model.rst:651
msgid ""
":ref:`UPDATE <box_space-update>`: Update the tuple, changing field "
"field[2]."
msgstr ":ref:`UPDATE <box_space-update>`: обновить кортеж, изменяя поле field[2]."

#: ../doc/1.10/book/box/data_model.rst:653
msgid ""
"The clause \"{999}\", which has the value to look up in the index of the "
"tuple's primary-key field, is mandatory, because ``update()`` requests "
"must always have a clause that specifies a unique key, which in this case"
" is field[1]."
msgstr ""
"Оператор \"{999}\" со значением, которое используется для поиска поля, "
"соответствующего ключу в первичном индексе, является обязательным, "
"поскольку в запросе ``update()`` должен быть оператор, который указывает "
"уникальный ключ, в данном случае -- field[1]."

#: ../doc/1.10/book/box/data_model.rst:657
msgid ""
"The clause \"{{'=', 2, 'Tarantino'}}\" specifies that assignment will "
"happen to field[2] with the new value."
msgstr ""
"Оператор \"{{'=', 2, 'Tarantino'}}\" указывает, что назначение нового "
"значения относится к field[2]."

#: ../doc/1.10/book/box/data_model.rst:660
msgid "tarantool> box.space.tester:update({999}, {{'=', 2, 'Tarantino'}})"
msgstr "tarantool> box.space.tester:update({999}, {{'=', 2, 'Tarantino'}})"

#: ../doc/1.10/book/box/data_model.rst:664
msgid ""
":ref:`UPSERT <box_space-upsert>`: Upsert the tuple, changing field "
"field[2] again."
msgstr ""
":ref:`UPSERT <box_space-upsert>`: обновить или вставить кортеж, снова "
"изменяя поле field[2]."

#: ../doc/1.10/book/box/data_model.rst:667
msgid ""
"The syntax of ``upsert()`` is similar to the syntax of ``update()``. "
"However, the execution logic of these two requests is different. UPSERT "
"is either UPDATE or INSERT, depending on the database's state. Also, "
"UPSERT execution is postponed until after transaction commit, so, unlike "
"``update()``, ``upsert()`` doesn't return data back."
msgstr ""
"Синтаксис ``upsert()`` похож на синтаксис ``update()``. Однако логика "
"выполнения двух запросов отличается. UPSERT означает UPDATE или INSERT, в"
" зависимости от состояния базы данных. Кроме того, выполнение UPSERT "
"откладывается до коммита транзакции, поэтому в отличие от``update()``, "
"``upsert()`` не возвращает данные."

#: ../doc/1.10/book/box/data_model.rst:673
msgid ""
"tarantool> box.space.tester:upsert({999, 'Taranted'}, {{'=', 2, "
"'Tarantism'}})"
msgstr ""
"tarantool> box.space.tester:upsert({999, 'Taranted'}, {{'=', 2, "
"'Tarantism'}})"

#: ../doc/1.10/book/box/data_model.rst:677
msgid ":ref:`REPLACE <box_space-replace>`: Replace the tuple, adding a new field."
msgstr ":ref:`REPLACE <box_space-replace>`: заменить кортеж, добавляя новое поле."

#: ../doc/1.10/book/box/data_model.rst:679
msgid ""
"This is also possible with the ``update()`` request, but the ``update()``"
" request is usually more complicated."
msgstr ""
"Это действие также можно выполнить с помощью запроса ``update()``, но "
"обычно запрос ``update()`` более сложен."

#: ../doc/1.10/book/box/data_model.rst:682
msgid "tarantool> box.space.tester:replace{999, 'Tarantella', 'Tarantula'}"
msgstr "tarantool> box.space.tester:replace{999, 'Tarantella', 'Tarantula'}"

#: ../doc/1.10/book/box/data_model.rst:686
msgid ":ref:`SELECT <box_space-select>`: Retrieve the tuple."
msgstr ":ref:`SELECT <box_space-select>`: провести выборку кортежа."

#: ../doc/1.10/book/box/data_model.rst:688
msgid ""
"The clause \"{999}\" is still mandatory, although it does not have to "
"mention the primary key."
msgstr ""
"Оператор \"{999}\" все еще обязателен, хотя в нем не должен упоминаться "
"первичный ключ."

#: ../doc/1.10/book/box/data_model.rst:691
msgid "tarantool> box.space.tester:select{999}"
msgstr "tarantool> box.space.tester:select{999}"

#: ../doc/1.10/book/box/data_model.rst:695
msgid ":ref:`DELETE <box_space-delete>`: Delete the tuple."
msgstr ":ref:`DELETE <box_space-delete>`: удалить кортеж."

#: ../doc/1.10/book/box/data_model.rst:697
msgid "In this example, we identify the primary-key field."
msgstr ""
"В этом примере мы определяем поле, соответствующее ключу в первичном "
"индексе."

#: ../doc/1.10/book/box/data_model.rst:699
msgid "tarantool> box.space.tester:delete{999}"
msgstr "tarantool> box.space.tester:delete{999}"

#: ../doc/1.10/book/box/data_model.rst:703
msgid "Summarizing the examples:"
msgstr "Подводя итоги по примерам:"

#: ../doc/1.10/book/box/data_model.rst:705
msgid ""
"Functions ``insert`` and ``replace`` accept a tuple (where a primary key "
"comes as part of the tuple)."
msgstr ""
"Функции ``insert`` и ``replace`` принимают кортеж (где первичный ключ -- "
"это часть кортежа)."

#: ../doc/1.10/book/box/data_model.rst:707
msgid ""
"Function ``upsert`` accepts a tuple (where a primary key comes as part of"
" the tuple), and also the update operations to execute."
msgstr ""
"Функция ``upsert`` принимает кортеж (где первичный ключ -- это часть "
"кортежа), а также операции по обновлению."

#: ../doc/1.10/book/box/data_model.rst:710
msgid ""
"Function ``delete`` accepts a full key of any unique index (primary or "
"secondary)."
msgstr ""
"Функция ``delete`` принимает полный ключ любого уникального индекса "
"(первичный или вторичный)."

#: ../doc/1.10/book/box/data_model.rst:712
msgid ""
"Function ``update`` accepts a full key of any unique index (primary or "
"secondary), and also the operations to execute."
msgstr ""
"Функция  ``update`` принимает полный ключ любого уникального индекса "
"(первичный или вторичный), а также операции к выполнению."

#: ../doc/1.10/book/box/data_model.rst:715
msgid ""
"Function ``select`` accepts any key: primary/secondary, unique/non-"
"unique, full/partial."
msgstr ""
"Функция ``select`` принимает любой ключ: первичный/вторичный, "
"уникальный/неуникальный, полный/часть."

#: ../doc/1.10/book/box/data_model.rst:718
msgid ""
"See reference on ``box.space`` for more :ref:`details on using data "
"operations <box_space-operations-detailed-examples>`."
msgstr ""
"Для получения более :ref:`подробной информации по использованию операций "
"с данными <box_space-operations-detailed-examples>` см. справочник по "
"``box.space``."

#: ../doc/1.10/book/box/data_model.rst:723
msgid ""
"Besides Lua, you can use :ref:`Perl, PHP, Python or other programming "
"language connectors <index-box_connectors>`. The client server protocol "
"is open and documented. See this :ref:`annotated BNF <box_protocol-"
"iproto_protocol>`."
msgstr ""
"Помимо Lua можно использовать :ref:`коннекторы к Perl, PHP, Python или "
"другому языку программирования <index-box_connectors>`. Клиент-серверный "
"протокол открыт и задокументирован. См. :ref:`БНФ с комментариями "
"<box_protocol-iproto_protocol>`."

#: ../doc/1.10/book/box/data_model.rst:732
msgid "Index operations"
msgstr "Операции с индексами"

#: ../doc/1.10/book/box/data_model.rst:734
msgid ""
"Index operations are automatic: if a data-manipulation request changes a "
"tuple, then it also changes the index keys defined for the tuple."
msgstr ""
"Операции с индексами производятся автоматически. Если запрос по "
"манипулированию данными меняет данные в кортеже, то меняются и ключи в "
"индексе для данного кортежа."

#: ../doc/1.10/book/box/data_model.rst:737
msgid "The simple index-creation operation that we've illustrated before is:"
msgstr ""
"Простая операция по созданию индекса, которую мы рассматривали ранее, "
"выглядит следующим образом:"

#: ../doc/1.10/book/box/data_model.rst:742
msgid ":samp:`box.space.{space-name}:create_index('{index-name}')`"
msgstr ":samp:`box.space.{имя-спейса}:create_index('{имя-индекса}')`"

#: ../doc/1.10/book/box/data_model.rst:744
msgid ""
"This creates a unique TREE index on the first field of all tuples (often "
"called \"Field#1\"), which is assumed to be numeric."
msgstr ""
"По умолчанию, при этом создается TREE-индекс по первому полю для всех "
"кортежей (обычно его называют \"Field#1\"). Предполагается, что "
"индексируемое поле является числовым."

#: ../doc/1.10/book/box/data_model.rst:747
msgid "The simple SELECT request that we've illustrated before is:"
msgstr "Вот простой SELECT-запрос, который мы рассматривали ранее:"

#: ../doc/1.10/book/box/data_model.rst:752
msgid ":extsamp:`box.space.{*{space-name}*}:select({*{value}*})`"
msgstr ":extsamp:`box.space.{*{space-name}*}:select({*{value}*})`"

#: ../doc/1.10/book/box/data_model.rst:754
msgid ""
"This looks for a single tuple via the first index. Since the first index "
"is always unique, the maximum number of returned tuples will be: one."
msgstr ""
"Такой запрос ищет отдельный кортеж по первичному индексу. Поскольку "
"первичный индекс всегда уникален, то данный запрос вернет не более одного"
" кортежа."

#: ../doc/1.10/book/box/data_model.rst:757
msgid "The following SELECT variations exist:"
msgstr "Возможны следующие варианты SELECT:"

#: ../doc/1.10/book/box/data_model.rst:759
msgid "The search can use comparisons other than equality."
msgstr ""
"Помимо условия равенства, при поиске могут использоваться и другие "
"условия сравнения."

#: ../doc/1.10/book/box/data_model.rst:766
msgid ""
"The :ref:`comparison operators <box_index-iterator-types>` are LT, LE, "
"EQ, REQ, GE, GT (for \"less than\", \"less than or equal\", \"equal\", "
"\"reversed equal\", \"greater than or equal\", \"greater than\" "
"respectively). Comparisons make sense if and only if the index type is "
"‘TREE'."
msgstr ""
"Можно использовать следующие :ref:`операторы сравнения <box_index-"
"iterator-types>`: LT (меньше), LE (меньше  или равно), EQ (равно, "
"результаты отсортированы в порядке возрастания по ключу), REQ (равно, "
"результаты отсортированы в порядке убывания по ключу), GE (больше или "
"равно), GT (больше). Сравнения имеют смысл только для индексов типа "
"'TREE'."

#: ../doc/1.10/book/box/data_model.rst:771
msgid ""
"This type of search may return more than one tuple; if so, the tuples "
"will be in descending order by key when the comparison operator is LT or "
"LE or REQ, otherwise in ascending order."
msgstr ""
"Этот вариант поиска может вернуть более одного кортежа. В таком случае "
"кортежи будут отсортированы в порядке убывания по ключу (если "
"использовался оператор LT, LE или REQ), либо в порядке возрастания (во "
"всех остальных случаях)."

#: ../doc/1.10/book/box/data_model.rst:775
msgid "The search can use a secondary index."
msgstr "Поиск может производиться по вторичному индексу."

#: ../doc/1.10/book/box/data_model.rst:782
msgid ""
"For a primary-key search, it is optional to specify an index name. For a "
"secondary-key search, it is mandatory."
msgstr ""
"При поиске по первичному индексу имя индекса можно не указывать. При "
"поиске же по вторичному индексу имя индекса указывать необходимо."

#: ../doc/1.10/book/box/data_model.rst:785
msgid "The search may be for some or all key parts."
msgstr "Поиск может производиться как по всему ключу, так и по его частям."

#: ../doc/1.10/book/box/data_model.rst:806
msgid "The search may be for all fields, using a table for the value:"
msgstr "Поиск может производиться по всем полям с использованием таблицы значений:"

#: ../doc/1.10/book/box/data_model.rst:813
msgid "or the search can be for one field, using a table or a scalar:"
msgstr ""
"либо же по одному полю (в этом случае используется таблица или скалярное "
"значение):"

#: ../doc/1.10/book/box/data_model.rst:820
msgid ""
"In the second case, the result will be two tuples: ``{1, 'A'}`` and ``{1,"
" 'B'}``."
msgstr ""
"Во втором случае Tarantool вернет два кортежа: ``{1, 'A'}`` и ``{1,  "
"'B'}``."

#: ../doc/1.10/book/box/data_model.rst:823
msgid ""
"You can specify even zero fields, causing all three tuples to be "
"returned. (Notice that partial key searches are available only in TREE "
"indexes.)"
msgstr ""
"При необходимости можно задать даже нулевые поля, в результате чего "
"Tarantool вернет все три кортежа (обратите внимание, что поиск по "
"компонентам ключа доступен только для TREE-индексов)."

#: ../doc/1.10/book/box/data_model.rst:826
msgid "**Examples**"
msgstr "**Примеры**"

#: ../doc/1.10/book/box/data_model.rst:828
msgid "BITSET example:"
msgstr "Пример работы с BITSET-индексом:"

#: ../doc/1.10/book/box/data_model.rst:830
msgid ""
"tarantool> box.schema.space.create('bitset_example')\n"
"tarantool> box.space.bitset_example:create_index('primary')\n"
"tarantool> "
"box.space.bitset_example:create_index('bitset',{unique=false,type='BITSET',"
" parts={2,'unsigned'}})\n"
"tarantool> box.space.bitset_example:insert{1,1}\n"
"tarantool> box.space.bitset_example:insert{2,4}\n"
"tarantool> box.space.bitset_example:insert{3,7}\n"
"tarantool> box.space.bitset_example:insert{4,3}\n"
"tarantool> box.space.bitset_example.index.bitset:select(2, "
"{iterator='BITS_ANY_SET'})"
msgstr ""
"tarantool> box.schema.space.create('bitset_example')\n"
"tarantool> box.space.bitset_example:create_index('primary')\n"
"tarantool> "
"box.space.bitset_example:create_index('bitset',{unique=false,type='BITSET',"
" parts={2,'unsigned'}})\n"
"tarantool> box.space.bitset_example:insert{1,1}\n"
"tarantool> box.space.bitset_example:insert{2,4}\n"
"tarantool> box.space.bitset_example:insert{3,7}\n"
"tarantool> box.space.bitset_example:insert{4,3}\n"
"tarantool> box.space.bitset_example.index.bitset:select(2, "
"{iterator='BITS_ANY_SET'})"

#: ../doc/1.10/book/box/data_model.rst:841
#: ../doc/1.10/book/box/data_model.rst:863
#: ../doc/1.10/tutorials/lua_tutorials.rst:877
msgid "The result will be:"
msgstr "Мы получим следующий результат:"

#: ../doc/1.10/book/box/data_model.rst:843
msgid ""
"---\n"
"- - [3, 7]\n"
"  - [4, 3]\n"
"..."
msgstr ""
"---\n"
"- - [3, 7]\n"
"  - [4, 3]\n"
"..."

#: ../doc/1.10/book/box/data_model.rst:850
msgid "because (7 AND 2) is not equal to 0, and (3 AND 2) is not equal to 0."
msgstr "поскольку (7 AND 2) не равно 0 и (3 AND 2) не равно 0."

#: ../doc/1.10/book/box/data_model.rst:852
msgid "RTREE example:"
msgstr "Пример работы с RTREE-индексом:"

#: ../doc/1.10/book/box/data_model.rst:854
msgid ""
"tarantool> box.schema.space.create('rtree_example')\n"
"tarantool> box.space.rtree_example:create_index('primary')\n"
"tarantool> "
"box.space.rtree_example:create_index('rtree',{unique=false,type='RTREE', "
"parts={2,'ARRAY'}})\n"
"tarantool> box.space.rtree_example:insert{1, {3, 5, 9, 10}}\n"
"tarantool> box.space.rtree_example:insert{2, {10, 11}}\n"
"tarantool> box.space.rtree_example.index.rtree:select({4, 7, 5, 9}, "
"{iterator = 'GT'})"
msgstr ""
"tarantool> box.schema.space.create('rtree_example')\n"
"tarantool> box.space.rtree_example:create_index('primary')\n"
"tarantool> "
"box.space.rtree_example:create_index('rtree',{unique=false,type='RTREE', "
"parts={2,'ARRAY'}})\n"
"tarantool> box.space.rtree_example:insert{1, {3, 5, 9, 10}}\n"
"tarantool> box.space.rtree_example:insert{2, {10, 11}}\n"
"tarantool> box.space.rtree_example.index.rtree:select({4, 7, 5, 9}, "
"{iterator = 'GT'})"

#: ../doc/1.10/book/box/data_model.rst:865
msgid ""
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"..."
msgstr ""
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"..."

#: ../doc/1.10/book/box/data_model.rst:871
msgid ""
"because a rectangle whose corners are at coordinates ``4,7,5,9`` is "
"entirely within a rectangle whose corners are at coordinates "
"``3,5,9,10``."
msgstr ""
"поскольку прямоугольник с углами в координатах ``4,7,5,9`` лежит целиком "
"внутри прямоугольника с углами в координатах ``3,5,9,10``."

#: ../doc/1.10/book/box/data_model.rst:874
msgid ""
"Additionally, there exist :ref:`index iterator operations <box_index-"
"index_pairs>`. They can only be used with code in Lua and C/C++. Index "
"iterators are for traversing indexes one key at a time, taking advantage "
"of features that are specific to an index type, for example evaluating "
"Boolean expressions when traversing BITSET indexes, or going in "
"descending order when traversing TREE indexes."
msgstr ""
"Кроме того, есть :ref:`операции с итераторами с индексом <box_index-"
"index_pairs>`. Их можно использовать только с кодом на языках Lua и "
"C/C++. Итераторы с индексом предназначены для обхода индексов по одному "
"ключу за раз, поскольку используют особенности каждого типа индекса, "
"например оценка логических выражений при обходе BITSET-индексов или обход"
" TREE-индексов в порядке по убыванию."

#: ../doc/1.10/book/box/data_model.rst:880
msgid ""
"See also other index operations like :ref:`alter() <box_index-alter>` and"
" :ref:`drop() <box_index-drop>` in reference for :ref:`box.index "
"<box_index>` submodule."
msgstr ""
"См. также информацию о других операциях с итераторами с индексом, таких "
"как :ref:`alter() <box_index-alter>` и :ref:`drop() <box_index-drop>` во "
"вложенном модуле :ref:`box.index <box_index>`."

#: ../doc/1.10/book/box/data_model.rst:885
msgid "Complexity factors"
msgstr "Факторы сложности"

#: ../doc/1.10/book/box/data_model.rst:887
msgid ""
"In reference for :ref:`box.space <box_space>` and :ref:`box.index "
"<box_index>` submodules, there are notes about which complexity factors "
"might affect the resource usage of each function."
msgstr ""
"Что касается вложенных модулей :ref:`box.space <box_space>` и "
":ref:`box.index <box_index>`, есть информация о том, как факторы "
"сложности могут повлиять на использование каждой функции."

#: ../doc/1.10/book/box/data_model.rst:897
msgid "Complexity factor"
msgstr "Фактор сложности"

#: ../doc/1.10/book/box/data_model.rst:900
msgid "Index size"
msgstr "Размер индекса"

#: ../doc/1.10/book/box/data_model.rst:900
msgid ""
"The number of index keys is the same as the number of tuples in the data "
"set. For a TREE index, if there are more keys, then the lookup time will "
"be greater, although of course the effect is not linear. For a HASH "
"index, if there are more keys, then there is more RAM used, but the "
"number of low-level steps tends to remain constant."
msgstr ""
"Количество ключей в индексе равно количеству кортежей в наборе данных. В "
"случае с TREE-индексом: с ростом количества ключей увеличивается время "
"поиска, хотя зависимость здесь, конечно же, не линейная. В случае с "
"HASH-индексом: с ростом количества ключей увеличивается объем оперативной"
" памяти, но количество низкоуровневых шагов остается примерно тем же."

#: ../doc/1.10/book/box/data_model.rst:908
msgid ""
"Typically, a HASH index is faster than a TREE index if the number of "
"tuples in the space is greater than one."
msgstr ""
"Как правило, поиск по HASH-индексу работает быстрее, чем по TREE-индексу,"
"  если в спейсе более одного кортежа."

#: ../doc/1.10/book/box/data_model.rst:912
msgid "Number of indexes accessed"
msgstr "Количество обращений к индексам"

#: ../doc/1.10/book/box/data_model.rst:912
msgid ""
"Ordinarily, only one index is accessed to retrieve one tuple. But to "
"update the tuple, there must be N accesses if the space has N different "
"indexes."
msgstr ""
"Обычно для выборки значений одного кортежа используется только один "
"индекс. Но при обновлении значений в кортеже требуется N обращений, если "
"в спейсе N индексов."

#: ../doc/1.10/book/box/data_model.rst:916
msgid ""
"Note re storage engine: Vinyl optimizes away such accesses if secondary "
"index fields are unchanged by the update. So, this complexity factor "
"applies only to memtx, since it always makes a full-tuple copy on every "
"update."
msgstr ""
"Примечание по движку базы данных: Vinyl отклоняет такой доступ, если "
"обновление не затрагивает поля вторичного индекса. Таким образом, этот "
"фактор сложности влияет только на memtx, поскольку он всегда создает "
"копию всего кортежа при каждом обновлении."

#: ../doc/1.10/book/box/data_model.rst:922
msgid "Number of tuples accessed"
msgstr "Количество обращений к кортежам"

#: ../doc/1.10/book/box/data_model.rst:922
msgid ""
"A few requests, for example SELECT, can retrieve multiple tuples. This "
"factor is usually less important than the others."
msgstr ""
"Некоторые запросы, например SELECT, могут возвращать несколько кортежей. "
"Как правило, это наименее важный фактор из всех."

#: ../doc/1.10/book/box/data_model.rst:926
msgid "WAL settings"
msgstr "Настройки WAL"

#: ../doc/1.10/book/box/data_model.rst:926
msgid ""
"The important setting for the write-ahead log is :ref:`wal_mode "
"<cfg_binary_logging_snapshots-wal_mode>`. If the setting causes no "
"writing or delayed writing, this factor is unimportant. If the setting "
"causes every data-change request to wait for writing to finish on a slow "
"device, this factor is more important than all the others."
msgstr ""
"Важным параметром для записи в WAL является :ref:`wal_mode "
"<cfg_binary_logging_snapshots-wal_mode>`. Если запись в WAL отключена или"
" задана запись с задержкой, но этот фактор не так важен. Если же запись в"
"  WAL производится при каждом запросе на изменение данных, то при каждом "
"таком запросе приходится ждать, пока отработает обращение к более "
"медленному диску, и данный фактор становится важнее всех остальных."

#: ../doc/1.10/book/box/engines/index.rst:39
msgid "Storage engines"
msgstr "Движки базы данных"

#: ../doc/1.10/book/box/engines/index.rst:41
msgid ""
"A storage engine is a set of very-low-level routines which actually store"
" and retrieve tuple values. Tarantool offers a choice of two storage "
"engines:"
msgstr ""
"Движок базы данных представляет собой набор очень низкоуровневых "
"процессов, которые фактически хранят и получают значения в кортежах. "
"Tarantool предлагает два движка базы данных на выбор:"

#: ../doc/1.10/book/box/engines/index.rst:44
msgid ""
"memtx (the in-memory storage engine) is the default and was the first to "
"arrive."
msgstr ""
"memtx (in-memory движок базы данных) используется по умолчанию, который "
"был первым."

#: ../doc/1.10/book/box/engines/index.rst:47
msgid ""
"vinyl (the on-disk storage engine) is a working key-value engine and will"
" especially appeal to users who like to see data go directly to disk, so "
"that recovery time might be shorter and database size might be larger."
msgstr ""
"vinyl (движок для хранения данных на диске) -- это рабочий движок на "
"основе пар ключ-значение, который особенно понравится пользователям, "
"предпочитающим записывать данные напрямую на диск, чтобы сократить время "
"восстановления и увеличить размер базы данных."

#: ../doc/1.10/book/box/engines/index.rst:51
msgid ""
"On the other hand, vinyl lacks some functions and options that are "
"available with memtx. Where that is the case, the relevant description in"
" this manual contains a note beginning with the words \"Note re storage "
"engine\"."
msgstr ""
"С другой стороны, vinyl'у не хватает некоторых функций и параметров, "
"доступных в memtx'е. В соответствующих случаях дается дополнительное "
"описание в виде примечания, которое начинается со слов **Примечание про "
"движок базы данных**."

#: ../doc/1.10/book/box/engines/index.rst:55
msgid ""
"Further in this section we discuss the details of storing data using the "
"vinyl storage engine."
msgstr ""
"Далее в разделе рассмотрим подробнее метод хранения данных с помощью "
"движка базы данных vinyl."

#: ../doc/1.10/book/box/engines/index.rst:58
msgid ""
"To specify that the engine should be vinyl, add the clause ``engine = "
"'vinyl'`` when creating a space, for example:"
msgstr ""
"Чтобы указать, что следует использовать именно vinyl, необходимо при "
"создании спейса добавить оператор ``engine = 'vinyl'``, например:"

#: ../doc/1.10/book/box/engines/index.rst:61
msgid "space = box.schema.space.create('name', {engine='vinyl'})"
msgstr "space = box.schema.space.create('name', {engine='vinyl'})"

#: ../doc/1.10/book/box/engines/index.rst:69
msgid "Differences between memtx and vinyl storage engines"
msgstr "Различия между движками memtx и vinyl"

#: ../doc/1.10/book/box/engines/index.rst:71
msgid ""
"The primary difference between memtx and vinyl is that memtx is an \"in-"
"memory\" engine while vinyl is an \"on-disk\" engine. An in-memory "
"storage engine is generally faster (each query is usually run under 1 "
"ms), and the memtx engine is justifiably the default for Tarantool, but "
"on-disk engine such as vinyl is preferable when the database is larger "
"than the available memory and adding more memory is not a realistic "
"option."
msgstr ""
"Основным различием между движками memtx и vinyl является то, что memtx "
"представляет собой \"in-memory\" движок, тогда как vinyl -- это "
"\"дисковый\" движок. Как правило, in-memory движок быстрее (каждый запрос"
" обычно выполняется меньше, чем за 1 мс), и движок memtx по праву "
"используется в Tarantool'е по умолчанию, но если база данных больше "
"объема доступной памяти, а добавление дополнительной памяти не "
"представляется возможным, рекомендуется использовать дисковый движок как "
"vinyl."

#: ../doc/1.10/book/box/engines/index.rst:84
#: ../doc/1.10/reference/configuration/cfg_basic.rst:122
msgid "Option"
msgstr "Характеристика"

#: ../doc/1.10/book/box/engines/index.rst:84
msgid "memtx"
msgstr "memtx"

#: ../doc/1.10/book/box/engines/index.rst:84
msgid "vinyl"
msgstr "vinyl"

#: ../doc/1.10/book/box/engines/index.rst:86
msgid "Supported index type"
msgstr "Поддерживаемый тип индекса"

#: ../doc/1.10/book/box/engines/index.rst:86
msgid "TREE, HASH, :ref:`RTREE <box_index-rtree>` or BITSET"
msgstr "TREE, HASH, :ref:`RTREE <box_index-rtree>` или BITSET"

#: ../doc/1.10/book/box/engines/index.rst:86
msgid "TREE"
msgstr "TREE"

#: ../doc/1.10/book/box/engines/index.rst:88
msgid "Temporary spaces"
msgstr "Временные спейсы"

#: ../doc/1.10/book/box/engines/index.rst:88
#: ../doc/1.10/book/box/engines/index.rst:90
#: ../doc/1.10/book/box/engines/index.rst:92
msgid "Supported"
msgstr "Поддерживается"

#: ../doc/1.10/book/box/engines/index.rst:88
#: ../doc/1.10/book/box/engines/index.rst:90
msgid "Not supported"
msgstr "Не поддерживается"

#: ../doc/1.10/book/box/engines/index.rst:90
msgid ":ref:`random() <box_index-random>` function"
msgstr "функция :ref:`random() <box_index-random>`"

#: ../doc/1.10/book/box/engines/index.rst:92
msgid ":ref:`alter() <box_index-alter>` function"
msgstr "функция :ref:`alter() <box_index-alter>`"

#: ../doc/1.10/book/box/engines/index.rst:92
msgid ""
"Supported starting from the 1.10.2 release (the primary index cannot be "
"modified)"
msgstr "Поддерживается с версии 1.10.2 (первичный индекс изменять нельзя)"

#: ../doc/1.10/book/box/engines/index.rst:95
msgid ":ref:`len() <box_space-len>` function"
msgstr "функция :ref:`len() <box_space-len>`"

#: ../doc/1.10/book/box/engines/index.rst:95
msgid "Returns the number of tuples in the space"
msgstr "Возвращает количество кортежей в спейсе"

#: ../doc/1.10/book/box/engines/index.rst:95
msgid "Returns the maximum approximate number of tuples in the space"
msgstr "Возвращает примерное максимальное количество кортежей в спейсе "

#: ../doc/1.10/book/box/engines/index.rst:98
msgid ":ref:`count() <box_index-count>` function"
msgstr "функция :ref:`count() <box_index-count>`"

#: ../doc/1.10/book/box/engines/index.rst:98
msgid "Takes a constant amount of time"
msgstr "Занимает одинаковые периоды времени"

#: ../doc/1.10/book/box/engines/index.rst:98
msgid "Takes a variable amount of time depending on a state of a DB"
msgstr "Занимает различное количество времени в зависимости от состояния БД"

#: ../doc/1.10/book/box/engines/index.rst:101
msgid ":ref:`delete() <box_space-delete>` function"
msgstr "функция :ref:`delete() <box_space-delete>`"

#: ../doc/1.10/book/box/engines/index.rst:101
msgid "Returns the deleted tuple, if any"
msgstr "Возвращает удаленный кортеж, если есть таковой"

#: ../doc/1.10/book/box/engines/index.rst:101
msgid "Always returns nil"
msgstr "Всегда возвращает nil"

#: ../doc/1.10/book/box/engines/index.rst:103
msgid "yield"
msgstr "передача управления"

#: ../doc/1.10/book/box/engines/index.rst:103
msgid ""
"Does not yield on the select requests unless the transaction is commited "
"to WAL"
msgstr ""
"Не передает управление на запросах выборки, если не происходит коммит "
"транзакции в журнал упреждающей записи (WAL)"

#: ../doc/1.10/book/box/engines/index.rst:103
msgid "Yields on the select requests or on its equivalents: get() or pairs()"
msgstr "Передает управление на запросах выборки или аналогичных: get() или pairs()"

#: ../doc/1.10/book/box/engines/vinyl.rst:5
msgid "Storing data with vinyl"
msgstr "Хранение данных с помощью vinyl"

#: ../doc/1.10/book/box/engines/vinyl.rst:7
#, python-format
msgid ""
"Tarantool is a transactional and persistent DBMS that maintains 100% of "
"its data in RAM. The greatest advantages of in-memory databases are their"
" speed and ease of use: they demonstrate consistently high performance, "
"but you never need to tune them."
msgstr ""
"Tarantool -- это транзакционная, персистентная СУБД, которая хранит 100% "
"данных в оперативной памяти. Основными преимущества хранения данных "
"оперативной памяти являются скорость и простота использования: нет "
"необходимости в оптимизации, однако производительность остается стабильно"
" высокой."

#: ../doc/1.10/book/box/engines/vinyl.rst:12
msgid ""
"A few years ago we decided to extend the product by implementing a "
"classical storage engine similar to those used by regular DBMSes: it uses"
" RAM for caching, while the bulk of its data is stored on disk. We "
"decided to make it possible to set a storage engine independently for "
"each table in the database, which is the same way that MySQL approaches "
"it, but we also wanted to support transactions from the very beginning."
msgstr ""
"Несколько лет назад мы решили расширить продукт посредством реализации "
"классической технологии хранения как в обычных СУБД: в оперативной памяти"
" хранится лишь кэш данных, а основной объем данных находится на диске. Мы"
" решили, что движок хранения можно будет выбирать независимо для каждой "
"таблицы, как это реализовано в MySQL, но при этом с самого начала будет "
"реализована поддержка транзакций."

#: ../doc/1.10/book/box/engines/vinyl.rst:19
msgid ""
"The first question we needed to answer was whether to create our own "
"storage engine or use an existing library. The open-source community "
"offered a few viable solutions. The RocksDB library was the fastest "
"growing open-source library and is currently one of the most prominent "
"out there. There were also several lesser-known libraries to consider, "
"such as WiredTiger, ForestDB, NestDB, and LMDB."
msgstr ""
"Первый вопрос, на который нужен был ответ: создавать свой движок или "
"использовать уже существующую библиотеку? Сообщество разработчиков "
"открытого ПО предлагает готовые библиотеки на выбор. Активнее всего "
"развивалась библиотека RocksDB, которая к настоящему времени стала одной "
"из самых популярных. Есть также несколько менее известных библиотек: "
"WiredTiger, ForestDB, NestDB, LMDB."

#: ../doc/1.10/book/box/engines/vinyl.rst:26
#, python-format
msgid ""
"Nevertheless, after studying the source code of existing libraries and "
"considering the pros and cons, we opted for our own storage engine. One "
"reason is that the existing third-party libraries expected requests to "
"come from multiple operating system threads and thus contained complex "
"synchronization primitives for controlling parallel data access. If we "
"had decided to embed one of these in Tarantool, we would have made our "
"users bear the overhead of a multithreaded application without getting "
"anything in return. The thing is, Tarantool has an actor-based "
"architecture. The way it processes transactions in a dedicated thread "
"allows it to do away with the unnecessary locks, interprocess "
"communication, and other overhead that accounts for up to 80% of "
"processor time in multithreaded DBMSes."
msgstr ""
"Тем не менее, изучив исходный код существующих библиотек и взвесив все "
"\"за\" и \"против\", мы решили написать свой движок. Одна из причин -- "
"все существующие сторонние библиотеки предполагают, что запросы к данным "
"могут поступать из множества потоков операционной системы, и поэтому "
"содержат сложные примитивы синхронизации для управления одновременным "
"доступом к данным. Если бы мы решили встраивать одну из них в Tarantool, "
"то пользователи были бы вынуждены нести издержки многопоточных "
"приложений, не получая ничего взамен. Дело в том, что в основе "
"Tarantool'а лежит архитектура на основе акторов. Обработка транзакций в "
"выделенном потоке позволяет обойтись без лишних блокировок, "
"межпроцессного взаимодействия и других затрат ресурсов, которые забирают "
"до 80% процессорного времени в многопоточных СУБД."

#: ../doc/1.10/book/box/engines/vinyl.rst:41
msgid "*The Tarantool process consists of a fixed number of \"actor\" threads*"
msgstr "*Процесс Tarantool'а состоит из заданного количества потоков*"

#: ../doc/1.10/book/box/engines/vinyl.rst:43
msgid ""
"If you design a database engine with cooperative multitasking in mind "
"right from the start, it not only significantly speeds up the development"
" process, but also allows the implementation of certain optimization "
"tricks that would be too complex for multithreaded engines. In short, "
"using a third-party solution wouldn’t have yielded the best result."
msgstr ""
"Если изначально проектировать движок с учетом кооперативной "
"многозадачности, можно не только существенно ускорить работу, но и "
"реализовать приемы оптимизации, слишком сложные для многопоточных "
"движков. В общем, использование стороннего решения не привело бы к "
"лучшему результату."

#: ../doc/1.10/book/box/engines/vinyl.rst:53
msgid "Algorithm"
msgstr "Алгоритм"

#: ../doc/1.10/book/box/engines/vinyl.rst:55
msgid ""
"Once the idea of using an existing library was off the table, we needed "
"to pick an architecture to build upon. There are two competing approaches"
" to on-disk data storage: the older one relies on B-trees and their "
"variations; the newer one advocates the use of log-structured merge-"
"trees, or \"LSM\" trees. MySQL, PostgreSQL, and Oracle use B-trees, while"
" Cassandra, MongoDB, and CockroachDB have adopted LSM trees."
msgstr ""
"Отказавшись от идеи внедрения существующих библиотек, необходимо было "
"выбрать архитектуру для использования в качестве основы. Есть два "
"альтернативных подхода к хранению данных на диске: старая модель с "
"использованием B-деревьев и их разновидностей и новая -- на основе "
"журнально-структурированных деревьев со слиянием, или LSM-деревьев (Log "
"Structured Merge Tree). MySQL, PostgreSQL и Oracle используют B-деревья, "
"а Cassandra, MongoDB и CockroachDB уже используют LSM-деревья."

#: ../doc/1.10/book/box/engines/vinyl.rst:62
msgid ""
"B-trees are considered better suited for reads and LSM trees—for writes. "
"However, with SSDs becoming more widespread and the fact that SSDs have "
"read throughput that’s several times greater than write throughput, the "
"advantages of LSM trees in most scenarios was more obvious to us."
msgstr ""
"Считается, что B-деревья более эффективны для чтения, а LSM-деревья -- "
"для записи. Тем не менее, с распространением SSD-дисков, у которых в "
"несколько раз выше производительность чтения по сравнению с "
"производительностью записи, преимущества LSM-деревьев стали очевидны в "
"большинстве сценариев."

#: ../doc/1.10/book/box/engines/vinyl.rst:67
msgid ""
"Before dissecting LSM trees in Tarantool, let’s take a look at how they "
"work. To do that, we’ll begin by analyzing a regular B-tree and the "
"issues it faces. A B-tree is a balanced tree made up of blocks, which "
"contain sorted lists of key- value pairs. (Topics such as filling and "
"balancing a B-tree or splitting and merging blocks are outside of the "
"scope of this article and can easily be found on Wikipedia). As a result,"
" we get a container sorted by key, where the smallest element is stored "
"in the leftmost node and the largest one in the rightmost node. Let’s "
"have a look at how insertions and searches in a B-tree happen."
msgstr ""
"Прежде чем разбираться с LSM-деревьями в Tarantool'е, посмотрим, как они "
"работают. Для этого разберем устройство обычного B-дерева и связанные с "
"ним проблемы. \"B\" в слове B-tree означает \"Block\", то есть это "
"сбалансированное дерево, состоящее из блоков, которые содержат "
"отсортированные списки пар ключ-значение. Вопросы наполнения дерева, "
"балансировки, разбиения и слияния блоков выходят за рамки данной статьи, "
"подробности вы сможете прочитать в Википедии. В итоге мы получаем "
"отсортированный по возрастанию ключа контейнер, минимальный элемент "
"которого хранится в крайнем левом узле, а максимальный -- в крайнем "
"правом. Посмотрим, как в B-дереве осуществляется поиск и вставка данных."

#: ../doc/1.10/book/box/engines/vinyl.rst:78
msgid "*Classical B-tree*"
msgstr "*Классическое B-дерево*"

#: ../doc/1.10/book/box/engines/vinyl.rst:80
#, fuzzy
msgid ""
"If you need to find an element or check its membership, the search starts"
" at the root, as usual. If the key is found in the root block, the search"
" stops; otherwise, the search visits the rightmost block holding the "
"largest element that’s not larger than the key being searched (recall "
"that elements at each level are sorted). If the first level yields no "
"results, the search proceeds to the next level. Finally, the search ends "
"up in one of the leaves and probably locates the needed key. Blocks are "
"stored and read into RAM one by one, meaning the algorithm reads "
":math:`logB(N)` blocks in a single search, where N is the number of "
"elements in the B-tree. In the simplest case, writes are done similarly: "
"the algorithm finds the block that holds the necessary element and "
"updates (inserts) its value."
msgstr ""
"Если необходимо найти элемент или проверить его наличие, поиск "
"начинается, как обычно, с вершины. Если ключ обнаружен в корневом блоке, "
"поиск заканчивается; в противном случае, переходим в блок с наибольшим "
"меньшим ключом, то есть в самый правый блок, в котором еще есть элементы "
"меньше искомого (элементы на всех уровнях расположены по возрастанию). "
"Если и там элемент не найден, снова переходим на уровень ниже. В конце "
"концов окажемся в одном из листьев и, возможно, обнаружим искомый "
"элемент. Блоки дерева хранятся на диске и читаются в оперативную память "
"по одному, то есть в рамках одного поиска алгоритм считывает "
":code:`logB(N)` блоков, где N -- это количество элементов в B-дереве. "
"Запись в самом простом случае осуществляется аналогично: алгоритм находит"
" блок, который содержит необходимый элемент, и обновляет (вставляет) его "
"значение."

#: ../doc/1.10/book/box/engines/vinyl.rst:92
msgid ""
"To better understand the data structure, let’s consider a practical "
"example: say we have a B-tree with 100,000,000 nodes, a block size of "
"4096 bytes, and an element size of 100 bytes. Thus each block will hold "
"up to 40 elements (all overhead considered), and the B-tree will consist "
"of around 2,570,000 blocks and 5 levels: the first four will have a size "
"of 256 Mb, while the last one will grow up to 10 Gb. Obviously, any "
"modern computer will be able to store all of the levels except the last "
"one in filesystem cache, so read requests will require just a single I/O "
"operation."
msgstr ""
"Чтобы наглядно представить себе эту структуру данных, возьмем B-дерево на"
" 100 000 000 узлов и предположим, что размер блока равен 4096 байтов, а "
"размер элемента -- 100 байтов. Таким образом, в каждом блоке можно будет "
"разместить до 40 элементов с учетом накладных расходов, а в B-дереве "
"будет около 2 570 000 блоков, пять уровней, при этом первые четыре займут"
" по 256 МБ, а последний -- до 10 ГБ. Очевидно, что на любом современном "
"компьютере все уровни, кроме последнего, успешно попадут в кэш файловой "
"системы, и фактически любая операция чтения будет требовать не более "
"одной операции ввода-вывода."

#: ../doc/1.10/book/box/engines/vinyl.rst:101
msgid ""
"But if we change our perspective —B-trees don’t look so good anymore. "
"Suppose we need to update a single element. Since working with B-trees "
"involves reading and writing whole blocks, we would have to read in one "
"whole block, change our 100 bytes out of 4096, and then write the whole "
"updated block to disk. In other words,we were forced to write 40 times "
"more data than we actually modified!"
msgstr ""
"Ситуация выглядит существенно менее радужно при смене точки зрения. "
"Предположим, что необходимо обновить один элемент дерева. Так как "
"операции с B-деревьями работают через чтение и запись целых блоков, "
"приходится прочитать 1 блок в память, изменить 100 байт из 4096, а затем "
"записать обновленный блок на диск. Таким образом, нам пришлось записать в"
" 40 раз больше, чем реальный объем измененных данных!"

#: ../doc/1.10/book/box/engines/vinyl.rst:108
msgid ""
"If you take into account the fact that an SSD block has a size of 64 Kb+ "
"and not every modification changes a whole element, the extra disk "
"workload can be greater still."
msgstr ""
"Принимая во внимание, что внутренний размер блока в SSD-дисках может быть"
" 64 КБ и больше, и не любое изменение элемента меняет его целиком, объем "
"\"паразитной\" нагрузки на диск может быть еще выше."

#: ../doc/1.10/book/box/engines/vinyl.rst:113
msgid ""
"Authors of specialized literature and blogs dedicated to on-disk data "
"storage have coined two terms for these phenomena: extra reads are "
"referred to as \"read amplification\" and writes as \"write "
"amplification\"."
msgstr ""
"Феномен таких \"паразитных\" чтений в литературе и блогах, посвященных "
"хранению на диске, называется read amplification (усложнение чтения), а "
"феномен \"паразитной\" записи -- write amplification (усложнение записи)."

#: ../doc/1.10/book/box/engines/vinyl.rst:117
msgid ""
"The amplification factor (multiplication coefficient) is calculated as "
"the ratio of the size of actual read (or written) data to the size of "
"data needed (or actually changed). In our B-tree example, the "
"amplification factor would be around 40 for both reads and writes."
msgstr ""
"Коэффициент усложнения, то есть коэффициент умножения, вычисляется как "
"отношение размера фактически прочитанных (или записанных) данных к "
"реально необходимому (или измененному) размеру. В нашем примере с "
"B-деревом коэффициент составит около 40 как для чтения, так и для записи."

#: ../doc/1.10/book/box/engines/vinyl.rst:123
msgid ""
"The huge number of extra I/O operations associated with updating data is "
"one of the main issues addressed by LSM trees. Let’s see how they work."
msgstr ""
"Объем \"паразитных\" операций ввода-вывода при обновлении данных является"
" одной из основных проблем, которую решают LSM-деревья. Рассмотрим, как "
"это работает."

#: ../doc/1.10/book/box/engines/vinyl.rst:127
msgid ""
"The key difference between LSM trees and regular B-trees is that LSM "
"trees don’t just store data (keys and values), but also data operations: "
"insertions and deletions."
msgstr ""
"Ключевое отличие LSM-деревьев от классических B-деревьев заключается в "
"том, что LSM-деревья не просто хранят данные (ключи и значения), а также "
"операции с данными: вставки и удаления."

#: ../doc/1.10/book/box/engines/vinyl.rst:133
#: ../doc/1.10/book/box/engines/vinyl.rst:189
#: ../doc/1.10/book/box/engines/vinyl.rst:204
#: ../doc/1.10/book/box/engines/vinyl.rst:226
#: ../doc/1.10/book/box/engines/vinyl.rst:278
#: ../doc/1.10/book/box/engines/vinyl.rst:303
#: ../doc/1.10/book/box/engines/vinyl.rst:640
#: ../doc/1.10/book/box/engines/vinyl.rst:792
msgid "|br|"
msgstr "|br|"

#: ../doc/1.10/book/box/engines/vinyl.rst:135
msgid "LSM tree:"
msgstr "LSM-дерево:"

#: ../doc/1.10/book/box/engines/vinyl.rst:140
msgid "Stores statements, not values:"
msgstr "Хранит операторы, а не значения:"

#: ../doc/1.10/book/box/engines/vinyl.rst:142
msgid ""
"Every statement is marked by LSN Append-only files, garbage is collected "
"after a checkpoint"
msgstr ""
"Для каждого оператора назначается LSN Обновление файлов происходит только"
" путем присоединения новых записей, сборка мусора проводится после "
"контрольной точки"

#: ../doc/1.10/book/box/engines/vinyl.rst:144
msgid "Transactional log of all filesystem changes: vylog"
msgstr "Журнал транзакций при любых изменениях в системе: vylog"

#: ../doc/1.10/book/box/engines/vinyl.rst:146
msgid ""
"For example, an element corresponding to an insertion operation has, "
"apart from a key and a value, an extra byte with an operation code "
"(\"REPLACE\" in the image above). An element representing the deletion "
"operation contains a key (since storing a value is unnecessary) and the "
"corresponding operation code—\"DELETE\". Also, each LSM tree element has "
"a log sequence number (LSN), which is the value of a monotonically "
"increasing sequence that uniquely identifies each operation. The whole "
"tree is first ordered by key in ascending order, and then, within a "
"single key scope, by LSN in descending order."
msgstr ""
"Например, элемент для операции вставки, помимо ключа и значения, содержит"
" дополнительный байт с кодом операции -- обозначенный выше как REPLACE. "
"Элемент для операции удаления содержит ключ элемента (хранить значение "
"нет необходимости) и соответствующий код операции -- DELETE. Также каждый"
" элемент LSM-дерева содержит порядковый номер операции (log sequence "
"number -- LSN), то есть значение монотонно возрастающей "
"последовательности, которое уникально идентифицирует каждую операцию. "
"Таким образом, всё дерево упорядочено сначала по возрастанию ключа, а в "
"пределах одного ключа -- по убыванию LSN."

#: ../doc/1.10/book/box/engines/vinyl.rst:157
msgid "*A single level of an LSM tree*"
msgstr "*Один уровень LSM-дерева*"

#: ../doc/1.10/book/box/engines/vinyl.rst:163
msgid "Filling an LSM tree"
msgstr "Наполнение LSM-дерева"

#: ../doc/1.10/book/box/engines/vinyl.rst:165
msgid ""
"Unlike a B-tree, which is stored completely on disk and can be partly "
"cached in RAM, when using an LSM tree, memory is explicitly separated "
"from disk right from the start. The issue of volatile memory and data "
"persistence is beyond the scope of the storage algorithm and can be "
"solved in various ways—for example, by logging changes."
msgstr ""
"В отличие от B-дерева, которое полностью хранится на диске и может "
"частично кэшироваться в оперативной памяти, в LSM-дереве разделение между"
" памятью и диском явно присутствует с самого начала. При этом проблема "
"сохранности данных, расположенных в энергозависимой памяти, выносится за "
"рамки алгоритма хранения: ее можно решить разными способами, например, "
"журналированием изменений."

#: ../doc/1.10/book/box/engines/vinyl.rst:171
msgid ""
"The part of an LSM tree that’s stored in RAM is called L0 (level zero). "
"The size of RAM is limited, so L0 is allocated a fixed amount of memory. "
"For example, in Tarantool, the L0 size is controlled by the "
"``vinyl_memory`` parameter. Initially, when an LSM tree is empty, "
"operations are written to L0. Recall that all elements are ordered by key"
" in ascending order, and then within a single key scope, by LSN in "
"descending order, so when a new value associated with a given key gets "
"inserted, it’s easy to locate the older value and delete it. L0 can be "
"structured as any container capable of storing a sorted sequence of "
"elements. For example, in Tarantool, L0 is implemented as a B+*-tree. "
"Lookups and insertions are standard operations for the data structure "
"underlying L0, so I won’t dwell on those."
msgstr ""
"Часть дерева, расположенную в оперативной памяти, называют L0 (level zero"
" -- уровень ноль). Объем оперативной памяти ограничен, поэтому для L0 "
"отводится фиксированная область. В конфигурации Tarantool'а, например, "
"размер L0 задается с помощью параметра ``vinyl_memory``. В начале, когда "
"LSM-дерево не содержит элементов, операции записываются в L0. Следует "
"отметить, что элементы в дереве упорядочены по возрастанию ключа, а затем"
" по убыванию LSN, так что в случае вставки нового значения по данному "
"ключу легко обнаружить и удалить предыдущее значение. L0 может быть "
"представлен любым контейнером, который сохраняет упорядоченность "
"элементов. Например, для хранения L0 Tarantool использует B+*-дерево. "
"Операции поиска и вставки -- это стандартные операции структуры данных, "
"используемой для представления L0, и мы их подробно рассматривать не "
"будем."

#: ../doc/1.10/book/box/engines/vinyl.rst:183
msgid ""
"Sooner or later the number of elements in an LSM tree exceeds the L0 size"
" and that’s when L0 gets written to a file on disk (called a \"run\") and"
" then cleared for storing new elements. This operation is called a "
"\"dump\"."
msgstr ""
"Рано или поздно количество элементов в дереве превысит размер L0. Тогда "
"L0 записывается в файл на диске (который называется забегом -- \"run\") и"
" освобождается под новые элементы. Эта операция называется \"дамп\" "
"(dump)."

#: ../doc/1.10/book/box/engines/vinyl.rst:191
msgid ""
"Dumps on disk form a sequence ordered by LSN: LSN ranges in different "
"runs don’t overlap, and the leftmost runs (at the head of the sequence) "
"hold newer operations. Think of these runs as a pyramid, with the newest "
"ones closer to the top. As runs keep getting dumped, the pyramid grows "
"higher. Note that newer runs may contain deletions or replacements for "
"existing keys. To remove older data, it’s necessary to perform garbage "
"collection (this process is sometimes called \"merge\" or \"compaction\")"
" by combining several older runs into a new one. If two versions of the "
"same key are encountered during a compaction, only the newer one is "
"retained; however, if a key insertion is followed by a deletion, then "
"both operations can be discarded."
msgstr ""
"Все дампы на диске образуют последовательность, упорядоченную по LSN: "
"диапазоны LSN в файлах не пересекаются, а ближе к началу "
"последовательности находятся файлы с более новыми операциями. Представим "
"эти файлы в виде пирамиды, где новые файлы расположены вверху, а старые "
"внизу. По мере появления новых файлов забегов, высота пирамиды растет. "
"При этом более свежие файлы могут содержать операции удаления или замены "
"для существующих ключей. Для удаления старых данных необходимо "
"производиться сборку мусора (этот процесс иногда называется \"слияние\" "
"-- в английском языке \"merge\" или \"compaction\"), объединяя нескольких"
" старых файлов в новый. Если при слиянии мы встречаем две версии одного и"
" того же ключа, то достаточно оставить только более новую версию, а если "
"после вставки ключа он был удален, то из результата можно исключить обе "
"операции."

#: ../doc/1.10/book/box/engines/vinyl.rst:206
msgid ""
"The key choices determining an LSM tree’s efficiency are which runs to "
"compact and when to compact them. Suppose an LSM tree stores a "
"monotonically increasing sequence of keys (1, 2, 3, ...,) with no "
"deletions. In this case, compacting runs would be useless: all of the "
"elements are sorted, the tree doesn’t have any garbage, and the location "
"of any key can unequivocally be determined. On the other hand, if an LSM "
"tree contains many deletions, doing a compaction would free up some disk "
"space. However, even if there are no deletions, but key ranges in "
"different runs overlap a lot, compacting such runs could speed up lookups"
" as there would be fewer runs to scan. In this case, it might make sense "
"to compact runs after each dump. But keep in mind that a compaction "
"causes all data stored on disk to be overwritten, so with few reads it’s "
"recommended to perform it less often."
msgstr ""
"Ключевым фактором эффективности LSM-дерева является то, в какой момент и "
"для каких файлов делается слияние. Представим, что LSM-дерево в качестве "
"ключей хранит монотонную последовательность вида 1, 2, 3 …, и операций "
"удаления нет. В этом случае слияние будет бесполезным -- все элементы уже"
" отсортированы, дерево не содержит мусор и можно однозначно определить, в"
" каком файле находится каждый ключ. Напротив, если LSM-дерево содержит "
"много операций удаления, слияние позволит освободить место на диске. Но "
"даже если удалений нет, а диапазоны ключей в разных файлах сильно "
"пересекаются, слияние может ускорить поиск, так как сократит число "
"просматриваемых файлов. В этом случае имеет смысл выполнять слияние после"
" каждого дампа. Однако следует отметить, что такое слияние приведет к "
"перезаписи всех данных на диске, поэтому если чтений мало, то лучше "
"делать слияния реже."

#: ../doc/1.10/book/box/engines/vinyl.rst:219
msgid ""
"To ensure it’s optimally configurable for any of the scenarios above, an "
"LSM tree organizes all runs into a pyramid: the newer the data "
"operations, the higher up the pyramid they are located. During a "
"compaction, the algorithm picks two or more neighboring runs of "
"approximately equal size, if possible."
msgstr ""
"Для оптимальной конфигурации под любой из описанных выше сценариев в "
"LSM-дереве все файлы организованы в пирамиду: чем новее операции с "
"данными, тем выше они находятся в пирамиде. При этом в слиянии участвуют "
"два или несколько соседних файлов в пирамиде; по возможности выбираются "
"файлы примерно одинакового размера."

#: ../doc/1.10/book/box/engines/vinyl.rst:228
msgid "Multi-level compaction can span any number of levels"
msgstr "Многоуровневое слияние может охватить любое количество уровней"

#: ../doc/1.10/book/box/engines/vinyl.rst:229
msgid "A level can contain multiple runs"
msgstr "Уровень может содержать несколько файлов"

#: ../doc/1.10/book/box/engines/vinyl.rst:231
msgid ""
"All of the neighboring runs of approximately equal size constitute an LSM"
" tree level on disk. The ratio of run sizes at different levels "
"determines the pyramid’s proportions, which allows optimizing the tree "
"for write-intensive or read-intensive scenarios."
msgstr ""
"Все соседние файлы примерно одинакового размера составляют уровень "
"LSM-дерева на диске. Соотношение размеров файлов на различных уровнях "
"определяет пропорции пирамиды, что позволяет оптимизировать дерево под "
"интенсивные вставки, либо интенсивные чтения."

#: ../doc/1.10/book/box/engines/vinyl.rst:236
msgid ""
"Suppose the L0 size is 100 Mb, the ratio of run sizes at each level (the "
"``vinyl_run_size_ratio`` parameter) is 5, and there can be no more than 2"
" runs per level (the ``vinyl_run_count_per_level`` parameter). After the "
"first 3 dumps, the disk will contain 3 runs of 100 Mb each—which "
"constitute L1 (level one). Since 3 > 2, the runs will be compacted into a"
" single 300 Mb run, with the older ones being deleted. After 2 more "
"dumps, there will be another compaction, this time of 2 runs of 100 Mb "
"each and the 300 Mb run, which will produce one 500 Mb run. It will be "
"moved to L2 (recall that the run size ratio is 5), leaving L1 empty. The "
"next 10 dumps will result in L2 having 3 runs of 500 Mb each, which will "
"be compacted into a single 1500 Mb run. Over the course of 10 more dumps,"
" the following will happen: 3 runs of 100 Mb each will be compacted "
"twice, as will two 100 Mb runs and one 300 Mb run, which will yield 2 new"
" 500 Mb runs in L2. Since L2 now has 3 runs, they will also be compacted:"
" two 500 Mb runs and one 1500 Mb run will produce a 2500 Mb run that will"
" be moved to L3, given its size."
msgstr ""
"Предположим, что размер L0 составляет 100 МБ, а соотношение размеров "
"файлов на каждом уровне (параметр ``vinyl_run_size_ratio``) равно 5, и на"
" каждом уровне может быть не более 2 файлов (параметр "
"``vinyl_run_count_per_level``). После первых трех дампов на диске "
"появятся 3 файла по 100 МБ, эти файлы образуют уровень L1. Так как 3 > 2,"
" запустится слияние файлов в новый файл размером 300 МБ, а старые будут "
"удалены. Спустя еще 2 дампа снова запустится слияние, на этот раз файлов "
"в 100, 100 и 300 МБ, в результате файл размером 500 МБ переместится на "
"уровень L2 (вспомним, что соотношение размеров уровней равно 5), а "
"уровень L1 останется пустым. Пройдут еще 10 дампов, и получим 3 файла по "
"500 МБ на уровне L2, в результате чего будет создан один файл размером "
"1500 МБ. Спустя еще 10 дампов произойдет следующее: 2 раза произведем "
"слияние 3 файлов по 100 МБ, а также 2 раза слияние файлов по 100, 100 и "
"300 МБ, что приведет к созданию двух файлов на уровне L2 по 500 МБ. "
"Поскольку на уровне L2 уже есть три файла, запустится слияние двух файлов"
" по 500 МБ и одного файла в 1500 МБ. Полученный в результате файл в 2500 "
"МБ, в силу своего размера, переедет на уровень L3."

#: ../doc/1.10/book/box/engines/vinyl.rst:251
msgid ""
"This can go on infinitely, but if an LSM tree contains lots of deletions,"
" the resulting compacted run can be moved not only down, but also up the "
"pyramid due to its size being smaller than the sizes of the original runs"
" that were compacted. In other words, it’s enough to logically track "
"which level a certain run belongs to, based on the run size and the "
"smallest and greatest LSN among all of its operations."
msgstr ""
"Процесс может продолжаться до бесконечности, а если в потоке операций с "
"LSM-деревом будет много удалений, образовавшийся в результате слияния "
"файл может переместиться не только вниз по пирамиде, но и вверх, так как "
"окажется меньше исходных файлов, использовавшихся при слиянии. Иными "
"словами, принадлежность файла к уровню достаточно отслеживать логически "
"на основе размера файла и минимального и максимального LSN среди всех "
"хранящихся в нем операций."

#: ../doc/1.10/book/box/engines/vinyl.rst:262
msgid "Controlling the form of an LSM tree"
msgstr "Управление формой LSM-дерева"

#: ../doc/1.10/book/box/engines/vinyl.rst:264
#, fuzzy
msgid ""
"If it’s necessary to reduce the number of runs for lookups, then the run "
"size ratio can be increased, thus bringing the number of levels down. If,"
" on the other hand, you need to minimize the compaction-related overhead,"
" then the run size ratio can be decreased: the pyramid will grow higher, "
"and even though runs will be compacted more often, they will be smaller, "
"which will reduce the total amount of work done. In general, write "
"amplification in an LSM tree is described by this formula: "
":math:`log_{x}(\\frac {N} {L0}) × x` or, alternatively, :math:`x × \\frac"
" {ln (\\frac {N} {C0})} {ln(x)}`, where N is the total size of all tree "
"elements, L0 is the level zero size, and x is the level size ratio (the "
"``level_size_ratio`` parameter). At :math:`\\frac {N} {C0}` = 40 (the "
"disk-to- memory ratio), the plot would look something like this:"
msgstr ""
"Если число файлов для поиска нужно уменьшить, то соотношение размеров "
"файлов на разных уровнях можно увеличить, и, как следствие, уменьшается "
"число уровней. Если, напротив, необходимо снизить затраты ресурсов, "
"вызванные слиянием, то можно уменьшить соотношение размеров уровней: "
"пирамида будет более высокой, а слияние хотя и выполняется чаще, но "
"работает в среднем с файлами меньшего размера, за счет чего суммарно "
"выполняет меньше работы. В целом, \"паразитная запись\" в LSM-дереве "
"описывается формулой :code:`log_{x}(\\frac {N} {L0}) × x` или :code:`x × "
"\\frac {ln (\\frac {N} {C0})} {ln(x)}`, где N -- это общий размер всех "
"элементов дерева, L0 -- это размер уровня ноль, а x -- это соотношение "
"размеров уровней (параметр ``level_size_ratio``). Если :code:`\\frac {N} "
"{C0}` = 40 (соотношение диск-память), график выглядит примерно вот так:"

#: ../doc/1.10/book/box/engines/vinyl.rst:280
msgid ""
"As for read amplification, it’s proportional to the number of levels. The"
" lookup cost at each level is no greater than that for a B-tree. Getting "
"back to the example of a tree with 100,000,000 elements: given 256 Mb of "
"RAM and the default values of ``vinyl_level_size_ratio`` and "
"``run_count_per_level``, write amplification would come out to about 13, "
"while read amplification could be as high as 150. Let’s try to figure out"
" why this happens."
msgstr ""
"\"Паразитное\" чтение при этом пропорционально количеству уровней. "
"Стоимость поиска на каждом уровне не превышает стоимости поиска в "
"B-дереве. Возвращаясь к нашему примеру дерева в 100 000 000 элементов: "
"при наличии 256 МБ оперативной памяти и стандартных значений параметров "
"``vinyl_level_size_ratio`` и ``run_count_per_level``, получим коэффициент"
" \"паразитной\" записи равным примерно 13, коэффициент \"паразитной\" "
"записи может доходить до 150. Разберемся, почему это происходит."

#: ../doc/1.10/book/box/engines/vinyl.rst:291
msgid "Search"
msgstr "Поиск"

#: ../doc/1.10/book/box/engines/vinyl.rst:293
msgid ""
"When doing a lookup in an LSM tree, what we need to find is not the "
"element itself, but the most recent operation associated with it. If it’s"
" a deletion, then the tree doesn’t contain this element. If it’s an "
"insertion, we need to grab the topmost value in the pyramid, and the "
"search can be stopped after finding the first matching key. In the worst-"
"case scenario, that is if the tree doesn’t hold the needed element, the "
"algorithm will have to sequentially visit all of the levels, starting "
"from L0."
msgstr ""
"При поиске в LSM-дереве нам необходимо найти не сам элемент, а последнюю "
"операцию с ним. Если это операция удаления, искомый элемент отсутствует в"
" дереве. Если это операция вставки, то искомому элементу соответствует "
"самое верхнее значение в LSM-пирамиде, и поиск можно остановить при "
"первом совпадении ключа. В худшем случае значение в дереве изначально "
"отсутствовало. Тогда поиск вынужден последовательно перебрать все уровни "
"дерева, начиная с L0."

#: ../doc/1.10/book/box/engines/vinyl.rst:305
msgid ""
"Unfortunately, this scenario is quite common in real life. For example, "
"when inserting a value into a tree, it’s necessary to make sure there are"
" no duplicates among primary/unique keys. So to speed up membership "
"checks, LSM trees use a probabilistic data structure called a \"Bloom "
"filter\", which will be covered a bit later, in a section on how vinyl "
"works under the hood."
msgstr ""
"К сожалению, на практике этот худший случай довольно распространен. "
"Например, при вставке в дерево необходимо убедиться в отсутствии "
"дубликатов для первичного или уникального ключа. Поэтому для ускорения "
"поиска несуществующих значений в LSM-деревьях применяется вероятностная "
"структура данных, которая называется \"фильтр Блума\". О нем мы поговорим"
" более детально в разделе, посвященном внутреннему устройству vinyl."

#: ../doc/1.10/book/box/engines/vinyl.rst:315
msgid "Range searching"
msgstr "Поиск по диапазону"

#: ../doc/1.10/book/box/engines/vinyl.rst:317
msgid ""
"In the case of a single-key search, the algorithm stops after "
"encountering the first match. However, when searching within a certain "
"key range (for example, looking for all the users with the last name "
"\"Ivanov\"), it’s necessary to scan all tree levels."
msgstr ""
"Если при поиске по одному ключу алгоритм завершается после первого "
"совпадения, то для поиска всех значений в диапазоне (например, всех "
"пользователей с фамилией \"Иванов\") необходимо просматривать все уровни "
"дерева."

#: ../doc/1.10/book/box/engines/vinyl.rst:324
msgid "*Searching within a range of [24,30)*"
msgstr "*Поиск по диапазону [24,30)*"

#: ../doc/1.10/book/box/engines/vinyl.rst:326
msgid ""
"The required range is formed the same way as when compacting several "
"runs: the algorithm picks the key with the largest LSN out of all the "
"sources, ignoring the other associated operations, then moves on to the "
"next key and repeats the procedure."
msgstr ""
"Формирование искомого диапазона при этом происходит так же, как и при "
"слиянии нескольких файлов: из всех источников алгоритм выбирает ключ с "
"максимальным LSN, отбрасывает остальные операции по этому ключу, сдвигает"
" позицию поиска на следующий ключ и повторяет процедуру."

#: ../doc/1.10/book/box/engines/vinyl.rst:335
msgid "Deletion"
msgstr "Удаление"

#: ../doc/1.10/book/box/engines/vinyl.rst:337
msgid ""
"Why would one store deletions? And why doesn’t it lead to a tree overflow"
" in the case of for i=1,10000000 put(i) delete(i) end?"
msgstr ""
"Зачем вообще хранить операции удаления? И почему это не приводит к "
"переполнению дерева, например, в сценарии for i=1,10000000 put(i) "
"delete(i) end?"

#: ../doc/1.10/book/box/engines/vinyl.rst:340
msgid ""
"With regards to lookups, deletions signal the absence of a value being "
"searched; with compactions, they clear the tree of \"garbage\" records "
"with older LSNs."
msgstr ""
"Роль операций удаления при поиске -- сообщать об отсутствии искомого "
"значения, а при слиянии -- очищать дерево от \"мусорных\" записей с более"
" старыми LSN."

#: ../doc/1.10/book/box/engines/vinyl.rst:343
msgid ""
"While the data is in RAM only, there’s no need to store deletions. "
"Similarly, you don’t need to keep them following a compaction if they "
"affect, among other things, the lowest tree level, which contains the "
"oldest dump. Indeed, if a value can’t be found at the lowest level, then "
"it doesn’t exist in the tree."
msgstr ""
"Пока данные хранятся только в оперативной памяти, нет необходимости "
"хранить операции удаления. Также нет необходимости сохранять операции "
"удаления после слияния, если оно затрагивает в том числе самый нижний "
"уровень дерева -- на нем находятся данные самого старого дампа. "
"Действительно, отсутствие значения на последнем уровне означает, что оно "
"отсутствует в дереве."

#: ../doc/1.10/book/box/engines/vinyl.rst:348
msgid "We can't delete from append-only files"
msgstr ""
"Нельзя производить удаление из файлов, которые обновляются только путем "
"присоединения новых записей"

#: ../doc/1.10/book/box/engines/vinyl.rst:349
msgid "Tombstones (delete markers) are inserted into L0 instead"
msgstr "Вместо этого на уровень L0 вносятся маркеры удаленных записей (tombstones)"

#: ../doc/1.10/book/box/engines/vinyl.rst:353
msgid "*Deletion, step 1: a tombstone is inserted into L0*"
msgstr "*Удаление, шаг 1: вставка удаленной записи в L0*"

#: ../doc/1.10/book/box/engines/vinyl.rst:357
msgid "*Deletion, step 2: the tombstone passes through intermediate levels*"
msgstr "*Удаление, шаг 2: удаленная запись проходит через промежуточные уровни*"

#: ../doc/1.10/book/box/engines/vinyl.rst:361
msgid ""
"*Deletion, step 3: in the case of a major compaction, the tombstone is "
"removed from the tree*"
msgstr ""
"*Удаление, шаг 3: при значительном слиянии удаленная запись удаляется из "
"дерева*"

#: ../doc/1.10/book/box/engines/vinyl.rst:363
msgid ""
"If a deletion is known to come right after the insertion of a unique "
"value, which is often the case when modifying a value in a secondary "
"index, then the deletion can safely be filtered out while compacting "
"intermediate tree levels. This optimization is implemented in vinyl."
msgstr ""
"Если мы знаем, что удаление следует сразу за вставкой уникального "
"значения -- а это частый случай при изменении значения во вторичном "
"индексе -- то операцию удаления можно отфильтровывать уже при слиянии "
"промежуточных уровней. Эта оптимизация реализована в vinyl'е."

#: ../doc/1.10/book/box/engines/vinyl.rst:372
msgid "Advantages of an LSM tree"
msgstr "Преимущества LSM-дерева"

#: ../doc/1.10/book/box/engines/vinyl.rst:374
msgid ""
"Apart from decreasing write amplification, the approach that involves "
"periodically dumping level L0 and compacting levels L1-Lk has a few "
"advantages over the approach to writes adopted by B-trees:"
msgstr ""
"Помимо снижения \"паразитной\" записи, подход с периодическими дампами "
"уровня L0 и слиянием уровней L1-Lk имеет ряд преимуществ перед подходом к"
" записи, используемым в B-деревьях:"

#: ../doc/1.10/book/box/engines/vinyl.rst:378
msgid ""
"Dumps and compactions write relatively large files: typically, the L0 "
"size is 50-100 Mb, which is thousands of times larger than the size of a "
"B-tree block."
msgstr ""
"При дампах и слиянии создаются относительно большие файлы: стандартный "
"размер L0 составляет 50-100 MБ, что в тысячи раз превышает размер блока "
"B-дерева."

#: ../doc/1.10/book/box/engines/vinyl.rst:381
msgid ""
"This large size allows efficiently compressing data before writing it. "
"Tarantool compresses data automatically, which further decreases write "
"amplification."
msgstr ""
"Большой размер позволяет эффективно сжимать данные перед записью. В "
"Tarantool'е сжатие происходит автоматически, что позволяет еще больше "
"уменьшить \"паразитную\" запись."

#: ../doc/1.10/book/box/engines/vinyl.rst:384
msgid ""
"There is no fragmentation overhead, since there’s no padding/empty space "
"between the elements inside a run."
msgstr ""
"Издержки фрагментации отсутствуют, потому что в файле элементы следуют "
"друг за другом без пустот/заполнений."

#: ../doc/1.10/book/box/engines/vinyl.rst:386
msgid ""
"All operations create new runs instead of modifying older data in place. "
"This allows avoiding those nasty locks that everyone hates so much. "
"Several operations can run in parallel without causing any conflicts. "
"This also simplifies making backups and moving data to replicas."
msgstr ""
"Все операции создают новые файлы, а не заменяют старые данные. Это "
"позволяет избавиться от столь ненавистных нам блокировок, при этом "
"несколько операций могут идти параллельно, не приводя к конфликтам. Это "
"также упрощает создание резервных копий и перенос данных на реплику."

#: ../doc/1.10/book/box/engines/vinyl.rst:391
msgid ""
"Storing older versions of data allows for the efficient implementation of"
" transaction support by using multiversion concurrency control."
msgstr ""
"Хранение старых версий данных позволяет эффективно реализовать поддержку "
"транзакций, используя подход управления параллельным доступом с помощью "
"многоверсионности."

#: ../doc/1.10/book/box/engines/vinyl.rst:399
msgid "Disadvantages of an LSM tree and how to deal with them"
msgstr "Недостатки LSM-дерева и их устранение"

#: ../doc/1.10/book/box/engines/vinyl.rst:401
#, fuzzy
msgid ""
"One of the key advantages of the B-tree as a search data structure is its"
" predictability: all operations take no longer than :math:`log_{B}(N)` to"
" run. Conversely, in a classical LSM tree, both read and write speeds can"
" differ by a factor of hundreds (best case scenario) or even thousands "
"(worst case scenario). For example, adding just one element to L0 can "
"cause it to overflow, which can trigger a chain reaction in levels L1, "
"L2, and so on. Lookups may find the needed element in L0 or may need to "
"scan all of the tree levels. It’s also necessary to optimize reads within"
" a single level to achieve speeds comparable to those of a B-tree. "
"Fortunately, most disadvantages can be mitigated or even eliminated with "
"additional algorithms and data structures. Let’s take a closer look at "
"these disadvantages and how they’re dealt with in Tarantool."
msgstr ""
"Одним из ключевых преимуществ B-дерева как структуры данных для поиска "
"является предсказуемость: любая операция занимает не более чем "
":code:`log_{B}(N)`. В классическом LSM-дереве скорость как чтения, так и "
"записи могут может отличаться в лучшем и худшем случае в сотни и тысячи "
"раз. Например, добавление всего лишь одного элемента в L0 может привести "
"к его переполнению, что в свою очередь, может привести к переполнению L1,"
" L2 и т.д. Процесс чтения может обнаружить исходный элемент в L0, а может"
" задействовать все уровни. Чтение в пределах одного уровня также "
"необходимо оптимизировать, чтобы добиться скорости, сравнимой с "
"B-деревом. К счастью, многие недостатки можно скрасить или полностью "
"устранить с помощью вспомогательных алгоритмов и структур данных. "
"Систематизируем эти недостатки и опишем способы борьбы с ними, "
"используемые в Tarantool'е."

#: ../doc/1.10/book/box/engines/vinyl.rst:417
msgid "Unpredictable write speed"
msgstr "Непредсказуемая скорость записи"

#: ../doc/1.10/book/box/engines/vinyl.rst:419
msgid ""
"In an LSM tree, insertions almost always affect L0 only. How do you avoid"
" idle time when the memory area allocated for L0 is full?"
msgstr ""
"Вставка данных в LSM-дерево почти всегда задействует исключительно L0. "
"Как избежать простоя, если заполнена область оперативной памяти, "
"отведенная под L0?"

#: ../doc/1.10/book/box/engines/vinyl.rst:422
msgid ""
"Clearing L0 involves two lengthy operations: writing to disk and memory "
"deallocation. To avoid idle time while L0 is being dumped, Tarantool uses"
" writeaheads. Suppose the L0 size is 256 Mb. The disk write speed is 10 "
"Mbps. Then it would take 26 seconds to dump L0. The insertion speed is "
"10,000 RPS, with each key having a size of 100 bytes. While L0 is being "
"dumped, it’s necessary to reserve 26 Mb of RAM, effectively slicing the "
"L0 size down to 230 Mb."
msgstr ""
"Освобождение L0 подразумевает две долгих операции: запись на диск и "
"освобождение памяти. Чтобы избежать простоя во время записи L0 на диск, "
"Tarantool использует упреждающую запись. Допустим, размер L0 составляет "
"256 MБ. Скорость записи на диск составляет 10 МБ/с. Тогда для записи L0 "
"на диск понадобится 26 секунд. Скорость вставки данных составляет 10 000 "
"запросов в секунду, а размер одного ключа -- 100 байтов. На время записи "
"необходимо зарезервировать около 26 MБ доступной оперативной памяти, "
"сократив реальный полезный размер L0 до 230 MБ."

#: ../doc/1.10/book/box/engines/vinyl.rst:430
msgid ""
"Tarantool does all of these calculations automatically, constantly "
"updating the rolling average of the DBMS workload and the histogram of "
"the disk speed. This allows using L0 as efficiently as possible and it "
"prevents write requests from timing out. But in the case of workload "
"surges, some wait time is still possible. That’s why we also introduced "
"an insertion timeout (the ``vinyl_timeout`` parameter), which is set to "
"60 seconds by default. The write operation itself is executed in "
"dedicated threads. The number of these threads (2 by default) is "
"controlled by the ``vinyl_write_threads`` parameter. The default value of"
" 2 allows doing dumps and compactions in parallel, which is also "
"necessary for ensuring system predictability."
msgstr ""
"Все эти расчеты Tarantool делает автоматически, постоянно поддерживая "
"скользящее среднее значение нагрузки на СУБД и гистограмму скорости "
"работы диска. Это позволяет максимально эффективно использовать L0 и "
"избежать истечения времени ожидания доступной памяти для операций записи."
" При резком всплеске нагрузки ожидание все же возможно, поэтому также "
"существует время ожидания операции вставки (параметр ``vinyl_timeout``), "
"значение которого по умолчанию составляет 60 секунд. Сама запись "
"осуществляется в выделенных потоках, число которых (2 по умолчанию) "
"задается в параметре ``vinyl_write_threads``. Используемое по умолчанию "
"значение 2 позволяет выполнять дамп параллельно со слиянием, что также "
"необходимо для предсказуемой работы системы."

#: ../doc/1.10/book/box/engines/vinyl.rst:441
msgid ""
"In Tarantool, compactions are always performed independently of dumps, in"
" a separate execution thread. This is made possible by the append-only "
"nature of an LSM tree: after dumps runs are never changed, and "
"compactions simply create new runs."
msgstr ""
"Слияния в Tarantool'е всегда выполняются независимо от дампов, в "
"отдельном потоке выполнения. Это возможно благодаря природе LSM-дерева --"
" после записи файлы в дереве никогда не меняются, а слияние лишь создает "
"новый файл."

#: ../doc/1.10/book/box/engines/vinyl.rst:446
msgid ""
"Delays can also be caused by L0 rotation and the deallocation of memory "
"dumped to disk: during a dump, L0 memory is owned by two operating system"
" threads, a transaction processing thread and a write thread. Even though"
" no elements are being added to the rotated L0, it can still be used for "
"lookups. To avoid read locks when doing lookups, the write thread doesn’t"
" deallocate the dumped memory, instead delegating this task to the "
"transaction processor thread. Following a dump, memory deallocation "
"itself happens instantaneously: to achieve this, L0 uses a special "
"allocator that deallocates all of the memory with a single operation."
msgstr ""
"К задержкам также может приводить ротация L0 и освобождение памяти, "
"записанной на диск: в процессе записи памятью L0 владеют два потока "
"операционной системы -- поток обработки транзакций и поток записи. Хотя в"
" L0 во время ротации элементы не добавляются, он может участвовать в "
"поиске. Чтобы избежать блокировок на чтение во время поиска, поток записи"
" не освобождает записанную память, а оставляет эту задачу потоку "
"обработки транзакций. Само освобождение после завершения дампа происходит"
" мгновенно: для этого в L0 используется специализированный механизм "
"распределения, позволяющий освободить всю память за одну операцию."

#: ../doc/1.10/book/box/engines/vinyl.rst:458
msgid "anticipatory dump"
msgstr "упреждающий дамп"

#: ../doc/1.10/book/box/engines/vinyl.rst:459
msgid "throttling"
msgstr "загрузка"

#: ../doc/1.10/book/box/engines/vinyl.rst:461
msgid ""
"The dump is performed from the so-called \"shadow\" L0 without blocking "
"new insertions and lookups"
msgstr ""
"Дамп происходит из так называемого \"теневого\" L0, не блокируя новые "
"вставки и чтения"

#: ../doc/1.10/book/box/engines/vinyl.rst:468
msgid "Unpredictable read speed"
msgstr "Непредсказуемая скорость чтений"

#: ../doc/1.10/book/box/engines/vinyl.rst:470
msgid ""
"Optimizing reads is the most difficult optimization task with regards to "
"LSM trees. The main complexity factor here is the number of levels: any "
"optimization causes not only much slower lookups, but also tends to "
"require significantly larger RAM resources. Fortunately, the append-only "
"nature of LSM trees allows us to address these problems in ways that "
"would be nontrivial for traditional data structures."
msgstr ""
"Чтение -- самая сложная задача для оптимизации в LSM-деревьях. Главным "
"фактором сложности является большое количество уровней: это не только "
"значительно замедляет поиск, но и потенциально значительно увеличивает "
"требования к оперативной памяти при почти любых попытках оптимизации. К "
"счастью, природа LSM-деревьев, где файлы обновляются только путем "
"присоединения новых записей, позволяет решать эти проблемы нестандартными"
" для традиционных структур данных способами."

#: ../doc/1.10/book/box/engines/vinyl.rst:479
msgid "page index"
msgstr "постраничный индекс"

#: ../doc/1.10/book/box/engines/vinyl.rst:480
msgid "bloom filters"
msgstr "фильтры Блума"

#: ../doc/1.10/book/box/engines/vinyl.rst:481
msgid "tuple range cache"
msgstr "кэш диапазона кортежей"

#: ../doc/1.10/book/box/engines/vinyl.rst:482
msgid "multi-level compaction"
msgstr "многоуровневое слияние"

#: ../doc/1.10/book/box/engines/vinyl.rst:488
msgid "Compression and page index"
msgstr "Сжатие и постраничный индекс"

#: ../doc/1.10/book/box/engines/vinyl.rst:490
msgid ""
"In B-trees, data compression is either the hardest problem to crack or a "
"great marketing tool—rather than something really useful. In LSM trees, "
"compression works as follows:"
msgstr ""
"Сжатие данных в B-деревьях -- это либо сложнейшая в реализации задача, "
"либо больше средство маркетинга, чем действительно полезный инструмент. "
"Сжатие в LSM-деревьях работает следующим образом:"

#: ../doc/1.10/book/box/engines/vinyl.rst:494
msgid ""
"During a dump or compaction all of the data within a single run is split "
"into pages. The page size (in bytes) is controlled by the "
"``vinyl_page_size`` parameter and can be set separately for each index. A"
" page doesn’t have to be exactly of ``vinyl_page_size`` size—depending on"
" the data it holds, it can be a little bit smaller or larger. Because of "
"this, pages never have any empty space inside."
msgstr ""
"При любом дампе или слиянии мы разбиваем все данные в одном файле на "
"страницы. Размер страницы в байтах задается в параметре "
"``vinyl_page_size``, который можно менять отдельно для каждого индекса. "
"Страница не обязана занимать строго то количество байт, которое прописано"
" ``vinyl_page_size`` -- она может быть чуть больше или чуть меньше, в "
"зависимости от хранящихся в ней данных. Благодаря этому страница никогда "
"не содержит пустот."

#: ../doc/1.10/book/box/engines/vinyl.rst:501
msgid ""
"Data is compressed by `Facebook’s streaming algorithm "
"<https://github.com/facebook/zstd>`_ called \"zstd\". The first key of "
"each page, along with the page offset, is added to a \"page index\", "
"which is a separate file that allows the quick retrieval of any page. "
"After a dump or compaction, the page index of the created run is also "
"written to disk."
msgstr ""
"Для сжатия используется `потоковый алгоритм Facebook "
"<https://github.com/facebook/zstd>`_ под названием \"zstd\". Первый ключ "
"каждой страницы и смещение страницы в файле добавляются в так называемый "
"постраничный индекс (page index) -- отдельный файл, который позволяет "
"быстро найти нужную страницу. После дампа или слияния постраничный индекс"
" созданного файла также записывается на диск."

#: ../doc/1.10/book/box/engines/vinyl.rst:508
msgid ""
"All `.index` files are cached in RAM, which allows finding the necessary "
"page with a single lookup in a `.run` file (in vinyl, this is the "
"extension of files resulting from a dump or compaction). Since data "
"within a page is sorted, after it’s read and decompressed, the needed key"
" can be found using a regular binary search. Decompression and reads are "
"handled by separate threads, and are controlled by the "
"``vinyl_read_threads`` parameter."
msgstr ""
"Все файлы типа `.index`  кэшируются в оперативной памяти, что позволяет "
"найти нужную страницу за одно чтение из файла `.run` (такое расширение "
"имени файла используется в vinyl'е для файлов, полученных в результате "
"дампа или слияния). Поскольку данные в странице отсортированы, после "
"чтения и декомпрессии нужный ключ можно найти с помощью простого "
"бинарного поиска. За чтение и декомпрессию отвечают отдельные потоки, их "
"количество определяется в параметре ``vinyl_read_threads``."

#: ../doc/1.10/book/box/engines/vinyl.rst:515
msgid ""
"Tarantool uses a universal file format: for example, the format of a "
"`.run` file is no different from that of an `.xlog` file (log file). This"
" simplifies backup and recovery as well as the usage of external tools."
msgstr ""
"Tarantool использует единый формат файлов: например, формат данных в "
"файле `.run` ничем не отличается от формата файла `.xlog`  (файл "
"журнала). Это упрощает резервное копирование и восстановление, а также "
"работу внешних инструментов."

#: ../doc/1.10/book/box/engines/vinyl.rst:523
msgid "Bloom filters"
msgstr "Фильтры Блума"

#: ../doc/1.10/book/box/engines/vinyl.rst:525
msgid ""
"Even though using a page index enables scanning fewer pages per run when "
"doing a lookup, it’s still necessary to traverse all of the tree levels. "
"There’s a special case, which involves checking if particular data is "
"absent when scanning all of the tree levels and it’s unavoidable: I’m "
"talking about insertions into a unique index. If the data being inserted "
"already exists, then inserting the same data into a unique index should "
"lead to an error. The only way to throw an error in an LSM tree before a "
"transaction is committed is to do a search before inserting the data. "
"Such reads form a class of their own in the DBMS world and are called "
"\"hidden\" or \"parasitic\" reads."
msgstr ""
"Хотя постраничный индекс позволяет уменьшить количество страниц, "
"просматриваемых при поиске в одном файле, он не отменяет необходимости "
"искать на всех уровнях дерева. Есть важный частный случай, когда "
"необходимо проверить отсутствие данных, и тогда просмотр всех уровней "
"неизбежен: вставка в уникальный индекс. Если данные уже существуют, то "
"вставка в уникальный индекс должна завершиться с ошибкой. Единственный "
"способ вернуть ошибку до завершения транзакции в LSM-дереве -- произвести"
" поиск перед вставкой. Такого рода чтения в СУБД образуют целый класс, "
"называемый \"скрытыми\" или \"паразитными\" чтениями."

#: ../doc/1.10/book/box/engines/vinyl.rst:535
msgid ""
"Another operation leading to hidden reads is updating a value in a field "
"on which a secondary index is defined. Secondary keys are regular LSM "
"trees that store differently ordered data. In most cases, in order not to"
" have to store all of the data in all of the indexes, a value associated "
"with a given key is kept in whole only in the primary index (any index "
"that stores both a key and a value is called \"covering\" or "
"\"clustered\"), whereas the secondary index only stores the fields on "
"which a secondary index is defined, and the values of the fields that are"
" part of the primary index. Thus, each time a change is made to a value "
"in a field on which a secondary index is defined, it’s necessary to first"
" remove the old key from the secondary index—and only then can the new "
"key be inserted. At update time, the old value is unknown, and it is this"
" value that needs to be read in from the primary key \"under the hood\"."
msgstr ""
"Другая операция, приводящая к скрытым чтениям, -- обновление значения, по"
" которому построен вторичный индекс. Вторичные ключи представляют собой "
"обычные LSM-деревья, в которых данные хранятся в другом порядке. Чаще "
"всего, чтобы не хранить все данные во всех индексах, значение, "
"соответствующее данному ключу, целиком сохраняется только в первичном "
"индексе (любой индекс, хранящий и ключ, и значение, называется "
"покрывающим или кластерным), а во вторичном индексе сохраняются лишь "
"поля, по которым построен вторичный индекс, и значения полей, участвующих"
" в первичном индексе. Тогда при любом изменении значения, по которому "
"построен вторичный ключ, приходится сначала удалять из вторичного индекса"
" старый ключ, и только потом вставлять новый. Старое значение во время "
"обновления неизвестно -- именно его и нужно читать из первичного ключа с "
"точки зрения внутреннего устройства."

#: ../doc/1.10/book/box/engines/vinyl.rst:550
msgid "update t1 set city=’Moscow’ where id=1"
msgstr "update t1 set city=’Moscow’ where id=1"

#: ../doc/1.10/book/box/engines/vinyl.rst:554
msgid ""
"To minimize the number of disk reads, especially for nonexistent data, "
"nearly all LSM trees use probabilistic data structures, and Tarantool is "
"no exception. A classical Bloom filter is made up of several (usually "
"3-to-5) bit arrays. When data is written, several hash functions are "
"calculated for each key in order to get corresponding array positions. "
"The bits at these positions are then set to 1. Due to possible hash "
"collisions, some bits might be set to 1 twice. We’re most interested in "
"the bits that remain 0 after all keys have been added. When looking for "
"an element within a run, the same hash functions are applied to produce "
"bit positions in the arrays. If any of the bits at these positions is 0, "
"then the element is definitely not in the run. The probability of a false"
" positive in a Bloom filter is calculated using Bayes’ theorem: each hash"
" function is an independent random variable, so the probability of a "
"collision simultaneously occurring in all of the bit arrays is "
"infinitesimal."
msgstr ""
"Чтобы уменьшить количество чтений с диска, особенно для несуществующих "
"значений, практически все LSM-деревья используют вероятностные структуры "
"данных. Tarantool не исключение. Классический фильтр Блума -- это набор "
"из нескольких (обычно 3-5) битовых массивов. При записи для каждого ключа"
" вычисляется несколько хеш-функций, и в каждом массиве выставляется бит, "
"соответствующий значению хеша. При хешировании могут возникнуть коллизии,"
" поэтому некоторые биты могут быть проставлены дважды. Интерес "
"представляют биты, которые оказались не проставлены после записи всех "
"ключей. При поиске также вычисляются выбранные хеш-функции. Если хотя бы "
"в одном из битовых массивов бит не стоит, то значение в файле "
"отсутствует. Вероятность срабатывания фильтра Блума определяется теоремой"
" Байеса: каждая хеш-функция представляет собой независимую случайную "
"величину, благодаря чему вероятность того, что во всех битовых массивах "
"одновременно произойдет коллизия, очень мала."

#: ../doc/1.10/book/box/engines/vinyl.rst:568
#, python-format
msgid ""
"The key advantage of Bloom filters in Tarantool is that they’re easily "
"configurable. The only parameter that can be specified separately for "
"each index is called ``bloom_fpr`` (FPR stands for \"false positive "
"ratio\") and it has the default value of 0.05, which translates to a 5% "
"FPR. Based on this parameter, Tarantool automatically creates Bloom "
"filters of the optimal size for partial- key and full-key searches. The "
"Bloom filters are stored in the `.index` file, along with the page index,"
" and are cached in RAM."
msgstr ""
"Ключевым преимуществом реализации фильтров Блума в Tarantool'е является "
"простота настройки. Единственный параметр, который можно менять "
"независимо для каждого индекса, называется ``bloom_fpr`` (FPR в данном "
"случае означает сокращение от \"false positive ratio\" -- коэффициент "
"ложноположительного срабатывания), который по умолчанию равен 0,05, или "
"5%. На основе этого параметра Tarantool автоматически строит фильтры "
"Блума оптимального размера для поиска как по полному ключу, так и по "
"компонентам ключа. Сами фильтры Блума хранятся вместе с постраничным "
"индексом в файле `.index` и кэшируются в оперативной памяти."

#: ../doc/1.10/book/box/engines/vinyl.rst:580
msgid "Caching"
msgstr "Кэширование"

#: ../doc/1.10/book/box/engines/vinyl.rst:582
msgid ""
"A lot of people think that caching is a silver bullet that can help with "
"any performance issue. \"When in doubt, add more cache\". In vinyl, "
"caching is viewed rather as a means of reducing the overall workload and "
"consequently, of getting a more stable response time for those requests "
"that don’t hit the cache. vinyl boasts a unique type of cache among "
"transactional systems called a \"range tuple cache\". Unlike, say, "
"RocksDB or MySQL, this cache doesn’t store pages, but rather ranges of "
"index values obtained  from disk, after having performed a compaction "
"spanning all tree levels. This allows the use of caching for both single-"
"key and key-range searches. Since this method of caching stores only hot "
"data and not, say, pages (you may need only some data from a page), RAM "
"is used in the most efficient way possible. The cache size is controlled "
"by the ``vinyl_cache`` parameter."
msgstr ""
"Многие привыкли считать кэширование панацеей от всех проблем с "
"производительностью: \"В любой непонятной ситуации добавляй кэш\". В "
"vinyl'е мы смотрим на кэш скорее как на средство снижения общей нагрузки "
"на диск, и, как следствие, получения более предсказуемого времени ответов"
" на запросы, которые не попали в кэш. В vinyl'е реализован уникальный для"
" транзакционных систем вид кэша под названием \"кэш диапазона кортежей\" "
"(range tuple cache). В отличие от RocksDB, например, или MySQL, этот кэш "
"хранит не страницы, а уже готовые диапазоны значений индекса, после их "
"чтения с диска и слияния всех уровней. Это позволяет использовать кэш для"
" запросов как по одному ключу, так и по диапазону ключей. Поскольку в "
"кэше хранятся только горячие данные, а не, скажем, страницы (в странице "
"может быть востребована лишь часть данных), оперативная память "
"используется наиболее оптимально. Размер кэша задается в параметре "
"``vinyl_cache``."

#: ../doc/1.10/book/box/engines/vinyl.rst:599
msgid "Garbage collection control"
msgstr "Управление сборкой мусора"

#: ../doc/1.10/book/box/engines/vinyl.rst:601
msgid ""
"Chances are that by now you’ve started losing focus and need a well-"
"deserved dopamine reward. Feel free to take a break, since working "
"through the rest of the article is going to take some serious mental "
"effort."
msgstr ""
"Возможно, добравшись до этого места вы уже начали терять концентрацию и "
"нуждаетесь в заслуженной дозе допамина. Самое время сделать перерыв, так "
"как для того, чтобы разобраться с оставшейся частью, понадобятся "
"серьезные усилия."

#: ../doc/1.10/book/box/engines/vinyl.rst:605
msgid ""
"An LSM tree in vinyl is just a small piece of the puzzle. Even with a "
"single table (or so-called \"space\"), vinyl creates and maintains "
"several LSM trees, one for each index. But even a single index can be "
"comprised of dozens of LSM trees. Let’s try to understand why this might "
"be necessary."
msgstr ""
"В vinyl'е устройство одного LSM-дерева -- это лишь фрагмент мозаики. "
"Vinyl создает и обслуживает несколько LSM-деревьев даже для одной таблицы"
" (так называемого спейса) -- по одному дереву на каждый индекс. Но даже "
"один единственный индекс может состоять из десятков LSM-деревьев. "
"Попробуем разобраться, зачем."

#: ../doc/1.10/book/box/engines/vinyl.rst:610
msgid ""
"Recall our example with a tree containing 100,000,000 records, 100 bytes "
"each. As time passes, the lowest LSM level may end up holding a 10 Gb "
"run. During compaction, a temporary run of approximately the same size "
"will be created. Data at intermediate levels takes up some space as well,"
" since the tree may store several operations associated with a single "
"key. In total, storing 10 Gb of actual data may require up to 30 Gb of "
"free space: 10 Gb for the last tree level, 10 Gb for a temporary run, and"
" 10 Gb for the remaining data. But what if the data size is not 10 Gb, "
"but 1 Tb? Requiring that the available disk space always be several times"
" greater than the actual data size is financially unpractical, not to "
"mention that it may take dozens of hours to create a 1 Tb run. And in the"
" case of an emergency shutdown or system restart, the process would have "
"to be started from scratch."
msgstr ""
"Рассмотрим наш стандартный пример: 100 000 000 записей по 100 байтов "
"каждая. Через некоторое время на самом нижнем уровне LSM у нас может "
"оказаться файл размером 10 ГБ. Во время слияния последнего уровня мы "
"создадим временный файл, который также будет занимать около 10 ГБ. Данные"
" на промежуточных уровнях тоже занимают место: по одному и тому же ключу "
"дерево может хранить несколько операций. Суммарно для хранения 10 ГБ "
"полезных данных нам может потребоваться до 30 ГБ свободного места: 10 ГБ "
"на последний уровень, 10 ГБ на временный файл и 10 ГБ на всё остальное. А"
" если данных не 1 ГБ, а 1 ТБ? Требовать, чтобы количество свободного "
"места на диске всегда в несколько раз превышало объем полезных данных, "
"экономически нецелесообразно, да и создание файла в 1ТБ может занимать "
"десятки часов. При любой аварии или перезапуске системы операцию придется"
" начинать заново."

#: ../doc/1.10/book/box/engines/vinyl.rst:623
msgid ""
"Here’s another scenario. Suppose the primary key is a monotonically "
"increasing sequence—for example, a time series. In this case, most "
"insertions will fall into the right part of the key range, so it wouldn’t"
" make much sense to do a compaction just to append a few million more "
"records to an already huge run."
msgstr ""
"Рассмотрим другую проблему. Представим, что первичный ключ дерева -- это "
"монотонная последовательность, например, временной ряд. В этом случае "
"основные вставки будут приходиться на правую часть диапазона ключей. Нет "
"смысла заново производить слияние лишь для того, чтобы дописать в конец и"
" без того огромного файла еще несколько миллионов записей."

#: ../doc/1.10/book/box/engines/vinyl.rst:628
msgid ""
"But what if writes predominantly occur in a particular region of the key "
"range, whereas most reads take place in a different region? How do you "
"optimize the form of the LSM tree in this case? If it’s too high, read "
"performance is impacted; if it’s too low—write speed is reduced."
msgstr ""
"А если вставки происходят, в основном, в одну часть диапазона ключей, а "
"чтения -- из другой части? Как в этом случае оптимизировать форму дерева?"
" Если оно будет слишком высоким, пострадают чтения, если слишком низким "
"-- запись."

#: ../doc/1.10/book/box/engines/vinyl.rst:633
msgid ""
"Tarantool \"factorizes\" this problem by creating multiple LSM trees for "
"each index. The approximate size of each subtree may be controlled by the"
" :ref:`vinyl_range_size <cfg_storage-vinyl_range_size>` configuration "
"parameter. We call such subtrees \"ranges\"."
msgstr ""
"Tarantool \"факторизует\" проблему, создавая не одно, а множество "
"LSM-деревьев для каждого индекса. Примерный размер каждого поддерева "
"можно задать в конфигурационном параметре ``vinyl_range_size``. Такие "
"поддеревья называется диапазонами (\"range\")."

#: ../doc/1.10/book/box/engines/vinyl.rst:642
msgid "Factorizing large LSM trees via ranging"
msgstr "Факторизация больших LSM-деревьев с помощью диапазонов"

#: ../doc/1.10/book/box/engines/vinyl.rst:644
msgid "Ranges reflect a static layout of sorted runs"
msgstr "Диапазоны отражают статичную структуру упорядоченных файлов"

#: ../doc/1.10/book/box/engines/vinyl.rst:645
msgid "Slices connect a sorted run into a range"
msgstr "Срезы объединяют упорядоченный файл в диапазон"

#: ../doc/1.10/book/box/engines/vinyl.rst:649
msgid ""
"Initially, when the index has few elements, it consists of a single "
"range. As more elements are added, its total size may exceed :ref:`the "
"maximum range size <cfg_storage-vinyl_range_size>`. In that case a "
"special operation called \"split\" divides the tree into two equal parts."
" The tree is split at the middle element in the range of keys stored in "
"the tree. For example, if  the tree initially stores the full range of "
"-inf…+inf, then after splitting it at the middle key X, we get two "
"subtrees: one that stores the range of -inf...X, and the other storing "
"the range of X…+inf. With this approach, we always know which subtree to "
"use for writes and which one for reads. If the tree contained deletions "
"and each of the neighboring ranges grew smaller as a result, the opposite"
" operation called \"coalesce\" combines two neighboring trees into one."
msgstr ""
"Изначально, пока в индексе мало элементов, он состоит из одного "
"диапазона. По мере добавления элементов суммарный объем может превысить "
":ref:`максимальный размер диапазона <cfg_storage-vinyl_range_size>`. В "
"таком случае выполняется операция под названием \"разделение\" (split), "
"которая делит дерево на две равные части. Разделение происходит по "
"срединному элементу диапазона ключей, хранящихся в дереве. Например, если"
" изначально дерево хранит полный диапазон -inf… +inf, то после разделения"
" по срединному ключу X получим два поддерева: одно будет хранить все "
"ключи от -inf до X, другое -- от X до +inf. Таким образом, при вставке "
"или чтении мы однозначно знаем, к какому поддереву обращаться. Если в "
"дереве были удаления и каждый из соседних диапазонов уменьшился, "
"выполняется обратная операция под названием \"объединение\" (coalesce). "
"Она объединяет два соседних дерева в одно."

#: ../doc/1.10/book/box/engines/vinyl.rst:662
msgid ""
"Split and coalesce don’t entail a compaction, the creation of new runs, "
"or other resource-intensive operations. An LSM tree is just a collection "
"of runs. vinyl has a special metadata log that helps keep track of which "
"run belongs to which subtree(s). This has the `.vylog` extension and its "
"format is compatible with an .xlog file. Similarly to an `.xlog` file, "
"the metadata log gets rotated at each checkpoint. To avoid the creation "
"of extra runs with split and coalesce, we have also introduced an "
"auxiliary entity called \"slice\". It’s a reference to a run containing a"
" key range and it’s stored only in the metadata log. Once the reference "
"counter drops to zero, the corresponding file gets removed. When it’s "
"necessary to perform a split or to coalesce, Tarantool creates slice "
"objects for each new tree, removes older slices, and writes these "
"operations to the metadata log, which literally stores records that look "
"like this: ``<tree id, slice id>`` or ``<slice id, run id, min, max>``."
msgstr ""
"Разделение и объединение не приводят к слиянию, созданию новых файлов и "
"прочим тяжеловесным операциям. LSM-дерево -- это лишь набор файлов. В "
"vinyl'е мы реализовали специальный журнал метаданных, позволяющий легко "
"отслеживать, какой файл принадлежит какому поддереву или поддеревьям. "
"Журнал имеет разрешение `.vylog`, по формату он совместим с файлом "
"`.xlog`. Как и файл `.xlog`, происходит автоматическая ротация файла при "
"каждой контрольной точке. Чтобы избежать повторного создания файлов при "
"разделении и объединении, мы ввели промежуточную сущность -- срез "
"(slice). Это ссылка на файл с указанием диапазона значений ключа, которая"
" хранится исключительно в журнале метаданных. Когда число ссылок на файл "
"становится равным нулю, файл удаляется. А когда необходимо произвести "
"разделение или объединение, Tarantool создает срезы для каждого нового "
"дерева, старые срезы удаляет, и записывает эти операции в журнал "
"метаданных. Буквально, журнал метаданных хранит записи вида "
"<идентификатор дерева, идентификатор среза> или <идентификатор среза, "
"идентификатор файла, мин, макс>."

#: ../doc/1.10/book/box/engines/vinyl.rst:676
msgid ""
"This way all of the heavy lifting associated with splitting a tree into "
"two subtrees is postponed until a compaction and then is performed "
"automatically. A huge advantage of dividing all of the keys into ranges "
"is the ability to independently control the L0 size as well as the dump "
"and compaction processes for each subtree, which makes these processes "
"manageable and predictable. Having a separate metadata log also "
"simplifies the implementation of both \"truncate\" and \"drop\". In "
"vinyl, they’re processed instantly, since they only work with the "
"metadata log, while garbage collection is done in the background."
msgstr ""
"Таким образом, непосредственно тяжелая работа по разбиению дерева на два "
"поддерева, откладывается до слияния и выполняется автоматически.\n"
"Огромным преимуществом подхода с разделением всего диапазона ключей на "
"диапазоны является возможность независимо управлять размером L0, а также "
"процессом создания дампов и слиянием для каждого поддерева. В результате "
"эти процессы являются управляемыми и предсказуемыми. Наличие отдельного "
"журнала метаданных также упрощает выполнение таких операций, как усечение"
" и удаление -- в vinyl'е они обрабатываются мгновенно, потому что "
"работают исключительно с журналом метаданных, а удаление мусора "
"выполняется в фоне."

#: ../doc/1.10/book/box/engines/vinyl.rst:689
msgid "Advanced features of vinyl"
msgstr "Расширенные возможности vinyl'а"

#: ../doc/1.10/book/box/engines/vinyl.rst:695
msgid "Upsert"
msgstr "Upsert (обновление и вставка)"

#: ../doc/1.10/book/box/engines/vinyl.rst:697
msgid ""
"In the previous sections, we mentioned only two operations stored by an "
"LSM tree: deletion and replacement. Let’s take a look at how all of the "
"other operations can be represented. An insertion can be represented via "
"a replacement—you just need to make sure there are no other elements with"
" the specified key. To perform an update, it’s necessary to read the "
"older value from the tree, so it’s easier to represent this operation as "
"a replacement as well—this speeds up future read requests by the key. "
"Besides, an update must return the new value, so there’s no avoiding "
"hidden reads."
msgstr ""
"В предыдущих разделах упоминались лишь две операции, которые хранит "
"LSM-дерево: удаление и замена. Давайте рассмотрим, как представлены все "
"остальные. Вставку можно представить с помощью замены -- необходимо лишь "
"предварительно убедиться в отсутствии элемента указанным ключом. Для "
"выполнения обновления необходимо предварительно считывать старое значение"
" из дерева, так что и эту операцию проще записать в дерево как замену -- "
"это ускорит будущие чтения по этому ключу. Кроме того, обновление должно "
"вернуть новое значение, так что скрытых чтений никак не избежать."

#: ../doc/1.10/book/box/engines/vinyl.rst:706
msgid ""
"In B-trees, the cost of hidden reads is negligible: to update a block, it"
" first needs to be read from disk anyway. Creating a special update "
"operation for an LSM tree that doesn’t cause any hidden reads is really "
"tempting."
msgstr ""
"В B-деревьях скрытые чтения почти ничего не стоят: чтобы обновить блок, "
"его в любом случае необходимо прочитать с диска. Для LSM-деревьев идея "
"создания специальной операции обновления, которая не приводила бы к "
"скрытым чтениям, выглядит очень заманчивой."

#: ../doc/1.10/book/box/engines/vinyl.rst:711
msgid ""
"Such an operation must contain not only a default value to be inserted if"
" a key has no value yet, but also a list of update operations to perform "
"if a value does exist."
msgstr ""
"Такая операция должна содержать как значение по умолчанию, которое нужно "
"вставить, если данных по ключу еще нет, так и список операций обновления,"
" которые нужно выполнить, если значение существует."

#: ../doc/1.10/book/box/engines/vinyl.rst:715
msgid ""
"At transaction execution time, Tarantool just saves the operation in an "
"LSM tree, then \"executes\" it later, during a compaction."
msgstr ""
"На этапе выполнения транзакции Tarantool лишь сохраняет всю операцию в "
"LSM-дереве, а \"выполняет\" ее уже только во время слияния."

#: ../doc/1.10/book/box/engines/vinyl.rst:719
msgid "The upsert operation:"
msgstr "Операция обновления и вставки:"

#: ../doc/1.10/book/box/engines/vinyl.rst:721
msgid "space:upsert(tuple, {{operator, field, value}, ... })"
msgstr "space:upsert(tuple, {{operator, field, value}, ... })"

#: ../doc/1.10/book/box/engines/vinyl.rst:725
msgid "Non-reading update or insert"
msgstr "Обновление без чтения или вставка"

#: ../doc/1.10/book/box/engines/vinyl.rst:726
msgid "Delayed execution"
msgstr "Отложенное выполнение"

#: ../doc/1.10/book/box/engines/vinyl.rst:727
msgid "Background upsert squashing prevents upserts from piling up"
msgstr ""
"Фоновое сжатие операций обновления и вставки предотвращает накапливание "
"операций"

#: ../doc/1.10/book/box/engines/vinyl.rst:729
msgid ""
"Unfortunately, postponing the operation execution until a compaction "
"doesn’t leave much leeway in terms of error handling. That’s why "
"Tarantool tries to validate upserts as fully as possible before writing "
"them to an LSM tree. However, some checks are only possible with older "
"data on hand, for example when the update operation is trying to add a "
"number to a string or to remove a field that doesn’t exist."
msgstr ""
"К сожалению, если откладывать выполнение операции на этап слияния, "
"возможностей для обработки ошибок не остается. Поэтому Tarantool "
"стремится максимально проверять операции обновления и вставки upsert "
"перед записью в дерево. Тем не менее, некоторые проверки можно выполнить "
"лишь имея старые данные на руках. Например, если обновление прибавляет "
"число к строке или удаляет несуществующее поле."

#: ../doc/1.10/book/box/engines/vinyl.rst:736
msgid ""
"A semantically similar operation exists in many products including "
"PostgreSQL and MongoDB. But anywhere you look, it’s just syntactic sugar "
"that combines the update and replace operations without avoiding hidden "
"reads. Most probably, the reason is that LSM trees as data storage "
"structures are relatively new."
msgstr ""
"Операция с похожей семантикой присутствует во многих продуктах, в том "
"числе в PostgreSQL и MongoDB. Но везде она представляет собой лишь "
"синтаксический сахар, объединяющий обновление и вставку, не избавляя СУБД"
" от необходимости выполнять скрытые чтения. Скорее всего, причиной этого "
"является относительная новизна LSM-деревьев в качестве структур данных "
"для хранения."

#: ../doc/1.10/book/box/engines/vinyl.rst:742
msgid ""
"Even though an upsert is a very important optimization and implementing "
"it cost us a lot of blood, sweat, and tears, we must admit that it has "
"limited applicability. If a table contains secondary keys or triggers, "
"hidden reads can’t be avoided. But if you have a scenario where secondary"
" keys are not required and the update following the transaction "
"completion will certainly not cause any errors, then the operation is for"
" you."
msgstr ""
"Хотя обновление и вставка upsert представляет собой очень важную "
"оптимизацию, и ее реализация стоила нам долгой напряженной работы, "
"следует признать, что ее применимость ограничена. Если в таблице есть "
"вторичные ключи или триггеры, скрытых чтений не избежать. А если у вас "
"есть сценарии, для которых не нужны вторичные ключи и обновление после "
"завершения транзакции однозначно не приведет к ошибкам -- эта операция "
"для вас."

#: ../doc/1.10/book/box/engines/vinyl.rst:749
msgid ""
"I’d like to tell you a short story about an upsert. It takes place back "
"when vinyl was only beginning to \"mature\" and we were using an upsert "
"in production for the first time. We had what seemed like an ideal "
"environment for it: we had tons of keys, the current time was being used "
"as values; update operations were inserting keys or modifying the current"
" time; and we had few reads. Load tests yielded great results."
msgstr ""
"Небольшая история, связанная с этим оператором: vinyl только начинал "
"\"взрослеть\", и мы впервые запустили операцию обновления и вставки "
"upsert на рабочие серверы. Казалось бы, идеальные условия: огромный набор"
" ключей, текущее время в качестве значения, операции обновления либо "
"вставляют ключ, либо обновляют текущее время, редкие операции чтения. "
"Нагрузочные тесты показали отличные результаты."

#: ../doc/1.10/book/box/engines/vinyl.rst:757
#, python-format
msgid ""
"Nevertheless, after a couple of days, the Tarantool process started "
"eating up 100% of our CPU, and the system performance dropped close to "
"zero."
msgstr ""
"Тем не менее, после пары дней работы процесс Tarantool'а начал потреблять"
" 100 % CPU, а производительность системы упала практически до нуля."

#: ../doc/1.10/book/box/engines/vinyl.rst:760
msgid ""
"We started digging into the issue and found out that the distribution of "
"requests across keys was significantly different from what we had seen in"
" the test environment. It was...well, quite nonuniform. Most keys were "
"updated once or twice a day, so the database was idle for the most part, "
"but there were much hotter keys with tens of thousands of updates per "
"day. Tarantool handled those just fine. But in the case of lookups by key"
" with tens of thousands of upserts, things quickly went downhill. To "
"return the most recent value, Tarantool had to read and \"replay\" the "
"whole history consisting of all of the upserts. When designing upserts, "
"we had hoped this would happen automatically during a compaction, but the"
" process never even got to that stage: the L0 size was more than enough, "
"so there were no dumps."
msgstr ""
"Начали подробно изучать проблему. Оказалось, что распределение запросов "
"по ключам существенно отличалось от того, что мы видели в тестовом "
"окружении. Оно было… очень неравномерное. Большая часть ключей "
"обновлялась 1-2 раза за сутки, и база для них не была нагружена. Но были "
"ключи гораздо более горячие -- десятки тысяч обновлений в сутки. "
"Tarantool прекрасно справлялся с этим потоком обновлений. А вот когда по "
"ключу с десятком тысяч операций обновления и вставки upsert происходило "
"чтение, всё шло под откос. Чтобы вернуть последнее значение, Tarantool'у "
"приходилось каждый раз прочитать и \"проиграть\" историю из десятков "
"тысяч команд обновления и вставки upsert. На стадии проекта мы надеялись,"
" что это произойдет автоматически во время слияния уровней, но до слияния"
" дело даже не доходило: памяти L0 было предостаточно, и дампы не "
"создавались."

#: ../doc/1.10/book/box/engines/vinyl.rst:773
msgid ""
"We solved the problem by adding a background process that performed "
"readaheads on any keys that had more than a few dozen upserts piled up, "
"so all those upserts were squashed and substituted with the read value."
msgstr ""
"Решили мы проблему добавлением фонового процесса, осуществляющего "
"упреждающие чтения для ключей, по которым накопилось больше нескольких "
"десятков операций обновления и вставки upsert с последующей заменой на "
"прочитанное значение."

#: ../doc/1.10/book/box/engines/vinyl.rst:782
msgid "Secondary keys"
msgstr "Вторичные ключи"

#: ../doc/1.10/book/box/engines/vinyl.rst:784
msgid ""
"Update is not the only operation where optimizing hidden reads is "
"critical. Even the replace operation, given secondary keys, has to read "
"the older value: it needs to be independently deleted from the secondary "
"indexes, and inserting a new element might not do this, leaving some "
"garbage behind."
msgstr ""
"Не только для операции обновления остро стоит проблема оптимизации "
"скрытых чтений. Даже операция замены при наличии вторичных ключей "
"вынуждена читать старое значение: его нужно независимо удалить из "
"вторичных индексов, а вставка нового элемента может этого не сделать, "
"оставив в индексе мусор."

#: ../doc/1.10/book/box/engines/vinyl.rst:794
#, python-format
msgid ""
"If secondary indexes are not unique, then collecting \"garbage\" from "
"them can be put off until a compaction, which is what we do in Tarantool."
" The append-only nature of LSM trees allowed us to implement full-blown "
"serializable transactions in vinyl. Read-only requests use older versions"
" of data without blocking any writes. The transaction manager itself is "
"fairly simple for now: in classical terms, it implements the MVTO "
"(multiversion timestamp ordering) class, whereby the winning transaction "
"is the one that finished earlier. There are no locks and associated "
"deadlocks. Strange as it may seem, this is a drawback rather than an "
"advantage: with parallel execution, you can increase the number of "
"successful transactions by simply holding some of them on lock when "
"necessary. We’re planning to improve the transaction manager soon. In the"
" current release, we focused on making the algorithm behave 100% "
"correctly and predictably. For example, our transaction manager is one of"
" the few on the NoSQL market that supports so-called \"gap locks\"."
msgstr ""
"Если вторичные индексы не уникальны, то удаление из них \"мусора\" также "
"можно перенести в фазу слияния, что мы и делаем в Tarantool'е. Природа "
"LSM-дерева, в котором файлы обновляются путем присоединения новых "
"записей, позволила нам реализовать в vinyl'е полноценные сериализуемые "
"транзакции. Запросы только для чтения при этом используют старые версии "
"данных и не блокируют запись. Сам менеджер транзакций пока довольно "
"простой: в традиционной классификации он реализует класс MVTO "
"(multiversion timestamp ordering -- упорядочение временных меток на "
"основе многоверсионности), при этом в конфликте побеждает та транзакция, "
"что завершилась первой. Блокировок и свойственных им взаимоблокировок "
"нет. Как ни странно, это скорее недостаток, чем преимущество: при "
"параллельном выполнении можно повысить количество успешных транзакций, "
"задерживая некоторые из них в нужный момент на блокировке. Развитие "
"менеджера транзакций в наших ближайших планах. В текущей версии мы "
"сфокусировались на том, чтобы сделать алгоритм корректным и предсказуемым"
" на 100%. Например, наш менеджер транзакций -- один из немногих в "
"NoSQL-среде, поддерживающих так называемые \"блокировки разрывов\" (gap "
"locks)."

#: ../doc/1.10/book/box/index.rst:39
msgid "Database"
msgstr "Функциональность СУБД"

#: ../doc/1.10/book/box/index.rst:41
msgid ""
"In this chapter, we introduce the basic concepts of working with "
"Tarantool as a database manager."
msgstr ""
"В данной главе мы рассмотрим основные понятия при работе с Tarantool'ом в"
" качестве системы управления базой данных."

#: ../doc/1.10/book/box/limitations.rst:39
msgid "Limitations"
msgstr "Ограничения"

#: ../doc/1.10/book/box/limitations.rst:41
msgid "**Number of parts in an index**"
msgstr "**Количество частей в индексе**"

#: ../doc/1.10/book/box/limitations.rst:43
msgid ""
"For TREE or HASH indexes, the maximum is 255 "
"(``box.schema.INDEX_PART_MAX``). For :ref:`RTREE <box_index-rtree>` "
"indexes, the maximum is 1 but the field is an ARRAY of up to 20 "
"dimensions. For BITSET indexes, the maximum is 1."
msgstr ""
"Для TREE-индексов или HASH-индексов максимальное количество -- 255 частей"
" (``box.schema.INDEX_PART_MAX``). Для :ref:`RTREE-индексов <box_index-"
"rtree>` максимальное количество -- 1, но это поля типа ARRAY (массив) с "
"размерностью до 20. Для BITSET-индексов максимальное количество -- 1."

#: ../doc/1.10/book/box/limitations.rst:50
msgid "**Number of indexes in a space**"
msgstr "**Количество индексов в спейсе**"

#: ../doc/1.10/book/box/limitations.rst:52
msgid "128 (``box.schema.INDEX_MAX``)."
msgstr "128 (``box.schema.INDEX_MAX``)."

#: ../doc/1.10/book/box/limitations.rst:56
msgid "**Number of fields in a tuple**"
msgstr "**Количество полей в кортеже**"

#: ../doc/1.10/book/box/limitations.rst:58
msgid ""
"The theoretical maximum is 2,147,483,647 (``box.schema.FIELD_MAX``). The "
"practical maximum is whatever is specified by the space's "
":ref:`field_count <box_space-field_count>` member, or the maximal tuple "
"length."
msgstr ""
"Теоретически максимальное количество составляет 2 147 483 647 полей "
"(``box.schema.FIELD_MAX``). Практически максимальное количество указано в"
" поле :ref:`field_count <box_space-field_count>` спейса или соответствует"
" максимальной длине кортежа."

#: ../doc/1.10/book/box/limitations.rst:65
msgid "**Number of bytes in a tuple**"
msgstr "**Количество байтов в кортеже**"

#: ../doc/1.10/book/box/limitations.rst:67
msgid ""
"The maximal number of bytes in a tuple is roughly equal to "
":ref:`memtx_max_tuple_size <cfg_storage-memtx_max_tuple_size>` or "
":ref:`vinyl_max_tuple_size <cfg_storage-vinyl_max_tuple_size>` (with a "
"metadata overhead of about 20 bytes per tuple, which is added on top of "
"useful bytes). By default, the value of either ``memtx_max_tuple_size`` "
"or ``vinyl_max_tuple_size`` is 1,048,576. To increase it, specify a "
"larger value when starting the Tarantool instance. For example, "
"``box.cfg{memtx_max_tuple_size=2*1048576}``."
msgstr ""
"Максимальное количество байтов в кортеже примерно равно "
":ref:`memtx_max_tuple_size <cfg_storage-memtx_max_tuple_size>` или "
":ref:`vinyl_max_tuple_size <cfg_storage-vinyl_max_tuple_size>` (с "
"ресурсами метаданных около 20 байтов на кортеж, которые добавляются к "
"полезным байтам). Значение ``memtx_max_tuple_size`` или "
"``vinyl_max_tuple_size`` по умолчанию составляет 1 048 576. Чтобы его "
"увеличить, укажите большее значение при запуске экземпляра Tarantool'а. "
"Например, ``box.cfg{memtx_max_tuple_size=2*1048576}``."

#: ../doc/1.10/book/box/limitations.rst:79
msgid "**Number of bytes in an index key**"
msgstr "**Количество байтов в индекс-ключе**"

#: ../doc/1.10/book/box/limitations.rst:81
msgid ""
"If a field in a tuple can contain a million bytes, then the index key can"
" contain a million bytes, so the maximum is determined by factors such as"
" :ref:`Number of bytes in a tuple <limitations_bytes_in_tuple>`, not by "
"the index support."
msgstr ""
"Если поле в кортеже может содержать миллион байтов, то индекс-ключ может "
"содержать миллион байтов, поэтому максимальное количество определяется "
"такими факторами, как :ref:`количество байтов в кортеже "
"<limitations_bytes_in_tuple>`, а не параметрами индекса."

#: ../doc/1.10/book/box/limitations.rst:88
msgid "**Number of spaces**"
msgstr "**Количество спейсов**"

#: ../doc/1.10/book/box/limitations.rst:90
msgid ""
"The theoretical maximum is 2147483647 (``box.schema.SPACE_MAX``) but the "
"practical maximum is around 65,000."
msgstr ""
"Теоретически максимальное количество составляет 2 147 483 647 "
"(``box.schema.SPACE_MAX``), но практически максимальное количество -- "
"около 65 000."

#: ../doc/1.10/book/box/limitations.rst:95
msgid "**Number of connections**"
msgstr "**Количество соединений**"

#: ../doc/1.10/book/box/limitations.rst:97
msgid ""
"The practical limit is the number of file descriptors that one can set "
"with the operating system."
msgstr ""
"Практически пределом является количество файловых дескрипторов, которые "
"можно определить с операционной системой."

#: ../doc/1.10/book/box/limitations.rst:102
msgid "**Space size**"
msgstr "**Размер спейса**"

#: ../doc/1.10/book/box/limitations.rst:104
msgid ""
"The total maximum size for all spaces is in effect set by "
":ref:`memtx_memory <cfg_storage-memtx_memory>`, which in turn is limited "
"by the total available memory."
msgstr ""
"Итоговый максимальный размер всех спейсов фактически определяется в "
":ref:`memtx_memory <cfg_storage-memtx_memory>`, который в свою очередь "
"ограничен общим размером свободной памяти."

#: ../doc/1.10/book/box/limitations.rst:110
msgid "**Update operations count**"
msgstr "**Число операций обновления**"

#: ../doc/1.10/book/box/limitations.rst:112
msgid ""
"The maximum number of operations that can be in a single update is 4000 "
"(``BOX_UPDATE_OP_CNT_MAX``)."
msgstr ""
"Максимальное количество операций, возможное в рамках одного обновления, "
"составляет 4000 (``BOX_UPDATE_OP_CNT_MAX``)."

#: ../doc/1.10/book/box/limitations.rst:117
msgid "**Number of users and roles**"
msgstr "**Количество пользователей и ролей**"

#: ../doc/1.10/book/box/limitations.rst:119
msgid "32 (``BOX_USER_MAX``)."
msgstr "32 (``BOX_USER_MAX``)."

#: ../doc/1.10/book/box/limitations.rst:123
msgid "**Length of an index name or space name or user name**"
msgstr "**Длина имени индекса, имени спейса или имени пользователя**"

#: ../doc/1.10/book/box/limitations.rst:125
msgid "65000 (``box.schema.NAME_MAX``)."
msgstr "65000 (``box.schema.NAME_MAX``)."

#: ../doc/1.10/book/box/limitations.rst:129
msgid "**Number of replicas in a replica set**"
msgstr "**Количество реплик в наборе реплик**"

#: ../doc/1.10/book/box/limitations.rst:131
msgid "32 (``vclock.VCLOCK_MAX``)."
msgstr "32 (``vclock.VCLOCK_MAX``)."

#: ../doc/1.10/book/box/triggers.rst:40
msgid "Triggers"
msgstr "Триггеры"

#: ../doc/1.10/book/box/triggers.rst:42
msgid ""
"**Triggers**, also known as **callbacks**, are functions which the server"
" executes when certain events happen."
msgstr ""
"**Триггеры**, которые также называют **обратными вызовами**, представляют"
" собой функции, которые выполняет сервер при наступлении определенных "
"событий."

#: ../doc/1.10/book/box/triggers.rst:45
msgid "There are four types of triggers in Tarantool:"
msgstr "В Tarantool'е есть четыре типа триггеров:"

#: ../doc/1.10/book/box/triggers.rst:47
msgid ""
":ref:`connection triggers <box_session-on_connect>`, which are executed "
"when a session begins or ends,"
msgstr ""
":ref:`триггеры для обработки соединений <box_session-on_connect>`, "
"которые выполняются, когда начинается или заканчивается сессия,"

#: ../doc/1.10/book/box/triggers.rst:50
msgid ""
":ref:`authentication triggers <box_session-on_auth>`, which are executed "
"during authentication,"
msgstr ""
":ref:`триггеры для обработки аутентификации <box_session-on_auth>`, "
"которые выполняются при аутентификации,"

#: ../doc/1.10/book/box/triggers.rst:53
msgid ""
":ref:`replace triggers <box_space-on_replace>`, which are for database "
"events, and"
msgstr ""
":ref:`триггеры для обработки замены <box_space-on_replace>`, которые "
"предназначены для событий в базе данных, и"

#: ../doc/1.10/book/box/triggers.rst:56
msgid ""
":ref:`transaction triggers <box-on_commit>`, which are executed during "
"commit or rollback."
msgstr ""
":ref:`триггеры для обработки транзакций <box-on_commit>`, которые "
"выполняются во время коммита или отката."

#: ../doc/1.10/book/box/triggers.rst:59
msgid "All triggers have the following characteristics:"
msgstr "У всех триггеров есть следующие особенности:"

#: ../doc/1.10/book/box/triggers.rst:61
msgid ""
"Triggers associate a function with an event. The request to \"define a "
"trigger\" implies passing the trigger’s function to one of the "
"\"on_event()\" functions:"
msgstr ""
"Триггеры связывают функцию с событием. Запрос \"определить триггер\" "
"подразумевает передачу функции с триггером в одну из функций обработки "
"событий \"on_event()\":"

#: ../doc/1.10/book/box/triggers.rst:65
msgid ":ref:`box.session.on_connect() <box_session-on_connect>`,"
msgstr ":ref:`box.session.on_connect() <box_session-on_connect>`,"

#: ../doc/1.10/book/box/triggers.rst:66
msgid ":ref:`box.session.on_auth() <box_session-on_auth>`,"
msgstr ":ref:`box.session.on_auth() <box_session-on_auth>`,"

#: ../doc/1.10/book/box/triggers.rst:67
msgid ":ref:`box.session.on_disconnect() <box_session-on_disconnect>`, or"
msgstr ":ref:`box.session.on_disconnect() <box_session-on_disconnect>`, or"

#: ../doc/1.10/book/box/triggers.rst:68
msgid ""
":ref:`space_object:on_replace() <box_space-on_replace>` plus "
":ref:`space_object:before_replace() <box_space-before_replace>` plus "
":ref:`box.on_commit() <box-on_commit>` and :ref:`box.on_rollback() <box-"
"on_rollback>`."
msgstr ""
":ref:`space_object:on_replace() <box_space-on_replace>` (после замены), "
":ref:`space_object:before_replace() <box_space-before_replace>` (перед "
"заменой),  :ref:`box.on_commit() <box-on_commit>` (при коммите) и "
":ref:`box.on_rollback() <box-on_rollback>` (при откате)."

#: ../doc/1.10/book/box/triggers.rst:72
msgid ""
"Triggers are defined only by the :ref:`'admin' user <authentication-"
"owners_privileges>`."
msgstr ""
"Только :ref:`пользователь 'admin' <authentication-owners_privileges>` "
"определяет триггеры."

#: ../doc/1.10/book/box/triggers.rst:74
msgid ""
"Triggers are stored in the Tarantool instance's memory, not in the "
"database. Therefore triggers disappear when the instance is shut down. To"
" make them permanent, put function definitions and trigger settings into "
"Tarantool's :ref:`initialization script <index-init_label>`."
msgstr ""
"Триггеры хранятся в памяти экземпляра Tarantool'а, а не в базе данных. "
"Поэтому триггеры пропадают, когда экземпляр отключают. Чтобы сохранить "
"их, поместите определения функции и настройки триггера в :ref:`скрипт "
"инициализации <index-init_label>` Tarantool'а."

#: ../doc/1.10/book/box/triggers.rst:79
msgid ""
"Triggers have low overhead. If a trigger is not defined, then the "
"overhead is minimal: merely a pointer dereference and check. If a trigger"
" is defined, then its overhead is equivalent to the overhead of calling a"
" function."
msgstr ""
"Триггеры не приводят к высокой затрате ресурсов. Если триггер не "
"определен, то затрата ресурсов минимальна: только разыменование указателя"
" и проверка. Если триггер определен, то затрата ресурсов аналогична "
"вызову функции."

#: ../doc/1.10/book/box/triggers.rst:83
msgid ""
"There can be multiple triggers for one event. In this case, triggers are "
"executed in the reverse order that they were defined in."
msgstr ""
"Для одного события можно определить несколько триггеров. В таком случае "
"триггеры выполняются в обратном порядке относительно того, как их "
"определили."

#: ../doc/1.10/book/box/triggers.rst:86
msgid ""
"Triggers must work within the event context. However, effects are "
"undefined if a function contains requests which normally could not occur "
"immediately after the event, but only before the return from the event. "
"For example, putting `os.exit() "
"<http://www.lua.org/manual/5.1/manual.html#pdf-os.exit>`_ or "
":ref:`box.rollback() <box-rollback>` in a trigger function would be "
"bringing in requests outside the event context."
msgstr ""
"Триггеры должны работать в контексте события. Однако результат не "
"определен, если функция содержит запросы, которые при нормальных условиях"
" не могут быть выполнены непосредственно после события, а только после "
"возврата из события. Например, если указать `os.exit() "
"<http://www.lua.org/manual/5.1/manual.html#pdf-os.exit>`_ или "
":ref:`box.rollback() <box-rollback>` в триггерной функции, запросы не "
"будут выполняться в контексте события."

#: ../doc/1.10/book/box/triggers.rst:93
msgid ""
"Triggers are replaceable. The request to \"redefine a trigger\" implies "
"passing a new trigger function and an old trigger function to one of the "
"\"on_event()\" functions."
msgstr ""
"Триггеры можно заменять. Запрос на \"замену триггера\" подразумевает "
"передачу новой триггерной функции и старой триггерной функции в одну из "
"функций обработки событий \"on_event()\"."

#: ../doc/1.10/book/box/triggers.rst:97
msgid ""
"The \"on_event()\" functions all have parameters which are function "
"pointers, and they all return function pointers. Remember that a Lua "
"function definition such as \"function f() x = x + 1 end\" is the same as"
" \"f = function () x = x + 1 end\" -- in both cases ``f`` gets a function"
" pointer. And \"trigger = box.session.on_connect(f)\" is the same as "
"\"trigger = box.session.on_connect(function () x = x + 1 end)\" -- in "
"both cases ``trigger`` gets the function pointer which was passed."
msgstr ""
"Во всех функциях обработки событий \"on_event()\" есть параметры, которые"
" представляют собой указатели функции, и все они возвращают указатели "
"функции. Следует запомнить, что определение Lua-функции, например, "
"\"function f() x = x + 1 end\" совпадает с \"f = function () x = x + 1 "
"end\" -- в обоих случаях ``f`` получит указатель функции. А \"trigger = "
"box.session.on_connect(f)\" -- это то же самое, что \"trigger = "
"box.session.on_connect(function () x = x + 1 end)\" -- в обоих случаях "
"``trigger`` получит переданный указатель функции."

#: ../doc/1.10/book/box/triggers.rst:105
msgid "To get a list of triggers, you can use:"
msgstr "Чтобы получить список триггеров, можно использовать следующее:"

#: ../doc/1.10/book/box/triggers.rst:107
msgid ""
"on_connect() – with no arguments – to return a table of all connect-"
"trigger functions;"
msgstr ""
"on_connect() – без аргументов – чтобы вернуть таблицу со всеми "
"триггерными функциями для обработки соединений;"

#: ../doc/1.10/book/box/triggers.rst:108
msgid "on_auth() to return all authentication-trigger functions;"
msgstr ""
"on_auth(), чтобы вернуть все триггерные функции для обработки "
"аутентификации;"

#: ../doc/1.10/book/box/triggers.rst:109
msgid "on_disconnect() to return all disconnect-trigger functions;"
msgstr ""
"on_disconnect(), чтобы вернуть все триггерные функции для обработки "
"отключений;"

#: ../doc/1.10/book/box/triggers.rst:110
msgid ""
"on_replace() to return all replace-trigger functions made for "
"on_replace();"
msgstr ""
"on_replace(), чтобы вернуть все триггерные функции для обработки замены, "
"сделанные для on_replace();"

#: ../doc/1.10/book/box/triggers.rst:111
msgid ""
"before_replace() to return all replace-trigger functions made for "
"before_replace()."
msgstr ""
"before_replace(), чтобы вернуть все триггерные функции для обработки "
"замены, сделанные для before_replace()."

#: ../doc/1.10/book/box/triggers.rst:115
msgid "Here we log connect and disconnect events into Tarantool server log."
msgstr ""
"Здесь мы записываем события подключения и отключения в журнал на сервере "
"Tarantool'а."

#: ../doc/1.10/book/box/triggers.rst:117
msgid ""
"log = require('log')\n"
"\n"
"function on_connect_impl()\n"
"  log.info(\"connected \"..box.session.peer()..\", sid "
"\"..box.session.id())\n"
"end\n"
"\n"
"function on_disconnect_impl()\n"
"  log.info(\"disconnected, sid \"..box.session.id())\n"
"end\n"
"\n"
"function on_auth_impl(user)\n"
"  log.info(\"authenticated sid \"..box.session.id()..\" as \"..user)\n"
"end\n"
"\n"
"function on_connect() pcall(on_connect_impl) end\n"
"function on_disconnect() pcall(on_disconnect_impl) end\n"
"function on_auth(user) pcall(on_auth_impl, user) end\n"
"\n"
"box.session.on_connect(on_connect)\n"
"box.session.on_disconnect(on_disconnect)\n"
"box.session.on_auth(on_auth)"
msgstr ""
"log = require('log')\n"
"\n"
"function on_connect_impl()\n"
"  log.info(\"connected \"..box.session.peer()..\", sid "
"\"..box.session.id())\n"
"end\n"
"\n"
"function on_disconnect_impl()\n"
"  log.info(\"disconnected, sid \"..box.session.id())\n"
"end\n"
"\n"
"function on_auth_impl(user)\n"
"  log.info(\"authenticated sid \"..box.session.id()..\" as \"..user)\n"
"end\n"
"\n"
"function on_connect() pcall(on_connect_impl) end\n"
"function on_disconnect() pcall(on_disconnect_impl) end\n"
"function on_auth(user) pcall(on_auth_impl, user) end\n"
"\n"
"box.session.on_connect(on_connect)\n"
"box.session.on_disconnect(on_disconnect)\n"
"box.session.on_auth(on_auth)"

#: ../doc/1.10/book/connectors/index.rst:39
msgid "Connectors"
msgstr "Коннекторы"

#: ../doc/1.10/book/connectors/index.rst:41
msgid "This chapter documents APIs for various programming languages."
msgstr "В этой главе описаны API для различных языков программирования."

#: ../doc/1.10/book/connectors/index.rst:45
msgid "Protocol"
msgstr "Протокол"

#: ../doc/1.10/book/connectors/index.rst:47
msgid ""
"Tarantool's binary protocol was designed with a focus on asynchronous I/O"
" and easy integration with proxies. Each client request starts with a "
"variable-length binary header, containing request id, request type, "
"instance id, log sequence number, and so on."
msgstr ""
"Бинарный протокол для передачи данных в Tarantool'е был разработан с "
"учетом потребностей асинхронного ввода-вывода для облегчения интеграции с"
" прокси-серверами. Каждый клиентский запрос начинается с бинарного "
"заголовка переменной длины. В заголовке указывается идентификатор и тип "
"запроса, идентификатор экземпляра, номер записи в журнале и т.д."

#: ../doc/1.10/book/connectors/index.rst:52
msgid ""
"The mandatory length, present in request header simplifies client or "
"proxy I/O. A response to a request is sent to the client as soon as it is"
" ready. It always carries in its header the same type and id as in the "
"request. The id makes it possible to match a request to a response, even "
"if the latter arrived out of order."
msgstr ""
"Также в заголовке обязательно указывается длина запроса, что облегчает "
"обработку данных. Ответ на запрос посылается по мере готовности. В "
"заголовке ответа указывается тот же идентификатор и тип запроса, что и в "
"изначальном запросе. По идентификатору можно легко соотнести запрос с "
"ответом, даже если ответ был получен не в порядке отсылки запросов."

#: ../doc/1.10/book/connectors/index.rst:58
msgid ""
"Unless implementing a client driver, you needn't concern yourself with "
"the complications of the binary protocol. Language-specific drivers "
"provide a friendly way to store domain language data structures in "
"Tarantool. A complete description of the binary protocol is maintained in"
" annotated Backus-Naur form in the source tree: please see the page about"
" :ref:`Tarantool's binary protocol <box_protocol-iproto_protocol>`."
msgstr ""
"Вдаваться в тонкости реализации Tarantool-протокола нужно только при "
"разработке нового коннектора для Tarantool'а -- см. :ref:`полное описание"
" бинарного протокола в Tarantool'е <box_protocol-iproto_protocol>` в виде"
" аннотированных BNF-диаграмм (Backus-Naur Form). В остальных случаях "
"достаточно взять уже существующий коннектор для нужного вам языка "
"программирования. Такие коннекторы позволяют легко хранить структуры "
"данных из разных языков в формате Tarantool'а."

#: ../doc/1.10/book/connectors/index.rst:67
msgid "Packet example"
msgstr "Пример пакета данных"

#: ../doc/1.10/book/connectors/index.rst:69
msgid ""
"The Tarantool API exists so that a client program can send a request "
"packet to a server instance, and receive a response. Here is an example "
"of a what the client would send for ``box.space[513]:insert{'A', 'BB'}``."
" The BNF description of the components is on the page about "
":ref:`Tarantool's binary protocol <box_protocol-iproto_protocol>`."
msgstr ""
"С помощью API Tarantool'а клиентские программы могут отправлять пакеты с "
"запросами в адрес экземпляра и получать на них ответы. Вот пример для "
"запроса :code:`box.space[513]:insert{'A', 'BB'}`. Описания компонентов "
"запроса (в виде BNF-диаграмм) вы найдете на странице о :ref:`бинарном "
"протоколе в Tarantool'е <box_protocol-iproto_protocol>`."

#: ../doc/1.10/book/connectors/index.rst:85
msgid "Component"
msgstr "Компонент"

#: ../doc/1.10/book/connectors/index.rst:85
msgid "Byte #0"
msgstr "Байт #0"

#: ../doc/1.10/book/connectors/index.rst:85
msgid "Byte #1"
msgstr "Байт #1"

#: ../doc/1.10/book/connectors/index.rst:85
msgid "Byte #2"
msgstr "Байт #2"

#: ../doc/1.10/book/connectors/index.rst:85
msgid "Byte #3"
msgstr "Байт #3"

#: ../doc/1.10/book/connectors/index.rst:87
msgid "code for insert"
msgstr "код для вставки"

#: ../doc/1.10/book/connectors/index.rst:87
#: ../doc/1.10/book/connectors/index.rst:91
msgid "02"
msgstr "02"

#: ../doc/1.10/book/connectors/index.rst:89
msgid "rest of header"
msgstr "остаток заголовка"

#: ../doc/1.10/book/connectors/index.rst:89
msgid "..."
msgstr "..."

#: ../doc/1.10/book/connectors/index.rst:91
msgid "2-digit number: space id"
msgstr "число из 2 цифр: ID спейса"

#: ../doc/1.10/book/connectors/index.rst:91
msgid "cd"
msgstr "cd"

#: ../doc/1.10/book/connectors/index.rst:91
msgid "01"
msgstr "01"

#: ../doc/1.10/book/connectors/index.rst:93
msgid "code for tuple"
msgstr "код для кортежа"

#: ../doc/1.10/book/connectors/index.rst:93
msgid "21"
msgstr "21"

#: ../doc/1.10/book/connectors/index.rst:95
msgid "1-digit number: field count = 2"
msgstr "число из 1 цифры: количество полей = 2"

#: ../doc/1.10/book/connectors/index.rst:95
msgid "92"
msgstr "92"

#: ../doc/1.10/book/connectors/index.rst:97
msgid "1-character string: field[1]"
msgstr "строка из 1 символа: поле[1]"

#: ../doc/1.10/book/connectors/index.rst:97
msgid "a1"
msgstr "a1"

#: ../doc/1.10/book/connectors/index.rst:97
msgid "41"
msgstr "41"

#: ../doc/1.10/book/connectors/index.rst:99
msgid "2-character string: field[2]"
msgstr "строка из 2 символов: поле[2]"

#: ../doc/1.10/book/connectors/index.rst:99
msgid "a2"
msgstr "a2"

#: ../doc/1.10/book/connectors/index.rst:99
msgid "42"
msgstr "42"

#: ../doc/1.10/book/connectors/index.rst:102
msgid ""
"Now, you could send that packet to the Tarantool instance, and interpret "
"the response (the page about :ref:`Tarantool's binary protocol "
"<box_protocol-iproto_protocol>` has a description of the packet format "
"for responses as well as requests). But it would be easier, and less "
"error-prone, if you could invoke a routine that formats the packet "
"according to typed parameters. Something like ``response = "
"tarantool_routine(\"insert\", 513, \"A\", \"B\");``. And that is why APIs"
" exist for drivers for Perl, Python, PHP, and so on."
msgstr ""
"Теперь получившийся пакет можно послать в адрес экземпляра Tarantool'а и "
"затем расшифровать ответ (описания формата пакета ответов и вопросов вы "
"найдете на той же странице о :ref:`бинарном протоколе в Tarantool'е "
"<box_protocol-iproto_protocol>`). Но более простым и верным способом "
"будет вызвать процедуру, которая сформирует готовый пакет с заданными "
"параметрами. Что-то вроде ``response = tarantool_routine(\"insert\", 513,"
" \"A\", \"B\");``. Для этого и существуют API для драйверов для Perl, "
"Python, PHP и т.д."

#: ../doc/1.10/book/connectors/index.rst:115
msgid "Setting up the server for connector examples"
msgstr "Настройка окружения для примеров работы с коннекторами"

#: ../doc/1.10/book/connectors/index.rst:117
msgid ""
"This chapter has examples that show how to connect to a Tarantool "
"instance via the Perl, PHP, Python, node.js, and C connectors. The "
"examples contain hard code that will work if and only if the following "
"conditions are met:"
msgstr ""
"В этой главе приводятся примеры того, как можно установить соединение с "
"Tarantool-сервером с помощью коннекторов для языков Perl, PHP, Python, "
"node.js и C. Обратите внимание, что в примерах указаны фиксированные "
"значения, поэтому для корректной работы всех примеров нужно соблюсти "
"следующие условия:"

#: ../doc/1.10/book/connectors/index.rst:121
msgid ""
"the Tarantool instance (tarantool) is running on localhost (127.0.0.1) "
"and is listening on port 3301 (``box.cfg.listen = '3301'``),"
msgstr ""
"экземпляр (Tarantool) запущен на локальной машине (``localhost = "
"127.0.0.1``),  а прослушивание для него настроено на порту 3301 "
"(``box.cfg.listen = '3301'``),"

#: ../doc/1.10/book/connectors/index.rst:124
msgid ""
"space ``examples`` has id = 999 (``box.space.examples.id = 999``) and has"
" a primary-key index for a numeric field "
"(``box.space[999].index[0].parts[1].type = \"unsigned\"``),"
msgstr ""
"в базе есть спейс``examples`` с идентификатором 999 "
"(``box.space.examples.id = 999``), и у него есть первичный индекс, "
"построенный по ключу числового типа "
"(``box.space[999].index[0].parts[1].type = \"unsigned\"``),"

#: ../doc/1.10/book/connectors/index.rst:128
msgid "user 'guest' has privileges for reading and writing."
msgstr "для пользователя 'guest' настроены права на чтение и запись."

#: ../doc/1.10/book/connectors/index.rst:130
msgid ""
"It is easy to meet all the conditions by starting the instance and "
"executing this script:"
msgstr ""
"Можно легко соблюсти все условия, запустив экземпляр и выполнив следующий"
" скрипт:"

#: ../doc/1.10/book/connectors/index.rst:133
msgid ""
"box.cfg{listen=3301}\n"
"box.schema.space.create('examples',{id=999})\n"
"box.space.examples:create_index('primary', {type = 'hash', parts = {1, "
"'unsigned'}})\n"
"box.schema.user.grant('guest','read,write','space','examples')\n"
"box.schema.user.grant('guest','read','space','_space')"
msgstr ""
"box.cfg{listen=3301}\n"
"box.schema.space.create('examples',{id=999})\n"
"box.space.examples:create_index('primary', {type = 'hash', parts = {1, "
"'unsigned'}})\n"
"box.schema.user.grant('guest','read,write','space','examples')\n"
"box.schema.user.grant('guest','read','space','_space')"

#: ../doc/1.10/book/connectors/__java.rst:3
msgid "Java"
msgstr "Java"

#: ../doc/1.10/book/connectors/__java.rst:5
msgid "See http://github.com/tarantool/tarantool-java/."
msgstr "См. http://github.com/tarantool/tarantool-java/."

#: ../doc/1.10/book/connectors/__go.rst:3
msgid "Go"
msgstr "Go"

#: ../doc/1.10/book/connectors/__go.rst:5
msgid "Please see https://github.com/mialinx/go-tarantool."
msgstr "См. https://github.com/mialinx/go-tarantool."

#: ../doc/1.10/book/connectors/__r.rst:3
msgid "R"
msgstr "R"

#: ../doc/1.10/book/connectors/__r.rst:5
msgid "See https://github.com/thekvs/tarantoolr."
msgstr "См. https://github.com/thekvs/tarantoolr."

#: ../doc/1.10/book/connectors/__erlang.rst:3
msgid "Erlang"
msgstr "Erlang"

#: ../doc/1.10/book/connectors/__erlang.rst:5
msgid "See `Erlang tarantool driver <https://github.com/stofel/taran>`_."
msgstr "См. `Erlang-драйвер для Tarantool'а <https://github.com/stofel/taran>`_."

#: ../doc/1.10/book/connectors/__perl.rst:3
msgid "Perl"
msgstr "Perl"

#: ../doc/1.10/book/connectors/__perl.rst:5
msgid ""
"The most commonly used Perl driver is `tarantool-perl "
"<https://github.com/tarantool/tarantool-perl>`_. It is not supplied as "
"part of the Tarantool repository; it must be installed separately. The "
"most common way to install it is by cloning from GitHub."
msgstr ""
"Самый используемый драйвер для Perl -- `tarantool-perl "
"<https://github.com/tarantool/tarantool-perl>`_. Он не входит в "
"репозиторий Tarantool'а, его необходимо устанавливать отдельно. Проще "
"всего установить его путем клонирования с GitHub."

#: ../doc/1.10/book/connectors/__perl.rst:10
msgid ""
"To avoid minor warnings that may appear the first time ``tarantool-perl``"
" is installed, start with installing some other modules that ``tarantool-"
"perl`` uses, with `CPAN, the Comprehensive Perl Archive Network "
"<https://en.wikipedia.org/wiki/Cpan>`_:"
msgstr ""
"Во избежание незначительных предупреждений, которые может выдать система "
"после первой установки ``tarantool-perl``, начните установку с некоторых "
"других модулей, которые использует ``tarantool-perl``, с `CPAN, the "
"Comprehensive Perl Archive Network (Всеобъемлющая сеть архивов Perl) "
"<https://ru.wikipedia.org/wiki/CPAN>`_:"

#: ../doc/1.10/book/connectors/__perl.rst:14
msgid ""
"$ sudo cpan install AnyEvent\n"
"$ sudo cpan install Devel::GlobalDestruction"
msgstr ""
"$ sudo cpan install AnyEvent\n"
"$ sudo cpan install Devel::GlobalDestruction"

#: ../doc/1.10/book/connectors/__perl.rst:19
msgid "Then, to install ``tarantool-perl`` itself, say:"
msgstr "Затем для установки самого ``tarantool-perl``, выполните:"

#: ../doc/1.10/book/connectors/__perl.rst:21
msgid ""
"$ git clone https://github.com/tarantool/tarantool-perl.git tarantool-"
"perl\n"
"$ cd tarantool-perl\n"
"$ git submodule init\n"
"$ git submodule update --recursive\n"
"$ perl Makefile.PL\n"
"$ make\n"
"$ sudo make install"
msgstr ""
"$ git clone https://github.com/tarantool/tarantool-perl.git tarantool-"
"perl\n"
"$ cd tarantool-perl\n"
"$ git submodule init\n"
"$ git submodule update --recursive\n"
"$ perl Makefile.PL\n"
"$ make\n"
"$ sudo make install"

#: ../doc/1.10/book/connectors/__perl.rst:31
msgid ""
"Here is a complete Perl program that inserts ``[99999,'BB']`` into "
"``space[999]`` via the Perl API. Before trying to run, check that the "
"server instance is listening at ``localhost:3301`` and that the space "
"``examples`` exists, as :ref:`described earlier <index-"
"connector_setting>`. To run, paste the code into a file named "
":file:`example.pl` and say :samp:`perl example.pl`. The program will "
"connect using an application-specific definition of the space. The "
"program will open a socket connection with the Tarantool instance at "
"``localhost:3301``, then send an :ref:`space_object:INSERT<box_space-"
"insert>` request, then — if all is well — end without displaying any "
"messages. If Tarantool is not running on ``localhost`` with :ref:`listen"
"<cfg_basic-listen>` port = 3301, the program will print “Connection "
"refused”."
msgstr ""
"Далее приводится пример полноценной программы на языке Perl, которая "
"осуществляет вставку кортежа ``[99999,'BB']`` в спейс ``space[999]`` с "
"помощью API для языка Perl. Перед запуском проверьте, что у экземпляра "
"задан порт для прослушивания на ``localhost:3301``, и в базе создан спейс"
" ``examples``, как :ref:`описано выше <index-connector_setting>`.  Чтобы "
"запустить программу, сохраните код в файл с именем :file:`example.pl` и "
"выполните команду :samp:`perl example.pl`. Программа установит "
"соединение, используя определение спейса для этой цели, откроет сокет для"
" соединения с экземпляром по ``localhost:3301``, пошлет запрос "
":ref:`space_object:INSERT<box_space-insert>`, а затем -- если всё хорошо "
"-- закончит работу без каких-либо сообщений. Если Tarantool не запущен на"
" ``localhost`` на :ref:`прослушивание <cfg_basic-listen>` по порту = "
"3301, то программа выдаст сообщение об ошибке \"Connection refused\"."

#: ../doc/1.10/book/connectors/__perl.rst:43
msgid ""
"#!/usr/bin/perl\n"
"use DR::Tarantool ':constant', 'tarantool';\n"
"use DR::Tarantool ':all';\n"
"use DR::Tarantool::MsgPack::SyncClient;\n"
"\n"
"my $tnt = DR::Tarantool::MsgPack::SyncClient->connect(\n"
"  host    => '127.0.0.1',                      # look for tarantool on "
"localhost\n"
"  port    => 3301,                             # on port 3301\n"
"  user    => 'guest',                          # username. for 'guest' we"
" do not also say 'password=>...'\n"
"\n"
"  spaces  => {\n"
"    999 => {                                   # definition of space[999]"
" ...\n"
"      name => 'examples',                      #   space[999] name = "
"'examples'\n"
"      default_type => 'STR',                   #   space[999] field type "
"is 'STR' if undefined\n"
"      fields => [ {                            #   definition of "
"space[999].fields ...\n"
"          name => 'field1', type => 'NUM' } ], #     space[999].field[1] "
"name='field1',type='NUM'\n"
"      indexes => {                             #   definition of "
"space[999] indexes ...\n"
"        0 => {\n"
"          name => 'primary', fields => [ 'field1' ] } } } } );\n"
"\n"
"$tnt->insert('examples' => [ 99999, 'BB' ]);"
msgstr ""
"#!/usr/bin/perl\n"
"#!/usr/bin/perl\n"
"use DR::Tarantool ':constant', 'tarantool';\n"
"use DR::Tarantool ':all';\n"
"use DR::Tarantool::MsgPack::SyncClient;\n"
"\n"
"  host    => '127.0.0.1',                      # поиск Tarantool-сервера "
"по адресу localhost\n"
"  port    => 3301,                             # на порту 3301\n"
"  user    => 'guest',                          # имя пользователя; здесь "
"же можно добавить 'password=>...'\n"
"\n"
"  spaces  => {\n"
"    999 => {                                   # определение спейса  "
"space[999] ...\n"
"      name => 'examples',                      # имя спейса space[999] = "
"'examples'\n"
"      default_type => 'STR',                   # если тип поля в "
"space[999] не задан, то = 'STR'\n"
"      fields => [ {                            # определение полей в "
"спейсе space[999] ...\n"
"          name => 'field1', type => 'NUM' } ], # имя поля "
"space[999].field[1]='field1', тип ='NUM'\n"
"      indexes => {                             # определение индексов "
"спейса space[999] ...\n"
"        0 => {\n"
"          name => 'primary', fields => [ 'field1' ] } } } } );\n"
"\n"
"$tnt->insert('examples' => [ 99999, 'BB' ]);"

#: ../doc/1.10/book/connectors/__perl.rst:67
msgid ""
"The example program uses field type names 'STR' and 'NUM' instead of "
":ref:`'string' and 'unsigned'<box_space-create_index>`, due to a "
"temporary Perl limitation."
msgstr ""
"Из-за временных ограничений в языке Perl, вместо полей типа "
":ref:`'string' и 'unsigned'<box_space-create_index>` в тестовой программе"
" указаны поля типа 'STR' и 'NUM'."

#: ../doc/1.10/book/connectors/__perl.rst:70
msgid ""
"The example program only shows one request and does not show all that's "
"necessary for good practice. For that, please see the `tarantool-perl "
"repository <https://github.com/tarantool/tarantool-perl>`_."
msgstr ""
"В этой программе мы привели пример использования лишь одного запроса. Для"
" полноценной работы с Tarantool'ом обратитесь к документации из "
"`репозитория tarantool-perl <https://github.com/tarantool/tarantool-"
"perl>`_."

#: ../doc/1.10/book/connectors/__php.rst:3
msgid "PHP"
msgstr "PHP"

#: ../doc/1.10/book/connectors/__php.rst:5
msgid ""
"`tarantool-php <https://github.com/tarantool/tarantool-php>`_ is the "
"official PHP connector for Tarantool. It is not supplied as part of the "
"Tarantool repository and must be installed separately (see `installation "
"instructions <https://github.com/tarantool/tarantool-php/#installing-and-"
"building>`_ in the connector's ``README`` file)."
msgstr ""
"`tarantool-php <https://github.com/tarantool/tarantool-php>`_ -- это "
"официальный PHP-коннектор для Tarantool'а. Он не входит в репозиторий "
"Tarantool'а, его необходимо устанавливать отдельно (`инструкции по "
"установке <https://github.com/tarantool/tarantool-php/#installing-and-"
"building>`_ см. в файле коннектора :file:`README`)."

#: ../doc/1.10/book/connectors/__php.rst:12
msgid ""
"Here is a complete PHP program that inserts ``[99999,'BB']`` into a space"
" named ``examples`` via the PHP API."
msgstr ""
"Далее приводится пример полноценной программы на языке PHP, которая "
"осуществляет вставку кортежа ``[99999,'BB']`` в спейс ``examples``  с "
"помощью API для языка PHP."

#: ../doc/1.10/book/connectors/__php.rst:15
msgid ""
"Before trying to run, check that the server instance is :ref:`listening "
"<cfg_basic-listen>` at ``localhost:3301`` and that the space ``examples``"
" exists, as :ref:`described earlier <index-connector_setting>`."
msgstr ""
"Перед запуском проверьте, что у экземпляра задан порт для "
":ref:`прослушивания <cfg_basic-listen>` на ``localhost:3301``, и в базе "
"создан спейс ``examples``, как :ref:`описано выше <index-"
"connector_setting>`."

#: ../doc/1.10/book/connectors/__php.rst:19
msgid "To run, paste the code into a file named :file:`example.php` and say:"
msgstr ""
"Чтобы запустить программу, сохраните код в файл с именем "
":file:`example.php` и выполните:"

#: ../doc/1.10/book/connectors/__php.rst:21
msgid "$ php -d extension=~/tarantool-php/modules/tarantool.so example.php"
msgstr "$ php -d extension=~/tarantool-php/modules/tarantool.so example.php"

#: ../doc/1.10/book/connectors/__php.rst:25
msgid ""
"The program will open a socket connection with the Tarantool instance at "
"``localhost:3301``, then send an :ref:`INSERT <box_space-insert>` "
"request, then -- if all is well -- print \"Insert succeeded\"."
msgstr ""
"Программа откроет сокет для соединения с экземпляром по "
"``localhost:3301``, отправит :ref:`INSERT-запрос <box_space-insert>`, а "
"затем -- если всё хорошо -- выдаст сообщение \"Insert succeeded\"."

#: ../doc/1.10/book/connectors/__php.rst:29
msgid ""
"If the tuple already exists, the program will print \"Duplicate key "
"exists in unique index 'primary' in space 'examples'\"."
msgstr ""
"Если такой кортеж уже существует, то программа выдаст сообщение об ошибке"
" “Duplicate key exists in unique index 'primary' in space 'examples'”."

#: ../doc/1.10/book/connectors/__php.rst:32
msgid ""
"<?php\n"
"$tarantool = new Tarantool('localhost', 3301);\n"
"\n"
"try {\n"
"    $tarantool->insert('examples', [99999, 'BB']);\n"
"    echo \"Insert succeeded\\n\";\n"
"} catch (Exception $e) {\n"
"    echo $e->getMessage(), \"\\n\";\n"
"}"
msgstr ""
"<?php\n"
"$tarantool = new Tarantool('localhost', 3301);\n"
"\n"
"try {\n"
"    $tarantool->insert('examples', [99999, 'BB']);\n"
"    echo \"Insert succeeded\\n\";\n"
"} catch (Exception $e) {\n"
"    echo $e->getMessage(), \"\\n\";\n"
"}"

#: ../doc/1.10/book/connectors/__php.rst:44
msgid ""
"The example program only shows one request and does not show all that's "
"necessary for good practice. For that, please see `tarantool/tarantool-"
"php <https://github.com/tarantool/tarantool-php>`_ project at GitHub."
msgstr ""
"В этой программе мы привели пример использования лишь одного запроса. Для"
" полноценной работы с Tarantool'ом обратитесь к документации из `проекта "
"tarantool-php на GitHub <https://github.com/tarantool/tarantool-php>`_."

#: ../doc/1.10/book/connectors/__php.rst:49
msgid ""
"Besides, there is another community-driven `GitHub project "
"<https://github.com/tarantool-php>`_ which includes an `alternative "
"connector <https://github.com/tarantool-php/client>`_ written in pure "
"PHP, an `object mapper <https://github.com/tarantool-php/mapper>`_, a "
"`queue <https://github.com/tarantool-php/queue>`_ and other packages."
msgstr ""
"Кроме того, сообщество разработчиков поддерживает `проект на GitHub "
"<https://github.com/tarantool-php>`_, который включает в себя `вариант "
"коннектора <https://github.com/tarantool-php/client>`_, написанный на "
"чистом PHP, `модуль сопоставления объектов <https://github.com/tarantool-"
"php/mapper>`_, `администратор очередей <https://github.com/tarantool-"
"php/queue>`_ и другие пакеты."

#: ../doc/1.10/book/connectors/__python.rst:3
msgid "Python"
msgstr "Python"

#: ../doc/1.10/book/connectors/__python.rst:5
#, fuzzy
msgid ""
"`tarantool-python <http://github.com/tarantool/tarantool-python>`_ is the"
" official Python connector for Tarantool. It is not supplied as part of "
"the Tarantool repository and must be installed separately (see below for "
"details)."
msgstr ""
"`tarantool-php <https://github.com/tarantool/tarantool-php>`_ -- это "
"официальный PHP-коннектор для Tarantool'а. Он не входит в репозиторий "
"Tarantool'а, его необходимо устанавливать отдельно (`инструкции по "
"установке <https://github.com/tarantool/tarantool-php/#installing-and-"
"building>`_ см. в файле коннектора :file:`README`)."

#: ../doc/1.10/book/connectors/__python.rst:9
msgid ""
"Here is a complete Python program that inserts "
"``[99999,'Value','Value']`` into space ``examples`` via the high-level "
"Python API."
msgstr ""
"Далее приводится пример полноценной программы на языке Python, которая "
"осуществляет вставку ``[99999,'Value','Value']`` в спейс ``examples`` с "
"помощью высокоуровневого API для языка Python. "

#: ../doc/1.10/book/connectors/__python.rst:12
msgid ""
"#!/usr/bin/python\n"
"from tarantool import Connection\n"
"\n"
"c = Connection(\"127.0.0.1\", 3301)\n"
"result = c.insert(\"examples\",(99999,'Value', 'Value'))\n"
"print result"
msgstr ""
"#!/usr/bin/python\n"
"from tarantool import Connection\n"
"\n"
"c = Connection(\"127.0.0.1\", 3301)\n"
"result = c.insert(\"examples\",(99999,'Value', 'Value'))\n"
"print result"

#: ../doc/1.10/book/connectors/__python.rst:21
msgid ""
"To prepare, paste the code into a file named :file:`example.py` and "
"install the ``tarantool-python`` connector with either :samp:`pip install"
" tarantool\\>0.4` to install in :file:`/usr` (requires **root** "
"privilege) or :samp:`pip install tarantool\\>0.4 --user` to install in "
":file:`~` i.e. user's default directory."
msgstr ""

#: ../doc/1.10/book/connectors/__python.rst:27
msgid ""
"Before trying to run, check that the server instance is :ref:`listening "
"<cfg_basic-listen>` at ``localhost:3301`` and that the space ``examples``"
" exists, as :ref:`described earlier <index-connector_setting>`. To run "
"the program, say :samp:`python example.py`. The program will connect to "
"the Tarantool server, will send the :ref:`INSERT<box_space-insert>` "
"request, and will not throw any exception if all went well. If the tuple "
"already exists, the program will throw ``tarantool.error.DatabaseError: "
"(3, \"Duplicate key exists in unique index 'primary' in space "
"'examples'\")``."
msgstr ""

#: ../doc/1.10/book/connectors/__python.rst:35
msgid ""
"The example program only shows one request and does not show all that's "
"necessary for good practice. For that, please see `tarantool-python "
"<http://github.com/tarantool/tarantool-python>`_ project at GitHub. For "
"an example of using Python API with `queue managers for Tarantool "
"<https://github.com/tarantool/queue>`_, see `queue-python "
"<https://github.com/tarantool/queue-python>`_ project at GitHub."
msgstr ""
"В этой программе мы привели пример использования лишь одного запроса. Для"
" полноценной работы с Tarantool'ом обратитесь к документации из `проекта "
"tarantool-python на GitHub <http://github.com/tarantool/tarantool-"
"python>`_. А на странице `проекта queue-python на GitHub "
"<https://github.com/tarantool/queue-python>`_ вы сможете найти примеры "
"использования Python API для работы с `очередями сообщений в Tarantool'е "
"<https://github.com/tarantool/queue>`_."

#: ../doc/1.10/book/connectors/__python.rst:42
msgid "Also there are several community-driven Python connectors:"
msgstr ""

#: ../doc/1.10/book/connectors/__python.rst:44
msgid "`asynctnt <https://github.com/igorcoding/asynctnt>`_ with asyncio support"
msgstr ""

#: ../doc/1.10/book/connectors/__python.rst:45
msgid ""
"`aiotarantool <https://github.com/shveenkov/aiotarantool>`_ also with "
"asyncio support"
msgstr ""

#: ../doc/1.10/book/connectors/__python.rst:46
msgid ""
"`gtarantool <https://github.com/shveenkov/gtarantool>`_ with gevent "
"support **no active maintenance**"
msgstr ""

#: ../doc/1.10/book/connectors/__nodejs.rst:3
msgid "Node.js"
msgstr "Node.js"

#: ../doc/1.10/book/connectors/__nodejs.rst:5
msgid ""
"The most commonly used node.js driver is the `Node Tarantool driver "
"<https://github.com/KlonD90/node-tarantool-driver>`_. It is not supplied "
"as part of the Tarantool repository; it must be installed separately. The"
" most common way to install it is with `npm <https://www.sitepoint.com"
"/beginners-guide-node-package-manager/>`_. For example, on Ubuntu, the "
"installation could look like this after npm has been installed:"
msgstr ""
"Самый используемый драйвер для node.js -- `Node Tarantool driver "
"<https://github.com/KlonD90/node-tarantool-driver>`_. Он не входит в "
"репозиторий Tarantool'а, его необходимо устанавливать отдельно. Проще "
"всего установить его вместе с `npm <https://www.sitepoint.com/beginners-"
"guide-node-package-manager/>`_. Например, на Ubuntu, когда npm уже "
"установлен, установка драйвера будет выглядеть следующим образом:"

#: ../doc/1.10/book/connectors/__nodejs.rst:13
msgid "$ npm install tarantool-driver --global"
msgstr "$ npm install tarantool-driver --global"

#: ../doc/1.10/book/connectors/__nodejs.rst:17
msgid ""
"Here is a complete node.js program that inserts ``[99999,'BB']`` into "
"``space[999]`` via the node.js API. Before trying to run, check that the "
"server instance is :ref:`listening <cfg_basic-listen>` at "
"``localhost:3301`` and that the space ``examples`` exists, as "
":ref:`described earlier <index-connector_setting>`. To run, paste the "
"code into a file named :file:`example.rs` and say ``node example.rs``. "
"The program will connect using an application-specific definition of the "
"space. The program will open a socket connection with the Tarantool "
"instance at ``localhost:3301``, then send an :ref:`INSERT <box_space-"
"insert>` request, then — if all is well — end after saying \"Insert "
"succeeded\". If Tarantool is not running on ``localhost`` with listen "
"port = 3301, the program will print “Connect failed”. If :ref:`the "
"'guest' user <box_space-user>` does not have authorization to connect, "
"the program will print \"Auth failed\". If the insert request fails for "
"any reason, for example because the tuple already exists, the program "
"will print \"Insert failed\"."
msgstr ""
"Далее приводится пример полноценной программы на языке node.js, которая "
"осуществляет вставку кортежа ``[99999,'BB']`` в спейс ``space[999]`` с "
"помощью API для языка node.js. Перед запуском проверьте, что у экземпляра"
" задан порт для :ref:`прослушивания <cfg_basic-listen>` на "
"``localhost:3301``, и в базе создан спейс ``examples``, как :ref:`описано"
" выше <index-connector_setting>`. Чтобы запустить программу, сохраните "
"код в файл с именем :file:`example.rs` и выполните команду ``node "
"example.rs``. Программа установит соединение, используя определение "
"спейса для этой цели, откроет сокет для соединения с экземпляром по "
"``localhost:3301``, отправит :ref:`INSERT-запрос <box_space-insert>`, а "
"затем -- если всё хорошо -- выдаст сообщение \"Insert succeeded\". Если "
"Tarantool не запущен на ``localhost`` на прослушивание по порту = 3301, "
"то программа выдаст сообщение об ошибке “Connect failed”. Если у "
":ref:`пользователя 'guest' <box_space-user>` нет прав на соединение, "
"программа выдаст сообщение об ошибке \"Auth failed\". Если запрос вставки"
" по какой-либо причине не сработает, например поскольку такой кортеж уже "
"существует, то программа выдаст сообщение об ошибке \"Insert failed\"."

#: ../doc/1.10/book/connectors/__nodejs.rst:31
msgid ""
"var TarantoolConnection = require('tarantool-driver');\n"
"var conn = new TarantoolConnection({port: 3301});\n"
"var insertTuple = [99999, \"BB\"];\n"
"conn.connect().then(function() {\n"
"    conn.auth(\"guest\", \"\").then(function() {\n"
"        conn.insert(999, insertTuple).then(function() {\n"
"            console.log(\"Insert succeeded\");\n"
"            process.exit(0);\n"
"    }, function(e) { console.log(\"Insert failed\");  process.exit(1); "
"});\n"
"    }, function(e) { console.log(\"Auth failed\");    process.exit(1); "
"});\n"
"    }, function(e) { console.log(\"Connect failed\"); process.exit(1); });"
msgstr ""
"var TarantoolConnection = require('tarantool-driver');\n"
"var conn = new TarantoolConnection({port: 3301});\n"
"var insertTuple = [99999, \"BB\"];\n"
"conn.connect().then(function() {\n"
"    conn.auth(\"guest\", \"\").then(function() {\n"
"        conn.insert(999, insertTuple).then(function() {\n"
"            console.log(\"Insert succeeded\");\n"
"            process.exit(0);\n"
"    }, function(e) { console.log(\"Insert failed\");  process.exit(1); "
"});\n"
"    }, function(e) { console.log(\"Auth failed\");    process.exit(1); "
"});\n"
"    }, function(e) { console.log(\"Connect failed\"); process.exit(1); });"

#: ../doc/1.10/book/connectors/__nodejs.rst:45
msgid ""
"The example program only shows one request and does not show all that's "
"necessary for good practice. For that, please see  `The node.js driver "
"repository <https://github.com/KlonD90/node-tarantool-driver>`_."
msgstr ""
"В этой программе мы привели пример использования лишь одного запроса. Для"
" полноценной работы с Tarantool'ом обратитесь к документации из "
"`репозитория драйвера для node.js <https://github.com/KlonD90/node-"
"tarantool-driver>`_."

#: ../doc/1.10/book/connectors/__csharp.rst:3
msgid "C#"
msgstr "C#"

#: ../doc/1.10/book/connectors/__csharp.rst:5
msgid ""
"The most commonly used C# driver is `progaudi.tarantool "
"<https://github.com/progaudi/progaudi.tarantool>`_, previously named "
"``tarantool-csharp``. It is not supplied as part of the Tarantool "
"repository; it must be installed separately. The makers recommend `cross-"
"platform installation using Nuget "
"<https://www.nuget.org/packages/progaudi.tarantool>`_."
msgstr ""
"Самый используемый драйвер для C# -- `progaudi.tarantool "
"<https://github.com/progaudi/progaudi.tarantool>`_, который раньше "
"назывался ``tarantool-csharp``. Он не входит в репозиторий Tarantool'а, "
"его необходимо устанавливать отдельно. Создатели драйвера рекомендуют "
"`кроссплатформенную установку с помощью Nuget "
"<https://www.nuget.org/packages/progaudi.tarantool>`_."

#: ../doc/1.10/book/connectors/__csharp.rst:11
msgid ""
"To be consistent with the other instructions in this chapter, here is a "
"way to install the driver directly on Ubuntu 16.04."
msgstr ""
"Чтобы придерживаться метода оформления других инструкций в данной главе, "
"дадим описание способа установки драйвера напрямую на 16.04."

#: ../doc/1.10/book/connectors/__csharp.rst:14
msgid ""
"Install .net core from Microsoft. Follow `.net core installation "
"instructions <https://www.microsoft.com/net/core#ubuntu>`_."
msgstr ""
"Установите среду .NET Core от Microsoft. Следуйте `инструкциям по "
"установке .NET Core <https://www.microsoft.com/net/core#ubuntu>`_."

#: ../doc/1.10/book/connectors/__csharp.rst:19
msgid ""
"Mono will not work, nor will .Net from xbuild. Only .net core supported "
"on Linux and Mac."
msgstr ""
"Mono не сработает, как не сработает и .Net от xbuild. Только .NET Core "
"поддерживается на Linux и Mac."

#: ../doc/1.10/book/connectors/__csharp.rst:21
msgid ""
"Read the Microsoft End User License Agreement first, because it is not an"
" ordinary open-source agreement and there will be a message during "
"installation saying \"This software may collect information about you and"
" your use of the software, and send that to Microsoft.\" Still you can "
"`set environment variables <https://docs.microsoft.com/en-"
"us/dotnet/core/tools/telemetry#behavior>`_ to opt out from telemetry."
msgstr ""
"Сначала прочитайте Условия лицензионного соглашения с Microsoft, "
"поскольку оно не похоже на обычные соглашения для ПО с открытым кодом, и "
"во время установки система выдаст сообщение о том, что ПО может собирать "
"информацию (\"This software may collect information about you and your "
"use of the software, and send that to Microsoft.\"). Несмотря на это, "
"можно `определить переменные окружения  <https://docs.microsoft.com/en-"
"us/dotnet/core/tools/telemetry#behavior>`_, чтобы отказаться от участия в"
" сборе телеметрических данных."

#: ../doc/1.10/book/connectors/__csharp.rst:29
msgid "Create a new console project."
msgstr "Создайте новый консольный проект."

#: ../doc/1.10/book/connectors/__csharp.rst:31
msgid ""
"$ cd ~\n"
"$ mkdir progaudi.tarantool.test\n"
"$ cd progaudi.tarantool.test\n"
"$ dotnet new console"
msgstr ""
"$ cd ~\n"
"$ mkdir progaudi.tarantool.test\n"
"$ cd progaudi.tarantool.test\n"
"$ dotnet new console"

#: ../doc/1.10/book/connectors/__csharp.rst:38
msgid "Add ``progaudi.tarantool`` reference."
msgstr "Добавьте ссылку на ``progaudi.tarantool``."

#: ../doc/1.10/book/connectors/__csharp.rst:40
msgid "$ dotnet add package progaudi.tarantool"
msgstr "$ dotnet add package progaudi.tarantool"

#: ../doc/1.10/book/connectors/__csharp.rst:44
msgid "Change code in ``Program.cs``."
msgstr "Измените код в ``Program.cs``."

#: ../doc/1.10/book/connectors/__csharp.rst:46
msgid ""
"$ cat <<EOT > Program.cs\n"
"using System;\n"
"using System.Threading.Tasks;\n"
"using ProGaudi.Tarantool.Client;\n"
"\n"
"public class HelloWorld\n"
"{\n"
"  static public void Main ()\n"
"  {\n"
"    Test().GetAwaiter().GetResult();\n"
"  }\n"
"  static async Task Test()\n"
"  {\n"
"    var box = await Box.Connect(\"127.0.0.1:3301\");\n"
"    var schema = box.GetSchema();\n"
"    var space = await schema.GetSpace(\"examples\");\n"
"    await space.Insert((99999, \"BB\"));\n"
"  }\n"
"}\n"
"EOT"
msgstr ""
"$ cat <<EOT > Program.cs\n"
"using System;\n"
"using System.Threading.Tasks;\n"
"using ProGaudi.Tarantool.Client;\n"
"\n"
"public class HelloWorld\n"
"{\n"
"  static public void Main ()\n"
"  {\n"
"    Test().GetAwaiter().GetResult();\n"
"  }\n"
"  static async Task Test()\n"
"  {\n"
"    var box = await Box.Connect(\"127.0.0.1:3301\");\n"
"    var schema = box.GetSchema();\n"
"    var space = await schema.GetSpace(\"examples\");\n"
"    await space.Insert((99999, \"BB\"));\n"
"  }\n"
"}\n"
"EOT"

#: ../doc/1.10/book/connectors/__csharp.rst:69
msgid "Build and run your application."
msgstr "Соберите и запустите приложение."

#: ../doc/1.10/book/connectors/__csharp.rst:71
msgid ""
"Before trying to run, check that the server is listening at "
"``localhost:3301`` and that the space ``examples`` exists, as "
":ref:`described earlier <index-connector_setting>`."
msgstr ""
"Перед запуском проверьте, что у экземпляра задан порт для прослушивания "
"на``localhost:3301``, и в базе создан спейс ``examples``, как "
":ref:`описано выше <index-connector_setting>`."

#: ../doc/1.10/book/connectors/__csharp.rst:75
msgid ""
"$ dotnet restore\n"
"$ dotnet run"
msgstr ""
"$ dotnet restore\n"
"$ dotnet run"

#: ../doc/1.10/book/connectors/__csharp.rst:80
msgid "The program will:"
msgstr "Программа:"

#: ../doc/1.10/book/connectors/__csharp.rst:82
msgid "connect using an application-specific definition of the space,"
msgstr "установит соединение, используя определение спейса для этой цели,"

#: ../doc/1.10/book/connectors/__csharp.rst:83
msgid "open a socket connection with the Tarantool server at `localhost:3301`,"
msgstr "откроет сокет для соединения с экземпляром по ``localhost:3301``,"

#: ../doc/1.10/book/connectors/__csharp.rst:84
msgid ""
"send an INSERT request, and — if all is well — end without saying "
"anything."
msgstr ""
"отправит INSERT-запрос, а затем -- если всё хорошо -- закончит работу без"
" каких-либо сообщений."

#: ../doc/1.10/book/connectors/__csharp.rst:86
msgid ""
"If Tarantool is not running on localhost with listen port = 3301, or if "
"user 'guest' does not have authorization to connect, or if the INSERT "
"request fails for any reason, the program will print an error message, "
"among other things (stacktrace, etc)."
msgstr ""
"Если Tarantool не запущен на ``localhost`` на прослушивание по порту "
"3301, или у пользователя 'guest' нет прав на соединение, или запрос "
"вставки по какой-либо причине не сработает, то программа выдаст сообщение"
" об ошибке и другую информацию (трассировку стека и т.д.)."

#: ../doc/1.10/book/connectors/__csharp.rst:91
msgid ""
"The example program only shows one request and does not show all that’s "
"necessary for good practice. For that, please see the `progaudi.tarantool"
" driver repository <https://github.com/progaudi/progaudi.tarantool>`_."
msgstr ""
"В этой программе мы привели пример использования лишь одного запроса. Для"
"  полноценной работы с Tarantool'ом с помощью PHP API, пожалуйста, "
"обратитесь к документации из `проекта tarantool-php на GitHub "
"<https://github.com/tarantool/tarantool-php>`_."

#: ../doc/1.10/book/connectors/__c.rst:3
msgid "C"
msgstr "C"

#: ../doc/1.10/book/connectors/__c.rst:5
msgid "Here follow two examples of using Tarantool's high-level C API."
msgstr ""
"В этом разделе даны два примера использования высокоуровневого API для "
"Tarantool'а и языка C."

#: ../doc/1.10/book/connectors/__c.rst:9
msgid "Example 1"
msgstr "Пример 1"

#: ../doc/1.10/book/connectors/__c.rst:11
msgid ""
"Here is a complete C program that inserts :code:`[99999,'B']` into space "
":code:`examples` via the high-level C API."
msgstr ""
"Далее приводится пример полноценной программы на языке C, которая "
"осуществляет вставку кортежа ``[99999,'B']`` в спейс :code:`examples` с "
"помощью высокоуровневого API для языка C. "

#: ../doc/1.10/book/connectors/__c.rst:14
#, python-format
msgid ""
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"\n"
"void main() {\n"
"   struct tnt_stream *tnt = tnt_net(NULL);          /* See note = SETUP "
"*/\n"
"   tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"   if (tnt_connect(tnt) < 0) {                      /* See note = CONNECT"
" */\n"
"       printf(\"Connection refused\\n\");\n"
"       exit(-1);\n"
"   }\n"
"   struct tnt_stream *tuple = tnt_object(NULL);     /* See note = MAKE "
"REQUEST */\n"
"   tnt_object_format(tuple, \"[%d%s]\", 99999, \"B\");\n"
"   tnt_insert(tnt, 999, tuple);                     /* See note = SEND "
"REQUEST */\n"
"   tnt_flush(tnt);\n"
"   struct tnt_reply reply;  tnt_reply_init(&reply); /* See note = GET "
"REPLY */\n"
"   tnt->read_reply(tnt, &reply);\n"
"   if (reply.code != 0) {\n"
"       printf(\"Insert failed %lu.\\n\", reply.code);\n"
"   }\n"
"   tnt_close(tnt);                                  /* See below = "
"TEARDOWN */\n"
"   tnt_stream_free(tuple);\n"
"   tnt_stream_free(tnt);\n"
"}"
msgstr ""
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"\n"
"void main() {\n"
"   struct tnt_stream *tnt = tnt_net(NULL);          /* См. ниже = "
"НАСТРОЙКА */\n"
"   tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"   if (tnt_connect(tnt) < 0) {                      /* См. ниже = "
"СОЕДИНЕНИЕ */\n"
"       printf(\"Connection refused\\n\");\n"
"       exit(-1);\n"
"   }\n"
"   struct tnt_stream *tuple = tnt_object(NULL);     /* См. ниже = "
"СОЗДАНИЕ ЗАПРОСА */\n"
"   tnt_object_format(tuple, \"[%d%s]\", 99999, \"B\");\n"
"   tnt_insert(tnt, 999, tuple);                     /* См. ниже = "
"ОТПРАВКА ЗАПРОСА */\n"
"   tnt_flush(tnt);\n"
"   struct tnt_reply reply;  tnt_reply_init(&reply); /* См. ниже = "
"ПОЛУЧЕНИЕ ОТВЕТА */\n"
"   tnt->read_reply(tnt, &reply);\n"
"   if (reply.code != 0) {\n"
"       printf(\"Insert failed %lu.\\n\", reply.code);\n"
"   }\n"
"   tnt_close(tnt);                                  /* См. ниже = "
"ЗАВЕРШЕНИЕ */\n"
"   tnt_stream_free(tuple);\n"
"   tnt_stream_free(tnt);\n"
"}"

#: ../doc/1.10/book/connectors/__c.rst:44
msgid ""
"Paste the code into a file named :file:`example.c` and install "
"``tarantool-c``. One way to install ``tarantool-c`` (using Ubuntu) is:"
msgstr ""
"Скопируйте исходный код программы в файл с именем :file:`example.c` и "
"установите коннектор ``tarantool-c``. Вот один из способов установки "
"``tarantool-c`` (под Ubuntu):"

#: ../doc/1.10/book/connectors/__c.rst:47
msgid ""
"$ git clone git://github.com/tarantool/tarantool-c.git ~/tarantool-c\n"
"$ cd ~/tarantool-c\n"
"$ git submodule init\n"
"$ git submodule update\n"
"$ cmake .\n"
"$ make\n"
"$ make install"
msgstr ""
"$ git clone git://github.com/tarantool/tarantool-c.git ~/tarantool-c\n"
"$ cd ~/tarantool-c\n"
"$ git submodule init\n"
"$ git submodule update\n"
"$ cmake .\n"
"$ make\n"
"$ make install"

#: ../doc/1.10/book/connectors/__c.rst:57
#: ../doc/1.10/book/connectors/__c.rst:282
msgid "To compile and link the program, say:"
msgstr ""
"Чтобы скомпилировать и слинковать тестовую программу, выполните следующую"
"  команду:"

#: ../doc/1.10/book/connectors/__c.rst:59
msgid ""
"$ # sometimes this is necessary:\n"
"$ export LD_LIBRARY_PATH=/usr/local/lib\n"
"$ gcc -o example example.c -ltarantool"
msgstr ""
"$ # иногда это необходимо:\n"
"$ export LD_LIBRARY_PATH=/usr/local/lib\n"
"$ gcc -o example example.c -ltarantool"

#: ../doc/1.10/book/connectors/__c.rst:65
msgid ""
"Before trying to run, check that a server instance is listening at "
"``localhost:3301`` and that the space ``examples`` exists, as "
":ref:`described earlier <index-connector_setting>`. To run the program, "
"say :samp:`./example`. The program will connect to the Tarantool "
"instance, and will send the request. If Tarantool is not running on "
"localhost with listen address = 3301, the program will print “Connection "
"refused”. If the insert fails, the program will print \"Insert failed\" "
"and an error number (see all error codes in the source file "
"`/src/box/errcode.h "
"<https://github.com/tarantool/tarantool/blob/1.10/src/box/errcode.h>`_)."
msgstr ""
"Перед запуском проверьте, что у экземпляра задан порт для прослушивания "
"на``localhost:3301``, и в базе создан спейс ``examples``, как "
":ref:`описано выше <index-connector_setting>`. Чтобы запустить программу,"
" выполните команду :samp:`./example`. Программа установит соединение с "
"экземпляром Tarantool'а и отправит запрос. Если Tarantool не запущен на "
"localhost на прослушивание по порту 3301, то программа выдаст сообщение "
"об ошибке “Connection refused”. Если вставка не сработает, программа "
"выдаст сообщение об ошибке \"Insert failed\" и код ошибки (все коды "
"ошибок см. в исходном файле `/src/box/errcode.h "
"<https://github.com/tarantool/tarantool/blob/1.10/src/box/errcode.h>`_)."

#: ../doc/1.10/book/connectors/__c.rst:77
msgid "Here are notes corresponding to comments in the example program."
msgstr ""
"Далее следуют примечания, на которые мы ссылались в комментариях к "
"исходному коду тестовой программы."

#: ../doc/1.10/book/connectors/__c.rst:79
msgid "**SETUP:** The setup begins by creating a stream."
msgstr "**НАСТРОЙКА:** Настройка начинается с создания потока (``tnt_stream``)."

#: ../doc/1.10/book/connectors/__c.rst:81
msgid ""
"struct tnt_stream *tnt = tnt_net(NULL);\n"
"tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");"
msgstr ""
"struct tnt_stream *tnt = tnt_net(NULL);\n"
"tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");"

#: ../doc/1.10/book/connectors/__c.rst:86
msgid ""
"In this program, the stream will be named ``tnt``. Before connecting on "
"the ``tnt`` stream, some options may have to be set. The most important "
"option is TNT_OPT_URI. In this program, the :ref:`URI <index-uri>` is "
"``localhost:3301``, since that is where the Tarantool instance is "
"supposed to be listening."
msgstr ""
"В нашей программе поток назван ``tnt``. Перед установкой соединения с "
"потоком ``tnt`` нужно задать ряд опций. Самая важная из них -- "
"TNT_OPT_URI. Для этой опции указан :ref:`URI <index-uri>` "
"``localhost:3301``, т.е. адрес, по которому должно быть настроено "
"прослушивание на стороне экземпляра Tarantool'а."

#: ../doc/1.10/book/connectors/__c.rst:92
#: ../doc/1.10/book/connectors/__c.rst:107
#: ../doc/1.10/book/connectors/__c.rst:134
#: ../doc/1.10/book/connectors/__c.rst:153
#: ../doc/1.10/book/connectors/__c.rst:177
#: ../doc/1.10/book/connectors/__c.rst:195
msgid "Function description:"
msgstr "Описание функции:"

#: ../doc/1.10/book/connectors/__c.rst:94
msgid ""
"struct tnt_stream *tnt_net(struct tnt_stream *s)\n"
"int tnt_set(struct tnt_stream *s, int option, variant option-value)"
msgstr ""
"struct tnt_stream *tnt_net(struct tnt_stream *s)\n"
"int tnt_set(struct tnt_stream *s, int option, variant option-value)"

#: ../doc/1.10/book/connectors/__c.rst:99
msgid ""
"**CONNECT:** Now that the stream named ``tnt`` exists and is associated "
"with a URI, this example program can connect to a server instance."
msgstr ""
"**СОЕДИНЕНИЕ:** Теперь когда мы создали поток с именем ``tnt`` и связали "
"его с конкретным URI, наша программа может устанавливать соединение с "
"экземпляром."

#: ../doc/1.10/book/connectors/__c.rst:102
msgid ""
"if (tnt_connect(tnt) < 0)\n"
"   { printf(\"Connection refused\\n\"); exit(-1); }"
msgstr ""
"if (tnt_connect(tnt) < 0)\n"
"   { printf(\"Connection refused\\n\"); exit(-1); }"

#: ../doc/1.10/book/connectors/__c.rst:109
msgid "int tnt_connect(struct tnt_stream *s)"
msgstr "int tnt_connect(struct tnt_stream *s)"

#: ../doc/1.10/book/connectors/__c.rst:113
msgid ""
"The connection might fail for a variety of reasons, such as: the server "
"is not running, or the URI contains an invalid :ref:`password"
"<authentication-passwords>`. If the connection fails, the return value "
"will be -1."
msgstr ""
"Попытка соединения может и не удаться по разным причинам, например если "
"Tarantool-сервер не запущен или в URI-строке указан неверный :ref:`пароль"
" <authentication-passwords>`. В случае неудачи функция вернет -1."

#: ../doc/1.10/book/connectors/__c.rst:117
msgid ""
"**MAKE REQUEST:** Most requests require passing a structured value, such "
"as the contents of a tuple."
msgstr ""
"**СОЗДАНИЕ ЗАПРОСА:** В большинстве запросов требуется передавать "
"структурированные данные, например содержимое кортежа."

#: ../doc/1.10/book/connectors/__c.rst:120
#, python-format
msgid ""
"struct tnt_stream *tuple = tnt_object(NULL);\n"
"tnt_object_format(tuple, \"[%d%s]\", 99999, \"B\");"
msgstr ""
"struct tnt_stream *tuple = tnt_object(NULL);\n"
"tnt_object_format(tuple, \"[%d%s]\", 99999, \"B\");"

#: ../doc/1.10/book/connectors/__c.rst:125
#, python-format
msgid ""
"In this program, the request will be an :ref:`INSERT<box_space-insert>`, "
"and the tuple contents will be an integer and a string. This is a simple "
"serial set of values, that is, there are no sub-structures or arrays. "
"Therefore it is easy in this case to format what will be passed using the"
" same sort of arguments that one would use with a C ``printf()`` "
"function: ``%d`` for the integer, ``%s`` for the string, then the integer"
" value, then a pointer to the string value."
msgstr ""
"В данной программе мы используем запрос :ref:`INSERT<box_space-insert>`, "
"а кортеж содержит целое число и строку.  Это простой набор значений без "
"каких-либо вложенных структур или массивов. И передаваемые значения мы "
"можем указать самым простым образом -- аналогично тому, как это сделано в"
" стандартной C-функции ``printf()``: ``%d`` для обозначения целого числа,"
" ``%s`` для обозначения строки, затем числовое значение, затем указатель "
"на строковое значение."

#: ../doc/1.10/book/connectors/__c.rst:136
msgid "ssize_t tnt_object_format(struct tnt_stream *s, const char *fmt, ...)"
msgstr "ssize_t tnt_object_format(struct tnt_stream *s, const char *fmt, ...)"

#: ../doc/1.10/book/connectors/__c.rst:140
msgid ""
"**SEND REQUEST:** The database-manipulation requests are analogous to the"
" requests in the box library."
msgstr ""
"**ОТПРАВКА ЗАПРОСА:** Отправка запросов на изменение данных в базе "
"делается аналогично тому, как это делается в Tarantool-библиотеке "
"``box``."

#: ../doc/1.10/book/connectors/__c.rst:143
msgid ""
"tnt_insert(tnt, 999, tuple);\n"
"tnt_flush(tnt);"
msgstr ""
"tnt_insert(tnt, 999, tuple);\n"
"tnt_flush(tnt);"

#: ../doc/1.10/book/connectors/__c.rst:148
msgid ""
"In this program, the choice is to do an INSERT request, so the program "
"passes the ``tnt_stream`` that was used for connection (``tnt``) and the "
"``tnt_stream`` that was set up with "
":c:func:`tarantoolc:tnt_object_format` (``tuple``)."
msgstr ""
"В данной программе мы делаем INSERT-запрос. В этом запросе мы передаем "
"поток ``tnt``, который ранее использовали для установки соединения, и "
"поток :code:`tuple`, который также ранее настроили с помощью функции "
":c:func:`tarantoolc:tnt_object_format`."

#: ../doc/1.10/book/connectors/__c.rst:155
msgid ""
"ssize_t tnt_insert(struct tnt_stream *s, uint32_t space, struct "
"tnt_stream *tuple)\n"
"ssize_t tnt_replace(struct tnt_stream *s, uint32_t space, struct "
"tnt_stream *tuple)\n"
"ssize_t tnt_select(struct tnt_stream *s, uint32_t space, uint32_t index,\n"
"                   uint32_t limit, uint32_t offset, uint8_t iterator,\n"
"                   struct tnt_stream *key)\n"
"ssize_t tnt_update(struct tnt_stream *s, uint32_t space, uint32_t index,\n"
"                   struct tnt_stream *key, struct tnt_stream *ops)"
msgstr ""
"ssize_t tnt_insert(struct tnt_stream *s, uint32_t space, struct "
"tnt_stream *tuple)\n"
"ssize_t tnt_replace(struct tnt_stream *s, uint32_t space, struct "
"tnt_stream *tuple)\n"
"ssize_t tnt_select(struct tnt_stream *s, uint32_t space, uint32_t index,\n"
"                   uint32_t limit, uint32_t offset, uint8_t iterator,\n"
"                   struct tnt_stream *key)\n"
"ssize_t tnt_update(struct tnt_stream *s, uint32_t space, uint32_t index,\n"
"                   struct tnt_stream *key, struct tnt_stream *ops)"

#: ../doc/1.10/book/connectors/__c.rst:165
msgid ""
"**GET REPLY:** For most requests, the client will receive a reply "
"containing some indication whether the result was successful, and a set "
"of tuples."
msgstr ""
"**ПОЛУЧЕНИЕ ОТВЕТА:** На большинство запросов клиент получает ответ, "
"который содержит информацию о том, был ли данный запрос успешно выполнен,"
"  а также содержит набор кортежей."

#: ../doc/1.10/book/connectors/__c.rst:168
#, python-format
msgid ""
"struct tnt_reply reply;  tnt_reply_init(&reply);\n"
"tnt->read_reply(tnt, &reply);\n"
"if (reply.code != 0)\n"
"   { printf(\"Insert failed %lu.\\n\", reply.code); }"
msgstr ""
"struct tnt_reply reply;  tnt_reply_init(&reply);\n"
"tnt->read_reply(tnt, &reply);\n"
"if (reply.code != 0)\n"
"   { printf(\"Insert failed %lu.\\n\", reply.code); }"

#: ../doc/1.10/book/connectors/__c.rst:175
msgid "This program checks for success but does not decode the rest of the reply."
msgstr ""
"Данная программа проверяет, был ли запрос выполнен успешно, но никак не "
"интерпретирует оставшуюся часть ответа."

#: ../doc/1.10/book/connectors/__c.rst:179
msgid ""
"struct tnt_reply *tnt_reply_init(struct tnt_reply *r)\n"
"tnt->read_reply(struct tnt_stream *s, struct tnt_reply *r)\n"
"void tnt_reply_free(struct tnt_reply *r)"
msgstr ""
"struct tnt_reply *tnt_reply_init(struct tnt_reply *r)\n"
"tnt->read_reply(struct tnt_stream *s, struct tnt_reply *r)\n"
"void tnt_reply_free(struct tnt_reply *r)"

#: ../doc/1.10/book/connectors/__c.rst:185
msgid ""
"**TEARDOWN:** When a session ends, the connection that was made with "
":c:func:`tarantoolc:tnt_connect()` should be closed, and the objects that"
" were made in the setup should be destroyed."
msgstr ""
"**ЗАВЕРШЕНИЕ:** По окончании сессии нам нужно закрыть соединение, "
"созданное с помощью функции :c:func:`tarantoolc:tnt_connect()`, и удалить"
"  объекты, созданные на этапе настройки."

#: ../doc/1.10/book/connectors/__c.rst:189
msgid ""
"tnt_close(tnt);\n"
"tnt_stream_free(tuple);\n"
"tnt_stream_free(tnt);"
msgstr ""
"tnt_close(tnt);\n"
"tnt_stream_free(tuple);\n"
"tnt_stream_free(tnt);"

#: ../doc/1.10/book/connectors/__c.rst:197
msgid ""
"void tnt_close(struct tnt_stream *s)\n"
"void tnt_stream_free(struct tnt_stream *s)"
msgstr ""
"void tnt_close(struct tnt_stream *s)\n"
"void tnt_stream_free(struct tnt_stream *s)"

#: ../doc/1.10/book/connectors/__c.rst:204
msgid "Example 2"
msgstr "Пример 2"

#: ../doc/1.10/book/connectors/__c.rst:206
msgid ""
"Here is a complete C program that selects, using index key ``[99999]``, "
"from space ``examples`` via the high-level C API. To display the results,"
" the program uses functions in the `MsgPuck "
"<http://rtsisyk.github.io/msgpuck/>`_ library which allow decoding of "
"`MessagePack <https://en.wikipedia.org/wiki/MessagePack>`_  arrays."
msgstr ""
"Далее приводится еще один пример полноценной программы на языке C, "
"которая осуществляет выборку по индекс-ключу ``[99999]`` из спейса "
"``examples`` с помощью высокоуровневого Tarantool API для языка C. Для "
"вывода результатов в этой программе используются функции из библиотеки "
"`MsgPuck <http://rtsisyk.github.io/msgpuck/>`_. Эти функции нужны для "
"декодирования массивов значений в формате `MessagePack "
"<https://en.wikipedia.org/wiki/MessagePack>`_."

#: ../doc/1.10/book/connectors/__c.rst:212
#, python-format
msgid ""
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"\n"
"#define MP_SOURCE 1\n"
"#include <msgpuck.h>\n"
"\n"
"void main() {\n"
"    struct tnt_stream *tnt = tnt_net(NULL);\n"
"    tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"    if (tnt_connect(tnt) < 0) {\n"
"        printf(\"Connection refused\\n\");\n"
"        exit(1);\n"
"    }\n"
"    struct tnt_stream *tuple = tnt_object(NULL);\n"
"    tnt_object_format(tuple, \"[%d]\", 99999); /* tuple = search key */\n"
"    tnt_select(tnt, 999, 0, (2^32) - 1, 0, 0, tuple);\n"
"    tnt_flush(tnt);\n"
"    struct tnt_reply reply; tnt_reply_init(&reply);\n"
"    tnt->read_reply(tnt, &reply);\n"
"    if (reply.code != 0) {\n"
"        printf(\"Select failed.\\n\");\n"
"        exit(1);\n"
"    }\n"
"    char field_type;\n"
"    field_type = mp_typeof(*reply.data);\n"
"    if (field_type != MP_ARRAY) {\n"
"        printf(\"no tuple array\\n\");\n"
"        exit(1);\n"
"    }\n"
"    long unsigned int row_count;\n"
"    uint32_t tuple_count = mp_decode_array(&reply.data);\n"
"    printf(\"tuple count=%u\\n\", tuple_count);\n"
"    unsigned int i, j;\n"
"    for (i = 0; i < tuple_count; ++i) {\n"
"        field_type = mp_typeof(*reply.data);\n"
"        if (field_type != MP_ARRAY) {\n"
"            printf(\"no field array\\n\");\n"
"            exit(1);\n"
"        }\n"
"        uint32_t field_count = mp_decode_array(&reply.data);\n"
"        printf(\"  field count=%u\\n\", field_count);\n"
"        for (j = 0; j < field_count; ++j) {\n"
"            field_type = mp_typeof(*reply.data);\n"
"            if (field_type == MP_UINT) {\n"
"                uint64_t num_value = mp_decode_uint(&reply.data);\n"
"                printf(\"    value=%lu.\\n\", num_value);\n"
"            } else if (field_type == MP_STR) {\n"
"                const char *str_value;\n"
"                uint32_t str_value_length;\n"
"                str_value = mp_decode_str(&reply.data, "
"&str_value_length);\n"
"                printf(\"    value=%.*s.\\n\", str_value_length, "
"str_value);\n"
"            } else {\n"
"                printf(\"wrong field type\\n\");\n"
"                exit(1);\n"
"            }\n"
"        }\n"
"    }\n"
"    tnt_close(tnt);\n"
"    tnt_stream_free(tuple);\n"
"    tnt_stream_free(tnt);\n"
"}"
msgstr ""
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"\n"
"#define MP_SOURCE 1\n"
"#include <msgpuck.h>\n"
"\n"
"void main() {\n"
"    struct tnt_stream *tnt = tnt_net(NULL);\n"
"    tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"    if (tnt_connect(tnt) < 0) {\n"
"        printf(\"Connection refused\\n\");\n"
"        exit(1);\n"
"    }\n"
"    struct tnt_stream *tuple = tnt_object(NULL);\n"
"    tnt_object_format(tuple, \"[%d]\", 99999); /* кортеж tuple = ключ для"
" поиска */\n"
"    tnt_select(tnt, 999, 0, (2^32) - 1, 0, 0, tuple);\n"
"    tnt_flush(tnt);\n"
"    struct tnt_reply reply; tnt_reply_init(&reply);\n"
"    tnt->read_reply(tnt, &reply);\n"
"    if (reply.code != 0) {\n"
"        printf(\"Select failed.\\n\");\n"
"        exit(1);\n"
"    }\n"
"    char field_type;\n"
"    field_type = mp_typeof(*reply.data);\n"
"    if (field_type != MP_ARRAY) {\n"
"        printf(\"no tuple array\\n\");\n"
"        exit(1);\n"
"    }\n"
"    long unsigned int row_count;\n"
"    uint32_t tuple_count = mp_decode_array(&reply.data);\n"
"    printf(\"tuple count=%u\\n\", tuple_count);\n"
"    unsigned int i, j;\n"
"    for (i = 0; i < tuple_count; ++i) {\n"
"        field_type = mp_typeof(*reply.data);\n"
"        if (field_type != MP_ARRAY) {\n"
"            printf(\"no field array\\n\");\n"
"            exit(1);\n"
"        }\n"
"        uint32_t field_count = mp_decode_array(&reply.data);\n"
"        printf(\"  field count=%u\\n\", field_count);\n"
"        for (j = 0; j < field_count; ++j) {\n"
"            field_type = mp_typeof(*reply.data);\n"
"            if (field_type == MP_UINT) {\n"
"                uint64_t num_value = mp_decode_uint(&reply.data);\n"
"                printf(\"    value=%lu.\\n\", num_value);\n"
"            } else if (field_type == MP_STR) {\n"
"                const char *str_value;\n"
"                uint32_t str_value_length;\n"
"                str_value = mp_decode_str(&reply.data, "
"&str_value_length);\n"
"                printf(\"    value=%.*s.\\n\", str_value_length, "
"str_value);\n"
"            } else {\n"
"                printf(\"wrong field type\\n\");\n"
"                exit(1);\n"
"            }\n"
"        }\n"
"    }\n"
"    tnt_close(tnt);\n"
"    tnt_stream_free(tuple);\n"
"    tnt_stream_free(tnt);\n"
"}"

#: ../doc/1.10/book/connectors/__c.rst:279
msgid ""
"Similarly to the first example, paste the code into a file named "
":file:`example2.c`."
msgstr ""
"Аналогично первому примеру, сохраните исходный код программы в файле с "
"именем :file:`example2.c`."

#: ../doc/1.10/book/connectors/__c.rst:284
msgid "$ gcc -o example2 example2.c -ltarantool"
msgstr "$ gcc -o example2 example2.c -ltarantool"

#: ../doc/1.10/book/connectors/__c.rst:288
msgid "To run the program, say :samp:`./example2`."
msgstr "Для запуска программы выполните команду :samp:`./example2`."

#: ../doc/1.10/book/connectors/__c.rst:290
msgid ""
"The two example programs only show a few requests and do not show all "
"that's necessary for good practice. See more in the `tarantool-c "
"documentation at GitHub <http://github.com/tarantool/tarantool-c>`_."
msgstr ""
"В этих двух программах мы привели пример использования лишь двух "
"запросов. Для полноценной работы с Tarantool'ом с помощью C API, "
"пожалуйста, обратитесь к документации из `проекта tarantool-c на GitHub "
"<http://github.com/tarantool/tarantool-c>`_."

#: ../doc/1.10/book/connectors/__results.rst:4
msgid "Interpreting function return values"
msgstr "Интерпретация возвращаемых значений"

#: ../doc/1.10/book/connectors/__results.rst:6
msgid ""
"For all connectors, calling a function via Tarantool causes a return in "
"the MsgPack format. If the function is called using the connector's API, "
"some conversions may occur. All scalar values are returned as tuples "
"(with a MsgPack type-identifier followed by a value); all non-scalar "
"values are returned as a group of tuples (with a MsgPack array-identifier"
" followed by the scalar values). If the function is called via the binary"
" protocol command layer -- \"eval\" -- rather than via the connector's "
"API, no conversions occur."
msgstr ""
"При работе с любым Tarantool-коннектором функции, вызванные с помощью "
"Tarantool'а, возвращают значения в формате MsgPack. Если функция была "
"вызвана через API коннектора, то формат возвращаемых значений будет "
"следующим: скалярные значения возвращаются в виде кортежей (сначала идет "
"идентификатор типа из формата MsgPack, а затем идет значение); все прочие"
"  (не скалярные) значения возвращаются в виде групп кортежей (сначала "
"идет  идентификатор массива в формате MsgPack, а затем идут скалярные "
"значения). Но если функция была вызвана в рамках бинарного протокола (с "
"помощью команды ``eval``), а не через API коннектора, то подобных "
"изменений формата возвращаемых значений не происходит."

#: ../doc/1.10/book/connectors/__results.rst:14
msgid ""
"In the following example, a Lua function will be created. Since it will "
"be accessed externally by a :ref:`'guest' user<box_space-user>`, a "
":ref:`grant <box_schema-user_grant>` of an execute privilege will be "
"necessary. The function returns an empty array, a scalar string, two "
"booleans, and a short integer. The values are the ones described in the "
"table :ref:`Common Types and MsgPack Encodings <msgpack-"
"common_types_and_msgpack_encodings>`."
msgstr ""
"Далее приводится пример создания Lua-функции. Поскольку эту функцию будет"
"  вызывать внешний пользователь :ref:`'guest' user<box_space-user>`, то "
"нужно настроить права на исполнение с помощью :ref:`grant <box_schema-"
"user_grant>`. Эта функция возвращает пустой массив, строку-скаляр, два "
"логических значения и короткое целое число. Значение будут теми же, что "
"описаны в разделе про MsgPack в таблице :ref:`Стандартные типы в "
"MsgPack-кодировке <msgpack-common_types_and_msgpack_encodings>`."

#: ../doc/1.10/book/connectors/__results.rst:21
msgid ""
"tarantool> box.cfg{listen=3301}\n"
"2016-03-03 18:45:52.802 [27381] main/101/interactive I> ready to accept "
"requests\n"
"---\n"
"...\n"
"tarantool> function f() return {},'a',false,true,127; end\n"
"---\n"
"...\n"
"tarantool> box.schema.func.create('f')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('guest','execute','function','f')\n"
"---\n"
"..."
msgstr ""
"tarantool> box.cfg{listen=3301}\n"
"2016-03-03 18:45:52.802 [27381] main/101/interactive I> ready to accept "
"requests\n"
"---\n"
"...\n"
"tarantool> function f() return {},'a',false,true,127; end\n"
"---\n"
"...\n"
"tarantool> box.schema.func.create('f')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('guest','execute','function','f')\n"
"---\n"
"..."

#: ../doc/1.10/book/connectors/__results.rst:37
msgid ""
"Here is a C program which calls the function. Although C is being used "
"for the example, the result would be precisely the same if the calling "
"program was written in Perl, PHP, Python, Go, or Java."
msgstr ""
"Далее идет пример программы на C, из который мы вызываем эту Lua-функцию."
"  Хотя в примере использован код на C, результат будет одинаковым, на "
"каком бы языке ни была написана вызываемая программа: Perl, PHP, Python, "
"Go или Java."

#: ../doc/1.10/book/connectors/__results.rst:41
#, python-format
msgid ""
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"void main() {\n"
"  struct tnt_stream *tnt = tnt_net(NULL);              /* SETUP */\n"
"  tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"   if (tnt_connect(tnt) < 0) {                         /* CONNECT */\n"
"       printf(\"Connection refused\\n\");\n"
"       exit(-1);\n"
"   }\n"
"   struct tnt_stream *arg; arg = tnt_object(NULL);     /* MAKE REQUEST */"
"\n"
"   tnt_object_add_array(arg, 0);\n"
"   struct tnt_request *req1 = tnt_request_call(NULL);  /* CALL function "
"f() */\n"
"   tnt_request_set_funcz(req1, \"f\");\n"
"   uint64_t sync1 = tnt_request_compile(tnt, req1);\n"
"   tnt_flush(tnt);                                     /* SEND REQUEST */"
"\n"
"   struct tnt_reply reply;  tnt_reply_init(&reply);    /* GET REPLY */\n"
"   tnt->read_reply(tnt, &reply);\n"
"   if (reply.code != 0) {\n"
"     printf(\"Call failed %lu.\\n\", reply.code);\n"
"     exit(-1);\n"
"   }\n"
"   const unsigned char *p= (unsigned char*)reply.data; /* PRINT REPLY */\n"
"   while (p < (unsigned char *) reply.data_end)\n"
"   {\n"
"     printf(\"%x \", *p);\n"
"     ++p;\n"
"   }\n"
"   printf(\"\\n\");\n"
"   tnt_close(tnt);                                     /* TEARDOWN */\n"
"   tnt_stream_free(arg);\n"
"   tnt_stream_free(tnt);\n"
"}"
msgstr ""
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"void main() {\n"
"  struct tnt_stream *tnt = tnt_net(NULL);              /* НАСТРОЙКА */\n"
"  tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"   if (tnt_connect(tnt) < 0) {                         /* СОЕДИНЕНИЕ */\n"
"       printf(\"Connection refused\\n\");\n"
"       exit(-1);\n"
"   }\n"
"   struct tnt_stream *arg; arg = tnt_object(NULL);     /* СОЗДАНИЕ "
"ЗАПРОСА */\n"
"   tnt_object_add_array(arg, 0);\n"
"   struct tnt_request *req1 = tnt_request_call(NULL);  /* ВЫЗОВ функции "
"f() */\n"
"   tnt_request_set_funcz(req1, \"f\");\n"
"   uint64_t sync1 = tnt_request_compile(tnt, req1);\n"
"   tnt_flush(tnt);                                     /* ОТПРАВКА "
"ЗАПРОСА */\n"
"   struct tnt_reply reply;  tnt_reply_init(&reply);    /* ПОЛУЧЕНИЕ "
"ОТВЕТА */\n"
"   tnt->read_reply(tnt, &reply);\n"
"   if (reply.code != 0) {\n"
"     printf(\"Call failed %lu.\\n\", reply.code);\n"
"     exit(-1);\n"
"   }\n"
"   const unsigned char *p= (unsigned char*)reply.data; /* ВЫВОД ОТВЕТА */"
"\n"
"   while (p < (unsigned char *) reply.data_end)\n"
"   {\n"
"     printf(\"%x \", *p);\n"
"     ++p;\n"
"   }\n"
"   printf(\"\\n\");\n"
"   tnt_close(tnt);                                     /* ЗАВЕРШЕНИЕ */\n"
"   tnt_stream_free(arg);\n"
"   tnt_stream_free(tnt);\n"
"}"

#: ../doc/1.10/book/connectors/__results.rst:79
msgid "When this program is executed, it will print:"
msgstr "По завершении программа выведет на экран следующие значения:"

#: ../doc/1.10/book/connectors/__results.rst:81
msgid "dd 0 0 0 5 90 91 a1 61 91 c2 91 c3 91 7f"
msgstr "dd 0 0 0 5 90 91 a1 61 91 c2 91 c3 91 7f"

#: ../doc/1.10/book/connectors/__results.rst:85
msgid ""
"The first five bytes -- ``dd 0 0 0 5`` -- are the MsgPack encoding for "
"\"32-bit array header with value 5\" (see `MsgPack specification "
"<http://github.com/msgpack/msgpack/blob/master/spec.md>`_). The rest are "
"as described in the table :ref:`Common Types and MsgPack Encodings "
"<msgpack-common_types_and_msgpack_encodings>`."
msgstr ""
"Первые пять байт -- ``dd 0 0 0 5`` -- это фрагмент данных в формате "
"MsgPack, означающий \"32-битный заголовок массива со значением 5\" (см. "
"`спецификацию на формат MsgPack "
"<http://github.com/msgpack/msgpack/blob/master/spec.md>`_). Остальные "
"значения описаны в таблице :ref:`Стандартные типы в MsgPack-кодировке "
"<msgpack-common_types_and_msgpack_encodings>`."

#: ../doc/1.10/book/faq.rst:39
msgid "FAQ"
msgstr "Вопросы и ответы"

#: ../doc/1.10/book/faq.rst
msgid "Q"
msgstr "В"

#: ../doc/1.10/book/faq.rst:43
msgid "Why Tarantool?"
msgstr "В чем особенности Tarantool'а?"

#: ../doc/1.10/book/faq.rst
msgid "A"
msgstr "О"

#: ../doc/1.10/book/faq.rst:44
msgid ""
"Tarantool is the latest generation of a family of in-memory data servers "
"developed for web applications. It is the result of practical experience "
"and trials within Mail.Ru since development began in 2008."
msgstr ""
"Tarantool -- представитель нового поколения семейства серверов для in-"
"memory базы данных, разработанный для веб-приложений.  Он создан в "
"компании Mail.Ru на основе практического опыта, полученного методом проб "
"и ошибок с начала разработки в 2008 году."

#: ../doc/1.10/book/faq.rst:48
msgid "Why Lua?"
msgstr "Почему Lua?"

#: ../doc/1.10/book/faq.rst:49
msgid ""
"Lua is a lightweight, fast, extensible multi-paradigm language. Lua also "
"happens to be very easy to embed. Lua coroutines relate very closely to "
"Tarantool fibers, and Lua architecture works well with Tarantool "
"internals. Lua acts well as a stored program language for Tarantool, "
"although connecting with other languages is also easy."
msgstr ""
"Lua -- это легкий, быстрый и расширяемый язык, позволяющий использовать "
"различные парадигмы программирования. Lua также легко встраивается в "
"различные приложения. Сопрограммы (coroutines) в Lua близко соотносятся с"
" файберами (fibers) в Tarantool'е, а вся Lua-архитектура гладко ложится "
"на его внутреннюю реализацию. Lua -- это первый язык, на котором можно "
"писать хранимые процедуры для Tarantool'а. В будущем список "
"поддерживаемых языков планируется расширить."

#: ../doc/1.10/book/faq.rst:55
msgid "What's the key advantage of Tarantool?"
msgstr "В чем ключевое преимущество Tarantool'а?"

#: ../doc/1.10/book/faq.rst
msgid ""
"Tarantool provides a rich database feature set (HASH, TREE, RTREE, BITSET"
" indexes, secondary indexes, composite indexes, transactions, triggers, "
"asynchronous replication) in a flexible environment of a Lua interpreter."
msgstr ""
"Tarantool обеспечивает богатый набор функций базы данных (HASH-индексы, "
"TREE-индексы, RTREE-индексы, BITSET-индексы, вторичные индексы, составные"
" индексы, транзакции, триггеры. асинхронная репликация) в гибкой среде "
"Lua-интерпретатора."

#: ../doc/1.10/book/faq.rst
msgid ""
"These two properties make it possible to be a fast, atomic and reliable "
"in-memory data server which handles non-trivial application-specific "
"logic. The advantage over traditional SQL servers is in performance: low-"
"overhead, lock-free architecture means Tarantool can serve an order of "
"magnitude more requests per second, on comparable hardware. The advantage"
" over NoSQL alternatives is in flexibility: Lua allows flexible "
"processing of data stored in a compact, denormalized format."
msgstr ""
"Благодаря этим характеристикам, он представляет собой быстрый и надежный "
"in-memory сервер с легким доступом к базе данных, который обрабатывает "
"нетривиальную проблемно-ориентированную логику. Преимущество по сравнению"
" с традиционными SQL-серверами -- в производительности: архитектура без "
"блокировок с малой перегрузкой означает, что Tarantool может обслуживать "
"на порядок больше запросов в секунду на аналогичном оборудовании. "
"Преимущество NoSQL-аналогов -- в гибкости: Lua допускает гибкую обработку"
" данных, хранимых в компактном денормализированном формате."

#: ../doc/1.10/book/faq.rst:69
msgid "Who is developing Tarantool?"
msgstr "Кто разрабатывает Tarantool?"

#: ../doc/1.10/book/faq.rst:70
msgid ""
"There is an engineering team employed by Mail.Ru -- check out our commit "
"logs on `github.com/tarantool <http://github.com/tarantool/>`_. The "
"development is fully open. Most of the connectors' authors, and the "
"maintainers for different distributions, come from the wider community."
msgstr ""
"Во-первых, этим занимается команда разработки в Mail.Ru -- см. историю "
"коммитов на `github.com/tarantool <http://github.com/tarantool/>`_. Вся "
"разработка ведется открытым образом. Кроме того, активную роль играют "
"члены сообщества разработчиков Tarantool'а. Их силами было создано "
"большинство коннекторов и ведутся доработки под разные дистрибутивы."

#: ../doc/1.10/book/faq.rst:75
msgid "Are there problems associated with being an in-memory server?"
msgstr ""
"Возникают ли проблемы из-за того, что Tarantool является in-memory "
"решением?"

#: ../doc/1.10/book/faq.rst:76
msgid ""
"The principal storage engine (memtx) is designed for RAM plus persistent "
"storage. It is immune to data loss because there is a write-ahead log. "
"Its memory-allocation and compression techniques ensure there is no "
"waste. And if Tarantool runs out of memory, then it will stop accepting "
"updates until more memory is available, but will continue to handle read "
"and delete requests without difficulty. However, for databases which are "
"much larger than the available RAM space, Tarantool has a second storage "
"engine (vinyl) which is only limited by the available disk space."
msgstr ""
"Основной движок баз данных в Tarantool'е работает с оперативной памятью, "
"но при этом он гарантирует сохранность данных благодаря механизму WAL "
"(write ahead log), т.е. журналу упреждающей записи. Также в Tarantool'е "
"используются технологии сжатия и распределения данных, которые позволяют "
"использовать все виды памяти наиболее эффективно. Если Tarantool "
"сталкивается с нехваткой оперативной памяти, то он приостанавливает прием"
" запросов на изменение данных до тех пор, пока не появится свободная "
"память, но при этом с успехом продолжает обработку запросов на чтение и "
"удаление данных. А для больших баз, где объем данных значительно "
"превосходит имеющийся объем оперативной памяти, у Tarantool'а есть второй"
" движок, чьи возможности ограничены лишь размером жесткого диска."

#: ../doc/1.10/book/faq.rst:85
msgid "Can I store (large) BLOBs in Tarantool?"
msgstr "Можно ли хранить (большие) объекты BLOB в Tarantool'е?"

#: ../doc/1.10/book/faq.rst:86
msgid ""
"Starting with Tarantool 1.7, there is no \"hard\" limit for the maximal "
"tuple size. Tarantool, however, is designed for high-velocity workload "
"with a lot of small chunks. For example, when you change an existing "
"tuple, Tarantool creates a new version of the tuple in memory. Thus, an "
"optimal tuple size is within kilobytes."
msgstr ""
"Начиная с Tarantool 1.7, нет \"жесткого\" ограничения на максимальный "
"размер кортежа. Однако Tarantool предназначен для работы с множеством "
"фрагментов на высокой скорости. Например, при изменении существующего "
"кортежа Tarantool создает новую версию кортежа в памяти. Таким образом, "
"оптимальный размер кортежа -- несколько килобайтов."

#: ../doc/1.10/book/faq.rst:93
msgid "I delete data from vinyl, but disk usage stays the same. What gives?"
msgstr ""
"Я удаляю данные из vinyl'а, но использование диска не изменяется. В чем "
"дело?"

#: ../doc/1.10/book/faq.rst:94
msgid ""
"Data you write to vinyl is persisted in append-only run files. These "
"files are immutable, and to perform a delete, a deletion marker "
"(tombstone) is written to a newer run file instead. On compaction, new "
"and old run files are merged, and a new run file is produced. "
"Independently, the checkpoint manager keeps track of all run files "
"involved in a checkpoint, and deletes obsolete files once they are no "
"longer needed."
msgstr ""
"Данные, записываемые в vinyl, сохраняются в исполняемых файлах, "
"обновление которых происходит только путем присоединения новых записей. "
"Такие файлы нельзя изменить, а для удаления маркер удаления (удаленная "
"запись) записывается в новый исполняемый файл. Для уплотнения данных "
"новый и старый исполняемые файлы объединяются, и создается новый "
"исполняемый файл. Независимо от этого, менеджер контрольных точек следит "
"за всеми исполняемыми файлами в контрольной точке и удаляет устаревшие "
"файлы, как только в них отпадает необходимость."

#: ../doc/1.10/book/getting_started/index.rst:39
msgid "Getting started"
msgstr "Руководство для начинающих"

#: ../doc/1.10/book/getting_started/index.rst:41
msgid ""
"In this chapter, we explain how to install Tarantool, how to start it, "
"and how to create a simple database."
msgstr ""
"В этой главе объясняется, как установить и запустить Tarantool, а также "
"как создать простую базу данных."

#: ../doc/1.10/book/getting_started/using_binary.rst:39
msgid "Using a binary package"
msgstr "Использование бинарного пакета"

#: ../doc/1.10/book/getting_started/using_binary.rst:41
msgid ""
"For production purposes, we recommend `official binary packages "
"<http://tarantool.org/download.html>`_. You can choose from two Tarantool"
" versions: ``1.10`` (stable) or ``2.2`` (beta). An automatic build system"
" creates, tests and publishes packages for every push into a "
"corresponding branch (``1.10`` or ``2.2``) at `Tarantool's GitHub "
"repository <https://github.com/tarantool/tarantool>`_."
msgstr ""
"Для промышленной разработки мы рекомендуем использовать `официальные "
"бинарные пакеты <http://tarantool.org/download.html>`_. Можно выбрать "
"одну из двух версий Tarantool’а: ``1.10`` (стабильная) или ``2.2`` "
"(бета). Автоматическая система сборки создает, тестирует и публикует "
"пакеты после  каждого коммита в соответствующую ветку (``1.10`` или "
"``2.2``) `репозитория Tarantool’а на GitHub "
"<https://github.com/tarantool/tarantool>`_."

#: ../doc/1.10/book/getting_started/using_binary.rst:48
msgid ""
"To download and install the package that’s appropriate for your OS, start"
" a shell (terminal) and enter the command-line instructions provided for "
"your OS at Tarantool's `download page "
"<http://tarantool.org/download.html>`_."
msgstr ""
"Чтобы скачать и установить бинарный пакет для вашей операционной системы,"
" откройте командную строку и введите инструкции, которые даны для вашей "
"операционной системы на `странице для скачивания "
"<http://tarantool.org/download.html>`_."

#: ../doc/1.10/book/getting_started/using_binary.rst:54
msgid "Starting Tarantool"
msgstr "Запуск экземпляра Tarantool’а"

#: ../doc/1.10/book/getting_started/using_binary.rst:56
msgid "To start a Tarantool instance, say this:"
msgstr "Для запуска экземпляра Tarantool’а выполните эту команду:"

#: ../doc/1.10/book/getting_started/using_binary.rst:58
msgid ""
"$ # if you downloaded a binary with apt-get or yum, say this:\n"
"$ /usr/bin/tarantool\n"
"$ # if you downloaded and untarred a binary tarball to ~/tarantool, say "
"this:\n"
"$ ~/tarantool/bin/tarantool"
msgstr ""
"$ # если вы скачали бинарный пакет с помощью apt-get или yum, введите:\n"
"$ /usr/bin/tarantool\n"
"$ # если вы скачали бинарный пакет в формате TAR\n"
"$ # и разархивировали его в директорию ~/tarantool, введите:\n"
"$ ~/tarantool/bin/tarantool"

#: ../doc/1.10/book/getting_started/using_binary.rst:65
msgid "Tarantool starts in the interactive mode and displays a prompt:"
msgstr ""
"Tarantool запускается в интерактивном режиме и показывает приглашение "
"командной строки:"

#: ../doc/1.10/book/getting_started/using_binary.rst:67
msgid "tarantool>"
msgstr "tarantool>"

#: ../doc/1.10/book/getting_started/using_binary.rst:71
#: ../doc/1.10/book/getting_started/using_docker.rst:118
msgid "Now you can enter requests on the command line."
msgstr "Теперь вы можете вводить запросы в командной строке."

#: ../doc/1.10/book/getting_started/using_binary.rst:75
#: ../doc/1.10/book/getting_started/using_docker.rst:122
msgid ""
"On production machines, Tarantool's interactive mode is for system "
"administration only. But we use it for most examples in this manual, "
"because the interactive mode is convenient for learning."
msgstr ""
"На боевых серверах интерактивный режим Tarantool’а предназначен только "
"для системных администраторов. Мы же используем его в большинстве "
"примеров в данном руководстве, потому что интерактивный режим хорошо "
"подходит для обучения."

#: ../doc/1.10/book/getting_started/using_binary.rst:81
#: ../doc/1.10/book/getting_started/using_docker.rst:128
msgid "Creating a database"
msgstr "Создание базы данных"

#: ../doc/1.10/book/getting_started/using_binary.rst:83
msgid "Here is how to create a simple test database after installation."
msgstr ""
"Далее объясняется, как создать простую тестовую базу данных после "
"установки Tarantool'а."

#: ../doc/1.10/book/getting_started/using_binary.rst:85
msgid ""
"To let Tarantool store data in a separate place, create a new directory "
"dedicated for tests:"
msgstr ""
"Чтобы Tarantool хранил данные в определенном месте, создайте "
"предназначенную специально для тестов директорию:"

#: ../doc/1.10/book/getting_started/using_binary.rst:88
msgid ""
"$ mkdir ~/tarantool_sandbox\n"
"$ cd ~/tarantool_sandbox"
msgstr ""
"$ mkdir ~/tarantool_sandbox\n"
"$ cd ~/tarantool_sandbox"

#: ../doc/1.10/book/getting_started/using_binary.rst:93
msgid "You can delete the directory when the tests are over."
msgstr "Ее можно удалить после окончания тестирования."

#: ../doc/1.10/book/getting_started/using_binary.rst:95
msgid "Check if the default port the database instance will listen to is vacant."
msgstr ""
"Проверьте доступность порта, используемого по умолчанию для прослушивания"
" на экземпляре базы данных."

#: ../doc/1.10/book/getting_started/using_binary.rst:97
msgid ""
"Depending on the release, during installation Tarantool may start a "
"demonstrative global ``example.lua`` instance that listens to the "
"``3301`` port by default. The ``example.lua`` file showcases basic "
"configuration and can be found in the "
"``/etc/tarantool/instances.enabled`` or "
"``/etc/tarantool/instances.available`` directories."
msgstr ""
"В зависимости от версии, Tarantool может во время установки запустить "
"экземпляр ``example.lua``, который настроен на прослушивание по порту "
"``3301`` по умолчанию. В файле ``example.lua`` показана базовая "
"конфигурация; его можно найти в директории "
"``/etc/tarantool/instances.enabled`` или "
"``/etc/tarantool/instances.available``."

#: ../doc/1.10/book/getting_started/using_binary.rst:103
msgid ""
"However, we encourage you to perform the instance startup manually, so "
"you can learn."
msgstr ""
"Тем не менее, мы предлагаем провести установку самостоятельно с целью "
"обучения. "

#: ../doc/1.10/book/getting_started/using_binary.rst:106
msgid "Make sure the default port is vacant:"
msgstr "Убедитесь, что свободен порт, используемый по умолчанию:"

#: ../doc/1.10/book/getting_started/using_binary.rst:108
msgid "To check if the demonstrative instance is running, say:"
msgstr ""
"Чтобы проверить статус работы демонстрационного экземпляра, выполните "
"команду:"

#: ../doc/1.10/book/getting_started/using_binary.rst:110
msgid ""
"$ lsof -i :3301\n"
"COMMAND    PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME\n"
"tarantool 6851 root   12u  IPv4  40827      0t0  TCP *:3301 (LISTEN)"
msgstr ""
"$ lsof -i :3301\n"
"COMMAND    PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME\n"
"tarantool 6851 root   12u  IPv4  40827      0t0  TCP *:3301 (LISTEN)"

#: ../doc/1.10/book/getting_started/using_binary.rst:116
msgid "If it does, kill the corresponding process. In this example:"
msgstr "Если он запущен, отключите соответствующий процесс. В данном примере:"

#: ../doc/1.10/book/getting_started/using_binary.rst:118
msgid "$ kill 6851"
msgstr "$ kill 6851"

#: ../doc/1.10/book/getting_started/using_binary.rst:122
msgid ""
"To start Tarantool's database module and make the instance accept TCP "
"requests on port ``3301``, say:"
msgstr ""
"Чтобы запустить модуль Tarantool’а для работы с базой данных и сделать "
"так, чтобы запущенный экземпляр принимал TCP-запросы на порту ``3301``, "
"выполните эту команду:"

#: ../doc/1.10/book/getting_started/using_binary.rst:129
msgid "Create the first :ref:`space <index-box_space>` (named ``tester``):"
msgstr "Создайте первый :ref:`спейс <index-box_space>` (с именем ``tester``):"

#: ../doc/1.10/book/getting_started/using_binary.rst:131
msgid "tarantool> s = box.schema.space.create('tester')"
msgstr "tarantool> s = box.schema.space.create('tester')"

#: ../doc/1.10/book/getting_started/using_binary.rst:135
#: ../doc/1.10/book/getting_started/using_docker.rst:138
msgid "Format the created space by specifying field names and types:"
msgstr "Форматируйте созданный спейс, указав имена и типы полей:"

#: ../doc/1.10/book/getting_started/using_binary.rst:137
msgid ""
"tarantool> s:format({\n"
"         > {name = 'id', type = 'unsigned'},\n"
"         > {name = 'band_name', type = 'string'},\n"
"         > {name = 'year', type = 'unsigned'}\n"
"         > })"
msgstr ""
"tarantool> s:format({\n"
"         > {name = 'id', type = 'unsigned'},\n"
"         > {name = 'band_name', type = 'string'},\n"
"         > {name = 'year', type = 'unsigned'}\n"
"         > })"

#: ../doc/1.10/book/getting_started/using_binary.rst:145
#: ../doc/1.10/book/getting_started/using_docker.rst:148
msgid "Create the first :ref:`index <index-box_index>` (named ``primary``):"
msgstr "Создайте первый :ref:`индекс <index-box_index>` (с именем ``primary``):"

#: ../doc/1.10/book/getting_started/using_binary.rst:147
msgid ""
"tarantool> s:create_index('primary', {\n"
"         > type = 'hash',\n"
"         > parts = {'id'}\n"
"         > })"
msgstr ""
"tarantool> s:create_index('primary', {\n"
"         > type = 'hash',\n"
"         > parts = {'id'}\n"
"         > })"

#: ../doc/1.10/book/getting_started/using_binary.rst:154
#: ../doc/1.10/book/getting_started/using_docker.rst:157
msgid "This is a primary index based on the ``id`` field of each tuple."
msgstr "Это первичный индекс по полю ``id`` в каждом кортеже."

#: ../doc/1.10/book/getting_started/using_binary.rst:156
#: ../doc/1.10/book/getting_started/using_docker.rst:159
msgid ""
"Insert three :ref:`tuples <index-box_tuple>` (our name for records) into "
"the space:"
msgstr ""
"Вставьте в созданный спейс три :ref:`кортежа <index-box_tuple>` (наш "
"термин для записей):"

#: ../doc/1.10/book/getting_started/using_binary.rst:159
msgid ""
"tarantool> s:insert{1, 'Roxette', 1986}\n"
"tarantool> s:insert{2, 'Scorpions', 2015}\n"
"tarantool> s:insert{3, 'Ace of Base', 1993}"
msgstr ""
"tarantool> s:insert{1, 'Roxette', 1986}\n"
"tarantool> s:insert{2, 'Scorpions', 2015}\n"
"tarantool> s:insert{3, 'Ace of Base', 1993}"

#: ../doc/1.10/book/getting_started/using_binary.rst:165
#: ../doc/1.10/book/getting_started/using_docker.rst:168
msgid "To select a tuple using the ``primary`` index, say:"
msgstr "Для выборки кортежей по первичному индексу ``primary`` выполните команду:"

#: ../doc/1.10/book/getting_started/using_binary.rst:167
msgid "tarantool> s:select{3}"
msgstr "tarantool> s:select{3}"

#: ../doc/1.10/book/getting_started/using_binary.rst:171
#: ../doc/1.10/book/getting_started/using_docker.rst:174
msgid "The terminal screen now looks like this:"
msgstr "Теперь вывод в окне терминала выглядит следующим образом:"

#: ../doc/1.10/book/getting_started/using_binary.rst:173
msgid ""
"tarantool> s = box.schema.space.create('tester')\n"
"---\n"
"...\n"
"tarantool> s:format({\n"
"         > {name = 'id', type = 'unsigned'},\n"
"         > {name = 'band_name', type = 'string'},\n"
"         > {name = 'year', type = 'unsigned'}\n"
"         > })\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {\n"
"         > type = 'hash',\n"
"         > parts = {'id'}\n"
"         > })\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: unsigned\n"
"    is_nullable: false\n"
"    fieldno: 1\n"
"  id: 0\n"
"  space_id: 512\n"
"  name: primary\n"
"  type: HASH\n"
"...\n"
"tarantool> s:insert{1, 'Roxette', 1986}\n"
"---\n"
"- [1, 'Roxette', 1986]\n"
"...\n"
"tarantool> s:insert{2, 'Scorpions', 2015}\n"
"---\n"
"- [2, 'Scorpions', 2015]\n"
"...\n"
"tarantool> s:insert{3, 'Ace of Base', 1993}\n"
"---\n"
"- [3, 'Ace of Base', 1993]\n"
"...\n"
"tarantool> s:select{3}\n"
"---\n"
"- - [3, 'Ace of Base', 1993]\n"
"..."
msgstr ""
"tarantool> s = box.schema.space.create('tester')\n"
"---\n"
"...\n"
"tarantool> s:format({\n"
"         > {name = 'id', type = 'unsigned'},\n"
"         > {name = 'band_name', type = 'string'},\n"
"         > {name = 'year', type = 'unsigned'}\n"
"         > })\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {\n"
"         > type = 'hash',\n"
"         > parts = {'id'}\n"
"         > })\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: unsigned\n"
"    is_nullable: false\n"
"    fieldno: 1\n"
"  id: 0\n"
"  space_id: 512\n"
"  name: primary\n"
"  type: HASH\n"
"...\n"
"tarantool> s:insert{1, 'Roxette', 1986}\n"
"---\n"
"- [1, 'Roxette', 1986]\n"
"...\n"
"tarantool> s:insert{2, 'Scorpions', 2015}\n"
"---\n"
"- [2, 'Scorpions', 2015]\n"
"...\n"
"tarantool> s:insert{3, 'Ace of Base', 1993}\n"
"---\n"
"- [3, 'Ace of Base', 1993]\n"
"...\n"
"tarantool> s:select{3}\n"
"---\n"
"- - [3, 'Ace of Base', 1993]\n"
"..."

#: ../doc/1.10/book/getting_started/using_binary.rst:217
#: ../doc/1.10/book/getting_started/using_docker.rst:220
msgid "To add a secondary index based on the ``band_name`` field, say:"
msgstr ""
"Для добавления вторичного индекса по полю ``band_name`` используйте эту "
"команду:"

#: ../doc/1.10/book/getting_started/using_binary.rst:219
msgid ""
"tarantool> s:create_index('secondary', {\n"
"         > type = 'hash',\n"
"         > parts = {'band_name'}\n"
"         > })"
msgstr ""
"tarantool> s:create_index('secondary', {\n"
"         > type = 'hash',\n"
"         > parts = {'band_name'}\n"
"         > })"

#: ../doc/1.10/book/getting_started/using_binary.rst:226
#: ../doc/1.10/book/getting_started/using_docker.rst:229
msgid "To select tuples using the ``secondary`` index, say:"
msgstr ""
"Для выборки кортежей по вторичному индексу ``secondary`` выполните "
"команду:"

#: ../doc/1.10/book/getting_started/using_binary.rst:228
msgid ""
"tarantool> s.index.secondary:select{'Scorpions'}\n"
"---\n"
"- - [2, 'Scorpions', 2015]\n"
"..."
msgstr ""
"tarantool> s.index.secondary:select{'Scorpions'}\n"
"---\n"
"- - [2, 'Scorpions', 2015]\n"
"..."

#: ../doc/1.10/book/getting_started/using_binary.rst:235
msgid "Now, to prepare for the example in the next section, try this:"
msgstr ""
"Теперь, чтобы подготовиться к примеру в следующем разделе, попробуйте "
"следующее:"

#: ../doc/1.10/book/getting_started/using_binary.rst:237
msgid ""
"tarantool> box.schema.user.grant('guest', 'read,write,execute', "
"'universe')"
msgstr ""
"tarantool> box.schema.user.grant('guest', 'read,write,execute', "
"'universe')"

#: ../doc/1.10/book/getting_started/using_binary.rst:246
msgid "Connecting remotely"
msgstr "Установка удаленного подключения"

#: ../doc/1.10/book/getting_started/using_binary.rst:248
msgid ""
"In the request ``box.cfg{listen = 3301}`` that we made earlier, the "
"``listen`` value can be any form of a :ref:`URI <index-uri>` (uniform "
"resource identifier). In this case, it’s just a local port: port "
"``3301``. You can send requests to the listen URI via:"
msgstr ""
"В запросе ``box.cfg{listen = 3301}``, который мы отправили ранее, "
"параметр ``listen`` может принимать в качестве значения :ref:`URI <index-"
"uri>` (унифицированный идентификатор ресурса) любой формы. В нашем случае"
" это просто локальный порт ``3301``. Вы можете отправлять запросы на "
"указанный  URI, используя:"

#: ../doc/1.10/book/getting_started/using_binary.rst:253
msgid "``telnet``,"
msgstr "``telnet``,"

#: ../doc/1.10/book/getting_started/using_binary.rst:254
msgid "a :ref:`connector <index-box_connectors>`,"
msgstr ":ref:`коннектор <index-box_connectors>`,"

#: ../doc/1.10/book/getting_started/using_binary.rst:255
msgid ""
"another instance of Tarantool (using the :ref:`console <console-module>` "
"module), or"
msgstr ""
"другой экземпляр Tarantool'а (с помощью модуля :ref:`console <console-"
"module>`), либо"

#: ../doc/1.10/book/getting_started/using_binary.rst:256
msgid ":ref:`tarantoolctl <tarantoolctl>` utility."
msgstr "утилиту :ref:`tarantoolctl <tarantoolctl>`."

#: ../doc/1.10/book/getting_started/using_binary.rst:258
msgid "Let’s try (4)."
msgstr "Давайте попробуем вариант с ``tarantoolctl``."

#: ../doc/1.10/book/getting_started/using_binary.rst:260
msgid ""
"Switch to another terminal. On Linux, for example, this means starting "
"another instance of a Bash shell. You can switch to any working directory"
" in the new terminal, not necessarily to ``~/tarantool_sandbox``."
msgstr ""
"Переключитесь на другой терминал. Например, в Linux-системе для этого "
"нужно запустить еще один экземпляр Bash. В новом терминале можно сменить "
"текущую рабочую директорию на любую другую, необязательно использовать "
"``~/tarantool_sandbox``."

#: ../doc/1.10/book/getting_started/using_binary.rst:264
msgid "Start the ``tarantoolctl`` utility:"
msgstr "Запустите утилиту ``tarantoolctl``:"

#: ../doc/1.10/book/getting_started/using_binary.rst:266
msgid "$ tarantoolctl connect '3301'"
msgstr "$ tarantoolctl connect '3301'"

#: ../doc/1.10/book/getting_started/using_binary.rst:270
msgid ""
"This means \"use ``tarantoolctl connect`` to connect to the Tarantool "
"instance that’s listening on ``localhost:3301``\"."
msgstr ""
"Данная команда означает «использовать утилиту ``tarantoolctl`` для "
"подключения к Tarantool-серверу, который слушает по адресу "
"``localhost:3301``»."

#: ../doc/1.10/book/getting_started/using_binary.rst:273
msgid "Try this request:"
msgstr "Введите следующий запрос:"

#: ../doc/1.10/book/getting_started/using_binary.rst:275
msgid "localhost:3301> box.space.tester:select{2}"
msgstr "localhost:3301> box.space.tester:select{2}"

#: ../doc/1.10/book/getting_started/using_binary.rst:279
msgid ""
"This means \"send a request to that Tarantool instance, and display the "
"result\". The result in this case is one of the tuples that was inserted "
"earlier. Your terminal screen should now look like this:"
msgstr ""
"Это означает \"послать запрос тому Tarantool-серверу и вывести результат "
"на экран\". Результатом в данном случае будет один из кортежей, что вы "
"вставляли ранее. В окне терминала теперь должно отображаться примерно "
"следующее:"

#: ../doc/1.10/book/getting_started/using_binary.rst:283
msgid ""
"$ tarantoolctl connect 3301\n"
"/usr/local/bin/tarantoolctl: connected to localhost:3301\n"
"localhost:3301> box.space.tester:select{2}\n"
"---\n"
"- - [2, 'Scorpions', 2015]\n"
"..."
msgstr ""
"$ tarantoolctl connect 3301\n"
"/usr/local/bin/tarantoolctl: connected to localhost:3301\n"
"localhost:3301> box.space.tester:select{2}\n"
"---\n"
"- - [2, 'Scorpions', 2015]\n"
"..."

#: ../doc/1.10/book/getting_started/using_binary.rst:292
msgid ""
"You can repeat ``box.space...:insert{}`` and ``box.space...:select{}`` "
"indefinitely, on either Tarantool instance."
msgstr ""
"Вы можете посылать запросы ``box.space...:insert{}`` и "
"``box.space...:select{}`` неограниченное количество раз на любом из двух "
"запущенных экземпляров Tarantool’а."

#: ../doc/1.10/book/getting_started/using_binary.rst:295
msgid "When the testing is over:"
msgstr "Закончив тестирование, выполните следующие шаги:"

#: ../doc/1.10/book/getting_started/using_binary.rst:297
msgid "To drop the space: ``s:drop()``"
msgstr "Для удаления спейса: ``s:drop()``"

#: ../doc/1.10/book/getting_started/using_binary.rst:298
msgid "To stop ``tarantoolctl``: Ctrl+C or Ctrl+D"
msgstr "Для остановки ``tarantoolctl``:  ctrl+C или ctrl+D"

#: ../doc/1.10/book/getting_started/using_binary.rst:299
msgid ""
"To stop Tarantool (an alternative): the standard Lua function `os.exit() "
"<http://www.lua.org/manual/5.1/manual.html#pdf-os.exit>`_"
msgstr ""
"Для остановки Tarantool’а (альтернативный вариант): стандартная "
"Lua-функция `os.exit() <http://www.lua.org/manual/5.1/manual.html#pdf- "
"os.exit>`_"

#: ../doc/1.10/book/getting_started/using_binary.rst:301
msgid "To stop Tarantool (from another terminal): ``sudo pkill -f tarantool``"
msgstr ""
"Для остановки Tarantool’а (из другого терминала): ``sudo pkill -f "
"tarantool``"

#: ../doc/1.10/book/getting_started/using_binary.rst:302
msgid "To destroy the test: ``rm -r ~/tarantool_sandbox``"
msgstr "Для удаления директории-песочницы: ``rm -r ~/tarantool_sandbox``"

#: ../doc/1.10/book/getting_started/using_docker.rst:39
msgid "Using a Docker image"
msgstr "Использование Docker-образа"

#: ../doc/1.10/book/getting_started/using_docker.rst:41
msgid ""
"For trial and test purposes, we recommend using `official Tarantool "
"images for Docker <https://github.com/tarantool/docker>`_. An official "
"image contains a particular Tarantool version and all popular external "
"modules for Tarantool. Everything is already installed and configured in "
"Linux. These images are the easiest way to install and use Tarantool."
msgstr ""
"Для практики и тестирования мы рекомендуем использовать `официальные "
"образы Tarantool’а для Docker <https://github.com/tarantool/docker>`_. "
"Официальный образ содержит определенную версию Tarantool’а и все "
"популярные внешние модули для Tarantool’а. Все необходимое уже "
"установлено и настроено на платформе Linux. Данные образы - это самый "
"простой способ установить и запустить Tarantool."

#: ../doc/1.10/book/getting_started/using_docker.rst:50
msgid ""
"If you're new to Docker, we recommend going over `this tutorial "
"<https://docs.docker.com/engine/getstarted/step_one/>`_ before proceeding"
" with this chapter."
msgstr ""
"Если вы никогда раньше не работали с Docker, рекомендуем сперва прочитать"
" `эту обучающую статью "
"<https://docs.docker.com/engine/getstarted/step_one/>`_."

#: ../doc/1.10/book/getting_started/using_docker.rst:58
msgid "Launching a container"
msgstr "Запуск контейнера"

#: ../doc/1.10/book/getting_started/using_docker.rst:60
msgid ""
"If you don't have Docker installed, please follow the official "
"`installation guide "
"<https://docs.docker.com/engine/getstarted/step_one/#/step-1-get-"
"docker>`_ for your OS."
msgstr ""
"Если Docker не установлен на вашей машине, следуйте официальным "
"`инструкциям по установке "
"<https://docs.docker.com/engine/getstarted/step_one/#/step-1-get- "
"docker>`_ для вашей ОС."

#: ../doc/1.10/book/getting_started/using_docker.rst:64
msgid ""
"To start a fully functional Tarantool instance, run a container with "
"minimal options:"
msgstr ""
"Для использования полнофункционального экземпляра Tarantool’а запустите "
"контейнер с минимальными настройками:"

#: ../doc/1.10/book/getting_started/using_docker.rst:67
msgid ""
"$ docker run \\\n"
"  --name mytarantool \\\n"
"  -d -p 3301:3301 \\\n"
"  -v /data/dir/on/host:/var/lib/tarantool \\\n"
"  tarantool/tarantool:1"
msgstr ""
"$ docker run \\\n"
"  --name mytarantool \\\n"
"  -d -p 3301:3301 \\\n"
"  -v /data/dir/on/host:/var/lib/tarantool \\\n"
"  tarantool/tarantool:1"

#: ../doc/1.10/book/getting_started/using_docker.rst:75
msgid ""
"This command runs a new container named ``mytarantool``. Docker starts it"
" from an official image named ``tarantool/tarantool:1``, with Tarantool "
"version ``1.9`` and all external modules already installed."
msgstr ""
"Эта команда запускает новый контейнер с именем ``mytarantool``. Docker "
"запускает его из официального образа ``tarantool/tarantool:1`` с "
"предустановленным Tarantool’ом ``1.9`` и всеми внешними модулями."

#: ../doc/1.10/book/getting_started/using_docker.rst:79
msgid ""
"Tarantool will be accepting incoming connections on ``localhost:3301``. "
"You may start using it as a key-value storage right away."
msgstr ""
"Tarantool будет принимать входящие подключения по адресу "
"``localhost:3301``. Можно сразу начать его использовать как key-value "
"хранилище."

#: ../doc/1.10/book/getting_started/using_docker.rst:82
msgid ""
"Tarantool :ref:`persists data <index-box_persistence>` inside the "
"container. To make your test data available after you stop the container,"
" this command also mounts the host's directory ``/data/dir/on/host`` (you"
" need to specify here an absolute path to an existing local directory) in"
" the container's directory ``/var/lib/tarantool`` (by convention, "
"Tarantool in a container uses this directory to persist data). So, all "
"changes made in the mounted directory on the container's side are applied"
" to the host's disk."
msgstr ""
"Tarantool :ref:`сохраняет данные <index-box_persistence>` внутри "
"контейнера. Чтобы ваше тестовые данные остались доступны после остановки "
"контейнера, эта команда также монтирует директорию ``/data/dir/on/host`` "
"(здесь необходимо указать абсолютный путь до существующей локальной "
"директории), расположенную на машине, в директорию ``/var/lib/tarantool``"
"  (Tarantool традиционно использует эту директорию в контейнере для "
"сохранения данных), расположенную в контейнере. Таким образом все "
"изменения в смонтированной директории, внесенные на стороне контейнера, "
"также отражаются в расположенной на пользовательском диске директории."

#: ../doc/1.10/book/getting_started/using_docker.rst:91
msgid ""
"Tarantool's database module in the container is already :ref:`configured "
"<box_introspection-box_cfg>` and started. You needn't do it manually, "
"unless you use Tarantool as an :ref:`application server <app_server>` and"
" run it with an application."
msgstr ""
"Модуль Tarantool’а для работы с базой данных уже :ref:`настроен "
"<box_introspection-box_cfg>` и запущен в контейнере. Ручная настройка не "
"требуется, если только вы не используете Tarantool как :ref:`сервер "
"приложений <app_server>` и не запускаете его вместе с приложением."

#: ../doc/1.10/book/getting_started/using_docker.rst:98
msgid "Attaching to Tarantool"
msgstr "Подключение к экземпляру Tarantool’а"

#: ../doc/1.10/book/getting_started/using_docker.rst:100
msgid "To attach to Tarantool that runs inside the container, say:"
msgstr ""
"Для подключения к запущенному в контейнере экземпляру Tarantool’а, "
"выполните эту команду:"

#: ../doc/1.10/book/getting_started/using_docker.rst:102
msgid "$ docker exec -i -t mytarantool console"
msgstr "$ docker exec -i -t mytarantool console"

#: ../doc/1.10/book/getting_started/using_docker.rst:106
msgid "This command:"
msgstr "Эта команда:"

#: ../doc/1.10/book/getting_started/using_docker.rst:108
msgid ""
"Instructs Tarantool to open an interactive console port for incoming "
"connections."
msgstr ""
"Требует от Tarantool’а открыть порт с интерактивной консолью для входящих"
"  подключений."

#: ../doc/1.10/book/getting_started/using_docker.rst:109
msgid ""
"Attaches to the Tarantool server inside the container under ``admin`` "
"user via a standard Unix socket."
msgstr ""
"Подключается через стандартный Unix-сокет к Tarantool-серверу, "
"запущенному внутри контейнера, из-под пользователя ``admin``."

#: ../doc/1.10/book/getting_started/using_docker.rst:112
msgid "Tarantool displays a prompt:"
msgstr "Tarantool показывает приглашение командной строки:"

#: ../doc/1.10/book/getting_started/using_docker.rst:114
msgid "tarantool.sock>"
msgstr "tarantool.sock>"

#: ../doc/1.10/book/getting_started/using_docker.rst:130
msgid "While you're attached to the console, let's create a simple test database."
msgstr "Подключившись к консоли, давайте создадим простую тестовую базу данных."

#: ../doc/1.10/book/getting_started/using_docker.rst:132
msgid "First, create the first :ref:`space <index-box_space>` (named ``tester``):"
msgstr ""
"Сначала создайте первый :ref:`спейс <index-box_space>` (с именем "
"``tester``):"

#: ../doc/1.10/book/getting_started/using_docker.rst:134
msgid "tarantool.sock> s = box.schema.space.create('tester')"
msgstr "tarantool.sock> s = box.schema.space.create('tester')"

#: ../doc/1.10/book/getting_started/using_docker.rst:140
msgid ""
"tarantool.sock> s:format({\n"
"              > {name = 'id', type = 'unsigned'},\n"
"              > {name = 'band_name', type = 'string'},\n"
"              > {name = 'year', type = 'unsigned'}\n"
"              > })"
msgstr ""
"tarantool.sock> s:format({\n"
"              > {name = 'id', type = 'unsigned'},\n"
"              > {name = 'band_name', type = 'string'},\n"
"              > {name = 'year', type = 'unsigned'}\n"
"              > })"

#: ../doc/1.10/book/getting_started/using_docker.rst:150
msgid ""
"tarantool.sock> s:create_index('primary', {\n"
"              > type = 'hash',\n"
"              > parts = {'id'}\n"
"              > })"
msgstr ""
"tarantool.sock> s:create_index('primary', {\n"
"              > type = 'hash',\n"
"              > parts = {'id'}\n"
"              > })"

#: ../doc/1.10/book/getting_started/using_docker.rst:162
msgid ""
"tarantool.sock> s:insert{1, 'Roxette', 1986}\n"
"tarantool.sock> s:insert{2, 'Scorpions', 2015}\n"
"tarantool.sock> s:insert{3, 'Ace of Base', 1993}"
msgstr ""
"tarantool.sock> s:insert{1, 'Roxette', 1986}\n"
"tarantool.sock> s:insert{2, 'Scorpions', 2015}\n"
"tarantool.sock> s:insert{3, 'Ace of Base', 1993}"

#: ../doc/1.10/book/getting_started/using_docker.rst:170
msgid "tarantool.sock> s:select{3}"
msgstr "tarantool.sock> s:select{3}"

#: ../doc/1.10/book/getting_started/using_docker.rst:176
msgid ""
"tarantool.sock> s = box.schema.space.create('tester')\n"
"---\n"
"...\n"
"tarantool.sock> s:format({\n"
"              > {name = 'id', type = 'unsigned'},\n"
"              > {name = 'band_name', type = 'string'},\n"
"              > {name = 'year', type = 'unsigned'}\n"
"              > })\n"
"---\n"
"...\n"
"tarantool.sock> s:create_index('primary', {\n"
"              > type = 'hash',\n"
"              > parts = {'id'}\n"
"              > })\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: unsigned\n"
"    is_nullable: false\n"
"    fieldno: 1\n"
"  id: 0\n"
"  space_id: 512\n"
"  name: primary\n"
"  type: HASH\n"
"...\n"
"tarantool.sock> s:insert{1, 'Roxette', 1986}\n"
"---\n"
"- [1, 'Roxette', 1986]\n"
"...\n"
"tarantool.sock> s:insert{2, 'Scorpions', 2015}\n"
"---\n"
"- [2, 'Scorpions', 2015]\n"
"...\n"
"tarantool.sock> s:insert{3, 'Ace of Base', 1993}\n"
"---\n"
"- [3, 'Ace of Base', 1993]\n"
"...\n"
"tarantool.sock> s:select{3}\n"
"---\n"
"- - [3, 'Ace of Base', 1993]\n"
"..."
msgstr ""
"tarantool.sock> s = box.schema.space.create('tester')\n"
"---\n"
"...\n"
"tarantool.sock> s:format({\n"
"              > {name = 'id', type = 'unsigned'},\n"
"              > {name = 'band_name', type = 'string'},\n"
"              > {name = 'year', type = 'unsigned'}\n"
"              > })\n"
"---\n"
"...\n"
"tarantool.sock> s:create_index('primary', {\n"
"              > type = 'hash',\n"
"              > parts = {'id'}\n"
"              > })\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: unsigned\n"
"    is_nullable: false\n"
"    fieldno: 1\n"
"  id: 0\n"
"  space_id: 512\n"
"  name: primary\n"
"  type: HASH\n"
"...\n"
"tarantool.sock> s:insert{1, 'Roxette', 1986}\n"
"---\n"
"- [1, 'Roxette', 1986]\n"
"...\n"
"tarantool.sock> s:insert{2, 'Scorpions', 2015}\n"
"---\n"
"- [2, 'Scorpions', 2015]\n"
"...\n"
"tarantool.sock> s:insert{3, 'Ace of Base', 1993}\n"
"---\n"
"- [3, 'Ace of Base', 1993]\n"
"...\n"
"tarantool.sock> s:select{3}\n"
"---\n"
"- - [3, 'Ace of Base', 1993]\n"
"..."

#: ../doc/1.10/book/getting_started/using_docker.rst:222
msgid ""
"tarantool.sock> s:create_index('secondary', {\n"
"              > type = 'hash',\n"
"              > parts = {'band_name'}\n"
"              > })"
msgstr ""
"tarantool.sock> s:create_index('secondary', {\n"
"              > type = 'hash',\n"
"              > parts = {'band_name'}\n"
"              > })"

#: ../doc/1.10/book/getting_started/using_docker.rst:231
msgid ""
"tarantool.sock> s.index.secondary:select{'Scorpions'}\n"
"---\n"
"- - [2, 'Scorpions', 2015]\n"
"..."
msgstr ""
"tarantool.sock> s.index.secondary:select{'Scorpions'}\n"
"---\n"
"- - [2, 'Scorpions', 2015]\n"
"..."

#: ../doc/1.10/book/getting_started/using_docker.rst:240
msgid "Stopping a container"
msgstr "Остановка контейнера"

#: ../doc/1.10/book/getting_started/using_docker.rst:242
msgid "When the testing is over, stop the container politely:"
msgstr ""
"После завершения тестирования для корректной остановки контейнера "
"выполните эту команду:"

#: ../doc/1.10/book/getting_started/using_docker.rst:244
msgid "$ docker stop mytarantool"
msgstr "$ docker stop mytarantool"

#: ../doc/1.10/book/getting_started/using_docker.rst:248
msgid ""
"This was a temporary container, and its disk/memory data were flushed "
"when you stopped it. But since you mounted a data directory from the host"
" in the container, Tarantool's data files were persisted to the host's "
"disk. Now if you start a new container and mount that data directory in "
"it, Tarantool will recover all data from disk and continue working with "
"the persisted data."
msgstr ""
"Это был временный контейнер, поэтому после остановки содержимое его "
"диска/памяти обнулилось. Но так как вы монтировали локальную директорию в"
"  контейнер, все данные Tarantool’а сохранились на диске вашей машины. "
"Если вы запустите новый контейнер и смонтируете в него ту же директорию с"
"  данными, Tarantool восстановит все данные с диска и продолжит с ними "
"работать."

#: ../doc/1.10/book/index.rst:39
msgid "User's Guide"
msgstr "Руководство пользователя"

#: ../doc/1.10/book/intro.rst:37
msgid "Preface"
msgstr "Предисловие"

#: ../doc/1.10/book/intro.rst:39
msgid ""
"Welcome to Tarantool! This is the User's Guide. We recommend reading it "
"first, and consulting :ref:`Reference <reference>` materials for more "
"detail afterwards, if needed."
msgstr ""
"Добро пожаловать в мир Tarantool! Сейчас вы читаете \"Руководство "
"пользователя\". Мы советуем начинать именно с него, а затем переходить к "
":ref:`\"Справочникам\" <reference>`, если вам понадобятся более подробные"
"  сведения."

#: ../doc/1.10/book/intro.rst:45
msgid "How to read the documentation"
msgstr "Как пользоваться документацией"

#: ../doc/1.10/book/intro.rst:47
msgid ""
"To get started, you can install and launch Tarantool using :ref:`a Docker"
" container <getting_started-using_docker>`, :ref:`a binary package "
"<getting_started-using_binary>`, or the online Tarantool server at "
"http://try.tarantool.org. Either way, as the first tryout, you can follow"
" the introductory exercises from :ref:`Chapter 2 \"Getting started\" "
"<getting_started>`. If you want more hands-on experience, proceed to "
":ref:`Tutorials <tutorials>` after you are through with Chapter 2."
msgstr ""
"Для начала можно установить и запустить Tarantool, используя "
":ref:`Docker-контейнер <getting_started-using_docker>`, :ref:`бинарный "
"пакет <getting_started-using_binary>` или онлайн-сервер Tarantool'а "
"http://try.tarantool.org. В любом случае для пробы можно сделать вводные "
"упражнения из :ref:`главы 2 \"Руководство для начинающих\" "
"<getting_started>`. Если хотите получить практический опыт, переходите к "
":ref:`Практическим заданиям <tutorials>` после работы с главой 2."

#: ../doc/1.10/book/intro.rst:56
msgid ""
":ref:`Chapter 3 \"Database\" <database-chapter>` is about using Tarantool"
" as a NoSQL DBMS, whereas :ref:`Chapter 4 \"Application server\" "
"<app_server>` is about using Tarantool as an application server."
msgstr ""
"В :ref:`главе 3 \"Функциональность СУБД\" <database-chapter>` рассказано "
"о возможностях Tarantool'а как NoSQL СУБД, а в :ref:`главе 4 \"Сервер "
"приложений\" <app_server>` -- о возможностях Tarantool'а как сервера "
"приложений Lua."

#: ../doc/1.10/book/intro.rst:60
msgid ""
":ref:`Chapter 5 \"Server administration\" <admin>` and :ref:`Chapter 6 "
"\"Replication\" <replication>` are primarily for administrators."
msgstr ""
":ref:`Глава 5 \"Администрирование серверной части\" <admin>` и "
":ref:`Глава 6 \"Репликация\" <replication>` предназначены в первую "
"очередь для системных администраторов."

#: ../doc/1.10/book/intro.rst:63
msgid ""
":ref:`Chapter 7 \"Connectors\" <index-box_connectors>` is strictly for "
"users who are connecting from a different language such as C or Perl or "
"Python — other users will find no immediate need for this chapter."
msgstr ""
":ref:`Глава 7 \"Коннекторы\" <index-box_connectors>` актуальна только для"
" тех пользователей, которые хотят устанавливать соединение с Tarantool'ом"
" с помощью программ на других языках программирования (например C, Perl "
"или Python) -- для прочих пользователей эта глава неактуальна."

#: ../doc/1.10/book/intro.rst:67
msgid ""
":ref:`Chapter 8 \"FAQ\" <faq>` gives answers to some frequently asked "
"questions about Tarantool."
msgstr ""
":ref:`Глава 8 \"Вопросы и ответы\" <faq>` содержит ответы на некоторые "
"часто задаваемые вопросы о Tarantool'е."

#: ../doc/1.10/book/intro.rst:70
msgid ""
"For experienced users, there are also :ref:`Reference <reference>` "
"materials, a :ref:`Contributor's Guide <contrib_guide>` and an extensive "
"set of comments in the source code."
msgstr ""
"Опытным же пользователям будут полезны :ref:`\"Справочники\" "
"<reference>`, :ref:`\"Руководство участника проекта\" <contrib_guide>` и "
"комментарии в исходном коде."

#: ../doc/1.10/book/intro.rst:76
msgid "Getting in touch with the Tarantool community"
msgstr "Как связаться с сообществом разработчиков Tarantool'а"

#: ../doc/1.10/book/intro.rst:78
msgid ""
"Please report bugs or make feature requests at "
"http://github.com/tarantool/tarantool/issues."
msgstr ""
"Оставить сообщение о найденных дефектах или сделать запрос на новые "
"функции можно тут: http://github.com/tarantool/tarantool/issues"

#: ../doc/1.10/book/intro.rst:80
msgid ""
"You can contact developers directly in `telegram "
"<http://telegram.me/tarantool>`_ or in a Tarantool discussion group "
"(`English <https://groups.google.com/forum/#!forum/tarantool>`_ or "
"`Russian <https://googlegroups.com/group/tarantool-ru>`_)."
msgstr ""
"Пообщаться напрямую с командой разработки Tarantool'а можно в `telegram "
"<http://telegram.me/tarantool>`_ или на форумах (`англоязычном "
"<https://groups.google.com/forum/#!forum/tarantool>`_ или `русскоязычном "
"<https://googlegroups.com/group/tarantool-ru>`_)."

#: ../doc/1.10/book/intro.rst:87
msgid "Conventions used in this manual"
msgstr "Условные обозначения, используемые в руководстве"

#: ../doc/1.10/book/intro.rst:89
msgid "Square brackets [ and ] enclose optional syntax."
msgstr "В квадратные скобки [ и ] включается синтаксис необязательных элементов."

#: ../doc/1.10/book/intro.rst:91
msgid "Two dots in a row .. mean the preceding tokens may be repeated."
msgstr "Две точки подряд .. означают, что предыдущие токены могут повторяться."

#: ../doc/1.10/book/intro.rst:93
msgid ""
"A vertical bar | means the preceding and following tokens are mutually "
"exclusive alternatives."
msgstr ""
"Вертикальная черта | означает, что предыдущий и последующий токены "
"представляют собой взаимоисключающие альтернативы."

#: ../doc/1.10/book/replication/index.rst:39
#: ../doc/1.10/reference/configuration/index.rst:258
msgid "Replication"
msgstr "Репликация"

#: ../doc/1.10/book/replication/index.rst:41
msgid ""
"Replication allows multiple Tarantool instances to work on copies of the "
"same databases. The databases are kept in sync because each instance can "
"communicate its changes to all the other instances."
msgstr ""
"Механизм репликации позволяет сразу многим экземплярам Tarantool'а "
"работать с копиями одних и тех же баз данных. При этом все базы остаются "
"в синхронизированном состоянии благодаря тому, что каждый экземпляр может"
" сообщать другим экземплярам о совершенных им изменениях."

#: ../doc/1.10/book/replication/repl_add_instances.rst:39
msgid "Adding instances"
msgstr "Добавление экземпляров"

#: ../doc/1.10/book/replication/repl_add_instances.rst:45
msgid "Adding a replica"
msgstr "Добавление реплики"

#: ../doc/1.10/book/replication/repl_add_instances.rst:50
msgid ""
"To add a second **replica** instance to the **master-replica** set from "
"our :ref:`bootstrapping example <replication-master_replica_bootstrap>`, "
"we need an analog of the instance file that we created for the first "
"replica in that set:"
msgstr ""
"Чтобы добавить вторую **реплику** в набор реплик с конфигурацией "
"**мастер-реплика** из нашего :ref:`примера настройки <replication-"
"master_replica_bootstrap>`, необходим аналог файла экземпляра, который мы"
" создали для первой реплики в этом наборе:"

#: ../doc/1.10/book/replication/repl_add_instances.rst:54
msgid ""
"-- instance file for replica #2\n"
"box.cfg{\n"
"  listen = 3301,\n"
"  replication = {'replicator:password@192.168.0.101:3301',  -- master URI"
"\n"
"                 'replicator:password@192.168.0.102:3301',  -- replica #1"
" URI\n"
"                 'replicator:password@192.168.0.103:3301'}, -- replica #2"
" URI\n"
"  read_only = true\n"
"}\n"
"box.once(\"schema\", function()\n"
"   box.schema.user.create('replicator', {password = 'password'})\n"
"   box.schema.user.grant('replicator', 'replication') -- grant "
"replication role\n"
"   box.schema.space.create(\"test\")\n"
"   box.space.test:create_index(\"primary\")\n"
"   print('box.once executed on replica #2')\n"
"end)"
msgstr ""
"-- файл экземпляра для реплики №2\n"
"box.cfg{\n"
"  listen = 3301,\n"
"  replication = {'replicator:password@192.168.0.101:3301',  -- URI "
"мастера\n"
"                 'replicator:password@192.168.0.102:3301',  -- URI "
"реплики №1\n"
"                 'replicator:password@192.168.0.103:3301'}, -- URI "
"реплики №2\n"
"  read_only = true\n"
"}\n"
"box.once(\"schema\", function()\n"
"   box.schema.user.create('replicator', {password = 'password'})\n"
"   box.schema.user.grant('replicator', 'replication') -- предоставить "
"роль для репликации\n"
"   box.schema.space.create(\"test\")\n"
"   box.space.test:create_index(\"primary\")\n"
"   print('box.once executed on replica #2')\n"
"end)"

#: ../doc/1.10/book/replication/repl_add_instances.rst:72
msgid ""
"Here we add the URI of replica #2 to the :ref:`replication "
"<cfg_replication-replication>` parameter, so now it contains three URIs."
msgstr ""
"Здесь мы добавляем URI реплики №2 в параметр :ref:`replication "
"<cfg_replication-replication>`, так что теперь он содержит три URI."

#: ../doc/1.10/book/replication/repl_add_instances.rst:75
msgid ""
"After we launch the new replica instance, it gets connected to the master"
" instance and retrieves the master's write-ahead-log and snapshot files:"
msgstr ""
"После запуска новая реплика подключается к мастер-серверу и получает от "
"него журнал упреждающей записи и файлы снимков:"

#: ../doc/1.10/book/replication/repl_add_instances.rst:78
msgid ""
"$ # launching replica #2\n"
"$ tarantool replica2.lua\n"
"2017-06-14 14:54:33.927 [46945] main/101/replica2.lua C> version "
"1.7.4-52-g980d30092\n"
"2017-06-14 14:54:33.927 [46945] main/101/replica2.lua C> log level 5\n"
"2017-06-14 14:54:33.928 [46945] main/101/replica2.lua I> mapping "
"268435456 bytes for tuple arena...\n"
"2017-06-14 14:54:33.930 [46945] main/104/applier/replicator@192.168.0.10 "
"I> remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 14:54:33.930 [46945] main/104/applier/replicator@192.168.0.10 "
"I> authenticated\n"
"2017-06-14 14:54:33.930 [46945] main/101/replica2.lua I> bootstrapping "
"replica from 192.168.0.101:3301\n"
"2017-06-14 14:54:33.933 [46945] main/104/applier/replicator@192.168.0.10 "
"I> initial data received\n"
"2017-06-14 14:54:33.933 [46945] main/104/applier/replicator@192.168.0.10 "
"I> final data received\n"
"2017-06-14 14:54:33.934 [46945] snapshot/101/main I> saving snapshot "
"`/var/lib/tarantool/replica2/00000000000000000010.snap.inprogress'\n"
"2017-06-14 14:54:33.934 [46945] snapshot/101/main I> done\n"
"2017-06-14 14:54:33.935 [46945] main/101/replica2.lua I> vinyl checkpoint"
" done\n"
"2017-06-14 14:54:33.935 [46945] main/101/replica2.lua I> ready to accept "
"requests\n"
"2017-06-14 14:54:33.935 [46945] main/101/replica2.lua I> set 'read_only' "
"configuration option to true\n"
"2017-06-14 14:54:33.936 [46945] main C> entering the event loop"
msgstr ""
"$ # запуск реплики №2\n"
"$ tarantool replica2.lua\n"
"2017-06-14 14:54:33.927 [46945] main/101/replica2.lua C> version "
"1.7.4-52-g980d30092\n"
"2017-06-14 14:54:33.927 [46945] main/101/replica2.lua C> log level 5\n"
"2017-06-14 14:54:33.928 [46945] main/101/replica2.lua I> mapping "
"268435456 bytes for tuple arena...\n"
"2017-06-14 14:54:33.930 [46945] main/104/applier/replicator@192.168.0.10 "
"I> remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 14:54:33.930 [46945] main/104/applier/replicator@192.168.0.10 "
"I> authenticated\n"
"2017-06-14 14:54:33.930 [46945] main/101/replica2.lua I> bootstrapping "
"replica from 192.168.0.101:3301\n"
"2017-06-14 14:54:33.933 [46945] main/104/applier/replicator@192.168.0.10 "
"I> initial data received\n"
"2017-06-14 14:54:33.933 [46945] main/104/applier/replicator@192.168.0.10 "
"I> final data received\n"
"2017-06-14 14:54:33.934 [46945] snapshot/101/main I> saving snapshot "
"`/var/lib/tarantool/replica2/00000000000000000010.snap.inprogress'\n"
"2017-06-14 14:54:33.934 [46945] snapshot/101/main I> done\n"
"2017-06-14 14:54:33.935 [46945] main/101/replica2.lua I> vinyl checkpoint"
" done\n"
"2017-06-14 14:54:33.935 [46945] main/101/replica2.lua I> ready to accept "
"requests\n"
"2017-06-14 14:54:33.935 [46945] main/101/replica2.lua I> set 'read_only' "
"configuration option to true\n"
"2017-06-14 14:54:33.936 [46945] main C> entering the event loop"

#: ../doc/1.10/book/replication/repl_add_instances.rst:97
msgid ""
"Since we are adding a read-only instance, there is no need to dynamically"
" update the ``replication`` parameter on the other running instances. "
"This update would be required if we :ref:`added a master instance "
"<replication-add_master>`."
msgstr ""
"Поскольку мы добавляем экземпляр только для чтения (read-only), нет "
"необходимости в динамическом обновлении параметра ``replication`` на "
"других работающих экземплярах. Такое обновление необходимо, если бы мы "
":ref:`добавляли мастера <replication-add_master>`."

#: ../doc/1.10/book/replication/repl_add_instances.rst:101
msgid ""
"However, we recommend specifying the URI of replica #3 in all instance "
"files of the replica set. This will keep all the files consistent with "
"each other and with the current replication topology, and so will help to"
" avoid configuration errors in case of further configuration updates and "
"replica set restart."
msgstr ""
"Тем не менее, рекомендуем указать URI реплики №3 во всех файлах "
"экземпляра в наборе реплик. Это поможет сохранить единообразие файлов и "
"согласовать их с текущей топологией репликации, а также не допустить "
"ошибок конфигурации в случае последующего обновления конфигурации и "
"перезапуска набора реплик."

#: ../doc/1.10/book/replication/repl_add_instances.rst:110
msgid "Adding a master"
msgstr "Добавление мастера"

#: ../doc/1.10/book/replication/repl_add_instances.rst:115
msgid ""
"To add a third master instance to the **master-master** set from our "
":ref:`bootstrapping example <replication-master_master_bootstrap>`, we "
"need an analog of the instance files that we created to bootstrap the "
"other master instances in that set:"
msgstr ""
"Чтобы добавить третьего мастера в набор реплик с конфигурацией "
"**мастер-мастер** из нашего :ref:`примера настройки <replication-"
"master_master_bootstrap>`, необходим аналог файлов экземпляров, которые "
"мы создали для настройки других мастеров в этом наборе:"

#: ../doc/1.10/book/replication/repl_add_instances.rst:120
msgid ""
"-- instance file for master #3\n"
"box.cfg{\n"
"  listen      = 3301,\n"
"  replication = {'replicator:password@192.168.0.101:3301',  -- master#1 "
"URI\n"
"                 'replicator:password@192.168.0.102:3301',  -- master#2 "
"URI\n"
"                 'replicator:password@192.168.0.103:3301'}, -- master#3 "
"URI\n"
"  read_only   = true, -- temporarily read-only\n"
"}\n"
"box.once(\"schema\", function()\n"
"   box.schema.user.create('replicator', {password = 'password'})\n"
"   box.schema.user.grant('replicator', 'replication') -- grant "
"\"replication\" role\n"
"   box.schema.space.create(\"test\")\n"
"   box.space.test:create_index(\"primary\")\n"
"end)"
msgstr ""
"-- файл экземпляра для мастера №3\n"
"box.cfg{\n"
"  listen      = 3301,\n"
"  replication = {'replicator:password@192.168.0.101:3301',  -- URI "
"мастера №1\n"
"                 'replicator:password@192.168.0.102:3301',  -- URI "
"мастера №2\n"
"                 'replicator:password@192.168.0.103:3301'}, -- URI "
"мастера №3\n"
"  read_only   = true, -- temporarily read-only\n"
"}\n"
"box.once(\"schema\", function()\n"
"   box.schema.user.create('replicator', {password = 'password'})\n"
"   box.schema.user.grant('replicator', 'replication') -- предоставить "
"роль \"replication\"\n"
"   box.schema.space.create(\"test\")\n"
"   box.space.test:create_index(\"primary\")\n"
"end)"

#: ../doc/1.10/book/replication/repl_add_instances.rst:137
msgid "Here we make the following changes:"
msgstr "Здесь мы вносим следующие изменения:"

#: ../doc/1.10/book/replication/repl_add_instances.rst:139
msgid ""
"Add the URI of master #3 to the :ref:`replication <cfg_replication-"
"replication>` parameter."
msgstr ""
"Добавить URI мастера №3 в параметр :ref:`replication <cfg_replication-"
"replication>`."

#: ../doc/1.10/book/replication/repl_add_instances.rst:141
msgid ""
"Temporarily specify :ref:`read_only=true <cfg_basic-read_only>` to "
"disable data-change operations on the instance. After launch, master #3 "
"will act as a replica until it retrieves all data from the other masters "
"in the replica set."
msgstr ""
"Временно укажите :ref:`read_only=true <cfg_basic-read_only>`, чтобы "
"отключить операции по изменению данных на этом экземпляре. После запуска "
"мастер №3 будет работать в качестве реплики, пока не получит все данные "
"от других мастеров в наборе реплик."

#: ../doc/1.10/book/replication/repl_add_instances.rst:145
msgid ""
"After we launch master #3, it gets connected to the other master "
"instances and retrieves their write-ahead-log and snapshot files:"
msgstr ""
"После запуска мастер №3 подключается к другим мастер-экземплярам и "
"получает от них файлы журнала упреждающей записи и файлы снимков:"

#: ../doc/1.10/book/replication/repl_add_instances.rst:148
msgid ""
"$ # launching master #3\n"
"$ tarantool master3.lua\n"
"2017-06-14 17:10:00.556 [47121] main/101/master3.lua C> version "
"1.7.4-52-g980d30092\n"
"2017-06-14 17:10:00.557 [47121] main/101/master3.lua C> log level 5\n"
"2017-06-14 17:10:00.557 [47121] main/101/master3.lua I> mapping 268435456"
" bytes for tuple arena...\n"
"2017-06-14 17:10:00.559 [47121] iproto/101/main I> binary: bound to "
"[::]:3301\n"
"2017-06-14 17:10:00.559 [47121] main/104/applier/replicator@192.168.0.10 "
"I> remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 17:10:00.559 [47121] main/105/applier/replicator@192.168.0.10 "
"I> remote master is 1.7.4 at 192.168.0.102:3301\n"
"2017-06-14 17:10:00.559 [47121] main/106/applier/replicator@192.168.0.10 "
"I> remote master is 1.7.4 at 192.168.0.103:3301\n"
"2017-06-14 17:10:00.559 [47121] main/105/applier/replicator@192.168.0.10 "
"I> authenticated\n"
"2017-06-14 17:10:00.559 [47121] main/101/master3.lua I> bootstrapping "
"replica from 192.168.0.102:3301\n"
"2017-06-14 17:10:00.562 [47121] main/105/applier/replicator@192.168.0.10 "
"I> initial data received\n"
"2017-06-14 17:10:00.562 [47121] main/105/applier/replicator@192.168.0.10 "
"I> final data received\n"
"2017-06-14 17:10:00.562 [47121] snapshot/101/main I> saving snapshot "
"`/Users/e.shebunyaeva/work/tarantool-test-"
"repl/master3_dir/00000000000000000009.snap.inprogress'\n"
"2017-06-14 17:10:00.562 [47121] snapshot/101/main I> done\n"
"2017-06-14 17:10:00.564 [47121] main/101/master3.lua I> vinyl checkpoint "
"done\n"
"2017-06-14 17:10:00.564 [47121] main/101/master3.lua I> ready to accept "
"requests\n"
"2017-06-14 17:10:00.565 [47121] main/101/master3.lua I> set 'read_only' "
"configuration option to true\n"
"2017-06-14 17:10:00.565 [47121] main C> entering the event loop\n"
"2017-06-14 17:10:00.565 [47121] main/104/applier/replicator@192.168.0.10 "
"I> authenticated"
msgstr ""
"$ # запуск мастера №3\n"
"$ tarantool master3.lua\n"
"2017-06-14 17:10:00.556 [47121] main/101/master3.lua C> version "
"1.7.4-52-g980d30092\n"
"2017-06-14 17:10:00.557 [47121] main/101/master3.lua C> log level 5\n"
"2017-06-14 17:10:00.557 [47121] main/101/master3.lua I> mapping 268435456"
" bytes for tuple arena...\n"
"2017-06-14 17:10:00.559 [47121] iproto/101/main I> binary: bound to "
"[::]:3301\n"
"2017-06-14 17:10:00.559 [47121] main/104/applier/replicator@192.168.0.10 "
"I> remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 17:10:00.559 [47121] main/105/applier/replicator@192.168.0.10 "
"I> remote master is 1.7.4 at 192.168.0.102:3301\n"
"2017-06-14 17:10:00.559 [47121] main/106/applier/replicator@192.168.0.10 "
"I> remote master is 1.7.4 at 192.168.0.103:3301\n"
"2017-06-14 17:10:00.559 [47121] main/105/applier/replicator@192.168.0.10 "
"I> authenticated\n"
"2017-06-14 17:10:00.559 [47121] main/101/master3.lua I> bootstrapping "
"replica from 192.168.0.102:3301\n"
"2017-06-14 17:10:00.562 [47121] main/105/applier/replicator@192.168.0.10 "
"I> initial data received\n"
"2017-06-14 17:10:00.562 [47121] main/105/applier/replicator@192.168.0.10 "
"I> final data received\n"
"2017-06-14 17:10:00.562 [47121] snapshot/101/main I> saving snapshot "
"`/Users/e.shebunyaeva/work/tarantool-test-"
"repl/master3_dir/00000000000000000009.snap.inprogress'\n"
"2017-06-14 17:10:00.562 [47121] snapshot/101/main I> done\n"
"2017-06-14 17:10:00.564 [47121] main/101/master3.lua I> vinyl checkpoint "
"done\n"
"2017-06-14 17:10:00.564 [47121] main/101/master3.lua I> ready to accept "
"requests\n"
"2017-06-14 17:10:00.565 [47121] main/101/master3.lua I> set 'read_only' "
"configuration option to true\n"
"2017-06-14 17:10:00.565 [47121] main C> entering the event loop\n"
"2017-06-14 17:10:00.565 [47121] main/104/applier/replicator@192.168.0.10 "
"I> authenticated"

#: ../doc/1.10/book/replication/repl_add_instances.rst:171
msgid ""
"Next, we add the URI of master #3 to the ``replication`` parameter on the"
" existing two masters. Replication-related parameters are dynamic, so we "
"only need to make a ``box.cfg{}`` request on each of the running "
"instances:"
msgstr ""
"Затем добавляем URI мастера №3 в параметр ``replication`` на существующих"
" мастерах. В конфигурации репликации используются динамические параметры,"
" поэтому необходимо только выполнить запрос ``box.cfg{}`` на каждом "
"работающем экземпляре:"

#: ../doc/1.10/book/replication/repl_add_instances.rst:175
msgid ""
"# adding master #3 URI to replication sources\n"
"tarantool> box.cfg{replication =\n"
"         > {'replicator:password@192.168.0.101:3301',\n"
"         > 'replicator:password@192.168.0.102:3301',\n"
"         > 'replicator:password@192.168.0.103:3301'}}\n"
"---\n"
"..."
msgstr ""
"# добавление URI мастера №3 в источники репликации\n"
"tarantool> box.cfg{replication =\n"
"         > {'replicator:password@192.168.0.101:3301',\n"
"         > 'replicator:password@192.168.0.102:3301',\n"
"         > 'replicator:password@192.168.0.103:3301'}}\n"
"---\n"
"..."

#: ../doc/1.10/book/replication/repl_add_instances.rst:185
msgid ""
"When master #3 catches up with the other masters' state, we can disable "
"read-only mode for this instance:"
msgstr ""
"Когда мастер №3 получает все необходимые изменения от других мастеров, "
"можно отключить режим только для чтения:"

#: ../doc/1.10/book/replication/repl_add_instances.rst:188
msgid ""
"# making master #3 a real master\n"
"tarantool> box.cfg{read_only=false}\n"
"---\n"
"..."
msgstr ""
"# назначение мастера №3 настоящим мастером\n"
"tarantool> box.cfg{read_only=false}\n"
"---\n"
"..."

#: ../doc/1.10/book/replication/repl_add_instances.rst:195
msgid ""
"We also recommend to specify master #3 URI in all instance files in order"
" to keep all the files consistent with each other and with the current "
"replication topology."
msgstr ""
"Также рекомендуется указать URI мастера №3 во всех файлах экземпляра, "
"чтобы сохранить единообразие файлов и согласовать их с текущей топологией"
" репликации."

#: ../doc/1.10/book/replication/repl_add_instances.rst:203
msgid "Orphan status"
msgstr "Статус orphan (одиночный)"

#: ../doc/1.10/book/replication/repl_add_instances.rst:205
msgid ""
"Starting with Tarantool version 1.9, there is a change to the procedure "
"when an instance joins a replica set. During ``box.cfg()`` the instance "
"will try to join all masters listed in :ref:`box.cfg.replication "
"<cfg_replication-replication>`. If the instance does not succeed with at "
"least the number of masters specified in :ref:`replication_connect_quorum"
" <cfg_replication-replication_connect_quorum>`, then it will switch to "
"**orphan status**. While an instance is in orphan status, it is read-"
"only."
msgstr ""
"Начиная с версии Tarantool'а 1.9, процедура подключения реплики к набору "
"реплик изменяется. Во время ``box.cfg()`` экземпляр попытается "
"подключиться ко всем мастерам, указанным в :ref:`box.cfg.replication "
"<cfg_replication-replication>`. Если не было успешно выполнено "
"подключение к количеству мастеров, указанному в "
":ref:`replication_connect_quorum <cfg_replication-"
"replication_connect_quorum>`, экземпляр переходит в **статус orphan** "
"(одиночный). Когда экземпляр находится в статусе orphan, он доступен "
"только для чтения."

#: ../doc/1.10/book/replication/repl_add_instances.rst:215
msgid ""
"To \"join\" a master, a replica instance must \"connect\" to the master "
"node and then \"sync\"."
msgstr ""
"Чтобы \"подключиться\" к мастеру, реплика должна \"установить "
"соединение\" с узлом мастера, а затем \"выполнить синхронизацию\"."

#: ../doc/1.10/book/replication/repl_add_instances.rst:218
msgid ""
"\"Connect\" means contact the master over the physical network and "
"receive acknowledgment. If there is no acknowledgment after "
":ref:`box.replication_connect_timeout <cfg_replication-"
"replication_connect_timeout>` seconds (usually 4 seconds), and retries "
"fail, then the connect step fails."
msgstr ""
"\"Установка соединения\" означает контакт с мастером по физической сети и"
" получение подтверждения. Если нет подтверждения соединения через "
":ref:`box.replication_connect_timeout <cfg_replication-"
"replication_connect_timeout>` секунд (обычно 4 секунды), и повторные "
"попытки подключения не сработали, то соединение не установлено."

#: ../doc/1.10/book/replication/repl_add_instances.rst:223
msgid ""
"\"Sync\" means receive updates from the master in order to make a local "
"database copy. Syncing is complete when the replica has received all the "
"updates, or at least has received enough updates that the replica's lag "
"(see :ref:`replication.upstream.lag <box_info_replication_upstream_lag>` "
"in ``box.info()``) is less than or equal to the number of seconds "
"specified in :ref:`box.cfg.replication_sync_lag <cfg_replication-"
"replication_sync_lag>`. If ``replication_sync_lag`` is unset (nil) or set"
" to TIMEOUT_INFINITY, then the replica skips the \"sync\" state and "
"switches to \"follow\" immediately."
msgstr ""
"\"Синхронизация\" означает получение обновлений от мастера для создания "
"локальной копии базы данных. Синхронизация завершена, когда реплика "
"получила все обновления или хотя бы получила достаточное количество "
"обновлений, чтобы отставание реплики (см. :ref:`replication.upstream.lag "
"<box_info_replication_upstream_lag>` в ``box.info()``) было меньше или "
"равно количеству секунд, указанному в :ref:`box.cfg.replication_sync_lag "
"<cfg_replication-replication_sync_lag>`. Если значение "
"``replication_sync_lag`` не задано (nil) или указано как "
"\"TIMEOUT_INFINITY\", то реплика пропускает шаг \"синхронизация\" и сразу"
" же переходит на \"отслеживание\"."

#: ../doc/1.10/book/replication/repl_add_instances.rst:235
msgid "The following situations are possible."
msgstr "Возможны следующие ситуации."

#: ../doc/1.10/book/replication/repl_add_instances.rst:239
msgid "**Situation 1: bootstrap**"
msgstr "**Ситуация 1: настройка**"

#: ../doc/1.10/book/replication/repl_add_instances.rst:241
msgid ""
"Here ``box.cfg{}`` is being called for the first time. A replica is "
"joining but no replica set exists yet."
msgstr ""
"Здесь впервые происходит вызов ``box.cfg{}``. Реплика подключается, но "
"набора реплик пока нет."

#: ../doc/1.10/book/replication/repl_add_instances.rst:244
msgid "Set status to 'orphan'."
msgstr "Установка статуса 'orphan' (одиночный)."

#: ../doc/1.10/book/replication/repl_add_instances.rst:245
msgid ""
"Try to connect to all nodes from ``box.cfg.replication``, or to the "
"number of nodes required by :ref:`replication_connect_quorum "
"<cfg_replication-replication_connect_quorum>`. Retrying up to 3 times in "
"30 seconds is possible because this is bootstrap, "
":ref:`replication_connect_timeout <cfg_replication-"
"replication_connect_timeout>` is overridden."
msgstr ""
"Попытка установить соединение со всеми узлами из ``box.cfg.replication`` "
"или с количеством узлов, указанным в параметре "
":ref:`replication_connect_quorum <cfg_replication-"
"replication_connect_quorum>`. Допускаются три повторные попытки за 30 "
"секунд, поскольку идет стадия настройки, параметр "
":ref:`replication_connect_timeout <cfg_replication-"
"replication_connect_timeout>` не учитывается."

#: ../doc/1.10/book/replication/repl_add_instances.rst:252
msgid ""
"Abort if not connected to all nodes in ``box.cfg.replication`` or "
":ref:`replication_connect_quorum <cfg_replication-"
"replication_connect_quorum>`."
msgstr ""
"Прекращение работы в случае отсутствия соединения со всеми узлами в "
"``box.cfg.replication`` или :ref:`replication_connect_quorum "
"<cfg_replication-replication_connect_quorum>`."

#: ../doc/1.10/book/replication/repl_add_instances.rst:255
msgid ""
"This instance might be elected as the replica set 'leader'. Criteria for "
"electing a leader include vclock value (largest is best), and whether it "
"is read-only or read-write (read-write is best unless there is no other "
"choice). The leader is the master that other instances must join. The "
"leader is the master that executes :ref:`box_once() <box-once>` "
"functions."
msgstr ""
"Экземпляр может быть выбран в качестве лидера 'leader' в наборе реплик. "
"Критерии выбора лидера включают в себя значение vclock (чем больше, тем "
"лучше), а также доступность только для чтения или для чтения и записи "
"(лучше всего для чтения и записи, кроме случаев, когда других вариантов "
"нет). Лидер является мастером, к которому должны подключиться другие "
"экземпляры. Лидер является мастером, который выполняет функции "
":ref:`box_once() <box-once>`."

#: ../doc/1.10/book/replication/repl_add_instances.rst:261
msgid ""
"If this instance is elected as the replica set leader, then perform an "
"\"automatic bootstrap\":"
msgstr ""
"Если данный экземпляр выбран лидером набора реплик, выполняется "
"\"самонастройка\"."

#: ../doc/1.10/book/replication/repl_add_instances.rst:265
msgid "Set status to 'running'."
msgstr "Установка статуса 'running' (запущен)."

#: ../doc/1.10/book/replication/repl_add_instances.rst:266
msgid "Return from ``box.cfg{}``."
msgstr "Возврат из ``box.cfg{}``."

#: ../doc/1.10/book/replication/repl_add_instances.rst:268
msgid ""
"Otherwise this instance will be a replica joining an existing replica "
"set, so:"
msgstr ""
"В противном случае, данный экземпляр будет репликой, которая подключается"
" к существующему набору реплик, поэтому:"

#: ../doc/1.10/book/replication/repl_add_instances.rst:271
msgid ""
"Bootstrap from the leader. See examples in section :ref:`Bootstrapping a "
"replica set <replication-bootstrap>`."
msgstr ""
"Настройка от лидера. См. примеры в разделе :ref:`Настройка набора реплик "
"<replication-bootstrap>`."

#: ../doc/1.10/book/replication/repl_add_instances.rst:273
msgid "In background, sync with all the other nodes in the replication set."
msgstr "Синхронизация со всеми остальными узлами в наборе реплик в фоновом режиме."

#: ../doc/1.10/book/replication/repl_add_instances.rst:275
msgid "**Situation 2: recovery**"
msgstr "**Ситуация 2: восстановление**"

#: ../doc/1.10/book/replication/repl_add_instances.rst:277
msgid ""
"Here ``box.cfg{}`` is not being called for the first time. It is being "
"called again in order to perform recovery."
msgstr ""
"Здесь вызов ``box.cfg{}`` происходит не впервые, а повторно для "
"осуществления восстановления."

#: ../doc/1.10/book/replication/repl_add_instances.rst:280
msgid ""
"Perform :ref:`recovery <internals-recovery_process>` from the last local "
"snapshot and the WAL files."
msgstr ""
"Проведение :ref:`восстановления <internals-recovery_process>` из "
"последнего локального снимка и WAL-файлов."

#: ../doc/1.10/book/replication/repl_add_instances.rst:283
msgid ""
"Connect to at least :ref:`replication_connect_quorum <cfg_replication-"
"replication_connect_quorum>` nodes."
msgstr ""
"Подключение к количеству узлов, указанному в "
":ref:`replication_connect_quorum <cfg_replication-"
"replication_connect_quorum>`."

#: ../doc/1.10/book/replication/repl_add_instances.rst:287
msgid ""
"Sync with all connected nodes, until the difference is not more than "
":ref:`replication_sync_lag <cfg_replication-replication_sync_lag>` "
"seconds."
msgstr ""
"Синхронизация со всеми подключенными узлами до тех пор, пока отличия не "
"будут более :ref:`replication_sync_lag <cfg_replication-"
"replication_sync_lag>` секунд."

#: ../doc/1.10/book/replication/repl_add_instances.rst:292
msgid "**Situation 3: configuration update**"
msgstr "**Ситуация 3: обновление конфигурации**"

#: ../doc/1.10/book/replication/repl_add_instances.rst:294
msgid ""
"Here ``box.cfg{}`` is not being called for the first time. It is being "
"called again because some replication parameter or something in the "
"replica set has changed."
msgstr ""
"Здесь вызов ``box.cfg{}`` происходит не впервые, а повторно, поскольку "
"изменились некоторые параметры репликации или что-то в наборе реплик."

#: ../doc/1.10/book/replication/repl_add_instances.rst:298
msgid ""
"Try to connect to all nodes from ``box.cfg.replication``, or to the "
"number of nodes required by :ref:`replication_connect_quorum "
"<cfg_replication-replication_connect_quorum>`, within the time period "
"specified in :ref:`replication_connect_timeout <cfg_replication-"
"replication_connect_timeout>`."
msgstr ""
"Попытка установить соединение со всеми узлами из ``box.cfg.replication`` "
"или с количеством узлов, указанным в параметре "
":ref:`replication_connect_quorum <cfg_replication-"
"replication_connect_quorum>` в течение периода времени, указанного в "
":ref:`replication_connect_timeout <cfg_replication-"
"replication_connect_timeout>`."

#: ../doc/1.10/book/replication/repl_add_instances.rst:304
msgid ""
"Try to sync with the connected nodes, within the time period specified in"
" :ref:`replication_sync_timeout <cfg_replication-"
"replication_sync_timeout>`."
msgstr ""
"Попытка синхронизации со всеми подключенными узлами в течение периода "
"времени, указанного в :ref:`replication_sync_timeout <cfg_replication-"
"replication_sync_timeout>`."

#: ../doc/1.10/book/replication/repl_add_instances.rst:308
msgid ""
"If earlier steps fail, change status to 'orphan'. (Attempts to sync will "
"continue in the background and when/if they succeed then 'orphan' status "
"will end.)"
msgstr ""
"Если предыдущие шаги не выполнены, статус изменяется на 'orphan' "
"(одиночный). (Попытки синхронизации будут продолжаться в фоновом режиме, "
"и когда/если они будут успешны, статус 'orphan' отключится.)"

#: ../doc/1.10/book/replication/repl_add_instances.rst:312
msgid ""
"If earlier steps succeed, set status to 'running' (master) or 'follow' "
"(replica)."
msgstr ""
"Если предыдущие шаги выполнены, статус изменяется на 'running' (мастер) "
"или 'follow' (реплика)."

#: ../doc/1.10/book/replication/repl_add_instances.rst:316
msgid "**Situation 4: rebootstrap**"
msgstr "**Ситуация 4: повторная настройка**"

#: ../doc/1.10/book/replication/repl_add_instances.rst:318
msgid ""
"Here ``box.cfg{}`` is not being called. The replica connected "
"successfully at some point in the past, and is now ready for an update "
"from the master. But the master cannot provide an update. This can happen"
" by accident, or more likely can happen because the replica is slow (its "
":ref:`lag <cfg_replication-replication_sync_lag>` is large), and the WAL "
"(.xlog) files containing the updates have been deleted. This is not "
"crippling. The replica can discard what it received earlier, and then ask"
" for the master's latest snapshot (.snap) file contents. Since it is "
"effectively going through the bootstrap process a second time, this is "
"called \"rebootstrapping\". However, there has to be one difference from "
"an ordinary bootstrap -- the replica's :ref:`replica id <replication-"
"replica-id>` will remain the same. If it changed, then the master would "
"think that the replica is a new addition to the cluster, and would "
"maintain a record of an instance ID of a replica that has ceased to "
"exist. Rebootstrapping was introduced in Tarantool version 1.10.2 and is "
"completely automatic."
msgstr ""
"Здесь не происходит вызов ``box.cfg{}``. В определенный момент в прошлом "
"реплика успешно установила соединение и в настоящий момент ожидает "
"обновления от мастера. Однако мастер не может передать обновления, что "
"может произойти случайно, или же если реплика работает слишком медленно "
"(большое значение :ref:`lag <cfg_replication-replication_sync_lag>`), а "
"WAL-файлы (.xlog) с обновлениями были удалены. Такая ситуация не является"
" критической -- реплика может сбросить ранее полученные данные, а затем "
"запросить содержание последнего файла снимка (.snap) мастера. Поскольку "
"фактически в таком случае повторно проводится процесс настройки, это "
"называется \"повторная настройка\". Тем не менее, есть отличие от обычной"
" настройки -- :ref:`идентификатор реплики <replication-replica-id>` "
"останется прежним. Если он изменится, то мастер посчитает, что в кластер "
"добавляется новая реплика, и сохранит идентификатор экземпляра реплики, "
"которой уже не существует. Полностью автоматизированный процесс повторной"
" настройки появился в версии Tarantool'а 1.10.2."

#: ../doc/1.10/book/replication/repl_add_instances.rst:339
msgid "Server startup with replication"
msgstr "Запуск сервера с репликацией"

#: ../doc/1.10/book/replication/repl_add_instances.rst:341
msgid ""
"In addition to the recovery process described in the section "
":ref:`Recovery process <internals-recovery_process>`, the server must "
"take additional steps and precautions if :ref:`replication <replication>`"
" is enabled."
msgstr ""
"Помимо процесса восстановления, описанного в разделе :ref:`Процесс "
"восстановления <internals-recovery_process>`, сервер должен предпринять "
"дополнительные шаги и меры предосторожности, если включена "
":ref:`репликация <replication>`."

#: ../doc/1.10/book/replication/repl_add_instances.rst:345
msgid ""
"Once again the startup procedure is initiated by the ``box.cfg{}`` "
"request. One of the ``box.cfg`` parameters may be :ref:`replication "
"<cfg_replication-replication>` which specifies replication source(-s). We"
" will refer to this replica, which is starting up due to ``box.cfg``, as "
"the \"local\" replica to distinguish it from the other replicas in a "
"replica set, which we will refer to as \"distant\" replicas."
msgstr ""
"И снова процедура запуска начинается с запроса ``box.cfg{}``. Одним из "
"параметров запроса ``box.cfg`` может быть :ref:`replication "
"<cfg_replication-replication>`, в котором указываются источники "
"репликации. Реплику, которая запускается сейчас с помощью ``box.cfg``, мы"
" будем называть локальной, чтобы отличать ее от других реплик в наборе "
"реплик, которые мы будем называть удаленными."

#: ../doc/1.10/book/replication/repl_add_instances.rst:352
msgid ""
"*If there is no snapshot .snap file and the 'replication' parameter is "
"empty*: |br| then the local replica assumes it is an unreplicated "
"\"standalone\" instance, or is the first replica of a new replica set. It"
" will generate new UUIDs for itself and for the replica set. The replica "
"UUID is stored in the ``_cluster`` space; the replica set UUID is stored "
"in the ``_schema`` space. Since a snapshot contains all the data in all "
"the spaces, that means the local replica's snapshot will contain the "
"replica UUID and the replica set UUID. Therefore, when the local replica "
"restarts on later occasions, it will be able to recover these UUIDs when "
"it reads the .snap file."
msgstr ""
"*Если нет файла снимка .snap и не указано значение параметра "
"`replication`*: |br| то локальная реплика предполагает, что является "
"нереплицируемым обособленным экземпляром или же первой репликой в новом "
"наборе реплик. Она сгенерирует новые UUID для себя и для набора реплик. "
"UUID реплики хранится в спейсе ``_cluster``; UUID набора реплик хранится "
"в спейсе ``_schema``. Поскольку снимок содержит все данные во всех "
"спейсах, это означает, что снимок локальной реплики будет содержать UUID "
"реплики и UUID набора реплик. Таким образом, когда локальная реплика "
"будет позднее перезапускаться, она сможет восстановить эти UUID после "
"прочтения файла снимка .snap."

#: ../doc/1.10/book/replication/repl_add_instances.rst:362
msgid ""
"*If there is no snapshot .snap file and the 'replication' parameter is "
"not empty and the '_cluster' space contains no other replica UUIDs*: |br|"
" then the local replica assumes it is not a standalone instance, but is "
"not yet part of a replica set. It must now join the replica set. It will "
"send its replica UUID to the first distant replica which is listed in "
"``replication`` and which will act as a master. This is called the \"join"
" request\". When a distant replica receives a join request, it will send "
"back:"
msgstr ""
"*Если нет файла снимка .snap, указано значение параметра `replication`, а"
" в спейсе `_cluster` отсутствуют UUID других реплик*: |br| то локальная "
"реплика предполагает, что не является обособленным экземпляром, но еще не"
" входит в набор реплик. Сейчас она должна быть подключиться в набор "
"реплик. Она отправит свой UUID реплики первой удаленной реплике, "
"указанной в параметре ``replication``, которая будет выступать в качестве"
" мастера. Это называется \"запрос на подключение\". Когда удаленная "
"реплика получает запрос на подключение, она отправляет в ответ:"

#: ../doc/1.10/book/replication/repl_add_instances.rst:370
msgid "the distant replica's replica set UUID,"
msgstr "UUID набора реплик, в который входит удаленная реплика"

#: ../doc/1.10/book/replication/repl_add_instances.rst:371
msgid ""
"the contents of the distant replica's .snap file. |br| When the local "
"replica receives this information, it puts the replica set UUID in its "
"``_schema`` space, puts the distant replica's UUID and connection "
"information in its ``_cluster`` space, and makes a snapshot containing "
"all the data sent by the distant replica. Then, if the local replica has "
"data in its WAL .xlog files, it sends that data to the distant replica. "
"The distant replica will receive this and update its own copy of the "
"data, and add the local replica's UUID to its ``_cluster`` space."
msgstr ""
"содержимое файла снимка .snap удаленной реплики. |br| Когда локальная "
"реплика получает эту информацию, она размещает UUID набора реплики в "
"своем спейсе ``_schema``, UUID удаленной реплики и информацию о "
"подключении в своем спейсе ``_cluster``, а затем создает снимок, который "
"содержит все данные, отправленные удаленной репликой. Затем, если в "
"WAL-файлах .xlog локальной реплики содержатся данные, они отправляются на"
" удаленную реплику. Удаленная реплика получается данные и обновляет свою "
"копию данных, а затем добавляет UUID локальной реплики в свой спейс "
"``_cluster``."

#: ../doc/1.10/book/replication/repl_add_instances.rst:380
msgid ""
"*If there is no snapshot .snap file and the 'replication' parameter is "
"not empty and the ``_cluster`` space contains other replica UUIDs*: |br| "
"then the local replica assumes it is not a standalone instance, and is "
"already part of a replica set. It will send its replica UUID and replica "
"set UUID to all the distant replicas which are listed in ``replication``."
" This is called the \"on-connect handshake\". When a distant replica "
"receives an on-connect handshake: |br|"
msgstr ""
"*Если нет файла снимка .snap, указано значение параметра `replication`, а"
" в спейсе ``_cluster`` есть UUID других реплик*: |br| то локальная "
"реплика предполагает, что не является обособленным экземпляром, и уже "
"входит в набор реплик. Она отправит свой UUID реплики и UUID набора "
"реплик всем удаленным репликам, указанным в параметре ``replication``. "
"Это называется \"подтверждение связи при подключении\". Когда удаленная "
"реплика получает подтверждение связи при подключении: |br|"

#: ../doc/1.10/book/replication/repl_add_instances.rst:387
msgid ""
"the distant replica compares its own copy of the replica set UUID to the "
"one in the on-connect handshake. If there is no match, then the handshake"
" fails and the local replica will display an error."
msgstr ""
"удаленная реплика сопоставляет свою версию UUID набора реплик с UUID, "
"переданным в ходе подтверждения связи при подключении. Если они не "
"совпадают, связь не устанавливается, и локальная реплика отобразит "
"ошибку."

#: ../doc/1.10/book/replication/repl_add_instances.rst:390
msgid ""
"the distant replica looks for a record of the connecting instance in its "
"``_cluster`` space. If there is none, then the handshake fails. |br| "
"Otherwise the handshake is successful. The distant replica will read any "
"new information from its own .snap and .xlog files, and send the new "
"requests to the local replica."
msgstr ""
"удаленная реплика ищет запись о подключающемся экземпляре в своем спейсе "
"``_cluster``. Если такой записи нет, связь не устанавливается. |br| Если "
"есть, связь подтверждается. Удаленная реплика выполняет чтение любой "
"новой информации из своих файлов .snap и .xlog и отправляет новые запросы"
" на локальную реплику."

#: ../doc/1.10/book/replication/repl_add_instances.rst:396
msgid ""
"In the end, the local replica knows what replica set it belongs to, the "
"distant replica knows that the local replica is a member of the replica "
"set, and both replicas have the same database contents."
msgstr ""
"Наконец, локальная реплика понимает, к какому набору реплик относится, "
"удаленная реплика понимает, что локальная реплика входит в набор реплик, "
"и у двух реплик одинаковое содержимое базы данных."

#: ../doc/1.10/book/replication/repl_add_instances.rst:402
msgid ""
"*If there is a snapshot file and replication source is not empty*: |br| "
"first the local replica goes through the recovery process described in "
"the previous section, using its own .snap and .xlog files. Then it sends "
"a \"subscribe\" request to all the other replicas of the replica set. The"
" subscribe request contains the server vector clock. The vector clock has"
" a collection of pairs 'server id, lsn' for every replica in the "
"``_cluster`` system space. Each distant replica, upon receiving a "
"subscribe request, will read its .xlog files' requests and send them to "
"the local replica if (lsn of .xlog file request) is greater than (lsn of "
"the vector clock in the subscribe request). After all the other replicas "
"of the replica set have responded to the local replica's subscribe "
"request, the replica startup is complete."
msgstr ""
"*Если есть файл снимка и указан источник репликации*: |br| сначала "
"локальная реплика проходит процесс восстановления, описанный в предыдущем"
" разделе, используя свои собственные файлы .snap и .xlog. Затем она "
"отправляет запрос подписки всем репликам в наборе реплик. Запрос подписки"
" содержит векторные часы сервера. Векторные часы включают набор пар "
"'идентификатор сервера, LSN' для каждой реплики в системном спейсе "
"``_cluster``. Каждая удаленная реплика, получив запрос подписки, "
"выполняет чтение запросов из файла .xlog и отправляет их на локальную "
"реплику, если LSN из запроса файла .xlog больше, чем LSN векторных часов "
"из запроса подписки. После того, как все реплики из набора реплик "
"отправили ответ на запрос подписки локальной реплики, запуск реплики "
"завершен."

#: ../doc/1.10/book/replication/repl_add_instances.rst:414
msgid ""
"The following temporary limitations applied for Tarantool versions "
"earlier than 1.7.7:"
msgstr ""
"Следующие временные ограничения применимы к версиям Tarantool'а ниже "
"1.7.7:"

#: ../doc/1.10/book/replication/repl_add_instances.rst:417
msgid ""
"The URIs in the ``replication`` parameter should all be in the same order"
" on all replicas. This is not mandatory but is an aid to consistency."
msgstr ""
"URI в параметре ``replication`` должны быть указаны в одинаковом порядке "
"на всех репликах. Это необязательно, но помогает соблюдать "
"консистентность."

#: ../doc/1.10/book/replication/repl_add_instances.rst:419
msgid ""
"The replicas of a replica set should be started up at slightly different "
"times. This is not mandatory but prevents a situation where each replica "
"is waiting for the other replica to be ready."
msgstr ""
"Реплики в наборе реплик должны запускаться не одновременно. Это "
"необязательно, но помогает избежать ситуации, когда все реплики ждут "
"готовности друг друга."

#: ../doc/1.10/book/replication/repl_add_instances.rst:423
msgid "The following limitation still applies for the current Tarantool version:"
msgstr "Следующее ограничение всё еще применимо к текущей версии Tarantool'а:"

#: ../doc/1.10/book/replication/repl_add_instances.rst:425
msgid ""
"The maximum number of entries in the ``_cluster`` space is :ref:`32 "
"<limitations_replicas>`. Tuples for out-of-date replicas are not "
"automatically re-used, so if this 32-replica limit is reached, users may "
"have to reorganize the ``_cluster`` space manually."
msgstr ""
"Максимальное количество записей в спейсе ``_cluster`` -- :ref:`32 "
"<limitations_replicas>`. Кортежи для устаревших реплик не "
"переиспользуются автоматически, поэтому по достижении предела в 32 "
"реплики, может понадобиться реорганизация спейса ``_cluster`` вручную."

#: ../doc/1.10/book/replication/repl_architecture.rst:39
msgid "Replication architecture"
msgstr "Архитектура механизма репликации"

#: ../doc/1.10/book/replication/repl_architecture.rst:45
msgid "Replication mechanism"
msgstr "Механизм репликации"

#: ../doc/1.10/book/replication/repl_architecture.rst:47
msgid ""
"A pack of instances which operate on copies of the same databases make up"
" a **replica set**. Each instance in a replica set has a role, **master**"
" or **replica**."
msgstr ""
"Набор экземпляров, которые работают на копиях одной базы данных, "
"составляют **набор реплик**. У каждого экземпляра в наборе реплик есть "
"роль: **мастер** или **реплика**."

#: ../doc/1.10/book/replication/repl_architecture.rst:51
msgid ""
"A replica gets all updates from the master by continuously fetching and "
"applying its :ref:`write ahead log (WAL)<internals-wal>`. Each record in "
"the WAL represents a single Tarantool data-change request such as "
":ref:`INSERT<box_space-insert>`, :ref:`UPDATE<box_space-update>` or "
":ref:`DELETE<box_space-delete>`, and is assigned a monotonically growing "
"log sequence number (**LSN**). In essence, Tarantool replication is "
"**row-based**: each data-change request is fully deterministic and "
"operates on a single :ref:`tuple<index-box_tuple>`. However, unlike a "
"classical row-based log, which contains entire copies of the changed "
"rows, Tarantool's WAL contains copies of the requests. For example, for "
"UPDATE requests, Tarantool only stores the primary key of the row and the"
" update operations, to save space."
msgstr ""
"Реплика получает все обновления от мастера, постоянно запрашивая и "
"применяя данные :ref:`журнала упреждающей записи (WAL)<internals-wal>`. "
"Каждая запись в WAL представляет собой отдельный запрос на изменение "
"данных в Tarantool’е, например, :ref:`INSERT<box_space-insert>`, "
":ref:`UPDATE<box_space-update>` или :ref:`DELETE<box_space-delete>`. "
"Такой записи присваивается монотонно возрастающее число, представляющее "
"регистрационный номер в журнале (**LSN**). По сути, репликация в "
"Tarantool’е является **построчной**: каждая команда на изменение данных "
"полностью детерминирована и относится к отдельному :ref:`кортежу<index-"
"box_tuple>`. Однако в отличие от типичного построчного журнала, который "
"содержит копии измененных строк полностью, WAL в Tarantool'е включает в "
"себя копии запросов. Например, для запросов типа UPDATE (обновление) "
"Tarantool сохранит только первичный ключ строки и операции обновления для"
" экономии места."

#: ../doc/1.10/book/replication/repl_architecture.rst:62
msgid ""
"Invocations of **stored programs** are not written to the WAL. Instead, "
"records of the actual **data-change requests, performed by the Lua "
"code**, are written to the WAL. This ensures that possible non-"
"determinism of Lua does not cause replication to go out of sync."
msgstr ""
"Вызовы **хранимых процедур** не регистрируются в журнале упреждающей "
"записи. Между тем, события по запросам **изменения фактических данных, "
"которые выполняют Lua-скрипты**, регистрируются в журнале. Таким образом,"
" возможное недетерминированное выполнение Lua гарантированно не приведет "
"к рассинхронизации."

#: ../doc/1.10/book/replication/repl_architecture.rst:67
msgid ""
"Data definition operations on **temporary spaces**, such as "
"creating/dropping, adding indexes, truncating, etc., are written to the "
"WAL, since information about temporary spaces is stored in non-temporary "
"system spaces, such as :ref:`box.space._space <box_space-space>`. Data "
"change operations on temporary spaces are not written to the WAL and are "
"not replicated."
msgstr ""
"Операции по определению данных во **временных спейсах**, такие как "
"создание/удаление, добавление индексов, усечение и т.д., регистрируются в"
" журнале, поскольку информация о временных спейсах хранится в постоянных "
"системных спейсах, например :ref:`box.space._space <box_space-space>`. "
"Операции по изменению данных во временных спейсах не регистрируются в "
"журнале и не реплицируются."

#: ../doc/1.10/book/replication/repl_architecture.rst:75
msgid ""
"Data change operations on **replication-local** spaces (spaces "
":ref:`created <box_schema-space_create>` with ``is_local`` = true) are "
"written to the WAL but are not replicated."
msgstr ""
"Операции по изменению данных в спейсах с **локальной репликацией** "
"(спейсах, :ref:`созданных <box_schema-space_create>` с параметром "
"``is_local`` = true) не регистрируются в журнале и не реплицируются."

#: ../doc/1.10/book/replication/repl_architecture.rst:79
msgid ""
"To create a valid initial state, to which WAL changes can be applied, "
"every instance of a replica set requires a start set of :ref:`checkpoint "
"files <index-box_persistence>`, such as .snap files for memtx and .run "
"files for vinyl. A replica joining an existing replica set, chooses an "
"existing master and automatically downloads the initial state from it. "
"This is called an **initial join**."
msgstr ""
"Чтобы создать подходящее начальное состояние, к которому можно применить "
"изменения из WAL-файла, для каждого экземпляра из набора реплик должен "
"быть исходный набор :ref:`файлов контрольной точки <index-"
"box_persistence>` -- .snap-файлы для memtx и .run-файлы для vinyl. Когда "
"реплика включается в существующий набор реплик, она выбирает "
"существующего мастера и автоматически загружает с него начальное "
"состояние. Это называется **начальным включением**."

#: ../doc/1.10/book/replication/repl_architecture.rst:86
msgid ""
"When an entire replica set is bootstrapped for the first time, there is "
"no master which could provide the initial checkpoint. In such a case, "
"replicas connect to each other and elect a master, which then creates the"
" starting set of checkpoint files, and distributes it to all the other "
"replicas. This is called an **automatic bootstrap** of a replica set."
msgstr ""
"При первой настройке целого набора реплик нет мастера, который "
"предоставил бы начальную контрольную точку. В таком случае реплики "
"подключаются друг к другу и выбирают мастера, который затем создает "
"начальный набор файлов контрольной точки и отправляет его всем репликам. "
"Это называется **самонастройкой** набора реплик."

#: ../doc/1.10/book/replication/repl_architecture.rst:92
msgid ""
"When a replica contacts a master (there can be many masters) for the "
"first time, it becomes part of a replica set. On subsequent occasions, it"
" should always contact a master in the same replica set. Once connected "
"to the master, the replica requests all changes that happened after the "
"latest local LSN (there can be many LSNs -- each master has its own LSN)."
msgstr ""
"Когда реплика впервые подключается к мастеру (может быть много мастеров),"
" она становится частью набора реплик. В последующих случаях она всегда "
"должна подключаться к мастеру в этом наборе реплик. После подключения к "
"мастеру реплика запрашивает все изменения, произошедшие с момента "
"последнего локального LSN (может быть много LSN -- у каждого мастера свой"
" LSN)."

#: ../doc/1.10/book/replication/repl_architecture.rst:98
msgid ""
"Each replica set is identified by a globally unique identifier, called "
"the **replica set UUID**. The identifier is created by the master which "
"creates the very first checkpoint, and is part of the checkpoint file. It"
" is stored in system space :ref:`box.space._schema <box_space-schema>`. "
"For example:"
msgstr ""
"Каждый набор реплик можно определить по глобально-уникальному "
"идентификатору, который называется **UUID набора реплик**. Идентификатор "
"создается мастером во время создания самой первой контрольной точки и "
"является частью файла контрольной точки. Он хранится в системном спейсе "
":ref:`box.space._schema <box_space-schema>`. Пример:"

#: ../doc/1.10/book/replication/repl_architecture.rst:103
msgid ""
"tarantool> box.space._schema:select{'cluster'}\n"
"---\n"
"- - ['cluster', '6308acb9-9788-42fa-8101-2e0cb9d3c9a0']\n"
"..."
msgstr ""
"tarantool> box.space._schema:select{'cluster'}\n"
"---\n"
"- - ['cluster', '6308acb9-9788-42fa-8101-2e0cb9d3c9a0']\n"
"..."

#: ../doc/1.10/book/replication/repl_architecture.rst:112
msgid ""
"Additionally, each instance in a replica set is assigned its own UUID, "
"when it joins the replica set. It is called an **instance UUID** and is a"
" globally unique identifier. The instance UUID is checked to ensure that "
"instances do not join a different replica set, e.g. because of a "
"configuration error. A unique instance identifier is also necessary to "
"apply rows originating from different masters only once, that is, to "
"implement multi-master replication. This is why each row in the write "
"ahead log, in addition to its log sequence number, stores the instance "
"identifier of the instance on which it was created. But using a UUID as "
"such an identifier would take too much space in the write ahead log, thus"
" a shorter integer number is assigned to the instance when it joins a "
"replica set. This number is then used to refer to the instance in the "
"write ahead log. It is called **instance id**. All identifiers are stored"
" in system space :ref:`box.space._cluster <box_space-cluster>`. For "
"example:"
msgstr ""
"Кроме того, каждому экземпляру в наборе реплик присваивается свой UUID, "
"когда он включается в набор реплик. Такой глобально-уникальный "
"идентификатор называется *UUID экземпляра**. UUID экземпляра проверяется,"
" чтобы экземпляры не подключались к различным наборам реплик, например, "
"из-за ошибки конфигурации. Уникальный идентификатор экземпляра также "
"необходим для однократного применения строк от разных мастеров, то есть "
"для многомастерной репликации. Вот почему каждая строка в журнале "
"упреждающей записи, помимо номер записи в журнале, хранит идентификатор "
"экземпляра, где запись была создана. Но использование UUID в качестве "
"такого идентификатора заняло бы слишком много места в журнале упреждающей"
" записи, поэтому экземпляру присваивается целое число при включении в "
"набор реплик. Это число, которое называется **ID экземпляра**, затем "
"используется для ссылок на экземпляр в журнале упреждающей записи. Все "
"идентификаторы хранятся в системном спейсе :ref:`box.space._cluster "
"<box_space-cluster>`. Например:"

#: ../doc/1.10/book/replication/repl_architecture.rst:133
msgid ""
"Here the instance ID is ``1`` (unique within the replica set), and the "
"instance UUID is ``88580b5c-4474-43ab-bd2b-2409a9af80d2`` (globally "
"unique)."
msgstr ""
"Здесь ID экземпляра -- ``1`` (уникальный номер в рамках набора реплик), а"
" UUID экземпляра -- ``88580b5c-4474-43ab-bd2b-2409a9af80d2`` (глобально "
"уникальный)."

#: ../doc/1.10/book/replication/repl_architecture.rst:136
msgid ""
"Using instance IDs is also handy for tracking the state of the entire "
"replica set. For example, :ref:`box.info.vclock <box_introspection-"
"box_info>` describes the state of replication in regard to each connected"
" peer."
msgstr ""
"Использование идентификаторов экземпляра также полезно для отслеживания "
"состояния всего набора реплик. Например, :ref:`box.info.vclock "
"<box_introspection-box_info>` описывает состояние репликации в отношении "
"каждого подключенного узла."

#: ../doc/1.10/book/replication/repl_architecture.rst:140
msgid ""
"tarantool> box.info.vclock\n"
"---\n"
"- {1: 827, 2: 584}\n"
"..."
msgstr ""
"tarantool> box.info.vclock\n"
"---\n"
"- {1: 827, 2: 584}\n"
"..."

#: ../doc/1.10/book/replication/repl_architecture.rst:147
msgid ""
"Here ``vclock`` contains log sequence numbers (827 and 584) for instances"
" with instance IDs 1 and 2."
msgstr ""
"Здесь ``vclock`` содержит номера записей в журнале (827 и 584) для "
"экземпляров с идентификаторами экземпляра 1 и 2."

#: ../doc/1.10/book/replication/repl_architecture.rst:150
msgid ""
"Starting in Tarantool 1.7.7, it is possible for administrators to assign "
"the instance UUID and the replica set UUID values, rather than let the "
"system generate them -- see the description of the :ref:`replicaset_uuid "
"<cfg_replication-replicaset_uuid>` configuration parameter."
msgstr ""
"Начиная с Tarantool 1.7.7, появилась возможность для администраторов "
"назначать UUID экземпляра и UUID набора реплик вместо сгенерированных "
"системой значений -- см. описание конфигурационного параметра "
":ref:`replicaset_uuid <cfg_replication-replicaset_uuid>`."

#: ../doc/1.10/book/replication/repl_architecture.rst:159
msgid "Replication setup"
msgstr "Настройка репликации"

#: ../doc/1.10/book/replication/repl_architecture.rst:161
msgid ""
"To enable replication, you need to specify two parameters in a "
"``box.cfg{}`` request:"
msgstr ""
"Чтобы включить репликацию, необходимо указать два параметра в запросе "
"``box.cfg{}``:"

#: ../doc/1.10/book/replication/repl_architecture.rst:164
msgid ""
":ref:`replication <cfg_replication-replication>` which defines the "
"replication source(s), and"
msgstr ""
":ref:`replication <cfg_replication-replication>`, который определяет "
"источники репликации, и"

#: ../doc/1.10/book/replication/repl_architecture.rst:166
msgid ""
":ref:`read_only <cfg_basic-read_only>` which is ``true`` for a replica "
"and ``false`` for a master."
msgstr ""
":ref:`read_only <cfg_basic-read_only>` со значением ``true`` для реплики "
"и ``false`` для мастера."

#: ../doc/1.10/book/replication/repl_architecture.rst:169
msgid ""
"Both these parameters are \"dynamic\". This allows a replica to become a "
"master and vice versa on the fly with the help of a ``box.cfg{}`` "
"request."
msgstr ""
" \"Динамические\" параметры репликации можно менять на лету, что "
"позволяет назначать реплику на роль мастера и наоборот. Для этого "
"используется запрос ``box.cfg{}``."

#: ../doc/1.10/book/replication/repl_architecture.rst:172
msgid ""
"Later we will give a detailed example of :ref:`bootstrapping a replica "
"set <replication-bootstrap>`."
msgstr ""
"Далее подробно рассмотрим пример :ref:`настройки набора реплик "
"<replication-bootstrap>`."

#: ../doc/1.10/book/replication/repl_architecture.rst:179
msgid "Replication roles: master and replica"
msgstr "Роли в репликации: мастер и реплика"

#: ../doc/1.10/book/replication/repl_architecture.rst:181
msgid ""
"The replication role (master or replica) is set by the :ref:`read_only "
"<cfg_basic-read_only>` configuration parameter. The recommended role is "
"\"read_only\" (replica) for all but one instance in the replica set."
msgstr ""
"Конфигурационный параметр :ref:`read_only <cfg_basic-read_only>` "
"определяет роль в репликации (мастер или реплика). Рекомендованная роль "
"для всех экземпляров в наборе реплик, кроме одного -- \"read-only\" "
"(реплика)."

#: ../doc/1.10/book/replication/repl_architecture.rst:185
msgid ""
"In a master-replica configuration, every change that happens on the "
"master will be visible on the replicas, but not vice versa."
msgstr ""
"В конфигурации мастер-реплика каждое изменение, сделанное на мастере, "
"будет отображаться на репликах, но не наоборот."

#: ../doc/1.10/book/replication/repl_architecture.rst:191
msgid ""
"A simple two-instance replica set with the master on one machine and the "
"replica on a different machine provides two benefits:"
msgstr ""
"Простой набор реплик с двумя экземплярами, один из которых является "
"мастером и расположен на одной машине, а другой -- реплика -- расположен "
"на другой машине, дает два преимущества:"

#: ../doc/1.10/book/replication/repl_architecture.rst:194
msgid ""
"**failover**, because if the master goes down then the replica can take "
"over, and"
msgstr ""
"**восстановление после отказа**, поскольку в случае отказа мастера "
"реплика может взять работу на себя, и"

#: ../doc/1.10/book/replication/repl_architecture.rst:196
msgid ""
"**load balancing**, because clients can connect to either the master or "
"the replica for read requests."
msgstr ""
"**балансировка нагрузки**, потому что клиенты во время запросов чтения "
"могут подключаться к мастеру или к реплике."

#: ../doc/1.10/book/replication/repl_architecture.rst:199
msgid ""
"In a **master-master** configuration (also called \"multi-master\"), "
"every change that happens on either instance will be visible on the other"
" one."
msgstr ""
"В конфигурации **мастер-мастер** (которая также называется "
"\"многомастерной\") каждое изменение на любом экземпляре будет также "
"отображаться на другом."

#: ../doc/1.10/book/replication/repl_architecture.rst:205
msgid ""
"The failover benefit in this case is still present, and the load-"
"balancing benefit is enhanced, because any instance can handle both read "
"and write requests. Meanwhile, for multi-master configurations, it is "
"necessary to understand the **replication guarantees** provided by the "
"asynchronous protocol that Tarantool implements."
msgstr ""
"Восстановление после отказа в таком случае также будет преимуществом, а "
"балансировка нагрузки улучшится, поскольку любой экземпляр может "
"обрабатывать запросы и на чтение, и на запись. В то же время, при "
"многомастерной конфигурации необходимо понимать **гарантии репликации**, "
"которые обеспечивает асинхронный протокол, внедренный в Tarantool."

#: ../doc/1.10/book/replication/repl_architecture.rst:211
msgid ""
"Tarantool multi-master replication guarantees that each change on each "
"master is propagated to all instances and is applied only once. Changes "
"from the same instance are applied in the same order as on the "
"originating instance. Changes from different instances, however, can be "
"mixed and applied in a different order on different instances. This may "
"lead to replication going out of sync in certain cases."
msgstr ""
"Многомастерная репликация Tarantool'а гарантирует, что каждое изменение "
"на каждом мастере передается на все экземпляры и применяется только один "
"раз. Изменения с одного экземпляра применяются в том же порядке, что и на"
" исходном экземпляре. Однако изменения с разных экземпляров могут "
"смешиваться и применяться в различном порядке на разных экземплярах. В "
"определенных случаях это может привести к рассинхронизации."

#: ../doc/1.10/book/replication/repl_architecture.rst:218
msgid ""
"For example, assuming the database is only appended to (i.e. it contains "
"only insertions), a multi-master configuration is safe. If there are also"
" deletions, but it is not mission critical that deletion happens in the "
"same order on all replicas (e.g. the DELETE is used to prune expired "
"data), a master-master configuration is also safe."
msgstr ""
"Например, принимая, что проводятся только операции добавления данных в "
"базу (т.е. она содержит только вставки), многомастерная конфигурация "
"сработает хорошо. Если данные также удаляются, но порядок операций "
"удаления на разных репликах не играет важной роли (например, DELETE "
"используется для отсечения устаревших данных), то конфигурация "
"мастер-мастер также безопасна."

#: ../doc/1.10/book/replication/repl_architecture.rst:224
msgid ""
"UPDATE operations, however, can easily go out of sync. For example, "
"assignment and increment are not commutative, and may yield different "
"results if applied in different order on different instances."
msgstr ""
"Однако операции обновления UPDATE могут с легкостью привести к "
"рассинхронизации. Например, операции присваивания и увеличения не "
"обладают коммутативностью и могут привести к различным результатам, если "
"применять их в различном порядке на разных экземплярах."

#: ../doc/1.10/book/replication/repl_architecture.rst:228
msgid ""
"More generally, it is only safe to use Tarantool master-master "
"replication if all database changes are **commutative**: the end result "
"does not depend on the order in which the changes are applied. You can "
"start learning more about conflict-free replicated data types `here "
"<https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type>`_."
msgstr ""
"В общем смысле, безопасно использовать репликацию мастер-мастер в "
"Tarantool'е, если все изменения в базе данных являются "
"**коммутативными**: конечный результат не зависит от порядка, в котором "
"применяются изменения. Дополнительную информацию о бесконфликтных типах "
"реплицируемых данных можно получить `здесь <https://en.wikipedia.org/wiki"
"/Conflict-free_replicated_data_type>`_."

#: ../doc/1.10/book/replication/repl_architecture.rst:238
msgid "Replication topologies: cascade, ring and full mesh"
msgstr "Топологии репликации: каскадная, кольцевая и полная ячеистая"

#: ../doc/1.10/book/replication/repl_architecture.rst:240
msgid ""
"Replication topology is set by the :ref:`replication <cfg_replication-"
"replication>` configuration parameter. The recommended topology is a "
"**full mesh**, because it makes potential failover easy."
msgstr ""
"Топология репликации определяется в конфигурационном параметре "
":ref:`replication <cfg_replication-replication>`. Рекомендована **полная "
"ячеистая** конфигурация, поскольку она облегчает возможное восстановление"
" после сбоя."

#: ../doc/1.10/book/replication/repl_architecture.rst:244
msgid ""
"Some database products offer **cascading replication** topologies: "
"creating a replica on a replica. Tarantool does not recommend such setup."
msgstr ""
"Некоторые СУБД предлагают топологии **каскадной репликации**: создание "
"реплики на реплике. Tarantool не рекомендует такие настройки."

#: ../doc/1.10/book/replication/repl_architecture.rst:250
msgid ""
"The problem with a cascading replica set is that some instances have no "
"connection to other instances and may not receive changes from them. One "
"essential change that must be propagated across all instances in a "
"replica set is an entry in ``box.space._cluster`` system space with the "
"replica set UUID. Without knowing the replica set UUID, a master refuses "
"to accept connections from such instances when replication topology "
"changes. Here is how this can happen:"
msgstr ""
"Недостаток каскадного набора реплик заключается в том, что некоторые "
"экземпляры не подключаются к другим экземплярам, поэтому не могут "
"получать от них изменения. Одно важное изменение, которое следует "
"передавать на все экземпляры в наборе реплик -- запись в системный спейс "
"``box.space._cluster`` с UUID набора реплик. Не зная UUID набора реплик, "
"мастер отклоняет подключения от таких экземпляров при изменении топологии"
" репликации. Вот как это может произойти:"

#: ../doc/1.10/book/replication/repl_architecture.rst:260
msgid ""
"We have a chain of three instances. Instance #1 contains entries for "
"instances #1 and #2 in its ``_cluster`` space. Instances #2 and #3 "
"contain entries for instances #1, #2 and #3 in their ``_cluster`` spaces."
msgstr ""
"У нас есть цепочка из трех экземпляров. Экземпляр №1 содержит записи для "
"экземпляров №1 и №2 в спейсе ``_cluster``. Экземпляры №2 и №3 содержат "
"записи для экземпляров №1, №2 и №3 в своих спейсах ``_cluster``."

#: ../doc/1.10/book/replication/repl_architecture.rst:267
msgid ""
"Now instance #2 is faulty. Instance #3 tries connecting to instance #1 as"
" its new master, but the master refuses the connection since it has no "
"entry for instance #3."
msgstr ""
"Теперь экземпляр №2 неисправен. Экземпляр №3 пытается подключиться к "
"экземпляру №1, как к новому мастеру, но мастер отклоняет подключение, "
"поскольку не содержит запись для экземпляра №3."

#: ../doc/1.10/book/replication/repl_architecture.rst:271
msgid "**Ring replication** topology is, however, supported:"
msgstr "Тем не менее, **кольцевая топология** поддерживается:"

#: ../doc/1.10/book/replication/repl_architecture.rst:276
msgid ""
"So, if you need a cascading topology, you may first create a ring to "
"ensure all instances know each other’s UUID, and then disconnect the "
"chain in the place you desire."
msgstr ""
"Поэтому если необходима каскадная топология, можно первоначально создать "
"кольцо, чтобы все экземпляры знали UUID друг друга, а затем разъединить "
"цепочку в необходимом месте."

#: ../doc/1.10/book/replication/repl_architecture.rst:280
msgid ""
"A stock recommendation for a master-master replication topology, however,"
" is a **full mesh**:"
msgstr ""
"Как бы то ни было, для репликации мастер-мастер рекомендуется **полная "
"ячеистая** топология:"

#: ../doc/1.10/book/replication/repl_architecture.rst:286
msgid ""
"You then can decide where to locate instances of the mesh -- within the "
"same data center, or spread across a few data centers. Tarantool will "
"automatically ensure that each row is applied only once on each instance."
" To remove a degraded instance from a mesh, simply change the "
"``replication`` configuration parameter."
msgstr ""
"В таком случае можно решить, где расположить экземпляры ячейки -- в том "
"же центре обработки данных или разместить в нескольких центрах. Tarantool"
" будет автоматически следить за тем, что каждая строка применяется "
"однократно на каждом экземпляре. Чтобы удалить экземпляр из ячейки после "
"отказа, просто измените конфигурационный параметр ``replication``."

#: ../doc/1.10/book/replication/repl_architecture.rst:291
msgid ""
"This ensures full cluster availability in case of a local failure, e.g. "
"one of the instances failing in one of the data centers, as well as in "
"case of an entire data center failure."
msgstr ""
"Таким образом можно обеспечить доступность всего кластера в случае "
"локального отказа, например отказа одного экземпляра в одном центре "
"обработки данных, а также в случае отказа всего центра обработки данных."

#: ../doc/1.10/book/replication/repl_architecture.rst:295
msgid "The maximal number of replicas in a mesh is 32."
msgstr "Максимальное количество реплик в ячейке -- 32."

#: ../doc/1.10/book/replication/repl_bootstrap.rst:39
msgid "Bootstrapping a replica set"
msgstr "Настройка набора реплик"

#: ../doc/1.10/book/replication/repl_bootstrap.rst:45
msgid "Master-replica bootstrap"
msgstr "Настройка репликации мастер-реплика"

#: ../doc/1.10/book/replication/repl_bootstrap.rst:47
msgid ""
"Let us first bootstrap a simple **master-replica** set containing two "
"instances, each located on its own machine. For easier administration, we"
" make the :ref:`instance files <admin-instance_file>` almost identical."
msgstr ""
"Сначала настроим простой набор **мастер-реплика** с двумя экземплярами, "
"каждый из которых находится на отдельном сервере. Для удобства "
"администрирования сделаем :ref:`файлы экземпляров <admin-instance_file>` "
"практически одинаковыми."

#: ../doc/1.10/book/replication/repl_bootstrap.rst:54
msgid "Here is an example of the master's instance file:"
msgstr "Ниже пример файла экземпляра для мастера:"

#: ../doc/1.10/book/replication/repl_bootstrap.rst:56
msgid ""
"-- instance file for the master\n"
"box.cfg{\n"
"  listen = 3301,\n"
"  replication = {'replicator:password@192.168.0.101:3301',  -- master URI"
"\n"
"                 'replicator:password@192.168.0.102:3301'}, -- replica "
"URI\n"
"  read_only = false\n"
"}\n"
"box.once(\"schema\", function()\n"
"   box.schema.user.create('replicator', {password = 'password'})\n"
"   box.schema.user.grant('replicator', 'replication') -- grant "
"replication role\n"
"   box.schema.space.create(\"test\")\n"
"   box.space.test:create_index(\"primary\")\n"
"   print('box.once executed on master')\n"
"end)"
msgstr ""
"-- файл экземпляра для мастера\n"
"box.cfg{\n"
"  listen = 3301,\n"
"  replication = {'replicator:password@192.168.0.101:3301',  -- URI "
"мастера\n"
"                 'replicator:password@192.168.0.102:3301'}, -- URI "
"реплики\n"
"  read_only = false\n"
"}\n"
"box.once(\"schema\", function()\n"
"  box.schema.user.create('replicator', {password = 'password'})\n"
"  box.schema.user.grant('replicator', 'replication') -- настроить роль "
"для репликации\n"
"  box.schema.space.create(\"test\")\n"
"  box.space.test:create_index(\"primary\")\n"
"  print('box.once executed on master')\n"
"end)"

#: ../doc/1.10/book/replication/repl_bootstrap.rst:75
msgid ""
"the ``box.cfg()`` :ref:`listen <cfg_basic-listen>` parameter defines a "
"URI (port 3301 in our example), on which the master can accept "
"connections from replicas."
msgstr ""
"параметр :ref:`listen <cfg_basic-listen>` в ``box.cfg{}`` определяет URI "
"(порт 3301 в нашем примере), на котором мастер может принимать "
"подключения от реплик."

#: ../doc/1.10/book/replication/repl_bootstrap.rst:78
msgid ""
"the ``box.cfg()`` :ref:`replication <cfg_replication-replication>` "
"parameter defines the URIs at which all instances in the replica set can "
"accept connections. It includes the replica's URI as well, although the "
"replica is not a replication source right now."
msgstr ""
"параметр :ref:`replication <cfg_replication-replication>` в ``box.cfg{}``"
" определяет URI, на которых все экземпляры в наборе реплик могут "
"принимать подключения. Он включает в себя также URI реплики, хотя реплики"
" в данном случае не является источником репликации."

#: ../doc/1.10/book/replication/repl_bootstrap.rst:85
msgid ""
"For security reasons, we recommend that administrators prevent "
"unauthorized replication sources by associating a password with every "
"user that has a replication :ref:`role <authentication-roles>`. That way,"
" the :ref:`URI <index-uri>` for ``replication`` parameter must have the "
"long form ``username:password@host:port``."
msgstr ""
"Для целей безопасности рекомендуем администраторам не допускать "
"репликацию из неавторизованных источников с помощью установки пароля для "
"каждого пользователя, у которого есть :ref:`роль <authentication-roles>` "
"для репликации. Таким образом, :ref:`URI <index-uri>` для параметра "
"``replication``  должен иметь развернутый вид "
"``username:password@host:port``."

#: ../doc/1.10/book/replication/repl_bootstrap.rst:91
msgid ""
"the :ref:`read_only = false <cfg_basic-read_only>` parameter setting "
"enables data-change operations on the instance and makes the instance act"
" as a master, not as a replica. *That is the only parameter setting in "
"our instance files that will differ.*"
msgstr ""
"параметр :ref:`read_only = false <cfg_basic-read_only>` разрешает "
"операции по изменению данных на экземпляре и заставляет данный экземпляр "
"работать в качестве мастера, а не реплики. *Это единственное значение "
"параметра, которое отличается в наших файлах экземпляров.*"

#: ../doc/1.10/book/replication/repl_bootstrap.rst:95
msgid ""
"the :ref:`box.once() <box-once>` function contains database "
"initialization logic that should be executed only once during the replica"
" set lifetime."
msgstr ""
"функция :ref:`box.once() <box-once>` содержит логику инициализации базы "
"данных, которая должна выполняться однократно в течение срока работы "
"набора реплик."

#: ../doc/1.10/book/replication/repl_bootstrap.rst:98
msgid ""
"In this example, we create a space with a primary index, and a user for "
"replication purposes. We also say ``print('box.once executed on "
"master')`` so that it will later be visible on a console whether "
"``box.once()`` was executed."
msgstr ""
"В данном примере создаем спейс с первичным индексом и пользователя для "
"целей репликации. Также выполним команду ``print('box.once executed on "
"master')``, чтобы позднее увидеть в консоли, была ли выполнена функция "
"``box.once()``."

#: ../doc/1.10/book/replication/repl_bootstrap.rst:104
msgid ""
"Replication requires privileges. We can grant privileges for accessing "
"spaces directly to the user who will start the instance. However, it is "
"more usual to grant privileges for accessing spaces to a :ref:`role "
"<authentication-roles>`, and then grant the role to the user who will "
"start the replica."
msgstr ""
"Репликация требует настройки прав. Права на доступ к спейсам можно задать"
" напрямую для пользователя, под чьим именем запущен экземпляр. Но обычно "
"права на доступ к спейсам задаются с помощью :ref:`роли <authentication-"
"roles>`, которая затем присваивается пользователю, под чьим именем "
"запущена реплика."

#: ../doc/1.10/book/replication/repl_bootstrap.rst:110
msgid ""
"Here we use Tarantool's predefined role named \"replication\" which by "
"default grants \"read\" privileges for all database objects "
"(\"universe\"), and we can change privileges for this role as required."
msgstr ""
"Здесь мы используем предварительно определенную роль Tarantool'а под "
"названием \"replication\", которая по умолчанию предоставляет права на "
"чтение всех объектов в базе данных (\"universe\"), а также сможем "
"настроить необходимые права для этой роли."

#: ../doc/1.10/book/replication/repl_bootstrap.rst:114
msgid ""
"In the replica's instance file, we set the ``read_only`` parameter to "
"\"true\", and say ``print('box.once executed on replica')`` so that later"
" it will be visible that ``box.once()`` was not executed more than once. "
"Otherwise the replica's instance file is identical to the master's "
"instance file."
msgstr ""
"В файле экземпляра для реплики устанавливаем значение \"true\" для "
"параметра ``read_only`` и выполняем команду ``print('box.once executed on"
" replica')``, чтобы позднее убедиться, что ``box.once()`` выполняется "
"только однократно. В других отношениях файл экземпляра для реплики "
"совпадает с файлом экземпляра для мастера."

#: ../doc/1.10/book/replication/repl_bootstrap.rst:119
msgid ""
"-- instance file for the replica\n"
"box.cfg{\n"
"  listen = 3301,\n"
"  replication = {'replicator:password@192.168.0.101:3301',  -- master URI"
"\n"
"                 'replicator:password@192.168.0.102:3301'}, -- replica "
"URI\n"
"  read_only = true\n"
"}\n"
"box.once(\"schema\", function()\n"
"   box.schema.user.create('replicator', {password = 'password'})\n"
"   box.schema.user.grant('replicator', 'replication') -- grant "
"replication role\n"
"   box.schema.space.create(\"test\")\n"
"   box.space.test:create_index(\"primary\")\n"
"   print('box.once executed on replica')\n"
"end)"
msgstr ""
"-- файл экземпляра для реплики\n"
"box.cfg{\n"
"  listen = 3301,\n"
"  replication = {'replicator:password@192.168.0.101:3301',  -- URI "
"мастера\n"
"                 'replicator:password@192.168.0.102:3301'}, -- URI "
"реплики\n"
"  read_only = true\n"
"}\n"
"box.once(\"schema\", function()\n"
"  box.schema.user.create('replicator', {password = 'password'})\n"
"  box.schema.user.grant('replicator', 'replication') -- настроить роль "
"для репликации\n"
"  box.schema.space.create(\"test\")\n"
"  box.space.test:create_index(\"primary\")\n"
"  print('box.once executed on replica')\n"
"end)"

#: ../doc/1.10/book/replication/repl_bootstrap.rst:138
msgid ""
"The replica does not inherit the master’s configuration parameters, such "
"as those making the :ref:`checkpoint daemon <book_cfg_checkpoint_daemon>`"
" run on the master. To get the same behavior, set the relevant parameters"
" explicitly so that they are the same on both master and replica."
msgstr ""
"Реплика не берет конфигурационные параметры с мастера, например настройки"
" запуска :ref:`фоновой программы для работы с контрольными точками "
"<book_cfg_checkpoint_daemon>` на мастере. Чтобы получить те же настройки "
"на реплике, необходимо задать их явным образом."

#: ../doc/1.10/book/replication/repl_bootstrap.rst:143
msgid "Now we can launch the two instances. The master..."
msgstr "Теперь можно запустить два экземпляра. Мастер..."

#: ../doc/1.10/book/replication/repl_bootstrap.rst:145
msgid ""
"$ # launching the master\n"
"$ tarantool master.lua\n"
"2017-06-14 14:12:03.847 [18933] main/101/master.lua C> version "
"1.7.4-52-g980d30092\n"
"2017-06-14 14:12:03.848 [18933] main/101/master.lua C> log level 5\n"
"2017-06-14 14:12:03.849 [18933] main/101/master.lua I> mapping 268435456 "
"bytes for tuple arena...\n"
"2017-06-14 14:12:03.859 [18933] iproto/101/main I> binary: bound to "
"[::]:3301\n"
"2017-06-14 14:12:03.861 [18933] main/105/applier/replicator@192.168.0. I>"
" can't connect to master\n"
"2017-06-14 14:12:03.861 [18933] main/105/applier/replicator@192.168.0. "
"coio.cc:105 !> SystemError connect, called on fd 14, aka "
"192.168.0.102:56736: Connection refused\n"
"2017-06-14 14:12:03.861 [18933] main/105/applier/replicator@192.168.0. I>"
" will retry every 1 second\n"
"2017-06-14 14:12:03.861 [18933] main/104/applier/replicator@192.168.0. I>"
" remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 14:12:19.878 [18933] main/105/applier/replicator@192.168.0. I>"
" remote master is 1.7.4 at 192.168.0.102:3301\n"
"2017-06-14 14:12:19.879 [18933] main/101/master.lua I> initializing an "
"empty data directory\n"
"2017-06-14 14:12:19.908 [18933] snapshot/101/main I> saving snapshot "
"`/var/lib/tarantool/master/00000000000000000000.snap.inprogress'\n"
"2017-06-14 14:12:19.914 [18933] snapshot/101/main I> done\n"
"2017-06-14 14:12:19.914 [18933] main/101/master.lua I> vinyl checkpoint "
"done\n"
"2017-06-14 14:12:19.917 [18933] main/101/master.lua I> ready to accept "
"requests\n"
"2017-06-14 14:12:19.918 [18933] main/105/applier/replicator@192.168.0. I>"
" failed to authenticate\n"
"2017-06-14 14:12:19.918 [18933] main/105/applier/replicator@192.168.0. "
"xrow.cc:431 E> ER_LOADING: Instance bootstrap hasn't finished yet\n"
"box.once executed on master\n"
"2017-06-14 14:12:19.920 [18933] main C> entering the event loop"
msgstr ""
"$ # запуск мастера\n"
"$ tarantool master.lua\n"
"2017-06-14 14:12:03.847 [18933] main/101/master.lua C> version "
"1.7.4-52-g980d30092\n"
"2017-06-14 14:12:03.848 [18933] main/101/master.lua C> log level 5\n"
"2017-06-14 14:12:03.849 [18933] main/101/master.lua I> mapping 268435456 "
"bytes for tuple arena...\n"
"2017-06-14 14:12:03.859 [18933] iproto/101/main I> binary: bound to "
"[::]:3301\n"
"2017-06-14 14:12:03.861 [18933] main/105/applier/replicator@192.168.0. I>"
" can't connect to master\n"
"2017-06-14 14:12:03.861 [18933] main/105/applier/replicator@192.168.0. "
"coio.cc:105 !> SystemError connect, called on fd 14, aka "
"192.168.0.102:56736: Connection refused\n"
"2017-06-14 14:12:03.861 [18933] main/105/applier/replicator@192.168.0. I>"
" will retry every 1 second\n"
"2017-06-14 14:12:03.861 [18933] main/104/applier/replicator@192.168.0. I>"
" remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 14:12:19.878 [18933] main/105/applier/replicator@192.168.0. I>"
" remote master is 1.7.4 at 192.168.0.102:3301\n"
"2017-06-14 14:12:19.879 [18933] main/101/master.lua I> initializing an "
"empty data directory\n"
"2017-06-14 14:12:19.908 [18933] snapshot/101/main I> saving snapshot "
"`/var/lib/tarantool/master/00000000000000000000.snap.inprogress'\n"
"2017-06-14 14:12:19.914 [18933] snapshot/101/main I> done\n"
"2017-06-14 14:12:19.914 [18933] main/101/master.lua I> vinyl checkpoint "
"done\n"
"2017-06-14 14:12:19.917 [18933] main/101/master.lua I> ready to accept "
"requests\n"
"2017-06-14 14:12:19.918 [18933] main/105/applier/replicator@192.168.0. I>"
" failed to authenticate\n"
"2017-06-14 14:12:19.918 [18933] main/105/applier/replicator@192.168.0. "
"xrow.cc:431 E> ER_LOADING: Instance bootstrap hasn't finished yet\n"
"box.once executed on master\n"
"2017-06-14 14:12:19.920 [18933] main C> entering the event loop"

#: ../doc/1.10/book/replication/repl_bootstrap.rst:168
msgid ""
"... (the display confirms that ``box.once()`` was executed on the master)"
" -- and the replica:"
msgstr ""
"... (выведенный результат подтверждает, что функция``box.once()`` была "
"выполнена на мастере) -- и реплику:"

#: ../doc/1.10/book/replication/repl_bootstrap.rst:170
msgid ""
"$ # launching the replica\n"
"$ tarantool replica.lua\n"
"2017-06-14 14:12:19.486 [18934] main/101/replica.lua C> version "
"1.7.4-52-g980d30092\n"
"2017-06-14 14:12:19.486 [18934] main/101/replica.lua C> log level 5\n"
"2017-06-14 14:12:19.487 [18934] main/101/replica.lua I> mapping 268435456"
" bytes for tuple arena...\n"
"2017-06-14 14:12:19.494 [18934] iproto/101/main I> binary: bound to "
"[::]:3311\n"
"2017-06-14 14:12:19.495 [18934] main/104/applier/replicator@192.168.0. I>"
" remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 14:12:19.495 [18934] main/105/applier/replicator@192.168.0. I>"
" remote master is 1.7.4 at 192.168.0.102:3302\n"
"2017-06-14 14:12:19.496 [18934] main/104/applier/replicator@192.168.0. I>"
" failed to authenticate\n"
"2017-06-14 14:12:19.496 [18934] main/104/applier/replicator@192.168.0. "
"xrow.cc:431 E> ER_LOADING: Instance bootstrap hasn't finished yet"
msgstr ""
"$ # запуск реплики\n"
"$ tarantool replica.lua\n"
"2017-06-14 14:12:19.486 [18934] main/101/replica.lua C> version "
"1.7.4-52-g980d30092\n"
"2017-06-14 14:12:19.486 [18934] main/101/replica.lua C> log level 5\n"
"2017-06-14 14:12:19.487 [18934] main/101/replica.lua I> mapping 268435456"
" bytes for tuple arena...\n"
"2017-06-14 14:12:19.494 [18934] iproto/101/main I> binary: bound to "
"[::]:3311\n"
"2017-06-14 14:12:19.495 [18934] main/104/applier/replicator@192.168.0. I>"
" remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 14:12:19.495 [18934] main/105/applier/replicator@192.168.0. I>"
" remote master is 1.7.4 at 192.168.0.102:3302\n"
"2017-06-14 14:12:19.496 [18934] main/104/applier/replicator@192.168.0. I>"
" failed to authenticate\n"
"2017-06-14 14:12:19.496 [18934] main/104/applier/replicator@192.168.0. "
"xrow.cc:431 E> ER_LOADING: Instance bootstrap hasn't finished yet"

#: ../doc/1.10/book/replication/repl_bootstrap.rst:183
msgid ""
"In both logs, there are messages saying that the replica was bootstrapped"
" from the master:"
msgstr ""
"В обоих журналах есть сообщения о том, что реплика получила настройки от "
"мастера:"

#: ../doc/1.10/book/replication/repl_bootstrap.rst:185
msgid ""
"$ # bootstrapping the replica (from the master's log)\n"
"<...>\n"
"2017-06-14 14:12:20.503 [18933] main/106/main I> initial data sent.\n"
"2017-06-14 14:12:20.505 [18933] relay/[::ffff:192.168.0.101]:/101/main I>"
" recover from `/var/lib/tarantool/master/00000000000000000000.xlog'\n"
"2017-06-14 14:12:20.505 [18933] main/106/main I> final data sent.\n"
"2017-06-14 14:12:20.522 [18933] relay/[::ffff:192.168.0.101]:/101/main I>"
" recover from `/Users/e.shebunyaeva/work/tarantool-test-"
"repl/master_dir/00000000000000000000.xlog'\n"
"2017-06-14 14:12:20.922 [18933] main/105/applier/replicator@192.168.0. I>"
" authenticated"
msgstr ""
"$ # настройка реплики (из журнала мастера)\n"
"<...>\n"
"2017-06-14 14:12:20.503 [18933] main/106/main I> initial data sent.\n"
"2017-06-14 14:12:20.505 [18933] relay/[::ffff:192.168.0.101]:/101/main I>"
" recover from `/var/lib/tarantool/master/00000000000000000000.xlog'\n"
"2017-06-14 14:12:20.505 [18933] main/106/main I> final data sent.\n"
"2017-06-14 14:12:20.522 [18933] relay/[::ffff:192.168.0.101]:/101/main I>"
" recover from `/Users/e.shebunyaeva/work/tarantool-test-"
"repl/master_dir/00000000000000000000.xlog'\n"
"2017-06-14 14:12:20.922 [18933] main/105/applier/replicator@192.168.0. I>"
" authenticated"

#: ../doc/1.10/book/replication/repl_bootstrap.rst:195
msgid ""
"$ # bootstrapping the replica (from the replica's log)\n"
"<...>\n"
"2017-06-14 14:12:20.498 [18934] main/104/applier/replicator@192.168.0. I>"
" authenticated\n"
"2017-06-14 14:12:20.498 [18934] main/101/replica.lua I> bootstrapping "
"replica from 192.168.0.101:3301\n"
"2017-06-14 14:12:20.512 [18934] main/104/applier/replicator@192.168.0. I>"
" initial data received\n"
"2017-06-14 14:12:20.512 [18934] main/104/applier/replicator@192.168.0. I>"
" final data received\n"
"2017-06-14 14:12:20.517 [18934] snapshot/101/main I> saving snapshot "
"`/var/lib/tarantool/replica/00000000000000000005.snap.inprogress'\n"
"2017-06-14 14:12:20.518 [18934] snapshot/101/main I> done\n"
"2017-06-14 14:12:20.519 [18934] main/101/replica.lua I> vinyl checkpoint "
"done\n"
"2017-06-14 14:12:20.520 [18934] main/101/replica.lua I> ready to accept "
"requests\n"
"2017-06-14 14:12:20.520 [18934] main/101/replica.lua I> set 'read_only' "
"configuration option to true\n"
"2017-06-14 14:12:20.520 [18934] main C> entering the event loop"
msgstr ""
"$ # настройка реплики (из журнала реплики)\n"
"<...>\n"
"2017-06-14 14:12:20.498 [18934] main/104/applier/replicator@192.168.0. I>"
" authenticated\n"
"2017-06-14 14:12:20.498 [18934] main/101/replica.lua I> bootstrapping "
"replica from 192.168.0.101:3301\n"
"2017-06-14 14:12:20.512 [18934] main/104/applier/replicator@192.168.0. I>"
" initial data received\n"
"2017-06-14 14:12:20.512 [18934] main/104/applier/replicator@192.168.0. I>"
" final data received\n"
"2017-06-14 14:12:20.517 [18934] snapshot/101/main I> saving snapshot "
"`/var/lib/tarantool/replica/00000000000000000005.snap.inprogress'\n"
"2017-06-14 14:12:20.518 [18934] snapshot/101/main I> done\n"
"2017-06-14 14:12:20.519 [18934] main/101/replica.lua I> vinyl checkpoint "
"done\n"
"2017-06-14 14:12:20.520 [18934] main/101/replica.lua I> ready to accept "
"requests\n"
"2017-06-14 14:12:20.520 [18934] main/101/replica.lua I> set 'read_only' "
"configuration option to true\n"
"2017-06-14 14:12:20.520 [18934] main C> entering the event loop"

#: ../doc/1.10/book/replication/repl_bootstrap.rst:210
msgid ""
"Notice that ``box.once()`` was executed only at the master, although we "
"added ``box.once()`` to both instance files."
msgstr ""
"Обратите внимание, что функция ``box.once()`` была выполнена только на "
"мастере, хотя мы добавили ``box.once()`` в оба файла экземпляра."

#: ../doc/1.10/book/replication/repl_bootstrap.rst:213
msgid "We could as well launch the replica first:"
msgstr "Также можно было сначала запустить реплику."

#: ../doc/1.10/book/replication/repl_bootstrap.rst:215
msgid ""
"$ # launching the replica\n"
"$ tarantool replica.lua\n"
"2017-06-14 14:35:36.763 [18952] main/101/replica.lua C> version "
"1.7.4-52-g980d30092\n"
"2017-06-14 14:35:36.765 [18952] main/101/replica.lua C> log level 5\n"
"2017-06-14 14:35:36.765 [18952] main/101/replica.lua I> mapping 268435456"
" bytes for tuple arena...\n"
"2017-06-14 14:35:36.772 [18952] iproto/101/main I> binary: bound to "
"[::]:3301\n"
"2017-06-14 14:35:36.772 [18952] main/104/applier/replicator@192.168.0. I>"
" can't connect to master\n"
"2017-06-14 14:35:36.772 [18952] main/104/applier/replicator@192.168.0. "
"coio.cc:105 !> SystemError connect, called on fd 13, aka "
"192.168.0.101:56820: Connection refused\n"
"2017-06-14 14:35:36.772 [18952] main/104/applier/replicator@192.168.0. I>"
" will retry every 1 second\n"
"2017-06-14 14:35:36.772 [18952] main/105/applier/replicator@192.168.0. I>"
" remote master is 1.7.4 at 192.168.0.102:3301"
msgstr ""
"$ # запуск реплики\n"
"$ tarantool replica.lua\n"
"2017-06-14 14:35:36.763 [18952] main/101/replica.lua C> version "
"1.7.4-52-g980d30092\n"
"2017-06-14 14:35:36.765 [18952] main/101/replica.lua C> log level 5\n"
"2017-06-14 14:35:36.765 [18952] main/101/replica.lua I> mapping 268435456"
" bytes for tuple arena...\n"
"2017-06-14 14:35:36.772 [18952] iproto/101/main I> binary: bound to "
"[::]:3301\n"
"2017-06-14 14:35:36.772 [18952] main/104/applier/replicator@192.168.0. I>"
" can't connect to master\n"
"2017-06-14 14:35:36.772 [18952] main/104/applier/replicator@192.168.0. "
"coio.cc:105 !> SystemError connect, called on fd 13, aka "
"192.168.0.101:56820: Connection refused\n"
"2017-06-14 14:35:36.772 [18952] main/104/applier/replicator@192.168.0. I>"
" will retry every 1 second\n"
"2017-06-14 14:35:36.772 [18952] main/105/applier/replicator@192.168.0. I>"
" remote master is 1.7.4 at 192.168.0.102:3301"

#: ../doc/1.10/book/replication/repl_bootstrap.rst:228
msgid "... and the master later:"
msgstr "... а затем уже мастера:"

#: ../doc/1.10/book/replication/repl_bootstrap.rst:230
msgid ""
"$ # launching the master\n"
"$ tarantool master.lua\n"
"2017-06-14 14:35:43.701 [18953] main/101/master.lua C> version "
"1.7.4-52-g980d30092\n"
"2017-06-14 14:35:43.702 [18953] main/101/master.lua C> log level 5\n"
"2017-06-14 14:35:43.702 [18953] main/101/master.lua I> mapping 268435456 "
"bytes for tuple arena...\n"
"2017-06-14 14:35:43.709 [18953] iproto/101/main I> binary: bound to "
"[::]:3301\n"
"2017-06-14 14:35:43.709 [18953] main/105/applier/replicator@192.168.0. I>"
" remote master is 1.7.4 at 192.168.0.102:3301\n"
"2017-06-14 14:35:43.709 [18953] main/104/applier/replicator@192.168.0. I>"
" remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 14:35:43.709 [18953] main/101/master.lua I> initializing an "
"empty data directory\n"
"2017-06-14 14:35:43.721 [18953] snapshot/101/main I> saving snapshot "
"`/var/lib/tarantool/master/00000000000000000000.snap.inprogress'\n"
"2017-06-14 14:35:43.722 [18953] snapshot/101/main I> done\n"
"2017-06-14 14:35:43.723 [18953] main/101/master.lua I> vinyl checkpoint "
"done\n"
"2017-06-14 14:35:43.723 [18953] main/101/master.lua I> ready to accept "
"requests\n"
"2017-06-14 14:35:43.724 [18953] main/105/applier/replicator@192.168.0. I>"
" failed to authenticate\n"
"2017-06-14 14:35:43.724 [18953] main/105/applier/replicator@192.168.0. "
"xrow.cc:431 E> ER_LOADING: Instance bootstrap hasn't finished yet\n"
"box.once executed on master\n"
"2017-06-14 14:35:43.726 [18953] main C> entering the event loop\n"
"2017-06-14 14:35:43.779 [18953] main/103/main I> initial data sent.\n"
"2017-06-14 14:35:43.780 [18953] relay/[::ffff:192.168.0.101]:/101/main I>"
" recover from `/var/lib/tarantool/master/00000000000000000000.xlog'\n"
"2017-06-14 14:35:43.780 [18953] main/103/main I> final data sent.\n"
"2017-06-14 14:35:43.796 [18953] relay/[::ffff:192.168.0.102]:/101/main I>"
" recover from `/var/lib/tarantool/master/00000000000000000000.xlog'\n"
"2017-06-14 14:35:44.726 [18953] main/105/applier/replicator@192.168.0. I>"
" authenticated"
msgstr ""
"$ # запуск мастера\n"
"$ tarantool master.lua\n"
"2017-06-14 14:35:43.701 [18953] main/101/master.lua C> version "
"1.7.4-52-g980d30092\n"
"2017-06-14 14:35:43.702 [18953] main/101/master.lua C> log level 5\n"
"2017-06-14 14:35:43.702 [18953] main/101/master.lua I> mapping 268435456 "
"bytes for tuple arena...\n"
"2017-06-14 14:35:43.709 [18953] iproto/101/main I> binary: bound to "
"[::]:3301\n"
"2017-06-14 14:35:43.709 [18953] main/105/applier/replicator@192.168.0. I>"
" remote master is 1.7.4 at 192.168.0.102:3301\n"
"2017-06-14 14:35:43.709 [18953] main/104/applier/replicator@192.168.0. I>"
" remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 14:35:43.709 [18953] main/101/master.lua I> initializing an "
"empty data directory\n"
"2017-06-14 14:35:43.721 [18953] snapshot/101/main I> saving snapshot "
"`/var/lib/tarantool/master/00000000000000000000.snap.inprogress'\n"
"2017-06-14 14:35:43.722 [18953] snapshot/101/main I> done\n"
"2017-06-14 14:35:43.723 [18953] main/101/master.lua I> vinyl checkpoint "
"done\n"
"2017-06-14 14:35:43.723 [18953] main/101/master.lua I> ready to accept "
"requests\n"
"2017-06-14 14:35:43.724 [18953] main/105/applier/replicator@192.168.0. I>"
" failed to authenticate\n"
"2017-06-14 14:35:43.724 [18953] main/105/applier/replicator@192.168.0. "
"xrow.cc:431 E> ER_LOADING: Instance bootstrap hasn't finished yet\n"
"box.once executed on master\n"
"2017-06-14 14:35:43.726 [18953] main C> entering the event loop\n"
"2017-06-14 14:35:43.779 [18953] main/103/main I> initial data sent.\n"
"2017-06-14 14:35:43.780 [18953] relay/[::ffff:192.168.0.101]:/101/main I>"
" recover from `/var/lib/tarantool/master/00000000000000000000.xlog'\n"
"2017-06-14 14:35:43.780 [18953] main/103/main I> final data sent.\n"
"2017-06-14 14:35:43.796 [18953] relay/[::ffff:192.168.0.102]:/101/main I>"
" recover from `/var/lib/tarantool/master/00000000000000000000.xlog'\n"
"2017-06-14 14:35:44.726 [18953] main/105/applier/replicator@192.168.0. I>"
" authenticated"

#: ../doc/1.10/book/replication/repl_bootstrap.rst:255
msgid ""
"In this case, the replica would wait for the master to become available, "
"so the launch order doesn't matter. Our ``box.once()`` logic would also "
"be executed only once, at the master."
msgstr ""
"В данном случае реплика ожидает доступности мастера, поэтому порядок "
"запуска не имеет значения. Наша функция ``box.once()`` также будет "
"выполняться однократно, только на мастере."

#: ../doc/1.10/book/replication/repl_bootstrap.rst:259
msgid ""
"$ # the replica has eventually connected to the master\n"
"$ # and got bootstrapped (from the replica's log)\n"
"2017-06-14 14:35:43.777 [18952] main/104/applier/replicator@192.168.0. I>"
" remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 14:35:43.777 [18952] main/104/applier/replicator@192.168.0. I>"
" authenticated\n"
"2017-06-14 14:35:43.777 [18952] main/101/replica.lua I> bootstrapping "
"replica from 192.168.0.199:3310\n"
"2017-06-14 14:35:43.788 [18952] main/104/applier/replicator@192.168.0. I>"
" initial data received\n"
"2017-06-14 14:35:43.789 [18952] main/104/applier/replicator@192.168.0. I>"
" final data received\n"
"2017-06-14 14:35:43.793 [18952] snapshot/101/main I> saving snapshot "
"`/var/lib/tarantool/replica/00000000000000000005.snap.inprogress'\n"
"2017-06-14 14:35:43.793 [18952] snapshot/101/main I> done\n"
"2017-06-14 14:35:43.795 [18952] main/101/replica.lua I> vinyl checkpoint "
"done\n"
"2017-06-14 14:35:43.795 [18952] main/101/replica.lua I> ready to accept "
"requests\n"
"2017-06-14 14:35:43.795 [18952] main/101/replica.lua I> set 'read_only' "
"configuration option to true\n"
"2017-06-14 14:35:43.795 [18952] main C> entering the event loop"
msgstr ""
"$ # реплика в итоге подключена к мастеру\n"
"$ # и получила настройки (из журнала реплики)\n"
"2017-06-14 14:35:43.777 [18952] main/104/applier/replicator@192.168.0. I>"
" remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 14:35:43.777 [18952] main/104/applier/replicator@192.168.0. I>"
" authenticated\n"
"2017-06-14 14:35:43.777 [18952] main/101/replica.lua I> bootstrapping "
"replica from 192.168.0.199:3310\n"
"2017-06-14 14:35:43.788 [18952] main/104/applier/replicator@192.168.0. I>"
" initial data received\n"
"2017-06-14 14:35:43.789 [18952] main/104/applier/replicator@192.168.0. I>"
" final data received\n"
"2017-06-14 14:35:43.793 [18952] snapshot/101/main I> saving snapshot "
"`/var/lib/tarantool/replica/00000000000000000005.snap.inprogress'\n"
"2017-06-14 14:35:43.793 [18952] snapshot/101/main I> done\n"
"2017-06-14 14:35:43.795 [18952] main/101/replica.lua I> vinyl checkpoint "
"done\n"
"2017-06-14 14:35:43.795 [18952] main/101/replica.lua I> ready to accept "
"requests\n"
"2017-06-14 14:35:43.795 [18952] main/101/replica.lua I> set 'read_only' "
"configuration option to true\n"
"2017-06-14 14:35:43.795 [18952] main C> entering the event loop"

#: ../doc/1.10/book/replication/repl_bootstrap.rst:279
msgid "Controlled failover"
msgstr "Контролируемое восстановление после сбоя"

#: ../doc/1.10/book/replication/repl_bootstrap.rst:281
msgid ""
"To perform a **controlled failover**, that is, swap the roles of the "
"master and replica, all we need to do is to set ``read_only=true`` at the"
" master, and ``read_only=false`` at the replica. The order of actions is "
"important here. If a system is running in production, we do not want "
"concurrent writes happening both at the replica and the master. Nor do we"
" want the new replica to accept any writes until it has finished fetching"
" all replication data from the old master. To compare replica and master "
"state, we can use :ref:`box.info.signature <box_introspection-box_info>`."
msgstr ""
"Чтобы провести **контролируемое восстановление после сбоя**, то есть "
"поменять роли мастера и реплики, нужно лишь настроить параметры "
"``read_only=true`` на мастере и ``read_only=false`` на реплике. Порядок "
"действий в данном случае имеет значение. Если система принята в "
"эксплуатацию, нам не нужна параллельная запись на реплике и на мастере. "
"Нежелательно также, чтобы новая реплика принимала запись, пока не получит"
" все реплицируемые данные со старого мастера. Чтобы сопоставить состояние"
" реплики и мастера, можно использовать :ref:`box.info.signature "
"<box_introspection-box_info>`."

#: ../doc/1.10/book/replication/repl_bootstrap.rst:290
msgid "Set ``read_only=true`` at the master."
msgstr "Настройте ``read_only=true`` на мастере."

#: ../doc/1.10/book/replication/repl_bootstrap.rst:292
msgid ""
"# at the master\n"
"tarantool> box.cfg{read_only=true}"
msgstr ""
"# на мастере\n"
"tarantool> box.cfg{read_only=true}"

#: ../doc/1.10/book/replication/repl_bootstrap.rst:297
msgid ""
"Record the master’s current position with ``box.info.signature``, "
"containing the sum of all LSNs in the master’s vector clock."
msgstr ""
"Зарегистрируйте текущее состояние мастера с помощью "
"``box.info.signature``, которое содержит общее количество всех LSN в "
"векторных часах мастера."

#: ../doc/1.10/book/replication/repl_bootstrap.rst:300
msgid ""
"# at the master\n"
"tarantool> box.info.signature"
msgstr ""
"# на мастере\n"
"tarantool> box.info.signature"

#: ../doc/1.10/book/replication/repl_bootstrap.rst:305
msgid "Wait until the replica’s signature is the same as the master’s."
msgstr "Подождите, пока сигнатура реплики не совпадет с сигнатурой мастера."

#: ../doc/1.10/book/replication/repl_bootstrap.rst:307
msgid ""
"# at the replica\n"
"tarantool> box.info.signature"
msgstr ""
"# на реплике\n"
"tarantool> box.info.signature"

#: ../doc/1.10/book/replication/repl_bootstrap.rst:312
msgid "Set ``read_only=false`` at the replica to enable write operations."
msgstr ""
"Настройте `read_only=false`` на реплике, чтобы запустить операции записи "
"данных."

#: ../doc/1.10/book/replication/repl_bootstrap.rst:314
msgid ""
"# at the replica\n"
"tarantool> box.cfg{read_only=false}"
msgstr ""
"# на реплике\n"
"tarantool> box.cfg{read_only=false}"

#: ../doc/1.10/book/replication/repl_bootstrap.rst:319
msgid ""
"These four steps ensure that the replica doesn’t accept new writes until "
"it’s done fetching writes from the master."
msgstr ""
"Эти шаги нужны для того, чтобы реплика гарантированно не принимала новые "
"записи, пока не получит данные от мастера."

#: ../doc/1.10/book/replication/repl_bootstrap.rst:326
msgid "Master-master bootstrap"
msgstr "Настройка репликации мастер-мастер"

#: ../doc/1.10/book/replication/repl_bootstrap.rst:328
msgid ""
"Now let us bootstrap a two-instance **master-master** set. For easier "
"administration, we make master#1 and master#2 instance files fully "
"identical."
msgstr ""
"Теперь настроим набор с двумя экземплярами **мастер-мастер**. Для "
"удобства управления сделаем файлы экземпляра для мастера №1 и мастера №2 "
"практически одинаковыми."

#: ../doc/1.10/book/replication/repl_bootstrap.rst:334
msgid ""
"We re-use the master's instance file from the :ref:`master-replica "
"example <replication-master_replica_bootstrap>` above."
msgstr ""
"Переиспользуем файл экземпляра для мастера из вышеописанного "
":ref:`примера мастер-реплика <replication-master_replica_bootstrap>`."

#: ../doc/1.10/book/replication/repl_bootstrap.rst:337
msgid ""
"-- instance file for any of the two masters\n"
"box.cfg{\n"
"  listen      = 3301,\n"
"  replication = {'replicator:password@192.168.0.101:3301',  -- master1 "
"URI\n"
"                 'replicator:password@192.168.0.102:3301'}, -- master2 "
"URI\n"
"  read_only   = false\n"
"}\n"
"box.once(\"schema\", function()\n"
"   box.schema.user.create('replicator', {password = 'password'})\n"
"   box.schema.user.grant('replicator', 'replication') -- grant "
"replication role\n"
"   box.schema.space.create(\"test\")\n"
"   box.space.test:create_index(\"primary\")\n"
"   print('box.once executed on master #1')\n"
"end)"
msgstr ""
"-- файл экземпляра для любого из двух мастеров\n"
"  box.cfg{\n"
"  listen      = 3301,\n"
"  replication = {'replicator:password@192.168.0.101:3301',  -- URI "
"мастера 1\n"
"                 'replicator:password@192.168.0.102:3301'}, -- URI "
"мастера 2\n"
"  read_only   = false\n"
"}\n"
"box.once(\"schema\", function()\n"
"  box.schema.user.create('replicator', {password = 'password'})\n"
"  box.schema.user.grant('replicator', 'replication') -- настроить роль "
"для репликации\n"
"  box.schema.space.create(\"test\")\n"
"  box.space.test:create_index(\"primary\")\n"
"  print('box.once executed on master #1')\n"
"end)"

#: ../doc/1.10/book/replication/repl_bootstrap.rst:354
msgid ""
"In the :ref:`replication <cfg_replication-replication>` parameter, we "
"define the URIs of both masters in the replica set and say "
"``print('box.once executed on master #1')`` so it will be clear when and "
"where the ``box.once()`` logic is executed."
msgstr ""
"В параметре :ref:`replication <cfg_replication-replication>` определим "
"URI обоих мастеров в наборе реплик и выполним команду ``print('box.once "
"executed on master #1')``, чтобы увидеть, когда и где будет выполнена "
"логика функции ``box.once()``."

#: ../doc/1.10/book/replication/repl_bootstrap.rst:359
msgid ""
"Now we can launch the two masters. Again, the launch order doesn't "
"matter. The ``box.once()`` logic will also be executed only once, at the "
"master which is elected as the replica set :ref:`leader <replication-"
"leader>` at bootstrap."
msgstr ""
"Теперь можно запустить оба мастера. Повторимся, что порядок запуска не "
"имеет значения. Логика ``box.once()`` также будет выполняться лишь "
"однократно на мастере, который будет выбран лидером (:ref:`leader "
"<replication-leader>`) в наборе реплик при настройке."

#: ../doc/1.10/book/replication/repl_bootstrap.rst:363
msgid ""
"$ # launching master #1\n"
"$ tarantool master1.lua\n"
"2017-06-14 15:39:03.062 [47021] main/101/master1.lua C> version "
"1.7.4-52-g980d30092\n"
"2017-06-14 15:39:03.062 [47021] main/101/master1.lua C> log level 5\n"
"2017-06-14 15:39:03.063 [47021] main/101/master1.lua I> mapping 268435456"
" bytes for tuple arena...\n"
"2017-06-14 15:39:03.065 [47021] iproto/101/main I> binary: bound to "
"[::]:3301\n"
"2017-06-14 15:39:03.065 [47021] main/105/applier/replicator@192.168.0.10 "
"I> can't connect to master\n"
"2017-06-14 15:39:03.065 [47021] main/105/applier/replicator@192.168.0.10 "
"coio.cc:107 !> SystemError connect, called on fd 14, aka "
"192.168.0.102:57110: Connection refused\n"
"2017-06-14 15:39:03.065 [47021] main/105/applier/replicator@192.168.0.10 "
"I> will retry every 1 second\n"
"2017-06-14 15:39:03.065 [47021] main/104/applier/replicator@192.168.0.10 "
"I> remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 15:39:08.070 [47021] main/105/applier/replicator@192.168.0.10 "
"I> remote master is 1.7.4 at 192.168.0.102:3301\n"
"2017-06-14 15:39:08.071 [47021] main/105/applier/replicator@192.168.0.10 "
"I> authenticated\n"
"2017-06-14 15:39:08.071 [47021] main/101/master1.lua I> bootstrapping "
"replica from 192.168.0.102:3301\n"
"2017-06-14 15:39:08.073 [47021] main/105/applier/replicator@192.168.0.10 "
"I> initial data received\n"
"2017-06-14 15:39:08.074 [47021] main/105/applier/replicator@192.168.0.10 "
"I> final data received\n"
"2017-06-14 15:39:08.074 [47021] snapshot/101/main I> saving snapshot "
"`/Users/e.shebunyaeva/work/tarantool-test-"
"repl/master1_dir/00000000000000000008.snap.inprogress'\n"
"2017-06-14 15:39:08.074 [47021] snapshot/101/main I> done\n"
"2017-06-14 15:39:08.076 [47021] main/101/master1.lua I> vinyl checkpoint "
"done\n"
"2017-06-14 15:39:08.076 [47021] main/101/master1.lua I> ready to accept "
"requests\n"
"box.once executed on master #1\n"
"2017-06-14 15:39:08.077 [47021] main C> entering the event loop"
msgstr ""
"$ # запуск мастера №1\n"
"$ tarantool master1.lua\n"
"2017-06-14 15:39:03.062 [47021] main/101/master1.lua C> version "
"1.7.4-52-g980d30092\n"
"2017-06-14 15:39:03.062 [47021] main/101/master1.lua C> log level 5\n"
"2017-06-14 15:39:03.063 [47021] main/101/master1.lua I> mapping 268435456"
" bytes for tuple arena...\n"
"2017-06-14 15:39:03.065 [47021] iproto/101/main I> binary: bound to "
"[::]:3301\n"
"2017-06-14 15:39:03.065 [47021] main/105/applier/replicator@192.168.0.10 "
"I> can't connect to master\n"
"2017-06-14 15:39:03.065 [47021] main/105/applier/replicator@192.168.0.10 "
"coio.cc:107 !> SystemError connect, called on fd 14, aka "
"192.168.0.102:57110: Connection refused\n"
"2017-06-14 15:39:03.065 [47021] main/105/applier/replicator@192.168.0.10 "
"I> will retry every 1 second\n"
"2017-06-14 15:39:03.065 [47021] main/104/applier/replicator@192.168.0.10 "
"I> remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 15:39:08.070 [47021] main/105/applier/replicator@192.168.0.10 "
"I> remote master is 1.7.4 at 192.168.0.102:3301\n"
"2017-06-14 15:39:08.071 [47021] main/105/applier/replicator@192.168.0.10 "
"I> authenticated\n"
"2017-06-14 15:39:08.071 [47021] main/101/master1.lua I> bootstrapping "
"replica from 192.168.0.102:3301\n"
"2017-06-14 15:39:08.073 [47021] main/105/applier/replicator@192.168.0.10 "
"I> initial data received\n"
"2017-06-14 15:39:08.074 [47021] main/105/applier/replicator@192.168.0.10 "
"I> final data received\n"
"2017-06-14 15:39:08.074 [47021] snapshot/101/main I> saving snapshot "
"`/Users/e.shebunyaeva/work/tarantool-test-"
"repl/master1_dir/00000000000000000008.snap.inprogress'\n"
"2017-06-14 15:39:08.074 [47021] snapshot/101/main I> done\n"
"2017-06-14 15:39:08.076 [47021] main/101/master1.lua I> vinyl checkpoint "
"done\n"
"2017-06-14 15:39:08.076 [47021] main/101/master1.lua I> ready to accept "
"requests\n"
"box.once executed on master #1\n"
"2017-06-14 15:39:08.077 [47021] main C> entering the event loop"

#: ../doc/1.10/book/replication/repl_bootstrap.rst:387
msgid ""
"$ # launching master #2\n"
"$ tarantool master2.lua\n"
"2017-06-14 15:39:07.452 [47022] main/101/master2.lua C> version "
"1.7.4-52-g980d30092\n"
"2017-06-14 15:39:07.453 [47022] main/101/master2.lua C> log level 5\n"
"2017-06-14 15:39:07.453 [47022] main/101/master2.lua I> mapping 268435456"
" bytes for tuple arena...\n"
"2017-06-14 15:39:07.455 [47022] iproto/101/main I> binary: bound to "
"[::]:3301\n"
"2017-06-14 15:39:07.455 [47022] main/104/applier/replicator@192.168.0.19 "
"I> remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 15:39:07.455 [47022] main/105/applier/replicator@192.168.0.10 "
"I> remote master is 1.7.4 at 192.168.0.102:3301\n"
"2017-06-14 15:39:07.455 [47022] main/101/master2.lua I> initializing an "
"empty data directory\n"
"2017-06-14 15:39:07.457 [47022] snapshot/101/main I> saving snapshot "
"`/Users/e.shebunyaeva/work/tarantool-test-"
"repl/master2_dir/00000000000000000000.snap.inprogress'\n"
"2017-06-14 15:39:07.457 [47022] snapshot/101/main I> done\n"
"2017-06-14 15:39:07.458 [47022] main/101/master2.lua I> vinyl checkpoint "
"done\n"
"2017-06-14 15:39:07.459 [47022] main/101/master2.lua I> ready to accept "
"requests\n"
"2017-06-14 15:39:07.460 [47022] main C> entering the event loop\n"
"2017-06-14 15:39:08.072 [47022] main/103/main I> initial data sent.\n"
"2017-06-14 15:39:08.073 [47022] relay/[::ffff:192.168.0.102]:/101/main I>"
" recover from `/Users/e.shebunyaeva/work/tarantool-test-"
"repl/master2_dir/00000000000000000000.xlog'\n"
"2017-06-14 15:39:08.073 [47022] main/103/main I> final data sent.\n"
"2017-06-14 15:39:08.077 [47022] relay/[::ffff:192.168.0.102]:/101/main I>"
" recover from `/Users/e.shebunyaeva/work/tarantool-test-"
"repl/master2_dir/00000000000000000000.xlog'\n"
"2017-06-14 15:39:08.461 [47022] main/104/applier/replicator@192.168.0.10 "
"I> authenticated"
msgstr ""
"$ # запуск мастера №2\n"
"$ tarantool master2.lua\n"
"2017-06-14 15:39:07.452 [47022] main/101/master2.lua C> version "
"1.7.4-52-g980d30092\n"
"2017-06-14 15:39:07.453 [47022] main/101/master2.lua C> log level 5\n"
"2017-06-14 15:39:07.453 [47022] main/101/master2.lua I> mapping 268435456"
" bytes for tuple arena...\n"
"2017-06-14 15:39:07.455 [47022] iproto/101/main I> binary: bound to "
"[::]:3301\n"
"2017-06-14 15:39:07.455 [47022] main/104/applier/replicator@192.168.0.19 "
"I> remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 15:39:07.455 [47022] main/105/applier/replicator@192.168.0.10 "
"I> remote master is 1.7.4 at 192.168.0.102:3301\n"
"2017-06-14 15:39:07.455 [47022] main/101/master2.lua I> initializing an "
"empty data directory\n"
"2017-06-14 15:39:07.457 [47022] snapshot/101/main I> saving snapshot "
"`/Users/e.shebunyaeva/work/tarantool-test-"
"repl/master2_dir/00000000000000000000.snap.inprogress'\n"
"2017-06-14 15:39:07.457 [47022] snapshot/101/main I> done\n"
"2017-06-14 15:39:07.458 [47022] main/101/master2.lua I> vinyl checkpoint "
"done\n"
"2017-06-14 15:39:07.459 [47022] main/101/master2.lua I> ready to accept "
"requests\n"
"2017-06-14 15:39:07.460 [47022] main C> entering the event loop\n"
"2017-06-14 15:39:08.072 [47022] main/103/main I> initial data sent.\n"
"2017-06-14 15:39:08.073 [47022] relay/[::ffff:192.168.0.102]:/101/main I>"
" recover from `/Users/e.shebunyaeva/work/tarantool-test-"
"repl/master2_dir/00000000000000000000.xlog'\n"
"2017-06-14 15:39:08.073 [47022] main/103/main I> final data sent.\n"
"2017-06-14 15:39:08.077 [47022] relay/[::ffff:192.168.0.102]:/101/main I>"
" recover from `/Users/e.shebunyaeva/work/tarantool-test-"
"repl/master2_dir/00000000000000000000.xlog'\n"
"2017-06-14 15:39:08.461 [47022] main/104/applier/replicator@192.168.0.10 "
"I> authenticated"

#: ../doc/1.10/book/replication/repl_duplicates.rst:39
msgid "Preventing duplicate actions"
msgstr "Предотвращение дублирующихся действий"

#: ../doc/1.10/book/replication/repl_duplicates.rst:41
msgid ""
"Tarantool guarantees that every update is applied only once on every "
"replica. However, due to the asynchronous nature of replication, the "
"order of updates is not guaranteed. We now analyze this problem with more"
" details, provide examples of replication going out of sync, and suggest "
"solutions."
msgstr ""
"Tarantool гарантирует, что все обновления применяются однократно на "
"каждой реплике. Однако, поскольку репликация носит асинхронный характер, "
"порядок обновлений не гарантируется. Сейчас мы проанализируем данную "
"проблему более подробно с примерами рассинхронизации репликации и "
"предложим соответствующие решения."

#: ../doc/1.10/book/replication/repl_duplicates.rst:50
msgid "Replication stops"
msgstr "Остановка репликации"

#: ../doc/1.10/book/replication/repl_duplicates.rst:52
msgid ""
"In a replica set of two masters, suppose master #1 tries to do something "
"that master #2 has already done. For example, try to insert a tuple with "
"the same unique key:"
msgstr ""
"Предположим, что в наборе реплик с двумя мастерами мастер №1 пытается "
"сделать что-то, что уже было сделано мастером №2. Например, попробуйте "
"вставить кортеж с одинаковым уникальным ключом:"

#: ../doc/1.10/book/replication/repl_duplicates.rst:56
msgid "tarantool> box.space.tester:insert{1, 'data'}"
msgstr "tarantool> box.space.tester:insert{1, 'data'}"

#: ../doc/1.10/book/replication/repl_duplicates.rst:60
msgid ""
"This would cause an error saying ``Duplicate key exists in unique index "
"'primary' in space 'tester'`` and the replication would be stopped. (This"
" is the behavior when the :ref:`replication_skip_conflict "
"<cfg_replication-replication_skip_conflict>` configuration parameter has "
"its default recommended value, ``false``.)"
msgstr ""
"Это вызовет сообщение об ошибке дубликата ключа (``Duplicate key exists "
"in unique index 'primary' in space 'tester'``), и репликация остановится."
" Такое поведение системы обеспечивается использованием рекомендуемого "
"значения ``false`` (по умолчанию) для конфигурационного параметра "
":ref:`replication_skip_conflict <cfg_replication-"
"replication_skip_conflict>`."

#: ../doc/1.10/book/replication/repl_duplicates.rst:66
msgid ""
"$ # error messages from master #1\n"
"2017-06-26 21:17:03.233 [30444] main/104/applier/rep_user@100.96.166.1 I>"
" can't read row\n"
"2017-06-26 21:17:03.233 [30444] main/104/applier/rep_user@100.96.166.1 "
"memtx_hash.cc:226 E> ER_TUPLE_FOUND:\n"
"Duplicate key exists in unique index 'primary' in space 'tester'\n"
"2017-06-26 21:17:03.233 [30444] relay/[::ffff:100.96.166.178]/101/main I>"
" the replica has closed its socket, exiting\n"
"2017-06-26 21:17:03.233 [30444] relay/[::ffff:100.96.166.178]/101/main C>"
" exiting the relay loop\n"
"\n"
"$ # error messages from master #2\n"
"2017-06-26 21:17:03.233 [30445] main/104/applier/rep_user@100.96.166.1 I>"
" can't read row\n"
"2017-06-26 21:17:03.233 [30445] main/104/applier/rep_user@100.96.166.1 "
"memtx_hash.cc:226 E> ER_TUPLE_FOUND:\n"
"Duplicate key exists in unique index 'primary' in space 'tester'\n"
"2017-06-26 21:17:03.234 [30445] relay/[::ffff:100.96.166.178]/101/main I>"
" the replica has closed its socket, exiting\n"
"2017-06-26 21:17:03.234 [30445] relay/[::ffff:100.96.166.178]/101/main C>"
" exiting the relay loop"
msgstr ""
"$ # сообщения об ошибках от мастера №1\n"
"2017-06-26 21:17:03.233 [30444] main/104/applier/rep_user@100.96.166.1 I>"
" can't read row\n"
"2017-06-26 21:17:03.233 [30444] main/104/applier/rep_user@100.96.166.1 "
"memtx_hash.cc:226 E> ER_TUPLE_FOUND:\n"
"Duplicate key exists in unique index 'primary' in space 'tester'\n"
"2017-06-26 21:17:03.233 [30444] relay/[::ffff:100.96.166.178]/101/main I>"
" the replica has closed its socket, exiting\n"
"2017-06-26 21:17:03.233 [30444] relay/[::ffff:100.96.166.178]/101/main C>"
" exiting the relay loop\n"
"\n"
"$ # сообщения об ошибках от мастера №2\n"
"2017-06-26 21:17:03.233 [30445] main/104/applier/rep_user@100.96.166.1 I>"
" can't read row\n"
"2017-06-26 21:17:03.233 [30445] main/104/applier/rep_user@100.96.166.1 "
"memtx_hash.cc:226 E> ER_TUPLE_FOUND:\n"
"Duplicate key exists in unique index 'primary' in space 'tester'\n"
"2017-06-26 21:17:03.234 [30445] relay/[::ffff:100.96.166.178]/101/main I>"
" the replica has closed its socket, exiting\n"
"2017-06-26 21:17:03.234 [30445] relay/[::ffff:100.96.166.178]/101/main C>"
" exiting the relay loop"

#: ../doc/1.10/book/replication/repl_duplicates.rst:82
msgid ""
"If we check replication statuses with ``box.info``, we will see that "
"replication at master #1 is stopped (``1.upstream.status = stopped``). "
"Additionally, no data is replicated from that master (section "
"``1.downstream`` is missing in the report), because the downstream has "
"encountered the same error:"
msgstr ""
"Если мы проверим статус репликации с помощью ``box.info``, то увидим, что"
" репликация на мастере №1 остановлена (``1.upstream.status = stopped``). "
"Кроме того, данные с этого мастера не реплицируются (группа "
"``1.downstream`` отсутствует в отчете), поскольку встречается та же "
"ошибка:"

#: ../doc/1.10/book/replication/repl_duplicates.rst:87
msgid ""
"# replication statuses (report from master #3)\n"
"tarantool> box.info\n"
"---\n"
"- version: 1.7.4-52-g980d30092\n"
"  id: 3\n"
"  ro: false\n"
"  vclock: {1: 9, 2: 1000000, 3: 3}\n"
"  uptime: 557\n"
"  lsn: 3\n"
"  vinyl: []\n"
"  cluster:\n"
"    uuid: 34d13b1a-f851-45bb-8f57-57489d3b3c8b\n"
"  pid: 30445\n"
"  status: running\n"
"  signature: 1000012\n"
"  replication:\n"
"    1:\n"
"      id: 1\n"
"      uuid: 7ab6dee7-dc0f-4477-af2b-0e63452573cf\n"
"      lsn: 9\n"
"      upstream:\n"
"        peer: replicator@192.168.0.101:3301\n"
"        lag: 0.00050592422485352\n"
"        status: stopped\n"
"        idle: 445.8626639843\n"
"        message: Duplicate key exists in unique index 'primary' in space "
"'tester'\n"
"    2:\n"
"      id: 2\n"
"      uuid: 9afbe2d9-db84-4d05-9a7b-e0cbbf861e28\n"
"      lsn: 1000000\n"
"      upstream:\n"
"        status: follow\n"
"        idle: 201.99915885925\n"
"        peer: replicator@192.168.0.102:3301\n"
"        lag: 0.0015020370483398\n"
"      downstream:\n"
"        vclock: {1: 8, 2: 1000000, 3: 3}\n"
"    3:\n"
"      id: 3\n"
"      uuid: e826a667-eed7-48d5-a290-64299b159571\n"
"      lsn: 3\n"
"  uuid: e826a667-eed7-48d5-a290-64299b159571\n"
"..."
msgstr ""
"# статусы репликации (отчет от мастера №3)\n"
"tarantool> box.info\n"
"---\n"
"- version: 1.7.4-52-g980d30092\n"
"  id: 3\n"
"  ro: false\n"
"  vclock: {1: 9, 2: 1000000, 3: 3}\n"
"  uptime: 557\n"
"  lsn: 3\n"
"  vinyl: []\n"
"  cluster:\n"
"    uuid: 34d13b1a-f851-45bb-8f57-57489d3b3c8b\n"
"  pid: 30445\n"
"  status: running\n"
"  signature: 1000012\n"
"  replication:\n"
"    1:\n"
"      id: 1\n"
"      uuid: 7ab6dee7-dc0f-4477-af2b-0e63452573cf\n"
"      lsn: 9\n"
"      upstream:\n"
"        peer: replicator@192.168.0.101:3301\n"
"        lag: 0.00050592422485352\n"
"        status: stopped\n"
"        idle: 445.8626639843\n"
"        message: Duplicate key exists in unique index 'primary' in space "
"'tester'\n"
"    2:\n"
"      id: 2\n"
"      uuid: 9afbe2d9-db84-4d05-9a7b-e0cbbf861e28\n"
"      lsn: 1000000\n"
"      upstream:\n"
"        status: follow\n"
"        idle: 201.99915885925\n"
"        peer: replicator@192.168.0.102:3301\n"
"        lag: 0.0015020370483398\n"
"      downstream:\n"
"        vclock: {1: 8, 2: 1000000, 3: 3}\n"
"    3:\n"
"      id: 3\n"
"      uuid: e826a667-eed7-48d5-a290-64299b159571\n"
"      lsn: 3\n"
"  uuid: e826a667-eed7-48d5-a290-64299b159571\n"
"..."

#: ../doc/1.10/book/replication/repl_duplicates.rst:133
msgid "When replication is later manually resumed:"
msgstr "Когда позднее репликация возобновлена вручную:"

#: ../doc/1.10/book/replication/repl_duplicates.rst:135
msgid ""
"# resuming stopped replication (at all masters)\n"
"tarantool> original_value = box.cfg.replication\n"
"tarantool> box.cfg{replication={}}\n"
"tarantool> box.cfg{replication=original_value}"
msgstr ""
"# возобновление остановленной репликации (на всех мастерах)\n"
"tarantool> original_value = box.cfg.replication\n"
"tarantool> box.cfg{replication={}}\n"
"tarantool> box.cfg{replication=original_value}"

#: ../doc/1.10/book/replication/repl_duplicates.rst:142
msgid "... the faulty row in the write-ahead-log files is skipped."
msgstr "... запись с ошибкой в журнале упреждающей записи пропущена."

#: ../doc/1.10/book/replication/repl_duplicates.rst:148
msgid "Replication runs out of sync"
msgstr "Рассинхронизация репликации"

#: ../doc/1.10/book/replication/repl_duplicates.rst:150
msgid ""
"In a master-master cluster of two instances, suppose we make the "
"following operation:"
msgstr ""
"Предположим, что мы выполняем следующую операцию в кластере из двух "
"экземпляров с конфигурацией мастер-мастер:"

#: ../doc/1.10/book/replication/repl_duplicates.rst:153
msgid "tarantool> box.space.tester:upsert({1}, {{'=', 2, box.info.uuid}})"
msgstr "tarantool> box.space.tester:upsert({1}, {{'=', 2, box.info.uuid}})"

#: ../doc/1.10/book/replication/repl_duplicates.rst:157
msgid "When this operation is applied on both instances in the replica set:"
msgstr "Когда эта операция применяется на обоих экземплярах в наборе реплик:"

#: ../doc/1.10/book/replication/repl_duplicates.rst:159
msgid ""
"# at master #1\n"
"tarantool> box.space.tester:upsert({1}, {{'=', 2, box.info.uuid}})\n"
"# at master #2\n"
"tarantool> box.space.tester:upsert({1}, {{'=', 2, box.info.uuid}})"
msgstr ""
"# на мастере №1\n"
"tarantool> box.space.tester:upsert({1}, {{'=', 2, box.info.uuid}})\n"
"# на мастере №2\n"
"tarantool> box.space.tester:upsert({1}, {{'=', 2, box.info.uuid}})"

#: ../doc/1.10/book/replication/repl_duplicates.rst:166
msgid ""
"... we can have the following results, depending on the order of "
"execution:"
msgstr "... можно получить следующие результаты в зависимости порядка выполнения:"

#: ../doc/1.10/book/replication/repl_duplicates.rst:168
msgid "each master’s row contains the UUID from master #1,"
msgstr "каждая строка мастера содержит UUID из мастера №1,"

#: ../doc/1.10/book/replication/repl_duplicates.rst:169
msgid "each master’s row contains the UUID from master #2,"
msgstr "каждая строка мастера содержит UUID из мастера №2,"

#: ../doc/1.10/book/replication/repl_duplicates.rst:170
msgid "master #1 has the UUID of master #2, and vice versa."
msgstr "у мастера №1 UUID мастера №2, и наоборот."

#: ../doc/1.10/book/replication/repl_duplicates.rst:176
msgid "Commutative changes"
msgstr "Коммутативные изменения"

#: ../doc/1.10/book/replication/repl_duplicates.rst:178
msgid ""
"The cases described in the previous paragraphs represent examples of "
"**non-commutative** operations, i.e. operations whose result depends on "
"the execution order. On the contrary, for **commutative operations**, the"
" execution order does not matter."
msgstr ""
"Случаи, описанные в предыдущих абзацах, представляют собой примеры "
"**некоммутативных** операций, т.е. операций, результат которых зависит от"
" порядка их выполнения. Для **коммутативных операций** порядок выполнения"
" значения не имеет."

#: ../doc/1.10/book/replication/repl_duplicates.rst:183
msgid "Consider for example the following command:"
msgstr "Рассмотрим, например, следующую команду:"

#: ../doc/1.10/book/replication/repl_duplicates.rst:185
msgid "tarantool> box.space.tester:upsert{{1, 0}, {{'+', 2, 1)}"
msgstr "tarantool> box.space.tester:upsert{{1, 0}, {{'+', 2, 1)}"

#: ../doc/1.10/book/replication/repl_duplicates.rst:189
msgid ""
"This operation is commutative: we get the same result no matter in which "
"order the update is applied on the other masters."
msgstr ""
"Эта операция коммутативна: получаем одинаковый результат, независимо от "
"порядка, в котором обновление применяется на других мастерах."

#: ../doc/1.10/book/replication/repl_monitoring.rst:39
msgid "Monitoring a replica set"
msgstr "Мониторинг набора реплик"

#: ../doc/1.10/book/replication/repl_monitoring.rst:41
msgid ""
"To learn what instances belong in the replica set, and obtain statistics "
"for all these instances, issue a :ref:`box.info.replication "
"<box_info_replication>` request:"
msgstr ""
"Чтобы узнать, какие экземпляры входят в набор реплик и получить "
"статистику по всем этим экземплярам, передайте запрос "
":ref:`box.info.replication <box_info_replication>`:"

#: ../doc/1.10/book/replication/repl_monitoring.rst:44
msgid ""
"tarantool> box.info.replication\n"
"---\n"
"  replication:\n"
"    1:\n"
"      id: 1\n"
"      uuid: b8a7db60-745f-41b3-bf68-5fcce7a1e019\n"
"      lsn: 88\n"
"    2:\n"
"      id: 2\n"
"      uuid: cd3c7da2-a638-4c5d-ae63-e7767c3a6896\n"
"      lsn: 31\n"
"      upstream:\n"
"        status: follow\n"
"        idle: 43.187747001648\n"
"        peer: replicator@192.168.0.102:3301\n"
"        lag: 0\n"
"      downstream:\n"
"     vclock: {1: 31}\n"
"    3:\n"
"      id: 3\n"
"      uuid: e38ef895-5804-43b9-81ac-9f2cd872b9c4\n"
"      lsn: 54\n"
"      upstream:\n"
"        status: follow\n"
"        idle: 43.187621831894\n"
"        peer: replicator@192.168.0.103:3301\n"
"        lag: 2\n"
"      downstream:\n"
"        vclock: {1: 54}\n"
"..."
msgstr ""
"tarantool> box.info.replication\n"
"---\n"
"  replication:\n"
"    1:\n"
"      id: 1\n"
"      uuid: b8a7db60-745f-41b3-bf68-5fcce7a1e019\n"
"      lsn: 88\n"
"    2:\n"
"      id: 2\n"
"      uuid: cd3c7da2-a638-4c5d-ae63-e7767c3a6896\n"
"      lsn: 31\n"
"      upstream:\n"
"        status: follow\n"
"        idle: 43.187747001648\n"
"        peer: replicator@192.168.0.102:3301\n"
"        lag: 0\n"
"      downstream:\n"
"     vclock: {1: 31}\n"
"    3:\n"
"      id: 3\n"
"      uuid: e38ef895-5804-43b9-81ac-9f2cd872b9c4\n"
"      lsn: 54\n"
"      upstream:\n"
"        status: follow\n"
"        idle: 43.187621831894\n"
"        peer: replicator@192.168.0.103:3301\n"
"        lag: 2\n"
"      downstream:\n"
"        vclock: {1: 54}\n"
"..."

#: ../doc/1.10/book/replication/repl_monitoring.rst:77
msgid ""
"This report is for a master-master replica set of three instances, each "
"having its own instance id, UUID and log sequence number."
msgstr ""
"Данный отчет сгенерирован для набора реплик из трех экземпляров с "
"конфигурацией мастер-мастер, у каждого из которых есть свой собственный "
"ID экземпляра, UUID и номер записи в журнале."

#: ../doc/1.10/book/replication/repl_monitoring.rst:83
msgid ""
"The request was issued at master #1, and the reply includes statistics "
"for the other two masters, given in regard to master #1."
msgstr ""
"Запрос был выполнен с мастера №1, и ответ включает в себя статистику по "
"двум другим мастерам относительно мастера №1."

#: ../doc/1.10/book/replication/repl_monitoring.rst:86
msgid "The primary indicators of replication health are:"
msgstr "Основные индикаторы работоспособности репликации:"

#: ../doc/1.10/book/replication/repl_monitoring.rst:90
msgid ""
":ref:`idle <box_info_replication_upstream_idle>`, the time (in seconds) "
"since the instance received the last event from a master."
msgstr ""
":ref:`бездействие <box_info_replication_upstream_idle>`, время (в "
"секундах) с момента получения последнего события от мастера."

#: ../doc/1.10/book/replication/repl_monitoring.rst:93
msgid ""
"A replica sends heartbeat messages to the master every second, and the "
"master is programmed to reconnect automatically if it does not see "
"heartbeat messages within :ref:`replication_timeout <cfg_replication-"
"replication_timeout>` seconds."
msgstr ""
"Реплика отправляет сообщения контрольного сигнала на мастер каждую "
"секунду, и мастер запрограммирован на автоматическое переподключение, "
"если он не получает сообщения контрольного сигнала в течение количества "
"секунд, указанного в :ref:`replication_timeout <cfg_replication-"
"replication_timeout>`."

#: ../doc/1.10/book/replication/repl_monitoring.rst:98
msgid ""
"Therefore, in a healthy replication setup, ``idle`` should never exceed "
"``replication_timeout``: if it does, either the replication is lagging "
"seriously behind, because the master is running ahead of the replica, or "
"the network link between the instances is down."
msgstr ""
"Таким образом, в работоспособном состоянии значение ``idle`` никогда не "
"должно превышать значение ``replication_timeout``: в противном случае, "
"либо репликация сильно отстает, поскольку мастер опережает реплику, либо "
"отсутствует сетевое подключение между экземплярами."

#: ../doc/1.10/book/replication/repl_monitoring.rst:103
msgid ""
":ref:`lag <box_info_replication_upstream_lag>`, the time difference "
"between the local time at the instance, recorded when the event was "
"received, and the local time at another master recorded when the event "
"was written to the :ref:`write ahead log <internals-wal>` on that master."
msgstr ""
":ref:`отставание <box_info_replication_upstream_lag>`, разница во времени"
" между локальным временем на экземпляре, зарегистрированным при получении"
" события, и локальное время на другом мастере, зарегистрированное при "
"записи события в :ref:`журнал упреждающей записи <internals-wal>` на этом"
" мастере."

#: ../doc/1.10/book/replication/repl_monitoring.rst:108
msgid ""
"Since the ``lag`` calculation uses the operating system clocks from two "
"different machines, do not be surprised if it’s negative: a time drift "
"may lead to the remote master clock being consistently behind the local "
"instance's clock."
msgstr ""
"Поскольку при расчете ``отставания`` используются часы операционной "
"системы с двух разных машин, не удивляйтесь, получив отрицательное число:"
" смещение во времени может привести к постоянному запаздыванию времени на"
" удаленном мастере относительно часов на локальном экземпляре."

#: ../doc/1.10/book/replication/repl_monitoring.rst:112
msgid "For multi-master configurations, ``lag`` is the maximal lag."
msgstr "Для многомастерной конфигурации это максимально возможное отставание."

#: ../doc/1.10/book/replication/repl_recover.rst:39
msgid "Recovering from a degraded state"
msgstr "Восстановление после сбоя"

#: ../doc/1.10/book/replication/repl_recover.rst:41
msgid ""
"\"Degraded state\" is a situation when the master becomes unavailable -- "
"due to hardware or network failure, or due to a programming bug."
msgstr ""
"\"Сбой\" -- это ситуация, когда мастер становится недоступен вследствие "
"проблем с оборудованием, сетевых неполадок или программной ошибки."

#: ../doc/1.10/book/replication/repl_recover.rst:47
msgid ""
"In a master-replica set, if a master disappears, error messages appear on"
" the replicas stating that the connection is lost:"
msgstr ""
"В конфигурации мастер-реплика, если мастер пропадает, на репликах "
"выводятся сообщения об ошибке с указанием потери соединения:"

#: ../doc/1.10/book/replication/repl_recover.rst:50
msgid ""
"$ # messages from a replica's log\n"
"2017-06-14 16:23:10.993 [19153] main/105/applier/replicator@192.168.0. I>"
" can't read row\n"
"2017-06-14 16:23:10.993 [19153] main/105/applier/replicator@192.168.0. "
"coio.cc:349 !> SystemError\n"
"unexpected EOF when reading from socket, called on fd 17, aka "
"192.168.0.101:57815,\n"
"peer of 192.168.0.101:3301: Broken pipe\n"
"2017-06-14 16:23:10.993 [19153] main/105/applier/replicator@192.168.0. I>"
" will retry every 1 second\n"
"2017-06-14 16:23:10.993 [19153] relay/[::ffff:192.168.0.101]:/101/main I>"
" the replica has closed its socket, exiting\n"
"2017-06-14 16:23:10.993 [19153] relay/[::ffff:192.168.0.101]:/101/main C>"
" exiting the relay loop"
msgstr ""
"$ # сообщения из журнала реплики\n"
"2017-06-14 16:23:10.993 [19153] main/105/applier/replicator@192.168.0. I>"
" can't read row\n"
"2017-06-14 16:23:10.993 [19153] main/105/applier/replicator@192.168.0. "
"coio.cc:349 !> SystemError\n"
"unexpected EOF when reading from socket, called on fd 17, aka "
"192.168.0.101:57815,\n"
"peer of 192.168.0.101:3301: Broken pipe\n"
"2017-06-14 16:23:10.993 [19153] main/105/applier/replicator@192.168.0. I>"
" will retry every 1 second\n"
"2017-06-14 16:23:10.993 [19153] relay/[::ffff:192.168.0.101]:/101/main I>"
" the replica has closed its socket, exiting\n"
"2017-06-14 16:23:10.993 [19153] relay/[::ffff:192.168.0.101]:/101/main C>"
" exiting the relay loop"

#: ../doc/1.10/book/replication/repl_recover.rst:61
msgid "... and the master's status is reported as \"disconnected\":"
msgstr "... а статус мастера выводится как \"отключенный\" (disconnected):"

#: ../doc/1.10/book/replication/repl_recover.rst:63
msgid ""
"# report from replica #1\n"
"tarantool> box.info.replication\n"
"---\n"
"- 1:\n"
"    id: 1\n"
"    uuid: 70e8e9dc-e38d-4046-99e5-d25419267229\n"
"    lsn: 542\n"
"    upstream:\n"
"      peer: replicator@192.168.0.101:3301\n"
"      lag: 0.00026607513427734\n"
"      status: disconnected\n"
"      idle: 182.36929893494\n"
"      message: connect, called on fd 13, aka 192.168.0.101:58244\n"
"  2:\n"
"    id: 2\n"
"    uuid: fb252ac7-5c34-4459-84d0-54d248b8c87e\n"
"    lsn: 0\n"
"  3:\n"
"    id: 3\n"
"    uuid: fd7681d8-255f-4237-b8bb-c4fb9d99024d\n"
"    lsn: 0\n"
"    downstream:\n"
"      vclock: {1: 542}\n"
"..."
msgstr ""
"# отчет от реплики № 1\n"
"tarantool> box.info.replication\n"
"---\n"
"- 1:\n"
"    id: 1\n"
"    uuid: 70e8e9dc-e38d-4046-99e5-d25419267229\n"
"    lsn: 542\n"
"    upstream:\n"
"      peer: replicator@192.168.0.101:3301\n"
"      lag: 0.00026607513427734\n"
"      status: disconnected\n"
"      idle: 182.36929893494\n"
"      message: connect, called on fd 13, aka 192.168.0.101:58244\n"
"  2:\n"
"    id: 2\n"
"    uuid: fb252ac7-5c34-4459-84d0-54d248b8c87e\n"
"    lsn: 0\n"
"  3:\n"
"    id: 3\n"
"    uuid: fd7681d8-255f-4237-b8bb-c4fb9d99024d\n"
"    lsn: 0\n"
"    downstream:\n"
"      vclock: {1: 542}\n"
"..."

#: ../doc/1.10/book/replication/repl_recover.rst:90
msgid ""
"# report from replica #2\n"
"tarantool> box.info.replication\n"
"---\n"
"- 1:\n"
"    id: 1\n"
"    uuid: 70e8e9dc-e38d-4046-99e5-d25419267229\n"
"    lsn: 542\n"
"    upstream:\n"
"      peer: replicator@192.168.0.101:3301\n"
"      lag: 0.00027203559875488\n"
"      status: disconnected\n"
"      idle: 186.76988101006\n"
"      message: connect, called on fd 13, aka 192.168.0.101:58253\n"
"  2:\n"
"    id: 2\n"
"    uuid: fb252ac7-5c34-4459-84d0-54d248b8c87e\n"
"    lsn: 0\n"
"    upstream:\n"
"      status: follow\n"
"      idle: 186.76960110664\n"
"      peer: replicator@192.168.0.102:3301\n"
"      lag: 0.00020599365234375\n"
"  3:\n"
"    id: 3\n"
"    uuid: fd7681d8-255f-4237-b8bb-c4fb9d99024d\n"
"    lsn: 0\n"
"..."
msgstr ""
"# отчет от реплики № 2\n"
"tarantool> box.info.replication\n"
"---\n"
"- 1:\n"
"    id: 1\n"
"    uuid: 70e8e9dc-e38d-4046-99e5-d25419267229\n"
"    lsn: 542\n"
"    upstream:\n"
"      peer: replicator@192.168.0.101:3301\n"
"      lag: 0.00027203559875488\n"
"      status: disconnected\n"
"      idle: 186.76988101006\n"
"      message: connect, called on fd 13, aka 192.168.0.101:58253\n"
"  2:\n"
"    id: 2\n"
"    uuid: fb252ac7-5c34-4459-84d0-54d248b8c87e\n"
"    lsn: 0\n"
"    upstream:\n"
"      status: follow\n"
"      idle: 186.76960110664\n"
"      peer: replicator@192.168.0.102:3301\n"
"      lag: 0.00020599365234375\n"
"  3:\n"
"    id: 3\n"
"    uuid: fd7681d8-255f-4237-b8bb-c4fb9d99024d\n"
"    lsn: 0\n"
"..."

#: ../doc/1.10/book/replication/repl_recover.rst:120
msgid "To declare that one of the replicas must now take over as a new master:"
msgstr "Чтобы объявить, что одна из реплик должна стать новым мастером:"

#: ../doc/1.10/book/replication/repl_recover.rst:122
msgid "Make sure that the old master is gone for good:"
msgstr "Убедитесь, что старый мастер окончательно недоступен:"

#: ../doc/1.10/book/replication/repl_recover.rst:124
msgid ""
"change network routing rules to avoid any more packets being delivered to"
" the master, or"
msgstr ""
"измените правила маршрутизации в сети, чтобы больше не отправлять пакеты "
"на мастер, или"

#: ../doc/1.10/book/replication/repl_recover.rst:126
msgid "shut down the master instance, if you have access to the machine, or"
msgstr "отключите мастер-экземпляр, если у вас есть доступ к машине, или"

#: ../doc/1.10/book/replication/repl_recover.rst:127
msgid "power off the container or the machine."
msgstr "отключите питание контейнера или машины."

#: ../doc/1.10/book/replication/repl_recover.rst:129
msgid ""
"Say ``box.cfg{read_only=false, listen=URI}`` on the replica, and "
"``box.cfg{replication=URI}`` on the other replicas in the set."
msgstr ""
"Выполните ``box.cfg{read_only=false, listen=URI}`` на реплике и "
"``box.cfg{replication=URI}`` на других репликах в наборе."

#: ../doc/1.10/book/replication/repl_recover.rst:134
msgid ""
"If there are updates on the old master that were not propagated before "
"the old master went down, :ref:`re-apply them manually <admin-"
"disaster_recovery-master_replica>` to the new master using ``tarantoolctl"
" cat`` and ``tarantoolctl play`` commands."
msgstr ""
"Если на старом мастере есть обновления, не переданные до выхода старого "
"мастера из строя, :ref:`примените их вручную <admin-disaster_recovery-"
"master_replica>` на новом мастере с помощью команд ``tarantoolctl cat`` "
"и``tarantoolctl play``."

#: ../doc/1.10/book/replication/repl_recover.rst:139
msgid ""
"There is no automatic way for a replica to detect that the master is gone"
" forever, since sources of failure and replication environments vary "
"significantly. So the detection of degraded state requires an external "
"observer."
msgstr ""
"Реплика не может автоматически определить, что мастер не будет доступен в"
" будущем, поскольку причины отказа и среды репликации могут существенно "
"отличаться друг от друга. Поэтому обнаруживать сбой должен человек."

#: ../doc/1.10/book/replication/repl_remove_instances.rst:39
msgid "Removing instances"
msgstr "Удаление экземпляров"

#: ../doc/1.10/book/replication/repl_remove_instances.rst:41
msgid "To remove an instance from a replica set politely, follow these steps:"
msgstr ""
"Чтобы правильно удалить экземпляр из набора реплик, выполните следующие "
"действия:"

#: ../doc/1.10/book/replication/repl_remove_instances.rst:43
msgid "On the instance, run ``box.cfg{}`` with a blank replication source:"
msgstr "Выполните ``box.cfg{}`` с пустым источником репликации на экземпляре:"

#: ../doc/1.10/book/replication/repl_remove_instances.rst:45
msgid ""
"tarantool> box.cfg{replication=''}\n"
"---\n"
"..."
msgstr ""
"tarantool> box.cfg{replication=''}\n"
"---\n"
"..."

#: ../doc/1.10/book/replication/repl_remove_instances.rst:51
msgid ""
"The other instances in the replica set will carry on. If later the "
"removed instance rejoins, it will receive all the updates that the other "
"instances made while it was away."
msgstr ""
"Остальные экземпляры продолжают работать. Если выбывший экземпляр снова "
"возвращается в кластер, то он получит информацию о всех изменениях, "
"которые произошли на остальных экземплярах за время его отсутствия."

#: ../doc/1.10/book/replication/repl_remove_instances.rst:55
msgid ""
"If the instance is decommissioned forever, delete the instance's record "
"from the following locations:"
msgstr ""
"Если экземпляр больше не будет использоваться, удалите записи об "
"экземпляре из следующих мест:"

#: ../doc/1.10/book/replication/repl_remove_instances.rst:58
msgid ""
"the :ref:`replication <cfg_replication-replication>` parameter at all "
"running instances in the replica set:"
msgstr ""
"параметр :ref:`replication <cfg_replication-replication>` на всех "
"работающих экземплярах в наборе реплик:"

#: ../doc/1.10/book/replication/repl_remove_instances.rst:61
msgid "tarantool> box.cfg{replication=...}"
msgstr "tarantool> box.cfg{replication=...}"

#: ../doc/1.10/book/replication/repl_remove_instances.rst:65
msgid ""
"the :ref:`box.space._cluster <box_space-cluster>` tuple on any master "
"instance in the replica set. For example, for a record with instance id ="
" 3:"
msgstr ""
"кортеж :ref:`box.space._cluster <box_space-cluster>` на любом мастере в "
"наборе реплик. Например, для записи с ID экземпляра = 3:"

#: ../doc/1.10/book/replication/repl_remove_instances.rst:68
msgid ""
"tarantool> box.space._cluster:select{}\n"
"---\n"
"- - [1, '913f99c8-aee3-47f2-b414-53ed0ec5bf27']\n"
"  - [2, 'eac1aee7-cfeb-46cc-8503-3f8eb4c7de1e']\n"
"  - [3, '97f2d65f-2e03-4dc8-8df3-2469bd9ce61e']\n"
"...\n"
"tarantool> box.space._cluster:delete(3)\n"
"---\n"
"- [3, '97f2d65f-2e03-4dc8-8df3-2469bd9ce61e']\n"
"..."
msgstr ""
"tarantool> box.space._cluster:select{}\n"
"---\n"
"- - [1, '913f99c8-aee3-47f2-b414-53ed0ec5bf27']\n"
"  - [2, 'eac1aee7-cfeb-46cc-8503-3f8eb4c7de1e']\n"
"  - [3, '97f2d65f-2e03-4dc8-8df3-2469bd9ce61e']\n"
"...\n"
"tarantool> box.space._cluster:delete(3)\n"
"---\n"
"- [3, '97f2d65f-2e03-4dc8-8df3-2469bd9ce61e']\n"
"..."

#: ../doc/1.10/book/replication/repl_reseed.rst:39
msgid "Reseeding a replica"
msgstr "Перезагрузка реплики"

#: ../doc/1.10/book/replication/repl_reseed.rst:41
msgid ""
"If any of a replica's .xlog/.snap/.run files are corrupted or deleted, "
"you can \"re-seed\" the replica:"
msgstr ""
"Если один из файлов формата .xlog/.snap/.run на реплике поврежден или "
"удален, можно \"перезагрузить\" реплику данными:"

#: ../doc/1.10/book/replication/repl_reseed.rst:44
msgid ""
"Stop the replica and destroy all local database files (the ones with "
"extensions .xlog/.snap/.run/.inprogress)."
msgstr ""
"Остановите реплику и удалите все локальные файлы базы данных (с "
"расширениями .xlog/.snap/.run/.inprogress)."

#: ../doc/1.10/book/replication/repl_reseed.rst:47
msgid "Delete the replica's record from the following locations:"
msgstr "Удалите запись о реплике из следующих мест:"

#: ../doc/1.10/book/replication/repl_reseed.rst:49
msgid "the ``replication`` parameter at all running instances in the replica set."
msgstr "параметр ``replication`` на всех работающих экземплярах в наборе реплик."

#: ../doc/1.10/book/replication/repl_reseed.rst:50
msgid "the ``box.space._cluster`` tuple on the master instance."
msgstr "кортеж ``box.space._cluster`` на мастер-экземпляре."

#: ../doc/1.10/book/replication/repl_reseed.rst:52
msgid ""
"See section :ref:`Removing instances <replication-remove_instances>` for "
"details."
msgstr ""
"Для получения подробной информации см. Раздел :ref:`Удаление экземпляров "
"<replication-remove_instances>`."

#: ../doc/1.10/book/replication/repl_reseed.rst:55
msgid ""
"Restart the replica with the same instance file to contact the master "
"again. The replica will then catch up with the master by retrieving all "
"the master’s tuples."
msgstr ""
"Перезапустите реплику с тем же файлом экземпляра для повторного "
"подключения к мастеру. Реплика синхронизируется с мастером после "
"получения всех кортежей."

#: ../doc/1.10/book/replication/repl_reseed.rst:61
msgid ""
"Remember that this procedure works only if the master’s WAL files are "
"present."
msgstr ""
"Следует отметить, что эта процедура сработает только в том случае, если "
"на мастере есть WAL-файлы."

#: ../doc/1.10/dev_guide/build_contribute_index.rst:37
msgid "Build and contribute"
msgstr "Содействие в разработке"

#: ../doc/1.10/dev_guide/building_documentation.rst:39
msgid "Building documentation"
msgstr "Сборка документации"

#: ../doc/1.10/dev_guide/building_documentation.rst:41
msgid ""
"Tarantool documentation is built using a simplified markup system named "
"``Sphinx`` (see http://sphinx-doc.org). You can build a local version of "
"this documentation and you can contribute to Tarantool's version."
msgstr ""
"Документация Tarantool'а создается с помощью системы упрощенной разметки "
"под названием ``Sphinx`` (see http://sphinx-doc.org). Вы можете создать "
"локальную версию документации, а также содействовать в разработке версии "
"Tarantool'а."

#: ../doc/1.10/dev_guide/building_documentation.rst:45
msgid "You need to install these packages:"
msgstr "Необходимо установить следующие пакеты:"

#: ../doc/1.10/dev_guide/building_documentation.rst:47
msgid "``git`` (a program for downloading source repositories)"
msgstr "``git`` (программа для скачивания репозиториев исходного кода)"

#: ../doc/1.10/dev_guide/building_documentation.rst:48
msgid "``CMake`` version 2.8 or later (a program for managing the build process)"
msgstr ""
"``CMake`` версии 2.8 или более новой (программа для управления процессом "
"сборки)"

#: ../doc/1.10/dev_guide/building_documentation.rst:49
msgid ""
"``Python`` version greater than 2.6 -- preferably 2.7 -- and less than "
"3.0 (Sphinx is a Python-based tool)"
msgstr ""
"``Python`` версии выше 2.6 -- рекомендуется 2.7 -- и ниже 3.0 (Sphinx -- "
"это средство на основе Python)"

#: ../doc/1.10/dev_guide/building_documentation.rst:51
msgid ""
"``LaTeX`` (a system for document preparation; the installable package "
"name usually begins with the word 'texlive' or 'tetex', on Ubuntu the "
"name is 'texlive-latex-base')"
msgstr ""
"``LaTeX`` (система для подготовки документации; название устанавливаемого"
" пакета обычно начинается со слов 'texlive' или 'tetex', на Ubuntu "
"называется 'texlive-latex-base')"

#: ../doc/1.10/dev_guide/building_documentation.rst:54
msgid ""
"``ImageMagick`` (a system for image conversion; on MacOS install it using"
" ``brew``)"
msgstr ""
"``ImageMagick`` (система для конвертации изображений; на MacOS "
"установите, используя ``brew``)"

#: ../doc/1.10/dev_guide/building_documentation.rst:57
msgid "You need to install these Python modules:"
msgstr "Необходимо установить следующие модули Python:"

#: ../doc/1.10/dev_guide/building_documentation.rst:59
msgid "`pip <https://pypi.python.org/pypi/pip>`_, any version"
msgstr "`pip <https://pypi.python.org/pypi/pip>`_ любой версии"

#: ../doc/1.10/dev_guide/building_documentation.rst:60
msgid "`Sphinx <https://pypi.python.org/pypi/Sphinx>`_ version 1.4.4 or later"
msgstr "`Sphinx <https://pypi.python.org/pypi/Sphinx>`_ версии 1.4.4 или новее"

#: ../doc/1.10/dev_guide/building_documentation.rst:64
msgid ""
"If you encounter the \"Missing SPHINX_EXECUTABLE\" error message on Mac, "
"manually export the PATH variable:"
msgstr ""
"Если на Mac появится сообщение ошибки \"Missing SPHINX_EXECUTABLE\"  Mac,"
" экспортируйте переменную PATH вручную:"

#: ../doc/1.10/dev_guide/building_documentation.rst:67
msgid "export PATH=$PATH:/User/user_name/Library/Python/2.7/bin"
msgstr "export PATH=$PATH:/User/user_name/Library/Python/2.7/bin"

#: ../doc/1.10/dev_guide/building_documentation.rst:71
msgid "`sphinx-intl <https://pypi.python.org/pypi/sphinx-intl>`_ version 0.9.9"
msgstr "`sphinx-intl <https://pypi.python.org/pypi/sphinx-intl>`_ версии 0.9.9"

#: ../doc/1.10/dev_guide/building_documentation.rst:75
msgid ""
"If you encounter the \"Missing SPHINX_INTL_DIR\" error message on Mac, "
"manually export the SPHINX_INTL_DIR variable:"
msgstr ""
"Если на Mac появится сообщение ошибки \"Missing SPHINX_INTL_DIR\"  Mac, "
"экспортируйте переменную SPHINX_INTL_DIR вручную:"

#: ../doc/1.10/dev_guide/building_documentation.rst:78
msgid "export SPHINX_INTL_DIR=/User/user_name/Library/Python/2.7/bin"
msgstr "export SPHINX_INTL_DIR=/User/user_name/Library/Python/2.7/bin"

#: ../doc/1.10/dev_guide/building_documentation.rst:82
msgid "`lupa <https://pypi.python.org/pypi/lupa>`_ -- any version"
msgstr "`lupa <https://pypi.python.org/pypi/lupa>`_ -- любой версии"

#: ../doc/1.10/dev_guide/building_documentation.rst:86
msgid ""
"You should specify ``--user`` flag on Mac while installing Python modules"
" for correct installation."
msgstr ""
"Для правильной установки модулей Python на Mac следует указать флаг "
"``--user``."

#: ../doc/1.10/dev_guide/building_documentation.rst:89
msgid ""
"See more details about installation in the :ref:`build-from-source "
"<building_from_source>` section of this documentation."
msgstr ""
"Более подробную информацию об установке см. в разделе :ref:`Сборка из "
"исходных файлов <building_from_source>` данного руководства."

#: ../doc/1.10/dev_guide/building_documentation.rst:92
msgid ""
"Use ``git`` to download the latest source code of this documentation from"
" the GitHub repository ``tarantool/doc``, branch 1.10. For example, to "
"download to a local directory named ``~/tarantool-doc``:"
msgstr ""
"Используйте ``git`` для загрузки последней версии исходного кода "
"документации из репозитория GitHub ``tarantool/doc`` (ветка 1.10). "
"Например, для загрузки локальной директории под названием ``~/tarantool-"
"doc``:"

#: ../doc/1.10/dev_guide/building_documentation.rst:96
msgid "$ git clone https://github.com/tarantool/doc.git ~/tarantool-doc"
msgstr "$ git clone https://github.com/tarantool/doc.git ~/tarantool-doc"

#: ../doc/1.10/dev_guide/building_documentation.rst:100
msgid "Use ``CMake`` to initiate the build."
msgstr "Используйте ``CMake``, чтобы начать сборку."

#: ../doc/1.10/dev_guide/building_documentation.rst:102
msgid ""
"$ cd ~/tarantool-doc\n"
"$ make clean         # unnecessary, added for good luck\n"
"$ rm CMakeCache.txt  # unnecessary, added for good luck\n"
"$ cmake .            # initiate"
msgstr ""
"$ cd ~/tarantool-doc\n"
"$ make clean         # необязательно, добавлено на удачу\n"
"$ rm CMakeCache.txt  # необязательно, добавлено на удачу\n"
"$ cmake .            # начать"

#: ../doc/1.10/dev_guide/building_documentation.rst:109
msgid "Build a local version of the documentation."
msgstr "Создайте локальную версию документации."

#: ../doc/1.10/dev_guide/building_documentation.rst:111
msgid ""
"Run the ``make`` command with an appropriate option to specify which "
"documentation version to build."
msgstr ""
"Выполните команду ``make`` с соответствующей опцией, чтобы указать версию"
" собираемой документации."

#: ../doc/1.10/dev_guide/building_documentation.rst:114
msgid ""
"$ cd ~/tarantool-doc\n"
"$ make sphinx-html           # multi-page English version\n"
"$ make sphinx-singlehtml     # one-page English version\n"
"$ make sphinx-html-ru        # multi-page Russian version\n"
"$ make sphinx-singlehtml-ru  # one-page Russian version\n"
"$ make all                   # all versions plus the entire web-site"
msgstr ""
"$ cd ~/tarantool-doc\n"
"$ make sphinx-html           # многостраничная английская версия\n"
"$ make sphinx-singlehtml     # одностраничная английская версия\n"
"$ make sphinx-html-ru        # многостраничная русская версия\n"
"$ make sphinx-singlehtml-ru  # одностраничная русская версия\n"
"$ make all                   # все версии плюс веб-сайт полностью"

#: ../doc/1.10/dev_guide/building_documentation.rst:123
msgid "Documentation will be created in subdirectories of ``/output``:"
msgstr "Документация будет создана в поддиректориях ``/output``:"

#: ../doc/1.10/dev_guide/building_documentation.rst:125
msgid "``/output/en`` (files of the English version)"
msgstr "``/output/en`` (файлы английской версии)"

#: ../doc/1.10/dev_guide/building_documentation.rst:126
msgid "``/output/ru`` (files of the Russian version)"
msgstr "``/output/ru`` (файлы русской версии)"

#: ../doc/1.10/dev_guide/building_documentation.rst:128
msgid ""
"The entry point for each version is the ``index.html`` file in the "
"appropriate directory."
msgstr ""
"Точкой входа в каждую версию будет файл ``index.html`` в соответствующей "
"директории."

#: ../doc/1.10/dev_guide/building_documentation.rst:131
msgid "Set up a web server."
msgstr "Настройте веб-сервер."

#: ../doc/1.10/dev_guide/building_documentation.rst:133
msgid ""
"One way is to say ``make sphinx-webserver``. This will set up and run the"
" web server on port ``8000``:"
msgstr ""
"Один способ сделать это -- выполнить команду ``make sphinx-webserver``. "
"Веб-сервер будет настроен и запущен по порту ``8000``:"

#: ../doc/1.10/dev_guide/building_documentation.rst:136
msgid ""
"$ cd ~/tarantool-doc\n"
"$ make sphinx-html       # as an example, build the multi-page English "
"documentation\n"
"$ make sphinx-webserver  # set up and run the web server"
msgstr ""
"$ cd ~/tarantool-doc\n"
"$ make sphinx-html       # в качестве примера соберем многостраничную "
"версию документации на английском языке\n"
"$ make sphinx-webserver  # настройка и запуск веб-сервера"

#: ../doc/1.10/dev_guide/building_documentation.rst:142
msgid ""
"In case port ``8000`` is already in use, you can specify any other port "
"number that is bigger than ``1000`` in the ``tarantool-"
"doc/CMakeLists.txt`` file (search it for the ``sphinx-webserver`` target)"
" and rebuild cmake files:"
msgstr ""
"Если порт ``8000`` уже используется, можно указать любой другой номер "
"порта свыше ``1000`` в файле ``tarantool-doc/CMakeLists.txt`` (найдите "
"его по ``sphinx-webserver``) и повторно собрать файлы cmake:"

#: ../doc/1.10/dev_guide/building_documentation.rst:147
msgid ""
"$ cd ~/tarantool-doc\n"
"$ git clean -qfxd        # clean up old cmake files\n"
"$ cmake .                # rebuild cmake files\n"
"$ make sphinx-html       # as an example, build the multi-page English "
"documentation\n"
"$ make sphinx-webserver  # set up and run the web server on the custom "
"port"
msgstr ""
"$ cd ~/tarantool-doc\n"
"$ git clean -qfxd        # очистка старых файлов cmake\n"
"$ cmake .                # повторная сборка файлов cmake\n"
"$ make sphinx-html       # в качестве примера соберем многостраничную "
"версию документации на английском языке\n"
"$ make sphinx-webserver  # настройка и запуск веб-сервера по указанному "
"порту"

#: ../doc/1.10/dev_guide/building_documentation.rst:155
msgid "Or you can release the port:"
msgstr "Или можно освободить порт:"

#: ../doc/1.10/dev_guide/building_documentation.rst:157
msgid ""
"$ sudo lsof -i :8000  # get the process ID (PID)\n"
"COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME\n"
"Python 19516 user 3u IPv4 0xe7f8gc6be1b43c7 0t0 TCP *:irdmi (LISTEN)\n"
"$ sudo kill -9 19516  # kill the process"
msgstr ""
"$ sudo lsof -i :8000  # получение идентификатора процесса (PID)\n"
"COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME\n"
"Python 19516 user 3u IPv4 0xe7f8gc6be1b43c7 0t0 TCP *:irdmi (LISTEN)\n"
"$ sudo kill -9 19516  # удаление процесса"

#: ../doc/1.10/dev_guide/building_documentation.rst:164
msgid ""
"The other way is to run the built-in web server in Python. Make sure to "
"run it from the documentation ``output`` folder:"
msgstr ""
"Другой способ -- это запустить встроенный веб-сервер на Python. "
"Убедитесь, что запускаете его из папки документации ``output``:"

#: ../doc/1.10/dev_guide/building_documentation.rst:167
msgid ""
"$ cd ~/tarantool-doc/output\n"
"$ python -m SimpleHTTPServer 8000"
msgstr ""
"$ cd ~/tarantool-doc/output\n"
"$ python -m SimpleHTTPServer 8000"

#: ../doc/1.10/dev_guide/building_documentation.rst:172
msgid ""
"In case port ``8000`` is already in use, you can specify any other port "
"number that is bigger than ``1000``."
msgstr ""
"Если порт ``8000`` уже используется, можно указать любой другой номер "
"порта свыше ``1000`` в файле."

#: ../doc/1.10/dev_guide/building_documentation.rst:175
msgid ""
"Open your browser and enter ``127.0.0.1:8000/en/doc/1.10/`` into the "
"address box (or ``127.0.0.1:8000/ru/doc/1.10/`` if you built the Russian "
"documentation). Mind the trailing slash \"/\" in the address string."
msgstr ""
"Откройте браузер и введите ``127.0.0.1:8000/en/doc/1.10/`` в адресной "
"строке (или ``127.0.0.1:8000/ru/doc/1.10/`` для документации на русском)."
" Обратите внимание на завершающую косую черту \"/\" в адресной строке."

#: ../doc/1.10/dev_guide/building_documentation.rst:179
msgid ""
"If your local documentation build is valid, the manual will appear in the"
" browser."
msgstr ""
"Если сборка локальной документации выполнена правильно, руководство "
"появится в окне браузера."

#: ../doc/1.10/dev_guide/building_documentation.rst:182
msgid ""
"To contribute to documentation, use the `REST "
"<http://docutils.sourceforge.net/docs/user/rst/quickstart.html>`_ format "
"for drafting and submit your updates as a `pull request "
"<https://help.github.com/articles/creating-a-pull-request/>`_ via GitHub."
msgstr ""
"Чтобы содействовать в разработке документации, используйте формат `REST "
"<http://docutils.sourceforge.net/docs/user/rst/quickstart.html>`_ для "
"создания чернового варианта и отправьте изменения на рассмотрение в виде "
"`запроса на включение в проект "
"<https://help.github.com/articles/creating-a-pull-request/>`_ через "
"GitHub."

#: ../doc/1.10/dev_guide/building_documentation.rst:188
msgid ""
"To comply with the writing and formatting style, use the :ref:`guidelines"
" <documentation_guidelines>` provided in the documentation, common sense "
"and existing documents."
msgstr ""
"Чтобы текст соответствовал стилю и формату, воспользуйтесь "
":ref:`рекомендациями <documentation_guidelines>`, предоставленными в "
"документации, здравым смыслом и уже существующими документами."

#: ../doc/1.10/dev_guide/building_documentation.rst:194
msgid ""
"If you suggest creating a new documentation section (a whole new page), "
"it has to be saved to the relevant section at GitHub."
msgstr ""
"Если вы предлагаете создать новый раздел документации (отдельную "
"страницу), его следует сохранить в соответствующий раздел на GitHub."

#: ../doc/1.10/dev_guide/building_documentation.rst:197
msgid ""
"If you want to contribute to localizing this documentation (for example "
"into Russian), add your translation strings to ``.po`` files stored in "
"the corresponding locale directory (for example "
"``/locale/ru/LC_MESSAGES/`` for Russian). See more about localizing with "
"Sphinx at http://www.sphinx-doc.org/en/stable/intl.html"
msgstr ""
"Если вы хотите содействовать в локализации данной документации (например,"
" на русский), добавьте перевод в файлы формата ``.po``, которые хранятся "
"в директории соответствующей локали (например, "
"``/locale/ru/LC_MESSAGES/`` для русского языка). Более подробную "
"информацию о локализации с помощью Sphinx см. по ссылке http://www"
".sphinx-doc.org/en/stable/intl.html"

#: ../doc/1.10/dev_guide/building_from_source.rst:39
msgid "Building from source"
msgstr "Сборка из исходных файлов"

#: ../doc/1.10/dev_guide/building_from_source.rst:41
msgid ""
"For downloading Tarantool source and building it, the platforms can "
"differ and the preferences can differ. But strategically the steps are "
"always the same."
msgstr ""
"При загрузке исходных файлов и сборке Tarantool'а могут отличаться "
"платформы и настройки, но в целом предпринимаются одинаковые действия."

#: ../doc/1.10/dev_guide/building_from_source.rst:44
msgid "Get tools and libraries that will be necessary for building and testing."
msgstr ""
"Найдите средства и библиотеки, которые будут нужны для сборки и "
"тестирования."

#: ../doc/1.10/dev_guide/building_from_source.rst:47
msgid "The absolutely necessary ones are:"
msgstr "Абсолютно необходимы следующие:"

#: ../doc/1.10/dev_guide/building_from_source.rst:49
msgid ""
"A program for downloading source repositories. |br| For all platforms, "
"this is ``git``. It allows downloading the latest complete set of source "
"files from the Tarantool repository on GitHub."
msgstr ""
"Программа для скачивания репозиториев исходного кода. |br| Для всех "
"платформ это будет ``git``. Программа позволяет скачивать самый "
"актуальный набор исходных файлов из репозитория Tarantool'а на GitHub."

#: ../doc/1.10/dev_guide/building_from_source.rst:53
msgid ""
"A C/C++ compiler. |br| Ordinarily, this is ``gcc`` and ``g++`` version "
"4.6 or later. On Mac OS X, this is ``Clang`` version 3.2+."
msgstr ""
"Компилятор C/C++. |br| Как правило, это ``gcc`` и ``g++`` версии 4.6 или "
"более новой. На Mac OS X это ``Clang`` версии 3.2+."

#: ../doc/1.10/dev_guide/building_from_source.rst:56
msgid ""
"A program for managing the build process. |br| For all platforms, this is"
" ``CMake`` version 2.8+."
msgstr ""
"Программа для управления процессом сборки. |br| Для всех платформ это "
"будет ``CMake`` версии 2.8+."

#: ../doc/1.10/dev_guide/building_from_source.rst:59
msgid "`ReadLine <http://www.gnu.org/software/readline/>`_ library, any version"
msgstr ""
"библиотека `ReadLine <http://www.gnu.org/software/readline/>`_ любой "
"версии"

#: ../doc/1.10/dev_guide/building_from_source.rst:60
msgid "`ncurses <https://www.gnu.org/software/ncurses/>`_ library, any version"
msgstr "библиотека `ncurses <https://www.gnu.org/software/ncurses/>`_ любой версии"

#: ../doc/1.10/dev_guide/building_from_source.rst:61
msgid "`OpenSSL <https://www.openssl.org>`_ library, version 1.0.1+"
msgstr "библиотека `OpenSSL <https://www.openssl.org>`_ версии 1.0.1+"

#: ../doc/1.10/dev_guide/building_from_source.rst:62
msgid "`cURL <https://curl.haxx.se/>`_ library, version 0.725+"
msgstr "библиотека `cURL <https://curl.haxx.se/>`_ версии 0.725+"

#: ../doc/1.10/dev_guide/building_from_source.rst:63
msgid "`LibYAML <http://pyyaml.org/wiki/LibYAML>`_ library, version 0.1.4+"
msgstr "библиотека `LibYAML <http://pyyaml.org/wiki/LibYAML>`_ версии 0.1.4+"

#: ../doc/1.10/dev_guide/building_from_source.rst:64
msgid "`ICU <http://site.icu-project.org/download>`_ library, recent version"
msgstr "библиотека `ICU <http://site.icu-project.org/download>`_ последней версии"

#: ../doc/1.10/dev_guide/building_from_source.rst:66
msgid ""
"Python and modules. |br| Python interpreter is not necessary for building"
" Tarantool itself, unless you intend to use the \"Run the test suite\" "
"option in step 5. For all platforms, this is ``python`` version 2.7+ (but"
" not 3.x). You need the following Python modules:"
msgstr ""
"Python и его модули. |br| Интерпретатор для Python не нужен для сборки "
"самого Tarantool'а, если вы не планируете проводить тестирование из шага "
"5. Для всех платформ это будет ``python`` версии 2.7+ (но не 3.x). "
"Необходимы следующие модули Python:"

#: ../doc/1.10/dev_guide/building_from_source.rst:71
msgid "`pyyaml <https://pypi.python.org/pypi/PyYAML>`_ version 3.10"
msgstr "`pyyaml <https://pypi.python.org/pypi/PyYAML>`_ версии 3.10"

#: ../doc/1.10/dev_guide/building_from_source.rst:72
msgid "`argparse <https://pypi.python.org/pypi/argparse>`_ version 1.1"
msgstr "`argparse <https://pypi.python.org/pypi/argparse>`_ версии 1.1"

#: ../doc/1.10/dev_guide/building_from_source.rst:73
msgid ""
"`msgpack-python <https://pypi.python.org/pypi/msgpack-python>`_ version "
"0.4.6"
msgstr ""
"`msgpack-python <https://pypi.python.org/pypi/msgpack-python>`_ версии "
"0.4.6"

#: ../doc/1.10/dev_guide/building_from_source.rst:74
msgid "`gevent <https://pypi.python.org/pypi/gevent>`_ version 1.1.2"
msgstr "`gevent <https://pypi.python.org/pypi/gevent>`_ версии 1.1.2"

#: ../doc/1.10/dev_guide/building_from_source.rst:75
msgid "`six <https://pypi.python.org/pypi/six>`_ version 1.8.0"
msgstr "`six <https://pypi.python.org/pypi/six>`_ версии 1.8.0"

#: ../doc/1.10/dev_guide/building_from_source.rst:77
msgid "To install all required dependencies, follow the instructions for your OS:"
msgstr ""
"Чтобы установить все необходимые зависимости, следуйте инструкциям для "
"вашей ОС:"

#: ../doc/1.10/dev_guide/building_from_source.rst:79
msgid "For Debian/Ubuntu, say:"
msgstr "Если вы используете Debian/Ubuntu, выполните команду:"

#: ../doc/1.10/dev_guide/building_from_source.rst:81
msgid ""
"$ apt install -y build-essential cmake coreutils sed \\\n"
"      libreadline-dev libncurses5-dev libyaml-dev libssl-dev \\\n"
"      libcurl4-openssl-dev libunwind-dev libicu-dev \\\n"
"      python python-pip python-setuptools python-dev \\\n"
"      python-msgpack python-yaml python-argparse python-six python-gevent"
msgstr ""
"$ apt install -y build-essential cmake coreutils sed \\\n"
"      libreadline-dev libncurses5-dev libyaml-dev libssl-dev \\\n"
"      libcurl4-openssl-dev libunwind-dev libicu-dev \\\n"
"      python python-pip python-setuptools python-dev \\\n"
"      python-msgpack python-yaml python-argparse python-six python-gevent"

#: ../doc/1.10/dev_guide/building_from_source.rst:89
msgid "For RHEL/CentOS/Fedora, say:"
msgstr "Если вы используете RHEL/CentOS/Fedora, выполните команду:"

#: ../doc/1.10/dev_guide/building_from_source.rst:91
msgid ""
"$ yum install -y gcc gcc-c++ cmake coreutils sed \\\n"
"      readline-devel ncurses-devel libyaml-devel openssl-devel \\\n"
"      libcurl-devel libunwind-devel libicu-devel \\\n"
"      python python-pip python-setuptools python-devel \\\n"
"      python-msgpack python-yaml python-argparse python-six python-gevent"
msgstr ""
"$ yum install -y gcc gcc-c++ cmake coreutils sed \\\n"
"      readline-devel ncurses-devel libyaml-devel openssl-devel \\\n"
"      libcurl-devel libunwind-devel libicu-devel \\\n"
"      python python-pip python-setuptools python-devel \\\n"
"      python-msgpack python-yaml python-argparse python-six python-gevent"

#: ../doc/1.10/dev_guide/building_from_source.rst:99
msgid "For Mac OS X (instructions below are for OS X El Capitan):"
msgstr "Если вы используете Mac OS X (команды для OS X El Capitan):"

#: ../doc/1.10/dev_guide/building_from_source.rst:101
msgid "If you're using Homebrew as your package manager, say:"
msgstr ""
"Если вы пользуетесь Homebrew в качестве менеджера пакетов, выполните "
"команду:"

#: ../doc/1.10/dev_guide/building_from_source.rst:103
msgid ""
"$ brew install cmake autoconf binutils zlib \\\n"
"       readline ncurses libyaml openssl curl libunwind-headers icu4c \\\n"
"       && pip install python-daemon \\\n"
"       msgpack-python pyyaml configargparse six gevent"
msgstr ""
"$ brew install cmake autoconf binutils zlib \\\n"
"       readline ncurses libyaml openssl curl libunwind-headers icu4c \\\n"
"       && pip install python-daemon \\\n"
"       msgpack-python pyyaml configargparse six gevent"

#: ../doc/1.10/dev_guide/building_from_source.rst:110
msgid "Alternatively, download Apple's default Xcode toolset:"
msgstr "В противном случае, загрузите стандартный пакет Xcode для разработки:"

#: ../doc/1.10/dev_guide/building_from_source.rst:112
msgid ""
"$ xcode-select --install\n"
"$ xcode-select -switch /Applications/Xcode.app/Contents/Developer"
msgstr ""
"$ xcode-select --install\n"
"$ xcode-select -switch /Applications/Xcode.app/Contents/Developer"

#: ../doc/1.10/dev_guide/building_from_source.rst:117
msgid "For FreeBSD (instructions below are for FreeBSD 10.1 release), say:"
msgstr "Если вы используете FreeBSD (команды для FreeBSD 10.1), выполните команду:"

#: ../doc/1.10/dev_guide/building_from_source.rst:119
msgid ""
"$ pkg install -y sudo git cmake gmake gcc coreutils \\\n"
"      readline ncurses libyaml openssl curl libunwind icu \\\n"
"      python27 py27-pip py27-setuptools py27-daemon \\\n"
"      py27-msgpack-python py27-yaml py27-argparse py27-six py27-gevent"
msgstr ""
"$ pkg install -y sudo git cmake gmake gcc coreutils \\\n"
"      readline ncurses libyaml openssl curl libunwind icu \\\n"
"      python27 py27-pip py27-setuptools py27-daemon \\\n"
"      py27-msgpack-python py27-yaml py27-argparse py27-six py27-gevent"

#: ../doc/1.10/dev_guide/building_from_source.rst:126
msgid ""
"If some Python modules are not available in a repository, it is best to "
"set up the modules by getting a tarball and doing the setup with ``python"
" setup.py`` like this:"
msgstr ""
"Если некоторые модули Python недоступны в репозитории, лучше всего "
"произвести настройку модулей, скачав пакет в формате TAR и выполнив "
"установку с помощью ``python setup.py`` следующим образом:"

#: ../doc/1.10/dev_guide/building_from_source.rst:130
msgid ""
"$ # On some machines, this initial command may be necessary:\n"
"$ wget https://bootstrap.pypa.io/ez_setup.py -O - | sudo python\n"
"\n"
"$ # Python module for parsing YAML (pyYAML), for test suite:\n"
"$ # (If wget fails, check at http://pyyaml.org/wiki/PyYAML\n"
"$ # what the current version is.)\n"
"$ cd ~\n"
"$ wget http://pyyaml.org/download/pyyaml/PyYAML-3.10.tar.gz\n"
"$ tar -xzf PyYAML-3.10.tar.gz\n"
"$ cd PyYAML-3.10\n"
"$ sudo python setup.py install"
msgstr ""
"$ # На некоторых машинах может потребоваться такая начальная команда:\n"
"$ wget https://bootstrap.pypa.io/ez_setup.py -O - | sudo python\n"
"\n"
"$ # Модуль Python для анализа YAML (pyYAML) для набора тестов:\n"
"$ # (Если wget не работает, проверьте на сайте "
"http://pyyaml.org/wiki/PyYAML\n"
"$ # актуальность версии.)\n"
"$ cd ~\n"
"$ wget http://pyyaml.org/download/pyyaml/PyYAML-3.10.tar.gz\n"
"$ tar -xzf PyYAML-3.10.tar.gz\n"
"$ cd PyYAML-3.10\n"
"$ sudo python setup.py install"

#: ../doc/1.10/dev_guide/building_from_source.rst:144
msgid ""
"Finally, use Python ``pip`` to bring in Python packages that may not be "
"up-to-date in the distro repositories. (On CentOS 7, it will be necessary"
" to install ``pip`` first, with :code:`sudo yum install epel-release` "
"followed by :code:`sudo yum install python-pip`.)"
msgstr ""
"Наконец, используйте ``pip`` в Python, чтобы импортировать пакеты Python,"
" которые могут быть неактуальны в репозиториях дистрибутивов.  (В CentOS "
"7 будет необходимо сначала установить ``pip`` так: :code:`sudo yum "
"install epel-release`, а затем :code:`sudo yum install python-pip`.)"

#: ../doc/1.10/dev_guide/building_from_source.rst:150
msgid ""
"$ pip install -r \\\n"
"      https://raw.githubusercontent.com/tarantool/test-"
"run/master/requirements.txt \\\n"
"      --user"
msgstr ""
"$ pip install -r \\\n"
"      https://raw.githubusercontent.com/tarantool/test-"
"run/master/requirements.txt \\\n"
"      --user"

#: ../doc/1.10/dev_guide/building_from_source.rst:156
msgid "This step is only necessary once, the first time you do a download."
msgstr "Это действие следует выполнить только один раз при первой загрузке."

#: ../doc/1.10/dev_guide/building_from_source.rst:158
msgid ""
"Use ``git`` to download the latest Tarantool source code from the GitHub "
"repository ``tarantool/tarantool``, branch 1.10, to a local directory "
"named ``~/tarantool``, for example:"
msgstr ""
"Используйте ``git``, чтобы загрузить последний исходный код Tarantool'а "
"из репозитория  на GitHub ``tarantool/tarantool`` (ветка 1.10) в "
"локальную директорию ``~/tarantool``, например:"

#: ../doc/1.10/dev_guide/building_from_source.rst:162
msgid ""
"$ git clone --recursive https://github.com/tarantool/tarantool.git -b "
"1.10 ~/tarantool"
msgstr ""
"$ git clone --recursive https://github.com/tarantool/tarantool.git -b "
"1.10 ~/tarantool"

#: ../doc/1.10/dev_guide/building_from_source.rst:166
msgid ""
"On rare occasions, the submodules need to be updated again with the "
"command:"
msgstr ""
"В редких случаях вложенные модули необходимо снова обновить с помощью "
"команды:"

#: ../doc/1.10/dev_guide/building_from_source.rst:169
msgid "$ git submodule update --init --recursive"
msgstr "$ git submodule update --init --recursive"

#: ../doc/1.10/dev_guide/building_from_source.rst:173
msgid "Use CMake to initiate the build."
msgstr "Используйте CMake, чтобы начать сборку."

#: ../doc/1.10/dev_guide/building_from_source.rst:175
msgid ""
"$ cd ~/tarantool\n"
"$ make clean         # unnecessary, added for good luck\n"
"$ rm CMakeCache.txt  # unnecessary, added for good luck\n"
"$ cmake .            # start initiating with build type=Debug"
msgstr ""
"$ cd ~/tarantool\n"
"$ make clean         # необязательно, добавлено на удачу\n"
"$ rm CMakeCache.txt  # необязательно, добавлено на удачу\n"
"$ cmake .            # начать с типом сборки = Debug (отладка)"

#: ../doc/1.10/dev_guide/building_from_source.rst:182
msgid ""
"On some platforms, it may be necessary to specify the C and C++ versions,"
" for example:"
msgstr ""
"На некоторых платформах может потребоваться указать версии C и C++, "
"например:"

#: ../doc/1.10/dev_guide/building_from_source.rst:185
msgid "$ CC=gcc-4.8 CXX=g++-4.8 cmake ."
msgstr "$ CC=gcc-4.8 CXX=g++-4.8 cmake ."

#: ../doc/1.10/dev_guide/building_from_source.rst:189
msgid ""
"The CMake option for specifying build type is "
":samp:`-DCMAKE_BUILD_TYPE={type}`, where :samp:`{type}` can be:"
msgstr ""
"Чтобы указать тип сборки в CMake используется опция "
":samp:`-DCMAKE_BUILD_TYPE={type}`, где :samp:`{type}` может быть:"

#: ../doc/1.10/dev_guide/building_from_source.rst:192
msgid "``Debug`` -- used by project maintainers"
msgstr "``Debug`` -- отладка, используется эксплуатационным персоналом на проекте"

#: ../doc/1.10/dev_guide/building_from_source.rst:193
msgid "``Release`` -- used only if the highest performance is required"
msgstr ""
"``Release`` -- релиз, используется только при необходимости высокой "
"производительности"

#: ../doc/1.10/dev_guide/building_from_source.rst:194
msgid ""
"``RelWithDebInfo`` -- used for production, also provides debugging "
"capabilities"
msgstr ""
"``RelWithDebInfo`` -- используется для сборки в эксплуатации, также "
"предоставляет возможности отладки"

#: ../doc/1.10/dev_guide/building_from_source.rst:196
msgid ""
"The CMake option for hinting that the result will be distributed is "
":code:`-DENABLE_DIST=ON`. If this option is on, then later ``make "
"install`` will install ``tarantoolctl`` files in addition to "
"``tarantool`` files."
msgstr ""
"Чтобы указать в CMake, что результат будет распределен, используется "
"опция :code:`-DENABLE_DIST=ON`. При наличии такой опции ``make install`` "
"в дальнейшем установит файлы ``tarantoolctl`` в дополнение к файлам "
"``tarantool``."

#: ../doc/1.10/dev_guide/building_from_source.rst:200
msgid "Use ``make`` to complete the build."
msgstr "Используйте ``make`` для завершения сборки."

#: ../doc/1.10/dev_guide/building_from_source.rst:202
msgid "$ make"
msgstr "$ make"

#: ../doc/1.10/dev_guide/building_from_source.rst:208
msgid "For FreeBSD, use ``gmake`` instead."
msgstr "В FreeBSD используйте вместо этого ``gmake``."

#: ../doc/1.10/dev_guide/building_from_source.rst:210
msgid "This creates the 'tarantool' executable in the ``src/`` directory."
msgstr "При этом создается исполняемый файл 'tarantool' в директории ``src/``."

#: ../doc/1.10/dev_guide/building_from_source.rst:212
msgid ""
"Next, it's highly recommended to say ``make install`` to install "
"Tarantool to the ``/usr/local`` directory and keep your system clean. "
"However, it is possible to run the Tarantool executable without "
"installation."
msgstr ""
"Далее настоятельно рекомендуется выполнить команду ``make install`` для "
"установки Tarantool'а в директорию ``/usr/local`` и поддержания порядка в"
" системе. Однако, можно запустить исполняемый файл и без установки."

#: ../doc/1.10/dev_guide/building_from_source.rst:216
msgid "Run the test suite."
msgstr "Проведите тестирование."

#: ../doc/1.10/dev_guide/building_from_source.rst:218
msgid ""
"This step is optional. Tarantool's developers always run the test suite "
"before they publish new versions. You should run the test suite too, if "
"you make any changes in the code. Assuming you downloaded to "
"``~/tarantool``, the principal steps are:"
msgstr ""
"Это необязательное действие. Разработчики Tarantool'а всегда проводят "
"тестирование до публикации новых версий. Следует проводить тестирование, "
"если внесены изменения в код. Итак, после загрузки в ``~/tarantool`` "
"основные действия:"

#: ../doc/1.10/dev_guide/building_from_source.rst:223
msgid ""
"$ # make a subdirectory named `bin`\n"
"$ mkdir ~/tarantool/bin\n"
"\n"
"$ # link Python to bin (this may require superuser privileges)\n"
"$ ln /usr/bin/python ~/tarantool/bin/python\n"
"\n"
"$ # get to the test subdirectory\n"
"$ cd ~/tarantool/test\n"
"\n"
"$ # run tests using Python\n"
"$ PATH=~/tarantool/bin:$PATH ./test-run.py"
msgstr ""
"$ # создание поддиректории под названием `bin`\n"
"$ mkdir ~/tarantool/bin\n"
"\n"
"$ # привязка Python к bin (могут потребовать права пользователя "
"superuser)\n"
"$ ln /usr/bin/python ~/tarantool/bin/python\n"
"\n"
"$ # переход в поддиректорию с тестами\n"
"$ cd ~/tarantool/test\n"
"\n"
"$ # проведение тестирования с помощью Python\n"
"$ PATH=~/tarantool/bin:$PATH ./test-run.py"

#: ../doc/1.10/dev_guide/building_from_source.rst:237
msgid "The output should contain reassuring reports, for example:"
msgstr "Вывод должен включать в себя обнадеживающие результаты, например:"

#: ../doc/1.10/dev_guide/building_from_source.rst:239
msgid ""
"======================================================================\n"
"TEST                                            RESULT\n"
"------------------------------------------------------------\n"
"box/bad_trigger.test.py                         [ pass ]\n"
"box/call.test.py                                [ pass ]\n"
"box/iproto.test.py                              [ pass ]\n"
"box/xlog.test.py                                [ pass ]\n"
"box/admin.test.lua                              [ pass ]\n"
"box/auth_access.test.lua                        [ pass ]\n"
"... etc."
msgstr ""
"======================================================================\n"
"TEST                                            RESULT\n"
"------------------------------------------------------------\n"
"box/bad_trigger.test.py                         [ pass ]\n"
"box/call.test.py                                [ pass ]\n"
"box/iproto.test.py                              [ pass ]\n"
"box/xlog.test.py                                [ pass ]\n"
"box/admin.test.lua                              [ pass ]\n"
"box/auth_access.test.lua                        [ pass ]\n"
"... etc."

#: ../doc/1.10/dev_guide/building_from_source.rst:252
msgid "To prevent later confusion, clean up what's in the ``bin`` subdirectory:"
msgstr "Во избежание путаницы очистите поддиректорию ``bin``:"

#: ../doc/1.10/dev_guide/building_from_source.rst:254
msgid ""
"$ rm ~/tarantool/bin/python\n"
"$ rmdir ~/tarantool/bin"
msgstr ""
"$ rm ~/tarantool/bin/python\n"
"$ rmdir ~/tarantool/bin"

#: ../doc/1.10/dev_guide/building_from_source.rst:259
msgid "Make RPM and Debian packages."
msgstr "Создайте пакеты RPM и Debian."

#: ../doc/1.10/dev_guide/building_from_source.rst:261
msgid ""
"This step is optional. It's only for people who want to redistribute "
"Tarantool. We highly recommend to use official packages from the "
"`tarantool.org <https://tarantool.org/download.html>`_ web-site. However,"
" you can build RPM and Debian packages using `PackPack "
"<https://github.com/packpack/packpack>`_ or using the ``dpkg-"
"buildpackage`` or ``rpmbuild`` tools. Please consult ``dpkg`` or "
"``rpmbuild`` documentation for details."
msgstr ""
"Это необязательное действие, которое следует выполнить только тем, кто "
"хочет перераспределить Tarantool. Мы настоятельно рекомендуем "
"использовать официальные пакеты с сайта `tarantool.org "
"<https://tarantool.org/download.html>`_. Однако, можно собрать пакеты RPM"
" и Debian с помощью `PackPack <https://github.com/packpack/packpack>`_ "
"или путем использования средств ``dpkg-buildpackage`` или ``rpmbuild``. "
"Для получения более подробной информации обратитесь к документации по "
"``dpkg`` или ``rpmbuild``."

#: ../doc/1.10/dev_guide/building_from_source.rst:269
msgid "Verify your Tarantool installation."
msgstr "Проверьте установку Tarantool'а."

#: ../doc/1.10/dev_guide/building_from_source.rst:271
msgid ""
"$ # if you installed tarantool locally after build\n"
"$ tarantool\n"
"$ # - OR -\n"
"$ # if you didn't install tarantool locally after build\n"
"$ ./src/tarantool"
msgstr ""
"$ # если tarantool установлен локально после сборки\n"
"$ tarantool\n"
"$ # - ИЛИ -\n"
"$ # если tarantool не установлен локально после сборки\n"
"$ ./src/tarantool"

#: ../doc/1.10/dev_guide/building_from_source.rst:279
msgid "This starts Tarantool in the interactive mode."
msgstr "Tarantool запустится в интерактивном режиме."

#: ../doc/1.10/dev_guide/building_from_source.rst:281
msgid "See also:"
msgstr "См. также:"

#: ../doc/1.10/dev_guide/building_from_source.rst:283
msgid ""
"`Tarantool README.md "
"<https://github.com/tarantool/tarantool/blob/1.10/README.md>`_"
msgstr ""
"`Tarantool README.md "
"<https://github.com/tarantool/tarantool/blob/1.10/README.md>`_"

#: ../doc/1.10/dev_guide/c_style_guide.rst:37
msgid "C Style Guide"
msgstr "Руководство по написанию кода на C"

#: ../doc/1.10/dev_guide/c_style_guide.rst:39
msgid ""
"The project's coding style is based on a version of the Linux kernel "
"coding style."
msgstr ""
"Стиль программирования проекта основан на версии стиля программирования "
"ядра Linux."

#: ../doc/1.10/dev_guide/c_style_guide.rst:41
msgid ""
"The latest version of the Linux style can be found at: "
"http://www.kernel.org/doc/Documentation/CodingStyle"
msgstr ""
"Последнюю версию стиля программирования Linux можно найти по ссылке: "
"http://www.kernel.org/doc/Documentation/CodingStyle"

#: ../doc/1.10/dev_guide/c_style_guide.rst:44
msgid ""
"Since it is open for changes, the version of style that we follow, one "
"from 2007-July-13, will be also copied later in this document."
msgstr ""
"Мы придерживаемся версии от 13 июля 2007 года, которая приводится ниже в "
"документе."

#: ../doc/1.10/dev_guide/c_style_guide.rst:47
msgid ""
"There are a few additional guidelines, either unique to Tarantool or "
"deviating from the Kernel guidelines."
msgstr ""
"Здесь мы приводим дополнительные рекомендации, которые либо специфичны "
"для Tarantool'а, либо отличаются от рекомендаций по программированию ядра"
" Linux."

#: ../doc/1.10/dev_guide/c_style_guide.rst:50
msgid ""
"Chapters 10 \"Kconfig configuration files\", 11 \"Data structures\", 13 "
"\"Printing kernel messages\", 14 \"Allocating memory\" and 17 \"Don't re-"
"invent the kernel macros\" do not apply, since they are specific to Linux"
" kernel programming environment."
msgstr ""
"Следующие главы не применимы, поскольку они специфичны для среды "
"программирования ядра Linux: 10 \"Конфигурационные файлы Kconfig\", 11 "
"\"Структуры данных\", 13 \"Вывод сообщений ядра\", 14 \"Выделение "
"памяти\" и 17 \"Не изобретайте макросы снова\"."

#: ../doc/1.10/dev_guide/c_style_guide.rst:55
msgid "The rest of Linux Kernel Coding Style is amended as follows:"
msgstr ""
"Остальные главы документа \"Стиль программирования ядра Linux\" "
"изменяются следующим образом:"

#: ../doc/1.10/dev_guide/c_style_guide.rst:59
msgid "General guidelines"
msgstr "Общие рекомендации"

#: ../doc/1.10/dev_guide/c_style_guide.rst:61
msgid ""
"We use Git for revision control. The latest development is happening in "
"the default branch (currently ``2.0``). Our git repository is hosted on "
"github, and can be checked out with ``git clone "
"git://github.com/tarantool/tarantool.git`` (anonymous read-only access)."
msgstr ""
"Для управления версиями мы пользуемся Git. Последние разработки ведутся в"
" ветке, используемой по умолчанию (сейчас ``2.0``). Наш git-репозиторий "
"находится на github, его можно посмотреть выгрузить с помощью ``git clone"
" git://github.com/tarantool/tarantool.git`` (для анонимного пользователя "
"доступ только для чтения)."

#: ../doc/1.10/dev_guide/c_style_guide.rst:66
msgid ""
"If you have any questions about Tarantool internals, please post them on "
"the developer discussion list, "
"https://groups.google.com/forum/#!forum/tarantool. However, please be "
"warned: Launchpad silently deletes posts from non-subscribed members, "
"thus please be sure to have subscribed to the list prior to posting. "
"Additionally, some engineers are always present on #tarantool channel on "
"irc.freenode.net."
msgstr ""
"Если у вас есть вопросы о внутреннем устройстве Tarantool'а, разместите "
"их в списке вопросов к обсуждению для разработчиков: "
"https://groups.google.com/forum/#!forum/tarantool. Однако, предупреждаем:"
" Launchpad молча удаляет сообщения от тех, кто не является подписчиком, "
"поэтому обязательно подпишитесь на список перед публикацией. Кроме того, "
"несколько инженеров всегда находятся на канале #tarantool в "
"irc.freenode.net."

#: ../doc/1.10/dev_guide/c_style_guide.rst:74
msgid "Commenting style"
msgstr "Стиль комментирования кода"

#: ../doc/1.10/dev_guide/c_style_guide.rst:76
msgid ""
"Use Doxygen comment format, Javadoc flavor, i.e. `@tag` rather than "
"`\\tag`. The main tags in use are @param, @retval, @return, @see, @note "
"and @todo."
msgstr ""
"Используйте формат комментирования Doxygen, разновидность Javadoc, то "
"есть `@tag` вместо `\\tag`. Основные используемые теги: @param, @retval, "
"@return, @see, @note и @todo."

#: ../doc/1.10/dev_guide/c_style_guide.rst:79
msgid ""
"Every function, except perhaps a very short and obvious one, should have "
"a comment. A sample function comment may look like below:"
msgstr ""
"Каждая функция, за исключением, пожалуй, очень короткой и очевидной, "
"должна быть прокомментирована. Пример комментария функции может выглядеть"
" следующим образом:"

#: ../doc/1.10/dev_guide/c_style_guide.rst:82
msgid ""
"/** Write all data to a descriptor.\n"
" *\n"
" * This function is equivalent to 'write', except it would ensure\n"
" * that all data is written to the file unless a non-ignorable\n"
" * error occurs.\n"
" *\n"
" * @retval 0  Success\n"
" *\n"
" * @reval  1  An error occurred (not EINTR)\n"
" * /\n"
"static int\n"
"write_all(int fd, void \\*data, size_t len);"
msgstr ""
"/** Запись всех данных в дескриптор.\n"
" *\n"
" * Эта функция аналогична 'write' во всём кроме того, что она "
"обеспечивает\n"
" * запись всех данных в файл, если не возникает ошибка,\n"
" * которую нельзя игнорировать.\n"
" *\n"
" * @retval 0  Выполнено\n"
" *\n"
" * @reval  1  Ошибка (не EINTR)\n"
" * /\n"
"static int\n"
"write_all(int fd, void \\*data, size_t len);"

#: ../doc/1.10/dev_guide/c_style_guide.rst:97
msgid ""
"Public structures and important structure members should be commented as "
"well."
msgstr ""
"Доступные структуры и важные элементы структуры также должны быть "
"прокомментированы."

#: ../doc/1.10/dev_guide/c_style_guide.rst:101
msgid "Header files"
msgstr "Файлы заголовка"

#: ../doc/1.10/dev_guide/c_style_guide.rst:103
msgid ""
"Use header guards. Put the header guard in the first line in the header, "
"before the copyright or declarations. Use all-uppercase name for the "
"header guard. Derive the header guard name from the file name, and append"
" _INCLUDED to get a macro name. For example, core/log_io.h -> "
"CORE_LOG_IO_H_INCLUDED. In ``.c`` (implementation) file, include the "
"respective declaration header before all other headers, to ensure that "
"the header is self- sufficient. Header \"header.h\" is self-sufficient if"
" the following compiles without errors:"
msgstr ""
"Используйте защиту заголовка. Поместите защиту заголовка в первую строку "
"заголовка до авторского права или объявления. Для защиты заголовка "
"используйте имя в верхнем регистре. Выводите имя защиты заголовка из "
"имени файла и добавьте _INCLUDED, чтобы получить имя макроса. Например, "
"core/log_io.h -> CORE_LOG_IO_H_INCLUDE. В файле ``.c`` (реализация) "
"следует включить соответствующий заголовок с объявлением перед всеми "
"другими заголовками, чтобы убедиться, что заголовок является автономным. "
"Заголовок \"header.h\" является автономным, если компилируется без "
"ошибок:"

#: ../doc/1.10/dev_guide/c_style_guide.rst:111
msgid "#include \"header.h\""
msgstr "#include \"header.h\""

#: ../doc/1.10/dev_guide/c_style_guide.rst:117
msgid "Allocating memory"
msgstr "Выделение памяти"

#: ../doc/1.10/dev_guide/c_style_guide.rst:119
msgid ""
"Prefer the supplied slab (salloc) and pool (palloc) allocators to "
"malloc()/free() for any performance-intensive or large  memory "
"allocations. Repetitive use of malloc()/free() can lead to memory "
"fragmentation and should therefore be avoided."
msgstr ""
"Предпочтительно использовать предоставляемые распределители slab'ов "
"(salloc) и пулов (palloc) вместо malloc()/free() для любых операций "
"выделения памяти большого объема. Многократное использование "
"malloc()/free() может привести к фрагментации памяти, чего следует "
"избегать."

#: ../doc/1.10/dev_guide/c_style_guide.rst:123
msgid ""
"Always free all allocated memory, even allocated  at start-up. We aim at "
"being valgrind leak-check clean, and in most cases it's just as easy to "
"free() the allocated memory as it is to write a valgrind suppression. "
"Freeing all allocated memory is also dynamic-load friendly: assuming a "
"plug-in can be dynamically loaded and unloaded multiple times, reload "
"should not lead to a memory leak."
msgstr ""
"Всегда освобождайте всю выделенную память, даже выделенную при запуске. "
"Мы стремимся к тому, чтобы valgrind не находил утечек памяти, и в "
"большинстве случаев так же легко освободить выделенную память по free(), "
"как и записать подавление valgrind. Освобождение всей выделенной памяти "
"также помогает динамическому балансированию нагрузки: предполагается, что"
" подключаемый модуль может динамически загружаться и выгружаться "
"несколько раз, перезагрузка не должна приводить к утечке памяти."

#: ../doc/1.10/dev_guide/c_style_guide.rst:131
msgid "Other"
msgstr "Прочее"

#: ../doc/1.10/dev_guide/c_style_guide.rst:133
msgid ""
"Select GNU C99 extensions are acceptable. It's OK to mix declarations and"
" statements, use true and false."
msgstr ""
"Допускаются расширения GNU C99. Можно смешивать операторы и объявления в "
"выражениях."

#: ../doc/1.10/dev_guide/c_style_guide.rst:136
msgid ""
"The not-so-current list of all GCC C extensions can be found at: "
"http://gcc.gnu.org/onlinedocs/gcc-4.3.5/gcc/C-Extensions.html"
msgstr ""
"Не слишком актуальный список всех расширений семейства языка C можно "
"найти по ссылке: "
"http://gcc.gnu.org/onlinedocs/gcc-4.3.5/gcc/C-Extensions.html"

#: ../doc/1.10/dev_guide/c_style_guide.rst:141
msgid "Linux kernel coding style"
msgstr "Стиль программирования ядра Linux"

#: ../doc/1.10/dev_guide/c_style_guide.rst:143
msgid ""
"This is a short document describing the preferred coding style for the "
"linux kernel.  Coding style is very personal, and I won't _force_ my "
"views on anybody, but this is what goes for anything that I have to be "
"able to maintain, and I'd prefer it for most other things too.  Please at"
" least consider the points made here."
msgstr ""
"В данном коротком документе описывается предпочтительный стиль "
"программирования для ядра Linux. Стиль программирования -- это личное "
"дело каждого, и я не буду никому _навязывать_ свои убеждения, но "
"поскольку это касается всего, что я должен поддерживать, я бы предпочел, "
"чтобы эти правила использовали повсеместно. Пожалуйста, хотя бы "
"рассмотрите описываемые здесь пункты."

#: ../doc/1.10/dev_guide/c_style_guide.rst:149
msgid ""
"First off, I'd suggest printing out a copy of the GNU coding standards, "
"and NOT read it.  Burn them, it's a great symbolic gesture."
msgstr ""
"Для начала я предлагаю вам распечатать копию стандартов написания кода "
"GNU и НЕ читать их. Сожгите их в качестве весьма символического жеста."

#: ../doc/1.10/dev_guide/c_style_guide.rst:152
msgid "Anyway, here goes:"
msgstr "В любом случае, поехали:"

#: ../doc/1.10/dev_guide/c_style_guide.rst:156
msgid "Chapter 1: Indentation"
msgstr "Глава 1: Отступы"

#: ../doc/1.10/dev_guide/c_style_guide.rst:158
msgid ""
"Tabs are 8 characters, and thus indentations are also 8 characters. There"
" are heretic movements that try to make indentations 4 (or even 2!) "
"characters deep, and that is akin to trying to define the value of PI to "
"be 3."
msgstr ""
"Табуляция составляет 8 символов, то есть отступы будут также в 8 "
"символов. Появляются отступнические движения, которые призывают делать "
"отступы в 4 (или даже 2!) символа, а это сродни попытке округлить число "
"Пи до 3."

#: ../doc/1.10/dev_guide/c_style_guide.rst:163
msgid ""
"Rationale: The whole idea behind indentation is to clearly define where a"
" block of control starts and ends.  Especially when you've been looking "
"at your screen for 20 straight hours, you'll find it a lot easier to see "
"how the indentation works if you have large indentations."
msgstr ""
"Обоснование: Основная идея отступов состоит в том, чтобы показать, где "
"начинается и заканчивается логический блок кода. Особенно если вы "
"смотрите на один и тот же код в течение 20 часов, трудно не заметить "
"пользу больших отступов."

#: ../doc/1.10/dev_guide/c_style_guide.rst:168
msgid ""
"Now, some people will claim that having 8-character indentations makes "
"the code move too far to the right, and makes it hard to read on a "
"80-character terminal screen.  The answer to that is that if you need "
"more than 3 levels of indentation, you're screwed anyway, and should fix "
"your program."
msgstr ""
"Некоторые могут возразить, что отступ в 8 символов делает код слишком "
"широким, особенно на 80-знаковой строке терминала. Ответ: Если вам "
"понадобилось более трех уровней отступа, вы что-то делаете неправильно, и"
" вам следует переписать этот участок."

#: ../doc/1.10/dev_guide/c_style_guide.rst:174
msgid ""
"In short, 8-char indents make things easier to read, and have the added "
"benefit of warning you when you're nesting your functions too deep. Heed "
"that warning."
msgstr ""
"Короче говоря, отступы в 8 символов облегчают чтение кода, да еще и "
"предупреждают, когда вы слишком глубоко встраиваете свои "
"функции. Прислушайтесь к этому."

#: ../doc/1.10/dev_guide/c_style_guide.rst:178
msgid ""
"The preferred way to ease multiple indentation levels in a switch "
"statement is to align the \"switch\" and its subordinate \"case\" labels "
"in the same column instead of \"double-indenting\" the \"case\" labels. "
"e.g.:"
msgstr ""
"Лучше всего упростить несколько уровней отступов в операторе switch, "
"выравнивая \"switch\" и его вспомогательные метки \"case\" в одном "
"столбце вместо использования двойных отступов для меток \"case\", "
"например:"

#: ../doc/1.10/dev_guide/c_style_guide.rst:182
msgid ""
"switch (suffix) {\n"
"case 'G':\n"
"case 'g':\n"
"    mem <<= 30;\n"
"    break;\n"
"case 'M':\n"
"case 'm':\n"
"    mem <<= 20;\n"
"    break;\n"
"case 'K':\n"
"case 'k':\n"
"    mem <<= 10;\n"
"    /* fall through */\n"
"default:\n"
"    break;\n"
"}"
msgstr ""
"switch (suffix) {\n"
"case 'G':\n"
"case 'g':\n"
"    mem <<= 30;\n"
"    break;\n"
"case 'M':\n"
"case 'm':\n"
"    mem <<= 20;\n"
"    break;\n"
"case 'K':\n"
"case 'k':\n"
"    mem <<= 10;\n"
"    /* fall through */\n"
"default:\n"
"    break;\n"
"}"

#: ../doc/1.10/dev_guide/c_style_guide.rst:202
msgid ""
"Don't put multiple statements on a single line unless you have something "
"to hide:"
msgstr ""
"Не размещайте несколько операторов на одной строке, если вам нечего "
"скрывать:"

#: ../doc/1.10/dev_guide/c_style_guide.rst:205
msgid ""
"if (condition) do_this;\n"
"  do_something_everytime;"
msgstr ""
"if (condition) do_this;\n"
"  do_something_everytime;"

#: ../doc/1.10/dev_guide/c_style_guide.rst:210
msgid ""
"Don't put multiple assignments on a single line either. Kernel coding "
"style is super simple. Avoid tricky expressions."
msgstr ""
"И не размещайте несколько операторов присваивания на одной строке. Стиль "
"программирования ядра чрезвычайно прост. Избегайте сложных выражений."

#: ../doc/1.10/dev_guide/c_style_guide.rst:213
msgid ""
"Outside of comments, documentation and except in Kconfig, spaces are "
"never used for indentation, and the above example is deliberately broken."
msgstr ""
"За пределами комментариев, документации и Kconfig, пробелы никогда не "
"используются для отступов, и приведенный выше пример намеренно нарушен."

#: ../doc/1.10/dev_guide/c_style_guide.rst:216
msgid "Get a decent editor and don't leave whitespace at the end of lines."
msgstr "Найдите достойный редактор и не оставляйте пробелы в конце строки."

#: ../doc/1.10/dev_guide/c_style_guide.rst:221
msgid "Chapter 2: Breaking long lines and strings"
msgstr "Глава 2: Разрыв длинных строк"

#: ../doc/1.10/dev_guide/c_style_guide.rst:223
msgid ""
"Coding style is all about readability and maintainability using commonly "
"available tools."
msgstr ""
"Смысл стиля программирования заключается в читаемости и удобстве "
"сопровождения с использованием общедоступных средств."

#: ../doc/1.10/dev_guide/c_style_guide.rst:226
msgid ""
"The limit on the length of lines is 80 columns, reduced to 66 columns for"
" comments, and this is a strongly preferred limit."
msgstr ""
"Длина строк ограничена 80 символами, для комментариев уменьшается до 66 "
"символов, и этому следует уделить особое внимание."

#: ../doc/1.10/dev_guide/c_style_guide.rst:229
msgid ""
"Statements longer than 80 columns will be broken into sensible chunks. "
"Descendants are always substantially shorter than the parent and are "
"placed substantially to the right. The same applies to function headers "
"with a long argument list. Long strings are as well broken into shorter "
"strings. The only exception to this is where exceeding 80 columns "
"significantly increases readability and does not hide information."
msgstr ""
"Операторы длиной более 80 символов будут разбиты на логические части. "
"Последующие части значительно короче основной и смещены вправо. То же "
"относится к заголовкам функций с длинным списком аргументов. Длинные "
"строки также разбиваются на более короткие строки. Единственным "
"исключением может быть случай, если превышение ограничений повысит "
"читаемость и не скроет необходимую информацию."

#: ../doc/1.10/dev_guide/c_style_guide.rst:236
#, python-format
msgid ""
"void fun(int a, int b, int c)\n"
"{\n"
"    if (condition)\n"
"        printk(KERN_WARNING \"Warning this is a long printk with \"\n"
"                        \"3 parameters a: %u b: %u \"\n"
"                        \"c: %u \\n\", a, b, c);\n"
"    else\n"
"        next_statement;\n"
"}"
msgstr ""
"void fun(int a, int b, int c)\n"
"{\n"
"    if (condition)\n"
"        printk(KERN_WARNING \"Warning this is a long printk with \"\n"
"                        \"3 parameters a: %u b: %u \"\n"
"                        \"c: %u \\n\", a, b, c);\n"
"    else\n"
"        next_statement;\n"
"}"

#: ../doc/1.10/dev_guide/c_style_guide.rst:250
msgid "Chapter 3: Placing Braces and Spaces"
msgstr "Глава 3: Фигурные скобки и пробелы"

#: ../doc/1.10/dev_guide/c_style_guide.rst:252
msgid ""
"The other issue that always comes up in C styling is the placement of "
"braces.  Unlike the indent size, there are few technical reasons to "
"choose one placement strategy over the other, but the preferred way, as "
"shown to us by the prophets Kernighan and Ritchie, is to put the opening "
"brace last on the line, and put the closing brace first, thusly:"
msgstr ""
"Другой проблемой, которая всегда возникает в программировании на C, "
"является размещение фигурных скобок. В отличие от отступов, есть "
"несколько технических обоснований, чтобы выбрать один способ, а не "
"другой, но предпочтительно, как нам показали великие Керниган и Ричи, "
"поместить открывающую скобку в конце строки, а закрывающую в начале новой"
" строки:"

#: ../doc/1.10/dev_guide/c_style_guide.rst:258
msgid ""
"if (x is true) {\n"
"    we do y\n"
"}"
msgstr ""
"if (x is true) {\n"
"    we do y\n"
"}"

#: ../doc/1.10/dev_guide/c_style_guide.rst:264
msgid ""
"This applies to all non-function statement blocks (if, switch, for, "
"while, do). e.g.:"
msgstr ""
"Это применимо ко всем блокам операторов без функций (if, switch, for, "
"while, do), например:"

#: ../doc/1.10/dev_guide/c_style_guide.rst:267
msgid ""
"switch (action) {\n"
"case KOBJ_ADD:\n"
"    return \"add\";\n"
"case KOBJ_REMOVE:\n"
"    return \"remove\";\n"
"case KOBJ_CHANGE:\n"
"    return \"change\";\n"
"default:\n"
"    return NULL;\n"
"}"
msgstr ""
"switch (action) {\n"
"case KOBJ_ADD:\n"
"    return \"add\";\n"
"case KOBJ_REMOVE:\n"
"    return \"remove\";\n"
"case KOBJ_CHANGE:\n"
"    return \"change\";\n"
"default:\n"
"    return NULL;\n"
"}"

#: ../doc/1.10/dev_guide/c_style_guide.rst:280
msgid ""
"However, there is one special case, namely functions: they have the "
"opening brace at the beginning of the next line, thus:"
msgstr ""
"И только в особенных случаях, а именно для функций, открывающая скобка "
"размещается в начале следующей строки:"

#: ../doc/1.10/dev_guide/c_style_guide.rst:283
msgid ""
"int function(int x)\n"
"{\n"
"    body of function;\n"
"}"
msgstr ""
"int function(int x)\n"
"{\n"
"    body of function;\n"
"}"

#: ../doc/1.10/dev_guide/c_style_guide.rst:290
msgid ""
"Heretic people all over the world have claimed that this inconsistency is"
" ...  well ...  inconsistent, but all right-thinking people know that (a)"
" K&R are _right_ and (b) K&R are right.  Besides, functions are special "
"anyway (you can't nest them in C)."
msgstr ""
"Отступники по всему миру утверждали, что такая несогласованность ... ну "
"... несогласованна, но все здравомыслящие люди знают: (a) K&R _правы_, "
"(б) K&R правы. Кроме того, функции в любом случае будут особенными (в C "
"их нельзя вложить)."

#: ../doc/1.10/dev_guide/c_style_guide.rst:295
msgid ""
"Note that the closing brace is empty on a line of its own, _except_ in "
"the cases where it is followed by a continuation of the same statement, "
"ie a \"while\" in a do-statement or an \"else\" in an if-statement, like "
"this:"
msgstr ""
"Обратите внимание, что за закрывающей скобкой на отдельной строке ничего "
"нет, _кроме_ тех случаев, когда за ней следует продолжение того же "
"оператора, то есть \"while\" в do-операторе или \"else\" в if-операторе, "
"например:"

#: ../doc/1.10/dev_guide/c_style_guide.rst:300
msgid ""
"do {\n"
"    body of do-loop;\n"
"} while (condition);"
msgstr ""
"do {\n"
"    body of do-loop;\n"
"} while (condition);"

#: ../doc/1.10/dev_guide/c_style_guide.rst:306
msgid "and"
msgstr "и"

#: ../doc/1.10/dev_guide/c_style_guide.rst:308
msgid ""
"if (x == y) {\n"
"    ..\n"
"} else if (x > y) {\n"
"    ...\n"
"} else {\n"
"    ....\n"
"}"
msgstr ""
"if (x == y) {\n"
"    ..\n"
"} else if (x > y) {\n"
"    ...\n"
"} else {\n"
"    ....\n"
"}"

#: ../doc/1.10/dev_guide/c_style_guide.rst:318
msgid "Rationale: K&R."
msgstr "Обоснование: K&R."

#: ../doc/1.10/dev_guide/c_style_guide.rst:320
msgid ""
"Also, note that this brace-placement also minimizes the number of empty "
"(or almost empty) lines, without any loss of readability.  Thus, as the "
"supply of new-lines on your screen is not a renewable resource (think "
"25-line terminal screens here), you have more empty lines to put comments"
" on."
msgstr ""
"Кроме того, обратите внимание, что такое расположение скобок также сводит"
" к минимуму количество пустых (или почти пустых) строк без потери "
"читаемости. Таким образом, поскольку новые строки на экране -- это не "
"возобновляемый ресурс (вспомним о 25-строчных экранах терминала), у вас "
"будет больше пустых строк для комментариев."

#: ../doc/1.10/dev_guide/c_style_guide.rst:326
msgid "Do not unnecessarily use braces where a single statement will do."
msgstr "Не используйте лишние фигурные скобки, если нужен всего один оператор."

#: ../doc/1.10/dev_guide/c_style_guide.rst:328
msgid ""
"if (condition)\n"
"    action();"
msgstr ""
"if (condition)\n"
"    action();"

#: ../doc/1.10/dev_guide/c_style_guide.rst:333
msgid ""
"This does not apply if one branch of a conditional statement is a single "
"statement. Use braces in both branches."
msgstr ""
"Это не применимо, если одна ветка условного оператора -- это отдельный "
"оператор. Используйте фигурные скобки в обеих ветках."

#: ../doc/1.10/dev_guide/c_style_guide.rst:336
msgid ""
"if (condition) {\n"
"    do_this();\n"
"    do_that();\n"
"} else {\n"
"    otherwise();\n"
"}"
msgstr ""
"if (condition) {\n"
"    do_this();\n"
"    do_that();\n"
"} else {\n"
"    otherwise();\n"
"}"

#: ../doc/1.10/dev_guide/c_style_guide.rst:347
msgid "Chapter 3.1:  Spaces"
msgstr "Глава 3.1: Пробелы"

#: ../doc/1.10/dev_guide/c_style_guide.rst:349
msgid ""
"Linux kernel style for use of spaces depends (mostly) on function-versus-"
"keyword usage.  Use a space after (most) keywords.  The notable "
"exceptions are sizeof, typeof, alignof, and __attribute__, which look "
"somewhat like functions (and are usually used with parentheses in Linux, "
"although they are not required in the language, as in: \"sizeof info\" "
"after \"struct fileinfo info;\" is declared)."
msgstr ""
"Стиль программирования ядра Linux в том, что касается пробелов, зависит "
"(в основном) от использования функции или ключевого слова. Используйте "
"пробел после (большинства) ключевых слов. Значимые исключения: sizeof, "
"typeof, alignof и __attribute__, которые похожи на функции (и обычно "
"используются с круглыми скобками в Linux, хотя они и не требуются, как в "
"объявлении \"sizeof info\" после \"struct fileinfo info;\")."

#: ../doc/1.10/dev_guide/c_style_guide.rst:356
msgid ""
"So use a space after these keywords: if, switch, case, for, do, while but"
" not with sizeof, typeof, alignof, or __attribute__.  E.g.,"
msgstr ""
"Поэтому добавляйте пробел после следующих ключевых слов: if, switch, "
"case, for, do, while, но не для sizeof, typeof, alignof или "
"__attribute__.  Пример:"

#: ../doc/1.10/dev_guide/c_style_guide.rst:359
msgid "s = sizeof(struct file);"
msgstr "s = sizeof(struct file);"

#: ../doc/1.10/dev_guide/c_style_guide.rst:363
msgid ""
"Do not add spaces around (inside) parenthesized expressions. This example"
" is **bad**:"
msgstr ""
"Не добавляйте пробелы вокруг (внутри) выражений в круглых скобках. Этот "
"пример **неправильный**:"

#: ../doc/1.10/dev_guide/c_style_guide.rst:366
msgid "s = sizeof( struct file );"
msgstr "s = sizeof( struct file );"

#: ../doc/1.10/dev_guide/c_style_guide.rst:370
msgid ""
"When declaring pointer data or a function that returns a pointer type, "
"the preferred use of '*' is adjacent to the data name or function name "
"and not adjacent to the type name.  Examples:"
msgstr ""
"Объявляя данных типа указателя или функцию, которая возвращает тип "
"указателя, предпочтительно использовать '*' рядом с именем данных или "
"именем функции, а не рядом с именем типа. Примеры:"

#: ../doc/1.10/dev_guide/c_style_guide.rst:374
msgid ""
"char *linux_banner;\n"
"unsigned long long memparse(char *ptr, char **retptr);\n"
"char *match_strdup(substring_t *s);"
msgstr ""
"char *linux_banner;\n"
"unsigned long long memparse(char *ptr, char **retptr);\n"
"char *match_strdup(substring_t *s);"

#: ../doc/1.10/dev_guide/c_style_guide.rst:380
msgid ""
"Use one space around (on each side of) most binary and ternary operators,"
" such as any of these:"
msgstr ""
"Добавляйте по одному пробелу вокруг (с каждой стороны) большинства знаков"
" двухместных и трехместных операций, например, любое из следующих:"

#: ../doc/1.10/dev_guide/c_style_guide.rst:383
msgid "=  +  -  <  >  *  /  %  |  &  ^  <=  >=  ==  !=  ?  :"
msgstr "=  +  -  <  >  *  /  %  |  &  ^  <=  >=  ==  !=  ?  :"

#: ../doc/1.10/dev_guide/c_style_guide.rst:385
msgid "but no space after unary operators:"
msgstr "но не добавляйте пробелы после знаков одноместных операций:"

#: ../doc/1.10/dev_guide/c_style_guide.rst:387
msgid "&  *  +  -  ~  !  sizeof  typeof  alignof  __attribute__  defined"
msgstr "&  *  +  -  ~  !  sizeof  typeof  alignof  __attribute__  defined"

#: ../doc/1.10/dev_guide/c_style_guide.rst:389
msgid "no space before the postfix increment & decrement unary operators:"
msgstr ""
"не нужны пробелы перед знаками одноместных операций увеличения или "
"уменьшения постфикса:"

#: ../doc/1.10/dev_guide/c_style_guide.rst:391
#: ../doc/1.10/dev_guide/c_style_guide.rst:395
msgid "++  --"
msgstr "++  --"

#: ../doc/1.10/dev_guide/c_style_guide.rst:393
msgid "no space after the prefix increment & decrement unary operators:"
msgstr ""
"не нужны пробелы после знаков одноместных операций увеличения или "
"уменьшения префикса:"

#: ../doc/1.10/dev_guide/c_style_guide.rst:397
msgid "and no space around the '.' and \"->\" structure member operators."
msgstr "и не нужны пробелы вокруг знаков элементов структуры '.' и \"->\"."

#: ../doc/1.10/dev_guide/c_style_guide.rst:399
msgid ""
"Do not leave trailing whitespace at the ends of lines.  Some editors with"
" \"smart\" indentation will insert whitespace at the beginning of new "
"lines as appropriate, so you can start typing the next line of code right"
" away. However, some such editors do not remove the whitespace if you end"
" up not putting a line of code there, such as if you leave a blank line."
"  As a result, you end up with lines containing trailing whitespace."
msgstr ""
"Не оставляйте пробелы на концах строк. Некоторые редакторы с \"умным\" "
"отступом вставляют пробелы в начале новых строк, поэтому вы можете сразу "
"ввести следующую строку кода. Однако некоторые такие редакторы не удаляют"
" пробелы, если вы не пишете там код, например, если вы оставите пустую "
"строку. В результате имеем строки с пробелами в конце."

#: ../doc/1.10/dev_guide/c_style_guide.rst:406
msgid ""
"Git will warn you about patches that introduce trailing whitespace, and "
"can optionally strip the trailing whitespace for you; however, if "
"applying a series of patches, this may make later patches in the series "
"fail by changing their context lines."
msgstr ""
"Git предупредит, если патчи содержат пробелы в конце строк, и может по "
"желанию удалить пробелы за вас; однако, в серии патчей, это может "
"привести к тому, что последующие патчи в серии не применятся, поскольку "
"изменены контекстные строки."

#: ../doc/1.10/dev_guide/c_style_guide.rst:414
msgid "Chapter 4: Naming"
msgstr "Глава 4: Именование"

#: ../doc/1.10/dev_guide/c_style_guide.rst:416
msgid ""
"C is a Spartan language, and so should your naming be.  Unlike Modula-2 "
"and Pascal programmers, C programmers do not use cute names like "
"ThisVariableIsATemporaryCounter.  A C programmer would call that variable"
" \"tmp\", which is much easier to write, and not the least more difficult"
" to understand."
msgstr ""
"C -- это спартанский язык, и именование должно быть спартанским. В "
"отличие от разработчиков на Modula-2 и Pascal, разработчики на языке C не"
" используют забавные имена, такие как ThisVariableIsATemporaryCounter. "
"Разработчик на языке C назвал бы такую переменную \"tmp\", что намного "
"легче написать и не менее сложно понять."

#: ../doc/1.10/dev_guide/c_style_guide.rst:422
msgid ""
"HOWEVER, while mixed-case names are frowned upon, descriptive names for "
"global variables are a must.  To call a global function \"foo\" is a "
"shooting offense."
msgstr ""
"ОДНАКО, хотя на имена со смешанным регистром смотрят неодобрительно, "
"обязательным требованием будут описательные имена глобальных переменных. "
"Назвать глобальную функцию \"foo\" -- это оскорбление."

#: ../doc/1.10/dev_guide/c_style_guide.rst:426
msgid ""
"GLOBAL variables (to be used only if you _really_ need them) need to have"
" descriptive names, as do global functions.  If you have a function that "
"counts the number of active users, you should call that "
"\"count_active_users()\" or similar, you should _not_ call it "
"\"cntusr()\"."
msgstr ""
"У ГЛОБАЛЬНЫХ переменных (которые надо использовать, только если без них "
"НЕЛЬЗЯ обойтись) должны быть описательные имена, равно как и у глобальных"
" функций. Если у вас есть функция, которая подсчитывает количество "
"активных пользователей, нужно назвать ее \"count_active_users()\" или "
"как-то похоже, _НЕ_ следует называть ее \"cntusr()\"."

#: ../doc/1.10/dev_guide/c_style_guide.rst:431
msgid ""
"Encoding the type of a function into the name (so-called Hungarian "
"notation) is brain damaged - the compiler knows the types anyway and can "
"check those, and it only confuses the programmer.  No wonder MicroSoft "
"makes buggy programs."
msgstr ""
"Кодирование типа функции в названии (так называемая венгерская нотация) "
"-- это признак плохого тона, поскольку компилятор в любом случае знает "
"типы и может их проверять, и это только путает программиста. "
"Неудивительно, что MicroSoft делает глючные программы."

#: ../doc/1.10/dev_guide/c_style_guide.rst:436
msgid ""
"LOCAL variable names should be short, and to the point.  If you have some"
" random integer loop counter, it should probably be called \"i\". Calling"
" it \"loop_counter\" is non-productive, if there is no chance of it being"
" mis-understood.  Similarly, \"tmp\" can be just about any type of "
"variable that is used to hold a temporary value."
msgstr ""
"Имена ЛОКАЛЬНЫХ переменных должны быть короткими и точными. Если у вас "
"есть счетчик случайных целых чисел, его следует называть \"i\". Назвать "
"его \"loop_counter\" будет непродуктивно, если нет никаких шансов, что "
"его перепутают. Аналогично \"tmp\" может быть практически любым типом "
"переменной, которая используется для хранения временного значения."

#: ../doc/1.10/dev_guide/c_style_guide.rst:442
msgid ""
"If you are afraid to mix up your local variable names, you have another "
"problem, which is called the function-growth-hormone-imbalance syndrome. "
"See chapter 6 (Functions)."
msgstr ""
"Если вы боитесь перепутать имена своих локальных переменных, у вас другая"
" проблема, которая называется синдромом дисбаланса гормона роста функций."
" См. Главу 6 (Функции)."

#: ../doc/1.10/dev_guide/c_style_guide.rst:449
msgid "Chapter 5: Typedefs"
msgstr "Глава 5: Директива Typedef"

#: ../doc/1.10/dev_guide/c_style_guide.rst:451
msgid "Please don't use things like \"vps_t\"."
msgstr "Не используйте что-то вроде \"vps_t\"."

#: ../doc/1.10/dev_guide/c_style_guide.rst:453
msgid ""
"It's a _mistake_ to use typedef for structures and pointers. When you see"
" a"
msgstr ""
"Будет _ошибкой_ использовать typedef для определения структур и "
"указателей. Если вы видите"

#: ../doc/1.10/dev_guide/c_style_guide.rst:455
msgid "vps_t a;"
msgstr "vps_t a;"

#: ../doc/1.10/dev_guide/c_style_guide.rst:459
msgid "in the source, what does it mean?"
msgstr "в исходном коде, что это означает?"

#: ../doc/1.10/dev_guide/c_style_guide.rst:461
msgid "In contrast, if it says"
msgstr "И наоборот, если говорится"

#: ../doc/1.10/dev_guide/c_style_guide.rst:463
msgid "struct virtual_container *a;"
msgstr "struct virtual_container *a;"

#: ../doc/1.10/dev_guide/c_style_guide.rst:467
msgid "you can actually tell what \"a\" is."
msgstr "можно действительно понять, что такое \"a\"."

#: ../doc/1.10/dev_guide/c_style_guide.rst:469
msgid ""
"Lots of people think that typedefs \"help readability\". Not so. They are"
" useful only for:"
msgstr ""
"Многие думают, что typedef \"способствует читаемости\". Это не так. Эту "
"директиву нужно использовать для:"

#: ../doc/1.10/dev_guide/c_style_guide.rst:472
msgid ""
"totally opaque objects (where the typedef is actively used to _hide_ what"
" the object is)."
msgstr ""
"непрозрачных объектов (где typedef активно используется для _сокрытия_ "
"объекта)."

#: ../doc/1.10/dev_guide/c_style_guide.rst:475
msgid ""
"Example: \"pte_t\" etc. opaque objects that you can only access using the"
" proper accessor functions."
msgstr ""
"Пример: \"pte_t\" и другие непрозрачные объекты, доступ к которым можно "
"получить с помощью соответствующих функций доступа."

#: ../doc/1.10/dev_guide/c_style_guide.rst:478
msgid ""
"NOTE! Opaqueness and \"accessor functions\" are not good in themselves. "
"The reason we have them for things like pte_t etc. is that there really "
"is absolutely _zero_ portably accessible information there."
msgstr ""
"ВНИМАНИЕ! Непрозрачность и функции доступа сами по себе не слишком "
"хороши. Причина, по которой мы используем их для pte_t и т.п., состоит в "
"том, что на самом деле там _нет_ никакой информации для скачивания."

#: ../doc/1.10/dev_guide/c_style_guide.rst:482
msgid ""
"Clear integer types, where the abstraction _helps_ avoid confusion "
"whether it is \"int\" or \"long\"."
msgstr ""
"Чисто целочисленные типы, где абстракция _помогает_ избежать путаницы, "
"\"int\" это или \"long\"."

#: ../doc/1.10/dev_guide/c_style_guide.rst:485
msgid ""
"u8/u16/u32 are perfectly fine typedefs, although they fit into category "
"(d) better than here."
msgstr ""
"u8/u16/u32 -- вполне нормальные typedef, хотя они больше подходят для "
"категории (d)."

#: ../doc/1.10/dev_guide/c_style_guide.rst:488
msgid ""
"NOTE! Again - there needs to be a _reason_ for this. If something is "
"\"unsigned long\", then there's no reason to do"
msgstr ""
"ВНИМАНИЕ! Опять же -- для этого должна быть _причина_. Если что-то "
"представляет собой \"unsigned long\", должна быть причина для"

#: ../doc/1.10/dev_guide/c_style_guide.rst:491
msgid "typedef unsigned long myflags_t;"
msgstr "typedef unsigned long myflags_t;"

#: ../doc/1.10/dev_guide/c_style_guide.rst:495
msgid ""
"but if there is a clear reason for why it under certain circumstances "
"might be an \"unsigned int\" and under other configurations might be "
"\"unsigned long\", then by all means go ahead and use a typedef."
msgstr ""
"но если есть четкая причина, почему при определенных обстоятельствах "
"может быть \"unsigned int\", а в других случаях может быть \"unsigned "
"long\", то на здоровье, используйте typedef."

#: ../doc/1.10/dev_guide/c_style_guide.rst:499
msgid "when you use sparse to literally create a _new_ type for type-checking."
msgstr ""
"когда вы используете разрыв, чтобы буквально создать _новый_ тип для "
"проверки типов."

#: ../doc/1.10/dev_guide/c_style_guide.rst:502
msgid ""
"New types which are identical to standard C99 types, in certain "
"exceptional circumstances."
msgstr ""
"Новые типы, идентичные стандартным типам C99, в определенных "
"исключительных обстоятельствах."

#: ../doc/1.10/dev_guide/c_style_guide.rst:505
msgid ""
"Although it would only take a short amount of time for the eyes and brain"
" to become accustomed to the standard types like 'uint32_t', some people "
"object to their use anyway."
msgstr ""
"Хотя глазам и мозгу требуется лишь короткое время, чтобы привыкнуть к "
"стандартным типам, например, 'uint32_t', некоторые в любом случае "
"возражают против их использования."

#: ../doc/1.10/dev_guide/c_style_guide.rst:509
msgid ""
"Therefore, the Linux-specific 'u8/u16/u32/u64' types and their signed "
"equivalents which are identical to standard types are permitted -- "
"although they are not mandatory in new code of your own."
msgstr ""
"Таким образом, допускаются специфичные для Linux типы 'u8/u16/u32/u64' и "
"их эквиваленты, идентичные стандартным типам, хотя они и не обязательны "
"новом коде."

#: ../doc/1.10/dev_guide/c_style_guide.rst:514
msgid ""
"When editing existing code which already uses one or the other set of "
"types, you should conform to the existing choices in that code."
msgstr ""
"При редактировании существующего кода, в котором уже используется один "
"или другой набор типов, следует придерживаться выбранного типа."

#: ../doc/1.10/dev_guide/c_style_guide.rst:517
msgid "Types safe for use in userspace."
msgstr "Типы, которые можно использовать в пользовательском пространстве."

#: ../doc/1.10/dev_guide/c_style_guide.rst:519
msgid ""
"In certain structures which are visible to userspace, we cannot require "
"C99 types and cannot use the 'u32' form above. Thus, we use __u32 and "
"similar types in all structures which are shared with userspace."
msgstr ""
"В некоторых структурах, видимых в пользовательском пространстве, мы не "
"можем требовать использования типов C99 и не можем применять форму 'u32' "
"выше. Таким образом, мы используем __u32 и подобные типы во всех "
"структурах, которые используются и в пользовательском пространстве."

#: ../doc/1.10/dev_guide/c_style_guide.rst:524
msgid ""
"Maybe there are other cases too, but the rule should basically be to "
"NEVER EVER use a typedef unless you can clearly match one of those rules."
msgstr ""
"Возможно, есть и другие случаи, но основное правило состоит в следующем: "
"НИКОГДА НЕ используйте typedef, если вы не соблюдаете одно из этих "
"правил."

#: ../doc/1.10/dev_guide/c_style_guide.rst:527
msgid ""
"In general, a pointer, or a struct that has elements that can reasonably "
"be directly accessed should **never** be a typedef."
msgstr ""
"В общем, указатель или структура, содержащие элементы, к которым можно "
"получить прямой доступ, **никогда** не должны быть typedef."

#: ../doc/1.10/dev_guide/c_style_guide.rst:533
msgid "Chapter 6: Functions"
msgstr "Глава 6: Функции"

#: ../doc/1.10/dev_guide/c_style_guide.rst:535
msgid ""
"Functions should be short and sweet, and do just one thing.  They should "
"fit on one or two screenfuls of text (the ISO/ANSI screen size is 80x24, "
"as we all know), and do one thing and do that well."
msgstr ""
"Функции должны быть короткими и приятными, и выполнять только одно "
"действие. Они должны помещаться на одном или двух экранах текста (размер "
"экрана ISO/ANSI 80x24, как мы все знаем), и выполнять одно действие, но "
"делать это хорошо."

#: ../doc/1.10/dev_guide/c_style_guide.rst:539
msgid ""
"The maximum length of a function is inversely proportional to the "
"complexity and indentation level of that function.  So, if you have a "
"conceptually simple function that is just one long (but simple) case-"
"statement, where you have to do lots of small things for a lot of "
"different cases, it's OK to have a longer function."
msgstr ""
"Максимальная длина функции обратно пропорциональна сложности функции и "
"уровню отступов. Итак, если у вас есть концептуально простая функция, "
"которая представляет собой лишь один длинный (но простой) оператор "
"вариант case, где вам нужно делать много мелочей для множества разных "
"случаев, длинная функция -- это нормально."

#: ../doc/1.10/dev_guide/c_style_guide.rst:545
msgid ""
"However, if you have a complex function, and you suspect that a less-"
"than-gifted first-year high-school student might not even understand what"
" the function is all about, you should adhere to the maximum limits all "
"the more closely.  Use helper functions with descriptive names (you can "
"ask the compiler to in-line them if you think it's performance-critical, "
"and it will probably do a better job of it than you would have done)."
msgstr ""
"Однако, если у вас есть сложная функция, и вы подозреваете, что не "
"слишком одаренный старшеклассник может даже не понять, о чем эта функция,"
" следует придерживаться ограничений. Используйте вспомогательные функции "
"с описательными именами (можно попросить компилятор встроить их, если "
"считаете, что это критически важно для производительности, и он, "
"вероятно, справится лучше)."

#: ../doc/1.10/dev_guide/c_style_guide.rst:553
msgid ""
"Another measure of the function is the number of local variables.  They "
"shouldn't exceed 5-10, or you're doing something wrong.  Re-think the "
"function, and split it into smaller pieces.  A human brain can generally "
"easily keep track of about 7 different things, anything more and it gets "
"confu/sed.  You know you're brilliant, but maybe you'd like to understand"
" what you did 2 weeks from now."
msgstr ""
"Другим критерием функции является количество локальных переменных. Их не "
"должно быть больше 5-10, или вы делаете что-то неправильно. Продумайте "
"функцию заново и разбейте ее на более мелкие части. Человеческий мозг "
"обычно легко отслеживает около 7 разных вещей, а больше -- и он уже "
"запутается. Вы знаете, что сейчас вы гений, но, возможно, вам через пару "
"недель захочется понять, что именно вы делали."

#: ../doc/1.10/dev_guide/c_style_guide.rst:560
msgid ""
"In source files, separate functions with one blank line.  If the function"
" is exported, the EXPORT* macro for it should follow immediately after "
"the closing function brace line.  E.g.:"
msgstr ""
"В исходных файлах разделяйте функции пустой строкой. Если функция "
"экспортируется, макрос EXPORT* должен следовать сразу за строкой с "
"закрывающей фигурной скобкой. Например:"

#: ../doc/1.10/dev_guide/c_style_guide.rst:564
msgid ""
"int system_is_up(void)\n"
"{\n"
"    return system_state == SYSTEM_RUNNING;\n"
"}\n"
"EXPORT_SYMBOL(system_is_up);"
msgstr ""
"int system_is_up(void)\n"
"{\n"
"    return system_state == SYSTEM_RUNNING;\n"
"}\n"
"EXPORT_SYMBOL(system_is_up);"

#: ../doc/1.10/dev_guide/c_style_guide.rst:572
msgid ""
"In function prototypes, include parameter names with their data types. "
"Although this is not required by the C language, it is preferred in Linux"
" because it is a simple way to add valuable information for the reader."
msgstr ""
"В прототипах функций включайте имена параметров с типами данных. Хотя для"
" языка C это и не требуется, но рекомендуется для Linux, потому что это "
"простой способ добавить ценную информацию для читателя."

#: ../doc/1.10/dev_guide/c_style_guide.rst:578
msgid "Chapter 7: Centralized exiting of functions"
msgstr "Глава 7: Централизованный выход из функции"

#: ../doc/1.10/dev_guide/c_style_guide.rst:580
msgid ""
"Albeit deprecated by some people, the equivalent of the goto statement is"
" used frequently by compilers in form of the unconditional jump "
"instruction."
msgstr ""
"Хотя некоторые объявили аналог оператора goto устаревшим, его часто "
"используют компиляторы в виде инструкции безусловной передачи управления."

#: ../doc/1.10/dev_guide/c_style_guide.rst:583
msgid ""
"The goto statement comes in handy when a function exits from multiple "
"locations and some common work such as cleanup has to be done."
msgstr ""
"Оператор goto пригодится, когда функция производит выход из нескольких "
"мест, и необходимо выполнить какие-то общие действия, такие как очистка."

#: ../doc/1.10/dev_guide/c_style_guide.rst:586
msgid "The rationale is:"
msgstr "Обоснование:"

#: ../doc/1.10/dev_guide/c_style_guide.rst:588
msgid "unconditional statements are easier to understand and follow"
msgstr "безусловные операторы легче понять и выполнять"

#: ../doc/1.10/dev_guide/c_style_guide.rst:589
msgid "nesting is reduced"
msgstr "уменьшается глубина вложения"

#: ../doc/1.10/dev_guide/c_style_guide.rst:590
msgid ""
"errors by not updating individual exit points when making modifications "
"are prevented"
msgstr ""
"предотвращаются ошибки по причине отсутствия обновления отдельных точек "
"выхода при внесении изменений"

#: ../doc/1.10/dev_guide/c_style_guide.rst:592
msgid "saves the compiler work to optimize redundant code away ;)"
msgstr "уменьшает объем работы компилятора для оптимизации избыточного кода ;)"

#: ../doc/1.10/dev_guide/c_style_guide.rst:594
msgid ""
"int fun(int a)\n"
"{\n"
"    int result = 0;\n"
"    char *buffer = kmalloc(SIZE);\n"
"\n"
"    if (buffer == NULL)\n"
"        return -ENOMEM;\n"
"\n"
"    if (condition1) {\n"
"        while (loop1) {\n"
"            ...\n"
"        }\n"
"        result = 1;\n"
"        goto out;\n"
"    }\n"
"    ...\n"
"out:\n"
"    kfree(buffer);\n"
"    return result;\n"
"}"
msgstr ""
"int fun(int a)\n"
"{\n"
"    int result = 0;\n"
"    char *buffer = kmalloc(SIZE);\n"
"\n"
"    if (buffer == NULL)\n"
"        return -ENOMEM;\n"
"\n"
"    if (condition1) {\n"
"        while (loop1) {\n"
"            ...\n"
"        }\n"
"        result = 1;\n"
"        goto out;\n"
"    }\n"
"    ...\n"
"out:\n"
"    kfree(buffer);\n"
"    return result;\n"
"}"

#: ../doc/1.10/dev_guide/c_style_guide.rst:619
msgid "Chapter 8: Commenting"
msgstr "Глава 8: Комментирование"

#: ../doc/1.10/dev_guide/c_style_guide.rst:621
msgid ""
"Comments are good, but there is also a danger of over-commenting. NEVER "
"try to explain HOW your code works in a comment: it's much better to "
"write the code so that the _working_ is obvious, and it's a waste of time"
" to explain badly written code. с Generally, you want your comments to "
"tell WHAT your code does, not HOW. Also, try to avoid putting comments "
"inside a function body: if the function is so complex that you need to "
"separately comment parts of it, you should probably go back to chapter 6 "
"for a while.  You can make small comments to note or warn about something"
" particularly clever (or ugly), but try to avoid excess.  Instead, put "
"the comments at the head of the function, telling people what it does, "
"and possibly WHY it does it."
msgstr ""
"Комментарии полезны, но есть и опасность чрезмерного комментирования. "
"НИКОГДА не пытайтесь объяснить в комментарии, КАК работает ваш код: "
"гораздо лучше написать код так, чтобы принцип _работы_ был очевиден, а "
"объяснять плохо написанный код -- это пустая трата времени. Как правило, "
"желательно, чтобы комментарии поясняли, ЧТО делает ваш код, а не КАК. "
"Кроме того, постарайтесь не размещать комментарии внутри тела функции: "
"если функция настолько сложна, что нужно отдельно комментировать ее "
"части, скорее всего, вам надо вернуться к главе 6. Можно давать небольшие"
" комментарии, чтобы отметить или предупредить о чем-то особенно умном "
"(или уродливом), но старайтесь избегать лишнего. Вместо этого поставьте "
"комментарии во главе функции, сообщите людям, что она делает, и, "
"возможно, ПОЧЕМУ она это делает."

#: ../doc/1.10/dev_guide/c_style_guide.rst:635
msgid ""
"When commenting the kernel API functions, please use the kernel-doc "
"format. See the files Documentation/kernel-doc-nano-HOWTO.txt and scripts"
"/kernel-doc for details."
msgstr ""
"Комментируя функции API ядра, используйте формат kernel-doc. Более "
"подробную информацию см. в файлах Documentation/kernel-doc-nano-HOWTO.txt"
" и scripts/kernel-doc."

#: ../doc/1.10/dev_guide/c_style_guide.rst:639
msgid ""
"Linux style for comments is the C89 :code:`/* ... */`` style. Don't use "
"C99-style :code:`// ...` comments."
msgstr ""
"Стиль Linux для комментариев -- стиль C89 :code:`/* ... */`` . Не "
"используйте стиль C99 :code:`// ...`."

#: ../doc/1.10/dev_guide/c_style_guide.rst:642
msgid "The preferred style for long (multi-line) comments is:"
msgstr "Для длинных (многострочных) комментариев рекомендуется:"

#: ../doc/1.10/dev_guide/c_style_guide.rst:644
msgid ""
"/*\n"
" * This is the preferred style for multi-line\n"
" * comments in the Linux kernel source code.\n"
" * Please use it consistently.\n"
" *\n"
" * Description:  A column of asterisks on the left side,\n"
" * with beginning and ending almost-blank lines.\n"
" */"
msgstr ""
"/*\n"
" * Рекомендуется использовать этот стиль для многострочных\n"
" * комментариев в исходном коде ядра Linux.\n"
" * Просьба использовать его согласованно.\n"
" *\n"
" * Описание:  Столбец звездочек слева,\n"
" * в начале и в конце почти пустые строки.\n"
" */"

#: ../doc/1.10/dev_guide/c_style_guide.rst:655
msgid ""
"It's also important to comment data, whether they are basic types or "
"derived types.  To this end, use just one data declaration per line (no "
"commas for multiple data declarations).  This leaves you room for a small"
" comment on each item, explaining its use."
msgstr ""
"Также важно комментировать данные, являются ли они базовыми или "
"производными типами. Для этого используйте только одно объявление данных "
"в строке (без запятой для объявления массива данных). Это оставляет вам "
"место для небольшого комментария к каждому пункту с объяснением его "
"использования."

#: ../doc/1.10/dev_guide/c_style_guide.rst:662
msgid "Chapter 9: You've made a mess of it"
msgstr "Глава 9: Вы устроили беспорядок"

#: ../doc/1.10/dev_guide/c_style_guide.rst:664
msgid ""
"That's OK, we all do.  You've probably been told by your long-time Unix "
"user helper that \"GNU emacs\" automatically formats the C sources for "
"you, and you've noticed that yes, it does do that, but the defaults it "
"uses are less than desirable (in fact, they are worse than random typing "
"- an infinite number of monkeys typing into GNU emacs would never make a "
"good program)."
msgstr ""
"Всё в порядке, мы все так делаем. Наверное, опытный пользователь Unix, "
"который вам помогает, сказал, что \"GNU emacs\" автоматически форматирует"
" исходный код C, и вы заметили, что да, действительно, но используемые по"
" умолчанию значения оставляют желать лучшего ( на самом деле, они хуже, "
"чем случайные -- несметное количество обезьян, печатающих в GNU emacs, "
"никогда не создаст хорошую программу)."

#: ../doc/1.10/dev_guide/c_style_guide.rst:671
msgid ""
"So, you can either get rid of GNU emacs, or change it to use saner "
"values.  To do the latter, you can stick the following in your .emacs "
"file:"
msgstr ""
"Итак, вы можете либо избавиться от GNU emacs, либо изменить его для "
"использования более адекватных значений. Чтобы сделать последнее, можно "
"вставить следующее в файл .emacs:"

#: ../doc/1.10/dev_guide/c_style_guide.rst:674
msgid ""
"(defun c-lineup-arglist-tabs-only (ignored)\n"
"\"Line up argument lists by tabs, not spaces\"\n"
"(let* ((anchor (c-langelem-pos c-syntactic-element))\n"
"    (column (c-langelem-2nd-pos c-syntactic-element))\n"
"    (offset (- (1+ column) anchor))\n"
"    (steps (floor offset c-basic-offset)))\n"
"    (* (max steps 1)\n"
"    c-basic-offset)))\n"
"\n"
"(add-hook 'c-mode-common-hook\n"
"        (lambda ()\n"
"            ;; Add kernel style\n"
"            (c-add-style\n"
"            \"linux-tabs-only\"\n"
"            '(\"linux\" (c-offsets-alist\n"
"                        (arglist-cont-nonempty\n"
"                        c-lineup-gcc-asm-reg\n"
"                        c-lineup-arglist-tabs-only))))))\n"
"\n"
"(add-hook 'c-mode-hook\n"
"        (lambda ()\n"
"            (let ((filename (buffer-file-name)))\n"
"            ;; Enable kernel mode for the appropriate files\n"
"            (when (and filename\n"
"                        (string-match (expand-file-name \"~/src/linux-"
"trees\")\n"
"                                    filename))\n"
"                (setq indent-tabs-mode t)\n"
"                (c-set-style \"linux-tabs-only\")))))"
msgstr ""
"(defun c-lineup-arglist-tabs-only (ignored)\n"
"\"Line up argument lists by tabs, not spaces\"\n"
"(let* ((anchor (c-langelem-pos c-syntactic-element))\n"
"    (column (c-langelem-2nd-pos c-syntactic-element))\n"
"    (offset (- (1+ column) anchor))\n"
"    (steps (floor offset c-basic-offset)))\n"
"    (* (max steps 1)\n"
"    c-basic-offset)))\n"
"\n"
"(add-hook 'c-mode-common-hook\n"
"        (lambda ()\n"
"            ;; Add kernel style\n"
"            (c-add-style\n"
"            \"linux-tabs-only\"\n"
"            '(\"linux\" (c-offsets-alist\n"
"                        (arglist-cont-nonempty\n"
"                        c-lineup-gcc-asm-reg\n"
"                        c-lineup-arglist-tabs-only))))))\n"
"\n"
"(add-hook 'c-mode-hook\n"
"        (lambda ()\n"
"            (let ((filename (buffer-file-name)))\n"
"            ;; Enable kernel mode for the appropriate files\n"
"            (when (and filename\n"
"                        (string-match (expand-file-name \"~/src/linux-"
"trees\")\n"
"                                    filename))\n"
"                (setq indent-tabs-mode t)\n"
"                (c-set-style \"linux-tabs-only\")))))"

#: ../doc/1.10/dev_guide/c_style_guide.rst:705
msgid ""
"This will make emacs go better with the kernel coding style for C files "
"below ~/src/linux-trees."
msgstr ""
"Это заставит emacs лучше работать со стилем программирования ядра для "
"файлов C в ~/src/linux-trees."

#: ../doc/1.10/dev_guide/c_style_guide.rst:708
msgid ""
"But even if you fail in getting emacs to do sane formatting, not "
"everything is lost: use \"indent\"."
msgstr ""
"Но даже если вам не удастся заставить emacs форматировать нормально, не "
"все потеряно: используйте \"indent\"."

#: ../doc/1.10/dev_guide/c_style_guide.rst:711
msgid ""
"Now, again, GNU indent has the same brain-dead settings that GNU emacs "
"has, which is why you need to give it a few command line options. "
"However, that's not too bad, because even the makers of GNU indent "
"recognize the authority of K&R (the GNU people aren't evil, they are just"
" severely misguided in this matter), so you just give indent the options "
"\"-kr -i8\" (stands for \"K&R, 8 character indents\"), or use "
"\"scripts/Lindent\", which indents in the latest style."
msgstr ""
"Опять же, у GNU indent такие же безмозглые настройки, как и у GNU emacs, "
"поэтому надо задать для него несколько параметров командной строки. Тем "
"не менее, это не так уж плохо, потому что даже разработчики GNU indent "
"признают авторитет K&R (люди из GNU не злые, они просто серьезно "
"ошибаются в этом вопросе), поэтому вы просто указываете опции \"-kr -i8\""
" (означает \"K&R, 8 символов отступа\") или используйте "
"\"scripts/Lindent\", которые делают отступы в новейшем стиле."

#: ../doc/1.10/dev_guide/c_style_guide.rst:719
msgid ""
"\"indent\" has a lot of options, and especially when it comes to comment "
"re-formatting you may want to take a look at the man page.  But remember:"
" \"indent\" is not a fix for bad programming."
msgstr ""
"В \"indent\" есть много опций, и особенно когда дело доходит до "
"повторного форматирования комментариев, вы можете захотеть взглянуть на "
"страницу руководства. Но помните: \"indent\" -- это не залог хорошего "
"программирования."

#: ../doc/1.10/dev_guide/c_style_guide.rst:726
msgid "Chapter 10: Kconfig configuration files"
msgstr "Глава 10: Конфигурационные файлы Kconfig"

#: ../doc/1.10/dev_guide/c_style_guide.rst:728
msgid ""
"For all of the Kconfig* configuration files throughout the source tree, "
"the indentation is somewhat different.  Lines under a \"config\" "
"definition are indented with one tab, while help text is indented an "
"additional two spaces. Example:"
msgstr ""
"Для всех конфигурационных файлов Kconfig* в дереве источников отступы "
"несколько отличаются. Строки под определением \"config\" имеют отступы на"
" позицию табуляции, а текст справки с отступом еще на два пробела. "
"Пример:"

#: ../doc/1.10/dev_guide/c_style_guide.rst:733
msgid ""
"config AUDIT\n"
"    bool \"Auditing support\"\n"
"    depends on NET\n"
"    help\n"
"    Enable auditing infrastructure that can be used with another\n"
"    kernel subsystem, such as SELinux (which requires this for\n"
"    logging of avc messages output).  Does not do system-call\n"
"    auditing without CONFIG_AUDITSYSCALL."
msgstr ""
"config AUDIT\n"
"    bool \"Auditing support\"\n"
"    depends on NET\n"
"    help\n"
"    Enable auditing infrastructure that can be used with another\n"
"    kernel subsystem, such as SELinux (which requires this for\n"
"    logging of avc messages output).  Does not do system-call\n"
"    auditing without CONFIG_AUDITSYSCALL."

#: ../doc/1.10/dev_guide/c_style_guide.rst:744
msgid ""
"Features that might still be considered unstable should be defined as "
"dependent on \"EXPERIMENTAL\":"
msgstr ""
"Функции, которые все еще могут считаться нестабильными, должны "
"определяться как зависящие от \"EXPERIMENTAL\":"

#: ../doc/1.10/dev_guide/c_style_guide.rst:747
msgid ""
"config SLUB\n"
"    depends on EXPERIMENTAL && !ARCH_USES_SLAB_PAGE_STRUCT\n"
"    bool \"SLUB (Unqueued Allocator)\"\n"
"    ..."
msgstr ""
"config SLUB\n"
"    depends on EXPERIMENTAL && !ARCH_USES_SLAB_PAGE_STRUCT\n"
"    bool \"SLUB (Unqueued Allocator)\"\n"
"    ..."

#: ../doc/1.10/dev_guide/c_style_guide.rst:754
msgid ""
"while seriously dangerous features (such as write support for certain "
"filesystems) should advertise this prominently in their prompt string:"
msgstr ""
"тогда как крайне опасные функции (например, поддержка записи для "
"определенных файловых систем) должны подчеркнуть это в строке "
"приглашения:"

#: ../doc/1.10/dev_guide/c_style_guide.rst:757
msgid ""
"config ADFS_FS_RW\n"
"    bool \"ADFS write support (DANGEROUS)\"\n"
"    depends on ADFS_FS\n"
"    ..."
msgstr ""
"config ADFS_FS_RW\n"
"    bool \"ADFS write support (DANGEROUS)\"\n"
"    depends on ADFS_FS\n"
"    ..."

#: ../doc/1.10/dev_guide/c_style_guide.rst:764
msgid ""
"For full documentation on the configuration files, see the file "
"Documentation/kbuild/kconfig-language.txt."
msgstr ""
"Полную документацию по файлам конфигурации см. в файле "
"Documentation/kbuild/kconfig-language.txt."

#: ../doc/1.10/dev_guide/c_style_guide.rst:770
msgid "Chapter 11: Data structures"
msgstr "Глава 11: Структуры данных"

#: ../doc/1.10/dev_guide/c_style_guide.rst:772
msgid ""
"Data structures that have visibility outside the single-threaded "
"environment they are created and destroyed in should always have "
"reference counts.  In the kernel, garbage collection doesn't exist (and "
"outside the kernel garbage collection is slow and inefficient), which "
"means that you absolutely _have_ to reference count all your uses."
msgstr ""
"Для структур данных, которые видимы за пределами однопотоковой среды, в "
"которой они создаются и удаляются, всегда должен выполняться подсчет "
"ссылок. В ядре нет сборки мусора (и за пределами ядра сборка мусора "
"производится медленно и неэффективно), а это означает, что абсолютно "
"_необходимо_ подсчитывать ссылки на каждый случай использования."

#: ../doc/1.10/dev_guide/c_style_guide.rst:778
msgid ""
"Reference counting means that you can avoid locking, and allows multiple "
"users to have access to the data structure in parallel - and not having "
"to worry about the structure suddenly going away from under them just "
"because they slept or did something else for a while."
msgstr ""
"Подсчет ссылок означает, что можно избежать блокировки и позволить "
"нескольким пользователям получать доступ к структуре данных одновременно "
"-- и не нужно беспокоиться о том, что структура внезапно исчезнет только "
"потому, что они спали или делали что-то еще."

#: ../doc/1.10/dev_guide/c_style_guide.rst:783
msgid ""
"Note that locking is _not_ a replacement for reference counting. Locking "
"is used to keep data structures coherent, while reference counting is a "
"memory management technique.  Usually both are needed, and they are not "
"to be confused with each other."
msgstr ""
"Обратите внимание, что блокировка _не_ является заменой для подсчета "
"ссылок. Блокировка используется для обеспечения целостности структур "
"данных, а подсчет ссылок -- это метод управления памятью. Обычно "
"необходимо и то, и другое, и их нельзя путать друг с другом."

#: ../doc/1.10/dev_guide/c_style_guide.rst:788
msgid ""
"Many data structures can indeed have two levels of reference counting, "
"when there are users of different \"classes\".  The subclass count counts"
" the number of subclass users, and decrements the global count just once "
"when the subclass count goes to zero."
msgstr ""
"Для многих структур данных действительно могут быть два уровня подсчета "
"ссылок, когда есть пользователи разных \"классов\". Подсчет подкласса "
"подсчитывает количество пользователей подкласса и уменьшает глобальный "
"счетчик только один раз, когда подсчет подкласса равен нулю."

#: ../doc/1.10/dev_guide/c_style_guide.rst:793
msgid ""
"Examples of this kind of \"multi-level-reference-counting\" can be found "
"in memory management (\"struct mm_struct\": mm_users and mm_count), and "
"in filesystem code (\"struct super_block\": s_count and s_active)."
msgstr ""
"Примеры такого многоуровневого подсчета ссылок можно найти в управлении "
"памятью (\"struct mm_struct\": mm_users и mm_count) и в коде файловой "
"системы (\"struct super_block\": s_count и s_active)."

#: ../doc/1.10/dev_guide/c_style_guide.rst:797
msgid ""
"Remember: if another thread can find your data structure, and you don't "
"have a reference count on it, you almost certainly have a bug."
msgstr ""
"Следует помнить, что если другой поток может найти вашу структуру данных,"
" и у вас нет счетчика ссылок, почти наверняка возникнет ошибка."

#: ../doc/1.10/dev_guide/c_style_guide.rst:802
msgid "Chapter 12: Macros, Enums and RTL"
msgstr "Глава 12: Макросы, перечисления и уровни регистровых передач (RTL)"

#: ../doc/1.10/dev_guide/c_style_guide.rst:804
msgid "Names of macros defining constants and labels in enums are capitalized."
msgstr ""
"Имена макросов, определяющих постоянные и метки в перечислениях, пишутся "
"заглавными буквами."

#: ../doc/1.10/dev_guide/c_style_guide.rst:806
msgid "#define CONSTANT 0x12345"
msgstr "#define CONSTANT 0x12345"

#: ../doc/1.10/dev_guide/c_style_guide.rst:810
msgid "Enums are preferred when defining several related constants."
msgstr ""
"Рекомендуется использовать перечисления при определении нескольких "
"связанных постоянных."

#: ../doc/1.10/dev_guide/c_style_guide.rst:812
msgid ""
"CAPITALIZED macro names are appreciated but macros resembling functions "
"may be named in lower case."
msgstr ""
"Ценятся имена макросов, написанные ЗАГЛАВНЫМИ буквами, но похожие на "
"функции макросы можно называть, используя буквы в нижнем регистре."

#: ../doc/1.10/dev_guide/c_style_guide.rst:815
msgid "Generally, inline functions are preferable to macros resembling functions."
msgstr ""
"Как правило, рекомендуется использовать встроенные функции для макросов, "
"похожих на функции."

#: ../doc/1.10/dev_guide/c_style_guide.rst:817
msgid "Macros with multiple statements should be enclosed in a do - while block:"
msgstr "Макросы с несколькими операторами должны быть заключены в блок do - while:"

#: ../doc/1.10/dev_guide/c_style_guide.rst:819
msgid ""
"#define macrofun(a, b, c)   \\\n"
"    do {                    \\\n"
"        if (a == 5)         \\\n"
"            do_this(b, c);  \\\n"
"    } while (0)"
msgstr ""
"#define macrofun(a, b, c)   \\\n"
"    do {                    \\\n"
"        if (a == 5)         \\\n"
"            do_this(b, c);  \\\n"
"    } while (0)"

#: ../doc/1.10/dev_guide/c_style_guide.rst:827
msgid "Things to avoid when using macros:"
msgstr "Во время использования макросов постарайтесь избегать следующего:"

#: ../doc/1.10/dev_guide/c_style_guide.rst:829
msgid "macros that affect control flow:"
msgstr "макросы, которые влияют на поток управления:"

#: ../doc/1.10/dev_guide/c_style_guide.rst:831
msgid ""
"#define FOO(x)                  \\\n"
"    do {                        \\\n"
"        if (blah(x) < 0)        \\\n"
"            return -EBUGGERED;  \\\n"
"    } while(0)"
msgstr ""
"#define FOO(x)                  \\\n"
"    do {                        \\\n"
"        if (blah(x) < 0)        \\\n"
"            return -EBUGGERED;  \\\n"
"    } while(0)"

#: ../doc/1.10/dev_guide/c_style_guide.rst:839
msgid ""
"is a _very_ bad idea.  It looks like a function call but exits the "
"\"calling\" function; don't break the internal parsers of those who will "
"read the code."
msgstr ""
"это _очень_ плохая идея. Он выглядит как вызов функции, но выходит из "
"вызывающей функции; не ломайте внутреннего анализатора у тех, кто "
"прочитает код."

#: ../doc/1.10/dev_guide/c_style_guide.rst:842
msgid "macros that depend on having a local variable with a magic name:"
msgstr ""
"макросы, которые зависят от наличия локальной переменной с магическим "
"именем:"

#: ../doc/1.10/dev_guide/c_style_guide.rst:844
msgid "#define FOO(val) bar(index, val)"
msgstr "#define FOO(val) bar(index, val)"

#: ../doc/1.10/dev_guide/c_style_guide.rst:848
msgid ""
"might look like a good thing, but it's confusing as hell when one reads "
"the code and it's prone to breakage from seemingly innocent changes."
msgstr ""
"могут показаться хорошей идеей, но они сбивают с толку, когда читаешь "
"код, и такой код склонен ломаться от, казалось бы, невинных изменений."

#: ../doc/1.10/dev_guide/c_style_guide.rst:851
msgid ""
"macros with arguments that are used as l-values: FOO(x) = y; will bite "
"you if somebody e.g. turns FOO into an inline function."
msgstr ""
"макросы с аргументами, которые используются как l-значения: FOO(x) = y; "
"это вам аукнется, если кто-то, например. сделает FOO встроенной функцией."

#: ../doc/1.10/dev_guide/c_style_guide.rst:854
msgid ""
"forgetting about precedence: macros defining constants using expressions "
"must enclose the expression in parentheses. Beware of similar issues with"
" macros using parameters."
msgstr ""
"потеря приоритета: макросы, определяющие постоянные с использованием "
"выражений, должны заключать выражение в круглые скобки. Остерегайтесь "
"аналогичных проблем с макросами с использованием параметров."

#: ../doc/1.10/dev_guide/c_style_guide.rst:858
msgid ""
"#define CONSTANT 0x4000\n"
"#define CONSTEXP (CONSTANT | 3)"
msgstr ""
"#define CONSTANT 0x4000\n"
"#define CONSTEXP (CONSTANT | 3)"

#: ../doc/1.10/dev_guide/c_style_guide.rst:863
msgid ""
"The cpp manual deals with macros exhaustively. The gcc internals manual "
"also covers RTL which is used frequently with assembly language in the "
"kernel."
msgstr ""
"В руководстве cpp подробно рассматриваются макросы. Руководство по "
"внутреннему устройству gcc также рассматривает уровни регистровых передач"
" (RTL), которые часто используются с языком ассемблера в ядре."

#: ../doc/1.10/dev_guide/c_style_guide.rst:868
msgid "Chapter 13: Printing kernel messages"
msgstr "Глава 13: Вывод сообщений ядра"

#: ../doc/1.10/dev_guide/c_style_guide.rst:870
msgid ""
"Kernel developers like to be seen as literate. Do mind the spelling of "
"kernel messages to make a good impression. Do not use crippled words like"
" \"dont\"; use \"do not\" or \"don't\" instead.  Make the messages "
"concise, clear, and unambiguous."
msgstr ""
"Разработчики ядра любят выглядеть грамотными. Обращайте внимание на "
"орфографию в сообщениях ядра, чтобы произвести хорошее впечатление. Не "
"используйте искаженные слова типа \"dont\"; вместо этого используйте \"do"
" not\" или \"don't\". Пусть сообщения будут краткими, ясными и "
"недвусмысленными."

#: ../doc/1.10/dev_guide/c_style_guide.rst:875
msgid "Kernel messages do not have to be terminated with a period."
msgstr "Сообщения ядра не должны заканчиваться точкой."

#: ../doc/1.10/dev_guide/c_style_guide.rst:877
#, python-format
msgid "Printing numbers in parentheses (%d) adds no value and should be avoided."
msgstr ""
"Вывод номеров в круглых скобках (%d) не повышает их ценность, и его "
"следует избегать."

#: ../doc/1.10/dev_guide/c_style_guide.rst:879
msgid ""
"There are a number of driver model diagnostic macros in <linux/device.h> "
"which you should use to make sure messages are matched to the right "
"device and driver, and are tagged with the right level:  dev_err(), "
"dev_warn(), dev_info(), and so forth.  For messages that aren't "
"associated with a particular device, <linux/kernel.h> defines pr_debug() "
"and pr_info()."
msgstr ""
"В <linux/device.h> есть несколько макросов для диагностики модели "
"драйвера, которые следует использовать, чтобы убедиться, что сообщения "
"соотнесены с правильным устройством и драйвером и помечены правильным "
"уровнем: dev_err(), dev_warn(), dev_info() и так далее. Для сообщений, не"
" связанных с определенным устройством, <linux/kernel.h> определяет "
"pr_debug() и pr_info()."

#: ../doc/1.10/dev_guide/c_style_guide.rst:885
msgid ""
"Coming up with good debugging messages can be quite a challenge; and once"
" you have them, they can be a huge help for remote troubleshooting.  Such"
" messages should be compiled out when the DEBUG symbol is not defined "
"(that is, by default they are not included).  When you use dev_dbg() or "
"pr_debug(), that's automatic.  Many subsystems have Kconfig options to "
"turn on -DDEBUG. A related convention uses VERBOSE_DEBUG to add "
"dev_vdbg() messages to the ones already enabled by DEBUG."
msgstr ""
"Придумать хорошие сообщения отладки может быть довольно сложно; и как "
"только у вас будут такие, они могут стать огромным подспорьем для "
"удаленного устранения неполадок. Такие сообщения должны быть "
"скомпилированы, когда символ DEBUG не определен (то есть, по умолчанию "
"они не включены). Если вы используете dev_dbg() или pr_debug(), это "
"сработает автоматически. Во многих подсистемах есть опции Kconfig для "
"включения -DDEBUG. В соответствующем соглашении VERBOSE_DEBUG "
"используется для добавления сообщений dev_vdbg() в сообщения, которые уже"
" включены с помощью DEBUG."

#: ../doc/1.10/dev_guide/c_style_guide.rst:895
msgid "Chapter 14: Allocating memory"
msgstr "Глава 14: Выделение памяти"

#: ../doc/1.10/dev_guide/c_style_guide.rst:897
msgid ""
"The kernel provides the following general purpose memory allocators: "
"kmalloc(), kzalloc(), kcalloc(), and vmalloc().  Please refer to the API "
"documentation for further information about them."
msgstr ""
"В ядре поддерживаются следующие распределители памяти широкого "
"применения: kmalloc(), kzalloc(), kcalloc(), and vmalloc().  Для "
"получения дополнительной информации обратитесь к документации по API."

#: ../doc/1.10/dev_guide/c_style_guide.rst:901
msgid "The preferred form for passing a size of a struct is the following:"
msgstr "Предпочтительна следующая форма передачи размера структуры:"

#: ../doc/1.10/dev_guide/c_style_guide.rst:903
msgid "p = kmalloc(sizeof(*p), ...);"
msgstr "p = kmalloc(sizeof(*p), ...);"

#: ../doc/1.10/dev_guide/c_style_guide.rst:907
msgid ""
"The alternative form where struct name is spelled out hurts readability "
"and introduces an opportunity for a bug when the pointer variable type is"
" changed but the corresponding sizeof that is passed to a memory "
"allocator is not."
msgstr ""
"Другая форма, в которой прописывается название структуры, ухудшает "
"читаемость и дает дополнительные возможности для возникновения ошибок при"
" изменении типа переменной указателя, когда соответствующий sizeof, "
"который передается в распределитель ресурсов, не меняется."

#: ../doc/1.10/dev_guide/c_style_guide.rst:911
msgid ""
"Casting the return value which is a void pointer is redundant. The "
"conversion from void pointer to any other pointer type is guaranteed by "
"the C programming language."
msgstr ""
"Не нужно отбрасывать возвращаемое значение, представляющее собой "
"указатель на объект, тип которого неизвестен. Язык программирования C "
"обеспечивает преобразование из указателя на объект, тип которого "
"неизвестен, на любой другой тип указателя."

#: ../doc/1.10/dev_guide/c_style_guide.rst:917
msgid "Chapter 15: The inline disease"
msgstr "Глава 15: Болезнь встраивания (inline)"

#: ../doc/1.10/dev_guide/c_style_guide.rst:919
msgid ""
"There appears to be a common misperception that gcc has a magic \"make me"
" faster\" speedup option called \"inline\". While the use of inlines can "
"be appropriate (for example as a means of replacing macros, see Chapter "
"12), it very often is not. Abundant use of the inline keyword leads to a "
"much bigger kernel, which in turn slows the system as a whole down, due "
"to a bigger icache footprint for the CPU and simply because there is less"
" memory available for the pagecache. Just think about it; a pagecache "
"miss causes a disk seek, which easily takes 5 milliseconds. There are a "
"LOT of cpu cycles that can go into these 5 milliseconds."
msgstr ""
"Похоже, что распространено ошибочное представление о том, что в gcc есть "
"волшебная опция ускорения, называемая встраиванием \"inline\". Хотя "
"использование встроенных строк может быть оправдано (например, как "
"средство замены макросов, см. Главу 12), довольно часто это не так. "
"Избыток ключевого слова inline приводит к увеличению ядра, что в свою "
"очередь, замедляет работу системы в целом из-за большего объема отпечатка"
" icache для процессора и просто потому, что для pagecache доступно  "
"меньше памяти. Просто подумайте: непопадание в pagecache вызывает поиск "
"по диску, который легко занимает 5 миллисекунд. Есть МНОГО циклов "
"процессора, которые могут пройти в эти 5 миллисекунд."

#: ../doc/1.10/dev_guide/c_style_guide.rst:929
msgid ""
"A reasonable rule of thumb is to not put inline at functions that have "
"more than 3 lines of code in them. An exception to this rule are the "
"cases where a parameter is known to be a compiletime constant, and as a "
"result of this constantness you *know* the compiler will be able to "
"optimize most of your function away at compile time. For a good example "
"of this later case, see the kmalloc() inline function."
msgstr ""
"Общее правило состоит в том, чтобы не вводить встраивание в функции, "
"содержащие больше трех строк кода. Исключением из этого правила являются "
"случаи, когда параметр известен как постоянная времени компиляции, и в "
"результате вы *знаете*, что компилятор сможет оптимизировать большую "
"часть ваших функций во время компиляции. Хороший пример последнего случая"
" -- встроенная функция kmalloc()."

#: ../doc/1.10/dev_guide/c_style_guide.rst:936
msgid ""
"Often people argue that adding inline to functions that are static and "
"used only once is always a win since there is no space tradeoff. While "
"this is technically correct, gcc is capable of inlining these "
"automatically without help, and the maintenance issue of removing the "
"inline when a second user appears outweighs the potential value of the "
"hint that tells gcc to do something it would have done anyway."
msgstr ""
"Часто утверждают, что беспроигрышным вариантом будет встраивание "
"статических функций, используемых только один раз, поскольку нет "
"компромиссов пространства. Хотя это технически правильно, gcc способен "
"автоматически встраивать их, а проблема удаления встроенного, если "
"появляется второй пользователь, перевешивает потенциальную ценность "
"подсказки для gcc делать что-то, что он сделал бы в любом случае."

#: ../doc/1.10/dev_guide/c_style_guide.rst:945
msgid "Chapter 16: Function return values and names"
msgstr "Глава 16: Возвращаемые значения и имена функций"

#: ../doc/1.10/dev_guide/c_style_guide.rst:947
msgid ""
"Functions can return values of many different kinds, and one of the most "
"common is a value indicating whether the function succeeded or failed.  "
"Such a value can be represented as an error-code integer (-Exxx = "
"failure, 0 = success) or a \"succeeded\" boolean (0 = failure, non-zero ="
" success)."
msgstr ""
"Функции могут возвращать значения множества различных типов, и одним из "
"наиболее распространенных является значение, которое указывает, была "
"функция выполнена или нет. Такое значение может быть представлено как "
"целое число с кодом ошибки (-Exxx = сбой, 0 = выполнено) или логическое "
"значение выполнения (0 = сбой, ненулевое значение = выполнено)."

#: ../doc/1.10/dev_guide/c_style_guide.rst:953
msgid ""
"Mixing up these two sorts of representations is a fertile source of "
"difficult-to-find bugs.  If the C language included a strong distinction "
"between integers and booleans then the compiler would find these mistakes"
" for us... but it doesn't.  To help prevent such bugs, always follow this"
" convention:"
msgstr ""
"Смешение этих двух видов дает богатую пищу для появления сложных для "
"обнаружения ошибок. Если бы в языке C были явные различия между целыми "
"числами и логическими значениями, тогда компилятор нашел бы для нас эти "
"ошибки... но это не так. Чтобы предотвратить такие ошибки, всегда "
"следуйте этому соглашению:"

#: ../doc/1.10/dev_guide/c_style_guide.rst:961
msgid ""
"If the name of a function is an action or an imperative command,\n"
"the function should return an error-code integer.  If the name\n"
"is a predicate, the function should return a \"succeeded\" boolean."
msgstr ""
"Если имя функции представляет собой действие или команду,\n"
"функция должна возвращать целое число с кодом ошибки.  Если имя функции\n"
"является утверждением, функция должна возвращать логическое значение "
"выполнения."

#: ../doc/1.10/dev_guide/c_style_guide.rst:965
msgid ""
"For example, \"add work\" is a command, and the add_work() function "
"returns 0 for success or -EBUSY for failure.  In the same way, \"PCI "
"device present\" is a predicate, and the pci_dev_present() function "
"returns 1 if it succeeds in finding a matching device or 0 if it doesn't."
msgstr ""
"Например, \"add work\" (добавить работу) -- это команда, а функция "
"add_work() возвращает 0 в случае выполнения или -EBUSY при сбое. Точно "
"так же \"PCI device present\" (есть PCI-устройство) представляет собой "
"утверждение, а функция pci_dev_present() возвращает 1, если ей удается "
"найти подходящее устройство, или 0, если это не так."

#: ../doc/1.10/dev_guide/c_style_guide.rst:970
msgid ""
"All EXPORTed functions must respect this convention, and so should all "
"public functions.  Private (static) functions need not, but it is "
"recommended that they do."
msgstr ""
"Все экспортируемые функции (EXPORT) должны подчиняться этому соглашению, "
"то же относится и ко всем доступным функциям. Закрытые (статические) "
"функции не должны подчиняться, но это рекомендуется."

#: ../doc/1.10/dev_guide/c_style_guide.rst:974
msgid ""
"Functions whose return value is the actual result of a computation, "
"rather than an indication of whether the computation succeeded, are not "
"subject to this rule.  Generally they indicate failure by returning some "
"out-of-range result.  Typical examples would be functions that return "
"pointers; they use NULL or the ERR_PTR mechanism to report failure."
msgstr ""
"Функции, возвращаемое значение которых является фактическим результатом "
"вычисления, а не указанием того, удалось ли выполнить вычисление, не "
"подпадают под это правило. Обычно они указывают на сбой, возвращая некое "
"недопустимое значение. Типичными примерами будут функции, возвращающие "
"указатели; чтобы сообщить об ошибке, они используют NULL или механизм "
"ERR_PTR."

#: ../doc/1.10/dev_guide/c_style_guide.rst:983
msgid "Chapter 17:  Don't re-invent the kernel macros"
msgstr "Глава 17: Не изобретайте макросы снова"

#: ../doc/1.10/dev_guide/c_style_guide.rst:985
msgid ""
"The header file include/linux/kernel.h contains a number of macros that "
"you should use, rather than explicitly coding some variant of them "
"yourself. For example, if you need to calculate the length of an array, "
"take advantage of the macro"
msgstr ""
"В файле заголовка include/linux/kernel.h содержатся несколько макросов, "
"которые следует использовать, а не программировать их самостоятельно. "
"Например, если необходимо рассчитать длину массива, воспользуйтесь "
"макросом"

#: ../doc/1.10/dev_guide/c_style_guide.rst:990
msgid "#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))"
msgstr "#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))"

#: ../doc/1.10/dev_guide/c_style_guide.rst:994
msgid "Similarly, if you need to calculate the size of some structure member, use"
msgstr ""
"Аналогичным образом, если необходимо рассчитать размер какого-либо "
"элемента структуры, используйте"

#: ../doc/1.10/dev_guide/c_style_guide.rst:996
msgid "#define FIELD_SIZEOF(t, f) (sizeof(((t*)0)->f))"
msgstr "#define FIELD_SIZEOF(t, f) (sizeof(((t*)0)->f))"

#: ../doc/1.10/dev_guide/c_style_guide.rst:1000
msgid ""
"There are also min() and max() macros that do strict type checking if you"
" need them.  Feel free to peruse that header file to see what else is "
"already defined that you shouldn't reproduce in your code."
msgstr ""
"Есть также макросы min() и max(), которые выполняют строгую проверку "
"типов, если понадобится. Не стесняйтесь ознакомиться с этим файлом "
"заголовка, чтобы узнать, что еще не нужно воспроизводить в своем коде."

#: ../doc/1.10/dev_guide/c_style_guide.rst:1006
msgid "Chapter 18:  Editor modelines and other cruft"
msgstr "Глава 18: Редакторские строки режима (modelines) и прочий хлам"

#: ../doc/1.10/dev_guide/c_style_guide.rst:1008
msgid ""
"Some editors can interpret configuration information embedded in source "
"files, indicated with special markers.  For example, emacs interprets "
"lines marked like this:"
msgstr ""
"Некоторые редакторы могут интерпретировать встроенную в исходные файлы "
"информацию о конфигурации, указанную специальными маркерами. Например, "
"emacs интерпретирует строки, помеченные следующим образом:"

#: ../doc/1.10/dev_guide/c_style_guide.rst:1012
msgid "-*- mode: c -*-"
msgstr "-*- mode: c -*-"

#: ../doc/1.10/dev_guide/c_style_guide.rst:1016
msgid "Or like this:"
msgstr "Или так:"

#: ../doc/1.10/dev_guide/c_style_guide.rst:1018
msgid ""
"/*\n"
"Local Variables:\n"
"compile-command: \"gcc -DMAGIC_DEBUG_FLAG foo.c\"\n"
"End:\n"
"*/"
msgstr ""
"/*\n"
"Local Variables:\n"
"compile-command: \"gcc -DMAGIC_DEBUG_FLAG foo.c\"\n"
"End:\n"
"*/"

#: ../doc/1.10/dev_guide/c_style_guide.rst:1026
msgid "Vim interprets markers that look like this:"
msgstr "Vim интерпретирует маркеры, которые выглядят так:"

#: ../doc/1.10/dev_guide/c_style_guide.rst:1028
msgid "/* vim:set sw=8 noet */"
msgstr "/* vim:set sw=8 noet */"

#: ../doc/1.10/dev_guide/c_style_guide.rst:1032
msgid ""
"Do not include any of these in source files.  People have their own "
"personal editor configurations, and your source files should not override"
" them.  This includes markers for indentation and mode configuration.  "
"People may use their own custom mode, or may have some other magic method"
" for making indentation work correctly."
msgstr ""
"Не включайте их в исходные файлы. У людей есть свои собственные настройки"
" редакторов, и ваши исходные файлы не должны их переопределять. Это "
"относится к маркерам для отступов и конфигурации режима. У других людей "
"могут быть свои собственные режимы или  другие волшебные методы для "
"правильной работы отступов."

#: ../doc/1.10/dev_guide/c_style_guide.rst:1040
msgid "Appendix I: References"
msgstr "Приложение I: Источники"

#: ../doc/1.10/dev_guide/c_style_guide.rst:1042
msgid ""
"`The C Programming Language, Second Edition "
"<https://en.wikipedia.org/wiki/The_C_Programming_Language>`_ by Brian W. "
"Kernighan and Dennis M. Ritchie. |br| Prentice Hall, Inc., 1988. |br| "
"ISBN 0-13-110362-8 (paperback), 0-13-110370-9 (hardback)."
msgstr ""
"Керниган Брайан В., Ричи Деннис М. `Язык программирования Си "
"<https://ru.wikipedia.org/wiki/%D0%AF%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F_%D0%A1%D0%B8_(%D0%BA%D0%BD%D0%B8%D0%B3%D0%B0)>`_."
" |br| Prentice Hall, Inc., 1988. |br| ISBN 0-13-110362-8 (в мягкой "
"обложке), 0-13-110370-9 (в твердом переплете)."

#: ../doc/1.10/dev_guide/c_style_guide.rst:1047
msgid ""
"`The Practice of Programming "
"<https://en.wikipedia.org/wiki/The_Practice_of_Programming>`_ by Brian W."
" Kernighan and Rob Pike. |br| Addison-Wesley, Inc., 1999. |br| ISBN "
"0-201-61586-X."
msgstr ""
"Керниган Брайан В., Пайк Роб. `Практика программирования "
"<https://en.wikipedia.org/wiki/The_Practice_of_Programming>`_. |br| "
"Addison-Wesley, Inc., 1999. |br| ISBN 0-201-61586-X."

#: ../doc/1.10/dev_guide/c_style_guide.rst:1052
msgid ""
"`GNU manuals <http://www.gnu.org/manual/>`_ - where in compliance with "
"K&R and this text - for **cpp**, **gcc**, **gcc internals** and "
"**indent**"
msgstr ""
"`Рекомендации GNU <http://www.gnu.org/manual/>`_ в соответствии с K&R и "
"данным текстом -- для **cpp**, **gcc**, **gcc internals** и **indent**"

#: ../doc/1.10/dev_guide/c_style_guide.rst:1055
msgid ""
"`WG14 International standardization workgroup for the programming "
"language C <http://www.open-std.org/JTC1/SC22/WG14/>`_"
msgstr ""
"`Рабочая группа по международной стандартизации языка программирования C "
"WG14 <http://www.open-std.org/JTC1/SC22/WG14/>`_"

#: ../doc/1.10/dev_guide/c_style_guide.rst:1058
msgid ""
"`Kernel CodingStyle, by greg@kroah.com at OLS 2002 "
"<http://www.kroah.com/linux/talks/ols_2002_kernel_codingstyle_talk/html/>`_"
msgstr ""
"`Стиль программирования ядра, автор greg@kroah.com, презентация на OLS "
"2002 "
"<http://www.kroah.com/linux/talks/ols_2002_kernel_codingstyle_talk/html/>`_"

#: ../doc/1.10/dev_guide/developer_guidelines.rst:37
msgid "Developer guidelines"
msgstr "Рекомендации для разработчиков"

#: ../doc/1.10/dev_guide/developer_guidelines.rst:43
msgid "How to work on a bug"
msgstr "Как работать над дефектами"

#: ../doc/1.10/dev_guide/developer_guidelines.rst:45
msgid ""
"Any defect, even minor, if it changes the user-visible server behavior, "
"needs a bug report. Report a bug at "
"http://github.com/tarantool/tarantool/issues."
msgstr ""
"На любой дефект, даже незначительный, если он изменяет доступное "
"пользователю поведение сервера, необходимо составить отчет об ошибке. "
"Сообщите о дефекте по ссылке "
"http://github.com/tarantool/tarantool/issues."

#: ../doc/1.10/dev_guide/developer_guidelines.rst:48
msgid ""
"When reporting a bug, try to come up with a test case right away. Set the"
" current maintenance milestone for the bug fix, and specify the series. "
"Assign the bug to yourself. Put the status to 'In progress' Once the "
"patch is ready, put the bug the bug to 'In review' and solicit a review "
"for the fix."
msgstr ""
"Когда вы сообщаете об ошибке, постарайтесь сразу же приступить к "
"тестовому сценарию. Установите текущую контрольную точку для исправления "
"ошибки и укажите серию. Назначьте задачу на себя. Укажите статус \"In "
"progress\" (выполняется). Как только патч готов, укажите статус ошибки "
"\"In review\" (на рассмотрении) и отправьте версию с исправленными "
"ошибками на рассмотрение."

#: ../doc/1.10/dev_guide/developer_guidelines.rst:53
msgid ""
"Once there is a positive code review, push the patch and set the status "
"to 'Closed'"
msgstr ""
"После успешного рассмотрения кода опубликуйте патч и укажите статус "
"\"Closed\" (закрыт)."

#: ../doc/1.10/dev_guide/developer_guidelines.rst:55
msgid ""
"Patches for bugs should contain a reference to the respective Launchpad "
"bug page or at least bug id. Each patch should have a test, unless coming"
" up with one is difficult in the current framework, in which case QA "
"should be alerted."
msgstr ""
"Патчи для исправления ошибок должны содержать ссылку на соответствующую "
"страницу дефекта Launchpad или хотя бы идентификатор дефекта. Каждому "
"патча должен соответствовать отдельный тест, если только это не слишком "
"трудно сделать в текущем окружении, и в этом случае следует предупредить "
"тестировщиков."

#: ../doc/1.10/dev_guide/developer_guidelines.rst:59
msgid ""
"There are two things you need to do when your patch makes it into the "
"master:"
msgstr "Когда ваш патч доходит до главной ветки проекта, нужно сделать следующее:"

#: ../doc/1.10/dev_guide/developer_guidelines.rst:61
msgid "put the bug to 'fix committed',"
msgstr "перевести статус ошибки в 'fix committed' (исправлено),"

#: ../doc/1.10/dev_guide/developer_guidelines.rst:62
msgid "delete the remote branch."
msgstr "удалить отдельную ветку."

#: ../doc/1.10/dev_guide/developer_guidelines.rst:68
msgid "How to write a commit message"
msgstr "Как писать сообщение о коммите"

#: ../doc/1.10/dev_guide/developer_guidelines.rst:70
msgid ""
"Any commit needs a helpful message. Mind the following guidelines when "
"committing to any of Tarantool repositories at GitHub."
msgstr ""
"Любой коммит следует описать в полезном сообщении. Следуйте "
"нижеприведенным рекомендациям при коммитах в любой репозиторий "
"Tarantool'а на GitHub."

#: ../doc/1.10/dev_guide/developer_guidelines.rst:73
msgid "Separate subject from body with a blank line."
msgstr "Отделяйте тему от тела сообщения пустой строкой."

#: ../doc/1.10/dev_guide/developer_guidelines.rst:74
msgid "Try to limit the subject line to **50 characters** or so."
msgstr "Постарайтесь ограничить тему сообщения примерно **50 символами**."

#: ../doc/1.10/dev_guide/developer_guidelines.rst:75
msgid ""
"Start the subject line with a capital letter unless it prefixed with a "
"subsystem name and semicolon:"
msgstr ""
"Начните тему сообщения с прописной буквы, если ей не предшествует префикс"
" с именем подсистемы и точка с запятой:"

#: ../doc/1.10/dev_guide/developer_guidelines.rst:78
msgid "memtx:"
msgstr "memtx:"

#: ../doc/1.10/dev_guide/developer_guidelines.rst:79
msgid "vinyl:"
msgstr "vinyl:"

#: ../doc/1.10/dev_guide/developer_guidelines.rst:80
msgid "xlog:"
msgstr "xlog:"

#: ../doc/1.10/dev_guide/developer_guidelines.rst:81
msgid "replication:"
msgstr "replication:"

#: ../doc/1.10/dev_guide/developer_guidelines.rst:82
msgid "recovery:"
msgstr "recovery:"

#: ../doc/1.10/dev_guide/developer_guidelines.rst:83
msgid "iproto:"
msgstr "iproto:"

#: ../doc/1.10/dev_guide/developer_guidelines.rst:84
msgid "net.box:"
msgstr "net.box:"

#: ../doc/1.10/dev_guide/developer_guidelines.rst:85
msgid "lua:"
msgstr "lua:"

#: ../doc/1.10/dev_guide/developer_guidelines.rst:86
msgid "sql:"
msgstr "sql:"

#: ../doc/1.10/dev_guide/developer_guidelines.rst:88
msgid "Do not end the subject line with a period."
msgstr "Не заканчивайте тему сообщения точкой."

#: ../doc/1.10/dev_guide/developer_guidelines.rst:89
msgid "Do not put \"gh-xx\", \"closes #xxx\" to the subject line."
msgstr "Не пишите \"gh-xx\", \"closes #xxx\" в строке темы."

#: ../doc/1.10/dev_guide/developer_guidelines.rst:90
msgid ""
"Use the imperative mood in the subject line. A properly formed Git commit"
" subject line should always be able to complete the following sentence: "
"\"If applied, this commit will */your subject line here/*\"."
msgstr ""
"В теме сообщения используйте повелительное наклонение. Правильно "
"оформленная тема Git-коммита должна корректно дополнять следующее "
"предложение: \"Если применить, коммит */здесь тема сообщения/*\"."

#: ../doc/1.10/dev_guide/developer_guidelines.rst:93
msgid "Wrap the body to **72 characters** or so."
msgstr "Уместите тело сообщения в примерно **72 символа**."

#: ../doc/1.10/dev_guide/developer_guidelines.rst:94
msgid "Use the body to explain **what and why** vs. how."
msgstr "Используйте тело сообщения, чтобы объяснить, **что и почему**, а не как."

#: ../doc/1.10/dev_guide/developer_guidelines.rst:95
msgid ""
"Link GitHub issues on the lasts lines (`see how "
"<https://help.github.com/articles/closing-issues-via-commit-messages>`_)."
msgstr ""
"Привяжите задачи на GitHub в последних строках (`см. как "
"<https://help.github.com/articles/closing-issues-via-commit-messages>`_)."

#: ../doc/1.10/dev_guide/developer_guidelines.rst:97
msgid ""
"Use your real name and real email address. For Tarantool team members, "
"**@tarantool.org** email is preferred, but not mandatory."
msgstr ""
"Используйте настоящие имя и адрес электронной почты. Членам проектной "
"команды Tarantool'а рекомендуется указывать почту на **@tarantool.org**, "
"но это необязательно."

#: ../doc/1.10/dev_guide/developer_guidelines.rst:101
msgid "A template:"
msgstr "Шаблон:"

#: ../doc/1.10/dev_guide/developer_guidelines.rst:103
msgid ""
"Summarize changes in 50 characters or less\n"
"\n"
"More detailed explanatory text, if necessary.\n"
"Wrap it to 72 characters or so.\n"
"In some contexts, the first line is treated as the subject of the\n"
"commit, and the rest of the text as the body.\n"
"The blank line separating the summary from the body is critical\n"
"(unless you omit the body entirely); various tools like `log`,\n"
"`shortlog` and `rebase` can get confused if you run the two together.\n"
"\n"
"Explain the problem that this commit is solving. Focus on why you\n"
"are making this change as opposed to how (the code explains that).\n"
"Are there side effects or other unintuitive consequences of this\n"
"change? Here's the place to explain them.\n"
"\n"
"Further paragraphs come after blank lines.\n"
"\n"
"- Bullet points are okay, too.\n"
"\n"
"- Typically a hyphen or asterisk is used for the bullet, preceded\n"
"  by a single space, with blank lines in between, but conventions\n"
"  vary here.\n"
"\n"
"Fixes: #123\n"
"Closes: #456\n"
"Needed for: #859\n"
"See also: #343, #789"
msgstr ""
"Кратко сформулируйте изменения в пределах 50 символов.\n"
"\n"
"При необходимости, более подробные объяснения.\n"
"Уместите детали в примерно 72 символов.\n"
"Иногда первая строка считается темой\n"
"коммита, а остальной текст -- телом сообщения.\n"
"Критически важна пустая строка, которая отделяет тему от тела сообщения\n"
"(если только тело не отсутствует совсем); различные средства, такие как "
"`log`,\n"
"`shortlog` и `rebase` могут их перепутать, если нет разделения.\n"
"\n"
"Объясните проблему, которую решает данный коммит. Уделите внимание тому, "
"почему\n"
"вы вносите эти изменения, а не как (это объясняется в коде).\n"
"Есть ли побочные эффекты или другие неочевидные последствия применения "
"этих\n"
"изменений? Здесь можно объяснить их.\n"
"\n"
"Следующие абзацы идут после пустых строк.\n"
"\n"
"- Можно также использовать элементы в списке.\n"
"\n"
"- Как правило, в качестве маркера применяется дефис или звездочка, "
"которой предшествует\n"
"  пробел, а между строками вставляются пустые строки, но в данном случае\n"
"  условные обозначения могут разниться.\n"
"\n"
"Исправляет: #123\n"
"Закрывает: #456\n"
"Необходим для: #859\n"
"См. также: #343, #789"

#: ../doc/1.10/dev_guide/developer_guidelines.rst:133
msgid "Some real-world examples:"
msgstr "Некоторые реальные примеры:"

#: ../doc/1.10/dev_guide/developer_guidelines.rst:135
msgid ""
"`tarantool/tarantool@2993a75 "
"<https://github.com/tarantool/tarantool/commit/2993a75858352f101deb4a15cefd497ae6a78cf7>`_"
msgstr ""
"`tarantool/tarantool@2993a75 "
"<https://github.com/tarantool/tarantool/commit/2993a75858352f101deb4a15cefd497ae6a78cf7>`_"

#: ../doc/1.10/dev_guide/developer_guidelines.rst:136
msgid ""
"`tarantool/tarantool@ccacba2 "
"<https://github.com/tarantool/tarantool/commit/ccacba28f813fb99fd9eaf07fb41bf604dd341bc>`_"
msgstr ""
"`tarantool/tarantool@ccacba2 "
"<https://github.com/tarantool/tarantool/commit/ccacba28f813fb99fd9eaf07fb41bf604dd341bc>`_"

#: ../doc/1.10/dev_guide/developer_guidelines.rst:137
msgid ""
"`tarantool/tarantool@386df3d "
"<https://github.com/tarantool/tarantool/commit/386df3d3eb9c5239fc83fd4dd3292d1b49446b89>`_"
msgstr ""
"`tarantool/tarantool@386df3d "
"<https://github.com/tarantool/tarantool/commit/386df3d3eb9c5239fc83fd4dd3292d1b49446b89>`_"

#: ../doc/1.10/dev_guide/developer_guidelines.rst:138
msgid ""
"`tarantool/tarantool@076a842 "
"<https://github.com/tarantool/tarantool/commit/076a842011e09c84c25fb5e68f1b23c9917a3750>`_"
msgstr ""
"`tarantool/tarantool@076a842 "
"<https://github.com/tarantool/tarantool/commit/076a842011e09c84c25fb5e68f1b23c9917a3750>`_"

#: ../doc/1.10/dev_guide/developer_guidelines.rst:140
msgid "Based on [1_] and [2_]."
msgstr "Основано на [1_] и [2_]."

#: ../doc/1.10/dev_guide/developer_guidelines.rst:146
msgid "How to submit a patch for review"
msgstr "Как отправить патч на рассмотрение"

#: ../doc/1.10/dev_guide/developer_guidelines.rst:148
msgid ""
"We don't accept GitHub pull requests. Instead, all patches should be sent"
" as plain-text messages to tarantool-patches@freelists.org. Please "
"subscribe to our mailing list at https://www.freelists.org/list"
"/tarantool-patches to ensure that your messages are added to the archive."
msgstr ""
"Мы не принимаем запросы на включение в проект на GitHub. Вместо этого все"
" патчи следует отправлять в виде обычного текстового сообщения по адресу "
"tarantool-patches@freelists.org. Просьба подписаться на рассылку "
"https://www.freelists.org/list/tarantool-patches, чтобы убедиться, что "
"ваши сообщения добавляются в архив."

#: ../doc/1.10/dev_guide/developer_guidelines.rst:154
msgid "**Preparing a patch**"
msgstr "**Подготовка патча**"

#: ../doc/1.10/dev_guide/developer_guidelines.rst:156
msgid ""
"Once you have committed a patch to your local git repository, you can "
"submit it for review."
msgstr ""
"После коммита патча в локальный репозиторий git вы можете отправить его "
"на рассмотрение."

#: ../doc/1.10/dev_guide/developer_guidelines.rst:159
msgid "To prepare an email, use ``git format-patch`` command:"
msgstr "Чтобы подготовить сообщение, воспользуйтесь командой ``git format-patch``:"

#: ../doc/1.10/dev_guide/developer_guidelines.rst:161
msgid "$ git format-patch -1"
msgstr "$ git format-patch -1"

#: ../doc/1.10/dev_guide/developer_guidelines.rst:165
msgid ""
"It will format the commit at the top of your local git repository as a "
"plain-text email and write it to a file in the current directory. The "
"file name will look like ``0001-your-commit-subject-line.patch``. To "
"specify a different directory, use ``-o`` option:"
msgstr ""
"В результате последний коммит в локальном репозитории git будет "
"отформатирован в виде обычного текстового сообщения в файл в текущей "
"директории. Название файла будет выглядеть так: "
"``0001-тема-коммита.patch``. Чтобы указать другую директорию, используйте"
" опцию ``-o``:"

#: ../doc/1.10/dev_guide/developer_guidelines.rst:170
msgid "$ git format-patch -1 -o ~/patches-to-send"
msgstr "$ git format-patch -1 -o ~/patches-to-send"

#: ../doc/1.10/dev_guide/developer_guidelines.rst:174
msgid ""
"Once the patch has been formatted, you can view and edit it with your "
"favorite text editor (after all, it is a plain-text file!). We strongly "
"recommend adding:"
msgstr ""
"После форматирования патча его можно просмотреть и отредактировать в "
"вашем любимом текстовом редакторе (всё-таки это файл с обычным текстом!) "
"Мы настоятельно рекомендуем добавить следующее:"

#: ../doc/1.10/dev_guide/developer_guidelines.rst:178
msgid "a hyperlink to the branch where this patch can be found at GitHub, and"
msgstr "ссылка на ветку, где можно найти этот патч на GitHub, а также"

#: ../doc/1.10/dev_guide/developer_guidelines.rst:179
msgid "a hyperlink to the GitHub issue your patch is supposed to fix, if any."
msgstr "ссылку на проблему на GitHub, которую решает ваш патч."

#: ../doc/1.10/dev_guide/developer_guidelines.rst:181
msgid ""
"If there is just one patch, the change log should go right after ``---`` "
"in the message body (it will be ignored by ``git am`` then)."
msgstr ""
"Если патч всего один, журнал изменений должен идти сразу после ``---`` в "
"теле сообщения (тогда ``git am`` проигнорирует его)."

#: ../doc/1.10/dev_guide/developer_guidelines.rst:184
msgid ""
"If there are multiple patches you want to submit in one go (e.g. this is "
"a big feature which requires some preparatory patches to be committed "
"first), you should send each patch in a separate email in reply to a "
"cover letter. To format a patch series accordingly, pass the following "
"options to ``git format-patch``:"
msgstr ""
"Если же вы хотите отправить сразу несколько патчей (например, это важная "
"функция, для которой нужны несколько предварительных патчей), каждый из "
"них следует отправлять в отдельном сообщении в ответ на сопроводительное "
"письмо. Чтобы соответствующим образом отформатировать серию патчей, "
"передайте следующие опции в ``git format-patch``:"

#: ../doc/1.10/dev_guide/developer_guidelines.rst:190
msgid "$ git format-patch --cover-letter --thread=shallow HEAD~2"
msgstr "$ git format-patch --cover-letter --thread=shallow HEAD~2"

#: ../doc/1.10/dev_guide/developer_guidelines.rst:196
msgid "``--cover-letter`` will make ``git format-patch`` generate a cover letter;"
msgstr ""
"``--cover-letter`` заставит ``git format-patch`` сгенерировать "
"сопроводительное письмо;"

#: ../doc/1.10/dev_guide/developer_guidelines.rst:197
msgid ""
"``--thread=shallow`` will mark each formatted patch email to be sent in "
"reply to the cover letter;"
msgstr ""
"``--thread=shallow`` отметит каждое сообщение с отформатированными "
"патчами, которые следует отправить в ответ на сопроводительное письмо;"

#: ../doc/1.10/dev_guide/developer_guidelines.rst:199
msgid ""
"``HEAD~2`` (we now use it instead of ``-1``) will make ``git format-"
"patch`` format the first two patches at the top of your local git branch "
"instead of just one. To format three patches, use ``HEAD~3``, and so "
"forth."
msgstr ""
"``HEAD~2`` (мы используем вместо ``-1``) заставит ``git format-patch`` "
"форматировать последние два патча в локальной ветке git, а не один. Чтобы"
" форматировать три патча, используйте ``HEAD~3``, и так далее."

#: ../doc/1.10/dev_guide/developer_guidelines.rst:203
msgid ""
"After the command has been successfully executed, you will find all your "
"patches formatted as separate emails in your current directory (or in the"
" directory specified via ``-o`` option):"
msgstr ""
"После успешного выполнения этой команды все ваши патчи будут "
"отформатированы в виде отдельных сообщений в текущей директории (или в "
"директории, указанной с помощью опции ``-o``):"

#: ../doc/1.10/dev_guide/developer_guidelines.rst:207
msgid ""
"0000-cover-letter.patch\n"
"0001-first-commit.patch\n"
"0002-second-commit.patch\n"
"..."
msgstr ""
"0000-cover-letter.patch\n"
"0001-first-commit.patch\n"
"0002-second-commit.patch\n"
"..."

#: ../doc/1.10/dev_guide/developer_guidelines.rst:214
msgid ""
"The cover letter will have BLURB in its subject and body. You'll have to "
"edit it before submitting (again, it is a plain text file). Please write:"
msgstr ""
"В теме и теле сопроводительного письма будут рекламные аннотации. Вам "
"нужно их отредактировать перед отправкой (опять же, это обычный текст). "
"Просьба указать следующее:"

#: ../doc/1.10/dev_guide/developer_guidelines.rst:217
msgid "a short series description in the subject line;"
msgstr "короткое описание в теме сообщения;"

#: ../doc/1.10/dev_guide/developer_guidelines.rst:218
msgid "a few words about each patch of the series in the body."
msgstr "несколько слов о каждом патче в теле сообщения."

#: ../doc/1.10/dev_guide/developer_guidelines.rst:220
msgid ""
"And don't forget to add hyperlinks to the GitHub issue and branch where "
"your series can be found. In this case you don't need to put links or any"
" additional information to each individual email -- the cover letter will"
" cover everything."
msgstr ""
"Кроме того, не забудьте добавить ссылки на проблему на GitHub и на ветку,"
" где можно найти серию патчей. В таком случае нет необходимости указывать"
" ссылки или дополнительную информацию в каждом отдельном письме, "
"поскольку всё необходимое уже будет в сопроводительном письме."

#: ../doc/1.10/dev_guide/developer_guidelines.rst:227
msgid ""
"To omit ``--cover-letter`` and ``--thread=shallow`` options, you can add "
"the following lines to your gitconfig:"
msgstr ""
"Чтобы не указывать опции ``--cover-letter`` и ``--thread=shallow``, можно"
" добавить в gitconfig следующие строки:"

#: ../doc/1.10/dev_guide/developer_guidelines.rst:230
msgid ""
"[format]\n"
"    thread = shallow\n"
"    coverLetter = auto"
msgstr ""
"[format]\n"
"    thread = shallow\n"
"    coverLetter = auto"

#: ../doc/1.10/dev_guide/developer_guidelines.rst:236
msgid "**Sending a patch**"
msgstr "**Отправка патча**"

#: ../doc/1.10/dev_guide/developer_guidelines.rst:238
msgid ""
"Once you have formatted your patches, they are ready to be sent via "
"email. Of course, you can send them with your favorite mail agent, but it"
" is much easier to use ``git send-email`` for this. Before using this "
"command, you need to configure it."
msgstr ""
"После форматирования патчей их можно отправлять по электронной почте. "
"Конечно, можно воспользоваться и любимым почтовым клиентом, но гораздо "
"проще отправить их с помощью ``git send-email``. Перед использованием "
"команды ее необходимо настроить."

#: ../doc/1.10/dev_guide/developer_guidelines.rst:243
msgid "If you use a GMail account, add the following code to your ``.gitconfig``:"
msgstr ""
"Если используется учетная запись GMail, добавьте следующий код в "
"``.gitconfig``:"

#: ../doc/1.10/dev_guide/developer_guidelines.rst:245
msgid ""
"[sendemail]\n"
"    smtpencryption = tls\n"
"    smtpserver = smtp.gmail.com\n"
"    smtpserverport = 587\n"
"    smtpuser = your.name@gmail.com\n"
"    smtppass = topsecret"
msgstr ""
"[sendemail]\n"
"    smtpencryption = tls\n"
"    smtpserver = smtp.gmail.com\n"
"    smtpserverport = 587\n"
"    smtpuser = your.name@gmail.com\n"
"    smtppass = topsecret"

#: ../doc/1.10/dev_guide/developer_guidelines.rst:254
msgid "For mail.ru users, the configuration will be slightly different:"
msgstr "Для пользователей mail.ru настройки будут слегка отличаться:"

#: ../doc/1.10/dev_guide/developer_guidelines.rst:256
msgid ""
"[sendemail]\n"
"    smtpencryption = ssl\n"
"    smtpserver = smtp.mail.ru\n"
"    smtpserverport = 465\n"
"    smtpuser = your.name@mail.ru\n"
"    smtppass = topsecret"
msgstr ""
"[sendemail]\n"
"    smtpencryption = ssl\n"
"    smtpserver = smtp.mail.ru\n"
"    smtpserverport = 465\n"
"    smtpuser = your.name@mail.ru\n"
"    smtppass = topsecret"

#: ../doc/1.10/dev_guide/developer_guidelines.rst:265
msgid ""
"If your email account is hosted by another service, consult your service "
"provider about your SMTP settings."
msgstr ""
"Если ваша учетная запись электронной почты находится на другом ресурсе, "
"уточните SMTP-настройки у поставщика услуг."

#: ../doc/1.10/dev_guide/developer_guidelines.rst:268
msgid "Once configured, use the following command to send your patches:"
msgstr "После настройки используйте следующую команду для отправки патчей:"

#: ../doc/1.10/dev_guide/developer_guidelines.rst:270
msgid "$ git send-email --to tarantool-patches@freelists.org 00*"
msgstr "$ git send-email --to tarantool-patches@freelists.org 00*"

#: ../doc/1.10/dev_guide/developer_guidelines.rst:274
msgid ""
"(``00*`` wildcard will be expanded by your shell to the list of patches "
"generated at the previous step.)"
msgstr ""
"(подстановочный символ ``00*`` будет распространяться на список патчей, "
"сгенерированных в предыдущем шаге.)"

#: ../doc/1.10/dev_guide/developer_guidelines.rst:277
msgid ""
"If you want someone in particular to review your patch, add them to the "
"list of recipients by passing ``--to`` or ``--cc`` once per each "
"recipient."
msgstr ""
"Если вы бы хотели, чтобы определенный человек рассматривал ваш патч, "
"добавьте его в список получателей, передав ``--to`` или ``--cc`` для "
"каждого получателя."

#: ../doc/1.10/dev_guide/developer_guidelines.rst:282
msgid ""
"It is useful to check that ``git send-email`` will work as expected "
"without sending anything to the world. Use ``--dry-run`` option for that."
msgstr ""
"Неплохо проверить, что ``git send-email`` будет работать должным образом,"
" не отправив ничего на весь мир. Для этого воспользуйтесь опцией ``--dry-"
"run``."

#: ../doc/1.10/dev_guide/developer_guidelines.rst:285
msgid "**Review process**"
msgstr "**Процесс рассмотрения**"

#: ../doc/1.10/dev_guide/developer_guidelines.rst:287
msgid ""
"After having sent your patches, you just wait for a review. The reviewer "
"will send their comments back to you in reply to the email that contains "
"the patch that in their opinion needs to be fixed."
msgstr ""
"После отправки патчей вы ожидаете их рассмотрения. Редактор отправит свои"
" комментарии в ответ на сообщение с патчем, который нуждается в "
"доработке, по его мнению."

#: ../doc/1.10/dev_guide/developer_guidelines.rst:291
msgid ""
"Upon receiving an email with review remarks, you carefully read it and "
"reply about whether you agree or disagree with. Please note that we use "
"the interleaved reply style (aka \"inline reply\") for communications "
"over email."
msgstr ""
"Получив электронное письмо с примечаниями, вы внимательно читаете его и "
"отвечаете, согласны вы или нет. Обратите внимание, что мы используем "
"стиль ответа с чередованием (он же \"встроенный ответ\") в сообщениях "
"электронной почты."

#: ../doc/1.10/dev_guide/developer_guidelines.rst:295
msgid ""
"Upon reaching an agreement, you send a fixed patch in reply to the email "
"that ended the discussion. To send a patch, you can either attach a plain"
" diff (created by ``git diff`` or ``git format-patch``) to email and send"
" it with your favorite mail agent, or use ``--in-reply-to`` option of "
"``git send-email`` command."
msgstr ""
"Достигнув соглашения, вы отправляете доработанный патч в ответ на "
"последнее сообщение в обсуждении. Чтобы отправить патч, вы можете либо "
"вложить простой diff (созданный с помощью ``git diff`` или ``git format-"
"patch``) в сообщение электронной почте и отправить его с помощью вашего "
"любимого почтового клиента, либо использовать опцию ``--in-reply-to`` "
"команды ``git send-email``."

#: ../doc/1.10/dev_guide/developer_guidelines.rst:301
msgid ""
"If you feel that the accumulated change set is large enough to send the "
"whole series anew and restart the review process in a different thread, "
"you generate the patch email(s) again with ``git format-patch``, this "
"time adding v2 (then v3, v4, and so forth) to the subject and a change "
"log to the message body. To modify the subject line accordingly, use the "
"``--subject-prefix`` option to ``git format-patch`` command:"
msgstr ""
"Если вы считаете, что общий набор изменений достаточно велик, чтобы "
"отправить всю серию заново и перезапустить процесс рассмотрения в рамках "
"нового обсуждения, вы снова генерируете сообщения с патчами с помощью "
"``git format-patch``, на этот раз добавив v2 (затем v3, v4 и так далее) в"
" тему и журнал изменений в тело сообщения. Чтобы соответствующим образом "
"изменить тему сообщения, используйте опцию ``--subject-prefix`` в команде"
" ``git format-patch``:"

#: ../doc/1.10/dev_guide/developer_guidelines.rst:308
msgid "$ git format-patch -1 --subject-prefix='PATCH v2'"
msgstr "$ git format-patch -1 --subject-prefix='PATCH v2'"

#: ../doc/1.10/dev_guide/developer_guidelines.rst:312
msgid ""
"To add a change log, open the generated email with you favorite text "
"editor and edit the message body. If there is just one patch, the change "
"log should go right after ``---`` in the message body (it will be ignored"
" by ``git am`` then). If there is more than one patch, the change log "
"should be added to the cover letter. Here is an example of a good change "
"log:"
msgstr ""
"Чтобы добавить журнал изменений, откройте созданное сообщение с помощью "
"любимого текстового редактора и отредактируйте тело сообщения. Если патч "
"всего один, журнал изменений должен идти сразу после ``---`` в теле "
"сообщения (тогда ``git am`` проигнорирует его). Если патчей несколько, "
"журнал изменений следует добавить в сопроводительное письмо. Хороший "
"пример журнала изменений:"

#: ../doc/1.10/dev_guide/developer_guidelines.rst:318
msgid ""
"Changes in v3:\n"
"  - Fixed comments as per review by Alex\n"
"  - Added more tests\n"
"Changes in v2:\n"
"  - Fixed a crash if the user passes invalid options\n"
"  - Fixed a memory leak at exit"
msgstr ""
"Changes in v3:\n"
"  - Fixed comments as per review by Alex\n"
"  - Added more tests\n"
" Changes in v2:\n"
"  - Fixed a crash if the user passes invalid options\n"
"  - Fixed a memory leak at exit"

#: ../doc/1.10/dev_guide/developer_guidelines.rst:327
msgid ""
"It is also a good practice to add a reference to the previous version of "
"your patch set (via a hyperlink or message id)."
msgstr ""
"Также правильно будет добавить ссылку на предыдущую версию набора патчей "
"(гиперссылку или идентификатор сообщения)."

#: ../doc/1.10/dev_guide/developer_guidelines.rst:332
msgid ""
"Do not disagree with the reviewer without providing a good argument "
"supporting your point of view."
msgstr "Не спорьте с редактором без веских аргументов в свою поддержку."

#: ../doc/1.10/dev_guide/developer_guidelines.rst:334
msgid ""
"Do not take every word the reviewer says for granted. Reviewers are "
"humans too, hence fallible."
msgstr ""
"Не принимайте любые слова редактора без доказательств. Редакторы -- тоже "
"люди, которые могут ошибаться."

#: ../doc/1.10/dev_guide/developer_guidelines.rst:336
msgid ""
"Do not expect that the reviewer will tell you how to do your thing. It is"
" not their job. The reviewer might suggest alternative ways to tackle the"
" problem, but in general it is your responsibility."
msgstr ""
"Не ждите, что редактор скажет вам, как что делать. Это не их работа. "
"Редактор может предложить пути решения проблемы, но вообще говоря, это "
"ваша обязанность."

#: ../doc/1.10/dev_guide/developer_guidelines.rst:339
msgid ""
"Do not forget to update your remote git branch every time you send a new "
"version of your patch."
msgstr ""
"Не забывайте обновлять удаленную ветку git каждый раз, когда отправляете "
"новую версию патча."

#: ../doc/1.10/dev_guide/developer_guidelines.rst:341
msgid ""
"Do follow the guidelines above. If you do not comply, your patches are "
"likely to be silently ignored."
msgstr ""
"Соблюдайте вышеуказанные рекомендации. Если вы не будете их соблюдать, "
"ваши патчи могут быть молча проигнорированы."

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:39
msgid "Documentation guidelines"
msgstr "Рекомендации по написанию документации"

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:41
msgid ""
"These guidelines are updated on the on-demand basis, covering only those "
"issues that cause pains to the existing writers. At this point, we do not"
" aim to come up with an exhaustive Documentation Style Guide for the "
"Tarantool project."
msgstr ""
"Данные рекомендации обновляются по запросу, охватывая только те проблемы,"
" которые вызывают вопросы у авторов документации. На данный момент мы не "
"стремимся разработать исчерпывающее руководство по написанию документации"
" для проекта Tarantool."

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:47
msgid "Markup issues"
msgstr "Вопросы по разметке"

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:51
msgid "Wrapping text"
msgstr "Перенос текста"

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:53
msgid ""
"The limit is 80 characters per line for plain text, and no limit for any "
"other constructions when wrapping affects ReST readability and/or HTML "
"output. Also, it makes no sense to wrap text into lines shorter than 80 "
"characters unless you have a good reason to do so."
msgstr ""
"Строка ограничена 80 символами для обычного текста и никак не ограничена "
"для любых других конструкций, когда обтекание влияет на читаемость ReST и"
" / или HTML-вывод. Кроме того, нет смысла переносить текст в строках "
"короче 80 символов, если у вас для этого нет веских оснований."

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:58
msgid ""
"The 80-character limit comes from the ISO/ANSI 80x24 screen resolution, "
"and it's unlikely that readers/writers will use 80-character consoles. "
"Yet it's still a standard for many coding guidelines (including "
"Tarantool). As for writers, the benefit is that an 80-character page "
"guide allows keeping the text window rather narrow most of the time, "
"leaving more space for other applications in a wide-screen environment."
msgstr ""
"Ограничение в 80 символов исходит из разрешения экрана ISO/ANSI 80x24, и "
"маловероятно, что читатели/писатели будут использовать 80-символьные "
"консоли. Тем не менее, такое ограничение по-прежнему является стандартом "
"во многих рекомендациях по программированию (включая Tarantool). Что "
"касается писателей, то благодаря ограничению размера страницы окно с "
"текстом может быть довольно узким, оставляя больше места для других "
"приложений в широкоэкранном окружении."

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:67
msgid "Formatting code snippets"
msgstr "Форматирование фрагментов кода"

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:69
msgid ""
"For code snippets, we mainly use the ``code-block`` directive with an "
"appropriate highlighting language. The most commonly used highlighting "
"languages are:"
msgstr ""
"Для фрагментов коды мы обычно используем директиву ``code-block`` с "
"соответствующей подсветкой синтаксиса языка. Чаще всего используем "
"следующее:"

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:73
msgid "``.. code-block:: tarantoolsession``"
msgstr "``.. code-block:: tarantoolsession``"

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:74
msgid "``.. code-block:: console``"
msgstr "``.. code-block:: console``"

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:75
msgid "``.. code-block:: lua``"
msgstr "``.. code-block:: lua``"

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:77
msgid "For example (a code snippet in Lua):"
msgstr "Например (фрагмент Lua-кода):"

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:79
msgid ""
"for page in paged_iter(\"X\", 10) do\n"
"  print(\"New Page. Number Of Tuples = \" .. #page)\n"
"  for i=1,#page,1 do print(page[i]) end\n"
"end"
msgstr ""
"for page in paged_iter(\"X\", 10) do\n"
"  print(\"New Page. Number Of Tuples = \" .. #page)\n"
"  for i=1,#page,1 do print(page[i]) end\n"
"end"

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:86
msgid ""
"In rare cases, when we need custom highlight for specific parts of a code"
" snippet and the ``code-block`` directive is not enough, we use the per-"
"line ``codenormal`` directive together and explicit output formatting "
"(defined in :file:`doc/sphinx/_static/sphinx_design.css`)."
msgstr ""
"В редких случаях при необходимости подсветить отдельные части фрагмента "
"кода, когда директивы ``code-block`` недостаточно, мы используем "
"директиву ``codenormal`` построчно вместе с явным форматированием вывода "
"(как указано в :file:`doc/sphinx/_static/sphinx_design.css`)."

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:91
msgid "Examples:"
msgstr "Примеры:"

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:93
msgid "Function syntax (the placeholder `space-name` is displayed in italics):"
msgstr "Синтаксис функции (объект-заполнитель `имя-спейса` отображается курсивом):"

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:95
msgid ""
":codenormal:`box.space.`:codeitalic:`space-"
"name`:codenormal:`:create_index('index-name')`"
msgstr ""
":codenormal:`box.space.`:codeitalic:`имя-спейса`:codenormal:`:create_index"
"('index-name')`"

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:97
msgid ""
"A tdb session (user input is in bold, command prompt is in blue, computer"
" output is in green):"
msgstr ""
"Сессия tdb (ввод информации пользователем выделяется жирным шрифтом, "
"приглашение на ввод команды -- синим, вывод -- зеленым):"

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:109
msgid ""
"Warning: Every entry of explicit output formatting (``codenormal``, "
"``codebold``, etc) tends to cause troubles when this documentation is "
"translated to other languages. Please avoid using explicit output "
"formatting unless it is REALLY needed."
msgstr ""
"Внимание: Каждая запись с явным форматированием вывода (``codenormal``, "
"``codebold`` и т.п.) часто вызывает трудности при переводе документации "
"на другие языки. Постарайтесь избегать специального форматирования, если "
"только без него никак НЕЛЬЗЯ обойтись."

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:116
msgid "Using separated links"
msgstr "Использование разделенных ссылок"

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:118
msgid "Avoid separating the link and the target definition (ref), like this:"
msgstr "Избегайте разделения ссылки и определения цели (ref), например:"

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:120
msgid ""
"This is a paragraph that contains `a link`_.\n"
"\n"
".. _a link: http://example.com/"
msgstr ""
"Это абзац, который содержит `ссылку`_.\n"
" \n"
" .. ссылка: http://example.com/"

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:126
msgid "Use non-separated links instead:"
msgstr "Используйте неразделенные ссылки:"

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:128
msgid "This is a paragraph that contains `a link <http://example.com/>`_."
msgstr "Это абзац, который содержит `ссылку <http://example.com/>`_."

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:132
msgid ""
"Warning: Every separated link tends to cause troubles when this "
"documentation is translated to other languages. Please avoid using "
"separated links unless it is REALLY needed (e.g. in tables)."
msgstr ""
"Внимание: Каждая разделенная ссылка часто вызывает трудности при переводе"
" документации на другие языки. Постарайтесь избегать разделенных ссылок, "
"если только без них никак НЕЛЬЗЯ обойтись (например, в таблицах)."

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:138
msgid "Creating labels for local links"
msgstr "Создание меток для локальных ссылок"

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:140
msgid ""
"We avoid using links that sphinx generates automatically for most "
"objects. Instead, we add our own labels for linking to any place in this "
"documentation."
msgstr ""
"Мы стараемся не использовать автоматически сгенерированные sphinx ссылки "
"для большинства объектов. Вместо них мы добавляем собственные метки для "
"ссылок на любое место в документации."

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:143
msgid "Our naming convention is as follows:"
msgstr "Соглашение об именовании заключается в следующем:"

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:145
msgid "Character set: a through z, 0 through 9, dash, underscore."
msgstr "Набор символов: от a до z, от 0 до 9, дефис, подчеркивание."

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:147
msgid "Format: ``path dash filename dash tag``"
msgstr "Формат: ``путь дефис имя файла дефис тег``"

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:149
msgid ""
"Example: ``_c_api-box_index-iterator_type`` |br| where: |br| ``c_api`` is"
" the directory name, |br| ``box_index`` is the file name (without "
"\".rst\"), and |br| ``iterator_type`` is the tag."
msgstr ""
"Пример: ``_c_api-box_index-iterator_type`` |br| где: |br| ``c_api`` -- "
"имя директории, |br| ``box_index`` -- имя файла (без \".rst\"), а |br| "
"``iterator_type`` -- тег."

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:155
msgid ""
"The file name is useful for knowing, when you see \"ref\", where it is "
"pointing to. And if the file name is meaningful, you see that better."
msgstr ""
"Имя файла используется для того, чтобы понять, куда указывает \"ref\". И "
"если имя файла имеет смысл, это гораздо понятнее."

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:158
msgid ""
"The file name alone, without a path, is enough when the file name is "
"unique within ``doc/sphinx``. So, for ``fiber.rst`` it should be just "
"\"fiber\", not \"reference-fiber\". While for \"index.rst\" (we have a "
"handful of \"index.rst\" in different directories) please specify the "
"path before the file name, e.g. \"reference-index\"."
msgstr ""
"Имени файла без пути достаточно, когда оно уникально в пределах "
"``doc/sphinx``. Поэтому для файла ``fiber.rst`` достаточно будет "
"\"fiber\", а не \"reference-fiber\". Тогда как для \"index.rst\" (а у нас"
" множество файлов \"index.rst\" в разных директориях) необходимо указать "
"путь до имени файла, например, \"reference-index\"."

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:165
msgid ""
"Use a dash \"-\" to delimit the path and the file name. In the "
"documentation source, we use only underscores \"_\" in paths and file "
"names, reserving dash \"-\" as the delimiter for local links."
msgstr ""
"Используйте дефис \"-\", чтобы разграничить путь и имя файла. В исходном "
"коде документации мы пользуемся только символами подчеркивания \"_\" при "
"указании пути и имени файла, оставляя дефисы \"-\" для разграничения в "
"локальных ссылках."

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:169
msgid ""
"The tag can be anything meaningful. The only guideline is for Tarantool "
"syntax items (such as members), where the preferred tag syntax is "
"``module_or_object_name dash member_name``. For example, ``box_space-"
"drop``."
msgstr ""
"Тег может содержать любую значимую информацию. Единственная рекомендация "
"дается для элементов синтаксиса Tarantool'а, где предпочтительно "
"использовать следующий синтаксис в тегах: ``имя_объекта_или_модуля дефис "
"имя_элемента``. Например, ``box_space-drop``."

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:175
msgid "Making comments"
msgstr "Добавление комментариев"

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:177
msgid ""
"Sometimes we may need to leave comments in a ReST file. To make sphinx "
"ignore some text during processing, use the following per-line notation "
"with \".. //\" as the comment marker:"
msgstr ""
"Иногда могут потребоваться комментарии в файле ReST. Чтобы sphinx не "
"учитывал этот текст во время обработки, используйте следующую запись в "
"каждой строке в качестве маркера комментария (\".. //\"):"

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:181
msgid ".. // your comment here"
msgstr ".. // здесь комментарий"

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:185
msgid ""
"The starting symbols \".. //\" do not interfere with the other ReST "
"markup, and they are easy to find both visually and using grep. There are"
" no symbols to escape in grep search, just go ahead with something like "
"this:"
msgstr ""
"Начальные символы \".. //\" не пересекаются с другими символами разметки "
"ReST, и их легко обнаружить как визуально, так и с помощью grep. В поиске"
" grep нет символов, которые нужно избегать, просто выполните примерно "
"следующее:"

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:189
msgid "$ grep \".. //\" doc/sphinx/dev_guide/*.rst"
msgstr "$ grep \".. //\" doc/sphinx/dev_guide/*.rst"

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:193
msgid ""
"These comments don't work properly in nested documentation, though (e.g. "
"if you leave a comment in module -> object -> method, sphinx ignores the "
"comment and all nested content that follows in the method description)."
msgstr ""
"Тем не менее, эти комментарии не сработают должным образом во вложенной "
"документации (например, если оставить комментарий в модуле -> объекте -> "
"методе, sphinx игнорирует комментарий и всё вложенное содержимое, который"
" следует в описании метода)."

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:199
msgid "Language and style issues"
msgstr "Вопросы по стилю и языку"

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:203
msgid "US vs British spelling"
msgstr "Британский или американский вариант английского"

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:205
msgid "We use English US spelling."
msgstr ""
"В английской версии документации мы придерживаемся американского варианта"
" английского языка."

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:209
msgid "Instance vs server"
msgstr "Экземпляр или сервер"

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:211
msgid ""
"We say \"instance\" rather than \"server\" to refer to an instance of "
"Tarantool server. This keeps the manual terminology consistent with names"
" like ``/etc/tarantool/instances.enabled`` in the Tarantool environment."
msgstr ""
"Ссылаясь на экземпляр Tarantool-сервера, мы говорим \"экземпляр\", а не "
"\"сервер\". Это обеспечивает однородность терминологии в руководстве и "
"именами в окружении Tarantool'а (например, "
"``/etc/tarantool/instances.enabled`` -- активные экземпляры)."

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:215
msgid ""
"Wrong usage: \"Replication allows multiple Tarantool *servers* to work on"
" copies of the same databases.\""
msgstr ""
"Неправильно: \"С помощью репликации несколько *серверов* Tarantool’а "
"могут работать на копиях одинаковых баз данных.\""

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:218
msgid ""
"Correct usage: \"Replication allows multiple Tarantool *instances* to "
"work on copies of the same databases.\""
msgstr ""
"Правильно: \"С помощью репликации несколько *экземпляров* Tarantool’а "
"могут работать на копиях одинаковых баз данных.\""

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:223
msgid "Examples and templates"
msgstr "Примеры и шаблоны"

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:227
msgid "Module and function"
msgstr "Модуль и функция"

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:229
msgid ""
"Here is an example of documenting a module (``my_fiber``) and a function "
"(``my_fiber.create``)."
msgstr ""
"Ниже приводится пример документирования модуля (``my_fiber``) и функции "
"(``my_fiber.create``)."

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:236
msgid ""
"Create and start a ``my_fiber`` object. The object is created and begins "
"to run immediately."
msgstr ""
"Создание и запуск ``my_fiber``. Происходит создание объекта, который "
"незамедлительно начинает работу."

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:239
msgid "the function to be associated with the ``my_fiber`` object"
msgstr "функция, которая будет связана с ``my_fiber``"

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:240
#: ../doc/1.10/reference/reference_lua/fiber.rst:230
#: ../doc/1.10/reference/reference_lua/fiber.rst:269
msgid "what will be passed to function"
msgstr "что передается в функцию"

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:242
msgid "created ``my_fiber`` object"
msgstr "созданный объект ``my_fiber``"

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:247
msgid ""
"tarantool> my_fiber = require('my_fiber')\n"
"---\n"
"...\n"
"tarantool> function function_name()\n"
"         >   my_fiber.sleep(1000)\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> my_fiber_object = my_fiber.create(function_name)\n"
"---\n"
"..."
msgstr ""
"tarantool> my_fiber = require('my_fiber')\n"
"---\n"
"...\n"
"tarantool> function function_name()\n"
"         >   my_fiber.sleep(1000)\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> my_fiber_object = my_fiber.create(function_name)\n"
"---\n"
"..."

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:263
msgid "Module, class and method"
msgstr "Модуль, класс и метод"

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:265
msgid ""
"Here is an example of documenting a module (``my_box.index``), a class "
"(``my_index_object``) and a function (``my_index_object.rename``)."
msgstr ""
"Ниже приводится пример документирования модуля (``my_box.index``), класса"
" (``my_index_object``) и функции (``my_index_object.rename``)."

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:276
msgid "an object reference"
msgstr "ссылка на объект"

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:277
msgid "a new name for the index (type = string)"
msgstr "новое имя для индекса (тип = строка)"

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:281
msgid "Possible errors: index_object does not exist."
msgstr "Возможные ошибки: index_object не существует."

#: ../doc/1.10/dev_guide/documentation_guidelines.rst:291
msgid "Complexity Factors: Index size, Index type, Number of tuples accessed."
msgstr ""
"Факторы сложности: Размер индекса, тип индекса, количество кортежей, к "
"которым получен доступ."

#: ../doc/1.10/dev_guide/guidelines_index.rst:37
msgid "Guidelines"
msgstr "Рекомендации"

#: ../doc/1.10/dev_guide/index.rst:39
msgid "Contributor's Guide"
msgstr "Руководство разработчика"

#: ../doc/1.10/dev_guide/internals_index.rst:37
msgid "Internals"
msgstr "Внутреннее устройство"

#: ../doc/1.10/dev_guide/box_protocol.rst:5
msgid "Tarantool's binary protocol"
msgstr "Бинарный протокол Tarantool'а"

#: ../doc/1.10/dev_guide/box_protocol.rst:7
msgid "Tarantool's binary protocol is a binary request/response protocol."
msgstr ""
"Бинарный протокол Tarantool'а представляет собой бинарный "
"запросно-ответный протокол."

#: ../doc/1.10/dev_guide/box_protocol.rst:11
msgid "Notation in diagrams"
msgstr "Система обозначений в схематическом представлении"

#: ../doc/1.10/dev_guide/box_protocol.rst:13
msgid ""
"0    X\n"
"+----+\n"
"|    | - X + 1 bytes\n"
"+----+\n"
" TYPE - type of MsgPack value (if it is a MsgPack object)\n"
"\n"
"+====+\n"
"|    | - Variable size MsgPack object\n"
"+====+\n"
" TYPE - type of MsgPack value\n"
"\n"
"+~~~~+\n"
"|    | - Variable size MsgPack Array/Map\n"
"+~~~~+\n"
" TYPE - type of MsgPack value"
msgstr ""
"0    X\n"
"+----+\n"
"|    | - X + 1 байт\n"
"+----+\n"
" TYPE - тип MsgPack-значения (если это MsgPack-объект)\n"
"\n"
"+====+\n"
"|    | - MsgPack-объект изменяемого размера\n"
"+====+\n"
" TYPE - тип MsgPack-значения\n"
"\n"
"+~~~~+\n"
"|    | - Массив или ассоциативный массив в формате MsgPack изменяемого "
"размера\n"
"+~~~~+\n"
" TYPE - тип MsgPack-значения"

#: ../doc/1.10/dev_guide/box_protocol.rst:32
msgid "MsgPack data types:"
msgstr "Типы MsgPack-данных:"

#: ../doc/1.10/dev_guide/box_protocol.rst:34
msgid "**MP_INT** - Integer"
msgstr "**MP_INT** - целое число"

#: ../doc/1.10/dev_guide/box_protocol.rst:35
msgid "**MP_MAP** - Map"
msgstr "**MP_MAP** - ассоциативный массив"

#: ../doc/1.10/dev_guide/box_protocol.rst:36
msgid "**MP_ARR** - Array"
msgstr "**MP_ARR** - массив"

#: ../doc/1.10/dev_guide/box_protocol.rst:37
msgid "**MP_STRING** - String"
msgstr "**MP_STRING** - строка"

#: ../doc/1.10/dev_guide/box_protocol.rst:38
msgid "**MP_FIXSTR** - Fixed size string"
msgstr "**MP_FIXSTR** - строка фиксированной длины"

#: ../doc/1.10/dev_guide/box_protocol.rst:39
msgid "**MP_OBJECT** - Any MsgPack object"
msgstr "**MP_OBJECT** - любой MsgPack-объект"

#: ../doc/1.10/dev_guide/box_protocol.rst:40
msgid "**MP_BIN** - MsgPack binary format"
msgstr "**MP_BIN** - бинарный формат MsgPack"

#: ../doc/1.10/dev_guide/box_protocol.rst:44
msgid "Greeting packet"
msgstr "Пакет приветствия"

#: ../doc/1.10/dev_guide/box_protocol.rst:46
msgid ""
"TARANTOOL'S GREETING:\n"
"\n"
"0                                     63\n"
"+--------------------------------------+\n"
"|                                      |\n"
"| Tarantool Greeting (server version)  |\n"
"|               64 bytes               |\n"
"+---------------------+----------------+\n"
"|                     |                |\n"
"| BASE64 encoded SALT |      NULL      |\n"
"|      44 bytes       |                |\n"
"+---------------------+----------------+\n"
"64                  107              127"
msgstr ""
"ПРИВЕТСТВИЕ TARANTOOL'А:\n"
" \n"
" 0                                     63\n"
" +--------------------------------------+\n"
" |                                      |\n"
" | Приветствие Tarantool'а (версия сервера)  |\n"
" |               64 байта               |\n"
" +---------------------+----------------+\n"
" |                     |                |\n"
" | СОЛЬ в кодировке BASE64 |      NULL      |\n"
" |      44 байта       |                |\n"
" +---------------------+----------------+\n"
" 64                  107              127"

#: ../doc/1.10/dev_guide/box_protocol.rst:62
msgid ""
"The server instance begins the dialogue by sending a fixed-size "
"(128-byte) text greeting to the client. The greeting always contains two "
"64-byte lines of ASCII text, each line ending with a newline character "
"(:code:`\\n`). The first line contains the instance version and protocol "
"type. The second line contains up to 44 bytes of base64-encoded random "
"string, to use in the authentication packet, and ends with up to 23 "
"spaces."
msgstr ""
"Экземпляр сервера начинает диалог с отправки клиенту текста приветствия "
"фиксированного размера (128 байтов). Приветствие всегда содержит две "
"64-байтные строки текста в формате ASCII, каждая строка заканчивается "
"символом разрыва строки (:code:`\\n`). Первая строка описывает версию "
"экземпляра и тип протокола. Вторая строка содержит случайную строку в "
"кодировке base64 размером до 44 байтов для использования в пакете "
"аутентификации и заканчивается на пробелы (до 23)."

#: ../doc/1.10/dev_guide/box_protocol.rst:70
msgid "Unified packet structure"
msgstr "Унифицированная структура пакета"

#: ../doc/1.10/dev_guide/box_protocol.rst:72
msgid ""
"Once a greeting is read, the protocol becomes pure request/response and "
"features a complete access to Tarantool functionality, including:"
msgstr ""
"После того, как приветствие прочитано, протокол становится простым "
"запросно-ответным протоколом и предоставляет полный доступ к функциям "
"Tarantool'а, включая:"

#: ../doc/1.10/dev_guide/box_protocol.rst:75
msgid ""
"request multiplexing, e.g. ability to asynchronously issue multiple "
"requests via the same connection"
msgstr ""
"мультиплексирование запросов, т.е. возможность асинхронной отправки "
"множества запросов по одному соединению;"

#: ../doc/1.10/dev_guide/box_protocol.rst:77
msgid "response format that supports zero-copy writes"
msgstr ""
"формат ответа, который поддерживает запись в режиме без копирования "
"(zero-copy)."

#: ../doc/1.10/dev_guide/box_protocol.rst:79
msgid ""
"The protocol uses `msgpack <http://msgpack.org>`_ for data structures and"
" encoding."
msgstr ""
"Для структуризации и кодирования данных протокол использует формат данных"
" `msgpack <http://msgpack.org>`_."

#: ../doc/1.10/dev_guide/box_protocol.rst:82
msgid ""
"The protocol uses maps that contain some integer constants as keys. These"
" constants are defined in `src/box/iproto_constants.h "
"<https://github.com/tarantool/tarantool/blob/1.9/src/box/iproto_constants.h>`_."
" We list common constants here:"
msgstr ""
"Протокол использует ассоциативные массивы, которые содержат несколько "
"целочисленных постоянных, в качестве ключей. Эти постоянные указаны по "
"ссылке `src/box/iproto_constants.h "
"<https://github.com/tarantool/tarantool/blob/1.9/src/box/iproto_constants.h>`_."
" Ниже приведены часто используемые постоянные:"

#: ../doc/1.10/dev_guide/box_protocol.rst:87
msgid ""
"-- user keys\n"
"<iproto_sync>          ::= 0x01\n"
"<iproto_schema_id>     ::= 0x05  /* also known as schema_version */\n"
"<iproto_space_id>      ::= 0x10\n"
"<iproto_index_id>      ::= 0x11\n"
"<iproto_limit>         ::= 0x12\n"
"<iproto_offset>        ::= 0x13\n"
"<iproto_iterator>      ::= 0x14\n"
"<iproto_key>           ::= 0x20\n"
"<iproto_tuple>         ::= 0x21\n"
"<iproto_function_name> ::= 0x22\n"
"<iproto_username>      ::= 0x23\n"
"<iproto_expr>          ::= 0x27 /* also known as expression */\n"
"<iproto_ops>           ::= 0x28\n"
"<iproto_data>          ::= 0x30\n"
"<iproto_error>         ::= 0x31"
msgstr ""
"-- пользовательские ключи\n"
"<iproto_sync>          ::= 0x01\n"
"<iproto_schema_id>     ::= 0x05  /* также schema_version */\n"
"<iproto_space_id>      ::= 0x10\n"
"<iproto_index_id>      ::= 0x11\n"
"<iproto_limit>         ::= 0x12\n"
"<iproto_offset>        ::= 0x13\n"
"<iproto_iterator>      ::= 0x14\n"
"<iproto_key>           ::= 0x20\n"
"<iproto_tuple>         ::= 0x21\n"
"<iproto_function_name> ::= 0x22\n"
"<iproto_username>      ::= 0x23\n"
"<iproto_expr>          ::= 0x27 /* также expression */\n"
"<iproto_ops>           ::= 0x28\n"
"<iproto_data>          ::= 0x30\n"
"<iproto_error>         ::= 0x31"

#: ../doc/1.10/dev_guide/box_protocol.rst:106
msgid ""
"-- -- Value for <code> key in request can be:\n"
"-- User command codes\n"
"<iproto_select>       ::= 0x01\n"
"<iproto_insert>       ::= 0x02\n"
"<iproto_replace>      ::= 0x03\n"
"<iproto_update>       ::= 0x04\n"
"<iproto_delete>       ::= 0x05\n"
"<iproto_call_16>      ::= 0x06 /* as used in version 1.6 */\n"
"<iproto_auth>         ::= 0x07\n"
"<iproto_eval>         ::= 0x08\n"
"<iproto_upsert>       ::= 0x09\n"
"<iproto_call>         ::= 0x0a\n"
"-- Admin command codes\n"
"-- (including codes for replica-set initialization and master election)\n"
"<iproto_ping>         ::= 0x40\n"
"<iproto_join>         ::= 0x41 /* i.e. replication join */\n"
"<iproto_subscribe>    ::= 0x42\n"
"<iproto_request_vote> ::= 0x43\n"
"\n"
"-- -- Value for <code> key in response can be:\n"
"<iproto_ok>           ::= 0x00\n"
"<iproto_type_error>   ::= 0x8XXX /* where XXX is a value in errcode.h */"
msgstr ""
"-- -- Значение ключа <code> в запросе может быть следующим:\n"
"-- Ключи для команд пользователя\n"
"<iproto_select>       ::= 0x01\n"
"<iproto_insert>       ::= 0x02\n"
"<iproto_replace>      ::= 0x03\n"
"<iproto_update>       ::= 0x04\n"
"<iproto_delete>       ::= 0x05\n"
"<iproto_call_16>      ::= 0x06 /* as used in version 1.6 */\n"
"<iproto_auth>         ::= 0x07\n"
"<iproto_eval>         ::= 0x08\n"
"<iproto_upsert>       ::= 0x09\n"
"<iproto_call>         ::= 0x0a\n"
"-- Коды для команд администратора\n"
"-- (включая коды для инициализации набора реплик и выбора мастера)\n"
"<iproto_ping>         ::= 0x40\n"
"<iproto_join>         ::= 0x41 /* i.e. replication join */\n"
"<iproto_subscribe>    ::= 0x42\n"
"<iproto_request_vote> ::= 0x43\n"
"\n"
"-- -- Значение для ключа <code> в ответе может быть следующим:\n"
"<iproto_ok>           ::= 0x00\n"
"<iproto_type_error>   ::= 0x8XXX /* где XXX -- это значение в errcode.h */"

#: ../doc/1.10/dev_guide/box_protocol.rst:132
msgid "Both :code:`<header>` and :code:`<body>` are msgpack maps:"
msgstr ""
"И заголовок :code:`<header>` и тело сообщения :code:`<body>` представляют"
" собой ассоциативные массивы в формате msgpack:"

#: ../doc/1.10/dev_guide/box_protocol.rst:134
msgid ""
"Request/Response:\n"
"\n"
"0        5\n"
"+--------+ +============+ +===================================+\n"
"| BODY + | |            | |                                   |\n"
"| HEADER | |   HEADER   | |               BODY                |\n"
"|  SIZE  | |            | |                                   |\n"
"+--------+ +============+ +===================================+\n"
"  MP_INT       MP_MAP                     MP_MAP"
msgstr ""
"Запрос / ответ:\n"
" \n"
"0        5\n"
"+--------+ +============+ +===================================+\n"
"| BODY + | |            | |                                   |\n"
"| HEADER | |   HEADER   | |               BODY                |\n"
"|  SIZE  | |            | |                                   |\n"
"+--------+ +============+ +===================================+\n"
"  MP_INT       MP_MAP                     MP_MAP"

#: ../doc/1.10/dev_guide/box_protocol.rst:146
msgid ""
"UNIFIED HEADER:\n"
"\n"
"+================+================+=====================+\n"
"|                |                |                     |\n"
"|   0x00: CODE   |   0x01: SYNC   |    0x05: SCHEMA_ID  |\n"
"| MP_INT: MP_INT | MP_INT: MP_INT |  MP_INT: MP_INT     |\n"
"|                |                |                     |\n"
"+================+================+=====================+\n"
"                          MP_MAP"
msgstr ""
"УНИФИЦИРОВАННЫЙ ЗАГОЛОВОК:\n"
"\n"
"+================+================+=====================+\n"
"|                |                |                     |\n"
"|   0x00: CODE   |   0x01: SYNC   |    0x05: SCHEMA_ID  |\n"
"| MP_INT: MP_INT | MP_INT: MP_INT |  MP_INT: MP_INT     |\n"
"|                |                |                     |\n"
"+================+================+=====================+\n"
"                          MP_MAP"

#: ../doc/1.10/dev_guide/box_protocol.rst:158
msgid ""
"They only differ in the allowed set of keys and values. The key defines "
"the type of value that follows. If a body has no keys, the entire msgpack"
" map for the body may be missing. Such is the case, for example, for a "
"<ping> request. ``schema_id`` may be absent in the request's header, "
"meaning that there will be no version checking, but it must be present in"
" the response. If ``schema_id`` is sent in the header, then it will be "
"checked."
msgstr ""
"Они различаются лишь набором допустимых ключей и значений. Ключ "
"определяет тип следующего за ним значения. Если в теле сообщения нет "
"ключей, может отсутствовать весь ассоциативный массив в формате msgpack "
"для тела сообщения. Так и случится при запросе проверки связи <ping>. "
"``schema_id`` может отсутствовать в заголовке запроса, что означает "
"отсутствие проверки версии, но этот ключ обязательно должен "
"присутствовать в ответе. Если ``schema_id`` отправляется в заголовке, "
"будет выполнена соответствующая проверка."

#: ../doc/1.10/dev_guide/box_protocol.rst:169
msgid "Authentication"
msgstr "Аутентификация"

#: ../doc/1.10/dev_guide/box_protocol.rst:171
msgid ""
"When a client connects to the server instance, the instance responds with"
" a 128-byte text greeting message. Part of the greeting is base-64 "
"encoded session salt - a random string which can be used for "
"authentication. The length of decoded salt (44 bytes) exceeds the amount "
"necessary to sign the authentication message (first 20 bytes). An excess "
"is reserved for future authentication schemas."
msgstr ""
"Когда клиент подключается к экземпляру сервера, экземпляр отвечает "
"128-байтным текстовым сообщением приветствия. Часть приветствия "
"представляет собой закодированное в формате base-64 значение соль для "
"сессии (случайная строка), которое можно использовать для аутентификации."
" Длина расшифрованного значения соль (44 байта) выходит за пределы "
"сообщения для аутентификации (первые 20 байтов). Остаток предназначается "
"для будущих схем аутентификации."

#: ../doc/1.10/dev_guide/box_protocol.rst:178
msgid ""
"PREPARE SCRAMBLE:\n"
"\n"
"    LEN(ENCODED_SALT) = 44;\n"
"    LEN(SCRAMBLE)     = 20;\n"
"\n"
"prepare 'chap-sha1' scramble:\n"
"\n"
"    salt = base64_decode(encoded_salt);\n"
"    step_1 = sha1(password);\n"
"    step_2 = sha1(step_1);\n"
"    step_3 = sha1(salt, step_2);\n"
"    scramble = xor(step_1, step_3);\n"
"    return scramble;\n"
"\n"
"AUTHORIZATION BODY: CODE = 0x07\n"
"\n"
"+==================+====================================+\n"
"|                  |        +-------------+-----------+ |\n"
"|  (KEY)           | (TUPLE)|  len == 9   | len == 20 | |\n"
"|   0x23:USERNAME  |   0x21:| \"chap-sha1\" |  SCRAMBLE | |\n"
"| MP_INT:MP_STRING | MP_INT:|  MP_STRING  |  MP_BIN   | |\n"
"|                  |        +-------------+-----------+ |\n"
"|                  |                   MP_ARRAY         |\n"
"+==================+====================================+\n"
"                        MP_MAP"
msgstr ""
"ПОДГОТОВКА КОДИРОВАНИЯ:\n"
"\n"
"    LEN(ENCODED_SALT) = 44;\n"
"    LEN(SCRAMBLE)     = 20;\n"
"\n"
"подготовить кодирование 'chap-sha1':\n"
"\n"
"    salt = base64_decode(encoded_salt);\n"
"    step_1 = sha1(password);\n"
"    step_2 = sha1(step_1);\n"
"    step_3 = sha1(salt, step_2);\n"
"    scramble = xor(step_1, step_3);\n"
"    return scramble;\n"
"\n"
"ТЕЛО СООБЩЕНИЯ АВТОРИЗАЦИИ: CODE = 0x07\n"
"\n"
"+==================+====================================+\n"
"|                  |        +-------------+-----------+ |\n"
"|  (KEY)           | (TUPLE)|  len == 9   | len == 20 | |\n"
"|   0x23:USERNAME  |   0x21:| \"chap-sha1\" |  SCRAMBLE | |\n"
"| MP_INT:MP_STRING | MP_INT:|  MP_STRING  |  MP_BIN   | |\n"
"|                  |        +-------------+-----------+ |\n"
"|                  |                   MP_ARRAY         |\n"
"+==================+====================================+\n"
"                        MP_MAP"

#: ../doc/1.10/dev_guide/box_protocol.rst:206
msgid ""
":code:`<key>` holds the user name. :code:`<tuple>` must be an array of 2 "
"fields: authentication mechanism (\"chap-sha1\" is the only supported "
"mechanism right now) and password, encrypted according to the specified "
"mechanism. Authentication in Tarantool is optional, if no authentication "
"is performed, session user is 'guest'. The instance responds to "
"authentication packet with a standard response with 0 tuples."
msgstr ""
":code:`<key>` содержит имя пользователя. :code:`<tuple>` должен "
"представлять собой массив из 2 полей: механизм аутентификации (в данный "
"момент поддерживается только механизм \"chap-sha1\") и пароль, "
"закодированный в соответствии с указанным механизмом. Аутентификация в "
"Tarantool'е необязательна: если аутентификация не проводится, то "
"пользователем в сессии будет 'guest'. Экземпляр отвечает на пакет "
"аутентификации стандартным ответом с 0 кортежей."

#: ../doc/1.10/dev_guide/box_protocol.rst:214
msgid "Requests"
msgstr "Запросы"

#: ../doc/1.10/dev_guide/box_protocol.rst:216
msgid "SELECT: CODE - 0x01 Find tuples matching the search pattern"
msgstr "SELECT: CODE - 0x01 Поиск кортежей, соответствующих шаблону поиска"

#: ../doc/1.10/dev_guide/box_protocol.rst:219
msgid ""
"SELECT BODY:\n"
"\n"
"+==================+==================+==================+\n"
"|                  |                  |                  |\n"
"|   0x10: SPACE_ID |   0x11: INDEX_ID |   0x12: LIMIT    |\n"
"| MP_INT: MP_INT   | MP_INT: MP_INT   | MP_INT: MP_INT   |\n"
"|                  |                  |                  |\n"
"+==================+==================+==================+\n"
"|                  |                  |                  |\n"
"|   0x13: OFFSET   |   0x14: ITERATOR |   0x20: KEY      |\n"
"| MP_INT: MP_INT   | MP_INT: MP_INT   | MP_INT: MP_ARRAY |\n"
"|                  |                  |                  |\n"
"+==================+==================+==================+\n"
"                          MP_MAP"
msgstr ""
"ТЕЛО СООБЩЕНИЯ ВЫБОРКИ SELECT:\n"
"\n"
"+==================+==================+==================+\n"
"|                  |                  |                  |\n"
"|   0x10: SPACE_ID |   0x11: INDEX_ID |   0x12: LIMIT    |\n"
"| MP_INT: MP_INT   | MP_INT: MP_INT   | MP_INT: MP_INT   |\n"
"|                  |                  |                  |\n"
"+==================+==================+==================+\n"
"|                  |                  |                  |\n"
"|   0x13: OFFSET   |   0x14: ITERATOR |   0x20: KEY      |\n"
"| MP_INT: MP_INT   | MP_INT: MP_INT   | MP_INT: MP_ARRAY |\n"
"|                  |                  |                  |\n"
"+==================+==================+==================+\n"
"                          MP_MAP"

#: ../doc/1.10/dev_guide/box_protocol.rst:236
msgid ""
"INSERT:  CODE - 0x02 Inserts tuple into the space, if no tuple with same "
"unique keys exists. Otherwise throw *duplicate key* error."
msgstr ""
"INSERT:  CODE - 0x02 Вставка кортежа в спейс, если нет кортежей с такими "
"же уникальными ключами. Если есть, выдать ошибку *duplicate key* "
"(повторяющееся значение ключа)."

#: ../doc/1.10/dev_guide/box_protocol.rst:238
msgid ""
"REPLACE: CODE - 0x03 Insert a tuple into the space or replace an existing"
" one."
msgstr ""
"REPLACE: CODE - 0x03 Вставка кортежа в спейс или замена существующего "
"кортежа."

#: ../doc/1.10/dev_guide/box_protocol.rst:241
msgid ""
"INSERT/REPLACE BODY:\n"
"\n"
"+==================+==================+\n"
"|                  |                  |\n"
"|   0x10: SPACE_ID |   0x21: TUPLE    |\n"
"| MP_INT: MP_INT   | MP_INT: MP_ARRAY |\n"
"|                  |                  |\n"
"+==================+==================+\n"
"                 MP_MAP"
msgstr ""
"ТЕЛО СООБЩЕНИЯ ВСТАВКИ/ЗАМЕНЫ INSERT/REPLACE:\n"
"\n"
"+==================+==================+\n"
"|                  |                  |\n"
"|   0x10: SPACE_ID |   0x21: TUPLE    |\n"
"| MP_INT: MP_INT   | MP_INT: MP_ARRAY |\n"
"|                  |                  |\n"
"+==================+==================+\n"
"                 MP_MAP"

#: ../doc/1.10/dev_guide/box_protocol.rst:254
msgid "UPDATE: CODE - 0x04 Update a tuple"
msgstr "UPDATE: CODE - 0x04 Обновление кортежа"

#: ../doc/1.10/dev_guide/box_protocol.rst:257
msgid ""
"UPDATE BODY:\n"
"\n"
"+==================+=======================+\n"
"|                  |                       |\n"
"|   0x10: SPACE_ID |   0x11: INDEX_ID      |\n"
"| MP_INT: MP_INT   | MP_INT: MP_INT        |\n"
"|                  |                       |\n"
"+==================+=======================+\n"
"|                  |          +~~~~~~~~~~+ |\n"
"|                  |          |          | |\n"
"|                  | (TUPLE)  |    OP    | |\n"
"|   0x20: KEY      |    0x21: |          | |\n"
"| MP_INT: MP_ARRAY |  MP_INT: +~~~~~~~~~~+ |\n"
"|                  |            MP_ARRAY   |\n"
"+==================+=======================+\n"
"                 MP_MAP"
msgstr ""
"ТЕЛО СООБЩЕНИЯ ОБНОВЛЕНИЯ UPDATE:\n"
"\n"
"+==================+=======================+\n"
"|                  |                       |\n"
"|   0x10: SPACE_ID |   0x11: INDEX_ID      |\n"
"| MP_INT: MP_INT   | MP_INT: MP_INT        |\n"
"|                  |                       |\n"
"+==================+=======================+\n"
"|                  |          +~~~~~~~~~~+ |\n"
"|                  |          |          | |\n"
"|                  | (TUPLE)  |    OP    | |\n"
"|   0x20: KEY      |    0x21: |          | |\n"
"| MP_INT: MP_ARRAY |  MP_INT: +~~~~~~~~~~+ |\n"
"|                  |            MP_ARRAY   |\n"
"+==================+=======================+\n"
"                 MP_MAP"

#: ../doc/1.10/dev_guide/box_protocol.rst:276
msgid ""
"OP:\n"
"    Works only for integer fields:\n"
"    * Addition    OP = '+' . space[key][field_no] += argument\n"
"    * Subtraction OP = '-' . space[key][field_no] -= argument\n"
"    * Bitwise AND OP = '&' . space[key][field_no] &= argument\n"
"    * Bitwise XOR OP = '^' . space[key][field_no] ^= argument\n"
"    * Bitwise OR  OP = '|' . space[key][field_no] |= argument\n"
"    Works on any fields:\n"
"    * Delete      OP = '#'\n"
"      delete <argument> fields starting\n"
"      from <field_no> in the space[<key>]\n"
"\n"
"0           2\n"
"+-----------+==========+==========+\n"
"|           |          |          |\n"
"|    OP     | FIELD_NO | ARGUMENT |\n"
"| MP_FIXSTR |  MP_INT  |  MP_INT  |\n"
"|           |          |          |\n"
"+-----------+==========+==========+\n"
"              MP_ARRAY"
msgstr ""
"OP:\n"
"    Работает только для целочисленных полей:\n"
"    * Сложение    OP = '+' . space[key][field_no] += argument\n"
"    * Вычитание OP = '-' . space[key][field_no] -= argument\n"
"    * Побитовое И OP = '&' . space[key][field_no] &= argument\n"
"    * Исключающее ИЛИ OP = '^' . space[key][field_no] ^= argument\n"
"    * Побитовое ИЛИ  OP = '|' . space[key][field_no] |= аргумент\n"
"    Работает для любых полей:\n"
"    * Удаление      OP = '#'\n"
"      удалить поля <argument>, начиная\n"
"      с поля <field_no> в спейсе с ключом space[<key>]\n"
"\n"
"0           2\n"
"+-----------+==========+==========+\n"
"|           |          |          |\n"
"|    OP     | FIELD_NO | ARGUMENT |\n"
"| MP_FIXSTR |  MP_INT  |  MP_INT  |\n"
"|           |          |          |\n"
"+-----------+==========+==========+\n"
"              MP_ARRAY"

#: ../doc/1.10/dev_guide/box_protocol.rst:299
msgid ""
"    * Insert      OP = '!'\n"
"      insert <argument> before <field_no>\n"
"    * Assign      OP = '='\n"
"      assign <argument> to field <field_no>.\n"
"      will extend the tuple if <field_no> == <max_field_no> + 1\n"
"\n"
"0           2\n"
"+-----------+==========+===========+\n"
"|           |          |           |\n"
"|    OP     | FIELD_NO | ARGUMENT  |\n"
"| MP_FIXSTR |  MP_INT  | MP_OBJECT |\n"
"|           |          |           |\n"
"+-----------+==========+===========+\n"
"              MP_ARRAY\n"
"\n"
"    Works on string fields:\n"
"    * Splice      OP = ':'\n"
"      take the string from space[key][field_no] and\n"
"      substitute <offset> bytes from <position> with <argument>"
msgstr ""
"    * Вставка      OP = '!'\n"
"      вставить <argument> до поля <field_no>\n"
"    * Присвоение      OP = '='\n"
"      присвоить <argument> полю <field_no>.\n"
"      увеличит кортеж, если <field_no> == <max_field_no> + 1\n"
"\n"
"0           2\n"
"+-----------+==========+===========+\n"
"|           |          |           |\n"
"|    OP     | FIELD_NO | ARGUMENT  |\n"
"| MP_FIXSTR |  MP_INT  | MP_OBJECT |\n"
"|           |          |           |\n"
"+-----------+==========+===========+\n"
"              MP_ARRAY\n"
"\n"
"    Работает со строковыми полями:\n"
"    * Разделение      OP = ':'\n"
"      взять строку из space[key][field_no] и\n"
"      заменить <offset> байтов из положения <position> на <argument>"

#: ../doc/1.10/dev_guide/box_protocol.rst:321
msgid ""
"0           2\n"
"+-----------+==========+==========+========+==========+\n"
"|           |          |          |        |          |\n"
"|    ':'    | FIELD_NO | POSITION | OFFSET | ARGUMENT |\n"
"| MP_FIXSTR |  MP_INT  |  MP_INT  | MP_INT |  MP_STR  |\n"
"|           |          |          |        |          |\n"
"+-----------+==========+==========+========+==========+\n"
"                         MP_ARRAY"
msgstr ""
"0           2\n"
"+-----------+==========+==========+========+==========+\n"
"|           |          |          |        |          |\n"
"|    ':'    | FIELD_NO | POSITION | OFFSET | ARGUMENT |\n"
"| MP_FIXSTR |  MP_INT  |  MP_INT  | MP_INT |  MP_STR  |\n"
"|           |          |          |        |          |\n"
"+-----------+==========+==========+========+==========+\n"
"                         MP_ARRAY"

#: ../doc/1.10/dev_guide/box_protocol.rst:333
msgid ""
"It is an error to specify an argument of a type that differs from the "
"expected type."
msgstr ""
"Указать аргумент типа, который отличается от ожидаемого типа, будет "
"ошибкой."

#: ../doc/1.10/dev_guide/box_protocol.rst:335
msgid "DELETE: CODE - 0x05 Delete a tuple"
msgstr "DELETE: CODE - 0x05 Удаление кортежа"

#: ../doc/1.10/dev_guide/box_protocol.rst:338
msgid ""
"DELETE BODY:\n"
"\n"
"+==================+==================+==================+\n"
"|                  |                  |                  |\n"
"|   0x10: SPACE_ID |   0x11: INDEX_ID |   0x20: KEY      |\n"
"| MP_INT: MP_INT   | MP_INT: MP_INT   | MP_INT: MP_ARRAY |\n"
"|                  |                  |                  |\n"
"+==================+==================+==================+\n"
"                          MP_MAP"
msgstr ""
"ТЕЛО СООБЩЕНИЯ УДАЛЕНИЯ DELETE:\n"
"\n"
"+==================+==================+==================+\n"
"|                  |                  |                  |\n"
"|   0x10: SPACE_ID |   0x11: INDEX_ID |   0x20: KEY      |\n"
"| MP_INT: MP_INT   | MP_INT: MP_INT   | MP_INT: MP_ARRAY |\n"
"|                  |                  |                  |\n"
"+==================+==================+==================+\n"
"                          MP_MAP"

#: ../doc/1.10/dev_guide/box_protocol.rst:351
msgid ""
"CALL_16: CODE - 0x06 Call a stored function, returning an array of "
"tuples. This is deprecated; CALL (0x0a) is recommended instead."
msgstr ""
"CALL_16: CODE - 0x06 Вызов хранимой функции с возвратом массива кортежей."
" Объявлен устаревшим; рекомендуется использовать CALL (0x0a)."

#: ../doc/1.10/dev_guide/box_protocol.rst:354
msgid ""
"CALL_16 BODY:\n"
"\n"
"+=======================+==================+\n"
"|                       |                  |\n"
"|   0x22: FUNCTION_NAME |   0x21: TUPLE    |\n"
"| MP_INT: MP_STRING     | MP_INT: MP_ARRAY |\n"
"|                       |                  |\n"
"+=======================+==================+\n"
"                    MP_MAP"
msgstr ""
"ТЕЛО СООБЩЕНИЯ CALL_16:\n"
"\n"
"+=======================+==================+\n"
"|                       |                  |\n"
"|   0x22: FUNCTION_NAME |   0x21: TUPLE    |\n"
"| MP_INT: MP_STRING     | MP_INT: MP_ARRAY |\n"
"|                       |                  |\n"
"+=======================+==================+\n"
"                    MP_MAP"

#: ../doc/1.10/dev_guide/box_protocol.rst:368
msgid "EVAL: CODE - 0x08 Evaulate Lua expression"
msgstr "EVAL: CODE - 0x08 Оценка Lua-выражения"

#: ../doc/1.10/dev_guide/box_protocol.rst:371
msgid ""
"EVAL BODY:\n"
"\n"
"+=======================+==================+\n"
"|                       |                  |\n"
"|   0x27: EXPRESSION    |   0x21: TUPLE    |\n"
"| MP_INT: MP_STRING     | MP_INT: MP_ARRAY |\n"
"|                       |                  |\n"
"+=======================+==================+\n"
"                    MP_MAP"
msgstr ""
"ТЕЛО СООБЩЕНИЯ EVAL:\n"
"\n"
"+=======================+==================+\n"
"|                       |                  |\n"
"|   0x27: EXPRESSION    |   0x21: TUPLE    |\n"
"| MP_INT: MP_STRING     | MP_INT: MP_ARRAY |\n"
"|                       |                  |\n"
"+=======================+==================+\n"
"                    MP_MAP"

#: ../doc/1.10/dev_guide/box_protocol.rst:384
msgid ""
"UPSERT: CODE - 0x09 Update tuple if it would be found elsewhere try to "
"insert tuple. Always use primary index for key."
msgstr ""
"UPSERT: CODE - 0x09 Обновление кортежа, если он уже существует, попытка "
"вставить кортеж. Всегда используйте первичный индекс."

#: ../doc/1.10/dev_guide/box_protocol.rst:387
msgid ""
"UPSERT BODY:\n"
"\n"
"+==================+==================+==========================+\n"
"|                  |                  |             +~~~~~~~~~~+ |\n"
"|                  |                  |             |          | |\n"
"|   0x10: SPACE_ID |   0x21: TUPLE    |       (OPS) |    OP    | |\n"
"| MP_INT: MP_INT   | MP_INT: MP_ARRAY |       0x28: |          | |\n"
"|                  |                  |     MP_INT: +~~~~~~~~~~+ |\n"
"|                  |                  |               MP_ARRAY   |\n"
"+==================+==================+==========================+\n"
"                                MP_MAP\n"
"\n"
"Operations structure same as for UPDATE operation.\n"
"   0           2\n"
"+-----------+==========+==========+\n"
"|           |          |          |\n"
"|    OP     | FIELD_NO | ARGUMENT |\n"
"| MP_FIXSTR |  MP_INT  |  MP_INT  |\n"
"|           |          |          |\n"
"+-----------+==========+==========+\n"
"              MP_ARRAY\n"
"\n"
"Supported operations:\n"
"\n"
"'+' - add a value to a numeric field. If the filed is not numeric, it's\n"
"      changed to 0 first. If the field does not exist, the operation is\n"
"      skipped. There is no error in case of overflow either, the value\n"
"      simply wraps around in C style. The range of the integer is "
"MsgPack:\n"
"      from -2^63 to 2^64-1\n"
"'-' - same as the previous, but subtract a value\n"
"'=' - assign a field to a value. The field must exist, if it does not "
"exist,\n"
"      the operation is skipped.\n"
"'!' - insert a field. It's only possible to insert a field if this create"
" no\n"
"      nil \"gaps\" between fields. E.g. it's possible to add a field "
"between\n"
"      existing fields or as the last field of the tuple.\n"
"'#' - delete a field. If the field does not exist, the operation is "
"skipped.\n"
"      It's not possible to change with update operations a part of the "
"primary\n"
"      key (this is validated before performing upsert)."
msgstr ""
"ТЕЛО СООБЩЕНИЯ ОБНОВЛЕНИЯ И ВСТАВКИ UPSERT:\n"
"\n"
"+==================+==================+==========================+\n"
"|                  |                  |             +~~~~~~~~~~+ |\n"
"|                  |                  |             |          | |\n"
"|   0x10: SPACE_ID |   0x21: TUPLE    |       (OPS) |    OP    | |\n"
"| MP_INT: MP_INT   | MP_INT: MP_ARRAY |       0x28: |          | |\n"
"|                  |                  |     MP_INT: +~~~~~~~~~~+ |\n"
"|                  |                  |               MP_ARRAY   |\n"
"+==================+==================+==========================+\n"
"                                MP_MAP\n"
"\n"
"Структура операции аналогична структуре операции обновления UPDATE.\n"
"   0           2\n"
"+-----------+==========+==========+\n"
"|           |          |          |\n"
"|    OP     | FIELD_NO | ARGUMENT |\n"
"| MP_FIXSTR |  MP_INT  |  MP_INT  |\n"
"|           |          |          |\n"
"+-----------+==========+==========+\n"
"              MP_ARRAY\n"
"\n"
"Поддерживаются следующие операции:\n"
"\n"
"'+' - прибавление значения к числовому полю. Если поле не является "
"числовым, оно\n"
"      сначала изменяется на 0. Если поле отсутствует, операция\n"
"      пропускается. В случае переполнения ошибки также не будет, значение"
"\n"
"      просто переносится в стиле языка C. Диапазон целых чисел в формате "
"MsgPack:\n"
"      от -2^63 до 2^64-1\n"
"'-' - как в предыдущей операции, но значение вычитается\n"
"'=' - присвоение значения полю. Если поле отсутствует,\n"
"      операция пропускается.\n"
"'!' - вставка поля. Можно вставить поле, если при этом не будут созданы\n"
"      промежутки с нулевым значением nil между полями. Например, можно "
"добавить поле между\n"
"      существующими полями или последнее поле в кортеже.\n"
"'#' - удаление поля. Если поле отсутствует, операция пропускается.\n"
"      Нельзя с помощью операции обновления update изменить компонент "
"первичного\n"
"      ключа (это проверяется перед выполнением операции upsert)."

#: ../doc/1.10/dev_guide/box_protocol.rst:428
msgid ""
"CALL: CODE - 0x0a Similar to CALL_16, but -- like EVAL, CALL returns a "
"list of values, unconverted"
msgstr ""
"CALL: CODE - 0x0a Аналог CALL_16, но как и операция EVAL, CALL возвращает"
" список неконвертированных значений"

#: ../doc/1.10/dev_guide/box_protocol.rst:431
msgid ""
"CALL BODY:\n"
"\n"
"+=======================+==================+\n"
"|                       |                  |\n"
"|   0x22: FUNCTION_NAME |   0x21: TUPLE    |\n"
"| MP_INT: MP_STRING     | MP_INT: MP_ARRAY |\n"
"|                       |                  |\n"
"+=======================+==================+\n"
"                    MP_MAP"
msgstr ""
"ТЕЛО СООБЩЕНИЯ CALL:\n"
"\n"
"+=======================+==================+\n"
"|                       |                  |\n"
"|   0x22: FUNCTION_NAME |   0x21: TUPLE    |\n"
"| MP_INT: MP_STRING     | MP_INT: MP_ARRAY |\n"
"|                       |                  |\n"
"+=======================+==================+\n"
"                    MP_MAP"

#: ../doc/1.10/dev_guide/box_protocol.rst:446
msgid "Response packet structure"
msgstr "Структура пакета ответа"

#: ../doc/1.10/dev_guide/box_protocol.rst:448
msgid "We will show whole packets here:"
msgstr "Здесь мы продемонстрируем пакеты полностью:"

#: ../doc/1.10/dev_guide/box_protocol.rst:450
msgid ""
"OK:    LEN + HEADER + BODY\n"
"\n"
"0      5                                          OPTIONAL\n"
"+------++================+================++===================+\n"
"|      ||                |                ||                   |\n"
"| BODY ||   0x00: 0x00   |   0x01: SYNC   ||   0x30: DATA      |\n"
"|HEADER|| MP_INT: MP_INT | MP_INT: MP_INT || MP_INT: MP_OBJECT |\n"
"| SIZE ||                |                ||                   |\n"
"+------++================+================++===================+\n"
" MP_INT                MP_MAP                      MP_MAP"
msgstr ""
"OK:    LEN + HEADER + BODY\n"
"\n"
"0      5                                          OPTIONAL\n"
"+------++================+================++===================+\n"
"|      ||                |                ||                   |\n"
"| BODY ||   0x00: 0x00   |   0x01: SYNC   ||   0x30: DATA      |\n"
"|HEADER|| MP_INT: MP_INT | MP_INT: MP_INT || MP_INT: MP_OBJECT |\n"
"| SIZE ||                |                ||                   |\n"
"+------++================+================++===================+\n"
" MP_INT                MP_MAP                      MP_MAP"

#: ../doc/1.10/dev_guide/box_protocol.rst:464
msgid ""
"Set of tuples in the response :code:`<data>` expects a msgpack array of "
"tuples as value EVAL command returns arbitrary `MP_ARRAY` with arbitrary "
"MsgPack values."
msgstr ""
"Предполагается, что набор кортежей в ответе :code:`<data>` будет "
"представлять собой msgpack-массив кортежей, поскольку команда EVAL "
"возвращается произвольный MsgPack-массив `MP_ARRAY` с произвольными "
"MsgPack-значениями."

#: ../doc/1.10/dev_guide/box_protocol.rst:467
msgid ""
"ERROR: LEN + HEADER + BODY\n"
"\n"
"0      5\n"
"+------++================+================++===================+\n"
"|      ||                |                ||                   |\n"
"| BODY ||   0x00: 0x8XXX |   0x01: SYNC   ||   0x31: ERROR     |\n"
"|HEADER|| MP_INT: MP_INT | MP_INT: MP_INT || MP_INT: MP_STRING |\n"
"| SIZE ||                |                ||                   |\n"
"+------++================+================++===================+\n"
" MP_INT                MP_MAP                      MP_MAP\n"
"\n"
"Where 0xXXX is ERRCODE."
msgstr ""
"ОШИБКА: LEN + HEADER + BODY\n"
"\n"
"0      5\n"
"+------++================+================++===================+\n"
"|      ||                |                ||                   |\n"
"| BODY ||   0x00: 0x8XXX |   0x01: SYNC   ||   0x31: ERROR     |\n"
"|HEADER|| MP_INT: MP_INT | MP_INT: MP_INT || MP_INT: MP_STRING |\n"
"| SIZE ||                |                ||                   |\n"
"+------++================+================++===================+\n"
" MP_INT                MP_MAP                      MP_MAP\n"
"\n"
"Где 0xXXX -- это код ошибки ERRCODE."

#: ../doc/1.10/dev_guide/box_protocol.rst:482
msgid ""
"An error message is present in the response only if there is an error; "
":code:`<error>` expects as value a msgpack string."
msgstr ""
"Сообщение об ошибке будет включено в ответ только в случае ошибки; "
"предполагается, что значение :code:`<error>` будет msgpack-строкой."

#: ../doc/1.10/dev_guide/box_protocol.rst:485
msgid ""
"Convenience macros which define hexadecimal constants for return codes "
"can be found in `src/box/errcode.h "
"<https://github.com/tarantool/tarantool/blob/1.10/src/box/errcode.h>`_"
msgstr ""
"Удобные макросы для определения шестнадцатеричных постоянных для "
"возвращаемых кодов можно найти по ссылке `src/box/errcode.h "
"<https://github.com/tarantool/tarantool/blob/1.10/src/box/errcode.h>`_"

#: ../doc/1.10/dev_guide/box_protocol.rst:491
msgid "Replication packet structure"
msgstr "Структура пакета при репликации"

#: ../doc/1.10/dev_guide/box_protocol.rst:493
msgid ""
"-- replication keys\n"
"<server_id>     ::= 0x02\n"
"<lsn>           ::= 0x03\n"
"<timestamp>     ::= 0x04\n"
"<server_uuid>   ::= 0x24\n"
"<cluster_uuid>  ::= 0x25\n"
"<vclock>        ::= 0x26"
msgstr ""
"-- ключи для репликации\n"
" <server_id>     ::= 0x02\n"
" <lsn>           ::= 0x03\n"
" <timestamp>     ::= 0x04\n"
" <server_uuid>   ::= 0x24\n"
" <cluster_uuid>  ::= 0x25\n"
" <vclock>        ::= 0x26"

#: ../doc/1.10/dev_guide/box_protocol.rst:503
msgid ""
"-- replication codes\n"
"<join>      ::= 0x41\n"
"<subscribe> ::= 0x42"
msgstr ""
"-- коды для репликации\n"
"<join>      ::= 0x41\n"
"<subscribe> ::= 0x42"

#: ../doc/1.10/dev_guide/box_protocol.rst:510
msgid ""
"JOIN:\n"
"\n"
"In the beginning you must send initial JOIN\n"
"               HEADER                      BODY\n"
"+================+================++===================+\n"
"|                |                ||   SERVER_UUID     |\n"
"|   0x00: 0x41   |   0x01: SYNC   ||   0x24: UUID      |\n"
"| MP_INT: MP_INT | MP_INT: MP_INT || MP_INT: MP_STRING |\n"
"|                |                ||                   |\n"
"+================+================++===================+\n"
"               MP_MAP                     MP_MAP\n"
"\n"
"Then instance, which we connect to, will send last SNAP file by, simply,\n"
"creating a number of INSERTs (with additional LSN and ServerID)\n"
"(don't reply). Then it'll send a vclock's MP_MAP and close a socket.\n"
"\n"
"+================+================++============================+\n"
"|                |                ||        +~~~~~~~~~~~~~~~~~+ |\n"
"|                |                ||        |                 | |\n"
"|   0x00: 0x00   |   0x01: SYNC   ||   0x26:| SRV_ID: SRV_LSN | |\n"
"| MP_INT: MP_INT | MP_INT: MP_INT || MP_INT:| MP_INT: MP_INT  | |\n"
"|                |                ||        +~~~~~~~~~~~~~~~~~+ |\n"
"|                |                ||               MP_MAP       |\n"
"+================+================++============================+\n"
"               MP_MAP                      MP_MAP\n"
"\n"
"SUBSCRIBE:\n"
"\n"
"Then you must send SUBSCRIBE:\n"
"\n"
"                              HEADER\n"
"+===================+===================+\n"
"|                   |                   |\n"
"|     0x00: 0x42    |    0x01: SYNC     |\n"
"|   MP_INT: MP_INT  |  MP_INT: MP_INT   |\n"
"|                   |                   |\n"
"+===================+===================+\n"
"|    SERVER_UUID    |    CLUSTER_UUID   |\n"
"|   0x24: UUID      |   0x25: UUID      |\n"
"| MP_INT: MP_STRING | MP_INT: MP_STRING |\n"
"|                   |                   |\n"
"+===================+===================+\n"
"                 MP_MAP\n"
"\n"
"      BODY\n"
"+================+\n"
"|                |\n"
"|   0x26: VCLOCK |\n"
"| MP_INT: MP_INT |\n"
"|                |\n"
"+================+\n"
"      MP_MAP\n"
"\n"
"Then you must process every query that'll came through other masters.\n"
"Every request between masters will have Additional LSN and SERVER_ID."
msgstr ""
"JOIN:\n"
"\n"
"Сначала необходимо отправить изначальный запрос JOIN\n"
"               HEADER                      BODY\n"
"+================+================++===================+\n"
"|                |                ||   SERVER_UUID     |\n"
"|   0x00: 0x41   |   0x01: SYNC   ||   0x24: UUID      |\n"
"| MP_INT: MP_INT | MP_INT: MP_INT || MP_INT: MP_STRING |\n"
"|                |                ||                   |\n"
"+================+================++===================+\n"
"               MP_MAP                     MP_MAP\n"
"\n"
"Затем экземпляр, к которому мы подключаемся, отправит последний файл "
"снимка SNAP,\n"
"просто создав количество запросов вставки INSERT (с дополнительным LSN и "
"ServerID)\n"
"(не отвечайте). Затем он отправит MP_MAP из vclock и закроет сокет.\n"
"\n"
"+================+================++============================+\n"
"|                |                ||        +~~~~~~~~~~~~~~~~~+ |\n"
"|                |                ||        |                 | |\n"
"|   0x00: 0x00   |   0x01: SYNC   ||   0x26:| SRV_ID: SRV_LSN | |\n"
"| MP_INT: MP_INT | MP_INT: MP_INT || MP_INT:| MP_INT: MP_INT  | |\n"
"|                |                ||        +~~~~~~~~~~~~~~~~~+ |\n"
"|                |                ||               MP_MAP       |\n"
"+================+================++============================+\n"
"               MP_MAP                      MP_MAP\n"
"\n"
"SUBSCRIBE:\n"
"\n"
"Далее необходимо отправить запрос SUBSCRIBE:\n"
"\n"
"                              HEADER\n"
"+===================+===================+\n"
"|                   |                   |\n"
"|     0x00: 0x42    |    0x01: SYNC     |\n"
"|   MP_INT: MP_INT  |  MP_INT: MP_INT   |\n"
"|                   |                   |\n"
"+===================+===================+\n"
"|    SERVER_UUID    |    CLUSTER_UUID   |\n"
"|   0x24: UUID      |   0x25: UUID      |\n"
"| MP_INT: MP_STRING | MP_INT: MP_STRING |\n"
"|                   |                   |\n"
"+===================+===================+\n"
"                 MP_MAP\n"
"\n"
"      BODY\n"
"+================+\n"
"|                |\n"
"|   0x26: VCLOCK |\n"
"| MP_INT: MP_INT |\n"
"|                |\n"
"+================+\n"
"      MP_MAP\n"
"\n"
" Затем следует обработать каждый запрос, который пришел от других "
"мастеров.\n"
" Каждый запрос между мастерами получит дополнительный LSN и SERVER_ID."

#: ../doc/1.10/dev_guide/box_protocol.rst:570
msgid "XLOG / SNAP"
msgstr "XLOG / SNAP"

#: ../doc/1.10/dev_guide/box_protocol.rst:572
msgid "XLOG and SNAP files have nearly the same format. The header looks like:"
msgstr ""
"Файлы форматов XLOG и SNAP выглядят практически одинаково. Заголовок "
"выглядит следующим образом:"

#: ../doc/1.10/dev_guide/box_protocol.rst:574
msgid ""
"<type>\\n                  SNAP\\n or XLOG\\n\n"
"<version>\\n               currently 0.13\\n\n"
"Server: <server_uuid>\\n   where UUID is a 36-byte string\n"
"VClock: <vclock_map>\\n    e.g. {1: 0}\\n\n"
"\\n"
msgstr ""
"<type>\\n                  SNAP\\n или XLOG\\n\n"
"<version>\\n               в данный момент 0.13\\n\n"
"Server: <server_uuid>\\n   где UUID -- это 36-байтная строка\n"
"VClock: <vclock_map>\\n    например, {1: 0}\\n\n"
"\\n"

#: ../doc/1.10/dev_guide/box_protocol.rst:582
msgid ""
"After the file header come the data tuples. Tuples begin with a row "
"marker ``0xd5ba0bab`` and the last tuple may be followed by an EOF marker"
" ``0xd510aded``. Thus, between the file header and the EOF marker, there "
"may be data tuples that have this form:"
msgstr ""
"После файла заголовка идут кортежи с данными. Кортежи начинаются с "
"маркера строки ``0xd5ba0bab``, а после последнего кортежа может стоять "
"маркер конца файла ``0xd510aded``. Таким образом, между заголовком файла "
"и маркером конца файла могут быть кортежи с данными в следующем виде:"

#: ../doc/1.10/dev_guide/box_protocol.rst:589
msgid ""
"0            3 4                                         17\n"
"+-------------+========+============+===========+=========+\n"
"|             |        |            |           |         |\n"
"| 0xd5ba0bab  | LENGTH | CRC32 PREV | CRC32 CUR | PADDING |\n"
"|             |        |            |           |         |\n"
"+-------------+========+============+===========+=========+\n"
"  MP_FIXEXT2    MP_INT     MP_INT       MP_INT      ---\n"
"\n"
"+============+ +===================================+\n"
"|            | |                                   |\n"
"|   HEADER   | |                BODY               |\n"
"|            | |                                   |\n"
"+============+ +===================================+\n"
"    MP_MAP                     MP_MAP"
msgstr ""
"0            3 4                                         17\n"
"+-------------+========+============+===========+=========+\n"
"|             |        |            |           |         |\n"
"| 0xd5ba0bab  | LENGTH | CRC32 PREV | CRC32 CUR | PADDING |\n"
"|             |        |            |           |         |\n"
"+-------------+========+============+===========+=========+\n"
"  MP_FIXEXT2    MP_INT     MP_INT       MP_INT      ---\n"
"\n"
"+============+ +===================================+\n"
"|            | |                                   |\n"
"|   HEADER   | |                BODY               |\n"
"|            | |                                   |\n"
"+============+ +===================================+\n"
"    MP_MAP                     MP_MAP"

#: ../doc/1.10/dev_guide/box_protocol.rst:606
msgid "See the example in the following section."
msgstr "См. пример в предыдущем разделе."

#: ../doc/1.10/dev_guide/internals.rst:9
msgid "Data persistence and the WAL file format"
msgstr "Персистентность данных и формат WAL-файла"

#: ../doc/1.10/dev_guide/internals.rst:11
msgid ""
"To maintain data persistence, Tarantool writes each data change request "
"(insert, update, delete, replace, upsert) into a write-ahead log (WAL) "
"file in the :ref:`wal_dir <cfg_basic-wal_dir>` directory. A new WAL file "
"is created for every :ref:`rows_per_wal <cfg_binary_logging_snapshots-"
"rows_per_wal>` records, or for every :ref:`wal_max_size "
"<cfg_binary_logging_snapshots-wal_max_size>` bytes. Each data change "
"request gets assigned a continuously growing 64-bit log sequence number. "
"The name of the WAL file is based on the log sequence number of the first"
" record in the file, plus an extension ``.xlog``."
msgstr ""
"Чтобы поддерживать персистентность данных, Tarantool записывает каждый "
"запрос изменения данных (insert, update, delete, replace, upsert) в файл "
"журнала упреждающей записи (WAL-файл) в директорию :ref:`wal_dir "
"<cfg_basic-wal_dir>`. Новый WAL-файл создается для количества записей, "
"определенного в параметре :ref:`rows_per_wal "
"<cfg_binary_logging_snapshots-rows_per_wal>`, или для количества байтов, "
"указанного в :ref:`wal_max_size <cfg_binary_logging_snapshots-"
"wal_max_size>` . Каждому запросу на изменение данных присваивается "
"постоянно возрастающее 64-битное число, представляющее собой "
"регистрационный номер в журнале (LSN). Название WAL-файла состоит из LSN "
"первой записи в файле плюс расширение ``.xlog``."

#: ../doc/1.10/dev_guide/internals.rst:20
msgid ""
"Apart from a log sequence number and the data change request (formatted "
"as in :ref:`Tarantool's binary protocol <box_protocol-iproto_protocol>`),"
" each WAL record contains a header, some metadata, and then the data "
"formatted according to `msgpack "
"<https://en.wikipedia.org/wiki/MessagePack>`_ rules. For example, this is"
" what the WAL file looks like after the first INSERT request "
"(\"s:insert({1})\") for the sandbox database created in our "
":ref:`\"Getting started\" exercises <getting_started>`. On the left are "
"the hexadecimal bytes that you would see with:"
msgstr ""
"Помимо номера записи в журнале (LSN) и запроса на изменение данных (в "
"формате :ref:`бинарного протокола Tarantool'а <box_protocol-"
"iproto_protocol>`), каждая запись в WAL-файле содержит заголовок, "
"некоторые метаданные, а также данные, форматированные по правилам "
"`msgpack <https://en.wikipedia.org/wiki/MessagePack>`_. Например, так "
"выглядит WAL-файл после первого запроса вставки INSERT "
"(\"s:insert({1})\") для базы данных из песочницы, созданной в упражнениях"
" в :ref:`\"Руководстве для начинающих\" <getting_started>`. Слева "
"представлены шестнадцатеричные байты, которые можно просмотреть с "
"помощью:"

#: ../doc/1.10/dev_guide/internals.rst:29
msgid "$ hexdump 00000000000000000000.xlog"
msgstr "$ hexdump 00000000000000000000.xlog"

#: ../doc/1.10/dev_guide/internals.rst:33
msgid "and on the right are comments."
msgstr "а справа -- комментарии."

#: ../doc/1.10/dev_guide/internals.rst:35
msgid ""
"Hex dump of WAL file       Comment\n"
"--------------------       -------\n"
"58 4c 4f 47 0a             \"XLOG\\n\"\n"
"30 2e 31 33 0a             \"0.13\\n\" = version\n"
"53 65 72 76 65 72 3a 20    \"Server: \"\n"
"38 62 66 32 32 33 65 30 2d [Server UUID]\\n\n"
"36 39 31 34 2d 34 62 35 35\n"
"2d 39 34 64 32 2d 64 32 62\n"
"36 64 30 39 62 30 31 39 36\n"
"0a\n"
"56 43 6c 6f 63 6b 3a 20    \"Vclock: \"\n"
"7b 7d                      \"{}\" = vclock value, initially blank\n"
"...                        (not shown = tuples for system spaces)\n"
"d5 ba 0b ab                Magic row marker always = 0xab0bbad5\n"
"19                         Length, not including length of header, = 25 "
"bytes\n"
"00                           Record header: previous crc32\n"
"ce 8c 3e d6 70               Record header: current crc32\n"
"a7 cc 73 7f 00 00 66 39      Record header: padding\n"
"84                         msgpack code meaning \"Map of 4 elements\" "
"follows\n"
"00 02                         element#1: tag=request type, "
"value=0x02=IPROTO_INSERT\n"
"02 01                         element#2: tag=server id, value=0x01\n"
"03 04                         element#3: tag=lsn, value=0x04\n"
"04 cb 41 d4 e2 2f 62 fd d5 d4 element#4: tag=timestamp, value=an 8-byte "
"\"Float64\"\n"
"82                         msgpack code meaning \"map of 2 elements\" "
"follows\n"
"10 cd 02 00                   element#1: tag=space id, value=512, big "
"byte first\n"
"21 91 01                      element#2: tag=tuple, value=1-element fixed"
" array={1}"
msgstr ""
"Шестнадцатеричный дамп WAL-файла       Комментарий\n"
"--------------------       -------\n"
"58 4c 4f 47 0a             \"XLOG\\n\"\n"
"30 2e 31 33 0a             \"0.13\\n\" = version\n"
"53 65 72 76 65 72 3a 20    \"Server: \"\n"
"38 62 66 32 32 33 65 30 2d [Server UUID]\\n\n"
"36 39 31 34 2d 34 62 35 35\n"
"2d 39 34 64 32 2d 64 32 62\n"
"36 64 30 39 62 30 31 39 36\n"
"0a\n"
"56 43 6c 6f 63 6b 3a 20    \"Vclock: \"\n"
"7b 7d                      \"{}\" = vclock value, initially blank\n"
"...                        (not shown = tuples for system spaces)\n"
"d5 ba 0b ab                Magic row marker always = 0xab0bbad5\n"
"19                         Length, not including length of header, = 25 "
"bytes\n"
"00                           Record header: previous crc32\n"
"ce 8c 3e d6 70               Record header: current crc32\n"
"a7 cc 73 7f 00 00 66 39      Record header: padding\n"
"84                         msgpack code meaning \"Map of 4 elements\" "
"follows\n"
"00 02                         element#1: tag=request type, "
"value=0x02=IPROTO_INSERT\n"
"02 01                         element#2: tag=server id, value=0x01\n"
"03 04                         element#3: tag=lsn, value=0x04\n"
"04 cb 41 d4 e2 2f 62 fd d5 d4 element#4: tag=timestamp, value=an 8-byte "
"\"Float64\"\n"
"82                         msgpack code meaning \"map of 2 elements\" "
"follows\n"
"10 cd 02 00                   element#1: tag=space id, value=512, big "
"byte first\n"
"21 91 01                      element#2: tag=tuple, value=1-element fixed"
" array={1}"

#: ../doc/1.10/dev_guide/internals.rst:64
msgid "A tool for reading .xlog files is Tarantool's :ref:`xlog module <xlog>`."
msgstr ""
"Для чтения файлов в формате .xlog в Tarantool'е предусмотрен :ref:`модуль"
" xlog <xlog>`."

#: ../doc/1.10/dev_guide/internals.rst:66
msgid ""
"Tarantool processes requests atomically: a change is either accepted and "
"recorded in the WAL, or discarded completely. Let's clarify how this "
"happens, using the REPLACE request as an example:"
msgstr ""
"Tarantool обрабатывает запросы атомарно: изменение либо принимается и "
"записывается в WAL-файл, или полностью исключается. Проясним, как этом "
"работает, используя в качестве примера REPLACE-запрос:"

#: ../doc/1.10/dev_guide/internals.rst:70
msgid ""
"The server instance attempts to locate the original tuple by primary key."
" If found, a reference to the tuple is retained for later use."
msgstr ""
"Экземпляр сервера пытается найти оригинальный кортеж по первичному ключу."
" Если кортеж найден, ссылка на него сохраняется для дальнейшего "
"использования."

#: ../doc/1.10/dev_guide/internals.rst:73
msgid ""
"The new tuple is validated. If for example it does not contain an indexed"
" field, or it has an indexed field whose type does not match the type "
"according to the index definition, the change is aborted."
msgstr ""
"Происходит проверка нового кортежа. Например, если в нем нет "
"проиндексированного поля, или же тип проиндексированного поля не "
"совпадает с типом в определении индекса, изменение прерывается."

#: ../doc/1.10/dev_guide/internals.rst:77
msgid "The new tuple replaces the old tuple in all existing indexes."
msgstr "Новый кортеж заменяет старый кортеж во всех существующих индексах."

#: ../doc/1.10/dev_guide/internals.rst:79
msgid ""
"A message is sent to the writer process running in the WAL thread, "
"requesting that the change be recorded in the WAL. The instance switches "
"to work on the next request until the write is acknowledged."
msgstr ""
"В процесс записи, запущенный в потоке журнала упреждающей записи, "
"отправляется сообщение о необходимости внесения записи в WAL-файл. "
"Экземпляр переключается на работу со следующим запросом, пока запись не "
"будет подтверждена."

#: ../doc/1.10/dev_guide/internals.rst:83
msgid ""
"On success, a confirmation is sent to the client. On failure, a rollback "
"procedure is begun. During the rollback procedure, the transaction "
"processor rolls back all changes to the database which occurred after the"
" first failed change, from latest to oldest, up to the first failed "
"change. All rolled back requests are aborted with :errcode:`ER_WAL_IO "
"<ER_WAL_IO>` error. No new change is applied while rollback is in "
"progress. When the rollback procedure is finished, the server restarts "
"the processing pipeline."
msgstr ""
"При успешном выполнении на клиент отправляется подтверждение. В случае "
"ошибки начинается процедура отката. Во время процедуры отката поток "
"обработки транзакций откатывается все изменения в базу данных, которые "
"произошли после первого невыполненного изменения, от последнего с "
"первому, вплоть до первого невыполненного изменения. Все запросы, которые"
" подверглись откату, прерываются с ошибкой :errcode:`ER_WAL_IO "
"<ER_WAL_IO>`. Новые изменения не применяются во время отката. По "
"окончании процедуры отката сервер повторно запускает конвейер обработки "
"операций."

#: ../doc/1.10/dev_guide/internals.rst:91
msgid ""
"One advantage of the described algorithm is that complete request "
"pipelining is achieved, even for requests on the same value of the "
"primary key. As a result, database performance doesn't degrade even if "
"all requests refer to the same key in the same space."
msgstr ""
"Одно из преимуществ описанного алгоритма заключается в том, что "
"достигается полная обработка запроса по конвейеру даже для запросов с "
"одинаковым значением первичного ключа. В результате производительность "
"базы данных не падает, даже если все запросы относятся к одному ключу в "
"одном спейсе."

#: ../doc/1.10/dev_guide/internals.rst:96
msgid ""
"The transaction processor thread communicates with the WAL writer thread "
"using asynchronous (yet reliable) messaging; the transaction processor "
"thread, not being blocked on WAL tasks, continues to handle requests "
"quickly even at high volumes of disk I/O. A response to a request is sent"
" as soon as it is ready, even if there were earlier incomplete requests "
"on the same connection. In particular, SELECT performance, even for "
"SELECTs running on a connection packed with UPDATEs and DELETEs, remains "
"unaffected by disk load."
msgstr ""
"Поток обработки транзакций взаимодействует с потоком записи в журнал "
"упреждающей записи с помощью асинхронного (однако надежного) обмена "
"сообщениями. Поток обработки транзакций, который не блокируется при "
"задачах записи в журнал, продолжает быстро обрабатывать запрос даже при "
"большом объеме дискового ввода-вывода. Ответ на запрос отправляется по "
"готовности, даже если ранее на том же соединении были незавершенные "
"запросы. В частности, на производительность выборки не влияет загрузка "
"диска, даже если SELECT-запросы передаются вместе с запросами UPDATE и "
"DELETE."

#: ../doc/1.10/dev_guide/internals.rst:104
msgid ""
"The WAL writer employs a number of durability modes, as defined in "
"configuration variable :ref:`wal_mode <index-wal_mode>`. It is possible "
"to turn the write-ahead log completely off, by setting :ref:`wal_mode "
"<cfg_binary_logging_snapshots-wal_mode>` to *none*. Even without the "
"write-ahead log it's still possible to take a persistent copy of the "
"entire data set with the :ref:`box.snapshot() <box-snapshot>` request."
msgstr ""
"При записи в WAL можно применять различные режимы долговечности, что "
"определяет конфигурационная переменная :ref:`wal_mode <index-wal_mode>`. "
"Можно полностью отключить журнал упреждающей записи, присвоив "
":ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>` значение *none*. "
"Даже без журнала упреждающей записи возможно сделать персистентную копию "
"всего набора данных с помощью запроса :ref:`box.snapshot() <box-"
"snapshot>`."

#: ../doc/1.10/dev_guide/internals.rst:111
msgid ""
"An .xlog file always contains changes based on the primary key. Even if "
"the client requested an update or delete using a secondary key, the "
"record in the .xlog file will contain the primary key."
msgstr ""
"Файл в формате .xlog всегда содержит изменения на основании первичного "
"ключа. Даже если клиент запрашивает обновление или удаление по вторичному"
" ключу, запись в файле в формате .xlog будет содержать первичный ключ."

#: ../doc/1.10/dev_guide/internals.rst:119
msgid "The snapshot file format"
msgstr "Формат файла снимка"

#: ../doc/1.10/dev_guide/internals.rst:121
msgid ""
"The format of a snapshot .snap file is nearly the same as the format of a"
" WAL .xlog file. However, the snapshot header differs: it contains the "
"instance's global unique identifier and the snapshot file's position in "
"history, relative to earlier snapshot files. Also, the content differs: "
"an .xlog file may contain records for any data-change requests (inserts, "
"updates, upserts, and deletes), a .snap file may only contain records of "
"inserts to memtx spaces."
msgstr ""
"Формат файла снимка .snap практически такой же, что и формат WAL-файла "
".xlog. Тем не менее, заголовок снимка отличается: он содержит глобально "
"уникальный идентификатор экземпляра и положения файла снимка в истории "
"относительно более ранних файлов снимка. Кроме того, отличается "
"содержание: .xlog-файл может содержать записи о любых запросах изменения "
"данных (вставка, обновление, обновление и вставка и удаление), а "
".snap-файл может содержать лишь записи о вставках в спейсы memtx'а."

#: ../doc/1.10/dev_guide/internals.rst:128
msgid ""
"Primarily, the .snap file's records are ordered by space id. Therefore "
"the records of system spaces -- such as ``_schema``, ``_space``, "
"``_index``, ``_func``, ``_priv`` and ``_cluster`` -- will be at the start"
" of the .snap file, before the records of any spaces that were created by"
" users."
msgstr ""
"В первую очередь записи в .snap-файле упорядочены по идентификатору "
"спейса. Таким образом, записи в системные спейсы -- такие как "
"``_schema``, ``_space``, ``_index``, ``_func``, ``_priv`` и ``_cluster`` "
"-- будут находиться в начале .snap-файла до записей в другие спейсы, "
"созданные пользователями."

#: ../doc/1.10/dev_guide/internals.rst:133
msgid ""
"Secondarily, the .snap file's records are ordered by primary key within "
"space id."
msgstr "Во вторую очередь записи в .snap-файле упорядочены по первичному ключу."

#: ../doc/1.10/dev_guide/internals.rst:139
msgid "The recovery process"
msgstr "Процесс восстановления"

#: ../doc/1.10/dev_guide/internals.rst:141
msgid ""
"The recovery process begins when box.cfg{} happens for the first time "
"after the Tarantool server instance starts."
msgstr ""
"Процесс восстановления начинается, когда box.cfg{} впервые используется "
"после запуска экземпляра Tarantool-сервера."

#: ../doc/1.10/dev_guide/internals.rst:144
msgid ""
"The recovery process must recover the databases as of the moment when the"
" instance was last shut down. For this it may use the latest snapshot "
"file and any WAL files that were written after the snapshot. One "
"complicating factor is that Tarantool has two engines -- the memtx data "
"must be reconstructed entirely from the snapshot and the WAL files, while"
" the vinyl data will be on disk but might require updating around the "
"time of a checkpoint. (When a snapshot happens, Tarantool tells the vinyl"
" engine to make a checkpoint, and the snapshot operation is rolled back "
"if anything goes wrong, so vinyl's checkpoint is at least as fresh as the"
" snapshot file.)"
msgstr ""
"Процесс восстановления должен восстановить базы данных на момент "
"последнего отключения экземпляра. Для этого можно использовать последний "
"файл снимка и любые WAL-файлы, которые были записаны после создания "
"снимка. Ситуацию осложняет фактор того, что в Tarantool'е используются "
"два движка -- данные memtx'а должны быть реконструированы полностью из "
"снимка и WAL-файлов, тогда как данные vinyl'а будут находиться на диске, "
"но может потребоваться их обновление на время создания контрольной точки."
" (При создании снимка Tarantool передает движку vinyl команду создания "
"контрольной точки, а операция создания снимка откатывается в случае "
"какой-либо ошибки, поэтому контрольная точка vinyl'а будет настолько же "
"актуальной, как и файл снимка.)"

#: ../doc/1.10/dev_guide/internals.rst:161
msgid "Step 1"
msgstr "Шаг 1"

#: ../doc/1.10/dev_guide/internals.rst:157
msgid ""
"Read the configuration parameters in the ``box.cfg{}`` request. "
"Parameters which affect recovery may include :ref:`work_dir <cfg_basic-"
"work_dir>`, :ref:`wal_dir <cfg_basic-wal_dir>`, :ref:`memtx_dir "
"<cfg_basic-memtx_dir>`, :ref:`vinyl_dir <cfg_basic-vinyl_dir>` and "
":ref:`force_recovery <cfg_binary_logging_snapshots-force_recovery>`."
msgstr ""
"Выполнить чтение конфигурационных параметров из запроса ``box.cfg{}``. "
"Параметры, которые могут повлиять на восстановление: :ref:`work_dir "
"<cfg_basic-work_dir>`, :ref:`wal_dir <cfg_basic-wal_dir>`, "
":ref:`memtx_dir <cfg_basic-memtx_dir>`, :ref:`vinyl_dir <cfg_basic-"
"vinyl_dir>` и :ref:`force_recovery <cfg_binary_logging_snapshots-"
"force_recovery>`."

#: ../doc/1.10/dev_guide/internals.rst:181
msgid "Step 2"
msgstr "Шаг 2"

#: ../doc/1.10/dev_guide/internals.rst:164
msgid ""
"Find the latest snapshot file. Use its data to reconstruct the in-memory "
"databases. Instruct the vinyl engine to recover to the latest checkpoint."
msgstr ""
"Найти последний файл снимка. Использовать данные для реконструкции in-"
"memory баз данных. Передать команду vinyl'у о восстановлении до последней"
" контрольной точки."

#: ../doc/1.10/dev_guide/internals.rst:167
msgid ""
"There are actually two variations of the reconstruction procedure for "
"memtx databases, depending on whether the recovery process is "
"\"default\"."
msgstr ""
"На самом деле, есть два варианта реконструкции баз данных memtx'а в "
"зависимости от того, выполняется ли стандартная процедура."

#: ../doc/1.10/dev_guide/internals.rst:170
msgid ""
"If the recovery process is default (``force_recovery`` is ``false``), "
"memtx can read data in the snapshot with all indexes disabled. First, all"
" tuples are read into memory. Then, primary keys are built in bulk, "
"taking advantage of the fact that the data is already sorted by primary "
"key within each space."
msgstr ""
"Если выполняется стандартная процедура (``force_recovery`` = ``false``), "
"memtx может выполнить чтение данных из снимка с отключенными индексами. "
"Сначала все кортежи считываются в память. Затем происходит массовая "
"загрузка первичных ключей с учетом того, что данные уже отсортированы по "
"первичному ключу в каждом спейсе."

#: ../doc/1.10/dev_guide/internals.rst:176
msgid ""
"If the recovery process is non-default (``force_recovery`` is ``true``), "
"Tarantool performs additional checking. Indexes are enabled at the start,"
" and tuples are added one by one. This means that any unique-key "
"constraint violations will be caught, and any duplicates will be skipped."
" Normally there will be no constraint violations or duplicates, so these "
"checks are only made if an error has occurred."
msgstr ""
"Если выполняется нестандартная процедура принудительного восстановления "
"(``force_recovery`` = ``true``), Tarantool проводит дополнительную "
"проверку. Сначала индексы активны, и кортежи добавляются по одному. Это "
"означает, что будут выявлены любые нарушения ограничений уникальности "
"ключей, и все повторяющиеся значения пропускаются. Как правило, не будет "
"нарушений ограничений или повторяющихся значений, поэтому такие проверки "
"проводятся только в случае ошибки."

#: ../doc/1.10/dev_guide/internals.rst:188
msgid "Step 3"
msgstr "Шаг 3"

#: ../doc/1.10/dev_guide/internals.rst:184
msgid ""
"Find the WAL file that was made at the time of, or after, the snapshot "
"file. Read its log entries until the log-entry LSN is greater than the "
"LSN of the snapshot, or greater than the LSN of the vinyl checkpoint. "
"This is the recovery process's \"start position\"; it matches the current"
" state of the engines."
msgstr ""
"Найти WAL-файл, который был создан во время создания файла снимка или "
"позже. Выполнить чтение записей журнала до тех пор, пока LSN записи в "
"журнале не будет больше LSN снимка или больше LSN контрольной точки в "
"vinyl'е. Это и будет начальной точкой для процесса восстановления, "
"которая соответствует текущему состоянию движков."

#: ../doc/1.10/dev_guide/internals.rst:192
msgid "Step 4"
msgstr "Шаг 4"

#: ../doc/1.10/dev_guide/internals.rst:191
msgid ""
"Redo the log entries, from the start position to the end of the WAL. The "
"engine skips a redo instruction if it is older than the engine's "
"checkpoint."
msgstr ""
"Повторить записи журнала с начальной точки до конца WAL. Движок "
"пропускает команду повторения, если данные старше контрольной точки "
"движка."

#: ../doc/1.10/dev_guide/internals.rst:196
msgid "Step 5"
msgstr "Шаг 5"

#: ../doc/1.10/dev_guide/internals.rst:195
msgid "For the memtx engine, re-create all secondary indexes."
msgstr "Повторно создать все вторичные индексы для движка memtx."

#: ../doc/1.10/dev_guide/lua_style_guide.rst:37
msgid "Lua Style Guide"
msgstr "Руководство по написанию кода на Lua"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:39
msgid "Inspiration:"
msgstr "Для вдохновения:"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:41
msgid "https://github.com/Olivine-Labs/lua-style-guide"
msgstr "https://github.com/Olivine-Labs/lua-style-guide"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:42
msgid "http://dev.minetest.net/Lua_code_style_guidelines"
msgstr "http://dev.minetest.net/Lua_code_style_guidelines"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:43
msgid "http://sputnik.freewisdom.org/en/Coding_Standard"
msgstr "http://sputnik.freewisdom.org/en/Coding_Standard"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:45
msgid ""
"Programming style is an art. There is some arbitrariness to the rules, "
"but there are sound rationales for them. It is useful not only to provide"
" sound advice on style but to understand the underlying rationale and "
"human aspect of why the style recommendations are formed:"
msgstr ""
"Придерживаться стиля в программировании -- это искусство. Даже учитывая "
"некоторую произвольность правил, для них есть надежное обоснование. "
"Полезно не только давать значимые советы по стилю, но также понимать "
"основополагающие причины и человеческий аспект того, почему формируются "
"рекомендации по стилю:"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:50
msgid "http://mindprod.com/jgloss/unmain.html"
msgstr "http://mindprod.com/jgloss/unmain.html"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:51
msgid "http://www.oreilly.com/catalog/perlbp/"
msgstr "http://www.oreilly.com/catalog/perlbp/"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:52
msgid "http://books.google.com/books?id=QnghAQAAIAAJ"
msgstr "http://books.google.com/books?id=QnghAQAAIAAJ"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:54
msgid "Zen of Python is good; understand it and use wisely:"
msgstr ""
"Дзен языка программирования Python подходит и здесь; используйте его с "
"умом:"

#: ../doc/1.10/dev_guide/lua_style_guide.rst
msgid "Beautiful is better than ugly."
msgstr "Красивое лучше, чем уродливое."

#: ../doc/1.10/dev_guide/lua_style_guide.rst
msgid "Explicit is better than implicit."
msgstr "Явное лучше, чем неявное."

#: ../doc/1.10/dev_guide/lua_style_guide.rst
msgid "Simple is better than complex."
msgstr "Простое лучше, чем сложное."

#: ../doc/1.10/dev_guide/lua_style_guide.rst
msgid "Complex is better than complicated."
msgstr "Сложное лучше, чем запутанное."

#: ../doc/1.10/dev_guide/lua_style_guide.rst
msgid "Flat is better than nested."
msgstr "Плоское лучше, чем вложенное."

#: ../doc/1.10/dev_guide/lua_style_guide.rst
msgid "Sparse is better than dense."
msgstr "Разреженное лучше, чем плотное."

#: ../doc/1.10/dev_guide/lua_style_guide.rst
msgid "Readability counts."
msgstr "Читаемость имеет значение."

#: ../doc/1.10/dev_guide/lua_style_guide.rst
msgid "Special cases aren't special enough to break the rules."
msgstr "Особые случаи не настолько особые, чтобы нарушать правила."

#: ../doc/1.10/dev_guide/lua_style_guide.rst
msgid "Although practicality beats purity."
msgstr "При этом практичность важнее безупречности."

#: ../doc/1.10/dev_guide/lua_style_guide.rst
msgid "Errors should never pass silently."
msgstr "Ошибки никогда не должны замалчиваться."

#: ../doc/1.10/dev_guide/lua_style_guide.rst
msgid "Unless explicitly silenced."
msgstr "Если не замалчиваются явно."

#: ../doc/1.10/dev_guide/lua_style_guide.rst
msgid "In the face of ambiguity, refuse the temptation to guess."
msgstr "Встретив двусмысленность, отбрось искушение угадать."

#: ../doc/1.10/dev_guide/lua_style_guide.rst
msgid "There should be one -- and preferably only one -- obvious way to do it."
msgstr ""
"Должен существовать один -- и, желательно, только один -- очевидный "
"способ сделать это."

#: ../doc/1.10/dev_guide/lua_style_guide.rst
msgid "Although that way may not be obvious at first unless you're Dutch."
msgstr "Хотя он поначалу может быть и не очевиден."

#: ../doc/1.10/dev_guide/lua_style_guide.rst
msgid "Now is better than never."
msgstr "Сейчас лучше, чем никогда."

#: ../doc/1.10/dev_guide/lua_style_guide.rst
msgid "Although never is often better than *right* now."
msgstr "Хотя никогда зачастую лучше, чем прямо сейчас."

#: ../doc/1.10/dev_guide/lua_style_guide.rst
msgid "If the implementation is hard to explain, it's a bad idea."
msgstr "Если реализацию сложно объяснить -- идея плоха."

#: ../doc/1.10/dev_guide/lua_style_guide.rst
msgid "If the implementation is easy to explain, it may be a good idea."
msgstr "Если реализацию легко объяснить -- идея, возможно, хороша."

#: ../doc/1.10/dev_guide/lua_style_guide.rst
msgid "Namespaces are one honking great idea -- let's do more of those!"
msgstr "Пространства имен -- отличная штука! Сделаем побольше!"

#: ../doc/1.10/dev_guide/lua_style_guide.rst
msgid "https://www.python.org/dev/peps/pep-0020/"
msgstr "https://www.python.org/dev/peps/pep-0020/"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:80
msgid "Indentation and Formatting"
msgstr "Отступы и форматирование"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:82
msgid ""
"4 spaces instead tabs. PIL suggests using of two spaces, but programmer "
"looks at code 4 up to 8 hours a day, so it's simplier to distinguish "
"indentation with 4 spaces. Why spaces? Similar representation everywhere."
msgstr ""
"4 пробела, а не табуляция. Библиотека PIL предлагает использовать два "
"пробела, но разработчик читает код от 4 до 8 часов в день, а различать "
"отступы с 4 пробелами легче. Почему именно пробелы? Соблюдение "
"однородности."

#: ../doc/1.10/dev_guide/lua_style_guide.rst:86
msgid "You can use vim modelines:"
msgstr "Можно использовать строки режима (modelines) vim:"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:88
msgid "-- vim:ts=4 ss=4 sw=4 expandtab"
msgstr "-- vim:ts=4 ss=4 sw=4 expandtab"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:92
msgid ""
"A file should ends w/ one newline symbol, but shouldn't ends w/ blank "
"line (two newline symbols)."
msgstr ""
"Файл должен заканчиваться на один символ переноса строки, но не должен "
"заканчиваться на пустой строке (два символа переноса строки)."

#: ../doc/1.10/dev_guide/lua_style_guide.rst:95
msgid "Every do/while/for/if/function should indent 4 spaces."
msgstr "Отступы всех do/while/for/if/function должны составлять 4 пробела."

#: ../doc/1.10/dev_guide/lua_style_guide.rst:97
msgid ""
"related ``or``/``and`` in ``if`` must be enclosed in the round brackets "
"(). Example:"
msgstr ""
"``or``/``and`` в ``if`` должны быть обрамлены круглыми скобками (). "
"Пример:"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:99
msgid ""
"if (a == true and b == false) or (a == false and b == true) then\n"
"    <...>\n"
"end -- good\n"
"\n"
"if a == true and b == false or a == false and b == true then\n"
"    <...>\n"
"end -- bad\n"
"\n"
"if a ^ b == true then\n"
"end -- good, but not explicit"
msgstr ""
"if (a == true and b == false) or (a == false and b == true) then\n"
"    <...>\n"
"end -- хорошо\n"
"\n"
"if a == true and b == false or a == false and b == true then\n"
"    <...>\n"
"end -- плохо\n"
"\n"
"if a ^ b == true then\n"
"end -- хорошо, но не явно"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:112
msgid "Type conversion"
msgstr "Преобразование типов"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:114
msgid ""
"Do not use concatenation to convert to string or addition to convert to "
"number (use ``tostring``/``tonumber`` instead):"
msgstr ""
"Не используйте конкатенацию для конвертации в строку или в число (вместо "
"этого воспользуйтесь ``tostring``/``tonumber``):"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:117
msgid ""
"local a = 123\n"
"a = a .. ''\n"
"-- bad\n"
"\n"
"local a = 123\n"
"a = tostring(a)\n"
"-- good\n"
"\n"
"local a = '123'\n"
"a = a + 5 -- 128\n"
"-- bad\n"
"\n"
"local a = '123'\n"
"a = tonumber(a) + 5 -- 128\n"
"-- good"
msgstr ""
"local a = 123\n"
"a = a .. ''\n"
"-- плохо\n"
"\n"
"local a = 123\n"
"a = tostring(a)\n"
"-- хорошо\n"
"\n"
"local a = '123'\n"
"a = a + 5 -- 128\n"
"-- плохо\n"
"\n"
"local a = '123'\n"
"a = tonumber(a) + 5 -- 128\n"
"-- хорошо"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:135
msgid "Try to avoid multiple nested ``if``'s with common body:"
msgstr "Постарайтесь избегать несколько вложенных ``if`` с общим телом оператора:"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:137
msgid ""
"if (a == true and b == false) or (a == false and b == true) then\n"
"    do_something()\n"
"end\n"
"-- good\n"
"\n"
"if a == true then\n"
"    if b == false then\n"
"        do_something()\n"
"    end\n"
"if b == true then\n"
"    if a == false then\n"
"        do_something()\n"
"    end\n"
"end\n"
"-- bad"
msgstr ""
"if (a == true and b == false) or (a == false and b == true) then\n"
"    do_something()\n"
"end\n"
"-- хорошо\n"
"\n"
"if a == true then\n"
"    if b == false then\n"
"        do_something()\n"
"    end\n"
"if b == true then\n"
"    if a == false then\n"
"        do_something()\n"
"    end\n"
"end\n"
"-- плохо"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:155
msgid ""
"Avoid multiple concatenations in one statement, use ``string.format`` "
"instead:"
msgstr ""
"Избегайте множества конкатенаций в одном операторе, лучше использовать "
"``string.format``:"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:157
#, python-format
msgid ""
"function say_greeting(period, name)\n"
"    local a = \"good  \" .. period .. \", \" .. name\n"
"end\n"
"-- bad\n"
"\n"
"function say_greeting(period, name)\n"
"    local a = string.format(\"good %s, %s\", period, name)\n"
"end\n"
"-- good\n"
"\n"
"local say_greeting_fmt = \"good %s, %s\"\n"
"function say_greeting(period, name)\n"
"    local a = say_greeting_fmt:format(period, name)\n"
"end\n"
"-- best"
msgstr ""
"function say_greeting(period, name)\n"
"     local a = \"good  \" .. period .. \", \" .. name\n"
"end\n"
"-- плохо\n"
"\n"
"function say_greeting(period, name)\n"
"    local a = string.format(\"good %s, %s\", period, name)\n"
"end\n"
"-- хорошо\n"
"\n"
"local say_greeting_fmt = \"good %s, %s\"\n"
"function say_greeting(period, name)\n"
"    local a = say_greeting_fmt:format(period, name)\n"
"end\n"
"-- лучше всего"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:175
msgid "Use ``and``/``or`` for default variable values"
msgstr ""
"Используйте ``and``/``or`` для указания значений переменных, используемых"
" по умолчанию,"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:177
msgid ""
"function(input)\n"
"    input = input or 'default_value'\n"
"end -- good\n"
"\n"
"function(input)\n"
"    if input == nil then\n"
"        input = 'default_value'\n"
"    end\n"
"end -- ok, but excessive"
msgstr ""
"function(input)\n"
"    input = input or 'default_value'\n"
"end -- хорошо\n"
"\n"
"function(input)\n"
"    if input == nil then\n"
"        input = 'default_value'\n"
"    end\n"
"end -- нормально, но избыточно"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:189
msgid "``if``'s and return statements:"
msgstr "операторов ``if`` и возврата:"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:191
msgid ""
"if a == true then\n"
"    return do_something()\n"
"end\n"
"do_other_thing() -- good\n"
"\n"
"if a == true then\n"
"    return do_something()\n"
"else\n"
"    do_other_thing()\n"
"end -- bad"
msgstr ""
"if a == true then\n"
"    return do_something()\n"
"end\n"
"do_other_thing() -- хорошо\n"
"\n"
"if a == true then\n"
"    return do_something()\n"
"else\n"
"    do_other_thing()\n"
"end -- плохо"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:204
msgid "Using spaces:"
msgstr "Использование пробелов:"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:206
msgid ""
"one shouldn't use spaces between function name and opening round bracket,"
" but arguments must be splitted with one whitespace charachter"
msgstr ""
"не следует вставлять пробелы между именем функции и открывающей круглой "
"скобкой, но аргумент необходимо разделять одним символом пробела"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:209
msgid ""
"function name (arg1,arg2,...)\n"
"end -- bad\n"
"\n"
"function name(arg1, arg2, ...)\n"
"end -- good"
msgstr ""
"function name (arg1,arg2,...)\n"
"end -- плохо\n"
"\n"
"function name(arg1, arg2, ...)\n"
"end -- хорошо"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:217
msgid "use space after comment marker"
msgstr "добавляйте пробел после маркера комментария"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:219
msgid ""
"while true do -- inline comment\n"
"-- comment\n"
"do_something()\n"
"end\n"
"--[[\n"
"  multiline\n"
"  comment\n"
"]]--"
msgstr ""
"while true do -- встроенный комментарий\n"
"-- комментарий\n"
"do_something()\n"
"end\n"
"--[[\n"
"  многострочный\n"
"  комментарий\n"
"]]--"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:230
msgid "surrounding operators"
msgstr "примыкающие конструкции"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:232
msgid ""
"local thing=1\n"
"thing = thing-1\n"
"thing = thing*1\n"
"thing = 'string'..'s'\n"
"-- bad\n"
"\n"
"local thing = 1\n"
"thing = thing - 1\n"
"thing = thing * 1\n"
"thing = 'string' .. 's'\n"
"-- good"
msgstr ""
"local thing=1\n"
"thing = thing-1\n"
"thing = thing*1\n"
"thing = 'string'..'s'\n"
"-- плохо\n"
"\n"
"local thing = 1\n"
"thing = thing - 1\n"
"thing = thing * 1\n"
"thing = 'string' .. 's'\n"
"-- хорошо"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:246
msgid "use space after commas in tables"
msgstr "добавляйте пробел после запятых в таблицах"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:248
msgid ""
"local thing = {1,2,3}\n"
"thing = {1 , 2 , 3}\n"
"thing = {1 ,2 ,3}\n"
"-- bad\n"
"\n"
"local thing = {1, 2, 3}\n"
"-- good"
msgstr ""
"local thing = {1,2,3}\n"
"thing = {1 , 2 , 3}\n"
"thing = {1 ,2 ,3}\n"
"-- плохо\n"
"\n"
"local thing = {1, 2, 3}\n"
"-- хорошо"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:258
msgid "use space in map definitions around equality sign and commas"
msgstr ""
"используйте пробелы в определениях ассоциативного массива по сторонам от "
"знаков равенства и запятых"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:260
msgid ""
"return {1,2,3,4} -- bad\n"
"return {\n"
"    key1 = val1,key2=val2\n"
"} -- bad\n"
"\n"
"return {\n"
"    1, 2, 3, 4\n"
"    key1 = val1, key2 = val2,\n"
"    key3 = vallll\n"
"} -- good"
msgstr ""
"return {1,2,3,4} -- плохо\n"
"return {\n"
"    key1 = val1,key2=val2\n"
"} -- плохо\n"
"\n"
"return {\n"
"    1, 2, 3, 4\n"
"    key1 = val1, key2 = val2,\n"
"    key3 = vallll\n"
"} -- хорошо"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:273
msgid "also, you may use alignment:"
msgstr "также можно применить выравнивание:"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:275
msgid ""
"return {\n"
"    long_key  = 'vaaaaalue',\n"
"    key       = 'val',\n"
"    something = 'even better'\n"
"}"
msgstr ""
"return {\n"
"    long_key  = 'vaaaaalue',\n"
"    key       = 'val',\n"
"    something = 'even better'\n"
"}"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:283
msgid ""
"extra blank lines may be used (sparingly) to separate groups of related "
"functions. Blank lines may be omitted between a bunch of related one-"
"liners (e.g. a set of dummy implementations)"
msgstr ""
"также можно добавлять пустые строки (не слишком часто) для выделения "
"групп связанных функций. Пустые строки не стоит добавлять между "
"несколькими связанными программами в одну строку (например, в формальной "
"реализации)"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:287
msgid "use blank lines in function, sparingly, to indicate logical sections"
msgstr ""
"не слишком часто можно добавлять пустые строки в коде функций, чтобы "
"отделить друг от друга логические части"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:289
msgid ""
"if thing then\n"
"    -- ...stuff...\n"
"end\n"
"function derp()\n"
"    -- ...stuff...\n"
"end\n"
"local wat = 7\n"
"-- bad\n"
"\n"
"if thing then\n"
"    -- ...stuff...\n"
"end\n"
"\n"
"function derp()\n"
"    -- ...stuff...\n"
"end\n"
"\n"
"local wat = 7\n"
"-- good"
msgstr ""
"if thing then\n"
"    -- ...что-то...\n"
"end\n"
"function derp()\n"
"    -- ...что-то...\n"
"end\n"
"local wat = 7\n"
"-- плохо\n"
"\n"
"if thing then\n"
"    -- ...что-то...\n"
"end\n"
"\n"
"function derp()\n"
"    -- ...что-то...\n"
"end\n"
"\n"
"local wat = 7\n"
"-- хорошо"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:311
msgid ""
"Delete whitespace at EOL (strongly forbidden. Use ``:s/\\s\\+$//gc`` in "
"vim to delete them)"
msgstr ""
"Удаляйте символы пробела в конце файла (они категорически запрещаются). "
"Для их удаления в vim используйте ``:s/\\s\\+$//gc``."

#: ../doc/1.10/dev_guide/lua_style_guide.rst:316
msgid "Avoid global variable"
msgstr "Недопущение глобальных переменных"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:318
msgid ""
"You must avoid global variables. If you have an exceptional case, use "
"``_G`` variable to set it, add prefix or add table instead of prefix:"
msgstr ""
"Следует избегать глобальных переменных. В исключительных случаях "
"используйте переменную ``_G`` для объявления, добавьте префикс или "
"таблицу вместо префикса:"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:321
msgid ""
"function bad_global_example()\n"
"end -- very, very bad\n"
"\n"
"function good_local_example()\n"
"end\n"
"_G.modulename_good_local_example = good_local_example -- good\n"
"_G.modulename = {}\n"
"_G.modulename.good_local_example = good_local_example -- better"
msgstr ""
"function bad_global_example()\n"
"end -- глобальная, очень-очень плохо\n"
"\n"
"function good_local_example()\n"
"end\n"
"_G.modulename_good_local_example = good_local_example -- локальная, "
"хорошо\n"
"_G.modulename = {}\n"
"_G.modulename.good_local_example = good_local_example -- локальная, лучше"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:332
msgid "Always use prefix to avoid name clash"
msgstr "Всегда добавляйте префиксы во избежание конфликта имен"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:336
msgid "Naming"
msgstr "Именование"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:338
msgid "names of variables/\"objects\" and \"methods\"/functions: snake_case"
msgstr "имена переменных/\"объектов\" и \"методов\"/функций: snake_case"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:339
msgid "names of \"classes\": CamelCase"
msgstr "имена \"классов\": CamelCase"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:340
msgid ""
"private variables/methods (properties in the future) of object starts "
"with underscores ``<object>._<name>``. Avoid using of ``local function "
"private_methods(self) end``"
msgstr ""
"частные переменные/методы (в будущем параметры) объекта начинаются с "
"символа подчеркивания ``<object>._<name>``. Избегайте ``local function "
"private_methods(self) end``"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:343
msgid ""
"boolean - naming ``is_<...>``, ``isnt_<...>``, ``has_``, ``hasnt_`` is a "
"good style."
msgstr ""
"логическое именование приветствуется ``is_<...>``, ``isnt_<...>``, "
"``has_``, ``hasnt_``."

#: ../doc/1.10/dev_guide/lua_style_guide.rst:344
msgid ""
"for \"very local\" variables: - ``t`` is for tables - ``i``, ``j`` are "
"for indexing - ``n`` is for counting - ``k``, ``v`` is what you get out "
"of ``pairs()`` (are acceptable, ``_`` if unused) - ``i``, ``v`` is what "
"you get out of ``ipairs()`` (are acceptable, ``_`` if unused) - "
"``k``/``key`` is for table keys - ``v``/``val``/``value`` is for values "
"that are passed around - ``x``/``y``/``z`` is for generic math quantities"
" - ``s``/``str``/``string`` is for strings - ``c`` is for 1-char strings "
"- ``f``/``func``/``cb`` are for functions - ``status, <rv>..`` or ``ok, "
"<rv>..`` is what you get out of pcall/xpcall - ``buf, sz`` is a (buffer, "
"size) pair - ``<name>_p`` is for pointers - ``t0``.. is for timestamps - "
"``err`` is for errors"
msgstr ""
"для \"самых локальных\" переменных: - ``t`` для таблиц - ``i``, ``j`` для"
" индексации - ``n`` для подсчета - ``k``, ``v`` для получения из "
"``pairs()`` (допускаются, ``_`` если не используются) - ``i``, ``v`` is "
"what you get out of ``ipairs()`` (допускаются, ``_`` если не "
"используются) - ``k``/``key`` для ключей таблицы - "
"``v``/``val``/``value`` для передаваемых значений - ``x``/``y``/``z`` для"
" общих математических величин - ``s``/``str``/``string`` для строк - "
"``c`` для односимвольных строк - ``f``/``func``/``cb`` для функций - "
"``status, <rv>..`` или ``ok, <rv>..`` для получения из pcall/xpcall - "
"``buf, sz`` -- это пара (буфер, размер) - ``<name>_p`` для указателей - "
"``t0``.. для временных отметок - ``err`` для ошибок"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:361
msgid ""
"abbrevations are acceptable if they're unambigous and if you'll document "
"(or they're too common) them."
msgstr ""
"допускается использование сокращений, если они недвусмысленны, и если вы "
"документируете их."

#: ../doc/1.10/dev_guide/lua_style_guide.rst:363
msgid ""
"global variables are written with ALL_CAPS. If it's some system variable,"
" then they're using underscore to define it (``_G``/``_VERSION``/..)"
msgstr ""
"глобальные переменные пишутся ЗАГЛАВНЫМИ_БУКВАМИ. Если это системная "
"переменная, для определения используется символ подчеркивания "
"(``_G``/``_VERSION``/..)"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:365
msgid ""
"module naming snake_case (avoid underscores and dashes) - 'luasql', "
"instead of 'Lua-SQL'"
msgstr ""
"именование модулей -- с помощью snake_case (избегайте подчеркивания и "
"дефисов) - 'luasql', а не 'Lua-SQL'"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:367
msgid "``*_mt`` and ``*_methods`` defines metatable and methods table"
msgstr "``*_mt`` и ``*_methods`` определяют метатаблицу и таблицу методов"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:371
msgid "Idioms and patterns"
msgstr "Идиомы и шаблоны"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:373
msgid ""
"Always use round brackets in call of functions except multiple cases "
"(common lua style idioms):"
msgstr ""
"Всегда пользуйтесь круглыми скобками при вызове функций, за исключением "
"множественных случаев (распространенные идиомы в Lua):"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:376
msgid "``*.cfg{ }`` functions (``box.cfg``/``memcached.cfg``/..)"
msgstr "функции ``*.cfg{ }`` (``box.cfg``/``memcached.cfg``/..)"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:377
msgid "``ffi.cdef[[ ]]`` function"
msgstr "функция ``ffi.cdef[[ ]]``"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:379
msgid "Avoid these kind of constructions:"
msgstr "Избегайте конструкций такого типа:"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:381
msgid "<func>'<name>' (strongly avoid require'..')"
msgstr "<func>'<name>' (особенно избегайте require'..')"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:382
msgid ""
"``function object:method() end`` (use ``functon object.method(self) end``"
" instead)"
msgstr ""
"``function object:method() end`` (используйте ``functon "
"object.method(self) end``)"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:383
msgid "do not use semicolon as table separator (only comma)"
msgstr ""
"не вставляйте точку с запятой в качестве символа-разделителя в таблице "
"(только запятые)"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:384
msgid ""
"semicolons at the end of line (only to split multiple statements on one "
"line)"
msgstr ""
"точки с запятой в конце строки (только для разделения нескольких "
"операторов в одной строке)"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:385
msgid "try to avoid unnecessary function creation (closures/..)"
msgstr "старайтесь избегать создания ненужных функций (closures/..)"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:389
msgid "Modules"
msgstr "Модули"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:391
msgid ""
"Don't start modules with license/authors/descriptions, you can write it "
"in LICENSE/AUTHORS/README files. For writing modules use one of the two "
"patterns (dont use ``modules()``):"
msgstr ""
"Не начинайте создание модуля с указания лицензии/авторов/описания, это "
"можно сделать в файлах LICENSE/AUTHORS/README соответственно. Для "
"написания модулей используйте один из двух шаблонов (не используйте "
"``modules()``):"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:395
msgid ""
"local M = {}\n"
"\n"
"function M.foo()\n"
"...\n"
"end\n"
"\n"
"function M.bar()\n"
"...\n"
"end\n"
"\n"
"return M"
msgstr ""
"local M = {}\n"
"\n"
"function M.foo()\n"
"...\n"
"end\n"
"\n"
"function M.bar()\n"
"...\n"
"end\n"
"\n"
"return M"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:409
msgid "or"
msgstr "или"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:411
msgid ""
"local function foo()\n"
"...\n"
"end\n"
"\n"
"local function bar()\n"
"...\n"
"end\n"
"\n"
"return {\n"
"foo = foo,\n"
"bar = bar,\n"
"}"
msgstr ""
"local function foo()\n"
"...\n"
"end\n"
"\n"
"local function bar()\n"
"...\n"
"end\n"
"\n"
"return {\n"
"foo = foo,\n"
"bar = bar,\n"
"}"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:428
msgid "Commenting"
msgstr "Комментирование"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:430
msgid ""
"You should write code the way it shouldn't be described, but don't forget"
" about commenting it. You shouldn't comment Lua syntax (assume that "
"reader already knows Lua language). Try to tell about functions/variable "
"names/etc."
msgstr ""
"Пишите код так, чтобы его не нужно было описывать, но не забывайте о "
"комментировании. Не следует комментировать Lua-синтаксис (примите, что "
"читатель знаком с языком Lua). Постарайтесь рассказать о функциях, именах"
" переменных и так далее."

#: ../doc/1.10/dev_guide/lua_style_guide.rst:434
msgid ""
"Multiline comments: use matching (``--[[ ]]--``) instead of simple "
"(``--[[ ]]``)."
msgstr ""
"Многострочные комментарии: используйте соответствующие скобки (``--[[ "
"]]--``) вместо простых (``--[[ ]]``)."

#: ../doc/1.10/dev_guide/lua_style_guide.rst:437
msgid "Public function comments (??):"
msgstr "Комментарии к доступным функциям (??):"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:439
msgid ""
"--- Copy any table (shallow and deep version)\n"
"-- * deepcopy: copies all levels\n"
"-- * shallowcopy: copies only first level\n"
"-- Supports __copy metamethod for copying custom tables with metatables\n"
"-- @function gsplit\n"
"-- @table         inp  original table\n"
"-- @shallow[opt]  sep  flag for shallow copy\n"
"-- @returns            table (copy)"
msgstr ""
"--- Копирование любой таблицы (поверхностное и глубокое)\n"
"-- * deepcopy: копирует все уровни\n"
"-- * shallowcopy: копирует только первый уровень\n"
"-- Поддержка метаметода __copy для копирования специальных таблиц с "
"метатаблицами\n"
"-- @function gsplit\n"
"-- @table         inp  оригинальная таблица\n"
"-- @shallow[opt]  sep  флаг для поверхностной копии\n"
"-- @returns            таблица (копия)"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:452
msgid "Testing"
msgstr "Тестирование"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:454
msgid "Use ``tap`` module for writing efficient tests. Example of test file:"
msgstr ""
"Используйте модуль ``tap``, чтобы написать эффективные тесты. Пример "
"файла с тестом:"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:456
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local test = require('tap').test('table')\n"
"test:plan(31)\n"
"\n"
"do -- check basic table.copy (deepcopy)\n"
"    local example_table = {\n"
"        {1, 2, 3},\n"
"        {\"help, I'm very nested\", {{{ }}} }\n"
"    }\n"
"\n"
"    local copy_table = table.copy(example_table)\n"
"\n"
"    test:is_deeply(\n"
"        example_table,\n"
"        copy_table,\n"
"        \"checking, that deepcopy behaves ok\"\n"
"    )\n"
"    test:isnt(\n"
"        example_table,\n"
"        copy_table,\n"
"        \"checking, that tables are different\"\n"
"    )\n"
"    test:isnt(\n"
"        example_table[1],\n"
"        copy_table[1],\n"
"        \"checking, that tables are different\"\n"
"    )\n"
"    test:isnt(\n"
"        example_table[2],\n"
"        copy_table[2],\n"
"        \"checking, that tables are different\"\n"
"    )\n"
"    test:isnt(\n"
"        example_table[2][2],\n"
"        copy_table[2][2],\n"
"        \"checking, that tables are different\"\n"
"    )\n"
"    test:isnt(\n"
"        example_table[2][2][1],\n"
"        copy_table[2][2][1],\n"
"        \"checking, that tables are different\"\n"
"    )\n"
"end\n"
"\n"
"<...>\n"
"\n"
"os.exit(test:check() == true and 0 or 1)"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"local test = require('tap').test('table')\n"
"test:plan(31)\n"
"\n"
"do -- проверка базовой table.copy (глубокая копия)\n"
"    local example_table = {\n"
"        {1, 2, 3},\n"
"        {\"help, I'm very nested\", {{{ }}} }\n"
"    }\n"
"\n"
"    local copy_table = table.copy(example_table)\n"
"\n"
"    test:is_deeply(\n"
"        example_table,\n"
"        copy_table,\n"
"        \"checking, that deepcopy behaves ok\"\n"
"    )\n"
"    test:isnt(\n"
"        example_table,\n"
"        copy_table,\n"
"        \"checking, that tables are different\"\n"
"    )\n"
"    test:isnt(\n"
"        example_table[1],\n"
"        copy_table[1],\n"
"        \"checking, that tables are different\"\n"
"    )\n"
"    test:isnt(\n"
"        example_table[2],\n"
"        copy_table[2],\n"
"        \"checking, that tables are different\"\n"
"    )\n"
"    test:isnt(\n"
"        example_table[2][2],\n"
"        copy_table[2][2],\n"
"        \"checking, that tables are different\"\n"
"    )\n"
"    test:isnt(\n"
"        example_table[2][2][1],\n"
"        copy_table[2][2][1],\n"
"        \"checking, that tables are different\"\n"
"    )\n"
"end\n"
"\n"
"<...>\n"
"\n"
"os.exit(test:check() == true and 0 or 1)"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:507
msgid "When you'll test your code output will be something like this:"
msgstr "После тестирования кода вывод будет примерно таким:"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:509
msgid ""
"TAP version 13\n"
"1..31\n"
"ok - checking, that deepcopy behaves ok\n"
"ok - checking, that tables are different\n"
"ok - checking, that tables are different\n"
"ok - checking, that tables are different\n"
"ok - checking, that tables are different\n"
"ok - checking, that tables are different\n"
"..."
msgstr ""
"TAP version 13\n"
"1..31\n"
"ok - checking, that deepcopy behaves ok\n"
"ok - checking, that tables are different\n"
"ok - checking, that tables are different\n"
"ok - checking, that tables are different\n"
"ok - checking, that tables are different\n"
"ok - checking, that tables are different\n"
"..."

#: ../doc/1.10/dev_guide/lua_style_guide.rst:523
msgid "Error Handling"
msgstr "Обработка ошибок"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:525
msgid "Be generous in what you accept and strict in what you return."
msgstr "Принимайте разнообразные значения и выдавайте строго определенные."

#: ../doc/1.10/dev_guide/lua_style_guide.rst:527
msgid ""
"With error handling this means that you must provide an error object as "
"second multi-return value in case of error. The error object can be a "
"string, a Lua table or cdata, in the latter cases it must have "
"``__tostring`` metamethod defined."
msgstr ""
"В рамках обработки ошибок это означает, что в случае ошибки вы должны "
"предоставить объект ошибки как второе возвращаемое значение. Объектом "
"ошибки может быть строка, Lua-таблица или cdata, в последнем случае "
"должен быть определен метаметод ``__tostring``."

#: ../doc/1.10/dev_guide/lua_style_guide.rst:532
msgid ""
"In case of error, use ``nil`` for the first return value. This makes the "
"error hard to ignore."
msgstr ""
"В случае ошибки нулевое значение ``nil`` должно быть первым возвращаемым "
"значением. В таком случае ошибку трудно игнорировать."

#: ../doc/1.10/dev_guide/lua_style_guide.rst:535
msgid ""
"When checking function return values, check the first argument first. If "
"it's ``nil``, look for error in the second argument:"
msgstr ""
"При проверке возвращаемых значений функции проверяйте сначала первый "
"аргумент. Если это ``nil``, ищите ошибку во втором аргументе:"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:538
msgid ""
"local data, err = foo()\n"
"if not data\n"
"    return nil, err\n"
"end\n"
"return bar(data)"
msgstr ""
"local data, err = foo()\n"
"if not data\n"
"    return nil, err\n"
"end\n"
"return bar(data)"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:546
msgid ""
"Unless performance of your code is paramount, try to avoid using more "
"than two return values."
msgstr ""
"Если производительность вашего кода не имеет первоочередное значение, "
"постарайтесь избегать использования более двух возвращаемых значений."

#: ../doc/1.10/dev_guide/lua_style_guide.rst:549
msgid ""
"In rare cases you may want to return ``nil`` as a legal return value. In "
"this case it's OK to check for error first, and return second:"
msgstr ""
"В редких случаях ``nil`` можно сделать возвращаемым значением. В таком "
"случае можно сначала проверить ошибку, а потом вернуть значение:"

#: ../doc/1.10/dev_guide/lua_style_guide.rst:552
msgid ""
"local data, err = foo()\n"
"if not err\n"
"    return data\n"
"end\n"
"return nil, err"
msgstr ""
"local data, err = foo()\n"
"if not err\n"
"    return data\n"
"end\n"
"return nil, err"

#: ../doc/1.10/dev_guide/python_style_guide.rst:37
msgid "Python Style Guide"
msgstr "Руководство по написанию кода на Python"

#: ../doc/1.10/dev_guide/python_style_guide.rst:41
msgid "Introduction"
msgstr "Введение"

#: ../doc/1.10/dev_guide/python_style_guide.rst:43
msgid ""
"This document gives coding conventions for the Python code comprising the"
" standard library in the main Python distribution.  Please see the "
"companion informational PEP describing style guidelines for the C code in"
" the C implementation of Python [1]_."
msgstr ""
"Данный документ описывает соглашение о том, как писать код для языка "
"Python, включая стандартную библиотеку, входящую в состав Python. "
"Посмотрите также на сопутствующую PEP (Python enhanced proposal -- заявку"
" на улучшение языка Python), описывающую, какого стиля следует "
"придерживаться при написании кода на C в реализации языка Python [1]_."

#: ../doc/1.10/dev_guide/python_style_guide.rst:48
msgid ""
"This document and PEP 257 (Docstring Conventions) were adapted from "
"Guido's original Python Style Guide essay, with some additions from "
"Barry's style guide [2]_."
msgstr ""
"Данный документ, а также PEP 257 (Документирование кода) созданы на "
"основе оригинала рекомендаций Гуидо ван Россума с добавлениями от Барри "
"[2]_."

#: ../doc/1.10/dev_guide/python_style_guide.rst:55
msgid "A Foolish Consistency is the Hobgoblin of Little Minds"
msgstr ""
"A Foolish Consistency is the Hobgoblin of Little Minds (\"Безрассудная "
"согласованность сбивает с толку мелкие умы\")"

#: ../doc/1.10/dev_guide/python_style_guide.rst:57
msgid ""
"One of Guido's key insights is that code is read much more often than it "
"is written.  The guidelines provided here are intended to improve the "
"readability of code and make it consistent across the wide spectrum of "
"Python code.  As PEP 20 says, \"Readability counts\"."
msgstr ""
"Одна из ключевых идей Гвидо заключается в том, что код читается намного "
"чаще, чем пишется. И рекомендации по стилю программирования предназначены"
" улучшить читаемость кода и сделать его согласованным во множестве "
"проектов на языке Python. Как написано в PEP 20, \"Читаемость имеет "
"значение\"."

#: ../doc/1.10/dev_guide/python_style_guide.rst:62
msgid ""
"A style guide is about consistency.  Consistency with this style guide is"
" important.  Consistency within a project is more important. Consistency "
"within one module or function is the most important."
msgstr ""
"В руководстве речь идет о согласованности. Согласованность с руководством"
" очень важна. Согласованность внутри проекта еще важнее. А "
"согласованность в пределах модуля или функции -- самое важное."

#: ../doc/1.10/dev_guide/python_style_guide.rst:66
msgid ""
"But most importantly: know when to be inconsistent -- sometimes the style"
" guide just doesn't apply.  When in doubt, use your best judgment.  Look "
"at other examples and decide what looks best.  And don't hesitate to ask!"
msgstr ""
"Но очень важно понимать, когда можно отойти от рекомендаций, потому что "
"руководство неприменимо. Если вы сомневаетесь, используйте свой опыт. "
"Просто посмотрите на другие примеры и решите, какой выглядит лучше. И не "
"бойтесь спросить!"

#: ../doc/1.10/dev_guide/python_style_guide.rst:71
msgid "Two good reasons to break a particular rule:"
msgstr "Правила можно нарушить по одной из этих причин:"

#: ../doc/1.10/dev_guide/python_style_guide.rst:73
msgid ""
"When applying the rule would make the code less readable, even for "
"someone who is used to reading code that follows the rules."
msgstr ""
"Если применение правила сделает код менее читаемым даже для того, кто "
"привык читать код, написанный по правилам."

#: ../doc/1.10/dev_guide/python_style_guide.rst:76
msgid ""
"To be consistent with surrounding code that also breaks it (maybe for "
"historic reasons) -- although this is also an opportunity to clean up "
"someone else's mess (in true XP style)."
msgstr ""
"Чтобы не отступать по стилю от уже написанного не по правилам кода "
"(возможно, в силу исторических причин) -- впрочем, это может быть "
"возможность причесать чужой код (в стиле XP)."

#: ../doc/1.10/dev_guide/python_style_guide.rst:83
msgid "Code lay-out"
msgstr "Размещение кода"

#: ../doc/1.10/dev_guide/python_style_guide.rst:87
msgid "Indentation"
msgstr "Отступы"

#: ../doc/1.10/dev_guide/python_style_guide.rst:89
msgid "Use 4 spaces per indentation level."
msgstr "Используйте 4 пробела на каждый уровень отступа."

#: ../doc/1.10/dev_guide/python_style_guide.rst:91
msgid ""
"For really old code that you don't want to mess up, you can continue to "
"use 8-space tabs."
msgstr ""
"Если вы не хотите наводить путаницу в очень старом коде, можете "
"продолжать использовать отступы в 8 пробелов."

#: ../doc/1.10/dev_guide/python_style_guide.rst:94
msgid ""
"Continuation lines should align wrapped elements either vertically using "
"Python's implicit line joining inside parentheses, brackets and braces, "
"or using a hanging indent.  When using a hanging indent the following "
"considerations should be applied; there should be no arguments on the "
"first line and further indentation should be used to clearly distinguish "
"itself as a continuation line."
msgstr ""
"Продолжения строк должны выравнивать переносимые элементы либо "
"вертикально, используя подразумевающееся объединение строк в скобках "
"(круглых, квадратных или фигурных), либо с использованием висячего "
"отступа. При использовании висячего отступа необходимо применять "
"следующие соображения: на первой строке не должно быть аргументов, а "
"остальные строки должны четко восприниматься как продолжение строки."

#: ../doc/1.10/dev_guide/python_style_guide.rst:101
#: ../doc/1.10/dev_guide/python_style_guide.rst:358
#: ../doc/1.10/dev_guide/python_style_guide.rst:387
#: ../doc/1.10/dev_guide/python_style_guide.rst:406
#: ../doc/1.10/dev_guide/python_style_guide.rst:419
msgid "Yes::"
msgstr "Правильно::"

#: ../doc/1.10/dev_guide/python_style_guide.rst:103
msgid ""
"# Aligned with opening delimiter\n"
"foo = long_function_name(var_one, var_two,\n"
"                         var_three, var_four)\n"
"\n"
"# More indentation included to distinguish this from the rest.\n"
"def long_function_name(\n"
"        var_one, var_two, var_three,\n"
"        var_four):\n"
"    print(var_one)"
msgstr ""
"# выравнивание по открывающему разделителю\n"
"foo = long_function_name(var_one, var_two,\n"
"                         var_three, var_four)\n"
"\n"
"# больше отступов, чтобы данный сегмент отличался от остальных.\n"
"def long_function_name(\n"
"        var_one, var_two, var_three,\n"
"        var_four):\n"
"    print(var_one)"

#: ../doc/1.10/dev_guide/python_style_guide.rst:113
#: ../doc/1.10/dev_guide/python_style_guide.rst:364
#: ../doc/1.10/dev_guide/python_style_guide.rst:395
#: ../doc/1.10/dev_guide/python_style_guide.rst:411
msgid "No::"
msgstr "Неправильно::"

#: ../doc/1.10/dev_guide/python_style_guide.rst:115
msgid ""
"# Arguments on first line forbidden when not using vertical alignment\n"
"foo = long_function_name(var_one, var_two,\n"
"    var_three, var_four)\n"
"\n"
"# Further indentation required as indentation is not distinguishable\n"
"def long_function_name(\n"
"    var_one, var_two, var_three,\n"
"    var_four):\n"
"    print(var_one)"
msgstr ""
"# запрещены аргументы на первой строке, если не используется вертикальное"
" выравнивание\n"
"foo = long_function_name(var_one, var_two,\n"
"    var_three, var_four)\n"
"\n"
"# необходимы дополнительные отступы для четких отличий\n"
"def long_function_name(\n"
"    var_one, var_two, var_three,\n"
"    var_four):\n"
"    print(var_one)"

#: ../doc/1.10/dev_guide/python_style_guide.rst:125
msgid "Optional::"
msgstr "Возможно::"

#: ../doc/1.10/dev_guide/python_style_guide.rst:127
msgid ""
"# Extra indentation is not necessary.\n"
"foo = long_function_name(\n"
"  var_one, var_two,\n"
"  var_three, var_four)"
msgstr ""
"# Нет необходимости в дополнительных отступах.\n"
"foo = long_function_name(\n"
"  var_one, var_two,\n"
"  var_three, var_four)"

#: ../doc/1.10/dev_guide/python_style_guide.rst:132
msgid ""
"The closing brace/bracket/parenthesis on multi-line constructs may either"
" line up under the first non-whitespace character of the last line of "
"list, as in::"
msgstr ""
"Закрывающие круглые/квадратные/фигурные скобки в многострочных "
"конструкциях могут находиться либо под первым символом последней строки "
"списка (не пробелом), например:"

#: ../doc/1.10/dev_guide/python_style_guide.rst:136
msgid ""
"my_list = [\n"
"    1, 2, 3,\n"
"    4, 5, 6,\n"
"    ]\n"
"result = some_function_that_takes_arguments(\n"
"    'a', 'b', 'c',\n"
"    'd', 'e', 'f',\n"
"    )"
msgstr ""
"my_list = [\n"
"    1, 2, 3,\n"
"    4, 5, 6,\n"
"    ]\n"
"result = some_function_that_takes_arguments(\n"
"    'a', 'b', 'c',\n"
"    'd', 'e', 'f',\n"
"    )"

#: ../doc/1.10/dev_guide/python_style_guide.rst:145
msgid ""
"or it may be lined up under the first character of the line that starts "
"the multi-line construct, as in::"
msgstr ""
"либо под первым символом строки, с которой начинается многострочная "
"конструкция:"

#: ../doc/1.10/dev_guide/python_style_guide.rst:148
msgid ""
"my_list = [\n"
"    1, 2, 3,\n"
"    4, 5, 6,\n"
"]\n"
"result = some_function_that_takes_arguments(\n"
"    'a', 'b', 'c',\n"
"    'd', 'e', 'f',\n"
")"
msgstr ""
"my_list = [\n"
"    1, 2, 3,\n"
"    4, 5, 6,\n"
"]\n"
"result = some_function_that_takes_arguments(\n"
"    'a', 'b', 'c',\n"
"    'd', 'e', 'f',\n"
")"

#: ../doc/1.10/dev_guide/python_style_guide.rst:160
msgid "Tabs or Spaces?"
msgstr "Табуляция или пробелы?"

#: ../doc/1.10/dev_guide/python_style_guide.rst:162
msgid "Never mix tabs and spaces."
msgstr "Никогда не смешивайте символы табуляции и пробелы."

#: ../doc/1.10/dev_guide/python_style_guide.rst:164
msgid ""
"The most popular way of indenting Python is with spaces only.  The "
"second-most popular way is with tabs only.  Code indented with a mixture "
"of tabs and spaces should be converted to using spaces exclusively.  When"
" invoking the Python command line interpreter with the ``-t`` option, it "
"issues warnings about code that illegally mixes tabs and spaces.  When "
"using ``-tt`` these warnings become errors. These options are highly "
"recommended!"
msgstr ""
"Самый распространенный способ отступов в Python -- пробелы. На втором "
"месте -- отступы только с использованием табуляции. Код, в котором "
"используются и те, и другие типы отступов, следует исправить так, чтобы "
"отступы в нем были расставлены только с помощью пробелов. При вызове "
"интерпретатора в командной строке с параметром ``-t`` он выдаст "
"предупреждение в случае использовании смешанного стиля в отступах. "
"Запустив интерпретатор с параметром -tt, вы получите в этих местах "
"ошибки. Рекомендуем использовать эти опции!"

#: ../doc/1.10/dev_guide/python_style_guide.rst:172
msgid ""
"For new projects, spaces-only are strongly recommended over tabs. Most "
"editors have features that make this easy to do."
msgstr ""
"В новых проектах для отступов настоятельно рекомендуется использовать "
"только пробелы. Во многих редакторах можно легко это делать."

#: ../doc/1.10/dev_guide/python_style_guide.rst:177
msgid "Maximum Line Length"
msgstr "Максимальная длина строки"

#: ../doc/1.10/dev_guide/python_style_guide.rst:179
msgid "Limit all lines to a maximum of 79 characters."
msgstr "Ограничьте максимальную длину строки 79 символами."

#: ../doc/1.10/dev_guide/python_style_guide.rst:181
msgid ""
"There are still many devices around that are limited to 80 character "
"lines; plus, limiting windows to 80 characters makes it possible to have "
"several windows side-by-side.  The default wrapping on such devices "
"disrupts the visual structure of the code, making it more difficult to "
"understand.  Therefore, please limit all lines to a maximum of 79 "
"characters.  For flowing long blocks of text (docstrings or comments), "
"limiting the length to 72 characters is recommended."
msgstr ""
"Пока еще есть немало устройств, где длина строки ограничена 80 символами;"
" к тому же, ограничив ширину окна 80 символами, мы можем расположить "
"несколько окон рядом друг с другом. Автоматический перенос строк на таких"
" устройствах нарушит форматирование, и код будет труднее понять. Поэтому "
"ограничьте длину строки 79 символами. Для длинных блоков текста (строки "
"документации или комментарии) рекомендуется ограничиваться 72 символами."

#: ../doc/1.10/dev_guide/python_style_guide.rst:189
msgid ""
"The preferred way of wrapping long lines is by using Python's implied "
"line continuation inside parentheses, brackets and braces.  Long lines "
"can be broken over multiple lines by wrapping expressions in parentheses."
" These should be used in preference to using a backslash for line "
"continuation."
msgstr ""
"Предпочтительный способ переноса длинных строк -- использование "
"подразумевающегося продолжения строки между обычными, квадратными и "
"фигурными скобками. Длинные строки можно разбить на несколько строк в "
"скобках. Это лучше, чем использовать обратную косую черту для продолжения"
" строки."

#: ../doc/1.10/dev_guide/python_style_guide.rst:195
msgid ""
"Backslashes may still be appropriate at times.  For example, long, "
"multiple ``with``-statements cannot use implicit continuation, so "
"backslashes are acceptable::"
msgstr ""
"Обратную косую черту можно использовать время от времени. Например, "
"длинный оператор with не может работать с неявными продолжениями, так что"
" обратная косая черта здесь подойдет:"

#: ../doc/1.10/dev_guide/python_style_guide.rst:199
msgid ""
"with open('/path/to/some/file/you/want/to/read') as file_1, \\\n"
"        open('/path/to/some/file/being/written', 'w') as file_2:\n"
"    file_2.write(file_1.read())"
msgstr ""
"with open('/path/to/some/file/you/want/to/read') as file_1, \\\n"
"        open('/path/to/some/file/being/written', 'w') as file_2:\n"
"    file_2.write(file_1.read())"

#: ../doc/1.10/dev_guide/python_style_guide.rst:203
msgid "Another such case is with ``assert`` statements."
msgstr "Еще один такой случай -- операторы ``assert``."

#: ../doc/1.10/dev_guide/python_style_guide.rst:205
msgid ""
"Make sure to indent the continued line appropriately.  The preferred "
"place to break around a binary operator is *after* the operator, not "
"before it.  Some examples::"
msgstr ""
"Делайте правильные отступы для перенесенной строки. Предпочтительнее "
"вставить перенос строки *после* логического оператора, а не перед ним. "
"Например:"

#: ../doc/1.10/dev_guide/python_style_guide.rst:209
#, python-format
msgid ""
"class Rectangle(Blob):\n"
"\n"
"    def __init__(self, width, height,\n"
"                 color='black', emphasis=None, highlight=0):\n"
"        if (width == 0 and height == 0 and\n"
"            color == 'red' and emphasis == 'strong' or\n"
"            highlight > 100):\n"
"            raise ValueError(\"sorry, you lose\")\n"
"        if width == 0 and height == 0 and (color == 'red' or\n"
"                                           emphasis is None):\n"
"            raise ValueError(\"I don't think so -- values are %s, %s\" %\n"
"                             (width, height))\n"
"        Blob.__init__(self, width, height,\n"
"                      color, emphasis, highlight)"
msgstr ""
"class Rectangle(Blob):\n"
"\n"
"    def __init__(self, width, height,\n"
"                 color='black', emphasis=None, highlight=0):\n"
"        if (width == 0 and height == 0 and\n"
"            color == 'red' and emphasis == 'strong' or\n"
"            highlight > 100):\n"
"            raise ValueError(\"sorry, you lose\")\n"
"        if width == 0 and height == 0 and (color == 'red' or\n"
"                                           emphasis is None):\n"
"            raise ValueError(\"I don't think so -- values are %s, %s\" %\n"
"                             (width, height))\n"
"        Blob.__init__(self, width, height,\n"
"                      color, emphasis, highlight)"

#: ../doc/1.10/dev_guide/python_style_guide.rst:226
msgid "Blank Lines"
msgstr "Пустые строки"

#: ../doc/1.10/dev_guide/python_style_guide.rst:228
msgid "Separate top-level function and class definitions with two blank lines."
msgstr ""
"Отделяйте функции верхнего уровня и определения классов двумя пустыми "
"строками."

#: ../doc/1.10/dev_guide/python_style_guide.rst:231
msgid "Method definitions inside a class are separated by a single blank line."
msgstr "Определения методов в пределах класса отделяйте одной пустой строкой."

#: ../doc/1.10/dev_guide/python_style_guide.rst:234
msgid ""
"Extra blank lines may be used (sparingly) to separate groups of related "
"functions.  Blank lines may be omitted between a bunch of related one-"
"liners (e.g. a set of dummy implementations)."
msgstr ""
"Также можно добавлять пустые строки (не слишком часто) для выделения "
"групп связанных функций. Пустые строки не стоит добавлять между "
"несколькими связанными программами в одну строку (например, в формальной "
"реализации)."

#: ../doc/1.10/dev_guide/python_style_guide.rst:238
msgid "Use blank lines in functions, sparingly, to indicate logical sections."
msgstr ""
"Не слишком часто можно добавлять пустые строки в коде функций, чтобы "
"отделить друг от друга логические части."

#: ../doc/1.10/dev_guide/python_style_guide.rst:240
msgid ""
"Python accepts the control-L (i.e. ^L) form feed character as whitespace;"
" Many tools treat these characters as page separators, so you may use "
"them to separate pages of related sections of your file. Note, some "
"editors and web-based code viewers may not recognize control-L as a form "
"feed and will show another glyph in its place."
msgstr ""
"Python расценивает символ control+L (или ^L) как пробел. Многие редакторы"
" обрабатывают его как разрыв страницы, поэтому его можно использовать для"
" выделения логических части в файле на разных страницах. Обратите "
"внимание, что не все редакторы распознают control+L и могут на его месте "
"отображать другой символ."

#: ../doc/1.10/dev_guide/python_style_guide.rst:248
msgid "Encodings (PEP 263)"
msgstr "Кодировка (PEP 263)"

#: ../doc/1.10/dev_guide/python_style_guide.rst:250
msgid ""
"Code in the core Python distribution should always use the ASCII or "
"Latin-1 encoding (a.k.a. ISO-8859-1).  For Python 3.0 and beyond, UTF-8 "
"is preferred over Latin-1, see PEP 3120."
msgstr ""
"В коде ядра Python всегда должна использоваться кодировка ASCII или "
"Latin-1 (также известную как ISO-8859-1). Начиная с версии Python 3.0, "
"предпочтительной является кодировка UTF-8, а не Latin-1 (см. PEP 3120). "

#: ../doc/1.10/dev_guide/python_style_guide.rst:254
msgid ""
"Files using ASCII should not have a coding cookie.  Latin-1 (or UTF-8) "
"should only be used when a comment or docstring needs to mention an "
"author name that requires Latin-1; otherwise, using ``\\x``, ``\\u`` or "
"``\\U`` escapes is the preferred way to include non-ASCII data in string "
"literals."
msgstr ""
"Для файлов с ASCII не следует объявлять кодировку. Используйте Latin-1 "
"(или UTF-8), только если необходимо указать в комментарии или строке "
"документации имя автора, содержащее в себе символ из Latin-1. В остальных"
" случаях рекомендуется использовать управляющие символы \\x, \\u или \\U,"
" чтобы вставить в строку символы не из ASCII."

#: ../doc/1.10/dev_guide/python_style_guide.rst:260
msgid ""
"For Python 3.0 and beyond, the following policy is prescribed for the "
"standard library (see PEP 3131): All identifiers in the Python standard "
"library MUST use ASCII-only identifiers, and SHOULD use English words "
"wherever feasible (in many cases, abbreviations and technical terms are "
"used which aren't English). In addition, string literals and comments "
"must also be in ASCII. The only exceptions are (a) test cases testing the"
" non-ASCII features, and (b) names of authors. Authors whose names are "
"not based on the latin alphabet MUST provide a latin transliteration of "
"their names."
msgstr ""
"Начиная с версии Python 3.0 и выше, в стандартной библиотеке действует "
"следующая политика (см. PEP 3131): все идентификаторы в стандартной "
"библиотеке Python ДОЛЖНЫ содержать только ASCII-символы и означать "
"английские слова везде, где это возможно (во многих случаях используются "
"сокращения или неанглийские технические термины). Кроме того, строки и "
"комментарии также должны содержать лишь ASCII-символы. Исключения "
"составляют: (a) тестовые сценарии для тестирования функций программы в "
"других кодировках, и (b) имена авторов. Авторы, в именах которых есть "
"буквы не из латинского алфавита, должны транслитерировать свои имена в "
"латиницу."

#: ../doc/1.10/dev_guide/python_style_guide.rst:271
msgid ""
"Open source projects with a global audience are encouraged to adopt a "
"similar policy."
msgstr ""
"В проектах с открытым кодом для широкой аудитории также рекомендуется "
"использовать это правило."

#: ../doc/1.10/dev_guide/python_style_guide.rst:277
msgid "Imports"
msgstr "Импорт"

#: ../doc/1.10/dev_guide/python_style_guide.rst:279
msgid "Imports should usually be on separate lines, e.g.::"
msgstr "Импорт разных модулей должен быть на разных строках, например:"

#: ../doc/1.10/dev_guide/python_style_guide.rst:286
msgid "It's okay to say this though::"
msgstr "В то же время, можно писать вот так:"

#: ../doc/1.10/dev_guide/python_style_guide.rst:290
msgid ""
"Imports are always put at the top of the file, just after any module "
"comments and docstrings, and before module globals and constants."
msgstr ""
"Импорт всегда нужно делать в начале файла сразу после комментариев к "
"модулю и строк документации, перед объявлением глобальных переменных и "
"постоянных."

#: ../doc/1.10/dev_guide/python_style_guide.rst:293
msgid "Imports should be grouped in the following order:"
msgstr "Группируйте импорты в следующем порядке:"

#: ../doc/1.10/dev_guide/python_style_guide.rst:295
msgid "standard library imports"
msgstr "импорты стандартной библиотеки"

#: ../doc/1.10/dev_guide/python_style_guide.rst:296
msgid "related third party imports"
msgstr "импорты сторонних библиотек"

#: ../doc/1.10/dev_guide/python_style_guide.rst:297
msgid "local application/library specific imports"
msgstr "импорты модулей текущего проекта"

#: ../doc/1.10/dev_guide/python_style_guide.rst:299
msgid "You should put a blank line between each group of imports."
msgstr "Между группами импортов вставляйте пустую строку."

#: ../doc/1.10/dev_guide/python_style_guide.rst:301
msgid "Put any relevant ``__all__`` specification after the imports."
msgstr "Указывайте все необходимые спецификации __all__ после импортов."

#: ../doc/1.10/dev_guide/python_style_guide.rst:303
msgid ""
"Relative imports for intra-package imports are highly discouraged. Always"
" use the absolute package path for all imports.  Even now that PEP 328 is"
" fully implemented in Python 2.5, its style of explicit relative imports "
"is actively discouraged; absolute imports are more portable and usually "
"more readable."
msgstr ""
"Относительные импорты крайне не рекомендуются. Всегда указывайте "
"абсолютный путь к модулю для всех видов импорта. Даже сейчас, когда PEP "
"328 реализован в версии Python 2.5, явно использовать относительные "
"импорты не рекомендуется. Абсолютные импорты более независимы и, как "
"правило, обладают лучшей читаемостью."

#: ../doc/1.10/dev_guide/python_style_guide.rst:309
msgid ""
"When importing a class from a class-containing module, it's usually okay "
"to spell this::"
msgstr "При импорте класса из модуля с классами, обычно можно писать так:"

#: ../doc/1.10/dev_guide/python_style_guide.rst:315
msgid "If this spelling causes local name clashes, then spell them ::"
msgstr "Если такое написание вызывает конфликт локальных имен, пишите:"

#: ../doc/1.10/dev_guide/python_style_guide.rst:320
msgid "and use \"myclass.MyClass\" and \"foo.bar.yourclass.YourClass\"."
msgstr "И используйте \"myclass.MyClass\" и \"foo.bar.yourclass.YourClass\"."

#: ../doc/1.10/dev_guide/python_style_guide.rst:325
msgid "Whitespace in Expressions and Statements"
msgstr "Пробелы в выражениях и операторах"

#: ../doc/1.10/dev_guide/python_style_guide.rst:329
msgid "Pet Peeves"
msgstr "Наболевшие вопросы"

#: ../doc/1.10/dev_guide/python_style_guide.rst:331
msgid "Avoid extraneous whitespace in the following situations:"
msgstr "Избегайте использования пробелов в следующих ситуациях:"

#: ../doc/1.10/dev_guide/python_style_guide.rst:333
msgid "Immediately inside parentheses, brackets or braces. ::"
msgstr "Перед круглыми, фигурными и квадратными скобками и после них:"

#: ../doc/1.10/dev_guide/python_style_guide.rst:338
msgid "Immediately before a comma, semicolon, or colon::"
msgstr "Сразу перед запятой, точкой с запятой, двоеточием:"

#: ../doc/1.10/dev_guide/python_style_guide.rst:343
msgid ""
"Immediately before the open parenthesis that starts the argument list of "
"a function call::"
msgstr ""
"Сразу перед открывающей скобкой, после которой начинается список "
"аргументов при вызове функции:"

#: ../doc/1.10/dev_guide/python_style_guide.rst:349
msgid ""
"Immediately before the open parenthesis that starts an indexing or "
"slicing::"
msgstr "Сразу перед открывающей скобкой, после которой идет индекс или срез:"

#: ../doc/1.10/dev_guide/python_style_guide.rst:355
msgid ""
"More than one space around an assignment (or other) operator to align it "
"with another."
msgstr ""
"Больше одного пробела вокруг оператора присваивания (или другого) для "
"того, чтобы выровнять его с другим оператором:"

#: ../doc/1.10/dev_guide/python_style_guide.rst:373
msgid "Other Recommendations"
msgstr "Прочие рекомендации"

#: ../doc/1.10/dev_guide/python_style_guide.rst:375
msgid ""
"Always surround these binary operators with a single space on either "
"side: assignment (``=``), augmented assignment (``+=``, ``-=`` etc.), "
"comparisons (``==``, ``<``, ``>``, ``!=``, ``<>``, ``<=``, ``>=``, "
"``in``, ``not in``, ``is``, ``is not``), Booleans (``and``, ``or``, "
"``not``)."
msgstr ""
"Всегда окружайте эти знаки двухместных операций пробелами по одному с "
"каждой стороны: присваивание (``=``), комбинированное присваивание "
"(``+=``, ``-=`` и т.д.), сравнения (``==``, ``<``, ``>``, ``!=``, ``<>``,"
" ``<=``, ``>=``, ``in``, ``not in``, ``is``, ``is not``), логические "
"операторы (``and``, ``or``, ``not``)."

#: ../doc/1.10/dev_guide/python_style_guide.rst:381
msgid ""
"If operators with different priorities are used, consider adding "
"whitespace around the operators with the lowest priority(ies). Use your "
"own judgement; however, never use more than one space, and always have "
"the same amount of whitespace on both sides of a binary operator."
msgstr ""
"Если используются знаки операций с разными приоритетами, рассмотрите "
"возможность добавить пробелы вокруг операций с самым низким приоритетом. "
"Судите сами, однако, никогда не используйте больше одного пробела, и "
"всегда используйте одинаковое количество пробелов по обе стороны от "
"знака."

#: ../doc/1.10/dev_guide/python_style_guide.rst:403
msgid ""
"Don't use spaces around the ``=`` sign when used to indicate a keyword "
"argument or a default parameter value."
msgstr ""
"Не используйте пробелы для отделения знака ``=``, когда он употребляется "
"для обозначения аргумента ключевого слова или значения параметра по "
"умолчанию."

#: ../doc/1.10/dev_guide/python_style_guide.rst:416
msgid ""
"Compound statements (multiple statements on the same line) are generally "
"discouraged."
msgstr ""
"Не рекомендуется использовать составные операторы (несколько операторов в"
" одной строке)."

#: ../doc/1.10/dev_guide/python_style_guide.rst:427
#: ../doc/1.10/dev_guide/python_style_guide.rst:436
msgid "Rather not::"
msgstr "Скорее неправильно:"

#: ../doc/1.10/dev_guide/python_style_guide.rst:432
msgid ""
"While sometimes it's okay to put an if/for/while with a small body on the"
" same line, never do this for multi-clause statements.  Also avoid "
"folding such long lines!"
msgstr ""
"Иногда можно разместить тело цикла if/for/while в той же строке, но если "
"операторов несколько, никогда так не делайте. И избегайте свертывания "
"таких длинных строк!"

#: ../doc/1.10/dev_guide/python_style_guide.rst:442
msgid "Definitely not::"
msgstr "Точно неправильно:"

#: ../doc/1.10/dev_guide/python_style_guide.rst:457
msgid "Comments"
msgstr "Комментарии"

#: ../doc/1.10/dev_guide/python_style_guide.rst:459
msgid ""
"Comments that contradict the code are worse than no comments.  Always "
"make a priority of keeping the comments up-to-date when the code changes!"
msgstr ""
"Комментарии, которые противоречат коду, хуже, чем отсутствие "
"комментариев. Всегда считайте первоочередной задачей исправить "
"комментарии, если меняется код!"

#: ../doc/1.10/dev_guide/python_style_guide.rst:463
msgid ""
"Comments should be complete sentences.  If a comment is a phrase or "
"sentence, its first word should be capitalized, unless it is an "
"identifier that begins with a lower case letter (never alter the case of "
"identifiers!)."
msgstr ""
"Комментарии должны представлять собой законченные предложения. Если "
"комментарием будет фраза или предложение, первое слово должно быть "
"написано с заглавной буквы, если только это не идентификатор, который "
"пишется со строчной буквы (никогда не меняйте регистр идентификаторов!)."

#: ../doc/1.10/dev_guide/python_style_guide.rst:468
msgid ""
"If a comment is short, the period at the end can be omitted.  Block "
"comments generally consist of one or more paragraphs built out of "
"complete sentences, and each sentence should end in a period."
msgstr ""
"Если комментарий короткий, точку в конце предложения можно опустить. Блок"
" комментариев обычно состоит из одного или более абзацев, составленных из"
" полных предложений, поэтому каждое предложение должно заканчиваться "
"точкой."

#: ../doc/1.10/dev_guide/python_style_guide.rst:472
msgid "You should use two spaces after a sentence-ending period."
msgstr "После точки в конце предложения следует ставить два пробела."

#: ../doc/1.10/dev_guide/python_style_guide.rst:474
msgid "When writing English, Strunk and White apply."
msgstr ""
"Если вы пишете на английском языке, не забывайте о рекомендациях Странка "
"и Уайта по стилю."

#: ../doc/1.10/dev_guide/python_style_guide.rst:476
#, python-format
msgid ""
"Python coders from non-English speaking countries: please write your "
"comments in English, unless you are 120% sure that the code will never be"
" read by people who don't speak your language."
msgstr ""
"Разработчики на языке Python из неанглоязычных стран, пишите комментарии "
"на английском, если только вы не уверены на 120%, что ваш код никогда не "
"будут читать люди, не знающие вашего родного языка."

#: ../doc/1.10/dev_guide/python_style_guide.rst:482
msgid "Block Comments"
msgstr "Блок комментариев"

#: ../doc/1.10/dev_guide/python_style_guide.rst:484
msgid ""
"Block comments generally apply to some (or all) code that follows them, "
"and are indented to the same level as that code.  Each line of a block "
"comment starts with a ``#`` and a single space (unless it is indented "
"text inside the comment)."
msgstr ""
"Блок комментариев обычно сопровождает фрагмент кода (или весь код), "
"который за ним следует, и находится на том же уровне отступов, что и сам "
"код. Каждая строка блока комментариев должна начинаться с символа ``#`` и"
" одного пробела после него (если только в самом тексте комментария нет "
"отступов)."

#: ../doc/1.10/dev_guide/python_style_guide.rst:489
msgid ""
"Paragraphs inside a block comment are separated by a line containing a "
"single ``#``."
msgstr ""
"Абзацы в пределах блока комментариев отделяются строкой, состоящей из "
"одного символа ``#``."

#: ../doc/1.10/dev_guide/python_style_guide.rst:494
msgid "Inline Comments"
msgstr "Комментарии в строке с кодом"

#: ../doc/1.10/dev_guide/python_style_guide.rst:496
msgid "Use inline comments sparingly."
msgstr "Старайтесь реже использовать подобные комментарии."

#: ../doc/1.10/dev_guide/python_style_guide.rst:498
msgid ""
"An inline comment is a comment on the same line as a statement. Inline "
"comments should be separated by at least two spaces from the statement.  "
"They should start with a # and a single space."
msgstr ""
"Встроенный комментарий находится в той же строке, что и оператор. Такие "
"комментарии должны отделяться от оператора хотя бы двумя пробелами. Они "
"должны начинаться с символа # и одного пробела."

#: ../doc/1.10/dev_guide/python_style_guide.rst:502
msgid ""
"Inline comments are unnecessary and in fact distracting if they state the"
" obvious.  Don't do this::"
msgstr ""
"Комментарии в строке с кодом не нужны и в действительности отвлекают от "
"чтения, если они объясняют очевидное. Не пишите так:"

#: ../doc/1.10/dev_guide/python_style_guide.rst:505
msgid "x = x + 1                 # Increment x"
msgstr "x = x + 1                 # Увеличение x"

#: ../doc/1.10/dev_guide/python_style_guide.rst:507
msgid "But sometimes, this is useful::"
msgstr "Иногда, впрочем, они полезны:"

#: ../doc/1.10/dev_guide/python_style_guide.rst:509
msgid "x = x + 1                 # Compensate for border"
msgstr "x = x + 1                 # Место для рамки окна"

#: ../doc/1.10/dev_guide/python_style_guide.rst:513
msgid "Documentation Strings"
msgstr "Строки документации"

#: ../doc/1.10/dev_guide/python_style_guide.rst:515
msgid ""
"Conventions for writing good documentation strings (a.k.a. "
"\"docstrings\") are immortalized in PEP 257."
msgstr ""
"Соглашения о написании хорошей документации (docstrings) увековечены "
"в PEP 257."

#: ../doc/1.10/dev_guide/python_style_guide.rst:518
msgid ""
"Write docstrings for all public modules, functions, classes, and methods."
"  Docstrings are not necessary for non-public methods, but you should "
"have a comment that describes what the method does.  This comment should "
"appear after the ``def`` line."
msgstr ""
"Пишите документацию для всех доступных модулей, функций, классов, "
"методов. Строки документации необязательны для внутренних методов, но "
"нужно добавить комментарий о том, что делает метод. Комментарий должен "
"идти после строки ``def``."

#: ../doc/1.10/dev_guide/python_style_guide.rst:523
msgid ""
"PEP 257 describes good docstring conventions.  Note that most "
"importantly, the ``\"\"\"`` that ends a multiline docstring should be on "
"a line by itself, and preferably preceded by a blank line, e.g.::"
msgstr ""
"PEP 257 объясняет, как правильно и хорошо писать документацию. Следует "
"отметить, что очень важно, чтобы закрывающие ``\"\"\"`` стояли на "
"отдельной строке, а предпочтительно, чтобы перед ними была и пустая "
"строка, например:"

#: ../doc/1.10/dev_guide/python_style_guide.rst:533
msgid ""
"For one liner docstrings, it's okay to keep the closing ``\"\"\"`` on the"
" same line."
msgstr ""
"Для однострочной документации можно оставить закрывающие ``\"\"\"`` на "
"той же строке."

#: ../doc/1.10/dev_guide/python_style_guide.rst:539
msgid "Version Bookkeeping"
msgstr "Контроль версий"

#: ../doc/1.10/dev_guide/python_style_guide.rst:541
msgid ""
"If you have to have Subversion, CVS, or RCS crud in your source file, do "
"it as follows. ::"
msgstr ""
"Если вам нужно использовать Subversion, CVS или RCS в ваших исходных "
"кодах, делайте это следующим образом:"

#: ../doc/1.10/dev_guide/python_style_guide.rst:544
msgid ""
"__version__ = \"$Revision$\"\n"
"# $Source$"
msgstr ""
"__version__ = \"$Revision$\"\n"
"# $Source$"

#: ../doc/1.10/dev_guide/python_style_guide.rst:547
msgid ""
"These lines should be included after the module's docstring, before any "
"other code, separated by a blank line above and below."
msgstr ""
"Эти строки следует указывать после документации модуля перед любым другим"
" кодом, отделяя их пустыми строками сверху и снизу."

#: ../doc/1.10/dev_guide/python_style_guide.rst:553
msgid "Naming Conventions"
msgstr "Соглашения по именованию"

#: ../doc/1.10/dev_guide/python_style_guide.rst:555
msgid ""
"The naming conventions of Python's library are a bit of a mess, so we'll "
"never get this completely consistent -- nevertheless, here are the "
"currently recommended naming standards.  New modules and packages "
"(including third party frameworks) should be written to these standards, "
"but where an existing library has a different style, internal consistency"
" is preferred."
msgstr ""
"Соглашения по именованию переменных в Python довольно запущены, поэтому "
"полной согласованности невозможно будет добиться. Тем не менее, ниже мы "
"приводим список рекомендованных стандартов именования. Новые модули и "
"пакеты (включая сторонние) должны быть написаны в соответствии с этими "
"стандартами, но если уже существующая библиотека написана в другом стиле,"
" предпочтительно поддерживать согласованность."

#: ../doc/1.10/dev_guide/python_style_guide.rst:564
msgid "Descriptive: Naming Styles"
msgstr "Описание: Стили имен"

#: ../doc/1.10/dev_guide/python_style_guide.rst:566
msgid ""
"There are a lot of different naming styles.  It helps to be able to "
"recognize what naming style is being used, independently from what they "
"are used for."
msgstr ""
"Существует много различных стилей именования. Полезно распознавать, какой"
" стиль именования используется независимо от того, для чего он "
"используется."

#: ../doc/1.10/dev_guide/python_style_guide.rst:570
msgid "The following naming styles are commonly distinguished:"
msgstr "Обычно различают следующие стили именования:"

#: ../doc/1.10/dev_guide/python_style_guide.rst:572
msgid "``b`` (single lowercase letter)"
msgstr "``b`` (отдельная строчная буква)"

#: ../doc/1.10/dev_guide/python_style_guide.rst:573
msgid "``B`` (single uppercase letter)"
msgstr "``B`` (отдельная заглавная буква)"

#: ../doc/1.10/dev_guide/python_style_guide.rst:574
msgid "``lowercase``"
msgstr "``lowercase`` (слово в нижнем регистре)"

#: ../doc/1.10/dev_guide/python_style_guide.rst:575
msgid "``lower_case_with_underscores``"
msgstr ""
"``lower_case_with_underscores`` (слова из строчных букв с символами "
"подчеркивания)"

#: ../doc/1.10/dev_guide/python_style_guide.rst:576
msgid "``UPPERCASE``"
msgstr "``UPPERCASE`` (заглавные буквы)"

#: ../doc/1.10/dev_guide/python_style_guide.rst:577
msgid "``UPPER_CASE_WITH_UNDERSCORES``"
msgstr ""
"UPPERCASE_WITH_UNDERSCORES (слова из заглавных букв с символами "
"подчеркивания)"

#: ../doc/1.10/dev_guide/python_style_guide.rst:578
msgid ""
"``CapitalizedWords`` (or CapWords, or CamelCase -- so named because of "
"the bumpy look of its letters [3]_).  This is also sometimes known as "
"StudlyCaps."
msgstr ""
"``CapitalizedWords`` (слова с заглавными буквами, или CapWords, или "
"CamelCase -- называется так, потому что прописные буквы внутри слова "
"напоминают горбы верблюда [3]_). Иногда называется StudlyCaps. "

#: ../doc/1.10/dev_guide/python_style_guide.rst:582
msgid ""
"Note: When using abbreviations in CapWords, capitalize all the letters of"
" the abbreviation.  Thus HTTPServerError is better than HttpServerError."
msgstr ""
"Примечание: когда вы используете аббревиатуры в стиле CapWords, пишите "
"все буквы аббревиатуры заглавными. HTTPServerError выглядит лучше, чем "
"HttpServerError."

#: ../doc/1.10/dev_guide/python_style_guide.rst:585
msgid ""
"``mixedCase`` (differs from CapitalizedWords by initial lowercase "
"character!)"
msgstr ""
"mixedCase (отличается от CapitalizedWords тем, что первое слово "
"начинается со строчной буквы!)"

#: ../doc/1.10/dev_guide/python_style_guide.rst:587
msgid "``Capitalized_Words_With_Underscores`` (ugly!)"
msgstr ""
"Capitalized_Words_With_Underscores (слова с заглавными буквами и "
"символами подчеркивания -- уродливо!)"

#: ../doc/1.10/dev_guide/python_style_guide.rst:589
msgid ""
"There's also the style of using a short unique prefix to group related "
"names together.  This is not used much in Python, but it is mentioned for"
" completeness.  For example, the ``os.stat()`` function returns a tuple "
"whose items traditionally have names like ``st_mode``, ``st_size``, "
"``st_mtime`` and so on.  (This is done to emphasize the correspondence "
"with the fields of the POSIX system call struct, which helps programmers "
"familiar with that.)"
msgstr ""
"Еще есть стиль, в котором к именам из одной логической группы добавляется"
" короткий уникальный префикс. Этот стиль редко используется в Python, но "
"упомянем его для полноты изложения. Например, функция ``os.stat()`` "
"возвращает кортеж, имена в котором традиционно выглядят так: ``st_mode``,"
" ``st_size``, ``st_mtime`` и так далее. (Так сделано, чтобы подчеркнуть "
"соответствие этих полей структуре системных вызовов POSIX, что помогает "
"знакомым с ней разработчикам)."

#: ../doc/1.10/dev_guide/python_style_guide.rst:597
msgid ""
"The X11 library uses a leading X for all its public functions.  In "
"Python, this style is generally deemed unnecessary because attribute and "
"method names are prefixed with an object, and function names are prefixed"
" with a module name."
msgstr ""
"В библиотеке X11 используется префикс Х для всех доступных функций. В "
"Python этот стиль считается лишним, потому что перед полями и именами "
"методов стоит имя объекта, а перед именами функций стоит имя модуля."

#: ../doc/1.10/dev_guide/python_style_guide.rst:602
msgid ""
"In addition, the following special forms using leading or trailing "
"underscores are recognized (these can generally be combined with any case"
" convention):"
msgstr ""
"Кроме того, используются следующие специальные формы записи имен с "
"добавлением символа подчеркивания в начало или конец имени (их можно "
"использовать с любым типом регистра):"

#: ../doc/1.10/dev_guide/python_style_guide.rst:606
msgid ""
"``_single_leading_underscore``: weak \"internal use\" indicator. E.g. "
"``from M import *`` does not import objects whose name starts with an "
"underscore."
msgstr ""
"``_single_leading_underscore``: слабый индикатор \"для внутреннего "
"пользования\". Например, ``from M import *`` не будет импортировать "
"объекты, имена которых начинаются с символа подчеркивания."

#: ../doc/1.10/dev_guide/python_style_guide.rst:610
msgid ""
"``single_trailing_underscore_``: used by convention to avoid conflicts "
"with Python keyword, e.g. ::"
msgstr ""
"``single_trailing_underscore_``: используется по соглашению во избежание "
"конфликтов с ключевыми словами Python, например:"

#: ../doc/1.10/dev_guide/python_style_guide.rst:615
msgid ""
"``__double_leading_underscore``: when naming a class attribute, invokes "
"name mangling (inside class FooBar, ``__boo`` becomes ``_FooBar__boo``; "
"see below)."
msgstr ""
"``__double_leading_underscore``: изменяет имя атрибута класса (в классе "
"FooBar, ``__boo`` становится ``_FooBar__boo``; см. ниже)."

#: ../doc/1.10/dev_guide/python_style_guide.rst:619
msgid ""
"``__double_leading_and_trailing_underscore__``: \"magic\" objects or "
"attributes that live in user-controlled namespaces. E.g. ``__init__``, "
"``__import__`` or ``__file__``.  Never invent such names; only use them "
"as documented."
msgstr ""
"``__double_leading_and_trailing_underscore__``: \"волшебные\" объекты или"
" атрибуты, которые находятся в live in в пространствах имен, управляемых "
"пользователем. Например, ``__init__``, ``__import__`` или ``__file__``. "
"Не придумывайте такие имена, используйте их только так, как написано в "
"документации."

#: ../doc/1.10/dev_guide/python_style_guide.rst:626
msgid "Prescriptive: Naming Conventions"
msgstr "Предписания: соглашения по именованию"

#: ../doc/1.10/dev_guide/python_style_guide.rst:630
msgid "Names to Avoid"
msgstr "Имена, которых следует избегать"

#: ../doc/1.10/dev_guide/python_style_guide.rst:632
msgid ""
"Never use the characters 'l' (lowercase letter el), 'O' (uppercase letter"
" oh), or 'I' (uppercase letter eye) as single character variable names."
msgstr ""
"Никогда не используйте символы 'l' (строчная латинская буква эль), 'O' "
"(заглавная латинская буква о) или 'I' (заглавная латинская буква ай) в "
"качестве однобуквенных имен переменных."

#: ../doc/1.10/dev_guide/python_style_guide.rst:636
msgid ""
"In some fonts, these characters are indistinguishable from the numerals "
"one and zero.  When tempted to use 'l', use 'L' instead."
msgstr ""
"В некоторых шрифтах эти символы неотличимы от цифр один и ноль. Если "
"нельзя обойтись без 'l', пишите вместо нее 'L'."

#: ../doc/1.10/dev_guide/python_style_guide.rst:641
msgid "Package and Module Names"
msgstr "Имена модулей и пакетов"

#: ../doc/1.10/dev_guide/python_style_guide.rst:643
msgid ""
"Modules should have short, all-lowercase names.  Underscores can be used "
"in the module name if it improves readability.  Python packages should "
"also have short, all-lowercase names, although the use of underscores is "
"discouraged."
msgstr ""
"Имена модулей должны быть короткими и состоять из строчных букв. Можно "
"использовать и символы подчеркивания, если это улучшает читаемость. Имена"
" пакетов Python также должны быть короткими и состоять из строчных букв, "
"но здесь символы подчеркивания не приветствуются."

#: ../doc/1.10/dev_guide/python_style_guide.rst:648
msgid ""
"Since module names are mapped to file names, and some file systems are "
"case insensitive and truncate long names, it is important that module "
"names be chosen to be fairly short -- this won't be a problem on Unix, "
"but it may be a problem when the code is transported to older Mac or "
"Windows versions, or DOS."
msgstr ""
"Так как имена модулей отображаются в именах файлов, а некоторые файловые "
"системы являются нечувствительными к регистру символов и обрезают длинные"
" имена, очень важно использовать достаточно короткие имена модулей -- это"
" не проблема в Unix, но может стать проблемой при переносе кода в старые "
"версии Windows, Mac или DOS."

#: ../doc/1.10/dev_guide/python_style_guide.rst:654
msgid ""
"When an extension module written in C or C++ has an accompanying Python "
"module that provides a higher level (e.g. more object oriented) "
"interface, the C/C++ module has a leading underscore (e.g. ``_socket``)."
msgstr ""
"Если для модуля расширения, написанного на С или C++, есть сопутствующий "
"Python-модуль, содержащий интерфейс более высокого уровня (например, "
"более объектно-ориентированный), модуль С/С++ начинается с символа "
"подчеркивания (например, ``_socket``)."

#: ../doc/1.10/dev_guide/python_style_guide.rst:661
msgid "Class Names"
msgstr "Имена классов"

#: ../doc/1.10/dev_guide/python_style_guide.rst:663
msgid ""
"Almost without exception, class names use the CapWords convention. "
"Classes for internal use have a leading underscore in addition."
msgstr ""
"Все имена классов должны соответствовать CapWords почти без исключений. "
"Классы для внутреннего использования могут также начинаться с символа "
"подчеркивания."

#: ../doc/1.10/dev_guide/python_style_guide.rst:668
msgid "Exception Names"
msgstr "Имена исключений"

#: ../doc/1.10/dev_guide/python_style_guide.rst:670
msgid ""
"Because exceptions should be classes, the class naming convention applies"
" here.  However, you should use the suffix \"Error\" on your exception "
"names (if the exception actually is an error)."
msgstr ""
"Так как исключения должны быть классами, к исключениям применяются "
"правила именования классов. Однако вы можете добавить суффикс \"Error\" в"
" конце имени (если исключение действительно является ошибкой)."

#: ../doc/1.10/dev_guide/python_style_guide.rst:676
msgid "Global Variable Names"
msgstr "Имена глобальных переменных"

#: ../doc/1.10/dev_guide/python_style_guide.rst:678
msgid ""
"(Let's hope that these variables are meant for use inside one module "
"only.)  The conventions are about the same as those for functions."
msgstr ""
"(Будем надеяться, что такие имена используются только в пределах одного "
"модуля.) Применяются те же правила, что и для имен функций."

#: ../doc/1.10/dev_guide/python_style_guide.rst:681
msgid ""
"Modules that are designed for use via ``from M import *`` should use the "
"``__all__`` mechanism to prevent exporting globals, or use the older "
"convention of prefixing such globals with an underscore (which you might "
"want to do to indicate these globals are \"module non-public\")."
msgstr ""
"В модули, которые предназначены для использования с помощью ``from M "
"import *``, следует добавить механизм ``__all__``, чтобы предотвратить "
"экспорт глобальных переменных, или же использовать старое соглашение, "
"добавляя перед именами таких глобальных переменных один символ "
"подчеркивания (которым можно обозначить глобальные переменные, которые "
"используются только внутри модуля)."

#: ../doc/1.10/dev_guide/python_style_guide.rst:689
msgid "Function Names"
msgstr "Имена функций"

#: ../doc/1.10/dev_guide/python_style_guide.rst:691
msgid ""
"Function names should be lowercase, with words separated by underscores "
"as necessary to improve readability."
msgstr ""
"Имена функций должны состоять из строчных букв, а слова разделяться "
"символами подчеркивания, чтобы улучшить читаемость."

#: ../doc/1.10/dev_guide/python_style_guide.rst:694
msgid ""
"mixedCase is allowed only in contexts where that's already the prevailing"
" style (e.g. threading.py), to retain backwards compatibility."
msgstr ""
"mixedCase допускается только в тех местах, где уже преобладает такой "
"стиль (например, threading.py), для обратной совместимости."

#: ../doc/1.10/dev_guide/python_style_guide.rst:700
msgid "Function and method arguments"
msgstr "Аргументы функций и методов"

#: ../doc/1.10/dev_guide/python_style_guide.rst:702
msgid "Always use ``self`` for the first argument to instance methods."
msgstr ""
"Всегда используйте ``self`` в качестве первого аргумента метода "
"экземпляра."

#: ../doc/1.10/dev_guide/python_style_guide.rst:704
msgid "Always use ``cls`` for the first argument to class methods."
msgstr "Всегда используйте ``cls`` в качестве первого аргумента метода класса."

#: ../doc/1.10/dev_guide/python_style_guide.rst:706
msgid ""
"If a function argument's name clashes with a reserved keyword, it is "
"generally better to append a single trailing underscore rather than use "
"an abbreviation or spelling corruption.  Thus ``class_`` is better than "
"``clss``.  (Perhaps better is to avoid such clashes by using a synonym.)"
msgstr ""
"Если имя аргумента функции конфликтует с зарезервированным ключевым "
"словом, обычно лучше добавить в конец имени символ подчеркивания, а не "
"сокращать слово или искажать его. Таким образом, ``class_`` лучше, чем "
"``clss``. (Возможно, будет лучше избегать конфликта имен путем подбора "
"синонима)."

#: ../doc/1.10/dev_guide/python_style_guide.rst:714
msgid "Method Names and Instance Variables"
msgstr "Имена методов и переменные экземпляров"

#: ../doc/1.10/dev_guide/python_style_guide.rst:716
msgid ""
"Use the function naming rules: lowercase with words separated by "
"underscores as necessary to improve readability."
msgstr ""
"Используйте тот же стиль, что и для имен функций: они должны состоять из "
"строчных букв, а слова разделяться символами подчеркивания, чтобы "
"улучшить читаемость."

#: ../doc/1.10/dev_guide/python_style_guide.rst:719
msgid ""
"Use one leading underscore only for non-public methods and instance "
"variables."
msgstr ""
"Используйте только один символ подчеркивания в начале слова для "
"внутренних методов и переменных экземпляров."

#: ../doc/1.10/dev_guide/python_style_guide.rst:722
msgid ""
"To avoid name clashes with subclasses, use two leading underscores to "
"invoke Python's name mangling rules."
msgstr ""
"Чтобы избежать конфликта имен с подклассами, добавьте два символа "
"подчеркивания в начале слова, чтобы включить механизм изменения имен в "
"Python. "

#: ../doc/1.10/dev_guide/python_style_guide.rst:725
msgid ""
"Python mangles these names with the class name: if class Foo has an "
"attribute named ``__a``, it cannot be accessed by ``Foo.__a``.  (An "
"insistent user could still gain access by calling ``Foo._Foo__a``.) "
"Generally, double leading underscores should be used only to avoid name "
"conflicts with attributes in classes designed to be subclassed."
msgstr ""
"Python изменяет эти имена: если в классе Foo есть атрибут с именем "
"``__a``, к нему нельзя обратиться через ``Foo.__a``. (Настойчивый "
"пользователь всё равно может получить доступ через ``Foo._Foo__a``.) "
"Вообще, двойное подчеркивание в начале имени должно использоваться только"
" во избежание конфликта имен с атрибутами классов, предназначенных для "
"разделения на подклассы."

#: ../doc/1.10/dev_guide/python_style_guide.rst:731
msgid "Note: there is some controversy about the use of __names (see below)."
msgstr ""
"Примечание: есть некоторые разногласия по поводу использования имен "
"__names (см. ниже)."

#: ../doc/1.10/dev_guide/python_style_guide.rst:735
msgid "Constants"
msgstr "Постоянные"

#: ../doc/1.10/dev_guide/python_style_guide.rst:737
msgid ""
"Constants are usually defined on a module level and written in all "
"capital letters with underscores separating words.  Examples include "
"``MAX_OVERFLOW`` and ``TOTAL``."
msgstr ""
"Постоянные обычно объявляются на уровне модуля и записываются только "
"заглавными буквами, а слова разделяются символами подчеркивания. "
"Например: MAX_OVERFLOW, TOTAL."

#: ../doc/1.10/dev_guide/python_style_guide.rst:743
msgid "Designing for inheritance"
msgstr "Проектирование наследования"

#: ../doc/1.10/dev_guide/python_style_guide.rst:745
msgid ""
"Always decide whether a class's methods and instance variables "
"(collectively: \"attributes\") should be public or non-public.  If in "
"doubt, choose non-public; it's easier to make it public later than to "
"make a public attribute non-public."
msgstr ""
"Обязательно решите, каким должен быть метод класса или переменная "
"экземпляра класса (в общем, атрибут) -- доступными (public) или "
"внутренними (non-public). Если вы сомневаетесь, делайте их внутренними. "
"Потом будет проще открыть к ним доступ, чем наоборот."

#: ../doc/1.10/dev_guide/python_style_guide.rst:750
msgid ""
"Public attributes are those that you expect unrelated clients of your "
"class to use, with your commitment to avoid backward incompatible "
"changes.  Non-public attributes are those that are not intended to be "
"used by third parties; you make no guarantees that non-public attributes "
"won't change or even be removed."
msgstr ""
"Доступные атрибуты -- это такие атрибуты, которые будут использовать "
"потребители ваших классов, и вы должны быть уверены в обратной "
"совместимости. Внутренние атрибуты, в свою очередь, не предназначены для "
"использования третьими лицами, поэтому вы можете не гарантировать, что не"
" измените или не удалите эти атрибуты."

#: ../doc/1.10/dev_guide/python_style_guide.rst:756
msgid ""
"We don't use the term \"private\" here, since no attribute is really "
"private in Python (without a generally unnecessary amount of work)."
msgstr ""
"Мы не используем термин \"закрытый\" (private), потому что на самом деле "
"в Python таких атрибутов не бывает (без ненужных дополнительных усилий)."

#: ../doc/1.10/dev_guide/python_style_guide.rst:759
msgid ""
"Another category of attributes are those that are part of the \"subclass "
"API\" (often called \"protected\" in other languages).  Some classes are "
"designed to be inherited from, either to extend or modify aspects of the "
"class's behavior.  When designing such a class, take care to make "
"explicit decisions about which attributes are public, which are part of "
"the subclass API, and which are truly only to be used by your base class."
msgstr ""
"Другой тип атрибутов классов принадлежит так называемому API подклассов "
"(в других языках они часто называются защищенными -- \"protected\"). "
"Некоторые классы предназначены для наследования другими классами, которые"
" расширяют или изменяют поведение базового класса. Когда вы проектируете "
"такой класс, решите и явным образом укажите, какие атрибуты являются "
"доступными (public), какие относятся к API подклассов (subclass API), а "
"какие используются только базовым классом."

#: ../doc/1.10/dev_guide/python_style_guide.rst:767
msgid "With this in mind, here are the Pythonic guidelines:"
msgstr "С учетом вышесказанного, сформулируем рекомендации:"

#: ../doc/1.10/dev_guide/python_style_guide.rst:769
msgid "Public attributes should have no leading underscores."
msgstr "В начале имени доступных атрибутов не должно быть символов подчеркивания."

#: ../doc/1.10/dev_guide/python_style_guide.rst:771
msgid ""
"If your public attribute name collides with a reserved keyword, append a "
"single trailing underscore to your attribute name.  This is preferable to"
" an abbreviation or corrupted spelling.  (However, not withstanding this "
"rule, 'cls' is the preferred spelling for any variable or argument which "
"is known to be a class, especially the first argument to a class method.)"
msgstr ""
"Если имя доступного атрибута конфликтует с ключевым словом языка, "
"добавьте в конец имени один символ подчеркивания. Это более "
"предпочтительно, чем сокращать слово или искажать его (однако, у этого "
"правила есть исключение: 'cls' -- это предпочтительное написание любой "
"переменной или аргумента, который означает класс, а особенно первого "
"аргумента метода класса)."

#: ../doc/1.10/dev_guide/python_style_guide.rst:779
#: ../doc/1.10/dev_guide/python_style_guide.rst:790
#: ../doc/1.10/dev_guide/python_style_guide.rst:812
msgid "Note 1:"
msgstr "Примечание 1:"

#: ../doc/1.10/dev_guide/python_style_guide.rst:779
msgid "See the argument name recommendation above for class methods."
msgstr "См. рекомендации по именам аргументов выше для методов класса."

#: ../doc/1.10/dev_guide/python_style_guide.rst:781
msgid ""
"For simple public data attributes, it is best to expose just the "
"attribute name, without complicated accessor/mutator methods.  Keep in "
"mind that Python provides an easy path to future enhancement, should you "
"find that a simple data attribute needs to grow functional behavior.  In "
"that case, use properties to hide functional implementation behind simple"
" data attribute access syntax."
msgstr ""
"Назовите простые открытые атрибуты понятными именами и не пишите сложные "
"методы доступа и изменения (accessor/mutator). Следует помнить, что в "
"Python очень легко расширить поведение функции, если потребуется. В этом "
"случае используйте свойства (properties), чтобы скрыть функциональную "
"реализацию за синтаксисом доступа к атрибутам."

#: ../doc/1.10/dev_guide/python_style_guide.rst:790
msgid "Properties only work on new-style classes."
msgstr "Свойства работают только в классах нового стиля (new-style classes)."

#: ../doc/1.10/dev_guide/python_style_guide.rst:794
#: ../doc/1.10/dev_guide/python_style_guide.rst:817
msgid "Note 2:"
msgstr "Примечание 2:"

#: ../doc/1.10/dev_guide/python_style_guide.rst:793
msgid ""
"Try to keep the functional behavior side-effect free, although side-"
"effects such as caching are generally fine."
msgstr ""
"Постарайтесь избавиться от побочных эффектов, связанных с функциональным "
"поведением, хотя такие вещи, как кэширование, вполне допустимы."

#: ../doc/1.10/dev_guide/python_style_guide.rst:799
#: ../doc/1.10/dev_guide/python_style_guide.rst:822
msgid "Note 3:"
msgstr "Примечание 3:"

#: ../doc/1.10/dev_guide/python_style_guide.rst:797
msgid ""
"Avoid using properties for computationally expensive operations; the "
"attribute notation makes the caller believe that access is (relatively) "
"cheap."
msgstr ""
"Избегайте использовать вычислительно затратные операции, потому что из-за"
" записи с помощью атрибутов создается впечатление, что доступ происходит "
"(относительно) быстро."

#: ../doc/1.10/dev_guide/python_style_guide.rst:801
msgid ""
"If your class is intended to be subclassed, and you have attributes that "
"you do not want subclasses to use, consider naming them with double "
"leading underscores and no trailing underscores.  This invokes Python's "
"name mangling algorithm, where the name of the class is mangled into the "
"attribute name.  This helps avoid attribute name collisions should "
"subclasses inadvertently contain attributes with the same name."
msgstr ""
"Если ваш класс предназначен для разделения на подклассы, но некоторые "
"атрибуты не должны наследоваться подклассами, подумайте о добавлении в "
"имена двух символов подчеркивания в начале и ни одного в конце. Механизм "
"изменения имен в Python сработает так, что имя класса добавится к имени "
"такого атрибута. Это позволит избежать конфликта имен, если в подклассах "
"случайно появятся атрибуты с такими же именами."

#: ../doc/1.10/dev_guide/python_style_guide.rst:810
msgid ""
"Note that only the simple class name is used in the mangled name, so if a"
" subclass chooses both the same class name and attribute name, you can "
"still get name collisions."
msgstr ""
"Обратите внимание, что только имена простых классов используются в "
"измененном имени, поэтому если в подклассе будет то же имя класса и имя "
"атрибута, то снова возникнет конфликт имен."

#: ../doc/1.10/dev_guide/python_style_guide.rst:815
msgid ""
"Name mangling can make certain uses, such as debugging and "
"``__getattr__()``, less convenient.  However the name mangling algorithm "
"is well documented and easy to perform manually."
msgstr ""
"Механизм изменения имен может затруднить отладку или работу с "
"``__getattr__()``. Тем не менее, алгоритм хорошо документирован и легко "
"реализуется вручную."

#: ../doc/1.10/dev_guide/python_style_guide.rst:820
msgid ""
"Not everyone likes name mangling.  Try to balance the need to avoid "
"accidental name clashes with potential use by advanced callers."
msgstr ""
"Не всем нравится механизм изменения имен. Постарайтесь достичь "
"компромисса между необходимостью избежать конфликта имен и возможностью "
"доступа к этим атрибутам."

#: ../doc/1.10/dev_guide/python_style_guide.rst:826
msgid "References"
msgstr "Использованная литература"

#: ../doc/1.10/dev_guide/python_style_guide.rst:828
msgid ""
"`PEP 7, Style Guide for C Code, van Rossum "
"<https://www.python.org/dev/peps/pep-0007/>`_"
msgstr ""
"ван Россум Гвидо. `PEP 7, Руководство по программированию на языке C "
"<https://www.python.org/dev/peps/pep-0007/>`_"

#: ../doc/1.10/dev_guide/python_style_guide.rst:829
msgid ""
"`Barry's GNU Mailman style guide "
"<http://barry.warsaw.us/software/STYLEGUIDE.txt>`_"
msgstr ""
"`Руководство Барри по GNU Mailman "
"<http://barry.warsaw.us/software/STYLEGUIDE.txt>`_"

#: ../doc/1.10/dev_guide/python_style_guide.rst:830
msgid "`CamelCase Wikipedia page <http://www.wikipedia.com/wiki/CamelCase>`_"
msgstr ""
"`Страница Википедии о CamelCase "
"<http://www.wikipedia.com/wiki/CamelCase>`_"

#: ../doc/1.10/dev_guide/python_style_guide.rst:834
msgid "Copyright"
msgstr "Защита авторских прав"

#: ../doc/1.10/dev_guide/python_style_guide.rst:836
msgid "Author:"
msgstr "Автор:"

#: ../doc/1.10/dev_guide/python_style_guide.rst:838
msgid "Guido van Rossum <guido@python.org>"
msgstr "Гвидо ван Россум <guido@python.org>"

#: ../doc/1.10/dev_guide/python_style_guide.rst:839
msgid "Barry Warsaw <barry@python.org>"
msgstr "Барри Ворсо <barry@python.org>"

#: ../doc/1.10/dev_guide/reference_capi/box.rst:37
#: ../doc/1.10/reference/reference_lua/box.rst:39
msgid "Module `box`"
msgstr "Модуль `box`"

#: ../doc/1.10/dev_guide/reference_capi/box.rst:41
msgid "Opaque structure passed to a C stored procedure"
msgstr "Непрозрачная структура, передаваемая в хранимую процедуру на языке C."

#: ../doc/1.10/dev_guide/reference_capi/box.rst:47
msgid "Return a tuple from a C stored procedure."
msgstr "Возврат кортежа с помощью хранимой процедуры на языке C."

#: ../doc/1.10/dev_guide/reference_capi/box.rst:49
msgid ""
"The returned tuple is automatically reference-counted by Tarantool. An "
"example program that uses ``box_return_tuple()`` is :ref:`write.c "
"<f_c_tutorial-write>`."
msgstr ""
"Для возвращаемого кортежа Tarantool проводит автоматический подсчет "
"ссылок. Пример программы, которая использует ``box_return_tuple()``: "
":ref:`write.c <f_c_tutorial-write>`."

#: ../doc/1.10/dev_guide/reference_capi/box.rst:53
msgid "an opaque structure passed to the C stored procedure by Tarantool"
msgstr ""
"непрозрачная структура, передаваемая Tarantool'ом в хранимую процедуру на"
" языке C"

#: ../doc/1.10/dev_guide/reference_capi/box.rst:55
msgid "a tuple to return"
msgstr "возвращаемый кортеж"

#: ../doc/1.10/dev_guide/reference_capi/box.rst
#: ../doc/1.10/dev_guide/reference_capi/box_index.rst
#: ../doc/1.10/dev_guide/reference_capi/coio.rst
#: ../doc/1.10/dev_guide/reference_capi/error.rst
#: ../doc/1.10/dev_guide/reference_capi/fiber.rst
#: ../doc/1.10/dev_guide/reference_capi/latch.rst
#: ../doc/1.10/dev_guide/reference_capi/tuple.rst
#: ../doc/1.10/dev_guide/reference_capi/txn.rst
#: ../doc/1.10/dev_guide/reference_capi/utils.rst
msgid "Returns"
msgstr "Возвращает"

#: ../doc/1.10/dev_guide/reference_capi/box.rst:57
msgid ""
"-1 on error (perhaps, out of memory; check :ref:`box_error_last()<c_api-"
"error-box_error_last>`)"
msgstr ""
"-1 в случае ошибки (возможная нехватка памяти; проверьте "
":ref:`box_error_last()<c_api-error-box_error_last>`)"

#: ../doc/1.10/dev_guide/reference_capi/box.rst:59
#: ../doc/1.10/dev_guide/reference_capi/box.rst:107
#: ../doc/1.10/dev_guide/reference_capi/box.rst:124
#: ../doc/1.10/dev_guide/reference_capi/box.rst:140
#: ../doc/1.10/dev_guide/reference_capi/box.rst:161
#: ../doc/1.10/dev_guide/reference_capi/box.rst:182
#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:99
#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:112
msgid "0 otherwise"
msgstr "0 в остальных случаях"

#: ../doc/1.10/dev_guide/reference_capi/box.rst:65
msgid "Find space id by name."
msgstr "Поиск идентификатора спейса по имени."

#: ../doc/1.10/dev_guide/reference_capi/box.rst:67
msgid "This function performs a SELECT request on the ``_vspace`` system space."
msgstr ""
"Данная функция делает запрос выборки SELECT из системного спейса "
"``_vspace``."

#: ../doc/1.10/dev_guide/reference_capi/box.rst:69
msgid "space name"
msgstr "имя спейса"

#: ../doc/1.10/dev_guide/reference_capi/box.rst:70
#: ../doc/1.10/dev_guide/reference_capi/box.rst:86
msgid "length of ``name``"
msgstr "длина имени ``name``"

#: ../doc/1.10/dev_guide/reference_capi/box.rst:72
#: ../doc/1.10/dev_guide/reference_capi/box.rst:88
msgid ""
":c:macro:`BOX_ID_NIL` on error or if not found (check "
":ref:`box_error_last()<c_api-error-box_error_last>`)"
msgstr ""
":c:macro:`BOX_ID_NIL` в случае ошибки или отсутствия (проверьте "
":ref:`box_error_last()<c_api-error-box_error_last>`)"

#: ../doc/1.10/dev_guide/reference_capi/box.rst:74
#: ../doc/1.10/dev_guide/reference_capi/box.rst:90
msgid "space_id otherwise"
msgstr "space_id в остальных случаях"

#: ../doc/1.10/dev_guide/reference_capi/box.rst:76
msgid "See also: :c:type:`box_index_id_by_name`"
msgstr "См. также :c:type:`box_index_id_by_name`"

#: ../doc/1.10/dev_guide/reference_capi/box.rst:80
msgid "Find index id by name."
msgstr "Поиск идентификатора индекса по имени."

#: ../doc/1.10/dev_guide/reference_capi/box.rst:82
msgid "This function performs a SELECT request on the ``_vindex`` system space."
msgstr ""
"Данная функция делает запрос выборки SELECT из системного спейса "
"``_vindex``."

#: ../doc/1.10/dev_guide/reference_capi/box.rst:84
#: ../doc/1.10/dev_guide/reference_capi/box.rst:100
#: ../doc/1.10/dev_guide/reference_capi/box.rst:117
#: ../doc/1.10/dev_guide/reference_capi/box.rst:132
#: ../doc/1.10/dev_guide/reference_capi/box.rst:148
#: ../doc/1.10/dev_guide/reference_capi/box.rst:169
#: ../doc/1.10/dev_guide/reference_capi/box.rst:190
#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:119
#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:163
#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:173
#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:183
#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:202
#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:218
#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:234
#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:250
#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:268
msgid "space identifier"
msgstr "идентификатор спейса"

#: ../doc/1.10/dev_guide/reference_capi/box.rst:85
msgid "index name"
msgstr "имя индекса"

#: ../doc/1.10/dev_guide/reference_capi/box.rst:92
msgid "See also: :c:type:`box_space_id_by_name`"
msgstr "См. также :c:type:`box_space_id_by_name`"

#: ../doc/1.10/dev_guide/reference_capi/box.rst:98
msgid "Execute an INSERT/REPLACE request."
msgstr "Выполнение запроса вставки или замены (INSERT/REPLACE)."

#: ../doc/1.10/dev_guide/reference_capi/box.rst:101
#: ../doc/1.10/dev_guide/reference_capi/box.rst:118
#: ../doc/1.10/dev_guide/reference_capi/box.rst:171
msgid "encoded tuple in MsgPack Array format ([ field1, field2, ...])"
msgstr "закодированный кортеж в формате MsgPack-массива ([ field1, field2, ...])"

#: ../doc/1.10/dev_guide/reference_capi/box.rst:102
#: ../doc/1.10/dev_guide/reference_capi/box.rst:119
#: ../doc/1.10/dev_guide/reference_capi/box.rst:172
msgid "end of a ``tuple``"
msgstr "конец кортежа ``tuple``"

#: ../doc/1.10/dev_guide/reference_capi/box.rst:103
#: ../doc/1.10/dev_guide/reference_capi/box.rst:120
msgid "output argument. Resulting tuple. Can be set to NULL to discard result"
msgstr ""
"аргумент вывода. Возвращаемый кортеж. Можно задать значение NULL для "
"сброса результата"

#: ../doc/1.10/dev_guide/reference_capi/box.rst:106
#: ../doc/1.10/dev_guide/reference_capi/box.rst:123
#: ../doc/1.10/dev_guide/reference_capi/box.rst:139
#: ../doc/1.10/dev_guide/reference_capi/box.rst:160
msgid "-1 on error (check :ref:`box_error_last()<c_api-error-box_error_last>`)"
msgstr ""
"-1 в случае ошибки (проверьте :ref:`box_error_last()<c_api-error-"
"box_error_last>`)"

#: ../doc/1.10/dev_guide/reference_capi/box.rst:109
msgid "See also :ref:`space_object.insert()<box_space-insert>`"
msgstr "См. также :ref:`space_object.insert()<box_space-insert>`"

#: ../doc/1.10/dev_guide/reference_capi/box.rst:115
msgid "Execute a REPLACE request."
msgstr "Выполнение запроса замены (REPLACE)."

#: ../doc/1.10/dev_guide/reference_capi/box.rst:126
msgid "See also :ref:`space_object.replace()<box_space-replace>`"
msgstr "См. также :ref:`space_object.replace()<box_space-replace>`"

#: ../doc/1.10/dev_guide/reference_capi/box.rst:130
msgid "Execute a DELETE request."
msgstr "Выполнение запроса удаления (DELETE)."

#: ../doc/1.10/dev_guide/reference_capi/box.rst:133
#: ../doc/1.10/dev_guide/reference_capi/box.rst:149
#: ../doc/1.10/dev_guide/reference_capi/box.rst:170
#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:120
#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:164
#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:174
#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:184
#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:203
#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:219
#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:235
#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:251
#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:269
msgid "index identifier"
msgstr "идентификатор индекса"

#: ../doc/1.10/dev_guide/reference_capi/box.rst:134
#: ../doc/1.10/dev_guide/reference_capi/box.rst:150
msgid "encoded key in MsgPack Array format ([ field1, field2, ...])"
msgstr "закодированный ключ в формате MsgPack-массива ([ field1, field2, ...])"

#: ../doc/1.10/dev_guide/reference_capi/box.rst:135
#: ../doc/1.10/dev_guide/reference_capi/box.rst:151
msgid "end of a ``key``"
msgstr "конец ключа ``key``"

#: ../doc/1.10/dev_guide/reference_capi/box.rst:136
#: ../doc/1.10/dev_guide/reference_capi/box.rst:157
#: ../doc/1.10/dev_guide/reference_capi/box.rst:178
msgid "output argument. An old tuple. Can be set to NULL to discard result"
msgstr ""
"аргумент вывода. Старый кортеж. Можно задать значение NULL для сброса "
"результата"

#: ../doc/1.10/dev_guide/reference_capi/box.rst:142
msgid "See also :ref:`space_object.delete()<box_space-delete>`"
msgstr "См. также :ref:`space_object.delete()<box_space-delete>`"

#: ../doc/1.10/dev_guide/reference_capi/box.rst:146
msgid "Execute an UPDATE request."
msgstr "Выполнение запроса обновления (UPDATE)."

#: ../doc/1.10/dev_guide/reference_capi/box.rst:152
#: ../doc/1.10/dev_guide/reference_capi/box.rst:173
msgid ""
"encoded operations in MsgPack Array format, e.g. ``[[ '=', field_id,  "
"value ], ['!', 2, 'xxx']]``"
msgstr ""
"закодированные операции в формате MsgPack-массива, например ``[[ '=', "
"field_id, value ], ['!', 2, 'xxx']]``"

#: ../doc/1.10/dev_guide/reference_capi/box.rst:154
msgid "end of an ``ops`` section"
msgstr "конец раздела операций ``ops``"

#: ../doc/1.10/dev_guide/reference_capi/box.rst:155
#: ../doc/1.10/dev_guide/reference_capi/box.rst:176
msgid ""
"0 if field_ids are zero-based as in C, 1 if field ids are 1-based as in "
"Lua"
msgstr ""
"0, если идентификаторы полей field_id с основанием 0, как в C, 1, если "
"идентификаторы полей с основанием 1, как в Lua"

#: ../doc/1.10/dev_guide/reference_capi/box.rst:163
msgid "See also :ref:`space_object.update()<box_space-update>`"
msgstr "См. также :ref:`space_object.update()<box_space-update>`"

#: ../doc/1.10/dev_guide/reference_capi/box.rst:167
msgid "Execute an UPSERT request."
msgstr "Выполнение запроса обновления и вставки (UPSERT)."

#: ../doc/1.10/dev_guide/reference_capi/box.rst:175
msgid "end of a ``ops``"
msgstr "конец операций ``ops``"

#: ../doc/1.10/dev_guide/reference_capi/box.rst:181
msgid "-1 on error (check ::ref:`box_error_last()<c_api-error-box_error_last>`)"
msgstr ""
"-1 в случае ошибки (проверьте :ref:`box_error_last()<c_api-error-"
"box_error_last>`)"

#: ../doc/1.10/dev_guide/reference_capi/box.rst:184
msgid "See also :ref:`space_object.upsert()<box_space-upsert>`"
msgstr "См. также :ref:`space_object.upsert()<box_space-upsert>`"

#: ../doc/1.10/dev_guide/reference_capi/box.rst:188
msgid "Truncate a space."
msgstr "Очистка спейса."

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:37
msgid "Module `index`"
msgstr "Модуль `index`"

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:41
msgid "A space iterator"
msgstr "Итератор спейса"

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:47
msgid ""
"Controls how to iterate over tuples in an index. Different index types "
"support different iterator types. For example, one can start iteration "
"from a particular value (request key) and then retrieve all tuples where "
"keys are greater or equal (= GE) to this key."
msgstr ""
"Управление итерацией кортежей в индексе. Различные типы индексов "
"поддерживают различные типы итераторов. Например, можно начать итерацию с"
" определенного значения (ключ запроса), а затем получить все кортежи, "
"ключи которых больше или равны (= GE) заданному ключу."

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:52
msgid ""
"If iterator type is not supported by the selected index type, iterator "
"constructor must fail with ER_UNSUPPORTED. To be selectable for primary "
"key, an index must support at least ITER_EQ and ITER_GE types."
msgstr ""
"Если тип итератора не поддерживается выбранным типом индекса, конструктор"
" итератора прекратит работу с ошибкой ER_UNSUPPORTED. Чтобы индекс можно "
"было выбрать для первичного ключа, он должен поддерживать типы ITER_EQ и "
"ITER_GE."

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:56
msgid ""
"NULL value of request key corresponds to the first or last key in the "
"index, depending on iteration direction. (first key for GE and GT types, "
"and last key for LE and LT). Therefore, to iterate over all tuples in an "
"index, one can use ITER_GE or ITER_LE iteration types with start key "
"equal to NULL. For ITER_EQ, the key must not be NULL."
msgstr ""
"Значение ключа запроса NULL соответствует первому или последнему ключу в "
"индексе, в зависимости от направления итерации (первый ключ для типов GE "
"и GT, последний ключ для типов LE и LT). Таким образом, для итерации по "
"всем кортежам в индексе можно использовать типы итерации ITER_GE или "
"ITER_LE с начальным ключом, который равен NULL. Для ITER_EQ ключ не "
"должен равняться NULL."

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:64
msgid "key == x ASC order"
msgstr "ключ == x в порядке возрастания"

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:68
msgid "key == x DESC order"
msgstr "ключ == x в порядке убывания"

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:72
msgid "all tuples"
msgstr "все кортежи"

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:76
msgid "key < x"
msgstr "ключ < x"

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:80
msgid "key <= x"
msgstr "ключ <= x"

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:84
msgid "key >= x"
msgstr "ключ >= x"

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:88
msgid "key > x"
msgstr "ключ > x"

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:92
msgid "all bits from x are set in key"
msgstr "все биты из x заданы в ключе"

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:96
msgid "at least one x's bit is set"
msgstr "задан хотя бы один бит из x"

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:100
msgid "all bits are not set"
msgstr "ни один бит не задан"

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:104
msgid "key overlaps x"
msgstr "ключ пересекается с x"

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:108
msgid "tuples in distance ascending order from specified point"
msgstr "кортежи в порядке возрастания расстояния из указанной точки"

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:114
msgid "Allocate and initialize iterator for space_id, index_id."
msgstr "Выделение и инициализация итератора для space_id, index_id."

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:116
msgid ""
"The returned iterator must be destroyed by :ref:`box_iterator_free<c_api-"
"box_index-box_iterator_free>`."
msgstr ""
"Возвращаемый итератор следует удалить с помощью :ref:`box_iterator_free"
"<c_api-box_index-box_iterator_free>`."

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:121
#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:252
msgid ":ref:`iterator_type<c_api-box_index-iterator_type>`"
msgstr ":ref:`iterator_type<c_api-box_index-iterator_type>`"

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:122
#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:204
#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:220
#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:236
#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:253
msgid "encode key in MsgPack Array format ([part1, part2, ...])"
msgstr "кодировка ключа в формате MsgPack-массива ([part1, part2, ...])"

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:123
#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:205
#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:221
#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:237
#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:254
msgid "the end of encoded ``key``"
msgstr "часть закодированного ключа ``key``"

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:125
msgid "NULL on error (check :ref:`box_error_last <c_api-error-box_error_last>`)"
msgstr ""
"NULL в случае ошибки (проверьте :ref:`box_error_last()<c_api-error-"
"box_error_last>`)"

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:126
msgid "iterator otherwise"
msgstr "итератор в остальных случаях"

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:128
msgid ""
"See also :ref:`box_iterator_next<c_api-box_index-box_iterator_next>`, "
":ref:`box_iterator_free<c_api-box_index-box_iterator_free>`"
msgstr ""
"См. также :ref:`box_iterator_next<c_api-box_index-box_iterator_next>`, "
":ref:`box_iterator_free<c_api-box_index-box_iterator_free>`"

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:135
msgid "Retrieve the next item from the ``iterator``."
msgstr "Получение следующего пункта из итератора ``iterator``."

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:137
#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:151
msgid ""
"an iterator returned by :ref:`box_index_iterator <c_api-box_index-"
"box_index_iterator>`"
msgstr ""
"итератор, возвращаемый :ref:`box_index_iterator <c_api-box_index-"
"box_index_iterator>`"

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:139
msgid "output argument. result a tuple or NULL if there is no more data."
msgstr ""
"аргумент вывода. Результатом будет кортеж или NULL, если данных больше "
"нет."

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:142
#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:166
#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:176
#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:209
msgid "-1 on error (check :ref:`box_error_last <c_api-error-box_error_last>`)"
msgstr ""
"-1 в случае ошибки (проверьте :ref:`box_error_last()<c_api-error-"
"box_error_last>`)"

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:143
msgid "0 on success. The end of data is not an error."
msgstr "0 в случае выполнения. Отсутствие данных не является ошибкой."

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:149
msgid "Destroy and deallocate iterator."
msgstr "Удаление и освобождение итератора."

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:156
msgid ""
"Determine a direction of the given iterator type: -1 for REQ, LT, LE, and"
" +1 for all others."
msgstr ""
"Определение направления заданного типа итератора: -1 для REQ, LT, LE, и "
"+1 для всех остальных."

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:161
msgid "Return the number of element in the index."
msgstr "Возврат номера элемента в индексе."

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:167
#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:177
msgid ">= 0 otherwise"
msgstr ">= 0 в остальных случаях"

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:171
msgid "Return the number of bytes used in memory by the index."
msgstr "Возврат количества байтов памяти, используемых индексом."

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:181
msgid "Return a random tuple from the index (useful for statistical analysis)."
msgstr ""
"Возврат случайного кортежа из индекса (используется для статистического "
"анализа)."

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:185
msgid "random seed"
msgstr "случайное начальное число"

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:186
#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:206
#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:222
#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:238
msgid "output argument. result a tuple or NULL if there is no tuples in space"
msgstr ""
"аргумент вывода. Результатом будет кортеж или NULL, если в спейсе нет "
"кортежей."

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:189
msgid "See also: :ref:`index_object.random<box_index-random>`"
msgstr "См. также :ref:`index_object.random<box_index-random>`"

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:195
msgid "Get a tuple from index by the key."
msgstr "Получение кортежа из индекса по ключу."

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:197
msgid ""
"Please note that this function works much more faster than "
":ref:`index_object.select<box_index-select>` or :ref:`box_index_iterator"
"<c_api-box_index-box_index_iterator>` + :ref:`box_iterator_next<c_api-"
"box_index-box_iterator_next>`."
msgstr ""
"Следует отметить, что данная функция работает намного быстрее, чем "
":ref:`index_object.select<box_index-select>` или :ref:`box_index_iterator"
"<c_api-box_index-box_index_iterator>` + :ref:`box_iterator_next<c_api-"
"box_index-box_iterator_next>`."

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:210
#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:226
#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:242
#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:257
#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:206
#: ../doc/1.10/dev_guide/reference_capi/txn.rst:52
#: ../doc/1.10/dev_guide/reference_capi/txn.rst:61
#: ../doc/1.10/dev_guide/reference_capi/utils.rst:99
msgid "0 on success"
msgstr "0, если выполнено"

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:212
msgid "See also: ``index_object.get()``"
msgstr "См. также ``index_object.get()``"

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:216
msgid "Return a first (minimal) tuple matched the provided key."
msgstr ""
"Возврат первого (минимального) кортежа, который соответствует заданному "
"ключу."

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:225
#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:241
#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:256
msgid "-1 on error (check :ref:`box_error_last() <c_api-error-box_error_last>`)"
msgstr ""
"-1 в случае ошибки (проверьте :ref:`box_error_last()<c_api-error-"
"box_error_last>`)"

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:228
msgid "See also: :ref:`index_object.min()<box_index-min>`"
msgstr "См. также :ref:`index_object.min()<box_index-min>`"

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:232
msgid "Return a last (maximal) tuple matched the provided key."
msgstr ""
"Возврат последнего (максимального) кортежа, который соответствует "
"заданному ключу."

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:244
msgid "See also: :ref:`index_object.max()<box_index-max>`"
msgstr "См. также :ref:`index_object.max()<box_index-max>`"

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:248
msgid "Count the number of tuple matched the provided key."
msgstr "Подсчет количества кортежей, которые соответствуют заданному ключу."

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:259
msgid "See also: :ref:`index_object.count()<box_index-count>`"
msgstr "См. также :ref:`index_object.count()<box_index-count>`"

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:264
msgid "Return :ref:`key definition <capi-tuple_key_def>` for an index"
msgstr "Возврат :ref:`определения ключа <capi-tuple_key_def>` для индекса"

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:266
msgid "Returned object is valid until the next yield."
msgstr "Возвращаемый объект действителен до следующей передачи управления."

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:271
#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:203
msgid "key definition on success"
msgstr "определение ключа, если выполнено"

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:272
#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:204
#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:222
msgid "NULL on error"
msgstr "NULL в случае ошибки"

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:274
msgid "See also: :ref:`box_tuple_compare() <capi-tuple_box_tuple_compare>`,"
msgstr "См. также :ref:`box_tuple_compare() <capi-tuple_box_tuple_compare>`,"

#: ../doc/1.10/dev_guide/reference_capi/box_index.rst:275
msgid ":ref:`box_tuple_format_new() <capi-tuple_box_tuple_format_new>`"
msgstr ":ref:`box_tuple_format_new() <capi-tuple_box_tuple_format_new>`"

#: ../doc/1.10/dev_guide/reference_capi/clock.rst:37
#: ../doc/1.10/reference/reference_lua/clock.rst:39
msgid "Module `clock`"
msgstr "Модуль `clock`"

#: ../doc/1.10/dev_guide/reference_capi/coio.rst:37
msgid "Module `coio`"
msgstr "Модуль `coio`"

#: ../doc/1.10/dev_guide/reference_capi/coio.rst:43
msgid "READ event"
msgstr "событие чтения READ"

#: ../doc/1.10/dev_guide/reference_capi/coio.rst:47
msgid "WRITE event"
msgstr "событие записи WRITE"

#: ../doc/1.10/dev_guide/reference_capi/coio.rst:53
msgid "Wait until READ or WRITE event on socket (``fd``). Yields."
msgstr ""
"Ожидание события чтения или записи (READ / WRITE) на сокете (``fd``) с "
"передачей управления."

#: ../doc/1.10/dev_guide/reference_capi/coio.rst:55
#: ../doc/1.10/dev_guide/reference_capi/coio.rst:104
msgid "non-blocking socket file description"
msgstr "дескриптор файла сокета без блокировки"

#: ../doc/1.10/dev_guide/reference_capi/coio.rst:56
msgid ""
"requested events to wait. Combination of ``COIO_READ | COIO_WRITE`` bit "
"flags."
msgstr ""
"запрашиваемые события. Комбинация битовых флагов ``COIO_READ | "
"COIO_WRITE``."

#: ../doc/1.10/dev_guide/reference_capi/coio.rst:58
msgid "timeout in seconds."
msgstr "время ожидания в секундах."

#: ../doc/1.10/dev_guide/reference_capi/coio.rst:60
msgid "0 - timeout"
msgstr "0 - время ожидания"

#: ../doc/1.10/dev_guide/reference_capi/coio.rst:61
msgid ""
">0 - returned events. Combination of ``TNT_IO_READ | TNT_IO_WRITE`` bit "
"flags."
msgstr ""
">0 - возвращаемые события. Комбинация битовых флагов ``TNT_IO_READ | "
"TNT_IO_WRITE``."

#: ../doc/1.10/dev_guide/reference_capi/coio.rst:67
msgid ""
"Create new eio task with specified function and arguments. Yield and wait"
" until the task is complete or a timeout occurs. This function may use "
"the :ref:`worker_pool_threads <cfg_basic-worker_pool_threads>` "
"configuration parameter."
msgstr ""
"Создание новой задачи ошибочного ввода-вывода (eio) с указанной функцией "
"и аргументами. Передает управление и ожидает окончания задачи или "
"истечения времени ожидания. Функция может использовать конфигурационный "
"параметр :ref:`worker_pool_threads <cfg_basic-worker_pool_threads>`."

#: ../doc/1.10/dev_guide/reference_capi/coio.rst:72
msgid ""
"To avoid double error checking, this function does not throw exceptions. "
"In most cases it is also necessary to check the return value of the "
"called function and perform necessary actions. If func sets errno, the "
"errno is preserved across the call."
msgstr ""
"Во избежание двойной проверки ошибок функция не выбрасывает исключения. В"
" большинстве случаев также необходимо проверять возвращаемое значение "
"вызванной функции и выполнить необходимые действия. Если функция "
"определяет номер ошибки errno, этот номер ошибки сохраняется в течение "
"вызова."

#: ../doc/1.10/dev_guide/reference_capi/coio.rst:77
msgid "-1 and ``errno`` = ENOMEM if failed to create a task"
msgstr "-1 и ``errno`` = ENOMEM, если задача не была создана"

#: ../doc/1.10/dev_guide/reference_capi/coio.rst:78
msgid "the function return (``errno`` is preserved)."
msgstr "возврат функции (``errno`` сохраняется)."

#: ../doc/1.10/dev_guide/reference_capi/coio.rst:82
msgid ""
"static ssize_t openfile_cb(va_list ap)\n"
"{\n"
"        const char* filename = va_arg(ap);\n"
"        int flags = va_arg(ap);\n"
"        return open(filename, flags);\n"
"}\n"
"\n"
"if (coio_call(openfile_cb, 0.10, \"/tmp/file\", 0) == -1)\n"
"    // handle errors.\n"
"..."
msgstr ""
"static ssize_t openfile_cb(va_list ap)\n"
" {\n"
"         const char* filename = va_arg(ap);\n"
"         int flags = va_arg(ap);\n"
"         return open(filename, flags);\n"
" }\n"
" \n"
" if (coio_call(openfile_cb, 0.10, \"/tmp/file\", 0) == -1)\n"
"     // обработка ошибок.\n"
" ..."

#: ../doc/1.10/dev_guide/reference_capi/coio.rst:97
msgid "Fiber-friendly version of :manpage:`getaddrinfo(3)`."
msgstr "Версия :manpage:`getaddrinfo(3)` для файбера."

#: ../doc/1.10/dev_guide/reference_capi/coio.rst:101
msgid ""
"Close the ``fd`` and wake any fiber blocked in :ref:`coio_wait() <c_api-"
"coio-coio_wait>` call on this ``fd``."
msgstr ""
"Закрытие ``fd`` и пробуждение любого файбера, заблокированного в вызове "
":ref:`coio_wait() <c_api-coio-coio_wait>` на данном сокете ``fd``."

#: ../doc/1.10/dev_guide/reference_capi/coio.rst:106
msgid "the result of ``close(fd)``, see :manpage:`close(2)`"
msgstr "результат ``close(fd)``, см. :manpage:`close(2)`"

#: ../doc/1.10/dev_guide/reference_capi/error.rst:37
msgid "Module `error`"
msgstr "Модуль `error`"

#: ../doc/1.10/dev_guide/reference_capi/error.rst:187
msgid "Error - contains information about error."
msgstr "Ошибка -- содержит информацию об ошибке."

#: ../doc/1.10/dev_guide/reference_capi/error.rst:191
msgid "Return the error type, e.g. \"ClientError\", \"SocketError\", etc."
msgstr "Возврат типа ошибки, например, \"ClientError\", \"SocketError\" и т.д."

#: ../doc/1.10/dev_guide/reference_capi/error.rst:193
#: ../doc/1.10/dev_guide/reference_capi/error.rst:200
#: ../doc/1.10/dev_guide/reference_capi/error.rst:207
msgid "error"
msgstr "ошибка"

#: ../doc/1.10/dev_guide/reference_capi/error.rst:194
#: ../doc/1.10/dev_guide/reference_capi/error.rst:208
msgid "not-null string"
msgstr "ненулевая строка"

#: ../doc/1.10/dev_guide/reference_capi/error.rst:198
msgid "Return IPROTO error code"
msgstr "Возврат кода ошибки IPROTO"

#: ../doc/1.10/dev_guide/reference_capi/error.rst:201
msgid "enum :ref:`box_error_code <capi-box_error_code>`"
msgstr "enum :ref:`box_error_code <capi-box_error_code>`"

#: ../doc/1.10/dev_guide/reference_capi/error.rst:205
msgid "Return the error message"
msgstr "Возврат сообщения ошибки"

#: ../doc/1.10/dev_guide/reference_capi/error.rst:214
msgid "Get the information about the last API call error."
msgstr "Получение информации о последней ошибке вызова API."

#: ../doc/1.10/dev_guide/reference_capi/error.rst:216
msgid ""
"The Tarantool error handling works most like libc's errno. All API calls "
"return -1 or NULL in the event of error. An internal pointer to "
"box_error_t type is set by API functions to indicate what went wrong. "
"This value is only significant if API call failed (returned -1 or NULL)."
msgstr ""
"Обработка ошибок в Tarantool'е больше всего похожа на errno в стандартной"
" библиотеке языка С libc. Все вызовы API возвращают -1 или NULL в случае "
"ошибки. Внутренний указатель на тип box_error_t задается функциями, чтобы"
" указать, что пошло не так. Это значение показательно, если вызов API не "
"прошел (вернулось -1 или NULL)."

#: ../doc/1.10/dev_guide/reference_capi/error.rst:221
msgid ""
"Successful function can also touch the last error in some cases. You "
"don't have to clear the last error before calling API functions. The "
"returned object is valid only until next call to **any** API function."
msgstr ""
"Выполненная функция в некоторых случаях также может затрагивать последнюю"
" ошибку. Необязательно удалять последнюю ошибку перед вызовом "
"API-функций. Возвращаемый объект применим только до следующего вызова "
"**любой** API-функции."

#: ../doc/1.10/dev_guide/reference_capi/error.rst:225
msgid ""
"You must set the last error using box_error_set() in your stored C "
"procedures if you want to return a custom error message. You can re-throw"
" the last API error to IPROTO client by keeping the current value and "
"returning -1 to Tarantool from your stored procedure."
msgstr ""
"Следует задать последнюю ошибку с помощью box_error_set() из хранимых "
"процедур на языке C, если необходимо вернуть специальное сообщение об "
"ошибке. Можно повторно сгенерировать последнюю API-ошибку в клиент "
"IPROTO, сохранив текущее значение и вернув -1 to Tarantool из хранимой "
"процедуры."

#: ../doc/1.10/dev_guide/reference_capi/error.rst:230
msgid "last error"
msgstr "последняя ошибка"

#: ../doc/1.10/dev_guide/reference_capi/error.rst:234
msgid "Clear the last error."
msgstr "Удаление последней ошибки."

#: ../doc/1.10/dev_guide/reference_capi/error.rst:238
msgid "Set the last error."
msgstr "Определение последней ошибки."

#: ../doc/1.10/dev_guide/reference_capi/error.rst:242
msgid "IPROTO :ref:`error code<capi-box_error_code>`"
msgstr "IPROTO :ref:`error code<capi-box_error_code>`"

#: ../doc/1.10/dev_guide/reference_capi/error.rst:244
#: ../doc/1.10/dev_guide/reference_capi/say.rst:67
#: ../doc/1.10/dev_guide/reference_capi/say.rst:82
msgid "format arguments"
msgstr "аргументы формата"

#: ../doc/1.10/dev_guide/reference_capi/error.rst:246
msgid "See also: IPROTO :ref:`error code<capi-box_error_code>`"
msgstr "См. также IPROTO :ref:`error code<capi-box_error_code>`"

#: ../doc/1.10/dev_guide/reference_capi/error.rst:250
msgid "A backward-compatible API define."
msgstr "Обратно совместимые определения API."

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:37
#: ../doc/1.10/reference/reference_lua/fiber.rst:39
msgid "Module `fiber`"
msgstr "Модуль `fiber`"

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:41
msgid ""
"Fiber - contains information about a :ref:`fiber <atomic-"
"threads_fibers_yields>`."
msgstr ""
"Файбер -- содержит информацию о :ref:`файбере <atomic-"
"threads_fibers_yields>`."

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:45
msgid "Function to run inside a fiber."
msgstr "Функции для выполнения в файбере."

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:49
msgid "Create a new fiber."
msgstr "Создание нового файбера."

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:51
msgid ""
"Takes a fiber from the fiber cache, if it's not empty. Can fail only if "
"there is not enough memory for the fiber structure or fiber stack."
msgstr ""
"Берет файбер из кэша файберов, если в нем что-то есть. Может не "
"сработать, только если недостаточно памяти для структуры файбера или "
"стека файбера."

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:54
msgid ""
"The created fiber automatically returns itself to the fiber cache when "
"its \"main\" function completes."
msgstr ""
"Созданный файбер автоматически возвращается в кэш файберов, когда "
"выполнена его основная функция."

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:57
#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:73
msgid "string with fiber name"
msgstr "строка с именем файбера"

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:58
msgid "func for run inside fiber"
msgstr "функция для выполнения в файбере"

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:60
#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:77
msgid "See also: :ref:`fiber_start()<c_api-fiber-fiber_start>`"
msgstr "См. также :ref:`fiber_start()<c_api-fiber-fiber_start>`"

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:64
msgid "Create a new fiber with defined attributes."
msgstr "Создание нового файбера с заданными атрибутами."

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:66
msgid ""
"Can fail only if there is not enough memory for the fiber structure or "
"fiber stack."
msgstr ""
"Может не сработать, только если недостаточно памяти для структуры файбера"
" или стека файбера."

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:69
msgid ""
"The created fiber automatically returns itself to the fiber cache if has "
"a default stack size when its \"main\" function completes."
msgstr ""
"Созданный файбер автоматически возвращается в кэш файберов, если у него "
"размер стека по умолчанию, когда выполнена его основная функция."

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:74
#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:197
#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:203
msgid "fiber attributes container"
msgstr "контейнер с атрибутами файбера"

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:75
msgid "function to run inside the fiber"
msgstr "функция для выполнения в файбере"

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:83
msgid "Start execution of created fiber."
msgstr "Запуск созданного файбера."

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:85
msgid "fiber to start"
msgstr "запускаемый файбер"

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:86
msgid "arguments to start the fiber with"
msgstr "аргументы для запуска файбера"

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:90
msgid "Return control to another fiber and wait until it'll be woken."
msgstr "Передача управления другому файберу и ожидание его пробуждения."

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:92
msgid "See also: :ref:`fiber_wakeup()<c_api-fiber-fiber_wakeup>`"
msgstr "См. также :ref:`fiber_wakeup()<c_api-fiber-fiber_wakeup>`"

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:98
msgid "Interrupt a synchronous wait of a fiber"
msgstr "Прерывание синхронного ожидания файбера"

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:100
#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:138
msgid "fiber to be woken up"
msgstr "пробуждаемый файбер"

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:106
msgid "Cancel the subject fiber (set ``FIBER_IS_CANCELLED`` flag)"
msgstr "Отмена файбера (установка флага ``FIBER_IS_CANCELLED``)"

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:108
msgid ""
"If target fiber's flag ``FIBER_IS_CANCELLABLE`` set, then it would be "
"woken up (maybe prematurely). Then current fiber yields until the target "
"fiber is dead (or is woken up by :ref:`fiber_wakeup()<c_api-fiber-"
"fiber_wakeup>`)."
msgstr ""
"Если на нужном файбере установлен флаг ``FIBER_IS_CANCELLABLE``, он "
"возобновит работу (возможно досрочно). Тогда текущий файбер передает "
"управление до тех пор, пока нужный файбер не будет удален (или не "
"возобновит работу с помощью :ref:`fiber_wakeup()<c_api-fiber-"
"fiber_wakeup>`)."

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:112
msgid "fiber to be cancelled"
msgstr "отменяемый файбер"

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:116
msgid ""
"Make it possible or not possible to wakeup the current fiber immediately "
"when it's cancelled."
msgstr ""
"Возможность или невозможность пробуждения текущего файбера сразу после "
"его отмены."

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:119
#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:130
msgid "fiber"
msgstr "файбер"

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:120
#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:131
msgid "status to set"
msgstr "назначаемый статус"

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:122
msgid "previous state"
msgstr "предыдущий статус"

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:128
msgid "Set fiber to be joinable (``false`` by default)."
msgstr "Определение файбера как присоединяемого (по умолчанию ``false``)"

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:135
msgid ""
"Wait until the fiber is dead and then move its execution status to the "
"caller. The fiber must not be detached."
msgstr ""
"Ожидание удаления файбера, а затем передача статуса его выполнения "
"вызывающему клиенту. Файбер не должен быть открепленным."

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:140
msgid "Before: ``FIBER_IS_JOINABLE`` flag is set."
msgstr "Ранее: установлен флаг ``FIBER_IS_JOINABLE``."

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:142
msgid "See also: :ref:`fiber_set_joinable()<c_api-fiber-fiber_set_joinable>`"
msgstr "См. также :ref:`fiber_set_joinable()<c_api-fiber-fiber_set_joinable>`"

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:146
msgid "Put the current fiber to sleep for at least 's' seconds."
msgstr "Перевод текущего файбера в режим ожидания как минимум на 's' секунд."

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:148
msgid "time to sleep"
msgstr "время ожидания"

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:150
msgid "Note: this is a cancellation point."
msgstr "Примечание: это и есть точка отмены."

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:152
msgid "See also: :ref:`fiber_is_cancelled()<c_api-fiber-fiber_is_cancelled>`"
msgstr "См. также :ref:`fiber_is_cancelled()<c_api-fiber-fiber_is_cancelled>`"

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:158
msgid "Check current fiber for cancellation (it must be checked manually)."
msgstr "Проверка отмены текущего файбера (это делается вручную)."

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:162
msgid "Report loop begin time as double (cheap)."
msgstr "Сообщение времени начала цикла в виде числа двойной точности."

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:166
msgid "Report loop begin time as 64-bit int."
msgstr "Сообщение времени начала цикла в виде 64-битного целого числа."

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:170
msgid "Reschedule fiber to end of event loop cycle."
msgstr "Перенос файбера для завершения событийного цикла."

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:176
msgid "Return ``slab_cache`` suitable to use with ``tarantool/small`` library"
msgstr ""
"Возврат ``slab_cache``, подходящего для использования с библиотекой "
"``tarantool/small``"

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:180
msgid "Return the current fiber."
msgstr "Возврат текущего файбера."

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:186
msgid ""
"Create a new fiber attributes container and initialize it with default "
"parameters."
msgstr ""
"Создание нового контейнера с атрибутами файбера и его инициализация с "
"параметрами по умолчанию."

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:189
msgid ""
"Can be used for creating many fibers: corresponding fibers will not take "
"ownership."
msgstr ""
"Можно использовать для создания множества файберов: смена владельца не "
"произойдет."

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:194
msgid ""
"Delete the ``fiber_attr`` and free all allocated resources. This is safe "
"when fibers created with this attribute still exist."
msgstr ""
"Удаление ``fiber_attr`` и освобождение всех выделенных ресурсов. "
"Используется, когда есть файберы, созданные с данным атрибутом."

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:201
msgid "Set the fiber's stack size in the fiber attributes container."
msgstr "Определение размера стека файбера в контейнере с атрибутами файбера."

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:204
msgid "stack size for new fibers (in bytes)"
msgstr "размер стека для новых файберов (в байтах)"

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:207
msgid ""
"-1 on failure (if ``stack_size`` is smaller than the minimum allowable "
"fiber stack size)"
msgstr ""
"-1, если не выполнено (если размер стека ``stack_size`` меньше минимально"
" допустимого размера стека файбера)"

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:212
msgid "Get the fiber's stack size from the fiber attributes container."
msgstr "Получение размера стека файбера из контейнера с атрибутами файбера."

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:214
msgid "fiber attributes container, or NULL for default"
msgstr "контейнер с атрибутами файбера или NULL, по умолчанию"

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:217
msgid "stack size (in bytes)"
msgstr "размер стека (в байтах)"

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:223
msgid ""
"A conditional variable: a synchronization primitive that allow fibers in "
"Tarantool's :ref:`cooperative multitasking <atomic-"
"cooperative_multitasking>` environment to yield until some predicate is "
"satisfied."
msgstr ""
"Условная переменная: примитив синхронизации, который позволяет файберам в"
" среде :ref:`кооперативной многозадачности <atomic-"
"cooperative_multitasking>` Tarantool'а передавать управление до "
"выполнения какого-либо предиката."

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:227
msgid ""
"Fiber conditions have two basic operations -- \"wait\" and \"signal\", --"
" where \"wait\" suspends the execution of a fiber (i.e. yields) until "
"\"signal\" is called."
msgstr ""
"Условия работы файбера поддерживают две основные операции -- \"wait\" "
"(ожидание) и \"signal\" (сигнал), -- где \"wait\" откладывает выполнение "
"файбера (то есть передает управление) до тех пор, пока не будет вызван "
"\"signal\"."

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:231
msgid ""
"Unlike ``pthread_cond``, ``fiber_cond`` doesn't require mutex/latch "
"wrapping."
msgstr ""
"В отличие от ``pthread_cond``, ``fiber_cond`` не требует функции-обертки "
"в виде мьютекса или защелки."

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:235
msgid "Create a new conditional variable."
msgstr "Создание новой условной переменной."

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:239
msgid "Delete the conditional variable."
msgstr "Удаление условной переменной."

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:241
msgid ""
"Note: behavior is undefined if there are fibers waiting for the "
"conditional variable."
msgstr ""
"Примечание: поведение не определено, если есть файберы, ожидающие "
"условной переменной."

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:244
msgid "conditional variable to delete"
msgstr "удаляемая условная переменная"

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:250
msgid "Wake up **one** (any) of the fibers waiting for the conditional variable."
msgstr "Пробуждение **одного** (любого) файбера, ожидающего условной переменной."

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:252
#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:260
msgid "Does nothing if no one is waiting."
msgstr "Не делает ничего, если нет ожидающих файберов."

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:254
#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:262
#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:278
msgid "conditional variable"
msgstr "условная переменная"

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:258
msgid "Wake up **all** fibers waiting for the conditional variable."
msgstr "Пробуждение **всех** файберов, ожидающих условной переменной."

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:268
msgid ""
"Suspend the execution of the current fiber (i.e. yield) until "
":ref:`fiber_cond_signal() <c_api-fiber_cond_signal>` is called."
msgstr ""
"Приостановление выполнения текущего файбера (т.е. передача управления) до"
" вызова :ref:`fiber_cond_signal() <c_api-fiber_cond_signal>`."

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:271
msgid ""
"Like ``pthread_cond``, ``fiber_cond`` can issue spurious wake ups caused "
"by explicit :ref:`fiber_wakeup()<c_api-fiber-fiber_wakeup>` or "
":ref:`fiber_cancel()<c_api-fiber-fiber_cancel>` calls. It is highly "
"recommended to wrap calls to this function into a loop and check the "
"actual predicate and :ref:`fiber_is_cancelled()<c_api-fiber-"
"fiber_is_cancelled>` on every iteration."
msgstr ""
"Как и ``pthread_cond``, ``fiber_cond`` может отправлять ложные сигналы "
"пробуждения с помощью вызова :ref:`fiber_wakeup()<c_api-fiber-"
"fiber_wakeup>` или :ref:`fiber_cancel()<c_api-fiber-fiber_cancel>`. "
"Настоятельно рекомендуется заключать вызовы данной функции в цикл и "
"проверять предикат и :ref:`fiber_is_cancelled()<c_api-fiber-"
"fiber_is_cancelled>` при каждой итерации."

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:279
msgid "timeout in seconds"
msgstr "время ожидания в секундах"

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:281
msgid ""
"0 on :ref:`fiber_cond_signal() <c_api-fiber_cond_signal>` call or a "
"spurious wake up"
msgstr ""
"0 при вызове :ref:`fiber_cond_signal() <c_api-fiber_cond_signal>` или "
"ложном пробуждении"

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:283
msgid "-1 on timeout, and the error code is set to 'TimedOut'"
msgstr ""
"-1 в случае ожидания, и задается код ошибки 'TimedOut' (истекло время "
"ожидания)"

#: ../doc/1.10/dev_guide/reference_capi/fiber.rst:287
msgid ""
"Shortcut for :ref:`fiber_cond_wait_timeout() <c_api-"
"fiber_cond_wait_timeout>`."
msgstr ""
"Ускоренный метод для :ref:`fiber_cond_wait_timeout() <c_api-"
"fiber_cond_wait_timeout>`."

#: ../doc/1.10/dev_guide/reference_capi/index.rst:39
msgid "C API reference"
msgstr "Справочник по C API"

#: ../doc/1.10/dev_guide/reference_capi/index.rst:41
msgid "List of C API headers"
msgstr "Список API для языка C"

#: ../doc/1.10/dev_guide/reference_capi/latch.rst:37
msgid "Module `latch`"
msgstr "Модуль `latch`"

#: ../doc/1.10/dev_guide/reference_capi/latch.rst:41
msgid "A lock for cooperative multitasking environment"
msgstr "Блокировка среды кооперативной многозадачности"

#: ../doc/1.10/dev_guide/reference_capi/latch.rst:45
msgid "Allocate and initialize the new latch."
msgstr "Выделение и инициализация новой защелки."

#: ../doc/1.10/dev_guide/reference_capi/latch.rst:47
msgid "allocated latch object"
msgstr "выделенная защелка"

#: ../doc/1.10/dev_guide/reference_capi/latch.rst
msgid "Return type"
msgstr "Возвращаемый тип"

#: ../doc/1.10/dev_guide/reference_capi/latch.rst:48
msgid "box_latch_t *"
msgstr "box_latch_t *"

#: ../doc/1.10/dev_guide/reference_capi/latch.rst:52
msgid "Destroy and free the latch."
msgstr "Удаление и освобождение защелки."

#: ../doc/1.10/dev_guide/reference_capi/latch.rst:54
msgid "latch to destroy"
msgstr "удаляемая защелка"

#: ../doc/1.10/dev_guide/reference_capi/latch.rst:58
msgid ""
"Lock a latch. Waits indefinitely until the current fiber can gain access "
"to the latch."
msgstr ""
"Применение защелки. Бесконечно ожидает момента, когда текущий файбер "
"может получить доступ к защелке."

#: ../doc/1.10/dev_guide/reference_capi/latch.rst
msgid "param box_latch_t* latch"
msgstr "param box_latch_t* latch"

#: ../doc/1.10/dev_guide/reference_capi/latch.rst:61
#: ../doc/1.10/dev_guide/reference_capi/latch.rst:67
msgid "latch to lock"
msgstr "применяемая защелка"

#: ../doc/1.10/dev_guide/reference_capi/latch.rst:65
msgid "Try to lock a latch. Return immediately if the latch is locked."
msgstr ""
"Попытка применить защелку. Возвращается незамедлительно, если защелка "
"поставлена."

#: ../doc/1.10/dev_guide/reference_capi/latch.rst:68
msgid "status of operation. 0 - success, 1 - latch is locked"
msgstr "статус операции. 0 -- успешно, 1 -- защелка поставлена"

#: ../doc/1.10/dev_guide/reference_capi/latch.rst:69
msgid "int"
msgstr "целое число"

#: ../doc/1.10/dev_guide/reference_capi/latch.rst:73
msgid "Unlock a latch. The fiber calling this function must own the latch."
msgstr ""
"Отмена защелки. Файбер, который вызывает данную функцию, должен иметь "
"права на защелку."

#: ../doc/1.10/dev_guide/reference_capi/latch.rst:75
msgid "latch to unlock"
msgstr "отменяемая защелка"

#: ../doc/1.10/dev_guide/reference_capi/say.rst:37
msgid "Module `say` (logging)"
msgstr "Модуль `say` (запись в журнал)"

#: ../doc/1.10/dev_guide/reference_capi/say.rst:45
msgid "do not use this value directly"
msgstr "не используйте непосредственно данное значение "

#: ../doc/1.10/dev_guide/reference_capi/say.rst:63
#: ../doc/1.10/dev_guide/reference_capi/say.rst:79
msgid "Format and print a message to Tarantool log file."
msgstr "Форматирование и запись сообщения в файл журнала Tarantool'а."

#: ../doc/1.10/dev_guide/reference_capi/say.rst:65
msgid ":ref:`log level <c_api-say-say_level>`"
msgstr ":ref:`log level <c_api-say-say_level>`"

#: ../doc/1.10/dev_guide/reference_capi/say.rst:66
#: ../doc/1.10/dev_guide/reference_capi/say.rst:81
msgid "``printf()``-like format string"
msgstr "строка в формате типа ``printf()``"

#: ../doc/1.10/dev_guide/reference_capi/say.rst:69
#: ../doc/1.10/dev_guide/reference_capi/say.rst:84
msgid "See also :manpage:`printf(3)`, :ref:`say_level<c_api-say-say_level>`"
msgstr "См. также :manpage:`printf(3)`, :ref:`say_level<c_api-say-say_level>`"

#: ../doc/1.10/dev_guide/reference_capi/say.rst:88
#, python-format
msgid "say_info(\"Some useful information: %s\", status);"
msgstr "say_info(\"Some useful information: %s\", status);"

#: ../doc/1.10/dev_guide/reference_capi/schema.rst:37
msgid "Module `schema`"
msgstr "Модуль `schema`"

#: ../doc/1.10/dev_guide/reference_capi/schema.rst:45
msgid "Start of the reserved range of system spaces."
msgstr "Начало выделенного диапазона системных спейсов."

#: ../doc/1.10/dev_guide/reference_capi/schema.rst:49
msgid "Space id of _schema."
msgstr "Идентификатор спейса _schema."

#: ../doc/1.10/dev_guide/reference_capi/schema.rst:53
msgid "Space id of _space."
msgstr "Идентификатор спейса _space."

#: ../doc/1.10/dev_guide/reference_capi/schema.rst:57
msgid "Space id of _vspace view."
msgstr "Идентификатор виртуального спейса _vspace."

#: ../doc/1.10/dev_guide/reference_capi/schema.rst:61
msgid "Space id of _index."
msgstr "Идентификатор спейса _index."

#: ../doc/1.10/dev_guide/reference_capi/schema.rst:65
msgid "Space id of _vindex view."
msgstr "Идентификатор виртуального спейса _vindex."

#: ../doc/1.10/dev_guide/reference_capi/schema.rst:69
msgid "Space id of _func."
msgstr "Идентификатор спейса _func."

#: ../doc/1.10/dev_guide/reference_capi/schema.rst:73
msgid "Space id of _vfunc view."
msgstr "Идентификатор виртуального спейса _vfunc."

#: ../doc/1.10/dev_guide/reference_capi/schema.rst:77
msgid "Space id of _user."
msgstr "Идентификатор спейса _user."

#: ../doc/1.10/dev_guide/reference_capi/schema.rst:81
msgid "Space id of _vuser view."
msgstr "Идентификатор виртуального спейса _vuser."

#: ../doc/1.10/dev_guide/reference_capi/schema.rst:85
msgid "Space id of _priv."
msgstr "Идентификатор спейса _priv."

#: ../doc/1.10/dev_guide/reference_capi/schema.rst:89
msgid "Space id of _vpriv view."
msgstr "Идентификатор виртуального спейса _vpriv."

#: ../doc/1.10/dev_guide/reference_capi/schema.rst:93
msgid "Space id of _cluster."
msgstr "Идентификатор спейса _cluster."

#: ../doc/1.10/dev_guide/reference_capi/schema.rst:97
msgid "Space id of _truncate."
msgstr "Идентификатор спейса _truncate."

#: ../doc/1.10/dev_guide/reference_capi/schema.rst:101
msgid "End of reserved range of system spaces."
msgstr "Окончание выделенного диапазона системных спейсов."

#: ../doc/1.10/dev_guide/reference_capi/schema.rst:105
msgid "NULL value, returned on error."
msgstr "Нулевое значение NULL возвращается в случае ошибки."

#: ../doc/1.10/dev_guide/reference_capi/trivia.rst:37
msgid "Module `trivia/config`"
msgstr "Модуль `trivia/config`"

#: ../doc/1.10/dev_guide/reference_capi/trivia.rst:41
msgid "Extern modifier for all public functions."
msgstr "Внешний модификатор для всех доступных функций."

#: ../doc/1.10/dev_guide/reference_capi/trivia.rst:45
msgid "Package major version - 1 for 1.9.2."
msgstr "Мажорная версия пакета -- 1 в 1.9.2."

#: ../doc/1.10/dev_guide/reference_capi/trivia.rst:49
msgid "Package minor version - 9 for 1.9.2."
msgstr "Минорная версия пакета -- 9 в 1.9.2."

#: ../doc/1.10/dev_guide/reference_capi/trivia.rst:53
msgid "Package patch version - 2 for 1.9.2."
msgstr "Патч-версия пакета -- 2 в 1.9.2."

#: ../doc/1.10/dev_guide/reference_capi/trivia.rst:57
msgid ""
"A string with major-minor-patch-commit-id identifier of the release, e.g."
" 1.9.2-0-g113ade24e."
msgstr ""
"Строка с идентификатором версии: "
"мажорная-минорная-патч-коммит-идентификатор, например, "
"1.9.2-0-g113ade24e."

#: ../doc/1.10/dev_guide/reference_capi/trivia.rst:62
msgid "System configuration dir (e.g ``/etc``)"
msgstr "Директория для системной конфигурации (например, ``/etc``)"

#: ../doc/1.10/dev_guide/reference_capi/trivia.rst:66
msgid "Install prefix (e.g. ``/usr``)"
msgstr "Префикс установки (например, ``/usr``)"

#: ../doc/1.10/dev_guide/reference_capi/trivia.rst:70
msgid "Build type, e.g. Debug or Release"
msgstr "Тип сборки, например, отладочная сборка или релиз."

#: ../doc/1.10/dev_guide/reference_capi/trivia.rst:74
msgid "CMake build type signature, e.g. ``Linux-x86_64-Debug``"
msgstr "Подпись типа сборки CMake, например, ``Linux-x86_64-Debug``"

#: ../doc/1.10/dev_guide/reference_capi/trivia.rst:78
msgid "Command line used to run CMake."
msgstr "Командная строка для запуска CMake."

#: ../doc/1.10/dev_guide/reference_capi/trivia.rst:82
msgid "Pathes to C and CXX compilers."
msgstr "Пути к компиляторам C и CXX."

#: ../doc/1.10/dev_guide/reference_capi/trivia.rst:86
msgid "C compile flags used to build Tarantool."
msgstr "Флаги компиляции C, используемые для сборки Tarantool'а."

#: ../doc/1.10/dev_guide/reference_capi/trivia.rst:90
msgid "CXX compile flags used to build Tarantool."
msgstr "Флаги компиляции CXX, используемые для сборки Tarantool'а."

#: ../doc/1.10/dev_guide/reference_capi/trivia.rst:94
msgid "A path to install ``*.lua`` module files."
msgstr "Путь для установки файлов модуля ``*.lua``."

#: ../doc/1.10/dev_guide/reference_capi/trivia.rst:98
msgid "A path to install ``*.so``/``*.dylib`` module files."
msgstr "Путь для установки файлов модуля ``*.so``/``*.dylib``"

#: ../doc/1.10/dev_guide/reference_capi/trivia.rst:102
msgid "A path to Lua includes (the same directory where this file is contained)"
msgstr "Путь к Lua (директория, где хранится этот файл)."

#: ../doc/1.10/dev_guide/reference_capi/trivia.rst:106
msgid ""
"A constant added to ``package.path`` in Lua to find ``*.lua`` module "
"files."
msgstr ""
"Постоянная, добавляемая к  ``package.path`` в Lua для поиска файлов "
"модуля ``*.lua``."

#: ../doc/1.10/dev_guide/reference_capi/trivia.rst:110
msgid ""
"A constant added to ``package.cpath`` in Lua to find ``*.so`` module "
"files."
msgstr ""
"Постоянная, добавляемая к  ``package.cpath`` в Lua для поиска файлов "
"модуля ``*.so``."

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:37
msgid "Module `tuple`"
msgstr "Модуль `tuple`"

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:45
msgid "Tuple format."
msgstr "Формат кортежа."

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:47
msgid ""
"Each Tuple has an associated format (class). Default format is used to "
"create tuples which are not attached to any particular space."
msgstr ""
"Каждому кортежу соответствует определенный формат (класс). По умолчанию, "
"используется формат для создания кортежей, не привязанных к определенному"
" спейсу."

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:58
msgid "Allocate and initialize a new tuple from raw MsgPack Array data."
msgstr "Выделение и инициализация нового кортежа из сырых данных MsgPack-массива."

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:60
msgid ""
"tuple format. Use :ref:`box_tuple_format_default()<c_api-tuple-"
"box_tuple_format_default>` to create space-independent tuple."
msgstr ""
"формат кортежа. Используйте :ref:`box_tuple_format_default()<c_api-tuple-"
"box_tuple_format_default>` для создания кортежа независимо от спейса."

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:63
msgid "tuple data in MsgPack Array format ([field1, field2, ...])"
msgstr "данные кортежа в формате MsgPack-массива ([ field1, field2, ...])"

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:64
msgid "the end of ``data``"
msgstr "конец данных ``data``"

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:66
#: ../doc/1.10/dev_guide/reference_capi/txn.rst:83
msgid "NULL on out of memory"
msgstr "NULL при нехватке памяти"

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:67
msgid "tuple otherwise"
msgstr "в остальных случаях кортеж"

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:69
msgid "See also: :ref:`box.tuple.new()<box_tuple-new>`"
msgstr "См. также :ref:`box.tuple.new()<box_tuple-new>`"

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:73
msgid ""
"When working with tuples, it is the developer's responsibility to ensure "
"that enough space is allocated, taking especial caution when writing to "
"them with msgpuck functions such as ``mp_encode_array()``."
msgstr ""
"При работе с кортежами в обязанности разработчика входит выделение "
"достаточного места, уделяя особое внимание записи данных с помощью таких "
"msgpuck-функций, как ``mp_encode_array()``."

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:82
msgid "Increase the reference counter of tuple."
msgstr "Увеличение значения счетчика количества ссылок на кортеж."

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:84
msgid ""
"Tuples are reference counted. All functions that return tuples guarantee "
"that the last returned tuple is reference counted internally until the "
"next call to API function that yields or returns another tuple."
msgstr ""
"Для кортежей подсчитываются ссылки. Все функции, которые возвращают "
"кортежи, обеспечивают внутренний подсчет ссылок для последнего "
"возвращенного кортежа до следующего вызова API-функции, которая передает "
"управление или возвращает другой кортеж."

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:88
msgid ""
"You should increase the reference counter before taking tuples for long "
"processing in your code. The Lua garbage collector will not destroy a "
"tuple that has references, even if another fiber removes them from a "
"space. After processing, decrement the reference counter using "
":ref:`box_tuple_unref()<c_api-tuple-box_tuple_unref>`, otherwise the "
"tuple will leak."
msgstr ""
"Следует увеличивать значение счетчика количества ссылок перед длительной "
"обработкой кортежей в коде. Сборщик мусора в Lua не будет удалять кортежи"
" с ссылками, даже если другой файбер удалит их из спейса. После обработки"
" уменьшите значение счетчика количества ссылок с помощью "
":ref:`box_tuple_unref()<c_api-tuple-box_tuple_unref>`, иначе кортеж будет"
" допускать утечку."

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:96
#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:109
#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:122
#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:128
#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:147
#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:162
msgid "a tuple"
msgstr "кортеж"

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:98
#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:111
#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:140
msgid "-1 on error"
msgstr "-1 в случае ошибки"

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:101
msgid "See also: :ref:`box_tuple_unref()<c_api-tuple-box_tuple_unref>`"
msgstr "См. также :ref:`box_tuple_unref()<c_api-tuple-box_tuple_unref>`"

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:107
msgid "Decrease the reference counter of tuple."
msgstr "Увеличение значения счетчика количества ссылок на кортеж."

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:114
msgid "See also: :ref:`box_tuple_ref()<c_api-tuple-box_tuple_ref>`"
msgstr "См. также :ref:`box_tuple_ref()<c_api-tuple-box_tuple_ref>`"

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:120
msgid "Return the number of fields in a tuple (the size of MsgPack Array)."
msgstr "Возврат количества полей в кортеже (размер MsgPack-массива)."

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:126
msgid ""
"Return the number of bytes used to store internal tuple data (MsgPack "
"Array)."
msgstr ""
"Возврат количества байтов, используемых для хранения внутренних данных "
"кортежа (MsgPack-массив)."

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:132
msgid "Dump raw MsgPack data to the memory buffer ``buf`` of size ``size``."
msgstr "Передача сырых MsgPack-данных в буфер памяти ``buf`` размера ``size``."

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:134
msgid "Store tuple fields in the memory buffer."
msgstr "Хранение полей кортежа в буфере памяти."

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:136
msgid ""
"Upon successful return, the function returns the number of bytes written."
" If buffer size is not enough then the return value is the number of "
"bytes which would have been written if enough space had been available."
msgstr ""
"При успешном выполнении функция возвращает количество записанных байтов. "
"Если размер буфера недостаточный, возвращается количество байтов, которое"
" было бы записано, если бы было достаточно места."

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:141
msgid "number of bytes written on success."
msgstr "количество записанных байтов при успешном выполнении."

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:145
msgid "Return the associated format."
msgstr "Возврат взаимосвязанного формата."

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:149
msgid "tuple format"
msgstr "формат кортежа"

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:155
msgid ""
"Return the raw tuple field in MsgPack format. The result is a pointer to "
"raw MessagePack data which can be decoded with mp_decode functions, for "
"an example see the tutorial program :ref:`read.c <f_c_tutorial-read>`."
msgstr ""
"Возврат поля кортежа в MsgPack-формате. Результатом будет указатель на "
"сырые данные в формате MessagePack, которые можно расшифровать с помощью "
"функций mp_decode. Пример можно увидеть в программе практикума "
":ref:`read.c <f_c_tutorial-read>`."

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:160
msgid "The buffer is valid until the next call to a ``box_tuple_*`` function."
msgstr "Буфер действует до следующего вызова функции ``box_tuple_*``."

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:163
msgid "zero-based index in MsgPack array."
msgstr "индекс с основанием 0 в MsgPack-массиве."

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:165
msgid ""
"NULL if i >= :ref:`box_tuple_field_count()<c_api-tuple-"
"box_tuple_field_count>`"
msgstr ""
"NULL, если i >= :ref:`box_tuple_field_count()<c_api-tuple-"
"box_tuple_field_count>`"

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:166
msgid "msgpack otherwise"
msgstr "в остальных случаях msgpack"

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:181
msgid "Possible data types for tuple fields."
msgstr "Допустимые типы данных для полей кортежа."

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:183
msgid ""
"One cannot use STRS/ENUM macros for types because there is a mismatch "
"between enum name (STRING) and type name literal (\"STR\"). STR is "
"already used as a type in Objective C."
msgstr ""
"Нельзя использовать макросы STRS/ENUM для типов, поскольку есть "
"несоответствие между именем enum (STRING) и литералом имени типа "
"(\"STR\"). STR уже используется в качестве типа в Objective-C."

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:191
msgid "Key definition"
msgstr "Определение ключа"

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:195
msgid ""
"Create a key definition with the key fields with passed types on passed "
"positions."
msgstr ""
"Создание определения ключа с полям ключа с переданными типами по "
"переданным позициям."

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:197
msgid "May be used for tuple format creation and/or tuple comparison."
msgstr ""
"Можно использовать для создания формата кортежа и/или сопоставления "
"кортежей."

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:199
msgid "array with key field identifiers"
msgstr "массив с идентификаторами поля ключа"

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:200
msgid "array with key :ref:`field types <capi-tuple_field_type>`"
msgstr "массив с :ref:`типами поля <capi-tuple_field_type>` ключа"

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:201
msgid "the number of key fields"
msgstr "количество полей ключа"

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:208
msgid "Delete a key definition"
msgstr "Удаление определения ключа"

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:210
msgid "key definition to delete"
msgstr "удаляемое определение ключа"

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:216
msgid "Return new in-memory tuple format based on passed key definitions"
msgstr "Возврат нового формата кортежа на основании переданных определений ключа"

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:218
msgid "array of keys defined for the format"
msgstr "массив ключей, определенный для формата"

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:219
msgid "count of keys"
msgstr "количество ключей"

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:221
msgid "new tuple format on success"
msgstr "новый формат кортежа, если выполнено"

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:226
msgid "Increment tuple format reference count"
msgstr "Увеличение значения подсчета ссылок на формат кортежа"

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:228
msgid "tuple format to ref"
msgstr "формат кортежа для ссылок"

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:232
msgid "Decrement tuple format reference count"
msgstr "Уменьшение значения подсчета ссылок на формат кортежа"

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:234
msgid "tuple format to unref"
msgstr "формат кортежа для уменьшения"

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:240
msgid "Compare tuples using key definition"
msgstr "Сопоставление кортежей, используя определение ключа"

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:242
msgid "the first tuple"
msgstr "первый кортеж"

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:243
msgid "the second tuple"
msgstr "второй кортеж"

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:244
#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:258
msgid "key definition"
msgstr "определение ключа"

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:246
msgid "0  if ``key_fields(tuple_a)`` == ``key_fields(tuple_b)``"
msgstr "0, если ``key_fields(tuple_a)`` == ``key_fields(tuple_b)``"

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:247
msgid "<0 if ``key_fields(tuple_a)`` < ``key_fields(tuple_b)``"
msgstr "<0, если ``key_fields(tuple_a)`` < ``key_fields(tuple_b)``"

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:248
msgid ">0 if ``key_fields(tuple_a)`` > ``key_fields(tuple_b)``"
msgstr ">0, если ``key_fields(tuple_a)`` > ``key_fields(tuple_b)``"

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:250
#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:264
msgid "See also: enum :ref:`field_type <capi-tuple_field_type>`"
msgstr "См. также enum :ref:`field_type <capi-tuple_field_type>`"

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:254
msgid "Compare a tuple with a key using key definition"
msgstr "Сопоставление кортежа с ключом, используя определение ключа"

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:257
msgid "key with MessagePack array header"
msgstr "ключ с заголовком MessagePack-массива"

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:260
msgid "0  if ``key_fields(tuple)`` == ``parts(key)``"
msgstr "0, если ``key_fields(tuple)`` == ``parts(key)``"

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:261
msgid "<0 if ``key_fields(tuple)`` < ``parts(key)``"
msgstr "<0, если ``key_fields(tuple)`` < ``parts(key)``"

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:262
msgid ">0 if ``key_fields(tuple)`` > ``parts(key)``"
msgstr ">0, если ``key_fields(tuple)`` > ``parts(key)``"

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:268
msgid "Tuple iterator"
msgstr "Итератор кортежей"

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:272
msgid ""
"Allocate and initialize a new tuple iterator. The tuple iterator allows "
"iterating over fields at the root level of a MsgPack array."
msgstr ""
"Выделение и инициализация нового итератора кортежей. Итератор кортежей "
"позволяет проводить итерацию по полям на корневом уровне MsgPack-массива."

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:277
msgid ""
"box_tuple_iterator_t* it = box_tuple_iterator(tuple);\n"
"if (it == NULL) {\n"
"    // error handling using box_error_last()\n"
"}\n"
"const char* field;\n"
"while (field = box_tuple_next(it)) {\n"
"    // process raw MsgPack data\n"
"}\n"
"\n"
"// rewind the iterator to the first position\n"
"box_tuple_rewind(it)\n"
"assert(box_tuple_position(it) == 0);\n"
"\n"
"// rewind three fields\n"
"field = box_tuple_seek(it, 3);\n"
"assert(box_tuple_position(it) == 4);\n"
"\n"
"box_iterator_free(it);"
msgstr ""
"box_tuple_iterator_t* it = box_tuple_iterator(tuple);\n"
"if (it == NULL) {\n"
"    // обработка ошибок с помощью box_error_last()\n"
"}\n"
"const char* field;\n"
"while (field = box_tuple_next(it)) {\n"
"    // обработка сырых MsgPack-данных\n"
"}\n"
"\n"
"// перемотка итератора на начальное положение\n"
"box_tuple_rewind(it)\n"
"assert(box_tuple_position(it) == 0);\n"
"\n"
"// перемотка на три поля\n"
"field = box_tuple_seek(it, 3);\n"
"assert(box_tuple_position(it) == 4);\n"
"\n"
"box_iterator_free(it);"

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:300
msgid "Destroy and free tuple iterator"
msgstr "Удаление и освобождение итератора кортежей"

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:306
msgid ""
"Return zero-based next position in iterator. That is, this function "
"returnы the field id of the field that will be returned by the next call "
"to :ref:`box_tuple_next()<c_api-tuple-box_tuple_next>`. Returned value is"
" zero after initialization or rewind and :ref:`box_tuple_field_count"
"()<c_api-tuple-box_tuple_field_count>` after the end of iteration."
msgstr ""
"Возврат следующего положения с основанием 0 в итераторе. То есть функция "
"возвращает идентификатор поля, который вернется при следующем вызове "
":ref:`box_tuple_next()<c_api-tuple-box_tuple_next>`. Возвращается "
"значение 0 после инициализации или перемотки и "
":ref:`box_tuple_field_count()<c_api-tuple-box_tuple_field_count>` по "
"окончании итерации."

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:313
#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:320
#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:335
#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:356
msgid "a tuple iterator"
msgstr "итератор кортежей"

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:314
msgid "position"
msgstr "положение"

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:318
msgid "Rewind iterator to the initial position."
msgstr "Перемотка итератора в начальное положение."

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:322
msgid "After: ``box_tuple_position(it) == 0``"
msgstr "После: ``box_tuple_position(it) == 0``"

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:326
msgid "Seek the tuple iterator."
msgstr "Поиск итератора кортежей."

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:328
msgid ""
"The result is a pointer to raw MessagePack data which can be decoded with"
" mp_decode functions, for an example see the tutorial program "
":ref:`read.c <f_c_tutorial-read>`. The returned buffer is valid until the"
" next call to ``box_tuple_*`` API. The requested ``field_no`` is returned"
" by the next call to ``box_tuple_next(it)``."
msgstr ""
"Результатом будет указатель на сырые MessagePack-данные, которые можно "
"расшифровать с помощью функций ``mp_decode``. Пример можно увидеть в "
"программе практикума :ref:`read.c <f_c_tutorial-read>`. Возвращаемый "
"буфер действует до следующего вызова API ``box_tuple_*`` . Запрашиваемый "
"номер поля ``field_no`` возвращается при следующем вызове "
"``box_tuple_next(it)``."

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:336
msgid "field number - zero-based position in MsgPack array"
msgstr "номер поля -- положение с основанием 0 в MsgPack-массиве"

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:339
msgid "After:"
msgstr "После:"

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:341
msgid "``box_tuple_position(it) == field_not`` if returned value is not NULL."
msgstr "``box_tuple_position(it) == field_not``, если возвращается не NULL."

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:342
msgid ""
"``box_tuple_position(it) == box_tuple_field_count(tuple)`` if returned "
"value is NULL."
msgstr ""
"``box_tuple_position(it) == box_tuple_field_count(tuple)``, если "
"возвращается NULL."

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:349
msgid "Return the next tuple field from tuple iterator."
msgstr "Возврат следующего поля кортежа из итератора кортежей."

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:351
msgid ""
"The result is a pointer to raw MessagePack data which can be decoded with"
" mp_decode functions, for an example see the tutorial program "
":ref:`read.c <f_c_tutorial-read>`. The returned buffer is valid until "
"next call to ``box_tuple_*`` API."
msgstr ""
"Результатом будет указатель на сырые MessagePack-данные, которые можно "
"расшифровать с помощью функций mp_decode. Пример можно увидеть в "
"программе практикума :ref:`read.c <f_c_tutorial-read>`. Возвращаемый "
"буфер действует до следующего вызова API ``box_tuple_*``."

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:357
msgid "NULL if there are no more fields"
msgstr "NULL, если полей больше нет"

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:358
msgid "MsgPack otherwise"
msgstr "в остальных случаях MsgPack"

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:360
msgid ""
"Before: :ref:`box_tuple_position()<c_api-tuple-box_tuple_position>` is "
"zero-based ID of returned field."
msgstr ""
"Ранее: :ref:`box_tuple_position()<c_api-tuple-box_tuple_position>` -- это"
" идентификатор с основанием 0 возвращаемого поля."

#: ../doc/1.10/dev_guide/reference_capi/tuple.rst:363
msgid ""
"After: ``box_tuple_position(it) == box_tuple_field_count(tuple)`` if "
"returned value is NULL."
msgstr ""
"После: ``box_tuple_position(it) == box_tuple_field_count(tuple)``, если "
"возвращается NULL."

#: ../doc/1.10/dev_guide/reference_capi/txn.rst:37
msgid "Module `txn`"
msgstr "Модуль `txn`"

#: ../doc/1.10/dev_guide/reference_capi/txn.rst:41
msgid "Return true if there is an active transaction."
msgstr "Возврат true (правда), если есть активная транзакция."

#: ../doc/1.10/dev_guide/reference_capi/txn.rst:47
msgid "Begin a transaction in the current fiber."
msgstr "Начало транзакции в текущем файбере."

#: ../doc/1.10/dev_guide/reference_capi/txn.rst:49
msgid ""
"A transaction is attached to caller fiber, therefore one fiber can have "
"only one active transaction. See also :ref:`box.begin()<box-begin>`."
msgstr ""
"Транзакция привязана к вызывающему файберу, поэтому в одном файбере может"
" быть только одна активная транзакция. См. также :ref:`box.begin()<box-"
"begin>`."

#: ../doc/1.10/dev_guide/reference_capi/txn.rst:53
msgid "-1 on error. Perhaps a transaction has already been started."
msgstr "-1 в случае ошибки. Возможно, транзакция уже была запущена."

#: ../doc/1.10/dev_guide/reference_capi/txn.rst:59
msgid "Commit the current transaction. See also :ref:`box.commit() <box-commit>`."
msgstr "Коммит текущей транзакции. См. также :ref:`box.commit() <box-commit>`."

#: ../doc/1.10/dev_guide/reference_capi/txn.rst:62
msgid "-1 on error. Perhaps a disk write failure"
msgstr "-1 в случае ошибки. Возможен отказ записи на диск"

#: ../doc/1.10/dev_guide/reference_capi/txn.rst:66
msgid ""
"Roll back the current transaction. See also :ref:`box.rollback() <box-"
"rollback>`."
msgstr "Откат текущей транзакции. См. также :ref:`box.rollback() <box-rollback>`."

#: ../doc/1.10/dev_guide/reference_capi/txn.rst:70
msgid "Return a descriptor of a savepoint."
msgstr "Возврат дескриптора контрольной точки."

#: ../doc/1.10/dev_guide/reference_capi/txn.rst:74
msgid "Roll back the current transaction as far as the specified savepoint."
msgstr "Откат текущей транзакции до указанной контрольной точки."

#: ../doc/1.10/dev_guide/reference_capi/txn.rst:78
msgid "Allocate memory on txn memory pool."
msgstr "Выделение памяти в пул памяти txn."

#: ../doc/1.10/dev_guide/reference_capi/txn.rst:80
msgid ""
"The memory is automatically deallocated when the transaction is committed"
" or rolled back."
msgstr "Память автоматически освобождается при коммите или откате транзакции."

#: ../doc/1.10/dev_guide/reference_capi/utils.rst:37
msgid "Module `lua/utils`"
msgstr "Модуль `lua/utils`"

#: ../doc/1.10/dev_guide/reference_capi/utils.rst:43
msgid "Push cdata of given ``ctypeid`` onto the stack."
msgstr "Принудительная передача cdata заданного ``ctypeid`` в стек."

#: ../doc/1.10/dev_guide/reference_capi/utils.rst:45
msgid ""
"CTypeID must be used from FFI at least once. Allocated memory returned "
"uninitialized. Only numbers and pointers are supported."
msgstr ""
"CTypeID должен быть использован хотя бы один раз из FFI. Выделенная "
"область памяти возвращается неинициализированной. Поддерживаются только "
"числа и указатели."

#: ../doc/1.10/dev_guide/reference_capi/utils.rst:48
#: ../doc/1.10/dev_guide/reference_capi/utils.rst:61
#: ../doc/1.10/dev_guide/reference_capi/utils.rst:76
#: ../doc/1.10/dev_guide/reference_capi/utils.rst:83
#: ../doc/1.10/dev_guide/reference_capi/utils.rst:96
#: ../doc/1.10/dev_guide/reference_capi/utils.rst:108
#: ../doc/1.10/dev_guide/reference_capi/utils.rst:115
#: ../doc/1.10/dev_guide/reference_capi/utils.rst:150
#: ../doc/1.10/dev_guide/reference_capi/utils.rst:162
msgid "Lua State"
msgstr "Lua_State"

#: ../doc/1.10/dev_guide/reference_capi/utils.rst:49
msgid "FFI's CTypeID of this cdata"
msgstr "CTypeID из FFI для cdata "

#: ../doc/1.10/dev_guide/reference_capi/utils.rst:51
#: ../doc/1.10/dev_guide/reference_capi/utils.rst:65
msgid "memory associated with this cdata"
msgstr "область памяти, ассоциированная с cdata"

#: ../doc/1.10/dev_guide/reference_capi/utils.rst:53
msgid "See also: :ref:`luaL_checkcdata()<c_api-utils-luaL_checkcdata>`"
msgstr "См. также :ref:`luaL_checkcdata()<c_api-utils-luaL_checkcdata>`"

#: ../doc/1.10/dev_guide/reference_capi/utils.rst:59
msgid "Check whether the function argument ``idx`` is a cdata."
msgstr "Проверка, является ли аргумент функции ``idx`` cdata."

#: ../doc/1.10/dev_guide/reference_capi/utils.rst:62
#: ../doc/1.10/dev_guide/reference_capi/utils.rst:77
msgid "stack index"
msgstr "индекс стека"

#: ../doc/1.10/dev_guide/reference_capi/utils.rst:63
msgid "output argument. FFI's CTypeID of returned cdata"
msgstr "аргумент вывода. CTypeID из FFI для возвращаемого cdata "

#: ../doc/1.10/dev_guide/reference_capi/utils.rst:67
msgid "See also: :ref:`luaL_pushcdata()<c_api-utils-luaL_pushcdata>`"
msgstr "См. также :ref:`luaL_pushcdata()<c_api-utils-luaL_pushcdata>`"

#: ../doc/1.10/dev_guide/reference_capi/utils.rst:71
msgid "Set finalizer function on a cdata object."
msgstr "Определение функции-финализатора для cdata."

#: ../doc/1.10/dev_guide/reference_capi/utils.rst:73
msgid ""
"Equivalent to call `ffi.gc(obj, function)`. Finalizer function must be on"
" the top of the stack."
msgstr ""
"Аналог вызова `ffi.gc(obj, function)`. Функция-финализатор должна быть на"
" вершине стека."

#: ../doc/1.10/dev_guide/reference_capi/utils.rst:81
msgid "Return CTypeID (FFI) of given СDATA type."
msgstr "Возврат CTypeID (FFI) заданного типа СDATA."

#: ../doc/1.10/dev_guide/reference_capi/utils.rst:84
msgid "C type name as string (e.g. \"struct request\" or \"uint32_t\")"
msgstr "Имя типа в C в виде строки (например, \"struct request\" или \"uint32_t\")"

#: ../doc/1.10/dev_guide/reference_capi/utils.rst:87
msgid "CTypeID"
msgstr "CTypeID"

#: ../doc/1.10/dev_guide/reference_capi/utils.rst:89
msgid ""
"See also: :ref:`luaL_pushcdata()<c_api-utils-luaL_pushcdata>`, "
":ref:`luaL_checkcdata()<c_api-utils-luaL_checkcdata>`"
msgstr ""
"См. также :ref:`luaL_pushcdata()<c_api-utils-luaL_pushcdata>`, "
":ref:`luaL_checkcdata()<c_api-utils-luaL_checkcdata>`"

#: ../doc/1.10/dev_guide/reference_capi/utils.rst:94
msgid "Declare symbols for FFI."
msgstr "Объявление символов для FFI."

#: ../doc/1.10/dev_guide/reference_capi/utils.rst:97
msgid "C definitions (e.g. \"struct stat\")"
msgstr "C-определения (например, \"struct stat\")"

#: ../doc/1.10/dev_guide/reference_capi/utils.rst:100
msgid "``LUA_ERRRUN``, ``LUA_ERRMEM` or ``LUA_ERRERR`` otherwise."
msgstr "``LUA_ERRRUN``, ``LUA_ERRMEM` или ``LUA_ERRERR``, в противном случае."

#: ../doc/1.10/dev_guide/reference_capi/utils.rst:102
msgid "See also: ``ffi.cdef(def)``"
msgstr "См. также ``ffi.cdef(def)``"

#: ../doc/1.10/dev_guide/reference_capi/utils.rst:106
msgid "Push uint64_t onto the stack."
msgstr "Принудительная передача uint64_t в стек."

#: ../doc/1.10/dev_guide/reference_capi/utils.rst:109
#: ../doc/1.10/dev_guide/reference_capi/utils.rst:116
msgid "value to push"
msgstr "передаваемое значение"

#: ../doc/1.10/dev_guide/reference_capi/utils.rst:113
msgid "Push int64_t onto the stack."
msgstr "Принудительная передача int64_t в стек."

#: ../doc/1.10/dev_guide/reference_capi/utils.rst:120
#: ../doc/1.10/dev_guide/reference_capi/utils.rst:134
msgid ""
"Check whether the argument idx is a uint64 or a convertable string and "
"returns this number."
msgstr ""
"Проверка, является ли аргумент idx uint64 или конвертируемой строкой, и "
"возврат этого числа."

#: ../doc/1.10/dev_guide/reference_capi/utils.rst
msgid "throws"
msgstr "выбрасывает"

#: ../doc/1.10/dev_guide/reference_capi/utils.rst:123
#: ../doc/1.10/dev_guide/reference_capi/utils.rst:130
msgid "error if the argument can't be converted"
msgstr "ошибку, если аргумент нельзя конвертировать"

#: ../doc/1.10/dev_guide/reference_capi/utils.rst:127
#: ../doc/1.10/dev_guide/reference_capi/utils.rst:141
msgid ""
"Check whether the argument idx is a int64 or a convertable string and "
"returns this number."
msgstr ""
"Проверка, является ли аргумент idx int64 или конвертируемой строкой, и "
"возврат этого числа."

#: ../doc/1.10/dev_guide/reference_capi/utils.rst:137
#: ../doc/1.10/dev_guide/reference_capi/utils.rst:144
msgid "the converted number or 0 of argument can't be converted"
msgstr "конвертированное число или 0, если аргумент нельзя конвертировать"

#: ../doc/1.10/dev_guide/reference_capi/utils.rst:148
msgid "Push a tuple onto the stack."
msgstr "Принудительная передача кортежа в стек."

#: ../doc/1.10/dev_guide/reference_capi/utils.rst:152
msgid "error on OOM"
msgstr "ошибка при нехватке памяти"

#: ../doc/1.10/dev_guide/reference_capi/utils.rst:154
msgid "See also: :ref:`luaT_istuple <c_api-utils-luaT_istuple>`"
msgstr "См. также :ref:`luaT_istuple <c_api-utils-luaT_istuple>`"

#: ../doc/1.10/dev_guide/reference_capi/utils.rst:160
msgid "Check whether ``idx`` is a tuple."
msgstr "Проверка, является ли ``idx`` кортежем."

#: ../doc/1.10/dev_guide/reference_capi/utils.rst:163
msgid "the stack index"
msgstr "индекс стека"

#: ../doc/1.10/dev_guide/reference_capi/utils.rst:165
msgid "non-NULL if ``idx`` is a tuple"
msgstr "не NULL, если ``idx`` -- это кортеж"

#: ../doc/1.10/dev_guide/reference_capi/utils.rst:166
msgid "NULL if ``idx`` is not a tuple"
msgstr "NULL, если ``idx`` -- это не кортеж"

#: ../doc/1.10/dev_guide/reference_capi/utils.rst:170
msgid "Re-throw the last Tarantool error as a Lua object."
msgstr "Повторение последней ошибки в Tarantool'е в виде Lua-объекта."

#: ../doc/1.10/dev_guide/reference_capi/utils.rst:172
msgid ""
"See also: `lua_error() "
"<https://www.lua.org/manual/5.1/manual.html#lua_error>`_,"
msgstr ""
"См. также `lua_error() "
"<https://www.lua.org/manual/5.1/manual.html#lua_error>`_,"

#: ../doc/1.10/dev_guide/reference_capi/utils.rst:173
msgid ":ref:`box_error_last() <c_api-error-box_error_last>`."
msgstr ":ref:`box_error_last() <c_api-error-box_error_last>`."

#: ../doc/1.10/dev_guide/reference_capi/utils.rst:177
msgid ""
"Similar to `lua_cpcall() "
"<https://www.lua.org/manual/5.1/manual.html#lua_cpcall>`_, but with the "
"proper support of Tarantool errors."
msgstr ""
"Аналог `lua_cpcall() "
"<https://www.lua.org/manual/5.1/manual.html#lua_cpcall>`_, но с "
"соответствующей поддержкой ошибок Tarantool'а."

#: ../doc/1.10/dev_guide/reference_capi/utils.rst:182
msgid "Get the global Lua state used by Tarantool."
msgstr "Получение глобального состояния Lua, используемого Tarantool'ом."

#: ../doc/1.10/dev_guide/release_management.rst:39
msgid "Release management"
msgstr "Управление версиями"

#: ../doc/1.10/dev_guide/release_management.rst:45
msgid "Release policy"
msgstr "Политика управления версия"

#: ../doc/1.10/dev_guide/release_management.rst:47
msgid ""
"A Tarantool release is identified by three digits, for example, 1.7.7. We"
" use these digits according to their definitions provided at "
"http://semver.org:"
msgstr ""
"Версия Tarantool'а определяется тремя цифрами, например, 1.7.7. Мы "
"пользуемся цифрами по определению, данному на сайте http://semver.org:"

#: ../doc/1.10/dev_guide/release_management.rst:50
msgid ""
"The first digit stands for MAJOR release. A **major** release may contain"
" *incompatible changes*."
msgstr ""
"Первая цифра означает МАЖОРНУЮ версию. **Мажорная** версия может "
"содержать *несовместимые изменения*."

#: ../doc/1.10/dev_guide/release_management.rst:52
msgid ""
"The second digit stands for MINOR release, it does not contain "
"incompatible changes, and is used for introducing backward-compatible "
"*features*."
msgstr ""
"Вторая цифра означает МИНОРНУЮ версию; такая версия не содержит "
"несовместимых изменений и используется для релиза нового *функционала* с "
"обратной совместимостью."

#: ../doc/1.10/dev_guide/release_management.rst:54
msgid ""
"The third digit is for PATCH releases that contain only backward-"
"compatible *bug fixes*."
msgstr ""
"Третья цифра используется для ПАТЧ-версий, которые содержат только "
"**исправления дефектов** с обратной совместимостью."

#: ../doc/1.10/dev_guide/release_management.rst:57
msgid "In MINOR digit, we reflect how stable a release is:"
msgstr "Цифра МИНОРНОЙ версии также отражает ее стабильность:"

#: ../doc/1.10/dev_guide/release_management.rst:59
msgid "0 meaning alpha,"
msgstr "0 означает альфа-версию,"

#: ../doc/1.10/dev_guide/release_management.rst:60
msgid "1 meaning beta,"
msgstr "1 означает бета-версию,"

#: ../doc/1.10/dev_guide/release_management.rst:61
msgid "anything between 1 and 10 meaning stable, and"
msgstr "от 1 до 10 означает стабильную версию, а"

#: ../doc/1.10/dev_guide/release_management.rst:62
msgid "10 meaning LTS."
msgstr "10 означает окончательную версию с долгосрочной технической поддержкой."

#: ../doc/1.10/dev_guide/release_management.rst:64
msgid ""
"So, each MAJOR release series goes through a development-maturity life "
"cycle of MINOR releases, as follows:"
msgstr ""
"Таким образом, каждая МАЖОРНАЯ версия проходит через жизненный цикл "
"разработки МИНОРНЫХ версий следующим образом:"

#: ../doc/1.10/dev_guide/release_management.rst:67
msgid ""
"**Alpha**. Once in every few months we release a few alpha versions, e.g."
" 2.0.1, 2.0.2."
msgstr ""
"**Альфа**. Один раз в несколько месяцев выходят несколько альфа-версий, "
"например, 2.0.1, 2.0.2."

#: ../doc/1.10/dev_guide/release_management.rst:70
msgid "Alpha versions may contain incompatible changes, crashes and other bugs."
msgstr ""
"Альфа-версии могут содержать несовместимые изменения, сбои и другие "
"дефекты."

#: ../doc/1.10/dev_guide/release_management.rst:72
msgid ""
"**Beta**. Once major changes necessary to introduce new flagship features"
" are ready, we release a few beta versions, e.g. 2.1.3, 2.1.4."
msgstr ""
"**Бета**. Когда готовы значительные изменения, необходимые для включения "
"новых основных функций, мы выпускаем несколько бета-версий, например, "
"2.1.3, 2.1.4."

#: ../doc/1.10/dev_guide/release_management.rst:75
msgid ""
"Beta versions may contain crashes, but do not have incompatible changes, "
"so can be used to develop new applications."
msgstr ""
"Бета-версии могут приводить к сбоям, но не содержат несовместимых "
"изменений, поэтому их можно использовать для разработки новых приложений."

#: ../doc/1.10/dev_guide/release_management.rst:78
msgid ""
"**Stable**. Finally, after we see our beta versions run successfully in "
"production, usually in a few more months, during which we fix all "
"incoming bugs and add some minor features, we declare this MAJOR release "
"series stable."
msgstr ""
"**Стабильная**. Наконец, после того, как бета-версии успешно отработают "
"примерно несколько месяцев, во время которых мы исправляем поступающие "
"дефекты и добавляем некоторые небольшие функции, мы объявляем эту "
"МАЖОРНУЮ версию стабильной."

#: ../doc/1.10/dev_guide/release_management.rst:83
msgid "Like Ubuntu, we distinguish two kinds of stable releases:"
msgstr "Как и в Ubuntu, мы различаем два вида стабильных версий:"

#: ../doc/1.10/dev_guide/release_management.rst:85
msgid ""
"**LTS (Long Term Support)** releases that are supported for 3 years "
"(community) and up to 5 years (paying customers). **LTS** release is "
"identified by MINOR version 10."
msgstr ""
"**LTS (Long Term Support - Долгосрочная техническая поддержка)** такие "
"версии поддерживаются в течение 3 лет (сообщество) и до 5 лет "
"(платежеспособные клиенты). **LTS**-версию можно идентифицировать по "
"МИНОРНОЙ версии = 10."

#: ../doc/1.10/dev_guide/release_management.rst:88
msgid ""
"**Standard stable releases** are only supported a few months after the "
"next stable is out."
msgstr ""
"**Стандартные стабильные версии** поддерживаются в течении нескольких "
"месяцев после выхода."

#: ../doc/1.10/dev_guide/release_management.rst:91
msgid "\"Support\" means that we continue fixing bugs in a release."
msgstr ""
"\"Support\" (поддержка) означает, что мы продолжаем исправлять ошибки в "
"этой версии."

#: ../doc/1.10/dev_guide/release_management.rst:93
msgid "We add commits simultaneously to three MAJOR releases:"
msgstr "Мы добавляем коммиты одновременно в три МАЖОРНЫЕ версии:"

#: ../doc/1.10/dev_guide/release_management.rst:95
msgid ""
"**LTS** is a stable release which does not receive new features, and only"
" gets backward compatible fixes. Hence, following the rules of semver, "
"LTS release never has its MAJOR or MINOR version increased, and only gets"
" PATCH level releases."
msgstr ""
"**LTS** -- это стабильная версия, которая не получает новые функции, а "
"только исправления обратной совместимости. Следовательно, по правилам "
"семантической версификации в LTS-версии никогда не увеличивается МАЖОРНАЯ"
" или МИНОРНАЯ, а только ПАТЧ-версия."

#: ../doc/1.10/dev_guide/release_management.rst:100
msgid ""
"**STABLE** is our current stable release, which may receive new features."
" When the next STABLE version is published, MINOR version is incremented."
" Between MINOR releases, we may have intermediate PATCH level releases as"
" well, which will contain only bug fixes. We maintain PATCH level "
"releases for two STABLE releases, the current and the previous one, to "
"preserve support continuity."
msgstr ""
"**СТАБИЛЬНАЯ** -- это наша текущая стабильная версия, в которую могут "
"быть добавлены новые функции. Когда выходит следующая СТАБИЛЬНАЯ версия, "
"увеличивается МИНОРНАЯ версия. Между МИНОРНЫМИ версиями у нас могут "
"увеличиваться промежуточные уровни ПАТЧ-версии, в которых будут только "
"исправлены дефекты. Мы поддерживаем ПАТЧ-уровни для двух СТАБИЛЬНЫХ "
"версий -- текущей и предыдущей -- для сообщества разработчиков."

#: ../doc/1.10/dev_guide/release_management.rst:107
msgid ""
"**NEXT** is our next MAJOR release, and it follows the maturity cycle "
"described in the beginning. While NEXT release is in alpha state, its "
"MINOR is frozen at 0 and is only increased when the release reaches BETA "
"status. Once the NEXT release becomes STABLE, we switch the vehicle for "
"delivery of minor features, designating the previous stable release as "
"LTS, and releasing it with MINOR set to 10."
msgstr ""
"**СЛЕДУЮЩАЯ** -- это следующая МАЖОРНАЯ версия, которая проходит процесс "
"зрелости, описанный в начале раздела. Когда СЛЕДУЮЩАЯ версия находится в "
"альфа-стадии, МИНОРНАЯ остается на уровне 0 и увеличивается, когда версия"
" переходит в БЕТА-стадию. После того, как СЛЕДУЮЩАЯ версия становится "
"СТАБИЛЬНОЙ, мы переключаемся на выдачу небольших функций, обозначая "
"предыдущую стабильную версию как LTS, и выпускаем ее с МИНОРНОЙ версией ="
" 10."

#: ../doc/1.10/dev_guide/release_management.rst:114
msgid "To sum up, once a quarter we release:"
msgstr "Итак, раз в квартал выходят:"

#: ../doc/1.10/dev_guide/release_management.rst:116
msgid "the next LTS release, e.g. 2.10.6, 2.10.7 or 2.10.8"
msgstr "следующая LTS-версия, например, 2.10.6, 2.10.7 или 2.10.8"

#: ../doc/1.10/dev_guide/release_management.rst:117
msgid "the next STABLE release, e.g. 3.6, 3.7 or 3.8"
msgstr "следующая СТАБИЛЬНАЯ версия,например, 3.6, 3.7 или 3.8"

#: ../doc/1.10/dev_guide/release_management.rst:118
msgid ""
"(optionally) an alpha or beta version of the NEXT release, e.g. 4.0.1, "
"4.0.2 or 4.0.3"
msgstr ""
"(возможно) альфа-стадия или бета-стадия СЛЕДУЮЩЕЙ версии, например, "
"4.0.1, 4.0.2 или 4.0.3"

#: ../doc/1.10/dev_guide/release_management.rst:121
msgid ""
"In all supported releases, we also release a PATCH release as soon as we "
"find and fix an outstanding CVE/vulnerability."
msgstr ""
"Для всех поддерживаемых версий мы также выпускаем ПАТЧИ, как только "
"обнаружим и устраним уязвимость."

#: ../doc/1.10/dev_guide/release_management.rst:124
msgid ""
"We also publish nightly builds, and use the fourth slot in the version "
"identifier to designate the nightly build number."
msgstr ""
"Мы также публикуем ночные сборки и используем четвертый слот в "
"идентификаторе версии для обозначения номера ночной сборки."

#: ../doc/1.10/dev_guide/release_management.rst:127
msgid "Example version identifier:"
msgstr "Пример идентификатора версии:"

#: ../doc/1.10/dev_guide/release_management.rst:129
msgid "2.0.3 - third alpha of 2.0 release"
msgstr "2.0.3 - третья альфа-стадия версии 2.0"

#: ../doc/1.10/dev_guide/release_management.rst:130
msgid "2.1.3 - a beta of 2.0 release"
msgstr "2.1.3 - бета-стадия версии 2.0"

#: ../doc/1.10/dev_guide/release_management.rst:131
msgid "2.2 - a stable version of 2.0 series, but not an LTS yet"
msgstr "2.2 - стабильная версия серии 2.0, но еще не LTS"

#: ../doc/1.10/dev_guide/release_management.rst:132
msgid "2.10 - an LTS release"
msgstr "2.10 - LTS-версия"

#: ../doc/1.10/dev_guide/release_management.rst:138
msgid "How to make a minor release"
msgstr "Как собрать минорную версию"

#: ../doc/1.10/dev_guide/release_management.rst:140
msgid ""
"$ git tag -a 2.4 -m \"Next minor in 2.x series\"\n"
"$ vim CMakeLists.txt # edit CPACK_PACKAGE_VERSION_PATCH\n"
"$ git push --tags"
msgstr ""
"$ git tag -a 2.4 -m \"Next minor in 2.x series\"\n"
"$ vim CMakeLists.txt # редактировать CPACK_PACKAGE_VERSION_PATCH\n"
"$ git push --tags"

#: ../doc/1.10/dev_guide/release_management.rst:146
msgid ""
"A tag which is made on a git branch can be taken along with a merge, or "
"left on the branch. The technique to \"keep the tag on the branch it was "
"originally set on\" is to use ``--no-fast-forward`` when merging this "
"branch."
msgstr ""
"Тег, который делается на ветке git, можно забрать при слиянии или "
"оставить на ветке. Метод \"сохранить тег на ветке, на которой он был "
"первоначально установлен\", заключается в использовании ``--no-fast-"
"forward`` при слиянии этой ветки."

#: ../doc/1.10/dev_guide/release_management.rst:150
msgid ""
"With ``--no-ff``, a merge changeset is created to represent the received "
"changes, and only that merge changeset ends up in the destination branch."
" This technique can be useful when there are two active lines of "
"development, e.g. \"stable\" and \"next\", and it's necessary to be able "
"to tag both lines independently."
msgstr ""
"С помощью ``--no-ff`` создается набор изменений при слиянии для пояснения"
" полученных изменений, и только этот набор изменений при слиянии "
"оказывается в ветке назначения. Этот метод можно использовать, когда есть"
" две активные линии разработки, например, \"стабильная\" и \"следующая\","
" и необходимо иметь возможность помечать тегами линии независимо друг от "
"друга."

#: ../doc/1.10/dev_guide/release_management.rst:156
msgid ""
"To make sure that a tag doesn't end up in the destination branch, it is "
"necessary to have the commit to which the tag is attached, \"stay on the "
"original branch\". That's exactly what a merge with disabled \"fast-"
"forward\" does -- creates a \"merge\" commit and adds it to both "
"branches."
msgstr ""
"Чтобы убедиться, что тег не окажется в ветке назначения, необходимо, "
"чтобы коммит, к которому привязан тег, остался в исходной ветке. Это и "
"происходит при отключенном \"fast-forward\" -- создается коммит для "
"слияния и добавляется в обе ветки."

#: ../doc/1.10/dev_guide/release_management.rst:161
msgid "Here's what it may look like:"
msgstr "Вот как это может выглядеть:"

#: ../doc/1.10/dev_guide/release_management.rst:163
msgid ""
"kostja@shmita:~/work/tarantool$ git checkout master\n"
"Already on 'master'\n"
"kostja@shmita:~/work/tarantool$ git tag -a 2.4 -m \"Next development\"\n"
"kostja@shmita:~/work/tarantool$ git describe\n"
"2.4\n"
"kostja@shmita:~/work/tarantool$ git checkout master-stable\n"
"Switched to branch 'master-stable'\n"
"kostja@shmita:~/work/tarantool$ git tag -a 2.3 -m \"Next stable\"\n"
"kostja@shmita:~/work/tarantool$ git describe\n"
"2.3\n"
"kostja@shmita:~/work/tarantool$ git checkout master\n"
"Switched to branch 'master'\n"
"kostja@shmita:~/work/tarantool$ git describe\n"
"2.4\n"
"kostja@shmita:~/work/tarantool$ git merge --no-ff master-stable\n"
"Auto-merging CMakeLists.txt\n"
"Merge made by recursive.\n"
" CMakeLists.txt |    1 +\n"
" 1 files changed, 1 insertions(+), 0 deletions(-)\n"
"kostja@shmita:~/work/tarantool$ git describe\n"
"2.4.0-0-g0a98576"
msgstr ""
"kostja@shmita:~/work/tarantool$ git checkout master\n"
"Already on 'master'\n"
"kostja@shmita:~/work/tarantool$ git tag -a 2.4 -m \"Next development\"\n"
"kostja@shmita:~/work/tarantool$ git describe\n"
"2.4\n"
"kostja@shmita:~/work/tarantool$ git checkout master-stable\n"
"Switched to branch 'master-stable'\n"
"kostja@shmita:~/work/tarantool$ git tag -a 2.3 -m \"Next stable\"\n"
"kostja@shmita:~/work/tarantool$ git describe\n"
"2.3\n"
"kostja@shmita:~/work/tarantool$ git checkout master\n"
"Switched to branch 'master'\n"
"kostja@shmita:~/work/tarantool$ git describe\n"
"2.4\n"
"kostja@shmita:~/work/tarantool$ git merge --no-ff master-stable\n"
"Auto-merging CMakeLists.txt\n"
"Merge made by recursive.\n"
" CMakeLists.txt |    1 +\n"
" 1 files changed, 1 insertions(+), 0 deletions(-)\n"
"kostja@shmita:~/work/tarantool$ git describe\n"
"2.4.0-0-g0a98576"

#: ../doc/1.10/dev_guide/release_management.rst:187
msgid "Also, don't forget this:"
msgstr "Кроме того, следует помнить:"

#: ../doc/1.10/dev_guide/release_management.rst:189
msgid "Update all issues. Upload the ChangeLog based on ``git log`` output."
msgstr ""
"Обновляйте все задачи. Обновляйте журнал изменений ChangeLog на основании"
" вывода ``git log``."

#: ../doc/1.10/dev_guide/release_management.rst:191
msgid ""
"The ChangeLog must only include items which are mentioned as issues on "
"GitHub. If anything significant is there, which is not mentioned, "
"something went wrong in release planning and the release should be held "
"up until this is cleared."
msgstr ""
"Журнал изменений ChangeLog должен включать в себя только пункты, "
"указанные в задачах на GitHub. Если что-то значительное не указано, "
"значит, что-то пошло не так при планировании версии, и ее выход следует "
"отложить до выяснения причин."

#: ../doc/1.10/dev_guide/release_management.rst:196
msgid ""
"Click 'Release milestone'. Create a milestone for the next minor release."
" Alert the driver to target bugs and blueprints to the new milestone."
msgstr ""
"Нажимайте 'Release milestone' (создать промежуточную версию). Создавайте "
"промежуточные версии для следующей минорной версии. Указывайте драйверу "
"на дефекты и проекты для новой промежуточной версии."

#: ../doc/1.10/dev_guide/release_management.rst:201
msgid "How to release a Docker container"
msgstr "Как выпустить Docker-контейнер"

#: ../doc/1.10/dev_guide/release_management.rst:203
msgid "To bump a new version of a Docker container:"
msgstr "Чтобы выдать новую версию Docker-контейнера:"

#: ../doc/1.10/dev_guide/release_management.rst:205
msgid ""
"On the ``master`` branch of `tarantool/docker "
"<https://github.com/tarantool/docker>`_ repository, find the Dockerfile "
"that corresponds to the commit's **major** version (e.g. "
"https://github.com/tarantool/docker/blob/master/2.x/Dockerfile for "
"Tarantool version 2.4) and specify the required commit in "
"``TARANTOOL_VERSION``, for example "
"``TARANTOOL_VERSION=2.4.0-11-gcd17b77f9``."
msgstr ""
"В главной ветке ``master`` в репозитории `tarantool/docker "
"<https://github.com/tarantool/docker>`_ найдите Dockerfile, который "
"соответствует **мажорной** версии коммита (например, "
"https://github.com/tarantool/docker/blob/master/2.4/Dockerfile for "
"Tarantool version 2.x), и укажите необходимый коммит в "
"``TARANTOOL_VERSION``, например, "
"``TARANTOOL_VERSION=2.4.0-11-gcd17b77f9``."

#: ../doc/1.10/dev_guide/release_management.rst:213
msgid "Commit the Dockerfile back to ``master`` branch."
msgstr "Снова загрузите Dockerfile в главную ветку."

#: ../doc/1.10/dev_guide/release_management.rst:215
msgid ""
"In the same repository, create a branch named after the commit's "
"``<major>.<minor>`` versions, e.g. branch ``2.4`` for commit "
"2.4.0-11-gcd17b77f9."
msgstr ""
"В том же репозитории создайте ветку с именем на основании версий коммита "
"``<major>.<minor>``, например, ветка ``2.4`` для коммита "
"2.4.0-11-gcd17b77f9."

#: ../doc/1.10/dev_guide/release_management.rst:219
msgid ""
"In Tarantool container build settings at ``hub.docker.com`` "
"(https://hub.docker.com/r/tarantool/tarantool/~/settings/automated-"
"builds/), add a new line:"
msgstr ""
"В настройках сборки контейнера Tarantool'а в ``hub.docker.com`` "
"(https://hub.docker.com/r/tarantool/tarantool/~/settings/automated-"
"builds/) добавьте новую строку:"

#: ../doc/1.10/dev_guide/release_management.rst:223
msgid "Branch: x.y, /x, x.y"
msgstr "Branch: x.y, /x, x.y"

#: ../doc/1.10/dev_guide/release_management.rst:227
msgid "where ``x`` and ``y`` correspond to the commit's major and minor versions."
msgstr "где ``x`` и ``y`` соответствуют мажорной и минорной версиям коммита."

#: ../doc/1.10/dev_guide/release_management.rst:229
msgid "Click **Save changes**."
msgstr "Нажмите **Save changes** (сохранить изменения)."

#: ../doc/1.10/dev_guide/release_management.rst:231
msgid "Shortly after, a new Docker container will be built."
msgstr "Вскоре будет создан новый Docker-контейнер."

#: ../doc/1.10/index.rst:40
msgid "Tarantool - Documentation"
msgstr "Tarantool - Документация"

#: ../doc/1.10/index.rst:47
msgid "|nbspc|"
msgstr "|nbspc|"

#: ../doc/1.10/index.rst:119
#, fuzzy
msgid ""
"Tarantool 1.10 manual  This manual embraces all aspects of using "
"Tarantool: from introductory information and exercises for beginners -- "
"to advanced instructions and detailed references for power users and "
"contributors.  Документация находится в процессе перевода и может "
"отставать от английской версии.  <div class=\"getting-started-button-"
"container\">     <a href=\"book/getting_started/\">         <button class"
"=\"getting-started-button btn\">             Руководство для начинающих"
"         </button>     </a> </div>  <div class=\"getting-started-button-"
"container\">     <a href=\"book/getting_started/\">         <button class"
"=\"getting-started-button btn\">             Getting started         "
"</button>     </a> </div>      <div class=\"badge-icon\"></div>  Other "
"formats:  Single-page HTML  PDF  /Users/e.shebunyaeva/work/tarantool-"
"doc/doc/1.10/index.rst:106: (WARNING/2) Bullet list ends without a blank "
"line; unexpected unindent.  See also:  Documentation archive  Articles  "
"/Users/e.shebunyaeva/work/tarantool-doc/doc/1.10/index.rst:109: "
"(WARNING/2) Bullet list ends without a blank line; unexpected unindent.  "
"Support:  Форум в Google  Чат в Telegram  Support:  Google forum  "
"Telegram chat"
msgstr ""
"Руководство по Tarantool 1.10 Данное руководство охватывает все "
"аспекты использования Tarantool'а: от вводной информации и упражнений для"
" начинающих -- до продвинутых инструкций и подробных справочников для "
"опытных пользователей и сторонних разработчиков.  Документация находится "
"в процессе перевода и может отставать от английской версии.      <div "
"class=\"badge-icon\"></div>  Другие форматы:  HTML одной страницей  PDF  "
"/Users/e.shebunyaeva/work/tarantool-doc-TMP/doc/1.10/index.rst:84: "
"(WARNING/2) Bullet list ends without a blank line; unexpected unindent.  "
"См. также:  Архив документации  Статьи  /Users/e.shebunyaeva/work"
"/tarantool-doc-TMP/doc/1.10/index.rst:87: (WARNING/2) Bullet list ends "
"without a blank line; unexpected unindent.  Поддержка:  Форум в Google  "
"Чат в Telegram  Поддержка:  Форум в Google  Чат в Telegram"

#: ../doc/1.10/index.rst:56
msgid "Tarantool 1.10 manual"
msgstr "Руководство по Tarantool 1.10"

#: ../doc/1.10/index.rst:60
msgid ""
"This manual embraces all aspects of using Tarantool: from introductory "
"information and exercises for beginners -- to advanced instructions and "
"detailed references for power users and contributors."
msgstr ""
"Данное руководство охватывает все аспекты использования Tarantool'а: от "
"вводной информации и упражнений для начинающих -- до продвинутых "
"инструкций и подробных справочников для опытных пользователей и сторонних"
" разработчиков."

#: ../doc/1.10/index.rst:103
msgid "**Other formats:**"
msgstr "**Другие форматы:**"

#: ../doc/1.10/index.rst:104
msgid "`Single-page HTML <singlehtml.html>`_"
msgstr "`HTML одной страницей <singlehtml.html>`_"

#: ../doc/1.10/index.rst:105
msgid "`PDF <Tarantool.pdf>`_"
msgstr "`PDF <Tarantool.pdf>`_"

#: ../doc/1.10/index.rst:106
msgid "**See also:**"
msgstr "**См. также:**"

#: ../doc/1.10/index.rst:107
msgid "`Documentation archive`_"
msgstr "`Архив документации`_"

#: ../doc/1.10/index.rst:108
msgid "`Articles`_"
msgstr "`Статьи`_"

#: ../doc/1.10/index.rst:116
msgid "**Support:**"
msgstr "**Поддержка:**"

#: ../doc/1.10/index.rst:117
msgid "`Google forum`_"
msgstr "`Форум в Google`_"

#: ../doc/1.10/index.rst:118
msgid "`Telegram chat`_"
msgstr "`Чат в Telegram`_"

#: ../doc/1.10/intro.rst:41
msgid "An application server together with a database manager"
msgstr "Сервер приложений + СУБД"

#: ../doc/1.10/intro.rst:43
msgid ""
"Tarantool is a Lua application server integrated with a database "
"management system. It has a \"fiber\" model which means that many "
"Tarantool applications can run simultaneously on a single thread, while "
"each instance of the Tarantool server itself can run multiple threads for"
" input-output and background maintenance. It incorporates the LuaJIT -- "
"\"Just In Time\" -- Lua compiler, Lua libraries for most common "
"applications, and the Tarantool Database Server which is an established "
"NoSQL DBMS. Thus Tarantool serves all the purposes that have made node.js"
" and Twisted popular, plus it supports data persistence."
msgstr ""
"Tarantool представляет собой сервер приложений на языке Lua, "
"интегрированный с СУБД. В основе Tarantool'а лежат файберы (fibers), что "
"означает, что несколько Tarantool-приложений могут работать в одном "
"потоке (thread), при этом каждый экземпляр Tarantool-сервера может "
"одновременно запускать несколько потоков для обработки ввода-вывода "
"данных и фоновых задач. Tarantool включает в себя LuaJIT (Just In Time) -"
" Lua-компилятор, Lua-библиотеки для наиболее распространенных приложений,"
" а также сервер базы данных Tarantool'а, который представляет собой "
"широко признанную СУБД NoSQL. Таким образом, Tarantool используется для "
"всех тех целей, которые принесли популярность node.js и Twisted, и более "
"того - поддерживает персистентность данных."

#: ../doc/1.10/intro.rst:51
msgid ""
"The code is free. The open-source license is `BSD license`_. The "
"supported platforms are GNU/Linux, Mac OS and FreeBSD."
msgstr ""
"Tarantool -- это open-source проект. Исходный код открыт для всех и "
"распространяется бесплатно согласно лицензии `BSD license`_. "
"Поддерживаемые платформы: GNU / Linux, Mac OS и FreeBSD."

#: ../doc/1.10/intro.rst:54
msgid ""
"Tarantool's creator and biggest user is `Mail.Ru`_, the largest internet "
"company in Russia, with 30 million users, 25 million emails per day, and "
"a web site whose Alexa global rank is in the `top 40`_ worldwide. "
"Tarantool services Mail.Ru's hottest data, such as the session data of "
"online users, the properties of online applications, the caches of the "
"underlying data, the distribution and sharding algorithms, and much more."
" Outside Mail.Ru the software is used by a growing number of projects in "
"online gaming, digital marketing, and social media industries. Although "
"Mail.Ru is the sponsor for product development, the roadmap and the bugs "
"database and the development process are fully open. The software "
"incorporates patches from dozens of community contributors. The Tarantool"
" community writes and maintains most of the drivers for programming "
"languages.  The greater Lua community has hundreds of useful packages "
"most of which can become Tarantool extensions."
msgstr ""
"Создателем Tarantool'а -- а также его основным пользователем -- является "
"компания `Mail.Ru`_, крупнейшая Интернет-компания России (30 млн "
"пользователей, 25 млн электронных писем в день, веб-сайт в списке `top "
"40`_ международного Alexa-рейтинга). Tarantool используется для обработки"
"  самых \"горячих\" данных Mail.Ru, таких как данные пользовательских "
"онлайн-сессий, настройки онлайн-приложений, кэширование сервисных данных,"
"  алгоритмы распределения данных и шардинга, и т.д. Tarantool также "
"используется во всё большем количестве проектов вне стен Mail.Ru. Это, к "
"примеру, онлайн-игры, цифровой маркетинг, социальные сети. Несмотря на то"
"  что Mail.Ru спонсирует разработку Tarantool'а, весь процесс разработки,"
" в т.ч. дальнейшие планы и база обнаруженных ошибок, является полностью "
"открытым. В Tarantool включены патчи от большого числа сторонних "
"разработчиков. Усилиями сообщества разработчиков Tarantool'а были "
"написаны (и далее поддерживаются) библиотеки для подключения модулей на "
"внешних языках программирования. А сообщество Lua-разработчиков "
"предоставило сотни полезных пакетов, большинство из которых можно "
"использовать в качестве расширений для Tarantool'а."

#: ../doc/1.10/intro.rst:68
msgid ""
"Users can create, modify and drop **Lua functions** at runtime. Or they "
"can define **Lua programs** that are loaded during startup for triggers, "
"background tasks, and interacting with networked peers. Unlike popular "
"application development frameworks based on a \"reactor\" pattern, "
"networking in server-side Lua is sequential, yet very efficient, as it is"
" built on top of the **cooperative multitasking** environment that "
"Tarantool itself uses."
msgstr ""
"Пользователи Tarantool'а могут создавать, изменять и удалять "
"**Lua-функции** прямо во время исполнения кода. Также они могут указывать"
"  **Lua-программы**, которые будут загружаться во время запуска "
"Tarantool'а. Такие программы могут служить триггерами, выполнять фоновые "
"задачи и взаимодействовать с другими узлами по сети. В отличие от многих "
"популярных сред разработки приложений, которые используют \"реактивный\" "
"принцип, сетевое взаимодействие в Lua устроено последовательно, но очень "
"эффективно, т.к. оно использует среду **кооперативной многозадачности** "
"самого Tarantool'а."

#: ../doc/1.10/intro.rst:76
msgid ""
"One of the built-in Lua packages provides an API for the Database "
"Management System. Thus some developers see Tarantool as a DBMS with a "
"popular stored procedure language, while others see it as a Lua "
"interpreter, while still others see it as a replacement for many "
"components of multi-tier Web applications. Performance can be a few "
"hundred thousand transactions per second on a laptop, scalable upwards or"
" outwards to server farms."
msgstr ""
"Один из встраиваемых Lua-пакетов -- это API для функций СУБД. Таким "
"образом, некоторые разработчики рассматривают Tarantool как СУБД с "
"популярным языком для написания хранимых процедур, другие рассматривают "
"его как Lua-интерпретатор, а третьи -- как вариант замены сразу "
"нескольких компонентов в многозвенных веб-приложениях. Производительность"
" Tarantool'а может достигать сотен тысяч транзакций в секунду на "
"ноутбуке, и ее можно наращивать \"вверх\" или \"вширь\" за счет новых "
"серверных ферм."

#: ../doc/1.10/intro.rst:86
msgid "Database features"
msgstr "Возможности СУБД"

#: ../doc/1.10/intro.rst:88
msgid ""
"Tarantool can run without it, but \"The Box\" -- the DBMS server -- is a "
"strong distinguishing feature."
msgstr ""
"Компонент \"box\" -- серверная часть с функциями СУБД -- это важная часть"
" Tarantool'а, хотя он может работать и без данного компонента."

#: ../doc/1.10/intro.rst:91
msgid ""
"The database API allows for permanently storing Lua objects, managing "
"object collections, creating or dropping secondary keys, making changes "
"atomically, configuring and monitoring replication, performing controlled"
" fail-over, and executing Lua code triggered by database events. Remote "
"database instances are accessible transparently via a remote-procedure-"
"invocation API."
msgstr ""
"API для функций СУБД позволяет хранить Lua-объекты, управлять коллекциями"
" объектов, создавать и удалять вторичные ключи, делать атомарные "
"изменения, конфигурировать и мониторить репликацию, производить  "
"контролируемое переключение при отказе (failover), а также исполнять код"
"  на Lua, который вызывается событиями в базе. А для прозрачного доступа "
"к  удаленным (remote) экземплярам баз данных разработан API для вызова "
"удаленных процедур."

#: ../doc/1.10/intro.rst:99
msgid ""
"Tarantool's DBMS server uses the **storage engine** concept, where "
"different sets of algorithms and data structures can be used for "
"different situations. Two storage engines are built-in: an in-memory "
"engine which has all the data and indexes in RAM, and a two-level B-tree "
"engine for data sets whose size is 10 to 1000 times the amount of "
"available RAM. All storage engines in Tarantool support transactions and "
"replication by using a common **write ahead log** (WAL). This ensures "
"consistency and crash safety of the persistent state. Changes are not "
"considered complete until the WAL is written. The logging subsystem "
"supports group commit."
msgstr ""
"В архитектуре серверной части СУБД Tarantool'а реализована концепция "
"\"движков\" базы данных (storage engines), где в разных ситуациях "
"используются разные наборы алгоритмов и структуры данных. В Tarantool'е "
"есть два встроенных движка: in-memory движок, который держит все данные и"
"  индексы в оперативной памяти, и двухуровневый движок для B-деревьев, "
"который обрабатывает данные размером в 10-1000 раз больше того, что может"
"  поместиться в оперативной памяти. Все движки в Tarantool'е поддерживают"
" транзакции и репликацию, поскольку они используют единый механизм "
"**упреждающей записи** (WAL = write ahead log). Это механизм обеспечивает"
"  согласованность и сохранность данных при сбоях. Таким образом, "
"изменения  не считаются завершенными, пока не проходит запись в лог WAL. "
"Подсистема записи в журнал также поддерживает групповые коммиты."

#: ../doc/1.10/intro.rst:110
msgid ""
"**Tarantool's in-memory storage engine** (memtx) keeps all the data in "
"random-access memory, and therefore has very low read latency. It also "
"keeps persistent copies of the data in non-volatile storage, such as "
"disk, when users request \"snapshots\". If an instance of the server "
"stops and the random-access memory is lost, then restarts, it reads the "
"latest snapshot and then replays the transactions that are in the log -- "
"therefore no data is lost."
msgstr ""
"**In-memory движок базы данных Tarantool'а** (memtx) хранит все данные в "
"оперативной памяти, поэтому у него низкое значение задержки чтения. Кроме"
" того, когда пользователи запрашивают снимки данных (snapshots), этот "
"движок создает персистентные копии данных в энергонезависимой памяти, "
"например на диске. Если экземпляр сервера прекращает работать и данные в "
"оперативной памяти теряются, то при следующем запуске сервер загрузит в "
"память самый свежий снимок и воспроизведет все транзакции из журнала. "
"Таким образом, данные не теряются."

#: ../doc/1.10/intro.rst:119
msgid ""
"**Tarantool's in-memory engine is lock-free** in typical situations. "
"Instead of the operating system's concurrency primitives, such as "
"mutexes, Tarantool uses cooperative multitasking to handle thousands of "
"connections simultaneously. There is a fixed number of independent "
"execution threads. The threads do not share state. Instead they exchange "
"data using low-overhead message queues. While this approach limits the "
"number of cores that the instance will use, it removes competition for "
"the memory bus and ensures peak scalability of memory access and network "
"throughput. CPU utilization of a typical highly-loaded Tarantool instance"
" is under 10%. Searches are possible via **secondary index keys** as well"
" as primary keys."
msgstr ""
"В штатных ситуациях **in-memory движок работает без блокировок**. Вместо "
"многопоточных примитивов, которые предлагает операционная система (таких "
"как mutex'ы), Tarantool использует кооперативную многозадачность для "
"работы с тысячами соединений одновременно. В Tarantool'е есть "
"фиксированное количество независимых потоков управления (thread), и у них"
" нет общего состояния. Для обмена данными между потоками используются "
"очереди сообщений с малой перегрузкой. Хотя такой подход накладывает "
"ограничение на количество процессорных ядер, которые может использовать "
"экземпляр, в то же время он позволяет избежать борьбы за шину памяти, а "
"также дает запас масштабируемости по скорости доступа к памяти и "
"производительности сети. В результате даже при большой нагрузке экземпляр"
" Tarantool'а в среднем использует процессор менее чем на 10%. Кроме того,"
" Tarantool поддерживает поиск как по первичным, так и по **внешним ключам"
" в индексах**."

#: ../doc/1.10/intro.rst:129
msgid ""
"**Tarantool's disk-based storage engine** is a fusion of ideas from "
"modern filesystems, log-structured merge trees and classical B-trees. All"
" data is organized into **ranges**. Each range is represented by a file "
"on disk. Range size is a configuration option and normally is around "
"64MB. Each range is a collection of pages, serving different purposes. "
"Pages in a fully merged range contain non-overlapping ranges of keys. A "
"range can be partially merged if there were a lot of changes in its key "
"range recently. In that case some pages represent new keys and values in "
"the range. The disk-based storage engine is append only: new data never "
"overwrites old data. The disk-based storage engine is named *vinyl*."
msgstr ""
"**Дисковый движок базы данных Tarantool'а** совмещает в себе подходы, "
"заимствованные из современных файловых систем, "
"журнально-структурированных деревьев со слиянием (log-structured merge "
"trees) и классических B-деревьев. Все данные разбиты на **диапазоны**. "
"Каждый диапазон представлен файлом на диске. Размер диапазона можно "
"изменять, обычно он равен 64МБ. Каждый диапазон -- это набор страниц, "
"которые служат разным целям. После полного слияния диапазона ключи на его"
" страницах не пересекаются. Если диапазоны ключей недавно сильно "
"изменялись, можно провести частичное слияние диапазона. В этом случае на "
"некоторых страницах появились новые ключи и значения. Дисковый движок "
"обновляет данные по принципу дописывания в конец: новые данные никогда не"
" затирают старые. Дисковый движок базы данных называется *vinyl*."

#: ../doc/1.10/intro.rst:140
msgid ""
"Tarantool supports **multi-part index keys**. The possible index types "
"are HASH, TREE, BITSET, and RTREE."
msgstr ""
"Tarantool поддерживает работу с **составными ключами в индексах**. "
"Возможные типы ключей: HASH, TREE, BITSET и RTREE."

#: ../doc/1.10/intro.rst:143
msgid ""
"Tarantool supports **asynchronous replication**, locally or to remote "
"hosts. The replication architecture can be **master-master**, that is, "
"many nodes may both handle the loads and receive what others have "
"handled, for the same data sets."
msgstr ""
"Tarantool также поддерживает **асинхронную репликацию** -- как локальную,"
" так и на удаленных серверах. При этом репликацию можно настроить по "
"принципу **мастер-мастер**, когда несколько узлов могут не только "
"обрабатывать входящую нагрузку, но и получать данные от других узлов."

#: ../doc/1.10/reference/configuration/index.rst:39
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1032
msgid "Configuration reference"
msgstr "Справочник по настройке"

#: ../doc/1.10/reference/configuration/index.rst:41
msgid ""
"This reference covers all options and parameters which can be set for "
"Tarantool on the command line or in an :ref:`initialization file <index-"
"init_label>`."
msgstr ""
"В данном справочнике рассматриваются все опции и параметры, которые можно"
" использовать в командной строке или в :ref:`файле инициализации <index-"
"init_label>`."

#: ../doc/1.10/reference/configuration/index.rst:44
msgid "Tarantool is started by entering either of the following command:"
msgstr "Tarantool можно запустить путем ввода одной из следующих команд:"

#: ../doc/1.10/reference/configuration/index.rst:49
msgid ""
"$ **tarantool**\n"
"\n"
"$ **tarantool** *options*\n"
"\n"
"$ **tarantool** *lua-initialization-file* **[** *arguments* **]**"
msgstr ""
"$ **tarantool**\n"
"\n"
"$ **tarantool** *options*\n"
"\n"
"$ **tarantool** *lua-initialization-file* **[** *arguments* **]**"

#: ../doc/1.10/reference/configuration/index.rst:57
msgid "Command options"
msgstr "Опции командной строки"

#: ../doc/1.10/reference/configuration/index.rst:61
msgid "Print an annotated list of all available options and exit."
msgstr "Вывод аннотированного списка всех доступных опций и выход."

#: ../doc/1.10/reference/configuration/index.rst:67
msgid "Print product name and version, for example:"
msgstr "Вывод названия и версии продукта, например:"

#: ../doc/1.10/reference/configuration/index.rst:69
msgid ""
"$ ./tarantool --version\n"
"Tarantool 1.7.0-1216-g73f7154\n"
"Target: Linux-x86_64-Debug\n"
"..."
msgstr ""
"$ ./tarantool --version\n"
"Tarantool 1.7.0-1216-g73f7154\n"
"Target: Linux-x86_64-Debug\n"
"..."

#: ../doc/1.10/reference/configuration/index.rst:76
msgid "In this example:"
msgstr "В данном примере:"

#: ../doc/1.10/reference/configuration/index.rst:78
msgid ""
"“Tarantool” is the name of the reusable asynchronous networking "
"programming framework."
msgstr ""
"“Tarantool” -- это название многократно используемого асинхронного сетевого фреймворка."

#: ../doc/1.10/reference/configuration/index.rst:81
msgid ""
"The 3-number version follows the standard ``<major>-<minor>-<patch>`` "
"scheme, in which ``<major>`` number is changed only rarely, ``<minor>`` "
"is incremented for each new milestone and indicates possible incompatible"
" changes, and ``<patch>`` stands for the number of bug fix releases made "
"after the start of the milestone. For non-released versions only, there "
"may be a commit number and commit SHA1 to indicate how much this "
"particular build has diverged from the last release."
msgstr ""
"Версия из 3 чисел создается по стандартной схеме "
"``<мажорная>-<минорная>-<патч-версия>``, где ``<мажорная>`` версия "
"изменяется редко, ``<минорная>`` последовательно увеличивается с каждым "
"новым выпущенным стабильным релизом и указывает на возможные "
"несовместимые изменения, а ``<патч-версия>`` означает количество версий с"
" исправленными ошибками с момента выхода стабильного релиза. Еще не "
"вышедшие версии могут также содержать номер коммита и коммит SHA1, чтобы "
"показать, насколько данная сборка отходит от последнего релиза."

#: ../doc/1.10/reference/configuration/index.rst:89
msgid ""
"“Target” is the platform tarantool was built on. Some platform-specific "
"details may follow this line."
msgstr ""
"“Target” -- это платформа, на которой собран Tarantool. Некоторые "
"платформенно-зависимые детали могут следовать за этой строкой."

#: ../doc/1.10/reference/configuration/index.rst:94
msgid ""
"Tarantool uses `git describe "
"<http://www.kernel.org/pub/software/scm/git/docs/git-describe.html>`_ to "
"produce its version id, and this id can be used at any time to check out "
"the corresponding source from our `git repository "
"<http://github.com/tarantool/tarantool.git>`_."
msgstr ""
"При выставлении номера версии Tarantool'а применяется `git describe "
"<http://www.kernel.org/pub/software/scm/git/docs/git-describe.html>`_, и "
"этот номер версии можно в любое время использовать для проверки "
"соответствующего исходного кода в `репозитории git "
"<http://github.com/tarantool/tarantool.git>`_."

#: ../doc/1.10/reference/configuration/index.rst:104
msgid "URI"
msgstr "Унифицированный идентификатор ресурса (URI)"

#: ../doc/1.10/reference/configuration/index.rst:106
msgid ""
"Some configuration parameters and some functions depend on a URI, or "
"\"Universal Resource Identifier\". The URI string format is similar to "
"the `generic syntax for a URI schema "
"<http://en.wikipedia.org/wiki/URI_scheme#Generic_syntax>`_. So it may "
"contain (in order) a user name for login, a password, a host name or host"
" IP address, and a port number. Only the port number is always mandatory."
" The password is mandatory if the user name is specified, unless the user"
" name is 'guest'. So, formally, the URI syntax is ``[host:]port`` or "
"``[username:password@]host:port``. If host is omitted, then '0.0.0.0' or "
"'[::]' is assumed, meaning respectively any IPv4 address or any IPv6 "
"address, on the local machine. If username:password is omitted, then "
"'guest' is assumed. Some examples:"
msgstr ""
"Некоторые конфигурационные параметры и некоторые функции зависимы от URI "
"(унифицированного идентификатора ресурса). Формат URI-строки похож на "
"`общий синтаксис URI-схемы "
"<http://en.wikipedia.org/wiki/URI_scheme#Generic_syntax>`_. Он может "
"содержать следующие данные (указаны по порядку): имя пользователя для "
"входа в систему, пароль, имя хоста или IP-адрес хоста и номер порта. "
"Обязательным параметром является только номер порта. Пароль является "
"обязательным, только если указано имя пользователя -- за исключением "
"случаев, когда пользователем будет 'guest'. Формально URI-синтаксис "
"представляет собой ``[хост:]порт`` или "
"``[имя-пользователя:пароль@]хост:порт``. Если хост не указан, то "
"предполагается хост '0.0.0.0' или '[::]', что означает любой IPv4-адрес "
"или IPv6-адрес на локальной машине соответственно. Если не указать "
"имя-пользователя:пароль, предполагается, что пользователем будет 'guest'."
" Некоторые примеры:"

#: ../doc/1.10/reference/configuration/index.rst:125
msgid "URI fragment"
msgstr "Фрагмент URI"

#: ../doc/1.10/reference/configuration/index.rst:127
msgid "port"
msgstr "порт"

#: ../doc/1.10/reference/configuration/index.rst:127
msgid "3301"
msgstr "3301"

#: ../doc/1.10/reference/configuration/index.rst:129
msgid "host:port"
msgstr "хост:порт"

#: ../doc/1.10/reference/configuration/index.rst:129
msgid "127.0.0.1:3301"
msgstr "127.0.0.1:3301"

#: ../doc/1.10/reference/configuration/index.rst:131
msgid "username:password@host:port"
msgstr "имя-пользователя:пароль@хост:порт"

#: ../doc/1.10/reference/configuration/index.rst:131
msgid "notguest:sesame@mail.ru:3301"
msgstr "notguest:sesame@mail.ru:3301"

#: ../doc/1.10/reference/configuration/index.rst:134
msgid ""
"In certain circumstances a Unix domain socket may be used where a URI is "
"expected, for example \"unix/:/tmp/unix_domain_socket.sock\" or simply "
"\"/tmp/unix_domain_socket.sock\"."
msgstr ""
"В определенных обстоятельствах можно использовать доменный сокет Unix, "
"когда ожидается URI, например, ``unix/:/tmp/unix_domain_socket.sock`` или"
" просто ``/tmp/unix_domain_socket.sock``."

#: ../doc/1.10/reference/configuration/index.rst:138
msgid "A method for parsing URIs is illustrated in :ref:`Module uri <uri-parse>`."
msgstr ""
"Метод разбора URI проиллюстрирован в справочнике по :ref:`модулю uri "
"<uri-parse>`."

#: ../doc/1.10/reference/configuration/index.rst:144
msgid "Initialization file"
msgstr "Файл инициализации"

#: ../doc/1.10/reference/configuration/index.rst:146
msgid ""
"If the command to start Tarantool includes :codeitalic:`lua-"
"initialization-file`, then Tarantool begins by invoking the Lua program "
"in the file, which by convention may have the name \"``script.lua``\". "
"The Lua program may get further arguments from the command line or may "
"use operating-system functions, such as ``getenv()``. The Lua program "
"almost always begins by invoking ``box.cfg()``, if the database server "
"will be used or if ports need to be opened. For example, suppose "
"``script.lua`` contains the lines"
msgstr ""
"Если команда запуска Tarantool'а включает в себя :codeitalic:`файл "
"инициализации`, то Tarantool запустится посредством вызова Lua-программы "
"из этого файла, который обычно называется \"``script.lua``\". В "
"Lua-программу можно добавить дополнительные аргументы из командной строки"
" или функции операционной системы, такие как ``getenv()``. Lua-программа "
"практически всегда запускается посредством вызова ``box.cfg()``, если "
"будет использоваться сервер базы данных или же необходимо открыть порты. "
"Например, предположим, что файл ``script.lua`` содержит строки:"

#: ../doc/1.10/reference/configuration/index.rst:154
msgid ""
"#!/usr/bin/env tarantool\n"
"box.cfg{\n"
"    listen              = os.getenv(\"LISTEN_URI\"),\n"
"    memtx_memory        = 100000,\n"
"    pid_file            = \"tarantool.pid\",\n"
"    rows_per_wal        = 50\n"
"}\n"
"print('Starting ', arg[1])"
msgstr ""
"#!/usr/bin/env tarantool\n"
"box.cfg{\n"
"   listen              = os.getenv(\"LISTEN_URI\"),\n"
"   memtx_memory        = 100000,\n"
"   pid_file            = \"tarantool.pid\",\n"
"   rows_per_wal        = 50\n"
"}\n"
"print('Starting ', arg[1])"

#: ../doc/1.10/reference/configuration/index.rst:165
msgid ""
"and suppose the environment variable LISTEN_URI contains 3301, and "
"suppose the command line is ``~/tarantool/src/tarantool script.lua ARG``."
" Then the screen might look like this:"
msgstr ""
"и предположим, что переменная окружения LISTEN_URI содержит значение "
"3301, а также предположим, что в командной строке "
"``~/tarantool/src/tarantool script.lua ARG``. Тогда вывод на экране может"
" выглядеть следующим образом:"

#: ../doc/1.10/reference/configuration/index.rst:169
msgid ""
"$ export LISTEN_URI=3301\n"
"$ ~/tarantool/src/tarantool script.lua ARG\n"
"... main/101/script.lua C> version 1.7.0-1216-g73f7154\n"
"... main/101/script.lua C> log level 5\n"
"... main/101/script.lua I> mapping 107374184 bytes for a shared arena...\n"
"... main/101/script.lua I> recovery start\n"
"... main/101/script.lua I> recovering from './00000000000000000000.snap'\n"
"... main/101/script.lua I> primary: bound to 0.0.0.0:3301\n"
"... main/102/leave_local_hot_standby I> ready to accept requests\n"
"Starting  ARG\n"
"... main C> entering the event loop"
msgstr ""
"$ export LISTEN_URI=3301\n"
"$ ~/tarantool/src/tarantool script.lua ARG\n"
"... main/101/script.lua C> version 1.7.0-1216-g73f7154\n"
"... main/101/script.lua C> log level 5\n"
"... main/101/script.lua I> mapping 107374184 bytes for a shared "
"arena...... main/101/script.lua I> recovery start\n"
"... main/101/script.lua I> recovering from "
"'./00000000000000000000.snap'... main/101/script.lua I> primary: bound to"
" 0.0.0.0:3301\n"
"... main/102/leave_local_hot_standby I> ready to accept requests\n"
"Starting  ARG\n"
"... main C> entering the event loop"

#: ../doc/1.10/reference/configuration/index.rst:183
msgid ""
"If you wish to start an interactive session on the same terminal after "
"initialization is complete, you can use :ref:`console.start() <console-"
"start>`."
msgstr ""
"Если необходимо начать интерактивную сессию на том же терминале по "
"окончании инициализации, можно использовать :ref:`console.start() "
"<console-start>`."

#: ../doc/1.10/reference/configuration/index.rst:199
msgid "Configuration parameters"
msgstr "Конфигурационные параметры"

#: ../doc/1.10/reference/configuration/index.rst:201
msgid "Configuration parameters have the form:"
msgstr "Конфигурационные параметры выглядят так:"

#: ../doc/1.10/reference/configuration/index.rst:203
msgid ":extsamp:`{**{box.cfg}**}{[{*{key = value}*} [, {*{key = value ...}*}]]}`"
msgstr ""
":extsamp:`{**{box.cfg}**}{[{*{ключ = значение}*} [, {*{ключ = значение "
"...}*}]]}`"

#: ../doc/1.10/reference/configuration/index.rst:205
msgid ""
"Since ``box.cfg`` may contain many configuration parameters and since "
"some of the parameters (such as directory addresses) are semi-permanent, "
"it's best to keep ``box.cfg`` in a Lua file. Typically this Lua file is "
"the initialization file which is specified on the tarantool command line."
msgstr ""
"Поскольку в ``box.cfg`` может быть множество конфигурационных параметров,"
" а некоторые параметры (такие как адреса директорий) являются "
"полупостоянными, лучше всего хранить ``box.cfg`` в Lua-файле. Как "
"правило, такой Lua-файл представляет собой файл инициализации, который "
"указан в командной строке Tarantool'а."

#: ../doc/1.10/reference/configuration/index.rst:210
msgid ""
"Most configuration parameters are for allocating resources, opening "
"ports, and specifying database behavior. All parameters are optional. A "
"few parameters are dynamic, that is, they can be changed at runtime by "
"calling ``box.cfg{}`` a second time."
msgstr ""
"Большинство конфигурационных параметров предназначены для распределения "
"ресурсов, открытия портом и указания поведения базы данных. Все параметры"
" необязательны. Некоторые параметры динамичны, то есть могут изменяться "
"во время исполнения кода посредством повторного вызова ``box.cfg{}``."

#: ../doc/1.10/reference/configuration/index.rst:215
msgid ""
"To see all the non-null parameters, say ``box.cfg`` (no parentheses). To "
"see a particular parameter, for example the listen address, say "
"``box.cfg.listen``."
msgstr ""
"Чтобы увидеть все ненулевые параметры, выполните ``box.cfg`` (без круглых"
" скобок). Чтобы увидеть определенный параметр, например, адрес для "
"прослушивания, выполните команду ``box.cfg.listen``."

#: ../doc/1.10/reference/configuration/index.rst:218
msgid ""
"The following sections describe all parameters for basic operation, for "
"storage, for binary logging and snapshots, for replication, for "
"networking, for logging, and for feedback."
msgstr ""
"В последующих разделах описаны все параметры для основных возможностей, "
"для хранения, для записи в бинарный журнал и создания снимков, для "
"репликации, для работы по сети, для журналирования и для обратной связи."

#: ../doc/1.10/reference/configuration/index.rst:224
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1038
msgid "Basic parameters"
msgstr "Базовые параметры"

#: ../doc/1.10/reference/configuration/cfg_basic.rst:1
msgid ":ref:`background <cfg_basic-background>`"
msgstr ":ref:`background <cfg_basic-background>`"

#: ../doc/1.10/reference/configuration/cfg_basic.rst:2
msgid ":ref:`custom_proc_title <cfg_basic-custom_proc_title>`"
msgstr ":ref:`custom_proc_title <cfg_basic-custom_proc_title>`"

#: ../doc/1.10/reference/configuration/cfg_basic.rst:3
msgid ":ref:`listen <cfg_basic-listen>`"
msgstr ":ref:`listen <cfg_basic-listen>`"

#: ../doc/1.10/reference/configuration/cfg_basic.rst:4
msgid ":ref:`memtx_dir <cfg_basic-memtx_dir>`"
msgstr ":ref:`memtx_dir <cfg_basic-memtx_dir>`"

#: ../doc/1.10/reference/configuration/cfg_basic.rst:5
msgid ":ref:`pid_file <cfg_basic-pid_file>`"
msgstr ":ref:`pid_file <cfg_basic-pid_file>`"

#: ../doc/1.10/reference/configuration/cfg_basic.rst:6
msgid ":ref:`read_only <cfg_basic-read_only>`"
msgstr ":ref:`read_only <cfg_basic-read_only>`"

#: ../doc/1.10/reference/configuration/cfg_basic.rst:7
msgid ":ref:`vinyl_dir <cfg_basic-vinyl_dir>`"
msgstr ":ref:`vinyl_dir <cfg_basic-vinyl_dir>`"

#: ../doc/1.10/reference/configuration/cfg_basic.rst:8
msgid ":ref:`vinyl_timeout <cfg_basic-vinyl_timeout>`"
msgstr ":ref:`vinyl_timeout <cfg_basic-vinyl_timeout>`"

#: ../doc/1.10/reference/configuration/cfg_basic.rst:9
msgid ":ref:`username <cfg_basic-username>`"
msgstr ":ref:`username <cfg_basic-username>`"

#: ../doc/1.10/reference/configuration/cfg_basic.rst:10
msgid ":ref:`wal_dir <cfg_basic-wal_dir>`"
msgstr ":ref:`wal_dir <cfg_basic-wal_dir>`"

#: ../doc/1.10/reference/configuration/cfg_basic.rst:11
msgid ":ref:`work_dir <cfg_basic-work_dir>`"
msgstr ":ref:`work_dir <cfg_basic-work_dir>`"

#: ../doc/1.10/reference/configuration/cfg_basic.rst:12
msgid ":ref:`worker_pool_threads <cfg_basic-worker_pool_threads>`"
msgstr ":ref:`worker_pool_threads <cfg_basic-worker_pool_threads>`"

#: ../doc/1.10/reference/configuration/cfg_basic.rst:18
msgid ""
"Run the server as a background task. The :ref:`log <cfg_logging-log>` and"
" :ref:`pid_file <cfg_basic-pid_file>` parameters must be non-null for "
"this to work."
msgstr ""
"Запуск сервера в виде фоновой задачи. Параметры :ref:`log <cfg_logging-"
"log>` и :ref:`pid_file <cfg_basic-pid_file>` должны быть не равны нулю, "
"что это сработало."

#: ../doc/1.10/reference/configuration/cfg_basic.rst:22
#: ../doc/1.10/reference/configuration/cfg_basic.rst:111
#: ../doc/1.10/reference/configuration/cfg_binary_logging_snapshots.rst:22
#: ../doc/1.10/reference/configuration/cfg_deprecated.rst:25
#: ../doc/1.10/reference/configuration/cfg_deprecated.rst:55
#: ../doc/1.10/reference/configuration/cfg_deprecated.rst:66
#: ../doc/1.10/reference/configuration/cfg_hot_standby.rst:48
#: ../doc/1.10/reference/configuration/cfg_logging.rst:127
#: ../doc/1.10/reference/configuration/cfg_logging.rst:282
#: ../doc/1.10/reference/configuration/cfg_replication.rst:124
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1121
msgid "Type: boolean"
msgstr "Тип: логический"

#: ../doc/1.10/reference/configuration/cfg_basic.rst:23
#: ../doc/1.10/reference/configuration/cfg_basic.rst:112
#: ../doc/1.10/reference/configuration/cfg_binary_logging_snapshots.rst:23
#: ../doc/1.10/reference/configuration/cfg_deprecated.rst:26
#: ../doc/1.10/reference/configuration/cfg_hot_standby.rst:49
#: ../doc/1.10/reference/configuration/cfg_replication.rst:125
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1057
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1068
msgid "Default: false"
msgstr "По умолчанию: false (ложь)"

#: ../doc/1.10/reference/configuration/cfg_basic.rst:24
#: ../doc/1.10/reference/configuration/cfg_basic.rst:86
#: ../doc/1.10/reference/configuration/cfg_basic.rst:97
#: ../doc/1.10/reference/configuration/cfg_basic.rst:141
#: ../doc/1.10/reference/configuration/cfg_basic.rst:168
#: ../doc/1.10/reference/configuration/cfg_basic.rst:182
#: ../doc/1.10/reference/configuration/cfg_basic.rst:207
#: ../doc/1.10/reference/configuration/cfg_binary_logging_snapshots.rst:24
#: ../doc/1.10/reference/configuration/cfg_binary_logging_snapshots.rst:37
#: ../doc/1.10/reference/configuration/cfg_binary_logging_snapshots.rst:52
#: ../doc/1.10/reference/configuration/cfg_binary_logging_snapshots.rst:86
#: ../doc/1.10/reference/configuration/cfg_binary_logging_snapshots.rst:98
#: ../doc/1.10/reference/configuration/cfg_deprecated.rst:27
#: ../doc/1.10/reference/configuration/cfg_deprecated.rst:57
#: ../doc/1.10/reference/configuration/cfg_deprecated.rst:95
#: ../doc/1.10/reference/configuration/cfg_deprecated.rst:110
#: ../doc/1.10/reference/configuration/cfg_hot_standby.rst:50
#: ../doc/1.10/reference/configuration/cfg_logging.rst:112
#: ../doc/1.10/reference/configuration/cfg_logging.rst:129
#: ../doc/1.10/reference/configuration/cfg_replication.rst:216
#: ../doc/1.10/reference/configuration/cfg_replication.rst:238
#: ../doc/1.10/reference/configuration/cfg_storage.rst:43
#: ../doc/1.10/reference/configuration/cfg_storage.rst:55
#: ../doc/1.10/reference/configuration/cfg_storage.rst:69
#: ../doc/1.10/reference/configuration/cfg_storage.rst:93
#: ../doc/1.10/reference/configuration/cfg_storage.rst:115
#: ../doc/1.10/reference/configuration/cfg_storage.rst:139
#: ../doc/1.10/reference/configuration/cfg_storage.rst:152
#: ../doc/1.10/reference/configuration/cfg_storage.rst:164
#: ../doc/1.10/reference/configuration/cfg_storage.rst:175
#: ../doc/1.10/reference/configuration/cfg_storage.rst:186
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1079
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1103
msgid "Dynamic: no"
msgstr "Динамический: нет"

#: ../doc/1.10/reference/configuration/cfg_basic.rst:30
msgid ""
"Add the given string to the server's process title (what’s shown in the "
"COMMAND column for ``ps -ef`` and ``top -c`` commands)."
msgstr ""
"Добавление заданной строки к названию процесса сервера (что показано в "
"столбце COMMAND для команд ``ps -ef`` и ``top -c``."

#: ../doc/1.10/reference/configuration/cfg_basic.rst:34
msgid ""
"For example, ordinarily :samp:`ps -ef` shows the Tarantool server process"
" thus:"
msgstr ""
"Например, как правило, :samp:`ps -ef` показывает процесс "
"Tarantool-сервера так:"

#: ../doc/1.10/reference/configuration/cfg_basic.rst:37
msgid ""
"$ ps -ef | grep tarantool\n"
"1000     14939 14188  1 10:53 pts/2    00:00:13 tarantool <running>"
msgstr ""
"$ ps -ef | grep tarantool\n"
"1000     14939 14188  1 10:53 pts/2    00:00:13 tarantool <running>"

#: ../doc/1.10/reference/configuration/cfg_basic.rst:42
msgid ""
"But if the configuration parameters include "
"``custom_proc_title='sessions'`` then the output looks like:"
msgstr ""
"Но если указан конфигурационный параметр "
"``custom_proc_title='sessions'``, вывод выглядит так:"

#: ../doc/1.10/reference/configuration/cfg_basic.rst:45
msgid ""
"$ ps -ef | grep tarantool\n"
"1000     14939 14188  1 10:53 pts/2    00:00:16 tarantool <running>: "
"sessions"
msgstr ""
"$ ps -ef | grep tarantool\n"
"1000     14939 14188  1 10:53 pts/2    00:00:16 tarantool <running>: "
"sessions"

#: ../doc/1.10/reference/configuration/cfg_basic.rst:50
#: ../doc/1.10/reference/configuration/cfg_basic.rst:84
#: ../doc/1.10/reference/configuration/cfg_basic.rst:95
#: ../doc/1.10/reference/configuration/cfg_basic.rst:139
#: ../doc/1.10/reference/configuration/cfg_basic.rst:166
#: ../doc/1.10/reference/configuration/cfg_basic.rst:180
#: ../doc/1.10/reference/configuration/cfg_basic.rst:205
#: ../doc/1.10/reference/configuration/cfg_binary_logging_snapshots.rst:84
#: ../doc/1.10/reference/configuration/cfg_logging.rst:110
#: ../doc/1.10/reference/configuration/cfg_logging.rst:180
#: ../doc/1.10/reference/configuration/cfg_logging.rst:293
#: ../doc/1.10/reference/configuration/cfg_replication.rst:44
#: ../doc/1.10/reference/configuration/cfg_replication.rst:214
#: ../doc/1.10/reference/configuration/cfg_replication.rst:236
msgid "Type: string"
msgstr "Тип: строка"

#: ../doc/1.10/reference/configuration/cfg_basic.rst:51
#: ../doc/1.10/reference/configuration/cfg_basic.rst:73
#: ../doc/1.10/reference/configuration/cfg_basic.rst:96
#: ../doc/1.10/reference/configuration/cfg_basic.rst:167
#: ../doc/1.10/reference/configuration/cfg_basic.rst:206
#: ../doc/1.10/reference/configuration/cfg_binary_logging_snapshots.rst:69
#: ../doc/1.10/reference/configuration/cfg_logging.rst:111
#: ../doc/1.10/reference/configuration/cfg_networking.rst:15
#: ../doc/1.10/reference/configuration/cfg_replication.rst:45
#: ../doc/1.10/reference/configuration/cfg_replication.rst:104
#: ../doc/1.10/reference/configuration/cfg_replication.rst:215
#: ../doc/1.10/reference/configuration/cfg_replication.rst:237
msgid "Default: null"
msgstr "По умолчанию: null"

#: ../doc/1.10/reference/configuration/cfg_basic.rst:52
#: ../doc/1.10/reference/configuration/cfg_basic.rst:74
#: ../doc/1.10/reference/configuration/cfg_basic.rst:113
#: ../doc/1.10/reference/configuration/cfg_basic.rst:158
#: ../doc/1.10/reference/configuration/cfg_basic.rst:221
#: ../doc/1.10/reference/configuration/cfg_deprecated.rst:68
#: ../doc/1.10/reference/configuration/cfg_snapshot_daemon.rst:70
#: ../doc/1.10/reference/configuration/cfg_snapshot_daemon.rst:99
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1058
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1069
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1113
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1123
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1135
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1150
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1171
msgid "Dynamic: yes"
msgstr "Динамический: да"

#: ../doc/1.10/reference/configuration/cfg_basic.rst:58
msgid ""
"The read/write data port number or :ref:`URI <index-uri>` (Universal "
"Resource Identifier) string. Has no default value, so **must be "
"specified** if connections will occur from remote clients that do not use"
" the :ref:`“admin port” <admin-security>`. Connections made with "
":samp:`listen = {URI}` are called \"binary port\" or \"binary protocol\" "
"connections."
msgstr ""
"Номер порта для чтения/записи данных или строка :ref:`URI <index-uri>` "
"(унифицированный идентификатор ресурса). Значение, используемое по "
"умолчанию, отсутствует, поэтому его **обязательно указать**, если "
"подключение выполняется с удаленных клиентов, которые не используют "
":ref:`“порт администрирования” <admin-security>`. Подключения, "
"выполняемые с помощью :samp:`listen = {URI}`, называются соединения по "
"бинарному порту или бинарному протоколу."

#: ../doc/1.10/reference/configuration/cfg_basic.rst:65
msgid "A typical value is 3301."
msgstr "Как правило, используется значение 3301."

#: ../doc/1.10/reference/configuration/cfg_basic.rst:69
msgid ""
"A replica also binds to this port, and accepts connections, but these "
"connections can only serve reads until the replica becomes a master."
msgstr ""
"Реплика также привязана на этот порт и принимает соединения, но эти "
"соединения служат только для чтения до тех пор, пока реплика не станет "
"мастером."

#: ../doc/1.10/reference/configuration/cfg_basic.rst:72
msgid "Type: integer or string"
msgstr "Тип: целое число или строка"

#: ../doc/1.10/reference/configuration/cfg_basic.rst:80
msgid ""
"A directory where memtx stores snapshot (.snap) files. Can be relative to"
" :ref:`work_dir <cfg_basic-work_dir>`. If not specified, defaults to "
"``work_dir``. See also :ref:`wal_dir <cfg_basic-wal_dir>`."
msgstr ""
"Директория, где memtx хранит файлы снимков (.snap). Может относиться к "
":ref:`work_dir <cfg_basic-work_dir>`. Если не указан, по умолчанию "
"``work_dir``. См. также :ref:`wal_dir <cfg_basic-wal_dir>`."

#: ../doc/1.10/reference/configuration/cfg_basic.rst:85
#: ../doc/1.10/reference/configuration/cfg_basic.rst:140
#: ../doc/1.10/reference/configuration/cfg_basic.rst:181
msgid "Default: \".\""
msgstr "По умолчанию: \".\""

#: ../doc/1.10/reference/configuration/cfg_basic.rst:92
msgid ""
"Store the process id in this file. Can be relative to :ref:`work_dir "
"<cfg_basic-work_dir>`. A typical value is “:file:`tarantool.pid`”."
msgstr ""
"Хранение идентификатора процесса в данном файле. Может относиться к "
":ref:`work_dir <cfg_basic-work_dir>`. Как правило, используется значение "
"“:file:`tarantool.pid`”."

#: ../doc/1.10/reference/configuration/cfg_basic.rst:103
msgid ""
"Say ``box.cfg{read_only=true...}`` to put the server instance in read-"
"only mode. After this, any requests that try to change persistent data "
"will fail with error :errcode:`ER_READONLY`. Read-only mode should be "
"used for master-replica :ref:`replication <replication>`. Read-only mode "
"does not affect data-change requests for spaces defined as "
":ref:`temporary <box_schema-space_create>`. Although read-only mode "
"prevents the server from writing to the :ref:`WAL <internals-wal>`, it "
"does not prevent writing diagnostics with the :ref:`log module <log-"
"module>`."
msgstr ""
"Чтобы ввести экземпляр сервера в режим только для чтения, выполните "
"команду ``box.cfg{read_only=true...}``. После этого не будут выполняться "
"любые запросы по изменению персистентных данных с ошибкой "
":errcode:`ER_READONLY`. Режим только для чтения следует использовать в "
":ref:`репликации <replication>` типа мастер-реплика. Режим только для "
"чтения не влияет на запросы по изменению данных в спейсах, которые "
"считаются :ref:`временными <box_schema-space_create>`. Хотя режим только "
"для чтения не позволяет серверу делать записи в :ref:`WAL-файлы "
"<internals-wal>`, запись диагностической информации в :ref:`модуле log "
"<log-module>` все равно осуществляется."

#: ../doc/1.10/reference/configuration/cfg_basic.rst:115
msgid ""
"Setting ``read_only == true`` affects spaces differently depending on the"
" options that were used during :ref:`box.schema.space.create <box_schema-"
"space_create>`, as summarized by this chart:"
msgstr ""
"Установка ``read_only == true`` по-разному влияет на спейсы в зависимости"
" от опций, использованных во время :ref:`box.schema.space.create "
"<box_schema-space_create>`, как описано в таблице:"

#: ../doc/1.10/reference/configuration/cfg_basic.rst:122
msgid "Can be created?"
msgstr "Можно создать?"

#: ../doc/1.10/reference/configuration/cfg_basic.rst:122
msgid "Can be written to?"
msgstr "Допускает запись?"

#: ../doc/1.10/reference/configuration/cfg_basic.rst:122
msgid "Is replicated?"
msgstr "Реплицируется?"

#: ../doc/1.10/reference/configuration/cfg_basic.rst:122
msgid "Is persistent?"
msgstr "Сохраняется?"

#: ../doc/1.10/reference/configuration/cfg_basic.rst:124
msgid "(default)"
msgstr "(по умолчанию)"

#: ../doc/1.10/reference/configuration/cfg_basic.rst:124
#: ../doc/1.10/reference/configuration/cfg_basic.rst:126
#: ../doc/1.10/reference/configuration/cfg_basic.rst:128
msgid "no"
msgstr "нет"

#: ../doc/1.10/reference/configuration/cfg_basic.rst:124
#: ../doc/1.10/reference/configuration/cfg_basic.rst:126
#: ../doc/1.10/reference/configuration/cfg_basic.rst:128
msgid "yes"
msgstr "да"

#: ../doc/1.10/reference/configuration/cfg_basic.rst:135
msgid ""
"A directory where vinyl files or subdirectories will be stored. Can be "
"relative to :ref:`work_dir <cfg_basic-work_dir>`. If not specified, "
"defaults to ``work_dir``."
msgstr ""
"Директория, где хранятся файлы или поддиректории vinyl'а. Может "
"относиться к :ref:`work_dir <cfg_basic-work_dir>`. Если не указан, по "
"умолчанию ``work_dir``."

#: ../doc/1.10/reference/configuration/cfg_basic.rst:147
msgid ""
"The vinyl storage engine has a scheduler which does compaction. When "
"vinyl is low on available memory, the compaction scheduler may be unable "
"to keep up with incoming update requests. In that situation, queries may "
"time out after ``vinyl_timeout`` seconds. This should rarely occur, since"
" normally vinyl would throttle inserts when it is running low on "
"compaction bandwidth. Compaction can also be ordered manually with "
":ref:`index_object:compact() <box_index-compact>`."
msgstr ""
"В движке базы данных vinyl есть планировщик, который осуществляет "
"слияние. Когда vinyl'у не хватает доступной памяти, планировщик не сможет"
" поддерживать скорость слияния в соответствии со входящими запросами "
"обновления. В такой ситуации время ожидания обработки запроса может "
"истечь после ``vinyl_timeout`` секунд. Это происходит редко, поскольку "
"обычно vinyl управляет загрузкой при операциях вставки, когда не хватает "
"скорости для слияния. Слияние можно запустить автоматически с помощью "
":ref:`index_object:compact() <box_index-compact>`."

#: ../doc/1.10/reference/configuration/cfg_basic.rst:156
#: ../doc/1.10/reference/configuration/cfg_binary_logging_snapshots.rst:68
#: ../doc/1.10/reference/configuration/cfg_binary_logging_snapshots.rst:96
#: ../doc/1.10/reference/configuration/cfg_deprecated.rst:93
#: ../doc/1.10/reference/configuration/cfg_deprecated.rst:108
#: ../doc/1.10/reference/configuration/cfg_logging.rst:139
#: ../doc/1.10/reference/configuration/cfg_logging.rst:303
#: ../doc/1.10/reference/configuration/cfg_networking.rst:14
#: ../doc/1.10/reference/configuration/cfg_replication.rst:75
#: ../doc/1.10/reference/configuration/cfg_replication.rst:148
#: ../doc/1.10/reference/configuration/cfg_replication.rst:165
#: ../doc/1.10/reference/configuration/cfg_storage.rst:28
#: ../doc/1.10/reference/configuration/cfg_storage.rst:67
#: ../doc/1.10/reference/configuration/cfg_storage.rst:162
msgid "Type: float"
msgstr "Тип: число с плавающей запятой"

#: ../doc/1.10/reference/configuration/cfg_basic.rst:157
msgid "Default: 60"
msgstr "По умолчанию: 60"

#: ../doc/1.10/reference/configuration/cfg_basic.rst:164
msgid "UNIX user name to switch to after start."
msgstr "Имя пользователя в UNIX, на которое переключается система после запуска."

#: ../doc/1.10/reference/configuration/cfg_basic.rst:174
msgid ""
"A directory where write-ahead log (.xlog) files are stored. Can be "
"relative to :ref:`work_dir <cfg_basic-work_dir>`. Sometimes ``wal_dir`` "
"and :ref:`memtx_dir <cfg_basic-memtx_dir>` are specified with different "
"values, so that write-ahead log files and snapshot files can be stored on"
" different disks. If not specified, defaults to ``work_dir``."
msgstr ""
"Директория, где хранятся файлы журнала упреждающей записи (.xlog). Может "
"относиться к :ref:`work_dir <cfg_basic-work_dir>`. Иногда в ``wal_dir`` и"
" :ref:`memtx_dir <cfg_basic-memtx_dir>` указываются разные значения, "
"чтобы WAL-файлы и файлы снимков хранились на разных дисках. Если не "
"указан, по умолчанию ``work_dir``."

#: ../doc/1.10/reference/configuration/cfg_basic.rst:188
msgid ""
"A directory where database working files will be stored. The server "
"instance switches to ``work_dir`` with :manpage:`chdir(2)` after start. "
"Can be relative to the current directory. If not specified, defaults to "
"the current directory. Other directory parameters may be relative to "
"``work_dir``, for example:"
msgstr ""
"Директория, где хранятся рабочие файлы базы данных. Экземпляр сервера "
"переключается на ``work_dir`` с помощью :manpage:`chdir(2)` после "
"запуска. Может относиться к текущей директории.  Если не указан, по "
"умолчанию = текущей директории. Другие параметры директории могут "
"относиться к ``work_dir``, например:"

#: ../doc/1.10/reference/configuration/cfg_basic.rst:194
msgid ""
"box.cfg{\n"
"    work_dir = '/home/user/A',\n"
"    wal_dir = 'B',\n"
"    memtx_dir = 'C'\n"
"}"
msgstr ""
"box.cfg{\n"
"    work_dir = '/home/user/A',\n"
"    wal_dir = 'B',\n"
"    memtx_dir = 'C'\n"
"}"

#: ../doc/1.10/reference/configuration/cfg_basic.rst:202
msgid ""
"will put xlog files in ``/home/user/A/B``, snapshot files in "
"``/home/user/A/C``, and all other files or subdirectories in "
"``/home/user/A``."
msgstr ""
"поместит xlog-файлы в ``/home/user/A/B``, файлы снимков в "
"``/home/user/A/C``, а все остальные файлы или поддиректории в "
"``/home/user/A``."

#: ../doc/1.10/reference/configuration/cfg_basic.rst:214
msgid ""
"The maximum number of threads to use during execution of certain internal"
" processes (currently :ref:`socket.getaddrinfo() <socket-getaddrinfo>` "
"and :ref:`coio_call() <c_api-coio-coio_call>`)."
msgstr ""
"Максимальное количество потоков, используемых во время исполнения "
"определенных внутренних процессов (сейчас :ref:`socket.getaddrinfo() "
"<socket-getaddrinfo>` и :ref:`coio_call() <c_api-coio-coio_call>`)."

#: ../doc/1.10/reference/configuration/cfg_basic.rst:219
#: ../doc/1.10/reference/configuration/cfg_binary_logging_snapshots.rst:35
#: ../doc/1.10/reference/configuration/cfg_binary_logging_snapshots.rst:50
#: ../doc/1.10/reference/configuration/cfg_logging.rst:28
#: ../doc/1.10/reference/configuration/cfg_networking.rst:50
#: ../doc/1.10/reference/configuration/cfg_networking.rst:67
#: ../doc/1.10/reference/configuration/cfg_replication.rst:58
#: ../doc/1.10/reference/configuration/cfg_replication.rst:103
#: ../doc/1.10/reference/configuration/cfg_snapshot_daemon.rst:68
#: ../doc/1.10/reference/configuration/cfg_snapshot_daemon.rst:97
#: ../doc/1.10/reference/configuration/cfg_storage.rst:41
#: ../doc/1.10/reference/configuration/cfg_storage.rst:53
#: ../doc/1.10/reference/configuration/cfg_storage.rst:78
#: ../doc/1.10/reference/configuration/cfg_storage.rst:91
#: ../doc/1.10/reference/configuration/cfg_storage.rst:101
#: ../doc/1.10/reference/configuration/cfg_storage.rst:113
#: ../doc/1.10/reference/configuration/cfg_storage.rst:137
#: ../doc/1.10/reference/configuration/cfg_storage.rst:150
#: ../doc/1.10/reference/configuration/cfg_storage.rst:173
#: ../doc/1.10/reference/configuration/cfg_storage.rst:184
msgid "Type: integer"
msgstr "Тип: целое число"

#: ../doc/1.10/reference/configuration/cfg_basic.rst:220
#: ../doc/1.10/reference/configuration/cfg_replication.rst:76
msgid "Default: 4"
msgstr "По умолчанию: 4"

#: ../doc/1.10/reference/configuration/index.rst:230
msgid "Configuring the storage"
msgstr "Настройка хранения"

#: ../doc/1.10/reference/configuration/cfg_storage.rst:1
msgid ":ref:`memtx_memory <cfg_storage-memtx_memory>`"
msgstr ":ref:`memtx_memory <cfg_storage-memtx_memory>`"

#: ../doc/1.10/reference/configuration/cfg_storage.rst:2
msgid ":ref:`memtx_max_tuple_size <cfg_storage-memtx_max_tuple_size>`"
msgstr ":ref:`memtx_max_tuple_size <cfg_storage-memtx_max_tuple_size>`"

#: ../doc/1.10/reference/configuration/cfg_storage.rst:3
msgid ":ref:`memtx_min_tuple_size <cfg_storage-memtx_min_tuple_size>`"
msgstr ":ref:`memtx_min_tuple_size <cfg_storage-memtx_min_tuple_size>`"

#: ../doc/1.10/reference/configuration/cfg_storage.rst:4
msgid ":ref:`vinyl_bloom_fpr <cfg_storage-vinyl_bloom_fpr>`"
msgstr ":ref:`vinyl_bloom_fpr <cfg_storage-vinyl_bloom_fpr>`"

#: ../doc/1.10/reference/configuration/cfg_storage.rst:5
msgid ":ref:`vinyl_cache <cfg_storage-vinyl_cache>`"
msgstr ":ref:`vinyl_cache <cfg_storage-vinyl_cache>`"

#: ../doc/1.10/reference/configuration/cfg_storage.rst:6
msgid ":ref:`vinyl_max_tuple_size <cfg_storage-vinyl_max_tuple_size>`"
msgstr ":ref:`vinyl_max_tuple_size <cfg_storage-vinyl_max_tuple_size>`"

#: ../doc/1.10/reference/configuration/cfg_storage.rst:7
msgid ":ref:`vinyl_memory <cfg_storage-vinyl_memory>`"
msgstr ":ref:`vinyl_memory <cfg_storage-vinyl_memory>`"

#: ../doc/1.10/reference/configuration/cfg_storage.rst:8
msgid ":ref:`vinyl_page_size <cfg_storage-vinyl_page_size>`"
msgstr ":ref:`vinyl_page_size <cfg_storage-vinyl_page_size>`"

#: ../doc/1.10/reference/configuration/cfg_storage.rst:9
msgid ":ref:`vinyl_range_size <cfg_storage-vinyl_range_size>`"
msgstr ":ref:`vinyl_range_size <cfg_storage-vinyl_range_size>`"

#: ../doc/1.10/reference/configuration/cfg_storage.rst:10
msgid ":ref:`vinyl_run_count_per_level <cfg_storage-vinyl_run_count_per_level>`"
msgstr ":ref:`vinyl_run_count_per_level <cfg_storage-vinyl_run_count_per_level>`"

#: ../doc/1.10/reference/configuration/cfg_storage.rst:11
msgid ":ref:`vinyl_run_size_ratio <cfg_storage-vinyl_run_size_ratio>`"
msgstr ":ref:`vinyl_run_size_ratio <cfg_storage-vinyl_run_size_ratio>`"

#: ../doc/1.10/reference/configuration/cfg_storage.rst:12
msgid ":ref:`vinyl_read_threads <cfg_storage-vinyl_read_threads>`"
msgstr ":ref:`vinyl_read_threads <cfg_storage-vinyl_read_threads>`"

#: ../doc/1.10/reference/configuration/cfg_storage.rst:13
msgid ":ref:`vinyl_write_threads <cfg_storage-vinyl_write_threads>`"
msgstr ":ref:`vinyl_write_threads <cfg_storage-vinyl_write_threads>`"

#: ../doc/1.10/reference/configuration/cfg_storage.rst:19
msgid ""
"How much memory Tarantool allocates to actually store tuples, in bytes. "
"When the limit is reached, :ref:`INSERT <box_space-insert>` or "
":ref:`UPDATE <box_space-insert>` requests begin failing with error "
":errcode:`ER_MEMORY_ISSUE`. The server does not go beyond the "
"``memtx_memory`` limit to allocate tuples, but there is additional memory"
" used to store indexes and connection information. Depending on actual "
"configuration and workload, Tarantool can consume up to 20% more than the"
" ``memtx_memory`` limit."
msgstr ""
"Количество памяти, которое Tarantool выделяет для фактического хранения "
"кортежей, в байтах. При достижении предельного значения запросы вставки "
":ref:`INSERT <box_space-insert>` или обновления :ref:`UPDATE <box_space-"
"insert>` выполняться не будут, выдавая ошибку :errcode:`ER_MEMORY_ISSUE`."
" Сервер не выходит за установленный предел памяти ``memtx_memory`` при "
"распределении кортежей, но есть дополнительная память, которая "
"используется для хранения индексов и информации о подключении. В "
"зависимости от рабочей конфигурации и загрузки, Tarantool может "
"потреблять на 20% больше предела ``memtx_memory``."

#: ../doc/1.10/reference/configuration/cfg_storage.rst:29
msgid "Default: 256 * 1024 * 1024 = 268435456"
msgstr "По умолчанию: 256 * 1024 * 1024 = 268435456"

#: ../doc/1.10/reference/configuration/cfg_storage.rst:30
#: ../doc/1.10/reference/configuration/cfg_storage.rst:103
msgid "Dynamic: **yes** but it cannot be decreased"
msgstr "Динамический: **да**, но нельзя уменьшить"

#: ../doc/1.10/reference/configuration/cfg_storage.rst:36
msgid ""
"Size of the largest allocation unit, in bytes, for the memtx storage "
"engine. It can be increased if it is necessary to store large tuples. See"
" also: :ref:`vinyl_max_tuple_size <cfg_storage-vinyl_max_tuple_size>`."
msgstr ""
"Размер наибольшего блока выделения памяти в байтах для движка базы данных"
" memtx. Его можно увеличить, если есть необходимость в хранении больших "
"кортежей. См. также :ref:`vinyl_max_tuple_size <cfg_storage-"
"vinyl_max_tuple_size>`."

#: ../doc/1.10/reference/configuration/cfg_storage.rst:42
#: ../doc/1.10/reference/configuration/cfg_storage.rst:92
msgid "Default: 1024 * 1024 = 1048576"
msgstr "По умолчанию: 1024 * 1024 = 1048576"

#: ../doc/1.10/reference/configuration/cfg_storage.rst:49
msgid ""
"Size of the smallest allocation unit, in bytes. It can be decreased if "
"most of the tuples are very small. The value must be between 8 and "
"1048280 inclusive."
msgstr ""
"Размер наименьшего блока выделения памяти в байтах. Его можно уменьшить, "
"если кортежи очень малого размера. Значение должно быть от 8 до 1 048 280"
" включительно."

#: ../doc/1.10/reference/configuration/cfg_storage.rst:54
msgid "Default: 16"
msgstr "По умолчанию: 16"

#: ../doc/1.10/reference/configuration/cfg_storage.rst:61
msgid ""
"Bloom filter false positive rate -- the suitable probability of the "
"`bloom filter <https://en.wikipedia.org/wiki/Bloom_filter>`_ to give a "
"wrong result. The ``vinyl_bloom_fpr`` setting is a default value for one "
"of the options in the :ref:`Options for space_object:create_index() "
"<box_space-create_index>` chart."
msgstr ""
"Доля ложноположительного срабатывания фильтра Блума -- подходящая "
"вероятность того, что `фильтр Блума "
"<https://ru.wikipedia.org/wiki/%D0%A4%D0%B8%D0%BB%D1%8C%D1%82%D1%80_%D0%91%D0%BB%D1%83%D0%BC%D0%B0>`_"
" выдаст ошибочный результат. Настройка ``vinyl_bloom_fpr`` -- это "
"значение, которое используется по умолчанию для одного из параметров в "
"таблице :ref:`Параметры space_object:create_index() <box_space-"
"create_index>`."

#: ../doc/1.10/reference/configuration/cfg_storage.rst:68
msgid "Default = 0.05"
msgstr "По умолчанию = 0.05"

#: ../doc/1.10/reference/configuration/cfg_storage.rst:75
msgid ""
"The cache size for the vinyl storage engine, in bytes. The cache can be "
"resized dynamically."
msgstr ""
"Размер кэша для движка базы данных vinyl в байтах. Размер кэша можно "
"изменить динамически."

#: ../doc/1.10/reference/configuration/cfg_storage.rst:79
#: ../doc/1.10/reference/configuration/cfg_storage.rst:102
msgid "Default = 128 * 1024 * 1024 = 134217728"
msgstr "По умолчанию = 128 * 1024 * 1024 = 134217728"

#: ../doc/1.10/reference/configuration/cfg_binary_logging_snapshots.rst:70
#: ../doc/1.10/reference/configuration/cfg_logging.rst:30
#: ../doc/1.10/reference/configuration/cfg_logging.rst:141
#: ../doc/1.10/reference/configuration/cfg_logging.rst:182
#: ../doc/1.10/reference/configuration/cfg_logging.rst:284
#: ../doc/1.10/reference/configuration/cfg_logging.rst:295
#: ../doc/1.10/reference/configuration/cfg_logging.rst:305
#: ../doc/1.10/reference/configuration/cfg_networking.rst:16
#: ../doc/1.10/reference/configuration/cfg_networking.rst:52
#: ../doc/1.10/reference/configuration/cfg_networking.rst:69
#: ../doc/1.10/reference/configuration/cfg_replication.rst:46
#: ../doc/1.10/reference/configuration/cfg_replication.rst:60
#: ../doc/1.10/reference/configuration/cfg_replication.rst:77
#: ../doc/1.10/reference/configuration/cfg_replication.rst:105
#: ../doc/1.10/reference/configuration/cfg_replication.rst:126
#: ../doc/1.10/reference/configuration/cfg_replication.rst:150
#: ../doc/1.10/reference/configuration/cfg_replication.rst:167
#: ../doc/1.10/reference/configuration/cfg_storage.rst:80
msgid "Dynamic: **yes**"
msgstr "Динамический: **да**"

#: ../doc/1.10/reference/configuration/cfg_storage.rst:86
msgid ""
"Size of the largest allocation unit, in bytes, for the vinyl storage "
"engine. It can be increased if it is necessary to store large tuples. See"
" also: :ref:`memtx_max_tuple_size <cfg_storage-memtx_max_tuple_size>`."
msgstr ""
"Размер наибольшего блока выделения памяти в байтах для движка базы данных"
" vinyl. Его можно увеличить, если есть необходимость в хранении больших "
"кортежей. См. также :ref:`memtx_max_tuple_size <cfg_storage-"
"memtx_max_tuple_size>`."

#: ../doc/1.10/reference/configuration/cfg_storage.rst:99
msgid "The maximum number of in-memory bytes that vinyl uses."
msgstr ""
"Максимальное количество байтов оперативной памяти, которые использует "
"vinyl."

#: ../doc/1.10/reference/configuration/cfg_storage.rst:109
msgid ""
"Page size, in bytes. Page is a read/write unit for vinyl disk operations."
" The ``vinyl_page_size`` setting is a default value for one of the "
"options in the :ref:`Options for space_object:create_index() <box_space-"
"create_index>` chart."
msgstr ""
"Размер страницы в байтах. Страница представляет собой блок чтения и "
"записи для операций на диске vinyl. Настройка ``vinyl_page_size`` -- это "
"значение, которое используется по умолчанию для одного из параметров в "
"таблице :ref:`Параметры space_object:create_index() `."

#: ../doc/1.10/reference/configuration/cfg_storage.rst:114
msgid "Default = 8 * 1024 = 8192"
msgstr "По умолчанию = 8 * 1024 = 8192"

#: ../doc/1.10/reference/configuration/cfg_storage.rst:121
msgid ""
"The default maximum range size for a vinyl index, in bytes. The maximum "
"range size affects the decision whether to :ref:`split <engines-"
"vinyl_split>` a range."
msgstr ""
"Максимальный размер диапазона для индекса vinyl'а в байтах. Максимальный "
"размер диапазона влияет на принятие решения о :ref:`разделении <engines-"
"vinyl_split>` диапазона."

#: ../doc/1.10/reference/configuration/cfg_storage.rst:125
msgid ""
"If ``vinyl_range_size`` is not nil and not 0, then it is used as the "
"default value for the ``range_size`` option in the :ref:`Options for "
"space_object:create_index() <box_space-create_index>` chart."
msgstr ""
"Если ``vinyl_range_size`` содержит не нулевое значение nil и не 0, это "
"значение используется в качестве значения по умолчанию для параметра "
"``range_size`` в таблице :ref:`Параметры space_object:create_index() "
"<box_space-create_index>`."

#: ../doc/1.10/reference/configuration/cfg_storage.rst:130
msgid ""
"If ``vinyl_range_size`` is nil or 0, and ``range_size`` is not specified "
"when the index is created, then Tarantool sets a value later depending on"
" performance considerations. To see the actual value, use "
":ref:`index_object:stat().range_size <box_index-stat>`."
msgstr ""
"Если ``vinyl_range_size`` содержит нулевое значение nil или 0, а параметр"
" ``range_size`` не задан при создании индекса, то Tarantool сам задает "
"это значение позднее в результате оценки производительности. Чтобы узнать"
" текущее значение, используйте :ref:`index_object:stat().range_size "
"<box_index-stat>`."

#: ../doc/1.10/reference/configuration/cfg_storage.rst:135
msgid ""
"In Tarantool versions prior to 1.10.2, ``vinyl_range_size`` default value"
" was 1073741824."
msgstr ""
"До версии Tarantool'а 1.10.2, значение ``vinyl_range_size`` по умолчанию "
"было 1073741824."

#: ../doc/1.10/reference/configuration/cfg_storage.rst:138
msgid "Default = nil"
msgstr "По умолчанию = нулевое значение nil"

#: ../doc/1.10/reference/configuration/cfg_storage.rst:145
msgid ""
"The maximal number of runs per level in vinyl LSM tree. If this number is"
" exceeded, a new level is created. The ``vinyl_run_count_per_level`` "
"setting is a default value for one of the options in the :ref:`Options "
"for space_object:create_index() <box_space-create_index>` chart."
msgstr ""
"Максимальное количество забегов на уровень журнально-структурированного "
"дерева со слиянием в vinyl'е. Настройка ``vinyl_run_count_per_level`` -- "
"это значение, которое используется по умолчанию для одного из параметров "
"в таблице :ref:`Параметры space_object:create_index() `."

#: ../doc/1.10/reference/configuration/cfg_storage.rst:151
#: ../doc/1.10/reference/configuration/cfg_storage.rst:185
msgid "Default = 2"
msgstr "По умолчанию = 2"

#: ../doc/1.10/reference/configuration/cfg_storage.rst:158
msgid ""
"Ratio between the sizes of different levels in the LSM tree. The "
"``vinyl_run_size_ratio`` setting is a default value for one of the "
"options in the :ref:`Options for space_object:create_index() <box_space-"
"create_index>` chart."
msgstr ""
"Отношение размеров различных уровней журнально-структурированного дерева "
"со слиянием. Настройка ``vinyl_run_size_ratio`` -- это значение, которое "
"используется по умолчанию для одного из параметров в таблице "
":ref:`Параметры space_object:create_index() `."

#: ../doc/1.10/reference/configuration/cfg_storage.rst:163
msgid "Default = 3.5"
msgstr "По умолчанию = 3.5"

#: ../doc/1.10/reference/configuration/cfg_storage.rst:170
msgid ""
"The maximum number of read threads that vinyl can use for some concurrent"
" operations, such as I/O and compression."
msgstr ""
"Максимальное количество потоков чтения, которые vinyl может использовать "
"в одновременных операциях, такие как ввод-вывод и компрессия."

#: ../doc/1.10/reference/configuration/cfg_storage.rst:174
msgid "Default = 1"
msgstr "По умолчанию = 1"

#: ../doc/1.10/reference/configuration/cfg_storage.rst:181
msgid ""
"The maximum number of write threads that vinyl can use for some "
"concurrent operations, such as I/O and compression."
msgstr ""
"Максимальное количество потоков записи, которые vinyl может использовать "
"в одновременных операциях, такие как ввод-вывод и компрессия."

#: ../doc/1.10/reference/configuration/index.rst:238
msgid "Checkpoint daemon"
msgstr "Демон создания контрольных точек"

#: ../doc/1.10/reference/configuration/cfg_snapshot_daemon.rst:1
msgid ":ref:`checkpoint_count <cfg_checkpoint_daemon-checkpoint_count>`"
msgstr ":ref:`checkpoint_count <cfg_checkpoint_daemon-checkpoint_count>`"

#: ../doc/1.10/reference/configuration/cfg_snapshot_daemon.rst:2
msgid ":ref:`checkpoint_interval <cfg_checkpoint_daemon-checkpoint_interval>`"
msgstr ":ref:`checkpoint_interval <cfg_checkpoint_daemon-checkpoint_interval>`"

#: ../doc/1.10/reference/configuration/cfg_snapshot_daemon.rst:4
msgid ""
"The checkpoint daemon is a fiber which is constantly running. At "
"intervals, it may make new :ref:`snapshot (.snap) files <index-"
"box_persistence>` and then may delete old snapshot files."
msgstr ""
"Демон создания контрольных точек -- это постоянно работающий файбер. "
"Периодически он может создавать :ref:`файлы снимка (.snap) <index-"
"box_persistence>`, а затем может удалять старые файлы снимка."

#: ../doc/1.10/reference/configuration/cfg_snapshot_daemon.rst:8
msgid ""
"The :ref:`checkpoint_interval <cfg_checkpoint_daemon-"
"checkpoint_interval>` and :ref:`checkpoint_count <cfg_checkpoint_daemon-"
"checkpoint_count>` configuration settings determine how long the "
"intervals are, and how many snapshots should exist before deletions "
"occur."
msgstr ""
"Настройки конфигурации :ref:`checkpoint_interval <cfg_checkpoint_daemon-"
"checkpoint_interval>` и :ref:`checkpoint_count <cfg_checkpoint_daemon-"
"checkpoint_count>` определяют длительность интервалов и количество "
"снимков, которое должно присутствовать до начала удалений."

#: ../doc/1.10/reference/configuration/cfg_snapshot_daemon.rst:15
msgid "**Tarantool garbage collector**"
msgstr "**Сборщик мусора Tarantool'а**"

#: ../doc/1.10/reference/configuration/cfg_snapshot_daemon.rst:17
msgid ""
"The checkpoint daemon may activate the Tarantool garbage collector which "
"deletes old files. This garbage collector is distinct from the `Lua "
"garbage collector <https://www.lua.org/manual/5.1/manual.html#2.10>`_ "
"which is for Lua objects, and distinct from a Tarantool garbage collector"
" which specializes in :ref:`handling shard buckets <vshard-gc>`."
msgstr ""
"Демон создания контрольных точек может запустить сборщик мусора "
"Tarantool'а, который удаляет старые файлы. Такой сборщик мусора на "
"отличается от `сборщика мусора в Lua "
"<https://www.lua.org/manual/5.1/manual.html#2.10>`_, который предназначен"
" для Lua-объектов, и от сборщика мусора, который специализируется на "
":ref:`обработке блоков шарда <vshard-gc>`."

#: ../doc/1.10/reference/configuration/cfg_snapshot_daemon.rst:24
msgid ""
"If the checkpoint daemon deletes an old snapshot file, then the Tarantool"
" garbage collector will also delete any :ref:`write-ahead log (.xlog) "
"<internals-wal>` files which are older than the snapshot file and which "
"contain information that is present in the snapshot file. It will also "
"delete obsolete vinyl ``.run`` files."
msgstr ""
"Если демон создания контрольных точек удаляет старый файл снимка, сборщик"
" мусора Tarantool'а также удалит любые файлы :ref:`журнала упреждающей "
"записи (.xlog) <internals-wal>` старше файла снимка, содержащие "
"информацию, которая присутствует в файле снимка. Он также удаляет "
"устаревшие файлы ``.run`` в vinyl'е."

#: ../doc/1.10/reference/configuration/cfg_snapshot_daemon.rst:30
msgid ""
"The checkpoint daemon and the Tarantool garbage collector will not delete"
" a file if:"
msgstr ""
"Демон создания контрольных точек и сборщик мусора Tarantool'а **не "
"удалят** файл, если:"

#: ../doc/1.10/reference/configuration/cfg_snapshot_daemon.rst:32
msgid ""
"a **backup** is ongoing and the file has not been backed up (see "
":ref:`\"Hot backup\" <admin-backups-hot_backup_vinyl_memtx>`), or"
msgstr ""
"идет **резервное копирование**, и файл еще не был скопирован (см. "
":ref:`\"Резервное копирование\" <admin-backups-hot_backup_vinyl_memtx>`),"
" или"

#: ../doc/1.10/reference/configuration/cfg_snapshot_daemon.rst:35
msgid ""
"**replication** is ongoing and the file has not been relayed to a replica"
" (see :ref:`\"Replication architecture\" <replication-architecture>`),"
msgstr ""
"идет **репликация**, и файл еще не был передан на реплику (см. "
":ref:`\"Архитектуру механизма репликации\" <replication-architecture>`),"

#: ../doc/1.10/reference/configuration/cfg_snapshot_daemon.rst:38
msgid "a replica is connecting, or"
msgstr "реплика подключается, или"

#: ../doc/1.10/reference/configuration/cfg_snapshot_daemon.rst:40
msgid ""
"a replica has fallen behind. The progress of each replica is tracked; if "
"a replica's position is far from being up to date, then the server stops "
"to give it a chance to catch up. If an administrator concludes that a "
"replica is permanently down, then the correct procedure is to restart the"
" server, or (preferably) :ref:`remove the replica from the cluster "
"<replication-remove_instances>`."
msgstr ""
"реплика отстает. Ход выполнения на каждой реплике отслеживается. Если "
"реплика далеко не актуальна, сервер останавливается, чтобы она могла "
"обновиться. Если администратор делает вывод, что реплика окончательно "
"недоступна, необходимо перезагрузить сервер или же (предпочтительно) "
":ref:`удалить реплику из кластера <replication-remove_instances>`."

#: ../doc/1.10/reference/configuration/cfg_snapshot_daemon.rst:52
msgid ""
"The interval between actions by the checkpoint daemon, in seconds. If "
"``checkpoint_interval`` is set to a value greater than zero, and there is"
" activity which causes change to a database, then the checkpoint daemon "
"will call :ref:`box.snapshot <box-snapshot>` every "
"``checkpoint_interval`` seconds, creating a new snapshot file each time. "
"If ``checkpoint_interval`` is set to zero, then the checkpoint daemon is "
"disabled."
msgstr ""
"Промежуток времени между действиями демона создания контрольных точек в "
"секундах. Если значение параметра ``checkpoint_interval`` больше нуля, и "
"выполняется изменение базы данных, то демон создания контрольных точек "
"будет вызывать :ref:`box.snapshot <box-snapshot>` каждые "
"``checkpoint_interval`` секунд, каждый раз создавая новый файл снимка. "
"Если значение параметра ``checkpoint_interval`` равно нулю, то демон "
"создания контрольных точек отключен."

#: ../doc/1.10/reference/configuration/cfg_snapshot_daemon.rst:61
msgid "box.cfg{checkpoint_interval=60}"
msgstr "box.cfg{checkpoint_interval=60}"

#: ../doc/1.10/reference/configuration/cfg_snapshot_daemon.rst:65
msgid ""
"will cause the checkpoint daemon to create a new database snapshot once "
"per minute, if there is activity."
msgstr ""
"приведет к созданию нового снимка базы данных демоном создания "
"контрольных точек каждую минуту, если наблюдается активность в базе "
"данных."

#: ../doc/1.10/reference/configuration/cfg_snapshot_daemon.rst:69
msgid "Default: 3600 (one hour)"
msgstr "По умолчанию: 3600 (один час)"

#: ../doc/1.10/reference/configuration/cfg_snapshot_daemon.rst:76
msgid ""
"The maximum number of snapshots that may exist on the :ref:`memtx_dir "
"<cfg_basic-memtx_dir>` directory before the checkpoint daemon will delete"
" old snapshots. If ``checkpoint_count`` equals zero, then the checkpoint "
"daemon does not delete old snapshots. For example:"
msgstr ""
"Максимальное количество снимков, которые могут находиться в директории "
":ref:`memtx_dir <cfg_basic-memtx_dir>` до того, как демон создания "
"контрольных точек будет удалять старые снимки. Если значение "
"``checkpoint_count`` равно нулю, то демон создания контрольных точек не "
"удаляет старые снимки. Например:"

#: ../doc/1.10/reference/configuration/cfg_snapshot_daemon.rst:82
msgid ""
"box.cfg{\n"
"    checkpoint_interval = 3600,\n"
"    checkpoint_count  = 10\n"
"}"
msgstr ""
"box.cfg{\n"
"    checkpoint_interval = 3600,\n"
"    checkpoint_count  = 10\n"
"}"

#: ../doc/1.10/reference/configuration/cfg_snapshot_daemon.rst:89
msgid ""
"will cause the checkpoint daemon to create a new snapshot each hour until"
" it has created ten snapshots. After that, it will delete the oldest "
"snapshot (and any associated write-ahead-log files) after creating a new "
"one."
msgstr ""
"заставит демон создания контрольных точек создавать снимок каждый час до "
"тех пор, пока не будет создано десять снимков. Затем самый старый "
"снимок удаляется (а также любые связанные с ним WAL-файлы) после создания нового "
"снимка."

#: ../doc/1.10/reference/configuration/cfg_snapshot_daemon.rst:93
msgid ""
"Remember that, as noted earlier, snapshots will not be deleted if "
"replication is ongoing and the file has not been relayed to a replica. "
"Therefore ``checkpoint_count`` has no effect unless all replicas are "
"alive."
msgstr ""
"Следует помнить, что как упоминалось выше, снимки не удаляются, если "
"выполняется репликация, и файл еще не был передан на реплику. Таким "
"образом, параметр ``checkpoint_count`` бесполезен, если какая-то реплика "
"неактивна."

#: ../doc/1.10/reference/configuration/cfg_binary_logging_snapshots.rst:97
#: ../doc/1.10/reference/configuration/cfg_snapshot_daemon.rst:98
msgid "Default: 2"
msgstr "По умолчанию: 2"

#: ../doc/1.10/reference/configuration/index.rst:244
msgid "Binary logging and snapshots"
msgstr "Записи в бинарный журнал и создание снимков"

#: ../doc/1.10/reference/configuration/cfg_binary_logging_snapshots.rst:1
msgid ":ref:`force_recovery <cfg_binary_logging_snapshots-force_recovery>`,"
msgstr ":ref:`force_recovery <cfg_binary_logging_snapshots-force_recovery>`,"

#: ../doc/1.10/reference/configuration/cfg_binary_logging_snapshots.rst:2
msgid ":ref:`rows_per_wal <cfg_binary_logging_snapshots-rows_per_wal>`,"
msgstr ":ref:`rows_per_wal <cfg_binary_logging_snapshots-rows_per_wal>`,"

#: ../doc/1.10/reference/configuration/cfg_binary_logging_snapshots.rst:3
msgid ":ref:`wal_max_size <cfg_binary_logging_snapshots-wal_max_size>`,"
msgstr ":ref:`wal_max_size <cfg_binary_logging_snapshots-wal_max_size>`,"

#: ../doc/1.10/reference/configuration/cfg_binary_logging_snapshots.rst:4
msgid ""
":ref:`snap_io_rate_limit <cfg_binary_logging_snapshots-"
"snap_io_rate_limit>`,"
msgstr ""
":ref:`snap_io_rate_limit <cfg_binary_logging_snapshots-"
"snap_io_rate_limit>`,"

#: ../doc/1.10/reference/configuration/cfg_binary_logging_snapshots.rst:5
msgid ":ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>`,"
msgstr ":ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>`,"

#: ../doc/1.10/reference/configuration/cfg_binary_logging_snapshots.rst:6
msgid ""
":ref:`wal_dir_rescan_delay <cfg_binary_logging_snapshots-"
"wal_dir_rescan_delay>`"
msgstr ""
":ref:`wal_dir_rescan_delay <cfg_binary_logging_snapshots-"
"wal_dir_rescan_delay>`"

#: ../doc/1.10/reference/configuration/cfg_binary_logging_snapshots.rst:12
msgid ""
"If ``force_recovery`` equals true, Tarantool tries to continue if there "
"is an error while reading a :ref:`snapshot file<index-box_persistence>` "
"(at server instance start) or a :ref:`write-ahead log file<internals-"
"wal>` (at server instance start or when applying an update at a replica):"
" skips invalid records, reads as much data as possible and lets the "
"process finish with a warning. Users can prevent the error from recurring"
" by writing to the database and executing :ref:`box.snapshot() <box-"
"snapshot>`."
msgstr ""
"Если значение ``force_recovery`` равно true (правда), Tarantool пытается "
"продолжать работу при обнаружении ошибки во время чтения :ref:`файла "
"снимка <index-box_persistence>` (при запуске экземпляра сервера) или "
":ref:`файла журнала упреждающей записи <internals-wal>` (при запуске "
"экземпляра сервера или применении обновлений к реплике): пропускает "
"нерабочие записи, считывает максимальное количество данных и позволяет "
"завершить процесс предупреждением. Пользователи могут предотвратить "
"повторное появление ошибки, записав данные в базу и выполнив "
":ref:`box.snapshot() <box-snapshot>`."

#: ../doc/1.10/reference/configuration/cfg_binary_logging_snapshots.rst:20
msgid "Otherwise, Tarantool aborts recovery if there is an error while reading."
msgstr "В остальных случаях Tarantool прерывает восстановление на ошибке чтения."

#: ../doc/1.10/reference/configuration/cfg_binary_logging_snapshots.rst:30
msgid ""
"How many log records to store in a single write-ahead log file. When this"
" limit is reached, Tarantool creates another WAL file named :samp"
":`{<first-lsn-in-wal>}.xlog`. This can be useful for simple rsync-based "
"backups."
msgstr ""
"Количество записей журнала, которое хранится в отдельном WAL-файле. При "
"достижении предельного значения Tarantool создает другой WAL-файл под "
"названием :samp:`{<первый-lsn-в-журнале>}.xlog`. Эту функцию можно "
"использовать для простого резервного копирования на основе rsync."

#: ../doc/1.10/reference/configuration/cfg_binary_logging_snapshots.rst:36
msgid "Default: 500000"
msgstr "По умолчанию: 500000"

#: ../doc/1.10/reference/configuration/cfg_binary_logging_snapshots.rst:43
msgid ""
"The maximum number of bytes in a single write-ahead log file. When a "
"request would cause an .xlog file to become larger than ``wal_max_size``,"
" Tarantool creates another WAL file -- the same effect that happens when "
"the :ref:`rows_per_wal <cfg_binary_logging_snapshots-rows_per_wal>` limit"
" is reached."
msgstr ""
"Максимальное количество байтов в отдельном журнале упреждающей записи. "
"Если в результате запроса файл .xlog будет больше, чем указано в "
"параметре ``wal_max_size``, Tarantool создает другой WAL-файл -- то же "
"самое происходит, когда достигнуто количество строк в журнале, указанное "
"в :ref:`rows_per_wal <cfg_binary_logging_snapshots-rows_per_wal>`."

#: ../doc/1.10/reference/configuration/cfg_binary_logging_snapshots.rst:51
msgid "Default: 268435456 (256 * 1024 * 1024)"
msgstr "По умолчанию: 268435456 (256 * 1024 * 1024)"

#: ../doc/1.10/reference/configuration/cfg_binary_logging_snapshots.rst:58
msgid ""
"Reduce the throttling effect of :ref:`box.snapshot <box-snapshot>` on "
"INSERT/UPDATE/DELETE performance by setting a limit on how many megabytes"
" per second it can write to disk. The same can be achieved by splitting "
":ref:`wal_dir <cfg_basic-wal_dir>` and :ref:`memtx_dir <cfg_basic-"
"memtx_dir>` locations and moving snapshots to a separate disk. The limit "
"also affects what :ref:`box.stat.vinyl().regulator <box_introspection-"
"box_stat_vinyl_regulator>` may show for the write rate of dumps to .run "
"and .index files."
msgstr ""
"Уменьшение загрузки :ref:`box.snapshot <box-snapshot>` при выполнении "
"операций вставки, обновления и удаления (INSERT/UPDATE/DELETE) путем "
"установки предела скорости записи на диск -- количества мегабайт в "
"секунду. Того же эффекта можно достичь, разделив директории :ref:`wal_dir"
" <cfg_basic-wal_dir>` и :ref:`memtx_dir <cfg_basic-memtx_dir>` и перенося"
" снимки на отдельный диск. Такой предел также ограничивает результат "
":ref:`box.stat.vinyl().regulator <box_introspection-"
"box_stat_vinyl_regulator>` относительно скорости записи дампов в файлы "
"формата .run и .index."

#: ../doc/1.10/reference/configuration/cfg_binary_logging_snapshots.rst:76
msgid "Specify fiber-WAL-disk synchronization mode as:"
msgstr "Определение синхронизации работы файбера с журналом упреждающей записи:"

#: ../doc/1.10/reference/configuration/cfg_binary_logging_snapshots.rst:78
msgid "``none``: write-ahead log is not maintained;"
msgstr "``none``: журнал упреждающей записи не поддерживается;"

#: ../doc/1.10/reference/configuration/cfg_binary_logging_snapshots.rst:79
msgid ""
"``write``: :ref:`fibers <fiber-fibers>` wait for their data to be written"
" to the write-ahead log (no :manpage:`fsync(2)`);"
msgstr ""
"``write``: :ref:`файберы <fiber-fibers>` ожидают записи данных в журнал "
"упреждающей записи (не :manpage:`fsync(2)`);"

#: ../doc/1.10/reference/configuration/cfg_binary_logging_snapshots.rst:81
msgid ""
"``fsync``: fibers wait for their data, :manpage:`fsync(2)` follows each "
":manpage:`write(2)`;"
msgstr ""
"``fsync``: файберы ожидают данные, синхронизация :manpage:`fsync(2)` "
"следует за каждой операцией записи :manpage:`write(2)`;"

#: ../doc/1.10/reference/configuration/cfg_binary_logging_snapshots.rst:85
msgid "Default: \"write\""
msgstr "По умолчанию: \"write\""

#: ../doc/1.10/reference/configuration/cfg_binary_logging_snapshots.rst:92
msgid ""
"Number of seconds between periodic scans of the write-ahead-log file "
"directory, when checking for changes to write-ahead-log files for the "
"sake of :ref:`replication <replication>` or :ref:`hot standby <index-"
"hot_standby>`."
msgstr ""
"Количество секунд между периодическим сканирование директории WAL-файла "
"при проверке изменений в WAL-файле для целей :ref:`репликации "
"<replication>` или :ref:`горячего резервирования <index-hot_standby>`."

#: ../doc/1.10/reference/configuration/index.rst:252
msgid "Hot standby"
msgstr "Горячее резервирование"

#: ../doc/1.10/reference/configuration/cfg_hot_standby.rst:3
msgid "Whether to start the server in **hot standby** mode."
msgstr "Запуск сервера в режиме **горячего резервирования**."

#: ../doc/1.10/reference/configuration/cfg_hot_standby.rst:5
msgid ""
"Hot standby is a feature which provides a simple form of failover without"
" :ref:`replication <replication>`."
msgstr ""
"Горячее резервирование -- это функция, которая обеспечивает простое "
"восстановление после отказа без :ref:`репликации <replication>`."

#: ../doc/1.10/reference/configuration/cfg_hot_standby.rst:8
msgid ""
"The expectation is that there will be two instances of the server using "
"the same configuration. The first one to start will be the \"primary\" "
"instance. The second one to start will be the \"standby\" instance."
msgstr ""
"Предполагается, что есть два экземпляра сервера, использующих одну и ту "
"же конфигурацию. Первый из них станет \"основным\" экземпляром. Тот, "
"который запускается вторым, станет \"резервным\" экземпляром."

#: ../doc/1.10/reference/configuration/cfg_hot_standby.rst:12
msgid ""
"To initiate the standby instance, start a second instance of the "
"Tarantool server on the same computer with the same :ref:`box.cfg "
"<box_introspection-box_cfg>` configuration settings -- including the same"
" directories and same non-null URIs -- and with the additional "
"configuration setting ``hot_standby = true``. Expect to see a "
"notification ending with the words ``I> Entering hot standby mode``. This"
" is fine. It means that the standby instance is ready to take over if the"
" primary instance goes down."
msgstr ""
"Чтобы создать резервный экземпляр, запустите второй экземпляр "
"Tarantool-сервера на том же компьютере с теми же настройками конфигурации"
" :ref:`box.cfg <box_introspection-box_cfg>` -- включая одинаковые "
"директории и ненулевые URI -- и с дополнительной настройкой конфигурации "
"``hot_standby = true``. В ближайшее время вы увидите уведомление, которое"
" заканчивается словами ``I> Entering hot standby mode`` (вход в режим "
"горячего резервирования). Всё в порядке -- это означает, что резервный "
"экземпляр готов взять работу на себя, если основной экземпляр прекратит "
"работу."

#: ../doc/1.10/reference/configuration/cfg_hot_standby.rst:22
msgid ""
"The standby instance will initialize and will try to take a lock on "
":ref:`wal_dir <cfg_basic-wal_dir>`, but will fail because the primary "
"instance has made a lock on ``wal_dir``. So the standby instance goes "
"into a loop, reading the write ahead log which the primary instance is "
"writing (so the two instances are always in sync), and trying to take the"
" lock. If the primary instance goes down for any reason, the lock will be"
" released. In this case, the standby instance will succeed in taking the "
"lock, will connect on the :ref:`listen <cfg_basic-listen>` address and "
"will become the primary instance. Expect to see a notification ending "
"with the words ``I> ready to accept requests``."
msgstr ""
"Резервный экземпляр начнет инициализацию и попытается заблокировать "
":ref:`wal_dir <cfg_basic-wal_dir>`, но не сможет, поскольку директория "
"``wal_dir`` заблокирована основным экземпляром. Поэтому резервный "
"экземпляр входит в цикл, выполняя чтение журнала упреждающей записи, в "
"который записывает данные основной экземпляр (поэтому два экземпляра "
"всегда синхронизированы), и пытаясь произвести блокировку. Если основной "
"экземпляр по какой-либо причине прекращает работу, блокировка снимается. "
"В таком случае резервный экземпляр сможет заблокировать директорию на "
"себя, подключится по адресу для :ref:`прослушивания <cfg_basic-listen>` и"
" станет основным экземпляром. В ближайшее время вы увидите уведомление, "
"которое заканчивается словами ``I> ready to accept requests`` (готов "
"принимать запросы)."

#: ../doc/1.10/reference/configuration/cfg_hot_standby.rst:35
msgid "Thus there is no noticeable downtime if the primary instance goes down."
msgstr ""
"Таким образом, если основной экземпляр прекращает работу, время простоя "
"отсутствует."

#: ../doc/1.10/reference/configuration/cfg_hot_standby.rst:37
msgid "Hot standby feature has no effect:"
msgstr "Функция горячего резервирования не работает:"

#: ../doc/1.10/reference/configuration/cfg_hot_standby.rst:39
msgid ""
"if :ref:`wal_dir_rescan_delay = a large number "
"<cfg_binary_logging_snapshots-wal_dir_rescan_delay>` (on Mac OS and "
"FreeBSD); on these platforms, it is designed so that the loop repeats "
"every ``wal_dir_rescan_delay`` seconds."
msgstr ""
"если :ref:`wal_dir_rescan_delay = большое число "
"<cfg_binary_logging_snapshots-wal_dir_rescan_delay>` (в Mac OS и "
"FreeBSD); на этих платформах цикл запрограммирован на повторение каждые "
"``wal_dir_rescan_delay`` секунд."

#: ../doc/1.10/reference/configuration/cfg_hot_standby.rst:43
msgid ""
"if :ref:`wal_mode = 'none' <cfg_binary_logging_snapshots-wal_mode>`; it "
"is designed to work with ``wal_mode = 'write'`` or ``wal_mode = "
"'fsync'``."
msgstr ""
"если :ref:`wal_mode = 'none' <cfg_binary_logging_snapshots-wal_mode>`; "
"будет работать только при ``wal_mode = 'write'`` или ``wal_mode = "
"'fsync'``."

#: ../doc/1.10/reference/configuration/cfg_hot_standby.rst:45
msgid ""
"for spaces created with :ref:`engine = 'vinyl' <box_schema-"
"space_create>`; it is designed to work for spaces created with ``engine ="
" 'memtx'``."
msgstr ""
"со спейсами, созданными на движке vinyl :ref:`engine = 'vinyl' "
"<box_schema-space_create>`; работает с движком memtx ``engine = "
"'memtx'``."

#: ../doc/1.10/reference/configuration/cfg_replication.rst:1
msgid ":ref:`replication <cfg_replication-replication>`"
msgstr ":ref:`replication <cfg_replication-replication>`"

#: ../doc/1.10/reference/configuration/cfg_replication.rst:2
msgid ":ref:`replication_timeout <cfg_replication-replication_timeout>`"
msgstr ":ref:`replication_timeout <cfg_replication-replication_timeout>`"

#: ../doc/1.10/reference/configuration/cfg_replication.rst:3
msgid ""
":ref:`replication_connect_timeout <cfg_replication-"
"replication_connect_timeout>`"
msgstr ""
":ref:`replication_connect_timeout <cfg_replication-"
"replication_connect_timeout>`"

#: ../doc/1.10/reference/configuration/cfg_replication.rst:4
msgid ""
":ref:`replication_connect_quorum <cfg_replication-"
"replication_connect_quorum>`"
msgstr ""
":ref:`replication_connect_quorum <cfg_replication-"
"replication_connect_quorum>`"

#: ../doc/1.10/reference/configuration/cfg_replication.rst:5
msgid ""
":ref:`replication_skip_conflict <cfg_replication-"
"replication_skip_conflict>`"
msgstr ""
":ref:`replication_skip_conflict <cfg_replication-"
"replication_skip_conflict>`"

#: ../doc/1.10/reference/configuration/cfg_replication.rst:6
msgid ":ref:`replication_sync_lag <cfg_replication-replication_sync_lag>`"
msgstr ":ref:`replication_sync_lag <cfg_replication-replication_sync_lag>`"

#: ../doc/1.10/reference/configuration/cfg_replication.rst:7
msgid ":ref:`replication_sync_timeout <cfg_replication-replication_sync_timeout>`"
msgstr ":ref:`replication_sync_timeout <cfg_replication-replication_sync_timeout>`"

#: ../doc/1.10/reference/configuration/cfg_replication.rst:8
msgid ":ref:`replicaset_uuid <cfg_replication-replicaset_uuid>`"
msgstr ":ref:`replicaset_uuid <cfg_replication-replicaset_uuid>`"

#: ../doc/1.10/reference/configuration/cfg_replication.rst:9
msgid ":ref:`instance_uuid <cfg_replication-instance_uuid>`"
msgstr ":ref:`instance_uuid <cfg_replication-instance_uuid>`"

#: ../doc/1.10/reference/configuration/cfg_replication.rst:15
msgid ""
"If ``replication`` is not an empty string, the instance is considered to "
"be a Tarantool :ref:`replica <replication>`. The replica will try to "
"connect to the master specified in ``replication`` with a :ref:`URI "
"<index-uri>` (Universal Resource Identifier), for example:"
msgstr ""
"Если ``replication`` не содержит пустую строку, экземпляр считается "
":ref:`репликой <replication>`. Реплика попытается подключиться к мастеру,"
" указанному в параметре ``replication`` по :ref:`URI <index-uri>` "
"(унифицированному идентификатору ресурса), например:"

#: ../doc/1.10/reference/configuration/cfg_replication.rst:20
msgid ":samp:`{konstantin}:{secret_password}@{tarantool.org}:{3301}`"
msgstr ":samp:`{konstantin}:{secret_password}@{tarantool.org}:{3301}`"

#: ../doc/1.10/reference/configuration/cfg_replication.rst:22
msgid ""
"If there is more than one replication source in a replica set, specify an"
" array of URIs, for example (replace 'uri' and 'uri2' in this example "
"with valid URIs):"
msgstr ""
"Если в наборе реплик более одного источника репликации, укажите массив "
"URI, например (замените 'uri' и 'uri2' в данном примере на рабочие URI):"

#: ../doc/1.10/reference/configuration/cfg_replication.rst:26
msgid ":extsamp:`box.cfg{ replication = { {*{'uri1'}*}, {*{'uri2'}*} } }`"
msgstr ":extsamp:`box.cfg{ replication = { {*{'uri1'}*}, {*{'uri2'}*} } }`"

#: ../doc/1.10/reference/configuration/cfg_replication.rst:28
msgid ""
"If one of the URIs is \"self\" -- that is, if one of the URIs is for the "
"instance where ``box.cfg{}`` is being executed on -- then it is ignored. "
"Thus it is possible to use the same ``replication`` specification on "
"multiple server instances, as shown in :ref:`these examples <replication-"
"bootstrap>`."
msgstr ""
"Если один из URI \"свой\" -- то есть один URI принадлежит экземпляру, где"
" выполняется ``box.cfg{}`` -- он не принимается во внимание. Таким "
"образом, можно использовать одну и ту же настройку параметра "
"``replication`` на нескольких экземплярах сервера, как показано в "
":ref:`этих примерах <replication-bootstrap>`."

#: ../doc/1.10/reference/configuration/cfg_replication.rst:34
msgid "The default user name is 'guest'."
msgstr "По умолчанию, пользователем считается 'guest'."

#: ../doc/1.10/reference/configuration/cfg_replication.rst:36
msgid ""
"A read-only replica does not accept data-change requests on the "
":ref:`listen <cfg_basic-listen>` port."
msgstr ""
"Реплика в режиме только для чтения не принимает запросы по изменению "
"данных по порту для :ref:`прослушивания <cfg_basic-listen>`."

#: ../doc/1.10/reference/configuration/cfg_replication.rst:39
msgid ""
"The ``replication`` parameter is dynamic, that is, to enter master mode, "
"simply set ``replication`` to an empty string and issue:"
msgstr ""
"Параметр ``replication`` является динамическим, то есть для входа в режим"
" мастера необходимо просто присвоить параметру ``replication`` пустую "
"строку и выполнить следующее:"

#: ../doc/1.10/reference/configuration/cfg_replication.rst:42
msgid ":extsamp:`box.cfg{ replication = {*{new-value}*} }`"
msgstr ":extsamp:`box.cfg{ replication = {*{новое-значение}*} }`"

#: ../doc/1.10/reference/configuration/cfg_replication.rst:52
msgid ""
"A replica sends heartbeat messages to the master every second, and the "
"master is programmed to reconnect automatically if it doesn’t see "
"heartbeat messages more often than ``replication_timeout`` seconds."
msgstr ""
"Реплика отправляет сообщения контрольного сигнала на мастер каждую "
"секунду, и мастер запрограммирован на автоматическое переподключение, "
"если он не получает сообщения контрольного сигнала дольше количества "
"секунд, указанного в ``replication_timeout``."

#: ../doc/1.10/reference/configuration/cfg_replication.rst:56
msgid "See more in :ref:`Monitoring a replica set <replication-monitoring>`."
msgstr ""
"См. дополнительную информацию в разделе :ref:`Мониторинг набора реплик "
"<replication-monitoring>`."

#: ../doc/1.10/reference/configuration/cfg_replication.rst:59
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1134
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1149
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1200
msgid "Default: 1"
msgstr "По умолчанию: 1"

#: ../doc/1.10/reference/configuration/cfg_replication.rst:66
msgid ""
"The number of seconds that a replica will wait when trying to connect to "
"a master in a cluster. See :ref:`orphan status <replication-"
"orphan_status>` for details."
msgstr ""
"Количество секунд, в течение которых реплика ожидает попытки подключения "
"к мастеру в кластере. Для получения подробной информации, см. "
":ref:`статус orphan <replication-orphan_status>`."

#: ../doc/1.10/reference/configuration/cfg_replication.rst:70
msgid ""
"This parameter is different from :ref:`replication_timeout "
"<cfg_replication-replication_timeout>`, which is only used to "
"automatically reconnect replication when it gets no heartbeats."
msgstr ""
"Данный параметр отличается от :ref:`replication_timeout <cfg_replication-"
"replication_timeout>`, который используется только для автоматического "
"переподключения репликации, когда отсутствуют сообщения контрольного "
"сигнала."

#: ../doc/1.10/reference/configuration/cfg_replication.rst:83
msgid ""
"By default a replica will try to connect to all the masters, or it will "
"not start. (The default is recommended so that all replicas will receive "
"the same replica set UUID.)"
msgstr ""
"По умолчанию, реплика попытается подключиться ко всем мастерам или не "
"запустится. (По умолчанию, рекомендуется, чтобы у всех реплик был "
"одинаковый UUID набора реплик)."

#: ../doc/1.10/reference/configuration/cfg_replication.rst:87
msgid ""
"However, by specifying ``replication_connect_quorum = N``, where N is a "
"number greater than or equal to zero, users can state that the replica "
"only needs to connect to N masters."
msgstr ""
"Однако, если указать ``replication_connect_quorum = N``, где N означает "
"число больше или равное нулю, это будет означать, что реплике нужно "
"подключиться к N количеству мастеров."

#: ../doc/1.10/reference/configuration/cfg_replication.rst:91
msgid ""
"This parameter has effect during bootstrap and during :ref:`configuration"
" update <replication-configuration_update>`. Setting "
"``replication_connect_quorum = 0`` makes Tarantool require no immediate "
"reconnect only in case of recovery. See :ref:`orphan status <replication-"
"orphan_status>` for details."
msgstr ""
"Данный параметр используется во время настройки и :ref:`обновления "
"конфигурации <replication-configuration_update>`. При настройке "
"``replication_connect_quorum = 0`` Tarantool не требует немедленного "
"переподключения в случае восстановления. Для получения подробной "
"информации, см. :ref:`статус orphan <replication-orphan_status>`."

#: ../doc/1.10/reference/configuration/cfg_replication.rst:97
#: ../doc/1.10/reference/configuration/cfg_replication.rst:118
#: ../doc/1.10/reference/configuration/cfg_replication.rst:208
#: ../doc/1.10/reference/configuration/cfg_replication.rst:230
msgid "Example:"
msgstr "Пример:"

#: ../doc/1.10/reference/configuration/cfg_replication.rst:99
msgid "box.cfg{replication_connect_quorum=2}"
msgstr "box.cfg{replication_connect_quorum=2}"

#: ../doc/1.10/reference/configuration/cfg_replication.rst:111
msgid ""
"By default, if a replica adds a unique key that another replica has "
"added, replication :ref:`stops <replication-replication_stops>` with "
"error = ER_TUPLE_FOUND."
msgstr ""
"По умолчанию, если реплика добавляет уникальный ключ, который уже "
"добавила другая реплика, репликация :ref:`останавливается <replication-"
"replication_stops>` с ошибкой = ER_TUPLE_FOUND."

#: ../doc/1.10/reference/configuration/cfg_replication.rst:115
msgid ""
"However, by specifying ``replication_skip_conflict = true``, users can "
"state that such errors may be ignored."
msgstr ""
"Однако если указать ``replication_skip_conflict = true``, пользователи "
"могут задать пропуск таких ошибок."

#: ../doc/1.10/reference/configuration/cfg_replication.rst:120
msgid "box.cfg{replication_skip_conflict=true}"
msgstr "box.cfg{replication_skip_conflict=true}"

#: ../doc/1.10/reference/configuration/cfg_replication.rst:133
msgid ""
"The maximum :ref:`lag <box_info_replication_upstream_lag>` allowed for a "
"replica. When a replica :ref:`syncs <replication-orphan_status>` (gets "
"updates from a master), it may not catch up completely. The number of "
"seconds that the replica is behind the master is called the \"lag\". "
"Syncing is considered to be complete when the replica's lag is less than "
"or equal to ``replication_sync_lag``."
msgstr ""
"Максимально допустимое :ref:`отставание "
"<box_info_replication_upstream_lag>` для реплики. Если реплика "
":ref:`синхронизируется <replication-orphan_status>` (то есть получает "
"обновления от мастера), она может обновиться не полностью. Количество "
"секунд, когда реплика находится позади мастера, называется \"отставание\""
" (lag). Синхронизация считается завершенной, когда отставание реплики "
"меньше или равно ``replication_sync_lag``."

#: ../doc/1.10/reference/configuration/cfg_replication.rst:140
msgid ""
"If a user sets ``replication_sync_lag`` to nil or to 365 * 100 * 86400 "
"(TIMEOUT_INFINITY), then lag does not matter -- the replica is always "
"considered to be \"synced\". Also, the lag is ignored (assumed to be "
"infinite) in case the master is running Tarantool older than 1.7.7, which"
" does not send :ref:`heartbeat messages <heartbeat>`."
msgstr ""
"Если пользователь задает значение ``replication_sync_lag``, равное nil "
"или 365 * 100 * 86400 (TIMEOUT_INFINITY), то отставание не имеет значения"
" -- реплика всегда будет синхронизирована. Кроме того, отставание не "
"учитывается (считается бесконечным), если мастер работает на версии "
"Tarantool'а старше 1.7.7, которая не отправляет :ref:`сообщения "
"контрольного сигнала <heartbeat>`."

#: ../doc/1.10/reference/configuration/cfg_replication.rst:145
msgid ""
"This parameter is ignored during bootstrap. See :ref:`orphan status "
"<replication-orphan_status>` for details."
msgstr ""
"Этот параметр не учитывается во время настройки. Для получения подробной "
"информации, см. :ref:`статус orphan <replication-orphan_status>`."

#: ../doc/1.10/reference/configuration/cfg_replication.rst:149
msgid "Default: 10"
msgstr "По умолчанию: 10"

#: ../doc/1.10/reference/configuration/cfg_replication.rst:156
msgid ""
"The number of seconds that a replica will wait when trying to sync with a"
" master in a cluster, or a :ref:`quorum <cfg_replication-"
"replication_connect_quorum>` of masters, after connecting or during "
":ref:`configuration update <replication-configuration_update>`. This "
"could fail indefinitely if ``replication_sync_lag`` is smaller than "
"network latency, or if the replica cannot keep pace with master updates. "
"If ``replication_sync_timeout`` expires, the replica enters :ref:`orphan "
"status <replication-orphan_status>`."
msgstr ""
"Количество секунд, в течение которых реплика ожидает попытки "
"синхронизации с мастером в кластере или :ref:`кворумом <cfg_replication-"
"replication_connect_quorum>` мастеров после подключения или во время "
":ref:`обновления конфигурации <replication-configuration_update>`, что "
"может никогда не произойти, если значение ``replication_sync_lag`` меньше"
" сетевой задержки, или реплика не может поддерживать темп обновлений "
"мастера. По истечении времени ``replication_sync_timeout`` реплика "
"получает :ref:`статус orphan <replication-orphan_status>`."

#: ../doc/1.10/reference/configuration/cfg_replication.rst:166
msgid "Default: 300"
msgstr "По умолчанию: 300"

#: ../doc/1.10/reference/configuration/cfg_replication.rst:173
msgid ""
"As described in section :ref:`\"Replication architecture\" <replication-"
"architecture>`, each replica set is identified by a `universally unique "
"identifier "
"<https://en.wikipedia.org/wiki/Universally_unique_identifier>`_ called "
"**replica set UUID**, and each instance is identified by an **instance "
"UUID**."
msgstr ""
"Как описано в разделе :ref:`\"Архитектура механизма репликации\" "
"<replication-architecture>`, каждый набор реплик идентифицируется по "
"`Универсальному уникальному идентификатору (UUID) "
"<https://en.wikipedia.org/wiki/Universally_unique_identifier>`_, который "
"называется **UUID набора реплик**, и каждый экземпляр идентифицируется по"
" **UUID экземпляра**."

#: ../doc/1.10/reference/configuration/cfg_replication.rst:180
msgid ""
"Ordinarily it is sufficient to let the system generate and format the "
"UUID strings which will be permanently stored."
msgstr ""
"Как правило, достаточно позволить системе сгенерировать и форматировать "
"строки, содержащие UUID, которые будут храниться постоянно."

#: ../doc/1.10/reference/configuration/cfg_replication.rst:183
msgid ""
"However, some administrators may prefer to store Tarantool configuration "
"information in a central repository, for example `Apache ZooKeeper "
"<https://zookeeper.apache.org>`_. Such administrators can assign their "
"own UUID values for either -- or both -- instances (:ref:`instance_uuid "
"<cfg_replication-instance_uuid>`) and replica set (``replicaset_uuid``), "
"when starting up for the first time."
msgstr ""
"Однако, некоторые администраторы предпочитают сохранять конфигурацию "
"Tarantool'а в центральном репозитории, например, `Apache ZooKeeper "
"<https://zookeeper.apache.org>`_. Они могут самостоятельно присвоить "
"значения экземплярам (:ref:`instance_uuid <cfg_replication-"
"instance_uuid>`) и набору реплик (``replicaset_uuid``) при первом "
"запуске."

#: ../doc/1.10/reference/configuration/cfg_replication.rst:190
msgid "General rules:"
msgstr "Общие правила:"

#: ../doc/1.10/reference/configuration/cfg_replication.rst:192
msgid ""
"The values must be true unique identifiers, not shared by other instances"
" or replica sets within the common infrastructure."
msgstr ""
"Значения должны быть действительно уникальными; они не должны "
"одновременно принадлежать другим экземплярам или наборам реплик в той же "
"инфраструктуре."

#: ../doc/1.10/reference/configuration/cfg_replication.rst:195
msgid ""
"The values must be used consistently, not changed after initial setup "
"(the initial values are stored in :ref:`snapshot files <index-"
"box_persistence>` and are checked whenever the system is restarted)."
msgstr ""
"Значения должны использоваться постоянно, неизменно с первого запуска "
"(первоначальные значения хранятся в :ref:`файлах снимков <index-"
"box_persistence>` и проверяются при каждом перезапуске системы)."

#: ../doc/1.10/reference/configuration/cfg_replication.rst:199
msgid ""
"The values must comply with `RFC 4122 "
"<https://tools.ietf.org/html/rfc4122>`_. The `nil UUID "
"<https://tools.ietf.org/html/rfc4122#section-4.1.7>`_ is not allowed."
msgstr ""
"Значения должны соответствовать требованиям `RFC 4122 "
"<https://tools.ietf.org/html/rfc4122>`_. `Нулевой UUID "
"<https://tools.ietf.org/html/rfc4122#section-4.1.7>`_ не допускается."

#: ../doc/1.10/reference/configuration/cfg_replication.rst:203
msgid ""
"The UUID format includes sixteen octets represented as 32 hexadecimal "
"(base 16) digits, displayed in five groups separated by hyphens, in the "
"form ``8-4-4-4-12`` for a total of 36 characters (32 alphanumeric "
"characters and four hyphens)."
msgstr ""
"Формат UUID включает в себя шестнадцать октетов, представленных в виде 32"
" шестнадцатеричных чисел (с основанием 16) в пяти группах, разделенных "
"дефисами в форме ``8-4-4-4-12`` -- 36 символов (32 буквенно-цифровых "
"символа и четыре дефиса)."

#: ../doc/1.10/reference/configuration/cfg_replication.rst:210
msgid "box.cfg{replicaset_uuid='7b853d13-508b-4b8e-82e6-806f088ea6e9'}"
msgstr "box.cfg{replicaset_uuid='7b853d13-508b-4b8e-82e6-806f088ea6e9'}"

#: ../doc/1.10/reference/configuration/cfg_replication.rst:222
msgid ""
"For replication administration purposes, it is possible to set the "
"`universally unique identifiers "
"<https://en.wikipedia.org/wiki/Universally_unique_identifier>`_ of the "
"instance (``instance_uuid``) and the replica set (``replicaset_uuid``), "
"instead of having the system generate the values."
msgstr ""
"Для целей администрирования репликации можно самостоятельно присвоить "
"`универсально уникальные идентификаторы "
"<https://en.wikipedia.org/wiki/Universally_unique_identifier>`_ "
"экземпляру (``instance_uuid``) и набору реплик (``replicaset_uuid``) "
"вместо использования сгенерированных системой значений."

#: ../doc/1.10/reference/configuration/cfg_replication.rst:227
msgid ""
"See the description of :ref:`replicaset_uuid <cfg_replication-"
"replicaset_uuid>` parameter for details."
msgstr ""
"Для получения подробной информации см. описание параметра "
":ref:`replicaset_uuid <cfg_replication-replicaset_uuid>`."

#: ../doc/1.10/reference/configuration/cfg_replication.rst:232
msgid "box.cfg{instance_uuid='037fec43-18a9-4e12-a684-a42b716fcd02'}"
msgstr "box.cfg{instance_uuid='037fec43-18a9-4e12-a684-a42b716fcd02'}"

#: ../doc/1.10/reference/configuration/index.rst:264
msgid "Networking"
msgstr "Работа с сетями"

#: ../doc/1.10/reference/configuration/cfg_networking.rst:1
msgid ":ref:`io_collect_interval <cfg_networking-io_collect_interval>`,"
msgstr ":ref:`io_collect_interval <cfg_networking-io_collect_interval>`,"

#: ../doc/1.10/reference/configuration/cfg_networking.rst:2
msgid ":ref:`net_msg_max <cfg_networking-net_msg_max>`"
msgstr ":ref:`net_msg_max <cfg_networking-net_msg_max>`"

#: ../doc/1.10/reference/configuration/cfg_networking.rst:3
msgid ":ref:`readahead <cfg_networking-readahead>`,"
msgstr ":ref:`readahead <cfg_networking-readahead>`,"

#: ../doc/1.10/reference/configuration/cfg_networking.rst:9
msgid ""
"The instance will sleep for io_collect_interval seconds between "
"iterations of the event loop. Can be used to reduce CPU load in "
"deployments in which the number of client connections is large, but "
"requests are not so frequent (for example, each connection issues just a "
"handful of requests per second)."
msgstr ""
"Экземпляр уходит в режим ожидания на io_collect_interval секунд между "
"итерациями событийного цикла. Это можно использовать для снижения "
"загрузки процессора в системах с большим количество клиентских "
"соединений, но нечастыми запросами (например, каждое соединение передает "
"лишь небольшое количество запросов в секунду)."

#: ../doc/1.10/reference/configuration/cfg_networking.rst:22
msgid ""
"To handle messages, Tarantool allocates fibers. To prevent fiber overhead"
" from affecting the whole system, Tarantool restricts how many messages "
"the fibers handle, so that some pending requests are blocked."
msgstr ""
"Для обработки сообщений Tarantool выделяет файберы. Чтобы не допустить "
"перегрузки файберов, которая влияет на всю систему, Tarantool "
"ограничивает число сообщений, которые могут обрабатывать файберы, чтобы "
"блокировать некоторые отложенные запросы."

#: ../doc/1.10/reference/configuration/cfg_networking.rst:27
msgid ""
"On powerful systems, increase ``net_msg_max`` and the scheduler will "
"immediately start processing pending requests."
msgstr ""
"В мощных системах увеличьте значение ``net_msg_max``, и планировщик "
"немедленно приступит к обработке отложенных запросов."

#: ../doc/1.10/reference/configuration/cfg_networking.rst:30
msgid ""
"On weaker systems, decrease ``net_msg_max`` and the overhead may decrease"
" although this may take some time because the scheduler must wait until "
"already-running requests finish."
msgstr ""
"В более слабых системах уменьшите значение``net_msg_max``, чтобы снизить "
"загрузку, хотя это и займет некоторое время, поскольку планировщик будет "
"ожидать завершения уже запущенных запросов."

#: ../doc/1.10/reference/configuration/cfg_networking.rst:34
msgid ""
"When ``net_msg_max`` is reached, Tarantool suspends processing of "
"incoming packages until it has processed earlier messages. This is not a "
"direct restriction of the number of fibers that handle network messages, "
"rather it is a system-wide restriction of channel bandwidth. This in turn"
" causes restriction of the number of incoming network messages that the "
":ref:`transaction processor thread <atomic-threads_fibers_yields>` "
"handles, and therefore indirectly affects the fibers that handle network "
"messages. (The number of fibers is smaller than the number of messages "
"because messages can be released as soon as they are delivered, while "
"incoming requests might not be processed until some time after delivery.)"
msgstr ""
"По достижении значения ``net_msg_max`` Tarantool приостанавливает "
"обработку входящих пакетов до тех пор, пока не обработает ранее "
"полученные сообщения. Это не ограничение количества файберов, которые "
"обрабатывают сетевые сообщения, напрямую, а скорее общесистемное "
"ограничение ширины полосы канала. В свою очередь, это вызывает "
"ограничение количества входящих сетевых сообщений, которые обрабатывает "
":ref:`поток обработки транзакций <atomic-threads_fibers_yields>`, таким "
"образом косвенно воздействуя на количество файберов, которые обрабатывают"
" сетевые сообщения. (Количество файберов меньше количества сообщений, "
"поскольку сообщения можно освободить сразу после доставки, а входящие "
"запросы могут ждать обработки в течение некоторого времени после "
"доставки.)"

#: ../doc/1.10/reference/configuration/cfg_networking.rst:48
msgid "On typical systems, the default value (768) is correct."
msgstr "Для стандартных систем подойдет значение, используемое по умолчанию (768)."

#: ../doc/1.10/reference/configuration/cfg_networking.rst:51
msgid "Default: 768"
msgstr "По умолчанию: 768"

#: ../doc/1.10/reference/configuration/cfg_networking.rst:58
msgid ""
"The size of the read-ahead buffer associated with a client connection. "
"The larger the buffer, the more memory an active connection consumes and "
"the more requests can be read from the operating system buffer in a "
"single system call. The rule of thumb is to make sure the buffer can "
"contain at least a few dozen requests. Therefore, if a typical tuple in a"
" request is large, e.g. a few kilobytes or even megabytes, the read-ahead"
" buffer size should be increased. If batched request processing is not "
"used, it’s prudent to leave this setting at its default."
msgstr ""
"Размер буфера опережающего считывания, связанный с клиентским "
"соединением. Чем больше буфер, тем больше памяти потребляет активное "
"соединение и тем больше запросов можно считать из буфера операционной "
"системы за отдельный системный вызов. Общее правило состоит в том, чтобы "
"убедиться, что буфер может содержать как минимум несколько десятков "
"соединений. Таким образом, если размер стандартного кортежа в запросе "
"значительный, например, несколько килобайтов или даже мегабайтов, следует"
" увеличить размер буфера опережающего считывания. Если не используется "
"пакетная обработка запросов, будет целесообразно оставить значение, "
"используемое по умолчанию."

#: ../doc/1.10/reference/configuration/cfg_networking.rst:68
msgid "Default: 16320"
msgstr "По умолчанию: 16320"

#: ../doc/1.10/reference/configuration/cfg_logging.rst:3
msgid ":ref:`log_level <cfg_logging-log_level>`"
msgstr ":ref:`log_level <cfg_logging-log_level>`"

#: ../doc/1.10/reference/configuration/cfg_logging.rst:4
msgid ":ref:`log <cfg_logging-log>`"
msgstr ":ref:`log <cfg_logging-log>`"

#: ../doc/1.10/reference/configuration/cfg_logging.rst:5
msgid ":ref:`log_nonblock <cfg_logging-log_nonblock>`"
msgstr ":ref:`log_nonblock <cfg_logging-log_nonblock>`"

#: ../doc/1.10/reference/configuration/cfg_logging.rst:6
msgid ":ref:`too_long_threshold <cfg_logging-too_long_threshold>`"
msgstr ":ref:`too_long_threshold <cfg_logging-too_long_threshold>`"

#: ../doc/1.10/reference/configuration/cfg_logging.rst:7
msgid ":ref:`log_format <cfg_logging-log_format>`"
msgstr ":ref:`log_format <cfg_logging-log_format>`"

#: ../doc/1.10/reference/configuration/cfg_logging.rst:13
msgid ""
"What level of detail the :ref:`log <admin-logs>` will have. There are "
"seven levels:"
msgstr "Уровень детализации записей :ref:`журнала <admin-logs>`. Есть 7 уровней:"

#: ../doc/1.10/reference/configuration/cfg_logging.rst:15
#: ../doc/1.10/reference/reference_lua/log.rst:125
msgid "1 – ``SYSERROR``"
msgstr "1 – ``SYSERROR``"

#: ../doc/1.10/reference/configuration/cfg_logging.rst:16
msgid "2 – ``ERROR``"
msgstr "2 – ``ERROR``"

#: ../doc/1.10/reference/configuration/cfg_logging.rst:17
#: ../doc/1.10/reference/reference_lua/log.rst:127
msgid "3 – ``CRITICAL``"
msgstr "3 – ``CRITICAL``"

#: ../doc/1.10/reference/configuration/cfg_logging.rst:18
msgid "4 – ``WARNING``"
msgstr "4 – ``WARNING``"

#: ../doc/1.10/reference/configuration/cfg_logging.rst:19
msgid "5 – ``INFO``"
msgstr "5 – ``INFO``"

#: ../doc/1.10/reference/configuration/cfg_logging.rst:20
msgid "6 – ``VERBOSE``"
msgstr "6 – ``VERBOSE``"

#: ../doc/1.10/reference/configuration/cfg_logging.rst:21
msgid "7 – ``DEBUG``"
msgstr "7 – ``DEBUG``"

#: ../doc/1.10/reference/configuration/cfg_logging.rst:23
msgid ""
"By setting log_level, one can enable logging of all classes below or "
"equal to the given level. Tarantool prints its logs to the standard error"
" stream by default, but this can be changed with the :ref:`log "
"<cfg_logging-log>` configuration parameter."
msgstr ""
"Задав значение параметра log_level, можно включить запись в журнал всех "
"событий заданного уровня или ниже. По умолчанию, Tarantool выводит записи"
" в стандартный поток сообщений об ошибках, но это можно изменить с "
"помощью конфигурационного параметра :ref:`log <cfg_logging-log>`."

#: ../doc/1.10/reference/configuration/cfg_logging.rst:29
msgid "Default: 5"
msgstr "По умолчанию: 5"

#: ../doc/1.10/reference/configuration/cfg_logging.rst:32
msgid ""
"Warning: prior to Tarantool 1.7.5 there were only six levels and "
"``DEBUG`` was level 6. Starting with Tarantool 1.7.5 ``VERBOSE`` is level"
" 6 and ``DEBUG`` is level 7. ``VERBOSE`` is a new level for monitoring "
"repetitive events which would cause too much log writing if ``INFO`` were"
" used instead."
msgstr ""
"Внимание: до версии Tarantool'а 1.7.5 было только 6 уровней, из них "
"шестым был уровень ``DEBUG``. Начиная с версии Tarantool'а 1.7.5 "
"``VERBOSE`` становится уровнем 6, а ``DEBUG`` -- уровнем 7. ``VERBOSE`` "
"представляет собой новый уровень для мониторинга повторяющихся событий, "
"которые бы привели к слишком большому количеству записей журнала при "
"использовании уровня ``INFO``."

#: ../doc/1.10/reference/configuration/cfg_logging.rst:41
msgid ""
"By default, Tarantool sends the log to the standard error stream "
"(``stderr``). If ``log`` is specified, Tarantool sends the log to a file,"
" or to a pipe, or to the system logger."
msgstr ""
"По умолчанию, Tarantool выводит записи в стандартный поток сообщений об "
"ошибках (``stderr``). Если задан параметр ``log``, Tarantool отправит "
"записи журнала в файл, в конвейер или в системный журнал syslog."

#: ../doc/1.10/reference/configuration/cfg_logging.rst:45
msgid "Example setting for sending the log to a file:"
msgstr "Пример настройки для отправки журнала в файл:"

#: ../doc/1.10/reference/configuration/cfg_logging.rst:47
msgid ""
"box.cfg{log = 'tarantool.log'}\n"
"-- or\n"
"box.cfg{log = 'file:tarantool.log'}"
msgstr ""
"box.cfg{log = 'tarantool.log'}\n"
"-- или\n"
"box.cfg{log = 'file:tarantool.log'}"

#: ../doc/1.10/reference/configuration/cfg_logging.rst:53
msgid ""
"This will open the file ``tarantool.log`` for output on the server’s "
"default directory. If the ``log`` string has no prefix or has the prefix "
"\"file:\", then the string is interpreted as a file path."
msgstr ""
"Откроется файл ``tarantool.log`` для вывода в директории сервера, "
"используемой по умолчанию. Если в строке ``log`` нет префикса или есть "
"префикс \"file:\", то строка считается путем к файлу."

#: ../doc/1.10/reference/configuration/cfg_logging.rst:57
msgid "Example setting for sending the log to a pipe:"
msgstr "Пример настройки для отправки журнала в конвейер:"

#: ../doc/1.10/reference/configuration/cfg_logging.rst:59
msgid ""
"box.cfg{log = '| cronolog tarantool.log'}\n"
"-- or\n"
"box.cfg{log = 'pipe: cronolog tarantool.log'}'"
msgstr ""
"box.cfg{log = '| cronolog tarantool.log'}\n"
"-- или\n"
"box.cfg{log = 'pipe: cronolog tarantool.log'}'"

#: ../doc/1.10/reference/configuration/cfg_logging.rst:65
msgid ""
"This will start the program `cronolog "
"<https://linux.die.net/man/1/cronolog>`_ when the server starts, and will"
" send all log messages to the standard input (``stdin``) of cronolog. If "
"the ``log`` string begins with '|' or has the prefix \"pipe:\", then the "
"string is interpreted as a Unix `pipeline "
"<https://en.wikipedia.org/wiki/Pipeline_%28Unix%29>`_."
msgstr ""
"Запустится программа `cronolog <https://linux.die.net/man/1/cronolog>`_ "
"при запуске сервера, которая будет отправлять все сообщения журнала на "
"стандартный вывод (``stdin``) в cronolog. Если строка ``log`` начинается "
"с '|' или содержит префикс \"pipe:\", то строка считается "
"Unix-`конвейером <https://en.wikipedia.org/wiki/Pipeline_%28Unix%29>`_."

#: ../doc/1.10/reference/configuration/cfg_logging.rst:71
msgid "Example setting for sending the log to syslog:"
msgstr "Пример настройки для отправки журнала в системный журнал syslog:"

#: ../doc/1.10/reference/configuration/cfg_logging.rst:73
msgid ""
"box.cfg{log = 'syslog:identity=tarantool'}\n"
"-- or\n"
"box.cfg{log = 'syslog:facility=user'}\n"
"-- or\n"
"box.cfg{log = 'syslog:identity=tarantool,facility=user'}\n"
"-- or\n"
"box.cfg{log = 'syslog:server=unix:/dev/log'}"
msgstr ""
"box.cfg{log = 'syslog:identity=tarantool'}\n"
"-- или\n"
"box.cfg{log = 'syslog:facility=user'}\n"
"-- или\n"
"box.cfg{log = 'syslog:identity=tarantool,facility=user'}\n"
"-- или\n"
"box.cfg{log = 'syslog:server=unix:/dev/log'}"

#: ../doc/1.10/reference/configuration/cfg_logging.rst:83
msgid ""
"If the ``log`` string begins with \"syslog:\", then it is interpreted as "
"a message for the `syslogd <http://www.rfc-base.org/txt/rfc-5424.txt>`_ "
"program which normally is running in the background of any Unix-like "
"platform. The setting can be 'syslog:', 'syslog:facility=...', "
"'syslog:identity=...', 'syslog:server=...', or a combination."
msgstr ""
"Если строка ``log`` начинается с \"syslog:\", это считается сообщением "
"для программы `syslogd <http://www.rfc-base.org/txt/rfc-5424.txt>`_, "
"которая, как правило, работает в фоне на любой Unix-платформе. Настройка "
"может быть: 'syslog:', 'syslog:facility=...', 'syslog:identity=...', "
"'syslog:server=...', или их комбинация."

#: ../doc/1.10/reference/configuration/cfg_logging.rst:90
msgid ""
"The ``syslog:identity`` setting is an arbitrary string which will be "
"placed at the beginning of all messages. The default value is: tarantool."
msgstr ""
"Настройка ``syslog:identity`` представляет собой произвольную строку, "
"которая размещается в начале всех сообщений. По умолчанию: tarantool."

#: ../doc/1.10/reference/configuration/cfg_logging.rst:93
msgid ""
"The ``syslog:facility`` setting is currently ignored but will be used in "
"the future. The value must be one of the `syslog "
"<https://en.wikipedia.org/wiki/Syslog>`_ keywords, which tell syslogd "
"where the message should go. The possible values are: auth, authpriv, "
"cron, daemon, ftp, kern, lpr, mail, news, security, syslog, user, uucp, "
"local0, local1, local2, local3, local4, local5, local6, local7. The "
"default value is: user."
msgstr ""
"В настоящий момент настройка ``syslog:facility`` не учитывается, но будет"
" использоваться в дальнейшем. Ее значением должно быть одно из ключевых "
"слов `syslog <https://en.wikipedia.org/wiki/Syslog>`_, которые сообщают "
"программе syslogd, куда отправлять сообщение. Возможные значения: auth, "
"authpriv, cron, daemon, ftp, kern, lpr, mail, news, security, syslog, "
"user, uucp, local0, local1, local2, local3, local4, local5, local6, "
"local7. По умолчанию: user."

#: ../doc/1.10/reference/configuration/cfg_logging.rst:100
msgid ""
"The ``syslog:server`` setting is the locator for the syslog server. It "
"can be a Unix socket path beginning with \"unix:\", or an ipv4 port "
"number. The default socket value is: dev/log (on Linux) or "
"/var/run/syslog (on Mac OS). The default port value is: 514, the UDP "
"port."
msgstr ""
"Настройка ``syslog:server`` -- это указатель для сервера syslog. Это "
"может быть путь к сокету Unix, который начинается с \"unix:\", или же "
"номер IPv4-порта. Значение по умолчанию для сокета: dev/log (в Linux) или"
" /var/run/syslog (в Mac OS). Значение по умолчанию для порта: 514, "
"UDP-порт."

#: ../doc/1.10/reference/configuration/cfg_logging.rst:105
msgid ""
"When logging to a file, Tarantool reopens the log on `SIGHUP "
"<https://en.wikipedia.org/wiki/SIGHUP>`_. When log is a program, its pid "
"is saved in the :ref:`log.logger_pid <log-logger_pid>` variable. You need"
" to send it a signal to rotate logs."
msgstr ""
"При записи в файл Tarantool повторно открывает журнал при сигнале `SIGHUP"
" <https://en.wikipedia.org/wiki/SIGHUP>`_. Если журнал является "
"программой, его PID сохраняется в переменной :ref:`log.logger_pid <log-"
"logger_pid>`. Необходимо отправить сигнал для ротации файлов журнала."

#: ../doc/1.10/reference/configuration/cfg_logging.rst:118
msgid ""
"If ``log_nonblock`` equals true, Tarantool does not block on the log file"
" descriptor when it’s not ready for write, and drops the message instead."
" If :ref:`log_level <cfg_logging-log_level>` is high, and many messages "
"go to the log file, setting ``log_nonblock`` to true may improve logging "
"performance at the cost of some log messages getting lost."
msgstr ""
"Если значение ``log_nonblock`` равно true (правда), Tarantool не "
"блокирует дескриптор файла журнала, когда он не готов вести запись, а "
"вместо этого сбрасывает сообщение. Если задан высокий уровень "
":ref:`log_level <cfg_logging-log_level>`,и много сообщений попадают в "
"файл журнала, перевод ``log_nonblock`` в true может улучшить "
"производительность ценой потери некоторых сообщений журнала."

#: ../doc/1.10/reference/configuration/cfg_logging.rst:124
msgid ""
"This parameter has effect only if the output is going to ``syslog`` or to"
" a pipe."
msgstr ""
"Данный параметр сработает, только если вывод производится в системный "
"журнал ``syslog`` или в конвейер."

#: ../doc/1.10/reference/configuration/cfg_deprecated.rst:56
#: ../doc/1.10/reference/configuration/cfg_deprecated.rst:67
#: ../doc/1.10/reference/configuration/cfg_logging.rst:128
#: ../doc/1.10/reference/configuration/cfg_logging.rst:283
msgid "Default: true"
msgstr "По умолчанию: true"

#: ../doc/1.10/reference/configuration/cfg_logging.rst:135
msgid ""
"If processing a request takes longer than the given value (in seconds), "
"warn about it in the log. Has effect only if :ref:`log_level "
"<cfg_logging-log_level>` is more than or equal to 4 (WARNING)."
msgstr ""
"Если обработка запроса занимает дольше времени, чем заданное значение (в "
"секундах), в журнал заносится соответствующее предупреждение. Сработает, "
"только если в :ref:`log_level <cfg_logging-log_level>` задан уровень 4 "
"(WARNING) или выше."

#: ../doc/1.10/reference/configuration/cfg_logging.rst:140
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1112
msgid "Default: 0.5"
msgstr "По умолчанию: 0.5"

#: ../doc/1.10/reference/configuration/cfg_logging.rst:147
msgid "Log entries have two possible formats:"
msgstr "Данные в журнал записываются в двух форматах:"

#: ../doc/1.10/reference/configuration/cfg_logging.rst:149
#: ../doc/1.10/reference/reference_lua/log.rst:55
msgid "'plain' (the default), or"
msgstr "'plain' (по умолчанию) или"

#: ../doc/1.10/reference/configuration/cfg_logging.rst:150
#: ../doc/1.10/reference/reference_lua/log.rst:56
msgid "'json' (with more detail and with JSON labels)."
msgstr "'json' (более детально с JSON-метками)."

#: ../doc/1.10/reference/configuration/cfg_logging.rst:152
#: ../doc/1.10/reference/reference_lua/log.rst:58
msgid "Here is what a log entry looks like after ``box.cfg{log_format='plain'}``:"
msgstr ""
"Вот как будет выглядеть запись в журнале после выполнения "
"``box.cfg{log_format='plain'}``:"

#: ../doc/1.10/reference/configuration/cfg_logging.rst:154
#: ../doc/1.10/reference/reference_lua/log.rst:60
msgid ""
"2017-10-16 11:36:01.508 [18081] main/101/interactive I> set 'log_format' "
"configuration option to \"plain\""
msgstr ""
"2017-10-16 11:36:01.508 [18081] main/101/interactive I> set 'log_format' "
"configuration option to \"plain\""

#: ../doc/1.10/reference/configuration/cfg_logging.rst:158
#: ../doc/1.10/reference/reference_lua/log.rst:64
msgid "Here is what a log entry looks like after ``box.cfg{log_format='json'}``:"
msgstr ""
"Вот как будет выглядеть запись в журнале после выполнения "
"``box.cfg{log_format='json'}``:"

#: ../doc/1.10/reference/configuration/cfg_logging.rst:160
#: ../doc/1.10/reference/reference_lua/log.rst:66
msgid ""
"{\"time\": \"2017-10-16T11:36:17.996-0600\",\n"
"\"level\": \"INFO\",\n"
"\"message\": \"set 'log_format' configuration option to \\\"json\\\"\",\n"
"\"pid\": 18081,|\n"
"\"cord_name\": \"main\",\n"
"\"fiber_id\": 101,\n"
"\"fiber_name\": \"interactive\",\n"
"\"file\": \"builtin\\/box\\/load_cfg.lua\",\n"
"\"line\": 317}"
msgstr ""
"{\"time\": \"2017-10-16T11:36:17.996-0600\",\n"
"\"level\": \"INFO\",\n"
"\"message\": \"set 'log_format' configuration option to \\\"json\\\"\",\n"
"\"pid\": 18081,|\n"
"\"cord_name\": \"main\",\n"
"\"fiber_id\": 101,\n"
"\"fiber_name\": \"interactive\",\n"
"\"file\": \"builtin\\/box\\/load_cfg.lua\",\n"
"\"line\": 317}"

#: ../doc/1.10/reference/configuration/cfg_logging.rst:172
msgid ""
"The ``log_format='plain'`` entry has time, process id, cord name, "
":ref:`fiber_id <fiber_object-id>`, :ref:`fiber_name <fiber_object-"
"name_get>`, :ref:`log level <cfg_logging-log_level>`, and message."
msgstr ""
"В простом формате (``log_format='plain'``) запись содержит время, "
"идентификатор процесса, имя файбера, идентификатор файбера :ref:`fiber_id"
" <fiber_object-id>`, имя файбера :ref:`fiber_name <fiber_object-"
"name_get>`, :ref:`уровень записи в журнал <cfg_logging-log_level>` и "
"сообщение."

#: ../doc/1.10/reference/configuration/cfg_logging.rst:177
msgid ""
"The ``log_format='json'`` entry has the same things along with their "
"labels, and in addition has the file name and line number of the "
"Tarantool source."
msgstr ""
"В JSON-формате (``log_format='json'``) запись содержит все "
"вышеперечисленное с соответствующими метками, а также имя файла и номер "
"строки Tarantool-источника."

#: ../doc/1.10/reference/configuration/cfg_logging.rst:181
msgid "Default: 'plain'"
msgstr "По умолчанию: 'plain'"

#: ../doc/1.10/reference/configuration/cfg_logging.rst:188
msgid "Logging example"
msgstr "Пример записи в журнал"

#: ../doc/1.10/reference/configuration/cfg_logging.rst:190
msgid ""
"This will illustrate how \"rotation\" works, that is, what happens when "
"the server instance is writing to a log and signals are used when "
"archiving it."
msgstr ""
"Данный пример проиллюстрирует ротацию файлов журнала, то есть что "
"происходит, когда экземпляр сервера производит запись в журнал? а при "
"архивировании используются сигналы."

#: ../doc/1.10/reference/configuration/cfg_logging.rst:193
msgid "Start with two terminal shells, Terminal #1 and Terminal #2."
msgstr "Запустите две оболочки, терминал №1 и терминал №2."

#: ../doc/1.10/reference/configuration/cfg_logging.rst:195
msgid ""
"On Terminal #1: start an interactive Tarantool session, then say the "
"logging will go to `Log_file`, then put a message \"Log Line #1\" in the "
"log file:"
msgstr ""
"На терминале №1 запустите интерактивную сессию Tarantool'а, затем "
"укажите, что запись в журнал ведется в файл `Log_file`, а затем поместите"
" сообщение \"Log Line #1\" в файл журнала:"

#: ../doc/1.10/reference/configuration/cfg_logging.rst:198
msgid ""
"box.cfg{log='Log_file'}\n"
"log = require('log')\n"
"log.info('Log Line #1')"
msgstr ""
"box.cfg{log='Log_file'}\n"
"log = require('log')\n"
"log.info('Log Line #1')"

#: ../doc/1.10/reference/configuration/cfg_logging.rst:204
msgid ""
"On Terminal #2: use ``mv`` so the log file is now named `Log_file.bak`. "
"The result of this is: the next log message will go to `Log_file.bak`."
msgstr ""
"На терминале №2 используйте команду ``mv``, чтобы файл журнала назывался "
"`Log_file.bak`. Результатом будет то, что следующее сообщение журнала "
"пойдет в файл `Log_file.bak`."

#: ../doc/1.10/reference/configuration/cfg_logging.rst:1462
msgid "mv Log_file Log_file.bak"
msgstr "mv Log_file Log_file.bak"

#: ../doc/1.10/reference/configuration/cfg_logging.rst:212
msgid "On Terminal #1: put a message \"Log Line #2\" in the log file."
msgstr "На терминале №1 поместите сообщение \"Log Line #2\" в файл журнала."

#: ../doc/1.10/reference/configuration/cfg_logging.rst:214
msgid "log.info('Log Line #2')"
msgstr "log.info('Log Line #2')"

#: ../doc/1.10/reference/configuration/cfg_logging.rst:218
msgid ""
"On Terminal #2: use ``ps`` to find the process ID of the Tarantool "
"instance."
msgstr ""
"На терминале №2 используйте команду ``ps``, чтобы найти ID процесса "
"экземпляра Tarantool'а."

#: ../doc/1.10/reference/configuration/cfg_logging.rst:1475
msgid "ps -A | grep tarantool"
msgstr "ps -A | grep tarantool"

#: ../doc/1.10/reference/configuration/cfg_logging.rst:225
msgid ""
"On Terminal #2: use ``kill -HUP`` to send a SIGHUP signal to the "
"Tarantool instance. The result of this is: Tarantool will open `Log_file`"
" again, and the next log message will go to `Log_file`. (The same effect "
"could be accomplished by executing log.rotate() on the instance.)"
msgstr ""
"На терминале №2 используйте команду ``kill -HUP`` для отправки сигнала "
"SIGHUP на экземпляр Tarantool'а. Результат: Tarantool снова откроет "
"`Log_file`, и следующее сообщение журнала пойдет в `Log_file`. (Тот же "
"результат можно получить путем выполнения команды log.rotate() на "
"экземпляре.)"

#: ../doc/1.10/reference/configuration/cfg_logging.rst:1485
msgid "kill -HUP *process_id*"
msgstr "kill -HUP *process_id*"

#: ../doc/1.10/reference/configuration/cfg_logging.rst:235
msgid "On Terminal #1: put a message \"Log Line #3\" in the log file."
msgstr "На терминале №1 поместите сообщение \"Log Line #3\" в файл журнала."

#: ../doc/1.10/reference/configuration/cfg_logging.rst:237
msgid "log.info('Log Line #3')"
msgstr "log.info('Log Line #3')"

#: ../doc/1.10/reference/configuration/cfg_logging.rst:241
msgid ""
"On Terminal #2: use ``less`` to examine files. `Log_file.bak` will have "
"these lines, except that the date and time will depend on when the "
"example is done:"
msgstr ""
"На терминале №2 используйте команду ``less`` для просмотра файлов. "
"`Log_file.bak` будет содержать следующие строки, но дата и время будут "
"указаны в зависимости от времени выполнения примера:"

#: ../doc/1.10/reference/configuration/cfg_logging.rst:1499
msgid ""
"2015-11-30 15:13:06.373 [27469] main/101/interactive I> Log Line #1`\n"
"2015-11-30 15:14:25.973 [27469] main/101/interactive I> Log Line #2`"
msgstr ""
"2015-11-30 15:13:06.373 [27469] main/101/interactive I> Log Line #1`\n"
"2015-11-30 15:14:25.973 [27469] main/101/interactive I> Log Line #2`"

#: ../doc/1.10/reference/configuration/cfg_logging.rst:250
msgid "and `Log_file` will have"
msgstr "а `Log_file` будет содержать"

#: ../doc/1.10/reference/configuration/cfg_logging.rst:1507
msgid ""
"log file has been reopened\n"
"2015-11-30 15:15:32.629 [27469] main/101/interactive I> Log Line #3"
msgstr ""
"log file has been reopened\n"
"2015-11-30 15:15:32.629 [27469] main/101/interactive I> Log Line #3"

#: ../doc/1.10/reference/configuration/cfg_logging.rst:260
msgid "Feedback"
msgstr "Обратная связь"

#: ../doc/1.10/reference/configuration/cfg_logging.rst:262
msgid ":ref:`feedback_enabled <cfg_logging-feedback_enabled>`"
msgstr ":ref:`feedback_enabled <cfg_logging-feedback_enabled>`"

#: ../doc/1.10/reference/configuration/cfg_logging.rst:263
msgid ":ref:`feedback_host <cfg_logging-feedback_host>`"
msgstr ":ref:`feedback_host <cfg_logging-feedback_host>`"

#: ../doc/1.10/reference/configuration/cfg_logging.rst:264
msgid ":ref:`feedback_interval <cfg_logging-feedback_interval>`"
msgstr ":ref:`feedback_interval <cfg_logging-feedback_interval>`"

#: ../doc/1.10/reference/configuration/cfg_logging.rst:266
msgid ""
"By default a Tarantool daemon sends a small packet once per hour, to "
"https://feedback.tarantool.io. The packet contains three values from "
":ref:`box.info <box_introspection-box_info>`: ``box.info.version``, "
"``box.info.uuid``, and ``box.info.cluster_uuid``. By changing the "
"feedback configuration parameters, users can adjust or turn off this "
"feature."
msgstr ""
"По умолчанию, демон Tarantool'а отправляет небольшой пакет каждый час на "
"https://feedback.tarantool.io. Пакет содержит три значения из "
":ref:`box.info <box_introspection-box_info>`: ``box.info.version``, "
"``box.info.uuid`` и ``box.info.cluster_uuid``. Изменив конфигурационные "
"параметры обратной связи, пользователи могут настроить или отключить эту "
"функцию."

#: ../doc/1.10/reference/configuration/cfg_logging.rst:277
msgid "Whether to send feedback."
msgstr "Отправлять обратную связь или нет."

#: ../doc/1.10/reference/configuration/cfg_logging.rst:279
msgid ""
"If this is set to ``true``, feedback will be sent as described above. If "
"this is set to ``false``, no feedback will be sent."
msgstr ""
"Если задано значение ``true``, обратная связь будет отправлена, как "
"описано выше. Если задано значение ``false``, обратная связь не "
"отправляется."

#: ../doc/1.10/reference/configuration/cfg_logging.rst:290
msgid ""
"The address to which the packet is sent. Usually the recipient is "
"Tarantool, but it can be any URL."
msgstr ""
"Адрес, на который отправляется пакет. Как правило, получателем будет "
"Tarantool, но можно указать любой URL."

#: ../doc/1.10/reference/configuration/cfg_logging.rst:294
msgid "Default: 'https://feedback.tarantool.io'"
msgstr "По умолчанию: 'https://feedback.tarantool.io'"

#: ../doc/1.10/reference/configuration/cfg_logging.rst:301
msgid "The number of seconds between sendings, usually 3600 (1 hour)."
msgstr "Количество секунд между отправками, обычно 3600 (1 час)."

#: ../doc/1.10/reference/configuration/cfg_logging.rst:304
msgid "Default: 3600"
msgstr "По умолчанию: 3600"

#: ../doc/1.10/reference/configuration/index.rst:276
msgid "Deprecated parameters"
msgstr "Устаревшие параметры"

#: ../doc/1.10/reference/configuration/cfg_deprecated.rst:3
msgid "These parameters are deprecated since Tarantool version 1.7.4:"
msgstr "Данные параметры объявлены устаревшими с версии Tarantool'а 1.7.4:"

#: ../doc/1.10/reference/configuration/cfg_deprecated.rst:5
msgid ":ref:`coredump <cfg_basic-coredump_deprecated>`"
msgstr ":ref:`coredump <cfg_basic-coredump_deprecated>`"

#: ../doc/1.10/reference/configuration/cfg_deprecated.rst:6
msgid ":ref:`logger <cfg_logging-logger_deprecated>`"
msgstr ":ref:`logger <cfg_logging-logger_deprecated>`"

#: ../doc/1.10/reference/configuration/cfg_deprecated.rst:7
msgid ":ref:`logger_nonblock <cfg_logging-logger_nonblock_deprecated>`"
msgstr ":ref:`logger_nonblock <cfg_logging-logger_nonblock_deprecated>`"

#: ../doc/1.10/reference/configuration/cfg_deprecated.rst:8
msgid ""
":ref:`panic_on_snap_error <cfg_binary_logging_snapshots-"
"panic_on_snap_error_deprecated>`,"
msgstr ""
":ref:`panic_on_snap_error <cfg_binary_logging_snapshots-"
"panic_on_snap_error_deprecated>`,"

#: ../doc/1.10/reference/configuration/cfg_deprecated.rst:9
msgid ""
":ref:`panic_on_wal_error <cfg_binary_logging_snapshots-"
"panic_on_wal_error_deprecated>`"
msgstr ""
":ref:`panic_on_wal_error <cfg_binary_logging_snapshots-"
"panic_on_wal_error_deprecated>`"

#: ../doc/1.10/reference/configuration/cfg_deprecated.rst:10
msgid ":ref:`replication_source <cfg_replication-replication_source_deprecated>`"
msgstr ":ref:`replication_source <cfg_replication-replication_source_deprecated>`"

#: ../doc/1.10/reference/configuration/cfg_deprecated.rst:11
msgid ":ref:`slab_alloc_arena <cfg_storage-slab_alloc_arena_deprecated>`"
msgstr ":ref:`slab_alloc_arena <cfg_storage-slab_alloc_arena_deprecated>`"

#: ../doc/1.10/reference/configuration/cfg_deprecated.rst:12
msgid ":ref:`slab_alloc_factor <cfg_storage-slab_alloc_factor_deprecated>`"
msgstr ":ref:`slab_alloc_factor <cfg_storage-slab_alloc_factor_deprecated>`"

#: ../doc/1.10/reference/configuration/cfg_deprecated.rst:13
msgid ":ref:`slab_alloc_maximal <cfg_storage-slab_alloc_maximal_deprecated>`"
msgstr ":ref:`slab_alloc_maximal <cfg_storage-slab_alloc_maximal_deprecated>`"

#: ../doc/1.10/reference/configuration/cfg_deprecated.rst:14
msgid ":ref:`slab_alloc_minimal <cfg_storage-slab_alloc_minimal_deprecated>`"
msgstr ":ref:`slab_alloc_minimal <cfg_storage-slab_alloc_minimal_deprecated>`"

#: ../doc/1.10/reference/configuration/cfg_deprecated.rst:15
msgid ":ref:`snap_dir <cfg_basic-snap_dir_deprecated>`"
msgstr ":ref:`snap_dir <cfg_basic-snap_dir_deprecated>`"

#: ../doc/1.10/reference/configuration/cfg_deprecated.rst:16
msgid ":ref:`snapshot_count <cfg_checkpoint_daemon-snapshot_count_deprecated>`"
msgstr ":ref:`snapshot_count <cfg_checkpoint_daemon-snapshot_count_deprecated>`"

#: ../doc/1.10/reference/configuration/cfg_deprecated.rst:17
msgid ":ref:`snapshot_period <cfg_checkpoint_daemon-snapshot_period_deprecated>`"
msgstr ":ref:`snapshot_period <cfg_checkpoint_daemon-snapshot_period_deprecated>`"

#: ../doc/1.10/reference/configuration/cfg_deprecated.rst:23
#: ../doc/1.10/reference/configuration/cfg_deprecated.rst:101
msgid "**Deprecated**, do not use."
msgstr "**Устаревший**, не использовать."

#: ../doc/1.10/reference/configuration/cfg_deprecated.rst:33
msgid ""
"**Deprecated** in favor of :ref:`log <cfg_logging-log>`. The parameter "
"was only renamed, while the type, values and semantics remained intact."
msgstr ""
"**Устаревший**, заменен параметром :ref:`log <cfg_logging-log>`. Параметр"
" был лишь переименован, его тип, значения и семантика остались прежними."

#: ../doc/1.10/reference/configuration/cfg_deprecated.rst:41
msgid ""
"**Deprecated** in favor of :ref:`log_nonblock <cfg_logging-"
"log_nonblock>`. The parameter was only renamed, while the type, values "
"and semantics remained intact."
msgstr ""
"**Устаревший**, заменен параметром :ref:`log_nonblock <cfg_logging-"
"log_nonblock>`. Параметр был лишь переименован, его тип, значения и "
"семантика остались прежними."

#: ../doc/1.10/reference/configuration/cfg_deprecated.rst:49
#: ../doc/1.10/reference/configuration/cfg_deprecated.rst:63
msgid ""
"**Deprecated** in favor of :ref:`force_recovery "
"<cfg_binary_logging_snapshots-force_recovery>`."
msgstr ""
"**Устаревший**, заменен параметром :ref:`force_recovery "
"<cfg_binary_logging_snapshots-force_recovery>`."

#: ../doc/1.10/reference/configuration/cfg_deprecated.rst:52
msgid ""
"If there is an error while reading a snapshot file (at server instance "
"start), abort."
msgstr ""
"Если при чтении файла снимка произошла ошибка (при запуске экземпляра "
"сервера), прервать выполнение."

#: ../doc/1.10/reference/configuration/cfg_deprecated.rst:74
msgid ""
"**Deprecated** in favor of :ref:`replication <cfg_replication-"
"replication>`. The parameter was only renamed, while the type, values and"
" semantics remained intact."
msgstr ""
"**Устаревший**, заменен параметром :ref:`replication <cfg_replication-"
"replication>`. Параметр был лишь переименован, его тип, значения и "
"семантика остались прежними."

#: ../doc/1.10/reference/configuration/cfg_deprecated.rst:83
msgid "**Deprecated** in favor of :ref:`memtx_memory <cfg_storage-memtx_memory>`."
msgstr ""
"**Устаревший**, заменен параметром :ref:`memtx_memory <cfg_storage-"
"memtx_memory>`."

#: ../doc/1.10/reference/configuration/cfg_deprecated.rst:86
msgid ""
"How much memory Tarantool allocates to actually store tuples, **in "
"gigabytes**. When the limit is reached, INSERT or UPDATE requests begin "
"failing with error :errcode:`ER_MEMORY_ISSUE`. While the server does not "
"go beyond the defined limit to allocate tuples, there is additional "
"memory used to store indexes and connection information. Depending on "
"actual configuration and workload, Tarantool can consume up to 20% more "
"than the limit set here."
msgstr ""
"Количество памяти, которое Tarantool выделяет для фактического хранения "
"кортежей, **в гигабайтах**. При достижении предельного значения запросы "
"вставки INSERT или обновления UPDATE выполняться не будут, выдавая ошибку"
" :errcode:`ER_MEMORY_ISSUE`. Сервер не выходит за установленный предел "
"памяти ``memtx_memory`` при распределении кортежей, но есть "
"дополнительная память, которая используется для хранения индексов и "
"информации о подключении. В зависимости от рабочей конфигурации и "
"загрузки, Tarantool может потреблять на 20% больше установленного "
"предела."

#: ../doc/1.10/reference/configuration/cfg_deprecated.rst:94
msgid "Default: 1.0"
msgstr "По умолчанию: 1.0"

#: ../doc/1.10/reference/configuration/cfg_deprecated.rst:103
msgid ""
"The multiplier for computing the sizes of memory chunks that tuples are "
"stored in. A lower value may result in less wasted memory depending on "
"the total amount of memory available and the distribution of item sizes."
msgstr ""
"Множитель для вычисления размеров блоков памяти, в которых хранятся "
"кортежи. Уменьшение значения может привести к уменьшению потерь памяти в "
"зависимости от общего объема доступной памяти и распределения размеров "
"элементов."

#: ../doc/1.10/reference/configuration/cfg_deprecated.rst:109
msgid "Default: 1.1"
msgstr "По умолчанию: 1.1"

#: ../doc/1.10/reference/configuration/cfg_deprecated.rst:116
msgid ""
"**Deprecated** in favor of :ref:`memtx_max_tuple_size <cfg_storage-"
"memtx_max_tuple_size>`. The parameter was only renamed, while the type, "
"values and semantics remained intact."
msgstr ""
"**Устаревший**, заменен параметром :ref:`memtx_max_tuple_size "
"<cfg_storage-memtx_max_tuple_size>`. Параметр был лишь переименован, его "
"тип, значения и семантика остались прежними."

#: ../doc/1.10/reference/configuration/cfg_deprecated.rst:125
msgid ""
"**Deprecated** in favor of :ref:`memtx_min_tuple_size <cfg_storage-"
"memtx_min_tuple_size>`. The parameter was only renamed, while the type, "
"values and semantics remained intact."
msgstr ""
"**Устаревший**, заменен параметром :ref:`memtx_min_tuple_size "
"<cfg_storage-memtx_min_tuple_size>`. Параметр был лишь переименован, его "
"тип, значения и семантика остались прежними."

#: ../doc/1.10/reference/configuration/cfg_deprecated.rst:134
msgid ""
"**Deprecated** in favor of :ref:`memtx_dir <cfg_basic-memtx_dir>`. The "
"parameter was only renamed, while the type, values and semantics remained"
" intact."
msgstr ""
"**Устаревший**, заменен параметром :ref:`memtx_dir <cfg_basic-"
"memtx_dir>`. Параметр был лишь переименован, его тип, значения и "
"семантика остались прежними."

#: ../doc/1.10/reference/configuration/cfg_deprecated.rst:142
msgid ""
"**Deprecated** in favor of :ref:`checkpoint_interval "
"<cfg_checkpoint_daemon-checkpoint_interval>`. The parameter was only "
"renamed, while the type, values and semantics remained intact."
msgstr ""
"**Устаревший**, заменен параметром :ref:`checkpoint_interval "
"<cfg_checkpoint_daemon-checkpoint_interval>`. Параметр был лишь "
"переименован, его тип, значения и семантика остались прежними."

#: ../doc/1.10/reference/configuration/cfg_deprecated.rst:151
msgid ""
"**Deprecated** in favor of :ref:`checkpoint_count <cfg_checkpoint_daemon-"
"checkpoint_count>`. The parameter was only renamed, while the type, "
"values and semantics remained intact."
msgstr ""
"**Устаревший**, заменен параметром :ref:`checkpoint_count "
"<cfg_checkpoint_daemon-checkpoint_count>`. Параметр был лишь "
"переименован, его тип, значения и семантика остались прежними."

#: ../doc/1.10/reference/index.rst:39
msgid "Reference"
msgstr "Справочники"

#: ../doc/1.10/reference/lua_tips.rst:39
msgid "Tips on Lua syntax"
msgstr "Рекомендации по Lua-синтаксису"

#: ../doc/1.10/reference/lua_tips.rst:41
msgid ""
"The Lua syntax for :ref:`data-manipulation functions <index-box_data-"
"operations>` can vary. Here are examples of the variations with "
"``select()`` requests. The same rules exist for the other data-"
"manipulation functions."
msgstr ""
"В :ref:`функциях управления данными <index-box_data-operations>` "
"Lua-синтаксис может различаться. Далее приводятся варианты таких различий"
" на примере запросов ``select()``. Аналогичные правила существуют и для "
"остальных функций."

#: ../doc/1.10/reference/lua_tips.rst:45
msgid ""
"Every one of the examples does the same thing: select a tuple set from a "
"space named 'tester' where the primary-key field value equals 1. For "
"these examples, we assume that the numeric id of 'tester' is 512, which "
"happens to be the case in our sandbox example only."
msgstr ""
"В каждом из приведенных примеров выполняются следующие действия: "
"производится выборка по набору кортежей из спейса с именем 'tester', где "
"значение поля, которое соответствует ключу в первичном индексе, равно 1. "
"Также во всех примерах мы принимаем, что числовой идентификатор спейса "
"'tester' равен 512, но это верно только для нашей тестовой базы."

#: ../doc/1.10/reference/lua_tips.rst:54
msgid "Object reference variations"
msgstr "Способы ссылки на объект"

#: ../doc/1.10/reference/lua_tips.rst:56
msgid "First, there are three **object reference variations**:"
msgstr "Во-первых, есть три *способа ссылки на объект*:"

#: ../doc/1.10/reference/lua_tips.rst:58
msgid ""
"-- #1 module . submodule . name\n"
"tarantool> box.space.tester:select{1}\n"
"-- #2 replace name with a literal in square brackets\n"
"tarantool> box.space['tester']:select{1}\n"
"-- #3 use a variable for the entire object reference\n"
"tarantool> s = box.space.tester\n"
"tarantool> s:select{1}"
msgstr ""
"-- #1 модуль.подмодуль.имя\n"
"tarantool> box.space.tester:select{1}\n"
"-- #2 заменить имя буквенной константой в квадратных скобках\n"
"tarantool> box.space['tester']:select{1}\n"
"-- #3 использовать переменную для всей ссылки на объект\n"
"tarantool> s = box.space.tester\n"
"tarantool> s:select{1}"

#: ../doc/1.10/reference/lua_tips.rst:68
msgid ""
"Examples in this manual usually have the \":samp:`box.space.{tester}:`\" "
"form (#1). However, this is a matter of user preference and all the "
"variations exist in the wild."
msgstr ""
"Для примеров в документации, как правило, используется вариант синтаксиса"
" №1, например \":samp:`box.space.{tester}:`\". Но вы можете с тем же "
"успехом пользоваться любым из трех описанных выше вариантов."

#: ../doc/1.10/reference/lua_tips.rst:72
msgid ""
"Also, descriptions in this manual use the syntax \"``space_object:``\" "
"for references to objects which are spaces, and \"``index_object:``\" for"
" references to objects which are indexes (for example "
":samp:`box.space.{tester}.index.{primary}:`)."
msgstr ""
"Также описания в руководстве используют синтаксис типа  "
"\"``space_object:``\" для ссылки на спейсы и \"``index_object:``\" для "
"ссылки на индексы (например, "
":samp:`box.space.{tester}.index.{primary}:`)."

#: ../doc/1.10/reference/lua_tips.rst:81
msgid "Parameter variations"
msgstr "Способы задания параметров"

#: ../doc/1.10/reference/lua_tips.rst:83
msgid "Then, there are seven **parameter variations**:"
msgstr "Затем есть семь *способов задания параметров*:"

#: ../doc/1.10/reference/lua_tips.rst:85
msgid ""
"-- #1\n"
"tarantool> box.space.tester:select{1}\n"
"-- #2\n"
"tarantool> box.space.tester:select({1})\n"
"-- #3\n"
"tarantool> box.space.tester:select(1)\n"
"-- #4\n"
"tarantool> box.space.tester.select(box.space.tester,1)\n"
"-- #5\n"
"tarantool> box.space.tester:select({1},{iterator='EQ'})\n"
"-- #6\n"
"tarantool> variable = 1\n"
"tarantool> box.space.tester:select{variable}\n"
"-- #7\n"
"tarantool> variable = {1}\n"
"tarantool> box.space.tester:select(variable)"
msgstr ""
"-- #1\n"
"tarantool> box.space.tester:select{1}\n"
"-- #2\n"
"tarantool> box.space.tester:select({1})\n"
"-- #3\n"
"tarantool> box.space.tester:select(1)\n"
"-- #4\n"
"tarantool> box.space.tester.select(box.space.tester,1)\n"
"-- #5\n"
"tarantool> box.space.tester:select({1},{iterator='EQ'})\n"
"-- #6\n"
"tarantool> variable = 1\n"
"tarantool> box.space.tester:select{variable}\n"
"-- #7\n"
"tarantool> variable = {1}\n"
"tarantool> box.space.tester:select(variable)"

#: ../doc/1.10/reference/lua_tips.rst:104
msgid ""
"Lua allows to omit parentheses ``()`` when invoking a function if its "
"only argument is a Lua table, and we use it sometimes in our examples. "
"This is why ``select{1}`` is equivalent to ``select({1})``. Literal "
"values such as ``1`` (a scalar value) or ``{1}`` (a Lua table value) may "
"be replaced by variable names, as in examples #6 and #7."
msgstr ""
"В Lua допускается пропуск круглых скобок ``()`` при вызове функции, если "
"единственным аргументом является Lua-таблица, и иногда мы этим пользуемся"
" в примерах. Вот почему ``select{1}`` аналогично ``select({1})``. "
"Литеральные значения, такие как ``1`` (скалярное значение) или ``{1}`` "
"(значение Lua-таблицы), можно заменить именами переменных, ка в примерах "
"6 и 7."

#: ../doc/1.10/reference/lua_tips.rst:110
msgid ""
"Although there are special cases where braces can be omitted, they are "
"preferable because they signal \"Lua table\". Examples and descriptions "
"in this manual have the ``{1}`` form. However, this too is a matter of "
"user preference and all the variations exist in the wild."
msgstr ""
"Хотя есть особые случаи, когда фигурные скобки можно опустить, "
"рекомендуется использовать их, потому что они означают Lua-таблицу. В "
"примерах и описаниях данного руководства применяется форма ``{1}``. "
"Однако это тоже вопрос предпочтений пользователя, и на практике применимы"
" все варианты."

#: ../doc/1.10/reference/lua_tips.rst:119
msgid "Rules for object names"
msgstr "Правила именования объектов"

#: ../doc/1.10/reference/lua_tips.rst:121
msgid ""
"Database objects have loose **rules for names**: the maximum length is "
"65000 bytes (not characters), and almost any legal Unicode character is "
"allowed, including spaces, ideograms and punctuation."
msgstr ""
"**Правила именования** объектов базы данных не слишком ограничены: "
"максимальная длина составляет 65000 байтов (не символов), допускается "
"практически любой символ Юникода, включая пробелы, идеограммы и знаки "
"пунктуации."

#: ../doc/1.10/reference/lua_tips.rst:126
msgid ""
"In those cases, to prevent confusion with Lua operators and separators, "
"object references should have the literal-in-square-brackets form (#2), "
"or the variable form (#3). For example:"
msgstr ""
"В таких случаях во избежание путаницы с операторами и разделителями в Lua"
" ссылки на объекты должны иметь форму типа литерал в квадратных скобках "
"(2) или форму переменной (3). Например:"

#: ../doc/1.10/reference/lua_tips.rst:130
msgid ""
"tarantool> box.space['1*A']:select{1}\n"
"tarantool> s = box.space['1*A !@$%^&*()_+12345678901234567890']\n"
"tarantool> s:select{1}"
msgstr ""
"tarantool> box.space['1*A']:select{1}\n"
"tarantool> s = box.space['1*A !@$%^&*()_+12345678901234567890']\n"
"tarantool> s:select{1}"

#: ../doc/1.10/reference/lua_tips.rst:136
msgid "Disallowed:"
msgstr "Не разрешаются:"

#: ../doc/1.10/reference/lua_tips.rst:138
msgid "characters which are unassigned code points,"
msgstr "символы, которые представляют собой неназначенные кодовые точки,"

#: ../doc/1.10/reference/lua_tips.rst:139
msgid "line and paragraph separators,"
msgstr "разделители строки и абзаца,"

#: ../doc/1.10/reference/lua_tips.rst:140
msgid "control characters,"
msgstr "управляющие символы,"

#: ../doc/1.10/reference/lua_tips.rst:141
msgid "the replacement character (U+FFFD)."
msgstr "символ замены (U+FFFD)."

#: ../doc/1.10/reference/lua_tips.rst:143
msgid "Not recommended: characters which cannot be displayed."
msgstr "Не рекомендуются: символы, которые не отображаются."

#: ../doc/1.10/reference/lua_tips.rst:145
msgid "Names are \"case sensitive\", so 'A' and 'a' are not the same."
msgstr "Имена зависимы от регистра, поэтому 'A' и 'a' -- это не одно и то же."

#: ../doc/1.10/reference/reference_lua/box.rst:41
msgid ""
"As well as executing Lua chunks or defining your own functions, you can "
"exploit Tarantool's storage functionality with the ``box`` module and its"
" submodules."
msgstr ""
"Помимо выполнения фрагментов кода на Lua или определения собственных "
"функций, с помощью модуля ``box`` и вложенных модулей можно использовать "
"функции хранилища Tarantool'а."

#: ../doc/1.10/reference/reference_lua/box.rst:44
msgid ""
"Every submodule contains one or more Lua functions. A few submodules "
"contain members as well as functions. The functions allow data definition"
" (create alter drop), data manipulation (insert delete update upsert "
"select replace), and introspection (inspecting contents of spaces, "
"accessing server configuration)."
msgstr ""
"Каждый вложенный модуль включает в себя одну или более Lua-функций. "
"Несколько вложенных модулей включают в себя элементы класса, а также "
"функции. Функции обеспечивают определение данных (create alter drop), "
"управление данными (insert delete update upsert select replace) и "
"просмотр состояния (просмотр содержимого спейсов, получение доступа к "
"конфигурации сервера)."

#: ../doc/1.10/reference/reference_lua/box.rst:49
msgid ""
"To catch errors that functions in ``box`` submodules may throw, use "
":ref:`pcall <error_handling>`."
msgstr ""
"Чтобы найти ошибки, которые могут выдать вложенные модули ``box``, "
"используйте :ref:`pcall <error_handling>`."

#: ../doc/1.10/reference/reference_lua/box.rst:51
msgid ""
"The contents of the ``box`` module can be inspected at runtime with "
"``box``, with no arguments. The ``box`` module contains:"
msgstr ""
"Содержимое модуля ``box`` можно просмотреть во время исполнения кода с "
"помощью команды ``box`` без аргументов. Модуль ``box`` включает в себя "
"следующее:"

#: ../doc/1.10/reference/reference_lua/box_error.rst:37
msgid "Submodule `box.error`"
msgstr "Вложенный модуль `box.error`"

#: ../doc/1.10/reference/reference_lua/box_error.rst:45
msgid ""
"The ``box.error`` function is for raising an error. The difference "
"between this function and Lua's built-in `error "
"<https://www.lua.org/pil/8.3.html>`_ function is that when the error "
"reaches the client, its error code is preserved. In contrast, a Lua error"
" would always be presented to the client as :errcode:`ER_PROC_LUA`."
msgstr ""
"Функция ``box.error`` предназначена для вызова ошибки. Разница между этой"
" функцией и встроенной Lua-функцией `error "
"<https://www.lua.org/pil/8.3.html>`_ в том, что когда клиент получает "
"ошибку, код ошибки сохраняется. В отличие от этого, ошибки в Lua всегда "
"передаются на клиент в виде :errcode:`ER_PROC_LUA`."

#: ../doc/1.10/reference/reference_lua/box_error.rst:55
msgid "Below is a list of all ``box.error`` functions."
msgstr "Ниже приведен перечень всех функций модуля ``box.error``."

#: ../doc/1.10/reference/reference_lua/box_error.rst:65
msgid ":ref:`box.error() <box_error-error>`"
msgstr ":ref:`box.error() <box_error-error>`"

#: ../doc/1.10/reference/reference_lua/box_error.rst:65
msgid "Throw an error"
msgstr "Вызов ошибки"

#: ../doc/1.10/reference/reference_lua/box_error.rst:68
msgid ":ref:`box.error.last() <box_error-last>`"
msgstr ":ref:`box.error.last() <box_error-last>`"

#: ../doc/1.10/reference/reference_lua/box_error.rst:68
msgid "Get a description of the last error"
msgstr "Получение описания последней ошибки"

#: ../doc/1.10/reference/reference_lua/box_error.rst:71
msgid ":ref:`box.error.clear() <box_error-clear>`"
msgstr ":ref:`box.error.clear() <box_error-clear>`"

#: ../doc/1.10/reference/reference_lua/box_error.rst:71
msgid "Clear the record of errors"
msgstr "Очистка записи об ошибках"

#: ../doc/1.10/reference/reference_lua/box_error.rst:74
msgid ":ref:`box.error.new() <box_error-new>`"
msgstr ":ref:`box.error.new() <box_error-new>`"

#: ../doc/1.10/reference/reference_lua/box_error.rst:74
msgid "Create an error but do not throw"
msgstr "Создание ошибки без выдачи"

#: ../doc/1.10/reference/reference_lua/box_error.rst:80
msgid ""
"When called with a Lua-table argument, the code and reason have any user-"
"desired values. The result will be those values."
msgstr ""
"При вызове с аргументом из Lua-таблицы значения параметров code и reason "
"будут любыми по желанию пользователя. Результатом будут эти значения."

#: ../doc/1.10/reference/reference_lua/box_error.rst:88
msgid ""
"When called without arguments, ``box.error()`` re-throws whatever the "
"last error was."
msgstr ""
"При вызове без аргументов ``box.error()`` повторно вызывает последнюю "
"ошибку."

#: ../doc/1.10/reference/reference_lua/box_error.rst:95
msgid ""
"Emulate a request error, with text based on one of the pre-defined "
"Tarantool errors defined in the file `errcode.h "
"<https://github.com/tarantool/tarantool/blob/1.10/src/box/errcode.h>`_ in"
" the source tree. Lua constants which correspond to those Tarantool "
"errors are defined as members of ``box.error``, for example "
"``box.error.NO_SUCH_USER == 45``."
msgstr ""
"Моделирование ошибки запроса с текстом на основе одной из ошибок "
"Tarantool'а, заданных в файле `errcode.h "
"<https://github.com/tarantool/tarantool/blob/1.10/src/box/errcode.h>`_ в "
"исходном дереве. Lua-постоянные, которые соответствуют этим ошибкам в "
"Tarantool'е, определяются как элементы ``box.error``, например "
"``box.error.NO_SUCH_USER == 45``."

#: ../doc/1.10/reference/reference_lua/box_error.rst:101
#: ../doc/1.10/reference/reference_lua/box_error.rst:191
msgid "number of a pre-defined error"
msgstr "номер предварительно заданной ошибки"

#: ../doc/1.10/reference/reference_lua/box_error.rst:102
#: ../doc/1.10/reference/reference_lua/box_error.rst:192
msgid "part of the message which will accompany the error"
msgstr "часть сообщения, которое сопровождает ошибку"

#: ../doc/1.10/reference/reference_lua/box_error.rst:106
#, python-format
msgid ""
"the ``NO_SUCH_USER`` message is \"``User '%s' is not found``\" -- it "
"includes one \"``%s``\" component which will be replaced with errtext. "
"Thus a call to ``box.error(box.error.NO_SUCH_USER, 'joe')`` or "
"``box.error(45, 'joe')`` will result in an error with the accompanying "
"message \"``User 'joe' is not found``\"."
msgstr ""
"сообщение ``NO_SUCH_USER`` = \"``User '%s' is not found``\" (пользователь"
" не найден) -- оно включает в себя компонент \"``%s``\", который будет "
"заменен значением параметра errtext. Таким образом, вызов "
"``box.error(box.error.NO_SUCH_USER, 'joe')`` или ``box.error(45, 'joe')``"
" приведет к ошибке с сообщением \"``User 'joe' is not found``\" "
"(пользователь 'joe' не найден)."

#: ../doc/1.10/reference/reference_lua/box_error.rst
msgid "except"
msgstr "Исключение:"

#: ../doc/1.10/reference/reference_lua/box_error.rst:112
msgid "whatever is specified in errcode-number."
msgstr "то, что указано в номере errcode."

#: ../doc/1.10/reference/reference_lua/box_error.rst:116
msgid ""
"tarantool> box.error{code = 555, reason = 'Arbitrary message'}\n"
"---\n"
"- error: Arbitrary message\n"
"...\n"
"tarantool> box.error()\n"
"---\n"
"- error: Arbitrary message\n"
"...\n"
"tarantool> box.error(box.error.FUNCTION_ACCESS_DENIED, 'A', 'B', 'C')\n"
"---\n"
"- error: A access denied for user 'B' to function 'C'\n"
"..."
msgstr ""
"tarantool> box.error{code = 555, reason = 'Arbitrary message'}\n"
"---\n"
"- error: Arbitrary message\n"
"...\n"
"tarantool> box.error()\n"
"---\n"
"- error: Arbitrary message\n"
"...\n"
"tarantool> box.error(box.error.FUNCTION_ACCESS_DENIED, 'A', 'B', 'C')\n"
"---\n"
"- error: A access denied for user 'B' to function 'C'\n"
"..."

#: ../doc/1.10/reference/reference_lua/box_error.rst:135
msgid ""
"Returns a description of the last error, as a Lua table with five "
"members: \"line\" (number) Tarantool source file line number, \"code\" "
"(number) error's number, \"type\", (string) error's C++ class, "
"\"message\" (string) error's message, \"file\" (string) Tarantool source "
"file. Additionally, if the error is a system error (for example due to a "
"failure in socket or file io), there may be a sixth member: \"errno\" "
"(number) C standard error number."
msgstr ""
"Возвращает описание последней ошибки в виде Lua-таблицы с 5 элементами: "
"\"line\" (число) -- номер строки в исходном файле Tarantool'а, \"code\" "
"(число) -- номер ошибки, \"type\" (строка) -- C++ класс ошибки, "
"\"message\" (строка) -- сообщение об ошибке, \"file\" (строка) -- "
"исходный файл Tarantool'а. Кроме того, если ошибка является системной "
"(например, по причине ошибки в сокете или файловом вводы-выводе), может "
"быть дополнительный шестой элемент: \"errno\" (число) стандартный номер "
"ошибки на языке C."

#: ../doc/1.10/reference/reference_lua/box_error.rst:145
msgid "rtype: table"
msgstr "Тип возвращаемого значения: таблица"

#: ../doc/1.10/reference/reference_lua/box_error.rst:151
msgid ""
"Clears the record of errors, so functions like `box.error()` or "
"`box.error.last()` will have no effect."
msgstr ""
"Очистка записи об ошибках, то есть функции `box.error()` или "
"`box.error.last()` не сработают."

#: ../doc/1.10/reference/reference_lua/box_error.rst:156
msgid ""
"tarantool> box.error{code = 555, reason = 'Arbitrary message'}\n"
"---\n"
"- error: Arbitrary message\n"
"...\n"
"tarantool> box.schema.space.create('#')\n"
"---\n"
"- error: Invalid identifier '#' (expected letters, digits or an "
"underscore)\n"
"...\n"
"tarantool> box.error.last()\n"
"---\n"
"- line: 278\n"
"  code: 70\n"
"  type: ClientError\n"
"  message: Invalid identifier '#' (expected letters, digits or an "
"underscore)\n"
"  file: "
"/tmp/buildd/tarantool-1.7.0.252.g1654e31~precise/src/box/key_def.cc\n"
"...\n"
"tarantool> box.error.clear()\n"
"---\n"
"...\n"
"tarantool> box.error.last()\n"
"---\n"
"- null\n"
"..."
msgstr ""
"tarantool> box.error{code = 555, reason = 'Arbitrary message'}\n"
"---\n"
"- error: Arbitrary message\n"
"...\n"
"tarantool> box.schema.space.create('#')\n"
"---\n"
"- error: Invalid identifier '#' (expected letters, digits or an "
"underscore)\n"
"...\n"
"tarantool> box.error.last()\n"
"---\n"
"- line: 278\n"
"  code: 70\n"
"  type: ClientError\n"
"  message: Invalid identifier '#' (expected letters, digits or an "
"underscore)\n"
"  file: "
"/tmp/buildd/tarantool-1.7.0.252.g1654e31~precise/src/box/key_def.cc\n"
"...\n"
"tarantool> box.error.clear()\n"
"---\n"
"...\n"
"tarantool> box.error.last()\n"
"---\n"
"- null\n"
"..."

#: ../doc/1.10/reference/reference_lua/box_error.rst:186
msgid ""
"Create an error object, but do not throw. This is useful when error "
"information should be saved for later retrieval. The parameters are the "
"same as for :ref:`box.error() <box_error-error>`, see the description "
"there."
msgstr ""
"Создание ошибки без выдачи. Используется, когда необходимо сохранить "
"информацию об ошибке для последующей выборки. Используются такие же "
"параметры, как в :ref:`box.error() <box_error-error>`, см. описание по "
"ссылке."

#: ../doc/1.10/reference/reference_lua/box_error.rst:196
msgid ""
"tarantool> e = box.error.new{code = 555, reason = 'Arbitrary message'}\n"
"---\n"
"...\n"
"tarantool> e:unpack()\n"
"---\n"
"- type: ClientError\n"
"  code: 555\n"
"  message: Arbitrary message\n"
"  trace:\n"
"  - file: '[string \"e = box.error.new{code = 555, reason = "
"''Arbit...\"]'\n"
"    line: 1\n"
"..."
msgstr ""
"tarantool> e = box.error.new{code = 555, reason = 'Arbitrary message'}\n"
"---\n"
"...\n"
"tarantool> e:unpack()\n"
"---\n"
"- type: ClientError\n"
"  code: 555\n"
"  message: Arbitrary message\n"
"  trace:\n"
"  - file: '[string \"e = box.error.new{code = 555, reason = "
"''Arbit...\"]'\n"
"    line: 1\n"
"..."

#: ../doc/1.10/reference/reference_lua/box_once.rst:39
msgid "Function `box.once`"
msgstr "Функция `box.once`"

#: ../doc/1.10/reference/reference_lua/box_once.rst:43
msgid ""
"Execute a function, provided it has not been executed before. A passed "
"value is checked to see whether the function has already been executed. "
"If it has been executed before, nothing happens. If it has not been "
"executed before, the function is invoked."
msgstr ""
"Выполнение функции при условии, что она раньше не выполнялась. "
"Передаваемое значение проверяется на предмет того, выполнялась ли "
"функция. Если она выполнялась, ничего не происходит. В противном случае "
"вызывается функция."

#: ../doc/1.10/reference/reference_lua/box_once.rst:48
msgid ""
"See an example of using ``box.once()`` while :ref:`bootstrapping a "
"replica set <replication-bootstrap>`."
msgstr ""
"См. пример использования ``box.once()`` во время :ref:`настройки набора "
"реплик <replication-bootstrap>`."

#: ../doc/1.10/reference/reference_lua/box_once.rst:51
msgid ""
"If an error occurs inside ``box.once()`` when initializing a database, "
"you can re-execute the failed ``box.once()`` block without stopping the "
"database. The solution is to delete the ``once`` object from the system "
"space :ref:`_schema <box_space-schema>`. Say "
"``box.space._schema:select{}``, find your ``once`` object there and "
"delete it. For example, re-executing a block with ``key='hello'`` :"
msgstr ""
"Если в ``box.once()`` возникает ошибка во время инициализации базы "
"данных, можно повторно запустить невыполненный блок ``box.once()``, не "
"останавливая базу данных. Для этого удалите объект ``once`` из системного"
" спейса :ref:`_schema <box_space-schema>`. Введите команду "
"``box.space._schema:select{}``, найдите объект ``once`` и удалите его. "
"Например, повторное выполнение блока ``key='hello'`` :"

#: ../doc/1.10/reference/reference_lua/box_once.rst:58
msgid ""
"When ``box.once()`` is used for initialization, it may be useful to wait "
"until the database is in an appropriate state (read-only or read-write). "
"In that case, see the functions in the :ref:`box.ctl submodule "
"<box_ctl>`."
msgstr ""
"Когда ``box.once()`` используется для инициализации, следует подождать, "
"пока база данных не будет в нужном состоянии (только для чтения или для "
"чтения и записи). Для этого см. функции во :ref:`вложенном модуле box.ctl"
" <box_ctl>`."

#: ../doc/1.10/reference/reference_lua/box_once.rst:62
msgid ""
"tarantool> box.space._schema:select{}\n"
"---\n"
"- - ['cluster', 'b4e15788-d962-4442-892e-d6c1dd5d13f2']\n"
"  - ['max_id', 512]\n"
"  - ['oncebye']\n"
"  - ['oncehello']\n"
"  - ['version', 1, 7, 2]\n"
"...\n"
"\n"
"tarantool> box.space._schema:delete('oncehello')\n"
"---\n"
"- ['oncehello']\n"
"...\n"
"\n"
"tarantool> box.once('hello', function() end)\n"
"---\n"
"..."
msgstr ""
"tarantool> box.space._schema:select{}\n"
"---\n"
"- - ['cluster', 'b4e15788-d962-4442-892e-d6c1dd5d13f2']\n"
"  - ['max_id', 512]\n"
"  - ['oncebye']\n"
"  - ['oncehello']\n"
"  - ['version', 1, 7, 2]\n"
"...\n"
"\n"
"tarantool> box.space._schema:delete('oncehello')\n"
"---\n"
"- ['oncehello']\n"
"...\n"
"\n"
"tarantool> box.once('hello', function() end)\n"
"---\n"
"..."

#: ../doc/1.10/reference/reference_lua/box_once.rst:82
msgid "a value that will be checked"
msgstr "значение для проверки"

#: ../doc/1.10/reference/reference_lua/box_once.rst:83
msgid "a function"
msgstr "функция"

#: ../doc/1.10/reference/reference_lua/box_once.rst:84
msgid "arguments that must be passed to function"
msgstr "аргументы, которые следует передать в функцию"

#: ../doc/1.10/reference/reference_lua/box_snapshot.rst:39
msgid "Function `box.snapshot`"
msgstr "Функция `box.snapshot`"

#: ../doc/1.10/reference/reference_lua/box_snapshot.rst:43
msgid ""
"Take a snapshot of all data and store it in :ref:`memtx_dir <cfg_basic-"
"memtx_dir>`:samp:`/{<latest-lsn>}.snap`. To take a snapshot, Tarantool "
"first enters the delayed garbage collection mode for all data. In this "
"mode, the :ref:`Tarantool garbage collector <cfg_checkpoint_daemon-"
"garbage-collector>` will not remove files which were created before the "
"snapshot started, it will not remove them until the snapshot has "
"finished. To preserve consistency of the primary key, used to iterate "
"over tuples, a copy-on-write technique is employed. If the master process"
" changes part of a primary key, the corresponding process page is split, "
"and the snapshot process obtains an old copy of the page. In effect, the "
"snapshot process uses multi-version concurrency control in order to avoid"
" copying changes which are superseded while it is running."
msgstr ""
"Создает снимок всех данных и сохраняет его в :ref:`memtx_dir <cfg_basic-"
"memtx_dir>`:samp:`/{<latest-lsn>}.snap`. Чтобы сделать снимок, сначала "
"Tarantool входит в режим сборки мусора по всем данным. В этом режиме "
":ref:`сборщик мусора Tarantool'а <cfg_checkpoint_daemon-garbage-"
"collector>` не будет удалять файлы, созданные до начала создания снимка, "
"до тех пор, пока не будет завершено создание снимка. Чтобы сохранить "
"консистентность первичного ключа, используемого для итерации по кортежам,"
" применяется технология копирования при записи. Если главный процесс "
"изменяет часть первичного ключа, страница соответствующего процесса "
"разделяется, и процесс создания снимка получает старую копию страницы. В "
"результате, процесс создания снимка использует многоверсионную "
"параллельную обработку данных, чтобы не скопировать изменения, замененные"
" одновременно с ходом процесса."

#: ../doc/1.10/reference/reference_lua/box_snapshot.rst:57
msgid ""
"Since a snapshot is written sequentially, one can expect a very high "
"write performance (averaging to 80MB/second on modern disks), which means"
" an average database instance gets saved in a matter of minutes. Users "
"may restrict the speed by changing :ref:`snap_io_rate_limit "
"<cfg_binary_logging_snapshots-snap_io_rate_limit>`."
msgstr ""
"Поскольку снимок создается последовательно, можно ожидать высокую "
"скорость записи (в среднем до 80 МБ/секунду на современных дисках), что "
"означает сохранение данных усредненного экземпляра базы данных за "
"несколько минут. Пользователи могут ограничить скорость записи, изменив "
"значение :ref:`snap_io_rate_limit <cfg_binary_logging_snapshots-"
"snap_io_rate_limit>`."

#: ../doc/1.10/reference/reference_lua/box_snapshot.rst:65
#, python-format
msgid ""
"As long as there are any changes to the parent index memory through "
"concurrent updates, there are going to be page splits, and therefore you "
"need to have some extra free memory to run this command. 10% of "
":ref:`memtx_memory <cfg_storage-memtx_memory>` is, on average, "
"sufficient. This statement waits until a snapshot is taken and returns "
"operation result."
msgstr ""
"При условии, что происходят изменения в родительском индексе в ходе "
"многопоточного обновления данных, будет происходить и расщепление "
"страниц, поэтому возникнет необходимость в наличии дополнительной "
"свободной памяти для выполнения этой команды. В среднем, будет достаточно"
" 10% от :ref:`memtx_memory <cfg_storage-memtx_memory>`. Оператор подождет"
" окончания создания снимка и вернет результат операции."

#: ../doc/1.10/reference/reference_lua/box_snapshot.rst:73
msgid ""
"**Change notice:** Prior to Tarantool version 1.6.6, the snapshot process"
" caused a fork, which could cause occasional latency spikes. Starting "
"with Tarantool version 1.6.6, the snapshot process creates a consistent "
"read view and this view is written to the snapshot file by a separate "
"thread (the \"Write Ahead Log\" thread)."
msgstr ""
"**Обновление:** До версии 1.6.6 Tarantool'а процесс создания снимка "
"вызывал создание ответвления, что могло привести к скачкам задержки "
"отклика. Начиная с версии 1.6.6 Tarantool'а, процесс создания снимка "
"создает вид постоянного просмотра, который и записывается в файл снимка с"
" помощью отдельного потока (поток упреждающей записи в журнал)."

#: ../doc/1.10/reference/reference_lua/box_snapshot.rst:79
msgid ""
"Although ``box.snapshot()`` does not cause a fork, there is a separate "
"fiber which may produce snapshots at regular intervals -- see the "
"discussion of the :ref:`checkpoint daemon <book_cfg_checkpoint_daemon>`."
msgstr ""
"Хотя ``box.snapshot()`` не создает ответвление, есть отдельный файбер, "
"который может создавать снимки на регулярной основе -- см. обсуждение "
":ref:`демона создания контрольных точек <book_cfg_checkpoint_daemon>`."

#: ../doc/1.10/reference/reference_lua/box_snapshot.rst:85
msgid ""
"tarantool> box.info.version\n"
"---\n"
"- 1.7.0-1216-g73f7154\n"
"...\n"
"tarantool> box.snapshot()\n"
"---\n"
"- ok\n"
"...\n"
"tarantool> box.snapshot()\n"
"---\n"
"- error: can't save snapshot, errno 17 (File exists)\n"
"..."
msgstr ""
"tarantool> box.info.version\n"
"---\n"
"- 1.7.0-1216-g73f7154\n"
"...\n"
"tarantool> box.snapshot()\n"
"---\n"
"- ok\n"
"...\n"
"tarantool> box.snapshot()\n"
"---\n"
"- error: can't save snapshot, errno 17 (File exists)\n"
"..."

#: ../doc/1.10/reference/reference_lua/box_snapshot.rst:100
msgid ""
"Taking a snapshot does not cause the server to start a new write-ahead "
"log. Once a snapshot is taken, old WALs can be deleted as long as all "
"replicated data is up to date. But the WAL which was current at the time "
"``box.snapshot()`` started must be kept for recovery, since it still "
"contains log records written after the start of ``box.snapshot()``."
msgstr ""
"Создание снимка не приводит к записи нового журнала упреждающей записи на"
" сервере. После создания снимка старые WAL-файлы можно удалить, если все "
"реплицируемые данные актуальны. Но WAL-файл на момент начала работы "
"``box.snapshot()`` следует сохранить на случай восстановления, поскольку "
"он содержит записи журнала после начала работы ``box.snapshot()``."

#: ../doc/1.10/reference/reference_lua/box_snapshot.rst:106
msgid ""
"An alternative way to save a snapshot is to send a SIGUSR1 signal to the "
"instance. While this approach could be handy, it is not recommended for "
"use in automation: a signal provides no way to find out whether the "
"snapshot was taken successfully or not."
msgstr ""
"Другим способом сохранения снимка будет отправка сигнала SIGUSR1 на "
"экземпляр. Хотя это может быть удобно, не рекомендуется использовать "
"такой метод в автоматическом процессе: сигнал не дает возможность "
"проверить, был ли корректно сделан снимок."

#: ../doc/1.10/reference/reference_lua/buffer.rst:39
msgid "Module `buffer`"
msgstr "Модуль `buffer`"

#: ../doc/1.10/reference/reference_lua/buffer.rst:41
msgid ""
"The ``buffer`` module returns a dynamically resizable buffer which is "
"solely for use as an option for methods of the :ref:`net.box module "
"<net_box-module>`."
msgstr ""
"Модуль ``buffer`` возвращает буфер, допускающий динамическое изменение "
"размера, который используется только в качестве опции для методов "
":ref:`модуля net.box <net_box-module>`."

#: ../doc/1.10/reference/reference_lua/buffer.rst:44
msgid ""
"Ordinarily the ``net.box`` methods return a Lua table. If a ``buffer`` "
"option is used, then the ``net.box`` methods return a raw MsgPack_ "
"string. This saves time on the server, if the client application has its "
"own routine for decoding MsgPack strings."
msgstr ""
"Как правило, модуль ``net.box`` возвращает Lua-таблицу. Если используется"
" опция ``buffer``, то методы модуля ``net.box`` возвращают "
"неформатированную строку MsgPack_. Это экономит время работы на сервере, "
"если в клиентском приложении есть собственная процедура декодирования "
"MsgPack-строк."

#: ../doc/1.10/reference/reference_lua/buffer.rst:54
msgid "a descriptor of a buffer."
msgstr "дескриптор буфера."

#: ../doc/1.10/reference/reference_lua/buffer.rst:55
#: ../doc/1.10/reference/reference_lua/uuid.rst:95
#: ../doc/1.10/reference/reference_lua/uuid.rst:117
#: ../doc/1.10/reference/reference_lua/uuid.rst:125
msgid "cdata"
msgstr "cdata."

#: ../doc/1.10/reference/reference_lua/buffer.rst:59
msgid ""
"Assume a Tarantool server is listening on farhost:3301. Assume it has a "
"space ``T`` with one tuple: ``'ABCDE', 12345``. In this example we start "
"up a server on localhost:3302 and then use ``net.box`` routines to "
"connect to farhost. Then we create a buffer, and use it as an option for "
"a ``conn.space...select()`` call. The result will be in MsgPack_ format. "
"To show this, we will use :ref:`msgpack.decode_unchecked() <msgpack-"
"decode_unchecked>` on ``ibuf.rpos`` (the \"read position\" of the "
"buffer). Thus we do not decode on the remote server, but we do decode on "
"the local server."
msgstr ""
"Предположим, что Tarantool-сервер настроен на прослушивание на "
"farhost:3301. Предположим, что на нем есть спейс ``T`` с одним кортежем: "
"``'ABCDE', 12345``. В данном примере запустим сервер на localhost:3302, а"
" затем используем процедуры ``net.box`` для подключения к farhost. Затем "
"создадим буфер и используем его как опцию для вызова "
"``conn.space...select()``. Результат получим в формате MsgPack_. Чтобы "
"показать это, используем :ref:`msgpack.decode_unchecked() <msgpack-"
"decode_unchecked>` на ``ibuf.rpos`` (\"позиция для чтения\" в буфере). "
"Таким образом, мы проведем декодирование не на удаленном сервере, а на "
"локальном."

#: ../doc/1.10/reference/reference_lua/buffer.rst:72
msgid ""
"box.cfg{listen=3302}\n"
"buffer = require('buffer')\n"
"ibuf = buffer.ibuf()\n"
"net_box = require('net.box')\n"
"conn = net_box.connect('farhost:3301')\n"
"buffer = require('buffer')\n"
"conn.space.T:select({},{buffer=ibuf})\n"
"msgpack = require('msgpack')\n"
"msgpack.decode_unchecked(ibuf.rpos)"
msgstr ""
"box.cfg{listen=3302}\n"
"buffer = require('buffer')\n"
"ibuf = buffer.ibuf()\n"
"net_box = require('net.box')\n"
"conn = net_box.connect('farhost:3301')\n"
"buffer = require('buffer')\n"
"conn.space.T:select({},{buffer=ibuf})\n"
"msgpack = require('msgpack')\n"
"msgpack.decode_unchecked(ibuf.rpos)"

#: ../doc/1.10/reference/reference_lua/buffer.rst:84
msgid "The result of the final request looks like this:"
msgstr "Результат последнего запроса выглядит следующим образом:"

#: ../doc/1.10/reference/reference_lua/buffer.rst:86
msgid ""
"tarantool> msgpack.decode_unchecked(ibuf.rpos)\n"
"---\n"
"- {48: [['ABCDE', 12345]]}\n"
"- 'cdata<char *>: 0x7f97ba10c041'\n"
"..."
msgstr ""
"tarantool> msgpack.decode_unchecked(ibuf.rpos)\n"
"---\n"
"- {48: [['ABCDE', 12345]]}\n"
"- 'cdata<char *>: 0x7f97ba10c041'\n"
"..."

#: ../doc/1.10/reference/reference_lua/buffer.rst:96
msgid ""
"Before Tarantool version 1.7.7, the function to use for this case is "
"``msgpack.ibuf_decode(ibuf.rpos)``. Starting with Tarantool version "
"1.7.7, ``ibuf_decode`` is deprecated."
msgstr ""
"До версии 1.7.7 Tarantool'а в данном случае следует использовать функцию "
"``msgpack.ibuf_decode(ibuf.rpos)``. Начиная с версии  1.7.7 Tarantool'а ,"
" ``ibuf_decode`` объявлена устаревшей."

#: ../doc/1.10/reference/reference_lua/clock.rst:45
msgid ""
"The ``clock`` module returns time values derived from the Posix / C "
"CLOCK_GETTIME_ function or equivalent. Most functions in the module "
"return a number of seconds; functions whose names end in \"64\" return a "
"64-bit number of nanoseconds."
msgstr ""
"Модуль ``clock`` возвращает значения времени, полученных из функции Posix"
" / C CLOCK_GETTIME_ или аналогичной. Большинство функций модуля "
"возвращают число секунд; функции, названия которых заканчиваются на "
"\"64\", возвращают 64-разрадяное число наносекунд."

#: ../doc/1.10/reference/reference_lua/clock.rst:54
msgid "Below is a list of all ``clock`` functions."
msgstr "Ниже приведен перечень всех функций модуля ``clock``."

#: ../doc/1.10/reference/reference_lua/clock.rst:64
msgid ":ref:`clock.time() <clock-time>` |br| :ref:`clock.realtime() <clock-time>`"
msgstr ":ref:`clock.time() <clock-time>` |br| :ref:`clock.realtime() <clock-time>`"

#: ../doc/1.10/reference/reference_lua/clock.rst:65
msgid "Get the wall clock time in seconds"
msgstr "Получение физического времени в секундах"

#: ../doc/1.10/reference/reference_lua/clock.rst:69
msgid ""
":ref:`clock.time64() <clock-time>` |br| :ref:`clock.realtime64() <clock-"
"time>`"
msgstr ""
":ref:`clock.time64() <clock-time>` |br| :ref:`clock.realtime64() <clock-"
"time>`"

#: ../doc/1.10/reference/reference_lua/clock.rst:70
msgid "Get the wall clock time in nanoseconds"
msgstr "Получение физического времени в наносекундах"

#: ../doc/1.10/reference/reference_lua/clock.rst:74
msgid ":ref:`clock.monotonic() <clock-monotonic>`"
msgstr ":ref:`clock.monotonic() <clock-monotonic>`"

#: ../doc/1.10/reference/reference_lua/clock.rst:74
msgid "Get the monotonic time in seconds"
msgstr "Получение монотонного времени в секундах"

#: ../doc/1.10/reference/reference_lua/clock.rst:77
msgid ":ref:`clock.monotonic64() <clock-monotonic>`"
msgstr ":ref:`clock.monotonic64() <clock-monotonic>`"

#: ../doc/1.10/reference/reference_lua/clock.rst:77
msgid "Get the monotonic time in nanoseconds"
msgstr "Получение монотонного времени в наносекундах"

#: ../doc/1.10/reference/reference_lua/clock.rst:80
msgid ":ref:`clock.proc() <clock-proc>`"
msgstr ":ref:`clock.proc() <clock-proc>`"

#: ../doc/1.10/reference/reference_lua/clock.rst:80
msgid "Get the processor time in seconds"
msgstr "Получение времени процессора в секундах"

#: ../doc/1.10/reference/reference_lua/clock.rst:83
msgid ":ref:`clock.proc64() <clock-proc>`"
msgstr ":ref:`clock.proc64() <clock-proc>`"

#: ../doc/1.10/reference/reference_lua/clock.rst:83
msgid "Get the processor time in nanoseconds"
msgstr "Получение времени процессора в наносекундах"

#: ../doc/1.10/reference/reference_lua/clock.rst:86
msgid ":ref:`clock.thread() <clock-thread>`"
msgstr ":ref:`clock.thread() <clock-thread>`"

#: ../doc/1.10/reference/reference_lua/clock.rst:86
msgid "Get the thread time in seconds"
msgstr "Получение рабочего времени потока в секундах"

#: ../doc/1.10/reference/reference_lua/clock.rst:89
msgid ":ref:`clock.thread64() <clock-thread>`"
msgstr ":ref:`clock.thread64() <clock-thread>`"

#: ../doc/1.10/reference/reference_lua/clock.rst:89
msgid "Get the thread time in nanoseconds"
msgstr "Получение рабочего времени потока в наносекундах"

#: ../doc/1.10/reference/reference_lua/clock.rst:92
msgid ":ref:`clock.bench() <clock-bench>`"
msgstr ":ref:`clock.bench() <clock-bench>`"

#: ../doc/1.10/reference/reference_lua/clock.rst:92
msgid "Measure the time a function takes within a processor"
msgstr "Измерение времени, которое функция проводит в процессоре"

#: ../doc/1.10/reference/reference_lua/clock.rst:105
msgid ""
"The wall clock time. Derived from C function "
"clock_gettime(CLOCK_REALTIME). This is the best function for knowing what"
" the official time is, as determined by the system administrator."
msgstr ""
"Физическое время в секундах. Получено из C-функции "
"clock_gettime(CLOCK_REALTIME). Использование этой функции лучше всего "
"подходит для выяснения официального времени, как установлено системным "
"администратором."

#: ../doc/1.10/reference/reference_lua/clock.rst:109
msgid "seconds or nanoseconds since epoch (1970-01-01 00:00:00), adjusted."
msgstr ""
"секунды или наносекунды с начала отсчета (1970-01-01 00:00:00), значение "
"корректируется."

#: ../doc/1.10/reference/reference_lua/clock.rst:110
#: ../doc/1.10/reference/reference_lua/clock.rst:135
#: ../doc/1.10/reference/reference_lua/clock.rst:156
#: ../doc/1.10/reference/reference_lua/clock.rst:177
msgid "number or number64"
msgstr "число или 64-разрядное число"

#: ../doc/1.10/reference/reference_lua/clock.rst:114
msgid ""
"-- This will print an approximate number of years since 1970.\n"
"clock = require('clock')\n"
"print(clock.time() / (365*24*60*60))"
msgstr ""
"-- Результатом будет примерное число лет с 1970.\n"
"clock = require('clock')\n"
"print(clock.time() / (365*24*60*60))"

#: ../doc/1.10/reference/reference_lua/clock.rst:120
msgid ""
"See also :ref:`fiber.time64 <fiber-time64>` and the standard Lua function"
" `os.clock <http://www.lua.org/manual/5.1/manual.html#pdf-os.clock>`_."
msgstr ""
"См. также :ref:`fiber.time64 <fiber-time64>` и стандартную Lua-функцию "
"`os.clock <http://www.lua.org/manual/5.1/manual.html#pdf-os.clock>`_."

#: ../doc/1.10/reference/reference_lua/clock.rst:128
msgid ""
"The monotonic time. Derived from C function "
"clock_gettime(CLOCK_MONOTONIC). Monotonic time is similar to wall clock "
"time but is not affected by changes to or from daylight saving time, or "
"by changes done by a user. This is the best function to use with "
"benchmarks that need to calculate elapsed time."
msgstr ""
"Монотонное время. Получено из C-функции clock_gettime(CLOCK_MONOTONIC). "
"Монотонное время похоже на физическое время, но на него не влияют "
"изменения для перехода на летнее время или изменения, сделанные "
"пользователем. Такую функцию лучше всего использовать для эталонного "
"тестирования, где необходимо рассчитать затраченное время."

#: ../doc/1.10/reference/reference_lua/clock.rst:134
msgid "seconds or nanoseconds since the last time that the computer was booted."
msgstr "секунды или наносекунды с момента последней загрузки компьютера."

#: ../doc/1.10/reference/reference_lua/clock.rst:139
msgid ""
"-- This will print nanoseconds since the start.\n"
"clock = require('clock')\n"
"print(clock.monotonic64())"
msgstr ""
"-- Результатом будет число наносекунд с запуска.\n"
"clock = require('clock')\n"
"print(clock.monotonic64())"

#: ../doc/1.10/reference/reference_lua/clock.rst:150
msgid ""
"The processor time. Derived from C function "
"``clock_gettime(CLOCK_PROCESS_CPUTIME_ID)``. This is the best function to"
" use with benchmarks that need to calculate how much time has been spent "
"within a CPU."
msgstr ""
"Время процессора. Получено из C-функции "
"``clock_gettime(CLOCK_PROCESS_CPUTIME_ID)``. Такую функцию лучше всего "
"использовать для эталонного тестирования, где необходимо рассчитать "
"время, затраченное на процессоре."

#: ../doc/1.10/reference/reference_lua/clock.rst:155
msgid "seconds or nanoseconds since processor start."
msgstr "секунды или наносекунды с момента начала работы процессора."

#: ../doc/1.10/reference/reference_lua/clock.rst:160
msgid ""
"-- This will print nanoseconds in the CPU since the start.\n"
"clock = require('clock')\n"
"print(clock.proc64())"
msgstr ""
"-- Результатом будет число наносекунд с запуска процессора.\n"
"clock = require('clock')\n"
"print(clock.proc64())"

#: ../doc/1.10/reference/reference_lua/clock.rst:171
msgid ""
"The thread time. Derived from C function "
"``clock_gettime(CLOCK_THREAD_CPUTIME_ID)``. This is the best function to "
"use with benchmarks that need to calculate how much time has been spent "
"within a thread within a CPU."
msgstr ""
"Рабочее время потока. Получено из C-функции "
"``clock_gettime(CLOCK_THREAD_CPUTIME_ID)``. Такую функцию лучше всего "
"использовать для эталонного тестирования, где необходимо рассчитать "
"время, затраченное потоком на процессоре."

#: ../doc/1.10/reference/reference_lua/clock.rst:176
msgid "seconds or nanoseconds since the transaction processor thread started."
msgstr ""
"секунды или наносекунды с момента начала работы потока процессора "
"транзакций."

#: ../doc/1.10/reference/reference_lua/clock.rst:181
msgid ""
"-- This will print seconds in the thread since the start.\n"
"clock = require('clock')\n"
"print(clock.thread64())"
msgstr ""
"-- Результатом будет число секунд с момента начала работы потока.\n"
"clock = require('clock')\n"
"print(clock.thread64())"

#: ../doc/1.10/reference/reference_lua/clock.rst:191
msgid ""
"The time that a function takes within a processor. This function uses "
"``clock.proc()``, therefore it calculates elapsed CPU time. Therefore it "
"is not useful for showing actual elapsed time."
msgstr ""
"Время, которое функция проводит в процессоре. Данная функция использует "
"``clock.proc()``, то есть рассчитывает затраченное процессором время. "
"Таким образом, она не используется для отображения фактически "
"затраченного времени."

#: ../doc/1.10/reference/reference_lua/clock.rst:195
msgid "function or function reference"
msgstr "функция или ссылка на функцию"

#: ../doc/1.10/reference/reference_lua/clock.rst:196
msgid "whatever values are required by the function."
msgstr "значения, которые необходимы для функции."

#: ../doc/1.10/reference/reference_lua/clock.rst:198
msgid ""
"**table**. first element - seconds of CPU time, second element - whatever"
" the function returns."
msgstr ""
"**таблица**. Первый элемент -- время работы процессора в секундах, второй"
" элемент -- то, что возвращает функция."

#: ../doc/1.10/reference/reference_lua/clock.rst:203
msgid ""
"-- Benchmark a function which sleeps 10 seconds.\n"
"-- NB: bench() will not calculate sleep time.\n"
"-- So the returned value will be {a number less than 10, 88}.\n"
"clock = require('clock')\n"
"fiber = require('fiber')\n"
"function f(param)\n"
"  fiber.sleep(param)\n"
"  return 88\n"
"end\n"
"clock.bench(f, 10)"
msgstr ""
"-- Эталонное тестирование функции, которая находится в спящем режиме в "
"течение 10 секунд.\n"
"-- NB: bench() не будет рассчитывать время сна.\n"
"-- Поэтому вернется значение, которое будет {число менее 10, 88}.\n"
"clock = require('clock')\n"
"fiber = require('fiber')\n"
"function f(param)\n"
"  fiber.sleep(param)\n"
"  return 88\n"
"end\n"
"clock.bench(f, 10)"

#: ../doc/1.10/reference/reference_lua/console.rst:39
msgid "Module `console`"
msgstr "Модуль `console`"

#: ../doc/1.10/reference/reference_lua/console.rst:45
msgid ""
"The console module allows one Tarantool instance to access another "
"Tarantool instance, and allows one Tarantool instance to start listening "
"on an :ref:`admin port <admin-security>`."
msgstr ""
"Модуль `console` позволяет одному экземпляру Tarantool'а получать доступ "
"к другому экземпляру Tarantool'а и позволяет одному экземпляру "
"Tarantool'а начать прослушивание по :ref:`порту администрирования <admin-"
"security>`."

#: ../doc/1.10/reference/reference_lua/console.rst:53
msgid "Below is a list of all ``console`` functions."
msgstr "Ниже приведен перечень всех функций модуля ``console``."

#: ../doc/1.10/reference/reference_lua/console.rst:63
msgid ":ref:`console.connect() <console-connect>`"
msgstr ":ref:`console.connect() <console-connect>`"

#: ../doc/1.10/reference/reference_lua/console.rst:63
msgid "Connect to an instance"
msgstr "Подключение к экземпляру"

#: ../doc/1.10/reference/reference_lua/console.rst:66
msgid ":ref:`console.listen() <console-listen>`"
msgstr ":ref:`console.listen() <console-listen>`"

#: ../doc/1.10/reference/reference_lua/console.rst:66
msgid "Listen for incoming requests"
msgstr "Прослушивание входящих запросов"

#: ../doc/1.10/reference/reference_lua/console.rst:69
msgid ":ref:`console.start() <console-start>`"
msgstr ":ref:`console.start() <console-start>`"

#: ../doc/1.10/reference/reference_lua/console.rst:69
msgid "Start the console"
msgstr "Запуск консоли"

#: ../doc/1.10/reference/reference_lua/console.rst:72
msgid ":ref:`console.ac() <console-ac>`"
msgstr ":ref:`console.ac() <console-ac>`"

#: ../doc/1.10/reference/reference_lua/console.rst:72
msgid "Set the auto-completion flag"
msgstr "Установка флага автодополнения ввода"

#: ../doc/1.10/reference/reference_lua/console.rst:75
msgid ":ref:`console.delimiter() <console-delimiter>`"
msgstr ":ref:`console.delimiter() <console-delimiter>`"

#: ../doc/1.10/reference/reference_lua/console.rst:75
msgid "Set a delimiter"
msgstr "Настройка разделителя"

#: ../doc/1.10/reference/reference_lua/console.rst:85
msgid ""
"Connect to the instance at :ref:`URI <index-uri>`, change the prompt from"
" '``tarantool>``' to ':samp:`{uri}>`', and act henceforth as a client "
"until the user ends the session or types ``control-D``."
msgstr ""
"Подключение к экземпляру по :ref:`URI <index-uri>`, смена командной "
"строки с '``tarantool>``' на ':samp:`{uri}>`' и дальнейшая работа в "
"качестве клиента до окончания сессии пользователя или ввода команды "
"``control-D``."

#: ../doc/1.10/reference/reference_lua/console.rst:89
msgid ""
"The console.connect function allows one Tarantool instance, in "
"interactive mode, to access another Tarantool instance. Subsequent "
"requests will appear to be handled locally, but in reality the requests "
"are being sent to the remote instance and the local instance is acting as"
" a client. Once connection is successful, the prompt will change and "
"subsequent requests are sent to, and executed on, the remote instance. "
"Results are displayed on the local instance. To return to local mode, "
"enter ``control-D``."
msgstr ""
"Функция console.connect позволяет одному экземпляру Tarantool'а в "
"интерактивном режиме получать доступ к другому экземпляру Tarantool'а. "
"Последующие запросы на первый взгляд будут обрабатываться локально, но в "
"действительности запросы отправляются на удаленный экземпляр, а локальный"
" экземпляр выступает в виде клиента. После успешного подключения "
"командная строка сменится, и последующие запросы отправляются и "
"выполняются на удаленном экземпляре. Результат выводится на локальный "
"экземпляр. Чтобы вернуться к работе на локальном экземпляре, введите "
"команду ``control-D``."

#: ../doc/1.10/reference/reference_lua/console.rst:97
msgid ""
"If the Tarantool instance at :samp:`uri` requires authentication, the "
"connection might look something like: "
"``console.connect('admin:secretpassword@distanthost.com:3301')``."
msgstr ""
"Если экземпляр Tarantool'а по :samp:`URI` запрашивает авторизацию, "
"подключение может выглядеть следующим образом: "
"``console.connect('admin:secretpassword@distanthost.com:3301')``."

#: ../doc/1.10/reference/reference_lua/console.rst:101
msgid ""
"There are no restrictions on the types of requests that can be entered, "
"except those which are due to privilege restrictions -- by default the "
"login to the remote instance is done with user name = 'guest'. The remote"
" instance could allow for this by granting at least one privilege: "
"``box.schema.user.grant('guest','execute','universe')``."
msgstr ""
"Нет ограничений по типу вводимых запросов, кроме ограничений по правам на"
" выполняемые запросы -- по умолчанию, вход в систему на удаленном "
"экземпляре выполняется от имени пользователя 'guest'. Можно разрешить "
"работу на удаленном экземпляре, выдав права: "
"``box.schema.user.grant('guest','execute','universe')``."

#: ../doc/1.10/reference/reference_lua/console.rst:107
msgid "the URI of the remote instance"
msgstr "URI удаленного экземпляра"

#: ../doc/1.10/reference/reference_lua/console.rst:110
msgid ""
"Possible errors: the connection will fail if the target Tarantool "
"instance was not initiated with ``box.cfg{listen=...}``."
msgstr ""
"Возможные ошибки: подключение не будет установлено, если целевой "
"экземпляр Tarantool'а не был инициирован с помощью "
"``box.cfg{listen=...}``."

#: ../doc/1.10/reference/reference_lua/console.rst:115
msgid ""
"tarantool> console = require('console')\n"
"---\n"
"...\n"
"tarantool> console.connect('198.18.44.44:3301')\n"
"---\n"
"...\n"
"198.18.44.44:3301> -- prompt is telling us that instance is remote"
msgstr ""
"tarantool> console = require('console')\n"
"---\n"
"...\n"
"tarantool> console.connect('198.18.44.44:3301')\n"
"---\n"
"...\n"
"198.18.44.44:3301> -- командная строка показывает, что работа идет с "
"удаленным экземпляром"

#: ../doc/1.10/reference/reference_lua/console.rst:129
msgid ""
"Listen on :ref:`URI <index-uri>`. The primary way of listening for "
"incoming requests is via the connection-information string, or URI, "
"specified in ``box.cfg{listen=...}``. The alternative way of listening is"
" via the URI specified in ``console.listen(...)``. This alternative way "
"is called \"administrative\" or simply :ref:`\"admin port\" <admin-"
"security>`. The listening is usually over a local host with a Unix domain"
" socket."
msgstr ""
"Прослушивание по :ref:`URI <index-uri>`. Основной способ прослушивания на"
" предмет входящих запросов -- по строке информации о подключении, или "
"URI, указанному в ``box.cfg{listen=...}``. Другой способ прослушивания --"
" по URI, указанному в ``console.listen(...)``. Этот другой способ "
"называется \"административным\" или просто :ref:`\"по порту "
"администрирования\" <admin-security>`. Такое прослушивание обычно "
"осуществляется по локальному хосту с доменным Unix-сокетом."

#: ../doc/1.10/reference/reference_lua/console.rst:136
msgid "the URI of the local instance"
msgstr "URI локального экземпляра"

#: ../doc/1.10/reference/reference_lua/console.rst:138
msgid ""
"The \"admin\" address is the URI to listen on. It has no default value, "
"so it must be specified if connections will occur via an admin port. The "
"parameter is expressed with URI = Universal Resource Identifier format, "
"for example \"/tmpdir/unix_domain_socket.sock\", or a numeric TCP port. "
"Connections are often made with telnet. A typical port value is 3313."
msgstr ""
"\"Административный\" адрес -- это URI для прослушивания. У него нет "
"значения по умолчанию, поэтому следует указать, будет ли подключение "
"производиться по порту администрирования. Параметр выражен URI = "
"Универсальным идентификатором ресурса, например "
"\"/tmpdir/unix_domain_socket.sock\", или числовым идентификатором "
"TCP-порта. Подключения часто выполняются по telnet. Типичное значение "
"порта: 3313."

#: ../doc/1.10/reference/reference_lua/console.rst:146
msgid ""
"tarantool> console = require('console')\n"
"---\n"
"...\n"
"tarantool> console.listen('unix/:/tmp/X.sock')\n"
"... main/103/console/unix/:/tmp/X I> started\n"
"---\n"
"- fd: 6\n"
"  name:\n"
"    host: unix/\n"
"    family: AF_UNIX\n"
"    type: SOCK_STREAM\n"
"    protocol: 0\n"
"    port: /tmp/X.sock\n"
"..."
msgstr ""
"tarantool> console = require('console')\n"
"---\n"
"...\n"
"tarantool> console.listen('unix/:/tmp/X.sock')\n"
"... main/103/console/unix/:/tmp/X I> started\n"
"---\n"
"- fd: 6\n"
"  name:\n"
"    host: unix/\n"
"    family: AF_UNIX\n"
"    type: SOCK_STREAM\n"
"    protocol: 0\n"
"    port: /tmp/X.sock\n"
"..."

#: ../doc/1.10/reference/reference_lua/console.rst:167
msgid "Start the console on the current interactive terminal."
msgstr "Запуск консоли на текущем интерактивном терминале."

#: ../doc/1.10/reference/reference_lua/console.rst:171
msgid ""
"A special use of ``console.start()`` is with :ref:`initialization files "
"<index-init_label>`. Normally, if one starts the Tarantool instance with "
":samp:`tarantool {initialization file}` there is no console. This can be "
"remedied by adding these lines at the end of the initialization file:"
msgstr ""
"``console.start()`` специально используется с :ref:`файлами инициализации"
" <index-init_label>`. Как правило, при запуске экземпляра Tarantool'а с "
"помощью команды :samp:`tarantool {initialization file}`, консоль не "
"поддерживается. Эту проблему можно решить путем добавления следующих "
"строк в конце файла инициализации:"

#: ../doc/1.10/reference/reference_lua/console.rst:176
msgid ""
"local console = require('console')\n"
"console.start()"
msgstr ""
"local console = require('console')\n"
"console.start()"

#: ../doc/1.10/reference/reference_lua/console.rst:185
msgid ""
"Set the auto-completion flag. If auto-completion is `true`, and the user "
"is using Tarantool as a client or the user is using Tarantool via "
"``console.connect()``, then hitting the TAB key may cause tarantool to "
"complete a word automatically. The default auto-completion value is "
"`true`."
msgstr ""
"Установка флага автодополнения ввода. Если значение автодополнения = "
"`true` (правда), и пользователь использует Tarantool в качестве клиента "
"или подключен к Tarantool'у по ``console.connect()``, то при нажатии "
"клавиши TAB Tarantool будет автоматически дополнять текст по введенной "
"части. По умолчанию, задано значение `true`."

#: ../doc/1.10/reference/reference_lua/console.rst:194
msgid "Set a custom end-of-request marker for Tarantool console."
msgstr "Настройка специального маркера окончания запроса для консоли Tarantool'а."

#: ../doc/1.10/reference/reference_lua/console.rst:196
msgid ""
"The default end-of-request marker is a newline (line feed). Custom "
"markers are not necessary because Tarantool can tell when a multi-line "
"request has not ended (for example, if it sees that a function "
"declaration does not have an end keyword). Nonetheless for special needs,"
" or for entering multi-line requests in older Tarantool versions, you can"
" change the end-of-request marker. As a result, newline alone is not "
"treated as end of request."
msgstr ""
"По умолчанию, маркер окончания запроса представляет собой символ разрыва "
"строки (перевод строки). Нет необходимости в специальных маркерах, "
"поскольку Tarantool может определить, если многостроковый запрос не "
"завершен (например, если видно, что при объявлении функции еще не задано "
"конечное ключевое слово). Тем не менее, в особых случаях или при вводе "
"многостроковых запросов в более ранних версиях Tarantool'а, можно "
"изменить маркер окончания запроса. В результате символ разрыва строки не "
"будет означать окончание запроса."

#: ../doc/1.10/reference/reference_lua/console.rst:204
msgid "To go back to normal mode, say: ``console.delimiter('')<marker>``"
msgstr ""
"Чтобы вернуться в нормальный режим, введите команду: "
"``console.delimiter('')<marker>``"

#: ../doc/1.10/reference/reference_lua/console.rst:206
msgid "a custom end-of-request marker for Tarantool console"
msgstr "специальный маркер окончания запроса для консоли Tarantool'а"

#: ../doc/1.10/reference/reference_lua/console.rst:210
msgid ""
"tarantool> console = require('console'); console.delimiter('!')\n"
"---\n"
"...\n"
"tarantool> function f ()\n"
"         > statement_1 = 'a'\n"
"         > statement_2 = 'b'\n"
"         > end!\n"
"---\n"
"...\n"
"tarantool> console.delimiter('')!\n"
"---\n"
"..."
msgstr ""
"tarantool> console = require('console'); console.delimiter('!')\n"
"---\n"
"...\n"
"tarantool> function f ()\n"
"         > statement_1 = 'a'\n"
"         > statement_2 = 'b'\n"
"         > end!\n"
"---\n"
"...\n"
"tarantool> console.delimiter('')!\n"
"---\n"
"..."

#: ../doc/1.10/reference/reference_lua/crypto.rst:39
msgid "Module `crypto`"
msgstr "Модуль `crypto`"

#: ../doc/1.10/reference/reference_lua/crypto.rst:47
msgid ""
"\"Crypto\" is short for \"Cryptography\", which generally refers to the "
"production of a digest value from a function (usually a `Cryptographic "
"hash function`_), applied against a string. Tarantool's ``crypto`` module"
" supports ten types of cryptographic hash functions (AES_, DES_, DSS_, "
"MD4_, MD5_, MDC2_, RIPEMD_, SHA-1_, SHA-2_). Some of the crypto "
"functionality is also present in the :ref:`digest` module."
msgstr ""
"\"Crypto\" -- это сокращенно \"криптография\", что обычно означает "
"производство значения дайджеста из функции (как правило, "
"криптографической хеш-функции -- `Cryptographic hash function`_), "
"примененной к строке. Модуль ``crypto`` Tarantool'а поддерживает десять "
"типов криптографических хеш-функций (AES_, DES_, DSS_, MD4_, MD5_, MDC2_,"
" RIPEMD_, SHA-1_, SHA-2_). В модуле :ref:`digest` также есть некоторые "
"криптографические функции."

#: ../doc/1.10/reference/reference_lua/crypto.rst:58
msgid "Below is a list of all ``crypto`` functions."
msgstr "Ниже приведен перечень всех функций модуля ``crypto``."

#: ../doc/1.10/reference/reference_lua/crypto.rst:68
msgid ":ref:`crypto.cipher.{algorithm}.{cipher_mode}.encrypt() <crypto-cipher>`"
msgstr ":ref:`crypto.cipher.{algorithm}.{cipher_mode}.encrypt() <crypto-cipher>`"

#: ../doc/1.10/reference/reference_lua/crypto.rst:68
msgid "Encrypt a string"
msgstr "Шифрование строки"

#: ../doc/1.10/reference/reference_lua/crypto.rst:71
msgid ":ref:`crypto.cipher.{algorithm}.{cipher_mode}.decrypt() <crypto-cipher>`"
msgstr ":ref:`crypto.cipher.{algorithm}.{cipher_mode}.decrypt() <crypto-cipher>`"

#: ../doc/1.10/reference/reference_lua/crypto.rst:71
msgid "Decrypt a string"
msgstr "Расшифрование строки"

#: ../doc/1.10/reference/reference_lua/crypto.rst:74
msgid ":ref:`crypto.digest.{algorithm}() <crypto-digest>`"
msgstr ":ref:`crypto.digest.{algorithm}() <crypto-digest>`"

#: ../doc/1.10/reference/reference_lua/crypto.rst:74
msgid "Get a digest"
msgstr "Получение дайджеста"

#: ../doc/1.10/reference/reference_lua/crypto.rst:84
msgid ""
"Pass or return a cipher derived from the string, key, and (optionally, "
"sometimes) initialization vector. The four choices of algorithms:"
msgstr ""
"Передача или возврат шифрованного сообщения, полученного из строки, ключа"
" и (необязательно) вектора инициализации. Четыре алгоритма на выбор:"

#: ../doc/1.10/reference/reference_lua/crypto.rst:87
msgid "aes128 - aes-128 (with 192-bit binary strings using AES)"
msgstr "aes128 - aes-128 (128-битные двоичные строки с использованием AES)"

#: ../doc/1.10/reference/reference_lua/crypto.rst:88
msgid "aes192 - aes-192 (with 192-bit binary strings using AES)"
msgstr "aes192 - aes-192 (192-битные двоичные строки с использованием AES)"

#: ../doc/1.10/reference/reference_lua/crypto.rst:89
msgid "aes256 - aes-256 (with 256-bit binary strings using AES)"
msgstr "aes256 - aes-256 (256-битные двоичные строки с использованием AES)"

#: ../doc/1.10/reference/reference_lua/crypto.rst:90
msgid ""
"des    - des (with 56-bit binary strings using DES, though DES is not "
"recommended)"
msgstr ""
"des    - des (56-битные двоичные строки с использованием DES, хотя "
"использование DES не рекомендуется)"

#: ../doc/1.10/reference/reference_lua/crypto.rst:93
msgid "Four choices of block cipher modes are also available:"
msgstr "Также доступны четыре режима блочного шифрования на выбор:"

#: ../doc/1.10/reference/reference_lua/crypto.rst:95
msgid "cbc - Cipher Block Chaining"
msgstr "cbc - Сцепление блоков шифротекста "

#: ../doc/1.10/reference/reference_lua/crypto.rst:96
msgid "cfb - Cipher Feedback"
msgstr "cfb - Обратная связь по шифротексту"

#: ../doc/1.10/reference/reference_lua/crypto.rst:97
msgid "ecb - Electronic Codebook"
msgstr "ecb - Электронная кодовая книга"

#: ../doc/1.10/reference/reference_lua/crypto.rst:98
msgid "ofb - Output Feedback"
msgstr "ofb - Обратная связь по выходу"

#: ../doc/1.10/reference/reference_lua/crypto.rst:100
msgid "For more information, read the article about `Encryption Modes`_"
msgstr ""
"Для получения дополнительной информации, см. статью о режимах шифрования "
"`Encryption Modes`_"

#: ../doc/1.10/reference/reference_lua/crypto.rst:104
msgid ""
"_16byte_iv='1234567890123456'\n"
"_16byte_pass='1234567890123456'\n"
"e=crypto.cipher.aes128.cbc.encrypt('string', _16byte_pass, _16byte_iv)\n"
"crypto.cipher.aes128.cbc.decrypt(e,  _16byte_pass, _16byte_iv)"
msgstr ""
"_16byte_iv='1234567890123456'\n"
"_16byte_pass='1234567890123456'\n"
"e=crypto.cipher.aes128.cbc.encrypt('string', _16byte_pass, _16byte_iv)\n"
"crypto.cipher.aes128.cbc.decrypt(e,  _16byte_pass, _16byte_iv)"

#: ../doc/1.10/reference/reference_lua/crypto.rst:119
msgid ""
"Pass or return a digest derived from the string. The eleven algorithm "
"choices:"
msgstr "Передача или возврат дайджеста из строки. Выбор из одиннадцати алгоритмов:"

#: ../doc/1.10/reference/reference_lua/crypto.rst:122
msgid "dss - dss (using DSS)"
msgstr "dss - dss (с использованием DSS)"

#: ../doc/1.10/reference/reference_lua/crypto.rst:123
msgid "dss1 - dss (using DSS-1)"
msgstr "dss1 - dss (с использованием DSS-1)"

#: ../doc/1.10/reference/reference_lua/crypto.rst:124
msgid "md4 - md4 (with 128-bit binary strings using MD4)"
msgstr "md4 - md4 (128-битные двоичные строки с использованием MD4)"

#: ../doc/1.10/reference/reference_lua/crypto.rst:125
msgid "md5 - md5 (with 128-bit binary strings using MD5)"
msgstr "md5 - md5 (128-битные двоичные строки с использованием MD5)"

#: ../doc/1.10/reference/reference_lua/crypto.rst:126
msgid "mdc2 - mdc2 (using MDC2)"
msgstr "mdc2 - mdc2 (с использованием MDC2)"

#: ../doc/1.10/reference/reference_lua/crypto.rst:127
msgid "ripemd160 - ripemd (with 160-bit binary strings using RIPEMD-160)"
msgstr ""
"ripemd160 - ripemd (160-битные двоичные строки с использованием "
"RIPEMD-160)"

#: ../doc/1.10/reference/reference_lua/crypto.rst:128
msgid "sha1 - sha-1 (with 160-bit binary strings using SHA-1)"
msgstr "sha1 - sha-1 (160-битные двоичные строки с использованием SHA-1)"

#: ../doc/1.10/reference/reference_lua/crypto.rst:129
msgid "sha224 - sha-224 (with 224-bit binary strings using SHA-2)"
msgstr "sha224 - sha-224 (224-битные двоичные строки с использованием SHA-2)"

#: ../doc/1.10/reference/reference_lua/crypto.rst:130
msgid "sha256 - sha-256 (with 256-bit binary strings using SHA-2)"
msgstr "sha256 - sha-256 (256-битные двоичные строки с использованием SHA-2)"

#: ../doc/1.10/reference/reference_lua/crypto.rst:131
msgid "sha384 - sha-384 (with 384-bit binary strings using SHA-2)"
msgstr "sha384 - sha-384 (384-битные двоичные строки с использованием SHA-2)"

#: ../doc/1.10/reference/reference_lua/crypto.rst:132
msgid "sha512 - sha-512(with 512-bit binary strings using SHA-2)."
msgstr "sha512 - sha-512(512-битные двоичные строки с использованием SHA-2)."

#: ../doc/1.10/reference/reference_lua/crypto.rst:136
msgid ""
"crypto.digest.md4('string')\n"
"crypto.digest.sha512('string')"
msgstr ""
"crypto.digest.md4('string')\n"
"crypto.digest.sha512('string')"

#: ../doc/1.10/reference/reference_lua/crypto.rst:143
msgid "Incremental methods in the crypto module"
msgstr "Инкрементальные методы в модуле ``crypto``"

#: ../doc/1.10/reference/reference_lua/crypto.rst:145
msgid ""
"Suppose that a digest is done for a string 'A', then a new part 'B' is "
"appended to the string, then a new digest is required. The new digest "
"could be recomputed for the whole string 'AB', but it is faster to take "
"what was computed before for 'A' and apply changes based on the new part "
"'B'. This is called multi-step or \"incremental\" digesting, which "
"Tarantool supports for all crypto functions."
msgstr ""
"Предположим, что вычислен дайджест для строки 'A', затем часть 'B' "
"добавляется в строку, необходим новый дайджест. Новый дайджест можно "
"пересчитать для всей строки 'AB', но быстрее будет взять вычисленный "
"дайджест для 'A' и внести изменения на основании добавленной части 'B'. "
"Это называется многошаговым процессом или \"инкрементным\" "
"хеш-суммированием, которое поддерживает Tarantool поддерживает для всех "
"криптографических функций."

#: ../doc/1.10/reference/reference_lua/crypto.rst:151
msgid ""
"crypto = require('crypto')\n"
"\n"
"-- print aes-192 digest of 'AB', with one step, then incrementally\n"
"key = 'key/key/key/key/key/key/'\n"
"iv =  'iviviviviviviviv'\n"
"print(crypto.cipher.aes192.cbc.encrypt('AB', key, iv))\n"
"c = crypto.cipher.aes192.cbc.encrypt.new(key)\n"
"c:init(nil, iv)\n"
"c:update('A')\n"
"c:update('B')\n"
"print(c:result())\n"
"c:free()\n"
"\n"
"-- print sha-256 digest of 'AB', with one step, then incrementally\n"
"print(crypto.digest.sha256('AB'))\n"
"c = crypto.digest.sha256.new()\n"
"c:init()\n"
"c:update('A')\n"
"c:update('B')\n"
"print(c:result())\n"
"c:free()"
msgstr ""
"crypto = require('crypto')\n"
"\n"
"-- вывести дайджест 'AB' по aes-192 пошагово, затем с инкрементом\n"
"key = 'key/key/key/key/key/key/'\n"
"iv =  'iviviviviviviviv'\n"
"print(crypto.cipher.aes192.cbc.encrypt('AB', key, iv))\n"
"c = crypto.cipher.aes192.cbc.encrypt.new(key)\n"
"c:init(nil, iv)\n"
"c:update('A')\n"
"c:update('B')\n"
"print(c:result())\n"
"c:free()\n"
"\n"
"-- вывести дайджест 'AB' по sha-256 пошагово, затем с инкрементом\n"
"print(crypto.digest.sha256('AB'))\n"
"c = crypto.digest.sha256.new()\n"
"c:init()\n"
"c:update('A')\n"
"c:update('B')\n"
"print(c:result())\n"
"c:free()"

#: ../doc/1.10/reference/reference_lua/crypto.rst:177
msgid "Getting the same results from digest and crypto modules"
msgstr "Получение одинаковых результатов из модулей digest и crypto"

#: ../doc/1.10/reference/reference_lua/crypto.rst:179
msgid ""
"The following functions are equivalent. For example, the ``digest`` "
"function and the ``crypto`` function will both produce the same result."
msgstr ""
"Следующие функции равноценны. Например, функция ``digest`` и функция "
"``crypto`` приведут к одному результату."

#: ../doc/1.10/reference/reference_lua/crypto.rst:182
msgid ""
"crypto.cipher.aes256.cbc.encrypt('x',b32,b16)==digest.aes256cbc.encrypt('x',b32,b16)"
"\n"
"crypto.digest.md4('string') == digest.md4('string')\n"
"crypto.digest.md5('string') == digest.md5('string')\n"
"crypto.digest.sha1('string') == digest.sha1('string')\n"
"crypto.digest.sha224('string') == digest.sha224('string')\n"
"crypto.digest.sha256('string') == digest.sha256('string')\n"
"crypto.digest.sha384('string') == digest.sha384('string')\n"
"crypto.digest.sha512('string') == digest.sha512('string')"
msgstr ""
"crypto.cipher.aes256.cbc.encrypt('x',b32,b16)==digest.aes256cbc.encrypt('x',b32,b16)"
"\n"
"crypto.digest.md4('string') == digest.md4('string')\n"
"crypto.digest.md5('string') == digest.md5('string')\n"
"crypto.digest.sha1('string') == digest.sha1('string')\n"
"crypto.digest.sha224('string') == digest.sha224('string')\n"
"crypto.digest.sha256('string') == digest.sha256('string')\n"
"crypto.digest.sha384('string') == digest.sha384('string')\n"
"crypto.digest.sha512('string') == digest.sha512('string')"

#: ../doc/1.10/reference/reference_lua/csv.rst:37
msgid "Module `csv`"
msgstr "Модуль `csv`"

#: ../doc/1.10/reference/reference_lua/csv.rst:45
msgid ""
"The ``csv`` module handles records formatted according to Comma-"
"Separated-Values (CSV) rules."
msgstr ""
"Модуль ``csv`` обрабатывает записи, форматированные в соответствии с "
"правилами CSV (значения, разделенные запятыми)."

#: ../doc/1.10/reference/reference_lua/csv.rst:48
msgid "The default formatting rules are:"
msgstr "По умолчанию, используются следующие правила форматирования:"

#: ../doc/1.10/reference/reference_lua/csv.rst:50
msgid ""
"Lua `escape sequences`_ such as \\\\n or \\\\10 are legal within strings "
"but not within files,"
msgstr ""
"Escape-последовательности `escape sequences`_ в Lua, такие как \\\\n или "
"\\\\10, можно использовать в строках, но не в файлах,"

#: ../doc/1.10/reference/reference_lua/csv.rst:52
msgid "Commas designate end-of-field,"
msgstr "Запятые обозначают конец поля,"

#: ../doc/1.10/reference/reference_lua/csv.rst:53
msgid "Line feeds, or line feeds plus carriage returns, designate end-of-record,"
msgstr ""
"Символы перевода строки или перевода строки плюс возврата каретки "
"означают конец записи,"

#: ../doc/1.10/reference/reference_lua/csv.rst:54
msgid "Leading or trailing spaces are ignored,"
msgstr "Начальные и конечные пробелы игнорируются,"

#: ../doc/1.10/reference/reference_lua/csv.rst:55
msgid "Quote marks may enclose fields or parts of fields,"
msgstr "Кавычками могут обрамляться поля или компоненты полей,"

#: ../doc/1.10/reference/reference_lua/csv.rst:56
msgid ""
"When enclosed by quote marks, commas and line feeds and spaces are "
"treated as ordinary characters, and a pair of quote marks \"\" is treated"
" as a single quote mark."
msgstr ""
"При обрамлении кавычками запятые, символы перевода строки и пробелы "
"считаются обычными символами, а двойные кавычки \"\" считаются "
"одинарными."

#: ../doc/1.10/reference/reference_lua/csv.rst:62
msgid "The possible options which can be passed to csv functions are:"
msgstr "Возможные параметры, передаваемые в функции модуля csv:"

#: ../doc/1.10/reference/reference_lua/csv.rst:64
msgid ""
":samp:`delimiter = {string}` (default: comma) -- single-byte character to"
" designate end-of-field"
msgstr ""
":samp:`delimiter = {строка}` (по умолчанию: запятая) -- однобайтовый "
"символ для обозначения конца поля"

#: ../doc/1.10/reference/reference_lua/csv.rst:66
msgid ""
":samp:`quote_char = {string}` (default: quote mark) -- single-byte "
"character to designate encloser of string"
msgstr ""
":samp:`quote_char = {строка}` (по умолчанию: кавычка) -- однобайтовый "
"символ для обозначения закрытия строки"

#: ../doc/1.10/reference/reference_lua/csv.rst:68
msgid ""
":samp:`chunk_size = {number}` (default: 4096) -- number of characters to "
"read at once (usually for file-IO efficiency)"
msgstr ""
":samp:`chunk_size = {число}` (по умолчанию: 4096) -- число символов для "
"одновременного чтения (обычно для эффективности файлового ввода-вывода)"

#: ../doc/1.10/reference/reference_lua/csv.rst:70
msgid ""
":samp:`skip_head_lines = {number}` (default: 0) -- number of lines to "
"skip at the start (usually for a header)"
msgstr ""
":samp:`skip_head_lines = {число}` (по умолчанию: 0) -- число строк, "
"которые пропускаются в начале (обычно для заголовка)"

#: ../doc/1.10/reference/reference_lua/csv.rst:77
msgid "Below is a list of all ``csv`` functions."
msgstr "Ниже приведен перечень всех функций модуля ``csv``."

#: ../doc/1.10/reference/reference_lua/csv.rst:87
msgid ":ref:`csv.load() <csv-load>`"
msgstr ":ref:`csv.load() <csv-load>`"

#: ../doc/1.10/reference/reference_lua/csv.rst:87
msgid "Load a CSV file"
msgstr "Загрузка CSV-файла"

#: ../doc/1.10/reference/reference_lua/csv.rst:90
msgid ":ref:`csv.dump() <csv-dump>`"
msgstr ":ref:`csv.dump() <csv-dump>`"

#: ../doc/1.10/reference/reference_lua/csv.rst:90
msgid "Transform input into a CSV-formatted string"
msgstr "Преобразование входного значения в строку формата CSV"

#: ../doc/1.10/reference/reference_lua/csv.rst:93
msgid ":ref:`csv.iterate() <csv-iterate>`"
msgstr ":ref:`csv.iterate() <csv-iterate>`"

#: ../doc/1.10/reference/reference_lua/csv.rst:93
msgid "Iterate over CSV records"
msgstr "Итерация по записям в формате CSV"

#: ../doc/1.10/reference/reference_lua/csv.rst:101
msgid ""
"Get CSV-formatted input from ``readable`` and return a table as output. "
"Usually ``readable`` is either a string or a file opened for reading. "
"Usually :samp:`{options}` is not specified."
msgstr ""
"Получение входного значения в формате CSV из ``readable`` и возврат "
"таблицы в качестве выходного значения. Обычно ``readable`` представляет "
"собой либо строку, либо открытый для чтения файл. Как правило, параметры "
":samp:`{options}` не указываются."

#: ../doc/1.10/reference/reference_lua/csv.rst:105
msgid ""
"a string, or any object which has a read() method, formatted according to"
" the CSV rules"
msgstr "строка или любой объект с методом read(), форматированный по правилам CSV "

#: ../doc/1.10/reference/reference_lua/csv.rst:107
#: ../doc/1.10/reference/reference_lua/csv.rst:233
msgid "see :ref:`above <csv-options>`"
msgstr "см. :ref:`выше <csv-options>`"

#: ../doc/1.10/reference/reference_lua/csv.rst:108
msgid "loaded_value"
msgstr "загруженное значение"

#: ../doc/1.10/reference/reference_lua/csv.rst:113
msgid ""
"Readable string has 3 fields, field#2 has comma and space so use quote "
"marks:"
msgstr ""
"В читаемой строке 3 поля, поле №2 содержит запятую и пробел, поэтому "
"следует использовать кавычки:"

#: ../doc/1.10/reference/reference_lua/csv.rst:116
msgid ""
"tarantool> csv = require('csv')\n"
"---\n"
"...\n"
"tarantool> csv.load('a,\"b,c \",d')\n"
"---\n"
"- - - a\n"
"    - 'b,c '\n"
"    - d\n"
"..."
msgstr ""
"tarantool> csv = require('csv')\n"
"---\n"
"...\n"
"tarantool> csv.load('a,\"b,c \",d')\n"
"---\n"
"- - - a\n"
"    - 'b,c '\n"
"    - d\n"
"..."

#: ../doc/1.10/reference/reference_lua/csv.rst:128
msgid ""
"Readable string contains 2-byte character = Cyrillic Letter Palochka: "
"(This displays a palochka if and only if character set = UTF-8.)"
msgstr ""
"В читаемой строке 2-байтный символ = Палочка в кириллице: (Отобразит "
"палочку только в том случае, если кодировка = UTF-8.)"

#: ../doc/1.10/reference/reference_lua/csv.rst:131
msgid ""
"tarantool> csv.load('a\\\\211\\\\128b')\n"
"---\n"
"- - - a\\211\\128b\n"
"..."
msgstr ""
"tarantool> csv.load('a\\\\211\\\\128b')\n"
"---\n"
"- - - a\\211\\128b\n"
"..."

#: ../doc/1.10/reference/reference_lua/csv.rst:138
msgid "Semicolon instead of comma for the delimiter:"
msgstr "Точка с запятой вместо запятой в виде символа разделителя:"

#: ../doc/1.10/reference/reference_lua/csv.rst:140
msgid ""
"tarantool> csv.load('a,b;c,d', {delimiter = ';'})\n"
"---\n"
"- - - a,b\n"
"    - c,d\n"
"..."
msgstr ""
"tarantool> csv.load('a,b;c,d', {delimiter = ';'})\n"
"---\n"
"- - - a,b\n"
"    - c,d\n"
"..."

#: ../doc/1.10/reference/reference_lua/csv.rst:148
msgid ""
"Readable file :file:`./file.csv` contains two CSV records. Explanation of"
" ``fio`` is in section :ref:`fio <fio-section>`. Source CSV file and "
"example respectively:"
msgstr ""
"Читаемый файл :file:`./file.csv` содержит две записи в формате CSV. "
"Объяснение блока ``fio`` дается в разделе :ref:`fio <fio-section>`. "
"Исходный CSV-файл и пример соответственно:"

#: ../doc/1.10/reference/reference_lua/csv.rst:152
msgid ""
"tarantool> -- input in file.csv is:\n"
"tarantool> -- a,\"b,c \",d\n"
"tarantool> -- a\\\\211\\\\128b\n"
"tarantool> fio = require('fio')\n"
"---\n"
"...\n"
"tarantool> f = fio.open('./file.csv', {'O_RDONLY'})\n"
"---\n"
"...\n"
"tarantool> csv.load(f, {chunk_size = 4096})\n"
"---\n"
"- - - a\n"
"    - 'b,c '\n"
"    - d\n"
"  - - a\\\\211\\\\128b\n"
"...\n"
"tarantool> f:close()\n"
"---\n"
"- true\n"
"..."
msgstr ""
"tarantool> -- входное значение в файле file.csv:\n"
"tarantool> -- a,\"b,c \",d\n"
"tarantool> -- a\\\\211\\\\128b\n"
"tarantool> fio = require('fio')\n"
"---\n"
"...\n"
"tarantool> f = fio.open('./file.csv', {'O_RDONLY'})\n"
"---\n"
"...\n"
"tarantool> csv.load(f, {chunk_size = 4096})\n"
"---\n"
"- - - a\n"
"    - 'b,c '\n"
"    - d\n"
"  - - a\\\\211\\\\128b\n"
"...\n"
"tarantool> f:close()\n"
"---\n"
"- true\n"
"..."

#: ../doc/1.10/reference/reference_lua/csv.rst:179
msgid ""
"Get table input from ``csv-table`` and return a CSV-formatted string as "
"output. Or, get table input from ``csv-table`` and put the output in "
"``writable``. Usually :samp:`{options}` is not specified. Usually "
"``writable``, if specified, is a file opened for writing. "
":ref:`csv.dump() <csv-dump>` is the reverse of :ref:`csv.load() <csv-"
"load>`."
msgstr ""
"Получение входного значения из таблицы ``csv-table`` и возврат строки в "
"формате CSV в качестве выходного значения. Или получение входного "
"значения из таблицы ``csv-table`` и размещение выходного значения в "
"``writable``. Обычно параметры :samp:`{options}` не указываются. Как "
"правило, если указан ``writable``, то это открытый для чтения файл. "
":ref:`csv.dump() <csv-dump>` -- это операция, обратная :ref:`csv.load() "
"<csv-load>`."

#: ../doc/1.10/reference/reference_lua/csv.rst:185
#: ../doc/1.10/reference/reference_lua/csv.rst:231
msgid "a table which can be formatted according to the CSV rules."
msgstr "таблица, которую можно форматировать в соответствии с правилами CSV"

#: ../doc/1.10/reference/reference_lua/csv.rst:187
msgid "optional. see :ref:`above <csv-options>`"
msgstr "необязательно. См. :ref:`выше <csv-options>`"

#: ../doc/1.10/reference/reference_lua/csv.rst:188
msgid "any object which has a ``write()`` method"
msgstr "любой объект с методом ``write()``"

#: ../doc/1.10/reference/reference_lua/csv.rst:190
msgid "dumped_value"
msgstr "записанное значение"

#: ../doc/1.10/reference/reference_lua/csv.rst:191
msgid "string, which is written to ``writable`` if specified"
msgstr "строка, которая записывается в объект ``writable``, если указан"

#: ../doc/1.10/reference/reference_lua/csv.rst:195
msgid "CSV-table has 3 fields, field#2 has \",\" so result has quote marks"
msgstr ""
"В таблице формата CSV 3 поля, поле №2 содержит \",\" поэтому результат "
"включает в себя кавычки"

#: ../doc/1.10/reference/reference_lua/csv.rst:197
msgid ""
"tarantool> csv = require('csv')\n"
"---\n"
"...\n"
"tarantool> csv.dump({'a','b,c ','d'})\n"
"---\n"
"- 'a,\"b,c \",d\n"
"\n"
"'\n"
"..."
msgstr ""
"tarantool> csv = require('csv')\n"
"---\n"
"...\n"
"tarantool> csv.dump({'a','b,c ','d'})\n"
"---\n"
"- 'a,\"b,c \",d\n"
"\n"
"'\n"
"..."

#: ../doc/1.10/reference/reference_lua/csv.rst:209
msgid "Round Trip: from string to table and back to string"
msgstr "Круговое преобразование: из строки в таблицу и обратно в строку"

#: ../doc/1.10/reference/reference_lua/csv.rst:211
msgid ""
"tarantool> csv_table = csv.load('a,b,c')\n"
"---\n"
"...\n"
"tarantool> csv.dump(csv_table)\n"
"---\n"
"- 'a,b,c\n"
"\n"
"'\n"
"..."
msgstr ""
"tarantool> csv_table = csv.load('a,b,c')\n"
"---\n"
"...\n"
"tarantool> csv.dump(csv_table)\n"
"---\n"
"- 'a,b,c\n"
"\n"
"'\n"
"..."

#: ../doc/1.10/reference/reference_lua/csv.rst:227
msgid ""
"Form a Lua iterator function for going through CSV records one field at a"
" time. Use of an iterator is strongly recommended if the amount of data "
"is large (ten or more megabytes)."
msgstr ""
"Создание Lua-функции с итератором для прохода по записям в формате CSV по"
" одному полю за раз. Настоятельно рекомендуется использовать итератор для"
" большого объема данных (10 мегабайт и более)."

#: ../doc/1.10/reference/reference_lua/csv.rst:235
msgid "Lua iterator function"
msgstr "Lua-функция с итератором"

#: ../doc/1.10/reference/reference_lua/csv.rst:236
msgid "iterator function"
msgstr "функция с итератором"

#: ../doc/1.10/reference/reference_lua/csv.rst:240
msgid ""
":ref:`csv.iterate() <csv-iterate>` is the low level of :ref:`csv.load() "
"<csv-load>` and :ref:`csv.dump() <csv-dump>`. To illustrate that, here is"
" a function which is the same as the :ref:`csv.load() <csv-load>` "
"function, as seen in `the Tarantool source code`_."
msgstr ""
":ref:`csv.iterate() <csv-iterate>` -- это :ref:`csv.load() <csv-load>` и "
":ref:`csv.dump() <csv-dump>` низкого уровня. Чтобы это доказать, "
"используем функцию, которая совпадает с функцией  :ref:`csv.load() <csv-"
"load>`, как можно увидеть в исходном коде Tarantool'а (`the Tarantool "
"source code`_)."

#: ../doc/1.10/reference/reference_lua/csv.rst:245
msgid ""
"tarantool> load = function(readable, opts)\n"
"         >   opts = opts or {}\n"
"         >   local result = {}\n"
"         >   for i, tup in csv.iterate(readable, opts) do\n"
"         >     result[i] = tup\n"
"         >   end\n"
"         >   return result\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> load('a,b,c')\n"
"---\n"
"- - - a\n"
"    - b\n"
"    - c\n"
"..."
msgstr ""
"tarantool> load = function(readable, opts)\n"
"         >   opts = opts or {}\n"
"         >   local result = {}\n"
"         >   for i, tup in csv.iterate(readable, opts) do\n"
"         >     result[i] = tup\n"
"         >   end\n"
"         >   return result\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> load('a,b,c')\n"
"---\n"
"- - - a\n"
"    - b\n"
"    - c\n"
"..."

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:39
msgid "Debug facilities"
msgstr "Средства отладки"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:45
msgid ""
"Tarantool users can benefit from built-in debug facilities that are part "
"of:"
msgstr ""
"Пользователи Tarantool'а могут воспользоваться преимуществами встроенных "
"средств отладки, которые составляют часть:"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:47
msgid ""
"Lua (`debug <https://www.lua.org/manual/5.1/manual.html#5.9>`_ library, "
"see details below) and"
msgstr ""
"Lua (библиотека `отладки "
"<https://www.lua.org/manual/5.1/manual.html#5.9>`_, см. подробное "
"описание ниже) и"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:49
msgid "LuaJit (`debug.* <http://luajit.org/extensions.html>`_ functions)."
msgstr "LuaJit (функции отладки `debug.* <http://luajit.org/extensions.html>`_)."

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:53
msgid ""
"The ``debug`` library provides an interface for debugging Lua programs. "
"All functions in this library reside in the ``debug`` table. Those "
"functions that operate on a thread have an optional first parameter that "
"specifies the thread to operate on. The default is always the current "
"thread."
msgstr ""
"Библиотека ``debug`` предоставляет интерфейс для отладки Lua-программ. "
"Все функции этой библиотеки содержатся в таблице ``debug``. В функциях "
"для работы с потоками есть дополнительный первый параметр, в котором "
"указывается необходимый поток. По умолчанию, это всегда текущий поток."

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:60
msgid ""
"This library should be used only for debugging and profiling and not as a"
" regular programming tool, as the functions provided here can take too "
"long to run. Besides, several of these functions can compromise otherwise"
" secure code."
msgstr ""
"Библиотеку следует использовать только для отладки и профилирования, а не"
" в качестве программного средства, поскольку данные функции выполняются "
"слишком долго. Кроме того, некоторые из этих функций могут привести к "
"нарушению работы безопасного в других отношениях кода."

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:69
msgid "Below is a list of all ``debug`` functions."
msgstr "Ниже приведен перечень всех функций библиотеки ``debug``."

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:79
msgid ":ref:`debug.debug() <debug-debug>`"
msgstr ":ref:`debug.debug() <debug-debug>`"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:79
msgid "Enter an interactive mode"
msgstr "Вход в интерактивный режим"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:82
msgid ":ref:`debug.getfenv() <debug-getfenv>`"
msgstr ":ref:`debug.getfenv() <debug-getfenv>`"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:82
msgid "Get an object's environment"
msgstr "Получение среды объекта"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:85
msgid ":ref:`debug.gethook() <debug-gethook>`"
msgstr ":ref:`debug.gethook() <debug-gethook>`"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:85
msgid "Get a thread's current hook settings"
msgstr "Получение текущих настроек ловушки потока"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:88
msgid ":ref:`debug.getinfo() <debug-getinfo>`"
msgstr ":ref:`debug.getinfo() <debug-getinfo>`"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:88
msgid "Get information about a function"
msgstr "Получение информации о функции"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:91
msgid ":ref:`debug.getlocal() <debug-getlocal>`"
msgstr ":ref:`debug.getlocal() <debug-getlocal>`"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:91
msgid "Get a local variable's name and value"
msgstr "Получение имени и значения локальной переменной"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:94
msgid ":ref:`debug.getmetatable() <debug-getmetatable>`"
msgstr ":ref:`debug.getmetatable() <debug-getmetatable>`"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:94
msgid "Get an object's metatable"
msgstr "Получение метатаблицы объекта"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:97
msgid ":ref:`debug.getregistry() <debug-getregistry>`"
msgstr ":ref:`debug.getregistry() <debug-getregistry>`"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:97
msgid "Get the registry table"
msgstr "Получение таблицы реестра"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:100
msgid ":ref:`debug.getupvalue() <debug-getupvalue>`"
msgstr ":ref:`debug.getupvalue() <debug-getupvalue>`"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:100
msgid "Get an upvalue's name and value"
msgstr "Получение имени и значения сопоставляющего значения"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:103
msgid ":ref:`debug.setfenv() <debug-setfenv>`"
msgstr ":ref:`debug.setfenv() <debug-setfenv>`"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:103
msgid "Set an object's environment"
msgstr "Определение среды объекта"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:106
msgid ":ref:`debug.sethook() <debug-sethook>`"
msgstr ":ref:`debug.sethook() <debug-sethook>`"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:106
msgid "Set a given function as a hook"
msgstr "Определение данной функции в качестве ловушки"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:109
msgid ":ref:`debug.setlocal() <debug-setlocal>`"
msgstr ":ref:`debug.setlocal() <debug-setlocal>`"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:109
msgid "Assign a value to a local variable"
msgstr "Присваивание значения локальной переменной"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:112
msgid ":ref:`debug.setmetatable() <debug-setmetatable>`"
msgstr ":ref:`debug.setmetatable() <debug-setmetatable>`"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:112
msgid "Set an object's metatable"
msgstr "Определение метатаблицы объекта"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:115
msgid ":ref:`debug.setupvalue() <debug-setupvalue>`"
msgstr ":ref:`debug.setupvalue() <debug-setupvalue>`"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:115
msgid "Assign a value to an upvalue"
msgstr "Присваивание значения сопоставляющему значению"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:118
msgid ":ref:`debug.traceback() <debug-traceback>`"
msgstr ":ref:`debug.traceback() <debug-traceback>`"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:118
msgid "Get a traceback of the call stack"
msgstr "Получение обратной трассировки стека вызовов"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:126
msgid ""
"Enters an interactive mode and runs each string that the user types in. "
"The user can, among other things, inspect global and local variables, "
"change their values and evaluate expressions."
msgstr ""
"Вход в интерактивный режим и выполнение каждой строки, которую печатает "
"пользователь. Пользователь может, в частности, проверять глобальные и "
"локальные переменные, изменять их значения и вычислять выражения."

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:130
msgid ""
"Enter ``cont`` to exit this function, so that the caller can continue its"
" execution."
msgstr ""
"Введите ``cont`` для выхода из данной функции, чтобы вызывающий клиент "
"мог продолжить выполнение."

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:135
msgid ""
"Commands for ``debug.debug()`` are not lexically nested within any "
"function and so have no direct access to local variables."
msgstr ""
"Команды для ``debug.debug()`` не вложены лексически в какую-либо функцию,"
" поэтому у них нет прямого доступа к локальным переменным."

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:142
msgid "object to get the environment of"
msgstr "объект, для которого будет получена среда"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:145
msgid "the environment of the ``object``"
msgstr "среда объекта ``object``"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:151
msgid "the current hook settings of the ``thread`` as three values:"
msgstr "текущие настройки ловушки потока ``thread`` в виде трех значений:"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:153
msgid "the current hook function"
msgstr "текущая функция-ловушка"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:154
msgid "the current hook mask"
msgstr "текущая маска ловушки"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:155
msgid "the current hook count as set by the ``debug.sethook()`` function"
msgstr "текущий счетчик ловушки, как определяет функция  ``debug.sethook()``"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:161
msgid "function to get information on"
msgstr "функция, по которой будет получена информация"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:163
msgid "what information on the ``function`` to return"
msgstr "какую информацию о функции ``function`` вернуть"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:165
msgid "a table with information about the ``function``"
msgstr "таблица с информацией о функции ``function``"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:167
msgid ""
"You can pass in a ``function`` directly, or you can give a number that "
"specifies a function running at level ``function`` of the call stack of "
"the given ``thread``: level 0 is the current function (``getinfo()`` "
"itself), level 1 is the function that called ``getinfo()``, and so on. If"
" ``function`` is a number larger than the number of active functions, "
"``getinfo()`` returns ``nil``."
msgstr ""
"Можно передать функцию ``function`` напрямую или же передать число, "
"которое указывает на функцию, выполняемую на уровне ``function`` стека "
"вызовов данного потока ``thread``: уровень 0 -- это текущая функция (сама"
" функция ``getinfo()``), уровень 1 -- это функция, которая вызвала "
"``getinfo()``, и т.д. Если для функции ``function`` указано число больше "
"числа активных функций, ``getinfo()`` вернет ``nil``."

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:174
msgid ""
"The default for ``what`` is to get all information available, except the "
"table of valid lines. If present, the option ``f`` adds a field named "
"``func`` with the function itself. If present, the option ``L`` adds a "
"field named ``activelines`` with the table of valid lines."
msgstr ""
"По умолчанию, ``what`` -- это вся доступная информация, кроме таблицы "
"допустимых строк. Если задать опцию ``f``, добавится поле под названием "
"``func`` с самой функцией. Если задать опцию ``L``, добавится поле под "
"названием ``activelines`` с таблицей доступных строк."

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:183
#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:260
msgid "level of the stack"
msgstr "уровень стека"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:184
#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:261
msgid "index of the local variable"
msgstr "индекс локальной переменной"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:186
msgid ""
"the name and the value of the local variable with the index ``local`` of "
"the function at level ``level`` of the stack or ``nil`` if there is no "
"local variable with the given index; raises an error if ``level`` is out "
"of range"
msgstr ""
"имя и значение локальной переменной с индексом ``local`` функции на "
"уровне ``level`` стека или ``nil``, если нет локальной переменной с "
"указанным индексом; появится ошибка, если уровень ``level`` вне диапазона"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:193
#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:271
msgid "You can call ``debug.getinfo()`` to check whether the level is valid."
msgstr "Можно вызвать ``debug.getinfo()`` для проверки доступности уровня."

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:199
msgid "object to get the metatable of"
msgstr "объект, для которого будет получена метатаблица"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:202
msgid "a metatable of the ``object`` or ``nil`` if it does not have a metatable"
msgstr "метатаблица объекта ``object`` или ``nil``, если метатаблица отсутствует"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:209
msgid "the registry table"
msgstr "таблица реестра"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:215
msgid "function to get the upvalue of"
msgstr "функция, для которой будет получено сопоставляющее значение"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:216
#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:291
msgid "index of the function upvalue"
msgstr "индекс сопоставляющего значения функции"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:218
msgid ""
"the name and the value of the upvalue with the index ``up`` of the "
"function ``func`` or ``nil`` if there is no upvalue with the given index"
msgstr ""
"имя и значение сопоставляющего значения с индексом ``up`` функции "
"``func`` или ``nil``, если нет сопоставляющего значения в пределах "
"заданного индекса"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:226
msgid "Sets the environment of the ``object`` to the ``table``."
msgstr "Определение среды объекта ``object`` для таблицы ``table``."

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:228
msgid "object to change the environment of"
msgstr "объект, среда которого будет изменена"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:230
msgid "table to set the object environment to"
msgstr "таблица для определения среды объекта"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:232
msgid "the ``object``"
msgstr "объект ``object``"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:238
msgid ""
"Sets the given function as a hook.  When called without arguments, turns "
"the hook off."
msgstr ""
"Определение данной функции в качестве ловушки. При вызове без аргументов "
"ловушка отключается."

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:241
msgid "function to set as a hook"
msgstr "функция, которая будет определена в качестве ловушки"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:242
msgid ""
"describes when the ``hook`` will be called; may have the following "
"values:  * ``c`` - the ``hook`` is called every time Lua calls a function"
" * ``r`` - the ``hook`` is called every time Lua returns from a function "
"* ``l`` - the ``hook`` is called every time Lua enters a new line of code"
msgstr ""
"описание того, когда будет вызвана ловушка ``hook``; может принимать "
"следующие значения:  * ``c`` -- ловушка``hook`` вызывается каждый раз, "
"когда Lua вызывает функцию * ``r`` -- ловушка ``hook`` вызывается каждый "
"раз, когда Lua возвращается из функции * ``l`` -- ловушка ``hook`` "
"вызывается каждый раз, когда Lua переходит на новую строку кода"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:242
msgid "describes when the ``hook`` will be called; may have the following values:"
msgstr ""
"описание того, когда будет вызвана ловушка ``hook``; может принимать "
"следующие значения:"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:245
msgid "``c`` - the ``hook`` is called every time Lua calls a function"
msgstr "``c`` -- ловушка``hook`` вызывается каждый раз, когда Lua вызывает функцию"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:246
msgid "``r`` - the ``hook`` is called every time Lua returns from a function"
msgstr ""
"``r`` -- ловушка ``hook`` вызывается каждый раз, когда Lua возвращается "
"из функции"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:247
msgid "``l`` - the ``hook`` is called every time Lua enters a new line of code"
msgstr ""
"``l`` -- ловушка ``hook`` вызывается каждый раз, когда Lua переходит на "
"новую строку кода"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:249
msgid ""
"describes when the ``hook`` will be called; when different from zero, the"
" ``hook`` is called after every ``count`` instructions."
msgstr ""
"описание того, когда будет вызвана ловушка ``hook``; если отличается от "
"нуля, ловушка ``hook`` вызывается после каждой инструкции ``count``."

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:257
msgid ""
"Assigns the value ``value`` to the local variable with the index "
"``local`` of the function at level ``level`` of the stack."
msgstr ""
"Присвоение значения ``value`` локальной переменной с индексом ``local`` "
"функции на уровне ``level`` стека"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:262
msgid "value to assign to the local variable"
msgstr "значение, присваиваемое локальной переменной"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:265
msgid ""
"the name of the local variable or ``nil`` if there is no local variable "
"with the given index; raises an error if ``level`` is out of range"
msgstr ""
"имя локальной переменной или ``nil``, если локальная переменная с "
"заданным индексом отсутствует; возникает ошибка, если уровень ``level`` "
"вне диапазона"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:277
msgid "Sets the metatable of the ``object`` to the ``table``."
msgstr "Определение метатаблицы объекта ``object`` для таблицы ``table``."

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:279
msgid "object to change the metatable of"
msgstr "объект, метатаблица которого будет изменена"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:281
msgid "table to set the object metatable to"
msgstr "таблица для определения метатаблицы объекта"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:287
msgid ""
"Assigns the value ``value`` to the upvalue with the index ``up`` of the "
"function ``func``."
msgstr ""
"Присвоение значения ``value`` сопоставляющему значению с индексом ``up`` "
"функции ``func``."

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:290
msgid "function to set the upvalue of"
msgstr "функция, для которой будет определено сопоставляющее значение"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:292
msgid "value to assign to the function upvalue"
msgstr "значение, присваиваемое сопоставляющему значению функции"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:295
msgid ""
"the name of the upvalue or ``nil`` if there is no upvalue with the given "
"index"
msgstr ""
"имя сопоставляющего значения или ``nil``, если сопоставляющее значение с "
"данным индексом отсутствует"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:302
msgid "an optional message prepended to the traceback"
msgstr "необязательное сообщение, добавленное к началу обратной трассировки"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:303
msgid "specifies at which level to start the traceback (default is 1)"
msgstr "указывает на каком уровне начинать обратную трассировку (по умолчанию, 1)"

#: ../doc/1.10/reference/reference_lua/debug_facilities.rst:306
msgid "a string with a traceback of the call stack"
msgstr "строка с обратной трассировкой стека вызовов"

#: ../doc/1.10/reference/reference_lua/digest.rst:39
msgid "Module `digest`"
msgstr "Модуль `digest`"

#: ../doc/1.10/reference/reference_lua/digest.rst:47
msgid ""
"A \"digest\" is a value which is returned by a function (usually a "
"`Cryptographic hash function`_), applied against a string. Tarantool's "
"``digest`` module supports several types of cryptographic hash functions "
"(AES_, MD4_, MD5_, SHA-1_, SHA-2_, PBKDF2_) as well as a checksum "
"function (CRC32_), two functions for base64_, and two non-cryptographic "
"hash functions (guava_, murmur_). Some of the digest functionality is "
"also present in the :ref:`crypto <crypto>`."
msgstr ""
"\"Дайджест\" -- это значение, которое возвращает функция (как правило, "
"криптографическая хеш-функция -- `Cryptographic hash function`_), "
"примененная к строке. Модуль``digest`` Tarantool'а поддерживает несколько"
" типов криптографических хеш-функций  (AES_, MD4_, MD5_, SHA-1_, SHA-2_, "
"PBKDF2_), а также функцию контрольного суммирования (CRC32_), две функции"
" для base64_ и две некриптографические хеш-функции (guava_, murmur_). "
"Часть функций модуля digest также включена в модуль :ref:`crypto "
"<crypto>`."

#: ../doc/1.10/reference/reference_lua/digest.rst:58
msgid "Below is a list of all ``digest`` functions."
msgstr "Ниже приведен перечень всех функций модуля ``digest``."

#: ../doc/1.10/reference/reference_lua/digest.rst:68
msgid ":ref:`digest.aes256cbc.encrypt() <digest-aes>`"
msgstr ":ref:`digest.aes256cbc.encrypt() <digest-aes>`"

#: ../doc/1.10/reference/reference_lua/digest.rst:68
msgid "Encrypt a string using AES"
msgstr "Шифрование строки с использованием AES"

#: ../doc/1.10/reference/reference_lua/digest.rst:71
msgid ":ref:`digest.aes256cbc.decrypt() <digest-aes>`"
msgstr ":ref:`digest.aes256cbc.decrypt() <digest-aes>`"

#: ../doc/1.10/reference/reference_lua/digest.rst:71
msgid "Decrypt a string using AES"
msgstr "Расшифрование строки с использованием AES"

#: ../doc/1.10/reference/reference_lua/digest.rst:74
msgid ":ref:`digest.md4() <digest-md4>`"
msgstr ":ref:`digest.md4() <digest-md4>`"

#: ../doc/1.10/reference/reference_lua/digest.rst:74
msgid "Get a digest made with MD4"
msgstr "Получение дайджеста с помощью MD4"

#: ../doc/1.10/reference/reference_lua/digest.rst:77
msgid ":ref:`digest.md4_hex() <digest-md4_hex>`"
msgstr ":ref:`digest.md4_hex() <digest-md4_hex>`"

#: ../doc/1.10/reference/reference_lua/digest.rst:77
msgid "Get a hexadecimal digest made with MD4"
msgstr "Получение шестнадцатеричного дайджеста с помощью MD4"

#: ../doc/1.10/reference/reference_lua/digest.rst:80
msgid ":ref:`digest.md5() <digest-md5>`"
msgstr ":ref:`digest.md5() <digest-md5>`"

#: ../doc/1.10/reference/reference_lua/digest.rst:80
msgid "Get a digest made with MD5"
msgstr "Получение дайджеста с помощью MD5"

#: ../doc/1.10/reference/reference_lua/digest.rst:83
msgid ":ref:`digest.md5_hex() <digest-md5_hex>`"
msgstr ":ref:`digest.md5_hex() <digest-md5_hex>`"

#: ../doc/1.10/reference/reference_lua/digest.rst:83
msgid "Get a hexadecimal digest made with MD5"
msgstr "Получение шестнадцатеричного дайджеста с помощью MD5"

#: ../doc/1.10/reference/reference_lua/digest.rst:86
msgid ":ref:`digest.pbkdf2() <digest-pbkdf2>`"
msgstr ":ref:`digest.pbkdf2() <digest-pbkdf2>`"

#: ../doc/1.10/reference/reference_lua/digest.rst:86
msgid "Get a digest made with PBKDF2"
msgstr "Получение дайджеста с помощью PBKDF2"

#: ../doc/1.10/reference/reference_lua/digest.rst:89
msgid ":ref:`digest.sha1() <digest-sha1>`"
msgstr ":ref:`digest.sha1() <digest-sha1>`"

#: ../doc/1.10/reference/reference_lua/digest.rst:89
msgid "Get a digest made with SHA-1"
msgstr "Получение дайджеста с помощью SHA-1"

#: ../doc/1.10/reference/reference_lua/digest.rst:92
msgid ":ref:`digest.sha1_hex() <digest-sha1_hex>`"
msgstr ":ref:`digest.sha1_hex() <digest-sha1_hex>`"

#: ../doc/1.10/reference/reference_lua/digest.rst:92
msgid "Get a hexadecimal digest made with SHA-1"
msgstr "Получение шестнадцатеричного дайджеста с помощью SHA-1"

#: ../doc/1.10/reference/reference_lua/digest.rst:95
msgid ":ref:`digest.sha224() <digest-sha224>`"
msgstr ":ref:`digest.sha224() <digest-sha224>`"

#: ../doc/1.10/reference/reference_lua/digest.rst:95
msgid "Get a 224-bit digest made with SHA-2"
msgstr "Получение 224-битного дайджеста с помощью SHA-2"

#: ../doc/1.10/reference/reference_lua/digest.rst:98
msgid ":ref:`digest.sha224_hex() <digest-sha224_hex>`"
msgstr ":ref:`digest.sha224_hex() <digest-sha224_hex>`"

#: ../doc/1.10/reference/reference_lua/digest.rst:98
msgid "Get a 56-byte hexadecimal digest made with SHA-2"
msgstr "Получение 56-байтного шестнадцатеричного дайджеста с помощью SHA-2"

#: ../doc/1.10/reference/reference_lua/digest.rst:101
msgid ":ref:`digest.sha256() <digest-sha256>`"
msgstr ":ref:`digest.sha256() <digest-sha256>`"

#: ../doc/1.10/reference/reference_lua/digest.rst:101
msgid "Get a 256-bit digest made with SHA-2"
msgstr "Получение 256-битного дайджеста с помощью SHA-2"

#: ../doc/1.10/reference/reference_lua/digest.rst:104
msgid ":ref:`digest.sha256_hex() <digest-sha256_hex>`"
msgstr ":ref:`digest.sha256_hex() <digest-sha256_hex>`"

#: ../doc/1.10/reference/reference_lua/digest.rst:104
msgid "Get a 64-byte hexadecimal digest made with SHA-2"
msgstr "Получение 64-байтного шестнадцатеричного дайджеста с помощью SHA-2"

#: ../doc/1.10/reference/reference_lua/digest.rst:107
msgid ":ref:`digest.sha384() <digest-sha384>`"
msgstr ":ref:`digest.sha384() <digest-sha384>`"

#: ../doc/1.10/reference/reference_lua/digest.rst:107
msgid "Get a 384-bit digest made with SHA-2"
msgstr "Получение 384-битного дайджеста с помощью SHA-2"

#: ../doc/1.10/reference/reference_lua/digest.rst:110
msgid ":ref:`digest.sha384_hex() <digest-sha384_hex>`"
msgstr ":ref:`digest.sha384_hex() <digest-sha384_hex>`"

#: ../doc/1.10/reference/reference_lua/digest.rst:110
msgid "Get a 96-byte hexadecimal digest made with SHA-2"
msgstr "Получение 96-байтного шестнадцатеричного дайджеста с помощью SHA-2"

#: ../doc/1.10/reference/reference_lua/digest.rst:113
msgid ":ref:`digest.sha512() <digest-sha512>`"
msgstr ":ref:`digest.sha512() <digest-sha512>`"

#: ../doc/1.10/reference/reference_lua/digest.rst:113
msgid "Get a 512-bit digest made with SHA-2"
msgstr "Получение 512-битного дайджеста с помощью SHA-2"

#: ../doc/1.10/reference/reference_lua/digest.rst:116
msgid ":ref:`digest.sha512_hex() <digest-sha512_hex>`"
msgstr ":ref:`digest.sha512_hex() <digest-sha512_hex>`"

#: ../doc/1.10/reference/reference_lua/digest.rst:116
msgid "Get a 128-byte hexadecimal digest made with SHA-2"
msgstr "Получение 128-байтного шестнадцатеричного дайджеста с помощью SHA-2"

#: ../doc/1.10/reference/reference_lua/digest.rst:119
msgid ":ref:`digest.base64_encode() <digest-base64_encode>`"
msgstr ":ref:`digest.base64_encode() <digest-base64_encode>`"

#: ../doc/1.10/reference/reference_lua/digest.rst:119
msgid "Encode a string to Base64"
msgstr "Кодирование строки по стандарту Base64"

#: ../doc/1.10/reference/reference_lua/digest.rst:122
msgid ":ref:`digest.base64_decode() <digest-base64_decode>`"
msgstr ":ref:`digest.base64_decode() <digest-base64_decode>`"

#: ../doc/1.10/reference/reference_lua/digest.rst:122
msgid "Decode a Base64-encoded string"
msgstr "Декодирование строки по стандарту Base64"

#: ../doc/1.10/reference/reference_lua/digest.rst:125
msgid ":ref:`digest.urandom() <digest-urandom>`"
msgstr ":ref:`digest.urandom() <digest-urandom>`"

#: ../doc/1.10/reference/reference_lua/digest.rst:125
msgid "Get an array of random bytes"
msgstr "Получение массива случайных байтов"

#: ../doc/1.10/reference/reference_lua/digest.rst:128
msgid ":ref:`digest.crc32() <digest-crc32>`"
msgstr ":ref:`digest.crc32() <digest-crc32>`"

#: ../doc/1.10/reference/reference_lua/digest.rst:128
msgid "Get a 32-bit checksum made with CRC32"
msgstr "Получение 32-битной контрольной суммы с помощью CRC32"

#: ../doc/1.10/reference/reference_lua/digest.rst:131
msgid ":ref:`digest.crc32.new() <digest-crc32_new>`"
msgstr ":ref:`digest.crc32.new() <digest-crc32_new>`"

#: ../doc/1.10/reference/reference_lua/digest.rst:131
msgid "Initiate incremental CRC32"
msgstr "Запуск инкрементного вычисления CRC32"

#: ../doc/1.10/reference/reference_lua/digest.rst:134
msgid ":ref:`digest.guava() <digest-guava>`"
msgstr ":ref:`digest.guava() <digest-guava>`"

#: ../doc/1.10/reference/reference_lua/digest.rst:134
msgid "Get a number made with a consistent hash"
msgstr "Получение числа с помощью консистентного хеширования"

#: ../doc/1.10/reference/reference_lua/digest.rst:137
msgid ":ref:`digest.murmur() <digest-murmur>`"
msgstr ":ref:`digest.murmur() <digest-murmur>`"

#: ../doc/1.10/reference/reference_lua/digest.rst:137
msgid "Get a digest made with MurmurHash"
msgstr "Получение дайджеста с помощью MurmurHash"

#: ../doc/1.10/reference/reference_lua/digest.rst:140
msgid ":ref:`digest.murmur.new() <digest-murmur_new>`"
msgstr ":ref:`digest.murmur.new() <digest-murmur_new>`"

#: ../doc/1.10/reference/reference_lua/digest.rst:140
msgid "Initiate incremental MurmurHash"
msgstr "Запуск инкрементного вычисления с помощью MurmurHash"

#: ../doc/1.10/reference/reference_lua/digest.rst:149
msgid "Returns 256-bit binary string = digest made with AES."
msgstr "Возврат 256-битной двоичной строки = дайджест, полученный с помощью AES."

#: ../doc/1.10/reference/reference_lua/digest.rst:155
msgid "Returns 128-bit binary string = digest made with MD4."
msgstr "Возврат 128-битной двоичной строки = дайджест, полученный с помощью MD4."

#: ../doc/1.10/reference/reference_lua/digest.rst:161
msgid "Returns 32-byte string = hexadecimal of a digest calculated with md4."
msgstr ""
"Возврат 32-байтной строки = шестнадцатеричное значение дайджеста, "
"вычисленного с помощью MD4."

#: ../doc/1.10/reference/reference_lua/digest.rst:167
msgid "Returns 128-bit binary string = digest made with MD5."
msgstr "Возврат 128-битной двоичной строки = дайджест, полученный с помощью MD5."

#: ../doc/1.10/reference/reference_lua/digest.rst:173
msgid "Returns 32-byte string = hexadecimal of a digest calculated with md5."
msgstr ""
"Возврат 32-байтной строки = шестнадцатеричное значение дайджеста, "
"вычисленного с помощью MD5."

#: ../doc/1.10/reference/reference_lua/digest.rst:179
msgid ""
"Returns binary string = digest made with PBKDF2. |br| For effective "
"encryption the ``iterations`` value should be at least several thousand. "
"The ``digest-length`` value determines the length of the resulting binary"
" string."
msgstr ""
"Возврат двоичной строки = дайджест, полученный с помощью PBKDF2. |br| Для"
" эффективности шифрования значение параметра количества итераций "
"``iterations`` должно быть как минимум несколько тысяч. Значение "
"параметра ``digest-length`` определяет длину полученной двоичной строки."

#: ../doc/1.10/reference/reference_lua/digest.rst:188
msgid "Returns 160-bit binary string = digest made with SHA-1."
msgstr "Возврат 160-битной двоичной строки = дайджест, полученный с помощью SHA-1."

#: ../doc/1.10/reference/reference_lua/digest.rst:194
msgid "Returns 40-byte string = hexadecimal of a digest calculated with sha1."
msgstr ""
"Возврат 40-байтной строки = шестнадцатеричное значение дайджеста, "
"вычисленного с помощью SHA-1."

#: ../doc/1.10/reference/reference_lua/digest.rst:200
msgid "Returns 224-bit binary string = digest made with SHA-2."
msgstr "Возврат 224-битной двоичной строки = дайджест, полученный с помощью SHA-2."

#: ../doc/1.10/reference/reference_lua/digest.rst:206
msgid "Returns 56-byte string = hexadecimal of a digest calculated with sha224."
msgstr ""
"Возврат 56-байтной строки = шестнадцатеричное значение дайджеста, "
"вычисленного с помощью SHA-224."

#: ../doc/1.10/reference/reference_lua/digest.rst:212
msgid "Returns 256-bit binary string =  digest made with SHA-2."
msgstr "Возврат 256-битной двоичной строки = дайджест, полученный с помощью SHA-2."

#: ../doc/1.10/reference/reference_lua/digest.rst:218
msgid "Returns 64-byte string = hexadecimal of a digest calculated with sha256."
msgstr ""
"Возврат 64-байтной строки = шестнадцатеричное значение дайджеста, "
"вычисленного с помощью SHA-256."

#: ../doc/1.10/reference/reference_lua/digest.rst:224
msgid "Returns 384-bit binary string =  digest made with SHA-2."
msgstr "Возврат 384-битной двоичной строки = дайджест, полученный с помощью SHA-2."

#: ../doc/1.10/reference/reference_lua/digest.rst:230
msgid "Returns 96-byte string = hexadecimal of a digest calculated with sha384."
msgstr ""
"Возврат 96-байтной строки = шестнадцатеричное значение дайджеста, "
"вычисленного с помощью SHA-384."

#: ../doc/1.10/reference/reference_lua/digest.rst:236
msgid "Returns 512-bit binary tring = digest made with SHA-2."
msgstr "Возврат 512-битной двоичной строки = дайджест, полученный с помощью SHA-2."

#: ../doc/1.10/reference/reference_lua/digest.rst:242
msgid "Returns 128-byte string = hexadecimal of a digest calculated with sha512."
msgstr ""
"Возврат 128-байтной строки = шестнадцатеричное значение дайджеста, "
"вычисленного с помощью SHA-512."

#: ../doc/1.10/reference/reference_lua/digest.rst:248
msgid "Returns base64 encoding from a regular string."
msgstr "Возврат кодированного по base64 значения обычной строки."

#: ../doc/1.10/reference/reference_lua/digest.rst:252
msgid "``nopad`` -- result must not include '=' for padding at the end,"
msgstr ""
"``nopad`` -- результат не должен включать в себя '=' для заполнения "
"символами в конце,"

#: ../doc/1.10/reference/reference_lua/digest.rst:253
msgid ""
"``nowrap`` -- result must not include line feed for splitting lines after"
" 72 characters,"
msgstr ""
"``nowrap`` -- результат не должен включать в себя символ переноса строки "
"для разделения строк после 72 символов,"

#: ../doc/1.10/reference/reference_lua/digest.rst:255
msgid ""
"``urlsafe`` -- result must not include '=' or line feed, and may contain "
"'-' or '_' instead of '+' or '/' for positions 62 and 63 in the index "
"table."
msgstr ""
"``urlsafe`` -- результат не должен включать в себя '=' или символ "
"переноса строки и может содержать '-' или '_' взамен '+' или '/' в "
"качестве 62 и 63 символа в схеме."

#: ../doc/1.10/reference/reference_lua/digest.rst:259
msgid "Options may be ``true`` or ``false``, the default value is ``false``."
msgstr ""
"Значения параметров могут быть ``true`` (правда) или ``false`` (ложь), по"
" умолчанию используется ``false``."

#: ../doc/1.10/reference/reference_lua/digest.rst:263
msgid "digest.base64_encode(string_variable,{nopad=true})"
msgstr "digest.base64_encode(string_variable,{nopad=true})"

#: ../doc/1.10/reference/reference_lua/digest.rst:271
msgid "Returns a regular string from a base64 encoding."
msgstr "Возврат обычной строки из кодированного по base64 значения."

#: ../doc/1.10/reference/reference_lua/digest.rst:277
msgid "Returns array of random bytes with length = integer."
msgstr "Возврат массива случайных байтов с длиной = целому числу."

#: ../doc/1.10/reference/reference_lua/digest.rst:283
msgid "Returns 32-bit checksum made with CRC32."
msgstr "Возврат 32-битной контрольной суммы с помощью CRC32."

#: ../doc/1.10/reference/reference_lua/digest.rst:285
msgid ""
"The ``crc32`` and ``crc32_update`` functions use the `Cyclic Redundancy "
"Check`_ polynomial value: ``0x1EDC6F41`` / ``4812730177``. (Other "
"settings are: input = reflected, output = reflected, initial value = "
"0xFFFFFFFF, final xor value = 0x0.) If it is necessary to be compatible "
"with other checksum functions in other programming languages, ensure that"
" the other functions use the same polynomial value."
msgstr ""
"Функции ``crc32`` и ``crc32_update`` используют значение многочлена "
"`Cyclic Redundancy Check`_ : ``0x1EDC6F41`` / ``4812730177``. (Другие "
"используемые значения: ввод = отраженное значение, вывод = отраженное "
"значение, начальное значение = 0xFFFFFFFF, финальное xor-значение = 0x0.)"
" Если необходима совместимость с другими функциями контрольной суммы на "
"другом языке программирования, убедитесь, что другие функции используют "
"то же значение многочлена."

#: ../doc/1.10/reference/reference_lua/digest.rst:292
msgid "For example, in Python, install the ``crcmod`` package and say:"
msgstr "Например, в Python установите пакет ``crcmod`` и введите команду:"

#: ../doc/1.10/reference/reference_lua/digest.rst:294
msgid ""
">>> import crcmod\n"
">>> fun = crcmod.mkCrcFun('4812730177')\n"
">>> fun('string')\n"
"3304160206L"
msgstr ""
">>> import crcmod\n"
">>> fun = crcmod.mkCrcFun('4812730177')\n"
">>> fun('string')\n"
"3304160206L"

#: ../doc/1.10/reference/reference_lua/digest.rst:301
msgid "In Perl, install the ``Digest::CRC`` module and run the following code:"
msgstr "В Perl установите модуль ``Digest::CRC`` и выполните следующий код:"

#: ../doc/1.10/reference/reference_lua/digest.rst:303
msgid ""
"use Digest::CRC;\n"
"$d = Digest::CRC->new(width => 32, poly => 0x1EDC6F41, init => "
"0xFFFFFFFF, refin => 1, refout => 1);\n"
"$d->add('string');\n"
"print $d->digest;"
msgstr ""
"use Digest::CRC;\n"
"$d = Digest::CRC->new(width => 32, poly => 0x1EDC6F41, init => "
"0xFFFFFFFF, refin => 1, refout => 1);\n"
"$d->add('string');\n"
"print $d->digest;"

#: ../doc/1.10/reference/reference_lua/digest.rst:310
msgid "(the expected output is 3304160206)."
msgstr "(ожидается выходное значение: 3304160206)."

#: ../doc/1.10/reference/reference_lua/digest.rst:316
msgid ""
"Initiates incremental crc32. See :ref:`incremental methods <digest-"
"incremental_digests>` notes."
msgstr ""
"Запуск инкрементного вычисления CRC32. См. примечания по "
":ref:`инкрементным методам <digest-incremental_digests>`."

#: ../doc/1.10/reference/reference_lua/digest.rst:323
msgid "Returns a number made with consistent hash."
msgstr "Возврат числа с помощью консистентного хеширования."

#: ../doc/1.10/reference/reference_lua/digest.rst:325
msgid ""
"The guava function uses the `Consistent Hashing`_ algorithm of the Google"
" guava library. The first parameter should be a hash code; the second "
"parameter should be the number of buckets; the returned value will be an "
"integer between 0 and the number of buckets. For example,"
msgstr ""
"Функция guava использует алгоритм консистентного хеширование (`Consistent"
" Hashing`_) из библиотеки guava от Google. Первым параметром должен быть "
"хеш-код; вторым параметром должно быть число слотов; возвращается "
"значение в виде целого числа в диапазоне от 0 до указанного числа слотов."
" Например,"

#: ../doc/1.10/reference/reference_lua/digest.rst:330
msgid ""
"tarantool> digest.guava(10863919174838991, 11)\n"
"---\n"
"- 8\n"
"..."
msgstr ""
"tarantool> digest.guava(10863919174838991, 11)\n"
"---\n"
"- 8\n"
"..."

#: ../doc/1.10/reference/reference_lua/digest.rst:341
msgid "Returns 32-bit binary string = digest made with MurmurHash."
msgstr ""
"Возврат 32-битной двоичной строки = дайджест, полученный с помощью "
"MurmurHash."

#: ../doc/1.10/reference/reference_lua/digest.rst:347
msgid ""
"Initiates incremental MurmurHash. See :ref:`incremental methods <digest-"
"incremental_digests>` notes. For example:"
msgstr ""
"Запуск инкрементного вычисления с помощью MurmurHash. См. примечания по "
":ref:`инкрементным методам <digest-incremental_digests>`. Например:"

#: ../doc/1.10/reference/reference_lua/digest.rst:351
msgid "murmur.new({seed=0})"
msgstr "murmur.new({seed=0})"

#: ../doc/1.10/reference/reference_lua/digest.rst:359
msgid "Incremental methods in the ``digest`` module"
msgstr "Инкрементальные методы в модуле ``digest``"

#: ../doc/1.10/reference/reference_lua/digest.rst:361
msgid ""
"Suppose that a digest is done for a string 'A', then a new part 'B' is "
"appended to the string, then a new digest is required. The new digest "
"could be recomputed for the whole string 'AB', but it is faster to take "
"what was computed before for 'A' and apply changes based on the new part "
"'B'. This is called multi-step or \"incremental\" digesting, which "
"Tarantool supports with crc32 and with murmur..."
msgstr ""
"Предположим, что вычислен дайджест для строки 'A', затем часть 'B' "
"добавляется в строку, необходим новый дайджест. Новый дайджест можно "
"пересчитать для всей строки 'AB', но быстрее будет взять вычисленный "
"дайджест для 'A' и внести изменения на основании добавленной части 'B'. "
"Это называется многошаговым процессом или \"инкрементным\" "
"хеш-суммированием, которое поддерживает Tarantool поддерживает для crc32 "
"и murmur..."

#: ../doc/1.10/reference/reference_lua/digest.rst:367
msgid ""
"digest = require('digest')\n"
"\n"
"-- print crc32 of 'AB', with one step, then incrementally\n"
"print(digest.crc32('AB'))\n"
"c = digest.crc32.new()\n"
"c:update('A')\n"
"c:update('B')\n"
"print(c:result())\n"
"\n"
"-- print murmur hash of 'AB', with one step, then incrementally\n"
"print(digest.murmur('AB'))\n"
"m = digest.murmur.new()\n"
"m:update('A')\n"
"m:update('B')\n"
"print(m:result())"
msgstr ""
"digest = require('digest')\n"
"\n"
"-- вывести дайджест 'AB' по crc32 пошагово, затем с инкрементом\n"
"print(digest.crc32('AB'))\n"
"c = digest.crc32.new()\n"
"c:update('A')\n"
"c:update('B')\n"
"print(c:result())\n"
"\n"
"-- вывести дайджест 'AB' по murmur hash пошагово, затем с инкрементом\n"
"print(digest.murmur('AB'))\n"
"m = digest.murmur.new()\n"
"m:update('A')\n"
"m:update('B')\n"
"print(m:result())"

#: ../doc/1.10/reference/reference_lua/digest.rst:389
msgid ""
"In the following example, the user creates two functions, "
"``password_insert()`` which inserts a SHA-1_ digest of the word "
"\"**^S^e^c^ret Wordpass**\" into a tuple set, and ``password_check()`` "
"which requires input of a password."
msgstr ""
"В следующем примере пользователь создает две функции: функцию "
"``password_insert()``, которая вставляет дайджест слова \"**^S^e^c^ret "
"Wordpass**\" по SHA-1_ в набор кортежей, и функцию ``password_check()``, "
"которая требует ввод пароля."

#: ../doc/1.10/reference/reference_lua/digest.rst:393
msgid ""
"tarantool> digest = require('digest')\n"
"---\n"
"...\n"
"tarantool> function password_insert()\n"
"         >   box.space.tester:insert{1234, digest.sha1('^S^e^c^ret "
"Wordpass')}\n"
"         >   return 'OK'\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> function password_check(password)\n"
"         >   local t = box.space.tester:select{12345}\n"
"         >   if digest.sha1(password) == t[2] then\n"
"         >     return 'Password is valid'\n"
"         >   else\n"
"         >     return 'Password is not valid'\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> password_insert()\n"
"---\n"
"- 'OK'\n"
"..."
msgstr ""
"tarantool> digest = require('digest')\n"
"---\n"
"...\n"
"tarantool> function password_insert()\n"
"         >   box.space.tester:insert{1234, digest.sha1('^S^e^c^ret "
"Wordpass')}\n"
"         >   return 'OK'\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> function password_check(password)\n"
"         >   local t = box.space.tester:select{12345}\n"
"         >   if digest.sha1(password) == t[2] then\n"
"         >     return 'Password is valid'\n"
"         >   else\n"
"         >     return 'Password is not valid'\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> password_insert()\n"
"---\n"
"- 'OK'\n"
"..."

#: ../doc/1.10/reference/reference_lua/digest.rst:419
msgid ""
"If a later user calls the ``password_check()`` function and enters the "
"wrong password, the result is an error."
msgstr ""
"Если затем пользователь вызовет функцию ``password_check()`` и вводит "
"неверный пароль, результатом будет ошибка."

#: ../doc/1.10/reference/reference_lua/digest.rst:422
msgid ""
"tarantool> password_check('Secret Password')\n"
"---\n"
"- 'Password is not valid'\n"
"..."
msgstr ""
"tarantool> password_check('Secret Password')\n"
"---\n"
"- 'Password is not valid'\n"
"..."

#: ../doc/1.10/reference/reference_lua/errcodes.rst:39
msgid "Database error codes"
msgstr "Коды ошибок базы данных"

#: ../doc/1.10/reference/reference_lua/errcodes.rst:41
msgid ""
"In the current version of the binary protocol, error messages, which are "
"normally more descriptive than error codes, are not present in server "
"responses. The actual message may contain a file name, a detailed reason "
"or operating system error code. All such messages, however, are logged in"
" the error log. Below are general descriptions of some popular codes. A "
"complete list of errors can be found in file `errcode.h`_ in the source "
"tree."
msgstr ""
"В текущей версии бинарного протокола в ответы сервера не включены "
"сообщения об ошибках, которые как правило, содержат больше информации, "
"чем коды ошибок. Само сообщение может содержать имя файла, подробное "
"описание причины или код ошибки операционной системы. Однако все такие "
"сообщения регистрируются в журнале ошибок. Ниже приведены общие описания "
"некоторых распространенных кодов. Полный список ошибок можно найти в "
"файле `errcode.h`_ в исходном дереве."

#: ../doc/1.10/reference/reference_lua/errcodes.rst:52
msgid "**List of error codes**"
msgstr "**Список кодов ошибок**"

#: ../doc/1.10/reference/reference_lua/errcodes.rst:60
msgid "ER_NONMASTER"
msgstr "ER_NONMASTER"

#: ../doc/1.10/reference/reference_lua/errcodes.rst:60
msgid ""
"(In replication) A server instance cannot modify data unless it is a "
"master."
msgstr ""
"(Репликация) Экземпляр сервера не может вносить изменения в данные, если "
"он не является мастером."

#: ../doc/1.10/reference/reference_lua/errcodes.rst:63
msgid "ER_ILLEGAL_PARAMS"
msgstr "ER_ILLEGAL_PARAMS"

#: ../doc/1.10/reference/reference_lua/errcodes.rst:63
msgid "Illegal parameters. Malformed protocol message."
msgstr "Недопустимые параметры. Некорректное протокольное сообщение."

#: ../doc/1.10/reference/reference_lua/errcodes.rst:66
msgid "ER_MEMORY_ISSUE"
msgstr "ER_MEMORY_ISSUE"

#: ../doc/1.10/reference/reference_lua/errcodes.rst:66
msgid ""
"Out of memory: :ref:`memtx_memory <cfg_storage-memtx_memory>` limit has "
"been reached."
msgstr ""
"Нехватка оперативной памяти: достижение предела памяти :ref:`memtx_memory"
" <cfg_storage-memtx_memory>`."

#: ../doc/1.10/reference/reference_lua/errcodes.rst:70
msgid "ER_WAL_IO"
msgstr "ER_WAL_IO"

#: ../doc/1.10/reference/reference_lua/errcodes.rst:70
msgid ""
"Failed to write to disk. May mean: failed to record a change in the "
"write-ahead log. Some sort of disk error."
msgstr ""
"Запись на диск не удалась. Может означать, что не удалось записать "
"изменение в журнале упреждающей записи. Некоторая ошибка на диске."

#: ../doc/1.10/reference/reference_lua/errcodes.rst:74
msgid "ER_KEY_PART_COUNT"
msgstr "ER_KEY_PART_COUNT"

#: ../doc/1.10/reference/reference_lua/errcodes.rst:74
msgid "Key part count is not the same as index part count"
msgstr "Количество частей ключа не совпадает с количеством частей индекса"

#: ../doc/1.10/reference/reference_lua/errcodes.rst:77
msgid "ER_NO_SUCH_SPACE"
msgstr "ER_NO_SUCH_SPACE"

#: ../doc/1.10/reference/reference_lua/errcodes.rst:77
msgid "The specified space does not exist."
msgstr "Указанный спейс отсутствует."

#: ../doc/1.10/reference/reference_lua/errcodes.rst:80
msgid "ER_NO_SUCH_INDEX"
msgstr "ER_NO_SUCH_INDEX"

#: ../doc/1.10/reference/reference_lua/errcodes.rst:80
msgid "The specified index in the specified space does not exist."
msgstr "Указанного индекса нет в указанном спейсе."

#: ../doc/1.10/reference/reference_lua/errcodes.rst:83
msgid "ER_PROC_LUA"
msgstr "ER_PROC_LUA"

#: ../doc/1.10/reference/reference_lua/errcodes.rst:83
msgid "An error occurred inside a Lua procedure."
msgstr "Возникла ошибке в Lua-процедуре."

#: ../doc/1.10/reference/reference_lua/errcodes.rst:86
msgid "ER_FIBER_STACK"
msgstr "ER_FIBER_STACK"

#: ../doc/1.10/reference/reference_lua/errcodes.rst:86
msgid ""
"The recursion limit was reached when creating a new fiber. This usually "
"indicates that a stored procedure is recursively invoking itself too "
"often."
msgstr ""
"При создании нового файбера был достигнут предел рекурсии. Обычно это "
"указывает на то, что хранимая процедура слишком часто рекурсивно вызывает"
" себя."

#: ../doc/1.10/reference/reference_lua/errcodes.rst:91
msgid "ER_UPDATE_FIELD"
msgstr "ER_UPDATE_FIELD"

#: ../doc/1.10/reference/reference_lua/errcodes.rst:91
msgid "An error occurred during update of a field."
msgstr "Возникла ошибка во время обновления поля."

#: ../doc/1.10/reference/reference_lua/errcodes.rst:94
msgid "ER_TUPLE_FOUND"
msgstr "ER_TUPLE_FOUND"

#: ../doc/1.10/reference/reference_lua/errcodes.rst:94
msgid "A duplicate key exists in a unique index."
msgstr "В уникальном индексе есть повторяющийся ключ."

#: ../doc/1.10/reference/reference_lua/errcodes.rst:102
msgid "Handling errors"
msgstr "Обработка ошибок"

#: ../doc/1.10/reference/reference_lua/errcodes.rst:104
msgid ""
"Here are some procedures that can make Lua functions more robust when "
"there are errors, particularly database errors."
msgstr ""
"Ниже представлены несколько процедур для более надежного вызова "
"Lua-функций в случае ошибок, в частности, ошибок базы данных."

#: ../doc/1.10/reference/reference_lua/errcodes.rst:107
msgid "Invoke with pcall."
msgstr "Вызов с помощью pcall."

#: ../doc/1.10/reference/reference_lua/errcodes.rst
msgid ""
"Take advantage of Lua's mechanisms for `\"Error handling and exceptions\""
" <http://www.lua.org/pil/8.4.html>`_, particularly ``pcall``. That is, "
"instead of simply invoking with"
msgstr ""
"Используйте механизмы Lua для `\"Обработки ошибок и исключений\" "
"<http://www.lua.org/pil/8.4.html>`_, в частности ``pcall``. То есть "
"вместо простого вызова функции с помощью"

#: ../doc/1.10/reference/reference_lua/errcodes.rst
msgid ":samp:`box.space.{space-name}:{function-name}()`"
msgstr ":samp:`box.space.{имя-спейса}:{имя-функции}()`"

#: ../doc/1.10/reference/reference_lua/errcodes.rst
msgid "say"
msgstr "выполните"

#: ../doc/1.10/reference/reference_lua/errcodes.rst
msgid ""
":samp:`if pcall(box.space.{space-name}.{function-name}, box.space.{space-"
"name}) ...`"
msgstr ""
":samp:`if pcall(box.space.{имя-спейса}.{имя-функции}, "
"box.space.{имя-спейса}) ...`"

#: ../doc/1.10/reference/reference_lua/errcodes.rst
msgid ""
"For some Tarantool box functions, pcall also returns error details "
"including a file-name and line-number within Tarantool's source code. "
"This can be seen by unpacking. For example:"
msgstr ""
"Для некоторых функций модуля box в Tarantool'е pcall также вернет "
"описание ошибки, включая имя файла и номер строки в исходном коде "
"Tarantool'а. Например:"

#: ../doc/1.10/reference/reference_lua/errcodes.rst
msgid "``x, y = pcall(function() box.schema.space.create('') end)``"
msgstr "``x, y = pcall(function() box.schema.space.create('') end)``"

#: ../doc/1.10/reference/reference_lua/errcodes.rst
msgid "``y:unpack()``"
msgstr "``y:unpack()``"

#: ../doc/1.10/reference/reference_lua/errcodes.rst:122
msgid ""
"See the tutorial :ref:`Sum a JSON field for all tuples <c_lua_tutorial-"
"sum_a_json_field>` to see how pcall can fit in an application."
msgstr ""
"Чтобы увидеть применение pcall в приложении, см. практическое задание "
":ref:`Подсчет суммы по JSON-полям во всех кортежах <c_lua_tutorial-"
"sum_a_json_field>`."

#: ../doc/1.10/reference/reference_lua/errcodes.rst:125
msgid "Examine and raise with box.error."
msgstr "Проверка и вызов ошибки с помощью box.error."

#: ../doc/1.10/reference/reference_lua/errcodes.rst:127
msgid ""
"To make a new error and pass it on, the box.error module provides "
":ref:`box.error(code, errtext [, errtext ...]) <box_error-error>`."
msgstr ""
"В модуле box.error предусмотрена функция :ref:`box.error(code, errtext [,"
" errtext ...]) <box_error-error>`, чтобы создать ошибку и передать ее."

#: ../doc/1.10/reference/reference_lua/errcodes.rst:130
msgid ""
"To find the last error, the box.error module provides "
":ref:`box.error.last() <box_error-last>`. (There is also a way to find "
"the text of the last operating-system error for certain functions -- "
":ref:`errno.strerror([code]) <errno-strerror>`.)"
msgstr ""
"Чтобы найти последнюю ошибку, в модуле box.error предусмотрена функция "
":ref:`box.error.last() <box_error-last>`. (Также можно найти текст "
"последней ошибки операционной системы для определенной функции -- "
":ref:`errno.strerror([code]) <errno-strerror>`.)"

#: ../doc/1.10/reference/reference_lua/errcodes.rst:135
msgid "Log."
msgstr "Запись в журнал."

#: ../doc/1.10/reference/reference_lua/errcodes.rst:137
msgid "Put messages in a log using the :ref:`log module <log-module>`."
msgstr "Записывайте сообщения в журнал с помощью :ref:`модуля log <log-module>`."

#: ../doc/1.10/reference/reference_lua/errcodes.rst:139
msgid ""
"And filter messages that are automatically generated, with the :ref:`log "
"<cfg_logging-log>` configuration parameter."
msgstr ""
"И отфильтровывайте автоматически созданные сообщения с помощью "
"конфигурационного параметра :ref:`log <cfg_logging-log>`."

#: ../doc/1.10/reference/reference_lua/errcodes.rst:143
msgid ""
"Generally, for Tarantool built-in functions which are designed to return "
"objects: the result will be an object, or nil, or `a Lua error "
"<https://www.lua.org/pil/8.3.html>`_. For example consider the "
":ref:`fio_read.lua <cookbook-fio_read>` program in our cookbook:"
msgstr ""
"Как правило, встроенные функции Tarantool'а, которые предназначены для "
"возврата объектов, вернут либо объект, либо нулевое значение nil, либо "
"`Lua-ошибку <https://www.lua.org/pil/8.3.html>`_. Например, рассмотрим "
"программу :ref:`fio_read.lua <cookbook-fio_read>` из рекомендаций по "
"разработке:"

#: ../doc/1.10/reference/reference_lua/errcodes.rst:161
msgid ""
"After a function call that might fail, like fio.open() above, it is "
"common to see syntax like ``if not f then ...`` or ``if f == nil then "
"...``, which check for common failures. But if there had been a syntax "
"error, for example fio.opex instead of fio.open, then there would have "
"been a Lua error and f would not have been changed. If checking for such "
"an obvious error had been a concern, the programmer would probably have "
"used pcall()."
msgstr ""
"После вызова функции, который может не сработать, как fio.open() выше, "
"обычно можно увидеть такой синтаксис, как ``if not f then ...`` или ``if "
"f == nil then ...``, который проверяет на типичные отказы. Но если есть "
"ошибка синтаксиса, например, fio.opex вместо fio.open, то появится "
"Lua-ошибка, и f не изменится. Если речь идет о проверке таких очевидных "
"ошибок, программист вероятно будет использовать pcall()."

#: ../doc/1.10/reference/reference_lua/errcodes.rst:171
msgid ""
"All functions in Tarantool modules should work this way, unless the "
"manual explicitly says otherwise."
msgstr ""
"Все функции в модулях Tarantool'а должны работать таким образом, если в "
"руководстве явно не говорится об обратном."

#: ../doc/1.10/reference/reference_lua/errno.rst:39
msgid "Module `errno`"
msgstr "Модуль `errno`"

#: ../doc/1.10/reference/reference_lua/errno.rst:47
msgid ""
"The ``errno`` module is typically used within a function or within a Lua "
"program, in association with a module whose functions can return "
"operating-system errors, such as :ref:`fio <fio-module>`."
msgstr ""
"Модуль ``errno``, как правило, используется внутри функции или в рамках "
"Lua-программы совместно с модулем, функции которого могут возвращать "
"ошибки ОС, например :ref:`fio <fio-module>`."

#: ../doc/1.10/reference/reference_lua/errno.rst:55
msgid "Below is a list of all ``errno`` functions."
msgstr "Ниже приведен перечень всех функций модуля ``errno``."

#: ../doc/1.10/reference/reference_lua/errno.rst:65
msgid ":ref:`errno() <errno-errno>`"
msgstr ":ref:`errno() <errno-errno>`"

#: ../doc/1.10/reference/reference_lua/errno.rst:65
msgid "Get an error number for the last OS-related function"
msgstr "Получение номера ошибки для последней функции, связанной с ОС"

#: ../doc/1.10/reference/reference_lua/errno.rst:68
msgid ":ref:`errno.strerror() <errno-strerror>`"
msgstr ":ref:`errno.strerror() <errno-strerror>`"

#: ../doc/1.10/reference/reference_lua/errno.rst:68
msgid "Get an error message for the corresponding error number"
msgstr "Получение сообщения об ошибке для соответствующего номера ошибки"

#: ../doc/1.10/reference/reference_lua/errno.rst:76
msgid ""
"Return an error number for the last operating-system-related function, or"
" 0. To invoke it, simply say ``errno()``, without the module name."
msgstr ""
"Возврат номера ошибки для последней функции, связанной с операционной "
"системой, или 0. Чтобы вызвать функцию, просто введите команду "
"``errno()`` без названия модуля."

#: ../doc/1.10/reference/reference_lua/errno.rst:85
msgid ""
"Return a string, given an error number. The string will contain the text "
"of the conventional error message for the current operating system. If "
"``code`` is not supplied, the error message will be for the last "
"operating-system-related function, or 0."
msgstr ""
"Возврат строки в ответ на номер ошибки. Строка будет содержать текст "
"традиционного сообщения об ошибке для текущей операционной системы. Если "
"не указан код ``code``, то будет выведено сообщение об ошибке для "
"последней функции, связанной с операционной системой, или 0."

#: ../doc/1.10/reference/reference_lua/errno.rst:90
msgid "number of an operating-system error"
msgstr "номер ошибки в операционной системе"

#: ../doc/1.10/reference/reference_lua/errno.rst:96
msgid ""
"This function displays the result of a call to :ref:`fio.open() <fio-"
"open>` which causes error 2 (``errno.ENOENT``). The display includes the "
"error number, the associated error string, and the error name."
msgstr ""
"Данная функция отображает результат вызова :ref:`fio.open() <fio-open>`, "
"который вызывает ошибку 2 (``errno.ENOENT``). В результат включен номер "
"ошибки, связанная с ним строка сообщения об ошибке и название ошибки."

#: ../doc/1.10/reference/reference_lua/errno.rst:100
msgid ""
"tarantool> function f()\n"
"         >   local fio = require('fio')\n"
"         >   local errno = require('errno')\n"
"         >   fio.open('no_such_file')\n"
"         >   print('errno() = ' .. errno())\n"
"         >   print('errno.strerror() = ' .. errno.strerror())\n"
"         >   local t = getmetatable(errno).__index\n"
"         >   for k, v in pairs(t) do\n"
"         >     if v == errno() then\n"
"         >       print('errno() constant = ' .. k)\n"
"         >     end\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"\n"
"tarantool> f()\n"
"errno() = 2\n"
"errno.strerror() = No such file or directory\n"
"errno() constant = ENOENT\n"
"---\n"
"..."
msgstr ""
"tarantool> function f()\n"
"         >   local fio = require('fio')\n"
"         >   local errno = require('errno')\n"
"         >   fio.open('no_such_file')\n"
"         >   print('errno() = ' .. errno())\n"
"         >   print('errno.strerror() = ' .. errno.strerror())\n"
"         >   local t = getmetatable(errno).__index\n"
"         >   for k, v in pairs(t) do\n"
"         >     if v == errno() then\n"
"         >       print('errno() constant = ' .. k)\n"
"         >     end\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"\n"
"tarantool> f()\n"
"errno() = 2\n"
"errno.strerror() = No such file or directory\n"
"errno() constant = ENOENT\n"
"---\n"
"..."

#: ../doc/1.10/reference/reference_lua/errno.rst:125
msgid ""
"To see all possible error names stored in the ``errno`` metatable, say "
"``getmetatable(errno)`` (output abridged):"
msgstr ""
"Чтобы увидеть все возможные названия ошибок, которые хранятся в "
"метатаблице ``errno``, введите команду ``getmetatable(errno)`` (выводятся"
" сокращенно):"

#: ../doc/1.10/reference/reference_lua/errno.rst:128
msgid ""
"tarantool> getmetatable(errno)\n"
"---\n"
"- __newindex: 'function: 0x41666a38'\n"
"  __call: 'function: 0x41666890'\n"
"  __index:\n"
"  ENOLINK: 67\n"
"  EMSGSIZE: 90\n"
"  EOVERFLOW: 75\n"
"  ENOTCONN: 107\n"
"  EFAULT: 14\n"
"  EOPNOTSUPP: 95\n"
"  EEXIST: 17\n"
"  ENOSR: 63\n"
"  ENOTSOCK: 88\n"
"  EDESTADDRREQ: 89\n"
"  <...>\n"
"..."
msgstr ""
"tarantool> getmetatable(errno)\n"
"---\n"
"- __newindex: 'function: 0x41666a38'\n"
"  __call: 'function: 0x41666890'\n"
"  __index:\n"
"  ENOLINK: 67\n"
"  EMSGSIZE: 90\n"
"  EOVERFLOW: 75\n"
"  ENOTCONN: 107\n"
"  EFAULT: 14\n"
"  EOPNOTSUPP: 95\n"
"  EEXIST: 17\n"
"  ENOSR: 63\n"
"  ENOTSOCK: 88\n"
"  EDESTADDRREQ: 89\n"
"  <...>\n"
"..."

#: ../doc/1.10/reference/reference_lua/fiber.rst:45
msgid "With the ``fiber`` module, you can:"
msgstr "С помощью модуля ``fiber`` можно:"

#: ../doc/1.10/reference/reference_lua/fiber.rst:47
msgid "create, run and manage :ref:`fibers <fiber-fibers>`,"
msgstr "создавать, запускать и управлять :ref:`файберами <fiber-fibers>`,"

#: ../doc/1.10/reference/reference_lua/fiber.rst:48
msgid ""
"send and receive messages between different processes (i.e. different "
"connections, sessions, or fibers) via :ref:`channels <fiber_ipc-"
"channel>`, and"
msgstr ""
"отправлять и получать сообщения для различных процессов (например, разные"
" соединения, сессии или файберы) по :ref:`каналам <fiber_ipc-channel>`, а"
" также"

#: ../doc/1.10/reference/reference_lua/fiber.rst:50
msgid ""
"use a :ref:`synchronization mechanism <fiber_ipc-cond_var>` for fibers, "
"similar to \"condition variables\" and similar to operating-system "
"functions such as ``pthread_cond_wait()`` plus ``pthread_cond_signal()``."
msgstr ""
"использовать :ref:`механизм синхронизации <fiber_ipc-cond_var>` для "
"файберов, аналогично работе \"условных переменных\" и функций "
"операционных систем, таких как ``pthread_cond_wait()`` плюс "
"``pthread_cond_signal()``."

#: ../doc/1.10/reference/reference_lua/fiber.rst:58
msgid "Below is a list of all ``fiber`` functions and members."
msgstr "Ниже приведен перечень всех функций и элементов модуля ``fiber``."

#: ../doc/1.10/reference/reference_lua/fiber.rst:68
msgid ":ref:`fiber.create() <fiber-create>`"
msgstr ":ref:`fiber.create() <fiber-create>`"

#: ../doc/1.10/reference/reference_lua/fiber.rst:68
msgid "Create and start a fiber"
msgstr "Создание и запуск файбера"

#: ../doc/1.10/reference/reference_lua/fiber.rst:71
msgid ":ref:`fiber.new() <fiber-new>`"
msgstr ":ref:`fiber.new() <fiber-new>`"

#: ../doc/1.10/reference/reference_lua/fiber.rst:71
msgid "Create but do not start a fiber"
msgstr "Создание файбера без запуска"

#: ../doc/1.10/reference/reference_lua/fiber.rst:74
msgid ":ref:`fiber.self() <fiber-self>`"
msgstr ":ref:`fiber.self() <fiber-self>`"

#: ../doc/1.10/reference/reference_lua/fiber.rst:74
msgid "Get a fiber object"
msgstr "Получение объекта файбера"

#: ../doc/1.10/reference/reference_lua/fiber.rst:77
msgid ":ref:`fiber.find() <fiber-find>`"
msgstr ":ref:`fiber.find() <fiber-find>`"

#: ../doc/1.10/reference/reference_lua/fiber.rst:77
msgid "Get a fiber object by ID"
msgstr "Получение объекта файбера по ID"

#: ../doc/1.10/reference/reference_lua/fiber.rst:80
msgid ":ref:`fiber.sleep() <fiber-sleep>`"
msgstr ":ref:`fiber.sleep() <fiber-sleep>`"

#: ../doc/1.10/reference/reference_lua/fiber.rst:80
msgid "Make a fiber go to sleep"
msgstr "Перевод файбера в режим ожидания"

#: ../doc/1.10/reference/reference_lua/fiber.rst:83
msgid ":ref:`fiber.yield() <fiber-yield>`"
msgstr ":ref:`fiber.yield() <fiber-yield>`"

#: ../doc/1.10/reference/reference_lua/fiber.rst:83
msgid "Yield control"
msgstr "Передача управления"

#: ../doc/1.10/reference/reference_lua/fiber.rst:86
msgid ":ref:`fiber.status() <fiber-status>`"
msgstr ":ref:`fiber.status() <fiber-status>`"

#: ../doc/1.10/reference/reference_lua/fiber.rst:86
msgid "Get the current fiber's status"
msgstr "Получение статуса активного файбера"

#: ../doc/1.10/reference/reference_lua/fiber.rst:89
msgid ":ref:`fiber.info() <fiber-info>`"
msgstr ":ref:`fiber.info() <fiber-info>`"

#: ../doc/1.10/reference/reference_lua/fiber.rst:89
msgid "Get information about all fibers"
msgstr "Получение информации о всех файберах"

#: ../doc/1.10/reference/reference_lua/fiber.rst:92
msgid ":ref:`fiber.kill() <fiber-kill>`"
msgstr ":ref:`fiber.kill() <fiber-kill>`"

#: ../doc/1.10/reference/reference_lua/fiber.rst:92
#: ../doc/1.10/reference/reference_lua/fiber.rst:110
msgid "Cancel a fiber"
msgstr "Отмена файбера"

#: ../doc/1.10/reference/reference_lua/fiber.rst:95
msgid ":ref:`fiber.testcancel() <fiber-testcancel>`"
msgstr ":ref:`fiber.testcancel() <fiber-testcancel>`"

#: ../doc/1.10/reference/reference_lua/fiber.rst:95
msgid "Check if the current fiber has been cancelled"
msgstr "Проверка отмены действующего файбера"

#: ../doc/1.10/reference/reference_lua/fiber.rst:98
msgid ":ref:`fiber_object:id() <fiber_object-id>`"
msgstr ":ref:`fiber_object:id() <fiber_object-id>`"

#: ../doc/1.10/reference/reference_lua/fiber.rst:98
msgid "Get a fiber's ID"
msgstr "Получение ID файбера"

#: ../doc/1.10/reference/reference_lua/fiber.rst:101
msgid ":ref:`fiber_object:name() <fiber_object-name_get>`"
msgstr ":ref:`fiber_object:name() <fiber_object-name_get>`"

#: ../doc/1.10/reference/reference_lua/fiber.rst:101
msgid "Get a fiber's name"
msgstr "Получение имени файбера"

#: ../doc/1.10/reference/reference_lua/fiber.rst:104
msgid ":ref:`fiber_object:name(name) <fiber_object-name_set>`"
msgstr ":ref:`fiber_object:name(name) <fiber_object-name_set>`"

#: ../doc/1.10/reference/reference_lua/fiber.rst:104
msgid "Set a fiber's name"
msgstr "Назначение имени файбера"

#: ../doc/1.10/reference/reference_lua/fiber.rst:107
msgid ":ref:`fiber_object:status() <fiber_object-status>`"
msgstr ":ref:`fiber_object:status() <fiber_object-status>`"

#: ../doc/1.10/reference/reference_lua/fiber.rst:107
msgid "Get a fiber's status"
msgstr "Получение статуса файбера"

#: ../doc/1.10/reference/reference_lua/fiber.rst:110
msgid ":ref:`fiber_object:cancel() <fiber_object-cancel>`"
msgstr ":ref:`fiber_object:cancel() <fiber_object-cancel>`"

#: ../doc/1.10/reference/reference_lua/fiber.rst:113
msgid ":ref:`fiber_object.storage <fiber_object-storage>`"
msgstr ":ref:`fiber_object.storage <fiber_object-storage>`"

#: ../doc/1.10/reference/reference_lua/fiber.rst:113
msgid "Local storage within the fiber"
msgstr "Локальное хранилище в пределах файбера"

#: ../doc/1.10/reference/reference_lua/fiber.rst:116
msgid ":ref:`fiber_object:set_joinable() <fiber_object-set_joinable>`"
msgstr ":ref:`fiber_object:set_joinable() <fiber_object-set_joinable>`"

#: ../doc/1.10/reference/reference_lua/fiber.rst:116
msgid "Make it possible for a new fiber to join"
msgstr "Создание возможности подключения нового файбера"

#: ../doc/1.10/reference/reference_lua/fiber.rst:119
msgid ":ref:`fiber_object:join() <fiber_object-join>`"
msgstr ":ref:`fiber_object:join() <fiber_object-join>`"

#: ../doc/1.10/reference/reference_lua/fiber.rst:119
msgid "Wait for a fiber's state to become 'dead'"
msgstr "Ожидание статуса 'dead' (недоступен) для файбера"

#: ../doc/1.10/reference/reference_lua/fiber.rst:122
msgid ":ref:`fiber.time() <fiber-time>`"
msgstr ":ref:`fiber.time() <fiber-time>`"

#: ../doc/1.10/reference/reference_lua/fiber.rst:122
msgid "Get the system time in seconds"
msgstr "Получение системного времени в секундах"

#: ../doc/1.10/reference/reference_lua/fiber.rst:125
msgid ":ref:`fiber.time64() <fiber-time64>`"
msgstr ":ref:`fiber.time64() <fiber-time64>`"

#: ../doc/1.10/reference/reference_lua/fiber.rst:125
msgid "Get the system time in microseconds"
msgstr "Получение системного времени в микросекундах"

#: ../doc/1.10/reference/reference_lua/fiber.rst:128
msgid ":ref:`fiber.channel() <fiber-channel>`"
msgstr ":ref:`fiber.channel() <fiber-channel>`"

#: ../doc/1.10/reference/reference_lua/fiber.rst:128
msgid "Create a communication channel"
msgstr "Создание канала связи"

#: ../doc/1.10/reference/reference_lua/fiber.rst:131
msgid ":ref:`channel_object:put() <channel_object-put>`"
msgstr ":ref:`channel_object:put() <channel_object-put>`"

#: ../doc/1.10/reference/reference_lua/fiber.rst:131
msgid "Send a message via a channel"
msgstr "Отправка сообщения по каналу связи"

#: ../doc/1.10/reference/reference_lua/fiber.rst:134
msgid ":ref:`channel_object:close() <channel_object-close>`"
msgstr ":ref:`channel_object:close() <channel_object-close>`"

#: ../doc/1.10/reference/reference_lua/fiber.rst:134
msgid "Close a channel"
msgstr "Закрытие канала"

#: ../doc/1.10/reference/reference_lua/fiber.rst:137
msgid ":ref:`channel_object:get() <channel_object-get>`"
msgstr ":ref:`channel_object:get() <channel_object-get>`"

#: ../doc/1.10/reference/reference_lua/fiber.rst:137
msgid "Fetch a message from a channel"
msgstr "Перехват сообщения из канала"

#: ../doc/1.10/reference/reference_lua/fiber.rst:140
msgid ":ref:`channel_object:is_empty() <channel_object-is_empty>`"
msgstr ":ref:`channel_object:is_empty() <channel_object-is_empty>`"

#: ../doc/1.10/reference/reference_lua/fiber.rst:140
msgid "Check if a channel is empty"
msgstr "Проверка пустоты канала"

#: ../doc/1.10/reference/reference_lua/fiber.rst:143
msgid ":ref:`channel_object:count() <channel_object-count>`"
msgstr ":ref:`channel_object:count() <channel_object-count>`"

#: ../doc/1.10/reference/reference_lua/fiber.rst:143
msgid "Count messages in a channel"
msgstr "Подсчет сообщений в канале"

#: ../doc/1.10/reference/reference_lua/fiber.rst:146
msgid ":ref:`channel_object:is_full() <channel_object-is_full>`"
msgstr ":ref:`channel_object:is_full() <channel_object-is_full>`"

#: ../doc/1.10/reference/reference_lua/fiber.rst:146
msgid "Check if a channel is full"
msgstr "Проверка заполненности канала"

#: ../doc/1.10/reference/reference_lua/fiber.rst:149
msgid ":ref:`channel_object:has_readers() <channel_object-has_readers>`"
msgstr ":ref:`channel_object:has_readers() <channel_object-has_readers>`"

#: ../doc/1.10/reference/reference_lua/fiber.rst:149
msgid "Check if an empty channel has any readers waiting"
msgstr "Проверка пустого канала на наличие читателей в состоянии ожидания"

#: ../doc/1.10/reference/reference_lua/fiber.rst:152
msgid ":ref:`channel_object:has_writers() <channel_object-has_writers>`"
msgstr ":ref:`channel_object:has_writers() <channel_object-has_writers>`"

#: ../doc/1.10/reference/reference_lua/fiber.rst:152
msgid "Check if a full channel has any writers waiting"
msgstr "Проверка полного канала на наличие писателей в состоянии ожидания"

#: ../doc/1.10/reference/reference_lua/fiber.rst:155
msgid ":ref:`channel_object:is_closed() <channel_object-is_closed>`"
msgstr ":ref:`channel_object:is_closed() <channel_object-is_closed>`"

#: ../doc/1.10/reference/reference_lua/fiber.rst:155
msgid "Check if a channel is closed"
msgstr "Проверка закрытия канала"

#: ../doc/1.10/reference/reference_lua/fiber.rst:158
msgid ":ref:`fiber.cond() <fiber-cond>`"
msgstr ":ref:`fiber.cond() <fiber-cond>`"

#: ../doc/1.10/reference/reference_lua/fiber.rst:158
msgid "Create a condition variable"
msgstr "Создание условной переменной"

#: ../doc/1.10/reference/reference_lua/fiber.rst:161
msgid ":ref:`cond_object:wait() <cond_object-wait>`"
msgstr ":ref:`cond_object:wait() <cond_object-wait>`"

#: ../doc/1.10/reference/reference_lua/fiber.rst:161
msgid "Make a fiber go to sleep until woken by another fiber"
msgstr "Перевод файбера в режим ожидания до пробуждения другим файбером"

#: ../doc/1.10/reference/reference_lua/fiber.rst:164
msgid ":ref:`cond_object:signal() <cond_object-signal>`"
msgstr ":ref:`cond_object:signal() <cond_object-signal>`"

#: ../doc/1.10/reference/reference_lua/fiber.rst:164
msgid "Wake up a single fiber"
msgstr "Пробуждение отдельного файбера"

#: ../doc/1.10/reference/reference_lua/fiber.rst:167
msgid ":ref:`cond_object:broadcast() <cond_object-broadcast>`"
msgstr ":ref:`cond_object:broadcast() <cond_object-broadcast>`"

#: ../doc/1.10/reference/reference_lua/fiber.rst:167
msgid "Wake up all fibers"
msgstr "Пробуждение всех файберов"

#: ../doc/1.10/reference/reference_lua/fiber.rst:178
msgid ""
"A **fiber** is a set of instructions which are executed with cooperative "
"multitasking. Fibers managed by the fiber module are associated with a "
"user-supplied function called the *fiber function*."
msgstr ""
"**Файбер** -- это набор инструкций, которые выполняются по принципу "
"кооперативной многозадачности. Файберы, управление которых происходит с "
"помощью модуля fiber, связаны с функцией под названием *функция для "
"файбера*, которую задает пользователь."

#: ../doc/1.10/reference/reference_lua/fiber.rst:182
msgid ""
"A fiber has three possible states: **running**, **suspended** or "
"**dead**. When a fiber is created with :ref:`fiber.create() <fiber-"
"create>`, it is running. When a fiber is created with :ref:`fiber.new() "
"<fiber-new>` or yields control with :ref:`fiber.sleep() <fiber-sleep>`, "
"it is suspended. When a fiber ends (because the fiber function ends), it "
"is dead."
msgstr ""
"Существуют три возможных состояния файбера: **running** (активен), "
"**suspended** (приостановлен) или **dead** (недоступен). После создания "
"файбера с помощью :ref:`fiber.create() <fiber-create>` он сразу активен. "
"После создания файбера с помощью :ref:`fiber.new() <fiber-new>` или "
"передачи управления с помощью :ref:`fiber.sleep() <fiber-sleep>` файбер "
"будет приостановлен. По окончании работы (по причине окончания работы "
"соответствующей функции) файбер становится недоступен."

#: ../doc/1.10/reference/reference_lua/fiber.rst:188
msgid ""
"All fibers are part of the fiber registry. This registry can be searched "
"with :ref:`fiber.find() <fiber-find>` - via fiber id (fid), which is a "
"numeric identifier."
msgstr ""
"Все файберы составляют часть реестра файберов. Можно производить поиск по"
" реестру с помощью :ref:`fiber.find() <fiber-find>` по ID файбера (fid), "
"который представляет собой числовой идентификатор."

#: ../doc/1.10/reference/reference_lua/fiber.rst:192
msgid ""
"A runaway fiber can be stopped with :ref:`fiber_object.cancel "
"<fiber_object-cancel>`. However, :ref:`fiber_object.cancel <fiber_object-"
"cancel>` is advisory — it works only if the runaway fiber calls "
":ref:`fiber.testcancel() <fiber-testcancel>` occasionally. Most ``box.*``"
" functions, such as :ref:`box.space...delete() <box_space-delete>` or "
":ref:`box.space...update() <box_space-update>`, do call "
":ref:`fiber.testcancel() <fiber-testcancel>` but "
":ref:`box.space...select{} <box_space-select>` does not. In practice, a "
"runaway fiber can only become unresponsive if it does many computations "
"and does not check whether it has been cancelled."
msgstr ""
"Неконтролируемый файбер можно остановить с помощью "
":ref:`fiber_object.cancel <fiber_object-cancel>`. Однако, функция "
":ref:`fiber_object.cancel <fiber_object-cancel>` консультативна, то есть "
"сработает только в том случае, если неконтролируемый файбер случайно "
"вызовет :ref:`fiber.testcancel() <fiber-testcancel>`. Большинство функций"
" типа ``box.*``, например :ref:`box.space...delete() <box_space-delete>` "
"или :ref:`box.space...update() <box_space-update>`, действительно "
"вызывают :ref:`fiber.testcancel() <fiber-testcancel>`, а "
":ref:`box.space...select{} <box_space-select>` не вызовет. В "
"действительности неконтролируемый файбер может перестать отвечать, если "
"он производит большое количество вычислений и не проверяет вероятность "
"отмены."

#: ../doc/1.10/reference/reference_lua/fiber.rst:203
msgid ""
"The other potential problem comes from fibers which never get scheduled, "
"because they are not subscribed to any events, or because no relevant "
"events occur. Such morphing fibers can be killed with :ref:`fiber.kill() "
"<fiber-kill>` at any time, since :ref:`fiber.kill() <fiber-kill>` sends "
"an asynchronous wakeup event to the fiber, and :ref:`fiber.testcancel() "
"<fiber-testcancel>` is checked whenever such a wakeup event occurs."
msgstr ""
"Другой потенциальной проблемой могут стать файберы, которые не включаются"
" в расписание, поскольку они не подписаны ни на какие события, или потому"
" что соответствующие события не происходят. Такие файберы можно в любое "
"принудительно остановить с помощью :ref:`fiber.kill() <fiber-kill>`, "
"потому что функция :ref:`fiber.kill() <fiber-kill>` отправляет "
"асинхронное событие пробуждения на файбер, а :ref:`fiber.testcancel() "
"<fiber-testcancel>` проверяет наступление такого события пробуждения."

#: ../doc/1.10/reference/reference_lua/fiber.rst:210
msgid ""
"Like all Lua objects, dead fibers are garbage collected. The Lua garbage "
"collector frees pool allocator memory owned by the fiber, resets all "
"fiber data, and returns the fiber (now called a fiber carcass) to the "
"fiber pool. The carcass can be reused when another fiber is created."
msgstr ""
"Сборщик мусора собирает недоступные файберы так же, как и все "
"Lua-объекты: сборщик мусора в Lua освобождает память выделенного для "
"файбера пула, сбрасывает все данные файбера и возвращает файбер (который "
"теперь называется каркасом файбера) в пул файберов. Каркас можно "
"использовать повторно при создании другого файбера."

#: ../doc/1.10/reference/reference_lua/fiber.rst:215
msgid ""
"A fiber has all the features of a Lua coroutine_ and all the programming "
"concepts that apply for Lua coroutines will apply for fibers as well. "
"However, Tarantool has made some enhancements for fibers and has used "
"fibers internally. So, although use of coroutines is possible and "
"supported, use of fibers is recommended."
msgstr ""
"У файбера есть все возможности сопрограммы (coroutine_) на языке Lua, и "
"все принципы программирования, которые применяются к сопрограммам на Lua,"
" применимы и к файберам. Однако Tarantool расширил возможности файберов "
"для внутреннего использования. Поэтому, несмотря на возможность и "
"поддержку использования сопрограмм, рекомендуется использовать файберы."

#: ../doc/1.10/reference/reference_lua/fiber.rst:227
msgid ""
"Create and start a fiber. The fiber is created and begins to run "
"immediately."
msgstr ""
"Создание и запуск файбера. Происходит создание файбера, который "
"незамедлительно начинает работу."

#: ../doc/1.10/reference/reference_lua/fiber.rst:229
#: ../doc/1.10/reference/reference_lua/fiber.rst:268
msgid "the function to be associated with the fiber"
msgstr "функция, которая будет связана с файбером"

#: ../doc/1.10/reference/reference_lua/fiber.rst
#: ../doc/1.10/reference/reference_lua/string.rst
#: ../doc/1.10/reference/reference_lua/table.rst
#: ../doc/1.10/reference/reference_rock/vshard/index.rst
msgid "Return"
msgstr "Возвращается"

#: ../doc/1.10/reference/reference_lua/fiber.rst:232
#: ../doc/1.10/reference/reference_lua/fiber.rst:271
msgid "created fiber object"
msgstr "созданный объект файбера"

#: ../doc/1.10/reference/reference_lua/fiber.rst
#: ../doc/1.10/reference/reference_lua/string.rst
#: ../doc/1.10/reference/reference_lua/table.rst
#: ../doc/1.10/reference/reference_rock/vshard/index.rst
msgid "Rtype"
msgstr "Тип возвращаемого значения"

#: ../doc/1.10/reference/reference_lua/fiber.rst:237
msgid ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function function_name()\n"
"         >   fiber.sleep(1000)\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> fiber_object = fiber.create(function_name)\n"
"---\n"
"..."
msgstr ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function function_name()\n"
"         >   fiber.sleep(1000)\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> fiber_object = fiber.create(function_name)\n"
"---\n"
"..."

#: ../doc/1.10/reference/reference_lua/fiber.rst:255
msgid ""
"Create but do not start a fiber: the fiber is created but does not begin "
"to run immediately -- it starts after the fiber creator (that is, the job"
" that is calling ``fiber.new()``) yields, under :ref:`transaction control"
" <atomic-atomic_execution>`. The initial fiber state is 'suspended'. Thus"
" ``fiber.new()`` differs slightly from :ref:`fiber.create() <fiber-"
"create>`."
msgstr ""
"Создание файбера без запуска: файбер создается, но не запускается сразу "
"же, а ожидает, пока создатель файбера (то есть задача, которая вызывает "
"``fiber.new()``) не передаст управление согласно правилам :ref:`контроля "
"транзакций <atomic-atomic_execution>`. Файбер создается со статусом "
"'suspended' (приостановлен). Таким образом, логика ``fiber.new()`` слегка"
" отличается от :ref:`fiber.create() <fiber-create>`."

#: ../doc/1.10/reference/reference_lua/fiber.rst:263
msgid ""
"Ordinarily ``fiber.new()`` is used in conjunction with "
":ref:`fiber_object:set_joinable() <fiber_object-set_joinable>` and "
":ref:`fiber_object:join() <fiber_object-join>`."
msgstr ""
"Как правило, ``fiber.new()`` используется вместе с "
":ref:`fiber_object:set_joinable() <fiber_object-set_joinable>` и "
":ref:`fiber_object:join() <fiber_object-join>`."

#: ../doc/1.10/reference/reference_lua/fiber.rst:276
msgid ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function function_name()\n"
"         >   fiber.sleep(1000)\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> fiber_object = fiber.new(function_name)\n"
"---\n"
"..."
msgstr ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function function_name()\n"
"         >   fiber.sleep(1000)\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> fiber_object = fiber.new(function_name)\n"
"---\n"
"..."

#: ../doc/1.10/reference/reference_lua/fiber.rst:294
msgid "fiber object for the currently scheduled fiber."
msgstr "объект файбера для запланированного на данный момент файбера."

#: ../doc/1.10/reference/reference_lua/fiber.rst:299
msgid ""
"tarantool> fiber.self()\n"
"---\n"
"- status: running\n"
"  name: interactive\n"
"  id: 101\n"
"..."
msgstr ""
"tarantool> fiber.self()\n"
"---\n"
"- status: running\n"
"  name: interactive\n"
"  id: 101\n"
"..."

#: ../doc/1.10/reference/reference_lua/fiber.rst:312
msgid "numeric identifier of the fiber."
msgstr "числовой идентификатор файбера."

#: ../doc/1.10/reference/reference_lua/fiber.rst:314
msgid "fiber object for the specified fiber."
msgstr "объект файбера для указанного файбера."

#: ../doc/1.10/reference/reference_lua/fiber.rst:319
msgid ""
"tarantool> fiber.find(101)\n"
"---\n"
"- status: running\n"
"  name: interactive\n"
"  id: 101\n"
"..."
msgstr ""
"tarantool> fiber.find(101)\n"
"---\n"
"- status: running\n"
"  name: interactive\n"
"  id: 101\n"
"..."

#: ../doc/1.10/reference/reference_lua/fiber.rst:332
msgid ""
"Yield control to the scheduler and sleep for the specified number of "
"seconds. Only the current fiber can be made to sleep."
msgstr ""
"Передача управления планировщику и переход в режим ожидания на указанное "
"количество секунд. Только текущий файбер можно перевести в режим "
"ожидания."

#: ../doc/1.10/reference/reference_lua/fiber.rst:335
msgid "number of seconds to sleep."
msgstr "количество секунд в режиме ожидания."

#: ../doc/1.10/reference/reference_lua/fiber.rst:339
msgid ""
"tarantool> fiber.sleep(1.5)\n"
"---\n"
"..."
msgstr ""
"tarantool> fiber.sleep(1.5)\n"
"---\n"
"..."

#: ../doc/1.10/reference/reference_lua/fiber.rst:349
msgid ""
"Yield control to the scheduler. Equivalent to :ref:`fiber.sleep(0) "
"<fiber-sleep>`, except that `fiber.sleep(0)` depends on a timer, "
"`fiber.yield()` does not."
msgstr ""
"Передача управления планировщику. Работает аналогично "
":ref:`fiber.sleep(0) <fiber-sleep>`, только `fiber.sleep(0)` зависит от "
"таймера, `fiber.yield()` -- нет."

#: ../doc/1.10/reference/reference_lua/fiber.rst:354
msgid ""
"tarantool> fiber.yield()\n"
"---\n"
"..."
msgstr ""
"tarantool> fiber.yield()\n"
"---\n"
"..."

#: ../doc/1.10/reference/reference_lua/fiber.rst:364
msgid ""
"Return the status of the current fiber. Or, if optional fiber_object is "
"passed, return the status of the specified fiber."
msgstr ""
"Возврат статуса текущего файбера. Или же, если передается необязательный "
"параметр fiber_object, возврат статуса указанного файбера."

#: ../doc/1.10/reference/reference_lua/fiber.rst:368
msgid "the status of ``fiber``. One of: “dead”, “suspended”, or “running”."
msgstr ""
"статус файбера: “dead” (недоступен), “suspended” (приостановлен) или "
"“running” (активен)."

#: ../doc/1.10/reference/reference_lua/fiber.rst:373
msgid ""
"tarantool> fiber.status()\n"
"---\n"
"- running\n"
"..."
msgstr ""
"tarantool> fiber.status()\n"
"---\n"
"- running\n"
"..."

#: ../doc/1.10/reference/reference_lua/fiber.rst:384
msgid "Return information about all fibers."
msgstr "Возврат информации о всех файберах."

#: ../doc/1.10/reference/reference_lua/fiber.rst:386
msgid ""
"number of context switches, backtrace, id, total memory, used memory, "
"name for each fiber."
msgstr ""
"количество переключений контекста, обратная трассировка, ID, общий объем "
"памяти, объем используемой памяти, имя каждого файбера."

#: ../doc/1.10/reference/reference_lua/fiber.rst:392
msgid ""
"tarantool> fiber.info()\n"
"---\n"
"- 101:\n"
"    csw: 7\n"
"    backtrace: []\n"
"    fid: 101\n"
"    memory:\n"
"      total: 65776\n"
"      used: 0\n"
"    name: interactive\n"
"..."
msgstr ""
"tarantool> fiber.info()\n"
"---\n"
"- 101:\n"
"    csw: 7\n"
"    backtrace: []\n"
"    fid: 101\n"
"    memory:\n"
"      total: 65776\n"
"      used: 0\n"
"    name: interactive\n"
"..."

#: ../doc/1.10/reference/reference_lua/fiber.rst:410
msgid ""
"Locate a fiber by its numeric id and cancel it. In other words, "
":ref:`fiber.kill() <fiber-kill>` combines :ref:`fiber.find() <fiber-"
"find>` and :ref:`fiber_object:cancel() <fiber_object-cancel>`."
msgstr ""
"Поиск файбера по числовому идентификатору и его отмена. Другими словами, "
":ref:`fiber.kill() <fiber-kill>` объединяет в себе :ref:`fiber.find() "
"<fiber-find>` и :ref:`fiber_object:cancel() <fiber_object-cancel>`."

#: ../doc/1.10/reference/reference_lua/fiber.rst:414
msgid "the id of the fiber to be cancelled."
msgstr "ID файбера для отмены."

#: ../doc/1.10/reference/reference_lua/fiber.rst
msgid "Exception"
msgstr "Исключение"

#: ../doc/1.10/reference/reference_lua/fiber.rst:415
msgid "the specified fiber does not exist or cancel is not permitted."
msgstr "указанный файбер отсутствует, или отмена невозможна."

#: ../doc/1.10/reference/reference_lua/fiber.rst:419
msgid ""
"tarantool> fiber.kill(fiber.id()) -- kill self, may make program end\n"
"---\n"
"- error: fiber is cancelled\n"
"..."
msgstr ""
"tarantool> fiber.kill(fiber.id()) -- функция с self может вызвать "
"окончание программы\n"
"---\n"
"- error: fiber is cancelled\n"
"..."

#: ../doc/1.10/reference/reference_lua/fiber.rst:431
msgid ""
"Check if the current fiber has been cancelled and throw an exception if "
"this is the case."
msgstr ""
"Проверка отмены действующего файбера и выдача исключения, если файбер "
"отменен."

#: ../doc/1.10/reference/reference_lua/fiber.rst:436
msgid ""
"Even if you catch the exception, the fiber will remain cancelled. Most "
"types of calls will check ``fiber.testcancel()``. However, some functions"
" (``id``, ``status``, ``join`` etc.) will return no error. We recommend "
"application developers to implement occasional checks with "
":ref:`fiber.testcancel() <fiber-testcancel>` and to end fiber's execution"
" as soon as possible in case it has been cancelled."
msgstr ""

#: ../doc/1.10/reference/reference_lua/fiber.rst:445
msgid ""
"tarantool> fiber.testcancel()\n"
"---\n"
"- error: fiber is cancelled\n"
"..."
msgstr ""
"tarantool> fiber.testcancel()\n"
"---\n"
"- error: fiber is cancelled\n"
"..."

#: ../doc/1.10/reference/reference_lua/fiber.rst:458
#: ../doc/1.10/reference/reference_lua/fiber.rst:483
#: ../doc/1.10/reference/reference_lua/fiber.rst:511
#: ../doc/1.10/reference/reference_lua/fiber.rst:533
#: ../doc/1.10/reference/reference_lua/fiber.rst:560
msgid ""
"generally this is an object referenced in the return from "
":ref:`fiber.create <fiber-create>` or :ref:`fiber.self <fiber-self>` or "
":ref:`fiber.find <fiber-find>`"
msgstr ""
"как правило, это объект, полученный в результате вызова "
":ref:`fiber.create <fiber-create>`, :ref:`fiber.self <fiber-self>` или "
":ref:`fiber.find <fiber-find>`"

#: ../doc/1.10/reference/reference_lua/fiber.rst:462
msgid "id of the fiber."
msgstr "ID файбера."

#: ../doc/1.10/reference/reference_lua/fiber.rst:465
msgid "``fiber.self():id()`` can also be expressed as ``fiber.id()``."
msgstr "``fiber.self():id()`` может также быть выражен как ``fiber.id()``."

#: ../doc/1.10/reference/reference_lua/fiber.rst:469
msgid ""
"tarantool> fiber_object = fiber.self()\n"
"---\n"
"...\n"
"tarantool> fiber_object:id()\n"
"---\n"
"- 101\n"
"..."
msgstr ""
"tarantool> fiber_object = fiber.self()\n"
"---\n"
"...\n"
"tarantool> fiber_object:id()\n"
"---\n"
"- 101\n"
"..."

#: ../doc/1.10/reference/reference_lua/fiber.rst:487
msgid "name of the fiber."
msgstr "имя файбера."

#: ../doc/1.10/reference/reference_lua/fiber.rst:490
msgid "``fiber.self():name()`` can also be expressed as ``fiber.name()``."
msgstr "``fiber.self():name()`` может также быть выражен как ``fiber.name()``."

#: ../doc/1.10/reference/reference_lua/fiber.rst:494
msgid ""
"tarantool> fiber.self():name()\n"
"---\n"
"- interactive\n"
"..."
msgstr ""
"tarantool> fiber.self():name()\n"
"---\n"
"- interactive\n"
"..."

#: ../doc/1.10/reference/reference_lua/fiber.rst:505
msgid ""
"Change the fiber name. By default a Tarantool server's interactive-mode "
"fiber is named 'interactive' and new fibers created due to "
":ref:`fiber.create <fiber-create>` are named 'lua'. Giving fibers "
"distinct names makes it easier to distinguish them when using "
":ref:`fiber.info <fiber-info>`."
msgstr ""
"Изменение имени файбера. По умолчанию, файбер в интерактивном режиме "
"экземпляра Tarantool'а называется 'interactive', а новые файберы, "
"созданные с помощью :ref:`fiber.create <fiber-create>`, называются 'lua'."
" Переименование файберов позволяет легче различать их при использовании "
":ref:`fiber.info <fiber-info>`."

#: ../doc/1.10/reference/reference_lua/fiber.rst:515
msgid "the new name of the fiber."
msgstr "новое имя файбера."

#: ../doc/1.10/reference/reference_lua/fiber.rst:521
msgid ""
"tarantool> fiber.self():name('non-interactive')\n"
"---\n"
"..."
msgstr ""
"tarantool> fiber.self():name('non-interactive')\n"
"---\n"
"..."

#: ../doc/1.10/reference/reference_lua/fiber.rst:531
msgid "Return the status of the specified fiber."
msgstr "Возврат статуса указанного файбера."

#: ../doc/1.10/reference/reference_lua/fiber.rst:537
msgid "the status of fiber. One of: “dead”, “suspended”, or “running”."
msgstr ""
"статус файбера: “dead” (недоступен), “suspended” (приостановлен) или "
"“running” (активен)."

#: ../doc/1.10/reference/reference_lua/fiber.rst:540
msgid "``fiber.self():status(`` can also be expressed as ``fiber.status()``."
msgstr "``fiber.self():status(`` может также быть выражен как ``fiber.status()``."

#: ../doc/1.10/reference/reference_lua/fiber.rst:544
msgid ""
"tarantool> fiber.self():status()\n"
"---\n"
"- running\n"
"..."
msgstr ""
"tarantool> fiber.self():status()\n"
"---\n"
"- running\n"
"..."

#: ../doc/1.10/reference/reference_lua/fiber.rst:555
#, fuzzy
msgid ""
"Cancel a fiber. Running and suspended fibers can be cancelled. After a "
"fiber has been cancelled, attempts to operate on it will cause errors, "
"for example :ref:`fiber_object:name() <fiber_object-name_get>` will cause"
" ``error: the fiber is dead``."
msgstr ""
"Отмена файбера. Активные и приостановленные файберы можно отменить. После"
" отмены файбера попытки работать с ним вызовут ошибку, например, вызов "
":ref:`fiber_object:id() <fiber_object-id>` вызовет ошибку с указанием "
"недоступности файбера ``error: the fiber is dead``."

#: ../doc/1.10/reference/reference_lua/fiber.rst:566
msgid "Possible errors: cancel is not permitted for the specified fiber object."
msgstr "Возможные ошибки: нельзя отменить указанный объект файбера."

#: ../doc/1.10/reference/reference_lua/fiber.rst:570
msgid ""
"tarantool> fiber.self():cancel() -- kill self, may make program end\n"
"---\n"
"- error: fiber is cancelled\n"
"..."
msgstr ""
"tarantool> fiber.self():cancel() -- функция с self может вызвать "
"окончание программы\n"
"---\n"
"- error: fiber is cancelled\n"
"..."

#: ../doc/1.10/reference/reference_lua/fiber.rst:581
msgid ""
"Local storage within the fiber. The storage can contain any number of "
"named values, subject to memory limitations. Naming may be done with "
":samp:`{fiber_object}.storage.{name}` or "
":samp:`{fiber_object}.storage['{name}'].` or with a number "
":samp:`{fiber_object}.storage[{number}]`. Values may be either numbers or"
" strings. The Lua garbage collector will mark or free the local storage "
"when :samp:`{fiber_object}:cancel()` happens."
msgstr ""
"Локальное хранилище в пределах файбера. Хранилище может содержать любое "
"количество именованных значений при соблюдении ограничений памяти. "
"Правила именования: :samp:`{объект_файбера}.storage.{имя}`, либо "
":samp:`{объект_файбера}.storage['{имя}'].`, либо с числом "
":samp:`{объект_файбера}.storage[{число}]`. Значения могут быть числовыми "
"или строковыми. Сборщик мусора в Lua отметит или освободит локальное "
"хранилище при вызове :samp:`{fiber_object}:cancel()`."

#: ../doc/1.10/reference/reference_lua/fiber.rst:590
msgid ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function f () fiber.sleep(1000); end\n"
"---\n"
"...\n"
"tarantool> fiber_function = fiber.create(f)\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage.str1 = 'string'\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage['str1']\n"
"---\n"
"- string\n"
"...\n"
"tarantool> fiber_function:cancel()\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage['str1']\n"
"---\n"
"- error: '[string \"return fiber_function.storage[''str1'']\"]:1: the "
"fiber is dead'\n"
"..."
msgstr ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function f () fiber.sleep(1000); end\n"
"---\n"
"...\n"
"tarantool> fiber_function = fiber.create(f)\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage.str1 = 'string'\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage['str1']\n"
"---\n"
"- string\n"
"...\n"
"tarantool> fiber_function:cancel()\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage['str1']\n"
"---\n"
"- error: '[string \"return fiber_function.storage[''str1'']\"]:1: the "
"fiber is dead'\n"
"..."

#: ../doc/1.10/reference/reference_lua/fiber.rst:616
msgid "See also :ref:`box.session.storage <box_session-storage>`."
msgstr "См. также :ref:`box.session.storage <box_session-storage>`."

#: ../doc/1.10/reference/reference_lua/fiber.rst:622
msgid ""
"``fiber_object:set_joinable(true)`` makes a fiber joinable; "
"``fiber_object:set_joinable(false)`` makes a fiber not joinable; the "
"default is false."
msgstr ""
"``fiber_object:set_joinable(true)`` делает файбер доступным для "
"присоединения; ``fiber_object:set_joinable(false)`` делает файбер "
"недоступным для присоединения; по умолчанию, false."

#: ../doc/1.10/reference/reference_lua/fiber.rst:626
msgid ""
"A joinable fiber can be waited for, with :ref:`fiber_object:join() "
"<fiber_object-join>`."
msgstr ""
"Присоединяемый файбер можно ожидать с помощью :ref:`fiber_object:join() "
"<fiber_object-join>`."

#: ../doc/1.10/reference/reference_lua/fiber.rst:629
msgid ""
"Best practice is to call ``fiber_object:set_joinable()`` before the fiber"
" function begins to execute, because otherwise the fiber could become "
"'dead' before ``fiber_object:set_joinable()`` takes effect. The usual "
"sequence could be:"
msgstr ""
"Лучше всего вызвать ``fiber_object:set_joinable()`` до начала выполнения "
"функции с файбером, поскольку в противном случае файбер может стать "
"недоступен до того, как сработает ``fiber_object:set_joinable()``. "
"Правильная последовательность может быть такой:"

#: ../doc/1.10/reference/reference_lua/fiber.rst:634
msgid ""
"Call ``fiber.new()`` instead of ``fiber.create()`` to create a new "
"fiber_object."
msgstr ""
"Вызов ``fiber.new()`` вместо ``fiber.create()`` для создания нового "
"объекта файбера fiber_object."

#: ../doc/1.10/reference/reference_lua/fiber.rst:637
msgid ""
"Do not yield at this point, because that will cause the fiber function to"
" begin."
msgstr ""
"Не передавать управление, поскольку это приведет к началу работы функции "
"с файбером."

#: ../doc/1.10/reference/reference_lua/fiber.rst:640
msgid ""
"Call ``fiber_object:set_joinable(true)`` to make the new fiber_object "
"joinable."
msgstr ""
"Вызов ``fiber_object:set_joinable(true)``, чтобы сделать новый объект "
"файбера fiber_object присоединяемым."

#: ../doc/1.10/reference/reference_lua/fiber.rst:643
msgid "Now it is safe to yield."
msgstr "Сейчас можно передать управление."

#: ../doc/1.10/reference/reference_lua/fiber.rst:645
msgid "Call ``fiber_object:join()``."
msgstr "Вызов ``fiber_object:join()``."

#: ../doc/1.10/reference/reference_lua/fiber.rst:647
msgid ""
"Usually ``fiber_object:join()`` should be called, otherwise the fiber's "
"status may become 'suspended' when the fiber function ends, instead of "
"'dead'."
msgstr ""
"Как правило, следует вызвать ``fiber_object:join()``, в противном случае,"
" статус файбера может перейти в 'suspended' (приостановлен) после "
"выполнения функции, а не 'dead' (недоступен)."

#: ../doc/1.10/reference/reference_lua/fiber.rst:651
msgid "the boolean value that changes the ``set_joinable`` flag"
msgstr "логическое значение, которое изменяет флаг ``set_joinable``"

#: ../doc/1.10/reference/reference_lua/fiber.rst:658
#: ../doc/1.10/reference/reference_lua/fiber.rst:708
msgid "The result of the following sequence of requests is:"
msgstr "Результат следующего ряда запросов:"

#: ../doc/1.10/reference/reference_lua/fiber.rst:660
msgid ""
"the global variable ``d`` will be 6 (which proves that the function was "
"not executed until after ``d`` was set to 1, when ``fiber.sleep(1)`` "
"caused a yield);"
msgstr ""
"глобальная переменная ``d`` получит значение 6 (что доказывает, что "
"функция не выполнялась до тех пор, пока значение ``d`` не стало 1, когда "
"``fiber.sleep(1)`` вызвал передачу управления);"

#: ../doc/1.10/reference/reference_lua/fiber.rst:663
msgid ""
"``fiber.status(fi2)`` will be 'suspended' (which proves that after the "
"function was executed the fiber status did not change to 'dead')."
msgstr ""
"``fiber.status(fi2)`` будет приостановлен 'suspended' (что доказывает, "
"что после выполнения функции статус файбера не изменился на недоступный "
"'dead')."

#: ../doc/1.10/reference/reference_lua/fiber.rst:666
msgid ""
"fiber=require('fiber')\n"
"d=0\n"
"function fu2() d=d+5 end\n"
"fi2=fiber.new(fu2) fi2:set_joinable(true) d=1 fiber.sleep(1)\n"
"print(d)\n"
"fiber.status(fi2)"
msgstr ""
"fiber=require('fiber')\n"
"d=0\n"
"function fu2() d=d+5 end\n"
"fi2=fiber.new(fu2) fi2:set_joinable(true) d=1 fiber.sleep(1)\n"
"print(d)\n"
"fiber.status(fi2)"

#: ../doc/1.10/reference/reference_lua/fiber.rst:679
msgid ""
"\"Join\" a joinable fiber. That is, let the fiber's function run and wait"
" until the fiber's status is 'dead' (normally a status becomes 'dead' "
"when the function execution finishes). Joining will cause a yield, "
"therefore, if the fiber is currently in a suspended state, execution of "
"its fiber function will resume."
msgstr ""
"\"Присоединение\" присоединяемого файбера. То есть возможность запуска "
"функции с файбером и ожидание перехода файбера в статус недоступности "
"'dead' (как правило, статус переходит в 'dead', когда заканчивается "
"выполнение функции). Присоединение вызовет передачу управления, таким "
"образом, если файбер находится в приостановленном состоянии, выполнение "
"функции файбера возобновится."

#: ../doc/1.10/reference/reference_lua/fiber.rst:687
msgid ""
"This kind of waiting is more convenient than going into a loop and "
"periodically checking the status; however, it works only if the fiber was"
" created with :ref:`fiber.new() <fiber-new>` and was made joinable with "
":ref:`fiber_object:set_joinable() <fiber_object-set_joinable>`."
msgstr ""
"Такое ожидание более удобно, чем переход в цикл с периодической проверкой"
" статуса; тем не менее, это работает, только если файбер был создан с "
"помощью :ref:`fiber.new() <fiber-new>` и стал доступным для присоединения"
" путем :ref:`fiber_object:set_joinable() <fiber_object-set_joinable>`."

#: ../doc/1.10/reference/reference_lua/fiber.rst:694
msgid ""
"two values. The first value is boolean. If the first value is true, then "
"the join succeeded because the fiber's function ended normally and the "
"second result has the return value from the fiber's function. If the "
"first value is false, then the join succeeded because the fiber's "
"function ended abnormally and the second result has the details about the"
" error, which one can unpack in the same way that one unpacks :ref:`a "
"pcall result <error_handling>`."
msgstr ""
"два значения. Первое значение логическое. Если первое значение = true "
"(правда), значит присоединение прошло успешно, поскольку функция файбера "
"была выполнена нормально, а второй результат -- это возвращаемое значение"
" функции файбера. Если же первое значение = false (ложь), значит "
"присоединение не было осуществлено, поскольку выполнение функции файбера "
"было прервано, а второй результат содержит подробную информацию об "
"ошибке, которую можно распаковать так же, как :ref:`результат вызова "
"pcall <error_handling>`."

#: ../doc/1.10/reference/reference_lua/fiber.rst:704
msgid "boolean +result type, or boolean + struct error"
msgstr ""
"логическое значение +тип результата, или логическое значение + ошибка "
"структуры"

#: ../doc/1.10/reference/reference_lua/fiber.rst:710
msgid "the first ``fiber.status()`` call returns 'suspended',"
msgstr "первый вызов ``fiber.status()`` возвращает 'suspended' (приостановлен),"

#: ../doc/1.10/reference/reference_lua/fiber.rst:711
msgid "the ``join()`` call returns true,"
msgstr "вызов ``join()`` возвращает true (правда),"

#: ../doc/1.10/reference/reference_lua/fiber.rst:712
msgid "the elapsed time is usually 5 seconds, and"
msgstr "как правило, проходит 5 секунд, и"

#: ../doc/1.10/reference/reference_lua/fiber.rst:713
msgid "the second ``fiber.status()`` call returns 'dead'."
msgstr "второй вызов ``fiber.status()`` возвращает 'dead' (недоступен)."

#: ../doc/1.10/reference/reference_lua/fiber.rst:715
msgid ""
"This proves that the ``join()`` does not return until the function -- "
"which sleeps 5 seconds -- is 'dead'."
msgstr ""
"Это доказывает, что ``join()`` не возвращает результат, пока функция, "
"которая находится в режиме ожидания в течение 5 секунд, недоступна "
"('dead')."

#: ../doc/1.10/reference/reference_lua/fiber.rst:718
msgid ""
"fiber=require('fiber')\n"
"function fu2() fiber.sleep(5) end\n"
"fi2=fiber.new(fu2) fi2:set_joinable(true)\n"
"start_time = os.time()\n"
"fiber.status(fi2)\n"
"fi2:join()\n"
"print('elapsed = ' .. os.time() - start_time)\n"
"fiber.status(fi2)"
msgstr ""
"fiber=require('fiber')\n"
"function fu2() fiber.sleep(5) end\n"
"fi2=fiber.new(fu2) fi2:set_joinable(true)\n"
"start_time = os.time()\n"
"fiber.status(fi2)\n"
"fi2:join()\n"
"print('elapsed = ' .. os.time() - start_time)\n"
"fiber.status(fi2)"

#: ../doc/1.10/reference/reference_lua/fiber.rst:733
msgid ""
"current system time (in seconds since the epoch) as a Lua number. The "
"time is taken from the event loop clock, which makes this call very "
"cheap, but still useful for constructing artificial tuple keys."
msgstr ""
"текущее системное время (в секундах с начала отсчета) в виде Lua-числа. "
"Время берется из часов событийного цикла, поэтому вызов полезен лишь для "
"создания искусственных ключей кортежа."

#: ../doc/1.10/reference/reference_lua/fiber.rst:737
#: ../doc/1.10/reference/reference_lua/fiber.rst:756
msgid "num"
msgstr "num"

#: ../doc/1.10/reference/reference_lua/fiber.rst:741
msgid ""
"tarantool> fiber.time(), fiber.time()\n"
"---\n"
"- 1448466279.2415\n"
"- 1448466279.2415\n"
"..."
msgstr ""
"tarantool> fiber.time(), fiber.time()\n"
"---\n"
"- 1448466279.2415\n"
"- 1448466279.2415\n"
"..."

#: ../doc/1.10/reference/reference_lua/fiber.rst:753
msgid ""
"current system time (in microseconds since the epoch) as a 64-bit "
"integer. The time is taken from the event loop clock."
msgstr ""
"текущее системное время (в микросекундах с начала отсчета) в виде "
"64-битного целого числа. Время берется из часов событийного цикла."

#: ../doc/1.10/reference/reference_lua/fiber.rst:760
msgid ""
"tarantool> fiber.time(), fiber.time64()\n"
"---\n"
"- 1448466351.2708\n"
"- 1448466351270762\n"
"..."
msgstr ""
"tarantool> fiber.time(), fiber.time64()\n"
"---\n"
"- 1448466351.2708\n"
"- 1448466351270762\n"
"..."

#: ../doc/1.10/reference/reference_lua/fiber.rst:772
msgid ""
"Make the function which will be associated with the fiber. This function "
"contains an infinite loop. Each iteration of the loop adds 1 to a global "
"variable named gvar, then goes to sleep for 2 seconds. The sleep causes "
"an implicit :ref:`fiber.yield() <fiber-yield>`."
msgstr ""
"Создание функции, которая будет связана с файбером. Такая функция "
"содержит бесконечный цикл. Каждая итерация цикла прибавляет 1 к "
"глобальной переменной под названием ``gvar``, а затем уходит в режим "
"ожидания на 2 секунды. Ожидание вызывает неявную передачу управления "
":ref:`fiber.yield() <fiber-yield>`."

#: ../doc/1.10/reference/reference_lua/fiber.rst:777
msgid ""
"tarantool> fiber = require('fiber')\n"
"tarantool> function function_x()\n"
"         >   gvar = 0\n"
"         >   while true do\n"
"         >     gvar = gvar + 1\n"
"         >     fiber.sleep(2)\n"
"         >   end\n"
"         > end\n"
"---\n"
"..."
msgstr ""
"tarantool> fiber = require('fiber')\n"
"tarantool> function function_x()\n"
"         >   gvar = 0\n"
"         >   while true do\n"
"         >     gvar = gvar + 1\n"
"         >     fiber.sleep(2)\n"
"         >   end\n"
"         > end\n"
"---\n"
"..."

#: ../doc/1.10/reference/reference_lua/fiber.rst:790
msgid ""
"Make a fiber, associate function_x with the fiber, and start function_x. "
"It will immediately \"detach\" so it will be running independently of the"
" caller."
msgstr ""
"Создание файбера, ассоциация функции function_x с файбером и запуск "
"function_x. Она сразу же \"отсоединится\", то есть будет работать "
"отдельно от вызывающего метода."

#: ../doc/1.10/reference/reference_lua/fiber.rst:793
msgid ""
"tarantool> gvar = 0\n"
"\n"
"tarantool> fiber_of_x = fiber.create(function_x)\n"
"---\n"
"..."
msgstr ""
"tarantool> gvar = 0\n"
"\n"
"tarantool> fiber_of_x = fiber.create(function_x)\n"
"---\n"
"..."

#: ../doc/1.10/reference/reference_lua/fiber.rst:801
msgid "Get the id of the fiber (fid), to be used in later displays."
msgstr "Получение ID файбера (fid) для последующего вывода."

#: ../doc/1.10/reference/reference_lua/fiber.rst:803
msgid ""
"tarantool> fid = fiber_of_x:id()\n"
"---\n"
"..."
msgstr ""
"tarantool> fid = fiber_of_x:id()\n"
"---\n"
"..."

#: ../doc/1.10/reference/reference_lua/fiber.rst:809
msgid ""
"Pause for a while, while the detached function runs. Then ... Display the"
" fiber id, the fiber status, and gvar (gvar will have gone up a bit "
"depending how long the pause lasted). The status is suspended because the"
" fiber spends almost all its time sleeping or yielding."
msgstr ""
"Небольшая остановка, пока работает отсоединенная функция. Затем ... "
"Отображение идентификатора файбера, статуса файбера и переменной gvar "
"(значение gvar немного увеличится в зависимости от длительности паузы). "
"Статус будет \"suspended\" (приостановлен), потому что файбер практически"
" всё время проводит в режиме ожидания или передачи управления."

#: ../doc/1.10/reference/reference_lua/fiber.rst:814
msgid ""
"tarantool> print('#', fid, '. ', fiber_of_x:status(), '. gvar=', gvar)\n"
"# 102 .  suspended . gvar= 399\n"
"---\n"
"..."
msgstr ""
"tarantool> print('#', fid, '. ', fiber_of_x:status(), '. gvar=', gvar)\n"
"# 102 .  suspended . gvar= 399\n"
"---\n"
"..."

#: ../doc/1.10/reference/reference_lua/fiber.rst:821
msgid ""
"Pause for a while, while the detached function runs. Then ... Cancel the "
"fiber. Then, once again ... Display the fiber id, the fiber status, and "
"gvar (gvar will have gone up a bit more depending how long the pause "
"lasted). This time the status is dead because the cancel worked."
msgstr ""
"Небольшая остановка, пока работает отсоединенная функция. Затем ... "
"Отмена файбера. Затем снова отображение идентификатора файбера, статуса "
"файбера и переменной gvar (значение gvar немного увеличится в зависимости"
" от длительности паузы). На этот раз статус будет \"dead\" (недоступен), "
"потому что произошла отмена."

#: ../doc/1.10/reference/reference_lua/fiber.rst:826
msgid ""
"tarantool> fiber_of_x:cancel()\n"
"---\n"
"...\n"
"tarantool> print('#', fid, '. ', fiber_of_x:status(), '. gvar=', gvar)\n"
"# 102 .  dead . gvar= 421\n"
"---\n"
"..."
msgstr ""
"tarantool> fiber_of_x:cancel()\n"
"---\n"
"...\n"
"tarantool> print('#', fid, '. ', fiber_of_x:status(), '. gvar=', gvar)\n"
"# 102 .  dead . gvar= 421\n"
"---\n"
"..."

#: ../doc/1.10/reference/reference_lua/fiber.rst:842
msgid "Channels"
msgstr "Каналы"

#: ../doc/1.10/reference/reference_lua/fiber.rst:844
msgid ""
"Call ``fiber.channel()`` to allocate space and get a channel object, "
"which will be called channel for examples in this section."
msgstr ""
"Вызов ``fiber.channel()`` для выделения спейса и получение объекта "
"канала, который будет называться \"channel\" в примерах данного раздела."

#: ../doc/1.10/reference/reference_lua/fiber.rst:847
msgid ""
"Call the other routines, via channel, to send messages, receive messages,"
" or check channel status."
msgstr ""
"Вызов других процедур по каналу для отправки сообщений, получения "
"сообщений или проверки статуса канала."

#: ../doc/1.10/reference/reference_lua/fiber.rst:850
msgid ""
"Message exchange is synchronous. The Lua garbage collector will mark or "
"free the channel when no one is using it, as with any other Lua object. "
"Use object-oriented syntax, for example ``channel:put(message)`` rather "
"than ``fiber.channel.put(message)``."
msgstr ""
"Обмен сообщения происходит синхронно. Сборщик мусора в Lua отмечает или "
"освобождает канал, когда его никто не использует, как и любой другой "
"Lua-объект. Используйте объектно-ориентированный синтаксис, например "
"``channel:put(message)``, а не ``fiber.channel.put(message)``."

#: ../doc/1.10/reference/reference_lua/fiber.rst:859
msgid "Create a new communication channel."
msgstr "Создание нового канала связи."

#: ../doc/1.10/reference/reference_lua/fiber.rst:861
msgid ""
"the maximum number of slots (spaces for ``channel:put`` messages) that "
"can be in use at once. The default is 0."
msgstr ""
"максимальное количество слотов (спейсы для сообщений ``channel:put``), "
"которые можно использовать одновременно. По умолчанию, 0."

#: ../doc/1.10/reference/reference_lua/fiber.rst:865
msgid "new channel."
msgstr "новый канал."

#: ../doc/1.10/reference/reference_lua/fiber.rst:866
msgid "userdata, possibly including the string \"channel ...\"."
msgstr "пользовательские данные, возможно включая строку \"channel ...\"."

#: ../doc/1.10/reference/reference_lua/fiber.rst:874
msgid ""
"Send a message using a channel. If the channel is full, ``channel:put()``"
" waits until there is a free slot in the channel."
msgstr ""
"Отправка сообщения по каналу связи. Если канал заполнен, "
"``channel:put()`` ожидает, пока не освободится слот в канале."

#: ../doc/1.10/reference/reference_lua/fiber.rst:877
msgid "what will be sent, usually a string or number or table"
msgstr "то, что отправляется, как правило, строка, число или таблица"

#: ../doc/1.10/reference/reference_lua/fiber.rst:878
msgid "maximum number of seconds to wait for a slot to become free"
msgstr "максимальное количество секунд ожидания, чтобы слот освободился"

#: ../doc/1.10/reference/reference_lua/fiber.rst:879
msgid ""
"If timeout is specified, and there is no free slot in the channel for the"
" duration of the timeout, then the return value is ``false``. If the "
"channel is closed, then the return value is ``false``. Otherwise, the "
"return value is ``true``, indicating success."
msgstr ""
"Если указан параметр времени ожидания timeout, и в канале нет свободного "
"слота в течение указанного времени, возвращается значение ``false`` "
"(ложь). Если канал закрыт, возвращается значение ``false``. В остальных "
"случаях возвращается значение ``true`` (правда), которое указывает на "
"успешную отправку."

#: ../doc/1.10/reference/reference_lua/fiber.rst:889
msgid ""
"Close the channel. All waiters in the channel will stop waiting. All "
"following ``channel:get()`` operations will return ``nil``, and all "
"following ``channel:put()`` operations will return ``false``."
msgstr ""
"Закрытие канала. Все, кто находится в режиме ожидания в канале, "
"отключаются. Все последующие операции ``channel:get()`` вернут нулевое "
"значение ``nil``, а все последующие операции ``channel:put()`` вернут "
"``false`` (ложь)."

#: ../doc/1.10/reference/reference_lua/fiber.rst:897
msgid ""
"Fetch and remove a message from a channel. If the channel is empty, "
"``channel:get()`` waits for a message."
msgstr ""
"Перехват и удаление сообщения из канала. Если канал пуст, "
"``channel:get()`` будет ожидать сообщения."

#: ../doc/1.10/reference/reference_lua/fiber.rst:900
msgid "maximum number of seconds to wait for a message"
msgstr "максимальное количество секунд ожидания сообщения"

#: ../doc/1.10/reference/reference_lua/fiber.rst:901
msgid ""
"If timeout is specified, and there is no message in the channel for the "
"duration of the timeout, then the return value is ``nil``. If the channel"
" is closed, then the return value is ``nil``. Otherwise, the return value"
" is the message placed on the channel by ``channel:put()``."
msgstr ""
"Если указан параметр времени ожидания timeout, и в канале нет сообщения в"
" течение указанного времени, возвращается нулевое значение ``nil``. Если "
"канал закрыт, возвращается значение ``nil``. В остальных случаях "
"возвращается сообщение, отправленное на канал с помощью "
"``channel:put()``."

#: ../doc/1.10/reference/reference_lua/fiber.rst:906
msgid "usually string or number or table, as determined by ``channel:put``"
msgstr "как правило, строка, число или таблица, как определяет ``channel:put()``"

#: ../doc/1.10/reference/reference_lua/fiber.rst:912
msgid "Check whether the channel is empty (has no messages)."
msgstr "Проверка пустоты канала (отсутствие сообщений)."

#: ../doc/1.10/reference/reference_lua/fiber.rst:914
msgid "``true`` if the channel is empty. Otherwise ``false``."
msgstr "``true`` (правда), если канал пуст. В противном случае, ``false`` (ложь)."

#: ../doc/1.10/reference/reference_lua/fiber.rst:921
msgid "Find out how many messages are in the channel."
msgstr "Определение количества сообщений в канале."

#: ../doc/1.10/reference/reference_lua/fiber.rst:923
msgid "the number of messages."
msgstr "количество сообщений."

#: ../doc/1.10/reference/reference_lua/fiber.rst:930
msgid "Check whether the channel is full."
msgstr "Проверка заполненности канала."

#: ../doc/1.10/reference/reference_lua/fiber.rst:932
msgid ""
"``true`` if the channel is full (the number of messages in the channel "
"equals the number of slots so there is no room for a new message). "
"Otherwise ``false``."
msgstr ""
"``true`` (правда), если канал заполнен (количество сообщений в канале "
"равно количеству слотов, то есть нет места для новых сообщений). В "
"противном случае, ``false`` (ложь)."

#: ../doc/1.10/reference/reference_lua/fiber.rst:941
msgid ""
"Check whether readers are waiting for a message because they have issued "
"``channel:get()`` and the channel is empty."
msgstr ""
"Проверка пустого канала на наличие читателей в состоянии ожидания "
"сообщения после отправки запросов ``channel:get()``."

#: ../doc/1.10/reference/reference_lua/fiber.rst:944
msgid "``true`` if readers are waiting. Otherwise ``false``."
msgstr ""
"``true`` (правда), если на канале есть читатели в ожидании сообщения. В "
"противном случае, ``false`` (ложь)."

#: ../doc/1.10/reference/reference_lua/fiber.rst:951
msgid ""
"Check whether writers are waiting because they have issued "
"``channel:put()`` and the channel is full."
msgstr ""
"Проверка полного канала на наличие писателей в состоянии ожидания после "
"отправки запросов ``channel:put()``."

#: ../doc/1.10/reference/reference_lua/fiber.rst:954
msgid "``true`` if writers are waiting. Otherwise ``false``."
msgstr ""
"``true`` (правда), если на канале есть писатели в состоянии ожидании. В "
"противном случае, ``false`` (ложь)."

#: ../doc/1.10/reference/reference_lua/fiber.rst:961
msgid "``true`` if the channel is already closed. Otherwise ``false``."
msgstr ""
"``true`` (правда), если канал уже закрыт. В противном случае, ``false`` "
"(ложь)."

#: ../doc/1.10/reference/reference_lua/fiber.rst:969
msgid ""
"This example should give a rough idea of what some functions for fibers "
"should look like. It's assumed that the functions would be referenced in "
":ref:`fiber.create() <fiber-create>`."
msgstr ""
"В данном примере дается примерное представление о том, как должны "
"выглядеть функции для файберов. Предполагается, что на функции ссылается "
":ref:`fiber.create() <fiber-create>`."

#: ../doc/1.10/reference/reference_lua/fiber.rst:973
msgid ""
"fiber = require('fiber')\n"
"channel = fiber.channel(10)\n"
"function consumer_fiber()\n"
"    while true do\n"
"        local task = channel:get()\n"
"        ...\n"
"    end\n"
"end\n"
"\n"
"function consumer2_fiber()\n"
"    while true do\n"
"        -- 10 seconds\n"
"        local task = channel:get(10)\n"
"        if task ~= nil then\n"
"            ...\n"
"        else\n"
"            -- timeout\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"function producer_fiber()\n"
"    while true do\n"
"        task = box.space...:select{...}\n"
"        ...\n"
"        if channel:is_empty() then\n"
"            -- channel is empty\n"
"        end\n"
"\n"
"        if channel:is_full() then\n"
"            -- channel is full\n"
"        end\n"
"\n"
"        ...\n"
"        if channel:has_readers() then\n"
"            -- there are some fibers\n"
"            -- that are waiting for data\n"
"        end\n"
"        ...\n"
"\n"
"        if channel:has_writers() then\n"
"            -- there are some fibers\n"
"            -- that are waiting for readers\n"
"        end\n"
"        channel:put(task)\n"
"    end\n"
"end\n"
"\n"
"function producer2_fiber()\n"
"    while true do\n"
"        task = box.space...select{...}\n"
"        -- 10 seconds\n"
"        if channel:put(task, 10) then\n"
"            ...\n"
"        else\n"
"            -- timeout\n"
"        end\n"
"    end\n"
"end"
msgstr ""
"fiber = require('fiber')\n"
" channel = fiber.channel(10)\n"
" function consumer_fiber()\n"
"     while true do\n"
"         local task = channel:get()\n"
"         ...\n"
"     end\n"
" end\n"
" \n"
" function consumer2_fiber()\n"
"     while true do\n"
"         -- 10 секунд\n"
"         local task = channel:get(10)\n"
"         if task ~= nil then\n"
"             ...\n"
"         else\n"
"             -- время ожидания\n"
"         end\n"
"     end\n"
" end\n"
" \n"
" function producer_fiber()\n"
"     while true do\n"
"         task = box.space...:select{...}\n"
"         ...\n"
"         if channel:is_empty() then\n"
"             -- канал пуст\n"
"         end\n"
" \n"
"         if channel:is_full() then\n"
"             -- канал полон\n"
"         end\n"
" \n"
"         ...\n"
"         if channel:has_readers() then\n"
"             -- есть файберы\n"
"             -- которые ожидают данные\n"
"         end\n"
"         ...\n"
" \n"
"         if channel:has_writers() then\n"
"             -- есть файберы\n"
"             -- которые ожидают читателей\n"
"         end\n"
"         channel:put(task)\n"
"     end\n"
" end\n"
" \n"
" function producer2_fiber()\n"
"     while true do\n"
"         task = box.space...select{...}\n"
"         -- 10 секунд\n"
"         if channel:put(task, 10) then\n"
"             ...\n"
"         else\n"
"             -- время ожидания\n"
"         end\n"
"     end\n"
" end"

#: ../doc/1.10/reference/reference_lua/fiber.rst:1039
msgid "Condition variables"
msgstr "Условные переменные"

#: ../doc/1.10/reference/reference_lua/fiber.rst:1041
msgid ""
"Call ``fiber.cond()`` to create a named condition variable, which will be"
" called 'cond' for examples in this section."
msgstr ""
"Вызов ``fiber.cond()`` используется для создания именованной условной "
"переменной, которая будет называться 'cond' для примеров данного раздела."

#: ../doc/1.10/reference/reference_lua/fiber.rst:1044
msgid ""
"Call ``cond:wait()`` to make a fiber wait for a signal via a condition "
"variable."
msgstr ""
"Вызов ``cond:wait()`` используется, чтобы заставить файбер ожидать "
"сигнал, с помощью условной переменной."

#: ../doc/1.10/reference/reference_lua/fiber.rst:1046
msgid ""
"Call ``cond:signal()`` to send a signal to wake up a single fiber that "
"has executed ``cond:wait()``."
msgstr ""
"Вызов ``cond:signal()`` используется, чтобы отправить сигнал для "
"пробуждения отдельного файбера, который выполнил запрос ``cond:wait()``."

#: ../doc/1.10/reference/reference_lua/fiber.rst:1049
msgid ""
"Call ``cond:broadcast()`` to send a signal to all fibers that have "
"executed ``cond:wait()``."
msgstr ""
"Вызов ``cond:broadcast()`` используется для отправки сигнала всем "
"файберам, которые выполнили ``cond:wait()``."

#: ../doc/1.10/reference/reference_lua/fiber.rst:1056
msgid "Create a new condition variable."
msgstr "Создание новой условной переменной."

#: ../doc/1.10/reference/reference_lua/fiber.rst:1058
msgid "new condition variable."
msgstr "новая условная переменная."

#: ../doc/1.10/reference/reference_lua/fiber.rst:1067
msgid ""
"Make the current fiber go to sleep, waiting until another fiber invokes "
"the ``signal()`` or ``broadcast()`` method on the cond object. The sleep "
"causes an implicit :ref:`fiber.yield() <fiber-yield>`."
msgstr ""
"Перевод файбера в режим ожидания до пробуждения другим файбером с помощью"
" метода ``signal()`` или ``broadcast()``. Переход в режим ожидания "
"вызывает неявную передачу управления :ref:`fiber.yield() <fiber-yield>`."

#: ../doc/1.10/reference/reference_lua/fiber.rst:1071
msgid "number of seconds to wait, default = forever."
msgstr "количество секунд ожидания, по умолчанию = всегда."

#: ../doc/1.10/reference/reference_lua/fiber.rst:1072
msgid ""
"If timeout is provided, and a signal doesn't happen for the duration of "
"the timeout, ``wait()`` returns false. If a signal or broadcast happens, "
"``wait()`` returns true."
msgstr ""
"Если указан параметр времени ожидания timeout, и сигнал не передается в "
"течение указанного времени, ``wait()`` вернет значение false (ложь). Если"
" передается ``signal()`` или ``broadcast()``, ``wait()`` вернет true "
"(правда)."

#: ../doc/1.10/reference/reference_lua/fiber.rst:1081
msgid "Wake up a single fiber that has executed ``wait()`` for the same variable."
msgstr ""
"Пробуждение отдельного файбера, который выполнил ``wait()`` для той же "
"переменной."

#: ../doc/1.10/reference/reference_lua/fiber.rst:1090
msgid "Wake up all fibers that have executed ``wait()`` for the same variable."
msgstr ""
"Пробуждение всех файберов, которые выполнили ``wait()`` для той же "
"переменной."

#: ../doc/1.10/reference/reference_lua/fiber.rst:1098
msgid ""
"Assume that a tarantool instance is running and listening for connections"
" on localhost port 3301. Assume that guest users have privileges to "
"connect. We will use the tarantoolctl utility to start two clients."
msgstr ""
"Предположим, что запущен экземпляр Tarantool'а на прослушивание на "
"localhost по порту 3301. Предположим, что у пользователя guest есть права"
" на подключение. Используем утилиту tarantoolctl для запуска двух "
"клиентов."

#: ../doc/1.10/reference/reference_lua/fiber.rst:1102
msgid "On terminal #1, say"
msgstr "В первом терминале введите:"

#: ../doc/1.10/reference/reference_lua/fiber.rst:1104
msgid ""
"$ tarantoolctl connect '3301'\n"
"tarantool> fiber = require('fiber')\n"
"tarantool> cond = fiber.cond()\n"
"tarantool> cond:wait()"
msgstr ""
"$ tarantoolctl connect '3301'\n"
"tarantool> fiber = require('fiber')\n"
"tarantool> cond = fiber.cond()\n"
"tarantool> cond:wait()"

#: ../doc/1.10/reference/reference_lua/fiber.rst:1111
msgid ""
"The job will hang because ``cond:wait()`` -- without an optional timeout "
"argument -- will go to sleep until the condition variable changes."
msgstr ""
"Задача повиснет, поскольку ``cond:wait()`` -- без дополнительного "
"аргумента времени ожидания timeout -- уйдет в режим ожидания до изменения"
" условной переменной."

#: ../doc/1.10/reference/reference_lua/fiber.rst:1114
msgid "On terminal #2, say"
msgstr "Во втором терминале введите:"

#: ../doc/1.10/reference/reference_lua/fiber.rst:1116
msgid ""
"$ tarantoolctl connect '3301'\n"
"tarantool> cond:signal()"
msgstr ""
"$ tarantoolctl connect '3301'\n"
"tarantool> cond:signal()"

#: ../doc/1.10/reference/reference_lua/fiber.rst:1121
msgid ""
"Now look again at terminal #1. It will show that the waiting stopped, and"
" the ``cond:wait()`` function returned ``true``."
msgstr ""
"Теперь снова взгляните на терминал №1. Он покажет, что ожидание "
"прекратилось, и функция ``cond:wait()`` вернула значение ``true``."

#: ../doc/1.10/reference/reference_lua/fiber.rst:1124
msgid ""
"This example depended on the use of a global conditional variable with "
"the arbitrary name ``cond``. In real life, programmers would make sure to"
" use different conditional variable names for different applications."
msgstr ""
"В данном примере показана зависимость от использования глобальной "
"условной переменной с произвольным именем ``cond``. В реальной жизни "
"разработчики следят за использованием различных имен для условных "
"переменных в разных приложениях."

#: ../doc/1.10/reference/reference_lua/fio.rst:39
msgid "Module `fio`"
msgstr "Модуль `fio`"

#: ../doc/1.10/reference/reference_lua/fio.rst:47
msgid ""
"Tarantool supports file input/output with an API that is similar to POSIX"
" syscalls. All operations are performed asynchronously. Multiple fibers "
"can access the same file simultaneously."
msgstr ""
"Tarantool поддерживает файловый ввод-вывод с помощью API, который "
"аналогичен системным вызовам POSIX. Все операции проводятся асинхронно. "
"Несколько файберов могут получать доступ к одному файлу одновременно."

#: ../doc/1.10/reference/reference_lua/fio.rst:51
msgid "The ``fio`` module contains:"
msgstr "Модуль ``fio`` включает в себя:"

#: ../doc/1.10/reference/reference_lua/fio.rst:53
msgid "functions for :ref:`common pathname manipulations <fio-pathname>`,"
msgstr "функции для :ref:`стандартных действий с путем к файлу <fio-pathname>`,"

#: ../doc/1.10/reference/reference_lua/fio.rst:54
msgid ""
"functions for :ref:`directory or file existence and type checks<fio-"
"checks>`,"
msgstr ""
"функции для :ref:`проверки наличия и типа директории или файла <fio-"
"checks>`,"

#: ../doc/1.10/reference/reference_lua/fio.rst:55
msgid "functions for :ref:`common file manipulations <fio-file>`, and"
msgstr "функции для :ref:`стандартных действий с файлами <fio-file>`, а также"

#: ../doc/1.10/reference/reference_lua/fio.rst:56
msgid ""
":ref:`constants <fio-c>` which are the same as POSIX flag values (for "
"example ``fio.c.flag.O_RDONLY`` = POSIX O_RDONLY)."
msgstr ""
":ref:`постоянные <fio-c>`., которые совпадают с флаговыми значениями "
"POSIX (например, ``fio.c.flag.O_RDONLY`` = POSIX O_RDONLY)."

#: ../doc/1.10/reference/reference_lua/fio.rst:63
msgid "Below is a list of all ``fio`` functions and members."
msgstr "Ниже приведен перечень всех функций и элементов модуля ``fio``."

#: ../doc/1.10/reference/reference_lua/fio.rst:75
msgid ":ref:`fio.pathjoin() <fio-pathjoin>`"
msgstr ":ref:`fio.pathjoin() <fio-pathjoin>`"

#: ../doc/1.10/reference/reference_lua/fio.rst:75
msgid "Form a path name from one or more partial strings"
msgstr "Формирование пути к файлу из одной или более частей строки"

#: ../doc/1.10/reference/reference_lua/fio.rst:78
msgid ":ref:`fio.basename() <fio-basename>`"
msgstr ":ref:`fio.basename() <fio-basename>`"

#: ../doc/1.10/reference/reference_lua/fio.rst:78
msgid "Get a file name"
msgstr "Получение имени файла"

#: ../doc/1.10/reference/reference_lua/fio.rst:81
msgid ":ref:`fio.dirname() <fio-dirname>`"
msgstr ":ref:`fio.dirname() <fio-dirname>`"

#: ../doc/1.10/reference/reference_lua/fio.rst:81
msgid "Get a directory name"
msgstr "Получение имени директории"

#: ../doc/1.10/reference/reference_lua/fio.rst:84
msgid ":ref:`fio.abspath() <fio-abspath>`"
msgstr ":ref:`fio.abspath() <fio-abspath>`"

#: ../doc/1.10/reference/reference_lua/fio.rst:84
msgid "Get a directory and file name"
msgstr "Получение имен директории и файла"

#: ../doc/1.10/reference/reference_lua/fio.rst:87
msgid ":ref:`fio.path.exists() <fio-path_exists>`"
msgstr ":ref:`fio.path.exists() <fio-path_exists>`"

#: ../doc/1.10/reference/reference_lua/fio.rst:87
#: ../doc/1.10/reference/reference_lua/fio.rst:99
msgid "Check if file or directory exists"
msgstr "Проверка наличия файла или директории"

#: ../doc/1.10/reference/reference_lua/fio.rst:90
msgid ":ref:`fio.path.is_dir() <fio-path_is_dir>`"
msgstr ":ref:`fio.path.is_dir() <fio-path_is_dir>`"

#: ../doc/1.10/reference/reference_lua/fio.rst:90
msgid "Check if file or directory is a directory"
msgstr "Проверка, является ли файл или директория директорией"

#: ../doc/1.10/reference/reference_lua/fio.rst:93
msgid ":ref:`fio.path.is_file() <fio-path_is_file>`"
msgstr ":ref:`fio.path.is_file() <fio-path_is_file>`"

#: ../doc/1.10/reference/reference_lua/fio.rst:93
msgid "Check if file or directory is a file"
msgstr "Проверка, является ли файл или директория файлом"

#: ../doc/1.10/reference/reference_lua/fio.rst:96
msgid ":ref:`fio.path.is_link() <fio-path_is_link>`"
msgstr ":ref:`fio.path.is_link() <fio-path_is_link>`"

#: ../doc/1.10/reference/reference_lua/fio.rst:96
msgid "Check if file or directory is a link"
msgstr "Проверка, является ли файл или директория ссылкой"

#: ../doc/1.10/reference/reference_lua/fio.rst:99
msgid ":ref:`fio.path.lexists() <fio-path_lexists>`"
msgstr ":ref:`fio.path.lexists() <fio-path_lexists>`"

#: ../doc/1.10/reference/reference_lua/fio.rst:102
msgid ":ref:`fio.umask() <fio-umask>`"
msgstr ":ref:`fio.umask() <fio-umask>`"

#: ../doc/1.10/reference/reference_lua/fio.rst:102
msgid "Set mask bits"
msgstr "Определение битов маски"

#: ../doc/1.10/reference/reference_lua/fio.rst:105
msgid ":ref:`fio.lstat() <fio-stat>` |br| :ref:`fio.stat() <fio-stat>`"
msgstr ":ref:`fio.lstat() <fio-stat>` |br| :ref:`fio.stat() <fio-stat>`"

#: ../doc/1.10/reference/reference_lua/fio.rst:106
msgid "Get information about a file object"
msgstr "Получение информации об объекте файла"

#: ../doc/1.10/reference/reference_lua/fio.rst:110
msgid ":ref:`fio.mkdir() <fio-mkdir>` |br| :ref:`fio.rmdir() <fio-mkdir>`"
msgstr ":ref:`fio.mkdir() <fio-mkdir>` |br| :ref:`fio.rmdir() <fio-mkdir>`"

#: ../doc/1.10/reference/reference_lua/fio.rst:111
msgid "Create or delete a directory"
msgstr "Создание или удаление директории"

#: ../doc/1.10/reference/reference_lua/fio.rst:115
msgid ":ref:`fio.chdir() <fio-chdir>`"
msgstr ":ref:`fio.chdir() <fio-chdir>`"

#: ../doc/1.10/reference/reference_lua/fio.rst:115
msgid "Change working directory"
msgstr "Изменение рабочей директории"

#: ../doc/1.10/reference/reference_lua/fio.rst:118
msgid ":ref:`fio.listdir() <fio-listdir>`"
msgstr ":ref:`fio.listdir() <fio-listdir>`"

#: ../doc/1.10/reference/reference_lua/fio.rst:118
msgid "List files in a directory"
msgstr "Вывод списка файлов в директории"

#: ../doc/1.10/reference/reference_lua/fio.rst:121
msgid ":ref:`fio.glob() <fio-glob>`"
msgstr ":ref:`fio.glob() <fio-glob>`"

#: ../doc/1.10/reference/reference_lua/fio.rst:121
msgid "Get files whose names match a given string"
msgstr "Получение файлов, имена которых совпадают с заданной строкой"

#: ../doc/1.10/reference/reference_lua/fio.rst:124
msgid ":ref:`fio.tempdir() <fio-tempdir>`"
msgstr ":ref:`fio.tempdir() <fio-tempdir>`"

#: ../doc/1.10/reference/reference_lua/fio.rst:124
msgid "Get the name of a directory for storing temporary files"
msgstr "Получение имени директории для хранения временных файлов"

#: ../doc/1.10/reference/reference_lua/fio.rst:127
msgid ":ref:`fio.cwd() <fio-cwd>`"
msgstr ":ref:`fio.cwd() <fio-cwd>`"

#: ../doc/1.10/reference/reference_lua/fio.rst:127
msgid "Get the name of the current working directory"
msgstr "Получение имени текущей рабочей директории"

#: ../doc/1.10/reference/reference_lua/fio.rst:130
msgid ""
":ref:`fio.copytree() <fio-copytree>` |br| :ref:`fio.mktree() <fio-"
"mktree>` |br| :ref:`fio.rmtree() <fio-rmtree>`"
msgstr ""
":ref:`fio.copytree() <fio-copytree>` |br| :ref:`fio.mktree() <fio-"
"mktree>` |br| :ref:`fio.rmtree() <fio-rmtree>`"

#: ../doc/1.10/reference/reference_lua/fio.rst:133
msgid "Create and delete directories"
msgstr "Создание и удаление директорий"

#: ../doc/1.10/reference/reference_lua/fio.rst:137
msgid ""
":ref:`fio.link() <fio-link>` |br| :ref:`fio.symlink() <fio-link>` |br| "
":ref:`fio.readlink() <fio-link>` |br| :ref:`fio.unlink() <fio-link>`"
msgstr ""
":ref:`fio.link() <fio-link>` |br| :ref:`fio.symlink() <fio-link>` |br| "
":ref:`fio.readlink() <fio-link>` |br| :ref:`fio.unlink() <fio-link>`"

#: ../doc/1.10/reference/reference_lua/fio.rst:140
msgid "Create and delete links"
msgstr "Создание и удаление ссылок"

#: ../doc/1.10/reference/reference_lua/fio.rst:146
msgid ":ref:`fio.rename() <fio-rename>`"
msgstr ":ref:`fio.rename() <fio-rename>`"

#: ../doc/1.10/reference/reference_lua/fio.rst:146
#: ../doc/1.10/reference/reference_lua/osmodule.rst:77
msgid "Rename a file or directory"
msgstr "Переименование файла или директории"

#: ../doc/1.10/reference/reference_lua/fio.rst:149
msgid ":ref:`fio.copyfile() <fio-copyfile>`"
msgstr ":ref:`fio.copyfile() <fio-copyfile>`"

#: ../doc/1.10/reference/reference_lua/fio.rst:149
msgid "Copy a file"
msgstr "Копирование файла"

#: ../doc/1.10/reference/reference_lua/fio.rst:152
msgid ":ref:`fio.chown() <fio-chown>` |br| :ref:`fio.chmod() <fio-chown>`"
msgstr ":ref:`fio.chown() <fio-chown>` |br| :ref:`fio.chmod() <fio-chown>`"

#: ../doc/1.10/reference/reference_lua/fio.rst:153
msgid "Manage rights to and ownership of file objects"
msgstr "Управление правами на использование и правами владения объектами файла"

#: ../doc/1.10/reference/reference_lua/fio.rst:157
msgid ":ref:`fio.truncate() <fio-truncate>`"
msgstr ":ref:`fio.truncate() <fio-truncate>`"

#: ../doc/1.10/reference/reference_lua/fio.rst:157
msgid "Reduce the file size"
msgstr "Уменьшение размера файла"

#: ../doc/1.10/reference/reference_lua/fio.rst:160
msgid ":ref:`fio.sync() <fio-sync>`"
msgstr ":ref:`fio.sync() <fio-sync>`"

#: ../doc/1.10/reference/reference_lua/fio.rst:160
msgid "Ensure that changes are written to disk"
msgstr "Проверка записи изменений на диск"

#: ../doc/1.10/reference/reference_lua/fio.rst:163
msgid ":ref:`fio.open() <fio-open>`"
msgstr ":ref:`fio.open() <fio-open>`"

#: ../doc/1.10/reference/reference_lua/fio.rst:163
msgid "Open a file"
msgstr "Открытие файла"

#: ../doc/1.10/reference/reference_lua/fio.rst:166
msgid ":ref:`file-handle:close() <file_handle-close>`"
msgstr ":ref:`file-handle:close() <file_handle-close>`"

#: ../doc/1.10/reference/reference_lua/fio.rst:166
msgid "Close a file"
msgstr "Закрытие файла"

#: ../doc/1.10/reference/reference_lua/fio.rst:169
msgid ""
":ref:`file-handle:pread() <file_handle-pread>` |br| :ref:`file-"
"handle:pwrite() <file_handle-pwrite>`"
msgstr ""
":ref:`file-handle:pread() <file_handle-pread>` |br| :ref:`file-"
"handle:pwrite() <file_handle-pwrite>`"

#: ../doc/1.10/reference/reference_lua/fio.rst:170
msgid "Perform random-access read or write on a file"
msgstr "Чтение или запись в файл с произвольным доступом"

#: ../doc/1.10/reference/reference_lua/fio.rst:174
msgid ""
":ref:`file-handle:read() <file_handle-read>` |br| :ref:`file-"
"handle:write() <file_handle-write>`"
msgstr ""
":ref:`file-handle:read() <file_handle-read>` |br| :ref:`file-"
"handle:write() <file_handle-write>`"

#: ../doc/1.10/reference/reference_lua/fio.rst:175
msgid "Perform non-random-access read or write on a file"
msgstr "Чтение или запись в файл не с произвольным доступом"

#: ../doc/1.10/reference/reference_lua/fio.rst:179
msgid ":ref:`file-handle:truncate() <file_handle-truncate>`"
msgstr ":ref:`file-handle:truncate() <file_handle-truncate>`"

#: ../doc/1.10/reference/reference_lua/fio.rst:179
msgid "Change the size of an open file"
msgstr "Изменение размера открытого файла"

#: ../doc/1.10/reference/reference_lua/fio.rst:182
msgid ":ref:`file-handle:seek() <file_handle-seek>`"
msgstr ":ref:`file-handle:seek() <file_handle-seek>`"

#: ../doc/1.10/reference/reference_lua/fio.rst:182
msgid "Change position in a file"
msgstr "Изменение позиции в файле"

#: ../doc/1.10/reference/reference_lua/fio.rst:185
msgid ":ref:`file-handle:stat() <file_handle-stat>`"
msgstr ":ref:`file-handle:stat() <file_handle-stat>`"

#: ../doc/1.10/reference/reference_lua/fio.rst:185
msgid "Get statistics about an open file"
msgstr "Получение статистики об открытом файле"

#: ../doc/1.10/reference/reference_lua/fio.rst:188
msgid ""
":ref:`file-handle:fsync() <file_handle-fsync>` |br| :ref:`file-"
"handle:fdatasync() <file_handle-fsync>`"
msgstr ""
":ref:`file-handle:fsync() <file_handle-fsync>` |br| :ref:`file-"
"handle:fdatasync() <file_handle-fsync>`"

#: ../doc/1.10/reference/reference_lua/fio.rst:189
msgid "Ensure that changes made to an open file are written to disk"
msgstr "Проверка записи изменений в открытом файле на диск"

#: ../doc/1.10/reference/reference_lua/fio.rst:193
msgid ":ref:`fio.c <fio-c_table>`"
msgstr ":ref:`fio.c <fio-c_table>`"

#: ../doc/1.10/reference/reference_lua/fio.rst:193
msgid "Table of constants similar to POSIX flag values"
msgstr "Таблица переменных, аналогичных флаговым значениям POSIX"

#: ../doc/1.10/reference/reference_lua/fio.rst:203
msgid "Common pathname manipulations"
msgstr "Стандартные действия с путем к файлу"

#: ../doc/1.10/reference/reference_lua/fio.rst:209
msgid "Concatenate partial string, separated by '/' to form a path name."
msgstr "Конкатенация частей строки, разделенных '/' для формирования пути к файлу."

#: ../doc/1.10/reference/reference_lua/fio.rst:211
msgid "one or more strings to be concatenated."
msgstr "одна или более строк для конкатенации."

#: ../doc/1.10/reference/reference_lua/fio.rst:212
#: ../doc/1.10/reference/reference_lua/fio.rst:231
#: ../doc/1.10/reference/reference_lua/fio.rst:252
msgid "path name"
msgstr "путь к файлу"

#: ../doc/1.10/reference/reference_lua/fio.rst:217
msgid ""
"tarantool> fio.pathjoin('/etc', 'default', 'myfile')\n"
"---\n"
"- /etc/default/myfile\n"
"..."
msgstr ""
"tarantool> fio.pathjoin('/etc', 'default', 'myfile')\n"
"---\n"
"- /etc/default/myfile\n"
"..."

#: ../doc/1.10/reference/reference_lua/fio.rst:228
msgid ""
"Given a full path name, remove all but the final part (the file name). "
"Also remove the suffix, if it is passed."
msgstr ""
"Удаление из полного пути к файлу всего, за исключением последней части "
"(имени файла). Также удаление суффикса, если он передается."

#: ../doc/1.10/reference/reference_lua/fio.rst:232
msgid "suffix"
msgstr "суффикс"

#: ../doc/1.10/reference/reference_lua/fio.rst:234
#: ../doc/1.10/reference/reference_lua/fio.rst:271
msgid "file name"
msgstr "имя файла"

#: ../doc/1.10/reference/reference_lua/fio.rst:239
msgid ""
"tarantool> fio.basename('/path/to/my.lua', '.lua')\n"
"---\n"
"- my\n"
"..."
msgstr ""
"tarantool> fio.basename('/path/to/my.lua', '.lua')\n"
"---\n"
"- my\n"
"..."

#: ../doc/1.10/reference/reference_lua/fio.rst:250
msgid "Given a full path name, remove the final part (the file name)."
msgstr "Удаление последней части (имени файла) из полного пути к файлу."

#: ../doc/1.10/reference/reference_lua/fio.rst:254
msgid "directory name, that is, path name except for file name."
msgstr "имя директории, то есть путь к файлу без имени файла."

#: ../doc/1.10/reference/reference_lua/fio.rst:259
msgid ""
"tarantool> fio.dirname('path/to/my.lua')\n"
"---\n"
"- 'path/to/'"
msgstr ""
"tarantool> fio.dirname('path/to/my.lua')\n"
"---\n"
"- 'path/to/'"

#: ../doc/1.10/reference/reference_lua/fio.rst:269
msgid "Given a final part (the file name), return the full path name."
msgstr "Возврат полного пути к файлу на основании последней части (имени файла)."

#: ../doc/1.10/reference/reference_lua/fio.rst:273
msgid "directory name, that is, path name including file name."
msgstr "имя директории, то есть путь к файлу с именем файла."

#: ../doc/1.10/reference/reference_lua/fio.rst:278
msgid ""
"tarantool> fio.abspath('my.lua')\n"
"---\n"
"- 'path/to/my.lua'\n"
"..."
msgstr ""
"tarantool> fio.abspath('my.lua')\n"
"---\n"
"- 'path/to/my.lua'\n"
"..."

#: ../doc/1.10/reference/reference_lua/fio.rst:289
msgid "Directory or file existence and type checks"
msgstr "Проверка наличия и типа директории или файла"

#: ../doc/1.10/reference/reference_lua/fio.rst:291
msgid ""
"Functions in this section are similar to some `Python os.path "
"<https://docs.python.org/2/library/os.path.htmll>`_ functions."
msgstr ""
"Функции в данном разделе подобны некоторым функциям `Python os.path "
"<https://docs.python.org/2/library/os.path.htmll>`_."

#: ../doc/1.10/reference/reference_lua/fio.rst:299
#: ../doc/1.10/reference/reference_lua/fio.rst:307
#: ../doc/1.10/reference/reference_lua/fio.rst:315
#: ../doc/1.10/reference/reference_lua/fio.rst:323
#: ../doc/1.10/reference/reference_lua/fio.rst:331
msgid "path to directory or file."
msgstr "путь к директории или файлу."

#: ../doc/1.10/reference/reference_lua/fio.rst:300
msgid ""
"true if path-name refers to a directory or file that exists and is not a "
"broken symbolic link; otherwise false"
msgstr ""
"true (правда), если путь к файлу ссылается на директорию или файл, "
"которые присутствуют в системе, и не представляет собой нерабочую "
"символьную ссылку; в противном случае, false (ложь)"

#: ../doc/1.10/reference/reference_lua/fio.rst:308
msgid "true if path-name refers to a directory; otherwise false"
msgstr ""
"true (правда), если путь к файлу ссылается на директорию; в противном "
"случае, false (ложь)"

#: ../doc/1.10/reference/reference_lua/fio.rst:316
msgid "true if path-name refers to a file; otherwise false"
msgstr ""
"true (правда), если путь к файлу ссылается на файл; в противном случае, "
"false (ложь)"

#: ../doc/1.10/reference/reference_lua/fio.rst:324
msgid "true if path-name refers to a symbolic link; otherwise false"
msgstr ""
"true (правда), если путь к файлу ссылается на символьную ссылку; в "
"противном случае, false (ложь)"

#: ../doc/1.10/reference/reference_lua/fio.rst:332
msgid ""
"true if path-name refers to a directory or file that exists or is a "
"broken symbolic link; otherwise false"
msgstr ""
"true (правда), если путь к файлу ссылается на директорию или файл, "
"которые присутствуют в системе, и представляет собой нерабочую символьную"
" ссылку; в противном случае, false (ложь)"

#: ../doc/1.10/reference/reference_lua/fio.rst:339
msgid "Common file manipulations"
msgstr "Стандартные действия с файлом"

#: ../doc/1.10/reference/reference_lua/fio.rst:345
msgid ""
"Set the mask bits used when creating files or directories. For a detailed"
" description type ``man 2 umask``."
msgstr ""
"Определение битов маски при создании файлов или директорий. Для получения"
" более подробного описания введите ``man 2 umask``."

#: ../doc/1.10/reference/reference_lua/fio.rst:348
msgid "mask bits."
msgstr "биты маски."

#: ../doc/1.10/reference/reference_lua/fio.rst:349
msgid "previous mask bits."
msgstr "предыдущие биты маски."

#: ../doc/1.10/reference/reference_lua/fio.rst:354
msgid ""
"tarantool> fio.umask(tonumber('755', 8))\n"
"---\n"
"- 493\n"
"..."
msgstr ""
"tarantool> fio.umask(tonumber('755', 8))\n"
"---\n"
"- 493\n"
"..."

#: ../doc/1.10/reference/reference_lua/fio.rst:366
msgid ""
"Returns information about a file object. For details type ``man 2 lstat``"
" or ``man 2 stat``."
msgstr ""
"Возврат информации об объекте файла. Для получения более подробной "
"информации введите ``man 2 lstat`` или ``man 2 stat``."

#: ../doc/1.10/reference/reference_lua/fio.rst:369
msgid "path name of file."
msgstr "путь к файлу."

#: ../doc/1.10/reference/reference_lua/fio.rst:370
msgid ""
"(If no error) table of fields which describe the file's block size, "
"creation time, size, and other attributes. |br| (If error) two return "
"values: null, error message."
msgstr ""
"(Если ошибки нет) таблица с полями, которые описывают размер блока файла,"
" время создания, размер и прочие атрибуты. |br| (В случае ошибки) "
"возвращаются два значения: null, сообщение об ошибке."

#: ../doc/1.10/reference/reference_lua/fio.rst:373
msgid "table."
msgstr "таблица."

#: ../doc/1.10/reference/reference_lua/fio.rst:375
msgid ""
"Additionally, the result of ``fio.stat('file-name')`` will include "
"methods equivalent to POSIX macros:"
msgstr ""
"Кроме того, результат ``fio.stat('имя-файла')`` будет включать в себя "
"методы, которые аналогичны макросам в POSIX:"

#: ../doc/1.10/reference/reference_lua/fio.rst:378
msgid "``is_blk()`` = POSIX macro S_ISBLK,"
msgstr "``is_blk()`` = макрос S_ISBLK в POSIX,"

#: ../doc/1.10/reference/reference_lua/fio.rst:379
msgid "``is_chr()`` = POSIX macro S_ISCHR,"
msgstr "``is_chr()`` = макрос S_ISCHR в POSIX"

#: ../doc/1.10/reference/reference_lua/fio.rst:380
msgid "``is_dir()`` = POSIX macro S_ISDIR,"
msgstr "``is_dir()`` = макрос S_ISDIR в POSIX,"

#: ../doc/1.10/reference/reference_lua/fio.rst:381
msgid "``is_fifo()`` = POSIX macro S_ISFIFO,"
msgstr "``is_fifo()`` = макрос S_ISFIFO в POSIX,"

#: ../doc/1.10/reference/reference_lua/fio.rst:382
msgid "``is_link()`` = POSIX macro S_ISLINK,"
msgstr "``is_link()`` = макрос S_ISLINK в POSIX,"

#: ../doc/1.10/reference/reference_lua/fio.rst:383
msgid "``is_reg()`` = POSIX macro S_ISREG,"
msgstr "``is_reg()`` = макрос S_ISREG в POSIX,"

#: ../doc/1.10/reference/reference_lua/fio.rst:384
msgid "``is_sock()`` = POSIX macro S_ISSOCK."
msgstr "``is_sock()`` = макрос S_ISSOCK в POSIX."

#: ../doc/1.10/reference/reference_lua/fio.rst:386
msgid "For example, ``fio.stat('/'):is_dir()`` will return true."
msgstr "Например, ``fio.stat('/'):is_dir()`` вернет true."

#: ../doc/1.10/reference/reference_lua/fio.rst:390
msgid ""
"tarantool> fio.lstat('/etc')\n"
"---\n"
"- inode: 1048577\n"
"  rdev: 0\n"
"  size: 12288\n"
"  atime: 1421340698\n"
"  mode: 16877\n"
"  mtime: 1424615337\n"
"  nlink: 160\n"
"  uid: 0\n"
"  blksize: 4096\n"
"  gid: 0\n"
"  ctime: 1424615337\n"
"  dev: 2049\n"
"  blocks: 24\n"
"..."
msgstr ""
"tarantool> fio.lstat('/etc')\n"
"---\n"
"- inode: 1048577\n"
"  rdev: 0\n"
"  size: 12288\n"
"  atime: 1421340698\n"
"  mode: 16877\n"
"  mtime: 1424615337\n"
"  nlink: 160\n"
"  uid: 0\n"
"  blksize: 4096\n"
"  gid: 0\n"
"  ctime: 1424615337\n"
"  dev: 2049\n"
"  blocks: 24\n"
"..."

#: ../doc/1.10/reference/reference_lua/fio.rst:416
msgid ""
"Create or delete a directory. For details type ``man 2 mkdir`` or ``man 2"
" rmdir``."
msgstr ""
"Создание или удаление директории. Для получения подробной информации "
"введите ``man 2 mkdir`` или ``man 2 rmdir``."

#: ../doc/1.10/reference/reference_lua/fio.rst:419
#: ../doc/1.10/reference/reference_lua/fio.rst:443
#: ../doc/1.10/reference/reference_lua/fio.rst:463
msgid "path of directory."
msgstr "путь к директории."

#: ../doc/1.10/reference/reference_lua/fio.rst:420
msgid ""
"Mode bits can be passed as a number or as string constants, for example "
"``S_IWUSR``. Mode bits can be combined by enclosing them in braces."
msgstr ""
"Биты режима работы можно передать в виде числа или строковых постоянных, "
"например ``S_IWUSR``. Биты режима работы можно комбинировать путем "
"обрамления их в фигурные скобки."

#: ../doc/1.10/reference/reference_lua/fio.rst:423
#: ../doc/1.10/reference/reference_lua/fio.rst:543
#: ../doc/1.10/reference/reference_lua/fio.rst:565
#: ../doc/1.10/reference/reference_lua/fio.rst:640
#: ../doc/1.10/reference/reference_lua/fio.rst:663
#: ../doc/1.10/reference/reference_lua/fio.rst:711
msgid ""
"(If no error) true. |br| (If error) two return values: false, error "
"message."
msgstr ""
"(Если ошибки нет) true. |br| (В случае ошибки) возвращаются два значения:"
" false, сообщение об ошибке."

#: ../doc/1.10/reference/reference_lua/fio.rst:429
msgid ""
"tarantool> fio.mkdir('/etc')\n"
"---\n"
"- false\n"
"..."
msgstr ""
"tarantool> fio.mkdir('/etc')\n"
"---\n"
"- false\n"
"..."

#: ../doc/1.10/reference/reference_lua/fio.rst:440
msgid "Change working directory. For details type ``man 2 chdir``."
msgstr ""
"Изменение рабочей директории. Для получения более подробной информации "
"введите ``man 2 chdir``."

#: ../doc/1.10/reference/reference_lua/fio.rst:444
msgid "(If success) true. (If failure) false."
msgstr "(Если выполнено) true. (Если не выполнено) false."

#: ../doc/1.10/reference/reference_lua/fio.rst:449
msgid ""
"tarantool> fio.chdir('/etc')\n"
"---\n"
"- true\n"
"..."
msgstr ""
"tarantool> fio.chdir('/etc')\n"
"---\n"
"- true\n"
"..."

#: ../doc/1.10/reference/reference_lua/fio.rst:460
msgid ""
"List files in directory. The result is similar to the result from the "
"``ls`` command."
msgstr ""
"Вывод списка файлов в директории. Результат похож на результат команды "
"``ls``."

#: ../doc/1.10/reference/reference_lua/fio.rst:464
msgid ""
"(If no error) a list of files. |br| (If error) two return values: null, "
"error message."
msgstr ""
"(Если ошибки нет) список файлов. |br| (В случае ошибки) возвращаются два "
"значения: null, сообщение об ошибке."

#: ../doc/1.10/reference/reference_lua/fio.rst:470
msgid ""
"tarantool> fio.listdir('/usr/lib/tarantool')\n"
"---\n"
"- - mysql\n"
"..."
msgstr ""
"tarantool> fio.listdir('/usr/lib/tarantool')\n"
"---\n"
"- - mysql\n"
"..."

#: ../doc/1.10/reference/reference_lua/fio.rst:481
msgid ""
"Return a list of files that match an input string. The list is "
"constructed with a single flag that controls the behavior of the "
"function: ``GLOB_NOESCAPE``. For details type ``man 3 glob``."
msgstr ""
"Возврат списка файлов, имена которых совпадают с введенной строкой. "
"Список составляется с одним флагом, который контролирует поведение "
"функции: ``GLOB_NOESCAPE``. Для получения подробной информации введите "
"``man 3 glob``."

#: ../doc/1.10/reference/reference_lua/fio.rst:485
msgid "path-name, which may contain wildcard characters."
msgstr "путь к файлу, который может содержать специальные символы."

#: ../doc/1.10/reference/reference_lua/fio.rst:486
msgid "list of files whose names match the input string"
msgstr "список файлов, имена которых совпадают с введенной строкой."

#: ../doc/1.10/reference/reference_lua/fio.rst:489
#: ../doc/1.10/reference/reference_lua/fio.rst:795
#: ../doc/1.10/reference/reference_lua/fio.rst:1028
msgid "**Possible errors:** nil."
msgstr "**Возможные ошибки:** nil."

#: ../doc/1.10/reference/reference_lua/fio.rst:493
msgid ""
"tarantool> fio.glob('/etc/x*')\n"
"---\n"
"- - /etc/xdg\n"
"  - /etc/xml\n"
"  - /etc/xul-ext\n"
"..."
msgstr ""
"tarantool> fio.glob('/etc/x*')\n"
"---\n"
"- - /etc/xdg\n"
"  - /etc/xml\n"
"  - /etc/xul-ext\n"
"..."

#: ../doc/1.10/reference/reference_lua/fio.rst:506
msgid "Return the name of a directory that can be used to store temporary files."
msgstr ""
"Возврат имени директории, которую можно использовать для хранения "
"временных файлов."

#: ../doc/1.10/reference/reference_lua/fio.rst:510
msgid ""
"tarantool> fio.tempdir()\n"
"---\n"
"- /tmp/lG31e7\n"
"..."
msgstr ""
"tarantool> fio.tempdir()\n"
"---\n"
"- /tmp/lG31e7\n"
"..."

#: ../doc/1.10/reference/reference_lua/fio.rst:521
msgid "Return the name of the current working directory."
msgstr "Возврат имени текущей рабочей директории."

#: ../doc/1.10/reference/reference_lua/fio.rst:525
msgid ""
"tarantool> fio.cwd()\n"
"---\n"
"- /home/username/tarantool_sandbox\n"
"..."
msgstr ""
"tarantool> fio.cwd()\n"
"---\n"
"- /home/username/tarantool_sandbox\n"
"..."

#: ../doc/1.10/reference/reference_lua/fio.rst:536
msgid ""
"Copy everything in the from-path, including subdirectory contents, to the"
" to-path. The result is similar to the result that one gets from the ``cp"
" -r`` command. The to-path should be empty."
msgstr ""
"Копирование всего из директории from-path, включая поддиректории, в to-"
"path. Результат аналогичен результату введения команды ``cp -r``. "
"Директория to-path должна быть пустой."

#: ../doc/1.10/reference/reference_lua/fio.rst:541
#: ../doc/1.10/reference/reference_lua/fio.rst:542
#: ../doc/1.10/reference/reference_lua/fio.rst:564
#: ../doc/1.10/reference/reference_lua/fio.rst:587
msgid "path-name."
msgstr "путь."

#: ../doc/1.10/reference/reference_lua/fio.rst:549
msgid ""
"tarantool> fio.copytree('/home/original','/home/archives')\n"
"---\n"
"- true\n"
"..."
msgstr ""
"tarantool> fio.copytree('/home/original','/home/archives')\n"
"---\n"
"- true\n"
"..."

#: ../doc/1.10/reference/reference_lua/fio.rst:560
msgid ""
"Create the path, including subdirectories, but without file contents. The"
" result is similar to the result that one gets from the ``mkdir`` "
"command."
msgstr ""
"Создание пути, включая поддиректории, но без содержимого файла. Результат"
" аналогичен результату введения команды ``mkdir``."

#: ../doc/1.10/reference/reference_lua/fio.rst:571
msgid ""
"tarantool> fio.mktree('/home/archives')\n"
"---\n"
"- true\n"
"..."
msgstr ""
"tarantool> fio.mktree('/home/archives')\n"
"---\n"
"- true\n"
"..."

#: ../doc/1.10/reference/reference_lua/fio.rst:582
msgid ""
"Remove the directory indicated by path-name, including subdirectories. "
"The result is similar to the result that one gets from the ``rmdir`` "
"command, recursively. The directory must be empty."
msgstr ""
"Удаление указанной директории, включая поддиректории. Результат "
"аналогичен результату введения команды ``rmdir``. Директория должна быть "
"пустой."

#: ../doc/1.10/reference/reference_lua/fio.rst:588
msgid ""
"(If no error) true. |br| (If error) two return values: null, error "
"message."
msgstr ""
"(Если ошибки нет) true. |br| (В случае ошибки) возвращаются два значения:"
" null, сообщение об ошибке."

#: ../doc/1.10/reference/reference_lua/fio.rst:594
msgid ""
"tarantool> fio.rmtree('/home/archives')\n"
"---\n"
"- true\n"
"..."
msgstr ""
"tarantool> fio.rmtree('/home/archives')\n"
"---\n"
"- true\n"
"..."

#: ../doc/1.10/reference/reference_lua/fio.rst:608
msgid ""
"Functions to create and delete links. For details type ``man readlink``, "
"``man 2 link``, ``man 2 symlink``, ``man 2 unlink``."
msgstr ""
"Функции для создания и удаления ссылок. Для получения  подробной "
"информации введите ``man readlink``, ``man 2 link``, ``man 2 symlink``, "
"``man 2 unlink``."

#: ../doc/1.10/reference/reference_lua/fio.rst:611
msgid "existing file name."
msgstr "имя существующего файла."

#: ../doc/1.10/reference/reference_lua/fio.rst:612
msgid "linked name."
msgstr "связанное имя."

#: ../doc/1.10/reference/reference_lua/fio.rst:614
msgid ""
"(If no error) ``fio.link`` and ``fio.symlink`` and ``fio.unlink`` return "
"true, ``fio.readlink`` returns the link value. |br| (If error) two return"
" values: false|null, error message."
msgstr ""
"(Если ошибки нет) ``fio.link``, ``fio.symlink`` и ``fio.unlink`` "
"возвращают true (правда), ``fio.readlink`` возвращает ссылку. |br| (В "
"случае ошибки) возвращаются два значения: false|null, сообщение об "
"ошибке."

#: ../doc/1.10/reference/reference_lua/fio.rst:620
msgid ""
"tarantool> fio.link('/home/username/tmp.txt', '/home/username/tmp.txt2')\n"
"---\n"
"- true\n"
"...\n"
"tarantool> fio.unlink('/home/username/tmp.txt2')\n"
"---\n"
"- true\n"
"..."
msgstr ""
"tarantool> fio.link('/home/username/tmp.txt', '/home/username/tmp.txt2')\n"
"---\n"
"- true\n"
"...\n"
"tarantool> fio.unlink('/home/username/tmp.txt2')\n"
"---\n"
"- true\n"
"..."

#: ../doc/1.10/reference/reference_lua/fio.rst:635
msgid "Rename a file or directory. For details type ``man 2 rename``."
msgstr ""
"Переименование файла или директории. Для получения подробной информации "
"введите ``man 2 rename``."

#: ../doc/1.10/reference/reference_lua/fio.rst:637
msgid "original name."
msgstr "первоначальное имя."

#: ../doc/1.10/reference/reference_lua/fio.rst:638
msgid "new name."
msgstr "новое имя."

#: ../doc/1.10/reference/reference_lua/fio.rst:646
msgid ""
"tarantool> fio.rename('/home/username/tmp.txt', "
"'/home/username/tmp.txt2')\n"
"---\n"
"- true\n"
"..."
msgstr ""
"tarantool> fio.rename('/home/username/tmp.txt', "
"'/home/username/tmp.txt2')\n"
"---\n"
"- true\n"
"..."

#: ../doc/1.10/reference/reference_lua/fio.rst:657
msgid ""
"Copy a file. The effect is similar to the effect that one gets with the "
"``cp`` command."
msgstr ""
"Копирование файла. Результат аналогичен результату введения команды "
"``cp``. "

#: ../doc/1.10/reference/reference_lua/fio.rst:660
msgid "path to original file."
msgstr "путь к первоначальному файлу."

#: ../doc/1.10/reference/reference_lua/fio.rst:661
msgid "path to new file."
msgstr "путь к новому файлу."

#: ../doc/1.10/reference/reference_lua/fio.rst:669
msgid ""
"tarantool> fio.copyfile('/home/user/tmp.txt', '/home/usern/tmp.txt2')\n"
"---\n"
"- true\n"
"..."
msgstr ""
"tarantool> fio.copyfile('/home/user/tmp.txt', '/home/usern/tmp.txt2')\n"
"---\n"
"- true\n"
"..."

#: ../doc/1.10/reference/reference_lua/fio.rst:681
msgid ""
"Manage the rights to file objects, or ownership of file objects. For "
"details type ``man 2 chown`` or ``man 2 chmod``."
msgstr ""
"Управление правами на использование и правами владения объектами файла. "
"Для получения подробной информации введите ``man 2 chown`` или ``man 2 "
"chmod``."

#: ../doc/1.10/reference/reference_lua/fio.rst:684
msgid "new user uid."
msgstr "новый UID пользователя."

#: ../doc/1.10/reference/reference_lua/fio.rst:685
msgid "new group uid."
msgstr "новый UID группы."

#: ../doc/1.10/reference/reference_lua/fio.rst:686
msgid "new permissions"
msgstr "новые права"

#: ../doc/1.10/reference/reference_lua/fio.rst:691
msgid ""
"tarantool> fio.chmod('/home/username/tmp.txt', tonumber('0755', 8))\n"
"---\n"
"- true\n"
"...\n"
"tarantool> fio.chown('/home/username/tmp.txt', 'username', 'username')\n"
"---\n"
"- true\n"
"..."
msgstr ""
"tarantool> fio.chmod('/home/username/tmp.txt', tonumber('0755', 8))\n"
"---\n"
"- true\n"
"...\n"
"tarantool> fio.chown('/home/username/tmp.txt', 'username', 'username')\n"
"---\n"
"- true\n"
"..."

#: ../doc/1.10/reference/reference_lua/fio.rst:706
msgid ""
"Reduce file size to a specified value. For details type ``man 2 "
"truncate``."
msgstr ""
"Уменьшение размера файла до указанного значения. Для получения подробной "
"информации введите ``man 2 truncate``."

#: ../doc/1.10/reference/reference_lua/fio.rst:717
msgid ""
"tarantool> fio.truncate('/home/username/tmp.txt', 99999)\n"
"---\n"
"- true\n"
"..."
msgstr ""
"tarantool> fio.truncate('/home/username/tmp.txt', 99999)\n"
"---\n"
"- true\n"
"..."

#: ../doc/1.10/reference/reference_lua/fio.rst:728
msgid "Ensure that changes are written to disk. For details type ``man 2 sync``."
msgstr ""
"Проверка записи изменений на диск. Для получения подробной информации "
"введите ``man 2 sync``."

#: ../doc/1.10/reference/reference_lua/fio.rst:730
#: ../doc/1.10/reference/reference_lua/fio.rst:831
#: ../doc/1.10/reference/reference_lua/fio.rst:890
#: ../doc/1.10/reference/reference_lua/fio.rst:975
#: ../doc/1.10/reference/reference_lua/fio.rst:1002
#: ../doc/1.10/reference/reference_lua/fio.rst:1082
msgid "true if success, false if failure."
msgstr "true -- если выполнено, false -- если не выполнено."

#: ../doc/1.10/reference/reference_lua/fio.rst:735
msgid ""
"tarantool> fio.sync()\n"
"---\n"
"- true\n"
"..."
msgstr ""
"tarantool> fio.sync()\n"
"---\n"
"- true\n"
"..."

#: ../doc/1.10/reference/reference_lua/fio.rst:750
msgid "Open a file in preparation for reading or writing or seeking."
msgstr "Открытие файла в процессе подготовки к чтению, записи или поиску."

#: ../doc/1.10/reference/reference_lua/fio.rst:752
msgid "Full path to the file to open."
msgstr "Полный путь к открываемому файлу."

#: ../doc/1.10/reference/reference_lua/fio.rst:753
msgid ""
"Flags can be passed as a number or as string constants, for example "
"'``O_RDONLY``', '``O_WRONLY``', '``O_RDWR``'. Flags can be combined by "
"enclosing them in braces. On Linux the full set of flags as described on "
"the `Linux man page <http://man7.org/linux/man-pages/man2/open.2.html>`_ "
"is:  * O_APPEND (start at end of file), * O_ASYNC (signal when IO is "
"possible), * O_CLOEXEC (enable a flag related to closing), * O_CREAT "
"(create file if it doesn't exist), * O_DIRECT (do less caching or no "
"caching), * O_DIRECTORY (fail if it's not a directory), * O_EXCL (fail if"
" file cannot be created), * O_LARGEFILE (allow 64-bit file offsets), * "
"O_NOATIME (no access-time updating), * O_NOCTTY (no console tty), * "
"O_NOFOLLOW (no following symbolic links), * O_NONBLOCK (no blocking), * "
"O_PATH (get a path for low-level use), * O_SYNC (force writing if it's "
"possible), * O_TMPFILE (the file will be temporary and nameless), * "
"O_TRUNC (truncate)  ... and, always, one of:  * O_RDONLY (read only), * "
"O_WRONLY (write only), or * O_RDWR (either read or write)."
msgstr ""
"Флаги могут передаваться в виде числа или в виде строковых постоянных, "
"например '``O_RDONLY``', '``O_WRONLY``', '``O_RDWR``'. Флаги можно "
"комбинировать путем обрамления их в фигурные скобки. Все флаги в Linux, "
"как описано на странице `руководства по Linux <http://man7.org/linux/man-"
"pages/man2/open.2.html>`_, представлены ниже:  * O_APPEND (открывать файл"
" в режиме добавления), * O_ASYNC (включать ввод-вывод, управляемый "
"сигналом), * O_CLOEXEC (устанавливать флаг, связанный с закрытием), * "
"O_CREAT (создать файл, если он не существует), * O_DIRECT (минимизировать"
" или отключать кэширование), * O_DIRECTORY (завершать вызов с ошибкой, "
"если путь не является директорией), * O_EXCL (завершать вызов с ошибкой, "
"если файл не может быть создан), * O_LARGEFILE (открывать 64-битные "
"файлы), * O_NOATIME (не обновлять время последнего доступа к файлу), * "
"O_NOCTTY (не делать терминальное устройство управляющим терминалом tty), "
"* O_NOFOLLOW (не открывать символьные ссылки), * O_NONBLOCK (открывать в "
"неблокирующем режиме), * O_PATH (получить путь для низкоуровневого "
"использования), * O_SYNC (включить принудительную запись, если возможно),"
" * O_TMPFILE (создать безымянный временный файл), * O_TRUNC (урезать)  "
"... и всегда используется один из флагов:  * O_RDONLY (только для "
"чтения), * O_WRONLY (только для записи) или * O_RDWR (для чтения и "
"записи)."

#: ../doc/1.10/reference/reference_lua/fio.rst:753
msgid ""
"Flags can be passed as a number or as string constants, for example "
"'``O_RDONLY``', '``O_WRONLY``', '``O_RDWR``'. Flags can be combined by "
"enclosing them in braces. On Linux the full set of flags as described on "
"the `Linux man page <http://man7.org/linux/man-pages/man2/open.2.html>`_ "
"is:"
msgstr ""
"Флаги могут передаваться в виде числа или в виде строковых постоянных, "
"например '``O_RDONLY``', '``O_WRONLY``', '``O_RDWR``'. Флаги можно "
"комбинировать путем обрамления их в фигурные скобки. Все флаги в Linux, "
"как описано на странице `руководства по Linux  <http://man7.org/linux"
"/man-pages/man2/open.2.html>`_, представлены ниже:"

#: ../doc/1.10/reference/reference_lua/fio.rst:762
msgid "O_APPEND (start at end of file),"
msgstr "O_APPEND (открывать файл в режиме добавления),"

#: ../doc/1.10/reference/reference_lua/fio.rst:763
msgid "O_ASYNC (signal when IO is possible),"
msgstr "O_ASYNC (включать ввод-вывод, управляемый сигналом),"

#: ../doc/1.10/reference/reference_lua/fio.rst:764
msgid "O_CLOEXEC (enable a flag related to closing),"
msgstr "O_CLOEXEC (устанавливать флаг, связанный с закрытием),"

#: ../doc/1.10/reference/reference_lua/fio.rst:765
msgid "O_CREAT (create file if it doesn't exist),"
msgstr "O_CREAT (создать файл, если он не существует),"

#: ../doc/1.10/reference/reference_lua/fio.rst:766
msgid "O_DIRECT (do less caching or no caching),"
msgstr "O_DIRECT (минимизировать или отключать кэширование),"

#: ../doc/1.10/reference/reference_lua/fio.rst:767
msgid "O_DIRECTORY (fail if it's not a directory),"
msgstr ""
"O_DIRECTORY (завершать вызов с ошибкой, если путь не является "
"директорией),"

#: ../doc/1.10/reference/reference_lua/fio.rst:768
msgid "O_EXCL (fail if file cannot be created),"
msgstr "O_EXCL (завершать вызов с ошибкой, если файл не может быть создан),"

#: ../doc/1.10/reference/reference_lua/fio.rst:769
msgid "O_LARGEFILE (allow 64-bit file offsets),"
msgstr "O_LARGEFILE (открывать 64-битные файлы),"

#: ../doc/1.10/reference/reference_lua/fio.rst:770
msgid "O_NOATIME (no access-time updating),"
msgstr "O_NOATIME (не обновлять время последнего доступа к файлу),"

#: ../doc/1.10/reference/reference_lua/fio.rst:771
msgid "O_NOCTTY (no console tty),"
msgstr "O_NOCTTY (не делать терминальное устройство управляющим терминалом tty),"

#: ../doc/1.10/reference/reference_lua/fio.rst:772
msgid "O_NOFOLLOW (no following symbolic links),"
msgstr "O_NOFOLLOW (не открывать символьные ссылки),"

#: ../doc/1.10/reference/reference_lua/fio.rst:773
msgid "O_NONBLOCK (no blocking),"
msgstr "O_NONBLOCK (открывать в неблокирующем режиме),"

#: ../doc/1.10/reference/reference_lua/fio.rst:774
msgid "O_PATH (get a path for low-level use),"
msgstr "O_PATH (получить путь для низкоуровневого использования),"

#: ../doc/1.10/reference/reference_lua/fio.rst:775
msgid "O_SYNC (force writing if it's possible),"
msgstr "O_SYNC (включить принудительную запись, если возможно),"

#: ../doc/1.10/reference/reference_lua/fio.rst:776
msgid "O_TMPFILE (the file will be temporary and nameless),"
msgstr "O_TMPFILE (создать безымянный временный файл),"

#: ../doc/1.10/reference/reference_lua/fio.rst:777
msgid "O_TRUNC (truncate)"
msgstr "O_TRUNC (урезать)"

#: ../doc/1.10/reference/reference_lua/fio.rst:779
msgid "... and, always, one of:"
msgstr "... и всегда используется один из флагов:"

#: ../doc/1.10/reference/reference_lua/fio.rst:781
msgid "O_RDONLY (read only),"
msgstr "O_RDONLY (только для чтения),"

#: ../doc/1.10/reference/reference_lua/fio.rst:782
msgid "O_WRONLY (write only), or"
msgstr "O_WRONLY (только для записи) или"

#: ../doc/1.10/reference/reference_lua/fio.rst:783
msgid "O_RDWR (either read or write)."
msgstr "O_RDWR (для чтения и записи)."

#: ../doc/1.10/reference/reference_lua/fio.rst:785
msgid ""
"Mode bits can be passed as a number or as string constants, for example "
"``S_IWUSR``. Mode bits are significant if flags include ``O_CREAT`` or "
"``O_TMPFILE``. Mode bits can be combined by enclosing them in braces."
msgstr ""
"Биты режима работы можно передать в виде числа или строковых постоянных, "
"например ``S_IWUSR``. Биты режима работы имеют значение, если указаны "
"флаги ``O_CREAT`` или ``O_TMPFILE``. Биты режима работы можно "
"комбинировать путем обрамления их в фигурные скобки."

#: ../doc/1.10/reference/reference_lua/fio.rst:790
msgid ""
"(If no error) file handle (abbreviated as 'fh' in later description). "
"|br| (If error) two return values: null, error message."
msgstr ""
"(Если ошибки нет) дескриптор файла (далее сокращенно 'fh'). |br| (В "
"случае ошибки) возвращаются два значения: null, сообщение об ошибке."

#: ../doc/1.10/reference/reference_lua/fio.rst:797
#: ../doc/1.10/reference/reference_lua/http.rst:213
msgid "**Example 1:**"
msgstr "**Пример 1:**"

#: ../doc/1.10/reference/reference_lua/fio.rst:799
msgid ""
"tarantool> fh = fio.open('/home/username/tmp.txt', {'O_RDWR', "
"'O_APPEND'})\n"
"---\n"
"...\n"
"tarantool> fh -- display file handle returned by fio.open\n"
"---\n"
"- fh: 11\n"
"..."
msgstr ""
"tarantool> fh = fio.open('/home/username/tmp.txt', {'O_RDWR', "
"'O_APPEND'})\n"
"---\n"
"...\n"
"tarantool> fh -- отображение дескриптора файла, который возвращает "
"fio.open\n"
"---\n"
"- fh: 11\n"
"..."

#: ../doc/1.10/reference/reference_lua/fio.rst:809
#: ../doc/1.10/reference/reference_lua/http.rst:242
msgid "**Example 2:**"
msgstr "**Пример 2:**"

#: ../doc/1.10/reference/reference_lua/fio.rst:811
msgid ""
"Using ``fio.open()`` with ``tonumber('N', 8)`` to set permissions as an "
"octal number:"
msgstr ""
"Using ``fio.open()`` with ``tonumber('N', 8)`` to set permissions as an "
"octal number:"

#: ../doc/1.10/reference/reference_lua/fio.rst:814
msgid ""
"tarantool> fio.open('x.txt', {'O_WRONLY', 'O_CREAT'}, tonumber('644',8))\n"
"---\n"
"- fh: 12\n"
"..."
msgstr ""
"tarantool> fio.open('x.txt', {'O_WRONLY', 'O_CREAT'}, tonumber('644',8))\n"
" ---\n"
" - fh: 12\n"
" ..."

#: ../doc/1.10/reference/reference_lua/fio.rst:827
msgid ""
"Close a file that was opened with ``fio.open``. For details type ``man 2 "
"close``."
msgstr ""
"Закрытие файла, который был открыт с помощью ``fio.open``. Для получения "
"подробной информации введите ``man 2 close``."

#: ../doc/1.10/reference/reference_lua/fio.rst:830
#: ../doc/1.10/reference/reference_lua/fio.rst:852
#: ../doc/1.10/reference/reference_lua/fio.rst:885
#: ../doc/1.10/reference/reference_lua/fio.rst:926
#: ../doc/1.10/reference/reference_lua/fio.rst:971
#: ../doc/1.10/reference/reference_lua/fio.rst:1001
#: ../doc/1.10/reference/reference_lua/fio.rst:1021
#: ../doc/1.10/reference/reference_lua/fio.rst:1047
#: ../doc/1.10/reference/reference_lua/fio.rst:1081
msgid "file-handle as returned by ``fio.open()``."
msgstr "дескриптор файла, который возвращает ``fio.open()``."

#: ../doc/1.10/reference/reference_lua/fio.rst:836
msgid ""
"tarantool> fh:close() -- where fh = file-handle\n"
"---\n"
"- true\n"
"..."
msgstr ""
"tarantool> fh:close() -- где fh = дескриптор файла\n"
"---\n"
"- true\n"
"..."

#: ../doc/1.10/reference/reference_lua/fio.rst:848
msgid ""
"Perform random-access read operation on a file, without affecting the "
"current seek position of the file. For details type ``man 2 pread``."
msgstr ""
"Чтение файла с произвольным доступом независимо от текущего положения в "
"поиске. Для получения подробной информации введите ``man 2 pread``."

#: ../doc/1.10/reference/reference_lua/fio.rst:853
msgid "where to read into (if the format is ``pread(buffer, count, offset)``)"
msgstr "откуда читать (если формат -- ``pread(buffer, count, offset)``)"

#: ../doc/1.10/reference/reference_lua/fio.rst:855
#: ../doc/1.10/reference/reference_lua/fio.rst:929
msgid "number of bytes to read"
msgstr "количество байтов для чтения"

#: ../doc/1.10/reference/reference_lua/fio.rst:856
msgid "offset within file where reading begins"
msgstr "смещение в файле -- где начинается чтение"

#: ../doc/1.10/reference/reference_lua/fio.rst:858
msgid ""
"If the format is ``pread(count, offset)`` then return a string containing"
" the data that was read from the file, or nil if failure."
msgstr ""
"Если формат -- ``pread(count, offset)``, возвращается строка с данными, "
"прочитанными из файла, либо нулевое значение nil, если не выполнено."

#: ../doc/1.10/reference/reference_lua/fio.rst:861
msgid ""
"If the format is ``pread(buffer, count, offset)`` then return the data to"
" the buffer. (Buffers can be acquired with :ref:`buffer.ibuf <buffer-"
"module>`.)"
msgstr ""
"Если формат -- ``pread(buffer, count, offset)``, возвращаются данные в "
"буфер. (Буферы можно ввести с помощью :ref:`buffer.ibuf <buffer-"
"module>`.)"

#: ../doc/1.10/reference/reference_lua/fio.rst:867
msgid ""
"tarantool> fh:pread(25, 25)\n"
"---\n"
"- |\n"
"  elete from t8//\n"
"  insert in\n"
"..."
msgstr ""
"tarantool> fh:pread(25, 25)\n"
"---\n"
"- |\n"
"  elete from t8//\n"
"  insert in\n"
"..."

#: ../doc/1.10/reference/reference_lua/fio.rst:881
msgid ""
"Perform random-access write operation on a file, without affecting the "
"current seek position of the file. For details type ``man 2 pwrite``."
msgstr ""
"Запись в файл с произвольным доступом независимо от текущего положения в "
"поиске. Для получения подробной информации введите ``man 2 pwrite``."

#: ../doc/1.10/reference/reference_lua/fio.rst:886
#: ../doc/1.10/reference/reference_lua/fio.rst:972
msgid "value to write"
msgstr "записываемое значение"

#: ../doc/1.10/reference/reference_lua/fio.rst:887
msgid ""
"number of bytes to write (if the format is ``pwrite(buffer, count, "
"offset)``)"
msgstr ""
"количество записываемых байтов (если формат -- ``pwrite(buffer, count, "
"offset)``)"

#: ../doc/1.10/reference/reference_lua/fio.rst:889
msgid "offset within file where writing begins"
msgstr "смещение в файле -- где начинается запись"

#: ../doc/1.10/reference/reference_lua/fio.rst:893
msgid ""
"If the format is ``pwrite(new-string, offset)`` then the returned string "
"is written to the file, as far as the end of the string."
msgstr ""
"Если формат --``pwrite(new-string, offset)``, строка записывается в файл "
"до конца строки."

#: ../doc/1.10/reference/reference_lua/fio.rst:896
msgid ""
"If the format is ``pwrite(buffer, count, offset)`` then the buffer "
"contents are written to the file, for ``count`` bytes. (Buffers can be "
"acquired with :ref:`buffer.ibuf <buffer-module>`.)"
msgstr ""
"Если формат -- ``pwrite(buffer, count, offset)``, содержимое буфера "
"записывается в файл в объеме, указанном в ``count``. (Буферы можно ввести"
" с помощью :ref:`buffer.ibuf <buffer-module>`.)"

#: ../doc/1.10/reference/reference_lua/fio.rst:900
msgid ""
"ibuf = require('buffer').ibuf()\n"
"---\n"
"...\n"
"\n"
"tarantool> fh:pwrite(ibuf, 1, 0)\n"
"---\n"
"- true\n"
"..."
msgstr ""
"ibuf = require('buffer').ibuf()\n"
"---\n"
"...\n"
"\n"
"tarantool> fh:pwrite(ibuf, 1, 0)\n"
"---\n"
"- true\n"
"..."

#: ../doc/1.10/reference/reference_lua/fio.rst:916
msgid ""
"Perform non-random-access read on a file. For details type ``man 2 read``"
" or ``man 2 write``."
msgstr ""
"Чтение файла не с произвольным доступом. Для получения подробной "
"информации введите ``man 2 read`` или ``man 2 write``."

#: ../doc/1.10/reference/reference_lua/fio.rst:921
#: ../doc/1.10/reference/reference_lua/fio.rst:966
msgid ""
"``fh:read`` and ``fh:write`` affect the seek position within the file, "
"and this must be taken into account when working on the same file from "
"multiple fibers. It is possible to limit or prevent file access from "
"other fibers with ``fiber.ipc``."
msgstr ""
"``fh:read`` и ``fh:write`` влияют на положение поиска по файлу, и это "
"следует учитывать при работе нескольких файберов над одним файлом. "
"Существует возможность ограничения или запрета на доступ к файлу с "
"помощью ``fiber.ipc``."

#: ../doc/1.10/reference/reference_lua/fio.rst:927
msgid "where to read into (if the format is ``read(buffer, count)``)"
msgstr "откуда читать (если формат -- ``read(buffer, count)``)"

#: ../doc/1.10/reference/reference_lua/fio.rst:931
msgid ""
"If the format is ``read()`` -- omitting ``count`` -- then read all bytes "
"in the file."
msgstr ""
"Если формат -- ``read()`` -- без ``count`` -- считываются все байты в "
"файле."

#: ../doc/1.10/reference/reference_lua/fio.rst:934
msgid ""
"If the format is ``read()``  or ``read([count])`` then return a string "
"containing the data that was read from the file, or nil if failure."
msgstr ""
"Если формат -- ``read()``  или ``read([count])``, возвращается строка с "
"данными, прочитанными из файла, либо нулевое значение nil, если не "
"выполнено."

#: ../doc/1.10/reference/reference_lua/fio.rst:937
msgid ""
"If the format is ``read(buffer, count)`` then return the data to the "
"buffer. (Buffers can be acquired with :ref:`buffer.ibuf <buffer-"
"module>`.)"
msgstr ""
"Если формат -- ``read(buffer, count)``, возвращаются данные в буфер. "
"(Буферы можно ввести с помощью :ref:`buffer.ibuf <buffer-module>`.)"

#: ../doc/1.10/reference/reference_lua/fio.rst:941
msgid ""
"ibuf = require('buffer').ibuf()\n"
"---\n"
"...\n"
"\n"
"tarantool> fh:read(ibuf:reserve(5), 5)\n"
"---\n"
"- 5\n"
"...\n"
"\n"
"tarantool> require('ffi').string(ibuf:alloc(5),5)\n"
"---\n"
"- abcde"
msgstr ""
"ibuf = require('buffer').ibuf()\n"
"---\n"
"...\n"
"\n"
"tarantool> fh:read(ibuf:reserve(5), 5)\n"
"---\n"
"- 5\n"
"...\n"
"\n"
"tarantool> require('ffi').string(ibuf:alloc(5),5)\n"
"---\n"
"- abcde"

#: ../doc/1.10/reference/reference_lua/fio.rst:961
msgid ""
"Perform non-random-access write on a file. For details type ``man 2 "
"write``."
msgstr ""
"Запись в файл не с произвольным доступом. Для получения подробной "
"информации введите ``man 2 write``."

#: ../doc/1.10/reference/reference_lua/fio.rst:973
msgid "number of bytes to write (if the format is ``write(buffer, count)``)"
msgstr "количество записываемых байтов (если формат -- ``write(buffer, count)``)"

#: ../doc/1.10/reference/reference_lua/fio.rst:978
msgid ""
"If the format is ``write(new-string)`` then the returned string is "
"written to the file, as far as the end of the string."
msgstr ""
"Если формат -- ``write(new-string)``, строка записывается в файл до конца"
" строки."

#: ../doc/1.10/reference/reference_lua/fio.rst:981
msgid ""
"If the format is ``write(buffer, count)`` then the buffer contents are "
"written to the file, for ``count`` bytes. (Buffers can be acquired with "
":ref:`buffer.ibuf <buffer-module>`.)"
msgstr ""
"Если формат -- ``write(buffer, count)``, содержимое буфера записывается в"
" файл в объеме, указанном в ``count``. (Буферы можно ввести с помощью "
":ref:`buffer.ibuf <buffer-module>`.)"

#: ../doc/1.10/reference/reference_lua/fio.rst:987
msgid ""
"tarantool> fh:write(\"new data\")\n"
"---\n"
"- true\n"
"..."
msgstr ""
"tarantool> fh:write(\"new data\")\n"
"---\n"
"- true\n"
"..."

#: ../doc/1.10/reference/reference_lua/fio.rst:998
msgid ""
"Change the size of an open file. Differs from ``fio.truncate``, which "
"changes the size of a closed file."
msgstr ""
"Изменение размера открытого файла. Отличается от функции "
"``fio.truncate``, которая изменяет размер закрытого файла."

#: ../doc/1.10/reference/reference_lua/fio.rst:1007
msgid ""
"tarantool> fh:truncate(0)\n"
"---\n"
"- true\n"
"..."
msgstr ""
"tarantool> fh:truncate(0)\n"
"---\n"
"- true\n"
"..."

#: ../doc/1.10/reference/reference_lua/fio.rst:1018
msgid ""
"Shift position in the file to the specified position. For details type "
"``man 2 seek``."
msgstr ""
"Изменение положения в файле на указанное. Для получения подробной "
"информации введите ``man 2 seek``."

#: ../doc/1.10/reference/reference_lua/fio.rst:1022
msgid "position to seek to"
msgstr "искомое положение"

#: ../doc/1.10/reference/reference_lua/fio.rst:1023
msgid ""
"'``SEEK_END``' = end of file, '``SEEK_CUR``' = current position, "
"'``SEEK_SET``' = start of file."
msgstr ""
"'``SEEK_END``' = конец файла, '``SEEK_CUR``' = текущее положение, "
"'``SEEK_SET``' = начало файла."

#: ../doc/1.10/reference/reference_lua/fio.rst:1025
msgid "the new position if success"
msgstr "новое положение, если выполнено"

#: ../doc/1.10/reference/reference_lua/fio.rst:1032
msgid ""
"tarantool> fh:seek(20, 'SEEK_SET')\n"
"---\n"
"- 20\n"
"..."
msgstr ""
"tarantool> fh:seek(20, 'SEEK_SET')\n"
"---\n"
"- 20\n"
"..."

#: ../doc/1.10/reference/reference_lua/fio.rst:1043
msgid ""
"Return statistics about an open file. This differs from ``fio.stat`` "
"which return statistics about a closed file. For details type ``man 2 "
"stat``."
msgstr ""
"Возврат статистики об открытом файле. Отличается от функции ``fio.stat``,"
" которая возвращает статистику о закрытом файле. Для получения подробной "
"информации введите ``man 2 stat``."

#: ../doc/1.10/reference/reference_lua/fio.rst:1048
msgid "details about the file."
msgstr "подробная информация о файле."

#: ../doc/1.10/reference/reference_lua/fio.rst:1053
msgid ""
"tarantool> fh:stat()\n"
"---\n"
"- inode: 729866\n"
"  rdev: 0\n"
"  size: 100\n"
"  atime: 140942855\n"
"  mode: 33261\n"
"  mtime: 1409430660\n"
"  nlink: 1\n"
"  uid: 1000\n"
"  blksize: 4096\n"
"  gid: 1000\n"
"  ctime: 1409430660\n"
"  dev: 2049\n"
"  blocks: 8\n"
"..."
msgstr ""
"tarantool> fh:stat()\n"
"---\n"
"- inode: 729866\n"
"  rdev: 0\n"
"  size: 100\n"
"  atime: 140942855\n"
"  mode: 33261\n"
"  mtime: 1409430660\n"
"  nlink: 1\n"
"  uid: 1000\n"
"  blksize: 4096\n"
"  gid: 1000\n"
"  ctime: 1409430660\n"
"  dev: 2049\n"
"  blocks: 8\n"
"..."

#: ../doc/1.10/reference/reference_lua/fio.rst:1077
msgid ""
"Ensure that file changes are written to disk, for an open file. Compare "
"``fio.sync``, which is for all files. For details type ``man 2 fsync`` or"
" ``man 2 fdatasync``."
msgstr ""
"Проверка записи изменений в открытом файле на диск. Ср. с ``fio.sync`` "
"для всех файлов. Для получения подробной информации введите ``man 2 "
"fsync`` or ``man 2 fdatasync``."

#: ../doc/1.10/reference/reference_lua/fio.rst:1086
msgid ""
"tarantool> fh:fsync()\n"
"---\n"
"- true\n"
"..."
msgstr ""
"tarantool> fh:fsync()\n"
"---\n"
"- true\n"
"..."

#: ../doc/1.10/reference/reference_lua/fio.rst:1097
msgid "FIO constants"
msgstr "Постоянные для файлового ввода-вывода"

#: ../doc/1.10/reference/reference_lua/fio.rst:1103
msgid ""
"Table with constants which are the same as POSIX flag values on the "
"target platform (see ``man 2 stat``)."
msgstr ""
"Таблица с постоянными, которые совпадают с флаговыми значениями в POSIX "
"на целевой платформе (см. ``man 2 stat``)."

#: ../doc/1.10/reference/reference_lua/fio.rst:1108
msgid ""
"tarantool> fio.c\n"
"---\n"
"- seek:\n"
"    SEEK_SET: 0\n"
"    SEEK_END: 2\n"
"    SEEK_CUR: 1\n"
"  mode:\n"
"    S_IWGRP: 16\n"
"    S_IXGRP: 8\n"
"    S_IROTH: 4\n"
"    S_IXOTH: 1\n"
"    S_IRUSR: 256\n"
"    S_IXUSR: 64\n"
"    S_IRWXU: 448\n"
"    S_IRWXG: 56\n"
"    S_IWOTH: 2\n"
"    S_IRWXO: 7\n"
"    S_IWUSR: 128\n"
"    S_IRGRP: 32\n"
"  flag:\n"
"    O_EXCL: 2048\n"
"    O_NONBLOCK: 4\n"
"    O_RDONLY: 0\n"
"    <...>\n"
"..."
msgstr ""
"tarantool> fio.c\n"
"---\n"
"- seek:\n"
"    SEEK_SET: 0\n"
"    SEEK_END: 2\n"
"    SEEK_CUR: 1\n"
"  mode:\n"
"    S_IWGRP: 16\n"
"    S_IXGRP: 8\n"
"    S_IROTH: 4\n"
"    S_IXOTH: 1\n"
"    S_IRUSR: 256\n"
"    S_IXUSR: 64\n"
"    S_IRWXU: 448\n"
"    S_IRWXG: 56\n"
"    S_IWOTH: 2\n"
"    S_IRWXO: 7\n"
"    S_IWUSR: 128\n"
"    S_IRGRP: 32\n"
"  flag:\n"
"    O_EXCL: 2048\n"
"    O_NONBLOCK: 4\n"
"    O_RDONLY: 0\n"
"    <...>\n"
"..."

#: ../doc/1.10/reference/reference_lua/fun.rst:39
msgid "Module `fun`"
msgstr "Модуль `fun`"

#: ../doc/1.10/reference/reference_lua/fun.rst:41
msgid ""
"Luafun, also known as the Lua Functional Library, takes advantage of the "
"features of LuaJIT to help users create complex functions. Inside the "
"module are \"sequence processors\" such as ``map``, ``filter``, "
"``reduce``, ``zip`` -- they take a user-written function as an argument "
"and run it against every element in a sequence, which can be faster or "
"more convenient than a user-written loop. Inside the module are "
"\"generators\" such as ``range``, ``tabulate``, and ``rands`` -- they "
"return a bounded or boundless series of values. Within the module are "
"\"reducers\", \"filters\", \"composers\" ... or, in short, all the "
"important features found in languages like Standard ML, Haskell, or "
"Erlang."
msgstr ""
"Luafun, также известная как библиотека для функционального "
"программирования в Lua, пользуется преимуществами LuaJIT, чтобы помочь "
"пользователям создавать сложные функции. Модуль включает в себя "
"\"последовательные процессоры\", такие как ``map``, ``filter``, "
"``reduce``, ``zip`` -- они берут написанную пользователем функцию в "
"качестве аргумента и применяют ее к каждому элементу в "
"последовательности, что может работать быстрее или более удобно, чем "
"написанный пользователем цикл. Модуль включает в себя \"генераторы\", "
"такие как ``range``, ``tabulate`` и ``rands`` -- они возвращают "
"ограниченный или неограниченный ряд значений. Модуль включает в себя "
"\"преобразователи\", \"фильтры\", \"компоновщики\" ... или, коротко "
"говоря, все важные функции из таких языков, как Standard ML, Haskell или "
"Erlang."

#: ../doc/1.10/reference/reference_lua/fun.rst:51
msgid ""
"The full documentation is `On the luafun section of github`_. However, "
"the first chapter can be skipped because installation is already done, "
"it's inside Tarantool. All that is needed is the usual ``require`` "
"request. After that, all the operations described in the Lua fun manual "
"will work, provided they are preceded by the name returned by the "
"``require`` request. For example:"
msgstr ""
"Вся документация находится по ссылке `On the luafun section of github`_. "
"Однако, первую главу можно пропустить, поскольку установка уже выполнена "
"в пределах Tarantool'а. Единственное, что нужно сделать, -- выполнить "
"обычный запрос ``require``. После этого сработают все операции, описанные"
" в руководстве по работе с библиотекой для функционального "
"программирования в Lua,  при условии, что перед ними указывается имя, "
"возвращенное запросом ``require``. Например:"

#: ../doc/1.10/reference/reference_lua/fun.rst:57
msgid ""
"tarantool> fun = require('fun')\n"
"---\n"
"...\n"
"tarantool> for _k, a in fun.range(3) do\n"
"         >   print(a)\n"
"         > end\n"
"1\n"
"2\n"
"3\n"
"---\n"
"..."
msgstr ""
"tarantool> fun = require('fun')\n"
"---\n"
"...\n"
"tarantool> for _k, a in fun.range(3) do\n"
"         >   print(a)\n"
"         > end\n"
"1\n"
"2\n"
"3\n"
"---\n"
"..."

#: ../doc/1.10/reference/reference_lua/http.rst:39
msgid "Module `http`"
msgstr "Модуль `http`"

#: ../doc/1.10/reference/reference_lua/http.rst:47
msgid ""
"The ``http`` module, specifically the ``http.client`` submodule, provides"
" the functionality of an HTTP client with support for HTTPS and "
"keepalive. It uses routines in the `libcurl "
"<https://curl.haxx.se/libcurl/>`_ library."
msgstr ""
"Модуль ``http``, в частности вложенный модуль ``http.client`` , "
"обеспечивать функциональные возможности HTTP-клиента с поддержкой HTTPS и"
" механизма поддержания в активном состоянии keepalive. Модуль использует "
"процедуры из библиотеки `libcurl <https://curl.haxx.se/libcurl/>`_."

#: ../doc/1.10/reference/reference_lua/http.rst:55
msgid "Below is a list of all ``http`` functions."
msgstr "Ниже приведен перечень всех функций модуля ``http``."

#: ../doc/1.10/reference/reference_lua/http.rst:65
msgid ":ref:`http.client.new() <http-new>`"
msgstr ":ref:`http.client.new() <http-new>`"

#: ../doc/1.10/reference/reference_lua/http.rst:65
msgid "Create an HTTP client instance"
msgstr "Создание экземпляра HTTP-клиента"

#: ../doc/1.10/reference/reference_lua/http.rst:68
msgid ":ref:`client_object:request() <client_object-request>`"
msgstr ":ref:`client_object:request() <client_object-request>`"

#: ../doc/1.10/reference/reference_lua/http.rst:68
msgid "Perform an HTTP request"
msgstr "Выполнение HTTP-запроса"

#: ../doc/1.10/reference/reference_lua/http.rst:71
msgid ":ref:`client_object:stat() <client_object-stat>`"
msgstr ":ref:`client_object:stat() <client_object-stat>`"

#: ../doc/1.10/reference/reference_lua/http.rst:71
msgid "Get a table with statistics"
msgstr "Получение таблицы со статистикой"

#: ../doc/1.10/reference/reference_lua/http.rst:79
msgid "Construct a new HTTP client instance."
msgstr "Создание нового экземпляра HTTP-клиента."

#: ../doc/1.10/reference/reference_lua/http.rst:81
msgid "the maximum number of entries in the connection cache."
msgstr "максимальное количество записей в кэше соединения."

#: ../doc/1.10/reference/reference_lua/http.rst:83
msgid "a new HTTP client instance"
msgstr "новый экземпляр HTTP-клиента"

#: ../doc/1.10/reference/reference_lua/http.rst:88
msgid ""
"tarantool> http_client = require('http.client').new({max_connections = "
"5})\n"
"---\n"
"..."
msgstr ""
"tarantool> http_client = require('http.client').new({max_connections = "
"5})\n"
"---\n"
"..."

#: ../doc/1.10/reference/reference_lua/http.rst:100
msgid ""
"If ``http_client`` is an HTTP client instance, ``http_client:request()`` "
"will perform an HTTP request and, if there is a successful connection, "
"will return a table with connection information."
msgstr ""
"Если ``http_client`` -- это экземпляр HTTP-клиента, "
"``http_client:request()`` выполнит HTTP-запрос, и в случае успешного "
"подключения вернет таблицу с информацией о подключении."

#: ../doc/1.10/reference/reference_lua/http.rst:104
msgid "HTTP method, for example 'GET' or 'POST' or 'PUT'"
msgstr "HTTP-метод, например 'GET', 'POST' или 'PUT'"

#: ../doc/1.10/reference/reference_lua/http.rst:105
msgid "location, for example 'https://tarantool.org/doc'"
msgstr "расположение, например 'https://tarantool.org/doc'"

#: ../doc/1.10/reference/reference_lua/http.rst:106
msgid "optional initial message, for example 'My text string!'"
msgstr "необязательное начальное сообщение, например 'My text string!'"

#: ../doc/1.10/reference/reference_lua/http.rst:107
#, fuzzy
msgid ""
"table of connection options, with any of these components:   * "
"``timeout`` - number of seconds to wait for a curl API read request    "
"before timing out  * ``ca_path`` - path to a directory holding one or "
"more certificates to    verify the peer with  * ``ca_file`` - path to an "
"SSL certificate file to verify the peer with  * ``verify_host`` - set "
"on/off verification of the certificate's name    (CN) against host. See "
"also    `CURLOPT_SSL_VERIFYHOST "
"<https://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYHOST.html>`_  * "
"``verify_peer`` - set on/off verification of the peer's SSL    "
"certificate. See also    `CURLOPT_SSL_VERIFYPEER "
"<https://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYPEER.html>`_  * "
"``ssl_key`` - path to a private key file for a TLS and SSL client    "
"certificate. See also    `CURLOPT_SSLKEY "
"<https://curl.haxx.se/libcurl/c/CURLOPT_SSLKEY.html>`_  * ``ssl_cert`` - "
"path to a SSL client certificate file. See also    `CURLOPT_SSLCERT "
"<https://curl.haxx.se/libcurl/c/CURLOPT_SSLCERT.html>`_  * ``headers`` - "
"table of HTTP headers  * ``keepalive_idle`` - delay, in seconds, that the"
" operating system    will wait while the connection is idle before "
"sending keepalive    probes. See also    `CURLOPT_TCP_KEEPIDLE "
"<https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPIDLE.html>`_    and the "
"note below about keepalive_interval.  * ``keepalive_interval`` - the "
"interval, in seconds, that the operating    system will wait between "
"sending keepalive probes. See also    `CURLOPT_TCP_KEEPINTVL "
"<https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPINTVL.html>`_.    If both"
" keepalive_idle and keepalive_interval are set, then    Tarantool will "
"also set HTTP keepalive headers: Connection:Keep-Alive    and Keep-"
"Alive:timeout=<keepalive_idle>.    Otherwise Tarantool will send "
"Connection:close  * ``low_speed_time`` - set the \"low speed time\" -- "
"the time that the    transfer speed should be below the \"low speed "
"limit\" for the library    to consider it too slow and abort. See also"
"    `CURLOPT_LOW_SPEED_TIME "
"<https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_TIME.html>`_  * "
"``low_speed_limit`` - set the \"low speed limit\" -- the average    "
"transfer speed in bytes per second that the transfer should be below    "
"during \"low speed time\" seconds for the library to consider it to be"
"    too slow and abort. See also    `CURLOPT_LOW_SPEED_LIMIT "
"<https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_LIMIT.html>`_  * "
"``verbose`` - set on/off verbose mode  * ``unix_socket`` - a socket name "
"to use instead of an Internet address,    for a local connection. The "
"Tarantool server must be built with    ``libcurl`` 7.40 or later. See the"
" :ref:`second example <http-example2>`    later in this section.  * "
"``max_header_name_len`` - the maximal length of a header name. If a "
"header    name is bigger than this value, it is truncated to this length."
"    The default value is '32'."
msgstr ""
"таблица с параметрами подключения, которые могут содержать любые из "
"следующих компонентов:   * ``timeout`` -- количество секунд ожидания "
"API-запроса curl на чтение до превышения времени ожидания  * ``ca_path`` "
"-- путь к директории, где хранятся один или более сертификатов для "
"проверки подключенного узла  * ``ca_file`` -- путь к SSL-сертификату для "
"проверки подключенного узла  * ``verify_host`` -- включение/отключение "
"проверки имени сертификата (CN) для хоста. См. также    "
"`CURLOPT_SSL_VERIFYHOST "
"<https://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYHOST.html>`_  * "
"``verify_peer`` --  включение/отключение проверки SSL-сертификата "
"подключенного узла. См. также    `CURLOPT_SSL_VERIFYPEER "
"<https://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYPEER.html>`_  * "
"``ssl_key`` -- путь к файлу закрытого ключа для клиентского "
"TSL-сертификата и SSL-сертификата. См. также    `CURLOPT_SSLKEY "
"<https://curl.haxx.se/libcurl/c/CURLOPT_SSLKEY.html>`_  * ``ssl_cert`` --"
" путь к файлу клиентского SSL-сертификата. См. также    `CURLOPT_SSLCERT "
"<https://curl.haxx.se/libcurl/c/CURLOPT_SSLCERT.html>`_  * ``headers`` --"
" таблица HTTP-заголовков  * ``keepalive_idle`` -- время задержки в "
"секундах, в течение которого операционная система находится в режиме "
"ожидания подключения до отправки сообщений для поддержания в активном "
"состоянии keepalive. См. также    `CURLOPT_TCP_KEEPALIVE "
"<https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPALIVE.html>`_  * "
"``keepalive_interval`` -- время интервала в секундах, в течение которого "
"операционная система находится в режиме ожидания между отправкой "
"сообщений keepalive. См. также    `CURLOPT_TCP_KEEPIDLE "
"<https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPIDLE.html>`_    и "
"примечание ниже к keepalive_interval.  * ``keepalive_interval`` -- период"
" времени в секундах между отправками сообщений keepalive в операционной "
"системе. См. также    `CURLOPT_TCP_KEEPINTVL "
"<https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPINTVL.html>`_.    Если "
"заданы оба параметр keepalive_idle и keepalive_interval, то    Tarantool "
"отобразит HTTP-заголовки для keepalive: Connection:Keep-Alive    и Keep-"
"Alive:timeout=<keepalive_idle>.    В противном случае, Tarantool отправит"
" Connection:close  * ``low_speed_time``  -- установка \"времени работы с "
"низкой скоростью\" -- времени, в течение которого скорость передачи "
"должна быть ниже \"предела низкой скорости\", чтобы библиотека посчитала "
"работу слишком медленной и завершила ее. См. также    "
"`CURLOPT_LOW_SPEED_TIME "
"<https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_TIME.html>`_  * "
"``low_speed_limit`` -- установка \"предела низкой скорости\" -- средней "
"скорости передачи в байтах в секунду, ниже которой должна быть скорость "
"передачи, чтобы библиотека посчитала работу слишком медленной и завершила"
" ее. См. также    `CURLOPT_LOW_SPEED_LIMIT "
"<https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_LIMIT.html>`_  * "
"``verbose`` -- включение/отключение режима отображения подробной "
"информации  * ``unix_socket`` -- имя сокета, которое используется вместо "
"адреса в сети Интернет,    для локального соединения. Сборка сервера "
"Tarantool'а должна осуществляться с помощью ``libcurl`` 7.40 или более "
"поздней версии. См. :ref:`второй пример <http-example2>` далее в разделе."
"  * ``max_header_name_len`` -- максимальная длина имени заголовка. Если "
"имя заголовка больше данного значения, оно усекается до такой длины. По "
"умолчанию, '32'."

#: ../doc/1.10/reference/reference_lua/http.rst:107
msgid "table of connection options, with any of these components:"
msgstr ""
"таблица с параметрами подключения, которые могут содержать любые из "
"следующих компонентов:"

#: ../doc/1.10/reference/reference_lua/http.rst:110
msgid ""
"``timeout`` - number of seconds to wait for a curl API read request "
"before timing out"
msgstr ""
"``timeout`` -- количество секунд ожидания API-запроса curl на чтение до "
"превышения времени ожидания"

#: ../doc/1.10/reference/reference_lua/http.rst:112
msgid ""
"``ca_path`` - path to a directory holding one or more certificates to "
"verify the peer with"
msgstr ""
"``ca_path`` -- путь к директории, где хранятся один или более "
"сертификатов для проверки подключенного узла"

#: ../doc/1.10/reference/reference_lua/http.rst:114
msgid "``ca_file`` - path to an SSL certificate file to verify the peer with"
msgstr "``ca_file`` -- путь к SSL-сертификату для проверки подключенного узла"

#: ../doc/1.10/reference/reference_lua/http.rst:115
msgid ""
"``verify_host`` - set on/off verification of the certificate's name (CN) "
"against host. See also `CURLOPT_SSL_VERIFYHOST "
"<https://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYHOST.html>`_"
msgstr ""
"``verify_host`` -- включение/отключение проверки имени сертификата (CN) "
"для хоста. См. также    `CURLOPT_SSL_VERIFYHOST "
"<https://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYHOST.html>`_"

#: ../doc/1.10/reference/reference_lua/http.rst:118
msgid ""
"``verify_peer`` - set on/off verification of the peer's SSL certificate. "
"See also `CURLOPT_SSL_VERIFYPEER "
"<https://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYPEER.html>`_"
msgstr ""
"``verify_peer`` --  включение/отключение проверки SSL-сертификата "
"подключенного узла. См. также `CURLOPT_SSL_VERIFYPEER "
"<https://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYPEER.html>`_"

#: ../doc/1.10/reference/reference_lua/http.rst:121
msgid ""
"``ssl_key`` - path to a private key file for a TLS and SSL client "
"certificate. See also `CURLOPT_SSLKEY "
"<https://curl.haxx.se/libcurl/c/CURLOPT_SSLKEY.html>`_"
msgstr ""
"``ssl_key`` -- путь к файлу закрытого ключа для клиентского "
"TSL-сертификата и SSL-сертификата. См. также `CURLOPT_SSLKEY "
"<https://curl.haxx.se/libcurl/c/CURLOPT_SSLKEY.html>`_"

#: ../doc/1.10/reference/reference_lua/http.rst:124
msgid ""
"``ssl_cert`` - path to a SSL client certificate file. See also "
"`CURLOPT_SSLCERT <https://curl.haxx.se/libcurl/c/CURLOPT_SSLCERT.html>`_"
msgstr ""
"``ssl_cert`` -- путь к файлу клиентского SSL-сертификата. См. также    "
"`CURLOPT_SSLCERT <https://curl.haxx.se/libcurl/c/CURLOPT_SSLCERT.html>`_"

#: ../doc/1.10/reference/reference_lua/http.rst:126
msgid "``headers`` - table of HTTP headers"
msgstr "``headers`` -- таблица HTTP-заголовков"

#: ../doc/1.10/reference/reference_lua/http.rst:127
msgid ""
"``keepalive_idle`` - delay, in seconds, that the operating system will "
"wait while the connection is idle before sending keepalive probes. See "
"also `CURLOPT_TCP_KEEPIDLE "
"<https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPIDLE.html>`_ and the note"
" below about keepalive_interval."
msgstr ""
"``keepalive_idle`` -- время задержки в секундах, в течение которого "
"операционная система находится в режиме ожидания подключения до отправки "
"сообщений для поддержания в активном состоянии keepalive. См. также "
"`CURLOPT_TCP_KEEPIDLE "
"<https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPIDLE.html>`_ и примечание"
" ниже к keepalive_interval."

#: ../doc/1.10/reference/reference_lua/http.rst:132
msgid ""
"``keepalive_interval`` - the interval, in seconds, that the operating "
"system will wait between sending keepalive probes. See also "
"`CURLOPT_TCP_KEEPINTVL "
"<https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPINTVL.html>`_. If both "
"keepalive_idle and keepalive_interval are set, then Tarantool will also "
"set HTTP keepalive headers: Connection:Keep-Alive and Keep-"
"Alive:timeout=<keepalive_idle>. Otherwise Tarantool will send "
"Connection:close"
msgstr ""
"``keepalive_interval`` -- период времени в секундах между отправками "
"сообщений keepalive в операционной системе. См. также "
"`CURLOPT_TCP_KEEPINTVL "
"<https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPINTVL.html>`_. Если "
"заданы оба параметр keepalive_idle и keepalive_interval, то Tarantool "
"отобразит HTTP-заголовки для keepalive: Connection:Keep-Alive и Keep-"
"Alive:timeout=<keepalive_idle>. В противном случае, Tarantool отправит "
"Connection:close."

#: ../doc/1.10/reference/reference_lua/http.rst:139
msgid ""
"``low_speed_time`` - set the \"low speed time\" -- the time that the "
"transfer speed should be below the \"low speed limit\" for the library to"
" consider it too slow and abort. See also `CURLOPT_LOW_SPEED_TIME "
"<https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_TIME.html>`_"
msgstr ""
"``low_speed_time`` -- установка \"времени работы с низкой скоростью\" -- "
"времени, в течение которого скорость передачи должна быть ниже \"предела "
"низкой скорости\", чтобы библиотека посчитала работу слишком медленной и "
"завершила ее. См. также    `CURLOPT_LOW_SPEED_TIME "
"<https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_TIME.html>`_"

#: ../doc/1.10/reference/reference_lua/http.rst:143
msgid ""
"``low_speed_limit`` - set the \"low speed limit\" -- the average transfer"
" speed in bytes per second that the transfer should be below during \"low"
" speed time\" seconds for the library to consider it to be too slow and "
"abort. See also `CURLOPT_LOW_SPEED_LIMIT "
"<https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_LIMIT.html>`_"
msgstr ""
"``low_speed_limit`` -- установка \"предела низкой скорости\" -- средней "
"скорости передачи в байтах в секунду, ниже которой должна быть скорость "
"передачи, чтобы библиотека посчитала работу слишком медленной и завершила"
" ее. См. также    `CURLOPT_LOW_SPEED_LIMIT "
"<https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_LIMIT.html>`_"

#: ../doc/1.10/reference/reference_lua/http.rst:148
msgid "``verbose`` - set on/off verbose mode"
msgstr ""
"``verbose`` -- включение/отключение режима отображения подробной "
"информации"

#: ../doc/1.10/reference/reference_lua/http.rst:149
msgid ""
"``unix_socket`` - a socket name to use instead of an Internet address, "
"for a local connection. The Tarantool server must be built with "
"``libcurl`` 7.40 or later. See the :ref:`second example <http-example2>` "
"later in this section."
msgstr ""
"``unix_socket`` -- имя сокета, которое используется вместо адреса в сети "
"Интернет,    для локального соединения. Сборка сервера Tarantool'а должна"
" осуществляться с помощью ``libcurl`` 7.40 или более поздней версии. См. "
":ref:`второй пример <http-example2>` далее в разделе."

#: ../doc/1.10/reference/reference_lua/http.rst:153
msgid ""
"``max_header_name_len`` - the maximal length of a header name. If a "
"header name is bigger than this value, it is truncated to this length. "
"The default value is '32'."
msgstr ""
"``max_header_name_len`` -- максимальная длина имени заголовка. Если имя "
"заголовка больше данного значения, оно усекается до такой длины. По "
"умолчанию, '32'."

#: ../doc/1.10/reference/reference_lua/http.rst:157
msgid "connection information, with all of these components:"
msgstr "информация о подключении со всеми следующими компонентами:"

#: ../doc/1.10/reference/reference_lua/http.rst:159
msgid "``status`` - HTTP response status"
msgstr "``status`` -- статус HTTP-ответа"

#: ../doc/1.10/reference/reference_lua/http.rst:160
msgid "``reason`` - HTTP response status text"
msgstr "``reason`` -- текст статуса HTTP-ответа"

#: ../doc/1.10/reference/reference_lua/http.rst:161
msgid "``headers`` - a Lua table with normalized HTTP headers"
msgstr "``headers`` -- Lua-таблица с нормализованными HTTP-заголовками"

#: ../doc/1.10/reference/reference_lua/http.rst:162
msgid "``body`` - response body"
msgstr "``body`` -- тело сообщения-ответа"

#: ../doc/1.10/reference/reference_lua/http.rst:163
msgid "``proto`` - protocol version"
msgstr "``proto`` -- версия протокола"

#: ../doc/1.10/reference/reference_lua/http.rst:167
msgid "The following \"shortcuts\" exist for requests:"
msgstr "Для запросов существуют следующие ускоренные методы:"

#: ../doc/1.10/reference/reference_lua/http.rst:169
msgid ""
"``http_client:get(url, options)`` - shortcut for "
"``http_client:request(\"GET\", url, nil, opts)``"
msgstr ""
"``http_client:get(url, options)`` -- вспомогательный метод для "
"``http_client:request(\"GET\", url, nil, opts)``"

#: ../doc/1.10/reference/reference_lua/http.rst:171
msgid ""
"``http_client:post (url, body, options)`` - shortcut for "
"``http_client:request(\"POST\", url, body, opts)``"
msgstr ""
"``http_client:post (url, body, options)`` -- ускоренный метод для "
"``http_client:request(\"POST\", url, body, opts)``"

#: ../doc/1.10/reference/reference_lua/http.rst:173
msgid ""
"``http_client:put(url, body, options)`` - shortcut for "
"``http_client:request(\"PUT\", url, body, opts)``"
msgstr ""
"``http_client:put(url, body, options)`` -- ускоренный метод для "
"``http_client:request(\"PUT\", url, body, opts)``"

#: ../doc/1.10/reference/reference_lua/http.rst:175
msgid ""
"``http_client:patch(url, body, options)`` - shortcut for "
"``http_client:request(\"PATCH\", url, body, opts)``"
msgstr ""
"``http_client:patch(url, body, options)`` -- ускоренный метод для "
"``http_client:request(\"PATCH\", url, body, opts)``"

#: ../doc/1.10/reference/reference_lua/http.rst:177
msgid ""
"``http_client:options(url, options)`` - shortcut for "
"``http_client:request(\"OPTIONS\", url, nil, opts)``"
msgstr ""
"``http_client:options(url, options)`` -- ускоренный метод для "
"``http_client:request(\"OPTIONS\", url, nil, opts)``"

#: ../doc/1.10/reference/reference_lua/http.rst:179
msgid ""
"``http_client:head(url, options)`` - shortcut for "
"``http_client:request(\"HEAD\", url, nil, opts)``"
msgstr ""
"``http_client:head(url, options)`` -- ускоренный метод для "
"``http_client:request(\"HEAD\", url, nil, opts)``"

#: ../doc/1.10/reference/reference_lua/http.rst:181
msgid ""
"``http_client:delete(url, options)`` - shortcut for "
"``http_client:request(\"DELETE\", url, nil, opts)``"
msgstr ""
"``http_client:delete(url, options)`` -- ускоренный метод для "
"``http_client:request(\"DELETE\", url, nil, opts)``"

#: ../doc/1.10/reference/reference_lua/http.rst:183
msgid ""
"``http_client:trace(url, options)`` - shortcut for "
"``http_client:request(\"TRACE\", url, nil, opts)``"
msgstr ""
"``http_client:trace(url, options)`` -- ускоренный метод для "
"``http_client:request(\"TRACE\", url, nil, opts)``"

#: ../doc/1.10/reference/reference_lua/http.rst:185
msgid ""
"``http_client:connect:(url, options)`` - shortcut for "
"``http_client:request(\"CONNECT\", url, nil, opts)``"
msgstr ""
"``http_client:connect:(url, options)`` -- ускоренный метод для "
"``http_client:request(\"CONNECT\", url, nil, opts)``"

#: ../doc/1.10/reference/reference_lua/http.rst:188
msgid ""
"Requests may be influenced by environment variables, for example users "
"can set up an http proxy by setting :samp:`HTTP_PROXY={proxy}` before "
"initiating any requests. See the web page document `Environment variables"
" libcurl understands <https://curl.haxx.se/libcurl/c/libcurl-env.html>`_."
msgstr ""
"На запросы могут влиять переменные окружения, например, пользователи "
"могут задать прокси-сервер с HTTP, указав "
":samp:`HTTP_PROXY={прокси-сервер}` перед выполнением каких-либо запросов."
" См. веб-документ по переменным окружения `Environment variables libcurl "
"understands <https://curl.haxx.se/libcurl/c/libcurl-env.html>`_."

#: ../doc/1.10/reference/reference_lua/http.rst:198
msgid "The ``http_client:stat()`` function returns a table with statistics:"
msgstr ""
"Функция ``http_client:stat()`` возвращает таблицу со статистическими "
"данными:"

#: ../doc/1.10/reference/reference_lua/http.rst:200
msgid "``active_requests`` - number of currently executing requests"
msgstr "``active_requests`` -- количество активно выполняемых запросов"

#: ../doc/1.10/reference/reference_lua/http.rst:201
msgid "``sockets_added`` - total number of sockets added into an event loop"
msgstr ""
"``sockets_added`` -- общее количество сокетов, добавленных в событийный "
"цикл"

#: ../doc/1.10/reference/reference_lua/http.rst:202
msgid "``sockets_deleted`` - total number of sockets sockets from an event loop"
msgstr ""
"``sockets_deleted`` -- общее количество сокетов, удаленных из событийного"
" цикла"

#: ../doc/1.10/reference/reference_lua/http.rst:203
msgid "``total_requests`` - total number of requests"
msgstr "``total_requests`` -- общее количество запросов"

#: ../doc/1.10/reference/reference_lua/http.rst:204
msgid ""
"``http_200_responses`` - total number of requests which have returned "
"code HTTP 200"
msgstr ""
"``http_200_responses`` -- общее количество запросов, которые вернули код "
"состояния HTTP 200"

#: ../doc/1.10/reference/reference_lua/http.rst:206
msgid ""
"``http_other_responses`` - total number of requests which have not "
"returned code HTTP 200"
msgstr ""
"``http_other_responses`` -- общее количество запросов, которые не вернули"
" код состояния HTTP 200"

#: ../doc/1.10/reference/reference_lua/http.rst:208
msgid ""
"``failed_requests`` - total number of requests which have failed "
"including system errors, curl errors, and HTTP errors"
msgstr ""
"``failed_requests`` -- общее количество невыполненных запросов, включая "
"системные ошибки, ошибки curl и HTTP-ошибки"

#: ../doc/1.10/reference/reference_lua/http.rst:215
msgid ""
"Connect to an HTTP server, look at the size of the response for a 'GET' "
"request, and look at the statistics for the session."
msgstr ""
"Подключение к HTTP-серверу, просмотр размера ответа на 'GET'-запрос и "
"просмотр статистики по сессии."

#: ../doc/1.10/reference/reference_lua/http.rst:218
msgid ""
"tarantool> http_client = require('http.client').new()\n"
"---\n"
"...\n"
"tarantool> r = http_client:request('GET','http://tarantool.org')\n"
"---\n"
"...\n"
"tarantool> string.len(r.body)\n"
"---\n"
"- 21725\n"
"...\n"
"tarantool> http_client:stat()\n"
"---\n"
"- total_requests: 1\n"
"  sockets_deleted: 2\n"
"  failed_requests: 0\n"
"  active_requests: 0\n"
"  http_other_responses: 0\n"
"  http_200_responses: 1\n"
"  sockets_added: 2"
msgstr ""
"tarantool> http_client = require('http.client').new()\n"
"---\n"
"...\n"
"tarantool> r = http_client:request('GET','http://tarantool.org')\n"
"---\n"
"...\n"
"tarantool> string.len(r.body)\n"
"---\n"
"- 21725\n"
"...\n"
"tarantool> http_client:stat()\n"
"---\n"
"- total_requests: 1\n"
"  sockets_deleted: 2\n"
"  failed_requests: 0\n"
"  active_requests: 0\n"
"  http_other_responses: 0\n"
"  http_200_responses: 1\n"
"  sockets_added: 2"

#: ../doc/1.10/reference/reference_lua/http.rst:244
msgid "Start two Tarantool instances on the same computer."
msgstr "Запустите два экземпляра Tarantool'а на одном компьютере."

#: ../doc/1.10/reference/reference_lua/http.rst:246
msgid "On the first Tarantool instance, listen on a Unix socket:"
msgstr "В первом экземпляре Tarantool'а включите прослушивание Unix-сокета:"

#: ../doc/1.10/reference/reference_lua/http.rst:248
msgid "box.cfg{listen='/tmp/unix_domain_socket.sock'}"
msgstr "box.cfg{listen='/tmp/unix_domain_socket.sock'}"

#: ../doc/1.10/reference/reference_lua/http.rst:252
msgid "On the second Tarantool instance, send via ``http_client``:"
msgstr "На втором экземпляре Tarantool'а отправьте с помощью ``http_client``:"

#: ../doc/1.10/reference/reference_lua/http.rst:254
msgid ""
"box.cfg{}\n"
"http_client = require('http.client').new({5})\n"
"http_client:put('http://localhost/','body',{unix_socket = "
"'/tmp/unix_domain_socket.sock'})"
msgstr ""
"box.cfg{}\n"
"http_client = require('http.client').new({5})\n"
"http_client:put('http://localhost/','body',{unix_socket = "
"'/tmp/unix_domain_socket.sock'})"

#: ../doc/1.10/reference/reference_lua/http.rst:260
msgid ""
"Terminal #1 will show an error message: \"Invalid MsgPack\". This is not "
"useful but demonstrates the syntax and demonstrates that was sent was "
"received."
msgstr ""
"Терминал №1 покажет сообщение об ошибке: \"Invalid MsgPack\". Данный "
"пример бесполезен, но наглядно демонстрирует синтаксис и получение "
"отправленного сообщения."

#: ../doc/1.10/reference/reference_lua/iconv.rst:39
msgid "Module `iconv`"
msgstr "Модуль `iconv`"

#: ../doc/1.10/reference/reference_lua/iconv.rst:47
msgid ""
"The ``iconv`` module provides a way to convert a string with one encoding"
" to a string with another encoding, for example from ASCII to UTF-8. It "
"is based on the POSIX iconv routines."
msgstr ""
"Модуль ``iconv`` предоставляет метод конвертации строки с одним типом "
"кодировки в строку с другим типом кодировки, например из ASCII в UTF-8. "
"Он основывается на процедурах с iconv в POSIX."

#: ../doc/1.10/reference/reference_lua/iconv.rst:51
msgid ""
"An exact list of the available encodings may depend on environment. "
"Typically the list includes ASCII, BIG5, KOI8R, LATIN8, MS-GREEK, SJIS, "
"and about 100 others. For a complete list, type ``iconv --list`` on a "
"terminal."
msgstr ""
"Точный список доступных кодировок зависит от окружения. Как правило, в "
"список входят ASCII, BIG5, KOI8R, LATIN8, MS-GREEK, SJIS и около 100 "
"других. Чтобы увидеть общий список, введите команду ``iconv --list`` в "
"терминале."

#: ../doc/1.10/reference/reference_lua/iconv.rst:60
msgid "Below is a list of all ``iconv`` functions."
msgstr "Ниже приведен перечень всех функций модуля ``iconv``."

#: ../doc/1.10/reference/reference_lua/iconv.rst:70
msgid ":ref:`iconv.new() <iconv-new>`"
msgstr ":ref:`iconv.new() <iconv-new>`"

#: ../doc/1.10/reference/reference_lua/iconv.rst:70
msgid "Create an iconv instance"
msgstr "Создание экземпляра iconv"

#: ../doc/1.10/reference/reference_lua/iconv.rst:73
msgid ":ref:`iconv.converter() <iconv-converter>`"
msgstr ":ref:`iconv.converter() <iconv-converter>`"

#: ../doc/1.10/reference/reference_lua/iconv.rst:73
msgid "Perform conversion on a string"
msgstr "Преобразование строки"

#: ../doc/1.10/reference/reference_lua/iconv.rst:81
msgid "Construct a new iconv instance."
msgstr "Создание нового iconv-экземпляра."

#: ../doc/1.10/reference/reference_lua/iconv.rst:83
msgid "the name of the encoding that we will convert to."
msgstr "название будущей кодировки."

#: ../doc/1.10/reference/reference_lua/iconv.rst:84
msgid "the name of the encoding that we will convert from."
msgstr "название используемой кодировки."

#: ../doc/1.10/reference/reference_lua/iconv.rst:86
msgid "a new iconv instance -- in effect, a callable function"
msgstr "новый экземпляр iconv -- на самом деле, вызываемая функция"

#: ../doc/1.10/reference/reference_lua/iconv.rst:89
msgid "If either parameter is not a valid name, there will be an error message."
msgstr ""
"Если значение одного из параметров представляет собой недопустимое имя, "
"появится сообщение об ошибке."

#: ../doc/1.10/reference/reference_lua/iconv.rst:93
msgid ""
"tarantool> converter = require('iconv').new('UTF8', 'ASCII')\n"
"---\n"
"..."
msgstr ""
"tarantool> converter = require('iconv').new('UTF8', 'ASCII')\n"
"---\n"
"..."

#: ../doc/1.10/reference/reference_lua/iconv.rst:103
msgid "Convert."
msgstr "Преобразование."

#: ../doc/1.10/reference/reference_lua/iconv.rst
msgid "param string input-string"
msgstr "param string input-string"

#: ../doc/1.10/reference/reference_lua/iconv.rst:105
msgid "the string to be converted (the \"from\" string)"
msgstr "строка для преобразования (\"из\")"

#: ../doc/1.10/reference/reference_lua/iconv.rst:107
msgid "the string that results from the conversion (the \"to\" string)"
msgstr "строка, получаемая в результате преобразования (\"в\")"

#: ../doc/1.10/reference/reference_lua/iconv.rst:109
msgid ""
"If anything in input-string cannot be converted, there will be an error "
"message and the result string will be unchanged."
msgstr ""
"Если что-либо в строке input-string нельзя преобразовать, появится "
"сообщение об ошибке, строка останется неизменной."

#: ../doc/1.10/reference/reference_lua/iconv.rst:114
msgid ""
"We know that the Unicode code point for \"Д\" (CYRILLIC CAPITAL LETTER "
"DE) is hexadecimal 0414 according to the character database of Unicode_. "
"Therefore that is what it will look like in UTF-16. We know that "
"Tarantool typically uses the UTF-8 character set. So make a from-UTF-8"
"-to-UTF-16 converter, use string.hex('Д') to show what Д's encoding looks"
" like in the UTF-8 source, and use string.hex('Д'-after-conversion) to "
"show what it looks like in the UTF-16 target. Since the result is 0414, "
"we see that iconv conversion works."
msgstr ""
"Мы знаем, что кодовая точка для заглавной буквы \"Д\" в Unicode "
"представляет собой шестнадцатеричное число 0414 в соответствии с таблицей"
" символов Unicode_. Таким образом, так она будет выглядеть в UTF-16. Мы "
"знаем, что как правило, Tarantool использует набор символов UTF-8. "
"Поэтому для создания конвертора из UTF-8 в UTF-16 используем "
"string.hex('Д'), чтобы показать, как выглядит кодировка Д в исходном "
"наборе символов UTF-8, а затем используем string.hex('Д'-after-"
"conversion), чтобы показать, как она будет выглядеть в целевом наборе "
"символов UTF-16. Поскольку результатом будет 0414, видим, что "
"преобразование с помощью iconv сработало."

#: ../doc/1.10/reference/reference_lua/iconv.rst:123
msgid ""
"tarantool> string.hex('Д')\n"
"---\n"
"- d094\n"
"...\n"
"\n"
"tarantool> converter = require('iconv').new('UTF16BE', 'UTF8')\n"
"---\n"
"...\n"
"\n"
"tarantool> utf16_string = converter('Д')\n"
"---\n"
"...\n"
"\n"
"tarantool> string.hex(utf16_string)\n"
"---\n"
"- '0414'\n"
"..."
msgstr ""
"tarantool> string.hex('Д')\n"
"---\n"
"- d094\n"
"...\n"
"\n"
"tarantool> converter = require('iconv').new('UTF16BE', 'UTF8')\n"
"---\n"
"...\n"
"\n"
"tarantool> utf16_string = converter('Д')\n"
"---\n"
"...\n"
"\n"
"tarantool> string.hex(utf16_string)\n"
"---\n"
"- '0414'\n"
"..."

#: ../doc/1.10/reference/reference_lua/index.rst:39
msgid "Built-in modules reference"
msgstr "Справочник по встроенным модулям"

#: ../doc/1.10/reference/reference_lua/index.rst:41
msgid "This reference covers Tarantool's built-in Lua modules."
msgstr "В данном справочнике рассматриваются встроенные Lua-модули Tarantool'а."

#: ../doc/1.10/reference/reference_lua/index.rst:45
msgid ""
"Some functions in these modules are analogs to functions from `standard "
"Lua libraries <http://www.lua.org/manual/>`_. For better results, we "
"recommend using functions from Tarantool's built-in modules."
msgstr ""
"Некоторые функции в данных модулях представляют собой аналоги функций из "
"`стандартных Lua-библиотек <http://www.lua.org/manual/>`_. Для достижения"
" наилучшего результата мы рекомендуем использовать функции из встроенных "
"модулей Tarantool'а."

#: ../doc/1.10/reference/reference_lua/index.rst:49
msgid "List of Lua modules"
msgstr "Перечень Lua-модулей"

#: ../doc/1.10/reference/reference_lua/json.rst:39
msgid "Module `json`"
msgstr "Модуль `json`"

#: ../doc/1.10/reference/reference_lua/json.rst:45
msgid ""
"The ``json`` module provides JSON manipulation routines. It is based on "
"the `Lua-CJSON module by Mark Pulford`_. For a complete manual on Lua-"
"CJSON please read `the official documentation`_."
msgstr ""
"Модуль ``json`` обеспечивает процедуры работы с форматом JSON. Он основан"
" на `модуле Lua-CJSON от Mark Pulford`_. Полное руководство по Lua-CJSON "
"включено в официальную документацию (`the official documentation`_)."

#: ../doc/1.10/reference/reference_lua/json.rst:53
msgid "Below is a list of all ``json`` functions and members."
msgstr "Ниже приведен перечень всех функций и элементов модуля ``json``."

#: ../doc/1.10/reference/reference_lua/json.rst:63
msgid ":ref:`json.encode() <json-encode>`"
msgstr ":ref:`json.encode() <json-encode>`"

#: ../doc/1.10/reference/reference_lua/json.rst:63
msgid "Convert a Lua object to a JSON string"
msgstr "Конвертация Lua-объекта в JSON-строку"

#: ../doc/1.10/reference/reference_lua/json.rst:66
msgid ":ref:`json.decode() <json-decode>`"
msgstr ":ref:`json.decode() <json-decode>`"

#: ../doc/1.10/reference/reference_lua/json.rst:66
msgid "Convert a JSON string to a Lua object"
msgstr "Конвертация JSON-строки в Lua-объект"

#: ../doc/1.10/reference/reference_lua/json.rst:69
msgid ":ref:`json.NULL <json-null>`"
msgstr ":ref:`json.NULL <json-null>`"

#: ../doc/1.10/reference/reference_lua/json.rst:69
#: ../doc/1.10/reference/reference_lua/msgpack.rst:73
#: ../doc/1.10/reference/reference_lua/yaml.rst:68
msgid "Analog of Lua's \"nil\""
msgstr "Аналог \"nil\" в языке Lua "

#: ../doc/1.10/reference/reference_lua/json.rst:79
msgid "Convert a Lua object to a JSON string."
msgstr "Конвертация Lua-объекта в JSON-строку."

#: ../doc/1.10/reference/reference_lua/json.rst:81
#: ../doc/1.10/reference/reference_lua/msgpack.rst:89
#: ../doc/1.10/reference/reference_lua/yaml.rst:80
msgid "either a scalar value or a Lua table value."
msgstr "скалярное значение или значение из Lua-таблицы."

#: ../doc/1.10/reference/reference_lua/json.rst:82
msgid "the original value reformatted as a JSON string."
msgstr "оригинальное значение, преобразованное в JSON-строку."

#: ../doc/1.10/reference/reference_lua/json.rst:87
msgid ""
"tarantool> json=require('json')\n"
"---\n"
"...\n"
"tarantool> json.encode(123)\n"
"---\n"
"- '123'\n"
"...\n"
"tarantool> json.encode({123})\n"
"---\n"
"- '[123]'\n"
"...\n"
"tarantool> json.encode({123, 234, 345})\n"
"---\n"
"- '[123,234,345]'\n"
"...\n"
"tarantool> json.encode({abc = 234, cde = 345})\n"
"---\n"
"- '{\"cde\":345,\"abc\":234}'\n"
"...\n"
"tarantool> json.encode({hello = {'world'}})\n"
"---\n"
"- '{\"hello\":[\"world\"]}'\n"
"..."
msgstr ""
"tarantool> json=require('json')\n"
"---\n"
"...\n"
"tarantool> json.encode(123)\n"
"---\n"
"- '123'\n"
"...\n"
"tarantool> json.encode({123})\n"
"---\n"
"- '[123]'\n"
"...\n"
"tarantool> json.encode({123, 234, 345})\n"
"---\n"
"- '[123,234,345]'\n"
"...\n"
"tarantool> json.encode({abc = 234, cde = 345})\n"
"---\n"
"- '{\"cde\":345,\"abc\":234}'\n"
"...\n"
"tarantool> json.encode({hello = {'world'}})\n"
"---\n"
"- '{\"hello\":[\"world\"]}'\n"
"..."

#: ../doc/1.10/reference/reference_lua/json.rst:117
msgid "Convert a JSON string to a Lua object."
msgstr "Конвертация JSON-строки в Lua-объект."

#: ../doc/1.10/reference/reference_lua/json.rst:119
msgid "a string formatted as JSON."
msgstr "строка в формате JSON."

#: ../doc/1.10/reference/reference_lua/json.rst:120
#: ../doc/1.10/reference/reference_lua/yaml.rst:91
msgid "the original contents formatted as a Lua table."
msgstr "оригинальное содержание в формате Lua-таблицы."

#: ../doc/1.10/reference/reference_lua/json.rst:125
msgid ""
"tarantool> json = require('json')\n"
"---\n"
"...\n"
"tarantool> json.decode('123')\n"
"---\n"
"- 123\n"
"...\n"
"tarantool> json.decode('[123, \"hello\"]')\n"
"---\n"
"- [123, 'hello']\n"
"...\n"
"tarantool> json.decode('{\"hello\": \"world\"}').hello\n"
"---\n"
"- world\n"
"..."
msgstr ""
"tarantool> json = require('json')\n"
"---\n"
"...\n"
"tarantool> json.decode('123')\n"
"---\n"
"- 123\n"
"...\n"
"tarantool> json.decode('[123, \"hello\"]')\n"
"---\n"
"- [123, 'hello']\n"
"...\n"
"tarantool> json.decode('{\"hello\": \"world\"}').hello\n"
"---\n"
"- world\n"
"..."

#: ../doc/1.10/reference/reference_lua/json.rst:143
msgid ""
"See the tutorial :ref:`Sum a JSON field for all tuples <c_lua_tutorial-"
"sum_a_json_field>` to see how ``json.decode()`` can fit in an "
"application."
msgstr ""
"Чтобы увидеть применение ``json.decode()`` в приложении, см. практическое"
" задание :ref:`Подсчет суммы по JSON-полям во всех кортежах "
"<c_lua_tutorial-sum_a_json_field>`."

#: ../doc/1.10/reference/reference_lua/json.rst:151
#: ../doc/1.10/reference/reference_lua/msgpack.rst:140
#: ../doc/1.10/reference/reference_lua/yaml.rst:98
msgid ""
"A value comparable to Lua \"nil\" which may be useful as a placeholder in"
" a tuple."
msgstr ""
"Значение, сопоставимое с нулевым значением \"nil\" в языке Lua, которое "
"можно использовать в качестве объекта-заполнителя в кортеже."

#: ../doc/1.10/reference/reference_lua/json.rst:156
msgid ""
"-- When nil is assigned to a Lua-table field, the field is null\n"
"tarantool> {nil, 'a', 'b'}\n"
"---\n"
"- - null\n"
"  - a\n"
"  - b\n"
"...\n"
"-- When json.NULL is assigned to a Lua-table field, the field is "
"json.NULL\n"
"tarantool> {json.NULL, 'a', 'b'}\n"
"---\n"
"- - null\n"
"  - a\n"
"  - b\n"
"...\n"
"-- When json.NULL is assigned to a JSON field, the field is null\n"
"tarantool> json.encode({field2 = json.NULL, field1 = 'a', field3 = 'c'})\n"
"---\n"
"- '{\"field2\":null,\"field1\":\"a\",\"field3\":\"c\"}'\n"
"..."
msgstr ""
"-- Когда полю Lua-таблицы присваивается nil, это поле -- null\n"
"tarantool> {nil, 'a', 'b'}\n"
"---\n"
"- - null\n"
"  - a\n"
"  - b\n"
"...\n"
"-- Когда полю Lua-таблицы присваивается json.NULL, это поле --  json.NULL"
"\n"
"tarantool> {json.NULL, 'a', 'b'}\n"
"---\n"
"- - null\n"
"  - a\n"
"  - b\n"
"...\n"
"-- Когда JSON-полю присваивается json.NULL, это поле -- null\n"
"tarantool> json.encode({field2 = json.NULL, field1 = 'a', field3 = 'c'})\n"
"---\n"
"- '{\"field2\":null,\"field1\":\"a\",\"field3\":\"c\"}'\n"
"..."

#: ../doc/1.10/reference/reference_lua/json.rst:178
msgid "The JSON output structure can be specified with ``__serialize``:"
msgstr "Структуру JSON-вывода можно указать с помощью ``__serialize``:"

#: ../doc/1.10/reference/reference_lua/json.rst:180
msgid "``__serialize=\"seq\"`` for an array"
msgstr "``__serialize=\"seq\"`` для массива"

#: ../doc/1.10/reference/reference_lua/json.rst:181
msgid "``__serialize=\"map\"`` for a map"
msgstr "``__serialize=\"map\"`` для ассоциативного массива"

#: ../doc/1.10/reference/reference_lua/json.rst:183
#: ../doc/1.10/reference/reference_lua/yaml.rst:135
msgid ""
"Serializing 'A' and 'B' with different ``__serialize`` values causes "
"different results:"
msgstr ""
"Сериализация 'A' и' B' различными значениями ``__serialize`` приводит к "
"различным результатам:"

#: ../doc/1.10/reference/reference_lua/json.rst:186
msgid ""
"tarantool> json.encode(setmetatable({'A', 'B'}, { __serialize=\"seq\"}))\n"
"---\n"
"- '[\"A\",\"B\"]'\n"
"...\n"
"tarantool> json.encode(setmetatable({'A', 'B'}, { __serialize=\"map\"}))\n"
"---\n"
"- '{\"1\":\"A\",\"2\":\"B\"}'\n"
"...\n"
"tarantool> json.encode({setmetatable({f1 = 'A', f2 = 'B'}, { "
"__serialize=\"map\"})})\n"
"---\n"
"- '[{\"f2\":\"B\",\"f1\":\"A\"}]'\n"
"...\n"
"tarantool> json.encode({setmetatable({f1 = 'A', f2 = 'B'}, { "
"__serialize=\"seq\"})})\n"
"---\n"
"- '[[]]'\n"
"..."
msgstr ""
"tarantool> json.encode(setmetatable({'A', 'B'}, { __serialize=\"seq\"}))\n"
"---\n"
"- '[\"A\",\"B\"]'\n"
"...\n"
"tarantool> json.encode(setmetatable({'A', 'B'}, { __serialize=\"map\"}))\n"
"---\n"
"- '{\"1\":\"A\",\"2\":\"B\"}'\n"
"...\n"
"tarantool> json.encode({setmetatable({f1 = 'A', f2 = 'B'}, { "
"__serialize=\"map\"})})\n"
"---\n"
"- '[{\"f2\":\"B\",\"f1\":\"A\"}]'\n"
"...\n"
"tarantool> json.encode({setmetatable({f1 = 'A', f2 = 'B'}, { "
"__serialize=\"seq\"})})\n"
"---\n"
"- '[[]]'\n"
"..."

#: ../doc/1.10/reference/reference_lua/json.rst:210
msgid "Configuration settings"
msgstr "Параметры конфигурации"

#: ../doc/1.10/reference/reference_lua/json.rst:212
msgid ""
"There are configuration settings which affect the way that Tarantool "
"encodes invalid numbers or types. They are all boolean ``true``/``false``"
" values"
msgstr ""
"Следующие параметры конфигурации определяют, как Tarantool кодирует "
"недопустимые числа или типы. Значения параметров -- логические "
"``true``/``false`` (правда/ложь)."

#: ../doc/1.10/reference/reference_lua/json.rst:215
msgid "``cfg.encode_invalid_numbers`` (default is true) -- allow nan and inf"
msgstr "``cfg.encode_invalid_numbers`` (по умолчанию, true) -- разрешить nan и inf"

#: ../doc/1.10/reference/reference_lua/json.rst:216
msgid ""
"``cfg.encode_use_tostring`` (default is false) -- use tostring for "
"unrecognizable types"
msgstr ""
"``cfg.encode_use_tostring`` (по умолчанию, false) -- использовать "
"tostring для нераспознаваемых типов"

#: ../doc/1.10/reference/reference_lua/json.rst:218
#: ../doc/1.10/reference/reference_lua/json.rst:225
msgid ""
"``cfg.encode_invalid_as_nil`` (default is false) -- use null for all "
"unrecognizable types"
msgstr ""
"``cfg.encode_invalid_as_nil`` (по умолчанию, false) -- использовать null "
"для всех нераспознаваемых типов"

#: ../doc/1.10/reference/reference_lua/json.rst:220
msgid "``cfg.encode_load_metatables`` (default is false) -- load metatables"
msgstr ""
"``cfg.encode_load_metatables`` (по умолчанию, false) -- загрузить "
"метатаблицы"

#: ../doc/1.10/reference/reference_lua/json.rst:221
msgid ""
"``cfg.encode_max_depth`` (default is 32) -- maximum nesting depth in a "
"structure"
msgstr ""

#: ../doc/1.10/reference/reference_lua/json.rst:222
#, fuzzy
msgid "``cfg.decode_invalid_numbers`` (default is true) -- allow nan and inf"
msgstr "``cfg.encode_invalid_numbers`` (по умолчанию, true) -- разрешить nan и inf"

#: ../doc/1.10/reference/reference_lua/json.rst:223
#, fuzzy
msgid ""
"``cfg.decode_use_tostring`` (default is false) -- use tostring for "
"unrecognizable types"
msgstr ""
"``cfg.encode_use_tostring`` (по умолчанию, false) -- использовать "
"tostring для нераспознаваемых типов"

#: ../doc/1.10/reference/reference_lua/json.rst:227
#, fuzzy
msgid "``cfg.decode_load_metatables`` (default is false) -- load metatables"
msgstr ""
"``cfg.encode_load_metatables`` (по умолчанию, false) -- загрузить "
"метатаблицы"

#: ../doc/1.10/reference/reference_lua/json.rst:228
msgid ""
"``cfg.decode_max_depth`` (default is 32) -- maximum nesting depth in a "
"structure"
msgstr ""

#: ../doc/1.10/reference/reference_lua/json.rst:230
msgid ""
"For example, the following code will interpret 0/0 (which is \"not a "
"number\") and 1/0 (which is \"infinity\") as special values rather than "
"nulls or errors:"
msgstr ""
"Например, следующий код интерпретирует 0/0 (что не является числом) и 1/0"
" (что представляет собой бесконечность) в качестве специальных значений, "
"а не как null или ошибку:"

#: ../doc/1.10/reference/reference_lua/json.rst:233
msgid ""
"json = require('json')\n"
"json.cfg{encode_invalid_numbers = true}\n"
"x = 0/0\n"
"y = 1/0\n"
"json.encode({1, x, y, 2})"
msgstr ""
"json = require('json')\n"
"json.cfg{encode_invalid_numbers = true}\n"
"x = 0/0\n"
"y = 1/0\n"
"json.encode({1, x, y, 2})"

#: ../doc/1.10/reference/reference_lua/json.rst:241
msgid "The result of the ``json.encode()`` request will look like this:"
msgstr "Результат запроса ``json.encode()`` будет следующим:"

#: ../doc/1.10/reference/reference_lua/json.rst:243
msgid ""
"tarantool> json.encode({1, x, y, 2})\n"
"---\n"
"- '[1,nan,inf,2]\n"
"..."
msgstr ""
"tarantool> json.encode({1, x, y, 2})\n"
"---\n"
"- '[1,nan,inf,2]\n"
"..."

#: ../doc/1.10/reference/reference_lua/json.rst:250
msgid ""
"The same configuration settings exist for json, for :ref:`MsgPack "
"<msgpack-module>`, and for :ref:`YAML <yaml-module>`."
msgstr ""
"Такие параметры конфигурации применяются для формата JSON, для "
":ref:`MsgPack <msgpack-module>` и для :ref:`YAML <yaml-module>`."

#: ../doc/1.10/reference/reference_lua/log.rst:39
msgid "Module `log`"
msgstr "Модуль `log`"

#: ../doc/1.10/reference/reference_lua/log.rst:47
msgid ""
"The Tarantool server puts all diagnostic messages in a log file specified"
" by the :ref:`log <cfg_logging-log>` configuration parameter. Diagnostic "
"messages may be either system-generated by the server's internal code, or"
" user-generated with the :samp:`log.{log_level_function_name}` function."
msgstr ""
"Сервер Tarantool'а сохраняет все сообщения об ошибке в файл журнала, "
"указанный в конфигурационном параметре :ref:`log <cfg_logging-log>`. "
"Сообщения об ошибке могут быть созданы либо системой с помощью "
"внутреннего кода сервера, либо пользователем с помощью функции "
":samp:`log.{log_level_function_name}`."

#: ../doc/1.10/reference/reference_lua/log.rst:52
msgid ""
"As explained in the description of :ref:`log_format <cfg_logging-"
"log_format>` configuration setting, there are two possible formats for "
"log entries:"
msgstr ""
"Как сказано в описании параметра :ref:`log_format <cfg_logging-"
"log_format>`, записи в журнале могут сохраняться в одном из двух "
"форматов:"

#: ../doc/1.10/reference/reference_lua/log.rst:82
msgid "Below is a list of all ``log`` functions."
msgstr "Ниже приведен перечень всех функций и элементов модуля ``log``."

#: ../doc/1.10/reference/reference_lua/log.rst:92
msgid ""
":ref:`log.error() <log-ug_message>` |br| :ref:`log.warn() <log-"
"ug_message>` |br| :ref:`log.info() <log-ug_message>` |br| "
":ref:`log.verbose() <log-ug_message>` |br| :ref:`log.debug() <log-"
"ug_message>`"
msgstr ""
":ref:`log.error() <log-ug_message>` |br| :ref:`log.warn() <log-"
"ug_message>` |br| :ref:`log.info() <log-ug_message>` |br| "
":ref:`log.verbose() <log-ug_message>` |br| :ref:`log.debug() <log-"
"ug_message>`"

#: ../doc/1.10/reference/reference_lua/log.rst:96
msgid "Write a user-generated message to a log file"
msgstr "Запись сгенерированного пользователем сообщения в файл журнала"

#: ../doc/1.10/reference/reference_lua/log.rst:103
msgid ":ref:`log.logger_pid() <log-logger_pid>`"
msgstr ":ref:`log.logger_pid() <log-logger_pid>`"

#: ../doc/1.10/reference/reference_lua/log.rst:103
msgid "Get the PID of a logger"
msgstr "Получение PID регистратора записи в журнале"

#: ../doc/1.10/reference/reference_lua/log.rst:106
msgid ":ref:`log.rotate() <log-rotate>`"
msgstr ":ref:`log.rotate() <log-rotate>`"

#: ../doc/1.10/reference/reference_lua/log.rst:106
msgid "Rotate a log file"
msgstr "Ротация файла журнала"

#: ../doc/1.10/reference/reference_lua/log.rst:118
msgid ""
"Output a user-generated message to the :ref:`log file <cfg_logging-log>`,"
" given log_level_function_name = ``error`` or ``warn`` or ``info`` or "
"``verbose`` or ``debug``."
msgstr ""
"Запись созданного пользователем сообщения в :ref:`файл журнала "
"<cfg_logging-log>` при условии, что log_level_function_name = ``error`` "
"или ``warn``, или ``info``, или ``verbose``, или ``debug``."

#: ../doc/1.10/reference/reference_lua/log.rst:122
msgid ""
"As explained in the description of the configuration setting for "
":ref:`log_level <cfg_logging-log_level>`, there are seven levels of "
"detail:"
msgstr ""
"Как поясняется в описании настроек конфигурации :ref:`log_level "
"<cfg_logging-log_level>`, есть семь уровней детализации:"

#: ../doc/1.10/reference/reference_lua/log.rst:126
msgid "2 – ``ERROR`` -- this corresponds to ``log.error(...)``"
msgstr "2 – ``ERROR`` -- соответствует ``log.error(...)``"

#: ../doc/1.10/reference/reference_lua/log.rst:128
msgid "4 – ``WARNING``  -- this corresponds to ``log.warn(...)``"
msgstr "4 – ``WARNING``  -- соответствует ``log.warn(...)``"

#: ../doc/1.10/reference/reference_lua/log.rst:129
msgid "5 – ``INFO`` -- this corresponds to ``log.info(...)``"
msgstr "5 – ``INFO`` -- соответствует ``log.info(...)``"

#: ../doc/1.10/reference/reference_lua/log.rst:130
msgid "6 – ``VERBOSE``  -- this corresponds to ``log.verbose(...)``"
msgstr "6 – ``VERBOSE``  -- соответствует ``log.verbose(...)``"

#: ../doc/1.10/reference/reference_lua/log.rst:131
msgid "7 – ``DEBUG`` -- this corresponds to ``log.debug(...)``"
msgstr "7 – ``DEBUG`` -- соответствует ``log.debug(...)``"

#: ../doc/1.10/reference/reference_lua/log.rst:133
msgid ""
"For example, if ``box.cfg.log_level`` is currently 5 (the default value),"
" then ``log.error(...)``, ``log.warn(...)`` and ``log.info(...)`` "
"messages will go to the log file. However, ``log.verbose(...)`` and "
"``log.debug(...)`` messages will not go to the log file, because they "
"correspond to higher levels of detail."
msgstr ""
"Например, если уровень ``box.cfg.log_level`` в данный момент -- 5 (по "
"умолчанию), то сообщения ``log.error(...)``, ``log.warn(...)`` и "
"``log.info(...)`` будут записываться в файл журнала. Однако, сообщения "
"``log.verbose(...)`` и ``log.debug(...)`` не будут записываться в файл "
"журнала, поскольку они соответствуют более высоким уровням детализации."

#: ../doc/1.10/reference/reference_lua/log.rst:139
#, python-format
msgid ""
"The actual output will be a line containing:  * the current timestamp, * "
"a module name, * 'E', 'W', 'I', 'V' or 'D' depending on "
"``log_level_function_name``, and * ``message``.  Output will not occur if"
" ``log_level_function_name`` is for a type greater than :ref:`log_level "
"<cfg_logging-log_level>`.  Messages may contain C-style format specifiers"
" %d or %s, so :samp:`log.error('...%d...%s', {x}, {y})` will work if "
"``x`` is a number and ``y`` is a string."
msgstr ""
"Выходное значение будет представлять собой строку, которая содержит "
"следующее: * текущая временная отметка, * название модуля, * 'E', 'W', "
"'I', 'V' или 'D' в зависимости от ``log_level_function_name`` и * "
"``сообщение``. Вывода не будет, если ``log_level_function_name`` "
"соответствует типу больше, чем :ref:`log_level <cfg_logging-log_level>`."
"  Сообщения могут содержать спецификаторы формата в стиле C: %d или %s, "
"то есть :samp:`log.error('...%d...%s', {x}, {y})` сработает, если ``x`` "
"-- это число, а ``y`` -- это строка."

#: ../doc/1.10/reference/reference_lua/log.rst:139
msgid "The actual output will be a line containing:"
msgstr ""
"Выходное значение будет представлять собой строку, которая содержит "
"следующее:"

#: ../doc/1.10/reference/reference_lua/log.rst:141
msgid "the current timestamp,"
msgstr "текущая временная отметка,"

#: ../doc/1.10/reference/reference_lua/log.rst:142
msgid "a module name,"
msgstr "название модуля,"

#: ../doc/1.10/reference/reference_lua/log.rst:143
msgid "'E', 'W', 'I', 'V' or 'D' depending on ``log_level_function_name``, and"
msgstr ", 'W', 'I', 'V' или 'D' в зависимости от ``log_level_function_name`` и"

#: ../doc/1.10/reference/reference_lua/log.rst:144
msgid "``message``."
msgstr "``сообщение``."

#: ../doc/1.10/reference/reference_lua/log.rst:146
msgid ""
"Output will not occur if ``log_level_function_name`` is for a type "
"greater than :ref:`log_level <cfg_logging-log_level>`."
msgstr ""
"Вывода не будет, если ``log_level_function_name`` соответствует типу "
"больше, чем :ref:`log_level <cfg_logging-log_level>`."

#: ../doc/1.10/reference/reference_lua/log.rst:150
#, python-format
msgid ""
"Messages may contain C-style format specifiers %d or %s, so "
":samp:`log.error('...%d...%s', {x}, {y})` will work if ``x`` is a number "
"and ``y`` is a string."
msgstr ""
"Сообщения могут содержать спецификаторы формата в стиле C: %d или %s, то "
"есть :samp:`log.error('...%d...%s', {x}, {y})` сработает, если ``x`` -- "
"это число, а ``y`` -- это строка."

#: ../doc/1.10/reference/reference_lua/log.rst:160
msgid "PID of a logger"
msgstr "PID регистратора записи в журнале"

#: ../doc/1.10/reference/reference_lua/log.rst:166
msgid "Rotate the log."
msgstr "Ротация журнала."

#: ../doc/1.10/reference/reference_lua/log.rst:174
#, python-format
msgid ""
"$ tarantool\n"
"tarantool> box.cfg{log_level=3, log='tarantool.txt'}\n"
"tarantool> log = require('log')\n"
"tarantool> log.error('Error')\n"
"tarantool> log.info('Info %s', box.info.version)\n"
"tarantool> os.exit()"
msgstr ""
"$ tarantool\n"
"tarantool> box.cfg{log_level=3, log='tarantool.txt'}\n"
"tarantool> log = require('log')\n"
"tarantool> log.error('Error')\n"
"tarantool> log.info('Info %s', box.info.version)\n"
"tarantool> os.exit()"

#: ../doc/1.10/reference/reference_lua/log.rst:183
msgid ""
"$ less tarantool.txt\n"
"2017-09-20 ... [68617] main/101/interactive C> version "
"1.7.5-31-ge939c6ea6\n"
"2017-09-20 ... [68617] main/101/interactive C> log level 3\n"
"2017-09-20 ... [68617] main/101/interactive [C]:-1 E> Error"
msgstr ""
"$ less tarantool.txt\n"
"2017-09-20 ... [68617] main/101/interactive C> version "
"1.7.5-31-ge939c6ea6\n"
"2017-09-20 ... [68617] main/101/interactive C> log level 3\n"
"2017-09-20 ... [68617] main/101/interactive [C]:-1 E> Error"

#: ../doc/1.10/reference/reference_lua/log.rst:190
msgid "The 'Error' line is visible in ``tarantool.txt`` preceded by the letter E."
msgstr "Строке 'Error' в файле ``tarantool.txt`` предшествует буква \"E\"."

#: ../doc/1.10/reference/reference_lua/log.rst:192
msgid "The 'Info' line is not present because the ``log_level`` is 3."
msgstr "Строка 'Info' отсутствует, потому что ``log_level`` -- 3."

#: ../doc/1.10/reference/reference_lua/msgpack.rst:39
msgid "Module `msgpack`"
msgstr "Модуль `msgpack`"

#: ../doc/1.10/reference/reference_lua/msgpack.rst:45
msgid ""
"The ``msgpack`` module takes strings in MsgPack_ format and decodes them,"
" or takes a series of non-MsgPack values and encodes them. Tarantool "
"makes heavy internal use of MsgPack because tuples in Tarantool are "
":ref:`stored <index-box_lua-vs-msgpack>` as MsgPack arrays."
msgstr ""
"Модуль ``msgpack`` берет строки в формате MsgPack_ и декодирует их или "
"берет ряд значений в ином формате и кодирует их в формат MsgPack. MsgPack"
" интенсивно используется в Tarantool'е, поскольку кортежи :ref:`хранятся "
"<index-box_lua-vs-msgpack>` в виде массивов в формате MsgPack."

#: ../doc/1.10/reference/reference_lua/msgpack.rst:54
msgid "Below is a list of all ``msgpack`` functions and members."
msgstr "Ниже приведен перечень всех функций и элементов модуля ``msgpack``."

#: ../doc/1.10/reference/reference_lua/msgpack.rst:64
msgid ":ref:`msgpack.encode() <msgpack-encode>`"
msgstr ":ref:`msgpack.encode() <msgpack-encode>`"

#: ../doc/1.10/reference/reference_lua/msgpack.rst:64
msgid "Convert a Lua object to an MsgPack string"
msgstr "Конвертация Lua-объекта в MsgPack-строку"

#: ../doc/1.10/reference/reference_lua/msgpack.rst:67
msgid ":ref:`msgpack.decode() <msgpack-decode>`"
msgstr ":ref:`msgpack.decode() <msgpack-decode>`"

#: ../doc/1.10/reference/reference_lua/msgpack.rst:67
#: ../doc/1.10/reference/reference_lua/msgpack.rst:70
msgid "Convert a MsgPack string to a Lua object"
msgstr "Конвертация MsgPack-строки в Lua-объект"

#: ../doc/1.10/reference/reference_lua/msgpack.rst:70
msgid ":ref:`msgpack.decode_unchecked() <msgpack-decode_unchecked>`"
msgstr ":ref:`msgpack.decode_unchecked() <msgpack-decode_unchecked>`"

#: ../doc/1.10/reference/reference_lua/msgpack.rst:73
msgid ":ref:`msgpack.NULL <msgpack-null>`"
msgstr ":ref:`msgpack.NULL <msgpack-null>`"

#: ../doc/1.10/reference/reference_lua/msgpack.rst:76
#, fuzzy
msgid ":ref:`msgpack.cfg <msgpack-cfg>`"
msgstr ":ref:`msgpack.NULL <msgpack-null>`"

#: ../doc/1.10/reference/reference_lua/msgpack.rst:76
#, fuzzy
msgid "Change configuration"
msgstr "Настройка экземпляров Tarantool’а"

#: ../doc/1.10/reference/reference_lua/msgpack.rst:87
msgid "Convert a Lua object to a MsgPack string."
msgstr "Конвертация Lua-объекта в MsgPack-строку."

#: ../doc/1.10/reference/reference_lua/msgpack.rst:90
msgid "the original value reformatted as a MsgPack string."
msgstr "оригинальное значение, преобразованное в MsgPack-строку."

#: ../doc/1.10/reference/reference_lua/msgpack.rst:97
msgid "Convert a MsgPack string to a Lua object."
msgstr "Конвертация MsgPack-строки в Lua-объект."

#: ../doc/1.10/reference/reference_lua/msgpack.rst:99
#: ../doc/1.10/reference/reference_lua/msgpack.rst:127
msgid "a string formatted as MsgPack."
msgstr "строка в формате MsgPack."

#: ../doc/1.10/reference/reference_lua/msgpack.rst:100
msgid "where to start, minimum = 1, maximum = string length, default = 1."
msgstr ""
"откуда начинать, минимальное значение = 1, максимальное = длина строки, "
"по умолчанию = 1."

#: ../doc/1.10/reference/reference_lua/msgpack.rst:105
msgid ""
"(if ``msgpack_string`` is in valid MsgPack format) the original contents "
"of ``msgpack_string``, formatted as a Lua table, (otherwise) a scalar "
"value, such as a string or a number;"
msgstr ""
"(если ``msgpack_string`` в правильном MsgPack-формате) содержимое "
"``msgpack_string`` в формате Lua-таблицы, (в противном случае) скалярное "
"значение, строка или число;"

#: ../doc/1.10/reference/reference_lua/msgpack.rst:108
msgid ""
"\"next_start_position\". If ``decode`` stops after parsing as far as byte"
" N in ``msgpack_string``, then \"next_start_position\" will equal N + 1, "
"and ``decode(msgpack_string, next_start_position)`` will continue parsing"
" from where the previous ``decode`` stopped, plus 1. Normally ``decode`` "
"parses all of ``msgpack_string``, so \"next_start_position\" will equal "
"``string.len(msgpack_string)`` + 1."
msgstr ""
"\"next_start_position\". Если расшифровка ``decode`` останавливается "
"после разбора байта N в ``msgpack_string``, то \"next_start_position\" = "
"N + 1, а ``decode(msgpack_string, next_start_position)`` продолжит разбор"
" с места остановки предыдущего ``decode`` плюс 1. Как правило, ``decode``"
" разбирает всю строку ``msgpack_string``, поэтому \"next_start_position\""
" будет равняться ``string.len(msgpack_string)`` + 1."

#: ../doc/1.10/reference/reference_lua/msgpack.rst:115
msgid "table and number"
msgstr "таблица и число"

#: ../doc/1.10/reference/reference_lua/msgpack.rst:121
msgid ""
"Convert a MsgPack string to a Lua object. Because checking is skipped, "
"``decode_unchecked()`` can operate with string pointers to buffers which "
"``decode()`` cannot handle. For an example see the :ref:`buffer <buffer-"
"module>` module."
msgstr ""
"Конвертация MsgPack-строки в Lua-объект. Поскольку проверка не "
"проводится, ``decode_unchecked()`` может работать с указателями строки в "
"буфере в отличие от ``decode()``. Пример см. в модуле :ref:`buffer "
"<buffer-module>`."

#: ../doc/1.10/reference/reference_lua/msgpack.rst:131
msgid "the original contents formatted as a Lua table;"
msgstr "оригинальное содержание в формате Lua-таблицы;"

#: ../doc/1.10/reference/reference_lua/msgpack.rst:132
msgid "the number of bytes that were decoded."
msgstr "количество декодированных байтов."

#: ../doc/1.10/reference/reference_lua/msgpack.rst:134
msgid "lua object"
msgstr "Lua-объект."

#: ../doc/1.10/reference/reference_lua/msgpack.rst:147
msgid ""
"tarantool> msgpack = require('msgpack')\n"
"---\n"
"...\n"
"tarantool> y = msgpack.encode({'a',1,'b',2})\n"
"---\n"
"...\n"
"tarantool> z = msgpack.decode(y)\n"
"---\n"
"...\n"
"tarantool> z[1], z[2], z[3], z[4]\n"
"---\n"
"- a\n"
"- 1\n"
"- b\n"
"- 2\n"
"...\n"
"tarantool> box.space.tester:insert{20, msgpack.NULL, 20}\n"
"---\n"
"- [20, null, 20]\n"
"..."
msgstr ""
"tarantool> msgpack = require('msgpack')\n"
"---\n"
"...\n"
"tarantool> y = msgpack.encode({'a',1,'b',2})\n"
"---\n"
"...\n"
"tarantool> z = msgpack.decode(y)\n"
"---\n"
"...\n"
"tarantool> z[1], z[2], z[3], z[4]\n"
"---\n"
"- a\n"
"- 1\n"
"- b\n"
"- 2\n"
"...\n"
"tarantool> box.space.tester:insert{20, msgpack.NULL, 20}\n"
"---\n"
"- [20, null, 20]\n"
"..."

#: ../doc/1.10/reference/reference_lua/msgpack.rst:172
msgid "The MsgPack output structure can be specified with ``__serialize``:"
msgstr "Структуру MsgPack-вывода можно указать с помощью ``__serialize``:"

#: ../doc/1.10/reference/reference_lua/msgpack.rst:174
msgid "``__serialize = \"seq\" or \"sequence\"`` for an array"
msgstr "``__serialize = \"seq\" или \"sequence\"`` для массива"

#: ../doc/1.10/reference/reference_lua/msgpack.rst:175
msgid "``__serialize = \"map\" or \"mapping\"`` for a map"
msgstr "``__serialize = \"map\" или \"mapping\"`` для ассоциативного массива"

#: ../doc/1.10/reference/reference_lua/msgpack.rst:177
msgid ""
"Serializing 'A' and 'B' with different ``__serialize`` values causes "
"different results. To show this, here is a routine which encodes "
"`{'A','B'}` both as an array and as a map, then displays each result in "
"hexadecimal."
msgstr ""
"Сериализация 'A' и' B' различными значениями ``__serialize`` приводит к "
"различным результатам. Чтобы показать различия, ниже приведена процедура "
"кодирования `{'A','B'}` в массив и в ассоциативный массив с выводом "
"каждого результата в виде шестнадцатеричного числа."

#: ../doc/1.10/reference/reference_lua/msgpack.rst:181
#, python-format
msgid ""
"function hexdump(bytes)\n"
"    local result = ''\n"
"    for i = 1, #bytes do\n"
"        result = result .. string.format(\"%x\", string.byte(bytes, i)) "
".. ' '\n"
"    end\n"
"    return result\n"
"end\n"
"\n"
"msgpack = require('msgpack')\n"
"m1 = msgpack.encode(setmetatable({'A', 'B'}, {\n"
"                             __serialize = \"seq\"\n"
"                          }))\n"
"m2 = msgpack.encode(setmetatable({'A', 'B'}, {\n"
"                             __serialize = \"map\"\n"
"                          }))\n"
"print('array encoding: ', hexdump(m1))\n"
"print('map encoding: ', hexdump(m2))"
msgstr ""
"function hexdump(bytes)\n"
"    local result = ''\n"
"    for i = 1, #bytes do\n"
"        result = result .. string.format(\"%x\", string.byte(bytes, i)) "
".. ' '\n"
"    end\n"
"    return result\n"
"end\n"
"\n"
"msgpack = require('msgpack')\n"
"m1 = msgpack.encode(setmetatable({'A', 'B'}, {\n"
"                             __serialize = \"seq\"\n"
"                          }))\n"
"m2 = msgpack.encode(setmetatable({'A', 'B'}, {\n"
"                             __serialize = \"map\"\n"
"                          }))\n"
"print('array encoding: ', hexdump(m1))\n"
"print('map encoding: ', hexdump(m2))"

#: ../doc/1.10/reference/reference_lua/msgpack.rst:201
msgid "**Result:**"
msgstr "**Результат:**"

#: ../doc/1.10/reference/reference_lua/msgpack.rst:206
msgid ""
"**array** encoding: 92 a1 41 a1 42\n"
"**map** encoding:   82 01 a1 41 02 a1 42"
msgstr ""
"**array** encoding: 92 a1 41 a1 42\n"
"**map** encoding:   82 01 a1 41 02 a1 42"

#: ../doc/1.10/reference/reference_lua/msgpack.rst:209
msgid "The MsgPack Specification_ page explains that the first encoding means:"
msgstr ""
"На странице спецификации MsgPack по ссылке Specification_ объясняется, "
"что значение первого результата кодирования:"

#: ../doc/1.10/reference/reference_lua/msgpack.rst:214
msgid "fixarray(2), fixstr(1), \"A\", fixstr(1), \"B\""
msgstr "fixarray(2), fixstr(1), \"A\", fixstr(1), \"B\""

#: ../doc/1.10/reference/reference_lua/msgpack.rst:216
msgid "and the second encoding means:"
msgstr "а значение второго результата кодирования:"

#: ../doc/1.10/reference/reference_lua/msgpack.rst:221
msgid "fixmap(2), key(1), fixstr(1), \"A\", key(2), fixstr(2), \"B\""
msgstr "fixmap(2), key(1), fixstr(1), \"A\", key(2), fixstr(2), \"B\""

#: ../doc/1.10/reference/reference_lua/msgpack.rst:223
msgid ""
"Here are examples for all the common types, with the Lua-table "
"representation on the left, with the MsgPack format name and encoding on "
"the right."
msgstr ""
"Ниже приведены примеры всех стандартных типов: слева отображение в "
"Lua-таблице, а справа -- имя и кодировка в формате MsgPack."

#: ../doc/1.10/reference/reference_lua/msgpack.rst:231
msgid "**Common Types and MsgPack Encodings**"
msgstr "**Стандартные типы в MsgPack-кодировке**"

#: ../doc/1.10/reference/reference_lua/msgpack.rst:239
msgid "{}"
msgstr "{}"

#: ../doc/1.10/reference/reference_lua/msgpack.rst:239
msgid "'fixmap' if metatable is 'map' = 80 otherwise 'fixarray' = 90"
msgstr ""
"'fixmap' = 80, если метатаблица -- ассоциативный массив 'map', в "
"противном случае, 'fixarray' = 90"

#: ../doc/1.10/reference/reference_lua/msgpack.rst:242
msgid "'a'"
msgstr "'a'"

#: ../doc/1.10/reference/reference_lua/msgpack.rst:242
msgid "'fixstr' = a1 61"
msgstr "'fixstr' = a1 61"

#: ../doc/1.10/reference/reference_lua/msgpack.rst:244
msgid "'false' = c2"
msgstr "'false' = c2"

#: ../doc/1.10/reference/reference_lua/msgpack.rst:246
msgid "'true' = c3"
msgstr "'true' = c3"

#: ../doc/1.10/reference/reference_lua/msgpack.rst:248
msgid "127"
msgstr "127"

#: ../doc/1.10/reference/reference_lua/msgpack.rst:248
msgid "'positive fixint' = 7f"
msgstr "'positive fixint' = 7f"

#: ../doc/1.10/reference/reference_lua/msgpack.rst:250
msgid "65535"
msgstr "65535"

#: ../doc/1.10/reference/reference_lua/msgpack.rst:250
msgid "'uint 16' = cd ff ff"
msgstr "'uint 16' = cd ff ff"

#: ../doc/1.10/reference/reference_lua/msgpack.rst:252
msgid "4294967295"
msgstr "4294967295"

#: ../doc/1.10/reference/reference_lua/msgpack.rst:252
msgid "'uint 32' = ce ff ff ff ff"
msgstr "'uint 32' = ce ff ff ff ff"

#: ../doc/1.10/reference/reference_lua/msgpack.rst:254
msgid "'nil' = c0"
msgstr "'nil' = c0"

#: ../doc/1.10/reference/reference_lua/msgpack.rst:256
msgid "same as nil"
msgstr "то же, что и nil"

#: ../doc/1.10/reference/reference_lua/msgpack.rst:258
msgid "[0] = 5"
msgstr "[0] = 5"

#: ../doc/1.10/reference/reference_lua/msgpack.rst:258
msgid ""
"'fixmap(1)' + 'positive fixint' (for the key) + 'positive fixint' (for "
"the value) = 81 00 05"
msgstr ""
"'fixmap(1)' + 'positive fixint' (для ключа) + 'positive fixint' (для "
"значения) = 81 00 05"

#: ../doc/1.10/reference/reference_lua/msgpack.rst:261
msgid "[0] = nil"
msgstr "[0] = nil"

#: ../doc/1.10/reference/reference_lua/msgpack.rst:261
msgid "'fixmap(0)' = 80 -- nil is not stored when it is a missing map value"
msgstr ""
"'fixmap(0)' = 80 -- nil не хранится, если это отсутствующее значение "
"ассоциативного массива"

#: ../doc/1.10/reference/reference_lua/msgpack.rst:264
msgid "1.5"
msgstr "1,5"

#: ../doc/1.10/reference/reference_lua/msgpack.rst:264
msgid "'float 64' = cb 3f f8 00 00 00 00 00 00"
msgstr "'float 64' = cb 3f f8 00 00 00 00 00 00"

#: ../doc/1.10/reference/reference_lua/msgpack.rst:271
msgid ""
"Some MsgPack configuration settings can be changed, in the same way that "
"they can be changed for json. See :ref:`Module JSON <json-module_cfg>` "
"for a list of some configuration settings. (The same configuration "
"settings exist for json, for MsgPack, and for  :ref:`YAML <yaml-"
"module>`.)"
msgstr ""

#: ../doc/1.10/reference/reference_lua/msgpack.rst:276
msgid ""
"For example, if ``msgpack.cfg.encode_invalid_numbers = true`` (the "
"default), then nan and inf are legal values. If that is not desirable, "
"then ensure that ``msgpack.encode()`` will not accept them, by saying "
"``msgpack.cfg{encode_invalid_numbers = false}``, thus:"
msgstr ""

#: ../doc/1.10/reference/reference_lua/msgpack.rst:281
msgid ""
" tarantool> msgpack = require('msgpack'); "
"msgpack.cfg{encode_invalid_numbers = true}\n"
" ---\n"
" ...\n"
" tarantool> msgpack.decode(msgpack.encode{1, 0 / 0, 1 / 0, false})\n"
" ---\n"
" - [1, -nan, inf, false]\n"
" - 22\n"
" ...\n"
" tarantool> msgpack.cfg{encode_invalid_numbers = false}\n"
"---\n"
"...\n"
" tarantool> msgpack.decode(msgpack.encode{1, 0 / 0, 1 / 0, false})\n"
" ---\n"
" - error: ... number must not be NaN or Inf'\n"
"..."
msgstr ""

#: ../doc/1.10/reference/reference_lua/net_box.rst:39
msgid "Module `net.box`"
msgstr "Модуль `net.box`"

#: ../doc/1.10/reference/reference_lua/net_box.rst:45
msgid ""
"The ``net.box`` module contains connectors to remote database systems. "
"One variant, to be discussed later, is for connecting to MySQL or MariaDB"
" or PostgreSQL (see :ref:`SQL DBMS modules <dbms_modules>` reference). "
"The other variant, which is discussed in this section, is for connecting "
"to Tarantool server instances via a network."
msgstr ""
"Модуль ``net.box`` включает в себя коннекторы для удаленных систем с "
"базами данных. Одним из вариантов, который рассматривается позднее, "
"является подключение к MySQL, MariaDB или PostgreSQL (см. справочник по "
":ref:`Модулям  СУБД SQL <dbms_modules>`). Другим вариантом, который "
"рассматривается в данном разделе, является подключение к экземплярам "
"Tarantool-сервера по сети."

#: ../doc/1.10/reference/reference_lua/net_box.rst:51
msgid "You can call the following methods:"
msgstr "Можно вызвать следующие методы:"

#: ../doc/1.10/reference/reference_lua/net_box.rst:53
msgid ""
"``require('net.box')`` to get a ``net.box`` object (named ``net_box`` for"
" examples in this section),"
msgstr ""
"``require('net.box')`` для получения объекта ``net.box`` (который "
"называется ``net_box`` для примеров в данном разделе),"

#: ../doc/1.10/reference/reference_lua/net_box.rst:55
msgid ""
"``net_box.connect()`` to connect and get a connection object (named "
"``conn`` for examples in this section),"
msgstr ""
"``net_box.connect()`` для подключения и получения объекта подключения "
"(который называется ``conn`` для примеров в данном разделе),"

#: ../doc/1.10/reference/reference_lua/net_box.rst:57
msgid ""
"other ``net.box()`` routines, passing ``conn:``, to execute requests on "
"the remote database system,"
msgstr ""
"другие процедуры ``net.box()``, передающие ``conn:`` для выполнения "
"запросов в удаленной системе базы данных,"

#: ../doc/1.10/reference/reference_lua/net_box.rst:59
msgid "``conn:close`` to disconnect."
msgstr "``conn:close`` для отключения."

#: ../doc/1.10/reference/reference_lua/net_box.rst:61
msgid ""
"All ``net.box`` methods are fiber-safe, that is, it is safe to share and "
"use the same connection object across multiple concurrent fibers. In fact"
" that is perhaps the best programming practice with Tarantool. When "
"multiple fibers use the same connection, all requests are pipelined "
"through the same network socket, but each fiber gets back a correct "
"response. Reducing the number of active sockets lowers the overhead of "
"system calls and increases the overall server performance. However for "
"some cases a single connection is not enough —- for example, when it is "
"necessary to prioritize requests or to use different authentication IDs."
msgstr ""
"Все методы ``net.box`` безопасны для файберов, то есть можно безопасно "
"обмениваться и использовать один и тот же объект подключения в нескольких"
" файберах одновременно. Фактически так лучше всего работать в "
"Tarantool'е. Когда несколько файберов используют одно соединение, все "
"запросы передаются по одному сетевому сокету, но каждый файбер получает "
"правильный ответ. Уменьшение количества активных сокетов снижает затрату "
"ресурсов на системные вызовы и увеличивает общую производительность "
"сервера. Однако, в некоторых случаях отдельного соединения недостаточно "
"-- например, когда необходимо отдавать приоритет разным запросам или "
"использовать различные идентификаторы при аутентификации."

#: ../doc/1.10/reference/reference_lua/net_box.rst:70
msgid ""
"Most ``net.box`` methods allow a final ``{options}`` argument, which can "
"be:"
msgstr ""
"В большинстве методов ``net.box`` можно использовать заключительный "
"аргумент ``{options}``, который может быть:"

#: ../doc/1.10/reference/reference_lua/net_box.rst:72
msgid ""
"``{timeout=...}``. For example, a method whose final argument is "
"``{timeout=1.5}`` will stop after 1.5 seconds on the local node, although"
" this does not guarantee that execution will stop on the remote server "
"node."
msgstr ""
"``{timeout=...}``. Например, метод с заключительным аргументом "
"``{timeout=1.5}`` остановится через 1,5 секунды на локальном узле, хотя "
"это не гарантирует, что выполнение остановится на удаленном сервере."

#: ../doc/1.10/reference/reference_lua/net_box.rst:75
msgid "``{buffer=...}``. For an example see :ref:`buffer module <buffer-module>`."
msgstr "``{buffer=...}``. Например, см. :ref:`модуль buffer <buffer-module>`."

#: ../doc/1.10/reference/reference_lua/net_box.rst:76
msgid ""
"``{is_async=...}``. For example, a method whose final argument is "
"``{is_async=true}`` will not wait for the result of a request. See the "
":ref:`is_async <net_box-is_async>` description."
msgstr ""
"``{is_async=...}``. Например, метод с заключительным аргументом "
"``{is_async=true}`` не будет ждать результата выполнения запроса. См. "
"описание :ref:`is_async <net_box-is_async>`."

#: ../doc/1.10/reference/reference_lua/net_box.rst:79
msgid ""
"``{on_push=... on_push_ctx=...}``. For receiving out-of-band messages. "
"See the :ref:`box.session.push <box_session-push>` description."
msgstr ""
"``{on_push=... on_push_ctx=...}``. Для получения внеполосных сообщений. "
"См. описание :ref:`box.session.push <box_session-push>`."

#: ../doc/1.10/reference/reference_lua/net_box.rst:82
msgid "The diagram below shows possible connection states and transitions:"
msgstr ""
"На диаграмме ниже представлены возможные состояния и варианты перехода из"
" одного состояния в другое:"

#: ../doc/1.10/reference/reference_lua/net_box.rst:90
msgid "On this diagram:"
msgstr "На этой диаграмме:"

#: ../doc/1.10/reference/reference_lua/net_box.rst:92
msgid "The state machine starts in the 'initial' state."
msgstr "Работа начинается с начального состояния 'initial'."

#: ../doc/1.10/reference/reference_lua/net_box.rst:94
msgid ""
"``net_box.connect()`` method changes the state to 'connecting' and spawns"
" a worker fiber."
msgstr ""
"Выполнение метода ``net_box.connect()`` переводит состояние в "
"'connecting', создается рабочий файбер."

#: ../doc/1.10/reference/reference_lua/net_box.rst:96
msgid ""
"If authentication and schema upload are required, it's possible later on "
"to re-enter the 'fetch_schema' state from 'active' if a request fails due"
" to a schema version mismatch error, so schema reload is triggered."
msgstr ""
"Если требуются аутентификация и загрузка схемы, можно позднее повторно "
"войти в состояние загрузки схемы 'fetch_schema' из активного 'active', "
"если запрос не будет выполнен из-за ошибки несовпадения версий схемы, то "
"есть будет вызвана перезагрузка схемы."

#: ../doc/1.10/reference/reference_lua/net_box.rst:100
msgid ""
"``conn.close()`` method sets the state to 'closed' and kills the worker. "
"If the transport is already in the 'error' state, ``close()`` does "
"nothing."
msgstr ""
"Метод ``conn.close()`` изменяет состояние на закрытое 'closed' и "
"отключает рабочий процесс. Если транспорт уже находится в состоянии "
"ошибки 'error', ``close()`` не делает ничего."

#: ../doc/1.10/reference/reference_lua/net_box.rst:107
msgid "Below is a list of all ``net.box`` functions."
msgstr "Ниже приведен перечень всех функций модуля ``net.box``."

#: ../doc/1.10/reference/reference_lua/net_box.rst:117
msgid ""
":ref:`net_box.connect() <net_box-connect>` |br| :ref:`net_box.new() "
"<net_box-new>`"
msgstr ""
":ref:`net_box.connect() <net_box-connect>` |br| :ref:`net_box.new() "
"<net_box-new>`"

#: ../doc/1.10/reference/reference_lua/net_box.rst:118
msgid "Create a connection"
msgstr "Создание подключения"

#: ../doc/1.10/reference/reference_lua/net_box.rst:122
msgid ":ref:`conn:ping() <conn-ping>`"
msgstr ":ref:`conn:ping() <conn-ping>`"

#: ../doc/1.10/reference/reference_lua/net_box.rst:122
msgid "Execute a PING command"
msgstr "Выполнение команды проверки состояния PING"

#: ../doc/1.10/reference/reference_lua/net_box.rst:125
msgid ":ref:`conn:wait_connected() <conn-wait_connected>`"
msgstr ":ref:`conn:wait_connected() <conn-wait_connected>`"

#: ../doc/1.10/reference/reference_lua/net_box.rst:125
msgid "Wait for a connection to be active or closed"
msgstr "Ожидание активности или закрытия подключения"

#: ../doc/1.10/reference/reference_lua/net_box.rst:128
msgid ":ref:`conn:is_connected() <conn-is_connected>`"
msgstr ":ref:`conn:is_connected() <conn-is_connected>`"

#: ../doc/1.10/reference/reference_lua/net_box.rst:128
msgid "Check if a connection is active or closed"
msgstr "Проверка активности или закрытия подключения"

#: ../doc/1.10/reference/reference_lua/net_box.rst:131
msgid ":ref:`conn:wait_state() <conn-wait_state>`"
msgstr ":ref:`conn:wait_state() <conn-wait_state>`"

#: ../doc/1.10/reference/reference_lua/net_box.rst:131
msgid "Wait for a target state"
msgstr "Ожидание нужного состояния"

#: ../doc/1.10/reference/reference_lua/net_box.rst:134
msgid ":ref:`conn:close() <conn-close>`"
msgstr ":ref:`conn:close() <conn-close>`"

#: ../doc/1.10/reference/reference_lua/net_box.rst:134
msgid "Close a connection"
msgstr "Закрытие подключения"

#: ../doc/1.10/reference/reference_lua/net_box.rst:137
msgid ":ref:`conn.space.space-name:select{field-value} <conn-select>`"
msgstr ":ref:`conn.space.space-name:select{field-value} <conn-select>`"

#: ../doc/1.10/reference/reference_lua/net_box.rst:140
msgid ":ref:`conn.space.space-name:get{field-value} <conn-get>`"
msgstr ":ref:`conn.space.space-name:get{field-value} <conn-get>`"

#: ../doc/1.10/reference/reference_lua/net_box.rst:143
msgid ":ref:`conn.space.space-name:insert{field-value} <conn-insert>`"
msgstr ":ref:`conn.space.space-name:insert{field-value} <conn-insert>`"

#: ../doc/1.10/reference/reference_lua/net_box.rst:146
msgid ":ref:`conn.space.space-name:replace{field-value} <conn-replace>`"
msgstr ":ref:`conn.space.space-name:replace{field-value} <conn-replace>`"

#: ../doc/1.10/reference/reference_lua/net_box.rst:149
msgid ":ref:`conn.space.space-name:update{field-value} <conn-update>`"
msgstr ":ref:`conn.space.space-name:update{field-value} <conn-update>`"

#: ../doc/1.10/reference/reference_lua/net_box.rst:152
msgid ":ref:`conn.space.space-name:upsert{field-value} <conn-upsert>`"
msgstr ":ref:`conn.space.space-name:upsert{field-value} <conn-upsert>`"

#: ../doc/1.10/reference/reference_lua/net_box.rst:155
msgid ":ref:`conn.space.space-name:delete{field-value} <conn-delete>`"
msgstr ":ref:`conn.space.space-name:delete{field-value} <conn-delete>`"

#: ../doc/1.10/reference/reference_lua/net_box.rst:158
msgid ":ref:`conn:eval() <net_box-eval>`"
msgstr ":ref:`conn:eval() <net_box-eval>`"

#: ../doc/1.10/reference/reference_lua/net_box.rst:158
msgid "Evaluate and execute the expression in a string"
msgstr "Оценка и выполнение выражения в строке"

#: ../doc/1.10/reference/reference_lua/net_box.rst:161
msgid ":ref:`conn:call() <net_box-call>`"
msgstr ":ref:`conn:call() <net_box-call>`"

#: ../doc/1.10/reference/reference_lua/net_box.rst:161
msgid "Call a stored procedure"
msgstr "Вызов хранимой процедуры"

#: ../doc/1.10/reference/reference_lua/net_box.rst:164
msgid ":ref:`conn:timeout() <conn-timeout>`"
msgstr ":ref:`conn:timeout() <conn-timeout>`"

#: ../doc/1.10/reference/reference_lua/net_box.rst:164
msgid "Set a timeout"
msgstr "Установка времени ожидания"

#: ../doc/1.10/reference/reference_lua/net_box.rst:180
msgid ""
"The names ``connect()`` and ``new()`` are synonyms: ``connect()`` is "
"preferred; ``new()`` is retained for backward compatibility."
msgstr ""
"Имена ``connect()`` и ``new()`` являются синонимами: предпочтительным "
"будет ``connect()``, а ``new()`` обеспечивает поддержку обратной "
"совместимости."

#: ../doc/1.10/reference/reference_lua/net_box.rst:183
msgid ""
"Create a new connection. The connection is established on demand, at the "
"time of the first request. It can be re-established automatically after a"
" disconnect (see ``reconnect_after`` option below). The returned ``conn``"
" object supports methods for making remote requests, such as select, "
"update or delete."
msgstr ""
"Создание нового подключения. Подключение устанавливается по требованию во"
" время первого запроса. Можно повторно установить подключение "
"автоматически после отключения (см. ниже опцию ``reconnect_after``). "
"Возвращается объект ``conn``, который поддерживает методы создание "
"удаленных запросов, таких как select, update или delete."

#: ../doc/1.10/reference/reference_lua/net_box.rst:189
msgid ""
"For a local Tarantool server, there is a pre-created always-established "
"connection object named :samp:`{net_box}.self`. Its purpose is to make "
"polymorphic use of the ``net_box`` API easier. Therefore :samp:`conn = "
"{net_box}.connect('localhost:3301')` can be replaced by :samp:`conn = "
"{net_box}.self`. However, there is an important difference between the "
"embedded connection and a remote one. With the embedded connection, "
"requests which do not modify data do not yield. When using a remote "
"connection, due to :ref:`the implicit rules <atomic-implicit-yields>` any"
" request can yield, and database state may have changed by the time it "
"regains control."
msgstr ""
"Для локального Tarantool-сервера есть заданный объект всегда "
"установленного подключения под названием :samp:`{net_box}.self`. Он "
"создан с целью облегчить полиморфное использование API модуля "
"``net_box``. Таким образом, :samp:`conn = "
"{net_box}.connect('localhost:3301')` можно заменить на :samp:`conn = "
"{net_box}.self`. Однако, есть важно отличие встроенного подключения от "
"удаленного. При встроенном подключении запросы без изменения данных не "
"передают управление. При использовании удаленного подключения любой "
"запрос может передавать управление исходя из :ref:`правил неявной "
"передачи управления <atomic-implicit-yields>`, и состояние базы данных "
"может измениться к тому времени, как управление вернется."

#: ../doc/1.10/reference/reference_lua/net_box.rst:201
msgid "Possible options:"
msgstr "Возможные опции"

#: ../doc/1.10/reference/reference_lua/net_box.rst:203
msgid ""
"`wait_connected`: by default, connection creation is blocked until the "
"connection is established, but passing ``wait_connected=false`` makes it "
"return immediately. Also, passing a timeout makes it wait before "
"returning (e.g. ``wait_connected=1.5`` makes it wait at most 1.5 "
"seconds)."
msgstr ""
"`wait_connected`: по умолчанию, создание подключения блокируется до тех "
"пор, пока подключение не будет установлено, но передача "
"``wait_connected=false`` заставит метод сразу же вернуться. Передача "
"времени ожидания заставит метод ждать до возвращения (например, "
"``wait_connected=1.5`` заставит ожидать подключения максимум 1,5 "
"секунды)."

#: ../doc/1.10/reference/reference_lua/net_box.rst:209
msgid ""
"In the presence of ``reconnect_after``, ``wait_connected`` ignores "
"transient failures. The wait completes once the connection is established"
" or is closed explicitly."
msgstr ""
"Если присутствует ``reconnect_after``, ``wait_connected`` проигнорирует "
"неустойчивые отказы. Ожидание заканчивается, когда подключение "
"установлено или явным образом закрыто."

#: ../doc/1.10/reference/reference_lua/net_box.rst:212
msgid ""
"`reconnect_after`: a ``net.box`` instance automatically reconnects any "
"time the connection is broken or if a connection attempt fails. This "
"makes transient network failures become transparent to the application. "
"Reconnect happens automatically in the background, so queries/requests "
"that suffered due to connectivity loss are transparently retried. The "
"number of retries is unlimited, connection attempts are done over the "
"specified timeout (e.g. ``reconnect_after=5`` for 5 secs). Once a "
"connection is explicitly closed, or once the Lua garbage collector "
"removes it, reconnects stop."
msgstr ""
"`reconnect_after`: ``net.box`` автоматически подключается повторно в "
"случае разрыва соединения или провала попытки подключения. В таком случае"
" неустойчивые сетевые отказы становятся очевидными. Повторное подключение"
" выполняется автоматически в фоновом режиме, поэтому запросы/обращения, "
"не выполненные по причине потери соединения, явным образом выполняются "
"повторно. Количество повторов не ограничено, попытки подключения "
"выполняются в течение указанного времени ожидания (например, "
"``reconnect_after=5`` -- 5 секунд). После явного закрытия подключения или"
" удаления сборщиком мусора в Lua попытки соединения повторно не "
"выполняются."

#: ../doc/1.10/reference/reference_lua/net_box.rst:222
msgid ""
"`call_16`: [since 1.7.2] by default, ``net.box`` connections comply with "
"a new binary protocol command for CALL, which is not backward compatible "
"with previous versions. The new CALL no longer restricts a function to "
"returning an array of tuples and allows returning an arbitrary "
"MsgPack/JSON result, including scalars, nil and void (nothing). The old "
"CALL is left intact for backward compatibility. It will be removed in the"
" next major release. All programming language drivers will be gradually "
"changed to use the new CALL. To connect to a Tarantool instance that uses"
" the old CALL, specify ``call_16=true``."
msgstr ""
"`call_16`: [с 1.7.2] по умолчанию, подключения ``net.box`` соответствуют "
"команде CALL нового бинарного протокола, который не поддерживает обратную"
" совместимость с предыдущими версиями. Команда нового бинарного протокола"
" для вызова CALL больше не ограничивает функцию в возврате массива "
"кортежей и позволяет возвращать произвольный результат в формате "
"MsgPack/JSON, включая scalar (скалярные значения), nil (нулевые значения)"
" и void (пусто). Старый метод CALL оставлен нетронутым для обратной "
"совместимости. В следующей основной версии он будет удален. Все драйверы "
"для языков программирования будут постепенно переведены на использование "
"нового метода CALL. Для подключения к экземпляру Tarantool'а, в котором "
"используется старый метод CALL, укажите ``call_16=true``."

#: ../doc/1.10/reference/reference_lua/net_box.rst:231
msgid ""
"`console`: depending on the option's value, the connection supports "
"different methods (as if instances of different classes were returned). "
"With ``console = true``, you can use ``conn`` methods ``close()``, "
"``is_connected()``, ``wait_state()``, ``eval()`` (in this case, both "
"binary and Lua console network protocols are supported). With ``console ="
" false`` (default), you can also use ``conn`` database methods (in this "
"case, only the binary protocol is supported). Deprecation notice: "
"``console = true`` is deprecated, users should use "
":ref:`console.connect() <console-connect>` instead."
msgstr ""
"`console`: в зависимости от значения параметра поддерживаются различные "
"методы (как если бы возвращались экземпляры разных классов). Если "
"``console = true``, можно использовать методы ``conn``: ``close()``, "
"``is_connected()``, ``wait_state()``, ``eval()`` (в этом случае "
"поддерживаются и бинарный сетевой протокол, и протокол Lua-консоли). Если"
" ``console = false`` (по умолчанию), также можно использовать методы "
"``conn`` для работы с базой данных (в этом случае поддерживается только "
"бинарный протокол). Устарел: ``console = true`` объявлен устаревшим, "
"вместо него следует использовать :ref:`console.connect() <console-"
"connect>`."

#: ../doc/1.10/reference/reference_lua/net_box.rst:239
msgid ""
"`connect_timeout`: number of seconds to wait before returning \"error: "
"Connection timed out\"."
msgstr ""
"`connect_timeout`: количество секунд ожидания до возврата ошибки \"error:"
" Connection timed out\"."

#: ../doc/1.10/reference/reference_lua/net_box.rst:241
msgid "the :ref:`URI <index-uri>` of the target for the connection"
msgstr ":ref:`URI <index-uri>` объекта подключения"

#: ../doc/1.10/reference/reference_lua/net_box.rst:242
msgid ""
"possible options are `wait_connected`, `reconnect_after`, `call_16` and "
"`console`"
msgstr ""
"возможные опции: `wait_connected`, `reconnect_after`, `call_16` и "
"`console`"

#: ../doc/1.10/reference/reference_lua/net_box.rst:243
msgid "conn object"
msgstr "объект подключения"

#: ../doc/1.10/reference/reference_lua/net_box.rst:248
msgid ""
"conn = net_box.connect('localhost:3301')\n"
"conn = net_box.connect('127.0.0.1:3302', {wait_connected = false})\n"
"conn = net_box.connect('127.0.0.1:3303', {reconnect_after = 5, call_16 = "
"true})"
msgstr ""
"conn = net_box.connect('localhost:3301')\n"
"conn = net_box.connect('127.0.0.1:3302', {wait_connected = false})\n"
"conn = net_box.connect('127.0.0.1:3303', {reconnect_after = 5, call_16 = "
"true})"

#: ../doc/1.10/reference/reference_lua/net_box.rst:260
msgid "Execute a PING command."
msgstr "Выполнение команды проверки состояния PING."

#: ../doc/1.10/reference/reference_lua/net_box.rst:262
msgid "true on success, false on error"
msgstr "true (правда), если выполнено, false (ложь) в случае ошибки"

#: ../doc/1.10/reference/reference_lua/net_box.rst:267
msgid "net_box.self:ping()"
msgstr "net_box.self:ping()"

#: ../doc/1.10/reference/reference_lua/net_box.rst:275
msgid "Wait for connection to be active or closed."
msgstr "Ожидание активности или закрытия подключения."

#: ../doc/1.10/reference/reference_lua/net_box.rst:277
#: ../doc/1.10/reference/reference_lua/net_box.rst:309
msgid "in seconds"
msgstr "в секундах"

#: ../doc/1.10/reference/reference_lua/net_box.rst:278
msgid "true when connected, false on failure."
msgstr "true (правда) при подключении, false (ложь), если не выполнено."

#: ../doc/1.10/reference/reference_lua/net_box.rst:283
msgid "net_box.self:wait_connected()"
msgstr "net_box.self:wait_connected()"

#: ../doc/1.10/reference/reference_lua/net_box.rst:291
msgid "Show whether connection is active or closed."
msgstr "Проверка активности или закрытия подключения."

#: ../doc/1.10/reference/reference_lua/net_box.rst:293
msgid "true if connected, false on failure."
msgstr "true (правда) при подключении, false (ложь), если не выполнено."

#: ../doc/1.10/reference/reference_lua/net_box.rst:298
msgid "net_box.self:is_connected()"
msgstr "net_box.self:is_connected()"

#: ../doc/1.10/reference/reference_lua/net_box.rst:306
msgid "[since 1.7.2] Wait for a target state."
msgstr "[с 1.7.2] Ожидание нужного состояния."

#: ../doc/1.10/reference/reference_lua/net_box.rst:308
msgid "target states"
msgstr "необходимое состояние"

#: ../doc/1.10/reference/reference_lua/net_box.rst:310
msgid ""
"true when a target state is reached, false on timeout or connection "
"closure"
msgstr ""
"true (правда) при подключении, false (ложь) при окончании времени "
"ожидания или закрытии подключения"

#: ../doc/1.10/reference/reference_lua/net_box.rst:315
msgid ""
"-- wait infinitely for 'active' state:\n"
"conn:wait_state('active')\n"
"\n"
"-- wait for 1.5 secs at most:\n"
"conn:wait_state('active', 1.5)\n"
"\n"
"-- wait infinitely for either `active` or `fetch_schema` state:\n"
"conn:wait_state({active=true, fetch_schema=true})"
msgstr ""
"-- бесконечное ожидание состояния 'active':\n"
"conn:wait_state('active')\n"
"\n"
"-- ожидание в течение максимум 1,5 секунд:\n"
"conn:wait_state('active', 1.5)\n"
"\n"
"-- бесконечное ожидание состояния `active` или `fetch_schema`:\n"
"conn:wait_state({active=true, fetch_schema=true})"

#: ../doc/1.10/reference/reference_lua/net_box.rst:330
msgid "Close a connection."
msgstr "Закрытие подключения."

#: ../doc/1.10/reference/reference_lua/net_box.rst:332
msgid ""
"Connection objects are destroyed by the Lua garbage collector, just like "
"any other objects in Lua, so an explicit destruction is not mandatory. "
"However, since close() is a system call, it is good programming practice "
"to close a connection explicitly when it is no longer needed, to avoid "
"lengthy stalls of the garbage collector."
msgstr ""
"Объекты подключения удаляются сборщиком мусора в Lua, как и любой другой "
"Lua-объект, поэтому удалять их явным образом необязательно. Однако, "
"поскольку close() представляет собой системный вызов, лучше всего закрыть"
" соединение явным образом, когда оно больше не используется, с целью "
"ускорения работы сборщика мусора."

#: ../doc/1.10/reference/reference_lua/net_box.rst:339
msgid "conn:close()"
msgstr "conn:close()"

#: ../doc/1.10/reference/reference_lua/net_box.rst:347
msgid ""
":samp:`conn.space.{space-name}:select`:code:`({...})` is the remote-call "
"equivalent of the local call :samp:`box.space.{space-"
"name}:select`:code:`{...}`."
msgstr ""
":samp:`conn.space.{имя-спейса}:select`:code:`({...})` -- это удаленный "
"вызов, аналогичный локальному вызову "
":samp:`box.space.{имя-спейса}:select`:code:`{...}`."

#: ../doc/1.10/reference/reference_lua/net_box.rst:352
msgid "conn.space.testspace:select({1,'B'}, {timeout=1})"
msgstr "conn.space.testspace:select({1,'B'}, {timeout=1})"

#: ../doc/1.10/reference/reference_lua/net_box.rst:358
msgid ""
"Due to :ref:`the implicit yield rules <atomic-implicit-yields>` a local "
":samp:`box.space.{space-name}:select`:code:`{...}` does not yield, but a "
"remote :samp:`conn.space.{space-name}:select`:code:`{...}` call does "
"yield, so global variables or database tuples data may change when a "
"remote :samp:`conn.space.{space-name}:select`:code:`{...}` occurs."
msgstr ""
"Исходя из :ref:`правил неявной передачи управления <atomic-implicit-"
"yields>`, локальный запрос "
":samp:`box.space.{имя-спейса}:select`:code:`{...}` не передает "
"управление, а удаленный "
":samp:`conn.space.{имя-спейса}:select`:code:`{...}` передаст, поэтому "
"глобальные переменные или кортежи в базе данных могут измениться во время"
" удаленного :samp:`conn.space.{имя-спейса}:select`:code:`{...}`."

#: ../doc/1.10/reference/reference_lua/net_box.rst:369
msgid ""
":samp:`conn.space.{space-name}:get(...)` is the remote-call equivalent of"
" the local call :samp:`box.space.{space-name}:get(...)`."
msgstr ""
":samp:`conn.space.{имя-спейса}:get(...)` -- это удаленный вызов, "
"аналогичный локальному вызову :samp:`box.space.{имя-спейса}:get(...)`."

#: ../doc/1.10/reference/reference_lua/net_box.rst:374
msgid "conn.space.testspace:get({1})"
msgstr "conn.space.testspace:get({1})"

#: ../doc/1.10/reference/reference_lua/net_box.rst:382
msgid ""
":samp:`conn.space.{space-name}:insert(...)` is the remote-call equivalent"
" of the local call :samp:`box.space.{space-name}:insert(...)`."
msgstr ""
":samp:`conn.space.{имя-спейса}:insert(...)` -- это удаленный вызов, "
"аналогичный локальному вызову :samp:`box.space.{имя-спейса}:insert(...)`."

#: ../doc/1.10/reference/reference_lua/net_box.rst:387
msgid "conn.space.testspace:insert({2,3,4,5}, {timeout=1.1})"
msgstr "conn.space.testspace:insert({2,3,4,5}, {timeout=1.1})"

#: ../doc/1.10/reference/reference_lua/net_box.rst:395
msgid ""
":samp:`conn.space.{space-name}:replace(...)` is the remote-call "
"equivalent of the local call :samp:`box.space.{space-name}:replace(...)`."
msgstr ""
":samp:`conn.space.{имя-спейса}:replace(...)` -- это удаленный вызов, "
"аналогичный локальному вызову "
":samp:`box.space.{имя-спейса}:replace(...)`."

#: ../doc/1.10/reference/reference_lua/net_box.rst:400
msgid "conn.space.testspace:replace({5,6,7,8})"
msgstr "conn.space.testspace:replace({5,6,7,8})"

#: ../doc/1.10/reference/reference_lua/net_box.rst:408
msgid ""
":samp:`conn.space.{space-name}:update(...)` is the remote-call equivalent"
" of the local call :samp:`box.space.{space-name}:update(...)`."
msgstr ""
":samp:`conn.space.{имя-спейса}:update(...)` -- это удаленный вызов, "
"аналогичный локальному вызову :samp:`box.space.{имя-спейса}:update(...)`."

#: ../doc/1.10/reference/reference_lua/net_box.rst:413
msgid "conn.space.Q:update({1},{{'=',2,5}}, {timeout=0})"
msgstr "conn.space.Q:update({1},{{'=',2,5}}, {timeout=0})"

#: ../doc/1.10/reference/reference_lua/net_box.rst:421
msgid ""
":samp:`conn.space.{space-name}:upsert(...)` is the remote-call equivalent"
" of the local call :samp:`box.space.{space-name}:upsert(...)`."
msgstr ""
":samp:`conn.space.{имя-спейса}:upsert(...)` -- это удаленный вызов, "
"аналогичный локальному вызову :samp:`box.space.{имя-спейса}:upsert(...)`."

#: ../doc/1.10/reference/reference_lua/net_box.rst:428
msgid ""
":samp:`conn.space.{space-name}:delete(...)` is the remote-call equivalent"
" of the local call :samp:`box.space.{space-name}:delete(...)`."
msgstr ""
":samp:`conn.space.{имя-спейса}:delete(...)` -- это удаленный вызов, "
"аналогичный локальному вызову :samp:`box.space.{имя-спейса}:delete(...)`."

#: ../doc/1.10/reference/reference_lua/net_box.rst:435
msgid ""
":samp:`conn:eval({Lua-string})` evaluates and executes the expression in "
"Lua-string, which may be any statement or series of statements. An "
":ref:`execute privilege <authentication-owners_privileges>` is required; "
"if the user does not have it, an administrator may grant it with "
":samp:`box.schema.user.grant({username}, 'execute', 'universe')`."
msgstr ""
":samp:`conn:eval({Lua-строка})` оценивает и выполняет выражение в "
"Lua-строке, которое может представлять собой любое выражение или "
"несколько выражений. Требуются :ref:`права на выполнение <authentication-"
"owners_privileges>`; если у пользователя таких прав нет, администратор "
"может их выдать с помощью "
":samp:`box.schema.user.grant({имя-пользователя}, 'execute', 'universe')`."

#: ../doc/1.10/reference/reference_lua/net_box.rst:441
msgid ""
"To ensure that the return from ``conn:eval`` is whatever the Lua "
"expression returns, begin the Lua-string with the word \"return\"."
msgstr ""
"Чтобы гарантировать, что ``conn:eval`` вернет то, что возвращает "
"выражение на Lua, начните Lua-строку со слова \"return\" (вернуть)."

#: ../doc/1.10/reference/reference_lua/net_box.rst:446
msgid ""
"tarantool> --Lua-string\n"
"tarantool> conn:eval('function f5() return 5+5 end; return f5();')\n"
"---\n"
"- 10\n"
"...\n"
"tarantool> --Lua-string, {arguments}\n"
"tarantool> conn:eval('return ...', {1,2,{3,'x'}})\n"
"---\n"
"- 1\n"
"- 2\n"
"- [3, 'x']\n"
"...\n"
"tarantool> --Lua-string, {arguments}, {options}\n"
"tarantool> conn:eval('return {nil,5}', {}, {timeout=0.1})\n"
"---\n"
"- [null, 5]\n"
"..."
msgstr ""
"tarantool> --Lua-строка\n"
"tarantool> conn:eval('function f5() return 5+5 end; return f5();')\n"
"---\n"
"- 10\n"
"...\n"
"tarantool> --Lua-строка, {аргументы}\n"
"tarantool> conn:eval('return ...', {1,2,{3,'x'}})\n"
"---\n"
"- 1\n"
"- 2\n"
"- [3, 'x']\n"
"...\n"
"tarantool> --Lua-строка, {аргументы}, {парметры}\n"
"tarantool> conn:eval('return {nil,5}', {}, {timeout=0.1})\n"
"---\n"
"- [null, 5]\n"
"..."

#: ../doc/1.10/reference/reference_lua/net_box.rst:470
msgid ""
"``conn:call('func', {'1', '2', '3'})`` is the remote-call equivalent of "
"``func('1', '2', '3')``. That is, ``conn:call`` is a remote stored-"
"procedure call. The return from ``conn:call`` is whatever the function "
"returns."
msgstr ""
"``conn:call('func', {'1', '2', '3'})`` -- это удаленный вызов, "
"аналогичный ``func('1', '2', '3')``. Таким образом, ``conn:call`` "
"представляет собой удаленный вызов хранимой процедуры. ``conn:call`` "
"возвращает то, что возвращает функция."

#: ../doc/1.10/reference/reference_lua/net_box.rst:474
msgid ""
"Limitation: the called function cannot return a function, for example if "
"``func2`` is defined as ``function func2 () return func end`` then "
"``conn:call(func2)`` will return \"error: unsupported Lua type "
"'function'\"."
msgstr ""
"Ограничение: вызванная функция не может вернуть функцию, например, если "
"``func2`` определяется как ``function func2 () return func end``, то "
"``conn:call(func2)`` вернет ошибку \"error: unsupported Lua type "
"'function'\"."

#: ../doc/1.10/reference/reference_lua/net_box.rst:480
msgid ""
"tarantool> -- create 2 functions with conn:eval()\n"
"tarantool> conn:eval('function f1() return 5+5 end;')\n"
"tarantool> conn:eval('function f2(x,y) return x,y end;')\n"
"tarantool> -- call first function with no parameters and no options\n"
"tarantool> conn:call('f1')\n"
"---\n"
"- 10\n"
"...\n"
"tarantool> -- call second function with two parameters and one option\n"
"tarantool> conn:call('f2',{1,'B'},{timeout=99})\n"
"---\n"
"- 1\n"
"- B\n"
"..."
msgstr ""
"tarantool> -- создание 2 функций с conn:eval()\n"
"tarantool> conn:eval('function f1() return 5+5 end;')\n"
"tarantool> conn:eval('function f2(x,y) return x,y end;')\n"
"tarantool> -- вызов первой функции без параметров и опций\n"
"tarantool> conn:call('f1')\n"
"---\n"
"- 10\n"
"...\n"
"tarantool> -- вызов второй функции с двумя параметрами и одной опцией\n"
"tarantool> conn:call('f2',{1,'B'},{timeout=99})\n"
"---\n"
"- 1\n"
"- B\n"
"..."

#: ../doc/1.10/reference/reference_lua/net_box.rst:503
msgid ""
"``timeout(...)`` is a wrapper which sets a timeout for the request that "
"follows it. Since version 1.7.4 this method is deprecated -- it is better"
" to pass a timeout value for a method's ``{options}`` parameter."
msgstr ""
"``timeout(...)`` -- это надстройка, которая определяет время ожидания для"
" запроса. С версии 1.7.4 этот метод объявлен устаревшим -- лучше передать"
" значение времени ожидания с помощью параметра ``{options}``."

#: ../doc/1.10/reference/reference_lua/net_box.rst:509
msgid "conn:timeout(0.5).space.tester:update({1}, {{'=', 2, 15}})"
msgstr "conn:timeout(0.5).space.tester:update({1}, {{'=', 2, 15}})"

#: ../doc/1.10/reference/reference_lua/net_box.rst:513
msgid ""
"Although ``timeout(...)`` is deprecated, all remote calls support its "
"use. Using a wrapper object makes the remote connection API compatible "
"with the local one, removing the need for a separate ``timeout`` "
"argument, which the local version would ignore. Once a request is sent, "
"it cannot be revoked from the remote server even if a timeout expires: "
"the timeout expiration only aborts the wait for the remote server "
"response, not the request itself."
msgstr ""
"Хотя ``timeout(...)`` объявлен устаревшим, все удаленные вызовы "
"поддерживают его. Использование надстройки обеспечивает совместимость API"
" удаленного соединения с локальным, поэтому отпадает необходимость в "
"отдельном аргументе ``timeout``, который проигнорирует локальная версия. "
"После отправки запроса его нельзя отменить с удаленного сервера даже по "
"истечении времени задержки: окончание времени задержки прерывает только "
"ожидание ответа от удаленного сервера, а не сам запрос."

#: ../doc/1.10/reference/reference_lua/net_box.rst:525
msgid ""
"``{is_async=true|false}`` is an option which is applicable for all "
"``net_box`` requests including ``conn:call``, ``conn:eval``, and the "
"``conn.space.space-name`` requests."
msgstr ""
"``{is_async=true|false}`` -- это опция, которую можно применить во всех "
"запросах ``net_box``, включая ``conn:call``, ``conn:eval`` и запросы "
"``conn.space.space-name``."

#: ../doc/1.10/reference/reference_lua/net_box.rst:529
msgid ""
"The default is ``is_async=false``, meaning requests are synchronous for "
"the fiber. The fiber is blocked, waiting until there is a reply to the "
"request or until timeout expires. Before Tarantool version 1.10, the only"
" way to make asynchronous requests was to put them in separate fibers."
msgstr ""
"По умолчанию, ``is_async=false``, что означает, что запросы будут "
"синхронными для файбера. Файбер блокируется в ожидании ответа на запрос "
"или до истечения времени ожидания. До версии Tarantool'а 1.10 "
"единственным способом выполнения асинхронных запросов было использование "
"отдельных файберов."

#: ../doc/1.10/reference/reference_lua/net_box.rst:535
msgid ""
"The non-default is ``is_async=true``, meaning requests are asynchronous "
"for the fiber. The request causes a yield but there is no waiting. The "
"immediate return is not the result of the request, instead it is an "
"object that the calling program can use later to get the result of the "
"request."
msgstr ""
"``is_async=true`` означает, что запросы будут асинхронными для файбера. "
"Запрос вызывает передачу управления, но файбер не входит в режим "
"ожидания. Сразу же возвращается результат, но это будет не результат "
"запроса, а объект, который может использовать вызывающая программа для "
"получения результат запроса."

#: ../doc/1.10/reference/reference_lua/net_box.rst:541
msgid ""
"This immediately-returned object, which we'll call \"future\", has its "
"own methods:"
msgstr ""
"У такого сразу же возвращаемого объекта, который мы называем \"future\" "
"(будущий), есть собственные методы:"

#: ../doc/1.10/reference/reference_lua/net_box.rst:544
msgid ""
"``future:is_ready()`` which will return true when the result of the "
"request is available,"
msgstr ""
"``future:is_ready()`` вернет true (правда), если доступен результат "
"запроса,"

#: ../doc/1.10/reference/reference_lua/net_box.rst:546
msgid ""
"``future:result()`` to get the result of the request (returns the "
"response or **nil** in case it's not ready yet or there has been an "
"error),"
msgstr ""
"``future:result()`` используется для получения результата запроса "
"(возвращает ответ на запрос или **nil** в случае, если ответ еще не готов"
" или произошла какая-либо ошибка),"

#: ../doc/1.10/reference/reference_lua/net_box.rst:548
msgid ""
"``future:wait_result(timeout)`` to wait until the result of the request "
"is available and then get it,"
msgstr ""
"``future:wait_result(timeout)`` будет ждать, когда результат запроса "
"будет доступен, а затем получит его."

#: ../doc/1.10/reference/reference_lua/net_box.rst:550
msgid "``future:discard()`` to abandon the object."
msgstr "``future:discard()`` откажется от объекта."

#: ../doc/1.10/reference/reference_lua/net_box.rst:552
msgid ""
"Typically a user would say ``future=request-name(...{is_async=true})``, "
"then either loop checking ``future:is_ready()`` until it is true and then"
" say ``request_result=future:result()``, or say "
"``request_result=future:wait_result(...)``. Alternatively the client "
"could check for \"out-of-band\" messages from the server by calling "
"``pairs()`` in a loop -- see :ref:`box.session.push() <box_session-"
"push>`."
msgstr ""
"В обычной ситуации пользователь введет команду "
"``future=имя-запроса(...{is_async=true})``, а затем либо цикл с проверкой"
" ``future:is_ready()`` до тех пор, пока он не вернет true, и получением "
"результата с помощью  ``request_result=future:result()``, либо же команду"
" ``request_result=future:wait_result(...)``. Возможен вариант, когда "
"клиент проверяет наличие внеполосных сообщений от сервера, вызывая в "
"цикле ``pairs()`` -- см. :ref:`box.session.push() <box_session-push>`."

#: ../doc/1.10/reference/reference_lua/net_box.rst:561
msgid ""
"tarantool> future = conn.space.tester:insert({900},{is_async=true})\n"
"---\n"
"...\n"
"tarantool> future\n"
"---\n"
"- method: insert\n"
"  response: [900]\n"
"  cond: cond\n"
"  on_push_ctx: []\n"
"  on_push: 'function: builtin#91'\n"
"...\n"
"tarantool> future:is_ready()\n"
"---\n"
"- true\n"
"...\n"
"tarantool> future:result()\n"
"---\n"
"- [900]\n"
"..."
msgstr ""
"tarantool> future = conn.space.tester:insert({900},{is_async=true})\n"
"---\n"
"...\n"
"tarantool> future\n"
"---\n"
"- method: insert\n"
"  response: [900]\n"
"  cond: cond\n"
"  on_push_ctx: []\n"
"  on_push: 'function: builtin#91'\n"
"...\n"
"tarantool> future:is_ready()\n"
"---\n"
"- true\n"
"...\n"
"tarantool> future:result()\n"
"---\n"
"- [900]\n"
"..."

#: ../doc/1.10/reference/reference_lua/net_box.rst:583
msgid ""
"Typically ``{is_async=true}`` is used only if the load is large (more "
"than 100,000 requests per second) and latency is large (more than 1 "
"second), or when it is necessary to send multiple requests in parallel "
"then collect responses (sometimes called a \"map-reduce\" scenario)."
msgstr ""
"Как правило, ``{is_async=true}`` используется только при большой загрузке"
" (более 100 000 запросов в секунду) и большой задержке чтения (более 1 "
"секунды), или же при необходимости отправки нескольких одновременных "
"запросов, которые собирают ответы (что иногда называется "
"\"отображение-свертка\")."

#: ../doc/1.10/reference/reference_lua/net_box.rst:591
msgid ""
"Although the final result of an async request is the same as the result "
"of a sync request, it is structured differently: as a table, instead of "
"as the unpacked values."
msgstr ""
"Хотя окончательный результат асинхронного запроса не отличается от "
"результата синхронного запроса, у него другая структура: таблица, а не "
"неупакованные значения."

#: ../doc/1.10/reference/reference_lua/net_box.rst:599
msgid "This example shows the use of most of the ``net.box`` methods."
msgstr "Ниже приводится пример использования большинства методов ``net.box``."

#: ../doc/1.10/reference/reference_lua/net_box.rst:601
msgid "The sandbox configuration for this example assumes that:"
msgstr "Данный пример сработает на конфигурации из песочницы, предполагается, что:"

#: ../doc/1.10/reference/reference_lua/net_box.rst:603
msgid "the Tarantool instance is running on ``localhost 127.0.0.1:3301``,"
msgstr "экземпляр Tarantool'а запущен на ``localhost 127.0.0.1:3301``,"

#: ../doc/1.10/reference/reference_lua/net_box.rst:604
msgid ""
"there is a space named ``tester`` with a numeric primary key and with a "
"tuple that contains a key value = 800,"
msgstr ""
"создан спейс под названием ``tester`` с первичным числовым ключом и "
"кортежем, в котором есть ключ со значением= 800,"

#: ../doc/1.10/reference/reference_lua/net_box.rst:606
msgid "the current user has read, write and execute privileges."
msgstr "у текущего пользователя есть права на чтение, запись и выполнение."

#: ../doc/1.10/reference/reference_lua/net_box.rst:608
msgid "Here are commands for a quick sandbox setup:"
msgstr "Ниже приведены команды для быстрой настройки песочницы:"

#: ../doc/1.10/reference/reference_lua/net_box.rst:610
msgid ""
"box.cfg{listen = 3301}\n"
"s = box.schema.space.create('tester')\n"
"s:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
"t = s:insert({800, 'TEST'})\n"
"box.schema.user.grant('guest', 'read,write,execute', 'universe')"
msgstr ""
"box.cfg{listen = 3301}\n"
"s = box.schema.space.create('tester')\n"
"s:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
"t = s:insert({800, 'TEST'})\n"
"box.schema.user.grant('guest', 'read,write,execute', 'universe')"

#: ../doc/1.10/reference/reference_lua/net_box.rst:618
msgid "And here starts the example:"
msgstr "А здесь приведен пример:"

#: ../doc/1.10/reference/reference_lua/net_box.rst:620
msgid ""
"tarantool> net_box = require('net.box')\n"
"---\n"
"...\n"
"tarantool> function example()\n"
"         >   local conn, wtuple\n"
"         >   if net_box.self:ping() then\n"
"         >     table.insert(ta, 'self:ping() succeeded')\n"
"         >     table.insert(ta, '  (no surprise -- self connection is "
"pre-established)')\n"
"         >   end\n"
"         >   if box.cfg.listen == '3301' then\n"
"         >     table.insert(ta,'The local server listen address = 3301')\n"
"         >   else\n"
"         >     table.insert(ta, 'The local server listen address is not "
"3301')\n"
"         >     table.insert(ta, '(  (maybe box.cfg{...listen=\"3301\"...}"
" was not stated)')\n"
"         >     table.insert(ta, '(  (so connect will fail)')\n"
"         >   end\n"
"         >   conn = net_box.connect('127.0.0.1:3301')\n"
"         >   conn.space.tester:delete({800})\n"
"         >   table.insert(ta, 'conn delete done on tester.')\n"
"         >   conn.space.tester:insert({800, 'data'})\n"
"         >   table.insert(ta, 'conn insert done on tester, index 0')\n"
"         >   table.insert(ta, '  primary key value = 800.')\n"
"         >   wtuple = conn.space.tester:select({800})\n"
"         >   table.insert(ta, 'conn select done on tester, index 0')\n"
"         >   table.insert(ta, '  number of fields = ' .. #wtuple)\n"
"         >   conn.space.tester:delete({800})\n"
"         >   table.insert(ta, 'conn delete done on tester')\n"
"         >   conn.space.tester:replace({800, 'New data', 'Extra data'})\n"
"         >   table.insert(ta, 'conn:replace done on tester')\n"
"         >   conn.space.tester:update({800}, {{'=', 2, 'Fld#1'}})\n"
"         >   table.insert(ta, 'conn update done on tester')\n"
"         >   conn:close()\n"
"         >   table.insert(ta, 'conn close done')\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> ta = {}\n"
"---\n"
"...\n"
"tarantool> example()\n"
"---\n"
"...\n"
"tarantool> ta\n"
"---\n"
"- - self:ping() succeeded\n"
"  - '  (no surprise -- self connection is pre-established)'\n"
"  - The local server listen address = 3301\n"
"  - conn delete done on tester.\n"
"  - conn insert done on tester, index 0\n"
"  - '  primary key value = 800.'\n"
"  - conn select done on tester, index 0\n"
"  - '  number of fields = 1'\n"
"  - conn delete done on tester\n"
"  - conn:replace done on tester\n"
"  - conn update done on tester\n"
"  - conn close done\n"
"..."
msgstr ""
"tarantool> net_box = require('net.box')\n"
"---\n"
"...\n"
"tarantool> function example()\n"
"         >   local conn, wtuple\n"
"         >   if net_box.self:ping() then\n"
"         >     table.insert(ta, 'self:ping() succeeded')\n"
"         >     table.insert(ta, '  (no surprise -- self connection is "
"pre-established)')\n"
"         >   end\n"
"         >   if box.cfg.listen == '3301' then\n"
"         >     table.insert(ta,'The local server listen address = 3301')\n"
"         >   else\n"
"         >     table.insert(ta, 'The local server listen address is not "
"3301')\n"
"         >     table.insert(ta, '(  (maybe box.cfg{...listen=\"3301\"...}"
" was not stated)')\n"
"         >     table.insert(ta, '(  (so connect will fail)')\n"
"         >   end\n"
"         >   conn = net_box.connect('127.0.0.1:3301')\n"
"         >   conn.space.tester:delete({800})\n"
"         >   table.insert(ta, 'conn delete done on tester.')\n"
"         >   conn.space.tester:insert({800, 'data'})\n"
"         >   table.insert(ta, 'conn insert done on tester, index 0')\n"
"         >   table.insert(ta, '  primary key value = 800.')\n"
"         >   wtuple = conn.space.tester:select({800})\n"
"         >   table.insert(ta, 'conn select done on tester, index 0')\n"
"         >   table.insert(ta, '  number of fields = ' .. #wtuple)\n"
"         >   conn.space.tester:delete({800})\n"
"         >   table.insert(ta, 'conn delete done on tester')\n"
"         >   conn.space.tester:replace({800, 'New data', 'Extra data'})\n"
"         >   table.insert(ta, 'conn:replace done on tester')\n"
"         >   conn.space.tester:update({800}, {{'=', 2, 'Fld#1'}})\n"
"         >   table.insert(ta, 'conn update done on tester')\n"
"         >   conn:close()\n"
"         >   table.insert(ta, 'conn close done')\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> ta = {}\n"
"---\n"
"...\n"
"tarantool> example()\n"
"---\n"
"...\n"
"tarantool> ta\n"
"---\n"
"- - self:ping() succeeded\n"
"  - '  (no surprise -- self connection is pre-established)'\n"
"  - The local server listen address = 3301\n"
"  - conn delete done on tester.\n"
"  - conn insert done on tester, index 0\n"
"  - '  primary key value = 800.'\n"
"  - conn select done on tester, index 0\n"
"  - '  number of fields = 1'\n"
"  - conn delete done on tester\n"
"  - conn:replace done on tester\n"
"  - conn update done on tester\n"
"  - conn close done\n"
"..."

#: ../doc/1.10/reference/reference_lua/osmodule.rst:39
msgid "Module `os`"
msgstr "Модуль `os`"

#: ../doc/1.10/reference/reference_lua/osmodule.rst:47
msgid ""
"The ``os`` module contains the functions :ref:`execute() <os-execute>`, "
":ref:`rename() <os-rename>`, :ref:`getenv() <os-getenv>`, :ref:`remove() "
"<os-remove>`, :ref:`date() <os-date>`, :ref:`exit() <os-exit>`, "
":ref:`time() <os-time>`, :ref:`clock() <os-clock>`, :ref:`tmpname() <os-"
"tmpname>`, :ref:`environ() <os-environ>`, :ref:`setenv() <os-setenv>`, "
":ref:`setlocale() <os-setlocale>`, :ref:`difftime() <os-difftime>`. Most "
"of these functions are described in the Lua manual Chapter 22 `The "
"Operating System Library <https://www.lua.org/pil/contents.html#22>`_."
msgstr ""
"Модуль ``os`` включает в себя следующие функции: :ref:`execute() <os-"
"execute>`, :ref:`rename() <os-rename>`, :ref:`getenv() <os-getenv>`, "
":ref:`remove() <os-remove>`, :ref:`date() <os-date>`, :ref:`exit() <os-"
"exit>`, :ref:`time() <os-time>`, :ref:`clock() <os-clock>`, "
":ref:`tmpname() <os-tmpname>`, :ref:`environ() <os-environ>`, "
":ref:`setenv() <os-setenv>`, :ref:`setlocale() <os-setlocale>`, "
":ref:`difftime() <os-difftime>`. Большинство этих функций описаны в Главе"
" 22 руководства по языку Lua `Библиотека функций операционной системы "
"<https://www.lua.org/pil/contents.html#22>`_."

#: ../doc/1.10/reference/reference_lua/osmodule.rst:64
msgid "Below is a list of all ``os`` functions."
msgstr "Ниже приведен перечень всех функций модуля ``os``."

#: ../doc/1.10/reference/reference_lua/osmodule.rst:74
msgid ":ref:`os.execute() <os-execute>`"
msgstr ":ref:`os.execute() <os-execute>`"

#: ../doc/1.10/reference/reference_lua/osmodule.rst:74
msgid "Execute by passing to the shell"
msgstr "Выполнение путем передачи в ОС"

#: ../doc/1.10/reference/reference_lua/osmodule.rst:77
msgid ":ref:`os.rename() <os-rename>`"
msgstr ":ref:`os.rename() <os-rename>`"

#: ../doc/1.10/reference/reference_lua/osmodule.rst:80
msgid ":ref:`os.getenv() <os-getenv>`"
msgstr ":ref:`os.getenv() <os-getenv>`"

#: ../doc/1.10/reference/reference_lua/osmodule.rst:80
msgid "Get an environment variable"
msgstr "Получение переменной окружения"

#: ../doc/1.10/reference/reference_lua/osmodule.rst:83
msgid ":ref:`os.remove() <os-remove>`"
msgstr ":ref:`os.remove() <os-remove>`"

#: ../doc/1.10/reference/reference_lua/osmodule.rst:83
msgid "Remove a file or directory"
msgstr "Удаление файла или директории"

#: ../doc/1.10/reference/reference_lua/osmodule.rst:86
msgid ":ref:`os.date() <os-date>`"
msgstr ":ref:`os.date() <os-date>`"

#: ../doc/1.10/reference/reference_lua/osmodule.rst:86
msgid "Get a formatted date"
msgstr "Получение даты в формате"

#: ../doc/1.10/reference/reference_lua/osmodule.rst:89
msgid ":ref:`os.exit() <os-exit>`"
msgstr ":ref:`os.exit() <os-exit>`"

#: ../doc/1.10/reference/reference_lua/osmodule.rst:89
msgid "Exit the program"
msgstr "Выход из программы"

#: ../doc/1.10/reference/reference_lua/osmodule.rst:92
msgid ":ref:`os.time() <os-time>`"
msgstr ":ref:`os.time() <os-time>`"

#: ../doc/1.10/reference/reference_lua/osmodule.rst:92
msgid "Get the number of seconds since the epoch"
msgstr "Получение числа секунд с начала отсчета"

#: ../doc/1.10/reference/reference_lua/osmodule.rst:95
msgid ":ref:`os.clock() <os-clock>`"
msgstr ":ref:`os.clock() <os-clock>`"

#: ../doc/1.10/reference/reference_lua/osmodule.rst:95
msgid "Get the number of CPU seconds since the program start"
msgstr "Получение числа времени ЦП в секундах с момента начала программы"

#: ../doc/1.10/reference/reference_lua/osmodule.rst:98
msgid ":ref:`os.tmpname() <os-tmpname>`"
msgstr ":ref:`os.tmpname() <os-tmpname>`"

#: ../doc/1.10/reference/reference_lua/osmodule.rst:98
msgid "Get the name of a temporary file"
msgstr "Получение имени временного файла"

#: ../doc/1.10/reference/reference_lua/osmodule.rst:101
msgid ":ref:`os.environ() <os-environ>`"
msgstr ":ref:`os.environ() <os-environ>`"

#: ../doc/1.10/reference/reference_lua/osmodule.rst:101
msgid "Get a table with all environment variables"
msgstr "Получение таблицы со всеми переменными окружения"

#: ../doc/1.10/reference/reference_lua/osmodule.rst:104
msgid ":ref:`os.setenv() <os-setenv>`"
msgstr ":ref:`os.setenv() <os-setenv>`"

#: ../doc/1.10/reference/reference_lua/osmodule.rst:104
msgid "Set an environment variable"
msgstr "Определение переменной окружения"

#: ../doc/1.10/reference/reference_lua/osmodule.rst:107
msgid ":ref:`os.setlocale() <os-setlocale>`"
msgstr ":ref:`os.setlocale() <os-setlocale>`"

#: ../doc/1.10/reference/reference_lua/osmodule.rst:107
msgid "Change the locale"
msgstr "Изменение локали"

#: ../doc/1.10/reference/reference_lua/osmodule.rst:110
msgid ":ref:`os.difftime() <os-difftime>`"
msgstr ":ref:`os.difftime() <os-difftime>`"

#: ../doc/1.10/reference/reference_lua/osmodule.rst:110
msgid "Get the number of seconds between two times"
msgstr "Получение числа секунд между двумя значениями времени"

#: ../doc/1.10/reference/reference_lua/osmodule.rst:118
msgid "Execute by passing to the shell."
msgstr "Выполнение путем передачи в ОС."

#: ../doc/1.10/reference/reference_lua/osmodule.rst:120
msgid "what to execute."
msgstr "что выполнить."

#: ../doc/1.10/reference/reference_lua/osmodule.rst:124
msgid ""
"tarantool> os.execute('ls -l /usr')\n"
"total 200\n"
"drwxr-xr-x   2 root root 65536 Apr 22 15:49 bin\n"
"drwxr-xr-x  59 root root 20480 Apr 18 07:58 include\n"
"drwxr-xr-x 210 root root 65536 Apr 18 07:59 lib\n"
"drwxr-xr-x  12 root root  4096 Apr 22 15:49 local\n"
"drwxr-xr-x   2 root root 12288 Jan 31 09:50 sbin\n"
"---\n"
"..."
msgstr ""
"tarantool> os.execute('ls -l /usr')\n"
"total 200\n"
"drwxr-xr-x   2 root root 65536 Apr 22 15:49 bin\n"
"drwxr-xr-x  59 root root 20480 Apr 18 07:58 include\n"
"drwxr-xr-x 210 root root 65536 Apr 18 07:59 lib\n"
"drwxr-xr-x  12 root root  4096 Apr 22 15:49 local\n"
"drwxr-xr-x   2 root root 12288 Jan 31 09:50 sbin\n"
"---\n"
"..."

#: ../doc/1.10/reference/reference_lua/osmodule.rst:140
msgid "Rename a file or directory."
msgstr "Переименование файла или директории."

#: ../doc/1.10/reference/reference_lua/osmodule.rst:142
msgid "name of existing file or directory,"
msgstr "имя существующего файла или директории,"

#: ../doc/1.10/reference/reference_lua/osmodule.rst:143
msgid "changed name of file or directory."
msgstr "измененное имя файла или директории."

#: ../doc/1.10/reference/reference_lua/osmodule.rst:147
msgid ""
"tarantool> os.rename('local','foreign')\n"
"---\n"
"- null\n"
"- 'local: No such file or directory'\n"
"- 2\n"
"..."
msgstr ""
"tarantool> os.rename('local','foreign')\n"
"---\n"
"- null\n"
"- 'local: No such file or directory'\n"
"- 2\n"
"..."

#: ../doc/1.10/reference/reference_lua/osmodule.rst:160
msgid "Get environment variable."
msgstr "Получение переменной окружения."

#: ../doc/1.10/reference/reference_lua/osmodule.rst:162
msgid "Parameters: (string) variable-name = environment variable name."
msgstr "Параметры: (string) variable-name = имя переменной окружения."

#: ../doc/1.10/reference/reference_lua/osmodule.rst:166
msgid ""
"tarantool> os.getenv('PATH')\n"
"---\n"
"- /usr/local/sbin:/usr/local/bin:/usr/sbin\n"
"..."
msgstr ""
"tarantool> os.getenv('PATH')\n"
"---\n"
"- /usr/local/sbin:/usr/local/bin:/usr/sbin\n"
"..."

#: ../doc/1.10/reference/reference_lua/osmodule.rst:177
msgid "Remove file or directory."
msgstr "Удаление файла или директории."

#: ../doc/1.10/reference/reference_lua/osmodule.rst:179
msgid ""
"Parameters: (string) name = name of file or directory which will be "
"removed."
msgstr ""
"Parameters: (string) name = имя файла или директории, которые будут "
"удалены."

#: ../doc/1.10/reference/reference_lua/osmodule.rst:183
msgid ""
"tarantool> os.remove('file')\n"
"---\n"
"- true\n"
"..."
msgstr ""
"tarantool> os.remove('file')\n"
"---\n"
"- true\n"
"..."

#: ../doc/1.10/reference/reference_lua/osmodule.rst:194
msgid "Return a formatted date."
msgstr "Возврат даты в формате."

#: ../doc/1.10/reference/reference_lua/osmodule.rst:196
msgid ""
"Parameters: (string) format-string = instructions; (string) time-since-"
"epoch = number of seconds since 1970-01-01. If time-since-epoch is "
"omitted, it is assumed to be the current time."
msgstr ""
"Parameters: (string) format-string = инструкции; (string) time-since-"
"epoch = число секунд с 1970-01-01. Если не указать time-since-epoch, "
"предполагается использование текущего времени."

#: ../doc/1.10/reference/reference_lua/osmodule.rst:201
#, python-format
msgid ""
"tarantool> os.date(\"%A %B %d\")\n"
"---\n"
"- Sunday April 24\n"
"..."
msgstr ""
"tarantool> os.date(\"%A %B %d\")\n"
"---\n"
"- Sunday April 24\n"
"..."

#: ../doc/1.10/reference/reference_lua/osmodule.rst:212
msgid ""
"Exit the program. If this is done on a server instance, then the instance"
" stops."
msgstr ""
"Выход из программы. Если выполняется на экземпляре сервера, "
"останавливается работа экземпляра."

#: ../doc/1.10/reference/reference_lua/osmodule.rst:216
msgid ""
"tarantool> os.exit()\n"
"user@user-shell:~/tarantool_sandbox$"
msgstr ""
"tarantool> os.exit()\n"
"user@user-shell:~/tarantool_sandbox$"

#: ../doc/1.10/reference/reference_lua/osmodule.rst:225
msgid "Return the number of seconds since the epoch."
msgstr "Возврат числа секунд с начала отсчета."

#: ../doc/1.10/reference/reference_lua/osmodule.rst:229
msgid ""
"tarantool> os.time()\n"
"---\n"
"- 1461516945\n"
"..."
msgstr ""
"tarantool> os.time()\n"
"---\n"
"- 1461516945\n"
"..."

#: ../doc/1.10/reference/reference_lua/osmodule.rst:240
msgid "Return the number of CPU seconds since the program start."
msgstr "Возврат числа времени ЦП в секундах с момента начала программы."

#: ../doc/1.10/reference/reference_lua/osmodule.rst:244
msgid ""
"tarantool> os.clock()\n"
"---\n"
"- 0.05\n"
"..."
msgstr ""
"tarantool> os.clock()\n"
"---\n"
"- 0.05\n"
"..."

#: ../doc/1.10/reference/reference_lua/osmodule.rst:255
msgid "Return a name for a temporary file."
msgstr "Возврат имени временного файла."

#: ../doc/1.10/reference/reference_lua/osmodule.rst:259
msgid ""
"tarantool> os.tmpname()\n"
"---\n"
"- /tmp/lua_7SW1m2\n"
"..."
msgstr ""
"tarantool> os.tmpname()\n"
"---\n"
"- /tmp/lua_7SW1m2\n"
"..."

#: ../doc/1.10/reference/reference_lua/osmodule.rst:270
msgid "Return a table containing all environment variables."
msgstr "Возврат таблицы со всеми переменными окружения."

#: ../doc/1.10/reference/reference_lua/osmodule.rst:274
msgid ""
"tarantool> os.environ()['TERM']..os.environ()['SHELL']\n"
"---\n"
"- xterm/bin/bash\n"
"..."
msgstr ""
"tarantool> os.environ()['TERM']..os.environ()['SHELL']\n"
"---\n"
"- xterm/bin/bash\n"
"..."

#: ../doc/1.10/reference/reference_lua/osmodule.rst:285
msgid "Set an environment variable."
msgstr "Определение переменной окружения."

#: ../doc/1.10/reference/reference_lua/osmodule.rst:289
msgid ""
"tarantool> os.setenv('VERSION','99')\n"
"---\n"
"-\n"
"..."
msgstr ""
"tarantool> os.setenv('VERSION','99')\n"
"---\n"
"-\n"
"..."

#: ../doc/1.10/reference/reference_lua/osmodule.rst:300
msgid ""
"Change the locale. If new-locale-string is not specified, return the "
"current locale."
msgstr ""
"Изменение локали. Если не указать new-locale-string, вернется текущая "
"локаль."

#: ../doc/1.10/reference/reference_lua/osmodule.rst:305
msgid ""
"tarantool> require('string').sub(os.setlocale(),1,20)\n"
"---\n"
"- LC_CTYPE=en_US.UTF-8\n"
"..."
msgstr ""
"tarantool> require('string').sub(os.setlocale(),1,20)\n"
"---\n"
"- LC_CTYPE=en_US.UTF-8\n"
"..."

#: ../doc/1.10/reference/reference_lua/osmodule.rst:316
msgid "Return the number of seconds between two times."
msgstr "Возврат числа секунд между двумя значениями времени."

#: ../doc/1.10/reference/reference_lua/osmodule.rst:320
msgid ""
"tarantool> os.difftime(os.time() - 0)\n"
"---\n"
"- 1486594859\n"
"..."
msgstr ""
"tarantool> os.difftime(os.time() - 0)\n"
"---\n"
"- 1486594859\n"
"..."

#: ../doc/1.10/reference/reference_lua/other.rst:37
msgid "Miscellaneous"
msgstr "Разное"

#: ../doc/1.10/reference/reference_lua/other.rst:43
msgid "Below is a list of miscellaneous functions."
msgstr "Ниже приведен перечень разных доступных функций."

#: ../doc/1.10/reference/reference_lua/other.rst:53
msgid ":ref:`tonumber64() <other-tonumber64>`"
msgstr ":ref:`tonumber64() <other-tonumber64>`"

#: ../doc/1.10/reference/reference_lua/other.rst:53
msgid "Convert a string or a Lua number to a 64-bit integer"
msgstr "Конвертация строки или Lua-числа в 64-битное целое число"

#: ../doc/1.10/reference/reference_lua/other.rst:56
msgid ":ref:`dostring() <other-dostring>`"
msgstr ":ref:`dostring() <other-dostring>`"

#: ../doc/1.10/reference/reference_lua/other.rst:56
msgid "Parse and execute an arbitrary chunk of Lua code"
msgstr "Анализ и выполнение произвольного Lua-кода"

#: ../doc/1.10/reference/reference_lua/other.rst:64
msgid ""
"Convert a string or a Lua number to a 64-bit integer. The input value can"
" be expressed in decimal, binary (for example 0b1010), or hexadecimal "
"(for example -0xffff). The result can be used in arithmetic, and the "
"arithmetic will be 64-bit integer arithmetic rather than floating-point "
"arithmetic. (Operations on an unconverted Lua number use floating-point "
"arithmetic.) The ``tonumber64()`` function is added by Tarantool; the "
"name is global."
msgstr ""
"Конвертация строки или Lua-числа в 64-битное целое число. Входное "
"значение может быть выражено десятичным, двоичным (например, 0b1010) или "
"шестнадцатеричным (например, -0xffff) числом. Результат может "
"использоваться в арифметике, причем скорее в 64-битной целочисленной "
"арифметике, а не в арифметике в системе с плавающей запятой. (Операции с "
"неконвертированными Lua-числами выполняются в арифметике в системе с "
"плавающей запятой.) Функция ``tonumber64()`` в Tarantool'е является "
"глобальной."

#: ../doc/1.10/reference/reference_lua/other.rst:74
msgid ""
"tarantool> type(123456789012345), type(tonumber64(123456789012345))\n"
"---\n"
"- number\n"
"- number\n"
"...\n"
"tarantool> i = tonumber64('1000000000')\n"
"---\n"
"...\n"
"tarantool> type(i), i / 2, i - 2, i * 2, i + 2, i % 2, i ^ 2\n"
"---\n"
"- number\n"
"- 500000000\n"
"- 999999998\n"
"- 2000000000\n"
"- 1000000002\n"
"- 0\n"
"- 1000000000000000000\n"
"..."
msgstr ""
"tarantool> type(123456789012345), type(tonumber64(123456789012345))\n"
"---\n"
"- number\n"
"- number\n"
"...\n"
"tarantool> i = tonumber64('1000000000')\n"
"---\n"
"...\n"
"tarantool> type(i), i / 2, i - 2, i * 2, i + 2, i % 2, i ^ 2\n"
"---\n"
"- number\n"
"- 500000000\n"
"- 999999998\n"
"- 2000000000\n"
"- 1000000002\n"
"- 0\n"
"- 1000000000000000000\n"
"..."

#: ../doc/1.10/reference/reference_lua/other.rst:99
msgid ""
"Parse and execute an arbitrary chunk of Lua code. This function is mainly"
" useful to define and run Lua code without having to introduce changes to"
" the global Lua environment."
msgstr ""
"Анализ и выполнение произвольного Lua-кода. Данная функция используется "
"преимущественно для определения и выполнения Lua-кода без необходимости "
"внесения изменений в глобальное Lua-окружение."

#: ../doc/1.10/reference/reference_lua/other.rst:103
msgid "Lua code"
msgstr "Lua-код"

#: ../doc/1.10/reference/reference_lua/other.rst:104
msgid ""
"zero or more scalar values which will be appended to, or substitute for, "
"items in the Lua chunk."
msgstr ""
"ноль или другие скалярные значения, которые заменяются или к которым "
"прибавляются значения."

#: ../doc/1.10/reference/reference_lua/other.rst:107
msgid "whatever is returned by the Lua code chunk."
msgstr "то, что возвращает Lua-код."

#: ../doc/1.10/reference/reference_lua/other.rst:109
msgid ""
"Possible errors: If there is a compilation error, it is raised as a Lua "
"error."
msgstr "Возможные ошибки: Ошибка компиляции появляется как Lua-ошибка."

#: ../doc/1.10/reference/reference_lua/other.rst:114
msgid ""
"tarantool> dostring('abc')\n"
"---\n"
"error: '[string \"abc\"]:1: ''='' expected near ''<eof>'''\n"
"...\n"
"tarantool> dostring('return 1')\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> dostring('return ...', 'hello', 'world')\n"
"---\n"
"- hello\n"
"- world\n"
"...\n"
"tarantool> dostring([[\n"
"         >   local f = function(key)\n"
"         >     local t = box.space.tester:select{key}\n"
"         >     if t ~= nil then\n"
"         >       return t[1]\n"
"         >     else\n"
"         >       return nil\n"
"         >     end\n"
"         >   end\n"
"         >   return f(...)]], 1)\n"
"---\n"
"- null\n"
"..."
msgstr ""
"tarantool> dostring('abc')\n"
"---\n"
"error: '[string \"abc\"]:1: ''='' expected near ''<eof>'''\n"
"...\n"
"tarantool> dostring('return 1')\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> dostring('return ...', 'hello', 'world')\n"
"---\n"
"- hello\n"
"- world\n"
"...\n"
"tarantool> dostring([[\n"
"         >   local f = function(key)\n"
"         >     local t = box.space.tester:select{key}\n"
"         >     if t ~= nil then\n"
"         >       return t[1]\n"
"         >     else\n"
"         >       return nil\n"
"         >     end\n"
"         >   end\n"
"         >   return f(...)]], 1)\n"
"---\n"
"- null\n"
"..."

#: ../doc/1.10/reference/reference_lua/pickle.rst:37
msgid "Module `pickle`"
msgstr "Модуль `pickle`"

#: ../doc/1.10/reference/reference_lua/pickle.rst:43
msgid "Below is a list of all ``pickle`` functions."
msgstr "Ниже приведен перечень всех функций модуля ``pickle``."

#: ../doc/1.10/reference/reference_lua/pickle.rst:53
msgid ":ref:`pickle.pack() <pickle-pack>`"
msgstr ":ref:`pickle.pack() <pickle-pack>`"

#: ../doc/1.10/reference/reference_lua/pickle.rst:53
msgid "Convert Lua variables to binary format"
msgstr "Конвертация Lua-переменных в двоичный формат"

#: ../doc/1.10/reference/reference_lua/pickle.rst:56
msgid ":ref:`pickle.unpack() <pickle-unpack>`"
msgstr ":ref:`pickle.unpack() <pickle-unpack>`"

#: ../doc/1.10/reference/reference_lua/pickle.rst:56
msgid "Convert Lua variables back from binary format"
msgstr "Конвертация Lua-переменных в двоичный формат"

#: ../doc/1.10/reference/reference_lua/pickle.rst:66
msgid ""
"To use Tarantool binary protocol primitives from Lua, it's necessary to "
"convert Lua variables to binary format. The ``pickle.pack()`` helper "
"function is prototyped after Perl 'pack_'."
msgstr ""
"Чтобы использовать примитивы бинарного протокола Tarantool'а из Lua, "
"необходимо конвертировать Lua-переменные в двоичный формат. Прототипом "
"вспомогательной функции ``pickle.pack()`` выступила функция 'pack_' из "
"Perl."

#: ../doc/1.10/reference/reference_lua/pickle.rst:72
msgid "**Format specifiers**"
msgstr "**Спецификаторы формата**"

#: ../doc/1.10/reference/reference_lua/pickle.rst:77
msgid "b, B"
msgstr "b, B"

#: ../doc/1.10/reference/reference_lua/pickle.rst:77
msgid ""
"converts Lua scalar value to a 1-byte integer, and stores the integer in "
"the resulting string"
msgstr ""
"конвертирует скалярное Lua-значение в 1-байтное целое число и хранит "
"целое число в полученной строке"

#: ../doc/1.10/reference/reference_lua/pickle.rst:80
msgid "s, S"
msgstr "s, S"

#: ../doc/1.10/reference/reference_lua/pickle.rst:80
msgid ""
"converts Lua scalar value to a 2-byte integer, and stores the integer in "
"the resulting string, low byte first"
msgstr ""
"конвертирует скалярное Lua-значение в 2-байтное целое число и хранит "
"целое число в полученной строке, сначала младший байт"

#: ../doc/1.10/reference/reference_lua/pickle.rst:84
msgid "i, I"
msgstr "i, I"

#: ../doc/1.10/reference/reference_lua/pickle.rst:84
msgid ""
"converts Lua scalar value to a 4-byte integer, and stores the integer in "
"the resulting string, low byte first"
msgstr ""
"конвертирует скалярное Lua-значение в 4-байтное целое число и хранит "
"целое число в полученной строке, сначала младший байт"

#: ../doc/1.10/reference/reference_lua/pickle.rst:88
msgid "l, L"
msgstr "l, L"

#: ../doc/1.10/reference/reference_lua/pickle.rst:88
msgid ""
"converts Lua scalar value to an 8-byte integer, and stores the integer in"
" the resulting string, low byte first"
msgstr ""
"конвертирует скалярное Lua-значение в 8-байтное целое число и хранит "
"целое число в полученной строке, сначала младший байт"

#: ../doc/1.10/reference/reference_lua/pickle.rst:92
msgid "n"
msgstr "n"

#: ../doc/1.10/reference/reference_lua/pickle.rst:92
msgid ""
"converts Lua scalar value to a 2-byte integer, and stores the integer in "
"the resulting string, big endian,"
msgstr ""
"конвертирует скалярное Lua-значение в 2-байтное целое число и хранит "
"целое число в полученной строке, порядок от старшего к младшему,"

#: ../doc/1.10/reference/reference_lua/pickle.rst:96
msgid "N"
msgstr "N"

#: ../doc/1.10/reference/reference_lua/pickle.rst:96
msgid ""
"converts Lua scalar value to a 4-byte integer, and stores the integer in "
"the resulting string, big"
msgstr ""
"конвертирует скалярное Lua-значение в 4-байтное целое число и хранит "
"целое число в полученной строке, порядок от старшего к младшему,"

#: ../doc/1.10/reference/reference_lua/pickle.rst:99
msgid "q, Q"
msgstr "q, Q"

#: ../doc/1.10/reference/reference_lua/pickle.rst:99
msgid ""
"converts Lua scalar value to an 8-byte integer, and stores the integer in"
" the resulting string, big endian,"
msgstr ""
"конвертирует скалярное Lua-значение в 8-байтное целое число и хранит "
"целое число в полученной строке, порядок от старшего к младшему,"

#: ../doc/1.10/reference/reference_lua/pickle.rst:103
msgid "f"
msgstr "f"

#: ../doc/1.10/reference/reference_lua/pickle.rst:103
msgid ""
"converts Lua scalar value to a 4-byte float, and stores the float in the "
"resulting string"
msgstr ""
"конвертирует скалярное Lua-значение в 4-байтное число с плавающей запятой"
" и хранит число с плавающей запятой в полученной строке"

#: ../doc/1.10/reference/reference_lua/pickle.rst:106
msgid "d"
msgstr "d"

#: ../doc/1.10/reference/reference_lua/pickle.rst:106
msgid ""
"converts Lua scalar value to a 8-byte double, and stores the double in "
"the resulting string"
msgstr ""
"конвертирует скалярное Lua-значение в 8-байтное число двойной точности и "
"хранит число двойной точности в полученной строке"

#: ../doc/1.10/reference/reference_lua/pickle.rst:109
msgid "a, A"
msgstr "a, A"

#: ../doc/1.10/reference/reference_lua/pickle.rst:109
msgid ""
"converts Lua scalar value to a sequence of bytes, and stores the sequence"
" in the resulting string"
msgstr ""
"конвертирует скалярное Lua-значение в последовательность байтов и хранит "
"последовательность в полученной строке"

#: ../doc/1.10/reference/reference_lua/pickle.rst:113
msgid "string containing format specifiers"
msgstr "строка со спецификаторами формата"

#: ../doc/1.10/reference/reference_lua/pickle.rst:114
msgid "scalar values to be formatted"
msgstr "скалярные значения к форматированию"

#: ../doc/1.10/reference/reference_lua/pickle.rst:115
msgid ""
"a binary string containing all arguments, packed according to the format "
"specifiers."
msgstr ""
"бинарная строка, которая содержит все аргументы, упакованные в "
"соответствии со спецификаторами формата."

#: ../doc/1.10/reference/reference_lua/pickle.rst:119
msgid ""
"A scalar value can be either a variable or a literal. Remember that large"
" integers should be entered with :ref:`tonumber64() or LL or ULL suffixes"
" <index-box_number>`."
msgstr ""
"Скалярное значение может быть либо переменной, либо литеральным "
"значением. Следует помнить, что большие целые числа нужно вводить с "
":ref:`tonumber64() или суффиксами LL или ULL <index-box_number>`."

#: ../doc/1.10/reference/reference_lua/pickle.rst:123
msgid "Possible errors: unknown format specifier."
msgstr "Возможные ошибки: неизвестный спецификатор формата."

#: ../doc/1.10/reference/reference_lua/pickle.rst:127
msgid ""
"tarantool> pickle = require('pickle')\n"
"---\n"
"...\n"
"tarantool> box.space.tester:insert{0, 'hello world'}\n"
"---\n"
"- [0, 'hello world']\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'=', 2, 'bye world'}})\n"
"---\n"
"- [0, 'bye world']\n"
"...\n"
"tarantool> box.space.tester:update({0}, {\n"
"         >   {'=', 2, pickle.pack('iiA', 0, 3, 'hello')}\n"
"         > })\n"
"---\n"
"- [0, \"\\0\\0\\0\\0\\x03\\0\\0\\0hello\"]\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'=', 2, 4}})\n"
"---\n"
"- [0, 4]\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'+', 2, 4}})\n"
"---\n"
"- [0, 8]\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'^', 2, 4}})\n"
"---\n"
"- [0, 12]\n"
"..."
msgstr ""
"tarantool> pickle = require('pickle')\n"
"---\n"
"...\n"
"tarantool> box.space.tester:insert{0, 'hello world'}\n"
"---\n"
"- [0, 'hello world']\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'=', 2, 'bye world'}})\n"
"---\n"
"- [0, 'bye world']\n"
"...\n"
"tarantool> box.space.tester:update({0}, {\n"
"         >   {'=', 2, pickle.pack('iiA', 0, 3, 'hello')}\n"
"         > })\n"
"---\n"
"- [0, \"\\0\\0\\0\\0\\x03\\0\\0\\0hello\"]\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'=', 2, 4}})\n"
"---\n"
"- [0, 4]\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'+', 2, 4}})\n"
"---\n"
"- [0, 8]\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'^', 2, 4}})\n"
"---\n"
"- [0, 12]\n"
"..."

#: ../doc/1.10/reference/reference_lua/pickle.rst:163
msgid ""
"Counterpart to ``pickle.pack()``. Warning: if format specifier 'A' is "
"used, it must be the last item."
msgstr ""
"Противоположность ``pickle.pack()``. Внимание: если используется "
"спецификатор формата 'A', он должен идти последним."

#: ../doc/1.10/reference/reference_lua/pickle.rst:169
msgid "A list of strings or numbers."
msgstr "Список строк или чисел."

#: ../doc/1.10/reference/reference_lua/pickle.rst:174
msgid ""
"tarantool> pickle = require('pickle')\n"
"---\n"
"...\n"
"tarantool> tuple = box.space.tester:replace{0}\n"
"---\n"
"...\n"
"tarantool> string.len(tuple[1])\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> pickle.unpack('b', tuple[1])\n"
"---\n"
"- 48\n"
"...\n"
"tarantool> pickle.unpack('bsi', pickle.pack('bsi', 255, 65535, "
"4294967295))\n"
"---\n"
"- 255\n"
"- 65535\n"
"- 4294967295\n"
"...\n"
"tarantool> pickle.unpack('ls', pickle.pack('ls', "
"tonumber64('18446744073709551615'), 65535))\n"
"---\n"
"...\n"
"tarantool> num, num64, str = pickle.unpack('slA', pickle.pack('slA', 666,"
"\n"
"         > tonumber64('666666666666666'), 'string'))\n"
"---\n"
"..."
msgstr ""
"tarantool> pickle = require('pickle')\n"
"---\n"
"...\n"
"tarantool> tuple = box.space.tester:replace{0}\n"
"---\n"
"...\n"
"tarantool> string.len(tuple[1])\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> pickle.unpack('b', tuple[1])\n"
"---\n"
"- 48\n"
"...\n"
"tarantool> pickle.unpack('bsi', pickle.pack('bsi', 255, 65535, "
"4294967295))\n"
"---\n"
"- 255\n"
"- 65535\n"
"- 4294967295\n"
"...\n"
"tarantool> pickle.unpack('ls', pickle.pack('ls', "
"tonumber64('18446744073709551615'), 65535))\n"
"---\n"
"...\n"
"tarantool> num, num64, str = pickle.unpack('slA', pickle.pack('slA', 666,"
"\n"
"         > tonumber64('666666666666666'), 'string'))\n"
"---\n"
"..."

#: ../doc/1.10/reference/reference_lua/socket.rst:39
msgid "Module `socket`"
msgstr "Модуль `socket`"

#: ../doc/1.10/reference/reference_lua/socket.rst:45
msgid ""
"The ``socket`` module allows exchanging data via BSD sockets with a local"
" or remote host in connection-oriented (TCP) or datagram-oriented (UDP) "
"mode. Semantics of the calls in the ``socket`` API closely follow "
"semantics of the corresponding POSIX calls. Function names and signatures"
" are mostly compatible with `luasocket`_."
msgstr ""
"Модуль ``socket`` позволяет обмениваться данными с локальным или "
"удаленным хостом по BSD-сокетам в режиме с установлением соединений (TCP)"
" или на основе датаграмм (UDP). Семантика вызовов в API модуля ``socket``"
" точно соответствует семантике соответствующих вызовов в POSIX. Имена и "
"сигнатуры функций по большей части совместимы с `luasocket`_."

#: ../doc/1.10/reference/reference_lua/socket.rst:51
msgid ""
"The functions for setting up and connecting are ``socket``, "
"``sysconnect``, ``tcp_connect``. The functions for sending data are "
"``send``, ``sendto``, ``write``, ``syswrite``. The functions for "
"receiving data are ``recv``, ``recvfrom``, ``read``. The functions for "
"waiting before sending/receiving data are ``wait``, ``readable``, "
"``writable``. The functions for setting flags are ``nonblock``, "
"``setsockopt``. The functions for stopping and disconnecting are "
"``shutdown``, ``close``. The functions for error checking are ``errno``, "
"``error``."
msgstr ""
"Функции для настройки и подключения: ``socket``, ``sysconnect``, "
"``tcp_connect``. Функции для отправки данных: ``send``, ``sendto``, "
"``write``, ``syswrite``. Функции для получения данных: ``recv``, "
"``recvfrom``, ``read``. Функции для ожидания отправки/получения данных: "
"``wait``, ``readable``, ``writable``. Функции для установки флагов: "
"``nonblock``, ``setsockopt``. Функции для остановки и отключения: "
"``shutdown``, ``close``. Функции для проверки ошибок: ``errno``, "
"``error``."

#: ../doc/1.10/reference/reference_lua/socket.rst:64
msgid "Below is a list of all ``socket`` functions."
msgstr "Ниже приведен перечень всех функций модуля ``socket``."

#: ../doc/1.10/reference/reference_lua/socket.rst:74
msgid ":ref:`socket() <socket-socket>`"
msgstr ":ref:`socket() <socket-socket>`"

#: ../doc/1.10/reference/reference_lua/socket.rst:74
msgid "Create a socket"
msgstr "Создание сокета"

#: ../doc/1.10/reference/reference_lua/socket.rst:76
msgid ":ref:`socket.tcp_connect() <socket-tcp_connect>`"
msgstr ":ref:`socket.tcp_connect() <socket-tcp_connect>`"

#: ../doc/1.10/reference/reference_lua/socket.rst:76
#: ../doc/1.10/reference/reference_lua/socket.rst:85
msgid "Connect a socket to a remote host"
msgstr "Подключение к удаленному хосту с помощью сокета"

#: ../doc/1.10/reference/reference_lua/socket.rst:79
msgid ":ref:`socket.getaddrinfo() <socket-getaddrinfo>`"
msgstr ":ref:`socket.getaddrinfo() <socket-getaddrinfo>`"

#: ../doc/1.10/reference/reference_lua/socket.rst:79
msgid "Get information about a remote site"
msgstr "Получение информации об удаленном узле"

#: ../doc/1.10/reference/reference_lua/socket.rst:82
msgid ":ref:`socket.tcp_server() <socket-tcp_server>`"
msgstr ":ref:`socket.tcp_server() <socket-tcp_server>`"

#: ../doc/1.10/reference/reference_lua/socket.rst:82
msgid "Make Tarantool act as a TCP server"
msgstr "Использование Tarantool'а в качестве TCP-сервера"

#: ../doc/1.10/reference/reference_lua/socket.rst:85
msgid ":ref:`socket_object:sysconnect() <socket-sysconnect>`"
msgstr ":ref:`socket_object:sysconnect() <socket-sysconnect>`"

#: ../doc/1.10/reference/reference_lua/socket.rst:88
msgid ""
":ref:`socket_object:send() <socket-send>` |br| "
":ref:`socket_object:write() <socket-send>`"
msgstr ""
":ref:`socket_object:send() <socket-send>` |br| "
":ref:`socket_object:write() <socket-send>`"

#: ../doc/1.10/reference/reference_lua/socket.rst:88
msgid "Send data over a connected socket"
msgstr "Отправка данных по подключенному сокету"

#: ../doc/1.10/reference/reference_lua/socket.rst:91
msgid ":ref:`socket_object:syswrite() <socket-syswrite>`"
msgstr ":ref:`socket_object:syswrite() <socket-syswrite>`"

#: ../doc/1.10/reference/reference_lua/socket.rst:91
msgid "Write data to the socket buffer if non-blocking"
msgstr "Запись данных в буфер сокета без блокировки"

#: ../doc/1.10/reference/reference_lua/socket.rst:94
msgid ":ref:`socket_object:recv() <socket-recv>`"
msgstr ":ref:`socket_object:recv() <socket-recv>`"

#: ../doc/1.10/reference/reference_lua/socket.rst:94
msgid "Read from a connected socket"
msgstr "Чтение с подключенного сокета"

#: ../doc/1.10/reference/reference_lua/socket.rst:96
msgid ":ref:`socket_object:sysread() <socket-sysread>`"
msgstr ":ref:`socket_object:sysread() <socket-sysread>`"

#: ../doc/1.10/reference/reference_lua/socket.rst:96
msgid "Read data from the socket buffer if non-blocking"
msgstr "Чтение данных из буфера сокета без блокировки"

#: ../doc/1.10/reference/reference_lua/socket.rst:99
msgid ":ref:`socket_object:bind() <socket-bind>`"
msgstr ":ref:`socket_object:bind() <socket-bind>`"

#: ../doc/1.10/reference/reference_lua/socket.rst:99
msgid "Bind a socket to the given host/port"
msgstr "Привязка сокета к данному хосту/порту"

#: ../doc/1.10/reference/reference_lua/socket.rst:102
msgid ":ref:`socket_object:listen() <socket-listen>`"
msgstr ":ref:`socket_object:listen() <socket-listen>`"

#: ../doc/1.10/reference/reference_lua/socket.rst:102
msgid "Start listening for incoming connections"
msgstr "Начало прослушивания входящих соединений"

#: ../doc/1.10/reference/reference_lua/socket.rst:105
msgid ":ref:`socket_object:accept() <socket-accept>`"
msgstr ":ref:`socket_object:accept() <socket-accept>`"

#: ../doc/1.10/reference/reference_lua/socket.rst:105
msgid "Accept a client connection + create a connected socket"
msgstr "Принятие запроса клиента на соединение + создание подключенного сокета"

#: ../doc/1.10/reference/reference_lua/socket.rst:108
msgid ":ref:`socket_object:sendto() <socket-sendto>`"
msgstr ":ref:`socket_object:sendto() <socket-sendto>`"

#: ../doc/1.10/reference/reference_lua/socket.rst:108
msgid "Send a message on a UDP socket to a specified host"
msgstr "Отправка сообщения по UDP-сокету на указанный хост"

#: ../doc/1.10/reference/reference_lua/socket.rst:111
msgid ":ref:`socket_object:recvfrom() <socket-recvfrom>`"
msgstr ":ref:`socket_object:recvfrom() <socket-recvfrom>`"

#: ../doc/1.10/reference/reference_lua/socket.rst:111
msgid "Receive a message on a UDP socket"
msgstr "Получение сообщения по UDP-сокету"

#: ../doc/1.10/reference/reference_lua/socket.rst:114
msgid ":ref:`socket_object:shutdown() <socket-shutdown>`"
msgstr ":ref:`socket_object:shutdown() <socket-shutdown>`"

#: ../doc/1.10/reference/reference_lua/socket.rst:114
msgid "Shut down a reading end, a writing end, or both"
msgstr "Отключение передачи данных на чтение, на запись или в обоих направлениях"

#: ../doc/1.10/reference/reference_lua/socket.rst:117
msgid ":ref:`socket_object:close() <socket-close>`"
msgstr ":ref:`socket_object:close() <socket-close>`"

#: ../doc/1.10/reference/reference_lua/socket.rst:117
msgid "Close a socket"
msgstr "Закрытие сокета"

#: ../doc/1.10/reference/reference_lua/socket.rst:119
msgid ""
":ref:`socket_object:error() <socket-error>` |br| "
":ref:`socket_object:errno() <socket-error>`"
msgstr ""
":ref:`socket_object:error() <socket-error>` |br| "
":ref:`socket_object:errno() <socket-error>`"

#: ../doc/1.10/reference/reference_lua/socket.rst:119
msgid "Get information about the last error on a socket"
msgstr "Получение информации о последней ошибке на сокете"

#: ../doc/1.10/reference/reference_lua/socket.rst:122
msgid ":ref:`socket_object:setsockopt() <socket-setsockopt>`"
msgstr ":ref:`socket_object:setsockopt() <socket-setsockopt>`"

#: ../doc/1.10/reference/reference_lua/socket.rst:122
msgid "Set socket flags"
msgstr "Определение флагов сокета"

#: ../doc/1.10/reference/reference_lua/socket.rst:124
msgid ":ref:`socket_object:getsockopt() <socket-getsockopt>`"
msgstr ":ref:`socket_object:getsockopt() <socket-getsockopt>`"

#: ../doc/1.10/reference/reference_lua/socket.rst:124
msgid "Get socket flags"
msgstr "Получение флагов сокета"

#: ../doc/1.10/reference/reference_lua/socket.rst:126
msgid ":ref:`socket_object:linger() <socket-linger>`"
msgstr ":ref:`socket_object:linger() <socket-linger>`"

#: ../doc/1.10/reference/reference_lua/socket.rst:126
msgid "Set/clear the SO_LINGER flag"
msgstr "Установить/убрать флаг SO_LINGER"

#: ../doc/1.10/reference/reference_lua/socket.rst:128
msgid ":ref:`socket_object:nonblock() <socket-nonblock>`"
msgstr ":ref:`socket_object:nonblock() <socket-nonblock>`"

#: ../doc/1.10/reference/reference_lua/socket.rst:128
msgid "Set/get the flag value"
msgstr "Определить/получить значение флага"

#: ../doc/1.10/reference/reference_lua/socket.rst:130
msgid ":ref:`socket_object:readable() <socket-readable>`"
msgstr ":ref:`socket_object:readable() <socket-readable>`"

#: ../doc/1.10/reference/reference_lua/socket.rst:130
msgid "Wait until something is readable"
msgstr "Ожидание доступности чего-либо для чтения"

#: ../doc/1.10/reference/reference_lua/socket.rst:133
msgid ":ref:`socket_object:writable() <socket-writable>`"
msgstr ":ref:`socket_object:writable() <socket-writable>`"

#: ../doc/1.10/reference/reference_lua/socket.rst:133
msgid "Wait until something is writable"
msgstr "Ожидание доступности чего-либо для записи"

#: ../doc/1.10/reference/reference_lua/socket.rst:136
msgid ":ref:`socket_object:wait() <socket-wait>`"
msgstr ":ref:`socket_object:wait() <socket-wait>`"

#: ../doc/1.10/reference/reference_lua/socket.rst:136
msgid "Wait until something is either readable or writable"
msgstr "Ожидание доступности чего-либо для чтения или записи"

#: ../doc/1.10/reference/reference_lua/socket.rst:139
msgid ":ref:`socket_object:name() <socket-name>`"
msgstr ":ref:`socket_object:name() <socket-name>`"

#: ../doc/1.10/reference/reference_lua/socket.rst:139
msgid "Get information about the connection's near side"
msgstr "Получение информации о ближней стороне соединения"

#: ../doc/1.10/reference/reference_lua/socket.rst:142
msgid ":ref:`socket_object:peer() <socket-peer>`"
msgstr ":ref:`socket_object:peer() <socket-peer>`"

#: ../doc/1.10/reference/reference_lua/socket.rst:142
msgid "Get information about the connection's far side"
msgstr "Получение информации о дальней стороне соединения"

#: ../doc/1.10/reference/reference_lua/socket.rst:145
msgid ":ref:`socket.iowait() <socket-iowait>`"
msgstr ":ref:`socket.iowait() <socket-iowait>`"

#: ../doc/1.10/reference/reference_lua/socket.rst:145
msgid "Wait for read/write activity"
msgstr "Ожидание активности чтения/записи"

#: ../doc/1.10/reference/reference_lua/socket.rst:148
msgid ""
"Typically a socket session will begin with the setup functions, will set "
"one or more flags, will have a loop with sending and receiving functions,"
" will end with the teardown functions -- as an example at the end of this"
" section will show. Throughout, there may be error-checking and waiting "
"functions for synchronization. To prevent a fiber containing socket "
"functions from \"blocking\" other fibers, the :ref:`implicit yield rules "
"<atomic-implicit-yields>` will cause a yield so that other processes may "
"take over, as is the norm for :ref:`cooperative multitasking <atomic-"
"cooperative_multitasking>`."
msgstr ""
"Как правило, сессия сокета начинается с функций настройки, определяет "
"один или более флагов, запустит цикл с функциями отправки и получения и "
"закончится функциями завершения -- как в примере в конце данного раздела."
" В течение сессии может быть проверка на ошибки и ожидание синхронизации "
"функции. Чтобы файбер с сокетом не блокировал другие файберы, "
":ref:`правила неявной передачи управления <atomic-implicit-yields>` "
"заставят его передать управление другим процессам в рамках "
":ref:`кооперативной многозадачности <atomic-cooperative_multitasking>`."

#: ../doc/1.10/reference/reference_lua/socket.rst:157
msgid ""
"For all examples in this section the socket name will be sock and the "
"function invocations will look like ``sock:function_name(...)``."
msgstr ""
"Для всех примеров в данном разделе имя сокета будет sock, а вызов функции"
" будет выглядеть как ``sock:имя_функции(...)``."

#: ../doc/1.10/reference/reference_lua/socket.rst:166
msgid ""
"Create a new TCP or UDP socket. The argument values are the same as in "
"the `Linux socket(2) man page <http://man7.org/linux/man-"
"pages/man2/socket.2.html>`_."
msgstr ""
"Создание нового TCP-сокета или UDP-сокета. Значения аргумента остаются "
"теми же, что и на `странице socket(2) руководства по Linux "
"<http://man7.org/linux/man-pages/man2/socket.2.html>`_."

#: ../doc/1.10/reference/reference_lua/socket.rst:169
msgid "an unconnected socket, or nil."
msgstr "неподключенный сокет или nil."

#: ../doc/1.10/reference/reference_lua/socket.rst:174
msgid "socket('AF_INET', 'SOCK_STREAM', 'tcp')"
msgstr "socket('AF_INET', 'SOCK_STREAM', 'tcp')"

#: ../doc/1.10/reference/reference_lua/socket.rst:182
msgid "Connect a socket to a remote host."
msgstr "Подключение к удаленному хосту с помощью сокета."

#: ../doc/1.10/reference/reference_lua/socket.rst:184
#: ../doc/1.10/reference/reference_lua/socket.rst:389
#: ../doc/1.10/reference/reference_lua/socket.rst:429
msgid "URL or IP address"
msgstr "URL или IP-адрес"

#: ../doc/1.10/reference/reference_lua/socket.rst:185
#: ../doc/1.10/reference/reference_lua/socket.rst:390
#: ../doc/1.10/reference/reference_lua/socket.rst:430
msgid "port number"
msgstr "номер порта"

#: ../doc/1.10/reference/reference_lua/socket.rst:186
msgid "timeout"
msgstr "время ожидания"

#: ../doc/1.10/reference/reference_lua/socket.rst:187
msgid "a connected socket, if no error."
msgstr "подключенный сокет, если нет ошибки."

#: ../doc/1.10/reference/reference_lua/socket.rst:192
msgid "socket.tcp_connect('127.0.0.1', 3301)"
msgstr "socket.tcp_connect('127.0.0.1', 3301)"

#: ../doc/1.10/reference/reference_lua/socket.rst:200
msgid ""
"The ``socket.getaddrinfo()`` function is useful for finding information "
"about a remote site so that the correct arguments for "
"``sock:sysconnect()`` can be passed. This function may use the "
":ref:`worker_pool_threads <cfg_basic-worker_pool_threads>` configuration "
"parameter."
msgstr ""
"Функция ``socket.getaddrinfo()`` используется для поиска информации об "
"удаленном узле, чтобы можно было передать правильные аргументы для "
"``sock:sysconnect()``. Эта функция может использовать конфигурационный "
"параметр :ref:`worker_pool_threads <cfg_basic-worker_pool_threads>`."

#: ../doc/1.10/reference/reference_lua/socket.rst:206
#: ../doc/1.10/reference/reference_lua/socket.rst:594
#: ../doc/1.10/reference/reference_lua/socket.rst:606
msgid ""
"A table containing these fields: \"host\", \"family\", \"type\", "
"\"protocol\", \"port\"."
msgstr ""
"Таблица со следующими полями: \"host\", \"family\", \"type\", "
"\"protocol\", \"port\"."

#: ../doc/1.10/reference/reference_lua/socket.rst:211
msgid ""
"tarantool> socket.getaddrinfo('tarantool.org', 'http')\n"
"---\n"
"- - host: 188.93.56.70\n"
"    family: AF_INET\n"
"    type: SOCK_STREAM\n"
"    protocol: tcp\n"
"    port: 80\n"
"  - host: 188.93.56.70\n"
"    family: AF_INET\n"
"    type: SOCK_DGRAM\n"
"    protocol: udp\n"
"    port: 80\n"
"..."
msgstr ""
"tarantool> socket.getaddrinfo('tarantool.org', 'http')\n"
"---\n"
"- - host: 188.93.56.70\n"
"    family: AF_INET\n"
"    type: SOCK_STREAM\n"
"    protocol: tcp\n"
"    port: 80\n"
"  - host: 188.93.56.70\n"
"    family: AF_INET\n"
"    type: SOCK_DGRAM\n"
"    protocol: udp\n"
"    port: 80\n"
"..."

#: ../doc/1.10/reference/reference_lua/socket.rst:231
msgid ""
"The ``socket.tcp_server()`` function makes Tarantool act as a server that"
" can accept connections. Usually the same objective is accomplished with "
":ref:`box.cfg{listen=...} <cfg_basic-listen>`."
msgstr ""
"Функция ``socket.tcp_server()`` заставляет Tarantool выступать в качестве"
" сервера для принятия подключений. Обычно для этой же цели используется "
":ref:`box.cfg{listen=...} <cfg_basic-listen>`."

#: ../doc/1.10/reference/reference_lua/socket.rst:235
msgid "host name or IP"
msgstr "имя или IP хоста"

#: ../doc/1.10/reference/reference_lua/socket.rst:236
msgid "host port, may be 0"
msgstr "порт хоста, может быть 0"

#: ../doc/1.10/reference/reference_lua/socket.rst:237
msgid "what to execute when a connection occurs"
msgstr "что выполнить после подключения"

#: ../doc/1.10/reference/reference_lua/socket.rst:239
msgid "number of seconds to wait before timing out"
msgstr "количество секунд ожидания"

#: ../doc/1.10/reference/reference_lua/socket.rst:242
msgid ""
"The handler-function-or-table parameter may be simply a function name / "
"function declaration: :code:`handler_function`. Or it may be a table: "
":code:`{handler =` :samp:`{handler_function} [, prepare = "
"{prepare_function}] [, name = {name}]` :code:`}`. ``handler_function`` is"
" mandatory; it may have a single parameter = the socket; it is for "
"continuous operation after the connection is made. ``prepare_function`` "
"is optional; it is executed once before any connection is made. Examples:"
msgstr ""
"Параметр handler-function-or-table может представлять собой просто имя "
"функции или объявление функции: :code:`handler_function`. Или же может "
"быть таблицей: :code:`{handler =` :samp:`{handler_function} [, prepare = "
"{prepare_function}] [, name = {name}]` :code:`}`. Функция "
"``handler_function`` является обязательной, в ней может быть только один "
"параметр = сокет (используется для непрерывной работы после установки "
"соединения). Функция ``prepare_function`` необязательна; она выполняется "
"однократно перед установкой соединения. Например:"

#: ../doc/1.10/reference/reference_lua/socket.rst:254
msgid ""
"socket.tcp_server('localhost', 3302, function (s) loop_loop() end)\n"
"socket.tcp_server('localhost', 3302, {handler=hfunc, name='name'})\n"
"socket.tcp_server('localhost', 3302, {handler=hfunc, prepare=pfunc})"
msgstr ""
"socket.tcp_server('localhost', 3302, function (s) loop_loop() end)\n"
"socket.tcp_server('localhost', 3302, {handler=hfunc, name='name'})\n"
"socket.tcp_server('localhost', 3302, {handler=hfunc, prepare=pfunc})"

#: ../doc/1.10/reference/reference_lua/socket.rst:260
msgid ""
"For a fuller example see :ref:`Use tcp_server to accept file contents "
"sent with socat <socket_socat>`."
msgstr ""
"Более полный пример см. в разделе :ref:`Использование tcp_server для "
"получения содержимого файла, отправленного по socat <socket_socat>`."

#: ../doc/1.10/reference/reference_lua/socket.rst:269
msgid ""
"Connect an existing socket to a remote host. The argument values are the "
"same as in :ref:`tcp_connect() <socket-tcp_connect>`. The host must be an"
" IP address."
msgstr ""
"Подключение к удаленному хосту с помощью существующего сокета. Значения "
"аргументов будут такие же, как в :ref:`tcp_connect() <socket-"
"tcp_connect>`. Хост должен представлять собой IP-адрес."

#: ../doc/1.10/reference/reference_lua/socket.rst:286
msgid "Parameters:"
msgstr "Параметры:"

#: ../doc/1.10/reference/reference_lua/socket.rst:276
msgid "Either:"
msgstr "Либо:"

#: ../doc/1.10/reference/reference_lua/socket.rst:275
msgid "host - a string representation of an IPv4 address or an IPv6 address;"
msgstr "host -- строковое представление IPv4 адреса или IPv6 адреса;"

#: ../doc/1.10/reference/reference_lua/socket.rst:277
msgid "port - a number."
msgstr "port -- число."

#: ../doc/1.10/reference/reference_lua/socket.rst:279
#: ../doc/1.10/reference/reference_lua/socket.rst:286
msgid "Or:"
msgstr "Либо:"

#: ../doc/1.10/reference/reference_lua/socket.rst:279
msgid "host - a string containing \"unix/\";"
msgstr "host -- строка, которая содержит \"unix/\";"

#: ../doc/1.10/reference/reference_lua/socket.rst:280
msgid "port - a string containing a path to a unix socket."
msgstr "port -- строка, которая содержит путь к Unix-сокету."

#: ../doc/1.10/reference/reference_lua/socket.rst:282
msgid "host - a number, 0 (zero), meaning \"all local interfaces\";"
msgstr "host -- число, 0 (ноль), что означает \"все локальные интерфейсы\";"

#: ../doc/1.10/reference/reference_lua/socket.rst:284
msgid ""
"port - a number. If a port number is 0 (zero), the socket will be bound "
"to a random local port."
msgstr ""
"port -- число. Если номер порта -- 0 (ноль), сокет будет привязан к "
"случайному локальному порту."

#: ../doc/1.10/reference/reference_lua/socket.rst:288
msgid "the socket object value may change if sysconnect() succeeds."
msgstr ""
"значение объекта сокета может изменяться, если будет выполнена функция "
"sysconnect()."

#: ../doc/1.10/reference/reference_lua/socket.rst:293
msgid ""
"socket = require('socket')\n"
"sock = socket('AF_INET', 'SOCK_STREAM', 'tcp')\n"
"sock:sysconnect(0, 3301)"
msgstr ""
"socket = require('socket')\n"
"sock = socket('AF_INET', 'SOCK_STREAM', 'tcp')\n"
"sock:sysconnect(0, 3301)"

#: ../doc/1.10/reference/reference_lua/socket.rst:304
msgid "Send data over a connected socket."
msgstr "Отправка данных по подключенному сокету."

#: ../doc/1.10/reference/reference_lua/socket.rst:306
#: ../doc/1.10/reference/reference_lua/socket.rst:431
msgid "what is to be sent"
msgstr "что отправляется"

#: ../doc/1.10/reference/reference_lua/socket.rst:307
#: ../doc/1.10/reference/reference_lua/socket.rst:433
msgid "the number of bytes sent."
msgstr "количество отправляемых байтов."

#: ../doc/1.10/reference/reference_lua/socket.rst:310
msgid "Possible errors: nil on error."
msgstr "Возможные ошибки: nil в случае ошибки."

#: ../doc/1.10/reference/reference_lua/socket.rst:316
msgid ""
"Write as much data as possible to the socket buffer if non-blocking. "
"Rarely used. For details see `this description`_."
msgstr ""
"Запись максимально возможного количества данных в буфер сокета без "
"блокировки. Используется редко. Для получения подробной информации см. "
"описание по ссылке `this description`_."

#: ../doc/1.10/reference/reference_lua/socket.rst:323
msgid ""
"Read ``size`` bytes from a connected socket. An internal read-ahead "
"buffer is used to reduce the cost of this call."
msgstr ""
"Чтение количества байтов, определенного в ``size``, из подключенного "
"сокета. Внутренний буфер опережающего считывания используется для "
"уменьшения использования ресурсов на вызов."

#: ../doc/1.10/reference/reference_lua/socket.rst:326
#: ../doc/1.10/reference/reference_lua/socket.rst:444
msgid ""
"maximum number of bytes to receive. See :ref:`Recommended size <socket-"
"recommended>`."
msgstr ""
"максимальное количество получаемых байтов. См. :ref:`Рекомендованный "
"размер <socket-recommended>`."

#: ../doc/1.10/reference/reference_lua/socket.rst:327
msgid "a string of the requested length on success."
msgstr "строка запрошенной длины, если выполнено."

#: ../doc/1.10/reference/reference_lua/socket.rst:330
msgid ""
"Possible errors: On error, returns an empty string, followed by status, "
"errno, errstr. In case the writing side has closed its end, returns the "
"remainder read from the socket (possibly an empty string), followed by "
"\"eof\" status."
msgstr ""
"Возможные ошибки: В случае ошибки возвращается пустая строка, после чего "
"статус, errno, errstr. Если передача данных на запись закрыта с другой "
"стороны, возвращаются оставшиеся для чтения данные из сокета (возможно, "
"пустая строка), после чего идет статус \"eof\" (конец файла)."

#: ../doc/1.10/reference/reference_lua/socket.rst:341
msgid ""
"Read from a connected socket until some condition is true, and return the"
" bytes that were read. Reading goes on until ``limit`` bytes have been "
"read, or a delimiter has been read, or a timeout has expired. Unlike "
"``socket_object:recv`` (which uses an internal read-ahead buffer), "
"``socket_object:read`` depends on the socket's buffer."
msgstr ""
"Чтение данных из подключенного сокета до выполнения какого-либо условия и"
" возврат прочтенных байтов. Производится чтения количества байтов, "
"которое указано в параметре ``limit``, либо до символа-разделителя, либо "
"до истечения времени ожидания. В отличие от ``socket_object:recv`` (где "
"используется внутренний буфер опережающего считывания), "
"``socket_object:read`` зависит от буфера сокета."

#: ../doc/1.10/reference/reference_lua/socket.rst:348
#: ../doc/1.10/reference/reference_lua/socket.rst:373
msgid ""
"maximum number of bytes to read, for example 50 means \"stop after 50 "
"bytes\""
msgstr ""
"максимальное количество байтов для чтения, например, 50 означает "
"\"остановиться на 50 байтах\""

#: ../doc/1.10/reference/reference_lua/socket.rst:350
msgid "separator for example '?' means \"stop after a question mark\""
msgstr "разделитель, например, '?' означает \"остановиться после знака вопроса\""

#: ../doc/1.10/reference/reference_lua/socket.rst:352
msgid ""
"maximum number of seconds to wait, for example 50 means \"stop after 50 "
"seconds\"."
msgstr ""
"максимальное количество секунд ожидания, например, 50 означает "
"\"остановиться через 50 секунд\"."

#: ../doc/1.10/reference/reference_lua/socket.rst:354
msgid ""
":samp:`chunk={limit}` and/or :samp:`delimiter={delimiter}`, for example "
":code:`{chunk=5,delimiter='x'}`."
msgstr ""
":samp:`chunk={предел}` и/или :samp:`delimiter={разделитель}`, например, "
":code:`{chunk=5,delimiter='x'}`."

#: ../doc/1.10/reference/reference_lua/socket.rst:358
msgid ""
"an empty string if there is nothing more to read, or a nil value if "
"error, or a string up to ``limit`` bytes long, which may include the "
"bytes that matched the ``delimiter`` expression."
msgstr ""
"пустая строка, если нет данных для чтения, либо нулевое значение nil в "
"случае ошибки, либо строка, ограниченная количеством байтов в ``limit``, "
"которая может включать в себя байты, совпадающие с выражением "
"``delimiter``."

#: ../doc/1.10/reference/reference_lua/socket.rst:368
msgid ""
"Return data from the socket buffer if non-blocking. In case the socket is"
" blocking, ``sysread()`` can block the calling process. Rarely used. For "
"details, see also `this description "
"<https://github.com/tarantool/tarantool/wiki/sockets%201.6>`_."
msgstr ""
"Возврат данных из буфера сокета без блокировки.Если сокет с блокировкой, "
"``sysread()`` может блокировать процесс вызова. Используется редко. Для "
"получения подробной информации, см. `описание  "
"<https://github.com/tarantool/tarantool/wiki/sockets%201.6>`_."

#: ../doc/1.10/reference/reference_lua/socket.rst:376
msgid ""
"an empty string if there is nothing more to read, or a nil value if "
"error, or a string up to ``size`` bytes long."
msgstr ""
"пустая строка, если нет данных для чтения, либо нулевое значение nil в "
"случае ошибки, либо строка, ограниченная количеством байтов в ``size``."

#: ../doc/1.10/reference/reference_lua/socket.rst:384
msgid ""
"Bind a socket to the given host/port. A UDP socket after binding can be "
"used to receive data (see :ref:`socket_object.recvfrom <socket-"
"recvfrom>`). A TCP socket can be used to accept new connections, after it"
" has been put in listen mode."
msgstr ""
"Привязка сокета к данному хосту/порту. UDP-сокет после привязки может "
"использоваться для получения данных (см. :ref:`socket_object.recvfrom "
"<socket-recvfrom>`). TCP-сокет может использоваться для принятия новых "
"соединений после перевода в режим прослушивания."

#: ../doc/1.10/reference/reference_lua/socket.rst:392
msgid ""
"true for success, false for error. If return is false, use "
":ref:`socket_object:errno() <socket-error>` or "
":ref:`socket_object:error() <socket-error>` to see details."
msgstr ""
"true (правда), если выполнено, false (ложь) в случае ошибки. Если "
"возвращается false, используйте :ref:`socket_object:errno() <socket-"
"error>` или :ref:`socket_object:error() <socket-error>` для получения "
"подробной информации."

#: ../doc/1.10/reference/reference_lua/socket.rst:401
msgid "Start listening for incoming connections."
msgstr "Начало прослушивания входящих соединений."

#: ../doc/1.10/reference/reference_lua/socket.rst:403
msgid ""
"on Linux the listen ``backlog`` backlog may be from "
"``/proc/sys/net/core/somaxconn``, on BSD the backlog may be "
"``SOMAXCONN``."
msgstr ""
"в Linux очередь запросов ``backlog`` может быть в "
"``/proc/sys/net/core/somaxconn``, в BSD очередь запросов может "
"представлять собой ``SOMAXCONN``."

#: ../doc/1.10/reference/reference_lua/socket.rst:407
msgid "true for success, false for error."
msgstr "true (правда), если выполнено, false (ложь) в случае ошибки."

#: ../doc/1.10/reference/reference_lua/socket.rst:408
msgid "boolean."
msgstr "boolean (логический)."

#: ../doc/1.10/reference/reference_lua/socket.rst:414
msgid ""
"Accept a new client connection and create a new connected socket. It is "
"good practice to set the socket's blocking mode explicitly after "
"accepting."
msgstr ""
"Принятие нового клиентского соединения и создание нового подключенного "
"сокета. Установка блокирующего режима на сокете явным образом после "
"принятия соединения приведет к эффективной работе."

#: ../doc/1.10/reference/reference_lua/socket.rst:418
msgid "new socket if success."
msgstr "новый сокет, если выполнено."

#: ../doc/1.10/reference/reference_lua/socket.rst:421
msgid "Possible errors: nil."
msgstr "Возможные ошибки: nil."

#: ../doc/1.10/reference/reference_lua/socket.rst:427
msgid "Send a message on a UDP socket to a specified host."
msgstr "Отправка сообщения по UDP-сокету на указанный хост."

#: ../doc/1.10/reference/reference_lua/socket.rst:436
msgid ""
"Possible errors: on error, returns nil and may return status, errno, "
"errstr."
msgstr ""
"Возможные ошибки: в случае ошибки возвращает nil, а также может вернуть "
"статус, errno, errstr."

#: ../doc/1.10/reference/reference_lua/socket.rst:442
msgid "Receive a message on a UDP socket."
msgstr "Получение сообщения по UDP-сокету."

#: ../doc/1.10/reference/reference_lua/socket.rst:445
msgid "message, a table containing \"host\", \"family\" and \"port\" fields."
msgstr "сообщение, таблица с полями \"host\", \"family\" и \"port\"."

#: ../doc/1.10/reference/reference_lua/socket.rst:446
msgid "string, table"
msgstr "строка, таблица"

#: ../doc/1.10/reference/reference_lua/socket.rst:448
msgid "Possible errors: on error, returns status, errno, errstr."
msgstr "Возможные ошибки: в случае ошибки возвращает nil, статус, errno, errstr."

#: ../doc/1.10/reference/reference_lua/socket.rst:452
msgid ""
"After ``message_content, message_sender = recvfrom(1)`` the value of "
"``message_content`` might be a string containing 'X' and the value of "
"``message_sender`` might be a table containing"
msgstr ""
"После ``message_content, message_sender = recvfrom(1)`` значением "
"``message_content`` может быть строка, которая содержит 'X', а значением "
"``message_sender`` может быть таблица, которая содержит"

#: ../doc/1.10/reference/reference_lua/socket.rst:456
msgid ""
"message_sender.host = '18.44.0.1'\n"
"message_sender.family = 'AF_INET'\n"
"message_sender.port = 43065"
msgstr ""
"message_sender.host = '18.44.0.1'\n"
"message_sender.family = 'AF_INET'\n"
"message_sender.port = 43065"

#: ../doc/1.10/reference/reference_lua/socket.rst:466
msgid "Shutdown a reading end, a writing end, or both ends of a socket."
msgstr "Отключение передачи данных на чтение, на запись или в обоих направлениях."

#: ../doc/1.10/reference/reference_lua/socket.rst:468
msgid "socket.SHUT_RD, socket.SHUT_WR, or socket.SHUT_RDWR."
msgstr "socket.SHUT_RD, socket.SHUT_WR, or socket.SHUT_RDWR."

#: ../doc/1.10/reference/reference_lua/socket.rst:470
#: ../doc/1.10/reference/reference_lua/tap.rst:187
#: ../doc/1.10/reference/reference_lua/tap.rst:210
#: ../doc/1.10/reference/reference_lua/tap.rst:244
#: ../doc/1.10/reference/reference_lua/tap.rst:279
#: ../doc/1.10/reference/reference_lua/tap.rst:292
#: ../doc/1.10/reference/reference_lua/tap.rst:302
#: ../doc/1.10/reference/reference_lua/tap.rst:317
#: ../doc/1.10/reference/reference_lua/tap.rst:338
#: ../doc/1.10/reference/reference_lua/tap.rst:357
msgid "true or false."
msgstr "true (правда) или false (ложь)."

#: ../doc/1.10/reference/reference_lua/socket.rst:477
msgid ""
"Close (destroy) a socket. A closed socket should not be used any more. A "
"socket is closed automatically when the Lua garbage collector removes its"
" user data."
msgstr ""
"Закрытие (удаление) сокета. Закрытый сокет больше не должен "
"использоваться. Сокет будет закрыт автоматически, когда сборщик мусора "
"Lua удалит данные."

#: ../doc/1.10/reference/reference_lua/socket.rst:481
msgid ""
"true on success, false on error. For example, if sock is already closed, "
"sock:close() returns false."
msgstr ""
"true (правда), если выполнено, false (ложь) в случае ошибки. Например, "
"если сокет sock уже закрыт, sock:close() вернет false."

#: ../doc/1.10/reference/reference_lua/socket.rst:490
msgid ""
"Retrieve information about the last error that occurred on a socket, if "
"any. Errors do not cause throwing of exceptions so these functions are "
"usually necessary."
msgstr ""
"Получение информации о последней ошибке на сокете, если таковая была. "
"Ошибки не выдают исключения, поэтому данные функции необходимы."

#: ../doc/1.10/reference/reference_lua/socket.rst:493
msgid ""
"result for ``sock:errno()``, result for ``sock:error()``. If there is no "
"error, then ``sock:errno()`` will return 0 and ``sock:error()``."
msgstr ""
"результат ``sock:errno()``, результат ``sock:error()``. Если ошибки нет, "
"то ``sock:errno()`` вернет 0 и ``sock:error()``."

#: ../doc/1.10/reference/reference_lua/socket.rst:495
msgid "number, string"
msgstr "число, строка"

#: ../doc/1.10/reference/reference_lua/socket.rst:501
msgid ""
"Set socket flags. The argument values are the same as in the `Linux "
"getsockopt(2) man page <http://man7.org/linux/man-"
"pages/man2/setsockopt.2.html>`_. The ones that Tarantool accepts are:"
msgstr ""
"Определение флагов сокета. Значения аргумента будут такими же, что и на "
"`странице getsockopt(2) руководства по Linux <http://man7.org/linux/man-"
"pages/man2/setsockopt.2.html>`_. Tarantool принимает следующие:"

#: ../doc/1.10/reference/reference_lua/socket.rst:505
msgid "SO_ACCEPTCONN"
msgstr "SO_ACCEPTCONN"

#: ../doc/1.10/reference/reference_lua/socket.rst:506
msgid "SO_BINDTODEVICE"
msgstr "SO_BINDTODEVICE"

#: ../doc/1.10/reference/reference_lua/socket.rst:507
msgid "SO_BROADCAST"
msgstr "SO_BROADCAST"

#: ../doc/1.10/reference/reference_lua/socket.rst:508
msgid "SO_DEBUG"
msgstr "SO_DEBUG"

#: ../doc/1.10/reference/reference_lua/socket.rst:509
msgid "SO_DOMAIN"
msgstr "SO_DOMAIN"

#: ../doc/1.10/reference/reference_lua/socket.rst:510
msgid "SO_ERROR"
msgstr "SO_ERROR"

#: ../doc/1.10/reference/reference_lua/socket.rst:511
msgid "SO_DONTROUTE"
msgstr "SO_DONTROUTE"

#: ../doc/1.10/reference/reference_lua/socket.rst:512
msgid "SO_KEEPALIVE"
msgstr "SO_KEEPALIVE"

#: ../doc/1.10/reference/reference_lua/socket.rst:513
msgid "SO_MARK"
msgstr "SO_MARK"

#: ../doc/1.10/reference/reference_lua/socket.rst:514
msgid "SO_OOBINLINE"
msgstr "SO_OOBINLINE"

#: ../doc/1.10/reference/reference_lua/socket.rst:515
msgid "SO_PASSCRED"
msgstr "SO_PASSCRED"

#: ../doc/1.10/reference/reference_lua/socket.rst:516
msgid "SO_PEERCRED"
msgstr "SO_PEERCRED"

#: ../doc/1.10/reference/reference_lua/socket.rst:517
msgid "SO_PRIORITY"
msgstr "SO_PRIORITY"

#: ../doc/1.10/reference/reference_lua/socket.rst:518
msgid "SO_PROTOCOL"
msgstr "SO_PROTOCOL"

#: ../doc/1.10/reference/reference_lua/socket.rst:519
msgid "SO_RCVBUF"
msgstr "SO_RCVBUF"

#: ../doc/1.10/reference/reference_lua/socket.rst:520
msgid "SO_RCVBUFFORCE"
msgstr "SO_RCVBUFFORCE"

#: ../doc/1.10/reference/reference_lua/socket.rst:521
msgid "SO_RCVLOWAT"
msgstr "SO_RCVLOWAT"

#: ../doc/1.10/reference/reference_lua/socket.rst:522
msgid "SO_SNDLOWAT"
msgstr "SO_SNDLOWAT"

#: ../doc/1.10/reference/reference_lua/socket.rst:523
msgid "SO_RCVTIMEO"
msgstr "SO_RCVTIMEO"

#: ../doc/1.10/reference/reference_lua/socket.rst:524
msgid "SO_SNDTIMEO"
msgstr "SO_SNDTIMEO"

#: ../doc/1.10/reference/reference_lua/socket.rst:525
msgid "SO_REUSEADDR"
msgstr "SO_REUSEADDR"

#: ../doc/1.10/reference/reference_lua/socket.rst:526
msgid "SO_SNDBUF"
msgstr "SO_SNDBUF"

#: ../doc/1.10/reference/reference_lua/socket.rst:527
msgid "SO_SNDBUFFORCE"
msgstr "SO_SNDBUFFORCE"

#: ../doc/1.10/reference/reference_lua/socket.rst:528
msgid "SO_TIMESTAMP"
msgstr "SO_TIMESTAMP"

#: ../doc/1.10/reference/reference_lua/socket.rst:529
msgid "SO_TYPE"
msgstr "SO_TYPE"

#: ../doc/1.10/reference/reference_lua/socket.rst:531
msgid "Setting SO_LINGER is done with ``sock:linger(active)``."
msgstr ""
"Установка флага SO_LINGER осуществляется с помощью "
"``sock:linger(active)``."

#: ../doc/1.10/reference/reference_lua/socket.rst:537
msgid "Get socket flags. For a list of possible flags see ``sock:setsockopt()``."
msgstr ""
"Получение флагов сокета. Список возможных флагов см. с помощью "
"``sock:setsockopt()``."

#: ../doc/1.10/reference/reference_lua/socket.rst:543
msgid ""
"Set or clear the SO_LINGER flag. For a description of the flag, see the "
"`Linux man page <http://man7.org/linux/man-pages/man1/loginctl.1.html>`_."
msgstr ""
"Установить или убрать флаг SO_LINGER. Описание флага см. в `руководстве "
"по Linux <http://man7.org/linux/man-pages/man1/loginctl.1.html>`_."

#: ../doc/1.10/reference/reference_lua/socket.rst:548
msgid "new active and timeout values."
msgstr "новые значения active и timeout."

#: ../doc/1.10/reference/reference_lua/socket.rst:554
msgid "``sock:nonblock()`` returns the current flag value."
msgstr "``sock:nonblock()`` возвращает текущее значение флага."

#: ../doc/1.10/reference/reference_lua/socket.rst:555
msgid "``sock:nonblock(false)`` sets the flag to false and returns false."
msgstr "``sock:nonblock(false)`` устанавливает флаг на false и возвращает false."

#: ../doc/1.10/reference/reference_lua/socket.rst:556
msgid "``sock:nonblock(true)`` sets the flag to true and returns true."
msgstr "``sock:nonblock(true)`` устанавливает флаг на true и возвращает true."

#: ../doc/1.10/reference/reference_lua/socket.rst:558
msgid ""
"This function may be useful before invoking a function which might "
"otherwise block indefinitely."
msgstr ""
"Эту функцию можно использовать до вызова функции, которая в противном "
"случае будет блокировать бесконечно."

#: ../doc/1.10/reference/reference_lua/socket.rst:565
msgid "Wait until something is readable, or until a timeout value expires."
msgstr ""
"Ожидание доступности чего-либо для чтения или до истечения времени "
"ожидания."

#: ../doc/1.10/reference/reference_lua/socket.rst:567
msgid "true if the socket is now readable, false if timeout expired;"
msgstr "true, если сокет доступен для чтения, false, если истекло время ожидания;"

#: ../doc/1.10/reference/reference_lua/socket.rst:573
msgid "Wait until something is writable, or until a timeout value expires."
msgstr ""
"Ожидание доступности чего-либо для записи или до истечения времени "
"ожидания."

#: ../doc/1.10/reference/reference_lua/socket.rst:575
msgid "true if the socket is now writable, false if timeout expired;"
msgstr "true, если сокет доступен для записи, false, если истекло время ожидания;"

#: ../doc/1.10/reference/reference_lua/socket.rst:581
msgid ""
"Wait until something is either readable or writable, or until a timeout "
"value expires."
msgstr ""
"Ожидание доступности чего-либо для чтения или записи, или до истечения "
"времени ожидания."

#: ../doc/1.10/reference/reference_lua/socket.rst:583
msgid ""
"'R' if the socket is now readable, 'W' if the socket is now writable, "
"'RW' if the socket is now both readable and writable, '' (empty string) "
"if timeout expired;"
msgstr ""
"'R', если сокет доступен для чтения, 'W', если сокет доступен для записи,"
" 'RW', если сокет доступен и для чтения, и для записи, '' (пустая "
"строка), если истекло время ожидания;"

#: ../doc/1.10/reference/reference_lua/socket.rst:589
msgid ""
"The ``sock:name()`` function is used to get information about the near "
"side of the connection. If a socket was bound to ``xyz.com:45``, then "
"``sock:name`` will return information about ``[host:xyz.com, port:45]``. "
"The equivalent POSIX function is ``getsockname()``."
msgstr ""
"Функция ``sock:name()`` используется для получения информации о ближней "
"стороне соединения. Если сокет привязан к ``xyz.com:45``, то "
"``sock:name`` вернет информацию о ``[host:xyz.com, port:45]``. "
"Аналогичная функция в POSIX -- ``getsockname()``."

#: ../doc/1.10/reference/reference_lua/socket.rst:601
msgid ""
"The ``sock:peer()`` function is used to get information about the far "
"side of a connection. If a TCP connection has been made to a distant host"
" ``tarantool.org:80``, ``sock:peer()`` will return information about "
"``[host:tarantool.org, port:80]``. The equivalent POSIX function is "
"``getpeername()``."
msgstr ""
"Функция ``sock:peer()`` используется для получения информации о дальней "
"стороне соединения. Если TCP-соединение установлено с удаленным хостом "
"``tarantool.org:80``, то ``sock:peer()`` вернет информацию о "
"``[host:tarantool.org, port:80]``. Аналогичная функция в POSIX --  "
"``getpeername()``."

#: ../doc/1.10/reference/reference_lua/socket.rst:613
msgid ""
"The ``socket.iowait()`` function is used to wait until read-or-write "
"activity occurs for a file descriptor."
msgstr ""
"Функция ``socket.iowait()`` используется для ожидания, пока дескриптор "
"файла не будет активен для чтения или записи."

#: ../doc/1.10/reference/reference_lua/socket.rst:616
msgid "file descriptor"
msgstr "дескриптор файла"

#: ../doc/1.10/reference/reference_lua/socket.rst:617
msgid "'R' or 1 = read, 'W' or 2 = write, 'RW' or 3 = read|write."
msgstr "'R' или 1 = чтение, 'W' или 2 = запись, 'RW' или 3 = чтение|запись."

#: ../doc/1.10/reference/reference_lua/socket.rst:618
msgid "number of seconds to wait"
msgstr "количество секунд ожидания"

#: ../doc/1.10/reference/reference_lua/socket.rst:620
msgid ""
"If the fd parameter is nil, then there will be a sleep until the timeout."
" If the timeout parameter is nil or unspecified, then timeout is "
"infinite."
msgstr ""
"Если значение параметра fd -- nil, то будет режим ожидания до истечения "
"времени, указанного в параметре timeout. Если timeout -- nil или не "
"указан, время ожидания считается бесконечным."

#: ../doc/1.10/reference/reference_lua/socket.rst:623
msgid ""
"Ordinarily the return value is the activity that occurred ('R' or 'W' or "
"'RW' or 1 or 2 or 3). If the timeout period goes by without any reading "
"or writing, the return is an error = ETIMEDOUT."
msgstr ""
"Как правило, возвращается значение совершенного действия ('R' или 'W', "
"или 'RW', или 1, или 2, или 3). Если время ожидания в timeout проходит "
"без действий чтения или записи, возвращается ошибка = ETIMEDOUT."

#: ../doc/1.10/reference/reference_lua/socket.rst:627
msgid "Example: ``socket.iowait(sock:fd(), 'r', 1.11)``"
msgstr "Пример: ``socket.iowait(sock:fd(), 'r', 1.11)``"

#: ../doc/1.10/reference/reference_lua/socket.rst:633
msgid "Recommended size"
msgstr "Рекомендованный размер"

#: ../doc/1.10/reference/reference_lua/socket.rst:635
msgid ""
"For ``recv`` and ``recvfrom``: use the optional ``size`` parameter to "
"limit the number of bytes to receive. A fixed size such as 512 is often "
"reasonable; a pre-calculated size that depends on context -- such as the "
"message format or the state of the network -- is often better. For "
"``recvfrom``, be aware that a size greater than the `Maximum Transmission"
" Unit <https://en.wikipedia.org/wiki/Maximum_transmission_unit>`_ can "
"cause inefficient transport. For Mac OS X, be aware that the size can be "
"tuned by changing ``sysctl net.inet.udp.maxdgram``."
msgstr ""
"Для ``recv`` и ``recvfrom``: используйте необязательный параметр "
"``size``, чтобы ограничить количество получаемых байтов. Часто "
"используется заданный размер, такой как 512; но во многих случаях лучше "
"использовать предварительно рассчитанный размер, который зависит от "
"контекста -- как формат сообщения или состояние сети. Что касается "
"``recvfrom``, следует помнить, что размер больше максимального размера "
"полезного блока данных одного пакета (`Maximum Transmission Unit "
"<https://en.wikipedia.org/wiki/Maximum_transmission_unit>`_) может "
"вызвать низкоэффективную передачу данных. Что касается Mac OS X, следует "
"отметить, что размер можно настроить с помощью ``sysctl "
"net.inet.udp.maxdgram``."

#: ../doc/1.10/reference/reference_lua/socket.rst:646
msgid ""
"If ``size`` is not stated: Tarantool will make an extra call to calculate"
" how many bytes are necessary. This extra call takes time, therefore not "
"stating ``size`` may be inefficient."
msgstr ""
"Если размер ``size`` не задан: Tarantool сделает дополнительный вызов для"
" расчет необходимого количества байтов. Такой дополнительный вызов "
"занимает время, поэтому во избежание низкой эффективности лучше указать "
"``size``."

#: ../doc/1.10/reference/reference_lua/socket.rst:650
msgid ""
"If ``size`` is stated: on a UDP socket, excess bytes are discarded. On a "
"TCP socket, excess bytes are not discarded and can be received by the "
"next call."
msgstr ""
"Если размер ``size`` задан: в UDP-сокете лишние байты отбрасываются; в "
"TCP-сокете лишние байты не отбрасываются, их можно получить при следующем"
" вызове."

#: ../doc/1.10/reference/reference_lua/socket.rst:660
msgid "Use of a TCP socket over the Internet"
msgstr "Использование TCP-сокета в интернете"

#: ../doc/1.10/reference/reference_lua/socket.rst:662
msgid ""
"In this example a connection is made over the internet between a "
"Tarantool instance and tarantool.org, then an HTTP \"head\" message is "
"sent, and a response is received: \"``HTTP/1.1 200 OK``\" or something "
"else if the site has moved. This is not a useful way to communicate with "
"this particular site, but shows that the system works."
msgstr ""
"В данном примере устанавливается соединение по интернету между "
"экземпляром Tarantool'а и tarantool.org, затем отправляется "
"HTTP-сообщение заголовка \"head\" и возвращается ответ: \"``HTTP/1.1 200 "
"OK``\" или что-то другое, если сайт перемещен. Так не слишком удобно "
"взаимодействовать с определенным сайтом, но пример показывает работу "
"системы."

#: ../doc/1.10/reference/reference_lua/socket.rst:668
msgid ""
"tarantool> socket = require('socket')\n"
"---\n"
"...\n"
"tarantool> sock = socket.tcp_connect('tarantool.org', 80)\n"
"---\n"
"...\n"
"tarantool> type(sock)\n"
"---\n"
"- table\n"
"...\n"
"tarantool> sock:error()\n"
"---\n"
"- null\n"
"...\n"
"tarantool> sock:send(\"HEAD / HTTP/1.0\\r\\nHost: "
"tarantool.org\\r\\n\\r\\n\")\n"
"---\n"
"- 40\n"
"...\n"
"tarantool> sock:read(17)\n"
"---\n"
"- HTTP/1.1 302 Move\n"
"...\n"
"tarantool> sock:close()\n"
"---\n"
"- true\n"
"..."
msgstr ""
"tarantool> socket = require('socket')\n"
"---\n"
"...\n"
"tarantool> sock = socket.tcp_connect('tarantool.org', 80)\n"
"---\n"
"...\n"
"tarantool> type(sock)\n"
"---\n"
"- table\n"
"...\n"
"tarantool> sock:error()\n"
"---\n"
"- null\n"
"...\n"
"tarantool> sock:send(\"HEAD / HTTP/1.0\\r\\nHost: "
"tarantool.org\\r\\n\\r\\n\")\n"
"---\n"
"- 40\n"
"...\n"
"tarantool> sock:read(17)\n"
"---\n"
"- HTTP/1.1 302 Move\n"
"...\n"
"tarantool> sock:close()\n"
"---\n"
"- true\n"
"..."

#: ../doc/1.10/reference/reference_lua/socket.rst:699
msgid "Use of a UDP socket on localhost"
msgstr "Использование UDP-сокета на localhost"

#: ../doc/1.10/reference/reference_lua/socket.rst:701
msgid ""
"Here is an example with datagrams. Set up two connections on 127.0.0.1 "
"(localhost): ``sock_1`` and ``sock_2``. Using ``sock_2``, send a message "
"to ``sock_1``. Using ``sock_1``, receive a message. Display the received "
"message. Close both connections. |br| This is not a useful way for a "
"computer to communicate with itself, but shows that the system works."
msgstr ""
"Ниже приведен пример с датаграммами. Устанавливается два соединения с "
"127.0.0.1 (localhost): ``sock_1`` и ``sock_2``. С помощью ``sock_2`` "
"отправляется сообщение на ``sock_1``. С помощью ``sock_1`` получается "
"сообщение. Отображается полученное сообщение. Оба соединения закрываются."
" |br| Компьютеру так не слишком удобно взаимодействовать с самим собой, "
"но пример показывает работу системы."

#: ../doc/1.10/reference/reference_lua/socket.rst:707
msgid ""
"tarantool> socket = require('socket')\n"
"---\n"
"...\n"
"tarantool> sock_1 = socket('AF_INET', 'SOCK_DGRAM', 'udp')\n"
"---\n"
"...\n"
"tarantool> sock_1:bind('127.0.0.1')\n"
"---\n"
"- true\n"
"...\n"
"tarantool> sock_2 = socket('AF_INET', 'SOCK_DGRAM', 'udp')\n"
"---\n"
"...\n"
"tarantool> sock_2:sendto('127.0.0.1', sock_1:name().port,'X')\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> message = sock_1:recvfrom(512)\n"
"---\n"
"...\n"
"tarantool> message\n"
"---\n"
"- X\n"
"...\n"
"tarantool> sock_1:close()\n"
"---\n"
"- true\n"
"...\n"
"tarantool> sock_2:close()\n"
"---\n"
"- true\n"
"..."
msgstr ""
"tarantool> socket = require('socket')\n"
"---\n"
"...\n"
"tarantool> sock_1 = socket('AF_INET', 'SOCK_DGRAM', 'udp')\n"
"---\n"
"...\n"
"tarantool> sock_1:bind('127.0.0.1')\n"
"---\n"
"- true\n"
"...\n"
"tarantool> sock_2 = socket('AF_INET', 'SOCK_DGRAM', 'udp')\n"
"---\n"
"...\n"
"tarantool> sock_2:sendto('127.0.0.1', sock_1:name().port,'X')\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> message = sock_1:recvfrom(512)\n"
"---\n"
"...\n"
"tarantool> message\n"
"---\n"
"- X\n"
"...\n"
"tarantool> sock_1:close()\n"
"---\n"
"- true\n"
"...\n"
"tarantool> sock_2:close()\n"
"---\n"
"- true\n"
"..."

#: ../doc/1.10/reference/reference_lua/socket.rst:746
msgid "Use tcp_server to accept file contents sent with socat"
msgstr ""
"Использование tcp_server для получения содержимого файла, отправленного "
"по socat"

#: ../doc/1.10/reference/reference_lua/socket.rst:748
msgid ""
"Here is an example of the tcp_server function, reading strings from the "
"client and printing them. On the client side, the Linux socat utility "
"will be used to ship a whole file for the tcp_server function to read."
msgstr ""
"Ниже приведен пример функции ``tcp_server``, которая читает строки с "
"клиента и выводит результат. На клиентской стороне утилита ``socat`` в "
"Linux будет использоваться для отправки целого файла на чтение функции "
"``tcp_server``."

#: ../doc/1.10/reference/reference_lua/socket.rst:753
msgid ""
"Start two shells. The first shell will be a server instance. The second "
"shell will be the client."
msgstr ""
"Запустите две оболочки. Первая оболочка будет экземпляром сервера. Вторая"
" оболочка будет клиентом."

#: ../doc/1.10/reference/reference_lua/socket.rst:756
msgid "On the first shell, start Tarantool and say:"
msgstr "В первой оболочке запустите Tarantool и выполните:"

#: ../doc/1.10/reference/reference_lua/socket.rst:758
msgid ""
"box.cfg{}\n"
"socket = require('socket')\n"
"socket.tcp_server('0.0.0.0', 3302,\n"
"{\n"
"  handler = function(s)\n"
"    while true do\n"
"      local request\n"
"      request = s:read(\"\\n\");\n"
"      if request == \"\" or request == nil then\n"
"        break\n"
"      end\n"
"      print(request)\n"
"    end\n"
"  end,\n"
"  prepare = function()\n"
"    print('Initialized')\n"
"  end\n"
"}\n"
")"
msgstr ""
"box.cfg{}\n"
"socket = require('socket')\n"
"socket.tcp_server('0.0.0.0', 3302,\n"
"{\n"
"  handler = function(s)\n"
"    while true do\n"
"      local request\n"
"      request = s:read(\"\\n\");\n"
"      if request == \"\" or request == nil then\n"
"        break\n"
"      end\n"
"      print(request)\n"
"    end\n"
"  end,\n"
"  prepare = function()\n"
"    print('Initialized')\n"
"  end\n"
"}\n"
")"

#: ../doc/1.10/reference/reference_lua/socket.rst:780
msgid ""
"The above code means: use `tcp_server()` to wait for a connection from "
"any host on port 3302. When it happens, enter a loop that reads on the "
"socket and prints what it reads. The \"delimiter\" for the read function "
"is \"\\\\n\" so each `read()` will read a string as far as the next line "
"feed, including the line feed."
msgstr ""
"Вышеуказанный код означает: использовать `tcp_server()` для ожидания "
"подключения с любого хоста по порту 3302. Когда это произойдет, ввести "
"цикл, который читает по сокету и выводит результат чтения. Разделителем "
"для функции чтения будет \"\\\\n\", поэтому каждое выполнение `read()` "
"выполнит чтение строки до перевода строки, включая перевод строки."

#: ../doc/1.10/reference/reference_lua/socket.rst:787
msgid ""
"On the second shell, create a file that contains a few lines. The "
"contents don't matter. Suppose the first line contains A, the second line"
" contains B, the third line contains C. Call this file \"tmp.txt\"."
msgstr ""
"Во второй оболочке создайте файл, который содержит несколько строк. "
"Содержимое не имеет значения. Предположим, что первая строка содержит A, "
"вторая строка содержит B, третья строка содержит C. Назовите этот файл "
"\"tmp.txt\"."

#: ../doc/1.10/reference/reference_lua/socket.rst:792
msgid ""
"On the second shell, use the socat utility to ship the tmp.txt file to "
"the server instance's host and port:"
msgstr ""
"Во второй оболочке используйте утилиту socat для отправки файла tmp.txt "
"на экземпляр сервера по хосту и порту:"

#: ../doc/1.10/reference/reference_lua/socket.rst:795
msgid "$ socat TCP:localhost:3302 ./tmp.txt"
msgstr "$ socat TCP:localhost:3302 ./tmp.txt"

#: ../doc/1.10/reference/reference_lua/socket.rst:799
msgid ""
"Now watch what happens on the first shell. The strings \"A\", \"B\", "
"\"C\" are printed."
msgstr ""
"Теперь смотрите, что происходит в первой оболочке. Выводятся строки "
"\"A\", \"B\", \"C\"."

#: ../doc/1.10/reference/reference_lua/strict.rst:39
msgid "Module `strict`"
msgstr "Модуль `strict`"

#: ../doc/1.10/reference/reference_lua/strict.rst:43
msgid ""
"The :code:`strict` module has functions for turning \"strict mode\" on or"
" off. When strict mode is on, an attempt to use an undeclared global "
"variable will cause an error. A global variable is considered "
"\"undeclared\" if it has never had a value assigned to it. Often this is "
"an indication of a programming error."
msgstr ""
"Модуль :code:`strict` включает в себя функции для включения или "
"отключения строгого режима \"strict mode\". Когда включен строгий режим, "
"попытка использовать необъявленную глобальную переменную приведет к "
"ошибке. Глобальная переменная считается необъявленной, если ей никогда не"
" было присвоено значение. Часто это указывает на ошибку программирования."

#: ../doc/1.10/reference/reference_lua/strict.rst:48
msgid ""
"By default strict mode is off, unless tarantool was built with the "
"``-DCMAKE_BUILD_TYPE=Debug`` option -- see the description of build "
"options in section :ref:`building-from-source <building_from_source>`."
msgstr ""
"По умолчанию, строгий режим отключен, не считая случаев, когда сборка "
"Tarantool'а производилась с помощью ``-DCMAKE_BUILD_TYPE=Debug`` -- см. "
"варианты сборки в разделе :ref:`сборка из исходников "
"<building_from_source>`."

#: ../doc/1.10/reference/reference_lua/strict.rst:54
msgid ""
"tarantool> strict = require('strict')\n"
"---\n"
"...\n"
"tarantool> strict.on()\n"
"---\n"
"...\n"
"tarantool> a = b -- strict mode is on so this will cause an error\n"
"---\n"
"- error: ... variable ''b'' is not declared'\n"
"...\n"
"tarantool> strict.off()\n"
"---\n"
"...\n"
"tarantool> a = b -- strict mode is off so this will not cause an error\n"
"---\n"
"..."
msgstr ""
"tarantool> strict = require('strict')\n"
"---\n"
"...\n"
"tarantool> strict.on()\n"
"---\n"
"...\n"
"tarantool> a = b -- строгий режим включен, поэтому появляется ошибка\n"
"---\n"
"- error: ... variable ''b'' is not declared'\n"
"...\n"
"tarantool> strict.off()\n"
"---\n"
"...\n"
"tarantool> a = b -- строгий режим отключен, поэтому ошибки нет\n"
"---\n"
"..."

#: ../doc/1.10/reference/reference_lua/string.rst:39
msgid "Module `string`"
msgstr "Модуль `string`"

#: ../doc/1.10/reference/reference_lua/string.rst:47
msgid ""
"The :code:`string` module has everything in the `standard Lua string "
"library <https://www.lua.org/pil/20.html>`_, and some Tarantool "
"extensions."
msgstr ""
"Модуль :code:`string` включает в себя всё из `стандартной библиотеки для "
"работы со строками в Lua <https://www.lua.org/pil/20.html>`_, а также "
"некоторые расширения специально для Tarantool'а."

#: ../doc/1.10/reference/reference_lua/string.rst:51
msgid ""
"In this section we only discuss the additional functions that the "
"Tarantool developers have added."
msgstr ""
"В данном разделе мы рассматриваем только дополнительные функции, "
"добавленные разработчиками Tarantool'а."

#: ../doc/1.10/reference/reference_lua/string.rst:54
msgid "Below is a list of all additional ``string`` functions."
msgstr "Ниже приведен перечень всех функций библиотеки ``string``."

#: ../doc/1.10/reference/reference_lua/string.rst:64
msgid ":ref:`string.ljust() <string-ljust>`"
msgstr ":ref:`string.ljust() <string-ljust>`"

#: ../doc/1.10/reference/reference_lua/string.rst:64
msgid "Left-justify a string"
msgstr "Выравнивание строки по левому полю"

#: ../doc/1.10/reference/reference_lua/string.rst:67
msgid ":ref:`string.rjust() <string-rjust>`"
msgstr ":ref:`string.rjust() <string-rjust>`"

#: ../doc/1.10/reference/reference_lua/string.rst:67
msgid "Right-justify a string"
msgstr "Выравнивание строки по правому полю"

#: ../doc/1.10/reference/reference_lua/string.rst:70
msgid ":ref:`string.hex() <string-hex>`"
msgstr ":ref:`string.hex() <string-hex>`"

#: ../doc/1.10/reference/reference_lua/string.rst:70
msgid "Get the hexadecimal value of a string"
msgstr "Получение шестнадцатеричного значения строки"

#: ../doc/1.10/reference/reference_lua/string.rst:73
msgid ":ref:`string.startswith() <string-startswith>`"
msgstr ":ref:`string.startswith() <string-startswith>`"

#: ../doc/1.10/reference/reference_lua/string.rst:73
msgid "Check if a string starts with a given substring"
msgstr "Проверка, начинается ли строка с заданной подстроки"

#: ../doc/1.10/reference/reference_lua/string.rst:76
msgid ":ref:`string.endswith() <string-endswith>`"
msgstr ":ref:`string.endswith() <string-endswith>`"

#: ../doc/1.10/reference/reference_lua/string.rst:76
msgid "Check if a string ends with a given substring"
msgstr "Проверка, заканчивается ли строка на заданную подстроку"

#: ../doc/1.10/reference/reference_lua/string.rst:79
msgid ":ref:`string.lstrip() <string-lstrip>`"
msgstr ":ref:`string.lstrip() <string-lstrip>`"

#: ../doc/1.10/reference/reference_lua/string.rst:79
msgid "Remove spaces on the left of a string"
msgstr "Удаление пробелов слева от строки"

#: ../doc/1.10/reference/reference_lua/string.rst:82
msgid ":ref:`string.rstrip() <string-rstrip>`"
msgstr ":ref:`string.rstrip() <string-rstrip>`"

#: ../doc/1.10/reference/reference_lua/string.rst:82
msgid "Remove spaces on the right of a string"
msgstr "Удаление пробелов справа от строки"

#: ../doc/1.10/reference/reference_lua/string.rst:85
msgid ":ref:`string.split() <string-split>`"
msgstr ":ref:`string.split() <string-split>`"

#: ../doc/1.10/reference/reference_lua/string.rst:85
msgid "Split a string into a table of strings"
msgstr "Разделение строки на таблицу со строками"

#: ../doc/1.10/reference/reference_lua/string.rst:88
msgid ":ref:`string.strip() <string-strip>`"
msgstr ":ref:`string.strip() <string-strip>`"

#: ../doc/1.10/reference/reference_lua/string.rst:88
msgid "Remove spaces on the left and right of a string"
msgstr "Удаление пробелов слева и справа от строки"

#: ../doc/1.10/reference/reference_lua/string.rst:97
msgid "Return the string left-justified in a string of length ``width``."
msgstr ""
"Возврат строки, выровненной по левому краю, шириной, указанной в "
"``width``."

#: ../doc/1.10/reference/reference_lua/string.rst:99
msgid "(string) the string to left-justify"
msgstr "(строка) строка для выравнивания по левому краю"

#: ../doc/1.10/reference/reference_lua/string.rst:100
msgid "(integer) the width of the string after left-justifying"
msgstr "(целое число) ширина строки после выравнивания по левому краю"

#: ../doc/1.10/reference/reference_lua/string.rst:101
#: ../doc/1.10/reference/reference_lua/string.rst:126
msgid "(string) a single character, default = 1 space"
msgstr "(строка) отдельный символ, по умолчанию = 1 пробел"

#: ../doc/1.10/reference/reference_lua/string.rst:103
msgid "left-justified string (unchanged if width <= string length)"
msgstr ""
"выровненная по левому краю строка (не изменяется, если ширина <= длине "
"строки)"

#: ../doc/1.10/reference/reference_lua/string.rst:108
msgid ""
"tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.ljust(' A', 5)\n"
"---\n"
"- ' A   '\n"
"..."
msgstr ""
"tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.ljust(' A', 5)\n"
"---\n"
"- ' A   '\n"
"..."

#: ../doc/1.10/reference/reference_lua/string.rst:122
msgid "Return the string right-justified in a string of length ``width``."
msgstr ""
"Возврат строки, выровненной по правому краю, шириной, указанной в "
"``width``."

#: ../doc/1.10/reference/reference_lua/string.rst:124
msgid "(string) the string to right-justify"
msgstr "(строка) строка для выравнивания по правому краю"

#: ../doc/1.10/reference/reference_lua/string.rst:125
msgid "(integer) the width of the string after right-justifying"
msgstr "(целое число) ширина строки после выравнивания по правому краю"

#: ../doc/1.10/reference/reference_lua/string.rst:128
msgid "right-justified string (unchanged if width <= string length)"
msgstr ""
"выровненная по правому краю строка (не изменяется, если ширина <= длине "
"строки)"

#: ../doc/1.10/reference/reference_lua/string.rst:133
msgid ""
"tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.rjust('', 5, 'X')\n"
"---\n"
"- 'XXXXX'\n"
"..."
msgstr ""
"tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.rjust('', 5, 'X')\n"
"---\n"
"- 'XXXXX'\n"
"..."

#: ../doc/1.10/reference/reference_lua/string.rst:147
msgid "Return the hexadecimal value of the input string."
msgstr "Возврат шестнадцатеричного значения введенной строки."

#: ../doc/1.10/reference/reference_lua/string.rst:149
#: ../doc/1.10/reference/reference_lua/string.rst:233
#: ../doc/1.10/reference/reference_lua/string.rst:256
#: ../doc/1.10/reference/reference_lua/string.rst:307
msgid "(string) the string to process"
msgstr "(строка) обрабатываемая строка"

#: ../doc/1.10/reference/reference_lua/string.rst:151
msgid "hexadecimal, 2 hex-digit characters for each input character"
msgstr ""
"шестнадцатеричное число, два символа шестнадцатеричных цифр для каждого "
"введенного символа"

#: ../doc/1.10/reference/reference_lua/string.rst:156
msgid ""
"tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.hex('ABC ')\n"
"---\n"
"- '41424320'\n"
"..."
msgstr ""
"tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.hex('ABC ')\n"
"---\n"
"- '41424320'\n"
"..."

#: ../doc/1.10/reference/reference_lua/string.rst:170
msgid ""
"Return True if ``input-string`` starts with ``start-string``, otherwise "
"return False."
msgstr ""
"Возврат true (правда), если ``input-string`` начинается со ``start-"
"string``, в противном случае, возврат false (ложь)."

#: ../doc/1.10/reference/reference_lua/string.rst:173
msgid "(string) the string where ``start-string`` should be looked for"
msgstr "(строка) строка, где производится поиск данных из ``start-string``"

#: ../doc/1.10/reference/reference_lua/string.rst:174
#: ../doc/1.10/reference/reference_lua/string.rst:204
msgid "(string) the string to look for"
msgstr "(строка) искомая строка"

#: ../doc/1.10/reference/reference_lua/string.rst:175
#: ../doc/1.10/reference/reference_lua/string.rst:205
msgid "(integer) position: where to start looking within ``input-string``"
msgstr "(целое число) положение: где начинать искать в пределах ``input-string``"

#: ../doc/1.10/reference/reference_lua/string.rst:176
#: ../doc/1.10/reference/reference_lua/string.rst:206
msgid "(integer) position: where to end looking within ``input-string``"
msgstr ""
"(целое число) положение: где заканчивать искать в пределах ``input-"
"string``"

#: ../doc/1.10/reference/reference_lua/string.rst:181
#: ../doc/1.10/reference/reference_lua/string.rst:211
msgid ""
"``start-pos`` and ``end-pos`` may be negative, meaning the position "
"should be calculated from the end of the string."
msgstr ""
"Значения ``start-pos`` и ``end-pos`` могут быть отрицательными, что "
"означает, что положение вычисляется с конца строки."

#: ../doc/1.10/reference/reference_lua/string.rst:186
msgid ""
"tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.startswith(' A', 'A', 2, 5)\n"
"---\n"
"- true\n"
"..."
msgstr ""
"tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.startswith(' A', 'A', 2, 5)\n"
"---\n"
"- true\n"
"..."

#: ../doc/1.10/reference/reference_lua/string.rst:200
msgid ""
"Return True if ``input-string`` ends with ``end-string``, otherwise "
"return False."
msgstr ""
"Возврат true (правда), если ``input-string`` заканчивается на ``end-"
"string``, в противном случае, возврат false (ложь)."

#: ../doc/1.10/reference/reference_lua/string.rst:203
msgid "(string) the string where ``end-string`` should be looked for"
msgstr "(строка) строка, где производится поиск данных из ``end-string``"

#: ../doc/1.10/reference/reference_lua/string.rst:216
msgid ""
"tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.endswith('Baa', 'aa')\n"
"---\n"
"- true\n"
"..."
msgstr ""
"tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.endswith('Baa', 'aa')\n"
"---\n"
"- true\n"
"..."

#: ../doc/1.10/reference/reference_lua/string.rst:231
msgid "Return the value of the input string, but without spaces on the left."
msgstr "Возврат значения введенной строки без пробелов слева."

#: ../doc/1.10/reference/reference_lua/string.rst:235
#: ../doc/1.10/reference/reference_lua/string.rst:258
#: ../doc/1.10/reference/reference_lua/string.rst:309
msgid "result after stripping spaces from input string"
msgstr "результат после удаления пробелов из введенной строки"

#: ../doc/1.10/reference/reference_lua/string.rst:240
msgid ""
"tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.lstrip(' ABC ')\n"
"---\n"
"- 'ABC '\n"
"..."
msgstr ""
"tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.lstrip(' ABC ')\n"
"---\n"
"- 'ABC '\n"
"..."

#: ../doc/1.10/reference/reference_lua/string.rst:254
msgid "Return the value of the input string, but without spaces on the right."
msgstr "Возврат значения введенной строки без пробелов справа."

#: ../doc/1.10/reference/reference_lua/string.rst:263
msgid ""
"tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.rstrip(' ABC ')\n"
"---\n"
"- ' ABC'\n"
"..."
msgstr ""
"tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.rstrip(' ABC ')\n"
"---\n"
"- ' ABC'\n"
"..."

#: ../doc/1.10/reference/reference_lua/string.rst:277
msgid ""
"Split ``input-string`` into one or more output strings in a table. The "
"places to split are the places where ``split-string`` occurs."
msgstr ""
"Разделение ``input-string`` на одну или более выводимых строк в таблице. "
"Места разделения указаны в ``split-string``."

#: ../doc/1.10/reference/reference_lua/string.rst:281
msgid "(string) the string to split"
msgstr "(строка) строка для разделения"

#: ../doc/1.10/reference/reference_lua/string.rst:282
msgid "(string) the string to find within ``input-string``. Default = space."
msgstr ""
"(строка) искомая строка в пределах ``input-string``. По умолчанию = "
"пробел."

#: ../doc/1.10/reference/reference_lua/string.rst:285
msgid "table of strings that were split from ``input-string``"
msgstr "таблица строк, которые были разделены из ``input-string``"

#: ../doc/1.10/reference/reference_lua/string.rst:290
msgid ""
"tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.split(\"A*BXX C\", \"XX\")\n"
"---\n"
"- - A*B\n"
"  - ' C'\n"
"..."
msgstr ""
"tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.split(\"A*BXX C\", \"XX\")\n"
"---\n"
"- - A*B\n"
"  - ' C'\n"
"..."

#: ../doc/1.10/reference/reference_lua/string.rst:305
msgid ""
"Return the value of the input string, but without spaces on the left or "
"the right."
msgstr "Возврат значения введенной строки без пробелов слева или справа."

#: ../doc/1.10/reference/reference_lua/string.rst:314
msgid ""
"tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.strip(' ABC ')\n"
"---\n"
"- ABC\n"
"..."
msgstr ""
"tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.strip(' ABC ')\n"
"---\n"
"- ABC\n"
"..."

#: ../doc/1.10/reference/reference_lua/table.rst:39
msgid "Module `table`"
msgstr "Модуль `table`"

#: ../doc/1.10/reference/reference_lua/table.rst:43
msgid ""
"The :code:`table` module has everything in the `standard Lua table "
"library <https://www.lua.org/pil/19.html>`_, and some Tarantool "
"extensions."
msgstr ""
"Модуль :code:`table` включает в себя всё из `стандартной библиотеки для "
"работы с таблицами в Lua <https://www.lua.org/pil/19.html>`_, а также "
"некоторые расширения специально для Tarantool'а."

#: ../doc/1.10/reference/reference_lua/table.rst:47
msgid ""
"You can see this by saying \"table\": you will see this list of "
"functions: ``clear`` (LuaJIT extension = erase all elements), `concat "
"<https://www.lua.org/manual/5.1/manual.html#pdf-table.concat>`_ "
"(concatenate), ``copy`` (make a copy of an array), ``deepcopy`` (see "
"description below), ``foreach``, ``foreach1``, `getn "
"<https://www.lua.org/pil/19.1.html>`_ (get the number of elements in an "
"array), `insert <https://www.lua.org/manual/5.1/manual.html#pdf-"
"table.insert>`_ (insert an element into an array), `maxn "
"<https://www.lua.org/manual/5.1/manual.html#pdf-table.maxn>`_ (get "
"largest index) `move <https://www.lua.org/manual/5.3/manual.html#pdf-"
"table.move>`_ (move elements between tables), ``new`` (LuaJIT extension ="
" return a new table with pre-allocated elements), `remove "
"<https://www.lua.org/manual/5.1/manual.html#pdf-table.remove>`_ (remove "
"an element from an array), `sort "
"<https://www.lua.org/manual/5.1/manual.html#pdf-table.sort>`_ (sort the "
"elements of an array)."
msgstr ""
"Чтобы убедиться в этом, выполните команду \"table\": вы увидите список "
"функций: ``clear`` (расширение LuaJIT = удаление всех элементов), `concat"
" <https://www.lua.org/manual/5.1/manual.html#pdf-table.concat>`_ "
"(конкатенация), ``copy`` (создание копии массива), ``deepcopy`` (см. "
"описание ниже), ``foreach``, ``foreach1``, `getn "
"<https://www.lua.org/pil/19.1.html>`_ (получение количества элементов в "
"массиве), `insert <https://www.lua.org/manual/5.1/manual.html#pdf-"
"table.insert>`_ (вставка элемента в массив), `maxn "
"<https://www.lua.org/manual/5.1/manual.html#pdf-table.maxn>`_ (получение "
"самого большого индекса) `move "
"<https://www.lua.org/manual/5.3/manual.html#pdf-table.move>`_ "
"(перемещение элементов между таблицами), ``new`` (расширение LuaJIT = "
"возврат новой таблицы с предварительно выделенными элементами), `remove "
"<https://www.lua.org/manual/5.1/manual.html#pdf-table.remove>`_ (удаление"
" элемента из массива), `sort <https://www.lua.org/manual/5.1/manual.html"
"#pdf-table.sort>`_ (сортировка элементов массива)."

#: ../doc/1.10/reference/reference_lua/table.rst:62
msgid ""
"In this section we only discuss the additional function that the "
"Tarantool developers have added: ``deepcopy``."
msgstr ""
"В данном разделе мы рассматриваем только дополнительную функцию, "
"добавленную разработчиками Tarantool'а: ``deepcopy``."

#: ../doc/1.10/reference/reference_lua/table.rst:69
msgid ""
"Return a \"deep\" copy of the table -- a copy which follows nested "
"structures to any depth and does not depend on pointers, it copies the "
"contents."
msgstr ""
"Возврат детальной копии таблицы -- копии, которая включает в себя "
"вложенные структуры любой глубины и не зависит от указателей, копируется "
"содержимое."

#: ../doc/1.10/reference/reference_lua/table.rst:73
msgid "(table) the table to copy"
msgstr "(таблица) таблица для копирования"

#: ../doc/1.10/reference/reference_lua/table.rst:75
msgid "the copy of the table"
msgstr "копия таблицы"

#: ../doc/1.10/reference/reference_lua/table.rst:80
msgid ""
"tarantool> input_table = {1,{'a','b'}}\n"
"---\n"
"...\n"
"\n"
"tarantool> output_table = table.deepcopy(input_table)\n"
"---\n"
"...\n"
"\n"
"tarantool> output_table\n"
"---\n"
"- - 1\n"
"  - - a\n"
"    - b\n"
"..."
msgstr ""
"tarantool> input_table = {1,{'a','b'}}\n"
"---\n"
"...\n"
"\n"
"tarantool> output_table = table.deepcopy(input_table)\n"
"---\n"
"...\n"
"\n"
"tarantool> output_table\n"
"---\n"
"- - 1\n"
"  - - a\n"
"    - b\n"
"..."

#: ../doc/1.10/reference/reference_lua/tap.rst:37
msgid "Module `tap`"
msgstr "Модуль `tap`"

#: ../doc/1.10/reference/reference_lua/tap.rst:43
msgid ""
"The ``tap`` module streamlines the testing of other modules. It allows "
"writing of tests in the `TAP protocol`_. The results from the tests can "
"be parsed by standard TAP-analyzers so they can be passed to utilities "
"such as `prove`_. Thus one can run tests and then use the results for "
"statistics, decision-making, and so on."
msgstr ""
"Модуль ``tap`` оптимизирует тестирование других модулей. Он позволяет "
"записывать тесты в TAP-протокол (`TAP protocol`_). Результаты тестов "
"могут подвергаться анализу стандартными TAP-анализаторами, поэтому их "
"можно передавать утилитам, например `prove`_. Таким образом, можно "
"выполнять тестирование, а затем использовать результаты для выведения "
"статистики, принятия решений и т.д."

#: ../doc/1.10/reference/reference_lua/tap.rst:53
msgid "Below is a list of all ``tap`` functions."
msgstr "Ниже приведен перечень всех функций модуля ``tap``."

#: ../doc/1.10/reference/reference_lua/tap.rst:63
msgid ":ref:`tap.test() <tap-test>`"
msgstr ":ref:`tap.test() <tap-test>`"

#: ../doc/1.10/reference/reference_lua/tap.rst:63
msgid "Initialize"
msgstr "Инициализация"

#: ../doc/1.10/reference/reference_lua/tap.rst:66
msgid ":ref:`taptest:test() <taptest-test>`"
msgstr ":ref:`taptest:test() <taptest-test>`"

#: ../doc/1.10/reference/reference_lua/tap.rst:66
msgid "Create a subtest and print the results"
msgstr "Создание подтеста и вывод результатов"

#: ../doc/1.10/reference/reference_lua/tap.rst:69
msgid ":ref:`taptest:plan() <taptest-plan>`"
msgstr ":ref:`taptest:plan() <taptest-plan>`"

#: ../doc/1.10/reference/reference_lua/tap.rst:69
msgid "Indicate how many tests to perform"
msgstr "Указание количества проводимых тестов"

#: ../doc/1.10/reference/reference_lua/tap.rst:72
msgid ":ref:`taptest:check() <taptest-check>`"
msgstr ":ref:`taptest:check() <taptest-check>`"

#: ../doc/1.10/reference/reference_lua/tap.rst:72
msgid "Check the number of tests performed"
msgstr "Проверка количества выполненных тестов"

#: ../doc/1.10/reference/reference_lua/tap.rst:75
msgid ":ref:`taptest:diag() <taptest-diag>`"
msgstr ":ref:`taptest:diag() <taptest-diag>`"

#: ../doc/1.10/reference/reference_lua/tap.rst:75
msgid "Display a diagnostic message"
msgstr "Отображение сообщения диагностики"

#: ../doc/1.10/reference/reference_lua/tap.rst:78
msgid ":ref:`taptest:ok() <taptest-ok>`"
msgstr ":ref:`taptest:ok() <taptest-ok>`"

#: ../doc/1.10/reference/reference_lua/tap.rst:78
#: ../doc/1.10/reference/reference_lua/tap.rst:81
#: ../doc/1.10/reference/reference_lua/tap.rst:84
msgid "Evaluate the condition and display the message"
msgstr "Оценка состояния и отображение сообщения"

#: ../doc/1.10/reference/reference_lua/tap.rst:81
msgid ":ref:`taptest:fail() <taptest-fail>`"
msgstr ":ref:`taptest:fail() <taptest-fail>`"

#: ../doc/1.10/reference/reference_lua/tap.rst:84
msgid ":ref:`taptest:skip() <taptest-skip>`"
msgstr ":ref:`taptest:skip() <taptest-skip>`"

#: ../doc/1.10/reference/reference_lua/tap.rst:87
msgid ":ref:`taptest:is() <taptest-is>`"
msgstr ":ref:`taptest:is() <taptest-is>`"

#: ../doc/1.10/reference/reference_lua/tap.rst:87
msgid "Check if the two arguments are equal"
msgstr "Проверка равенства двух аргументов"

#: ../doc/1.10/reference/reference_lua/tap.rst:90
msgid ":ref:`taptest:isnt() <taptest-isnt>`"
msgstr ":ref:`taptest:isnt() <taptest-isnt>`"

#: ../doc/1.10/reference/reference_lua/tap.rst:90
msgid "Check if the two arguments are different"
msgstr "Проверка отличий двух аргументов"

#: ../doc/1.10/reference/reference_lua/tap.rst:93
msgid ":ref:`taptest:is_deeply() <taptest-is_deeply>`"
msgstr ":ref:`taptest:is_deeply() <taptest-is_deeply>`"

#: ../doc/1.10/reference/reference_lua/tap.rst:93
msgid "Recursively check if the two arguments are equal"
msgstr "Рекурсивная проверка равенства двух аргументов"

#: ../doc/1.10/reference/reference_lua/tap.rst:96
msgid ":ref:`taptest:like() <taptest-like>`"
msgstr ":ref:`taptest:like() <taptest-like>`"

#: ../doc/1.10/reference/reference_lua/tap.rst:96
msgid "Check if the argument matches a pattern"
msgstr "Проверка соответствия аргумента шаблону"

#: ../doc/1.10/reference/reference_lua/tap.rst:99
msgid ":ref:`taptest:unlike() <taptest-unlike>`"
msgstr ":ref:`taptest:unlike() <taptest-unlike>`"

#: ../doc/1.10/reference/reference_lua/tap.rst:99
msgid "Check if the argument does not match a pattern"
msgstr "Проверка отличия аргумента от шаблона"

#: ../doc/1.10/reference/reference_lua/tap.rst:102
msgid ""
":ref:`taptest:isnil() <taptest-istype>` |br| :ref:`taptest:isstring() "
"<taptest-istype>` |br| :ref:`taptest:isnumber() <taptest-istype>` |br| "
":ref:`taptest:istable() <taptest-istype>` |br| :ref:`taptest:isboolean() "
"<taptest-istype>` |br| :ref:`taptest:isudata() <taptest-istype>` |br| "
":ref:`taptest:iscdata() <taptest-istype>`"
msgstr ""
":ref:`taptest:isnil() <taptest-istype>` |br| :ref:`taptest:isstring() "
"<taptest-istype>` |br| :ref:`taptest:isnumber() <taptest-istype>` |br| "
":ref:`taptest:istable() <taptest-istype>` |br| :ref:`taptest:isboolean() "
"<taptest-istype>` |br| :ref:`taptest:isudata() <taptest-istype>` |br| "
":ref:`taptest:iscdata() <taptest-istype>`"

#: ../doc/1.10/reference/reference_lua/tap.rst:108
msgid "Check if a value has a particular type"
msgstr "Проверка соответствия значения определенному типу"

#: ../doc/1.10/reference/reference_lua/tap.rst:124
msgid "Initialize."
msgstr "Инициализация."

#: ../doc/1.10/reference/reference_lua/tap.rst:126
msgid ""
"The result of ``tap.test`` is an object, which will be called taptest in "
"the rest of this discussion, which is necessary for ``taptest:plan()`` "
"and all the other methods."
msgstr ""
"Результатом ``tap.test`` является объект, который будет называться "
"taptest в ходе данного разбора, что необходимо для ``taptest:plan()`` и "
"всех остальных методов."

#: ../doc/1.10/reference/reference_lua/tap.rst:130
#: ../doc/1.10/reference/reference_lua/tap.rst:151
msgid "an arbitrary name to give for the test outputs."
msgstr "произвольное имя для результата теста."

#: ../doc/1.10/reference/reference_lua/tap.rst:131
#: ../doc/1.10/reference/reference_lua/tap.rst:153
msgid "taptest"
msgstr "taptest"

#: ../doc/1.10/reference/reference_lua/tap.rst:134
msgid ""
"tap = require('tap')\n"
"taptest = tap.test('test-name')"
msgstr ""
"tap = require('tap')\n"
"taptest = tap.test('test-name')"

#: ../doc/1.10/reference/reference_lua/tap.rst:145
msgid ""
"Create a subtest (if no ``func`` argument specified), or (if all "
"arguments are specified) create a subtest, run the test function and "
"print the result."
msgstr ""
"Создание подтеста (если не указан аргумент ``func``) или (если указаны "
"все аргументы) создание подтеста, выполнение тестовой функции и вывод "
"результата."

#: ../doc/1.10/reference/reference_lua/tap.rst:149
msgid "See the :ref:`example <tap-example>`."
msgstr "См. :ref:`пример <tap-example>`."

#: ../doc/1.10/reference/reference_lua/tap.rst:152
msgid "the test logic to run."
msgstr "выполняемая тестовая логика."

#: ../doc/1.10/reference/reference_lua/tap.rst:154
msgid "userdata or string"
msgstr "userdata или строка"

#: ../doc/1.10/reference/reference_lua/tap.rst:160
msgid "Indicate how many tests will be performed."
msgstr "Указание количества проводимых тестов."

#: ../doc/1.10/reference/reference_lua/tap.rst:169
msgid "Checks the number of tests performed."
msgstr "Проверка количества выполненных тестов."

#: ../doc/1.10/reference/reference_lua/tap.rst:171
msgid ""
"The result will be a display saying ``# bad plan: ...`` if the number of "
"completed tests is not equal to the number of tests specified by "
"``taptest:plan(...)``. (This is a purely Tarantool feature: \"bad plan\" "
"messages are out of the TAP13 standard.)"
msgstr ""
"Выведенный результат будет включать в себя сообщение: ``# bad plan: "
"...``, если количество выполненных тестов не равно количеству тестов, "
"указанному в ``taptest:plan(...)``. (Это собственная функция Tarantool'а:"
" сообщения типа \"bad plan\" не входят в стандарт TAP13.)"

#: ../doc/1.10/reference/reference_lua/tap.rst:176
msgid ""
"This check should only be done after all planned tests are complete, so "
"ordinarily ``taptest:check()`` will only appear at the end of a script. "
"However, as a Tarantool extension, ``taptest:check()`` may appear at the "
"end of any subtest. Therefore there are three ways to cause the check:"
msgstr ""
"Такую проверку следует проводить только по завершении всех "
"запланированных тестов, поэтому как правило, ``taptest:check()`` появится"
" лишь в конце скрипта. Тем не менее, в качестве расширения Tarantool'а, "
"``taptest:check()`` может появиться в начале любого подтеста. Таким "
"образом, проверка появится в трех случаях:"

#: ../doc/1.10/reference/reference_lua/tap.rst:181
msgid "by calling ``taptest:check()`` at the end of a script,"
msgstr "при вызове ``taptest:check()`` в конце скрипта,"

#: ../doc/1.10/reference/reference_lua/tap.rst:182
msgid "by calling a function which ends with a call to ``taptest:check()``,"
msgstr "при вызове функции, которая заканчивается вызовом ``taptest:check()``,"

#: ../doc/1.10/reference/reference_lua/tap.rst:183
msgid ""
"or by calling taptest:test('...', subtest-function-name) where subtest-"
"function-name does not need to end with ``taptest:check()`` because it "
"can be called after the subtest is complete."
msgstr ""
"или при вызове taptest:test('...', имя-функции-подтеста), где функция "
"подтеста не обязана заканчиваться на ``taptest:check()``, поскольку ее "
"можно вызвать по окончании подтеста."

#: ../doc/1.10/reference/reference_lua/tap.rst:194
msgid "Display a diagnostic message."
msgstr "Отображение сообщения диагностики."

#: ../doc/1.10/reference/reference_lua/tap.rst:196
msgid "the message to be displayed."
msgstr "отображаемое сообщение."

#: ../doc/1.10/reference/reference_lua/tap.rst:203
msgid ""
"This is a basic function which is used by other functions. Depending on "
"the value of ``condition``, print 'ok' or 'not ok' along with debugging "
"information. Displays the message."
msgstr ""
"Это базовая функция, которая используется другими функциями. В "
"зависимости от условия ``condition``, выводится 'ok' или 'not ok' вместе "
"с отладочной информацией. Отображается сообщение."

#: ../doc/1.10/reference/reference_lua/tap.rst:207
msgid "an expression which is true or false"
msgstr "выражение, которое либо true (правда), либо false (ложь)"

#: ../doc/1.10/reference/reference_lua/tap.rst:208
#: ../doc/1.10/reference/reference_lua/tap.rst:242
#: ../doc/1.10/reference/reference_lua/tap.rst:255
#: ../doc/1.10/reference/reference_lua/tap.rst:278
#: ../doc/1.10/reference/reference_lua/tap.rst:290
#: ../doc/1.10/reference/reference_lua/tap.rst:307
#: ../doc/1.10/reference/reference_lua/tap.rst:322
#: ../doc/1.10/reference/reference_lua/tap.rst:336
#: ../doc/1.10/reference/reference_lua/tap.rst:355
msgid "name of the test"
msgstr "имя теста"

#: ../doc/1.10/reference/reference_lua/tap.rst:215
msgid ""
"tarantool> taptest:ok(true, 'x')\n"
"ok - x\n"
"---\n"
"- true\n"
"...\n"
"tarantool> tap = require('tap')\n"
"---\n"
"...\n"
"tarantool> taptest = tap.test('test-name')\n"
"TAP version 13\n"
"---\n"
"...\n"
"tarantool> taptest:ok(1 + 1 == 2, 'X')\n"
"ok - X\n"
"---\n"
"- true\n"
"..."
msgstr ""
"tarantool> taptest:ok(true, 'x')\n"
"ok - x\n"
"---\n"
"- true\n"
"...\n"
"tarantool> tap = require('tap')\n"
"---\n"
"...\n"
"tarantool> taptest = tap.test('test-name')\n"
"TAP version 13\n"
"---\n"
"...\n"
"tarantool> taptest:ok(1 + 1 == 2, 'X')\n"
"ok - X\n"
"---\n"
"- true\n"
"..."

#: ../doc/1.10/reference/reference_lua/tap.rst:239
msgid ""
"``taptest:fail('x')`` is equivalent to ``taptest:ok(false, 'x')``. "
"Displays the message."
msgstr ""
"``taptest:fail('x')`` -- аналог ``taptest:ok(false, 'x')``. Отображается "
"сообщение."

#: ../doc/1.10/reference/reference_lua/tap.rst:251
msgid ""
"``taptest:skip('x')`` is equivalent to ``taptest:ok(true, 'x' .. '# "
"skip')``. Displays the message."
msgstr ""
"``taptest:skip('x')`` -- аналог ``taptest:ok(true, 'x' .. '# skip')``. "
"Отображается сообщение."

#: ../doc/1.10/reference/reference_lua/tap.rst:261
msgid ""
"tarantool> taptest:skip('message')\n"
"ok - message # skip\n"
"---\n"
"- true\n"
"..."
msgstr ""
"tarantool> taptest:skip('message')\n"
"ok - message # skip\n"
"---\n"
"- true\n"
"..."

#: ../doc/1.10/reference/reference_lua/tap.rst:273
msgid ""
"Check whether the first argument equals the second argument. Displays "
"extensive message if the result is false."
msgstr ""
"Проверка равенства первого аргумента второму аргументу. Отображается "
"подробное сообщение, если результатом будет false (ложь)."

#: ../doc/1.10/reference/reference_lua/tap.rst:276
#: ../doc/1.10/reference/reference_lua/tap.rst:288
#: ../doc/1.10/reference/reference_lua/tap.rst:305
#: ../doc/1.10/reference/reference_lua/tap.rst:320
#: ../doc/1.10/reference/reference_lua/tap.rst:334
msgid "actual result"
msgstr "фактический результат"

#: ../doc/1.10/reference/reference_lua/tap.rst:277
#: ../doc/1.10/reference/reference_lua/tap.rst:289
#: ../doc/1.10/reference/reference_lua/tap.rst:306
msgid "expected result"
msgstr "ожидаемый результат"

#: ../doc/1.10/reference/reference_lua/tap.rst:286
msgid "This is the negation of :ref:`taptest:is() <taptest-is>`."
msgstr "Отрицание :ref:`taptest:is() <taptest-is>`."

#: ../doc/1.10/reference/reference_lua/tap.rst:299
msgid ""
"Recursive version of ``taptest:is(...)``, which can be be used to compare"
" tables as well as scalar values."
msgstr ""
"Рекурсивная версия ``taptest:is(...)``, которую можно использовать для "
"сопоставления таблиц, а также скалярных значений."

#: ../doc/1.10/reference/reference_lua/tap.rst:313
msgid ""
"Verify a string against a `pattern <http://lua-"
"users.org/wiki/PatternsTutorial>`_. Ok if match is found."
msgstr ""
"Проверка совпадения строки с `шаблоном <http://lua-"
"users.org/wiki/PatternsTutorial>`_. Ok, если найдено совпадение."

#: ../doc/1.10/reference/reference_lua/tap.rst:321
#: ../doc/1.10/reference/reference_lua/tap.rst:335
msgid "pattern"
msgstr "шаблон"

#: ../doc/1.10/reference/reference_lua/tap.rst:324
msgid "test:like(tarantool.version, '^[1-9]', \"version\")"
msgstr "test:like(tarantool.version, '^[1-9]', \"version\")"

#: ../doc/1.10/reference/reference_lua/tap.rst:332
msgid "This is the negation of :ref:`taptest:like() <taptest-like>`."
msgstr "Отрицание :ref:`taptest:like() <taptest-like>`."

#: ../doc/1.10/reference/reference_lua/tap.rst:351
msgid ""
"Test whether a value has a particular type. Displays a long message if "
"the value is not of the specified type."
msgstr ""
"Проверка соответствия значения определенному типу. Отображается длинное "
"сообщение, если значение не принадлежит указанному типу."

#: ../doc/1.10/reference/reference_lua/tap.rst:369
msgid ""
"To run this example: put the script in a file named ./tap.lua, then make "
"tap.lua executable by saying ``chmod a+x ./tap.lua``, then execute using "
"Tarantool as a script processor by saying ./tap.lua."
msgstr ""
"Для выполнения данного примера поместите скрипт в файл под названием "
"./tap.lua, затем сделайте tap.lua выполняемым файлом с помощью команды "
"``chmod a+x ./tap.lua``, а затем выполните его, используя Tarantool в "
"качестве обработчика скриптов после выполнения команды ./tap.lua."

#: ../doc/1.10/reference/reference_lua/tap.rst:373
msgid ""
"#!/usr/bin/tarantool\n"
"local tap = require('tap')\n"
"test = tap.test(\"my test name\")\n"
"test:plan(2)\n"
"test:ok(2 * 2 == 4, \"2 * 2 is 4\")\n"
"test:test(\"some subtests for test2\", function(test)\n"
"    test:plan(2)\n"
"    test:is(2 + 2, 4, \"2 + 2 is 4\")\n"
"    test:isnt(2 + 3, 4, \"2 + 3 is not 4\")\n"
"end)\n"
"test:check()"
msgstr ""
"#!/usr/bin/tarantool\n"
"local tap = require('tap')\n"
"test = tap.test(\"my test name\")\n"
"test:plan(2)\n"
"test:ok(2 * 2 == 4, \"2 * 2 is 4\")\n"
"test:test(\"some subtests for test2\", function(test)\n"
"    test:plan(2)\n"
"    test:is(2 + 2, 4, \"2 + 2 is 4\")\n"
"    test:isnt(2 + 3, 4, \"2 + 3 is not 4\")\n"
"end)\n"
"test:check()"

#: ../doc/1.10/reference/reference_lua/tap.rst:387
msgid "The output from the above script will look approximately like this:"
msgstr "Результатом вышеприведенного скрипта будет примерно следующее:"

#: ../doc/1.10/reference/reference_lua/tap.rst:389
msgid ""
"TAP version 13\n"
"1..2\n"
"ok - 2 * 2 is 4\n"
"    # Some subtests for test2\n"
"    1..2\n"
"    ok - 2 + 2 is 4,\n"
"    ok - 2 + 3 is not 4\n"
"    # Some subtests for test2: end\n"
"ok - some subtests for test2"
msgstr ""
"TAP version 13\n"
"1..2\n"
"ok - 2 * 2 is 4\n"
"    # Some subtests for test2\n"
"    1..2\n"
"    ok - 2 + 2 is 4,\n"
"    ok - 2 + 3 is not 4\n"
"    # Some subtests for test2: end\n"
"ok - some subtests for test2"

#: ../doc/1.10/reference/reference_lua/tarantool.rst:39
msgid "Module `tarantool`"
msgstr "Модуль `tarantool`"

#: ../doc/1.10/reference/reference_lua/tarantool.rst:43
msgid ""
"By saying ``require('tarantool')``, one can answer some questions about "
"how the tarantool server was built, such as \"what flags were used\", or "
"\"what was the version of the compiler\"."
msgstr ""
"Выполнив команду ``require('tarantool')``, можно получить ответы на "
"вопросы о том, как был собран Tarantool-сервер, например, какие флаги "
"были использованы, или какая версия компилятора использовалась."

#: ../doc/1.10/reference/reference_lua/tarantool.rst:49
msgid ""
"Additionally one can see the uptime and the server version and the "
"process id. Those information items can also be accessed with "
":ref:`box.info() <box_introspection-box_info>` but use of the tarantool "
"module is recommended."
msgstr ""
"Кроме того, можно проверить время работы и версию сервера, а также "
"идентификатор процесса. Эту информацию также можно получить с помощью "
":ref:`box.info() <box_introspection-box_info>`, но рекомендуется "
"использовать модуль tarantool."

#: ../doc/1.10/reference/reference_lua/tarantool.rst:56
msgid ""
"tarantool> tarantool = require('tarantool')\n"
"---\n"
"...\n"
"tarantool> tarantool\n"
"---\n"
"- build:\n"
"    target: Linux-x86_64-RelWithDebInfo\n"
"    options: cmake . -DCMAKE_INSTALL_PREFIX=/usr -DENABLE_BACKTRACE=ON\n"
"    mod_format: so\n"
"    flags: ' -fno-common -fno-omit-frame-pointer -fno-stack-protector "
"-fexceptions\n"
"      -funwind-tables -fopenmp -msse2 -std=c11 -Wall -Wextra -Wno-sign-"
"compare -Wno-strict-aliasing\n"
"      -fno-gnu89-inline'\n"
"    compiler: /usr/bin/x86_64-linux-gnu-gcc /usr/bin/x86_64-linux-gnu-g++"
"\n"
"  uptime: 'function: 0x408668e0'\n"
"  version: 1.7.0-66-g9093daa\n"
"  pid: 'function: 0x40866900'\n"
"...\n"
"tarantool> tarantool.pid()\n"
"---\n"
"- 30155\n"
"...\n"
"tarantool> tarantool.uptime()\n"
"---\n"
"- 108.64641499519\n"
"..."
msgstr ""
"tarantool> tarantool = require('tarantool')\n"
"---\n"
"...\n"
"tarantool> tarantool\n"
"---\n"
"- build:\n"
"    target: Linux-x86_64-RelWithDebInfo\n"
"    options: cmake . -DCMAKE_INSTALL_PREFIX=/usr -DENABLE_BACKTRACE=ON\n"
"    mod_format: so\n"
"    flags: ' -fno-common -fno-omit-frame-pointer -fno-stack-protector "
"-fexceptions\n"
"      -funwind-tables -fopenmp -msse2 -std=c11 -Wall -Wextra -Wno-sign-"
"compare -Wno-strict-aliasing\n"
"      -fno-gnu89-inline'\n"
"    compiler: /usr/bin/x86_64-linux-gnu-gcc /usr/bin/x86_64-linux-gnu-g++"
"\n"
"  uptime: 'function: 0x408668e0'\n"
"  version: 1.7.0-66-g9093daa\n"
"  pid: 'function: 0x40866900'\n"
"...\n"
"tarantool> tarantool.pid()\n"
"---\n"
"- 30155\n"
"...\n"
"tarantool> tarantool.uptime()\n"
"---\n"
"- 108.64641499519\n"
"..."

#: ../doc/1.10/reference/reference_lua/uri.rst:37
msgid "Module `uri`"
msgstr "Модуль `uri`"

#: ../doc/1.10/reference/reference_lua/uri.rst:43
msgid ""
"A \"URI\" is a \"Uniform Resource Identifier\". The `IETF standard "
"<https://www.ietf.org/rfc/rfc2396.txt>`_ says a URI string looks like "
"this:"
msgstr ""
"URI -- это Унифицированный идентификатор ресурса (Uniform Resource "
"Identifier). Согласно `стандарту IETF "
"<https://www.ietf.org/rfc/rfc2396.txt>`_, URI-строка выглядит следующим "
"образом:"

#: ../doc/1.10/reference/reference_lua/uri.rst:47
msgid "[scheme:]scheme-specific-part[#fragment]"
msgstr "[схема:]специальная-часть-схемы[#фрагмент]"

#: ../doc/1.10/reference/reference_lua/uri.rst:51
msgid "A common type, a hierarchical URI, looks like this:"
msgstr "Общий тип, иерархический URI, выглядит так:"

#: ../doc/1.10/reference/reference_lua/uri.rst:53
msgid "[scheme:][//authority][path][?query][#fragment]"
msgstr "[схема:][//адрес][путь][?запрос][#фрагмент]"

#: ../doc/1.10/reference/reference_lua/uri.rst:57
msgid ""
"For example the string ``'https://tarantool.org/x.html#y'`` has three "
"components:"
msgstr ""
"Например, строка ``'https://tarantool.org/x.html#y'`` содержит три "
"компонента:"

#: ../doc/1.10/reference/reference_lua/uri.rst:60
msgid "``https`` is the scheme,"
msgstr "``https`` -- схема,"

#: ../doc/1.10/reference/reference_lua/uri.rst:61
msgid "``tarantool.org/x.html`` is the path,"
msgstr "``tarantool.org/x.html`` -- путь,"

#: ../doc/1.10/reference/reference_lua/uri.rst:62
msgid "``y`` is the fragment."
msgstr "``y`` -- фрагмент."

#: ../doc/1.10/reference/reference_lua/uri.rst:64
msgid ""
"Tarantool's URI module provides routines which convert URI strings into "
"their components, or turn components into URI strings."
msgstr ""
"Модуль Tarantool'а URI включает в себя процедуры для разложения URI-строк"
" на компоненты или объединения компонентов в URI-строку."

#: ../doc/1.10/reference/reference_lua/uri.rst:71
msgid "Below is a list of all ``uri`` functions."
msgstr "Ниже приведен перечень всех функций модуля ``uri``."

#: ../doc/1.10/reference/reference_lua/uri.rst:81
msgid ":ref:`uri.parse() <uri-parse>`"
msgstr ":ref:`uri.parse() <uri-parse>`"

#: ../doc/1.10/reference/reference_lua/uri.rst:81
msgid "Get a table of URI components"
msgstr "Получение таблицы URI-компонентов"

#: ../doc/1.10/reference/reference_lua/uri.rst:84
msgid ":ref:`uri.format() <uri-format>`"
msgstr ":ref:`uri.format() <uri-format>`"

#: ../doc/1.10/reference/reference_lua/uri.rst:84
msgid "Construct a URI from components"
msgstr "Создание URI из компонентов"

#: ../doc/1.10/reference/reference_lua/uri.rst:94
msgid "a Uniform Resource Identifier"
msgstr "Унифицированный идентификатор ресурса"

#: ../doc/1.10/reference/reference_lua/uri.rst:95
msgid ""
"URI-components-table. Possible components are fragment, host, login, "
"password, path, query, scheme, service."
msgstr ""
"таблица с компонентами URI. Доступные компоненты: fragment (фрагмент), "
"host (хост), login (имя для входа), password (пароль), path (путь), query"
" (запрос), scheme (схема), service (сервис)."

#: ../doc/1.10/reference/reference_lua/uri.rst:97
msgid "Table"
msgstr "Таблица"

#: ../doc/1.10/reference/reference_lua/uri.rst:101
msgid ""
"tarantool> uri = require('uri')\n"
"---\n"
"...\n"
"\n"
"tarantool> uri.parse('http://x.html#y')\n"
"---\n"
"- host: x.html\n"
"  scheme: http\n"
"  fragment: y\n"
"..."
msgstr ""
"tarantool> uri = require('uri')\n"
"---\n"
"...\n"
"\n"
"tarantool> uri.parse('http://x.html#y')\n"
"---\n"
"- host: x.html\n"
"  scheme: http\n"
"  fragment: y\n"
"..."

#: ../doc/1.10/reference/reference_lua/uri.rst:118
msgid "a series of name:value pairs, one for each component"
msgstr "ряд пар ключ-значение, одна для каждого компонента"

#: ../doc/1.10/reference/reference_lua/uri.rst:120
msgid ""
"boolean. If this is supplied and is ``true``, then the password component"
" is rendered in clear text, otherwise it is omitted."
msgstr ""
"логическое значение. Если указать значение ``true``, то компонент пароля "
"отображается открытым текстом, в остальных случаях не отображается."

#: ../doc/1.10/reference/reference_lua/uri.rst:123
msgid "URI-string. Thus uri.format() is the reverse of uri.parse()."
msgstr ""
"URI-строка. Таким образом, uri.format() -- это операция, обратная "
"uri.parse()."

#: ../doc/1.10/reference/reference_lua/uri.rst:128
msgid ""
"tarantool> uri.format({host = 'x.html', scheme = 'http', fragment = 'y'})"
"\n"
"---\n"
"- http://x.html#y\n"
"..."
msgstr ""
"tarantool> uri.format({host = 'x.html', scheme = 'http', fragment = 'y'})"
"\n"
"---\n"
"- http://x.html#y\n"
"..."

#: ../doc/1.10/reference/reference_lua/utf8.rst:39
msgid "Module `utf8`"
msgstr "Модуль `utf8`"

#: ../doc/1.10/reference/reference_lua/utf8.rst:45
msgid ""
"``utf8`` is Tarantool's module for handling UTF-8 strings. It includes "
"some functions which are compatible with ones in `Lua 5.3 "
"<https://www.lua.org/manual/5.3/manual.html#6.5>`_ but Tarantool has much"
" more. For example, because internally Tarantool contains a complete copy"
" of the \"International Components For Unicode\" library, there are "
"comparison functions which understand the default ordering for Cyrillic "
"(Capital Letter Zhe Ж = Small Letter Zhe ж) and Japanese (Hiragana A = "
"Katakana A)."
msgstr ""
"``utf8`` -- это модуль Tarantool'а для обработки строк в формате UTF-8. "
"Он содержит некоторые функции, которые совместимы с функциями `Lua 5.3 "
"<https://www.lua.org/manual/5.3/manual.html#6.5>`_, но возможности "
"Tarantool'а намного больше. Например, поскольку Tarantool включает в себя"
" полную копию библиотеки Международных компонентов для Юникода "
"(\"International Components For Unicode\"), доступны также функции "
"сравнения, которые понимают упорядочение символов в кириллице (заглавная "
"буква  Ж = строчная буква ж) и японском языке (A в хирагане = A в "
"катакане)."

#: ../doc/1.10/reference/reference_lua/utf8.rst:55
msgid "The module is fully built-in so ``require('utf8')`` is not necessary."
msgstr ""
"Модуль является встроенным, поэтому нет необходимости выполнять команду "
"``require('utf8')``."

#: ../doc/1.10/reference/reference_lua/utf8.rst:65
msgid ":ref:`casecmp <utf8-casecmp>` and |br| :ref:`cmp <utf8-cmp>`"
msgstr ":ref:`casecmp <utf8-casecmp>` and |br| :ref:`cmp <utf8-cmp>`"

#: ../doc/1.10/reference/reference_lua/utf8.rst:65
msgid "Comparisons"
msgstr "Сравнения"

#: ../doc/1.10/reference/reference_lua/utf8.rst:68
msgid ":ref:`lower <utf8-islower>` and |br| :ref:`upper <utf8-isupper>`"
msgstr ":ref:`lower <utf8-islower>` and |br| :ref:`upper <utf8-isupper>`"

#: ../doc/1.10/reference/reference_lua/utf8.rst:68
msgid "Case conversions"
msgstr "Замена регистра"

#: ../doc/1.10/reference/reference_lua/utf8.rst:71
msgid ""
":ref:`isalpha <utf8-isalpha>`, |br| :ref:`isdigit <utf8-isdigit>`, |br| "
":ref:`islower <utf8-islower>` and |br| :ref:`isupper <utf8-isupper>`"
msgstr ""
":ref:`isalpha <utf8-isalpha>`, |br| :ref:`isdigit <utf8-isdigit>`, |br| "
":ref:`islower <utf8-islower>` and |br| :ref:`isupper <utf8-isupper>`"

#: ../doc/1.10/reference/reference_lua/utf8.rst:71
msgid "Determine character types"
msgstr "Определение типа символа"

#: ../doc/1.10/reference/reference_lua/utf8.rst:76
msgid ":ref:`sub <utf8-sub>`"
msgstr ":ref:`sub <utf8-sub>`"

#: ../doc/1.10/reference/reference_lua/utf8.rst:76
msgid "Substrings"
msgstr "Подстроки"

#: ../doc/1.10/reference/reference_lua/utf8.rst:78
msgid ":ref:`length <utf8-length>`"
msgstr ":ref:`length <utf8-length>`"

#: ../doc/1.10/reference/reference_lua/utf8.rst:78
msgid "Length in characters"
msgstr "Длина в символах"

#: ../doc/1.10/reference/reference_lua/utf8.rst:80
msgid ":ref:`next <utf8-next>`"
msgstr ":ref:`next <utf8-next>`"

#: ../doc/1.10/reference/reference_lua/utf8.rst:80
msgid "Character-at-a-time iterations"
msgstr "Посимвольная итерация"

#: ../doc/1.10/reference/reference_lua/utf8.rst:89
#: ../doc/1.10/reference/reference_lua/utf8.rst:150
#: ../doc/1.10/reference/reference_lua/utf8.rst:271
#: ../doc/1.10/reference/reference_lua/utf8.rst:308
#: ../doc/1.10/reference/reference_lua/utf8.rst:325
#: ../doc/1.10/reference/reference_lua/utf8.rst:384
msgid "a string encoded with UTF-8"
msgstr "строка в формате UTF-8"

#: ../doc/1.10/reference/reference_lua/utf8.rst:90
#: ../doc/1.10/reference/reference_lua/utf8.rst:151
msgid "-1 meaning \"less\", 0 meaning \"equal\", +1 meaning \"greater\""
msgstr "-1 означает \"меньше\", 0 означает \"равно\", +1 означает \"больше\""

#: ../doc/1.10/reference/reference_lua/utf8.rst:93
msgid ""
"Compare two strings with the Default Unicode Collation Element Table "
"(DUCET) for the `Unicode Collation Algorithm "
"<http://www.unicode.org/Public/UCA/10.0.0/allkeys.txt>`_. Thus 'å' is "
"less than 'B', even though the code-point value of å (229) is greater "
"than the code-point value of B (66), because the algorithm depends on the"
" values in the Collation Element Table, not the code-point values."
msgstr ""
"Сравнение двух строк с Таблицей сортировки символов Юникода по умолчанию "
"(DUCET) для `Алгоритма сортировки по Юникоду (Unicode Collation "
"Algorithm) <http://www.unicode.org/Public/UCA/10.0.0/allkeys.txt>`_. В "
"результате 'å' меньше, чем 'B', хотя значение кодовой точки å (229) "
"больше значения кодовой точки B (66), поскольку алгоритм основывается на "
"значениях Таблица сортировки символов, а не на значениях кодовых точек."

#: ../doc/1.10/reference/reference_lua/utf8.rst:100
msgid ""
"The comparison is done with primary weights. Therefore the elements which"
" affect secondary or later weights (such as \"case\" in Latin or Cyrillic"
" alphabets, or \"kana differentiation\" in Japanese) are ignored. If "
"asked \"is this like a Microsoft case-insensitive accent-insensitive "
"collation\" we tend to answer \"yes\", though the Unicode Collation "
"Algorithm is far more sophisticated than those terms imply."
msgstr ""
"Сравнение осуществляется на основании основного веса. Таким образом, не "
"учитываются элементы, которые влияют на вторичный или последующий вес "
"(такие как \"регистр\" в латинице или кириллице, или \"отличия каны\" в "
"японском языке). Если спросить: \"Это похоже на сортировку без учета "
"регистра и ударения от компании Майкрософт?\" - ответом будет: \"Скорее "
"да\", хотя Алгоритм сортировки по Юникоду гораздо сложнее, чем это "
"описание."

#: ../doc/1.10/reference/reference_lua/utf8.rst:110
msgid ""
"tarantool> utf8.casecmp('é','e'),utf8.casecmp('E','e')\n"
"---\n"
"- 0\n"
"- 0\n"
"..."
msgstr ""
"tarantool> utf8.casecmp('é','e'),utf8.casecmp('E','e')\n"
"---\n"
"- 0\n"
"- 0\n"
"..."

#: ../doc/1.10/reference/reference_lua/utf8.rst:122
msgid "a Unicode code point value, repeatable"
msgstr "значение кодовой точки в Юникоде, повторяется"

#: ../doc/1.10/reference/reference_lua/utf8.rst:123
msgid "a UTF-8 string"
msgstr "строка в UTF-8"

#: ../doc/1.10/reference/reference_lua/utf8.rst:126
msgid ""
"The code-point number is the value that corresponds to a character in the"
" `Unicode Character Database "
"<http://www.unicode.org/Public/5.2.0/ucd/UnicodeData.txt>`_ This is not "
"the same as the byte values of the encoded character, because the UTF-8 "
"encoding scheme is more complex than a simple copy of the code-point "
"number."
msgstr ""
"Число кодовой точки -- это значение, которое соответствует символу в "
"`Базе данных символов Юникода "
"<http://www.unicode.org/Public/5.2.0/ucd/UnicodeData.txt>`_ This is not "
"the same as the byte values of the encoded character, because the UTF-8 "
"encoding scheme is more complex than a simple copy of the code-point "
"number."

#: ../doc/1.10/reference/reference_lua/utf8.rst:133
msgid ""
"Another way to construct a string with Unicode characters is with the "
"\\\\u{hex-digits} escape mechanism, for example '\\\\u{41}\\\\u{42}' and "
"``utf8.char(65,66)`` both produce the string 'AB'."
msgstr ""
"Другой способ создать строку с символами Юникода -- с помощью механизма "
"экранирования символов \\\\u{шестнадцатеричные-числа}, например, в "
"результате и '\\\\u{41}\\\\u{42}', и ``utf8.char(65,66)`` получим строку "
"'AB'."

#: ../doc/1.10/reference/reference_lua/utf8.rst:139
msgid ""
"tarantool> utf8.char(229)\n"
"---\n"
"- å\n"
"..."
msgstr ""
"tarantool> utf8.char(229)\n"
"---\n"
"- å\n"
"..."

#: ../doc/1.10/reference/reference_lua/utf8.rst:154
msgid ""
"Compare two strings with the Default Unicode Collation Element Table "
"(DUCET) for the `Unicode Collation Algorithm "
"<http://www.unicode.org/Public/UCA/10.0.0/allkeys.txt>`_. Thus 'å' is "
"less than 'B', even though the code-point value of å (229) is greater "
"than the code-point value of B (66), because the algorithm depends on the"
" values in the Collation Element Table, not the code values."
msgstr ""
"Сравнение двух строк с Таблицей сортировки символов Юникода по умолчанию "
"(DUCET) для `Алгоритма сортировки по Юникоду (Unicode Collation "
"Algorithm) <http://www.unicode.org/Public/UCA/10.0.0/allkeys.txt>`_. В "
"результате 'å' меньше, чем 'B', хотя значение кодовой точки å (229) "
"больше значения кодовой точки B (66), поскольку алгоритм основывается на "
"значениях Таблица сортировки символов, а не на значениях кода."

#: ../doc/1.10/reference/reference_lua/utf8.rst:161
msgid ""
"The comparison is done with at least three weights. Therefore the "
"elements which affect secondary or later weights (such as \"case\" in "
"Latin or Cyrillic alphabets, or \"kana differentiation\" in Japanese) are"
" not ignored. and upper case comes after lower case."
msgstr ""
"Сравнение осуществляется на основании не менее трех значений веса. Таким "
"образом, не учитываются элементы, которые влияют на вторичный или "
"последующий вес (такие как \"регистр\" в латинице или кириллице, или "
"\"отличия каны\" в японском языке), а верхний регистр следует за нижним."

#: ../doc/1.10/reference/reference_lua/utf8.rst:168
msgid ""
"tarantool> utf8.cmp('é','e'),utf8.cmp('E','e')\n"
"---\n"
"- 1\n"
"- 1\n"
"..."
msgstr ""
"tarantool> utf8.cmp('é','e'),utf8.cmp('E','e')\n"
"---\n"
"- 1\n"
"- 1\n"
"..."

#: ../doc/1.10/reference/reference_lua/utf8.rst:180
#: ../doc/1.10/reference/reference_lua/utf8.rst:205
#: ../doc/1.10/reference/reference_lua/utf8.rst:227
#: ../doc/1.10/reference/reference_lua/utf8.rst:249
msgid ""
"a single UTF8 character, expressed as a one-byte string or a code point "
"value"
msgstr ""
"отдельный символ UTF8, выраженный в виде однобайтной строки или значения "
"кодовой точки"

#: ../doc/1.10/reference/reference_lua/utf8.rst:185
msgid ""
"Return true if the input character is an \"alphabetic-like\" character, "
"otherwise return false. Generally speaking a character will be considered"
" alphabetic-like provided it is typically used within a word, as opposed "
"to a digit or punctuation. It does not have to be a character in an "
"alphabet."
msgstr ""
"Возврат true (правда), если введенный символ является буквенным, в "
"остальных случаях -- false (ложь). В целом, символ считается буквенным, "
"если он используется в рамках слова, а не как число или знак пунктуации. "
"Такой символ необязательно должен быть буквой алфавита."

#: ../doc/1.10/reference/reference_lua/utf8.rst:192
msgid ""
"tarantool> utf8.isalpha('Ж'),utf8.isalpha('å'),utf8.isalpha('9')\n"
"---\n"
"- true\n"
"- true\n"
"- false\n"
"..."
msgstr ""
"tarantool> utf8.isalpha('Ж'),utf8.isalpha('å'),utf8.isalpha('9')\n"
"---\n"
"- true\n"
"- true\n"
"- false\n"
"..."

#: ../doc/1.10/reference/reference_lua/utf8.rst:210
msgid "Return true if the input character is a digit, otherwise return false."
msgstr ""
"Возврат true (правда), если введенный символ является цифрой, в остальных"
" случаях -- false (ложь)."

#: ../doc/1.10/reference/reference_lua/utf8.rst:214
msgid ""
"tarantool> utf8.isdigit('Ж'),utf8.isdigit('å'),utf8.isdigit('9')\n"
"---\n"
"- false\n"
"- false\n"
"- true\n"
"..."
msgstr ""
"tarantool> utf8.isdigit('Ж'),utf8.isdigit('å'),utf8.isdigit('9')\n"
"---\n"
"- false\n"
"- false\n"
"- true\n"
"..."

#: ../doc/1.10/reference/reference_lua/utf8.rst:232
msgid "Return true if the input character is lower case, otherwise return false."
msgstr ""
"Возврат true (правда), если введенный символ относится к нижнему "
"регистру, в остальных случаях -- false (ложь)."

#: ../doc/1.10/reference/reference_lua/utf8.rst:236
msgid ""
"tarantool> utf8.islower('Ж'),utf8.islower('å'),utf8.islower('9')\n"
"---\n"
"- false\n"
"- true\n"
"- false\n"
"..."
msgstr ""
"tarantool> utf8.islower('Ж'),utf8.islower('å'),utf8.islower('9')\n"
"---\n"
"- false\n"
"- true\n"
"- false\n"
"..."

#: ../doc/1.10/reference/reference_lua/utf8.rst:254
msgid "Return true if the input character is upper case, otherwise return false."
msgstr ""
"Возврат true (правда), если введенный символ относится к верхнему "
"регистру, в остальных случаях -- false (ложь)."

#: ../doc/1.10/reference/reference_lua/utf8.rst:258
msgid ""
"tarantool> utf8.isupper('Ж'),utf8.isupper('å'),utf8.isupper('9')\n"
"---\n"
"- true\n"
"- false\n"
"- false\n"
"..."
msgstr ""
"tarantool> utf8.isupper('Ж'),utf8.isupper('å'),utf8.isupper('9')\n"
"---\n"
"- true\n"
"- false\n"
"- false\n"
"..."

#: ../doc/1.10/reference/reference_lua/utf8.rst:272
msgid "byte position of the first character"
msgstr "позиция байта первого символа"

#: ../doc/1.10/reference/reference_lua/utf8.rst:273
msgid "byte position where to stop"
msgstr "позиция байта для остановки"

#: ../doc/1.10/reference/reference_lua/utf8.rst:274
msgid "the number of characters in the string, or between start and end"
msgstr "количество символов в строке или же от начала до конца"

#: ../doc/1.10/reference/reference_lua/utf8.rst:277
msgid ""
"Byte positions for start and end can be negative, which indicates "
"\"calculate from end of string\" rather than \"calculate from start of "
"string\"."
msgstr ""
"Позиции байта в начале и в конце могут быть отрицательными, что указывает"
" на отсчет с конца строки, а не с начала."

#: ../doc/1.10/reference/reference_lua/utf8.rst:280
msgid ""
"If the string contains a byte sequence which is not valid in UTF-8, each "
"byte in the invalid byte sequence will be counted as one character."
msgstr ""
"Если строка содержит последовательность байтов, которая неприменима для "
"UTF-8, каждый байт в неправильной последовательности будет считаться за "
"один символ."

#: ../doc/1.10/reference/reference_lua/utf8.rst:283
msgid ""
"UTF-8 is a variable-size encoding scheme. Typically a simple Latin letter"
" takes one byte, a Cyrillic letter takes two bytes, a Chinese/Japanese "
"character takes three bytes, and the maximum is four bytes."
msgstr ""
"UTF-8 представляет собой схему кодирования изменяемого размера. Как "
"правило, одна буква латиницы занимает один байт, буква кириллицы занимает"
" два байта, а символ из китайского или японского языка занимает три "
"байта, максимальный размер -- четыре байта."

#: ../doc/1.10/reference/reference_lua/utf8.rst:290
msgid ""
"tarantool> utf8.len('G'),utf8.len('ж')\n"
"---\n"
"- 1\n"
"- 1\n"
"...\n"
"\n"
"tarantool> string.len('G'),string.len('ж')\n"
"---\n"
"- 1\n"
"- 2\n"
"..."
msgstr ""
"tarantool> utf8.len('G'),utf8.len('ж')\n"
"---\n"
"- 1\n"
"- 1\n"
"...\n"
"\n"
"tarantool> string.len('G'),string.len('ж')\n"
"---\n"
"- 1\n"
"- 2\n"
"..."

#: ../doc/1.10/reference/reference_lua/utf8.rst:309
msgid "the same string, lower case"
msgstr "та же строка в нижнем регистре"

#: ../doc/1.10/reference/reference_lua/utf8.rst:314
msgid ""
"tarantool> utf8.lower('ÅΓÞЖABCDEFG')\n"
"---\n"
"- åγþжabcdefg\n"
"..."
msgstr ""
"tarantool> utf8.lower('ÅΓÞЖABCDEFG')\n"
"---\n"
"- åγþжabcdefg\n"
"..."

#: ../doc/1.10/reference/reference_lua/utf8.rst:326
msgid "byte position where to start within the string, default is 1"
msgstr "позиция байта внутри строки, с которой начать выполнение, по умолчанию = 1"

#: ../doc/1.10/reference/reference_lua/utf8.rst:327
msgid ""
"byte position of the next character and the code point value of the next "
"character"
msgstr ""
"позиция байта следующего символа и значение кодовой точки следующего "
"символа "

#: ../doc/1.10/reference/reference_lua/utf8.rst:330
msgid ""
"The ``next`` function is often used in a loop to get one character at a "
"time from a UTF-8 string."
msgstr ""
"Функция ``next`` часто используется в цикле для получения символа за раз "
"из строки в формате UTF-8."

#: ../doc/1.10/reference/reference_lua/utf8.rst:335
msgid ""
"In the string 'åa' the first character is 'å', it starts at position 1, "
"it takes two bytes to store so the character after it will be at position"
" 3, its Unicode code point value is (decimal) 229."
msgstr ""
"В строке 'åa' первый символ -- 'å', он начинается в позиции 1, занимает "
"два байта, поэтому символ после него будет на позиции 3, значение кодовой"
" точки в Юникоде (десятичное) -- 229."

#: ../doc/1.10/reference/reference_lua/utf8.rst:340
msgid ""
"tarantool> -- show next-character position + first-character codepoint\n"
"tarantool> utf8.next('åa', 1)\n"
"---\n"
"- 3\n"
"- 229\n"
"...\n"
"tarantool> -- (loop) show codepoint of every character\n"
"tarantool> for position,codepoint in utf8.next,'åa' do print(codepoint) "
"end\n"
"229\n"
"97\n"
"..."
msgstr ""
"tarantool> -- показать позицию следующего символа + кодовую точку первого"
" символа\n"
"tarantool> utf8.next('åa', 1)\n"
"---\n"
"- 3\n"
"- 229\n"
"...\n"
"tarantool> -- (цикл) показать кодовую точку каждого символа\n"
"tarantool> for position,codepoint in utf8.next,'åa' do print(codepoint) "
"end\n"
"229\n"
"97\n"
"..."

#: ../doc/1.10/reference/reference_lua/utf8.rst:358
msgid "a string encoded as UTF-8"
msgstr "строка в формате UTF-8"

#: ../doc/1.10/reference/reference_lua/utf8.rst:359
msgid "the position of the first character"
msgstr "позиция первого символа"

#: ../doc/1.10/reference/reference_lua/utf8.rst:360
msgid "the position of the last character"
msgstr "позиция последнего символа"

#: ../doc/1.10/reference/reference_lua/utf8.rst:361
msgid "a UTF-8 string, the \"substring\" of the input value"
msgstr "строка в формате UTF-8, \"подстрока\" введенного значения"

#: ../doc/1.10/reference/reference_lua/utf8.rst:364
msgid ""
"Character positions for start and end can be negative, which indicates "
"\"calculate from end of string\" rather than \"calculate from start of "
"string\"."
msgstr ""
"Позиции символа в начале и в конце могут быть отрицательными, что "
"указывает на отсчет с конца строки, а не с начала."

#: ../doc/1.10/reference/reference_lua/utf8.rst:367
msgid ""
"The default value for end-character is the length of the input string. "
"Therefore, saying ``utf8.sub(1, 'abc')`` will return 'abc', the same as "
"the input string."
msgstr ""
"Значение end-character по умолчанию -- длина введенной строки. Таким "
"образом, выполнение ``utf8.sub(1, 'abc')`` вернет 'abc', т.е. введенную "
"строку."

#: ../doc/1.10/reference/reference_lua/utf8.rst:373
msgid ""
"tarantool> utf8.sub('åγþжabcdefg', 5, 8)\n"
"---\n"
"- abcd\n"
"..."
msgstr ""
"tarantool> utf8.sub('åγþжabcdefg', 5, 8)\n"
"---\n"
"- abcd\n"
"..."

#: ../doc/1.10/reference/reference_lua/utf8.rst:385
msgid "the same string, upper case"
msgstr "та же строка в верхнем регистре"

#: ../doc/1.10/reference/reference_lua/utf8.rst:390
msgid ""
"In rare cases the upper-case result may be longer than the lower-case "
"input, for example ``utf8.upper('ß')`` is 'SS'."
msgstr ""
"В редких случаях результат в верхнем регистре может быть длиннее "
"введенной строки в нижнем регистре, например, ``utf8.upper('ß')`` вернет "
"'SS'."

#: ../doc/1.10/reference/reference_lua/utf8.rst:395
msgid ""
"tarantool> utf8.upper('åγþжabcdefg')\n"
"---\n"
"- ÅΓÞЖABCDEFG\n"
"..."
msgstr ""
"tarantool> utf8.upper('åγþжabcdefg')\n"
"---\n"
"- ÅΓÞЖABCDEFG\n"
"..."

#: ../doc/1.10/reference/reference_lua/uuid.rst:37
msgid "Module `uuid`"
msgstr "Модуль `uuid`"

#: ../doc/1.10/reference/reference_lua/uuid.rst:43
msgid ""
"A \"UUID\" is a `Universally unique identifier`_. If an application "
"requires that a value be unique only within a single computer or on a "
"single database, then a simple counter is better than a UUID, because "
"getting a UUID is time-consuming (it requires a syscall_). For clusters "
"of computers, or widely distributed applications, UUIDs are better."
msgstr ""
"UUID -- это Универсальный уникальный идентификатор (`Universally unique "
"identifier`_). Если значение должно быть уникальным в пределах отдельного"
" компьютера или одной базы данных, лучше использовать простой счетчик "
"вместо UUID, поскольку получение UUID затратно по времени (требуется "
"syscall_). Что же касается кластеров компьютеров или широко "
"распространенных приложений, лучше использовать UUID."

#: ../doc/1.10/reference/reference_lua/uuid.rst:53
msgid "Below is list of all ``uuid`` functions and members."
msgstr "Ниже приведен перечень всех функций и элементов модуля ``uuid``."

#: ../doc/1.10/reference/reference_lua/uuid.rst:63
msgid ":ref:`uuid.nil <uuid-nil>`"
msgstr ":ref:`uuid.nil <uuid-nil>`"

#: ../doc/1.10/reference/reference_lua/uuid.rst:63
#: ../doc/1.10/reference/reference_lua/uuid.rst:88
msgid "A nil object"
msgstr "Объект nil"

#: ../doc/1.10/reference/reference_lua/uuid.rst:65
msgid ""
":ref:`uuid() <uuid-__call>` |br| :ref:`uuid.bin() <uuid-bin>` |br| "
":ref:`uuid.str() <uuid-str>`"
msgstr ""
":ref:`uuid() <uuid-__call>` |br| :ref:`uuid.bin() <uuid-bin>` |br| "
":ref:`uuid.str() <uuid-str>`"

#: ../doc/1.10/reference/reference_lua/uuid.rst:66
msgid "Get a UUID"
msgstr "Получение UUID"

#: ../doc/1.10/reference/reference_lua/uuid.rst:69
msgid ""
":ref:`uuid.fromstr() <uuid-fromstr>` |br| :ref:`uuid.frombin() <uuid-"
"frombin>` |br| :ref:`uuid_object:bin() <uuid-object_bin>` |br| "
":ref:`uuid_object:str() <uuid-object_str>`"
msgstr ""
":ref:`uuid.fromstr() <uuid-fromstr>` |br| :ref:`uuid.frombin() <uuid-"
"frombin>` |br| :ref:`uuid_object:bin() <uuid-object_bin>` |br| "
":ref:`uuid_object:str() <uuid-object_str>`"

#: ../doc/1.10/reference/reference_lua/uuid.rst:72
msgid "Get a converted UUID"
msgstr "Получение конвертированного UUID"

#: ../doc/1.10/reference/reference_lua/uuid.rst:78
msgid ":ref:`uuid_object:isnil() <uuid-isnil>`"
msgstr ":ref:`uuid_object:isnil() <uuid-isnil>`"

#: ../doc/1.10/reference/reference_lua/uuid.rst:78
msgid "Check if a UUID is an all-zero value"
msgstr "Проверка, состоит ли UUID из одних нулей"

#: ../doc/1.10/reference/reference_lua/uuid.rst:94
#: ../doc/1.10/reference/reference_lua/uuid.rst:101
#: ../doc/1.10/reference/reference_lua/uuid.rst:108
msgid "a UUID"
msgstr "UUID"

#: ../doc/1.10/reference/reference_lua/uuid.rst:102
msgid "16-byte string"
msgstr "16-байтная строка"

#: ../doc/1.10/reference/reference_lua/uuid.rst:109
msgid "36-byte binary string"
msgstr "36-байтная двоичная строка"

#: ../doc/1.10/reference/reference_lua/uuid.rst:115
msgid "UUID in 36-byte hexadecimal string"
msgstr "UUID в 36-байтной шестнадцатеричной строке"

#: ../doc/1.10/reference/reference_lua/uuid.rst:116
#: ../doc/1.10/reference/reference_lua/uuid.rst:124
msgid "converted UUID"
msgstr "конвертированный UUID"

#: ../doc/1.10/reference/reference_lua/uuid.rst:123
msgid "UUID in 16-byte binary string"
msgstr "UUID в 16-байтной двоичной строке"

#: ../doc/1.10/reference/reference_lua/uuid.rst:133
msgid "``byte-order`` can be one of next flags:"
msgstr "``byte-order`` может быть одним из следующих флагов:"

#: ../doc/1.10/reference/reference_lua/uuid.rst:135
msgid "'l' - little-endian,"
msgstr "'l' - порядок от младшего к старшему,"

#: ../doc/1.10/reference/reference_lua/uuid.rst:136
msgid "'b' - big-endian,"
msgstr "'b' - порядок от старшего к младшему,"

#: ../doc/1.10/reference/reference_lua/uuid.rst:137
msgid "'h' - endianness depends on host (default),"
msgstr "'h' - порядок зависит от хоста (по умолчанию),"

#: ../doc/1.10/reference/reference_lua/uuid.rst:138
msgid "'n' - endianness depends on network"
msgstr "'n' - порядок зависит от сети"

#: ../doc/1.10/reference/reference_lua/uuid.rst:140
msgid "one of ``'l'``, ``'b'``, ``'h'`` or ``'n'``."
msgstr "один из ``'l'``, ``'b'``, ``'h'`` или ``'n'``."

#: ../doc/1.10/reference/reference_lua/uuid.rst:142
#: ../doc/1.10/reference/reference_lua/uuid.rst:149
msgid "UUID converted from cdata input value."
msgstr "UUID, сконвертированный из введенного значения формата cdata."

#: ../doc/1.10/reference/reference_lua/uuid.rst:143
msgid "16-byte binary string"
msgstr "16-байтная двоичная строка"

#: ../doc/1.10/reference/reference_lua/uuid.rst:150
msgid "36-byte hexadecimal string"
msgstr "36-байтная шестнадцатеричная строка"

#: ../doc/1.10/reference/reference_lua/uuid.rst:156
msgid ""
"The all-zero UUID value can be expressed as uuid.NULL, or as "
"``uuid.fromstr('00000000-0000-0000-0000-000000000000')``. The comparison "
"with an all-zero value can also be expressed as ``uuid_with_type_cdata =="
" uuid.NULL``."
msgstr ""
"Значение UUID из одних нулей может быть выражено как uuid.NULL или "
"``uuid.fromstr('00000000-0000-0000-0000-000000000000')``. Сравнение со "
"значением из одних нулей также может быть выражено как "
"``uuid_with_type_cdata == uuid.NULL``."

#: ../doc/1.10/reference/reference_lua/uuid.rst:161
msgid "true if the value is all zero, otherwise false."
msgstr ""
"true (правда), если значение состоит из одних нулей, в противном случае "
"false (ложь)."

#: ../doc/1.10/reference/reference_lua/uuid.rst:168
msgid ""
"tarantool> uuid = require('uuid')\n"
"---\n"
"...\n"
"tarantool> uuid(), uuid.bin(), uuid.str()\n"
"---\n"
"- 16ffedc8-cbae-4f93-a05e-349f3ab70baa\n"
"- !!binary FvG+Vy1MfUC6kIyeM81DYw==\n"
"- 67c999d2-5dce-4e58-be16-ac1bcb93160f\n"
"...\n"
"tarantool> uu = uuid()\n"
"---\n"
"...\n"
"tarantool> #uu:bin(), #uu:str(), type(uu), uu:isnil()\n"
"---\n"
"- 16\n"
"- 36\n"
"- cdata\n"
"- false\n"
"..."
msgstr ""
"tarantool> uuid = require('uuid')\n"
"---\n"
"...\n"
"tarantool> uuid(), uuid.bin(), uuid.str()\n"
"---\n"
"- 16ffedc8-cbae-4f93-a05e-349f3ab70baa\n"
"- !!binary FvG+Vy1MfUC6kIyeM81DYw==\n"
"- 67c999d2-5dce-4e58-be16-ac1bcb93160f\n"
"...\n"
"tarantool> uu = uuid()\n"
"---\n"
"...\n"
"tarantool> #uu:bin(), #uu:str(), type(uu), uu:isnil()\n"
"---\n"
"- 16\n"
"- 36\n"
"- cdata\n"
"- false\n"
"..."

#: ../doc/1.10/reference/reference_lua/xlog.rst:39
msgid "Module `xlog`"
msgstr "Модуль `xlog`"

#: ../doc/1.10/reference/reference_lua/xlog.rst:41
msgid ""
"The xlog module contains one function: ``pairs()``. It can be used to "
"read Tarantool's :ref:`snapshot files<index-box_persistence>` or :ref"
":`write-ahead-log (WAL) <internals-wal>` files. A description of the file"
" format is in section :ref:`Data persistence and the WAL file format "
"<internals-data_persistence>`."
msgstr ""
"Модуль xlog включает в себя одну функцию: ``pairs()``. Ее можно "
"использовать для чтения :ref:`файлов снимка <index-box_persistence>` или "
":ref:`файлов журнала упреждающей записи (WAL) <internals-wal>` в "
"Tarantool'е. Описание формата файла дается в разделе "
":ref:`Персистентность данных и формат WAL-файла <internals-"
"data_persistence>`."

#: ../doc/1.10/reference/reference_lua/xlog.rst:53
msgid "Open a file, and allow iterating over one file entry at a time."
msgstr "Открытие файла и итерация по одной записи файла за раз."

#: ../doc/1.10/reference/reference_lua/xlog.rst
msgid "returns"
msgstr "возвращает"

#: ../doc/1.10/reference/reference_lua/xlog.rst:55
msgid "iterator  which can be used in a for/end loop."
msgstr "итератор, который можно использовать в цикле for / end."

#: ../doc/1.10/reference/reference_lua/xlog.rst:56
msgid "`iterator <https://www.lua.org/pil/7.1.html>`_"
msgstr "`итератор <https://www.lua.org/pil/7.1.html>`_"

#: ../doc/1.10/reference/reference_lua/xlog.rst:58
msgid ""
"Possible errors: File does not contain properly formatted snapshot or "
"write-ahead-log information."
msgstr ""
"Возможные ошибки: Файл не содержит снимок в правильном формате или "
"информацию журнала упреждающей записи."

#: ../doc/1.10/reference/reference_lua/xlog.rst:63
msgid ""
"This will read the first write-ahead-log (WAL) file that was created in "
"the :ref:`wal_dir <cfg_basic-wal_dir>` directory in our :ref:`\"Getting "
"started\" exercises <getting_started>`."
msgstr ""
"В данном примере производится чтение первого WAL-файла, который был "
"создан в директории :ref:`wal_dir <cfg_basic-wal_dir>` в рамках наших "
":ref:`упражнений в \"Руководстве для начинающих\" <getting_started>`."

#: ../doc/1.10/reference/reference_lua/xlog.rst:67
msgid ""
"Each result from ``pairs()`` is formatted with MsgPack so its structure "
"can be specified with :ref:`__serialize <msgpack-serialize>`."
msgstr ""
"Каждый результат из ``pairs()`` выводится в формате MsgPack, поэтому его "
"структуру можно указать с помощью :ref:`__serialize <msgpack-serialize>`."

#: ../doc/1.10/reference/reference_lua/xlog.rst:70
msgid ""
"xlog = require('xlog')\n"
"t = {}\n"
"for k, v in xlog.pairs('00000000000000000000.xlog') do\n"
"  table.insert(t, setmetatable(v, { __serialize = \"map\"}))\n"
"end\n"
"return t"
msgstr ""
"xlog = require('xlog')\n"
"t = {}\n"
"for k, v in xlog.pairs('00000000000000000000.xlog') do\n"
"  table.insert(t, setmetatable(v, { __serialize = \"map\"}))\n"
"end\n"
"return t"

#: ../doc/1.10/reference/reference_lua/xlog.rst:79
msgid "The first lines of the result will look like:"
msgstr "Первые строки результата будут выглядеть следующим образом:"

#: ../doc/1.10/reference/reference_lua/xlog.rst:81
msgid ""
"(...)\n"
"---\n"
"- - {'BODY':   {'space_id': 272, 'index_base': 1, 'key': ['max_id'],\n"
"                'tuple': [['+', 2, 1]]},\n"
"     'HEADER': {'type': 'UPDATE', 'timestamp': 1477846870.8541,\n"
"                'lsn': 1, 'server_id': 1}}\n"
"  - {'BODY':   {'space_id': 280,\n"
"                 'tuple': [512, 1, 'tester', 'memtx', 0, {}, []]},\n"
"     'HEADER': {'type': 'INSERT', 'timestamp': 1477846870.8597,\n"
"                'lsn': 2, 'server_id': 1}}"
msgstr ""
"(...)\n"
"---\n"
"- - {'BODY':   {'space_id': 272, 'index_base': 1, 'key': ['max_id'],\n"
"                'tuple': [['+', 2, 1]]},\n"
"     'HEADER': {'type': 'UPDATE', 'timestamp': 1477846870.8541,\n"
"                'lsn': 1, 'server_id': 1}}\n"
"  - {'BODY':   {'space_id': 280,\n"
"                 'tuple': [512, 1, 'tester', 'memtx', 0, {}, []]},\n"
"     'HEADER': {'type': 'INSERT', 'timestamp': 1477846870.8597,\n"
"                'lsn': 2, 'server_id': 1}}"

#: ../doc/1.10/reference/reference_lua/yaml.rst:39
msgid "Module `yaml`"
msgstr "Модуль `yaml`"

#: ../doc/1.10/reference/reference_lua/yaml.rst:45
msgid ""
"The ``yaml`` module takes strings in YAML_ format and decodes them, or "
"takes a series of non-YAML values and encodes them."
msgstr ""
"Модуль ``yaml`` берет строки в формате YAML_ и декодирует их или берет "
"ряд значений в ином формате и кодирует их в формат YAML."

#: ../doc/1.10/reference/reference_lua/yaml.rst:52
msgid "Below is a list of all ``yaml`` functions and members."
msgstr "Ниже приведен перечень всех функций и элементов модуля ``yaml``."

#: ../doc/1.10/reference/reference_lua/yaml.rst:62
msgid ":ref:`yaml.encode() <yaml-encode>`"
msgstr ":ref:`yaml.encode() <yaml-encode>`"

#: ../doc/1.10/reference/reference_lua/yaml.rst:62
msgid "Convert a Lua object to a YAML string"
msgstr "Конвертация Lua-объекта в YAML-строку"

#: ../doc/1.10/reference/reference_lua/yaml.rst:65
msgid ":ref:`yaml.decode() <yaml-decode>`"
msgstr ":ref:`yaml.decode() <yaml-decode>`"

#: ../doc/1.10/reference/reference_lua/yaml.rst:65
msgid "Convert a YAML string to a Lua object"
msgstr "Конвертация YAML-строки в Lua-объект"

#: ../doc/1.10/reference/reference_lua/yaml.rst:68
msgid ":ref:`yaml.NULL <yaml-null>`"
msgstr ":ref:`yaml.NULL <yaml-null>`"

#: ../doc/1.10/reference/reference_lua/yaml.rst:78
msgid "Convert a Lua object to a YAML string."
msgstr "Конвертация Lua-объекта в YAML-строку."

#: ../doc/1.10/reference/reference_lua/yaml.rst:81
msgid "the original value reformatted as a YAML string."
msgstr "оригинальное значение, преобразованное в YAML-строку."

#: ../doc/1.10/reference/reference_lua/yaml.rst:88
msgid "Convert a YAML string to a Lua object."
msgstr "Конвертация YAML-строки в Lua-объект."

#: ../doc/1.10/reference/reference_lua/yaml.rst:90
msgid "a string formatted as YAML."
msgstr "строка в формате YAML."

#: ../doc/1.10/reference/reference_lua/yaml.rst:104
msgid ""
"tarantool> yaml = require('yaml')\n"
"---\n"
"...\n"
"tarantool> y = yaml.encode({'a', 1, 'b', 2})\n"
"---\n"
"...\n"
"tarantool> z = yaml.decode(y)\n"
"---\n"
"...\n"
"tarantool> z[1], z[2], z[3], z[4]\n"
"---\n"
"- a\n"
"- 1\n"
"- b\n"
"- 2\n"
"...\n"
"tarantool> if yaml.NULL == nil then print('hi') end\n"
"hi\n"
"---\n"
"..."
msgstr ""
"tarantool> yaml = require('yaml')\n"
"---\n"
"...\n"
"tarantool> y = yaml.encode({'a', 1, 'b', 2})\n"
"---\n"
"...\n"
"tarantool> z = yaml.decode(y)\n"
"---\n"
"...\n"
"tarantool> z[1], z[2], z[3], z[4]\n"
"---\n"
"- a\n"
"- 1\n"
"- b\n"
"- 2\n"
"...\n"
"tarantool> if yaml.NULL == nil then print('hi') end\n"
"hi\n"
"---\n"
"..."

#: ../doc/1.10/reference/reference_lua/yaml.rst:127
msgid ""
"The `YAML collection style <http://yaml.org/spec/1.1/#id930798>`_ can be "
"specified with ``__serialize``:"
msgstr ""
"`Набор YAML-стилей <http://yaml.org/spec/1.1/#id930798>`_ можно указать с"
" помощью ``__serialize``:"

#: ../doc/1.10/reference/reference_lua/yaml.rst:130
msgid "``__serialize=\"sequence\"`` for a Block Sequence array,"
msgstr "``__serialize=\"sequence\"`` для массива последовательности блоков,"

#: ../doc/1.10/reference/reference_lua/yaml.rst:131
msgid "``__serialize=\"seq\"`` for a Flow Sequence array,"
msgstr "``__serialize=\"seq\"`` для массива последовательности потоков,"

#: ../doc/1.10/reference/reference_lua/yaml.rst:132
msgid "``__serialize=\"mapping\"`` for a Block Mapping map,"
msgstr ""
"``__serialize=\"mapping\"`` для ассоциативного массива последовательности"
" блоков,"

#: ../doc/1.10/reference/reference_lua/yaml.rst:133
msgid "``__serialize=\"map\"`` for a Flow Mapping map."
msgstr ""
"``__serialize=\"map\"`` для ассоциативного массива последовательности "
"потоков."

#: ../doc/1.10/reference/reference_lua/yaml.rst:138
msgid ""
"tarantool> yaml = require('yaml')\n"
"---\n"
"...\n"
"tarantool> yaml.encode(setmetatable({'A', 'B'}, { "
"__serialize=\"sequence\"}))\n"
"---\n"
"- |\n"
"  ---\n"
"  - A\n"
"  - B\n"
"  ...\n"
"...\n"
"tarantool> yaml.encode(setmetatable({'A', 'B'}, { __serialize=\"seq\"}))\n"
"---\n"
"- |\n"
"  ---\n"
"  ['A', 'B']\n"
"  ...\n"
"...\n"
"tarantool> yaml.encode({setmetatable({f1 = 'A', f2 = 'B'}, { "
"__serialize=\"map\"})})\n"
"---\n"
"- |\n"
"  ---\n"
"  - {'f2': 'B', 'f1': 'A'}\n"
"  ...\n"
"...\n"
"tarantool> yaml.encode({setmetatable({f1 = 'A', f2 = 'B'}, { "
"__serialize=\"mapping\"})})\n"
"---\n"
"- |\n"
"  ---\n"
"  - f2: B\n"
"    f1: A\n"
"  ...\n"
"..."
msgstr ""
"tarantool> yaml = require('yaml')\n"
"---\n"
"...\n"
"tarantool> yaml.encode(setmetatable({'A', 'B'}, { "
"__serialize=\"sequence\"}))\n"
"---\n"
"- |\n"
"  ---\n"
"  - A\n"
"  - B\n"
"  ...\n"
"...\n"
"tarantool> yaml.encode(setmetatable({'A', 'B'}, { __serialize=\"seq\"}))\n"
"---\n"
"- |\n"
"  ---\n"
"  ['A', 'B']\n"
"  ...\n"
"...\n"
"tarantool> yaml.encode({setmetatable({f1 = 'A', f2 = 'B'}, { "
"__serialize=\"map\"})})\n"
"---\n"
"- |\n"
"  ---\n"
"  - {'f2': 'B', 'f1': 'A'}\n"
"  ...\n"
"...\n"
"tarantool> yaml.encode({setmetatable({f1 = 'A', f2 = 'B'}, { "
"__serialize=\"mapping\"})})\n"
"---\n"
"- |\n"
"  ---\n"
"  - f2: B\n"
"    f1: A\n"
"  ...\n"
"..."

#: ../doc/1.10/reference/reference_lua/yaml.rst:174
msgid ""
"Also, some YAML configuration settings for encoding can be changed, in "
"the same way that they can be changed for :ref:`JSON <json-module_cfg>`."
msgstr ""
"Кроме того, некоторые параметры конфигурации YAML для кодировки можно "
"изменить так же, как и для :ref:`JSON <json-module_cfg>`."

#: ../doc/1.10/reference/reference_rock/dbms.rst:39
msgid "SQL DBMS Modules"
msgstr "Модули СУБД SQL"

#: ../doc/1.10/reference/reference_rock/dbms.rst:41
msgid ""
"The discussion here in the reference is about incorporating and using two"
" modules that have already been created: the \"SQL DBMS rocks\" for MySQL"
" and PostgreSQL."
msgstr ""
"В данном разделе справочника рассматривается внедрение и использование "
"двух уже созданных модулей: сторонние библиотеки СУБД SQL для MySQL и "
"PostgreSQL."

#: ../doc/1.10/reference/reference_rock/dbms.rst:45
msgid ""
"To call another DBMS from Tarantool, the essential requirements are: "
"another DBMS, and Tarantool. The module which connects Tarantool to "
"another DBMS may be called a \"connector\". Within the module there is a "
"shared library which may be called a \"driver\"."
msgstr ""
"Для вызова другой СУБД из Tarantool'а нужно: другая СУБД и Tarantool. "
"Модуль, который соединяет другую СУБД может называться коннектором. В "
"модуле есть библиотека общего пользования, которая может называться "
"драйвером."

#: ../doc/1.10/reference/reference_rock/dbms.rst:50
msgid ""
"Tarantool supplies DBMS connector modules with the module manager for "
"Lua, LuaRocks. So the connector modules may be called \"rocks\"."
msgstr ""
"Tarantool предоставляет модули-коннекторы для СУБД вместе с менеджером "
"модулей для Lua под названием LuaRocks."

#: ../doc/1.10/reference/reference_rock/dbms.rst:53
msgid ""
"The Tarantool rocks allow for connecting to SQL servers and executing SQL"
" statements the same way that a MySQL or PostgreSQL client does. The SQL "
"statements are visible as Lua methods. Thus Tarantool can serve as a "
"\"MySQL Lua Connector\" or \"PostgreSQL Lua Connector\", which would be "
"useful even if that was all Tarantool could do. But of course Tarantool "
"is also a DBMS, so the module also is useful for any operations, such as "
"database copying and accelerating, which work best when the application "
"can work on both SQL and Tarantool inside the same Lua routine. The "
"methods for connect/select/insert/etc. are similar to the ones in the "
":ref:`net.box <net_box-module>` module."
msgstr ""
"Модули Tarantool'а позволяют подключаться к SQL-серверам и выполнять "
"SQL-запросы так же, как это делает клиент MySQL или PostgreSQL. Операторы"
" SQL доступны как Lua-методы. Таким образом, Tarantool может служить "
"Lua-коннектором для MySQL или Lua-коннектором для PostgreSQL, что было бы"
" полезно, даже если бы Tarantool больше ничего не умел. Но конечно же, "
"Tarantool также представляет собой СУБД, поэтому модуль используется для "
"любых операций, таких как копирование и ускорение базы данных, которые "
"максимально эффективно, если приложение может работать как с SQL, так и с"
" Tarantool в пределах одной Lua-процедуры. Методы подключения / выборки /"
" вставки / и т.д. аналогичны методам модуля :ref:`net.box <net_box-"
"module>`."

#: ../doc/1.10/reference/reference_rock/dbms.rst:64
msgid ""
"From a user's point of view the MySQL and PostgreSQL rocks are very "
"similar, so the following sections -- \"MySQL Example\" and \"PostgreSQL "
"Example\" -- contain some redundancy."
msgstr ""
"С точки зрения пользователя, модули для MySQL и PostgreSQL очень похожи, "
"поэтому следующие разделы -- \"Пример для MySQL\" и \"Пример для "
"PostgreSQL\" -- слегка избыточны."

#: ../doc/1.10/reference/reference_rock/dbms.rst:72
msgid "MySQL Example"
msgstr "Пример для MySQL"

#: ../doc/1.10/reference/reference_rock/dbms.rst:74
msgid ""
"This example assumes that MySQL 5.5 or MySQL 5.6 or MySQL 5.7 has been "
"installed. Recent MariaDB versions will also work, the MariaDB C "
"connector is used. The package that matters most is the MySQL client "
"developer package, typically named something like libmysqlclient-dev. The"
" file that matters most from this package is libmysqlclient.so or a "
"similar name. One can use ``find`` or ``whereis`` to see what directories"
" these files are installed in."
msgstr ""
"В данном примере предполагается, что установлены MySQL 5.5, MySQL 5.6 или"
" MySQL 5.7. Последние версии MariaDB также подойдут, используется "
"коннектор к MariaDB для C. Самым важным пакетом будет пакет для "
"разработчиков клиента MySQL, который обычно называется libmysqlclient-"
"dev. Наиболее важным файлом из этого пакета будет файл libmysqlclient.so "
"или с похожим названием. Можно использовать `` find`` или `` whereis``, "
"чтобы узнать, в каких директориях установлены эти файлы."

#: ../doc/1.10/reference/reference_rock/dbms.rst:81
msgid ""
"It will be necessary to install Tarantool's MySQL driver shared library, "
"load it, and use it to connect to a MySQL server instance. After that, "
"one can pass any MySQL statement to the server instance and receive "
"results, including multiple result sets."
msgstr ""
"Также нужно будет установить библиотеку общего пользования Tarantool'а с "
"драйвером для MySQL, загрузить ее и использовать для подключения к "
"экземпляру MySQL-сервера. После этого можно передавать любой оператор "
"MySQL на экземпляр сервера и получать результаты, включая наборы "
"результатов."

#: ../doc/1.10/reference/reference_rock/dbms.rst:87
#: ../doc/1.10/reference/reference_rock/dbms.rst:440
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:91
msgid "Installation"
msgstr "Установка"

#: ../doc/1.10/reference/reference_rock/dbms.rst:89
#: ../doc/1.10/reference/reference_rock/dbms.rst:442
msgid ""
"Check the instructions for `downloading and installing a binary package "
"<http://tarantool.org/download.html>`_ that apply for the environment "
"where Tarantool was installed. In addition to installing ``tarantool``, "
"install ``tarantool-dev``. For example, on Ubuntu, add the line:"
msgstr ""
"Проверьте инструкции по `загрузке и установке бинарного пакета "
"<http://tarantool.org/download.html>`_, которые применимы к среде, где "
"установлен Tarantool. Помимо установки ``tarantool``, установите "
"``tarantool-dev``. Например, в Ubuntu добавьте строку:"

#: ../doc/1.10/reference/reference_rock/dbms.rst:99
msgid "Now, for the MySQL driver shared library, there are two ways to install:"
msgstr ""
"Что касается библиотеки общего пользования с драйвером для MySQL, ее "
"можно установить двумя способами:"

#: ../doc/1.10/reference/reference_rock/dbms.rst:103
#: ../doc/1.10/reference/reference_rock/dbms.rst:456
msgid "With LuaRocks"
msgstr "Из LuaRocks"

#: ../doc/1.10/reference/reference_rock/dbms.rst:105
#: ../doc/1.10/reference/reference_rock/dbms.rst:458
msgid ""
"Begin by installing luarocks and making sure that tarantool is among the "
"upstream servers, as in the instructions on `rocks.tarantool.org`_, the "
"Tarantool luarocks page. Now execute this:"
msgstr ""
"Начните с установки luarocks. Убедитесь, что tarantool указан в серверах,"
" как описано на странице сторонних модулей Tarantool'а "
"`rocks.tarantool.org`_. Затем выполните:"

#: ../doc/1.10/reference/reference_rock/dbms.rst:112
msgid ""
"luarocks install mysql [MYSQL_LIBDIR = *path*]\n"
"                       [MYSQL_INCDIR = *path*]\n"
"                       [--local]"
msgstr ""
"luarocks install mysql [MYSQL_LIBDIR = *path*]\n"
"                       [MYSQL_INCDIR = *path*]\n"
"                       [--local]"

#: ../doc/1.10/reference/reference_rock/dbms.rst:118
msgid "$ luarocks install mysql MYSQL_LIBDIR=/usr/local/mysql/lib"
msgstr "$ luarocks install mysql MYSQL_LIBDIR=/usr/local/mysql/lib"

#: ../doc/1.10/reference/reference_rock/dbms.rst:124
#: ../doc/1.10/reference/reference_rock/dbms.rst:477
msgid "With GitHub"
msgstr "Из GitHub"

#: ../doc/1.10/reference/reference_rock/dbms.rst:126
msgid ""
"Go the site `github.com/tarantool/mysql`_. Follow the instructions there,"
" saying:"
msgstr ""
"Перейдите по ссылке `github.com/tarantool/mysql`_. Следуя инструкциям, "
"введите команду:"

#: ../doc/1.10/reference/reference_rock/dbms.rst:128
msgid ""
"$ git clone https://github.com/tarantool/mysql.git\n"
"$ cd mysql && cmake . -DCMAKE_BUILD_TYPE=RelWithDebInfo\n"
"$ make\n"
"$ make install"
msgstr ""
"$ git clone https://github.com/tarantool/mysql.git\n"
" $ cd mysql && cmake . -DCMAKE_BUILD_TYPE=RelWithDebInfo\n"
" $ make\n"
" $ make install"

#: ../doc/1.10/reference/reference_rock/dbms.rst:135
#: ../doc/1.10/reference/reference_rock/dbms.rst:488
msgid ""
"At this point it is a good idea to check that the installation produced a"
" file named ``driver.so``, and to check that this file is on a directory "
"that is searched by the ``require`` request."
msgstr ""
"На данном этапе желательно проверить, что после установки появился файл "
"под названием ``driver.so``, а также проверить, что этот файл находится в"
" директории, которую можно найти по запросу ``require``."

#: ../doc/1.10/reference/reference_rock/dbms.rst:141
#: ../doc/1.10/reference/reference_rock/dbms.rst:494
msgid "Connecting"
msgstr "Подключение"

#: ../doc/1.10/reference/reference_rock/dbms.rst:143
msgid ""
"Begin by making a ``require`` request for the mysql driver. We will "
"assume that the name is ``mysql`` in further examples."
msgstr ""
"Начните с выполнения запроса ``require`` для драйвера mysql. В дальнейших"
" примерах у него будет имя ``mysql``."

#: ../doc/1.10/reference/reference_rock/dbms.rst:146
msgid "mysql = require('mysql')"
msgstr "mysql = require('mysql')"

#: ../doc/1.10/reference/reference_rock/dbms.rst:150
#: ../doc/1.10/reference/reference_rock/dbms.rst:503
msgid "Now, say:"
msgstr "Теперь выполните:"

#: ../doc/1.10/reference/reference_rock/dbms.rst:155
msgid "*connection_name* = mysql.connect(*connection options*)"
msgstr "*имя_подключения* = mysql.connect(*параметры подключения*)"

#: ../doc/1.10/reference/reference_rock/dbms.rst:157
#: ../doc/1.10/reference/reference_rock/dbms.rst:510
msgid "The connection-options parameter is a table. Possible options are:"
msgstr "Параметры подключения включены в таблицу. Доступные параметры:"

#: ../doc/1.10/reference/reference_rock/dbms.rst:159
#: ../doc/1.10/reference/reference_rock/dbms.rst:512
msgid ":samp:`host = {host-name}` - string, default value = 'localhost'"
msgstr ":samp:`host = {имя-хоста}` -- строка, значение по умолчанию = 'localhost'"

#: ../doc/1.10/reference/reference_rock/dbms.rst:160
msgid ":samp:`port = {port-number}` - number, default value = 3306"
msgstr ":samp:`port = {номер-порта}` -- число, значение по умолчанию = 3306"

#: ../doc/1.10/reference/reference_rock/dbms.rst:161
#: ../doc/1.10/reference/reference_rock/dbms.rst:514
msgid ""
":samp:`user = {user-name}` - string, default value is operating-system "
"user name"
msgstr ""
":samp:`user = {имя-пользователя}` -- строка, значение по умолчанию -- имя"
" пользователя в операционной системе"

#: ../doc/1.10/reference/reference_rock/dbms.rst:162
msgid ":samp:`password = {password}` - string, default value is blank"
msgstr ":samp:`password = {пароль}` -- строка, по умолчанию пустая"

#: ../doc/1.10/reference/reference_rock/dbms.rst:163
#: ../doc/1.10/reference/reference_rock/dbms.rst:516
msgid ":samp:`db = {database-name}` - string, default value is blank"
msgstr ":samp:`db = {имя-базы-данных}` -- строка, по умолчанию пустая"

#: ../doc/1.10/reference/reference_rock/dbms.rst:164
msgid ":samp:`raise = {true|false}` - boolean, default value is false"
msgstr ""
":samp:`raise = {true|false}` -- логическое значение, по умолчанию, false "
"(ложь)"

#: ../doc/1.10/reference/reference_rock/dbms.rst:166
msgid ""
"The option names, except for `raise`, are similar to the names that "
"MySQL's mysql client uses, for details see the MySQL manual at "
"`dev.mysql.com/doc/refman/5.6/en/connecting.html`_. The `raise` option "
"should be set to :codenormal:`true` if errors should be raised when "
"encountered. To connect with a Unix socket rather than with TCP, specify "
"``host = 'unix/'`` and :samp:`port = {socket-name}`."
msgstr ""
"Имена параметров, за исключением `raise`, похожи на имена, которые "
"используются в MySQL-клиенте mysql, для получения подробной информации "
"см. руководство по MySQL по ссылке "
"`dev.mysql.com/doc/refman/5.6/en/connecting.html`_. Значение параметра "
"`raise` следует указать как :codenormal:`true`, если ошибки должны "
"возникать при обнаружении. Чтобы подключиться по Unix-сокету, а не по "
"TCP, укажите ``host = 'unix/'`` и :samp:`port = {имя-сокета}`."

#: ../doc/1.10/reference/reference_rock/dbms.rst:173
#: ../doc/1.10/reference/reference_rock/dbms.rst:520
msgid "Example, using a table literal enclosed in {braces}:"
msgstr "Пример с использованием таблицы, заключенной в {фигурные скобки}:"

#: ../doc/1.10/reference/reference_rock/dbms.rst:175
msgid ""
"conn = mysql.connect({\n"
"    host = '127.0.0.1',\n"
"    port = 3306,\n"
"    user = 'p',\n"
"    password = 'p',\n"
"    db = 'test',\n"
"    raise = true\n"
"})\n"
"-- OR\n"
"conn = mysql.connect({\n"
"    host = 'unix/',\n"
"    port = '/var/run/mysqld/mysqld.sock'\n"
"})"
msgstr ""
"conn = mysql.connect({\n"
"     host = '127.0.0.1',\n"
"     port = 3306,\n"
"     user = 'p',\n"
"     password = 'p',\n"
"     db = 'test',\n"
"     raise = true\n"
" })\n"
"-- ИЛИ\n"
"conn = mysql.connect({\n"
"    host = 'unix/',\n"
"    port = '/var/run/mysqld/mysqld.sock'\n"
"})"

#: ../doc/1.10/reference/reference_rock/dbms.rst:191
#: ../doc/1.10/reference/reference_rock/dbms.rst:532
msgid "Example, creating a function which sets each option in a separate line:"
msgstr ""
"Пример с созданием функции, которая определяет параметры в отдельных "
"строках:"

#: ../doc/1.10/reference/reference_rock/dbms.rst:193
msgid ""
"tarantool> -- Connection function. Usage: conn = mysql_connect()\n"
"tarantool> function mysql_connection()\n"
"         >   local p = {}\n"
"         >   p.host = 'widgets.com'\n"
"         >   p.db = 'test'\n"
"         >   conn = mysql.connect(p)\n"
"         >   return conn\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> conn = mysql_connect()\n"
"---\n"
"..."
msgstr ""
"tarantool> -- Функция подключения. Использование: conn = mysql_connect()\n"
"tarantool> function mysql_connection()\n"
"         >   local p = {}\n"
"         >   p.host = 'widgets.com'\n"
"         >   p.db = 'test'\n"
"         >   conn = mysql.connect(p)\n"
"         >   return conn\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> conn = mysql_connect()\n"
"---\n"
"..."

#: ../doc/1.10/reference/reference_rock/dbms.rst:209
#: ../doc/1.10/reference/reference_rock/dbms.rst:551
msgid "We will assume that the name is 'conn' in further examples."
msgstr "Предполагаем, что в дальнейших примерах будет использоваться имя 'conn'."

#: ../doc/1.10/reference/reference_rock/dbms.rst:213
#: ../doc/1.10/reference/reference_rock/dbms.rst:555
msgid "How to ping"
msgstr "Как проверить связь"

#: ../doc/1.10/reference/reference_rock/dbms.rst:215
#: ../doc/1.10/reference/reference_rock/dbms.rst:557
msgid "To ensure that a connection is working, the request is:"
msgstr "Чтобы убедиться, что подключение работает, следует использовать запрос:"

#: ../doc/1.10/reference/reference_rock/dbms.rst:220
#: ../doc/1.10/reference/reference_rock/dbms.rst:562
msgid "*connection-name*:ping()"
msgstr "*имя-соединение*:ping()"

#: ../doc/1.10/reference/reference_rock/dbms.rst:224
#: ../doc/1.10/reference/reference_rock/dbms.rst:566
msgid ""
"tarantool> conn:ping()\n"
"---\n"
"- true\n"
"..."
msgstr ""
"tarantool> conn:ping()\n"
"---\n"
"- true\n"
"..."

#: ../doc/1.10/reference/reference_rock/dbms.rst:233
#: ../doc/1.10/reference/reference_rock/dbms.rst:575
msgid "Executing a statement"
msgstr "Исполнение оператора"

#: ../doc/1.10/reference/reference_rock/dbms.rst:235
msgid "For all MySQL statements, the request is:"
msgstr "Для всех операторов MySQL запрос будет:"

#: ../doc/1.10/reference/reference_rock/dbms.rst:240
#: ../doc/1.10/reference/reference_rock/dbms.rst:582
msgid "*connection-name*:execute(*sql-statement* [, *parameters*])"
msgstr "*имя-соединения*:execute(*sql-оператор* [, *параметры*])"

#: ../doc/1.10/reference/reference_rock/dbms.rst:242
msgid ""
"where ``sql-statement`` is a string, and the optional ``parameters`` are "
"extra values that can be plugged in to replace any question marks "
"(\"?\"s) in the SQL statement."
msgstr ""
"где ``sql-statement`` -- это строка, а необязательные параметры -- это "
"дополнительные значения, которыми можно заменить любые знаки вопроса "
"(\"?\") в SQL-операторе."

#: ../doc/1.10/reference/reference_rock/dbms.rst:248
msgid ""
"tarantool> conn:execute('select table_name from "
"information_schema.tables')\n"
"---\n"
"- - table_name: ALL_PLUGINS\n"
"  - table_name: APPLICABLE_ROLES\n"
"  - table_name: CHARACTER_SETS\n"
"  <...>\n"
"- 78\n"
"..."
msgstr ""
"tarantool> conn:execute('select table_name from "
"information_schema.tables')\n"
"---\n"
"- - table_name: ALL_PLUGINS\n"
"  - table_name: APPLICABLE_ROLES\n"
"  - table_name: CHARACTER_SETS\n"
"  <...>\n"
"- 78\n"
"..."

#: ../doc/1.10/reference/reference_rock/dbms.rst:261
#: ../doc/1.10/reference/reference_rock/dbms.rst:602
msgid "Closing connection"
msgstr "Закрытие соединения"

#: ../doc/1.10/reference/reference_rock/dbms.rst:263
msgid "To end a session that began with ``mysql.connect``, the request is:"
msgstr ""
"Чтобы закрыть сессию, которую открыли с помощью ``mysql.connect``, "
"используется следующий запрос:"

#: ../doc/1.10/reference/reference_rock/dbms.rst:268
#: ../doc/1.10/reference/reference_rock/dbms.rst:609
msgid "*connection-name*:close()"
msgstr "*имя-соединения*:close()"

#: ../doc/1.10/reference/reference_rock/dbms.rst:272
#: ../doc/1.10/reference/reference_rock/dbms.rst:613
msgid ""
"tarantool> conn:close()\n"
"---\n"
"..."
msgstr ""
"tarantool> conn:close()\n"
"---\n"
"..."

#: ../doc/1.10/reference/reference_rock/dbms.rst:278
msgid ""
"For further information, including examples of rarely-used requests, see "
"the README.md file at `github.com/tarantool/mysql`_."
msgstr ""
"Для получения дополнительной информации, включая примеры редко "
"используемых запросов, см. файл README.md по ссылке "
"`github.com/tarantool/mysql`_."

#: ../doc/1.10/reference/reference_rock/dbms.rst:285
msgid ""
"The example was run on an Ubuntu 12.04 (\"precise\") machine where "
"tarantool had been installed in a /usr subdirectory, and a copy of MySQL "
"had been installed on ~/mysql-5.5. The mysqld server instance is already "
"running on the local host 127.0.0.1."
msgstr ""
"Пример выполняется на машине с ОС Ubuntu 12.04 (Precise Pangolin), где "
"Tarantool установлен в поддиректорию /usr, а копия MySQL установлена в "
"~/mysql-5.5. Экземпляр сервера mysqld уже запущен на localhost 127.0.0.1."

#: ../doc/1.10/reference/reference_rock/dbms.rst:289
msgid ""
"$ export TMDIR=~/mysql-5.5\n"
"$ # Check that the include subdirectory exists by looking\n"
"$ # for .../include/mysql.h. (If this fails, there's a chance\n"
"$ # that it's in .../include/mysql/mysql.h instead.)\n"
"$ [ -f $TMDIR/include/mysql.h ] && echo \"OK\" || echo \"Error\"\n"
"OK\n"
"\n"
"$ # Check that the library subdirectory exists and has the\n"
"$ # necessary .so file.\n"
"$ [ -f $TMDIR/lib/libmysqlclient.so ] && echo \"OK\" || echo \"Error\"\n"
"OK\n"
"\n"
"$ # Check that the mysql client can connect using some factory\n"
"$ # defaults: port = 3306, user = 'root', user password = '',\n"
"$ # database = 'test'. These can be changed, provided one uses\n"
"$ # the changed values in all places.\n"
"$ $TMDIR/bin/mysql --port=3306 -h 127.0.0.1 --user=root \\\n"
"    --password= --database=test\n"
"Welcome to the MySQL monitor.  Commands end with ; or \\g.\n"
"Your MySQL connection id is 25\n"
"Server version: 5.5.35 MySQL Community Server (GPL)\n"
"...\n"
"Type 'help;' or '\\h' for help. Type '\\c' to clear ...\n"
"\n"
"$ # Insert a row in database test, and quit.\n"
"mysql> CREATE TABLE IF NOT EXISTS test (s1 INT, s2 VARCHAR(50));\n"
"Query OK, 0 rows affected (0.13 sec)\n"
"mysql> INSERT INTO test.test VALUES (1,'MySQL row');\n"
"Query OK, 1 row affected (0.02 sec)\n"
"mysql> QUIT\n"
"Bye\n"
"\n"
"$ # Install luarocks\n"
"$ sudo apt-get -y install luarocks | grep -E \"Setting up|already\"\n"
"Setting up luarocks (2.0.8-2) ...\n"
"\n"
"$ # Set up the Tarantool rock list in ~/.luarocks,\n"
"$ # following instructions at rocks.tarantool.org\n"
"$ mkdir ~/.luarocks\n"
"$ echo \"rocks_servers = {[[http://rocks.tarantool.org/]]}\" >> \\\n"
"    ~/.luarocks/config.lua\n"
"\n"
"$ # Ensure that the next \"install\" will get files from Tarantool\n"
"$ # master repository. The resultant display is normal for Ubuntu\n"
"$ # 12.04 precise\n"
"$ cat /etc/apt/sources.list.d/tarantool.list\n"
"deb http://tarantool.org/dist/1.7/ubuntu/ precise main\n"
"deb-src http://tarantool.org/dist/1.7/ubuntu/ precise main\n"
"\n"
"$ # Install tarantool-dev. The displayed line should show version = 1.6\n"
"$ sudo apt-get -y install tarantool-dev | grep -E \"Setting up|already\"\n"
"Setting up tarantool-dev (1.6.6.222.g48b98bb~precise-1) ...\n"
"$\n"
"\n"
"$ # Use luarocks to install locally, that is, relative to $HOME\n"
"$ luarocks install mysql MYSQL_LIBDIR=/usr/local/mysql/lib --local\n"
"Installing http://rocks.tarantool.org/mysql-scm-1.rockspec...\n"
"... (more info about building the Tarantool/MySQL driver appears here)\n"
"mysql scm-1 is now built and installed in ~/.luarocks/\n"
"\n"
"$ # Ensure driver.so now has been created in a place\n"
"$ # tarantool will look at\n"
"$ find ~/.luarocks -name \"driver.so\"\n"
"~/.luarocks/lib/lua/5.1/mysql/driver.so\n"
"\n"
"$ # Change directory to a directory which can be used for\n"
"$ # temporary tests. For this example we assume that the name\n"
"$ # of this directory is /home/pgulutzan/tarantool_sandbox.\n"
"$ # (Change \"/home/pgulutzan\" to whatever is the user's actual\n"
"$ # home directory for the machine that's used for this test.)\n"
"$ cd /home/pgulutzan/tarantool_sandbox\n"
"\n"
"$ # Start the Tarantool server instance. Do not use a Lua initialization "
"file.\n"
"\n"
"$ tarantool\n"
"tarantool: version 1.7.0-222-g48b98bb\n"
"type 'help' for interactive help\n"
"tarantool>"
msgstr ""
"$ export TMDIR=~/mysql-5.5\n"
"$ # Проверьте, что создана поддиректория include, путем поиска\n"
"$ # .../include/mysql.h. (Если нет, то можно проверить\n"
"$ # .../include/mysql/mysql.h.)\n"
"$ [ -f $TMDIR/include/mysql.h ] && echo \"OK\" || echo \"Error\"\n"
"OK\n"
"\n"
"$ # Проверьте, что создана поддиректория library, а в ней\n"
"$ # необходимый файл .so.\n"
"$ [ -f $TMDIR/lib/libmysqlclient.so ] && echo \"OK\" || echo \"Error\"\n"
"OK\n"
"\n"
"$ # Проверьте, что mysql-клиент может подключиться, с помощью настроек\n"
"$ # по умолчанию: порт = 3306, пользователь = 'root', пароль пользователя"
" = '',\n"
"$ # база данных = 'test'. Эти настройки можно изменить, используя\n"
"$ # измененные значения.\n"
"$ $TMDIR/bin/mysql --port=3306 -h 127.0.0.1 --user=root \\\n"
"    --password= --database=test\n"
"Welcome to the MySQL monitor.  Commands end with ; or \\g.\n"
"Your MySQL connection id is 25\n"
"Server version: 5.5.35 MySQL Community Server (GPL)\n"
"...\n"
"Type 'help;' or '\\h' for help. Type '\\c' to clear ...\n"
"\n"
"$ # Вставьте строку в базу данных test и завершите работу.\n"
"mysql> CREATE TABLE IF NOT EXISTS test (s1 INT, s2 VARCHAR(50));\n"
"Query OK, 0 rows affected (0.13 sec)\n"
"mysql> INSERT INTO test.test VALUES (1,'MySQL row');\n"
"Query OK, 1 row affected (0.02 sec)\n"
"mysql> QUIT\n"
"Bye\n"
"\n"
"$ # Установите luarocks\n"
"$ sudo apt-get -y install luarocks | grep -E \"Setting up|already\"\n"
"Setting up luarocks (2.0.8-2) ...\n"
"\n"
"$ # Настройте список сторонних модулей Tarantool'а в ~/.luarocks,\n"
"$ # следуя инструкциям по ссылке rocks.tarantool.org\n"
"$ mkdir ~/.luarocks\n"
"$ echo \"rocks_servers = {[[http://rocks.tarantool.org/]]}\" >> \\\n"
"    ~/.luarocks/config.lua\n"
"\n"
"$ # Убедитесь, что при следующей установке будут использованы файлы из "
"главного\n"
"$ # хранилища Tarantool'а. Получаем результат, нормальный для Ubuntu\n"
"$ # 12.04 Precise Pangolin\n"
"$ cat /etc/apt/sources.list.d/tarantool.list\n"
"deb http://tarantool.org/dist/1.7/ubuntu/ precise main\n"
"deb-src http://tarantool.org/dist/1.7/ubuntu/ precise main\n"
"\n"
"$ # Установите tarantool-dev. Строка на экране должна показать версию 1.6"
"\n"
"$ sudo apt-get -y install tarantool-dev | grep -E \"Setting up|already\"\n"
"Setting up tarantool-dev (1.6.6.222.g48b98bb~precise-1) ...\n"
"$\n"
"\n"
"$ # Используйте luarocks для локальной установки, то есть в $HOME\n"
"$ luarocks install mysql MYSQL_LIBDIR=/usr/local/mysql/lib --local\n"
"Installing http://rocks.tarantool.org/mysql-scm-1.rockspec...\n"
"... (здесь будет еще информация о сборке драйвера Tarantool/MySQL)\n"
"mysql scm-1 is now built and installed in ~/.luarocks/\n"
"\n"
"$ # Убедитесь, что driver.so создан в месте,\n"
"$ # где Tarantool будет искать его\n"
"$ find ~/.luarocks -name \"driver.so\"\n"
"~/.luarocks/lib/lua/5.1/mysql/driver.so\n"
"\n"
"$ # Измените директорию на директорию, которую можно использовать для\n"
"$ # временного тестирования. В данном примере предполагаем, что имя\n"
"$ # этой директории будет /home/pgulutzan/tarantool_sandbox.\n"
"$ # (Измените \"/home/pgulutzan\" на фактическую корневую директорию\n"
"$ # пользователя машины, используемой для тестирования.)\n"
"$ cd /home/pgulutzan/tarantool_sandbox\n"
"\n"
"$ # Запустите экземпляр Tarantool-сервера. Не используйте файл "
"инициализации Lua.\n"
"\n"
"$ tarantool\n"
"tarantool: version 1.7.0-222-g48b98bb\n"
"type 'help' for interactive help\n"
"tarantool>"

#: ../doc/1.10/reference/reference_rock/dbms.rst:370
msgid ""
"Configure tarantool and load mysql module. Make sure that tarantool "
"doesn't reply \"error\" for the call to \"require()\"."
msgstr ""
"Настройте Tarantool и загрузите модуль mysql. Убедитесь, что Tarantool не"
" выбрасывает ошибку в ответ на вызов \"require()\"."

#: ../doc/1.10/reference/reference_rock/dbms.rst:373
msgid ""
"tarantool> box.cfg{}\n"
"...\n"
"tarantool> mysql = require('mysql')\n"
"---\n"
"..."
msgstr ""
"tarantool> box.cfg{}\n"
"...\n"
"tarantool> mysql = require('mysql')\n"
"---\n"
"..."

#: ../doc/1.10/reference/reference_rock/dbms.rst:381
msgid ""
"Create a Lua function that will connect to the MySQL server instance, "
"(using some factory default values for the port and user and password), "
"retrieve one row, and display the row. For explanations of the statement "
"types used here, read the Lua tutorial earlier in the Tarantool user "
"manual."
msgstr ""
"Создайте Lua-функцию, которая подключится к экземпляру MySQL-сервера "
"(используя значения по умолчанию для параметров порта, пользователя и "
"пароля), выберите одну строку и выведите ее на экран. Описание "
"используемых здесь типов операторов вы можете найти в практикуме по Lua в"
" руководстве пользователя Tarantool'а."

#: ../doc/1.10/reference/reference_rock/dbms.rst:386
msgid ""
"tarantool> function mysql_select ()\n"
"         >   local conn = mysql.connect({\n"
"         >     host = '127.0.0.1',\n"
"         >     port = 3306,\n"
"         >     user = 'root',\n"
"         >     db = 'test'\n"
"         >   })\n"
"         >   local test = conn:execute('SELECT * FROM test WHERE s1 = 1')"
"\n"
"         >   local row = ''\n"
"         >   for i, card in pairs(test) do\n"
"         >       row = row .. card.s2 .. ' '\n"
"         >       end\n"
"         >   conn:close()\n"
"         >   return row\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> mysql_select()\n"
"---\n"
"- 'MySQL row '\n"
"..."
msgstr ""
"tarantool> function mysql_select ()\n"
"         >   local conn = mysql.connect({\n"
"         >     host = '127.0.0.1',\n"
"         >     port = 3306,\n"
"         >     user = 'root',\n"
"         >     db = 'test'\n"
"         >   })\n"
"         >   local test = conn:execute('SELECT * FROM test WHERE s1 = 1')"
"\n"
"         >   local row = ''\n"
"         >   for i, card in pairs(test) do\n"
"         >       row = row .. card.s2 .. ' '\n"
"         >       end\n"
"         >   conn:close()\n"
"         >   return row\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> mysql_select()\n"
"---\n"
"- 'MySQL row '\n"
"..."

#: ../doc/1.10/reference/reference_rock/dbms.rst:410
msgid ""
"Observe the result. It contains \"MySQL row\". So this is the row that "
"was inserted into the MySQL database. And now it's been selected with the"
" Tarantool client."
msgstr ""
"Просмотрите результат. В нем есть строка \"MySQL row\". Это и есть "
"строка, которая была вставлена в базу данных MySQL. А сейчас она выделена"
" с помощью Tarantool-клиента."

#: ../doc/1.10/reference/reference_rock/dbms.rst:417
msgid "PostgreSQL Example"
msgstr "Пример для PostgreSQL "

#: ../doc/1.10/reference/reference_rock/dbms.rst:419
msgid ""
"This example assumes that PostgreSQL 8 or PostgreSQL 9 has been "
"installed. More recent versions should also work. The package that "
"matters most is the PostgreSQL developer package, typically named "
"something like libpq-dev. On Ubuntu this can be installed with:"
msgstr ""
"В данном примере предполагается, что установлены PostgreSQL 8 или "
"PostgreSQL 9. Более поздние версии  также должны сработать. Самым важным "
"пакетом будет пакет для разработчиков клиента PostgreSQL, который обычно "
"называется libpq-dev. На Ubuntu его можно установить следующим образом:"

#: ../doc/1.10/reference/reference_rock/dbms.rst:424
msgid "$ sudo apt-get install libpq-dev"
msgstr "$ sudo apt-get install libpq-dev"

#: ../doc/1.10/reference/reference_rock/dbms.rst:428
msgid ""
"However, because not all platforms are alike, for this example the "
"assumption is that the user must check that the appropriate PostgreSQL "
"files are present and must explicitly state where they are when building "
"the Tarantool/PostgreSQL driver. One can use ``find`` or ``whereis`` to "
"see what directories PostgreSQL files are installed in."
msgstr ""
"Однако, не все платформы одинаковы, поэтому в данном примере "
"предполагается, что пользователь должен проверить наличие нужных "
"PostgreSQL-файлов, а также явным образом прописать, где они находятся, "
"для сборки драйвера Tarantool/PostgreSQL. Для поиска директорий, где "
"установлены PostgreSQL-файлы, можно воспользоваться командами ``find`` "
"или ``whereis``."

#: ../doc/1.10/reference/reference_rock/dbms.rst:434
msgid ""
"It will be necessary to install Tarantool's PostgreSQL driver shared "
"library, load it, and use it to connect to a PostgreSQL server instance. "
"After that, one can pass any PostgreSQL statement to the server instance "
"and receive results."
msgstr ""
"Также нужно будет установить библиотеку общего пользования Tarantool'а с "
"драйвером для PostgreSQL, загрузить ее и использовать для подключения к "
"экземпляру PostgreSQL-сервера. После этого можно передавать любой "
"оператор PostgreSQL на экземпляр сервера и получать результаты."

#: ../doc/1.10/reference/reference_rock/dbms.rst:452
msgid ""
"Now, for the PostgreSQL driver shared library, there are two ways to "
"install:"
msgstr ""
"Что касается библиотеки общего пользования с драйвером для PostgreSQL, ее"
" можно установить двумя способами:"

#: ../doc/1.10/reference/reference_rock/dbms.rst:465
msgid ""
"luarocks install pg [POSTGRESQL_LIBDIR = *path*]\n"
"                    [POSTGRESQL_INCDIR = *path*]\n"
"                    [--local]"
msgstr ""
"luarocks install pg [POSTGRESQL_LIBDIR = *путь*]\n"
"                    [POSTGRESQL_INCDIR = *путь*]\n"
"                    [--local]"

#: ../doc/1.10/reference/reference_rock/dbms.rst:471
msgid "$ luarocks install pg POSTGRESQL_LIBDIR=/usr/local/postgresql/lib"
msgstr "$ luarocks install pg POSTGRESQL_LIBDIR=/usr/local/postgresql/lib"

#: ../doc/1.10/reference/reference_rock/dbms.rst:479
msgid ""
"Go the site `github.com/tarantool/pg`_. Follow the instructions there, "
"saying:"
msgstr ""
"Перейдите по ссылке `github.com/tarantool/pg`_. Следуя инструкциям, "
"введите команду:"

#: ../doc/1.10/reference/reference_rock/dbms.rst:481
msgid ""
"$ git clone https://github.com/tarantool/pg.git\n"
"$ cd pg && cmake . -DCMAKE_BUILD_TYPE=RelWithDebInfo\n"
"$ make\n"
"$ make install"
msgstr ""
"$ git clone https://github.com/tarantool/pg.git\n"
"$ cd pg && cmake . -DCMAKE_BUILD_TYPE=RelWithDebInfo\n"
"$ make\n"
"$ make install"

#: ../doc/1.10/reference/reference_rock/dbms.rst:496
msgid ""
"Begin by making a ``require`` request for the pg driver. We will assume "
"that the name is ``pg`` in further examples."
msgstr ""
"Начните с выполнения запроса ``require`` для драйвера pg. В дальнейших "
"примерах у него будет имя ``pg``."

#: ../doc/1.10/reference/reference_rock/dbms.rst:499
msgid "pg = require('pg')"
msgstr "pg = require('pg')"

#: ../doc/1.10/reference/reference_rock/dbms.rst:508
msgid "*connection_name* = pg.connect(*connection options*)"
msgstr "*имя_подключения* = pg.connect(*параметры подключения*)"

#: ../doc/1.10/reference/reference_rock/dbms.rst:513
msgid ":samp:`port = {port-number}` - number, default value = 5432"
msgstr ":samp:`port = {номер-порта}` -- число, значение по умолчанию = 5432"

#: ../doc/1.10/reference/reference_rock/dbms.rst:515
msgid ""
":samp:`pass = {password}` or :samp:`password = {password}` - string, "
"default value is blank"
msgstr ""
":samp:`pass = {пароль}` или :samp:`password = {пароль}` -- строка, по "
"умолчанию пустая"

#: ../doc/1.10/reference/reference_rock/dbms.rst:518
msgid "The names are similar to the names that PostgreSQL itself uses."
msgstr "Имена параметров похожи на имена, которые используются в PostgreSQL."

#: ../doc/1.10/reference/reference_rock/dbms.rst:522
msgid ""
"conn = pg.connect({\n"
"    host = '127.0.0.1',\n"
"    port = 5432,\n"
"    user = 'p',\n"
"    password = 'p',\n"
"    db = 'test'\n"
"})"
msgstr ""
"conn = pg.connect({\n"
"    host = '127.0.0.1',\n"
"    port = 5432,\n"
"    user = 'p',\n"
"    password = 'p',\n"
"    db = 'test'\n"
"})"

#: ../doc/1.10/reference/reference_rock/dbms.rst:534
msgid ""
"tarantool> function pg_connect()\n"
"         >   local p = {}\n"
"         >   p.host = 'widgets.com'\n"
"         >   p.db = 'test'\n"
"         >   p.user = 'postgres'\n"
"         >   p.password = 'postgres'\n"
"         >   local conn = pg.connect(p)\n"
"         >   return conn\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> conn = pg_connect()\n"
"---\n"
"..."
msgstr ""
"tarantool> function pg_connect()\n"
"         >   local p = {}\n"
"         >   p.host = 'widgets.com'\n"
"         >   p.db = 'test'\n"
"         >   p.user = 'postgres'\n"
"         >   p.password = 'postgres'\n"
"         >   local conn = pg.connect(p)\n"
"         >   return conn\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> conn = pg_connect()\n"
"---\n"
"..."

#: ../doc/1.10/reference/reference_rock/dbms.rst:577
msgid "For all PostgreSQL statements, the request is:"
msgstr "Для всех операторов PostgreSQL запрос будет:"

#: ../doc/1.10/reference/reference_rock/dbms.rst:584
msgid ""
"where ``sql-statement`` is a string, and the optional ``parameters`` are "
"extra values that can be plugged in to replace any placeholders ($1 $2 $3"
" etc.) in the SQL statement."
msgstr ""
"где ``sql-statement`` -- это строка, а необязательные параметры -- это "
"дополнительные значения, которыми можно заменить любые местозаполнители "
"($1 $2 $3 и т.д.) в SQL-операторе."

#: ../doc/1.10/reference/reference_rock/dbms.rst:590
msgid ""
"tarantool> conn:execute('select tablename from pg_tables')\n"
"---\n"
"- - tablename: pg_statistic\n"
"  - tablename: pg_type\n"
"  - tablename: pg_authid\n"
"  <...>\n"
"..."
msgstr ""
"tarantool> conn:execute('select tablename from pg_tables')\n"
"---\n"
"- - tablename: pg_statistic\n"
"  - tablename: pg_type\n"
"  - tablename: pg_authid\n"
"  <...>\n"
"..."

#: ../doc/1.10/reference/reference_rock/dbms.rst:604
msgid "To end a session that began with ``pg.connect``, the request is:"
msgstr ""
"Чтобы закрыть сессию, которую открыли с помощью ``pg.connect``, "
"используется следующий запрос:"

#: ../doc/1.10/reference/reference_rock/dbms.rst:619
msgid ""
"For further information, including examples of rarely-used requests, see "
"the README.md file at `github.com/tarantool/pg`_."
msgstr ""
"Для получения дополнительной информации, включая примеры редко "
"используемых запросов, см. файл README.md по ссылке "
"`github.com/tarantool/pg`_."

#: ../doc/1.10/reference/reference_rock/dbms.rst:626
msgid ""
"The example was run on an Ubuntu 12.04 (\"precise\") machine where "
"tarantool had been installed in a /usr subdirectory, and a copy of "
"PostgreSQL had been installed on /usr. The PostgreSQL server instance is "
"already running on the local host 127.0.0.1."
msgstr ""
"Пример выполняется на машине с ОС Ubuntu 12.04 (Precise Pangolin), где "
"Tarantool установлен в поддиректорию /usr, а копия PostgreSQL установлена"
" в /usr. Экземпляр сервера PostgreSQL уже запущен на localhost 127.0.0.1."

#: ../doc/1.10/reference/reference_rock/dbms.rst:630
msgid ""
"$ # Check that the include subdirectory exists\n"
"$ # by looking for /usr/include/postgresql/libpq-fe-h.\n"
"$ [ -f /usr/include/postgresql/libpq-fe.h ] && echo \"OK\" || echo "
"\"Error\"\n"
"OK\n"
"\n"
"$ # Check that the library subdirectory exists and has the necessary .so "
"file.\n"
"$ [ -f /usr/lib/x86_64-linux-gnu/libpq.so ] && echo \"OK\" || echo "
"\"Error\"\n"
"OK\n"
"\n"
"$ # Check that the psql client can connect using some factory defaults:\n"
"$ # port = 5432, user = 'postgres', user password = 'postgres',\n"
"$ # database = 'postgres'. These can be changed, provided one changes\n"
"$ # them in all places. Insert a row in database postgres, and quit.\n"
"$ psql -h 127.0.0.1 -p 5432 -U postgres -d postgres\n"
"Password for user postgres:\n"
"psql (9.3.10)\n"
"SSL connection (cipher: DHE-RSA-AES256-SHA, bits: 256)\n"
"Type \"help\" for help.\n"
"\n"
"postgres=# CREATE TABLE test (s1 INT, s2 VARCHAR(50));\n"
"CREATE TABLE\n"
"postgres=# INSERT INTO test VALUES (1,'PostgreSQL row');\n"
"INSERT 0 1\n"
"postgres=# \\q\n"
"$\n"
"\n"
"$ # Install luarocks\n"
"$ sudo apt-get -y install luarocks | grep -E \"Setting up|already\"\n"
"Setting up luarocks (2.0.8-2) ...\n"
"\n"
"$ # Set up the Tarantool rock list in ~/.luarocks,\n"
"$ # following instructions at rocks.tarantool.org\n"
"$ mkdir ~/.luarocks\n"
"$ echo \"rocks_servers = {[[http://rocks.tarantool.org/]]}\" >> \\\n"
"        ~/.luarocks/config.lua\n"
"\n"
"$ # Ensure that the next \"install\" will get files from Tarantool master"
"\n"
"$ # repository. The resultant display is normal for Ubuntu 12.04 precise\n"
"$ cat /etc/apt/sources.list.d/tarantool.list\n"
"deb http://tarantool.org/dist/1.7/ubuntu/ precise main\n"
"deb-src http://tarantool.org/dist/1.7/ubuntu/ precise main\n"
"\n"
"$ # Install tarantool-dev. The displayed line should show version = 1.7\n"
"$ sudo apt-get -y install tarantool-dev | grep -E \"Setting up|already\"\n"
"Setting up tarantool-dev (1.7.0.222.g48b98bb~precise-1) ...\n"
"$\n"
"\n"
"$ # Use luarocks to install locally, that is, relative to $HOME\n"
"$ luarocks install pg POSTGRESQL_LIBDIR=/usr/lib/x86_64-linux-gnu --local"
"\n"
"Installing http://rocks.tarantool.org/pg-scm-1.rockspec...\n"
"... (more info about building the Tarantool/PostgreSQL driver appears "
"here)\n"
"pg scm-1 is now built and installed in ~/.luarocks/\n"
"\n"
"$ # Ensure driver.so now has been created in a place\n"
"$ # tarantool will look at\n"
"$ find ~/.luarocks -name \"driver.so\"\n"
"~/.luarocks/lib/lua/5.1/pg/driver.so\n"
"\n"
"$ # Change directory to a directory which can be used for\n"
"$ # temporary tests. For this example we assume that the\n"
"$ # name of this directory is $HOME/tarantool_sandbox.\n"
"$ # (Change \"$HOME\" to whatever is the user's actual\n"
"$ # home directory for the machine that's used for this test.)\n"
"cd $HOME/tarantool_sandbox\n"
"\n"
"$ # Start the Tarantool server instance. Do not use a Lua initialization "
"file.\n"
"\n"
"$ tarantool\n"
"tarantool: version 1.7.0-412-g803b15c\n"
"type 'help' for interactive help\n"
"tarantool>"
msgstr ""
"$ # Проверьте, что создана поддиректория include, путем поиска\n"
"$ # /usr/include/postgresql/libpq-fe-h.\n"
"$ [ -f /usr/include/postgresql/libpq-fe.h ] && echo \"OK\" || echo "
"\"Error\"\n"
"OK\n"
"\n"
"$ # Проверьте, что создана поддиректория library, а в ней необходимый "
"файл .so.\n"
"$ [ -f /usr/lib/x86_64-linux-gnu/libpq.so ] && echo \"OK\" || echo "
"\"Error\"\n"
"OK\n"
"\n"
"$ # Проверьте, что psql-клиент может подключиться, с помощью настроек по "
"умолчанию:\n"
"$ # порт = 5432, пользователь = 'postgres', пароль пользователя = "
"'postgres',\n"
"$ # база данных = 'postgres'. Эти настройки можно изменить, используя\n"
"$ # измененные значения. Вставьте строку в базу данных postgres и "
"завершите работу.\n"
"$ psql -h 127.0.0.1 -p 5432 -U postgres -d postgres\n"
"Password for user postgres:\n"
"psql (9.3.10)\n"
"SSL connection (cipher: DHE-RSA-AES256-SHA, bits: 256)\n"
"Type \"help\" for help.\n"
"\n"
"postgres=# CREATE TABLE test (s1 INT, s2 VARCHAR(50));\n"
"CREATE TABLE\n"
"postgres=# INSERT INTO test VALUES (1,'PostgreSQL row');\n"
"INSERT 0 1\n"
"postgres=# \\q\n"
"$\n"
"\n"
"$ # Установите luarocks\n"
"$ sudo apt-get -y install luarocks | grep -E \"Setting up|already\"\n"
"Setting up luarocks (2.0.8-2) ...\n"
"\n"
"$ # Настройте список сторонних модулей Tarantool'а в ~/.luarocks,\n"
"$ # следуя инструкциям по ссылке rocks.tarantool.org\n"
"$ mkdir ~/.luarocks\n"
"$ echo \"rocks_servers = {[[http://rocks.tarantool.org/]]}\" >> \\\n"
"        ~/.luarocks/config.lua\n"
"\n"
"$ # Убедитесь, что при следующей установке будут использованы файлы из "
"главного\n"
"$ # хранилища Tarantool'а. Получаем результат, нормальный для Ubuntu "
"12.04 Precise Pangolin\n"
"$ cat /etc/apt/sources.list.d/tarantool.list\n"
"deb http://tarantool.org/dist/1.7/ubuntu/ precise main\n"
"deb-src http://tarantool.org/dist/1.7/ubuntu/ precise main\n"
"\n"
"$ # Установите tarantool-dev. Строка на экране должна показать версию 1.7"
"\n"
"$ sudo apt-get -y install tarantool-dev | grep -E \"Setting up|already\"\n"
"Setting up tarantool-dev (1.7.0.222.g48b98bb~precise-1) ...\n"
"$\n"
"\n"
"$ # Используйте luarocks для локальной установки, то есть в $HOME\n"
"$ luarocks install pg POSTGRESQL_LIBDIR=/usr/lib/x86_64-linux-gnu --local"
"\n"
"Installing http://rocks.tarantool.org/pg-scm-1.rockspec...\n"
"... (здесь будет еще информация о сборке драйвера Tarantool/PostgreSQL)\n"
"pg scm-1 is now built and installed in ~/.luarocks/\n"
"\n"
"$ # Убедитесь, что driver.so создан в месте,\n"
"$ # где Tarantool будет искать его\n"
"$ find ~/.luarocks -name \"driver.so\"\n"
"~/.luarocks/lib/lua/5.1/pg/driver.so\n"
"\n"
"$ # Измените директорию на директорию, которую можно использовать для\n"
"$ # временного тестирования. В данном примере предполагаем, что имя\n"
"$ # name этой директории будет $HOME/tarantool_sandbox.\n"
"$ # (Измените \"$HOME\" на фактическую корневую директорию\n"
"$ # машины, используемой для тестирования.)\n"
"cd $HOME/tarantool_sandbox\n"
"\n"
"$ # Запустите экземпляр Tarantool-сервера. Не используйте файл "
"инициализации Lua.\n"
"\n"
"$ tarantool\n"
"tarantool: version 1.7.0-412-g803b15c\n"
"type 'help' for interactive help\n"
"tarantool>"

#: ../doc/1.10/reference/reference_rock/dbms.rst:704
msgid ""
"Configure tarantool and load pg module. Make sure that tarantool doesn't "
"reply \"error\" for the call to \"require()\"."
msgstr ""
"Настройте Tarantool и загрузите модуль pg. Убедитесь, что Tarantool не "
"выбрасывает ошибку в ответ на вызов \"require()\"."

#: ../doc/1.10/reference/reference_rock/dbms.rst:707
msgid ""
"tarantool> box.cfg{}\n"
"...\n"
"tarantool> pg = require('pg')\n"
"---\n"
"..."
msgstr ""
"tarantool> box.cfg{}\n"
"...\n"
"tarantool> pg = require('pg')\n"
"---\n"
"..."

#: ../doc/1.10/reference/reference_rock/dbms.rst:715
msgid ""
"Create a Lua function that will connect to a PostgreSQL server, (using "
"some factory default values for the port and user and password), retrieve"
" one row, and display the row. For explanations of the statement types "
"used here, read the Lua tutorial earlier in the Tarantool user manual."
msgstr ""
"Создайте Lua-функцию, которая подключится к PostgreSQL-серверу (используя"
" значения по умолчанию для параметров порта, пользователя и пароля), "
"выберите одну строку и выведите ее на экран. Описание используемых здесь "
"типов операторов вы можете найти в практикуме по Lua в руководстве "
"пользователя Tarantool'а."

#: ../doc/1.10/reference/reference_rock/dbms.rst:720
msgid ""
"tarantool> function pg_select ()\n"
"         >   local conn = pg.connect({\n"
"         >     host = '127.0.0.1',\n"
"         >     port = 5432,\n"
"         >     user = 'postgres',\n"
"         >     password = 'postgres',\n"
"         >     db = 'postgres'\n"
"         >   })\n"
"         >   local test = conn:execute('SELECT * FROM test WHERE s1 = 1')"
"\n"
"         >   local row = ''\n"
"         >   for i, card in pairs(test) do\n"
"         >       row = row .. card.s2 .. ' '\n"
"         >       end\n"
"         >   conn:close()\n"
"         >   return row\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> pg_select()\n"
"---\n"
"- 'PostgreSQL row '\n"
"..."
msgstr ""
"tarantool> function pg_select ()\n"
"         >   local conn = pg.connect({\n"
"         >     host = '127.0.0.1',\n"
"         >     port = 5432,\n"
"         >     user = 'postgres',\n"
"         >     password = 'postgres',\n"
"         >     db = 'postgres'\n"
"         >   })\n"
"         >   local test = conn:execute('SELECT * FROM test WHERE s1 = 1')"
"\n"
"         >   local row = ''\n"
"         >   for i, card in pairs(test) do\n"
"         >       row = row .. card.s2 .. ' '\n"
"         >       end\n"
"         >   conn:close()\n"
"         >   return row\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> pg_select()\n"
"---\n"
"- 'PostgreSQL row '\n"
"..."

#: ../doc/1.10/reference/reference_rock/dbms.rst:745
msgid ""
"Observe the result. It contains \"PostgreSQL row\". So this is the row "
"that was inserted into the PostgreSQL database. And now it's been "
"selected with the Tarantool client."
msgstr ""
"Просмотрите результат. В нем есть строка \"PostgreSQL row\". Это и есть "
"строка, которая была вставлена в базу данных PostgreSQL. А сейчас она "
"выделена с помощью Tarantool-клиента."

#: ../doc/1.10/reference/reference_rock/expirationd.rst:39
msgid "Module `expirationd`"
msgstr "Модуль `expirationd`"

#: ../doc/1.10/reference/reference_rock/expirationd.rst:41
msgid ""
"For a commercial-grade example of a Lua rock that works with Tarantool, "
"let us look at the source code of ``expirationd``, which Tarantool "
"supplies on GitHub_ with an Artistic license. The ``expirationd.lua`` "
"program is lengthy (about 500 lines), so here we will only highlight the "
"matters that will be enhanced by studying the full source later."
msgstr ""
"Рассмотрим исходный код ``expirationd`` -- пример Lua-модуля для "
"промышленной эксплуатации, который работает с Tarantool'ом -- Tarantool "
"предоставляет его с лицензией Artistic на GitHub_. Программа "
"``expirationd.lua`` довольно объемная (около 500 строк), поэтому здесь мы"
" остановимся на пунктах, знания о которых можно расширить, позднее изучив"
" программу полностью."

#: ../doc/1.10/reference/reference_rock/expirationd.rst:47
msgid ""
"task.worker_fiber = fiber.create(worker_loop, task)\n"
"log.info(\"expiration: task %q restarted\", task.name)\n"
"...\n"
"fiber.sleep(expirationd.constants.check_interval)\n"
"..."
msgstr ""
"task.worker_fiber = fiber.create(worker_loop, task)\n"
"log.info(\"expiration: task %q restarted\", task.name)\n"
"...\n"
"fiber.sleep(expirationd.constants.check_interval)\n"
"..."

#: ../doc/1.10/reference/reference_rock/expirationd.rst:55
msgid ""
"Whenever one hears \"daemon\" in Tarantool, one should suspect it's being"
" done with a :doc:`fiber<../reference_lua/fiber>`. The program is making "
"a fiber and turning control over to it so it runs occasionally, goes to "
"sleep, then comes back for more."
msgstr ""
"Если в Tarantool'е упоминается \"демон\", то речь идет об использовании "
":doc:`файбера <../reference_lua/fiber>`. Программа создает файбер и "
"передает управление так, что он периодически запускается, уходит в режим "
"ожидания, а затем повторяет эти действия."

#: ../doc/1.10/reference/reference_rock/expirationd.rst:60
msgid ""
"for _, tuple in scan_space.index[0]:pairs(nil, {iterator = "
"box.index.ALL}) do\n"
"...\n"
"    expiration_process(task, tuple)\n"
"...\n"
"    /* expiration_process() contains:\n"
"    if task.is_tuple_expired(task.args, tuple) then\n"
"    task.expired_tuples_count = task.expired_tuples_count + 1\n"
"    task.process_expired_tuple(task.space_id, task.args, tuple) */"
msgstr ""
"for _, tuple in scan_space.index[0]:pairs(nil, {iterator = "
"box.index.ALL}) do\n"
"...\n"
"    expiration_process(task, tuple)\n"
"...\n"
"    /* expiration_process() contains:\n"
"    if task.is_tuple_expired(task.args, tuple) then\n"
"    task.expired_tuples_count = task.expired_tuples_count + 1\n"
"    task.process_expired_tuple(task.space_id, task.args, tuple) */"

#: ../doc/1.10/reference/reference_rock/expirationd.rst:71
msgid ""
"The \"for\" instruction can be translated as \"iterate through the index "
"of the space that is being scanned\", and within it, if the tuple is "
"\"expired\" (for example, if the tuple has a timestamp field which is "
"less than the current time), process the tuple as an expired tuple."
msgstr ""
"Команду \"for\" можно перевести как \"выполнить итерацию по индексу "
"сканируемого спейса\", а внутри -- если кортеж \"неактуален\" (например, "
"если в кортеже есть поле метки времени, которое меньше текущего времени),"
" то обработать кортеж как неактуальный кортеж."

#: ../doc/1.10/reference/reference_rock/expirationd.rst:76
msgid ""
"-- default process_expired_tuple function\n"
"local function default_tuple_drop(space_id, args, tuple)\n"
"    box.space[space_id]:delete(construct_key(space_id, tuple))\n"
"end\n"
"    /* construct_key() contains:\n"
"    local function construct_key(space_id, tuple)\n"
"        return fun.map(\n"
"            function(x) return tuple[x.fieldno] end,\n"
"           box.space[space_id].index[0].parts\n"
"        ):totable()\n"
"    end */"
msgstr ""
"-- функция обработки неактуального кортежа по умолчанию\n"
"local function default_tuple_drop(space_id, args, tuple)\n"
"    box.space[space_id]:delete(construct_key(space_id, tuple))\n"
"end\n"
"    /* construct_key() contains:\n"
"    local function construct_key(space_id, tuple)\n"
"        return fun.map(\n"
"            function(x) return tuple[x.fieldno] end,\n"
"           box.space[space_id].index[0].parts\n"
"        ):totable()\n"
"    end */"

#: ../doc/1.10/reference/reference_rock/expirationd.rst:90
msgid ""
"Ultimately the tuple-expiry process leads to ``default_tuple_drop()`` "
"which does a \"delete\" of a tuple from its original space. First the fun"
" :ref:`fun <fun-module>` module is used, specifically fun.map_. "
"Remembering that :codenormal:`index[0]` is always the space's primary "
"key, and "
":codenormal:`index[0].parts[`:codeitalic:`N`:codenormal:`].fieldno` is "
"always the field number for key part :codeitalic:`N`, fun.map() is "
"creating a table from the primary-key values of the tuple. The result of "
"fun.map() is passed to :ref:`space_object:delete() <box_space-delete>`."
msgstr ""
"В конечном итоге, обработка неактуального кортежа приводит к "
"``default_tuple_drop()``, что приводит к удалению кортежа из "
"первоначального спейса. Сначала используется модуль :ref:`fun <fun-"
"module>`, в частности fun.map_. Учитывая, что :codenormal:`index[0]` "
"всегда является первичным ключом спейса, а "
":codenormal:`index[0].parts[`:codeitalic:`N`:codenormal:`].fieldno` "
"всегда является номером поля для компонента ключа :codeitalic:`N`, "
"функция fun.map() создает таблицу из первичных значений кортежа. "
"Результат fun.map() передается в :ref:`space_object:delete() <box_space-"
"delete>`."

#: ../doc/1.10/reference/reference_rock/expirationd.rst:100
msgid ""
"local function expirationd_run_task(name, space_id, is_tuple_expired, "
"options)\n"
"..."
msgstr ""
"local function expirationd_run_task(name, space_id, is_tuple_expired, "
"options)\n"
"..."

#: ../doc/1.10/reference/reference_rock/expirationd.rst:105
msgid ""
"At this point, if the above explanation is worthwhile, it is clear that "
"``expirationd.lua`` starts a background routine (fiber) which iterates "
"through all the tuples in a space, sleeps cooperatively so that other "
"fibers can operate at the same time, and -- whenever it finds a tuple "
"that has expired -- deletes it from this space. Now the "
"\"``expirationd_run_task()``\" function can be used in a test which "
"creates sample data, lets the daemon run for a while, and prints results."
msgstr ""
"На этом этапе ясно, что ``expirationd.lua`` запускает фоновый процесс "
"(файбер), который выполняет итерацию по всем кортежам в спейсе, в рамках "
"кооперативной многозадачности уходит в режим ожидания, чтобы другие "
"файберы могли работать одновременно с ним, а когда находит неактуальный "
"кортеж, удаляет его из спейса. Теперь функцию "
"\"``expirationd_run_task()``\" можно использовать в тестировании, где "
"создаются образцы данных, некоторое время работает демон, и выводятся "
"результаты."

#: ../doc/1.10/reference/reference_rock/expirationd.rst:114
msgid ""
"For those who like to see things run, here are the exact steps to get "
"``expirationd`` through the test."
msgstr ""
"Если вы хотите увидеть, как все работает, обратите внимание на "
"нижеприведенные шаги по включению ``expirationd`` в тестирование."

#: ../doc/1.10/reference/reference_rock/expirationd.rst:117
msgid ""
"Get ``expirationd.lua``. There are standard ways -- it is after all part "
"of a `standard rock <https://luarocks.org/modules/rtsisyk/expirationd>`_ "
"-- but for this purpose just copy the contents of ``expirationd.lua`` to "
"a directory on the Lua path (type ``print(package.path)`` to see the Lua "
"path)."
msgstr ""
"Найдите ``expirationd.lua``. Можно воспользоваться стандартным способом, "
"поскольку модуль включен в общий список `модулей "
"<https://luarocks.org/modules/rtsisyk/expirationd>`_, но для этой цели "
"просто скопируйте содержимое ``expirationd.lua`` в директорию в Lua-пути "
"(введите ``print(package.path)``, чтобы увидеть Lua-путь)."

#: ../doc/1.10/reference/reference_rock/expirationd.rst:122
msgid "Start the Tarantool server as described before."
msgstr "Запустите Tarantool-сервер, как описано выше."

#: ../doc/1.10/reference/reference_rock/expirationd.rst:123
msgid "Execute these requests:"
msgstr "Выполните следующие запросы:"

#: ../doc/1.10/reference/reference_rock/expirationd.rst:125
msgid ""
"fiber = require('fiber')\n"
"expd = require('expirationd')\n"
"box.cfg{}\n"
"e = box.schema.space.create('expirationd_test')\n"
"e:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
"e:replace{1, fiber.time() + 3}\n"
"e:replace{2, fiber.time() + 30}\n"
"function is_tuple_expired(args, tuple)\n"
"  if (tuple[2] < fiber.time()) then return true end\n"
"  return false\n"
"  end\n"
"expd.run_task('expirationd_test', e.id, is_tuple_expired)\n"
"retval = {}\n"
"fiber.sleep(2)\n"
"expd.task_stats()\n"
"fiber.sleep(2)\n"
"expd.task_stats()\n"
"expd.kill_task('expirationd_test')\n"
"e:drop()\n"
"os.exit()"
msgstr ""
"fiber = require('fiber')\n"
"expd = require('expirationd')\n"
"box.cfg{}\n"
"e = box.schema.space.create('expirationd_test')\n"
"e:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
"e:replace{1, fiber.time() + 3}\n"
"e:replace{2, fiber.time() + 30}\n"
"function is_tuple_expired(args, tuple)\n"
"  if (tuple[2] < fiber.time()) then return true end\n"
"  return false\n"
"  end\n"
"expd.run_task('expirationd_test', e.id, is_tuple_expired)\n"
"retval = {}\n"
"fiber.sleep(2)\n"
"expd.task_stats()\n"
"fiber.sleep(2)\n"
"expd.task_stats()\n"
"expd.kill_task('expirationd_test')\n"
"e:drop()\n"
"os.exit()"

#: ../doc/1.10/reference/reference_rock/expirationd.rst:148
msgid ""
"The database-specific requests (``cfg``, :ref:`space.create <box_schema-"
"space_create>`, :ref:`create_index <box_space-create_index>`) should "
"already be familiar."
msgstr ""
"Запросы в работе с базой данных (``cfg``, :ref:`space.create <box_schema-"
"space_create>`, :ref:`create_index <box_space-create_index>`) уже должны "
"быть вам знакомы."

#: ../doc/1.10/reference/reference_rock/expirationd.rst:153
msgid ""
"The function which will be supplied to ``expirationd`` is "
":codenormal:`is_tuple_expired`, which is saying \"if the second field of "
"the tuple is less than the :ref:`current time <fiber-time>`  , then "
"return true, otherwise return false\"."
msgstr ""
"В ``expirationd`` передается функция :codenormal:`is_tuple_expired`, "
"которая задает следующее условие: если второе поле кортежа меньше "
":ref:`текущего времени <fiber-time>`  , вернуть true (правда), в "
"противном случае, вернуть false (ложь)."

#: ../doc/1.10/reference/reference_rock/expirationd.rst:158
msgid ""
"The key for getting the rock rolling is ``expd = "
"require('expirationd')``. The require_ function is what reads in the "
"program; it will appear in many later examples in this manual, when it's "
"necessary to get a module that's not part of the Tarantool kernel, but is"
" on the Lua path (``package.path``) or the C path (``package.cpath``). "
"After the Lua variable expd has been assigned the value of the "
"``expirationd`` module, it's possible to invoke the module's "
"``run_task()`` function."
msgstr ""
"Ключ к запуску модуля -- ``expd = require('expirationd')``. Функция "
"require_ -- это именно то, что выполняет чтение в программе. Она появится"
" и в дальнейших примерах в данном руководстве, когда будет необходимо "
"запустить модуль, который не входит в ядро Tarantool'а, но находится в "
"Lua-пути (``package.path``) или же C-пути (``package.cpath``). После "
"того, как Lua-переменной expd присваивается значение модуля "
"``expirationd``, можно вызвать функцию модуля ``run_task()``."

#: ../doc/1.10/reference/reference_rock/expirationd.rst:167
msgid ""
"After :ref:`sleeping <fiber-sleep>` for two seconds, when the task has "
"had time to do its iterations through the spaces, ``expd.task_stats()`` "
"will print out a report showing how many tuples have expired -- "
"\"expired_count: 0\"."
msgstr ""
"После ухода :ref:`в режим ожидания <fiber-sleep>` на две секунды, когда "
"проводится итерация по спейсам, ``expd.task_stats()`` выведет отчет о "
"количестве неактуальных кортежей -- \"expired_count: 0\"."

#: ../doc/1.10/reference/reference_rock/expirationd.rst:172
msgid ""
"After sleeping for two more seconds, ``expd.task_stats()`` will print out"
" a report showing how many tuples have expired -- \"expired_count: 1\". "
"This shows that the ``is_tuple_expired()`` function eventually returned "
"\"true\" for one of the tuples, because its timestamp field was more than"
" three seconds old."
msgstr ""
"После ожидания в течение еще двух секунд ``expd.task_stats()`` выведет "
"отчет о количестве неактуальных кортежей -- \"expired_count: 1\". Это "
"показывает, что функция ``is_tuple_expired()`` с течением времени вернула"
" \"true\" для одного из кортежей, поскольку поле метки времени было "
"дольше трех секунд."

#: ../doc/1.10/reference/reference_rock/expirationd.rst:179
msgid ""
"Of course, ``expirationd`` can be customized to do different things by "
"passing different parameters, which will be evident after looking in more"
" detail at the source code. Particularly important are ``{options}`` "
"which can be added as a final parameter in ``expirationd.run_task``:"
msgstr ""
"Конечно, ``expirationd`` можно настроить на выполнение различных задач с "
"помощью разных параметров, что будет очевидно после более детального "
"изучения исходного кода. В частности, важны опции ``{options}``, которые "
"можно добавить в качестве последнего параметра в "
"``expirationd.run_task``:"

#: ../doc/1.10/reference/reference_rock/expirationd.rst:184
msgid ""
"``force`` (boolean) -- run task even on replica. Default: ``force=false``"
" so ordinarily ``expirationd`` ignores replicas."
msgstr ""
"``force`` (логическое значение) -- выполнение задачи даже на реплике. По "
"умолчанию: ``force=false``, поэтому, как правило, ``expirationd`` не "
"учитывает реплики."

#: ../doc/1.10/reference/reference_rock/expirationd.rst:186
msgid ""
"``tuples_per_iteration`` (integer) -- number of tuples that will be "
"checked by one iteration Default: ``tuples_per_iteration=1024``."
msgstr ""
"``tuples_per_iteration`` (целое число) -- количество кортежей, которые "
"проверяются за одну итерацию. По умолчанию: "
"``tuples_per_iteration=1024``."

#: ../doc/1.10/reference/reference_rock/expirationd.rst:189
msgid ""
"``full_scan_time`` (number) -- number of seconds required for full index "
"scan Default: ``full_scan_time=3600``."
msgstr ""
"``full_scan_time`` (число) -- число секунд на полное сканирование диска. "
"По умолчанию: ``full_scan_time=3600``."

#: ../doc/1.10/reference/reference_rock/expirationd.rst:191
msgid ""
"``vinyl_assumed_space_len`` (integer) -- assumed size of vinyl space, for"
" the first iteration only. Default: ``vinyl_assumed_space_len=10000000``."
msgstr ""
"``vinyl_assumed_space_len`` (целое число) -- предполагаемый размер спейса"
" vinyl'а, используется только для первой итерации. По умолчанию: "
"``vinyl_assumed_space_len=10000000``."

#: ../doc/1.10/reference/reference_rock/expirationd.rst:194
msgid ""
"``vinyl_assumed_space_len_factor`` (integer) -- factor for recalculation "
"of size of vinyl space. Default: ``vinyl_assumed_space_len_factor=2``. "
"(The size of a vinyl space cannot be easily calculated, so on the first "
"iteration it will be the \"assumed\" size, on the second iteration it "
"will be \"assumed\" times \"factor\", on the third iteration it will be "
"\"assumed\" times \"factor\" times factor\", and so on.)"
msgstr ""
"``vinyl_assumed_space_len_factor`` (целое число) -- коэффициент "
"перерасчета размера спейса vinyl'а. По умолчанию: "
"``vinyl_assumed_space_len_factor=2``. (Размер спейса vinyl'а не так легко"
" рассчитать, поэтому для первой итерации используется \"предполагаемый\" "
"размер, на второй итерации -- \"предполагаемый\" размер, помноженный на "
"\"коэффициент\", на третьей итерации -- \"предполагаемый\" размер, дважды"
" помноженный на \"коэффициент\" и так далее.)"

#: ../doc/1.10/reference/reference_rock/index.rst:37
msgid "Rocks reference"
msgstr "Справочник по сторонним библиотекам"

#: ../doc/1.10/reference/reference_rock/index.rst:39
msgid "This reference covers third-party Lua modules for Tarantool."
msgstr "В данном справочнике описаны сторонние Lua-модули для Tarantool'а."

#: ../doc/1.10/reference/reference_rock/shard.rst:39
msgid "Module `shard`"
msgstr "Модуль `shard`"

#: ../doc/1.10/reference/reference_rock/shard.rst:43
msgid ""
"With sharding, the tuples of a tuple set are distributed to multiple "
"nodes, with a Tarantool database server instance on each node. With this "
"arrangement, each instance is handling only a subset of the total data, "
"so larger loads can be handled by simply adding more computers to a "
"network."
msgstr ""
"Во время шардинга кортежи из набора кортежей распределяются по нескольким"
" узлам, на каждом из которых есть экземпляр сервера базы данных "
"Tarantool'а. При таком распределении каждый экземпляр обрабатывает только"
" подмножество общих данных, поэтому появляется возможность обрабатывать "
"данные при больших нагрузках путем простого добавления большего "
"количества компьютеров в сеть."

#: ../doc/1.10/reference/reference_rock/shard.rst:48
msgid ""
"The Tarantool `shard` module has facilities for creating shards, as well "
"as analogues for the data-manipulation functions of the box library "
"(select, insert, replace, update, delete)."
msgstr ""
"Модуль Tarantool'а `shard` позволяет создавать шарды, а также аналоги "
"функций по управлению данными из библиотеки box (select, insert, replace,"
" update, delete)."

#: ../doc/1.10/reference/reference_rock/shard.rst:52
msgid "First some terminology:"
msgstr "Для начала введем терминологию:"

#: ../doc/1.10/reference/reference_rock/shard.rst:55
msgid "**Consistent hash**"
msgstr "**Консистентное хеширование**"

#: ../doc/1.10/reference/reference_rock/shard.rst:57
msgid ""
"The `shard` module distributes according to a hash algorithm, that is, it"
" applies a hash function to a tuple's primary-key value in order to "
"decide which shard the tuple belongs to. The hash function is `consistent"
" <https://en.wikipedia.org/wiki/Consistent_hashing>`_ so that changing "
"the number of servers will not affect results for many keys. The specific"
" hash function that the `shard` module uses is :ref:`digest.guava "
"<digest-guava>` in the :codeitalic:`digest` module."
msgstr ""
"Модуль `shard` распределяет данные в соответствии с алгоритмом "
"хеширования, то есть применяет хеш-функцию к значению первичного ключа "
"кортежа, что определить к какому шарду относится кортеж. Хеш-функция "
"является `консистентной "
"<https://en.wikipedia.org/wiki/Consistent_hashing>`_, поэтому изменение "
"количества серверов не повлияет на результат для множества ключей. Модуль"
" `shard` использует специальную хеш-функцию :ref:`digest.guava <digest-"
"guava>` из модуля :codeitalic:`digest`."

#: ../doc/1.10/reference/reference_rock/shard.rst:64
msgid "**Instance**"
msgstr "**Экземпляр**"

#: ../doc/1.10/reference/reference_rock/shard.rst:66
msgid ""
"A currently-running in-memory copy of the Tarantool server, sometimes "
"called a \"server instance\". Usually each shard is associated with one "
"instance, or, if both sharding and replicating are going on, each shard "
"is associated with one replica set."
msgstr ""
"Запущенная in-memory копия Tarantool-сервера иногда называется "
"экземпляром сервера. Как правило, каждый шард ассоциирован с одним "
"экземпляром, или же, если выполняется и шардинг, и репликация, каждый "
"шард ассоциирован с одним набором реплик."

#: ../doc/1.10/reference/reference_rock/shard.rst:70
msgid "**Queue**"
msgstr "**Очередь**"

#: ../doc/1.10/reference/reference_rock/shard.rst:72
msgid ""
"A temporary list of recent update requests. Sometimes called "
"\"batching\". Since updates to a sharded database can be slow, it may "
"speed up throughput to send requests to a queue rather than wait for the "
"update to finish on every node. The `shard` module has functions for "
"adding requests to the queue, which it will process without further "
"intervention. Queuing is optional."
msgstr ""
"Временный список последних запросов обновления. Иногда называется "
"\"пакетная обработка\". Поскольку обновления в базу данных с шардингом "
"могут быть замедлены, ускорить выполнение можно путем отправки запросов в"
" очередь вместо ожидания окончания обновления на каждом узле. В модуле "
"`shard` присутствуют функции для добавления запросов в очередь, которые "
"будут затем обработаны без дополнительных действий. Использование очереди"
" необязательно."

#: ../doc/1.10/reference/reference_rock/shard.rst:78
msgid "**Redundancy**"
msgstr "**Резервирование по принципу избыточности**"

#: ../doc/1.10/reference/reference_rock/shard.rst:80
msgid "The number of replicated data copies in each shard."
msgstr "Количество копий реплицируемых данных в каждом шарде."

#: ../doc/1.10/reference/reference_rock/shard.rst:81
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:2122
msgid "**Replica**"
msgstr "**Реплика**"

#: ../doc/1.10/reference/reference_rock/shard.rst:83
msgid "An instance which is part of a replica set."
msgstr "Экземпляр, который входит в набор реплик."

#: ../doc/1.10/reference/reference_rock/shard.rst:84
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:2111
msgid "**Replica set**"
msgstr "**Набор реплик**"

#: ../doc/1.10/reference/reference_rock/shard.rst:86
msgid ""
"Often a single shard is associated with a single instance; however, often"
" the shard is replicated. When a shard is replicated, the multiple "
"instances (\"replicas\"), which handle the shard's replicated data, are a"
" \"replica set\"."
msgstr ""
"Часто отдельный шард ассоциирован с отдельным экземпляром. Однако, часто "
"шард реплицируется. Когда шард реплицируется, множество экземпляров "
"(\"реплики\"), которые обрабатывают реплицируемые данные шарда, "
"составляют \"набор реплик\"."

#: ../doc/1.10/reference/reference_rock/shard.rst:90
msgid "**Replicated data**"
msgstr "**Реплицируемые данные**"

#: ../doc/1.10/reference/reference_rock/shard.rst:92
msgid ""
"A complete copy of the data. The `shard` module handles both sharding and"
" replication. One shard can contain one or more replicated data copies. "
"When a write occurs, the write is attempted on every replicated data copy"
" in turn. The `shard` module does not use the built-in replication "
"feature."
msgstr ""
"Полная копия данных. Модуль `shard` обрабатывает как шардинг, так и "
"репликацию. Один шард может содержать одну или несколько копий "
"реплицируемых данных. Попытки записи производятся по очереди на каждую "
"копию реплицируемых данных. Модуль `shard` не использует встроенную "
"функцию репликации."

#: ../doc/1.10/reference/reference_rock/shard.rst:96
msgid "**Shard**"
msgstr "**Шард**"

#: ../doc/1.10/reference/reference_rock/shard.rst:98
msgid ""
"A subset of the tuples in the database partitioned according to the value"
" returned by the consistent hash function. Usually each shard is on a "
"separate node, or a separate set of nodes (for example if redundancy = 3 "
"then the shard will be on three nodes)."
msgstr ""
"Подмножество кортежей в базе данных, разделенное по значению, которое "
"возвращает консистентная хеш-функция. Как правило, каждый шард находится "
"на отдельном узле или отдельном наборе узлов (например, если "
"резервирование = 3, то шард будет на трех узлах)."

#: ../doc/1.10/reference/reference_rock/shard.rst:102
msgid "**Zone**"
msgstr "**Зона**"

#: ../doc/1.10/reference/reference_rock/shard.rst:104
msgid ""
"A physical location where the nodes are closely connected, with the same "
"security and backup and access points. The simplest example of a zone is "
"a single computer with a single Tarantool-server instance. A shard's "
"replicated data copies should be in different zones."
msgstr ""
"Физическое местоположение, где узлы тесно связаны, с одинаковыми точками "
"безопасности, резервного копирования и доступа. Простейшим примером зоны "
"является один компьютер с одним экземпляром Tarantool-сервера. Копии "
"реплицируемых данных на шарде должны находиться в разных зонах."

#: ../doc/1.10/reference/reference_rock/shard.rst:109
msgid ""
"The `shard` package is distributed separately from the main `tarantool` "
"package. To acquire it, do a separate installation:"
msgstr ""
"Пакет `shard` распространяется отдельно от основного пакета `Tarantool`. "
"Для работы с ним выполните установку отдельно:"

#: ../doc/1.10/reference/reference_rock/shard.rst:112
msgid "with Tarantool 1.7.4+, say:"
msgstr "либо на версии Tarantool'а 1.7.4+ выполните команду:"

#: ../doc/1.10/reference/reference_rock/shard.rst:114
msgid "$ tarantoolctl rocks install shard"
msgstr "$ tarantoolctl rocks install shard"

#: ../doc/1.10/reference/reference_rock/shard.rst:118
msgid "install with `yum` or `apt`, for example on Ubuntu say:"
msgstr ""
"либо установите с помощью `yum` или `apt`, например, на Ubuntu выполните "
"команду:"

#: ../doc/1.10/reference/reference_rock/shard.rst:124
msgid ""
"or download from GitHub `tarantool/shard` and use the Lua files as "
"described in the `README <https://github.com/tarantool/shard>`_."
msgstr ""
"либо скачайте из GitHub `tarantool/shard` и используйте Lua-файлы, как "
"описано в файле `README <https://github.com/tarantool/shard>`_."

#: ../doc/1.10/reference/reference_rock/shard.rst:127
msgid "Then, before using the module, say ``shard = require('shard')``."
msgstr ""
"Затем перед использованием модуля выполните команду ``shard = "
"require('shard')``."

#: ../doc/1.10/reference/reference_rock/shard.rst:129
msgid "The most important function is:"
msgstr "Самой необходимой функцией модуля является"

#: ../doc/1.10/reference/reference_rock/shard.rst:134
msgid "shard.init(*shard-configuration*)"
msgstr "shard.init(*настройка-шарда*)"

#: ../doc/1.10/reference/reference_rock/shard.rst:136
msgid "This must be called for every shard."
msgstr "Ее следует вызывать для каждого шарда."

#: ../doc/1.10/reference/reference_rock/shard.rst:138
msgid "The shard configuration is a table with these fields:"
msgstr "Настройка шарда представляет собой таблицу со следующими полями:"

#: ../doc/1.10/reference/reference_rock/shard.rst:140
msgid "`servers` (a list of URIs of nodes and the zones the nodes are in)"
msgstr ""
"`servers` -- серверы, т.е. список URI узлов и зон, в которых находятся "
"узлы"

#: ../doc/1.10/reference/reference_rock/shard.rst:141
msgid "`login` (the user name which applies for accessing via the `shard` module)"
msgstr ""
"`login` -- имя пользователя, которое используется для доступа по модулю "
"`shard`"

#: ../doc/1.10/reference/reference_rock/shard.rst:142
msgid "`password` (the password for the login)"
msgstr "`password` -- пароль для имени пользователя"

#: ../doc/1.10/reference/reference_rock/shard.rst:143
msgid "`redundancy` (a number, minimum 1)"
msgstr "`redundancy` -- резервирование, число, минимум 1"

#: ../doc/1.10/reference/reference_rock/shard.rst:144
msgid ""
"`binary` (a port number that this host is listening on, on the current "
"host, (distinguishable from the 'listen' port specified by `box.cfg`)"
msgstr ""
"`binary` -- номер порта, на котором настроено прослушивание для текущего "
"хоста (отличный от порта 'listen', который определяет `box.cfg`)"

#: ../doc/1.10/reference/reference_rock/shard.rst:147
msgid "Possible errors:"
msgstr "Возможные ошибки:"

#: ../doc/1.10/reference/reference_rock/shard.rst:149
msgid "redundancy should not be greater than the number of servers;"
msgstr ""
"значение параметра redundancy (резервирование) не должно быть больше "
"количества серверов;"

#: ../doc/1.10/reference/reference_rock/shard.rst:150
msgid "the servers must be alive;"
msgstr "серверы должны быть рабочими;"

#: ../doc/1.10/reference/reference_rock/shard.rst:151
msgid ""
"two replicated data copies of the same shard should not be in the same "
"zone."
msgstr ""
"две копии реплицируемых данных одного шарда не должны находиться в одной "
"зоне."

#: ../doc/1.10/reference/reference_rock/shard.rst:155
msgid "Example: `shard.init` syntax for one shard"
msgstr "Пример: синтаксис `shard.init` для одного шарда"

#: ../doc/1.10/reference/reference_rock/shard.rst:157
msgid "The number of replicated data copies per shard (redundancy) is 3."
msgstr ""
"Количество копий реплицируемых данных на один шард (redundancy -- "
"резервирование) равно 3."

#: ../doc/1.10/reference/reference_rock/shard.rst:158
msgid "The number of instances is 3."
msgstr "Количество экземпляров равно 3."

#: ../doc/1.10/reference/reference_rock/shard.rst:159
msgid "The `shard` module will conclude that there is only one shard."
msgstr "Модуль `shard` делает вывод, что существует только один шард."

#: ../doc/1.10/reference/reference_rock/shard.rst:161
msgid ""
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'localhost:33131', zone = '1' },\n"
"         >     { uri = 'localhost:33132', zone = '2' },\n"
"         >     { uri = 'localhost:33133', zone = '3' }\n"
"         >   },\n"
"         >   login = 'test_user',\n"
"         >   password = 'pass',\n"
"         >   redundancy = '3',\n"
"         >   binary = 33131,\n"
"         > }\n"
"---\n"
"...\n"
"tarantool> shard.init(cfg)\n"
"---\n"
"..."
msgstr ""
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'localhost:33131', zone = '1' },\n"
"         >     { uri = 'localhost:33132', zone = '2' },\n"
"         >     { uri = 'localhost:33133', zone = '3' }\n"
"         >   },\n"
"         >   login = 'test_user',\n"
"         >   password = 'pass',\n"
"         >   redundancy = '3',\n"
"         >   binary = 33131,\n"
"         > }\n"
"---\n"
"...\n"
"tarantool> shard.init(cfg)\n"
"---\n"
"..."

#: ../doc/1.10/reference/reference_rock/shard.rst:182
msgid "Example: `shard.init` syntax for three shards"
msgstr "Пример: синтаксис `shard.init` для трех шардов"

#: ../doc/1.10/reference/reference_rock/shard.rst:184
msgid ""
"This describes three shards. Each shard has two replicated data copies. "
"Since the number of servers is 7, and the number of replicated data "
"copies per shard is 2, and dividing 7 / 2 leaves a remainder of 1, one of"
" the servers will not be used. This is not necessarily an error, because "
"perhaps one of the servers in the list is not alive."
msgstr ""
"Здесь описаны три шарда. Каждый шард содержит две копии реплицируемых "
"данных. Поскольку количество серверов равно 7, количество копий "
"реплицируемых данных на один шард равно 2, а деление 7 на 2 дает в "
"остатке 1, -- один из серверов не будет использоваться. Это необязательно"
" должно быть ошибкой, поскольку один из серверов может быть нерабочим."

#: ../doc/1.10/reference/reference_rock/shard.rst:189
msgid ""
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'host1:33131', zone = '1' },\n"
"         >     { uri = 'host2:33131', zone = '2' },\n"
"         >     { uri = 'host3:33131', zone = '3' },\n"
"         >     { uri = 'host4:33131', zone = '4' },\n"
"         >     { uri = 'host5:33131', zone = '5' },\n"
"         >     { uri = 'host6:33131', zone = '6' },\n"
"         >     { uri = 'host7:33131', zone = '7' }\n"
"         >   },\n"
"         >   login = 'test_user',\n"
"         >   password = 'pass',\n"
"         >   redundancy = '2',\n"
"         >   binary = 33131,\n"
"         > }\n"
"---\n"
"...\n"
"tarantool> shard.init(cfg)\n"
"---\n"
"..."
msgstr ""
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'host1:33131', zone = '1' },\n"
"         >     { uri = 'host2:33131', zone = '2' },\n"
"         >     { uri = 'host3:33131', zone = '3' },\n"
"         >     { uri = 'host4:33131', zone = '4' },\n"
"         >     { uri = 'host5:33131', zone = '5' },\n"
"         >     { uri = 'host6:33131', zone = '6' },\n"
"         >     { uri = 'host7:33131', zone = '7' }\n"
"         >   },\n"
"         >   login = 'test_user',\n"
"         >   password = 'pass',\n"
"         >   redundancy = '2',\n"
"         >   binary = 33131,\n"
"         > }\n"
"---\n"
"...\n"
"tarantool> shard.init(cfg)\n"
"---\n"
"..."

#: ../doc/1.10/reference/reference_rock/shard.rst:212
msgid ""
"Every data-access function in the `box` module has an analogue in the "
"`shard` module:"
msgstr ""
"Каждой функции взаимодействия с данными модуля `box` соответствует "
"функция в модуле `shard`:"

#: ../doc/1.10/reference/reference_rock/shard.rst:218
msgid ""
"shard[*space-name*].insert{...}\n"
"shard[*space-name*].replace{...}\n"
"shard[*space-name*].delete{...}\n"
"shard[*space-name*].select{...}\n"
"shard[*space-name*].update{...}\n"
"shard[*space-name*].auto_increment{...}"
msgstr ""
"shard[*имя-спейса*].insert{...}\n"
"shard[*имя-спейса*].replace{...}\n"
"shard[*имя-спейса*].delete{...}\n"
"shard[*имя-спейса*].select{...}\n"
"shard[*имя-спейса*].update{...}\n"
"shard[*имя-спейса*].auto_increment{...}"

#: ../doc/1.10/reference/reference_rock/shard.rst:225
msgid ""
"For example, to insert in table T in a sharded database you simply say "
"``shard.T:insert{...}`` instead of ``box.space.T:insert{...}``."
msgstr ""
"Например, чтобы выполнить вставку в таблицу T в базе данных с шардингом, "
"просто выполните команду ``shard.T:insert{...}`` вместо "
"``box.space.T:insert{...}``."

#: ../doc/1.10/reference/reference_rock/shard.rst:228
msgid "A ``shard.T:select{}`` request without a primary key will cause an error."
msgstr "Запрос ``shard.T:select{}`` без первичного ключа вызовет ошибку."

#: ../doc/1.10/reference/reference_rock/shard.rst:230
msgid "Every queued data-access function has an analogue in the `shard` module:"
msgstr ""
"Каждой функции модуля `box` для взаимодействия с данными, поставленной в "
"очередь, соответствует функция в модуле `shard`:"

#: ../doc/1.10/reference/reference_rock/shard.rst:235
msgid ""
"shard[*space-name*].q_insert{...}\n"
"shard[*space-name*].q_replace{...}\n"
"shard[*space-name*].q_delete{...}\n"
"shard[*space-name*].q_select{...}\n"
"shard[*space-name*].q_update{...}\n"
"shard[*space-name*].q_auto_increment{...}"
msgstr ""
"shard[*имя-спейса*].q_insert{...}\n"
"shard[*имя-спейса*].q_replace{...}\n"
"shard[*имя-спейса*].q_delete{...}\n"
"shard[*имя-спейса*].q_select{...}\n"
"shard[*имя-спейса*].q_update{...}\n"
"shard[*имя-спейса*].q_auto_increment{...}"

#: ../doc/1.10/reference/reference_rock/shard.rst:242
msgid ""
"The user must add an `operation_id`. For details of queued data-access "
"functions, and of maintenance-related functions, see the `README "
"<https://github.com/tarantool/shard>`_."
msgstr ""
"Пользователь должен добавить `operation_id`. Чтобы получить "
"дополнительную информацию о функциях для взаимодействия с данными, "
"поставленными в очередь, и о функциях, предназначенных для обслуживания, "
"см. файл `README <https://github.com/tarantool/shard>`_."

#: ../doc/1.10/reference/reference_rock/shard.rst:248
msgid "Example: shard, minimal configuration"
msgstr "Пример: шард, минимальная настройка"

#: ../doc/1.10/reference/reference_rock/shard.rst:250
msgid ""
"There is only one shard, and that shard contains only one replicated data"
" copy. So this isn't illustrating the features of either replication or "
"sharding, it's only illustrating what the syntax is, and what the "
"messages look like, that anyone could duplicate in a minute or two with "
"the magic of cut-and-paste."
msgstr ""
"Создан только один шард, который содержит только одну копию реплицируемых"
" данных. Таким образом, данный пример не иллюстрирует возможности "
"репликации или шардинга, он показывает синтаксис и отображаемые "
"сообщения, что каждый может повторить за пару минут лишь с помощью "
"вырезания и вставки."

#: ../doc/1.10/reference/reference_rock/shard.rst:256
msgid ""
"$ mkdir ~/tarantool_sandbox_1\n"
"$ cd ~/tarantool_sandbox_1\n"
"$ rm -r *.snap\n"
"$ rm -r *.xlog\n"
"$ ~/tarantool-1.7/src/tarantool\n"
"\n"
"tarantool> box.cfg{listen = 3301}\n"
"tarantool> box.schema.space.create('tester')\n"
"tarantool> box.space.tester:create_index('primary', {})\n"
"tarantool> box.schema.user.create('test_user', {password = 'pass'})\n"
"tarantool> box.schema.user.grant('test_user', 'read,write,execute', "
"'universe')\n"
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >       { uri = 'localhost:3301', zone = '1' },\n"
"         >   },\n"
"         >   login = 'test_user';\n"
"         >   password = 'pass';\n"
"         >   redundancy = 1;\n"
"         >   binary = 3301;\n"
"         > }\n"
"tarantool> shard = require('shard')\n"
"tarantool> shard.init(cfg)\n"
"tarantool> -- Now put something in ...\n"
"tarantool> shard.tester:insert{1,'Tuple #1'}"
msgstr ""
"$ mkdir ~/tarantool_sandbox_1\n"
"$ cd ~/tarantool_sandbox_1\n"
"$ rm -r *.snap\n"
"$ rm -r *.xlog\n"
"$ ~/tarantool-1.7/src/tarantool\n"
"\n"
"tarantool> box.cfg{listen = 3301}\n"
"tarantool> box.schema.space.create('tester')\n"
"tarantool> box.space.tester:create_index('primary', {})\n"
"tarantool> box.schema.user.create('test_user', {password = 'pass'})\n"
"tarantool> box.schema.user.grant('test_user', 'read,write,execute', "
"'universe')\n"
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >       { uri = 'localhost:3301', zone = '1' },\n"
"         >   },\n"
"         >   login = 'test_user';\n"
"         >   password = 'pass';\n"
"         >   redundancy = 1;\n"
"         >   binary = 3301;\n"
"         > }\n"
"tarantool> shard = require('shard')\n"
"tarantool> shard.init(cfg)\n"
"tarantool> -- Введите что-нибудь ...\n"
"tarantool> shard.tester:insert{1,'Tuple #1'}"

#: ../doc/1.10/reference/reference_rock/shard.rst:283
msgid ""
"If you cut and paste the above, then the result, showing only the "
"requests and responses for `shard.init` and `shard.tester`, should look "
"approximately like this:"
msgstr ""
"Если вырезать и вставить вышеуказанное, то результат с запросами и "
"ответами только для `shard.init` и `shard.tester` должен выглядеть "
"примерно так:"

#: ../doc/1.10/reference/reference_rock/shard.rst:287
msgid ""
"<...>\n"
"tarantool> shard.init(cfg)\n"
"2017-09-06 ... I> Sharding initialization started...\n"
"2017-09-06 ... I> establishing connection to cluster servers...\n"
"2017-09-06 ... I> connected to all servers\n"
"2017-09-06 ... I> started\n"
"2017-09-06 ... I> redundancy = 1\n"
"2017-09-06 ... I> Adding localhost:3301 to shard 1\n"
"2017-09-06 ... I> shards = 1\n"
"2017-09-06 ... I> Done\n"
"---\n"
"- true\n"
"...\n"
"tarantool> -- Now put something in ...\n"
"---\n"
"...\n"
"tarantool> shard.tester:insert{1,'Tuple #1'}\n"
"---\n"
"- - [1, 'Tuple #1']\n"
"..."
msgstr ""
"<...>\n"
"tarantool> shard.init(cfg)\n"
"2017-09-06 ... I> Sharding initialization started...\n"
"2017-09-06 ... I> establishing connection to cluster servers...\n"
"2017-09-06 ... I> connected to all servers\n"
"2017-09-06 ... I> started\n"
"2017-09-06 ... I> redundancy = 1\n"
"2017-09-06 ... I> Adding localhost:3301 to shard 1\n"
"2017-09-06 ... I> shards = 1\n"
"2017-09-06 ... I> Done\n"
"---\n"
"- true\n"
"...\n"
"tarantool> -- Введите что--нибудь...\n"
"---\n"
"...\n"
"tarantool> shard.tester:insert{1,'Tuple #1'}\n"
"---\n"
"- - [1, 'Tuple #1']\n"
"..."

#: ../doc/1.10/reference/reference_rock/shard.rst:312
msgid "Example: shard, scaling out"
msgstr "Пример: шард, горизонтальное масштабирование"

#: ../doc/1.10/reference/reference_rock/shard.rst:314
msgid ""
"There are two shards, and each shard contains one replicated data copy. "
"This requires two nodes. In real life the two nodes would be two "
"computers, but for this illustration the requirement is merely: start two"
" shells, which we'll call Terminal#1 and Terminal #2."
msgstr ""
"Созданы два шарда, каждый из которых содержит одну копию реплицируемых "
"данных. В реальной жизни два узла будут представлены двумя компьютерами, "
"для примера же требуется использовать две оболочки, которые мы назовем "
"\"терминал №1\" и \"терминал №2\"."

#: ../doc/1.10/reference/reference_rock/shard.rst:319
msgid "On Terminal #1, say:"
msgstr "В первом терминале введите:"

#: ../doc/1.10/reference/reference_rock/shard.rst:321
msgid ""
"$ mkdir ~/tarantool_sandbox_1\n"
"$ cd ~/tarantool_sandbox_1\n"
"$ rm -r *.snap\n"
"$ rm -r *.xlog\n"
"$ ~/tarantool-1.7/src/tarantool\n"
"\n"
"tarantool> box.cfg{listen = 3301}\n"
"tarantool> box.schema.space.create('tester')\n"
"tarantool> box.space.tester:create_index('primary', {})\n"
"tarantool> box.schema.user.create('test_user', {password = 'pass'})\n"
"tarantool> box.schema.user.grant('test_user', 'read,write,execute', "
"'universe')\n"
"tarantool> console = require('console')\n"
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'localhost:3301', zone = '1' },\n"
"         >     { uri = 'localhost:3302', zone = '2' },\n"
"         >   },\n"
"         >   login = 'test_user',\n"
"         >   password = 'pass',\n"
"         >   redundancy = 1,\n"
"         >   binary = 3301,\n"
"         > }\n"
"tarantool> shard = require('shard')\n"
"tarantool> shard.init(cfg)\n"
"tarantool> -- Now put something in ...\n"
"tarantool> shard.tester:insert{1,'Tuple #1'}"
msgstr ""
"$ mkdir ~/tarantool_sandbox_1\n"
"$ cd ~/tarantool_sandbox_1\n"
"$ rm -r *.snap\n"
"$ rm -r *.xlog\n"
"$ ~/tarantool-1.7/src/tarantool\n"
"\n"
"tarantool> box.cfg{listen = 3301}\n"
"tarantool> box.schema.space.create('tester')\n"
"tarantool> box.space.tester:create_index('primary', {})\n"
"tarantool> box.schema.user.create('test_user', {password = 'pass'})\n"
"tarantool> box.schema.user.grant('test_user', 'read,write,execute', "
"'universe')\n"
"tarantool> console = require('console')\n"
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'localhost:3301', zone = '1' },\n"
"         >     { uri = 'localhost:3302', zone = '2' },\n"
"         >   },\n"
"         >   login = 'test_user',\n"
"         >   password = 'pass',\n"
"         >   redundancy = 1,\n"
"         >   binary = 3301,\n"
"         > }\n"
"tarantool> shard = require('shard')\n"
"tarantool> shard.init(cfg)\n"
"tarantool> -- Введите что-нибудь ...\n"
"tarantool> shard.tester:insert{1,'Tuple #1'}"

#: ../doc/1.10/reference/reference_rock/shard.rst:350
msgid "On Terminal #2, say:"
msgstr "Во втором терминале введите:"

#: ../doc/1.10/reference/reference_rock/shard.rst:352
msgid ""
"$ mkdir ~/tarantool_sandbox_2\n"
"$ cd ~/tarantool_sandbox_2\n"
"$ rm -r *.snap\n"
"$ rm -r *.xlog\n"
"$ ~/tarantool-1.7/src/tarantool\n"
"\n"
"tarantool> box.cfg{listen = 3302}\n"
"tarantool> box.schema.space.create('tester')\n"
"tarantool> box.space.tester:create_index('primary', {})\n"
"tarantool> box.schema.user.create('test_user', {password = 'pass'})\n"
"tarantool> box.schema.user.grant('test_user', 'read,write,execute', "
"'universe')\n"
"tarantool> console = require('console')\n"
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'localhost:3301', zone = '1' };\n"
"         >     { uri = 'localhost:3302', zone = '2' };\n"
"         >   };\n"
"         >   login = 'test_user';\n"
"         >   password = 'pass';\n"
"         >   redundancy = 1;\n"
"         >   binary = 3302;\n"
"         > }\n"
"tarantool> shard = require('shard')\n"
"tarantool> shard.init(cfg)\n"
"tarantool> -- Now get something out ...\n"
"tarantool> shard.tester:select{1}"
msgstr ""
"$ mkdir ~/tarantool_sandbox_2\n"
"$ cd ~/tarantool_sandbox_2\n"
"$ rm -r *.snap\n"
"$ rm -r *.xlog\n"
"$ ~/tarantool-1.7/src/tarantool\n"
"\n"
"tarantool> box.cfg{listen = 3302}\n"
"tarantool> box.schema.space.create('tester')\n"
"tarantool> box.space.tester:create_index('primary', {})\n"
"tarantool> box.schema.user.create('test_user', {password = 'pass'})\n"
"tarantool> box.schema.user.grant('test_user', 'read,write,execute', "
"'universe')\n"
"tarantool> console = require('console')\n"
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'localhost:3301', zone = '1' };\n"
"         >     { uri = 'localhost:3302', zone = '2' };\n"
"         >   };\n"
"         >   login = 'test_user';\n"
"         >   password = 'pass';\n"
"         >   redundancy = 1;\n"
"         >   binary = 3302;\n"
"         > }\n"
"tarantool> shard = require('shard')\n"
"tarantool> shard.init(cfg)\n"
"tarantool> -- Выведите что-нибудь ...\n"
"tarantool> shard.tester:select{1}"

#: ../doc/1.10/reference/reference_rock/shard.rst:381
msgid ""
"What will appear on Terminal #1 is: a loop of error messages saying "
"\"Connection refused\" and \"server check failure\". This is normal. It "
"will go on until Terminal #2 process starts."
msgstr ""
"На терминале №1 появится цикл сообщений с ошибками типа \"Connection "
"refused\" (в подключении отказано) и \"server check failure\" (отказ "
"проверки сервера). Это нормально. Сообщения будут появляться, пока не "
"начнется процесс на терминале №2."

#: ../doc/1.10/reference/reference_rock/shard.rst:385
msgid "What will appear on Terminal #2, at the end, should look like this:"
msgstr "В конце, на терминале №2 появится примерно следующее:"

#: ../doc/1.10/reference/reference_rock/shard.rst:387
msgid ""
"tarantool> shard.tester:select{1}\n"
"---\n"
"- - - [1, 'Tuple #1']\n"
"..."
msgstr ""
"tarantool> shard.tester:select{1}\n"
"---\n"
"- - - [1, 'Tuple #1']\n"
"..."

#: ../doc/1.10/reference/reference_rock/shard.rst:394
msgid ""
"This shows that what was inserted by Terminal #1 can be selected by "
"Terminal #2, via the `shard` module."
msgstr ""
"Данный пример показывает, что введенная на терминале №1 информация может "
"быть извлечена на терминале №2 с помощью модуля `shard`."

#: ../doc/1.10/reference/reference_rock/shard.rst:397
msgid "For details, see the `README <https://github.com/tarantool/shard>`_."
msgstr ""
"Для получения подробной информации см. файл `README "
"<https://github.com/tarantool/shard>`_."

#: ../doc/1.10/reference/reference_rock/tdb.rst:37
msgid "Module `tdb`"
msgstr "Модуль `tdb`"

#: ../doc/1.10/reference/reference_rock/tdb.rst:39
msgid ""
"The Tarantool Debugger (abbreviation = ``tdb``) can be used with any Lua "
"program. The operational features include: setting breakpoints, examining"
" variables, going forward one line at a time, backtracing, and showing "
"information about fibers. The display features include: using different "
"colors for different situations, including line numbers, and adding "
"hints."
msgstr ""
"Отладчик Tarantool'а (сокращенно ``tdb``) можно использовать с любой "
"Lua-программой. Рабочие функции: определение точек прерывания, "
"исследование переменных, перебор строк по одной, обратная трассировка и "
"отображение информации о файберах. Функции вывода: использование "
"различных цветов в разных ситуациях, включая номера строк, и добавление "
"подсказок."

#: ../doc/1.10/reference/reference_rock/tdb.rst:45
msgid ""
"It is not supplied as part of the Tarantool repository; it must be "
"installed separately. Here is the usual way:"
msgstr ""
"Модуль не поставляется в репозитории Tarantool'а, его следует "
"устанавливать отдельно. Это обычно делается следующим образом:"

#: ../doc/1.10/reference/reference_rock/tdb.rst:48
msgid ""
"$ git clone --recursive https://github.com/Sulverus/tdb\n"
"$ cd tdb\n"
"$ make\n"
"$ sudo make install prefix=/usr/share/tarantool/"
msgstr ""
"$ git clone --recursive https://github.com/Sulverus/tdb\n"
"$ cd tdb\n"
"$ make\n"
"$ sudo make install prefix=/usr/share/tarantool/"

#: ../doc/1.10/reference/reference_rock/tdb.rst:55
msgid ""
"To initiate ``tdb`` within a Lua program and set a breakpoint, edit the "
"program to include these lines:"
msgstr ""
"Чтобы запустить ``tdb`` в рамках Lua-программы и определить точку "
"прерывания, включите в программу следующие строки:"

#: ../doc/1.10/reference/reference_rock/tdb.rst:58
msgid ""
"tdb = require('tdb')\n"
"tdb.start()"
msgstr ""
"tdb = require('tdb')\n"
"tdb.start()"

#: ../doc/1.10/reference/reference_rock/tdb.rst:63
msgid ""
"To start the debugging session, execute the Lua program. Execution will "
"stop at the breakpoint, and it will be possible to enter debugging "
"commands."
msgstr ""
"Чтобы начать сессию отладки, выполните Lua-программу: выполнение "
"остановится на точке прерывания, и можно будет вводить команды отладчика."

#: ../doc/1.10/reference/reference_rock/tdb.rst:68
msgid "Debugger Commands"
msgstr "Команды отладчика"

#: ../doc/1.10/reference/reference_rock/tdb.rst:72
msgid ":codebold:`bt`"
msgstr ":codebold:`bt`"

#: ../doc/1.10/reference/reference_rock/tdb.rst:71
msgid ""
"Backtrace -- show the stack (in red), with program/function names and "
"line numbers of whatever has been invoked to reach the current line."
msgstr ""
"Обратная трассировка -- отображение стека (красным) с именами "
"программы/функции и номерами строк, выполнение которых привело к текущей "
"строке."

#: ../doc/1.10/reference/reference_rock/tdb.rst:75
msgid ":codebold:`c`"
msgstr ":codebold:`c`"

#: ../doc/1.10/reference/reference_rock/tdb.rst:75
msgid "Continue till next breakpoint or till program ends."
msgstr ""
"Продолжение выполнения до следующей точки прерывания или до окончания "
"программы."

#: ../doc/1.10/reference/reference_rock/tdb.rst:82
msgid ":codebold:`e`"
msgstr ":codebold:`e`"

#: ../doc/1.10/reference/reference_rock/tdb.rst:78
msgid ""
"Enter evaluation mode. When the program is in evaluation mode, one can "
"execute certain Lua statements that would be valid in the context. This "
"is particularly useful for displaying the values of the program's "
"variables. Other debugger commands will not work until one exits "
"evaluation mode by typing :codebold:`-e`."
msgstr ""
"Вход в режим вычисления. Когда программа находится в режиме вычисления, "
"можно выполнять определенные запросы, которые будут действовать с точки "
"зрения контекста. Это особенно полезно для отображения значений "
"переменных программы. Другие команды отладчика не будут работать, пока не"
" выйти из режима оценки, набрав: :codebold:`-e`."

#: ../doc/1.10/reference/reference_rock/tdb.rst:85
msgid ":codebold:`-e`"
msgstr ":codebold:`-e`"

#: ../doc/1.10/reference/reference_rock/tdb.rst:85
msgid "Exit evaluation mode."
msgstr "Выход из режима оценка."

#: ../doc/1.10/reference/reference_rock/tdb.rst:89
msgid ":codebold:`f`"
msgstr ":codebold:`f`"

#: ../doc/1.10/reference/reference_rock/tdb.rst:88
msgid ""
"Display the fiber id, the program name, and the percentage of memory "
"used, as a table."
msgstr ""
"Отображение идентификатора файбера, имени программы и процентного "
"соотношения использованной памяти в виде таблицы."

#: ../doc/1.10/reference/reference_rock/tdb.rst:92
msgid ":codebold:`n`"
msgstr ":codebold:`n`"

#: ../doc/1.10/reference/reference_rock/tdb.rst:92
msgid "Go to the next line, skipping over any function calls."
msgstr "Переход на следующую строку с пропуском любых вызовов функций."

#: ../doc/1.10/reference/reference_rock/tdb.rst:95
msgid ":codebold:`globals`"
msgstr ":codebold:`globals`"

#: ../doc/1.10/reference/reference_rock/tdb.rst:95
msgid "Display names of variables or functions which are defined as global."
msgstr "Отображение имен переменных или функций, которые являются глобальными."

#: ../doc/1.10/reference/reference_rock/tdb.rst:98
msgid ":codebold:`h`"
msgstr ":codebold:`h`"

#: ../doc/1.10/reference/reference_rock/tdb.rst:98
msgid "Display a list of debugger commands."
msgstr "Отображение списка команд отладчика."

#: ../doc/1.10/reference/reference_rock/tdb.rst:102
msgid ":codebold:`locals`"
msgstr ":codebold:`locals`"

#: ../doc/1.10/reference/reference_rock/tdb.rst:101
msgid ""
"Display names and values of variables, for example the control variables "
"of a Lua \"for\" statement."
msgstr ""
"Отображение имен и значений переменных, например, переменных для "
"управления Lua-оператором \"for\"."

#: ../doc/1.10/reference/reference_rock/tdb.rst:105
msgid ":codebold:`q`"
msgstr ":codebold:`q`"

#: ../doc/1.10/reference/reference_rock/tdb.rst:105
msgid "Quit immediately."
msgstr "Немедленный выход."

#: ../doc/1.10/reference/reference_rock/tdb.rst:109
msgid "Example Session"
msgstr "Пример сессии"

#: ../doc/1.10/reference/reference_rock/tdb.rst:111
msgid ""
"Put the following program in a default directory and call it "
"\"example.lua\":"
msgstr ""
"Сохраните следующую программу в директории по умолчанию и назовите ее "
"\"example.lua\":"

#: ../doc/1.10/reference/reference_rock/tdb.rst:113
msgid ""
"tdb = require('tdb')\n"
"tdb.start()\n"
"i = 1\n"
"j = 'a' .. i\n"
"print('end of program')"
msgstr ""
"tdb = require('tdb')\n"
"tdb.start()\n"
"i = 1\n"
"j = 'a' .. i\n"
"print('end of program')"

#: ../doc/1.10/reference/reference_rock/tdb.rst:121
msgid "Now start Tarantool, using example.lua as the initialization file"
msgstr "Запустите Tarantool, используя example.lua в качестве файла инициализации."

#: ../doc/1.10/reference/reference_rock/tdb.rst:123
msgid "$ tarantool example.lua"
msgstr "$ tarantool example.lua"

#: ../doc/1.10/reference/reference_rock/tdb.rst:127
#: ../doc/1.10/reference/reference_rock/tdb.rst:152
msgid "The screen should now look like this:"
msgstr "Теперь вывод на экране выглядит следующим образом:"

#: ../doc/1.10/reference/reference_rock/tdb.rst:132
msgid ""
"$ :codebold:`tarantool example.lua`\n"
":codeblue:`(TDB)`  :codegreen:`Tarantool debugger v.0.0.3. Type h for "
"help`\n"
"example.lua\n"
":codeblue:`(TDB)`  :codegreen:`[example.lua]`\n"
":codeblue:`(TDB)`  :codenormal:`3: i = 1`\n"
":codeblue:`(TDB)>`"
msgstr ""
"$ :codebold:`tarantool example.lua`\n"
":codeblue:`(TDB)`  :codegreen:`Tarantool debugger v.0.0.3. Type h for "
"help`\n"
"example.lua\n"
":codeblue:`(TDB)`  :codegreen:`[example.lua]`\n"
":codeblue:`(TDB)`  :codenormal:`3: i = 1`\n"
":codeblue:`(TDB)>`"

#: ../doc/1.10/reference/reference_rock/tdb.rst:139
msgid ""
"Debugger prompts are blue, debugger hints and information are green, and "
"the current line -- line 3 of example.lua -- is the default color. Now "
"enter six debugger commands:"
msgstr ""
"Запросы отладчика выделены синим, подсказки и информация -- зеленым, а "
"текущая строка -- 3 строка программы example.lua -- цветом, который "
"используется по умолчанию. Введите 6 команд отладчика:"

#: ../doc/1.10/reference/reference_rock/tdb.rst:143
msgid ""
"n  -- go to next line\n"
"n  -- go to next line\n"
"e  -- enter evaluation mode\n"
"j  -- display j\n"
"-e -- exit evaluation mode\n"
"q  -- quit"
msgstr ""
"n  -- переход на следующую строку\n"
"n  -- переход на следующую строку\n"
"e  -- вход в режим оценки\n"
"j  -- отображение j\n"
"-e -- выход из режима оценки\n"
"q  -- выход"

#: ../doc/1.10/reference/reference_rock/tdb.rst:157
msgid ""
"$ :codebold:`tarantool example.lua`\n"
":codeblue:`(TDB)`  :codegreen:`Tarantool debugger v.0.0.3. Type h for "
"help`\n"
"example.lua\n"
":codeblue:`(TDB)`  :codegreen:`[example.lua]`\n"
":codeblue:`(TDB)`  :codenormal:`3: i = 1`\n"
":codeblue:`(TDB)>` n\n"
":codeblue:`(TDB)`  :codenormal:`4: j = 'a' .. i`\n"
":codeblue:`(TDB)>` n\n"
":codeblue:`(TDB)`  :codenormal:`5: print('end of program')`\n"
":codeblue:`(TDB)>` e\n"
":codeblue:`(TDB)`  :codegreen:`Eval mode ON`\n"
":codeblue:`(TDB)>` j\n"
"j       a1\n"
":codeblue:`(TDB)>` -e\n"
":codeblue:`(TDB)`  :codegreen:`Eval mode OFF`\n"
":codeblue:`(TDB)>` q"
msgstr ""
"$ :codebold:`tarantool example.lua`\n"
":codeblue:`(TDB)`  :codegreen:`Tarantool debugger v.0.0.3. Type h for "
"help`\n"
"example.lua\n"
":codeblue:`(TDB)`  :codegreen:`[example.lua]`\n"
":codeblue:`(TDB)`  :codenormal:`3: i = 1`\n"
":codeblue:`(TDB)>` n\n"
":codeblue:`(TDB)`  :codenormal:`4: j = 'a' .. i`\n"
":codeblue:`(TDB)>` n\n"
":codeblue:`(TDB)`  :codenormal:`5: print('end of program')`\n"
":codeblue:`(TDB)>` e\n"
":codeblue:`(TDB)`  :codegreen:`Eval mode ON`\n"
":codeblue:`(TDB)>` j\n"
"j       a1\n"
":codeblue:`(TDB)>` -e\n"
":codeblue:`(TDB)`  :codegreen:`Eval mode OFF`\n"
":codeblue:`(TDB)>` q"

#: ../doc/1.10/reference/reference_rock/tdb.rst:174
msgid ""
"Another debugger example can be found `here "
"<https://github.com/sulverus/tdb>`_."
msgstr ""
"Другой пример работы отладчика можно найти `здесь "
"<https://github.com/sulverus/tdb>`_."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:39
msgid "Module `vshard`"
msgstr "Модуль `vshard`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:45
msgid "Summary"
msgstr "Обзор"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:47
msgid ""
"The ``vshard`` module introduces the sharding feature, which enables "
"horizontal scaling in Tarantool."
msgstr ""
"В модуле ``vshard`` реализована новая функция шардинга (сегментирования),"
" которая позволяет осуществлять горизонтальное масштабирование в "
"Tarantool'е."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:50
msgid ""
"While a project is growing, scaling the databases may become the most "
"challenging issue. Once a single server cannot withstand the load, "
"scaling methods should be applied."
msgstr ""
"С ростом проекта масштабируемость баз данных становится проблемой. Если "
"отдельный сервер не может справиться с нагрузкой, необходимо применять "
"средства масштабирования."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:54
msgid ""
"There are two different approaches for scaling data, `vertical and "
"horizontal scaling "
"<https://en.wikipedia.org/wiki/Scalability#Horizontal_and_vertical_scaling>`_:"
msgstr ""
"Есть два различных подхода к масштабированию данных: `вертикальное и "
"горизонтальное масштабирование "
"<https://en.wikipedia.org/wiki/Scalability#Horizontal_and_vertical_scaling>`_:"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:57
msgid ""
"*Vertical scaling* implies that the hardware capacities of a single "
"server would be increased."
msgstr ""
"*Вертикальное масштабирование* подразумевает увеличение "
"производительности системы отдельного сервера."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:60
msgid ""
"*Horizontal scaling* implies that a dataset is partitioned and "
"distributed over multiple servers. In case new servers are added, the "
"dataset is re-distributed evenly across all servers, both the original "
"and new ones."
msgstr ""
"*Горизонтальное масштабирование* подразумевает секционирование набора "
"данных и распределение данных по множеству серверов. При добавлении новых"
" серверов набор данных повторно равномерно распределяется по всем "
"серверам, новым и старым."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:64
msgid "Sharding is a database architecture that allows for horizontal scaling."
msgstr ""
"Шардинг, или сегментирование, представляет собой архитектуру базы данных,"
" которая предоставляет возможность горизонтального масштабирования."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:66
msgid ""
"With ``vshard``, the tuples of a dataset are distributed across multiple "
"nodes, with a Tarantool database server instance on each node. Each "
"instance handles only a subset of the total data, so larger loads can be "
"handled by simply adding more servers. The initial dataset is partitioned"
" into multiple parts, so each part is stored on a separate server. The "
"dataset is partitioned using sharding keys."
msgstr ""
"С помощью модуля ``vshard`` кортежи набора данных распределяются по "
"множеству узлов, на каждом из которых находится экземпляр сервера базы "
"данных Tarantool'а. Каждый экземпляр обрабатывает лишь подмножество от "
"общего количества данных, поэтому увеличение нагрузки можно "
"компенсировать добавлением новых серверов. Первоначальный набор данных "
"секционируется на множество частей, то есть каждая часть хранится на "
"отдельном сервере. Секционирование набора данных осуществляется с помощью"
" сегментных ключей."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:72
msgid ""
"The ``vshard`` module is based on the concept of virtual buckets, where a"
" tuple set is partitioned into a large number of abstract virtual nodes "
"(virtual buckets, or buckets) rather than into a smaller number of "
"physical nodes."
msgstr ""
"Модуль ``vshard`` основан на концепции виртуальных сегментов: набор "
"кортежей распределяется на большое количество абстрактных виртуальных "
"узлов (виртуальных сегментов, или сегментов), а не на малое количество "
"физических узлов."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:76
msgid ""
"Hashing a sharding key into a large number of virtual buckets allows "
"seamlessly changing the number of servers in the cluster. The rebalancing"
" mechanism distributes buckets evenly among all shards in case some "
"servers were added or removed."
msgstr ""
"Хеширование сегментного ключа в большое количество виртуальных сегментов "
"позволяет незаметно для пользователя изменять количество серверов в "
"кластере. Механизм балансирования распределяет сегменты между шардами, "
"если некоторые серверы добавляются или убираются."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:80
msgid ""
"The buckets have states, so it is easy to monitor the server states. For "
"example, a server instance is active and available for all types of "
"requests, or a failover occurred and the instance accepts only read "
"requests."
msgstr ""
"Для сегментов предусмотрены состояния, поэтому можно легко отслеживать "
"состояние сервера. Например, активен ли экземпляр сервера и доступен ли "
"он для всех типов запросов, или же произошел отказ, и сервер принимает "
"только запросы на чтение."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:84
msgid ""
"The ``vshard`` module provides analogs for the data-manipulation "
"functions of the Tarantool ``box`` library (select, insert, replace, "
"update, delete)."
msgstr ""
"Модуль ``vshard`` предоставляет функции, аналогичные функциям по "
"управлению данными библиотеки Tarantool'а ``box`` (select, insert, "
"replace, update, delete)."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:93
msgid ""
"The ``vshard`` module is distributed separately from the main Tarantool "
"package. To acquire it, do a separate installation:"
msgstr ""
"Пакет ``vshard`` распространяется отдельно от основного пакета "
"Tarantool'а. Для работы с ним выполните установку отдельно:"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:96
msgid "$ tarantoolctl rocks install vshard"
msgstr "$ tarantoolctl rocks install vshard"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:102
msgid "The ``vshard`` module requires Tarantool version 1.9+."
msgstr "Для работы с модулем ``vshard`` необходима версия Tarantool'а 1.9+."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:108
msgid "Quick start"
msgstr "Краткое руководство"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:110
msgid ""
"The ``vshard/example/`` directory includes a pre-configured development "
"cluster of 1 ``router`` and 2 replica sets of 2 nodes (2 ``storages``) "
"each, making 5 Tarantool instances in total:"
msgstr ""
"В директории ``vshard/example/`` находится предварительно настроенный "
"кластер из 1 роутера и 2 наборов реплик из 2 узлов (2 хранилища) в "
"каждом, что составляет всего 5 экземпляров Tarantool'а в целом:"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:114
msgid "``router_1`` – a ``router`` instance"
msgstr "``router_1`` – экземпляр роутера (``router``)"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:115
msgid ""
"``storage_1_a`` – a ``storage`` instance, the master of the first replica"
" set"
msgstr ""
"``storage_1_a`` – экземпляр хранилища (``storage``), мастер первого "
"набора реплик"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:116
msgid ""
"``storage_1_b`` – a ``storage`` instance, the replica of the first "
"replica set"
msgstr ""
"``storage_1_b`` – экземпляр хранилища (``storage``), реплика из первого "
"набора реплик"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:117
msgid ""
"``storage_2_a`` – a ``storage`` instance, the master of the second "
"replica set"
msgstr ""
"``storage_2_a`` – экземпляр хранилища (``storage``), мастер второго "
"набора реплик"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:118
msgid ""
"``storage_2_b`` – a ``storage`` instance, the replica of the second "
"replica set"
msgstr ""
"``storage_2_b`` – экземпляр хранилища (``storage``), реплика из второго "
"набора реплик"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:120
msgid ""
"All instances are managed using the ``tarantoolctl`` utility which comes "
"with Tarantool."
msgstr ""
"Управление всеми экземплярами осуществляется с помощью утилиты "
"``tarantoolctl``."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:122
msgid ""
"Change the directory to ``example/`` and use make to run the development "
"cluster:"
msgstr ""
"Измените директорию ``example/`` и используйте команду make для запуска "
"кластера:"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:124
msgid ""
"$ cd example/\n"
"$ make\n"
"tarantoolctl stop storage_1_a  # stop the first storage instance\n"
"Stopping instance storage_1_a...\n"
"tarantoolctl stop storage_1_b\n"
"<...>\n"
"rm -rf data/\n"
"tarantoolctl start storage_1_a # start the first storage instance\n"
"Starting instance storage_1_a...\n"
"Starting configuration of replica 8a274925-a26d-47fc-9e1b-af88ce939412\n"
"I am master\n"
"Taking on replicaset master role...\n"
"Run console at unix/:./data/storage_1_a.control\n"
"started\n"
"mkdir ./data/storage_1_a\n"
"<...>\n"
"tarantoolctl start router_1 # start the router\n"
"Starting instance router_1...\n"
"Starting router configuration\n"
"Calling box.cfg()...\n"
"<...>\n"
"Run console at unix/:./data/router_1.control\n"
"started\n"
"mkdir ./data/router_1\n"
"Waiting cluster to start\n"
"echo \"vshard.router.bootstrap()\" | tarantoolctl enter router_1\n"
"connected to unix/:./data/router_1.control\n"
"unix/:./data/router_1.control> vshard.router.bootstrap()\n"
"---\n"
"- true\n"
"...\n"
"unix/:./data/router_1.control>\n"
"tarantoolctl enter router_1 # enter the admin console\n"
"connected to unix/:./data/router_1.control\n"
"unix/:./data/router_1.control>"
msgstr ""
"$ cd example/\n"
"$ make\n"
"tarantoolctl stop storage_1_a  # stop the first storage instance\n"
"Stopping instance storage_1_a...\n"
"tarantoolctl stop storage_1_b\n"
"<...>\n"
"rm -rf data/\n"
"tarantoolctl start storage_1_a # start the first storage instance\n"
"Starting instance storage_1_a...\n"
"Starting configuration of replica 8a274925-a26d-47fc-9e1b-af88ce939412\n"
"I am master\n"
"Taking on replicaset master role...\n"
"Run console at unix/:./data/storage_1_a.control\n"
"started\n"
"mkdir ./data/storage_1_a\n"
"<...>\n"
"tarantoolctl start router_1 # start the router\n"
"Starting instance router_1...\n"
"Starting router configuration\n"
"Calling box.cfg()...\n"
"<...>\n"
"Run console at unix/:./data/router_1.control\n"
"started\n"
"mkdir ./data/router_1\n"
"Waiting cluster to start\n"
"echo \"vshard.router.bootstrap()\" | tarantoolctl enter router_1\n"
"connected to unix/:./data/router_1.control\n"
"unix/:./data/router_1.control> vshard.router.bootstrap()\n"
"---\n"
"- true\n"
"...\n"
"unix/:./data/router_1.control>\n"
"tarantoolctl enter router_1 # enter the admin console\n"
"connected to unix/:./data/router_1.control\n"
"unix/:./data/router_1.control>"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:162
msgid "Some ``tarantoolctl`` commands:"
msgstr "Некоторые команды ``tarantoolctl``:"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:164
msgid "``tarantoolctl start router_1`` – start the router instance"
msgstr "``tarantoolctl start router_1`` – запуск экземпляра роутера"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:165
msgid "``tarantoolctl enter router_1``  – enter the admin console"
msgstr "``tarantoolctl enter router_1``  – вход в административную консоль"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:167
msgid ""
"The full list of ``tarantoolctl`` commands for managing Tarantool "
"instances is available in the :ref:`tarantoolctl reference "
"<tarantoolctl>`."
msgstr ""
"Полный список команд ``tarantoolctl`` для управления экземплярами "
"Tarantool'а можно найти в :ref:`справочнике по tarantoolctl "
"<tarantoolctl>`."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:170
msgid "Essential make commands you need to know:"
msgstr "Необходимо знать следующие команды make:"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:172
msgid "``make start`` – start all Tarantool instances"
msgstr "``make start`` – запуск всех экземпляров Tarantool'а"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:173
msgid "``make stop`` – stop all Tarantool instances"
msgstr "``make stop`` – остановка всех экземпляров Tarantool'а"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:174
msgid "``make logcat`` – show logs from all instances"
msgstr "``make logcat`` – вывод журналов всех экземпляров"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:175
msgid "``make enter`` – enter the admin console on router_1"
msgstr "``make enter`` – вход в административную консоль на роутере router_1"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:176
msgid "``make clean`` – clean up all persistent data"
msgstr "``make clean`` – очистка всех персистентных данных"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:177
msgid ""
"``make test`` – run the test suite (you can also run test-run.py in the "
"test directory)"
msgstr ""
"``make test`` – запуск набора тестов (можно также выполнить test-run.py в"
" директории с тестами)"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:178
msgid ""
"``make`` – execute ``make stop``, ``make clean``, ``make start`` and "
"``make enter``"
msgstr ""
"``make`` – выполнить ``make stop``, ``make clean``, ``make start`` и "
"``make enter``"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:180
msgid "For example, to start all instances, use ``make start``:"
msgstr "Например, для запуска всех экземпляров используйте ``make start``:"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:182
msgid ""
"$ make start\n"
"$ ps x|grep tarantool\n"
"46564   ??  Ss     0:00.34 tarantool storage_1_a.lua <running>\n"
"46566   ??  Ss     0:00.19 tarantool storage_1_b.lua <running>\n"
"46568   ??  Ss     0:00.35 tarantool storage_2_a.lua <running>\n"
"46570   ??  Ss     0:00.20 tarantool storage_2_b.lua <running>\n"
"46572   ??  Ss     0:00.25 tarantool router_1.lua <running>"
msgstr ""
"$ make start\n"
"$ ps x|grep tarantool\n"
"46564   ??  Ss     0:00.34 tarantool storage_1_a.lua <running>\n"
"46566   ??  Ss     0:00.19 tarantool storage_1_b.lua <running>\n"
"46568   ??  Ss     0:00.35 tarantool storage_2_a.lua <running>\n"
"46570   ??  Ss     0:00.20 tarantool storage_2_b.lua <running>\n"
"46572   ??  Ss     0:00.25 tarantool router_1.lua <running>"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:192
msgid "To perform commands in the admin console, use the ``router`` API:"
msgstr ""
"Для выполнения команд в административной консоли, используйте API "
"``router``:"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:194
msgid ""
"unix/:./data/router_1.control> vshard.router.info()\n"
"---\n"
"- replicasets:\n"
"    ac522f65-aa94-4134-9f64-51ee384f1a54:\n"
"      replica: &0\n"
"        network_timeout: 0.5\n"
"        status: available\n"
"        uri: storage@127.0.0.1:3303\n"
"        uuid: 1e02ae8a-afc0-4e91-ba34-843a356b8ed7\n"
"      uuid: ac522f65-aa94-4134-9f64-51ee384f1a54\n"
"      master: *0\n"
"    cbf06940-0790-498b-948d-042b62cf3d29:\n"
"      replica: &1\n"
"        network_timeout: 0.5\n"
"        status: available\n"
"        uri: storage@127.0.0.1:3301\n"
"        uuid: 8a274925-a26d-47fc-9e1b-af88ce939412\n"
"      uuid: cbf06940-0790-498b-948d-042b62cf3d29\n"
"      master: *1\n"
"  bucket:\n"
"    unreachable: 0\n"
"    available_ro: 0\n"
"    unknown: 0\n"
"    available_rw: 3000\n"
"  status: 0\n"
"  alerts: []\n"
"..."
msgstr ""
"unix/:./data/router_1.control> vshard.router.info()\n"
"---\n"
"- replicasets:\n"
"    ac522f65-aa94-4134-9f64-51ee384f1a54:\n"
"      replica: &0\n"
"        network_timeout: 0.5\n"
"        status: available\n"
"        uri: storage@127.0.0.1:3303\n"
"        uuid: 1e02ae8a-afc0-4e91-ba34-843a356b8ed7\n"
"      uuid: ac522f65-aa94-4134-9f64-51ee384f1a54\n"
"      master: *0\n"
"    cbf06940-0790-498b-948d-042b62cf3d29:\n"
"      replica: &1\n"
"        network_timeout: 0.5\n"
"        status: available\n"
"        uri: storage@127.0.0.1:3301\n"
"        uuid: 8a274925-a26d-47fc-9e1b-af88ce939412\n"
"      uuid: cbf06940-0790-498b-948d-042b62cf3d29\n"
"      master: *1\n"
"  bucket:\n"
"    unreachable: 0\n"
"    available_ro: 0\n"
"    unknown: 0\n"
"    available_rw: 3000\n"
"  status: 0\n"
"  alerts: []\n"
"..."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:228
msgid "Architecture"
msgstr "Архитектура"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:230
msgid ""
"A sharded cluster in Tarantool consists of storages, routers, and a "
"rebalancer."
msgstr ""
"Сегментированный кластер в Tarantool'е состоит из хранилищ, роутеров и "
"балансировщика."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:232
msgid ""
"A **storage** is a node storing a subset of a dataset. Multiple "
"replicated storages are deployed as replica sets to provide redundancy (a"
" replica set can also be called a shard)."
msgstr ""
"**Хранилище** (storage) -- это узел, который хранит подмножество набора "
"данных. Развертывание нескольких реплицируемых хранилищ осуществляется в "
"виде наборов реплик, чтобы обеспечить резерв (набор реплик также можно "
"называть шардом или сегментом)."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:236
msgid ""
"A **router** is a standalone software component that routes read and "
"write requests from the client application to shards."
msgstr ""
"**Роутер** (router) -- это автономный компонент ПО, который обеспечивает "
"маршрутизацию запросов чтения и записи от клиентского приложения к "
"шардам."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:239
msgid ""
"A **rebalancer** is an internal component that distributes the dataset "
"among all shards evenly in case some servers are added or removed. It "
"also balances the load considering the capacities of existing replica "
"sets."
msgstr ""
"**Балансировщик** (rebalancer) -- это внутренний компонент, который "
"равномерно распределяет набор данных между всеми шардами в случае "
"добавления или удаления серверов. Он также занимается выравниванием "
"нагрузки с учетом производительности существующих наборов реплик."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:250
msgid "Storage"
msgstr "Хранилище"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:252
msgid ""
"**Storage** is a node storing a subset of a dataset. Multiple replicated "
"storages comprise a replica set. Each storage in a replica set has a "
"role, **master** or **replica**. A master processes read and write "
"requests. A replica processes read requests but cannot process write "
"requests."
msgstr ""
"**Хранилище** (storage) -- это узел, который хранит подмножество набора "
"данных. Несколько реплицируемых хранилищ составляют набор реплик. У "
"каждого хранилища в наборе реплик есть роль: **мастер** или **реплика**. "
"Мастер обрабатывает запросы на чтение и запись. Реплика обрабатывает "
"запросы на чтение, но не может обрабатывать запросы на запись."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:264
msgid "Virtual buckets"
msgstr "Виртуальные сегменты"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:266
msgid ""
"The sharded dataset is partitioned into a large number of abstract nodes "
"called **virtual buckets** (further referred to as **buckets**)."
msgstr ""
"Набор данных при шардинге распределяется на большое количество "
"абстрактных узлов, которые называются **виртуальные сегменты** (далее по "
"тексту **сегменты**)."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:269
msgid ""
"The dataset is partitioned using the sharding key (or **bucket id**, in "
"Tarantool terminology). Bucket id is a number from 1 to N, where N is the"
" total number of buckets."
msgstr ""
"Секционирование набора данных происходит с помощью сегментного ключа (или"
" **идентификатора сегмента** (bucket id) в терминах Tarantool'а). "
"Идентификатор сегмента -- это число от 1 до N, где N -- это общее "
"количество сегментов."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:276
msgid ""
"Each replica set stores a unique subset of buckets. One bucket cannot "
"belong to multiple replica sets at a time."
msgstr ""
"В каждом наборе реплик есть уникальное подмножество сегментов. Одна "
"сегмент не может относиться к нескольким наборам реплик одновременно."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:282
msgid ""
"The total number of buckets is determined by the administrator who sets "
"up the initial cluster configuration."
msgstr ""
"Общее количество сегментов определяет администратор, который настраивает "
"первоначальную конфигурацию кластера."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:285
msgid ""
"Every Tarantool space you plan to shard must have a bucket id field "
"indexed by the bucket id ``index``. Spaces without the bucket id indexes "
"don’t participate in sharding but can be used as regular spaces. By "
"default, the name of the index coincides with the bucket id."
msgstr ""
"Каждый спейс Tarantool'а, который планируется сегментировать, должен "
"включать в себя проиндексированное поле с идентификатором сегмента. "
"Спейсы без индексов идентификаторов сегментов не участвуют в шардинге, но"
" могут использоваться в качестве обычных спейсов. По умолчанию, имя "
"индекса совпадает с идентификатором сегмента."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:294
msgid "Migration of buckets"
msgstr "Миграция сегментов"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:296
msgid ""
"A **rebalancer** is a background rebalancing process that ensures an even"
" distribution of buckets across the shards. During rebalancing, buckets "
"are being migrated among replica sets."
msgstr ""
"**Балансировщик** представляет собой фоновый процесс балансировки, "
"который обеспечивает равномерное распределение сегментов по шардам. Во "
"время балансировки происходит миграция сегментов по наборам реплик."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:300
msgid ""
"A replica set from which the bucket is being migrated is called a "
"**source** ; a target replica set to which the bucket is being migrated is"
" called a **destination**."
msgstr ""
"Набор реплик, из которого переносится сегмент, называется **исходный** "
"(source); а набор реплик, куда переносится сегмент, называется "
"**целевой** (destination)."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:303
msgid ""
"A **replica set lock** makes a replica set invisible to the rebalancer. A"
" locked replica set can neither receive new buckets nor migrate its own "
"buckets."
msgstr ""
"**Блокировка набора реплик** позволяет набору реплик оставаться невидимым"
" для балансировщика. Набор реплик с блокировкой не может ни принимать "
"новые сегменты, ни мигрировать свои собственные."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:306
msgid "While a bucket is being migrated, it can have different states:"
msgstr "Во время миграции у сегмента могут быть разные статусы:"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:308
msgid "ACTIVE – the bucket is available for read and write requests."
msgstr "ACTIVE (активный) -- сегмент доступен для запросов чтения и записи."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:309
msgid ""
"PINNED – the bucket is locked for migrating to another replica set. "
"Otherwise pinned buckets are similar to buckets in the ACTIVE state."
msgstr ""
"PINNED (закрепленный) -- сегмент заблокирован для миграции в другой набор"
" реплик. Во всем остальном закрепленные сегменты аналогичны активным "
"сегментам."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:311
msgid ""
"SENDING – the bucket is currently being copied to the destination replica"
" set; read requests to the source replica set are still processed."
msgstr ""
"SENDING (отправляемый) -- в настоящий момент сегмент копируется в целевой"
" набор реплик; запросы на чтение в исходный набор реплик обрабатываются."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:313
msgid ""
"RECEIVING – the bucket is currently being filled; all requests to it are "
"rejected."
msgstr ""
"RECEIVING (принимающий) -- происходит наполнение сегмента; все запросы "
"отклоняются."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:314
msgid ""
"SENT – the bucket was migrated to the destination replica set. The "
"`router` uses the SENT state to calculate the new location of the bucket."
" A bucket in the SENT state goes to the GARBAGE state automatically after"
" BUCKET_SENT_GARBAGE_DELAY seconds, which by default is :ref:`0.5 seconds"
" <cfg_basic-collect_bucket_garbage_interval>`."
msgstr ""
"SENT (отправленный) -- сегмент был перенесен в целевой набор реплик. "
"Роутер использует статус SENT, чтобы определить новое местонахождение "
"сегмента. Сегмент в статусе SENT переходит в статус мусора GARBAGE "
"автоматически через количество секунд, указанное в "
"BUCKET_SENT_GARBAGE_DELAY, по умолчанию равное :ref:`0,5 секунды "
"<cfg_basic-collect_bucket_garbage_interval>`."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:318
msgid ""
"GARBAGE – the bucket was already migrated to the destination replica set "
"during rebalancing; or the bucket was initially in the RECEIVING state, "
"but some error occurred during the migration."
msgstr ""
"GARBAGE (мусор) -- произошла миграция сегмента в целевой набор реплик во "
"время балансировки; или же принимающий сегмент был в статусе RECEIVING, "
"но произошла ошибка во время миграции."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:322
msgid "Buckets in the GARBAGE state are deleted by the garbage collector."
msgstr "Сегменты в статусе мусора GARBAGE удаляются сборщиком мусора."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:327
msgid "Migration is performed as follows:"
msgstr "Миграция происходит следующим образом:"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:329
msgid ""
"At the destination replica set, a new bucket is created and assigned the "
"RECEIVING state, the data copying starts, and the bucket rejects all "
"requests."
msgstr ""
"В целевом наборе реплик создается новый сегмент, который получает статус "
"RECEIVING (принимающий), начинается копирование данных, и сегмент "
"отклоняет все запросы."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:331
msgid ""
"The source bucket in the source replica set is assigned the SENDING "
"state, and the bucket continues to process read requests."
msgstr ""
"Отправляемый сегмент в исходном наборе реплик получает статус SENDING и "
"продолжает обрабатывать запросы на чтение."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:333
msgid ""
"Once the data is copied, the bucket on the source replica set is assigned"
" the SENT and it starts rejecting all requests."
msgstr ""
"После копирования данных сегмент в исходном наборе реплик получает статус"
" отправленного (SENT) и перестает принимать запросы."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:335
msgid ""
"The bucket on the destination replica set is assigned the ACTIVE state "
"and starts accepting all requests."
msgstr ""
"Сегмент в целевом наборе реплик переходит в активный статус (ACTIVE) и "
"начинает принимать все запросы."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:342
msgid "The `_bucket` system space"
msgstr "Системный спейс `_bucket`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:344
msgid ""
"The ``_bucket`` system space of each replica set stores the ids of "
"buckets present in the replica set. The space contains the following "
"fields:"
msgstr ""
"Системный спейс ``_bucket`` в каждом наборе реплик хранит идентификаторы "
"сегментов данного набора реплик. Спейс содержит следующие поля:"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:347
msgid "``bucket`` – bucket id"
msgstr "``bucket`` -- идентификатор сегмента"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:348
msgid "``status`` – state of the bucket"
msgstr "``status`` -- статус сегмента"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:349
msgid "``destination`` – UUID of the destination replica set"
msgstr "``destination`` -- UUID целевого набора реплик"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:351
msgid "An example of ``_bucket.select{}``:"
msgstr "Пример ``_bucket.select{}``:"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:353
msgid ""
"---\n"
"- - [1, ACTIVE, abfe2ef6-9d11-4756-b668-7f5bc5108e2a]\n"
"  - [2, SENT, 19f83dcb-9a01-45bc-a0cf-b0c5060ff82c]\n"
"..."
msgstr ""
"---\n"
"- - [1, ACTIVE, abfe2ef6-9d11-4756-b668-7f5bc5108e2a]\n"
"  - [2, SENT, 19f83dcb-9a01-45bc-a0cf-b0c5060ff82c]\n"
"..."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:360
msgid ""
"Once the bucket is migrated, the destination replica set identified by "
"UUID is filled in the table. While the bucket is still located on the "
"source replica set, the value of the destination replica set UUID is "
"equal to ``NULL``."
msgstr ""
"После миграции сегмента UUID целевого набора реплик вносится в таблицу. "
"Пока сегмент еще находится в исходном наборе реплик, значение UUID "
"целевого набора реплик равно ``NULL``."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:368
msgid "Router"
msgstr "Роутер"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:370
msgid ""
"All requests from the application come to the sharded cluster through a "
"``router``. The ``router`` keeps the topology of a sharded cluster "
"transparent for the application, thus keeping the application unaware of:"
msgstr ""
"Все запросы из приложения приходят в сегментированный кластер через "
"роутер (``router``). Роутер сохраняет топологию сегментированного "
"кластера прозрачной для приложения, не сообщая приложению:"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:374
msgid "the number and location of shards,"
msgstr "номер и местоположение шардов,"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:375
msgid "data rebalancing process,"
msgstr "процесс балансировки данных,"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:376
msgid ""
"the fact and the process of a failover that occurred after a replica's "
"failure."
msgstr "наличие отказа и восстановление после отказа реплики."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:378
msgid ""
"The ``router`` does not have a persistent state, nor does it store the "
"cluster topology or balance the data. The ``router`` is a standalone "
"software component that can run in the storage layer or application layer"
" depending on the application features."
msgstr ""
"У роутера нет постоянного статуса, он не хранит топологию кластера и не "
"выполняет балансировку данных. Роутер -- это автономный компонент ПО, "
"который может работать на уровне хранилища или на уровне приложения в "
"зависимости от функций приложения."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:386
msgid "The routing table"
msgstr "Таблица маршрутизации"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:388
msgid ""
"А routing table on the ``router`` stores the map of all bucket ids to "
"replica sets. It ensures the consistency of sharding in case of failover."
msgstr ""
"Таблица маршрутизации роутера отображает все идентификаторы сегментов с "
"соответствующими наборами реплик. Она обеспечивает консистентность "
"шардинга в случае отказа."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:391
msgid ""
"The ``router`` keeps a persistent pool of connections to all the storages"
" that are created at startup. This helps prevent configuration errors. "
"Once the connection pool is created, the ``router`` caches the current "
"state of the routing table in order to speed up routing. If a bucket "
"migrated to another ``storage`` after rebalancing, or a failover occurred"
" and caused one of the shards switching to another replica, the "
"``discovery fiber`` on the ``router`` updates the routing table "
"automatically."
msgstr ""
"Роутер поддерживает постоянный пул соединений со всеми хранилищами, "
"созданными при запуске, что помогает избежать ошибки конфигурации. После "
"создания пула соединений роутер кэширует текущее состояние таблицы "
"маршрутизации, чтобы ускорить ее. Если произошла миграция сегмента в "
"другое хранилище после балансировки или же отказ, который вызвал "
"переключение шарда на другую реплику, файбер обнаружения (``discovery "
"fiber``) в роутере обновит таблицу маршрутизации автоматически."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:398
msgid ""
"As the bucket id is explicitly indicated both in the data and in the "
"mapping table on the ``router``, the data is consistent regardless of the"
" application logic. It also makes rebalancing transparent for the "
"application."
msgstr ""
"Поскольку идентификатор сегмента явно указан как в данных, так и в "
"таблице отображения на роутере, данные сохраняются независимо от логики "
"приложения. Это также обеспечивает прозрачность балансировки для "
"приложения."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:406
msgid "Processing requests"
msgstr "Обработка запросов"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:408
msgid ""
"Requests to the database can be performed by the application or using "
"stored procedures. Either way, the bucket id should be explicitly "
"specified in the request."
msgstr ""
"Запросы в базу данных можно производить из приложения или с помощью "
"хранимых процедур. В любом случае идентификатор сегмента следует явным "
"образом указать в запросе."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:411
msgid ""
"All requests are forwarded to the ``router`` first. The only operation "
"supported by the ``router`` is ``call``. The operation is performed via "
"the ``vshard.router.call()`` function:"
msgstr ""
"Сначала все запросы направляются в роутер. Роутер поддерживает только "
"операцию вызова, которая выполняется с помощью функции "
"``vshard.router.call()``:"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:415
msgid ""
"result = vshard.router.call(<bucket_id>, <mode>, <function_name>, "
"{<argument_list>}, {<opts>})"
msgstr ""
"result = vshard.router.call(<идентификатор_сегмента>, <режим>, "
"<имя_функции>, {<список_аргументов>}, {<опции>})"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:419
msgid "Requests are processed as follows:"
msgstr "Запросы обрабатываются следующим образом:"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:421
msgid ""
"The ``router`` uses the bucket id to search for a replica set with the "
"corresponding bucket in the routing table."
msgstr ""
"Роутер использует идентификатор сегмента для поиска набора реплик с "
"соответствующим сегментом в таблице маршрутизации."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:424
msgid ""
"If the map of the bucket id to the replica set is not known to the "
"``router`` (the discovery fiber hasn’t filled the table yet), the "
"``router`` makes requests to all ``storages`` to find out where the "
"bucket is located."
msgstr ""
"Если роутер не содержит информацию о соответствии идентификатора сегмента"
" набору реплик (файбер обнаружения еще не заполнил таблицу), роутер "
"выполняет запросы ко всем хранилищам, чтобы обнаружить местонахождение "
"сегмента."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:427
msgid "Once the bucket is located, the shard checks:"
msgstr "После обнаружения сегмента шард проверяет:"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:429
msgid ""
"whether the bucket is stored in the ``_bucket`` system space of the "
"replica set;"
msgstr "хранится ли сегмент в системном спейсе ``_bucket`` набора реплик;"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:430
msgid ""
"whether the bucket is ACTIVE or PINNED (for a read request, it can also "
"be SENDING)."
msgstr ""
"находится ли сегмент в статусе ACTIVE (активный) или PINNED "
"(закрепленный) (если выполняется запрос на чтение, то сегмент может "
"находиться в состоянии отправки SENDING)."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:431
msgid ""
"If all the checks succeed, the request is executed. Otherwise, it is "
"terminated with the error: ``“wrong bucket”``."
msgstr ""
"Если проверка пройдена, запрос выполняется. В противном случае, "
"выполнение запроса прекращается с ошибкой: ``“wrong bucket”`` "
"(несоответствующий сегмент)."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:438
msgid "Administration"
msgstr "Администрирование"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:444
msgid "Configuring a sharded cluster"
msgstr "Конфигурация сегментированного кластера"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:446
msgid "A minimal viable sharded cluster should consist of:"
msgstr "Минимальный рабочий сегментированный кластер должен состоять из:"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:448
msgid ""
"one or more replica sets, each containing two or more ``storage`` "
"instances"
msgstr ""
"одного или нескольких наборов реплик с двумя или несколькими хранилищами "
"в каждом"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:449
msgid "one or more ``router`` instances"
msgstr "одного или нескольких роутеров"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:451
msgid ""
"The number of ``storage`` instances in a replica set defines the "
"redundancy factor of the data. The recommended value is 3 or more. The "
"number of ``router`` instances is not limited, because routers are "
"completely stateless. We recommend increasing the number of routers when "
"an existing ``router`` instance becomes CPU or I/O bound."
msgstr ""
"Количество хранилищ в наборе реплик определяет коэффициент избыточности "
"данных. Рекомендуемое значение: 3 или более. Количество роутеров не "
"ограничено, потому что у роутеров нет состояния. Рекомендуем увеличивать "
"количество роутеров, если существующий экземпляр роутера ограничен "
"возможностями процессора или ввода-вывода."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:456
msgid ""
"``vshard`` supports multiple ``router`` instances on a single Tarantool "
"instance. Each ``router`` can be connected to any ``vshard`` cluster. "
"Multiple ``router`` instances can be connected to the same cluster."
msgstr ""
"``vshard`` поддерживает работу с несколькими роутерами в отдельном "
"экземпляре Tarantool'а. Каждый роутер может подключиться к любому "
"кластеру ``vshard``. Несколько роутеров могут быть подключены к одному "
"кластеру."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:460
msgid ""
"As the ``router`` and ``storage`` applications perform completely "
"different sets of functions, they should be deployed to different "
"Tarantool instances. Although it is technically possible to place the "
"router application on every ``storage`` node, this approach is highly "
"discouraged and should be avoided on production deployments."
msgstr ""
"Поскольку приложения роутера (``router``) и хранилища (``storage``) "
"выполняют совершенно разные наборы функций, их следует разворачивать на "
"различных экземплярах Tarantool'а. Хотя технически возможно разместить "
"приложение роутера на каждом узле типа хранилища, такой подход крайне не "
"рекомендуется, и его следует избегать при развертывании в "
"производственной среде."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:465
msgid ""
"All ``storage`` instances can be deployed using identical instance "
"(configuration) files."
msgstr ""
"Все хранилища можно развернуть, используя один набор файлов экземпляра "
"(конфигурационных файлов)."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:468
msgid "Self-identification is currently performed using ``tarantoolctl``:"
msgstr ""
"Самоопределение в настоящий момент осуществляется с помощью "
"``tarantoolctl``:"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:470
msgid "$ tarantoolctl instance_name"
msgstr "$ tarantoolctl имя_экземпляра"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:474
msgid ""
"All ``router`` instances can also be deployed using identical instance "
"(configuration) files."
msgstr ""
"Все роутеры также можно развернуть, используя один набор файлов "
"экземпляра (конфигурационных файлов)."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:477
msgid ""
"All cluster nodes must share a common topology. An administrator must "
"ensure that the configurations are identical. We suggest using a "
"configuration management tool like Ansible or Puppet to deploy the "
"cluster."
msgstr ""
"Топология всех узлов кластера должна быть одинаковой. Администратор "
"должен убедиться, что конфигурации совпадают. Рекомендуем использовать "
"инструмент управления конфигурациями, такой как Ansible или Puppet, во "
"время развертывания кластера."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:481
msgid ""
"Sharding is not integrated into any system for centralized configuration "
"management. It is expected that the application itself is responsible for"
" interacting with such a system and passing the sharding parameters."
msgstr ""
"Шардинг не интегрирован ни в одну систему для централизованного "
"управления конфигурациями. Предполагается, что само приложение отвечает "
"за взаимодействие с такой системой и передачу параметров шардинга."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:489
msgid "Sample configuration"
msgstr "Образец конфигурации"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:491
msgid "The configuration of a simple sharded cluster can look like this:"
msgstr ""
"Конфигурация простого сегментированного кластера может выглядеть "
"следующим образом:"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:493
msgid ""
"local cfg = {\n"
"    memtx_memory = 100 * 1024 * 1024,\n"
"    replication_connect_quorum = 0,\n"
"    bucket_count = 10000,\n"
"    rebalancer_disbalance_threshold = 10,\n"
"    rebalancer_max_receiving = 100,\n"
"    sharding = {\n"
"        ['cbf06940-0790-498b-948d-042b62cf3d29'] = {\n"
"            replicas = {\n"
"                ['8a274925-a26d-47fc-9e1b-af88ce939412'] = {\n"
"                    uri = 'storage:storage@127.0.0.1:3301',\n"
"                    name = 'storage_1_a',\n"
"                    master = true\n"
"                },\n"
"                ['3de2e3e1-9ebe-4d0d-abb1-26d301b84633'] = {\n"
"                    uri = 'storage:storage@127.0.0.1:3302',\n"
"                    name = 'storage_1_b'\n"
"                }\n"
"            },\n"
"        },\n"
"        ['ac522f65-aa94-4134-9f64-51ee384f1a54'] = {\n"
"            replicas = {\n"
"                ['1e02ae8a-afc0-4e91-ba34-843a356b8ed7'] = {\n"
"                    uri = 'storage:storage@127.0.0.1:3303',\n"
"                    name = 'storage_2_a',\n"
"                    master = true\n"
"                },\n"
"                ['001688c3-66f8-4a31-8e19-036c17d489c2'] = {\n"
"                    uri = 'storage:storage@127.0.0.1:3304',\n"
"                    name = 'storage_2_b'\n"
"                }\n"
"            },\n"
"        },\n"
"    },\n"
"}"
msgstr ""
"local cfg = {\n"
"    memtx_memory = 100 * 1024 * 1024,\n"
"    replication_connect_quorum = 0,\n"
"    bucket_count = 10000,\n"
"    rebalancer_disbalance_threshold = 10,\n"
"    rebalancer_max_receiving = 100,\n"
"    sharding = {\n"
"        ['cbf06940-0790-498b-948d-042b62cf3d29'] = {\n"
"            replicas = {\n"
"                ['8a274925-a26d-47fc-9e1b-af88ce939412'] = {\n"
"                    uri = 'storage:storage@127.0.0.1:3301',\n"
"                    name = 'storage_1_a',\n"
"                    master = true\n"
"                },\n"
"                ['3de2e3e1-9ebe-4d0d-abb1-26d301b84633'] = {\n"
"                    uri = 'storage:storage@127.0.0.1:3302',\n"
"                    name = 'storage_1_b'\n"
"                }\n"
"            },\n"
"        },\n"
"        ['ac522f65-aa94-4134-9f64-51ee384f1a54'] = {\n"
"            replicas = {\n"
"                ['1e02ae8a-afc0-4e91-ba34-843a356b8ed7'] = {\n"
"                    uri = 'storage:storage@127.0.0.1:3303',\n"
"                    name = 'storage_2_a',\n"
"                    master = true\n"
"                },\n"
"                ['001688c3-66f8-4a31-8e19-036c17d489c2'] = {\n"
"                    uri = 'storage:storage@127.0.0.1:3304',\n"
"                    name = 'storage_2_b'\n"
"                }\n"
"            },\n"
"        },\n"
"    },\n"
"}"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:531
msgid ""
"This cluster includes one ``router`` instance and two ``storage`` "
"instances. Each ``storage`` instance includes one master and one replica."
msgstr ""
"Данный кластер включает в себя один роутер (``router``) и два хранилища "
"(``storage``). Каждое хранилище включает в себя один мастер и одну "
"реплику."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:534
msgid ""
"The sharding field defines the logical topology of a sharded Tarantool "
"cluster. All the other fields are passed to ``box.cfg()`` as they are, "
"without modifications. See the :ref:`Configuration reference <vshard-"
"config-reference>` section for details."
msgstr ""
"Поле sharding (шардинг) определяет логическую топологию сегментированного"
" кластера Tarantool'а. Все остальные поля передаются в ``box.cfg()`` в "
"неизменном виде. Для получения подробной информации см. раздел "
":ref:`Справочник по настройке <vshard-config-reference>`."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:538
msgid "On routers call ``vshard.router.cfg(cfg)``:"
msgstr "На роутерах вызовите ``vshard.router.cfg(cfg)``:"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:540
msgid ""
"cfg.listen = 3300\n"
"\n"
"-- Start the database with sharding\n"
"vshard = require('vshard')\n"
"vshard.router.cfg(cfg)"
msgstr ""
"cfg.listen = 3300\n"
"\n"
"-- Запуск базы данных с шардингом\n"
"vshard = require('vshard')\n"
"vshard.router.cfg(cfg)"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:548
msgid "On storages call ``vshard.storage.cfg(cfg, instance_uuid)``:"
msgstr "На хранилищах вызовите ``vshard.storage.cfg(cfg, uuid_экземпляра)``:"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:550
msgid ""
"-- Get instance name\n"
"local MY_UUID = \"de0ea826-e71d-4a82-bbf3-b04a6413e417\"\n"
"\n"
"-- Call a configuration provider\n"
"local cfg = require('localcfg')\n"
"\n"
"-- Start the database with sharding\n"
"vshard = require('vshard')\n"
"vshard.storage.cfg(cfg, MY_UUID)"
msgstr ""
"-- Получение имени экземпляра\n"
"local MY_UUID = \"de0ea826-e71d-4a82-bbf3-b04a6413e417\"\n"
"\n"
"-- Вызов поставщика конфигурации\n"
"local cfg = require('localcfg')\n"
"\n"
"-- Запуск базы данных с шардингом\n"
"vshard = require('vshard')\n"
"vshard.storage.cfg(cfg, MY_UUID)"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:562
msgid ""
"``vshard.storage.cfg()`` automatically calls ``box.cfg()`` and configures"
" the listen port and replication parameters."
msgstr ""
"``vshard.storage.cfg()`` автоматически вызывает ``box.cfg()`` и "
"настраивает порт для прослушивания и параметры репликации."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:565
msgid ""
"See ``router.lua`` and ``storage.lua`` in the ``vshard/example`` "
"directory for a sample configuration."
msgstr ""
"Образец конфигурации можно посмотреть в файлах ``router.lua`` и "
"``storage.lua`` в директории ``vshard/example``."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:572
msgid "Replica weights"
msgstr "Вес реплики"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:574
msgid ""
"The ``router`` sends all requests to the master instance only. Setting "
"replica weights allows sending read requests not only to the master "
"instance, but to any available replica that is the 'nearest' to the "
"``router``. Weights are used to define distances between replicas within "
"a replica set."
msgstr ""
"Роутер отправляет все запросы только на мастер-экземпляр. Задав вес "
"реплики, можно разрешить отправку запросов на чтение не только на "
"мастер-экземпляр, но и на доступную реплику, которая находится ближе "
"всего к роутеру. Вес используется для определения расстояния между "
"репликами в наборе реплик."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:579
msgid ""
"Weights can be used, for example, to define the physical distance between"
" the ``router`` and each replica in each replica set. In such a case read"
" requests are sent to the nearest replica."
msgstr ""
"Например, вес можно использовать для определения физического расстояния "
"между роутером и каждой репликой в наборе реплик. В таком случае запросы "
"на чтение будут отправляться на ближайшую реплику."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:583
msgid ""
"Setting weights can also help to define the most powerful replicas: the "
"ones that can process the largest number of requests per second."
msgstr ""
"Кроме того, можно задать вес реплик, чтобы определить наиболее мощную "
"реплику, которая может обрабатывать наибольшее количество запросов в "
"секунду."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:586
msgid ""
"The idea is to specify the zone for every ``router`` and every replica, "
"therefore filling a matrix of relative zone weights. This approach allows"
" setting different weights in different zones for the same replica set."
msgstr ""
"Основная идея состоит в том, чтобы указать зону для каждого ``роутера`` и"
" каждой реплики, и таким образом составить матрицу относительных весов "
"зоны. Этот подход позволяет устанавливать разный вес в разных зонах для "
"одного набора реплик."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:590
msgid ""
"To set weights, use the zone attribute for each replica during "
"configuration:"
msgstr ""
"Чтобы задать вес, используйте атрибут zone (зона) для каждой реплики во "
"время конфигурации:"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:592
msgid ""
"local cfg = {\n"
"   sharding = {\n"
"      ['...replicaset_uuid...'] = {\n"
"         replicas = {\n"
"            ['...replica_uuid...'] = {\n"
"                 ...,\n"
"                 zone = <number or string>\n"
"            }\n"
"         }\n"
"      }\n"
"   }\n"
"}"
msgstr ""
"local cfg = {\n"
"   sharding = {\n"
"      ['...uuid_набора_реплик...'] = {\n"
"         replicas = {\n"
"            ['...uuid_реплики...'] = {\n"
"                 ...,\n"
"                 zone = <число или строка>\n"
"            }\n"
"         }\n"
"      }\n"
"   }\n"
"}"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:607
msgid ""
"Then, specify relative weights for each zone pair in the weights "
"parameter of ``vshard.router.cfg``. For example:"
msgstr ""
"Затем укажите относительный вес для каждой пары зон в параметре weights "
"(вес) в ``vshard.router.cfg``. Например:"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:610
msgid ""
"weights = {\n"
"    [1] = {\n"
"        [2] = 1, -- routers of the 1st zone see the weight of the 2nd "
"zone as 1\n"
"        [3] = 2, -- routers of the 1st zone see the weight of the 3rd "
"zone as 2\n"
"\n"
"\n"
"   [4] = 3, -- ...\n"
"    },\n"
"    [2] = {\n"
"        [1] = 10,\n"
"        [2] = 0,\n"
"        [3] = 10,\n"
"        [4] = 20,\n"
"    },\n"
"    [3] = {\n"
"        [1] = 100,\n"
"        [2] = 200, -- routers of the 3rd zone see the weight of the 2nd "
"zone as 200. Mind that it is not equal to the weight of the 2nd zone = 2 "
"visible from the 1st zone\n"
"        [4] = 1000,\n"
"    }\n"
"}\n"
"\n"
"local cfg = vshard.router.cfg({weights = weights, sharding = ...})"
msgstr ""
"weights = {\n"
"    [1] = {\n"
"        [2] = 1, -- роутеры 1 зоны видят вес 2 зоны = 1\n"
"        [3] = 2, -- роутеры 1 зоны видят вес 3 зоны = 2\n"
"\n"
"\n"
"   [4] = 3, -- ...\n"
"    },\n"
"    [2] = {\n"
"        [1] = 10,\n"
"        [2] = 0,\n"
"        [3] = 10,\n"
"        [4] = 20,\n"
"    },\n"
"    [3] = {\n"
"        [1] = 100,\n"
"        [2] = 200, -- роутеры 3 зоны видят вес 2 зоны = 200. Обратите "
"внимание, что этот вес не равен весу 2 зоны (= 2), который видят роутеры "
"1 зоны\n"
"        [4] = 1000,\n"
"    }\n"
"}\n"
"\n"
"local cfg = vshard.router.cfg({weights = weights, sharding = ...})"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:639
msgid "Replica set weights"
msgstr "Вес набора реплик"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:641
msgid ""
"A replica set weight is not the same as the replica weight. The weight of"
" a replica set defines the capacity of the replica set: the larger the "
"weight, the more buckets the replica set can store. The total size of all"
" sharded spaces in the replica set is also its capacity metric."
msgstr ""
"Вес набора реплик не равноценен весу реплики. Вес набора реплик "
"определяет производительность набора реплик: чем больше вес, тем больше "
"сегментов может хранить набор реплик. Общий размер всех сегментированных "
"спейсов в наборе реплик также определяет его производительность."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:646
msgid ""
"You can consider replica set weights as the relative amount of data "
"within a replica set. For example, if ``replicaset_1 = 100``, and "
"``replicaset_2 = 200``, the second replica set stores twice as many "
"buckets as the first one. By default, all weights of all replica sets are"
" equal."
msgstr ""
"Вес набора реплик можно рассматривать как относительный объем данных в "
"наборе реплик. Например, если ``replicaset_1 = 100``, и ``replicaset_2 = "
"200``, второй набор реплик хранит в два раза больше сегментов, чем "
"первый. По умолчанию веса всех наборов реплик равны."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:651
msgid ""
"You can use weights, for example, to store the prevailing amount of data "
"on a replica set with more memory space."
msgstr ""
"Вес можно использовать, к примеру, чтобы хранить преобладающий объем "
"данных в наборе реплик с большим объемом памяти."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:658
msgid "Rebalancing process"
msgstr "Процесс балансировки"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:660
msgid ""
"There is an **etalon number** of buckets for a replica set. (Etalon in "
"this context means \"ideal\".) If there is no deviation from this number "
"in the whole replica set, then the buckets are distributed evenly."
msgstr ""
"Существует **эталонное число** сегментов в наборе реплик (\"эталонный\" в"
" данном случае значит идеальный). Если во всем наборе реплик это число "
"остается неизменным, то сегменты распределяются равномерно."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:665
msgid ""
"The etalon number is calculated automatically considering the number of "
"buckets in the cluster and weights of the replica sets."
msgstr ""
"Эталонное число рассчитывается автоматически с учетом количества "
"сегментов в кластере и веса наборов реплик."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:668
msgid ""
"For example: The user specified the number of buckets is 3000, and "
"weights of 3 replica sets are 1, 0.5, and 1.5. The resulting etalon "
"numbers of buckets for the replica sets are: 1st replica set – 1000, 2nd "
"replica set – 500, 3rd replica set – 1500."
msgstr ""
"Например: Пользователь указал, что количество сегментов = 3000, а вес 3 "
"наборов реплик составляет 1, 0,5 и 1,5. В результате получаем следующее "
"эталонное число сегментов для наборов реплик: 1 набор реплик – 1000, 2 "
"набор реплик – 500, 3 набор реплик – 1500."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:673
msgid ""
"This approach allows assigning a zero weight to a replica set, which "
"initiates migration of its buckets to the remaining cluster nodes. It "
"also allows adding a new zero-load replica set, which initiates migration"
" of the buckets from the loaded replica sets to the zero-load replica "
"set."
msgstr ""
"Такой подход позволяет назначить нулевой вес для набора реплик, который "
"запускает миграцию сегментов на оставшиеся узлы кластера. Это также "
"позволяет добавить новый набор реплик с нулевой нагрузкой, который "
"запускает миграцию сегментов из загруженных наборов реплик в набор реплик"
" с нулевой нагрузкой."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:680
msgid ""
"A new zero-load replica set should be assigned a weight for rebalancing "
"to start."
msgstr ""
"Новому набору реплик с нулевой нагрузкой следует присвоить вес, чтобы "
"начать процесс балансировки."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:682
msgid ""
"The ``rebalancer`` wakes up periodically and redistributes data from the "
"most loaded nodes to less loaded nodes. Rebalancing starts if the "
"disbalance threshold of a replica set exceeds a disbalance threshold "
"specified in the configuration."
msgstr ""
"``Балансировщик`` периодически просыпается и перераспределяет данные из "
"наиболее загруженных узлов в менее загруженные узлы. Балансировка "
"начинается, когда предел дисбаланса в наборе реплик превышает предел "
"дисбаланса, указанный в конфигурации."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:686
msgid "The disbalance threshold is calculated as follows:"
msgstr "Предел дисбаланса рассчитывается следующим образом:"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:688
msgid "|etalon_bucket_number - real_bucket_number| / etalon_bucket_number * 100"
msgstr ""
"|эталонное_число_сегментов - текущее_число_сегментов| / "
"эталонное_число_сегментов * 100"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:692
msgid "When a new shard is added, the configuration can be updated dynamically:"
msgstr "При добавлении нового шарда конфигурацию можно обновить динамически:"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:694
msgid ""
"The configuration should be updated on all the ``routers`` first, and "
"then on all the ``storages``."
msgstr ""
"Конфигурацию следует сначала обновить на всех роутерах, а затем на всех "
"хранилищах."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:696
msgid "The new shard becomes available for rebalancing in the ``storage`` layer."
msgstr "Новый шард становится доступен для балансирования на уровне хранилища."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:697
msgid "As a result of rebalancing, buckets are migrated to the new shard."
msgstr "В результате балансировки происходит миграция сегментов на новый шард."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:698
msgid ""
"If a migrated bucket is requested, ``router`` receives an error code "
"containing information about the new location of the bucket."
msgstr ""
"Если происходит запрос к перемещенному сегменту, ``роутер`` получает код "
"ошибки с информацией о новом местонахождении сегмента."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:701
msgid ""
"At this time, the new shard is already present in the ``router``'s pool "
"of connections, so redirection is transparent for the application."
msgstr ""
"В это время новый шард уже включен в пул соединений ``роутера``, поэтому "
"переадресация видима для приложения."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:708
msgid "Replica set lock and bucket pin"
msgstr "Блокировка набора реплик и закрепление корзины"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:710
msgid ""
"A replica set lock makes a replica set invisible to the ``rebalancer``: a"
" locked replica set can neither receive new buckets nor migrate its own "
"buckets."
msgstr ""
"Блокировка набора реплик делает набор реплик невидимым для "
"балансировщика: заблокированный набор реплик не может ни принимать новые "
"сегменты, ни мигрировать собственные сегменты."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:713
msgid ""
"A bucket pin blocks a specific bucket from migrating: a pinned bucket "
"stays on the replica set to which it is pinned, until it is unpinned."
msgstr ""
"В результате закрепления сегмента определенный сегмент блокируется для "
"миграции: закрепленный сегмент остается в наборе реплик, в котором он "
"закреплен, до отмены закрепления."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:716
msgid ""
"Pinning all replica set buckets is not equivalent to locking a replica "
"set. Even if you pin all buckets, a non-locked replica set can still "
"receive new buckets."
msgstr ""
"Закрепление всех сегментов в наборе реплик не означает блокирование "
"набора реплик. Даже после закрепления всех сегментов незаблокированный "
"набор реплик может принимать новые сегменты."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:719
msgid ""
"Replica set lock is helpful, for example, to separate a replica set from "
"production replica sets for testing, or to preserve some application "
"metadata that must not be sharded for a while. A bucket pin is used for "
"similar cases but in a smaller scope."
msgstr ""
"Блокировка набора реплик используется, к примеру, чтобы выделить для "
"тестирования набор реплик из наборов реплик, используемых в производстве,"
" или чтобы сохранить некоторые метаданные приложения, которые в течение "
"некоторого времени не должны быть сегментированы. Закрепление сегмента "
"используется в похожих случаях, но в меньшем масштабе."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:724
msgid ""
"By both locking a replica set and pinning all buckets, one can isolate an"
" entire replica set."
msgstr ""
"Блокировка набора реплик и закрепление всех сегментов означает изоляцию "
"целого набора реплик."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:727
msgid ""
"Locked replica sets and pinned buckets affect the rebalancing algorithm "
"as the ``rebalancer`` must ignore locked replica sets and consider pinned"
" buckets when attempting to reach the best possible balance."
msgstr ""
"Заблокированные наборы реплик и закрепленные сегменты влияют на алгоритм "
"балансировки, так как ``балансировщик`` должен игнорировать "
"заблокированные наборы реплик и учитывать закрепленные сегменты при "
"попытке достичь наилучшего возможного баланса."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:731
msgid ""
"The issue is not trivial as a user can pin too many buckets to a replica "
"set, so a perfect balance becomes unreachable. For example, consider the "
"following cluster (assume all replica set weights are equal to 1)."
msgstr ""
"Это нетривиальная задача, поскольку пользователь может закрепить слишком "
"много сегментов в наборе реплик, так что становится невозможным "
"достижение идеального баланса. Например, рассмотрим следующий кластер "
"(предположим, что все веса наборов реплик равны 1)."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:735
msgid "The initial configuration:"
msgstr "Начальная конфигурация:"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:737
msgid ""
"rs1: bucket_count = 150\n"
"rs2: bucket_count = 150, pinned_count = 120"
msgstr ""
"rs1: bucket_count = 150 -- число сегментов\n"
"rs2: bucket_count = 150, pinned_count = 120 -- число сегментов, число "
"закрепленных сегментов"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:742
msgid "Adding a new replica set:"
msgstr "Добавление нового набора реплик:"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:744
msgid ""
"rs1: bucket_count = 150\n"
"rs2: bucket_count = 150, pinned_count = 120\n"
"rs3: bucket_count = 0"
msgstr ""
"rs1: bucket_count = 150\n"
"rs2: bucket_count = 150, pinned_count = 120\n"
"rs3: bucket_count = 0"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:750
msgid ""
"The perfect balance would be ``100 - 100 - 100``, which is impossible "
"since the ``rs2`` replica set has 120 pinned buckets. The best possible "
"balance here is the following:"
msgstr ""
"Идеальным балансом было бы ``100 - 100 - 100``, чего невозможно достичь, "
"поскольку набор реплик ``rs2`` содержит 120 закрепленных сегментов. The "
"best possible balance here is the following:"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:754
msgid ""
"rs1: bucket_count = 90\n"
"rs2: bucket_count = 120, pinned_count 120\n"
"rs3: bucket_count = 90"
msgstr ""
"rs1: bucket_count = 90\n"
"rs2: bucket_count = 120, pinned_count 120\n"
"rs3: bucket_count = 90"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:760
msgid ""
"The ``rebalancer`` moved as many buckets as possible from ``rs2`` to "
"decrease the disbalance. At the same time it respected equal weights of "
"``rs1`` and ``rs3``."
msgstr ""
"``Балансировщик`` переместил максимально возможное количество сегментов "
"из ``rs2``, чтобы уменьшить дисбаланс. В то же время он учел одинаковый "
"вес respected ``rs1`` и ``rs3``."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:763
msgid ""
"The algorithms for implementing locks and pins are completely different, "
"although they look similar in terms of functionality."
msgstr ""
"Алгоритмы реализации блокировки и закрепления совершенно разные, хотя с "
"точки зрения функций они похожи."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:770
msgid "Replica set lock and rebalancing"
msgstr "Заблокированный набор реплик и балансировка"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:772
msgid ""
"Locked replica sets simply do not participate in rebalancing. This means "
"that even if the actual total number of buckets is not equal to the "
"etalon number, the disbalance cannot be fixed due to the lock. When the "
"rebalancer detects that one of the replica sets is locked, it "
"recalculates the etalon number of buckets of the non-locked replica sets "
"as if the locked replica set and its buckets did not exist at all."
msgstr ""
"Заблокированные наборы реплик просто не участвуют в балансировке. Это "
"означает, что даже если фактическое общее количество сегментов не равно "
"эталонному числу, дисбаланс нельзя исправить из-за блокировки. Когда "
"балансировщик обнаруживает, что один из наборов реплик заблокирован, он "
"пересчитывает эталонное число сегментов неблокированных наборов реплик, "
"как если бы заблокированный набор реплик и его сегменты вообще не "
"существовали."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:783
msgid "Bucket pin and rebalancing"
msgstr "Закрепленный набор реплик и балансировка"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:785
msgid ""
"Rebalancing replica sets with pinned buckets requires a more complex "
"algorithm. Here pinned_count[o] is the number of pinned buckets, and "
"``etalon_count`` is the etalon number of buckets for a replica set:"
msgstr ""
"Балансировка наборов реплик с закрепленными сегментами требует более "
"сложного алгоритма. Здесь pinned_count[o] -- это число закрепленных "
"сегментов, а ``etalon_count`` -- это эталонное число сегментов для набора"
" реплик:"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:789
msgid ""
"The ``rebalancer`` calculates the etalon number of buckets as if all "
"buckets were not pinned. Then the rebalancer checks each replica set and "
"compares the etalon number of buckets with the number of pinned buckets "
"in a replica set. If ``pinned_count < etalon_count``, non-locked replica "
"sets (at this point all locked replica sets already are filtered out) "
"with pinned buckets can receive new buckets."
msgstr ""
"Балансировщик рассчитывает эталонное число сегментов, как если бы все "
"сегменты не были закреплены. Затем балансировщик проверяет каждый набор "
"реплик и сопоставляет эталонное число сегментов с числом закрепленных "
"сегментов в наборе реплик. Если ``pinned_count < etalon_count``, "
"незаблокированные наборы реплик (на данном этапе все заблокированные "
"наборы реплик уже отфильтрованы) с закрепленными сегментами могут "
"получать новые сегменты."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:795
msgid ""
"If ``pinned_count > etalon_count``, the disbalance cannot be fixed, as "
"the ``rebalancer`` cannot move pinned buckets out of this replica set. In"
" such a case the etalon number is updated and set equal to the number of "
"pinned buckets. The replica sets with ``pinned_count > etalon_count`` are"
" not processed by the ``rebalancer``, and the number of pinned buckets is"
" subtracted from the total number of buckets. The rebalancer tries to "
"move out as many buckets as possible from such replica sets."
msgstr ""
"Если же ``pinned_count > etalon_count``, дисбаланс исправить нельзя, так "
"как балансировщик не может вывести закрепленные сегменты из этого набора "
"реплик. В таком случае эталонное число обновляется как равное числу "
"закрепленных сегментов. Наборы реплик с ``pinned_count > etalon_count`` "
"не обрабатываются балансировщиком`, а число закрепленных сегментов "
"вычитается из общего числа сегментов. Балансировщик пытается вывести как "
"можно больше сегментов из таких наборов реплик."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:802
msgid ""
"This procedure is restarted from step 1 for replica sets with "
"``pinned_count >= etalon_count`` until ``pinned_count <= etalon_count`` "
"on all replica sets. The procedure is also restarted when the total "
"number of buckets is changed."
msgstr ""
"Эта процедура перезапускается с шага 1 для наборов реплик с "
"``pinned_count >= etalon_count`` до тех пор, пока не будет выполнено "
"условие ``pinned_count <= etalon_count`` для всех наборов реплик. "
"Процедура также перезапускается при изменении общего числа сегментов."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:807
msgid "Here is the pseudocode for the algorithm:"
msgstr "Псевдокод для данного алгоритма будет следующим:"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:809
msgid ""
"function cluster_calculate_perfect_balance(replicasets, bucket_count)\n"
"        -- rebalance the buckets using weights of the still viable "
"replica sets --\n"
"end;\n"
"\n"
"cluster = <all of the non-locked replica sets>;\n"
"bucket_count = <the total number of buckets in the cluster>;\n"
"can_reach_balance = false\n"
"while not can_reach_balance do\n"
"        can_reach_balance = true\n"
"        cluster_calculate_perfect_balance(cluster, bucket_count);\n"
"        foreach replicaset in cluster do\n"
"                if replicaset.perfect_bucket_count <\n"
"                   replicaset.pinned_bucket_count then\n"
"                        can_reach_balance = false\n"
"                        bucket_count -= replicaset.pinned_bucket_count;\n"
"                        replicaset.perfect_bucket_count =\n"
"                                replicaset.pinned_bucket_count;\n"
"                end;\n"
"        end;\n"
"end;\n"
"cluster_calculate_perfect_balance(cluster, bucket_count);"
msgstr ""
"function cluster_calculate_perfect_balance(replicasets, bucket_count)\n"
"        -- балансировка сегментов с использованием веса рабочих наборов "
"реплик --\n"
"end;\n"
"\n"
"cluster = <all of the non-locked replica sets>;\n"
"bucket_count = <the total number of buckets in the cluster>;\n"
"can_reach_balance = false\n"
"while not can_reach_balance do\n"
"        can_reach_balance = true\n"
"        cluster_calculate_perfect_balance(cluster, bucket_count);\n"
"        foreach replicaset in cluster do\n"
"                if replicaset.perfect_bucket_count <\n"
"                   replicaset.pinned_bucket_count then\n"
"                        can_reach_balance = false\n"
"                        bucket_count -= replicaset.pinned_bucket_count;\n"
"                        replicaset.perfect_bucket_count =\n"
"                                replicaset.pinned_bucket_count;\n"
"                end;\n"
"        end;\n"
"end;\n"
"cluster_calculate_perfect_balance(cluster, bucket_count);"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:833
msgid ""
"The complexity of the algorithm is ``O(N^2)``, where N is the number of "
"replica sets. On each step, the algorithm either finishes the "
"calculation, or ignores at least one new replica set overloaded with the "
"pinned buckets, and updates the etalon number of buckets on other replica"
" sets."
msgstr ""
"Сложность алгоритма составляет ``O(N^2)``, где N -- количество наборов "
"реплик. На каждом шаге алгоритм либо завершает вычисление, либо "
"игнорирует хотя бы один новый набор реплик, перегруженный закрепленными "
"сегментами, и обновляет эталонное число сегментов в других наборах "
"реплик."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:842
msgid "Bucket ref"
msgstr "Ссылка в сегменте"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:844
msgid ""
"Bucket ref is an in-memory counter that is similar to the :ref:`bucket "
"pin <vshard-lock-pin>`, but has the following differences:"
msgstr ""
"Ссылка в сегменте -- это счетчик в оперативной памяти, который похож на "
":ref:`закрепление сегмента <vshard-lock-pin>` со следующими отличиями:"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:847
msgid ""
"Bucket ref is not persistent. Refs are intended for forbidding bucket "
"transfer during request execution, but on restart all requests are "
"dropped."
msgstr ""
"Ссылка в сегменте никогда не сохраняется. Ссылки предназначены для "
"запрета передачи сегментов во время выполнения запроса, но при "
"перезапуске все запросы отбрасываются."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:850
msgid "There are two types of bucket refs: read-only (RO) and read-write (RW)."
msgstr "Есть 2 типа ссылок в сегменте: только чтение (RO) и чтение-запись (RW)."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:852
msgid ""
"If a bucket has RW refs, it can not be moved. However, when the "
"rebalancer needs it to be sent, it locks the bucket for new write "
"requests, waits until all current requests are finished, and then sends "
"the bucket."
msgstr ""
"Если в сегменте есть ссылки типа RW, его нельзя перемещать. Однако, если "
"балансировщику требуется отправка этого сегмента, он блокирует его для "
"новых запросов на запись, ожидает завершения всех текущих запросов, а "
"затем отправляет сегмент."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:857
msgid ""
"If a bucket has RO refs, it can be sent, but cannot be dropped. Such a "
"bucket can even enter GARBAGE or SENT state, but its data is kept until "
"the last reader is gone."
msgstr ""
"Если в сегменте есть ссылки типа RO, его можно отправить, но нельзя "
"удалить. Такой сегмент может даже перейти в статус мусора GARBAGE или "
"отправки SENT, но его данные сохраняются до тех пор, пока не уйдет "
"последний читатель."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:861
msgid "A single bucket can have both RO and RW refs."
msgstr "В одном сегменте могут быть ссылки как типа RO, так и типа RW."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:863
msgid "Bucket ref is countable."
msgstr "Ссылки в сегменте исчисляются."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:865
msgid ""
"The :ref:`vshard.storage.bucket_ref/unref()<storage_api-bucket_ref>` "
"methods are called automatically when :ref:`vshard.router.call() "
"<router_api-call>` or :ref:`vshard.storage.call() <storage_api-call>` is "
"used. For raw API like ``r = vshard.router.route() r:callro/callrw`` you "
"should explicitly call the ``bucket_ref()`` method inside the function. "
"Also, make sure that you call ``bucket_unref()`` after ``bucket_ref()``, "
"otherwise the bucket cannot be moved from the storage until the instance "
"restart."
msgstr ""
"Методы :ref:`vshard.storage.bucket_ref/unref()<storage_api-bucket_ref>` "
"вызываются автоматически при использовании :ref:`vshard.router.call() "
"<router_api-call>` или :ref:`vshard.storage.call() <storage_api-call>`. "
"При использовании API, например ``r = vshard.router.route() "
"r:callro/callrw``, следует дополнительно вызвать метод ``bucket_ref()`` в"
" рамках функции. Кроме того, следует убедиться, что после "
"``bucket_ref()`` вызывается ``bucket_unref()``, иначе сегмент нельзя "
"перемещать из хранилища до перезапуска экземпляра."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:873
msgid ""
"To see how many refs there are for a bucket, use "
":ref:`vshard.storage.buckets_info([bucket_id]) <storage_api-"
"buckets_info>` (the ``bucket_id`` parameter is optional)."
msgstr ""
"Чтобы узнать количество ссылок в сегменте, используйте "
":ref:`vshard.storage.buckets_info([идентификатор_сегмента]) <storage_api-"
"buckets_info>` (параметр ``идентификатор_сегмента`` необязателен)."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:879
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1891
msgid ""
"vshard.storage.buckets_info(1)\n"
"---\n"
"- 1:\n"
"    status: active\n"
"    ref_rw: 1\n"
"    ref_ro: 1\n"
"    ro_lock: true\n"
"    rw_lock: true\n"
"    id: 1"
msgstr ""
"vshard.storage.buckets_info(1)\n"
"---\n"
"- 1:\n"
"    status: active\n"
"    ref_rw: 1\n"
"    ref_ro: 1\n"
"    ro_lock: true\n"
"    rw_lock: true\n"
"    id: 1"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:895
msgid "Defining spaces"
msgstr "Определение спейса"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:897
msgid ""
"Spaces should be defined within a storage application using "
"``box.once()``. For example:"
msgstr ""
"В приложении хранилища следует определить спейсы с помощью "
"``box.once()``. Например:"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:900
msgid ""
"box.once(\"testapp:schema:1\", function()\n"
"    local customer = box.schema.space.create('customer')\n"
"    customer:format({\n"
"        {'customer_id', 'unsigned'},\n"
"        {'bucket_id', 'unsigned'},\n"
"        {'name', 'string'},\n"
"    })\n"
"    customer:create_index('customer_id', {parts = {'customer_id'}})\n"
"    customer:create_index('bucket_id', {parts = {'bucket_id'}, unique = "
"false})\n"
"\n"
"    local account = box.schema.space.create('account')\n"
"    account:format({\n"
"        {'account_id', 'unsigned'},\n"
"        {'customer_id', 'unsigned'},\n"
"        {'bucket_id', 'unsigned'},\n"
"        {'balance', 'unsigned'},\n"
"        {'name', 'string'},\n"
"    })\n"
"    account:create_index('account_id', {parts = {'account_id'}})\n"
"    account:create_index('customer_id', {parts = {'customer_id'}, unique "
"= false})\n"
"    account:create_index('bucket_id', {parts = {'bucket_id'}, unique = "
"false})\n"
"    box.snapshot()\n"
"\n"
"    box.schema.func.create('customer_lookup')\n"
"    box.schema.role.grant('public', 'execute', 'function', "
"'customer_lookup')\n"
"    box.schema.func.create('customer_add')\n"
"end)"
msgstr ""
"box.once(\"testapp:schema:1\", function()\n"
"    local customer = box.schema.space.create('customer')\n"
"    customer:format({\n"
"        {'customer_id', 'unsigned'},\n"
"        {'bucket_id', 'unsigned'},\n"
"        {'name', 'string'},\n"
"    })\n"
"    customer:create_index('customer_id', {parts = {'customer_id'}})\n"
"    customer:create_index('bucket_id', {parts = {'bucket_id'}, unique = "
"false})\n"
"\n"
"    local account = box.schema.space.create('account')\n"
"    account:format({\n"
"        {'account_id', 'unsigned'},\n"
"        {'customer_id', 'unsigned'},\n"
"        {'bucket_id', 'unsigned'},\n"
"        {'balance', 'unsigned'},\n"
"        {'name', 'string'},\n"
"    })\n"
"    account:create_index('account_id', {parts = {'account_id'}})\n"
"    account:create_index('customer_id', {parts = {'customer_id'}, unique "
"= false})\n"
"    account:create_index('bucket_id', {parts = {'bucket_id'}, unique = "
"false})\n"
"    box.snapshot()\n"
"\n"
"    box.schema.func.create('customer_lookup')\n"
"    box.schema.role.grant('public', 'execute', 'function', "
"'customer_lookup')\n"
"    box.schema.func.create('customer_add')\n"
"end)"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:934
msgid "Bootstrapping and restarting a storage"
msgstr "Настройка и перезапуск хранилища"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:936
msgid "If a replica set master fails, it is recommended to:"
msgstr "В случае отказа мастера в наборе реплик рекомендуется:"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:938
msgid ""
"Switch one of the replicas into the master mode. This allows the new "
"master to process all the incoming requests."
msgstr ""
"Переключить одну из реплик в режим мастера, что позволит новому мастеру "
"обрабатывать все входящие запросы."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:940
msgid ""
"Update the configuration of all the cluster members. This forwards all "
"the requests to the new master."
msgstr ""
"Обновить конфигурацию всех членов кластера, в результате чего все запросы"
" будут перенаправлены на новый мастер."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:943
msgid ""
"Monitoring the master and switching the instance modes can be handled by "
"any external utility."
msgstr ""
"Мониторинг состояния мастера и переключение режимов экземпляров можно "
"осуществлять с помощью внешней утилиты."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:946
msgid ""
"To perform a scheduled downtime of a replica set master, it is "
"recommended to:"
msgstr ""
"Для проведения запланированного остановки мастера в наборе реплик "
"рекомендуется:"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:948
msgid ""
"Update the configuration of the master and wait for the replicas to get "
"into sync. All the requests then are forwarded to a new master."
msgstr ""
"Обновить конфигурацию мастера и подождать синхронизации всех реплик, в "
"результате чего все запросы будут перенаправлены на новый мастер."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:950
msgid "Switch another instance into the master mode."
msgstr "Переключить другой экземпляр в режим мастера."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:951
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:957
msgid "Update the configuration of all the nodes."
msgstr "Обновить конфигурацию всех узлов."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:952
msgid "Shut down the old master."
msgstr "Отключить старый мастер."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:954
msgid "To perform a scheduled downtime of a replica set, it is recommended to:"
msgstr "Для проведения запланированной остановки набора реплик рекомендуется:"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:956
msgid "Migrate all the buckets to the other cluster storages."
msgstr "Произвести миграцию всех сегментов в другие хранилища кластера."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:958
msgid "Shut down the replica set."
msgstr "Отключить набор реплик."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:960
msgid ""
"In case a whole replica set fails, some part of the dataset becomes "
"inaccessible. Meanwhile, the ``router`` tries to reconnect to the master "
"of the failed replica set. This way, once the replica set is up and "
"running again, the cluster is automatically restored."
msgstr ""
"В случае отказа всего набора реплик некоторая часть набора данных "
"становится недоступной. Тем временем ``роутер`` пытается повторно "
"подключиться к мастеру отказавшего набора реплик. Таким образом, после "
"того, как набор реплик снова запущен, кластер автоматически "
"восстанавливается."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:971
msgid ""
"Searches for buckets, buckets recovery, and buckets rebalancing are "
"performed automatically and do not require human intervention."
msgstr ""
"Поиск сегментов, восстановление сегментов и балансировка сегментов "
"выполняются автоматически и не требуют вмешательства человека."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:974
msgid ""
"Technically, there are multiple fibers responsible for different types of"
" operations:"
msgstr ""
"С технической точки зрения есть несколько файберов, которые отвечают за "
"различные типы действий:"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:977
msgid ""
"a **discovery** fiber on the ``router`` searches for buckets in the "
"background"
msgstr ""
"файбер **обнаружения** на ``роутере`` выполняет поиск сегментов в фоновом"
" режиме"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:978
msgid "a **failover** fiber on the ``router`` maintains replica connections"
msgstr ""
"файбер **восстановления после отказа** на ``роутере`` поддерживает "
"соединения с репликами"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:979
msgid ""
"a **garbage collector** fiber on each master ``storage`` removes the "
"contents of buckets that were moved"
msgstr ""
"файбер **сборки мусора** на каждом мастер-хранилище удаляет содержимое "
"перемещенных сегментов"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:981
msgid ""
"a **bucket recovery** fiber on each master ``storage`` recovers buckets "
"in the SENDING and RECEIVING states in case of reboot"
msgstr ""
"файбер **восстановления сегмента** на каждом мастер-хранилище "
"восстанавливает сегменты в статусах отправки SENDING и получения "
"RECEIVING в случае перезагрузки"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:983
msgid ""
"a **rebalancer** on a single master ``storage`` among all replica sets "
"executes the rebalancing process."
msgstr ""
"**балансировщик** на отдельном мастер-хранилище среди множества наборов "
"реплик выполняет процесс балансировки."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:986
msgid ""
"See the :ref:`Rebalancing process <vshard-rebalancing>` section for "
"details."
msgstr ""
"Для получения подробной информации см. раздел :ref:`Процесс балансировки "
"<vshard-rebalancing>`."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:992
msgid "Garbage collector"
msgstr "Сборщик мусора"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:994
msgid ""
"A **garbage collector** fiber runs in the background on the master "
"storages of each replica set. It starts deleting the contents of the "
"bucket in the GARBAGE state part by part. Once the bucket is empty, its "
"record is deleted from the ``_bucket`` system space."
msgstr ""
"Файбер **сборщик мусора** работает в фоновом режиме на мастер-хранилищах "
"в каждом наборе реплик. Он начинает удалять содержимое сегмента в "
"состоянии мусора GARBAGE по частям. Когда сегмент пуст, запись о нем "
"удаляется из системного спейса ``_bucket``."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1003
msgid "Bucket recovery"
msgstr "Восстановление сегмента"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1005
msgid ""
"A **bucket recovery** fiber runs on the master storages. It helps to "
"recover buckets in the SENDING and RECEIVING states in case of reboot."
msgstr ""
"Файбер **восстановления сегмента** работает на мастер-хранилищах. Он "
"помогает восстановить сегменты в статусах отправки SENDING и получения "
"RECEIVING в случае перезагрузки."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1008
msgid "Buckets in the SENDING state are recovered as follows:"
msgstr "Сегменты в статусе SENDING восстанавливаются следующим образом:"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1010
msgid "The system first searches for buckets in the SENDING state."
msgstr "Сначала система ищет сегменты в статусе SENDING."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1011
msgid ""
"If such a bucket is found, the system sends a request to the destination "
"replica set."
msgstr ""
"Если такой сегмент обнаружен, система отправляет запрос в целевой набор "
"реплик."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1013
msgid ""
"If the bucket on the destination replica set is ACTIVE, the original "
"bucket is deleted from the source node."
msgstr ""
"Если сегмент в целевом наборе реплик находится в активном статусе ACTIVE,"
" исходный сегмент удаляется из исходного узла."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1016
msgid "Buckets in the RECEIVING state are deleted without extra checks."
msgstr "Сегменты в статусе RECEIVING удаляются без дополнительных проверок."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1022
msgid "Failover"
msgstr "Восстановление после отказа"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1024
msgid ""
"A **failover** fiber runs on every ``router``. If a master of a replica "
"set becomes unavailable, the failover fiber redirects read requests to "
"the replicas. Write requests are rejected with an error until the master "
"becomes available."
msgstr ""
"Файбер **восстановления после отказа** работает на каждом роутере. Если "
"мастер набора реплик становится недоступным, файбер перенаправляет "
"запросы на чтение к репликам. Запросы на запись отклоняются с ошибкой до "
"тех пор, пока мастер не будет доступен."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1040
msgid ":ref:`sharding <cfg_basic-sharding>`"
msgstr ":ref:`sharding <cfg_basic-sharding>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1041
msgid ":ref:`weights <cfg_basic-weights>`"
msgstr ":ref:`weights <cfg_basic-weights>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1042
msgid ":ref:`shard_index <cfg_basic-shard_index>`"
msgstr ":ref:`shard_index <cfg_basic-shard_index>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1043
msgid ":ref:`bucket_count <cfg_basic-bucket_count>`"
msgstr ":ref:`bucket_count <cfg_basic-bucket_count>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1044
msgid ""
":ref:`collect_bucket_garbage_interval <cfg_basic-"
"collect_bucket_garbage_interval>`"
msgstr ""
":ref:`collect_bucket_garbage_interval <cfg_basic-"
"collect_bucket_garbage_interval>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1045
msgid ":ref:`collect_lua_garbage <cfg_basic-collect_lua_garbage>`"
msgstr ":ref:`collect_lua_garbage <cfg_basic-collect_lua_garbage>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1046
msgid ":ref:`sync_timeout <cfg_basic-sync_timeout>`"
msgstr ":ref:`sync_timeout <cfg_basic-sync_timeout>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1047
msgid ""
":ref:`rebalancer_disbalance_threshold <cfg_basic-"
"rebalancer_disbalance_threshold>`"
msgstr ""
":ref:`rebalancer_disbalance_threshold <cfg_basic-"
"rebalancer_disbalance_threshold>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1048
msgid ":ref:`rebalancer_max_receiving <cfg_basic-rebalancer_max_receiving>`"
msgstr ":ref:`rebalancer_max_receiving <cfg_basic-rebalancer_max_receiving>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1054
msgid "A field defining the logical topology of the sharded Tarantool cluster."
msgstr ""
"Поле, которое определяет логическую топологию сегментированного кластера "
"Tarantool'а."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1056
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1067
msgid "Type: table"
msgstr "Тип: таблица"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1064
msgid ""
"A field defining the configuration of relative weights for each zone pair"
" in a replica set. See the :ref:`Replica weights <vshard-replica-"
"weights>` section."
msgstr ""
"Поле, которое определяет конфигурацию относительного веса для каждой пары"
" зон в наборе реплик. См. раздел :ref:`Вес реплики <vshard-replica-"
"weights>`."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1075
msgid "An index over the bucket id."
msgstr "Индекс по идентификатору сегмента."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1077
msgid "Type: non-empty string or non-negative integer"
msgstr "Тип: непустая строка или неотрицательное целое число"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1078
msgid "Default: coincides with the bucket id number"
msgstr "По умолчанию: совпадает с числом идентификатора сегмента"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1085
msgid "The total number of buckets in a cluster."
msgstr "Общее число сегментов в кластере."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1087
msgid ""
"This number should be several orders of magnitude larger than the "
"potential number of cluster nodes, considering potential scaling out in "
"the foreseeable future."
msgstr ""
"Это число должно быть на несколько порядков больше, чем потенциальное "
"число узлов кластера, учитывая потенциальное масштабирование в обозримом "
"будущем."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1092
msgid ""
"If the estimated number of nodes is M, then the data set should be "
"divided into 100M or even 1000M buckets, depending on the planned scaling"
" out. This number is certainly greater than the potential number of "
"cluster nodes in the system being designed."
msgstr ""
"Если предполагаемое количество узлов равно M, тогда набор данных должен "
"быть разделен на 100M или даже 1000M сегментов, в зависимости от "
"запланированного масштабирования. Это число, безусловно, больше "
"потенциального числа узлов кластера в проектируемой системе."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1097
msgid ""
"Keep in mind that too many buckets can cause a need to allocate more "
"memory to store routing information. On the other hand, an insufficient "
"number of buckets can lead to decreased granularity when rebalancing."
msgstr ""
"Следует помнить, что слишком большое число сегментов может привести к "
"необходимости выделять больше памяти для хранения информации о "
"маршрутизации. С другой стороны, недостаточное число сегментов может "
"привести к снижению степени детализации при балансировке."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1101
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1111
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1133
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1148
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1169
msgid "Type: number"
msgstr "Тип: число"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1102
msgid "Default: 3000"
msgstr "По умолчанию: 3000"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1109
msgid "The interval between garbage collector actions, in seconds."
msgstr "Интервал между действиями сборщика мусора в секундах."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1119
msgid "If set to true, the Lua collectgarbage() function is called periodically."
msgstr ""
"Если задано значение true (правда), периодически вызывается Lua-функция "
"collectgarbage()."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1122
msgid "Default: no"
msgstr "По умолчанию: нет"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1129
msgid ""
"Timeout to wait for synchronization of the old master with replicas "
"before demotion. Used when switching a master or when manually calling "
"the ``sync()`` function."
msgstr ""
"Время ожидания синхронизации старого мастера с репликами перед сменой "
"мастера. Используется при переключении мастера или при вызове функции "
"``sync()`` вручную."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1141
msgid ""
"A maximum bucket disbalance threshold, in percent. The threshold is "
"calculated for each replica set using the following formula:"
msgstr ""
"Максимальный предел дисбаланса сегментов в процентах. Предел вычисляется "
"для каждого набора реплик по следующей формуле:"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1144
msgid "|etalon_bucket_count - real_bucket_count| / etalon_bucket_count * 100"
msgstr ""
"|эталонное_число_сегментов - фактическое_число_сегментов| / "
"эталонное_число_сегментов * 100"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1156
msgid ""
"The maximum number of buckets that can be received in parallel by a "
"single replica set. This number must be limited, because when a new "
"replica set is added to a cluster, the rebalancer sends a very large "
"amount of buckets from the existing replica sets to the new replica set. "
"This produces a heavy load on a new replica set."
msgstr ""
"Максимальное количество сегментов, которые может получить параллельно "
"один набор реплик. Это число должно быть ограничено, так как при "
"добавлении нового набора реплик в кластер балансировщик отправляет очень "
"большое количество сегментов из существующих наборов реплик в новый набор"
" реплик. Это создает большую нагрузку на новый набор реплик."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1163
msgid ""
"Suppose ``rebalancer_max_receiving`` is equal to 100, ``bucket_count`` is"
" equal to 1000. There are 3 replica sets with 333, 333 and 334 buckets on"
" each respectively. When a new replica set is added, each replica set’s "
"``etalon_bucket_count`` becomes equal to 250. Rather than receiving all "
"250 buckets at once, the new replica set receives 100, 100 and 50 buckets"
" sequentially."
msgstr ""
"Предположим, ``rebalancer_max_receiving`` = 100, число сегментов в "
"``bucket_count`` = 1000. Есть 3 набора реплик с 333, 333 и 334 сегментами"
" соответственно. При добавлении нового набора реплик "
"``эталонное_число_сегментов`` становится равным 250. Вместо того, чтобы "
"сразу получить все 250 сегментов, новый набор реплик получит "
"последовательно 100, 100 и 50 сегментов."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1170
msgid "Default: 100"
msgstr "По умолчанию: 100"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1177
msgid "Replica set functions"
msgstr "Функции набора реплик"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1179
msgid ":ref:`uuid <cfg_replica_set-uuid>`"
msgstr ":ref:`uuid <cfg_replica_set-uuid>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1180
msgid ":ref:`weight <cfg_replica_set-weight>`"
msgstr ":ref:`weight <cfg_replica_set-weight>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1186
msgid "A unique identifier of a replica set."
msgstr "Уникальный идентификатор набора реплик."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1188
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1199
msgid "Type:"
msgstr "Тип:"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1189
msgid "Default:"
msgstr "По умолчанию:"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1190
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1201
msgid "Dynamic:"
msgstr "Динамическое:"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1196
msgid ""
"A weight of a replica set. See the :ref:`Replica set weights <vshard-"
"replica-set-weights>` section for details."
msgstr ""
"Вес набора реплик. Для получения подробной информации см. раздел "
":ref:`Вес набора реплик <vshard-replica-set-weights>`."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1207
msgid "API reference"
msgstr "Справочник по API"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1213
msgid "Router public API"
msgstr "Общедоступные API роутера"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1215
msgid ":ref:`vshard.router.bootstrap() <router_api-bootstrap>`"
msgstr ":ref:`vshard.router.bootstrap() <router_api-bootstrap>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1216
msgid ":ref:`vshard.router.cfg(cfg) <router_api-cfg>`"
msgstr ":ref:`vshard.router.cfg(cfg) <router_api-cfg>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1217
msgid ":ref:`vshard.router.new(name, cfg) <router_api-new>`"
msgstr ":ref:`vshard.router.new(name, cfg) <router_api-new>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1218
msgid ""
":ref:`vshard.router.call(bucket_id, mode, function_name, {argument_list},"
" {options}) <router_api-call>`"
msgstr ""
":ref:`vshard.router.call(bucket_id, mode, function_name, {argument_list},"
" {options}) <router_api-call>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1219
msgid ""
":ref:`vshard.router.callro(bucket_id, function_name, {argument_list}, "
"{options}) <router_api-callro>`"
msgstr ""
":ref:`vshard.router.callro(bucket_id, function_name, {argument_list}, "
"{options}) <router_api-callro>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1220
msgid ""
":ref:`vshard.router.callrw(bucket_id, function_name, {argument_list}, "
"{options}) <router_api-callrw>`"
msgstr ""
":ref:`vshard.router.callrw(bucket_id, function_name, {argument_list}, "
"{options}) <router_api-callrw>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1221
msgid ""
":ref:`vshard.router.callre(bucket_id, function_name, {argument_list}, "
"{options}) <router_api-callre>`"
msgstr ""
":ref:`vshard.router.callre(bucket_id, function_name, {argument_list}, "
"{options}) <router_api-callre>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1222
msgid ""
":ref:`vshard.router.callbro(bucket_id, function_name, {argument_list}, "
"{options}) <router_api-callbro>`"
msgstr ""
":ref:`vshard.router.callbro(bucket_id, function_name, {argument_list}, "
"{options}) <router_api-callbro>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1223
msgid ""
":ref:`vshard.router.callbre(bucket_id, function_name, {argument_list}, "
"{options}) <router_api-callbre>`"
msgstr ""
":ref:`vshard.router.callbre(bucket_id, function_name, {argument_list}, "
"{options}) <router_api-callbre>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1224
msgid ":ref:`vshard.router.route(bucket_id) <router_api-route>`"
msgstr ":ref:`vshard.router.route(bucket_id) <router_api-route>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1225
msgid ":ref:`vshard.router.routeall() <router_api-routeall>`"
msgstr ":ref:`vshard.router.routeall() <router_api-routeall>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1226
msgid ":ref:`vshard.router.bucket_id(key) <router_api-bucket_id>`"
msgstr ":ref:`vshard.router.bucket_id(key) <router_api-bucket_id>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1227
msgid ":ref:`vshard.router.bucket_count() <router_api-bucket_count>`"
msgstr ":ref:`vshard.router.bucket_count() <router_api-bucket_count>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1228
msgid ":ref:`vshard.router.sync(timeout) <router_api-sync>`"
msgstr ":ref:`vshard.router.sync(timeout) <router_api-sync>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1229
msgid ":ref:`vshard.router.discovery_wakeup() <router_api-discovery_wakeup>`"
msgstr ":ref:`vshard.router.discovery_wakeup() <router_api-discovery_wakeup>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1230
msgid ":ref:`vshard.router.info() <router_api-info>`"
msgstr ":ref:`vshard.router.info() <router_api-info>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1231
msgid ":ref:`vshard.router.buckets_info() <router_api-buckets_info>`"
msgstr ":ref:`vshard.router.buckets_info() <router_api-buckets_info>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1232
msgid ":ref:`replicaset.call() <router_api-replicaset_call>`"
msgstr ":ref:`replicaset.call() <router_api-replicaset_call>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1233
msgid ":ref:`replicaset.callro() <router_api-replicaset_callro>`"
msgstr ":ref:`replicaset.callro() <router_api-replicaset_callro>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1234
msgid ":ref:`replicaset.callrw() <router_api-replicaset_callrw>`"
msgstr ":ref:`replicaset.callrw() <router_api-replicaset_callrw>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1235
msgid ":ref:`replicaset.callre() <router_api-replicaset_callre>`"
msgstr ":ref:`replicaset.callre() <router_api-replicaset_callre>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1241
msgid ""
"Perform the initial cluster bootstrap and distribute all buckets across "
"the replica sets."
msgstr ""
"Выполнение первоначальной настройки кластера и распределение всех "
"сегментов по наборам реплик."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1248
msgid ""
"Configure the database and start sharding for the specified ``router`` "
"instance. See the :ref:`sample configuration <vshard-config-cluster-"
"example>` above."
msgstr ""
"Настройка базы данных и начало шардинга указанного ``роутера``. См. "
":ref:`образец конфигурации<vshard-config-cluster-example>` выше."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1252
msgid "a configuration table"
msgstr "конфигурационная таблица"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1258
msgid ""
"Create a new router instance. ``vshard`` supports multiple routers in a "
"single Tarantool instance. Each router can be connected to any ``vshard``"
" cluster, and multiple routers can be connected to the same cluster."
msgstr ""
"Создание нового экземпляра роутера. ``vshard`` поддерживает работу "
"нескольких роутеров в отдельном экземпляре Tarantool'а. Каждый роутер "
"может подключаться к любом кластеру ``vshard``, несколько роутеров могут "
"подключаться к одному кластеру."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1262
msgid ""
"A router created via ``vshard.router.new()`` works in the same way as a "
"static router, but the method name is preceded by a colon "
"(``vshard.router:method_name(...)``), while for a static router the "
"method name is preceded by a period (``vshard.router.method_name(...)``)."
msgstr ""
"Роутер, созданный с помощью ``vshard.router.new()``, работает так же, как"
" и статичный роутер, но перед его методами указывается двоеточие "
"(``vshard.router:имя_метода(...)``), а перед методами статичного роутера "
"-- точка (``vshard.router.имя_метода(...)``)."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1267
msgid ""
"A static router can be obtained via the ``vshard.router.static()`` method"
" and then used like a router created via the ``vshard.router.new()`` "
"method."
msgstr ""
"Статичный роутер можно получить при помощи метода "
"``vshard.router.static()``, а затем использовать его как роутер, "
"созданный с помощью метода ``vshard.router.new()``."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1273
msgid "``box.cfg`` is shared among all the routers of a single instance."
msgstr "``box.cfg`` используется всеми роутерами одного экземпляра."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1275
msgid ""
"a router instance name. This name is used as a prefix in logs of the "
"router and must be unique within the instance"
msgstr ""
"имя экземпляра роутера, которое используется в качестве префикса в "
"журналах роутера и должно быть уникальным в пределах экземпляра"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1277
msgid ""
"a configuration table. The :ref:`sample configuration <vshard-config-"
"cluster-example>` is described above."
msgstr ""
"конфигурационная таблица. :ref:`Образец конфигурации <vshard-config-"
"cluster-example>` описан выше."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1281
msgid ""
"a router instance, if created successfully; otherwise, nil and an error "
"object"
msgstr "экземпляр роутера, если он создан; в противном случае, nil и ошибка"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1288
msgid ""
"Call the function identified by function-name on the shard storing the "
"bucket identified by bucket_id. See the :ref:`Processing requests "
"<vshard-process-requests>` section for details on function operation."
msgstr ""
"Вызов функции по имени функции (function-name) на шарде, где хранится "
"сегмент с указанным идентификатором (bucket_id). Для получения подробной "
"информации о работе функции см. раздел :ref:`Обработка запросов <vshard-"
"process-requests>`."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1292
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1347
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1378
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1411
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1455
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1488
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1695
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1775
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1803
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1814
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1825
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1851
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1970
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1990
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1999
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:2024
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:2042
msgid "a bucket identifier"
msgstr "идентификатор сегмента"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1293
msgid ""
"either a string = 'read'|'write', or a map with mode='read'|'write' "
"and/or prefer_replica=true|false and/or balance=true|false."
msgstr ""
"либо строка = 'read'|'write' (чтение|запись), либо ассоциативный массив с"
" параметром mode ='read'|'write' (чтение|запись) и/или "
"prefer_replica=true|false (правда|ложь), и/или balance=true|false "
"(правда|ложь)."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1294
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1348
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1379
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1412
msgid "a function to execute"
msgstr "выполняемая функция"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1295
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1349
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1380
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1413
msgid "an array of the function's arguments"
msgstr "массив аргументов функции"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1296
msgid ""
"* ``timeout`` – a request timeout, in seconds. If the router cannot "
"identify a   shard with the specified bucket_id, the operation will be "
"repeated until the   timeout is reached."
msgstr ""
"* ``timeout`` -- время ожидания запроса в секундах. Если роутер не может "
"определить шард с указанным идентификатором сегмента, операция "
"повторяется до истечения времени ожидания."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1298
msgid ""
"``timeout`` – a request timeout, in seconds. If the router cannot "
"identify a shard with the specified bucket_id, the operation will be "
"repeated until the timeout is reached."
msgstr ""
"``timeout`` -- время ожидания запроса в секундах. Если роутер не может "
"определить шард с указанным идентификатором сегмента, операция "
"повторяется до истечения времени ожидания."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1302
msgid ""
"The mode parameter has two possible forms: a string or a map. Examples of"
" the string form are: 'read', 'write'. Examples of the map form are: "
"{mode='read'}, {mode='write'}, {mode='read', prefer_replica=true}, "
"{mode='read', balance=true}, {mode='read', prefer_replica=true, "
"balance=true}. If 'write' is specified then the target is the master. If "
"prefer_replica=true is specified then the preferred target is one of the "
"replicas, but the target is the master if there is no conveniently "
"available replica. It may be good to specify prefer_replica=true for "
"functions which are expensive in terms of resource use, to avoid slowing "
"down the master. If balance=true then there is load balancing -- reads "
"are distributed over all the nodes in the replica set in round-robin "
"fashion, with a preference for replicas if prefer_replica=true is also "
"set."
msgstr ""
"У параметра режима mode есть две доступные формы: строка или "
"ассоциативный массив. Примеры строки: 'read' (чтение), 'write' (запись). "
"Примеры ассоциативного массива: {mode='read'}, {mode='write'}, "
"{mode='read', prefer_replica=true}, {mode='read', balance=true}, "
"{mode='read', prefer_replica=true, balance=true}. Если указать значение "
"'write' (запись), то целью будет мастер. Если указать "
"prefer_replica=true, то предпочитаемая цель -- одна из реплик; если же "
"доступной реплики нет, то целью будет мастер. Удобно указать "
"prefer_replica=true для ресурсозатратных функций во избежание замедления "
"работы мастера. Если задать balance=true, добавится балансировка нагрузки"
" -- чтения распределяются по всем узлам набора реплик по кругу, "
"предпочтение отдается репликам, если также задан параметр "
"prefer_replica=true."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1316
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1358
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1389
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1422
msgid ""
"The original return value of the executed function, or ``nil`` and error "
"object. The error object has a type attribute equal to ``ShardingError`` "
"or one of the regular Tarantool errors (``ClientError``, ``OutOfMemory``,"
" ``SocketError``, etc.)."
msgstr ""
"Исходное возвращаемое значение выполняемой функции или ``nil`` и ошибка. "
"Объект ошибки содержит атрибут типа, который равен ``ShardingError`` или "
"одной из стандартных ошибок Tarantool'а(``ClientError``, ``OutOfMemory``,"
" ``SocketError`` и т.д.)."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1321
msgid ""
"``ShardingError`` is returned on errors specific for sharding: the "
"replica set is not available, the master is missing, wrong bucket id, "
"etc. It has an attribute code containing one of the values from the "
"``vshard.error.code.*`` LUA table, an optional attribute containing a "
"message with the human-readable error description, and other attributes "
"specific for the error code."
msgstr ""
"``ShardingError`` возвращается в случае ошибок шардинга: набор реплик "
"недоступен, отсутствует мастер, неверный идентификатор сегмента и т.д. "
"Такая ошибка содержит код с одним из значений из Lua-таблицы "
"``vshard.error.code.*``, необязательный атрибут сообщения с удобным для "
"восприятия описанием ошибки и другие атрибуты, специфичные для данного "
"кода ошибки."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1329
msgid "To call ``customer_add`` function from ``vshard/example``, say:"
msgstr ""
"Для вызова функции ``customer_add`` из ``vshard/example`` выполните "
"команду:"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1331
msgid ""
"vshard.router.call(100, 'write', 'customer_add', {{customer_id = 2, "
"bucket_id = 100, name = 'name2', accounts = {}}}, {timeout = 100})\n"
"-- or, the same thing but with a map for the second argument\n"
"vshard.router.call(100, {mode='write'}, 'customer_add', {{customer_id = "
"2, bucket_id = 100, name = 'name2', accounts = {}}}, {timeout = 100})"
msgstr ""
"vshard.router.call(100, 'write', 'customer_add', {{customer_id = 2, "
"bucket_id = 100, name = 'name2', accounts = {}}}, {timeout = 100})\n"
"-- или то же самое, но с ассоциативным массивом в качестве второго "
"аргумента\n"
"vshard.router.call(100, {mode='write'}, 'customer_add', {{customer_id = "
"2, bucket_id = 100, name = 'name2', accounts = {}}}, {timeout = 100})"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1341
msgid ""
"Call the function identified by function-name on the shard storing the "
"bucket identified by bucket_id, in read-only mode (similar to calling "
"vshard.router.call with mode='read'). See the :ref:`Processing requests "
"<vshard-process-requests>` section for details on function operation."
msgstr ""
"Вызов функции по имени функции (function-name) на шарде, где хранится "
"сегмент с указанным идентификатором (bucket_id) в режиме только для "
"чтения (аналогично вызову vshard.router.call в режиме mode='read'). Для "
"получения подробной информации о работе функции см. раздел "
":ref:`Обработка запросов <vshard-process-requests>`."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1350
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1381
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1414
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1611
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1632
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1651
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1673
msgid ""
"* ``timeout`` – a request timeout, in seconds. In case the ``router`` "
"cannot identify a   shard with the bucket id, the operation will be "
"repeated until the   timeout is reached."
msgstr ""
"* ``timeout`` -- время ожидания запроса в секундах. Если ``роутер`` не "
"может определить шард с идентификатором сегмента, операция повторяется до"
" истечения времени ожидания."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1352
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1383
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1416
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1613
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1634
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1653
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1675
msgid ""
"``timeout`` – a request timeout, in seconds. In case the ``router`` "
"cannot identify a shard with the bucket id, the operation will be "
"repeated until the timeout is reached."
msgstr ""
"``timeout`` -- время ожидания запроса в секундах. Если ``роутер`` не "
"может определить шард с идентификатором сегмента, операция повторяется до"
" истечения времени ожидания."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1363
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1394
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1427
msgid ""
"``ShardingError`` is returned on errors specific for sharding: the "
"replica set is not available, the master is missing, wrong bucket id, "
"etc. It has an attribute code containing one of the values from the "
"``vshard.error.code.*`` LUA table, an optional attribute containing a "
"message with the human-readable error description, and other attributes "
"specific for this error code."
msgstr ""
"``ShardingError`` возвращается в случае ошибок шардинга: набор реплик "
"недоступен, отсутствует мастер, неверный идентификатор сегмента и т.д. "
"Такая ошибка сб.одержит код с одним из значений из Lua-таблицы "
"``vshard.error.code.*``, необязательный атрибут сообщения с удобным для "
"восприятия описанием ошибки и другие атрибуты, специфичные для данного "
"кода ошибки."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1373
msgid ""
"Call the function identified by function-name on the shard storing the "
"bucket identified by bucket_id, in read-write mode (similar to calling "
"vshard.router.call with mode='write'). See the :ref:`Processing requests "
"<vshard-process-requests>` section for details on function operation."
msgstr ""
"Вызов функции по имени функции (function-name) на шарде, где хранится "
"сегмент с указанным идентификатором (bucket_id) в режиме чтения и записи "
"(аналогично вызову vshard.router.call в режиме mode='write'). Для "
"получения подробной информации о работе функции см. раздел "
":ref:`Обработка запросов <vshard-process-requests>`."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1404
msgid ""
"Call the function identified by function-name on the shard storing the "
"bucket identified by bucket_id, in read-only mode (similar to calling "
"vshard.router.call with mode='read'), with preference for a replica "
"rather than a master (similar to calling vshard.router.call with "
"prefer_replica = true). See the :ref:`Processing requests <vshard-"
"process-requests>` section for details on function operation."
msgstr ""
"Вызов функции по имени функции (function-name) на шарде, где хранится "
"сегмент с указанным идентификатором (bucket_id) в режиме только для "
"чтения (аналогично вызову vshard.router.call в режиме mode='read'), когда"
" предпочтение отдается реплике, а не мастеру (аналогично вызову "
"vshard.router.call с параметром  prefer_replica = true). Для получения "
"подробной информации о работе функции см. раздел :ref:`Обработка запросов"
" <vshard-process-requests>`."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1437
msgid ""
"This has the same effect as :ref:`vshard.router.call() <router_api-call>`"
" with mode parameter = {mode='read', balance=true}."
msgstr ""
"Эквивалент :ref:`vshard.router.call() <router_api-call>` с параметром "
"mode = {mode='read', balance=true}."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1445
msgid ""
"This has the same effect as :ref:`vshard.router.call() <router_api-call>`"
" with mode parameter = {mode='read', balance=true, prefer_replica=true}."
msgstr ""
"Эквивалент :ref:`vshard.router.call() <router_api-call>` с параметром "
"mode = {mode='read', balance=true, prefer_replica=true}."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1453
msgid ""
"Return the replica set object for the bucket with the specified bucket id"
" value."
msgstr ""
"Возврат объекта набора реплик для сегмента с указанным значением "
"идентификатора сегмента (bucket id)."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1457
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1472
msgid "a replica set object"
msgstr "объект набора реплик"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1461
msgid "replicaset = vshard.router.route(123)"
msgstr "replicaset = vshard.router.route(123)"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1469
msgid "Return all available replica set objects."
msgstr "Возврат всех доступных объектов наборов реплик."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1471
msgid "a map of the following type: ``{UUID = replicaset}``"
msgstr "ассоциативный массив следующего вида: ``{UUID = replicaset}``"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1476
msgid "replicaset = vshard.router.routeall()"
msgstr "replicaset = vshard.router.routeall()"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1484
msgid "Calculate the bucket id using a simple built-in hash function."
msgstr ""
"Вычисление идентификатора сегмента с помощью простой встроенной "
"хеш-функции."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1486
msgid "a hash key. This can be any Lua object (number, table, string)."
msgstr "хеш-ключ. Это может быть любой Lua-объект (число, таблица, строка)."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1493
msgid "bucket_id = vshard.router.bucket_id(18374927634039)"
msgstr "bucket_id = vshard.router.bucket_id(18374927634039)"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1501
msgid "Return the total number of buckets specified in ``vshard.router.cfg()``."
msgstr "Возврат общего количества сегментов, указанных в `vshard.router.cfg()``."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1503
msgid "the total number of buckets"
msgstr "общее количество сегментов"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1510
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1789
msgid "Wait until the dataset is synchronized on replicas."
msgstr "Ожидание синхронизации набора данных на репликах."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1512
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1791
msgid "a timeout, in seconds"
msgstr "время ожидания в секундах"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1514
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1793
#, fuzzy
msgid ""
"``true`` if the dataset was synchronized successfully; or ``nil`` and "
"``err`` explaining why the dataset cannot be synchronized."
msgstr ""
"``true`` (правда), если выполнено открепление сегмента; или же ``nil`` и "
"ошибка ``err`` с объяснением причины невозможности открепления сегмента"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1521
msgid "Force wakeup of the bucket discovery fiber."
msgstr "Принудительный запуск файбера обнаружения сегментов."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1527
msgid "Return information about each instance."
msgstr "Возврат информации по каждому экземпляру."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1531
msgid "Replica set parameters:"
msgstr "Параметры набора реплик:"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1533
msgid "replica set uuid"
msgstr "UUID набора реплик"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1534
msgid "master instance parameters"
msgstr "параметры мастер-экземпляра"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1535
msgid "replica instance parameters"
msgstr "параметры реплики"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1537
msgid "Instance parameters:"
msgstr "Параметры экземпляра:"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1539
msgid "``uri`` — URI of the instance"
msgstr "``uri`` -- URI экземпляра"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1540
msgid "``uuid`` — UUID of the instance"
msgstr "``uuid`` -- UUID экземпляра"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1541
msgid ""
"``status`` – status of the instance (``available``, ``unreachable``, "
"``missing``)"
msgstr ""
"``status`` -- статус экземпляра: ``available`` (доступный), "
"``unreachable`` (недоступный), ``missing`` (отсутствующий)"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1542
msgid ""
"``network_timeout`` – a timeout for the request. The value is updated "
"automatically on each 10th successful request and each 2nd failed "
"request."
msgstr ""
"``network_timeout`` -- время ожидания запроса. Данное значение "
"обновляется автоматически на каждом 10 выполненном запросе и на каждом 2 "
"невыполненном запросе."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1545
msgid "Bucket parameters:"
msgstr "Параметры сегмента:"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1547
msgid ""
"``available_ro`` – the number of buckets known to the ``router`` and "
"available for read requests"
msgstr ""
"``available_ro`` -- количество сегментов, известных роутеру и доступных "
"для запросов чтения"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1548
msgid ""
"``available_rw`` – the number of buckets known to the router and "
"available for read and write requests"
msgstr ""
"``available_rw`` -- количество сегментов, известных роутеру и доступных "
"для запросов чтения и записи"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1549
msgid ""
"``unavailable`` – the number of buckets known to the ``router`` but "
"unavailable for any requests"
msgstr ""
"``unavailable`` -- количество сегментов, известных роутеру, но "
"недоступных для любых запросов"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1550
msgid ""
"``unreachable`` – the number of buckets whose replica sets are not known "
"to the ``router``"
msgstr ""
"``unreachable``-- количество сегментов, для которых роутер не знает "
"соответствующие наборы реплик"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1554
msgid ""
"tarantool> vshard.router.info()\n"
"---\n"
"- replicasets:\n"
"    ac522f65-aa94-4134-9f64-51ee384f1a54:\n"
"      replica: &0\n"
"        network_timeout: 0.5\n"
"        status: available\n"
"        uri: storage@127.0.0.1:3303\n"
"        uuid: 1e02ae8a-afc0-4e91-ba34-843a356b8ed7\n"
"      uuid: ac522f65-aa94-4134-9f64-51ee384f1a54\n"
"      master: *0\n"
"    cbf06940-0790-498b-948d-042b62cf3d29:\n"
"      replica: &1\n"
"        network_timeout: 0.5\n"
"        status: available\n"
"        uri: storage@127.0.0.1:3301\n"
"        uuid: 8a274925-a26d-47fc-9e1b-af88ce939412\n"
"      uuid: cbf06940-0790-498b-948d-042b62cf3d29\n"
"      master: *1\n"
"  bucket:\n"
"    unreachable: 0\n"
"    available_ro: 0\n"
"    unknown: 0\n"
"    available_rw: 3000\n"
"  status: 0\n"
"  alerts: []\n"
"..."
msgstr ""
"tarantool> vshard.router.info()\n"
"---\n"
"- replicasets:\n"
"    ac522f65-aa94-4134-9f64-51ee384f1a54:\n"
"      replica: &0\n"
"        network_timeout: 0.5\n"
"        status: available\n"
"        uri: storage@127.0.0.1:3303\n"
"        uuid: 1e02ae8a-afc0-4e91-ba34-843a356b8ed7\n"
"      uuid: ac522f65-aa94-4134-9f64-51ee384f1a54\n"
"      master: *0\n"
"    cbf06940-0790-498b-948d-042b62cf3d29:\n"
"      replica: &1\n"
"        network_timeout: 0.5\n"
"        status: available\n"
"        uri: storage@127.0.0.1:3301\n"
"        uuid: 8a274925-a26d-47fc-9e1b-af88ce939412\n"
"      uuid: cbf06940-0790-498b-948d-042b62cf3d29\n"
"      master: *1\n"
"  bucket:\n"
"    unreachable: 0\n"
"    available_ro: 0\n"
"    unknown: 0\n"
"    available_rw: 3000\n"
"  status: 0\n"
"  alerts: []\n"
"..."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1588
msgid ""
"Return information about each bucket. Since a bucket map can be huge, "
"only the required range of buckets can be specified."
msgstr ""
"Возврат информации по каждому сегменту. Поскольку массив сегментов может "
"быть огромен, можно указать только необходимый ряд сегментов."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1591
msgid "the offset in a bucket map of the first bucket to show"
msgstr "начальное значение выборки сегментов"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1592
msgid "the maximum number of buckets to show"
msgstr "максимальное количество показываемых сегментов"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1594
msgid "a map of the following type: ``{bucket_id = 'unknown'/replicaset_uuid}``"
msgstr ""
"ассоциативный массив следующего вида: ``{bucket_id = "
"'unknown'/replicaset_uuid}``"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1600
msgid ""
"Call a function on a nearest available master (distances are defined "
"using ``replica.zone`` and ``cfg.weights`` matrix) with specified "
"arguments."
msgstr ""
"Вызов функции с указанными аргументами на ближайшем доступном мастере "
"(расстояние определяется с помощью матрицы ``replica.zone`` и "
"``cfg.weights``)."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1606
msgid "The ``replicaset.call`` method is similar to ``replicaset.callrw``."
msgstr "Метод ``replicaset.call`` аналогичен ``replicaset.callrw``."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1608
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1629
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1648
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1670
msgid "UUID of a replica set"
msgstr "UUID набора реплик"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1609
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1630
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1649
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1671
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1777
msgid "function to execute"
msgstr "выполняемая функция"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1610
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1631
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1650
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1672
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1778
msgid "array of the function's arguments"
msgstr "массив аргументов функции"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1621
msgid ""
"Call a function on a nearest available master (distances are defined "
"using ``replica.zone`` and ``cfg.weights`` matrix) with a specified "
"arguments."
msgstr ""
"Вызов функции с указанными аргументами на ближайшем доступном мастере "
"(расстояние определяется с помощью матрицы ``replica.zone`` и "
"``cfg.weights``)."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1627
msgid "The ``replicaset.callrw`` method is similar to ``replicaset.call``."
msgstr "Метод ``replicaset.callrw`` аналогичен ``replicaset.call``."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1642
msgid ""
"Call a function on the nearest available replica (distances are defined "
"using ``replica.zone`` and ``cfg.weights`` matrix) with specified "
"arguments. It is recommended to call only read-only functions using "
"``replicaset.callro()``, as the function can be executed not only on a "
"master, but also on replicas."
msgstr ""
"Вызов функции с указанными аргументами на ближайшей доступной реплике "
"(расстояние определяется с помощью матрицы ``replica.zone`` и "
"``cfg.weights``). С помощью ``replicaset.callro()`` рекомендуется "
"вызывать исключительно функции, доступные только для чтения. поскольку "
"такие функции можно выполнять не только на мастере, но и на репликах."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1661
msgid ""
"Call a function on the nearest available replica (distances are defined "
"using ``replica.zone`` and ``cfg.weights`` matrix) with specified "
"arguments, with preference for a replica rather than a master (similar to"
" calling vshard.router.call with prefer_replica = true). It is "
"recommended to call only read-only functions using "
"``replicaset.callre()``, as the function can be executed not only on a "
"master, but also on replicas."
msgstr ""
"Вызов функции с указанными аргументами на ближайшей доступной реплике "
"(расстояние определяется с помощью матрицы ``replica.zone`` и "
"``cfg.weights``), предпочтение отдается реплике, а не мастеру (аналогично"
" вызову vshard.router.call с параметром prefer_replica = true). С помощью"
" ``replicaset.callre()`` рекомендуется вызывать исключительно функции, "
"доступные только для чтения. поскольку такие функции можно выполнять не "
"только на мастере, но и на репликах."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1683
msgid "Router internal API"
msgstr "Внутренние API роутера"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1685
msgid ""
":ref:`vshard.router.bucket_discovery(bucket_id) <router_api-"
"bucket_discovery>`"
msgstr ""
":ref:`vshard.router.bucket_discovery(bucket_id) <router_api-"
"bucket_discovery>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1691
msgid ""
"Search for the bucket in the whole cluster. If the bucket is not found, "
"it is likely that it does not exist. The bucket might also be moved "
"during rebalancing and currently is in the RECEIVING state."
msgstr ""
"Поиск сегмента по всему кластеру. Если сегмент не обнаружен, скорее "
"всего, он не существует. Также сегмент также может быть перемещен во "
"время балансировки и в данный момент находится в статусе получения "
"RECEIVING."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1701
msgid "Storage public API"
msgstr "Общедоступные API хранилища"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1703
msgid ":ref:`vshard.storage.cfg(cfg, name) <storage_api-cfg>`"
msgstr ":ref:`vshard.storage.cfg(cfg, name) <storage_api-cfg>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1704
msgid ":ref:`vshard.storage.info() <storage_api-info>`"
msgstr ":ref:`vshard.storage.info() <storage_api-info>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1705
msgid ""
":ref:`vshard.storage.call(bucket_id, mode, function_name, "
"{argument_list}) <storage_api-call>`"
msgstr ""
":ref:`vshard.storage.call(bucket_id, mode, function_name, "
"{argument_list}) <storage_api-call>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1706
msgid ":ref:`vshard.storage.sync(timeout) <storage_api-sync>`"
msgstr ":ref:`vshard.storage.sync(timeout) <storage_api-sync>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1707
msgid ":ref:`vshard.storage.bucket_pin(bucket_id) <storage_api-bucket_pin>`"
msgstr ":ref:`vshard.storage.bucket_pin(bucket_id) <storage_api-bucket_pin>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1708
msgid ":ref:`vshard.storage.bucket_unpin(bucket_id) <storage_api-bucket_unpin>`"
msgstr ":ref:`vshard.storage.bucket_unpin(bucket_id) <storage_api-bucket_unpin>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1709
msgid ":ref:`vshard.storage.bucket_ref(bucket_id, mode) <storage_api-bucket_ref>`"
msgstr ":ref:`vshard.storage.bucket_ref(bucket_id, mode) <storage_api-bucket_ref>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1710
msgid ":ref:`vshard.storage.bucket_refro() <storage_api-bucket_refro>`"
msgstr ":ref:`vshard.storage.bucket_refro() <storage_api-bucket_refro>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1711
msgid ":ref:`vshard.storage.bucket_refrw() <storage_api-bucket_refrw>`"
msgstr ":ref:`vshard.storage.bucket_refrw() <storage_api-bucket_refrw>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1712
msgid ""
":ref:`vshard.storage.bucket_unref(bucket_id, mode) <storage_api-"
"bucket_unref>`"
msgstr ""
":ref:`vshard.storage.bucket_unref(bucket_id, mode) <storage_api-"
"bucket_unref>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1713
msgid ":ref:`vshard.storage.bucket_unrefro() <storage_api-bucket_unrefro>`"
msgstr ":ref:`vshard.storage.bucket_unrefro() <storage_api-bucket_unrefro>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1714
msgid ":ref:`vshard.storage.bucket_unrefrw() <storage_api-bucket_unrefrw>`"
msgstr ":ref:`vshard.storage.bucket_unrefrw() <storage_api-bucket_unrefrw>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1715
msgid ""
":ref:`vshard.storage.find_garbage_bucket(bucket_index, control) "
"<storage_api-find_garbage_bucket>`"
msgstr ""
":ref:`vshard.storage.find_garbage_bucket(bucket_index, control) "
"<storage_api-find_garbage_bucket>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1716
msgid ""
":ref:`vshard.storage.rebalancer_disable() <storage_api-"
"rebalancer_disable>`"
msgstr ""
":ref:`vshard.storage.rebalancer_disable() <storage_api-"
"rebalancer_disable>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1717
msgid ":ref:`vshard.storage.rebalancer_enable() <storage_api-rebalancer_enable>`"
msgstr ":ref:`vshard.storage.rebalancer_enable() <storage_api-rebalancer_enable>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1718
msgid ":ref:`vshard.storage.is_locked() <storage_api-is_locked>`"
msgstr ":ref:`vshard.storage.is_locked() <storage_api-is_locked>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1719
msgid ""
":ref:`vshard.storage.rebalancing_is_in_progress() <storage_api-"
"rebalancing_is_in_progress>`"
msgstr ""
":ref:`vshard.storage.rebalancing_is_in_progress() <storage_api-"
"rebalancing_is_in_progress>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1720
msgid ":ref:`vshard.storage.buckets_info() <storage_api-buckets_info>`"
msgstr ":ref:`vshard.storage.buckets_info() <storage_api-buckets_info>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1721
msgid ":ref:`vshard.storage.buckets_count() <storage_api-buckets_count>`"
msgstr ":ref:`vshard.storage.buckets_count() <storage_api-buckets_count>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1722
msgid ":ref:`vshard.storage.sharded_spaces() <storage_api-sharded_spaces>`"
msgstr ":ref:`vshard.storage.sharded_spaces() <storage_api-sharded_spaces>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1728
msgid ""
"Configure the database and start sharding for the specified ``storage`` "
"instance."
msgstr ""
"Конфигурация базы данных и начало шардинга на указанном экземпляре "
"хранилища."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1731
msgid "a ``storage`` configuration"
msgstr "конфигурация хранилища"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1732
msgid "UUID of the instance"
msgstr "UUID экземпляра"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1738
msgid "Return information about the storage instance in the following format:"
msgstr "Возврат информации по экземпляру хранилища в следующем формате:"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1740
msgid ""
"tarantool> vshard.storage.info()\n"
"---\n"
"- buckets:\n"
"    2995:\n"
"      status: active\n"
"      id: 2995\n"
"    2997:\n"
"      status: active\n"
"      id: 2997\n"
"    2999:\n"
"      status: active\n"
"      id: 2999\n"
"  replicasets:\n"
"    2dd0a343-624e-4d3a-861d-f45efc571cd3:\n"
"      uuid: 2dd0a343-624e-4d3a-861d-f45efc571cd3\n"
"      master:\n"
"        state: active\n"
"        uri: storage:storage@127.0.0.1:3301\n"
"        uuid: 2ec29309-17b6-43df-ab07-b528e1243a79\n"
"    c7ad642f-2cd8-4a8c-bb4e-4999ac70bba1:\n"
"      uuid: c7ad642f-2cd8-4a8c-bb4e-4999ac70bba1\n"
"      master:\n"
"        state: active\n"
"        uri: storage:storage@127.0.0.1:3303\n"
"        uuid: 810d85ef-4ce4-4066-9896-3c352fec9e64\n"
"..."
msgstr ""
"tarantool> vshard.storage.info()\n"
"---\n"
"- buckets:\n"
"    2995:\n"
"      status: active\n"
"      id: 2995\n"
"    2997:\n"
"      status: active\n"
"      id: 2997\n"
"    2999:\n"
"      status: active\n"
"      id: 2999\n"
"  replicasets:\n"
"    2dd0a343-624e-4d3a-861d-f45efc571cd3:\n"
"      uuid: 2dd0a343-624e-4d3a-861d-f45efc571cd3\n"
"      master:\n"
"        state: active\n"
"        uri: storage:storage@127.0.0.1:3301\n"
"        uuid: 2ec29309-17b6-43df-ab07-b528e1243a79\n"
"    c7ad642f-2cd8-4a8c-bb4e-4999ac70bba1:\n"
"      uuid: c7ad642f-2cd8-4a8c-bb4e-4999ac70bba1\n"
"      master:\n"
"        state: active\n"
"        uri: storage:storage@127.0.0.1:3303\n"
"        uuid: 810d85ef-4ce4-4066-9896-3c352fec9e64\n"
"..."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1773
msgid "Call the specified function on the current ``storage`` instance."
msgstr "Вызов указанной функции на текущем экземпляре хранилища."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1776
msgid "a type of the function: 'read' or 'write'"
msgstr "тип функции: 'read' или 'write' (чтение или запись)"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1782
msgid ""
"The original return value of the executed function, or ``nil`` and error "
"object."
msgstr "Исходное возвращаемое значение выполняемой функции или ``nil`` и ошибка."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1800
msgid ""
"Pin a bucket to a replica set. A pinned bucket cannot be moved even if it"
" breaks the cluster balance."
msgstr ""
"Закрепление сегмента в наборе реплик. Закрепленный сегмент нельзя "
"перемещать, даже если это нарушает баланс в кластере."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1805
msgid ""
"``true`` if the bucket is pinned successfully; or ``nil`` and ``err`` "
"explaining why the bucket cannot be pinned"
msgstr ""
"``true`` (правда), если выполнено закрепление сегмента; или же ``nil`` и "
"ошибка ``err`` с объяснением причины невозможности закрепления сегмента"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1812
msgid "Return a pinned bucket back into the active state."
msgstr "Возврат закрепленного сегмента в активное состояние."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1816
msgid ""
"``true`` if the bucket is unpinned successfully; or ``nil`` and ``err`` "
"explaining why the bucket cannot be unpinned"
msgstr ""
"``true`` (правда), если выполнено открепление сегмента; или же ``nil`` и "
"ошибка ``err`` с объяснением причины невозможности открепления сегмента"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1823
msgid "Create an RO or RW :ref:`ref <vshard-ref>`."
msgstr "Создание :ref:`ссылки <vshard-ref>` типа RO или RW."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1826
#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1852
msgid "'read' or 'write'"
msgstr "'read' или 'write' (чтение или запись)"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1828
msgid ""
"``true`` if the bucket ref is created successfully; or ``nil`` and "
"``err`` explaining why the ref cannot be created"
msgstr ""
"``true`` (правда), если выполнено создание ссылки; или же ``nil`` и "
"ошибка ``err`` с объяснением причины невозможности создания ссылки"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1835
msgid ""
"An alias for :ref:`vshard.storage.bucket_ref <storage_api-bucket_ref>` in"
" the RO mode."
msgstr ""
"Псевдоним для :ref:`vshard.storage.bucket_ref <storage_api-bucket_ref>` в"
" режиме только чтения."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1842
msgid ""
"An alias for :ref:`vshard.storage.bucket_ref <storage_api-bucket_ref>` in"
" the RW mode."
msgstr ""
"Псевдоним для :ref:`vshard.storage.bucket_ref <storage_api-bucket_ref>` в"
" режиме чтения и записи."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1849
msgid "Remove a RO/RW :ref:`ref <vshard-ref>`."
msgstr "Удаление :ref:`ссылки <vshard-ref>` RO/RW."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1854
msgid ""
"``true`` if the bucket ref is removed successfully; or ``nil`` and "
"``err`` explaining why the ref cannot be removed"
msgstr ""
"``true`` (правда), если выполнено удаление ссылки; или же ``nil`` и "
"ошибка ``err`` с объяснением причины невозможности удаления ссылки"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1861
msgid ""
"An alias for :ref:`vshard.storage.bucket_unref <storage_api-"
"bucket_unref>` in the RO mode."
msgstr ""
"Псевдоним для :ref:`vshard.storage.bucket_unref <storage_api-"
"bucket_unref>` в режиме только чтения."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1868
msgid ""
"An alias for :ref:`vshard.storage.bucket_unref <storage_api-"
"bucket_unref>` in the RW mode."
msgstr ""
"Псевдоним для :ref:`vshard.storage.bucket_unref <storage_api-"
"bucket_unref>` в режиме чтения и записи."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1875
msgid ""
"Find a bucket which has data in a space but is not stored in a "
"``_bucket`` space; or is in a GARBAGE state."
msgstr ""
"Поиск сегмента, который хранит данные в спейсе, но не указан в спейсе "
"``_bucket``, или находится в статусе мусора (GARBAGE)."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1878
msgid "index of a space with the part of a bucket id"
msgstr "индекс спейса с частью идентификатора спейса"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1879
msgid ""
"a garbage collector controller. If there is an increased buckets "
"generation, then the search should be interrupted."
msgstr ""
"контроллер сборщика мусора. Если увеличивается масштаб создания "
"сегментов, поиск следует прервать."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1882
msgid "an identifier of the bucket in the garbage state, if found; otherwise, nil"
msgstr ""
"идентификатор сегмента в статусе мусора, если таковой обнаружен; в "
"противном случае, nil"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1889
msgid "Return information about each bucket located in storage. For example:"
msgstr ""
"Возврат информации по каждому сегменту, расположенному в хранилище. "
"Например:"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1907
msgid "Return the number of buckets located in storage."
msgstr "Возврат количества сегментов, расположенных в хранилище."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1913
msgid "Immediately wake up a recovery fiber, if it exists."
msgstr "Немедленный запуск файбера восстановления, если такой есть."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1919
msgid ""
"Return a flag indicating whether rebalancing is in progress. The result "
"is true if the node is currently applying routes received from a "
"rebalancer node in the special fiber."
msgstr ""
"Возврат флага, указывающего на ход процесса балансировки. Результатом "
"будет true (правда), если в данный момент узел применяет маршруты, "
"полученные от узла балансировки в специальном файбере."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1927
msgid "Return a flag indicating whether storage is invisible to the rebalancer."
msgstr "Возврат флага, указывающего на недоступность хранилища для балансировщика."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1933
msgid ""
"Disable rebalancing. A disabled rebalancer sleeps until it is enabled "
"again with vshard.storage.rebalancer_enable()."
msgstr ""
"Отключение балансировки. Отключенный балансировщик находится в режиме "
"ожидания до повторного запуска с помощью "
"vshard.storage.rebalancer_enable()."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1940
msgid "Enable rebalancing."
msgstr "Запуск балансировки."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1946
msgid ""
"Show the spaces that are visible to rebalancer and garbage collector "
"fibers."
msgstr ""
"Отображение спейсов, которые доступны балансировщику и файберам сборщика "
"мусора."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1952
msgid "Storage internal API"
msgstr "Внутренние API хранилища"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1954
msgid ":ref:`vshard.storage.bucket_stat(bucket_id) <storage_api-bucket_stat>`"
msgstr ":ref:`vshard.storage.bucket_stat(bucket_id) <storage_api-bucket_stat>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1955
msgid ""
":ref:`vshard.storage.bucket_recv(bucket_id, from, data) <storage_api-"
"bucket_recv>`"
msgstr ""
":ref:`vshard.storage.bucket_recv(bucket_id, from, data) <storage_api-"
"bucket_recv>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1956
msgid ""
":ref:`vshard.storage.bucket_delete_garbage(bucket_id) <storage_api-"
"bucket_delete_garbage>`"
msgstr ""
":ref:`vshard.storage.bucket_delete_garbage(bucket_id) <storage_api-"
"bucket_delete_garbage>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1957
msgid ""
":ref:`vshard.storage.bucket_collect(bucket_id) <storage_api-"
"bucket_collect>`"
msgstr ""
":ref:`vshard.storage.bucket_collect(bucket_id) <storage_api-"
"bucket_collect>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1958
msgid ""
":ref:`vshard.storage.bucket_force_create(first_bucket_id, count) "
"<storage_api-bucket_force_create>`"
msgstr ""
":ref:`vshard.storage.bucket_force_create(first_bucket_id, count) "
"<storage_api-bucket_force_create>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1959
msgid ""
":ref:`vshard.storage.bucket_force_drop(bucket_id, to) <storage_api-"
"bucket_force_drop>`"
msgstr ""
":ref:`vshard.storage.bucket_force_drop(bucket_id, to) <storage_api-"
"bucket_force_drop>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1960
msgid ":ref:`vshard.storage.bucket_send(bucket_id, to) <storage_api-bucket_send>`"
msgstr ":ref:`vshard.storage.bucket_send(bucket_id, to) <storage_api-bucket_send>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1961
msgid ":ref:`vshard.storage.buckets_discovery() <storage_api-buckets_discovery>`"
msgstr ":ref:`vshard.storage.buckets_discovery() <storage_api-buckets_discovery>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1962
msgid ""
":ref:`vshard.storage.rebalancer_request_state() <storage_api-"
"rebalancer_request_state>`"
msgstr ""
":ref:`vshard.storage.rebalancer_request_state() <storage_api-"
"rebalancer_request_state>`"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1968
msgid "Receive a bucket identified by bucket id from a remote replica set."
msgstr ""
"Получение сегмента по идентификатору сегмента (bucket id) из удаленного "
"набора реплик."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1971
msgid "UUID of source replica set"
msgstr "UUID исходного набора реплик"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1972
msgid ""
"data logically stored in a bucket identified by bucket_id, in the same "
"format as the return value from ``bucket_collect() <storage_api-"
"bucket_collect>``"
msgstr ""
"данные, которые хранятся логически в сегменте, определенном по "
"идентификатору сегмента (bucket_id), в том же формате, что и возвращаемое"
" значение метода ``bucket_collect() <storage_api-bucket_collect>``"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1979
msgid "Return information about the bucket id:"
msgstr "Возврат информации об идентификаторе сегмента (bucket id):"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1981
msgid ""
"tarantool> vshard.storage.bucket_stat(1)\n"
"---\n"
"- 0\n"
"- status: active\n"
"  id: 1\n"
"..."
msgstr ""
"tarantool> vshard.storage.bucket_stat(1)\n"
"---\n"
"- 0\n"
"- status: active\n"
"  id: 1\n"
"..."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:1996
msgid ""
"Force garbage collection for the bucket identified by bucket_id in case "
"the bucket was transferred to a different replica set."
msgstr ""
"Принудительная сборка мусора для сегмента, найденного по идентификатору "
"(bucket_id), если сегмент был перемещен в другой набор реплик."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:2005
msgid ""
"Collect all the data that is logically stored in the bucket identified by"
" bucket_id:"
msgstr ""
"Сбор всех данных, которые хранятся логически в сегменте, найденном по "
"идентификатору (bucket_id):"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:2007
msgid ""
"tarantool> vshard.storage.bucket_collect(1)\n"
"---\n"
"- 0\n"
"- - - 514\n"
"    - - [10, 1, 1, 100, 'Account 10']\n"
"      - [11, 1, 1, 100, 'Account 11']\n"
"      - [12, 1, 1, 100, 'Account 12']\n"
"      - [50, 5, 1, 100, 'Account 50']\n"
"      - [51, 5, 1, 100, 'Account 51']\n"
"      - [52, 5, 1, 100, 'Account 52']\n"
"  - - 513\n"
"    - - [1, 1, 'Customer 1']\n"
"      - [5, 1, 'Customer 5']\n"
"..."
msgstr ""
"tarantool> vshard.storage.bucket_collect(1)\n"
"---\n"
"- 0\n"
"- - - 514\n"
"    - - [10, 1, 1, 100, 'Account 10']\n"
"      - [11, 1, 1, 100, 'Account 11']\n"
"      - [12, 1, 1, 100, 'Account 12']\n"
"      - [50, 5, 1, 100, 'Account 50']\n"
"      - [51, 5, 1, 100, 'Account 51']\n"
"      - [52, 5, 1, 100, 'Account 52']\n"
"  - - 513\n"
"    - - [1, 1, 'Customer 1']\n"
"      - [5, 1, 'Customer 5']\n"
"..."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:2030
msgid ""
"Force creation of the buckets (single or multiple) on the current replica"
" set. Use only for manual emergency recovery or for initial bootstrap."
msgstr ""
"Принудительное создание сегментов (одного или нескольких) в текущем "
"наборе реплик. Используется только для ручного аварийного восстановления "
"или для начальной настройки."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:2033
msgid "an identifier of the first bucket in a range"
msgstr "идентификатор первого сегмента в диапазоне"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:2034
msgid "the number of buckets to insert (default = 1)"
msgstr "количество вставляемых сегментов (по умолчанию, 1)"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:2040
msgid "Drop a bucket manually for tests or emergency cases."
msgstr "Удаление сегмента вручную для тестирования или в аварийной ситуации."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:2048
msgid ""
"Send a specified bucket from the current replica set to a remote replica "
"set."
msgstr ""
"Отправка указанного сегмента из текущего набора реплик в удаленный набор "
"реплик."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:2050
msgid "bucket identifier"
msgstr "идентификатор сегмента"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:2051
msgid "UUID of a remote replica set"
msgstr "UUID удаленного набора реплик"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:2057
msgid ""
"Check all buckets of the host storage that have the SENT or ACTIVE state,"
" return the number of active buckets."
msgstr ""
"Проверка всех сегментов хост-хранилища в статусе отправки SENT или "
"активном статусе ACTIVE, возврат количества активных сегментов."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:2060
msgid "the number of buckets in the active state, if found; otherwise, nil"
msgstr ""
"количество сегментов в активном статусе, если таковые обнаружены; в "
"противном случае, nil"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:2066
msgid "Collect an array of active bucket identifiers for discovery."
msgstr "Сбор массива идентификаторов активных сегментов для обнаружения."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:2072
msgid "Glossary"
msgstr "Глоссарий"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:2077
msgid "**Vertical scaling**"
msgstr "**Вертикальное масштабирование**"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:2079
msgid ""
"Adding more power to a single server: using a more powerful CPU, adding "
"more capacity to RAM, adding more storage space, etc."
msgstr ""
"Добавление мощности в отдельный сервер: использование более мощного "
"процессора, добавление оперативной памяти, добавление хранилищ и т.д. "

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:2083
msgid "**Horizontal scaling**"
msgstr "**Горизонтальное масштабирование**"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:2085
msgid ""
"Adding more servers to the pool of resources, then partitioning and "
"distributing a dataset across the servers."
msgstr ""
"Добавление дополнительных серверов в пул ресурсов, последующее "
"секционирование и распределение набора данных по серверам."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:2089
msgid "**Sharding**"
msgstr "**Шардинг**"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:2091
msgid ""
"A database architecture that allows partitioning a dataset using a "
"sharding key and distributing a dataset across multiple servers. Sharding"
" is a special case of horizontal scaling."
msgstr ""
"Архитектура базы данных, которая допускает секционирование набора данных "
"по сегментному ключу и распределение набора данных по нескольким "
"серверам. Шардинг представляет собой частный случай горизонтального "
"масштабирования."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:2096
msgid "**Node**"
msgstr "**Узел**"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:2098
msgid "A virtual or physical server instance."
msgstr "Виртуальный или физический экземпляр сервера."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:2101
msgid "**Cluster**"
msgstr "**Кластер**"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:2103
msgid "A set of nodes that make up a single group."
msgstr "Набор узлов, которые составляют отдельную группу."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:2106
msgid "**Storage**"
msgstr "**Хранилище**"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:2108
msgid "A node storing a subset of a dataset."
msgstr "Узел, который хранит подмножество данных из набора."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:2113
msgid ""
"A set of storage nodes storing copies of a dataset. Each storage in a "
"replica set has a role, master or replica."
msgstr ""
"Ряд узлов, на которых хранятся копии набора данных. У каждого хранилища в"
" наборе реплик есть роль: мастер или реплика."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:2117
msgid "**Master**"
msgstr "**Мастер**"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:2119
msgid "A storage in a replica set processing read and write requests."
msgstr ""
"Хранилище в наборе реплик, которое обрабатывает запросы на чтение и "
"запись."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:2124
msgid "A storage in a replica set processing only read requests."
msgstr "Хранилище в наборе реплик, которое обрабатывает только запросы на чтение."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:2127
msgid "**Read requests**"
msgstr "**Запросы на чтение**"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:2129
msgid "Read-only requests, that is, select requests."
msgstr "Запросы только на чтение, то есть выборка."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:2132
msgid "**Write requests**"
msgstr "**Запросы на запись**"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:2134
msgid "Data-change operations, that is create, replace, update, delete requests."
msgstr ""
"Операции по изменению данных, то есть запросы на создание, замену, "
"обновление и удаление данных."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:2137
msgid "**Buckets (virtual buckets)**"
msgstr "**Сегменты (виртуальные сегменты)**"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:2139
msgid ""
"The abstract virtual nodes into which the dataset is partitioned by the "
"sharding key (bucket id)."
msgstr ""
"Абстрактные виртуальные узлы, на которые производится секционирование "
"набора данных по сегментному ключу (идентификатору сегмента)."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:2143
msgid "**Bucket id**"
msgstr "**Идентификатор сегмента**"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:2145
msgid ""
"A sharding key defining which bucket belongs to which replica set. A "
"bucket id may be calculated from a :ref:`hash key <router_api-"
"bucket_id>`."
msgstr ""
"Сегментный ключ, который определяет принадлежность сегмента к "
"определенному набору реплик. Идентификатор сегмента можно вычислить из "
":ref:`хеш-ключа <router_api-bucket_id>`."

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:2149
msgid "**Router**"
msgstr "**Роутер**"

#: ../doc/1.10/reference/reference_rock/vshard/index.rst:2151
msgid ""
"A proxy server responsible for routing requests from an application to "
"nodes in a cluster."
msgstr ""
"Прокси-сервер, который отвечает за запросы маршрутизации от приложения к "
"узлам в кластере."

#: ../doc/1.10/reference/tarantoolctl.rst:39
msgid "Utility `tarantoolctl`"
msgstr "Утилита `tarantoolctl`"

#: ../doc/1.10/reference/tarantoolctl.rst:41
msgid ""
"``tarantoolctl`` is a utility for administering Tarantool :ref:`instances"
" <tarantoolctl-instance_management>`, :ref:`checkpoint files "
"<tarantoolctl-checkpoint_management>` and :ref:`modules <tarantoolctl-"
"module_management>`. It is shipped and installed as part of Tarantool "
"distribution."
msgstr ""
"``tarantoolctl`` представляет собой утилиту для администрирования "
":ref:`экземпляров <tarantoolctl-instance_management>`, :ref:`файлов "
"контрольной точки <tarantoolctl-checkpoint_management>` и :ref:`модулей "
"<tarantoolctl-module_management>` в Tarantool'е. Утилита поставляется и "
"устанавливается как часть дистрибутива Tarantool'а."

#: ../doc/1.10/reference/tarantoolctl.rst:47
msgid ""
"See also ``tarantoolctl`` usage examples in :ref:`Server administration "
"<admin>` section."
msgstr ""
"См. также примеры использования ``tarantoolctl`` в разделе "
":ref:`Администрирование серверной части <admin>`."

#: ../doc/1.10/reference/tarantoolctl.rst:54
msgid "Command format"
msgstr "Формат команд"

#: ../doc/1.10/reference/tarantoolctl.rst:56
msgid "``tarantoolctl COMMAND NAME [URI] [FILE] [OPTIONS..]``"
msgstr "``tarantoolctl COMMAND NAME [URI] [FILE] [OPTIONS..]``"

#: ../doc/1.10/reference/tarantoolctl.rst:60
msgid ""
"``COMMAND`` is one of the following: ``start``, ``stop``, ``status``, "
"``restart``, ``logrotate``, ``check``, ``enter``, ``eval``, ``connect``, "
"``cat``, ``play``, ``rocks``."
msgstr ""
"``COMMAND`` -- это одна из следующих команд, описанных ниже: ``start``, "
"``stop``, ``status``, ``restart``, ``logrotate``, ``check``, ``enter``, "
"``eval``, ``connect``, ``cat``, ``play``, ``rocks``."

#: ../doc/1.10/reference/tarantoolctl.rst:64
msgid ""
"``NAME`` is the name of an :ref:`instance file <admin-instance_file>` or "
"a :ref:`module <app_server-modules>`."
msgstr ""
"``NAME`` -- это имя :ref:`файла экземпляра <admin-instance_file>` или "
":ref:`модуля <app_server-modules>`."

#: ../doc/1.10/reference/tarantoolctl.rst:67
msgid "``FILE`` is the path to some file (.lua, .xlog or .snap)."
msgstr "``FILE`` -- это путь к какому-либо файлу (.lua, .xlog или .snap)."

#: ../doc/1.10/reference/tarantoolctl.rst:69
msgid "``URI`` is the URI of some Tarantool instance."
msgstr "``URI`` -- это URI некого экземпляра Tarantool'а."

#: ../doc/1.10/reference/tarantoolctl.rst:71
msgid "``OPTIONS`` are options taken by some ``tarantoolctl`` commands."
msgstr "``OPTIONS`` -- это параметры, которые принимают команды ``tarantoolctl``."

#: ../doc/1.10/reference/tarantoolctl.rst:77
msgid "Commands for managing Tarantool instances"
msgstr "Команды для управления экземплярами Tarantool'а"

#: ../doc/1.10/reference/tarantoolctl.rst:83
msgid "``tarantoolctl start NAME``"
msgstr "``tarantoolctl start NAME``"

#: ../doc/1.10/reference/tarantoolctl.rst:80
msgid "Start a Tarantool instance."
msgstr "Запуск экземпляра Tarantool’а."

#: ../doc/1.10/reference/tarantoolctl.rst:82
msgid ""
"Additionally, this command sets the TARANTOOLCTL environment variable to "
"'true', to mark that the instance was started by ``tarantoolctl``."
msgstr ""
"Кроме того, данная команда задает значение переменной окружения "
"TARANTOOLCTL = 'true' (правда), чтобы отметить, что экземпляр был запущен"
" с помощью ``tarantoolctl``."

#: ../doc/1.10/reference/tarantoolctl.rst:86
msgid "``tarantoolctl stop NAME``"
msgstr "``tarantoolctl stop NAME``"

#: ../doc/1.10/reference/tarantoolctl.rst:86
msgid "Stop a Tarantool instance."
msgstr "Остановка экземпляра Tarantool'а."

#: ../doc/1.10/reference/tarantoolctl.rst:94
msgid "``tarantoolctl status NAME``"
msgstr "``tarantoolctl status NAME``"

#: ../doc/1.10/reference/tarantoolctl.rst:89
msgid ""
"Show an instance's status (started/stopped). If pid file exists and an "
"alive control socket exists, the return code is ``0``. Otherwise, the "
"return code is not ``0``."
msgstr ""
"Отображение статуса экземпляра (работает/остановлен). Если есть PID-файл "
"и активный управляющий сокет, возвращается код ``0``. В остальных случаях"
" возвращается не ``0``."

#: ../doc/1.10/reference/tarantoolctl.rst:93
msgid ""
"Reports typical problems to stderr (e.g. pid file exists and control "
"socket doesn't)."
msgstr ""
"Сообщает о типичных проблемах стандартного вывода ошибок (например, "
"PID-файл есть, а управляющий сокет отсутствует)."

#: ../doc/1.10/reference/tarantoolctl.rst:101
msgid "``tarantoolctl restart NAME``"
msgstr "``tarantoolctl restart NAME``"

#: ../doc/1.10/reference/tarantoolctl.rst:97
msgid "Stop and start a Tarantool instance."
msgstr "Остановка и запуск экземпляра Tarantool’а."

#: ../doc/1.10/reference/tarantoolctl.rst:99
msgid ""
"Additionally, this command sets the TARANTOOL_RESTARTED environment "
"variable to 'true', to mark that the instance was restarted by "
"``tarantoolctl``."
msgstr ""
"Кроме того, данная команда задает значение переменной окружения "
"TARANTOOL_RESTARTED = 'true' (правда), чтобы отметить, что экземпляр был "
"перезапущен с помощью ``tarantoolctl``."

#: ../doc/1.10/reference/tarantoolctl.rst:106
msgid "``tarantoolctl logrotate NAME``"
msgstr "``tarantoolctl logrotate NAME``"

#: ../doc/1.10/reference/tarantoolctl.rst:104
msgid ""
"Rotate logs of a started Tarantool instance. Works only if logging-into-"
"file is enabled in the instance file. Pipe/syslog make no effect."
msgstr ""
"Ротация файлов журнала работающего Tarantool-экземпляра. Работает только "
"в том случае, если в файле экземпляра задан параметр записи журнала в "
"файл. Отправка записей в конвейер или системный журнал syslog не имеет "
"значения в данном случае."

#: ../doc/1.10/reference/tarantoolctl.rst:109
msgid "``tarantoolctl check NAME``"
msgstr "``tarantoolctl check NAME``"

#: ../doc/1.10/reference/tarantoolctl.rst:109
msgid "Check an instance file for syntax errors."
msgstr "Проверка файла экземпляра на ошибки синтаксиса."

#: ../doc/1.10/reference/tarantoolctl.rst:112
msgid "``tarantoolctl enter NAME``"
msgstr "``tarantoolctl enter NAME``"

#: ../doc/1.10/reference/tarantoolctl.rst:112
msgid "Enter an instance's interactive Lua console."
msgstr "Вход в интерактивную Lua-консоль экземпляра."

#: ../doc/1.10/reference/tarantoolctl.rst:115
msgid "``tarantoolctl eval NAME FILE``"
msgstr "``tarantoolctl eval NAME FILE``"

#: ../doc/1.10/reference/tarantoolctl.rst:115
msgid "Evaluate a local Lua file on a running Tarantool instance."
msgstr "Оценка локального Lua-файла на работающем экземпляре Tarantool'а."

#: ../doc/1.10/reference/tarantoolctl.rst:119
msgid "``tarantoolctl connect URI``"
msgstr "``tarantoolctl connect URI``"

#: ../doc/1.10/reference/tarantoolctl.rst:118
msgid ""
"Connect to a Tarantool instance on an admin-console port. Supports both "
"TCP/Unix sockets."
msgstr ""
"Подключение к экземпляру Tarantool'а по порту административной консоли. "
"Поддерживаются TCP и Unix сокеты."

#: ../doc/1.10/reference/tarantoolctl.rst:125
msgid "Commands for managing checkpoint files"
msgstr "Команды для управления файлами контрольной точки"

#: ../doc/1.10/reference/tarantoolctl.rst:128
msgid ""
"``tarantoolctl cat FILE.. [--space=space_no ..] [--show-system] "
"[--from=from_lsn] [--to=to_lsn] [--replica=replica_id ..]``"
msgstr ""
"``tarantoolctl cat FILE.. [--space=space_no ..] [--show-system] "
"[--from=from_lsn] [--to=to_lsn] [--replica=replica_id ..]``"

#: ../doc/1.10/reference/tarantoolctl.rst:128
msgid "Print into stdout the contents of .snap/.xlog files."
msgstr "Стандартный вывод содержимого .snap-файла или .xlog-файла."

#: ../doc/1.10/reference/tarantoolctl.rst:131
msgid ""
"``tarantoolctl play URI FILE.. [--space=space_no ..] [--show-system] "
"[--from=from_lsn] [--to=to_lsn] [--replica=replica_id ..]``"
msgstr ""
"``tarantoolctl play URI FILE.. [--space=space_no ..] [--show-system] "
"[--from=from_lsn] [--to=to_lsn] [--replica=replica_id ..]``"

#: ../doc/1.10/reference/tarantoolctl.rst:131
msgid "Play the contents of .snap/.xlog files to another Tarantool instance."
msgstr ""
"Передача содержимого .snap-файла или .xlog-файла на другой экземпляр "
"Tarantool'а."

#: ../doc/1.10/reference/tarantoolctl.rst:133
#: ../doc/1.10/reference/tarantoolctl.rst:184
msgid "Supported options:"
msgstr "Поддерживаемые опции:"

#: ../doc/1.10/reference/tarantoolctl.rst:135
msgid ""
"``--space=space_no`` to filter the output by space number. May be passed "
"more than once."
msgstr ""
"``--space=space_no`` для фильтрации вывода по номеру спейса. Можно "
"передавать несколько раз."

#: ../doc/1.10/reference/tarantoolctl.rst:137
msgid "``--show-system`` to show the contents of system spaces."
msgstr "``--show-system`` для отображения содержимого системных спейсов."

#: ../doc/1.10/reference/tarantoolctl.rst:138
msgid "``--from=from_lsn`` to show operations starting from the given lsn."
msgstr "``--from=from_lsn`` для отображения операций, начиная с заданного LSN."

#: ../doc/1.10/reference/tarantoolctl.rst:139
msgid "``--to=to_lsn`` to show operations ending with the given lsn."
msgstr "``--to=to_lsn`` для отображения операций, заканчивая заданным LSN."

#: ../doc/1.10/reference/tarantoolctl.rst:140
msgid ""
"``--replica=replica_id`` to filter the output by replica id. May be "
"passed more than once."
msgstr ""
"``--replica=replica_id`` для фильтрации вывода по идентификатору реплики."
" Можно передавать несколько раз."

#: ../doc/1.10/reference/tarantoolctl.rst:147
msgid "Commands for managing Tarantool modules"
msgstr "Команды для управления модулями Tarantool'а"

#: ../doc/1.10/reference/tarantoolctl.rst:150
msgid "``tarantoolctl rocks install NAME``"
msgstr "``tarantoolctl rocks install NAME``"

#: ../doc/1.10/reference/tarantoolctl.rst:150
msgid "Install a module in the current directory."
msgstr "Установка модуля в текущей директории."

#: ../doc/1.10/reference/tarantoolctl.rst:153
msgid "``tarantoolctl rocks remove NAME``"
msgstr "``tarantoolctl rocks remove NAME``"

#: ../doc/1.10/reference/tarantoolctl.rst:153
msgid "Remove a module."
msgstr "Удаление модуля."

#: ../doc/1.10/reference/tarantoolctl.rst:156
msgid "``tarantoolctl rocks show NAME``"
msgstr "``tarantoolctl rocks show NAME``"

#: ../doc/1.10/reference/tarantoolctl.rst:156
msgid "Show information about an installed module."
msgstr "Отображение информации об установленном модуле."

#: ../doc/1.10/reference/tarantoolctl.rst:159
msgid "``tarantoolctl rocks search NAME``"
msgstr "``tarantoolctl rocks search NAME``"

#: ../doc/1.10/reference/tarantoolctl.rst:159
msgid "Search the repository for modules."
msgstr "Поиск модулей по репозиторию."

#: ../doc/1.10/reference/tarantoolctl.rst:162
msgid "``tarantoolctl rocks list``"
msgstr "``tarantoolctl rocks list``"

#: ../doc/1.10/reference/tarantoolctl.rst:162
msgid "List all installed modules."
msgstr "Вывод списка всех установленных модулей."

#: ../doc/1.10/reference/tarantoolctl.rst:172
msgid "``tarantoolctl rocks pack {<rockspec> | <name> [<version>]}``"
msgstr "``tarantoolctl rocks pack {<rockspec> | <имя> [<версия>]}``"

#: ../doc/1.10/reference/tarantoolctl.rst:165
msgid "Create a rock by packing sources or binaries."
msgstr "Создание модуля путем компоновки исходных или бинарных файлов."

#: ../doc/1.10/reference/tarantoolctl.rst:167
#: ../doc/1.10/reference/tarantoolctl.rst:177
msgid "As an argument, you can specify:"
msgstr "В качестве аргумента можно указать:"

#: ../doc/1.10/reference/tarantoolctl.rst:169
msgid ""
"a ``.rockspec`` file to create a source rock containing the module's "
"sources, or"
msgstr ""
"файл в формате ``.rockspec`` для создания модуля, который содержит "
"исходные файлы или"

#: ../doc/1.10/reference/tarantoolctl.rst:171
msgid ""
"the name of an installed module (and its version if there are more than "
"one) to create a binary rock containing the compiled module."
msgstr ""
"имя установленного модуля (с версией, если их больше одной) для создания "
"модуля, который содержит скомпилированные файлы."

#: ../doc/1.10/reference/tarantoolctl.rst:182
msgid ""
"``tarantoolctl rocks unpack {<rock_file> | <rockspec> | <name> "
"[version]}``"
msgstr "``tarantoolctl rocks unpack {<rock_file> | <rockspec> | <имя> [версия]}``"

#: ../doc/1.10/reference/tarantoolctl.rst:175
msgid "Unpack the contents of a rock into a new directory under the current one."
msgstr "Распаковка содержимого модуля в новую директорию в текущей директории."

#: ../doc/1.10/reference/tarantoolctl.rst:179
msgid "source or binary rock files,"
msgstr "исходные или бинарные файлы модуля,"

#: ../doc/1.10/reference/tarantoolctl.rst:180
msgid "``.rockspec`` files, or"
msgstr "файлы ``.rockspec`` или"

#: ../doc/1.10/reference/tarantoolctl.rst:181
msgid ""
"names of rocks or ``.rockspec`` files in remote repositories (and the "
"rock version if there are more than one)."
msgstr ""
"имя модулей или файлов в формате ``.rockspec`` в удаленных репозиториях "
"(с версией модуля, если их больше одной)."

#: ../doc/1.10/reference/tarantoolctl.rst:186
msgid "``--server=server_name`` check this server first, then the usual list."
msgstr "``--server=имя_севрера`` сначала проверить данный сервер, затем по списку."

#: ../doc/1.10/reference/tarantoolctl.rst:187
msgid ""
"``--only-server=server_name`` check this server only, ignore the usual "
"list."
msgstr ""
"``--only-server=имя_сервера`` проверить только данный сервер, остальные "
"пропустить."

#: ../doc/1.10/tutorials/c_tutorial.rst:37
msgid "C tutorial"
msgstr "Практическое задание на C"

#: ../doc/1.10/tutorials/c_tutorial.rst:39
msgid ""
"Here is one C tutorial: :ref:`C stored procedures <f_c_tutorial-"
"c_stored_procedures>`."
msgstr ""
"Ниже приводится практическое занятие на языке C: :ref:`Хранимые процедуры"
" на языке C <f_c_tutorial-c_stored_procedures>`."

#: ../doc/1.10/tutorials/c_tutorial.rst:46
msgid "C stored procedures"
msgstr "Хранимые процедуры на языке C"

#: ../doc/1.10/tutorials/c_tutorial.rst:48
msgid ""
"Tarantool can call C code with :ref:`modules <app_server-modules>`, or "
"with :ref:`ffi <cookbook-ffi_printf>`, or with C stored procedures. This "
"tutorial only is about the third option, C stored procedures. In fact the"
" routines are always \"C functions\" but the phrase \"stored procedure\" "
"is commonly used for historical reasons."
msgstr ""
"Tarantool может вызывать код на языке C с помощью :ref:`модулей "
"<app_server-modules>`, :ref:`ffi <cookbook-ffi_printf>` или хранимых "
"процедур на C. В данном практическом задании рассматривается только "
"третий метод, хранимые процедуры на языке C. На самом деле, программы "
"всегда представляют собой функции на языке C, но исторически сложилось "
"так, что широко используется фраза \"хранимая процедура\"."

#: ../doc/1.10/tutorials/c_tutorial.rst:55
msgid ""
"In this tutorial, which can be followed by anyone with a Tarantool "
"development package and a C compiler, there are five tasks:"
msgstr ""
"Данное практическое задание могут выполнить те, у кого есть пакет "
"программ для разработки Tarantool'а и компилятор языка программирования "
"C. Оно состоит из пяти задач:"

#: ../doc/1.10/tutorials/c_tutorial.rst:58
msgid ":ref:`easy.c <f_c_tutorial-easy>` -- prints \"hello world\";"
msgstr ":ref:`easy.c <f_c_tutorial-easy>` -- выводит \"hello world\";"

#: ../doc/1.10/tutorials/c_tutorial.rst:59
msgid ":ref:`harder.c <f_c_tutorial-harder>` -- decodes a passed parameter value;"
msgstr ""
":ref:`harder.c <f_c_tutorial-harder>` -- декодирует переданное значение "
"параметра;"

#: ../doc/1.10/tutorials/c_tutorial.rst:60
msgid ""
":ref:`hardest.c <f_c_tutorial-hardest>` -- uses the C API to do a DBMS "
"insert;"
msgstr ""
":ref:`hardest.c <f_c_tutorial-hardest>` -- использует API для языка C для"
" вставки в базу данных;"

#: ../doc/1.10/tutorials/c_tutorial.rst:61
msgid ":ref:`read.c <f_c_tutorial-read>` -- uses the C API to do a DBMS select;"
msgstr ""
":ref:`read.c <f_c_tutorial-read>` -- использует API для языка C для "
"выборки из базы данных;"

#: ../doc/1.10/tutorials/c_tutorial.rst:62
msgid ""
":ref:`write.c <f_c_tutorial-write>` -- uses the C API to do a DBMS "
"replace."
msgstr ""
":ref:`write.c <f_c_tutorial-write>` -- использует API для языка C для "
"замены в базе данных."

#: ../doc/1.10/tutorials/c_tutorial.rst:64
msgid ""
"After following the instructions, and seeing that the results are what is"
" described here, users should feel confident about writing their own "
"stored procedures."
msgstr ""
"По окончании задания, вы увидите описанные здесь результаты и сможете "
"самостоятельно написать хранимые процедуры."

#: ../doc/1.10/tutorials/c_tutorial.rst:68
msgid "**Preparation**"
msgstr "**Подготовка**"

#: ../doc/1.10/tutorials/c_tutorial.rst:70
msgid "Check that these items exist on the computer:"
msgstr "Проверьте наличие следующих элементов на компьютере:"

#: ../doc/1.10/tutorials/c_tutorial.rst:72
msgid "Tarantool 1.10"
msgstr "Tarantool 1.10"

#: ../doc/1.10/tutorials/c_tutorial.rst:73
msgid "A gcc compiler, any modern version should work"
msgstr "Компилятор GCC, подойдет любая современная версия"

#: ../doc/1.10/tutorials/c_tutorial.rst:74
msgid "``module.h`` and files #included in it"
msgstr "``module.h`` и включенные в него файлы"

#: ../doc/1.10/tutorials/c_tutorial.rst:75
msgid "``msgpuck.h``"
msgstr "``msgpuck.h``"

#: ../doc/1.10/tutorials/c_tutorial.rst:76
msgid "``libmsgpuck.a`` (only for some recent msgpuck versions)"
msgstr "``libmsgpuck.a`` (только для некоторых последних версий msgpuck)"

#: ../doc/1.10/tutorials/c_tutorial.rst:78
msgid ""
"The ``module.h`` file will exist if Tarantool was installed from source. "
"Otherwise Tarantool's \"developer\" package must be installed. For "
"example on Ubuntu say:"
msgstr ""
"Файл ``module.h`` есть в системе, если Tarantool был установлен из "
"исходных файлов. В противном случае, следует установить пакет Tarantool'а"
" \"developer\". Например, на Ubuntu введите команду:"

#: ../doc/1.10/tutorials/c_tutorial.rst:86
msgid "or on Fedora say:"
msgstr "или на Fedora введите команду:"

#: ../doc/1.10/tutorials/c_tutorial.rst:88
msgid "$ dnf -y install tarantool-devel"
msgstr "$ dnf -y install tarantool-devel"

#: ../doc/1.10/tutorials/c_tutorial.rst:92
msgid ""
"The ``msgpuck.h`` file will exist if Tarantool was installed from source."
" Otherwise the \"msgpuck\" package must be installed from "
"`https://github.com/rtsisyk/msgpuck "
"<https://github.com/rtsisyk/msgpuck>`_."
msgstr ""
"Файл ``msgpuck.h`` есть в системе, если Tarantool был установлен из "
"исходных файлов. В противном случае, следует установить пакет \"msgpuck\""
" по ссылке `https://github.com/rtsisyk/msgpuck "
"<https://github.com/rtsisyk/msgpuck>`_."

#: ../doc/1.10/tutorials/c_tutorial.rst:96
msgid ""
"Both ``module.h`` and ``msgpuck.h`` must be on the include path for the C"
" compiler to see them. For example, if ``module.h`` address is "
"``/usr/local/include/tarantool/module.h``, and ``msgpuck.h`` address is "
"``/usr/local/include/msgpuck/msgpuck.h``, and they are not currently on "
"the include path, say:"
msgstr ""
"Чтобы компилятор C увидел файлы ``module.h`` и ``msgpuck.h``, путь к ним "
"следует сохранить в переменной. Например, если адрес файла ``module.h`` "
"-- ``/usr/local/include/tarantool/module.h``, а адрес файла ``msgpuck.h``"
" -- ``/usr/local/include/msgpuck/msgpuck.h``, введите команду:"

#: ../doc/1.10/tutorials/c_tutorial.rst:102
msgid "$ export CPATH=/usr/local/include/tarantool:/usr/local/include/msgpuck"
msgstr "$ export CPATH=/usr/local/include/tarantool:/usr/local/include/msgpuck"

#: ../doc/1.10/tutorials/c_tutorial.rst:106
msgid ""
"The ``libmsgpuck.a`` static library is necessary with msgpuck versions "
"produced after February 2017. If and only if you encounter linking "
"problems when using the gcc statements in the examples for this tutorial,"
" you should put ``libmsgpuck.a`` on the path (``libmsgpuck.a`` is "
"produced from both msgpuck and Tarantool source downloads so it should be"
" easy to find). For example, instead of \":code:`gcc -shared -o harder.so"
" -fPIC harder.c`\" for the second example below, you will need to say "
"\":code:`gcc -shared -o harder.so -fPIC harder.c libmsgpuck.a`\"."
msgstr ""
"Статическая библиотека ``libmsgpuck.a`` нужна для версий msgpuck старше "
"февраля 2017 года. Только в том случае, если встречаются проблемы "
"соединения при использовании операторов GCC в примерах данного "
"практического задания, в пути следует указывать ``libmsgpuck.a`` "
"(``libmsgpuck.a`` создан из исходных файлов загрузки msgpuck и Tarantool,"
" поэтому его легко найти). Например, вместо \":code:`gcc -shared -o "
"harder.so -fPIC harder.c`\" во втором примере ниже, необходимо ввести "
"\":code:`gcc -shared -o harder.so -fPIC harder.c libmsgpuck.a`\"."

#: ../doc/1.10/tutorials/c_tutorial.rst:115
msgid ""
"Requests will be done using Tarantool as a :ref:`client <admin-"
"using_tarantool_as_a_client>`. Start Tarantool, and enter these requests."
msgstr ""
"Tarantool выполняет запросы в качестве :ref:`клиента <admin-"
"using_tarantool_as_a_client>`. Запустите Tarantool и введите эти запросы."

#: ../doc/1.10/tutorials/c_tutorial.rst:119
msgid ""
"box.cfg{listen=3306}\n"
"box.schema.space.create('capi_test')\n"
"box.space.capi_test:create_index('primary')\n"
"net_box = require('net.box')\n"
"capi_connection = net_box:new(3306)"
msgstr ""
"box.cfg{listen=3306}\n"
"box.schema.space.create('capi_test')\n"
"box.space.capi_test:create_index('primary')\n"
"net_box = require('net.box')\n"
"capi_connection = net_box:new(3306)"

#: ../doc/1.10/tutorials/c_tutorial.rst:127
msgid ""
"In plainer language: create a space named ``capi_test``, and make a "
"connection to self named ``capi_connection``."
msgstr ""
"Проще говоря: создайте спейс под названием ``capi_test``, и выполните "
"соединение с одноименным ``capi_connection``."

#: ../doc/1.10/tutorials/c_tutorial.rst:130
msgid ""
"Leave the client running. It will be necessary to enter more requests "
"later."
msgstr "Не закрывайте клиент. Он понадобится для последующих запросов."

#: ../doc/1.10/tutorials/c_tutorial.rst:134
msgid "**easy.c**"
msgstr "**easy.c**"

#: ../doc/1.10/tutorials/c_tutorial.rst:136
msgid ""
"Start another shell. Change directory (``cd``) so that it is the same as "
"the directory that the client is running on."
msgstr ""
"Запустите еще один терминал. Измените директорию (``cd``), чтобы она "
"совпадала с директорией, где запущен клиент."

#: ../doc/1.10/tutorials/c_tutorial.rst:139
msgid "Create a file. Name it ``easy.c``. Put these six lines in it."
msgstr ""
"Создайте файл. Назовите его ``easy.c``. Запишите в него следующие шесть "
"строк."

#: ../doc/1.10/tutorials/c_tutorial.rst:141
msgid ""
"#include \"module.h\"\n"
"int easy(box_function_ctx_t *ctx, const char *args, const char *args_end)"
"\n"
"{\n"
"  printf(\"hello world\\n\");\n"
"  return 0;\n"
"}\n"
"int easy2(box_function_ctx_t *ctx, const char *args, const char "
"*args_end)\n"
"{\n"
"  printf(\"hello world -- easy2\\n\");\n"
"  return 0;\n"
"}"
msgstr ""
"#include \"module.h\"\n"
"int easy(box_function_ctx_t *ctx, const char *args, const char *args_end)"
"\n"
"{\n"
"  printf(\"hello world\\n\");\n"
"  return 0;\n"
"}\n"
"int easy2(box_function_ctx_t *ctx, const char *args, const char "
"*args_end)\n"
"{\n"
"  printf(\"hello world -- easy2\\n\");\n"
"  return 0;\n"
"}"

#: ../doc/1.10/tutorials/c_tutorial.rst:156
msgid "Compile the program, producing a library file named ``easy.so``:"
msgstr ""
"Скомпилируйте программу, что создаст файл библиотеки под названием "
"``easy.so``:"

#: ../doc/1.10/tutorials/c_tutorial.rst:158
msgid "$ gcc -shared -o easy.so -fPIC easy.c"
msgstr "$ gcc -shared -o easy.so -fPIC easy.c"

#: ../doc/1.10/tutorials/c_tutorial.rst:162
#: ../doc/1.10/tutorials/c_tutorial.rst:250
#: ../doc/1.10/tutorials/c_tutorial.rst:337
#: ../doc/1.10/tutorials/c_tutorial.rst:441
#: ../doc/1.10/tutorials/c_tutorial.rst:522
msgid "Now go back to the client and execute these requests:"
msgstr "Теперь вернитесь в клиент и выполните следующие запросы:"

#: ../doc/1.10/tutorials/c_tutorial.rst:164
msgid ""
"box.schema.func.create('easy', {language = 'C'})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'easy')\n"
"capi_connection:call('easy')"
msgstr ""
"box.schema.func.create('easy', {language = 'C'})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'easy')\n"
"capi_connection:call('easy')"

#: ../doc/1.10/tutorials/c_tutorial.rst:170
msgid ""
"If these requests appear unfamiliar, re-read the descriptions of "
":ref:`box.schema.func.create() <box_schema-func_create>`, "
":ref:`box.schema.user.grant() <box_schema-user_grant>` and "
":ref:`conn:call() <net_box-call>`."
msgstr ""
"Если эти запросы вам незнакомы, перечитайте описание "
":ref:`box.schema.func.create() <box_schema-func_create>`, "
":ref:`box.schema.user.grant() <box_schema-user_grant>` и "
":ref:`conn:call() <net_box-call>`."

#: ../doc/1.10/tutorials/c_tutorial.rst:176
msgid "The function that matters is ``capi_connection:call('easy')``."
msgstr "Важна функция ``capi_connection:call('easy')``."

#: ../doc/1.10/tutorials/c_tutorial.rst:178
msgid ""
"Its first job is to find the 'easy' function, which should be easy "
"because by default Tarantool looks on the current directory for a file "
"named ``easy.so``."
msgstr ""
"Во-первых, она ищет функцию easy, что должно быть легко, потому что по "
"умолчанию Tarantool ищет в текущей директории файл под названием "
"``easy.so``."

#: ../doc/1.10/tutorials/c_tutorial.rst:182
msgid ""
"Its second job is to call the 'easy' function. Since the ``easy()`` "
"function in ``easy.c`` begins with ``printf(\"hello world\\n\")``, the "
"words \"hello world\" will appear on the screen."
msgstr ""
"Во-вторых, она вызывает функцию easy. Поскольку функция ``easy()`` в "
"``easy.c`` начинается с ``printf(\"hello world\\n\")``, слова \"hello "
"world\" появятся на экране."

#: ../doc/1.10/tutorials/c_tutorial.rst:186
msgid ""
"Its third job is to check that the call was successful. Since the "
"``easy()`` function in ``easy.c`` ends with :code:`return 0`, there is no"
" error message to display and the request is over."
msgstr ""
"В-третьих, она проверяет, что вызов прошел успешно. Поскольку функция "
"``easy()`` в ``easy.c`` оканчивается на :code:`return 0`, сообщение об "
"ошибке отсутствует, и запрос выполнен."

#: ../doc/1.10/tutorials/c_tutorial.rst:190
#: ../doc/1.10/tutorials/c_tutorial.rst:366
msgid "The result should look like this:"
msgstr "Результат должен выглядеть следующим образом:"

#: ../doc/1.10/tutorials/c_tutorial.rst:192
msgid ""
"tarantool> capi_connection:call('easy')\n"
"hello world\n"
"---\n"
"- []\n"
"..."
msgstr ""
"tarantool> capi_connection:call('easy')\n"
"hello world\n"
"---\n"
"- []\n"
"..."

#: ../doc/1.10/tutorials/c_tutorial.rst:200
msgid ""
"Now let's call the other function in easy.c -- ``easy2()``. This is "
"almost the same as the ``easy()`` function, but there's a detail: when "
"the file name is not the same as the function name, then we have to "
"specify :samp:`{file-name}.{function-name}`."
msgstr ""
"Теперь вызовем другую функцию в easy.c -- ``easy2()``. Она практически "
"совпадает с функцией ``easy()``, но есть небольшое отличие: если имя "
"файла не совпадет с именем функции, нужно будет указать "
":samp:`{имя-файла}.{имя-функции}`."

#: ../doc/1.10/tutorials/c_tutorial.rst:206
msgid ""
"box.schema.func.create('easy.easy2', {language = 'C'})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'easy.easy2')\n"
"capi_connection:call('easy.easy2')"
msgstr ""
"box.schema.func.create('easy.easy2', {language = 'C'})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'easy.easy2')\n"
"capi_connection:call('easy.easy2')"

#: ../doc/1.10/tutorials/c_tutorial.rst:212
msgid "... and this time the result will be \"hello world -- easy2\"."
msgstr "... и на этот раз результатом будет: \"hello world -- easy2\"."

#: ../doc/1.10/tutorials/c_tutorial.rst:214
msgid "Conclusion: calling a C function is easy."
msgstr "Вывод: вызвать C-функцию легко."

#: ../doc/1.10/tutorials/c_tutorial.rst:218
msgid "**harder.c**"
msgstr "**harder.c**"

#: ../doc/1.10/tutorials/c_tutorial.rst:220
msgid "Go back to the shell where the ``easy.c`` program was created."
msgstr "Вернитесь в терминал, где была создана программа ``easy.c``."

#: ../doc/1.10/tutorials/c_tutorial.rst:222
msgid "Create a file. Name it ``harder.c``. Put these 17 lines in it:"
msgstr ""
"Создайте файл. Назовите его ``harder.c``. Запишите в него следующие 17 "
"строк:"

#: ../doc/1.10/tutorials/c_tutorial.rst:224
#, python-format
msgid ""
"#include \"module.h\"\n"
"#include \"msgpuck.h\"\n"
"int harder(box_function_ctx_t *ctx, const char *args, const char "
"*args_end)\n"
"{\n"
"  uint32_t arg_count = mp_decode_array(&args);\n"
"  printf(\"arg_count = %d\\n\", arg_count);\n"
"  uint32_t field_count = mp_decode_array(&args);\n"
"  printf(\"field_count = %d\\n\", field_count);\n"
"  uint32_t val;\n"
"  int i;\n"
"  for (i = 0; i < field_count; ++i)\n"
"  {\n"
"    val = mp_decode_uint(&args);\n"
"    printf(\"val=%d.\\n\", val);\n"
"  }\n"
"  return 0;\n"
"}"
msgstr ""
"#include \"module.h\"\n"
"#include \"msgpuck.h\"\n"
"int harder(box_function_ctx_t *ctx, const char *args, const char "
"*args_end)\n"
"{\n"
"  uint32_t arg_count = mp_decode_array(&args);\n"
"  printf(\"arg_count = %d\\n\", arg_count);\n"
"  uint32_t field_count = mp_decode_array(&args);\n"
"  printf(\"field_count = %d\\n\", field_count);\n"
"  uint32_t val;\n"
"  int i;\n"
"  for (i = 0; i < field_count; ++i)\n"
"  {\n"
"    val = mp_decode_uint(&args);\n"
"    printf(\"val=%d.\\n\", val);\n"
"  }\n"
"  return 0;\n"
"}"

#: ../doc/1.10/tutorials/c_tutorial.rst:244
msgid "Compile the program, producing a library file named ``harder.so``:"
msgstr ""
"Скомпилируйте программу, что создаст файл библиотеки под названием "
"``harder.so``:"

#: ../doc/1.10/tutorials/c_tutorial.rst:246
msgid "$ gcc -shared -o harder.so -fPIC harder.c"
msgstr "$ gcc -shared -o harder.so -fPIC harder.c"

#: ../doc/1.10/tutorials/c_tutorial.rst:252
msgid ""
"box.schema.func.create('harder', {language = 'C'})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'harder')\n"
"passable_table = {}\n"
"table.insert(passable_table, 1)\n"
"table.insert(passable_table, 2)\n"
"table.insert(passable_table, 3)\n"
"capi_connection:call('harder', passable_table)"
msgstr ""
"box.schema.func.create('harder', {language = 'C'})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'harder')\n"
"passable_table = {}\n"
"table.insert(passable_table, 1)\n"
"table.insert(passable_table, 2)\n"
"table.insert(passable_table, 3)\n"
"capi_connection:call('harder', passable_table)"

#: ../doc/1.10/tutorials/c_tutorial.rst:262
msgid ""
"This time the call is passing a Lua table (``passable_table``) to the "
"``harder()`` function. The ``harder()`` function will see it, it's in the"
" :code:`char *args` parameter."
msgstr ""
"На этот раз вызов передает Lua-таблицу (``passable_table``) в функцию "
"``harder()``. Функция``harder()`` увидит это, как указано в параметре "
":code:`char *args`."

#: ../doc/1.10/tutorials/c_tutorial.rst:266
msgid ""
"At this point the ``harder()`` function will start using functions "
"defined in `msgpuck.h <http://rtsisyk.github.io/msgpuck>`_. The routines "
"that begin with \"mp\" are msgpuck functions that handle data formatted "
"according to the MsgPack_ specification. Passes and returns are always "
"done with this format so one must become acquainted with msgpuck to "
"become proficient with the C API."
msgstr ""
"На данный момент функция ``harder()`` начнет использовать функции, "
"определенные в `msgpuck.h <http://rtsisyk.github.io/msgpuck>`_. "
"Процедуры, которые начинаются с \"mp\" -- это функции msgpuck, которые "
"обрабатывают данные в формате MsgPack_. Передача и возврат всегда "
"осуществляются в этом формате, поэтому следует ознакомиться с msgpuck для"
" того, чтобы овладеть навыками работы с API для языка C."

#: ../doc/1.10/tutorials/c_tutorial.rst:274
msgid ""
"For now, though, it's enough to know that ``mp_decode_array()`` returns "
"the number of elements in an array, and ``mp_decode_uint`` returns an "
"unsigned integer, from :code:`args`. And there's a side effect: when the "
"decoding finishes, :code:`args` has changed and is now pointing to the "
"next element."
msgstr ""
"Однако, пока достаточно понимать, что функция ``mp_decode_array()`` "
"возвращает количество элементов в массиве, а функция ``mp_decode_uint`` "
"возвращает целое число без знака из :code:`args`. Есть также побочный "
"эффект: по окончании декодирования :code:`args` изменился и теперь "
"указывает на следующий элемент."

#: ../doc/1.10/tutorials/c_tutorial.rst:280
msgid ""
"Therefore the first displayed line will be \"arg_count = 1\" because "
"there was only one item passed: ``passable_table``. |br| The second "
"displayed line will be \"field_count = 3\" because there are three items "
"in the table. |br| The next three lines will be \"1\" and \"2\" and \"3\""
" because those are the values in the items in the table."
msgstr ""
"Таким образом, первой будет отображена строка \"arg_count = 1\", "
"поскольку был передан только один элемент: ``passable_table``. |br| "
"Второй будет отображена строка \"field_count = 3\", потому что в таблице "
"находятся три элемента. |br| Следующие три строки будут \"1\", \"2\" и "
"\"3\", потому что это значения элементов в таблице."

#: ../doc/1.10/tutorials/c_tutorial.rst:287
msgid "And now the screen looks like this:"
msgstr "Теперь вывод на экране выглядит следующим образом:"

#: ../doc/1.10/tutorials/c_tutorial.rst:289
msgid ""
"tarantool> capi_connection:call('harder', passable_table)\n"
"arg_count = 1\n"
"field_count = 3\n"
"val=1.\n"
"val=2.\n"
"val=3.\n"
"---\n"
"- []\n"
"..."
msgstr ""
"tarantool> capi_connection:call('harder', passable_table)\n"
"arg_count = 1\n"
"field_count = 3\n"
"val=1.\n"
"val=2.\n"
"val=3.\n"
"---\n"
"- []\n"
"..."

#: ../doc/1.10/tutorials/c_tutorial.rst:301
msgid ""
"Conclusion: decoding parameter values passed to a C function is not easy "
"at first, but there are routines to do the job, and they're documented, "
"and there aren't very many of them."
msgstr ""
"Вывод: на первый взгляд, декодирование значений параметров, переданных в "
"C-функцию непросто, но существуют документированные процедуры для этих "
"целей, и их не так много."

#: ../doc/1.10/tutorials/c_tutorial.rst:308
msgid "**hardest.c**"
msgstr "**hardest.c**"

#: ../doc/1.10/tutorials/c_tutorial.rst:310
msgid ""
"Go back to the shell where the ``easy.c`` and the ``harder.c`` programs "
"were created."
msgstr ""
"Вернитесь в терминал, где были созданы программы ``easy.c`` и "
"``harder.c``."

#: ../doc/1.10/tutorials/c_tutorial.rst:313
msgid "Create a file. Name it ``hardest.c``. Put these 13 lines in it:"
msgstr ""
"Создайте файл. Назовите его ```hardest.c``. Запишите в него следующие 13 "
"строк:"

#: ../doc/1.10/tutorials/c_tutorial.rst:315
msgid ""
"#include \"module.h\"\n"
"#include \"msgpuck.h\"\n"
"int hardest(box_function_ctx_t *ctx, const char *args, const char "
"*args_end)\n"
"{\n"
"  uint32_t space_id = box_space_id_by_name(\"capi_test\", "
"strlen(\"capi_test\"));\n"
"  char tuple[1024]; /* Must be big enough for mp_encode results */\n"
"  char *tuple_pointer = tuple;\n"
"  tuple_pointer = mp_encode_array(tuple_pointer, 2);\n"
"  tuple_pointer = mp_encode_uint(tuple_pointer, 10000);\n"
"  tuple_pointer = mp_encode_str(tuple_pointer, \"String 2\", 8);\n"
"  int n = box_insert(space_id, tuple, tuple_pointer, NULL);\n"
"  return n;\n"
"}"
msgstr ""
"#include \"module.h\"\n"
"#include \"msgpuck.h\"\n"
"int hardest(box_function_ctx_t *ctx, const char *args, const char "
"*args_end)\n"
"{\n"
"  uint32_t space_id = box_space_id_by_name(\"capi_test\", "
"strlen(\"capi_test\"));\n"
"  char tuple[1024]; /* Must be big enough for mp_encode results */\n"
"  char *tuple_pointer = tuple;\n"
"  tuple_pointer = mp_encode_array(tuple_pointer, 2);\n"
"  tuple_pointer = mp_encode_uint(tuple_pointer, 10000);\n"
"  tuple_pointer = mp_encode_str(tuple_pointer, \"String 2\", 8);\n"
"  int n = box_insert(space_id, tuple, tuple_pointer, NULL);\n"
"  return n;\n"
"}"

#: ../doc/1.10/tutorials/c_tutorial.rst:331
msgid "Compile the program, producing a library file named ``hardest.so``:"
msgstr ""
"Скомпилируйте программу, что создаст файл библиотеки под названием "
"``hardest.so``:"

#: ../doc/1.10/tutorials/c_tutorial.rst:333
msgid "$ gcc -shared -o hardest.so -fPIC hardest.c"
msgstr "$ gcc -shared -o hardest.so -fPIC hardest.c"

#: ../doc/1.10/tutorials/c_tutorial.rst:339
msgid ""
"box.schema.func.create('hardest', {language = \"C\"})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'hardest')\n"
"box.schema.user.grant('guest', 'read,write', 'space', 'capi_test')\n"
"capi_connection:call('hardest')"
msgstr ""
"box.schema.func.create('hardest', {language = \"C\"})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'hardest')\n"
"box.schema.user.grant('guest', 'read,write', 'space', 'capi_test')\n"
"capi_connection:call('hardest')"

#: ../doc/1.10/tutorials/c_tutorial.rst:346
msgid "This time the C function is doing three things:"
msgstr "На этот раз C-функция выполняет три действия:"

#: ../doc/1.10/tutorials/c_tutorial.rst:348
msgid ""
"finding the numeric identifier of the ``capi_test`` space by calling "
"``box_space_id_by_name()``;"
msgstr ""
"найдет числовой идентификатор спейса ``capi_test`` путем вызова "
"``box_space_id_by_name()``;"

#: ../doc/1.10/tutorials/c_tutorial.rst:350
msgid "formatting a tuple using more ``msgpuck.h`` functions;"
msgstr "форматирует кортеж, используя другие функции ``msgpuck.h``;"

#: ../doc/1.10/tutorials/c_tutorial.rst:351
msgid "inserting a tuple using ``box_insert()``."
msgstr "вставит кортеж с помощью ``box_insert()``."

#: ../doc/1.10/tutorials/c_tutorial.rst:355
msgid ""
"``char tuple[1024];`` is used here as just a quick way of saying "
"\"allocate more than enough bytes\". For serious programs the developer "
"must be careful to allow enough space for all the bytes that the "
"``mp_encode`` routines will use up."
msgstr ""
"``char tuple[1024];`` используется здесь просто в качестве быстрого "
"способа ввода команды \"выделить байтов с запасом\". В серьезных "
"программах разработчику следует обратить внимание на то, чтобы выделить "
"достаточно места, которое будут использовать процедуры ``mp_encode``."

#: ../doc/1.10/tutorials/c_tutorial.rst:360
msgid "Now, still on the client, execute this request:"
msgstr "Затем всё еще в клиенте выполните следующий запрос:"

#: ../doc/1.10/tutorials/c_tutorial.rst:362
msgid "box.space.capi_test:select()"
msgstr "box.space.capi_test:select()"

#: ../doc/1.10/tutorials/c_tutorial.rst:368
msgid ""
"tarantool> box.space.capi_test:select()\n"
"---\n"
"- - [10000, 'String 2']\n"
"..."
msgstr ""
"tarantool> box.space.capi_test:select()\n"
"---\n"
"- - [10000, 'String 2']\n"
"..."

#: ../doc/1.10/tutorials/c_tutorial.rst:375
msgid ""
"This proves that the ``hardest()`` function succeeded, but where did "
":ref:`box_space_id_by_name() <box-box_space_id_by_name>` and "
":ref:`box_insert() <box-box_insert>` come from? Answer: the :ref:`C API "
"<index-c_api_reference>`."
msgstr ""
"Это доказывает, что функция ``hardest()`` была успешно выполнена, но "
"откуда взялись :ref:`box_space_id_by_name() <box-box_space_id_by_name>` и"
" :ref:`box_insert() <box-box_insert>`? Ответ: :ref:`API для языка C "
"<index-c_api_reference>`."

#: ../doc/1.10/tutorials/c_tutorial.rst:382
msgid "**read.c**"
msgstr "**read.c**"

#: ../doc/1.10/tutorials/c_tutorial.rst:384
msgid ""
"Go back to the shell where the ``easy.c`` and the ``harder.c`` and the "
"``hardest.c`` programs were created."
msgstr ""
"Вернитесь в терминал, где были созданы программы ``easy.c``, ``harder.c``"
" и ``hardest.c``."

#: ../doc/1.10/tutorials/c_tutorial.rst:387
msgid "Create a file. Name it ``read.c``. Put these 43 lines in it:"
msgstr ""
"Создайте файл. Назовите его ``read.c``. Запишите в него следующие 43 "
"строки:"

#: ../doc/1.10/tutorials/c_tutorial.rst:389
#, python-format
msgid ""
"#include \"module.h\"\n"
"#include <msgpuck.h>\n"
"int read(box_function_ctx_t *ctx, const char *args, const char *args_end)"
"\n"
"{\n"
"  char tuple_buf[1024];      /* where the raw MsgPack tuple will be "
"stored */\n"
"  uint32_t space_id = box_space_id_by_name(\"capi_test\", "
"strlen(\"capi_test\"));\n"
"  uint32_t index_id = 0;     /* The number of the space's first index */\n"
"  uint32_t key = 10000;      /* The key value that box_insert() used */\n"
"  mp_encode_array(tuple_buf, 0); /* clear */\n"
"  box_tuple_format_t *fmt = box_tuple_format_default();\n"
"  box_tuple_t *tuple = box_tuple_new(fmt, tuple_buf, tuple_buf+512);\n"
"  assert(tuple != NULL);\n"
"  char key_buf[16];          /* Pass key_buf = encoded key = 1000 */\n"
"  char *key_end = key_buf;\n"
"  key_end = mp_encode_array(key_end, 1);\n"
"  key_end = mp_encode_uint(key_end, key);\n"
"  assert(key_end < key_buf + sizeof(key_buf));\n"
"  /* Get the tuple. There's no box_select() but there's this. */\n"
"  int r = box_index_get(space_id, index_id, key_buf, key_end, &tuple);\n"
"  assert(r == 0);\n"
"  assert(tuple != NULL);\n"
"  /* Get each field of the tuple + display what you get. */\n"
"  int field_no;             /* The first field number is 0. */\n"
"  for (field_no = 0; field_no < 2; ++field_no)\n"
"  {\n"
"    const char *field = box_tuple_field(tuple, field_no);\n"
"    assert(field != NULL);\n"
"    assert(mp_typeof(*field) == MP_STR || mp_typeof(*field) == MP_UINT);\n"
"    if (mp_typeof(*field) == MP_UINT)\n"
"    {\n"
"      uint32_t uint_value = mp_decode_uint(&field);\n"
"      printf(\"uint value=%u.\\n\", uint_value);\n"
"    }\n"
"    else /* if (mp_typeof(*field) == MP_STR) */\n"
"    {\n"
"      const char *str_value;\n"
"      uint32_t str_value_length;\n"
"      str_value = mp_decode_str(&field, &str_value_length);\n"
"      printf(\"string value=%.*s.\\n\", str_value_length, str_value);\n"
"    }\n"
"  }\n"
"  return 0;\n"
"}"
msgstr ""
"#include \"module.h\"\n"
"#include <msgpuck.h>\n"
"int read(box_function_ctx_t *ctx, const char *args, const char *args_end)"
"\n"
"{\n"
"  char tuple_buf[1024];      /* здесь будет храниться тапл в сыром "
"MsgPack-формате */\n"
"  uint32_t space_id = box_space_id_by_name(\"capi_test\", "
"strlen(\"capi_test\"));\n"
"  uint32_t index_id = 0;     /* номер первого индекса спейса */\n"
"  uint32_t key = 10000;      /* значение ключа, используемое box_insert()"
" */\n"
"  mp_encode_array(tuple_buf, 0); /* clear */\n"
"  box_tuple_format_t *fmt = box_tuple_format_default();\n"
"  box_tuple_t *tuple = box_tuple_new(fmt, tuple_buf, tuple_buf+512);\n"
"  assert(tuple != NULL);\n"
"  char key_buf[16];          /* передаем key_buf = закодированный ключ = "
"1000 */\n"
"  char *key_end = key_buf;\n"
"  key_end = mp_encode_array(key_end, 1);\n"
"  key_end = mp_encode_uint(key_end, key);\n"
"  assert(key_end < key_buf + sizeof(key_buf));\n"
"  /* Получить тапл. У нас нет box_select(), но есть вот это. */\n"
"  int r = box_index_get(space_id, index_id, key_buf, key_end, &tuple);\n"
"  assert(r == 0);\n"
"  assert(tuple != NULL);\n"
"  /* Получить каждое поле тапла + показать полученное значение */\n"
"  int field_no;             /* номер первого поля = 0 */\n"
"  for (field_no = 0; field_no < 2; ++field_no)\n"
"  {\n"
"    const char *field = box_tuple_field(tuple, field_no);\n"
"    assert(field != NULL);\n"
"    assert(mp_typeof(*field) == MP_STR || mp_typeof(*field) == MP_UINT);\n"
"    if (mp_typeof(*field) == MP_UINT)\n"
"    {\n"
"      uint32_t uint_value = mp_decode_uint(&field);\n"
"      printf(\"uint value=%u.\\n\", uint_value);\n"
"    }\n"
"    else /* если (mp_typeof(*field) == MP_STR) */\n"
"    {\n"
"      const char *str_value;\n"
"      uint32_t str_value_length;\n"
"      str_value = mp_decode_str(&field, &str_value_length);\n"
"      printf(\"string value=%.*s.\\n\", str_value_length, str_value);\n"
"    }\n"
"  }\n"
"  return 0;\n"
"}"

#: ../doc/1.10/tutorials/c_tutorial.rst:435
msgid "Compile the program, producing a library file named ``read.so``:"
msgstr ""
"Скомпилируйте программу, что создаст файл библиотеки под названием "
"``read.so``:"

#: ../doc/1.10/tutorials/c_tutorial.rst:437
msgid "$ gcc -shared -o read.so -fPIC read.c"
msgstr "$ gcc -shared -o read.so -fPIC read.c"

#: ../doc/1.10/tutorials/c_tutorial.rst:443
msgid ""
"box.schema.func.create('read', {language = \"C\"})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'read')\n"
"box.schema.user.grant('guest', 'read,write', 'space', 'capi_test')\n"
"capi_connection:call('read')"
msgstr ""
"box.schema.func.create('read', {language = \"C\"})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'read')\n"
"box.schema.user.grant('guest', 'read,write', 'space', 'capi_test')\n"
"capi_connection:call('read')"

#: ../doc/1.10/tutorials/c_tutorial.rst:450
msgid "This time the C function is doing four things:"
msgstr "На этот раз C-функция выполняет четыре действия:"

#: ../doc/1.10/tutorials/c_tutorial.rst:452
#: ../doc/1.10/tutorials/c_tutorial.rst:533
msgid ""
"once again, finding the numeric identifier of the ``capi_test`` space by "
"calling ``box_space_id_by_name()``;"
msgstr ""
"снова найдет числовой идентификатор спейса ``capi_test`` путем вызова "
"``box_space_id_by_name()``;"

#: ../doc/1.10/tutorials/c_tutorial.rst:454
msgid "formatting a search key = 10000 using more ``msgpuck.h`` functions;"
msgstr "форматирует ключ поиска = 10 000, используя другие функции ``msgpuck.h``;"

#: ../doc/1.10/tutorials/c_tutorial.rst:455
msgid "getting a tuple using ``box_index_get()``;"
msgstr "получает кортеж с помощью ``box_index_get()``;"

#: ../doc/1.10/tutorials/c_tutorial.rst:456
msgid ""
"going through the tuple's fields with ``box_tuple_get()`` and then "
"decoding each field depending on its type. In this case, since what we "
"are getting is the tuple that we inserted with ``hardest.c``, we know in "
"advance that the type is either MP_UINT or MP_STR; however, it's very "
"common to have a case statement here with one option for each possible "
"type."
msgstr ""
"проходит по полям каждого кортежа с помощью ``box_tuple_get()``. а затем "
"декодирует каждое поле в зависимости от его типа. В данном случае, "
"поскольку мы получаем кортеж, который сами вставили с помощью "
"``hardest.c``, мы знаем заранее, что его тип будет MP_UINT или MP_STR. "
"Однако, весьма часто здесь употребляется оператор выбора case с одной "
"опцией для каждого возможного типа."

#: ../doc/1.10/tutorials/c_tutorial.rst:463
msgid "The result of ``capi_connection:call('read')`` should look like this:"
msgstr "В результате вызова ``capi_connection:call('read')`` должны получить:"

#: ../doc/1.10/tutorials/c_tutorial.rst:465
msgid ""
"tarantool> capi_connection:call('read')\n"
"uint value=10000.\n"
"string value=String 2.\n"
"---\n"
"- []\n"
"..."
msgstr ""
"tarantool> capi_connection:call('read')\n"
"uint value=10000.\n"
"string value=String 2.\n"
"---\n"
"- []\n"
"..."

#: ../doc/1.10/tutorials/c_tutorial.rst:474
msgid ""
"This proves that the ``read()`` function succeeded. Once again the "
"important functions that start with `box` -- :ref:`box_index_get() "
"<c_api-box_index-box_index_get>` and :ref:`box_tuple_field() <c_api-"
"tuple-box_tuple_field>` -- came from the :ref:`C API <index-"
"c_api_reference>`."
msgstr ""
"Это доказывает, что функция ``read()`` была успешно выполнена. И снова "
"важные функции, которые начинаются с `box` -- :ref:`box_index_get() "
"<c_api-box_index-box_index_get>` и :ref:`box_tuple_field() <c_api-tuple-"
"box_tuple_field>` -- пришли из :ref:`API для языка C <index-"
"c_api_reference>`."

#: ../doc/1.10/tutorials/c_tutorial.rst:482
msgid "**write.c**"
msgstr "**write.c**"

#: ../doc/1.10/tutorials/c_tutorial.rst:484
msgid ""
"Go back to the shell where the programs ``easy.c``, ``harder.c``, "
"``hardest.c`` and ``read.c`` were created."
msgstr ""
"Вернитесь в терминал, где были созданы программы ``easy.c``, "
"``harder.c``, ``hardest.c`` и ``read.c``."

#: ../doc/1.10/tutorials/c_tutorial.rst:487
msgid "Create a file. Name it ``write.c``. Put these 24 lines in it:"
msgstr ""
"Создайте файл. Назовите его ``write.c``. Запишите в него следующие 24 "
"строки:"

#: ../doc/1.10/tutorials/c_tutorial.rst:489
#, python-format
msgid ""
"#include \"module.h\"\n"
"#include <msgpuck.h>\n"
"int write(box_function_ctx_t *ctx, const char *args, const char "
"*args_end)\n"
"{\n"
"  static const char *space = \"capi_test\";\n"
"  char tuple_buf[1024]; /* Must be big enough for mp_encode results */\n"
"  uint32_t space_id = box_space_id_by_name(space, strlen(space));\n"
"  if (space_id == BOX_ID_NIL) {\n"
"    return box_error_set(__FILE__, __LINE__, ER_PROC_C,\n"
"    \"Can't find space %s\", \"capi_test\");\n"
"  }\n"
"  char *tuple_end = tuple_buf;\n"
"  tuple_end = mp_encode_array(tuple_end, 2);\n"
"  tuple_end = mp_encode_uint(tuple_end, 1);\n"
"  tuple_end = mp_encode_uint(tuple_end, 22);\n"
"  box_txn_begin();\n"
"  if (box_replace(space_id, tuple_buf, tuple_end, NULL) != 0)\n"
"    return -1;\n"
"  box_txn_commit();\n"
"  fiber_sleep(0.001);\n"
"  struct tuple *tuple = box_tuple_new(box_tuple_format_default(),\n"
"                                      tuple_buf, tuple_end);\n"
"  return box_return_tuple(ctx, tuple);\n"
"}"
msgstr ""
"#include \"module.h\"\n"
"#include <msgpuck.h>\n"
"int write(box_function_ctx_t *ctx, const char *args, const char "
"*args_end)\n"
"{\n"
"  static const char *space = \"capi_test\";\n"
"  char tuple_buf[1024]; /* Должен быть достаточно большим, чтобы вместить"
" результат mp_encode */\n"
"  uint32_t space_id = box_space_id_by_name(space, strlen(space));\n"
"  if (space_id == BOX_ID_NIL) {\n"
"    return box_error_set(__FILE__, __LINE__, ER_PROC_C,\n"
"    \"Can't find space %s\", \"capi_test\");\n"
"  }\n"
"  char *tuple_end = tuple_buf;\n"
"  tuple_end = mp_encode_array(tuple_end, 2);\n"
"  tuple_end = mp_encode_uint(tuple_end, 1);\n"
"  tuple_end = mp_encode_uint(tuple_end, 22);\n"
"  box_txn_begin();\n"
"  if (box_replace(space_id, tuple_buf, tuple_end, NULL) != 0)\n"
"    return -1;\n"
"  box_txn_commit();\n"
"  fiber_sleep(0.001);\n"
"  struct tuple *tuple = box_tuple_new(box_tuple_format_default(),\n"
"                                      tuple_buf, tuple_end);\n"
"  return box_return_tuple(ctx, tuple);\n"
"}"

#: ../doc/1.10/tutorials/c_tutorial.rst:516
msgid "Compile the program, producing a library file named ``write.so``:"
msgstr ""
"Скомпилируйте программу, что создаст файл библиотеки под названием "
"``write.so``:"

#: ../doc/1.10/tutorials/c_tutorial.rst:518
msgid "$ gcc -shared -o write.so -fPIC write.c"
msgstr "$ gcc -shared -o write.so -fPIC write.c"

#: ../doc/1.10/tutorials/c_tutorial.rst:524
msgid ""
"box.schema.func.create('write', {language = \"C\"})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'write')\n"
"box.schema.user.grant('guest', 'read,write', 'space', 'capi_test')\n"
"capi_connection:call('write')"
msgstr ""
"box.schema.func.create('write', {language = \"C\"})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'write')\n"
"box.schema.user.grant('guest', 'read,write', 'space', 'capi_test')\n"
"capi_connection:call('write')"

#: ../doc/1.10/tutorials/c_tutorial.rst:531
msgid "This time the C function is doing six things:"
msgstr "На этот раз C-функция выполняет шесть действий:"

#: ../doc/1.10/tutorials/c_tutorial.rst:535
msgid "making a new tuple;"
msgstr "создает новый кортеж;"

#: ../doc/1.10/tutorials/c_tutorial.rst:536
msgid "starting a transaction;"
msgstr "начинает транзакцию;"

#: ../doc/1.10/tutorials/c_tutorial.rst:537
msgid "replacing a tuple in ``box.space.capi_test``"
msgstr "заменяет кортеж в ``box.space.capi_test``"

#: ../doc/1.10/tutorials/c_tutorial.rst:538
msgid "ending a transaction;"
msgstr "заканчивает транзакцию;"

#: ../doc/1.10/tutorials/c_tutorial.rst:539
msgid ""
"the final line is a replacement for the loop in ``read.c`` -- instead of "
"getting each field and printing it, use the ``box_return_tuple(...)`` "
"function to return the entire tuple to the caller and let the caller "
"display it."
msgstr ""
"последняя строка заменяет цикл ``read.c`` -- вместо получения и вывода "
"каждого поля, использует функцию ``box_return_tuple(...)`` для возврата "
"всего кортежа вызывающему клиенту, чтобы вывести его на экран."

#: ../doc/1.10/tutorials/c_tutorial.rst:544
msgid "The result of ``capi_connection:call('write')`` should look like this:"
msgstr "В результате вызова ``capi_connection:call('write')`` должны получить:"

#: ../doc/1.10/tutorials/c_tutorial.rst:546
msgid ""
"tarantool> capi_connection:call('write')\n"
"---\n"
"- [[1, 22]]\n"
"..."
msgstr ""
"tarantool> capi_connection:call('write')\n"
"---\n"
"- [[1, 22]]\n"
"..."

#: ../doc/1.10/tutorials/c_tutorial.rst:553
msgid ""
"This proves that the ``write()`` function succeeded. Once again the "
"important functions that start with `box` -- :ref:`box_txn_begin() <txn-"
"box_txn_begin>`, :ref:`box_txn_commit() <txn-box_txn_commit>` and "
":ref:`box_return_tuple() <box-box_return_tuple>` -- came from the :ref:`C"
" API <index-c_api_reference>`."
msgstr ""
"Это доказывает, что функция ``write()`` была успешно выполнена. И снова "
"важные функции, которые начинаются с `box` -- :ref:`box_txn_begin() <txn-"
"box_txn_begin>`, :ref:`box_txn_commit() <txn-box_txn_commit>` и "
":ref:`box_return_tuple() <box-box_return_tuple>` -- пришли из :ref:`API "
"для языка C <index-c_api_reference>`."

#: ../doc/1.10/tutorials/c_tutorial.rst:560
msgid ""
"Conclusion: the long description of the whole C API is there for a good "
"reason. All of the functions in it can be called from C functions which "
"are called from Lua. So C \"stored procedures\" have full access to the "
"database."
msgstr ""
"Вывод: длинное описание всего API для языка C необходимо в силу весомых "
"причин. Все функции можно вызвать из C-функций, которые вызываются из "
"Lua. Таким образом, хранимые процедуры на языке C получают полный доступ "
"к базе данных."

#: ../doc/1.10/tutorials/c_tutorial.rst:566
msgid "**Cleaning up**"
msgstr "**Очистка данных**"

#: ../doc/1.10/tutorials/c_tutorial.rst:568
msgid ""
"Get rid of each of the function tuples with :ref:`box.schema.func.drop "
"<box_schema-func_drop>`."
msgstr ""
"Удалите все кортежи с функцией с помощью :ref:`box.schema.func.drop "
"<box_schema-func_drop>`."

#: ../doc/1.10/tutorials/c_tutorial.rst:570
msgid ""
"Get rid of the ``capi_test`` space with :ref:`box.schema.capi_test:drop()"
" <box_space-drop>`."
msgstr ""
"Удалите спейс ``capi_test`` с помощью :ref:`box.schema.capi_test:drop() "
"<box_space-drop>`."

#: ../doc/1.10/tutorials/c_tutorial.rst:572
msgid "Remove the ``.c`` and ``.so`` files that were created for this tutorial."
msgstr ""
"Удалите файлы с разрешением ``.c`` и ``.so``, созданные для данного "
"практического задания."

#: ../doc/1.10/tutorials/c_tutorial.rst:575
msgid "**An example in the test suite**"
msgstr "**Пример из набора тестов**"

#: ../doc/1.10/tutorials/c_tutorial.rst:577
msgid ""
"Download the source code of Tarantool. Look in a subdirectory "
":code:`test/box`. Notice that there is a file named "
":code:`tuple_bench.test.lua` and another file named "
":code:`tuple_bench.c`. Examine the Lua file and observe that it is "
"calling a function in the C file, using the same techniques that this "
"tutorial has shown."
msgstr ""
"Скачайте исходный код Tarantool'а. Откройте поддиректорию "
":code:`test/box`. Проверьте наличие файла под названием "
":code:`tuple_bench.test.lua` и еще одного файла под названием "
":code:`tuple_bench.c`. Изучите Lua-файл на предмет вызова функции в "
"C-файле с использованием методов, описанных в данном практическом "
"задании."

#: ../doc/1.10/tutorials/c_tutorial.rst:584
msgid ""
"Conclusion: parts of the standard test suite use C stored procedures, and"
" they must work, because releases don't happen if Tarantool doesn't pass "
"the tests."
msgstr ""
"Вывод: некоторые тесты из стандартного набора используют хранимые "
"процедуры на языке C, а они должны работать, поскольку мы не можем "
"выпустить Tarantool, если он не прошел тестирование."

#: ../doc/1.10/tutorials/index.rst:39
msgid "Tutorials"
msgstr "Практикум"

#: ../doc/1.10/tutorials/libslave.rst:39
msgid "`libslave` tutorial"
msgstr "Практические задания по `libslave`"

#: ../doc/1.10/tutorials/libslave.rst:41
msgid ""
"``libslave`` is a C++ library for reading data changes done by MysQL and,"
" optionally, writing them to a Tarantool database. It works by acting as "
"a replication slave. The MySQL server writes data-change information to a"
" \"binary log\", and transfers the information to any client that says "
"\"I want to see the information starting with this file and this record, "
"continuously\". So, ``libslave`` is primarily good for making a Tarantool"
" database replica (much faster than using a conventional MySQL slave "
"server), and for keeping track of data changes so they can be searched."
msgstr ""
"``libslave`` представляет собой библиотеку C++ для считывания изменений "
"данных, внесенных с помощью MySQL, а также -- опционально -- для записи "
"их в базу данных Tarantool'а. Она выступает в качестве ведомого в схеме "
"репликации. Сервер MySQL записывает информацию об изменении данных в "
"бинарный журнал и передает ее на любой клиент, который запрашивает: "
"\"Хочу увидеть всю информацию, начиная с этого файла и этой записи, "
"безостановочно\". Таким образом, библиотека ``libslave``, прежде всего, "
"используется для создания реплик базы данных Tarantool'а (намного "
"быстрее, чем используя традиционный ведомый сервер MySQL) и для "
"отслеживания изменений данных, чтобы они были пригодны для поиска."

#: ../doc/1.10/tutorials/libslave.rst:52
msgid ""
"We will not go into the many details here -- the `API documentation "
"<https://github.com/vozbu/libslave/wiki/API>`_ has them. We will only "
"show an exercise: a minimal program that uses the library."
msgstr ""
"Здесь мы не будем подробно рассматривать библиотеку -- информация есть в "
"`документации по API <https://github.com/vozbu/libslave/wiki/API>`_. Мы "
"лишь дадим упражнение: минимальная программа с использованием библиотеки."

#: ../doc/1.10/tutorials/libslave.rst:58
msgid "Use a test machine. Do not use a production machine."
msgstr "Используйте тестовый сервер. Не используйте боевой сервер."

#: ../doc/1.10/tutorials/libslave.rst:60
msgid "STEP 1: Make sure you have:"
msgstr "ШАГ 1: Убедитесь в наличии следующего:"

#: ../doc/1.10/tutorials/libslave.rst:62
msgid "a recent version of Linux (versions such as Ubuntu 14.04 will not do),"
msgstr "последняя версия Linux (например, Ubuntu версии 14.04 не подойдет),"

#: ../doc/1.10/tutorials/libslave.rst:63
msgid "a recent version of MySQL 5.6 or MySQL 5.7 server (MariaDB will not do),"
msgstr "сервер MySQL версии 5.6 или 5.7 (MariaDB не подойдет),"

#: ../doc/1.10/tutorials/libslave.rst:64
msgid ""
"MySQL client development package. For example, on Ubuntu you can download"
" it with this command:"
msgstr ""
"пакет программ для разработки клиента MySQL. Например, на Ubuntu можно "
"загрузить его с помощью следующей команды:"

#: ../doc/1.10/tutorials/libslave.rst:67
msgid "$ sudo apt-get install mysql-client-core-5.7"
msgstr "$ sudo apt-get install mysql-client-core-5.7"

#: ../doc/1.10/tutorials/libslave.rst:71
msgid "STEP 2: Download ``libslave``."
msgstr "ШАГ 2: Установите ``libslave``."

#: ../doc/1.10/tutorials/libslave.rst:73
msgid ""
"The recommended source is https://github.com/tarantool/libslave/. "
"Downloads include the source code only."
msgstr ""
"Рекомендуется источник по ссылке https://github.com/tarantool/libslave/. "
"Загрузки включают в себя только исходный код."

#: ../doc/1.10/tutorials/libslave.rst:76
msgid ""
"$ sudo apt-get install libboost-all-dev\n"
"$ cd ~\n"
"$ git clone https://github.com/tarantool/libslave.git tarantool-libslave\n"
"$ cd tarantool-libslave\n"
"$ git submodule init\n"
"$ git submodule update\n"
"$ cmake .\n"
"$ make"
msgstr ""
"$ sudo apt-get install libboost-all-dev\n"
"$ cd ~\n"
"$ git clone https://github.com/tarantool/libslave.git tarantool-libslave\n"
"$ cd tarantool-libslave\n"
"$ git submodule init\n"
"$ git submodule update\n"
"$ cmake .\n"
"$ make"

#: ../doc/1.10/tutorials/libslave.rst:87
msgid ""
"If you see an error message mentioning the word \"vector\", edit "
"``field.h`` and add this line:"
msgstr ""
"Если система выдаст сообщение с ошибкой со словом \"vector\", "
"отредактируйте ``field.h``, добавив следующую строку:"

#: ../doc/1.10/tutorials/libslave.rst:90
msgid "#include <vector>"
msgstr "#include <vector>"

#: ../doc/1.10/tutorials/libslave.rst:94
msgid ""
"STEP 3: Start the MySQL server. On the command line, add appropriate "
"switches for doing replication. For example:"
msgstr ""
"ШАГ 3: Запустите сервер MySQL. В командной строке добавьте "
"соответствующие коммутаторы для выполнения репликации. Например:"

#: ../doc/1.10/tutorials/libslave.rst:97
msgid "$ mysqld --log-bin=mysql-bin --server-id=1"
msgstr "$ mysqld --log-bin=mysql-bin --server-id=1"

#: ../doc/1.10/tutorials/libslave.rst:101
msgid "STEP 4: For purposes of this exercise, we are assuming you have:"
msgstr "ШАГ 4: Для целей данного упражнения, предполагаем, что у вас есть:"

#: ../doc/1.10/tutorials/libslave.rst:103
msgid "a \"root\" user with password \"root\" with privileges,"
msgstr "пользователь \"root\" с паролем \"root\" с правами,"

#: ../doc/1.10/tutorials/libslave.rst:104
msgid "a \"test\" database with a table named \"test\","
msgstr "тестовая база данных \"test\" с тестовой таблицей под названием \"test\","

#: ../doc/1.10/tutorials/libslave.rst:105
msgid "a binary log named \"mysql-bin\","
msgstr "бинарный журнал под названием \"mysql-bin\","

#: ../doc/1.10/tutorials/libslave.rst:106
msgid "a server with server id = 1."
msgstr "сервер с идентификатором 1."

#: ../doc/1.10/tutorials/libslave.rst:108
msgid ""
"The values are hard-coded in the program, though of course you can change"
" the program -- it's easy to see their settings."
msgstr ""
"Значения заданы в программе, хотя программу, конечно, можно изменить -- "
"посмотреть настройки несложно."

#: ../doc/1.10/tutorials/libslave.rst:111
msgid "STEP 5: Look at the program:"
msgstr "ШАГ 5: Обратите внимание на программу:"

#: ../doc/1.10/tutorials/libslave.rst:113
msgid ""
"#include <unistd.h>\n"
"#include <iostream>\n"
"#include <sstream>\n"
"#include \"Slave.h\"\n"
"#include \"DefaultExtState.h\"\n"
"\n"
"slave::Slave* sl = NULL;\n"
"\n"
"void callback(const slave::RecordSet& event) {\n"
"    slave::Slave::binlog_pos_t sBinlogPos = sl->getLastBinlog();\n"
"    switch (event.type_event) {\n"
"    case slave::RecordSet::Update: std::cout << \"UPDATE\" << \"\\n\"; "
"break;\n"
"    case slave::RecordSet::Delete: std::cout << \"DELETE\" << \"\\n\"; "
"break;\n"
"    case slave::RecordSet::Write:  std::cout << \"INSERT\" << \"\\n\"; "
"break;\n"
"    default: break;\n"
"    }\n"
"}\n"
"\n"
"bool isStopping()\n"
"{\n"
"    return 0;\n"
"}\n"
"\n"
"int main(int argc, char** argv)\n"
"{\n"
"    slave::MasterInfo masterinfo;\n"
"    masterinfo.conn_options.mysql_host = \"127.0.0.1\";\n"
"    masterinfo.conn_options.mysql_port = 3306;\n"
"    masterinfo.conn_options.mysql_user = \"root\";\n"
"    masterinfo.conn_options.mysql_pass = \"root\";\n"
"    bool error = false;\n"
"    try {\n"
"        slave::DefaultExtState sDefExtState;\n"
"        slave::Slave slave(masterinfo, sDefExtState);\n"
"        sl = &slave;\n"
"        sDefExtState.setMasterLogNamePos(\"mysql-bin\", 0);\n"
"        slave.setCallback(\"test\", \"test\", callback);\n"
"        slave.init();\n"
"        slave.createDatabaseStructure();\n"
"        try {\n"
"            slave.get_remote_binlog(isStopping);\n"
"        } catch (std::exception& ex) {\n"
"            std::cout << \"Error reading: \" << ex.what() << std::endl;\n"
"            error = true;\n"
"        }\n"
"    } catch (std::exception& ex) {\n"
"        std::cout << \"Error initializing: \" << ex.what() << std::endl;\n"
"        error = true;\n"
"    }\n"
"    return 0;\n"
"}"
msgstr ""
"#include <unistd.h>\n"
"#include <iostream>\n"
"#include <sstream>\n"
"#include \"Slave.h\"\n"
"#include \"DefaultExtState.h\"\n"
"\n"
"slave::Slave* sl = NULL;\n"
"\n"
"void callback(const slave::RecordSet& event) {\n"
"    slave::Slave::binlog_pos_t sBinlogPos = sl->getLastBinlog();\n"
"    switch (event.type_event) {\n"
"    case slave::RecordSet::Update: std::cout << \"UPDATE\" << \"\\n\"; "
"break;\n"
"    case slave::RecordSet::Delete: std::cout << \"DELETE\" << \"\\n\"; "
"break;\n"
"    case slave::RecordSet::Write:  std::cout << \"INSERT\" << \"\\n\"; "
"break;\n"
"    default: break;\n"
"    }\n"
"}\n"
"\n"
"bool isStopping()\n"
"{\n"
"    return 0;\n"
"}\n"
"\n"
"int main(int argc, char** argv)\n"
"{\n"
"    slave::MasterInfo masterinfo;\n"
"    masterinfo.conn_options.mysql_host = \"127.0.0.1\";\n"
"    masterinfo.conn_options.mysql_port = 3306;\n"
"    masterinfo.conn_options.mysql_user = \"root\";\n"
"    masterinfo.conn_options.mysql_pass = \"root\";\n"
"    bool error = false;\n"
"    try {\n"
"        slave::DefaultExtState sDefExtState;\n"
"        slave::Slave slave(masterinfo, sDefExtState);\n"
"        sl = &slave;\n"
"        sDefExtState.setMasterLogNamePos(\"mysql-bin\", 0);\n"
"        slave.setCallback(\"test\", \"test\", callback);\n"
"        slave.init();\n"
"        slave.createDatabaseStructure();\n"
"        try {\n"
"            slave.get_remote_binlog(isStopping);\n"
"        } catch (std::exception& ex) {\n"
"            std::cout << \"Error reading: \" << ex.what() << std::endl;\n"
"            error = true;\n"
"        }\n"
"    } catch (std::exception& ex) {\n"
"        std::cout << \"Error initializing: \" << ex.what() << std::endl;\n"
"        error = true;\n"
"    }\n"
"    return 0;\n"
"}"

#: ../doc/1.10/tutorials/libslave.rst:167
msgid ""
"Everything unnecessary has been stripped so that you can see quickly how "
"it works. At the start of ``main()``, there are some settings used for "
"connecting -- host, port, user, password. Then there is an initialization"
" call with the binary log file name = \"mysql-bin\". Pay particular "
"attention to the ``setCallback`` statement, which passes database name = "
"\"test\", table name = \"test\", and callback function address = "
"callback. The program will be looping and invoking this callback "
"function. See how, earlier in the program, the callback function prints "
"\"UPDATE\" or \"DELETE\" or \"INSERT\" depending on what is passed to it."
msgstr ""
"Всё лишнее почистили, чтобы можно было ясно увидеть, как это работает. В "
"начале функции ``main()`` есть некоторые настройки, используемые для "
"установки соединения -- хост, порт, пользователь, пароль. Затем есть "
"вызов инициализации с именем файла бинарного журнала = \"mysql-bin\". "
"Обратите особое внимание на оператор ``setCallback``, который передает "
"имя базы данных = \"test\", имя таблицы = \"test\" и адрес функции "
"обратного вызова = callback. Программа войдет в цикл и будет вызывать эту"
" функцию обратного вызова. Посмотрите, как на ранних этапах программы "
"функция обратного вызова выводит \"UPDATE\", \"DELETE\" или \"INSERT\" в "
"зависимости от переданных данных."

#: ../doc/1.10/tutorials/libslave.rst:178
msgid ""
"STEP 5: Put the program in the ``tarantool-libslave`` directory and name "
"it ``example.cpp``."
msgstr ""
"ШАГ 5: Поместите программу в директорию ``tarantool-libslave`` и назовите"
" ее ``example.cpp``."

#: ../doc/1.10/tutorials/libslave.rst:181
msgid "Step 6: Compile and build:"
msgstr "ШАГ 6: Выполните компиляцию и сборку:"

#: ../doc/1.10/tutorials/libslave.rst:183
msgid ""
"$ g++ -I/tarantool-libslave/include example.cpp -o example libslave_a.a "
"-ldl -lpthread"
msgstr ""
"$ g++ -I/tarantool-libslave/include example.cpp -o example libslave_a.a "
"-ldl -lpthread"

#: ../doc/1.10/tutorials/libslave.rst:189
msgid "Replace ``tarantool-libslave/include`` with the full directory name."
msgstr "Замените ``tarantool-libslave/include`` на полное имя директории."

#: ../doc/1.10/tutorials/libslave.rst:191
msgid ""
"Notice that the name of the static library is ``libslave_a.a``, not "
"``libslave.a``."
msgstr ""
"Обратите внимание, что имя статической библиотеки -- ``libslave_a.a``, а "
"не ``libslave.a``."

#: ../doc/1.10/tutorials/libslave.rst:194
msgid "Step 7: Run:"
msgstr "ШАГ 7: Выполните:"

#: ../doc/1.10/tutorials/libslave.rst:196
msgid "$ ./example"
msgstr "$ ./example"

#: ../doc/1.10/tutorials/libslave.rst:200
msgid ""
"The result will be nothing -- the program is looping, waiting for the "
"MySQL server to write to the replication binary log."
msgstr ""
"Результат нет -- программа в цикле ожидает, пока сервер MySQL запишет "
"данные в бинарный журнал репликации."

#: ../doc/1.10/tutorials/libslave.rst:203
msgid ""
"Step 8: Start a MySQL client program -- any client program will do. Enter"
" these statements:"
msgstr ""
"ШАГ 8: Запустите клиентскую программу MySQL -- подойдет любая клиентская "
"программа. Введите следующие операторы:"

#: ../doc/1.10/tutorials/libslave.rst:206
msgid ""
"USE test\n"
"INSERT INTO test VALUES ('A');\n"
"INSERT INTO test VALUES ('B');\n"
"DELETE FROM test;"
msgstr ""
"USE test\n"
"INSERT INTO test VALUES ('A');\n"
"INSERT INTO test VALUES ('B');\n"
"DELETE FROM test;"

#: ../doc/1.10/tutorials/libslave.rst:213
msgid "Watch what happens in ``example.cpp`` output -- it displays:"
msgstr ""
"Проверьте, что происходит в выводе программы ``example.cpp`` -- "
"отображается следующее:"

#: ../doc/1.10/tutorials/libslave.rst:215
msgid ""
"INSERT\n"
"INSERT\n"
"DELETE\n"
"DELETE"
msgstr ""
"INSERT\n"
"INSERT\n"
"DELETE\n"
"DELETE"

#: ../doc/1.10/tutorials/libslave.rst:222
msgid ""
"This is row-based replication, so you see two DELETEs, because there are "
"two rows."
msgstr ""
"Репликация является построчной, поэтому видим DELETE два раза -- потому "
"что есть две строки."

#: ../doc/1.10/tutorials/libslave.rst:225
msgid "What the exercise has shown is:"
msgstr "В результате выполнения упражнения видим:"

#: ../doc/1.10/tutorials/libslave.rst:227
msgid "the library can be built, and"
msgstr "можно собрать библиотеку, а "

#: ../doc/1.10/tutorials/libslave.rst:228
msgid ""
"programs that use the library can access everything that the MySQL server"
" dumps."
msgstr ""
"программы, которые используют библиотеку, могут получить доступ ко всему,"
" что сохраняет сервер MySQL."

#: ../doc/1.10/tutorials/libslave.rst:231
msgid "For the many details and examples of usage in the field, see:"
msgstr "Более подробную информацию и примеры использования см. ниже:"

#: ../doc/1.10/tutorials/libslave.rst
msgid "Our downloadable ``libslave`` version:"
msgstr "Загрузить нашу версию ``libslave`` можно по ссылке:"

#: ../doc/1.10/tutorials/libslave.rst
msgid "https://github.com/tarantool/libslave"
msgstr "https://github.com/tarantool/libslave"

#: ../doc/1.10/tutorials/libslave.rst
msgid "The version it was forked from (with a different README):"
msgstr "Ответвление сделано из версии по ссылке (с другим файлом README):"

#: ../doc/1.10/tutorials/libslave.rst
msgid "https://github.com/vozbu/libslave/wiki/API"
msgstr "https://github.com/vozbu/libslave/wiki/API"

#: ../doc/1.10/tutorials/libslave.rst:239
msgid ""
"`How to speed up your MySQL with replication to in-memory database "
"<http://highscalability.com/blog/2017/3/29/how-to-speed-up-your-mysql-"
"with-replication-to-in-memory-dat.html>`_ article"
msgstr ""
"Статья `How to speed up your MySQL with replication to in-memory database"
" <http://highscalability.com/blog/2017/3/29/how-to-speed-up-your-mysql-"
"with-replication-to-in-memory-dat.html>`_ (на английском)"

#: ../doc/1.10/tutorials/libslave.rst:241
msgid ""
"`Replicating data from MySQL to Tarantool "
"<https://habrahabr.ru/company/mailru/blog/323870/>`_ article (in Russian)"
msgstr ""
"Статья `Репликация из MySQL в Tarantool "
"<https://habrahabr.ru/company/mailru/blog/323870/>`_"

#: ../doc/1.10/tutorials/libslave.rst:243
msgid ""
"`Asynchronous replication uncensored <https://habrahabr.ru/company/oleg-"
"bunin/blog/313594/>`_ article (in Russian)"
msgstr ""
"Статья `Асинхронная репликация без цензуры <https://habrahabr.ru/company"
"/oleg-bunin/blog/313594/>`_"

#: ../doc/1.10/tutorials/lua_tutorials.rst:39
msgid "Lua tutorials"
msgstr "Практические задания на Lua"

#: ../doc/1.10/tutorials/lua_tutorials.rst:41
msgid "Here are three tutorials on using Lua stored procedures with Tarantool:"
msgstr ""
"Практические задания по использованию хранимых процедур на языке Lua в "
"работе с Tarantool'ом:"

#: ../doc/1.10/tutorials/lua_tutorials.rst:43
msgid ""
":ref:`Insert one million tuples with a Lua stored procedure "
"<c_lua_tutorial-insert_one_million_tuples>`,"
msgstr ""
":ref:`Вставка 1 млн кортежей с помощью хранимой процедуры на языке Lua "
"<c_lua_tutorial-insert_one_million_tuples>`,"

#: ../doc/1.10/tutorials/lua_tutorials.rst:44
msgid ":ref:`Sum a JSON field for all tuples <c_lua_tutorial-sum_a_json_field>`,"
msgstr ""
":ref:`Подсчет суммы по JSON-полям во всех кортежах <c_lua_tutorial-"
"sum_a_json_field>`,"

#: ../doc/1.10/tutorials/lua_tutorials.rst:45
msgid ":ref:`Indexed pattern search <c_lua_tutorial-indexed_pattern_search>`."
msgstr ""
":ref:`Индексированный поиск по шаблонам <c_lua_tutorial-"
"indexed_pattern_search>`."

#: ../doc/1.10/tutorials/lua_tutorials.rst:51
msgid "Insert one million tuples with a Lua stored procedure"
msgstr "Вставка 1 млн кортежей с помощью хранимой процедуры на языке Lua"

#: ../doc/1.10/tutorials/lua_tutorials.rst:53
msgid ""
"This is an exercise assignment: “Insert one million tuples. Each tuple "
"should have a constantly-increasing numeric primary-key field and a "
"random alphabetic 10-character string field.”"
msgstr ""
"Задание по данному практикуму: “Вставьте 1 миллион кортежей. В каждом "
"кортеже должно быть поле, которое соответствует ключу в первичном "
"индексе, в виде постоянно возрастающего числа, а также поле в виде "
"буквенной строки со случайным значением из 10 символов.”"

#: ../doc/1.10/tutorials/lua_tutorials.rst:57
msgid ""
"The purpose of the exercise is to show what Lua functions look like "
"inside Tarantool. It will be necessary to employ the Lua math library, "
"the Lua string library, the Tarantool box library, the Tarantool "
"box.tuple library, loops, and concatenations. It should be easy to follow"
" even for a person who has not used either Lua or Tarantool before. The "
"only requirement is a knowledge of how other programming languages work "
"and a memory of the first two chapters of this manual. But for better "
"understanding, follow the comments and the links, which point to the Lua "
"manual or to elsewhere in this Tarantool manual. To further enhance "
"learning, type the statements in with the tarantool client while reading "
"along."
msgstr ""
"Цель данного упражнения состоит в том, чтобы показать, как выглядят "
"Lua-функции в Tarantool'е. Необходимо будет работать с математической "
"библиотекой Lua, библиотекой для работы со строками интерпретатора Lua, "
"Tarantool-библиотекой ``box``, Tarantool-библиотекой ``box.tuple``, "
"циклами и конкатенацией. Инструкции легко будет выполнять даже тем, кто "
"никогда не использовал раньше Lua или Tarantool. Единственное требование "
"-- знание того, как работают другие языки программирования, и изучение "
"первых двух глав данного руководства. Но для лучшего понимания можно "
"следовать по комментариям и ссылкам на руководство по Lua или другим "
"пунктам в данном руководстве по Tarantool'у. А чтобы облегчить изучение, "
"читайте инструкции параллельно с вводом операторов в Tarantool-клиент."

#: ../doc/1.10/tutorials/lua_tutorials.rst:69
msgid "Configure"
msgstr "Настройка"

#: ../doc/1.10/tutorials/lua_tutorials.rst:71
msgid ""
"We are going to use the Tarantool sandbox that was created for our "
":ref:`\"Getting started\" exercises <getting_started>`. So there is a "
"single space, and a numeric primary key, and a running Tarantool server "
"instance which also serves as a client."
msgstr ""
"Будем использовать Tarantool-песочницу, которую создавали для "
":ref:`упражнений раздела \"Руководство для начинающих\" "
"<getting_started>`. Таким образом, у нас есть один спейс и числовой ключ "
"первичного индекса, а также экземпляр Tarantool'а, который также "
"выступает в виде клиента."

#: ../doc/1.10/tutorials/lua_tutorials.rst:78
msgid "Delimiter"
msgstr "Разделитель"

#: ../doc/1.10/tutorials/lua_tutorials.rst:80
msgid ""
"In earlier versions of Tarantool, multi-line functions had to be enclosed"
" within \"delimiters\". They are no longer necessary, and so they will "
"not be used in this tutorial. However, they are still supported. Users "
"who wish to use delimiters, or users of older versions of Tarantool, "
"should check the syntax description for :ref:`declaring a delimiter "
"<console-delimiter>` before proceeding."
msgstr ""
"В более ранних версиях Tarantool'а многострочные функции обрамляются "
"символами-разделителями. Сейчас в них нет необходимости, поэтому в данном"
" практическом задании они использоваться не будут. Однако они все еще "
"поддерживаются. Если вы хотите использовать разделители или используете "
"более раннюю версию Tarantool'а, перед работой проверьте описание "
"синтаксиса для :ref:`объявления разделителя <console-delimiter>`."

#: ../doc/1.10/tutorials/lua_tutorials.rst:89
msgid "Create a function that returns a string"
msgstr "Создание функции, которая возвращает строку"

#: ../doc/1.10/tutorials/lua_tutorials.rst:91
msgid ""
"We will start by making a function that returns a fixed string, “Hello "
"world”."
msgstr ""
"Начнем с создания функции, которая возвращает заданную строку -- “Hello "
"world”."

#: ../doc/1.10/tutorials/lua_tutorials.rst:93
msgid ""
"function string_function()\n"
"  return \"hello world\"\n"
"end"
msgstr ""
"function string_function()\n"
"  return \"hello world\"\n"
"end"

#: ../doc/1.10/tutorials/lua_tutorials.rst:99
msgid ""
"The word \"``function``\" is a Lua keyword -- we're about to go into Lua."
" The function name is string_function. The function has one executable "
"statement, ``return \"hello world\"``. The string \"hello world\" is "
"enclosed in double quotes here, although Lua doesn't care -- one could "
"use single quotes instead. The word \"``end``\" means “this is the end of"
" the Lua function declaration.” To confirm that the function works, we "
"can say"
msgstr ""
"Слово \"``function``\" (функция) -- ключевое слово в языке Lua. "
"Рассмотрим подробно работу с языком Lua. Имя функции -- string_function "
"(строковая_функция). В функции есть один исполняемый оператор, ``return "
"\"hello world\"`` (вернуть \"hello world\"). Строка \"hello world\" здесь"
" заключена в двойные кавычки, хотя в Lua это не имеет значения, можно "
"использовать одинарные кавычки. Слово \"``end``\" означает, что “это "
"конец объявления Lua-функции.” Чтобы проверить работу функции, можем "
"выполнить команду"

#: ../doc/1.10/tutorials/lua_tutorials.rst:106
msgid "string_function()"
msgstr "string_function()"

#: ../doc/1.10/tutorials/lua_tutorials.rst:110
msgid ""
"Sending ``function-name()`` means “invoke the Lua function.” The effect "
"is that the string which the function returns will end up on the screen."
msgstr ""
"Отправка ``function-name()`` (имя-функции) означает команду вызова "
"Lua-функции. В результате возвращаемая функцией строка появится на "
"экране."

#: ../doc/1.10/tutorials/lua_tutorials.rst:113
msgid ""
"For more about Lua strings see Lua manual `chapter 2.4 \"Strings\"`_ . "
"For more about functions see Lua manual `chapter 5 \"Functions\"`_."
msgstr ""
"Для получения подробной информации о строках в языке Lua, см.  `Главу 2.4"
" \"Строки\"`_ в руководстве по языку Lua. Для получения подробной "
"информации о функциях см. Главу 5 \"Функции\" в руководстве по языку Lua "
"(`chapter 5 \"Functions\"`_)."

#: ../doc/1.10/tutorials/lua_tutorials.rst:119
#: ../doc/1.10/tutorials/lua_tutorials.rst:163
#: ../doc/1.10/tutorials/lua_tutorials.rst:215
#: ../doc/1.10/tutorials/lua_tutorials.rst:271
#: ../doc/1.10/tutorials/lua_tutorials.rst:317
#: ../doc/1.10/tutorials/lua_tutorials.rst:377
#: ../doc/1.10/tutorials/lua_tutorials.rst:470
msgid "The screen now looks like this:"
msgstr "Теперь вывод на экране выглядит следующим образом:"

#: ../doc/1.10/tutorials/lua_tutorials.rst:121
msgid ""
"tarantool> function string_function()\n"
"         >   return \"hello world\"\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> string_function()\n"
"---\n"
"- hello world\n"
"...\n"
"tarantool>"
msgstr ""
"tarantool> function string_function()\n"
"         >   return \"hello world\"\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> string_function()\n"
"---\n"
"- hello world\n"
"...\n"
"tarantool>"

#: ../doc/1.10/tutorials/lua_tutorials.rst:136
msgid "Create a function that calls another function and sets a variable"
msgstr "Создание функции, которая вызывает другую функцию и определяет переменную"

#: ../doc/1.10/tutorials/lua_tutorials.rst:138
msgid ""
"Now that ``string_function`` exists, we can invoke it from another "
"function."
msgstr ""
"Теперь у нас есть функция ``string_function``, и можно вызвать ее с "
"помощью другой функции."

#: ../doc/1.10/tutorials/lua_tutorials.rst:141
msgid ""
"function main_function()\n"
"  local string_value\n"
"  string_value = string_function()\n"
"  return string_value\n"
"end"
msgstr ""
"function main_function()\n"
"  local string_value\n"
"  string_value = string_function()\n"
"  return string_value\n"
"end"

#: ../doc/1.10/tutorials/lua_tutorials.rst:149
msgid ""
"We begin by declaring a variable \"``string_value``\". The word "
"\"``local``\" means that string_value appears only in ``main_function``. "
"If we didn't use \"``local``\" then ``string_value`` would be visible "
"everywhere - even by other users using other clients connected to this "
"server instance! Sometimes that's a very desirable feature for inter-"
"client communication, but not this time."
msgstr ""
"Сначала объявим переменную \"``string_value``\" (значение_строки). Слово "
"\"``local``\" (локально) означает, что string_value появится только в "
"``main_function`` (основная_функция). Если бы мы не использовали "
"\"``local``\", то ``string_value`` увидели бы даже пользователи других "
"клиентов, которые подключились к данному экземпляру! Иногда это может "
"быть очень полезно при взаимодействии клиентов, но не в нашем случае."

#: ../doc/1.10/tutorials/lua_tutorials.rst:155
msgid ""
"Then we assign a value to ``string_value``, namely, the result of "
"``string_function()``. Soon we will invoke ``main_function()`` to check "
"that it got the value."
msgstr ""
"Затем определим значение для ``string_value``, а именно, результат "
"функции ``string_function()``. Сейчас вызовем ``main_function()``, чтобы "
"проверить, что значение определено."

#: ../doc/1.10/tutorials/lua_tutorials.rst:159
msgid ""
"For more about Lua variables see Lua manual `chapter 4.2 \"Local "
"Variables and Blocks\"`_ ."
msgstr ""
"Для получения подробной информации о переменных в языке Lua, см. Главу "
"4.2 \"Локальные переменные и блоки\" в руководстве по языку Lua (`chapter"
" 4.2 \"Local Variables and Blocks\"`_)."

#: ../doc/1.10/tutorials/lua_tutorials.rst:165
msgid ""
"tarantool> function main_function()\n"
"         >   local string_value\n"
"         >   string_value = string_function()\n"
"         >   return string_value\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- hello world\n"
"...\n"
"tarantool>"
msgstr ""
"tarantool> function main_function()\n"
"         >   local string_value\n"
"         >   string_value = string_function()\n"
"         >   return string_value\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- hello world\n"
"...\n"
"tarantool>"

#: ../doc/1.10/tutorials/lua_tutorials.rst:182
msgid "Modify the function so it returns a one-letter random string"
msgstr "Изменение функции для возврата строки из одной случайной буквы"

#: ../doc/1.10/tutorials/lua_tutorials.rst:184
msgid ""
"Now that it's a bit clearer how to make a variable, we can change "
"``string_function()`` so that, instead of returning a fixed literal "
"\"Hello world\", it returns a random letter between 'A' and 'Z'."
msgstr ""
"Сейчас стало понятно, как задавать переменную, поэтому можно изменить "
"функцию ``string_function()`` так, чтобы вместо возврата заданной фразы "
"\"Hello world\", она возвращала случайным образом выбранную букву от 'A' "
"до 'Z'."

#: ../doc/1.10/tutorials/lua_tutorials.rst:188
msgid ""
"function string_function()\n"
"  local random_number\n"
"  local random_string\n"
"  random_number = math.random(65, 90)\n"
"  random_string = string.char(random_number)\n"
"  return random_string\n"
"end"
msgstr ""
"function string_function()\n"
"  local random_number\n"
"  local random_string\n"
"  random_number = math.random(65, 90)\n"
"  random_string = string.char(random_number)\n"
"  return random_string\n"
"end"

#: ../doc/1.10/tutorials/lua_tutorials.rst:198
msgid ""
"It is not necessary to destroy the old ``string_function()`` contents, "
"they're simply overwritten. The first assignment invokes a random-number "
"function in Lua's math library; the parameters mean “the number must be "
"an integer between 65 and 90.” The second assignment invokes an integer-"
"to-character function in Lua's string library; the parameter is the code "
"point of the character. Luckily the ASCII value of 'A' is 65 and the "
"ASCII value of 'Z' is 90 so the result will always be a letter between A "
"and Z."
msgstr ""
"Нет необходимости стирать содержание старой функции "
"``string_function()``, оно просто перезаписывается. Первый оператор "
"вызывает функцию из математической библиотеки Lua, которая возвращает "
"случайное число; параметры означают, что число должно быть целым от 65 до"
" 90. Второй оператор вызывает функцию из библиотеки Lua для работы со "
"строками, которая преобразует число в символ; параметр представляет собой"
" кодовую точку символа. К счастью, в кодировке ASCII символу 'A' "
"соответствует значение 65, а 'Z' -- 90, так что в результате всегда "
"получим букву от A до Z."

#: ../doc/1.10/tutorials/lua_tutorials.rst:206
msgid ""
"For more about Lua math-library functions see Lua users \"`Math Library "
"Tutorial`_\". For more about Lua string-library functions see Lua users "
"\"`String Library Tutorial`_\" ."
msgstr ""
"Для получения подробной информации о функциях математической библиотеки в"
" языке Lua, см. Практическое задание по математической библиотеке для "
"пользователей Lua (`Math Library Tutorial`_). Для получения подробной "
"информации о функциях библиотеки для работы со строками в языке Lua, см. "
" Практическое задание по библиотеке для работы со строками для "
"пользователей Lua (`String Library Tutorial`_)."

#: ../doc/1.10/tutorials/lua_tutorials.rst:212
msgid ""
"Once again the ``string_function()`` can be invoked from main_function() "
"which can be invoked with ``main_function()``."
msgstr ""
"И снова функцию ``string_function()`` можно вызвать из main_function(), "
"которую можно вызвать с помощью ``main_function()``."

#: ../doc/1.10/tutorials/lua_tutorials.rst:217
msgid ""
"tarantool> function string_function()\n"
"         >   local random_number\n"
"         >   local random_string\n"
"         >   random_number = math.random(65, 90)\n"
"         >   random_string = string.char(random_number)\n"
"         >   return random_string\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- C\n"
"...\n"
"tarantool>"
msgstr ""
"tarantool> function string_function()\n"
"         >   local random_number\n"
"         >   local random_string\n"
"         >   random_number = math.random(65, 90)\n"
"         >   random_string = string.char(random_number)\n"
"         >   return random_string\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- C\n"
"...\n"
"tarantool>"

#: ../doc/1.10/tutorials/lua_tutorials.rst:234
msgid ""
"... Well, actually it won't always look like this because "
"``math.random()`` produces random numbers. But for the illustration "
"purposes it won't matter what the random string values are."
msgstr ""
"... На самом деле, вывод не всегда будет именно таким, поскольку функция "
"``math.random()`` вызывает случайные числа. Но для наглядности случайные "
"значения в строке не важны."

#: ../doc/1.10/tutorials/lua_tutorials.rst:240
msgid "Modify the function so it returns a ten-letter random string"
msgstr "Изменение функции для возврата строки из десяти случайных букв"

#: ../doc/1.10/tutorials/lua_tutorials.rst:242
msgid ""
"Now that it's clear how to produce one-letter random strings, we can "
"reach our goal of producing a ten-letter string by concatenating ten one-"
"letter strings, in a loop."
msgstr ""
"Сейчас стало понятно, как вызывать строки из одной случайной буквы, "
"поэтому можно перейти к нашей цели -- возврату строки из десяти букв с "
"помощью конкатенации десяти строк из одной случайной буквы в цикле."

#: ../doc/1.10/tutorials/lua_tutorials.rst:246
msgid ""
"function string_function()\n"
"  local random_number\n"
"  local random_string\n"
"  random_string = \"\"\n"
"  for x = 1,10,1 do\n"
"    random_number = math.random(65, 90)\n"
"    random_string = random_string .. string.char(random_number)\n"
"  end\n"
"  return random_string\n"
"end"
msgstr ""
"function string_function()\n"
"  local random_number\n"
"  local random_string\n"
"  random_string = \"\"\n"
"  for x = 1,10,1 do\n"
"    random_number = math.random(65, 90)\n"
"    random_string = random_string .. string.char(random_number)\n"
"  end\n"
"  return random_string\n"
"end"

#: ../doc/1.10/tutorials/lua_tutorials.rst:259
msgid ""
"The words \"for x = 1,10,1\" mean “start with x equals 1, loop until x "
"equals 10, increment x by 1 for each iteration.” The symbol \"..\" means "
"\"concatenate\", that is, add the string on the right of the \"..\" sign "
"to the string on the left of the \"..\" sign. Since we start by saying "
"that random_string is \"\" (a blank string), the end result is that "
"random_string has 10 random letters. Once again the ``string_function()``"
" can be invoked from ``main_function()`` which can be invoked with "
"``main_function()``."
msgstr ""
"Слова \"for x = 1,10,1\" означают: “начать с x, равного 1, зацикливать до"
" тех пор, пока x не будет равен 10, увеличивать x на 1 на каждом шаге "
"цикла”. Символ \"..\" означает \"конкатенацию\", то есть добавление "
"строки справа от знака \"..\" к строке слева от знака \"..\". Поскольку в"
" начале определяется, что random_string (случайная_строка) представляет "
"собой \"\" (пустую строку), в результате получим, что в random_string 10 "
"случайных букв. И снова функцию ``string_function()`` можно вызвать из "
"``main_function()``, которую можно вызвать с помощью ``main_function()``."

#: ../doc/1.10/tutorials/lua_tutorials.rst:267
msgid "For more about Lua loops see Lua manual `chapter 4.3.4 \"Numeric for\"`_."
msgstr ""
"Для получения подробной информации о циклах в языке Lua, см. Главу 4.3.4 "
"\"Числовой оператор for\" в руководстве по языку Lua (`chapter 4.3.4 "
"\"Numeric for\"`_)."

#: ../doc/1.10/tutorials/lua_tutorials.rst:273
msgid ""
"tarantool> function string_function()\n"
"         >   local random_number\n"
"         >   local random_string\n"
"         >   random_string = \"\"\n"
"         >   for x = 1,10,1 do\n"
"         >     random_number = math.random(65, 90)\n"
"         >     random_string = random_string .. "
"string.char(random_number)\n"
"         >   end\n"
"         >   return random_string\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- 'ZUDJBHKEFM'\n"
"...\n"
"tarantool>"
msgstr ""
"tarantool> function string_function()\n"
"         >   local random_number\n"
"         >   local random_string\n"
"         >   random_string = \"\"\n"
"         >   for x = 1,10,1 do\n"
"         >     random_number = math.random(65, 90)\n"
"         >     random_string = random_string .. "
"string.char(random_number)\n"
"         >   end\n"
"         >   return random_string\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- 'ZUDJBHKEFM'\n"
"...\n"
"tarantool>"

#: ../doc/1.10/tutorials/lua_tutorials.rst:295
msgid "Make a tuple out of a number and a string"
msgstr "Составление кортежа из числа и строки"

#: ../doc/1.10/tutorials/lua_tutorials.rst:297
msgid ""
"Now that it's clear how to make a 10-letter random string, it's possible "
"to make a tuple that contains a number and a 10-letter random string, by "
"invoking a function in Tarantool's library of Lua functions."
msgstr ""
"Сейчас стало понятно, как создать строку из 10 случайных букв, поэтому "
"можно создать кортеж, который будет содержать число и строку из 10 "
"случайных букв, с помощью функции в Tarantool-библиотеке Lua-функций."

#: ../doc/1.10/tutorials/lua_tutorials.rst:301
msgid ""
"function main_function()\n"
"  local string_value, t\n"
"  string_value = string_function()\n"
"  t = box.tuple.new({1, string_value})\n"
"  return t\n"
"end"
msgstr ""
"function main_function()\n"
"  local string_value, t\n"
"  string_value = string_function()\n"
"  t = box.tuple.new({1, string_value})\n"
"  return t\n"
"end"

#: ../doc/1.10/tutorials/lua_tutorials.rst:310
msgid ""
"Once this is done, t will be the value of a new tuple which has two "
"fields. The first field is numeric: 1. The second field is a random "
"string. Once again the ``string_function()`` can be invoked from "
"``main_function()`` which can be invoked with  ``main_function()``."
msgstr ""
"После этого, \"t\" будет представлять собой значение нового кортежа с "
"двумя полями. Первое поле является числовым: \"1\". Второе поле "
"представляет собой случайную строку. И снова функцию "
"``string_function()`` можно вызвать из ``main_function()``, которую можно"
" вызвать с помощью ``main_function()``."

#: ../doc/1.10/tutorials/lua_tutorials.rst:315
msgid ""
"For more about Tarantool tuples see Tarantool manual section "
":ref:`Submodule box.tuple <box_tuple>`."
msgstr ""
"Для получения подробной информации о кортежах в Tarantool'е, см. раздел "
":ref:`Вложенный модуль box.tuple <box_tuple>` руководства по Tarantool'у."

#: ../doc/1.10/tutorials/lua_tutorials.rst:319
msgid ""
"tarantool> function main_function()\n"
"         > local string_value, t\n"
"         > string_value = string_function()\n"
"         > t = box.tuple.new({1, string_value})\n"
"         > return t\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- [1, 'PNPZPCOOKA']\n"
"...\n"
"tarantool>"
msgstr ""
"tarantool> function main_function()\n"
"         > local string_value, t\n"
"         > string_value = string_function()\n"
"         > t = box.tuple.new({1, string_value})\n"
"         > return t\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- [1, 'PNPZPCOOKA']\n"
"...\n"
"tarantool>"

#: ../doc/1.10/tutorials/lua_tutorials.rst:337
msgid "Modify main_function to insert a tuple into the database"
msgstr "Изменение основной функции main_function для вставки кортежа в базу данных"

#: ../doc/1.10/tutorials/lua_tutorials.rst:339
msgid ""
"Now that it's clear how to make a tuple that contains a number and a "
"10-letter random string, the only trick remaining is putting that tuple "
"into tester. Remember that tester is the first space that was defined in "
"the sandbox, so it's like a database table."
msgstr ""
"Сейчас стало понятно, как создавать кортеж, который содержит число и "
"строку из десяти случайных букв, поэтому осталось только поместить этот "
"кортеж в спейс tester. Следует отметить, что tester -- это первый спейс, "
"определенный в песочнице, поэтому он представляет собой таблицу в базе "
"данных."

#: ../doc/1.10/tutorials/lua_tutorials.rst:344
msgid ""
"function main_function()\n"
"  local string_value, t\n"
"  string_value = string_function()\n"
"  t = box.tuple.new({1,string_value})\n"
"  box.space.tester:replace(t)\n"
"end"
msgstr ""
"function main_function()\n"
"  local string_value, t\n"
"  string_value = string_function()\n"
"  t = box.tuple.new({1,string_value})\n"
"  box.space.tester:replace(t)\n"
"end"

#: ../doc/1.10/tutorials/lua_tutorials.rst:353
msgid ""
"The new line here is ``box.space.tester:replace(t)``. The name contains "
"'tester' because the insertion is going to be to tester. The second "
"parameter is the tuple value. To be perfectly correct we could have said "
"``box.space.tester:insert(t)`` here, rather than "
"``box.space.tester:replace(t)``, but \"replace\" means “insert even if "
"there is already a tuple whose primary-key value is a duplicate”, and "
"that makes it easier to re-run the exercise even if the sandbox database "
"isn't empty. Once this is done, tester will contain a tuple with two "
"fields. The first field will be 1. The second field will be a random "
"10-letter string. Once again the ``string_function(``) can be invoked "
"from ``main_function()`` which can be invoked with ``main_function()``. "
"But ``main_function()`` won't tell the whole story, because it does not "
"return t, it only puts t into the database. To confirm that something got"
" inserted, we'll use a SELECT request."
msgstr ""
"Здесь новая строка -- ``box.space.tester:replace(t)``. Имя содержит слово"
" 'tester', потому что вставка будет осуществляться в спейс tester. Второй"
" параметр представляет собой значение в кортеже. Для абсолютной точности "
"мы могли ввести команду ``box.space.tester:insert(t)``, а не "
"``box.space.tester:replace(t)``, но слово \"replace\" (заменить) означает"
" “вставить, даже если уже существует кортеж, у которого значение "
"первичного ключа совпадает”, и это облегчит повтор упражнения, даже если "
"песочница не пуста. После того, как это будет выполнено, спейс tester "
"будет содержать кортеж с двумя полями. Первое поле будет 1. Второе поле "
"будет представлять собой строку из десяти случайных букв. И снова функцию"
" ``string_function()`` можно вызвать из ``main_function()``, которую "
"можно вызвать с помощью ``main_function()``. Но функция "
"``main_function()`` не может полностью отразить ситуацию, поскольку она "
"не возвращает t, она только размещает t в базе данных. Чтобы убедиться, "
"что произошла вставка, используем SELECT-запрос."

#: ../doc/1.10/tutorials/lua_tutorials.rst:367
msgid ""
"main_function()\n"
"box.space.tester:select{1}"
msgstr ""
"main_function()\n"
"         box.space.tester:select{1}"

#: ../doc/1.10/tutorials/lua_tutorials.rst:372
msgid ""
"For more about Tarantool insert and replace calls, see Tarantool manual "
"section :ref:`Submodule box.space <box_space>`, "
":ref:`space_object:insert() <box_space-insert>`, and "
":ref:`space_object:replace() <box_space-replace>`."
msgstr ""
"Для получения подробной информации о вызовах insert и replace в "
"Tarantool'е, см. разделы :ref:`Вложенный модуль box.space <box_space>`, "
":ref:`space_object:insert() <box_space-insert>` и "
":ref:`space_object:replace() <box_space-replace>` руководства по "
"Tarantool'у."

#: ../doc/1.10/tutorials/lua_tutorials.rst:379
msgid ""
"tarantool> function main_function()\n"
"         >   local string_value, t\n"
"         >   string_value = string_function()\n"
"         >   t = box.tuple.new({1,string_value})\n"
"         >   box.space.tester:replace(t)\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"...\n"
"tarantool> box.space.tester:select{1}\n"
"---\n"
"- - [1, 'EUJYVEECIL']\n"
"...\n"
"tarantool>"
msgstr ""
"tarantool> function main_function()\n"
"         >   local string_value, t\n"
"         >   string_value = string_function()\n"
"         >   t = box.tuple.new({1,string_value})\n"
"         >   box.space.tester:replace(t)\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"...\n"
"tarantool> box.space.tester:select{1}\n"
"---\n"
"- - [1, 'EUJYVEECIL']\n"
"...\n"
"tarantool>"

#: ../doc/1.10/tutorials/lua_tutorials.rst:400
msgid "Modify main_function to insert a million tuples into the database"
msgstr ""
"Изменение основной функции main_function для вставки миллиона кортежей в "
"базу данных"

#: ../doc/1.10/tutorials/lua_tutorials.rst:402
msgid ""
"Now that it's clear how to insert one tuple into the database, it's no "
"big deal to figure out how to scale up: instead of inserting with a "
"literal value = 1 for the primary key, insert with a variable value = "
"between 1 and 1 million, in a loop. Since we already saw how to loop, "
"that's a simple thing. The only extra wrinkle that we add here is a "
"timing function."
msgstr ""
"Сейчас стало понятно, как вставить кортеж в базу данных, поэтому несложно"
" догадаться, как можно увеличить масштаб: вместо того, чтобы вставлять "
"значение 1 для первичного ключа, вставьте значение переменной от 1 до "
"миллиона в цикле. Поскольку уже рассматривалось, как заводить цикл, это "
"будет несложно. Мы лишь добавим небольшой штрих -- функцию распределения "
"во времени."

#: ../doc/1.10/tutorials/lua_tutorials.rst:408
msgid ""
"function main_function()\n"
"  local string_value, t\n"
"  for i = 1,1000000,1 do\n"
"    string_value = string_function()\n"
"    t = box.tuple.new({i,string_value})\n"
"    box.space.tester:replace(t)\n"
"  end\n"
"end\n"
"start_time = os.clock()\n"
"main_function()\n"
"end_time = os.clock()\n"
"'insert done in ' .. end_time - start_time .. ' seconds'"
msgstr ""
"function main_function()\n"
"  local string_value, t\n"
"  for i = 1,1000000,1 do\n"
"    string_value = string_function()\n"
"    t = box.tuple.new({i,string_value})\n"
"    box.space.tester:replace(t)\n"
"  end\n"
"end\n"
"start_time = os.clock()\n"
"main_function()\n"
"end_time = os.clock()\n"
"'insert done in ' .. end_time - start_time .. ' seconds'"

#: ../doc/1.10/tutorials/lua_tutorials.rst:423
msgid ""
"The standard Lua function `os.clock() "
"<http://www.lua.org/manual/5.1/manual.html#pdf-os.clock>`_ will return "
"the number of CPU seconds since the start. Therefore, by getting "
"start_time = number of seconds just before the inserting, and then "
"getting end_time = number of seconds just after the inserting, we can "
"calculate (end_time - start_time) = elapsed time in seconds. We will "
"display that value by putting it in a request without any assignments, "
"which causes Tarantool to send the value to the client, which prints it. "
"(Lua's answer to the C ``printf()`` function, which is ``print()``, will "
"also work.)"
msgstr ""
"Стандартная Lua-функция `os.clock() "
"<http://www.lua.org/manual/5.1/manual.html#pdf-os.clock>`_ вернет время "
"ЦП в секундах с момента начала программы. Таким образом, выводя "
"start_time = number of seconds (время_начала = число секунд) прямо перед "
"вставкой, а затем выводя end_time = number of seconds (время_окончания = "
"число секунд) сразу после вставки, можно рассчитать (время_окончания - "
"время_начала) = затраченное время в секундах. Отобразим это значение "
"путем ввода в запрос без операторов, что приведет к тому, что Tarantool "
"отправит значение на клиент, который выведет это значение. (Ответ Lua на "
"C-функцию ``printf()``, а именно ``print()``, также сработает.)"

#: ../doc/1.10/tutorials/lua_tutorials.rst:433
msgid ""
"For more on Lua ``os.clock()`` see Lua manual `chapter 22.1 \"Date and "
"Time\"`_. For more on Lua print() see Lua manual `chapter 5 "
"\"Functions\"`_."
msgstr ""
"Для получения подробной информации о функции ``os.clock()`` см. Главу "
"22.1 \"Дата и время\" в руководстве по языку Lua (`chapter 22.1 \"Date "
"and Time\"`_). Для получения подробной информации о функции print() см. "
"Главу 5 \"Функции\" в руководстве по языку Lua (`chapter 5 "
"\"Functions\"`_)."

#: ../doc/1.10/tutorials/lua_tutorials.rst:439
msgid ""
"Since this is the grand finale, we will redo the final versions of all "
"the necessary requests: the request that created ``string_function()``, "
"the request that created ``main_function()``, and the request that "
"invokes ``main_function()``."
msgstr ""
"И поскольку наступает кульминация -- повторно введем окончательные "
"варианты всех необходимых запросов: запрос, который создает "
"``string_function()``, запрос, который создает ``main_function()``, и "
"запрос, который вызывает ``main_function()``."

#: ../doc/1.10/tutorials/lua_tutorials.rst:444
msgid ""
"function string_function()\n"
"  local random_number\n"
"  local random_string\n"
"  random_string = \"\"\n"
"  for x = 1,10,1 do\n"
"    random_number = math.random(65, 90)\n"
"    random_string = random_string .. string.char(random_number)\n"
"  end\n"
"  return random_string\n"
"end\n"
"\n"
"function main_function()\n"
"  local string_value, t\n"
"  for i = 1,1000000,1 do\n"
"    string_value = string_function()\n"
"    t = box.tuple.new({i,string_value})\n"
"    box.space.tester:replace(t)\n"
"  end\n"
"end\n"
"start_time = os.clock()\n"
"main_function()\n"
"end_time = os.clock()\n"
"'insert done in ' .. end_time - start_time .. ' seconds'"
msgstr ""
"function string_function()\n"
"           local random_number\n"
"           local random_string\n"
"           random_string = \"\"\n"
"           for x = 1,10,1 do\n"
"             random_number = math.random(65, 90)\n"
"             random_string = random_string .. string.char(random_number)\n"
"           end\n"
"           return random_string\n"
"         end\n"
"         \n"
"         function main_function()\n"
"           local string_value, t\n"
"           for i = 1,1000000,1 do\n"
"             string_value = string_function()\n"
"             t = box.tuple.new({i,string_value})\n"
"             box.space.tester:replace(t)\n"
"           end\n"
"         end\n"
"         start_time = os.clock()\n"
"         main_function()\n"
"         end_time = os.clock()\n"
"         'insert done in ' .. end_time - start_time .. ' seconds'"

#: ../doc/1.10/tutorials/lua_tutorials.rst:472
msgid ""
"tarantool> function string_function()\n"
"         >   local random_number\n"
"         >   local random_string\n"
"         >   random_string = \"\"\n"
"         >   for x = 1,10,1 do\n"
"         >     random_number = math.random(65, 90)\n"
"         >     random_string = random_string .. "
"string.char(random_number)\n"
"         >   end\n"
"         >   return random_string\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> function main_function()\n"
"         >   local string_value, t\n"
"         >   for i = 1,1000000,1 do\n"
"         >     string_value = string_function()\n"
"         >     t = box.tuple.new({i,string_value})\n"
"         >     box.space.tester:replace(t)\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> start_time = os.clock()\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"...\n"
"tarantool> end_time = os.clock()\n"
"---\n"
"...\n"
"tarantool> 'insert done in ' .. end_time - start_time .. ' seconds'\n"
"---\n"
"- insert done in 37.62 seconds\n"
"...\n"
"tarantool>"
msgstr ""
"tarantool> function string_function()\n"
"         >   local random_number\n"
"         >   local random_string\n"
"         >   random_string = \"\"\n"
"         >   for x = 1,10,1 do\n"
"         >     random_number = math.random(65, 90)\n"
"         >     random_string = random_string .. "
"string.char(random_number)\n"
"         >   end\n"
"         >   return random_string\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> function main_function()\n"
"         >   local string_value, t\n"
"         >   for i = 1,1000000,1 do\n"
"         >     string_value = string_function()\n"
"         >     t = box.tuple.new({i,string_value})\n"
"         >     box.space.tester:replace(t)\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> start_time = os.clock()\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"...\n"
"tarantool> end_time = os.clock()\n"
"---\n"
"...\n"
"tarantool> 'insert done in ' .. end_time - start_time .. ' seconds'\n"
"---\n"
"- insert done in 37.62 seconds\n"
"...\n"
"tarantool>"

#: ../doc/1.10/tutorials/lua_tutorials.rst:511
msgid ""
"What has been shown is that Lua functions are quite expressive (in fact "
"one can do more with Tarantool's Lua stored procedures than one can do "
"with stored procedures in some SQL DBMSs), and that it's straightforward "
"to combine Lua-library functions and Tarantool-library functions."
msgstr ""
"Итак, мы доказали, что возможности Lua-функций довольно многообразны (на "
"самом деле, с помощью хранимых процедур на языке Lua в Tarantool'е можно "
"сделать больше, чем с помощью хранимых процедур в некоторых SQL СУБД), и "
"несложно комбинировать функции Lua-библиотек и функции "
"Tarantool-библиотек."

#: ../doc/1.10/tutorials/lua_tutorials.rst:516
msgid ""
"What has also been shown is that inserting a million tuples took 37 "
"seconds. The host computer was a Linux laptop. By changing :ref:`wal_mode"
" <cfg_binary_logging_snapshots-wal_mode>` to 'none' before running the "
"test, one can reduce the elapsed time to 4 seconds."
msgstr ""
"Также мы показали, что вставка миллиона кортежей заняла 37 секунд. Хостом"
" выступил ноутбук с ОС Linux. А изменив значение  :ref:`wal_mode "
"<cfg_binary_logging_snapshots-wal_mode>` на 'none' перед запуском теста, "
"можно уменьшить затраченное время до 4 секунд."

#: ../doc/1.10/tutorials/lua_tutorials.rst:524
msgid "Sum a JSON field for all tuples"
msgstr "Подсчет суммы по JSON-полям во всех кортежах"

#: ../doc/1.10/tutorials/lua_tutorials.rst:526
msgid ""
"This is an exercise assignment: “Assume that inside every tuple there is "
"a string formatted as JSON. Inside that string there is a JSON numeric "
"field. For each tuple, find the numeric field's value and add it to a "
"'sum' variable. At end, return the 'sum' variable.” The purpose of the "
"exercise is to get experience in one way to read and process tuples."
msgstr ""
"Задание по данному практикуму: “Предположим, что в каждом кортеже есть "
"строка в формате JSON. В каждой строке есть числовое поле формата JSON. "
"Для каждого кортежа необходимо найти значение числового поля и прибавить "
"его к переменной 'sum' (сумма). В конце функция должна вернуть переменную"
" 'sum'.” Цель данного упражнения -- получить опыт в прочтении и обработке"
" кортежей одновременно."

#: ../doc/1.10/tutorials/lua_tutorials.rst:532
msgid ""
"json = require('json')\n"
"function sum_json_field(field_name)\n"
"  local v, t, sum, field_value, is_valid_json, lua_table\n"
"  sum = 0\n"
"  for v, t in box.space.tester:pairs() do\n"
"    is_valid_json, lua_table = pcall(json.decode, t[2])\n"
"    if is_valid_json then\n"
"      field_value = lua_table[field_name]\n"
"      if type(field_value) == \"number\" then sum = sum + field_value end"
"\n"
"    end\n"
"  end\n"
"  return sum\n"
"end"
msgstr ""
"json = require('json')\n"
"function sum_json_field(field_name)\n"
"  local v, t, sum, field_value, is_valid_json, lua_table\n"
"  sum = 0\n"
"  for v, t in box.space.tester:pairs() do\n"
"    is_valid_json, lua_table = pcall(json.decode, t[2])\n"
"    if is_valid_json then\n"
"      field_value = lua_table[field_name]\n"
"      if type(field_value) == \"number\" then sum = sum + field_value end"
"\n"
"    end\n"
"  end\n"
"  return sum\n"
"end"

#: ../doc/1.10/tutorials/lua_tutorials.rst:549
msgid ""
"**LINE 3: WHY \"LOCAL\".** This line declares all the variables that will"
" be used in the function. Actually it's not necessary to declare all "
"variables at the start, and in a long function it would be better to "
"declare variables just before using them. In fact it's not even necessary"
" to declare variables at all, but an undeclared variable is \"global\". "
"That's not desirable for any of the variables that are declared in line "
"1, because all of them are for use only within the function."
msgstr ""
"**СТРОКА 3: ЗАЧЕМ НУЖЕН \"LOCAL\".** Эта строка объявляет все переменные,"
" которые будут использоваться в функции. На самом деле, нет необходимости"
" в начале объявлять все переменные, а в длинной функции лучше объявить "
"переменные прямо перед их использованием. Фактически объявлять переменные"
" вообще необязательно, но необъявленная переменная будет \"глобальной\". "
"Это представляется нежелательным для всех переменных, объявленных в "
"строке 1, поскольку все они используются только в рамках функции."

#: ../doc/1.10/tutorials/lua_tutorials.rst:556
msgid ""
"**LINE 5: WHY \"PAIRS()\".** Our job is to go through all the rows and "
"there are two ways to do it: with :ref:`box.space.space_object:pairs() "
"<box_space-pairs>` or with ``variable = select(...)`` followed by "
":samp:`for i, {n}, 1 do {some-function}(variable[i]) end`. We preferred "
"``pairs()`` for this example."
msgstr ""
"**СТРОКА 5: ЗАЧЕМ НУЖЕН \"PAIRS()\".** Наша задача -- пройти по всем "
"строкам, что можно сделать двумя способами: с помощью "
":ref:`box.space.space_object:pairs() <box_space-pairs>` или с помощью "
"``variable = select(...)`` с указанием :samp:`for i, {n}, 1 do "
"{некая-функция}(variable[i]) end`. Для данного примера мы предпочли "
"использовать ``pairs()``."

#: ../doc/1.10/tutorials/lua_tutorials.rst:561
msgid ""
"**LINE 5: START THE MAIN LOOP.** Everything inside this \"``for``\" loop "
"will be repeated as long as there is another index key. A tuple is "
"fetched and can be referenced with variable :code:`t`."
msgstr ""
"**СТРОКА 5: НАЧАЛО ОСНОВНОГО ЦИКЛА.** Всё внутри цикла \"``for``\" будет "
"повторяться до тех пор, пока не кончатся индекс-ключи. На полученный "
"кортеж можно сослаться с помощью переменной :code:`t`."

#: ../doc/1.10/tutorials/lua_tutorials.rst:565
msgid ""
"**LINE 6: WHY \"PCALL\".** If we simply said ``lua_table = "
"json.decode(t[2]))``, then the function would abort with an error if it "
"encountered something wrong with the JSON string - a missing colon, for "
"example. By putting the function inside \"``pcall``\" (`protected "
"call`_), we're saying: we want to intercept that sort of error, so if "
"there's a problem just set ``is_valid_json = false`` and we will know "
"what to do about it later."
msgstr ""
"**СТРОКА 6: ЗАЧЕМ НУЖЕН \"PCALL\".** Если бы мы просто ввели ``lua_table "
"= json.decode(t[2]))``, то функция завершила бы работу с ошибкой, "
"обнаружив любое несоответствие в JSON-строке, например отсутствие "
"запятой. Заключив функцию в \"``pcall``\" (`protected call`_ -- "
"защищенный вызов), мы заявляем следующее: хотим перехватывать ошибки "
"такого рода, поэтому в случае ошибки следует просто указать "
"``is_valid_json = false``, и позднее мы решим, что с этим делать."

#: ../doc/1.10/tutorials/lua_tutorials.rst:572
msgid ""
"**LINE 6: MEANING.** The function is :ref:`json.decode <json-decode>` "
"which means decode a JSON string, and the parameter is t[2] which is a "
"reference to a JSON string. There's a bit of hard coding here, we're "
"assuming that the second field in the tuple is where the JSON string was "
"inserted. For example, we're assuming a tuple looks like"
msgstr ""
"**СТРОКА 6: ЗНАЧЕНИЕ.** Функция :ref:`json.decode <json-decode>` означает"
" декодирование JSON-строки, а параметр t[2] представляет собой ссылку на "
"JSON-строку. Здесь есть заранее заданные значения, а мы предполагаем, что"
" JSON-строка была вставлена во второе поле кортежа. Например, "
"предположим, что кортеж выглядит следующим образом:"

#: ../doc/1.10/tutorials/lua_tutorials.rst:582
msgid ""
"field[1]: 444\n"
"field[2]: '{\"Hello\": \"world\", \"Quantity\": 15}'"
msgstr ""
"field[1]: 444\n"
"field[2]: '{\"Hello\": \"world\", \"Quantity\": 15}'"

#: ../doc/1.10/tutorials/lua_tutorials.rst:585
msgid ""
"meaning that the tuple's first field, the primary key field, is a number "
"while the tuple's second field, the JSON string, is a string. Thus the "
"entire statement means \"decode ``t[2]`` (the tuple's second field) as a "
"JSON string; if there's an error set ``is_valid_json = false``; if "
"there's no error set ``is_valid_json = true`` and set ``lua_table =`` a "
"Lua table which has the decoded string\"."
msgstr ""
"что означает, что первое поле кортежа, первичное поле, представляет собой"
" число, а второе поле кортежа, JSON-строка, является строкой. Таким "
"образом, значение оператора будет следующим: \"декодировать ``t[2]`` "
"(второе поле кортежа) как JSON-строку; если обнаружится ошибка, то "
"указать ``is_valid_json = false``; если ошибок нет, указать "
"``is_valid_json = true`` и ``lua_table =`` Lua-таблица, в которой "
"находится декодированная строка\"."

#: ../doc/1.10/tutorials/lua_tutorials.rst:591
msgid ""
"**LINE 8.** At last we are ready to get the JSON field value from the Lua"
" table that came from the JSON string. The value in field_name, which is "
"the parameter for the whole function, must be a name of a JSON field. For"
" example, inside the JSON string ``'{\"Hello\": \"world\", \"Quantity\": "
"15}'``, there are two JSON fields: \"Hello\" and \"Quantity\". If the "
"whole function is invoked with ``sum_json_field(\"Quantity\")``, then "
"``field_value = lua_table[field_name]`` is effectively the same as "
"``field_value = lua_table[\"Quantity\"]`` or even ``field_value = "
"lua_table.Quantity``. Those are just three different ways of saying: for "
"the Quantity field in the Lua table, get the value and put it in variable"
" :code:`field_value`."
msgstr ""
"**СТРОКА 8.** Наконец, мы готовы получить значение JSON-поля из "
"Lua-таблицы, взятое из JSON-строки. Значение в field_name (имя_поля), "
"которое является параметром всей функции, должно представлять собой "
"JSON-поле. Например, в JSON-строке ``'{\"Hello\": \"world\", "
"\"Quantity\": 15}'`` есть два JSON-поля: \"Hello\" и \"Quantity\". Если "
"вся функция вызывается с помощью ``sum_json_field(\"Quantity\")``, тогда "
"``field_value = lua_table[field_name]`` (значение_поля = "
"Lua_таблица[имя_поля]) по сути аналогично ``field_value = "
"lua_table[\"Quantity\"]`` или даже ``field_value = lua_table.Quantity``. "
"Итак, этими тремя способами можно ввести следующую команду: получить "
"значение поля Quantity в Lua-таблице и поместить его в переменную "
":code:`field_value`."

#: ../doc/1.10/tutorials/lua_tutorials.rst:601
msgid ""
"**LINE 9: WHY \"IF\".** Suppose that the JSON string is well formed but "
"the JSON field is not a number, or is missing. In that case, the function"
" would be aborted when there was an attempt to add it to the sum. By "
"first checking ``type(field_value) == \"number\"``, we avoid that "
"abortion. Anyone who knows that the database is in perfect shape can skip"
" this kind of thing."
msgstr ""
"**СТРОКА 9: ЗАЧЕМ НУЖЕН \"IF\".** Предположим, что JSON-строка не "
"содержит синтаксических ошибок, но JSON-поле не является числовым или "
"вовсе отсутствует. В таком случае выполнение функции прервется при "
"попытке прибавить значение к сумме. Если сначала проверить, "
"``type(field_value) == \"number\"`` (тип(значение_поля) == \"число\"), "
"можно избежать прерывания функции. Если вы уверены, что база данных в "
"идеальном состоянии, этот шаг можно пропустить."

#: ../doc/1.10/tutorials/lua_tutorials.rst:607
msgid ""
"And the function is complete. Time to test it. Starting with an empty "
"database, defined the same way as the sandbox database in our "
":ref:`\"Getting started\" exercises <getting_started>`,"
msgstr ""
"И функция готова. Пора протестировать ее. Начинаем с пустой базы данных "
"так же, как с песочницы в :ref:`упражнения в \"Руководстве для "
"начинающих\" <getting_started>`,"

#: ../doc/1.10/tutorials/lua_tutorials.rst:611
msgid ""
"-- if tester is left over from some previous test, destroy it\n"
"box.space.tester:drop()\n"
"box.schema.space.create('tester')\n"
"box.space.tester:create_index('primary', {parts = {1, 'unsigned'}})"
msgstr ""
"-- если спейс tester остался от предыдущего задания, удалите его\n"
"box.space.tester:drop()\n"
"box.schema.space.create('tester')\n"
"box.space.tester:create_index('primary', {parts = {1, 'unsigned'}})"

#: ../doc/1.10/tutorials/lua_tutorials.rst:618
msgid ""
"then add some tuples where the first field is a number and the second "
"field is a string."
msgstr ""
"затем добавим несколько кортежей, где первое поле является числовым, а "
"второе поле представляет собой строку."

#: ../doc/1.10/tutorials/lua_tutorials.rst:621
msgid ""
"box.space.tester:insert{444, '{\"Item\": \"widget\", \"Quantity\": 15}'}\n"
"box.space.tester:insert{445, '{\"Item\": \"widget\", \"Quantity\": 7}'}\n"
"box.space.tester:insert{446, '{\"Item\": \"golf club\", \"Quantity\": "
"\"sunshine\"}'}\n"
"box.space.tester:insert{447, '{\"Item\": \"waffle iron\", \"Quantit\": "
"3}'}"
msgstr ""
"box.space.tester:insert{444, '{\"Item\": \"widget\", \"Quantity\": 15}'}\n"
"box.space.tester:insert{445, '{\"Item\": \"widget\", \"Quantity\": 7}'}\n"
"box.space.tester:insert{446, '{\"Item\": \"golf club\", \"Quantity\": "
"\"sunshine\"}'}\n"
"box.space.tester:insert{447, '{\"Item\": \"waffle iron\", \"Quantit\": "
"3}'}"

#: ../doc/1.10/tutorials/lua_tutorials.rst:628
msgid ""
"Since this is a test, there are deliberate errors. The \"golf club\" and "
"the \"waffle iron\" do not have numeric Quantity fields, so must be "
"ignored. Therefore the real sum of the Quantity field in the JSON strings"
" should be: 15 + 7 = 22."
msgstr ""
"Для целей практики здесь допущены ошибки. В \"golf club\" и \"waffle "
"iron\" поля Quantity не являются числовыми, поэтому будут игнорироваться."
" Таким образом, итоговая сумма для полей Quantity в JSON-строках должна "
"быть следующей: 15 + 7 = 22."

#: ../doc/1.10/tutorials/lua_tutorials.rst:633
msgid "Invoke the function with ``sum_json_field(\"Quantity\")``."
msgstr "Вызовите функцию с помощью ``sum_json_field(\"Quantity\")``."

#: ../doc/1.10/tutorials/lua_tutorials.rst:635
msgid ""
"tarantool> sum_json_field(\"Quantity\")\n"
"---\n"
"- 22\n"
"..."
msgstr ""
"tarantool> sum_json_field(\"Quantity\")\n"
"---\n"
"- 22\n"
"..."

#: ../doc/1.10/tutorials/lua_tutorials.rst:642
msgid ""
"It works. We'll just leave, as exercises for future improvement, the "
"possibility that the \"hard coding\" assumptions could be removed, that "
"there might have to be an overflow check if some field values are huge, "
"and that the function should contain a :ref:`yield <atomic-"
"threads_fibers_yields>` instruction if the count of tuples is huge."
msgstr ""
"Сработало. Для дополнительной отработки материала можно убрать заранее "
"заданные значения, добавить проверку потенциально возможного "
"арифметического переполнения при наличии больших значений некоторых "
"полей, а также команду :ref:`передачи управления <atomic-"
"threads_fibers_yields>` при огромном количестве кортежей."

#: ../doc/1.10/tutorials/lua_tutorials.rst:651
msgid "Indexed pattern search"
msgstr "Индексированный поиск по шаблонам"

#: ../doc/1.10/tutorials/lua_tutorials.rst:653
msgid ""
"Here is a generic function which takes a field identifier and a search "
"pattern, and returns all tuples that match. |br| * The field must be the "
"first field of a TREE index. |br| * The function will use `Lua pattern "
"matching <http://www.lua.org/manual/5.2/manual.html#6.4.1>`_, which "
"allows \"magic characters\" in regular expressions. |br| * The initial "
"characters in the pattern, as far as the first magic character, will be "
"used as an index search key. For each tuple that is found via the index, "
"there will be a match of the whole pattern. |br| * To be "
":ref:`cooperative <atomic-cooperative_multitasking>`, the function should"
" yield after every 10 tuples, unless there is a reason to delay yielding."
" |br| With this function, we can take advantage of Tarantool's indexes "
"for speed, and take advantage of Lua's pattern matching for flexibility. "
"It does everything that an SQL \"LIKE\" search can do, and far more."
msgstr ""
"Здесь приведена обобщенная функция, которая берет идентификатор поля и "
"шаблон поиска, а затем возвращает все кортежи, которые подходят под "
"критерии. |br| * Поле должно быть первым полем в TREE-индексе. |br| * "
"Функция применяет `шаблоны в языке Lua "
"<http://www.lua.org/manual/5.2/manual.html#6.4.1>`_, что позволяет "
"использовать \"магические символы\" в регулярных выражениях. |br| * "
"Начальные символы в шаблоне до самого первого магического символа будут "
"использоваться в качестве ключа поиска по индексу. Каждый кортеж, "
"обнаруженный по индексу, будет соответствовать всему шаблону. |br| * В "
"целях :ref:`кооперативной многозадачности <atomic-"
"cooperative_multitasking>` функция должна передавать управление через "
"каждые 10 кортежей, если только нет причин отложить передачу управления. "
"|br| С помощью данной функции можно воспользоваться индексами Tarantool'а"
" для ускорения и шаблонами на языке Lua для гибкости. Поддерживаются все "
"возможности поиска LIKE в SQL -- и многие другие."

#: ../doc/1.10/tutorials/lua_tutorials.rst:670
msgid ""
"Read the following Lua code to see how it works. The comments that begin "
"with \"SEE NOTE ...\" refer to long explanations that follow the code."
msgstr ""
"Прочитайте следующий Lua-код, чтобы понять, как он работает. Комментарии,"
" которые начинаются с \"СМ. ПРИМЕЧАНИЕ ...\" ссылаются на подробные "
"объяснения, приведенные ниже."

#: ../doc/1.10/tutorials/lua_tutorials.rst:674
msgid ""
"function indexed_pattern_search(space_name, field_no, pattern)\n"
"  -- SEE NOTE #1 \"FIND AN APPROPRIATE INDEX\"\n"
"  if (box.space[space_name] == nil) then\n"
"    print(\"Error: Failed to find the specified space\")\n"
"    return nil\n"
"  end\n"
"  local index_no = -1\n"
"  for i=0,box.schema.INDEX_MAX,1 do\n"
"    if (box.space[space_name].index[i] == nil) then break end\n"
"    if (box.space[space_name].index[i].type == \"TREE\"\n"
"        and box.space[space_name].index[i].parts[1].fieldno == field_no\n"
"        and (box.space[space_name].index[i].parts[1].type == \"scalar\"\n"
"        or box.space[space_name].index[i].parts[1].type == \"string\")) "
"then\n"
"      index_no = i\n"
"      break\n"
"    end\n"
"  end\n"
"  if (index_no == -1) then\n"
"    print(\"Error: Failed to find an appropriate index\")\n"
"    return nil\n"
"  end\n"
"  -- SEE NOTE #2 \"DERIVE INDEX SEARCH KEY FROM PATTERN\"\n"
"  local index_search_key = \"\"\n"
"  local index_search_key_length = 0\n"
"  local last_character = \"\"\n"
"  local c = \"\"\n"
"  local c2 = \"\"\n"
"  for i=1,string.len(pattern),1 do\n"
"    c = string.sub(pattern, i, i)\n"
"    if (last_character ~= \"%\") then\n"
"      if (c == '^' or c == \"$\" or c == \"(\" or c == \")\" or c == "
"\".\"\n"
"                   or c == \"[\" or c == \"]\" or c == \"*\" or c == "
"\"+\"\n"
"                   or c == \"-\" or c == \"?\") then\n"
"        break\n"
"      end\n"
"      if (c == \"%\") then\n"
"        c2 = string.sub(pattern, i + 1, i + 1)\n"
"        if (string.match(c2, \"%p\") == nil) then break end\n"
"        index_search_key = index_search_key .. c2\n"
"      else\n"
"        index_search_key = index_search_key .. c\n"
"      end\n"
"    end\n"
"    last_character = c\n"
"  end\n"
"  index_search_key_length = string.len(index_search_key)\n"
"  if (index_search_key_length < 3) then\n"
"    print(\"Error: index search key \" .. index_search_key .. \" is too "
"short\")\n"
"    return nil\n"
"  end\n"
"  -- SEE NOTE #3 \"OUTER LOOP: INITIATE\"\n"
"  local result_set = {}\n"
"  local number_of_tuples_in_result_set = 0\n"
"  local previous_tuple_field = \"\"\n"
"  while true do\n"
"    local number_of_tuples_since_last_yield = 0\n"
"    local is_time_for_a_yield = false\n"
"    -- SEE NOTE #4 \"INNER LOOP: ITERATOR\"\n"
"    for _,tuple in box.space[space_name].index[index_no]:\n"
"    pairs(index_search_key,{iterator = box.index.GE}) do\n"
"      -- SEE NOTE #5 \"INNER LOOP: BREAK IF INDEX KEY IS TOO GREAT\"\n"
"      if (string.sub(tuple[field_no], 1, index_search_key_length)\n"
"      > index_search_key) then\n"
"        break\n"
"      end\n"
"      -- SEE NOTE #6 \"INNER LOOP: BREAK AFTER EVERY 10 TUPLES -- MAYBE\""
"\n"
"      number_of_tuples_since_last_yield = "
"number_of_tuples_since_last_yield + 1\n"
"      if (number_of_tuples_since_last_yield >= 10\n"
"          and tuple[field_no] ~= previous_tuple_field) then\n"
"        index_search_key = tuple[field_no]\n"
"        is_time_for_a_yield = true\n"
"        break\n"
"        end\n"
"      previous_tuple_field = tuple[field_no]\n"
"      -- SEE NOTE #7 \"INNER LOOP: ADD TO RESULT SET IF PATTERN MATCHES\""
"\n"
"      if (string.match(tuple[field_no], pattern) ~= nil) then\n"
"        number_of_tuples_in_result_set = number_of_tuples_in_result_set +"
" 1\n"
"        result_set[number_of_tuples_in_result_set] = tuple\n"
"      end\n"
"    end\n"
"    -- SEE NOTE #8 \"OUTER LOOP: BREAK, OR YIELD AND CONTINUE\"\n"
"    if (is_time_for_a_yield ~= true) then\n"
"      break\n"
"    end\n"
"    require('fiber').yield()\n"
"  end\n"
"  return result_set\n"
"end"
msgstr ""
"function indexed_pattern_search(space_name, field_no, pattern)\n"
"  -- СМ. ПРИМЕЧАНИЕ №1 \"ПОИСК НУЖНОГО ИНДЕКСА\"\n"
"  if (box.space[space_name] == nil) then\n"
"    print(\"Error: Failed to find the specified space\")\n"
"    return nil\n"
"  end\n"
"  local index_no = -1\n"
"  for i=0,box.schema.INDEX_MAX,1 do\n"
"    if (box.space[space_name].index[i] == nil) then break end\n"
"    if (box.space[space_name].index[i].type == \"TREE\"\n"
"        and box.space[space_name].index[i].parts[1].fieldno == field_no\n"
"        and (box.space[space_name].index[i].parts[1].type == \"scalar\"\n"
"        or box.space[space_name].index[i].parts[1].type == \"string\")) "
"then\n"
"      index_no = i\n"
"      break\n"
"    end\n"
"  end\n"
"  if (index_no == -1) then\n"
"    print(\"Error: Failed to find an appropriate index\")\n"
"    return nil\n"
"  end\n"
"  -- СМ. ПРИМЕЧАНИЕ №2 \"ПОЛУЧЕНИЕ КЛЮЧА ИНДЕКСНОГО ПОИСКА ИЗ ШАБЛОНА\"\n"
"  local index_search_key = \"\"\n"
"  local index_search_key_length = 0\n"
"  local last_character = \"\"\n"
"  local c = \"\"\n"
"  local c2 = \"\"\n"
"  for i=1,string.len(pattern),1 do\n"
"    c = string.sub(pattern, i, i)\n"
"    if (last_character ~= \"%\") then\n"
"      if (c == '^' or c == \"$\" or c == \"(\" or c == \")\" or c == "
"\".\"\n"
"                   or c == \"[\" or c == \"]\" or c == \"*\" or c == "
"\"+\"\n"
"                   or c == \"-\" or c == \"?\") then\n"
"        break\n"
"      end\n"
"      if (c == \"%\") then\n"
"        c2 = string.sub(pattern, i + 1, i + 1)\n"
"        if (string.match(c2, \"%p\") == nil) then break end\n"
"        index_search_key = index_search_key .. c2\n"
"      else\n"
"        index_search_key = index_search_key .. c\n"
"      end\n"
"    end\n"
"    last_character = c\n"
"  end\n"
"  index_search_key_length = string.len(index_search_key)\n"
"  if (index_search_key_length < 3) then\n"
"    print(\"Error: index search key \" .. index_search_key .. \" is too "
"short\")\n"
"    return nil\n"
"  end\n"
"  -- СМ. ПРИМЕЧАНИЕ №3 \"ВНЕШНИЙ ЦИКЛ: НАЧАЛО\"\n"
"  local result_set = {}\n"
"  local number_of_tuples_in_result_set = 0\n"
"  local previous_tuple_field = \"\"\n"
"  while true do\n"
"    local number_of_tuples_since_last_yield = 0\n"
"    local is_time_for_a_yield = false\n"
"    -- СМ. ПРИМЕЧАНИЕ №4 \"ВНУТРЕННИЙ ЦИКЛ: ИТЕРАТОР\"\n"
"    for _,tuple in box.space[space_name].index[index_no]:\n"
"    pairs(index_search_key,{iterator = box.index.GE}) do\n"
"      -- СМ. ПРИМЕЧАНИЕ №5 \"ВНУТРЕННИЙ ЦИКЛ: ПРЕРЫВАНИЕ, ЕСЛИ КЛЮЧ "
"ИНДЕКСА СЛИШКОМ БОЛЬШОЙ\"\n"
"      if (string.sub(tuple[field_no], 1, index_search_key_length)\n"
"      > index_search_key) then\n"
"        break\n"
"      end\n"
"      -- СМ. ПРИМЕЧАНИЕ №6 \"ВНУТРЕННИЙ ЦИКЛ: ПРЕРЫВАНИЕ ПОСЛЕ КАЖДЫХ "
"ДЕСЯТИ КОРТЕЖЕЙ -- ВОЗМОЖНО\"\n"
"      number_of_tuples_since_last_yield = "
"number_of_tuples_since_last_yield + 1\n"
"      if (number_of_tuples_since_last_yield >= 10\n"
"          and tuple[field_no] ~= previous_tuple_field) then\n"
"        index_search_key = tuple[field_no]\n"
"        is_time_for_a_yield = true\n"
"        break\n"
"        end\n"
"      previous_tuple_field = tuple[field_no]\n"
"      -- СМ. ПРИМЕЧАНИЕ №7 \"ВНУТРЕННИЙ ЦИКЛ: ДОБАВЛЕНИЕ В РЕЗУЛЬТАТ, "
"ЕСЛИ ШАБЛОН СОВПАДЕТ\"\n"
"      if (string.match(tuple[field_no], pattern) ~= nil) then\n"
"        number_of_tuples_in_result_set = number_of_tuples_in_result_set +"
" 1\n"
"        result_set[number_of_tuples_in_result_set] = tuple\n"
"      end\n"
"    end\n"
"    -- СМ. ПРИМЕЧАНИЕ №8 \"ВНЕШНИЙ ЦИКЛ: ПРЕРЫВАНИЕ ИЛИ ПЕРЕДАЧА "
"УПРАВЛЕНИЯ И ПРОДОЛЖЕНИЕ\"\n"
"    if (is_time_for_a_yield ~= true) then\n"
"      break\n"
"    end\n"
"    require('fiber').yield()\n"
"  end\n"
"  return result_set\n"
"end"

#: ../doc/1.10/tutorials/lua_tutorials.rst:765
msgid ""
"NOTE #1 \"FIND AN APPROPRIATE INDEX\" |br| The caller has passed "
"space_name (a string) and field_no (a number). The requirements are: |br|"
" (a) index type must be \"TREE\" because for other index types (HASH, "
"BITSET, RTREE) a search with :ref:`iterator=GE <box_index-iterator-"
"types>` will not return strings in order by string value; |br| (b) "
"field_no must be the first index part; |br| (c) the field must contain "
"strings, because for other data types (such as \"unsigned\") pattern "
"searches are not possible; |br| If these requirements are not met by any "
"index, then print an error message and return nil."
msgstr ""
"ПРИМЕЧАНИЕ №1 \"ПОИСК НУЖНОГО ИНДЕКСА\" |br| Вызывающий клиент передал "
"space_name (имя_спейса -- строка) и field_no (номер_поля -- число). "
"Требования следующие: |br| (a) тип индекса должен быть \"TREE\", "
"поскольку для других типов индекса (HASH, BITSET, RTREE) поиск с "
":ref:`итератором=GE <box_index-iterator-types>` не вернет строки, "
"упорядоченные по строковому значению; |br| (b) field_no должен "
"представлять собой первую часть индекса; |br| (c) поле должно содержать "
"строки, потому что для других типов данных (как \"unsigned\") шаблоны "
"поиска не применяются; |br| Если индекс не удовлетворяет этим "
"требованиям, выдать сообщение об ошибке и вернуть нулевое значение nil."

#: ../doc/1.10/tutorials/lua_tutorials.rst:777
msgid ""
"NOTE #2 \"DERIVE INDEX SEARCH KEY FROM PATTERN\" |br| The caller has "
"passed pattern (a string). The index search key will be the characters in"
" the pattern as far as the first magic character. Lua's magic characters "
"are % ^ $ ( ) . [ ] * + - ?. For example, if the pattern is \"ABC.E\", "
"the period is a magic character and therefore the index search key will "
"be \"ABC\". But there is a complication ... If we see \"%\" followed by a"
" punctuation character, that punctuation character is \"escaped\" so "
"remove the \"%\" when making the index search key. For example, if the "
"pattern is \"AB%$E\", the dollar sign is escaped and therefore the index "
"search key will be \"AB$E\". Finally there is a check that the index "
"search key length must be at least three -- this is an arbitrary number, "
"and in fact zero would be okay, but short index search keys will cause "
"long search times."
msgstr ""
"ПРИМЕЧАНИЕ №2 \"ПОЛУЧЕНИЕ КЛЮЧА ИНДЕКСНОГО ПОИСКА ИЗ ШАБЛОНА\" |br| "
"Вызывающий клиент передал шаблон (строку). Ключом поиска по индексу "
"являются символы в шаблоне до первого магического символа. Магические "
"символы в Lua: % ^ $ ( ) . [ ] * + - ?. Например, если задан шаблон "
"\"ABC.E\", точка будет магическим символом, и ключом поиска по индексу "
"будет \"ABC\". Однако есть затруднение ... Если символ \"%\" будет идти "
"следом за знаком препинания, этот знак препинания экранируется, поэтому "
"следует убрать \"%\" из ключа поиска по индексу. Например, если задан "
"шаблон \"AB%$E\", знак доллара экранируется, поэтому ключом поиска по "
"индексу будет \"AB$E\". Наконец, есть проверка длины ключа поиска по "
"индексу -- не менее трех символов, причем это число выбрано произвольно, "
"и даже ноль здесь подойдет, но по короткому ключу поиск займет длительное"
" время."

#: ../doc/1.10/tutorials/lua_tutorials.rst:794
msgid ""
"NOTE #3 -- \"OUTER LOOP: INITIATE\" |br| The function's job is to return "
"a result set, just as `box.space...select <box_space-select>` would. We "
"will fill it within an outer loop that contains an inner loop. The outer "
"loop's job is to execute the inner loop, and possibly :ref:`yield "
"<atomic-threads_fibers_yields>`, until the search ends. The inner loop's "
"job is to find tuples via the index, and put them in the result set if "
"they match the pattern."
msgstr ""
"ПРИМЕЧАНИЕ №3 \"ВНЕШНИЙ ЦИКЛ: НАЧАЛО\" |br| Назначение функции -- вернуть"
" результирующий набор данных, как вернул бы запрос `box.space...select "
"<box_space-select>`. Мы внесем ее во внешний цикл, который включает в "
"себя внутренний цикл. Назначение внешнего цикла -- выполнять внутренний "
"цикл и, при необходимости, :ref:`передачу управления <atomic-"
"threads_fibers_yields>`, пока поиск не будет завершен. Назначение "
"внутреннего цикла -- находить кортежи по индексу и включать их в "
"результирующий набор данных, если они подходят под шаблон."

#: ../doc/1.10/tutorials/lua_tutorials.rst:803
msgid ""
"NOTE #4 \"INNER LOOP: ITERATOR\" |br| The for loop here is using pairs(),"
" see the :ref:`explanation of what index iterators are <box_index-"
"index_pairs>`. Within the inner loop, there will be a local variable "
"named \"tuple\" which contains the latest tuple found via the index "
"search key."
msgstr ""
"ПРИМЕЧАНИЕ №4 \"ВНУТРЕННИЙ ЦИКЛ: ИТЕРАТОР\" |br| Цикл for здесь "
"использует pairs(), см. :ref:`объяснение, что такое итераторы <box_index-"
"index_pairs>`. Во внутреннем цикле будет локальная переменная под "
"названием \"tuple\" (кортеж), которая содержит последний кортеж, "
"обнаруженный в ходе поиска по индексу."

#: ../doc/1.10/tutorials/lua_tutorials.rst:810
msgid ""
"NOTE #5 \"INNER LOOP: BREAK IF INDEX KEY IS TOO GREAT\" |br| The iterator"
" is GE (Greater or Equal), and we must be more specific: if the search "
"index key has N characters, then the leftmost N characters of the "
"result's index field must not be greater than the search index key. For "
"example, if the search index key is 'ABC', then 'ABCDE' is a potential "
"match, but 'ABD' is a signal that no more matches are possible."
msgstr ""
"ПРИМЕЧАНИЕ №5 \"ВНУТРЕННИЙ ЦИКЛ: ПРЕРЫВАНИЕ, ЕСЛИ КЛЮЧ ИНДЕКСА СЛИШКОМ "
"БОЛЬШОЙ\" |br| Используется итератор GE (Greater or Equal - больше или "
"равно), поэтому необходимо уточнить: если ключ поиска по индексу включает"
" в себя N символов, то крайние N символов слева от найденного поля "
"индекса не должны быть больше ключа поиска. Например, если ключом поиска "
"является  'ABC', то 'ABCDE' потенциально подходит, а 'ABD' означает, что "
"в дальнейшем совпадений не будет."

#: ../doc/1.10/tutorials/lua_tutorials.rst:819
msgid ""
"NOTE #6 \"INNER LOOP: BREAK AFTER EVERY 10 TUPLES -- MAYBE\" |br| This "
"chunk of code is for cooperative multitasking. The number 10 is "
"arbitrary, and usually a larger number would be okay. The simple rule "
"would be \"after checking 10 tuples, yield, and then resume the search "
"(that is, do the inner loop again) starting after the last value that was"
" found\". However, if the index is non-unique or if there is more than "
"one field in the index, then we might have duplicates -- for example "
"{\"ABC\",1}, {\"ABC\", 2}, {\"ABC\", 3}\" -- and it would be difficult to"
" decide which \"ABC\" tuple to resume with. Therefore, if the result's "
"index field is the same as the previous result's index field, there is no"
" break."
msgstr ""
"ПРИМЕЧАНИЕ №6 \"ВНУТРЕННИЙ ЦИКЛ: ПРЕРЫВАНИЕ ПОСЛЕ КАЖДЫХ ДЕСЯТИ КОРТЕЖЕЙ "
"-- ВОЗМОЖНО\" |br| Эта часть кода предназначена для кооперативной "
"многозадачности. Число 10 выбрано произвольно, и как правило, большее "
"число также подойдет. Простое правило гласит: \"после проверки 10 "
"кортежей передать управление, а затем возобновить поиск (то есть снова "
"выполнять внутренний цикл), начиная с последнего обнаруженного "
"значения\". Однако, если индекс не уникален, или в индексе более одного "
"поля, можно получить дублирующиеся результаты, например, {\"ABC\",1}, "
"{\"ABC\", 2}, {\"ABC\", 3}\" -- и будет трудно решить, с какого кортежа "
"\"ABC\" возобновлять поиск. Таким образом, если найденное поле индекса "
"совпадает с предыдущим найденным полем индекса, цикл не прерывается."

#: ../doc/1.10/tutorials/lua_tutorials.rst:832
msgid ""
"NOTE #7 \"INNER LOOP: ADD TO RESULT SET IF PATTERN MATCHES\" |br| Compare"
" the result's index field to the entire pattern. For example, suppose "
"that the caller passed pattern \"ABC.E\" and there is an indexed field "
"containing \"ABCDE\". Therefore the initial index search key is \"ABC\". "
"Therefore a tuple containing an indexed field with \"ABCDE\" will be "
"found by the iterator, because \"ABCDE\" > \"ABC\". In that case "
"string.match will return a value which is not nil. Therefore this tuple "
"can be added to the result set."
msgstr ""
"ПРИМЕЧАНИЕ №7 \"ВНУТРЕННИЙ ЦИКЛ: ДОБАВЛЕНИЕ В РЕЗУЛЬТАТ, ЕСЛИ ШАБЛОН "
"СОВПАДЕТ\" |br| Сравнение найденного поля индекса с шаблоном. Например, "
"предположим, что вызывающий клиент передает шаблон \"ABC.E\", и "
"существует поле индекса, содержащее \"ABCDE\". В таком случае, начальный "
"ключ поиска будет \"ABC\". Таким образом, кортеж, содержащий поле индекса"
" с \"ABCDE\" будет обнаружен итератором, поскольку \"ABCDE\" > \"ABC\". В"
" этом случае, string.match вернет значение, отличное от нулевого nil. В "
"итоге, этот кортеж можно добавить в результирующий набор данных."

#: ../doc/1.10/tutorials/lua_tutorials.rst:842
msgid ""
"NOTE #8 \"OUTER LOOP: BREAK, OR YIELD AND CONTINUE\" |br| There are three"
" conditions which will cause a break from the inner loop: (1) the for "
"loop ends naturally because there are no more index keys which are "
"greater than or equal to the index search key, (2) the index key is too "
"great as described in NOTE #5, (3) it is time for a yield as described in"
" NOTE #6. If condition (1) or condition (2) is true, then there is "
"nothing more to do, the outer loop ends too. If and only if condition (3)"
" is true, the outer loop must yield and then continue. If it does "
"continue, then the inner loop -- the iterator search -- will happen again"
" with a new value for the index search key."
msgstr ""
"ПРИМЕЧАНИЕ №8 \"ВНЕШНИЙ ЦИКЛ: ПРЕРЫВАНИЕ ИЛИ ПЕРЕДАЧА УПРАВЛЕНИЯ И "
"ПРОДОЛЖЕНИЕ\" |br| Существуют три условия, которые вызовут прерывание из "
"внутреннего цикла: (1) цикл for заканчивается закономерно, потому что "
"отсутствуют ключи индекса, которые больше или равны ключу поиска по "
"индексу, (2) ключ индекса слишком большой, как описано в ПРИМЕЧАНИИ №5, "
"(3) пора передавать управление, как описано в ПРИМЕЧАНИИ №6. Если условие"
" (1) или условие (2) соблюдается, другие действия не требуются, и внешний"
" цикл также заканчивается. Только в том случае, если справедливо условие "
"(3), внешний цикл должен передать управление, а затем продолжить "
"выполнение. Если он продолжит выполнение, то внутренний цикл -- поиск с "
"итератором -- будет выполняться снова с новым значением для ключа поиска "
"по индексу."

#: ../doc/1.10/tutorials/lua_tutorials.rst:855
msgid "EXAMPLE:"
msgstr "ПРИМЕР:"

#: ../doc/1.10/tutorials/lua_tutorials.rst:857
msgid ""
"Start Tarantool, cut and paste the code for function "
"``indexed_pattern_search()``, and try the following:"
msgstr ""
"Запустите Tarantool, скопируйте и вставьте код для функции "
"``indexed_pattern_search()`` и попробуйте выполнить следующее:"

#: ../doc/1.10/tutorials/lua_tutorials.rst:863
msgid ""
"box.space.t:drop()\n"
"box.schema.space.create('t')\n"
"box.space.t:create_index('primary',{})\n"
"box.space.t:create_index('secondary',{unique=false,parts={2,'string',3,'string'}})"
"\n"
"box.space.t:insert{1,'A','a'}\n"
"box.space.t:insert{2,'AB',''}\n"
"box.space.t:insert{3,'ABC','a'}\n"
"box.space.t:insert{4,'ABCD',''}\n"
"box.space.t:insert{5,'ABCDE','a'}\n"
"box.space.t:insert{6,'ABCDE',''}\n"
"box.space.t:insert{7,'ABCDEF','a'}\n"
"box.space.t:insert{8,'ABCDF',''}\n"
"indexed_pattern_search(\"t\", 2, \"ABC.E.\")"
msgstr ""
"box.space.t:drop()\n"
"box.schema.space.create('t')\n"
"box.space.t:create_index('primary',{})\n"
"box.space.t:create_index('secondary',{unique=false,parts={2,'string',3,'string'}})"
"\n"
"box.space.t:insert{1,'A','a'}\n"
"box.space.t:insert{2,'AB',''}\n"
"box.space.t:insert{3,'ABC','a'}\n"
"box.space.t:insert{4,'ABCD',''}\n"
"box.space.t:insert{5,'ABCDE','a'}\n"
"box.space.t:insert{6,'ABCDE',''}\n"
"box.space.t:insert{7,'ABCDEF','a'}\n"
"box.space.t:insert{8,'ABCDF',''}\n"
"indexed_pattern_search(\"t\", 2, \"ABC.E.\")"

#: ../doc/1.10/tutorials/lua_tutorials.rst:879
msgid ""
"tarantool> indexed_pattern_search(\"t\", 2, \"ABC.E.\")\n"
"---\n"
"- - [7, 'ABCDEF', 'a']\n"
"..."
msgstr ""
"tarantool> indexed_pattern_search(\"t\", 2, \"ABC.E.\")\n"
"---\n"
"- - [7, 'ABCDEF', 'a']\n"
"..."

#: ../doc/1.10/whats_new.rst:39
msgid "Release Notes"
msgstr "Примечания к версиям"

#: ../doc/1.10/whats_new.rst:41
msgid ""
"The Release Notes are summaries of significant changes introduced in "
"Tarantool :ref:`1.10.3 <whats_new_1103>`, :ref:`1.10.2 <whats_new_1102>`,"
" :ref:`1.9.0 <whats_new_190>`, :ref:`1.7.6 <whats_new_176>`, :ref:`1.7.5 "
"<whats_new_175>`, :ref:`1.7.4 <whats_new_174>`, :ref:`1.7.3 "
"<whats_new_173>`, :ref:`1.7.2 <whats_new_172>`, :ref:`1.7.1 "
"<whats_new_171>`, :ref:`1.6.9 <whats_new_169>`, :ref:`1.6.8 "
"<whats_new_168>`, and :ref:`1.6.6 <whats_new_166>`."
msgstr ""
"Примечания к версиям содержат краткое описание значимых изменений в "
"следующих версиях Tarantool'а: :ref:`1.10.3 <whats_new_1103>`, "
":ref:`1.10.2 <whats_new_1102>`, :ref:`1.9.0 <whats_new_190>`, :ref:`1.7.6"
" <whats_new_176>`, :ref:`1.7.5 <whats_new_175>`, :ref:`1.7.4 "
"<whats_new_174>`, :ref:`1.7.3 <whats_new_173>`, :ref:`1.7.2 "
"<whats_new_172>`, :ref:`1.7.1 <whats_new_171>`, :ref:`1.6.9 "
"<whats_new_169>`, :ref:`1.6.8 <whats_new_168>`, and :ref:`1.6.6 "
"<whats_new_166>`."

#: ../doc/1.10/whats_new.rst:55
msgid ""
"For smaller feature changes and bug fixes, see closed `milestones "
"<https://github.com/tarantool/tarantool/milestones?state=closed>`_ at "
"GitHub."
msgstr ""
"Более мелкие изменения и исправления дефектов указаны в отчетах о "
"`выпущенных стабильных релизах (milestone = closed) "
"<https://github.com/tarantool/tarantool/milestones?state=closed>`_ на "
"GitHub."

#: ../doc/1.10/whats_new.rst:63
msgid "Version 1.10"
msgstr "Версия 1.10"

#: ../doc/1.10/whats_new.rst:67
msgid "**Release 1.10.3**"
msgstr "**Версия 1.10.3**"

#: ../doc/1.10/whats_new.rst:69
msgid "Release type: stable (lts). Release date: 2019-04-01.  Tag: 1-10-3."
msgstr "Тип версии: стабильная (lts). Дата выхода: 2019-04-01.  Тег: 1-10-3."

#: ../doc/1.10/whats_new.rst:71
msgid "Announcement: https://github.com/tarantool/tarantool/releases/tag/1.10.3."
msgstr "Сообщение: https://github.com/tarantool/tarantool/releases/tag/1.10.3."

#: ../doc/1.10/whats_new.rst:75
msgid ""
"1.10.3 is the next :ref:`stable (lts) <release-policy>` release in the "
"1.10 series. The label 'stable' means we have had systems running in "
"production without known crashes, bad results or other showstopper bugs "
"for quite a while now."
msgstr ""
"1.10.3 представляет собой очередную :ref:`стабильную (lts) <release-"
"policy>` версию в серии 1.10. Пометка \"стабильная\" означает, что "
"некоторые системы в течение определенного времени успешно отработали в "
"производственной среде без известных сбоев, ненадежных результатов и "
"прочих неисправностей."

#: ../doc/1.10/whats_new.rst:79
msgid ""
"This release resolves 69 issues since 1.10.2. There may be bugs in less "
"common areas, please feel free to file an issue at GitHub. Compatibility"
msgstr ""
"Эта версия содержит 69 исправлений по сравнению с версией 1.10.2. "
"Возможны ошибки в малоиспользуемых областях; обратитесь на GitHub, чтобы "
"сообщить об ошибке. Совместимость"

#: ../doc/1.10/whats_new.rst:83
msgid ""
"Tarantool 1.10.x is backward compatible with Tarantool 1.9.x in binary "
"data layout, client-server protocol and replication protocol. Please "
":ref:`upgrade <admin-upgrades>` using the ``box.schema.upgrade()`` "
"procedure to unlock all the new features of the 1.10.x series when "
"migrating from 1.9 version."
msgstr ""
"Tarantool 1.10.x обратно совместим с Tarantool 1.9.x в том, что касается "
"структуры бинарных данных, клиент-серверного протокола и протокола "
"репликации. Чтобф воспользоваться новыми функциями серии 1.10.x, "
":ref:`обновите <admin-upgrades>` версию 1.9 с помощью процедуры "
"``box.schema.upgrade()``."

#: ../doc/1.10/whats_new.rst:86
msgid "Functionality added or changed"
msgstr "Изменения или добавления функциональности"

#: ../doc/1.10/whats_new.rst:88
msgid ""
"(Engines) Randomize vinyl index compaction Issue `3944 "
"<https://github.com/tarantool/tarantool/issues/3944>`_."
msgstr ""
"(Движки) Слияние индексов в vinyl'е носит случайный характер. Проблема "
"`3944 <https://github.com/tarantool/tarantool/issues/3944>`_."

#: ../doc/1.10/whats_new.rst:90
msgid ""
"(Engines) Throttle tx thread if compaction doesn't keep up with dumps "
"Issue `3721 <https://github.com/tarantool/tarantool/issues/3721>`_."
msgstr ""
"(Движки) Регулировка потока tx, если слияние не успевает за созданием "
"дампов. Проблема `3721 "
"<https://github.com/tarantool/tarantool/issues/3721>`_."

#: ../doc/1.10/whats_new.rst:92
msgid ""
"(Engines) Do not apply run_count_per_level to the last level Issue `3657 "
"<https://github.com/tarantool/tarantool/issues/3657>`_."
msgstr ""
"(Движки) Отмена run_count_per_level для последнего уровня. Проблема `3657"
" <https://github.com/tarantool/tarantool/issues/3657>`_."

#: ../doc/1.10/whats_new.rst:94
msgid ""
"(Server) Report the number of active iproto connections Issue `3905 "
"<https://github.com/tarantool/tarantool/issues/3905>`_."
msgstr ""
"(Сервер) Отчет о количестве активных соединений iproto. Проблема `3905 "
"<https://github.com/tarantool/tarantool/issues/3905>`_."

#: ../doc/1.10/whats_new.rst:96
msgid ""
"(Replication) Never keep a dead replica around if running out of disk "
"space Issue `3397 <https://github.com/tarantool/tarantool/issues/3397>`_."
msgstr ""
"(Репликация) Удаление мертвой реплики, когда не хватает свободного места "
"на диске. Проблема `3397 "
"<https://github.com/tarantool/tarantool/issues/3397>`_."

#: ../doc/1.10/whats_new.rst:98
msgid ""
"(Replication) Report join progress to the replica log Issue `3165 "
"<https://github.com/tarantool/tarantool/issues/3165>`_."
msgstr ""
"(Репликация) Отчет о состоянии присоединения в журнале реплики. Проблема "
"`3165 <https://github.com/tarantool/tarantool/issues/3165>`_."

#: ../doc/1.10/whats_new.rst:100
msgid ""
"(Lua) Expose snapshot status in box.info.gc() Issue `3935 "
"<https://github.com/tarantool/tarantool/issues/3935>`_."
msgstr ""
"(Lua) Отображение статуса снимка в box.info.gc(). Проблема `3935 "
"<https://github.com/tarantool/tarantool/issues/3935>`_."

#: ../doc/1.10/whats_new.rst:102
msgid ""
"(Lua) Show names of Lua functions in backtraces in fiber.info() Issue "
"`3538 <https://github.com/tarantool/tarantool/issues/3538>`_."
msgstr ""
"(Lua) Отображение имен Lua-функций в обратной трассировке fiber.info(). "
"Проблема `3538 <https://github.com/tarantool/tarantool/issues/3538>`_."

#: ../doc/1.10/whats_new.rst:104
msgid ""
"(Lua) Check if transaction opened Issue `3518 "
"<https://github.com/tarantool/tarantool/issues/3518>`_."
msgstr ""
"(Lua) Проверка наличия открытой транзакции. Проблема `3518 "
"<https://github.com/tarantool/tarantool/issues/3518>`_."

#: ../doc/1.10/whats_new.rst:107
msgid "Bugs fixed"
msgstr "Исправленные ошибки"

#: ../doc/1.10/whats_new.rst:109
msgid ""
"(Engines) Tarantool crashes if DML races with DDL Issue `3420 "
"<https://github.com/tarantool/tarantool/issues/3420>`_."
msgstr ""
"(Движки) Сбой Tarantool'а при гонке потоков DML и DDL. Проблема `3420 "
"<https://github.com/tarantool/tarantool/issues/3420>`_."

#: ../doc/1.10/whats_new.rst:111
msgid ""
"(Engines) Recovery error if DDL is aborted Issue `4066 "
"<https://github.com/tarantool/tarantool/issues/4066>`_."
msgstr ""
"(Движки) Ошибка восстановления при прерывании работы DDL. Проблема `4066 "
"<https://github.com/tarantool/tarantool/issues/4066>`_."

#: ../doc/1.10/whats_new.rst:113
msgid ""
"(Engines) Tarantool could commit in the read-only mode Issue `4016 "
"<https://github.com/tarantool/tarantool/issues/4016>`_."
msgstr ""
"(Движки) Коммиты Tarantool'а в режиме только для чтения. Проблема `4016 "
"<https://github.com/tarantool/tarantool/issues/4016>`_."

#: ../doc/1.10/whats_new.rst:115
msgid ""
"(Engines) Vinyl iterator crashes if used throughout DDL Issue `4000 "
"<https://github.com/tarantool/tarantool/issues/4000>`_."
msgstr ""
"(Движки) Сбой итератора vinyl'а при использовании DDL. Проблема `4000 "
"<https://github.com/tarantool/tarantool/issues/4000>`_."

#: ../doc/1.10/whats_new.rst:117
msgid ""
"(Engines) Vinyl doesn't exit until dump/compaction is complete Issue "
"`3949 <https://github.com/tarantool/tarantool/issues/3949>`_."
msgstr ""
"(Движки) Vinyl не завершает работу, пока не закончится создание дампа или"
" слияние. Проблема `3949 "
"<https://github.com/tarantool/tarantool/issues/3949>`_."

#: ../doc/1.10/whats_new.rst:119
msgid ""
"(Engines) After re-creating secondary index no data is visible Issue "
"`3903 <https://github.com/tarantool/tarantool/issues/3903>`_."
msgstr ""
"(Движки) После повторного создания вторичного индекса не видно данных. "
"Проблема `3903 <https://github.com/tarantool/tarantool/issues/3903>`_."

#: ../doc/1.10/whats_new.rst:121
msgid ""
"(Engines) box.info.memory().tx underflow Issue `3897 "
"<https://github.com/tarantool/tarantool/issues/3897>`_."
msgstr ""
"(Движки) Незагруженность box.info.memory().tx. Проблема `3897 "
"<https://github.com/tarantool/tarantool/issues/3897>`_."

#: ../doc/1.10/whats_new.rst:123
msgid ""
"(Engines) Vinyl stalls on intensive random insertion Issue `3603 "
"<https://github.com/tarantool/tarantool/issues/3603>`_."
msgstr ""
"(Движки) Vinyl замедляет скорость при интенсивных случайных вставках. "
"Проблема `3603 <https://github.com/tarantool/tarantool/issues/3603>`_."

#: ../doc/1.10/whats_new.rst:125
msgid ""
"(Server) Newer version of libcurl explodes fiber stack Issue `3569 "
"<https://github.com/tarantool/tarantool/issues/3569>`_."
msgstr ""
"(Сервер) Новая версия libcurl вызывает переполнение стека файбера. "
"Проблема `3569 <https://github.com/tarantool/tarantool/issues/3569>`_."

#: ../doc/1.10/whats_new.rst:127
msgid ""
"(Server) SIGHUP crashes tarantool Issue `4063 "
"<https://github.com/tarantool/tarantool/issues/4063>`_."
msgstr ""
"(Сервер) SIGHUP вызывает завершение работы Tarantool'а. Проблема `4063 "
"<https://github.com/tarantool/tarantool/issues/4063>`_."

#: ../doc/1.10/whats_new.rst:129
msgid ""
"(Server) checkpoint_daemon.lua:49: bad argument #2 to 'format' Issue "
"`4030 <https://github.com/tarantool/tarantool/issues/4030>`_."
msgstr ""
"(Сервер) checkpoint_daemon.lua:49: неправильный аргумент №2 для 'format'."
" Проблема `4030 <https://github.com/tarantool/tarantool/issues/4030>`_."

#: ../doc/1.10/whats_new.rst:131
msgid ""
"(Server) fiber:name() show only part of name Issue `4011 "
"<https://github.com/tarantool/tarantool/issues/4011>`_."
msgstr ""
"(Сервер) fiber:name() показывает только часть имени. Проблема `4011 "
"<https://github.com/tarantool/tarantool/issues/4011>`_."

#: ../doc/1.10/whats_new.rst:133
msgid ""
"(Server) Second hot standby switch may fail Issue `3967 "
"<https://github.com/tarantool/tarantool/issues/3967>`_."
msgstr ""
"(Сервер) Второе переключение режима горячего резервирования hot standby "
"может не сработать. Проблема `3967 "
"<https://github.com/tarantool/tarantool/issues/3967>`_."

#: ../doc/1.10/whats_new.rst:135
msgid ""
"(Server) Updating box.cfg.readahead doesn't affect existing connections "
"Issue `3958 <https://github.com/tarantool/tarantool/issues/3958>`_."
msgstr ""
"(Сервер) Обновление box.cfg.readahead не влияет на текущие соединения. "
"Проблема `3958 <https://github.com/tarantool/tarantool/issues/3958>`_."

#: ../doc/1.10/whats_new.rst:137
msgid ""
"(Server) fiber.join() blocks in 'suspended' if fiber has cancelled Issue "
"`3948 <https://github.com/tarantool/tarantool/issues/3948>`_."
msgstr ""
"(Сервер) fiber.join() остается заблокирован в статусе 'suspended', если "
"файбер был отменен. Проблема `3948 "
"<https://github.com/tarantool/tarantool/issues/3948>`_."

#: ../doc/1.10/whats_new.rst:139
msgid ""
"(Server) Tarantool can be crashed by sending gibberish to a binary socket"
" Issue `3900 <https://github.com/tarantool/tarantool/issues/3900>`_."
msgstr ""
"(Сервер) Tarantool может завершить работу с ошибкой при отправке ненужных"
" данных в бинарный сокет. Проблема `3900 "
"<https://github.com/tarantool/tarantool/issues/3900>`_."

#: ../doc/1.10/whats_new.rst:141
msgid ""
"(Server) Stored procedure to produce push-messages never breaks on client"
" disconnect Issue `3859 "
"<https://github.com/tarantool/tarantool/issues/3559>`_."
msgstr ""
"(Сервер) Хранимая процедура для создания push-сообщений не прерывается "
"при отключении клиента. Проблема `3859 "
"<https://github.com/tarantool/tarantool/issues/3559>`_."

#: ../doc/1.10/whats_new.rst:143
msgid ""
"(Server) Tarantool crashed in lj_vm_return Issue `3840 "
"<https://github.com/tarantool/tarantool/issues/3840>`_."
msgstr ""
"(Сервер) Tarantool завершил работу с ошибкой в lj_vm_return. Проблема "
"`3840 <https://github.com/tarantool/tarantool/issues/3840>`_."

#: ../doc/1.10/whats_new.rst:145
msgid ""
"(Server) Fiber executing box.cfg() may process messages from iproto Issue"
" `3779 <https://github.com/tarantool/tarantool/issues/3779>`_."
msgstr ""
"(Сервер) Файбер, выполняющий box.cfg(), может обрабатывать сообщения из "
"iproto. Проблема `3779 "
"<https://github.com/tarantool/tarantool/issues/3779>`_."

#: ../doc/1.10/whats_new.rst:147
msgid ""
"(Server) Possible regression on nosqlbench Issue `3747 "
"<https://github.com/tarantool/tarantool/issues/3747>`_."
msgstr ""
"(Сервер) Возможная регрессия на nosqlbench. Проблема `3747 "
"<https://github.com/tarantool/tarantool/issues/3747>`_."

#: ../doc/1.10/whats_new.rst:149
msgid ""
"(Server) Assertion after improper index creation Issue `3744 "
"<https://github.com/tarantool/tarantool/issues/3744>`_."
msgstr ""
"(Сервер) Утверждение после неправильного создания индекса. Проблема `3744"
" <https://github.com/tarantool/tarantool/issues/3744>`_."

#: ../doc/1.10/whats_new.rst:151
msgid ""
"(Server) Tarantool crashes on vshard startup (lj_gc_step) Issue `3725 "
"<https://github.com/tarantool/tarantool/issues/3725>`_."
msgstr ""
"(Сервер) Сбой Tarantool'а при запуске поvshard (lj_gc_step). Проблема "
"`3725 <https://github.com/tarantool/tarantool/issues/3725>`_."

#: ../doc/1.10/whats_new.rst:153
msgid ""
"(Server) Do not restart replication on box.cfg if the configuration "
"didn't change Issue `3711 "
"<https://github.com/tarantool/tarantool/issues/3711>`_."
msgstr ""
"(Сервер) Репликация не запускается повторно на box.cfg, если конфигурация"
" не изменилась. Проблема `3711 "
"<https://github.com/tarantool/tarantool/issues/3711>`_."

#: ../doc/1.10/whats_new.rst:155
msgid ""
"(Replication) Applier times out too fast when reading large tuples Issue "
"`4042 <https://github.com/tarantool/tarantool/issues/4042>`_."
msgstr ""
"(Репликация) Время работы наложения (applier) сокращается при чтении "
"кортежей большого размера. Проблема `4042 "
"<https://github.com/tarantool/tarantool/issues/4042>`_."

#: ../doc/1.10/whats_new.rst:157
msgid ""
"(Replication) Vinyl replica join fails Issue `3968 "
"<https://github.com/tarantool/tarantool/issues/3968>`_."
msgstr ""
"(Репликации) Сбой присоединения реплики Vinyl. Проблема `3968 "
"<https://github.com/tarantool/tarantool/issues/3968>`_."

#: ../doc/1.10/whats_new.rst:159
msgid ""
"(Replication) Error during replication Issue `3910 "
"<https://github.com/tarantool/tarantool/issues/3910>`_."
msgstr ""
"(Репликация) Ошибка во время репликации. Проблема `3910 "
"<https://github.com/tarantool/tarantool/issues/3910>`_."

#: ../doc/1.10/whats_new.rst:161
msgid ""
"(Replication) Downstream status doesn't show up in replication.info "
"unless the channel is broken Issue `3904 "
"<https://github.com/tarantool/tarantool/issues/3904>`_."
msgstr ""
"(Репликация) Статус downstream не отображается в replication.info, если "
"канал не сломан. Проблема `3904 "
"<https://github.com/tarantool/tarantool/issues/3904>`_."

#: ../doc/1.10/whats_new.rst:163
msgid ""
"(Replication) replication fails: tx checksum mismatch Issue `3993 "
"<https://github.com/tarantool/tarantool/issues/3883>`_."
msgstr ""
"(Репликация) Сбой репликации: несовпадение контрольной суммы tx. Проблема"
" `3993 <https://github.com/tarantool/tarantool/issues/3883>`_."

#: ../doc/1.10/whats_new.rst:165
msgid ""
"(Replication) Rebootstrap crashes if master has replica's rows Issue "
"`3740 <https://github.com/tarantool/tarantool/issues/3740>`_."
msgstr ""
"(Репликация) Потворная настройка не производится, если на мастере есть "
"строки из реплики. Проблема `3740 "
"<https://github.com/tarantool/tarantool/issues/3740>`_."

#: ../doc/1.10/whats_new.rst:167
msgid ""
"(Replication) After restart tuples revert back to their old state which "
"was before replica sync Issue `3722 "
"<https://github.com/tarantool/tarantool/issues/3722>`_."
msgstr ""
"(Репликация) После перезапуска состояние кортежей откатывается на "
"дорепликационное состояние. Проблема `3722 "
"<https://github.com/tarantool/tarantool/issues/3722>`_."

#: ../doc/1.10/whats_new.rst:169
msgid ""
"(Replication) Add vclock for safer hot standby switch Issue `3002 "
"<https://github.com/tarantool/tarantool/issues/3002>`_."
msgstr ""
"(Репликации) Добавление vclock для более безопасного переключения в режим"
" горячего резервирования hot standby. Проблема `3002 "
"<https://github.com/tarantool/tarantool/issues/3002>`_."

#: ../doc/1.10/whats_new.rst:171
msgid ""
"(Replication) Master row is skipped forever in case of wal write failure "
"Issue `2283 <https://github.com/tarantool/tarantool/issues/2283>`_."
msgstr ""
"(Репликации) Строка из мастера исчезает при сбое записи в журнал "
"упреждающей записи. Проблема `2283 "
"<https://github.com/tarantool/tarantool/issues/2283>`_."

#: ../doc/1.10/whats_new.rst:173
msgid ""
"(Lua) space:frommap():tomap() conversion fail Issue `4045 "
"<https://github.com/tarantool/tarantool/issues/4045>`_."
msgstr ""
"(Lua) Сбой преобразования space:frommap():tomap(). Проблема `4045 "
"<https://github.com/tarantool/tarantool/issues/4045>`_."

#: ../doc/1.10/whats_new.rst:175
msgid ""
"(Lua) Non-informative message when trying to read a negative count of "
"bytes from socket Issue `3979 "
"<https://github.com/tarantool/tarantool/issues/3979>`_."
msgstr ""
"(Lua) Неинформативное сообщение при попытке прочитать отрицательное "
"значение счетчика байтов из сокета. Проблема `3979 "
"<https://github.com/tarantool/tarantool/issues/3979>`_."

#: ../doc/1.10/whats_new.rst:177
msgid ""
"(Lua) space:frommap raise \"tuple field does not match...\" even for "
"nullable field Issue `3883 "
"<https://github.com/tarantool/tarantool/issues/3883>`_."
msgstr ""
"(Lua) space:frommap вызывает ошибку несовпадения кортежей (\"tuple field "
"does not match...\") даже для нулевого поля. Проблема `3883 "
"<https://github.com/tarantool/tarantool/issues/3883>`_."

#: ../doc/1.10/whats_new.rst:179
msgid ""
"(Lua) Tarantool crashes on net.box.call after some uptime with vshard "
"internal fiber Issue `3751 "
"<https://github.com/tarantool/tarantool/issues/3751>`_."
msgstr ""
"(Lua) Завершение работы Tarantool'а с ошибкой на net.box.call после "
"нормальной работы с внутренним файбером vshard. Проблема `3751 "
"<https://github.com/tarantool/tarantool/issues/3751>`_."

#: ../doc/1.10/whats_new.rst:181
msgid ""
"(Lua) Heap use after free in lbox_error Issue `1955 "
"<https://github.com/tarantool/tarantool/issues/1955>`_."
msgstr ""
"(Lua) Использование динамической памяти в lbox_error. Проблема `1955 "
"<https://github.com/tarantool/tarantool/issues/1955>`_."

#: ../doc/1.10/whats_new.rst:183
msgid ""
"(Misc) http.client doesn't honour 'connection: keep-alive' Issue `3955 "
"<https://github.com/tarantool/tarantool/issues/3955>`_."
msgstr ""
"(Разное) http.client не подтверждает 'connection: keep-alive'. Проблема "
"`3955 <https://github.com/tarantool/tarantool/issues/3955>`_."

#: ../doc/1.10/whats_new.rst:185
msgid ""
"(Misc) net.box wait_connected is broken Issue `3856 "
"<https://github.com/tarantool/tarantool/issues/3856>`_."
msgstr ""
"(Разное) Сломан wait_connected в net.box. Проблема `3856 "
"<https://github.com/tarantool/tarantool/issues/3856>`_."

#: ../doc/1.10/whats_new.rst:187
msgid ""
"(Misc) Mac build fails on Mojave Issue `3797 "
"<https://github.com/tarantool/tarantool/issues/3797>`_."
msgstr ""
"(Разное) Сборка Mac завершается с ошибкой в Mojave. Проблема `3797 "
"<https://github.com/tarantool/tarantool/issues/3797>`_."

#: ../doc/1.10/whats_new.rst:189
msgid ""
"(Misc) FreeBSD build error: no SSL support Issue `3750 "
"<https://github.com/tarantool/tarantool/issues/3750>`_."
msgstr ""
"(Разное) Ошибка сборки FreeBSD: отсутствует поддержка SSL. Проблема `3750"
" <https://github.com/tarantool/tarantool/issues/3750>`_."

#: ../doc/1.10/whats_new.rst:191
msgid ""
"(Misc) 'http.client' sets invalid (?) reason Issue `3681 "
"<https://github.com/tarantool/tarantool/issues/3681>`_."
msgstr ""
"(Разное) 'http.client' выдает неправильную (?) причину. Проблема `3681 "
"<https://github.com/tarantool/tarantool/issues/3681>`_."

#: ../doc/1.10/whats_new.rst:193
msgid ""
"(Misc) Http client silently modifies headers when value is not a "
"\"string\" or a \"number\" Issue `3679 "
"<https://github.com/tarantool/tarantool/issues/3679>`_."
msgstr ""
"(Разное) Http client молча изменяет заголовки, когда значение -- не "
"\"строка\" и не \"число\". Проблема `3679 "
"<https://github.com/tarantool/tarantool/issues/3679>`_."

#: ../doc/1.10/whats_new.rst:195
msgid ""
"(Misc) yaml.encode uses multiline format for 'false' and 'true' Issue "
"`3662 <https://github.com/tarantool/tarantool/issues/3662>`_."
msgstr ""
"(Разное) yaml.encode использует многострочный формат для 'false' и "
"'true'. Проблема `3662 "
"<https://github.com/tarantool/tarantool/issues/3662>`_."

#: ../doc/1.10/whats_new.rst:197
msgid ""
"(Misc) yaml.encode encodes 'null' incorrectly Issue `3583 "
"<https://github.com/tarantool/tarantool/issues/3583>`_."
msgstr ""
"(Разное) yaml.encode неправильно кодирует 'null'. Проблема `3583 "
"<https://github.com/tarantool/tarantool/issues/3583>`_."

#: ../doc/1.10/whats_new.rst:199
msgid ""
"(Misc) Error object message is empty Issue `3604 "
"<https://github.com/tarantool/tarantool/issues/3604>`_."
msgstr ""
"(Разное) Пустое сообщение объекта ошибки. Проблема `3604 "
"<https://github.com/tarantool/tarantool/issues/3604>`_."

#: ../doc/1.10/whats_new.rst:201
msgid ""
"(Misc) Log can be flooded by warning messages Issue `2218 "
"<https://github.com/tarantool/tarantool/issues/2218>`_."
msgstr ""
"(Разное) Журнал переполняется предупреждениями. Проблема `2218 "
"<https://github.com/tarantool/tarantool/issues/2218>`_."

#: ../doc/1.10/whats_new.rst:204
msgid ""
"Deprecations: the console=true option for :ref:`net.box.new <net_box-"
"new>` is deprecated."
msgstr ""
"Устаревшие функции: опция console=true для :ref:`net.box.new <net_box-"
"new>` объявлена устаревшей."

#: ../doc/1.10/whats_new.rst:208
msgid "**Release 1.10.2**"
msgstr "**Версия 1.10.2**"

#: ../doc/1.10/whats_new.rst:210
msgid "Release type: stable (lts). Release date: 2018-10-13.  Tag: 1-10-2."
msgstr "Тип версии: стабильная (lts). Дата выхода: 2018-10-13.  Тег: 1-10-2."

#: ../doc/1.10/whats_new.rst:212
msgid "Announcement: https://github.com/tarantool/tarantool/releases/tag/1.10.2."
msgstr "Сообщение: https://github.com/tarantool/tarantool/releases/tag/1.10.2."

#: ../doc/1.10/whats_new.rst:214
msgid ""
"This is the first :ref:`stable (lts) <release-policy>` release in the "
"1.10 series. Also, Tarantool 1.10.2 is a major release that deprecates "
"Tarantool 1.9.2. It resolves 95 issues since 1.9.2."
msgstr ""
"Данная сборка представляет собой первую :ref:`стабильную (lts) <release-"
"policy>` версию в серии 1.10. Кроме того, Tarantool 1.10.2 представляет "
"собой мажорную версию, версия Tarantool 1.9.2 объявлена устаревшей. Это "
"обновление содержит 95 исправлений по сравнению с версией 1.9.2."

#: ../doc/1.10/whats_new.rst:219
msgid ""
"Tarantool 1.10.x is backward compatible with Tarantool 1.9.x in binary "
"data layout, client-server protocol and replication protocol. You can "
":ref:`upgrade <admin-upgrades>` using the ``box.schema.upgrade()`` "
"procedure."
msgstr ""
"Tarantool 1.10.x обратно совместим с Tarantool 1.9.x в том, что касается "
"структуры бинарных данных, клиент-серверного протокола и протокола "
"репликации. :ref:`Обновление <admin-upgrades>` можно произвести с помощью"
" процедуры ``box.schema.upgrade()``."

#: ../doc/1.10/whats_new.rst:224
msgid ""
"The goal of this release is to significantly increase ``vinyl`` stability"
" and introduce automatic rebootstrap of a Tarantool replica set."
msgstr ""
"Цель данного релиза -- значительно повысить стабильность ``vinyl'а`` и "
"реализовать автоматическую повторную настройку набора реплик в "
"Tarantool'е."

#: ../doc/1.10/whats_new.rst:227 ../doc/1.10/whats_new.rst:322
#: ../doc/1.10/whats_new.rst:475 ../doc/1.10/whats_new.rst:557
#: ../doc/1.10/whats_new.rst:751 ../doc/1.10/whats_new.rst:907
#: ../doc/1.10/whats_new.rst:967 ../doc/1.10/whats_new.rst:1086
#: ../doc/1.10/whats_new.rst:1146 ../doc/1.10/whats_new.rst:1208
#: ../doc/1.10/whats_new.rst:1306 ../doc/1.10/whats_new.rst:1346
msgid "Functionality added or changed:"
msgstr "Изменения или добавления функциональности:"

#: ../doc/1.10/whats_new.rst:229
msgid ""
"(Engines) support ALTER for non-empty vinyl spaces. Issue `1653 "
"<https://github.com/tarantool/tarantool/issues/1653>`_."
msgstr ""
"(Движки) поддержка изменения ALTER непустых спейсов в vinyl'е. Проблема "
"`1653 <https://github.com/tarantool/tarantool/issues/1653>`_."

#: ../doc/1.10/whats_new.rst:231
msgid ""
"(Engines) tuples stored in the vinyl cache are not shared among the "
"indexes of the same space. Issue `3478 "
"<https://github.com/tarantool/tarantool/issues/3478>`_."
msgstr ""
"(Движки) кортежи, которые хранятся в кэше vinyl'а, не учитываются в "
"индексах того же спейса. Проблема `3478 "
"<https://github.com/tarantool/tarantool/issues/3478>`_."

#: ../doc/1.10/whats_new.rst:234
msgid ""
"(Engines) keep a stack of UPSERTS in ``vy_read_iterator``. Issue `1833 "
"<https://github.com/tarantool/tarantool/issues/1833>`_."
msgstr ""
"(Движки) хранение стека операций обновления и вставки UPSERT в "
"``vy_read_iterator``. Проблема `1833 "
"<https://github.com/tarantool/tarantool/issues/1833>`_."

#: ../doc/1.10/whats_new.rst:236
msgid ""
"(Engines) ``box.ctl.reset_stat()``, a function to reset vinyl statistics."
" Issue `3198 <https://github.com/tarantool/tarantool/issues/3198>`_."
msgstr ""
"(Движки) ``box.ctl.reset_stat()``, функция сброса статистики в vinyl'е. "
"Проблема `3198 <https://github.com/tarantool/tarantool/issues/3198>`_."

#: ../doc/1.10/whats_new.rst:239
msgid ""
"(Server) :ref:`configurable syslog destination <cfg_logging-log>`. Issue "
"`3487 <https://github.com/tarantool/tarantool/issues/3487>`_."
msgstr ""
"(Сервер) :ref:`настройка места назначения syslog <cfg_logging-log>`. "
"Проблема `3487 <https://github.com/tarantool/tarantool/issues/3487>`_."

#: ../doc/1.10/whats_new.rst:241
msgid ""
"(Server) allow different nullability in indexes and format. Issue `3430 "
"<https://github.com/tarantool/tarantool/issues/3430>`_."
msgstr ""
"(Сервер) допустимость неопределенного значения разного вида в индексах и "
"форматах. Проблема `3430 "
"<https://github.com/tarantool/tarantool/issues/3430>`_."

#: ../doc/1.10/whats_new.rst:243
msgid ""
"(Server) allow to :ref:`back up any checkpoint <admin-backups-"
"backup_start>`, not just the last one. Issue `3410 "
"<https://github.com/tarantool/tarantool/issues/3410>`_."
msgstr ""
"(Сервер) допустимость :ref:`резервного копирования любой контрольной "
"точки <admin-backups-backup_start>`, а не только последней. Проблема "
"`3410 <https://github.com/tarantool/tarantool/issues/3410>`_."

#: ../doc/1.10/whats_new.rst:247
msgid ""
"(Server) a way to detect that a Tarantool process was started / restarted"
" by ``tarantoolctl`` (:ref:`TARANTOOLCTL and TARANTOOL_RESTARTED "
"<tarantoolctl-instance_management>` env vars). Issues `3384 "
"<https://github.com/tarantool/tarantool/issues/3384>`_, `3215 "
"<https://github.com/tarantool/tarantool/issues/3215>`_."
msgstr ""
"(Сервер) метод, чтобы определить был ли запуск или перезапуск процесса "
"Tarantool'а осуществлен с помощью ``tarantoolctl`` (переменные окружения "
":ref:`TARANTOOLCTL и TARANTOOL_RESTARTED <tarantoolctl-"
"instance_management>`). Проблемы `3384 "
"<https://github.com/tarantool/tarantool/issues/3384>`_, `3215 "
"<https://github.com/tarantool/tarantool/issues/3215>`_."

#: ../doc/1.10/whats_new.rst:253
msgid ""
"(Server) :ref:`net_msg_max <cfg_networking-net_msg_max>` configuration "
"parameter to restrict the number of allocated fibers. Issue `3320 "
"<https://github.com/tarantool/tarantool/issues/3320>`_."
msgstr ""
"(Сервер) конфигурационный параметр :ref:`net_msg_max <cfg_networking-"
"net_msg_max>` ограничивает число выделенных файберов. Проблема `3320 "
"<https://github.com/tarantool/tarantool/issues/3320>`_."

#: ../doc/1.10/whats_new.rst:257
msgid ""
"(Replication) display the connection status if the downstream gets "
"disconnected from the upstream "
"(:ref:`box.info.replication.downstream.status <box_info_replication>` ``="
" disconnected``). Issue `3365 "
"<https://github.com/tarantool/tarantool/issues/3365>`_."
msgstr ""
"(Репликация) отображение статуса соединения, если последующий сервер "
"отключается от предыдущего (:ref:`box.info.replication.downstream.status "
"<box_info_replication>` ``= disconnected``). Проблема `3365 "
"<https://github.com/tarantool/tarantool/issues/3365>`_."

#: ../doc/1.10/whats_new.rst:263
msgid ""
"(Replication) :ref:`replica-local spaces <replication-local>` Issue `3443"
" <https://github.com/tarantool/tarantool/issues/3443>`_."
msgstr ""
"(Репликация) :ref:`спейсы с локальной репликацией <replication-local>` "
"Проблема `3443 <https://github.com/tarantool/tarantool/issues/3443>`_."

#: ../doc/1.10/whats_new.rst:265
msgid ""
"(Replication) :ref:`replication_skip_conflict <cfg_replication-"
"replication_skip_conflict>`, a new option in ``box.cfg{}`` to skip "
"conflicting rows in replication. Issue `3270 "
"<https://github.com/tarantool/tarantool/issues/3270>`_."
msgstr ""
"(Репликация) :ref:`replication_skip_conflict <cfg_replication-"
"replication_skip_conflict>`, новый параметр в ``box.cfg{}`` для пропуска "
"конфликтов строк при репликации. Проблема `3270 "
"<https://github.com/tarantool/tarantool/issues/3270>`_."

#: ../doc/1.10/whats_new.rst:269
msgid ""
"(Replication) remove old snapshots which are not needed by replicas. "
"Issue `3444 <https://github.com/tarantool/tarantool/issues/3444>`_."
msgstr ""
"(Репликация) удаление старых снимков, которые не нужны репликами. "
"Проблема `3444 <https://github.com/tarantool/tarantool/issues/3444>`_."

#: ../doc/1.10/whats_new.rst:272
msgid ""
"(Replication) log records which tried to commit twice. Issue `3105 "
"<https://github.com/tarantool/tarantool/issues/3105>`_."
msgstr ""
"(Репликации) запись в журнал попытки повторного коммита. Проблема `3105 "
"<https://github.com/tarantool/tarantool/issues/3105>`_."

#: ../doc/1.10/whats_new.rst:276
msgid ""
"(Lua) new function :ref:`fiber.join() <fiber_object-join>`. Issue `1397 "
"<https://github.com/tarantool/tarantool/issues/1397>`_."
msgstr ""
"(Lua) новая функция :ref:`fiber.join() <fiber_object-join>`. Проблема "
"`1397 <https://github.com/tarantool/tarantool/issues/1397>`_."

#: ../doc/1.10/whats_new.rst:278
msgid ""
"(Lua) new option ``names_only`` to :ref:`tuple:tomap() <box_tuple-"
"tomap>`. Issue `3280 "
"<https://github.com/tarantool/tarantool/issues/3280>`_."
msgstr ""
"(Lua) новая опция ``names_only`` для :ref:`tuple:tomap() <box_tuple-"
"tomap>`. Проблема `3280 "
"<https://github.com/tarantool/tarantool/issues/3280>`_."

#: ../doc/1.10/whats_new.rst:280
msgid ""
"(Lua) support custom rock servers (``server`` and ``only-server`` options"
" for :ref:`tarantoolctl rocks <tarantoolctl-module_management>` command)."
" Issue `2640 <https://github.com/tarantool/tarantool/issues/2640>`_."
msgstr ""
"(Lua) поддержка специализированных серверов для модулей (опции ``server``"
" и ``only-server`` для команды :ref:`tarantoolctl rocks <tarantoolctl-"
"module_management>`). Проблема `2640 "
"<https://github.com/tarantool/tarantool/issues/2640>`_."

#: ../doc/1.10/whats_new.rst:285
msgid ""
"(Lua) expose ``on_commit``/``on_rollback`` triggers to Lua; Issue `857 "
"<https://github.com/tarantool/tarantool/issues/857>`_."
msgstr ""
"(Lua) передача триггеров ``on_commit``/``on_rollback`` в Lua. Проблема "
"`857 <https://github.com/tarantool/tarantool/issues/857>`_."

#: ../doc/1.10/whats_new.rst:287
msgid ""
"(Lua) new function :ref:`box.is_in_txn() <box-is_in_txn>` to check if a "
"transaction is open; Issue `3518 "
"<https://github.com/tarantool/tarantool/issues/3518>`_."
msgstr ""
"(Lua) новая функция :ref:`box.is_in_txn() <box-is_in_txn>` для проверки "
"наличия открытой транзакции. Проблема `3518 "
"<https://github.com/tarantool/tarantool/issues/3518>`_."

#: ../doc/1.10/whats_new.rst:290
msgid ""
"(Lua) tuple field access via a json path (by :ref:`number <box_tuple-"
"field_number>`, :ref:`name <box_tuple-field_name>`, and :ref:`path "
"<box_tuple-field_path>`); Issue `1285 "
"<https://github.com/tarantool/tarantool/issues/1285>`_."
msgstr ""
"(Lua) доступ к полю кортежа по JSON-пути (по :ref:`номеру <box_tuple-"
"field_number>`, :ref:`имени <box_tuple-field_name>` и :ref:`пути "
"<box_tuple-field_path>`). Проблема`1285 "
"<https://github.com/tarantool/tarantool/issues/1285>`_."

#: ../doc/1.10/whats_new.rst:295
msgid ""
"(Lua) new function :ref:`space:frommap() <box_space-frommap>`; Issue "
"`3282 <https://github.com/tarantool/tarantool/issues/3282>`_."
msgstr ""
"(Lua) новая функция :ref:`space:frommap() <box_space-frommap>`. Проблема "
"`3282 <https://github.com/tarantool/tarantool/issues/3282>`_."

#: ../doc/1.10/whats_new.rst:297
msgid ""
"(Lua) new module :ref:`utf8 <utf8-module>` that implements libicu's "
"bindings for use in Lua; Issues `3290 "
"<https://github.com/tarantool/tarantool/issues/3290>`_, `3385 "
"<https://github.com/tarantool/tarantool/issues/3385>`_."
msgstr ""
"(Lua) новый модуль :ref:`utf8 <utf8-module>`, который имплементирует "
"привязки libicu для использования в Lua. Проблемы `3290 "
"<https://github.com/tarantool/tarantool/issues/3290>`_, `3385 "
"<https://github.com/tarantool/tarantool/issues/3385>`_."

#: ../doc/1.10/whats_new.rst:306
msgid "Version 1.9"
msgstr "Версия 1.9"

#: ../doc/1.10/whats_new.rst:310
msgid "**Release 1.9.0**"
msgstr "**Версия 1.9.0**"

#: ../doc/1.10/whats_new.rst:312
msgid "Release type: stable. Release date: 2018-02-26.  Tag: 1.9.0-4-g195d446."
msgstr "Тип версии: стабильная. Дата выхода: 2018-02-26.  Тег: 1.9.0-4-g195d446."

#: ../doc/1.10/whats_new.rst:314
msgid "Announcement: https://github.com/tarantool/tarantool/releases/tag/1.9.0."
msgstr "Сообщение:  https://github.com/tarantool/tarantool/releases/tag/1.9.0."

#: ../doc/1.10/whats_new.rst:316
msgid ""
"This is the successor of the 1.7.6 stable release. The goal of this "
"release is increased maturity of vinyl and master-master replication, and"
" it contributes a number of features to this cause. Please follow the "
"download instructions at https://tarantool.io/en/download/download.html "
"to download and install a package for your operating system."
msgstr ""
"Эта версия следует за стабильной версией 1.7.6. Цель данной версии -- "
"повысить стабилизацию vinyl'а и репликации типа мастер-мастер, для чего "
"предусмотрено значительное количество новых функций. Следуйте инструкциям"
" по загрузке по ссылке https://tarantool.io/en/download/download.html для"
" установки пакета для вашей операционной системы."

#: ../doc/1.10/whats_new.rst:324
msgid ""
"(Security) it is now possible to :ref:`block/unblock <authentication-"
"owners_privileges>` users. Issue `2898 "
"<https://github.com/tarantool/tarantool/issues/2898>`_."
msgstr ""
"(Безопасность) появилась возможность :ref:`блокировки и разблокировки "
"<authentication-owners_privileges>` пользователей. Проблема `2898 "
"<https://github.com/tarantool/tarantool/issues/2898>`_."

#: ../doc/1.10/whats_new.rst:327
msgid ""
"(Security) new function :ref:`box.session.euid() <box_session-euid>` to "
"return effective user. Effective user can be different from authenticated"
" user in case of ``setuid`` functions or ``box.session.su``. Issue `2994 "
"<https://github.com/tarantool/tarantool/issues/2994>`_."
msgstr ""
"(Безопасность) новая функция :ref:`box.session.euid() <box_session-euid>`"
" возвращает действующего пользователя. Действующий пользователь может "
"отличаться от авторизованного пользователя при использовании функций "
"``setuid`` или ``box.session.su``. Проблема `2994 "
"<https://github.com/tarantool/tarantool/issues/2994>`_."

#: ../doc/1.10/whats_new.rst:331
msgid ""
"(Security) new :ref:`super <box_space-user>` role, with superuser access."
" Grant 'super' to guest to disable access control. Issue `3022 "
"<https://github.com/tarantool/tarantool/issues/3022>`_."
msgstr ""
"(Безопасность) новая роль суперпользователя :ref:`super <box_space-"
"user>`. Чтобы отключить управление доступом, следует назначить "
"пользователю guest роль 'super'. Проблема `3022 "
"<https://github.com/tarantool/tarantool/issues/3022>`_."

#: ../doc/1.10/whats_new.rst:334
msgid ""
"(Security) :ref:`on_auth <box_session-on_auth>` trigger is now fired in "
"case of both successful and failed authentication. Issue `3039 "
"<https://github.com/tarantool/tarantool/issues/3039>`_."
msgstr ""
"(Безопасность) триггер :ref:`on_auth <box_session-on_auth>` срабатывает, "
"когда аутентификация пройдена, а также, когда аутентификация не пройдена."
" Проблема `3039 <https://github.com/tarantool/tarantool/issues/3039>`_."

#: ../doc/1.10/whats_new.rst:337
msgid ""
"(Replication/recovery) new replication configuration algorithm: if "
"replication doesn't connect to replication_quorum peers in "
":ref:`replication_connect_timeout <cfg_replication-"
"replication_connect_timeout>` seconds, the server start continues but the"
" server enters the new :ref:`orphan <replication-orphan_status>` status, "
"which is basically read-only, until the replicas connect to each other. "
"Issues `3151 <https://github.com/tarantool/tarantool/issues/3151>`_ and "
"`2958 <https://github.com/tarantool/tarantool/issues/2958>`_."
msgstr ""
"(Репликация/восстановление) новый алгоритм конфигурации репликации: если "
"экземпляр не подключается к количеству узлов, указанному в "
"replication_quorum, за количество секунд, указанное в "
":ref:`replication_connect_timeout <cfg_replication-"
"replication_connect_timeout>`, сервер начинает работу, но в качестве "
":ref:`одиночного <replication-orphan_status>`, то есть в режиме только "
"для чтения, пока реплики не подключатся друг к другу. Проблемы `3151 "
"<https://github.com/tarantool/tarantool/issues/3151>`_ и `2958 "
"<https://github.com/tarantool/tarantool/issues/2958>`_."

#: ../doc/1.10/whats_new.rst:343
msgid ""
"(Replication/recovery) after replication connect at startup, the server "
"does not start processing write requests before :ref:`syncing up "
"<replication-orphan_status>` syncing up with all connected peers."
msgstr ""
"(Репликация/восстановление) после включения репликации при запуске сервер"
" не начинает обработку запросов на запись до :ref:`синхронизации "
"<replication-orphan_status>` со всеми подключенными узлами."

#: ../doc/1.10/whats_new.rst:346
msgid ""
"(Replication/recovery) it is now possible to explicitly set "
":ref:`instance_uuid <cfg_replication-instance_uuid>` and :ref:`replica "
"set uuid <cfg_replication-replicaset_uuid>` as configuration parameters. "
"Issue `2967 <https://github.com/tarantool/tarantool/issues/2967>`_."
msgstr ""
"(Репликация/восстановление) появилась возможность явным образом задать "
":ref:`UUID экземпляра <cfg_replication-instance_uuid>` и :ref:`UUID "
"набора реплик <cfg_replication-replicaset_uuid>` в качестве "
"конфигурационных параметров. Проблема `2967 "
"<https://github.com/tarantool/tarantool/issues/2967>`_."

#: ../doc/1.10/whats_new.rst:350
msgid ""
"(Replication/recovery) :ref:`box.once() <box-once>` no longer fails on a "
"read-only replica but waits. Issue `2537 "
"<https://github.com/tarantool/tarantool/issues/2537>`_."
msgstr ""
"(Репликация/восстановление) :ref:`box.once() <box-once>` больше не "
"прекращает работу на реплике в режиме только для чтения, а переходит в "
"режим ожидания. Проблема `2537 "
"<https://github.com/tarantool/tarantool/issues/2537>`_."

#: ../doc/1.10/whats_new.rst:353
msgid ""
"(Replication/recovery) :ref:`force_recovery "
"<cfg_binary_logging_snapshots-force_recovery>` can now skip a corrupted "
"xlog file. Issue `3076 "
"<https://github.com/tarantool/tarantool/issues/3076>`_."
msgstr ""
"(Репликация/восстановление) :ref:`force_recovery "
"<cfg_binary_logging_snapshots-force_recovery>` может пропускать "
"поврежденный xlog-файл. Проблема `3076 "
"<https://github.com/tarantool/tarantool/issues/3076>`_."

#: ../doc/1.10/whats_new.rst:355
msgid ""
"(Replication/recovery) improved replication monitoring: "
":ref:`box.info.replication <box_info_replication>` shows peer ip:port and"
" correct replication lag even for idle peers. Issues `2753 "
"<https://github.com/tarantool/tarantool/issues/2753>`_ and `2689 "
"<https://github.com/tarantool/tarantool/issues/2689>`_."
msgstr ""
"(Репликация/восстановление) улучшен мониторинг репликации: "
":ref:`box.info.replication <box_info_replication>` показывает "
"IP-адрес:порт узла в сети и правильную задержку репликации для неактивных"
" узлов. Проблема `2753 "
"<https://github.com/tarantool/tarantool/issues/2753>`_ и `2689 "
"<https://github.com/tarantool/tarantool/issues/2689>`_."

#: ../doc/1.10/whats_new.rst:359
msgid ""
"(Application server) new :ref:`before <box_space-before_replace>` "
"triggers which can be used for conflict resolution in master-master "
"replication. Issue `2993 "
"<https://github.com/tarantool/tarantool/issues/2993>`_."
msgstr ""
"(Сервер приложений) новые триггеры до события (:ref:`before <box_space-"
"before_replace>`) можно использовать для разрешения конфликтов при "
"репликации типа мастер-мастер. Проблема `2993 "
"<https://github.com/tarantool/tarantool/issues/2993>`_."

#: ../doc/1.10/whats_new.rst:362
msgid ""
"(Application server) :ref:`http client <http-module>` now correctly "
"parses cookies and supports http+unix:// paths. Issues `3040 "
"<https://github.com/tarantool/tarantool/issues/3040>`_ and `2801 "
"<https://github.com/tarantool/tarantool/issues/2801>`_."
msgstr ""
"(Сервер приложений) :ref:`http client <http-module>` правильно разбирает "
"файлы cookie и поддерживает пути http+unix://. Проблемы `3040 "
"<https://github.com/tarantool/tarantool/issues/3040>`_ и `2801 "
"<https://github.com/tarantool/tarantool/issues/2801>`_."

#: ../doc/1.10/whats_new.rst:366
msgid ""
"(Application server) ``fio`` rock now supports ``file_exists()``, "
"``rename()`` works across filesystems, and ``read()`` without arguments "
"reads the whole file. Issues `2924 "
"<https://github.com/tarantool/tarantool/issues/2924>`_, `2751 "
"<https://github.com/tarantool/tarantool/issues/2751>`_ and `2925 "
"<https://github.com/tarantool/tarantool/issues/2925>`_."
msgstr ""
"(Сервер приложений) в модуле ``fio`` появилась поддержка "
"``file_exists()``, ``rename()`` работает в разных файловых системах, "
"``read()`` без аргументов выполняет чтение всего файла. Проблемы `2924 "
"<https://github.com/tarantool/tarantool/issues/2924>`_, `2751 "
"<https://github.com/tarantool/tarantool/issues/2751>`_ и `2925 "
"<https://github.com/tarantool/tarantool/issues/2925>`_."

#: ../doc/1.10/whats_new.rst:372
msgid ""
"(Application server) ``fio`` rock errors now follow Tarantool function "
"call conventions and always return an error message in addition to the "
"error flag."
msgstr ""
"(Сервер приложений) ошибки в модуле ``fio`` соответствуют стандартам "
"вызова функции в Tarantool'е и всегда возвращают сообщение об ошибке "
"вместе с флагом ошибки."

#: ../doc/1.10/whats_new.rst:374
msgid ""
"(Application server) ``digest`` rock now supports pbkdf2 password hashing"
" algorithm, useful in PCI/DSS compliant applications. Issue `2874 "
"<https://github.com/tarantool/tarantool/issues/2874>`_."
msgstr ""
"(Сервер приложений) модуль ``digest`` поддерживает алгоритм хеширования "
"паролей pbkdf2, который используется в приложениях, совместимых с "
"PCI/DSS. Проблема `2874 "
"<https://github.com/tarantool/tarantool/issues/2874>`_."

#: ../doc/1.10/whats_new.rst:377
msgid ""
"(Application server) :ref:`box.info.memory() <box_info_memory>` provides "
"a high-level overview of server memory usage, including networking, Lua, "
"transaction and index memory. Issue `934 "
"<https://github.com/tarantool/tarantool/issues/934>`_."
msgstr ""
"(Сервер приложений) :ref:`box.info.memory() <box_info_memory>` "
"обеспечивает общий обзор использования памяти сервера: работа по сети, "
"Lua, транзакции и индексы. Проблема `934 "
"<https://github.com/tarantool/tarantool/issues/934>`_."

#: ../doc/1.10/whats_new.rst:380
msgid ""
"(Database) it is now possible to :ref:`add missing tuple fields "
"<box_space-is_nullable>` to an index, which is very useful when adding an"
" index along with the evolution of the database schema. Issue `2988 "
"<https://github.com/tarantool/tarantool/issues/2988>`_."
msgstr ""
"(База данных) появилась возможность :ref:`добавить отсутствующие поля "
"кортежа <box_space-is_nullable>` в индекс, что используется при "
"добавлении индекса вместе с эволюцией схемы базы данных. Проблема `2988 "
"<https://github.com/tarantool/tarantool/issues/2988>`_."

#: ../doc/1.10/whats_new.rst:384
msgid ""
"(Database) lots of improvements in field type support when creating or "
":ref:`altering <box_index-alter>` spaces and indexes. Issues `2893 "
"<https://github.com/tarantool/tarantool/issues/2893>`_, `3011 "
"<https://github.com/tarantool/tarantool/issues/3011>`_ and `3008 "
"<https://github.com/tarantool/tarantool/issues/3008>`_."
msgstr ""
"(База данных) множество улучшений поддержки типов полей при создании или "
":ref:`изменении <box_index-alter>` спейсов и индексов. Проблемы `2893 "
"<https://github.com/tarantool/tarantool/issues/2893>`_, `3011 "
"<https://github.com/tarantool/tarantool/issues/3011>`_ и `3008 "
"<https://github.com/tarantool/tarantool/issues/3008>`_."

#: ../doc/1.10/whats_new.rst:389
msgid ""
"(Database) it is now possible to turn on :ref:`is_nullable <box_space-"
"is_nullable>` property on a field even if the space is not empty, the "
"change is instantaneous. Issue `2973 "
"<https://github.com/tarantool/tarantool/issues/2973>`_."
msgstr ""
"(База данных) появилась возможность включения опции :ref:`is_nullable "
"<box_space-is_nullable>` для поля, даже если спейс не является пустым, с "
"мгновенным применением изменений. Проблема `2973 "
"<https://github.com/tarantool/tarantool/issues/2973>`_."

#: ../doc/1.10/whats_new.rst:392
msgid ""
"(Database) :ref:`logging <log-module>` has been improved in many "
"respects: individual messages (issues `1972 "
"<https://github.com/tarantool/tarantool/issues/1972>`_, `2743 "
"<https://github.com/tarantool/tarantool/issues/2743>`_, `2900 "
"<https://github.com/tarantool/tarantool/issues/2900>`_), more logging in "
"cases when it was useful (issues `3096 "
"<https://github.com/tarantool/tarantool/issues/3096>`_, `2871 "
"<https://github.com/tarantool/tarantool/issues/2871>`_)."
msgstr ""
"(База данных) улучшены многие аспекты :ref:`журналирования <log-module>`:"
" отдельные сообщения (проблемы `1972 "
"<https://github.com/tarantool/tarantool/issues/1972>`_, `2743 "
"<https://github.com/tarantool/tarantool/issues/2743>`_, `2900 "
"<https://github.com/tarantool/tarantool/issues/2900>`_), увеличение "
"количества записей при необходимости (проблемы `3096 "
"<https://github.com/tarantool/tarantool/issues/3096>`_, `2871 "
"<https://github.com/tarantool/tarantool/issues/2871>`_)."

#: ../doc/1.10/whats_new.rst:399
msgid ""
"(Vinyl storage engine) it is now possible to make a :ref:`unique "
"<box_index-unique>` vinyl index non-unique without index rebuild. Issue "
"`2449 <https://github.com/tarantool/tarantool/issues/2449>`_."
msgstr ""
"(Движок базы данных Vinyl) появилась возможность сделать :ref:`уникальный"
" <box_index-unique>` индекс в vinyl'е неуникальным без повторного "
"создания индекса. Проблема `2449 "
"<https://github.com/tarantool/tarantool/issues/2449>`_."

#: ../doc/1.10/whats_new.rst:402
msgid ""
"(Vinyl storage engine) improved UPDATE, REPLACE and recovery performance "
"in presence of secondary keys. Issues `2289 "
"<https://github.com/tarantool/tarantool/issues/2289>`_, `2875 "
"<https://github.com/tarantool/tarantool/issues/2875>`_ and `3154 "
"<https://github.com/tarantool/tarantool/issues/3154>`_."
msgstr ""
"(Движок базы данных Vinyl) улучшена производительность операций "
"обновления UPDATE, замены REPLACE и восстановления при наличии вторичных "
"ключей. Проблемы `2289 "
"<https://github.com/tarantool/tarantool/issues/2289>`_, `2875 "
"<https://github.com/tarantool/tarantool/issues/2875>`_ и `3154 "
"<https://github.com/tarantool/tarantool/issues/3154>`_."

#: ../doc/1.10/whats_new.rst:407
msgid ""
"(Vinyl storage engine) :ref:`space:len() <box_space-len>` and "
":ref:`space:bsize() <box_space-bsize>` now work for vinyl (although they "
"are still not exact). Issue `3056 "
"<https://github.com/tarantool/tarantool/issues/3056>`_."
msgstr ""
"(Движок базы данных Vinyl) :ref:`space:len() <box_space-len>` и "
":ref:`space:bsize() <box_space-bsize>` работают с vinyl'ом (хотя и "
"неточно). Проблема `3056 "
"<https://github.com/tarantool/tarantool/issues/3056>`_."

#: ../doc/1.10/whats_new.rst:411
msgid ""
"(Vinyl storage engine) recovery speed has improved in presence of "
"secondary keys. Issue `2099 "
"<https://github.com/tarantool/tarantool/issues/2099>`_."
msgstr ""
"(Движок базы данных Vinyl) улучшена скорость восстановления при наличии "
"вторичных ключей. Проблема `2099 "
"<https://github.com/tarantool/tarantool/issues/2099>`_."

#: ../doc/1.10/whats_new.rst:414
msgid ""
"(Builds) Alpine Linux support. Issue `3067 "
"<https://github.com/tarantool/tarantool/issues/3067>`_."
msgstr ""
"(Сборки) Поддержка Alpine Linux. Проблема `3067 "
"<https://github.com/tarantool/tarantool/issues/3067>`_."

#: ../doc/1.10/whats_new.rst:421
msgid "Version 1.7"
msgstr "Версия 1.7"

#: ../doc/1.10/whats_new.rst:425
msgid "**Release 1.7.6**"
msgstr "**Версия 1.7.6**"

#: ../doc/1.10/whats_new.rst:427
msgid "Release type: stable. Release date: 2017-11-07.  Tag: 1.7.6-0-g7b2945d6c."
msgstr "Тип версии: стабильная. Дата выхода: 2017-11-07.  Тег: 1.7.6-0-g7b2945d6c."

#: ../doc/1.10/whats_new.rst:429
msgid ""
"Announcement: "
"https://groups.google.com/forum/#!topic/tarantool/hzc7O2YDZUc."
msgstr ""
"Объявление о выходе: "
"https://groups.google.com/forum/#!topic/tarantool/hzc7O2YDZUc."

#: ../doc/1.10/whats_new.rst:431
msgid ""
"This is the next stable release in the 1.7 series. It resolves more than "
"75 issues since 1.7.5."
msgstr ""
"Данная сборка представляет собой очередную стабильную версию в серии 1.7."
" Это обновление содержит более 75 исправлений по сравнению с версией "
"1.7.5."

#: ../doc/1.10/whats_new.rst:434
msgid "What's new in Tarantool 1.7.6?"
msgstr "Что нового в Tarantool 1.7.6?"

#: ../doc/1.10/whats_new.rst:436
msgid ""
"In addition to :ref:`rollback <box-rollback>` of a transaction, there is "
"now rollback to a defined point within a transaction -- :ref:`savepoint "
"<box-savepoint>` support."
msgstr ""
"В дополнение к :ref:`откату <box-rollback>` транзакции, появился откат на"
" определенную точку в пределах транзакции -- поддержка :ref:`точки "
"сохранения <box-savepoint>`."

#: ../doc/1.10/whats_new.rst:438
msgid ""
"There is a new object type: :ref:`sequences <index-box_sequence>`. The "
"older option, :ref:`auto-increment <box_space-auto_increment>`, will be "
"deprecated."
msgstr ""
"Появился новый объектный тип: :ref:`последовательности <index-"
"box_sequence>`. Устаревший вариант, :ref:`автоматическое увеличение "
"<box_space-auto_increment>`, объявлен устаревшим."

#: ../doc/1.10/whats_new.rst:440
msgid "String indexes can have :ref:`collations <index-collation>`."
msgstr "В строковых индексах появилась :ref:`сортировка <index-collation>`."

#: ../doc/1.10/whats_new.rst:442
msgid "New options are available for:"
msgstr "Добавлены новые опции:"

#: ../doc/1.10/whats_new.rst:444
msgid ":ref:`net_box <net_box-module>` (timeouts),"
msgstr ":ref:`net_box <net_box-module>` (время ожидания),"

#: ../doc/1.10/whats_new.rst:445
msgid ":ref:`string <string-module>` functions,"
msgstr "функции :ref:`string <string-module>`,"

#: ../doc/1.10/whats_new.rst:446
msgid ""
"space :ref:`formats <box_space-format>` (user-defined field names and "
"types),"
msgstr ""
":ref:`форматы <box_space-format>` для спейса (имена и типы полей, "
"задаваемые пользователем),"

#: ../doc/1.10/whats_new.rst:447
msgid ":ref:`base64 <digest-base64_encode>` (``urlsafe`` option), and"
msgstr ":ref:`base64 <digest-base64_encode>` (опция ``urlsafe``),  а также"

#: ../doc/1.10/whats_new.rst:448
msgid ""
"index :ref:`creation <box_space-create_index>` (collation, :ref:`is-"
"nullable <box_space-is_nullable>`, field names)."
msgstr ""
":ref:`создание <box_space-create_index>` индекса (сортировка, :ref:`is-"
"nullable <box_space-is_nullable>` (возможность допустить неопределенное "
"значение), имена полей)."

#: ../doc/1.10/whats_new.rst:451 ../doc/1.10/whats_new.rst:897
#: ../doc/1.10/whats_new.rst:957 ../doc/1.10/whats_new.rst:1139
#: ../doc/1.10/whats_new.rst:1182 ../doc/1.10/whats_new.rst:1294
#: ../doc/1.10/whats_new.rst:1336
msgid "Incompatible changes:"
msgstr "Несовместимые изменения:"

#: ../doc/1.10/whats_new.rst:453
msgid ""
"Layout of ``box.space._index`` has been extended to support "
":ref:`is_nullable <box_space-is_nullable>` and :ref:`collation <index-"
"collation>` features. All new indexes created on columns with "
"``is_nullable`` or ``collation`` properties will have the new definition "
"format. Please update your client libraries if you plan to use these new "
"features. Issue `2802 "
"<https://github.com/tarantool/tarantool/issues/2802>`_"
msgstr ""
"Расширенная структура ``box.space._index`` поддерживает функции "
":ref:`is_nullable <box_space-is_nullable>` и :ref:`collation <index-"
"collation>` (сортировка). Все новые индексы, созданные по столбцам со "
"свойствами  ``is_nullable`` или ``collation`` получат новый формат "
"определения. Обновите клиентские библиотеки, если планируете использовать"
" новые возможности. Проблема `2802 "
"<https://github.com/tarantool/tarantool/issues/2802>`_"

#: ../doc/1.10/whats_new.rst:460
msgid ""
":ref:`fiber_name() <fiber_object-name_get>` now raises an exception "
"instead of truncating long fiber names. We found that some Lua modules "
"such as :ref:`expirationd <expirationd-module>` use ``fiber.name()`` as a"
" key to identify background tasks. If a name is truncated, this fact was "
"silently missed. The new behavior allows to detect bugs caused by "
"``fiber.name()`` truncation. Please use ``fiber.name(name, { truncate = "
"true })`` to emulate the old behavior. Issue `2622 "
"<https://github.com/tarantool/tarantool/issues/2622>`_"
msgstr ""
":ref:`fiber_name() <fiber_object-name_get>` теперь выдает ошибку вместо "
"усечения длинных имен файберов. Мы обнаружили, что некоторые Lua-модули, "
"такие как :ref:`expirationd <expirationd-module>`, используют "
"``fiber.name()`` для определения фоновых задач. Если же имя усечено, они "
"упускают файбер из вида. Обновление позволит обнаружить ошибки, вызванные"
" усечением имени файбера ``fiber.name()``. Используйте ``fiber.name(name,"
" { truncate = true })`` для моделирования старого поведения системы. "
"Проблема `2622 <https://github.com/tarantool/tarantool/issues/2622>`_"

#: ../doc/1.10/whats_new.rst:467
msgid ""
":ref:`space:format() <box_space-format>` is now validated on DML "
"operations. Previously ``space:format()`` was only used by client "
"libraries, but starting from Tarantoool 1.7.6, field types in "
"``space:format()`` are validated on the server side on every DML "
"operation, and field names can be used in indexes and Lua code. If you "
"used ``space:format()`` in a non-standard way, please update layout and "
"type names according to the official documentation for space formats."
msgstr ""
":ref:`space:format() <box_space-format>` проверяется в DML-операциях. "
"Раньше ``space:format()`` использовался только в клиентских библиотеках, "
"но с версии Tarantoool 1.7.6 типы полей в ``space:format()`` проверяются "
"на стороне сервера при каждой DML-операции, и имена полей могут "
"использоваться в индексах и Lua-коде. Если ``space:format()`` "
"использовался нестандартно, обновите структуру и имена типов в "
"соответствии с официальной документацией по форматам спейса."

#: ../doc/1.10/whats_new.rst:477
msgid ""
"Hybrid schema-less + schemaful data model. Earlier Tarantool versions "
"allowed to store arbitrary MessagePack documents in spaces. Starting from"
" Tarantool 1.7.6, you can use :ref:`space:format() <box_space-format>` to"
" define schema restrictions and constraints for tuples in spaces. Defined"
" field types are automatically validated on every DML operation, and "
"defined field names can be used instead of field numbers in Lua code. A "
"new function :ref:`tuple:tomap() <box_tuple-tomap>` was added to convert "
"a tuple into a key-value Lua dictionary."
msgstr ""
"Гибридная модель данных без схемы + со схемой. Раньше версии Tarantool "
"позволяли хранить произвольный набор документов в формате MessagePack в "
"спейсах. Начиная с версии Tarantool 1.7.6, можно использовать "
":ref:`space:format() <box_space-format>` для определения условий и "
"ограничений схемы для кортежей в спейсах. Определенные типы полей "
"автоматически проверяются при каждой DML-операции, а определенные имена "
"полей могут использоваться вместо номеров полей в Lua-коде. Добавлена "
"новая функция :ref:`tuple:tomap() <box_tuple-tomap>` для конвертации "
"кортежа в Lua-словарь пар ключ-значение."

#: ../doc/1.10/whats_new.rst:484
msgid ""
"Collation and Unicode support. By default, when Tarantool compares "
"strings, it takes into consideration only the numeric value of each byte "
"in the string. To allow the ordering that you see in phone books and "
"dictionaries, Tarantool 1.7.6 introduces support for collations based on "
"the `Default Unicode Collation Element Table (DUCET) "
"<http://unicode.org/reports/tr10/#Default_Unicode_Collation_Element_Table>`_"
" and the rules described in `Unicode® Technical Standard #10 Unicode "
"Collation Algorithm (UTS #10 UCA) <http://unicode.org/reports/tr10>`_ See"
" :ref:`collations <index-collation>`."
msgstr ""
"Поддержка сортировки и Юникода. По умолчанию, когда Tarantool "
"сопоставляет строки, он берет во внимание только числовое значение "
"каждого байта в строке. Чтобы задействовать такое распределение, как в "
"телефонных справочниках и словарях, в Tarantool'е версии 1.7.6 впервые "
"поддерживается сортировка по Таблице сортировки символов Юникода по "
"умолчанию (`Default Unicode Collation Element Table (DUCET) "
"<http://unicode.org/reports/tr10/#Default_Unicode_Collation_Element_Table>`_)"
" и в соответствии с правилами, описанными в Техническом стандарте Юникода"
" №10 -- Алгоритм сортировки по Юникоду (`Unicode® Technical Standard #10 "
"Unicode Collation Algorithm (UTS #10 UCA) "
"<http://unicode.org/reports/tr10>`_). См. :ref:`сортировку <index-"
"collation>`."

#: ../doc/1.10/whats_new.rst:492
msgid ""
"NULL values in unique and non-unique indexes. By default, all fields in "
"Tarantool are  \"NOT NULL\". Starting from Tarantool 1.7.6, you can use "
"``is_nullable`` option in :ref:`space:format() <box_space-format>` or "
":ref:`inside an index part definition <box_space-is_nullable>` to allow "
"storing NULL in indexes. Tarantool partially implements `three-valued "
"logic <https://en.wikipedia.org/wiki/Three-valued_logic>`_ from the SQL "
"standard and allows storing multiple NULL values in unique indexes. Issue"
" `1557 <https://github.com/tarantool/tarantool/issues/1557>`_."
msgstr ""
"Значения NULL в уникальных и неуникальных индексах. По умолчанию, все "
"поля в Tarantool'е \"НЕ NULL\". Начиная с версии Tarantool 1.7.6, можно "
"использовать опцию ``is_nullable`` (возможность допустить неопределенное "
"значение) в :ref:`space:format() <box_space-format>` или :ref:`в "
"определении части индекса <box_space-is_nullable>`, чтобы разрешить "
"хранение значения NULL в индексах. Tarantool частично реализует `троичную"
" логику "
"<https://ru.wikipedia.org/wiki/%D0%A2%D1%80%D0%BE%D0%B8%D1%87%D0%BD%D0%B0%D1%8F_%D0%BB%D0%BE%D0%B3%D0%B8%D0%BA%D0%B0>`_"
" из стандарта SQL и позволяет хранить несколько значений NULL в "
"уникальных индексах. Проблема `1557 "
"<https://github.com/tarantool/tarantool/issues/1557>`_."

#: ../doc/1.10/whats_new.rst:502
msgid ""
"Sequences and a new implementation of :ref:`auto_increment() <box_space-"
"auto_increment>`. Tarantool 1.7.6 introduces new :ref:`sequence number "
"generators <index-box_sequence>` (like CREATE SEQUENCE in SQL). This "
"feature is used to implement new persistent auto increment in spaces. "
"Issue `389 <https://github.com/tarantool/tarantool/issues/389>`_."
msgstr ""
"Последовательности и внедрение автоматического увеличения "
":ref:`auto_increment() <box_space-auto_increment>`. В версии Tarantool "
"1.7.6 впервые реализованы :ref:`генераторы порядковых номеров <index-"
"box_sequence>` (как CREATE SEQUENCE -- создание последовательности -- в "
"SQL). Эта функция используется для внедрения нового персистентного "
"автоматического увеличения в спейсах. Проблема `389 "
"<https://github.com/tarantool/tarantool/issues/389>`_."

#: ../doc/1.10/whats_new.rst:507
msgid ""
"Vinyl: introduced gap locks in Vinyl transaction manager. The new locking"
" mechanism in Vinyl TX manager reduces the number of conflicts in "
"transactions. Issue `2671 "
"<https://github.com/tarantool/tarantool/issues/2671>`_."
msgstr ""
"Vinyl: появляется блокировка разрывов в менеджере транзакций Vinyl'а. "
"Новый блокирующий механизм в менеджере Vinyl TX снижает количество "
"конфликтов в транзакциях. Проблема `2671 "
"<https://github.com/tarantool/tarantool/issues/2671>`_."

#: ../doc/1.10/whats_new.rst:510
msgid ""
"net.box: :ref:`on_connect <box_session-on_connect>` and "
":ref:`on_disconnect <box_session-on_disconnect>` triggers. Issue `2858 "
"<https://github.com/tarantool/tarantool/issues/2858>`_."
msgstr ""
"net.box: триггеры :ref:`on_connect <box_session-on_connect>` и "
":ref:`on_disconnect <box_session-on_disconnect>` (по "
"подключению/отключению). Проблема `2858 "
"<https://github.com/tarantool/tarantool/issues/2858>`_."

#: ../doc/1.10/whats_new.rst:513
msgid ""
"Structured logging in :ref:`JSON format <cfg_logging-log_format>`. Issue "
"`2795 <https://github.com/tarantool/tarantool/issues/2795>`_."
msgstr ""
"Структурированная запись в журнал в :ref:`формате JSON <cfg_logging-"
"log_format>`. Проблема `2795 "
"<https://github.com/tarantool/tarantool/issues/2795>`_."

#: ../doc/1.10/whats_new.rst:515
msgid ""
"(Lua) Lua: :ref:`string.strip() <string-strip>` Issue `2785 "
"<https://github.com/tarantool/tarantool/issues/2785>`_."
msgstr ""
"(Lua) Lua: :ref:`string.strip() <string-strip>` Проблема `2785 "
"<https://github.com/tarantool/tarantool/issues/2785>`_."

#: ../doc/1.10/whats_new.rst:517
msgid ""
"(Lua) added :ref:`base64_urlsafe_encode() <digest-base64_encode>` to "
"``digest`` module. Issue `2777 "
"<https://github.com/tarantool/tarantool/issues/2777>`_."
msgstr ""
"(Lua) добавлен API :ref:`base64_urlsafe_encode() <digest-base64_encode>` "
"для модуля ``digest``. Проблема `2777 "
"<https://github.com/tarantool/tarantool/issues/2777>`_."

#: ../doc/1.10/whats_new.rst:519
msgid ""
"Log conflicted keys in master-master replication. Issue `2779 "
"<https://github.com/tarantool/tarantool/issues/2779>`_."
msgstr ""
"Запись конфликтов в ключах в журнал в рамках репликации мастер-мастер. "
"Проблема `2779 <https://github.com/tarantool/tarantool/issues/2779>`_."

#: ../doc/1.10/whats_new.rst:521
msgid ""
"Allow to disable backtrace in :ref:`fiber.info() <fiber-info>`. Issue "
"`2878 <https://github.com/tarantool/tarantool/issues/2878>`_."
msgstr ""
"Возможность отключить обратную трассировку в :ref:`fiber.info() <fiber-"
"info>`. Проблема `2878 "
"<https://github.com/tarantool/tarantool/issues/2878>`_."

#: ../doc/1.10/whats_new.rst:523
msgid ""
"Implemented ``tarantoolctl rocks make *.spec``. Issue `2846 "
"<https://github.com/tarantool/tarantool/issues/2846>`_."
msgstr ""
"Реализована возможность создания сторонних библиотек ``tarantoolctl rocks"
" make *.spec``. Проблема `2846 "
"<https://github.com/tarantool/tarantool/issues/2846>`_."

#: ../doc/1.10/whats_new.rst:525
msgid ""
"Extended the default loader to look for ``.rocks`` in the parent dir "
"hierarchy. Issue `2676 "
"<https://github.com/tarantool/tarantool/issues/2676>`_."
msgstr ""
"Новая функция загрузчика, используемого по умолчанию,  позволяет искать "
"модули ``.rocks`` в родительской иерархии. Проблема `2676 "
"<https://github.com/tarantool/tarantool/issues/2676>`_."

#: ../doc/1.10/whats_new.rst:527
msgid ""
"``SOL_TCP`` options support in :ref:`socket:setsockopt() <socket-"
"setsockopt>`. Issue `598 "
"<https://github.com/tarantool/tarantool/issues/598>`_."
msgstr ""
"Поддержка опций ``SOL_TCP`` в  :ref:`socket:setsockopt() <socket-"
"setsockopt>`. Проблема `598 "
"<https://github.com/tarantool/tarantool/issues/598>`_."

#: ../doc/1.10/whats_new.rst:529
msgid ""
"Partial emulation of LuaSocket on top of Tarantool Socket. Issue `2727 "
"<https://github.com/tarantool/tarantool/issues/2727>`_."
msgstr ""
"Частичное моделирование LuaSocket поверх Tarantool Socket. Проблема `2727"
" <https://github.com/tarantool/tarantool/issues/2727>`_."

#: ../doc/1.10/whats_new.rst:532
msgid "Developer tools:"
msgstr "Инструменты разработчика:"

#: ../doc/1.10/whats_new.rst:534
msgid ""
"Integration with IntelliJ IDEA with debugging support. Now you can use "
"IntelliJ IDEA as an IDE to develop and debug Lua applications for "
"Tarantool. See :ref:`Using IDE <app_server-using_ide>`."
msgstr ""
"Интеграция с IntelliJ IDEA с поддержкой отладки. Появилась возможность "
"использовать IntelliJ IDEA в качестве IDE для разработки и отладки "
"Lua-приложений для Tarantool'а. См. :ref:`Использование IDE <app_server-"
"using_ide>`."

#: ../doc/1.10/whats_new.rst:537
msgid ""
"Integration with `MobDebug <https://github.com/pkulchenko/MobDebug>`_ "
"remote Lua debugger. Issue `2728 "
"<https://github.com/tarantool/tarantool/issues/2728>`_."
msgstr ""
"Интеграция с удаленным Lua-отладчиком `MobDebug "
"<https://github.com/pkulchenko/MobDebug>`_. Проблема `2728 "
"<https://github.com/tarantool/tarantool/issues/2728>`_."

#: ../doc/1.10/whats_new.rst:539
msgid ""
"Configured ``/usr/bin/tarantool`` as an alternative Lua interpreter on "
"Debian/Ubuntu. Issue `2730 "
"<https://github.com/tarantool/tarantool/issues/2730>`_."
msgstr ""
"Настройка ``/usr/bin/tarantool`` в качестве альтернативного "
"Lua-интерпретатора для Debian/Ubuntu. Проблема `2730 "
"<https://github.com/tarantool/tarantool/issues/2730>`_."

#: ../doc/1.10/whats_new.rst:542 ../doc/1.10/whats_new.rst:643
#: ../doc/1.10/whats_new.rst:1319 ../doc/1.10/whats_new.rst:1399
msgid "New rocks:"
msgstr "Новые сторонние библиотеки:"

#: ../doc/1.10/whats_new.rst:544
msgid ""
"`smtp.client <https://github.com/tarantool/smtp>`_ - support SMTP via "
"``libcurl``."
msgstr ""
"`smtp.client <https://github.com/tarantool/smtp>`_ -- поддержка SMTP по "
"``libcurl``."

#: ../doc/1.10/whats_new.rst:548
msgid "**Release 1.7.5**"
msgstr "**Версия 1.7.5**"

#: ../doc/1.10/whats_new.rst:550
msgid "Release type: stable. Release date: 2017-08-22.  Tag: 1.7.5."
msgstr "Тип версии: стабильная. Дата выхода: 2017-08-22.  Тег: 1.7.5."

#: ../doc/1.10/whats_new.rst:552
msgid "Announcement: https://github.com/tarantool/doc/issues/289."
msgstr "Объявление о выходе: https://github.com/tarantool/doc/issues/289."

#: ../doc/1.10/whats_new.rst:554
msgid ""
"This is a stable release in the 1.7 series. This release resolves more "
"than 160 issues since 1.7.4."
msgstr ""
"Данная сборка представляет собой стабильную версию в серии 1.7. Это "
"обновление содержит более 160 исправлений по сравнению с версией 1.7.4."

#: ../doc/1.10/whats_new.rst:559
msgid ""
"(Vinyl) a new :ref:`force_recovery <cfg_binary_logging_snapshots-"
"force_recovery>` mode to recover broken disk files. Use "
"``box.cfg{force_recovery=true}`` to recover corrupted data files after "
"hardware issues or power outages. Issue `2253 "
"<https://github.com/tarantool/tarantool/issues/2253>`_."
msgstr ""
"(Vinyl) новый режим принудительного восставовления :ref:`force_recovery "
"<cfg_binary_logging_snapshots-force_recovery>` для восстановления "
"поврежденных файлов на диске. Используйте "
"``box.cfg{force_recovery=true}`` для восстановления файлов с данными, "
"поврежденными в результате проблем с оборудованием или отключения "
"электроэнергии. Проблема `2253 "
"<https://github.com/tarantool/tarantool/issues/2253>`_."

#: ../doc/1.10/whats_new.rst:564
msgid ""
"(Vinyl) index options can be changed on the fly without rebuild. Now "
":ref:`page_size <cfg_storage-vinyl_page_size>`, :ref:`run_size_ratio "
"<cfg_storage-vinyl_run_size_ratio>`, :ref:`run_count_per_level "
"<cfg_storage-vinyl_run_count_per_level>` and :ref:`bloom_fpr "
"<cfg_storage-vinyl_bloom_fpr>` index options can be dynamically changed "
"via :ref:`index:alter() <box_index-alter>`. The changes take effect in "
"newly created data files only. Issue `2109 "
"<https://github.com/tarantool/tarantool/issues/2109>`_."
msgstr ""
"(Vinyl) параметры индекса можно менять на лету без необходимости "
"пересборки. Появилась возможность динамически изменять параметры "
":ref:`page_size <cfg_storage-vinyl_page_size>`, :ref:`run_size_ratio "
"<cfg_storage-vinyl_run_size_ratio>`, :ref:`run_count_per_level "
"<cfg_storage-vinyl_run_count_per_level>` и :ref:`bloom_fpr <cfg_storage-"
"vinyl_bloom_fpr>` с помощью :ref:`index:alter() <box_index-alter>`. "
"Изменения вступают в силу только для вновь созданных файлов. Проблема "
"`2109 <https://github.com/tarantool/tarantool/issues/2109>`_."

#: ../doc/1.10/whats_new.rst:572
msgid ""
"(Vinyl) improve :ref:`box.info.vinyl() <box_introspection-box_info>` and "
"``index:info()`` output. Issue `1662 "
"<https://github.com/tarantool/tarantool/issues/1662>`_."
msgstr ""
"(Vinyl) улучшен вывод :ref:`box.info.vinyl() <box_introspection-"
"box_info>` и ``index:info()``. Проблема `1662 "
"<https://github.com/tarantool/tarantool/issues/1662>`_."

#: ../doc/1.10/whats_new.rst:574
msgid ""
"(Vinyl) introduce :ref:`box.cfg.vinyl_timeout <cfg_basic-vinyl_timeout>` "
"option to control quota throttling. Issue `2014 "
"<https://github.com/tarantool/tarantool/issues/2014>`_."
msgstr ""
"(Vinyl) появляется опция :ref:`box.cfg.vinyl_timeout <cfg_basic-"
"vinyl_timeout>` для управления загрузкой на основе квот. Проблема `2014 "
"<https://github.com/tarantool/tarantool/issues/2014>`_."

#: ../doc/1.10/whats_new.rst:576
msgid ""
"Memtx: stable :ref:`index:pairs() <box_index-index_pairs>` iterators for "
"the TREE index. TREE iterators are automatically restored to a proper "
"position after index's modifications. Issue `1796 "
"<https://github.com/tarantool/tarantool/issues/1796>`_."
msgstr ""
"Memtx: стабильные итераторы :ref:`index:pairs() <box_index-index_pairs>` "
"для TREE-индекса. TREE-итераторы автоматически восстанавливаются в "
"правильном положении после изменений индекса. Проблема `1796 "
"<https://github.com/tarantool/tarantool/issues/1796>`_."

#: ../doc/1.10/whats_new.rst:579
msgid ""
"(Memtx) :ref:`predictable order <box_index-index_pairs>` for non-unique "
"TREE indexes. Non-unique TREE indexes preserve the sort order for "
"duplicate entries. Issue `2476 "
"<https://github.com/tarantool/tarantool/issues/2476>`_."
msgstr ""
"(Memtx)  :ref:`предсказуемый порядок <box_index-index_pairs>` для "
"неуникальных TREE-индексов. Неуникальные TREE-индексы сохраняют порядок "
"сортировки для дублирующихся записей. Проблема `2476 "
"<https://github.com/tarantool/tarantool/issues/2476>`_."

#: ../doc/1.10/whats_new.rst:582
msgid ""
"(Memtx+Vinyl) dynamic configuration of :ref:`max tuple size <cfg_storage-"
"memtx_max_tuple_size>`. Now ``box.cfg.memtx_max_tuple_size`` and "
"``box.cfg.vinyl_max_tuple_size`` configuration options can be changed on "
"the fly without need to restart the server. Issue `2667 "
"<https://github.com/tarantool/tarantool/issues/2667>`_."
msgstr ""
"(Memtx+Vinyl) динамическая настройка :ref:`максимального размера кортежа "
"<cfg_storage-memtx_max_tuple_size>`. Впервые конфигурационные параметры "
"``box.cfg.memtx_max_tuple_size`` и ``box.cfg.vinyl_max_tuple_size`` можно"
" изменять на лету без необходимости перезагрузки сервера. Проблема `2667 "
"<https://github.com/tarantool/tarantool/issues/2667>`_."

#: ../doc/1.10/whats_new.rst:586
msgid ""
"(Memtx+Vinyl) new implementation. Space :ref:`truncation <box_space-"
"truncate>` doesn't cause re-creation of all indexes any more. Issue `618 "
"<https://github.com/tarantool/tarantool/issues/618>`_."
msgstr ""
"(Memtx+Vinyl) новая реализация. :ref:`Усечение <box_space-truncate>` "
"спейса больше не вызывает повторное создание всех индексов. Проблема `618"
" <https://github.com/tarantool/tarantool/issues/618>`_."

#: ../doc/1.10/whats_new.rst:589
msgid ""
"Extended the :ref:`maximal length <limitations_length>` of all "
"identifiers from 32 to 65k characters. Space, user and function names are"
" not limited by 32 characters anymore. Issue `944 "
"<https://github.com/tarantool/tarantool/issues/944>`_."
msgstr ""
":ref:`Максимальная длина <limitations_length>` всех идентификаторов "
"расширена с 32 до 65 тысяч символов. Имена спейса, пользователя и функции"
" больше не ограничены 32 символами. Проблема `944 "
"<https://github.com/tarantool/tarantool/issues/944>`_."

#: ../doc/1.10/whats_new.rst:592
msgid ""
":ref:`Heartbeat <cfg_replication-replication_timeout>` messages for "
"replication. Replication client now sends the selective acknowledgments "
"for processed records and automatically re-establish stalled connections."
" This feature also changes :ref:`box.info.replication[replica_id].vclock "
"<box_info_replication>`. to display committed vclock of remote replica. "
"Issue `2484 <https://github.com/tarantool/tarantool/issues/2484>`_."
msgstr ""
"Сообщения :ref:`контрольного сигнала <cfg_replication-"
"replication_timeout>` для репликации. Репликационный клиент теперь "
"выборочно отправляет подтверждение обработки записей и автоматически "
"переподключается в случае замедления. Также в рамках этого изменения "
":ref:`box.info.replication[replica_id].vclock <box_info_replication>` "
"будет отображать определенный vclock удаленной реплики. Проблема `2484 "
"<https://github.com/tarantool/tarantool/issues/2484>`_."

#: ../doc/1.10/whats_new.rst:598
msgid ""
"Keep track of remote replicas during WAL maintenance. Replication master "
"now automatically preserves xlogs needed for remote replicas. Issue `748 "
"<https://github.com/tarantool/tarantool/issues/748>`_."
msgstr ""
"Отслеживание удаленных реплик во время обслуживания WAL. Мастер "
"репликации будет автоматически сохранять xlog-файлы, необходимые для "
"удаленных реплик. Проблема `748 "
"<https://github.com/tarantool/tarantool/issues/748>`_."

#: ../doc/1.10/whats_new.rst:601
msgid ""
"Enabled :ref:`box.tuple.new() <box_tuple-new>` to work without "
"``box.cfg()``. Issue `2047 "
"<https://github.com/tarantool/tarantool/issues/2047>`_."
msgstr ""
" :ref:`box.tuple.new() <box_tuple-new>` впервые работает с ``box.cfg()``."
" Проблема `2047 <https://github.com/tarantool/tarantool/issues/2047>`_."

#: ../doc/1.10/whats_new.rst:603
msgid ""
":ref:`box.atomic(fun, ...) <box-atomic>` wrapper to execute function in a"
" transaction. Issue `818 "
"<https://github.com/tarantool/tarantool/issues/818>`_."
msgstr ""
"Надстройка :ref:`box.atomic(fun, ...) <box-atomic>` будет выполнять "
"функции в транзакции. Проблема `818 "
"<https://github.com/tarantool/tarantool/issues/818>`_."

#: ../doc/1.10/whats_new.rst:605
msgid ""
":ref:`box.session.type() <box_session-type>` helper to determine session "
"type. Issue `2642 <https://github.com/tarantool/tarantool/issues/2642>`_."
msgstr ""
"Вспомогательная функция :ref:`box.session.type() <box_session-type>` "
"будет определять тип сессии. Проблема `2642 "
"<https://github.com/tarantool/tarantool/issues/2642>`_."

#: ../doc/1.10/whats_new.rst:607
msgid ""
"Hot code :ref:`reload <box_schema-func_reload>` for stored C stored "
"procedures. Use ``box.schema.func.reload('modulename.function')`` to "
"reload dynamic shared libraries on the fly. Issue `910 "
"<https://github.com/tarantool/tarantool/issues/910>`_."
msgstr ""
"Горячая :ref:`перезагрузка кода <box_schema-func_reload>` для хранимых "
"процедур на языке C. Используйте "
"``box.schema.func.reload('modulename.function')`` для перезагрузки "
"библиотек общего пользования на лету. Проблема `910 "
"<https://github.com/tarantool/tarantool/issues/910>`_."

#: ../doc/1.10/whats_new.rst:611
msgid ""
":ref:`string.hex() <string-hex>` and ``str:hex()`` Lua API. Issue `2522 "
"<https://github.com/tarantool/tarantool/issues/2522>`_."
msgstr ""
"API для Lua: :ref:`string.hex() <string-hex>` и ``str:hex()``. Проблема "
"`2522 <https://github.com/tarantool/tarantool/issues/2522>`_."

#: ../doc/1.10/whats_new.rst:613
msgid ""
"Package manager based on LuaRocks. Use ``tarantoolctl rocks install "
"MODULENAME`` to install MODULENAME Lua module from "
"https://rocks.tarantool.org/. Issue `2067 "
"<https://github.com/tarantool/tarantool/issues/2067>`_."
msgstr ""
"Менеджер пакетов на основе LuaRocks. Используйте ``tarantoolctl rocks "
"install MODULENAME`` для установки Lua-модуля MODULENAME (имя модуля) из "
"https://rocks.tarantool.org/. Проблема `2067 "
"<https://github.com/tarantool/tarantool/issues/2067>`_."

#: ../doc/1.10/whats_new.rst:617
msgid ""
"Lua 5.1 command line options. Tarantool binary now supports '-i', '-e', "
"'-m' and '-l' command line options. Issue `1265 "
"<https://github.com/tarantool/tarantool/issues/1265>`_."
msgstr ""
"Опции командной строки в Lua 5.1. Бинарный протокол Tarantool'а "
"поддерживает опции командной строки: '-i', '-e', '-m' и '-l'. Проблема "
"`1265 <https://github.com/tarantool/tarantool/issues/1265>`_."

#: ../doc/1.10/whats_new.rst:620
msgid ""
"Experimental GC64 mode for LuaJIT. GC64 mode allow to operate the full "
"address space on 64-bit hosts. Enable via ``-DLUAJIT_ENABLE_GC64=ON "
"compile-time`` configuration option. Issue `2643 "
"<https://github.com/tarantool/tarantool/issues/2643>`_."
msgstr ""
"Экспериментальный режим GC64 для LuaJIT. Режим GC64 позволяет работать со"
" спейсами с полным адресом на 64-битных хостах. Включить настройку можно "
"с помощью ``-DLUAJIT_ENABLE_GC64=ON compile-time``. Проблема `2643 "
"<https://github.com/tarantool/tarantool/issues/2643>`_."

#: ../doc/1.10/whats_new.rst:624
msgid ""
"Syslog logger now support non-blocking mode. "
":ref:`box.cfg{log_nonblock=true} <cfg_logging-log_nonblock>` now also "
"works for syslog logger. Issue `2466 "
"<https://github.com/tarantool/tarantool/issues/2466>`_."
msgstr ""
"Регистратор журнала syslog поддерживает неблокирующий режим. "
":ref:`box.cfg{log_nonblock=true} <cfg_logging-log_nonblock>` также "
"работает для регистратора syslog. Проблема `2466 "
"<https://github.com/tarantool/tarantool/issues/2466>`_."

#: ../doc/1.10/whats_new.rst:627
msgid ""
"Added a VERBOSE :ref:`log level <cfg_logging-log_level>` beyond INFO. "
"Issue `2467 <https://github.com/tarantool/tarantool/issues/2467>`_."
msgstr ""
"Добавлен уровень :ref:`записи в журнал <cfg_logging-log_level>` VERBOSE "
"выше INFO. Проблема `2467 "
"<https://github.com/tarantool/tarantool/issues/2467>`_."

#: ../doc/1.10/whats_new.rst:629
msgid ""
"Tarantool now automatically makes snapshots every hour. Please set "
":ref:`box.cfg{checkpoint_interval=0  <cfg_checkpoint_daemon-"
"checkpoint_interval>` to restore pre-1.7.5 behaviour. Issue `2496 "
"<https://github.com/tarantool/tarantool/issues/2496>`_."
msgstr ""
"Tarantool автоматически делает снимки каждый час. Установите "
":ref:`box.cfg{checkpoint_interval=0  <cfg_checkpoint_daemon-"
"checkpoint_interval>`, чтобы восстановить поведение предыдущих версий. "
"Проблема `2496 <https://github.com/tarantool/tarantool/issues/2496>`_."

#: ../doc/1.10/whats_new.rst:632
msgid ""
"Increase precision for percentage ratios provoded by "
":ref:`box.slab.info() <box_slab_info>`. Issue `2082 "
"<https://github.com/tarantool/tarantool/issues/2082>`_."
msgstr ""
"Увеличена точность для процентного соотношения, приведенного с помощью "
":ref:`box.slab.info() <box_slab_info>`. Проблема `2082 "
"<https://github.com/tarantool/tarantool/issues/2082>`_."

#: ../doc/1.10/whats_new.rst:634
msgid ""
"Stack traces now contain symbols names on all supported platforms. "
"Previous versions of Tarantool didn't display meaningful function names "
"in :ref:`fiber.info() <fiber-info>` on non-x86 platforms. Issue `2103 "
"<https://github.com/tarantool/tarantool/issues/2103>`_."
msgstr ""
"Трассировка стека будет содержать имена символов на всех поддерживаемых "
"платформах. В предыдущих версиях Tarantool не отображал значимые имена "
"функций в :ref:`fiber.info() <fiber-info>` на платформах не-x86. Проблема"
" `2103 <https://github.com/tarantool/tarantool/issues/2103>`_."

#: ../doc/1.10/whats_new.rst:638
msgid ""
"Allowed to create fiber with custom stack size from C API. Issue `2438 "
"<https://github.com/tarantool/tarantool/issues/2438>`_."
msgstr ""
"Появилась возможность создания файбера с заданным размером стека из API "
"для языка C. Проблема `2438 "
"<https://github.com/tarantool/tarantool/issues/2438>`_."

#: ../doc/1.10/whats_new.rst:640
msgid ""
"Added ``ipc_cond`` to public C API. Issue `1451 "
"<https://github.com/tarantool/tarantool/issues/1451>`_."
msgstr ""
"В API для языка C добавлена функция ``ipc_cond``. Проблема `1451 "
"<https://github.com/tarantool/tarantool/issues/1451>`_."

#: ../doc/1.10/whats_new.rst:645
msgid ""
":ref:`http.client <http-module>` (built-in) - libcurl-based HTTP client "
"with SSL/TLS support. Issue `2083 "
"<https://github.com/tarantool/tarantool/issues/x2083>`_."
msgstr ""
":ref:`http.client <http-module>` (встроенная) - HTTP-клиент на основе "
"libcurl с поддержкой SSL/TLS. Проблема `2083 "
"<https://github.com/tarantool/tarantool/issues/x2083>`_."

#: ../doc/1.10/whats_new.rst:647
msgid ""
":ref:`iconv <iconv-converter>` (built-in) - bindings for iconv. Issue "
"`2587 <https://github.com/tarantool/tarantool/issues/2587>`_."
msgstr ""
":ref:`iconv <iconv-converter>` (встроенная) - привязки для iconv. "
"Проблема `2587 <https://github.com/tarantool/tarantool/issues/2587>`_."

#: ../doc/1.10/whats_new.rst:649
msgid ""
"`authman <https://github.com/mailru/tarantool-authman>`_ - API for user "
"registration and login in your site using email and social networks."
msgstr ""
"`authman <https://github.com/mailru/tarantool-authman>`_ - API для "
"регистрации пользователя и входа в систему с использованием email и "
"социальных сетей."

#: ../doc/1.10/whats_new.rst:651
msgid ""
"`document <https://github.com/tarantool/document>`_ - store nested "
"documents in Tarantool."
msgstr ""
"`document <https://github.com/tarantool/document>`_ - хранит вложенные "
"документы в Tarantool'е."

#: ../doc/1.10/whats_new.rst:652
msgid ""
"`synchronized <https://github.com/tarantool/synchronized>`_ - critical "
"sections for Lua."
msgstr ""
"`synchronized <https://github.com/tarantool/synchronized>`_ - критические"
" секции для Lua."

#: ../doc/1.10/whats_new.rst:656
msgid "**Release 1.7.4**"
msgstr "**Версия 1.7.4**"

#: ../doc/1.10/whats_new.rst:658
msgid ""
"Release type: release candidate. Release date: 2017-05-12. Release tag: "
"Tag: 1.7.4."
msgstr ""
"Тип версии: предварительная версия. Дата выхода: 2017-05-12.  Тег версии:"
" 1.7.4."

#: ../doc/1.10/whats_new.rst:660
msgid ""
"Announcement: https://github.com/tarantool/tarantool/releases/tag/1.7.4 "
"or https://groups.google.com/forum/#!topic/tarantool/3x88ATX9YbY"
msgstr ""
"Объявление о выходе: "
"https://github.com/tarantool/tarantool/releases/tag/1.7.4 или "
"https://groups.google.com/forum/#!topic/tarantool/3x88ATX9YbY"

#: ../doc/1.10/whats_new.rst:663
msgid ""
"This is a release candidate in the 1.7 series. Vinyl Engine, the flagship"
" feature of 1.7.x, is now feature complete."
msgstr ""
"Данная сборка представляет собой предварительную версию перед выпуском "
"нового релиза в серии 1.7. Движок vinyl, ключевой компонент 1.7.x, "
"обладает полностью реализованной заявленной функциональностью."

#: ../doc/1.10/whats_new.rst:666
msgid "Incompatible changes"
msgstr "Несовместимые изменения"

#: ../doc/1.10/whats_new.rst:668
msgid "``box.cfg()`` options were changed to add Vinyl support:"
msgstr ""
"Для поддержки vinyl были внесены следующие изменения в параметры "
"``box.cfg()``:"

#: ../doc/1.10/whats_new.rst:670
msgid "``snap_dir`` renamed to ``memtx_dir``"
msgstr "переименование ``snap_dir`` в ``memtx_dir``"

#: ../doc/1.10/whats_new.rst:671
msgid ""
"``slab_alloc_arena`` (gigabytes) renamed to ``memtx_memory`` (bytes), "
"default value changed from 1Gb to 256MB"
msgstr ""
"переименование ``slab_alloc_arena`` (гигабайты) в ``memtx_memory`` "
"(байты), значение, используемое по умолчанию, изменилось с 1 Гб на 256 МБ"

#: ../doc/1.10/whats_new.rst:673
msgid "``slab_alloc_minimal`` renamed to ``memtx_min_tuple_size``"
msgstr "переименование ``slab_alloc_minimal`` в ``memtx_min_tuple_size``"

#: ../doc/1.10/whats_new.rst:674
msgid "``slab_alloc_maximal`` renamed to ``memtx_max_tuple_size``"
msgstr "переименование ``slab_alloc_maximal`` в ``memtx_max_tuple_size``"

#: ../doc/1.10/whats_new.rst:675
msgid "``slab_alloc_factor`` is deprecated, not relevant in 1.7.x"
msgstr "``slab_alloc_factor`` больше не используется, не применимо в 1.7.x"

#: ../doc/1.10/whats_new.rst:676
msgid "``snapshot_count`` renamed to ``checkpoint_count``"
msgstr "переименование ``snapshot_count`` в ``checkpoint_count``"

#: ../doc/1.10/whats_new.rst:677
msgid "``snapshot_period`` renamed to ``checkpoint_interval``"
msgstr "переименование ``snapshot_period`` в ``checkpoint_interval``"

#: ../doc/1.10/whats_new.rst:678
msgid "``logger`` renamed to ``log``"
msgstr "переименование ``logger`` в ``log``"

#: ../doc/1.10/whats_new.rst:679
msgid "``logger_nonblock`` renamed to ``log_nonblock``"
msgstr "переименование ``logger_nonblock`` в ``log_nonblock``"

#: ../doc/1.10/whats_new.rst:680
msgid "``logger_level`` renamed to ``log_level``"
msgstr "переименование ``logger_level`` в ``log_level``"

#: ../doc/1.10/whats_new.rst:681
msgid "``replication_source`` renamed to ``replication``"
msgstr "переименование ``replication_source`` в ``replication``"

#: ../doc/1.10/whats_new.rst:682
msgid ""
"``panic_on_snap_error = true`` and ``panic_on_wal_error = true`` "
"superseded by ``force_recovery = false``"
msgstr ""
"``panic_on_snap_error = true`` и ``panic_on_wal_error = true`` заменены "
"``force_recovery = false``"

#: ../doc/1.10/whats_new.rst:685
msgid ""
"Until Tarantool 1.8, you can use deprecated parameters for both initial "
"and runtime configuration, but such usage will print a warning in the "
"server log. Issues `1927 "
"<https://github.com/tarantool/tarantool/issues/1927>`_ and `2042 "
"<https://github.com/tarantool/tarantool/issues/2042>`_."
msgstr ""
"В версиях Tarantool'а до 1.8 можно использовать устаревшие параметры как "
"для начальной, так и для рабочей конфигурации, но в таком случае система "
"запишет сообщение предупреждения в журнал сервера. Проблемы `1927 "
"<https://github.com/tarantool/tarantool/issues/1927>`_ и `2042 "
"<https://github.com/tarantool/tarantool/issues/2042>`_."

#: ../doc/1.10/whats_new.rst:691
msgid ""
"Hot standy mode is now off by default. Tarantool automatically detects "
"another running instance in the same ``wal_dir`` and refuses to start. "
"Use ``box.cfg {hot_standby = true}`` to enable the hot standby mode. "
"Issue `775 <https://github.com/tarantool/tarantool/issues/775>`_."
msgstr ""
"Режим hot standby (горячее резервирование) по умолчанию будет отключен. "
"Tarantool автоматически находит еще один запущенный экземпляр в той же "
"директории ``wal_dir`` и откажется запускаться. Используйте ``box.cfg "
"{hot_standby = true}`` для включения режима hot standby. Проблема `775 "
"<https://github.com/tarantool/tarantool/issues/775>`_."

#: ../doc/1.10/whats_new.rst:695
msgid ""
"UPSERT via a secondary key was banned to avoid unclear semantics. Issue "
"`2226 <https://github.com/tarantool/tarantool/issues/2226>`_."
msgstr ""
"Операция UPSERT по вторичному ключу запрещена во избежание "
"неопределенности семантики. Проблема `2226 "
"<https://github.com/tarantool/tarantool/issues/2226>`_."

#: ../doc/1.10/whats_new.rst:697
msgid ""
"``box.info`` and ``box.info.replication`` format was changed to display "
"information about upstream and downstream connections (Issue `723 "
"<https://github.com/tarantool/tarantool/issues/723>`_):"
msgstr ""
"В формат ``box.info`` и ``box.info.replication`` для отображения "
"информации о подключениях к upstream и downstream внесены следующие "
"изменения (Проблема `723 "
"<https://github.com/tarantool/tarantool/issues/723>`_):"

#: ../doc/1.10/whats_new.rst:701
msgid ""
"Added ``box.info.replication[instance_id].downstream.vclock`` to display "
"the last sent row to remote replica."
msgstr ""
"Добавление ``box.info.replication[instance_id].downstream.vclock`` для "
"отображения последней строки, отправленной на удаленную реплику."

#: ../doc/1.10/whats_new.rst:703
msgid "Added ``box.info.replication[instance_id].id``."
msgstr "Добавление ``box.info.replication[instance_id].id``."

#: ../doc/1.10/whats_new.rst:704
msgid "Added ``box.info.replication[instance_id].lsn``."
msgstr "Добавление ``box.info.replication[instance_id].lsn``."

#: ../doc/1.10/whats_new.rst:705
msgid ""
"Moved ``box.info.replication[instance_id].{vclock,status,error}`` to "
"``box.info.replication[instance_id].upstream.{vclock,status,error}``."
msgstr ""
"Перемещение ``box.info.replication[instance_id].{vclock,status,error}`` в"
" ``box.info.replication[instance_id].upstream.{vclock,status,error}``."

#: ../doc/1.10/whats_new.rst:707
msgid ""
"All registered replicas from ``box.space._cluster`` are included to "
"``box.info.replication`` output."
msgstr ""
"Включение всех зарегистрированных реплик из ``box.space._cluster`` в "
"вывод ``box.info.replication``."

#: ../doc/1.10/whats_new.rst:709
msgid "``box.info.server.id`` renamed ``box.info.id``"
msgstr "Переименование ``box.info.server.id`` в ``box.info.id``"

#: ../doc/1.10/whats_new.rst:710
msgid "``box.info.server.lsn`` renamed ``box.info.lsn``"
msgstr "Переименование ``box.info.server.lsn`` в ``box.info.lsn``"

#: ../doc/1.10/whats_new.rst:711
msgid "``box.info.server.uuid`` renamed ``box.info.uuid``"
msgstr "Переименование ``box.info.server.uuid`` в ``box.info.uuid``"

#: ../doc/1.10/whats_new.rst:712
msgid "``box.info.cluster.signature`` renamed to ``box.info.signature``"
msgstr "Переименование ``box.info.cluster.signature`` в ``box.info.signature``"

#: ../doc/1.10/whats_new.rst:713
msgid ""
"``box.info.id`` and ``box.info.lsn`` now return `nil` instead of `-1` "
"during initial cluster bootstrap."
msgstr ""
"Возврат значения `nil` вместо `-1` функциями ``box.info.id`` и "
"``box.info.lsn`` во время начальной настройки кластера."

#: ../doc/1.10/whats_new.rst:716
msgid "``net.box``: added per-request options to all requests:"
msgstr "``net.box``: добавление запрошенные параметров во все запросы:"

#: ../doc/1.10/whats_new.rst:718
msgid ""
"``conn.call(func_name, arg1, arg2,...)`` changed to "
"``conn.call(func_name, {arg1, arg2, ...}, opts)``"
msgstr ""
"изменение ``conn.call(func_name, arg1, arg2,...)`` на "
"``conn.call(func_name, {arg1, arg2, ...}, opts)``"

#: ../doc/1.10/whats_new.rst:720
msgid ""
"``conn.eval(func_name, arg1, arg2,...)`` changed to "
"``conn.eval(func_name, {arg1, arg2, ...}, opts)``"
msgstr ""
"изменение ``conn.eval(func_name, arg1, arg2,...)`` на "
"``conn.eval(func_name, {arg1, arg2, ...}, opts)``"

#: ../doc/1.10/whats_new.rst:723
msgid ""
"All requests now support ``timeout = <seconds>``, ``buffer = <ibuf>`` "
"options."
msgstr ""
"Все запросы поддерживают параметры ``timeout = <seconds>``(время задержки"
" в секундах), ``buffer = <ibuf>`` (буфер)."

#: ../doc/1.10/whats_new.rst:724
msgid "Added ``connect_timeout`` option to ``netbox.connect()``."
msgstr "Добавление опции ``connect_timeout`` в ``netbox.connect()``."

#: ../doc/1.10/whats_new.rst:725
msgid ""
"``netbox:timeout()`` and ``conn:timeout()`` are now deprecated. Use "
"``netbox.connect(host, port, { call_16 = true })`` for 1.6.x-compatible "
"behavior. Issue `2195 "
"<https://github.com/tarantool/tarantool/issues/2195>`_."
msgstr ""
"``netbox:timeout()`` и ``conn:timeout()`` объявлены устаревшими. "
"Используйте ``netbox.connect(host, port, { call_16 = true })``, чтобы "
"получить поведение как в 1.6.x. Проблема `2195 "
"<https://github.com/tarantool/tarantool/issues/2195>`_."

#: ../doc/1.10/whats_new.rst:729
msgid ""
"systemd configuration changed to support ``Type=Notify`` / "
"``sd_notify()``. Now ``systemctl start tarantool@INSTANCE`` will wait "
"until Tarantool has started and recovered from xlogs. The recovery status"
" is reported to ``systemctl status tarantool@INSTANCE``. Issue `1923 "
"<https://github.com/tarantool/tarantool/issues/1923>`_."
msgstr ""
"Конфигурация systemd будет поддерживать ``Type=Notify`` / "
"``sd_notify()``. ``systemctl start tarantool@ЭКЗЕМПЛЯР`` будет ожидать, "
"пока Tarantool не запустится и не восстановится из xlog-файлов. Статус "
"восстановления передается в ``systemctl status tarantool@ЭКЗЕМПЛЯР``. "
"Проблема `1923 <https://github.com/tarantool/tarantool/issues/1923>`_."

#: ../doc/1.10/whats_new.rst:734
msgid ""
"``log`` module now doesn't prefix all messages with the full path to "
"tarantool binary when used without ``box.cfg()``. Issue `1876 "
"<https://github.com/tarantool/tarantool/issues/1876>`_."
msgstr ""
"Модуль ``log`` не будет присоединять ко всем сообщениям полный путь к "
"бинарному файлу при использовании без ``box.cfg()``. Проблема `1876 "
"<https://github.com/tarantool/tarantool/issues/1876>`_."

#: ../doc/1.10/whats_new.rst:737
msgid ""
"``require('log').logger_pid()`` was renamed to ``require('log').pid()``. "
"Issue `2917 <https://github.com/tarantool/tarantool/issues/2917>`_."
msgstr ""
"Переименование ``require('log').logger_pid()`` в "
"``require('log').pid()``. Проблема `2917 "
"<https://github.com/tarantool/tarantool/issues/2917>`_."

#: ../doc/1.10/whats_new.rst:739
msgid ""
"Removed Lua 5.0 compatible defines and functions (Issue `2396 "
"<https://github.com/tarantool/tarantool/issues/2396>`_):"
msgstr ""
"Удаленные определения и функции, совместимые с Lua 5.0 (Проблема `2396 "
"<https://github.com/tarantool/tarantool/issues/2396>`_):"

#: ../doc/1.10/whats_new.rst:742
msgid "``luaL_reg`` removed in favor of ``luaL_Reg``"
msgstr "``luaL_Reg`` заменяет удаленный ``luaL_reg``"

#: ../doc/1.10/whats_new.rst:743
msgid "``luaL_getn(L, i)`` removed in favor of ``lua_objlen(L, i)``"
msgstr "``lua_objlen(L, i)`` заменяет удаленный ``luaL_getn(L, i)``"

#: ../doc/1.10/whats_new.rst:744
msgid "``luaL_setn(L, i, j)`` removed (was no-op)"
msgstr "Удаление ``luaL_setn(L, i, j)`` (пустая операция)"

#: ../doc/1.10/whats_new.rst:745
msgid "``lua_ref(L, lock)`` removed in favor of ``luaL_ref(L, lock)``"
msgstr "``luaL_ref(L, lock)`` заменяет удаленный ``lua_ref(L, lock)``"

#: ../doc/1.10/whats_new.rst:746
msgid ""
"``lua_getref(L,ref)`` removed in favor of ``lua_rawgeti(L, "
"LUA_REGISTRYINDEX, (ref))``"
msgstr ""
"``lua_rawgeti(L, LUA_REGISTRYINDEX, (ref))`` заменяет удаленный "
"``lua_getref(L,ref)``"

#: ../doc/1.10/whats_new.rst:747
msgid "``lua_unref(L, ref)`` removed in favor of ``luaL_unref(L, ref)``"
msgstr "``luaL_unref(L, ref)`` заменяет удаленный ``lua_unref(L, ref)``."

#: ../doc/1.10/whats_new.rst:748
msgid "``math.mod()`` removed in favor of ``math.fmod()``"
msgstr "``math.fmod()`` заменяет удаленный ``math.mod()``"

#: ../doc/1.10/whats_new.rst:749
msgid "``string.gfind()`` removed in favor of ``string.gmatch()``"
msgstr "``string.gmatch()`` заменяет удаленный ``string.gfind()``"

#: ../doc/1.10/whats_new.rst:753
msgid ""
"(Vinyl) multi-level compaction. The compaction scheduler now groups runs "
"of the same range into levels to reduce the write amplification during "
"compaction. This design allows Vinyl to support 1:100+ ram:disk use-"
"cases. Issue `1821 "
"<https://github.com/tarantool/tarantool/issues/1821>`_."
msgstr ""
"(Vinyl) многоуровневое слияние. Планировщик слияния будет группировать "
"забеги одного диапазона в уровни, чтобы снизить \"паразитную\" запись во "
"время слияния. Новая функция позволит Vinyl'у поддерживать сценарии "
"1:100+ оперативная память:диск. Проблема `1821 "
"<https://github.com/tarantool/tarantool/issues/1821>`_."

#: ../doc/1.10/whats_new.rst:758
msgid ""
"(Vinyl) bloom filters for sorted runs. Bloom filter is a probabilistic "
"data structure which can be used to test whether a requested key is "
"present in a run file without reading the actual file from the disk. "
"Bloom filter may have false-positive matches but false-negative matches "
"are impossible. This feature reduces the number of seeks needed for "
"random lookups and speeds up REPLACE/DELETE with enabled secondary keys. "
"Issue `1919 <https://github.com/tarantool/tarantool/issues/1919>`_."
msgstr ""
"(Vinyl) Фильтры Блума для упорядоченных файлов. Фильтр Блума -- это "
"вероятностная структура данных, которую можно использовать для проверки "
"наличия необходимого ключа в файле без считывания самого файла с диска. "
"Фильтр Блума может выдавать ложноположительное срабатывание (элемента в "
"множестве нет, но структура данных сообщает, что он есть), но "
"не ложноотрицательное. Данная функция уменьшает объем поиска, необходимый"
" для случайного просмотра, и ускоряет операции REPLACE/DELETE со "
"вторичными ключами. Проблема `1919 "
"<https://github.com/tarantool/tarantool/issues/1919>`_."

#: ../doc/1.10/whats_new.rst:766
msgid ""
"(Vinyl) key-level cache for point lookups and range queries. Vinyl "
"storage engine caches selected keys and key ranges instead of entire disk"
" pages like in traditional databases. This approach is more efficient "
"because the cache is not polluted with raw disk data. Issue `1692 "
"<https://github.com/tarantool/tarantool/issues/1692>`_."
msgstr ""
"(Vinyl) кэш на уровне ключей для поиска точек и запросов по диапазону. "
"Движок базы данных Vinyl кэширует выбранные ключи и диапазоны ключей "
"вместо страниц диска полностью, как в традиционных базах данных. Такой "
"подход более эффективен, поскольку кэш не заполнен сырыми данными. "
"Проблема `1692 <https://github.com/tarantool/tarantool/issues/1692>`_."

#: ../doc/1.10/whats_new.rst:771
msgid ""
"(Vinyl) implemented the common memory level for in-memory indexes. Now "
"all in-memory indexes of a space store pointers to the same tuples "
"instead of cached secondary key index data. This feature significantly "
"reduces the memory footprint in case of secondary keys. Issue `1908 "
"<https://github.com/tarantool/tarantool/issues/1908>`_."
msgstr ""
"(Vinyl) внедрение уровня общей памяти для in-memory индексов. Все in-"
"memory индексы спейса будут хранить указатели на одни и те же кортежи, "
"вместо закэшированных данных вторичного индекса. Данная функция "
"значительно уменьшает объем необходимой памяти в случае вторичных ключей."
" Проблема `1908 <https://github.com/tarantool/tarantool/issues/1908>`_."

#: ../doc/1.10/whats_new.rst:776
msgid ""
"(Vinyl) new implementation of initial state transfer of JOIN command in "
"replication protocol. New replication protocol fixes problems with "
"consistency and secondary keys. We implemented a special kind of low-cost"
" database-wide read-view to avoid dirty reads in JOIN procedure. This "
"trick wasn't not possible in traditional B-Tree based databases. Issue "
"`2001 <https://github.com/tarantool/tarantool/issues/2001>`_."
msgstr ""
"(Vinyl) новая реализация передачи начального состояния JOIN-команды в "
"протоколе репликации. Новый протокол репликации исправляет проблемы с "
"согласованностью и вторичными ключами. Мы внедрили специальный вид "
"просмотра по всей базе данных с небольшой нагрузкой, чтобы избежать "
"неподтвержденного чтения в JOIN-процедуре. В традиционных базах данных на"
" основе B-Tree такое не представляется возможным. Проблема `2001 "
"<https://github.com/tarantool/tarantool/issues/2001>`_."

#: ../doc/1.10/whats_new.rst:782
msgid ""
"(Vinyl) index-wide mems/runs. Removed ranges from in-memory and and the "
"stop layer of LSM tree on disk. Issue `2209 "
"<https://github.com/tarantool/tarantool/issues/2209>`_."
msgstr ""
"(Vinyl) забеги по всему индексу. Удалены диапазоны из оперативной памяти "
"и уровень LSM-дерева на диске. Проблема `2209 "
"<https://github.com/tarantool/tarantool/issues/2209>`_."

#: ../doc/1.10/whats_new.rst:785
msgid ""
"(Vinyl) coalesce small ranges. Before dumping or compacting a range, "
"consider coalescing it with its neighbors. Issue `1735 "
"<https://github.com/tarantool/tarantool/issues/1735>`_."
msgstr ""
"(Vinyl) объединение небольших диапазонов. Перед созданием дампа или "
"слиянием диапазона рассмотрите возможность объединения его с соседними "
"диапазонами. Проблема `1735 "
"<https://github.com/tarantool/tarantool/issues/1735>`_."

#: ../doc/1.10/whats_new.rst:789
msgid ""
"(Vinyl) implemented transnational journal for metadata. Now information "
"about all Vinyl files is logged in a special ``.vylog`` file. Issue `1967"
" <https://github.com/tarantool/tarantool/issues/1967>`_."
msgstr ""
"(Vinyl) внедрен многосторонний журнал для метаданных. Информация о всех "
"Vinyl-файлах будет записываться в специальный ``.vylog``-файл. Проблема "
"`1967 <https://github.com/tarantool/tarantool/issues/1967>`_."

#: ../doc/1.10/whats_new.rst:792
msgid ""
"(Vinyl) implemented consistent secondary keys. Issue `2410 "
"<https://github.com/tarantool/tarantool/issues/2410>`_."
msgstr ""
"(Vinyl) появились постоянные вторичные ключи. Проблема `2410 "
"<https://github.com/tarantool/tarantool/issues/2410>`_."

#: ../doc/1.10/whats_new.rst:794
msgid ""
"(Memtx+Vinyl) implemented low-level Lua API to create consistent backups."
" of Memtx + Vinyl data. The new feature provides "
"``box.backup.start()/stop()`` functions to create backups of all spaces. "
":ref:`box.backup.start() <admin-backups-backup_start>` pauses the "
"Tarantool garbage collector and returns the list of files to copy. These "
"files then can be copied be any third-party tool, like cp, ln, tar, "
"rsync, etc. ``box.backup.stop()`` lets the garbage collector continue. "
"Created backups can be restored instantly by copying into a new directory"
" and starting a new Tarantool instance. No special preparation, "
"conversion or unpacking is needed. Issue `1916 "
"<https://github.com/tarantool/tarantool/issues/1916>`_."
msgstr ""
"(Memtx+Vinyl) внедрен низкоуровневый API для Lua в целях создания "
"согласованных резервных копий данных Memtx + Vinyl. Новая "
"функциональность обеспечивает создание резервных копий всех спейсов с "
"помощью функций ``box.backup.start()/stop()``. :ref:`box.backup.start() "
"<admin-backups-backup_start>` останавливает работу сборщика мусора "
"Tarantool'а и возвращает список файлов для копирования. Затем эти файлы "
"можно скопировать с помощью любого стороннего средства, например, cp, ln,"
" tar, rsync и т.д. ``box.backup.stop()`` возобновляет работу сборщика "
"мусора. Чтобы немедленно восстановить данные, скопируйте созданные "
"резервные копии в новую директорию, а затем запустите новый экземпляр "
"Tarantool'а. Нет необходимости в дополнительной подготовке, "
"преобразовании или распаковывании. Проблема `1916 "
"<https://github.com/tarantool/tarantool/issues/1916>`_."

#: ../doc/1.10/whats_new.rst:805
msgid ""
"(Vinyl) added statistics for background workers to ``box.info.vinyl()``. "
"Issue `2005 <https://github.com/tarantool/tarantool/issues/2005>`_."
msgstr ""
"(Vinyl) добавлена статистика для фоновых рабочих процессов в "
"``box.info.vinyl()``. Проблема `2005 "
"<https://github.com/tarantool/tarantool/issues/2005>`_."

#: ../doc/1.10/whats_new.rst:807
msgid ""
"(Memtx+Vinyl) reduced the memory footprint for indexes which keys are "
"sequential and start from the first field. This optimization was "
"necessary for secondary keys in Vinyl, but we optimized Memtx as well. "
"Issue `2046 <https://github.com/tarantool/tarantool/issues/2046>`_."
msgstr ""
"(Memtx+Vinyl) уменьшен объем необходимой памяти для индексов с "
"последовательными ключами, которые начинаются с первого поля. Такая "
"оптимизация была необходима для вторичных ключей в Vinyl'е, но мы также "
"оптимизировали Memtx. Проблема `2046 "
"<https://github.com/tarantool/tarantool/issues/2046>`_."

#: ../doc/1.10/whats_new.rst:811
msgid ""
"LuaJIT was rebased on the latest 2.1.0b3 with out patches (Issue `2396 "
"<https://github.com/tarantool/tarantool/issues/2396>`_):"
msgstr ""
"LuaJIT получил все изменения с последней версии 2.1.0b3 с нашими патчами "
"(Проблема `2396 <https://github.com/tarantool/tarantool/issues/2396>`_):"

#: ../doc/1.10/whats_new.rst:814
msgid "Added JIT compiler backend for ARM64"
msgstr "Добавлен бэкенд для JIT-компилятора для архитектуры ARM64"

#: ../doc/1.10/whats_new.rst:815
msgid "Added JIT compiler backend and interpreter for MIPS64"
msgstr "Добавлен бэкенд и интерпретатор для JIT-компилятора для архитектуры MIPS64"

#: ../doc/1.10/whats_new.rst:816
msgid "Added some more Lua 5.2 and Lua 5.3 extensions"
msgstr "Добавлены некоторые расширения для Lua 5.2 и Lua 5.3"

#: ../doc/1.10/whats_new.rst:817
msgid "Fixed several bugs"
msgstr "Исправление нескольких ошибок"

#: ../doc/1.10/whats_new.rst:818
msgid "Removed Lua 5.0 legacy (see incompatible changes above)."
msgstr "Удалены устаревшие функции Lua 5.0 (см. несовместимые изменения выше)."

#: ../doc/1.10/whats_new.rst:820
msgid ""
"Enabled a new smart string hashing algorithm in LuaJIT to avoid "
"significant slowdown when a lot of collisions are generated. Contributed "
"by Yury Sokolov (@funny-falcon) and Nick Zavaritsky (@mejedi). See "
"https://github.com/tarantool/luajit/pull/2."
msgstr ""
"Запущен новый умный алгоритм хеширования строк в LuaJIT, чтобы избежать "
"замедления работы в случае множества коллизий. Разработали Юрий Соколов "
"(@funny-falcon) и Ник Заварицкий (@mejedi). См. "
"https://github.com/tarantool/luajit/pull/2."

#: ../doc/1.10/whats_new.rst:824
msgid ""
"``box.snapshot()`` now updates mtime of a snapshot file if there were no "
"changes to the database since the last snapshot. Issue `2045 "
"<https://github.com/tarantool/tarantl/issues/2045>`_."
msgstr ""
"``box.snapshot()`` теперь обновляет время mtime в файле снимка, если не "
"было изменений в базе данных с момента последнего снимка. Проблема `2045 "
"<https://github.com/tarantool/tarantl/issues/2045>`_."

#: ../doc/1.10/whats_new.rst:827
msgid ""
"Implemented ``space:bsize()`` to return the memory size utilized by all "
"tuples of the space. Contributed by Roman Tokarev (@rtokarev). Issue "
"`2043 <https://github.com/tarantool/tarantool/issues/2043>`_."
msgstr ""
"Внедрена функция ``space:bsize()`` для возврата объема памяти, занятого "
"всеми кортежами спейса. Разработал Роман Токарев (@rtokarev). Проблема "
"`2043 <https://github.com/tarantool/tarantool/issues/2043>`_."

#: ../doc/1.10/whats_new.rst:831
msgid "Exported new Lua/C functions to public API:"
msgstr "Новые функции Lua/C вынесены в общедоступный API:"

#: ../doc/1.10/whats_new.rst:833
msgid ""
"``luaT_pushtuple``, ``luaT_istuple`` (issue `1878 "
"<https://github.com/tarantool/tarantool/issues/1878>`_)"
msgstr ""
"``luaT_pushtuple``, ``luaT_istuple`` (проблема `1878 "
"<https://github.com/tarantool/tarantool/issues/1878>`_)"

#: ../doc/1.10/whats_new.rst:835
msgid ""
"``luaT_error``, ``luaT_call``, ``luaT_cpcall`` (issue `2291 "
"<https://github.com/tarantool/tarantool/issues/2291>`_)"
msgstr ""
"``luaT_error``, ``luaT_call``, ``luaT_cpcall`` (проблема `2291 "
"<https://github.com/tarantool/tarantool/issues/2291>`_)"

#: ../doc/1.10/whats_new.rst:837
msgid ""
"``luaT_state`` (issue `2416 "
"<https://github.com/tarantool/tarantool/issues/2416>`_)"
msgstr ""
"``luaT_state`` (проблема `2416 "
"<https://github.com/tarantool/tarantool/issues/2416>`_)"

#: ../doc/1.10/whats_new.rst:840
msgid ""
"Exported new Box/C functions to public API: ``box_key_def``, "
"``box_tuple_format``, ``tuple_compare()``, ``tuple_compare_with_key()``. "
"Issue `2225 <https://github.com/tarantool/tarantool/issues/2225>`_."
msgstr ""
"Новые функции Box/C вынесены в общедоступный API: ``box_key_def``, "
"``box_tuple_format``, ``tuple_compare()``, ``tuple_compare_with_key()``. "
"Проблема `2225 <https://github.com/tarantool/tarantool/issues/2225>`_."

#: ../doc/1.10/whats_new.rst:843
msgid ""
"xlogs now can be rotated based on size (``wal_max_size``) as well as the "
"number of written rows (``rows_per_wal``). Issue `173 "
"<https://github.com/tarantool/tarantool/issues/173>`_."
msgstr ""
"Можно осуществлять ротацию xlog-файлов на основе размера "
"(``wal_max_size``), а также количества записанных строк "
"(``rows_per_wal``). Проблема `173 "
"<https://github.com/tarantool/tarantool/issues/173>`_."

#: ../doc/1.10/whats_new.rst:846
msgid ""
"Added ``string.split()``, ``string.startswith()``, ``string.endswith()``,"
" ``string.ljust()``, ``string.rjust()``, ``string.center()`` API. Issues "
"`2211 <https://github.com/tarantool/tarantool/issues/2211>`_, `2214 "
"<https://github.com/tarantool/tarantool/issues/2214>`_, `2415 "
"<https://github.com/tarantool/tarantool/issues/2415>`_."
msgstr ""
"Добавлены следующие API: ``string.split()``, ``string.startswith()``, "
"``string.endswith()``, ``string.ljust()``, ``string.rjust()``, "
"``string.center()``. Проблемы `2211 "
"<https://github.com/tarantool/tarantool/issues/2211>`_, `2214 "
"<https://github.com/tarantool/tarantool/issues/2214>`_, `2415 "
"<https://github.com/tarantool/tarantool/issues/2415>`_."

#: ../doc/1.10/whats_new.rst:851
msgid ""
"Added ``table.copy()`` and ``table.deepcopy()`` functions. Issue `2212 "
"<https://github.com/tarantool/tarantool/issues/2412>`_."
msgstr ""
"Добавлены функции ``table.copy()`` и ``table.deepcopy()``. Проблема `2212"
" <https://github.com/tarantool/tarantool/issues/2412>`_."

#: ../doc/1.10/whats_new.rst:853
msgid ""
"Added ``pwd`` module to work with UNIX users and groups. Issue `2213 "
"<https://github.com/tarantool/tarantool/issues/2213>`_."
msgstr ""
"Добавлен модуль ``pwd`` для работы с пользователями и группами в UNIX. "
"Проблема `2213 <https://github.com/tarantool/tarantool/issues/2213>`_."

#: ../doc/1.10/whats_new.rst:855
msgid ""
"Removed noisy \"client unix/: connected\" messages from logs. Use "
"``box.session.on_connect()``/``on_disconnect()`` triggers instead. Issue "
"`1938 <https://github.com/tarantool/t`arantool/issues/1938>`_."
msgstr ""
"Удалены неуместные сообщения  \"client unix/: connected\" из журналов. "
"Используйте вместо них триггеры "
"``box.session.on_connect()``/``on_disconnect()`` (на подключение / "
"отключение). Проблема `1938 "
"<https://github.com/tarantool/t`arantool/issues/1938>`_."

#: ../doc/1.10/whats_new.rst:859
msgid ""
"``box.session.on_connect()``/``on_disconnect()``/``on_auth()`` triggers "
"now also fired for admin console connections."
msgstr ""
"Триггеры ``box.session.on_connect()``/``on_disconnect()``/``on_auth()`` "
"также срабатывают для подключений административной консоли."

#: ../doc/1.10/whats_new.rst:862
msgid ""
"tarantoolctl: ``eval``, ``enter``, ``connect`` commands now support UNIX "
"pipes. Issue `672 <https://github.com/tarantool/tarantool/issues/672>`_."
msgstr ""
"tarantoolctl: следующие команды: ``eval``, ``enter``, ``connect`` -- "
"теперь поддерживают конвейеры UNIX. Проблема `672 "
"<https://github.com/tarantool/tarantool/issues/672>`_."

#: ../doc/1.10/whats_new.rst:864
msgid ""
"tarantoolctl: improved error messages and added a new man page. Issue "
"`1488 <https://github.com/tarantool/tarantool/issues/1488>`_."
msgstr ""
"tarantoolctl: более точные сообщения об ошибке; добавлена новая страница "
"справочника. Проблема `1488 "
"<https://github.com/tarantool/tarantool/issues/1488>`_."

#: ../doc/1.10/whats_new.rst:866
msgid ""
"tarantoolctl: added filter by ``replica_id`` to ``cat`` and ``play`` "
"commands. Issue `2301 "
"<https://github.com/tarantool/tarantool/issues/2301>`_."
msgstr ""
"tarantoolctl: добавлен фильтр по ``replica_id`` для команд ``cat`` и "
"``play``. Проблема `2301 "
"<https://github.com/tarantool/tarantool/issues/2301>`_."

#: ../doc/1.10/whats_new.rst:868
msgid ""
"tarantoolctl: ``start``, ``stop`` and ``restart`` commands now redirect "
"to ``systemctl start/stop/restart`` when systemd is enabled. Issue `2254 "
"<https://github.com/tarantool/tarantool/issues/2254>`_."
msgstr ""
"tarantoolctl: Команды ``start``, ``stop`` и ``restart`` перенаправляют на"
" ``systemctl start/stop/restart``, когда запущен systemd. Проблема `2254 "
"<https://github.com/tarantool/tarantool/issues/2254>`_."

#: ../doc/1.10/whats_new.rst:871
msgid ""
"net.box: added ``buffer = <buffer>`` per-request option to store raw "
"MessagePack responses into a C buffer. Issue `2195 "
"<https://github.com/tarantool/tarantool/issues/2195>`_."
msgstr ""
"net.box: по запросу добавлена опция ``buffer = <buffer>`` для хранения "
"исходных ответов MessagePack в буфер C. Проблема `2195 "
"<https://github.com/tarantool/tarantool/issues/2195>`_."

#: ../doc/1.10/whats_new.rst:874
msgid ""
"net.box: added ``connect_timeout`` option. Issue `2054 "
"<https://github.com/tarantool/tarantool/issues/2054>`_."
msgstr ""
"net.box: добавлена опция ``connect_timeout``. Проблема `2054 "
"<https://github.com/tarantool/tarantool/issues/2054>`_."

#: ../doc/1.10/whats_new.rst:876
msgid ""
"net.box: added ``on_schema_reload()`` hook. Issue `2021 "
"<https://github.com/tarantool/tarantool/issues/2021>`_."
msgstr ""
"net.box: добавлена ловушка ``on_schema_reload()``. Проблема `2021 "
"<https://github.com/tarantool/tarantool/issues/2021>`_."

#: ../doc/1.10/whats_new.rst:878
msgid ""
"net.box: exposed ``conn.schema_version`` and ``space.connection`` to API."
" Issue `2412 <https://github.com/tarantool/tarantool/issues/2412>`_."
msgstr ""
"net.box: ``conn.schema_version`` и ``space.connection`` дополнены API. "
"Проблема `2412 <https://github.com/tarantool/tarantool/issues/2412>`_."

#: ../doc/1.10/whats_new.rst:880
msgid ""
"log: ``debug()``/``info()``/``warn()``/``error()`` now doesn't fail on "
"formatting errors. Issue `889 "
"<https://github.com/tarantool/tarantool/issues/889>`_."
msgstr ""
"log: ``debug()``/``info()``/``warn()``/``error()`` не выдают сбой при "
"ошибках форматирования. Проблема `889 "
"<https://github.com/tarantool/tarantool/issues/889>`_."

#: ../doc/1.10/whats_new.rst:883
msgid ""
"crypto: added HMAC support. Contributed by Andrey Kulikov (@amdei). Issue"
" `725 <https://github.com/tarantool/tarantool/issues/725>`_."
msgstr ""
"crypto: добавлена поддержка HMAC. Разработал Андрей Куликов (@amdei). "
"Проблема `725 <https://github.com/tarantool/tarantool/issues/725>`_."

#: ../doc/1.10/whats_new.rst:889
msgid "**Release 1.7.3**"
msgstr "**Версия 1.7.3**"

#: ../doc/1.10/whats_new.rst:891
msgid ""
"Release type: beta. Release date: 2016-12-24. Release tag: Tag: "
"1.7.3-0-gf0c92aa."
msgstr "Тип версии: бета. Дата выхода: 2016-12-24.  Тег версии: 1.7.3-0-gf0c92aa."

#: ../doc/1.10/whats_new.rst:893
msgid "Announcement: https://github.com/tarantool/tarantool/releases/tag/1.7.3"
msgstr ""
"Объявление о выходе: "
"https://github.com/tarantool/tarantool/releases/tag/1.7.3"

#: ../doc/1.10/whats_new.rst:895
msgid "This is the second beta release in the 1.7 series."
msgstr "Данная сборка представляет собой вторую бета-версию в серии 1.7."

#: ../doc/1.10/whats_new.rst:899
msgid ""
"Broken ``coredump()`` Lua function was removed. Use ``gdb -batch -ex "
"\"generate-core-file\" -p $PID`` instead. Issue `1886 "
"<https://github.com/tarantool/tarantool/issues/1886>`_."
msgstr ""
"Удалена поврежденная Lua-функция ``coredump()``. Используйте вместо нее "
"``gdb -batch -ex \"generate-core-file\" -p $PID``. Проблема `1886 "
"<https://github.com/tarantool/tarantool/issues/1886>`_."

#: ../doc/1.10/whats_new.rst:902
msgid ""
"Vinyl disk layout was changed since 1.7.2 to add ZStandard compression "
"and improve the performance of secondary keys. Use the replication "
"mechanism to upgrade from 1.7.2 beta. Issue `1656 "
"<https://github.com/tarantool/tarantool/issues/1656>`_."
msgstr ""
"Структура диска Vinyl изменилась с версии 1.7.2: добавлен механизм "
"компрессии ZStandard и улучшена производительность вторичных ключей. "
"Используйте механизм репликации для обновления с бета-версии 1.7.2. "
"Проблема `1656 <https://github.com/tarantool/tarantool/issues/1656>`_."

#: ../doc/1.10/whats_new.rst:909
msgid "Substantial progress on stabilizing the Vinyl storage engine:"
msgstr "Значительный прогресс в стабилизации движка базы данных Vinyl:"

#: ../doc/1.10/whats_new.rst:911
msgid "Fix most known crashes and bugs with bad results."
msgstr ""
"Исправлены большинство известных отказов системы и ошибок, выдающих "
"плохие результаты."

#: ../doc/1.10/whats_new.rst:912
msgid "Switch to use XLOG/SNAP format for all data files."
msgstr "Замена формата всех файлов с данными на XLOG/SNAP."

#: ../doc/1.10/whats_new.rst:913
msgid "Enable ZStandard compression for all data files."
msgstr "Использование механизма компрессии ZStandard для всех файлов с данными."

#: ../doc/1.10/whats_new.rst:914
msgid ""
"Squash UPSERT operations on the fly and merge hot keys using a background"
" fiber."
msgstr ""
"Сжатие операций UPSERT на лету и объединение горячих клавиш с помощью "
"фонового файбера."

#: ../doc/1.10/whats_new.rst:916
msgid "Significantly improve the performance of index:pairs() and index:count()."
msgstr "Значительное улучшение производительности index:pairs() и index:count()."

#: ../doc/1.10/whats_new.rst:917
msgid "Remove unnecessary conflicts from transactions."
msgstr "Удаление ненужных конфликтов из транзакций."

#: ../doc/1.10/whats_new.rst:918
msgid "In-memory level was mostly replaced by memtx data structures."
msgstr "Уровень In-memory по большей части заменен структурами данных  memtx."

#: ../doc/1.10/whats_new.rst:919
msgid "Specialized allocators are used in most places."
msgstr ""
"В большинстве случаев используются специализированные распределители "
"ресурсов."

#: ../doc/1.10/whats_new.rst:921
msgid ""
"We're still actively working on Vinyl and plan to add multi-level "
"compaction and improve the performance of secondary keys in 1.7.4. This "
"implies a data format change."
msgstr ""
"Мы все еще активно работаем над Vinyl'ом и планируем добавить "
"многоуровневое слияние и улучшить производительность в работе со "
"вторичными ключами в версии 1.7.4. Это подразумевает изменение формата "
"данных."

#: ../doc/1.10/whats_new.rst:924
msgid ""
"Support for DML requests for space:on_replace() triggers. Issue `587 "
"<https://github.com/tarantool/tarantool/issues/587>`_."
msgstr ""
"Поддержка DML-запросов для триггеров space:on_replace(). Проблема `587 "
"<https://github.com/tarantool/tarantool/issues/587>`_."

#: ../doc/1.10/whats_new.rst:926
msgid ""
"UPSERT can be used with the empty list of operations. Issue `1854 "
"<https://github.com/tarantool/tarantool/issues/1854>`_."
msgstr ""
"UPSERT можно использовать с пустым списком операций. Проблема `1854 "
"<https://github.com/tarantool/tarantool/issues/1854>`_."

#: ../doc/1.10/whats_new.rst:928
msgid ""
"Lua functions to manipulate environment variables. Issue `1718 "
"<https://github.com/tarantool/tarantool/issues/1718>`_."
msgstr ""
"Lua-функции будут управлять переменными окружения. Проблема `1718 "
"<https://github.com/tarantool/tarantool/issues/1718>`_."

#: ../doc/1.10/whats_new.rst:930
msgid ""
"Lua library to read Tarantool snapshots and xlogs. Issue `1782 "
"<https://github.com/tarantool/tarantool/issues/1782>`_."
msgstr ""
"Lua-библиотека будет считывать снимки Tarantool'а и xlog-файлы. Проблема "
"`1782 <https://github.com/tarantool/tarantool/issues/1782>`_."

#: ../doc/1.10/whats_new.rst:932
msgid ""
"New ``play`` and ``cat`` commands in ``tarantoolctl``. Issue `1861 "
"<https://github.com/tarantool/tarantool/issues/1861>`_."
msgstr ""
"Новые команды в ``tarantoolctl``: ``play`` и``cat``. Проблема `1861 "
"<https://github.com/tarantool/tarantool/issues/1861>`_."

#: ../doc/1.10/whats_new.rst:934
msgid ""
"Improve support for the large number of active network clients. "
"Issue#5#1892."
msgstr ""
"Улучшена поддержка большого количества активных сетевых клиентов. "
"Проблема #5#1892."

#: ../doc/1.10/whats_new.rst:936
msgid ""
"Support for ``space:pairs(key, iterator-type)`` syntax. Issue `1875 "
"<https://github.com/tarantool/tarantool/issues/1875>`_."
msgstr ""
"Поддержка синтаксиса ``space:pairs(key, iterator-type)``. Проблема `1875 "
"<https://github.com/tarantool/tarantool/issues/1875>`_."

#: ../doc/1.10/whats_new.rst:938
msgid ""
"Automatic cluster bootstrap now also works without authorization. Issue "
"`1589 <https://github.com/tarantool/tarantool/issues/1589>`_."
msgstr ""
"Автоматическая настройка кластера будет работать и без авторизации. "
"Проблема `1589 <https://github.com/tarantool/tarantool/issues/1589>`_."

#: ../doc/1.10/whats_new.rst:940
msgid ""
"Replication retries to connect to master indefinitely. Issue `1511 "
"<https://github.com/tarantool/tarantool/issues/1511>`_."
msgstr ""
"При репликации попытки повторного подключения к мастеру бесконечны. "
"Проблема `1511 <https://github.com/tarantool/tarantool/issues/1511>`_."

#: ../doc/1.10/whats_new.rst:942
msgid ""
"Temporary spaces now work with ``box.cfg { read_only = true }``. Issue "
"`1378 <https://github.com/tarantool/tarantool/issues/1378>`_."
msgstr ""
"Временные спейсы будут работать с ``box.cfg { read_only = true }``. "
"Проблема `1378 <https://github.com/tarantool/tarantool/issues/1378>`_."

#: ../doc/1.10/whats_new.rst:944
msgid ""
"The maximum length of space names increased to 64 bytes (was 32). Issue "
"`2008 <https://github.com/tarantool/tarantool/issues/2008>`_."
msgstr ""
"Максимальная длина имени спейса увеличена до 64 байтов (ранее 32). "
"Проблема `2008 <https://github.com/tarantool/tarantool/issues/2008>`_."

#: ../doc/1.10/whats_new.rst:949
msgid "**Release 1.7.2**"
msgstr "**Версия 1.7.2**"

#: ../doc/1.10/whats_new.rst:951
msgid ""
"Release type: beta. Release date: 2016-09-29. Release tag: Tag: "
"`1.7.2-1-g92ed6c4`."
msgstr ""
"Тип версии: бета. Дата выхода: 2016-09-29.  Тег версии: "
"`1.7.2-1-g92ed6c4`."

#: ../doc/1.10/whats_new.rst:953
msgid ""
"Announcement: https://groups.google.com/forum/#!topic/tarantool-"
"ru/qUYUesEhRQg"
msgstr ""
"Объявление о выходе: https://groups.google.com/forum/#!topic/tarantool-"
"ru/qUYUesEhRQg"

#: ../doc/1.10/whats_new.rst:955
msgid "This is a release in the 1.7 series."
msgstr "Данная сборка представляет собой версию в серии 1.7."

#: ../doc/1.10/whats_new.rst:959
msgid ""
"A new binary protocol command for CALL, which no more restricts a "
"function to returning an array of tuples and allows returning an "
"arbitrary MsgPack/JSON result, including scalars, nil and void (nothing)."
" The old CALL is left intact for backward compatibility. It will be "
"removed in the next major release. All programming language drivers will "
"be gradually changed to use the new CALL. Issue `1296 "
"<https://github.com/tarantool/tarantool/issues/1296>`_."
msgstr ""
"Команда нового бинарного протокола для вызова CALL больше не ограничивает"
" функцию в возврате массива кортежей и позволяет возвращать произвольный "
"результат в формате MsgPack/JSON, включая scalar (скалярные значения), "
"nil (нулевые значения) и void (пусто). Старый метод CALL оставлен "
"нетронутым для обратной совместимости. В следующей основной версии он "
"будет удален. Все драйверы для языков программирования будут постепенно "
"переведены на использование нового метода CALL. Проблема `1296 "
"<https://github.com/tarantool/tarantool/issues/1296>`_."

#: ../doc/1.10/whats_new.rst:969
msgid ""
"Vinyl storage engine finally reached the beta stage. This release fixes "
"more than 90 bugs in Vinyl, in particular, removing unpredictable latency"
" spikes, all known crashes and bad/lost result bugs."
msgstr ""
"Разработка движка базы данных Vinyl, наконец, перешла в бета-стадию. В "
"данной версии исправлены более 90 ошибок в Vinyl'е, в частности, удаление"
" непредсказуемых скачков задержки отклика, все известные отказы системы и"
" ошибки, выдающие плохие результаты или их отсутствие."

#: ../doc/1.10/whats_new.rst:973
msgid ""
"new cooperative multitasking based architecture to eliminate latency "
"spikes,"
msgstr ""
"новая архитектура на основе кооперативной многозадачности для устранения "
"скачков задержки отклика,"

#: ../doc/1.10/whats_new.rst:974
msgid "support for non-sequential multi-part keys,"
msgstr "поддержка непоследовательных составных ключей,"

#: ../doc/1.10/whats_new.rst:975
msgid "support for secondary keys,"
msgstr "поддержка вторичных ключей,"

#: ../doc/1.10/whats_new.rst:976
msgid "support for ``auto_increment()``,"
msgstr "поддержка ``auto_increment()``,"

#: ../doc/1.10/whats_new.rst:977
msgid "number, integer, scalar field types in indexes,"
msgstr ""
"типы полей в индексах: number (число), integer (целое число), scalar "
"(скаляр),"

#: ../doc/1.10/whats_new.rst:978
msgid "INSERT, REPLACE and UPDATE return new tuple, like in memtx."
msgstr "операции INSERT, REPLACE и UPDATE возвращают новый кортеж, как в memtx'е."

#: ../doc/1.10/whats_new.rst:980
msgid ""
"We're still actively working on Vinyl and plan to add ``zstd`` "
"compression and a new memory allocator for Vinyl in-memory index in "
"1.7.3. This implies a data format change which we plan to implement "
"before 1.7 becomes generally available."
msgstr ""
"Мы все еще активно работаем над Vinyl'ом и планируем добавить механизм "
"компрессии ``zstd`` и новый распределитель ресурсов для Vinyl'а в версии "
"1.7.3. Это подразумевает изменение формата данных, который планируется "
"внедрить до того, как версия 1.7 станет общедоступной."

#: ../doc/1.10/whats_new.rst:984
msgid ""
"Tab-based autocompletion in the interactive console, "
"``require('console').connect()``, ``tarantoolctl enter`` and "
"``tarantoolctl connect`` commands. Issues `86 "
"<https://github.com/tarantool/tarantool/issues/86>`_ and `1790 "
"<https://github.com/tarantool/tarantool/issues/1790>`_. Use the TAB key "
"to auto complete the names of Lua variables, functions and meta-methods."
msgstr ""
"Автодополнение по Tab в интерактивной консоли, команды "
"`require('console').connect()``, ``tarantoolctl enter`` и ``tarantoolctl "
"connect``. Проблемы `86 "
"<https://github.com/tarantool/tarantool/issues/86>`_ и `1790 "
"<https://github.com/tarantool/tarantool/issues/1790>`_. Используйте "
"клавишу TAB для автодополнения имен переменных, функций и метаметодов в "
"Lua."

#: ../doc/1.10/whats_new.rst:991
msgid ""
"A new implementation of ``net.box`` improving performance and solving "
"problems when the Lua garbage collector handles dead connections. Issues "
"`799 <https://github.com/tarantool/tarantool/issues/799>`_, `800 "
"<https://github.com/tarantool/tarantool/issues/800>`_, `1138 "
"<https://github.com/tarantool/tarantool/issues/1138>`_ and `1750 "
"<https://github.com/tarantool/tarantool/issues/1750>`_."
msgstr ""
"Новая реализация ``net.box`` с улучшенной производительностью и решением "
"проблем, когда сборщик мусора в Lua работает с недоступными соединениями."
" Проблемы `799 <https://github.com/tarantool/tarantool/issues/799>`_, "
"`800 <https://github.com/tarantool/tarantool/issues/800>`_, `1138 "
"<https://github.com/tarantool/tarantool/issues/1138>`_ и `1750 "
"<https://github.com/tarantool/tarantool/issues/1750>`_."

#: ../doc/1.10/whats_new.rst:997
msgid ""
"memtx snapshots and xlog files are now compressed on the fly using the "
"fast `ZStandard <https://github.com/facebook/zstd>`_ compression "
"algorithm. Compression options are configured automatically to get an "
"optimal trade-off between CPU utilization and disk throughput."
msgstr ""
"Появилась компрессия снимков memtx и xlog-файлов на лету с использованием"
" быстрого алгоритма компрессии `ZStandard "
"<https://github.com/facebook/zstd>`_. Компрессия настраивается "
"автоматически для получения оптимального соотношения между использованием"
" ЦП и пропускной способностью диска."

#: ../doc/1.10/whats_new.rst:1001
msgid ""
"``fiber.cond()`` - a new synchronization mechanism for cooperative "
"multitasking. Issue `1731 "
"<https://github.com/tarantool/tarantool/issues/1731>`_."
msgstr ""
"``fiber.cond()`` -- новый механизм синхронизации для кооперативной "
"многозадачности. Проблема `1731 "
"<https://github.com/tarantool/tarantool/issues/1731>`_."

#: ../doc/1.10/whats_new.rst:1003
msgid ""
"Tarantool can now be installed using universal Snappy packages "
"(http://snapcraft.io/) with ``snap install tarantool --channel=beta``."
msgstr ""
"Tarantool теперь можно устанавливать из универсальных Snappy-пакетов "
"(http://snapcraft.io/) с помощью команды ``snap install tarantool "
"--channel=beta``."

#: ../doc/1.10/whats_new.rst:1006 ../doc/1.10/whats_new.rst:1168
#: ../doc/1.10/whats_new.rst:1269
msgid "New rocks and packages:"
msgstr "Новые модули и пакеты:"

#: ../doc/1.10/whats_new.rst:1008 ../doc/1.10/whats_new.rst:1170
msgid ""
"`curl <https://github.com/tarantool/tarantool-curl>`_ - non-blocking "
"bindings for libcurl"
msgstr ""
"`curl <https://github.com/tarantool/tarantool-curl>`_ - неблокирующие "
"привязки для libcurl"

#: ../doc/1.10/whats_new.rst:1009 ../doc/1.10/whats_new.rst:1171
msgid ""
"`prometheus <https://github.com/tarantool/prometheus>`_ - Prometheus "
"metric collector for Tarantool"
msgstr ""
"`prometheus <https://github.com/tarantool/prometheus>`_ - сборщик метрик "
"Prometheus для Tarantool'а"

#: ../doc/1.10/whats_new.rst:1010
msgid ""
"`gis <https://github.com/tarantool/gis>`_ - a full-featured geospatial "
"extension for Tarantool"
msgstr ""
"`gis <https://github.com/tarantool/gis>`_ - полнофункциональное "
"геопространственное расширение для Tarantool'а"

#: ../doc/1.10/whats_new.rst:1011
msgid ""
"`mqtt <https://github.com/tarantool/mqtt>`_ - an MQTT protocol client for"
" Tarantool"
msgstr ""
"`mqtt <https://github.com/tarantool/mqtt>`_ - клиент MQTT-протокола для "
"Tarantool'а"

#: ../doc/1.10/whats_new.rst:1012 ../doc/1.10/whats_new.rst:1174
msgid ""
"`luaossl <https://github.com/tarantool/luaossl>`_ - the most "
"comprehensive OpenSSL module in the Lua universe"
msgstr ""
"`luaossl <https://github.com/tarantool/luaossl>`_ -  самый полноценный "
"OpenSSL-модуль во вселенной Lua"

#: ../doc/1.10/whats_new.rst:1014
msgid "Deprecated, removed features and minor incompatibilities:"
msgstr "Устаревшие, удаленные и несовместимые функции:"

#: ../doc/1.10/whats_new.rst:1016
msgid ""
"``num`` and ``str`` fields type names are deprecated, use ``unsigned`` "
"and ``string`` instead. Issue `1534 "
"<https://github.com/tarantool/tarantool/issues/1534>`_."
msgstr ""
"Имена типов полей ``num`` и ``str`` объявлены устаревшими, используйте "
"вместо них ``unsigned`` и ``string``. Проблема `1534 "
"<https://github.com/tarantool/tarantool/issues/1534>`_."

#: ../doc/1.10/whats_new.rst:1019
msgid ""
"``space:inc()`` and ``space:dec()`` were removed (deprecated in 1.6.x) "
"Issue `1289 <https://github.com/tarantool/tarantool/issues/1289>`_."
msgstr ""
"Удалены ``space:inc()`` и ``space:dec()`` (объявлены устаревшими в версии"
" 1.6.x). Проблема `1289 "
"<https://github.com/tarantool/tarantool/issues/1289>`_."

#: ../doc/1.10/whats_new.rst:1021
msgid ""
"``fiber:cancel()`` is now asynchronous and doesn't wait for the fiber to "
"end. Issue `1732 <https://github.com/tarantool/tarantool/issues/1732>`_."
msgstr ""
"Функция ``fiber:cancel()`` теперь является асинхронной и не ждет "
"завершения работы файбера. Проблема `1732 "
"<https://github.com/tarantool/tarantool/issues/1732>`_."

#: ../doc/1.10/whats_new.rst:1023
msgid ""
"Implicit error-prone ``tostring()`` was removed from ``digest`` API. "
"Issue `1591 <https://github.com/tarantool/tarantool/issues/1591>`_."
msgstr ""
"Склонная к ошибкам функция ``tostring()`` была удалена из API ``digest``."
" Проблема `1591 <https://github.com/tarantool/tarantool/issues/1591>`_."

#: ../doc/1.10/whats_new.rst:1025 ../doc/1.10/whats_new.rst:1141
msgid "Support for SHA-0 (``digest.sha()``) was removed due to OpenSSL upgrade."
msgstr ""
"Поддержка SHA-0 (``digest.sha()``) прекращается по причине обновления "
"OpenSSL."

#: ../doc/1.10/whats_new.rst:1026
msgid ""
"``net.box`` now uses one-based indexes for ``space.name.index[x].parts``."
" Issue `1729 <https://github.com/tarantool/tarantool/issues/1729>`_."
msgstr ""
"``net.box`` будет использовать индексы, начинающиеся с 1, для "
"``space.name.index[x].parts``. Проблемы `1729 "
"<https://github.com/tarantool/tarantool/issues/1729>`_."

#: ../doc/1.10/whats_new.rst:1028
msgid ""
"Tarantool binary now dynamically links with ``libssl.so`` during compile "
"time instead of loading it at the run time."
msgstr ""
"Бинарный файл Tarantool'а будет динамически связываться с ``libssl.so`` "
"во время компиляции вместо загрузки во время выполнения."

#: ../doc/1.10/whats_new.rst:1030
msgid ""
"Debian and Ubuntu packages switched to use native ``systemd`` "
"configuration alongside with old-fashioned ``sysvinit`` scripts."
msgstr ""
"Пакеты Debian и Ubuntu будут использовать встроенную конфигурацию "
"``systemd`` вместе с вышедшими из употребления скриптами ``sysvinit``."

#: ../doc/1.10/whats_new.rst:1033
msgid ""
"``systemd`` provides its own facilities for multi-instance management. To"
" upgrade, perform the following steps:"
msgstr ""
"В ``systemd`` появляется возможность управления несколькими экземплярами."
" Чтобы обновить, выполните следующие действия:"

#: ../doc/1.10/whats_new.rst:1036
msgid "Install new 1.7.2 packages."
msgstr "Установите новые пакеты версии 1.7.2."

#: ../doc/1.10/whats_new.rst:1037
msgid ""
"Ensure that ``INSTANCENAME.lua`` file is present in "
"``/etc/tarantool/instace.enabled``."
msgstr ""
"Убедитесь в наличии файла ``ИМЯ_ЭКЗЕМПЛЯРА.lua`` в директории "
"``/etc/tarantool/instace.enabled``."

#: ../doc/1.10/whats_new.rst:1038 ../doc/1.10/whats_new.rst:1190
msgid "Stop INSTANCENAME using ``tarantoolctl stop INSTANCENAME``."
msgstr "Остановите ЭКЗЕМПЛЯР с помощью ``tarantoolctl stop ИМЯ_ЭКЗЕМПЛЯРА``."

#: ../doc/1.10/whats_new.rst:1039 ../doc/1.10/whats_new.rst:1191
msgid "Start INSTANCENAME using ``systemctl start tarantool@INSTANCENAME``."
msgstr ""
"Запустите ЭКЗЕМПЛЯР с помощью ``systemctl start "
"tarantool@ИМЯ_ЭКЗЕМПЛЯРА``."

#: ../doc/1.10/whats_new.rst:1040 ../doc/1.10/whats_new.rst:1192
msgid ""
"Enable INSTANCENAME during system boot using ``systemctl enable "
"trantool@INTANCENAME``."
msgstr ""
"Включите ЭКЗЕМПЛЯР во время загрузки системы с помощью ``systemctl enable"
" tarantool@ИМЯ_ЭКЗЕМПЛЯРА``."

#: ../doc/1.10/whats_new.rst:1041
msgid ""
"Say ``systemctl disable tarantool; update-rc.d tarantool remove`` to "
"disable sysvinit-compatible wrappers."
msgstr ""
"Введите команду ``systemctl disable tarantool; update-rc.d tarantool "
"remove``, чтобы отключить надстройки, совместимые с sysvinit."

#: ../doc/1.10/whats_new.rst:1044
msgid ""
"Refer to issue `1291 "
"<https://github.com/tarantool/tarantool/issues/1291>`_ comment and "
":ref:`the administration chapter <admin>` for additional information."
msgstr ""
"Для получения дополнительной информации см. комментарии к проблеме `1291 "
"<https://github.com/tarantool/tarantool/issues/1291>`_ и главу :ref:`по "
"администрированию серверной части <admin>`."

#: ../doc/1.10/whats_new.rst:1047
msgid ""
"Debian and Ubuntu packages start a ready-to-use ``example.lua`` instance "
"on a clean installation of the package. The default instance grants "
"universe permissions for ``guest`` user and listens on \"locahost:3313\"."
msgstr ""
"Пакеты для Debian и Ubuntu запускают готовый к использованию экземпляр "
"``example.lua`` при чистой установке пакета. В экземпляре, используемом "
"по умолчанию, предоставлены права на universe для пользователя ``guest`` "
"и настроено прослушивание по \"locahost:3313\"."

#: ../doc/1.10/whats_new.rst:1051 ../doc/1.10/whats_new.rst:1144
msgid "Fedora 22 packages were deprecated (EOL)."
msgstr "Пакеты для Fedora 22 объявлены устаревшими (прекращение поддержки)."

#: ../doc/1.10/whats_new.rst:1055
msgid "**Release 1.7.1**"
msgstr "**Версия 1.7.1**"

#: ../doc/1.10/whats_new.rst:1057
msgid "Release type: alpha. Release date: 2016-07-11."
msgstr "Тип версии: альфа. Дата выхода: 2016-07-11."

#: ../doc/1.10/whats_new.rst:1059
msgid ""
"Announcement: "
"https://groups.google.com/forum/#!topic/tarantool/KGYj3VKJKb8"
msgstr ""
"Объявление о выходе: "
"https://groups.google.com/forum/#!topic/tarantool/KGYj3VKJKb8"

#: ../doc/1.10/whats_new.rst:1061
msgid ""
"This is the first alpha in the 1.7 series. The main feature of this "
"release is a new storage engine, called \"vinyl\". Vinyl is a write "
"optimized storage engine, allowing the amount of data stored exceed the "
"amount of available RAM 10-100x times. Vinyl is a continuation of the "
"Sophia engine from 1.6, and effectively a fork and a distant relative of "
"Dmitry Simonenko's Sophia. Sophia is superseded and replaced by Vinyl. "
"Internally it is organized as a log structured merge tree. However, it "
"takes a serious effort to improve on the traditional deficiencies of log "
"structured storage, such as poor read performance and unpredictable write"
" latency. A single index is range partitioned among many LSM data "
"structures, each having its own in-memory buffers of adjustable size. "
"Range partitioning allows merges of LSM levels to be more granular, as "
"well as to prioritize hot ranges over cold ones in access to resources, "
"such as RAM and I/O. The merge scheduler is designed to minimize write "
"latency while ensuring read performance stays within acceptable limits. "
"Vinyl today only supports a primary key index. The index can consist of "
"up to 256 parts, like in MemTX, up from 8 in Sophia. Partial key reads "
"are supported. Support of non-sequential multi part keys, as well as "
"secondary keys is on the short term todo. Our intent is to remove all "
"limitations currently present in Vinyl, making it a first class citizen "
"in Tarantool."
msgstr ""
"Данная сборка представляет собой первую альфа-версию в серии 1.7. "
"Основной функцией данной версии является новый движок базы данных под "
"названием \"vinyl\". Vinyl представляет собой оптимизированный для записи"
" движок базы данных, который позволяет сохранять объем сохраняемых "
"данных, превышающий объем доступной памяти в 10-100 раз. Vinyl является "
"продолжением движка Sophia из версии 1.6, а именно ответвлением и дальним"
" родственником Sophia Дмитрия Симоненко. Новый Vinyl заменяет Sophia. Он "
"реализован в виде журнально-структурированного дерева со слиянием (log-"
"structured merge tree -- LSM-tree). Однако усовершенствование таких "
"традиционных недостатков журнально-структурированных хранилищ, как низкая"
" производительность при чтении и непредсказуемая задержка во времени при "
"записи, стоит больших усилий. Отдельный индекс секционирован по "
"диапазонам между многими структурами данных LSM, в каждой из который "
"находятся собственные буферы оперативной памяти регулируемого размера. "
"Секционирование по диапазонам позволяет осуществить слияние LSM-уровней, "
"чтобы добиться большей детализации, а также отдать приоритет горячим "
"диапазонам по отношению к холодным в том, что касается доступа к "
"ресурсам, таким как оперативная память и ввод-вывод. Планировщик слияний "
"предназначен для сведения времени задержки записи к минимуму, а также для"
" поддержания производительности при чтении в приемлемых пределах. На "
"сегодняшний день Vinyl поддерживает только первичные индексы. Индекс "
"может состоять из 256 частей, как в MemTX'е, по сравнению с 8 в Sophia. "
"Поддерживает чтение по компонентам ключа. Вскоре ожидается поддержка "
"непоследовательных составных ключей, а также вторичных ключей. "
"Наше намерение заключается в том, чтобы убрать любые ограничения, которые"
" есть сейчас в Vinyl'е, чтобы сделать его полноценным компонентом "
"Tarantool'а."

#: ../doc/1.10/whats_new.rst:1088
msgid ""
"The disk-based storage engine, which was called ``sophia`` or ``phia`` in"
" earlier versions, is superseded by the ``vinyl`` storage engine."
msgstr ""
"Дисковый движок, который в более ранних версиях Tarantool'а назывался "
"``sophia`` или ``phia``, заменен новым движком под названием ``vinyl``."

#: ../doc/1.10/whats_new.rst:1090
msgid "There are new types for indexed fields."
msgstr "Добавлены новые типы индексируемых полей."

#: ../doc/1.10/whats_new.rst:1091
msgid "The LuaJIT version is updated."
msgstr "Обновлена версия LuaJIT."

#: ../doc/1.10/whats_new.rst:1092
msgid ""
"Automatic replica set bootstrap (for easier configuration of a new "
"replica set) is supported."
msgstr ""
"Поддерживается автоматическая настройка набора реплик, что существенно "
"упрощает настройку нового набора реплик."

#: ../doc/1.10/whats_new.rst:1094
msgid "The ``space_object:inc()`` function is removed."
msgstr "Функция ``space_object:inc()`` объявлена устаревшей."

#: ../doc/1.10/whats_new.rst:1095
msgid "The ``space_object:dec()`` function is removed."
msgstr "Функция ``space_object:dec()`` объявлена устаревшей."

#: ../doc/1.10/whats_new.rst:1096
msgid "The ``space_object:bsize()`` function is added."
msgstr "Добавлена функция ``space_object:bsize()``."

#: ../doc/1.10/whats_new.rst:1097
msgid ""
"The ``box.coredump()`` function is removed, for an alternative see "
":ref:`Core dumps <admin-core_dumps>`."
msgstr ""
"Удалена функция ``box.coredump()``, аналог см. в главе :ref:`Создание "
"дампов памяти <admin-core_dumps>`."

#: ../doc/1.10/whats_new.rst:1099
msgid "The ``hot_standby`` configuration option is added."
msgstr "Добавлена опция настройки ``hot_standby`` (горячий резерв)."

#: ../doc/1.10/whats_new.rst:1100
msgid "Configuration parameters revised or renamed:"
msgstr "Исправленные или переименованные конфигурационные параметры:"

#: ../doc/1.10/whats_new.rst:1102
msgid "``slab_alloc_arena`` (in gigabytes) to ``memtx_memory`` (in bytes),"
msgstr "``slab_alloc_arena`` (в гигабайтах) в ``memtx_memory`` (в байтах),"

#: ../doc/1.10/whats_new.rst:1103
msgid "``slab_alloc_minimal`` to ``memtx_min_tuple_size``,"
msgstr "``slab_alloc_minimal`` в ``memtx_min_tuple_size``,"

#: ../doc/1.10/whats_new.rst:1104
msgid "``slab_alloc_maximal`` to ``memtx_max_tuple_size``,"
msgstr "``slab_alloc_maximal`` в ``memtx_max_tuple_size``,"

#: ../doc/1.10/whats_new.rst:1105
msgid "``replication_source`` to ``replication``,"
msgstr "``replication_source`` в ``replication``,"

#: ../doc/1.10/whats_new.rst:1106
msgid "``snap_dir`` to ``memtx_dir``,"
msgstr "``snap_dir`` в ``memtx_dir``,"

#: ../doc/1.10/whats_new.rst:1107
msgid "``logger`` to ``log``,"
msgstr "``logger`` в ``log``,"

#: ../doc/1.10/whats_new.rst:1108
msgid "``logger_nonblock`` to ``log_nonblock``,"
msgstr "``logger_nonblock`` в ``log_nonblock``,"

#: ../doc/1.10/whats_new.rst:1109
msgid "``snapshot_count`` to ``checkpoint_count``,"
msgstr "``snapshot_count`` в ``checkpoint_count``,"

#: ../doc/1.10/whats_new.rst:1110
msgid "``snapshot_period`` to ``checkpoint_interval``,"
msgstr "``snapshot_period`` в ``checkpoint_interval``,"

#: ../doc/1.10/whats_new.rst:1111
msgid ""
"``panic_on_wal_error`` and ``panic_on_snap_error`` united under "
"``force_recovery``."
msgstr ""
"``panic_on_wal_error`` и ``panic_on_snap_error`` объединены в  "
"``force_recovery``."

#: ../doc/1.10/whats_new.rst:1112
msgid ""
"Until Tarantool 1.8, you can use :ref:`deprecated parameters "
"<cfg_deprecated>` for both initial and runtime configuration, but "
"Tarantool will display a warning. Also, you can specify both deprecated "
"and up-to-date parameters, provided that their values are harmonized. If "
"not, Tarantool will display an error."
msgstr ""
"В версиях Tarantool'а до 1.8 можно использовать :ref:`устаревшие  "
"параметры <cfg_deprecated>` как для начальной, так и для рабочей "
"конфигурации, но в таком случае Tarantool выдаст предупреждение. Также "
"можно указывать как устаревшие, так и новые параметры при условии, что их"
" значения согласованы. В противном случае, Tarantool выдаст ошибку."

#: ../doc/1.10/whats_new.rst:1116
msgid ""
"Automatic replication cluster bootstrap; it's now much easier to "
"configure a new replication cluster."
msgstr ""
"У кластера репликации появилась возможность автоматической настройки, что"
" существенно упрощает настройку нового кластера."

#: ../doc/1.10/whats_new.rst:1118
msgid "New indexable data types: INTEGER and SCALAR."
msgstr "Новые индексируемые типы данных: INTEGER (целое число) и SCALAR (скаляр)."

#: ../doc/1.10/whats_new.rst:1119
msgid "Code refactoring and performance improvements."
msgstr "Рефакторинг кода и улучшение производительности."

#: ../doc/1.10/whats_new.rst:1120
msgid "Updated LuaJIT to 2.1-beta116."
msgstr "LuaJIT обновлен до версии 2.1-beta116."

#: ../doc/1.10/whats_new.rst:1126
msgid "Version 1.6"
msgstr "Версия 1.6"

#: ../doc/1.10/whats_new.rst:1130
msgid "**Release 1.6.9**"
msgstr "**Версия 1.6.9**"

#: ../doc/1.10/whats_new.rst:1132
msgid ""
"Release type: maintenance. Release date: 2016-09-27. Release tag: "
"1.6.9-4-gcc9ddd7."
msgstr ""
"Тип версии: обновленная. Дата выхода: 2016-09-27. Тег версии: "
"1.6.9-4-gcc9ddd7."

#: ../doc/1.10/whats_new.rst:1134
msgid ""
"Since February 15, 2017, due to Tarantool issue#2040 `Remove sophia "
"engine from 1.6 <https://github.com/tarantool/tarantool/issues/2040>`_ "
"there no longer is a storage engine named `sophia`. It will be superseded"
" in version 1.7 by the `vinyl` storage engine."
msgstr ""
"С 15 февраля 2017 года вследствие проблемы № 2040 `Удалить движок sophia "
"из версии 1.6 <https://github.com/tarantool/tarantool/issues/2040>`_, "
"движок базы данных под названием `sophia` отсутствует. В версии 1.7 его "
"заменит движок базы данных `vinyl`."

#: ../doc/1.10/whats_new.rst:1142
msgid ""
"Tarantool binary now dynamically links with libssl.so during compile time"
" instead of loading it at the run time."
msgstr ""
"Бинарный файл Tarantool'а будет динамически связываться с libssl.so во "
"время компиляции вместо загрузки во время выполнения."

#: ../doc/1.10/whats_new.rst:1148
msgid ""
"Tab-based autocompletion in the interactive console. Issue `86 "
"<https://github.com/tarantool/tarantool/issues/86>`_"
msgstr ""
"Автодополнение по Tab в интерактивной консоли. Проблема `86 "
"<https://github.com/tarantool/tarantool/issues/86>`_"

#: ../doc/1.10/whats_new.rst:1150
msgid ""
"LUA_PATH and LUA_CPATH environment variables taken into account, like in "
"PUC-RIO Lua. Issue `1428 "
"<https://github.com/tarantool/tarantool/issues/1428>`_"
msgstr ""
"Принимаются во внимание переменные окружения LUA_PATH и LUA_CPATH, как в "
"PUC-RIO Lua. Проблема `1428 "
"<https://github.com/tarantool/tarantool/issues/1428>`_"

#: ../doc/1.10/whats_new.rst:1152
msgid ""
"Search for ``.dylib`` as well as for ``.so`` libraries in OS X. Issue "
"`810 <https://github.com/tarantool/tarantool/issues/810>`_."
msgstr ""
"Поиск по библиотекам ``.dylib``, а также ``.so`` в OS X. Проблема `810 "
"<https://github.com/tarantool/tarantool/issues/810>`_."

#: ../doc/1.10/whats_new.rst:1154
msgid ""
"A new ``box.cfg { read_only = true }`` option to emulate master-slave "
"behavior. Issue `246 "
"<https://github.com/tarantool/tarantool/issues/246>`_"
msgstr ""
"Новая опция ``box.cfg { read_only = true }`` для моделирования поведения "
"главный-ведомый. Проблема `246 "
"<https://github.com/tarantool/tarantool/issues/246>`_"

#: ../doc/1.10/whats_new.rst:1156
msgid ""
"``if_not_exists = true`` option added to box.schema.user.grant. Issue "
"`1683 <https://github.com/tarantool/tarantool/issues/1683>`_"
msgstr ""
"Опция ``if_not_exists = true`` добавлена в box.schema.user.grant. "
"Проблема `1683 <https://github.com/tarantool/tarantool/issues/1683>`_"

#: ../doc/1.10/whats_new.rst:1158
msgid ""
"``clock_realtime()``/``monotonic()`` functions added to the public C API."
" Issue `1455 <https://github.com/tarantool/tarantool/issues/1455>`_"
msgstr ""
"Функции ``clock_realtime()``/``monotonic()`` добавлены в общедоступный "
"API для языка C. Проблема `1455 "
"<https://github.com/tarantool/tarantool/issues/1455>`_"

#: ../doc/1.10/whats_new.rst:1160
msgid ""
"``space:count(key, opts)`` introduced as an alias for "
"``space.index.primary:count(key, opts)``. Issue `1391 "
"<https://github.com/tarantool/tarantool/issues/13918>`_"
msgstr ""
"Появляется ``space:count(key, opts)`` в качестве псевдонима для "
"``space.index.primary:count(key, opts)``. Проблема `1391 "
"<https://github.com/tarantool/tarantool/issues/13918>`_"

#: ../doc/1.10/whats_new.rst:1163
msgid ""
"Upgrade script for 1.6.4 -> 1.6.8 -> 1.6.9. Issue `1281 "
"<https://github.com/tarantool/tarantool/issues/1281>`_"
msgstr ""
"Обновление скрипта для 1.6.4 -> 1.6.8 -> 1.6.9. Проблема `1281 "
"<https://github.com/tarantool/tarantool/issues/1281>`_"

#: ../doc/1.10/whats_new.rst:1165
msgid ""
"Support for OpenSSL 1.1. Issue `1722 "
"<https://github.com/tarantool/tarantool/issues/1722>`_"
msgstr ""
"Поддержка OpenSSL 1.1. Проблема `1722 "
"<https://github.com/tarantool/tarantool/issues/1722>`_"

#: ../doc/1.10/whats_new.rst:1172
msgid ""
"`gis <https://github.com/tarantool/gis>`_ - full-featured geospatial "
"extension for Tarantool."
msgstr ""
"`gis <https://github.com/tarantool/gis>`_ -- полнофункциональное "
"геопространственное расширение для Tarantool'а."

#: ../doc/1.10/whats_new.rst:1173
msgid ""
"`mqtt <https://github.com/tarantool/mqtt>`_ - MQTT protocol client for "
"Tarantool"
msgstr ""
"`mqtt <https://github.com/tarantool/mqtt>`_ -- клиент MQTT-протокола для "
"Tarantool'а"

#: ../doc/1.10/whats_new.rst:1178
msgid "**Release 1.6.8**"
msgstr "**Версия 1.6.8**"

#: ../doc/1.10/whats_new.rst:1180
msgid ""
"Release type: maintenance. Release date: 2016-02-25. Release tag: "
"1.6.8-525-ga571ac0."
msgstr ""
"Тип версии: обновленная. Дата выхода: 2016-02-25. Тег версии: "
"1.6.8-525-ga571ac0."

#: ../doc/1.10/whats_new.rst:1184
msgid ""
"RPM packages for CentOS 7 / RHEL 7 and Fedora 22+ now use native systemd "
"configuration without legacy sysvinit shell scripts. Systemd provides its"
" own facilities for multi-instance management. To upgrade, perform the "
"following steps:"
msgstr ""
"RPM-пакеты для CentOS 7 / RHEL 7 Fedora 22+ будут использовать встроенную"
" конфигурацию systemd без устаревших скриптов sysvinit. В systemd "
"появляется возможность управления несколькими экземплярами. Чтобы "
"обновить, выполните следующие действия:"

#: ../doc/1.10/whats_new.rst:1189
msgid ""
"Ensure that ``INSTANCENAME.lua`` file is present in "
"``/etc/tarantool/instace.available``."
msgstr ""
"Убедитесь в наличии файла ``ИМЯ_ЭКЗЕМПЛЯРА.lua`` в директории "
"``/etc/tarantool/instace.available``."

#: ../doc/1.10/whats_new.rst:1194
msgid ""
"``/etc/tarantool/instance.enabled`` directory is now deprecated for "
"systemd-enabled platforms."
msgstr ""
"Директория ``/etc/tarantool/instance.enabled`` больше не используется для"
" платформ, запускаемых по ``systemd``."

#: ../doc/1.10/whats_new.rst:1196
msgid "See :ref:`the administration chapter <admin>` for additional information."
msgstr ""
"Для получения дополнительной информации см. главу :ref:`по "
"администрированию серверной части <admin>`."

#: ../doc/1.10/whats_new.rst:1198
msgid ""
"Sophia was upgraded to v2.1 to fix upsert, memory corruption and other "
"bugs. Sophia v2.1 doesn't support old v1.1 data format. Please use "
"Tarantool replication to upgrade. Issue `1222 "
"<https://github.com/tarantool/tarantool/issues/1222>`_"
msgstr ""
"Движок Sophia был обновлен до версии 2.1 для исправления ошибок upsert, "
"нарушения целостности данных в памяти и других ошибок. Sophia версии 2.1 "
"не поддерживает старый формат данных версии 1.1. Используйте репликацию в"
" Tarantool'е для обновления. Проблема `1222 "
"<https://github.com/tarantool/tarantool/issues/1222>`_"

#: ../doc/1.10/whats_new.rst:1202
msgid "Ubuntu Vivid, Fedora 20, Fedora 21 were deprecated due to EOL."
msgstr ""
"Ubuntu Vivid, Fedora 20, Fedora 21 объявлены устаревшими по причине "
"прекращения поддержки."

#: ../doc/1.10/whats_new.rst:1203
msgid ""
"i686 packages were deprecated. Please use our RPM and DEB specs to build "
"these on your own infrastructure."
msgstr ""
"i686-пакеты объявлены устаревшими. Используйте наши спецификации по RPM и"
" DEB для сборки на своей инфраструктуре."

#: ../doc/1.10/whats_new.rst:1205
msgid ""
"Please update your ``yum.repos.d`` and/or apt ``sources.list.d`` "
"according to instructions at http://tarantool.org/download.html"
msgstr ""
"Обновите ``yum.repos.d`` и/или apt ``sources.list.d`` в соответствии с "
"инструкциями по ссылке http://tarantool.org/download.html"

#: ../doc/1.10/whats_new.rst:1210
msgid ""
"Tarantool 1.6.8 fully supports ARMv7 and ARMv8 (aarch64) processors. Now "
"it is possible to use Tarantool on a wide range of consumer devices, "
"starting from popular Raspberry PI 2 to coin-size embedded boards and no-"
"name mini-micro-nano-PCs. Issue `1153 "
"<https://github.com/tarantool/tarantool/issues/1153>`_. (Also qemu works "
"well, but we don't have real hardware to check.)"
msgstr ""
"Tarantool в версии 1.6.8 полностью поддерживает процессоры ARMv7 и ARMv8 "
"(aarch64). Теперь можно будет использовать Tarantool на самых разных "
"пользовательских устройствах от популярного Raspberry PI 2 и до плат "
"размером с монету и безымянных мини-микро-нано-компьютеров. Проблема "
"`1153 <https://github.com/tarantool/tarantool/issues/1153>`_. (На qemu "
"также работает хорошо, но у нас нет оборудования, чтобы проверить.)"

#: ../doc/1.10/whats_new.rst:1216
msgid ""
"Tuple comparator functions were optimized, providing up to 30% "
"performance boost when an index key consists of 2, 3 or more parts. Issue"
" `969 <https://github.com/tarantool/tarantool/issues/969>`_."
msgstr ""
"Функции компаратора кортежей были оптимизированы, чтобы обеспечить "
"повышение производительности на 30%, когда индексный ключ состоит из 2, 3"
" и более частей. Проблема `969 "
"<https://github.com/tarantool/tarantool/issues/969>`_."

#: ../doc/1.10/whats_new.rst:1219
msgid ""
"Tuple allocator changes give another 15% performance improvement. Issue "
"`1298 <https://github.com/tarantool/tarantool/issues/1298>`_"
msgstr ""
"Изменения распределителя кортежей дают улучшение производительности еще "
"на 15%. Проблема `1298 "
"<https://github.com/tarantool/tarantool/issues/1298>`_"

#: ../doc/1.10/whats_new.rst:1221
msgid ""
"Replication relay performance was improved by reducing the amount of data"
" directory re-scans. Issue `11150 "
"<https://github.com/tarantool/tarantool/issues/1150>`_"
msgstr ""
"Производительность передачи данных репликации была улучшена путем "
"уменьшения объема данных в повторном сканировании. Проблема `11150 "
"<https://github.com/tarantool/tarantool/issues/1150>`_"

#: ../doc/1.10/whats_new.rst:1224
msgid ""
"A random delay was introduced into snapshot daemon, reducing the chance "
"that multiple instances take a snapshot at the same time. Issue `732 "
"<https://github.com/tarantool/tarantool/issues/732>`_."
msgstr ""
"В демоне создания снимков появилась произвольная задержка, что снижает "
"возможность того, что несколько экземпляров будут делать снимки "
"одновременно. Проблема `732 "
"<https://github.com/tarantool/tarantool/issues/732>`_."

#: ../doc/1.10/whats_new.rst:1227
msgid "Sophia storage engine was upgraded to v2.1:"
msgstr "Движок базы данных Sophia был обновлен до версии 2.1:"

#: ../doc/1.10/whats_new.rst:1229
msgid "serializable Snapshot Isolation (SSI),"
msgstr "изоляция сериализуемых снимков (SSI -- Serializable Snapshot Isolation),"

#: ../doc/1.10/whats_new.rst:1230
msgid "RAM storage mode,"
msgstr "режим хранения в оперативной памяти,"

#: ../doc/1.10/whats_new.rst:1231
msgid "anti-cache storage mode,"
msgstr "режим хранения без кэша,"

#: ../doc/1.10/whats_new.rst:1232
msgid "persistent caching storage mode,"
msgstr "режим хранения в кэше с подключением к базе данных,"

#: ../doc/1.10/whats_new.rst:1233
msgid "implemented AMQ Filter,"
msgstr "внедренный AMQ-фильтр,"

#: ../doc/1.10/whats_new.rst:1234
msgid "LRU mode,"
msgstr "режим LRU (удаление страниц, которые дольше всего не использовались),"

#: ../doc/1.10/whats_new.rst:1235
msgid "separate compression for hot and cold data,"
msgstr "отдельная компрессия горячих и холодных данных,"

#: ../doc/1.10/whats_new.rst:1236
msgid "snapshot implementation for Faster Recovery,"
msgstr "внедрение снимков для быстрого восстановления,"

#: ../doc/1.10/whats_new.rst:1237
msgid "upsert reorganizations and fixes,"
msgstr "реорганизация и исправление ошибок в upsert,"

#: ../doc/1.10/whats_new.rst:1238
msgid "new performance metrics."
msgstr "новые метрики производительности."

#: ../doc/1.10/whats_new.rst:1240
msgid "Please note \"Incompatible changes\" above."
msgstr "Обратите внимание на \"Несовместимые изменения\" выше."

#: ../doc/1.10/whats_new.rst:1242
msgid ""
"Allow to remove servers with non-zero LSN from ``_cluster`` space. Issue "
"`1219 <https://github.com/tarantool/tarantool/issues/1219>`_."
msgstr ""
"Возможно удаление серверов с ненулевым LSN из спейса ``_cluster``. "
"Проблема `1219 <https://github.com/tarantool/tarantool/issues/1219>`_."

#: ../doc/1.10/whats_new.rst:1244
msgid ""
"``net.box`` now automatically reloads space and index definitions. Issue "
"`1183 <https://github.com/tarantool/tarantool/issues/1183>`_."
msgstr ""
"``net.box`` теперь автоматически перезагружает схемы спейса и индексов. "
"Проблема `1183 <https://github.com/tarantool/tarantool/issues/1183>`_."

#: ../doc/1.10/whats_new.rst:1246
msgid ""
"The maximal number of indexes in space was increased to 128. Issue `1311 "
"<https://github.com/tarantool/tarantool/issues/1311>`_."
msgstr ""
"Максимальное количество индексов в спейсе было увеличено до 128. Проблема"
" `1311 <https://github.com/tarantool/tarantool/issues/1311>`_."

#: ../doc/1.10/whats_new.rst:1248
msgid ""
"New native ``systemd`` configuration with support of instance management "
"and daemon supervision (CentOS 7 and Fedora 22+ only). Please note "
"\"Incompatible changes\" above. Issue `1264 "
"<https://github.com/tarantool/tarantool/issues/1264>`_."
msgstr ""
"Новая встроенная конфигурацию ``systemd`` с поддержкой управления "
"экземплярами и контролем демонов (только CentOS 7 и Fedora 22+). См. "
"\"Несовместимые изменения\" выше. Проблема `1264 "
"<https://github.com/tarantool/tarantool/issues/1264>`_."

#: ../doc/1.10/whats_new.rst:1252
msgid ""
"Tarantool package was accepted to the official Fedora repositories "
"(https://apps.fedoraproject.org/packages/tarantool)."
msgstr ""
"Пакет Tarantool'а принят в официальный репозиторий Fedora "
"(https://apps.fedoraproject.org/packages/tarantool)."

#: ../doc/1.10/whats_new.rst:1254
msgid ""
"Tarantool brew formula (OS X) was accepted to the official Homebrew "
"repository (http://brewformulas.org/tarantool)."
msgstr ""
"Пакет Tarantool'а (OS X) принят в официальный репозиторий Homebrew "
"(http://brewformulas.org/tarantool)."

#: ../doc/1.10/whats_new.rst:1256
msgid ""
"Clang compiler support was added on FreeBSD. Issue `786 "
"<https://github.com/tarantool/tarantool/issues/786>`_."
msgstr ""
"Поддержка компилятора Clang добавлена в FreeBSD. Проблема `786 "
"<https://github.com/tarantool/tarantool/issues/786>`_."

#: ../doc/1.10/whats_new.rst:1258
msgid ""
"Support for musl libc, used by Alpine Linux and Docker images, was added."
" Issue `1249 <https://github.com/tarantool/tarantool/issues/1249>`_."
msgstr ""
"Добавлена поддержка библиотеки musl libc, используемой образами Alpine "
"Linux и Docker. Проблема `1249 "
"<https://github.com/tarantool/tarantool/issues/1249>`_."

#: ../doc/1.10/whats_new.rst:1260
msgid "Added support for GCC 6.0."
msgstr "Добавлена поддержка GCC 6.0."

#: ../doc/1.10/whats_new.rst:1261
msgid ""
"Ubuntu Wily, Xenial and Fedora 22, 23 and 24 are now supported "
"distributions for which we build official packages."
msgstr ""
"Получили поддержку Ubuntu Wily, Xenial и Fedora 22, 23 и 24, для которых "
"мы создаем официальные пакеты."

#: ../doc/1.10/whats_new.rst:1263
msgid ""
"box.info.cluster.uuid can be used to retrieve cluster UUID. Issue `1117 "
"<https://github.com/tarantool/tarantool/issues/1117>`_."
msgstr ""
"box.info.cluster.uuid можно использовать для получения UUID кластера. "
"Проблема `1117 <https://github.com/tarantool/tarantool/issues/1117>`_."

#: ../doc/1.10/whats_new.rst:1265
msgid ""
"Numerous improvements in the documentation, added documentation for "
"``syslog``, ``clock``, ``fiber.storage`` packages, updated the built-in "
"tutorial."
msgstr ""
"Многочисленные исправления в документации, добавлена документация по "
"пакетам ``syslog``, ``clock``, ``fiber.storage``, встроенное практическое"
" задание получило обновление."

#: ../doc/1.10/whats_new.rst:1271
msgid ""
"Tarantool switched to a new Docker-based cloud build infrastructure The "
"new buildbot significantly decreases commit-to-package time. The official"
" repositories at http://tarantool.org now contain the latest version of "
"the server, rocks and connectors. See http://github.com/tarantool/build"
msgstr ""
"Tarantool перешел на новую облачную инфраструктуру на основе Docker. "
"Новый инструмент интеграции разработки buildbot значительно уменьшает "
"время передачи коммитов в пакеты. Официальные репозитории по ссылке "
"http://tarantool.org теперь содержат последнюю версию сервера, модулей и "
"коннекторов. См. http://github.com/tarantool/build"

#: ../doc/1.10/whats_new.rst:1276
msgid ""
"The repositories at http://tarantool.org/download.html were moved to "
"http://packagecloud.io cloud hosting (backed by Amazon AWS). Thanks to "
"packagecloud.io for their support of open source!"
msgstr ""
"Репозитории по ссылке http://tarantool.org/download.html were был "
"перенесены в облачное хранилище http://packagecloud.io (при поддержке "
"Amazon AWS). Благодарим packagecloud.io за поддержку свободного ПО!"

#: ../doc/1.10/whats_new.rst:1279
msgid ""
"``memcached`` - memcached text and binary protocol implementation for "
"Tarantool. Turns Tarantool into a persistent memcached with master-master"
" replication. See https://github.com/tarantool/memcached"
msgstr ""
"``memcached`` -- внедрение текстового и бинарного протокола memcached для"
" Tarantool'а. Превращает Tarantool в memcached с доступом к базе данных с"
" репликацией по схеме мастер-мастер. См. "
"https://github.com/tarantool/memcached"

#: ../doc/1.10/whats_new.rst:1282
msgid ""
"``migrate`` - a Tarantool rock for migration from Tarantool 1.5 to 1.6. "
"See https://github.com/bigbes/migrate"
msgstr ""
"``migrate`` -- модуль Tarantool'а для миграции с версии 1.5 на версию "
"1.6. См. https://github.com/bigbes/migrate"

#: ../doc/1.10/whats_new.rst:1284
msgid ""
"``cqueues`` - a Lua asynchronous networking, threading, and notification "
"framework (contributed by @daurnimator). PR `1204 "
"<https://github.com/tarantool/tarantool/pull/1204>`_."
msgstr ""
"``cqueues`` -- асинхронный Lua-каркас для работы по сети с потоками и "
"уведомлениями (разработал @daurnimator). Проблема `1204 "
"<https://github.com/tarantool/tarantool/pull/1204>`_."

#: ../doc/1.10/whats_new.rst:1290
msgid "**Release 1.6.7**"
msgstr "**Версия 1.6.7**"

#: ../doc/1.10/whats_new.rst:1292
msgid "Release type: maintenance. Release date: 2015-11-17."
msgstr "Тип версии: обновленная. Дата выхода: 2015-11-17."

#: ../doc/1.10/whats_new.rst:1296
msgid ""
"The syntax of ``upsert`` command has been changed and an extra ``key`` "
"argument was removed from it. The primary key for look up is now always "
"taken from the tuple, which is the second argument of upsert. "
"``upsert()`` was added fairly late at a release cycle and the design had "
"an obvious bug which we had to fix. Sorry for this."
msgstr ""
"Изменился синтаксис команды ``upsert``, и из нее был удален "
"дополнительный аргумент ``key``. Первичный ключ для поиска всегда берется"
" из кортежа, который является вторым аргументом в upsert. ``upsert()`` "
"добавили довольно поздно в рабочем цикле, и в проекте была очевидная "
"ошибка, которую нам пришлось исправлять. Извините."

#: ../doc/1.10/whats_new.rst:1302
msgid ""
"``fiber.channel.broadcast()`` was removed since it wasn't used by anyone "
"and didn't work properly."
msgstr ""
"Функцию ``fiber.channel.broadcast()`` удалили, потому что ее никто не "
"использовал, и она работала некорректно."

#: ../doc/1.10/whats_new.rst:1304
msgid "tarantoolctl ``reload`` command renamed to ``eval``."
msgstr "Команда ``reload`` утилиты tarantoolctl переименована в``eval``."

#: ../doc/1.10/whats_new.rst:1308
msgid ""
"``logger`` option now accepts a syntax for syslog output. Use uri-style "
"syntax for file, pipe or syslog log destination."
msgstr ""
"Опция ``logger`` допускает синтаксис для вывода в системный журнал "
"syslog. Используйте синтаксис URI, чтобы определить место назначения "
"журнала: в файл, в конвейер или syslog."

#: ../doc/1.10/whats_new.rst:1310
msgid ""
"``replication_source`` now accepts an array of URIs, so each replica can "
"have up to 30 peers."
msgstr ""
"``replication_source`` принимает массив URI, так что в каждой реплике "
"может быть до 30 узлов."

#: ../doc/1.10/whats_new.rst:1312
msgid ""
"RTREE index now accept two types of ``distance`` functions: ``euclid`` "
"and ``manhattan``."
msgstr ""
"RTREE-индекс принимает два типа функций ``distance``: ``euclid`` и "
"``manhattan``."

#: ../doc/1.10/whats_new.rst:1314
msgid ""
"``fio.abspath()`` - a new function in ``fio`` rock to convert a relative "
"path to absolute."
msgstr ""
"``fio.abspath()`` -- новая функция в модуле ``fio`` для конвертации "
"относительного пути в абсолютный."

#: ../doc/1.10/whats_new.rst:1316
msgid "The process title now can be set with an on-board ``title`` rock."
msgstr ""
"Название процесса теперь можно определить с помощью встроенного модуля "
"``title``."

#: ../doc/1.10/whats_new.rst:1317
msgid "This release uses LuaJIT 2.1."
msgstr "В данной версии используется LuaJIT 2.1."

#: ../doc/1.10/whats_new.rst:1321
msgid ""
"``memcached`` - makes Tarantool understand Memcached binary protocol. "
"Text protocol support is in progress and will be added to the rock "
"itself, without changes to the server core."
msgstr ""
"``memcached`` помогает Tarantool'у понимать бинарный протокол Memcached. "
"Поддержка текстового протокола находится в процессе разработки и будет "
"добавлена в отдельный модуль без изменений основных компонентов."

#: ../doc/1.10/whats_new.rst:1327
msgid "**Release 1.6.6**"
msgstr "**Версия 1.6.6**"

#: ../doc/1.10/whats_new.rst:1329
msgid "Release type: maintenance. Release date: 2015-08-28."
msgstr "Тип версии: обновленная. Дата выхода: 2015-08-28."

#: ../doc/1.10/whats_new.rst:1332
msgid ""
"Tarantool 1.6 is no longer getting major new features, although it will "
"be maintained. The developers are concentrating on Tarantool version 1.9."
msgstr ""
"Tarantool версии 1.6 больше не получает значимых новых функций, но "
"продолжает поддерживаться. Разработчики сосредоточили свои усилия на "
"версии 1.9."

#: ../doc/1.10/whats_new.rst:1338
msgid ""
"A new schema of ``_index`` system space which accommodates multi-"
"dimensional RTREE indexes. Tarantool 1.6.6 works fine with an old "
"snapshot and system spaces, but you will not be able to start Tarantool "
"1.6.5 with a data directory created by Tarantool 1.6.6, neither will you "
"be able to query Tarantool 1.6.6 schema with 1.6.5 net.box."
msgstr ""
"Появляется новая схема системного спейса ``_index`` для размещения "
"многомерных RTREE-индексов. Tarantool 1.6.6 нормально работает со старыми"
" снимками и системными спейсами, но нельзя будет запустить Tarantool "
"версии 1.6.5 с директорий, созданной в Tarantool'е версии 1.6.6, как "
"нельзя будет ввести запрос в Tarantool 1.6.6 с net.box версии 1.6.5."

#: ../doc/1.10/whats_new.rst:1344
msgid "``box.info.snapshot_pid`` is renamed to ``box.info.snapshot_in_progress``"
msgstr ""
"Переименование ``box.info.snapshot_pid`` в "
"``box.info.snapshot_in_progress``"

#: ../doc/1.10/whats_new.rst:1348
msgid ""
"Threaded architecture for network. Network I/O has finally been moved to "
"a separate thread, increasing single instance performance by up to 50%."
msgstr ""
"Потоковая архитектура для работы по сети. Сетевой ввод-вывод окончательно"
" переведен на отдельный поток, что увеличит производительность отдельного"
" экземпляра до 50%."

#: ../doc/1.10/whats_new.rst:1351
msgid ""
"Threaded architecture for checkpointing. Tarantool no longer forks to "
"create a snapshot, but uses a separate thread, accessing data via a "
"consistent read view. This eliminates all known latency spikes caused by "
"snapshotting."
msgstr ""
"Потоковая архитектура для создания контрольных точек. Tarantool больше не"
" делает ответвлений для создания снимка, а использует отдельный поток, "
"получая доступ к данным с помощью вида постоянного просмотра. Это "
"помогает устранить скачки задержки отклика во время создания снимков."

#: ../doc/1.10/whats_new.rst:1356
msgid ""
"Stored procedures in C/C++. Stored procedures in C/C++ provide speed (3-4"
" times, compared to a Lua version in our measurements), as well as "
"unlimited extensibility power. Since C/C++ procedures run in the same "
"memory space as the database, they are also an easy tool to corrupt "
"database memory. See :ref:`The C API description <index-"
"c_api_reference>`."
msgstr ""
"Хранимые процедуры на языках C/C++. Хранимые процедуры на языках C/C++ "
"дают скорость (в 3-4 раза больше по сравнению с Lua-версией по нашим "
"подсчетам), а также возможность неограниченного расширения. Поскольку "
"процедуры C/C++ выполняются там же, где располагается база данных, они "
"могут с легкостью повредить базу данных. См. :ref:`API для языка C "
"<index-c_api_reference>`."

#: ../doc/1.10/whats_new.rst:1363
msgid ""
"Multidimensional RTREE index. RTREE index type now support a large (up to"
" 32) number of dimensions. RTREE data structure has been optimized to "
"actually use `R\\*-TREE <https://en.wikipedia.org/wiki/R*_tree>`_. We're "
"working on further improvements of the index, in particular, configurable"
" distance function. See https://github.com/tarantool/tarantool/wiki/R"
"-tree-index-quick-start-and-usage"
msgstr ""
"Многомерный RTREE-индекс. RTREE-индекс теперь поддерживает большое "
"количество измерений (до 32). Cтруктура данных RTREE была оптимизирована "
"так, чтобы действительно использовать `R\\*-TREE "
"<https://en.wikipedia.org/wiki/R*_tree>`_. Мы работаем над дальнейшим "
"улучшением индекса, в частности, над функцией конфигурации расстояния. "
"См. https://github.com/tarantool/tarantool/wiki/R-tree-index-quick-start-"
"and-usage"

#: ../doc/1.10/whats_new.rst:1370
msgid ""
"Sophia 2.1.1, with support of compression and multipart primary keys. See"
" https://groups.google.com/forum/#!topic/sophia-database/GfcbEC7ksRg"
msgstr ""
"Sophia 2.1.1 с поддержкой компрессии и составных первичных ключей. См. "
"https://groups.google.com/forum/#!topic/sophia-database/GfcbEC7ksRg"

#: ../doc/1.10/whats_new.rst:1373
msgid ""
"New ``upsert`` command available in the binary protocol and in stored "
"functions. The key advantage of upsert is that it's much faster with "
"write-optimized storage (sophia storage engine), but some caveats exists "
"as well. See Issue `905 "
"<https://github.com/tarantool/tarantool/issues/905>`_ for details. Even "
"though upsert performance advantage is most prominent with sophia engine,"
" it works with all storage engines."
msgstr ""
"В бинарном протоколе и в хранимых функциях доступна новая команда "
"``upsert``. Ключевое преимущество команды upsert в том, что она работает "
"намного быстрее с хранилищами, оптимизированными для чтения (движок базы "
"данных sophia), однако есть также некоторые оговорки. Для получения "
"дополнительной информации см. проблему `905 "
"<https://github.com/tarantool/tarantool/issues/905>`_. И хотя "
"преимущество производительности upsert наиболее очевидно с движком "
"sophia, команда работает со всеми движками базы данных."

#: ../doc/1.10/whats_new.rst:1380
msgid ""
"Better memory diagnostics information for fibers, tuple and index arena "
"Try a new command ``box.slab.stats()``, for detailed information about "
"tuple/index slabs, ``fiber.info()`` now displays information about memory"
" used by the fiber."
msgstr ""
"Более точная информация диагностики памяти для файберов, кортежей и "
"индексов. Используйте новую команду ``box.slab.stats()`` для получения "
"подробной информация о кортежах/индексах, команда ``fiber.info()`` "
"отобразит информацию о памяти, занятой файбером."

#: ../doc/1.10/whats_new.rst:1384
msgid ""
"Update and delete now work using a secondary index, if the index is "
"unique."
msgstr ""
"Операции update и delete работают с использованием вторичного индекса, "
"если индекс уникальный."

#: ../doc/1.10/whats_new.rst:1386
msgid ""
"Authentication triggers. Set ``box.session.on_auth`` triggers to catch "
"authentication events. Trigger API is improved to display all defined "
"triggers, easily remove old triggers."
msgstr ""
"Триггеры для аутентификации. Установите триггеры ``box.session.on_auth`` "
"для отслеживания событий аутентификации. API для триггеров улучшили, "
"чтобы он отображал все заданные триггеры, старые триггеры легко удалить."

#: ../doc/1.10/whats_new.rst:1389
msgid "Manifold performance improvements of ``net.box`` built-in package."
msgstr "Разнообразные улучшения производительности встроенного модуля ``net.box``."

#: ../doc/1.10/whats_new.rst:1390
msgid "Performance optimizations of BITSET index."
msgstr "Оптимизация производительности BITSET-индекса."

#: ../doc/1.10/whats_new.rst:1391
msgid "``panic_on_wal_error`` is a dynamic configuration option now."
msgstr ""
"``panic_on_wal_error`` представляет собой динамический параметр "
"конфигурации."

#: ../doc/1.10/whats_new.rst:1392
msgid "iproto ``sync`` field is available in Lua as ``session.sync()``."
msgstr "Поле iproto ``sync`` доступно в Lua как ``session.sync()``."

#: ../doc/1.10/whats_new.rst:1393
msgid ""
"``box.once()`` - a new method to invoke code once in an instance and "
"replica set lifetime. Use ``once()`` to set up spaces and uses, as well "
"as do schema upgrade in production."
msgstr ""
"``box.once()`` -- новый метод для вызова кода однократно в течение срока "
"жизни экземпляра и набора реплик. Используйте ``once()`` для настройки "
"спейсов и пользователей, а также для обновления схемы в эксплуатационной "
"среде."

#: ../doc/1.10/whats_new.rst:1397
msgid "``box.error.last()`` to return the last error in a session."
msgstr "``box.error.last()`` возвращает последнюю ошибку в сессии."

#: ../doc/1.10/whats_new.rst:1401
msgid ""
"``jit.*``, ``jit.dump``, ``jit.util``, ``jit.vmdef`` modules of LuaJIT "
"2.0 are now available as built-ins. See http://luajit.org/ext_jit.html"
msgstr ""
"Следующие модули LuaJIT 2.0 теперь являются встроенными: ``jit.*``, "
"``jit.dump``, ``jit.util``, ``jit.vmdef``. См. "
"http://luajit.org/ext_jit.html"

#: ../doc/1.10/whats_new.rst:1404
msgid ""
"``strict`` built-in package, banning use of undeclared variables in Lua. "
"Strict mode is on when Tarantool is compiled with debug. Turn on/off with"
" ``require('strict').on()``/``require('strict').off()``."
msgstr ""
"``strict`` -- встроенный пакет, который запрещает использование "
"необъявленных переменных в Lua. Работа ведется в таком режиме, когда "
"Tarantool компилируется с отладкой. Чтобы включить/отключить этот режим, "
"используйте ``require('strict').on()``/``require('strict').off()`` "
"соответственно."

#: ../doc/1.10/whats_new.rst:1407
msgid ""
"``pg`` and ``mysql`` rocks, available at http://rocks.tarantool.org - "
"working with MySQL and PostgreSQL from Tarantool."
msgstr ""
"``pg`` и ``mysql`` -- модули, доступные по ссылке "
"http://rocks.tarantool.org -- работают с MySQL и PostgreSQL из "
"Tarantool'а."

#: ../doc/1.10/whats_new.rst:1409
msgid ""
"``gperftools`` rock, availble at http://rocks.tarantool.org - getting "
"perfromance data using Google's gperf from Tarantool."
msgstr ""
"``gperftools`` -- модуль, доступный по ссылке http://rocks.tarantool.org "
"-- получает данные о производительности с помощью Google gperf из "
"Tarantool'а."

#: ../doc/1.10/whats_new.rst:1411
msgid ""
"``csv`` built-in rock, to parse and load CSV (comma-separated values) "
"data."
msgstr ""
"``csv`` -- встроенный модуль для разбора и загрузки данных в формате CSV "
"(значения, разделенные запятыми)."

#: ../doc/1.10/whats_new.rst:1414
msgid "New supported platforms:"
msgstr "Поддержка новой платформы:"

#: ../doc/1.10/whats_new.rst:1416
msgid "Fedora 22, Ubuntu Vivid"
msgstr "Fedora 22, Ubuntu Vivid"

#~ msgid ""
#~ "Alter an index. It is legal in "
#~ "some circumstances to change an index's"
#~ " parts and/or change the type and "
#~ "the ``is_nullable`` flag for a part. "
#~ "However, this usually causes rebuilding "
#~ "of the space, except for the "
#~ "simple case where the ``is_nullable`` "
#~ "flag is changed from ``false`` to "
#~ "``true``."
#~ msgstr ""
#~ "Изменение индекса. В определенных "
#~ "обстоятельствах можно изменять компоненты "
#~ "индекса и / или изменять тип "
#~ "компонента и флаг  ``is_nullable`` для "
#~ "него. Тем не менее, это обычно "
#~ "приводит к перестроению спейса за "
#~ "исключением простого случая, когда значение"
#~ " флага ``is_nullable`` меняется с ``false``"
#~ " на ``true``."

#~ msgid ""
#~ "**Note re storage engine:** vinyl "
#~ "supports ``alter()`` for non-empty "
#~ "spaces. Primary index definition cannot "
#~ "be altered."
#~ msgstr ""
#~ "**Примечание про движок базы данных:** "
#~ "vinyl поддерживает ``alter()`` для не "
#~ "пустых спейсов. Определение первичного индекса"
#~ " изменить нельзя."

#~ msgid "A sequence cannot be dropped if it is associated with an index."
#~ msgstr "Последовательность нельзя удалить, если она связана с индексом."

#~ msgid ""
#~ "``box.stat.vinyl().disk.dump`` has the amount "
#~ "of data from recent changes that "
#~ "has been dumped, and the count of"
#~ " dumps."
#~ msgstr ""
#~ "``box.stat.vinyl().disk.dump`` содержит объем данных"
#~ " из последних изменений, для которых "
#~ "был создан дамп, а также счетчик "
#~ "дампов."

#~ msgid ""
#~ "Tarantool \"factorizes\" this problem by "
#~ "creating multiple LSM trees for each "
#~ "index. The approximate size of each "
#~ "subtree is controlled by the "
#~ "``vinyl_range_size`` parameter, which is equal"
#~ " to 1 Gb by default. We call"
#~ " such subtrees \"ranges\"."
#~ msgstr ""
#~ "Tarantool \"факторизует\" проблему, создавая "
#~ "не одно, а множество LSM-деревьев для"
#~ " каждого индекса. Примерный размер каждого"
#~ " поддерева задается в параметре "
#~ "``vinyl_range_size`` и по умолчанию равен "
#~ "1 ГБ. Такие поддеревья называется "
#~ "диапазонами (\"range\")."

#~ msgid ""
#~ "Tarantool 1.10 manual  This manual "
#~ "embraces all aspects of using Tarantool:"
#~ " from introductory information and "
#~ "exercises for beginners -- to advanced"
#~ " instructions and detailed references for"
#~ " power users and contributors.  "
#~ "Документация находится в процессе перевода "
#~ "и может отставать от английской версии."
#~ "      <div class=\"badge-icon\"></div>  Other "
#~ "sources  Single page  PDF  English  "
#~ "Russian  Telegram chat RU  Telegram chat"
#~ " EN"
#~ msgstr ""
#~ "Руководство по Tarantool 1.10  Данное "
#~ "руководство охватывает все аспекты использования "
#~ "Tarantool'а: от вводной информации и "
#~ "упражнений для начинающих -- до "
#~ "продвинутых инструкций и подробных "
#~ "справочников для опытных пользователей и "
#~ "сторонних разработчиков.  Документация находится "
#~ "в процессе перевода и может отставать"
#~ " от английской версии.      <div class"
#~ "=\"badge-icon\"></div>  Другие источники  На "
#~ "одной странице  PDF  Форум (eng)  Форум"
#~ " (рус)  Чат в Telegram на RU  "
#~ "Чат в Telegram на EN"

#~ msgid "Other sources"
#~ msgstr "Другие источники"

#~ msgid "`English`_"
#~ msgstr "`Форум (eng)`_"

#~ msgid "`Russian`_"
#~ msgstr "`Форум (рус)`_"

#~ msgid "Default = 1024 * 1024 * 1024 = 1073741824"
#~ msgstr "По умолчанию = 1024 * 1024 * 1024 = 1073741824"

#~ msgid ""
#~ "crypto.cipher.aes192.cbc.encrypt('string', 'key', 'initialization')\n"
#~ "crypto.cipher.aes256.ecb.decrypt('string', 'key', 'initialization')"
#~ msgstr ""
#~ "crypto.cipher.aes192.cbc.encrypt('string', 'key', 'initialization')\n"
#~ "  crypto.cipher.aes256.ecb.decrypt('string', 'key', 'initialization')"

#~ msgid "sha - sha (with 160-bit binary strings using SHA-0)"
#~ msgstr "sha - sha (160-битные двоичные строки с использованием SHA-0)"

#~ msgid ":ref:`digest.sha() <digest-sha>`"
#~ msgstr ":ref:`digest.sha() <digest-sha>`"

#~ msgid "Get a digest made with SHA-0"
#~ msgstr "Получение дайджеста с помощью SHA-0"

#~ msgid ":ref:`digest.sha_hex() <digest-sha_hex>`"
#~ msgstr ":ref:`digest.sha_hex() <digest-sha_hex>`"

#~ msgid "Get a hexadecimal digest made with SHA-0"
#~ msgstr "Получение шестнадцатеричного дайджеста с помощью SHA-0"

#~ msgid ""
#~ "Returns 160-bit binary string = digest"
#~ " made with SHA-0. |br| Not "
#~ "recommended."
#~ msgstr ""
#~ "Возврат 160-битной двоичной строки = "
#~ "дайджест, полученный с помощью SHA-0. "
#~ "|br| Не рекомендуется."

#~ msgid "Returns 40-byte string = hexadecimal of a digest calculated with sha."
#~ msgstr ""
#~ "Возврат 40-байтной строки = шестнадцатеричное"
#~ " значение дайджеста, вычисленного с помощью"
#~ " SHA."

#~ msgid "true if successful, false if not successful"
#~ msgstr "true, если выполнено, false, если не выполнено"

#~ msgid ""
#~ "``keepalive_interval`` - the interval, in "
#~ "seconds, that the operating system will"
#~ " wait between sending keepalive probes. "
#~ "See also `CURLOPT_TCP_KEEPALIVE "
#~ "<https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPALIVE.html>`_"
#~ msgstr ""
#~ "``keepalive_interval`` -- время интервала в"
#~ " секундах, в течение которого операционная"
#~ " система находится в режиме ожидания "
#~ "между отправкой сообщений keepalive. См. "
#~ "также    `CURLOPT_TCP_KEEPALIVE "
#~ "<https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPALIVE.html>`_"

#~ msgid "Below is a list of all ``utf8`` functions."
#~ msgstr "Ниже приведен перечень всех функций модуля ``utf8``."

#~ msgid ""
#~ "The comparison is done with all "
#~ "weights, and upper case comes before "
#~ "lower case."
#~ msgstr ""
#~ "Сравнение проводится во всем весам, и"
#~ " верхний регистр считается важнее нижнего"
#~ " регистра."

#~ msgid "number, or error if the input string is not valid UTF-8"
#~ msgstr "число или ошибка, если введена строка не в формате UTF-8"

#~ msgid ""
#~ "If an error occurs, the error "
#~ "return will include the byte position"
#~ " where the not-valid UTF-8 character"
#~ " was found, as a second value."
#~ msgstr ""
#~ "В случае ошибки возврат включает в "
#~ "себя в качество второго значения позицию"
#~ " байта, где был обнаружен символ не"
#~ " в формате UTF-8."

#~ msgid "string, or error if the input string is not valid UTF-8"
#~ msgstr "строка или ошибка, если введена строка не в формате UTF-8"

#~ msgid "table, or error if the input string is not valid UTF-8"
#~ msgstr "таблица или ошибка, если введена строка не в формате UTF-8"

#~ msgid "See also"
#~ msgstr "Дополнительно"

#~ msgid "**Resources:**"
#~ msgstr "**Ресурсы:**"

#~ msgid "Database operations usually do not yield, but it depends on the engine:"
#~ msgstr ""
#~ "Операции по изменению базы данных обычно"
#~ " не передают управление, но это "
#~ "зависит от движка:"

#~ msgid "In memtx, reads or writes do not require I/O and do not yield."
#~ msgstr ""
#~ "В memtx'е чтение и запись не "
#~ "требуют ввода-вывода и не передают "
#~ "управление."

#~ msgid ""
#~ "In vinyl, not all data is in "
#~ "memory, and SELECT often incurs a "
#~ "disc I/O, and therefore yields, while"
#~ " a write may stall waiting for "
#~ "memory to free up, thus also "
#~ "causing a yield."
#~ msgstr ""
#~ "В vinyl'е не все данные находятся "
#~ "в оперативной памяти, и запрос SELECT"
#~ " часто подразумевает дисковый ввод-вывод и,"
#~ " следовательно, передачу управления, пока "
#~ "запись ожидает освобождения памяти, что "
#~ "также вызывает передачу управления."

#~ msgid ""
#~ "In the \"autocommit\" mode, all data "
#~ "change operations are followed by an "
#~ "automatic commit, which yields. So does"
#~ " an explicit commit of a multi-"
#~ "statement transaction, :ref:`box.commit() <box-"
#~ "commit>`."
#~ msgstr ""
#~ "В режиме \"автокоммита\" все операции по"
#~ " изменению данных сопровождаются автоматическим"
#~ " коммитом, который передает управление. "
#~ "Также передает управление явный коммит "
#~ "составной транзакции :ref:`box.commit() <box-"
#~ "commit>`."

#~ msgid ""
#~ "tarantool> box.stat()\n"
#~ "---\n"
#~ "- DELETE:\n"
#~ "    total: 1873949\n"
#~ "    rps: 123\n"
#~ "  SELECT:\n"
#~ "    total: 1237723\n"
#~ "    rps: 4099\n"
#~ "  INSERT:\n"
#~ "    total: 0\n"
#~ "    rps: 0\n"
#~ "  EVAL:\n"
#~ "    total: 0\n"
#~ "    rps: 0\n"
#~ "  CALL:\n"
#~ "    total: 0\n"
#~ "    rps: 0\n"
#~ "  REPLACE:\n"
#~ "    total: 1239123\n"
#~ "    rps: 7849\n"
#~ "  UPSERT:\n"
#~ "    total: 0\n"
#~ "    rps: 0\n"
#~ "  AUTH:\n"
#~ "    total: 0\n"
#~ "    rps: 0\n"
#~ "  ERROR:\n"
#~ "    total: 0\n"
#~ "    rps: 0\n"
#~ "  UPDATE:\n"
#~ "    total: 0\n"
#~ "    rps: 0\n"
#~ "...\n"
#~ "tarantool> box.stat().DELETE -- a selected item of the table\n"
#~ "---\n"
#~ "- total: 0\n"
#~ "  rps: 0\n"
#~ "...\n"
#~ "tarantool> box.stat.net()\n"
#~ "---\n"
#~ "- SENT:\n"
#~ "    total: 0\n"
#~ "    rps: 0\n"
#~ "  RECEIVED:\n"
#~ "    total: 0\n"
#~ "    rps: 0\n"
#~ "...\n"
#~ "tarantool> box.stat.vinyl().tx.commit -- a selected item of the table\n"
#~ "---\n"
#~ "- 1047632\n"
#~ "..."
#~ msgstr ""
#~ "tarantool> box.stat()\n"
#~ "---\n"
#~ "- DELETE:\n"
#~ "    total: 1873949\n"
#~ "    rps: 123\n"
#~ "  SELECT:\n"
#~ "    total: 1237723\n"
#~ "    rps: 4099\n"
#~ "  INSERT:\n"
#~ "    total: 0\n"
#~ "    rps: 0\n"
#~ "  EVAL:\n"
#~ "    total: 0\n"
#~ "    rps: 0\n"
#~ "  CALL:\n"
#~ "    total: 0\n"
#~ "    rps: 0\n"
#~ "  REPLACE:\n"
#~ "    total: 1239123\n"
#~ "    rps: 7849\n"
#~ "  UPSERT:\n"
#~ "    total: 0\n"
#~ "    rps: 0\n"
#~ "  AUTH:\n"
#~ "    total: 0\n"
#~ "    rps: 0\n"
#~ "  ERROR:\n"
#~ "    total: 0\n"
#~ "    rps: 0\n"
#~ "  UPDATE:\n"
#~ "    total: 0\n"
#~ "    rps: 0\n"
#~ "...\n"
#~ "tarantool> box.stat().DELETE -- выбранный пункт таблицы\n"
#~ "---\n"
#~ "- total: 0\n"
#~ "  rps: 0\n"
#~ "...\n"
#~ "tarantool> box.stat.net()\n"
#~ "---\n"
#~ "- SENT:\n"
#~ "    total: 0\n"
#~ "    rps: 0\n"
#~ "  RECEIVED:\n"
#~ "    total: 0\n"
#~ "    rps: 0\n"
#~ "...\n"
#~ "tarantool> box.stat.vinyl().tx.commit -- выбранный пункт таблицы\n"
#~ "---\n"
#~ "- 1047632\n"
#~ "..."

#~ msgid "error if the operation fails to write to disk."
#~ msgstr "ошибка, если операция не может выполнить запись на диск."

#~ msgid ""
#~ "any error that :ref:`box.begin() <box-"
#~ "begin>` and :ref:`box.commit() <box-commit>`"
#~ " can return."
#~ msgstr ""
#~ "любая ошибка, которую могут вернуть "
#~ ":ref:`box.begin() <box-begin>` и "
#~ ":ref:`box.commit() <box-commit>`."

#~ msgid "Create the first :ref:`index <index-box_index>` (named 'primary'):"
#~ msgstr "Создайте первый :ref:`индекс <index-box_index>` (с именем 'primary'):"

#~ msgid "This is a primary index based on the 'id' field of each tuple."
#~ msgstr "Это первичный индекс по полю 'id' в каждом кортеже."

#~ msgid "To select a tuple using the 'primary' index, say:"
#~ msgstr "Для выборки кортежей по первичному индексу выполните команду:"

#~ msgid "To add a secondary index based on the 'band_name' field, say:"
#~ msgstr ""
#~ "Для добавления вторичного индекса по "
#~ "полю 'band_name' используйте эту команду:"

#~ msgid "To select tuples using the 'secondary' index, say:"
#~ msgstr "Для выборки кортежей по вторичному индексу выполните команду:"

#~ msgid ""
#~ "conn:call('function5')\n"
#~ "conn:call('fx',{1,'B'},{timeout=99})"
#~ msgstr ""
#~ "conn:call('function5')\n"
#~ " conn:call('fx',{1,'B'},{timeout=99})"

#~ msgid ""
#~ "conn:eval('return 5+5')\n"
#~ "conn:eval('return ...', {1,2,3})\n"
#~ "conn:eval('return 5+5, {}, {timeout=0.1})"
#~ msgstr ""
#~ "conn:eval('return 5+5')\n"
#~ " conn:eval('return ...', {1,2,3})\n"
#~ " conn:eval('return 5+5, {}, {timeout=0.1})"

#~ msgid ""
#~ "The handler-function parameter may be"
#~ " a function name (for example "
#~ "``function_55``), a function declaration (for"
#~ " example ``function () print('!') end``),"
#~ " or a table including handler = "
#~ "function (for example ``{handler=function_55, "
#~ "name='A'}``)."
#~ msgstr ""
#~ "Параметр handler-function может представлять"
#~ " собой имя функции (например, "
#~ "``function_55``), объявление функции (например, "
#~ "``function () print('!') end``) или "
#~ "таблицу с handler = функция (например,"
#~ " ``{handler=function_55, name='A'}``)."

#~ msgid "``socket.tcp_server('localhost', 3302, function () end)``"
#~ msgstr "``socket.tcp_server('localhost', 3302, function () end)``"

#~ msgid "You can see this by saying \"table\":"
#~ msgstr "Выполнив команду \"table\", можно увидеть доступные функции:"

#~ msgid ""
#~ "tarantool> table\n"
#~ "---\n"
#~ "- maxn: 'function: builtin#90'\n"
#~ "  copy: 'function: 0x41e9d300'\n"
#~ "  new: 'function: builtin#94'\n"
#~ "  clear: 'function: builtin#95'\n"
#~ "  move: 'function: 0x41e918e0'\n"
#~ "  foreach: 'function: 0x41e91588'\n"
#~ "  sort: 'function: builtin#93'\n"
#~ "  remove: 'function: 0x41e917c8'\n"
#~ "  foreachi: 'function: 0x41e914b8'\n"
#~ "  deepcopy: 'function: 0x41e9d2e0'\n"
#~ "  getn: 'function: 0x41e91620'\n"
#~ "  concat: 'function: builtin#92'\n"
#~ "  insert: 'function: builtin#91'\n"
#~ "..."
#~ msgstr ""
#~ "tarantool> table\n"
#~ "---\n"
#~ "- maxn: 'function: builtin#90'\n"
#~ "  copy: 'function: 0x41e9d300'\n"
#~ "  new: 'function: builtin#94'\n"
#~ "  clear: 'function: builtin#95'\n"
#~ "  move: 'function: 0x41e918e0'\n"
#~ "  foreach: 'function: 0x41e91588'\n"
#~ "  sort: 'function: builtin#93'\n"
#~ "  remove: 'function: 0x41e917c8'\n"
#~ "  foreachi: 'function: 0x41e914b8'\n"
#~ "  deepcopy: 'function: 0x41e9d2e0'\n"
#~ "  getn: 'function: 0x41e91620'\n"
#~ "  concat: 'function: builtin#92'\n"
#~ "  insert: 'function: builtin#91'\n"
#~ "..."

#~ msgid ""
#~ "SENT – the bucket was migrated to"
#~ " the destination replica set. The "
#~ "`router` uses this state to calculate"
#~ " the new location of the bucket. "
#~ "The bucket in the SENT state goes"
#~ " to the GARBAGE state automatically "
#~ "in 0.5 seconds after migration (the "
#~ "time period is defined by the "
#~ "BUCKET_SENT_GARBAGE_DELAY value)."
#~ msgstr ""
#~ "SENT (отправленный) -- произошла миграция "
#~ "сегмента в целевой набор реплик. "
#~ "`Роутер` использует такой статус, чтобы "
#~ "рассчитать новое местоположение сегмента. "
#~ "Отправленный сегмент в статусе SENT "
#~ "автоматически переходит в статус мусора "
#~ "GARBAGE через 0,5 секунды после миграции"
#~ " (это время задается в параметре "
#~ "BUCKET_SENT_GARBAGE_DELAY)."

#~ msgid ""
#~ ":ref:`vshard.router.call(bucket_id, mode(read:write), "
#~ "function_name, {argument_list}, {options}) "
#~ "<router_api-call>`"
#~ msgstr ""
#~ ":ref:`vshard.router.call(bucket_id, mode(read:write), "
#~ "function_name, {argument_list}, {options}) "
#~ "<router_api-call>`"

#~ msgid ""
#~ "A router created via ``vshard.router.new()``"
#~ " works in the same way as a "
#~ "static router, but requires a colon "
#~ "before calling its methods "
#~ "(``vshard.router:method_name(...)``), while a static"
#~ " router requires a dot "
#~ "(``vshard.router.method_name(...)``)."
#~ msgstr ""
#~ "Роутер, созданный с помощью "
#~ "``vshard.router.new()``, работает так же, как"
#~ " и статичный роутер, но при вызове"
#~ " перед его методами необходимо указывать"
#~ " двоеточие, а (``vshard.router:метод(...)``), а"
#~ " перед методами статичного роутера -- "
#~ "точку (``vshard.router.метод(...)``)."

#~ msgid ""
#~ "result = vshard.router.call(100, 'write', "
#~ "'customer_add', {{customer_id = 2, bucket_id"
#~ " = 100, name = 'name2', accounts "
#~ "= {}}}, {timeout = 100})"
#~ msgstr ""
#~ "result = vshard.router.call(100, 'write', "
#~ "'customer_add', {{customer_id = 2, bucket_id"
#~ " = 100, name = 'name2', accounts "
#~ "= {}}}, {timeout = 100})"

#~ msgid ""
#~ "Call the user function on the "
#~ "shard storing the bucket with the "
#~ "specified bucket id in the read "
#~ "only mode. See the :ref:`Processing "
#~ "requests <vshard-process-requests>` section"
#~ " for details on function operation."
#~ msgstr ""
#~ "Вызов пользовательской функции на шарде, "
#~ "где хранится сегмент с указанным "
#~ "идентификатором, в режиме только чтения. "
#~ "Для получения подробной информации о "
#~ "работе функции см. раздел :ref:`Обработка "
#~ "запросов <vshard-process-requests>`."

#~ msgid ""
#~ "Call the user function on the "
#~ "shard storing the bucket with the "
#~ "specified bucket id in the write "
#~ "mode. See the :ref:`Processing requests "
#~ "<vshard-process-requests>` section for "
#~ "details on function operation."
#~ msgstr ""
#~ "Вызов пользовательской функции на шарде, "
#~ "где хранится сегмент с указанным "
#~ "идентификатором, в режиме записи. Для "
#~ "получения подробной информации о работе "
#~ "функции см. раздел :ref:`Обработка запросов"
#~ " <vshard-process-requests>`."

#~ msgid ""
#~ "``box.backup.start()`` informs the server that"
#~ " some activities that might interfer "
#~ "with backup should be suspended -- "
#~ "suspend checkpointing, suspend Tarantool "
#~ "garbage collection, and effectively enter "
#~ "read-only mode."
#~ msgstr ""
#~ "``box.backup.start()`` сообщает серверу, что "
#~ "следует отложить некоторые действия, которые"
#~ " могут помешать резервному копированию --"
#~ " отложить создание контрольной точки, "
#~ "отложить сборку мусора и фактически "
#~ "перейти в режим только для чтения."

#~ msgid "search values"
#~ msgstr "искомые значения"

#~ msgid ""
#~ "To prepare, paste the code into a"
#~ " file named :file:`example.py` and install"
#~ " the ``tarantool-python`` connector with"
#~ " either :samp:`pip install tarantool\\>0.4` "
#~ "to install in :file:`/usr` (requires "
#~ "**root** privilege) or :samp:`pip install "
#~ "tarantool\\>0.4 --user` to install in "
#~ ":file:`~` i.e. user's default directory. "
#~ "Before trying to run, check that "
#~ "the server instance is :ref:`listening "
#~ "<cfg_basic-listen>` at ``localhost:3301`` and "
#~ "that the space ``examples`` exists, as"
#~ " :ref:`described earlier <index-"
#~ "connector_setting>`. To run the program, "
#~ "say :samp:`python example.py`. The program "
#~ "will connect to the Tarantool server,"
#~ " will send the :ref:`INSERT<box_space-"
#~ "insert>` request, and will not throw "
#~ "any exception if all went well. If"
#~ " the tuple already exists, the "
#~ "program will throw ``tarantool.error.DatabaseError:"
#~ " (3, \"Duplicate key exists in unique"
#~ " index 'primary' in space 'examples'\")``."
#~ msgstr ""
#~ "Для подготовки сохраните код в файл "
#~ "с именем :file:`example.py` и установите "
#~ "коннектор ``tarantool-python``. Для установки"
#~ " коннектора воспользуйтесь либо командой "
#~ "samp:`pip install tarantool\\>0.4` для "
#~ "установки в директорию :file:`/usr` "
#~ "(потребуются права уровня  **root**), либо "
#~ "командой :samp:`pip install tarantool\\>0.4 "
#~ "--user` для установки в директорию "
#~ ":file:`~`, т.е. в используемую по "
#~ "умолчанию директорию текущего пользователя. "
#~ "Перед запуском проверьте, что у "
#~ "экземпляра задан порт для :ref:`прослушивания"
#~ " <cfg_basic-listen>` на ``localhost:3301``, "
#~ "и в базе создан спейс ``examples``, "
#~ "как :ref:`описано выше <index-"
#~ "connector_setting>`. Чтобы запустить программу, "
#~ "выполните команду :samp:`python example.py`. "
#~ "Программа установит соединение с "
#~ "Tarantool-сервером, пошлет :ref:`INSERT-запрос "
#~ "<box_space-insert>` и не выбросит никакого"
#~ " исключения, если всё прошло хорошо. "
#~ "Если такой кортеж уже существует, то "
#~ "программа выбросит исключение "
#~ "``tarantool.error.DatabaseError: (3, \"Duplicate key"
#~ " exists in unique index 'primary' in"
#~ " space 'examples'\")``."

#~ msgid "This exception cannot be caught by pcall or xpcall."
#~ msgstr "Это исключение нельзя найти при помощи pcall или xpcall."

#~ msgid ""
#~ "Also, some MsgPack configuration settings "
#~ "for encoding can be changed, in "
#~ "the same way that they can be "
#~ "changed for :ref:`JSON <json-module_cfg>`."
#~ msgstr ""
#~ "Кроме того, некоторые параметры конфигурации"
#~ " MsgPack для кодировки можно изменить "
#~ "так же, как и для :ref:`JSON "
#~ "<json-module_cfg>`."

