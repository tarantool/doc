
msgid "Developer's guide"
msgstr "Руководство для разработчика"

msgid ""
"To develop an application, use the Tarantool Cartridge framework that is "
":ref:`installed <enterprise-install>` as part of Tarantool Enterprise."
msgstr ""
"Для разработки приложений используйте среду Tarantool Cartridge, которая "
":ref:`установлена <enterprise-install>` как компонент Tarantool Enterprise."

msgid "Here is a summary of the commands you need:"
msgstr "Ниже приведен список необходимых команд:"

msgid "Create a cluster-aware application from the template:"
msgstr "Создайте приложение с поддержкой кластеров из шаблона:"

msgid "Develop your application:"
msgstr "Разработайте приложение:"

msgid "Package your application:"
msgstr "Упакуйте приложение:"

msgid "Deploy your application:"
msgstr "Разверните приложение:"

msgid "For ``rpm`` package:"
msgstr "Для пакета ``rpm``:"

msgid "Upload the package to all servers dedicated to Tarantool."
msgstr "Загрузите пакет на все серверы, выделенные для Tarantool."

msgid "Install the package:"
msgstr "Установите пакет:"

msgid "Launch the application."
msgstr "Запустите приложение."

msgid "For ``tgz`` archive:"
msgstr "Для архива ``tgz``:"

msgid "Upload the archive to all servers dedicated to Tarantool."
msgstr "Загрузите архив на все серверы, выделенные для Tarantool."

msgid "Unpack the archive:"
msgstr "Распакуйте архив:"

msgid "Launch the application"
msgstr "Запустите приложение"

msgid ""
"For details and examples, please consult the open-source Tarantool "
"documentation:"
msgstr ""
"Более подробную информацию с примерами см. в документации по Tarantool с "
"открытым кодом:"

msgid ""
"a `getting started guide <https://github.com/tarantool/cartridge-"
"cli/blob/master/examples/getting-started-app/README.md>`_ that walks you "
"through developing and deploying a simple clustered application using "
"Tarantool Cartridge,"
msgstr ""
"`руководство для начинающих <https://github.com/tarantool/cartridge-"
"cli/blob/master/examples/getting-started-app/README.md>`_, в котором "
"пошагово разбирается разработка и развертывание простого кластерного "
"приложения с помощью Tarantool Cartridge,"

msgid ""
"a `detailed manual </book/cartridge/>`_ "
"on creating and managing clustered Tarantool applications using Tarantool "
"Cartridge."
msgstr ""
"`подробное руководство "
"</book/cartridge/>`_ по созданию и "
"управлению кластерными приложениями Tarantool с помощью Tarantool Cartridge."

msgid ""
"Further on, this guide focuses on Enterprise-specific developer features "
"available on top of the open-source Tarantool version with the Tarantool "
"Cartridge framework:"
msgstr ""
"Кроме того, в этом руководстве особое внимание уделяется функциям "
"разработчика, специфичным для Enterprise-версии, которые доступны в "
"дополнение к версии Tarantool с открытым исходным кодом в среде Tarantool "
"Cartridge:"

msgid ":ref:`LDAP authorization in the web interface <ldap_auth>`,"
msgstr ""
":ref:`авторизация с использованием LDAP в веб-интерфейсе <ldap_auth>`,"

msgid ""
":ref:`environment-independent applications <enterprise-env-independent-"
"apps>`,"
msgstr ""
":ref:`независимые от среды приложения <enterprise-env-independent-apps>`,"

msgid ""
":ref:`sample applications with Enterprise flavors <enterprise-run-app>`."
msgstr ""
":ref:`примеры приложений, которые подходят для Enterprise-версии "
"<enterprise-run-app>`."

msgid "Implementing LDAP authorization in the web interface"
msgstr "Реализация авторизации с использованием LDAP в веб-интерфейсе"

msgid ""
"If you run an LDAP server in your organization, you can connect Tarantool "
"Enterprise to it and let it handle the authorization. In this case, follow "
"the `general recipe "
"</book/cartridge/cartridge_dev/#implementing-"
"authorization-in-the-web-interface>`_ where in the first step add the "
"``ldap`` module to the ``.rockspec`` file as a dependency and consider "
"implementing the ``check_password`` function the following way:"
msgstr ""
"Если в вашей организации есть сервер LDAP, можно подключить к нему Tarantool"
" Enterprise для обработки авторизации. В этом случае следуйте `общим "
"рекомендациям "
"</book/cartridge/cartridge_dev/#implementing-"
"authorization-in-the-web-interface>`_ "
"</book/cartridge/cartridge_dev/#implementing-"
"authorization-in-the-web-interface>`_ , где на первом шаге необходимо "
"добавить модуль ``ldap`` в файл ``.rockspec`` в качестве зависимости; "
"рекомендуется также реализовать функцию ``check_password`` следующим "
"образом:"

msgid "Delivering environment-independent applications"
msgstr "Формирование независимых от среды приложений"

msgid ""
"Tarantool Enterprise allows you to build environment-independent "
"applications."
msgstr ""
"Tarantool Enterprise позволяет создавать независимые от среды приложения."

msgid ""
"An environment-independent application is an assembly (in one directory) of:"
msgstr ""
"Независимое от среды приложение представляет собой сборку следующих "
"компонентов (в одной директории):"

msgid "files with Lua code,"
msgstr "файлы с кодом на Lua,"

msgid "``tarantool`` executable,"
msgstr "исполняемый файл ``tarantool``,"

msgid "plugged external modules (if necessary)."
msgstr "подключенные внешние модули (при необходимости)."

msgid ""
"When started by the ``tarantool`` executable, the application provides a "
"service."
msgstr ""
"Запущенное с помощью исполняемого файла tarantool приложение обеспечивает "
"работу сервиса."

msgid ""
"The modules are Lua rocks installed into a virtual environment (under the "
"application directory) similar to Python's ``virtualenv`` and Ruby's "
"bundler."
msgstr ""
"Модули -- это сторонние библиотеки на Lua, установленные в виртуальную среду"
" (в директории приложения), которая аналогична ``virtualenv`` в Python и "
"bundler в Ruby."

msgid ""
"Such an application has the same structure both in development and "
"production-ready phases. All the application-related code resides in one "
"place, ready to be packed and copied over to any server."
msgstr ""
"Структура такого приложения остается неизменной как на стадии разработки, "
"так и на стадии производственной эксплуатации. Весь связанный с приложением "
"код находится в одном месте, готов к упаковке и копированию на любой сервер."

msgid "Packaging applications"
msgstr "Упаковка приложений"

msgid ""
"Once custom cluster role(s) are defined and the application is developed, "
"pack it and all its dependencies (module binaries) together with the "
"``tarantool`` executable."
msgstr ""
"После определения пользовательских кластерных ролей и разработки приложения "
"упакуйте его со всеми зависимостями (бинарные файлы модулей) и с исполняемым"
" файлом ``tarantool``."

msgid ""
"This will allow you to upload, install, and run your application on any "
"server in one go."
msgstr ""
"Это позволит вам легко загружать, устанавливать и запускать приложение на "
"любом сервере."

msgid "To pack the application, say:"
msgstr "Чтобы упаковать приложение, выполните команду:"

msgid ""
"where specify a path to your development environment -- the Git repository "
"containing your application code, -- and one of the following build options:"
msgstr ""
"где укажите путь к вашей среде разработки (репозиторию Git, который содержит"
" код приложения), а также один из параметров сборки:"

msgid "``rpm`` to build an RPM package (recommended), or"
msgstr "``rpm`` для сборки RPM-пакета (рекомендуется), или"

msgid ""
"``tgz`` to build a ``tar + gz`` archive (choose this option only if you do "
"not have root privileges on servers dedicated for Tarantool Enterprise)."
msgstr ""
"``tgz`` для сборки архива ``tar + gz`` (выберите этот параметр, только если "
"у вас нет прав уровня root на серверах, выделенных для Tarantool "
"Enterprise)."

msgid ""
"This will create a package (or compressed archive) named "
"``<app_name>-<version_tag>-<number_of_commits>`` (e.g., "
"``myapp-1.2.1-12.rpm``) containing your environment-independent application."
msgstr ""
"В результате будет создан пакет (или сжатый архив) с именем "
"``<имя_приложения>-<версия_тег>-<количество_коммитов>`` (например, "
"``myapp-1.2.1-12.rpm``), который будет хранить ваше приложение в не "
"зависимом от среды виде."

msgid ""
"Next, proceed to deploying :ref:`packaged applications <enterprise-packaged-"
"app>` (or :ref:`archived ones <enterprise-archived-app>`) on your servers."
msgstr ""
"Далее переходите к развертыванию :ref:`пакетных <enterprise-packaged-app>` "
"(или же :ref:`архивированных <enterprise-archived-app>`) приложений на "
"серверах."

msgid "Deploying packaged applications"
msgstr "Развертывание пакетных приложений"

msgid ""
"To deploy your packaged application, do the following on every server "
"dedicated for Tarantool Enterprise:"
msgstr ""
"Чтобы развернуть пакетное приложение, выполните следующие действия на каждом"
" сервере, выделенном для Tarantool Enterprise:"

msgid ""
"Upload the package created in the :ref:`previous step <enterprise-app-"
"package>`."
msgstr ""
"Загрузите локально пакет, созданный на :ref:`предыдущем шаге <enterprise-"
"app-package>`."

msgid "Install:"
msgstr "Установите приложение:"

msgid ""
"Start one or multiple Tarantool instances with the corresponding services as"
" described below."
msgstr ""
"Запустите один или несколько экземпляров Tarantool с соответствующими "
"сервисами, как описано ниже."

msgid "A single instance:"
msgstr "Отдельный экземпляр:"

msgid ""
"This will start an instantiated ``systemd`` service that will listen to port"
" ``3301``."
msgstr ""
"Это запустит экземпляр сервиса ``systemd`` с прослушиванием по порту "
"``3301``."

msgid "Multiple instances on one or multiple servers:"
msgstr "Несколько экземпляров на одном или нескольких серверах:"

msgid ""
"where ``<app_name>@instance_<number>`` is the instantiated service name for "
"``systemd`` with an incremental ``<number>`` (unique for every instance) to "
"be added to the ``3300`` port the instance will listen to (e.g., ``3301``, "
"``3302``, etc.)."
msgstr ""
"где ``<app_name>@instance_<number>`` (<имя_приложения>@экземпляр_<число>) --"
" это имя экземпляра сервиса ``systemd`` с инкрементным числом ``<number>`` "
"(уникальным для каждого экземпляра), которое следует добавить к порту "
"``3300`` для настройки прослушивания (например, ``3301``, ``3302`` и т.д.)."

msgid ""
"In case it is a cluster-aware application, proceed to `deploying the cluster"
" "
"</book/cartridge/cartridge_admin/#deploying-"
"the-cluster>`_."
msgstr ""
"Если это приложение с поддержкой кластеров, далее переходите к "
"`развертыванию кластера "
"</book/cartridge/cartridge_admin/#deploying-"
"the-cluster>`_."

msgid ""
"To stop all services on a server, use the ``systemctl stop`` command and "
"specify instance names one by one. For example:"
msgstr ""
"Чтобы остановить все сервисы на сервере, используйте команду ``systemctl "
"stop`` и укажите имена экземпляров по одному. Например:"

msgid "Deploying archived applications"
msgstr "Развертывание архивированных приложений"

msgid ""
"While the RPM package places your application to "
"``/usr/share/tarantool/<app_name>`` on your server by default, the ``tar + "
"gz`` archive does not enforce any structure apart from just the "
"``<app_name>/`` directory, so you are responsible for placing it "
"appropriately."
msgstr ""
"Тогда как пакет RPM по умолчанию помещает ваше приложение в "
"``/usr/share/tarantool/<имя_приложения>`` на вашем сервере, архив ``tar + "
"gz`` не создает какую-либо структуру, помимо директории "
"``<имя_приложения>/``, поэтому вы сами несете ответственность за "
"правильность размещения приложения."

msgid ""
"RPM packages are recommended for deployment. Deploy archives only if you do "
"not have root privileges."
msgstr ""
"Для развертывания рекомендуется использовать RPM-пакеты. Развертывайте "
"архивы, только если у вас нет прав уровня root."

msgid ""
"To place and deploy the application, do the following on every server "
"dedicated for Tarantool Enterprise:"
msgstr ""
"Чтобы разместить и развернуть приложение, выполните следующие действия на "
"каждом сервере, выделенном для Tarantool Enterprise:"

msgid ""
"Upload the archive, decompress, and extract it to the ``/home/<user>/apps`` "
"directory:"
msgstr ""
"Загрузите архив, распакуйте его и извлеките содержимое в директорию "
"``/home/<user>/apps``:"

msgid "Start Tarantool instances with the corresponding services."
msgstr "Запустите экземпляры Tarantool с соответствующими сервисами."

msgid ""
"To manage instances and configuration, use tools like ``ansible``, "
"``systemd``, and ``supervisord``."
msgstr ""
"Для управления и конфигурации экземпляров используйте такие средства, как "
"``ansible``, ``systemd`` и ``supervisord``."

msgid "Upgrading code"
msgstr "Обновление кода"

msgid ""
"All instances in the cluster are to run the same code. This includes all the"
" components: custom roles, applications, module binaries, ``tarantool``, and "
"``tt`` (if necessary) executables."
msgstr ""
"Все экземпляры в кластере должны использовать один и тот же код. Это "
"относится ко всем компонентам: пользовательским ролям, приложениям, бинарным"
" файлам модулей, исполняемым файлам ``tarantool`` и ``tt`` (при "
"необходимости)."

msgid ""
"Pay attention to possible backward incompatibility that any component may "
"introduce. This will help you choose a scenario for an :ref:`upgrade in "
"production <enterprise-production-upgrade>`. Keep in mind that you are "
"responsible for code compatibility and handling conflicts should "
"inconsistencies occur."
msgstr ""
"Обратите внимание на возможную обратную совместимость, которую может "
"принести с собой любой компонент. Это поможет вам выбрать сценарий для "
":ref:`обновления в эксплуатационной среде <enterprise-production-upgrade>`. "
"Имейте в виду, что вы несете ответственность за совместимость кода и "
"обработку конфликтов в случае возникновения несоответствий."

msgid ""
"To upgrade any of the components, prepare a new version of the package "
"(archive):"
msgstr ""
"Чтобы обновить любой из компонентов, подготовьте новую версию пакета "
"(архива):"

msgid ""
"Update the necessary files in your development environment (directory):"
msgstr "Обновите необходимые файлы в вашей среде разработки (директории):"

msgid "Your own source code: custom roles and/or applications."
msgstr ""
"Ваш собственный исходный код: пользовательские роли и / или приложения."

msgid "Module binaries."
msgstr "Бинарные файлы модулей."

msgid "Executables. Replace them with ones from the new bundle."
msgstr "Исполняемые файлы. Замените их на файлы из нового комплекта."

msgid ""
"Increment the version as described in `application versioning "
"</book/cartridge/cartridge_dev/#application-"
"versioning>`_."
msgstr ""
"Увеличьте версию, как описано в разделе по `управлению версиями приложения "
"</book/cartridge/cartridge_dev/#application-"
"versioning>`_."

msgid ""
"Repack the updated files as described in :ref:`packaging applications "
"<enterprise-app-package>`."
msgstr ""
"Повторно упакуйте обновленные файлы, как описано в разделе по :ref:`упаковке"
" приложений <enterprise-app-package>`."

msgid ""
"Choose an upgrade scenario as described in the :ref:`Upgrading in production "
"<enterprise-production-upgrade>` section."
msgstr ""
"Выберите сценарий обновления, как описано в разделе по :ref:`обновлению в "
"эксплуатационной среде <enterprise-production-upgrade>`."

msgid "Running sample applications"
msgstr "Запуск примеров приложений"

msgid ""
"The Enterprise distribution package includes sample applications in the "
"``examples/`` directory that showcase basic Tarantool functionality."
msgstr ""
"Дистрибутив Enterprise включает в себя примеры приложений в директории "
"``examples/``, которые демонстрируют основные функциональные возможности "
"Tarantool."

msgid "Sample applications:"
msgstr "Примеры приложений:"

msgid "Write-through cache application for PostgreSQL"
msgstr "Приложение кэширования со сквозной записью в PostgreSQL"

msgid ""
"The example in ``pg_writethrough_cache/`` shows how Tarantool can cache data"
" written *through* it to a PostgreSQL database to speed up the reads."
msgstr ""
"Пример в ``pg_writethrough_cache/`` показывает, как Tarantool может "
"кэшировать данные, записанные через него в базу данных PostgreSQL для "
"ускорения запросов на чтение."

msgid ""
"The sample application requires a deployed PostgreSQL database and the "
"following rock modules:"
msgstr ""
"Для примера приложения требуется развернутая база данных PostgreSQL и "
"следующие модули сторонних библиотек:"

msgid ""
"Look through the code in the files to get an understanding of what the "
"application does."
msgstr "Просмотрите код в файлах, чтобы понять, что может делать приложение."

msgid "To run the application for a local PostgreSQL database, say:"
msgstr ""
"Чтобы запустить приложение для локальной базы данных PostgreSQL, выполните "
"команду:"

msgid "Write-behind cache application for Oracle"
msgstr "Приложение кэширования с отложенной записью в Oracle"

msgid ""
"The example in ``ora-writebehind-cache/`` shows how Tarantool can cache "
"writes and queue them to an Oracle database to speed up both writes and "
"reads."
msgstr ""
"Пример в ``ora-writebehind-cache/`` показывает, как Tarantool может "
"кэшировать записи и помещать их в базу данных Oracle для ускорения как "
"записи, так и чтения."

msgid "Application requirements"
msgstr "Требования приложения"

msgid "The sample application requires:"
msgstr "Для примера приложения необходимы:"

msgid "deployed Oracle database;"
msgstr "развернутая база данных Oracle;"

msgid ""
"Oracle tools: `Instant Client and SQL Plus "
"<https://www.oracle.com/technetwork/topics/linuxx86-64soft-092277.html>`_, "
"both of version 12.2;"
msgstr ""
"инструменты Oracle: `Instant Client and SQL Plus "
"<https://www.oracle.com/technetwork/topics/linuxx86-64soft-092277.html>`_, "
"оба версии 12.2;"

msgid ""
"In case the Oracle Instant Client errors out on ``.so`` files (Oracle's "
"dynamic libraries), put them to some directory and add it to the "
"``LD_LIBRARY_PATH`` environment variable."
msgstr ""
"Если Oracle Instant Client выдает ошибки в файлах с расширением ``.so`` "
"(динамические библиотеки Oracle), поместите их в какую-либо директорию и "
"добавьте ее в переменную окружения ``LD_LIBRARY_PATH``."

msgid ""
"For example: ``export "
"LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$PWD/<path_to_so_files>``"
msgstr ""
"Например: ``export "
"LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$PWD/<путь_к_файлам_so>``"

msgid "rock modules listed in the ``rockspec`` file."
msgstr "модули сторонних библиотек, перечисленные в файле ``rockspec``."

msgid ""
"To install the modules, run the following command in the "
"``examples/ora_writebehind_cache`` directory:"
msgstr ""
"Чтобы установить модули, выполните следующую команду в директории "
"``examples/ora_writebehind_cache``:"

msgid ""
"If you do not have a deployed Oracle instance at hand, run a dummy in a "
"Docker container:"
msgstr ""
"Если у вас нет развернутого экземпляра Oracle под рукой, запустите пустой "
"объект в контейнере Docker:"

msgid ""
"In the browser, log in to `Oracle container registry <container-"
"registry.oracle.com>`_, click **Database**, and accept the Oracle's "
"Enterprise Terms and Restrictions."
msgstr ""
"В браузере войдите в `Реестр контейнеров Oracle <container-"
"registry.oracle.com>`_, выберите **Database** (База данных) и примите "
"«Корпоративные условия и ограничения Oracle»."

msgid ""
"In the ``ora-writebehind-cache/`` directory, log in to the repository under "
"the Oracle account, pull, and run an image using the prepared scripts:"
msgstr ""
"В директории ``ora-writebehind-cache/`` войдите в репозиторий под учетной "
"записью Oracle, получите данные и запустите образ с помощью подготовленных "
"скриптов"

msgid "When all is set and done, run the example application."
msgstr "Когда всё будет готово, запустите пример приложения."

msgid "Running write-behind cache"
msgstr "Запуск кэширования с отложенной записью"

msgid ""
"To launch the application, run the following in the "
"``examples/ora_writebehind_cache`` directory:"
msgstr ""
"Чтобы запустить приложение, выполните следующую команду в директории "
"``examples/ora_writebehind_cache``:"

msgid "The application supports the following requests:"
msgstr "Данное приложение поддерживает следующие запросы:"

msgid "Get: ``GET http://<host>:<http_port>/account/id``;"
msgstr "Получение данных: ``GET http://<host>:<http_port>/account/id``;"

msgid ""
"Add: ``POST http://<host>:<http_port>/account/`` with the following data:"
msgstr ""
"Добавление: ``POST http://<host>:<http_port>/account/`` со следующими "
"данными:"

msgid ""
"Update: ``POST http://<host>:<http_port>/account/id`` with the same data as "
"in the add request;"
msgstr ""
"Обновление: ``POST http://<host>:<http_port>/account/id`` с теми же данными,"
" что и в запросе на добавление;"

msgid ""
"Remove: ``DELETE http://<host>:<http_port>/account/id`` where ``id`` is an "
"account identifier."
msgstr ""
"Удаление: ``DELETE http://<host>:<http_port>/account/id``,где ``id`` -- это "
"идентификатор учетной записи."

msgid ""
"Look for sample CURL scripts in the "
"``examples/ora_writebehind_cache/testing`` directory and check "
"``README.md`` for more information on implementation."
msgstr ""
"Взгляните на примеры скриптов CURL в директории "
"``examples/ora_writebehind_cache/testing`` и просмотрите файл ``README.md`` "
"для получения дополнительной информации об их использовании."

msgid "Hello-world application in Docker"
msgstr "Простейшее приложение в Docker"

msgid ""
"The example in the ``docker/`` directory contains a hello-world application "
"that you can pack in a Docker container and run on CentOS 7."
msgstr ""
"Пример в директории ``docker/`` содержит простейшее приложение, которое "
"можно упаковать в контейнер Docker и запустить на CentOS 7."

msgid ""
"The ``hello.lua`` file is the entry point and it is very bare-bones, so you "
"can add your code here."
msgstr ""
"Файл ``hello.lua`` представляет собой элементарную точку входа в приложение,"
" поэтому вы можете добавить туда собственный код."

msgid "To build the container, say:"
msgstr "Чтобы создать контейнер, выполните команду:"

msgid "To run it:"
msgstr "Чтобы запустить его:"

#~ msgid ""
#~ "Implement some setters (and getters, if necessary) using the "
#~ "``cluster.confapplier`` public API functions: ``get_readonly(section)``, "
#~ "``get_deepcopy(section)``, and ``patch_clusterwide({section = "
#~ "section_cfg})``."
#~ msgstr ""
#~ "Использовать некоторые сеттеры (и геттеры, если необходимо), с помощью "
#~ "функций общедоступного API ``cluster.confapplier``: "
#~ "``get_readonly(section)``, ``get_deepcopy(section)`` и "
#~ "``patch_clusterwide({section = section_cfg})``."

#~ msgid ""
#~ "Define, first, the ``validate_config(conf_new, conf_old)``, then the "
#~ "``apply_config(conf, opts)`` functions."
#~ msgstr ""
#~ "Сначала определить ``validate_config(conf_new, conf_old)``, затем функции "
#~ "``apply_config(conf, opts)``."

#~ msgid ""
#~ "These functions both take two Lua tables as arguments: the ones dubbed with "
#~ "``conf`` are configuration tables as you might have guessed, and ``opts`` "
#~ "includes a boolean ``is_master`` flag described later."
#~ msgstr ""
#~ "Обе эти функции принимают в качестве аргументов две Lua-таблицы: в ``conf`` "
#~ "передаются таблицы конфигурации, а в ``opts`` -- логический флаг "
#~ "``is_master``, описанный ниже."

#~ msgid "Once the application is developed, pack it as described below."
#~ msgstr "После разработки приложения, упакуйте его, как описано ниже."

#~ msgid "where specify one of the following options:"
#~ msgstr "где укажите один из следующих параметров:"

#~ msgid "(Recommended) ``rpm`` to create an RPM package."
#~ msgstr "(Рекомендованный) ``rpm`` для создания RPM-пакета."

#~ msgid ""
#~ "This guide explains how to develop environment-independent applications -- "
#~ "either cluster-aware or not -- and run sample applications provided by the "
#~ "distribution."
#~ msgstr ""
#~ "В данном руководстве описывается, как разрабатывать независимые от среды "
#~ "приложения – как с поддержкой кластеров, так и без нее -- и запускать "
#~ "примеры приложений, включенные в дистрибутив."

#~ msgid ""
#~ "To develop and run an application, in short, you need to go through the "
#~ "following steps:"
#~ msgstr ""
#~ "Итак, чтобы разработать и запустить приложение, вам необходимо выполнить "
#~ "следующие шаги:"

#~ msgid "Set up a development environment from a template for the application."
#~ msgstr "Настройте среду разработки из шаблона для приложения."

#~ msgid ""
#~ "Develop the application. In case it is a cluster-aware application, "
#~ "implement it in a custom cluster role to initialize the database in a "
#~ "cluster environment."
#~ msgstr ""
#~ "Разработайте приложение. Если это приложение с поддержкой кластеров, "
#~ "реализуйте его в виде отдельной кластерной роли, чтобы инициализировать базу"
#~ " данных в кластерной среде."

#~ msgid "Plug all the necessary rock modules."
#~ msgstr "Подключите все необходимые модули из сторонних библиотек."

#~ msgid ""
#~ "Pack the application and module binaries together with the ``tarantool`` "
#~ "executable."
#~ msgstr ""
#~ "Упакуйте бинарные файлы приложения и модулей вместе с исполняемым файлом "
#~ "``tarantool``."

#~ msgid ""
#~ "Upload, install, and start corresponding instantiated services on every "
#~ "server dedicated for Tarantool Enterprise."
#~ msgstr ""
#~ "Загрузите, установите и запустите соответствующие экземпляры сервисов на "
#~ "каждом сервере, выделенном для Tarantool Enterprise."

#~ msgid "The following sections provide details for each of these steps."
#~ msgstr "В следующих разделах подробно описывается каждый из этих шагов."

#~ msgid "Setting up development environments from templates"
#~ msgstr "В следующих разделах подробно описывается каждый из этих шагов."

#~ msgid ""
#~ "Tarantool Enterprise provides you with templates to help set up your "
#~ "application development environment for both cluster-aware and plain (e.g., "
#~ "Tarantool as a proxy to third-party databases) application use cases."
#~ msgstr ""
#~ "В Tarantool Enterprise включены шаблоны, которые помогут вам настроить среду"
#~ " для разработки приложений как с поддержкой кластеров, так и без нее "
#~ "(например, для использования Tarantool в качестве прокси для сторонних баз "
#~ "данных)."

#~ msgid "To set up a development environment, in any directory say:"
#~ msgstr ""
#~ "Чтобы настроить среду разработки, в любой директории выполните команду:"

#~ msgid "where specify:"
#~ msgstr "где укажите:"

#~ msgid ""
#~ "the ``plain`` template to develop an application for single or multiple "
#~ "independent Tarantool instances; or"
#~ msgstr ""
#~ "шаблон ``plain`` для разработки приложения для одного или нескольких "
#~ "независимых экземпляров Tarantool; или же"

#~ msgid "the ``cluster`` template to develop a cluster-aware application."
#~ msgstr "шаблон ``cluster`` для разработки приложений с поддержкой кластеров."

#~ msgid ""
#~ "The script will automatically set up a Git repository in a new "
#~ "``<app_name>/`` directory, tag it with version ``0.1.0``, and put the "
#~ "necessary files into it."
#~ msgstr ""
#~ "Скрипт автоматически установит Git-репозиторий в новую директорию "
#~ "``<имя_приложения>/``, проставит тег версии 0.1.0 и поместит в него "
#~ "необходимые файлы."

#~ msgid ""
#~ "In this Git repository, you can develop the application, plug the necessary "
#~ "modules, and then easily pack everything to deploy on your server(s)."
#~ msgstr ""
#~ "В этом Git-репозитории можно разработать приложение, подключить необходимые "
#~ "модули, а затем с легкостью упаковать все для развертывания на своих "
#~ "серверах."

#~ msgid ""
#~ "This section describes templates, default files they provide, and introduces"
#~ " the notion of cluster roles that allow you to segregate functionality "
#~ "between instances."
#~ msgstr ""
#~ "В этом разделе описываются шаблоны, включенные в них по умолчанию файлы, и "
#~ "вводится понятие кластерных ролей, которые позволяют распределять функции "
#~ "экземпляров."

#~ msgid ""
#~ "To start developing an application, simply edit the default files provided "
#~ "by the template selected in the :ref:`previous step <enterprise-app-"
#~ "template>`."
#~ msgstr ""
#~ "Чтобы начать разработку приложения, просто отредактируйте файлы, включенные "
#~ "по умолчанию в шаблон, который был выбран на :ref:`предыдущем шаге "
#~ "<enterprise-app-template>`."

#~ msgid ""
#~ "During development, keep track of the :ref:`application version <enterprise-"
#~ "app-versioning>`."
#~ msgstr ""
#~ "Во время разработки следите за изменением :ref:`версии приложения "
#~ "<enterprise-app-versioning>`."

#~ msgid "Plain template"
#~ msgstr "Шаблон plain"

#~ msgid ""
#~ "The plain template creates the ``<app_name>/`` directory with the following "
#~ "contents:"
#~ msgstr ""
#~ "Шаблон plain создает директорию ``<имя_приложения>/``, которая содержит "
#~ "следующее:"

#~ msgid ""
#~ "``<app_name>-scm-1.rockspec`` file where you can specify the application "
#~ "dependencies."
#~ msgstr ""
#~ "файл ``<имя_приложения>-scm-1.rockspec``, где можно указать зависимости "
#~ "приложения."

#~ msgid ""
#~ "``deps.sh`` script that resolves dependencies from the ``.rockspec`` file."
#~ msgstr ""
#~ "скрипт ``deps.sh``, который решает проблемы с зависимостями из файла "
#~ "``.rockspec``."

#~ msgid "``init.lua`` file which is the entry point for your application."
#~ msgstr "файл ``init.lua``, который является точкой входа в ваше приложение."

#~ msgid "``.git`` file necessary for a Git repository."
#~ msgstr "файл ``.git``, необходимый для Git-репозитория."

#~ msgid "``.gitignore`` file to ignore the unnecessary files."
#~ msgstr "файл ``.gitignore``, чтобы не учитывать ненужные файлы."

#~ msgid "Cluster template"
#~ msgstr "Шаблон cluster"

#~ msgid ""
#~ "In addition to the files listed in the plain template section, the cluster "
#~ "template contains the following:"
#~ msgstr ""
#~ "Помимо файлов, перечисленных в разделе о шаблоне plain, шаблон cluster "
#~ "содержит следующее:"

#~ msgid ""
#~ "``env.lua`` file that sets common rock paths so that the application can be "
#~ "started from any directory."
#~ msgstr ""
#~ "файл ``env.lua``, который устанавливает общие пути для модулей, чтобы "
#~ "приложение можно было запустить из любой директории."

#~ msgid ""
#~ "``custom-role.lua`` file that is a placeholder for a user-defined cluster "
#~ "role described in the :ref:`next section <enterprise-cluster-roles>`."
#~ msgstr ""
#~ "файл ``custom-role.lua`` , который представляет собой объект-заглушку для "
#~ "определяемой пользователем кластерной роли, описанной в :ref:`следующем "
#~ "разделе <enterprise-cluster-roles>`."

#~ msgid ""
#~ "The entry point file (``init.lua``) of the cluster template differs from the"
#~ " plain one. Among other things, it loads the ``cluster`` module and calls "
#~ "its initialization function:"
#~ msgstr ""
#~ "Файл входа в приложение (``init.lua``) в шаблоне cluster отличается от "
#~ "аналогичного файла в шаблоне plain. Помимо прочего, он загружает модуль "
#~ "``cluster`` и вызывает его функцию инициализации:"

#~ msgid ""
#~ "The ``cluster.cfg()`` call renders the instance operable via the "
#~ "administrative console but does not call ``box.cfg()`` to configure "
#~ "instances."
#~ msgstr ""
#~ "Вызов ``cluster.cfg()`` позволяет управлять экземпляром через "
#~ "административную консоль, но не вызывает ``box.cfg()`` для настройки "
#~ "экземпляров."

#~ msgid "Calling the ``box.cfg()`` function is forbidden."
#~ msgstr "Запрещается вызывать функцию ``box.cfg()``."

#~ msgid "The cluster itself will do it for you when it is time to:"
#~ msgstr "Сам кластер сделает это за вас, когда придет время:"

#~ msgid "bootstrap the current instance once you:"
#~ msgstr "загрузить текущий экземпляр, когда вы:"

#~ msgid "run ``cluster.bootstrap()`` via the administrative console, or"
#~ msgstr "выполните ``cluster.bootstrap()`` в административной консоли, или"

#~ msgid "click **Create** in the web interface;"
#~ msgstr "нажмете **Create** (Создать) в веб-интерфейсе;"

#~ msgid "join the instance to an existing cluster once you:"
#~ msgstr "присоединить экземпляр к существующему кластеру, когда вы:"

#~ msgid ""
#~ "run ``cluster.join_server({uri = 'other_instance_uri'})`` via the console, "
#~ "or"
#~ msgstr ""
#~ "выполните ``cluster.join_server({uri = ''uri_другого_экземпляра'})`` в "
#~ "консоли, или"

#~ msgid ""
#~ "click **Join** (an existing replica set) or **Create** (a new replica set) "
#~ "in the web interface."
#~ msgstr ""
#~ "нажмете **Join** (Присоединить -- к уже существующему набору реплик) или "
#~ "**Create** (Создать -- для нового набора реплик) в веб-интерфейсе."

#~ msgid ""
#~ "Notice that you can specify a cookie for the cluster (``cluster_cookie`` "
#~ "parameter) if you need to run several clusters in the same network. The "
#~ "cookie can be any string value."
#~ msgstr ""
#~ "Обратите внимание, что для кластера можно указать cookie (параметр "
#~ "``cluster_cookie``), если необходимо запустить несколько кластеров в одной "
#~ "сети. Указать можно любое строковое значение."

#~ msgid ""
#~ "Before developing a cluster-aware application, familiarize yourself with the"
#~ " notion of cluster roles described in the :ref:`next section <enterprise-"
#~ "cluster-roles>` and make sure to define a custom role to initialize the "
#~ "database for the cluster application."
#~ msgstr ""
#~ "Перед тем как разрабатывать приложение с поддержкой кластеров, ознакомьтесь "
#~ "с понятием кластерных ролей в :ref:`следующем разделе <enterprise-cluster-"
#~ "roles>` и обязательно определите специальную роль для инициализации базы "
#~ "данных для кластерного приложения."

#~ msgid "Defining custom cluster roles"
#~ msgstr "Определение пользовательских кластерных ролей"

#~ msgid ""
#~ "Tarantool Enterprise cluster segregates instance functionality in a role-"
#~ "based way. **Cluster roles** are Lua modules that implement some instance-"
#~ "specific functions and/or logic."
#~ msgstr ""
#~ "Кластер Tarantool Enterprise распределяет функции экземпляров на основе "
#~ "ролей. **Кластерные роли** -- это Lua-модули, которые реализуют некоторые "
#~ "заданные для экземпляра функции и/или логику."

#~ msgid ""
#~ "Since all instances running cluster applications use the same source code "
#~ "and are aware of all the defined roles (and plugged modules), multiple "
#~ "different roles can be dynamically enabled and disabled on any number of "
#~ "instances without restarts even during cluster operation."
#~ msgstr ""
#~ "Поскольку все экземпляры, на которых запущены кластерные приложения, "
#~ "используют один и тот же исходный код и знают обо всех определенных ролях (и"
#~ " подключенных модулях), вы можете динамически включать и отключать несколько"
#~ " разных ролей на любом количестве экземпляров без перезапуска даже во время "
#~ "работы кластера."

#~ msgid "Built-in roles"
#~ msgstr "Встроенные роли"

#~ msgid ""
#~ "The cluster module comes with two built-in roles that implement automatic "
#~ "sharding:"
#~ msgstr ""
#~ "В модуль cluster входят две встроенные роли, которые реализуют "
#~ "автоматический шардинг:"

#~ msgid ""
#~ "``vshard-router`` that handles the ``vshard``'s *compute-intensive* "
#~ "workload: routes requests to storage nodes."
#~ msgstr ""
#~ "``vshard-router`` обрабатывает *ресурсоемкие* вычисления в ``vshard``: "
#~ "направляет запросы к узлам хранения данных."

#~ msgid ""
#~ "``vshard-storage`` that handles the ``vshard``'s *transaction-intensive* "
#~ "workload: stores and manages a subset of a dataset."
#~ msgstr ""
#~ "``vshard-storage`` работает с *большим количеством транзакций* в ``vshard``:"
#~ " хранит подмножество набора данных и управляет им."

#~ msgid ""
#~ "For more information on sharding, see the `vshard module documentation "
#~ "</reference/reference_rock/vshard/>`_."
#~ msgstr ""
#~ "Для получения дополнительной информации о шардинге см. `документацию по "
#~ "модулю vshard "
#~ "</reference/reference_rock/vshard/>`_."

#~ msgid ""
#~ "With the built-in and custom roles, Tarantool Enterprise allows you to "
#~ "develop applications with separated compute and transaction handling. Later,"
#~ " the relevant workload-specific roles can be enabled on different instances "
#~ "running on physical servers with workload-dedicated hardware."
#~ msgstr ""
#~ "Благодаря встроенным и пользовательским ролям, Tarantool Enterprise "
#~ "позволяет разрабатывать приложения, где вычисления отделены от обработки "
#~ "транзакций. Позже соответствующие роли в зависимости от рабочей нагрузки "
#~ "можно включить на разных экземплярах, которые работают на физических "
#~ "серверах с оборудованием, выделенным для рабочей нагрузки."

#~ msgid ""
#~ "Neither ``vshard-router`` nor ``vshard-storage`` manage spaces, indexes, or "
#~ "formats. To start developing an application, edit the ``custom-role.lua`` "
#~ "placeholder file: add a ``box.schema.space.create()`` call to your first "
#~ "cluster role."
#~ msgstr ""
#~ "Ни ``vshard-router``, ни ``vshard-storage`` не управляют спейсами, индексами"
#~ " и форматами. Чтобы начать разработку приложения, отредактируйте файл-"
#~ "заглушку ``custom-role.lua``: добавьте вызов ``box.schema.space.create()`` в"
#~ " свою первую кластерную роль."

#~ msgid "Additionally, you can implement several such roles to:"
#~ msgstr "Кроме того, можно реализовать несколько таких ролей, чтобы:"

#~ msgid "define stored procedures;"
#~ msgstr "определить хранимые процедуры;"

#~ msgid "implement functionality on top of ``vshard``;"
#~ msgstr "реализовать функции поверх ``vshard``;"

#~ msgid "go without ``vshard`` at all;"
#~ msgstr "полностью обойтись без ``vshard``;"

#~ msgid ""
#~ "implement one or multiple supplementary services such as e-mail notifier, "
#~ "replicator, etc."
#~ msgstr ""
#~ "реализовать один или несколько дополнительных сервисов, таких как средство "
#~ "уведомления по электронной почте, репликатор и т.д."

#~ msgid "Implementing and registering custom roles"
#~ msgstr "Реализация и регистрация пользовательских ролей"

#~ msgid "To implement a custom cluster role, do the following:"
#~ msgstr ""
#~ "Чтобы реализовать пользовательскую кластерную роль, выполните следующие "
#~ "действия:"

#~ msgid ""
#~ "Register the new role in the cluster by modifying the ``cluster.cfg()`` call"
#~ " in the ``init.lua`` entry point file:"
#~ msgstr ""
#~ "Зарегистрируйте новую роль в кластере, изменив вызов ``cluster.cfg()`` в "
#~ "файле входа в приложение ``init.lua``:"

#~ msgid "where ``custom-role`` is the name of the Lua module to be loaded."
#~ msgstr ""
#~ "где ``custom-role`` (пользовательская роль) -- это название загружаемого "
#~ "Lua-модуля."

#~ msgid ""
#~ "Implement the role in a file with the appropriate name (``custom-"
#~ "role.lua``). For example:"
#~ msgstr ""
#~ "Поместите роль в файл с соответствующим именем (``custom-role.lua``). "
#~ "Например:"

#~ msgid ""
#~ "Where the ``role_name`` may differ from the module name passed to the "
#~ "``cluster.cfg()`` function. If the ``role_name`` variable is not specified, "
#~ "the module name is the default value."
#~ msgstr ""
#~ "Где имя роли ``role_name`` может отличаться от имени модуля, переданного в "
#~ "функции ``cluster.cfg()``. Если не указать переменную ``role_name``, по "
#~ "умолчанию будет использовано имя модуля."

#~ msgid ""
#~ "Role names must be unique as it is impossible to register multiple roles "
#~ "with the same name."
#~ msgstr ""
#~ "Имена ролей должны быть уникальными, поскольку невозможно зарегистрировать "
#~ "несколько ролей с одним именем."

#~ msgid ""
#~ "The role module does not have required functions but the cluster may execute"
#~ " the following ones during the role's life cycle:"
#~ msgstr ""
#~ "В модуле роли нет обязательных функций, но в течение жизненного цикла роли "
#~ "кластер может выполнять следующие функции:"

#~ msgid "``init()`` is the role's *initialization* function."
#~ msgstr "``init()`` -- это функция *инициализации* роли."

#~ msgid ""
#~ "Inside the function's body you can call any ``box`` functions: create "
#~ "spaces, indexes, grant permissions, etc. Here is what the initialization "
#~ "function may look like:"
#~ msgstr ""
#~ "В теле функции можно вызывать любые функции из ``box``: создавать спейсы, "
#~ "индексы, выдавать права и т.д. Вот как может выглядеть функция "
#~ "инициализации:"

#~ msgid ""
#~ "The function's body is wrapped in a conditional statement that lets you call"
#~ " ``box`` functions on masters only. This protects against replication "
#~ "collisions as data propagates to replicas automatically."
#~ msgstr ""
#~ "Тело функции заключено в условный оператор, который позволяет вызывать "
#~ "функции ``box`` только на мастерах. Это предотвращает конфликты репликации, "
#~ "так как данные автоматически передаются на реплики."

#~ msgid ""
#~ "``stop()`` is the role's *termination* function. Implement it if "
#~ "initialization starts a fiber that has to be stopped or does any job that "
#~ "has to be undone on termination."
#~ msgstr ""
#~ "``stop()`` это функция *завершения работы* роли. Используйте ее, если "
#~ "инициализация запускает файбер, который необходимо остановить, или же "
#~ "выполняет любую задачу, которую следует отменить при завершении работы."

#~ msgid ""
#~ "``validate_config()`` and ``apply_config()`` are *validation* and "
#~ "*application* functions that make custom roles configurable. Implement them "
#~ "if some configuration data has to be stored cluster-wide."
#~ msgstr ""
#~ "``validate_config()`` и ``apply_config()`` -- это функции *валидации* и "
#~ "*применения  конфигурации* соответственно, которые обеспечивают возможность "
#~ "настройки ролей. Используйте их, если некоторые настройки должны храниться "
#~ "на уровне кластера."

#~ msgid ""
#~ "Next, get a grip on the :ref:`role's life cycle <cluster-role-lifecycle>` to"
#~ " implement the necessary functions."
#~ msgstr ""
#~ "Затем изучите :ref:`жизненный цикл роли <cluster-role-lifecycle>`, чтобы "
#~ "реализовать необходимые функции."

#~ msgid "Defining role dependencies"
#~ msgstr "Определение зависимостей ролей"

#~ msgid ""
#~ "You can instruct the cluster to apply some other roles if your custom role "
#~ "is enabled."
#~ msgstr ""
#~ "Можно настроить кластер таким образом, чтобы при включении пользовательской "
#~ "роли применялись также другие роли."

#~ msgid "For example:"
#~ msgstr "Например:"

#~ msgid ""
#~ "Here ``vshard-router`` role will be initialized automatically for every "
#~ "instance with ``custom-role`` enabled."
#~ msgstr ""
#~ "В данном примере роль  ``vshard-router`` будет инициализирована "
#~ "автоматически для каждого экземпляра со включенной ролью ``custom-role``."

#~ msgid "Using multiple vshard storage groups"
#~ msgstr "Использование нескольких групп хранилищ"

#~ msgid ""
#~ "Replica sets with ``vshard-storage`` roles can belong to different *groups*."
#~ " For example, ``hot`` or ``cold`` groups meant to independently process hot "
#~ "and cold data."
#~ msgstr ""
#~ "Наборы реплик с ролью ``vshard-storage`` могут относиться к различным "
#~ "*группам*. Например, группы ``hot`` (горячие) и ``cold`` (холодные) "
#~ "независимо друг от друга обрабатывают наиболее важные \"горячие\" и редко "
#~ "используемые \"холодные\" данные соответственно."

#~ msgid "Groups are specified in the cluster's configuration:"
#~ msgstr "Группы указаны в конфигурации кластера:"

#~ msgid ""
#~ "If no groups are specified, the cluster assumes that all replica sets belong"
#~ " to the ``default`` group."
#~ msgstr ""
#~ "Если группы не указаны, кластер предполагает, что все наборы реплик входят в"
#~ " группу ``default`` (по умолчанию)."

#~ msgid ""
#~ "With multiple groups enabled, every replica set with a ``vshard-storage`` "
#~ "role enabled must be assigned to a particular group. The assignment can "
#~ "never be changed."
#~ msgstr ""
#~ "Если включены несколько группы, каждый набор реплик с включенной ролью "
#~ "``vshard-storage`` должен быть назначен в определенную группу. Эту настройку"
#~ " нельзя изменить впоследствии."

#~ msgid ""
#~ "Another limitation is that you cannot add groups dynamically (will become "
#~ "available in future)."
#~ msgstr ""
#~ "Есть еще одно ограничение -- нельзя добавлять группы динамически (такая "
#~ "возможность появится в будущих версиях)."

#~ msgid ""
#~ "Finally, mind the new syntax for router access. Every instance with a "
#~ "``vshard-router`` role enabled initializes multiple routers. All of them are"
#~ " accessible through the role:"
#~ msgstr ""
#~ "Наконец, обратите внимание на новый синтаксис для доступа к роутеру. Каждый "
#~ "экземпляр со включенной ролью ``vshard-router`` инициализирует несколько "
#~ "роутеров. Доступ к ним можно получить через роль:"

#~ msgid ""
#~ "If you have no roles specified, you can access a static router as before:"
#~ msgstr ""
#~ "Если роли не указаны, доступ к статическому роутеру можно получить, как и "
#~ "прежде:"

#~ msgid ""
#~ "However, when using the new API, you must call a static router with a colon:"
#~ msgstr ""
#~ "Тем не менее, при использовании нового API следует вызывать статический "
#~ "роутер при помощи двоеточия:"

#~ msgid "Role's life cycle and the order of function execution"
#~ msgstr "Жизненный цикл роли и порядок выполнения функций"

#~ msgid ""
#~ "The cluster displays all custom role names along with the built-in "
#~ "``vshard`` ones in the web interface. Cluster administrators can enable and "
#~ "disable them for particular instances either via the web interface or "
#~ "cluster public API. For example:"
#~ msgstr ""
#~ "Кластер отображает все имена пользовательских ролей вместе с именами "
#~ "встроенных ролей из ``vshard`` в веб-интерфейсе. Администраторы кластера "
#~ "могут включать и отключать их для определенных экземпляров либо через веб-"
#~ "интерфейс, либо через общедоступный API кластера. Например:"

#~ msgid ""
#~ "If multiple roles are enabled on an instance at the same time, the cluster "
#~ "first initializes the built-in roles (if any) and then the custom ones (if "
#~ "any) in the order the latter were listed in ``cluster.cfg()``."
#~ msgstr ""
#~ "Если несколько ролей одновременно включены на экземпляре, кластер сначала "
#~ "инициализирует встроенные роли (если они есть), а затем пользовательские "
#~ "(если они есть) в том порядке, в котором последние были перечислены в "
#~ "``cluster.cfg()``."

#~ msgid ""
#~ "If a custom role has dependent roles, the dependencies are registered and "
#~ "validated first, prior to the role itself."
#~ msgstr ""
#~ "Если у пользовательской роли есть зависимые роли, сначала происходит "
#~ "регистрация и валидация зависимостей, а затем уже самой роли."

#~ msgid "The cluster calls the role's functions in the following circumstances:"
#~ msgstr "Кластер вызывает функции роли в следующих случаях:"

#~ msgid ""
#~ "The ``init()`` function, typically, once: either when the role is enabled by"
#~ " the administrator or at the instance restart. Enabling a role once is "
#~ "normally enough."
#~ msgstr ""
#~ "Функция ``init()`` обычно выполняется один раз: либо когда администратор "
#~ "включает роль, либо при перезапуске экземпляра. Как правило, достаточно один"
#~ " раз включить роль."

#~ msgid ""
#~ "The ``stop()`` function -- only when the administrator disables the role, "
#~ "not on instance termination."
#~ msgstr ""
#~ "Функция ``stop()`` -- только когда администратор отключает роль, а не во "
#~ "время завершения работы экземпляра."

#~ msgid ""
#~ "The ``validate_config()`` function, first, before the automatic "
#~ "``box.cfg()`` call (database initialization), then -- upon every "
#~ "configuration update."
#~ msgstr ""
#~ "Функция ``validate_config()``: сначала до автоматического вызова box.cfg() "
#~ "(инициализация базы данных), а затем при каждом обновлении конфигурации."

#~ msgid "The ``apply_config()`` function upon every configuration update."
#~ msgstr "Функция ``apply_config()`` -- при каждом обновлении конфигурации."

#~ msgid ""
#~ "Hence, if the cluster is tasked with performing the following actions, it "
#~ "will execute the functions listed in the following order:"
#~ msgstr ""
#~ "Таким образом, если поставить для кластера задачу выполнить следующие "
#~ "действия, он будет выполнять перечисленные функции в следующем порядке:"

#~ msgid "Join an instance or create a replica set, both with an enabled role:"
#~ msgstr ""
#~ "Присоединение экземпляра или создание набора реплик (в обоих случаях с "
#~ "включенной ролью):"

#~ msgid "``validate_config()``"
#~ msgstr "``validate_config()``"

#~ msgid "``init()``"
#~ msgstr "``init()``"

#~ msgid "``apply_config()``"
#~ msgstr "``apply_config()``"

#~ msgid "Restart an instance with an enabled role:"
#~ msgstr "Перезапуск экземпляра с включенной ролью:"

#~ msgid "Disable role: ``stop()``."
#~ msgstr "Отключение роли: ``stop()``."

#~ msgid "Upon the ``cluster.confapplier.patch_clusterwide()`` call:"
#~ msgstr "При вызове ``cluster.confapplier.patch_clusterwide()``:"

#~ msgid "Upon a triggered failover:"
#~ msgstr "При запущенном восстановлении после отказа:"

#~ msgid "Considering the described behavior:"
#~ msgstr "Учитывая вышеописанное поведение:"

#~ msgid "The ``init()`` function may:"
#~ msgstr "Функция ``init()`` может:"

#~ msgid "Call ``box`` functions."
#~ msgstr "Вызывать функции ``box``."

#~ msgid ""
#~ "Start a fiber and, in this case, the ``stop()`` function should take care of"
#~ " the fiber's termination."
#~ msgstr ""
#~ "Запускать файбер, и в таком случае функция ``stop()`` должна позаботиться о "
#~ "завершении работы файбера."

#~ msgid "Configure the built-in :ref:`HTTP server <httpd_instance>`."
#~ msgstr "Настраивать встроенный :ref:`HTTP-сервер <httpd_instance>`."

#~ msgid "Execute any code related to the role's initialization."
#~ msgstr "Выполнять любой код, связанный с инициализацией роли."

#~ msgid ""
#~ "The ``stop()`` functions must undo any job that has to be undone on role's "
#~ "termination."
#~ msgstr ""
#~ "Функции ``stop()`` должны отменять любую задачу, которую необходимо отменить"
#~ " при завершении работы роли."

#~ msgid ""
#~ "The ``validate_config()`` function must validate any configuration change."
#~ msgstr ""
#~ "Функция ``validate_config()`` должна валидировать любые изменения "
#~ "конфигурации."

#~ msgid ""
#~ "The ``apply_config()`` function may execute any code related to a "
#~ "configuration change, e.g., take care of an ``expirationd`` fiber."
#~ msgstr ""
#~ "Функция ``apply_config()`` может выполнять любой код, связанный с изменением"
#~ " конфигурации, например следить за файбером ``expirationd``."

#~ msgid ""
#~ "The validation and application functions together allow you to customize the"
#~ " cluster-wide configuration as described in the :ref:`next section <cluster-"
#~ "role-config>`."
#~ msgstr ""
#~ "Функции валидации и применения конфигурации вместе позволяют настраивать "
#~ "конфигурацию всего кластера, как описано в :ref:`следующем разделе <cluster-"
#~ "role-config>`."

#~ msgid "Configuring custom roles"
#~ msgstr "Конфигурация пользовательских ролей"

#~ msgid "You can:"
#~ msgstr "Вы можете:"

#~ msgid ""
#~ "Store your custom roles as sections in cluster-wide configuration, for "
#~ "example:"
#~ msgstr ""
#~ "Хранить пользовательские роли в виде разделов в конфигурации на уровне "
#~ "кластера, например:"

#~ msgid ""
#~ "Download and upload cluster-wide configuration using :ref:`cluster UI "
#~ "<cluster-configuration>` or API (via GET/PUT queries to ``admin/config`` "
#~ "endpoint like ``curl localhost:8081/admin/config`` and ``curl -X PUT -d "
#~ "\"{'my_parameter': 'value'}\" localhost:8081/admin/config``)."
#~ msgstr ""
#~ "Загружать и выгружать конфигурацию всего кластера через :ref:`веб-интерфейс "
#~ "кластера <cluster-configuration>` или с помощью API (запросы GET/PUT к "
#~ "конечной точке ``admin/config``: ``curl localhost:8081/admin/config`` и "
#~ "``curl -X PUT -d \"{'my_parameter': 'value'}\" "
#~ "localhost:8081/admin/config``)."

#~ msgid "Utilize it in your role ``apply_config()`` function."
#~ msgstr "Использовать ее в своей функции ``apply_config()``."

#~ msgid ""
#~ "Every instance in the cluster stores a copy of the configuration file in its"
#~ " working directory (configured by ``cluster.cfg({workdir = ...})``):"
#~ msgstr ""
#~ "Каждый экземпляр в кластере хранит копию конфигурационного файла в своей "
#~ "рабочей директории (которую можно задать с помощью ``cluster.cfg({workdir = "
#~ "...})``):"

#~ msgid ""
#~ "``/var/lib/tarantool/<instance_name>/config.yml`` for instances deployed "
#~ "from RPM packages and managed by ``systemd``."
#~ msgstr ""
#~ "``/var/lib/tarantool/<instance_name>/config.yml`` для экземпляров, "
#~ "развернутых из RPM-пакетов, под управлением ``systemd``."

#~ msgid ""
#~ "``/home/<username>/tarantool_state/var/lib/tarantool/config.yml`` for "
#~ "instances deployed from archives."
#~ msgstr ""
#~ "``/home/<username>/tarantool_state/var/lib/tarantool/config.yml`` для "
#~ "экземпляров, развернутых из архивов."

#~ msgid ""
#~ "The cluster's configuration is a Lua table, downloaded and uploaded as YAML."
#~ " If some application-specific configuration data, e.g., a database schema as"
#~ " defined by DDL (data definition language), has to be stored on every "
#~ "instance in the cluster, you can implement your own API by adding a custom "
#~ "section to the table. The cluster will help you spread it safely across all "
#~ "instances."
#~ msgstr ""
#~ "Конфигурация кластера представляет собой Lua-таблицу, загружаемую и "
#~ "выгружаемую в формате YAML. Если некоторые данные конфигурации для "
#~ "конкретного приложения (например, схему базы данных, описанную с помощью "
#~ "языка определения данных DDL) необходимо хранить в каждом экземпляре "
#~ "кластера, можно использовать свой собственный API, добавив в таблицу "
#~ "специальный раздел. Кластер поможет вам безопасно передать его всем "
#~ "экземплярам."

#~ msgid ""
#~ "Such section goes in parallel (in the same file) with the topology-specific "
#~ "and ``vshard``-specific ones the cluster automatically generates. Unlike the"
#~ " generated, the custom section's modification, validation, and application "
#~ "logic has to be defined."
#~ msgstr ""
#~ "Такой раздел создается параллельно (в одном файле) с разделами о топологии и"
#~ " о ``vshard``, которые кластер генерирует автоматически. В отличие от "
#~ "сгенерированных разделов, логику изменения, проверки и применения "
#~ "конфигурации в специальном разделе необходимо определять вручную."

#~ msgid "The common way is to define two functions:"
#~ msgstr ""
#~ "Самый распространенный способ определения двух функций заключается в "
#~ "следующем:"

#~ msgid ""
#~ "``validate_config(conf_new, conf_old)`` to validate changes made in the new "
#~ "configuration (``conf_new``) versus the old configuration (``conf_old``)."
#~ msgstr ""
#~ "``validate_config(conf_new, conf_old)`` для валидации изменений, сделанных в"
#~ " новой конфигурации (``conf_new``) по отношению к старой конфигурации "
#~ "(``conf_old``)."

#~ msgid ""
#~ "``apply_config(conf, opts)`` to execute any code related to a configuration "
#~ "change. As input, this function takes the configuration to apply (``conf``, "
#~ "which is actually the new configuration that you validated earlier with "
#~ "``validate_config()``) and options (the ``opts`` argument that includes "
#~ "``is_master``, a Boolean flag described later)."
#~ msgstr ""
#~ "``apply_config(conf, opts)`` для выполнения любого кода, связанного с "
#~ "изменениями конфигурации. Входными данными для этой функции будут "
#~ "применяемая конфигурация (``conf``, которая и есть новая конфигурация, "
#~ "проверенная чуть ранее с помощью ``validate_config()``), а также параметры "
#~ "(аргумент ``opts`` включает в себя описываемый ниже логический флаг "
#~ "``is_master`` )."

#~ msgid ""
#~ "The ``validate_config()`` function must detect all configuration problems "
#~ "that may lead to ``apply_config()`` errors. For more information, see the "
#~ ":ref:`next section <cluster-role-config-apply>`."
#~ msgstr ""
#~ "Функция ``validate_config()`` должна обнаружить все проблемы конфигурации, "
#~ "которые могут привести к ошибкам ``apply_config()``. Для получения "
#~ "дополнительной информации см. :ref:`следующий раздел <cluster-role-config-"
#~ "apply>`."

#~ msgid ""
#~ "When implementing validation and application functions that call ``box`` "
#~ "ones for some reason, the following precautions apply:"
#~ msgstr ""
#~ "При реализации функций валидации и применения конфигурации, которые по "
#~ "какой-либо причине вызывают функции ``box``, следует принять следующие меры "
#~ "предосторожности:"

#~ msgid ""
#~ "Due to the :ref:`role's life cycle <cluster-role-lifecycle>`, the cluster "
#~ "does not guarantee an automatic ``box.cfg()`` call prior to calling "
#~ "``validate_config()``."
#~ msgstr ""
#~ ":ref:`Жизненный цикл роли <cluster-role-lifecycle>` не предполагает, что "
#~ "кластер автоматически вызовет ``box.cfg()`` до вызова ``validate_config()``."

#~ msgid ""
#~ "If the validation function is to call any ``box`` functions (e.g., to check "
#~ "a format), make sure the calls are wrapped in a protective conditional "
#~ "statement that checks if ``box.cfg()`` has already happened:"
#~ msgstr ""
#~ "Если функция валидации должна вызвать какие-либо функции из ``box`` "
#~ "(например, для проверки формата), убедитесь, что вызовы заключены в защитный"
#~ " условный оператор, который проверяет, произошел ли уже вызов ``box.cfg()``:"

#~ msgid ""
#~ "Unlike the validation and similar to initialization function, "
#~ "``apply_config()`` can call ``box`` functions freely as the cluster applies "
#~ "custom configuration after the automatic ``box.cfg()`` call."
#~ msgstr ""
#~ "В отличие от функции валидации, как и в случае с функцией инициализации, "
#~ "``apply_config()`` может свободно вызывать функции из ``box``, поскольку "
#~ "кластер применяет пользовательскую конфигурацию после автоматического вызова"
#~ " ``box.cfg()``."

#~ msgid ""
#~ "However, creating spaces, users, etc., can cause replication collisions when"
#~ " performed on both master and replica instances simultaneously. The "
#~ "appropriate way is to call such ``box`` functions on masters only and let "
#~ "the changes propagate to replicas automatically."
#~ msgstr ""
#~ "Однако создание спейсов, пользователей и т.п. может привести к конфликтам "
#~ "репликации при одновременном выполнении на мастере и на реплике. Оптимальный"
#~ " способ заключается в том, чтобы вызывать такие функции из ``box`` только на"
#~ " мастерах и автоматически передавать изменения на реплики."

#~ msgid ""
#~ "Upon the ``apply_config(conf, opts)`` execution, the cluster passes an "
#~ "``is_master`` flag in the ``opts`` table which you can use to wrap "
#~ "collision-inducing ``box`` functions in a protective conditional statement:"
#~ msgstr ""
#~ "По выполнении ``apply_config(conf, opts)`` кластер передает флаг "
#~ "``is_master`` в таблице ``opts``, который можно использовать для заключения "
#~ "функций из ``box`` в защитный условный оператор, если они могут вызвать "
#~ "конфликт:"

#~ msgid "Custom configuration example"
#~ msgstr "Пример пользовательской конфигурации"

#~ msgid ""
#~ "Consider the following code as part of the role's module (``custom-"
#~ "role.lua``) implementation:"
#~ msgstr ""
#~ "Рассмотрим следующий код как часть реализации модуля роли (``custom-"
#~ "role.lua``):"

#~ msgid "Once the configuration is customized, do one of the following:"
#~ msgstr "После настройки конфигурации выполните одно из следующих действий:"

#~ msgid ""
#~ "continue developing your application and pay attention to its "
#~ ":ref:`versioning <enterprise-app-versioning>`;"
#~ msgstr ""
#~ "продолжите разработку приложения, обращая особое внимание на "
#~ ":ref:`управление версиями <enterprise-app-versioning>`;"

#~ msgid ""
#~ "(optional) :ref:`enable authorization <auth-enable>` in the web interface."
#~ msgstr ""
#~ "(необязательно) :ref:`включите авторизацию <auth-enable>` в веб-интерфейсе."

#~ msgid ""
#~ "in case the cluster is already deployed, :ref:`apply the configuration "
#~ "<cluster-role-config-apply>` cluster-wide."
#~ msgstr ""
#~ "если кластер уже развернут, :ref:`примените конфигурацию <cluster-role-"
#~ "config-apply>` для всего кластера."

#~ msgid "Applying custom role's configuration"
#~ msgstr "Применение конфигурации пользовательской роли"

#~ msgid ""
#~ "With the implementation showed by the :ref:`example <cluster-role-config-"
#~ "example>`, you can call the ``set_secret()`` function to apply the new "
#~ "configuration via the administrative console or an HTTP endpoint if the role"
#~ " exports one."
#~ msgstr ""
#~ "В :ref:`примере <cluster-role-config-example>` реализации можно вызвать "
#~ "функцию ``set_secret()``, чтобы применить новую конфигурацию с помощью "
#~ "административной консоли или конечной точки HTTP, если роль экспортирует "
#~ "таковую."

#~ msgid ""
#~ "The ``set_secret()`` function calls "
#~ "``cluster.confapplier.patch_clusterwide()`` which performs a two-phase "
#~ "commit:"
#~ msgstr ""
#~ "Функция ``set_secret()`` вызывает "
#~ "``cluster.confapplier.patch_clusterwide()``, которая производит двухфазную "
#~ "фиксацию транзакций:"

#~ msgid ""
#~ "It patches the active configuration in memory: copies the table and replaces"
#~ " the ``\"custom-role\"`` section in the copy with the one given by the "
#~ "``set_secret()`` function."
#~ msgstr ""
#~ "Исправляет активную конфигурацию в памяти: копирует таблицу и заменяет "
#~ "раздел ``\"custom-role\"`` в копии на раздел, который задан функцией "
#~ "``set_secret()``."

#~ msgid ""
#~ "The cluster checks if the new configuration can be applied on all instances "
#~ "except disabled and expelled. All instances subject to update must be "
#~ "healthy and ``alive`` according to the :ref:`membership module <enterprise-"
#~ "membership-rock>`."
#~ msgstr ""
#~ "Кластер проверяет, можно ли применить новую конфигурацию ко всем "
#~ "экземплярам, кроме отключенных и исключенных. Все обновляемые экземпляры "
#~ "должны быть исправными и рабочими в соответствии с требованиями :ref:`модуля"
#~ " membership <enterprise-membership-rock>`."

#~ msgid ""
#~ "(**Preparation phase**) The cluster propagates the patched configuration. "
#~ "Every instance validates it with the ``validate_config()`` function of every"
#~ " registered role. Depending on the validation's result:"
#~ msgstr ""
#~ "(**Фаза подготовки**) Кластер передает исправленную конфигурацию. Каждый "
#~ "экземпляр валидирует ее с помощью функции ``validate_config()`` каждой "
#~ "зарегистрированной роли. В зависимости от результата валидации:"

#~ msgid ""
#~ "If successful (i.e., returns ``true``), the instance saves the new "
#~ "configuration to a temporary file named ``config.prepare.yml`` within the "
#~ "working directory."
#~ msgstr ""
#~ "В случае успеха (то есть возврата значения ``true``) экземпляр сохраняет "
#~ "новую конфигурацию во временный файл с именем ``config.prepare.yml`` в "
#~ "рабочей директории."

#~ msgid ""
#~ "(**Abort phase**) Otherwise, the instance reports an error and all other "
#~ "instances roll back the update: remove the file they may have already "
#~ "prepared."
#~ msgstr ""
#~ "(**Фаза отмены**) В противном случае экземпляр сообщает об ошибке, а все "
#~ "остальные экземпляры откатывают обновление: удаляют файл, который они, "
#~ "возможно, уже подготовили."

#~ msgid ""
#~ "(**Commit phase**) Upon successful preparation of all instances, the cluster"
#~ " commits the changes. Every instance:"
#~ msgstr ""
#~ "(**Фаза фиксации**) После успешной подготовки всех экземпляров кластер "
#~ "фиксирует изменения. Каждый экземпляр:"

#~ msgid "Creates the active configuration's hard-link."
#~ msgstr "Создает жесткую ссылку активной конфигурации."

#~ msgid ""
#~ "Atomically replaces the active one with the prepared. The atomic replacement"
#~ " is indivisible -- it can either succeed or fail entirely, never partially."
#~ msgstr ""
#~ "Атомарно заменяет активную на подготовленную. Атомарная замена неделима, то "
#~ "есть она может быть либо выполнена, либо не выполнена полностью, но не "
#~ "частично."

#~ msgid "Calls the ``apply_config()`` function of every registered role."
#~ msgstr "Вызывает функцию ``apply_config()`` каждой зарегистрированной роли."

#~ msgid ""
#~ "If any of these steps fail, an error pops up in the web interface next to "
#~ "the corresponding instance. The cluster does not handle such errors "
#~ "automatically, they require manual repair."
#~ msgstr ""
#~ "Если любой из этих шагов не будет выполнен, в веб-интерфейсе появится ошибка"
#~ " рядом с соответствующим экземпляром. Кластер не обрабатывает такие ошибки "
#~ "автоматически, их необходимо исправлять вручную."

#~ msgid ""
#~ "You will avoid the repair if the ``validate_config()`` function can detect "
#~ "all configuration problems that may lead to ``apply_config()`` errors."
#~ msgstr ""
#~ "Такого рода исправлений можно избежать, если функция ``validate_config()`` "
#~ "сможет обнаружить все проблемы конфигурации, которые могут привести к "
#~ "ошибкам в ``apply_config()``."

#~ msgid "Using the built-in HTTP server"
#~ msgstr "Использование встроенного HTTP-сервера"

#~ msgid ""
#~ "The cluster launches an ``httpd`` server instance during initialization "
#~ "(``cluster.cfg()``). You can bind a port to the instance via an "
#~ "environmental variable:"
#~ msgstr ""
#~ "Кластер запускает экземпляр ``httpd``-сервера во время инициализации "
#~ "(``cluster.cfg()``). Можно привязать порт к экземпляру через переменную "
#~ "окружения:"

#~ msgid ""
#~ "To make use of the ``httpd`` instance, access it and configure routes inside"
#~ " the ``init()`` function of some role, e.g. a role that exposes API over "
#~ "HTTP:"
#~ msgstr ""
#~ "Чтобы использовать ``httpd``-экземпляр, получите к нему доступ и настройте "
#~ "маршруты в рамках функции ``init()`` для какой-либо роли (например, для  "
#~ "роли, которая предоставляет API через HTTP):"

#~ msgid ""
#~ "For more information on the usage of Tarantool's HTTP server, see `its "
#~ "documentation <https://github.com/tarantool/http>`_."
#~ msgstr ""
#~ "Для получения дополнительной информации об использовании HTTP-сервера "
#~ "Tarantool обратитесь к `соответствующей документации "
#~ "<https://github.com/tarantool/http>`_."

#~ msgid ""
#~ "To implement authorization in the web interface of every instance in "
#~ "Tarantool cluster:"
#~ msgstr ""
#~ "Чтобы реализовать авторизацию в веб-интерфейсе каждого экземпляра в кластере"
#~ " Tarantool:"

#~ msgid ""
#~ "Implement a new, say, ``auth`` module with a ``check_password`` function. It"
#~ " should check the credentials of any user trying to log in to the web "
#~ "interface."
#~ msgstr ""
#~ "Используйте модуль, к примеру, ``auth`` с функцией ``check_password``. "
#~ "Данная функция проверяет учетные данные любого пользователя, который "
#~ "пытается войти в веб-интерфейс."

#~ msgid ""
#~ "The ``check_password`` function accepts a username and password and returns "
#~ "an authentication success or failure."
#~ msgstr ""
#~ "Функция ``check_password`` принимает имя пользователя и пароль и возвращает "
#~ "результат аутентификации: пройдена или нет."

#~ msgid ""
#~ "Pass the implemented ``auth`` module name as a parameter to "
#~ "``cluster.cfg()``, so the cluster can use it:"
#~ msgstr ""
#~ "Передайте имя используемого модуля ``auth`` в качестве параметра для "
#~ "``cluster.cfg()``, чтобы кластер мог использовать его:"

#~ msgid ""
#~ "This adds a **Log in** button to the upper right corner of the web interface"
#~ " but still lets the unsigned users interact with the interface. This is "
#~ "convenient for testing."
#~ msgstr ""
#~ "Это добавит кнопку **Log in** (Войти) в верхний правый угол в веб-"
#~ "интерфейсе, но все же позволит неавторизованным пользователям "
#~ "взаимодействовать с интерфейсом, что удобно для тестирования."

#~ msgid ""
#~ "Also, to authorize requests to cluster API, you can use the HTTP basic "
#~ "authorization header."
#~ msgstr ""
#~ "Кроме того, для авторизации запросов к API кластера можно использовать "
#~ "базовый заголовок HTTP для авторизации."

#~ msgid ""
#~ "To require the authorization of every user in the web interface even before "
#~ "the cluster bootstrap, add the following line:"
#~ msgstr ""
#~ "Чтобы требовать авторизацию каждого пользователя в веб-интерфейсе даже до "
#~ "начальной загрузки кластера, добавьте следующую строку:"

#~ msgid ""
#~ "With the authentication enabled and the ``auth`` module implemented, the "
#~ "user will not be able to even bootstrap the cluster without logging in. "
#~ "After the successful login and bootstrap, the authentication can be enabled "
#~ "and disabled cluster-wide in the web interface and the ``auth_enabled`` "
#~ "parameter is ignored."
#~ msgstr ""
#~ "С включенной аутентификацией при использовании модуля ``auth`` пользователь "
#~ "не сможет даже загрузить кластер без входа в систему. После успешного входа "
#~ "в систему и начальной загрузки можно включить и отключить аутентификацию для"
#~ " всего кластера в веб-интерфейсе, а параметр ``auth_enabled`` игнорируется."

#~ msgid "Application versioning"
#~ msgstr "Управление версиями приложения"

#~ msgid ""
#~ "Tarantool Enterprise understands semantic versioning as described at "
#~ "`semver.org <https://semver.org>`_. When developing an application, create "
#~ "new Git branches and tag them appropriately. These tags are used to "
#~ "calculate version increments for subsequent packaging."
#~ msgstr ""
#~ "В Tarantool Enterprise семантическое управление версиями осуществляется так,"
#~ " как описано на сайте `semver.org <https://semver.org>`_. При разработке "
#~ "приложения создайте новые ветки Git и пометьте их соответствующими тегами. "
#~ "Эти теги используются для расчета увеличения значения версий для последующей"
#~ " упаковки."

#~ msgid ""
#~ "For example, if your application has version 1.2.1, tag your current branch "
#~ "with ``1.2.1`` (annotated or not)."
#~ msgstr ""
#~ "Например, если версия вашего приложения -- 1.2.1, пометьте текущую ветку "
#~ "тегом ``1.2.1`` (с аннотациями или без них)."

#~ msgid "To retrieve the current version from Git, say:"
#~ msgstr "Чтобы получить значение текущей версии из Git, выполните команду:"

#~ msgid ""
#~ "This output shows that we are 12 commits after the version 1.2.1. If we are "
#~ "to package the application at this point, it will have a full version of "
#~ "``1.2.1-12`` and its package will be named ``<app_name>-1.2.1-12.rpm``."
#~ msgstr ""
#~ "Вывод показывает, что после версии 1.2.1 было 12 коммитов. Если мы соберемся"
#~ " упаковать приложение на данном этапе, его полная версия будет ``1.2.1-12``,"
#~ " а пакет будет называться ``<имя_приложения>-1.2.1-12.rpm``."

#~ msgid ""
#~ "Non-semantic tags are prohibited. You will not be able to create a package "
#~ "from a branch with the latest tag being non-semantic."
#~ msgstr ""
#~ "Запрещается использовать не семантические теги. Вы не сможете создать пакет "
#~ "из ветки, если последний тег не будет семантическим."

#~ msgid ""
#~ "Once you :ref:`package <enterprise-app-package>` your application, the "
#~ "version is saved in a ``VERSION`` file in the package root."
#~ msgstr ""
#~ "После :ref:`упаковки <enterprise-app-package>` приложения его версия "
#~ "сохраняется в файл ``VERSION`` в корневой каталог пакета."

#~ msgid "Using .tarantoolapp.ignore files"
#~ msgstr "Использование файлов .tarantoolapp.ignore"

#~ msgid ""
#~ "You can add a ``.tarantoolapp.ignore`` file to your application repository "
#~ "to exclude particular files and/or directories from package builds."
#~ msgstr ""
#~ "В репозиторий приложения можно добавить файл ``.tarantoolapp.ignore``, чтобы"
#~ " не включать определенные файлы и/или директории в сборки пакета."

#~ msgid ""
#~ "For the most part, the logic is similar to that of ``.gitignore`` files. The"
#~ " major difference is that in ``.tarantoolapp.ignore`` files the order of "
#~ "exceptions relative to the rest of the templates does not matter, while in "
#~ "``.gitignore`` files the order does matter."
#~ msgstr ""
#~ "По большей части логика похожа на логику файлов ``.gitignore``. Основное "
#~ "отличие состоит в том, что в файлах ``.tarantoolapp.ignore`` порядок "
#~ "исключения относительно остальных шаблонов не имеет значения, а в файлах "
#~ "``.gitignore`` -- имеет."

#~ msgid "**.tarantoolapp.ignore** entry"
#~ msgstr "запись в **.tarantoolapp.ignore**"

#~ msgid "ignores every..."
#~ msgstr "игнорирует все..."

#~ msgid "``target/``"
#~ msgstr "``target/``"

#~ msgid "**folder** (due to the trailing ``/``) named ``target``, recursively"
#~ msgstr ""
#~ "**папки** (поскольку в конце стоит ``/``) под названием ``target`` "
#~ "рекурсивно"

#~ msgid "``target``"
#~ msgstr "``target``"

#~ msgid "**file or folder** named ``target``, recursively"
#~ msgstr "**файлы или папки** под названием ``target`` рекурсивно"

#~ msgid "``/target``"
#~ msgstr "``/target``"

#~ msgid ""
#~ "**file or folder** named ``target`` in the top-most directory (due to the "
#~ "leading ``/``)"
#~ msgstr ""
#~ "**файлы или папки** под названием ``target`` в самой верхней директории "
#~ "(поскольку в начале стоит ``/``)"

#~ msgid "``/target/``"
#~ msgstr "``/target/``"

#~ msgid ""
#~ "**folder** named ``target`` in the top-most directory (leading and trailing "
#~ "``/``)"
#~ msgstr ""
#~ "**папки** под названием ``target`` в самой верхней директории (в начале и в "
#~ "конце стоит ``/``)"

#~ msgid "``*.class``"
#~ msgstr "``*.class``"

#~ msgid "every **file or folder** ending with ``.class``, recursively"
#~ msgstr "**файлы или папки**, оканчивающиеся на ``.class``, рекурсивно"

#~ msgid "``#comment``"
#~ msgstr "``#comment``"

#~ msgid "nothing, this is a comment (the first character is a ``#``)"
#~ msgstr "ничего, это комментарий (первый символ -- ``#``)"

#~ msgid "``\\#comment``"
#~ msgstr "``\\#comment``"

#~ msgid "every **file or folder** with name ``#comment`` (``\\`` for escaping)"
#~ msgstr "**файлы или папки** под названием ``#comment`` (``\\`` для выделения)"

#~ msgid "``target/logs/``"
#~ msgstr "``target/logs/``"

#~ msgid ""
#~ "every **folder** named ``logs`` which is a subdirectory of a folder named "
#~ "``target``"
#~ msgstr ""
#~ "**папки** под названием ``logs``, которые представляют собой поддиректорию "
#~ "папки под названием ``target``"

#~ msgid "``target/*/logs/``"
#~ msgstr "``target/*/logs/``"

#~ msgid ""
#~ "every **folder** named ``logs`` two levels under a folder named ``target`` "
#~ "(``*`` doesn’t include ``/``)"
#~ msgstr ""
#~ "**папки** под названием ``logs`` на два уровня ниже папки под названием "
#~ "``target`` (``*`` не включает ``/``)"

#~ msgid "``target/**/logs/``"
#~ msgstr "``target/**/logs/``"

#~ msgid ""
#~ "every **folder** named ``logs`` somewhere under a folder named ``target`` "
#~ "(``**`` includes ``/``)"
#~ msgstr ""
#~ "**папки** под названием ``logs`` где угодно в пределах папки ``target`` "
#~ "(``**`` включает ``/``)"

#~ msgid "``*.py[co]``"
#~ msgstr "``*.py[co]``"

#~ msgid ""
#~ "every **file or folder** ending in ``.pyc`` or ``.pyo``; however, it doesn’t"
#~ " match ``.py!``"
#~ msgstr ""
#~ "**файлы или папки**, оканчивающиеся на ``.pyc`` или ``.pyo``, но не на "
#~ "``.py!``"

#~ msgid "``*.py[!co]``"
#~ msgstr "``*.py[!co]``"

#~ msgid "every **file or folder** ending in anything other than ``c`` or ``o``"
#~ msgstr ""
#~ "**файлы или папки**, оканчивающиеся на что угодно, кроме ``c`` или ``o``"

#~ msgid "``*.file[0-9]``"
#~ msgstr "``*.file[0-9]``"

#~ msgid "every **file or folder** ending in digit"
#~ msgstr "**файлы или папки**, оканчивающиеся на цифру"

#~ msgid "``*.file[!0-9]``"
#~ msgstr "``*.file[!0-9]``"

#~ msgid "every **file or folder** ending in anything other than digit"
#~ msgstr "**файлы или папки**, оканчивающиеся на что угодно, кроме цифры"

#~ msgid "``*``"
#~ msgstr "``*``"

#~ msgid "**every**"
#~ msgstr "**всё**"

#~ msgid "``/*``"
#~ msgstr "``/*``"

#~ msgid "**everything** in the top-most directory (due to the leading ``/``)"
#~ msgstr "**всё** в самой верхней директории (поскольку в начале стоит ``/``)"

#~ msgid "``**/*.tar.gz``"
#~ msgstr "``**/*.tar.gz``"

#~ msgid ""
#~ "every ``*.tar.gz`` file or folder which is **one or more** levels under the "
#~ "starting folder"
#~ msgstr ""
#~ "every ``*.tar.gz`` file or folder which is **one or more** levels under the "
#~ "starting folder"

#~ msgid "``!file``"
#~ msgstr "``!file``"

#~ msgid ""
#~ "every **file or folder** will be ignored even if it matches other patterns"
#~ msgstr ""
#~ "every **file or folder** will be ignored even if it matches other patterns"

#~ msgid ""
#~ "Take the ``tarantoolctl`` binary from the SDK and upload it anywhere on the "
#~ "server. If you do not have root privileges, a good place is ``$HOME/bin``. "
#~ "Add this path to your ``~/.bash_profile``:"
#~ msgstr ""
#~ "Возьмите бинарный файл ``tarantoolctl`` из SDK и загрузите его в любое место"
#~ " на сервере. Если у вас нет прав уровня root, оптимально будет поместить его"
#~ " в ``$HOME/bin``. Добавьте этот путь в ``~/.bash_profile``:"

#~ msgid ""
#~ "Configure ``tarantoolctl`` to look for Tarantool instances in a certain "
#~ "place. For example, add the following lines to "
#~ "``~/.config/tarantool/tarantool``:"
#~ msgstr ""
#~ "Настройте ``tarantoolctl`` для поиска экземпляров Tarantool в определенном "
#~ "месте. Например, добавьте следующие строки в "
#~ "``~/.config/tarantool/tarantool``:"

#~ msgid ""
#~ "where ``<user>`` is the username of an account without root privileges, the "
#~ "``instance_dir`` is the directory to unpack applications to, and the rest "
#~ "are state directories."
#~ msgstr ""
#~ "где ``<user>`` (пользователь) -- это имя пользователя учетной записи без "
#~ "прав уровня root, ``instance_dir`` -- это директория для распаковки "
#~ "приложений, а прочее -- это директории состояния."

#~ msgid ""
#~ "where ``<number>`` is the incremental number (unique for every instance) to "
#~ "be added to the ``3300`` port the instance will listen to (e.g., ``3301``, "
#~ "``3302``, etc.)."
#~ msgstr ""
#~ "где ``<number>`` (число) -- это инкрементное число (уникальное для каждого "
#~ "экземпляра), которое следует добавить к порту ``3300`` для настройки "
#~ "прослушивания (например, ``3301``, ``3302`` и т.д.)."

#~ msgid ""
#~ "This starts several instances from the same directory "
#~ "``/home/<user>/apps/<app_name>`` but their state files differ depending on "
#~ "the suffix after ``@``. For example, the log file of the first instance will"
#~ " have the following path:"
#~ msgstr ""
#~ "Это запускает несколько экземпляров из одной директории "
#~ "``/home/<пользователь>/apps/<имя_приложения>``, но файлы состояния будут "
#~ "отличаться в зависимости от суффикса после @. Например, путь к файлу журнала"
#~ " первого экземпляра будет следующим:"

#~ msgid ""
#~ "To stop all instances on a server, run the following command for every "
#~ "instance:"
#~ msgstr ""
#~ "Чтобы остановить все экземпляры сервера, выполните следующую команду для "
#~ "каждого экземпляра:"

#~ msgid ""
#~ "The example in the ``cluster/`` directory showcases a simple cluster-aware "
#~ "application. It consists of the following files:"
#~ msgstr ""
#~ "Пример в директории ``cluster/`` представляет собой простое приложение с "
#~ "поддержкой кластеров. Он состоит из следующих файлов:"

#~ msgid ""
#~ "``init.lua`` -- module containing the ``cluster.cfg()`` initialization "
#~ "function."
#~ msgstr ""
#~ "``init.lua`` -- модуль, который содержит функцию инициализации "
#~ "``cluster.cfg()``."

#~ msgid ""
#~ "``app.lua`` -- role module to contain your stored procedures and API calls."
#~ msgstr ""
#~ "``app.lua`` -- модуль роли, который содержит хранимые процедуры и вызовы "
#~ "API."

#~ msgid "``storage.lua`` -- role module defining functions for the database."
#~ msgstr ""
#~ "``storage.lua`` -- модуль роли, который определяет функции для базы данных."

#~ msgid ""
#~ "``deps.sh`` -- script to resolve rocks dependencies from an offline "
#~ "repository included in the archive."
#~ msgstr ""
#~ "``deps.sh`` -- скрипт для решения проблем с зависимостями сторонних "
#~ "библиотек из автономного репозитория, который включен в данный архив."

#~ msgid "``start.sh`` -- script to start several Tarantool instances."
#~ msgstr "``start.sh`` -- скрипт для запуска нескольких экземпляров Tarantool."

#~ msgid "``assemble.sh`` -- script to assemble the cluster."
#~ msgstr "``assemble.sh`` -- скрипт для сборки кластера."

#~ msgid ""
#~ "``test.py`` -- health check test showing how to put and get data from the "
#~ "running application."
#~ msgstr ""
#~ "``test.py`` -- проверка работоспособности, которая показывает, как поместить"
#~ " и получить данные из запущенного приложения."

#~ msgid "``clean.sh`` -- script to clean the data."
#~ msgstr "``clean.sh`` -- скрипт для очистки данных."

#~ msgid "To start the sample application, do the following:"
#~ msgstr "Чтобы запустить пример приложения, выполните следующие действия:"

#~ msgid "Start several instances:"
#~ msgstr "Запустите несколько экземпляров:"

#~ msgid ""
#~ "Assemble the cluster by assigning roles to instances in the web interface or"
#~ " simply run:"
#~ msgstr ""
#~ "Соберите кластер путем назначения ролей для экземпляров в веб-интерфейсе или"
#~ " просто выполните команду:"

#~ msgid "To check if all the instances are up and running, say:"
#~ msgstr ""
#~ "Чтобы удостовериться, что все экземпляры запущены и работают, выполните "
#~ "команду:"

#~ msgid ""
#~ "To run a basic sanity check on the application, use the provided test "
#~ "script:"
#~ msgstr ""
#~ "Чтобы запустить базовую проверку работоспособности приложения, используйте "
#~ "предоставленный тестовый скрипт:"

#~ msgid "To clean the data after, say:"
#~ msgstr "Чтобы после этого выполнить очистку данных, выполните команду:"

#~ msgid "To stop the application, say:"
#~ msgstr "Чтобы остановить приложение, выполните команду:"
