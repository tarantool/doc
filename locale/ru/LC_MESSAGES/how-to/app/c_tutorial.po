
msgid "C tutorial"
msgstr "Практическое задание на C"

msgid "C stored procedures"
msgstr "Хранимые процедуры на языке C"

msgid ""
"Tarantool can call C code with :ref:`modules <app_server-modules>`, or with "
":ref:`ffi <cookbook-ffi_printf>`, or with C stored procedures. This tutorial"
" only is about the third option, C stored procedures. In fact the routines "
"are always \"C functions\" but the phrase \"stored procedure\" is commonly "
"used for historical reasons."
msgstr ""
"Tarantool может вызывать код на языке C с помощью :ref:`модулей <app_server-"
"modules>`, :ref:`ffi <cookbook-ffi_printf>` или хранимых процедур на C. В "
"данном практическом задании рассматривается только третий метод, хранимые "
"процедуры на языке C. На самом деле, программы всегда представляют собой "
"функции на языке C, но исторически сложилось так, что широко используется "
"фраза \"хранимая процедура\"."

msgid ""
"In this tutorial, which can be followed by anyone with a Tarantool "
"development package and a C compiler, there are five tasks:"
msgstr ""
"Данное практическое задание могут выполнить те, у кого есть пакет программ "
"для разработки Tarantool и компилятор языка программирования C. Оно состоит "
"из пяти задач:"

msgid ":ref:`easy.c <f_c_tutorial-easy>` -- prints \"hello world\";"
msgstr ":ref:`easy.c <f_c_tutorial-easy>` -- выводит \"hello world\";"

msgid ""
":ref:`harder.c <f_c_tutorial-harder>` -- decodes a passed parameter value;"
msgstr ""
":ref:`harder.c <f_c_tutorial-harder>` -- декодирует переданное значение "
"параметра;"

msgid ""
":ref:`hardest.c <f_c_tutorial-hardest>` -- uses the C API to do a DBMS "
"insert;"
msgstr ""
":ref:`hardest.c <f_c_tutorial-hardest>` -- использует API для языка C для "
"вставки в базу данных;"

msgid ""
":ref:`read.c <f_c_tutorial-read>` -- uses the C API to do a DBMS select;"
msgstr ""
":ref:`read.c <f_c_tutorial-read>` -- использует API для языка C для выборки "
"из базы данных;"

msgid ""
":ref:`write.c <f_c_tutorial-write>` -- uses the C API to do a DBMS replace."
msgstr ""
":ref:`write.c <f_c_tutorial-write>` -- использует API для языка C для замены"
" в базе данных."

msgid ""
"After following the instructions, and seeing that the results are what is "
"described here, users should feel confident about writing their own stored "
"procedures."
msgstr ""
"По окончании задания, вы увидите описанные здесь результаты и сможете "
"самостоятельно написать хранимые процедуры."

#, fuzzy
msgid "Preparation"
msgstr "**Подготовка**"

msgid "Check that these items exist on the computer:"
msgstr "Проверьте наличие следующих элементов на компьютере:"

msgid "Tarantool 2.1 or later"
msgstr ""

msgid "A gcc compiler, any modern version should work"
msgstr "Компилятор GCC, подойдет любая современная версия"

msgid "``module.h`` and files #included in it"
msgstr "``module.h`` и включенные в него файлы"

msgid "``msgpuck.h``"
msgstr "``msgpuck.h``"

msgid "``libmsgpuck.a`` (only for some recent msgpuck versions)"
msgstr "``libmsgpuck.a`` (только для некоторых последних версий msgpuck)"

msgid ""
"The ``module.h`` file will exist if Tarantool was installed from source. "
"Otherwise Tarantool's \"developer\" package must be installed. For example "
"on Ubuntu say:"
msgstr ""
"Файл ``module.h`` есть в системе, если Tarantool был установлен из исходных "
"файлов. В противном случае, следует установить пакет Tarantool "
"\"developer\". Например, на Ubuntu введите команду:"

msgid "$ sudo apt-get install tarantool-dev"
msgstr "$ sudo apt-get install tarantool-dev"

msgid "or on Fedora say:"
msgstr "или на Fedora введите команду:"

msgid "$ dnf -y install tarantool-devel"
msgstr "$ dnf -y install tarantool-devel"

msgid ""
"The ``msgpuck.h`` file will exist if Tarantool was installed from source. "
"Otherwise the \"msgpuck\" package must be installed from "
"`https://github.com/tarantool/msgpuck "
"<https://github.com/tarantool/msgpuck>`_."
msgstr ""

msgid ""
"Both ``module.h`` and ``msgpuck.h`` must be on the include path for the C "
"compiler to see them. For example, if ``module.h`` address is "
"``/usr/local/include/tarantool/module.h``, and ``msgpuck.h`` address is "
"``/usr/local/include/msgpuck/msgpuck.h``, and they are not currently on the "
"include path, say:"
msgstr ""
"Чтобы компилятор C увидел файлы ``module.h`` и ``msgpuck.h``, путь к ним "
"следует сохранить в переменной. Например, если адрес файла ``module.h`` -- "
"``/usr/local/include/tarantool/module.h``, а адрес файла ``msgpuck.h`` -- "
"``/usr/local/include/msgpuck/msgpuck.h``, введите команду:"

msgid "$ export CPATH=/usr/local/include/tarantool:/usr/local/include/msgpuck"
msgstr ""
"$ export CPATH=/usr/local/include/tarantool:/usr/local/include/msgpuck"

msgid ""
"The ``libmsgpuck.a`` static library is necessary with msgpuck versions "
"produced after February 2017. If and only if you encounter linking problems "
"when using the gcc statements in the examples for this tutorial, you should "
"put ``libmsgpuck.a`` on the path (``libmsgpuck.a`` is produced from both "
"msgpuck and Tarantool source downloads so it should be easy to find). For "
"example, instead of \":code:`gcc -shared -o harder.so -fPIC harder.c`\" for "
"the second example below, you will need to say \":code:`gcc -shared -o "
"harder.so -fPIC harder.c libmsgpuck.a`\"."
msgstr ""
"Статическая библиотека ``libmsgpuck.a`` нужна для версий msgpuck старше "
"февраля 2017 года. Только в том случае, если встречаются проблемы соединения"
" при использовании операторов GCC в примерах данного практического задания, "
"в пути следует указывать ``libmsgpuck.a`` (``libmsgpuck.a`` создан из "
"исходных файлов загрузки msgpuck и Tarantool, поэтому его легко найти). "
"Например, вместо \":code:`gcc -shared -o harder.so -fPIC harder.c`\" во "
"втором примере ниже, необходимо ввести \":code:`gcc -shared -o harder.so "
"-fPIC harder.c libmsgpuck.a`\"."

msgid ""
"Requests will be done using Tarantool as a :ref:`client <admin-"
"using_tarantool_as_a_client>`. Start Tarantool, and enter these requests."
msgstr ""
"Tarantool выполняет запросы в качестве :ref:`клиента <admin-"
"using_tarantool_as_a_client>`. Запустите Tarantool и введите эти запросы."

msgid ""
"box.cfg{listen=3306}\n"
"box.schema.space.create('capi_test')\n"
"box.space.capi_test:create_index('primary')\n"
"net_box = require('net.box')\n"
"capi_connection = net_box:new(3306)"
msgstr ""
"box.cfg{listen=3306}\n"
"box.schema.space.create('capi_test')\n"
"box.space.capi_test:create_index('primary')\n"
"net_box = require('net.box')\n"
"capi_connection = net_box:new(3306)"

msgid ""
"In plainer language: create a space named ``capi_test``, and make a "
"connection to self named ``capi_connection``."
msgstr ""
"Проще говоря: создайте спейс под названием ``capi_test``, и выполните "
"соединение с одноименным ``capi_connection``."

msgid ""
"Leave the client running. It will be necessary to enter more requests later."
msgstr "Не закрывайте клиент. Он понадобится для последующих запросов."

#, fuzzy
msgid "easy.c"
msgstr "**easy.c**"

msgid ""
"Start another shell. Change directory (``cd``) so that it is the same as the"
" directory that the client is running on."
msgstr ""
"Запустите еще один терминал. Измените директорию (``cd``), чтобы она "
"совпадала с директорией, где запущен клиент."

msgid "Create a file. Name it ``easy.c``. Put these six lines in it."
msgstr ""
"Создайте файл. Назовите его ``easy.c``. Запишите в него следующие шесть "
"строк."

msgid ""
"#include \"module.h\"\n"
"int easy(box_function_ctx_t *ctx, const char *args, const char *args_end)\n"
"{\n"
"  printf(\"hello world\\n\");\n"
"  return 0;\n"
"}\n"
"int easy2(box_function_ctx_t *ctx, const char *args, const char *args_end)\n"
"{\n"
"  printf(\"hello world -- easy2\\n\");\n"
"  return 0;\n"
"}"
msgstr ""
"#include \"module.h\"\n"
"int easy(box_function_ctx_t *ctx, const char *args, const char *args_end)\n"
"{\n"
"  printf(\"hello world\\n\");\n"
"  return 0;\n"
"}\n"
"int easy2(box_function_ctx_t *ctx, const char *args, const char *args_end)\n"
"{\n"
"  printf(\"hello world -- easy2\\n\");\n"
"  return 0;\n"
"}"

msgid "Compile the program, producing a library file named ``easy.so``:"
msgstr ""
"Скомпилируйте программу, что создаст файл библиотеки под названием "
"``easy.so``:"

msgid "$ gcc -shared -o easy.so -fPIC easy.c"
msgstr "$ gcc -shared -o easy.so -fPIC easy.c"

msgid "Now go back to the client and execute these requests:"
msgstr "Теперь вернитесь в клиент и выполните следующие запросы:"

msgid ""
"box.schema.func.create('easy', {language = 'C'})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'easy')\n"
"capi_connection:call('easy')"
msgstr ""
"box.schema.func.create('easy', {language = 'C'})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'easy')\n"
"capi_connection:call('easy')"

msgid ""
"If these requests appear unfamiliar, re-read the descriptions of "
":doc:`/reference/reference_lua/box_schema/func_create`, "
":doc:`/reference/reference_lua/box_schema/user_grant` and :ref:`conn:call() "
"<net_box-call>`."
msgstr ""
"Если эти запросы вам незнакомы, перечитайте описание "
":doc:`/reference/reference_lua/box_schema/func_create`, "
":doc:`/reference/reference_lua/box_schema/user_grant` и :ref:`conn:call() "
"<net_box-call>`."

msgid "The function that matters is ``capi_connection:call('easy')``."
msgstr "Важна функция ``capi_connection:call('easy')``."

msgid ""
"Its first job is to find the 'easy' function, which should be easy because "
"by default Tarantool looks on the current directory for a file named "
"``easy.so``."
msgstr ""
"Во-первых, она ищет функцию easy, что должно быть легко, потому что по "
"умолчанию Tarantool ищет в текущей директории файл под названием "
"``easy.so``."

msgid ""
"Its second job is to call the 'easy' function. Since the ``easy()`` function"
" in ``easy.c`` begins with ``printf(\"hello world\\n\")``, the words \"hello"
" world\" will appear on the screen."
msgstr ""
"Во-вторых, она вызывает функцию easy. Поскольку функция ``easy()`` в "
"``easy.c`` начинается с ``printf(\"hello world\\n\")``, слова \"hello "
"world\" появятся на экране."

msgid ""
"Its third job is to check that the call was successful. Since the ``easy()``"
" function in ``easy.c`` ends with :code:`return 0`, there is no error "
"message to display and the request is over."
msgstr ""
"В-третьих, она проверяет, что вызов прошел успешно. Поскольку функция "
"``easy()`` в ``easy.c`` оканчивается на :code:`return 0`, сообщение об "
"ошибке отсутствует, и запрос выполнен."

msgid "The result should look like this:"
msgstr "Результат должен выглядеть следующим образом:"

msgid ""
"tarantool> capi_connection:call('easy')\n"
"hello world\n"
"---\n"
"- []\n"
"..."
msgstr ""
"tarantool> capi_connection:call('easy')\n"
"hello world\n"
"---\n"
"- []\n"
"..."

msgid ""
"Now let's call the other function in easy.c -- ``easy2()``. This is almost "
"the same as the ``easy()`` function, but there's a detail: when the file "
"name is not the same as the function name, then we have to specify "
":samp:`{file-name}.{function-name}`."
msgstr ""
"Теперь вызовем другую функцию в easy.c -- ``easy2()``. Она практически "
"совпадает с функцией ``easy()``, но есть небольшое отличие: если имя файла "
"не совпадет с именем функции, нужно будет указать :samp:`{имя-файла}.{имя-"
"функции}`."

msgid ""
"box.schema.func.create('easy.easy2', {language = 'C'})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'easy.easy2')\n"
"capi_connection:call('easy.easy2')"
msgstr ""
"box.schema.func.create('easy.easy2', {language = 'C'})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'easy.easy2')\n"
"capi_connection:call('easy.easy2')"

msgid "... and this time the result will be \"hello world -- easy2\"."
msgstr "... и на этот раз результатом будет: \"hello world -- easy2\"."

msgid "Conclusion: calling a C function is easy."
msgstr "Вывод: вызвать C-функцию легко."

#, fuzzy
msgid "harder.c"
msgstr "**harder.c**"

msgid "Go back to the shell where the ``easy.c`` program was created."
msgstr "Вернитесь в терминал, где была создана программа ``easy.c``."

msgid "Create a file. Name it ``harder.c``. Put these 17 lines in it:"
msgstr ""
"Создайте файл. Назовите его ``harder.c``. Запишите в него следующие 17 "
"строк:"

#, python-format
msgid ""
"#include \"module.h\"\n"
"#include \"msgpuck.h\"\n"
"int harder(box_function_ctx_t *ctx, const char *args, const char *args_end)\n"
"{\n"
"  uint32_t arg_count = mp_decode_array(&args);\n"
"  printf(\"arg_count = %d\\n\", arg_count);\n"
"  uint32_t field_count = mp_decode_array(&args);\n"
"  printf(\"field_count = %d\\n\", field_count);\n"
"  uint32_t val;\n"
"  int i;\n"
"  for (i = 0; i < field_count; ++i)\n"
"  {\n"
"    val = mp_decode_uint(&args);\n"
"    printf(\"val=%d.\\n\", val);\n"
"  }\n"
"  return 0;\n"
"}"
msgstr ""
"#include \"module.h\"\n"
"#include \"msgpuck.h\"\n"
"int harder(box_function_ctx_t *ctx, const char *args, const char *args_end)\n"
"{\n"
"  uint32_t arg_count = mp_decode_array(&args);\n"
"  printf(\"arg_count = %d\\n\", arg_count);\n"
"  uint32_t field_count = mp_decode_array(&args);\n"
"  printf(\"field_count = %d\\n\", field_count);\n"
"  uint32_t val;\n"
"  int i;\n"
"  for (i = 0; i < field_count; ++i)\n"
"  {\n"
"    val = mp_decode_uint(&args);\n"
"    printf(\"val=%d.\\n\", val);\n"
"  }\n"
"  return 0;\n"
"}"

msgid "Compile the program, producing a library file named ``harder.so``:"
msgstr ""
"Скомпилируйте программу, что создаст файл библиотеки под названием "
"``harder.so``:"

msgid "$ gcc -shared -o harder.so -fPIC harder.c"
msgstr "$ gcc -shared -o harder.so -fPIC harder.c"

msgid ""
"box.schema.func.create('harder', {language = 'C'})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'harder')\n"
"passable_table = {}\n"
"table.insert(passable_table, 1)\n"
"table.insert(passable_table, 2)\n"
"table.insert(passable_table, 3)\n"
"capi_connection:call('harder', {passable_table})"
msgstr ""

msgid ""
"This time the call is passing a Lua table (``passable_table``) to the "
"``harder()`` function. The ``harder()`` function will see it, it's in the "
":code:`char *args` parameter."
msgstr ""
"На этот раз вызов передает Lua-таблицу (``passable_table``) в функцию "
"``harder()``. Функция``harder()`` увидит это, как указано в параметре "
":code:`char *args`."

msgid ""
"At this point the ``harder()`` function will start using functions defined "
"in `msgpuck.h <https://github.com/tarantool/msgpuck>`_. The routines that "
"begin with \"mp\" are msgpuck functions that handle data formatted according"
" to the `MsgPack <http://msgpack.org/>`_ specification. Passes and returns "
"are always done with this format so one must become acquainted with msgpuck "
"to become proficient with the C API."
msgstr ""

msgid ""
"For now, though, it's enough to know that ``mp_decode_array()`` returns the "
"number of elements in an array, and ``mp_decode_uint`` returns an unsigned "
"integer, from :code:`args`. And there's a side effect: when the decoding "
"finishes, :code:`args` has changed and is now pointing to the next element."
msgstr ""
"Однако, пока достаточно понимать, что функция ``mp_decode_array()`` "
"возвращает количество элементов в массиве, а функция ``mp_decode_uint`` "
"возвращает целое число без знака из :code:`args`. Есть также побочный "
"эффект: по окончании декодирования :code:`args` изменился и теперь указывает"
" на следующий элемент."

msgid ""
"Therefore the first displayed line will be \"arg_count = 1\" because there "
"was only one item passed: ``passable_table``. |br| The second displayed line"
" will be \"field_count = 3\" because there are three items in the table. "
"|br| The next three lines will be \"1\" and \"2\" and \"3\" because those "
"are the values in the items in the table."
msgstr ""
"Таким образом, первой будет отображена строка \"arg_count = 1\", поскольку "
"был передан только один элемент: ``passable_table``. |br| Второй будет "
"отображена строка \"field_count = 3\", потому что в таблице находятся три "
"элемента. |br| Следующие три строки будут \"1\", \"2\" и \"3\", потому что "
"это значения элементов в таблице."

msgid "And now the screen looks like this:"
msgstr "Теперь вывод на экране выглядит следующим образом:"

msgid ""
"tarantool> capi_connection:call('harder', passable_table)\n"
"arg_count = 1\n"
"field_count = 3\n"
"val=1.\n"
"val=2.\n"
"val=3.\n"
"---\n"
"- []\n"
"..."
msgstr ""
"tarantool> capi_connection:call('harder', passable_table)\n"
"arg_count = 1\n"
"field_count = 3\n"
"val=1.\n"
"val=2.\n"
"val=3.\n"
"---\n"
"- []\n"
"..."

msgid ""
"Conclusion: decoding parameter values passed to a C function is not easy at "
"first, but there are routines to do the job, and they're documented, and "
"there aren't very many of them."
msgstr ""
"Вывод: на первый взгляд, декодирование значений параметров, переданных в "
"C-функцию непросто, но существуют документированные процедуры для этих "
"целей, и их не так много."

#, fuzzy
msgid "hardest.c"
msgstr "**hardest.c**"

msgid ""
"Go back to the shell where the ``easy.c`` and the ``harder.c`` programs were"
" created."
msgstr ""
"Вернитесь в терминал, где были созданы программы ``easy.c`` и ``harder.c``."

msgid "Create a file. Name it ``hardest.c``. Put these 13 lines in it:"
msgstr ""
"Создайте файл. Назовите его ```hardest.c``. Запишите в него следующие 13 "
"строк:"

msgid ""
"#include \"module.h\"\n"
"#include \"msgpuck.h\"\n"
"int hardest(box_function_ctx_t *ctx, const char *args, const char *args_end)\n"
"{\n"
"  uint32_t space_id = box_space_id_by_name(\"capi_test\", strlen(\"capi_test\"));\n"
"  char tuple[1024]; /* Must be big enough for mp_encode results */\n"
"  char *tuple_pointer = tuple;\n"
"  tuple_pointer = mp_encode_array(tuple_pointer, 2);\n"
"  tuple_pointer = mp_encode_uint(tuple_pointer, 10000);\n"
"  tuple_pointer = mp_encode_str(tuple_pointer, \"String 2\", 8);\n"
"  int n = box_insert(space_id, tuple, tuple_pointer, NULL);\n"
"  return n;\n"
"}"
msgstr ""
"#include \"module.h\"\n"
"#include \"msgpuck.h\"\n"
"int hardest(box_function_ctx_t *ctx, const char *args, const char *args_end)\n"
"{\n"
"  uint32_t space_id = box_space_id_by_name(\"capi_test\", strlen(\"capi_test\"));\n"
"  char tuple[1024]; /* Must be big enough for mp_encode results */\n"
"  char *tuple_pointer = tuple;\n"
"  tuple_pointer = mp_encode_array(tuple_pointer, 2);\n"
"  tuple_pointer = mp_encode_uint(tuple_pointer, 10000);\n"
"  tuple_pointer = mp_encode_str(tuple_pointer, \"String 2\", 8);\n"
"  int n = box_insert(space_id, tuple, tuple_pointer, NULL);\n"
"  return n;\n"
"}"

msgid "Compile the program, producing a library file named ``hardest.so``:"
msgstr ""
"Скомпилируйте программу, что создаст файл библиотеки под названием "
"``hardest.so``:"

msgid "$ gcc -shared -o hardest.so -fPIC hardest.c"
msgstr "$ gcc -shared -o hardest.so -fPIC hardest.c"

msgid ""
"box.schema.func.create('hardest', {language = \"C\"})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'hardest')\n"
"box.schema.user.grant('guest', 'read,write', 'space', 'capi_test')\n"
"capi_connection:call('hardest')"
msgstr ""
"box.schema.func.create('hardest', {language = \"C\"})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'hardest')\n"
"box.schema.user.grant('guest', 'read,write', 'space', 'capi_test')\n"
"capi_connection:call('hardest')"

msgid "This time the C function is doing three things:"
msgstr "На этот раз C-функция выполняет три действия:"

msgid ""
"finding the numeric identifier of the ``capi_test`` space by calling "
"``box_space_id_by_name()``;"
msgstr ""
"найдет числовой идентификатор спейса ``capi_test`` путем вызова "
"``box_space_id_by_name()``;"

msgid "formatting a tuple using more ``msgpuck.h`` functions;"
msgstr "форматирует кортеж, используя другие функции ``msgpuck.h``;"

msgid "inserting a tuple using ``box_insert()``."
msgstr "вставит кортеж с помощью ``box_insert()``."

msgid ""
"``char tuple[1024];`` is used here as just a quick way of saying \"allocate "
"more than enough bytes\". For serious programs the developer must be careful"
" to allow enough space for all the bytes that the ``mp_encode`` routines "
"will use up."
msgstr ""
"``char tuple[1024];`` используется здесь просто в качестве быстрого способа "
"ввода команды \"выделить байтов с запасом\". В серьезных программах "
"разработчику следует обратить внимание на то, чтобы выделить достаточно "
"места, которое будут использовать процедуры ``mp_encode``."

msgid "Now, still on the client, execute this request:"
msgstr "Затем всё еще в клиенте выполните следующий запрос:"

msgid "box.space.capi_test:select()"
msgstr "box.space.capi_test:select()"

msgid ""
"tarantool> box.space.capi_test:select()\n"
"---\n"
"- - [10000, 'String 2']\n"
"..."
msgstr ""
"tarantool> box.space.capi_test:select()\n"
"---\n"
"- - [10000, 'String 2']\n"
"..."

msgid ""
"This proves that the ``hardest()`` function succeeded, but where did "
":ref:`box_space_id_by_name() <box-box_space_id_by_name>` and "
":ref:`box_insert() <box-box_insert>` come from? Answer: the :ref:`C API "
"<index-c_api_reference>`."
msgstr ""
"Это доказывает, что функция ``hardest()`` была успешно выполнена, но откуда "
"взялись :ref:`box_space_id_by_name() <box-box_space_id_by_name>` и "
":ref:`box_insert() <box-box_insert>`? Ответ: :ref:`API для языка C <index-"
"c_api_reference>`."

#, fuzzy
msgid "read.c"
msgstr "**read.c**"

msgid ""
"Go back to the shell where the ``easy.c`` and the ``harder.c`` and the "
"``hardest.c`` programs were created."
msgstr ""
"Вернитесь в терминал, где были созданы программы ``easy.c``, ``harder.c`` и "
"``hardest.c``."

msgid "Create a file. Name it ``read.c``. Put these 43 lines in it:"
msgstr ""
"Создайте файл. Назовите его ``read.c``. Запишите в него следующие 43 строки:"

#, fuzzy, python-format
msgid ""
"#include \"module.h\"\n"
"#include <msgpuck.h>\n"
"int read(box_function_ctx_t *ctx, const char *args, const char *args_end)\n"
"{\n"
"  char tuple_buf[1024];      /* where the raw MsgPack tuple will be stored */\n"
"  uint32_t space_id = box_space_id_by_name(\"capi_test\", strlen(\"capi_test\"));\n"
"  uint32_t index_id = 0;     /* The number of the space's first index */\n"
"  uint32_t key = 10000;      /* The key value that box_insert() used */\n"
"  mp_encode_array(tuple_buf, 0); /* clear */\n"
"  box_tuple_format_t *fmt = box_tuple_format_default();\n"
"  box_tuple_t *tuple = NULL;\n"
"  char key_buf[16];          /* Pass key_buf = encoded key = 1000 */\n"
"  char *key_end = key_buf;\n"
"  key_end = mp_encode_array(key_end, 1);\n"
"  key_end = mp_encode_uint(key_end, key);\n"
"  assert(key_end <= key_buf + sizeof(key_buf));\n"
"  /* Get the tuple. There's no box_select() but there's this. */\n"
"  int r = box_index_get(space_id, index_id, key_buf, key_end, &tuple);\n"
"  assert(r == 0);\n"
"  assert(tuple != NULL);\n"
"  /* Get each field of the tuple + display what you get. */\n"
"  int field_no;             /* The first field number is 0. */\n"
"  for (field_no = 0; field_no < 2; ++field_no)\n"
"  {\n"
"    const char *field = box_tuple_field(tuple, field_no);\n"
"    assert(field != NULL);\n"
"    assert(mp_typeof(*field) == MP_STR || mp_typeof(*field) == MP_UINT);\n"
"    if (mp_typeof(*field) == MP_UINT)\n"
"    {\n"
"      uint32_t uint_value = mp_decode_uint(&field);\n"
"      printf(\"uint value=%u.\\n\", uint_value);\n"
"    }\n"
"    else /* if (mp_typeof(*field) == MP_STR) */\n"
"    {\n"
"      const char *str_value;\n"
"      uint32_t str_value_length;\n"
"      str_value = mp_decode_str(&field, &str_value_length);\n"
"      printf(\"string value=%.*s.\\n\", str_value_length, str_value);\n"
"    }\n"
"  }\n"
"  return 0;\n"
"}"
msgstr ""
"#include \"module.h\"\n"
"#include <msgpuck.h>\n"
"int read(box_function_ctx_t *ctx, const char *args, const char *args_end)\n"
"{\n"
"  char tuple_buf[1024];      /* здесь будет храниться тапл в сыром MsgPack-формате */\n"
"  uint32_t space_id = box_space_id_by_name(\"capi_test\", strlen(\"capi_test\"));\n"
"  uint32_t index_id = 0;     /* номер первого индекса спейса */\n"
"  uint32_t key = 10000;      /* значение ключа, используемое box_insert() */\n"
"  mp_encode_array(tuple_buf, 0); /* clear */\n"
"  box_tuple_format_t *fmt = box_tuple_format_default();\n"
"  box_tuple_t *tuple = box_tuple_new(fmt, tuple_buf, tuple_buf+512);\n"
"  assert(tuple != NULL);\n"
"  char key_buf[16];          /* передаем key_buf = закодированный ключ = 1000 */\n"
"  char *key_end = key_buf;\n"
"  key_end = mp_encode_array(key_end, 1);\n"
"  key_end = mp_encode_uint(key_end, key);\n"
"  assert(key_end < key_buf + sizeof(key_buf));\n"
"  /* Получить тапл. У нас нет box_select(), но есть вот это. */\n"
"  int r = box_index_get(space_id, index_id, key_buf, key_end, &tuple);\n"
"  assert(r == 0);\n"
"  assert(tuple != NULL);\n"
"  /* Получить каждое поле тапла + показать полученное значение */\n"
"  int field_no;             /* номер первого поля = 0 */\n"
"  for (field_no = 0; field_no < 2; ++field_no)\n"
"  {\n"
"    const char *field = box_tuple_field(tuple, field_no);\n"
"    assert(field != NULL);\n"
"    assert(mp_typeof(*field) == MP_STR || mp_typeof(*field) == MP_UINT);\n"
"    if (mp_typeof(*field) == MP_UINT)\n"
"    {\n"
"      uint32_t uint_value = mp_decode_uint(&field);\n"
"      printf(\"uint value=%u.\\n\", uint_value);\n"
"    }\n"
"    else /* если (mp_typeof(*field) == MP_STR) */\n"
"    {\n"
"      const char *str_value;\n"
"      uint32_t str_value_length;\n"
"      str_value = mp_decode_str(&field, &str_value_length);\n"
"      printf(\"string value=%.*s.\\n\", str_value_length, str_value);\n"
"    }\n"
"  }\n"
"  return 0;\n"
"}"

msgid "Compile the program, producing a library file named ``read.so``:"
msgstr ""
"Скомпилируйте программу, что создаст файл библиотеки под названием "
"``read.so``:"

msgid "$ gcc -shared -o read.so -fPIC read.c"
msgstr "$ gcc -shared -o read.so -fPIC read.c"

msgid ""
"box.schema.func.create('read', {language = \"C\"})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'read')\n"
"box.schema.user.grant('guest', 'read,write', 'space', 'capi_test')\n"
"capi_connection:call('read')"
msgstr ""
"box.schema.func.create('read', {language = \"C\"})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'read')\n"
"box.schema.user.grant('guest', 'read,write', 'space', 'capi_test')\n"
"capi_connection:call('read')"

msgid "This time the C function is doing four things:"
msgstr "На этот раз C-функция выполняет четыре действия:"

msgid ""
"once again, finding the numeric identifier of the ``capi_test`` space by "
"calling ``box_space_id_by_name()``;"
msgstr ""
"снова найдет числовой идентификатор спейса ``capi_test`` путем вызова "
"``box_space_id_by_name()``;"

msgid "formatting a search key = 10000 using more ``msgpuck.h`` functions;"
msgstr ""
"форматирует ключ поиска = 10 000, используя другие функции ``msgpuck.h``;"

msgid "getting a tuple using ``box_index_get()``;"
msgstr "получает кортеж с помощью ``box_index_get()``;"

msgid ""
"going through the tuple's fields with ``box_tuple_get()`` and then decoding "
"each field depending on its type. In this case, since what we are getting is"
" the tuple that we inserted with ``hardest.c``, we know in advance that the "
"type is either MP_UINT or MP_STR; however, it's very common to have a case "
"statement here with one option for each possible type."
msgstr ""
"проходит по полям каждого кортежа с помощью ``box_tuple_get()``. а затем "
"декодирует каждое поле в зависимости от его типа. В данном случае, поскольку"
" мы получаем кортеж, который сами вставили с помощью ``hardest.c``, мы знаем"
" заранее, что его тип будет MP_UINT или MP_STR. Однако, весьма часто здесь "
"употребляется оператор выбора case с одной опцией для каждого возможного "
"типа."

msgid "The result of ``capi_connection:call('read')`` should look like this:"
msgstr "В результате вызова ``capi_connection:call('read')`` должны получить:"

msgid ""
"tarantool> capi_connection:call('read')\n"
"uint value=10000.\n"
"string value=String 2.\n"
"---\n"
"- []\n"
"..."
msgstr ""
"tarantool> capi_connection:call('read')\n"
"uint value=10000.\n"
"string value=String 2.\n"
"---\n"
"- []\n"
"..."

msgid ""
"This proves that the ``read()`` function succeeded. Once again the important"
" functions that start with `box` -- :ref:`box_index_get() <c_api-box_index-"
"box_index_get>` and :ref:`box_tuple_field() <c_api-tuple-box_tuple_field>` "
"-- came from the :ref:`C API <index-c_api_reference>`."
msgstr ""
"Это доказывает, что функция ``read()`` была успешно выполнена. И снова "
"важные функции, которые начинаются с `box` -- :ref:`box_index_get() <c_api-"
"box_index-box_index_get>` и :ref:`box_tuple_field() <c_api-tuple-"
"box_tuple_field>` -- пришли из :ref:`API для языка C <index-"
"c_api_reference>`."

#, fuzzy
msgid "write.c"
msgstr "**write.c**"

msgid ""
"Go back to the shell where the programs ``easy.c``, ``harder.c``, "
"``hardest.c`` and ``read.c`` were created."
msgstr ""
"Вернитесь в терминал, где были созданы программы ``easy.c``, ``harder.c``, "
"``hardest.c`` и ``read.c``."

msgid "Create a file. Name it ``write.c``. Put these 24 lines in it:"
msgstr ""
"Создайте файл. Назовите его ``write.c``. Запишите в него следующие 24 "
"строки:"

#, python-format
msgid ""
"#include \"module.h\"\n"
"#include <msgpuck.h>\n"
"int write(box_function_ctx_t *ctx, const char *args, const char *args_end)\n"
"{\n"
"  static const char *space = \"capi_test\";\n"
"  char tuple_buf[1024]; /* Must be big enough for mp_encode results */\n"
"  uint32_t space_id = box_space_id_by_name(space, strlen(space));\n"
"  if (space_id == BOX_ID_NIL) {\n"
"    return box_error_set(__FILE__, __LINE__, ER_PROC_C,\n"
"    \"Can't find space %s\", \"capi_test\");\n"
"  }\n"
"  char *tuple_end = tuple_buf;\n"
"  tuple_end = mp_encode_array(tuple_end, 2);\n"
"  tuple_end = mp_encode_uint(tuple_end, 1);\n"
"  tuple_end = mp_encode_uint(tuple_end, 22);\n"
"  box_txn_begin();\n"
"  if (box_replace(space_id, tuple_buf, tuple_end, NULL) != 0)\n"
"    return -1;\n"
"  box_txn_commit();\n"
"  fiber_sleep(0.001);\n"
"  struct tuple *tuple = box_tuple_new(box_tuple_format_default(),\n"
"                                      tuple_buf, tuple_end);\n"
"  return box_return_tuple(ctx, tuple);\n"
"}"
msgstr ""
"#include \"module.h\"\n"
"#include <msgpuck.h>\n"
"int write(box_function_ctx_t *ctx, const char *args, const char *args_end)\n"
"{\n"
"  static const char *space = \"capi_test\";\n"
"  char tuple_buf[1024]; /* Должен быть достаточно большим, чтобы вместить результат mp_encode */\n"
"  uint32_t space_id = box_space_id_by_name(space, strlen(space));\n"
"  if (space_id == BOX_ID_NIL) {\n"
"    return box_error_set(__FILE__, __LINE__, ER_PROC_C,\n"
"    \"Can't find space %s\", \"capi_test\");\n"
"  }\n"
"  char *tuple_end = tuple_buf;\n"
"  tuple_end = mp_encode_array(tuple_end, 2);\n"
"  tuple_end = mp_encode_uint(tuple_end, 1);\n"
"  tuple_end = mp_encode_uint(tuple_end, 22);\n"
"  box_txn_begin();\n"
"  if (box_replace(space_id, tuple_buf, tuple_end, NULL) != 0)\n"
"    return -1;\n"
"  box_txn_commit();\n"
"  fiber_sleep(0.001);\n"
"  struct tuple *tuple = box_tuple_new(box_tuple_format_default(),\n"
"                                      tuple_buf, tuple_end);\n"
"  return box_return_tuple(ctx, tuple);\n"
"}"

msgid "Compile the program, producing a library file named ``write.so``:"
msgstr ""
"Скомпилируйте программу, что создаст файл библиотеки под названием "
"``write.so``:"

msgid "$ gcc -shared -o write.so -fPIC write.c"
msgstr "$ gcc -shared -o write.so -fPIC write.c"

msgid ""
"box.schema.func.create('write', {language = \"C\"})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'write')\n"
"box.schema.user.grant('guest', 'read,write', 'space', 'capi_test')\n"
"capi_connection:call('write')"
msgstr ""
"box.schema.func.create('write', {language = \"C\"})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'write')\n"
"box.schema.user.grant('guest', 'read,write', 'space', 'capi_test')\n"
"capi_connection:call('write')"

msgid "This time the C function is doing six things:"
msgstr "На этот раз C-функция выполняет шесть действий:"

msgid "making a new tuple;"
msgstr "создает новый кортеж;"

msgid "starting a transaction;"
msgstr "начинает транзакцию;"

msgid "replacing a tuple in ``box.space.capi_test``"
msgstr "заменяет кортеж в ``box.space.capi_test``"

msgid "ending a transaction;"
msgstr "заканчивает транзакцию;"

msgid ""
"the final line is a replacement for the loop in ``read.c`` -- instead of "
"getting each field and printing it, use the ``box_return_tuple(...)`` "
"function to return the entire tuple to the caller and let the caller display"
" it."
msgstr ""
"последняя строка заменяет цикл ``read.c`` -- вместо получения и вывода "
"каждого поля, использует функцию ``box_return_tuple(...)`` для возврата "
"всего кортежа вызывающему клиенту, чтобы вывести его на экран."

msgid "The result of ``capi_connection:call('write')`` should look like this:"
msgstr ""
"В результате вызова ``capi_connection:call('write')`` должны получить:"

msgid ""
"tarantool> capi_connection:call('write')\n"
"---\n"
"- [[1, 22]]\n"
"..."
msgstr ""
"tarantool> capi_connection:call('write')\n"
"---\n"
"- [[1, 22]]\n"
"..."

msgid ""
"This proves that the ``write()`` function succeeded. Once again the "
"important functions that start with `box` -- :ref:`box_txn_begin() <txn-"
"box_txn_begin>`, :ref:`box_txn_commit() <txn-box_txn_commit>` and "
":ref:`box_return_tuple() <box-box_return_tuple>` -- came from the :ref:`C "
"API <index-c_api_reference>`."
msgstr ""
"Это доказывает, что функция ``write()`` была успешно выполнена. И снова "
"важные функции, которые начинаются с `box` -- :ref:`box_txn_begin() <txn-"
"box_txn_begin>`, :ref:`box_txn_commit() <txn-box_txn_commit>` и "
":ref:`box_return_tuple() <box-box_return_tuple>` -- пришли из :ref:`API для "
"языка C <index-c_api_reference>`."

msgid ""
"Conclusion: the long description of the whole C API is there for a good "
"reason. All of the functions in it can be called from C functions which are "
"called from Lua. So C \"stored procedures\" have full access to the "
"database."
msgstr ""
"Вывод: длинное описание всего API для языка C необходимо в силу весомых "
"причин. Все функции можно вызвать из C-функций, которые вызываются из Lua. "
"Таким образом, хранимые процедуры на языке C получают полный доступ к базе "
"данных."

#, fuzzy
msgid "Cleaning up"
msgstr "**Очистка данных**"

msgid ""
"Get rid of each of the function tuples with "
":doc:`/reference/reference_lua/box_schema/func_drop`."
msgstr ""
"Удалите все кортежи с функцией с помощью "
":doc:`/reference/reference_lua/box_schema/func_drop`."

msgid ""
"Get rid of the ``capi_test`` space with :ref:`box.schema.capi_test:drop() "
"<box_space-drop>`."
msgstr ""
"Удалите спейс ``capi_test`` с помощью :ref:`box.schema.capi_test:drop() "
"<box_space-drop>`."

msgid ""
"Remove the ``.c`` and ``.so`` files that were created for this tutorial."
msgstr ""
"Удалите файлы с разрешением ``.c`` и ``.so``, созданные для данного "
"практического задания."

#, fuzzy
msgid "An example in the test suite"
msgstr "**Пример из набора тестов**"

msgid ""
"Download the source code of Tarantool. Look in a subdirectory "
":code:`test/box`. Notice that there is a file named "
":code:`tuple_bench.test.lua` and another file named :code:`tuple_bench.c`. "
"Examine the Lua file and observe that it is calling a function in the C "
"file, using the same techniques that this tutorial has shown."
msgstr ""
"Скачайте исходный код Tarantool. Откройте поддиректорию :code:`test/box`. "
"Проверьте наличие файла под названием :code:`tuple_bench.test.lua` и еще "
"одного файла под названием :code:`tuple_bench.c`. Изучите Lua-файл на "
"предмет вызова функции в C-файле с использованием методов, описанных в "
"данном практическом задании."

msgid ""
"Conclusion: parts of the standard test suite use C stored procedures, and "
"they must work, because releases don't happen if Tarantool doesn't pass the "
"tests."
msgstr ""
"Вывод: некоторые тесты из стандартного набора используют хранимые процедуры "
"на языке C, а они должны работать, поскольку мы не можем выпустить "
"Tarantool, если он не прошел тестирование."

#~ msgid ""
#~ "Here is one C tutorial: :ref:`C stored procedures <f_c_tutorial-"
#~ "c_stored_procedures>`."
#~ msgstr ""
#~ "Ниже приводится практическое занятие на языке C: :ref:`Хранимые процедуры на"
#~ " языке C <f_c_tutorial-c_stored_procedures>`."
